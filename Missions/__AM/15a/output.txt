// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 23411 0 0
// InitNature ;
  19: CALL 19922 0 0
// InitArtifact ;
  23: CALL 20539 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5136 0 0
// PrepareAlliance ;
  44: CALL 1460 0 0
// PrepareArabian ;
  48: CALL 7185 0 0
// PrepareRussian ;
  52: CALL 9502 0 0
// PrepareLegion ;
  56: CALL 7752 0 0
// Action ;
  60: CALL 12488 0 0
// MC_Start ( ) ;
  64: CALL 25591 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked , negotiationWithArabs , omarKilled ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// negotiationWithArabs := LoadVariable ( 13a_negotiationWithArabs , false ) ;
  96: LD_ADDR_EXP 19
 100: PUSH
 101: LD_STRING 13a_negotiationWithArabs
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// omarKilled := false ;
 112: LD_ADDR_EXP 20
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// russianDestroyed := false ;
 120: LD_ADDR_EXP 2
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// legionDestroyed := false ;
 128: LD_ADDR_EXP 3
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// americanDestroyed := false ;
 136: LD_ADDR_EXP 4
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// arabianDestroyed := false ;
 144: LD_ADDR_EXP 5
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// americanCapitulated := false ;
 152: LD_ADDR_EXP 6
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// russianCapitulated := false ;
 160: LD_ADDR_EXP 7
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// legionCapitulated := false ;
 168: LD_ADDR_EXP 8
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactIResearched := false ;
 176: LD_ADDR_EXP 12
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// artifactIIResearched := false ;
 184: LD_ADDR_EXP 13
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// artifactIIIResearched := false ;
 192: LD_ADDR_EXP 14
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// alienSpotted := false ;
 200: LD_ADDR_EXP 10
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// spawnOmar := false ;
 208: LD_ADDR_EXP 11
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 224: LD_ADDR_EXP 16
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// allianceTeam := [ ] ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// arabianAttacked := false ;
 239: LD_ADDR_EXP 18
 243: PUSH
 244: LD_INT 0
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 1
 251: RET
// export function CustomInitMacro ( ) ; begin
 252: LD_INT 0
 254: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 255: LD_ADDR_EXP 104
 259: PUSH
 260: LD_INT 26
 262: PUSH
 263: LD_INT 1
 265: PUSH
 266: LD_INT 4
 268: PUSH
 269: LD_INT 8
 271: PUSH
 272: EMPTY
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 278: LD_ADDR_EXP 105
 282: PUSH
 283: LD_INT 27
 285: PUSH
 286: LD_INT 2
 288: PUSH
 289: LD_INT 3
 291: PUSH
 292: LD_INT 7
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 6
 306: PUSH
 307: LD_INT 7
 309: PUSH
 310: LD_INT 9
 312: PUSH
 313: LD_INT 10
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_OWVAR 67
 326: ARRAY
 327: PPUSH
 328: LD_INT 28
 330: PPUSH
 331: CALL 47564 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 335: LD_INT 1
 337: PPUSH
 338: LD_INT 10
 340: PUSH
 341: LD_INT 11
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: LD_INT 15
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: PPUSH
 356: CALL 48647 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 29
 365: PUSH
 366: EMPTY
 367: LIST
 368: PPUSH
 369: CALL 48744 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 373: LD_ADDR_EXP 109
 377: PUSH
 378: LD_EXP 109
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: LD_INT 22
 388: PUSH
 389: LD_INT 2
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: PUSH
 396: LD_INT 25
 398: PUSH
 399: LD_INT 15
 401: PUSH
 402: EMPTY
 403: LIST
 404: LIST
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: PPUSH
 410: CALL_OW 69
 414: PPUSH
 415: CALL_OW 1
 419: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 420: LD_INT 1
 422: PPUSH
 423: LD_INT 13
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 1
 431: PUSH
 432: LD_INT 31
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: PUSH
 441: LD_INT 13
 443: PUSH
 444: LD_INT 2
 446: PUSH
 447: LD_INT 1
 449: PUSH
 450: LD_INT 31
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: PUSH
 459: LD_INT 13
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 1
 467: PUSH
 468: LD_INT 28
 470: PUSH
 471: EMPTY
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 13
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 1
 485: PUSH
 486: LD_INT 28
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: PUSH
 495: LD_INT 13
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 28
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 13
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: LD_INT 1
 521: PUSH
 522: LD_INT 28
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_INT 13
 533: PUSH
 534: LD_INT 1
 536: PUSH
 537: LD_INT 2
 539: PUSH
 540: LD_INT 88
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: LIST
 547: LIST
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL 47901 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 4
 567: PPUSH
 568: CALL 48086 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 572: LD_INT 2
 574: PPUSH
 575: LD_INT 10
 577: PUSH
 578: LD_INT 11
 580: PUSH
 581: LD_INT 12
 583: PUSH
 584: LD_INT 14
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PPUSH
 593: CALL 48647 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 597: LD_INT 2
 599: PPUSH
 600: LD_INT 14
 602: PUSH
 603: EMPTY
 604: LIST
 605: PPUSH
 606: CALL 48744 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 610: LD_INT 2
 612: PPUSH
 613: LD_INT 21
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 51
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 22
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 52
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_INT 24
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 3
 747: PUSH
 748: LD_INT 47
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PPUSH
 767: CALL 47901 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 771: LD_INT 2
 773: PPUSH
 774: LD_INT 5
 776: PPUSH
 777: CALL 48086 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 781: LD_INT 2
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL 48518 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 791: LD_INT 3
 793: PPUSH
 794: LD_INT 10
 796: PUSH
 797: LD_INT 12
 799: PUSH
 800: LD_INT 14
 802: PUSH
 803: LD_INT 15
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: PUSH
 812: LD_OWVAR 67
 816: ARRAY
 817: PPUSH
 818: LD_INT 24
 820: PPUSH
 821: CALL 47564 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 825: LD_INT 3
 827: PPUSH
 828: LD_INT 10
 830: PUSH
 831: LD_INT 11
 833: PUSH
 834: LD_INT 13
 836: PUSH
 837: LD_INT 15
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PPUSH
 846: CALL 48647 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 850: LD_INT 3
 852: PPUSH
 853: LD_INT 13
 855: PUSH
 856: EMPTY
 857: LIST
 858: PPUSH
 859: CALL 48744 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 863: LD_ADDR_EXP 109
 867: PUSH
 868: LD_EXP 109
 872: PPUSH
 873: LD_INT 3
 875: PPUSH
 876: LD_INT 22
 878: PUSH
 879: LD_INT 8
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 25
 888: PUSH
 889: LD_INT 15
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PPUSH
 900: CALL_OW 69
 904: PPUSH
 905: CALL_OW 1
 909: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 910: LD_INT 3
 912: PPUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 2
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 31
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 13
 951: PUSH
 952: LD_INT 3
 954: PUSH
 955: LD_INT 2
 957: PUSH
 958: LD_INT 32
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 28
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PUSH
1039: LD_INT 14
1041: PUSH
1042: LD_INT 1
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 88
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: LIST
1066: PPUSH
1067: CALL 47901 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1071: LD_INT 3
1073: PPUSH
1074: LD_INT 4
1076: PPUSH
1077: CALL 48086 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 10
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 11
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 48647 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 33
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 48744 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 6
1127: PUSH
1128: LD_INT 7
1130: PUSH
1131: LD_INT 9
1133: PUSH
1134: LD_INT 10
1136: PUSH
1137: EMPTY
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 49074 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1148: LD_INT 4
1150: PPUSH
1151: LD_INT 54
1153: PPUSH
1154: LD_INT 85
1156: PPUSH
1157: LD_INT 2
1159: PPUSH
1160: LD_INT 25
1162: PUSH
1163: LD_INT 16
1165: PUSH
1166: LD_INT 17
1168: PUSH
1169: LD_INT 18
1171: PUSH
1172: LD_INT 22
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 48864 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 5
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 1
1197: PUSH
1198: LD_INT 7
1200: PUSH
1201: EMPTY
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 1
1215: PUSH
1216: LD_INT 6
1218: PUSH
1219: EMPTY
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: PUSH
1225: LD_INT 5
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 1
1233: PUSH
1234: LD_INT 7
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: LD_INT 1
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: LD_INT 6
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: LD_INT 1
1266: PUSH
1267: LD_INT 3
1269: PUSH
1270: LD_INT 12
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: PUSH
1279: LD_INT 3
1281: PUSH
1282: LD_INT 1
1284: PUSH
1285: LD_INT 3
1287: PUSH
1288: LD_INT 13
1290: PUSH
1291: EMPTY
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: LIST
1304: PPUSH
1305: CALL 47901 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1309: LD_INT 4
1311: PPUSH
1312: LD_INT 4
1314: PPUSH
1315: CALL 48086 0 2
// MC_SetTame ( 4 , powellApe ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 11
1324: PPUSH
1325: CALL 48467 0 2
// end ;
1329: LD_VAR 0 1
1333: RET
// every 0 0$1 trigger debug do var i ;
1334: LD_EXP 1
1338: IFFALSE 1436
1340: GO 1342
1342: DISABLE
1343: LD_INT 0
1345: PPUSH
// begin enable ;
1346: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1347: LD_ADDR_VAR 0 1
1351: PUSH
1352: LD_INT 22
1354: PUSH
1355: LD_INT 7
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: LD_INT 21
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: PUSH
1375: LD_INT 21
1377: PUSH
1378: LD_INT 2
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 3
1392: PUSH
1393: LD_INT 24
1395: PUSH
1396: LD_INT 1000
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PPUSH
1412: CALL_OW 69
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1434
// SetLives ( i , 1000 ) ;
1420: LD_VAR 0 1
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 234
1432: GO 1417
1434: POP
1435: POP
// end ;
1436: PPOPN 1
1438: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1439: LD_EXP 16
1443: PUSH
1444: LD_INT 5
1446: GREATEREQUAL
1447: IFFALSE 1459
1449: GO 1451
1451: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1452: LD_STRING ACH_ARTIFACT
1454: PPUSH
1455: CALL_OW 543
1459: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1460: LD_INT 0
1462: PPUSH
1463: PPUSH
1464: PPUSH
1465: PPUSH
1466: PPUSH
// SetInvulnrability ( alien , true ) ;
1467: LD_INT 1
1469: PPUSH
1470: LD_INT 1
1472: PPUSH
1473: CALL_OW 607
// uc_side := 7 ;
1477: LD_ADDR_OWVAR 20
1481: PUSH
1482: LD_INT 7
1484: ST_TO_ADDR
// tmp := [ ] ;
1485: LD_ADDR_VAR 0 5
1489: PUSH
1490: EMPTY
1491: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1492: LD_ADDR_EXP 21
1496: PUSH
1497: LD_STRING JMM
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: LD_STRING 14a_
1508: PPUSH
1509: CALL 54473 0 3
1513: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1514: LD_ADDR_EXP 54
1518: PUSH
1519: LD_STRING Burlak
1521: PPUSH
1522: LD_EXP 1
1526: NOT
1527: PPUSH
1528: LD_STRING 14a_
1530: PPUSH
1531: CALL 54473 0 3
1535: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1536: LD_ADDR_EXP 36
1540: PUSH
1541: LD_STRING Joan
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 13a_
1552: PPUSH
1553: CALL 54473 0 3
1557: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1558: LD_ADDR_EXP 22
1562: PUSH
1563: LD_STRING Roth
1565: PPUSH
1566: LD_EXP 1
1570: NOT
1571: PPUSH
1572: LD_STRING 13a_
1574: PPUSH
1575: CALL 54473 0 3
1579: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1580: LD_ADDR_EXP 40
1584: PUSH
1585: LD_STRING Gossudarov
1587: PPUSH
1588: LD_EXP 1
1592: NOT
1593: PPUSH
1594: LD_STRING 13a_
1596: PPUSH
1597: CALL 54473 0 3
1601: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1602: LD_ADDR_EXP 27
1606: PUSH
1607: LD_STRING Denis
1609: PPUSH
1610: LD_EXP 1
1614: NOT
1615: PPUSH
1616: LD_STRING 13a_
1618: PPUSH
1619: CALL 54473 0 3
1623: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1624: LD_ADDR_EXP 37
1628: PUSH
1629: LD_STRING DeltaDoctor
1631: PPUSH
1632: LD_EXP 1
1636: NOT
1637: PPUSH
1638: LD_STRING 13a_
1640: PPUSH
1641: CALL 54473 0 3
1645: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1646: LD_ADDR_EXP 39
1650: PUSH
1651: LD_STRING Mike
1653: PPUSH
1654: LD_EXP 1
1658: NOT
1659: PPUSH
1660: LD_STRING 13a_
1662: PPUSH
1663: CALL 54473 0 3
1667: ST_TO_ADDR
// if DeltaDoctor then
1668: LD_EXP 37
1672: IFFALSE 1690
// tmp := tmp ^ DeltaDoctor ;
1674: LD_ADDR_VAR 0 5
1678: PUSH
1679: LD_VAR 0 5
1683: PUSH
1684: LD_EXP 37
1688: ADD
1689: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1690: LD_ADDR_EXP 35
1694: PUSH
1695: LD_STRING Simms
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 13a_
1706: PPUSH
1707: CALL 54473 0 3
1711: ST_TO_ADDR
// if Simms then
1712: LD_EXP 35
1716: IFFALSE 1734
// tmp := tmp ^ Simms ;
1718: LD_ADDR_VAR 0 5
1722: PUSH
1723: LD_VAR 0 5
1727: PUSH
1728: LD_EXP 35
1732: ADD
1733: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1734: LD_ADDR_EXP 33
1738: PUSH
1739: LD_STRING Frank
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 13a_
1750: PPUSH
1751: CALL 54473 0 3
1755: ST_TO_ADDR
// if Frank then
1756: LD_EXP 33
1760: IFFALSE 1778
// tmp := tmp ^ Frank ;
1762: LD_ADDR_VAR 0 5
1766: PUSH
1767: LD_VAR 0 5
1771: PUSH
1772: LD_EXP 33
1776: ADD
1777: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1778: LD_ADDR_EXP 41
1782: PUSH
1783: LD_STRING Kirilenkova
1785: PPUSH
1786: LD_EXP 1
1790: NOT
1791: PPUSH
1792: LD_STRING 13a_
1794: PPUSH
1795: CALL 54473 0 3
1799: ST_TO_ADDR
// if Kirilenkova then
1800: LD_EXP 41
1804: IFFALSE 1822
// tmp := tmp ^ Kirilenkova ;
1806: LD_ADDR_VAR 0 5
1810: PUSH
1811: LD_VAR 0 5
1815: PUSH
1816: LD_EXP 41
1820: ADD
1821: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1822: LD_ADDR_EXP 42
1826: PUSH
1827: LD_STRING Titov
1829: PPUSH
1830: LD_EXP 1
1834: NOT
1835: PPUSH
1836: LD_STRING 13a_
1838: PPUSH
1839: CALL 54473 0 3
1843: ST_TO_ADDR
// if Titov then
1844: LD_EXP 42
1848: IFFALSE 1866
// tmp := tmp ^ Titov ;
1850: LD_ADDR_VAR 0 5
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 42
1864: ADD
1865: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1866: LD_ADDR_EXP 43
1870: PUSH
1871: LD_STRING Fadeev
1873: PPUSH
1874: LD_EXP 1
1878: NOT
1879: PPUSH
1880: LD_STRING 13a_
1882: PPUSH
1883: CALL 54473 0 3
1887: ST_TO_ADDR
// if Fadeev then
1888: LD_EXP 43
1892: IFFALSE 1910
// tmp := tmp ^ Fadeev ;
1894: LD_ADDR_VAR 0 5
1898: PUSH
1899: LD_VAR 0 5
1903: PUSH
1904: LD_EXP 43
1908: ADD
1909: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1910: LD_ADDR_EXP 44
1914: PUSH
1915: LD_STRING Dolgov
1917: PPUSH
1918: LD_EXP 1
1922: NOT
1923: PPUSH
1924: LD_STRING 13a_
1926: PPUSH
1927: CALL 54473 0 3
1931: ST_TO_ADDR
// if Dolgov then
1932: LD_EXP 44
1936: IFFALSE 1954
// tmp := tmp ^ Dolgov ;
1938: LD_ADDR_VAR 0 5
1942: PUSH
1943: LD_VAR 0 5
1947: PUSH
1948: LD_EXP 44
1952: ADD
1953: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1954: LD_ADDR_EXP 45
1958: PUSH
1959: LD_STRING Petrosyan
1961: PPUSH
1962: LD_EXP 1
1966: NOT
1967: PPUSH
1968: LD_STRING 13a_
1970: PPUSH
1971: CALL 54473 0 3
1975: ST_TO_ADDR
// if Petrosyan then
1976: LD_EXP 45
1980: IFFALSE 1998
// tmp := tmp ^ Petrosyan ;
1982: LD_ADDR_VAR 0 5
1986: PUSH
1987: LD_VAR 0 5
1991: PUSH
1992: LD_EXP 45
1996: ADD
1997: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1998: LD_ADDR_EXP 46
2002: PUSH
2003: LD_STRING Scholtze
2005: PPUSH
2006: LD_EXP 1
2010: NOT
2011: PPUSH
2012: LD_STRING 13a_
2014: PPUSH
2015: CALL 54473 0 3
2019: ST_TO_ADDR
// if Scholtze then
2020: LD_EXP 46
2024: IFFALSE 2042
// tmp := tmp ^ Scholtze ;
2026: LD_ADDR_VAR 0 5
2030: PUSH
2031: LD_VAR 0 5
2035: PUSH
2036: LD_EXP 46
2040: ADD
2041: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2042: LD_ADDR_EXP 47
2046: PUSH
2047: LD_STRING Oblukov
2049: PPUSH
2050: LD_EXP 1
2054: NOT
2055: PPUSH
2056: LD_STRING 13a_
2058: PPUSH
2059: CALL 54473 0 3
2063: ST_TO_ADDR
// if Oblukov then
2064: LD_EXP 47
2068: IFFALSE 2086
// tmp := tmp ^ Oblukov ;
2070: LD_ADDR_VAR 0 5
2074: PUSH
2075: LD_VAR 0 5
2079: PUSH
2080: LD_EXP 47
2084: ADD
2085: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2086: LD_ADDR_EXP 48
2090: PUSH
2091: LD_STRING Kapitsova
2093: PPUSH
2094: LD_EXP 1
2098: NOT
2099: PPUSH
2100: LD_STRING 13a_
2102: PPUSH
2103: CALL 54473 0 3
2107: ST_TO_ADDR
// if Kapitsova then
2108: LD_EXP 48
2112: IFFALSE 2130
// tmp := tmp ^ Kapitsova ;
2114: LD_ADDR_VAR 0 5
2118: PUSH
2119: LD_VAR 0 5
2123: PUSH
2124: LD_EXP 48
2128: ADD
2129: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2130: LD_ADDR_EXP 49
2134: PUSH
2135: LD_STRING Lipshchin
2137: PPUSH
2138: LD_EXP 1
2142: NOT
2143: PPUSH
2144: LD_STRING 13a_
2146: PPUSH
2147: CALL 54473 0 3
2151: ST_TO_ADDR
// if Lipshchin then
2152: LD_EXP 49
2156: IFFALSE 2174
// tmp := tmp ^ Lipshchin ;
2158: LD_ADDR_VAR 0 5
2162: PUSH
2163: LD_VAR 0 5
2167: PUSH
2168: LD_EXP 49
2172: ADD
2173: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2174: LD_ADDR_EXP 50
2178: PUSH
2179: LD_STRING Petrovova
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13a_
2190: PPUSH
2191: CALL 54473 0 3
2195: ST_TO_ADDR
// if Petrovova then
2196: LD_EXP 50
2200: IFFALSE 2218
// tmp := tmp ^ Petrovova ;
2202: LD_ADDR_VAR 0 5
2206: PUSH
2207: LD_VAR 0 5
2211: PUSH
2212: LD_EXP 50
2216: ADD
2217: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2218: LD_ADDR_EXP 51
2222: PUSH
2223: LD_STRING Kovalyuk
2225: PPUSH
2226: LD_EXP 1
2230: NOT
2231: PPUSH
2232: LD_STRING 13a_
2234: PPUSH
2235: CALL 54473 0 3
2239: ST_TO_ADDR
// if Kovalyuk then
2240: LD_EXP 51
2244: IFFALSE 2262
// tmp := tmp ^ Kovalyuk ;
2246: LD_ADDR_VAR 0 5
2250: PUSH
2251: LD_VAR 0 5
2255: PUSH
2256: LD_EXP 51
2260: ADD
2261: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2262: LD_ADDR_EXP 52
2266: PUSH
2267: LD_STRING Kuzmov
2269: PPUSH
2270: LD_EXP 1
2274: NOT
2275: PPUSH
2276: LD_STRING 13a_
2278: PPUSH
2279: CALL 54473 0 3
2283: ST_TO_ADDR
// if Kuzmov then
2284: LD_EXP 52
2288: IFFALSE 2306
// tmp := tmp ^ Kuzmov ;
2290: LD_ADDR_VAR 0 5
2294: PUSH
2295: LD_VAR 0 5
2299: PUSH
2300: LD_EXP 52
2304: ADD
2305: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 53
2310: PUSH
2311: LD_STRING Karamazov
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 54473 0 3
2327: ST_TO_ADDR
// if Karamazov then
2328: LD_EXP 53
2332: IFFALSE 2350
// tmp := tmp ^ Karamazov ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 53
2348: ADD
2349: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2350: LD_ADDR_EXP 55
2354: PUSH
2355: LD_STRING Belkov
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13a_
2366: PPUSH
2367: CALL 54473 0 3
2371: ST_TO_ADDR
// if Belkov then
2372: LD_EXP 55
2376: IFFALSE 2394
// tmp := tmp ^ Belkov ;
2378: LD_ADDR_VAR 0 5
2382: PUSH
2383: LD_VAR 0 5
2387: PUSH
2388: LD_EXP 55
2392: ADD
2393: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2394: LD_ADDR_EXP 56
2398: PUSH
2399: LD_STRING Gnyevko
2401: PPUSH
2402: LD_EXP 1
2406: NOT
2407: PPUSH
2408: LD_STRING 13a_
2410: PPUSH
2411: CALL 54473 0 3
2415: ST_TO_ADDR
// if Gnyevko then
2416: LD_EXP 56
2420: IFFALSE 2438
// tmp := tmp ^ Gnyevko ;
2422: LD_ADDR_VAR 0 5
2426: PUSH
2427: LD_VAR 0 5
2431: PUSH
2432: LD_EXP 56
2436: ADD
2437: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING Coonie
2445: PPUSH
2446: CALL_OW 25
2450: ST_TO_ADDR
// if not Lisa then
2451: LD_EXP 23
2455: NOT
2456: IFFALSE 2502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2458: LD_ADDR_EXP 23
2462: PUSH
2463: LD_STRING Lisa
2465: PPUSH
2466: LD_EXP 1
2470: NOT
2471: PPUSH
2472: LD_STRING 13a_
2474: PPUSH
2475: CALL 54473 0 3
2479: ST_TO_ADDR
// if Lisa then
2480: LD_EXP 23
2484: IFFALSE 2502
// tmp := tmp ^ Lisa ;
2486: LD_ADDR_VAR 0 5
2490: PUSH
2491: LD_VAR 0 5
2495: PUSH
2496: LD_EXP 23
2500: ADD
2501: ST_TO_ADDR
// end ; if not Donaldson then
2502: LD_EXP 24
2506: NOT
2507: IFFALSE 2553
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2509: LD_ADDR_EXP 24
2513: PUSH
2514: LD_STRING Donaldson
2516: PPUSH
2517: LD_EXP 1
2521: NOT
2522: PPUSH
2523: LD_STRING 13a_
2525: PPUSH
2526: CALL 54473 0 3
2530: ST_TO_ADDR
// if Donaldson then
2531: LD_EXP 24
2535: IFFALSE 2553
// tmp := tmp ^ Donaldson ;
2537: LD_ADDR_VAR 0 5
2541: PUSH
2542: LD_VAR 0 5
2546: PUSH
2547: LD_EXP 24
2551: ADD
2552: ST_TO_ADDR
// end ; if not Bobby then
2553: LD_EXP 25
2557: NOT
2558: IFFALSE 2604
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2560: LD_ADDR_EXP 25
2564: PUSH
2565: LD_STRING Bobby
2567: PPUSH
2568: LD_EXP 1
2572: NOT
2573: PPUSH
2574: LD_STRING 13a_
2576: PPUSH
2577: CALL 54473 0 3
2581: ST_TO_ADDR
// if Bobby then
2582: LD_EXP 25
2586: IFFALSE 2604
// tmp := tmp ^ Bobby ;
2588: LD_ADDR_VAR 0 5
2592: PUSH
2593: LD_VAR 0 5
2597: PUSH
2598: LD_EXP 25
2602: ADD
2603: ST_TO_ADDR
// end ; if not Cyrus then
2604: LD_EXP 26
2608: NOT
2609: IFFALSE 2655
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2611: LD_ADDR_EXP 26
2615: PUSH
2616: LD_STRING Cyrus
2618: PPUSH
2619: LD_EXP 1
2623: NOT
2624: PPUSH
2625: LD_STRING 13a_
2627: PPUSH
2628: CALL 54473 0 3
2632: ST_TO_ADDR
// if Cyrus then
2633: LD_EXP 26
2637: IFFALSE 2655
// tmp := tmp ^ Cyrus ;
2639: LD_ADDR_VAR 0 5
2643: PUSH
2644: LD_VAR 0 5
2648: PUSH
2649: LD_EXP 26
2653: ADD
2654: ST_TO_ADDR
// end ; if not Brown then
2655: LD_EXP 28
2659: NOT
2660: IFFALSE 2706
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2662: LD_ADDR_EXP 28
2666: PUSH
2667: LD_STRING Brown
2669: PPUSH
2670: LD_EXP 1
2674: NOT
2675: PPUSH
2676: LD_STRING 13a_
2678: PPUSH
2679: CALL 54473 0 3
2683: ST_TO_ADDR
// if Brown then
2684: LD_EXP 28
2688: IFFALSE 2706
// tmp := tmp ^ Brown ;
2690: LD_ADDR_VAR 0 5
2694: PUSH
2695: LD_VAR 0 5
2699: PUSH
2700: LD_EXP 28
2704: ADD
2705: ST_TO_ADDR
// end ; if not Gladstone then
2706: LD_EXP 29
2710: NOT
2711: IFFALSE 2757
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2713: LD_ADDR_EXP 29
2717: PUSH
2718: LD_STRING Gladstone
2720: PPUSH
2721: LD_EXP 1
2725: NOT
2726: PPUSH
2727: LD_STRING 13a_
2729: PPUSH
2730: CALL 54473 0 3
2734: ST_TO_ADDR
// if Gladstone then
2735: LD_EXP 29
2739: IFFALSE 2757
// tmp := tmp ^ Gladstone ;
2741: LD_ADDR_VAR 0 5
2745: PUSH
2746: LD_VAR 0 5
2750: PUSH
2751: LD_EXP 29
2755: ADD
2756: ST_TO_ADDR
// end ; if not Cornel then
2757: LD_EXP 31
2761: NOT
2762: IFFALSE 2808
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2764: LD_ADDR_EXP 31
2768: PUSH
2769: LD_STRING Cornel
2771: PPUSH
2772: LD_EXP 1
2776: NOT
2777: PPUSH
2778: LD_STRING 13a_
2780: PPUSH
2781: CALL 54473 0 3
2785: ST_TO_ADDR
// if Cornel then
2786: LD_EXP 31
2790: IFFALSE 2808
// tmp := tmp ^ Cornel ;
2792: LD_ADDR_VAR 0 5
2796: PUSH
2797: LD_VAR 0 5
2801: PUSH
2802: LD_EXP 31
2806: ADD
2807: ST_TO_ADDR
// end ; if not Houten then
2808: LD_EXP 30
2812: NOT
2813: IFFALSE 2859
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2815: LD_ADDR_EXP 30
2819: PUSH
2820: LD_STRING Houten
2822: PPUSH
2823: LD_EXP 1
2827: NOT
2828: PPUSH
2829: LD_STRING 13a_
2831: PPUSH
2832: CALL 54473 0 3
2836: ST_TO_ADDR
// if Houten then
2837: LD_EXP 30
2841: IFFALSE 2859
// tmp := tmp ^ Houten ;
2843: LD_ADDR_VAR 0 5
2847: PUSH
2848: LD_VAR 0 5
2852: PUSH
2853: LD_EXP 30
2857: ADD
2858: ST_TO_ADDR
// end ; if not Gary then
2859: LD_EXP 32
2863: NOT
2864: IFFALSE 2910
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2866: LD_ADDR_EXP 32
2870: PUSH
2871: LD_STRING Gary
2873: PPUSH
2874: LD_EXP 1
2878: NOT
2879: PPUSH
2880: LD_STRING 13a_
2882: PPUSH
2883: CALL 54473 0 3
2887: ST_TO_ADDR
// if Gary then
2888: LD_EXP 32
2892: IFFALSE 2910
// tmp := tmp ^ Gary ;
2894: LD_ADDR_VAR 0 5
2898: PUSH
2899: LD_VAR 0 5
2903: PUSH
2904: LD_EXP 32
2908: ADD
2909: ST_TO_ADDR
// end ; if not Kikuchi then
2910: LD_EXP 34
2914: NOT
2915: IFFALSE 2961
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2917: LD_ADDR_EXP 34
2921: PUSH
2922: LD_STRING Kikuchi
2924: PPUSH
2925: LD_EXP 1
2929: NOT
2930: PPUSH
2931: LD_STRING 13a_
2933: PPUSH
2934: CALL 54473 0 3
2938: ST_TO_ADDR
// if Kikuchi then
2939: LD_EXP 34
2943: IFFALSE 2961
// tmp := tmp ^ Kikuchi ;
2945: LD_ADDR_VAR 0 5
2949: PUSH
2950: LD_VAR 0 5
2954: PUSH
2955: LD_EXP 34
2959: ADD
2960: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2961: LD_ADDR_VAR 0 5
2965: PUSH
2966: LD_VAR 0 5
2970: PUSH
2971: LD_STRING 13a_others
2973: PPUSH
2974: CALL_OW 31
2978: UNION
2979: ST_TO_ADDR
// tmp := tmp diff 0 ;
2980: LD_ADDR_VAR 0 5
2984: PUSH
2985: LD_VAR 0 5
2989: PUSH
2990: LD_INT 0
2992: DIFF
2993: ST_TO_ADDR
// if tmp < 15 then
2994: LD_VAR 0 5
2998: PUSH
2999: LD_INT 15
3001: LESS
3002: IFFALSE 3090
// for i = 15 downto tmp do
3004: LD_ADDR_VAR 0 2
3008: PUSH
3009: DOUBLE
3010: LD_INT 15
3012: INC
3013: ST_TO_ADDR
3014: LD_VAR 0 5
3018: PUSH
3019: FOR_DOWNTO
3020: IFFALSE 3088
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 1
3039: PPUSH
3040: LD_INT 2
3042: PPUSH
3043: CALL_OW 12
3047: ARRAY
3048: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3049: LD_INT 0
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: LD_INT 4
3057: PPUSH
3058: CALL_OW 12
3062: PPUSH
3063: LD_INT 8
3065: PPUSH
3066: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3070: LD_ADDR_VAR 0 5
3074: PUSH
3075: LD_VAR 0 5
3079: PUSH
3080: CALL_OW 44
3084: ADD
3085: ST_TO_ADDR
// end ;
3086: GO 3019
3088: POP
3089: POP
// if not debug then
3090: LD_EXP 1
3094: NOT
3095: IFFALSE 3275
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3097: LD_ADDR_VAR 0 4
3101: PUSH
3102: LD_STRING 
3104: PPUSH
3105: LD_INT 14
3107: PUSH
3108: LD_INT 13
3110: PUSH
3111: LD_INT 12
3113: PUSH
3114: LD_INT 11
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_OWVAR 67
3127: ARRAY
3128: PPUSH
3129: LD_INT 14
3131: PUSH
3132: LD_INT 13
3134: PUSH
3135: LD_INT 12
3137: PUSH
3138: LD_INT 11
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: PUSH
3147: LD_OWVAR 67
3151: ARRAY
3152: PPUSH
3153: LD_INT -5
3155: PUSH
3156: LD_EXP 21
3160: PUSH
3161: LD_EXP 54
3165: PUSH
3166: LD_EXP 22
3170: PUSH
3171: LD_EXP 36
3175: PUSH
3176: LD_EXP 27
3180: PUSH
3181: LD_EXP 40
3185: PUSH
3186: LD_INT -2
3188: PUSH
3189: LD_INT -3
3191: PUSH
3192: LD_INT -5
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: PUSH
3207: LD_VAR 0 5
3211: ADD
3212: PPUSH
3213: LD_INT 1
3215: PUSH
3216: LD_INT 4
3218: PUSH
3219: LD_INT 2
3221: PUSH
3222: LD_INT 1
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 5
3234: PUSH
3235: LD_INT 0
3237: PUSH
3238: LD_INT 3
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: PUSH
3246: LD_INT 9
3248: PUSH
3249: LD_INT 0
3251: PUSH
3252: LD_INT 3
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: PPUSH
3268: CALL_OW 42
3272: ST_TO_ADDR
3273: GO 3324
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_EXP 42
3284: PUSH
3285: LD_EXP 43
3289: PUSH
3290: LD_EXP 44
3294: PUSH
3295: LD_EXP 45
3299: PUSH
3300: LD_EXP 46
3304: PUSH
3305: LD_EXP 47
3309: PUSH
3310: LD_EXP 48
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: LIST
3319: LIST
3320: LIST
3321: LIST
3322: LIST
3323: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3324: LD_ADDR_EXP 17
3328: PUSH
3329: LD_VAR 0 5
3333: PUSH
3334: LD_VAR 0 4
3338: DIFF
3339: ST_TO_ADDR
// uc_nation := 1 ;
3340: LD_ADDR_OWVAR 21
3344: PUSH
3345: LD_INT 1
3347: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3348: LD_INT 5
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 1
3356: PPUSH
3357: LD_INT 6
3359: PPUSH
3360: LD_INT 100
3362: PPUSH
3363: CALL 59493 0 5
// veh := CreateVehicle ;
3367: LD_ADDR_VAR 0 3
3371: PUSH
3372: CALL_OW 45
3376: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3377: LD_VAR 0 3
3381: PPUSH
3382: LD_INT 7
3384: NEG
3385: PPUSH
3386: CALL_OW 242
// SetDir ( veh , 3 ) ;
3390: LD_VAR 0 3
3394: PPUSH
3395: LD_INT 3
3397: PPUSH
3398: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3402: LD_VAR 0 3
3406: PPUSH
3407: LD_INT 31
3409: PPUSH
3410: LD_INT 0
3412: PPUSH
3413: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3417: LD_EXP 21
3421: PPUSH
3422: LD_VAR 0 3
3426: PPUSH
3427: CALL_OW 52
// if Joan then
3431: LD_EXP 36
3435: IFFALSE 3507
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 3
3442: PPUSH
3443: LD_INT 1
3445: PPUSH
3446: LD_INT 11
3448: PPUSH
3449: LD_INT 100
3451: PPUSH
3452: CALL 59493 0 5
// veh := CreateVehicle ;
3456: LD_ADDR_VAR 0 3
3460: PUSH
3461: CALL_OW 45
3465: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3466: LD_VAR 0 3
3470: PPUSH
3471: LD_INT 3
3473: PPUSH
3474: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3478: LD_VAR 0 3
3482: PPUSH
3483: LD_INT 30
3485: PPUSH
3486: LD_INT 0
3488: PPUSH
3489: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3493: LD_EXP 36
3497: PPUSH
3498: LD_VAR 0 3
3502: PPUSH
3503: CALL_OW 52
// end ; if Roth then
3507: LD_EXP 22
3511: IFFALSE 3583
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 1
3521: PPUSH
3522: LD_INT 11
3524: PPUSH
3525: LD_INT 100
3527: PPUSH
3528: CALL 59493 0 5
// veh := CreateVehicle ;
3532: LD_ADDR_VAR 0 3
3536: PUSH
3537: CALL_OW 45
3541: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3542: LD_VAR 0 3
3546: PPUSH
3547: LD_INT 3
3549: PPUSH
3550: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3554: LD_VAR 0 3
3558: PPUSH
3559: LD_INT 30
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3569: LD_EXP 22
3573: PPUSH
3574: LD_VAR 0 3
3578: PPUSH
3579: CALL_OW 52
// end ; if Denis then
3583: LD_EXP 27
3587: IFFALSE 3659
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3589: LD_INT 5
3591: PPUSH
3592: LD_INT 3
3594: PPUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 9
3600: PPUSH
3601: LD_INT 100
3603: PPUSH
3604: CALL 59493 0 5
// veh := CreateVehicle ;
3608: LD_ADDR_VAR 0 3
3612: PUSH
3613: CALL_OW 45
3617: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3618: LD_VAR 0 3
3622: PPUSH
3623: LD_INT 3
3625: PPUSH
3626: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3630: LD_VAR 0 3
3634: PPUSH
3635: LD_INT 30
3637: PPUSH
3638: LD_INT 0
3640: PPUSH
3641: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3645: LD_EXP 27
3649: PPUSH
3650: LD_VAR 0 3
3654: PPUSH
3655: CALL_OW 52
// end ; uc_nation := 3 ;
3659: LD_ADDR_OWVAR 21
3663: PUSH
3664: LD_INT 3
3666: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3667: LD_INT 22
3669: PPUSH
3670: LD_INT 3
3672: PPUSH
3673: LD_INT 1
3675: PPUSH
3676: LD_INT 45
3678: PPUSH
3679: LD_INT 100
3681: PPUSH
3682: CALL 59493 0 5
// veh := CreateVehicle ;
3686: LD_ADDR_VAR 0 3
3690: PUSH
3691: CALL_OW 45
3695: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3696: LD_VAR 0 3
3700: PPUSH
3701: LD_INT 7
3703: NEG
3704: PPUSH
3705: CALL_OW 242
// SetDir ( veh , 3 ) ;
3709: LD_VAR 0 3
3713: PPUSH
3714: LD_INT 3
3716: PPUSH
3717: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3721: LD_VAR 0 3
3725: PPUSH
3726: LD_INT 31
3728: PPUSH
3729: LD_INT 0
3731: PPUSH
3732: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3736: LD_EXP 54
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 52
// if Gossudarov then
3750: LD_EXP 40
3754: IFFALSE 3841
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3756: LD_INT 22
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 51
3767: PPUSH
3768: LD_INT 100
3770: PPUSH
3771: CALL 59493 0 5
// veh := CreateVehicle ;
3775: LD_ADDR_VAR 0 3
3779: PUSH
3780: CALL_OW 45
3784: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3785: LD_VAR 0 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3797: LD_VAR 0 3
3801: PPUSH
3802: LD_INT 30
3804: PPUSH
3805: LD_INT 0
3807: PPUSH
3808: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3812: LD_EXP 40
3816: PPUSH
3817: LD_VAR 0 3
3821: PPUSH
3822: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3826: LD_VAR 0 3
3830: PPUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 100
3836: PPUSH
3837: CALL_OW 290
// end ; if Mike then
3841: LD_EXP 39
3845: IFFALSE 3862
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3847: LD_EXP 39
3851: PPUSH
3852: LD_INT 30
3854: PPUSH
3855: LD_INT 0
3857: PPUSH
3858: CALL_OW 49
// for i in selected do
3862: LD_ADDR_VAR 0 2
3866: PUSH
3867: LD_VAR 0 4
3871: PUSH
3872: FOR_IN
3873: IFFALSE 4431
// begin uc_nation := GetNation ( i ) ;
3875: LD_ADDR_OWVAR 21
3879: PUSH
3880: LD_VAR 0 2
3884: PPUSH
3885: CALL_OW 248
3889: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3890: LD_VAR 0 2
3894: PUSH
3895: LD_EXP 23
3899: PUSH
3900: LD_EXP 24
3904: PUSH
3905: LD_EXP 26
3909: PUSH
3910: LD_EXP 25
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: IN
3921: IFFALSE 3944
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3923: LD_INT 5
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 1
3931: PPUSH
3932: LD_INT 6
3934: PPUSH
3935: LD_INT 100
3937: PPUSH
3938: CALL 59493 0 5
3942: GO 4378
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3944: LD_VAR 0 2
3948: PUSH
3949: LD_EXP 47
3953: PUSH
3954: LD_EXP 52
3958: PUSH
3959: LD_EXP 50
3963: PUSH
3964: LD_EXP 42
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: LIST
3973: LIST
3974: IN
3975: IFFALSE 4006
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3977: LD_INT 24
3979: PPUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_INT 1
3985: PPUSH
3986: LD_INT 46
3988: PPUSH
3989: LD_INT 65
3991: PPUSH
3992: LD_INT 75
3994: PPUSH
3995: CALL_OW 12
3999: PPUSH
4000: CALL 59493 0 5
4004: GO 4378
// if i = Karamazov then
4006: LD_VAR 0 2
4010: PUSH
4011: LD_EXP 53
4015: EQUAL
4016: IFFALSE 4039
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
4018: LD_INT 22
4020: PPUSH
4021: LD_INT 3
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 52
4029: PPUSH
4030: LD_INT 100
4032: PPUSH
4033: CALL 59493 0 5
4037: GO 4378
// if i = Brown then
4039: LD_VAR 0 2
4043: PUSH
4044: LD_EXP 28
4048: EQUAL
4049: IFFALSE 4072
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 3
4056: PPUSH
4057: LD_INT 1
4059: PPUSH
4060: LD_INT 13
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 59493 0 5
4070: GO 4378
// if uc_nation = nation_american then
4072: LD_OWVAR 21
4076: PUSH
4077: LD_INT 1
4079: EQUAL
4080: IFFALSE 4231
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4082: LD_INT 3
4084: PUSH
4085: LD_INT 5
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: PUSH
4096: LD_OWVAR 21
4100: PUSH
4101: LD_INT 3
4103: MOD
4104: PUSH
4105: LD_INT 1
4107: PLUS
4108: ARRAY
4109: PPUSH
4110: LD_INT 1
4112: PUSH
4113: LD_INT 3
4115: PUSH
4116: LD_INT 1
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: LIST
4123: PUSH
4124: LD_OWVAR 21
4128: PUSH
4129: LD_INT 3
4131: MOD
4132: PUSH
4133: LD_INT 1
4135: PLUS
4136: ARRAY
4137: PPUSH
4138: LD_INT 1
4140: PPUSH
4141: LD_INT 11
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: LD_INT 5
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: LD_INT 6
4157: PUSH
4158: LD_INT 7
4160: PUSH
4161: LD_INT 9
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: PUSH
4169: LD_INT 6
4171: PUSH
4172: LD_INT 9
4174: PUSH
4175: LD_INT 12
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: LIST
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: LIST
4187: PUSH
4188: LD_OWVAR 21
4192: PUSH
4193: LD_INT 3
4195: MOD
4196: PUSH
4197: LD_INT 1
4199: PLUS
4200: ARRAY
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: PPUSH
4214: LD_INT 65
4216: PPUSH
4217: LD_INT 75
4219: PPUSH
4220: CALL_OW 12
4224: PPUSH
4225: CALL 59493 0 5
// end else
4229: GO 4378
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4231: LD_INT 22
4233: PUSH
4234: LD_INT 23
4236: PUSH
4237: LD_INT 23
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PUSH
4245: LD_OWVAR 21
4249: PUSH
4250: LD_INT 3
4252: MOD
4253: PUSH
4254: LD_INT 1
4256: PLUS
4257: ARRAY
4258: PPUSH
4259: LD_INT 1
4261: PUSH
4262: LD_INT 3
4264: PUSH
4265: LD_INT 1
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: LIST
4272: PUSH
4273: LD_OWVAR 21
4277: PUSH
4278: LD_INT 3
4280: MOD
4281: PUSH
4282: LD_INT 1
4284: PLUS
4285: ARRAY
4286: PPUSH
4287: LD_INT 1
4289: PPUSH
4290: LD_INT 45
4292: PUSH
4293: LD_INT 43
4295: PUSH
4296: LD_INT 44
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 46
4306: PUSH
4307: LD_INT 45
4309: PUSH
4310: LD_INT 44
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: PUSH
4318: LD_INT 46
4320: PUSH
4321: LD_INT 43
4323: PUSH
4324: LD_INT 45
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: LIST
4336: PUSH
4337: LD_OWVAR 21
4341: PUSH
4342: LD_INT 3
4344: MOD
4345: PUSH
4346: LD_INT 1
4348: PLUS
4349: ARRAY
4350: PUSH
4351: LD_INT 1
4353: PPUSH
4354: LD_INT 3
4356: PPUSH
4357: CALL_OW 12
4361: ARRAY
4362: PPUSH
4363: LD_INT 65
4365: PPUSH
4366: LD_INT 75
4368: PPUSH
4369: CALL_OW 12
4373: PPUSH
4374: CALL 59493 0 5
// end ; veh := CreateVehicle ;
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: CALL_OW 45
4387: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4388: LD_VAR 0 3
4392: PPUSH
4393: LD_INT 3
4395: PPUSH
4396: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4400: LD_VAR 0 3
4404: PPUSH
4405: LD_INT 30
4407: PPUSH
4408: LD_INT 0
4410: PPUSH
4411: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4415: LD_VAR 0 2
4419: PPUSH
4420: LD_VAR 0 3
4424: PPUSH
4425: CALL_OW 52
// end ;
4429: GO 3872
4431: POP
4432: POP
// if artifactArCaptured then
4433: LD_EXP 9
4437: IFFALSE 4523
// begin uc_nation := nation_american ;
4439: LD_ADDR_OWVAR 21
4443: PUSH
4444: LD_INT 1
4446: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4447: LD_INT 3
4449: PPUSH
4450: LD_INT 3
4452: PPUSH
4453: LD_INT 3
4455: PPUSH
4456: LD_INT 12
4458: PPUSH
4459: LD_INT 100
4461: PPUSH
4462: CALL 59493 0 5
// veh := CreateVehicle ;
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: CALL_OW 45
4475: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 3
4483: PPUSH
4484: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4488: LD_VAR 0 3
4492: PPUSH
4493: LD_INT 198
4495: PPUSH
4496: LD_INT 22
4498: PPUSH
4499: LD_INT 0
4501: PPUSH
4502: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4506: LD_VAR 0 3
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 50
4516: PPUSH
4517: CALL_OW 290
// end else
4521: GO 4542
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4523: LD_INT 4
4525: PPUSH
4526: LD_INT 5
4528: PPUSH
4529: LD_INT 267
4531: PPUSH
4532: LD_INT 226
4534: PPUSH
4535: LD_INT 0
4537: PPUSH
4538: CALL_OW 58
// end ; uc_nation := nation_american ;
4542: LD_ADDR_OWVAR 21
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4550: LD_INT 3
4552: PPUSH
4553: LD_INT 3
4555: PPUSH
4556: LD_INT 3
4558: PPUSH
4559: LD_INT 12
4561: PPUSH
4562: LD_INT 100
4564: PPUSH
4565: CALL 59493 0 5
// veh := CreateVehicle ;
4569: LD_ADDR_VAR 0 3
4573: PUSH
4574: CALL_OW 45
4578: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4579: LD_VAR 0 3
4583: PPUSH
4584: LD_INT 3
4586: PPUSH
4587: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 218
4598: PPUSH
4599: LD_INT 23
4601: PPUSH
4602: LD_INT 0
4604: PPUSH
4605: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4609: LD_VAR 0 3
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 30
4619: PPUSH
4620: CALL_OW 290
// uc_nation := nation_russian ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 3
4631: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4632: LD_INT 22
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 51
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 59493 0 5
// veh := CreateVehicle ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4661: LD_VAR 0 3
4665: PPUSH
4666: LD_INT 3
4668: PPUSH
4669: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4673: LD_VAR 0 3
4677: PPUSH
4678: LD_INT 214
4680: PPUSH
4681: LD_INT 20
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4691: LD_VAR 0 3
4695: PPUSH
4696: LD_INT 4
4698: PPUSH
4699: LD_INT 40
4701: PPUSH
4702: CALL_OW 290
// end ;
4706: LD_VAR 0 1
4710: RET
// export function AllianceSupport ; var i , veh ; begin
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
// if not allianceTeam then
4716: LD_EXP 17
4720: NOT
4721: IFFALSE 4725
// exit ;
4723: GO 5131
// for i := 1 to 6 do
4725: LD_ADDR_VAR 0 2
4729: PUSH
4730: DOUBLE
4731: LD_INT 1
4733: DEC
4734: ST_TO_ADDR
4735: LD_INT 6
4737: PUSH
4738: FOR_TO
4739: IFFALSE 5035
// begin uc_side := 7 ;
4741: LD_ADDR_OWVAR 20
4745: PUSH
4746: LD_INT 7
4748: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4749: LD_ADDR_OWVAR 21
4753: PUSH
4754: LD_INT 1
4756: PUSH
4757: LD_INT 3
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: PUSH
4764: LD_VAR 0 2
4768: PUSH
4769: LD_INT 2
4771: MOD
4772: PUSH
4773: LD_INT 1
4775: PLUS
4776: ARRAY
4777: ST_TO_ADDR
// if uc_nation = 1 then
4778: LD_OWVAR 21
4782: PUSH
4783: LD_INT 1
4785: EQUAL
4786: IFFALSE 4828
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4788: LD_INT 5
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 6
4799: PUSH
4800: LD_INT 7
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: LD_INT 1
4809: PPUSH
4810: LD_INT 2
4812: PPUSH
4813: CALL_OW 12
4817: ARRAY
4818: PPUSH
4819: LD_INT 100
4821: PPUSH
4822: CALL 59493 0 5
4826: GO 4866
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4828: LD_INT 23
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 46
4839: PUSH
4840: LD_INT 47
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: LD_INT 1
4849: PPUSH
4850: LD_INT 2
4852: PPUSH
4853: CALL_OW 12
4857: ARRAY
4858: PPUSH
4859: LD_INT 100
4861: PPUSH
4862: CALL 59493 0 5
// if not allianceTeam then
4866: LD_EXP 17
4870: NOT
4871: IFFALSE 4875
// break ;
4873: GO 5035
// veh := CreateVehicle ;
4875: LD_ADDR_VAR 0 3
4879: PUSH
4880: CALL_OW 45
4884: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4885: LD_VAR 0 3
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4897: LD_VAR 0 3
4901: PPUSH
4902: LD_INT 38
4904: PPUSH
4905: LD_INT 0
4907: PPUSH
4908: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4912: LD_EXP 17
4916: PUSH
4917: LD_INT 1
4919: ARRAY
4920: PPUSH
4921: LD_INT 3
4923: PPUSH
4924: CALL_OW 259
4928: PUSH
4929: LD_INT 4
4931: GREATER
4932: IFFALSE 4950
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4934: LD_EXP 17
4938: PUSH
4939: LD_INT 1
4941: ARRAY
4942: PPUSH
4943: LD_INT 3
4945: PPUSH
4946: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4950: LD_EXP 17
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: LD_INT 4
4961: PPUSH
4962: CALL_OW 259
4966: PUSH
4967: LD_INT 8
4969: GREATER
4970: IFFALSE 4988
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4972: LD_EXP 17
4976: PUSH
4977: LD_INT 1
4979: ARRAY
4980: PPUSH
4981: LD_INT 4
4983: PPUSH
4984: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4988: LD_EXP 17
4992: PUSH
4993: LD_INT 1
4995: ARRAY
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
5006: LD_ADDR_EXP 17
5010: PUSH
5011: LD_EXP 17
5015: PPUSH
5016: LD_INT 1
5018: PPUSH
5019: CALL_OW 3
5023: ST_TO_ADDR
// ComHold ( veh ) ;
5024: LD_VAR 0 3
5028: PPUSH
5029: CALL_OW 140
// end ;
5033: GO 4738
5035: POP
5036: POP
// uc_side := 7 ;
5037: LD_ADDR_OWVAR 20
5041: PUSH
5042: LD_INT 7
5044: ST_TO_ADDR
// uc_nation := 1 ;
5045: LD_ADDR_OWVAR 21
5049: PUSH
5050: LD_INT 1
5052: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5053: LD_INT 5
5055: PPUSH
5056: LD_INT 3
5058: PPUSH
5059: LD_INT 3
5061: PPUSH
5062: LD_INT 11
5064: PPUSH
5065: LD_INT 100
5067: PPUSH
5068: CALL 59493 0 5
// veh := CreateVehicle ;
5072: LD_ADDR_VAR 0 3
5076: PUSH
5077: CALL_OW 45
5081: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 4
5089: PPUSH
5090: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5094: LD_VAR 0 3
5098: PPUSH
5099: LD_INT 305
5101: PPUSH
5102: LD_INT 218
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 48
// ComHold ( veh ) ;
5112: LD_VAR 0 3
5116: PPUSH
5117: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5121: LD_INT 313
5123: PPUSH
5124: LD_INT 220
5126: PPUSH
5127: CALL_OW 86
// end ; end_of_file
5131: LD_VAR 0 1
5135: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5136: LD_INT 0
5138: PPUSH
5139: PPUSH
5140: PPUSH
5141: PPUSH
5142: PPUSH
5143: PPUSH
5144: PPUSH
5145: PPUSH
5146: PPUSH
5147: PPUSH
5148: PPUSH
// if Difficulty = 1 then
5149: LD_OWVAR 67
5153: PUSH
5154: LD_INT 1
5156: EQUAL
5157: IFFALSE 5195
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
5159: LD_ADDR_VAR 0 2
5163: PUSH
5164: LD_INT 95
5166: PUSH
5167: LD_INT 39
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5193
// RemoveUnit ( i ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: CALL_OW 64
5191: GO 5179
5193: POP
5194: POP
// InitHc ;
5195: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5199: LD_INT 387
5201: PPUSH
5202: LD_STRING sigma
5204: PPUSH
5205: CALL_OW 500
// uc_side := 1 ;
5209: LD_ADDR_OWVAR 20
5213: PUSH
5214: LD_INT 1
5216: ST_TO_ADDR
// uc_nation := 1 ;
5217: LD_ADDR_OWVAR 21
5221: PUSH
5222: LD_INT 1
5224: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5225: LD_ADDR_VAR 0 2
5229: PUSH
5230: LD_INT 22
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 21
5242: PUSH
5243: LD_INT 3
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL_OW 69
5258: PUSH
5259: FOR_IN
5260: IFFALSE 5276
// SetBLevel ( i , 10 ) ;
5262: LD_VAR 0 2
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: CALL_OW 241
5274: GO 5259
5276: POP
5277: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 274
5285: PPUSH
5286: LD_INT 1
5288: PPUSH
5289: LD_INT 7500
5291: PPUSH
5292: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5296: LD_INT 387
5298: PPUSH
5299: CALL_OW 274
5303: PPUSH
5304: LD_INT 2
5306: PPUSH
5307: LD_INT 4000
5309: PPUSH
5310: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5314: LD_INT 387
5316: PPUSH
5317: CALL_OW 274
5321: PPUSH
5322: LD_INT 3
5324: PPUSH
5325: LD_INT 50
5327: PPUSH
5328: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5332: LD_INT 476
5334: PPUSH
5335: CALL_OW 274
5339: PPUSH
5340: LD_INT 1
5342: PPUSH
5343: LD_INT 5500
5345: PPUSH
5346: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5350: LD_INT 476
5352: PPUSH
5353: CALL_OW 274
5357: PPUSH
5358: LD_INT 2
5360: PPUSH
5361: LD_INT 4000
5363: PPUSH
5364: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5368: LD_INT 476
5370: PPUSH
5371: CALL_OW 274
5375: PPUSH
5376: LD_INT 3
5378: PPUSH
5379: LD_INT 10
5381: PPUSH
5382: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5386: LD_STRING 12a_PowellKilled
5388: PPUSH
5389: LD_INT 0
5391: PPUSH
5392: CALL_OW 30
5396: IFFALSE 5423
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5398: LD_INT 1
5400: PPUSH
5401: LD_INT 1
5403: PPUSH
5404: LD_INT 10
5406: PPUSH
5407: CALL_OW 380
// Powell := CreateHuman ;
5411: LD_ADDR_EXP 57
5415: PUSH
5416: CALL_OW 44
5420: ST_TO_ADDR
// end else
5421: GO 5436
// Powell := NewCharacter ( Powell ) ;
5423: LD_ADDR_EXP 57
5427: PUSH
5428: LD_STRING Powell
5430: PPUSH
5431: CALL_OW 25
5435: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5436: LD_EXP 57
5440: PPUSH
5441: LD_INT 387
5443: PPUSH
5444: CALL_OW 52
// tmp := [ ] ;
5448: LD_ADDR_VAR 0 7
5452: PUSH
5453: EMPTY
5454: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5455: LD_ADDR_EXP 23
5459: PUSH
5460: LD_STRING Lisa
5462: PPUSH
5463: LD_EXP 1
5467: NOT
5468: PPUSH
5469: LD_STRING 12p_
5471: PPUSH
5472: CALL 54473 0 3
5476: ST_TO_ADDR
// if Lisa then
5477: LD_EXP 23
5481: IFFALSE 5499
// tmp := tmp ^ Lisa ;
5483: LD_ADDR_VAR 0 7
5487: PUSH
5488: LD_VAR 0 7
5492: PUSH
5493: LD_EXP 23
5497: ADD
5498: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5499: LD_ADDR_EXP 24
5503: PUSH
5504: LD_STRING Donaldson
5506: PPUSH
5507: LD_EXP 1
5511: NOT
5512: PPUSH
5513: LD_STRING 12p_
5515: PPUSH
5516: CALL 54473 0 3
5520: ST_TO_ADDR
// if Donaldson then
5521: LD_EXP 24
5525: IFFALSE 5543
// tmp := tmp ^ Donaldson ;
5527: LD_ADDR_VAR 0 7
5531: PUSH
5532: LD_VAR 0 7
5536: PUSH
5537: LD_EXP 24
5541: ADD
5542: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5543: LD_ADDR_EXP 25
5547: PUSH
5548: LD_STRING Bobby
5550: PPUSH
5551: LD_EXP 1
5555: NOT
5556: PPUSH
5557: LD_STRING 12p_
5559: PPUSH
5560: CALL 54473 0 3
5564: ST_TO_ADDR
// if Bobby then
5565: LD_EXP 25
5569: IFFALSE 5587
// tmp := tmp ^ Bobby ;
5571: LD_ADDR_VAR 0 7
5575: PUSH
5576: LD_VAR 0 7
5580: PUSH
5581: LD_EXP 25
5585: ADD
5586: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5587: LD_ADDR_EXP 26
5591: PUSH
5592: LD_STRING Cyrus
5594: PPUSH
5595: LD_EXP 1
5599: NOT
5600: PPUSH
5601: LD_STRING 12p_
5603: PPUSH
5604: CALL 54473 0 3
5608: ST_TO_ADDR
// if Cyrus then
5609: LD_EXP 26
5613: IFFALSE 5631
// tmp := tmp ^ Cyrus ;
5615: LD_ADDR_VAR 0 7
5619: PUSH
5620: LD_VAR 0 7
5624: PUSH
5625: LD_EXP 26
5629: ADD
5630: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5631: LD_ADDR_EXP 28
5635: PUSH
5636: LD_STRING Brown
5638: PPUSH
5639: LD_EXP 1
5643: NOT
5644: PPUSH
5645: LD_STRING 12p_
5647: PPUSH
5648: CALL 54473 0 3
5652: ST_TO_ADDR
// if Brown then
5653: LD_EXP 28
5657: IFFALSE 5675
// tmp := tmp ^ Brown ;
5659: LD_ADDR_VAR 0 7
5663: PUSH
5664: LD_VAR 0 7
5668: PUSH
5669: LD_EXP 28
5673: ADD
5674: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5675: LD_ADDR_EXP 29
5679: PUSH
5680: LD_STRING Gladstone
5682: PPUSH
5683: LD_EXP 1
5687: NOT
5688: PPUSH
5689: LD_STRING 12p_
5691: PPUSH
5692: CALL 54473 0 3
5696: ST_TO_ADDR
// if Gladstone then
5697: LD_EXP 29
5701: IFFALSE 5719
// tmp := tmp ^ Gladstone ;
5703: LD_ADDR_VAR 0 7
5707: PUSH
5708: LD_VAR 0 7
5712: PUSH
5713: LD_EXP 29
5717: ADD
5718: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5719: LD_ADDR_EXP 30
5723: PUSH
5724: LD_STRING Houten
5726: PPUSH
5727: LD_EXP 1
5731: NOT
5732: PPUSH
5733: LD_STRING 12p_
5735: PPUSH
5736: CALL 54473 0 3
5740: ST_TO_ADDR
// if Houten then
5741: LD_EXP 30
5745: IFFALSE 5763
// tmp := tmp ^ Houten ;
5747: LD_ADDR_VAR 0 7
5751: PUSH
5752: LD_VAR 0 7
5756: PUSH
5757: LD_EXP 30
5761: ADD
5762: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5763: LD_ADDR_EXP 31
5767: PUSH
5768: LD_STRING Cornel
5770: PPUSH
5771: LD_EXP 1
5775: NOT
5776: PPUSH
5777: LD_STRING 12p_
5779: PPUSH
5780: CALL 54473 0 3
5784: ST_TO_ADDR
// if Cornel then
5785: LD_EXP 31
5789: IFFALSE 5807
// tmp := tmp ^ Cornel ;
5791: LD_ADDR_VAR 0 7
5795: PUSH
5796: LD_VAR 0 7
5800: PUSH
5801: LD_EXP 31
5805: ADD
5806: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5807: LD_ADDR_EXP 32
5811: PUSH
5812: LD_STRING Gary
5814: PPUSH
5815: LD_EXP 1
5819: NOT
5820: PPUSH
5821: LD_STRING 12p_
5823: PPUSH
5824: CALL 54473 0 3
5828: ST_TO_ADDR
// if Gary then
5829: LD_EXP 32
5833: IFFALSE 5851
// tmp := tmp ^ Gary ;
5835: LD_ADDR_VAR 0 7
5839: PUSH
5840: LD_VAR 0 7
5844: PUSH
5845: LD_EXP 32
5849: ADD
5850: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5851: LD_ADDR_EXP 34
5855: PUSH
5856: LD_STRING Kikuchi
5858: PPUSH
5859: LD_EXP 1
5863: NOT
5864: PPUSH
5865: LD_STRING 12p_
5867: PPUSH
5868: CALL 54473 0 3
5872: ST_TO_ADDR
// if Kikuchi then
5873: LD_EXP 34
5877: IFFALSE 5895
// tmp := tmp ^ Kikuchi ;
5879: LD_ADDR_VAR 0 7
5883: PUSH
5884: LD_VAR 0 7
5888: PUSH
5889: LD_EXP 34
5893: ADD
5894: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5895: LD_ADDR_VAR 0 7
5899: PUSH
5900: LD_VAR 0 7
5904: PUSH
5905: LD_STRING 12p_others
5907: PPUSH
5908: CALL_OW 31
5912: UNION
5913: ST_TO_ADDR
// InitHc_All ( ) ;
5914: CALL_OW 584
// if tmp < 36 then
5918: LD_VAR 0 7
5922: PUSH
5923: LD_INT 36
5925: LESS
5926: IFFALSE 5993
// for i = 1 to 36 - tmp do
5928: LD_ADDR_VAR 0 2
5932: PUSH
5933: DOUBLE
5934: LD_INT 1
5936: DEC
5937: ST_TO_ADDR
5938: LD_INT 36
5940: PUSH
5941: LD_VAR 0 7
5945: MINUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 5991
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5950: LD_INT 1
5952: PPUSH
5953: LD_VAR 0 2
5957: PUSH
5958: LD_INT 4
5960: MOD
5961: PUSH
5962: LD_INT 1
5964: PLUS
5965: PPUSH
5966: LD_INT 10
5968: PPUSH
5969: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5973: LD_ADDR_VAR 0 7
5977: PUSH
5978: LD_VAR 0 7
5982: PUSH
5983: CALL_OW 44
5987: ADD
5988: ST_TO_ADDR
// end ;
5989: GO 5947
5991: POP
5992: POP
// p := 0 ;
5993: LD_ADDR_VAR 0 6
5997: PUSH
5998: LD_INT 0
6000: ST_TO_ADDR
// for i in tmp do
6001: LD_ADDR_VAR 0 2
6005: PUSH
6006: LD_VAR 0 7
6010: PUSH
6011: FOR_IN
6012: IFFALSE 6064
// begin p := Inc ( p ) ;
6014: LD_ADDR_VAR 0 6
6018: PUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: CALL 94046 0 1
6028: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
6029: LD_VAR 0 2
6033: PPUSH
6034: LD_INT 62
6036: PPUSH
6037: LD_INT 93
6039: PPUSH
6040: LD_INT 9
6042: PPUSH
6043: LD_INT 0
6045: PPUSH
6046: CALL_OW 50
// if p > 36 then
6050: LD_VAR 0 6
6054: PUSH
6055: LD_INT 36
6057: GREATER
6058: IFFALSE 6062
// break ;
6060: GO 6064
// end ;
6062: GO 6011
6064: POP
6065: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
6066: LD_ADDR_EXP 80
6070: PUSH
6071: LD_EXP 80
6075: PPUSH
6076: LD_INT 4
6078: PPUSH
6079: LD_INT 22
6081: PUSH
6082: LD_INT 1
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PPUSH
6089: CALL_OW 69
6093: PUSH
6094: LD_EXP 57
6098: DIFF
6099: PPUSH
6100: CALL_OW 1
6104: ST_TO_ADDR
// uc_side := 0 ;
6105: LD_ADDR_OWVAR 20
6109: PUSH
6110: LD_INT 0
6112: ST_TO_ADDR
// uc_nation := 0 ;
6113: LD_ADDR_OWVAR 21
6117: PUSH
6118: LD_INT 0
6120: ST_TO_ADDR
// for i = 1 to 4 do
6121: LD_ADDR_VAR 0 2
6125: PUSH
6126: DOUBLE
6127: LD_INT 1
6129: DEC
6130: ST_TO_ADDR
6131: LD_INT 4
6133: PUSH
6134: FOR_TO
6135: IFFALSE 6166
// begin InitHc ;
6137: CALL_OW 19
// hc_class := class_apeman ;
6141: LD_ADDR_OWVAR 28
6145: PUSH
6146: LD_INT 12
6148: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6149: CALL_OW 44
6153: PPUSH
6154: LD_INT 11
6156: PPUSH
6157: LD_INT 0
6159: PPUSH
6160: CALL_OW 49
// end ;
6164: GO 6134
6166: POP
6167: POP
// end ;
6168: LD_VAR 0 1
6172: RET
// every 6 6$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6173: LD_EXP 4
6177: NOT
6178: IFFALSE 7107
6180: GO 6182
6182: DISABLE
6183: LD_INT 0
6185: PPUSH
6186: PPUSH
6187: PPUSH
6188: PPUSH
// begin enable ;
6189: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6190: LD_INT 22
6192: PUSH
6193: LD_INT 1
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PUSH
6200: LD_INT 23
6202: PUSH
6203: LD_INT 1
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 30
6212: PUSH
6213: LD_INT 3
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 69
6229: NOT
6230: IFFALSE 6234
// exit ;
6232: GO 7107
// if Prob ( 40 ) then
6234: LD_INT 40
6236: PPUSH
6237: CALL_OW 13
6241: IFFALSE 6368
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6243: LD_INT 4
6245: PPUSH
6246: LD_INT 5
6248: PUSH
6249: LD_INT 1
6251: PUSH
6252: LD_INT 2
6254: PUSH
6255: LD_INT 7
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 5
6266: PUSH
6267: LD_INT 1
6269: PUSH
6270: LD_INT 2
6272: PUSH
6273: LD_INT 7
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_INT 5
6284: PUSH
6285: LD_INT 1
6287: PUSH
6288: LD_INT 2
6290: PUSH
6291: LD_INT 7
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 5
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: LD_INT 2
6308: PUSH
6309: LD_INT 6
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 5
6320: PUSH
6321: LD_INT 1
6323: PUSH
6324: LD_INT 2
6326: PUSH
6327: LD_INT 6
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 5
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: LD_INT 2
6344: PUSH
6345: LD_INT 6
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: LIST
6360: LIST
6361: PPUSH
6362: CALL 47949 0 2
// end else
6366: GO 6491
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6368: LD_INT 4
6370: PPUSH
6371: LD_INT 5
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: LD_INT 2
6379: PUSH
6380: LD_INT 7
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: LIST
6388: PUSH
6389: LD_INT 5
6391: PUSH
6392: LD_INT 1
6394: PUSH
6395: LD_INT 2
6397: PUSH
6398: LD_INT 9
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 5
6409: PUSH
6410: LD_INT 1
6412: PUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 9
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 5
6427: PUSH
6428: LD_INT 1
6430: PUSH
6431: LD_INT 2
6433: PUSH
6434: LD_INT 6
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 5
6445: PUSH
6446: LD_INT 1
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: LIST
6459: LIST
6460: PUSH
6461: LD_INT 5
6463: PUSH
6464: LD_INT 1
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 6
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: PPUSH
6487: CALL 47949 0 2
// end ; p := 0 ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 0
6498: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// p := Inc ( p ) ;
6506: LD_ADDR_VAR 0 4
6510: PUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 94046 0 1
6520: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6521: LD_INT 4
6523: PPUSH
6524: LD_INT 1
6526: PPUSH
6527: CALL 49405 0 2
6531: PUSH
6532: LD_INT 6
6534: GREATEREQUAL
6535: IFTRUE 6547
6537: PUSH
6538: LD_VAR 0 4
6542: PUSH
6543: LD_INT 100
6545: GREATER
6546: OR
6547: IFFALSE 6499
// wait ( 0 0$30 ) ;
6549: LD_INT 1050
6551: PPUSH
6552: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_siberium_rocket ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , us_crane ] ] ] ) diff mc_defender [ 4 ] ;
6556: LD_ADDR_VAR 0 2
6560: PUSH
6561: LD_INT 22
6563: PUSH
6564: LD_INT 1
6566: PUSH
6567: EMPTY
6568: LIST
6569: LIST
6570: PUSH
6571: LD_INT 21
6573: PUSH
6574: LD_INT 2
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 34
6586: PUSH
6587: LD_INT 8
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: PUSH
6598: LD_INT 3
6600: PUSH
6601: LD_INT 34
6603: PUSH
6604: LD_INT 12
6606: PUSH
6607: EMPTY
6608: LIST
6609: LIST
6610: PUSH
6611: EMPTY
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 3
6617: PUSH
6618: LD_INT 34
6620: PUSH
6621: LD_INT 13
6623: PUSH
6624: EMPTY
6625: LIST
6626: LIST
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: LIST
6637: LIST
6638: PPUSH
6639: CALL_OW 69
6643: PUSH
6644: LD_EXP 102
6648: PUSH
6649: LD_INT 4
6651: ARRAY
6652: DIFF
6653: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6654: LD_ADDR_EXP 99
6658: PUSH
6659: LD_EXP 99
6663: PPUSH
6664: LD_INT 4
6666: PPUSH
6667: LD_EXP 99
6671: PUSH
6672: LD_INT 4
6674: ARRAY
6675: PUSH
6676: LD_VAR 0 2
6680: DIFF
6681: PPUSH
6682: CALL_OW 1
6686: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6687: LD_ADDR_VAR 0 3
6691: PUSH
6692: LD_INT 0
6694: PPUSH
6695: LD_INT 2
6697: PPUSH
6698: CALL_OW 12
6702: ST_TO_ADDR
// p := 0 ;
6703: LD_ADDR_VAR 0 4
6707: PUSH
6708: LD_INT 0
6710: ST_TO_ADDR
// if target then
6711: LD_VAR 0 3
6715: IFFALSE 6870
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6717: LD_ADDR_VAR 0 2
6721: PUSH
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 24
6729: PUSH
6730: LD_INT 250
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PPUSH
6737: CALL_OW 72
6741: ST_TO_ADDR
// for i in tmp do
6742: LD_ADDR_VAR 0 1
6746: PUSH
6747: LD_VAR 0 2
6751: PUSH
6752: FOR_IN
6753: IFFALSE 6793
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6755: LD_VAR 0 1
6759: PPUSH
6760: LD_INT 114
6762: PPUSH
6763: LD_INT 108
6765: PPUSH
6766: CALL_OW 297
6770: PUSH
6771: LD_INT 9
6773: GREATER
6774: IFFALSE 6791
// ComMoveXY ( i , 114 , 108 ) ;
6776: LD_VAR 0 1
6780: PPUSH
6781: LD_INT 114
6783: PPUSH
6784: LD_INT 108
6786: PPUSH
6787: CALL_OW 111
6791: GO 6752
6793: POP
6794: POP
// wait ( 0 0$1 ) ;
6795: LD_INT 35
6797: PPUSH
6798: CALL_OW 67
// p := Inc ( p ) ;
6802: LD_ADDR_VAR 0 4
6806: PUSH
6807: LD_VAR 0 4
6811: PPUSH
6812: CALL 94046 0 1
6816: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6817: LD_VAR 0 2
6821: PPUSH
6822: LD_INT 92
6824: PUSH
6825: LD_INT 114
6827: PUSH
6828: LD_INT 108
6830: PUSH
6831: LD_INT 9
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 72
6844: PUSH
6845: LD_VAR 0 2
6849: PUSH
6850: LD_INT 1
6852: MINUS
6853: GREATEREQUAL
6854: IFTRUE 6866
6856: PUSH
6857: LD_VAR 0 4
6861: PUSH
6862: LD_INT 30
6864: GREATER
6865: OR
6866: IFFALSE 6717
// end else
6868: GO 7021
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6870: LD_ADDR_VAR 0 2
6874: PUSH
6875: LD_VAR 0 2
6879: PPUSH
6880: LD_INT 24
6882: PUSH
6883: LD_INT 250
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PPUSH
6890: CALL_OW 72
6894: ST_TO_ADDR
// for i in tmp do
6895: LD_ADDR_VAR 0 1
6899: PUSH
6900: LD_VAR 0 2
6904: PUSH
6905: FOR_IN
6906: IFFALSE 6946
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6908: LD_VAR 0 1
6912: PPUSH
6913: LD_INT 129
6915: PPUSH
6916: LD_INT 139
6918: PPUSH
6919: CALL_OW 297
6923: PUSH
6924: LD_INT 9
6926: GREATER
6927: IFFALSE 6944
// ComMoveXY ( i , 129 , 139 ) ;
6929: LD_VAR 0 1
6933: PPUSH
6934: LD_INT 129
6936: PPUSH
6937: LD_INT 139
6939: PPUSH
6940: CALL_OW 111
6944: GO 6905
6946: POP
6947: POP
// wait ( 0 0$1 ) ;
6948: LD_INT 35
6950: PPUSH
6951: CALL_OW 67
// p := Inc ( p ) ;
6955: LD_ADDR_VAR 0 4
6959: PUSH
6960: LD_VAR 0 4
6964: PPUSH
6965: CALL 94046 0 1
6969: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 92
6977: PUSH
6978: LD_INT 129
6980: PUSH
6981: LD_INT 139
6983: PUSH
6984: LD_INT 9
6986: PUSH
6987: EMPTY
6988: LIST
6989: LIST
6990: LIST
6991: LIST
6992: PPUSH
6993: CALL_OW 72
6997: PUSH
6998: LD_VAR 0 2
7002: PUSH
7003: LD_INT 1
7005: MINUS
7006: GREATEREQUAL
7007: IFTRUE 7019
7009: PUSH
7010: LD_VAR 0 4
7014: PUSH
7015: LD_INT 30
7017: GREATER
7018: OR
7019: IFFALSE 6870
// end ; repeat wait ( 0 0$1 ) ;
7021: LD_INT 35
7023: PPUSH
7024: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7028: LD_ADDR_VAR 0 2
7032: PUSH
7033: LD_VAR 0 2
7037: PPUSH
7038: LD_INT 50
7040: PUSH
7041: EMPTY
7042: LIST
7043: PPUSH
7044: CALL_OW 72
7048: ST_TO_ADDR
// for i in tmp do
7049: LD_ADDR_VAR 0 1
7053: PUSH
7054: LD_VAR 0 2
7058: PUSH
7059: FOR_IN
7060: IFFALSE 7098
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
7062: LD_VAR 0 1
7066: PPUSH
7067: LD_INT 81
7069: PUSH
7070: LD_INT 1
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: PPUSH
7077: CALL_OW 69
7081: PPUSH
7082: LD_VAR 0 1
7086: PPUSH
7087: CALL_OW 74
7091: PPUSH
7092: CALL_OW 115
7096: GO 7059
7098: POP
7099: POP
// until not tmp ;
7100: LD_VAR 0 2
7104: NOT
7105: IFFALSE 7021
// end ;
7107: PPOPN 4
7109: END
// every 30 30$00 trigger not americanDestroyed do
7110: LD_EXP 4
7114: NOT
7115: IFFALSE 7184
7117: GO 7119
7119: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
7120: LD_INT 63000
7122: PUSH
7123: LD_INT 42000
7125: PUSH
7126: LD_INT 31500
7128: PUSH
7129: LD_INT 21000
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: ARRAY
7143: PPUSH
7144: CALL_OW 67
// if americanDestroyed then
7148: LD_EXP 4
7152: IFFALSE 7156
// exit ;
7154: GO 7184
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
7156: LD_INT 4
7158: PPUSH
7159: LD_INT 5
7161: PUSH
7162: LD_INT 3
7164: PUSH
7165: LD_INT 1
7167: PUSH
7168: LD_INT 8
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: PUSH
7177: EMPTY
7178: LIST
7179: PPUSH
7180: CALL 47949 0 2
// end ; end_of_file
7184: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
7185: LD_INT 0
7187: PPUSH
7188: PPUSH
7189: PPUSH
7190: PPUSH
7191: PPUSH
// side := 2 ;
7192: LD_ADDR_VAR 0 5
7196: PUSH
7197: LD_INT 2
7199: ST_TO_ADDR
// InitHc ;
7200: CALL_OW 19
// uc_side := side ;
7204: LD_ADDR_OWVAR 20
7208: PUSH
7209: LD_VAR 0 5
7213: ST_TO_ADDR
// uc_nation := 2 ;
7214: LD_ADDR_OWVAR 21
7218: PUSH
7219: LD_INT 2
7221: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7222: LD_ADDR_VAR 0 2
7226: PUSH
7227: LD_INT 22
7229: PUSH
7230: LD_INT 2
7232: PUSH
7233: EMPTY
7234: LIST
7235: LIST
7236: PUSH
7237: LD_INT 21
7239: PUSH
7240: LD_INT 3
7242: PUSH
7243: EMPTY
7244: LIST
7245: LIST
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PPUSH
7251: CALL_OW 69
7255: PUSH
7256: FOR_IN
7257: IFFALSE 7273
// SetBLevel ( i , 10 ) ;
7259: LD_VAR 0 2
7263: PPUSH
7264: LD_INT 10
7266: PPUSH
7267: CALL_OW 241
7271: GO 7256
7273: POP
7274: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7275: LD_ADDR_VAR 0 4
7279: PUSH
7280: LD_INT 22
7282: PUSH
7283: LD_VAR 0 5
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: PUSH
7292: LD_INT 30
7294: PUSH
7295: LD_INT 32
7297: PUSH
7298: EMPTY
7299: LIST
7300: LIST
7301: PUSH
7302: LD_INT 58
7304: PUSH
7305: EMPTY
7306: LIST
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: PPUSH
7313: CALL_OW 69
7317: ST_TO_ADDR
// for i = 1 to 10 do
7318: LD_ADDR_VAR 0 2
7322: PUSH
7323: DOUBLE
7324: LD_INT 1
7326: DEC
7327: ST_TO_ADDR
7328: LD_INT 10
7330: PUSH
7331: FOR_TO
7332: IFFALSE 7404
// begin uc_nation := nation_nature ;
7334: LD_ADDR_OWVAR 21
7338: PUSH
7339: LD_INT 0
7341: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7342: LD_ADDR_OWVAR 28
7346: PUSH
7347: LD_INT 15
7349: ST_TO_ADDR
// hc_gallery :=  ;
7350: LD_ADDR_OWVAR 33
7354: PUSH
7355: LD_STRING 
7357: ST_TO_ADDR
// hc_name :=  ;
7358: LD_ADDR_OWVAR 26
7362: PUSH
7363: LD_STRING 
7365: ST_TO_ADDR
// un := CreateHuman ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: CALL_OW 44
7375: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7376: LD_VAR 0 3
7380: PPUSH
7381: LD_VAR 0 4
7385: PUSH
7386: LD_VAR 0 4
7390: PUSH
7391: LD_VAR 0 2
7395: MINUS
7396: ARRAY
7397: PPUSH
7398: CALL_OW 52
// end ;
7402: GO 7331
7404: POP
7405: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7406: LD_INT 503
7408: PPUSH
7409: LD_INT 27
7411: PPUSH
7412: LD_STRING 
7414: PPUSH
7415: LD_INT 8
7417: PUSH
7418: LD_INT 9
7420: PUSH
7421: LD_INT 10
7423: PUSH
7424: LD_INT 10
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: LIST
7432: PUSH
7433: LD_OWVAR 67
7437: ARRAY
7438: PPUSH
7439: LD_INT 3000
7441: PUSH
7442: LD_INT 500
7444: PUSH
7445: LD_INT 150
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: LIST
7452: PPUSH
7453: LD_INT 16
7455: PUSH
7456: LD_INT 6
7458: PUSH
7459: LD_INT 6
7461: PUSH
7462: LD_INT 6
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PPUSH
7471: CALL 63330 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7475: LD_ADDR_EXP 80
7479: PUSH
7480: LD_EXP 80
7484: PPUSH
7485: LD_INT 1
7487: PPUSH
7488: LD_INT 22
7490: PUSH
7491: LD_VAR 0 5
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: PUSH
7500: LD_INT 23
7502: PUSH
7503: LD_INT 2
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 3
7512: PUSH
7513: LD_INT 21
7515: PUSH
7516: LD_INT 2
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: LIST
7531: PPUSH
7532: CALL_OW 69
7536: PPUSH
7537: CALL_OW 1
7541: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7542: LD_INT 216
7544: PPUSH
7545: LD_INT 228
7547: PPUSH
7548: LD_INT 2
7550: PPUSH
7551: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7555: LD_INT 223
7557: PPUSH
7558: LD_INT 241
7560: PPUSH
7561: LD_INT 2
7563: PPUSH
7564: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7568: LD_INT 216
7570: PPUSH
7571: LD_INT 217
7573: PPUSH
7574: LD_INT 2
7576: PPUSH
7577: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7581: LD_INT 233
7583: PPUSH
7584: LD_INT 257
7586: PPUSH
7587: LD_INT 2
7589: PPUSH
7590: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7594: LD_INT 230
7596: PPUSH
7597: LD_INT 199
7599: PPUSH
7600: LD_INT 2
7602: PPUSH
7603: CALL_OW 244
// end ;
7607: LD_VAR 0 1
7611: RET
// export Omar ; export function PrepareOmarAli ; begin
7612: LD_INT 0
7614: PPUSH
// uc_side := 5 ;
7615: LD_ADDR_OWVAR 20
7619: PUSH
7620: LD_INT 5
7622: ST_TO_ADDR
// uc_nation := 2 ;
7623: LD_ADDR_OWVAR 21
7627: PUSH
7628: LD_INT 2
7630: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7631: LD_ADDR_EXP 58
7635: PUSH
7636: LD_STRING Omar
7638: PPUSH
7639: CALL_OW 25
7643: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7644: LD_EXP 58
7648: PPUSH
7649: LD_INT 330
7651: PPUSH
7652: LD_INT 244
7654: PPUSH
7655: LD_INT 0
7657: PPUSH
7658: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7662: LD_EXP 58
7666: PPUSH
7667: LD_INT 252
7669: PPUSH
7670: LD_INT 220
7672: PPUSH
7673: CALL_OW 111
// end ;
7677: LD_VAR 0 1
7681: RET
// export function PrepareOmarAli2 ; begin
7682: LD_INT 0
7684: PPUSH
// uc_side := 5 ;
7685: LD_ADDR_OWVAR 20
7689: PUSH
7690: LD_INT 5
7692: ST_TO_ADDR
// uc_nation := 2 ;
7693: LD_ADDR_OWVAR 21
7697: PUSH
7698: LD_INT 2
7700: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7701: LD_ADDR_EXP 58
7705: PUSH
7706: LD_STRING Omar
7708: PPUSH
7709: CALL_OW 25
7713: ST_TO_ADDR
// PlaceUnitXY ( Omar , 289 , 164 , false ) ;
7714: LD_EXP 58
7718: PPUSH
7719: LD_INT 289
7721: PPUSH
7722: LD_INT 164
7724: PPUSH
7725: LD_INT 0
7727: PPUSH
7728: CALL_OW 48
// ComMoveXY ( Omar , 254 , 166 ) ;
7732: LD_EXP 58
7736: PPUSH
7737: LD_INT 254
7739: PPUSH
7740: LD_INT 166
7742: PPUSH
7743: CALL_OW 111
// end ; end_of_file
7747: LD_VAR 0 1
7751: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7752: LD_INT 0
7754: PPUSH
7755: PPUSH
7756: PPUSH
7757: PPUSH
7758: PPUSH
// side := 8 ;
7759: LD_ADDR_VAR 0 3
7763: PUSH
7764: LD_INT 8
7766: ST_TO_ADDR
// InitHc ;
7767: CALL_OW 19
// uc_side := side ;
7771: LD_ADDR_OWVAR 20
7775: PUSH
7776: LD_VAR 0 3
7780: ST_TO_ADDR
// uc_nation := 2 ;
7781: LD_ADDR_OWVAR 21
7785: PUSH
7786: LD_INT 2
7788: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7789: LD_ADDR_VAR 0 2
7793: PUSH
7794: LD_INT 22
7796: PUSH
7797: LD_VAR 0 3
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: LD_INT 21
7808: PUSH
7809: LD_INT 3
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PPUSH
7820: CALL_OW 69
7824: PUSH
7825: FOR_IN
7826: IFFALSE 7842
// SetBLevel ( i , 10 ) ;
7828: LD_VAR 0 2
7832: PPUSH
7833: LD_INT 10
7835: PPUSH
7836: CALL_OW 241
7840: GO 7825
7842: POP
7843: POP
// Schulz := NewCharacter ( Schulz ) ;
7844: LD_ADDR_EXP 59
7848: PUSH
7849: LD_STRING Schulz
7851: PPUSH
7852: CALL_OW 25
7856: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7857: LD_ADDR_EXP 61
7861: PUSH
7862: LD_STRING Kaia
7864: PPUSH
7865: CALL_OW 25
7869: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7870: LD_EXP 61
7874: PPUSH
7875: LD_INT 324
7877: PPUSH
7878: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7882: LD_ADDR_EXP 60
7886: PUSH
7887: LD_STRING Kozlov
7889: PPUSH
7890: LD_INT 0
7892: PPUSH
7893: LD_STRING 
7895: PPUSH
7896: CALL 54473 0 3
7900: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7901: LD_EXP 60
7905: PPUSH
7906: LD_INT 22
7908: PUSH
7909: LD_INT 8
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: LD_INT 23
7918: PUSH
7919: LD_INT 3
7921: PUSH
7922: EMPTY
7923: LIST
7924: LIST
7925: PUSH
7926: LD_INT 30
7928: PUSH
7929: LD_INT 8
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: PPUSH
7941: CALL_OW 69
7945: PUSH
7946: LD_INT 1
7948: ARRAY
7949: PPUSH
7950: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7954: LD_EXP 60
7958: PPUSH
7959: LD_INT 3
7961: PPUSH
7962: LD_INT 10
7964: PPUSH
7965: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7969: LD_ADDR_VAR 0 5
7973: PUSH
7974: LD_INT 22
7976: PUSH
7977: LD_VAR 0 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PUSH
7986: LD_INT 30
7988: PUSH
7989: LD_INT 32
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 58
7998: PUSH
7999: EMPTY
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: LIST
8006: PPUSH
8007: CALL_OW 69
8011: ST_TO_ADDR
// for i = 1 to 10 do
8012: LD_ADDR_VAR 0 2
8016: PUSH
8017: DOUBLE
8018: LD_INT 1
8020: DEC
8021: ST_TO_ADDR
8022: LD_INT 10
8024: PUSH
8025: FOR_TO
8026: IFFALSE 8098
// begin uc_nation := nation_nature ;
8028: LD_ADDR_OWVAR 21
8032: PUSH
8033: LD_INT 0
8035: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
8036: LD_ADDR_OWVAR 28
8040: PUSH
8041: LD_INT 15
8043: ST_TO_ADDR
// hc_gallery :=  ;
8044: LD_ADDR_OWVAR 33
8048: PUSH
8049: LD_STRING 
8051: ST_TO_ADDR
// hc_name :=  ;
8052: LD_ADDR_OWVAR 26
8056: PUSH
8057: LD_STRING 
8059: ST_TO_ADDR
// un := CreateHuman ;
8060: LD_ADDR_VAR 0 4
8064: PUSH
8065: CALL_OW 44
8069: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
8070: LD_VAR 0 4
8074: PPUSH
8075: LD_VAR 0 5
8079: PUSH
8080: LD_VAR 0 5
8084: PUSH
8085: LD_VAR 0 2
8089: MINUS
8090: ARRAY
8091: PPUSH
8092: CALL_OW 52
// end ;
8096: GO 8025
8098: POP
8099: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
8100: LD_INT 324
8102: PPUSH
8103: LD_INT 3
8105: PPUSH
8106: LD_STRING 
8108: PPUSH
8109: LD_INT 8
8111: PUSH
8112: LD_INT 9
8114: PUSH
8115: LD_INT 10
8117: PUSH
8118: LD_INT 10
8120: PUSH
8121: EMPTY
8122: LIST
8123: LIST
8124: LIST
8125: LIST
8126: PUSH
8127: LD_OWVAR 67
8131: ARRAY
8132: PPUSH
8133: LD_INT 3000
8135: PUSH
8136: LD_INT 500
8138: PUSH
8139: LD_INT 150
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: LD_INT 16
8149: PUSH
8150: LD_INT 6
8152: PUSH
8153: LD_INT 6
8155: PUSH
8156: LD_INT 8
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: LIST
8163: LIST
8164: PPUSH
8165: CALL 63330 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
8169: LD_ADDR_EXP 80
8173: PUSH
8174: LD_EXP 80
8178: PPUSH
8179: LD_INT 3
8181: PPUSH
8182: LD_INT 22
8184: PUSH
8185: LD_VAR 0 3
8189: PUSH
8190: EMPTY
8191: LIST
8192: LIST
8193: PUSH
8194: LD_INT 23
8196: PUSH
8197: LD_INT 2
8199: PUSH
8200: EMPTY
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: LD_INT 21
8209: PUSH
8210: LD_INT 2
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: LIST
8225: PPUSH
8226: CALL_OW 69
8230: PUSH
8231: LD_EXP 59
8235: DIFF
8236: PPUSH
8237: CALL_OW 1
8241: ST_TO_ADDR
// end ;
8242: LD_VAR 0 1
8246: RET
// export function BuildKozlovBomb ; begin
8247: LD_INT 0
8249: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
8250: LD_INT 332
8252: PPUSH
8253: CALL_OW 302
8257: NOT
8258: IFTRUE 8270
8260: PUSH
8261: LD_INT 336
8263: PPUSH
8264: CALL_OW 302
8268: NOT
8269: OR
8270: IFFALSE 8274
// exit ;
8272: GO 8371
// ComChangeProfession ( Kozlov , 4 ) ;
8274: LD_EXP 60
8278: PPUSH
8279: LD_INT 4
8281: PPUSH
8282: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8286: LD_INT 336
8288: PPUSH
8289: LD_INT 25
8291: PPUSH
8292: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8296: LD_INT 35
8298: PPUSH
8299: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8303: LD_INT 25
8305: PPUSH
8306: LD_INT 8
8308: PPUSH
8309: CALL_OW 321
8313: PUSH
8314: LD_INT 2
8316: EQUAL
8317: IFFALSE 8296
// ComExitBuilding ( Kozlov ) ;
8319: LD_EXP 60
8323: PPUSH
8324: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8328: LD_EXP 60
8332: PPUSH
8333: LD_INT 332
8335: PPUSH
8336: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8340: LD_EXP 60
8344: PPUSH
8345: LD_INT 3
8347: PPUSH
8348: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8352: LD_INT 332
8354: PPUSH
8355: LD_INT 23
8357: PPUSH
8358: LD_INT 3
8360: PPUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 48
8366: PPUSH
8367: CALL_OW 125
// end ;
8371: LD_VAR 0 1
8375: RET
// every 5 5$30 + 4 4$00 trigger not legionDestroyed do var i , tmp , target , p ;
8376: LD_EXP 3
8380: NOT
8381: IFFALSE 9394
8383: GO 8385
8385: DISABLE
8386: LD_INT 0
8388: PPUSH
8389: PPUSH
8390: PPUSH
8391: PPUSH
// begin enable ;
8392: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8393: LD_INT 22
8395: PUSH
8396: LD_INT 8
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PUSH
8403: LD_INT 23
8405: PUSH
8406: LD_INT 2
8408: PUSH
8409: EMPTY
8410: LIST
8411: LIST
8412: PUSH
8413: LD_INT 30
8415: PUSH
8416: LD_INT 3
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: LIST
8427: PPUSH
8428: CALL_OW 69
8432: NOT
8433: IFFALSE 8437
// exit ;
8435: GO 9394
// if Prob ( 40 ) then
8437: LD_INT 40
8439: PPUSH
8440: CALL_OW 13
8444: IFFALSE 8571
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 14
8451: PUSH
8452: LD_INT 1
8454: PUSH
8455: LD_INT 2
8457: PUSH
8458: LD_INT 28
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: LIST
8465: LIST
8466: PUSH
8467: LD_INT 14
8469: PUSH
8470: LD_INT 1
8472: PUSH
8473: LD_INT 2
8475: PUSH
8476: LD_INT 28
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: LIST
8483: LIST
8484: PUSH
8485: LD_INT 14
8487: PUSH
8488: LD_INT 1
8490: PUSH
8491: LD_INT 2
8493: PUSH
8494: LD_INT 28
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_INT 14
8505: PUSH
8506: LD_INT 1
8508: PUSH
8509: LD_INT 2
8511: PUSH
8512: LD_INT 28
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: LIST
8519: LIST
8520: PUSH
8521: LD_INT 14
8523: PUSH
8524: LD_INT 1
8526: PUSH
8527: LD_INT 2
8529: PUSH
8530: LD_INT 28
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_INT 14
8541: PUSH
8542: LD_INT 1
8544: PUSH
8545: LD_INT 2
8547: PUSH
8548: LD_INT 26
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: PPUSH
8565: CALL 47949 0 2
// end else
8569: GO 8778
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8571: LD_INT 3
8573: PPUSH
8574: LD_INT 14
8576: PUSH
8577: LD_INT 1
8579: PUSH
8580: LD_INT 2
8582: PUSH
8583: LD_INT 27
8585: PUSH
8586: LD_INT 26
8588: PUSH
8589: LD_INT 26
8591: PUSH
8592: LD_INT 28
8594: PUSH
8595: EMPTY
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: PUSH
8601: LD_OWVAR 67
8605: ARRAY
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: LIST
8611: LIST
8612: PUSH
8613: LD_INT 14
8615: PUSH
8616: LD_INT 1
8618: PUSH
8619: LD_INT 2
8621: PUSH
8622: LD_INT 27
8624: PUSH
8625: LD_INT 26
8627: PUSH
8628: LD_INT 26
8630: PUSH
8631: LD_INT 26
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: LIST
8638: LIST
8639: PUSH
8640: LD_OWVAR 67
8644: ARRAY
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: LIST
8650: LIST
8651: PUSH
8652: LD_INT 14
8654: PUSH
8655: LD_INT 1
8657: PUSH
8658: LD_INT 2
8660: PUSH
8661: LD_INT 26
8663: PUSH
8664: LD_INT 26
8666: PUSH
8667: LD_INT 29
8669: PUSH
8670: LD_INT 29
8672: PUSH
8673: EMPTY
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: PUSH
8679: LD_OWVAR 67
8683: ARRAY
8684: PUSH
8685: EMPTY
8686: LIST
8687: LIST
8688: LIST
8689: LIST
8690: PUSH
8691: LD_INT 13
8693: PUSH
8694: LD_INT 1
8696: PUSH
8697: LD_INT 2
8699: PUSH
8700: LD_INT 26
8702: PUSH
8703: LD_INT 29
8705: PUSH
8706: LD_INT 29
8708: PUSH
8709: LD_INT 29
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: PUSH
8718: LD_OWVAR 67
8722: ARRAY
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: LIST
8728: LIST
8729: PUSH
8730: LD_INT 13
8732: PUSH
8733: LD_INT 1
8735: PUSH
8736: LD_INT 2
8738: PUSH
8739: LD_INT 29
8741: PUSH
8742: EMPTY
8743: LIST
8744: LIST
8745: LIST
8746: LIST
8747: PUSH
8748: LD_INT 14
8750: PUSH
8751: LD_INT 1
8753: PUSH
8754: LD_INT 2
8756: PUSH
8757: LD_INT 26
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: LIST
8764: LIST
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: LIST
8770: LIST
8771: LIST
8772: LIST
8773: PPUSH
8774: CALL 47949 0 2
// end ; p := 0 ;
8778: LD_ADDR_VAR 0 4
8782: PUSH
8783: LD_INT 0
8785: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8786: LD_INT 35
8788: PPUSH
8789: CALL_OW 67
// p := Inc ( p ) ;
8793: LD_ADDR_VAR 0 4
8797: PUSH
8798: LD_VAR 0 4
8802: PPUSH
8803: CALL 94046 0 1
8807: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8808: LD_INT 3
8810: PPUSH
8811: LD_INT 1
8813: PPUSH
8814: CALL 49405 0 2
8818: PUSH
8819: LD_INT 6
8821: GREATEREQUAL
8822: IFTRUE 8834
8824: PUSH
8825: LD_VAR 0 4
8829: PUSH
8830: LD_INT 100
8832: GREATER
8833: OR
8834: IFFALSE 8786
// wait ( 0 0$30 ) ;
8836: LD_INT 1050
8838: PPUSH
8839: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
8843: LD_ADDR_VAR 0 2
8847: PUSH
8848: LD_INT 22
8850: PUSH
8851: LD_INT 8
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 21
8860: PUSH
8861: LD_INT 2
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: LD_INT 3
8870: PUSH
8871: LD_INT 34
8873: PUSH
8874: LD_INT 31
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: PUSH
8885: LD_INT 3
8887: PUSH
8888: LD_INT 34
8890: PUSH
8891: LD_INT 32
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: PUSH
8902: LD_INT 3
8904: PUSH
8905: LD_INT 34
8907: PUSH
8908: LD_INT 88
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: LIST
8925: PPUSH
8926: CALL_OW 69
8930: PUSH
8931: LD_EXP 102
8935: PUSH
8936: LD_INT 3
8938: ARRAY
8939: DIFF
8940: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8941: LD_ADDR_EXP 99
8945: PUSH
8946: LD_EXP 99
8950: PPUSH
8951: LD_INT 3
8953: PPUSH
8954: LD_EXP 99
8958: PUSH
8959: LD_INT 3
8961: ARRAY
8962: PUSH
8963: LD_VAR 0 2
8967: DIFF
8968: PPUSH
8969: CALL_OW 1
8973: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8974: LD_ADDR_VAR 0 3
8978: PUSH
8979: LD_INT 0
8981: PPUSH
8982: LD_INT 2
8984: PPUSH
8985: CALL_OW 12
8989: ST_TO_ADDR
// p := 0 ;
8990: LD_ADDR_VAR 0 4
8994: PUSH
8995: LD_INT 0
8997: ST_TO_ADDR
// if target then
8998: LD_VAR 0 3
9002: IFFALSE 9157
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9004: LD_ADDR_VAR 0 2
9008: PUSH
9009: LD_VAR 0 2
9013: PPUSH
9014: LD_INT 24
9016: PUSH
9017: LD_INT 250
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PPUSH
9024: CALL_OW 72
9028: ST_TO_ADDR
// for i in tmp do
9029: LD_ADDR_VAR 0 1
9033: PUSH
9034: LD_VAR 0 2
9038: PUSH
9039: FOR_IN
9040: IFFALSE 9080
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
9042: LD_VAR 0 1
9046: PPUSH
9047: LD_INT 89
9049: PPUSH
9050: LD_INT 71
9052: PPUSH
9053: CALL_OW 297
9057: PUSH
9058: LD_INT 9
9060: GREATER
9061: IFFALSE 9078
// ComMoveXY ( i , 89 , 71 ) ;
9063: LD_VAR 0 1
9067: PPUSH
9068: LD_INT 89
9070: PPUSH
9071: LD_INT 71
9073: PPUSH
9074: CALL_OW 111
9078: GO 9039
9080: POP
9081: POP
// wait ( 0 0$1 ) ;
9082: LD_INT 35
9084: PPUSH
9085: CALL_OW 67
// p := Inc ( p ) ;
9089: LD_ADDR_VAR 0 4
9093: PUSH
9094: LD_VAR 0 4
9098: PPUSH
9099: CALL 94046 0 1
9103: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9104: LD_VAR 0 2
9108: PPUSH
9109: LD_INT 92
9111: PUSH
9112: LD_INT 89
9114: PUSH
9115: LD_INT 71
9117: PUSH
9118: LD_INT 9
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: LIST
9125: LIST
9126: PPUSH
9127: CALL_OW 72
9131: PUSH
9132: LD_VAR 0 2
9136: PUSH
9137: LD_INT 1
9139: MINUS
9140: GREATEREQUAL
9141: IFTRUE 9153
9143: PUSH
9144: LD_VAR 0 4
9148: PUSH
9149: LD_INT 30
9151: GREATER
9152: OR
9153: IFFALSE 9004
// end else
9155: GO 9308
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9157: LD_ADDR_VAR 0 2
9161: PUSH
9162: LD_VAR 0 2
9166: PPUSH
9167: LD_INT 24
9169: PUSH
9170: LD_INT 250
9172: PUSH
9173: EMPTY
9174: LIST
9175: LIST
9176: PPUSH
9177: CALL_OW 72
9181: ST_TO_ADDR
// for i in tmp do
9182: LD_ADDR_VAR 0 1
9186: PUSH
9187: LD_VAR 0 2
9191: PUSH
9192: FOR_IN
9193: IFFALSE 9233
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
9195: LD_VAR 0 1
9199: PPUSH
9200: LD_INT 147
9202: PPUSH
9203: LD_INT 4
9205: PPUSH
9206: CALL_OW 297
9210: PUSH
9211: LD_INT 9
9213: GREATER
9214: IFFALSE 9231
// ComMoveXY ( i , 147 , 4 ) ;
9216: LD_VAR 0 1
9220: PPUSH
9221: LD_INT 147
9223: PPUSH
9224: LD_INT 4
9226: PPUSH
9227: CALL_OW 111
9231: GO 9192
9233: POP
9234: POP
// wait ( 0 0$1 ) ;
9235: LD_INT 35
9237: PPUSH
9238: CALL_OW 67
// p := Inc ( p ) ;
9242: LD_ADDR_VAR 0 4
9246: PUSH
9247: LD_VAR 0 4
9251: PPUSH
9252: CALL 94046 0 1
9256: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9257: LD_VAR 0 2
9261: PPUSH
9262: LD_INT 92
9264: PUSH
9265: LD_INT 147
9267: PUSH
9268: LD_INT 4
9270: PUSH
9271: LD_INT 9
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: LIST
9278: LIST
9279: PPUSH
9280: CALL_OW 72
9284: PUSH
9285: LD_VAR 0 2
9289: PUSH
9290: LD_INT 1
9292: MINUS
9293: GREATEREQUAL
9294: IFTRUE 9306
9296: PUSH
9297: LD_VAR 0 4
9301: PUSH
9302: LD_INT 30
9304: GREATER
9305: OR
9306: IFFALSE 9157
// end ; repeat wait ( 0 0$1 ) ;
9308: LD_INT 35
9310: PPUSH
9311: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
9315: LD_ADDR_VAR 0 2
9319: PUSH
9320: LD_VAR 0 2
9324: PPUSH
9325: LD_INT 50
9327: PUSH
9328: EMPTY
9329: LIST
9330: PPUSH
9331: CALL_OW 72
9335: ST_TO_ADDR
// for i in tmp do
9336: LD_ADDR_VAR 0 1
9340: PUSH
9341: LD_VAR 0 2
9345: PUSH
9346: FOR_IN
9347: IFFALSE 9385
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
9349: LD_VAR 0 1
9353: PPUSH
9354: LD_INT 81
9356: PUSH
9357: LD_INT 8
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PPUSH
9364: CALL_OW 69
9368: PPUSH
9369: LD_VAR 0 1
9373: PPUSH
9374: CALL_OW 74
9378: PPUSH
9379: CALL_OW 115
9383: GO 9346
9385: POP
9386: POP
// until not tmp ;
9387: LD_VAR 0 2
9391: NOT
9392: IFFALSE 9308
// end ;
9394: PPOPN 4
9396: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
9397: LD_EXP 60
9401: PPUSH
9402: CALL_OW 302
9406: IFFALSE 9415
9408: PUSH
9409: LD_EXP 3
9413: NOT
9414: AND
9415: IFFALSE 9424
9417: GO 9419
9419: DISABLE
// BuildKozlovBomb ;
9420: CALL 8247 0 0
9424: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9425: LD_INT 22
9427: PUSH
9428: LD_INT 8
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: PUSH
9435: LD_INT 34
9437: PUSH
9438: LD_INT 48
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: PPUSH
9449: CALL_OW 69
9453: IFFALSE 9501
9455: GO 9457
9457: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9458: LD_INT 22
9460: PUSH
9461: LD_INT 8
9463: PUSH
9464: EMPTY
9465: LIST
9466: LIST
9467: PUSH
9468: LD_INT 34
9470: PUSH
9471: LD_INT 48
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: PUSH
9478: EMPTY
9479: LIST
9480: LIST
9481: PPUSH
9482: CALL_OW 69
9486: PUSH
9487: LD_INT 1
9489: ARRAY
9490: PPUSH
9491: LD_INT 173
9493: PPUSH
9494: LD_INT 96
9496: PPUSH
9497: CALL_OW 116
// end ; end_of_file
9501: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9502: LD_INT 0
9504: PPUSH
9505: PPUSH
9506: PPUSH
9507: PPUSH
9508: PPUSH
9509: PPUSH
9510: PPUSH
9511: PPUSH
9512: PPUSH
9513: PPUSH
// side := 3 ;
9514: LD_ADDR_VAR 0 6
9518: PUSH
9519: LD_INT 3
9521: ST_TO_ADDR
// InitHc ;
9522: CALL_OW 19
// uc_side := side ;
9526: LD_ADDR_OWVAR 20
9530: PUSH
9531: LD_VAR 0 6
9535: ST_TO_ADDR
// uc_nation := 3 ;
9536: LD_ADDR_OWVAR 21
9540: PUSH
9541: LD_INT 3
9543: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9544: LD_ADDR_VAR 0 2
9548: PUSH
9549: LD_INT 22
9551: PUSH
9552: LD_VAR 0 6
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: LD_INT 21
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: PPUSH
9575: CALL_OW 69
9579: PUSH
9580: FOR_IN
9581: IFFALSE 9597
// SetBLevel ( i , 10 ) ;
9583: LD_VAR 0 2
9587: PPUSH
9588: LD_INT 10
9590: PPUSH
9591: CALL_OW 241
9595: GO 9580
9597: POP
9598: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9599: LD_ADDR_VAR 0 10
9603: PUSH
9604: LD_INT 22
9606: PUSH
9607: LD_VAR 0 6
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: PUSH
9616: LD_INT 30
9618: PUSH
9619: LD_INT 34
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: PUSH
9626: EMPTY
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL_OW 69
9634: ST_TO_ADDR
// if teleport then
9635: LD_VAR 0 10
9639: IFFALSE 9660
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9641: LD_VAR 0 10
9645: PUSH
9646: LD_INT 1
9648: ARRAY
9649: PPUSH
9650: LD_INT 123
9652: PPUSH
9653: LD_INT 122
9655: PPUSH
9656: CALL_OW 243
// hc_importance := 0 ;
9660: LD_ADDR_OWVAR 32
9664: PUSH
9665: LD_INT 0
9667: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9668: LD_ADDR_EXP 62
9672: PUSH
9673: LD_STRING Platonov
9675: PPUSH
9676: CALL_OW 25
9680: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9681: LD_ADDR_EXP 63
9685: PUSH
9686: LD_STRING Yakotich
9688: PPUSH
9689: LD_EXP 1
9693: NOT
9694: PPUSH
9695: LD_STRING 09_
9697: PPUSH
9698: CALL 54473 0 3
9702: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9703: LD_ADDR_EXP 64
9707: PUSH
9708: LD_STRING Gleb
9710: PPUSH
9711: CALL_OW 25
9715: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9716: LD_STRING 03_Cornel
9718: PPUSH
9719: CALL_OW 28
9723: IFFALSE 9771
// begin Bierezov := NewCharacter ( Mikhail ) ;
9725: LD_ADDR_EXP 65
9729: PUSH
9730: LD_STRING Mikhail
9732: PPUSH
9733: CALL_OW 25
9737: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9738: LD_EXP 65
9742: PPUSH
9743: LD_INT 197
9745: PPUSH
9746: LD_INT 111
9748: PPUSH
9749: LD_INT 9
9751: PPUSH
9752: LD_INT 0
9754: PPUSH
9755: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9759: LD_EXP 65
9763: PPUSH
9764: LD_INT 3
9766: PPUSH
9767: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9771: LD_EXP 62
9775: PPUSH
9776: LD_INT 126
9778: PPUSH
9779: CALL_OW 52
// if Yakotich then
9783: LD_EXP 63
9787: IFFALSE 9810
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9789: LD_EXP 63
9793: PPUSH
9794: LD_INT 197
9796: PPUSH
9797: LD_INT 111
9799: PPUSH
9800: LD_INT 9
9802: PPUSH
9803: LD_INT 0
9805: PPUSH
9806: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9810: LD_EXP 64
9814: PPUSH
9815: LD_INT 197
9817: PPUSH
9818: LD_INT 111
9820: PPUSH
9821: LD_INT 9
9823: PPUSH
9824: LD_INT 0
9826: PPUSH
9827: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9831: LD_ADDR_VAR 0 5
9835: PUSH
9836: LD_INT 126
9838: PPUSH
9839: LD_INT 2
9841: PPUSH
9842: LD_STRING zhukov
9844: PPUSH
9845: LD_INT 9
9847: PUSH
9848: LD_INT 10
9850: PUSH
9851: LD_INT 10
9853: PUSH
9854: LD_INT 10
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_OWVAR 67
9867: ARRAY
9868: PPUSH
9869: LD_INT 9000
9871: PUSH
9872: LD_INT 1000
9874: PUSH
9875: LD_INT 300
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: LIST
9882: PPUSH
9883: LD_INT 21
9885: PUSH
9886: LD_INT 8
9888: PUSH
9889: LD_INT 13
9891: PUSH
9892: LD_INT 8
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: LIST
9899: LIST
9900: PPUSH
9901: CALL 63330 0 6
9905: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9906: LD_ADDR_EXP 80
9910: PUSH
9911: LD_EXP 80
9915: PPUSH
9916: LD_INT 2
9918: PPUSH
9919: LD_VAR 0 5
9923: PUSH
9924: LD_EXP 63
9928: PUSH
9929: LD_EXP 64
9933: PUSH
9934: LD_EXP 65
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: LIST
9943: UNION
9944: PPUSH
9945: CALL_OW 1
9949: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9950: LD_ADDR_VAR 0 4
9954: PUSH
9955: LD_INT 267
9957: PPUSH
9958: CALL_OW 274
9962: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9963: LD_VAR 0 4
9967: PPUSH
9968: LD_INT 1
9970: PPUSH
9971: LD_INT 5000
9973: PPUSH
9974: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9978: LD_VAR 0 4
9982: PPUSH
9983: LD_INT 2
9985: PPUSH
9986: LD_INT 200
9988: PPUSH
9989: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9993: LD_VAR 0 4
9997: PPUSH
9998: LD_INT 3
10000: PPUSH
10001: LD_INT 200
10003: PPUSH
10004: CALL_OW 277
// for i := 1 to 6 do
10008: LD_ADDR_VAR 0 2
10012: PUSH
10013: DOUBLE
10014: LD_INT 1
10016: DEC
10017: ST_TO_ADDR
10018: LD_INT 6
10020: PUSH
10021: FOR_TO
10022: IFFALSE 10105
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
10024: LD_INT 0
10026: PPUSH
10027: LD_INT 8
10029: PUSH
10030: LD_INT 9
10032: PUSH
10033: LD_INT 10
10035: PUSH
10036: LD_INT 10
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: LIST
10043: LIST
10044: PUSH
10045: LD_OWVAR 67
10049: ARRAY
10050: PPUSH
10051: CALL_OW 381
// un := CreateHuman ;
10055: LD_ADDR_VAR 0 8
10059: PUSH
10060: CALL_OW 44
10064: ST_TO_ADDR
// if i mod 2 = 0 then
10065: LD_VAR 0 2
10069: PUSH
10070: LD_INT 2
10072: MOD
10073: PUSH
10074: LD_INT 0
10076: EQUAL
10077: IFFALSE 10091
// SetClass ( un , class_bazooker ) ;
10079: LD_VAR 0 8
10083: PPUSH
10084: LD_INT 9
10086: PPUSH
10087: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
10091: LD_VAR 0 8
10095: PPUSH
10096: LD_INT 674
10098: PPUSH
10099: CALL_OW 52
// end ;
10103: GO 10021
10105: POP
10106: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
10107: LD_INT 21
10109: PPUSH
10110: LD_INT 3
10112: PPUSH
10113: LD_INT 3
10115: PPUSH
10116: LD_INT 52
10118: PPUSH
10119: LD_INT 100
10121: PPUSH
10122: CALL 59493 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
10126: CALL_OW 45
10130: PPUSH
10131: LD_INT 259
10133: PPUSH
10134: LD_INT 145
10136: PPUSH
10137: LD_INT 3
10139: PPUSH
10140: LD_INT 0
10142: PPUSH
10143: CALL 94833 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
10147: CALL_OW 45
10151: PPUSH
10152: LD_INT 245
10154: PPUSH
10155: LD_INT 139
10157: PPUSH
10158: LD_INT 3
10160: PPUSH
10161: LD_INT 0
10163: PPUSH
10164: CALL 94833 0 5
// behemoths := [ ] ;
10168: LD_ADDR_EXP 66
10172: PUSH
10173: EMPTY
10174: ST_TO_ADDR
// behemothBuilders := [ ] ;
10175: LD_ADDR_EXP 67
10179: PUSH
10180: EMPTY
10181: ST_TO_ADDR
// j := 3 ;
10182: LD_ADDR_VAR 0 3
10186: PUSH
10187: LD_INT 3
10189: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
10190: LD_ADDR_VAR 0 2
10194: PUSH
10195: LD_INT 22
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 25
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 69
10223: PUSH
10224: FOR_IN
10225: IFFALSE 10275
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
10227: LD_ADDR_EXP 67
10231: PUSH
10232: LD_EXP 67
10236: PPUSH
10237: LD_VAR 0 2
10241: PPUSH
10242: CALL 92673 0 2
10246: ST_TO_ADDR
// j := j - 1 ;
10247: LD_ADDR_VAR 0 3
10251: PUSH
10252: LD_VAR 0 3
10256: PUSH
10257: LD_INT 1
10259: MINUS
10260: ST_TO_ADDR
// if j = 0 then
10261: LD_VAR 0 3
10265: PUSH
10266: LD_INT 0
10268: EQUAL
10269: IFFALSE 10273
// break ;
10271: GO 10275
// end ;
10273: GO 10224
10275: POP
10276: POP
// end ;
10277: LD_VAR 0 1
10281: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
10282: LD_INT 0
10284: PPUSH
10285: PPUSH
10286: PPUSH
10287: PPUSH
10288: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
10289: LD_ADDR_VAR 0 4
10293: PUSH
10294: LD_INT 209
10296: PUSH
10297: LD_INT 149
10299: PUSH
10300: EMPTY
10301: LIST
10302: LIST
10303: PUSH
10304: LD_INT 219
10306: PUSH
10307: LD_INT 154
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: PUSH
10314: LD_INT 223
10316: PUSH
10317: LD_INT 149
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PUSH
10324: LD_INT 232
10326: PUSH
10327: LD_INT 155
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: ST_TO_ADDR
// if not behemothBuilders then
10340: LD_EXP 67
10344: NOT
10345: IFFALSE 10349
// exit ;
10347: GO 10453
// j := 1 ;
10349: LD_ADDR_VAR 0 3
10353: PUSH
10354: LD_INT 1
10356: ST_TO_ADDR
// for i in behemothBuilders do
10357: LD_ADDR_VAR 0 2
10361: PUSH
10362: LD_EXP 67
10366: PUSH
10367: FOR_IN
10368: IFFALSE 10451
// begin if IsInUnit ( i ) then
10370: LD_VAR 0 2
10374: PPUSH
10375: CALL_OW 310
10379: IFFALSE 10390
// ComExitBuilding ( i ) ;
10381: LD_VAR 0 2
10385: PPUSH
10386: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
10390: LD_VAR 0 2
10394: PPUSH
10395: LD_INT 37
10397: PPUSH
10398: LD_VAR 0 4
10402: PUSH
10403: LD_VAR 0 3
10407: ARRAY
10408: PUSH
10409: LD_INT 1
10411: ARRAY
10412: PPUSH
10413: LD_VAR 0 4
10417: PUSH
10418: LD_VAR 0 3
10422: ARRAY
10423: PUSH
10424: LD_INT 2
10426: ARRAY
10427: PPUSH
10428: LD_INT 0
10430: PPUSH
10431: CALL_OW 230
// j := j + 1 ;
10435: LD_ADDR_VAR 0 3
10439: PUSH
10440: LD_VAR 0 3
10444: PUSH
10445: LD_INT 1
10447: PLUS
10448: ST_TO_ADDR
// end ;
10449: GO 10367
10451: POP
10452: POP
// end ;
10453: LD_VAR 0 1
10457: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10458: LD_INT 3
10460: PPUSH
10461: CALL 92734 0 1
10465: IFFALSE 10498
10467: PUSH
10468: LD_INT 22
10470: PUSH
10471: LD_INT 3
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: PUSH
10478: LD_INT 30
10480: PUSH
10481: LD_INT 37
10483: PUSH
10484: EMPTY
10485: LIST
10486: LIST
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: PPUSH
10492: CALL_OW 69
10496: NOT
10497: AND
10498: IFFALSE 10688
10500: GO 10502
10502: DISABLE
10503: LD_INT 0
10505: PPUSH
10506: PPUSH
// begin enable ;
10507: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10508: LD_ADDR_VAR 0 2
10512: PUSH
10513: LD_INT 3
10515: PPUSH
10516: CALL 92734 0 1
10520: ST_TO_ADDR
// for i in tmp do
10521: LD_ADDR_VAR 0 1
10525: PUSH
10526: LD_VAR 0 2
10530: PUSH
10531: FOR_IN
10532: IFFALSE 10686
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10534: LD_VAR 0 1
10538: PPUSH
10539: LD_INT 7
10541: PPUSH
10542: CALL_OW 308
10546: IFFALSE 10564
10548: PUSH
10549: LD_VAR 0 1
10553: PPUSH
10554: CALL_OW 110
10558: PUSH
10559: LD_INT 2
10561: EQUAL
10562: NOT
10563: AND
10564: IFFALSE 10578
// SetTag ( i , 2 ) ;
10566: LD_VAR 0 1
10570: PPUSH
10571: LD_INT 2
10573: PPUSH
10574: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10578: LD_INT 81
10580: PUSH
10581: LD_INT 3
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PUSH
10588: LD_INT 91
10590: PUSH
10591: LD_VAR 0 1
10595: PUSH
10596: LD_INT 12
10598: PUSH
10599: EMPTY
10600: LIST
10601: LIST
10602: LIST
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: NOT
10613: IFFALSE 10631
10615: PUSH
10616: LD_VAR 0 1
10620: PPUSH
10621: CALL_OW 110
10625: PUSH
10626: LD_INT 2
10628: EQUAL
10629: NOT
10630: AND
10631: IFFALSE 10650
// ComAgressiveMove ( i , 64 , 93 ) else
10633: LD_VAR 0 1
10637: PPUSH
10638: LD_INT 64
10640: PPUSH
10641: LD_INT 93
10643: PPUSH
10644: CALL_OW 114
10648: GO 10684
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10650: LD_VAR 0 1
10654: PPUSH
10655: LD_INT 81
10657: PUSH
10658: LD_INT 3
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: PPUSH
10665: CALL_OW 69
10669: PPUSH
10670: LD_VAR 0 1
10674: PPUSH
10675: CALL_OW 74
10679: PPUSH
10680: CALL_OW 115
// end ;
10684: GO 10531
10686: POP
10687: POP
// end ;
10688: PPOPN 2
10690: END
// every 6 6$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10691: LD_EXP 2
10695: NOT
10696: IFFALSE 11788
10698: GO 10700
10700: DISABLE
10701: LD_INT 0
10703: PPUSH
10704: PPUSH
10705: PPUSH
10706: PPUSH
10707: PPUSH
// begin enable ;
10708: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10709: LD_INT 22
10711: PUSH
10712: LD_INT 3
10714: PUSH
10715: EMPTY
10716: LIST
10717: LIST
10718: PUSH
10719: LD_INT 30
10721: PUSH
10722: LD_INT 3
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PPUSH
10733: CALL_OW 69
10737: NOT
10738: IFFALSE 10742
// exit ;
10740: GO 11788
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10742: LD_ADDR_VAR 0 4
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 3
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PUSH
10757: LD_INT 30
10759: PUSH
10760: LD_INT 34
10762: PUSH
10763: EMPTY
10764: LIST
10765: LIST
10766: PUSH
10767: EMPTY
10768: LIST
10769: LIST
10770: PPUSH
10771: CALL_OW 69
10775: ST_TO_ADDR
// if Prob ( 40 ) then
10776: LD_INT 40
10778: PPUSH
10779: CALL_OW 13
10783: IFFALSE 10910
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10785: LD_INT 2
10787: PPUSH
10788: LD_INT 22
10790: PUSH
10791: LD_INT 3
10793: PUSH
10794: LD_INT 3
10796: PUSH
10797: LD_INT 49
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: LIST
10804: LIST
10805: PUSH
10806: LD_INT 22
10808: PUSH
10809: LD_INT 3
10811: PUSH
10812: LD_INT 3
10814: PUSH
10815: LD_INT 49
10817: PUSH
10818: EMPTY
10819: LIST
10820: LIST
10821: LIST
10822: LIST
10823: PUSH
10824: LD_INT 22
10826: PUSH
10827: LD_INT 3
10829: PUSH
10830: LD_INT 3
10832: PUSH
10833: LD_INT 49
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: PUSH
10842: LD_INT 24
10844: PUSH
10845: LD_INT 3
10847: PUSH
10848: LD_INT 3
10850: PUSH
10851: LD_INT 46
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: PUSH
10860: LD_INT 24
10862: PUSH
10863: LD_INT 3
10865: PUSH
10866: LD_INT 3
10868: PUSH
10869: LD_INT 46
10871: PUSH
10872: EMPTY
10873: LIST
10874: LIST
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 24
10880: PUSH
10881: LD_INT 3
10883: PUSH
10884: LD_INT 3
10886: PUSH
10887: LD_INT 46
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: LIST
10894: LIST
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: PPUSH
10904: CALL 47949 0 2
// end else
10908: GO 11033
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10910: LD_INT 2
10912: PPUSH
10913: LD_INT 24
10915: PUSH
10916: LD_INT 3
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: LD_INT 47
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: PUSH
10931: LD_INT 24
10933: PUSH
10934: LD_INT 3
10936: PUSH
10937: LD_INT 3
10939: PUSH
10940: LD_INT 47
10942: PUSH
10943: EMPTY
10944: LIST
10945: LIST
10946: LIST
10947: LIST
10948: PUSH
10949: LD_INT 24
10951: PUSH
10952: LD_INT 3
10954: PUSH
10955: LD_INT 3
10957: PUSH
10958: LD_INT 47
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: LIST
10965: LIST
10966: PUSH
10967: LD_INT 24
10969: PUSH
10970: LD_INT 3
10972: PUSH
10973: LD_INT 3
10975: PUSH
10976: LD_INT 46
10978: PUSH
10979: EMPTY
10980: LIST
10981: LIST
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 24
10987: PUSH
10988: LD_INT 3
10990: PUSH
10991: LD_INT 3
10993: PUSH
10994: LD_INT 46
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: LIST
11001: LIST
11002: PUSH
11003: LD_INT 24
11005: PUSH
11006: LD_INT 3
11008: PUSH
11009: LD_INT 3
11011: PUSH
11012: LD_INT 46
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: PUSH
11021: EMPTY
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: PPUSH
11029: CALL 47949 0 2
// end ; if Difficulty > 1 then
11033: LD_OWVAR 67
11037: PUSH
11038: LD_INT 1
11040: GREATER
11041: IFFALSE 11071
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
11043: LD_INT 2
11045: PPUSH
11046: LD_INT 24
11048: PUSH
11049: LD_INT 3
11051: PUSH
11052: LD_INT 3
11054: PUSH
11055: LD_INT 47
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: LIST
11062: LIST
11063: PUSH
11064: EMPTY
11065: LIST
11066: PPUSH
11067: CALL 47949 0 2
// p := 0 ;
11071: LD_ADDR_VAR 0 5
11075: PUSH
11076: LD_INT 0
11078: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11079: LD_INT 35
11081: PPUSH
11082: CALL_OW 67
// p := Inc ( p ) ;
11086: LD_ADDR_VAR 0 5
11090: PUSH
11091: LD_VAR 0 5
11095: PPUSH
11096: CALL 94046 0 1
11100: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 120 ;
11101: LD_INT 2
11103: PPUSH
11104: LD_INT 1
11106: PPUSH
11107: CALL 49405 0 2
11111: PUSH
11112: LD_INT 6
11114: PUSH
11115: LD_INT 7
11117: PUSH
11118: LD_INT 7
11120: PUSH
11121: LD_INT 7
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: LIST
11128: LIST
11129: PUSH
11130: LD_OWVAR 67
11134: ARRAY
11135: GREATEREQUAL
11136: IFTRUE 11148
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_INT 120
11146: GREATER
11147: OR
11148: IFFALSE 11079
// wait ( 0 0$30 ) ;
11150: LD_INT 1050
11152: PPUSH
11153: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11157: LD_ADDR_VAR 0 2
11161: PUSH
11162: LD_INT 22
11164: PUSH
11165: LD_INT 3
11167: PUSH
11168: EMPTY
11169: LIST
11170: LIST
11171: PUSH
11172: LD_INT 23
11174: PUSH
11175: LD_INT 3
11177: PUSH
11178: EMPTY
11179: LIST
11180: LIST
11181: PUSH
11182: LD_INT 21
11184: PUSH
11185: LD_INT 2
11187: PUSH
11188: EMPTY
11189: LIST
11190: LIST
11191: PUSH
11192: LD_INT 3
11194: PUSH
11195: LD_INT 34
11197: PUSH
11198: LD_INT 48
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: PUSH
11209: LD_INT 3
11211: PUSH
11212: LD_INT 34
11214: PUSH
11215: LD_INT 51
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: LD_INT 3
11228: PUSH
11229: LD_INT 34
11231: PUSH
11232: LD_INT 52
11234: PUSH
11235: EMPTY
11236: LIST
11237: LIST
11238: PUSH
11239: EMPTY
11240: LIST
11241: LIST
11242: PUSH
11243: EMPTY
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: PPUSH
11251: CALL_OW 69
11255: PUSH
11256: LD_EXP 102
11260: PUSH
11261: LD_INT 2
11263: ARRAY
11264: DIFF
11265: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11266: LD_ADDR_EXP 99
11270: PUSH
11271: LD_EXP 99
11275: PPUSH
11276: LD_INT 2
11278: PPUSH
11279: LD_EXP 99
11283: PUSH
11284: LD_INT 2
11286: ARRAY
11287: PUSH
11288: LD_VAR 0 2
11292: DIFF
11293: PPUSH
11294: CALL_OW 1
11298: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11299: LD_ADDR_VAR 0 3
11303: PUSH
11304: LD_INT 0
11306: PPUSH
11307: LD_INT 1
11309: PPUSH
11310: CALL_OW 12
11314: ST_TO_ADDR
// p := 0 ;
11315: LD_ADDR_VAR 0 5
11319: PUSH
11320: LD_INT 0
11322: ST_TO_ADDR
// if target then
11323: LD_VAR 0 3
11327: IFFALSE 11482
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11329: LD_ADDR_VAR 0 2
11333: PUSH
11334: LD_VAR 0 2
11338: PPUSH
11339: LD_INT 24
11341: PUSH
11342: LD_INT 250
11344: PUSH
11345: EMPTY
11346: LIST
11347: LIST
11348: PPUSH
11349: CALL_OW 72
11353: ST_TO_ADDR
// for i in tmp do
11354: LD_ADDR_VAR 0 1
11358: PUSH
11359: LD_VAR 0 2
11363: PUSH
11364: FOR_IN
11365: IFFALSE 11405
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11367: LD_VAR 0 1
11371: PPUSH
11372: LD_INT 139
11374: PPUSH
11375: LD_INT 89
11377: PPUSH
11378: CALL_OW 297
11382: PUSH
11383: LD_INT 9
11385: GREATER
11386: IFFALSE 11403
// ComMoveXY ( i , 139 , 89 ) ;
11388: LD_VAR 0 1
11392: PPUSH
11393: LD_INT 139
11395: PPUSH
11396: LD_INT 89
11398: PPUSH
11399: CALL_OW 111
11403: GO 11364
11405: POP
11406: POP
// wait ( 0 0$1 ) ;
11407: LD_INT 35
11409: PPUSH
11410: CALL_OW 67
// p := Inc ( p ) ;
11414: LD_ADDR_VAR 0 5
11418: PUSH
11419: LD_VAR 0 5
11423: PPUSH
11424: CALL 94046 0 1
11428: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11429: LD_VAR 0 2
11433: PPUSH
11434: LD_INT 92
11436: PUSH
11437: LD_INT 139
11439: PUSH
11440: LD_INT 89
11442: PUSH
11443: LD_INT 9
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: PPUSH
11452: CALL_OW 72
11456: PUSH
11457: LD_VAR 0 2
11461: PUSH
11462: LD_INT 1
11464: MINUS
11465: GREATEREQUAL
11466: IFTRUE 11478
11468: PUSH
11469: LD_VAR 0 5
11473: PUSH
11474: LD_INT 30
11476: GREATER
11477: OR
11478: IFFALSE 11329
// end else
11480: GO 11651
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11482: LD_VAR 0 2
11486: PPUSH
11487: LD_VAR 0 4
11491: PUSH
11492: LD_INT 1
11494: ARRAY
11495: PPUSH
11496: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11500: LD_ADDR_VAR 0 2
11504: PUSH
11505: LD_VAR 0 2
11509: PPUSH
11510: LD_INT 24
11512: PUSH
11513: LD_INT 250
11515: PUSH
11516: EMPTY
11517: LIST
11518: LIST
11519: PPUSH
11520: CALL_OW 72
11524: ST_TO_ADDR
// for i in tmp do
11525: LD_ADDR_VAR 0 1
11529: PUSH
11530: LD_VAR 0 2
11534: PUSH
11535: FOR_IN
11536: IFFALSE 11576
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11538: LD_VAR 0 1
11542: PPUSH
11543: LD_INT 124
11545: PPUSH
11546: LD_INT 139
11548: PPUSH
11549: CALL_OW 297
11553: PUSH
11554: LD_INT 9
11556: GREATER
11557: IFFALSE 11574
// ComMoveXY ( i , 124 , 139 ) ;
11559: LD_VAR 0 1
11563: PPUSH
11564: LD_INT 124
11566: PPUSH
11567: LD_INT 139
11569: PPUSH
11570: CALL_OW 111
11574: GO 11535
11576: POP
11577: POP
// wait ( 0 0$1 ) ;
11578: LD_INT 35
11580: PPUSH
11581: CALL_OW 67
// p := Inc ( p ) ;
11585: LD_ADDR_VAR 0 5
11589: PUSH
11590: LD_VAR 0 5
11594: PPUSH
11595: CALL 94046 0 1
11599: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11600: LD_VAR 0 2
11604: PPUSH
11605: LD_INT 92
11607: PUSH
11608: LD_INT 124
11610: PUSH
11611: LD_INT 139
11613: PUSH
11614: LD_INT 9
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: PPUSH
11623: CALL_OW 72
11627: PUSH
11628: LD_VAR 0 2
11632: PUSH
11633: LD_INT 1
11635: MINUS
11636: GREATEREQUAL
11637: IFTRUE 11649
11639: PUSH
11640: LD_VAR 0 5
11644: PUSH
11645: LD_INT 30
11647: GREATER
11648: OR
11649: IFFALSE 11500
// end ; repeat wait ( 0 0$1 ) ;
11651: LD_INT 35
11653: PPUSH
11654: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11658: LD_ADDR_VAR 0 2
11662: PUSH
11663: LD_VAR 0 2
11667: PPUSH
11668: LD_INT 50
11670: PUSH
11671: EMPTY
11672: LIST
11673: PPUSH
11674: CALL_OW 72
11678: ST_TO_ADDR
// for i in tmp do
11679: LD_ADDR_VAR 0 1
11683: PUSH
11684: LD_VAR 0 2
11688: PUSH
11689: FOR_IN
11690: IFFALSE 11779
// begin if GetWeapon ( i ) = ru_time_lapser then
11692: LD_VAR 0 1
11696: PPUSH
11697: CALL_OW 264
11701: PUSH
11702: LD_INT 49
11704: EQUAL
11705: IFFALSE 11743
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11707: LD_VAR 0 1
11711: PPUSH
11712: LD_INT 81
11714: PUSH
11715: LD_INT 3
11717: PUSH
11718: EMPTY
11719: LIST
11720: LIST
11721: PPUSH
11722: CALL_OW 69
11726: PPUSH
11727: LD_VAR 0 1
11731: PPUSH
11732: CALL_OW 74
11736: PPUSH
11737: CALL_OW 112
11741: GO 11777
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11743: LD_VAR 0 1
11747: PPUSH
11748: LD_INT 81
11750: PUSH
11751: LD_INT 3
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PPUSH
11758: CALL_OW 69
11762: PPUSH
11763: LD_VAR 0 1
11767: PPUSH
11768: CALL_OW 74
11772: PPUSH
11773: CALL_OW 115
// end ;
11777: GO 11689
11779: POP
11780: POP
// until not tmp ;
11781: LD_VAR 0 2
11785: NOT
11786: IFFALSE 11651
// end ;
11788: PPOPN 5
11790: END
// every 30 30$00 trigger not russianDestroyed do
11791: LD_EXP 2
11795: NOT
11796: IFFALSE 11865
11798: GO 11800
11800: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11801: LD_INT 105000
11803: PUSH
11804: LD_INT 84000
11806: PUSH
11807: LD_INT 63000
11809: PUSH
11810: LD_INT 52500
11812: PUSH
11813: EMPTY
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: PUSH
11819: LD_OWVAR 67
11823: ARRAY
11824: PPUSH
11825: CALL_OW 67
// if russianDestroyed then
11829: LD_EXP 2
11833: IFFALSE 11837
// exit ;
11835: GO 11865
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11837: LD_INT 2
11839: PPUSH
11840: LD_INT 23
11842: PUSH
11843: LD_INT 3
11845: PUSH
11846: LD_INT 1
11848: PUSH
11849: LD_INT 48
11851: PUSH
11852: EMPTY
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: PUSH
11858: EMPTY
11859: LIST
11860: PPUSH
11861: CALL 47949 0 2
// end ; end_of_file
11865: END
// export function CustomEvent ( event ) ; begin
11866: LD_INT 0
11868: PPUSH
// end ;
11869: LD_VAR 0 2
11873: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11874: LD_VAR 0 2
11878: PPUSH
11879: LD_VAR 0 3
11883: PPUSH
11884: LD_INT 15
11886: PPUSH
11887: CALL_OW 309
11891: IFFALSE 11900
// YouLost ( MothContaminate ) ;
11893: LD_STRING MothContaminate
11895: PPUSH
11896: CALL_OW 104
// end ;
11900: PPOPN 3
11902: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: LD_INT 15
11915: PPUSH
11916: CALL_OW 309
11920: IFFALSE 11936
// begin wait ( 0 0$6 ) ;
11922: LD_INT 210
11924: PPUSH
11925: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11929: LD_STRING MothContaminateBomb
11931: PPUSH
11932: CALL_OW 104
// end ; end ;
11936: PPOPN 3
11938: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11939: LD_VAR 0 1
11943: PPUSH
11944: CALL 114113 0 1
// if un = JMM then
11948: LD_VAR 0 1
11952: PUSH
11953: LD_EXP 21
11957: EQUAL
11958: IFFALSE 11969
// begin YouLost ( JMM ) ;
11960: LD_STRING JMM
11962: PPUSH
11963: CALL_OW 104
// exit ;
11967: GO 12120
// end ; if un = Omar then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 58
11978: EQUAL
11979: IFFALSE 11989
// omarKilled := true ;
11981: LD_ADDR_EXP 20
11985: PUSH
11986: LD_INT 1
11988: ST_TO_ADDR
// if GetSide ( un ) = 2 and not arabianAttacked then
11989: LD_VAR 0 1
11993: PPUSH
11994: CALL_OW 255
11998: PUSH
11999: LD_INT 2
12001: EQUAL
12002: IFFALSE 12011
12004: PUSH
12005: LD_EXP 18
12009: NOT
12010: AND
12011: IFFALSE 12021
// arabianAttacked := true ;
12013: LD_ADDR_EXP 18
12017: PUSH
12018: LD_INT 1
12020: ST_TO_ADDR
// if un = Powell then
12021: LD_VAR 0 1
12025: PUSH
12026: LD_EXP 57
12030: EQUAL
12031: IFFALSE 12041
// americanDestroyed := true ;
12033: LD_ADDR_EXP 4
12037: PUSH
12038: LD_INT 1
12040: ST_TO_ADDR
// if un = Platonov then
12041: LD_VAR 0 1
12045: PUSH
12046: LD_EXP 62
12050: EQUAL
12051: IFFALSE 12061
// russianDestroyed := true ;
12053: LD_ADDR_EXP 2
12057: PUSH
12058: LD_INT 1
12060: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
12061: LD_VAR 0 1
12065: PUSH
12066: LD_INT 22
12068: PUSH
12069: LD_INT 7
12071: PUSH
12072: EMPTY
12073: LIST
12074: LIST
12075: PUSH
12076: LD_INT 21
12078: PUSH
12079: LD_INT 2
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PPUSH
12090: CALL_OW 69
12094: IN
12095: IFFALSE 12111
// vehicleLostCounter := vehicleLostCounter + 1 ;
12097: LD_ADDR_EXP 15
12101: PUSH
12102: LD_EXP 15
12106: PUSH
12107: LD_INT 1
12109: PLUS
12110: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
12111: LD_VAR 0 1
12115: PPUSH
12116: CALL 51455 0 1
// end ;
12120: PPOPN 1
12122: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12123: LD_VAR 0 1
12127: PPUSH
12128: LD_VAR 0 2
12132: PPUSH
12133: CALL 53809 0 2
// end ;
12137: PPOPN 2
12139: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12140: LD_VAR 0 1
12144: PPUSH
12145: CALL 52873 0 1
// end ;
12149: PPOPN 1
12151: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
12152: LD_VAR 0 1
12156: PUSH
12157: LD_INT 22
12159: PUSH
12160: LD_INT 8
12162: PUSH
12163: EMPTY
12164: LIST
12165: LIST
12166: PUSH
12167: LD_INT 30
12169: PUSH
12170: LD_INT 2
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: PUSH
12177: LD_INT 23
12179: PUSH
12180: LD_INT 3
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: EMPTY
12188: LIST
12189: LIST
12190: LIST
12191: PPUSH
12192: CALL_OW 69
12196: IN
12197: IFFALSE 12224
// begin ComUpgrade ( building ) ;
12199: LD_VAR 0 1
12203: PPUSH
12204: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
12208: LD_EXP 60
12212: PPUSH
12213: LD_VAR 0 1
12217: PPUSH
12218: CALL 62867 0 2
// exit ;
12222: GO 12233
// end ; MCE_BuildingComplete ( building ) ;
12224: LD_VAR 0 1
12228: PPUSH
12229: CALL 53116 0 1
// end ;
12233: PPOPN 1
12235: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12236: LD_VAR 0 1
12240: PPUSH
12241: LD_VAR 0 2
12245: PPUSH
12246: CALL 51143 0 2
// end ;
12250: PPOPN 2
12252: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12253: LD_VAR 0 1
12257: PPUSH
12258: LD_VAR 0 2
12262: PPUSH
12263: LD_VAR 0 3
12267: PPUSH
12268: LD_VAR 0 4
12272: PPUSH
12273: LD_VAR 0 5
12277: PPUSH
12278: CALL 50761 0 5
// end ;
12282: PPOPN 5
12284: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
12285: LD_VAR 0 1
12289: PPUSH
12290: LD_VAR 0 2
12294: PPUSH
12295: CALL 114171 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
12299: LD_VAR 0 1
12303: PPUSH
12304: LD_VAR 0 2
12308: PPUSH
12309: CALL 50310 0 2
// end ;
12313: PPOPN 2
12315: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12316: LD_VAR 0 1
12320: PPUSH
12321: LD_VAR 0 2
12325: PPUSH
12326: LD_VAR 0 3
12330: PPUSH
12331: LD_VAR 0 4
12335: PPUSH
12336: CALL 50142 0 4
// end ;
12340: PPOPN 4
12342: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12343: LD_VAR 0 1
12347: PPUSH
12348: LD_VAR 0 2
12352: PPUSH
12353: LD_VAR 0 3
12357: PPUSH
12358: CALL 49915 0 3
// end ;
12362: PPOPN 3
12364: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12365: LD_VAR 0 1
12369: PPUSH
12370: LD_VAR 0 2
12374: PPUSH
12375: CALL 49798 0 2
// end ;
12379: PPOPN 2
12381: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12382: LD_VAR 0 1
12386: PPUSH
12387: LD_VAR 0 2
12391: PPUSH
12392: CALL 54106 0 2
// end ;
12396: PPOPN 2
12398: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
12399: LD_VAR 0 1
12403: PUSH
12404: LD_INT 674
12406: EQUAL
12407: IFFALSE 12429
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
12409: LD_VAR 0 2
12413: PPUSH
12414: LD_INT 227
12416: PPUSH
12417: LD_INT 136
12419: PPUSH
12420: CALL_OW 428
12424: PPUSH
12425: CALL_OW 120
// end ;
12429: PPOPN 2
12431: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12432: LD_VAR 0 1
12436: PPUSH
12437: LD_VAR 0 2
12441: PPUSH
12442: LD_VAR 0 3
12446: PPUSH
12447: LD_VAR 0 4
12451: PPUSH
12452: CALL 54330 0 4
// end ;
12456: PPOPN 4
12458: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12459: LD_VAR 0 1
12463: PPUSH
12464: LD_VAR 0 2
12468: PPUSH
12469: CALL 49605 0 2
// end ;
12473: PPOPN 2
12475: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12476: LD_VAR 0 1
12480: PPUSH
12481: CALL 114155 0 1
// end ; end_of_file
12485: PPOPN 1
12487: END
// export function Action ; begin
12488: LD_INT 0
12490: PPUSH
// InGameOn ;
12491: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
12495: LD_INT 206
12497: PPUSH
12498: LD_INT 11
12500: PPUSH
12501: CALL_OW 86
// wait ( 0 0$1 ) ;
12505: LD_INT 35
12507: PPUSH
12508: CALL_OW 67
// if LoadVariable ( 12a_PowellKilled , false ) then
12512: LD_STRING 12a_PowellKilled
12514: PPUSH
12515: LD_INT 0
12517: PPUSH
12518: CALL_OW 30
12522: IFFALSE 12562
// begin Say ( Burlak , DStart-Burlak-Bur-1 ) ;
12524: LD_EXP 54
12528: PPUSH
12529: LD_STRING DStart-Burlak-Bur-1
12531: PPUSH
12532: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12536: LD_EXP 21
12540: PPUSH
12541: LD_STRING DStart-JMM-JMM-2
12543: PPUSH
12544: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) end else
12548: LD_EXP 54
12552: PPUSH
12553: LD_STRING DStart-JMM-Bur-2
12555: PPUSH
12556: CALL_OW 88
12560: GO 12610
// begin Say ( JMM , DStart-JMM-JMM-1 ) ;
12562: LD_EXP 21
12566: PPUSH
12567: LD_STRING DStart-JMM-JMM-1
12569: PPUSH
12570: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
12574: LD_EXP 54
12578: PPUSH
12579: LD_STRING DStart-JMM-Bur-1
12581: PPUSH
12582: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12586: LD_EXP 21
12590: PPUSH
12591: LD_STRING DStart-JMM-JMM-2
12593: PPUSH
12594: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
12598: LD_EXP 54
12602: PPUSH
12603: LD_STRING DStart-JMM-Bur-2
12605: PPUSH
12606: CALL_OW 88
// end ; InGameOff ;
12610: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12614: LD_STRING MStart
12616: PPUSH
12617: CALL_OW 337
// SaveForQuickRestart ;
12621: CALL_OW 22
// end ;
12625: LD_VAR 0 1
12629: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12630: LD_INT 7
12632: PPUSH
12633: LD_INT 255
12635: PPUSH
12636: LD_INT 219
12638: PPUSH
12639: CALL_OW 293
12643: IFFALSE 13254
12645: GO 12647
12647: DISABLE
12648: LD_INT 0
12650: PPUSH
// begin wait ( 0 0$3 ) ;
12651: LD_INT 105
12653: PPUSH
12654: CALL_OW 67
// alienSpotted := true ;
12658: LD_ADDR_EXP 10
12662: PUSH
12663: LD_INT 1
12665: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12666: LD_ADDR_VAR 0 1
12670: PUSH
12671: LD_INT 22
12673: PUSH
12674: LD_INT 7
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: LD_INT 23
12683: PUSH
12684: LD_INT 3
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: LD_INT 21
12693: PUSH
12694: LD_INT 1
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PUSH
12701: LD_INT 26
12703: PUSH
12704: LD_INT 1
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: LIST
12715: LIST
12716: PPUSH
12717: CALL_OW 69
12721: PUSH
12722: LD_EXP 54
12726: PUSH
12727: LD_EXP 42
12731: PUSH
12732: LD_EXP 44
12736: PUSH
12737: LD_EXP 45
12741: PUSH
12742: LD_EXP 52
12746: PUSH
12747: LD_EXP 51
12751: PUSH
12752: LD_EXP 46
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: LIST
12765: DIFF
12766: ST_TO_ADDR
// DialogueOn ;
12767: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12771: LD_INT 255
12773: PPUSH
12774: LD_INT 219
12776: PPUSH
12777: LD_INT 7
12779: PPUSH
12780: LD_INT 20
12782: NEG
12783: PPUSH
12784: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12788: LD_INT 255
12790: PPUSH
12791: LD_INT 219
12793: PPUSH
12794: CALL_OW 86
// if speaker then
12798: LD_VAR 0 1
12802: IFFALSE 12820
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12804: LD_VAR 0 1
12808: PUSH
12809: LD_INT 1
12811: ARRAY
12812: PPUSH
12813: LD_STRING DAlienBase-RSol1-1
12815: PPUSH
12816: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12820: LD_EXP 21
12824: PPUSH
12825: LD_STRING DAlienBase-JMM-1
12827: PPUSH
12828: CALL_OW 88
// if IsOk ( Burlak ) then
12832: LD_EXP 54
12836: PPUSH
12837: CALL_OW 302
12841: IFFALSE 12862
// begin dwait ( 0 0$1 ) ;
12843: LD_INT 35
12845: PPUSH
12846: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12850: LD_EXP 54
12854: PPUSH
12855: LD_STRING DAlienBase-Bur-1
12857: PPUSH
12858: CALL_OW 88
// end ; if IsOk ( Roth ) then
12862: LD_EXP 22
12866: PPUSH
12867: CALL_OW 302
12871: IFFALSE 12885
// Say ( Roth , DAlienBase-Roth-1 ) ;
12873: LD_EXP 22
12877: PPUSH
12878: LD_STRING DAlienBase-Roth-1
12880: PPUSH
12881: CALL_OW 88
// if IsOk ( Gossudarov ) then
12885: LD_EXP 40
12889: PPUSH
12890: CALL_OW 302
12894: IFFALSE 12910
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12896: LD_EXP 40
12900: PPUSH
12901: LD_STRING DAlienBase-Gos-1
12903: PPUSH
12904: CALL_OW 88
12908: GO 13027
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12910: LD_ADDR_VAR 0 1
12914: PUSH
12915: LD_INT 22
12917: PUSH
12918: LD_INT 7
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: PUSH
12925: LD_INT 25
12927: PUSH
12928: LD_INT 4
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PUSH
12935: LD_INT 21
12937: PUSH
12938: LD_INT 1
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: PUSH
12945: LD_INT 26
12947: PUSH
12948: LD_INT 1
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: EMPTY
12956: LIST
12957: LIST
12958: LIST
12959: LIST
12960: PPUSH
12961: CALL_OW 69
12965: PUSH
12966: LD_EXP 22
12970: PUSH
12971: LD_EXP 21
12975: PUSH
12976: LD_EXP 54
12980: PUSH
12981: LD_EXP 42
12985: PUSH
12986: LD_EXP 52
12990: PUSH
12991: LD_EXP 51
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: DIFF
13004: ST_TO_ADDR
// if speaker then
13005: LD_VAR 0 1
13009: IFFALSE 13027
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
13011: LD_VAR 0 1
13015: PUSH
13016: LD_INT 1
13018: ARRAY
13019: PPUSH
13020: LD_STRING DAlienBase-Sci1-1
13022: PPUSH
13023: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
13027: LD_INT 255
13029: PPUSH
13030: LD_INT 219
13032: PPUSH
13033: LD_INT 7
13035: PPUSH
13036: CALL_OW 331
// DialogueOff ;
13040: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
13044: LD_INT 35
13046: PPUSH
13047: CALL_OW 67
// until IsSelected ( alien ) ;
13051: LD_INT 1
13053: PPUSH
13054: CALL_OW 306
13058: IFFALSE 13044
// if not artifactIResearched or not artifactIIResearched then
13060: LD_EXP 12
13064: NOT
13065: IFTRUE 13074
13067: PUSH
13068: LD_EXP 13
13072: NOT
13073: OR
13074: IFFALSE 13254
// begin if IsOk ( Roth ) then
13076: LD_EXP 22
13080: PPUSH
13081: CALL_OW 302
13085: IFFALSE 13101
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
13087: LD_EXP 22
13091: PPUSH
13092: LD_STRING DAlieBaseNotReady-Roth-1
13094: PPUSH
13095: CALL_OW 88
13099: GO 13254
// if IsOk ( Gossudarov ) then
13101: LD_EXP 40
13105: PPUSH
13106: CALL_OW 302
13110: IFFALSE 13126
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
13112: LD_EXP 40
13116: PPUSH
13117: LD_STRING DAlieBaseNotReady-Gos-1
13119: PPUSH
13120: CALL_OW 88
13124: GO 13254
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13126: LD_ADDR_VAR 0 1
13130: PUSH
13131: LD_INT 22
13133: PUSH
13134: LD_INT 7
13136: PUSH
13137: EMPTY
13138: LIST
13139: LIST
13140: PUSH
13141: LD_INT 23
13143: PUSH
13144: LD_INT 3
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: PUSH
13151: LD_INT 25
13153: PUSH
13154: LD_INT 4
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: PUSH
13161: LD_INT 21
13163: PUSH
13164: LD_INT 1
13166: PUSH
13167: EMPTY
13168: LIST
13169: LIST
13170: PUSH
13171: LD_INT 26
13173: PUSH
13174: LD_INT 1
13176: PUSH
13177: EMPTY
13178: LIST
13179: LIST
13180: PUSH
13181: EMPTY
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: PPUSH
13188: CALL_OW 69
13192: PUSH
13193: LD_EXP 22
13197: PUSH
13198: LD_EXP 21
13202: PUSH
13203: LD_EXP 54
13207: PUSH
13208: LD_EXP 42
13212: PUSH
13213: LD_EXP 52
13217: PUSH
13218: LD_EXP 51
13222: PUSH
13223: EMPTY
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: DIFF
13231: ST_TO_ADDR
// if speaker then
13232: LD_VAR 0 1
13236: IFFALSE 13254
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
13238: LD_VAR 0 1
13242: PUSH
13243: LD_INT 1
13245: ARRAY
13246: PPUSH
13247: LD_STRING DAlieBaseNotReady-RSci1-1
13249: PPUSH
13250: CALL_OW 88
// end ; end ; end ;
13254: PPOPN 1
13256: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
13257: LD_INT 24
13259: PPUSH
13260: LD_INT 7
13262: PPUSH
13263: CALL_OW 321
13267: PUSH
13268: LD_INT 2
13270: EQUAL
13271: IFFALSE 13968
13273: GO 13275
13275: DISABLE
13276: LD_INT 0
13278: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13279: LD_ADDR_VAR 0 1
13283: PUSH
13284: LD_INT 22
13286: PUSH
13287: LD_INT 7
13289: PUSH
13290: EMPTY
13291: LIST
13292: LIST
13293: PUSH
13294: LD_INT 23
13296: PUSH
13297: LD_INT 3
13299: PUSH
13300: EMPTY
13301: LIST
13302: LIST
13303: PUSH
13304: LD_INT 25
13306: PUSH
13307: LD_INT 4
13309: PUSH
13310: EMPTY
13311: LIST
13312: LIST
13313: PUSH
13314: LD_INT 21
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: LD_INT 26
13326: PUSH
13327: LD_INT 1
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: PPUSH
13341: CALL_OW 69
13345: PUSH
13346: LD_EXP 22
13350: PUSH
13351: LD_EXP 21
13355: PUSH
13356: LD_EXP 54
13360: PUSH
13361: LD_EXP 42
13365: PUSH
13366: LD_EXP 52
13370: PUSH
13371: LD_EXP 51
13375: PUSH
13376: EMPTY
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: DIFF
13384: ST_TO_ADDR
// if not speaker then
13385: LD_VAR 0 1
13389: NOT
13390: IFFALSE 13394
// exit ;
13392: GO 13968
// DialogueOn ;
13394: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
13398: LD_VAR 0 1
13402: PUSH
13403: LD_INT 1
13405: ARRAY
13406: PPUSH
13407: LD_STRING DArtefTechnology-RSci1-1
13409: PPUSH
13410: CALL_OW 88
// if IsOk ( Burlak ) then
13414: LD_EXP 54
13418: PPUSH
13419: CALL_OW 302
13423: IFFALSE 13437
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
13425: LD_EXP 54
13429: PPUSH
13430: LD_STRING DArtefTechnology-Bur-1
13432: PPUSH
13433: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
13437: LD_VAR 0 1
13441: PUSH
13442: LD_INT 1
13444: ARRAY
13445: PPUSH
13446: LD_STRING DArtefTechnology-RSci1-2
13448: PPUSH
13449: CALL_OW 88
// if Denis then
13453: LD_EXP 27
13457: IFFALSE 13474
// speaker := [ Denis ] else
13459: LD_ADDR_VAR 0 1
13463: PUSH
13464: LD_EXP 27
13468: PUSH
13469: EMPTY
13470: LIST
13471: ST_TO_ADDR
13472: GO 13580
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13474: LD_ADDR_VAR 0 1
13478: PUSH
13479: LD_INT 22
13481: PUSH
13482: LD_INT 7
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PUSH
13489: LD_INT 23
13491: PUSH
13492: LD_INT 1
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PUSH
13499: LD_INT 25
13501: PUSH
13502: LD_INT 4
13504: PUSH
13505: EMPTY
13506: LIST
13507: LIST
13508: PUSH
13509: LD_INT 21
13511: PUSH
13512: LD_INT 1
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: PUSH
13519: LD_INT 26
13521: PUSH
13522: LD_INT 1
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: LIST
13533: LIST
13534: LIST
13535: PPUSH
13536: CALL_OW 69
13540: PUSH
13541: LD_EXP 22
13545: PUSH
13546: LD_EXP 21
13550: PUSH
13551: LD_EXP 54
13555: PUSH
13556: LD_EXP 42
13560: PUSH
13561: LD_EXP 52
13565: PUSH
13566: LD_EXP 51
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: DIFF
13579: ST_TO_ADDR
// if speaker then
13580: LD_VAR 0 1
13584: IFFALSE 13602
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
13586: LD_VAR 0 1
13590: PUSH
13591: LD_INT 1
13593: ARRAY
13594: PPUSH
13595: LD_STRING DArtefTechnology-Sci1-2
13597: PPUSH
13598: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13602: LD_ADDR_VAR 0 1
13606: PUSH
13607: LD_INT 22
13609: PUSH
13610: LD_INT 7
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: PUSH
13617: LD_INT 23
13619: PUSH
13620: LD_INT 3
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PUSH
13627: LD_INT 25
13629: PUSH
13630: LD_INT 4
13632: PUSH
13633: EMPTY
13634: LIST
13635: LIST
13636: PUSH
13637: LD_INT 21
13639: PUSH
13640: LD_INT 1
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PUSH
13647: LD_INT 26
13649: PUSH
13650: LD_INT 1
13652: PUSH
13653: EMPTY
13654: LIST
13655: LIST
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: LIST
13661: LIST
13662: LIST
13663: PPUSH
13664: CALL_OW 69
13668: PUSH
13669: LD_EXP 22
13673: PUSH
13674: LD_EXP 21
13678: PUSH
13679: LD_EXP 54
13683: PUSH
13684: LD_EXP 42
13688: PUSH
13689: LD_EXP 52
13693: PUSH
13694: LD_EXP 51
13698: PUSH
13699: EMPTY
13700: LIST
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: DIFF
13707: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13708: LD_VAR 0 1
13712: IFFALSE 13728
13714: PUSH
13715: LD_EXP 9
13719: IFTRUE 13727
13721: PUSH
13722: LD_EXP 5
13726: OR
13727: AND
13728: IFFALSE 13964
// begin if arabianDestroyed and IsOk ( Burlak ) then
13730: LD_EXP 5
13734: IFFALSE 13747
13736: PUSH
13737: LD_EXP 54
13741: PPUSH
13742: CALL_OW 302
13746: AND
13747: IFFALSE 13763
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13749: LD_EXP 54
13753: PPUSH
13754: LD_STRING DArtefTechnology-Bur-2
13756: PPUSH
13757: CALL_OW 88
13761: GO 13775
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13763: LD_EXP 21
13767: PPUSH
13768: LD_STRING DArtefTechnology-JMM-2
13770: PPUSH
13771: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13775: LD_VAR 0 1
13779: PUSH
13780: LD_INT 1
13782: ARRAY
13783: PPUSH
13784: LD_STRING DArtefTechnology-RSci1-3
13786: PPUSH
13787: CALL_OW 88
// if Denis then
13791: LD_EXP 27
13795: IFFALSE 13812
// speaker := [ Denis ] else
13797: LD_ADDR_VAR 0 1
13801: PUSH
13802: LD_EXP 27
13806: PUSH
13807: EMPTY
13808: LIST
13809: ST_TO_ADDR
13810: GO 13918
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13812: LD_ADDR_VAR 0 1
13816: PUSH
13817: LD_INT 22
13819: PUSH
13820: LD_INT 7
13822: PUSH
13823: EMPTY
13824: LIST
13825: LIST
13826: PUSH
13827: LD_INT 23
13829: PUSH
13830: LD_INT 1
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: PUSH
13837: LD_INT 25
13839: PUSH
13840: LD_INT 4
13842: PUSH
13843: EMPTY
13844: LIST
13845: LIST
13846: PUSH
13847: LD_INT 21
13849: PUSH
13850: LD_INT 1
13852: PUSH
13853: EMPTY
13854: LIST
13855: LIST
13856: PUSH
13857: LD_INT 26
13859: PUSH
13860: LD_INT 1
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: PUSH
13867: EMPTY
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: PPUSH
13874: CALL_OW 69
13878: PUSH
13879: LD_EXP 22
13883: PUSH
13884: LD_EXP 21
13888: PUSH
13889: LD_EXP 54
13893: PUSH
13894: LD_EXP 42
13898: PUSH
13899: LD_EXP 52
13903: PUSH
13904: LD_EXP 51
13908: PUSH
13909: EMPTY
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: DIFF
13917: ST_TO_ADDR
// if speaker then
13918: LD_VAR 0 1
13922: IFFALSE 13964
// if alienSpotted then
13924: LD_EXP 10
13928: IFFALSE 13948
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13930: LD_VAR 0 1
13934: PUSH
13935: LD_INT 1
13937: ARRAY
13938: PPUSH
13939: LD_STRING DArtefTechnology-Sci1-3
13941: PPUSH
13942: CALL_OW 88
13946: GO 13964
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13948: LD_VAR 0 1
13952: PUSH
13953: LD_INT 1
13955: ARRAY
13956: PPUSH
13957: LD_STRING DArtefTechnology-Sci1-3a
13959: PPUSH
13960: CALL_OW 88
// end ; DialogueOff ;
13964: CALL_OW 7
// end ;
13968: PPOPN 1
13970: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13971: LD_EXP 12
13975: IFFALSE 14178
13977: GO 13979
13979: DISABLE
13980: LD_INT 0
13982: PPUSH
// begin if Denis then
13983: LD_EXP 27
13987: IFFALSE 14004
// speaker := [ Denis ] else
13989: LD_ADDR_VAR 0 1
13993: PUSH
13994: LD_EXP 27
13998: PUSH
13999: EMPTY
14000: LIST
14001: ST_TO_ADDR
14002: GO 14110
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14004: LD_ADDR_VAR 0 1
14008: PUSH
14009: LD_INT 22
14011: PUSH
14012: LD_INT 7
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: PUSH
14019: LD_INT 23
14021: PUSH
14022: LD_INT 1
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: LD_INT 25
14031: PUSH
14032: LD_INT 4
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: LD_INT 21
14041: PUSH
14042: LD_INT 1
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: PUSH
14049: LD_INT 26
14051: PUSH
14052: LD_INT 1
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: PUSH
14059: EMPTY
14060: LIST
14061: LIST
14062: LIST
14063: LIST
14064: LIST
14065: PPUSH
14066: CALL_OW 69
14070: PUSH
14071: LD_EXP 22
14075: PUSH
14076: LD_EXP 21
14080: PUSH
14081: LD_EXP 54
14085: PUSH
14086: LD_EXP 42
14090: PUSH
14091: LD_EXP 52
14095: PUSH
14096: LD_EXP 51
14100: PUSH
14101: EMPTY
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: DIFF
14109: ST_TO_ADDR
// if not speaker then
14110: LD_VAR 0 1
14114: NOT
14115: IFFALSE 14119
// exit ;
14117: GO 14178
// DialogueOn ;
14119: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
14123: LD_VAR 0 1
14127: PUSH
14128: LD_INT 1
14130: ARRAY
14131: PPUSH
14132: LD_STRING DArtefTechnologyAm-Sci1-1
14134: PPUSH
14135: CALL_OW 88
// if IsOk ( Burlak ) then
14139: LD_EXP 54
14143: PPUSH
14144: CALL_OW 302
14148: IFFALSE 14162
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
14150: LD_EXP 54
14154: PPUSH
14155: LD_STRING DArtefTechnologyAm-Bur-1
14157: PPUSH
14158: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
14162: LD_EXP 21
14166: PPUSH
14167: LD_STRING DArtefTechnologyAm-JMM-1
14169: PPUSH
14170: CALL_OW 88
// DialogueOff ;
14174: CALL_OW 7
// end ;
14178: PPOPN 1
14180: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
14181: LD_EXP 13
14185: IFFALSE 14387
14187: GO 14189
14189: DISABLE
14190: LD_INT 0
14192: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14193: LD_ADDR_VAR 0 1
14197: PUSH
14198: LD_INT 22
14200: PUSH
14201: LD_INT 7
14203: PUSH
14204: EMPTY
14205: LIST
14206: LIST
14207: PUSH
14208: LD_INT 23
14210: PUSH
14211: LD_INT 3
14213: PUSH
14214: EMPTY
14215: LIST
14216: LIST
14217: PUSH
14218: LD_INT 25
14220: PUSH
14221: LD_INT 4
14223: PUSH
14224: EMPTY
14225: LIST
14226: LIST
14227: PUSH
14228: LD_INT 21
14230: PUSH
14231: LD_INT 1
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: PUSH
14238: LD_INT 26
14240: PUSH
14241: LD_INT 1
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: EMPTY
14249: LIST
14250: LIST
14251: LIST
14252: LIST
14253: LIST
14254: PPUSH
14255: CALL_OW 69
14259: PUSH
14260: LD_EXP 22
14264: PUSH
14265: LD_EXP 21
14269: PUSH
14270: LD_EXP 54
14274: PUSH
14275: LD_EXP 42
14279: PUSH
14280: LD_EXP 52
14284: PUSH
14285: LD_EXP 51
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: DIFF
14298: ST_TO_ADDR
// if not speaker then
14299: LD_VAR 0 1
14303: NOT
14304: IFFALSE 14308
// exit ;
14306: GO 14387
// DialogueOn ;
14308: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
14312: LD_VAR 0 1
14316: PUSH
14317: LD_VAR 0 1
14321: ARRAY
14322: PPUSH
14323: LD_STRING DArtefTechnologyRu-RSci1-1
14325: PPUSH
14326: CALL_OW 88
// if IsOk ( Burlak ) then
14330: LD_EXP 54
14334: PPUSH
14335: CALL_OW 302
14339: IFFALSE 14353
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
14341: LD_EXP 54
14345: PPUSH
14346: LD_STRING DArtefTechnologyRu-Bur-1
14348: PPUSH
14349: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
14353: LD_VAR 0 1
14357: PUSH
14358: LD_VAR 0 1
14362: ARRAY
14363: PPUSH
14364: LD_STRING DArtefTechnologyRu-RSci1-2
14366: PPUSH
14367: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
14371: LD_EXP 21
14375: PPUSH
14376: LD_STRING DArtefTechnologyRu-JMM-1
14378: PPUSH
14379: CALL_OW 88
// DialogueOff ;
14383: CALL_OW 7
// end ;
14387: PPOPN 1
14389: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
14390: LD_INT 24
14392: PPUSH
14393: LD_INT 7
14395: PPUSH
14396: CALL_OW 321
14400: PUSH
14401: LD_INT 2
14403: EQUAL
14404: IFFALSE 14419
14406: PUSH
14407: LD_INT 1
14409: PPUSH
14410: CALL_OW 255
14414: PUSH
14415: LD_INT 7
14417: EQUAL
14418: AND
14419: IFFALSE 14587
14421: GO 14423
14423: DISABLE
14424: LD_INT 0
14426: PPUSH
// begin if Denis then
14427: LD_EXP 27
14431: IFFALSE 14448
// speaker := [ Denis ] else
14433: LD_ADDR_VAR 0 1
14437: PUSH
14438: LD_EXP 27
14442: PUSH
14443: EMPTY
14444: LIST
14445: ST_TO_ADDR
14446: GO 14554
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14448: LD_ADDR_VAR 0 1
14452: PUSH
14453: LD_INT 22
14455: PUSH
14456: LD_INT 7
14458: PUSH
14459: EMPTY
14460: LIST
14461: LIST
14462: PUSH
14463: LD_INT 23
14465: PUSH
14466: LD_INT 1
14468: PUSH
14469: EMPTY
14470: LIST
14471: LIST
14472: PUSH
14473: LD_INT 25
14475: PUSH
14476: LD_INT 4
14478: PUSH
14479: EMPTY
14480: LIST
14481: LIST
14482: PUSH
14483: LD_INT 21
14485: PUSH
14486: LD_INT 1
14488: PUSH
14489: EMPTY
14490: LIST
14491: LIST
14492: PUSH
14493: LD_INT 26
14495: PUSH
14496: LD_INT 1
14498: PUSH
14499: EMPTY
14500: LIST
14501: LIST
14502: PUSH
14503: EMPTY
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: PUSH
14515: LD_EXP 22
14519: PUSH
14520: LD_EXP 21
14524: PUSH
14525: LD_EXP 54
14529: PUSH
14530: LD_EXP 42
14534: PUSH
14535: LD_EXP 52
14539: PUSH
14540: LD_EXP 51
14544: PUSH
14545: EMPTY
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: DIFF
14553: ST_TO_ADDR
// if not speaker then
14554: LD_VAR 0 1
14558: NOT
14559: IFFALSE 14563
// exit ;
14561: GO 14587
// DialogueOn ;
14563: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
14567: LD_VAR 0 1
14571: PUSH
14572: LD_INT 1
14574: ARRAY
14575: PPUSH
14576: LD_STRING DArtefTechnologyArStart-Sci1-1
14578: PPUSH
14579: CALL_OW 88
// DialogueOff ;
14583: CALL_OW 7
// end ;
14587: PPOPN 1
14589: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
14590: LD_EXP 14
14594: IFFALSE 14875
14596: GO 14598
14598: DISABLE
14599: LD_INT 0
14601: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14602: LD_ADDR_VAR 0 1
14606: PUSH
14607: LD_INT 22
14609: PUSH
14610: LD_INT 7
14612: PUSH
14613: EMPTY
14614: LIST
14615: LIST
14616: PUSH
14617: LD_INT 23
14619: PUSH
14620: LD_INT 3
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 25
14629: PUSH
14630: LD_INT 4
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 26
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: LIST
14662: LIST
14663: PPUSH
14664: CALL_OW 69
14668: PUSH
14669: LD_EXP 22
14673: PUSH
14674: LD_EXP 21
14678: PUSH
14679: LD_EXP 54
14683: PUSH
14684: LD_EXP 42
14688: PUSH
14689: LD_EXP 52
14693: PUSH
14694: LD_EXP 51
14698: PUSH
14699: EMPTY
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: DIFF
14707: ST_TO_ADDR
// if not speaker then
14708: LD_VAR 0 1
14712: NOT
14713: IFFALSE 14717
// exit ;
14715: GO 14875
// DialogueOn ;
14717: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14721: LD_VAR 0 1
14725: PUSH
14726: LD_INT 1
14728: ARRAY
14729: PPUSH
14730: LD_STRING DArtefTechnologyAr-RSci1-1
14732: PPUSH
14733: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14737: LD_EXP 21
14741: PPUSH
14742: LD_STRING DArtefTechnologyAr-JMM-1
14744: PPUSH
14745: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14749: LD_VAR 0 1
14753: PUSH
14754: LD_INT 1
14756: ARRAY
14757: PPUSH
14758: LD_STRING DArtefTechnologyAr-RSci1-2
14760: PPUSH
14761: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14765: LD_EXP 21
14769: PPUSH
14770: LD_STRING DArtefTechnologyAr-JMM-2
14772: PPUSH
14773: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14777: LD_VAR 0 1
14781: PUSH
14782: LD_INT 1
14784: ARRAY
14785: PPUSH
14786: LD_STRING DArtefTechnologyAr-RSci1-3
14788: PPUSH
14789: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14793: LD_EXP 21
14797: PPUSH
14798: LD_STRING DArtefTechnologyAr-JMM-3
14800: PPUSH
14801: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14805: LD_VAR 0 1
14809: PUSH
14810: LD_INT 1
14812: ARRAY
14813: PPUSH
14814: LD_STRING DArtefTechnologyAr-RSci1-4
14816: PPUSH
14817: CALL_OW 88
// if IsOk ( Burlak ) then
14821: LD_EXP 54
14825: PPUSH
14826: CALL_OW 302
14830: IFFALSE 14844
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14832: LD_EXP 54
14836: PPUSH
14837: LD_STRING DArtefTechnologyAr-Bur-4
14839: PPUSH
14840: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14844: LD_EXP 21
14848: PPUSH
14849: LD_STRING DArtefTechnologyAr-JMM-4
14851: PPUSH
14852: CALL_OW 88
// DialogueOff ;
14856: CALL_OW 7
// wait ( 0 0$45 ) ;
14860: LD_INT 1575
14862: PPUSH
14863: CALL_OW 67
// spawnOmar := true ;
14867: LD_ADDR_EXP 11
14871: PUSH
14872: LD_INT 1
14874: ST_TO_ADDR
// end ;
14875: PPOPN 1
14877: END
// every 0 0$1 trigger spawnOmar and negotiationWithArabs do
14878: LD_EXP 11
14882: IFFALSE 14890
14884: PUSH
14885: LD_EXP 19
14889: AND
14890: IFFALSE 15327
14892: GO 14894
14894: DISABLE
// begin PrepareOmarAli ;
14895: CALL 7612 0 0
// if not HasTask ( Omar ) then
14899: LD_EXP 58
14903: PPUSH
14904: CALL_OW 314
14908: NOT
14909: IFFALSE 14926
// ComMoveXY ( Omar , 252 , 220 ) ;
14911: LD_EXP 58
14915: PPUSH
14916: LD_INT 252
14918: PPUSH
14919: LD_INT 220
14921: PPUSH
14922: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14926: LD_INT 35
14928: PPUSH
14929: CALL_OW 67
// if omarKilled then
14933: LD_EXP 20
14937: IFFALSE 14941
// exit ;
14939: GO 15327
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14941: LD_EXP 58
14945: PPUSH
14946: CALL_OW 314
14950: NOT
14951: IFFALSE 14974
14953: PUSH
14954: LD_EXP 58
14958: PPUSH
14959: LD_INT 252
14961: PPUSH
14962: LD_INT 220
14964: PPUSH
14965: CALL_OW 297
14969: PUSH
14970: LD_INT 6
14972: GREATER
14973: AND
14974: IFFALSE 14991
// ComMoveXY ( Omar , 252 , 220 ) ;
14976: LD_EXP 58
14980: PPUSH
14981: LD_INT 252
14983: PPUSH
14984: LD_INT 220
14986: PPUSH
14987: CALL_OW 111
// until See ( 7 , Omar ) ;
14991: LD_INT 7
14993: PPUSH
14994: LD_EXP 58
14998: PPUSH
14999: CALL_OW 292
15003: IFFALSE 14926
// CenterNowOnUnits ( Omar ) ;
15005: LD_EXP 58
15009: PPUSH
15010: CALL_OW 87
// DialogueOn ;
15014: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
15018: LD_EXP 58
15022: PPUSH
15023: LD_STRING DOmar-Omar-1
15025: PPUSH
15026: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
15030: LD_EXP 21
15034: PPUSH
15035: LD_STRING DOmar-JMM-1
15037: PPUSH
15038: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
15042: LD_EXP 58
15046: PPUSH
15047: LD_STRING DOmar-Omar-2
15049: PPUSH
15050: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
15054: LD_EXP 21
15058: PPUSH
15059: LD_STRING DOmar-JMM-2
15061: PPUSH
15062: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
15066: LD_EXP 58
15070: PPUSH
15071: LD_STRING DOmar-Omar-3
15073: PPUSH
15074: CALL_OW 88
// if IsOk ( Burlak ) then
15078: LD_EXP 54
15082: PPUSH
15083: CALL_OW 302
15087: IFFALSE 15103
// Say ( Burlak , DOmar-Bur-3 ) else
15089: LD_EXP 54
15093: PPUSH
15094: LD_STRING DOmar-Bur-3
15096: PPUSH
15097: CALL_OW 88
15101: GO 15115
// Say ( JMM , DOmar-JMM-3 ) ;
15103: LD_EXP 21
15107: PPUSH
15108: LD_STRING DOmar-JMM-3
15110: PPUSH
15111: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
15115: LD_EXP 58
15119: PPUSH
15120: LD_STRING DOmar-Omar-4
15122: PPUSH
15123: CALL_OW 88
// case Query ( QAccept ) of 1 :
15127: LD_STRING QAccept
15129: PPUSH
15130: CALL_OW 97
15134: PUSH
15135: LD_INT 1
15137: DOUBLE
15138: EQUAL
15139: IFTRUE 15143
15141: GO 15179
15143: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
15144: LD_EXP 21
15148: PPUSH
15149: LD_STRING DQrAccept#1-JMM-1
15151: PPUSH
15152: CALL_OW 88
// SetSide ( Omar , 7 ) ;
15156: LD_EXP 58
15160: PPUSH
15161: LD_INT 7
15163: PPUSH
15164: CALL_OW 235
// ComStop ( Omar ) ;
15168: LD_EXP 58
15172: PPUSH
15173: CALL_OW 141
// end ; 2 :
15177: GO 15228
15179: LD_INT 2
15181: DOUBLE
15182: EQUAL
15183: IFTRUE 15187
15185: GO 15227
15187: POP
// begin if IsOk ( Burlak ) then
15188: LD_EXP 54
15192: PPUSH
15193: CALL_OW 302
15197: IFFALSE 15213
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
15199: LD_EXP 54
15203: PPUSH
15204: LD_STRING DQrAccept#2-Bur-1
15206: PPUSH
15207: CALL_OW 88
15211: GO 15225
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
15213: LD_EXP 21
15217: PPUSH
15218: LD_STRING DQrAccept#2-JMM-1
15220: PPUSH
15221: CALL_OW 88
// end ; end ;
15225: GO 15228
15227: POP
// DialogueOff ;
15228: CALL_OW 7
// if GetSide ( Omar ) = 7 then
15232: LD_EXP 58
15236: PPUSH
15237: CALL_OW 255
15241: PUSH
15242: LD_INT 7
15244: EQUAL
15245: IFFALSE 15256
// begin SetAchievement ( ACH_OMAR ) ;
15247: LD_STRING ACH_OMAR
15249: PPUSH
15250: CALL_OW 543
// exit ;
15254: GO 15327
// end ; ComMoveXY ( Omar , 219 , 161 ) ;
15256: LD_EXP 58
15260: PPUSH
15261: LD_INT 219
15263: PPUSH
15264: LD_INT 161
15266: PPUSH
15267: CALL_OW 111
// AddComMoveXY ( Omar , 186 , 113 ) ;
15271: LD_EXP 58
15275: PPUSH
15276: LD_INT 186
15278: PPUSH
15279: LD_INT 113
15281: PPUSH
15282: CALL_OW 171
// wait ( 0 0$2 ) ;
15286: LD_INT 70
15288: PPUSH
15289: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
15293: LD_INT 35
15295: PPUSH
15296: CALL_OW 67
// ComMoveXY ( Omar , 186 , 113 ) ;
15300: LD_EXP 58
15304: PPUSH
15305: LD_INT 186
15307: PPUSH
15308: LD_INT 113
15310: PPUSH
15311: CALL_OW 111
// until not HasTask ( Omar ) ;
15315: LD_EXP 58
15319: PPUSH
15320: CALL_OW 314
15324: NOT
15325: IFFALSE 15293
// end ;
15327: END
// every 0 0$1 trigger not omarKilled and russianCapitulated and ( ( IsOk ( Omar ) and GetSide ( Omar ) = 7 ) or not negotiationWithArabs ) do var i ;
15328: LD_EXP 20
15332: NOT
15333: IFFALSE 15341
15335: PUSH
15336: LD_EXP 7
15340: AND
15341: IFFALSE 15380
15343: PUSH
15344: LD_EXP 58
15348: PPUSH
15349: CALL_OW 302
15353: IFFALSE 15370
15355: PUSH
15356: LD_EXP 58
15360: PPUSH
15361: CALL_OW 255
15365: PUSH
15366: LD_INT 7
15368: EQUAL
15369: AND
15370: IFTRUE 15379
15372: PUSH
15373: LD_EXP 19
15377: NOT
15378: OR
15379: AND
15380: IFFALSE 15955
15382: GO 15384
15384: DISABLE
15385: LD_INT 0
15387: PPUSH
// begin if not negotiationWithArabs and not omarKilled then
15388: LD_EXP 19
15392: NOT
15393: IFFALSE 15402
15395: PUSH
15396: LD_EXP 20
15400: NOT
15401: AND
15402: IFFALSE 15408
// PrepareOmarAli2 ;
15404: CALL 7682 0 0
// wait ( 0 0$2 ) ;
15408: LD_INT 70
15410: PPUSH
15411: CALL_OW 67
// SetSide ( Omar , 5 ) ;
15415: LD_EXP 58
15419: PPUSH
15420: LD_INT 5
15422: PPUSH
15423: CALL_OW 235
// if IsInUnit ( Omar ) then
15427: LD_EXP 58
15431: PPUSH
15432: CALL_OW 310
15436: IFFALSE 15447
// ComExitVehicle ( Omar ) ;
15438: LD_EXP 58
15442: PPUSH
15443: CALL_OW 121
// if IsInUnit ( Omar ) then
15447: LD_EXP 58
15451: PPUSH
15452: CALL_OW 310
15456: IFFALSE 15467
// ComExitBuilding ( Omar ) ;
15458: LD_EXP 58
15462: PPUSH
15463: CALL_OW 122
// wait ( 0 0$1 ) ;
15467: LD_INT 35
15469: PPUSH
15470: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15474: LD_EXP 58
15478: PPUSH
15479: LD_INT 203
15481: PPUSH
15482: LD_INT 120
15484: PPUSH
15485: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15489: LD_INT 35
15491: PPUSH
15492: CALL_OW 67
// if omarKilled then
15496: LD_EXP 20
15500: IFFALSE 15504
// exit ;
15502: GO 15955
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
15504: LD_EXP 58
15508: PPUSH
15509: CALL_OW 306
15513: IFTRUE 15536
15515: PUSH
15516: LD_EXP 58
15520: PPUSH
15521: LD_INT 203
15523: PPUSH
15524: LD_INT 120
15526: PPUSH
15527: CALL_OW 297
15531: PUSH
15532: LD_INT 20
15534: LESS
15535: OR
15536: IFFALSE 15489
// DialogueOn ;
15538: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
15542: LD_EXP 58
15546: PPUSH
15547: CALL_OW 250
15551: PPUSH
15552: LD_EXP 58
15556: PPUSH
15557: CALL_OW 251
15561: PPUSH
15562: LD_INT 7
15564: PPUSH
15565: LD_INT 6
15567: NEG
15568: PPUSH
15569: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
15573: LD_EXP 58
15577: PPUSH
15578: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
15582: LD_EXP 21
15586: PPUSH
15587: LD_STRING DOmarContam-JMM-1
15589: PPUSH
15590: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
15594: LD_EXP 58
15598: PPUSH
15599: LD_STRING DOmarContam-Omar-1
15601: PPUSH
15602: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
15606: LD_EXP 21
15610: PPUSH
15611: LD_STRING DOmarContam-JMM-2
15613: PPUSH
15614: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
15618: LD_EXP 58
15622: PPUSH
15623: CALL_OW 250
15627: PPUSH
15628: LD_EXP 58
15632: PPUSH
15633: CALL_OW 251
15637: PPUSH
15638: LD_INT 7
15640: PPUSH
15641: CALL_OW 331
// DialogueOff ;
15645: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
15649: LD_INT 5
15651: PPUSH
15652: LD_INT 7
15654: PPUSH
15655: LD_INT 2
15657: PPUSH
15658: LD_INT 1
15660: PPUSH
15661: CALL_OW 80
// repeat wait ( 0 0$2 ) ;
15665: LD_INT 70
15667: PPUSH
15668: CALL_OW 67
// if not HexInfo ( 203 , 120 ) then
15672: LD_INT 203
15674: PPUSH
15675: LD_INT 120
15677: PPUSH
15678: CALL_OW 428
15682: NOT
15683: IFFALSE 15702
// ComMoveXY ( Omar , 203 , 120 ) else
15685: LD_EXP 58
15689: PPUSH
15690: LD_INT 203
15692: PPUSH
15693: LD_INT 120
15695: PPUSH
15696: CALL_OW 111
15700: GO 15717
// ComMoveXY ( Omar , 188 , 115 ) ;
15702: LD_EXP 58
15706: PPUSH
15707: LD_INT 188
15709: PPUSH
15710: LD_INT 115
15712: PPUSH
15713: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) or GetDistUnitXY ( Omar , 188 , 115 ) < 5 ;
15717: LD_EXP 58
15721: PPUSH
15722: LD_INT 203
15724: PPUSH
15725: LD_INT 120
15727: PPUSH
15728: CALL_OW 307
15732: IFTRUE 15755
15734: PUSH
15735: LD_EXP 58
15739: PPUSH
15740: LD_INT 188
15742: PPUSH
15743: LD_INT 115
15745: PPUSH
15746: CALL_OW 297
15750: PUSH
15751: LD_INT 5
15753: LESS
15754: OR
15755: IFFALSE 15665
// ComHold ( Omar ) ;
15757: LD_EXP 58
15761: PPUSH
15762: CALL_OW 140
// InGameOn ;
15766: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
15770: LD_INT 203
15772: PPUSH
15773: LD_INT 120
15775: PPUSH
15776: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
15780: LD_INT 203
15782: PPUSH
15783: LD_INT 120
15785: PPUSH
15786: LD_INT 7
15788: PPUSH
15789: LD_INT 30
15791: NEG
15792: PPUSH
15793: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
15797: LD_ADDR_VAR 0 1
15801: PUSH
15802: LD_INT 203
15804: PUSH
15805: LD_INT 120
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: LD_INT 202
15814: PUSH
15815: LD_INT 125
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PUSH
15822: LD_INT 195
15824: PUSH
15825: LD_INT 117
15827: PUSH
15828: EMPTY
15829: LIST
15830: LIST
15831: PUSH
15832: LD_INT 216
15834: PUSH
15835: LD_INT 123
15837: PUSH
15838: EMPTY
15839: LIST
15840: LIST
15841: PUSH
15842: LD_INT 224
15844: PUSH
15845: LD_INT 131
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: LD_INT 212
15854: PUSH
15855: LD_INT 133
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PUSH
15862: EMPTY
15863: LIST
15864: LIST
15865: LIST
15866: LIST
15867: LIST
15868: LIST
15869: PUSH
15870: FOR_IN
15871: IFFALSE 15907
// begin wait ( 0 0$0.5 ) ;
15873: LD_INT 18
15875: PPUSH
15876: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15880: LD_VAR 0 1
15884: PUSH
15885: LD_INT 1
15887: ARRAY
15888: PPUSH
15889: LD_VAR 0 1
15893: PUSH
15894: LD_INT 2
15896: ARRAY
15897: PPUSH
15898: LD_INT 5
15900: PPUSH
15901: CALL_OW 495
// end ;
15905: GO 15870
15907: POP
15908: POP
// KillUnit ( Omar ) ;
15909: LD_EXP 58
15913: PPUSH
15914: CALL_OW 66
// wait ( 0 0$3 ) ;
15918: LD_INT 105
15920: PPUSH
15921: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15925: LD_EXP 21
15929: PPUSH
15930: LD_STRING D16b-JMM-1
15932: PPUSH
15933: CALL_OW 91
// wait ( 0 0$2 ) ;
15937: LD_INT 70
15939: PPUSH
15940: CALL_OW 67
// InGameOff ;
15944: CALL_OW 9
// YouLost ( MothContaminate ) ;
15948: LD_STRING MothContaminate
15950: PPUSH
15951: CALL_OW 104
// end ;
15955: PPOPN 1
15957: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15958: LD_EXP 4
15962: NOT
15963: IFFALSE 15995
15965: PUSH
15966: LD_INT 22
15968: PUSH
15969: LD_INT 1
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: PUSH
15976: LD_INT 34
15978: PUSH
15979: LD_INT 8
15981: PUSH
15982: EMPTY
15983: LIST
15984: LIST
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PPUSH
15990: CALL_OW 69
15994: AND
15995: IFFALSE 16128
15997: GO 15999
15999: DISABLE
// begin wait ( 0 0$10 ) ;
16000: LD_INT 350
16002: PPUSH
16003: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
16007: LD_EXP 57
16011: PPUSH
16012: CALL_OW 302
16016: NOT
16017: IFTRUE 16050
16019: PUSH
16020: LD_INT 22
16022: PUSH
16023: LD_INT 1
16025: PUSH
16026: EMPTY
16027: LIST
16028: LIST
16029: PUSH
16030: LD_INT 34
16032: PUSH
16033: LD_INT 8
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: PUSH
16040: EMPTY
16041: LIST
16042: LIST
16043: PPUSH
16044: CALL_OW 69
16048: NOT
16049: OR
16050: IFFALSE 16054
// exit ;
16052: GO 16128
// DialogueOn ;
16054: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
16058: LD_EXP 57
16062: PPUSH
16063: LD_STRING DWinAmericans-Pow-1
16065: PPUSH
16066: CALL_OW 94
// if IsOk ( Burlak ) then
16070: LD_EXP 54
16074: PPUSH
16075: CALL_OW 302
16079: IFFALSE 16093
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
16081: LD_EXP 54
16085: PPUSH
16086: LD_STRING DWinAmericans-Bur-1
16088: PPUSH
16089: CALL_OW 88
// if LoadVariable ( 12a_PowellKilled , false ) then
16093: LD_STRING 12a_PowellKilled
16095: PPUSH
16096: LD_INT 0
16098: PPUSH
16099: CALL_OW 30
16103: IFFALSE 16117
// Say ( JMM , DWinAmericans-JMM-1 ) ;
16105: LD_EXP 21
16109: PPUSH
16110: LD_STRING DWinAmericans-JMM-1
16112: PPUSH
16113: CALL_OW 88
// DialogueOff ;
16117: CALL_OW 7
// YouLost ( AmBomb ) ;
16121: LD_STRING AmBomb
16123: PPUSH
16124: CALL_OW 104
// end ;
16128: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
16129: LD_EXP 2
16133: NOT
16134: IFFALSE 16166
16136: PUSH
16137: LD_INT 22
16139: PUSH
16140: LD_INT 3
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: PUSH
16147: LD_INT 34
16149: PUSH
16150: LD_INT 48
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: PPUSH
16161: CALL_OW 69
16165: AND
16166: IFFALSE 16287
16168: GO 16170
16170: DISABLE
// begin wait ( 0 0$10 ) ;
16171: LD_INT 350
16173: PPUSH
16174: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
16178: LD_EXP 62
16182: PPUSH
16183: CALL_OW 302
16187: NOT
16188: IFTRUE 16221
16190: PUSH
16191: LD_INT 22
16193: PUSH
16194: LD_INT 3
16196: PUSH
16197: EMPTY
16198: LIST
16199: LIST
16200: PUSH
16201: LD_INT 34
16203: PUSH
16204: LD_INT 48
16206: PUSH
16207: EMPTY
16208: LIST
16209: LIST
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: PPUSH
16215: CALL_OW 69
16219: NOT
16220: OR
16221: IFFALSE 16225
// exit ;
16223: GO 16287
// DialogueOn ;
16225: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
16229: LD_EXP 62
16233: PPUSH
16234: LD_STRING DWinRussians-Pla-1
16236: PPUSH
16237: CALL_OW 94
// if IsOk ( Burlak ) then
16241: LD_EXP 54
16245: PPUSH
16246: CALL_OW 302
16250: IFFALSE 16264
// Say ( Burlak , DWinRussians-Bur-1 ) ;
16252: LD_EXP 54
16256: PPUSH
16257: LD_STRING DWinRussians-Bur-1
16259: PPUSH
16260: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
16264: LD_EXP 21
16268: PPUSH
16269: LD_STRING DWinRussians-JMM-1
16271: PPUSH
16272: CALL_OW 88
// DialogueOff ;
16276: CALL_OW 7
// YouLost ( RuBomb ) ;
16280: LD_STRING RuBomb
16282: PPUSH
16283: CALL_OW 104
// end ;
16287: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
16288: LD_INT 7
16290: PPUSH
16291: LD_INT 22
16293: PUSH
16294: LD_INT 7
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 70
16305: IFFALSE 16314
16307: PUSH
16308: LD_EXP 4
16312: NOT
16313: AND
16314: IFFALSE 16343
16316: GO 16318
16318: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
16319: LD_EXP 57
16323: PPUSH
16324: LD_STRING DSurrenderAmericans-Pow-1
16326: PPUSH
16327: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
16331: LD_EXP 21
16335: PPUSH
16336: LD_STRING DSurrenderAmericans-JMM-1
16338: PPUSH
16339: CALL_OW 88
// end ;
16343: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
16344: LD_INT 2
16346: PPUSH
16347: LD_INT 22
16349: PUSH
16350: LD_INT 7
16352: PUSH
16353: EMPTY
16354: LIST
16355: LIST
16356: PPUSH
16357: CALL_OW 70
16361: IFFALSE 16370
16363: PUSH
16364: LD_EXP 2
16368: NOT
16369: AND
16370: IFFALSE 16378
16372: PUSH
16373: LD_EXP 54
16377: AND
16378: IFFALSE 16407
16380: GO 16382
16382: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
16383: LD_EXP 62
16387: PPUSH
16388: LD_STRING DSurrenderRussians-Pla-1
16390: PPUSH
16391: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
16395: LD_EXP 54
16399: PPUSH
16400: LD_STRING DSurrenderRussians-Bur-1
16402: PPUSH
16403: CALL_OW 88
// end ;
16407: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
16408: LD_EXP 4
16412: IFFALSE 16853
16414: GO 16416
16416: DISABLE
16417: LD_INT 0
16419: PPUSH
16420: PPUSH
16421: PPUSH
// begin MC_Kill ( 4 ) ;
16422: LD_INT 4
16424: PPUSH
16425: CALL 23668 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
16429: LD_INT 1
16431: PPUSH
16432: LD_INT 7
16434: PPUSH
16435: LD_INT 1
16437: PPUSH
16438: LD_INT 1
16440: PPUSH
16441: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
16445: LD_ADDR_VAR 0 3
16449: PUSH
16450: LD_INT 22
16452: PUSH
16453: LD_INT 1
16455: PUSH
16456: EMPTY
16457: LIST
16458: LIST
16459: PUSH
16460: LD_INT 50
16462: PUSH
16463: EMPTY
16464: LIST
16465: PUSH
16466: LD_INT 26
16468: PUSH
16469: LD_INT 1
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: PUSH
16476: LD_INT 23
16478: PUSH
16479: LD_INT 1
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: LIST
16490: LIST
16491: PPUSH
16492: CALL_OW 69
16496: PUSH
16497: LD_EXP 57
16501: PUSH
16502: LD_EXP 29
16506: PUSH
16507: LD_EXP 26
16511: PUSH
16512: LD_EXP 25
16516: PUSH
16517: LD_EXP 32
16521: PUSH
16522: LD_EXP 30
16526: PUSH
16527: EMPTY
16528: LIST
16529: LIST
16530: LIST
16531: LIST
16532: LIST
16533: LIST
16534: DIFF
16535: ST_TO_ADDR
// if not speaker then
16536: LD_VAR 0 3
16540: NOT
16541: IFFALSE 16581
// begin uc_side := 1 ;
16543: LD_ADDR_OWVAR 20
16547: PUSH
16548: LD_INT 1
16550: ST_TO_ADDR
// uc_nation := 1 ;
16551: LD_ADDR_OWVAR 21
16555: PUSH
16556: LD_INT 1
16558: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16559: LD_INT 1
16561: PPUSH
16562: LD_INT 0
16564: PPUSH
16565: CALL_OW 381
// speaker := CreateHuman ;
16569: LD_ADDR_VAR 0 3
16573: PUSH
16574: CALL_OW 44
16578: ST_TO_ADDR
// end else
16579: GO 16595
// speaker := speaker [ 1 ] ;
16581: LD_ADDR_VAR 0 3
16585: PUSH
16586: LD_VAR 0 3
16590: PUSH
16591: LD_INT 1
16593: ARRAY
16594: ST_TO_ADDR
// DialogueOn ;
16595: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
16599: LD_VAR 0 3
16603: PPUSH
16604: LD_STRING DSurrenderAmericans-Sol1-1a
16606: PPUSH
16607: CALL_OW 94
// DialogueOff ;
16611: CALL_OW 7
// americanCapitulated := true ;
16615: LD_ADDR_EXP 6
16619: PUSH
16620: LD_INT 1
16622: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16623: LD_ADDR_VAR 0 2
16627: PUSH
16628: LD_INT 22
16630: PUSH
16631: LD_INT 1
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: PUSH
16638: LD_INT 21
16640: PUSH
16641: LD_INT 1
16643: PUSH
16644: EMPTY
16645: LIST
16646: LIST
16647: PUSH
16648: EMPTY
16649: LIST
16650: LIST
16651: PPUSH
16652: CALL_OW 69
16656: PUSH
16657: LD_INT 22
16659: PUSH
16660: LD_INT 1
16662: PUSH
16663: EMPTY
16664: LIST
16665: LIST
16666: PUSH
16667: LD_INT 21
16669: PUSH
16670: LD_INT 2
16672: PUSH
16673: EMPTY
16674: LIST
16675: LIST
16676: PUSH
16677: LD_INT 1
16679: PUSH
16680: EMPTY
16681: LIST
16682: PUSH
16683: EMPTY
16684: LIST
16685: LIST
16686: LIST
16687: PPUSH
16688: CALL_OW 69
16692: ADD
16693: ST_TO_ADDR
// if tmp then
16694: LD_VAR 0 2
16698: IFFALSE 16853
// repeat wait ( 0 0$1 ) ;
16700: LD_INT 35
16702: PPUSH
16703: CALL_OW 67
// for i in tmp do
16707: LD_ADDR_VAR 0 1
16711: PUSH
16712: LD_VAR 0 2
16716: PUSH
16717: FOR_IN
16718: IFFALSE 16802
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16720: LD_VAR 0 1
16724: PPUSH
16725: CALL_OW 310
16729: IFFALSE 16751
16731: PUSH
16732: LD_VAR 0 1
16736: PPUSH
16737: CALL_OW 310
16741: PPUSH
16742: CALL_OW 247
16746: PUSH
16747: LD_INT 3
16749: EQUAL
16750: AND
16751: IFFALSE 16762
// ComExitBuilding ( i ) ;
16753: LD_VAR 0 1
16757: PPUSH
16758: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
16762: LD_VAR 0 1
16766: PPUSH
16767: LD_INT 122
16769: PPUSH
16770: LD_INT 242
16772: PPUSH
16773: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
16777: LD_VAR 0 1
16781: PPUSH
16782: LD_INT 35
16784: PPUSH
16785: CALL_OW 308
16789: IFFALSE 16800
// RemoveUnit ( i ) ;
16791: LD_VAR 0 1
16795: PPUSH
16796: CALL_OW 64
// end ;
16800: GO 16717
16802: POP
16803: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16804: LD_INT 22
16806: PUSH
16807: LD_INT 1
16809: PUSH
16810: EMPTY
16811: LIST
16812: LIST
16813: PUSH
16814: LD_INT 2
16816: PUSH
16817: LD_INT 21
16819: PUSH
16820: LD_INT 1
16822: PUSH
16823: EMPTY
16824: LIST
16825: LIST
16826: PUSH
16827: LD_INT 33
16829: PUSH
16830: LD_INT 1
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: LIST
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 69
16850: NOT
16851: IFFALSE 16700
// end ;
16853: PPOPN 3
16855: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16856: LD_EXP 2
16860: IFFALSE 17311
16862: GO 16864
16864: DISABLE
16865: LD_INT 0
16867: PPUSH
16868: PPUSH
16869: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16870: LD_INT 35
16872: PPUSH
16873: CALL_OW 67
// until IsDead ( Yakotich ) ;
16877: LD_EXP 63
16881: PPUSH
16882: CALL_OW 301
16886: IFFALSE 16870
// MC_Kill ( 2 ) ;
16888: LD_INT 2
16890: PPUSH
16891: CALL 23668 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16895: LD_INT 3
16897: PPUSH
16898: LD_INT 7
16900: PPUSH
16901: LD_INT 1
16903: PPUSH
16904: LD_INT 1
16906: PPUSH
16907: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16911: LD_ADDR_VAR 0 3
16915: PUSH
16916: LD_INT 22
16918: PUSH
16919: LD_INT 3
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PUSH
16926: LD_INT 50
16928: PUSH
16929: EMPTY
16930: LIST
16931: PUSH
16932: LD_INT 26
16934: PUSH
16935: LD_INT 1
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PUSH
16942: LD_INT 23
16944: PUSH
16945: LD_INT 3
16947: PUSH
16948: EMPTY
16949: LIST
16950: LIST
16951: PUSH
16952: EMPTY
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: PPUSH
16958: CALL_OW 69
16962: PUSH
16963: LD_EXP 62
16967: DIFF
16968: ST_TO_ADDR
// if not speaker then
16969: LD_VAR 0 3
16973: NOT
16974: IFFALSE 17014
// begin uc_side := 3 ;
16976: LD_ADDR_OWVAR 20
16980: PUSH
16981: LD_INT 3
16983: ST_TO_ADDR
// uc_nation := 3 ;
16984: LD_ADDR_OWVAR 21
16988: PUSH
16989: LD_INT 3
16991: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16992: LD_INT 1
16994: PPUSH
16995: LD_INT 0
16997: PPUSH
16998: CALL_OW 381
// speaker := CreateHuman ;
17002: LD_ADDR_VAR 0 3
17006: PUSH
17007: CALL_OW 44
17011: ST_TO_ADDR
// end else
17012: GO 17028
// speaker := speaker [ 1 ] ;
17014: LD_ADDR_VAR 0 3
17018: PUSH
17019: LD_VAR 0 3
17023: PUSH
17024: LD_INT 1
17026: ARRAY
17027: ST_TO_ADDR
// DialogueOn ;
17028: CALL_OW 6
// if IsOK ( Burlak ) then
17032: LD_EXP 54
17036: PPUSH
17037: CALL_OW 302
17041: IFFALSE 17057
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
17043: LD_VAR 0 3
17047: PPUSH
17048: LD_STRING DSurrenderRussians-RSol1-1
17050: PPUSH
17051: CALL_OW 94
17055: GO 17069
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
17057: LD_VAR 0 3
17061: PPUSH
17062: LD_STRING DSurrenderRussians-RSol1-1a
17064: PPUSH
17065: CALL_OW 94
// DialogueOff ;
17069: CALL_OW 7
// russianCapitulated := true ;
17073: LD_ADDR_EXP 7
17077: PUSH
17078: LD_INT 1
17080: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17081: LD_ADDR_VAR 0 2
17085: PUSH
17086: LD_INT 22
17088: PUSH
17089: LD_INT 3
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 21
17098: PUSH
17099: LD_INT 1
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: PPUSH
17110: CALL_OW 69
17114: PUSH
17115: LD_INT 22
17117: PUSH
17118: LD_INT 3
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: PUSH
17125: LD_INT 21
17127: PUSH
17128: LD_INT 2
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 1
17137: PUSH
17138: EMPTY
17139: LIST
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: LIST
17145: PPUSH
17146: CALL_OW 69
17150: ADD
17151: ST_TO_ADDR
// if tmp then
17152: LD_VAR 0 2
17156: IFFALSE 17311
// repeat wait ( 0 0$1 ) ;
17158: LD_INT 35
17160: PPUSH
17161: CALL_OW 67
// for i in tmp do
17165: LD_ADDR_VAR 0 1
17169: PUSH
17170: LD_VAR 0 2
17174: PUSH
17175: FOR_IN
17176: IFFALSE 17260
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17178: LD_VAR 0 1
17182: PPUSH
17183: CALL_OW 310
17187: IFFALSE 17209
17189: PUSH
17190: LD_VAR 0 1
17194: PPUSH
17195: CALL_OW 310
17199: PPUSH
17200: CALL_OW 247
17204: PUSH
17205: LD_INT 3
17207: EQUAL
17208: AND
17209: IFFALSE 17220
// ComExitBuilding ( i ) ;
17211: LD_VAR 0 1
17215: PPUSH
17216: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
17220: LD_VAR 0 1
17224: PPUSH
17225: LD_INT 154
17227: PPUSH
17228: LD_INT 1
17230: PPUSH
17231: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
17235: LD_VAR 0 1
17239: PPUSH
17240: LD_INT 36
17242: PPUSH
17243: CALL_OW 308
17247: IFFALSE 17258
// RemoveUnit ( i ) ;
17249: LD_VAR 0 1
17253: PPUSH
17254: CALL_OW 64
// end ;
17258: GO 17175
17260: POP
17261: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17262: LD_INT 22
17264: PUSH
17265: LD_INT 3
17267: PUSH
17268: EMPTY
17269: LIST
17270: LIST
17271: PUSH
17272: LD_INT 2
17274: PUSH
17275: LD_INT 21
17277: PUSH
17278: LD_INT 1
17280: PUSH
17281: EMPTY
17282: LIST
17283: LIST
17284: PUSH
17285: LD_INT 33
17287: PUSH
17288: LD_INT 1
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: LIST
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: PPUSH
17304: CALL_OW 69
17308: NOT
17309: IFFALSE 17158
// end ;
17311: PPOPN 3
17313: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
17314: LD_INT 22
17316: PUSH
17317: LD_INT 8
17319: PUSH
17320: EMPTY
17321: LIST
17322: LIST
17323: PUSH
17324: LD_INT 21
17326: PUSH
17327: LD_INT 1
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: PUSH
17334: LD_INT 23
17336: PUSH
17337: LD_INT 2
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: PUSH
17344: EMPTY
17345: LIST
17346: LIST
17347: LIST
17348: PPUSH
17349: CALL_OW 69
17353: PUSH
17354: LD_INT 18
17356: LESS
17357: IFTRUE 17370
17359: PUSH
17360: LD_EXP 60
17364: PPUSH
17365: CALL_OW 301
17369: OR
17370: IFTRUE 17385
17372: PUSH
17373: LD_INT 324
17375: PPUSH
17376: CALL_OW 255
17380: PUSH
17381: LD_INT 7
17383: EQUAL
17384: OR
17385: IFFALSE 17398
17387: GO 17389
17389: DISABLE
// legionDestroyed := true ;
17390: LD_ADDR_EXP 3
17394: PUSH
17395: LD_INT 1
17397: ST_TO_ADDR
17398: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
17399: LD_INT 22
17401: PUSH
17402: LD_INT 2
17404: PUSH
17405: EMPTY
17406: LIST
17407: LIST
17408: PUSH
17409: LD_INT 21
17411: PUSH
17412: LD_INT 1
17414: PUSH
17415: EMPTY
17416: LIST
17417: LIST
17418: PUSH
17419: LD_INT 23
17421: PUSH
17422: LD_INT 2
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: PUSH
17429: EMPTY
17430: LIST
17431: LIST
17432: LIST
17433: PPUSH
17434: CALL_OW 69
17438: PUSH
17439: LD_INT 9
17441: LESS
17442: IFTRUE 17453
17444: PUSH
17445: LD_INT 503
17447: PPUSH
17448: CALL_OW 301
17452: OR
17453: IFTRUE 17468
17455: PUSH
17456: LD_INT 503
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 7
17466: EQUAL
17467: OR
17468: IFFALSE 17481
17470: GO 17472
17472: DISABLE
// arabianDestroyed := true ;
17473: LD_ADDR_EXP 5
17477: PUSH
17478: LD_INT 1
17480: ST_TO_ADDR
17481: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
17482: LD_EXP 5
17486: IFFALSE 17732
17488: GO 17490
17490: DISABLE
17491: LD_INT 0
17493: PPUSH
17494: PPUSH
// begin MC_Kill ( 1 ) ;
17495: LD_INT 1
17497: PPUSH
17498: CALL 23668 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17502: LD_ADDR_VAR 0 2
17506: PUSH
17507: LD_INT 22
17509: PUSH
17510: LD_INT 2
17512: PUSH
17513: EMPTY
17514: LIST
17515: LIST
17516: PUSH
17517: LD_INT 21
17519: PUSH
17520: LD_INT 1
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: PUSH
17527: EMPTY
17528: LIST
17529: LIST
17530: PPUSH
17531: CALL_OW 69
17535: PUSH
17536: LD_INT 22
17538: PUSH
17539: LD_INT 2
17541: PUSH
17542: EMPTY
17543: LIST
17544: LIST
17545: PUSH
17546: LD_INT 21
17548: PUSH
17549: LD_INT 2
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: EMPTY
17560: LIST
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: PPUSH
17567: CALL_OW 69
17571: ADD
17572: ST_TO_ADDR
// if tmp then
17573: LD_VAR 0 2
17577: IFFALSE 17732
// repeat wait ( 0 0$1 ) ;
17579: LD_INT 35
17581: PPUSH
17582: CALL_OW 67
// for i in tmp do
17586: LD_ADDR_VAR 0 1
17590: PUSH
17591: LD_VAR 0 2
17595: PUSH
17596: FOR_IN
17597: IFFALSE 17681
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17599: LD_VAR 0 1
17603: PPUSH
17604: CALL_OW 310
17608: IFFALSE 17630
17610: PUSH
17611: LD_VAR 0 1
17615: PPUSH
17616: CALL_OW 310
17620: PPUSH
17621: CALL_OW 247
17625: PUSH
17626: LD_INT 3
17628: EQUAL
17629: AND
17630: IFFALSE 17641
// ComExitBuilding ( i ) ;
17632: LD_VAR 0 1
17636: PPUSH
17637: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
17641: LD_VAR 0 1
17645: PPUSH
17646: LD_INT 254
17648: PPUSH
17649: LD_INT 268
17651: PPUSH
17652: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
17656: LD_VAR 0 1
17660: PPUSH
17661: LD_INT 34
17663: PPUSH
17664: CALL_OW 308
17668: IFFALSE 17679
// RemoveUnit ( i ) ;
17670: LD_VAR 0 1
17674: PPUSH
17675: CALL_OW 64
// end ;
17679: GO 17596
17681: POP
17682: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17683: LD_INT 22
17685: PUSH
17686: LD_INT 2
17688: PUSH
17689: EMPTY
17690: LIST
17691: LIST
17692: PUSH
17693: LD_INT 2
17695: PUSH
17696: LD_INT 21
17698: PUSH
17699: LD_INT 1
17701: PUSH
17702: EMPTY
17703: LIST
17704: LIST
17705: PUSH
17706: LD_INT 33
17708: PUSH
17709: LD_INT 1
17711: PUSH
17712: EMPTY
17713: LIST
17714: LIST
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: LIST
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: PPUSH
17725: CALL_OW 69
17729: NOT
17730: IFFALSE 17579
// end ;
17732: PPOPN 2
17734: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
17735: LD_EXP 3
17739: IFFALSE 18093
17741: GO 17743
17743: DISABLE
17744: LD_INT 0
17746: PPUSH
17747: PPUSH
// begin MC_Kill ( 3 ) ;
17748: LD_INT 3
17750: PPUSH
17751: CALL 23668 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
17755: LD_INT 8
17757: PPUSH
17758: LD_INT 7
17760: PPUSH
17761: LD_INT 1
17763: PPUSH
17764: LD_INT 1
17766: PPUSH
17767: CALL_OW 80
// DialogueOn ;
17771: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
17775: LD_EXP 59
17779: PPUSH
17780: LD_STRING D15-Szulc-1
17782: PPUSH
17783: CALL_OW 94
// DialogueOff ;
17787: CALL_OW 7
// legionCapitulated := true ;
17791: LD_ADDR_EXP 8
17795: PUSH
17796: LD_INT 1
17798: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
17799: LD_ADDR_VAR 0 1
17803: PUSH
17804: LD_INT 22
17806: PUSH
17807: LD_INT 8
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: PUSH
17814: LD_INT 21
17816: PUSH
17817: LD_INT 3
17819: PUSH
17820: EMPTY
17821: LIST
17822: LIST
17823: PUSH
17824: LD_INT 23
17826: PUSH
17827: LD_INT 3
17829: PUSH
17830: EMPTY
17831: LIST
17832: LIST
17833: PUSH
17834: EMPTY
17835: LIST
17836: LIST
17837: LIST
17838: PPUSH
17839: CALL_OW 69
17843: PUSH
17844: FOR_IN
17845: IFFALSE 17861
// SetLives ( i , 3 ) ;
17847: LD_VAR 0 1
17851: PPUSH
17852: LD_INT 3
17854: PPUSH
17855: CALL_OW 234
17859: GO 17844
17861: POP
17862: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17863: LD_ADDR_VAR 0 2
17867: PUSH
17868: LD_INT 22
17870: PUSH
17871: LD_INT 8
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: PUSH
17878: LD_INT 21
17880: PUSH
17881: LD_INT 1
17883: PUSH
17884: EMPTY
17885: LIST
17886: LIST
17887: PUSH
17888: EMPTY
17889: LIST
17890: LIST
17891: PPUSH
17892: CALL_OW 69
17896: PUSH
17897: LD_INT 22
17899: PUSH
17900: LD_INT 8
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PUSH
17907: LD_INT 21
17909: PUSH
17910: LD_INT 2
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: PUSH
17917: LD_INT 1
17919: PUSH
17920: EMPTY
17921: LIST
17922: PUSH
17923: EMPTY
17924: LIST
17925: LIST
17926: LIST
17927: PPUSH
17928: CALL_OW 69
17932: ADD
17933: ST_TO_ADDR
// if tmp then
17934: LD_VAR 0 2
17938: IFFALSE 18093
// repeat wait ( 0 0$1 ) ;
17940: LD_INT 35
17942: PPUSH
17943: CALL_OW 67
// for i in tmp do
17947: LD_ADDR_VAR 0 1
17951: PUSH
17952: LD_VAR 0 2
17956: PUSH
17957: FOR_IN
17958: IFFALSE 18042
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17960: LD_VAR 0 1
17964: PPUSH
17965: CALL_OW 310
17969: IFFALSE 17991
17971: PUSH
17972: LD_VAR 0 1
17976: PPUSH
17977: CALL_OW 310
17981: PPUSH
17982: CALL_OW 247
17986: PUSH
17987: LD_INT 3
17989: EQUAL
17990: AND
17991: IFFALSE 18002
// ComExitBuilding ( i ) ;
17993: LD_VAR 0 1
17997: PPUSH
17998: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
18002: LD_VAR 0 1
18006: PPUSH
18007: LD_INT 10
18009: PPUSH
18010: LD_INT 1
18012: PPUSH
18013: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
18017: LD_VAR 0 1
18021: PPUSH
18022: LD_INT 32
18024: PPUSH
18025: CALL_OW 308
18029: IFFALSE 18040
// RemoveUnit ( i ) ;
18031: LD_VAR 0 1
18035: PPUSH
18036: CALL_OW 64
// end ;
18040: GO 17957
18042: POP
18043: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
18044: LD_INT 22
18046: PUSH
18047: LD_INT 8
18049: PUSH
18050: EMPTY
18051: LIST
18052: LIST
18053: PUSH
18054: LD_INT 2
18056: PUSH
18057: LD_INT 21
18059: PUSH
18060: LD_INT 1
18062: PUSH
18063: EMPTY
18064: LIST
18065: LIST
18066: PUSH
18067: LD_INT 33
18069: PUSH
18070: LD_INT 1
18072: PUSH
18073: EMPTY
18074: LIST
18075: LIST
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: PUSH
18082: EMPTY
18083: LIST
18084: LIST
18085: PPUSH
18086: CALL_OW 69
18090: NOT
18091: IFFALSE 17940
// end ;
18093: PPOPN 2
18095: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
18096: LD_EXP 5
18100: NOT
18101: IFFALSE 18113
18103: PUSH
18104: LD_OWVAR 1
18108: PUSH
18109: LD_INT 63000
18111: GREATEREQUAL
18112: AND
18113: IFFALSE 18125
18115: PUSH
18116: LD_OWVAR 67
18120: PUSH
18121: LD_INT 3
18123: LESS
18124: AND
18125: IFFALSE 18134
18127: GO 18129
18129: DISABLE
// AllianceSupport ;
18130: CALL 4711 0 0
18134: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or omarKilled or not IsPlaced ( Omar ) ) do var med1 , med2 ;
18135: LD_EXP 4
18139: IFFALSE 18147
18141: PUSH
18142: LD_EXP 2
18146: AND
18147: IFFALSE 18155
18149: PUSH
18150: LD_EXP 3
18154: AND
18155: IFFALSE 18163
18157: PUSH
18158: LD_EXP 5
18162: AND
18163: IFFALSE 18171
18165: PUSH
18166: LD_EXP 6
18170: AND
18171: IFFALSE 18179
18173: PUSH
18174: LD_EXP 7
18178: AND
18179: IFFALSE 18187
18181: PUSH
18182: LD_EXP 8
18186: AND
18187: IFFALSE 18226
18189: PUSH
18190: LD_EXP 58
18194: PPUSH
18195: CALL_OW 255
18199: PUSH
18200: LD_INT 5
18202: NONEQUAL
18203: IFTRUE 18211
18205: PUSH
18206: LD_EXP 20
18210: OR
18211: IFTRUE 18225
18213: PUSH
18214: LD_EXP 58
18218: PPUSH
18219: CALL_OW 305
18223: NOT
18224: OR
18225: AND
18226: IFFALSE 19919
18228: GO 18230
18230: DISABLE
18231: LD_INT 0
18233: PPUSH
18234: PPUSH
// begin wait ( 0 0$5 ) ;
18235: LD_INT 175
18237: PPUSH
18238: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 3 then
18242: LD_INT 22
18244: PUSH
18245: LD_INT 7
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: PUSH
18252: LD_INT 21
18254: PUSH
18255: LD_INT 1
18257: PUSH
18258: EMPTY
18259: LIST
18260: LIST
18261: PUSH
18262: LD_INT 23
18264: PUSH
18265: LD_INT 1
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: PUSH
18272: LD_INT 50
18274: PUSH
18275: EMPTY
18276: LIST
18277: PUSH
18278: EMPTY
18279: LIST
18280: LIST
18281: LIST
18282: LIST
18283: PPUSH
18284: CALL_OW 69
18288: PPUSH
18289: CALL 56697 0 1
18293: PUSH
18294: LD_INT 3
18296: LESS
18297: IFFALSE 18308
// begin YouLost ( LostVictory ) ;
18299: LD_STRING LostVictory
18301: PPUSH
18302: CALL_OW 104
// exit ;
18306: GO 19919
// end ; music_class := 5 ;
18308: LD_ADDR_OWVAR 72
18312: PUSH
18313: LD_INT 5
18315: ST_TO_ADDR
// music_nat := 5 ;
18316: LD_ADDR_OWVAR 71
18320: PUSH
18321: LD_INT 5
18323: ST_TO_ADDR
// if vehicleLostCounter < 3 then
18324: LD_EXP 15
18328: PUSH
18329: LD_INT 3
18331: LESS
18332: IFFALSE 18341
// SetAchievement ( ACH_ECONOMY ) ;
18334: LD_STRING ACH_ECONOMY
18336: PPUSH
18337: CALL_OW 543
// if tick < 60 60$00 then
18341: LD_OWVAR 1
18345: PUSH
18346: LD_INT 126000
18348: LESS
18349: IFFALSE 18365
// begin wait ( 3 ) ;
18351: LD_INT 3
18353: PPUSH
18354: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
18358: LD_STRING ACH_ASPEED_19
18360: PPUSH
18361: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
18365: LD_EXP 21
18369: PPUSH
18370: CALL_OW 87
// InGameOn ;
18374: CALL_OW 8
// DialogueOn ;
18378: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
18382: LD_EXP 21
18386: PPUSH
18387: LD_STRING DEnd-JMM-JMM-1
18389: PPUSH
18390: CALL_OW 88
// if Joan then
18394: LD_EXP 36
18398: IFFALSE 18414
// Say ( Joan , DEnd-JMM-Joan-1 ) else
18400: LD_EXP 36
18404: PPUSH
18405: LD_STRING DEnd-JMM-Joan-1
18407: PPUSH
18408: CALL_OW 88
18412: GO 18462
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
18414: LD_EXP 23
18418: IFFALSE 18435
18420: PUSH
18421: LD_EXP 23
18425: PPUSH
18426: CALL_OW 255
18430: PUSH
18431: LD_INT 7
18433: EQUAL
18434: AND
18435: IFFALSE 18448
18437: PUSH
18438: LD_EXP 23
18442: PPUSH
18443: CALL_OW 305
18447: AND
18448: IFFALSE 18462
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
18450: LD_EXP 23
18454: PPUSH
18455: LD_STRING DEnd-JMM-Lisa-1
18457: PPUSH
18458: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
18462: LD_EXP 33
18466: IFFALSE 18479
18468: PUSH
18469: LD_EXP 33
18473: PPUSH
18474: CALL_OW 305
18478: AND
18479: IFFALSE 18493
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
18481: LD_EXP 33
18485: PPUSH
18486: LD_STRING DEnd-JMM-Frank-1
18488: PPUSH
18489: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
18493: LD_EXP 26
18497: IFFALSE 18514
18499: PUSH
18500: LD_EXP 26
18504: PPUSH
18505: CALL_OW 255
18509: PUSH
18510: LD_INT 7
18512: EQUAL
18513: AND
18514: IFFALSE 18527
18516: PUSH
18517: LD_EXP 26
18521: PPUSH
18522: CALL_OW 305
18526: AND
18527: IFFALSE 18541
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
18529: LD_EXP 26
18533: PPUSH
18534: LD_STRING DEnd-JMM-Cyrus-1
18536: PPUSH
18537: CALL_OW 88
// if Burlak then
18541: LD_EXP 54
18545: IFFALSE 18559
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
18547: LD_EXP 54
18551: PPUSH
18552: LD_STRING DEnd-JMM-Bur-1
18554: PPUSH
18555: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
18559: LD_EXP 36
18563: IFFALSE 18571
18565: PUSH
18566: LD_EXP 23
18570: AND
18571: IFFALSE 18588
18573: PUSH
18574: LD_EXP 23
18578: PPUSH
18579: CALL_OW 255
18583: PUSH
18584: LD_INT 7
18586: EQUAL
18587: AND
18588: IFFALSE 18601
18590: PUSH
18591: LD_EXP 23
18595: PPUSH
18596: CALL_OW 305
18600: AND
18601: IFFALSE 18614
18603: PUSH
18604: LD_EXP 54
18608: PPUSH
18609: CALL_OW 302
18613: AND
18614: IFFALSE 18628
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
18616: LD_EXP 23
18620: PPUSH
18621: LD_STRING DEnd-Burlak-Lisa-1
18623: PPUSH
18624: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
18628: LD_EXP 55
18632: IFFALSE 18645
18634: PUSH
18635: LD_EXP 55
18639: PPUSH
18640: CALL_OW 305
18644: AND
18645: IFFALSE 18659
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18647: LD_EXP 55
18651: PPUSH
18652: LD_STRING DEnd-JMM-Bel-1
18654: PPUSH
18655: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
18659: LD_EXP 56
18663: IFFALSE 18676
18665: PUSH
18666: LD_EXP 56
18670: PPUSH
18671: CALL_OW 305
18675: AND
18676: IFFALSE 18690
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18678: LD_EXP 56
18682: PPUSH
18683: LD_STRING DEnd-JMM-Gny-1
18685: PPUSH
18686: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
18690: LD_EXP 31
18694: IFFALSE 18711
18696: PUSH
18697: LD_EXP 31
18701: PPUSH
18702: CALL_OW 255
18706: PUSH
18707: LD_INT 7
18709: EQUAL
18710: AND
18711: IFFALSE 18724
18713: PUSH
18714: LD_EXP 31
18718: PPUSH
18719: CALL_OW 305
18723: AND
18724: IFFALSE 18738
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
18726: LD_EXP 31
18730: PPUSH
18731: LD_STRING DEnd-JMM-Corn-1
18733: PPUSH
18734: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
18738: LD_EXP 24
18742: IFFALSE 18759
18744: PUSH
18745: LD_EXP 24
18749: PPUSH
18750: CALL_OW 255
18754: PUSH
18755: LD_INT 7
18757: EQUAL
18758: AND
18759: IFFALSE 18772
18761: PUSH
18762: LD_EXP 24
18766: PPUSH
18767: CALL_OW 305
18771: AND
18772: IFFALSE 18786
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
18774: LD_EXP 24
18778: PPUSH
18779: LD_STRING DEnd-JMM-Don-1
18781: PPUSH
18782: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
18786: LD_EXP 25
18790: IFFALSE 18807
18792: PUSH
18793: LD_EXP 25
18797: PPUSH
18798: CALL_OW 255
18802: PUSH
18803: LD_INT 7
18805: EQUAL
18806: AND
18807: IFFALSE 18820
18809: PUSH
18810: LD_EXP 25
18814: PPUSH
18815: CALL_OW 305
18819: AND
18820: IFFALSE 18834
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
18822: LD_EXP 25
18826: PPUSH
18827: LD_STRING DEnd-JMM-Bobby-1
18829: PPUSH
18830: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
18834: LD_EXP 27
18838: IFFALSE 18855
18840: PUSH
18841: LD_EXP 27
18845: PPUSH
18846: CALL_OW 255
18850: PUSH
18851: LD_INT 7
18853: EQUAL
18854: AND
18855: IFFALSE 18868
18857: PUSH
18858: LD_EXP 27
18862: PPUSH
18863: CALL_OW 305
18867: AND
18868: IFFALSE 18882
// Say ( Denis , DEnd-JMM-Den-1 ) ;
18870: LD_EXP 27
18874: PPUSH
18875: LD_STRING DEnd-JMM-Den-1
18877: PPUSH
18878: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
18882: LD_EXP 29
18886: IFFALSE 18903
18888: PUSH
18889: LD_EXP 29
18893: PPUSH
18894: CALL_OW 255
18898: PUSH
18899: LD_INT 7
18901: EQUAL
18902: AND
18903: IFFALSE 18916
18905: PUSH
18906: LD_EXP 29
18910: PPUSH
18911: CALL_OW 305
18915: AND
18916: IFFALSE 18930
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
18918: LD_EXP 29
18922: PPUSH
18923: LD_STRING DEnd-JMM-Glad-1
18925: PPUSH
18926: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18930: LD_EXP 34
18934: IFFALSE 18951
18936: PUSH
18937: LD_EXP 34
18941: PPUSH
18942: CALL_OW 255
18946: PUSH
18947: LD_INT 7
18949: EQUAL
18950: AND
18951: IFFALSE 18964
18953: PUSH
18954: LD_EXP 34
18958: PPUSH
18959: CALL_OW 305
18963: AND
18964: IFFALSE 18978
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18966: LD_EXP 34
18970: PPUSH
18971: LD_STRING DEnd-JMM-Yam-1
18973: PPUSH
18974: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
18978: LD_EXP 28
18982: IFFALSE 18999
18984: PUSH
18985: LD_EXP 28
18989: PPUSH
18990: CALL_OW 255
18994: PUSH
18995: LD_INT 7
18997: EQUAL
18998: AND
18999: IFFALSE 19012
19001: PUSH
19002: LD_EXP 28
19006: PPUSH
19007: CALL_OW 305
19011: AND
19012: IFFALSE 19026
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
19014: LD_EXP 28
19018: PPUSH
19019: LD_STRING DEnd-JMM-Brown-1
19021: PPUSH
19022: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
19026: LD_EXP 38
19030: IFFALSE 19047
19032: PUSH
19033: LD_EXP 38
19037: PPUSH
19038: CALL_OW 255
19042: PUSH
19043: LD_INT 7
19045: EQUAL
19046: AND
19047: IFFALSE 19060
19049: PUSH
19050: LD_EXP 38
19054: PPUSH
19055: CALL_OW 305
19059: AND
19060: IFFALSE 19074
// Say ( Connie , DEnd-JMM-Con-1 ) ;
19062: LD_EXP 38
19066: PPUSH
19067: LD_STRING DEnd-JMM-Con-1
19069: PPUSH
19070: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
19074: LD_EXP 32
19078: IFFALSE 19095
19080: PUSH
19081: LD_EXP 32
19085: PPUSH
19086: CALL_OW 255
19090: PUSH
19091: LD_INT 7
19093: EQUAL
19094: AND
19095: IFFALSE 19108
19097: PUSH
19098: LD_EXP 32
19102: PPUSH
19103: CALL_OW 305
19107: AND
19108: IFFALSE 19122
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
19110: LD_EXP 32
19114: PPUSH
19115: LD_STRING DEnd-JMM-Gary-1
19117: PPUSH
19118: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
19122: LD_EXP 22
19126: IFFALSE 19139
19128: PUSH
19129: LD_EXP 22
19133: PPUSH
19134: CALL_OW 305
19138: AND
19139: IFFALSE 19153
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
19141: LD_EXP 22
19145: PPUSH
19146: LD_STRING DEnd-JMM-Roth-1
19148: PPUSH
19149: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
19153: LD_EXP 35
19157: IFFALSE 19165
19159: PUSH
19160: LD_EXP 22
19164: AND
19165: IFFALSE 19178
19167: PUSH
19168: LD_EXP 35
19172: PPUSH
19173: CALL_OW 305
19177: AND
19178: IFFALSE 19192
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
19180: LD_EXP 35
19184: PPUSH
19185: LD_STRING DEnd-JMM-Sim-1
19187: PPUSH
19188: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
19192: LD_EXP 30
19196: IFFALSE 19213
19198: PUSH
19199: LD_EXP 30
19203: PPUSH
19204: CALL_OW 255
19208: PUSH
19209: LD_INT 7
19211: EQUAL
19212: AND
19213: IFFALSE 19226
19215: PUSH
19216: LD_EXP 30
19220: PPUSH
19221: CALL_OW 305
19225: AND
19226: IFFALSE 19240
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
19228: LD_EXP 30
19232: PPUSH
19233: LD_STRING DEnd-JMM-VanH-1
19235: PPUSH
19236: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
19240: LD_EXP 44
19244: IFFALSE 19257
19246: PUSH
19247: LD_EXP 44
19251: PPUSH
19252: CALL_OW 305
19256: AND
19257: IFFALSE 19271
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
19259: LD_EXP 44
19263: PPUSH
19264: LD_STRING DEnd-JMM-Dol-1
19266: PPUSH
19267: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
19271: LD_EXP 34
19275: IFFALSE 19292
19277: PUSH
19278: LD_EXP 34
19282: PPUSH
19283: CALL_OW 255
19287: PUSH
19288: LD_INT 7
19290: EQUAL
19291: AND
19292: IFFALSE 19305
19294: PUSH
19295: LD_EXP 34
19299: PPUSH
19300: CALL_OW 305
19304: AND
19305: IFFALSE 19319
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
19307: LD_EXP 34
19311: PPUSH
19312: LD_STRING DEnd-JMM-Yam-1
19314: PPUSH
19315: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
19319: LD_EXP 48
19323: IFFALSE 19336
19325: PUSH
19326: LD_EXP 48
19330: PPUSH
19331: CALL_OW 305
19335: AND
19336: IFFALSE 19350
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
19338: LD_EXP 48
19342: PPUSH
19343: LD_STRING DEnd-JMM-Kap-1
19345: PPUSH
19346: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
19350: LD_EXP 51
19354: IFFALSE 19367
19356: PUSH
19357: LD_EXP 51
19361: PPUSH
19362: CALL_OW 305
19366: AND
19367: IFFALSE 19381
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
19369: LD_EXP 51
19373: PPUSH
19374: LD_STRING DEnd-JMM-Kov-1
19376: PPUSH
19377: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
19381: LD_EXP 46
19385: IFFALSE 19398
19387: PUSH
19388: LD_EXP 46
19392: PPUSH
19393: CALL_OW 305
19397: AND
19398: IFFALSE 19412
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
19400: LD_EXP 46
19404: PPUSH
19405: LD_STRING DEnd-JMM-Sch-1
19407: PPUSH
19408: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
19412: LD_EXP 42
19416: IFFALSE 19429
19418: PUSH
19419: LD_EXP 42
19423: PPUSH
19424: CALL_OW 305
19428: AND
19429: IFFALSE 19442
19431: PUSH
19432: LD_EXP 54
19436: PPUSH
19437: CALL_OW 302
19441: AND
19442: IFFALSE 19456
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
19444: LD_EXP 42
19448: PPUSH
19449: LD_STRING DEnd-JMM-Tit-1
19451: PPUSH
19452: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
19456: LD_EXP 47
19460: IFFALSE 19473
19462: PUSH
19463: LD_EXP 47
19467: PPUSH
19468: CALL_OW 305
19472: AND
19473: IFFALSE 19487
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
19475: LD_EXP 47
19479: PPUSH
19480: LD_STRING DEnd-JMM-Obl-1
19482: PPUSH
19483: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
19487: LD_EXP 49
19491: IFFALSE 19504
19493: PUSH
19494: LD_EXP 49
19498: PPUSH
19499: CALL_OW 305
19503: AND
19504: IFFALSE 19518
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
19506: LD_EXP 49
19510: PPUSH
19511: LD_STRING DEnd-JMM-Lip-1
19513: PPUSH
19514: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
19518: LD_EXP 43
19522: IFFALSE 19535
19524: PUSH
19525: LD_EXP 43
19529: PPUSH
19530: CALL_OW 305
19534: AND
19535: IFFALSE 19548
19537: PUSH
19538: LD_EXP 54
19542: PPUSH
19543: CALL_OW 302
19547: AND
19548: IFFALSE 19562
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
19550: LD_EXP 43
19554: PPUSH
19555: LD_STRING DEnd-Burlak-Fad-1
19557: PPUSH
19558: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
19562: LD_EXP 50
19566: IFFALSE 19579
19568: PUSH
19569: LD_EXP 50
19573: PPUSH
19574: CALL_OW 305
19578: AND
19579: IFFALSE 19593
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
19581: LD_EXP 50
19585: PPUSH
19586: LD_STRING DEnd-Burlak-Ptr-1
19588: PPUSH
19589: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
19593: LD_EXP 52
19597: IFFALSE 19610
19599: PUSH
19600: LD_EXP 52
19604: PPUSH
19605: CALL_OW 305
19609: AND
19610: IFFALSE 19624
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
19612: LD_EXP 52
19616: PPUSH
19617: LD_STRING DEnd-Burlak-Kuz-1
19619: PPUSH
19620: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
19624: LD_EXP 41
19628: IFFALSE 19641
19630: PUSH
19631: LD_EXP 41
19635: PPUSH
19636: CALL_OW 305
19640: AND
19641: IFFALSE 19654
19643: PUSH
19644: LD_EXP 54
19648: PPUSH
19649: CALL_OW 302
19653: AND
19654: IFFALSE 19668
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
19656: LD_EXP 41
19660: PPUSH
19661: LD_STRING DEnd-Burlak-Kir-1
19663: PPUSH
19664: CALL_OW 88
// if Joan then
19668: LD_EXP 36
19672: IFFALSE 19686
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
19674: LD_EXP 36
19678: PPUSH
19679: LD_STRING DEnd-Burlak-Joan-1
19681: PPUSH
19682: CALL_OW 88
// if IsOk ( Burlak ) then
19686: LD_EXP 54
19690: PPUSH
19691: CALL_OW 302
19695: IFFALSE 19709
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
19697: LD_EXP 21
19701: PPUSH
19702: LD_STRING DEnd-Burlak-JMM-1
19704: PPUSH
19705: CALL_OW 88
// dwait ( 0 0$2 ) ;
19709: LD_INT 70
19711: PPUSH
19712: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
19716: LD_EXP 59
19720: PPUSH
19721: LD_STRING DEnd-Szulc
19723: PPUSH
19724: CALL_OW 94
// dwait ( 0 0$1 ) ;
19728: LD_INT 35
19730: PPUSH
19731: CALL_OW 68
// if IsLive ( Burlak ) then
19735: LD_EXP 54
19739: PPUSH
19740: CALL_OW 300
19744: IFFALSE 19756
// med1 := 1 else
19746: LD_ADDR_VAR 0 1
19750: PUSH
19751: LD_INT 1
19753: ST_TO_ADDR
19754: GO 19765
// med1 := - 1 ;
19756: LD_ADDR_VAR 0 1
19760: PUSH
19761: LD_INT 1
19763: NEG
19764: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
19765: LD_EXP 12
19769: IFFALSE 19777
19771: PUSH
19772: LD_EXP 13
19776: AND
19777: IFFALSE 19785
19779: PUSH
19780: LD_EXP 14
19784: AND
19785: IFFALSE 19797
// med2 := 1 else
19787: LD_ADDR_VAR 0 2
19791: PUSH
19792: LD_INT 1
19794: ST_TO_ADDR
19795: GO 19806
// med2 := - 1 ;
19797: LD_ADDR_VAR 0 2
19801: PUSH
19802: LD_INT 1
19804: NEG
19805: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
19806: LD_STRING Hero
19808: PPUSH
19809: LD_INT 1
19811: PPUSH
19812: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
19816: LD_STRING Artefact
19818: PPUSH
19819: LD_VAR 0 2
19823: PPUSH
19824: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
19828: LD_STRING ReconcileBurlak
19830: PPUSH
19831: LD_VAR 0 1
19835: PPUSH
19836: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
19840: LD_OWVAR 67
19844: PUSH
19845: LD_INT 3
19847: GREATEREQUAL
19848: IFFALSE 19860
19850: PUSH
19851: LD_VAR 0 1
19855: PUSH
19856: LD_INT 1
19858: EQUAL
19859: AND
19860: IFFALSE 19872
19862: PUSH
19863: LD_VAR 0 2
19867: PUSH
19868: LD_INT 1
19870: EQUAL
19871: AND
19872: IFFALSE 19884
// SetAchievementEX ( ACH_AMER , 19 ) ;
19874: LD_STRING ACH_AMER
19876: PPUSH
19877: LD_INT 19
19879: PPUSH
19880: CALL_OW 564
// GiveMedals ( MAIN ) ;
19884: LD_STRING MAIN
19886: PPUSH
19887: CALL_OW 102
// InGameOff ;
19891: CALL_OW 9
// DialogueOff ;
19895: CALL_OW 7
// music_nat := 1 ;
19899: LD_ADDR_OWVAR 71
19903: PUSH
19904: LD_INT 1
19906: ST_TO_ADDR
// music_class := 4 ;
19907: LD_ADDR_OWVAR 72
19911: PUSH
19912: LD_INT 4
19914: ST_TO_ADDR
// YouWin ;
19915: CALL_OW 103
// end ; end_of_file
19919: PPOPN 2
19921: END
// export function InitNature ; begin
19922: LD_INT 0
19924: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
19925: LD_INT 3
19927: PPUSH
19928: LD_INT 3
19930: PPUSH
19931: LD_INT 2
19933: PPUSH
19934: LD_INT 1
19936: PPUSH
19937: LD_INT 1
19939: PPUSH
19940: LD_INT 0
19942: PPUSH
19943: LD_INT 0
19945: PPUSH
19946: LD_INT 17
19948: PPUSH
19949: LD_INT 0
19951: PPUSH
19952: CALL 89324 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
19956: LD_INT 2
19958: PPUSH
19959: LD_INT 1
19961: PPUSH
19962: LD_INT 1
19964: PPUSH
19965: LD_INT 1
19967: PPUSH
19968: LD_INT 1
19970: PPUSH
19971: LD_INT 0
19973: PPUSH
19974: LD_INT 0
19976: PPUSH
19977: LD_INT 18
19979: PPUSH
19980: LD_INT 0
19982: PPUSH
19983: CALL 89324 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
19987: LD_INT 4
19989: PPUSH
19990: LD_INT 1
19992: PPUSH
19993: LD_INT 2
19995: PPUSH
19996: LD_INT 4
19998: PPUSH
19999: LD_INT 2
20001: PPUSH
20002: LD_INT 1
20004: PPUSH
20005: LD_INT 0
20007: PPUSH
20008: LD_INT 19
20010: PPUSH
20011: LD_INT 0
20013: PPUSH
20014: CALL 89324 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
20018: LD_INT 0
20020: PPUSH
20021: LD_INT 0
20023: PPUSH
20024: LD_INT 0
20026: PPUSH
20027: LD_INT 0
20029: PPUSH
20030: LD_INT 0
20032: PPUSH
20033: LD_INT 0
20035: PPUSH
20036: LD_INT 9
20038: PPUSH
20039: LD_INT 0
20041: PPUSH
20042: LD_INT 20
20044: PPUSH
20045: CALL 89324 0 9
// end ; end_of_file
20049: LD_VAR 0 1
20053: RET
// every 0 0$30 do var time ;
20054: GO 20056
20056: DISABLE
20057: LD_INT 0
20059: PPUSH
// begin time := 0 0$30 ;
20060: LD_ADDR_VAR 0 1
20064: PUSH
20065: LD_INT 1050
20067: ST_TO_ADDR
// repeat wait ( time ) ;
20068: LD_VAR 0 1
20072: PPUSH
20073: CALL_OW 67
// if Prob ( 50 ) then
20077: LD_INT 50
20079: PPUSH
20080: CALL_OW 13
20084: IFFALSE 20113
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
20086: LD_INT 1
20088: PPUSH
20089: LD_INT 5
20091: PPUSH
20092: CALL_OW 12
20096: PPUSH
20097: LD_INT 106
20099: PPUSH
20100: LD_INT 89
20102: PPUSH
20103: LD_INT 45
20105: PPUSH
20106: LD_INT 1
20108: PPUSH
20109: CALL_OW 56
// time := time + 0 0$3 ;
20113: LD_ADDR_VAR 0 1
20117: PUSH
20118: LD_VAR 0 1
20122: PUSH
20123: LD_INT 105
20125: PLUS
20126: ST_TO_ADDR
// if Prob ( 30 ) then
20127: LD_INT 30
20129: PPUSH
20130: CALL_OW 13
20134: IFFALSE 20180
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
20136: LD_INT 525
20138: PPUSH
20139: LD_INT 735
20141: PPUSH
20142: CALL_OW 12
20146: PPUSH
20147: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
20151: LD_INT 1
20153: PPUSH
20154: LD_INT 5
20156: PPUSH
20157: CALL_OW 12
20161: PPUSH
20162: LD_INT 21
20164: PPUSH
20165: LD_INT 26
20167: PPUSH
20168: LD_INT 12
20170: PPUSH
20171: LD_INT 1
20173: PPUSH
20174: CALL_OW 56
// end else
20178: GO 20216
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
20180: LD_INT 700
20182: PPUSH
20183: LD_INT 1225
20185: PPUSH
20186: CALL_OW 12
20190: PPUSH
20191: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
20195: LD_INT 1
20197: PPUSH
20198: LD_INT 5
20200: PPUSH
20201: CALL_OW 12
20205: PPUSH
20206: LD_INT 14
20208: PPUSH
20209: LD_INT 1
20211: PPUSH
20212: CALL_OW 55
// end ; if Prob ( 50 ) then
20216: LD_INT 50
20218: PPUSH
20219: CALL_OW 13
20223: IFFALSE 20269
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
20225: LD_INT 700
20227: PPUSH
20228: LD_INT 1050
20230: PPUSH
20231: CALL_OW 12
20235: PPUSH
20236: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
20240: LD_INT 1
20242: PPUSH
20243: LD_INT 5
20245: PPUSH
20246: CALL_OW 12
20250: PPUSH
20251: LD_INT 181
20253: PPUSH
20254: LD_INT 218
20256: PPUSH
20257: LD_INT 16
20259: PPUSH
20260: LD_INT 1
20262: PPUSH
20263: CALL_OW 56
// end else
20267: GO 20341
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
20269: LD_INT 350
20271: PPUSH
20272: LD_INT 525
20274: PPUSH
20275: CALL_OW 12
20279: PPUSH
20280: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
20284: LD_INT 1
20286: PPUSH
20287: LD_INT 5
20289: PPUSH
20290: CALL_OW 12
20294: PPUSH
20295: LD_INT 13
20297: PPUSH
20298: LD_INT 1
20300: PPUSH
20301: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
20305: LD_INT 350
20307: PPUSH
20308: LD_INT 700
20310: PPUSH
20311: CALL_OW 12
20315: PPUSH
20316: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
20320: LD_INT 1
20322: PPUSH
20323: LD_INT 5
20325: PPUSH
20326: CALL_OW 12
20330: PPUSH
20331: LD_INT 33
20333: PPUSH
20334: LD_INT 1
20336: PPUSH
20337: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
20341: LD_INT 65
20343: PUSH
20344: LD_INT 62
20346: PUSH
20347: LD_INT 55
20349: PUSH
20350: LD_INT 50
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: LIST
20357: LIST
20358: PUSH
20359: LD_OWVAR 67
20363: ARRAY
20364: PPUSH
20365: CALL_OW 13
20369: IFFALSE 20415
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
20371: LD_INT 525
20373: PPUSH
20374: LD_INT 875
20376: PPUSH
20377: CALL_OW 12
20381: PPUSH
20382: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
20386: LD_INT 1
20388: PPUSH
20389: LD_INT 5
20391: PPUSH
20392: CALL_OW 12
20396: PPUSH
20397: LD_INT 294
20399: PPUSH
20400: LD_INT 211
20402: PPUSH
20403: LD_INT 30
20405: PPUSH
20406: LD_INT 1
20408: PPUSH
20409: CALL_OW 56
// end else
20413: GO 20457
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
20415: LD_INT 420
20417: PPUSH
20418: LD_INT 770
20420: PPUSH
20421: CALL_OW 12
20425: PPUSH
20426: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
20430: LD_INT 1
20432: PPUSH
20433: LD_INT 5
20435: PPUSH
20436: CALL_OW 12
20440: PPUSH
20441: LD_INT 294
20443: PPUSH
20444: LD_INT 211
20446: PPUSH
20447: LD_INT 30
20449: PPUSH
20450: LD_INT 1
20452: PPUSH
20453: CALL_OW 56
// end ; if time > 2 2$20 then
20457: LD_VAR 0 1
20461: PUSH
20462: LD_INT 4900
20464: GREATER
20465: IFFALSE 20475
// time := 0 0$50 ;
20467: LD_ADDR_VAR 0 1
20471: PUSH
20472: LD_INT 1750
20474: ST_TO_ADDR
// until false ;
20475: LD_INT 0
20477: IFFALSE 20068
// end ;
20479: PPOPN 1
20481: END
// every 0 0$45 trigger tick < 10 10$00 do
20482: LD_OWVAR 1
20486: PUSH
20487: LD_INT 21000
20489: LESS
20490: IFFALSE 20538
20492: GO 20494
20494: DISABLE
// begin enable ;
20495: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
20496: LD_INT 350
20498: PPUSH
20499: LD_INT 700
20501: PPUSH
20502: CALL_OW 12
20506: PPUSH
20507: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
20511: LD_INT 3
20513: PPUSH
20514: LD_INT 5
20516: PPUSH
20517: CALL_OW 12
20521: PPUSH
20522: LD_INT 181
20524: PPUSH
20525: LD_INT 13
20527: PPUSH
20528: LD_INT 20
20530: PPUSH
20531: LD_INT 1
20533: PPUSH
20534: CALL_OW 56
// end ; end_of_file
20538: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
20539: LD_INT 0
20541: PPUSH
// SetArtifactRes ( 7 , true ) ;
20542: LD_INT 7
20544: PPUSH
20545: LD_INT 1
20547: PPUSH
20548: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
20552: LD_ADDR_EXP 68
20556: PUSH
20557: EMPTY
20558: PUSH
20559: EMPTY
20560: PUSH
20561: EMPTY
20562: PUSH
20563: EMPTY
20564: LIST
20565: LIST
20566: LIST
20567: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
20568: LD_ADDR_EXP 69
20572: PUSH
20573: LD_INT 1050
20575: PUSH
20576: LD_OWVAR 67
20580: MUL
20581: PUSH
20582: LD_INT 2800
20584: PUSH
20585: LD_OWVAR 67
20589: MUL
20590: PUSH
20591: LD_INT 1
20593: NEG
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: LIST
20599: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
20600: LD_ADDR_EXP 70
20604: PUSH
20605: LD_INT 10
20607: PUSH
20608: LD_INT 35
20610: PUSH
20611: LD_INT 100
20613: PUSH
20614: EMPTY
20615: LIST
20616: LIST
20617: LIST
20618: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
20619: LD_ADDR_EXP 71
20623: PUSH
20624: LD_INT 0
20626: PUSH
20627: LD_INT 0
20629: PUSH
20630: LD_INT 0
20632: PUSH
20633: EMPTY
20634: LIST
20635: LIST
20636: LIST
20637: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
20638: LD_ADDR_EXP 73
20642: PUSH
20643: LD_INT 300
20645: PUSH
20646: LD_INT 500
20648: PUSH
20649: LD_INT 800
20651: PUSH
20652: EMPTY
20653: LIST
20654: LIST
20655: LIST
20656: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
20657: LD_ADDR_EXP 74
20661: PUSH
20662: LD_INT 0
20664: PUSH
20665: LD_INT 0
20667: PUSH
20668: LD_INT 0
20670: PUSH
20671: EMPTY
20672: LIST
20673: LIST
20674: LIST
20675: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
20676: LD_ADDR_EXP 75
20680: PUSH
20681: LD_INT 0
20683: PUSH
20684: LD_INT 0
20686: PUSH
20687: LD_INT 0
20689: PUSH
20690: EMPTY
20691: LIST
20692: LIST
20693: LIST
20694: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
20695: LD_ADDR_EXP 72
20699: PUSH
20700: LD_INT 0
20702: PUSH
20703: LD_INT 0
20705: PUSH
20706: LD_INT 0
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: LIST
20713: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
20714: LD_ADDR_EXP 76
20718: PUSH
20719: LD_INT 4
20721: PUSH
20722: LD_INT 3
20724: PUSH
20725: LD_INT 1
20727: PUSH
20728: EMPTY
20729: LIST
20730: LIST
20731: LIST
20732: PUSH
20733: LD_INT 5
20735: PUSH
20736: LD_INT 4
20738: PUSH
20739: LD_INT 2
20741: PUSH
20742: EMPTY
20743: LIST
20744: LIST
20745: LIST
20746: PUSH
20747: LD_INT 6
20749: PUSH
20750: LD_INT 3
20752: PUSH
20753: LD_INT 3
20755: PUSH
20756: EMPTY
20757: LIST
20758: LIST
20759: LIST
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: LIST
20765: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
20766: LD_ADDR_EXP 77
20770: PUSH
20771: LD_INT 0
20773: PUSH
20774: LD_INT 0
20776: PUSH
20777: LD_INT 0
20779: PUSH
20780: EMPTY
20781: LIST
20782: LIST
20783: LIST
20784: ST_TO_ADDR
// end ;
20785: LD_VAR 0 1
20789: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
20790: LD_INT 24
20792: PPUSH
20793: LD_INT 7
20795: PPUSH
20796: CALL_OW 321
20800: PUSH
20801: LD_INT 2
20803: EQUAL
20804: IFFALSE 21734
20806: GO 20808
20808: DISABLE
20809: LD_INT 0
20811: PPUSH
20812: PPUSH
20813: PPUSH
20814: PPUSH
20815: PPUSH
// begin enable ;
20816: ENABLE
// for i = 1 to 3 do
20817: LD_ADDR_VAR 0 1
20821: PUSH
20822: DOUBLE
20823: LD_INT 1
20825: DEC
20826: ST_TO_ADDR
20827: LD_INT 3
20829: PUSH
20830: FOR_TO
20831: IFFALSE 21732
// begin pos := FindArtifact ( i + 2 ) ;
20833: LD_ADDR_VAR 0 2
20837: PUSH
20838: LD_VAR 0 1
20842: PUSH
20843: LD_INT 2
20845: PLUS
20846: PPUSH
20847: CALL_OW 469
20851: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
20852: LD_ADDR_EXP 68
20856: PUSH
20857: LD_EXP 68
20861: PPUSH
20862: LD_VAR 0 1
20866: PPUSH
20867: LD_VAR 0 2
20871: PPUSH
20872: CALL_OW 1
20876: ST_TO_ADDR
// if pos then
20877: LD_VAR 0 2
20881: IFFALSE 21593
// begin case i of 1 :
20883: LD_VAR 0 1
20887: PUSH
20888: LD_INT 1
20890: DOUBLE
20891: EQUAL
20892: IFTRUE 20896
20894: GO 20973
20896: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
20897: LD_ADDR_VAR 0 4
20901: PUSH
20902: LD_INT 22
20904: PUSH
20905: LD_INT 7
20907: PUSH
20908: EMPTY
20909: LIST
20910: LIST
20911: PUSH
20912: LD_INT 23
20914: PUSH
20915: LD_INT 1
20917: PUSH
20918: EMPTY
20919: LIST
20920: LIST
20921: PUSH
20922: LD_INT 2
20924: PUSH
20925: LD_INT 30
20927: PUSH
20928: LD_INT 8
20930: PUSH
20931: EMPTY
20932: LIST
20933: LIST
20934: PUSH
20935: LD_INT 30
20937: PUSH
20938: LD_INT 7
20940: PUSH
20941: EMPTY
20942: LIST
20943: LIST
20944: PUSH
20945: LD_INT 30
20947: PUSH
20948: LD_INT 11
20950: PUSH
20951: EMPTY
20952: LIST
20953: LIST
20954: PUSH
20955: EMPTY
20956: LIST
20957: LIST
20958: LIST
20959: LIST
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: LIST
20965: PPUSH
20966: CALL_OW 69
20970: ST_TO_ADDR
20971: GO 21081
20973: LD_INT 2
20975: DOUBLE
20976: EQUAL
20977: IFTRUE 20981
20979: GO 21058
20981: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
20982: LD_ADDR_VAR 0 4
20986: PUSH
20987: LD_INT 22
20989: PUSH
20990: LD_INT 7
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: LD_INT 23
20999: PUSH
21000: LD_INT 3
21002: PUSH
21003: EMPTY
21004: LIST
21005: LIST
21006: PUSH
21007: LD_INT 2
21009: PUSH
21010: LD_INT 30
21012: PUSH
21013: LD_INT 8
21015: PUSH
21016: EMPTY
21017: LIST
21018: LIST
21019: PUSH
21020: LD_INT 30
21022: PUSH
21023: LD_INT 7
21025: PUSH
21026: EMPTY
21027: LIST
21028: LIST
21029: PUSH
21030: LD_INT 30
21032: PUSH
21033: LD_INT 11
21035: PUSH
21036: EMPTY
21037: LIST
21038: LIST
21039: PUSH
21040: EMPTY
21041: LIST
21042: LIST
21043: LIST
21044: LIST
21045: PUSH
21046: EMPTY
21047: LIST
21048: LIST
21049: LIST
21050: PPUSH
21051: CALL_OW 69
21055: ST_TO_ADDR
21056: GO 21081
21058: LD_INT 3
21060: DOUBLE
21061: EQUAL
21062: IFTRUE 21066
21064: GO 21080
21066: POP
// labs := [ alien ] ; end ;
21067: LD_ADDR_VAR 0 4
21071: PUSH
21072: LD_INT 1
21074: PUSH
21075: EMPTY
21076: LIST
21077: ST_TO_ADDR
21078: GO 21081
21080: POP
// if not labs then
21081: LD_VAR 0 4
21085: NOT
21086: IFFALSE 21090
// continue ;
21088: GO 20830
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
21090: LD_ADDR_VAR 0 5
21094: PUSH
21095: LD_VAR 0 4
21099: PPUSH
21100: LD_EXP 68
21104: PUSH
21105: LD_VAR 0 1
21109: ARRAY
21110: PUSH
21111: LD_INT 1
21113: ARRAY
21114: PPUSH
21115: LD_EXP 68
21119: PUSH
21120: LD_VAR 0 1
21124: ARRAY
21125: PUSH
21126: LD_INT 2
21128: ARRAY
21129: PPUSH
21130: CALL_OW 73
21134: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
21135: LD_VAR 0 5
21139: NOT
21140: IFTRUE 21160
21142: PUSH
21143: LD_VAR 0 5
21147: PUSH
21148: LD_EXP 75
21152: PUSH
21153: LD_VAR 0 1
21157: ARRAY
21158: NONEQUAL
21159: OR
21160: IFFALSE 21265
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
21162: LD_INT 7
21164: PPUSH
21165: LD_EXP 76
21169: PUSH
21170: LD_VAR 0 1
21174: ARRAY
21175: PUSH
21176: LD_INT 3
21178: ARRAY
21179: PPUSH
21180: LD_INT 0
21182: PPUSH
21183: LD_EXP 75
21187: PUSH
21188: LD_VAR 0 1
21192: ARRAY
21193: PPUSH
21194: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21198: LD_INT 7
21200: PPUSH
21201: LD_EXP 76
21205: PUSH
21206: LD_VAR 0 1
21210: ARRAY
21211: PUSH
21212: LD_INT 1
21214: ARRAY
21215: PPUSH
21216: LD_INT 0
21218: PPUSH
21219: LD_EXP 75
21223: PUSH
21224: LD_VAR 0 1
21228: ARRAY
21229: PPUSH
21230: CALL_OW 468
// if nearestLab then
21234: LD_VAR 0 5
21238: IFFALSE 21265
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
21240: LD_ADDR_EXP 75
21244: PUSH
21245: LD_EXP 75
21249: PPUSH
21250: LD_VAR 0 1
21254: PPUSH
21255: LD_VAR 0 5
21259: PPUSH
21260: CALL_OW 1
21264: ST_TO_ADDR
// end ; if not nearestLab then
21265: LD_VAR 0 5
21269: NOT
21270: IFFALSE 21274
// continue ;
21272: GO 20830
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
21274: LD_VAR 0 5
21278: PPUSH
21279: LD_EXP 68
21283: PUSH
21284: LD_VAR 0 1
21288: ARRAY
21289: PUSH
21290: LD_INT 1
21292: ARRAY
21293: PPUSH
21294: LD_EXP 68
21298: PUSH
21299: LD_VAR 0 1
21303: ARRAY
21304: PUSH
21305: LD_INT 2
21307: ARRAY
21308: PPUSH
21309: CALL_OW 297
21313: PUSH
21314: LD_INT 8
21316: LESS
21317: IFFALSE 21516
// begin if not artifactsResearched [ i ] then
21319: LD_EXP 71
21323: PUSH
21324: LD_VAR 0 1
21328: ARRAY
21329: NOT
21330: IFFALSE 21411
// begin if BuildingStatus ( nearestLab ) = bs_idle then
21332: LD_VAR 0 5
21336: PPUSH
21337: CALL_OW 461
21341: PUSH
21342: LD_INT 2
21344: EQUAL
21345: IFFALSE 21379
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
21347: LD_INT 7
21349: PPUSH
21350: LD_EXP 76
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PUSH
21361: LD_INT 3
21363: ARRAY
21364: PPUSH
21365: LD_INT 2
21367: PPUSH
21368: LD_VAR 0 5
21372: PPUSH
21373: CALL_OW 468
21377: GO 21409
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
21379: LD_INT 7
21381: PPUSH
21382: LD_EXP 76
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PUSH
21393: LD_INT 3
21395: ARRAY
21396: PPUSH
21397: LD_INT 1
21399: PPUSH
21400: LD_VAR 0 5
21404: PPUSH
21405: CALL_OW 468
// end else
21409: GO 21514
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
21411: LD_VAR 0 5
21415: PPUSH
21416: CALL_OW 461
21420: PUSH
21421: LD_INT 2
21423: EQUAL
21424: IFFALSE 21438
21426: PUSH
21427: LD_EXP 77
21431: PUSH
21432: LD_VAR 0 1
21436: ARRAY
21437: AND
21438: IFFALSE 21484
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
21440: LD_INT 7
21442: PPUSH
21443: LD_EXP 76
21447: PUSH
21448: LD_VAR 0 1
21452: ARRAY
21453: PUSH
21454: LD_INT 1
21456: ARRAY
21457: PPUSH
21458: LD_EXP 76
21462: PUSH
21463: LD_VAR 0 1
21467: ARRAY
21468: PUSH
21469: LD_INT 2
21471: ARRAY
21472: PPUSH
21473: LD_VAR 0 5
21477: PPUSH
21478: CALL_OW 468
21482: GO 21514
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
21484: LD_INT 7
21486: PPUSH
21487: LD_EXP 76
21491: PUSH
21492: LD_VAR 0 1
21496: ARRAY
21497: PUSH
21498: LD_INT 1
21500: ARRAY
21501: PPUSH
21502: LD_INT 1
21504: PPUSH
21505: LD_VAR 0 5
21509: PPUSH
21510: CALL_OW 468
// end else
21514: GO 21591
// begin if not artifactsResearched [ i ] then
21516: LD_EXP 71
21520: PUSH
21521: LD_VAR 0 1
21525: ARRAY
21526: NOT
21527: IFFALSE 21561
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
21529: LD_INT 7
21531: PPUSH
21532: LD_EXP 76
21536: PUSH
21537: LD_VAR 0 1
21541: ARRAY
21542: PUSH
21543: LD_INT 3
21545: ARRAY
21546: PPUSH
21547: LD_INT 0
21549: PPUSH
21550: LD_VAR 0 5
21554: PPUSH
21555: CALL_OW 468
21559: GO 21591
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
21561: LD_INT 7
21563: PPUSH
21564: LD_EXP 76
21568: PUSH
21569: LD_VAR 0 1
21573: ARRAY
21574: PUSH
21575: LD_INT 1
21577: ARRAY
21578: PPUSH
21579: LD_INT 0
21581: PPUSH
21582: LD_VAR 0 5
21586: PPUSH
21587: CALL_OW 468
// end ; end else
21591: GO 21730
// begin if not artifactsLabs [ i ] then
21593: LD_EXP 75
21597: PUSH
21598: LD_VAR 0 1
21602: ARRAY
21603: NOT
21604: IFFALSE 21608
// continue ;
21606: GO 20830
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
21608: LD_INT 7
21610: PPUSH
21611: LD_EXP 76
21615: PUSH
21616: LD_VAR 0 1
21620: ARRAY
21621: PUSH
21622: LD_INT 3
21624: ARRAY
21625: PPUSH
21626: LD_INT 0
21628: PPUSH
21629: LD_EXP 75
21633: PUSH
21634: LD_VAR 0 1
21638: ARRAY
21639: PPUSH
21640: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21644: LD_INT 7
21646: PPUSH
21647: LD_EXP 76
21651: PUSH
21652: LD_VAR 0 1
21656: ARRAY
21657: PUSH
21658: LD_INT 1
21660: ARRAY
21661: PPUSH
21662: LD_INT 0
21664: PPUSH
21665: LD_EXP 75
21669: PUSH
21670: LD_VAR 0 1
21674: ARRAY
21675: PPUSH
21676: CALL_OW 468
// if artifactsLabsWorking [ i ] then
21680: LD_EXP 72
21684: PUSH
21685: LD_VAR 0 1
21689: ARRAY
21690: IFFALSE 21730
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
21692: LD_ADDR_EXP 72
21696: PUSH
21697: LD_EXP 72
21701: PPUSH
21702: LD_VAR 0 1
21706: PPUSH
21707: LD_INT 0
21709: PPUSH
21710: CALL_OW 1
21714: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
21715: LD_EXP 75
21719: PUSH
21720: LD_VAR 0 1
21724: ARRAY
21725: PPUSH
21726: CALL_OW 127
// end ; end ; end ;
21730: GO 20830
21732: POP
21733: POP
// end ;
21734: PPOPN 5
21736: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un , base ;
21737: LD_INT 0
21739: PPUSH
21740: PPUSH
21741: PPUSH
21742: PPUSH
21743: PPUSH
21744: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
21745: LD_VAR 0 2
21749: PUSH
21750: LD_EXP 76
21754: PUSH
21755: LD_INT 1
21757: ARRAY
21758: PUSH
21759: LD_INT 3
21761: ARRAY
21762: EQUAL
21763: IFFALSE 21886
// begin lab := artifactsLabs [ 1 ] ;
21765: LD_ADDR_VAR 0 6
21769: PUSH
21770: LD_EXP 75
21774: PUSH
21775: LD_INT 1
21777: ARRAY
21778: ST_TO_ADDR
// if not lab then
21779: LD_VAR 0 6
21783: NOT
21784: IFFALSE 21788
// exit ;
21786: GO 23016
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
21788: LD_VAR 0 6
21792: PPUSH
21793: LD_EXP 73
21797: PUSH
21798: LD_INT 1
21800: ARRAY
21801: PPUSH
21802: LD_INT 1
21804: PPUSH
21805: CALL_OW 486
// if artifactsResProgress [ 1 ] then
21809: LD_EXP 74
21813: PUSH
21814: LD_INT 1
21816: ARRAY
21817: IFFALSE 21837
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
21819: LD_VAR 0 6
21823: PPUSH
21824: LD_EXP 74
21828: PUSH
21829: LD_INT 1
21831: ARRAY
21832: PPUSH
21833: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
21837: LD_ADDR_EXP 72
21841: PUSH
21842: LD_EXP 72
21846: PPUSH
21847: LD_INT 1
21849: PPUSH
21850: LD_INT 1
21852: PPUSH
21853: CALL_OW 1
21857: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
21858: LD_INT 7
21860: PPUSH
21861: LD_EXP 76
21865: PUSH
21866: LD_INT 1
21868: ARRAY
21869: PUSH
21870: LD_INT 3
21872: ARRAY
21873: PPUSH
21874: LD_INT 0
21876: PPUSH
21877: LD_VAR 0 6
21881: PPUSH
21882: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
21886: LD_VAR 0 2
21890: PUSH
21891: LD_EXP 76
21895: PUSH
21896: LD_INT 2
21898: ARRAY
21899: PUSH
21900: LD_INT 3
21902: ARRAY
21903: EQUAL
21904: IFFALSE 22027
// begin lab := artifactsLabs [ 2 ] ;
21906: LD_ADDR_VAR 0 6
21910: PUSH
21911: LD_EXP 75
21915: PUSH
21916: LD_INT 2
21918: ARRAY
21919: ST_TO_ADDR
// if not lab then
21920: LD_VAR 0 6
21924: NOT
21925: IFFALSE 21929
// exit ;
21927: GO 23016
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
21929: LD_VAR 0 6
21933: PPUSH
21934: LD_EXP 73
21938: PUSH
21939: LD_INT 2
21941: ARRAY
21942: PPUSH
21943: LD_INT 1
21945: PPUSH
21946: CALL_OW 486
// if artifactsResProgress [ 2 ] then
21950: LD_EXP 74
21954: PUSH
21955: LD_INT 2
21957: ARRAY
21958: IFFALSE 21978
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
21960: LD_VAR 0 6
21964: PPUSH
21965: LD_EXP 74
21969: PUSH
21970: LD_INT 2
21972: ARRAY
21973: PPUSH
21974: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
21978: LD_ADDR_EXP 72
21982: PUSH
21983: LD_EXP 72
21987: PPUSH
21988: LD_INT 2
21990: PPUSH
21991: LD_INT 1
21993: PPUSH
21994: CALL_OW 1
21998: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
21999: LD_INT 7
22001: PPUSH
22002: LD_EXP 76
22006: PUSH
22007: LD_INT 2
22009: ARRAY
22010: PUSH
22011: LD_INT 3
22013: ARRAY
22014: PPUSH
22015: LD_INT 0
22017: PPUSH
22018: LD_VAR 0 6
22022: PPUSH
22023: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
22027: LD_VAR 0 2
22031: PUSH
22032: LD_EXP 76
22036: PUSH
22037: LD_INT 3
22039: ARRAY
22040: PUSH
22041: LD_INT 3
22043: ARRAY
22044: EQUAL
22045: IFFALSE 22168
// begin lab := artifactsLabs [ 3 ] ;
22047: LD_ADDR_VAR 0 6
22051: PUSH
22052: LD_EXP 75
22056: PUSH
22057: LD_INT 3
22059: ARRAY
22060: ST_TO_ADDR
// if not lab then
22061: LD_VAR 0 6
22065: NOT
22066: IFFALSE 22070
// exit ;
22068: GO 23016
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
22070: LD_VAR 0 6
22074: PPUSH
22075: LD_EXP 73
22079: PUSH
22080: LD_INT 3
22082: ARRAY
22083: PPUSH
22084: LD_INT 1
22086: PPUSH
22087: CALL_OW 486
// if artifactsResProgress [ 3 ] then
22091: LD_EXP 74
22095: PUSH
22096: LD_INT 3
22098: ARRAY
22099: IFFALSE 22119
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
22101: LD_VAR 0 6
22105: PPUSH
22106: LD_EXP 74
22110: PUSH
22111: LD_INT 3
22113: ARRAY
22114: PPUSH
22115: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
22119: LD_ADDR_EXP 72
22123: PUSH
22124: LD_EXP 72
22128: PPUSH
22129: LD_INT 3
22131: PPUSH
22132: LD_INT 1
22134: PPUSH
22135: CALL_OW 1
22139: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
22140: LD_INT 7
22142: PPUSH
22143: LD_EXP 76
22147: PUSH
22148: LD_INT 3
22150: ARRAY
22151: PUSH
22152: LD_INT 3
22154: ARRAY
22155: PPUSH
22156: LD_INT 0
22158: PPUSH
22159: LD_VAR 0 6
22163: PPUSH
22164: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
22168: LD_VAR 0 2
22172: PUSH
22173: LD_EXP 76
22177: PUSH
22178: LD_INT 1
22180: ARRAY
22181: PUSH
22182: LD_INT 1
22184: ARRAY
22185: EQUAL
22186: IFFALSE 22394
// begin lab := artifactsLabs [ 1 ] ;
22188: LD_ADDR_VAR 0 6
22192: PUSH
22193: LD_EXP 75
22197: PUSH
22198: LD_INT 1
22200: ARRAY
22201: ST_TO_ADDR
// base := GetBase ( lab ) ;
22202: LD_ADDR_VAR 0 10
22206: PUSH
22207: LD_VAR 0 6
22211: PPUSH
22212: CALL_OW 274
22216: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
22217: LD_VAR 0 6
22221: PPUSH
22222: CALL_OW 274
22226: PPUSH
22227: CALL 92903 0 1
22231: PUSH
22232: LD_INT 3
22234: ARRAY
22235: PUSH
22236: LD_EXP 70
22240: PUSH
22241: LD_INT 1
22243: ARRAY
22244: LESS
22245: IFFALSE 22259
// begin HintSpec ( ArtifactCost , 2 ) ;
22247: LD_STRING ArtifactCost
22249: PPUSH
22250: LD_INT 2
22252: PPUSH
22253: CALL_OW 338
// exit ;
22257: GO 23016
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 1 ] ) ) ;
22259: LD_VAR 0 10
22263: PPUSH
22264: LD_INT 3
22266: PPUSH
22267: LD_VAR 0 10
22271: PPUSH
22272: LD_INT 3
22274: PPUSH
22275: CALL_OW 275
22279: PUSH
22280: LD_EXP 70
22284: PUSH
22285: LD_INT 1
22287: ARRAY
22288: MINUS
22289: PPUSH
22290: CALL_OW 277
// artifactsReady := Replace ( artifactsReady , 1 , false ) ;
22294: LD_ADDR_EXP 77
22298: PUSH
22299: LD_EXP 77
22303: PPUSH
22304: LD_INT 1
22306: PPUSH
22307: LD_INT 0
22309: PPUSH
22310: CALL_OW 1
22314: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
22315: LD_VAR 0 3
22319: PPUSH
22320: LD_VAR 0 4
22324: PPUSH
22325: LD_INT 7
22327: PPUSH
22328: LD_INT 12
22330: NEG
22331: PPUSH
22332: CALL_OW 330
// wait ( 0 0$30 ) ;
22336: LD_INT 1050
22338: PPUSH
22339: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
22343: LD_VAR 0 3
22347: PPUSH
22348: LD_VAR 0 4
22352: PPUSH
22353: LD_INT 7
22355: PPUSH
22356: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
22360: LD_EXP 69
22364: PUSH
22365: LD_INT 1
22367: ARRAY
22368: PPUSH
22369: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
22373: LD_ADDR_EXP 77
22377: PUSH
22378: LD_EXP 77
22382: PPUSH
22383: LD_INT 1
22385: PPUSH
22386: LD_INT 1
22388: PPUSH
22389: CALL_OW 1
22393: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
22394: LD_VAR 0 2
22398: PUSH
22399: LD_EXP 76
22403: PUSH
22404: LD_INT 2
22406: ARRAY
22407: PUSH
22408: LD_INT 1
22410: ARRAY
22411: EQUAL
22412: IFFALSE 22699
// begin lab := artifactsLabs [ 2 ] ;
22414: LD_ADDR_VAR 0 6
22418: PUSH
22419: LD_EXP 75
22423: PUSH
22424: LD_INT 2
22426: ARRAY
22427: ST_TO_ADDR
// base := GetBase ( lab ) ;
22428: LD_ADDR_VAR 0 10
22432: PUSH
22433: LD_VAR 0 6
22437: PPUSH
22438: CALL_OW 274
22442: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
22443: LD_VAR 0 3
22447: PUSH
22448: LD_INT 81
22450: PUSH
22451: LD_INT 7
22453: PUSH
22454: EMPTY
22455: LIST
22456: LIST
22457: PUSH
22458: LD_INT 2
22460: PUSH
22461: LD_INT 32
22463: PUSH
22464: LD_INT 3
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: LD_INT 30
22473: PUSH
22474: LD_INT 28
22476: PUSH
22477: EMPTY
22478: LIST
22479: LIST
22480: PUSH
22481: LD_INT 30
22483: PUSH
22484: LD_INT 30
22486: PUSH
22487: EMPTY
22488: LIST
22489: LIST
22490: PUSH
22491: LD_INT 35
22493: PUSH
22494: LD_INT 49
22496: PUSH
22497: EMPTY
22498: LIST
22499: LIST
22500: PUSH
22501: LD_INT 34
22503: PUSH
22504: LD_INT 49
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: PUSH
22511: LD_INT 30
22513: PUSH
22514: LD_INT 21
22516: PUSH
22517: EMPTY
22518: LIST
22519: LIST
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: LIST
22525: LIST
22526: LIST
22527: LIST
22528: LIST
22529: PUSH
22530: EMPTY
22531: LIST
22532: LIST
22533: PPUSH
22534: CALL_OW 69
22538: IN
22539: NOT
22540: IFFALSE 22544
// exit ;
22542: GO 23016
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
22544: LD_VAR 0 6
22548: PPUSH
22549: CALL_OW 274
22553: PPUSH
22554: CALL 92903 0 1
22558: PUSH
22559: LD_INT 3
22561: ARRAY
22562: PUSH
22563: LD_EXP 70
22567: PUSH
22568: LD_INT 2
22570: ARRAY
22571: LESS
22572: IFFALSE 22586
// begin HintSpec ( ArtifactCost , 2 ) ;
22574: LD_STRING ArtifactCost
22576: PPUSH
22577: LD_INT 2
22579: PPUSH
22580: CALL_OW 338
// exit ;
22584: GO 23016
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 2 ] ) ) ;
22586: LD_VAR 0 10
22590: PPUSH
22591: LD_INT 3
22593: PPUSH
22594: LD_VAR 0 10
22598: PPUSH
22599: LD_INT 3
22601: PPUSH
22602: CALL_OW 275
22606: PUSH
22607: LD_EXP 70
22611: PUSH
22612: LD_INT 2
22614: ARRAY
22615: MINUS
22616: PPUSH
22617: CALL_OW 277
// artifactsReady := Replace ( artifactsReady , 2 , false ) ;
22621: LD_ADDR_EXP 77
22625: PUSH
22626: LD_EXP 77
22630: PPUSH
22631: LD_INT 2
22633: PPUSH
22634: LD_INT 0
22636: PPUSH
22637: CALL_OW 1
22641: ST_TO_ADDR
// KillUnit ( x ) ;
22642: LD_VAR 0 3
22646: PPUSH
22647: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
22651: LD_ADDR_EXP 16
22655: PUSH
22656: LD_EXP 16
22660: PUSH
22661: LD_INT 1
22663: PLUS
22664: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
22665: LD_EXP 69
22669: PUSH
22670: LD_INT 2
22672: ARRAY
22673: PPUSH
22674: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
22678: LD_ADDR_EXP 77
22682: PUSH
22683: LD_EXP 77
22687: PPUSH
22688: LD_INT 2
22690: PPUSH
22691: LD_INT 1
22693: PPUSH
22694: CALL_OW 1
22698: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
22699: LD_VAR 0 2
22703: PUSH
22704: LD_EXP 76
22708: PUSH
22709: LD_INT 3
22711: ARRAY
22712: PUSH
22713: LD_INT 1
22715: ARRAY
22716: EQUAL
22717: IFFALSE 23016
// begin lab := artifactsLabs [ 3 ] ;
22719: LD_ADDR_VAR 0 6
22723: PUSH
22724: LD_EXP 75
22728: PUSH
22729: LD_INT 3
22731: ARRAY
22732: ST_TO_ADDR
// base := GetBase ( lab ) ;
22733: LD_ADDR_VAR 0 10
22737: PUSH
22738: LD_VAR 0 6
22742: PPUSH
22743: CALL_OW 274
22747: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
22748: LD_VAR 0 6
22752: PPUSH
22753: CALL_OW 274
22757: PPUSH
22758: CALL 92903 0 1
22762: PUSH
22763: LD_INT 3
22765: ARRAY
22766: PUSH
22767: LD_EXP 70
22771: PUSH
22772: LD_INT 3
22774: ARRAY
22775: LESS
22776: IFFALSE 22790
// begin HintSpec ( ArtifactCost , 2 ) ;
22778: LD_STRING ArtifactCost
22780: PPUSH
22781: LD_INT 2
22783: PPUSH
22784: CALL_OW 338
// exit ;
22788: GO 23016
// end ; SetResourceType ( base , mat_siberit , ( GetResourceType ( base , mat_siberit ) - artifactsSibCost [ 3 ] ) ) ;
22790: LD_VAR 0 10
22794: PPUSH
22795: LD_INT 3
22797: PPUSH
22798: LD_VAR 0 10
22802: PPUSH
22803: LD_INT 3
22805: PPUSH
22806: CALL_OW 275
22810: PUSH
22811: LD_EXP 70
22815: PUSH
22816: LD_INT 3
22818: ARRAY
22819: MINUS
22820: PPUSH
22821: CALL_OW 277
// SetAreaMapShow ( teleportArea , 1 ) ;
22825: LD_INT 37
22827: PPUSH
22828: LD_INT 1
22830: PPUSH
22831: CALL_OW 424
// time := 0 0$30 ;
22835: LD_ADDR_VAR 0 7
22839: PUSH
22840: LD_INT 1050
22842: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
22843: LD_ADDR_EXP 77
22847: PUSH
22848: LD_EXP 77
22852: PPUSH
22853: LD_INT 3
22855: PPUSH
22856: LD_INT 0
22858: PPUSH
22859: CALL_OW 1
22863: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
22864: LD_ADDR_OWVAR 47
22868: PUSH
22869: LD_STRING #Am15a-1
22871: PUSH
22872: LD_VAR 0 7
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22881: LD_INT 35
22883: PPUSH
22884: CALL_OW 67
// time := time - 0 0$1 ;
22888: LD_ADDR_VAR 0 7
22892: PUSH
22893: LD_VAR 0 7
22897: PUSH
22898: LD_INT 35
22900: MINUS
22901: ST_TO_ADDR
// until time = 0 0$00 ;
22902: LD_VAR 0 7
22906: PUSH
22907: LD_INT 0
22909: EQUAL
22910: IFFALSE 22864
// display_strings :=  ;
22912: LD_ADDR_OWVAR 47
22916: PUSH
22917: LD_STRING 
22919: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
22920: LD_INT 37
22922: PPUSH
22923: LD_INT 0
22925: PPUSH
22926: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
22930: LD_ADDR_VAR 0 8
22934: PUSH
22935: LD_INT 37
22937: PPUSH
22938: LD_INT 3
22940: PUSH
22941: LD_INT 21
22943: PUSH
22944: LD_INT 3
22946: PUSH
22947: EMPTY
22948: LIST
22949: LIST
22950: PUSH
22951: EMPTY
22952: LIST
22953: LIST
22954: PPUSH
22955: CALL_OW 70
22959: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
22960: LD_VAR 0 3
22964: PPUSH
22965: LD_VAR 0 4
22969: PPUSH
22970: CALL_OW 84
// for un in list do
22974: LD_ADDR_VAR 0 9
22978: PUSH
22979: LD_VAR 0 8
22983: PUSH
22984: FOR_IN
22985: IFFALSE 23014
// TeleportUnit ( un , x , y , 12 , true ) ;
22987: LD_VAR 0 9
22991: PPUSH
22992: LD_VAR 0 3
22996: PPUSH
22997: LD_VAR 0 4
23001: PPUSH
23002: LD_INT 12
23004: PPUSH
23005: LD_INT 1
23007: PPUSH
23008: CALL_OW 483
23012: GO 22984
23014: POP
23015: POP
// end ; end ;
23016: PPOPN 10
23018: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
23019: LD_INT 0
23021: PPUSH
23022: PPUSH
// begin labNum := 0 ;
23023: LD_ADDR_VAR 0 4
23027: PUSH
23028: LD_INT 0
23030: ST_TO_ADDR
// for i = 1 to artifactsLabs do
23031: LD_ADDR_VAR 0 3
23035: PUSH
23036: DOUBLE
23037: LD_INT 1
23039: DEC
23040: ST_TO_ADDR
23041: LD_EXP 75
23045: PUSH
23046: FOR_TO
23047: IFFALSE 23081
// if artifactsLabs [ i ] = lab then
23049: LD_EXP 75
23053: PUSH
23054: LD_VAR 0 3
23058: ARRAY
23059: PUSH
23060: LD_VAR 0 1
23064: EQUAL
23065: IFFALSE 23079
// begin labNum := i ;
23067: LD_ADDR_VAR 0 4
23071: PUSH
23072: LD_VAR 0 3
23076: ST_TO_ADDR
// break ;
23077: GO 23081
// end ;
23079: GO 23046
23081: POP
23082: POP
// if not labNum then
23083: LD_VAR 0 4
23087: NOT
23088: IFFALSE 23092
// exit ;
23090: GO 23170
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
23092: LD_INT 7
23094: PPUSH
23095: LD_EXP 76
23099: PUSH
23100: LD_VAR 0 4
23104: ARRAY
23105: PUSH
23106: LD_INT 3
23108: ARRAY
23109: PPUSH
23110: LD_INT 2
23112: PPUSH
23113: LD_VAR 0 1
23117: PPUSH
23118: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
23122: LD_ADDR_EXP 74
23126: PUSH
23127: LD_EXP 74
23131: PPUSH
23132: LD_VAR 0 4
23136: PPUSH
23137: LD_VAR 0 2
23141: PPUSH
23142: CALL_OW 1
23146: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
23147: LD_ADDR_EXP 72
23151: PUSH
23152: LD_EXP 72
23156: PPUSH
23157: LD_VAR 0 4
23161: PPUSH
23162: LD_INT 0
23164: PPUSH
23165: CALL_OW 1
23169: ST_TO_ADDR
// end ;
23170: PPOPN 4
23172: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
23173: LD_INT 0
23175: PPUSH
23176: PPUSH
// begin labNum := 0 ;
23177: LD_ADDR_VAR 0 3
23181: PUSH
23182: LD_INT 0
23184: ST_TO_ADDR
// for i = 1 to artifactsLabs do
23185: LD_ADDR_VAR 0 2
23189: PUSH
23190: DOUBLE
23191: LD_INT 1
23193: DEC
23194: ST_TO_ADDR
23195: LD_EXP 75
23199: PUSH
23200: FOR_TO
23201: IFFALSE 23235
// if artifactsLabs [ i ] = lab then
23203: LD_EXP 75
23207: PUSH
23208: LD_VAR 0 2
23212: ARRAY
23213: PUSH
23214: LD_VAR 0 1
23218: EQUAL
23219: IFFALSE 23233
// begin labNum := i ;
23221: LD_ADDR_VAR 0 3
23225: PUSH
23226: LD_VAR 0 2
23230: ST_TO_ADDR
// break ;
23231: GO 23235
// end ;
23233: GO 23200
23235: POP
23236: POP
// if not labNum then
23237: LD_VAR 0 3
23241: NOT
23242: IFFALSE 23246
// exit ;
23244: GO 23408
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
23246: LD_INT 7
23248: PPUSH
23249: LD_EXP 76
23253: PUSH
23254: LD_VAR 0 3
23258: ARRAY
23259: PUSH
23260: LD_INT 3
23262: ARRAY
23263: PPUSH
23264: LD_INT 0
23266: PPUSH
23267: LD_VAR 0 1
23271: PPUSH
23272: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
23276: LD_ADDR_EXP 71
23280: PUSH
23281: LD_EXP 71
23285: PPUSH
23286: LD_VAR 0 3
23290: PPUSH
23291: LD_INT 1
23293: PPUSH
23294: CALL_OW 1
23298: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
23299: LD_ADDR_EXP 77
23303: PUSH
23304: LD_EXP 77
23308: PPUSH
23309: LD_VAR 0 3
23313: PPUSH
23314: LD_INT 1
23316: PPUSH
23317: CALL_OW 1
23321: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
23322: LD_ADDR_EXP 72
23326: PUSH
23327: LD_EXP 72
23331: PPUSH
23332: LD_VAR 0 3
23336: PPUSH
23337: LD_INT 0
23339: PPUSH
23340: CALL_OW 1
23344: ST_TO_ADDR
// case labNum of 1 :
23345: LD_VAR 0 3
23349: PUSH
23350: LD_INT 1
23352: DOUBLE
23353: EQUAL
23354: IFTRUE 23358
23356: GO 23369
23358: POP
// artifactIResearched := true ; 2 :
23359: LD_ADDR_EXP 12
23363: PUSH
23364: LD_INT 1
23366: ST_TO_ADDR
23367: GO 23408
23369: LD_INT 2
23371: DOUBLE
23372: EQUAL
23373: IFTRUE 23377
23375: GO 23388
23377: POP
// artifactIIResearched := true ; 3 :
23378: LD_ADDR_EXP 13
23382: PUSH
23383: LD_INT 1
23385: ST_TO_ADDR
23386: GO 23408
23388: LD_INT 3
23390: DOUBLE
23391: EQUAL
23392: IFTRUE 23396
23394: GO 23407
23396: POP
// artifactIIIResearched := true ; end ;
23397: LD_ADDR_EXP 14
23401: PUSH
23402: LD_INT 1
23404: ST_TO_ADDR
23405: GO 23408
23407: POP
// end ; end_of_file
23408: PPOPN 3
23410: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
23411: LD_INT 0
23413: PPUSH
23414: PPUSH
// skirmish := false ;
23415: LD_ADDR_EXP 78
23419: PUSH
23420: LD_INT 0
23422: ST_TO_ADDR
// debug_mc := false ;
23423: LD_ADDR_EXP 79
23427: PUSH
23428: LD_INT 0
23430: ST_TO_ADDR
// mc_bases := [ ] ;
23431: LD_ADDR_EXP 80
23435: PUSH
23436: EMPTY
23437: ST_TO_ADDR
// mc_sides := [ ] ;
23438: LD_ADDR_EXP 106
23442: PUSH
23443: EMPTY
23444: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
23445: LD_ADDR_EXP 81
23449: PUSH
23450: EMPTY
23451: ST_TO_ADDR
// mc_building_repairs := [ ] ;
23452: LD_ADDR_EXP 82
23456: PUSH
23457: EMPTY
23458: ST_TO_ADDR
// mc_need_heal := [ ] ;
23459: LD_ADDR_EXP 83
23463: PUSH
23464: EMPTY
23465: ST_TO_ADDR
// mc_healers := [ ] ;
23466: LD_ADDR_EXP 84
23470: PUSH
23471: EMPTY
23472: ST_TO_ADDR
// mc_build_list := [ ] ;
23473: LD_ADDR_EXP 85
23477: PUSH
23478: EMPTY
23479: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
23480: LD_ADDR_EXP 112
23484: PUSH
23485: EMPTY
23486: ST_TO_ADDR
// mc_builders := [ ] ;
23487: LD_ADDR_EXP 86
23491: PUSH
23492: EMPTY
23493: ST_TO_ADDR
// mc_construct_list := [ ] ;
23494: LD_ADDR_EXP 87
23498: PUSH
23499: EMPTY
23500: ST_TO_ADDR
// mc_turret_list := [ ] ;
23501: LD_ADDR_EXP 88
23505: PUSH
23506: EMPTY
23507: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
23508: LD_ADDR_EXP 89
23512: PUSH
23513: EMPTY
23514: ST_TO_ADDR
// mc_miners := [ ] ;
23515: LD_ADDR_EXP 94
23519: PUSH
23520: EMPTY
23521: ST_TO_ADDR
// mc_mines := [ ] ;
23522: LD_ADDR_EXP 93
23526: PUSH
23527: EMPTY
23528: ST_TO_ADDR
// mc_minefields := [ ] ;
23529: LD_ADDR_EXP 95
23533: PUSH
23534: EMPTY
23535: ST_TO_ADDR
// mc_crates := [ ] ;
23536: LD_ADDR_EXP 96
23540: PUSH
23541: EMPTY
23542: ST_TO_ADDR
// mc_crates_collector := [ ] ;
23543: LD_ADDR_EXP 97
23547: PUSH
23548: EMPTY
23549: ST_TO_ADDR
// mc_crates_area := [ ] ;
23550: LD_ADDR_EXP 98
23554: PUSH
23555: EMPTY
23556: ST_TO_ADDR
// mc_vehicles := [ ] ;
23557: LD_ADDR_EXP 99
23561: PUSH
23562: EMPTY
23563: ST_TO_ADDR
// mc_attack := [ ] ;
23564: LD_ADDR_EXP 100
23568: PUSH
23569: EMPTY
23570: ST_TO_ADDR
// mc_produce := [ ] ;
23571: LD_ADDR_EXP 101
23575: PUSH
23576: EMPTY
23577: ST_TO_ADDR
// mc_defender := [ ] ;
23578: LD_ADDR_EXP 102
23582: PUSH
23583: EMPTY
23584: ST_TO_ADDR
// mc_parking := [ ] ;
23585: LD_ADDR_EXP 104
23589: PUSH
23590: EMPTY
23591: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
23592: LD_ADDR_EXP 90
23596: PUSH
23597: EMPTY
23598: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
23599: LD_ADDR_EXP 92
23603: PUSH
23604: EMPTY
23605: ST_TO_ADDR
// mc_scan := [ ] ;
23606: LD_ADDR_EXP 103
23610: PUSH
23611: EMPTY
23612: ST_TO_ADDR
// mc_scan_area := [ ] ;
23613: LD_ADDR_EXP 105
23617: PUSH
23618: EMPTY
23619: ST_TO_ADDR
// mc_tech := [ ] ;
23620: LD_ADDR_EXP 107
23624: PUSH
23625: EMPTY
23626: ST_TO_ADDR
// mc_class := [ ] ;
23627: LD_ADDR_EXP 121
23631: PUSH
23632: EMPTY
23633: ST_TO_ADDR
// mc_class_case_use := [ ] ;
23634: LD_ADDR_EXP 122
23638: PUSH
23639: EMPTY
23640: ST_TO_ADDR
// mc_is_defending := [ ] ;
23641: LD_ADDR_EXP 123
23645: PUSH
23646: EMPTY
23647: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
23648: LD_ADDR_EXP 114
23652: PUSH
23653: EMPTY
23654: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
23655: LD_ADDR_EXP 124
23659: PUSH
23660: LD_INT 0
23662: ST_TO_ADDR
// end ;
23663: LD_VAR 0 1
23667: RET
// export function MC_Kill ( base ) ; begin
23668: LD_INT 0
23670: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
23671: LD_ADDR_EXP 80
23675: PUSH
23676: LD_EXP 80
23680: PPUSH
23681: LD_VAR 0 1
23685: PPUSH
23686: EMPTY
23687: PPUSH
23688: CALL_OW 1
23692: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23693: LD_ADDR_EXP 81
23697: PUSH
23698: LD_EXP 81
23702: PPUSH
23703: LD_VAR 0 1
23707: PPUSH
23708: EMPTY
23709: PPUSH
23710: CALL_OW 1
23714: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23715: LD_ADDR_EXP 82
23719: PUSH
23720: LD_EXP 82
23724: PPUSH
23725: LD_VAR 0 1
23729: PPUSH
23730: EMPTY
23731: PPUSH
23732: CALL_OW 1
23736: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23737: LD_ADDR_EXP 83
23741: PUSH
23742: LD_EXP 83
23746: PPUSH
23747: LD_VAR 0 1
23751: PPUSH
23752: EMPTY
23753: PPUSH
23754: CALL_OW 1
23758: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23759: LD_ADDR_EXP 84
23763: PUSH
23764: LD_EXP 84
23768: PPUSH
23769: LD_VAR 0 1
23773: PPUSH
23774: EMPTY
23775: PPUSH
23776: CALL_OW 1
23780: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23781: LD_ADDR_EXP 85
23785: PUSH
23786: LD_EXP 85
23790: PPUSH
23791: LD_VAR 0 1
23795: PPUSH
23796: EMPTY
23797: PPUSH
23798: CALL_OW 1
23802: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23803: LD_ADDR_EXP 86
23807: PUSH
23808: LD_EXP 86
23812: PPUSH
23813: LD_VAR 0 1
23817: PPUSH
23818: EMPTY
23819: PPUSH
23820: CALL_OW 1
23824: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23825: LD_ADDR_EXP 87
23829: PUSH
23830: LD_EXP 87
23834: PPUSH
23835: LD_VAR 0 1
23839: PPUSH
23840: EMPTY
23841: PPUSH
23842: CALL_OW 1
23846: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23847: LD_ADDR_EXP 88
23851: PUSH
23852: LD_EXP 88
23856: PPUSH
23857: LD_VAR 0 1
23861: PPUSH
23862: EMPTY
23863: PPUSH
23864: CALL_OW 1
23868: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23869: LD_ADDR_EXP 89
23873: PUSH
23874: LD_EXP 89
23878: PPUSH
23879: LD_VAR 0 1
23883: PPUSH
23884: EMPTY
23885: PPUSH
23886: CALL_OW 1
23890: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23891: LD_ADDR_EXP 90
23895: PUSH
23896: LD_EXP 90
23900: PPUSH
23901: LD_VAR 0 1
23905: PPUSH
23906: EMPTY
23907: PPUSH
23908: CALL_OW 1
23912: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23913: LD_ADDR_EXP 91
23917: PUSH
23918: LD_EXP 91
23922: PPUSH
23923: LD_VAR 0 1
23927: PPUSH
23928: LD_INT 0
23930: PPUSH
23931: CALL_OW 1
23935: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23936: LD_ADDR_EXP 92
23940: PUSH
23941: LD_EXP 92
23945: PPUSH
23946: LD_VAR 0 1
23950: PPUSH
23951: EMPTY
23952: PPUSH
23953: CALL_OW 1
23957: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23958: LD_ADDR_EXP 93
23962: PUSH
23963: LD_EXP 93
23967: PPUSH
23968: LD_VAR 0 1
23972: PPUSH
23973: EMPTY
23974: PPUSH
23975: CALL_OW 1
23979: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23980: LD_ADDR_EXP 94
23984: PUSH
23985: LD_EXP 94
23989: PPUSH
23990: LD_VAR 0 1
23994: PPUSH
23995: EMPTY
23996: PPUSH
23997: CALL_OW 1
24001: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24002: LD_ADDR_EXP 95
24006: PUSH
24007: LD_EXP 95
24011: PPUSH
24012: LD_VAR 0 1
24016: PPUSH
24017: EMPTY
24018: PPUSH
24019: CALL_OW 1
24023: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
24024: LD_ADDR_EXP 96
24028: PUSH
24029: LD_EXP 96
24033: PPUSH
24034: LD_VAR 0 1
24038: PPUSH
24039: EMPTY
24040: PPUSH
24041: CALL_OW 1
24045: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
24046: LD_ADDR_EXP 97
24050: PUSH
24051: LD_EXP 97
24055: PPUSH
24056: LD_VAR 0 1
24060: PPUSH
24061: EMPTY
24062: PPUSH
24063: CALL_OW 1
24067: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24068: LD_ADDR_EXP 98
24072: PUSH
24073: LD_EXP 98
24077: PPUSH
24078: LD_VAR 0 1
24082: PPUSH
24083: EMPTY
24084: PPUSH
24085: CALL_OW 1
24089: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
24090: LD_ADDR_EXP 99
24094: PUSH
24095: LD_EXP 99
24099: PPUSH
24100: LD_VAR 0 1
24104: PPUSH
24105: EMPTY
24106: PPUSH
24107: CALL_OW 1
24111: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
24112: LD_ADDR_EXP 100
24116: PUSH
24117: LD_EXP 100
24121: PPUSH
24122: LD_VAR 0 1
24126: PPUSH
24127: EMPTY
24128: PPUSH
24129: CALL_OW 1
24133: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
24134: LD_ADDR_EXP 101
24138: PUSH
24139: LD_EXP 101
24143: PPUSH
24144: LD_VAR 0 1
24148: PPUSH
24149: EMPTY
24150: PPUSH
24151: CALL_OW 1
24155: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
24156: LD_ADDR_EXP 102
24160: PUSH
24161: LD_EXP 102
24165: PPUSH
24166: LD_VAR 0 1
24170: PPUSH
24171: EMPTY
24172: PPUSH
24173: CALL_OW 1
24177: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
24178: LD_ADDR_EXP 103
24182: PUSH
24183: LD_EXP 103
24187: PPUSH
24188: LD_VAR 0 1
24192: PPUSH
24193: EMPTY
24194: PPUSH
24195: CALL_OW 1
24199: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
24200: LD_ADDR_EXP 104
24204: PUSH
24205: LD_EXP 104
24209: PPUSH
24210: LD_VAR 0 1
24214: PPUSH
24215: EMPTY
24216: PPUSH
24217: CALL_OW 1
24221: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
24222: LD_ADDR_EXP 105
24226: PUSH
24227: LD_EXP 105
24231: PPUSH
24232: LD_VAR 0 1
24236: PPUSH
24237: EMPTY
24238: PPUSH
24239: CALL_OW 1
24243: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24244: LD_ADDR_EXP 107
24248: PUSH
24249: LD_EXP 107
24253: PPUSH
24254: LD_VAR 0 1
24258: PPUSH
24259: EMPTY
24260: PPUSH
24261: CALL_OW 1
24265: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24266: LD_ADDR_EXP 109
24270: PUSH
24271: LD_EXP 109
24275: PPUSH
24276: LD_VAR 0 1
24280: PPUSH
24281: EMPTY
24282: PPUSH
24283: CALL_OW 1
24287: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24288: LD_ADDR_EXP 110
24292: PUSH
24293: LD_EXP 110
24297: PPUSH
24298: LD_VAR 0 1
24302: PPUSH
24303: EMPTY
24304: PPUSH
24305: CALL_OW 1
24309: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24310: LD_ADDR_EXP 111
24314: PUSH
24315: LD_EXP 111
24319: PPUSH
24320: LD_VAR 0 1
24324: PPUSH
24325: EMPTY
24326: PPUSH
24327: CALL_OW 1
24331: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24332: LD_ADDR_EXP 112
24336: PUSH
24337: LD_EXP 112
24341: PPUSH
24342: LD_VAR 0 1
24346: PPUSH
24347: EMPTY
24348: PPUSH
24349: CALL_OW 1
24353: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24354: LD_ADDR_EXP 113
24358: PUSH
24359: LD_EXP 113
24363: PPUSH
24364: LD_VAR 0 1
24368: PPUSH
24369: EMPTY
24370: PPUSH
24371: CALL_OW 1
24375: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24376: LD_ADDR_EXP 114
24380: PUSH
24381: LD_EXP 114
24385: PPUSH
24386: LD_VAR 0 1
24390: PPUSH
24391: EMPTY
24392: PPUSH
24393: CALL_OW 1
24397: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24398: LD_ADDR_EXP 115
24402: PUSH
24403: LD_EXP 115
24407: PPUSH
24408: LD_VAR 0 1
24412: PPUSH
24413: EMPTY
24414: PPUSH
24415: CALL_OW 1
24419: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24420: LD_ADDR_EXP 116
24424: PUSH
24425: LD_EXP 116
24429: PPUSH
24430: LD_VAR 0 1
24434: PPUSH
24435: EMPTY
24436: PPUSH
24437: CALL_OW 1
24441: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24442: LD_ADDR_EXP 117
24446: PUSH
24447: LD_EXP 117
24451: PPUSH
24452: LD_VAR 0 1
24456: PPUSH
24457: EMPTY
24458: PPUSH
24459: CALL_OW 1
24463: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24464: LD_ADDR_EXP 118
24468: PUSH
24469: LD_EXP 118
24473: PPUSH
24474: LD_VAR 0 1
24478: PPUSH
24479: EMPTY
24480: PPUSH
24481: CALL_OW 1
24485: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24486: LD_ADDR_EXP 119
24490: PUSH
24491: LD_EXP 119
24495: PPUSH
24496: LD_VAR 0 1
24500: PPUSH
24501: EMPTY
24502: PPUSH
24503: CALL_OW 1
24507: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24508: LD_ADDR_EXP 120
24512: PUSH
24513: LD_EXP 120
24517: PPUSH
24518: LD_VAR 0 1
24522: PPUSH
24523: EMPTY
24524: PPUSH
24525: CALL_OW 1
24529: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24530: LD_ADDR_EXP 121
24534: PUSH
24535: LD_EXP 121
24539: PPUSH
24540: LD_VAR 0 1
24544: PPUSH
24545: EMPTY
24546: PPUSH
24547: CALL_OW 1
24551: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24552: LD_ADDR_EXP 122
24556: PUSH
24557: LD_EXP 122
24561: PPUSH
24562: LD_VAR 0 1
24566: PPUSH
24567: LD_INT 0
24569: PPUSH
24570: CALL_OW 1
24574: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24575: LD_ADDR_EXP 123
24579: PUSH
24580: LD_EXP 123
24584: PPUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: LD_INT 0
24592: PPUSH
24593: CALL_OW 1
24597: ST_TO_ADDR
// end ;
24598: LD_VAR 0 2
24602: RET
// export function MC_Add ( side , units ) ; var base ; begin
24603: LD_INT 0
24605: PPUSH
24606: PPUSH
// base := mc_bases + 1 ;
24607: LD_ADDR_VAR 0 4
24611: PUSH
24612: LD_EXP 80
24616: PUSH
24617: LD_INT 1
24619: PLUS
24620: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
24621: LD_ADDR_EXP 106
24625: PUSH
24626: LD_EXP 106
24630: PPUSH
24631: LD_VAR 0 4
24635: PPUSH
24636: LD_VAR 0 1
24640: PPUSH
24641: CALL_OW 1
24645: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
24646: LD_ADDR_EXP 80
24650: PUSH
24651: LD_EXP 80
24655: PPUSH
24656: LD_VAR 0 4
24660: PPUSH
24661: LD_VAR 0 2
24665: PPUSH
24666: CALL_OW 1
24670: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
24671: LD_ADDR_EXP 81
24675: PUSH
24676: LD_EXP 81
24680: PPUSH
24681: LD_VAR 0 4
24685: PPUSH
24686: EMPTY
24687: PPUSH
24688: CALL_OW 1
24692: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
24693: LD_ADDR_EXP 82
24697: PUSH
24698: LD_EXP 82
24702: PPUSH
24703: LD_VAR 0 4
24707: PPUSH
24708: EMPTY
24709: PPUSH
24710: CALL_OW 1
24714: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
24715: LD_ADDR_EXP 83
24719: PUSH
24720: LD_EXP 83
24724: PPUSH
24725: LD_VAR 0 4
24729: PPUSH
24730: EMPTY
24731: PPUSH
24732: CALL_OW 1
24736: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
24737: LD_ADDR_EXP 84
24741: PUSH
24742: LD_EXP 84
24746: PPUSH
24747: LD_VAR 0 4
24751: PPUSH
24752: EMPTY
24753: PPUSH
24754: CALL_OW 1
24758: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
24759: LD_ADDR_EXP 85
24763: PUSH
24764: LD_EXP 85
24768: PPUSH
24769: LD_VAR 0 4
24773: PPUSH
24774: EMPTY
24775: PPUSH
24776: CALL_OW 1
24780: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
24781: LD_ADDR_EXP 86
24785: PUSH
24786: LD_EXP 86
24790: PPUSH
24791: LD_VAR 0 4
24795: PPUSH
24796: EMPTY
24797: PPUSH
24798: CALL_OW 1
24802: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
24803: LD_ADDR_EXP 87
24807: PUSH
24808: LD_EXP 87
24812: PPUSH
24813: LD_VAR 0 4
24817: PPUSH
24818: EMPTY
24819: PPUSH
24820: CALL_OW 1
24824: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
24825: LD_ADDR_EXP 88
24829: PUSH
24830: LD_EXP 88
24834: PPUSH
24835: LD_VAR 0 4
24839: PPUSH
24840: EMPTY
24841: PPUSH
24842: CALL_OW 1
24846: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
24847: LD_ADDR_EXP 89
24851: PUSH
24852: LD_EXP 89
24856: PPUSH
24857: LD_VAR 0 4
24861: PPUSH
24862: EMPTY
24863: PPUSH
24864: CALL_OW 1
24868: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
24869: LD_ADDR_EXP 90
24873: PUSH
24874: LD_EXP 90
24878: PPUSH
24879: LD_VAR 0 4
24883: PPUSH
24884: EMPTY
24885: PPUSH
24886: CALL_OW 1
24890: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
24891: LD_ADDR_EXP 91
24895: PUSH
24896: LD_EXP 91
24900: PPUSH
24901: LD_VAR 0 4
24905: PPUSH
24906: LD_INT 0
24908: PPUSH
24909: CALL_OW 1
24913: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
24914: LD_ADDR_EXP 92
24918: PUSH
24919: LD_EXP 92
24923: PPUSH
24924: LD_VAR 0 4
24928: PPUSH
24929: EMPTY
24930: PPUSH
24931: CALL_OW 1
24935: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
24936: LD_ADDR_EXP 93
24940: PUSH
24941: LD_EXP 93
24945: PPUSH
24946: LD_VAR 0 4
24950: PPUSH
24951: EMPTY
24952: PPUSH
24953: CALL_OW 1
24957: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
24958: LD_ADDR_EXP 94
24962: PUSH
24963: LD_EXP 94
24967: PPUSH
24968: LD_VAR 0 4
24972: PPUSH
24973: EMPTY
24974: PPUSH
24975: CALL_OW 1
24979: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24980: LD_ADDR_EXP 95
24984: PUSH
24985: LD_EXP 95
24989: PPUSH
24990: LD_VAR 0 4
24994: PPUSH
24995: EMPTY
24996: PPUSH
24997: CALL_OW 1
25001: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
25002: LD_ADDR_EXP 96
25006: PUSH
25007: LD_EXP 96
25011: PPUSH
25012: LD_VAR 0 4
25016: PPUSH
25017: EMPTY
25018: PPUSH
25019: CALL_OW 1
25023: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
25024: LD_ADDR_EXP 97
25028: PUSH
25029: LD_EXP 97
25033: PPUSH
25034: LD_VAR 0 4
25038: PPUSH
25039: EMPTY
25040: PPUSH
25041: CALL_OW 1
25045: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
25046: LD_ADDR_EXP 98
25050: PUSH
25051: LD_EXP 98
25055: PPUSH
25056: LD_VAR 0 4
25060: PPUSH
25061: EMPTY
25062: PPUSH
25063: CALL_OW 1
25067: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
25068: LD_ADDR_EXP 99
25072: PUSH
25073: LD_EXP 99
25077: PPUSH
25078: LD_VAR 0 4
25082: PPUSH
25083: EMPTY
25084: PPUSH
25085: CALL_OW 1
25089: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
25090: LD_ADDR_EXP 100
25094: PUSH
25095: LD_EXP 100
25099: PPUSH
25100: LD_VAR 0 4
25104: PPUSH
25105: EMPTY
25106: PPUSH
25107: CALL_OW 1
25111: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
25112: LD_ADDR_EXP 101
25116: PUSH
25117: LD_EXP 101
25121: PPUSH
25122: LD_VAR 0 4
25126: PPUSH
25127: EMPTY
25128: PPUSH
25129: CALL_OW 1
25133: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
25134: LD_ADDR_EXP 102
25138: PUSH
25139: LD_EXP 102
25143: PPUSH
25144: LD_VAR 0 4
25148: PPUSH
25149: EMPTY
25150: PPUSH
25151: CALL_OW 1
25155: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
25156: LD_ADDR_EXP 103
25160: PUSH
25161: LD_EXP 103
25165: PPUSH
25166: LD_VAR 0 4
25170: PPUSH
25171: EMPTY
25172: PPUSH
25173: CALL_OW 1
25177: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
25178: LD_ADDR_EXP 104
25182: PUSH
25183: LD_EXP 104
25187: PPUSH
25188: LD_VAR 0 4
25192: PPUSH
25193: EMPTY
25194: PPUSH
25195: CALL_OW 1
25199: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
25200: LD_ADDR_EXP 105
25204: PUSH
25205: LD_EXP 105
25209: PPUSH
25210: LD_VAR 0 4
25214: PPUSH
25215: EMPTY
25216: PPUSH
25217: CALL_OW 1
25221: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
25222: LD_ADDR_EXP 107
25226: PUSH
25227: LD_EXP 107
25231: PPUSH
25232: LD_VAR 0 4
25236: PPUSH
25237: EMPTY
25238: PPUSH
25239: CALL_OW 1
25243: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
25244: LD_ADDR_EXP 109
25248: PUSH
25249: LD_EXP 109
25253: PPUSH
25254: LD_VAR 0 4
25258: PPUSH
25259: EMPTY
25260: PPUSH
25261: CALL_OW 1
25265: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
25266: LD_ADDR_EXP 110
25270: PUSH
25271: LD_EXP 110
25275: PPUSH
25276: LD_VAR 0 4
25280: PPUSH
25281: EMPTY
25282: PPUSH
25283: CALL_OW 1
25287: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
25288: LD_ADDR_EXP 111
25292: PUSH
25293: LD_EXP 111
25297: PPUSH
25298: LD_VAR 0 4
25302: PPUSH
25303: EMPTY
25304: PPUSH
25305: CALL_OW 1
25309: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
25310: LD_ADDR_EXP 112
25314: PUSH
25315: LD_EXP 112
25319: PPUSH
25320: LD_VAR 0 4
25324: PPUSH
25325: EMPTY
25326: PPUSH
25327: CALL_OW 1
25331: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
25332: LD_ADDR_EXP 113
25336: PUSH
25337: LD_EXP 113
25341: PPUSH
25342: LD_VAR 0 4
25346: PPUSH
25347: EMPTY
25348: PPUSH
25349: CALL_OW 1
25353: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
25354: LD_ADDR_EXP 114
25358: PUSH
25359: LD_EXP 114
25363: PPUSH
25364: LD_VAR 0 4
25368: PPUSH
25369: EMPTY
25370: PPUSH
25371: CALL_OW 1
25375: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
25376: LD_ADDR_EXP 115
25380: PUSH
25381: LD_EXP 115
25385: PPUSH
25386: LD_VAR 0 4
25390: PPUSH
25391: EMPTY
25392: PPUSH
25393: CALL_OW 1
25397: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
25398: LD_ADDR_EXP 116
25402: PUSH
25403: LD_EXP 116
25407: PPUSH
25408: LD_VAR 0 4
25412: PPUSH
25413: EMPTY
25414: PPUSH
25415: CALL_OW 1
25419: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
25420: LD_ADDR_EXP 117
25424: PUSH
25425: LD_EXP 117
25429: PPUSH
25430: LD_VAR 0 4
25434: PPUSH
25435: EMPTY
25436: PPUSH
25437: CALL_OW 1
25441: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
25442: LD_ADDR_EXP 118
25446: PUSH
25447: LD_EXP 118
25451: PPUSH
25452: LD_VAR 0 4
25456: PPUSH
25457: EMPTY
25458: PPUSH
25459: CALL_OW 1
25463: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
25464: LD_ADDR_EXP 119
25468: PUSH
25469: LD_EXP 119
25473: PPUSH
25474: LD_VAR 0 4
25478: PPUSH
25479: EMPTY
25480: PPUSH
25481: CALL_OW 1
25485: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
25486: LD_ADDR_EXP 120
25490: PUSH
25491: LD_EXP 120
25495: PPUSH
25496: LD_VAR 0 4
25500: PPUSH
25501: EMPTY
25502: PPUSH
25503: CALL_OW 1
25507: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
25508: LD_ADDR_EXP 121
25512: PUSH
25513: LD_EXP 121
25517: PPUSH
25518: LD_VAR 0 4
25522: PPUSH
25523: EMPTY
25524: PPUSH
25525: CALL_OW 1
25529: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
25530: LD_ADDR_EXP 122
25534: PUSH
25535: LD_EXP 122
25539: PPUSH
25540: LD_VAR 0 4
25544: PPUSH
25545: LD_INT 0
25547: PPUSH
25548: CALL_OW 1
25552: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
25553: LD_ADDR_EXP 123
25557: PUSH
25558: LD_EXP 123
25562: PPUSH
25563: LD_VAR 0 4
25567: PPUSH
25568: LD_INT 0
25570: PPUSH
25571: CALL_OW 1
25575: ST_TO_ADDR
// result := base ;
25576: LD_ADDR_VAR 0 3
25580: PUSH
25581: LD_VAR 0 4
25585: ST_TO_ADDR
// end ;
25586: LD_VAR 0 3
25590: RET
// export function MC_Start ( ) ; var i ; begin
25591: LD_INT 0
25593: PPUSH
25594: PPUSH
// for i = 1 to mc_bases do
25595: LD_ADDR_VAR 0 2
25599: PUSH
25600: DOUBLE
25601: LD_INT 1
25603: DEC
25604: ST_TO_ADDR
25605: LD_EXP 80
25609: PUSH
25610: FOR_TO
25611: IFFALSE 26711
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
25613: LD_ADDR_EXP 80
25617: PUSH
25618: LD_EXP 80
25622: PPUSH
25623: LD_VAR 0 2
25627: PPUSH
25628: LD_EXP 80
25632: PUSH
25633: LD_VAR 0 2
25637: ARRAY
25638: PUSH
25639: LD_INT 0
25641: DIFF
25642: PPUSH
25643: CALL_OW 1
25647: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
25648: LD_ADDR_EXP 81
25652: PUSH
25653: LD_EXP 81
25657: PPUSH
25658: LD_VAR 0 2
25662: PPUSH
25663: EMPTY
25664: PPUSH
25665: CALL_OW 1
25669: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
25670: LD_ADDR_EXP 82
25674: PUSH
25675: LD_EXP 82
25679: PPUSH
25680: LD_VAR 0 2
25684: PPUSH
25685: EMPTY
25686: PPUSH
25687: CALL_OW 1
25691: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
25692: LD_ADDR_EXP 83
25696: PUSH
25697: LD_EXP 83
25701: PPUSH
25702: LD_VAR 0 2
25706: PPUSH
25707: EMPTY
25708: PPUSH
25709: CALL_OW 1
25713: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
25714: LD_ADDR_EXP 84
25718: PUSH
25719: LD_EXP 84
25723: PPUSH
25724: LD_VAR 0 2
25728: PPUSH
25729: EMPTY
25730: PUSH
25731: EMPTY
25732: PUSH
25733: EMPTY
25734: LIST
25735: LIST
25736: PPUSH
25737: CALL_OW 1
25741: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
25742: LD_ADDR_EXP 85
25746: PUSH
25747: LD_EXP 85
25751: PPUSH
25752: LD_VAR 0 2
25756: PPUSH
25757: EMPTY
25758: PPUSH
25759: CALL_OW 1
25763: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
25764: LD_ADDR_EXP 112
25768: PUSH
25769: LD_EXP 112
25773: PPUSH
25774: LD_VAR 0 2
25778: PPUSH
25779: EMPTY
25780: PPUSH
25781: CALL_OW 1
25785: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
25786: LD_ADDR_EXP 86
25790: PUSH
25791: LD_EXP 86
25795: PPUSH
25796: LD_VAR 0 2
25800: PPUSH
25801: EMPTY
25802: PPUSH
25803: CALL_OW 1
25807: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
25808: LD_ADDR_EXP 87
25812: PUSH
25813: LD_EXP 87
25817: PPUSH
25818: LD_VAR 0 2
25822: PPUSH
25823: EMPTY
25824: PPUSH
25825: CALL_OW 1
25829: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
25830: LD_ADDR_EXP 88
25834: PUSH
25835: LD_EXP 88
25839: PPUSH
25840: LD_VAR 0 2
25844: PPUSH
25845: LD_EXP 80
25849: PUSH
25850: LD_VAR 0 2
25854: ARRAY
25855: PPUSH
25856: LD_INT 2
25858: PUSH
25859: LD_INT 30
25861: PUSH
25862: LD_INT 32
25864: PUSH
25865: EMPTY
25866: LIST
25867: LIST
25868: PUSH
25869: LD_INT 30
25871: PUSH
25872: LD_INT 33
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: LIST
25883: PPUSH
25884: CALL_OW 72
25888: PPUSH
25889: CALL_OW 1
25893: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
25894: LD_ADDR_EXP 89
25898: PUSH
25899: LD_EXP 89
25903: PPUSH
25904: LD_VAR 0 2
25908: PPUSH
25909: LD_EXP 80
25913: PUSH
25914: LD_VAR 0 2
25918: ARRAY
25919: PPUSH
25920: LD_INT 2
25922: PUSH
25923: LD_INT 30
25925: PUSH
25926: LD_INT 32
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: PUSH
25933: LD_INT 30
25935: PUSH
25936: LD_INT 31
25938: PUSH
25939: EMPTY
25940: LIST
25941: LIST
25942: PUSH
25943: EMPTY
25944: LIST
25945: LIST
25946: LIST
25947: PUSH
25948: LD_INT 58
25950: PUSH
25951: EMPTY
25952: LIST
25953: PUSH
25954: EMPTY
25955: LIST
25956: LIST
25957: PPUSH
25958: CALL_OW 72
25962: PPUSH
25963: CALL_OW 1
25967: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
25968: LD_ADDR_EXP 90
25972: PUSH
25973: LD_EXP 90
25977: PPUSH
25978: LD_VAR 0 2
25982: PPUSH
25983: EMPTY
25984: PPUSH
25985: CALL_OW 1
25989: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
25990: LD_ADDR_EXP 94
25994: PUSH
25995: LD_EXP 94
25999: PPUSH
26000: LD_VAR 0 2
26004: PPUSH
26005: EMPTY
26006: PPUSH
26007: CALL_OW 1
26011: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
26012: LD_ADDR_EXP 93
26016: PUSH
26017: LD_EXP 93
26021: PPUSH
26022: LD_VAR 0 2
26026: PPUSH
26027: EMPTY
26028: PPUSH
26029: CALL_OW 1
26033: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
26034: LD_ADDR_EXP 95
26038: PUSH
26039: LD_EXP 95
26043: PPUSH
26044: LD_VAR 0 2
26048: PPUSH
26049: EMPTY
26050: PPUSH
26051: CALL_OW 1
26055: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
26056: LD_ADDR_EXP 96
26060: PUSH
26061: LD_EXP 96
26065: PPUSH
26066: LD_VAR 0 2
26070: PPUSH
26071: EMPTY
26072: PPUSH
26073: CALL_OW 1
26077: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
26078: LD_ADDR_EXP 97
26082: PUSH
26083: LD_EXP 97
26087: PPUSH
26088: LD_VAR 0 2
26092: PPUSH
26093: EMPTY
26094: PPUSH
26095: CALL_OW 1
26099: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
26100: LD_ADDR_EXP 98
26104: PUSH
26105: LD_EXP 98
26109: PPUSH
26110: LD_VAR 0 2
26114: PPUSH
26115: EMPTY
26116: PPUSH
26117: CALL_OW 1
26121: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
26122: LD_ADDR_EXP 99
26126: PUSH
26127: LD_EXP 99
26131: PPUSH
26132: LD_VAR 0 2
26136: PPUSH
26137: EMPTY
26138: PPUSH
26139: CALL_OW 1
26143: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
26144: LD_ADDR_EXP 100
26148: PUSH
26149: LD_EXP 100
26153: PPUSH
26154: LD_VAR 0 2
26158: PPUSH
26159: EMPTY
26160: PPUSH
26161: CALL_OW 1
26165: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
26166: LD_ADDR_EXP 101
26170: PUSH
26171: LD_EXP 101
26175: PPUSH
26176: LD_VAR 0 2
26180: PPUSH
26181: EMPTY
26182: PPUSH
26183: CALL_OW 1
26187: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
26188: LD_ADDR_EXP 102
26192: PUSH
26193: LD_EXP 102
26197: PPUSH
26198: LD_VAR 0 2
26202: PPUSH
26203: EMPTY
26204: PPUSH
26205: CALL_OW 1
26209: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
26210: LD_ADDR_EXP 91
26214: PUSH
26215: LD_EXP 91
26219: PPUSH
26220: LD_VAR 0 2
26224: PPUSH
26225: LD_INT 0
26227: PPUSH
26228: CALL_OW 1
26232: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
26233: LD_ADDR_EXP 104
26237: PUSH
26238: LD_EXP 104
26242: PPUSH
26243: LD_VAR 0 2
26247: PPUSH
26248: LD_INT 0
26250: PPUSH
26251: CALL_OW 1
26255: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
26256: LD_ADDR_EXP 92
26260: PUSH
26261: LD_EXP 92
26265: PPUSH
26266: LD_VAR 0 2
26270: PPUSH
26271: EMPTY
26272: PPUSH
26273: CALL_OW 1
26277: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
26278: LD_ADDR_EXP 103
26282: PUSH
26283: LD_EXP 103
26287: PPUSH
26288: LD_VAR 0 2
26292: PPUSH
26293: LD_INT 0
26295: PPUSH
26296: CALL_OW 1
26300: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
26301: LD_ADDR_EXP 105
26305: PUSH
26306: LD_EXP 105
26310: PPUSH
26311: LD_VAR 0 2
26315: PPUSH
26316: EMPTY
26317: PPUSH
26318: CALL_OW 1
26322: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
26323: LD_ADDR_EXP 108
26327: PUSH
26328: LD_EXP 108
26332: PPUSH
26333: LD_VAR 0 2
26337: PPUSH
26338: LD_INT 0
26340: PPUSH
26341: CALL_OW 1
26345: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
26346: LD_ADDR_EXP 109
26350: PUSH
26351: LD_EXP 109
26355: PPUSH
26356: LD_VAR 0 2
26360: PPUSH
26361: EMPTY
26362: PPUSH
26363: CALL_OW 1
26367: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
26368: LD_ADDR_EXP 110
26372: PUSH
26373: LD_EXP 110
26377: PPUSH
26378: LD_VAR 0 2
26382: PPUSH
26383: EMPTY
26384: PPUSH
26385: CALL_OW 1
26389: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
26390: LD_ADDR_EXP 111
26394: PUSH
26395: LD_EXP 111
26399: PPUSH
26400: LD_VAR 0 2
26404: PPUSH
26405: EMPTY
26406: PPUSH
26407: CALL_OW 1
26411: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
26412: LD_ADDR_EXP 113
26416: PUSH
26417: LD_EXP 113
26421: PPUSH
26422: LD_VAR 0 2
26426: PPUSH
26427: LD_EXP 80
26431: PUSH
26432: LD_VAR 0 2
26436: ARRAY
26437: PPUSH
26438: LD_INT 2
26440: PUSH
26441: LD_INT 30
26443: PUSH
26444: LD_INT 6
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 30
26453: PUSH
26454: LD_INT 7
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PUSH
26461: LD_INT 30
26463: PUSH
26464: LD_INT 8
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: LIST
26475: LIST
26476: PPUSH
26477: CALL_OW 72
26481: PPUSH
26482: CALL_OW 1
26486: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
26487: LD_ADDR_EXP 114
26491: PUSH
26492: LD_EXP 114
26496: PPUSH
26497: LD_VAR 0 2
26501: PPUSH
26502: EMPTY
26503: PPUSH
26504: CALL_OW 1
26508: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
26509: LD_ADDR_EXP 115
26513: PUSH
26514: LD_EXP 115
26518: PPUSH
26519: LD_VAR 0 2
26523: PPUSH
26524: EMPTY
26525: PPUSH
26526: CALL_OW 1
26530: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
26531: LD_ADDR_EXP 116
26535: PUSH
26536: LD_EXP 116
26540: PPUSH
26541: LD_VAR 0 2
26545: PPUSH
26546: EMPTY
26547: PPUSH
26548: CALL_OW 1
26552: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
26553: LD_ADDR_EXP 117
26557: PUSH
26558: LD_EXP 117
26562: PPUSH
26563: LD_VAR 0 2
26567: PPUSH
26568: EMPTY
26569: PPUSH
26570: CALL_OW 1
26574: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
26575: LD_ADDR_EXP 118
26579: PUSH
26580: LD_EXP 118
26584: PPUSH
26585: LD_VAR 0 2
26589: PPUSH
26590: EMPTY
26591: PPUSH
26592: CALL_OW 1
26596: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
26597: LD_ADDR_EXP 119
26601: PUSH
26602: LD_EXP 119
26606: PPUSH
26607: LD_VAR 0 2
26611: PPUSH
26612: EMPTY
26613: PPUSH
26614: CALL_OW 1
26618: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
26619: LD_ADDR_EXP 120
26623: PUSH
26624: LD_EXP 120
26628: PPUSH
26629: LD_VAR 0 2
26633: PPUSH
26634: EMPTY
26635: PPUSH
26636: CALL_OW 1
26640: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
26641: LD_ADDR_EXP 121
26645: PUSH
26646: LD_EXP 121
26650: PPUSH
26651: LD_VAR 0 2
26655: PPUSH
26656: EMPTY
26657: PPUSH
26658: CALL_OW 1
26662: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
26663: LD_ADDR_EXP 122
26667: PUSH
26668: LD_EXP 122
26672: PPUSH
26673: LD_VAR 0 2
26677: PPUSH
26678: LD_INT 0
26680: PPUSH
26681: CALL_OW 1
26685: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
26686: LD_ADDR_EXP 123
26690: PUSH
26691: LD_EXP 123
26695: PPUSH
26696: LD_VAR 0 2
26700: PPUSH
26701: LD_INT 0
26703: PPUSH
26704: CALL_OW 1
26708: ST_TO_ADDR
// end ;
26709: GO 25610
26711: POP
26712: POP
// MC_InitSides ( ) ;
26713: CALL 26999 0 0
// MC_InitResearch ( ) ;
26717: CALL 26738 0 0
// CustomInitMacro ( ) ;
26721: CALL 252 0 0
// skirmish := true ;
26725: LD_ADDR_EXP 78
26729: PUSH
26730: LD_INT 1
26732: ST_TO_ADDR
// end ;
26733: LD_VAR 0 1
26737: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
26738: LD_INT 0
26740: PPUSH
26741: PPUSH
26742: PPUSH
26743: PPUSH
26744: PPUSH
26745: PPUSH
// if not mc_bases then
26746: LD_EXP 80
26750: NOT
26751: IFFALSE 26755
// exit ;
26753: GO 26994
// for i = 1 to 8 do
26755: LD_ADDR_VAR 0 2
26759: PUSH
26760: DOUBLE
26761: LD_INT 1
26763: DEC
26764: ST_TO_ADDR
26765: LD_INT 8
26767: PUSH
26768: FOR_TO
26769: IFFALSE 26795
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
26771: LD_ADDR_EXP 107
26775: PUSH
26776: LD_EXP 107
26780: PPUSH
26781: LD_VAR 0 2
26785: PPUSH
26786: EMPTY
26787: PPUSH
26788: CALL_OW 1
26792: ST_TO_ADDR
26793: GO 26768
26795: POP
26796: POP
// tmp := [ ] ;
26797: LD_ADDR_VAR 0 5
26801: PUSH
26802: EMPTY
26803: ST_TO_ADDR
// for i = 1 to mc_sides do
26804: LD_ADDR_VAR 0 2
26808: PUSH
26809: DOUBLE
26810: LD_INT 1
26812: DEC
26813: ST_TO_ADDR
26814: LD_EXP 106
26818: PUSH
26819: FOR_TO
26820: IFFALSE 26878
// if not mc_sides [ i ] in tmp then
26822: LD_EXP 106
26826: PUSH
26827: LD_VAR 0 2
26831: ARRAY
26832: PUSH
26833: LD_VAR 0 5
26837: IN
26838: NOT
26839: IFFALSE 26876
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
26841: LD_ADDR_VAR 0 5
26845: PUSH
26846: LD_VAR 0 5
26850: PPUSH
26851: LD_VAR 0 5
26855: PUSH
26856: LD_INT 1
26858: PLUS
26859: PPUSH
26860: LD_EXP 106
26864: PUSH
26865: LD_VAR 0 2
26869: ARRAY
26870: PPUSH
26871: CALL_OW 2
26875: ST_TO_ADDR
26876: GO 26819
26878: POP
26879: POP
// if not tmp then
26880: LD_VAR 0 5
26884: NOT
26885: IFFALSE 26889
// exit ;
26887: GO 26994
// for j in tmp do
26889: LD_ADDR_VAR 0 3
26893: PUSH
26894: LD_VAR 0 5
26898: PUSH
26899: FOR_IN
26900: IFFALSE 26992
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
26902: LD_ADDR_VAR 0 6
26906: PUSH
26907: LD_INT 22
26909: PUSH
26910: LD_VAR 0 3
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PPUSH
26919: CALL_OW 69
26923: ST_TO_ADDR
// if not un then
26924: LD_VAR 0 6
26928: NOT
26929: IFFALSE 26933
// continue ;
26931: GO 26899
// nation := GetNation ( un [ 1 ] ) ;
26933: LD_ADDR_VAR 0 4
26937: PUSH
26938: LD_VAR 0 6
26942: PUSH
26943: LD_INT 1
26945: ARRAY
26946: PPUSH
26947: CALL_OW 248
26951: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
26952: LD_ADDR_EXP 107
26956: PUSH
26957: LD_EXP 107
26961: PPUSH
26962: LD_VAR 0 3
26966: PPUSH
26967: LD_VAR 0 3
26971: PPUSH
26972: LD_VAR 0 4
26976: PPUSH
26977: LD_INT 1
26979: PPUSH
26980: CALL 54620 0 3
26984: PPUSH
26985: CALL_OW 1
26989: ST_TO_ADDR
// end ;
26990: GO 26899
26992: POP
26993: POP
// end ;
26994: LD_VAR 0 1
26998: RET
// export function MC_InitSides ( ) ; var i ; begin
26999: LD_INT 0
27001: PPUSH
27002: PPUSH
// if not mc_bases then
27003: LD_EXP 80
27007: NOT
27008: IFFALSE 27012
// exit ;
27010: GO 27086
// for i = 1 to mc_bases do
27012: LD_ADDR_VAR 0 2
27016: PUSH
27017: DOUBLE
27018: LD_INT 1
27020: DEC
27021: ST_TO_ADDR
27022: LD_EXP 80
27026: PUSH
27027: FOR_TO
27028: IFFALSE 27084
// if mc_bases [ i ] then
27030: LD_EXP 80
27034: PUSH
27035: LD_VAR 0 2
27039: ARRAY
27040: IFFALSE 27082
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
27042: LD_ADDR_EXP 106
27046: PUSH
27047: LD_EXP 106
27051: PPUSH
27052: LD_VAR 0 2
27056: PPUSH
27057: LD_EXP 80
27061: PUSH
27062: LD_VAR 0 2
27066: ARRAY
27067: PUSH
27068: LD_INT 1
27070: ARRAY
27071: PPUSH
27072: CALL_OW 255
27076: PPUSH
27077: CALL_OW 1
27081: ST_TO_ADDR
27082: GO 27027
27084: POP
27085: POP
// end ;
27086: LD_VAR 0 1
27090: RET
// every 0 0$03 trigger skirmish do
27091: LD_EXP 78
27095: IFFALSE 27249
27097: GO 27099
27099: DISABLE
// begin enable ;
27100: ENABLE
// MC_CheckBuildings ( ) ;
27101: CALL 31807 0 0
// MC_CheckPeopleLife ( ) ;
27105: CALL 31968 0 0
// RaiseSailEvent ( 100 ) ;
27109: LD_INT 100
27111: PPUSH
27112: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
27116: LD_INT 103
27118: PPUSH
27119: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
27123: LD_INT 104
27125: PPUSH
27126: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
27130: LD_INT 105
27132: PPUSH
27133: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
27137: LD_INT 106
27139: PPUSH
27140: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
27144: LD_INT 107
27146: PPUSH
27147: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
27151: LD_INT 108
27153: PPUSH
27154: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
27158: LD_INT 109
27160: PPUSH
27161: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
27165: LD_INT 110
27167: PPUSH
27168: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
27172: LD_INT 111
27174: PPUSH
27175: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
27179: LD_INT 112
27181: PPUSH
27182: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
27186: LD_INT 113
27188: PPUSH
27189: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
27193: LD_INT 120
27195: PPUSH
27196: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
27200: LD_INT 121
27202: PPUSH
27203: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
27207: LD_INT 122
27209: PPUSH
27210: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
27214: LD_INT 123
27216: PPUSH
27217: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
27221: LD_INT 124
27223: PPUSH
27224: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
27228: LD_INT 125
27230: PPUSH
27231: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
27235: LD_INT 126
27237: PPUSH
27238: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
27242: LD_INT 200
27244: PPUSH
27245: CALL_OW 427
// end ;
27249: END
// on SailEvent ( event ) do begin if event < 100 then
27250: LD_VAR 0 1
27254: PUSH
27255: LD_INT 100
27257: LESS
27258: IFFALSE 27269
// CustomEvent ( event ) ;
27260: LD_VAR 0 1
27264: PPUSH
27265: CALL 11866 0 1
// if event = 100 then
27269: LD_VAR 0 1
27273: PUSH
27274: LD_INT 100
27276: EQUAL
27277: IFFALSE 27283
// MC_ClassManager ( ) ;
27279: CALL 27677 0 0
// if event = 101 then
27283: LD_VAR 0 1
27287: PUSH
27288: LD_INT 101
27290: EQUAL
27291: IFFALSE 27297
// MC_RepairBuildings ( ) ;
27293: CALL 32555 0 0
// if event = 102 then
27297: LD_VAR 0 1
27301: PUSH
27302: LD_INT 102
27304: EQUAL
27305: IFFALSE 27311
// MC_Heal ( ) ;
27307: CALL 33494 0 0
// if event = 103 then
27311: LD_VAR 0 1
27315: PUSH
27316: LD_INT 103
27318: EQUAL
27319: IFFALSE 27325
// MC_Build ( ) ;
27321: CALL 33920 0 0
// if event = 104 then
27325: LD_VAR 0 1
27329: PUSH
27330: LD_INT 104
27332: EQUAL
27333: IFFALSE 27339
// MC_TurretWeapon ( ) ;
27335: CALL 35568 0 0
// if event = 105 then
27339: LD_VAR 0 1
27343: PUSH
27344: LD_INT 105
27346: EQUAL
27347: IFFALSE 27353
// MC_BuildUpgrade ( ) ;
27349: CALL 35113 0 0
// if event = 106 then
27353: LD_VAR 0 1
27357: PUSH
27358: LD_INT 106
27360: EQUAL
27361: IFFALSE 27367
// MC_PlantMines ( ) ;
27363: CALL 36000 0 0
// if event = 107 then
27367: LD_VAR 0 1
27371: PUSH
27372: LD_INT 107
27374: EQUAL
27375: IFFALSE 27381
// MC_CollectCrates ( ) ;
27377: CALL 36810 0 0
// if event = 108 then
27381: LD_VAR 0 1
27385: PUSH
27386: LD_INT 108
27388: EQUAL
27389: IFFALSE 27395
// MC_LinkRemoteControl ( ) ;
27391: CALL 38684 0 0
// if event = 109 then
27395: LD_VAR 0 1
27399: PUSH
27400: LD_INT 109
27402: EQUAL
27403: IFFALSE 27409
// MC_ProduceVehicle ( ) ;
27405: CALL 38869 0 0
// if event = 110 then
27409: LD_VAR 0 1
27413: PUSH
27414: LD_INT 110
27416: EQUAL
27417: IFFALSE 27423
// MC_SendAttack ( ) ;
27419: CALL 39339 0 0
// if event = 111 then
27423: LD_VAR 0 1
27427: PUSH
27428: LD_INT 111
27430: EQUAL
27431: IFFALSE 27437
// MC_Defend ( ) ;
27433: CALL 39447 0 0
// if event = 112 then
27437: LD_VAR 0 1
27441: PUSH
27442: LD_INT 112
27444: EQUAL
27445: IFFALSE 27451
// MC_Research ( ) ;
27447: CALL 40347 0 0
// if event = 113 then
27451: LD_VAR 0 1
27455: PUSH
27456: LD_INT 113
27458: EQUAL
27459: IFFALSE 27465
// MC_MinesTrigger ( ) ;
27461: CALL 41487 0 0
// if event = 120 then
27465: LD_VAR 0 1
27469: PUSH
27470: LD_INT 120
27472: EQUAL
27473: IFFALSE 27479
// MC_RepairVehicle ( ) ;
27475: CALL 41588 0 0
// if event = 121 then
27479: LD_VAR 0 1
27483: PUSH
27484: LD_INT 121
27486: EQUAL
27487: IFFALSE 27493
// MC_TameApe ( ) ;
27489: CALL 42365 0 0
// if event = 122 then
27493: LD_VAR 0 1
27497: PUSH
27498: LD_INT 122
27500: EQUAL
27501: IFFALSE 27507
// MC_ChangeApeClass ( ) ;
27503: CALL 43210 0 0
// if event = 123 then
27507: LD_VAR 0 1
27511: PUSH
27512: LD_INT 123
27514: EQUAL
27515: IFFALSE 27521
// MC_Bazooka ( ) ;
27517: CALL 43866 0 0
// if event = 124 then
27521: LD_VAR 0 1
27525: PUSH
27526: LD_INT 124
27528: EQUAL
27529: IFFALSE 27535
// MC_TeleportExit ( ) ;
27531: CALL 44068 0 0
// if event = 125 then
27535: LD_VAR 0 1
27539: PUSH
27540: LD_INT 125
27542: EQUAL
27543: IFFALSE 27549
// MC_Deposits ( ) ;
27545: CALL 44725 0 0
// if event = 126 then
27549: LD_VAR 0 1
27553: PUSH
27554: LD_INT 126
27556: EQUAL
27557: IFFALSE 27563
// MC_RemoteDriver ( ) ;
27559: CALL 45358 0 0
// if event = 200 then
27563: LD_VAR 0 1
27567: PUSH
27568: LD_INT 200
27570: EQUAL
27571: IFFALSE 27577
// MC_Idle ( ) ;
27573: CALL 47293 0 0
// end ;
27577: PPOPN 1
27579: END
// export function MC_Reset ( base , tag ) ; var i ; begin
27580: LD_INT 0
27582: PPUSH
27583: PPUSH
// if not mc_bases [ base ] or not tag then
27584: LD_EXP 80
27588: PUSH
27589: LD_VAR 0 1
27593: ARRAY
27594: NOT
27595: IFTRUE 27604
27597: PUSH
27598: LD_VAR 0 2
27602: NOT
27603: OR
27604: IFFALSE 27608
// exit ;
27606: GO 27672
// for i in mc_bases [ base ] union mc_ape [ base ] do
27608: LD_ADDR_VAR 0 4
27612: PUSH
27613: LD_EXP 80
27617: PUSH
27618: LD_VAR 0 1
27622: ARRAY
27623: PUSH
27624: LD_EXP 109
27628: PUSH
27629: LD_VAR 0 1
27633: ARRAY
27634: UNION
27635: PUSH
27636: FOR_IN
27637: IFFALSE 27670
// if GetTag ( i ) = tag then
27639: LD_VAR 0 4
27643: PPUSH
27644: CALL_OW 110
27648: PUSH
27649: LD_VAR 0 2
27653: EQUAL
27654: IFFALSE 27668
// SetTag ( i , 0 ) ;
27656: LD_VAR 0 4
27660: PPUSH
27661: LD_INT 0
27663: PPUSH
27664: CALL_OW 109
27668: GO 27636
27670: POP
27671: POP
// end ;
27672: LD_VAR 0 3
27676: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
27677: LD_INT 0
27679: PPUSH
27680: PPUSH
27681: PPUSH
27682: PPUSH
27683: PPUSH
27684: PPUSH
27685: PPUSH
27686: PPUSH
// if not mc_bases then
27687: LD_EXP 80
27691: NOT
27692: IFFALSE 27696
// exit ;
27694: GO 28147
// for i = 1 to mc_bases do
27696: LD_ADDR_VAR 0 2
27700: PUSH
27701: DOUBLE
27702: LD_INT 1
27704: DEC
27705: ST_TO_ADDR
27706: LD_EXP 80
27710: PUSH
27711: FOR_TO
27712: IFFALSE 28145
// begin tmp := MC_ClassCheckReq ( i ) ;
27714: LD_ADDR_VAR 0 4
27718: PUSH
27719: LD_VAR 0 2
27723: PPUSH
27724: CALL 28152 0 1
27728: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
27729: LD_ADDR_EXP 121
27733: PUSH
27734: LD_EXP 121
27738: PPUSH
27739: LD_VAR 0 2
27743: PPUSH
27744: LD_VAR 0 4
27748: PPUSH
27749: CALL_OW 1
27753: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
27754: LD_ADDR_VAR 0 6
27758: PUSH
27759: LD_EXP 80
27763: PUSH
27764: LD_VAR 0 2
27768: ARRAY
27769: PPUSH
27770: LD_INT 2
27772: PUSH
27773: LD_INT 30
27775: PUSH
27776: LD_INT 4
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 30
27785: PUSH
27786: LD_INT 5
27788: PUSH
27789: EMPTY
27790: LIST
27791: LIST
27792: PUSH
27793: EMPTY
27794: LIST
27795: LIST
27796: LIST
27797: PPUSH
27798: CALL_OW 72
27802: PUSH
27803: LD_EXP 80
27807: PUSH
27808: LD_VAR 0 2
27812: ARRAY
27813: PPUSH
27814: LD_INT 2
27816: PUSH
27817: LD_INT 30
27819: PUSH
27820: LD_INT 0
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 30
27829: PUSH
27830: LD_INT 1
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: LIST
27841: PPUSH
27842: CALL_OW 72
27846: PUSH
27847: LD_EXP 80
27851: PUSH
27852: LD_VAR 0 2
27856: ARRAY
27857: PPUSH
27858: LD_INT 30
27860: PUSH
27861: LD_INT 3
27863: PUSH
27864: EMPTY
27865: LIST
27866: LIST
27867: PPUSH
27868: CALL_OW 72
27872: PUSH
27873: LD_EXP 80
27877: PUSH
27878: LD_VAR 0 2
27882: ARRAY
27883: PPUSH
27884: LD_INT 2
27886: PUSH
27887: LD_INT 30
27889: PUSH
27890: LD_INT 6
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: LD_INT 30
27899: PUSH
27900: LD_INT 7
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 30
27909: PUSH
27910: LD_INT 8
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: EMPTY
27918: LIST
27919: LIST
27920: LIST
27921: LIST
27922: PPUSH
27923: CALL_OW 72
27927: PUSH
27928: EMPTY
27929: LIST
27930: LIST
27931: LIST
27932: LIST
27933: ST_TO_ADDR
// for j := 1 to 4 do
27934: LD_ADDR_VAR 0 3
27938: PUSH
27939: DOUBLE
27940: LD_INT 1
27942: DEC
27943: ST_TO_ADDR
27944: LD_INT 4
27946: PUSH
27947: FOR_TO
27948: IFFALSE 28141
// begin if not tmp [ j ] then
27950: LD_VAR 0 4
27954: PUSH
27955: LD_VAR 0 3
27959: ARRAY
27960: NOT
27961: IFFALSE 27965
// continue ;
27963: GO 27947
// for p in tmp [ j ] do
27965: LD_ADDR_VAR 0 5
27969: PUSH
27970: LD_VAR 0 4
27974: PUSH
27975: LD_VAR 0 3
27979: ARRAY
27980: PUSH
27981: FOR_IN
27982: IFFALSE 28137
// begin if not b [ j ] then
27984: LD_VAR 0 6
27988: PUSH
27989: LD_VAR 0 3
27993: ARRAY
27994: NOT
27995: IFFALSE 27999
// break ;
27997: GO 28137
// e := 0 ;
27999: LD_ADDR_VAR 0 7
28003: PUSH
28004: LD_INT 0
28006: ST_TO_ADDR
// for k in b [ j ] do
28007: LD_ADDR_VAR 0 8
28011: PUSH
28012: LD_VAR 0 6
28016: PUSH
28017: LD_VAR 0 3
28021: ARRAY
28022: PUSH
28023: FOR_IN
28024: IFFALSE 28051
// if IsNotFull ( k ) then
28026: LD_VAR 0 8
28030: PPUSH
28031: CALL 56779 0 1
28035: IFFALSE 28049
// begin e := k ;
28037: LD_ADDR_VAR 0 7
28041: PUSH
28042: LD_VAR 0 8
28046: ST_TO_ADDR
// break ;
28047: GO 28051
// end ;
28049: GO 28023
28051: POP
28052: POP
// if e and not UnitGoingToBuilding ( p , e ) then
28053: LD_VAR 0 7
28057: IFFALSE 28076
28059: PUSH
28060: LD_VAR 0 5
28064: PPUSH
28065: LD_VAR 0 7
28069: PPUSH
28070: CALL 91283 0 2
28074: NOT
28075: AND
28076: IFFALSE 28135
// begin if IsInUnit ( p ) then
28078: LD_VAR 0 5
28082: PPUSH
28083: CALL_OW 310
28087: IFFALSE 28098
// ComExitBuilding ( p ) ;
28089: LD_VAR 0 5
28093: PPUSH
28094: CALL_OW 122
// ComEnterUnit ( p , e ) ;
28098: LD_VAR 0 5
28102: PPUSH
28103: LD_VAR 0 7
28107: PPUSH
28108: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
28112: LD_VAR 0 5
28116: PPUSH
28117: LD_VAR 0 3
28121: PPUSH
28122: CALL_OW 183
// AddComExitBuilding ( p ) ;
28126: LD_VAR 0 5
28130: PPUSH
28131: CALL_OW 182
// end ; end ;
28135: GO 27981
28137: POP
28138: POP
// end ;
28139: GO 27947
28141: POP
28142: POP
// end ;
28143: GO 27711
28145: POP
28146: POP
// end ;
28147: LD_VAR 0 1
28151: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
28152: LD_INT 0
28154: PPUSH
28155: PPUSH
28156: PPUSH
28157: PPUSH
28158: PPUSH
28159: PPUSH
28160: PPUSH
28161: PPUSH
28162: PPUSH
28163: PPUSH
28164: PPUSH
28165: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
28166: LD_ADDR_VAR 0 2
28170: PUSH
28171: LD_INT 0
28173: PUSH
28174: LD_INT 0
28176: PUSH
28177: LD_INT 0
28179: PUSH
28180: LD_INT 0
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: LIST
28187: LIST
28188: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
28189: LD_VAR 0 1
28193: NOT
28194: IFTRUE 28209
28196: PUSH
28197: LD_EXP 80
28201: PUSH
28202: LD_VAR 0 1
28206: ARRAY
28207: NOT
28208: OR
28209: IFTRUE 28257
28211: PUSH
28212: LD_EXP 80
28216: PUSH
28217: LD_VAR 0 1
28221: ARRAY
28222: PPUSH
28223: LD_INT 2
28225: PUSH
28226: LD_INT 30
28228: PUSH
28229: LD_INT 0
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 30
28238: PUSH
28239: LD_INT 1
28241: PUSH
28242: EMPTY
28243: LIST
28244: LIST
28245: PUSH
28246: EMPTY
28247: LIST
28248: LIST
28249: LIST
28250: PPUSH
28251: CALL_OW 72
28255: NOT
28256: OR
28257: IFFALSE 28261
// exit ;
28259: GO 31802
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
28261: LD_ADDR_VAR 0 4
28265: PUSH
28266: LD_EXP 80
28270: PUSH
28271: LD_VAR 0 1
28275: ARRAY
28276: PPUSH
28277: LD_INT 2
28279: PUSH
28280: LD_INT 25
28282: PUSH
28283: LD_INT 1
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 25
28292: PUSH
28293: LD_INT 2
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: LD_INT 25
28302: PUSH
28303: LD_INT 3
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 25
28312: PUSH
28313: LD_INT 4
28315: PUSH
28316: EMPTY
28317: LIST
28318: LIST
28319: PUSH
28320: LD_INT 25
28322: PUSH
28323: LD_INT 5
28325: PUSH
28326: EMPTY
28327: LIST
28328: LIST
28329: PUSH
28330: LD_INT 25
28332: PUSH
28333: LD_INT 8
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: LD_INT 25
28342: PUSH
28343: LD_INT 9
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: LIST
28354: LIST
28355: LIST
28356: LIST
28357: LIST
28358: LIST
28359: PPUSH
28360: CALL_OW 72
28364: ST_TO_ADDR
// if not tmp then
28365: LD_VAR 0 4
28369: NOT
28370: IFFALSE 28374
// exit ;
28372: GO 31802
// for i in tmp do
28374: LD_ADDR_VAR 0 3
28378: PUSH
28379: LD_VAR 0 4
28383: PUSH
28384: FOR_IN
28385: IFFALSE 28416
// if GetTag ( i ) then
28387: LD_VAR 0 3
28391: PPUSH
28392: CALL_OW 110
28396: IFFALSE 28414
// tmp := tmp diff i ;
28398: LD_ADDR_VAR 0 4
28402: PUSH
28403: LD_VAR 0 4
28407: PUSH
28408: LD_VAR 0 3
28412: DIFF
28413: ST_TO_ADDR
28414: GO 28384
28416: POP
28417: POP
// if not tmp then
28418: LD_VAR 0 4
28422: NOT
28423: IFFALSE 28427
// exit ;
28425: GO 31802
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
28427: LD_ADDR_VAR 0 5
28431: PUSH
28432: LD_EXP 80
28436: PUSH
28437: LD_VAR 0 1
28441: ARRAY
28442: PPUSH
28443: LD_INT 2
28445: PUSH
28446: LD_INT 25
28448: PUSH
28449: LD_INT 1
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 25
28458: PUSH
28459: LD_INT 5
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: LD_INT 25
28468: PUSH
28469: LD_INT 8
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PUSH
28476: LD_INT 25
28478: PUSH
28479: LD_INT 9
28481: PUSH
28482: EMPTY
28483: LIST
28484: LIST
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: PPUSH
28493: CALL_OW 72
28497: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
28498: LD_ADDR_VAR 0 6
28502: PUSH
28503: LD_EXP 80
28507: PUSH
28508: LD_VAR 0 1
28512: ARRAY
28513: PPUSH
28514: LD_INT 25
28516: PUSH
28517: LD_INT 2
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PPUSH
28524: CALL_OW 72
28528: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
28529: LD_ADDR_VAR 0 7
28533: PUSH
28534: LD_EXP 80
28538: PUSH
28539: LD_VAR 0 1
28543: ARRAY
28544: PPUSH
28545: LD_INT 25
28547: PUSH
28548: LD_INT 3
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PPUSH
28555: CALL_OW 72
28559: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
28560: LD_ADDR_VAR 0 8
28564: PUSH
28565: LD_EXP 80
28569: PUSH
28570: LD_VAR 0 1
28574: ARRAY
28575: PPUSH
28576: LD_INT 25
28578: PUSH
28579: LD_INT 4
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 24
28588: PUSH
28589: LD_INT 251
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PPUSH
28600: CALL_OW 72
28604: ST_TO_ADDR
// if mc_is_defending [ base ] then
28605: LD_EXP 123
28609: PUSH
28610: LD_VAR 0 1
28614: ARRAY
28615: IFFALSE 29076
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
28617: LD_ADDR_EXP 122
28621: PUSH
28622: LD_EXP 122
28626: PPUSH
28627: LD_VAR 0 1
28631: PPUSH
28632: LD_INT 4
28634: PPUSH
28635: CALL_OW 1
28639: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
28640: LD_ADDR_VAR 0 12
28644: PUSH
28645: LD_EXP 80
28649: PUSH
28650: LD_VAR 0 1
28654: ARRAY
28655: PPUSH
28656: LD_INT 2
28658: PUSH
28659: LD_INT 30
28661: PUSH
28662: LD_INT 4
28664: PUSH
28665: EMPTY
28666: LIST
28667: LIST
28668: PUSH
28669: LD_INT 30
28671: PUSH
28672: LD_INT 5
28674: PUSH
28675: EMPTY
28676: LIST
28677: LIST
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: LIST
28683: PPUSH
28684: CALL_OW 72
28688: ST_TO_ADDR
// if not b then
28689: LD_VAR 0 12
28693: NOT
28694: IFFALSE 28698
// exit ;
28696: GO 31802
// p := [ ] ;
28698: LD_ADDR_VAR 0 11
28702: PUSH
28703: EMPTY
28704: ST_TO_ADDR
// if sci >= 2 then
28705: LD_VAR 0 8
28709: PUSH
28710: LD_INT 2
28712: GREATEREQUAL
28713: IFFALSE 28744
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
28715: LD_ADDR_VAR 0 8
28719: PUSH
28720: LD_VAR 0 8
28724: PUSH
28725: LD_INT 1
28727: ARRAY
28728: PUSH
28729: LD_VAR 0 8
28733: PUSH
28734: LD_INT 2
28736: ARRAY
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: ST_TO_ADDR
28742: GO 28805
// if sci = 1 then
28744: LD_VAR 0 8
28748: PUSH
28749: LD_INT 1
28751: EQUAL
28752: IFFALSE 28773
// sci := [ sci [ 1 ] ] else
28754: LD_ADDR_VAR 0 8
28758: PUSH
28759: LD_VAR 0 8
28763: PUSH
28764: LD_INT 1
28766: ARRAY
28767: PUSH
28768: EMPTY
28769: LIST
28770: ST_TO_ADDR
28771: GO 28805
// if sci = 0 then
28773: LD_VAR 0 8
28777: PUSH
28778: LD_INT 0
28780: EQUAL
28781: IFFALSE 28805
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
28783: LD_ADDR_VAR 0 11
28787: PUSH
28788: LD_VAR 0 4
28792: PPUSH
28793: LD_INT 4
28795: PPUSH
28796: CALL 91153 0 2
28800: PUSH
28801: LD_INT 1
28803: ARRAY
28804: ST_TO_ADDR
// if eng > 4 then
28805: LD_VAR 0 6
28809: PUSH
28810: LD_INT 4
28812: GREATER
28813: IFFALSE 28859
// for i = eng downto 4 do
28815: LD_ADDR_VAR 0 3
28819: PUSH
28820: DOUBLE
28821: LD_VAR 0 6
28825: INC
28826: ST_TO_ADDR
28827: LD_INT 4
28829: PUSH
28830: FOR_DOWNTO
28831: IFFALSE 28857
// eng := eng diff eng [ i ] ;
28833: LD_ADDR_VAR 0 6
28837: PUSH
28838: LD_VAR 0 6
28842: PUSH
28843: LD_VAR 0 6
28847: PUSH
28848: LD_VAR 0 3
28852: ARRAY
28853: DIFF
28854: ST_TO_ADDR
28855: GO 28830
28857: POP
28858: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
28859: LD_ADDR_VAR 0 4
28863: PUSH
28864: LD_VAR 0 4
28868: PUSH
28869: LD_VAR 0 5
28873: PUSH
28874: LD_VAR 0 6
28878: UNION
28879: PUSH
28880: LD_VAR 0 7
28884: UNION
28885: PUSH
28886: LD_VAR 0 8
28890: UNION
28891: DIFF
28892: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
28893: LD_ADDR_VAR 0 13
28897: PUSH
28898: LD_EXP 80
28902: PUSH
28903: LD_VAR 0 1
28907: ARRAY
28908: PPUSH
28909: LD_INT 2
28911: PUSH
28912: LD_INT 30
28914: PUSH
28915: LD_INT 32
28917: PUSH
28918: EMPTY
28919: LIST
28920: LIST
28921: PUSH
28922: LD_INT 30
28924: PUSH
28925: LD_INT 31
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: LIST
28936: PPUSH
28937: CALL_OW 72
28941: PUSH
28942: LD_EXP 80
28946: PUSH
28947: LD_VAR 0 1
28951: ARRAY
28952: PPUSH
28953: LD_INT 2
28955: PUSH
28956: LD_INT 30
28958: PUSH
28959: LD_INT 4
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: LD_INT 30
28968: PUSH
28969: LD_INT 5
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: LIST
28980: PPUSH
28981: CALL_OW 72
28985: PUSH
28986: LD_INT 6
28988: MUL
28989: PLUS
28990: ST_TO_ADDR
// if bcount < tmp then
28991: LD_VAR 0 13
28995: PUSH
28996: LD_VAR 0 4
29000: LESS
29001: IFFALSE 29047
// for i = tmp downto bcount do
29003: LD_ADDR_VAR 0 3
29007: PUSH
29008: DOUBLE
29009: LD_VAR 0 4
29013: INC
29014: ST_TO_ADDR
29015: LD_VAR 0 13
29019: PUSH
29020: FOR_DOWNTO
29021: IFFALSE 29045
// tmp := Delete ( tmp , tmp ) ;
29023: LD_ADDR_VAR 0 4
29027: PUSH
29028: LD_VAR 0 4
29032: PPUSH
29033: LD_VAR 0 4
29037: PPUSH
29038: CALL_OW 3
29042: ST_TO_ADDR
29043: GO 29020
29045: POP
29046: POP
// result := [ tmp , 0 , 0 , p ] ;
29047: LD_ADDR_VAR 0 2
29051: PUSH
29052: LD_VAR 0 4
29056: PUSH
29057: LD_INT 0
29059: PUSH
29060: LD_INT 0
29062: PUSH
29063: LD_VAR 0 11
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: LIST
29072: LIST
29073: ST_TO_ADDR
// exit ;
29074: GO 31802
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
29076: LD_EXP 80
29080: PUSH
29081: LD_VAR 0 1
29085: ARRAY
29086: PPUSH
29087: LD_INT 2
29089: PUSH
29090: LD_INT 30
29092: PUSH
29093: LD_INT 6
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 30
29102: PUSH
29103: LD_INT 7
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 30
29112: PUSH
29113: LD_INT 8
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: EMPTY
29121: LIST
29122: LIST
29123: LIST
29124: LIST
29125: PPUSH
29126: CALL_OW 72
29130: NOT
29131: IFFALSE 29161
29133: PUSH
29134: LD_EXP 80
29138: PUSH
29139: LD_VAR 0 1
29143: ARRAY
29144: PPUSH
29145: LD_INT 30
29147: PUSH
29148: LD_INT 3
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PPUSH
29155: CALL_OW 72
29159: NOT
29160: AND
29161: IFFALSE 29233
// begin if eng = tmp then
29163: LD_VAR 0 6
29167: PUSH
29168: LD_VAR 0 4
29172: EQUAL
29173: IFFALSE 29177
// exit ;
29175: GO 31802
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
29177: LD_ADDR_EXP 122
29181: PUSH
29182: LD_EXP 122
29186: PPUSH
29187: LD_VAR 0 1
29191: PPUSH
29192: LD_INT 1
29194: PPUSH
29195: CALL_OW 1
29199: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
29200: LD_ADDR_VAR 0 2
29204: PUSH
29205: LD_INT 0
29207: PUSH
29208: LD_VAR 0 4
29212: PUSH
29213: LD_VAR 0 6
29217: DIFF
29218: PUSH
29219: LD_INT 0
29221: PUSH
29222: LD_INT 0
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: ST_TO_ADDR
// exit ;
29231: GO 31802
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
29233: LD_EXP 107
29237: PUSH
29238: LD_EXP 106
29242: PUSH
29243: LD_VAR 0 1
29247: ARRAY
29248: ARRAY
29249: IFFALSE 29307
29251: PUSH
29252: LD_EXP 80
29256: PUSH
29257: LD_VAR 0 1
29261: ARRAY
29262: PPUSH
29263: LD_INT 2
29265: PUSH
29266: LD_INT 30
29268: PUSH
29269: LD_INT 6
29271: PUSH
29272: EMPTY
29273: LIST
29274: LIST
29275: PUSH
29276: LD_INT 30
29278: PUSH
29279: LD_INT 7
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 30
29288: PUSH
29289: LD_INT 8
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: LIST
29300: LIST
29301: PPUSH
29302: CALL_OW 72
29306: AND
29307: IFFALSE 29337
29309: PUSH
29310: LD_EXP 80
29314: PUSH
29315: LD_VAR 0 1
29319: ARRAY
29320: PPUSH
29321: LD_INT 30
29323: PUSH
29324: LD_INT 3
29326: PUSH
29327: EMPTY
29328: LIST
29329: LIST
29330: PPUSH
29331: CALL_OW 72
29335: NOT
29336: AND
29337: IFFALSE 29553
// begin if sci >= 6 then
29339: LD_VAR 0 8
29343: PUSH
29344: LD_INT 6
29346: GREATEREQUAL
29347: IFFALSE 29351
// exit ;
29349: GO 31802
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
29351: LD_ADDR_EXP 122
29355: PUSH
29356: LD_EXP 122
29360: PPUSH
29361: LD_VAR 0 1
29365: PPUSH
29366: LD_INT 2
29368: PPUSH
29369: CALL_OW 1
29373: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
29374: LD_ADDR_VAR 0 9
29378: PUSH
29379: LD_VAR 0 4
29383: PUSH
29384: LD_VAR 0 8
29388: DIFF
29389: PPUSH
29390: LD_INT 4
29392: PPUSH
29393: CALL 91153 0 2
29397: ST_TO_ADDR
// p := [ ] ;
29398: LD_ADDR_VAR 0 11
29402: PUSH
29403: EMPTY
29404: ST_TO_ADDR
// if sci < 6 and sort > 6 then
29405: LD_VAR 0 8
29409: PUSH
29410: LD_INT 6
29412: LESS
29413: IFFALSE 29425
29415: PUSH
29416: LD_VAR 0 9
29420: PUSH
29421: LD_INT 6
29423: GREATER
29424: AND
29425: IFFALSE 29506
// begin for i = 1 to 6 - sci do
29427: LD_ADDR_VAR 0 3
29431: PUSH
29432: DOUBLE
29433: LD_INT 1
29435: DEC
29436: ST_TO_ADDR
29437: LD_INT 6
29439: PUSH
29440: LD_VAR 0 8
29444: MINUS
29445: PUSH
29446: FOR_TO
29447: IFFALSE 29502
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
29449: LD_ADDR_VAR 0 11
29453: PUSH
29454: LD_VAR 0 11
29458: PPUSH
29459: LD_VAR 0 11
29463: PUSH
29464: LD_INT 1
29466: PLUS
29467: PPUSH
29468: LD_VAR 0 9
29472: PUSH
29473: LD_INT 1
29475: ARRAY
29476: PPUSH
29477: CALL_OW 2
29481: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
29482: LD_ADDR_VAR 0 9
29486: PUSH
29487: LD_VAR 0 9
29491: PPUSH
29492: LD_INT 1
29494: PPUSH
29495: CALL_OW 3
29499: ST_TO_ADDR
// end ;
29500: GO 29446
29502: POP
29503: POP
// end else
29504: GO 29526
// if sort then
29506: LD_VAR 0 9
29510: IFFALSE 29526
// p := sort [ 1 ] ;
29512: LD_ADDR_VAR 0 11
29516: PUSH
29517: LD_VAR 0 9
29521: PUSH
29522: LD_INT 1
29524: ARRAY
29525: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
29526: LD_ADDR_VAR 0 2
29530: PUSH
29531: LD_INT 0
29533: PUSH
29534: LD_INT 0
29536: PUSH
29537: LD_INT 0
29539: PUSH
29540: LD_VAR 0 11
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: LIST
29549: LIST
29550: ST_TO_ADDR
// exit ;
29551: GO 31802
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
29553: LD_EXP 107
29557: PUSH
29558: LD_EXP 106
29562: PUSH
29563: LD_VAR 0 1
29567: ARRAY
29568: ARRAY
29569: IFFALSE 29627
29571: PUSH
29572: LD_EXP 80
29576: PUSH
29577: LD_VAR 0 1
29581: ARRAY
29582: PPUSH
29583: LD_INT 2
29585: PUSH
29586: LD_INT 30
29588: PUSH
29589: LD_INT 6
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 30
29598: PUSH
29599: LD_INT 7
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 30
29608: PUSH
29609: LD_INT 8
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: LIST
29620: LIST
29621: PPUSH
29622: CALL_OW 72
29626: AND
29627: IFFALSE 29656
29629: PUSH
29630: LD_EXP 80
29634: PUSH
29635: LD_VAR 0 1
29639: ARRAY
29640: PPUSH
29641: LD_INT 30
29643: PUSH
29644: LD_INT 3
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PPUSH
29651: CALL_OW 72
29655: AND
29656: IFFALSE 30396
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
29658: LD_ADDR_EXP 122
29662: PUSH
29663: LD_EXP 122
29667: PPUSH
29668: LD_VAR 0 1
29672: PPUSH
29673: LD_INT 3
29675: PPUSH
29676: CALL_OW 1
29680: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29681: LD_ADDR_VAR 0 2
29685: PUSH
29686: LD_INT 0
29688: PUSH
29689: LD_INT 0
29691: PUSH
29692: LD_INT 0
29694: PUSH
29695: LD_INT 0
29697: PUSH
29698: EMPTY
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: ST_TO_ADDR
// if not eng then
29704: LD_VAR 0 6
29708: NOT
29709: IFFALSE 29772
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
29711: LD_ADDR_VAR 0 11
29715: PUSH
29716: LD_VAR 0 4
29720: PPUSH
29721: LD_INT 2
29723: PPUSH
29724: CALL 91153 0 2
29728: PUSH
29729: LD_INT 1
29731: ARRAY
29732: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
29733: LD_ADDR_VAR 0 2
29737: PUSH
29738: LD_VAR 0 2
29742: PPUSH
29743: LD_INT 2
29745: PPUSH
29746: LD_VAR 0 11
29750: PPUSH
29751: CALL_OW 1
29755: ST_TO_ADDR
// tmp := tmp diff p ;
29756: LD_ADDR_VAR 0 4
29760: PUSH
29761: LD_VAR 0 4
29765: PUSH
29766: LD_VAR 0 11
29770: DIFF
29771: ST_TO_ADDR
// end ; if tmp and sci < 6 then
29772: LD_VAR 0 4
29776: IFFALSE 29788
29778: PUSH
29779: LD_VAR 0 8
29783: PUSH
29784: LD_INT 6
29786: LESS
29787: AND
29788: IFFALSE 29976
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
29790: LD_ADDR_VAR 0 9
29794: PUSH
29795: LD_VAR 0 4
29799: PUSH
29800: LD_VAR 0 8
29804: PUSH
29805: LD_VAR 0 7
29809: UNION
29810: DIFF
29811: PPUSH
29812: LD_INT 4
29814: PPUSH
29815: CALL 91153 0 2
29819: ST_TO_ADDR
// p := [ ] ;
29820: LD_ADDR_VAR 0 11
29824: PUSH
29825: EMPTY
29826: ST_TO_ADDR
// if sort then
29827: LD_VAR 0 9
29831: IFFALSE 29947
// for i = 1 to 6 - sci do
29833: LD_ADDR_VAR 0 3
29837: PUSH
29838: DOUBLE
29839: LD_INT 1
29841: DEC
29842: ST_TO_ADDR
29843: LD_INT 6
29845: PUSH
29846: LD_VAR 0 8
29850: MINUS
29851: PUSH
29852: FOR_TO
29853: IFFALSE 29945
// begin if i = sort then
29855: LD_VAR 0 3
29859: PUSH
29860: LD_VAR 0 9
29864: EQUAL
29865: IFFALSE 29869
// break ;
29867: GO 29945
// if GetClass ( i ) = 4 then
29869: LD_VAR 0 3
29873: PPUSH
29874: CALL_OW 257
29878: PUSH
29879: LD_INT 4
29881: EQUAL
29882: IFFALSE 29886
// continue ;
29884: GO 29852
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29886: LD_ADDR_VAR 0 11
29890: PUSH
29891: LD_VAR 0 11
29895: PPUSH
29896: LD_VAR 0 11
29900: PUSH
29901: LD_INT 1
29903: PLUS
29904: PPUSH
29905: LD_VAR 0 9
29909: PUSH
29910: LD_VAR 0 3
29914: ARRAY
29915: PPUSH
29916: CALL_OW 2
29920: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29921: LD_ADDR_VAR 0 4
29925: PUSH
29926: LD_VAR 0 4
29930: PUSH
29931: LD_VAR 0 9
29935: PUSH
29936: LD_VAR 0 3
29940: ARRAY
29941: DIFF
29942: ST_TO_ADDR
// end ;
29943: GO 29852
29945: POP
29946: POP
// if p then
29947: LD_VAR 0 11
29951: IFFALSE 29976
// result := Replace ( result , 4 , p ) ;
29953: LD_ADDR_VAR 0 2
29957: PUSH
29958: LD_VAR 0 2
29962: PPUSH
29963: LD_INT 4
29965: PPUSH
29966: LD_VAR 0 11
29970: PPUSH
29971: CALL_OW 1
29975: ST_TO_ADDR
// end ; if tmp and mech < 6 then
29976: LD_VAR 0 4
29980: IFFALSE 29992
29982: PUSH
29983: LD_VAR 0 7
29987: PUSH
29988: LD_INT 6
29990: LESS
29991: AND
29992: IFFALSE 30180
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29994: LD_ADDR_VAR 0 9
29998: PUSH
29999: LD_VAR 0 4
30003: PUSH
30004: LD_VAR 0 8
30008: PUSH
30009: LD_VAR 0 7
30013: UNION
30014: DIFF
30015: PPUSH
30016: LD_INT 3
30018: PPUSH
30019: CALL 91153 0 2
30023: ST_TO_ADDR
// p := [ ] ;
30024: LD_ADDR_VAR 0 11
30028: PUSH
30029: EMPTY
30030: ST_TO_ADDR
// if sort then
30031: LD_VAR 0 9
30035: IFFALSE 30151
// for i = 1 to 6 - mech do
30037: LD_ADDR_VAR 0 3
30041: PUSH
30042: DOUBLE
30043: LD_INT 1
30045: DEC
30046: ST_TO_ADDR
30047: LD_INT 6
30049: PUSH
30050: LD_VAR 0 7
30054: MINUS
30055: PUSH
30056: FOR_TO
30057: IFFALSE 30149
// begin if i = sort then
30059: LD_VAR 0 3
30063: PUSH
30064: LD_VAR 0 9
30068: EQUAL
30069: IFFALSE 30073
// break ;
30071: GO 30149
// if GetClass ( i ) = 3 then
30073: LD_VAR 0 3
30077: PPUSH
30078: CALL_OW 257
30082: PUSH
30083: LD_INT 3
30085: EQUAL
30086: IFFALSE 30090
// continue ;
30088: GO 30056
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30090: LD_ADDR_VAR 0 11
30094: PUSH
30095: LD_VAR 0 11
30099: PPUSH
30100: LD_VAR 0 11
30104: PUSH
30105: LD_INT 1
30107: PLUS
30108: PPUSH
30109: LD_VAR 0 9
30113: PUSH
30114: LD_VAR 0 3
30118: ARRAY
30119: PPUSH
30120: CALL_OW 2
30124: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30125: LD_ADDR_VAR 0 4
30129: PUSH
30130: LD_VAR 0 4
30134: PUSH
30135: LD_VAR 0 9
30139: PUSH
30140: LD_VAR 0 3
30144: ARRAY
30145: DIFF
30146: ST_TO_ADDR
// end ;
30147: GO 30056
30149: POP
30150: POP
// if p then
30151: LD_VAR 0 11
30155: IFFALSE 30180
// result := Replace ( result , 3 , p ) ;
30157: LD_ADDR_VAR 0 2
30161: PUSH
30162: LD_VAR 0 2
30166: PPUSH
30167: LD_INT 3
30169: PPUSH
30170: LD_VAR 0 11
30174: PPUSH
30175: CALL_OW 1
30179: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
30180: LD_VAR 0 4
30184: PUSH
30185: LD_INT 6
30187: GREATER
30188: IFFALSE 30200
30190: PUSH
30191: LD_VAR 0 6
30195: PUSH
30196: LD_INT 6
30198: LESS
30199: AND
30200: IFFALSE 30394
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30202: LD_ADDR_VAR 0 9
30206: PUSH
30207: LD_VAR 0 4
30211: PUSH
30212: LD_VAR 0 8
30216: PUSH
30217: LD_VAR 0 7
30221: UNION
30222: PUSH
30223: LD_VAR 0 6
30227: UNION
30228: DIFF
30229: PPUSH
30230: LD_INT 2
30232: PPUSH
30233: CALL 91153 0 2
30237: ST_TO_ADDR
// p := [ ] ;
30238: LD_ADDR_VAR 0 11
30242: PUSH
30243: EMPTY
30244: ST_TO_ADDR
// if sort then
30245: LD_VAR 0 9
30249: IFFALSE 30365
// for i = 1 to 6 - eng do
30251: LD_ADDR_VAR 0 3
30255: PUSH
30256: DOUBLE
30257: LD_INT 1
30259: DEC
30260: ST_TO_ADDR
30261: LD_INT 6
30263: PUSH
30264: LD_VAR 0 6
30268: MINUS
30269: PUSH
30270: FOR_TO
30271: IFFALSE 30363
// begin if i = sort then
30273: LD_VAR 0 3
30277: PUSH
30278: LD_VAR 0 9
30282: EQUAL
30283: IFFALSE 30287
// break ;
30285: GO 30363
// if GetClass ( i ) = 2 then
30287: LD_VAR 0 3
30291: PPUSH
30292: CALL_OW 257
30296: PUSH
30297: LD_INT 2
30299: EQUAL
30300: IFFALSE 30304
// continue ;
30302: GO 30270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30304: LD_ADDR_VAR 0 11
30308: PUSH
30309: LD_VAR 0 11
30313: PPUSH
30314: LD_VAR 0 11
30318: PUSH
30319: LD_INT 1
30321: PLUS
30322: PPUSH
30323: LD_VAR 0 9
30327: PUSH
30328: LD_VAR 0 3
30332: ARRAY
30333: PPUSH
30334: CALL_OW 2
30338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30339: LD_ADDR_VAR 0 4
30343: PUSH
30344: LD_VAR 0 4
30348: PUSH
30349: LD_VAR 0 9
30353: PUSH
30354: LD_VAR 0 3
30358: ARRAY
30359: DIFF
30360: ST_TO_ADDR
// end ;
30361: GO 30270
30363: POP
30364: POP
// if p then
30365: LD_VAR 0 11
30369: IFFALSE 30394
// result := Replace ( result , 2 , p ) ;
30371: LD_ADDR_VAR 0 2
30375: PUSH
30376: LD_VAR 0 2
30380: PPUSH
30381: LD_INT 2
30383: PPUSH
30384: LD_VAR 0 11
30388: PPUSH
30389: CALL_OW 1
30393: ST_TO_ADDR
// end ; exit ;
30394: GO 31802
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
30396: LD_EXP 107
30400: PUSH
30401: LD_EXP 106
30405: PUSH
30406: LD_VAR 0 1
30410: ARRAY
30411: ARRAY
30412: NOT
30413: IFFALSE 30442
30415: PUSH
30416: LD_EXP 80
30420: PUSH
30421: LD_VAR 0 1
30425: ARRAY
30426: PPUSH
30427: LD_INT 30
30429: PUSH
30430: LD_INT 3
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PPUSH
30437: CALL_OW 72
30441: AND
30442: IFFALSE 30456
30444: PUSH
30445: LD_EXP 85
30449: PUSH
30450: LD_VAR 0 1
30454: ARRAY
30455: AND
30456: IFFALSE 31070
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
30458: LD_ADDR_EXP 122
30462: PUSH
30463: LD_EXP 122
30467: PPUSH
30468: LD_VAR 0 1
30472: PPUSH
30473: LD_INT 5
30475: PPUSH
30476: CALL_OW 1
30480: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30481: LD_ADDR_VAR 0 2
30485: PUSH
30486: LD_INT 0
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: LD_INT 0
30494: PUSH
30495: LD_INT 0
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: ST_TO_ADDR
// if sci > 1 then
30504: LD_VAR 0 8
30508: PUSH
30509: LD_INT 1
30511: GREATER
30512: IFFALSE 30540
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
30514: LD_ADDR_VAR 0 4
30518: PUSH
30519: LD_VAR 0 4
30523: PUSH
30524: LD_VAR 0 8
30528: PUSH
30529: LD_VAR 0 8
30533: PUSH
30534: LD_INT 1
30536: ARRAY
30537: DIFF
30538: DIFF
30539: ST_TO_ADDR
// if tmp and not sci then
30540: LD_VAR 0 4
30544: IFFALSE 30553
30546: PUSH
30547: LD_VAR 0 8
30551: NOT
30552: AND
30553: IFFALSE 30622
// begin sort := SortBySkill ( tmp , 4 ) ;
30555: LD_ADDR_VAR 0 9
30559: PUSH
30560: LD_VAR 0 4
30564: PPUSH
30565: LD_INT 4
30567: PPUSH
30568: CALL 91153 0 2
30572: ST_TO_ADDR
// if sort then
30573: LD_VAR 0 9
30577: IFFALSE 30593
// p := sort [ 1 ] ;
30579: LD_ADDR_VAR 0 11
30583: PUSH
30584: LD_VAR 0 9
30588: PUSH
30589: LD_INT 1
30591: ARRAY
30592: ST_TO_ADDR
// if p then
30593: LD_VAR 0 11
30597: IFFALSE 30622
// result := Replace ( result , 4 , p ) ;
30599: LD_ADDR_VAR 0 2
30603: PUSH
30604: LD_VAR 0 2
30608: PPUSH
30609: LD_INT 4
30611: PPUSH
30612: LD_VAR 0 11
30616: PPUSH
30617: CALL_OW 1
30621: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30622: LD_ADDR_VAR 0 4
30626: PUSH
30627: LD_VAR 0 4
30631: PUSH
30632: LD_VAR 0 7
30636: DIFF
30637: ST_TO_ADDR
// if tmp and mech < 6 then
30638: LD_VAR 0 4
30642: IFFALSE 30654
30644: PUSH
30645: LD_VAR 0 7
30649: PUSH
30650: LD_INT 6
30652: LESS
30653: AND
30654: IFFALSE 30842
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
30656: LD_ADDR_VAR 0 9
30660: PUSH
30661: LD_VAR 0 4
30665: PUSH
30666: LD_VAR 0 8
30670: PUSH
30671: LD_VAR 0 7
30675: UNION
30676: DIFF
30677: PPUSH
30678: LD_INT 3
30680: PPUSH
30681: CALL 91153 0 2
30685: ST_TO_ADDR
// p := [ ] ;
30686: LD_ADDR_VAR 0 11
30690: PUSH
30691: EMPTY
30692: ST_TO_ADDR
// if sort then
30693: LD_VAR 0 9
30697: IFFALSE 30813
// for i = 1 to 6 - mech do
30699: LD_ADDR_VAR 0 3
30703: PUSH
30704: DOUBLE
30705: LD_INT 1
30707: DEC
30708: ST_TO_ADDR
30709: LD_INT 6
30711: PUSH
30712: LD_VAR 0 7
30716: MINUS
30717: PUSH
30718: FOR_TO
30719: IFFALSE 30811
// begin if i = sort then
30721: LD_VAR 0 3
30725: PUSH
30726: LD_VAR 0 9
30730: EQUAL
30731: IFFALSE 30735
// break ;
30733: GO 30811
// if GetClass ( i ) = 3 then
30735: LD_VAR 0 3
30739: PPUSH
30740: CALL_OW 257
30744: PUSH
30745: LD_INT 3
30747: EQUAL
30748: IFFALSE 30752
// continue ;
30750: GO 30718
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30752: LD_ADDR_VAR 0 11
30756: PUSH
30757: LD_VAR 0 11
30761: PPUSH
30762: LD_VAR 0 11
30766: PUSH
30767: LD_INT 1
30769: PLUS
30770: PPUSH
30771: LD_VAR 0 9
30775: PUSH
30776: LD_VAR 0 3
30780: ARRAY
30781: PPUSH
30782: CALL_OW 2
30786: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30787: LD_ADDR_VAR 0 4
30791: PUSH
30792: LD_VAR 0 4
30796: PUSH
30797: LD_VAR 0 9
30801: PUSH
30802: LD_VAR 0 3
30806: ARRAY
30807: DIFF
30808: ST_TO_ADDR
// end ;
30809: GO 30718
30811: POP
30812: POP
// if p then
30813: LD_VAR 0 11
30817: IFFALSE 30842
// result := Replace ( result , 3 , p ) ;
30819: LD_ADDR_VAR 0 2
30823: PUSH
30824: LD_VAR 0 2
30828: PPUSH
30829: LD_INT 3
30831: PPUSH
30832: LD_VAR 0 11
30836: PPUSH
30837: CALL_OW 1
30841: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30842: LD_ADDR_VAR 0 4
30846: PUSH
30847: LD_VAR 0 4
30851: PUSH
30852: LD_VAR 0 6
30856: DIFF
30857: ST_TO_ADDR
// if tmp and eng < 6 then
30858: LD_VAR 0 4
30862: IFFALSE 30874
30864: PUSH
30865: LD_VAR 0 6
30869: PUSH
30870: LD_INT 6
30872: LESS
30873: AND
30874: IFFALSE 31068
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30876: LD_ADDR_VAR 0 9
30880: PUSH
30881: LD_VAR 0 4
30885: PUSH
30886: LD_VAR 0 8
30890: PUSH
30891: LD_VAR 0 7
30895: UNION
30896: PUSH
30897: LD_VAR 0 6
30901: UNION
30902: DIFF
30903: PPUSH
30904: LD_INT 2
30906: PPUSH
30907: CALL 91153 0 2
30911: ST_TO_ADDR
// p := [ ] ;
30912: LD_ADDR_VAR 0 11
30916: PUSH
30917: EMPTY
30918: ST_TO_ADDR
// if sort then
30919: LD_VAR 0 9
30923: IFFALSE 31039
// for i = 1 to 6 - eng do
30925: LD_ADDR_VAR 0 3
30929: PUSH
30930: DOUBLE
30931: LD_INT 1
30933: DEC
30934: ST_TO_ADDR
30935: LD_INT 6
30937: PUSH
30938: LD_VAR 0 6
30942: MINUS
30943: PUSH
30944: FOR_TO
30945: IFFALSE 31037
// begin if i = sort then
30947: LD_VAR 0 3
30951: PUSH
30952: LD_VAR 0 9
30956: EQUAL
30957: IFFALSE 30961
// break ;
30959: GO 31037
// if GetClass ( i ) = 2 then
30961: LD_VAR 0 3
30965: PPUSH
30966: CALL_OW 257
30970: PUSH
30971: LD_INT 2
30973: EQUAL
30974: IFFALSE 30978
// continue ;
30976: GO 30944
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30978: LD_ADDR_VAR 0 11
30982: PUSH
30983: LD_VAR 0 11
30987: PPUSH
30988: LD_VAR 0 11
30992: PUSH
30993: LD_INT 1
30995: PLUS
30996: PPUSH
30997: LD_VAR 0 9
31001: PUSH
31002: LD_VAR 0 3
31006: ARRAY
31007: PPUSH
31008: CALL_OW 2
31012: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31013: LD_ADDR_VAR 0 4
31017: PUSH
31018: LD_VAR 0 4
31022: PUSH
31023: LD_VAR 0 9
31027: PUSH
31028: LD_VAR 0 3
31032: ARRAY
31033: DIFF
31034: ST_TO_ADDR
// end ;
31035: GO 30944
31037: POP
31038: POP
// if p then
31039: LD_VAR 0 11
31043: IFFALSE 31068
// result := Replace ( result , 2 , p ) ;
31045: LD_ADDR_VAR 0 2
31049: PUSH
31050: LD_VAR 0 2
31054: PPUSH
31055: LD_INT 2
31057: PPUSH
31058: LD_VAR 0 11
31062: PPUSH
31063: CALL_OW 1
31067: ST_TO_ADDR
// end ; exit ;
31068: GO 31802
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
31070: LD_EXP 107
31074: PUSH
31075: LD_EXP 106
31079: PUSH
31080: LD_VAR 0 1
31084: ARRAY
31085: ARRAY
31086: NOT
31087: IFFALSE 31116
31089: PUSH
31090: LD_EXP 80
31094: PUSH
31095: LD_VAR 0 1
31099: ARRAY
31100: PPUSH
31101: LD_INT 30
31103: PUSH
31104: LD_INT 3
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PPUSH
31111: CALL_OW 72
31115: AND
31116: IFFALSE 31131
31118: PUSH
31119: LD_EXP 85
31123: PUSH
31124: LD_VAR 0 1
31128: ARRAY
31129: NOT
31130: AND
31131: IFFALSE 31802
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
31133: LD_ADDR_EXP 122
31137: PUSH
31138: LD_EXP 122
31142: PPUSH
31143: LD_VAR 0 1
31147: PPUSH
31148: LD_INT 6
31150: PPUSH
31151: CALL_OW 1
31155: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
31156: LD_ADDR_VAR 0 2
31160: PUSH
31161: LD_INT 0
31163: PUSH
31164: LD_INT 0
31166: PUSH
31167: LD_INT 0
31169: PUSH
31170: LD_INT 0
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: ST_TO_ADDR
// if sci >= 1 then
31179: LD_VAR 0 8
31183: PUSH
31184: LD_INT 1
31186: GREATEREQUAL
31187: IFFALSE 31209
// tmp := tmp diff sci [ 1 ] ;
31189: LD_ADDR_VAR 0 4
31193: PUSH
31194: LD_VAR 0 4
31198: PUSH
31199: LD_VAR 0 8
31203: PUSH
31204: LD_INT 1
31206: ARRAY
31207: DIFF
31208: ST_TO_ADDR
// if tmp and not sci then
31209: LD_VAR 0 4
31213: IFFALSE 31222
31215: PUSH
31216: LD_VAR 0 8
31220: NOT
31221: AND
31222: IFFALSE 31291
// begin sort := SortBySkill ( tmp , 4 ) ;
31224: LD_ADDR_VAR 0 9
31228: PUSH
31229: LD_VAR 0 4
31233: PPUSH
31234: LD_INT 4
31236: PPUSH
31237: CALL 91153 0 2
31241: ST_TO_ADDR
// if sort then
31242: LD_VAR 0 9
31246: IFFALSE 31262
// p := sort [ 1 ] ;
31248: LD_ADDR_VAR 0 11
31252: PUSH
31253: LD_VAR 0 9
31257: PUSH
31258: LD_INT 1
31260: ARRAY
31261: ST_TO_ADDR
// if p then
31262: LD_VAR 0 11
31266: IFFALSE 31291
// result := Replace ( result , 4 , p ) ;
31268: LD_ADDR_VAR 0 2
31272: PUSH
31273: LD_VAR 0 2
31277: PPUSH
31278: LD_INT 4
31280: PPUSH
31281: LD_VAR 0 11
31285: PPUSH
31286: CALL_OW 1
31290: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
31291: LD_ADDR_VAR 0 4
31295: PUSH
31296: LD_VAR 0 4
31300: PUSH
31301: LD_VAR 0 7
31305: DIFF
31306: ST_TO_ADDR
// if tmp and mech < 6 then
31307: LD_VAR 0 4
31311: IFFALSE 31323
31313: PUSH
31314: LD_VAR 0 7
31318: PUSH
31319: LD_INT 6
31321: LESS
31322: AND
31323: IFFALSE 31505
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
31325: LD_ADDR_VAR 0 9
31329: PUSH
31330: LD_VAR 0 4
31334: PUSH
31335: LD_VAR 0 7
31339: DIFF
31340: PPUSH
31341: LD_INT 3
31343: PPUSH
31344: CALL 91153 0 2
31348: ST_TO_ADDR
// p := [ ] ;
31349: LD_ADDR_VAR 0 11
31353: PUSH
31354: EMPTY
31355: ST_TO_ADDR
// if sort then
31356: LD_VAR 0 9
31360: IFFALSE 31476
// for i = 1 to 6 - mech do
31362: LD_ADDR_VAR 0 3
31366: PUSH
31367: DOUBLE
31368: LD_INT 1
31370: DEC
31371: ST_TO_ADDR
31372: LD_INT 6
31374: PUSH
31375: LD_VAR 0 7
31379: MINUS
31380: PUSH
31381: FOR_TO
31382: IFFALSE 31474
// begin if i = sort then
31384: LD_VAR 0 3
31388: PUSH
31389: LD_VAR 0 9
31393: EQUAL
31394: IFFALSE 31398
// break ;
31396: GO 31474
// if GetClass ( i ) = 3 then
31398: LD_VAR 0 3
31402: PPUSH
31403: CALL_OW 257
31407: PUSH
31408: LD_INT 3
31410: EQUAL
31411: IFFALSE 31415
// continue ;
31413: GO 31381
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31415: LD_ADDR_VAR 0 11
31419: PUSH
31420: LD_VAR 0 11
31424: PPUSH
31425: LD_VAR 0 11
31429: PUSH
31430: LD_INT 1
31432: PLUS
31433: PPUSH
31434: LD_VAR 0 9
31438: PUSH
31439: LD_VAR 0 3
31443: ARRAY
31444: PPUSH
31445: CALL_OW 2
31449: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31450: LD_ADDR_VAR 0 4
31454: PUSH
31455: LD_VAR 0 4
31459: PUSH
31460: LD_VAR 0 9
31464: PUSH
31465: LD_VAR 0 3
31469: ARRAY
31470: DIFF
31471: ST_TO_ADDR
// end ;
31472: GO 31381
31474: POP
31475: POP
// if p then
31476: LD_VAR 0 11
31480: IFFALSE 31505
// result := Replace ( result , 3 , p ) ;
31482: LD_ADDR_VAR 0 2
31486: PUSH
31487: LD_VAR 0 2
31491: PPUSH
31492: LD_INT 3
31494: PPUSH
31495: LD_VAR 0 11
31499: PPUSH
31500: CALL_OW 1
31504: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
31505: LD_ADDR_VAR 0 4
31509: PUSH
31510: LD_VAR 0 4
31514: PUSH
31515: LD_VAR 0 6
31519: DIFF
31520: ST_TO_ADDR
// if tmp and eng < 4 then
31521: LD_VAR 0 4
31525: IFFALSE 31537
31527: PUSH
31528: LD_VAR 0 6
31532: PUSH
31533: LD_INT 4
31535: LESS
31536: AND
31537: IFFALSE 31727
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
31539: LD_ADDR_VAR 0 9
31543: PUSH
31544: LD_VAR 0 4
31548: PUSH
31549: LD_VAR 0 7
31553: PUSH
31554: LD_VAR 0 6
31558: UNION
31559: DIFF
31560: PPUSH
31561: LD_INT 2
31563: PPUSH
31564: CALL 91153 0 2
31568: ST_TO_ADDR
// p := [ ] ;
31569: LD_ADDR_VAR 0 11
31573: PUSH
31574: EMPTY
31575: ST_TO_ADDR
// if sort then
31576: LD_VAR 0 9
31580: IFFALSE 31696
// for i = 1 to 4 - eng do
31582: LD_ADDR_VAR 0 3
31586: PUSH
31587: DOUBLE
31588: LD_INT 1
31590: DEC
31591: ST_TO_ADDR
31592: LD_INT 4
31594: PUSH
31595: LD_VAR 0 6
31599: MINUS
31600: PUSH
31601: FOR_TO
31602: IFFALSE 31694
// begin if i = sort then
31604: LD_VAR 0 3
31608: PUSH
31609: LD_VAR 0 9
31613: EQUAL
31614: IFFALSE 31618
// break ;
31616: GO 31694
// if GetClass ( i ) = 2 then
31618: LD_VAR 0 3
31622: PPUSH
31623: CALL_OW 257
31627: PUSH
31628: LD_INT 2
31630: EQUAL
31631: IFFALSE 31635
// continue ;
31633: GO 31601
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31635: LD_ADDR_VAR 0 11
31639: PUSH
31640: LD_VAR 0 11
31644: PPUSH
31645: LD_VAR 0 11
31649: PUSH
31650: LD_INT 1
31652: PLUS
31653: PPUSH
31654: LD_VAR 0 9
31658: PUSH
31659: LD_VAR 0 3
31663: ARRAY
31664: PPUSH
31665: CALL_OW 2
31669: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31670: LD_ADDR_VAR 0 4
31674: PUSH
31675: LD_VAR 0 4
31679: PUSH
31680: LD_VAR 0 9
31684: PUSH
31685: LD_VAR 0 3
31689: ARRAY
31690: DIFF
31691: ST_TO_ADDR
// end ;
31692: GO 31601
31694: POP
31695: POP
// if p then
31696: LD_VAR 0 11
31700: IFFALSE 31725
// result := Replace ( result , 2 , p ) ;
31702: LD_ADDR_VAR 0 2
31706: PUSH
31707: LD_VAR 0 2
31711: PPUSH
31712: LD_INT 2
31714: PPUSH
31715: LD_VAR 0 11
31719: PPUSH
31720: CALL_OW 1
31724: ST_TO_ADDR
// end else
31725: GO 31771
// for i = eng downto 5 do
31727: LD_ADDR_VAR 0 3
31731: PUSH
31732: DOUBLE
31733: LD_VAR 0 6
31737: INC
31738: ST_TO_ADDR
31739: LD_INT 5
31741: PUSH
31742: FOR_DOWNTO
31743: IFFALSE 31769
// tmp := tmp union eng [ i ] ;
31745: LD_ADDR_VAR 0 4
31749: PUSH
31750: LD_VAR 0 4
31754: PUSH
31755: LD_VAR 0 6
31759: PUSH
31760: LD_VAR 0 3
31764: ARRAY
31765: UNION
31766: ST_TO_ADDR
31767: GO 31742
31769: POP
31770: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
31771: LD_ADDR_VAR 0 2
31775: PUSH
31776: LD_VAR 0 2
31780: PPUSH
31781: LD_INT 1
31783: PPUSH
31784: LD_VAR 0 4
31788: PUSH
31789: LD_VAR 0 5
31793: DIFF
31794: PPUSH
31795: CALL_OW 1
31799: ST_TO_ADDR
// exit ;
31800: GO 31802
// end ; end ;
31802: LD_VAR 0 2
31806: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
31807: LD_INT 0
31809: PPUSH
31810: PPUSH
31811: PPUSH
// if not mc_bases then
31812: LD_EXP 80
31816: NOT
31817: IFFALSE 31821
// exit ;
31819: GO 31963
// for i = 1 to mc_bases do
31821: LD_ADDR_VAR 0 2
31825: PUSH
31826: DOUBLE
31827: LD_INT 1
31829: DEC
31830: ST_TO_ADDR
31831: LD_EXP 80
31835: PUSH
31836: FOR_TO
31837: IFFALSE 31954
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
31839: LD_ADDR_VAR 0 3
31843: PUSH
31844: LD_EXP 80
31848: PUSH
31849: LD_VAR 0 2
31853: ARRAY
31854: PPUSH
31855: LD_INT 21
31857: PUSH
31858: LD_INT 3
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 3
31867: PUSH
31868: LD_INT 2
31870: PUSH
31871: LD_INT 30
31873: PUSH
31874: LD_INT 29
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 30
31883: PUSH
31884: LD_INT 30
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: LIST
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 3
31902: PUSH
31903: LD_INT 24
31905: PUSH
31906: LD_INT 1000
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: LIST
31921: PPUSH
31922: CALL_OW 72
31926: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
31927: LD_ADDR_EXP 81
31931: PUSH
31932: LD_EXP 81
31936: PPUSH
31937: LD_VAR 0 2
31941: PPUSH
31942: LD_VAR 0 3
31946: PPUSH
31947: CALL_OW 1
31951: ST_TO_ADDR
// end ;
31952: GO 31836
31954: POP
31955: POP
// RaiseSailEvent ( 101 ) ;
31956: LD_INT 101
31958: PPUSH
31959: CALL_OW 427
// end ;
31963: LD_VAR 0 1
31967: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
31968: LD_INT 0
31970: PPUSH
31971: PPUSH
31972: PPUSH
31973: PPUSH
31974: PPUSH
31975: PPUSH
31976: PPUSH
// if not mc_bases then
31977: LD_EXP 80
31981: NOT
31982: IFFALSE 31986
// exit ;
31984: GO 32550
// for i = 1 to mc_bases do
31986: LD_ADDR_VAR 0 2
31990: PUSH
31991: DOUBLE
31992: LD_INT 1
31994: DEC
31995: ST_TO_ADDR
31996: LD_EXP 80
32000: PUSH
32001: FOR_TO
32002: IFFALSE 32541
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
32004: LD_ADDR_VAR 0 5
32008: PUSH
32009: LD_EXP 80
32013: PUSH
32014: LD_VAR 0 2
32018: ARRAY
32019: PUSH
32020: LD_EXP 109
32024: PUSH
32025: LD_VAR 0 2
32029: ARRAY
32030: UNION
32031: PPUSH
32032: LD_INT 21
32034: PUSH
32035: LD_INT 1
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: LD_INT 1
32044: PUSH
32045: LD_INT 3
32047: PUSH
32048: LD_INT 54
32050: PUSH
32051: EMPTY
32052: LIST
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: LD_INT 3
32060: PUSH
32061: LD_INT 24
32063: PUSH
32064: LD_INT 1000
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: LIST
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PPUSH
32084: CALL_OW 72
32088: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
32089: LD_ADDR_VAR 0 6
32093: PUSH
32094: LD_EXP 80
32098: PUSH
32099: LD_VAR 0 2
32103: ARRAY
32104: PPUSH
32105: LD_INT 21
32107: PUSH
32108: LD_INT 1
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: PUSH
32115: LD_INT 1
32117: PUSH
32118: LD_INT 3
32120: PUSH
32121: LD_INT 54
32123: PUSH
32124: EMPTY
32125: LIST
32126: PUSH
32127: EMPTY
32128: LIST
32129: LIST
32130: PUSH
32131: LD_INT 3
32133: PUSH
32134: LD_INT 24
32136: PUSH
32137: LD_INT 250
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: LIST
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PPUSH
32157: CALL_OW 72
32161: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
32162: LD_ADDR_VAR 0 7
32166: PUSH
32167: LD_VAR 0 5
32171: PUSH
32172: LD_VAR 0 6
32176: DIFF
32177: ST_TO_ADDR
// if not need_heal_1 then
32178: LD_VAR 0 6
32182: NOT
32183: IFFALSE 32216
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
32185: LD_ADDR_EXP 83
32189: PUSH
32190: LD_EXP 83
32194: PPUSH
32195: LD_VAR 0 2
32199: PUSH
32200: LD_INT 1
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: PPUSH
32207: EMPTY
32208: PPUSH
32209: CALL 59615 0 3
32213: ST_TO_ADDR
32214: GO 32286
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
32216: LD_ADDR_EXP 83
32220: PUSH
32221: LD_EXP 83
32225: PPUSH
32226: LD_VAR 0 2
32230: PUSH
32231: LD_INT 1
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PPUSH
32238: LD_EXP 83
32242: PUSH
32243: LD_VAR 0 2
32247: ARRAY
32248: PUSH
32249: LD_INT 1
32251: ARRAY
32252: PPUSH
32253: LD_INT 3
32255: PUSH
32256: LD_INT 24
32258: PUSH
32259: LD_INT 1000
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PPUSH
32270: CALL_OW 72
32274: PUSH
32275: LD_VAR 0 6
32279: UNION
32280: PPUSH
32281: CALL 59615 0 3
32285: ST_TO_ADDR
// if not need_heal_2 then
32286: LD_VAR 0 7
32290: NOT
32291: IFFALSE 32324
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
32293: LD_ADDR_EXP 83
32297: PUSH
32298: LD_EXP 83
32302: PPUSH
32303: LD_VAR 0 2
32307: PUSH
32308: LD_INT 2
32310: PUSH
32311: EMPTY
32312: LIST
32313: LIST
32314: PPUSH
32315: EMPTY
32316: PPUSH
32317: CALL 59615 0 3
32321: ST_TO_ADDR
32322: GO 32356
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
32324: LD_ADDR_EXP 83
32328: PUSH
32329: LD_EXP 83
32333: PPUSH
32334: LD_VAR 0 2
32338: PUSH
32339: LD_INT 2
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PPUSH
32346: LD_VAR 0 7
32350: PPUSH
32351: CALL 59615 0 3
32355: ST_TO_ADDR
// if need_heal_2 then
32356: LD_VAR 0 7
32360: IFFALSE 32521
// for j in need_heal_2 do
32362: LD_ADDR_VAR 0 3
32366: PUSH
32367: LD_VAR 0 7
32371: PUSH
32372: FOR_IN
32373: IFFALSE 32519
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32375: LD_ADDR_VAR 0 5
32379: PUSH
32380: LD_EXP 80
32384: PUSH
32385: LD_VAR 0 2
32389: ARRAY
32390: PPUSH
32391: LD_INT 2
32393: PUSH
32394: LD_INT 30
32396: PUSH
32397: LD_INT 6
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 30
32406: PUSH
32407: LD_INT 7
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 30
32416: PUSH
32417: LD_INT 8
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 30
32426: PUSH
32427: LD_INT 0
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 30
32436: PUSH
32437: LD_INT 1
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: PPUSH
32452: CALL_OW 72
32456: ST_TO_ADDR
// if tmp then
32457: LD_VAR 0 5
32461: IFFALSE 32517
// begin k := NearestUnitToUnit ( tmp , j ) ;
32463: LD_ADDR_VAR 0 4
32467: PUSH
32468: LD_VAR 0 5
32472: PPUSH
32473: LD_VAR 0 3
32477: PPUSH
32478: CALL_OW 74
32482: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
32483: LD_VAR 0 3
32487: PPUSH
32488: LD_VAR 0 4
32492: PPUSH
32493: CALL_OW 296
32497: PUSH
32498: LD_INT 5
32500: GREATER
32501: IFFALSE 32517
// ComMoveToNearbyEntrance ( j , k ) ;
32503: LD_VAR 0 3
32507: PPUSH
32508: LD_VAR 0 4
32512: PPUSH
32513: CALL 93552 0 2
// end ; end ;
32517: GO 32372
32519: POP
32520: POP
// if not need_heal_1 and not need_heal_2 then
32521: LD_VAR 0 6
32525: NOT
32526: IFFALSE 32535
32528: PUSH
32529: LD_VAR 0 7
32533: NOT
32534: AND
32535: IFFALSE 32539
// continue ;
32537: GO 32001
// end ;
32539: GO 32001
32541: POP
32542: POP
// RaiseSailEvent ( 102 ) ;
32543: LD_INT 102
32545: PPUSH
32546: CALL_OW 427
// end ;
32550: LD_VAR 0 1
32554: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
32555: LD_INT 0
32557: PPUSH
32558: PPUSH
32559: PPUSH
32560: PPUSH
32561: PPUSH
32562: PPUSH
32563: PPUSH
32564: PPUSH
// if not mc_bases then
32565: LD_EXP 80
32569: NOT
32570: IFFALSE 32574
// exit ;
32572: GO 33489
// for i = 1 to mc_bases do
32574: LD_ADDR_VAR 0 2
32578: PUSH
32579: DOUBLE
32580: LD_INT 1
32582: DEC
32583: ST_TO_ADDR
32584: LD_EXP 80
32588: PUSH
32589: FOR_TO
32590: IFFALSE 33487
// begin if not mc_building_need_repair [ i ] then
32592: LD_EXP 81
32596: PUSH
32597: LD_VAR 0 2
32601: ARRAY
32602: NOT
32603: IFFALSE 32788
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
32605: LD_ADDR_VAR 0 6
32609: PUSH
32610: LD_EXP 99
32614: PUSH
32615: LD_VAR 0 2
32619: ARRAY
32620: PPUSH
32621: LD_INT 3
32623: PUSH
32624: LD_INT 24
32626: PUSH
32627: LD_INT 1000
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 2
32640: PUSH
32641: LD_INT 34
32643: PUSH
32644: LD_INT 13
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: LD_INT 34
32653: PUSH
32654: LD_INT 52
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: PUSH
32661: LD_INT 34
32663: PUSH
32664: LD_INT 88
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: LIST
32675: LIST
32676: PUSH
32677: EMPTY
32678: LIST
32679: LIST
32680: PPUSH
32681: CALL_OW 72
32685: ST_TO_ADDR
// if cranes then
32686: LD_VAR 0 6
32690: IFFALSE 32752
// for j in cranes do
32692: LD_ADDR_VAR 0 3
32696: PUSH
32697: LD_VAR 0 6
32701: PUSH
32702: FOR_IN
32703: IFFALSE 32750
// if not IsInArea ( j , mc_parking [ i ] ) then
32705: LD_VAR 0 3
32709: PPUSH
32710: LD_EXP 104
32714: PUSH
32715: LD_VAR 0 2
32719: ARRAY
32720: PPUSH
32721: CALL_OW 308
32725: NOT
32726: IFFALSE 32748
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32728: LD_VAR 0 3
32732: PPUSH
32733: LD_EXP 104
32737: PUSH
32738: LD_VAR 0 2
32742: ARRAY
32743: PPUSH
32744: CALL_OW 113
32748: GO 32702
32750: POP
32751: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
32752: LD_ADDR_EXP 82
32756: PUSH
32757: LD_EXP 82
32761: PPUSH
32762: LD_VAR 0 2
32766: PPUSH
32767: EMPTY
32768: PPUSH
32769: CALL_OW 1
32773: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
32774: LD_VAR 0 2
32778: PPUSH
32779: LD_INT 101
32781: PPUSH
32782: CALL 27580 0 2
// continue ;
32786: GO 32589
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
32788: LD_ADDR_EXP 86
32792: PUSH
32793: LD_EXP 86
32797: PPUSH
32798: LD_VAR 0 2
32802: PPUSH
32803: EMPTY
32804: PPUSH
32805: CALL_OW 1
32809: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32810: LD_VAR 0 2
32814: PPUSH
32815: LD_INT 103
32817: PPUSH
32818: CALL 27580 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
32822: LD_ADDR_VAR 0 5
32826: PUSH
32827: LD_EXP 80
32831: PUSH
32832: LD_VAR 0 2
32836: ARRAY
32837: PUSH
32838: LD_EXP 109
32842: PUSH
32843: LD_VAR 0 2
32847: ARRAY
32848: UNION
32849: PPUSH
32850: LD_INT 2
32852: PUSH
32853: LD_INT 25
32855: PUSH
32856: LD_INT 2
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: LD_INT 25
32865: PUSH
32866: LD_INT 16
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: LIST
32877: PUSH
32878: EMPTY
32879: LIST
32880: PPUSH
32881: CALL_OW 72
32885: ST_TO_ADDR
// if mc_need_heal [ i ] then
32886: LD_EXP 83
32890: PUSH
32891: LD_VAR 0 2
32895: ARRAY
32896: IFFALSE 32940
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
32898: LD_ADDR_VAR 0 5
32902: PUSH
32903: LD_VAR 0 5
32907: PUSH
32908: LD_EXP 83
32912: PUSH
32913: LD_VAR 0 2
32917: ARRAY
32918: PUSH
32919: LD_INT 1
32921: ARRAY
32922: PUSH
32923: LD_EXP 83
32927: PUSH
32928: LD_VAR 0 2
32932: ARRAY
32933: PUSH
32934: LD_INT 2
32936: ARRAY
32937: UNION
32938: DIFF
32939: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
32940: LD_ADDR_VAR 0 6
32944: PUSH
32945: LD_EXP 99
32949: PUSH
32950: LD_VAR 0 2
32954: ARRAY
32955: PPUSH
32956: LD_INT 2
32958: PUSH
32959: LD_INT 34
32961: PUSH
32962: LD_INT 13
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: PUSH
32969: LD_INT 34
32971: PUSH
32972: LD_INT 52
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 34
32981: PUSH
32982: LD_INT 88
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: PPUSH
32995: CALL_OW 72
32999: ST_TO_ADDR
// if cranes then
33000: LD_VAR 0 6
33004: IFFALSE 33176
// begin for j in cranes do
33006: LD_ADDR_VAR 0 3
33010: PUSH
33011: LD_VAR 0 6
33015: PUSH
33016: FOR_IN
33017: IFFALSE 33174
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
33019: LD_VAR 0 3
33023: PPUSH
33024: CALL_OW 256
33028: PUSH
33029: LD_INT 1000
33031: EQUAL
33032: IFFALSE 33046
33034: PUSH
33035: LD_VAR 0 3
33039: PPUSH
33040: CALL_OW 314
33044: NOT
33045: AND
33046: IFFALSE 33112
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
33048: LD_ADDR_VAR 0 8
33052: PUSH
33053: LD_EXP 81
33057: PUSH
33058: LD_VAR 0 2
33062: ARRAY
33063: PPUSH
33064: LD_VAR 0 3
33068: PPUSH
33069: CALL_OW 74
33073: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
33074: LD_VAR 0 8
33078: PPUSH
33079: LD_INT 16
33081: PPUSH
33082: CALL 62594 0 2
33086: PUSH
33087: LD_INT 4
33089: ARRAY
33090: PUSH
33091: LD_INT 10
33093: LESS
33094: IFFALSE 33110
// ComRepairBuilding ( j , to_repair ) ;
33096: LD_VAR 0 3
33100: PPUSH
33101: LD_VAR 0 8
33105: PPUSH
33106: CALL_OW 130
// end else
33110: GO 33172
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
33112: LD_VAR 0 3
33116: PPUSH
33117: CALL_OW 256
33121: PUSH
33122: LD_INT 500
33124: LESS
33125: IFFALSE 33150
33127: PUSH
33128: LD_VAR 0 3
33132: PPUSH
33133: LD_EXP 104
33137: PUSH
33138: LD_VAR 0 2
33142: ARRAY
33143: PPUSH
33144: CALL_OW 308
33148: NOT
33149: AND
33150: IFFALSE 33172
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33152: LD_VAR 0 3
33156: PPUSH
33157: LD_EXP 104
33161: PUSH
33162: LD_VAR 0 2
33166: ARRAY
33167: PPUSH
33168: CALL_OW 113
// end ;
33172: GO 33016
33174: POP
33175: POP
// end ; if tmp > 3 then
33176: LD_VAR 0 5
33180: PUSH
33181: LD_INT 3
33183: GREATER
33184: IFFALSE 33204
// tmp := ShrinkArray ( tmp , 4 ) ;
33186: LD_ADDR_VAR 0 5
33190: PUSH
33191: LD_VAR 0 5
33195: PPUSH
33196: LD_INT 4
33198: PPUSH
33199: CALL 92988 0 2
33203: ST_TO_ADDR
// if not tmp then
33204: LD_VAR 0 5
33208: NOT
33209: IFFALSE 33213
// continue ;
33211: GO 32589
// for j in tmp do
33213: LD_ADDR_VAR 0 3
33217: PUSH
33218: LD_VAR 0 5
33222: PUSH
33223: FOR_IN
33224: IFFALSE 33483
// begin if IsInUnit ( j ) then
33226: LD_VAR 0 3
33230: PPUSH
33231: CALL_OW 310
33235: IFFALSE 33246
// ComExitBuilding ( j ) ;
33237: LD_VAR 0 3
33241: PPUSH
33242: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
33246: LD_VAR 0 3
33250: PUSH
33251: LD_EXP 82
33255: PUSH
33256: LD_VAR 0 2
33260: ARRAY
33261: IN
33262: NOT
33263: IFFALSE 33321
// begin SetTag ( j , 101 ) ;
33265: LD_VAR 0 3
33269: PPUSH
33270: LD_INT 101
33272: PPUSH
33273: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
33277: LD_ADDR_EXP 82
33281: PUSH
33282: LD_EXP 82
33286: PPUSH
33287: LD_VAR 0 2
33291: PUSH
33292: LD_EXP 82
33296: PUSH
33297: LD_VAR 0 2
33301: ARRAY
33302: PUSH
33303: LD_INT 1
33305: PLUS
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PPUSH
33311: LD_VAR 0 3
33315: PPUSH
33316: CALL 59615 0 3
33320: ST_TO_ADDR
// end ; wait ( 1 ) ;
33321: LD_INT 1
33323: PPUSH
33324: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
33328: LD_ADDR_VAR 0 7
33332: PUSH
33333: LD_EXP 81
33337: PUSH
33338: LD_VAR 0 2
33342: ARRAY
33343: ST_TO_ADDR
// if mc_scan [ i ] then
33344: LD_EXP 103
33348: PUSH
33349: LD_VAR 0 2
33353: ARRAY
33354: IFFALSE 33416
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
33356: LD_ADDR_VAR 0 7
33360: PUSH
33361: LD_EXP 81
33365: PUSH
33366: LD_VAR 0 2
33370: ARRAY
33371: PPUSH
33372: LD_INT 3
33374: PUSH
33375: LD_INT 30
33377: PUSH
33378: LD_INT 32
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 30
33387: PUSH
33388: LD_INT 33
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 30
33397: PUSH
33398: LD_INT 31
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: LIST
33409: LIST
33410: PPUSH
33411: CALL_OW 72
33415: ST_TO_ADDR
// if not to_repair_tmp then
33416: LD_VAR 0 7
33420: NOT
33421: IFFALSE 33425
// continue ;
33423: GO 33223
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
33425: LD_ADDR_VAR 0 8
33429: PUSH
33430: LD_VAR 0 7
33434: PPUSH
33435: LD_VAR 0 3
33439: PPUSH
33440: CALL_OW 74
33444: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
33445: LD_VAR 0 8
33449: PPUSH
33450: LD_INT 16
33452: PPUSH
33453: CALL 62594 0 2
33457: PUSH
33458: LD_INT 4
33460: ARRAY
33461: PUSH
33462: LD_INT 14
33464: LESS
33465: IFFALSE 33481
// ComRepairBuilding ( j , to_repair ) ;
33467: LD_VAR 0 3
33471: PPUSH
33472: LD_VAR 0 8
33476: PPUSH
33477: CALL_OW 130
// end ;
33481: GO 33223
33483: POP
33484: POP
// end ;
33485: GO 32589
33487: POP
33488: POP
// end ;
33489: LD_VAR 0 1
33493: RET
// export function MC_Heal ; var i , j , tmp ; begin
33494: LD_INT 0
33496: PPUSH
33497: PPUSH
33498: PPUSH
33499: PPUSH
// if not mc_bases then
33500: LD_EXP 80
33504: NOT
33505: IFFALSE 33509
// exit ;
33507: GO 33915
// for i = 1 to mc_bases do
33509: LD_ADDR_VAR 0 2
33513: PUSH
33514: DOUBLE
33515: LD_INT 1
33517: DEC
33518: ST_TO_ADDR
33519: LD_EXP 80
33523: PUSH
33524: FOR_TO
33525: IFFALSE 33913
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
33527: LD_EXP 83
33531: PUSH
33532: LD_VAR 0 2
33536: ARRAY
33537: PUSH
33538: LD_INT 1
33540: ARRAY
33541: NOT
33542: IFFALSE 33561
33544: PUSH
33545: LD_EXP 83
33549: PUSH
33550: LD_VAR 0 2
33554: ARRAY
33555: PUSH
33556: LD_INT 2
33558: ARRAY
33559: NOT
33560: AND
33561: IFFALSE 33599
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
33563: LD_ADDR_EXP 84
33567: PUSH
33568: LD_EXP 84
33572: PPUSH
33573: LD_VAR 0 2
33577: PPUSH
33578: EMPTY
33579: PPUSH
33580: CALL_OW 1
33584: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
33585: LD_VAR 0 2
33589: PPUSH
33590: LD_INT 102
33592: PPUSH
33593: CALL 27580 0 2
// continue ;
33597: GO 33524
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
33599: LD_ADDR_VAR 0 4
33603: PUSH
33604: LD_EXP 80
33608: PUSH
33609: LD_VAR 0 2
33613: ARRAY
33614: PPUSH
33615: LD_INT 25
33617: PUSH
33618: LD_INT 4
33620: PUSH
33621: EMPTY
33622: LIST
33623: LIST
33624: PPUSH
33625: CALL_OW 72
33629: ST_TO_ADDR
// if not tmp then
33630: LD_VAR 0 4
33634: NOT
33635: IFFALSE 33639
// continue ;
33637: GO 33524
// if mc_taming [ i ] then
33639: LD_EXP 111
33643: PUSH
33644: LD_VAR 0 2
33648: ARRAY
33649: IFFALSE 33673
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33651: LD_ADDR_EXP 111
33655: PUSH
33656: LD_EXP 111
33660: PPUSH
33661: LD_VAR 0 2
33665: PPUSH
33666: EMPTY
33667: PPUSH
33668: CALL_OW 1
33672: ST_TO_ADDR
// for j in tmp do
33673: LD_ADDR_VAR 0 3
33677: PUSH
33678: LD_VAR 0 4
33682: PUSH
33683: FOR_IN
33684: IFFALSE 33909
// begin if IsInUnit ( j ) then
33686: LD_VAR 0 3
33690: PPUSH
33691: CALL_OW 310
33695: IFFALSE 33706
// ComExitBuilding ( j ) ;
33697: LD_VAR 0 3
33701: PPUSH
33702: CALL_OW 122
// if not j in mc_healers [ i ] then
33706: LD_VAR 0 3
33710: PUSH
33711: LD_EXP 84
33715: PUSH
33716: LD_VAR 0 2
33720: ARRAY
33721: IN
33722: NOT
33723: IFFALSE 33769
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
33725: LD_ADDR_EXP 84
33729: PUSH
33730: LD_EXP 84
33734: PPUSH
33735: LD_VAR 0 2
33739: PUSH
33740: LD_EXP 84
33744: PUSH
33745: LD_VAR 0 2
33749: ARRAY
33750: PUSH
33751: LD_INT 1
33753: PLUS
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PPUSH
33759: LD_VAR 0 3
33763: PPUSH
33764: CALL 59615 0 3
33768: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
33769: LD_VAR 0 3
33773: PPUSH
33774: CALL_OW 110
33778: PUSH
33779: LD_INT 102
33781: NONEQUAL
33782: IFFALSE 33796
// SetTag ( j , 102 ) ;
33784: LD_VAR 0 3
33788: PPUSH
33789: LD_INT 102
33791: PPUSH
33792: CALL_OW 109
// Wait ( 3 ) ;
33796: LD_INT 3
33798: PPUSH
33799: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
33803: LD_EXP 83
33807: PUSH
33808: LD_VAR 0 2
33812: ARRAY
33813: PUSH
33814: LD_INT 1
33816: ARRAY
33817: IFFALSE 33849
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
33819: LD_VAR 0 3
33823: PPUSH
33824: LD_EXP 83
33828: PUSH
33829: LD_VAR 0 2
33833: ARRAY
33834: PUSH
33835: LD_INT 1
33837: ARRAY
33838: PUSH
33839: LD_INT 1
33841: ARRAY
33842: PPUSH
33843: CALL_OW 128
33847: GO 33907
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
33849: LD_VAR 0 3
33853: PPUSH
33854: CALL_OW 314
33858: NOT
33859: IFFALSE 33877
33861: PUSH
33862: LD_EXP 83
33866: PUSH
33867: LD_VAR 0 2
33871: ARRAY
33872: PUSH
33873: LD_INT 2
33875: ARRAY
33876: AND
33877: IFFALSE 33907
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
33879: LD_VAR 0 3
33883: PPUSH
33884: LD_EXP 83
33888: PUSH
33889: LD_VAR 0 2
33893: ARRAY
33894: PUSH
33895: LD_INT 2
33897: ARRAY
33898: PUSH
33899: LD_INT 1
33901: ARRAY
33902: PPUSH
33903: CALL_OW 128
// end ;
33907: GO 33683
33909: POP
33910: POP
// end ;
33911: GO 33524
33913: POP
33914: POP
// end ;
33915: LD_VAR 0 1
33919: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
33920: LD_INT 0
33922: PPUSH
33923: PPUSH
33924: PPUSH
33925: PPUSH
33926: PPUSH
33927: PPUSH
// if not mc_bases then
33928: LD_EXP 80
33932: NOT
33933: IFFALSE 33937
// exit ;
33935: GO 35108
// for i = 1 to mc_bases do
33937: LD_ADDR_VAR 0 2
33941: PUSH
33942: DOUBLE
33943: LD_INT 1
33945: DEC
33946: ST_TO_ADDR
33947: LD_EXP 80
33951: PUSH
33952: FOR_TO
33953: IFFALSE 35106
// begin if mc_scan [ i ] then
33955: LD_EXP 103
33959: PUSH
33960: LD_VAR 0 2
33964: ARRAY
33965: IFFALSE 33969
// continue ;
33967: GO 33952
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
33969: LD_EXP 85
33973: PUSH
33974: LD_VAR 0 2
33978: ARRAY
33979: NOT
33980: IFFALSE 33995
33982: PUSH
33983: LD_EXP 87
33987: PUSH
33988: LD_VAR 0 2
33992: ARRAY
33993: NOT
33994: AND
33995: IFFALSE 34009
33997: PUSH
33998: LD_EXP 86
34002: PUSH
34003: LD_VAR 0 2
34007: ARRAY
34008: AND
34009: IFFALSE 34047
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
34011: LD_ADDR_EXP 86
34015: PUSH
34016: LD_EXP 86
34020: PPUSH
34021: LD_VAR 0 2
34025: PPUSH
34026: EMPTY
34027: PPUSH
34028: CALL_OW 1
34032: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
34033: LD_VAR 0 2
34037: PPUSH
34038: LD_INT 103
34040: PPUSH
34041: CALL 27580 0 2
// continue ;
34045: GO 33952
// end ; if mc_construct_list [ i ] then
34047: LD_EXP 87
34051: PUSH
34052: LD_VAR 0 2
34056: ARRAY
34057: IFFALSE 34277
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
34059: LD_ADDR_VAR 0 5
34063: PUSH
34064: LD_EXP 80
34068: PUSH
34069: LD_VAR 0 2
34073: ARRAY
34074: PPUSH
34075: LD_INT 25
34077: PUSH
34078: LD_INT 2
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PPUSH
34085: CALL_OW 72
34089: PUSH
34090: LD_EXP 82
34094: PUSH
34095: LD_VAR 0 2
34099: ARRAY
34100: DIFF
34101: ST_TO_ADDR
// if not tmp then
34102: LD_VAR 0 5
34106: NOT
34107: IFFALSE 34111
// continue ;
34109: GO 33952
// for j in tmp do
34111: LD_ADDR_VAR 0 3
34115: PUSH
34116: LD_VAR 0 5
34120: PUSH
34121: FOR_IN
34122: IFFALSE 34273
// begin if not mc_builders [ i ] then
34124: LD_EXP 86
34128: PUSH
34129: LD_VAR 0 2
34133: ARRAY
34134: NOT
34135: IFFALSE 34193
// begin SetTag ( j , 103 ) ;
34137: LD_VAR 0 3
34141: PPUSH
34142: LD_INT 103
34144: PPUSH
34145: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34149: LD_ADDR_EXP 86
34153: PUSH
34154: LD_EXP 86
34158: PPUSH
34159: LD_VAR 0 2
34163: PUSH
34164: LD_EXP 86
34168: PUSH
34169: LD_VAR 0 2
34173: ARRAY
34174: PUSH
34175: LD_INT 1
34177: PLUS
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PPUSH
34183: LD_VAR 0 3
34187: PPUSH
34188: CALL 59615 0 3
34192: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34193: LD_VAR 0 3
34197: PPUSH
34198: CALL_OW 310
34202: IFFALSE 34213
// ComExitBuilding ( j ) ;
34204: LD_VAR 0 3
34208: PPUSH
34209: CALL_OW 122
// wait ( 3 ) ;
34213: LD_INT 3
34215: PPUSH
34216: CALL_OW 67
// if not mc_construct_list [ i ] then
34220: LD_EXP 87
34224: PUSH
34225: LD_VAR 0 2
34229: ARRAY
34230: NOT
34231: IFFALSE 34235
// break ;
34233: GO 34273
// if not HasTask ( j ) then
34235: LD_VAR 0 3
34239: PPUSH
34240: CALL_OW 314
34244: NOT
34245: IFFALSE 34271
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
34247: LD_VAR 0 3
34251: PPUSH
34252: LD_EXP 87
34256: PUSH
34257: LD_VAR 0 2
34261: ARRAY
34262: PUSH
34263: LD_INT 1
34265: ARRAY
34266: PPUSH
34267: CALL 62867 0 2
// end ;
34271: GO 34121
34273: POP
34274: POP
// end else
34275: GO 35104
// if mc_build_list [ i ] then
34277: LD_EXP 85
34281: PUSH
34282: LD_VAR 0 2
34286: ARRAY
34287: IFFALSE 35104
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
34289: LD_EXP 85
34293: PUSH
34294: LD_VAR 0 2
34298: ARRAY
34299: PUSH
34300: LD_INT 1
34302: ARRAY
34303: PUSH
34304: LD_INT 1
34306: ARRAY
34307: PPUSH
34308: CALL 62691 0 1
34312: IFFALSE 34360
34314: PUSH
34315: LD_EXP 80
34319: PUSH
34320: LD_VAR 0 2
34324: ARRAY
34325: PPUSH
34326: LD_INT 2
34328: PUSH
34329: LD_INT 30
34331: PUSH
34332: LD_INT 2
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 30
34341: PUSH
34342: LD_INT 3
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: EMPTY
34350: LIST
34351: LIST
34352: LIST
34353: PPUSH
34354: CALL_OW 72
34358: NOT
34359: AND
34360: IFFALSE 34465
// begin for j = 1 to mc_build_list [ i ] do
34362: LD_ADDR_VAR 0 3
34366: PUSH
34367: DOUBLE
34368: LD_INT 1
34370: DEC
34371: ST_TO_ADDR
34372: LD_EXP 85
34376: PUSH
34377: LD_VAR 0 2
34381: ARRAY
34382: PUSH
34383: FOR_TO
34384: IFFALSE 34463
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
34386: LD_EXP 85
34390: PUSH
34391: LD_VAR 0 2
34395: ARRAY
34396: PUSH
34397: LD_VAR 0 3
34401: ARRAY
34402: PUSH
34403: LD_INT 1
34405: ARRAY
34406: PUSH
34407: LD_INT 2
34409: EQUAL
34410: IFFALSE 34461
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
34412: LD_ADDR_EXP 85
34416: PUSH
34417: LD_EXP 85
34421: PPUSH
34422: LD_VAR 0 2
34426: PPUSH
34427: LD_EXP 85
34431: PUSH
34432: LD_VAR 0 2
34436: ARRAY
34437: PPUSH
34438: LD_VAR 0 3
34442: PPUSH
34443: LD_INT 1
34445: PPUSH
34446: LD_INT 0
34448: PPUSH
34449: CALL 59023 0 4
34453: PPUSH
34454: CALL_OW 1
34458: ST_TO_ADDR
// break ;
34459: GO 34463
// end ;
34461: GO 34383
34463: POP
34464: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34465: LD_ADDR_VAR 0 6
34469: PUSH
34470: LD_EXP 80
34474: PUSH
34475: LD_VAR 0 2
34479: ARRAY
34480: PPUSH
34481: LD_INT 2
34483: PUSH
34484: LD_INT 30
34486: PUSH
34487: LD_INT 0
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 30
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: LIST
34508: PPUSH
34509: CALL_OW 72
34513: ST_TO_ADDR
// for k := 1 to depot do
34514: LD_ADDR_VAR 0 4
34518: PUSH
34519: DOUBLE
34520: LD_INT 1
34522: DEC
34523: ST_TO_ADDR
34524: LD_VAR 0 6
34528: PUSH
34529: FOR_TO
34530: IFFALSE 35102
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
34532: LD_EXP 85
34536: PUSH
34537: LD_VAR 0 2
34541: ARRAY
34542: PUSH
34543: LD_INT 1
34545: ARRAY
34546: PUSH
34547: LD_INT 1
34549: ARRAY
34550: PUSH
34551: LD_INT 0
34553: EQUAL
34554: IFTRUE 34649
34556: PUSH
34557: LD_VAR 0 6
34561: PUSH
34562: LD_VAR 0 4
34566: ARRAY
34567: PPUSH
34568: LD_EXP 85
34572: PUSH
34573: LD_VAR 0 2
34577: ARRAY
34578: PUSH
34579: LD_INT 1
34581: ARRAY
34582: PUSH
34583: LD_INT 1
34585: ARRAY
34586: PPUSH
34587: LD_EXP 85
34591: PUSH
34592: LD_VAR 0 2
34596: ARRAY
34597: PUSH
34598: LD_INT 1
34600: ARRAY
34601: PUSH
34602: LD_INT 2
34604: ARRAY
34605: PPUSH
34606: LD_EXP 85
34610: PUSH
34611: LD_VAR 0 2
34615: ARRAY
34616: PUSH
34617: LD_INT 1
34619: ARRAY
34620: PUSH
34621: LD_INT 3
34623: ARRAY
34624: PPUSH
34625: LD_EXP 85
34629: PUSH
34630: LD_VAR 0 2
34634: ARRAY
34635: PUSH
34636: LD_INT 1
34638: ARRAY
34639: PUSH
34640: LD_INT 4
34642: ARRAY
34643: PPUSH
34644: CALL 68171 0 5
34648: OR
34649: IFFALSE 34930
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
34651: LD_ADDR_VAR 0 5
34655: PUSH
34656: LD_EXP 80
34660: PUSH
34661: LD_VAR 0 2
34665: ARRAY
34666: PPUSH
34667: LD_INT 25
34669: PUSH
34670: LD_INT 2
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PPUSH
34677: CALL_OW 72
34681: PUSH
34682: LD_EXP 82
34686: PUSH
34687: LD_VAR 0 2
34691: ARRAY
34692: DIFF
34693: ST_TO_ADDR
// if not tmp then
34694: LD_VAR 0 5
34698: NOT
34699: IFFALSE 34703
// continue ;
34701: GO 34529
// for j in tmp do
34703: LD_ADDR_VAR 0 3
34707: PUSH
34708: LD_VAR 0 5
34712: PUSH
34713: FOR_IN
34714: IFFALSE 34926
// begin if not mc_builders [ i ] then
34716: LD_EXP 86
34720: PUSH
34721: LD_VAR 0 2
34725: ARRAY
34726: NOT
34727: IFFALSE 34785
// begin SetTag ( j , 103 ) ;
34729: LD_VAR 0 3
34733: PPUSH
34734: LD_INT 103
34736: PPUSH
34737: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34741: LD_ADDR_EXP 86
34745: PUSH
34746: LD_EXP 86
34750: PPUSH
34751: LD_VAR 0 2
34755: PUSH
34756: LD_EXP 86
34760: PUSH
34761: LD_VAR 0 2
34765: ARRAY
34766: PUSH
34767: LD_INT 1
34769: PLUS
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PPUSH
34775: LD_VAR 0 3
34779: PPUSH
34780: CALL 59615 0 3
34784: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34785: LD_VAR 0 3
34789: PPUSH
34790: CALL_OW 310
34794: IFFALSE 34805
// ComExitBuilding ( j ) ;
34796: LD_VAR 0 3
34800: PPUSH
34801: CALL_OW 122
// wait ( 3 ) ;
34805: LD_INT 3
34807: PPUSH
34808: CALL_OW 67
// if not mc_build_list [ i ] then
34812: LD_EXP 85
34816: PUSH
34817: LD_VAR 0 2
34821: ARRAY
34822: NOT
34823: IFFALSE 34827
// break ;
34825: GO 34926
// if not HasTask ( j ) then
34827: LD_VAR 0 3
34831: PPUSH
34832: CALL_OW 314
34836: NOT
34837: IFFALSE 34924
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
34839: LD_VAR 0 3
34843: PPUSH
34844: LD_EXP 85
34848: PUSH
34849: LD_VAR 0 2
34853: ARRAY
34854: PUSH
34855: LD_INT 1
34857: ARRAY
34858: PUSH
34859: LD_INT 1
34861: ARRAY
34862: PPUSH
34863: LD_EXP 85
34867: PUSH
34868: LD_VAR 0 2
34872: ARRAY
34873: PUSH
34874: LD_INT 1
34876: ARRAY
34877: PUSH
34878: LD_INT 2
34880: ARRAY
34881: PPUSH
34882: LD_EXP 85
34886: PUSH
34887: LD_VAR 0 2
34891: ARRAY
34892: PUSH
34893: LD_INT 1
34895: ARRAY
34896: PUSH
34897: LD_INT 3
34899: ARRAY
34900: PPUSH
34901: LD_EXP 85
34905: PUSH
34906: LD_VAR 0 2
34910: ARRAY
34911: PUSH
34912: LD_INT 1
34914: ARRAY
34915: PUSH
34916: LD_INT 4
34918: ARRAY
34919: PPUSH
34920: CALL_OW 145
// end ;
34924: GO 34713
34926: POP
34927: POP
// end else
34928: GO 35100
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
34930: LD_EXP 80
34934: PUSH
34935: LD_VAR 0 2
34939: ARRAY
34940: PPUSH
34941: LD_EXP 85
34945: PUSH
34946: LD_VAR 0 2
34950: ARRAY
34951: PUSH
34952: LD_INT 1
34954: ARRAY
34955: PUSH
34956: LD_INT 1
34958: ARRAY
34959: PPUSH
34960: LD_EXP 85
34964: PUSH
34965: LD_VAR 0 2
34969: ARRAY
34970: PUSH
34971: LD_INT 1
34973: ARRAY
34974: PUSH
34975: LD_INT 2
34977: ARRAY
34978: PPUSH
34979: LD_EXP 85
34983: PUSH
34984: LD_VAR 0 2
34988: ARRAY
34989: PUSH
34990: LD_INT 1
34992: ARRAY
34993: PUSH
34994: LD_INT 3
34996: ARRAY
34997: PPUSH
34998: LD_EXP 85
35002: PUSH
35003: LD_VAR 0 2
35007: ARRAY
35008: PUSH
35009: LD_INT 1
35011: ARRAY
35012: PUSH
35013: LD_INT 4
35015: ARRAY
35016: PPUSH
35017: LD_EXP 80
35021: PUSH
35022: LD_VAR 0 2
35026: ARRAY
35027: PPUSH
35028: LD_INT 21
35030: PUSH
35031: LD_INT 3
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PPUSH
35038: CALL_OW 72
35042: PPUSH
35043: EMPTY
35044: PPUSH
35045: CALL 66907 0 7
35049: NOT
35050: IFFALSE 35100
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
35052: LD_ADDR_EXP 85
35056: PUSH
35057: LD_EXP 85
35061: PPUSH
35062: LD_VAR 0 2
35066: PPUSH
35067: LD_EXP 85
35071: PUSH
35072: LD_VAR 0 2
35076: ARRAY
35077: PPUSH
35078: LD_INT 1
35080: PPUSH
35081: LD_INT 1
35083: NEG
35084: PPUSH
35085: LD_INT 0
35087: PPUSH
35088: CALL 59023 0 4
35092: PPUSH
35093: CALL_OW 1
35097: ST_TO_ADDR
// continue ;
35098: GO 34529
// end ; end ;
35100: GO 34529
35102: POP
35103: POP
// end ; end ;
35104: GO 33952
35106: POP
35107: POP
// end ;
35108: LD_VAR 0 1
35112: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
35113: LD_INT 0
35115: PPUSH
35116: PPUSH
35117: PPUSH
35118: PPUSH
35119: PPUSH
35120: PPUSH
// if not mc_bases then
35121: LD_EXP 80
35125: NOT
35126: IFFALSE 35130
// exit ;
35128: GO 35563
// for i = 1 to mc_bases do
35130: LD_ADDR_VAR 0 2
35134: PUSH
35135: DOUBLE
35136: LD_INT 1
35138: DEC
35139: ST_TO_ADDR
35140: LD_EXP 80
35144: PUSH
35145: FOR_TO
35146: IFFALSE 35561
// begin tmp := mc_build_upgrade [ i ] ;
35148: LD_ADDR_VAR 0 4
35152: PUSH
35153: LD_EXP 112
35157: PUSH
35158: LD_VAR 0 2
35162: ARRAY
35163: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
35164: LD_ADDR_VAR 0 6
35168: PUSH
35169: LD_EXP 113
35173: PUSH
35174: LD_VAR 0 2
35178: ARRAY
35179: PPUSH
35180: LD_INT 2
35182: PUSH
35183: LD_INT 30
35185: PUSH
35186: LD_INT 6
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 30
35195: PUSH
35196: LD_INT 7
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: LIST
35207: PPUSH
35208: CALL_OW 72
35212: ST_TO_ADDR
// if not tmp and not lab then
35213: LD_VAR 0 4
35217: NOT
35218: IFFALSE 35227
35220: PUSH
35221: LD_VAR 0 6
35225: NOT
35226: AND
35227: IFFALSE 35231
// continue ;
35229: GO 35145
// if tmp then
35231: LD_VAR 0 4
35235: IFFALSE 35355
// for j in tmp do
35237: LD_ADDR_VAR 0 3
35241: PUSH
35242: LD_VAR 0 4
35246: PUSH
35247: FOR_IN
35248: IFFALSE 35353
// begin if UpgradeCost ( j ) then
35250: LD_VAR 0 3
35254: PPUSH
35255: CALL 66559 0 1
35259: IFFALSE 35351
// begin ComUpgrade ( j ) ;
35261: LD_VAR 0 3
35265: PPUSH
35266: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
35270: LD_ADDR_EXP 112
35274: PUSH
35275: LD_EXP 112
35279: PPUSH
35280: LD_VAR 0 2
35284: PPUSH
35285: LD_EXP 112
35289: PUSH
35290: LD_VAR 0 2
35294: ARRAY
35295: PUSH
35296: LD_VAR 0 3
35300: DIFF
35301: PPUSH
35302: CALL_OW 1
35306: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
35307: LD_ADDR_EXP 87
35311: PUSH
35312: LD_EXP 87
35316: PPUSH
35317: LD_VAR 0 2
35321: PUSH
35322: LD_EXP 87
35326: PUSH
35327: LD_VAR 0 2
35331: ARRAY
35332: PUSH
35333: LD_INT 1
35335: PLUS
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PPUSH
35341: LD_VAR 0 3
35345: PPUSH
35346: CALL 59615 0 3
35350: ST_TO_ADDR
// end ; end ;
35351: GO 35247
35353: POP
35354: POP
// if not lab or not mc_lab_upgrade [ i ] then
35355: LD_VAR 0 6
35359: NOT
35360: IFTRUE 35375
35362: PUSH
35363: LD_EXP 114
35367: PUSH
35368: LD_VAR 0 2
35372: ARRAY
35373: NOT
35374: OR
35375: IFFALSE 35379
// continue ;
35377: GO 35145
// for j in lab do
35379: LD_ADDR_VAR 0 3
35383: PUSH
35384: LD_VAR 0 6
35388: PUSH
35389: FOR_IN
35390: IFFALSE 35557
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
35392: LD_VAR 0 3
35396: PPUSH
35397: CALL_OW 266
35401: PUSH
35402: LD_INT 6
35404: PUSH
35405: LD_INT 7
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: IN
35412: IFFALSE 35429
35414: PUSH
35415: LD_VAR 0 3
35419: PPUSH
35420: CALL_OW 461
35424: PUSH
35425: LD_INT 1
35427: NONEQUAL
35428: AND
35429: IFFALSE 35555
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
35431: LD_VAR 0 3
35435: PPUSH
35436: LD_EXP 114
35440: PUSH
35441: LD_VAR 0 2
35445: ARRAY
35446: PUSH
35447: LD_INT 1
35449: ARRAY
35450: PPUSH
35451: CALL 66768 0 2
35455: IFFALSE 35555
// begin ComCancel ( j ) ;
35457: LD_VAR 0 3
35461: PPUSH
35462: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
35466: LD_VAR 0 3
35470: PPUSH
35471: LD_EXP 114
35475: PUSH
35476: LD_VAR 0 2
35480: ARRAY
35481: PUSH
35482: LD_INT 1
35484: ARRAY
35485: PPUSH
35486: CALL_OW 207
// if not j in mc_construct_list [ i ] then
35490: LD_VAR 0 3
35494: PUSH
35495: LD_EXP 87
35499: PUSH
35500: LD_VAR 0 2
35504: ARRAY
35505: IN
35506: NOT
35507: IFFALSE 35553
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
35509: LD_ADDR_EXP 87
35513: PUSH
35514: LD_EXP 87
35518: PPUSH
35519: LD_VAR 0 2
35523: PUSH
35524: LD_EXP 87
35528: PUSH
35529: LD_VAR 0 2
35533: ARRAY
35534: PUSH
35535: LD_INT 1
35537: PLUS
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PPUSH
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL 59615 0 3
35552: ST_TO_ADDR
// break ;
35553: GO 35557
// end ; end ; end ;
35555: GO 35389
35557: POP
35558: POP
// end ;
35559: GO 35145
35561: POP
35562: POP
// end ;
35563: LD_VAR 0 1
35567: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
35568: LD_INT 0
35570: PPUSH
35571: PPUSH
35572: PPUSH
35573: PPUSH
35574: PPUSH
35575: PPUSH
35576: PPUSH
35577: PPUSH
35578: PPUSH
// if not mc_bases then
35579: LD_EXP 80
35583: NOT
35584: IFFALSE 35588
// exit ;
35586: GO 35995
// for i = 1 to mc_bases do
35588: LD_ADDR_VAR 0 2
35592: PUSH
35593: DOUBLE
35594: LD_INT 1
35596: DEC
35597: ST_TO_ADDR
35598: LD_EXP 80
35602: PUSH
35603: FOR_TO
35604: IFFALSE 35993
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
35606: LD_EXP 88
35610: PUSH
35611: LD_VAR 0 2
35615: ARRAY
35616: NOT
35617: IFTRUE 35647
35619: PUSH
35620: LD_EXP 80
35624: PUSH
35625: LD_VAR 0 2
35629: ARRAY
35630: PPUSH
35631: LD_INT 30
35633: PUSH
35634: LD_INT 3
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PPUSH
35641: CALL_OW 72
35645: NOT
35646: OR
35647: IFFALSE 35651
// continue ;
35649: GO 35603
// busy := false ;
35651: LD_ADDR_VAR 0 8
35655: PUSH
35656: LD_INT 0
35658: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35659: LD_ADDR_VAR 0 4
35663: PUSH
35664: LD_EXP 80
35668: PUSH
35669: LD_VAR 0 2
35673: ARRAY
35674: PPUSH
35675: LD_INT 30
35677: PUSH
35678: LD_INT 3
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PPUSH
35685: CALL_OW 72
35689: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
35690: LD_ADDR_VAR 0 6
35694: PUSH
35695: LD_EXP 88
35699: PUSH
35700: LD_VAR 0 2
35704: ARRAY
35705: PPUSH
35706: LD_INT 2
35708: PUSH
35709: LD_INT 30
35711: PUSH
35712: LD_INT 32
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: PUSH
35719: LD_INT 30
35721: PUSH
35722: LD_INT 33
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: LIST
35733: PPUSH
35734: CALL_OW 72
35738: ST_TO_ADDR
// if not t then
35739: LD_VAR 0 6
35743: NOT
35744: IFFALSE 35748
// continue ;
35746: GO 35603
// for j in tmp do
35748: LD_ADDR_VAR 0 3
35752: PUSH
35753: LD_VAR 0 4
35757: PUSH
35758: FOR_IN
35759: IFFALSE 35789
// if not BuildingStatus ( j ) = bs_idle then
35761: LD_VAR 0 3
35765: PPUSH
35766: CALL_OW 461
35770: PUSH
35771: LD_INT 2
35773: EQUAL
35774: NOT
35775: IFFALSE 35787
// begin busy := true ;
35777: LD_ADDR_VAR 0 8
35781: PUSH
35782: LD_INT 1
35784: ST_TO_ADDR
// break ;
35785: GO 35789
// end ;
35787: GO 35758
35789: POP
35790: POP
// if busy then
35791: LD_VAR 0 8
35795: IFFALSE 35799
// continue ;
35797: GO 35603
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
35799: LD_ADDR_VAR 0 7
35803: PUSH
35804: LD_VAR 0 6
35808: PPUSH
35809: LD_INT 35
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PPUSH
35819: CALL_OW 72
35823: ST_TO_ADDR
// if tw then
35824: LD_VAR 0 7
35828: IFFALSE 35905
// begin tw := tw [ 1 ] ;
35830: LD_ADDR_VAR 0 7
35834: PUSH
35835: LD_VAR 0 7
35839: PUSH
35840: LD_INT 1
35842: ARRAY
35843: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
35844: LD_ADDR_VAR 0 9
35848: PUSH
35849: LD_VAR 0 7
35853: PPUSH
35854: LD_EXP 105
35858: PUSH
35859: LD_VAR 0 2
35863: ARRAY
35864: PPUSH
35865: CALL 65022 0 2
35869: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
35870: LD_EXP 119
35874: PUSH
35875: LD_VAR 0 2
35879: ARRAY
35880: IFFALSE 35903
// if not weapon in mc_allowed_tower_weapons [ i ] then
35882: LD_VAR 0 9
35886: PUSH
35887: LD_EXP 119
35891: PUSH
35892: LD_VAR 0 2
35896: ARRAY
35897: IN
35898: NOT
35899: IFFALSE 35903
// continue ;
35901: GO 35603
// end else
35903: GO 35968
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
35905: LD_ADDR_VAR 0 5
35909: PUSH
35910: LD_EXP 88
35914: PUSH
35915: LD_VAR 0 2
35919: ARRAY
35920: PPUSH
35921: LD_VAR 0 4
35925: PPUSH
35926: CALL 92217 0 2
35930: ST_TO_ADDR
// if not tmp2 then
35931: LD_VAR 0 5
35935: NOT
35936: IFFALSE 35940
// continue ;
35938: GO 35603
// tw := tmp2 [ 1 ] ;
35940: LD_ADDR_VAR 0 7
35944: PUSH
35945: LD_VAR 0 5
35949: PUSH
35950: LD_INT 1
35952: ARRAY
35953: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
35954: LD_ADDR_VAR 0 9
35958: PUSH
35959: LD_VAR 0 5
35963: PUSH
35964: LD_INT 2
35966: ARRAY
35967: ST_TO_ADDR
// end ; if not weapon then
35968: LD_VAR 0 9
35972: NOT
35973: IFFALSE 35977
// continue ;
35975: GO 35603
// ComPlaceWeapon ( tw , weapon ) ;
35977: LD_VAR 0 7
35981: PPUSH
35982: LD_VAR 0 9
35986: PPUSH
35987: CALL_OW 148
// end ;
35991: GO 35603
35993: POP
35994: POP
// end ;
35995: LD_VAR 0 1
35999: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
36000: LD_INT 0
36002: PPUSH
36003: PPUSH
36004: PPUSH
36005: PPUSH
36006: PPUSH
36007: PPUSH
36008: PPUSH
// if not mc_bases then
36009: LD_EXP 80
36013: NOT
36014: IFFALSE 36018
// exit ;
36016: GO 36805
// for i = 1 to mc_bases do
36018: LD_ADDR_VAR 0 2
36022: PUSH
36023: DOUBLE
36024: LD_INT 1
36026: DEC
36027: ST_TO_ADDR
36028: LD_EXP 80
36032: PUSH
36033: FOR_TO
36034: IFFALSE 36803
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
36036: LD_EXP 93
36040: PUSH
36041: LD_VAR 0 2
36045: ARRAY
36046: NOT
36047: IFTRUE 36073
36049: PUSH
36050: LD_EXP 93
36054: PUSH
36055: LD_VAR 0 2
36059: ARRAY
36060: PUSH
36061: LD_EXP 94
36065: PUSH
36066: LD_VAR 0 2
36070: ARRAY
36071: EQUAL
36072: OR
36073: IFTRUE 36087
36075: PUSH
36076: LD_EXP 103
36080: PUSH
36081: LD_VAR 0 2
36085: ARRAY
36086: OR
36087: IFFALSE 36091
// continue ;
36089: GO 36033
// if mc_miners [ i ] then
36091: LD_EXP 94
36095: PUSH
36096: LD_VAR 0 2
36100: ARRAY
36101: IFFALSE 36488
// begin for j = mc_miners [ i ] downto 1 do
36103: LD_ADDR_VAR 0 3
36107: PUSH
36108: DOUBLE
36109: LD_EXP 94
36113: PUSH
36114: LD_VAR 0 2
36118: ARRAY
36119: INC
36120: ST_TO_ADDR
36121: LD_INT 1
36123: PUSH
36124: FOR_DOWNTO
36125: IFFALSE 36486
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
36127: LD_EXP 94
36131: PUSH
36132: LD_VAR 0 2
36136: ARRAY
36137: PUSH
36138: LD_VAR 0 3
36142: ARRAY
36143: PPUSH
36144: CALL_OW 301
36148: IFTRUE 36177
36150: PUSH
36151: LD_EXP 94
36155: PUSH
36156: LD_VAR 0 2
36160: ARRAY
36161: PUSH
36162: LD_VAR 0 3
36166: ARRAY
36167: PPUSH
36168: CALL_OW 257
36172: PUSH
36173: LD_INT 1
36175: NONEQUAL
36176: OR
36177: IFFALSE 36240
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
36179: LD_ADDR_VAR 0 5
36183: PUSH
36184: LD_EXP 94
36188: PUSH
36189: LD_VAR 0 2
36193: ARRAY
36194: PUSH
36195: LD_EXP 94
36199: PUSH
36200: LD_VAR 0 2
36204: ARRAY
36205: PUSH
36206: LD_VAR 0 3
36210: ARRAY
36211: DIFF
36212: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
36213: LD_ADDR_EXP 94
36217: PUSH
36218: LD_EXP 94
36222: PPUSH
36223: LD_VAR 0 2
36227: PPUSH
36228: LD_VAR 0 5
36232: PPUSH
36233: CALL_OW 1
36237: ST_TO_ADDR
// continue ;
36238: GO 36124
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
36240: LD_EXP 94
36244: PUSH
36245: LD_VAR 0 2
36249: ARRAY
36250: PUSH
36251: LD_VAR 0 3
36255: ARRAY
36256: PPUSH
36257: CALL_OW 257
36261: PUSH
36262: LD_INT 1
36264: EQUAL
36265: IFFALSE 36291
36267: PUSH
36268: LD_EXP 94
36272: PUSH
36273: LD_VAR 0 2
36277: ARRAY
36278: PUSH
36279: LD_VAR 0 3
36283: ARRAY
36284: PPUSH
36285: CALL_OW 459
36289: NOT
36290: AND
36291: IFFALSE 36317
36293: PUSH
36294: LD_EXP 94
36298: PUSH
36299: LD_VAR 0 2
36303: ARRAY
36304: PUSH
36305: LD_VAR 0 3
36309: ARRAY
36310: PPUSH
36311: CALL_OW 314
36315: NOT
36316: AND
36317: IFFALSE 36484
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
36319: LD_EXP 94
36323: PUSH
36324: LD_VAR 0 2
36328: ARRAY
36329: PUSH
36330: LD_VAR 0 3
36334: ARRAY
36335: PPUSH
36336: CALL_OW 310
36340: IFFALSE 36363
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
36342: LD_EXP 94
36346: PUSH
36347: LD_VAR 0 2
36351: ARRAY
36352: PUSH
36353: LD_VAR 0 3
36357: ARRAY
36358: PPUSH
36359: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
36363: LD_EXP 94
36367: PUSH
36368: LD_VAR 0 2
36372: ARRAY
36373: PUSH
36374: LD_VAR 0 3
36378: ARRAY
36379: PPUSH
36380: CALL_OW 314
36384: NOT
36385: IFFALSE 36484
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
36387: LD_ADDR_VAR 0 7
36391: PUSH
36392: LD_VAR 0 3
36396: PUSH
36397: LD_EXP 93
36401: PUSH
36402: LD_VAR 0 2
36406: ARRAY
36407: PPUSH
36408: CALL 56697 0 1
36412: MOD
36413: PUSH
36414: LD_INT 1
36416: PLUS
36417: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
36418: LD_EXP 94
36422: PUSH
36423: LD_VAR 0 2
36427: ARRAY
36428: PUSH
36429: LD_VAR 0 3
36433: ARRAY
36434: PPUSH
36435: LD_EXP 93
36439: PUSH
36440: LD_VAR 0 2
36444: ARRAY
36445: PUSH
36446: LD_VAR 0 7
36450: ARRAY
36451: PUSH
36452: LD_INT 1
36454: ARRAY
36455: PPUSH
36456: LD_EXP 93
36460: PUSH
36461: LD_VAR 0 2
36465: ARRAY
36466: PUSH
36467: LD_VAR 0 7
36471: ARRAY
36472: PUSH
36473: LD_INT 2
36475: ARRAY
36476: PPUSH
36477: LD_INT 0
36479: PPUSH
36480: CALL_OW 193
// end ; end ; end ;
36484: GO 36124
36486: POP
36487: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
36488: LD_ADDR_VAR 0 5
36492: PUSH
36493: LD_EXP 80
36497: PUSH
36498: LD_VAR 0 2
36502: ARRAY
36503: PPUSH
36504: LD_INT 2
36506: PUSH
36507: LD_INT 30
36509: PUSH
36510: LD_INT 4
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 30
36519: PUSH
36520: LD_INT 5
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 30
36529: PUSH
36530: LD_INT 32
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: PPUSH
36543: CALL_OW 72
36547: ST_TO_ADDR
// if not tmp then
36548: LD_VAR 0 5
36552: NOT
36553: IFFALSE 36557
// continue ;
36555: GO 36033
// list := [ ] ;
36557: LD_ADDR_VAR 0 6
36561: PUSH
36562: EMPTY
36563: ST_TO_ADDR
// for j in tmp do
36564: LD_ADDR_VAR 0 3
36568: PUSH
36569: LD_VAR 0 5
36573: PUSH
36574: FOR_IN
36575: IFFALSE 36646
// begin for k in UnitsInside ( j ) do
36577: LD_ADDR_VAR 0 4
36581: PUSH
36582: LD_VAR 0 3
36586: PPUSH
36587: CALL_OW 313
36591: PUSH
36592: FOR_IN
36593: IFFALSE 36642
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
36595: LD_VAR 0 4
36599: PPUSH
36600: CALL_OW 257
36604: PUSH
36605: LD_INT 1
36607: EQUAL
36608: IFFALSE 36622
36610: PUSH
36611: LD_VAR 0 4
36615: PPUSH
36616: CALL_OW 459
36620: NOT
36621: AND
36622: IFFALSE 36640
// list := list ^ k ;
36624: LD_ADDR_VAR 0 6
36628: PUSH
36629: LD_VAR 0 6
36633: PUSH
36634: LD_VAR 0 4
36638: ADD
36639: ST_TO_ADDR
36640: GO 36592
36642: POP
36643: POP
// end ;
36644: GO 36574
36646: POP
36647: POP
// list := list diff mc_miners [ i ] ;
36648: LD_ADDR_VAR 0 6
36652: PUSH
36653: LD_VAR 0 6
36657: PUSH
36658: LD_EXP 94
36662: PUSH
36663: LD_VAR 0 2
36667: ARRAY
36668: DIFF
36669: ST_TO_ADDR
// if not list then
36670: LD_VAR 0 6
36674: NOT
36675: IFFALSE 36679
// continue ;
36677: GO 36033
// k := mc_mines [ i ] - mc_miners [ i ] ;
36679: LD_ADDR_VAR 0 4
36683: PUSH
36684: LD_EXP 93
36688: PUSH
36689: LD_VAR 0 2
36693: ARRAY
36694: PUSH
36695: LD_EXP 94
36699: PUSH
36700: LD_VAR 0 2
36704: ARRAY
36705: MINUS
36706: ST_TO_ADDR
// if k > list then
36707: LD_VAR 0 4
36711: PUSH
36712: LD_VAR 0 6
36716: GREATER
36717: IFFALSE 36729
// k := list ;
36719: LD_ADDR_VAR 0 4
36723: PUSH
36724: LD_VAR 0 6
36728: ST_TO_ADDR
// for j = 1 to k do
36729: LD_ADDR_VAR 0 3
36733: PUSH
36734: DOUBLE
36735: LD_INT 1
36737: DEC
36738: ST_TO_ADDR
36739: LD_VAR 0 4
36743: PUSH
36744: FOR_TO
36745: IFFALSE 36799
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
36747: LD_ADDR_EXP 94
36751: PUSH
36752: LD_EXP 94
36756: PPUSH
36757: LD_VAR 0 2
36761: PUSH
36762: LD_EXP 94
36766: PUSH
36767: LD_VAR 0 2
36771: ARRAY
36772: PUSH
36773: LD_INT 1
36775: PLUS
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PPUSH
36781: LD_VAR 0 6
36785: PUSH
36786: LD_VAR 0 3
36790: ARRAY
36791: PPUSH
36792: CALL 59615 0 3
36796: ST_TO_ADDR
36797: GO 36744
36799: POP
36800: POP
// end ;
36801: GO 36033
36803: POP
36804: POP
// end ;
36805: LD_VAR 0 1
36809: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
36810: LD_INT 0
36812: PPUSH
36813: PPUSH
36814: PPUSH
36815: PPUSH
36816: PPUSH
36817: PPUSH
36818: PPUSH
36819: PPUSH
36820: PPUSH
36821: PPUSH
36822: PPUSH
// if not mc_bases then
36823: LD_EXP 80
36827: NOT
36828: IFFALSE 36832
// exit ;
36830: GO 38679
// for i = 1 to mc_bases do
36832: LD_ADDR_VAR 0 2
36836: PUSH
36837: DOUBLE
36838: LD_INT 1
36840: DEC
36841: ST_TO_ADDR
36842: LD_EXP 80
36846: PUSH
36847: FOR_TO
36848: IFFALSE 38677
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
36850: LD_EXP 80
36854: PUSH
36855: LD_VAR 0 2
36859: ARRAY
36860: NOT
36861: IFTRUE 36875
36863: PUSH
36864: LD_EXP 87
36868: PUSH
36869: LD_VAR 0 2
36873: ARRAY
36874: OR
36875: IFFALSE 36879
// continue ;
36877: GO 36847
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
36879: LD_EXP 96
36883: PUSH
36884: LD_VAR 0 2
36888: ARRAY
36889: NOT
36890: IFFALSE 36904
36892: PUSH
36893: LD_EXP 97
36897: PUSH
36898: LD_VAR 0 2
36902: ARRAY
36903: AND
36904: IFFALSE 36942
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36906: LD_ADDR_EXP 97
36910: PUSH
36911: LD_EXP 97
36915: PPUSH
36916: LD_VAR 0 2
36920: PPUSH
36921: EMPTY
36922: PPUSH
36923: CALL_OW 1
36927: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
36928: LD_VAR 0 2
36932: PPUSH
36933: LD_INT 107
36935: PPUSH
36936: CALL 27580 0 2
// continue ;
36940: GO 36847
// end ; target := [ ] ;
36942: LD_ADDR_VAR 0 7
36946: PUSH
36947: EMPTY
36948: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36949: LD_ADDR_VAR 0 6
36953: PUSH
36954: LD_EXP 80
36958: PUSH
36959: LD_VAR 0 2
36963: ARRAY
36964: PUSH
36965: LD_INT 1
36967: ARRAY
36968: PPUSH
36969: CALL_OW 255
36973: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36974: LD_ADDR_VAR 0 9
36978: PUSH
36979: LD_EXP 80
36983: PUSH
36984: LD_VAR 0 2
36988: ARRAY
36989: PPUSH
36990: LD_INT 2
36992: PUSH
36993: LD_INT 30
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 30
37005: PUSH
37006: LD_INT 1
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: LIST
37017: PPUSH
37018: CALL_OW 72
37022: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
37023: LD_ADDR_VAR 0 3
37027: PUSH
37028: DOUBLE
37029: LD_EXP 96
37033: PUSH
37034: LD_VAR 0 2
37038: ARRAY
37039: INC
37040: ST_TO_ADDR
37041: LD_INT 1
37043: PUSH
37044: FOR_DOWNTO
37045: IFFALSE 37292
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
37047: LD_EXP 96
37051: PUSH
37052: LD_VAR 0 2
37056: ARRAY
37057: PUSH
37058: LD_VAR 0 3
37062: ARRAY
37063: PUSH
37064: LD_INT 2
37066: ARRAY
37067: PPUSH
37068: LD_EXP 96
37072: PUSH
37073: LD_VAR 0 2
37077: ARRAY
37078: PUSH
37079: LD_VAR 0 3
37083: ARRAY
37084: PUSH
37085: LD_INT 3
37087: ARRAY
37088: PPUSH
37089: CALL_OW 488
37093: IFFALSE 37147
37095: PUSH
37096: LD_EXP 96
37100: PUSH
37101: LD_VAR 0 2
37105: ARRAY
37106: PUSH
37107: LD_VAR 0 3
37111: ARRAY
37112: PUSH
37113: LD_INT 2
37115: ARRAY
37116: PPUSH
37117: LD_EXP 96
37121: PUSH
37122: LD_VAR 0 2
37126: ARRAY
37127: PUSH
37128: LD_VAR 0 3
37132: ARRAY
37133: PUSH
37134: LD_INT 3
37136: ARRAY
37137: PPUSH
37138: CALL_OW 284
37142: PUSH
37143: LD_INT 0
37145: EQUAL
37146: AND
37147: IFFALSE 37202
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
37149: LD_ADDR_VAR 0 5
37153: PUSH
37154: LD_EXP 96
37158: PUSH
37159: LD_VAR 0 2
37163: ARRAY
37164: PPUSH
37165: LD_VAR 0 3
37169: PPUSH
37170: CALL_OW 3
37174: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
37175: LD_ADDR_EXP 96
37179: PUSH
37180: LD_EXP 96
37184: PPUSH
37185: LD_VAR 0 2
37189: PPUSH
37190: LD_VAR 0 5
37194: PPUSH
37195: CALL_OW 1
37199: ST_TO_ADDR
// continue ;
37200: GO 37044
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
37202: LD_VAR 0 6
37206: PPUSH
37207: LD_EXP 96
37211: PUSH
37212: LD_VAR 0 2
37216: ARRAY
37217: PUSH
37218: LD_VAR 0 3
37222: ARRAY
37223: PUSH
37224: LD_INT 2
37226: ARRAY
37227: PPUSH
37228: LD_EXP 96
37232: PUSH
37233: LD_VAR 0 2
37237: ARRAY
37238: PUSH
37239: LD_VAR 0 3
37243: ARRAY
37244: PUSH
37245: LD_INT 3
37247: ARRAY
37248: PPUSH
37249: LD_INT 30
37251: PPUSH
37252: CALL 60885 0 4
37256: PUSH
37257: LD_INT 4
37259: ARRAY
37260: PUSH
37261: LD_INT 0
37263: EQUAL
37264: IFFALSE 37290
// begin target := mc_crates [ i ] [ j ] ;
37266: LD_ADDR_VAR 0 7
37270: PUSH
37271: LD_EXP 96
37275: PUSH
37276: LD_VAR 0 2
37280: ARRAY
37281: PUSH
37282: LD_VAR 0 3
37286: ARRAY
37287: ST_TO_ADDR
// break ;
37288: GO 37292
// end ; end ;
37290: GO 37044
37292: POP
37293: POP
// if not target then
37294: LD_VAR 0 7
37298: NOT
37299: IFFALSE 37303
// continue ;
37301: GO 36847
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
37303: LD_ADDR_VAR 0 8
37307: PUSH
37308: LD_EXP 99
37312: PUSH
37313: LD_VAR 0 2
37317: ARRAY
37318: PPUSH
37319: LD_INT 2
37321: PUSH
37322: LD_INT 3
37324: PUSH
37325: LD_INT 58
37327: PUSH
37328: EMPTY
37329: LIST
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 61
37337: PUSH
37338: EMPTY
37339: LIST
37340: PUSH
37341: LD_INT 33
37343: PUSH
37344: LD_INT 5
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 33
37353: PUSH
37354: LD_INT 3
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 2
37370: PUSH
37371: LD_INT 34
37373: PUSH
37374: LD_INT 32
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 34
37383: PUSH
37384: LD_INT 51
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 34
37393: PUSH
37394: LD_INT 12
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PPUSH
37411: CALL_OW 72
37415: ST_TO_ADDR
// if not cargo then
37416: LD_VAR 0 8
37420: NOT
37421: IFFALSE 38135
// begin if mc_crates_collector [ i ] < 5 then
37423: LD_EXP 97
37427: PUSH
37428: LD_VAR 0 2
37432: ARRAY
37433: PUSH
37434: LD_INT 5
37436: LESS
37437: IFFALSE 37807
// begin if mc_ape [ i ] then
37439: LD_EXP 109
37443: PUSH
37444: LD_VAR 0 2
37448: ARRAY
37449: IFFALSE 37496
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
37451: LD_ADDR_VAR 0 5
37455: PUSH
37456: LD_EXP 109
37460: PUSH
37461: LD_VAR 0 2
37465: ARRAY
37466: PPUSH
37467: LD_INT 25
37469: PUSH
37470: LD_INT 16
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PUSH
37477: LD_INT 24
37479: PUSH
37480: LD_INT 750
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PPUSH
37491: CALL_OW 72
37495: ST_TO_ADDR
// if not tmp then
37496: LD_VAR 0 5
37500: NOT
37501: IFFALSE 37548
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
37503: LD_ADDR_VAR 0 5
37507: PUSH
37508: LD_EXP 80
37512: PUSH
37513: LD_VAR 0 2
37517: ARRAY
37518: PPUSH
37519: LD_INT 25
37521: PUSH
37522: LD_INT 2
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 24
37531: PUSH
37532: LD_INT 750
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PPUSH
37543: CALL_OW 72
37547: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
37548: LD_EXP 109
37552: PUSH
37553: LD_VAR 0 2
37557: ARRAY
37558: IFFALSE 37601
37560: PUSH
37561: LD_EXP 80
37565: PUSH
37566: LD_VAR 0 2
37570: ARRAY
37571: PPUSH
37572: LD_INT 25
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 24
37584: PUSH
37585: LD_INT 750
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: PPUSH
37596: CALL_OW 72
37600: AND
37601: IFFALSE 37613
37603: PUSH
37604: LD_VAR 0 5
37608: PUSH
37609: LD_INT 5
37611: LESS
37612: AND
37613: IFFALSE 37695
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
37615: LD_ADDR_VAR 0 3
37619: PUSH
37620: LD_EXP 80
37624: PUSH
37625: LD_VAR 0 2
37629: ARRAY
37630: PPUSH
37631: LD_INT 25
37633: PUSH
37634: LD_INT 2
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 24
37643: PUSH
37644: LD_INT 750
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PPUSH
37655: CALL_OW 72
37659: PUSH
37660: FOR_IN
37661: IFFALSE 37693
// begin tmp := tmp union j ;
37663: LD_ADDR_VAR 0 5
37667: PUSH
37668: LD_VAR 0 5
37672: PUSH
37673: LD_VAR 0 3
37677: UNION
37678: ST_TO_ADDR
// if tmp >= 5 then
37679: LD_VAR 0 5
37683: PUSH
37684: LD_INT 5
37686: GREATEREQUAL
37687: IFFALSE 37691
// break ;
37689: GO 37693
// end ;
37691: GO 37660
37693: POP
37694: POP
// end ; if not tmp then
37695: LD_VAR 0 5
37699: NOT
37700: IFFALSE 37704
// continue ;
37702: GO 36847
// for j in tmp do
37704: LD_ADDR_VAR 0 3
37708: PUSH
37709: LD_VAR 0 5
37713: PUSH
37714: FOR_IN
37715: IFFALSE 37805
// if not GetTag ( j ) then
37717: LD_VAR 0 3
37721: PPUSH
37722: CALL_OW 110
37726: NOT
37727: IFFALSE 37803
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
37729: LD_ADDR_EXP 97
37733: PUSH
37734: LD_EXP 97
37738: PPUSH
37739: LD_VAR 0 2
37743: PUSH
37744: LD_EXP 97
37748: PUSH
37749: LD_VAR 0 2
37753: ARRAY
37754: PUSH
37755: LD_INT 1
37757: PLUS
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PPUSH
37763: LD_VAR 0 3
37767: PPUSH
37768: CALL 59615 0 3
37772: ST_TO_ADDR
// SetTag ( j , 107 ) ;
37773: LD_VAR 0 3
37777: PPUSH
37778: LD_INT 107
37780: PPUSH
37781: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
37785: LD_EXP 97
37789: PUSH
37790: LD_VAR 0 2
37794: ARRAY
37795: PUSH
37796: LD_INT 5
37798: GREATEREQUAL
37799: IFFALSE 37803
// break ;
37801: GO 37805
// end ;
37803: GO 37714
37805: POP
37806: POP
// end ; if mc_crates_collector [ i ] and target then
37807: LD_EXP 97
37811: PUSH
37812: LD_VAR 0 2
37816: ARRAY
37817: IFFALSE 37825
37819: PUSH
37820: LD_VAR 0 7
37824: AND
37825: IFFALSE 38133
// begin if mc_crates_collector [ i ] < target [ 1 ] then
37827: LD_EXP 97
37831: PUSH
37832: LD_VAR 0 2
37836: ARRAY
37837: PUSH
37838: LD_VAR 0 7
37842: PUSH
37843: LD_INT 1
37845: ARRAY
37846: LESS
37847: IFFALSE 37867
// tmp := mc_crates_collector [ i ] else
37849: LD_ADDR_VAR 0 5
37853: PUSH
37854: LD_EXP 97
37858: PUSH
37859: LD_VAR 0 2
37863: ARRAY
37864: ST_TO_ADDR
37865: GO 37881
// tmp := target [ 1 ] ;
37867: LD_ADDR_VAR 0 5
37871: PUSH
37872: LD_VAR 0 7
37876: PUSH
37877: LD_INT 1
37879: ARRAY
37880: ST_TO_ADDR
// k := 0 ;
37881: LD_ADDR_VAR 0 4
37885: PUSH
37886: LD_INT 0
37888: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
37889: LD_ADDR_VAR 0 3
37893: PUSH
37894: LD_EXP 97
37898: PUSH
37899: LD_VAR 0 2
37903: ARRAY
37904: PUSH
37905: FOR_IN
37906: IFFALSE 38131
// begin k := k + 1 ;
37908: LD_ADDR_VAR 0 4
37912: PUSH
37913: LD_VAR 0 4
37917: PUSH
37918: LD_INT 1
37920: PLUS
37921: ST_TO_ADDR
// if k > tmp then
37922: LD_VAR 0 4
37926: PUSH
37927: LD_VAR 0 5
37931: GREATER
37932: IFFALSE 37936
// break ;
37934: GO 38131
// if not GetClass ( j ) in [ 2 , 16 ] then
37936: LD_VAR 0 3
37940: PPUSH
37941: CALL_OW 257
37945: PUSH
37946: LD_INT 2
37948: PUSH
37949: LD_INT 16
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: IN
37956: NOT
37957: IFFALSE 38010
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
37959: LD_ADDR_EXP 97
37963: PUSH
37964: LD_EXP 97
37968: PPUSH
37969: LD_VAR 0 2
37973: PPUSH
37974: LD_EXP 97
37978: PUSH
37979: LD_VAR 0 2
37983: ARRAY
37984: PUSH
37985: LD_VAR 0 3
37989: DIFF
37990: PPUSH
37991: CALL_OW 1
37995: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37996: LD_VAR 0 3
38000: PPUSH
38001: LD_INT 0
38003: PPUSH
38004: CALL_OW 109
// continue ;
38008: GO 37905
// end ; if IsInUnit ( j ) then
38010: LD_VAR 0 3
38014: PPUSH
38015: CALL_OW 310
38019: IFFALSE 38030
// ComExitBuilding ( j ) ;
38021: LD_VAR 0 3
38025: PPUSH
38026: CALL_OW 122
// wait ( 3 ) ;
38030: LD_INT 3
38032: PPUSH
38033: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
38037: LD_VAR 0 3
38041: PPUSH
38042: CALL_OW 314
38046: IFFALSE 38084
38048: PUSH
38049: LD_VAR 0 6
38053: PPUSH
38054: LD_VAR 0 7
38058: PUSH
38059: LD_INT 2
38061: ARRAY
38062: PPUSH
38063: LD_VAR 0 7
38067: PUSH
38068: LD_INT 3
38070: ARRAY
38071: PPUSH
38072: LD_INT 30
38074: PPUSH
38075: CALL 60885 0 4
38079: PUSH
38080: LD_INT 4
38082: ARRAY
38083: AND
38084: IFFALSE 38102
// ComStandNearbyBuilding ( j , depot ) else
38086: LD_VAR 0 3
38090: PPUSH
38091: LD_VAR 0 9
38095: PPUSH
38096: CALL 56157 0 2
38100: GO 38129
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
38102: LD_VAR 0 3
38106: PPUSH
38107: LD_VAR 0 7
38111: PUSH
38112: LD_INT 2
38114: ARRAY
38115: PPUSH
38116: LD_VAR 0 7
38120: PUSH
38121: LD_INT 3
38123: ARRAY
38124: PPUSH
38125: CALL_OW 117
// end ;
38129: GO 37905
38131: POP
38132: POP
// end ; end else
38133: GO 38675
// begin for j in cargo do
38135: LD_ADDR_VAR 0 3
38139: PUSH
38140: LD_VAR 0 8
38144: PUSH
38145: FOR_IN
38146: IFFALSE 38673
// begin if GetTag ( j ) <> 0 then
38148: LD_VAR 0 3
38152: PPUSH
38153: CALL_OW 110
38157: PUSH
38158: LD_INT 0
38160: NONEQUAL
38161: IFFALSE 38165
// continue ;
38163: GO 38145
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
38165: LD_VAR 0 3
38169: PPUSH
38170: CALL_OW 256
38174: PUSH
38175: LD_INT 1000
38177: LESS
38178: IFFALSE 38203
38180: PUSH
38181: LD_VAR 0 3
38185: PPUSH
38186: LD_EXP 104
38190: PUSH
38191: LD_VAR 0 2
38195: ARRAY
38196: PPUSH
38197: CALL_OW 308
38201: NOT
38202: AND
38203: IFFALSE 38225
// ComMoveToArea ( j , mc_parking [ i ] ) ;
38205: LD_VAR 0 3
38209: PPUSH
38210: LD_EXP 104
38214: PUSH
38215: LD_VAR 0 2
38219: ARRAY
38220: PPUSH
38221: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
38225: LD_VAR 0 3
38229: PPUSH
38230: CALL_OW 256
38234: PUSH
38235: LD_INT 1000
38237: LESS
38238: IFFALSE 38262
38240: PUSH
38241: LD_VAR 0 3
38245: PPUSH
38246: LD_EXP 104
38250: PUSH
38251: LD_VAR 0 2
38255: ARRAY
38256: PPUSH
38257: CALL_OW 308
38261: AND
38262: IFFALSE 38266
// continue ;
38264: GO 38145
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
38266: LD_VAR 0 3
38270: PPUSH
38271: CALL_OW 262
38275: PUSH
38276: LD_INT 2
38278: EQUAL
38279: IFFALSE 38296
38281: PUSH
38282: LD_VAR 0 3
38286: PPUSH
38287: CALL_OW 261
38291: PUSH
38292: LD_INT 15
38294: LESS
38295: AND
38296: IFFALSE 38300
// continue ;
38298: GO 38145
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
38300: LD_VAR 0 3
38304: PPUSH
38305: CALL_OW 262
38309: PUSH
38310: LD_INT 1
38312: EQUAL
38313: IFFALSE 38330
38315: PUSH
38316: LD_VAR 0 3
38320: PPUSH
38321: CALL_OW 261
38325: PUSH
38326: LD_INT 10
38328: LESS
38329: AND
38330: IFFALSE 38610
// begin if not depot then
38332: LD_VAR 0 9
38336: NOT
38337: IFFALSE 38341
// continue ;
38339: GO 38145
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
38341: LD_VAR 0 3
38345: PPUSH
38346: LD_VAR 0 9
38350: PPUSH
38351: LD_VAR 0 3
38355: PPUSH
38356: CALL_OW 74
38360: PPUSH
38361: CALL_OW 296
38365: PUSH
38366: LD_INT 6
38368: LESS
38369: IFFALSE 38385
// SetFuel ( j , 100 ) else
38371: LD_VAR 0 3
38375: PPUSH
38376: LD_INT 100
38378: PPUSH
38379: CALL_OW 240
38383: GO 38610
// if GetFuel ( j ) = 0 then
38385: LD_VAR 0 3
38389: PPUSH
38390: CALL_OW 261
38394: PUSH
38395: LD_INT 0
38397: EQUAL
38398: IFFALSE 38610
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
38400: LD_ADDR_EXP 99
38404: PUSH
38405: LD_EXP 99
38409: PPUSH
38410: LD_VAR 0 2
38414: PPUSH
38415: LD_EXP 99
38419: PUSH
38420: LD_VAR 0 2
38424: ARRAY
38425: PUSH
38426: LD_VAR 0 3
38430: DIFF
38431: PPUSH
38432: CALL_OW 1
38436: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
38437: LD_VAR 0 3
38441: PPUSH
38442: CALL_OW 263
38446: PUSH
38447: LD_INT 1
38449: EQUAL
38450: IFFALSE 38466
// ComExitVehicle ( IsInUnit ( j ) ) ;
38452: LD_VAR 0 3
38456: PPUSH
38457: CALL_OW 310
38461: PPUSH
38462: CALL_OW 121
// if GetControl ( j ) = control_remote then
38466: LD_VAR 0 3
38470: PPUSH
38471: CALL_OW 263
38475: PUSH
38476: LD_INT 2
38478: EQUAL
38479: IFFALSE 38490
// ComUnlink ( j ) ;
38481: LD_VAR 0 3
38485: PPUSH
38486: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
38490: LD_ADDR_VAR 0 10
38494: PUSH
38495: LD_VAR 0 2
38499: PPUSH
38500: LD_INT 3
38502: PPUSH
38503: CALL 48404 0 2
38507: ST_TO_ADDR
// if fac then
38508: LD_VAR 0 10
38512: IFFALSE 38608
// begin for k in fac do
38514: LD_ADDR_VAR 0 4
38518: PUSH
38519: LD_VAR 0 10
38523: PUSH
38524: FOR_IN
38525: IFFALSE 38606
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
38527: LD_ADDR_VAR 0 11
38531: PUSH
38532: LD_VAR 0 10
38536: PPUSH
38537: LD_VAR 0 3
38541: PPUSH
38542: CALL_OW 265
38546: PPUSH
38547: LD_VAR 0 3
38551: PPUSH
38552: CALL_OW 262
38556: PPUSH
38557: LD_VAR 0 3
38561: PPUSH
38562: CALL_OW 263
38566: PPUSH
38567: LD_VAR 0 3
38571: PPUSH
38572: CALL_OW 264
38576: PPUSH
38577: CALL 57055 0 5
38581: ST_TO_ADDR
// if components then
38582: LD_VAR 0 11
38586: IFFALSE 38604
// begin MC_InsertProduceList ( i , components ) ;
38588: LD_VAR 0 2
38592: PPUSH
38593: LD_VAR 0 11
38597: PPUSH
38598: CALL 47949 0 2
// break ;
38602: GO 38606
// end ; end ;
38604: GO 38524
38606: POP
38607: POP
// end ; continue ;
38608: GO 38145
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
38610: LD_VAR 0 3
38614: PPUSH
38615: LD_INT 1
38617: PPUSH
38618: CALL_OW 289
38622: PUSH
38623: LD_INT 100
38625: LESS
38626: IFFALSE 38640
38628: PUSH
38629: LD_VAR 0 3
38633: PPUSH
38634: CALL_OW 314
38638: NOT
38639: AND
38640: IFFALSE 38669
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
38642: LD_VAR 0 3
38646: PPUSH
38647: LD_VAR 0 7
38651: PUSH
38652: LD_INT 2
38654: ARRAY
38655: PPUSH
38656: LD_VAR 0 7
38660: PUSH
38661: LD_INT 3
38663: ARRAY
38664: PPUSH
38665: CALL_OW 117
// break ;
38669: GO 38673
// end ;
38671: GO 38145
38673: POP
38674: POP
// end ; end ;
38675: GO 36847
38677: POP
38678: POP
// end ;
38679: LD_VAR 0 1
38683: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
38684: LD_INT 0
38686: PPUSH
38687: PPUSH
38688: PPUSH
38689: PPUSH
// if not mc_bases then
38690: LD_EXP 80
38694: NOT
38695: IFFALSE 38699
// exit ;
38697: GO 38864
// for i = 1 to mc_bases do
38699: LD_ADDR_VAR 0 2
38703: PUSH
38704: DOUBLE
38705: LD_INT 1
38707: DEC
38708: ST_TO_ADDR
38709: LD_EXP 80
38713: PUSH
38714: FOR_TO
38715: IFFALSE 38862
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
38717: LD_ADDR_VAR 0 4
38721: PUSH
38722: LD_EXP 99
38726: PUSH
38727: LD_VAR 0 2
38731: ARRAY
38732: PUSH
38733: LD_EXP 102
38737: PUSH
38738: LD_VAR 0 2
38742: ARRAY
38743: UNION
38744: PPUSH
38745: LD_INT 33
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PPUSH
38755: CALL_OW 72
38759: ST_TO_ADDR
// if tmp then
38760: LD_VAR 0 4
38764: IFFALSE 38860
// for j in tmp do
38766: LD_ADDR_VAR 0 3
38770: PUSH
38771: LD_VAR 0 4
38775: PUSH
38776: FOR_IN
38777: IFFALSE 38858
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
38779: LD_VAR 0 3
38783: PPUSH
38784: CALL_OW 312
38788: NOT
38789: IFFALSE 38806
38791: PUSH
38792: LD_VAR 0 3
38796: PPUSH
38797: CALL_OW 256
38801: PUSH
38802: LD_INT 250
38804: GREATEREQUAL
38805: AND
38806: IFFALSE 38819
// Connect ( j ) else
38808: LD_VAR 0 3
38812: PPUSH
38813: CALL 62975 0 1
38817: GO 38856
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
38819: LD_VAR 0 3
38823: PPUSH
38824: CALL_OW 256
38828: PUSH
38829: LD_INT 250
38831: LESS
38832: IFFALSE 38845
38834: PUSH
38835: LD_VAR 0 3
38839: PPUSH
38840: CALL_OW 312
38844: AND
38845: IFFALSE 38856
// ComUnlink ( j ) ;
38847: LD_VAR 0 3
38851: PPUSH
38852: CALL_OW 136
38856: GO 38776
38858: POP
38859: POP
// end ;
38860: GO 38714
38862: POP
38863: POP
// end ;
38864: LD_VAR 0 1
38868: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
38869: LD_INT 0
38871: PPUSH
38872: PPUSH
38873: PPUSH
38874: PPUSH
38875: PPUSH
// if not mc_bases then
38876: LD_EXP 80
38880: NOT
38881: IFFALSE 38885
// exit ;
38883: GO 39334
// for i = 1 to mc_bases do
38885: LD_ADDR_VAR 0 2
38889: PUSH
38890: DOUBLE
38891: LD_INT 1
38893: DEC
38894: ST_TO_ADDR
38895: LD_EXP 80
38899: PUSH
38900: FOR_TO
38901: IFFALSE 39332
// begin if not mc_produce [ i ] then
38903: LD_EXP 101
38907: PUSH
38908: LD_VAR 0 2
38912: ARRAY
38913: NOT
38914: IFFALSE 38918
// continue ;
38916: GO 38900
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38918: LD_ADDR_VAR 0 5
38922: PUSH
38923: LD_EXP 80
38927: PUSH
38928: LD_VAR 0 2
38932: ARRAY
38933: PPUSH
38934: LD_INT 30
38936: PUSH
38937: LD_INT 3
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PPUSH
38944: CALL_OW 72
38948: ST_TO_ADDR
// if not fac then
38949: LD_VAR 0 5
38953: NOT
38954: IFFALSE 38958
// continue ;
38956: GO 38900
// for j in fac do
38958: LD_ADDR_VAR 0 3
38962: PUSH
38963: LD_VAR 0 5
38967: PUSH
38968: FOR_IN
38969: IFFALSE 39328
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
38971: LD_VAR 0 3
38975: PPUSH
38976: CALL_OW 461
38980: PUSH
38981: LD_INT 2
38983: NONEQUAL
38984: IFTRUE 39004
38986: PUSH
38987: LD_VAR 0 3
38991: PPUSH
38992: LD_INT 15
38994: PPUSH
38995: CALL 62594 0 2
38999: PUSH
39000: LD_INT 4
39002: ARRAY
39003: OR
39004: IFFALSE 39008
// continue ;
39006: GO 38968
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
39008: LD_VAR 0 3
39012: PPUSH
39013: LD_EXP 101
39017: PUSH
39018: LD_VAR 0 2
39022: ARRAY
39023: PUSH
39024: LD_INT 1
39026: ARRAY
39027: PUSH
39028: LD_INT 1
39030: ARRAY
39031: PPUSH
39032: LD_EXP 101
39036: PUSH
39037: LD_VAR 0 2
39041: ARRAY
39042: PUSH
39043: LD_INT 1
39045: ARRAY
39046: PUSH
39047: LD_INT 2
39049: ARRAY
39050: PPUSH
39051: LD_EXP 101
39055: PUSH
39056: LD_VAR 0 2
39060: ARRAY
39061: PUSH
39062: LD_INT 1
39064: ARRAY
39065: PUSH
39066: LD_INT 3
39068: ARRAY
39069: PPUSH
39070: LD_EXP 101
39074: PUSH
39075: LD_VAR 0 2
39079: ARRAY
39080: PUSH
39081: LD_INT 1
39083: ARRAY
39084: PUSH
39085: LD_INT 4
39087: ARRAY
39088: PPUSH
39089: CALL_OW 448
39093: IFFALSE 39188
39095: PUSH
39096: LD_VAR 0 3
39100: PPUSH
39101: LD_EXP 101
39105: PUSH
39106: LD_VAR 0 2
39110: ARRAY
39111: PUSH
39112: LD_INT 1
39114: ARRAY
39115: PUSH
39116: LD_INT 1
39118: ARRAY
39119: PUSH
39120: LD_EXP 101
39124: PUSH
39125: LD_VAR 0 2
39129: ARRAY
39130: PUSH
39131: LD_INT 1
39133: ARRAY
39134: PUSH
39135: LD_INT 2
39137: ARRAY
39138: PUSH
39139: LD_EXP 101
39143: PUSH
39144: LD_VAR 0 2
39148: ARRAY
39149: PUSH
39150: LD_INT 1
39152: ARRAY
39153: PUSH
39154: LD_INT 3
39156: ARRAY
39157: PUSH
39158: LD_EXP 101
39162: PUSH
39163: LD_VAR 0 2
39167: ARRAY
39168: PUSH
39169: LD_INT 1
39171: ARRAY
39172: PUSH
39173: LD_INT 4
39175: ARRAY
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: PPUSH
39183: CALL 66408 0 2
39187: AND
39188: IFFALSE 39326
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
39190: LD_VAR 0 3
39194: PPUSH
39195: LD_EXP 101
39199: PUSH
39200: LD_VAR 0 2
39204: ARRAY
39205: PUSH
39206: LD_INT 1
39208: ARRAY
39209: PUSH
39210: LD_INT 1
39212: ARRAY
39213: PPUSH
39214: LD_EXP 101
39218: PUSH
39219: LD_VAR 0 2
39223: ARRAY
39224: PUSH
39225: LD_INT 1
39227: ARRAY
39228: PUSH
39229: LD_INT 2
39231: ARRAY
39232: PPUSH
39233: LD_EXP 101
39237: PUSH
39238: LD_VAR 0 2
39242: ARRAY
39243: PUSH
39244: LD_INT 1
39246: ARRAY
39247: PUSH
39248: LD_INT 3
39250: ARRAY
39251: PPUSH
39252: LD_EXP 101
39256: PUSH
39257: LD_VAR 0 2
39261: ARRAY
39262: PUSH
39263: LD_INT 1
39265: ARRAY
39266: PUSH
39267: LD_INT 4
39269: ARRAY
39270: PPUSH
39271: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
39275: LD_ADDR_VAR 0 4
39279: PUSH
39280: LD_EXP 101
39284: PUSH
39285: LD_VAR 0 2
39289: ARRAY
39290: PPUSH
39291: LD_INT 1
39293: PPUSH
39294: CALL_OW 3
39298: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
39299: LD_ADDR_EXP 101
39303: PUSH
39304: LD_EXP 101
39308: PPUSH
39309: LD_VAR 0 2
39313: PPUSH
39314: LD_VAR 0 4
39318: PPUSH
39319: CALL_OW 1
39323: ST_TO_ADDR
// break ;
39324: GO 39328
// end ; end ;
39326: GO 38968
39328: POP
39329: POP
// end ;
39330: GO 38900
39332: POP
39333: POP
// end ;
39334: LD_VAR 0 1
39338: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
39339: LD_INT 0
39341: PPUSH
39342: PPUSH
39343: PPUSH
// if not mc_bases then
39344: LD_EXP 80
39348: NOT
39349: IFFALSE 39353
// exit ;
39351: GO 39442
// for i = 1 to mc_bases do
39353: LD_ADDR_VAR 0 2
39357: PUSH
39358: DOUBLE
39359: LD_INT 1
39361: DEC
39362: ST_TO_ADDR
39363: LD_EXP 80
39367: PUSH
39368: FOR_TO
39369: IFFALSE 39440
// begin if mc_attack [ i ] then
39371: LD_EXP 100
39375: PUSH
39376: LD_VAR 0 2
39380: ARRAY
39381: IFFALSE 39438
// begin tmp := mc_attack [ i ] [ 1 ] ;
39383: LD_ADDR_VAR 0 3
39387: PUSH
39388: LD_EXP 100
39392: PUSH
39393: LD_VAR 0 2
39397: ARRAY
39398: PUSH
39399: LD_INT 1
39401: ARRAY
39402: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39403: LD_ADDR_EXP 100
39407: PUSH
39408: LD_EXP 100
39412: PPUSH
39413: LD_VAR 0 2
39417: PPUSH
39418: EMPTY
39419: PPUSH
39420: CALL_OW 1
39424: ST_TO_ADDR
// Attack ( tmp ) ;
39425: LD_VAR 0 3
39429: PPUSH
39430: CALL 120587 0 1
// exit ;
39434: POP
39435: POP
39436: GO 39442
// end ; end ;
39438: GO 39368
39440: POP
39441: POP
// end ;
39442: LD_VAR 0 1
39446: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
39447: LD_INT 0
39449: PPUSH
39450: PPUSH
39451: PPUSH
39452: PPUSH
39453: PPUSH
39454: PPUSH
39455: PPUSH
// if not mc_bases then
39456: LD_EXP 80
39460: NOT
39461: IFFALSE 39465
// exit ;
39463: GO 40342
// for i = 1 to mc_bases do
39465: LD_ADDR_VAR 0 2
39469: PUSH
39470: DOUBLE
39471: LD_INT 1
39473: DEC
39474: ST_TO_ADDR
39475: LD_EXP 80
39479: PUSH
39480: FOR_TO
39481: IFFALSE 40340
// begin if not mc_bases [ i ] then
39483: LD_EXP 80
39487: PUSH
39488: LD_VAR 0 2
39492: ARRAY
39493: NOT
39494: IFFALSE 39498
// continue ;
39496: GO 39480
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
39498: LD_ADDR_VAR 0 7
39502: PUSH
39503: LD_EXP 80
39507: PUSH
39508: LD_VAR 0 2
39512: ARRAY
39513: PUSH
39514: LD_INT 1
39516: ARRAY
39517: PPUSH
39518: CALL 56381 0 1
39522: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
39523: LD_ADDR_EXP 103
39527: PUSH
39528: LD_EXP 103
39532: PPUSH
39533: LD_VAR 0 2
39537: PPUSH
39538: LD_EXP 80
39542: PUSH
39543: LD_VAR 0 2
39547: ARRAY
39548: PUSH
39549: LD_INT 1
39551: ARRAY
39552: PPUSH
39553: CALL_OW 255
39557: PPUSH
39558: LD_EXP 105
39562: PUSH
39563: LD_VAR 0 2
39567: ARRAY
39568: PPUSH
39569: CALL 56346 0 2
39573: PPUSH
39574: CALL_OW 1
39578: ST_TO_ADDR
// if not mc_scan [ i ] then
39579: LD_EXP 103
39583: PUSH
39584: LD_VAR 0 2
39588: ARRAY
39589: NOT
39590: IFFALSE 39774
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
39592: LD_ADDR_EXP 123
39596: PUSH
39597: LD_EXP 123
39601: PPUSH
39602: LD_VAR 0 2
39606: PPUSH
39607: LD_INT 0
39609: PPUSH
39610: CALL_OW 1
39614: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39615: LD_ADDR_VAR 0 4
39619: PUSH
39620: LD_EXP 80
39624: PUSH
39625: LD_VAR 0 2
39629: ARRAY
39630: PPUSH
39631: LD_INT 2
39633: PUSH
39634: LD_INT 25
39636: PUSH
39637: LD_INT 5
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 25
39646: PUSH
39647: LD_INT 8
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 25
39656: PUSH
39657: LD_INT 9
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: LIST
39668: LIST
39669: PPUSH
39670: CALL_OW 72
39674: ST_TO_ADDR
// if not tmp then
39675: LD_VAR 0 4
39679: NOT
39680: IFFALSE 39684
// continue ;
39682: GO 39480
// for j in tmp do
39684: LD_ADDR_VAR 0 3
39688: PUSH
39689: LD_VAR 0 4
39693: PUSH
39694: FOR_IN
39695: IFFALSE 39772
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
39697: LD_VAR 0 3
39701: PPUSH
39702: CALL_OW 310
39706: PPUSH
39707: CALL_OW 266
39711: PUSH
39712: LD_INT 5
39714: EQUAL
39715: IFFALSE 39732
39717: PUSH
39718: LD_VAR 0 3
39722: PPUSH
39723: CALL_OW 257
39727: PUSH
39728: LD_INT 1
39730: EQUAL
39731: AND
39732: IFFALSE 39746
39734: PUSH
39735: LD_VAR 0 3
39739: PPUSH
39740: CALL_OW 459
39744: NOT
39745: AND
39746: IFFALSE 39754
39748: PUSH
39749: LD_VAR 0 7
39753: AND
39754: IFFALSE 39770
// ComChangeProfession ( j , class ) ;
39756: LD_VAR 0 3
39760: PPUSH
39761: LD_VAR 0 7
39765: PPUSH
39766: CALL_OW 123
39770: GO 39694
39772: POP
39773: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
39774: LD_EXP 103
39778: PUSH
39779: LD_VAR 0 2
39783: ARRAY
39784: IFFALSE 39799
39786: PUSH
39787: LD_EXP 123
39791: PUSH
39792: LD_VAR 0 2
39796: ARRAY
39797: NOT
39798: AND
39799: IFFALSE 39814
39801: PUSH
39802: LD_EXP 102
39806: PUSH
39807: LD_VAR 0 2
39811: ARRAY
39812: NOT
39813: AND
39814: IFFALSE 39965
39816: PUSH
39817: LD_EXP 80
39821: PUSH
39822: LD_VAR 0 2
39826: ARRAY
39827: PPUSH
39828: LD_INT 50
39830: PUSH
39831: EMPTY
39832: LIST
39833: PUSH
39834: LD_INT 2
39836: PUSH
39837: LD_INT 30
39839: PUSH
39840: LD_INT 32
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 30
39849: PUSH
39850: LD_INT 33
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 30
39859: PUSH
39860: LD_INT 4
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 30
39869: PUSH
39870: LD_INT 5
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PPUSH
39888: CALL_OW 72
39892: PUSH
39893: LD_INT 4
39895: LESS
39896: IFTRUE 39964
39898: PUSH
39899: LD_EXP 80
39903: PUSH
39904: LD_VAR 0 2
39908: ARRAY
39909: PPUSH
39910: LD_INT 3
39912: PUSH
39913: LD_INT 24
39915: PUSH
39916: LD_INT 1000
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 2
39929: PUSH
39930: LD_INT 30
39932: PUSH
39933: LD_INT 0
39935: PUSH
39936: EMPTY
39937: LIST
39938: LIST
39939: PUSH
39940: LD_INT 30
39942: PUSH
39943: LD_INT 1
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: LIST
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PPUSH
39959: CALL_OW 72
39963: OR
39964: AND
39965: IFFALSE 40218
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39967: LD_ADDR_EXP 123
39971: PUSH
39972: LD_EXP 123
39976: PPUSH
39977: LD_VAR 0 2
39981: PPUSH
39982: LD_INT 1
39984: PPUSH
39985: CALL_OW 1
39989: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39990: LD_ADDR_VAR 0 4
39994: PUSH
39995: LD_EXP 80
39999: PUSH
40000: LD_VAR 0 2
40004: ARRAY
40005: PPUSH
40006: LD_INT 2
40008: PUSH
40009: LD_INT 25
40011: PUSH
40012: LD_INT 1
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: PUSH
40019: LD_INT 25
40021: PUSH
40022: LD_INT 5
40024: PUSH
40025: EMPTY
40026: LIST
40027: LIST
40028: PUSH
40029: LD_INT 25
40031: PUSH
40032: LD_INT 8
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 25
40041: PUSH
40042: LD_INT 9
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: LIST
40055: PPUSH
40056: CALL_OW 72
40060: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
40061: LD_ADDR_VAR 0 4
40065: PUSH
40066: LD_VAR 0 4
40070: PUSH
40071: LD_VAR 0 4
40075: PPUSH
40076: LD_INT 18
40078: PPUSH
40079: CALL 90218 0 2
40083: DIFF
40084: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
40085: LD_VAR 0 4
40089: NOT
40090: IFFALSE 40138
40092: PUSH
40093: LD_EXP 80
40097: PUSH
40098: LD_VAR 0 2
40102: ARRAY
40103: PPUSH
40104: LD_INT 2
40106: PUSH
40107: LD_INT 30
40109: PUSH
40110: LD_INT 4
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 30
40119: PUSH
40120: LD_INT 5
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: LIST
40131: PPUSH
40132: CALL_OW 72
40136: NOT
40137: AND
40138: IFFALSE 40200
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
40140: LD_ADDR_VAR 0 4
40144: PUSH
40145: LD_EXP 80
40149: PUSH
40150: LD_VAR 0 2
40154: ARRAY
40155: PPUSH
40156: LD_INT 2
40158: PUSH
40159: LD_INT 25
40161: PUSH
40162: LD_INT 2
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 25
40171: PUSH
40172: LD_INT 3
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 25
40181: PUSH
40182: LD_INT 4
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: PPUSH
40195: CALL_OW 72
40199: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
40200: LD_VAR 0 2
40204: PPUSH
40205: LD_VAR 0 4
40209: PPUSH
40210: CALL 125356 0 2
// exit ;
40214: POP
40215: POP
40216: GO 40342
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
40218: LD_EXP 103
40222: PUSH
40223: LD_VAR 0 2
40227: ARRAY
40228: IFFALSE 40243
40230: PUSH
40231: LD_EXP 123
40235: PUSH
40236: LD_VAR 0 2
40240: ARRAY
40241: NOT
40242: AND
40243: IFFALSE 40257
40245: PUSH
40246: LD_EXP 102
40250: PUSH
40251: LD_VAR 0 2
40255: ARRAY
40256: AND
40257: IFFALSE 40338
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
40259: LD_ADDR_EXP 123
40263: PUSH
40264: LD_EXP 123
40268: PPUSH
40269: LD_VAR 0 2
40273: PPUSH
40274: LD_INT 1
40276: PPUSH
40277: CALL_OW 1
40281: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
40282: LD_ADDR_VAR 0 4
40286: PUSH
40287: LD_EXP 102
40291: PUSH
40292: LD_VAR 0 2
40296: ARRAY
40297: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
40298: LD_ADDR_EXP 102
40302: PUSH
40303: LD_EXP 102
40307: PPUSH
40308: LD_VAR 0 2
40312: PPUSH
40313: EMPTY
40314: PPUSH
40315: CALL_OW 1
40319: ST_TO_ADDR
// Defend ( i , tmp ) ;
40320: LD_VAR 0 2
40324: PPUSH
40325: LD_VAR 0 4
40329: PPUSH
40330: CALL 125960 0 2
// exit ;
40334: POP
40335: POP
40336: GO 40342
// end ; end ;
40338: GO 39480
40340: POP
40341: POP
// end ;
40342: LD_VAR 0 1
40346: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
40347: LD_INT 0
40349: PPUSH
40350: PPUSH
40351: PPUSH
40352: PPUSH
40353: PPUSH
40354: PPUSH
40355: PPUSH
40356: PPUSH
40357: PPUSH
40358: PPUSH
40359: PPUSH
// if not mc_bases then
40360: LD_EXP 80
40364: NOT
40365: IFFALSE 40369
// exit ;
40367: GO 41482
// for i = 1 to mc_bases do
40369: LD_ADDR_VAR 0 2
40373: PUSH
40374: DOUBLE
40375: LD_INT 1
40377: DEC
40378: ST_TO_ADDR
40379: LD_EXP 80
40383: PUSH
40384: FOR_TO
40385: IFFALSE 41480
// begin tmp := mc_lab [ i ] ;
40387: LD_ADDR_VAR 0 6
40391: PUSH
40392: LD_EXP 113
40396: PUSH
40397: LD_VAR 0 2
40401: ARRAY
40402: ST_TO_ADDR
// if not tmp then
40403: LD_VAR 0 6
40407: NOT
40408: IFFALSE 40412
// continue ;
40410: GO 40384
// idle_lab := 0 ;
40412: LD_ADDR_VAR 0 11
40416: PUSH
40417: LD_INT 0
40419: ST_TO_ADDR
// for j in tmp do
40420: LD_ADDR_VAR 0 3
40424: PUSH
40425: LD_VAR 0 6
40429: PUSH
40430: FOR_IN
40431: IFFALSE 41476
// begin researching := false ;
40433: LD_ADDR_VAR 0 10
40437: PUSH
40438: LD_INT 0
40440: ST_TO_ADDR
// side := GetSide ( j ) ;
40441: LD_ADDR_VAR 0 4
40445: PUSH
40446: LD_VAR 0 3
40450: PPUSH
40451: CALL_OW 255
40455: ST_TO_ADDR
// if not mc_tech [ side ] then
40456: LD_EXP 107
40460: PUSH
40461: LD_VAR 0 4
40465: ARRAY
40466: NOT
40467: IFFALSE 40471
// continue ;
40469: GO 40430
// if BuildingStatus ( j ) = bs_idle then
40471: LD_VAR 0 3
40475: PPUSH
40476: CALL_OW 461
40480: PUSH
40481: LD_INT 2
40483: EQUAL
40484: IFFALSE 40676
// begin if idle_lab and UnitsInside ( j ) < 6 then
40486: LD_VAR 0 11
40490: IFFALSE 40507
40492: PUSH
40493: LD_VAR 0 3
40497: PPUSH
40498: CALL_OW 313
40502: PUSH
40503: LD_INT 6
40505: LESS
40506: AND
40507: IFFALSE 40578
// begin tmp2 := UnitsInside ( idle_lab ) ;
40509: LD_ADDR_VAR 0 9
40513: PUSH
40514: LD_VAR 0 11
40518: PPUSH
40519: CALL_OW 313
40523: ST_TO_ADDR
// if tmp2 then
40524: LD_VAR 0 9
40528: IFFALSE 40570
// for x in tmp2 do
40530: LD_ADDR_VAR 0 7
40534: PUSH
40535: LD_VAR 0 9
40539: PUSH
40540: FOR_IN
40541: IFFALSE 40568
// begin ComExitBuilding ( x ) ;
40543: LD_VAR 0 7
40547: PPUSH
40548: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40552: LD_VAR 0 7
40556: PPUSH
40557: LD_VAR 0 3
40561: PPUSH
40562: CALL_OW 180
// end ;
40566: GO 40540
40568: POP
40569: POP
// idle_lab := 0 ;
40570: LD_ADDR_VAR 0 11
40574: PUSH
40575: LD_INT 0
40577: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
40578: LD_ADDR_VAR 0 5
40582: PUSH
40583: LD_EXP 107
40587: PUSH
40588: LD_VAR 0 4
40592: ARRAY
40593: PUSH
40594: FOR_IN
40595: IFFALSE 40657
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
40597: LD_VAR 0 3
40601: PPUSH
40602: LD_VAR 0 5
40606: PPUSH
40607: CALL_OW 430
40611: IFFALSE 40629
40613: PUSH
40614: LD_VAR 0 4
40618: PPUSH
40619: LD_VAR 0 5
40623: PPUSH
40624: CALL 55441 0 2
40628: AND
40629: IFFALSE 40655
// begin researching := true ;
40631: LD_ADDR_VAR 0 10
40635: PUSH
40636: LD_INT 1
40638: ST_TO_ADDR
// ComResearch ( j , t ) ;
40639: LD_VAR 0 3
40643: PPUSH
40644: LD_VAR 0 5
40648: PPUSH
40649: CALL_OW 124
// break ;
40653: GO 40657
// end ;
40655: GO 40594
40657: POP
40658: POP
// if not researching then
40659: LD_VAR 0 10
40663: NOT
40664: IFFALSE 40676
// idle_lab := j ;
40666: LD_ADDR_VAR 0 11
40670: PUSH
40671: LD_VAR 0 3
40675: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
40676: LD_VAR 0 3
40680: PPUSH
40681: CALL_OW 461
40685: PUSH
40686: LD_INT 10
40688: EQUAL
40689: IFFALSE 41295
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
40691: LD_EXP 109
40695: PUSH
40696: LD_VAR 0 2
40700: ARRAY
40701: NOT
40702: IFFALSE 40717
40704: PUSH
40705: LD_EXP 110
40709: PUSH
40710: LD_VAR 0 2
40714: ARRAY
40715: NOT
40716: AND
40717: IFFALSE 40735
40719: PUSH
40720: LD_EXP 107
40724: PUSH
40725: LD_VAR 0 4
40729: ARRAY
40730: PUSH
40731: LD_INT 1
40733: GREATER
40734: AND
40735: IFFALSE 40866
// begin ComCancel ( j ) ;
40737: LD_VAR 0 3
40741: PPUSH
40742: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
40746: LD_ADDR_EXP 107
40750: PUSH
40751: LD_EXP 107
40755: PPUSH
40756: LD_VAR 0 4
40760: PPUSH
40761: LD_EXP 107
40765: PUSH
40766: LD_VAR 0 4
40770: ARRAY
40771: PPUSH
40772: LD_EXP 107
40776: PUSH
40777: LD_VAR 0 4
40781: ARRAY
40782: PUSH
40783: LD_INT 1
40785: MINUS
40786: PPUSH
40787: LD_EXP 107
40791: PUSH
40792: LD_VAR 0 4
40796: ARRAY
40797: PPUSH
40798: LD_INT 0
40800: PPUSH
40801: CALL 59023 0 4
40805: PPUSH
40806: CALL_OW 1
40810: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
40811: LD_ADDR_EXP 107
40815: PUSH
40816: LD_EXP 107
40820: PPUSH
40821: LD_VAR 0 4
40825: PPUSH
40826: LD_EXP 107
40830: PUSH
40831: LD_VAR 0 4
40835: ARRAY
40836: PPUSH
40837: LD_EXP 107
40841: PUSH
40842: LD_VAR 0 4
40846: ARRAY
40847: PPUSH
40848: LD_INT 1
40850: PPUSH
40851: LD_INT 0
40853: PPUSH
40854: CALL 59023 0 4
40858: PPUSH
40859: CALL_OW 1
40863: ST_TO_ADDR
// continue ;
40864: GO 40430
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
40866: LD_EXP 109
40870: PUSH
40871: LD_VAR 0 2
40875: ARRAY
40876: IFFALSE 40891
40878: PUSH
40879: LD_EXP 110
40883: PUSH
40884: LD_VAR 0 2
40888: ARRAY
40889: NOT
40890: AND
40891: IFFALSE 41018
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
40893: LD_ADDR_EXP 110
40897: PUSH
40898: LD_EXP 110
40902: PPUSH
40903: LD_VAR 0 2
40907: PUSH
40908: LD_EXP 110
40912: PUSH
40913: LD_VAR 0 2
40917: ARRAY
40918: PUSH
40919: LD_INT 1
40921: PLUS
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PPUSH
40927: LD_EXP 109
40931: PUSH
40932: LD_VAR 0 2
40936: ARRAY
40937: PUSH
40938: LD_INT 1
40940: ARRAY
40941: PPUSH
40942: CALL 59615 0 3
40946: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
40947: LD_EXP 109
40951: PUSH
40952: LD_VAR 0 2
40956: ARRAY
40957: PUSH
40958: LD_INT 1
40960: ARRAY
40961: PPUSH
40962: LD_INT 112
40964: PPUSH
40965: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
40969: LD_ADDR_VAR 0 9
40973: PUSH
40974: LD_EXP 109
40978: PUSH
40979: LD_VAR 0 2
40983: ARRAY
40984: PPUSH
40985: LD_INT 1
40987: PPUSH
40988: CALL_OW 3
40992: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
40993: LD_ADDR_EXP 109
40997: PUSH
40998: LD_EXP 109
41002: PPUSH
41003: LD_VAR 0 2
41007: PPUSH
41008: LD_VAR 0 9
41012: PPUSH
41013: CALL_OW 1
41017: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
41018: LD_EXP 109
41022: PUSH
41023: LD_VAR 0 2
41027: ARRAY
41028: IFFALSE 41042
41030: PUSH
41031: LD_EXP 110
41035: PUSH
41036: LD_VAR 0 2
41040: ARRAY
41041: AND
41042: IFFALSE 41066
41044: PUSH
41045: LD_EXP 110
41049: PUSH
41050: LD_VAR 0 2
41054: ARRAY
41055: PUSH
41056: LD_INT 1
41058: ARRAY
41059: PPUSH
41060: CALL_OW 310
41064: NOT
41065: AND
41066: IFFALSE 41083
41068: PUSH
41069: LD_VAR 0 3
41073: PPUSH
41074: CALL_OW 313
41078: PUSH
41079: LD_INT 6
41081: EQUAL
41082: AND
41083: IFFALSE 41139
// begin tmp2 := UnitsInside ( j ) ;
41085: LD_ADDR_VAR 0 9
41089: PUSH
41090: LD_VAR 0 3
41094: PPUSH
41095: CALL_OW 313
41099: ST_TO_ADDR
// if tmp2 = 6 then
41100: LD_VAR 0 9
41104: PUSH
41105: LD_INT 6
41107: EQUAL
41108: IFFALSE 41139
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
41110: LD_VAR 0 9
41114: PUSH
41115: LD_INT 1
41117: ARRAY
41118: PPUSH
41119: LD_INT 112
41121: PPUSH
41122: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
41126: LD_VAR 0 9
41130: PUSH
41131: LD_INT 1
41133: ARRAY
41134: PPUSH
41135: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
41139: LD_EXP 110
41143: PUSH
41144: LD_VAR 0 2
41148: ARRAY
41149: IFFALSE 41173
41151: PUSH
41152: LD_EXP 110
41156: PUSH
41157: LD_VAR 0 2
41161: ARRAY
41162: PUSH
41163: LD_INT 1
41165: ARRAY
41166: PPUSH
41167: CALL_OW 314
41171: NOT
41172: AND
41173: IFFALSE 41197
41175: PUSH
41176: LD_EXP 110
41180: PUSH
41181: LD_VAR 0 2
41185: ARRAY
41186: PUSH
41187: LD_INT 1
41189: ARRAY
41190: PPUSH
41191: CALL_OW 310
41195: NOT
41196: AND
41197: IFFALSE 41223
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
41199: LD_EXP 110
41203: PUSH
41204: LD_VAR 0 2
41208: ARRAY
41209: PUSH
41210: LD_INT 1
41212: ARRAY
41213: PPUSH
41214: LD_VAR 0 3
41218: PPUSH
41219: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
41223: LD_EXP 110
41227: PUSH
41228: LD_VAR 0 2
41232: ARRAY
41233: PUSH
41234: LD_INT 1
41236: ARRAY
41237: PPUSH
41238: CALL_OW 310
41242: IFFALSE 41274
41244: PUSH
41245: LD_EXP 110
41249: PUSH
41250: LD_VAR 0 2
41254: ARRAY
41255: PUSH
41256: LD_INT 1
41258: ARRAY
41259: PPUSH
41260: CALL_OW 310
41264: PPUSH
41265: CALL_OW 461
41269: PUSH
41270: LD_INT 3
41272: NONEQUAL
41273: AND
41274: IFFALSE 41295
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
41276: LD_EXP 110
41280: PUSH
41281: LD_VAR 0 2
41285: ARRAY
41286: PUSH
41287: LD_INT 1
41289: ARRAY
41290: PPUSH
41291: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
41295: LD_VAR 0 3
41299: PPUSH
41300: CALL_OW 461
41304: PUSH
41305: LD_INT 6
41307: EQUAL
41308: IFFALSE 41320
41310: PUSH
41311: LD_VAR 0 6
41315: PUSH
41316: LD_INT 1
41318: GREATER
41319: AND
41320: IFFALSE 41474
// begin sci := [ ] ;
41322: LD_ADDR_VAR 0 8
41326: PUSH
41327: EMPTY
41328: ST_TO_ADDR
// for x in ( tmp diff j ) do
41329: LD_ADDR_VAR 0 7
41333: PUSH
41334: LD_VAR 0 6
41338: PUSH
41339: LD_VAR 0 3
41343: DIFF
41344: PUSH
41345: FOR_IN
41346: IFFALSE 41398
// begin if sci = 6 then
41348: LD_VAR 0 8
41352: PUSH
41353: LD_INT 6
41355: EQUAL
41356: IFFALSE 41360
// break ;
41358: GO 41398
// if BuildingStatus ( x ) = bs_idle then
41360: LD_VAR 0 7
41364: PPUSH
41365: CALL_OW 461
41369: PUSH
41370: LD_INT 2
41372: EQUAL
41373: IFFALSE 41396
// sci := sci ^ UnitsInside ( x ) ;
41375: LD_ADDR_VAR 0 8
41379: PUSH
41380: LD_VAR 0 8
41384: PUSH
41385: LD_VAR 0 7
41389: PPUSH
41390: CALL_OW 313
41394: ADD
41395: ST_TO_ADDR
// end ;
41396: GO 41345
41398: POP
41399: POP
// if not sci then
41400: LD_VAR 0 8
41404: NOT
41405: IFFALSE 41409
// continue ;
41407: GO 40430
// for x in sci do
41409: LD_ADDR_VAR 0 7
41413: PUSH
41414: LD_VAR 0 8
41418: PUSH
41419: FOR_IN
41420: IFFALSE 41472
// if IsInUnit ( x ) and not HasTask ( x ) then
41422: LD_VAR 0 7
41426: PPUSH
41427: CALL_OW 310
41431: IFFALSE 41445
41433: PUSH
41434: LD_VAR 0 7
41438: PPUSH
41439: CALL_OW 314
41443: NOT
41444: AND
41445: IFFALSE 41470
// begin ComExitBuilding ( x ) ;
41447: LD_VAR 0 7
41451: PPUSH
41452: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
41456: LD_VAR 0 7
41460: PPUSH
41461: LD_VAR 0 3
41465: PPUSH
41466: CALL_OW 180
// end ;
41470: GO 41419
41472: POP
41473: POP
// end ; end ;
41474: GO 40430
41476: POP
41477: POP
// end ;
41478: GO 40384
41480: POP
41481: POP
// end ;
41482: LD_VAR 0 1
41486: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
41487: LD_INT 0
41489: PPUSH
41490: PPUSH
// if not mc_bases then
41491: LD_EXP 80
41495: NOT
41496: IFFALSE 41500
// exit ;
41498: GO 41583
// for i = 1 to mc_bases do
41500: LD_ADDR_VAR 0 2
41504: PUSH
41505: DOUBLE
41506: LD_INT 1
41508: DEC
41509: ST_TO_ADDR
41510: LD_EXP 80
41514: PUSH
41515: FOR_TO
41516: IFFALSE 41581
// if mc_mines [ i ] and mc_miners [ i ] then
41518: LD_EXP 93
41522: PUSH
41523: LD_VAR 0 2
41527: ARRAY
41528: IFFALSE 41542
41530: PUSH
41531: LD_EXP 94
41535: PUSH
41536: LD_VAR 0 2
41540: ARRAY
41541: AND
41542: IFFALSE 41579
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
41544: LD_EXP 94
41548: PUSH
41549: LD_VAR 0 2
41553: ARRAY
41554: PUSH
41555: LD_INT 1
41557: ARRAY
41558: PPUSH
41559: CALL_OW 255
41563: PPUSH
41564: LD_EXP 93
41568: PUSH
41569: LD_VAR 0 2
41573: ARRAY
41574: PPUSH
41575: CALL 56534 0 2
41579: GO 41515
41581: POP
41582: POP
// end ;
41583: LD_VAR 0 1
41587: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
41588: LD_INT 0
41590: PPUSH
41591: PPUSH
41592: PPUSH
41593: PPUSH
41594: PPUSH
41595: PPUSH
41596: PPUSH
41597: PPUSH
// if not mc_bases or not mc_parking then
41598: LD_EXP 80
41602: NOT
41603: IFTRUE 41612
41605: PUSH
41606: LD_EXP 104
41610: NOT
41611: OR
41612: IFFALSE 41616
// exit ;
41614: GO 42360
// for i = 1 to mc_bases do
41616: LD_ADDR_VAR 0 2
41620: PUSH
41621: DOUBLE
41622: LD_INT 1
41624: DEC
41625: ST_TO_ADDR
41626: LD_EXP 80
41630: PUSH
41631: FOR_TO
41632: IFFALSE 42358
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
41634: LD_EXP 80
41638: PUSH
41639: LD_VAR 0 2
41643: ARRAY
41644: NOT
41645: IFTRUE 41660
41647: PUSH
41648: LD_EXP 104
41652: PUSH
41653: LD_VAR 0 2
41657: ARRAY
41658: NOT
41659: OR
41660: IFFALSE 41664
// continue ;
41662: GO 41631
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
41664: LD_ADDR_VAR 0 5
41668: PUSH
41669: LD_EXP 80
41673: PUSH
41674: LD_VAR 0 2
41678: ARRAY
41679: PUSH
41680: LD_INT 1
41682: ARRAY
41683: PPUSH
41684: CALL_OW 255
41688: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41689: LD_ADDR_VAR 0 6
41693: PUSH
41694: LD_EXP 80
41698: PUSH
41699: LD_VAR 0 2
41703: ARRAY
41704: PPUSH
41705: LD_INT 30
41707: PUSH
41708: LD_INT 3
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PPUSH
41715: CALL_OW 72
41719: ST_TO_ADDR
// if not fac then
41720: LD_VAR 0 6
41724: NOT
41725: IFFALSE 41776
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41727: LD_ADDR_VAR 0 6
41731: PUSH
41732: LD_EXP 80
41736: PUSH
41737: LD_VAR 0 2
41741: ARRAY
41742: PPUSH
41743: LD_INT 2
41745: PUSH
41746: LD_INT 30
41748: PUSH
41749: LD_INT 0
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: PUSH
41756: LD_INT 30
41758: PUSH
41759: LD_INT 1
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: LIST
41770: PPUSH
41771: CALL_OW 72
41775: ST_TO_ADDR
// if not fac then
41776: LD_VAR 0 6
41780: NOT
41781: IFFALSE 41785
// continue ;
41783: GO 41631
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41785: LD_ADDR_VAR 0 7
41789: PUSH
41790: LD_EXP 104
41794: PUSH
41795: LD_VAR 0 2
41799: ARRAY
41800: PPUSH
41801: LD_INT 22
41803: PUSH
41804: LD_VAR 0 5
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 21
41815: PUSH
41816: LD_INT 2
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: PUSH
41823: LD_INT 3
41825: PUSH
41826: LD_INT 60
41828: PUSH
41829: EMPTY
41830: LIST
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: LD_INT 3
41838: PUSH
41839: LD_INT 24
41841: PUSH
41842: LD_INT 1000
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: LIST
41857: LIST
41858: PPUSH
41859: CALL_OW 70
41863: ST_TO_ADDR
// for j in fac do
41864: LD_ADDR_VAR 0 3
41868: PUSH
41869: LD_VAR 0 6
41873: PUSH
41874: FOR_IN
41875: IFFALSE 41970
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41877: LD_ADDR_VAR 0 7
41881: PUSH
41882: LD_VAR 0 7
41886: PUSH
41887: LD_INT 22
41889: PUSH
41890: LD_VAR 0 5
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 91
41901: PUSH
41902: LD_VAR 0 3
41906: PUSH
41907: LD_INT 15
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 21
41917: PUSH
41918: LD_INT 2
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 3
41927: PUSH
41928: LD_INT 60
41930: PUSH
41931: EMPTY
41932: LIST
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 3
41940: PUSH
41941: LD_INT 24
41943: PUSH
41944: LD_INT 1000
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: PPUSH
41962: CALL_OW 69
41966: UNION
41967: ST_TO_ADDR
41968: GO 41874
41970: POP
41971: POP
// if not vehs then
41972: LD_VAR 0 7
41976: NOT
41977: IFFALSE 42003
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41979: LD_ADDR_EXP 92
41983: PUSH
41984: LD_EXP 92
41988: PPUSH
41989: LD_VAR 0 2
41993: PPUSH
41994: EMPTY
41995: PPUSH
41996: CALL_OW 1
42000: ST_TO_ADDR
// continue ;
42001: GO 41631
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
42003: LD_ADDR_VAR 0 8
42007: PUSH
42008: LD_EXP 80
42012: PUSH
42013: LD_VAR 0 2
42017: ARRAY
42018: PPUSH
42019: LD_INT 30
42021: PUSH
42022: LD_INT 3
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PPUSH
42029: CALL_OW 72
42033: ST_TO_ADDR
// if tmp then
42034: LD_VAR 0 8
42038: IFFALSE 42141
// begin for j in tmp do
42040: LD_ADDR_VAR 0 3
42044: PUSH
42045: LD_VAR 0 8
42049: PUSH
42050: FOR_IN
42051: IFFALSE 42139
// for k in UnitsInside ( j ) do
42053: LD_ADDR_VAR 0 4
42057: PUSH
42058: LD_VAR 0 3
42062: PPUSH
42063: CALL_OW 313
42067: PUSH
42068: FOR_IN
42069: IFFALSE 42135
// if k then
42071: LD_VAR 0 4
42075: IFFALSE 42133
// if not k in mc_repair_vehicle [ i ] then
42077: LD_VAR 0 4
42081: PUSH
42082: LD_EXP 92
42086: PUSH
42087: LD_VAR 0 2
42091: ARRAY
42092: IN
42093: NOT
42094: IFFALSE 42133
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
42096: LD_ADDR_EXP 92
42100: PUSH
42101: LD_EXP 92
42105: PPUSH
42106: LD_VAR 0 2
42110: PPUSH
42111: LD_EXP 92
42115: PUSH
42116: LD_VAR 0 2
42120: ARRAY
42121: PUSH
42122: LD_VAR 0 4
42126: UNION
42127: PPUSH
42128: CALL_OW 1
42132: ST_TO_ADDR
42133: GO 42068
42135: POP
42136: POP
42137: GO 42050
42139: POP
42140: POP
// end ; if not mc_repair_vehicle [ i ] then
42141: LD_EXP 92
42145: PUSH
42146: LD_VAR 0 2
42150: ARRAY
42151: NOT
42152: IFFALSE 42156
// continue ;
42154: GO 41631
// for j in mc_repair_vehicle [ i ] do
42156: LD_ADDR_VAR 0 3
42160: PUSH
42161: LD_EXP 92
42165: PUSH
42166: LD_VAR 0 2
42170: ARRAY
42171: PUSH
42172: FOR_IN
42173: IFFALSE 42354
// begin if GetClass ( j ) <> 3 then
42175: LD_VAR 0 3
42179: PPUSH
42180: CALL_OW 257
42184: PUSH
42185: LD_INT 3
42187: NONEQUAL
42188: IFFALSE 42229
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
42190: LD_ADDR_EXP 92
42194: PUSH
42195: LD_EXP 92
42199: PPUSH
42200: LD_VAR 0 2
42204: PPUSH
42205: LD_EXP 92
42209: PUSH
42210: LD_VAR 0 2
42214: ARRAY
42215: PUSH
42216: LD_VAR 0 3
42220: DIFF
42221: PPUSH
42222: CALL_OW 1
42226: ST_TO_ADDR
// continue ;
42227: GO 42172
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
42229: LD_VAR 0 3
42233: PPUSH
42234: CALL_OW 311
42238: NOT
42239: IFFALSE 42264
42241: PUSH
42242: LD_VAR 0 3
42246: PUSH
42247: LD_EXP 83
42251: PUSH
42252: LD_VAR 0 2
42256: ARRAY
42257: PUSH
42258: LD_INT 1
42260: ARRAY
42261: IN
42262: NOT
42263: AND
42264: IFFALSE 42289
42266: PUSH
42267: LD_VAR 0 3
42271: PUSH
42272: LD_EXP 83
42276: PUSH
42277: LD_VAR 0 2
42281: ARRAY
42282: PUSH
42283: LD_INT 2
42285: ARRAY
42286: IN
42287: NOT
42288: AND
42289: IFFALSE 42352
// begin if IsInUnit ( j ) then
42291: LD_VAR 0 3
42295: PPUSH
42296: CALL_OW 310
42300: IFFALSE 42313
// ComExitBuilding ( j ) else
42302: LD_VAR 0 3
42306: PPUSH
42307: CALL_OW 122
42311: GO 42352
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
42313: LD_VAR 0 3
42317: PPUSH
42318: LD_VAR 0 7
42322: PUSH
42323: LD_INT 1
42325: ARRAY
42326: PPUSH
42327: CALL 94756 0 2
42331: NOT
42332: IFFALSE 42352
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
42334: LD_VAR 0 3
42338: PPUSH
42339: LD_VAR 0 7
42343: PUSH
42344: LD_INT 1
42346: ARRAY
42347: PPUSH
42348: CALL_OW 129
// end ; end ;
42352: GO 42172
42354: POP
42355: POP
// end ;
42356: GO 41631
42358: POP
42359: POP
// end ;
42360: LD_VAR 0 1
42364: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
42365: LD_INT 0
42367: PPUSH
42368: PPUSH
42369: PPUSH
42370: PPUSH
42371: PPUSH
42372: PPUSH
42373: PPUSH
42374: PPUSH
42375: PPUSH
42376: PPUSH
42377: PPUSH
// if not mc_bases then
42378: LD_EXP 80
42382: NOT
42383: IFFALSE 42387
// exit ;
42385: GO 43205
// for i = 1 to mc_bases do
42387: LD_ADDR_VAR 0 2
42391: PUSH
42392: DOUBLE
42393: LD_INT 1
42395: DEC
42396: ST_TO_ADDR
42397: LD_EXP 80
42401: PUSH
42402: FOR_TO
42403: IFFALSE 43203
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
42405: LD_EXP 108
42409: PUSH
42410: LD_VAR 0 2
42414: ARRAY
42415: NOT
42416: IFTRUE 42434
42418: PUSH
42419: LD_EXP 83
42423: PUSH
42424: LD_VAR 0 2
42428: ARRAY
42429: PUSH
42430: LD_INT 1
42432: ARRAY
42433: OR
42434: IFTRUE 42452
42436: PUSH
42437: LD_EXP 83
42441: PUSH
42442: LD_VAR 0 2
42446: ARRAY
42447: PUSH
42448: LD_INT 2
42450: ARRAY
42451: OR
42452: IFTRUE 42475
42454: PUSH
42455: LD_EXP 106
42459: PUSH
42460: LD_VAR 0 2
42464: ARRAY
42465: PPUSH
42466: LD_INT 1
42468: PPUSH
42469: CALL_OW 325
42473: NOT
42474: OR
42475: IFTRUE 42489
42477: PUSH
42478: LD_EXP 103
42482: PUSH
42483: LD_VAR 0 2
42487: ARRAY
42488: OR
42489: IFFALSE 42493
// continue ;
42491: GO 42402
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
42493: LD_ADDR_VAR 0 8
42497: PUSH
42498: LD_EXP 80
42502: PUSH
42503: LD_VAR 0 2
42507: ARRAY
42508: PPUSH
42509: LD_INT 25
42511: PUSH
42512: LD_INT 4
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: PUSH
42519: LD_INT 50
42521: PUSH
42522: EMPTY
42523: LIST
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: LD_INT 60
42530: PUSH
42531: EMPTY
42532: LIST
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: LIST
42542: PPUSH
42543: CALL_OW 72
42547: PUSH
42548: LD_EXP 84
42552: PUSH
42553: LD_VAR 0 2
42557: ARRAY
42558: DIFF
42559: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42560: LD_ADDR_VAR 0 9
42564: PUSH
42565: LD_EXP 80
42569: PUSH
42570: LD_VAR 0 2
42574: ARRAY
42575: PPUSH
42576: LD_INT 2
42578: PUSH
42579: LD_INT 30
42581: PUSH
42582: LD_INT 0
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: LD_INT 30
42591: PUSH
42592: LD_INT 1
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: LIST
42603: PPUSH
42604: CALL_OW 72
42608: ST_TO_ADDR
// if not tmp or not dep then
42609: LD_VAR 0 8
42613: NOT
42614: IFTRUE 42623
42616: PUSH
42617: LD_VAR 0 9
42621: NOT
42622: OR
42623: IFFALSE 42627
// continue ;
42625: GO 42402
// side := GetSide ( tmp [ 1 ] ) ;
42627: LD_ADDR_VAR 0 11
42631: PUSH
42632: LD_VAR 0 8
42636: PUSH
42637: LD_INT 1
42639: ARRAY
42640: PPUSH
42641: CALL_OW 255
42645: ST_TO_ADDR
// dep := dep [ 1 ] ;
42646: LD_ADDR_VAR 0 9
42650: PUSH
42651: LD_VAR 0 9
42655: PUSH
42656: LD_INT 1
42658: ARRAY
42659: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
42660: LD_ADDR_VAR 0 7
42664: PUSH
42665: LD_EXP 108
42669: PUSH
42670: LD_VAR 0 2
42674: ARRAY
42675: PPUSH
42676: LD_INT 22
42678: PUSH
42679: LD_INT 0
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 25
42688: PUSH
42689: LD_INT 12
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PPUSH
42700: CALL_OW 70
42704: PUSH
42705: LD_INT 22
42707: PUSH
42708: LD_INT 0
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 25
42717: PUSH
42718: LD_INT 12
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: LD_INT 91
42727: PUSH
42728: LD_VAR 0 9
42732: PUSH
42733: LD_INT 20
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: LIST
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: LIST
42745: PPUSH
42746: CALL_OW 69
42750: UNION
42751: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
42752: LD_ADDR_VAR 0 10
42756: PUSH
42757: LD_EXP 108
42761: PUSH
42762: LD_VAR 0 2
42766: ARRAY
42767: PPUSH
42768: LD_INT 81
42770: PUSH
42771: LD_VAR 0 11
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PPUSH
42780: CALL_OW 70
42784: ST_TO_ADDR
// if not apes or danger_at_area then
42785: LD_VAR 0 7
42789: NOT
42790: IFTRUE 42798
42792: PUSH
42793: LD_VAR 0 10
42797: OR
42798: IFFALSE 42848
// begin if mc_taming [ i ] then
42800: LD_EXP 111
42804: PUSH
42805: LD_VAR 0 2
42809: ARRAY
42810: IFFALSE 42846
// begin MC_Reset ( i , 121 ) ;
42812: LD_VAR 0 2
42816: PPUSH
42817: LD_INT 121
42819: PPUSH
42820: CALL 27580 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42824: LD_ADDR_EXP 111
42828: PUSH
42829: LD_EXP 111
42833: PPUSH
42834: LD_VAR 0 2
42838: PPUSH
42839: EMPTY
42840: PPUSH
42841: CALL_OW 1
42845: ST_TO_ADDR
// end ; continue ;
42846: GO 42402
// end ; for j in tmp do
42848: LD_ADDR_VAR 0 3
42852: PUSH
42853: LD_VAR 0 8
42857: PUSH
42858: FOR_IN
42859: IFFALSE 43199
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
42861: LD_VAR 0 3
42865: PUSH
42866: LD_EXP 111
42870: PUSH
42871: LD_VAR 0 2
42875: ARRAY
42876: IN
42877: NOT
42878: IFFALSE 42896
42880: PUSH
42881: LD_EXP 111
42885: PUSH
42886: LD_VAR 0 2
42890: ARRAY
42891: PUSH
42892: LD_INT 3
42894: LESS
42895: AND
42896: IFFALSE 42954
// begin SetTag ( j , 121 ) ;
42898: LD_VAR 0 3
42902: PPUSH
42903: LD_INT 121
42905: PPUSH
42906: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
42910: LD_ADDR_EXP 111
42914: PUSH
42915: LD_EXP 111
42919: PPUSH
42920: LD_VAR 0 2
42924: PUSH
42925: LD_EXP 111
42929: PUSH
42930: LD_VAR 0 2
42934: ARRAY
42935: PUSH
42936: LD_INT 1
42938: PLUS
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PPUSH
42944: LD_VAR 0 3
42948: PPUSH
42949: CALL 59615 0 3
42953: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
42954: LD_VAR 0 3
42958: PUSH
42959: LD_EXP 111
42963: PUSH
42964: LD_VAR 0 2
42968: ARRAY
42969: IN
42970: IFFALSE 43197
// begin if GetClass ( j ) <> 4 then
42972: LD_VAR 0 3
42976: PPUSH
42977: CALL_OW 257
42981: PUSH
42982: LD_INT 4
42984: NONEQUAL
42985: IFFALSE 43038
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
42987: LD_ADDR_EXP 111
42991: PUSH
42992: LD_EXP 111
42996: PPUSH
42997: LD_VAR 0 2
43001: PPUSH
43002: LD_EXP 111
43006: PUSH
43007: LD_VAR 0 2
43011: ARRAY
43012: PUSH
43013: LD_VAR 0 3
43017: DIFF
43018: PPUSH
43019: CALL_OW 1
43023: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43024: LD_VAR 0 3
43028: PPUSH
43029: LD_INT 0
43031: PPUSH
43032: CALL_OW 109
// continue ;
43036: GO 42858
// end ; if IsInUnit ( j ) then
43038: LD_VAR 0 3
43042: PPUSH
43043: CALL_OW 310
43047: IFFALSE 43058
// ComExitBuilding ( j ) ;
43049: LD_VAR 0 3
43053: PPUSH
43054: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
43058: LD_ADDR_VAR 0 6
43062: PUSH
43063: LD_VAR 0 7
43067: PPUSH
43068: LD_VAR 0 3
43072: PPUSH
43073: CALL_OW 74
43077: ST_TO_ADDR
// if not ape then
43078: LD_VAR 0 6
43082: NOT
43083: IFFALSE 43087
// break ;
43085: GO 43199
// x := GetX ( ape ) ;
43087: LD_ADDR_VAR 0 4
43091: PUSH
43092: LD_VAR 0 6
43096: PPUSH
43097: CALL_OW 250
43101: ST_TO_ADDR
// y := GetY ( ape ) ;
43102: LD_ADDR_VAR 0 5
43106: PUSH
43107: LD_VAR 0 6
43111: PPUSH
43112: CALL_OW 251
43116: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
43117: LD_VAR 0 4
43121: PPUSH
43122: LD_VAR 0 5
43126: PPUSH
43127: CALL_OW 488
43131: NOT
43132: IFTRUE 43162
43134: PUSH
43135: LD_VAR 0 11
43139: PPUSH
43140: LD_VAR 0 4
43144: PPUSH
43145: LD_VAR 0 5
43149: PPUSH
43150: LD_INT 20
43152: PPUSH
43153: CALL 60885 0 4
43157: PUSH
43158: LD_INT 4
43160: ARRAY
43161: OR
43162: IFFALSE 43166
// break ;
43164: GO 43199
// if not HasTask ( j ) then
43166: LD_VAR 0 3
43170: PPUSH
43171: CALL_OW 314
43175: NOT
43176: IFFALSE 43197
// ComTameXY ( j , x , y ) ;
43178: LD_VAR 0 3
43182: PPUSH
43183: LD_VAR 0 4
43187: PPUSH
43188: LD_VAR 0 5
43192: PPUSH
43193: CALL_OW 131
// end ; end ;
43197: GO 42858
43199: POP
43200: POP
// end ;
43201: GO 42402
43203: POP
43204: POP
// end ;
43205: LD_VAR 0 1
43209: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
43210: LD_INT 0
43212: PPUSH
43213: PPUSH
43214: PPUSH
43215: PPUSH
43216: PPUSH
43217: PPUSH
43218: PPUSH
43219: PPUSH
// if not mc_bases then
43220: LD_EXP 80
43224: NOT
43225: IFFALSE 43229
// exit ;
43227: GO 43861
// for i = 1 to mc_bases do
43229: LD_ADDR_VAR 0 2
43233: PUSH
43234: DOUBLE
43235: LD_INT 1
43237: DEC
43238: ST_TO_ADDR
43239: LD_EXP 80
43243: PUSH
43244: FOR_TO
43245: IFFALSE 43859
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
43247: LD_EXP 109
43251: PUSH
43252: LD_VAR 0 2
43256: ARRAY
43257: NOT
43258: IFTRUE 43288
43260: PUSH
43261: LD_EXP 109
43265: PUSH
43266: LD_VAR 0 2
43270: ARRAY
43271: PPUSH
43272: LD_INT 25
43274: PUSH
43275: LD_INT 12
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PPUSH
43282: CALL_OW 72
43286: NOT
43287: OR
43288: IFFALSE 43292
// continue ;
43290: GO 43244
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
43292: LD_ADDR_VAR 0 5
43296: PUSH
43297: LD_EXP 109
43301: PUSH
43302: LD_VAR 0 2
43306: ARRAY
43307: PUSH
43308: LD_INT 1
43310: ARRAY
43311: PPUSH
43312: CALL_OW 255
43316: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
43317: LD_VAR 0 5
43321: PPUSH
43322: LD_INT 2
43324: PPUSH
43325: CALL_OW 325
43329: IFFALSE 43582
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
43331: LD_ADDR_VAR 0 4
43335: PUSH
43336: LD_EXP 109
43340: PUSH
43341: LD_VAR 0 2
43345: ARRAY
43346: PPUSH
43347: LD_INT 25
43349: PUSH
43350: LD_INT 16
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PPUSH
43357: CALL_OW 72
43361: ST_TO_ADDR
// if tmp < 6 then
43362: LD_VAR 0 4
43366: PUSH
43367: LD_INT 6
43369: LESS
43370: IFFALSE 43582
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43372: LD_ADDR_VAR 0 6
43376: PUSH
43377: LD_EXP 80
43381: PUSH
43382: LD_VAR 0 2
43386: ARRAY
43387: PPUSH
43388: LD_INT 2
43390: PUSH
43391: LD_INT 30
43393: PUSH
43394: LD_INT 0
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 30
43403: PUSH
43404: LD_INT 1
43406: PUSH
43407: EMPTY
43408: LIST
43409: LIST
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: LIST
43415: PPUSH
43416: CALL_OW 72
43420: ST_TO_ADDR
// if depot then
43421: LD_VAR 0 6
43425: IFFALSE 43582
// begin selected := 0 ;
43427: LD_ADDR_VAR 0 7
43431: PUSH
43432: LD_INT 0
43434: ST_TO_ADDR
// for j in depot do
43435: LD_ADDR_VAR 0 3
43439: PUSH
43440: LD_VAR 0 6
43444: PUSH
43445: FOR_IN
43446: IFFALSE 43477
// begin if UnitsInside ( j ) < 6 then
43448: LD_VAR 0 3
43452: PPUSH
43453: CALL_OW 313
43457: PUSH
43458: LD_INT 6
43460: LESS
43461: IFFALSE 43475
// begin selected := j ;
43463: LD_ADDR_VAR 0 7
43467: PUSH
43468: LD_VAR 0 3
43472: ST_TO_ADDR
// break ;
43473: GO 43477
// end ; end ;
43475: GO 43445
43477: POP
43478: POP
// if selected then
43479: LD_VAR 0 7
43483: IFFALSE 43582
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
43485: LD_ADDR_VAR 0 3
43489: PUSH
43490: LD_EXP 109
43494: PUSH
43495: LD_VAR 0 2
43499: ARRAY
43500: PPUSH
43501: LD_INT 25
43503: PUSH
43504: LD_INT 12
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PPUSH
43511: CALL_OW 72
43515: PUSH
43516: FOR_IN
43517: IFFALSE 43580
// if not HasTask ( j ) then
43519: LD_VAR 0 3
43523: PPUSH
43524: CALL_OW 314
43528: NOT
43529: IFFALSE 43578
// begin if not IsInUnit ( j ) then
43531: LD_VAR 0 3
43535: PPUSH
43536: CALL_OW 310
43540: NOT
43541: IFFALSE 43557
// ComEnterUnit ( j , selected ) ;
43543: LD_VAR 0 3
43547: PPUSH
43548: LD_VAR 0 7
43552: PPUSH
43553: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
43557: LD_VAR 0 3
43561: PPUSH
43562: LD_INT 16
43564: PPUSH
43565: CALL_OW 183
// AddComExitBuilding ( j ) ;
43569: LD_VAR 0 3
43573: PPUSH
43574: CALL_OW 182
// end ;
43578: GO 43516
43580: POP
43581: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
43582: LD_VAR 0 5
43586: PPUSH
43587: LD_INT 11
43589: PPUSH
43590: CALL_OW 325
43594: IFFALSE 43857
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
43596: LD_ADDR_VAR 0 4
43600: PUSH
43601: LD_EXP 109
43605: PUSH
43606: LD_VAR 0 2
43610: ARRAY
43611: PPUSH
43612: LD_INT 25
43614: PUSH
43615: LD_INT 16
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PPUSH
43622: CALL_OW 72
43626: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
43627: LD_VAR 0 4
43631: PUSH
43632: LD_INT 6
43634: GREATEREQUAL
43635: IFTRUE 43652
43637: PUSH
43638: LD_VAR 0 5
43642: PPUSH
43643: LD_INT 2
43645: PPUSH
43646: CALL_OW 325
43650: NOT
43651: OR
43652: IFFALSE 43857
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43654: LD_ADDR_VAR 0 8
43658: PUSH
43659: LD_EXP 80
43663: PUSH
43664: LD_VAR 0 2
43668: ARRAY
43669: PPUSH
43670: LD_INT 2
43672: PUSH
43673: LD_INT 30
43675: PUSH
43676: LD_INT 4
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 30
43685: PUSH
43686: LD_INT 5
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: EMPTY
43694: LIST
43695: LIST
43696: LIST
43697: PPUSH
43698: CALL_OW 72
43702: ST_TO_ADDR
// if barracks then
43703: LD_VAR 0 8
43707: IFFALSE 43857
// begin selected := 0 ;
43709: LD_ADDR_VAR 0 7
43713: PUSH
43714: LD_INT 0
43716: ST_TO_ADDR
// for j in barracks do
43717: LD_ADDR_VAR 0 3
43721: PUSH
43722: LD_VAR 0 8
43726: PUSH
43727: FOR_IN
43728: IFFALSE 43759
// begin if UnitsInside ( j ) < 6 then
43730: LD_VAR 0 3
43734: PPUSH
43735: CALL_OW 313
43739: PUSH
43740: LD_INT 6
43742: LESS
43743: IFFALSE 43757
// begin selected := j ;
43745: LD_ADDR_VAR 0 7
43749: PUSH
43750: LD_VAR 0 3
43754: ST_TO_ADDR
// break ;
43755: GO 43759
// end ; end ;
43757: GO 43727
43759: POP
43760: POP
// if selected then
43761: LD_VAR 0 7
43765: IFFALSE 43857
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
43767: LD_ADDR_VAR 0 3
43771: PUSH
43772: LD_EXP 109
43776: PUSH
43777: LD_VAR 0 2
43781: ARRAY
43782: PPUSH
43783: LD_INT 25
43785: PUSH
43786: LD_INT 12
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PPUSH
43793: CALL_OW 72
43797: PUSH
43798: FOR_IN
43799: IFFALSE 43855
// if not IsInUnit ( j ) and not HasTask ( j ) then
43801: LD_VAR 0 3
43805: PPUSH
43806: CALL_OW 310
43810: NOT
43811: IFFALSE 43825
43813: PUSH
43814: LD_VAR 0 3
43818: PPUSH
43819: CALL_OW 314
43823: NOT
43824: AND
43825: IFFALSE 43853
// begin ComEnterUnit ( j , selected ) ;
43827: LD_VAR 0 3
43831: PPUSH
43832: LD_VAR 0 7
43836: PPUSH
43837: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
43841: LD_VAR 0 3
43845: PPUSH
43846: LD_INT 15
43848: PPUSH
43849: CALL_OW 183
// end ;
43853: GO 43798
43855: POP
43856: POP
// end ; end ; end ; end ; end ;
43857: GO 43244
43859: POP
43860: POP
// end ;
43861: LD_VAR 0 1
43865: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
43866: LD_INT 0
43868: PPUSH
43869: PPUSH
43870: PPUSH
43871: PPUSH
// if not mc_bases then
43872: LD_EXP 80
43876: NOT
43877: IFFALSE 43881
// exit ;
43879: GO 44063
// for i = 1 to mc_bases do
43881: LD_ADDR_VAR 0 2
43885: PUSH
43886: DOUBLE
43887: LD_INT 1
43889: DEC
43890: ST_TO_ADDR
43891: LD_EXP 80
43895: PUSH
43896: FOR_TO
43897: IFFALSE 44061
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
43899: LD_ADDR_VAR 0 4
43903: PUSH
43904: LD_EXP 80
43908: PUSH
43909: LD_VAR 0 2
43913: ARRAY
43914: PPUSH
43915: LD_INT 25
43917: PUSH
43918: LD_INT 9
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PPUSH
43925: CALL_OW 72
43929: ST_TO_ADDR
// if not tmp then
43930: LD_VAR 0 4
43934: NOT
43935: IFFALSE 43939
// continue ;
43937: GO 43896
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
43939: LD_EXP 106
43943: PUSH
43944: LD_VAR 0 2
43948: ARRAY
43949: PPUSH
43950: LD_INT 29
43952: PPUSH
43953: CALL_OW 325
43957: NOT
43958: IFFALSE 43981
43960: PUSH
43961: LD_EXP 106
43965: PUSH
43966: LD_VAR 0 2
43970: ARRAY
43971: PPUSH
43972: LD_INT 28
43974: PPUSH
43975: CALL_OW 325
43979: NOT
43980: AND
43981: IFFALSE 43985
// continue ;
43983: GO 43896
// for j in tmp do
43985: LD_ADDR_VAR 0 3
43989: PUSH
43990: LD_VAR 0 4
43994: PUSH
43995: FOR_IN
43996: IFFALSE 44057
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
43998: LD_VAR 0 3
44002: PUSH
44003: LD_EXP 83
44007: PUSH
44008: LD_VAR 0 2
44012: ARRAY
44013: PUSH
44014: LD_INT 1
44016: ARRAY
44017: IN
44018: NOT
44019: IFFALSE 44044
44021: PUSH
44022: LD_VAR 0 3
44026: PUSH
44027: LD_EXP 83
44031: PUSH
44032: LD_VAR 0 2
44036: ARRAY
44037: PUSH
44038: LD_INT 2
44040: ARRAY
44041: IN
44042: NOT
44043: AND
44044: IFFALSE 44055
// ComSpaceTimeShoot ( j ) ;
44046: LD_VAR 0 3
44050: PPUSH
44051: CALL 55532 0 1
44055: GO 43995
44057: POP
44058: POP
// end ;
44059: GO 43896
44061: POP
44062: POP
// end ;
44063: LD_VAR 0 1
44067: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
44068: LD_INT 0
44070: PPUSH
44071: PPUSH
44072: PPUSH
44073: PPUSH
44074: PPUSH
44075: PPUSH
44076: PPUSH
44077: PPUSH
44078: PPUSH
// if not mc_bases then
44079: LD_EXP 80
44083: NOT
44084: IFFALSE 44088
// exit ;
44086: GO 44720
// for i = 1 to mc_bases do
44088: LD_ADDR_VAR 0 2
44092: PUSH
44093: DOUBLE
44094: LD_INT 1
44096: DEC
44097: ST_TO_ADDR
44098: LD_EXP 80
44102: PUSH
44103: FOR_TO
44104: IFFALSE 44718
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
44106: LD_EXP 115
44110: PUSH
44111: LD_VAR 0 2
44115: ARRAY
44116: NOT
44117: IFTRUE 44143
44119: PUSH
44120: LD_INT 38
44122: PPUSH
44123: LD_EXP 106
44127: PUSH
44128: LD_VAR 0 2
44132: ARRAY
44133: PPUSH
44134: CALL_OW 321
44138: PUSH
44139: LD_INT 2
44141: NONEQUAL
44142: OR
44143: IFFALSE 44147
// continue ;
44145: GO 44103
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
44147: LD_ADDR_VAR 0 8
44151: PUSH
44152: LD_EXP 80
44156: PUSH
44157: LD_VAR 0 2
44161: ARRAY
44162: PPUSH
44163: LD_INT 30
44165: PUSH
44166: LD_INT 34
44168: PUSH
44169: EMPTY
44170: LIST
44171: LIST
44172: PPUSH
44173: CALL_OW 72
44177: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
44178: LD_ADDR_VAR 0 9
44182: PUSH
44183: LD_EXP 80
44187: PUSH
44188: LD_VAR 0 2
44192: ARRAY
44193: PPUSH
44194: LD_INT 25
44196: PUSH
44197: LD_INT 4
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PPUSH
44204: CALL_OW 72
44208: PPUSH
44209: LD_INT 0
44211: PPUSH
44212: CALL 90218 0 2
44216: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
44217: LD_VAR 0 9
44221: NOT
44222: IFTRUE 44231
44224: PUSH
44225: LD_VAR 0 8
44229: NOT
44230: OR
44231: IFTRUE 44253
44233: PUSH
44234: LD_EXP 80
44238: PUSH
44239: LD_VAR 0 2
44243: ARRAY
44244: PPUSH
44245: LD_INT 124
44247: PPUSH
44248: CALL 90218 0 2
44252: OR
44253: IFFALSE 44257
// continue ;
44255: GO 44103
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
44257: LD_EXP 116
44261: PUSH
44262: LD_VAR 0 2
44266: ARRAY
44267: PUSH
44268: LD_EXP 115
44272: PUSH
44273: LD_VAR 0 2
44277: ARRAY
44278: LESS
44279: IFFALSE 44299
44281: PUSH
44282: LD_EXP 116
44286: PUSH
44287: LD_VAR 0 2
44291: ARRAY
44292: PUSH
44293: LD_VAR 0 8
44297: LESS
44298: AND
44299: IFFALSE 44716
// begin tmp := sci [ 1 ] ;
44301: LD_ADDR_VAR 0 7
44305: PUSH
44306: LD_VAR 0 9
44310: PUSH
44311: LD_INT 1
44313: ARRAY
44314: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
44315: LD_VAR 0 7
44319: PPUSH
44320: LD_INT 124
44322: PPUSH
44323: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
44327: LD_ADDR_VAR 0 3
44331: PUSH
44332: DOUBLE
44333: LD_EXP 115
44337: PUSH
44338: LD_VAR 0 2
44342: ARRAY
44343: INC
44344: ST_TO_ADDR
44345: LD_EXP 115
44349: PUSH
44350: LD_VAR 0 2
44354: ARRAY
44355: PUSH
44356: FOR_DOWNTO
44357: IFFALSE 44702
// begin if IsInUnit ( tmp ) then
44359: LD_VAR 0 7
44363: PPUSH
44364: CALL_OW 310
44368: IFFALSE 44379
// ComExitBuilding ( tmp ) ;
44370: LD_VAR 0 7
44374: PPUSH
44375: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
44379: LD_INT 35
44381: PPUSH
44382: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
44386: LD_VAR 0 7
44390: PPUSH
44391: CALL_OW 310
44395: NOT
44396: IFFALSE 44410
44398: PUSH
44399: LD_VAR 0 7
44403: PPUSH
44404: CALL_OW 314
44408: NOT
44409: AND
44410: IFFALSE 44379
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
44412: LD_ADDR_VAR 0 6
44416: PUSH
44417: LD_VAR 0 7
44421: PPUSH
44422: CALL_OW 250
44426: PUSH
44427: LD_VAR 0 7
44431: PPUSH
44432: CALL_OW 251
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
44441: LD_INT 35
44443: PPUSH
44444: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
44448: LD_ADDR_VAR 0 4
44452: PUSH
44453: LD_EXP 115
44457: PUSH
44458: LD_VAR 0 2
44462: ARRAY
44463: PUSH
44464: LD_VAR 0 3
44468: ARRAY
44469: PUSH
44470: LD_INT 1
44472: ARRAY
44473: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
44474: LD_ADDR_VAR 0 5
44478: PUSH
44479: LD_EXP 115
44483: PUSH
44484: LD_VAR 0 2
44488: ARRAY
44489: PUSH
44490: LD_VAR 0 3
44494: ARRAY
44495: PUSH
44496: LD_INT 2
44498: ARRAY
44499: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
44500: LD_VAR 0 7
44504: PPUSH
44505: LD_INT 10
44507: PPUSH
44508: CALL 62594 0 2
44512: PUSH
44513: LD_INT 4
44515: ARRAY
44516: IFFALSE 44554
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
44518: LD_VAR 0 7
44522: PPUSH
44523: LD_VAR 0 6
44527: PUSH
44528: LD_INT 1
44530: ARRAY
44531: PPUSH
44532: LD_VAR 0 6
44536: PUSH
44537: LD_INT 2
44539: ARRAY
44540: PPUSH
44541: CALL_OW 111
// wait ( 0 0$10 ) ;
44545: LD_INT 350
44547: PPUSH
44548: CALL_OW 67
// end else
44552: GO 44580
// begin ComMoveXY ( tmp , x , y ) ;
44554: LD_VAR 0 7
44558: PPUSH
44559: LD_VAR 0 4
44563: PPUSH
44564: LD_VAR 0 5
44568: PPUSH
44569: CALL_OW 111
// wait ( 0 0$3 ) ;
44573: LD_INT 105
44575: PPUSH
44576: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
44580: LD_VAR 0 7
44584: PPUSH
44585: LD_VAR 0 4
44589: PPUSH
44590: LD_VAR 0 5
44594: PPUSH
44595: CALL_OW 307
44599: IFFALSE 44441
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
44601: LD_VAR 0 7
44605: PPUSH
44606: LD_VAR 0 4
44610: PPUSH
44611: LD_VAR 0 5
44615: PPUSH
44616: LD_VAR 0 8
44620: PUSH
44621: LD_VAR 0 3
44625: ARRAY
44626: PPUSH
44627: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
44631: LD_INT 35
44633: PPUSH
44634: CALL_OW 67
// until not HasTask ( tmp ) ;
44638: LD_VAR 0 7
44642: PPUSH
44643: CALL_OW 314
44647: NOT
44648: IFFALSE 44631
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
44650: LD_ADDR_EXP 116
44654: PUSH
44655: LD_EXP 116
44659: PPUSH
44660: LD_VAR 0 2
44664: PUSH
44665: LD_EXP 116
44669: PUSH
44670: LD_VAR 0 2
44674: ARRAY
44675: PUSH
44676: LD_INT 1
44678: PLUS
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PPUSH
44684: LD_VAR 0 8
44688: PUSH
44689: LD_VAR 0 3
44693: ARRAY
44694: PPUSH
44695: CALL 59615 0 3
44699: ST_TO_ADDR
// end ;
44700: GO 44356
44702: POP
44703: POP
// MC_Reset ( i , 124 ) ;
44704: LD_VAR 0 2
44708: PPUSH
44709: LD_INT 124
44711: PPUSH
44712: CALL 27580 0 2
// end ; end ;
44716: GO 44103
44718: POP
44719: POP
// end ;
44720: LD_VAR 0 1
44724: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
44725: LD_INT 0
44727: PPUSH
44728: PPUSH
44729: PPUSH
// if not mc_bases then
44730: LD_EXP 80
44734: NOT
44735: IFFALSE 44739
// exit ;
44737: GO 45353
// for i = 1 to mc_bases do
44739: LD_ADDR_VAR 0 2
44743: PUSH
44744: DOUBLE
44745: LD_INT 1
44747: DEC
44748: ST_TO_ADDR
44749: LD_EXP 80
44753: PUSH
44754: FOR_TO
44755: IFFALSE 45351
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44757: LD_ADDR_VAR 0 3
44761: PUSH
44762: LD_EXP 80
44766: PUSH
44767: LD_VAR 0 2
44771: ARRAY
44772: PPUSH
44773: LD_INT 25
44775: PUSH
44776: LD_INT 4
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PPUSH
44783: CALL_OW 72
44787: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44788: LD_VAR 0 3
44792: NOT
44793: IFTRUE 44808
44795: PUSH
44796: LD_EXP 117
44800: PUSH
44801: LD_VAR 0 2
44805: ARRAY
44806: NOT
44807: OR
44808: IFTRUE 44856
44810: PUSH
44811: LD_EXP 80
44815: PUSH
44816: LD_VAR 0 2
44820: ARRAY
44821: PPUSH
44822: LD_INT 2
44824: PUSH
44825: LD_INT 30
44827: PUSH
44828: LD_INT 0
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 30
44837: PUSH
44838: LD_INT 1
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: LIST
44849: PPUSH
44850: CALL_OW 72
44854: NOT
44855: OR
44856: IFFALSE 44906
// begin if mc_deposits_finder [ i ] then
44858: LD_EXP 118
44862: PUSH
44863: LD_VAR 0 2
44867: ARRAY
44868: IFFALSE 44904
// begin MC_Reset ( i , 125 ) ;
44870: LD_VAR 0 2
44874: PPUSH
44875: LD_INT 125
44877: PPUSH
44878: CALL 27580 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44882: LD_ADDR_EXP 118
44886: PUSH
44887: LD_EXP 118
44891: PPUSH
44892: LD_VAR 0 2
44896: PPUSH
44897: EMPTY
44898: PPUSH
44899: CALL_OW 1
44903: ST_TO_ADDR
// end ; continue ;
44904: GO 44754
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
44906: LD_EXP 117
44910: PUSH
44911: LD_VAR 0 2
44915: ARRAY
44916: PUSH
44917: LD_INT 1
44919: ARRAY
44920: PUSH
44921: LD_INT 3
44923: ARRAY
44924: PUSH
44925: LD_INT 1
44927: EQUAL
44928: IFFALSE 44954
44930: PUSH
44931: LD_INT 20
44933: PPUSH
44934: LD_EXP 106
44938: PUSH
44939: LD_VAR 0 2
44943: ARRAY
44944: PPUSH
44945: CALL_OW 321
44949: PUSH
44950: LD_INT 2
44952: NONEQUAL
44953: AND
44954: IFFALSE 45004
// begin if mc_deposits_finder [ i ] then
44956: LD_EXP 118
44960: PUSH
44961: LD_VAR 0 2
44965: ARRAY
44966: IFFALSE 45002
// begin MC_Reset ( i , 125 ) ;
44968: LD_VAR 0 2
44972: PPUSH
44973: LD_INT 125
44975: PPUSH
44976: CALL 27580 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44980: LD_ADDR_EXP 118
44984: PUSH
44985: LD_EXP 118
44989: PPUSH
44990: LD_VAR 0 2
44994: PPUSH
44995: EMPTY
44996: PPUSH
44997: CALL_OW 1
45001: ST_TO_ADDR
// end ; continue ;
45002: GO 44754
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
45004: LD_EXP 117
45008: PUSH
45009: LD_VAR 0 2
45013: ARRAY
45014: PUSH
45015: LD_INT 1
45017: ARRAY
45018: PUSH
45019: LD_INT 1
45021: ARRAY
45022: PPUSH
45023: LD_EXP 117
45027: PUSH
45028: LD_VAR 0 2
45032: ARRAY
45033: PUSH
45034: LD_INT 1
45036: ARRAY
45037: PUSH
45038: LD_INT 2
45040: ARRAY
45041: PPUSH
45042: LD_EXP 106
45046: PUSH
45047: LD_VAR 0 2
45051: ARRAY
45052: PPUSH
45053: CALL_OW 440
45057: IFFALSE 45100
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
45059: LD_ADDR_EXP 117
45063: PUSH
45064: LD_EXP 117
45068: PPUSH
45069: LD_VAR 0 2
45073: PPUSH
45074: LD_EXP 117
45078: PUSH
45079: LD_VAR 0 2
45083: ARRAY
45084: PPUSH
45085: LD_INT 1
45087: PPUSH
45088: CALL_OW 3
45092: PPUSH
45093: CALL_OW 1
45097: ST_TO_ADDR
45098: GO 45349
// begin if not mc_deposits_finder [ i ] then
45100: LD_EXP 118
45104: PUSH
45105: LD_VAR 0 2
45109: ARRAY
45110: NOT
45111: IFFALSE 45163
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
45113: LD_ADDR_EXP 118
45117: PUSH
45118: LD_EXP 118
45122: PPUSH
45123: LD_VAR 0 2
45127: PPUSH
45128: LD_VAR 0 3
45132: PUSH
45133: LD_INT 1
45135: ARRAY
45136: PUSH
45137: EMPTY
45138: LIST
45139: PPUSH
45140: CALL_OW 1
45144: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
45145: LD_VAR 0 3
45149: PUSH
45150: LD_INT 1
45152: ARRAY
45153: PPUSH
45154: LD_INT 125
45156: PPUSH
45157: CALL_OW 109
// end else
45161: GO 45349
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
45163: LD_EXP 118
45167: PUSH
45168: LD_VAR 0 2
45172: ARRAY
45173: PUSH
45174: LD_INT 1
45176: ARRAY
45177: PPUSH
45178: CALL_OW 310
45182: IFFALSE 45205
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
45184: LD_EXP 118
45188: PUSH
45189: LD_VAR 0 2
45193: ARRAY
45194: PUSH
45195: LD_INT 1
45197: ARRAY
45198: PPUSH
45199: CALL_OW 122
45203: GO 45349
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
45205: LD_EXP 118
45209: PUSH
45210: LD_VAR 0 2
45214: ARRAY
45215: PUSH
45216: LD_INT 1
45218: ARRAY
45219: PPUSH
45220: CALL_OW 314
45224: NOT
45225: IFFALSE 45290
45227: PUSH
45228: LD_EXP 118
45232: PUSH
45233: LD_VAR 0 2
45237: ARRAY
45238: PUSH
45239: LD_INT 1
45241: ARRAY
45242: PPUSH
45243: LD_EXP 117
45247: PUSH
45248: LD_VAR 0 2
45252: ARRAY
45253: PUSH
45254: LD_INT 1
45256: ARRAY
45257: PUSH
45258: LD_INT 1
45260: ARRAY
45261: PPUSH
45262: LD_EXP 117
45266: PUSH
45267: LD_VAR 0 2
45271: ARRAY
45272: PUSH
45273: LD_INT 1
45275: ARRAY
45276: PUSH
45277: LD_INT 2
45279: ARRAY
45280: PPUSH
45281: CALL_OW 297
45285: PUSH
45286: LD_INT 6
45288: GREATER
45289: AND
45290: IFFALSE 45349
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
45292: LD_EXP 118
45296: PUSH
45297: LD_VAR 0 2
45301: ARRAY
45302: PUSH
45303: LD_INT 1
45305: ARRAY
45306: PPUSH
45307: LD_EXP 117
45311: PUSH
45312: LD_VAR 0 2
45316: ARRAY
45317: PUSH
45318: LD_INT 1
45320: ARRAY
45321: PUSH
45322: LD_INT 1
45324: ARRAY
45325: PPUSH
45326: LD_EXP 117
45330: PUSH
45331: LD_VAR 0 2
45335: ARRAY
45336: PUSH
45337: LD_INT 1
45339: ARRAY
45340: PUSH
45341: LD_INT 2
45343: ARRAY
45344: PPUSH
45345: CALL_OW 111
// end ; end ; end ;
45349: GO 44754
45351: POP
45352: POP
// end ;
45353: LD_VAR 0 1
45357: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
45358: LD_INT 0
45360: PPUSH
45361: PPUSH
45362: PPUSH
45363: PPUSH
45364: PPUSH
45365: PPUSH
45366: PPUSH
45367: PPUSH
45368: PPUSH
45369: PPUSH
45370: PPUSH
// if not mc_bases then
45371: LD_EXP 80
45375: NOT
45376: IFFALSE 45380
// exit ;
45378: GO 46340
// for i = 1 to mc_bases do
45380: LD_ADDR_VAR 0 2
45384: PUSH
45385: DOUBLE
45386: LD_INT 1
45388: DEC
45389: ST_TO_ADDR
45390: LD_EXP 80
45394: PUSH
45395: FOR_TO
45396: IFFALSE 46338
// begin if not mc_bases [ i ] or mc_scan [ i ] then
45398: LD_EXP 80
45402: PUSH
45403: LD_VAR 0 2
45407: ARRAY
45408: NOT
45409: IFTRUE 45423
45411: PUSH
45412: LD_EXP 103
45416: PUSH
45417: LD_VAR 0 2
45421: ARRAY
45422: OR
45423: IFFALSE 45427
// continue ;
45425: GO 45395
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
45427: LD_ADDR_VAR 0 7
45431: PUSH
45432: LD_EXP 80
45436: PUSH
45437: LD_VAR 0 2
45441: ARRAY
45442: PUSH
45443: LD_INT 1
45445: ARRAY
45446: PPUSH
45447: CALL_OW 248
45451: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
45452: LD_VAR 0 7
45456: PUSH
45457: LD_INT 3
45459: EQUAL
45460: IFTRUE 45502
45462: PUSH
45463: LD_EXP 99
45467: PUSH
45468: LD_VAR 0 2
45472: ARRAY
45473: PUSH
45474: LD_EXP 102
45478: PUSH
45479: LD_VAR 0 2
45483: ARRAY
45484: UNION
45485: PPUSH
45486: LD_INT 33
45488: PUSH
45489: LD_INT 2
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PPUSH
45496: CALL_OW 72
45500: NOT
45501: OR
45502: IFFALSE 45506
// continue ;
45504: GO 45395
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
45506: LD_ADDR_VAR 0 9
45510: PUSH
45511: LD_EXP 80
45515: PUSH
45516: LD_VAR 0 2
45520: ARRAY
45521: PPUSH
45522: LD_INT 30
45524: PUSH
45525: LD_INT 36
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: PPUSH
45532: CALL_OW 72
45536: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
45537: LD_ADDR_VAR 0 10
45541: PUSH
45542: LD_EXP 99
45546: PUSH
45547: LD_VAR 0 2
45551: ARRAY
45552: PPUSH
45553: LD_INT 34
45555: PUSH
45556: LD_INT 31
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: PPUSH
45563: CALL_OW 72
45567: ST_TO_ADDR
// if not cts and not mcts then
45568: LD_VAR 0 9
45572: NOT
45573: IFFALSE 45582
45575: PUSH
45576: LD_VAR 0 10
45580: NOT
45581: AND
45582: IFFALSE 45586
// continue ;
45584: GO 45395
// x := cts ;
45586: LD_ADDR_VAR 0 11
45590: PUSH
45591: LD_VAR 0 9
45595: ST_TO_ADDR
// if not x then
45596: LD_VAR 0 11
45600: NOT
45601: IFFALSE 45613
// x := mcts ;
45603: LD_ADDR_VAR 0 11
45607: PUSH
45608: LD_VAR 0 10
45612: ST_TO_ADDR
// if not x then
45613: LD_VAR 0 11
45617: NOT
45618: IFFALSE 45622
// continue ;
45620: GO 45395
// if mc_remote_driver [ i ] then
45622: LD_EXP 120
45626: PUSH
45627: LD_VAR 0 2
45631: ARRAY
45632: IFFALSE 46031
// for j in mc_remote_driver [ i ] do
45634: LD_ADDR_VAR 0 3
45638: PUSH
45639: LD_EXP 120
45643: PUSH
45644: LD_VAR 0 2
45648: ARRAY
45649: PUSH
45650: FOR_IN
45651: IFFALSE 46029
// begin if GetClass ( j ) <> 3 then
45653: LD_VAR 0 3
45657: PPUSH
45658: CALL_OW 257
45662: PUSH
45663: LD_INT 3
45665: NONEQUAL
45666: IFFALSE 45719
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
45668: LD_ADDR_EXP 120
45672: PUSH
45673: LD_EXP 120
45677: PPUSH
45678: LD_VAR 0 2
45682: PPUSH
45683: LD_EXP 120
45687: PUSH
45688: LD_VAR 0 2
45692: ARRAY
45693: PUSH
45694: LD_VAR 0 3
45698: DIFF
45699: PPUSH
45700: CALL_OW 1
45704: ST_TO_ADDR
// SetTag ( j , 0 ) ;
45705: LD_VAR 0 3
45709: PPUSH
45710: LD_INT 0
45712: PPUSH
45713: CALL_OW 109
// continue ;
45717: GO 45650
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
45719: LD_EXP 99
45723: PUSH
45724: LD_VAR 0 2
45728: ARRAY
45729: PPUSH
45730: LD_INT 34
45732: PUSH
45733: LD_INT 31
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: PUSH
45740: LD_INT 58
45742: PUSH
45743: EMPTY
45744: LIST
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PPUSH
45750: CALL_OW 72
45754: IFFALSE 45768
45756: PUSH
45757: LD_VAR 0 3
45761: PPUSH
45762: CALL 90253 0 1
45766: NOT
45767: AND
45768: IFFALSE 45839
// begin if IsInUnit ( j ) then
45770: LD_VAR 0 3
45774: PPUSH
45775: CALL_OW 310
45779: IFFALSE 45790
// ComExitBuilding ( j ) ;
45781: LD_VAR 0 3
45785: PPUSH
45786: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
45790: LD_VAR 0 3
45794: PPUSH
45795: LD_EXP 99
45799: PUSH
45800: LD_VAR 0 2
45804: ARRAY
45805: PPUSH
45806: LD_INT 34
45808: PUSH
45809: LD_INT 31
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 58
45818: PUSH
45819: EMPTY
45820: LIST
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PPUSH
45826: CALL_OW 72
45830: PUSH
45831: LD_INT 1
45833: ARRAY
45834: PPUSH
45835: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
45839: LD_VAR 0 3
45843: PPUSH
45844: CALL_OW 310
45848: NOT
45849: IFTRUE 45885
45851: PUSH
45852: LD_VAR 0 3
45856: PPUSH
45857: CALL_OW 310
45861: PPUSH
45862: CALL_OW 266
45866: PUSH
45867: LD_INT 36
45869: NONEQUAL
45870: IFFALSE 45884
45872: PUSH
45873: LD_VAR 0 3
45877: PPUSH
45878: CALL 90253 0 1
45882: NOT
45883: AND
45884: OR
45885: IFFALSE 46027
// begin if IsInUnit ( j ) then
45887: LD_VAR 0 3
45891: PPUSH
45892: CALL_OW 310
45896: IFFALSE 45907
// ComExitBuilding ( j ) ;
45898: LD_VAR 0 3
45902: PPUSH
45903: CALL_OW 122
// ct := 0 ;
45907: LD_ADDR_VAR 0 8
45911: PUSH
45912: LD_INT 0
45914: ST_TO_ADDR
// for k in x do
45915: LD_ADDR_VAR 0 4
45919: PUSH
45920: LD_VAR 0 11
45924: PUSH
45925: FOR_IN
45926: IFFALSE 46005
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
45928: LD_VAR 0 4
45932: PPUSH
45933: CALL_OW 264
45937: PUSH
45938: LD_INT 31
45940: EQUAL
45941: IFFALSE 45955
45943: PUSH
45944: LD_VAR 0 4
45948: PPUSH
45949: CALL_OW 311
45953: NOT
45954: AND
45955: IFTRUE 45989
45957: PUSH
45958: LD_VAR 0 4
45962: PPUSH
45963: CALL_OW 266
45967: PUSH
45968: LD_INT 36
45970: EQUAL
45971: IFFALSE 45988
45973: PUSH
45974: LD_VAR 0 4
45978: PPUSH
45979: CALL_OW 313
45983: PUSH
45984: LD_INT 3
45986: LESS
45987: AND
45988: OR
45989: IFFALSE 46003
// begin ct := k ;
45991: LD_ADDR_VAR 0 8
45995: PUSH
45996: LD_VAR 0 4
46000: ST_TO_ADDR
// break ;
46001: GO 46005
// end ;
46003: GO 45925
46005: POP
46006: POP
// if ct then
46007: LD_VAR 0 8
46011: IFFALSE 46027
// ComEnterUnit ( j , ct ) ;
46013: LD_VAR 0 3
46017: PPUSH
46018: LD_VAR 0 8
46022: PPUSH
46023: CALL_OW 120
// end ; end ;
46027: GO 45650
46029: POP
46030: POP
// places := 0 ;
46031: LD_ADDR_VAR 0 5
46035: PUSH
46036: LD_INT 0
46038: ST_TO_ADDR
// for j = 1 to x do
46039: LD_ADDR_VAR 0 3
46043: PUSH
46044: DOUBLE
46045: LD_INT 1
46047: DEC
46048: ST_TO_ADDR
46049: LD_VAR 0 11
46053: PUSH
46054: FOR_TO
46055: IFFALSE 46131
// if GetWeapon ( x [ j ] ) = ar_control_tower then
46057: LD_VAR 0 11
46061: PUSH
46062: LD_VAR 0 3
46066: ARRAY
46067: PPUSH
46068: CALL_OW 264
46072: PUSH
46073: LD_INT 31
46075: EQUAL
46076: IFFALSE 46094
// places := places + 1 else
46078: LD_ADDR_VAR 0 5
46082: PUSH
46083: LD_VAR 0 5
46087: PUSH
46088: LD_INT 1
46090: PLUS
46091: ST_TO_ADDR
46092: GO 46129
// if GetBType ( x [ j ] ) = b_control_tower then
46094: LD_VAR 0 11
46098: PUSH
46099: LD_VAR 0 3
46103: ARRAY
46104: PPUSH
46105: CALL_OW 266
46109: PUSH
46110: LD_INT 36
46112: EQUAL
46113: IFFALSE 46129
// places := places + 3 ;
46115: LD_ADDR_VAR 0 5
46119: PUSH
46120: LD_VAR 0 5
46124: PUSH
46125: LD_INT 3
46127: PLUS
46128: ST_TO_ADDR
46129: GO 46054
46131: POP
46132: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
46133: LD_VAR 0 5
46137: PUSH
46138: LD_INT 0
46140: EQUAL
46141: IFTRUE 46161
46143: PUSH
46144: LD_VAR 0 5
46148: PUSH
46149: LD_EXP 120
46153: PUSH
46154: LD_VAR 0 2
46158: ARRAY
46159: LESSEQUAL
46160: OR
46161: IFFALSE 46165
// continue ;
46163: GO 45395
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
46165: LD_ADDR_VAR 0 6
46169: PUSH
46170: LD_EXP 80
46174: PUSH
46175: LD_VAR 0 2
46179: ARRAY
46180: PPUSH
46181: LD_INT 25
46183: PUSH
46184: LD_INT 3
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: PPUSH
46191: CALL_OW 72
46195: PUSH
46196: LD_EXP 120
46200: PUSH
46201: LD_VAR 0 2
46205: ARRAY
46206: DIFF
46207: PPUSH
46208: LD_INT 3
46210: PPUSH
46211: CALL 91153 0 2
46215: ST_TO_ADDR
// for j in tmp do
46216: LD_ADDR_VAR 0 3
46220: PUSH
46221: LD_VAR 0 6
46225: PUSH
46226: FOR_IN
46227: IFFALSE 46262
// if GetTag ( j ) > 0 then
46229: LD_VAR 0 3
46233: PPUSH
46234: CALL_OW 110
46238: PUSH
46239: LD_INT 0
46241: GREATER
46242: IFFALSE 46260
// tmp := tmp diff j ;
46244: LD_ADDR_VAR 0 6
46248: PUSH
46249: LD_VAR 0 6
46253: PUSH
46254: LD_VAR 0 3
46258: DIFF
46259: ST_TO_ADDR
46260: GO 46226
46262: POP
46263: POP
// if not tmp then
46264: LD_VAR 0 6
46268: NOT
46269: IFFALSE 46273
// continue ;
46271: GO 45395
// if places then
46273: LD_VAR 0 5
46277: IFFALSE 46336
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
46279: LD_ADDR_EXP 120
46283: PUSH
46284: LD_EXP 120
46288: PPUSH
46289: LD_VAR 0 2
46293: PPUSH
46294: LD_EXP 120
46298: PUSH
46299: LD_VAR 0 2
46303: ARRAY
46304: PUSH
46305: LD_VAR 0 6
46309: PUSH
46310: LD_INT 1
46312: ARRAY
46313: UNION
46314: PPUSH
46315: CALL_OW 1
46319: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
46320: LD_VAR 0 6
46324: PUSH
46325: LD_INT 1
46327: ARRAY
46328: PPUSH
46329: LD_INT 126
46331: PPUSH
46332: CALL_OW 109
// end ; end ;
46336: GO 45395
46338: POP
46339: POP
// end ;
46340: LD_VAR 0 1
46344: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
46345: LD_INT 0
46347: PPUSH
46348: PPUSH
46349: PPUSH
46350: PPUSH
46351: PPUSH
46352: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
46353: LD_VAR 0 1
46357: NOT
46358: IFTRUE 46367
46360: PUSH
46361: LD_VAR 0 2
46365: NOT
46366: OR
46367: IFTRUE 46376
46369: PUSH
46370: LD_VAR 0 3
46374: NOT
46375: OR
46376: IFTRUE 46424
46378: PUSH
46379: LD_VAR 0 4
46383: PUSH
46384: LD_INT 1
46386: PUSH
46387: LD_INT 2
46389: PUSH
46390: LD_INT 3
46392: PUSH
46393: LD_INT 4
46395: PUSH
46396: LD_INT 5
46398: PUSH
46399: LD_INT 8
46401: PUSH
46402: LD_INT 9
46404: PUSH
46405: LD_INT 15
46407: PUSH
46408: LD_INT 16
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: IN
46422: NOT
46423: OR
46424: IFFALSE 46428
// exit ;
46426: GO 47288
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
46428: LD_ADDR_VAR 0 2
46432: PUSH
46433: LD_VAR 0 2
46437: PPUSH
46438: LD_INT 21
46440: PUSH
46441: LD_INT 3
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: LD_INT 24
46450: PUSH
46451: LD_INT 250
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: EMPTY
46459: LIST
46460: LIST
46461: PPUSH
46462: CALL_OW 72
46466: ST_TO_ADDR
// case class of 1 , 15 :
46467: LD_VAR 0 4
46471: PUSH
46472: LD_INT 1
46474: DOUBLE
46475: EQUAL
46476: IFTRUE 46486
46478: LD_INT 15
46480: DOUBLE
46481: EQUAL
46482: IFTRUE 46486
46484: GO 46571
46486: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
46487: LD_ADDR_VAR 0 8
46491: PUSH
46492: LD_VAR 0 2
46496: PPUSH
46497: LD_INT 2
46499: PUSH
46500: LD_INT 30
46502: PUSH
46503: LD_INT 32
46505: PUSH
46506: EMPTY
46507: LIST
46508: LIST
46509: PUSH
46510: LD_INT 30
46512: PUSH
46513: LD_INT 31
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: EMPTY
46521: LIST
46522: LIST
46523: LIST
46524: PPUSH
46525: CALL_OW 72
46529: PUSH
46530: LD_VAR 0 2
46534: PPUSH
46535: LD_INT 2
46537: PUSH
46538: LD_INT 30
46540: PUSH
46541: LD_INT 4
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_INT 30
46550: PUSH
46551: LD_INT 5
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: LIST
46562: PPUSH
46563: CALL_OW 72
46567: ADD
46568: ST_TO_ADDR
46569: GO 46817
46571: LD_INT 2
46573: DOUBLE
46574: EQUAL
46575: IFTRUE 46585
46577: LD_INT 16
46579: DOUBLE
46580: EQUAL
46581: IFTRUE 46585
46583: GO 46631
46585: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
46586: LD_ADDR_VAR 0 8
46590: PUSH
46591: LD_VAR 0 2
46595: PPUSH
46596: LD_INT 2
46598: PUSH
46599: LD_INT 30
46601: PUSH
46602: LD_INT 0
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_INT 30
46611: PUSH
46612: LD_INT 1
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: LIST
46623: PPUSH
46624: CALL_OW 72
46628: ST_TO_ADDR
46629: GO 46817
46631: LD_INT 3
46633: DOUBLE
46634: EQUAL
46635: IFTRUE 46639
46637: GO 46685
46639: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
46640: LD_ADDR_VAR 0 8
46644: PUSH
46645: LD_VAR 0 2
46649: PPUSH
46650: LD_INT 2
46652: PUSH
46653: LD_INT 30
46655: PUSH
46656: LD_INT 2
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: PUSH
46663: LD_INT 30
46665: PUSH
46666: LD_INT 3
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: PUSH
46673: EMPTY
46674: LIST
46675: LIST
46676: LIST
46677: PPUSH
46678: CALL_OW 72
46682: ST_TO_ADDR
46683: GO 46817
46685: LD_INT 4
46687: DOUBLE
46688: EQUAL
46689: IFTRUE 46693
46691: GO 46750
46693: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
46694: LD_ADDR_VAR 0 8
46698: PUSH
46699: LD_VAR 0 2
46703: PPUSH
46704: LD_INT 2
46706: PUSH
46707: LD_INT 30
46709: PUSH
46710: LD_INT 6
46712: PUSH
46713: EMPTY
46714: LIST
46715: LIST
46716: PUSH
46717: LD_INT 30
46719: PUSH
46720: LD_INT 7
46722: PUSH
46723: EMPTY
46724: LIST
46725: LIST
46726: PUSH
46727: LD_INT 30
46729: PUSH
46730: LD_INT 8
46732: PUSH
46733: EMPTY
46734: LIST
46735: LIST
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: PPUSH
46743: CALL_OW 72
46747: ST_TO_ADDR
46748: GO 46817
46750: LD_INT 5
46752: DOUBLE
46753: EQUAL
46754: IFTRUE 46770
46756: LD_INT 8
46758: DOUBLE
46759: EQUAL
46760: IFTRUE 46770
46762: LD_INT 9
46764: DOUBLE
46765: EQUAL
46766: IFTRUE 46770
46768: GO 46816
46770: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
46771: LD_ADDR_VAR 0 8
46775: PUSH
46776: LD_VAR 0 2
46780: PPUSH
46781: LD_INT 2
46783: PUSH
46784: LD_INT 30
46786: PUSH
46787: LD_INT 4
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: PUSH
46794: LD_INT 30
46796: PUSH
46797: LD_INT 5
46799: PUSH
46800: EMPTY
46801: LIST
46802: LIST
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: LIST
46808: PPUSH
46809: CALL_OW 72
46813: ST_TO_ADDR
46814: GO 46817
46816: POP
// if not tmp then
46817: LD_VAR 0 8
46821: NOT
46822: IFFALSE 46826
// exit ;
46824: GO 47288
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
46826: LD_VAR 0 4
46830: PUSH
46831: LD_INT 1
46833: PUSH
46834: LD_INT 15
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: IN
46841: IFFALSE 46855
46843: PUSH
46844: LD_EXP 89
46848: PUSH
46849: LD_VAR 0 1
46853: ARRAY
46854: AND
46855: IFFALSE 47011
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
46857: LD_ADDR_VAR 0 9
46861: PUSH
46862: LD_EXP 89
46866: PUSH
46867: LD_VAR 0 1
46871: ARRAY
46872: PUSH
46873: LD_INT 1
46875: ARRAY
46876: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
46877: LD_VAR 0 9
46881: PUSH
46882: LD_EXP 90
46886: PUSH
46887: LD_VAR 0 1
46891: ARRAY
46892: IN
46893: NOT
46894: IFFALSE 47009
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
46896: LD_ADDR_EXP 90
46900: PUSH
46901: LD_EXP 90
46905: PPUSH
46906: LD_VAR 0 1
46910: PUSH
46911: LD_EXP 90
46915: PUSH
46916: LD_VAR 0 1
46920: ARRAY
46921: PUSH
46922: LD_INT 1
46924: PLUS
46925: PUSH
46926: EMPTY
46927: LIST
46928: LIST
46929: PPUSH
46930: LD_VAR 0 9
46934: PPUSH
46935: CALL 59615 0 3
46939: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
46940: LD_ADDR_EXP 89
46944: PUSH
46945: LD_EXP 89
46949: PPUSH
46950: LD_VAR 0 1
46954: PPUSH
46955: LD_EXP 89
46959: PUSH
46960: LD_VAR 0 1
46964: ARRAY
46965: PUSH
46966: LD_VAR 0 9
46970: DIFF
46971: PPUSH
46972: CALL_OW 1
46976: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
46977: LD_VAR 0 3
46981: PPUSH
46982: LD_EXP 90
46986: PUSH
46987: LD_VAR 0 1
46991: ARRAY
46992: PUSH
46993: LD_EXP 90
46997: PUSH
46998: LD_VAR 0 1
47002: ARRAY
47003: ARRAY
47004: PPUSH
47005: CALL_OW 120
// end ; exit ;
47009: GO 47288
// end ; if tmp > 1 then
47011: LD_VAR 0 8
47015: PUSH
47016: LD_INT 1
47018: GREATER
47019: IFFALSE 47123
// for i = 2 to tmp do
47021: LD_ADDR_VAR 0 6
47025: PUSH
47026: DOUBLE
47027: LD_INT 2
47029: DEC
47030: ST_TO_ADDR
47031: LD_VAR 0 8
47035: PUSH
47036: FOR_TO
47037: IFFALSE 47121
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
47039: LD_VAR 0 8
47043: PUSH
47044: LD_VAR 0 6
47048: ARRAY
47049: PPUSH
47050: CALL_OW 461
47054: PUSH
47055: LD_INT 6
47057: EQUAL
47058: IFFALSE 47119
// begin x := tmp [ i ] ;
47060: LD_ADDR_VAR 0 9
47064: PUSH
47065: LD_VAR 0 8
47069: PUSH
47070: LD_VAR 0 6
47074: ARRAY
47075: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
47076: LD_ADDR_VAR 0 8
47080: PUSH
47081: LD_VAR 0 8
47085: PPUSH
47086: LD_VAR 0 6
47090: PPUSH
47091: CALL_OW 3
47095: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
47096: LD_ADDR_VAR 0 8
47100: PUSH
47101: LD_VAR 0 8
47105: PPUSH
47106: LD_INT 1
47108: PPUSH
47109: LD_VAR 0 9
47113: PPUSH
47114: CALL_OW 2
47118: ST_TO_ADDR
// end ;
47119: GO 47036
47121: POP
47122: POP
// for i in tmp do
47123: LD_ADDR_VAR 0 6
47127: PUSH
47128: LD_VAR 0 8
47132: PUSH
47133: FOR_IN
47134: IFFALSE 47161
// begin if IsNotFull ( i ) then
47136: LD_VAR 0 6
47140: PPUSH
47141: CALL 56779 0 1
47145: IFFALSE 47159
// begin j := i ;
47147: LD_ADDR_VAR 0 7
47151: PUSH
47152: LD_VAR 0 6
47156: ST_TO_ADDR
// break ;
47157: GO 47161
// end ; end ;
47159: GO 47133
47161: POP
47162: POP
// if j then
47163: LD_VAR 0 7
47167: IFFALSE 47185
// ComEnterUnit ( unit , j ) else
47169: LD_VAR 0 3
47173: PPUSH
47174: LD_VAR 0 7
47178: PPUSH
47179: CALL_OW 120
47183: GO 47288
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47185: LD_ADDR_VAR 0 10
47189: PUSH
47190: LD_VAR 0 2
47194: PPUSH
47195: LD_INT 2
47197: PUSH
47198: LD_INT 30
47200: PUSH
47201: LD_INT 0
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 30
47210: PUSH
47211: LD_INT 1
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: LIST
47222: PPUSH
47223: CALL_OW 72
47227: ST_TO_ADDR
// if depot then
47228: LD_VAR 0 10
47232: IFFALSE 47288
// begin depot := NearestUnitToUnit ( depot , unit ) ;
47234: LD_ADDR_VAR 0 10
47238: PUSH
47239: LD_VAR 0 10
47243: PPUSH
47244: LD_VAR 0 3
47248: PPUSH
47249: CALL_OW 74
47253: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
47254: LD_VAR 0 3
47258: PPUSH
47259: LD_VAR 0 10
47263: PPUSH
47264: CALL_OW 296
47268: PUSH
47269: LD_INT 10
47271: GREATER
47272: IFFALSE 47288
// ComStandNearbyBuilding ( unit , depot ) ;
47274: LD_VAR 0 3
47278: PPUSH
47279: LD_VAR 0 10
47283: PPUSH
47284: CALL 56157 0 2
// end ; end ; end ;
47288: LD_VAR 0 5
47292: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
47293: LD_INT 0
47295: PPUSH
47296: PPUSH
47297: PPUSH
47298: PPUSH
// if not mc_bases then
47299: LD_EXP 80
47303: NOT
47304: IFFALSE 47308
// exit ;
47306: GO 47559
// for i = 1 to mc_bases do
47308: LD_ADDR_VAR 0 2
47312: PUSH
47313: DOUBLE
47314: LD_INT 1
47316: DEC
47317: ST_TO_ADDR
47318: LD_EXP 80
47322: PUSH
47323: FOR_TO
47324: IFFALSE 47557
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
47326: LD_ADDR_VAR 0 4
47330: PUSH
47331: LD_EXP 80
47335: PUSH
47336: LD_VAR 0 2
47340: ARRAY
47341: PPUSH
47342: LD_INT 21
47344: PUSH
47345: LD_INT 1
47347: PUSH
47348: EMPTY
47349: LIST
47350: LIST
47351: PPUSH
47352: CALL_OW 72
47356: PUSH
47357: LD_EXP 109
47361: PUSH
47362: LD_VAR 0 2
47366: ARRAY
47367: UNION
47368: ST_TO_ADDR
// if not tmp then
47369: LD_VAR 0 4
47373: NOT
47374: IFFALSE 47378
// continue ;
47376: GO 47323
// for j in tmp do
47378: LD_ADDR_VAR 0 3
47382: PUSH
47383: LD_VAR 0 4
47387: PUSH
47388: FOR_IN
47389: IFFALSE 47553
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
47391: LD_VAR 0 3
47395: PPUSH
47396: CALL_OW 110
47400: NOT
47401: IFFALSE 47415
47403: PUSH
47404: LD_VAR 0 3
47408: PPUSH
47409: CALL_OW 314
47413: NOT
47414: AND
47415: IFFALSE 47429
47417: PUSH
47418: LD_VAR 0 3
47422: PPUSH
47423: CALL_OW 311
47427: NOT
47428: AND
47429: IFFALSE 47443
47431: PUSH
47432: LD_VAR 0 3
47436: PPUSH
47437: CALL_OW 310
47441: NOT
47442: AND
47443: IFFALSE 47468
47445: PUSH
47446: LD_VAR 0 3
47450: PUSH
47451: LD_EXP 83
47455: PUSH
47456: LD_VAR 0 2
47460: ARRAY
47461: PUSH
47462: LD_INT 1
47464: ARRAY
47465: IN
47466: NOT
47467: AND
47468: IFFALSE 47493
47470: PUSH
47471: LD_VAR 0 3
47475: PUSH
47476: LD_EXP 83
47480: PUSH
47481: LD_VAR 0 2
47485: ARRAY
47486: PUSH
47487: LD_INT 2
47489: ARRAY
47490: IN
47491: NOT
47492: AND
47493: IFFALSE 47514
47495: PUSH
47496: LD_VAR 0 3
47500: PUSH
47501: LD_EXP 92
47505: PUSH
47506: LD_VAR 0 2
47510: ARRAY
47511: IN
47512: NOT
47513: AND
47514: IFFALSE 47551
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
47516: LD_VAR 0 2
47520: PPUSH
47521: LD_EXP 80
47525: PUSH
47526: LD_VAR 0 2
47530: ARRAY
47531: PPUSH
47532: LD_VAR 0 3
47536: PPUSH
47537: LD_VAR 0 3
47541: PPUSH
47542: CALL_OW 257
47546: PPUSH
47547: CALL 46345 0 4
// end ;
47551: GO 47388
47553: POP
47554: POP
// end ;
47555: GO 47323
47557: POP
47558: POP
// end ;
47559: LD_VAR 0 1
47563: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
47564: LD_INT 0
47566: PPUSH
47567: PPUSH
47568: PPUSH
47569: PPUSH
47570: PPUSH
47571: PPUSH
// if not mc_bases [ base ] then
47572: LD_EXP 80
47576: PUSH
47577: LD_VAR 0 1
47581: ARRAY
47582: NOT
47583: IFFALSE 47587
// exit ;
47585: GO 47788
// tmp := [ ] ;
47587: LD_ADDR_VAR 0 6
47591: PUSH
47592: EMPTY
47593: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
47594: LD_ADDR_VAR 0 7
47598: PUSH
47599: LD_VAR 0 3
47603: PPUSH
47604: LD_INT 0
47606: PPUSH
47607: CALL_OW 517
47611: ST_TO_ADDR
// if not list then
47612: LD_VAR 0 7
47616: NOT
47617: IFFALSE 47621
// exit ;
47619: GO 47788
// c := Count ( list [ 1 ] ) ;
47621: LD_ADDR_VAR 0 9
47625: PUSH
47626: LD_VAR 0 7
47630: PUSH
47631: LD_INT 1
47633: ARRAY
47634: PPUSH
47635: CALL 56697 0 1
47639: ST_TO_ADDR
// if amount > c then
47640: LD_VAR 0 2
47644: PUSH
47645: LD_VAR 0 9
47649: GREATER
47650: IFFALSE 47662
// amount := c ;
47652: LD_ADDR_VAR 0 2
47656: PUSH
47657: LD_VAR 0 9
47661: ST_TO_ADDR
// for i := 1 to amount do
47662: LD_ADDR_VAR 0 5
47666: PUSH
47667: DOUBLE
47668: LD_INT 1
47670: DEC
47671: ST_TO_ADDR
47672: LD_VAR 0 2
47676: PUSH
47677: FOR_TO
47678: IFFALSE 47736
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
47680: LD_ADDR_VAR 0 6
47684: PUSH
47685: LD_VAR 0 6
47689: PPUSH
47690: LD_VAR 0 5
47694: PPUSH
47695: LD_VAR 0 7
47699: PUSH
47700: LD_INT 1
47702: ARRAY
47703: PUSH
47704: LD_VAR 0 5
47708: ARRAY
47709: PUSH
47710: LD_VAR 0 7
47714: PUSH
47715: LD_INT 2
47717: ARRAY
47718: PUSH
47719: LD_VAR 0 5
47723: ARRAY
47724: PUSH
47725: EMPTY
47726: LIST
47727: LIST
47728: PPUSH
47729: CALL_OW 1
47733: ST_TO_ADDR
47734: GO 47677
47736: POP
47737: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
47738: LD_ADDR_EXP 93
47742: PUSH
47743: LD_EXP 93
47747: PPUSH
47748: LD_VAR 0 1
47752: PPUSH
47753: LD_VAR 0 6
47757: PPUSH
47758: CALL_OW 1
47762: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
47763: LD_ADDR_EXP 95
47767: PUSH
47768: LD_EXP 95
47772: PPUSH
47773: LD_VAR 0 1
47777: PPUSH
47778: LD_VAR 0 3
47782: PPUSH
47783: CALL_OW 1
47787: ST_TO_ADDR
// end ;
47788: LD_VAR 0 4
47792: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
47793: LD_INT 0
47795: PPUSH
// if not mc_bases [ base ] then
47796: LD_EXP 80
47800: PUSH
47801: LD_VAR 0 1
47805: ARRAY
47806: NOT
47807: IFFALSE 47811
// exit ;
47809: GO 47836
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
47811: LD_ADDR_EXP 85
47815: PUSH
47816: LD_EXP 85
47820: PPUSH
47821: LD_VAR 0 1
47825: PPUSH
47826: LD_VAR 0 2
47830: PPUSH
47831: CALL_OW 1
47835: ST_TO_ADDR
// end ;
47836: LD_VAR 0 3
47840: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
47841: LD_INT 0
47843: PPUSH
// if not mc_bases [ base ] then
47844: LD_EXP 80
47848: PUSH
47849: LD_VAR 0 1
47853: ARRAY
47854: NOT
47855: IFFALSE 47859
// exit ;
47857: GO 47896
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
47859: LD_ADDR_EXP 85
47863: PUSH
47864: LD_EXP 85
47868: PPUSH
47869: LD_VAR 0 1
47873: PPUSH
47874: LD_EXP 85
47878: PUSH
47879: LD_VAR 0 1
47883: ARRAY
47884: PUSH
47885: LD_VAR 0 2
47889: UNION
47890: PPUSH
47891: CALL_OW 1
47895: ST_TO_ADDR
// end ;
47896: LD_VAR 0 3
47900: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
47901: LD_INT 0
47903: PPUSH
// if not mc_bases [ base ] then
47904: LD_EXP 80
47908: PUSH
47909: LD_VAR 0 1
47913: ARRAY
47914: NOT
47915: IFFALSE 47919
// exit ;
47917: GO 47944
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
47919: LD_ADDR_EXP 101
47923: PUSH
47924: LD_EXP 101
47928: PPUSH
47929: LD_VAR 0 1
47933: PPUSH
47934: LD_VAR 0 2
47938: PPUSH
47939: CALL_OW 1
47943: ST_TO_ADDR
// end ;
47944: LD_VAR 0 3
47948: RET
// export function MC_InsertProduceList ( base , components ) ; begin
47949: LD_INT 0
47951: PPUSH
// if not mc_bases [ base ] then
47952: LD_EXP 80
47956: PUSH
47957: LD_VAR 0 1
47961: ARRAY
47962: NOT
47963: IFFALSE 47967
// exit ;
47965: GO 48004
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
47967: LD_ADDR_EXP 101
47971: PUSH
47972: LD_EXP 101
47976: PPUSH
47977: LD_VAR 0 1
47981: PPUSH
47982: LD_EXP 101
47986: PUSH
47987: LD_VAR 0 1
47991: ARRAY
47992: PUSH
47993: LD_VAR 0 2
47997: ADD
47998: PPUSH
47999: CALL_OW 1
48003: ST_TO_ADDR
// end ;
48004: LD_VAR 0 3
48008: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
48009: LD_INT 0
48011: PPUSH
// if not mc_bases [ base ] then
48012: LD_EXP 80
48016: PUSH
48017: LD_VAR 0 1
48021: ARRAY
48022: NOT
48023: IFFALSE 48027
// exit ;
48025: GO 48081
// mc_defender := Replace ( mc_defender , base , deflist ) ;
48027: LD_ADDR_EXP 102
48031: PUSH
48032: LD_EXP 102
48036: PPUSH
48037: LD_VAR 0 1
48041: PPUSH
48042: LD_VAR 0 2
48046: PPUSH
48047: CALL_OW 1
48051: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
48052: LD_ADDR_EXP 91
48056: PUSH
48057: LD_EXP 91
48061: PPUSH
48062: LD_VAR 0 1
48066: PPUSH
48067: LD_VAR 0 2
48071: PUSH
48072: LD_INT 0
48074: PLUS
48075: PPUSH
48076: CALL_OW 1
48080: ST_TO_ADDR
// end ;
48081: LD_VAR 0 3
48085: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
48086: LD_INT 0
48088: PPUSH
// if not mc_bases [ base ] then
48089: LD_EXP 80
48093: PUSH
48094: LD_VAR 0 1
48098: ARRAY
48099: NOT
48100: IFFALSE 48104
// exit ;
48102: GO 48129
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
48104: LD_ADDR_EXP 91
48108: PUSH
48109: LD_EXP 91
48113: PPUSH
48114: LD_VAR 0 1
48118: PPUSH
48119: LD_VAR 0 2
48123: PPUSH
48124: CALL_OW 1
48128: ST_TO_ADDR
// end ;
48129: LD_VAR 0 3
48133: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
48134: LD_INT 0
48136: PPUSH
48137: PPUSH
48138: PPUSH
48139: PPUSH
// if not mc_bases [ base ] then
48140: LD_EXP 80
48144: PUSH
48145: LD_VAR 0 1
48149: ARRAY
48150: NOT
48151: IFFALSE 48155
// exit ;
48153: GO 48220
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
48155: LD_ADDR_EXP 100
48159: PUSH
48160: LD_EXP 100
48164: PPUSH
48165: LD_VAR 0 1
48169: PUSH
48170: LD_EXP 100
48174: PUSH
48175: LD_VAR 0 1
48179: ARRAY
48180: PUSH
48181: LD_INT 1
48183: PLUS
48184: PUSH
48185: EMPTY
48186: LIST
48187: LIST
48188: PPUSH
48189: LD_VAR 0 1
48193: PUSH
48194: LD_VAR 0 2
48198: PUSH
48199: LD_VAR 0 3
48203: PUSH
48204: LD_VAR 0 4
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: LIST
48213: LIST
48214: PPUSH
48215: CALL 59615 0 3
48219: ST_TO_ADDR
// end ;
48220: LD_VAR 0 5
48224: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
48225: LD_INT 0
48227: PPUSH
// if not mc_bases [ base ] then
48228: LD_EXP 80
48232: PUSH
48233: LD_VAR 0 1
48237: ARRAY
48238: NOT
48239: IFFALSE 48243
// exit ;
48241: GO 48268
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
48243: LD_ADDR_EXP 117
48247: PUSH
48248: LD_EXP 117
48252: PPUSH
48253: LD_VAR 0 1
48257: PPUSH
48258: LD_VAR 0 2
48262: PPUSH
48263: CALL_OW 1
48267: ST_TO_ADDR
// end ;
48268: LD_VAR 0 3
48272: RET
// export function MC_GetMinesField ( base ) ; begin
48273: LD_INT 0
48275: PPUSH
// result := mc_mines [ base ] ;
48276: LD_ADDR_VAR 0 2
48280: PUSH
48281: LD_EXP 93
48285: PUSH
48286: LD_VAR 0 1
48290: ARRAY
48291: ST_TO_ADDR
// end ;
48292: LD_VAR 0 2
48296: RET
// export function MC_GetProduceList ( base ) ; begin
48297: LD_INT 0
48299: PPUSH
// result := mc_produce [ base ] ;
48300: LD_ADDR_VAR 0 2
48304: PUSH
48305: LD_EXP 101
48309: PUSH
48310: LD_VAR 0 1
48314: ARRAY
48315: ST_TO_ADDR
// end ;
48316: LD_VAR 0 2
48320: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
48321: LD_INT 0
48323: PPUSH
48324: PPUSH
// if not mc_bases then
48325: LD_EXP 80
48329: NOT
48330: IFFALSE 48334
// exit ;
48332: GO 48399
// if mc_bases [ base ] then
48334: LD_EXP 80
48338: PUSH
48339: LD_VAR 0 1
48343: ARRAY
48344: IFFALSE 48399
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
48346: LD_ADDR_VAR 0 3
48350: PUSH
48351: LD_EXP 80
48355: PUSH
48356: LD_VAR 0 1
48360: ARRAY
48361: PPUSH
48362: LD_INT 30
48364: PUSH
48365: LD_VAR 0 2
48369: PUSH
48370: EMPTY
48371: LIST
48372: LIST
48373: PPUSH
48374: CALL_OW 72
48378: ST_TO_ADDR
// if result then
48379: LD_VAR 0 3
48383: IFFALSE 48399
// result := result [ 1 ] ;
48385: LD_ADDR_VAR 0 3
48389: PUSH
48390: LD_VAR 0 3
48394: PUSH
48395: LD_INT 1
48397: ARRAY
48398: ST_TO_ADDR
// end ; end ;
48399: LD_VAR 0 3
48403: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
48404: LD_INT 0
48406: PPUSH
48407: PPUSH
// if not mc_bases then
48408: LD_EXP 80
48412: NOT
48413: IFFALSE 48417
// exit ;
48415: GO 48462
// if mc_bases [ base ] then
48417: LD_EXP 80
48421: PUSH
48422: LD_VAR 0 1
48426: ARRAY
48427: IFFALSE 48462
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
48429: LD_ADDR_VAR 0 3
48433: PUSH
48434: LD_EXP 80
48438: PUSH
48439: LD_VAR 0 1
48443: ARRAY
48444: PPUSH
48445: LD_INT 30
48447: PUSH
48448: LD_VAR 0 2
48452: PUSH
48453: EMPTY
48454: LIST
48455: LIST
48456: PPUSH
48457: CALL_OW 72
48461: ST_TO_ADDR
// end ;
48462: LD_VAR 0 3
48466: RET
// export function MC_SetTame ( base , area ) ; begin
48467: LD_INT 0
48469: PPUSH
// if not mc_bases or not base then
48470: LD_EXP 80
48474: NOT
48475: IFTRUE 48484
48477: PUSH
48478: LD_VAR 0 1
48482: NOT
48483: OR
48484: IFFALSE 48488
// exit ;
48486: GO 48513
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
48488: LD_ADDR_EXP 108
48492: PUSH
48493: LD_EXP 108
48497: PPUSH
48498: LD_VAR 0 1
48502: PPUSH
48503: LD_VAR 0 2
48507: PPUSH
48508: CALL_OW 1
48512: ST_TO_ADDR
// end ;
48513: LD_VAR 0 3
48517: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
48518: LD_INT 0
48520: PPUSH
48521: PPUSH
// if not mc_bases or not base then
48522: LD_EXP 80
48526: NOT
48527: IFTRUE 48536
48529: PUSH
48530: LD_VAR 0 1
48534: NOT
48535: OR
48536: IFFALSE 48540
// exit ;
48538: GO 48642
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
48540: LD_ADDR_VAR 0 4
48544: PUSH
48545: LD_EXP 80
48549: PUSH
48550: LD_VAR 0 1
48554: ARRAY
48555: PPUSH
48556: LD_INT 30
48558: PUSH
48559: LD_VAR 0 2
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PPUSH
48568: CALL_OW 72
48572: ST_TO_ADDR
// if not tmp then
48573: LD_VAR 0 4
48577: NOT
48578: IFFALSE 48582
// exit ;
48580: GO 48642
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
48582: LD_ADDR_EXP 112
48586: PUSH
48587: LD_EXP 112
48591: PPUSH
48592: LD_VAR 0 1
48596: PPUSH
48597: LD_EXP 112
48601: PUSH
48602: LD_VAR 0 1
48606: ARRAY
48607: PPUSH
48608: LD_EXP 112
48612: PUSH
48613: LD_VAR 0 1
48617: ARRAY
48618: PUSH
48619: LD_INT 1
48621: PLUS
48622: PPUSH
48623: LD_VAR 0 4
48627: PUSH
48628: LD_INT 1
48630: ARRAY
48631: PPUSH
48632: CALL_OW 2
48636: PPUSH
48637: CALL_OW 1
48641: ST_TO_ADDR
// end ;
48642: LD_VAR 0 3
48646: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
48647: LD_INT 0
48649: PPUSH
48650: PPUSH
// if not mc_bases or not base or not kinds then
48651: LD_EXP 80
48655: NOT
48656: IFTRUE 48665
48658: PUSH
48659: LD_VAR 0 1
48663: NOT
48664: OR
48665: IFTRUE 48674
48667: PUSH
48668: LD_VAR 0 2
48672: NOT
48673: OR
48674: IFFALSE 48678
// exit ;
48676: GO 48739
// for i in kinds do
48678: LD_ADDR_VAR 0 4
48682: PUSH
48683: LD_VAR 0 2
48687: PUSH
48688: FOR_IN
48689: IFFALSE 48737
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
48691: LD_ADDR_EXP 114
48695: PUSH
48696: LD_EXP 114
48700: PPUSH
48701: LD_VAR 0 1
48705: PUSH
48706: LD_EXP 114
48710: PUSH
48711: LD_VAR 0 1
48715: ARRAY
48716: PUSH
48717: LD_INT 1
48719: PLUS
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PPUSH
48725: LD_VAR 0 4
48729: PPUSH
48730: CALL 59615 0 3
48734: ST_TO_ADDR
48735: GO 48688
48737: POP
48738: POP
// end ;
48739: LD_VAR 0 3
48743: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
48744: LD_INT 0
48746: PPUSH
// if not mc_bases or not base or not areas then
48747: LD_EXP 80
48751: NOT
48752: IFTRUE 48761
48754: PUSH
48755: LD_VAR 0 1
48759: NOT
48760: OR
48761: IFTRUE 48770
48763: PUSH
48764: LD_VAR 0 2
48768: NOT
48769: OR
48770: IFFALSE 48774
// exit ;
48772: GO 48799
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
48774: LD_ADDR_EXP 98
48778: PUSH
48779: LD_EXP 98
48783: PPUSH
48784: LD_VAR 0 1
48788: PPUSH
48789: LD_VAR 0 2
48793: PPUSH
48794: CALL_OW 1
48798: ST_TO_ADDR
// end ;
48799: LD_VAR 0 3
48803: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
48804: LD_INT 0
48806: PPUSH
// if not mc_bases or not base or not teleports_exit then
48807: LD_EXP 80
48811: NOT
48812: IFTRUE 48821
48814: PUSH
48815: LD_VAR 0 1
48819: NOT
48820: OR
48821: IFTRUE 48830
48823: PUSH
48824: LD_VAR 0 2
48828: NOT
48829: OR
48830: IFFALSE 48834
// exit ;
48832: GO 48859
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
48834: LD_ADDR_EXP 115
48838: PUSH
48839: LD_EXP 115
48843: PPUSH
48844: LD_VAR 0 1
48848: PPUSH
48849: LD_VAR 0 2
48853: PPUSH
48854: CALL_OW 1
48858: ST_TO_ADDR
// end ;
48859: LD_VAR 0 3
48863: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
48864: LD_INT 0
48866: PPUSH
48867: PPUSH
48868: PPUSH
// if not mc_bases or not base or not ext_list then
48869: LD_EXP 80
48873: NOT
48874: IFTRUE 48883
48876: PUSH
48877: LD_VAR 0 1
48881: NOT
48882: OR
48883: IFTRUE 48892
48885: PUSH
48886: LD_VAR 0 5
48890: NOT
48891: OR
48892: IFFALSE 48896
// exit ;
48894: GO 49069
// tmp := GetFacExtXYD ( x , y , d ) ;
48896: LD_ADDR_VAR 0 8
48900: PUSH
48901: LD_VAR 0 2
48905: PPUSH
48906: LD_VAR 0 3
48910: PPUSH
48911: LD_VAR 0 4
48915: PPUSH
48916: CALL 90283 0 3
48920: ST_TO_ADDR
// if not tmp then
48921: LD_VAR 0 8
48925: NOT
48926: IFFALSE 48930
// exit ;
48928: GO 49069
// for i in tmp do
48930: LD_ADDR_VAR 0 7
48934: PUSH
48935: LD_VAR 0 8
48939: PUSH
48940: FOR_IN
48941: IFFALSE 49067
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
48943: LD_ADDR_EXP 85
48947: PUSH
48948: LD_EXP 85
48952: PPUSH
48953: LD_VAR 0 1
48957: PPUSH
48958: LD_EXP 85
48962: PUSH
48963: LD_VAR 0 1
48967: ARRAY
48968: PPUSH
48969: LD_EXP 85
48973: PUSH
48974: LD_VAR 0 1
48978: ARRAY
48979: PUSH
48980: LD_INT 1
48982: PLUS
48983: PPUSH
48984: LD_VAR 0 5
48988: PUSH
48989: LD_INT 1
48991: ARRAY
48992: PUSH
48993: LD_VAR 0 7
48997: PUSH
48998: LD_INT 1
49000: ARRAY
49001: PUSH
49002: LD_VAR 0 7
49006: PUSH
49007: LD_INT 2
49009: ARRAY
49010: PUSH
49011: LD_VAR 0 7
49015: PUSH
49016: LD_INT 3
49018: ARRAY
49019: PUSH
49020: EMPTY
49021: LIST
49022: LIST
49023: LIST
49024: LIST
49025: PPUSH
49026: CALL_OW 2
49030: PPUSH
49031: CALL_OW 1
49035: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
49036: LD_ADDR_VAR 0 5
49040: PUSH
49041: LD_VAR 0 5
49045: PPUSH
49046: LD_INT 1
49048: PPUSH
49049: CALL_OW 3
49053: ST_TO_ADDR
// if not ext_list then
49054: LD_VAR 0 5
49058: NOT
49059: IFFALSE 49065
// exit ;
49061: POP
49062: POP
49063: GO 49069
// end ;
49065: GO 48940
49067: POP
49068: POP
// end ;
49069: LD_VAR 0 6
49073: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
49074: LD_INT 0
49076: PPUSH
// if not mc_bases or not base or not weapon_list then
49077: LD_EXP 80
49081: NOT
49082: IFTRUE 49091
49084: PUSH
49085: LD_VAR 0 1
49089: NOT
49090: OR
49091: IFTRUE 49100
49093: PUSH
49094: LD_VAR 0 2
49098: NOT
49099: OR
49100: IFFALSE 49104
// exit ;
49102: GO 49129
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
49104: LD_ADDR_EXP 119
49108: PUSH
49109: LD_EXP 119
49113: PPUSH
49114: LD_VAR 0 1
49118: PPUSH
49119: LD_VAR 0 2
49123: PPUSH
49124: CALL_OW 1
49128: ST_TO_ADDR
// end ;
49129: LD_VAR 0 3
49133: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
49134: LD_INT 0
49136: PPUSH
// if not mc_bases or not base or not tech_list then
49137: LD_EXP 80
49141: NOT
49142: IFTRUE 49151
49144: PUSH
49145: LD_VAR 0 1
49149: NOT
49150: OR
49151: IFTRUE 49160
49153: PUSH
49154: LD_VAR 0 2
49158: NOT
49159: OR
49160: IFFALSE 49164
// exit ;
49162: GO 49189
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
49164: LD_ADDR_EXP 107
49168: PUSH
49169: LD_EXP 107
49173: PPUSH
49174: LD_VAR 0 1
49178: PPUSH
49179: LD_VAR 0 2
49183: PPUSH
49184: CALL_OW 1
49188: ST_TO_ADDR
// end ;
49189: LD_VAR 0 3
49193: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
49194: LD_INT 0
49196: PPUSH
// if not mc_bases or not parking_area or not base then
49197: LD_EXP 80
49201: NOT
49202: IFTRUE 49211
49204: PUSH
49205: LD_VAR 0 2
49209: NOT
49210: OR
49211: IFTRUE 49220
49213: PUSH
49214: LD_VAR 0 1
49218: NOT
49219: OR
49220: IFFALSE 49224
// exit ;
49222: GO 49249
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
49224: LD_ADDR_EXP 104
49228: PUSH
49229: LD_EXP 104
49233: PPUSH
49234: LD_VAR 0 1
49238: PPUSH
49239: LD_VAR 0 2
49243: PPUSH
49244: CALL_OW 1
49248: ST_TO_ADDR
// end ;
49249: LD_VAR 0 3
49253: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
49254: LD_INT 0
49256: PPUSH
// if not mc_bases or not base or not scan_area then
49257: LD_EXP 80
49261: NOT
49262: IFTRUE 49271
49264: PUSH
49265: LD_VAR 0 1
49269: NOT
49270: OR
49271: IFTRUE 49280
49273: PUSH
49274: LD_VAR 0 2
49278: NOT
49279: OR
49280: IFFALSE 49284
// exit ;
49282: GO 49309
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
49284: LD_ADDR_EXP 105
49288: PUSH
49289: LD_EXP 105
49293: PPUSH
49294: LD_VAR 0 1
49298: PPUSH
49299: LD_VAR 0 2
49303: PPUSH
49304: CALL_OW 1
49308: ST_TO_ADDR
// end ;
49309: LD_VAR 0 3
49313: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
49314: LD_INT 0
49316: PPUSH
49317: PPUSH
// if not mc_bases or not base then
49318: LD_EXP 80
49322: NOT
49323: IFTRUE 49332
49325: PUSH
49326: LD_VAR 0 1
49330: NOT
49331: OR
49332: IFFALSE 49336
// exit ;
49334: GO 49400
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
49336: LD_ADDR_VAR 0 3
49340: PUSH
49341: LD_INT 1
49343: PUSH
49344: LD_INT 2
49346: PUSH
49347: LD_INT 3
49349: PUSH
49350: LD_INT 4
49352: PUSH
49353: LD_INT 11
49355: PUSH
49356: EMPTY
49357: LIST
49358: LIST
49359: LIST
49360: LIST
49361: LIST
49362: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
49363: LD_ADDR_EXP 107
49367: PUSH
49368: LD_EXP 107
49372: PPUSH
49373: LD_VAR 0 1
49377: PPUSH
49378: LD_EXP 107
49382: PUSH
49383: LD_VAR 0 1
49387: ARRAY
49388: PUSH
49389: LD_VAR 0 3
49393: DIFF
49394: PPUSH
49395: CALL_OW 1
49399: ST_TO_ADDR
// end ;
49400: LD_VAR 0 2
49404: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
49405: LD_INT 0
49407: PPUSH
// result := mc_vehicles [ base ] ;
49408: LD_ADDR_VAR 0 3
49412: PUSH
49413: LD_EXP 99
49417: PUSH
49418: LD_VAR 0 1
49422: ARRAY
49423: ST_TO_ADDR
// if onlyCombat then
49424: LD_VAR 0 2
49428: IFFALSE 49600
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
49430: LD_ADDR_VAR 0 3
49434: PUSH
49435: LD_VAR 0 3
49439: PUSH
49440: LD_VAR 0 3
49444: PPUSH
49445: LD_INT 2
49447: PUSH
49448: LD_INT 34
49450: PUSH
49451: LD_INT 12
49453: PUSH
49454: EMPTY
49455: LIST
49456: LIST
49457: PUSH
49458: LD_INT 34
49460: PUSH
49461: LD_INT 51
49463: PUSH
49464: EMPTY
49465: LIST
49466: LIST
49467: PUSH
49468: LD_INT 34
49470: PUSH
49471: LD_INT 89
49473: PUSH
49474: EMPTY
49475: LIST
49476: LIST
49477: PUSH
49478: LD_INT 34
49480: PUSH
49481: LD_INT 32
49483: PUSH
49484: EMPTY
49485: LIST
49486: LIST
49487: PUSH
49488: LD_INT 34
49490: PUSH
49491: LD_INT 13
49493: PUSH
49494: EMPTY
49495: LIST
49496: LIST
49497: PUSH
49498: LD_INT 34
49500: PUSH
49501: LD_INT 52
49503: PUSH
49504: EMPTY
49505: LIST
49506: LIST
49507: PUSH
49508: LD_INT 34
49510: PUSH
49511: LD_INT 88
49513: PUSH
49514: EMPTY
49515: LIST
49516: LIST
49517: PUSH
49518: LD_INT 34
49520: PUSH
49521: LD_INT 14
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: PUSH
49528: LD_INT 34
49530: PUSH
49531: LD_INT 53
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: PUSH
49538: LD_INT 34
49540: PUSH
49541: LD_INT 98
49543: PUSH
49544: EMPTY
49545: LIST
49546: LIST
49547: PUSH
49548: LD_INT 34
49550: PUSH
49551: LD_INT 31
49553: PUSH
49554: EMPTY
49555: LIST
49556: LIST
49557: PUSH
49558: LD_INT 34
49560: PUSH
49561: LD_INT 48
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PUSH
49568: LD_INT 34
49570: PUSH
49571: LD_INT 8
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: LIST
49582: LIST
49583: LIST
49584: LIST
49585: LIST
49586: LIST
49587: LIST
49588: LIST
49589: LIST
49590: LIST
49591: LIST
49592: LIST
49593: PPUSH
49594: CALL_OW 72
49598: DIFF
49599: ST_TO_ADDR
// end ; end_of_file
49600: LD_VAR 0 3
49604: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
49605: LD_INT 0
49607: PPUSH
49608: PPUSH
49609: PPUSH
// if not mc_bases or not skirmish then
49610: LD_EXP 80
49614: NOT
49615: IFTRUE 49624
49617: PUSH
49618: LD_EXP 78
49622: NOT
49623: OR
49624: IFFALSE 49628
// exit ;
49626: GO 49793
// for i = 1 to mc_bases do
49628: LD_ADDR_VAR 0 4
49632: PUSH
49633: DOUBLE
49634: LD_INT 1
49636: DEC
49637: ST_TO_ADDR
49638: LD_EXP 80
49642: PUSH
49643: FOR_TO
49644: IFFALSE 49791
// begin if sci in mc_bases [ i ] then
49646: LD_VAR 0 2
49650: PUSH
49651: LD_EXP 80
49655: PUSH
49656: LD_VAR 0 4
49660: ARRAY
49661: IN
49662: IFFALSE 49789
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
49664: LD_ADDR_EXP 109
49668: PUSH
49669: LD_EXP 109
49673: PPUSH
49674: LD_VAR 0 4
49678: PUSH
49679: LD_EXP 109
49683: PUSH
49684: LD_VAR 0 4
49688: ARRAY
49689: PUSH
49690: LD_INT 1
49692: PLUS
49693: PUSH
49694: EMPTY
49695: LIST
49696: LIST
49697: PPUSH
49698: LD_VAR 0 1
49702: PPUSH
49703: CALL 59615 0 3
49707: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
49708: LD_ADDR_VAR 0 5
49712: PUSH
49713: LD_EXP 80
49717: PUSH
49718: LD_VAR 0 4
49722: ARRAY
49723: PPUSH
49724: LD_INT 2
49726: PUSH
49727: LD_INT 30
49729: PUSH
49730: LD_INT 0
49732: PUSH
49733: EMPTY
49734: LIST
49735: LIST
49736: PUSH
49737: LD_INT 30
49739: PUSH
49740: LD_INT 1
49742: PUSH
49743: EMPTY
49744: LIST
49745: LIST
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: LIST
49751: PPUSH
49752: CALL_OW 72
49756: PPUSH
49757: LD_VAR 0 1
49761: PPUSH
49762: CALL_OW 74
49766: ST_TO_ADDR
// if tmp then
49767: LD_VAR 0 5
49771: IFFALSE 49787
// ComStandNearbyBuilding ( ape , tmp ) ;
49773: LD_VAR 0 1
49777: PPUSH
49778: LD_VAR 0 5
49782: PPUSH
49783: CALL 56157 0 2
// break ;
49787: GO 49791
// end ; end ;
49789: GO 49643
49791: POP
49792: POP
// end ;
49793: LD_VAR 0 3
49797: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
49798: LD_INT 0
49800: PPUSH
49801: PPUSH
49802: PPUSH
// if not mc_bases or not skirmish then
49803: LD_EXP 80
49807: NOT
49808: IFTRUE 49817
49810: PUSH
49811: LD_EXP 78
49815: NOT
49816: OR
49817: IFFALSE 49821
// exit ;
49819: GO 49910
// for i = 1 to mc_bases do
49821: LD_ADDR_VAR 0 4
49825: PUSH
49826: DOUBLE
49827: LD_INT 1
49829: DEC
49830: ST_TO_ADDR
49831: LD_EXP 80
49835: PUSH
49836: FOR_TO
49837: IFFALSE 49908
// begin if building in mc_busy_turret_list [ i ] then
49839: LD_VAR 0 1
49843: PUSH
49844: LD_EXP 90
49848: PUSH
49849: LD_VAR 0 4
49853: ARRAY
49854: IN
49855: IFFALSE 49906
// begin tmp := mc_busy_turret_list [ i ] diff building ;
49857: LD_ADDR_VAR 0 5
49861: PUSH
49862: LD_EXP 90
49866: PUSH
49867: LD_VAR 0 4
49871: ARRAY
49872: PUSH
49873: LD_VAR 0 1
49877: DIFF
49878: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
49879: LD_ADDR_EXP 90
49883: PUSH
49884: LD_EXP 90
49888: PPUSH
49889: LD_VAR 0 4
49893: PPUSH
49894: LD_VAR 0 5
49898: PPUSH
49899: CALL_OW 1
49903: ST_TO_ADDR
// break ;
49904: GO 49908
// end ; end ;
49906: GO 49836
49908: POP
49909: POP
// end ;
49910: LD_VAR 0 3
49914: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
49915: LD_INT 0
49917: PPUSH
49918: PPUSH
49919: PPUSH
// if not mc_bases or not skirmish then
49920: LD_EXP 80
49924: NOT
49925: IFTRUE 49934
49927: PUSH
49928: LD_EXP 78
49932: NOT
49933: OR
49934: IFFALSE 49938
// exit ;
49936: GO 50137
// for i = 1 to mc_bases do
49938: LD_ADDR_VAR 0 5
49942: PUSH
49943: DOUBLE
49944: LD_INT 1
49946: DEC
49947: ST_TO_ADDR
49948: LD_EXP 80
49952: PUSH
49953: FOR_TO
49954: IFFALSE 50135
// if building in mc_bases [ i ] then
49956: LD_VAR 0 1
49960: PUSH
49961: LD_EXP 80
49965: PUSH
49966: LD_VAR 0 5
49970: ARRAY
49971: IN
49972: IFFALSE 50133
// begin tmp := mc_bases [ i ] diff building ;
49974: LD_ADDR_VAR 0 6
49978: PUSH
49979: LD_EXP 80
49983: PUSH
49984: LD_VAR 0 5
49988: ARRAY
49989: PUSH
49990: LD_VAR 0 1
49994: DIFF
49995: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
49996: LD_ADDR_EXP 80
50000: PUSH
50001: LD_EXP 80
50005: PPUSH
50006: LD_VAR 0 5
50010: PPUSH
50011: LD_VAR 0 6
50015: PPUSH
50016: CALL_OW 1
50020: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
50021: LD_VAR 0 1
50025: PUSH
50026: LD_EXP 88
50030: PUSH
50031: LD_VAR 0 5
50035: ARRAY
50036: IN
50037: IFFALSE 50076
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
50039: LD_ADDR_EXP 88
50043: PUSH
50044: LD_EXP 88
50048: PPUSH
50049: LD_VAR 0 5
50053: PPUSH
50054: LD_EXP 88
50058: PUSH
50059: LD_VAR 0 5
50063: ARRAY
50064: PUSH
50065: LD_VAR 0 1
50069: DIFF
50070: PPUSH
50071: CALL_OW 1
50075: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
50076: LD_VAR 0 1
50080: PUSH
50081: LD_EXP 89
50085: PUSH
50086: LD_VAR 0 5
50090: ARRAY
50091: IN
50092: IFFALSE 50131
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
50094: LD_ADDR_EXP 89
50098: PUSH
50099: LD_EXP 89
50103: PPUSH
50104: LD_VAR 0 5
50108: PPUSH
50109: LD_EXP 89
50113: PUSH
50114: LD_VAR 0 5
50118: ARRAY
50119: PUSH
50120: LD_VAR 0 1
50124: DIFF
50125: PPUSH
50126: CALL_OW 1
50130: ST_TO_ADDR
// break ;
50131: GO 50135
// end ;
50133: GO 49953
50135: POP
50136: POP
// end ;
50137: LD_VAR 0 4
50141: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
50142: LD_INT 0
50144: PPUSH
50145: PPUSH
50146: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
50147: LD_EXP 80
50151: NOT
50152: IFTRUE 50161
50154: PUSH
50155: LD_EXP 78
50159: NOT
50160: OR
50161: IFTRUE 50176
50163: PUSH
50164: LD_VAR 0 3
50168: PUSH
50169: LD_EXP 106
50173: IN
50174: NOT
50175: OR
50176: IFFALSE 50180
// exit ;
50178: GO 50305
// for i = 1 to mc_vehicles do
50180: LD_ADDR_VAR 0 6
50184: PUSH
50185: DOUBLE
50186: LD_INT 1
50188: DEC
50189: ST_TO_ADDR
50190: LD_EXP 99
50194: PUSH
50195: FOR_TO
50196: IFFALSE 50303
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
50198: LD_VAR 0 2
50202: PUSH
50203: LD_EXP 99
50207: PUSH
50208: LD_VAR 0 6
50212: ARRAY
50213: IN
50214: IFTRUE 50234
50216: PUSH
50217: LD_VAR 0 1
50221: PUSH
50222: LD_EXP 99
50226: PUSH
50227: LD_VAR 0 6
50231: ARRAY
50232: IN
50233: OR
50234: IFFALSE 50301
// begin tmp := mc_vehicles [ i ] diff old ;
50236: LD_ADDR_VAR 0 7
50240: PUSH
50241: LD_EXP 99
50245: PUSH
50246: LD_VAR 0 6
50250: ARRAY
50251: PUSH
50252: LD_VAR 0 2
50256: DIFF
50257: ST_TO_ADDR
// tmp := tmp diff new ;
50258: LD_ADDR_VAR 0 7
50262: PUSH
50263: LD_VAR 0 7
50267: PUSH
50268: LD_VAR 0 1
50272: DIFF
50273: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
50274: LD_ADDR_EXP 99
50278: PUSH
50279: LD_EXP 99
50283: PPUSH
50284: LD_VAR 0 6
50288: PPUSH
50289: LD_VAR 0 7
50293: PPUSH
50294: CALL_OW 1
50298: ST_TO_ADDR
// break ;
50299: GO 50303
// end ;
50301: GO 50195
50303: POP
50304: POP
// end ;
50305: LD_VAR 0 5
50309: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
50310: LD_INT 0
50312: PPUSH
50313: PPUSH
50314: PPUSH
50315: PPUSH
// if not mc_bases or not skirmish then
50316: LD_EXP 80
50320: NOT
50321: IFTRUE 50330
50323: PUSH
50324: LD_EXP 78
50328: NOT
50329: OR
50330: IFFALSE 50334
// exit ;
50332: GO 50756
// repeat wait ( 0 0$1 ) ;
50334: LD_INT 35
50336: PPUSH
50337: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
50341: LD_EXP 124
50345: NOT
50346: IFFALSE 50334
// mc_block_vehicle_constructed_thread := true ;
50348: LD_ADDR_EXP 124
50352: PUSH
50353: LD_INT 1
50355: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
50356: LD_ADDR_VAR 0 5
50360: PUSH
50361: LD_VAR 0 1
50365: PPUSH
50366: CALL_OW 255
50370: ST_TO_ADDR
// for i = 1 to mc_bases do
50371: LD_ADDR_VAR 0 4
50375: PUSH
50376: DOUBLE
50377: LD_INT 1
50379: DEC
50380: ST_TO_ADDR
50381: LD_EXP 80
50385: PUSH
50386: FOR_TO
50387: IFFALSE 50746
// begin if factory in mc_bases [ i ] then
50389: LD_VAR 0 2
50393: PUSH
50394: LD_EXP 80
50398: PUSH
50399: LD_VAR 0 4
50403: ARRAY
50404: IN
50405: IFFALSE 50744
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
50407: LD_EXP 102
50411: PUSH
50412: LD_VAR 0 4
50416: ARRAY
50417: PUSH
50418: LD_EXP 91
50422: PUSH
50423: LD_VAR 0 4
50427: ARRAY
50428: LESS
50429: IFFALSE 50518
50431: PUSH
50432: LD_VAR 0 1
50436: PPUSH
50437: CALL_OW 264
50441: PUSH
50442: LD_INT 31
50444: PUSH
50445: LD_INT 32
50447: PUSH
50448: LD_INT 51
50450: PUSH
50451: LD_INT 89
50453: PUSH
50454: LD_INT 12
50456: PUSH
50457: LD_INT 30
50459: PUSH
50460: LD_INT 98
50462: PUSH
50463: LD_INT 11
50465: PUSH
50466: LD_INT 53
50468: PUSH
50469: LD_INT 14
50471: PUSH
50472: LD_INT 91
50474: PUSH
50475: LD_INT 29
50477: PUSH
50478: LD_INT 99
50480: PUSH
50481: LD_INT 13
50483: PUSH
50484: LD_INT 52
50486: PUSH
50487: LD_INT 88
50489: PUSH
50490: LD_INT 48
50492: PUSH
50493: LD_INT 8
50495: PUSH
50496: EMPTY
50497: LIST
50498: LIST
50499: LIST
50500: LIST
50501: LIST
50502: LIST
50503: LIST
50504: LIST
50505: LIST
50506: LIST
50507: LIST
50508: LIST
50509: LIST
50510: LIST
50511: LIST
50512: LIST
50513: LIST
50514: LIST
50515: IN
50516: NOT
50517: AND
50518: IFFALSE 50566
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
50520: LD_ADDR_EXP 102
50524: PUSH
50525: LD_EXP 102
50529: PPUSH
50530: LD_VAR 0 4
50534: PUSH
50535: LD_EXP 102
50539: PUSH
50540: LD_VAR 0 4
50544: ARRAY
50545: PUSH
50546: LD_INT 1
50548: PLUS
50549: PUSH
50550: EMPTY
50551: LIST
50552: LIST
50553: PPUSH
50554: LD_VAR 0 1
50558: PPUSH
50559: CALL 59615 0 3
50563: ST_TO_ADDR
50564: GO 50610
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
50566: LD_ADDR_EXP 99
50570: PUSH
50571: LD_EXP 99
50575: PPUSH
50576: LD_VAR 0 4
50580: PUSH
50581: LD_EXP 99
50585: PUSH
50586: LD_VAR 0 4
50590: ARRAY
50591: PUSH
50592: LD_INT 1
50594: PLUS
50595: PUSH
50596: EMPTY
50597: LIST
50598: LIST
50599: PPUSH
50600: LD_VAR 0 1
50604: PPUSH
50605: CALL 59615 0 3
50609: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
50610: LD_ADDR_EXP 124
50614: PUSH
50615: LD_INT 0
50617: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
50618: LD_VAR 0 1
50622: PPUSH
50623: CALL_OW 263
50627: PUSH
50628: LD_INT 2
50630: EQUAL
50631: IFFALSE 50660
// begin repeat wait ( 0 0$3 ) ;
50633: LD_INT 105
50635: PPUSH
50636: CALL_OW 67
// Connect ( vehicle ) ;
50640: LD_VAR 0 1
50644: PPUSH
50645: CALL 62975 0 1
// until IsControledBy ( vehicle ) ;
50649: LD_VAR 0 1
50653: PPUSH
50654: CALL_OW 312
50658: IFFALSE 50633
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
50660: LD_VAR 0 1
50664: PPUSH
50665: LD_EXP 104
50669: PUSH
50670: LD_VAR 0 4
50674: ARRAY
50675: PPUSH
50676: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
50680: LD_VAR 0 1
50684: PPUSH
50685: CALL_OW 263
50689: PUSH
50690: LD_INT 1
50692: NONEQUAL
50693: IFFALSE 50697
// break ;
50695: GO 50746
// repeat wait ( 0 0$1 ) ;
50697: LD_INT 35
50699: PPUSH
50700: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
50704: LD_VAR 0 1
50708: PPUSH
50709: LD_EXP 104
50713: PUSH
50714: LD_VAR 0 4
50718: ARRAY
50719: PPUSH
50720: CALL_OW 308
50724: IFFALSE 50697
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
50726: LD_VAR 0 1
50730: PPUSH
50731: CALL_OW 311
50735: PPUSH
50736: CALL_OW 121
// exit ;
50740: POP
50741: POP
50742: GO 50756
// end ; end ;
50744: GO 50386
50746: POP
50747: POP
// mc_block_vehicle_constructed_thread := false ;
50748: LD_ADDR_EXP 124
50752: PUSH
50753: LD_INT 0
50755: ST_TO_ADDR
// end ;
50756: LD_VAR 0 3
50760: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
50761: LD_INT 0
50763: PPUSH
50764: PPUSH
50765: PPUSH
50766: PPUSH
// if not mc_bases or not skirmish then
50767: LD_EXP 80
50771: NOT
50772: IFTRUE 50781
50774: PUSH
50775: LD_EXP 78
50779: NOT
50780: OR
50781: IFFALSE 50785
// exit ;
50783: GO 51138
// repeat wait ( 0 0$1 ) ;
50785: LD_INT 35
50787: PPUSH
50788: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
50792: LD_VAR 0 2
50796: PPUSH
50797: LD_VAR 0 3
50801: PPUSH
50802: CALL_OW 284
50806: IFFALSE 50785
// if GetResourceTypeXY ( x , y ) = mat_artefact then
50808: LD_VAR 0 2
50812: PPUSH
50813: LD_VAR 0 3
50817: PPUSH
50818: CALL_OW 283
50822: PUSH
50823: LD_INT 4
50825: EQUAL
50826: IFFALSE 50830
// exit ;
50828: GO 51138
// for i = 1 to mc_bases do
50830: LD_ADDR_VAR 0 7
50834: PUSH
50835: DOUBLE
50836: LD_INT 1
50838: DEC
50839: ST_TO_ADDR
50840: LD_EXP 80
50844: PUSH
50845: FOR_TO
50846: IFFALSE 51136
// begin if mc_crates_area [ i ] then
50848: LD_EXP 98
50852: PUSH
50853: LD_VAR 0 7
50857: ARRAY
50858: IFFALSE 50969
// for j in mc_crates_area [ i ] do
50860: LD_ADDR_VAR 0 8
50864: PUSH
50865: LD_EXP 98
50869: PUSH
50870: LD_VAR 0 7
50874: ARRAY
50875: PUSH
50876: FOR_IN
50877: IFFALSE 50967
// if InArea ( x , y , j ) then
50879: LD_VAR 0 2
50883: PPUSH
50884: LD_VAR 0 3
50888: PPUSH
50889: LD_VAR 0 8
50893: PPUSH
50894: CALL_OW 309
50898: IFFALSE 50965
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50900: LD_ADDR_EXP 96
50904: PUSH
50905: LD_EXP 96
50909: PPUSH
50910: LD_VAR 0 7
50914: PUSH
50915: LD_EXP 96
50919: PUSH
50920: LD_VAR 0 7
50924: ARRAY
50925: PUSH
50926: LD_INT 1
50928: PLUS
50929: PUSH
50930: EMPTY
50931: LIST
50932: LIST
50933: PPUSH
50934: LD_VAR 0 4
50938: PUSH
50939: LD_VAR 0 2
50943: PUSH
50944: LD_VAR 0 3
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: LIST
50953: PPUSH
50954: CALL 59615 0 3
50958: ST_TO_ADDR
// exit ;
50959: POP
50960: POP
50961: POP
50962: POP
50963: GO 51138
// end ;
50965: GO 50876
50967: POP
50968: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50969: LD_ADDR_VAR 0 9
50973: PUSH
50974: LD_EXP 80
50978: PUSH
50979: LD_VAR 0 7
50983: ARRAY
50984: PPUSH
50985: LD_INT 2
50987: PUSH
50988: LD_INT 30
50990: PUSH
50991: LD_INT 0
50993: PUSH
50994: EMPTY
50995: LIST
50996: LIST
50997: PUSH
50998: LD_INT 30
51000: PUSH
51001: LD_INT 1
51003: PUSH
51004: EMPTY
51005: LIST
51006: LIST
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: LIST
51012: PPUSH
51013: CALL_OW 72
51017: ST_TO_ADDR
// if not depot then
51018: LD_VAR 0 9
51022: NOT
51023: IFFALSE 51027
// continue ;
51025: GO 50845
// for j in depot do
51027: LD_ADDR_VAR 0 8
51031: PUSH
51032: LD_VAR 0 9
51036: PUSH
51037: FOR_IN
51038: IFFALSE 51132
// if GetDistUnitXY ( j , x , y ) < 30 then
51040: LD_VAR 0 8
51044: PPUSH
51045: LD_VAR 0 2
51049: PPUSH
51050: LD_VAR 0 3
51054: PPUSH
51055: CALL_OW 297
51059: PUSH
51060: LD_INT 30
51062: LESS
51063: IFFALSE 51130
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
51065: LD_ADDR_EXP 96
51069: PUSH
51070: LD_EXP 96
51074: PPUSH
51075: LD_VAR 0 7
51079: PUSH
51080: LD_EXP 96
51084: PUSH
51085: LD_VAR 0 7
51089: ARRAY
51090: PUSH
51091: LD_INT 1
51093: PLUS
51094: PUSH
51095: EMPTY
51096: LIST
51097: LIST
51098: PPUSH
51099: LD_VAR 0 4
51103: PUSH
51104: LD_VAR 0 2
51108: PUSH
51109: LD_VAR 0 3
51113: PUSH
51114: EMPTY
51115: LIST
51116: LIST
51117: LIST
51118: PPUSH
51119: CALL 59615 0 3
51123: ST_TO_ADDR
// exit ;
51124: POP
51125: POP
51126: POP
51127: POP
51128: GO 51138
// end ;
51130: GO 51037
51132: POP
51133: POP
// end ;
51134: GO 50845
51136: POP
51137: POP
// end ;
51138: LD_VAR 0 6
51142: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
51143: LD_INT 0
51145: PPUSH
51146: PPUSH
51147: PPUSH
51148: PPUSH
// if not mc_bases or not skirmish then
51149: LD_EXP 80
51153: NOT
51154: IFTRUE 51163
51156: PUSH
51157: LD_EXP 78
51161: NOT
51162: OR
51163: IFFALSE 51167
// exit ;
51165: GO 51450
// side := GetSide ( lab ) ;
51167: LD_ADDR_VAR 0 4
51171: PUSH
51172: LD_VAR 0 2
51176: PPUSH
51177: CALL_OW 255
51181: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
51182: LD_VAR 0 4
51186: PUSH
51187: LD_EXP 106
51191: IN
51192: NOT
51193: IFTRUE 51202
51195: PUSH
51196: LD_EXP 107
51200: NOT
51201: OR
51202: IFTRUE 51211
51204: PUSH
51205: LD_EXP 80
51209: NOT
51210: OR
51211: IFFALSE 51215
// exit ;
51213: GO 51450
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
51215: LD_ADDR_EXP 107
51219: PUSH
51220: LD_EXP 107
51224: PPUSH
51225: LD_VAR 0 4
51229: PPUSH
51230: LD_EXP 107
51234: PUSH
51235: LD_VAR 0 4
51239: ARRAY
51240: PUSH
51241: LD_VAR 0 1
51245: DIFF
51246: PPUSH
51247: CALL_OW 1
51251: ST_TO_ADDR
// for i = 1 to mc_bases do
51252: LD_ADDR_VAR 0 5
51256: PUSH
51257: DOUBLE
51258: LD_INT 1
51260: DEC
51261: ST_TO_ADDR
51262: LD_EXP 80
51266: PUSH
51267: FOR_TO
51268: IFFALSE 51448
// begin if lab in mc_bases [ i ] then
51270: LD_VAR 0 2
51274: PUSH
51275: LD_EXP 80
51279: PUSH
51280: LD_VAR 0 5
51284: ARRAY
51285: IN
51286: IFFALSE 51446
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
51288: LD_VAR 0 1
51292: PUSH
51293: LD_INT 11
51295: PUSH
51296: LD_INT 4
51298: PUSH
51299: LD_INT 3
51301: PUSH
51302: LD_INT 2
51304: PUSH
51305: EMPTY
51306: LIST
51307: LIST
51308: LIST
51309: LIST
51310: IN
51311: IFFALSE 51325
51313: PUSH
51314: LD_EXP 110
51318: PUSH
51319: LD_VAR 0 5
51323: ARRAY
51324: AND
51325: IFFALSE 51446
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
51327: LD_ADDR_VAR 0 6
51331: PUSH
51332: LD_EXP 110
51336: PUSH
51337: LD_VAR 0 5
51341: ARRAY
51342: PUSH
51343: LD_INT 1
51345: ARRAY
51346: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
51347: LD_ADDR_EXP 110
51351: PUSH
51352: LD_EXP 110
51356: PPUSH
51357: LD_VAR 0 5
51361: PPUSH
51362: EMPTY
51363: PPUSH
51364: CALL_OW 1
51368: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
51369: LD_VAR 0 6
51373: PPUSH
51374: LD_INT 0
51376: PPUSH
51377: CALL_OW 109
// ComExitBuilding ( tmp ) ;
51381: LD_VAR 0 6
51385: PPUSH
51386: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
51390: LD_ADDR_EXP 109
51394: PUSH
51395: LD_EXP 109
51399: PPUSH
51400: LD_VAR 0 5
51404: PPUSH
51405: LD_EXP 109
51409: PUSH
51410: LD_VAR 0 5
51414: ARRAY
51415: PPUSH
51416: LD_INT 1
51418: PPUSH
51419: LD_VAR 0 6
51423: PPUSH
51424: CALL_OW 2
51428: PPUSH
51429: CALL_OW 1
51433: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
51434: LD_VAR 0 5
51438: PPUSH
51439: LD_INT 112
51441: PPUSH
51442: CALL 27580 0 2
// end ; end ; end ;
51446: GO 51267
51448: POP
51449: POP
// end ;
51450: LD_VAR 0 3
51454: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
51455: LD_INT 0
51457: PPUSH
51458: PPUSH
51459: PPUSH
51460: PPUSH
51461: PPUSH
51462: PPUSH
51463: PPUSH
51464: PPUSH
// if not mc_bases or not skirmish then
51465: LD_EXP 80
51469: NOT
51470: IFTRUE 51479
51472: PUSH
51473: LD_EXP 78
51477: NOT
51478: OR
51479: IFFALSE 51483
// exit ;
51481: GO 52868
// for i = 1 to mc_bases do
51483: LD_ADDR_VAR 0 3
51487: PUSH
51488: DOUBLE
51489: LD_INT 1
51491: DEC
51492: ST_TO_ADDR
51493: LD_EXP 80
51497: PUSH
51498: FOR_TO
51499: IFFALSE 52866
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
51501: LD_VAR 0 1
51505: PUSH
51506: LD_EXP 80
51510: PUSH
51511: LD_VAR 0 3
51515: ARRAY
51516: IN
51517: IFTRUE 51537
51519: PUSH
51520: LD_VAR 0 1
51524: PUSH
51525: LD_EXP 87
51529: PUSH
51530: LD_VAR 0 3
51534: ARRAY
51535: IN
51536: OR
51537: IFTRUE 51557
51539: PUSH
51540: LD_VAR 0 1
51544: PUSH
51545: LD_EXP 102
51549: PUSH
51550: LD_VAR 0 3
51554: ARRAY
51555: IN
51556: OR
51557: IFTRUE 51577
51559: PUSH
51560: LD_VAR 0 1
51564: PUSH
51565: LD_EXP 99
51569: PUSH
51570: LD_VAR 0 3
51574: ARRAY
51575: IN
51576: OR
51577: IFTRUE 51597
51579: PUSH
51580: LD_VAR 0 1
51584: PUSH
51585: LD_EXP 109
51589: PUSH
51590: LD_VAR 0 3
51594: ARRAY
51595: IN
51596: OR
51597: IFTRUE 51617
51599: PUSH
51600: LD_VAR 0 1
51604: PUSH
51605: LD_EXP 110
51609: PUSH
51610: LD_VAR 0 3
51614: ARRAY
51615: IN
51616: OR
51617: IFFALSE 52864
// begin if un in mc_ape [ i ] then
51619: LD_VAR 0 1
51623: PUSH
51624: LD_EXP 109
51628: PUSH
51629: LD_VAR 0 3
51633: ARRAY
51634: IN
51635: IFFALSE 51674
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
51637: LD_ADDR_EXP 109
51641: PUSH
51642: LD_EXP 109
51646: PPUSH
51647: LD_VAR 0 3
51651: PPUSH
51652: LD_EXP 109
51656: PUSH
51657: LD_VAR 0 3
51661: ARRAY
51662: PUSH
51663: LD_VAR 0 1
51667: DIFF
51668: PPUSH
51669: CALL_OW 1
51673: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
51674: LD_VAR 0 1
51678: PUSH
51679: LD_EXP 110
51683: PUSH
51684: LD_VAR 0 3
51688: ARRAY
51689: IN
51690: IFFALSE 51714
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
51692: LD_ADDR_EXP 110
51696: PUSH
51697: LD_EXP 110
51701: PPUSH
51702: LD_VAR 0 3
51706: PPUSH
51707: EMPTY
51708: PPUSH
51709: CALL_OW 1
51713: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
51714: LD_VAR 0 1
51718: PPUSH
51719: CALL_OW 247
51723: PUSH
51724: LD_INT 2
51726: EQUAL
51727: IFFALSE 51808
51729: PUSH
51730: LD_VAR 0 1
51734: PPUSH
51735: CALL_OW 110
51739: PUSH
51740: LD_INT 20
51742: EQUAL
51743: IFTRUE 51763
51745: PUSH
51746: LD_VAR 0 1
51750: PUSH
51751: LD_EXP 102
51755: PUSH
51756: LD_VAR 0 3
51760: ARRAY
51761: IN
51762: OR
51763: IFTRUE 51807
51765: PUSH
51766: LD_VAR 0 1
51770: PPUSH
51771: CALL_OW 264
51775: PUSH
51776: LD_INT 12
51778: PUSH
51779: LD_INT 51
51781: PUSH
51782: LD_INT 89
51784: PUSH
51785: LD_INT 32
51787: PUSH
51788: LD_INT 13
51790: PUSH
51791: LD_INT 52
51793: PUSH
51794: LD_INT 31
51796: PUSH
51797: EMPTY
51798: LIST
51799: LIST
51800: LIST
51801: LIST
51802: LIST
51803: LIST
51804: LIST
51805: IN
51806: OR
51807: AND
51808: IFFALSE 52116
// begin if un in mc_defender [ i ] then
51810: LD_VAR 0 1
51814: PUSH
51815: LD_EXP 102
51819: PUSH
51820: LD_VAR 0 3
51824: ARRAY
51825: IN
51826: IFFALSE 51865
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51828: LD_ADDR_EXP 102
51832: PUSH
51833: LD_EXP 102
51837: PPUSH
51838: LD_VAR 0 3
51842: PPUSH
51843: LD_EXP 102
51847: PUSH
51848: LD_VAR 0 3
51852: ARRAY
51853: PUSH
51854: LD_VAR 0 1
51858: DIFF
51859: PPUSH
51860: CALL_OW 1
51864: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
51865: LD_ADDR_VAR 0 8
51869: PUSH
51870: LD_VAR 0 3
51874: PPUSH
51875: LD_INT 3
51877: PPUSH
51878: CALL 48404 0 2
51882: ST_TO_ADDR
// if fac then
51883: LD_VAR 0 8
51887: IFFALSE 52116
// begin for j in fac do
51889: LD_ADDR_VAR 0 4
51893: PUSH
51894: LD_VAR 0 8
51898: PUSH
51899: FOR_IN
51900: IFFALSE 52114
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
51902: LD_ADDR_VAR 0 9
51906: PUSH
51907: LD_VAR 0 8
51911: PPUSH
51912: LD_VAR 0 1
51916: PPUSH
51917: CALL_OW 265
51921: PPUSH
51922: LD_VAR 0 1
51926: PPUSH
51927: CALL_OW 262
51931: PPUSH
51932: LD_VAR 0 1
51936: PPUSH
51937: CALL_OW 263
51941: PPUSH
51942: LD_VAR 0 1
51946: PPUSH
51947: CALL_OW 264
51951: PPUSH
51952: CALL 57055 0 5
51956: ST_TO_ADDR
// if components then
51957: LD_VAR 0 9
51961: IFFALSE 52112
// begin if GetWeapon ( un ) = ar_control_tower then
51963: LD_VAR 0 1
51967: PPUSH
51968: CALL_OW 264
51972: PUSH
51973: LD_INT 31
51975: EQUAL
51976: IFFALSE 52093
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
51978: LD_VAR 0 1
51982: PPUSH
51983: CALL_OW 311
51987: PPUSH
51988: LD_INT 0
51990: PPUSH
51991: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
51995: LD_ADDR_EXP 120
51999: PUSH
52000: LD_EXP 120
52004: PPUSH
52005: LD_VAR 0 3
52009: PPUSH
52010: LD_EXP 120
52014: PUSH
52015: LD_VAR 0 3
52019: ARRAY
52020: PUSH
52021: LD_VAR 0 1
52025: PPUSH
52026: CALL_OW 311
52030: DIFF
52031: PPUSH
52032: CALL_OW 1
52036: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
52037: LD_ADDR_VAR 0 7
52041: PUSH
52042: LD_EXP 101
52046: PUSH
52047: LD_VAR 0 3
52051: ARRAY
52052: PPUSH
52053: LD_INT 1
52055: PPUSH
52056: LD_VAR 0 9
52060: PPUSH
52061: CALL_OW 2
52065: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52066: LD_ADDR_EXP 101
52070: PUSH
52071: LD_EXP 101
52075: PPUSH
52076: LD_VAR 0 3
52080: PPUSH
52081: LD_VAR 0 7
52085: PPUSH
52086: CALL_OW 1
52090: ST_TO_ADDR
// end else
52091: GO 52110
// MC_InsertProduceList ( i , [ components ] ) ;
52093: LD_VAR 0 3
52097: PPUSH
52098: LD_VAR 0 9
52102: PUSH
52103: EMPTY
52104: LIST
52105: PPUSH
52106: CALL 47949 0 2
// break ;
52110: GO 52114
// end ; end ;
52112: GO 51899
52114: POP
52115: POP
// end ; end ; if GetType ( un ) = unit_building then
52116: LD_VAR 0 1
52120: PPUSH
52121: CALL_OW 247
52125: PUSH
52126: LD_INT 3
52128: EQUAL
52129: IFFALSE 52532
// begin btype := GetBType ( un ) ;
52131: LD_ADDR_VAR 0 5
52135: PUSH
52136: LD_VAR 0 1
52140: PPUSH
52141: CALL_OW 266
52145: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
52146: LD_VAR 0 5
52150: PUSH
52151: LD_INT 29
52153: PUSH
52154: LD_INT 30
52156: PUSH
52157: EMPTY
52158: LIST
52159: LIST
52160: IN
52161: IFFALSE 52234
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
52163: LD_VAR 0 1
52167: PPUSH
52168: CALL_OW 250
52172: PPUSH
52173: LD_VAR 0 1
52177: PPUSH
52178: CALL_OW 251
52182: PPUSH
52183: LD_VAR 0 1
52187: PPUSH
52188: CALL_OW 255
52192: PPUSH
52193: CALL_OW 440
52197: NOT
52198: IFFALSE 52234
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
52200: LD_VAR 0 1
52204: PPUSH
52205: CALL_OW 250
52209: PPUSH
52210: LD_VAR 0 1
52214: PPUSH
52215: CALL_OW 251
52219: PPUSH
52220: LD_VAR 0 1
52224: PPUSH
52225: CALL_OW 255
52229: PPUSH
52230: CALL_OW 441
// end ; if btype = b_warehouse then
52234: LD_VAR 0 5
52238: PUSH
52239: LD_INT 1
52241: EQUAL
52242: IFFALSE 52260
// begin btype := b_depot ;
52244: LD_ADDR_VAR 0 5
52248: PUSH
52249: LD_INT 0
52251: ST_TO_ADDR
// pos := 1 ;
52252: LD_ADDR_VAR 0 6
52256: PUSH
52257: LD_INT 1
52259: ST_TO_ADDR
// end ; if btype = b_factory then
52260: LD_VAR 0 5
52264: PUSH
52265: LD_INT 3
52267: EQUAL
52268: IFFALSE 52286
// begin btype := b_workshop ;
52270: LD_ADDR_VAR 0 5
52274: PUSH
52275: LD_INT 2
52277: ST_TO_ADDR
// pos := 1 ;
52278: LD_ADDR_VAR 0 6
52282: PUSH
52283: LD_INT 1
52285: ST_TO_ADDR
// end ; if btype = b_barracks then
52286: LD_VAR 0 5
52290: PUSH
52291: LD_INT 5
52293: EQUAL
52294: IFFALSE 52304
// btype := b_armoury ;
52296: LD_ADDR_VAR 0 5
52300: PUSH
52301: LD_INT 4
52303: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
52304: LD_VAR 0 5
52308: PUSH
52309: LD_INT 7
52311: PUSH
52312: LD_INT 8
52314: PUSH
52315: EMPTY
52316: LIST
52317: LIST
52318: IN
52319: IFFALSE 52329
// btype := b_lab ;
52321: LD_ADDR_VAR 0 5
52325: PUSH
52326: LD_INT 6
52328: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
52329: LD_ADDR_EXP 85
52333: PUSH
52334: LD_EXP 85
52338: PPUSH
52339: LD_VAR 0 3
52343: PUSH
52344: LD_EXP 85
52348: PUSH
52349: LD_VAR 0 3
52353: ARRAY
52354: PUSH
52355: LD_INT 1
52357: PLUS
52358: PUSH
52359: EMPTY
52360: LIST
52361: LIST
52362: PPUSH
52363: LD_VAR 0 5
52367: PUSH
52368: LD_VAR 0 1
52372: PPUSH
52373: CALL_OW 250
52377: PUSH
52378: LD_VAR 0 1
52382: PPUSH
52383: CALL_OW 251
52387: PUSH
52388: LD_VAR 0 1
52392: PPUSH
52393: CALL_OW 254
52397: PUSH
52398: EMPTY
52399: LIST
52400: LIST
52401: LIST
52402: LIST
52403: PPUSH
52404: CALL 59615 0 3
52408: ST_TO_ADDR
// if pos = 1 then
52409: LD_VAR 0 6
52413: PUSH
52414: LD_INT 1
52416: EQUAL
52417: IFFALSE 52532
// begin tmp := mc_build_list [ i ] ;
52419: LD_ADDR_VAR 0 7
52423: PUSH
52424: LD_EXP 85
52428: PUSH
52429: LD_VAR 0 3
52433: ARRAY
52434: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
52435: LD_VAR 0 7
52439: PPUSH
52440: LD_INT 2
52442: PUSH
52443: LD_INT 30
52445: PUSH
52446: LD_INT 0
52448: PUSH
52449: EMPTY
52450: LIST
52451: LIST
52452: PUSH
52453: LD_INT 30
52455: PUSH
52456: LD_INT 1
52458: PUSH
52459: EMPTY
52460: LIST
52461: LIST
52462: PUSH
52463: EMPTY
52464: LIST
52465: LIST
52466: LIST
52467: PPUSH
52468: CALL_OW 72
52472: IFFALSE 52482
// pos := 2 ;
52474: LD_ADDR_VAR 0 6
52478: PUSH
52479: LD_INT 2
52481: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
52482: LD_ADDR_VAR 0 7
52486: PUSH
52487: LD_VAR 0 7
52491: PPUSH
52492: LD_VAR 0 6
52496: PPUSH
52497: LD_VAR 0 7
52501: PPUSH
52502: CALL 59941 0 3
52506: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
52507: LD_ADDR_EXP 85
52511: PUSH
52512: LD_EXP 85
52516: PPUSH
52517: LD_VAR 0 3
52521: PPUSH
52522: LD_VAR 0 7
52526: PPUSH
52527: CALL_OW 1
52531: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
52532: LD_VAR 0 1
52536: PUSH
52537: LD_EXP 80
52541: PUSH
52542: LD_VAR 0 3
52546: ARRAY
52547: IN
52548: IFFALSE 52587
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
52550: LD_ADDR_EXP 80
52554: PUSH
52555: LD_EXP 80
52559: PPUSH
52560: LD_VAR 0 3
52564: PPUSH
52565: LD_EXP 80
52569: PUSH
52570: LD_VAR 0 3
52574: ARRAY
52575: PUSH
52576: LD_VAR 0 1
52580: DIFF
52581: PPUSH
52582: CALL_OW 1
52586: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
52587: LD_VAR 0 1
52591: PUSH
52592: LD_EXP 87
52596: PUSH
52597: LD_VAR 0 3
52601: ARRAY
52602: IN
52603: IFFALSE 52642
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
52605: LD_ADDR_EXP 87
52609: PUSH
52610: LD_EXP 87
52614: PPUSH
52615: LD_VAR 0 3
52619: PPUSH
52620: LD_EXP 87
52624: PUSH
52625: LD_VAR 0 3
52629: ARRAY
52630: PUSH
52631: LD_VAR 0 1
52635: DIFF
52636: PPUSH
52637: CALL_OW 1
52641: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
52642: LD_VAR 0 1
52646: PUSH
52647: LD_EXP 99
52651: PUSH
52652: LD_VAR 0 3
52656: ARRAY
52657: IN
52658: IFFALSE 52697
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
52660: LD_ADDR_EXP 99
52664: PUSH
52665: LD_EXP 99
52669: PPUSH
52670: LD_VAR 0 3
52674: PPUSH
52675: LD_EXP 99
52679: PUSH
52680: LD_VAR 0 3
52684: ARRAY
52685: PUSH
52686: LD_VAR 0 1
52690: DIFF
52691: PPUSH
52692: CALL_OW 1
52696: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
52697: LD_VAR 0 1
52701: PUSH
52702: LD_EXP 102
52706: PUSH
52707: LD_VAR 0 3
52711: ARRAY
52712: IN
52713: IFFALSE 52752
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
52715: LD_ADDR_EXP 102
52719: PUSH
52720: LD_EXP 102
52724: PPUSH
52725: LD_VAR 0 3
52729: PPUSH
52730: LD_EXP 102
52734: PUSH
52735: LD_VAR 0 3
52739: ARRAY
52740: PUSH
52741: LD_VAR 0 1
52745: DIFF
52746: PPUSH
52747: CALL_OW 1
52751: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
52752: LD_VAR 0 1
52756: PUSH
52757: LD_EXP 89
52761: PUSH
52762: LD_VAR 0 3
52766: ARRAY
52767: IN
52768: IFFALSE 52807
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
52770: LD_ADDR_EXP 89
52774: PUSH
52775: LD_EXP 89
52779: PPUSH
52780: LD_VAR 0 3
52784: PPUSH
52785: LD_EXP 89
52789: PUSH
52790: LD_VAR 0 3
52794: ARRAY
52795: PUSH
52796: LD_VAR 0 1
52800: DIFF
52801: PPUSH
52802: CALL_OW 1
52806: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
52807: LD_VAR 0 1
52811: PUSH
52812: LD_EXP 88
52816: PUSH
52817: LD_VAR 0 3
52821: ARRAY
52822: IN
52823: IFFALSE 52862
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
52825: LD_ADDR_EXP 88
52829: PUSH
52830: LD_EXP 88
52834: PPUSH
52835: LD_VAR 0 3
52839: PPUSH
52840: LD_EXP 88
52844: PUSH
52845: LD_VAR 0 3
52849: ARRAY
52850: PUSH
52851: LD_VAR 0 1
52855: DIFF
52856: PPUSH
52857: CALL_OW 1
52861: ST_TO_ADDR
// end ; break ;
52862: GO 52866
// end ;
52864: GO 51498
52866: POP
52867: POP
// end ;
52868: LD_VAR 0 2
52872: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
52873: LD_INT 0
52875: PPUSH
52876: PPUSH
52877: PPUSH
// if not mc_bases or not skirmish then
52878: LD_EXP 80
52882: NOT
52883: IFTRUE 52892
52885: PUSH
52886: LD_EXP 78
52890: NOT
52891: OR
52892: IFFALSE 52896
// exit ;
52894: GO 53111
// for i = 1 to mc_bases do
52896: LD_ADDR_VAR 0 3
52900: PUSH
52901: DOUBLE
52902: LD_INT 1
52904: DEC
52905: ST_TO_ADDR
52906: LD_EXP 80
52910: PUSH
52911: FOR_TO
52912: IFFALSE 53109
// begin if building in mc_construct_list [ i ] then
52914: LD_VAR 0 1
52918: PUSH
52919: LD_EXP 87
52923: PUSH
52924: LD_VAR 0 3
52928: ARRAY
52929: IN
52930: IFFALSE 53107
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52932: LD_ADDR_EXP 87
52936: PUSH
52937: LD_EXP 87
52941: PPUSH
52942: LD_VAR 0 3
52946: PPUSH
52947: LD_EXP 87
52951: PUSH
52952: LD_VAR 0 3
52956: ARRAY
52957: PUSH
52958: LD_VAR 0 1
52962: DIFF
52963: PPUSH
52964: CALL_OW 1
52968: ST_TO_ADDR
// if building in mc_lab [ i ] then
52969: LD_VAR 0 1
52973: PUSH
52974: LD_EXP 113
52978: PUSH
52979: LD_VAR 0 3
52983: ARRAY
52984: IN
52985: IFFALSE 53040
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
52987: LD_ADDR_EXP 114
52991: PUSH
52992: LD_EXP 114
52996: PPUSH
52997: LD_VAR 0 3
53001: PPUSH
53002: LD_EXP 114
53006: PUSH
53007: LD_VAR 0 3
53011: ARRAY
53012: PPUSH
53013: LD_INT 1
53015: PPUSH
53016: LD_EXP 114
53020: PUSH
53021: LD_VAR 0 3
53025: ARRAY
53026: PPUSH
53027: LD_INT 0
53029: PPUSH
53030: CALL 59023 0 4
53034: PPUSH
53035: CALL_OW 1
53039: ST_TO_ADDR
// if not building in mc_bases [ i ] then
53040: LD_VAR 0 1
53044: PUSH
53045: LD_EXP 80
53049: PUSH
53050: LD_VAR 0 3
53054: ARRAY
53055: IN
53056: NOT
53057: IFFALSE 53103
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
53059: LD_ADDR_EXP 80
53063: PUSH
53064: LD_EXP 80
53068: PPUSH
53069: LD_VAR 0 3
53073: PUSH
53074: LD_EXP 80
53078: PUSH
53079: LD_VAR 0 3
53083: ARRAY
53084: PUSH
53085: LD_INT 1
53087: PLUS
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: PPUSH
53093: LD_VAR 0 1
53097: PPUSH
53098: CALL 59615 0 3
53102: ST_TO_ADDR
// exit ;
53103: POP
53104: POP
53105: GO 53111
// end ; end ;
53107: GO 52911
53109: POP
53110: POP
// end ;
53111: LD_VAR 0 2
53115: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
53116: LD_INT 0
53118: PPUSH
53119: PPUSH
53120: PPUSH
53121: PPUSH
53122: PPUSH
53123: PPUSH
53124: PPUSH
// if not mc_bases or not skirmish then
53125: LD_EXP 80
53129: NOT
53130: IFTRUE 53139
53132: PUSH
53133: LD_EXP 78
53137: NOT
53138: OR
53139: IFFALSE 53143
// exit ;
53141: GO 53804
// for i = 1 to mc_bases do
53143: LD_ADDR_VAR 0 3
53147: PUSH
53148: DOUBLE
53149: LD_INT 1
53151: DEC
53152: ST_TO_ADDR
53153: LD_EXP 80
53157: PUSH
53158: FOR_TO
53159: IFFALSE 53802
// begin if building in mc_construct_list [ i ] then
53161: LD_VAR 0 1
53165: PUSH
53166: LD_EXP 87
53170: PUSH
53171: LD_VAR 0 3
53175: ARRAY
53176: IN
53177: IFFALSE 53800
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
53179: LD_ADDR_EXP 87
53183: PUSH
53184: LD_EXP 87
53188: PPUSH
53189: LD_VAR 0 3
53193: PPUSH
53194: LD_EXP 87
53198: PUSH
53199: LD_VAR 0 3
53203: ARRAY
53204: PUSH
53205: LD_VAR 0 1
53209: DIFF
53210: PPUSH
53211: CALL_OW 1
53215: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
53216: LD_ADDR_EXP 80
53220: PUSH
53221: LD_EXP 80
53225: PPUSH
53226: LD_VAR 0 3
53230: PUSH
53231: LD_EXP 80
53235: PUSH
53236: LD_VAR 0 3
53240: ARRAY
53241: PUSH
53242: LD_INT 1
53244: PLUS
53245: PUSH
53246: EMPTY
53247: LIST
53248: LIST
53249: PPUSH
53250: LD_VAR 0 1
53254: PPUSH
53255: CALL 59615 0 3
53259: ST_TO_ADDR
// btype := GetBType ( building ) ;
53260: LD_ADDR_VAR 0 5
53264: PUSH
53265: LD_VAR 0 1
53269: PPUSH
53270: CALL_OW 266
53274: ST_TO_ADDR
// side := GetSide ( building ) ;
53275: LD_ADDR_VAR 0 8
53279: PUSH
53280: LD_VAR 0 1
53284: PPUSH
53285: CALL_OW 255
53289: ST_TO_ADDR
// if btype = b_lab then
53290: LD_VAR 0 5
53294: PUSH
53295: LD_INT 6
53297: EQUAL
53298: IFFALSE 53348
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
53300: LD_ADDR_EXP 113
53304: PUSH
53305: LD_EXP 113
53309: PPUSH
53310: LD_VAR 0 3
53314: PUSH
53315: LD_EXP 113
53319: PUSH
53320: LD_VAR 0 3
53324: ARRAY
53325: PUSH
53326: LD_INT 1
53328: PLUS
53329: PUSH
53330: EMPTY
53331: LIST
53332: LIST
53333: PPUSH
53334: LD_VAR 0 1
53338: PPUSH
53339: CALL 59615 0 3
53343: ST_TO_ADDR
// exit ;
53344: POP
53345: POP
53346: GO 53804
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
53348: LD_VAR 0 5
53352: PUSH
53353: LD_INT 0
53355: PUSH
53356: LD_INT 2
53358: PUSH
53359: LD_INT 4
53361: PUSH
53362: EMPTY
53363: LIST
53364: LIST
53365: LIST
53366: IN
53367: IFFALSE 53491
// begin if btype = b_armoury then
53369: LD_VAR 0 5
53373: PUSH
53374: LD_INT 4
53376: EQUAL
53377: IFFALSE 53387
// btype := b_barracks ;
53379: LD_ADDR_VAR 0 5
53383: PUSH
53384: LD_INT 5
53386: ST_TO_ADDR
// if btype = b_depot then
53387: LD_VAR 0 5
53391: PUSH
53392: LD_INT 0
53394: EQUAL
53395: IFFALSE 53405
// btype := b_warehouse ;
53397: LD_ADDR_VAR 0 5
53401: PUSH
53402: LD_INT 1
53404: ST_TO_ADDR
// if btype = b_workshop then
53405: LD_VAR 0 5
53409: PUSH
53410: LD_INT 2
53412: EQUAL
53413: IFFALSE 53423
// btype := b_factory ;
53415: LD_ADDR_VAR 0 5
53419: PUSH
53420: LD_INT 3
53422: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
53423: LD_VAR 0 5
53427: PPUSH
53428: LD_VAR 0 8
53432: PPUSH
53433: CALL_OW 323
53437: PUSH
53438: LD_INT 1
53440: EQUAL
53441: IFFALSE 53487
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
53443: LD_ADDR_EXP 112
53447: PUSH
53448: LD_EXP 112
53452: PPUSH
53453: LD_VAR 0 3
53457: PUSH
53458: LD_EXP 112
53462: PUSH
53463: LD_VAR 0 3
53467: ARRAY
53468: PUSH
53469: LD_INT 1
53471: PLUS
53472: PUSH
53473: EMPTY
53474: LIST
53475: LIST
53476: PPUSH
53477: LD_VAR 0 1
53481: PPUSH
53482: CALL 59615 0 3
53486: ST_TO_ADDR
// exit ;
53487: POP
53488: POP
53489: GO 53804
// end ; if btype in [ b_bunker , b_turret ] then
53491: LD_VAR 0 5
53495: PUSH
53496: LD_INT 32
53498: PUSH
53499: LD_INT 33
53501: PUSH
53502: EMPTY
53503: LIST
53504: LIST
53505: IN
53506: IFFALSE 53796
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
53508: LD_ADDR_EXP 88
53512: PUSH
53513: LD_EXP 88
53517: PPUSH
53518: LD_VAR 0 3
53522: PUSH
53523: LD_EXP 88
53527: PUSH
53528: LD_VAR 0 3
53532: ARRAY
53533: PUSH
53534: LD_INT 1
53536: PLUS
53537: PUSH
53538: EMPTY
53539: LIST
53540: LIST
53541: PPUSH
53542: LD_VAR 0 1
53546: PPUSH
53547: CALL 59615 0 3
53551: ST_TO_ADDR
// if btype = b_bunker then
53552: LD_VAR 0 5
53556: PUSH
53557: LD_INT 32
53559: EQUAL
53560: IFFALSE 53796
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
53562: LD_ADDR_EXP 89
53566: PUSH
53567: LD_EXP 89
53571: PPUSH
53572: LD_VAR 0 3
53576: PUSH
53577: LD_EXP 89
53581: PUSH
53582: LD_VAR 0 3
53586: ARRAY
53587: PUSH
53588: LD_INT 1
53590: PLUS
53591: PUSH
53592: EMPTY
53593: LIST
53594: LIST
53595: PPUSH
53596: LD_VAR 0 1
53600: PPUSH
53601: CALL 59615 0 3
53605: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
53606: LD_ADDR_VAR 0 6
53610: PUSH
53611: LD_EXP 80
53615: PUSH
53616: LD_VAR 0 3
53620: ARRAY
53621: PPUSH
53622: LD_INT 25
53624: PUSH
53625: LD_INT 1
53627: PUSH
53628: EMPTY
53629: LIST
53630: LIST
53631: PUSH
53632: LD_INT 3
53634: PUSH
53635: LD_INT 54
53637: PUSH
53638: EMPTY
53639: LIST
53640: PUSH
53641: EMPTY
53642: LIST
53643: LIST
53644: PUSH
53645: EMPTY
53646: LIST
53647: LIST
53648: PPUSH
53649: CALL_OW 72
53653: ST_TO_ADDR
// if tmp then
53654: LD_VAR 0 6
53658: IFFALSE 53664
// exit ;
53660: POP
53661: POP
53662: GO 53804
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53664: LD_ADDR_VAR 0 6
53668: PUSH
53669: LD_EXP 80
53673: PUSH
53674: LD_VAR 0 3
53678: ARRAY
53679: PPUSH
53680: LD_INT 2
53682: PUSH
53683: LD_INT 30
53685: PUSH
53686: LD_INT 4
53688: PUSH
53689: EMPTY
53690: LIST
53691: LIST
53692: PUSH
53693: LD_INT 30
53695: PUSH
53696: LD_INT 5
53698: PUSH
53699: EMPTY
53700: LIST
53701: LIST
53702: PUSH
53703: EMPTY
53704: LIST
53705: LIST
53706: LIST
53707: PPUSH
53708: CALL_OW 72
53712: ST_TO_ADDR
// if not tmp then
53713: LD_VAR 0 6
53717: NOT
53718: IFFALSE 53724
// exit ;
53720: POP
53721: POP
53722: GO 53804
// for j in tmp do
53724: LD_ADDR_VAR 0 4
53728: PUSH
53729: LD_VAR 0 6
53733: PUSH
53734: FOR_IN
53735: IFFALSE 53794
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
53737: LD_ADDR_VAR 0 7
53741: PUSH
53742: LD_VAR 0 4
53746: PPUSH
53747: CALL_OW 313
53751: PPUSH
53752: LD_INT 25
53754: PUSH
53755: LD_INT 1
53757: PUSH
53758: EMPTY
53759: LIST
53760: LIST
53761: PPUSH
53762: CALL_OW 72
53766: ST_TO_ADDR
// if units then
53767: LD_VAR 0 7
53771: IFFALSE 53792
// begin ComExitBuilding ( units [ 1 ] ) ;
53773: LD_VAR 0 7
53777: PUSH
53778: LD_INT 1
53780: ARRAY
53781: PPUSH
53782: CALL_OW 122
// exit ;
53786: POP
53787: POP
53788: POP
53789: POP
53790: GO 53804
// end ; end ;
53792: GO 53734
53794: POP
53795: POP
// end ; end ; exit ;
53796: POP
53797: POP
53798: GO 53804
// end ; end ;
53800: GO 53158
53802: POP
53803: POP
// end ;
53804: LD_VAR 0 2
53808: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
53809: LD_INT 0
53811: PPUSH
53812: PPUSH
53813: PPUSH
53814: PPUSH
53815: PPUSH
53816: PPUSH
53817: PPUSH
// if not mc_bases or not skirmish then
53818: LD_EXP 80
53822: NOT
53823: IFTRUE 53832
53825: PUSH
53826: LD_EXP 78
53830: NOT
53831: OR
53832: IFFALSE 53836
// exit ;
53834: GO 54101
// btype := GetBType ( building ) ;
53836: LD_ADDR_VAR 0 6
53840: PUSH
53841: LD_VAR 0 1
53845: PPUSH
53846: CALL_OW 266
53850: ST_TO_ADDR
// x := GetX ( building ) ;
53851: LD_ADDR_VAR 0 7
53855: PUSH
53856: LD_VAR 0 1
53860: PPUSH
53861: CALL_OW 250
53865: ST_TO_ADDR
// y := GetY ( building ) ;
53866: LD_ADDR_VAR 0 8
53870: PUSH
53871: LD_VAR 0 1
53875: PPUSH
53876: CALL_OW 251
53880: ST_TO_ADDR
// d := GetDir ( building ) ;
53881: LD_ADDR_VAR 0 9
53885: PUSH
53886: LD_VAR 0 1
53890: PPUSH
53891: CALL_OW 254
53895: ST_TO_ADDR
// for i = 1 to mc_bases do
53896: LD_ADDR_VAR 0 4
53900: PUSH
53901: DOUBLE
53902: LD_INT 1
53904: DEC
53905: ST_TO_ADDR
53906: LD_EXP 80
53910: PUSH
53911: FOR_TO
53912: IFFALSE 54099
// begin if not mc_build_list [ i ] then
53914: LD_EXP 85
53918: PUSH
53919: LD_VAR 0 4
53923: ARRAY
53924: NOT
53925: IFFALSE 53929
// continue ;
53927: GO 53911
// for j := 1 to mc_build_list [ i ] do
53929: LD_ADDR_VAR 0 5
53933: PUSH
53934: DOUBLE
53935: LD_INT 1
53937: DEC
53938: ST_TO_ADDR
53939: LD_EXP 85
53943: PUSH
53944: LD_VAR 0 4
53948: ARRAY
53949: PUSH
53950: FOR_TO
53951: IFFALSE 54095
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
53953: LD_VAR 0 6
53957: PUSH
53958: LD_VAR 0 7
53962: PUSH
53963: LD_VAR 0 8
53967: PUSH
53968: LD_VAR 0 9
53972: PUSH
53973: EMPTY
53974: LIST
53975: LIST
53976: LIST
53977: LIST
53978: PPUSH
53979: LD_EXP 85
53983: PUSH
53984: LD_VAR 0 4
53988: ARRAY
53989: PUSH
53990: LD_VAR 0 5
53994: ARRAY
53995: PPUSH
53996: CALL 66222 0 2
54000: IFFALSE 54093
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
54002: LD_ADDR_EXP 85
54006: PUSH
54007: LD_EXP 85
54011: PPUSH
54012: LD_VAR 0 4
54016: PPUSH
54017: LD_EXP 85
54021: PUSH
54022: LD_VAR 0 4
54026: ARRAY
54027: PPUSH
54028: LD_VAR 0 5
54032: PPUSH
54033: CALL_OW 3
54037: PPUSH
54038: CALL_OW 1
54042: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
54043: LD_ADDR_EXP 87
54047: PUSH
54048: LD_EXP 87
54052: PPUSH
54053: LD_VAR 0 4
54057: PUSH
54058: LD_EXP 87
54062: PUSH
54063: LD_VAR 0 4
54067: ARRAY
54068: PUSH
54069: LD_INT 1
54071: PLUS
54072: PUSH
54073: EMPTY
54074: LIST
54075: LIST
54076: PPUSH
54077: LD_VAR 0 1
54081: PPUSH
54082: CALL 59615 0 3
54086: ST_TO_ADDR
// exit ;
54087: POP
54088: POP
54089: POP
54090: POP
54091: GO 54101
// end ;
54093: GO 53950
54095: POP
54096: POP
// end ;
54097: GO 53911
54099: POP
54100: POP
// end ;
54101: LD_VAR 0 3
54105: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
54106: LD_INT 0
54108: PPUSH
54109: PPUSH
54110: PPUSH
// if not mc_bases or not skirmish then
54111: LD_EXP 80
54115: NOT
54116: IFTRUE 54125
54118: PUSH
54119: LD_EXP 78
54123: NOT
54124: OR
54125: IFFALSE 54129
// exit ;
54127: GO 54325
// for i = 1 to mc_bases do
54129: LD_ADDR_VAR 0 4
54133: PUSH
54134: DOUBLE
54135: LD_INT 1
54137: DEC
54138: ST_TO_ADDR
54139: LD_EXP 80
54143: PUSH
54144: FOR_TO
54145: IFFALSE 54234
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
54147: LD_VAR 0 1
54151: PUSH
54152: LD_EXP 88
54156: PUSH
54157: LD_VAR 0 4
54161: ARRAY
54162: IN
54163: IFFALSE 54184
54165: PUSH
54166: LD_VAR 0 1
54170: PUSH
54171: LD_EXP 89
54175: PUSH
54176: LD_VAR 0 4
54180: ARRAY
54181: IN
54182: NOT
54183: AND
54184: IFFALSE 54232
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
54186: LD_ADDR_EXP 89
54190: PUSH
54191: LD_EXP 89
54195: PPUSH
54196: LD_VAR 0 4
54200: PUSH
54201: LD_EXP 89
54205: PUSH
54206: LD_VAR 0 4
54210: ARRAY
54211: PUSH
54212: LD_INT 1
54214: PLUS
54215: PUSH
54216: EMPTY
54217: LIST
54218: LIST
54219: PPUSH
54220: LD_VAR 0 1
54224: PPUSH
54225: CALL 59615 0 3
54229: ST_TO_ADDR
// break ;
54230: GO 54234
// end ; end ;
54232: GO 54144
54234: POP
54235: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
54236: LD_VAR 0 1
54240: PPUSH
54241: CALL_OW 257
54245: PUSH
54246: LD_EXP 106
54250: IN
54251: IFFALSE 54268
54253: PUSH
54254: LD_VAR 0 1
54258: PPUSH
54259: CALL_OW 266
54263: PUSH
54264: LD_INT 5
54266: EQUAL
54267: AND
54268: IFFALSE 54285
54270: PUSH
54271: LD_VAR 0 2
54275: PPUSH
54276: CALL_OW 110
54280: PUSH
54281: LD_INT 18
54283: NONEQUAL
54284: AND
54285: IFFALSE 54325
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
54287: LD_VAR 0 2
54291: PPUSH
54292: CALL_OW 257
54296: PUSH
54297: LD_INT 5
54299: PUSH
54300: LD_INT 8
54302: PUSH
54303: LD_INT 9
54305: PUSH
54306: EMPTY
54307: LIST
54308: LIST
54309: LIST
54310: IN
54311: IFFALSE 54325
// SetClass ( unit , 1 ) ;
54313: LD_VAR 0 2
54317: PPUSH
54318: LD_INT 1
54320: PPUSH
54321: CALL_OW 336
// end ;
54325: LD_VAR 0 3
54329: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
54330: LD_INT 0
54332: PPUSH
54333: PPUSH
// if not mc_bases or not skirmish then
54334: LD_EXP 80
54338: NOT
54339: IFTRUE 54348
54341: PUSH
54342: LD_EXP 78
54346: NOT
54347: OR
54348: IFFALSE 54352
// exit ;
54350: GO 54468
// if GetLives ( abandoned_vehicle ) > 250 then
54352: LD_VAR 0 2
54356: PPUSH
54357: CALL_OW 256
54361: PUSH
54362: LD_INT 250
54364: GREATER
54365: IFFALSE 54369
// exit ;
54367: GO 54468
// for i = 1 to mc_bases do
54369: LD_ADDR_VAR 0 6
54373: PUSH
54374: DOUBLE
54375: LD_INT 1
54377: DEC
54378: ST_TO_ADDR
54379: LD_EXP 80
54383: PUSH
54384: FOR_TO
54385: IFFALSE 54466
// begin if driver in mc_bases [ i ] then
54387: LD_VAR 0 1
54391: PUSH
54392: LD_EXP 80
54396: PUSH
54397: LD_VAR 0 6
54401: ARRAY
54402: IN
54403: IFFALSE 54464
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
54405: LD_VAR 0 1
54409: PPUSH
54410: LD_EXP 80
54414: PUSH
54415: LD_VAR 0 6
54419: ARRAY
54420: PPUSH
54421: LD_INT 2
54423: PUSH
54424: LD_INT 30
54426: PUSH
54427: LD_INT 0
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: PUSH
54434: LD_INT 30
54436: PUSH
54437: LD_INT 1
54439: PUSH
54440: EMPTY
54441: LIST
54442: LIST
54443: PUSH
54444: EMPTY
54445: LIST
54446: LIST
54447: LIST
54448: PPUSH
54449: CALL_OW 72
54453: PUSH
54454: LD_INT 1
54456: ARRAY
54457: PPUSH
54458: CALL 93552 0 2
// break ;
54462: GO 54466
// end ; end ;
54464: GO 54384
54466: POP
54467: POP
// end ; end_of_file
54468: LD_VAR 0 5
54472: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
54473: LD_INT 0
54475: PPUSH
54476: PPUSH
// if exist_mode then
54477: LD_VAR 0 2
54481: IFFALSE 54527
// begin unit := CreateCharacter ( prefix & ident ) ;
54483: LD_ADDR_VAR 0 5
54487: PUSH
54488: LD_VAR 0 3
54492: PUSH
54493: LD_VAR 0 1
54497: STR
54498: PPUSH
54499: CALL_OW 34
54503: ST_TO_ADDR
// if unit then
54504: LD_VAR 0 5
54508: IFFALSE 54525
// DeleteCharacters ( prefix & ident ) ;
54510: LD_VAR 0 3
54514: PUSH
54515: LD_VAR 0 1
54519: STR
54520: PPUSH
54521: CALL_OW 40
// end else
54525: GO 54542
// unit := NewCharacter ( ident ) ;
54527: LD_ADDR_VAR 0 5
54531: PUSH
54532: LD_VAR 0 1
54536: PPUSH
54537: CALL_OW 25
54541: ST_TO_ADDR
// result := unit ;
54542: LD_ADDR_VAR 0 4
54546: PUSH
54547: LD_VAR 0 5
54551: ST_TO_ADDR
// end ;
54552: LD_VAR 0 4
54556: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
54557: LD_INT 0
54559: PPUSH
54560: PPUSH
// if exist_mode then
54561: LD_VAR 0 2
54565: IFFALSE 54590
// unit := CreateCharacter ( prefix & ident ) else
54567: LD_ADDR_VAR 0 5
54571: PUSH
54572: LD_VAR 0 3
54576: PUSH
54577: LD_VAR 0 1
54581: STR
54582: PPUSH
54583: CALL_OW 34
54587: ST_TO_ADDR
54588: GO 54605
// unit := NewCharacter ( ident ) ;
54590: LD_ADDR_VAR 0 5
54594: PUSH
54595: LD_VAR 0 1
54599: PPUSH
54600: CALL_OW 25
54604: ST_TO_ADDR
// result := unit ;
54605: LD_ADDR_VAR 0 4
54609: PUSH
54610: LD_VAR 0 5
54614: ST_TO_ADDR
// end ;
54615: LD_VAR 0 4
54619: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
54620: LD_INT 0
54622: PPUSH
54623: PPUSH
// if not side or not nation then
54624: LD_VAR 0 1
54628: NOT
54629: IFTRUE 54638
54631: PUSH
54632: LD_VAR 0 2
54636: NOT
54637: OR
54638: IFFALSE 54642
// exit ;
54640: GO 55436
// case nation of nation_american :
54642: LD_VAR 0 2
54646: PUSH
54647: LD_INT 1
54649: DOUBLE
54650: EQUAL
54651: IFTRUE 54655
54653: GO 54877
54655: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
54656: LD_ADDR_VAR 0 4
54660: PUSH
54661: LD_INT 35
54663: PUSH
54664: LD_INT 45
54666: PUSH
54667: LD_INT 46
54669: PUSH
54670: LD_INT 47
54672: PUSH
54673: LD_INT 82
54675: PUSH
54676: LD_INT 83
54678: PUSH
54679: LD_INT 84
54681: PUSH
54682: LD_INT 85
54684: PUSH
54685: LD_INT 86
54687: PUSH
54688: LD_INT 1
54690: PUSH
54691: LD_INT 2
54693: PUSH
54694: LD_INT 6
54696: PUSH
54697: LD_INT 15
54699: PUSH
54700: LD_INT 16
54702: PUSH
54703: LD_INT 7
54705: PUSH
54706: LD_INT 12
54708: PUSH
54709: LD_INT 13
54711: PUSH
54712: LD_INT 10
54714: PUSH
54715: LD_INT 14
54717: PUSH
54718: LD_INT 20
54720: PUSH
54721: LD_INT 21
54723: PUSH
54724: LD_INT 22
54726: PUSH
54727: LD_INT 25
54729: PUSH
54730: LD_INT 32
54732: PUSH
54733: LD_INT 27
54735: PUSH
54736: LD_INT 36
54738: PUSH
54739: LD_INT 69
54741: PUSH
54742: LD_INT 39
54744: PUSH
54745: LD_INT 34
54747: PUSH
54748: LD_INT 40
54750: PUSH
54751: LD_INT 48
54753: PUSH
54754: LD_INT 49
54756: PUSH
54757: LD_INT 50
54759: PUSH
54760: LD_INT 51
54762: PUSH
54763: LD_INT 52
54765: PUSH
54766: LD_INT 53
54768: PUSH
54769: LD_INT 54
54771: PUSH
54772: LD_INT 55
54774: PUSH
54775: LD_INT 56
54777: PUSH
54778: LD_INT 57
54780: PUSH
54781: LD_INT 58
54783: PUSH
54784: LD_INT 59
54786: PUSH
54787: LD_INT 60
54789: PUSH
54790: LD_INT 61
54792: PUSH
54793: LD_INT 62
54795: PUSH
54796: LD_INT 80
54798: PUSH
54799: LD_INT 82
54801: PUSH
54802: LD_INT 83
54804: PUSH
54805: LD_INT 84
54807: PUSH
54808: LD_INT 85
54810: PUSH
54811: LD_INT 86
54813: PUSH
54814: LD_INT 90
54816: PUSH
54817: LD_INT 93
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: LIST
54824: LIST
54825: LIST
54826: LIST
54827: LIST
54828: LIST
54829: LIST
54830: LIST
54831: LIST
54832: LIST
54833: LIST
54834: LIST
54835: LIST
54836: LIST
54837: LIST
54838: LIST
54839: LIST
54840: LIST
54841: LIST
54842: LIST
54843: LIST
54844: LIST
54845: LIST
54846: LIST
54847: LIST
54848: LIST
54849: LIST
54850: LIST
54851: LIST
54852: LIST
54853: LIST
54854: LIST
54855: LIST
54856: LIST
54857: LIST
54858: LIST
54859: LIST
54860: LIST
54861: LIST
54862: LIST
54863: LIST
54864: LIST
54865: LIST
54866: LIST
54867: LIST
54868: LIST
54869: LIST
54870: LIST
54871: LIST
54872: LIST
54873: LIST
54874: ST_TO_ADDR
54875: GO 55358
54877: LD_INT 2
54879: DOUBLE
54880: EQUAL
54881: IFTRUE 54885
54883: GO 55119
54885: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
54886: LD_ADDR_VAR 0 4
54890: PUSH
54891: LD_INT 35
54893: PUSH
54894: LD_INT 45
54896: PUSH
54897: LD_INT 46
54899: PUSH
54900: LD_INT 47
54902: PUSH
54903: LD_INT 82
54905: PUSH
54906: LD_INT 83
54908: PUSH
54909: LD_INT 84
54911: PUSH
54912: LD_INT 85
54914: PUSH
54915: LD_INT 87
54917: PUSH
54918: LD_INT 70
54920: PUSH
54921: LD_INT 1
54923: PUSH
54924: LD_INT 11
54926: PUSH
54927: LD_INT 3
54929: PUSH
54930: LD_INT 4
54932: PUSH
54933: LD_INT 5
54935: PUSH
54936: LD_INT 6
54938: PUSH
54939: LD_INT 15
54941: PUSH
54942: LD_INT 18
54944: PUSH
54945: LD_INT 7
54947: PUSH
54948: LD_INT 17
54950: PUSH
54951: LD_INT 8
54953: PUSH
54954: LD_INT 20
54956: PUSH
54957: LD_INT 21
54959: PUSH
54960: LD_INT 22
54962: PUSH
54963: LD_INT 72
54965: PUSH
54966: LD_INT 26
54968: PUSH
54969: LD_INT 69
54971: PUSH
54972: LD_INT 39
54974: PUSH
54975: LD_INT 40
54977: PUSH
54978: LD_INT 41
54980: PUSH
54981: LD_INT 42
54983: PUSH
54984: LD_INT 43
54986: PUSH
54987: LD_INT 48
54989: PUSH
54990: LD_INT 49
54992: PUSH
54993: LD_INT 50
54995: PUSH
54996: LD_INT 51
54998: PUSH
54999: LD_INT 52
55001: PUSH
55002: LD_INT 53
55004: PUSH
55005: LD_INT 54
55007: PUSH
55008: LD_INT 55
55010: PUSH
55011: LD_INT 56
55013: PUSH
55014: LD_INT 60
55016: PUSH
55017: LD_INT 61
55019: PUSH
55020: LD_INT 62
55022: PUSH
55023: LD_INT 66
55025: PUSH
55026: LD_INT 67
55028: PUSH
55029: LD_INT 68
55031: PUSH
55032: LD_INT 81
55034: PUSH
55035: LD_INT 82
55037: PUSH
55038: LD_INT 83
55040: PUSH
55041: LD_INT 84
55043: PUSH
55044: LD_INT 85
55046: PUSH
55047: LD_INT 87
55049: PUSH
55050: LD_INT 88
55052: PUSH
55053: LD_INT 92
55055: PUSH
55056: LD_INT 94
55058: PUSH
55059: EMPTY
55060: LIST
55061: LIST
55062: LIST
55063: LIST
55064: LIST
55065: LIST
55066: LIST
55067: LIST
55068: LIST
55069: LIST
55070: LIST
55071: LIST
55072: LIST
55073: LIST
55074: LIST
55075: LIST
55076: LIST
55077: LIST
55078: LIST
55079: LIST
55080: LIST
55081: LIST
55082: LIST
55083: LIST
55084: LIST
55085: LIST
55086: LIST
55087: LIST
55088: LIST
55089: LIST
55090: LIST
55091: LIST
55092: LIST
55093: LIST
55094: LIST
55095: LIST
55096: LIST
55097: LIST
55098: LIST
55099: LIST
55100: LIST
55101: LIST
55102: LIST
55103: LIST
55104: LIST
55105: LIST
55106: LIST
55107: LIST
55108: LIST
55109: LIST
55110: LIST
55111: LIST
55112: LIST
55113: LIST
55114: LIST
55115: LIST
55116: ST_TO_ADDR
55117: GO 55358
55119: LD_INT 3
55121: DOUBLE
55122: EQUAL
55123: IFTRUE 55127
55125: GO 55357
55127: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
55128: LD_ADDR_VAR 0 4
55132: PUSH
55133: LD_INT 46
55135: PUSH
55136: LD_INT 47
55138: PUSH
55139: LD_INT 1
55141: PUSH
55142: LD_INT 2
55144: PUSH
55145: LD_INT 82
55147: PUSH
55148: LD_INT 83
55150: PUSH
55151: LD_INT 84
55153: PUSH
55154: LD_INT 85
55156: PUSH
55157: LD_INT 86
55159: PUSH
55160: LD_INT 11
55162: PUSH
55163: LD_INT 9
55165: PUSH
55166: LD_INT 20
55168: PUSH
55169: LD_INT 19
55171: PUSH
55172: LD_INT 21
55174: PUSH
55175: LD_INT 24
55177: PUSH
55178: LD_INT 22
55180: PUSH
55181: LD_INT 25
55183: PUSH
55184: LD_INT 28
55186: PUSH
55187: LD_INT 29
55189: PUSH
55190: LD_INT 30
55192: PUSH
55193: LD_INT 31
55195: PUSH
55196: LD_INT 37
55198: PUSH
55199: LD_INT 38
55201: PUSH
55202: LD_INT 32
55204: PUSH
55205: LD_INT 27
55207: PUSH
55208: LD_INT 33
55210: PUSH
55211: LD_INT 69
55213: PUSH
55214: LD_INT 39
55216: PUSH
55217: LD_INT 34
55219: PUSH
55220: LD_INT 40
55222: PUSH
55223: LD_INT 71
55225: PUSH
55226: LD_INT 23
55228: PUSH
55229: LD_INT 44
55231: PUSH
55232: LD_INT 48
55234: PUSH
55235: LD_INT 49
55237: PUSH
55238: LD_INT 50
55240: PUSH
55241: LD_INT 51
55243: PUSH
55244: LD_INT 52
55246: PUSH
55247: LD_INT 53
55249: PUSH
55250: LD_INT 54
55252: PUSH
55253: LD_INT 55
55255: PUSH
55256: LD_INT 56
55258: PUSH
55259: LD_INT 57
55261: PUSH
55262: LD_INT 58
55264: PUSH
55265: LD_INT 59
55267: PUSH
55268: LD_INT 63
55270: PUSH
55271: LD_INT 64
55273: PUSH
55274: LD_INT 65
55276: PUSH
55277: LD_INT 82
55279: PUSH
55280: LD_INT 83
55282: PUSH
55283: LD_INT 84
55285: PUSH
55286: LD_INT 85
55288: PUSH
55289: LD_INT 86
55291: PUSH
55292: LD_INT 89
55294: PUSH
55295: LD_INT 91
55297: PUSH
55298: EMPTY
55299: LIST
55300: LIST
55301: LIST
55302: LIST
55303: LIST
55304: LIST
55305: LIST
55306: LIST
55307: LIST
55308: LIST
55309: LIST
55310: LIST
55311: LIST
55312: LIST
55313: LIST
55314: LIST
55315: LIST
55316: LIST
55317: LIST
55318: LIST
55319: LIST
55320: LIST
55321: LIST
55322: LIST
55323: LIST
55324: LIST
55325: LIST
55326: LIST
55327: LIST
55328: LIST
55329: LIST
55330: LIST
55331: LIST
55332: LIST
55333: LIST
55334: LIST
55335: LIST
55336: LIST
55337: LIST
55338: LIST
55339: LIST
55340: LIST
55341: LIST
55342: LIST
55343: LIST
55344: LIST
55345: LIST
55346: LIST
55347: LIST
55348: LIST
55349: LIST
55350: LIST
55351: LIST
55352: LIST
55353: LIST
55354: ST_TO_ADDR
55355: GO 55358
55357: POP
// if state > - 1 and state < 3 then
55358: LD_VAR 0 3
55362: PUSH
55363: LD_INT 1
55365: NEG
55366: GREATER
55367: IFFALSE 55379
55369: PUSH
55370: LD_VAR 0 3
55374: PUSH
55375: LD_INT 3
55377: LESS
55378: AND
55379: IFFALSE 55436
// for i in result do
55381: LD_ADDR_VAR 0 5
55385: PUSH
55386: LD_VAR 0 4
55390: PUSH
55391: FOR_IN
55392: IFFALSE 55434
// if GetTech ( i , side ) <> state then
55394: LD_VAR 0 5
55398: PPUSH
55399: LD_VAR 0 1
55403: PPUSH
55404: CALL_OW 321
55408: PUSH
55409: LD_VAR 0 3
55413: NONEQUAL
55414: IFFALSE 55432
// result := result diff i ;
55416: LD_ADDR_VAR 0 4
55420: PUSH
55421: LD_VAR 0 4
55425: PUSH
55426: LD_VAR 0 5
55430: DIFF
55431: ST_TO_ADDR
55432: GO 55391
55434: POP
55435: POP
// end ;
55436: LD_VAR 0 4
55440: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
55441: LD_INT 0
55443: PPUSH
55444: PPUSH
55445: PPUSH
// result := true ;
55446: LD_ADDR_VAR 0 3
55450: PUSH
55451: LD_INT 1
55453: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
55454: LD_ADDR_VAR 0 5
55458: PUSH
55459: LD_VAR 0 2
55463: PPUSH
55464: CALL_OW 480
55468: ST_TO_ADDR
// if not tmp then
55469: LD_VAR 0 5
55473: NOT
55474: IFFALSE 55478
// exit ;
55476: GO 55527
// for i in tmp do
55478: LD_ADDR_VAR 0 4
55482: PUSH
55483: LD_VAR 0 5
55487: PUSH
55488: FOR_IN
55489: IFFALSE 55525
// if GetTech ( i , side ) <> state_researched then
55491: LD_VAR 0 4
55495: PPUSH
55496: LD_VAR 0 1
55500: PPUSH
55501: CALL_OW 321
55505: PUSH
55506: LD_INT 2
55508: NONEQUAL
55509: IFFALSE 55523
// begin result := false ;
55511: LD_ADDR_VAR 0 3
55515: PUSH
55516: LD_INT 0
55518: ST_TO_ADDR
// exit ;
55519: POP
55520: POP
55521: GO 55527
// end ;
55523: GO 55488
55525: POP
55526: POP
// end ;
55527: LD_VAR 0 3
55531: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
55532: LD_INT 0
55534: PPUSH
55535: PPUSH
55536: PPUSH
55537: PPUSH
55538: PPUSH
55539: PPUSH
55540: PPUSH
55541: PPUSH
55542: PPUSH
55543: PPUSH
55544: PPUSH
55545: PPUSH
55546: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
55547: LD_VAR 0 1
55551: NOT
55552: IFTRUE 55569
55554: PUSH
55555: LD_VAR 0 1
55559: PPUSH
55560: CALL_OW 257
55564: PUSH
55565: LD_INT 9
55567: NONEQUAL
55568: OR
55569: IFFALSE 55573
// exit ;
55571: GO 56152
// side := GetSide ( unit ) ;
55573: LD_ADDR_VAR 0 9
55577: PUSH
55578: LD_VAR 0 1
55582: PPUSH
55583: CALL_OW 255
55587: ST_TO_ADDR
// tech_space := tech_spacanom ;
55588: LD_ADDR_VAR 0 12
55592: PUSH
55593: LD_INT 29
55595: ST_TO_ADDR
// tech_time := tech_taurad ;
55596: LD_ADDR_VAR 0 13
55600: PUSH
55601: LD_INT 28
55603: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
55604: LD_ADDR_VAR 0 11
55608: PUSH
55609: LD_VAR 0 1
55613: PPUSH
55614: CALL_OW 310
55618: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
55619: LD_VAR 0 11
55623: PPUSH
55624: CALL_OW 247
55628: PUSH
55629: LD_INT 2
55631: EQUAL
55632: IFFALSE 55636
// exit ;
55634: GO 56152
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55636: LD_ADDR_VAR 0 8
55640: PUSH
55641: LD_INT 81
55643: PUSH
55644: LD_VAR 0 9
55648: PUSH
55649: EMPTY
55650: LIST
55651: LIST
55652: PUSH
55653: LD_INT 3
55655: PUSH
55656: LD_INT 21
55658: PUSH
55659: LD_INT 3
55661: PUSH
55662: EMPTY
55663: LIST
55664: LIST
55665: PUSH
55666: EMPTY
55667: LIST
55668: LIST
55669: PUSH
55670: EMPTY
55671: LIST
55672: LIST
55673: PPUSH
55674: CALL_OW 69
55678: ST_TO_ADDR
// if not tmp then
55679: LD_VAR 0 8
55683: NOT
55684: IFFALSE 55688
// exit ;
55686: GO 56152
// if in_unit then
55688: LD_VAR 0 11
55692: IFFALSE 55716
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
55694: LD_ADDR_VAR 0 10
55698: PUSH
55699: LD_VAR 0 8
55703: PPUSH
55704: LD_VAR 0 11
55708: PPUSH
55709: CALL_OW 74
55713: ST_TO_ADDR
55714: GO 55736
// enemy := NearestUnitToUnit ( tmp , unit ) ;
55716: LD_ADDR_VAR 0 10
55720: PUSH
55721: LD_VAR 0 8
55725: PPUSH
55726: LD_VAR 0 1
55730: PPUSH
55731: CALL_OW 74
55735: ST_TO_ADDR
// if not enemy then
55736: LD_VAR 0 10
55740: NOT
55741: IFFALSE 55745
// exit ;
55743: GO 56152
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
55745: LD_VAR 0 11
55749: IFFALSE 55771
55751: PUSH
55752: LD_VAR 0 11
55756: PPUSH
55757: LD_VAR 0 10
55761: PPUSH
55762: CALL_OW 296
55766: PUSH
55767: LD_INT 13
55769: GREATER
55770: AND
55771: IFTRUE 55793
55773: PUSH
55774: LD_VAR 0 1
55778: PPUSH
55779: LD_VAR 0 10
55783: PPUSH
55784: CALL_OW 296
55788: PUSH
55789: LD_INT 12
55791: GREATER
55792: OR
55793: IFFALSE 55797
// exit ;
55795: GO 56152
// missile := [ 1 ] ;
55797: LD_ADDR_VAR 0 14
55801: PUSH
55802: LD_INT 1
55804: PUSH
55805: EMPTY
55806: LIST
55807: ST_TO_ADDR
// if Researched ( side , tech_space ) then
55808: LD_VAR 0 9
55812: PPUSH
55813: LD_VAR 0 12
55817: PPUSH
55818: CALL_OW 325
55822: IFFALSE 55851
// missile := Replace ( missile , missile + 1 , 2 ) ;
55824: LD_ADDR_VAR 0 14
55828: PUSH
55829: LD_VAR 0 14
55833: PPUSH
55834: LD_VAR 0 14
55838: PUSH
55839: LD_INT 1
55841: PLUS
55842: PPUSH
55843: LD_INT 2
55845: PPUSH
55846: CALL_OW 1
55850: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
55851: LD_VAR 0 9
55855: PPUSH
55856: LD_VAR 0 13
55860: PPUSH
55861: CALL_OW 325
55865: IFFALSE 55889
55867: PUSH
55868: LD_VAR 0 10
55872: PPUSH
55873: CALL_OW 255
55877: PPUSH
55878: LD_VAR 0 13
55882: PPUSH
55883: CALL_OW 325
55887: NOT
55888: AND
55889: IFFALSE 55918
// missile := Replace ( missile , missile + 1 , 3 ) ;
55891: LD_ADDR_VAR 0 14
55895: PUSH
55896: LD_VAR 0 14
55900: PPUSH
55901: LD_VAR 0 14
55905: PUSH
55906: LD_INT 1
55908: PLUS
55909: PPUSH
55910: LD_INT 3
55912: PPUSH
55913: CALL_OW 1
55917: ST_TO_ADDR
// if missile < 2 then
55918: LD_VAR 0 14
55922: PUSH
55923: LD_INT 2
55925: LESS
55926: IFFALSE 55930
// exit ;
55928: GO 56152
// x := GetX ( enemy ) ;
55930: LD_ADDR_VAR 0 4
55934: PUSH
55935: LD_VAR 0 10
55939: PPUSH
55940: CALL_OW 250
55944: ST_TO_ADDR
// y := GetY ( enemy ) ;
55945: LD_ADDR_VAR 0 5
55949: PUSH
55950: LD_VAR 0 10
55954: PPUSH
55955: CALL_OW 251
55959: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
55960: LD_ADDR_VAR 0 6
55964: PUSH
55965: LD_VAR 0 4
55969: PUSH
55970: LD_INT 1
55972: NEG
55973: PPUSH
55974: LD_INT 1
55976: PPUSH
55977: CALL_OW 12
55981: PLUS
55982: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
55983: LD_ADDR_VAR 0 7
55987: PUSH
55988: LD_VAR 0 5
55992: PUSH
55993: LD_INT 1
55995: NEG
55996: PPUSH
55997: LD_INT 1
55999: PPUSH
56000: CALL_OW 12
56004: PLUS
56005: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
56006: LD_VAR 0 6
56010: PPUSH
56011: LD_VAR 0 7
56015: PPUSH
56016: CALL_OW 488
56020: NOT
56021: IFFALSE 56043
// begin _x := x ;
56023: LD_ADDR_VAR 0 6
56027: PUSH
56028: LD_VAR 0 4
56032: ST_TO_ADDR
// _y := y ;
56033: LD_ADDR_VAR 0 7
56037: PUSH
56038: LD_VAR 0 5
56042: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
56043: LD_ADDR_VAR 0 3
56047: PUSH
56048: LD_INT 1
56050: PPUSH
56051: LD_VAR 0 14
56055: PPUSH
56056: CALL_OW 12
56060: ST_TO_ADDR
// case i of 1 :
56061: LD_VAR 0 3
56065: PUSH
56066: LD_INT 1
56068: DOUBLE
56069: EQUAL
56070: IFTRUE 56074
56072: GO 56091
56074: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
56075: LD_VAR 0 1
56079: PPUSH
56080: LD_VAR 0 10
56084: PPUSH
56085: CALL_OW 115
56089: GO 56152
56091: LD_INT 2
56093: DOUBLE
56094: EQUAL
56095: IFTRUE 56099
56097: GO 56121
56099: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
56100: LD_VAR 0 1
56104: PPUSH
56105: LD_VAR 0 6
56109: PPUSH
56110: LD_VAR 0 7
56114: PPUSH
56115: CALL_OW 153
56119: GO 56152
56121: LD_INT 3
56123: DOUBLE
56124: EQUAL
56125: IFTRUE 56129
56127: GO 56151
56129: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
56130: LD_VAR 0 1
56134: PPUSH
56135: LD_VAR 0 6
56139: PPUSH
56140: LD_VAR 0 7
56144: PPUSH
56145: CALL_OW 154
56149: GO 56152
56151: POP
// end ;
56152: LD_VAR 0 2
56156: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
56157: LD_INT 0
56159: PPUSH
56160: PPUSH
56161: PPUSH
56162: PPUSH
56163: PPUSH
56164: PPUSH
// if not unit or not building then
56165: LD_VAR 0 1
56169: NOT
56170: IFTRUE 56179
56172: PUSH
56173: LD_VAR 0 2
56177: NOT
56178: OR
56179: IFFALSE 56183
// exit ;
56181: GO 56341
// x := GetX ( building ) ;
56183: LD_ADDR_VAR 0 5
56187: PUSH
56188: LD_VAR 0 2
56192: PPUSH
56193: CALL_OW 250
56197: ST_TO_ADDR
// y := GetY ( building ) ;
56198: LD_ADDR_VAR 0 6
56202: PUSH
56203: LD_VAR 0 2
56207: PPUSH
56208: CALL_OW 251
56212: ST_TO_ADDR
// for i := 0 to 5 do
56213: LD_ADDR_VAR 0 4
56217: PUSH
56218: DOUBLE
56219: LD_INT 0
56221: DEC
56222: ST_TO_ADDR
56223: LD_INT 5
56225: PUSH
56226: FOR_TO
56227: IFFALSE 56339
// begin _x := ShiftX ( x , i , 3 ) ;
56229: LD_ADDR_VAR 0 7
56233: PUSH
56234: LD_VAR 0 5
56238: PPUSH
56239: LD_VAR 0 4
56243: PPUSH
56244: LD_INT 3
56246: PPUSH
56247: CALL_OW 272
56251: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
56252: LD_ADDR_VAR 0 8
56256: PUSH
56257: LD_VAR 0 6
56261: PPUSH
56262: LD_VAR 0 4
56266: PPUSH
56267: LD_INT 3
56269: PPUSH
56270: CALL_OW 273
56274: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
56275: LD_VAR 0 7
56279: PPUSH
56280: LD_VAR 0 8
56284: PPUSH
56285: CALL_OW 488
56289: NOT
56290: IFFALSE 56294
// continue ;
56292: GO 56226
// if HexInfo ( _x , _y ) = 0 then
56294: LD_VAR 0 7
56298: PPUSH
56299: LD_VAR 0 8
56303: PPUSH
56304: CALL_OW 428
56308: PUSH
56309: LD_INT 0
56311: EQUAL
56312: IFFALSE 56337
// begin ComMoveXY ( unit , _x , _y ) ;
56314: LD_VAR 0 1
56318: PPUSH
56319: LD_VAR 0 7
56323: PPUSH
56324: LD_VAR 0 8
56328: PPUSH
56329: CALL_OW 111
// exit ;
56333: POP
56334: POP
56335: GO 56341
// end ; end ;
56337: GO 56226
56339: POP
56340: POP
// end ;
56341: LD_VAR 0 3
56345: RET
// export function ScanBase ( side , base_area ) ; begin
56346: LD_INT 0
56348: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
56349: LD_ADDR_VAR 0 3
56353: PUSH
56354: LD_VAR 0 2
56358: PPUSH
56359: LD_INT 81
56361: PUSH
56362: LD_VAR 0 1
56366: PUSH
56367: EMPTY
56368: LIST
56369: LIST
56370: PPUSH
56371: CALL_OW 70
56375: ST_TO_ADDR
// end ;
56376: LD_VAR 0 3
56380: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
56381: LD_INT 0
56383: PPUSH
56384: PPUSH
56385: PPUSH
56386: PPUSH
// result := false ;
56387: LD_ADDR_VAR 0 2
56391: PUSH
56392: LD_INT 0
56394: ST_TO_ADDR
// side := GetSide ( unit ) ;
56395: LD_ADDR_VAR 0 3
56399: PUSH
56400: LD_VAR 0 1
56404: PPUSH
56405: CALL_OW 255
56409: ST_TO_ADDR
// nat := GetNation ( unit ) ;
56410: LD_ADDR_VAR 0 4
56414: PUSH
56415: LD_VAR 0 1
56419: PPUSH
56420: CALL_OW 248
56424: ST_TO_ADDR
// case nat of 1 :
56425: LD_VAR 0 4
56429: PUSH
56430: LD_INT 1
56432: DOUBLE
56433: EQUAL
56434: IFTRUE 56438
56436: GO 56449
56438: POP
// tech := tech_lassight ; 2 :
56439: LD_ADDR_VAR 0 5
56443: PUSH
56444: LD_INT 12
56446: ST_TO_ADDR
56447: GO 56488
56449: LD_INT 2
56451: DOUBLE
56452: EQUAL
56453: IFTRUE 56457
56455: GO 56468
56457: POP
// tech := tech_mortar ; 3 :
56458: LD_ADDR_VAR 0 5
56462: PUSH
56463: LD_INT 41
56465: ST_TO_ADDR
56466: GO 56488
56468: LD_INT 3
56470: DOUBLE
56471: EQUAL
56472: IFTRUE 56476
56474: GO 56487
56476: POP
// tech := tech_bazooka ; end ;
56477: LD_ADDR_VAR 0 5
56481: PUSH
56482: LD_INT 44
56484: ST_TO_ADDR
56485: GO 56488
56487: POP
// if Researched ( side , tech ) then
56488: LD_VAR 0 3
56492: PPUSH
56493: LD_VAR 0 5
56497: PPUSH
56498: CALL_OW 325
56502: IFFALSE 56529
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
56504: LD_ADDR_VAR 0 2
56508: PUSH
56509: LD_INT 5
56511: PUSH
56512: LD_INT 8
56514: PUSH
56515: LD_INT 9
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: LIST
56522: PUSH
56523: LD_VAR 0 4
56527: ARRAY
56528: ST_TO_ADDR
// end ;
56529: LD_VAR 0 2
56533: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
56534: LD_INT 0
56536: PPUSH
56537: PPUSH
56538: PPUSH
// if not mines then
56539: LD_VAR 0 2
56543: NOT
56544: IFFALSE 56548
// exit ;
56546: GO 56692
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56548: LD_ADDR_VAR 0 5
56552: PUSH
56553: LD_INT 81
56555: PUSH
56556: LD_VAR 0 1
56560: PUSH
56561: EMPTY
56562: LIST
56563: LIST
56564: PUSH
56565: LD_INT 3
56567: PUSH
56568: LD_INT 21
56570: PUSH
56571: LD_INT 3
56573: PUSH
56574: EMPTY
56575: LIST
56576: LIST
56577: PUSH
56578: EMPTY
56579: LIST
56580: LIST
56581: PUSH
56582: EMPTY
56583: LIST
56584: LIST
56585: PPUSH
56586: CALL_OW 69
56590: ST_TO_ADDR
// for i in mines do
56591: LD_ADDR_VAR 0 4
56595: PUSH
56596: LD_VAR 0 2
56600: PUSH
56601: FOR_IN
56602: IFFALSE 56690
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
56604: LD_VAR 0 4
56608: PUSH
56609: LD_INT 1
56611: ARRAY
56612: PPUSH
56613: LD_VAR 0 4
56617: PUSH
56618: LD_INT 2
56620: ARRAY
56621: PPUSH
56622: CALL_OW 458
56626: NOT
56627: IFFALSE 56631
// continue ;
56629: GO 56601
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
56631: LD_VAR 0 4
56635: PUSH
56636: LD_INT 1
56638: ARRAY
56639: PPUSH
56640: LD_VAR 0 4
56644: PUSH
56645: LD_INT 2
56647: ARRAY
56648: PPUSH
56649: CALL_OW 428
56653: PUSH
56654: LD_VAR 0 5
56658: IN
56659: IFFALSE 56688
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
56661: LD_VAR 0 4
56665: PUSH
56666: LD_INT 1
56668: ARRAY
56669: PPUSH
56670: LD_VAR 0 4
56674: PUSH
56675: LD_INT 2
56677: ARRAY
56678: PPUSH
56679: LD_VAR 0 1
56683: PPUSH
56684: CALL_OW 456
// end ;
56688: GO 56601
56690: POP
56691: POP
// end ;
56692: LD_VAR 0 3
56696: RET
// export function Count ( array ) ; begin
56697: LD_INT 0
56699: PPUSH
// result := array + 0 ;
56700: LD_ADDR_VAR 0 2
56704: PUSH
56705: LD_VAR 0 1
56709: PUSH
56710: LD_INT 0
56712: PLUS
56713: ST_TO_ADDR
// end ;
56714: LD_VAR 0 2
56718: RET
// export function IsEmpty ( building ) ; begin
56719: LD_INT 0
56721: PPUSH
// if not building then
56722: LD_VAR 0 1
56726: NOT
56727: IFFALSE 56731
// exit ;
56729: GO 56774
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
56731: LD_ADDR_VAR 0 2
56735: PUSH
56736: LD_VAR 0 1
56740: PUSH
56741: LD_INT 22
56743: PUSH
56744: LD_VAR 0 1
56748: PPUSH
56749: CALL_OW 255
56753: PUSH
56754: EMPTY
56755: LIST
56756: LIST
56757: PUSH
56758: LD_INT 58
56760: PUSH
56761: EMPTY
56762: LIST
56763: PUSH
56764: EMPTY
56765: LIST
56766: LIST
56767: PPUSH
56768: CALL_OW 69
56772: IN
56773: ST_TO_ADDR
// end ;
56774: LD_VAR 0 2
56778: RET
// export function IsNotFull ( building ) ; var places ; begin
56779: LD_INT 0
56781: PPUSH
56782: PPUSH
// if not building then
56783: LD_VAR 0 1
56787: NOT
56788: IFFALSE 56792
// exit ;
56790: GO 56820
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
56792: LD_ADDR_VAR 0 2
56796: PUSH
56797: LD_VAR 0 1
56801: PPUSH
56802: LD_INT 3
56804: PUSH
56805: LD_INT 62
56807: PUSH
56808: EMPTY
56809: LIST
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: PPUSH
56815: CALL_OW 72
56819: ST_TO_ADDR
// end ;
56820: LD_VAR 0 2
56824: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
56825: LD_INT 0
56827: PPUSH
56828: PPUSH
56829: PPUSH
56830: PPUSH
// tmp := [ ] ;
56831: LD_ADDR_VAR 0 3
56835: PUSH
56836: EMPTY
56837: ST_TO_ADDR
// list := [ ] ;
56838: LD_ADDR_VAR 0 5
56842: PUSH
56843: EMPTY
56844: ST_TO_ADDR
// for i = 16 to 25 do
56845: LD_ADDR_VAR 0 4
56849: PUSH
56850: DOUBLE
56851: LD_INT 16
56853: DEC
56854: ST_TO_ADDR
56855: LD_INT 25
56857: PUSH
56858: FOR_TO
56859: IFFALSE 56932
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
56861: LD_ADDR_VAR 0 3
56865: PUSH
56866: LD_VAR 0 3
56870: PUSH
56871: LD_INT 22
56873: PUSH
56874: LD_VAR 0 1
56878: PPUSH
56879: CALL_OW 255
56883: PUSH
56884: EMPTY
56885: LIST
56886: LIST
56887: PUSH
56888: LD_INT 91
56890: PUSH
56891: LD_VAR 0 1
56895: PUSH
56896: LD_INT 6
56898: PUSH
56899: EMPTY
56900: LIST
56901: LIST
56902: LIST
56903: PUSH
56904: LD_INT 30
56906: PUSH
56907: LD_VAR 0 4
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: LIST
56920: PUSH
56921: EMPTY
56922: LIST
56923: PPUSH
56924: CALL_OW 69
56928: ADD
56929: ST_TO_ADDR
56930: GO 56858
56932: POP
56933: POP
// for i = 1 to tmp do
56934: LD_ADDR_VAR 0 4
56938: PUSH
56939: DOUBLE
56940: LD_INT 1
56942: DEC
56943: ST_TO_ADDR
56944: LD_VAR 0 3
56948: PUSH
56949: FOR_TO
56950: IFFALSE 57038
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
56952: LD_ADDR_VAR 0 5
56956: PUSH
56957: LD_VAR 0 5
56961: PUSH
56962: LD_VAR 0 3
56966: PUSH
56967: LD_VAR 0 4
56971: ARRAY
56972: PPUSH
56973: CALL_OW 266
56977: PUSH
56978: LD_VAR 0 3
56982: PUSH
56983: LD_VAR 0 4
56987: ARRAY
56988: PPUSH
56989: CALL_OW 250
56993: PUSH
56994: LD_VAR 0 3
56998: PUSH
56999: LD_VAR 0 4
57003: ARRAY
57004: PPUSH
57005: CALL_OW 251
57009: PUSH
57010: LD_VAR 0 3
57014: PUSH
57015: LD_VAR 0 4
57019: ARRAY
57020: PPUSH
57021: CALL_OW 254
57025: PUSH
57026: EMPTY
57027: LIST
57028: LIST
57029: LIST
57030: LIST
57031: PUSH
57032: EMPTY
57033: LIST
57034: ADD
57035: ST_TO_ADDR
57036: GO 56949
57038: POP
57039: POP
// result := list ;
57040: LD_ADDR_VAR 0 2
57044: PUSH
57045: LD_VAR 0 5
57049: ST_TO_ADDR
// end ;
57050: LD_VAR 0 2
57054: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
57055: LD_INT 0
57057: PPUSH
57058: PPUSH
57059: PPUSH
57060: PPUSH
57061: PPUSH
57062: PPUSH
57063: PPUSH
// if not factory then
57064: LD_VAR 0 1
57068: NOT
57069: IFFALSE 57073
// exit ;
57071: GO 57676
// if control = control_apeman then
57073: LD_VAR 0 4
57077: PUSH
57078: LD_INT 5
57080: EQUAL
57081: IFFALSE 57190
// begin tmp := UnitsInside ( factory ) ;
57083: LD_ADDR_VAR 0 8
57087: PUSH
57088: LD_VAR 0 1
57092: PPUSH
57093: CALL_OW 313
57097: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
57098: LD_VAR 0 8
57102: PPUSH
57103: LD_INT 25
57105: PUSH
57106: LD_INT 12
57108: PUSH
57109: EMPTY
57110: LIST
57111: LIST
57112: PPUSH
57113: CALL_OW 72
57117: NOT
57118: IFFALSE 57128
// control := control_manual ;
57120: LD_ADDR_VAR 0 4
57124: PUSH
57125: LD_INT 1
57127: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
57128: LD_ADDR_VAR 0 8
57132: PUSH
57133: LD_VAR 0 1
57137: PPUSH
57138: CALL 56825 0 1
57142: ST_TO_ADDR
// if tmp then
57143: LD_VAR 0 8
57147: IFFALSE 57190
// begin for i in tmp do
57149: LD_ADDR_VAR 0 7
57153: PUSH
57154: LD_VAR 0 8
57158: PUSH
57159: FOR_IN
57160: IFFALSE 57188
// if i [ 1 ] = b_ext_radio then
57162: LD_VAR 0 7
57166: PUSH
57167: LD_INT 1
57169: ARRAY
57170: PUSH
57171: LD_INT 22
57173: EQUAL
57174: IFFALSE 57186
// begin control := control_remote ;
57176: LD_ADDR_VAR 0 4
57180: PUSH
57181: LD_INT 2
57183: ST_TO_ADDR
// break ;
57184: GO 57188
// end ;
57186: GO 57159
57188: POP
57189: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
57190: LD_VAR 0 1
57194: PPUSH
57195: LD_VAR 0 2
57199: PPUSH
57200: LD_VAR 0 3
57204: PPUSH
57205: LD_VAR 0 4
57209: PPUSH
57210: LD_VAR 0 5
57214: PPUSH
57215: CALL_OW 448
57219: IFFALSE 57254
// begin result := [ chassis , engine , control , weapon ] ;
57221: LD_ADDR_VAR 0 6
57225: PUSH
57226: LD_VAR 0 2
57230: PUSH
57231: LD_VAR 0 3
57235: PUSH
57236: LD_VAR 0 4
57240: PUSH
57241: LD_VAR 0 5
57245: PUSH
57246: EMPTY
57247: LIST
57248: LIST
57249: LIST
57250: LIST
57251: ST_TO_ADDR
// exit ;
57252: GO 57676
// end ; _chassis := AvailableChassisList ( factory ) ;
57254: LD_ADDR_VAR 0 9
57258: PUSH
57259: LD_VAR 0 1
57263: PPUSH
57264: CALL_OW 475
57268: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
57269: LD_ADDR_VAR 0 11
57273: PUSH
57274: LD_VAR 0 1
57278: PPUSH
57279: CALL_OW 476
57283: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
57284: LD_ADDR_VAR 0 12
57288: PUSH
57289: LD_VAR 0 1
57293: PPUSH
57294: CALL_OW 477
57298: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
57299: LD_ADDR_VAR 0 10
57303: PUSH
57304: LD_VAR 0 1
57308: PPUSH
57309: CALL_OW 478
57313: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
57314: LD_VAR 0 9
57318: NOT
57319: IFTRUE 57328
57321: PUSH
57322: LD_VAR 0 11
57326: NOT
57327: OR
57328: IFTRUE 57337
57330: PUSH
57331: LD_VAR 0 12
57335: NOT
57336: OR
57337: IFTRUE 57346
57339: PUSH
57340: LD_VAR 0 10
57344: NOT
57345: OR
57346: IFFALSE 57381
// begin result := [ chassis , engine , control , weapon ] ;
57348: LD_ADDR_VAR 0 6
57352: PUSH
57353: LD_VAR 0 2
57357: PUSH
57358: LD_VAR 0 3
57362: PUSH
57363: LD_VAR 0 4
57367: PUSH
57368: LD_VAR 0 5
57372: PUSH
57373: EMPTY
57374: LIST
57375: LIST
57376: LIST
57377: LIST
57378: ST_TO_ADDR
// exit ;
57379: GO 57676
// end ; if not chassis in _chassis then
57381: LD_VAR 0 2
57385: PUSH
57386: LD_VAR 0 9
57390: IN
57391: NOT
57392: IFFALSE 57418
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
57394: LD_ADDR_VAR 0 2
57398: PUSH
57399: LD_VAR 0 9
57403: PUSH
57404: LD_INT 1
57406: PPUSH
57407: LD_VAR 0 9
57411: PPUSH
57412: CALL_OW 12
57416: ARRAY
57417: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
57418: LD_VAR 0 2
57422: PPUSH
57423: LD_VAR 0 3
57427: PPUSH
57428: CALL 57681 0 2
57432: NOT
57433: IFFALSE 57494
// repeat engine := _engine [ 1 ] ;
57435: LD_ADDR_VAR 0 3
57439: PUSH
57440: LD_VAR 0 11
57444: PUSH
57445: LD_INT 1
57447: ARRAY
57448: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
57449: LD_ADDR_VAR 0 11
57453: PUSH
57454: LD_VAR 0 11
57458: PPUSH
57459: LD_INT 1
57461: PPUSH
57462: CALL_OW 3
57466: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
57467: LD_VAR 0 2
57471: PPUSH
57472: LD_VAR 0 3
57476: PPUSH
57477: CALL 57681 0 2
57481: IFTRUE 57492
57483: PUSH
57484: LD_VAR 0 11
57488: PUSH
57489: EMPTY
57490: EQUAL
57491: OR
57492: IFFALSE 57435
// if not control in _control then
57494: LD_VAR 0 4
57498: PUSH
57499: LD_VAR 0 12
57503: IN
57504: NOT
57505: IFFALSE 57531
// control := _control [ rand ( 1 , _control ) ] ;
57507: LD_ADDR_VAR 0 4
57511: PUSH
57512: LD_VAR 0 12
57516: PUSH
57517: LD_INT 1
57519: PPUSH
57520: LD_VAR 0 12
57524: PPUSH
57525: CALL_OW 12
57529: ARRAY
57530: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
57531: LD_VAR 0 2
57535: PPUSH
57536: LD_VAR 0 5
57540: PPUSH
57541: CALL 57903 0 2
57545: NOT
57546: IFFALSE 57607
// repeat weapon := _weapon [ 1 ] ;
57548: LD_ADDR_VAR 0 5
57552: PUSH
57553: LD_VAR 0 10
57557: PUSH
57558: LD_INT 1
57560: ARRAY
57561: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
57562: LD_ADDR_VAR 0 10
57566: PUSH
57567: LD_VAR 0 10
57571: PPUSH
57572: LD_INT 1
57574: PPUSH
57575: CALL_OW 3
57579: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
57580: LD_VAR 0 2
57584: PPUSH
57585: LD_VAR 0 5
57589: PPUSH
57590: CALL 57903 0 2
57594: IFTRUE 57605
57596: PUSH
57597: LD_VAR 0 10
57601: PUSH
57602: EMPTY
57603: EQUAL
57604: OR
57605: IFFALSE 57548
// result := [ ] ;
57607: LD_ADDR_VAR 0 6
57611: PUSH
57612: EMPTY
57613: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
57614: LD_VAR 0 1
57618: PPUSH
57619: LD_VAR 0 2
57623: PPUSH
57624: LD_VAR 0 3
57628: PPUSH
57629: LD_VAR 0 4
57633: PPUSH
57634: LD_VAR 0 5
57638: PPUSH
57639: CALL_OW 448
57643: IFFALSE 57676
// result := [ chassis , engine , control , weapon ] ;
57645: LD_ADDR_VAR 0 6
57649: PUSH
57650: LD_VAR 0 2
57654: PUSH
57655: LD_VAR 0 3
57659: PUSH
57660: LD_VAR 0 4
57664: PUSH
57665: LD_VAR 0 5
57669: PUSH
57670: EMPTY
57671: LIST
57672: LIST
57673: LIST
57674: LIST
57675: ST_TO_ADDR
// end ;
57676: LD_VAR 0 6
57680: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
57681: LD_INT 0
57683: PPUSH
// if not chassis or not engine then
57684: LD_VAR 0 1
57688: NOT
57689: IFTRUE 57698
57691: PUSH
57692: LD_VAR 0 2
57696: NOT
57697: OR
57698: IFFALSE 57702
// exit ;
57700: GO 57898
// case engine of engine_solar :
57702: LD_VAR 0 2
57706: PUSH
57707: LD_INT 2
57709: DOUBLE
57710: EQUAL
57711: IFTRUE 57715
57713: GO 57753
57715: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
57716: LD_ADDR_VAR 0 3
57720: PUSH
57721: LD_INT 11
57723: PUSH
57724: LD_INT 12
57726: PUSH
57727: LD_INT 13
57729: PUSH
57730: LD_INT 14
57732: PUSH
57733: LD_INT 1
57735: PUSH
57736: LD_INT 2
57738: PUSH
57739: LD_INT 3
57741: PUSH
57742: EMPTY
57743: LIST
57744: LIST
57745: LIST
57746: LIST
57747: LIST
57748: LIST
57749: LIST
57750: ST_TO_ADDR
57751: GO 57882
57753: LD_INT 1
57755: DOUBLE
57756: EQUAL
57757: IFTRUE 57761
57759: GO 57823
57761: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
57762: LD_ADDR_VAR 0 3
57766: PUSH
57767: LD_INT 11
57769: PUSH
57770: LD_INT 12
57772: PUSH
57773: LD_INT 13
57775: PUSH
57776: LD_INT 14
57778: PUSH
57779: LD_INT 1
57781: PUSH
57782: LD_INT 2
57784: PUSH
57785: LD_INT 3
57787: PUSH
57788: LD_INT 4
57790: PUSH
57791: LD_INT 5
57793: PUSH
57794: LD_INT 21
57796: PUSH
57797: LD_INT 23
57799: PUSH
57800: LD_INT 22
57802: PUSH
57803: LD_INT 24
57805: PUSH
57806: EMPTY
57807: LIST
57808: LIST
57809: LIST
57810: LIST
57811: LIST
57812: LIST
57813: LIST
57814: LIST
57815: LIST
57816: LIST
57817: LIST
57818: LIST
57819: LIST
57820: ST_TO_ADDR
57821: GO 57882
57823: LD_INT 3
57825: DOUBLE
57826: EQUAL
57827: IFTRUE 57831
57829: GO 57881
57831: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57832: LD_ADDR_VAR 0 3
57836: PUSH
57837: LD_INT 13
57839: PUSH
57840: LD_INT 14
57842: PUSH
57843: LD_INT 2
57845: PUSH
57846: LD_INT 3
57848: PUSH
57849: LD_INT 4
57851: PUSH
57852: LD_INT 5
57854: PUSH
57855: LD_INT 21
57857: PUSH
57858: LD_INT 22
57860: PUSH
57861: LD_INT 23
57863: PUSH
57864: LD_INT 24
57866: PUSH
57867: EMPTY
57868: LIST
57869: LIST
57870: LIST
57871: LIST
57872: LIST
57873: LIST
57874: LIST
57875: LIST
57876: LIST
57877: LIST
57878: ST_TO_ADDR
57879: GO 57882
57881: POP
// result := ( chassis in result ) ;
57882: LD_ADDR_VAR 0 3
57886: PUSH
57887: LD_VAR 0 1
57891: PUSH
57892: LD_VAR 0 3
57896: IN
57897: ST_TO_ADDR
// end ;
57898: LD_VAR 0 3
57902: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
57903: LD_INT 0
57905: PPUSH
// if not chassis or not weapon then
57906: LD_VAR 0 1
57910: NOT
57911: IFTRUE 57920
57913: PUSH
57914: LD_VAR 0 2
57918: NOT
57919: OR
57920: IFFALSE 57924
// exit ;
57922: GO 59018
// case weapon of us_machine_gun :
57924: LD_VAR 0 2
57928: PUSH
57929: LD_INT 2
57931: DOUBLE
57932: EQUAL
57933: IFTRUE 57937
57935: GO 57967
57937: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
57938: LD_ADDR_VAR 0 3
57942: PUSH
57943: LD_INT 1
57945: PUSH
57946: LD_INT 2
57948: PUSH
57949: LD_INT 3
57951: PUSH
57952: LD_INT 4
57954: PUSH
57955: LD_INT 5
57957: PUSH
57958: EMPTY
57959: LIST
57960: LIST
57961: LIST
57962: LIST
57963: LIST
57964: ST_TO_ADDR
57965: GO 59002
57967: LD_INT 3
57969: DOUBLE
57970: EQUAL
57971: IFTRUE 57975
57973: GO 58005
57975: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
57976: LD_ADDR_VAR 0 3
57980: PUSH
57981: LD_INT 1
57983: PUSH
57984: LD_INT 2
57986: PUSH
57987: LD_INT 3
57989: PUSH
57990: LD_INT 4
57992: PUSH
57993: LD_INT 5
57995: PUSH
57996: EMPTY
57997: LIST
57998: LIST
57999: LIST
58000: LIST
58001: LIST
58002: ST_TO_ADDR
58003: GO 59002
58005: LD_INT 11
58007: DOUBLE
58008: EQUAL
58009: IFTRUE 58013
58011: GO 58043
58013: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
58014: LD_ADDR_VAR 0 3
58018: PUSH
58019: LD_INT 1
58021: PUSH
58022: LD_INT 2
58024: PUSH
58025: LD_INT 3
58027: PUSH
58028: LD_INT 4
58030: PUSH
58031: LD_INT 5
58033: PUSH
58034: EMPTY
58035: LIST
58036: LIST
58037: LIST
58038: LIST
58039: LIST
58040: ST_TO_ADDR
58041: GO 59002
58043: LD_INT 4
58045: DOUBLE
58046: EQUAL
58047: IFTRUE 58051
58049: GO 58077
58051: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
58052: LD_ADDR_VAR 0 3
58056: PUSH
58057: LD_INT 2
58059: PUSH
58060: LD_INT 3
58062: PUSH
58063: LD_INT 4
58065: PUSH
58066: LD_INT 5
58068: PUSH
58069: EMPTY
58070: LIST
58071: LIST
58072: LIST
58073: LIST
58074: ST_TO_ADDR
58075: GO 59002
58077: LD_INT 5
58079: DOUBLE
58080: EQUAL
58081: IFTRUE 58085
58083: GO 58111
58085: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
58086: LD_ADDR_VAR 0 3
58090: PUSH
58091: LD_INT 2
58093: PUSH
58094: LD_INT 3
58096: PUSH
58097: LD_INT 4
58099: PUSH
58100: LD_INT 5
58102: PUSH
58103: EMPTY
58104: LIST
58105: LIST
58106: LIST
58107: LIST
58108: ST_TO_ADDR
58109: GO 59002
58111: LD_INT 9
58113: DOUBLE
58114: EQUAL
58115: IFTRUE 58119
58117: GO 58145
58119: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
58120: LD_ADDR_VAR 0 3
58124: PUSH
58125: LD_INT 2
58127: PUSH
58128: LD_INT 3
58130: PUSH
58131: LD_INT 4
58133: PUSH
58134: LD_INT 5
58136: PUSH
58137: EMPTY
58138: LIST
58139: LIST
58140: LIST
58141: LIST
58142: ST_TO_ADDR
58143: GO 59002
58145: LD_INT 7
58147: DOUBLE
58148: EQUAL
58149: IFTRUE 58153
58151: GO 58179
58153: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
58154: LD_ADDR_VAR 0 3
58158: PUSH
58159: LD_INT 2
58161: PUSH
58162: LD_INT 3
58164: PUSH
58165: LD_INT 4
58167: PUSH
58168: LD_INT 5
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: LIST
58175: LIST
58176: ST_TO_ADDR
58177: GO 59002
58179: LD_INT 12
58181: DOUBLE
58182: EQUAL
58183: IFTRUE 58187
58185: GO 58213
58187: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
58188: LD_ADDR_VAR 0 3
58192: PUSH
58193: LD_INT 2
58195: PUSH
58196: LD_INT 3
58198: PUSH
58199: LD_INT 4
58201: PUSH
58202: LD_INT 5
58204: PUSH
58205: EMPTY
58206: LIST
58207: LIST
58208: LIST
58209: LIST
58210: ST_TO_ADDR
58211: GO 59002
58213: LD_INT 13
58215: DOUBLE
58216: EQUAL
58217: IFTRUE 58221
58219: GO 58247
58221: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
58222: LD_ADDR_VAR 0 3
58226: PUSH
58227: LD_INT 2
58229: PUSH
58230: LD_INT 3
58232: PUSH
58233: LD_INT 4
58235: PUSH
58236: LD_INT 5
58238: PUSH
58239: EMPTY
58240: LIST
58241: LIST
58242: LIST
58243: LIST
58244: ST_TO_ADDR
58245: GO 59002
58247: LD_INT 14
58249: DOUBLE
58250: EQUAL
58251: IFTRUE 58255
58253: GO 58273
58255: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
58256: LD_ADDR_VAR 0 3
58260: PUSH
58261: LD_INT 4
58263: PUSH
58264: LD_INT 5
58266: PUSH
58267: EMPTY
58268: LIST
58269: LIST
58270: ST_TO_ADDR
58271: GO 59002
58273: LD_INT 6
58275: DOUBLE
58276: EQUAL
58277: IFTRUE 58281
58279: GO 58299
58281: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
58282: LD_ADDR_VAR 0 3
58286: PUSH
58287: LD_INT 4
58289: PUSH
58290: LD_INT 5
58292: PUSH
58293: EMPTY
58294: LIST
58295: LIST
58296: ST_TO_ADDR
58297: GO 59002
58299: LD_INT 10
58301: DOUBLE
58302: EQUAL
58303: IFTRUE 58307
58305: GO 58325
58307: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
58308: LD_ADDR_VAR 0 3
58312: PUSH
58313: LD_INT 4
58315: PUSH
58316: LD_INT 5
58318: PUSH
58319: EMPTY
58320: LIST
58321: LIST
58322: ST_TO_ADDR
58323: GO 59002
58325: LD_INT 22
58327: DOUBLE
58328: EQUAL
58329: IFTRUE 58333
58331: GO 58359
58333: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
58334: LD_ADDR_VAR 0 3
58338: PUSH
58339: LD_INT 11
58341: PUSH
58342: LD_INT 12
58344: PUSH
58345: LD_INT 13
58347: PUSH
58348: LD_INT 14
58350: PUSH
58351: EMPTY
58352: LIST
58353: LIST
58354: LIST
58355: LIST
58356: ST_TO_ADDR
58357: GO 59002
58359: LD_INT 23
58361: DOUBLE
58362: EQUAL
58363: IFTRUE 58367
58365: GO 58393
58367: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
58368: LD_ADDR_VAR 0 3
58372: PUSH
58373: LD_INT 11
58375: PUSH
58376: LD_INT 12
58378: PUSH
58379: LD_INT 13
58381: PUSH
58382: LD_INT 14
58384: PUSH
58385: EMPTY
58386: LIST
58387: LIST
58388: LIST
58389: LIST
58390: ST_TO_ADDR
58391: GO 59002
58393: LD_INT 24
58395: DOUBLE
58396: EQUAL
58397: IFTRUE 58401
58399: GO 58427
58401: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
58402: LD_ADDR_VAR 0 3
58406: PUSH
58407: LD_INT 11
58409: PUSH
58410: LD_INT 12
58412: PUSH
58413: LD_INT 13
58415: PUSH
58416: LD_INT 14
58418: PUSH
58419: EMPTY
58420: LIST
58421: LIST
58422: LIST
58423: LIST
58424: ST_TO_ADDR
58425: GO 59002
58427: LD_INT 30
58429: DOUBLE
58430: EQUAL
58431: IFTRUE 58435
58433: GO 58461
58435: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
58436: LD_ADDR_VAR 0 3
58440: PUSH
58441: LD_INT 11
58443: PUSH
58444: LD_INT 12
58446: PUSH
58447: LD_INT 13
58449: PUSH
58450: LD_INT 14
58452: PUSH
58453: EMPTY
58454: LIST
58455: LIST
58456: LIST
58457: LIST
58458: ST_TO_ADDR
58459: GO 59002
58461: LD_INT 25
58463: DOUBLE
58464: EQUAL
58465: IFTRUE 58469
58467: GO 58487
58469: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
58470: LD_ADDR_VAR 0 3
58474: PUSH
58475: LD_INT 13
58477: PUSH
58478: LD_INT 14
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: ST_TO_ADDR
58485: GO 59002
58487: LD_INT 27
58489: DOUBLE
58490: EQUAL
58491: IFTRUE 58495
58493: GO 58513
58495: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
58496: LD_ADDR_VAR 0 3
58500: PUSH
58501: LD_INT 13
58503: PUSH
58504: LD_INT 14
58506: PUSH
58507: EMPTY
58508: LIST
58509: LIST
58510: ST_TO_ADDR
58511: GO 59002
58513: LD_INT 92
58515: DOUBLE
58516: EQUAL
58517: IFTRUE 58521
58519: GO 58547
58521: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
58522: LD_ADDR_VAR 0 3
58526: PUSH
58527: LD_INT 11
58529: PUSH
58530: LD_INT 12
58532: PUSH
58533: LD_INT 13
58535: PUSH
58536: LD_INT 14
58538: PUSH
58539: EMPTY
58540: LIST
58541: LIST
58542: LIST
58543: LIST
58544: ST_TO_ADDR
58545: GO 59002
58547: LD_INT 28
58549: DOUBLE
58550: EQUAL
58551: IFTRUE 58555
58553: GO 58573
58555: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
58556: LD_ADDR_VAR 0 3
58560: PUSH
58561: LD_INT 13
58563: PUSH
58564: LD_INT 14
58566: PUSH
58567: EMPTY
58568: LIST
58569: LIST
58570: ST_TO_ADDR
58571: GO 59002
58573: LD_INT 29
58575: DOUBLE
58576: EQUAL
58577: IFTRUE 58581
58579: GO 58599
58581: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
58582: LD_ADDR_VAR 0 3
58586: PUSH
58587: LD_INT 13
58589: PUSH
58590: LD_INT 14
58592: PUSH
58593: EMPTY
58594: LIST
58595: LIST
58596: ST_TO_ADDR
58597: GO 59002
58599: LD_INT 31
58601: DOUBLE
58602: EQUAL
58603: IFTRUE 58607
58605: GO 58625
58607: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
58608: LD_ADDR_VAR 0 3
58612: PUSH
58613: LD_INT 13
58615: PUSH
58616: LD_INT 14
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: ST_TO_ADDR
58623: GO 59002
58625: LD_INT 26
58627: DOUBLE
58628: EQUAL
58629: IFTRUE 58633
58631: GO 58651
58633: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
58634: LD_ADDR_VAR 0 3
58638: PUSH
58639: LD_INT 13
58641: PUSH
58642: LD_INT 14
58644: PUSH
58645: EMPTY
58646: LIST
58647: LIST
58648: ST_TO_ADDR
58649: GO 59002
58651: LD_INT 42
58653: DOUBLE
58654: EQUAL
58655: IFTRUE 58659
58657: GO 58685
58659: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
58660: LD_ADDR_VAR 0 3
58664: PUSH
58665: LD_INT 21
58667: PUSH
58668: LD_INT 22
58670: PUSH
58671: LD_INT 23
58673: PUSH
58674: LD_INT 24
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: LIST
58681: LIST
58682: ST_TO_ADDR
58683: GO 59002
58685: LD_INT 43
58687: DOUBLE
58688: EQUAL
58689: IFTRUE 58693
58691: GO 58719
58693: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
58694: LD_ADDR_VAR 0 3
58698: PUSH
58699: LD_INT 21
58701: PUSH
58702: LD_INT 22
58704: PUSH
58705: LD_INT 23
58707: PUSH
58708: LD_INT 24
58710: PUSH
58711: EMPTY
58712: LIST
58713: LIST
58714: LIST
58715: LIST
58716: ST_TO_ADDR
58717: GO 59002
58719: LD_INT 44
58721: DOUBLE
58722: EQUAL
58723: IFTRUE 58727
58725: GO 58753
58727: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
58728: LD_ADDR_VAR 0 3
58732: PUSH
58733: LD_INT 21
58735: PUSH
58736: LD_INT 22
58738: PUSH
58739: LD_INT 23
58741: PUSH
58742: LD_INT 24
58744: PUSH
58745: EMPTY
58746: LIST
58747: LIST
58748: LIST
58749: LIST
58750: ST_TO_ADDR
58751: GO 59002
58753: LD_INT 45
58755: DOUBLE
58756: EQUAL
58757: IFTRUE 58761
58759: GO 58787
58761: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
58762: LD_ADDR_VAR 0 3
58766: PUSH
58767: LD_INT 21
58769: PUSH
58770: LD_INT 22
58772: PUSH
58773: LD_INT 23
58775: PUSH
58776: LD_INT 24
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: LIST
58783: LIST
58784: ST_TO_ADDR
58785: GO 59002
58787: LD_INT 49
58789: DOUBLE
58790: EQUAL
58791: IFTRUE 58795
58793: GO 58821
58795: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
58796: LD_ADDR_VAR 0 3
58800: PUSH
58801: LD_INT 21
58803: PUSH
58804: LD_INT 22
58806: PUSH
58807: LD_INT 23
58809: PUSH
58810: LD_INT 24
58812: PUSH
58813: EMPTY
58814: LIST
58815: LIST
58816: LIST
58817: LIST
58818: ST_TO_ADDR
58819: GO 59002
58821: LD_INT 51
58823: DOUBLE
58824: EQUAL
58825: IFTRUE 58829
58827: GO 58855
58829: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
58830: LD_ADDR_VAR 0 3
58834: PUSH
58835: LD_INT 21
58837: PUSH
58838: LD_INT 22
58840: PUSH
58841: LD_INT 23
58843: PUSH
58844: LD_INT 24
58846: PUSH
58847: EMPTY
58848: LIST
58849: LIST
58850: LIST
58851: LIST
58852: ST_TO_ADDR
58853: GO 59002
58855: LD_INT 52
58857: DOUBLE
58858: EQUAL
58859: IFTRUE 58863
58861: GO 58889
58863: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
58864: LD_ADDR_VAR 0 3
58868: PUSH
58869: LD_INT 21
58871: PUSH
58872: LD_INT 22
58874: PUSH
58875: LD_INT 23
58877: PUSH
58878: LD_INT 24
58880: PUSH
58881: EMPTY
58882: LIST
58883: LIST
58884: LIST
58885: LIST
58886: ST_TO_ADDR
58887: GO 59002
58889: LD_INT 53
58891: DOUBLE
58892: EQUAL
58893: IFTRUE 58897
58895: GO 58915
58897: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
58898: LD_ADDR_VAR 0 3
58902: PUSH
58903: LD_INT 23
58905: PUSH
58906: LD_INT 24
58908: PUSH
58909: EMPTY
58910: LIST
58911: LIST
58912: ST_TO_ADDR
58913: GO 59002
58915: LD_INT 46
58917: DOUBLE
58918: EQUAL
58919: IFTRUE 58923
58921: GO 58941
58923: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
58924: LD_ADDR_VAR 0 3
58928: PUSH
58929: LD_INT 23
58931: PUSH
58932: LD_INT 24
58934: PUSH
58935: EMPTY
58936: LIST
58937: LIST
58938: ST_TO_ADDR
58939: GO 59002
58941: LD_INT 47
58943: DOUBLE
58944: EQUAL
58945: IFTRUE 58949
58947: GO 58967
58949: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_radar :
58950: LD_ADDR_VAR 0 3
58954: PUSH
58955: LD_INT 23
58957: PUSH
58958: LD_INT 24
58960: PUSH
58961: EMPTY
58962: LIST
58963: LIST
58964: ST_TO_ADDR
58965: GO 59002
58967: LD_INT 98
58969: DOUBLE
58970: EQUAL
58971: IFTRUE 58975
58973: GO 59001
58975: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
58976: LD_ADDR_VAR 0 3
58980: PUSH
58981: LD_INT 21
58983: PUSH
58984: LD_INT 22
58986: PUSH
58987: LD_INT 23
58989: PUSH
58990: LD_INT 24
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: LIST
58997: LIST
58998: ST_TO_ADDR
58999: GO 59002
59001: POP
// result := ( chassis in result ) ;
59002: LD_ADDR_VAR 0 3
59006: PUSH
59007: LD_VAR 0 1
59011: PUSH
59012: LD_VAR 0 3
59016: IN
59017: ST_TO_ADDR
// end ;
59018: LD_VAR 0 3
59022: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
59023: LD_INT 0
59025: PPUSH
59026: PPUSH
59027: PPUSH
59028: PPUSH
59029: PPUSH
59030: PPUSH
59031: PPUSH
// result := array ;
59032: LD_ADDR_VAR 0 5
59036: PUSH
59037: LD_VAR 0 1
59041: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
59042: LD_VAR 0 1
59046: NOT
59047: IFTRUE 59056
59049: PUSH
59050: LD_VAR 0 2
59054: NOT
59055: OR
59056: IFTRUE 59065
59058: PUSH
59059: LD_VAR 0 3
59063: NOT
59064: OR
59065: IFTRUE 59079
59067: PUSH
59068: LD_VAR 0 2
59072: PUSH
59073: LD_VAR 0 1
59077: GREATER
59078: OR
59079: IFTRUE 59093
59081: PUSH
59082: LD_VAR 0 3
59086: PUSH
59087: LD_VAR 0 1
59091: GREATER
59092: OR
59093: IFFALSE 59097
// exit ;
59095: GO 59393
// if direction then
59097: LD_VAR 0 4
59101: IFFALSE 59165
// begin d := 1 ;
59103: LD_ADDR_VAR 0 9
59107: PUSH
59108: LD_INT 1
59110: ST_TO_ADDR
// if i_from > i_to then
59111: LD_VAR 0 2
59115: PUSH
59116: LD_VAR 0 3
59120: GREATER
59121: IFFALSE 59147
// length := ( array - i_from ) + i_to else
59123: LD_ADDR_VAR 0 11
59127: PUSH
59128: LD_VAR 0 1
59132: PUSH
59133: LD_VAR 0 2
59137: MINUS
59138: PUSH
59139: LD_VAR 0 3
59143: PLUS
59144: ST_TO_ADDR
59145: GO 59163
// length := i_to - i_from ;
59147: LD_ADDR_VAR 0 11
59151: PUSH
59152: LD_VAR 0 3
59156: PUSH
59157: LD_VAR 0 2
59161: MINUS
59162: ST_TO_ADDR
// end else
59163: GO 59226
// begin d := - 1 ;
59165: LD_ADDR_VAR 0 9
59169: PUSH
59170: LD_INT 1
59172: NEG
59173: ST_TO_ADDR
// if i_from > i_to then
59174: LD_VAR 0 2
59178: PUSH
59179: LD_VAR 0 3
59183: GREATER
59184: IFFALSE 59204
// length := i_from - i_to else
59186: LD_ADDR_VAR 0 11
59190: PUSH
59191: LD_VAR 0 2
59195: PUSH
59196: LD_VAR 0 3
59200: MINUS
59201: ST_TO_ADDR
59202: GO 59226
// length := ( array - i_to ) + i_from ;
59204: LD_ADDR_VAR 0 11
59208: PUSH
59209: LD_VAR 0 1
59213: PUSH
59214: LD_VAR 0 3
59218: MINUS
59219: PUSH
59220: LD_VAR 0 2
59224: PLUS
59225: ST_TO_ADDR
// end ; if not length then
59226: LD_VAR 0 11
59230: NOT
59231: IFFALSE 59235
// exit ;
59233: GO 59393
// tmp := array ;
59235: LD_ADDR_VAR 0 10
59239: PUSH
59240: LD_VAR 0 1
59244: ST_TO_ADDR
// for i = 1 to length do
59245: LD_ADDR_VAR 0 6
59249: PUSH
59250: DOUBLE
59251: LD_INT 1
59253: DEC
59254: ST_TO_ADDR
59255: LD_VAR 0 11
59259: PUSH
59260: FOR_TO
59261: IFFALSE 59381
// begin for j = 1 to array do
59263: LD_ADDR_VAR 0 7
59267: PUSH
59268: DOUBLE
59269: LD_INT 1
59271: DEC
59272: ST_TO_ADDR
59273: LD_VAR 0 1
59277: PUSH
59278: FOR_TO
59279: IFFALSE 59367
// begin k := j + d ;
59281: LD_ADDR_VAR 0 8
59285: PUSH
59286: LD_VAR 0 7
59290: PUSH
59291: LD_VAR 0 9
59295: PLUS
59296: ST_TO_ADDR
// if k > array then
59297: LD_VAR 0 8
59301: PUSH
59302: LD_VAR 0 1
59306: GREATER
59307: IFFALSE 59317
// k := 1 ;
59309: LD_ADDR_VAR 0 8
59313: PUSH
59314: LD_INT 1
59316: ST_TO_ADDR
// if not k then
59317: LD_VAR 0 8
59321: NOT
59322: IFFALSE 59334
// k := array ;
59324: LD_ADDR_VAR 0 8
59328: PUSH
59329: LD_VAR 0 1
59333: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
59334: LD_ADDR_VAR 0 10
59338: PUSH
59339: LD_VAR 0 10
59343: PPUSH
59344: LD_VAR 0 8
59348: PPUSH
59349: LD_VAR 0 1
59353: PUSH
59354: LD_VAR 0 7
59358: ARRAY
59359: PPUSH
59360: CALL_OW 1
59364: ST_TO_ADDR
// end ;
59365: GO 59278
59367: POP
59368: POP
// array := tmp ;
59369: LD_ADDR_VAR 0 1
59373: PUSH
59374: LD_VAR 0 10
59378: ST_TO_ADDR
// end ;
59379: GO 59260
59381: POP
59382: POP
// result := array ;
59383: LD_ADDR_VAR 0 5
59387: PUSH
59388: LD_VAR 0 1
59392: ST_TO_ADDR
// end ;
59393: LD_VAR 0 5
59397: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
59398: LD_INT 0
59400: PPUSH
59401: PPUSH
// result := 0 ;
59402: LD_ADDR_VAR 0 3
59406: PUSH
59407: LD_INT 0
59409: ST_TO_ADDR
// if not array or not value in array then
59410: LD_VAR 0 1
59414: NOT
59415: IFTRUE 59430
59417: PUSH
59418: LD_VAR 0 2
59422: PUSH
59423: LD_VAR 0 1
59427: IN
59428: NOT
59429: OR
59430: IFFALSE 59434
// exit ;
59432: GO 59488
// for i = 1 to array do
59434: LD_ADDR_VAR 0 4
59438: PUSH
59439: DOUBLE
59440: LD_INT 1
59442: DEC
59443: ST_TO_ADDR
59444: LD_VAR 0 1
59448: PUSH
59449: FOR_TO
59450: IFFALSE 59486
// if value = array [ i ] then
59452: LD_VAR 0 2
59456: PUSH
59457: LD_VAR 0 1
59461: PUSH
59462: LD_VAR 0 4
59466: ARRAY
59467: EQUAL
59468: IFFALSE 59484
// begin result := i ;
59470: LD_ADDR_VAR 0 3
59474: PUSH
59475: LD_VAR 0 4
59479: ST_TO_ADDR
// exit ;
59480: POP
59481: POP
59482: GO 59488
// end ;
59484: GO 59449
59486: POP
59487: POP
// end ;
59488: LD_VAR 0 3
59492: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
59493: LD_INT 0
59495: PPUSH
// vc_chassis := chassis ;
59496: LD_ADDR_OWVAR 37
59500: PUSH
59501: LD_VAR 0 1
59505: ST_TO_ADDR
// vc_engine := engine ;
59506: LD_ADDR_OWVAR 39
59510: PUSH
59511: LD_VAR 0 2
59515: ST_TO_ADDR
// vc_control := control ;
59516: LD_ADDR_OWVAR 38
59520: PUSH
59521: LD_VAR 0 3
59525: ST_TO_ADDR
// vc_weapon := weapon ;
59526: LD_ADDR_OWVAR 40
59530: PUSH
59531: LD_VAR 0 4
59535: ST_TO_ADDR
// vc_fuel_battery := fuel ;
59536: LD_ADDR_OWVAR 41
59540: PUSH
59541: LD_VAR 0 5
59545: ST_TO_ADDR
// end ;
59546: LD_VAR 0 6
59550: RET
// export function WantPlant ( unit ) ; var task ; begin
59551: LD_INT 0
59553: PPUSH
59554: PPUSH
// result := false ;
59555: LD_ADDR_VAR 0 2
59559: PUSH
59560: LD_INT 0
59562: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
59563: LD_ADDR_VAR 0 3
59567: PUSH
59568: LD_VAR 0 1
59572: PPUSH
59573: CALL_OW 437
59577: ST_TO_ADDR
// if task then
59578: LD_VAR 0 3
59582: IFFALSE 59610
// if task [ 1 ] [ 1 ] = p then
59584: LD_VAR 0 3
59588: PUSH
59589: LD_INT 1
59591: ARRAY
59592: PUSH
59593: LD_INT 1
59595: ARRAY
59596: PUSH
59597: LD_STRING p
59599: EQUAL
59600: IFFALSE 59610
// result := true ;
59602: LD_ADDR_VAR 0 2
59606: PUSH
59607: LD_INT 1
59609: ST_TO_ADDR
// end ;
59610: LD_VAR 0 2
59614: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
59615: LD_INT 0
59617: PPUSH
59618: PPUSH
59619: PPUSH
59620: PPUSH
// if pos < 1 then
59621: LD_VAR 0 2
59625: PUSH
59626: LD_INT 1
59628: LESS
59629: IFFALSE 59633
// exit ;
59631: GO 59936
// if pos = 1 then
59633: LD_VAR 0 2
59637: PUSH
59638: LD_INT 1
59640: EQUAL
59641: IFFALSE 59674
// result := Replace ( arr , pos [ 1 ] , value ) else
59643: LD_ADDR_VAR 0 4
59647: PUSH
59648: LD_VAR 0 1
59652: PPUSH
59653: LD_VAR 0 2
59657: PUSH
59658: LD_INT 1
59660: ARRAY
59661: PPUSH
59662: LD_VAR 0 3
59666: PPUSH
59667: CALL_OW 1
59671: ST_TO_ADDR
59672: GO 59936
// begin tmp := arr ;
59674: LD_ADDR_VAR 0 6
59678: PUSH
59679: LD_VAR 0 1
59683: ST_TO_ADDR
// s_arr := [ tmp ] ;
59684: LD_ADDR_VAR 0 7
59688: PUSH
59689: LD_VAR 0 6
59693: PUSH
59694: EMPTY
59695: LIST
59696: ST_TO_ADDR
// for i = 1 to pos - 1 do
59697: LD_ADDR_VAR 0 5
59701: PUSH
59702: DOUBLE
59703: LD_INT 1
59705: DEC
59706: ST_TO_ADDR
59707: LD_VAR 0 2
59711: PUSH
59712: LD_INT 1
59714: MINUS
59715: PUSH
59716: FOR_TO
59717: IFFALSE 59762
// begin tmp := tmp [ pos [ i ] ] ;
59719: LD_ADDR_VAR 0 6
59723: PUSH
59724: LD_VAR 0 6
59728: PUSH
59729: LD_VAR 0 2
59733: PUSH
59734: LD_VAR 0 5
59738: ARRAY
59739: ARRAY
59740: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
59741: LD_ADDR_VAR 0 7
59745: PUSH
59746: LD_VAR 0 7
59750: PUSH
59751: LD_VAR 0 6
59755: PUSH
59756: EMPTY
59757: LIST
59758: ADD
59759: ST_TO_ADDR
// end ;
59760: GO 59716
59762: POP
59763: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
59764: LD_ADDR_VAR 0 6
59768: PUSH
59769: LD_VAR 0 6
59773: PPUSH
59774: LD_VAR 0 2
59778: PUSH
59779: LD_VAR 0 2
59783: ARRAY
59784: PPUSH
59785: LD_VAR 0 3
59789: PPUSH
59790: CALL_OW 1
59794: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
59795: LD_ADDR_VAR 0 7
59799: PUSH
59800: LD_VAR 0 7
59804: PPUSH
59805: LD_VAR 0 7
59809: PPUSH
59810: LD_VAR 0 6
59814: PPUSH
59815: CALL_OW 1
59819: ST_TO_ADDR
// for i = s_arr downto 2 do
59820: LD_ADDR_VAR 0 5
59824: PUSH
59825: DOUBLE
59826: LD_VAR 0 7
59830: INC
59831: ST_TO_ADDR
59832: LD_INT 2
59834: PUSH
59835: FOR_DOWNTO
59836: IFFALSE 59920
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
59838: LD_ADDR_VAR 0 6
59842: PUSH
59843: LD_VAR 0 7
59847: PUSH
59848: LD_VAR 0 5
59852: PUSH
59853: LD_INT 1
59855: MINUS
59856: ARRAY
59857: PPUSH
59858: LD_VAR 0 2
59862: PUSH
59863: LD_VAR 0 5
59867: PUSH
59868: LD_INT 1
59870: MINUS
59871: ARRAY
59872: PPUSH
59873: LD_VAR 0 7
59877: PUSH
59878: LD_VAR 0 5
59882: ARRAY
59883: PPUSH
59884: CALL_OW 1
59888: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
59889: LD_ADDR_VAR 0 7
59893: PUSH
59894: LD_VAR 0 7
59898: PPUSH
59899: LD_VAR 0 5
59903: PUSH
59904: LD_INT 1
59906: MINUS
59907: PPUSH
59908: LD_VAR 0 6
59912: PPUSH
59913: CALL_OW 1
59917: ST_TO_ADDR
// end ;
59918: GO 59835
59920: POP
59921: POP
// result := s_arr [ 1 ] ;
59922: LD_ADDR_VAR 0 4
59926: PUSH
59927: LD_VAR 0 7
59931: PUSH
59932: LD_INT 1
59934: ARRAY
59935: ST_TO_ADDR
// end ; end ;
59936: LD_VAR 0 4
59940: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
59941: LD_INT 0
59943: PPUSH
59944: PPUSH
// if not list then
59945: LD_VAR 0 1
59949: NOT
59950: IFFALSE 59954
// exit ;
59952: GO 60045
// i := list [ pos1 ] ;
59954: LD_ADDR_VAR 0 5
59958: PUSH
59959: LD_VAR 0 1
59963: PUSH
59964: LD_VAR 0 2
59968: ARRAY
59969: ST_TO_ADDR
// if not i then
59970: LD_VAR 0 5
59974: NOT
59975: IFFALSE 59979
// exit ;
59977: GO 60045
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
59979: LD_ADDR_VAR 0 1
59983: PUSH
59984: LD_VAR 0 1
59988: PPUSH
59989: LD_VAR 0 2
59993: PPUSH
59994: LD_VAR 0 1
59998: PUSH
59999: LD_VAR 0 3
60003: ARRAY
60004: PPUSH
60005: CALL_OW 1
60009: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
60010: LD_ADDR_VAR 0 1
60014: PUSH
60015: LD_VAR 0 1
60019: PPUSH
60020: LD_VAR 0 3
60024: PPUSH
60025: LD_VAR 0 5
60029: PPUSH
60030: CALL_OW 1
60034: ST_TO_ADDR
// result := list ;
60035: LD_ADDR_VAR 0 4
60039: PUSH
60040: LD_VAR 0 1
60044: ST_TO_ADDR
// end ;
60045: LD_VAR 0 4
60049: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
60050: LD_INT 0
60052: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
60053: LD_ADDR_VAR 0 5
60057: PUSH
60058: LD_VAR 0 1
60062: PPUSH
60063: CALL_OW 250
60067: PPUSH
60068: LD_VAR 0 1
60072: PPUSH
60073: CALL_OW 251
60077: PPUSH
60078: LD_VAR 0 2
60082: PPUSH
60083: LD_VAR 0 3
60087: PPUSH
60088: LD_VAR 0 4
60092: PPUSH
60093: CALL 60475 0 5
60097: ST_TO_ADDR
// end ;
60098: LD_VAR 0 5
60102: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
60103: LD_INT 0
60105: PPUSH
60106: PPUSH
60107: PPUSH
60108: PPUSH
// if not list or not unit then
60109: LD_VAR 0 2
60113: NOT
60114: IFTRUE 60123
60116: PUSH
60117: LD_VAR 0 1
60121: NOT
60122: OR
60123: IFFALSE 60127
// exit ;
60125: GO 60470
// result := [ ] ;
60127: LD_ADDR_VAR 0 5
60131: PUSH
60132: EMPTY
60133: ST_TO_ADDR
// for i in list do
60134: LD_ADDR_VAR 0 6
60138: PUSH
60139: LD_VAR 0 2
60143: PUSH
60144: FOR_IN
60145: IFFALSE 60363
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
60147: LD_ADDR_VAR 0 8
60151: PUSH
60152: LD_VAR 0 1
60156: PPUSH
60157: LD_VAR 0 6
60161: PUSH
60162: LD_INT 1
60164: ARRAY
60165: PPUSH
60166: LD_VAR 0 6
60170: PUSH
60171: LD_INT 2
60173: ARRAY
60174: PPUSH
60175: CALL_OW 297
60179: ST_TO_ADDR
// if not Count ( result ) then
60180: LD_VAR 0 5
60184: PPUSH
60185: CALL 56697 0 1
60189: NOT
60190: IFFALSE 60223
// begin result := Join ( result , [ i , tmp ] ) ;
60192: LD_ADDR_VAR 0 5
60196: PUSH
60197: LD_VAR 0 5
60201: PPUSH
60202: LD_VAR 0 6
60206: PUSH
60207: LD_VAR 0 8
60211: PUSH
60212: EMPTY
60213: LIST
60214: LIST
60215: PPUSH
60216: CALL 92673 0 2
60220: ST_TO_ADDR
// continue ;
60221: GO 60144
// end ; if result [ result ] [ 2 ] <= tmp then
60223: LD_VAR 0 5
60227: PUSH
60228: LD_VAR 0 5
60232: ARRAY
60233: PUSH
60234: LD_INT 2
60236: ARRAY
60237: PUSH
60238: LD_VAR 0 8
60242: LESSEQUAL
60243: IFFALSE 60276
// result := Join ( result , [ i , tmp ] ) else
60245: LD_ADDR_VAR 0 5
60249: PUSH
60250: LD_VAR 0 5
60254: PPUSH
60255: LD_VAR 0 6
60259: PUSH
60260: LD_VAR 0 8
60264: PUSH
60265: EMPTY
60266: LIST
60267: LIST
60268: PPUSH
60269: CALL 92673 0 2
60273: ST_TO_ADDR
60274: GO 60361
// begin for j := 1 to Count ( result ) do
60276: LD_ADDR_VAR 0 7
60280: PUSH
60281: DOUBLE
60282: LD_INT 1
60284: DEC
60285: ST_TO_ADDR
60286: LD_VAR 0 5
60290: PPUSH
60291: CALL 56697 0 1
60295: PUSH
60296: FOR_TO
60297: IFFALSE 60359
// begin if tmp < result [ j ] [ 2 ] then
60299: LD_VAR 0 8
60303: PUSH
60304: LD_VAR 0 5
60308: PUSH
60309: LD_VAR 0 7
60313: ARRAY
60314: PUSH
60315: LD_INT 2
60317: ARRAY
60318: LESS
60319: IFFALSE 60357
// begin result := Insert ( result , j , [ i , tmp ] ) ;
60321: LD_ADDR_VAR 0 5
60325: PUSH
60326: LD_VAR 0 5
60330: PPUSH
60331: LD_VAR 0 7
60335: PPUSH
60336: LD_VAR 0 6
60340: PUSH
60341: LD_VAR 0 8
60345: PUSH
60346: EMPTY
60347: LIST
60348: LIST
60349: PPUSH
60350: CALL_OW 2
60354: ST_TO_ADDR
// break ;
60355: GO 60359
// end ; end ;
60357: GO 60296
60359: POP
60360: POP
// end ; end ;
60361: GO 60144
60363: POP
60364: POP
// if result and not asc then
60365: LD_VAR 0 5
60369: IFFALSE 60378
60371: PUSH
60372: LD_VAR 0 3
60376: NOT
60377: AND
60378: IFFALSE 60395
// result := ReverseArray ( result ) ;
60380: LD_ADDR_VAR 0 5
60384: PUSH
60385: LD_VAR 0 5
60389: PPUSH
60390: CALL 87753 0 1
60394: ST_TO_ADDR
// tmp := [ ] ;
60395: LD_ADDR_VAR 0 8
60399: PUSH
60400: EMPTY
60401: ST_TO_ADDR
// if mode then
60402: LD_VAR 0 4
60406: IFFALSE 60470
// begin for i := 1 to result do
60408: LD_ADDR_VAR 0 6
60412: PUSH
60413: DOUBLE
60414: LD_INT 1
60416: DEC
60417: ST_TO_ADDR
60418: LD_VAR 0 5
60422: PUSH
60423: FOR_TO
60424: IFFALSE 60458
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
60426: LD_ADDR_VAR 0 8
60430: PUSH
60431: LD_VAR 0 8
60435: PPUSH
60436: LD_VAR 0 5
60440: PUSH
60441: LD_VAR 0 6
60445: ARRAY
60446: PUSH
60447: LD_INT 1
60449: ARRAY
60450: PPUSH
60451: CALL 92673 0 2
60455: ST_TO_ADDR
60456: GO 60423
60458: POP
60459: POP
// result := tmp ;
60460: LD_ADDR_VAR 0 5
60464: PUSH
60465: LD_VAR 0 8
60469: ST_TO_ADDR
// end ; end ;
60470: LD_VAR 0 5
60474: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
60475: LD_INT 0
60477: PPUSH
60478: PPUSH
60479: PPUSH
60480: PPUSH
// if not list then
60481: LD_VAR 0 3
60485: NOT
60486: IFFALSE 60490
// exit ;
60488: GO 60880
// result := [ ] ;
60490: LD_ADDR_VAR 0 6
60494: PUSH
60495: EMPTY
60496: ST_TO_ADDR
// for i in list do
60497: LD_ADDR_VAR 0 7
60501: PUSH
60502: LD_VAR 0 3
60506: PUSH
60507: FOR_IN
60508: IFFALSE 60710
// begin tmp := GetDistUnitXY ( i , x , y ) ;
60510: LD_ADDR_VAR 0 9
60514: PUSH
60515: LD_VAR 0 7
60519: PPUSH
60520: LD_VAR 0 1
60524: PPUSH
60525: LD_VAR 0 2
60529: PPUSH
60530: CALL_OW 297
60534: ST_TO_ADDR
// if not result then
60535: LD_VAR 0 6
60539: NOT
60540: IFFALSE 60566
// result := [ [ i , tmp ] ] else
60542: LD_ADDR_VAR 0 6
60546: PUSH
60547: LD_VAR 0 7
60551: PUSH
60552: LD_VAR 0 9
60556: PUSH
60557: EMPTY
60558: LIST
60559: LIST
60560: PUSH
60561: EMPTY
60562: LIST
60563: ST_TO_ADDR
60564: GO 60708
// begin if result [ result ] [ 2 ] <= tmp then
60566: LD_VAR 0 6
60570: PUSH
60571: LD_VAR 0 6
60575: ARRAY
60576: PUSH
60577: LD_INT 2
60579: ARRAY
60580: PUSH
60581: LD_VAR 0 9
60585: LESSEQUAL
60586: IFFALSE 60628
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
60588: LD_ADDR_VAR 0 6
60592: PUSH
60593: LD_VAR 0 6
60597: PPUSH
60598: LD_VAR 0 6
60602: PUSH
60603: LD_INT 1
60605: PLUS
60606: PPUSH
60607: LD_VAR 0 7
60611: PUSH
60612: LD_VAR 0 9
60616: PUSH
60617: EMPTY
60618: LIST
60619: LIST
60620: PPUSH
60621: CALL_OW 2
60625: ST_TO_ADDR
60626: GO 60708
// for j := 1 to result do
60628: LD_ADDR_VAR 0 8
60632: PUSH
60633: DOUBLE
60634: LD_INT 1
60636: DEC
60637: ST_TO_ADDR
60638: LD_VAR 0 6
60642: PUSH
60643: FOR_TO
60644: IFFALSE 60706
// begin if tmp < result [ j ] [ 2 ] then
60646: LD_VAR 0 9
60650: PUSH
60651: LD_VAR 0 6
60655: PUSH
60656: LD_VAR 0 8
60660: ARRAY
60661: PUSH
60662: LD_INT 2
60664: ARRAY
60665: LESS
60666: IFFALSE 60704
// begin result := Insert ( result , j , [ i , tmp ] ) ;
60668: LD_ADDR_VAR 0 6
60672: PUSH
60673: LD_VAR 0 6
60677: PPUSH
60678: LD_VAR 0 8
60682: PPUSH
60683: LD_VAR 0 7
60687: PUSH
60688: LD_VAR 0 9
60692: PUSH
60693: EMPTY
60694: LIST
60695: LIST
60696: PPUSH
60697: CALL_OW 2
60701: ST_TO_ADDR
// break ;
60702: GO 60706
// end ; end ;
60704: GO 60643
60706: POP
60707: POP
// end ; end ;
60708: GO 60507
60710: POP
60711: POP
// if result and not asc then
60712: LD_VAR 0 6
60716: IFFALSE 60725
60718: PUSH
60719: LD_VAR 0 4
60723: NOT
60724: AND
60725: IFFALSE 60800
// begin tmp := result ;
60727: LD_ADDR_VAR 0 9
60731: PUSH
60732: LD_VAR 0 6
60736: ST_TO_ADDR
// for i = tmp downto 1 do
60737: LD_ADDR_VAR 0 7
60741: PUSH
60742: DOUBLE
60743: LD_VAR 0 9
60747: INC
60748: ST_TO_ADDR
60749: LD_INT 1
60751: PUSH
60752: FOR_DOWNTO
60753: IFFALSE 60798
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
60755: LD_ADDR_VAR 0 6
60759: PUSH
60760: LD_VAR 0 6
60764: PPUSH
60765: LD_VAR 0 9
60769: PUSH
60770: LD_VAR 0 7
60774: MINUS
60775: PUSH
60776: LD_INT 1
60778: PLUS
60779: PPUSH
60780: LD_VAR 0 9
60784: PUSH
60785: LD_VAR 0 7
60789: ARRAY
60790: PPUSH
60791: CALL_OW 1
60795: ST_TO_ADDR
60796: GO 60752
60798: POP
60799: POP
// end ; tmp := [ ] ;
60800: LD_ADDR_VAR 0 9
60804: PUSH
60805: EMPTY
60806: ST_TO_ADDR
// if mode then
60807: LD_VAR 0 5
60811: IFFALSE 60880
// begin for i = 1 to result do
60813: LD_ADDR_VAR 0 7
60817: PUSH
60818: DOUBLE
60819: LD_INT 1
60821: DEC
60822: ST_TO_ADDR
60823: LD_VAR 0 6
60827: PUSH
60828: FOR_TO
60829: IFFALSE 60868
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
60831: LD_ADDR_VAR 0 9
60835: PUSH
60836: LD_VAR 0 9
60840: PPUSH
60841: LD_VAR 0 7
60845: PPUSH
60846: LD_VAR 0 6
60850: PUSH
60851: LD_VAR 0 7
60855: ARRAY
60856: PUSH
60857: LD_INT 1
60859: ARRAY
60860: PPUSH
60861: CALL_OW 1
60865: ST_TO_ADDR
60866: GO 60828
60868: POP
60869: POP
// result := tmp ;
60870: LD_ADDR_VAR 0 6
60874: PUSH
60875: LD_VAR 0 9
60879: ST_TO_ADDR
// end ; end ;
60880: LD_VAR 0 6
60884: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
60885: LD_INT 0
60887: PPUSH
60888: PPUSH
60889: PPUSH
60890: PPUSH
60891: PPUSH
60892: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
60893: LD_ADDR_VAR 0 5
60897: PUSH
60898: LD_INT 0
60900: PUSH
60901: LD_INT 0
60903: PUSH
60904: LD_INT 0
60906: PUSH
60907: EMPTY
60908: PUSH
60909: EMPTY
60910: LIST
60911: LIST
60912: LIST
60913: LIST
60914: ST_TO_ADDR
// if not x or not y then
60915: LD_VAR 0 2
60919: NOT
60920: IFTRUE 60929
60922: PUSH
60923: LD_VAR 0 3
60927: NOT
60928: OR
60929: IFFALSE 60933
// exit ;
60931: GO 62589
// if not range then
60933: LD_VAR 0 4
60937: NOT
60938: IFFALSE 60948
// range := 10 ;
60940: LD_ADDR_VAR 0 4
60944: PUSH
60945: LD_INT 10
60947: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
60948: LD_ADDR_VAR 0 8
60952: PUSH
60953: LD_INT 81
60955: PUSH
60956: LD_VAR 0 1
60960: PUSH
60961: EMPTY
60962: LIST
60963: LIST
60964: PUSH
60965: LD_INT 92
60967: PUSH
60968: LD_VAR 0 2
60972: PUSH
60973: LD_VAR 0 3
60977: PUSH
60978: LD_VAR 0 4
60982: PUSH
60983: EMPTY
60984: LIST
60985: LIST
60986: LIST
60987: LIST
60988: PUSH
60989: LD_INT 3
60991: PUSH
60992: LD_INT 21
60994: PUSH
60995: LD_INT 3
60997: PUSH
60998: EMPTY
60999: LIST
61000: LIST
61001: PUSH
61002: EMPTY
61003: LIST
61004: LIST
61005: PUSH
61006: EMPTY
61007: LIST
61008: LIST
61009: LIST
61010: PPUSH
61011: CALL_OW 69
61015: ST_TO_ADDR
// if not tmp then
61016: LD_VAR 0 8
61020: NOT
61021: IFFALSE 61025
// exit ;
61023: GO 62589
// for i in tmp do
61025: LD_ADDR_VAR 0 6
61029: PUSH
61030: LD_VAR 0 8
61034: PUSH
61035: FOR_IN
61036: IFFALSE 62564
// begin points := [ 0 , 0 , 0 ] ;
61038: LD_ADDR_VAR 0 9
61042: PUSH
61043: LD_INT 0
61045: PUSH
61046: LD_INT 0
61048: PUSH
61049: LD_INT 0
61051: PUSH
61052: EMPTY
61053: LIST
61054: LIST
61055: LIST
61056: ST_TO_ADDR
// bpoints := 1 ;
61057: LD_ADDR_VAR 0 10
61061: PUSH
61062: LD_INT 1
61064: ST_TO_ADDR
// case GetType ( i ) of unit_human :
61065: LD_VAR 0 6
61069: PPUSH
61070: CALL_OW 247
61074: PUSH
61075: LD_INT 1
61077: DOUBLE
61078: EQUAL
61079: IFTRUE 61083
61081: GO 61665
61083: POP
// begin if GetClass ( i ) = 1 then
61084: LD_VAR 0 6
61088: PPUSH
61089: CALL_OW 257
61093: PUSH
61094: LD_INT 1
61096: EQUAL
61097: IFFALSE 61118
// points := [ 10 , 5 , 3 ] ;
61099: LD_ADDR_VAR 0 9
61103: PUSH
61104: LD_INT 10
61106: PUSH
61107: LD_INT 5
61109: PUSH
61110: LD_INT 3
61112: PUSH
61113: EMPTY
61114: LIST
61115: LIST
61116: LIST
61117: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
61118: LD_VAR 0 6
61122: PPUSH
61123: CALL_OW 257
61127: PUSH
61128: LD_INT 2
61130: PUSH
61131: LD_INT 3
61133: PUSH
61134: LD_INT 4
61136: PUSH
61137: EMPTY
61138: LIST
61139: LIST
61140: LIST
61141: IN
61142: IFFALSE 61163
// points := [ 3 , 2 , 1 ] ;
61144: LD_ADDR_VAR 0 9
61148: PUSH
61149: LD_INT 3
61151: PUSH
61152: LD_INT 2
61154: PUSH
61155: LD_INT 1
61157: PUSH
61158: EMPTY
61159: LIST
61160: LIST
61161: LIST
61162: ST_TO_ADDR
// if GetClass ( i ) = 5 then
61163: LD_VAR 0 6
61167: PPUSH
61168: CALL_OW 257
61172: PUSH
61173: LD_INT 5
61175: EQUAL
61176: IFFALSE 61197
// points := [ 130 , 5 , 2 ] ;
61178: LD_ADDR_VAR 0 9
61182: PUSH
61183: LD_INT 130
61185: PUSH
61186: LD_INT 5
61188: PUSH
61189: LD_INT 2
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: LIST
61196: ST_TO_ADDR
// if GetClass ( i ) = 8 then
61197: LD_VAR 0 6
61201: PPUSH
61202: CALL_OW 257
61206: PUSH
61207: LD_INT 8
61209: EQUAL
61210: IFFALSE 61231
// points := [ 35 , 35 , 30 ] ;
61212: LD_ADDR_VAR 0 9
61216: PUSH
61217: LD_INT 35
61219: PUSH
61220: LD_INT 35
61222: PUSH
61223: LD_INT 30
61225: PUSH
61226: EMPTY
61227: LIST
61228: LIST
61229: LIST
61230: ST_TO_ADDR
// if GetClass ( i ) = 9 then
61231: LD_VAR 0 6
61235: PPUSH
61236: CALL_OW 257
61240: PUSH
61241: LD_INT 9
61243: EQUAL
61244: IFFALSE 61265
// points := [ 20 , 55 , 40 ] ;
61246: LD_ADDR_VAR 0 9
61250: PUSH
61251: LD_INT 20
61253: PUSH
61254: LD_INT 55
61256: PUSH
61257: LD_INT 40
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: LIST
61264: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
61265: LD_VAR 0 6
61269: PPUSH
61270: CALL_OW 257
61274: PUSH
61275: LD_INT 12
61277: PUSH
61278: LD_INT 16
61280: PUSH
61281: EMPTY
61282: LIST
61283: LIST
61284: IN
61285: IFFALSE 61306
// points := [ 5 , 3 , 2 ] ;
61287: LD_ADDR_VAR 0 9
61291: PUSH
61292: LD_INT 5
61294: PUSH
61295: LD_INT 3
61297: PUSH
61298: LD_INT 2
61300: PUSH
61301: EMPTY
61302: LIST
61303: LIST
61304: LIST
61305: ST_TO_ADDR
// if GetClass ( i ) = 17 then
61306: LD_VAR 0 6
61310: PPUSH
61311: CALL_OW 257
61315: PUSH
61316: LD_INT 17
61318: EQUAL
61319: IFFALSE 61340
// points := [ 100 , 50 , 75 ] ;
61321: LD_ADDR_VAR 0 9
61325: PUSH
61326: LD_INT 100
61328: PUSH
61329: LD_INT 50
61331: PUSH
61332: LD_INT 75
61334: PUSH
61335: EMPTY
61336: LIST
61337: LIST
61338: LIST
61339: ST_TO_ADDR
// if GetClass ( i ) = 15 then
61340: LD_VAR 0 6
61344: PPUSH
61345: CALL_OW 257
61349: PUSH
61350: LD_INT 15
61352: EQUAL
61353: IFFALSE 61374
// points := [ 10 , 5 , 3 ] ;
61355: LD_ADDR_VAR 0 9
61359: PUSH
61360: LD_INT 10
61362: PUSH
61363: LD_INT 5
61365: PUSH
61366: LD_INT 3
61368: PUSH
61369: EMPTY
61370: LIST
61371: LIST
61372: LIST
61373: ST_TO_ADDR
// if GetClass ( i ) = 14 then
61374: LD_VAR 0 6
61378: PPUSH
61379: CALL_OW 257
61383: PUSH
61384: LD_INT 14
61386: EQUAL
61387: IFFALSE 61408
// points := [ 10 , 0 , 0 ] ;
61389: LD_ADDR_VAR 0 9
61393: PUSH
61394: LD_INT 10
61396: PUSH
61397: LD_INT 0
61399: PUSH
61400: LD_INT 0
61402: PUSH
61403: EMPTY
61404: LIST
61405: LIST
61406: LIST
61407: ST_TO_ADDR
// if GetClass ( i ) = 11 then
61408: LD_VAR 0 6
61412: PPUSH
61413: CALL_OW 257
61417: PUSH
61418: LD_INT 11
61420: EQUAL
61421: IFFALSE 61442
// points := [ 30 , 10 , 5 ] ;
61423: LD_ADDR_VAR 0 9
61427: PUSH
61428: LD_INT 30
61430: PUSH
61431: LD_INT 10
61433: PUSH
61434: LD_INT 5
61436: PUSH
61437: EMPTY
61438: LIST
61439: LIST
61440: LIST
61441: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
61442: LD_VAR 0 1
61446: PPUSH
61447: LD_INT 5
61449: PPUSH
61450: CALL_OW 321
61454: PUSH
61455: LD_INT 2
61457: EQUAL
61458: IFFALSE 61475
// bpoints := bpoints * 1.8 ;
61460: LD_ADDR_VAR 0 10
61464: PUSH
61465: LD_VAR 0 10
61469: PUSH
61470: LD_REAL  1.80000000000000E+0000
61473: MUL
61474: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
61475: LD_VAR 0 6
61479: PPUSH
61480: CALL_OW 257
61484: PUSH
61485: LD_INT 1
61487: PUSH
61488: LD_INT 2
61490: PUSH
61491: LD_INT 3
61493: PUSH
61494: LD_INT 4
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: LIST
61501: LIST
61502: IN
61503: IFFALSE 61523
61505: PUSH
61506: LD_VAR 0 1
61510: PPUSH
61511: LD_INT 51
61513: PPUSH
61514: CALL_OW 321
61518: PUSH
61519: LD_INT 2
61521: EQUAL
61522: AND
61523: IFFALSE 61540
// bpoints := bpoints * 1.2 ;
61525: LD_ADDR_VAR 0 10
61529: PUSH
61530: LD_VAR 0 10
61534: PUSH
61535: LD_REAL  1.20000000000000E+0000
61538: MUL
61539: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
61540: LD_VAR 0 6
61544: PPUSH
61545: CALL_OW 257
61549: PUSH
61550: LD_INT 5
61552: PUSH
61553: LD_INT 7
61555: PUSH
61556: LD_INT 9
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: LIST
61563: IN
61564: IFFALSE 61584
61566: PUSH
61567: LD_VAR 0 1
61571: PPUSH
61572: LD_INT 52
61574: PPUSH
61575: CALL_OW 321
61579: PUSH
61580: LD_INT 2
61582: EQUAL
61583: AND
61584: IFFALSE 61601
// bpoints := bpoints * 1.5 ;
61586: LD_ADDR_VAR 0 10
61590: PUSH
61591: LD_VAR 0 10
61595: PUSH
61596: LD_REAL  1.50000000000000E+0000
61599: MUL
61600: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
61601: LD_VAR 0 1
61605: PPUSH
61606: LD_INT 66
61608: PPUSH
61609: CALL_OW 321
61613: PUSH
61614: LD_INT 2
61616: EQUAL
61617: IFFALSE 61634
// bpoints := bpoints * 1.1 ;
61619: LD_ADDR_VAR 0 10
61623: PUSH
61624: LD_VAR 0 10
61628: PUSH
61629: LD_REAL  1.10000000000000E+0000
61632: MUL
61633: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
61634: LD_ADDR_VAR 0 10
61638: PUSH
61639: LD_VAR 0 10
61643: PUSH
61644: LD_VAR 0 6
61648: PPUSH
61649: LD_INT 1
61651: PPUSH
61652: CALL_OW 259
61656: PUSH
61657: LD_REAL  1.15000000000000E+0000
61660: MUL
61661: MUL
61662: ST_TO_ADDR
// end ; unit_vehicle :
61663: GO 62493
61665: LD_INT 2
61667: DOUBLE
61668: EQUAL
61669: IFTRUE 61673
61671: GO 62481
61673: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
61674: LD_VAR 0 6
61678: PPUSH
61679: CALL_OW 264
61683: PUSH
61684: LD_INT 2
61686: PUSH
61687: LD_INT 42
61689: PUSH
61690: LD_INT 24
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: LIST
61697: IN
61698: IFFALSE 61719
// points := [ 25 , 5 , 3 ] ;
61700: LD_ADDR_VAR 0 9
61704: PUSH
61705: LD_INT 25
61707: PUSH
61708: LD_INT 5
61710: PUSH
61711: LD_INT 3
61713: PUSH
61714: EMPTY
61715: LIST
61716: LIST
61717: LIST
61718: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
61719: LD_VAR 0 6
61723: PPUSH
61724: CALL_OW 264
61728: PUSH
61729: LD_INT 4
61731: PUSH
61732: LD_INT 43
61734: PUSH
61735: LD_INT 25
61737: PUSH
61738: EMPTY
61739: LIST
61740: LIST
61741: LIST
61742: IN
61743: IFFALSE 61764
// points := [ 40 , 15 , 5 ] ;
61745: LD_ADDR_VAR 0 9
61749: PUSH
61750: LD_INT 40
61752: PUSH
61753: LD_INT 15
61755: PUSH
61756: LD_INT 5
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: LIST
61763: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
61764: LD_VAR 0 6
61768: PPUSH
61769: CALL_OW 264
61773: PUSH
61774: LD_INT 3
61776: PUSH
61777: LD_INT 23
61779: PUSH
61780: EMPTY
61781: LIST
61782: LIST
61783: IN
61784: IFFALSE 61805
// points := [ 7 , 25 , 8 ] ;
61786: LD_ADDR_VAR 0 9
61790: PUSH
61791: LD_INT 7
61793: PUSH
61794: LD_INT 25
61796: PUSH
61797: LD_INT 8
61799: PUSH
61800: EMPTY
61801: LIST
61802: LIST
61803: LIST
61804: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
61805: LD_VAR 0 6
61809: PPUSH
61810: CALL_OW 264
61814: PUSH
61815: LD_INT 5
61817: PUSH
61818: LD_INT 27
61820: PUSH
61821: LD_INT 44
61823: PUSH
61824: EMPTY
61825: LIST
61826: LIST
61827: LIST
61828: IN
61829: IFFALSE 61850
// points := [ 14 , 50 , 16 ] ;
61831: LD_ADDR_VAR 0 9
61835: PUSH
61836: LD_INT 14
61838: PUSH
61839: LD_INT 50
61841: PUSH
61842: LD_INT 16
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: LIST
61849: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
61850: LD_VAR 0 6
61854: PPUSH
61855: CALL_OW 264
61859: PUSH
61860: LD_INT 6
61862: PUSH
61863: LD_INT 46
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: IN
61870: IFFALSE 61891
// points := [ 32 , 120 , 70 ] ;
61872: LD_ADDR_VAR 0 9
61876: PUSH
61877: LD_INT 32
61879: PUSH
61880: LD_INT 120
61882: PUSH
61883: LD_INT 70
61885: PUSH
61886: EMPTY
61887: LIST
61888: LIST
61889: LIST
61890: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
61891: LD_VAR 0 6
61895: PPUSH
61896: CALL_OW 264
61900: PUSH
61901: LD_INT 7
61903: PUSH
61904: LD_INT 28
61906: PUSH
61907: LD_INT 45
61909: PUSH
61910: LD_INT 92
61912: PUSH
61913: EMPTY
61914: LIST
61915: LIST
61916: LIST
61917: LIST
61918: IN
61919: IFFALSE 61940
// points := [ 35 , 20 , 45 ] ;
61921: LD_ADDR_VAR 0 9
61925: PUSH
61926: LD_INT 35
61928: PUSH
61929: LD_INT 20
61931: PUSH
61932: LD_INT 45
61934: PUSH
61935: EMPTY
61936: LIST
61937: LIST
61938: LIST
61939: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
61940: LD_VAR 0 6
61944: PPUSH
61945: CALL_OW 264
61949: PUSH
61950: LD_INT 47
61952: PUSH
61953: EMPTY
61954: LIST
61955: IN
61956: IFFALSE 61977
// points := [ 67 , 45 , 75 ] ;
61958: LD_ADDR_VAR 0 9
61962: PUSH
61963: LD_INT 67
61965: PUSH
61966: LD_INT 45
61968: PUSH
61969: LD_INT 75
61971: PUSH
61972: EMPTY
61973: LIST
61974: LIST
61975: LIST
61976: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
61977: LD_VAR 0 6
61981: PPUSH
61982: CALL_OW 264
61986: PUSH
61987: LD_INT 26
61989: PUSH
61990: EMPTY
61991: LIST
61992: IN
61993: IFFALSE 62014
// points := [ 120 , 30 , 80 ] ;
61995: LD_ADDR_VAR 0 9
61999: PUSH
62000: LD_INT 120
62002: PUSH
62003: LD_INT 30
62005: PUSH
62006: LD_INT 80
62008: PUSH
62009: EMPTY
62010: LIST
62011: LIST
62012: LIST
62013: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
62014: LD_VAR 0 6
62018: PPUSH
62019: CALL_OW 264
62023: PUSH
62024: LD_INT 22
62026: PUSH
62027: EMPTY
62028: LIST
62029: IN
62030: IFFALSE 62051
// points := [ 40 , 1 , 1 ] ;
62032: LD_ADDR_VAR 0 9
62036: PUSH
62037: LD_INT 40
62039: PUSH
62040: LD_INT 1
62042: PUSH
62043: LD_INT 1
62045: PUSH
62046: EMPTY
62047: LIST
62048: LIST
62049: LIST
62050: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
62051: LD_VAR 0 6
62055: PPUSH
62056: CALL_OW 264
62060: PUSH
62061: LD_INT 29
62063: PUSH
62064: EMPTY
62065: LIST
62066: IN
62067: IFFALSE 62088
// points := [ 70 , 200 , 400 ] ;
62069: LD_ADDR_VAR 0 9
62073: PUSH
62074: LD_INT 70
62076: PUSH
62077: LD_INT 200
62079: PUSH
62080: LD_INT 400
62082: PUSH
62083: EMPTY
62084: LIST
62085: LIST
62086: LIST
62087: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
62088: LD_VAR 0 6
62092: PPUSH
62093: CALL_OW 264
62097: PUSH
62098: LD_INT 14
62100: PUSH
62101: LD_INT 53
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: IN
62108: IFFALSE 62129
// points := [ 40 , 10 , 20 ] ;
62110: LD_ADDR_VAR 0 9
62114: PUSH
62115: LD_INT 40
62117: PUSH
62118: LD_INT 10
62120: PUSH
62121: LD_INT 20
62123: PUSH
62124: EMPTY
62125: LIST
62126: LIST
62127: LIST
62128: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
62129: LD_VAR 0 6
62133: PPUSH
62134: CALL_OW 264
62138: PUSH
62139: LD_INT 9
62141: PUSH
62142: EMPTY
62143: LIST
62144: IN
62145: IFFALSE 62166
// points := [ 5 , 70 , 20 ] ;
62147: LD_ADDR_VAR 0 9
62151: PUSH
62152: LD_INT 5
62154: PUSH
62155: LD_INT 70
62157: PUSH
62158: LD_INT 20
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: LIST
62165: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
62166: LD_VAR 0 6
62170: PPUSH
62171: CALL_OW 264
62175: PUSH
62176: LD_INT 10
62178: PUSH
62179: EMPTY
62180: LIST
62181: IN
62182: IFFALSE 62203
// points := [ 35 , 110 , 70 ] ;
62184: LD_ADDR_VAR 0 9
62188: PUSH
62189: LD_INT 35
62191: PUSH
62192: LD_INT 110
62194: PUSH
62195: LD_INT 70
62197: PUSH
62198: EMPTY
62199: LIST
62200: LIST
62201: LIST
62202: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
62203: LD_VAR 0 6
62207: PPUSH
62208: CALL_OW 265
62212: PUSH
62213: LD_INT 25
62215: EQUAL
62216: IFFALSE 62237
// points := [ 80 , 65 , 100 ] ;
62218: LD_ADDR_VAR 0 9
62222: PUSH
62223: LD_INT 80
62225: PUSH
62226: LD_INT 65
62228: PUSH
62229: LD_INT 100
62231: PUSH
62232: EMPTY
62233: LIST
62234: LIST
62235: LIST
62236: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
62237: LD_VAR 0 6
62241: PPUSH
62242: CALL_OW 263
62246: PUSH
62247: LD_INT 1
62249: EQUAL
62250: IFFALSE 62285
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
62252: LD_ADDR_VAR 0 10
62256: PUSH
62257: LD_VAR 0 10
62261: PUSH
62262: LD_VAR 0 6
62266: PPUSH
62267: CALL_OW 311
62271: PPUSH
62272: LD_INT 3
62274: PPUSH
62275: CALL_OW 259
62279: PUSH
62280: LD_INT 4
62282: MUL
62283: MUL
62284: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
62285: LD_VAR 0 6
62289: PPUSH
62290: CALL_OW 263
62294: PUSH
62295: LD_INT 2
62297: EQUAL
62298: IFFALSE 62349
// begin j := IsControledBy ( i ) ;
62300: LD_ADDR_VAR 0 7
62304: PUSH
62305: LD_VAR 0 6
62309: PPUSH
62310: CALL_OW 312
62314: ST_TO_ADDR
// if j then
62315: LD_VAR 0 7
62319: IFFALSE 62349
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
62321: LD_ADDR_VAR 0 10
62325: PUSH
62326: LD_VAR 0 10
62330: PUSH
62331: LD_VAR 0 7
62335: PPUSH
62336: LD_INT 3
62338: PPUSH
62339: CALL_OW 259
62343: PUSH
62344: LD_INT 3
62346: MUL
62347: MUL
62348: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
62349: LD_VAR 0 6
62353: PPUSH
62354: CALL_OW 264
62358: PUSH
62359: LD_INT 5
62361: PUSH
62362: LD_INT 6
62364: PUSH
62365: LD_INT 46
62367: PUSH
62368: LD_INT 44
62370: PUSH
62371: LD_INT 47
62373: PUSH
62374: LD_INT 45
62376: PUSH
62377: LD_INT 28
62379: PUSH
62380: LD_INT 7
62382: PUSH
62383: LD_INT 27
62385: PUSH
62386: LD_INT 29
62388: PUSH
62389: EMPTY
62390: LIST
62391: LIST
62392: LIST
62393: LIST
62394: LIST
62395: LIST
62396: LIST
62397: LIST
62398: LIST
62399: LIST
62400: IN
62401: IFFALSE 62421
62403: PUSH
62404: LD_VAR 0 1
62408: PPUSH
62409: LD_INT 52
62411: PPUSH
62412: CALL_OW 321
62416: PUSH
62417: LD_INT 2
62419: EQUAL
62420: AND
62421: IFFALSE 62438
// bpoints := bpoints * 1.2 ;
62423: LD_ADDR_VAR 0 10
62427: PUSH
62428: LD_VAR 0 10
62432: PUSH
62433: LD_REAL  1.20000000000000E+0000
62436: MUL
62437: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
62438: LD_VAR 0 6
62442: PPUSH
62443: CALL_OW 264
62447: PUSH
62448: LD_INT 6
62450: PUSH
62451: LD_INT 46
62453: PUSH
62454: LD_INT 47
62456: PUSH
62457: EMPTY
62458: LIST
62459: LIST
62460: LIST
62461: IN
62462: IFFALSE 62479
// bpoints := bpoints * 1.2 ;
62464: LD_ADDR_VAR 0 10
62468: PUSH
62469: LD_VAR 0 10
62473: PUSH
62474: LD_REAL  1.20000000000000E+0000
62477: MUL
62478: ST_TO_ADDR
// end ; unit_building :
62479: GO 62493
62481: LD_INT 3
62483: DOUBLE
62484: EQUAL
62485: IFTRUE 62489
62487: GO 62492
62489: POP
// ; end ;
62490: GO 62493
62492: POP
// for j = 1 to 3 do
62493: LD_ADDR_VAR 0 7
62497: PUSH
62498: DOUBLE
62499: LD_INT 1
62501: DEC
62502: ST_TO_ADDR
62503: LD_INT 3
62505: PUSH
62506: FOR_TO
62507: IFFALSE 62560
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
62509: LD_ADDR_VAR 0 5
62513: PUSH
62514: LD_VAR 0 5
62518: PPUSH
62519: LD_VAR 0 7
62523: PPUSH
62524: LD_VAR 0 5
62528: PUSH
62529: LD_VAR 0 7
62533: ARRAY
62534: PUSH
62535: LD_VAR 0 9
62539: PUSH
62540: LD_VAR 0 7
62544: ARRAY
62545: PUSH
62546: LD_VAR 0 10
62550: MUL
62551: PLUS
62552: PPUSH
62553: CALL_OW 1
62557: ST_TO_ADDR
62558: GO 62506
62560: POP
62561: POP
// end ;
62562: GO 61035
62564: POP
62565: POP
// result := Replace ( result , 4 , tmp ) ;
62566: LD_ADDR_VAR 0 5
62570: PUSH
62571: LD_VAR 0 5
62575: PPUSH
62576: LD_INT 4
62578: PPUSH
62579: LD_VAR 0 8
62583: PPUSH
62584: CALL_OW 1
62588: ST_TO_ADDR
// end ;
62589: LD_VAR 0 5
62593: RET
// export function DangerAtRange ( unit , range ) ; begin
62594: LD_INT 0
62596: PPUSH
// if not unit then
62597: LD_VAR 0 1
62601: NOT
62602: IFFALSE 62606
// exit ;
62604: GO 62651
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
62606: LD_ADDR_VAR 0 3
62610: PUSH
62611: LD_VAR 0 1
62615: PPUSH
62616: CALL_OW 255
62620: PPUSH
62621: LD_VAR 0 1
62625: PPUSH
62626: CALL_OW 250
62630: PPUSH
62631: LD_VAR 0 1
62635: PPUSH
62636: CALL_OW 251
62640: PPUSH
62641: LD_VAR 0 2
62645: PPUSH
62646: CALL 60885 0 4
62650: ST_TO_ADDR
// end ;
62651: LD_VAR 0 3
62655: RET
// export function DangerInArea ( side , area ) ; begin
62656: LD_INT 0
62658: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
62659: LD_ADDR_VAR 0 3
62663: PUSH
62664: LD_VAR 0 2
62668: PPUSH
62669: LD_INT 81
62671: PUSH
62672: LD_VAR 0 1
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: PPUSH
62681: CALL_OW 70
62685: ST_TO_ADDR
// end ;
62686: LD_VAR 0 3
62690: RET
// export function IsExtension ( b ) ; begin
62691: LD_INT 0
62693: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
62694: LD_ADDR_VAR 0 2
62698: PUSH
62699: LD_VAR 0 1
62703: PUSH
62704: LD_INT 23
62706: PUSH
62707: LD_INT 20
62709: PUSH
62710: LD_INT 22
62712: PUSH
62713: LD_INT 17
62715: PUSH
62716: LD_INT 24
62718: PUSH
62719: LD_INT 21
62721: PUSH
62722: LD_INT 19
62724: PUSH
62725: LD_INT 16
62727: PUSH
62728: LD_INT 25
62730: PUSH
62731: LD_INT 18
62733: PUSH
62734: EMPTY
62735: LIST
62736: LIST
62737: LIST
62738: LIST
62739: LIST
62740: LIST
62741: LIST
62742: LIST
62743: LIST
62744: LIST
62745: IN
62746: ST_TO_ADDR
// end ;
62747: LD_VAR 0 2
62751: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
62752: LD_INT 0
62754: PPUSH
62755: PPUSH
62756: PPUSH
// result := [ ] ;
62757: LD_ADDR_VAR 0 4
62761: PUSH
62762: EMPTY
62763: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
62764: LD_ADDR_VAR 0 5
62768: PUSH
62769: LD_VAR 0 2
62773: PPUSH
62774: LD_INT 21
62776: PUSH
62777: LD_INT 3
62779: PUSH
62780: EMPTY
62781: LIST
62782: LIST
62783: PPUSH
62784: CALL_OW 70
62788: ST_TO_ADDR
// if not tmp then
62789: LD_VAR 0 5
62793: NOT
62794: IFFALSE 62798
// exit ;
62796: GO 62862
// if checkLink then
62798: LD_VAR 0 3
62802: IFFALSE 62852
// begin for i in tmp do
62804: LD_ADDR_VAR 0 6
62808: PUSH
62809: LD_VAR 0 5
62813: PUSH
62814: FOR_IN
62815: IFFALSE 62850
// if GetBase ( i ) <> base then
62817: LD_VAR 0 6
62821: PPUSH
62822: CALL_OW 274
62826: PUSH
62827: LD_VAR 0 1
62831: NONEQUAL
62832: IFFALSE 62848
// ComLinkToBase ( base , i ) ;
62834: LD_VAR 0 1
62838: PPUSH
62839: LD_VAR 0 6
62843: PPUSH
62844: CALL_OW 169
62848: GO 62814
62850: POP
62851: POP
// end ; result := tmp ;
62852: LD_ADDR_VAR 0 4
62856: PUSH
62857: LD_VAR 0 5
62861: ST_TO_ADDR
// end ;
62862: LD_VAR 0 4
62866: RET
// export function ComComplete ( units , b ) ; var i ; begin
62867: LD_INT 0
62869: PPUSH
62870: PPUSH
// if not units then
62871: LD_VAR 0 1
62875: NOT
62876: IFFALSE 62880
// exit ;
62878: GO 62970
// for i in units do
62880: LD_ADDR_VAR 0 4
62884: PUSH
62885: LD_VAR 0 1
62889: PUSH
62890: FOR_IN
62891: IFFALSE 62968
// if BuildingStatus ( b ) = bs_build then
62893: LD_VAR 0 2
62897: PPUSH
62898: CALL_OW 461
62902: PUSH
62903: LD_INT 1
62905: EQUAL
62906: IFFALSE 62966
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
62908: LD_VAR 0 4
62912: PPUSH
62913: LD_STRING h
62915: PUSH
62916: LD_VAR 0 2
62920: PPUSH
62921: CALL_OW 250
62925: PUSH
62926: LD_VAR 0 2
62930: PPUSH
62931: CALL_OW 251
62935: PUSH
62936: LD_VAR 0 2
62940: PUSH
62941: LD_INT 0
62943: PUSH
62944: LD_INT 0
62946: PUSH
62947: LD_INT 0
62949: PUSH
62950: EMPTY
62951: LIST
62952: LIST
62953: LIST
62954: LIST
62955: LIST
62956: LIST
62957: LIST
62958: PUSH
62959: EMPTY
62960: LIST
62961: PPUSH
62962: CALL_OW 446
62966: GO 62890
62968: POP
62969: POP
// end ;
62970: LD_VAR 0 3
62974: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
62975: LD_INT 0
62977: PPUSH
62978: PPUSH
62979: PPUSH
62980: PPUSH
62981: PPUSH
62982: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
62983: LD_VAR 0 1
62987: NOT
62988: IFTRUE 63005
62990: PUSH
62991: LD_VAR 0 1
62995: PPUSH
62996: CALL_OW 263
63000: PUSH
63001: LD_INT 2
63003: NONEQUAL
63004: OR
63005: IFFALSE 63009
// exit ;
63007: GO 63325
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
63009: LD_ADDR_VAR 0 6
63013: PUSH
63014: LD_INT 22
63016: PUSH
63017: LD_VAR 0 1
63021: PPUSH
63022: CALL_OW 255
63026: PUSH
63027: EMPTY
63028: LIST
63029: LIST
63030: PUSH
63031: LD_INT 2
63033: PUSH
63034: LD_INT 30
63036: PUSH
63037: LD_INT 36
63039: PUSH
63040: EMPTY
63041: LIST
63042: LIST
63043: PUSH
63044: LD_INT 34
63046: PUSH
63047: LD_INT 31
63049: PUSH
63050: EMPTY
63051: LIST
63052: LIST
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: LIST
63058: PUSH
63059: EMPTY
63060: LIST
63061: LIST
63062: PPUSH
63063: CALL_OW 69
63067: ST_TO_ADDR
// if not tmp then
63068: LD_VAR 0 6
63072: NOT
63073: IFFALSE 63077
// exit ;
63075: GO 63325
// result := [ ] ;
63077: LD_ADDR_VAR 0 2
63081: PUSH
63082: EMPTY
63083: ST_TO_ADDR
// for i in tmp do
63084: LD_ADDR_VAR 0 3
63088: PUSH
63089: LD_VAR 0 6
63093: PUSH
63094: FOR_IN
63095: IFFALSE 63166
// begin t := UnitsInside ( i ) ;
63097: LD_ADDR_VAR 0 4
63101: PUSH
63102: LD_VAR 0 3
63106: PPUSH
63107: CALL_OW 313
63111: ST_TO_ADDR
// if t then
63112: LD_VAR 0 4
63116: IFFALSE 63164
// for j in t do
63118: LD_ADDR_VAR 0 7
63122: PUSH
63123: LD_VAR 0 4
63127: PUSH
63128: FOR_IN
63129: IFFALSE 63162
// result := Replace ( result , result + 1 , j ) ;
63131: LD_ADDR_VAR 0 2
63135: PUSH
63136: LD_VAR 0 2
63140: PPUSH
63141: LD_VAR 0 2
63145: PUSH
63146: LD_INT 1
63148: PLUS
63149: PPUSH
63150: LD_VAR 0 7
63154: PPUSH
63155: CALL_OW 1
63159: ST_TO_ADDR
63160: GO 63128
63162: POP
63163: POP
// end ;
63164: GO 63094
63166: POP
63167: POP
// if not result then
63168: LD_VAR 0 2
63172: NOT
63173: IFFALSE 63177
// exit ;
63175: GO 63325
// mech := result [ 1 ] ;
63177: LD_ADDR_VAR 0 5
63181: PUSH
63182: LD_VAR 0 2
63186: PUSH
63187: LD_INT 1
63189: ARRAY
63190: ST_TO_ADDR
// if result > 1 then
63191: LD_VAR 0 2
63195: PUSH
63196: LD_INT 1
63198: GREATER
63199: IFFALSE 63311
// begin for i = 2 to result do
63201: LD_ADDR_VAR 0 3
63205: PUSH
63206: DOUBLE
63207: LD_INT 2
63209: DEC
63210: ST_TO_ADDR
63211: LD_VAR 0 2
63215: PUSH
63216: FOR_TO
63217: IFFALSE 63309
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
63219: LD_ADDR_VAR 0 4
63223: PUSH
63224: LD_VAR 0 2
63228: PUSH
63229: LD_VAR 0 3
63233: ARRAY
63234: PPUSH
63235: LD_INT 3
63237: PPUSH
63238: CALL_OW 259
63242: PUSH
63243: LD_VAR 0 2
63247: PUSH
63248: LD_VAR 0 3
63252: ARRAY
63253: PPUSH
63254: CALL_OW 432
63258: MINUS
63259: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
63260: LD_VAR 0 4
63264: PUSH
63265: LD_VAR 0 5
63269: PPUSH
63270: LD_INT 3
63272: PPUSH
63273: CALL_OW 259
63277: PUSH
63278: LD_VAR 0 5
63282: PPUSH
63283: CALL_OW 432
63287: MINUS
63288: GREATEREQUAL
63289: IFFALSE 63307
// mech := result [ i ] ;
63291: LD_ADDR_VAR 0 5
63295: PUSH
63296: LD_VAR 0 2
63300: PUSH
63301: LD_VAR 0 3
63305: ARRAY
63306: ST_TO_ADDR
// end ;
63307: GO 63216
63309: POP
63310: POP
// end ; ComLinkTo ( vehicle , mech ) ;
63311: LD_VAR 0 1
63315: PPUSH
63316: LD_VAR 0 5
63320: PPUSH
63321: CALL_OW 135
// end ;
63325: LD_VAR 0 2
63329: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
63330: LD_INT 0
63332: PPUSH
63333: PPUSH
63334: PPUSH
63335: PPUSH
63336: PPUSH
63337: PPUSH
63338: PPUSH
63339: PPUSH
63340: PPUSH
63341: PPUSH
63342: PPUSH
63343: PPUSH
63344: PPUSH
// result := [ ] ;
63345: LD_ADDR_VAR 0 7
63349: PUSH
63350: EMPTY
63351: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
63352: LD_VAR 0 1
63356: PPUSH
63357: CALL_OW 266
63361: PUSH
63362: LD_INT 0
63364: PUSH
63365: LD_INT 1
63367: PUSH
63368: EMPTY
63369: LIST
63370: LIST
63371: IN
63372: NOT
63373: IFFALSE 63377
// exit ;
63375: GO 65017
// if name then
63377: LD_VAR 0 3
63381: IFFALSE 63397
// SetBName ( base_dep , name ) ;
63383: LD_VAR 0 1
63387: PPUSH
63388: LD_VAR 0 3
63392: PPUSH
63393: CALL_OW 500
// base := GetBase ( base_dep ) ;
63397: LD_ADDR_VAR 0 15
63401: PUSH
63402: LD_VAR 0 1
63406: PPUSH
63407: CALL_OW 274
63411: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
63412: LD_ADDR_VAR 0 16
63416: PUSH
63417: LD_VAR 0 1
63421: PPUSH
63422: CALL_OW 255
63426: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
63427: LD_ADDR_VAR 0 17
63431: PUSH
63432: LD_VAR 0 1
63436: PPUSH
63437: CALL_OW 248
63441: ST_TO_ADDR
// if sources then
63442: LD_VAR 0 5
63446: IFFALSE 63493
// for i = 1 to 3 do
63448: LD_ADDR_VAR 0 8
63452: PUSH
63453: DOUBLE
63454: LD_INT 1
63456: DEC
63457: ST_TO_ADDR
63458: LD_INT 3
63460: PUSH
63461: FOR_TO
63462: IFFALSE 63491
// AddResourceType ( base , i , sources [ i ] ) ;
63464: LD_VAR 0 15
63468: PPUSH
63469: LD_VAR 0 8
63473: PPUSH
63474: LD_VAR 0 5
63478: PUSH
63479: LD_VAR 0 8
63483: ARRAY
63484: PPUSH
63485: CALL_OW 276
63489: GO 63461
63491: POP
63492: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
63493: LD_ADDR_VAR 0 18
63497: PUSH
63498: LD_VAR 0 15
63502: PPUSH
63503: LD_VAR 0 2
63507: PPUSH
63508: LD_INT 1
63510: PPUSH
63511: CALL 62752 0 3
63515: ST_TO_ADDR
// InitHc ;
63516: CALL_OW 19
// InitUc ;
63520: CALL_OW 18
// uc_side := side ;
63524: LD_ADDR_OWVAR 20
63528: PUSH
63529: LD_VAR 0 16
63533: ST_TO_ADDR
// uc_nation := nation ;
63534: LD_ADDR_OWVAR 21
63538: PUSH
63539: LD_VAR 0 17
63543: ST_TO_ADDR
// if buildings then
63544: LD_VAR 0 18
63548: IFFALSE 64876
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
63550: LD_ADDR_VAR 0 19
63554: PUSH
63555: LD_VAR 0 18
63559: PPUSH
63560: LD_INT 2
63562: PUSH
63563: LD_INT 30
63565: PUSH
63566: LD_INT 29
63568: PUSH
63569: EMPTY
63570: LIST
63571: LIST
63572: PUSH
63573: LD_INT 30
63575: PUSH
63576: LD_INT 30
63578: PUSH
63579: EMPTY
63580: LIST
63581: LIST
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: LIST
63587: PPUSH
63588: CALL_OW 72
63592: ST_TO_ADDR
// if tmp then
63593: LD_VAR 0 19
63597: IFFALSE 63645
// for i in tmp do
63599: LD_ADDR_VAR 0 8
63603: PUSH
63604: LD_VAR 0 19
63608: PUSH
63609: FOR_IN
63610: IFFALSE 63643
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
63612: LD_VAR 0 8
63616: PPUSH
63617: CALL_OW 250
63621: PPUSH
63622: LD_VAR 0 8
63626: PPUSH
63627: CALL_OW 251
63631: PPUSH
63632: LD_VAR 0 16
63636: PPUSH
63637: CALL_OW 441
63641: GO 63609
63643: POP
63644: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
63645: LD_VAR 0 18
63649: PPUSH
63650: LD_INT 2
63652: PUSH
63653: LD_INT 30
63655: PUSH
63656: LD_INT 32
63658: PUSH
63659: EMPTY
63660: LIST
63661: LIST
63662: PUSH
63663: LD_INT 30
63665: PUSH
63666: LD_INT 33
63668: PUSH
63669: EMPTY
63670: LIST
63671: LIST
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: LIST
63677: PPUSH
63678: CALL_OW 72
63682: IFFALSE 63770
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
63684: LD_ADDR_VAR 0 8
63688: PUSH
63689: LD_VAR 0 18
63693: PPUSH
63694: LD_INT 2
63696: PUSH
63697: LD_INT 30
63699: PUSH
63700: LD_INT 32
63702: PUSH
63703: EMPTY
63704: LIST
63705: LIST
63706: PUSH
63707: LD_INT 30
63709: PUSH
63710: LD_INT 33
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: LIST
63721: PPUSH
63722: CALL_OW 72
63726: PUSH
63727: FOR_IN
63728: IFFALSE 63768
// begin if not GetBWeapon ( i ) then
63730: LD_VAR 0 8
63734: PPUSH
63735: CALL_OW 269
63739: NOT
63740: IFFALSE 63766
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
63742: LD_VAR 0 8
63746: PPUSH
63747: LD_VAR 0 8
63751: PPUSH
63752: LD_VAR 0 2
63756: PPUSH
63757: CALL 65022 0 2
63761: PPUSH
63762: CALL_OW 431
// end ;
63766: GO 63727
63768: POP
63769: POP
// end ; for i = 1 to personel do
63770: LD_ADDR_VAR 0 8
63774: PUSH
63775: DOUBLE
63776: LD_INT 1
63778: DEC
63779: ST_TO_ADDR
63780: LD_VAR 0 6
63784: PUSH
63785: FOR_TO
63786: IFFALSE 64856
// begin if i > 4 then
63788: LD_VAR 0 8
63792: PUSH
63793: LD_INT 4
63795: GREATER
63796: IFFALSE 63800
// break ;
63798: GO 64856
// case i of 1 :
63800: LD_VAR 0 8
63804: PUSH
63805: LD_INT 1
63807: DOUBLE
63808: EQUAL
63809: IFTRUE 63813
63811: GO 63893
63813: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
63814: LD_ADDR_VAR 0 12
63818: PUSH
63819: LD_VAR 0 18
63823: PPUSH
63824: LD_INT 22
63826: PUSH
63827: LD_VAR 0 16
63831: PUSH
63832: EMPTY
63833: LIST
63834: LIST
63835: PUSH
63836: LD_INT 58
63838: PUSH
63839: EMPTY
63840: LIST
63841: PUSH
63842: LD_INT 2
63844: PUSH
63845: LD_INT 30
63847: PUSH
63848: LD_INT 32
63850: PUSH
63851: EMPTY
63852: LIST
63853: LIST
63854: PUSH
63855: LD_INT 30
63857: PUSH
63858: LD_INT 4
63860: PUSH
63861: EMPTY
63862: LIST
63863: LIST
63864: PUSH
63865: LD_INT 30
63867: PUSH
63868: LD_INT 5
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: LIST
63879: LIST
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: LIST
63885: PPUSH
63886: CALL_OW 72
63890: ST_TO_ADDR
63891: GO 64115
63893: LD_INT 2
63895: DOUBLE
63896: EQUAL
63897: IFTRUE 63901
63899: GO 63963
63901: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
63902: LD_ADDR_VAR 0 12
63906: PUSH
63907: LD_VAR 0 18
63911: PPUSH
63912: LD_INT 22
63914: PUSH
63915: LD_VAR 0 16
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: LD_INT 2
63926: PUSH
63927: LD_INT 30
63929: PUSH
63930: LD_INT 0
63932: PUSH
63933: EMPTY
63934: LIST
63935: LIST
63936: PUSH
63937: LD_INT 30
63939: PUSH
63940: LD_INT 1
63942: PUSH
63943: EMPTY
63944: LIST
63945: LIST
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: LIST
63951: PUSH
63952: EMPTY
63953: LIST
63954: LIST
63955: PPUSH
63956: CALL_OW 72
63960: ST_TO_ADDR
63961: GO 64115
63963: LD_INT 3
63965: DOUBLE
63966: EQUAL
63967: IFTRUE 63971
63969: GO 64033
63971: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
63972: LD_ADDR_VAR 0 12
63976: PUSH
63977: LD_VAR 0 18
63981: PPUSH
63982: LD_INT 22
63984: PUSH
63985: LD_VAR 0 16
63989: PUSH
63990: EMPTY
63991: LIST
63992: LIST
63993: PUSH
63994: LD_INT 2
63996: PUSH
63997: LD_INT 30
63999: PUSH
64000: LD_INT 2
64002: PUSH
64003: EMPTY
64004: LIST
64005: LIST
64006: PUSH
64007: LD_INT 30
64009: PUSH
64010: LD_INT 3
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: EMPTY
64018: LIST
64019: LIST
64020: LIST
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: PPUSH
64026: CALL_OW 72
64030: ST_TO_ADDR
64031: GO 64115
64033: LD_INT 4
64035: DOUBLE
64036: EQUAL
64037: IFTRUE 64041
64039: GO 64114
64041: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
64042: LD_ADDR_VAR 0 12
64046: PUSH
64047: LD_VAR 0 18
64051: PPUSH
64052: LD_INT 22
64054: PUSH
64055: LD_VAR 0 16
64059: PUSH
64060: EMPTY
64061: LIST
64062: LIST
64063: PUSH
64064: LD_INT 2
64066: PUSH
64067: LD_INT 30
64069: PUSH
64070: LD_INT 6
64072: PUSH
64073: EMPTY
64074: LIST
64075: LIST
64076: PUSH
64077: LD_INT 30
64079: PUSH
64080: LD_INT 7
64082: PUSH
64083: EMPTY
64084: LIST
64085: LIST
64086: PUSH
64087: LD_INT 30
64089: PUSH
64090: LD_INT 8
64092: PUSH
64093: EMPTY
64094: LIST
64095: LIST
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: LIST
64101: LIST
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PPUSH
64107: CALL_OW 72
64111: ST_TO_ADDR
64112: GO 64115
64114: POP
// if i = 1 then
64115: LD_VAR 0 8
64119: PUSH
64120: LD_INT 1
64122: EQUAL
64123: IFFALSE 64234
// begin tmp := [ ] ;
64125: LD_ADDR_VAR 0 19
64129: PUSH
64130: EMPTY
64131: ST_TO_ADDR
// for j in f do
64132: LD_ADDR_VAR 0 9
64136: PUSH
64137: LD_VAR 0 12
64141: PUSH
64142: FOR_IN
64143: IFFALSE 64216
// if GetBType ( j ) = b_bunker then
64145: LD_VAR 0 9
64149: PPUSH
64150: CALL_OW 266
64154: PUSH
64155: LD_INT 32
64157: EQUAL
64158: IFFALSE 64185
// tmp := Insert ( tmp , 1 , j ) else
64160: LD_ADDR_VAR 0 19
64164: PUSH
64165: LD_VAR 0 19
64169: PPUSH
64170: LD_INT 1
64172: PPUSH
64173: LD_VAR 0 9
64177: PPUSH
64178: CALL_OW 2
64182: ST_TO_ADDR
64183: GO 64214
// tmp := Insert ( tmp , tmp + 1 , j ) ;
64185: LD_ADDR_VAR 0 19
64189: PUSH
64190: LD_VAR 0 19
64194: PPUSH
64195: LD_VAR 0 19
64199: PUSH
64200: LD_INT 1
64202: PLUS
64203: PPUSH
64204: LD_VAR 0 9
64208: PPUSH
64209: CALL_OW 2
64213: ST_TO_ADDR
64214: GO 64142
64216: POP
64217: POP
// if tmp then
64218: LD_VAR 0 19
64222: IFFALSE 64234
// f := tmp ;
64224: LD_ADDR_VAR 0 12
64228: PUSH
64229: LD_VAR 0 19
64233: ST_TO_ADDR
// end ; x := personel [ i ] ;
64234: LD_ADDR_VAR 0 13
64238: PUSH
64239: LD_VAR 0 6
64243: PUSH
64244: LD_VAR 0 8
64248: ARRAY
64249: ST_TO_ADDR
// if x = - 1 then
64250: LD_VAR 0 13
64254: PUSH
64255: LD_INT 1
64257: NEG
64258: EQUAL
64259: IFFALSE 64470
// begin for j in f do
64261: LD_ADDR_VAR 0 9
64265: PUSH
64266: LD_VAR 0 12
64270: PUSH
64271: FOR_IN
64272: IFFALSE 64466
// repeat InitHc ;
64274: CALL_OW 19
// if GetBType ( j ) = b_barracks then
64278: LD_VAR 0 9
64282: PPUSH
64283: CALL_OW 266
64287: PUSH
64288: LD_INT 5
64290: EQUAL
64291: IFFALSE 64361
// begin if UnitsInside ( j ) < 3 then
64293: LD_VAR 0 9
64297: PPUSH
64298: CALL_OW 313
64302: PUSH
64303: LD_INT 3
64305: LESS
64306: IFFALSE 64342
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
64308: LD_INT 0
64310: PPUSH
64311: LD_INT 5
64313: PUSH
64314: LD_INT 8
64316: PUSH
64317: LD_INT 9
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: LIST
64324: PUSH
64325: LD_VAR 0 17
64329: ARRAY
64330: PPUSH
64331: LD_VAR 0 4
64335: PPUSH
64336: CALL_OW 380
64340: GO 64359
// PrepareHuman ( false , i , skill ) ;
64342: LD_INT 0
64344: PPUSH
64345: LD_VAR 0 8
64349: PPUSH
64350: LD_VAR 0 4
64354: PPUSH
64355: CALL_OW 380
// end else
64359: GO 64378
// PrepareHuman ( false , i , skill ) ;
64361: LD_INT 0
64363: PPUSH
64364: LD_VAR 0 8
64368: PPUSH
64369: LD_VAR 0 4
64373: PPUSH
64374: CALL_OW 380
// un := CreateHuman ;
64378: LD_ADDR_VAR 0 14
64382: PUSH
64383: CALL_OW 44
64387: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
64388: LD_ADDR_VAR 0 7
64392: PUSH
64393: LD_VAR 0 7
64397: PPUSH
64398: LD_INT 1
64400: PPUSH
64401: LD_VAR 0 14
64405: PPUSH
64406: CALL_OW 2
64410: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
64411: LD_VAR 0 14
64415: PPUSH
64416: LD_VAR 0 9
64420: PPUSH
64421: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
64425: LD_VAR 0 9
64429: PPUSH
64430: CALL_OW 313
64434: PUSH
64435: LD_INT 6
64437: EQUAL
64438: IFTRUE 64462
64440: PUSH
64441: LD_VAR 0 9
64445: PPUSH
64446: CALL_OW 266
64450: PUSH
64451: LD_INT 32
64453: PUSH
64454: LD_INT 31
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: IN
64461: OR
64462: IFFALSE 64274
64464: GO 64271
64466: POP
64467: POP
// end else
64468: GO 64854
// for j = 1 to x do
64470: LD_ADDR_VAR 0 9
64474: PUSH
64475: DOUBLE
64476: LD_INT 1
64478: DEC
64479: ST_TO_ADDR
64480: LD_VAR 0 13
64484: PUSH
64485: FOR_TO
64486: IFFALSE 64852
// begin InitHc ;
64488: CALL_OW 19
// if not f then
64492: LD_VAR 0 12
64496: NOT
64497: IFFALSE 64586
// begin PrepareHuman ( false , i , skill ) ;
64499: LD_INT 0
64501: PPUSH
64502: LD_VAR 0 8
64506: PPUSH
64507: LD_VAR 0 4
64511: PPUSH
64512: CALL_OW 380
// un := CreateHuman ;
64516: LD_ADDR_VAR 0 14
64520: PUSH
64521: CALL_OW 44
64525: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
64526: LD_ADDR_VAR 0 7
64530: PUSH
64531: LD_VAR 0 7
64535: PPUSH
64536: LD_INT 1
64538: PPUSH
64539: LD_VAR 0 14
64543: PPUSH
64544: CALL_OW 2
64548: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
64549: LD_VAR 0 14
64553: PPUSH
64554: LD_VAR 0 1
64558: PPUSH
64559: CALL_OW 250
64563: PPUSH
64564: LD_VAR 0 1
64568: PPUSH
64569: CALL_OW 251
64573: PPUSH
64574: LD_INT 10
64576: PPUSH
64577: LD_INT 0
64579: PPUSH
64580: CALL_OW 50
// continue ;
64584: GO 64485
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
64586: LD_VAR 0 12
64590: PUSH
64591: LD_INT 1
64593: ARRAY
64594: PPUSH
64595: CALL_OW 313
64599: IFFALSE 64627
64601: PUSH
64602: LD_VAR 0 12
64606: PUSH
64607: LD_INT 1
64609: ARRAY
64610: PPUSH
64611: CALL_OW 266
64615: PUSH
64616: LD_INT 32
64618: PUSH
64619: LD_INT 31
64621: PUSH
64622: EMPTY
64623: LIST
64624: LIST
64625: IN
64626: AND
64627: IFTRUE 64648
64629: PUSH
64630: LD_VAR 0 12
64634: PUSH
64635: LD_INT 1
64637: ARRAY
64638: PPUSH
64639: CALL_OW 313
64643: PUSH
64644: LD_INT 6
64646: EQUAL
64647: OR
64648: IFFALSE 64668
// f := Delete ( f , 1 ) ;
64650: LD_ADDR_VAR 0 12
64654: PUSH
64655: LD_VAR 0 12
64659: PPUSH
64660: LD_INT 1
64662: PPUSH
64663: CALL_OW 3
64667: ST_TO_ADDR
// if not f then
64668: LD_VAR 0 12
64672: NOT
64673: IFFALSE 64691
// begin x := x + 2 ;
64675: LD_ADDR_VAR 0 13
64679: PUSH
64680: LD_VAR 0 13
64684: PUSH
64685: LD_INT 2
64687: PLUS
64688: ST_TO_ADDR
// continue ;
64689: GO 64485
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
64691: LD_VAR 0 12
64695: PUSH
64696: LD_INT 1
64698: ARRAY
64699: PPUSH
64700: CALL_OW 266
64704: PUSH
64705: LD_INT 5
64707: EQUAL
64708: IFFALSE 64782
// begin if UnitsInside ( f [ 1 ] ) < 3 then
64710: LD_VAR 0 12
64714: PUSH
64715: LD_INT 1
64717: ARRAY
64718: PPUSH
64719: CALL_OW 313
64723: PUSH
64724: LD_INT 3
64726: LESS
64727: IFFALSE 64763
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
64729: LD_INT 0
64731: PPUSH
64732: LD_INT 5
64734: PUSH
64735: LD_INT 8
64737: PUSH
64738: LD_INT 9
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: LIST
64745: PUSH
64746: LD_VAR 0 17
64750: ARRAY
64751: PPUSH
64752: LD_VAR 0 4
64756: PPUSH
64757: CALL_OW 380
64761: GO 64780
// PrepareHuman ( false , i , skill ) ;
64763: LD_INT 0
64765: PPUSH
64766: LD_VAR 0 8
64770: PPUSH
64771: LD_VAR 0 4
64775: PPUSH
64776: CALL_OW 380
// end else
64780: GO 64799
// PrepareHuman ( false , i , skill ) ;
64782: LD_INT 0
64784: PPUSH
64785: LD_VAR 0 8
64789: PPUSH
64790: LD_VAR 0 4
64794: PPUSH
64795: CALL_OW 380
// un := CreateHuman ;
64799: LD_ADDR_VAR 0 14
64803: PUSH
64804: CALL_OW 44
64808: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
64809: LD_ADDR_VAR 0 7
64813: PUSH
64814: LD_VAR 0 7
64818: PPUSH
64819: LD_INT 1
64821: PPUSH
64822: LD_VAR 0 14
64826: PPUSH
64827: CALL_OW 2
64831: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
64832: LD_VAR 0 14
64836: PPUSH
64837: LD_VAR 0 12
64841: PUSH
64842: LD_INT 1
64844: ARRAY
64845: PPUSH
64846: CALL_OW 52
// end ;
64850: GO 64485
64852: POP
64853: POP
// end ;
64854: GO 63785
64856: POP
64857: POP
// result := result ^ buildings ;
64858: LD_ADDR_VAR 0 7
64862: PUSH
64863: LD_VAR 0 7
64867: PUSH
64868: LD_VAR 0 18
64872: ADD
64873: ST_TO_ADDR
// end else
64874: GO 65017
// begin for i = 1 to personel do
64876: LD_ADDR_VAR 0 8
64880: PUSH
64881: DOUBLE
64882: LD_INT 1
64884: DEC
64885: ST_TO_ADDR
64886: LD_VAR 0 6
64890: PUSH
64891: FOR_TO
64892: IFFALSE 65015
// begin if i > 4 then
64894: LD_VAR 0 8
64898: PUSH
64899: LD_INT 4
64901: GREATER
64902: IFFALSE 64906
// break ;
64904: GO 65015
// x := personel [ i ] ;
64906: LD_ADDR_VAR 0 13
64910: PUSH
64911: LD_VAR 0 6
64915: PUSH
64916: LD_VAR 0 8
64920: ARRAY
64921: ST_TO_ADDR
// if x = - 1 then
64922: LD_VAR 0 13
64926: PUSH
64927: LD_INT 1
64929: NEG
64930: EQUAL
64931: IFFALSE 64935
// continue ;
64933: GO 64891
// PrepareHuman ( false , i , skill ) ;
64935: LD_INT 0
64937: PPUSH
64938: LD_VAR 0 8
64942: PPUSH
64943: LD_VAR 0 4
64947: PPUSH
64948: CALL_OW 380
// un := CreateHuman ;
64952: LD_ADDR_VAR 0 14
64956: PUSH
64957: CALL_OW 44
64961: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
64962: LD_VAR 0 14
64966: PPUSH
64967: LD_VAR 0 1
64971: PPUSH
64972: CALL_OW 250
64976: PPUSH
64977: LD_VAR 0 1
64981: PPUSH
64982: CALL_OW 251
64986: PPUSH
64987: LD_INT 10
64989: PPUSH
64990: LD_INT 0
64992: PPUSH
64993: CALL_OW 50
// result := result ^ un ;
64997: LD_ADDR_VAR 0 7
65001: PUSH
65002: LD_VAR 0 7
65006: PUSH
65007: LD_VAR 0 14
65011: ADD
65012: ST_TO_ADDR
// end ;
65013: GO 64891
65015: POP
65016: POP
// end ; end ;
65017: LD_VAR 0 7
65021: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
65022: LD_INT 0
65024: PPUSH
65025: PPUSH
65026: PPUSH
65027: PPUSH
65028: PPUSH
65029: PPUSH
65030: PPUSH
65031: PPUSH
65032: PPUSH
65033: PPUSH
65034: PPUSH
65035: PPUSH
65036: PPUSH
65037: PPUSH
65038: PPUSH
65039: PPUSH
// result := false ;
65040: LD_ADDR_VAR 0 3
65044: PUSH
65045: LD_INT 0
65047: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
65048: LD_VAR 0 1
65052: NOT
65053: IFTRUE 65078
65055: PUSH
65056: LD_VAR 0 1
65060: PPUSH
65061: CALL_OW 266
65065: PUSH
65066: LD_INT 32
65068: PUSH
65069: LD_INT 33
65071: PUSH
65072: EMPTY
65073: LIST
65074: LIST
65075: IN
65076: NOT
65077: OR
65078: IFFALSE 65082
// exit ;
65080: GO 66217
// nat := GetNation ( tower ) ;
65082: LD_ADDR_VAR 0 12
65086: PUSH
65087: LD_VAR 0 1
65091: PPUSH
65092: CALL_OW 248
65096: ST_TO_ADDR
// side := GetSide ( tower ) ;
65097: LD_ADDR_VAR 0 16
65101: PUSH
65102: LD_VAR 0 1
65106: PPUSH
65107: CALL_OW 255
65111: ST_TO_ADDR
// x := GetX ( tower ) ;
65112: LD_ADDR_VAR 0 10
65116: PUSH
65117: LD_VAR 0 1
65121: PPUSH
65122: CALL_OW 250
65126: ST_TO_ADDR
// y := GetY ( tower ) ;
65127: LD_ADDR_VAR 0 11
65131: PUSH
65132: LD_VAR 0 1
65136: PPUSH
65137: CALL_OW 251
65141: ST_TO_ADDR
// if not x or not y then
65142: LD_VAR 0 10
65146: NOT
65147: IFTRUE 65156
65149: PUSH
65150: LD_VAR 0 11
65154: NOT
65155: OR
65156: IFFALSE 65160
// exit ;
65158: GO 66217
// weapon := 0 ;
65160: LD_ADDR_VAR 0 18
65164: PUSH
65165: LD_INT 0
65167: ST_TO_ADDR
// fac_list := [ ] ;
65168: LD_ADDR_VAR 0 17
65172: PUSH
65173: EMPTY
65174: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
65175: LD_ADDR_VAR 0 6
65179: PUSH
65180: LD_VAR 0 1
65184: PPUSH
65185: CALL_OW 274
65189: PPUSH
65190: LD_VAR 0 2
65194: PPUSH
65195: LD_INT 0
65197: PPUSH
65198: CALL 62752 0 3
65202: PPUSH
65203: LD_INT 30
65205: PUSH
65206: LD_INT 3
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: PPUSH
65213: CALL_OW 72
65217: ST_TO_ADDR
// if not factories then
65218: LD_VAR 0 6
65222: NOT
65223: IFFALSE 65227
// exit ;
65225: GO 66217
// for i in factories do
65227: LD_ADDR_VAR 0 8
65231: PUSH
65232: LD_VAR 0 6
65236: PUSH
65237: FOR_IN
65238: IFFALSE 65263
// fac_list := fac_list union AvailableWeaponList ( i ) ;
65240: LD_ADDR_VAR 0 17
65244: PUSH
65245: LD_VAR 0 17
65249: PUSH
65250: LD_VAR 0 8
65254: PPUSH
65255: CALL_OW 478
65259: UNION
65260: ST_TO_ADDR
65261: GO 65237
65263: POP
65264: POP
// if not fac_list then
65265: LD_VAR 0 17
65269: NOT
65270: IFFALSE 65274
// exit ;
65272: GO 66217
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
65274: LD_ADDR_VAR 0 5
65278: PUSH
65279: LD_INT 4
65281: PUSH
65282: LD_INT 5
65284: PUSH
65285: LD_INT 9
65287: PUSH
65288: LD_INT 10
65290: PUSH
65291: LD_INT 6
65293: PUSH
65294: LD_INT 7
65296: PUSH
65297: LD_INT 11
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: LIST
65304: LIST
65305: LIST
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 27
65311: PUSH
65312: LD_INT 28
65314: PUSH
65315: LD_INT 26
65317: PUSH
65318: LD_INT 30
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: PUSH
65327: LD_INT 43
65329: PUSH
65330: LD_INT 44
65332: PUSH
65333: LD_INT 46
65335: PUSH
65336: LD_INT 45
65338: PUSH
65339: LD_INT 47
65341: PUSH
65342: LD_INT 49
65344: PUSH
65345: EMPTY
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: LIST
65352: PUSH
65353: EMPTY
65354: LIST
65355: LIST
65356: LIST
65357: PUSH
65358: LD_VAR 0 12
65362: ARRAY
65363: ST_TO_ADDR
// list := list isect fac_list ;
65364: LD_ADDR_VAR 0 5
65368: PUSH
65369: LD_VAR 0 5
65373: PUSH
65374: LD_VAR 0 17
65378: ISECT
65379: ST_TO_ADDR
// if not list then
65380: LD_VAR 0 5
65384: NOT
65385: IFFALSE 65389
// exit ;
65387: GO 66217
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
65389: LD_VAR 0 12
65393: PUSH
65394: LD_INT 3
65396: EQUAL
65397: IFFALSE 65409
65399: PUSH
65400: LD_INT 49
65402: PUSH
65403: LD_VAR 0 5
65407: IN
65408: AND
65409: IFFALSE 65429
65411: PUSH
65412: LD_INT 31
65414: PPUSH
65415: LD_VAR 0 16
65419: PPUSH
65420: CALL_OW 321
65424: PUSH
65425: LD_INT 2
65427: EQUAL
65428: AND
65429: IFFALSE 65489
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
65431: LD_INT 22
65433: PUSH
65434: LD_VAR 0 16
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 35
65445: PUSH
65446: LD_INT 49
65448: PUSH
65449: EMPTY
65450: LIST
65451: LIST
65452: PUSH
65453: LD_INT 91
65455: PUSH
65456: LD_VAR 0 1
65460: PUSH
65461: LD_INT 10
65463: PUSH
65464: EMPTY
65465: LIST
65466: LIST
65467: LIST
65468: PUSH
65469: EMPTY
65470: LIST
65471: LIST
65472: LIST
65473: PPUSH
65474: CALL_OW 69
65478: NOT
65479: IFFALSE 65489
// weapon := ru_time_lapser ;
65481: LD_ADDR_VAR 0 18
65485: PUSH
65486: LD_INT 49
65488: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
65489: LD_VAR 0 12
65493: PUSH
65494: LD_INT 1
65496: PUSH
65497: LD_INT 2
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: IN
65504: IFFALSE 65528
65506: PUSH
65507: LD_INT 11
65509: PUSH
65510: LD_VAR 0 5
65514: IN
65515: IFTRUE 65527
65517: PUSH
65518: LD_INT 30
65520: PUSH
65521: LD_VAR 0 5
65525: IN
65526: OR
65527: AND
65528: IFFALSE 65548
65530: PUSH
65531: LD_INT 6
65533: PPUSH
65534: LD_VAR 0 16
65538: PPUSH
65539: CALL_OW 321
65543: PUSH
65544: LD_INT 2
65546: EQUAL
65547: AND
65548: IFFALSE 65715
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
65550: LD_INT 22
65552: PUSH
65553: LD_VAR 0 16
65557: PUSH
65558: EMPTY
65559: LIST
65560: LIST
65561: PUSH
65562: LD_INT 2
65564: PUSH
65565: LD_INT 35
65567: PUSH
65568: LD_INT 11
65570: PUSH
65571: EMPTY
65572: LIST
65573: LIST
65574: PUSH
65575: LD_INT 35
65577: PUSH
65578: LD_INT 30
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: LIST
65589: PUSH
65590: LD_INT 91
65592: PUSH
65593: LD_VAR 0 1
65597: PUSH
65598: LD_INT 18
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: LIST
65605: PUSH
65606: EMPTY
65607: LIST
65608: LIST
65609: LIST
65610: PPUSH
65611: CALL_OW 69
65615: NOT
65616: IFFALSE 65692
65618: PUSH
65619: LD_INT 22
65621: PUSH
65622: LD_VAR 0 16
65626: PUSH
65627: EMPTY
65628: LIST
65629: LIST
65630: PUSH
65631: LD_INT 2
65633: PUSH
65634: LD_INT 30
65636: PUSH
65637: LD_INT 32
65639: PUSH
65640: EMPTY
65641: LIST
65642: LIST
65643: PUSH
65644: LD_INT 30
65646: PUSH
65647: LD_INT 33
65649: PUSH
65650: EMPTY
65651: LIST
65652: LIST
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: LIST
65658: PUSH
65659: LD_INT 91
65661: PUSH
65662: LD_VAR 0 1
65666: PUSH
65667: LD_INT 12
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: LIST
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: LIST
65679: PUSH
65680: EMPTY
65681: LIST
65682: PPUSH
65683: CALL_OW 69
65687: PUSH
65688: LD_INT 2
65690: GREATER
65691: AND
65692: IFFALSE 65715
// weapon := [ us_radar , ar_radar ] [ nat ] ;
65694: LD_ADDR_VAR 0 18
65698: PUSH
65699: LD_INT 11
65701: PUSH
65702: LD_INT 30
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: PUSH
65709: LD_VAR 0 12
65713: ARRAY
65714: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
65715: LD_VAR 0 18
65719: NOT
65720: IFFALSE 65740
65722: PUSH
65723: LD_INT 40
65725: PPUSH
65726: LD_VAR 0 16
65730: PPUSH
65731: CALL_OW 321
65735: PUSH
65736: LD_INT 2
65738: EQUAL
65739: AND
65740: IFFALSE 65776
65742: PUSH
65743: LD_INT 7
65745: PUSH
65746: LD_VAR 0 5
65750: IN
65751: IFTRUE 65763
65753: PUSH
65754: LD_INT 28
65756: PUSH
65757: LD_VAR 0 5
65761: IN
65762: OR
65763: IFTRUE 65775
65765: PUSH
65766: LD_INT 45
65768: PUSH
65769: LD_VAR 0 5
65773: IN
65774: OR
65775: AND
65776: IFFALSE 66030
// begin hex := GetHexInfo ( x , y ) ;
65778: LD_ADDR_VAR 0 4
65782: PUSH
65783: LD_VAR 0 10
65787: PPUSH
65788: LD_VAR 0 11
65792: PPUSH
65793: CALL_OW 546
65797: ST_TO_ADDR
// if hex [ 1 ] then
65798: LD_VAR 0 4
65802: PUSH
65803: LD_INT 1
65805: ARRAY
65806: IFFALSE 65810
// exit ;
65808: GO 66217
// height := hex [ 2 ] ;
65810: LD_ADDR_VAR 0 15
65814: PUSH
65815: LD_VAR 0 4
65819: PUSH
65820: LD_INT 2
65822: ARRAY
65823: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
65824: LD_ADDR_VAR 0 14
65828: PUSH
65829: LD_INT 0
65831: PUSH
65832: LD_INT 2
65834: PUSH
65835: LD_INT 3
65837: PUSH
65838: LD_INT 5
65840: PUSH
65841: EMPTY
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: ST_TO_ADDR
// for i in tmp do
65847: LD_ADDR_VAR 0 8
65851: PUSH
65852: LD_VAR 0 14
65856: PUSH
65857: FOR_IN
65858: IFFALSE 66028
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
65860: LD_ADDR_VAR 0 9
65864: PUSH
65865: LD_VAR 0 10
65869: PPUSH
65870: LD_VAR 0 8
65874: PPUSH
65875: LD_INT 5
65877: PPUSH
65878: CALL_OW 272
65882: PUSH
65883: LD_VAR 0 11
65887: PPUSH
65888: LD_VAR 0 8
65892: PPUSH
65893: LD_INT 5
65895: PPUSH
65896: CALL_OW 273
65900: PUSH
65901: EMPTY
65902: LIST
65903: LIST
65904: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
65905: LD_VAR 0 9
65909: PUSH
65910: LD_INT 1
65912: ARRAY
65913: PPUSH
65914: LD_VAR 0 9
65918: PUSH
65919: LD_INT 2
65921: ARRAY
65922: PPUSH
65923: CALL_OW 488
65927: IFFALSE 66026
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
65929: LD_ADDR_VAR 0 4
65933: PUSH
65934: LD_VAR 0 9
65938: PUSH
65939: LD_INT 1
65941: ARRAY
65942: PPUSH
65943: LD_VAR 0 9
65947: PUSH
65948: LD_INT 2
65950: ARRAY
65951: PPUSH
65952: CALL_OW 546
65956: ST_TO_ADDR
// if hex [ 1 ] then
65957: LD_VAR 0 4
65961: PUSH
65962: LD_INT 1
65964: ARRAY
65965: IFFALSE 65969
// continue ;
65967: GO 65857
// h := hex [ 2 ] ;
65969: LD_ADDR_VAR 0 13
65973: PUSH
65974: LD_VAR 0 4
65978: PUSH
65979: LD_INT 2
65981: ARRAY
65982: ST_TO_ADDR
// if h + 7 < height then
65983: LD_VAR 0 13
65987: PUSH
65988: LD_INT 7
65990: PLUS
65991: PUSH
65992: LD_VAR 0 15
65996: LESS
65997: IFFALSE 66026
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
65999: LD_ADDR_VAR 0 18
66003: PUSH
66004: LD_INT 7
66006: PUSH
66007: LD_INT 28
66009: PUSH
66010: LD_INT 45
66012: PUSH
66013: EMPTY
66014: LIST
66015: LIST
66016: LIST
66017: PUSH
66018: LD_VAR 0 12
66022: ARRAY
66023: ST_TO_ADDR
// break ;
66024: GO 66028
// end ; end ; end ;
66026: GO 65857
66028: POP
66029: POP
// end ; if not weapon then
66030: LD_VAR 0 18
66034: NOT
66035: IFFALSE 66095
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
66037: LD_ADDR_VAR 0 5
66041: PUSH
66042: LD_VAR 0 5
66046: PUSH
66047: LD_INT 11
66049: PUSH
66050: LD_INT 30
66052: PUSH
66053: LD_INT 49
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: LIST
66060: DIFF
66061: ST_TO_ADDR
// if not list then
66062: LD_VAR 0 5
66066: NOT
66067: IFFALSE 66071
// exit ;
66069: GO 66217
// weapon := list [ rand ( 1 , list ) ] ;
66071: LD_ADDR_VAR 0 18
66075: PUSH
66076: LD_VAR 0 5
66080: PUSH
66081: LD_INT 1
66083: PPUSH
66084: LD_VAR 0 5
66088: PPUSH
66089: CALL_OW 12
66093: ARRAY
66094: ST_TO_ADDR
// end ; if weapon then
66095: LD_VAR 0 18
66099: IFFALSE 66217
// begin tmp := CostOfWeapon ( weapon ) ;
66101: LD_ADDR_VAR 0 14
66105: PUSH
66106: LD_VAR 0 18
66110: PPUSH
66111: CALL_OW 451
66115: ST_TO_ADDR
// j := GetBase ( tower ) ;
66116: LD_ADDR_VAR 0 9
66120: PUSH
66121: LD_VAR 0 1
66125: PPUSH
66126: CALL_OW 274
66130: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
66131: LD_VAR 0 9
66135: PPUSH
66136: LD_INT 1
66138: PPUSH
66139: CALL_OW 275
66143: PUSH
66144: LD_VAR 0 14
66148: PUSH
66149: LD_INT 1
66151: ARRAY
66152: GREATEREQUAL
66153: IFFALSE 66179
66155: PUSH
66156: LD_VAR 0 9
66160: PPUSH
66161: LD_INT 2
66163: PPUSH
66164: CALL_OW 275
66168: PUSH
66169: LD_VAR 0 14
66173: PUSH
66174: LD_INT 2
66176: ARRAY
66177: GREATEREQUAL
66178: AND
66179: IFFALSE 66205
66181: PUSH
66182: LD_VAR 0 9
66186: PPUSH
66187: LD_INT 3
66189: PPUSH
66190: CALL_OW 275
66194: PUSH
66195: LD_VAR 0 14
66199: PUSH
66200: LD_INT 3
66202: ARRAY
66203: GREATEREQUAL
66204: AND
66205: IFFALSE 66217
// result := weapon ;
66207: LD_ADDR_VAR 0 3
66211: PUSH
66212: LD_VAR 0 18
66216: ST_TO_ADDR
// end ; end ;
66217: LD_VAR 0 3
66221: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
66222: LD_INT 0
66224: PPUSH
66225: PPUSH
// result := true ;
66226: LD_ADDR_VAR 0 3
66230: PUSH
66231: LD_INT 1
66233: ST_TO_ADDR
// if array1 = array2 then
66234: LD_VAR 0 1
66238: PUSH
66239: LD_VAR 0 2
66243: EQUAL
66244: IFFALSE 66304
// begin for i = 1 to array1 do
66246: LD_ADDR_VAR 0 4
66250: PUSH
66251: DOUBLE
66252: LD_INT 1
66254: DEC
66255: ST_TO_ADDR
66256: LD_VAR 0 1
66260: PUSH
66261: FOR_TO
66262: IFFALSE 66300
// if array1 [ i ] <> array2 [ i ] then
66264: LD_VAR 0 1
66268: PUSH
66269: LD_VAR 0 4
66273: ARRAY
66274: PUSH
66275: LD_VAR 0 2
66279: PUSH
66280: LD_VAR 0 4
66284: ARRAY
66285: NONEQUAL
66286: IFFALSE 66298
// begin result := false ;
66288: LD_ADDR_VAR 0 3
66292: PUSH
66293: LD_INT 0
66295: ST_TO_ADDR
// break ;
66296: GO 66300
// end ;
66298: GO 66261
66300: POP
66301: POP
// end else
66302: GO 66312
// result := false ;
66304: LD_ADDR_VAR 0 3
66308: PUSH
66309: LD_INT 0
66311: ST_TO_ADDR
// end ;
66312: LD_VAR 0 3
66316: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
66317: LD_INT 0
66319: PPUSH
66320: PPUSH
// if not array1 or not array2 then
66321: LD_VAR 0 1
66325: NOT
66326: IFTRUE 66335
66328: PUSH
66329: LD_VAR 0 2
66333: NOT
66334: OR
66335: IFFALSE 66339
// exit ;
66337: GO 66403
// result := true ;
66339: LD_ADDR_VAR 0 3
66343: PUSH
66344: LD_INT 1
66346: ST_TO_ADDR
// for i = 1 to array1 do
66347: LD_ADDR_VAR 0 4
66351: PUSH
66352: DOUBLE
66353: LD_INT 1
66355: DEC
66356: ST_TO_ADDR
66357: LD_VAR 0 1
66361: PUSH
66362: FOR_TO
66363: IFFALSE 66401
// if array1 [ i ] <> array2 [ i ] then
66365: LD_VAR 0 1
66369: PUSH
66370: LD_VAR 0 4
66374: ARRAY
66375: PUSH
66376: LD_VAR 0 2
66380: PUSH
66381: LD_VAR 0 4
66385: ARRAY
66386: NONEQUAL
66387: IFFALSE 66399
// begin result := false ;
66389: LD_ADDR_VAR 0 3
66393: PUSH
66394: LD_INT 0
66396: ST_TO_ADDR
// break ;
66397: GO 66401
// end ;
66399: GO 66362
66401: POP
66402: POP
// end ;
66403: LD_VAR 0 3
66407: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
66408: LD_INT 0
66410: PPUSH
66411: PPUSH
66412: PPUSH
// pom := GetBase ( fac ) ;
66413: LD_ADDR_VAR 0 5
66417: PUSH
66418: LD_VAR 0 1
66422: PPUSH
66423: CALL_OW 274
66427: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
66428: LD_ADDR_VAR 0 4
66432: PUSH
66433: LD_VAR 0 2
66437: PUSH
66438: LD_INT 1
66440: ARRAY
66441: PPUSH
66442: LD_VAR 0 2
66446: PUSH
66447: LD_INT 2
66449: ARRAY
66450: PPUSH
66451: LD_VAR 0 2
66455: PUSH
66456: LD_INT 3
66458: ARRAY
66459: PPUSH
66460: LD_VAR 0 2
66464: PUSH
66465: LD_INT 4
66467: ARRAY
66468: PPUSH
66469: CALL_OW 449
66473: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
66474: LD_ADDR_VAR 0 3
66478: PUSH
66479: LD_VAR 0 5
66483: PPUSH
66484: LD_INT 1
66486: PPUSH
66487: CALL_OW 275
66491: PUSH
66492: LD_VAR 0 4
66496: PUSH
66497: LD_INT 1
66499: ARRAY
66500: GREATEREQUAL
66501: IFFALSE 66527
66503: PUSH
66504: LD_VAR 0 5
66508: PPUSH
66509: LD_INT 2
66511: PPUSH
66512: CALL_OW 275
66516: PUSH
66517: LD_VAR 0 4
66521: PUSH
66522: LD_INT 2
66524: ARRAY
66525: GREATEREQUAL
66526: AND
66527: IFFALSE 66553
66529: PUSH
66530: LD_VAR 0 5
66534: PPUSH
66535: LD_INT 3
66537: PPUSH
66538: CALL_OW 275
66542: PUSH
66543: LD_VAR 0 4
66547: PUSH
66548: LD_INT 3
66550: ARRAY
66551: GREATEREQUAL
66552: AND
66553: ST_TO_ADDR
// end ;
66554: LD_VAR 0 3
66558: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
66559: LD_INT 0
66561: PPUSH
66562: PPUSH
66563: PPUSH
66564: PPUSH
// pom := GetBase ( building ) ;
66565: LD_ADDR_VAR 0 3
66569: PUSH
66570: LD_VAR 0 1
66574: PPUSH
66575: CALL_OW 274
66579: ST_TO_ADDR
// if not pom then
66580: LD_VAR 0 3
66584: NOT
66585: IFFALSE 66589
// exit ;
66587: GO 66763
// btype := GetBType ( building ) ;
66589: LD_ADDR_VAR 0 5
66593: PUSH
66594: LD_VAR 0 1
66598: PPUSH
66599: CALL_OW 266
66603: ST_TO_ADDR
// if btype = b_armoury then
66604: LD_VAR 0 5
66608: PUSH
66609: LD_INT 4
66611: EQUAL
66612: IFFALSE 66622
// btype := b_barracks ;
66614: LD_ADDR_VAR 0 5
66618: PUSH
66619: LD_INT 5
66621: ST_TO_ADDR
// if btype = b_depot then
66622: LD_VAR 0 5
66626: PUSH
66627: LD_INT 0
66629: EQUAL
66630: IFFALSE 66640
// btype := b_warehouse ;
66632: LD_ADDR_VAR 0 5
66636: PUSH
66637: LD_INT 1
66639: ST_TO_ADDR
// if btype = b_workshop then
66640: LD_VAR 0 5
66644: PUSH
66645: LD_INT 2
66647: EQUAL
66648: IFFALSE 66658
// btype := b_factory ;
66650: LD_ADDR_VAR 0 5
66654: PUSH
66655: LD_INT 3
66657: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
66658: LD_ADDR_VAR 0 4
66662: PUSH
66663: LD_VAR 0 5
66667: PPUSH
66668: LD_VAR 0 1
66672: PPUSH
66673: CALL_OW 248
66677: PPUSH
66678: CALL_OW 450
66682: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
66683: LD_ADDR_VAR 0 2
66687: PUSH
66688: LD_VAR 0 3
66692: PPUSH
66693: LD_INT 1
66695: PPUSH
66696: CALL_OW 275
66700: PUSH
66701: LD_VAR 0 4
66705: PUSH
66706: LD_INT 1
66708: ARRAY
66709: GREATEREQUAL
66710: IFFALSE 66736
66712: PUSH
66713: LD_VAR 0 3
66717: PPUSH
66718: LD_INT 2
66720: PPUSH
66721: CALL_OW 275
66725: PUSH
66726: LD_VAR 0 4
66730: PUSH
66731: LD_INT 2
66733: ARRAY
66734: GREATEREQUAL
66735: AND
66736: IFFALSE 66762
66738: PUSH
66739: LD_VAR 0 3
66743: PPUSH
66744: LD_INT 3
66746: PPUSH
66747: CALL_OW 275
66751: PUSH
66752: LD_VAR 0 4
66756: PUSH
66757: LD_INT 3
66759: ARRAY
66760: GREATEREQUAL
66761: AND
66762: ST_TO_ADDR
// end ;
66763: LD_VAR 0 2
66767: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
66768: LD_INT 0
66770: PPUSH
66771: PPUSH
66772: PPUSH
// pom := GetBase ( building ) ;
66773: LD_ADDR_VAR 0 4
66777: PUSH
66778: LD_VAR 0 1
66782: PPUSH
66783: CALL_OW 274
66787: ST_TO_ADDR
// if not pom then
66788: LD_VAR 0 4
66792: NOT
66793: IFFALSE 66797
// exit ;
66795: GO 66902
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
66797: LD_ADDR_VAR 0 5
66801: PUSH
66802: LD_VAR 0 2
66806: PPUSH
66807: LD_VAR 0 1
66811: PPUSH
66812: CALL_OW 248
66816: PPUSH
66817: CALL_OW 450
66821: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
66822: LD_ADDR_VAR 0 3
66826: PUSH
66827: LD_VAR 0 4
66831: PPUSH
66832: LD_INT 1
66834: PPUSH
66835: CALL_OW 275
66839: PUSH
66840: LD_VAR 0 5
66844: PUSH
66845: LD_INT 1
66847: ARRAY
66848: GREATEREQUAL
66849: IFFALSE 66875
66851: PUSH
66852: LD_VAR 0 4
66856: PPUSH
66857: LD_INT 2
66859: PPUSH
66860: CALL_OW 275
66864: PUSH
66865: LD_VAR 0 5
66869: PUSH
66870: LD_INT 2
66872: ARRAY
66873: GREATEREQUAL
66874: AND
66875: IFFALSE 66901
66877: PUSH
66878: LD_VAR 0 4
66882: PPUSH
66883: LD_INT 3
66885: PPUSH
66886: CALL_OW 275
66890: PUSH
66891: LD_VAR 0 5
66895: PUSH
66896: LD_INT 3
66898: ARRAY
66899: GREATEREQUAL
66900: AND
66901: ST_TO_ADDR
// end ;
66902: LD_VAR 0 3
66906: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
66907: LD_INT 0
66909: PPUSH
66910: PPUSH
66911: PPUSH
66912: PPUSH
66913: PPUSH
66914: PPUSH
66915: PPUSH
66916: PPUSH
66917: PPUSH
66918: PPUSH
66919: PPUSH
// result := false ;
66920: LD_ADDR_VAR 0 8
66924: PUSH
66925: LD_INT 0
66927: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
66928: LD_VAR 0 5
66932: NOT
66933: IFTRUE 66942
66935: PUSH
66936: LD_VAR 0 1
66940: NOT
66941: OR
66942: IFTRUE 66951
66944: PUSH
66945: LD_VAR 0 2
66949: NOT
66950: OR
66951: IFTRUE 66960
66953: PUSH
66954: LD_VAR 0 3
66958: NOT
66959: OR
66960: IFFALSE 66964
// exit ;
66962: GO 67790
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
66964: LD_ADDR_VAR 0 14
66968: PUSH
66969: LD_VAR 0 1
66973: PPUSH
66974: LD_VAR 0 2
66978: PPUSH
66979: LD_VAR 0 3
66983: PPUSH
66984: LD_VAR 0 4
66988: PPUSH
66989: LD_VAR 0 5
66993: PUSH
66994: LD_INT 1
66996: ARRAY
66997: PPUSH
66998: CALL_OW 248
67002: PPUSH
67003: LD_INT 0
67005: PPUSH
67006: CALL 69071 0 6
67010: ST_TO_ADDR
// if not hexes then
67011: LD_VAR 0 14
67015: NOT
67016: IFFALSE 67020
// exit ;
67018: GO 67790
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
67020: LD_ADDR_VAR 0 17
67024: PUSH
67025: LD_VAR 0 5
67029: PPUSH
67030: LD_INT 22
67032: PUSH
67033: LD_VAR 0 13
67037: PPUSH
67038: CALL_OW 255
67042: PUSH
67043: EMPTY
67044: LIST
67045: LIST
67046: PUSH
67047: LD_INT 2
67049: PUSH
67050: LD_INT 30
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 30
67062: PUSH
67063: LD_INT 1
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: EMPTY
67071: LIST
67072: LIST
67073: LIST
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PPUSH
67079: CALL_OW 72
67083: ST_TO_ADDR
// for i = 1 to hexes do
67084: LD_ADDR_VAR 0 9
67088: PUSH
67089: DOUBLE
67090: LD_INT 1
67092: DEC
67093: ST_TO_ADDR
67094: LD_VAR 0 14
67098: PUSH
67099: FOR_TO
67100: IFFALSE 67788
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67102: LD_ADDR_VAR 0 13
67106: PUSH
67107: LD_VAR 0 14
67111: PUSH
67112: LD_VAR 0 9
67116: ARRAY
67117: PUSH
67118: LD_INT 1
67120: ARRAY
67121: PPUSH
67122: LD_VAR 0 14
67126: PUSH
67127: LD_VAR 0 9
67131: ARRAY
67132: PUSH
67133: LD_INT 2
67135: ARRAY
67136: PPUSH
67137: CALL_OW 428
67141: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
67142: LD_VAR 0 14
67146: PUSH
67147: LD_VAR 0 9
67151: ARRAY
67152: PUSH
67153: LD_INT 1
67155: ARRAY
67156: PPUSH
67157: LD_VAR 0 14
67161: PUSH
67162: LD_VAR 0 9
67166: ARRAY
67167: PUSH
67168: LD_INT 2
67170: ARRAY
67171: PPUSH
67172: CALL_OW 351
67176: IFTRUE 67215
67178: PUSH
67179: LD_VAR 0 14
67183: PUSH
67184: LD_VAR 0 9
67188: ARRAY
67189: PUSH
67190: LD_INT 1
67192: ARRAY
67193: PPUSH
67194: LD_VAR 0 14
67198: PUSH
67199: LD_VAR 0 9
67203: ARRAY
67204: PUSH
67205: LD_INT 2
67207: ARRAY
67208: PPUSH
67209: CALL_OW 488
67213: NOT
67214: OR
67215: IFTRUE 67232
67217: PUSH
67218: LD_VAR 0 13
67222: PPUSH
67223: CALL_OW 247
67227: PUSH
67228: LD_INT 3
67230: EQUAL
67231: OR
67232: IFFALSE 67238
// exit ;
67234: POP
67235: POP
67236: GO 67790
// if not tmp then
67238: LD_VAR 0 13
67242: NOT
67243: IFFALSE 67247
// continue ;
67245: GO 67099
// result := true ;
67247: LD_ADDR_VAR 0 8
67251: PUSH
67252: LD_INT 1
67254: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
67255: LD_VAR 0 6
67259: IFFALSE 67276
67261: PUSH
67262: LD_VAR 0 13
67266: PPUSH
67267: CALL_OW 247
67271: PUSH
67272: LD_INT 2
67274: EQUAL
67275: AND
67276: IFFALSE 67293
67278: PUSH
67279: LD_VAR 0 13
67283: PPUSH
67284: CALL_OW 263
67288: PUSH
67289: LD_INT 1
67291: EQUAL
67292: AND
67293: IFFALSE 67457
// begin if IsDrivenBy ( tmp ) then
67295: LD_VAR 0 13
67299: PPUSH
67300: CALL_OW 311
67304: IFFALSE 67308
// continue ;
67306: GO 67099
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
67308: LD_VAR 0 6
67312: PPUSH
67313: LD_INT 3
67315: PUSH
67316: LD_INT 60
67318: PUSH
67319: EMPTY
67320: LIST
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 3
67328: PUSH
67329: LD_INT 55
67331: PUSH
67332: EMPTY
67333: LIST
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PPUSH
67343: CALL_OW 72
67347: IFFALSE 67455
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
67349: LD_ADDR_VAR 0 18
67353: PUSH
67354: LD_VAR 0 6
67358: PPUSH
67359: LD_INT 3
67361: PUSH
67362: LD_INT 60
67364: PUSH
67365: EMPTY
67366: LIST
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 3
67374: PUSH
67375: LD_INT 55
67377: PUSH
67378: EMPTY
67379: LIST
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PPUSH
67389: CALL_OW 72
67393: PUSH
67394: LD_INT 1
67396: ARRAY
67397: ST_TO_ADDR
// if IsInUnit ( driver ) then
67398: LD_VAR 0 18
67402: PPUSH
67403: CALL_OW 310
67407: IFFALSE 67418
// ComExit ( driver ) ;
67409: LD_VAR 0 18
67413: PPUSH
67414: CALL 93071 0 1
// AddComEnterUnit ( driver , tmp ) ;
67418: LD_VAR 0 18
67422: PPUSH
67423: LD_VAR 0 13
67427: PPUSH
67428: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
67432: LD_VAR 0 18
67436: PPUSH
67437: LD_VAR 0 7
67441: PPUSH
67442: CALL_OW 173
// AddComExitVehicle ( driver ) ;
67446: LD_VAR 0 18
67450: PPUSH
67451: CALL_OW 181
// end ; continue ;
67455: GO 67099
// end ; if not cleaners or not tmp in cleaners then
67457: LD_VAR 0 6
67461: NOT
67462: IFTRUE 67477
67464: PUSH
67465: LD_VAR 0 13
67469: PUSH
67470: LD_VAR 0 6
67474: IN
67475: NOT
67476: OR
67477: IFFALSE 67786
// begin if dep then
67479: LD_VAR 0 17
67483: IFFALSE 67619
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
67485: LD_ADDR_VAR 0 16
67489: PUSH
67490: LD_VAR 0 17
67494: PUSH
67495: LD_INT 1
67497: ARRAY
67498: PPUSH
67499: CALL_OW 250
67503: PPUSH
67504: LD_VAR 0 17
67508: PUSH
67509: LD_INT 1
67511: ARRAY
67512: PPUSH
67513: CALL_OW 254
67517: PPUSH
67518: LD_INT 5
67520: PPUSH
67521: CALL_OW 272
67525: PUSH
67526: LD_VAR 0 17
67530: PUSH
67531: LD_INT 1
67533: ARRAY
67534: PPUSH
67535: CALL_OW 251
67539: PPUSH
67540: LD_VAR 0 17
67544: PUSH
67545: LD_INT 1
67547: ARRAY
67548: PPUSH
67549: CALL_OW 254
67553: PPUSH
67554: LD_INT 5
67556: PPUSH
67557: CALL_OW 273
67561: PUSH
67562: EMPTY
67563: LIST
67564: LIST
67565: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
67566: LD_VAR 0 16
67570: PUSH
67571: LD_INT 1
67573: ARRAY
67574: PPUSH
67575: LD_VAR 0 16
67579: PUSH
67580: LD_INT 2
67582: ARRAY
67583: PPUSH
67584: CALL_OW 488
67588: IFFALSE 67619
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
67590: LD_VAR 0 13
67594: PPUSH
67595: LD_VAR 0 16
67599: PUSH
67600: LD_INT 1
67602: ARRAY
67603: PPUSH
67604: LD_VAR 0 16
67608: PUSH
67609: LD_INT 2
67611: ARRAY
67612: PPUSH
67613: CALL_OW 111
// continue ;
67617: GO 67099
// end ; end ; r := GetDir ( tmp ) ;
67619: LD_ADDR_VAR 0 15
67623: PUSH
67624: LD_VAR 0 13
67628: PPUSH
67629: CALL_OW 254
67633: ST_TO_ADDR
// if r = 5 then
67634: LD_VAR 0 15
67638: PUSH
67639: LD_INT 5
67641: EQUAL
67642: IFFALSE 67652
// r := 0 ;
67644: LD_ADDR_VAR 0 15
67648: PUSH
67649: LD_INT 0
67651: ST_TO_ADDR
// for j = r to 5 do
67652: LD_ADDR_VAR 0 10
67656: PUSH
67657: DOUBLE
67658: LD_VAR 0 15
67662: DEC
67663: ST_TO_ADDR
67664: LD_INT 5
67666: PUSH
67667: FOR_TO
67668: IFFALSE 67784
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
67670: LD_ADDR_VAR 0 11
67674: PUSH
67675: LD_VAR 0 13
67679: PPUSH
67680: CALL_OW 250
67684: PPUSH
67685: LD_VAR 0 10
67689: PPUSH
67690: LD_INT 2
67692: PPUSH
67693: CALL_OW 272
67697: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
67698: LD_ADDR_VAR 0 12
67702: PUSH
67703: LD_VAR 0 13
67707: PPUSH
67708: CALL_OW 251
67712: PPUSH
67713: LD_VAR 0 10
67717: PPUSH
67718: LD_INT 2
67720: PPUSH
67721: CALL_OW 273
67725: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
67726: LD_VAR 0 11
67730: PPUSH
67731: LD_VAR 0 12
67735: PPUSH
67736: CALL_OW 488
67740: IFFALSE 67759
67742: PUSH
67743: LD_VAR 0 11
67747: PPUSH
67748: LD_VAR 0 12
67752: PPUSH
67753: CALL_OW 428
67757: NOT
67758: AND
67759: IFFALSE 67782
// begin ComMoveXY ( tmp , _x , _y ) ;
67761: LD_VAR 0 13
67765: PPUSH
67766: LD_VAR 0 11
67770: PPUSH
67771: LD_VAR 0 12
67775: PPUSH
67776: CALL_OW 111
// break ;
67780: GO 67784
// end ; end ;
67782: GO 67667
67784: POP
67785: POP
// end ; end ;
67786: GO 67099
67788: POP
67789: POP
// end ;
67790: LD_VAR 0 8
67794: RET
// export function BuildingTechInvented ( side , btype ) ; begin
67795: LD_INT 0
67797: PPUSH
// result := true ;
67798: LD_ADDR_VAR 0 3
67802: PUSH
67803: LD_INT 1
67805: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
67806: LD_VAR 0 2
67810: PUSH
67811: LD_INT 24
67813: DOUBLE
67814: EQUAL
67815: IFTRUE 67825
67817: LD_INT 33
67819: DOUBLE
67820: EQUAL
67821: IFTRUE 67825
67823: GO 67850
67825: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
67826: LD_ADDR_VAR 0 3
67830: PUSH
67831: LD_INT 32
67833: PPUSH
67834: LD_VAR 0 1
67838: PPUSH
67839: CALL_OW 321
67843: PUSH
67844: LD_INT 2
67846: EQUAL
67847: ST_TO_ADDR
67848: GO 68166
67850: LD_INT 20
67852: DOUBLE
67853: EQUAL
67854: IFTRUE 67858
67856: GO 67883
67858: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
67859: LD_ADDR_VAR 0 3
67863: PUSH
67864: LD_INT 6
67866: PPUSH
67867: LD_VAR 0 1
67871: PPUSH
67872: CALL_OW 321
67876: PUSH
67877: LD_INT 2
67879: EQUAL
67880: ST_TO_ADDR
67881: GO 68166
67883: LD_INT 22
67885: DOUBLE
67886: EQUAL
67887: IFTRUE 67897
67889: LD_INT 36
67891: DOUBLE
67892: EQUAL
67893: IFTRUE 67897
67895: GO 67922
67897: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
67898: LD_ADDR_VAR 0 3
67902: PUSH
67903: LD_INT 15
67905: PPUSH
67906: LD_VAR 0 1
67910: PPUSH
67911: CALL_OW 321
67915: PUSH
67916: LD_INT 2
67918: EQUAL
67919: ST_TO_ADDR
67920: GO 68166
67922: LD_INT 30
67924: DOUBLE
67925: EQUAL
67926: IFTRUE 67930
67928: GO 67955
67930: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
67931: LD_ADDR_VAR 0 3
67935: PUSH
67936: LD_INT 20
67938: PPUSH
67939: LD_VAR 0 1
67943: PPUSH
67944: CALL_OW 321
67948: PUSH
67949: LD_INT 2
67951: EQUAL
67952: ST_TO_ADDR
67953: GO 68166
67955: LD_INT 28
67957: DOUBLE
67958: EQUAL
67959: IFTRUE 67969
67961: LD_INT 21
67963: DOUBLE
67964: EQUAL
67965: IFTRUE 67969
67967: GO 67994
67969: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
67970: LD_ADDR_VAR 0 3
67974: PUSH
67975: LD_INT 21
67977: PPUSH
67978: LD_VAR 0 1
67982: PPUSH
67983: CALL_OW 321
67987: PUSH
67988: LD_INT 2
67990: EQUAL
67991: ST_TO_ADDR
67992: GO 68166
67994: LD_INT 16
67996: DOUBLE
67997: EQUAL
67998: IFTRUE 68002
68000: GO 68027
68002: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
68003: LD_ADDR_VAR 0 3
68007: PUSH
68008: LD_INT 84
68010: PPUSH
68011: LD_VAR 0 1
68015: PPUSH
68016: CALL_OW 321
68020: PUSH
68021: LD_INT 2
68023: EQUAL
68024: ST_TO_ADDR
68025: GO 68166
68027: LD_INT 19
68029: DOUBLE
68030: EQUAL
68031: IFTRUE 68041
68033: LD_INT 23
68035: DOUBLE
68036: EQUAL
68037: IFTRUE 68041
68039: GO 68066
68041: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
68042: LD_ADDR_VAR 0 3
68046: PUSH
68047: LD_INT 83
68049: PPUSH
68050: LD_VAR 0 1
68054: PPUSH
68055: CALL_OW 321
68059: PUSH
68060: LD_INT 2
68062: EQUAL
68063: ST_TO_ADDR
68064: GO 68166
68066: LD_INT 17
68068: DOUBLE
68069: EQUAL
68070: IFTRUE 68074
68072: GO 68099
68074: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
68075: LD_ADDR_VAR 0 3
68079: PUSH
68080: LD_INT 39
68082: PPUSH
68083: LD_VAR 0 1
68087: PPUSH
68088: CALL_OW 321
68092: PUSH
68093: LD_INT 2
68095: EQUAL
68096: ST_TO_ADDR
68097: GO 68166
68099: LD_INT 18
68101: DOUBLE
68102: EQUAL
68103: IFTRUE 68107
68105: GO 68132
68107: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
68108: LD_ADDR_VAR 0 3
68112: PUSH
68113: LD_INT 40
68115: PPUSH
68116: LD_VAR 0 1
68120: PPUSH
68121: CALL_OW 321
68125: PUSH
68126: LD_INT 2
68128: EQUAL
68129: ST_TO_ADDR
68130: GO 68166
68132: LD_INT 27
68134: DOUBLE
68135: EQUAL
68136: IFTRUE 68140
68138: GO 68165
68140: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
68141: LD_ADDR_VAR 0 3
68145: PUSH
68146: LD_INT 35
68148: PPUSH
68149: LD_VAR 0 1
68153: PPUSH
68154: CALL_OW 321
68158: PUSH
68159: LD_INT 2
68161: EQUAL
68162: ST_TO_ADDR
68163: GO 68166
68165: POP
// end ;
68166: LD_VAR 0 3
68170: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
68171: LD_INT 0
68173: PPUSH
68174: PPUSH
68175: PPUSH
68176: PPUSH
68177: PPUSH
68178: PPUSH
68179: PPUSH
68180: PPUSH
68181: PPUSH
68182: PPUSH
68183: PPUSH
// result := false ;
68184: LD_ADDR_VAR 0 6
68188: PUSH
68189: LD_INT 0
68191: ST_TO_ADDR
// if btype = b_depot then
68192: LD_VAR 0 2
68196: PUSH
68197: LD_INT 0
68199: EQUAL
68200: IFFALSE 68212
// begin result := true ;
68202: LD_ADDR_VAR 0 6
68206: PUSH
68207: LD_INT 1
68209: ST_TO_ADDR
// exit ;
68210: GO 69066
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
68212: LD_VAR 0 1
68216: NOT
68217: IFTRUE 68242
68219: PUSH
68220: LD_VAR 0 1
68224: PPUSH
68225: CALL_OW 266
68229: PUSH
68230: LD_INT 0
68232: PUSH
68233: LD_INT 1
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: IN
68240: NOT
68241: OR
68242: IFTRUE 68251
68244: PUSH
68245: LD_VAR 0 2
68249: NOT
68250: OR
68251: IFTRUE 68287
68253: PUSH
68254: LD_VAR 0 5
68258: PUSH
68259: LD_INT 0
68261: PUSH
68262: LD_INT 1
68264: PUSH
68265: LD_INT 2
68267: PUSH
68268: LD_INT 3
68270: PUSH
68271: LD_INT 4
68273: PUSH
68274: LD_INT 5
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: IN
68285: NOT
68286: OR
68287: IFTRUE 68306
68289: PUSH
68290: LD_VAR 0 3
68294: PPUSH
68295: LD_VAR 0 4
68299: PPUSH
68300: CALL_OW 488
68304: NOT
68305: OR
68306: IFFALSE 68310
// exit ;
68308: GO 69066
// side := GetSide ( depot ) ;
68310: LD_ADDR_VAR 0 9
68314: PUSH
68315: LD_VAR 0 1
68319: PPUSH
68320: CALL_OW 255
68324: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
68325: LD_VAR 0 9
68329: PPUSH
68330: LD_VAR 0 2
68334: PPUSH
68335: CALL 67795 0 2
68339: NOT
68340: IFFALSE 68344
// exit ;
68342: GO 69066
// pom := GetBase ( depot ) ;
68344: LD_ADDR_VAR 0 10
68348: PUSH
68349: LD_VAR 0 1
68353: PPUSH
68354: CALL_OW 274
68358: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
68359: LD_ADDR_VAR 0 11
68363: PUSH
68364: LD_VAR 0 2
68368: PPUSH
68369: LD_VAR 0 1
68373: PPUSH
68374: CALL_OW 248
68378: PPUSH
68379: CALL_OW 450
68383: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
68384: LD_VAR 0 10
68388: PPUSH
68389: LD_INT 1
68391: PPUSH
68392: CALL_OW 275
68396: PUSH
68397: LD_VAR 0 11
68401: PUSH
68402: LD_INT 1
68404: ARRAY
68405: GREATEREQUAL
68406: IFFALSE 68432
68408: PUSH
68409: LD_VAR 0 10
68413: PPUSH
68414: LD_INT 2
68416: PPUSH
68417: CALL_OW 275
68421: PUSH
68422: LD_VAR 0 11
68426: PUSH
68427: LD_INT 2
68429: ARRAY
68430: GREATEREQUAL
68431: AND
68432: IFFALSE 68458
68434: PUSH
68435: LD_VAR 0 10
68439: PPUSH
68440: LD_INT 3
68442: PPUSH
68443: CALL_OW 275
68447: PUSH
68448: LD_VAR 0 11
68452: PUSH
68453: LD_INT 3
68455: ARRAY
68456: GREATEREQUAL
68457: AND
68458: NOT
68459: IFFALSE 68463
// exit ;
68461: GO 69066
// if GetBType ( depot ) = b_depot then
68463: LD_VAR 0 1
68467: PPUSH
68468: CALL_OW 266
68472: PUSH
68473: LD_INT 0
68475: EQUAL
68476: IFFALSE 68488
// dist := 28 else
68478: LD_ADDR_VAR 0 14
68482: PUSH
68483: LD_INT 28
68485: ST_TO_ADDR
68486: GO 68496
// dist := 36 ;
68488: LD_ADDR_VAR 0 14
68492: PUSH
68493: LD_INT 36
68495: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
68496: LD_VAR 0 1
68500: PPUSH
68501: LD_VAR 0 3
68505: PPUSH
68506: LD_VAR 0 4
68510: PPUSH
68511: CALL_OW 297
68515: PUSH
68516: LD_VAR 0 14
68520: GREATER
68521: IFFALSE 68525
// exit ;
68523: GO 69066
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
68525: LD_ADDR_VAR 0 12
68529: PUSH
68530: LD_VAR 0 2
68534: PPUSH
68535: LD_VAR 0 3
68539: PPUSH
68540: LD_VAR 0 4
68544: PPUSH
68545: LD_VAR 0 5
68549: PPUSH
68550: LD_VAR 0 1
68554: PPUSH
68555: CALL_OW 248
68559: PPUSH
68560: LD_INT 0
68562: PPUSH
68563: CALL 69071 0 6
68567: ST_TO_ADDR
// if not hexes then
68568: LD_VAR 0 12
68572: NOT
68573: IFFALSE 68577
// exit ;
68575: GO 69066
// hex := GetHexInfo ( x , y ) ;
68577: LD_ADDR_VAR 0 15
68581: PUSH
68582: LD_VAR 0 3
68586: PPUSH
68587: LD_VAR 0 4
68591: PPUSH
68592: CALL_OW 546
68596: ST_TO_ADDR
// if hex [ 1 ] then
68597: LD_VAR 0 15
68601: PUSH
68602: LD_INT 1
68604: ARRAY
68605: IFFALSE 68609
// exit ;
68607: GO 69066
// height := hex [ 2 ] ;
68609: LD_ADDR_VAR 0 13
68613: PUSH
68614: LD_VAR 0 15
68618: PUSH
68619: LD_INT 2
68621: ARRAY
68622: ST_TO_ADDR
// for i = 1 to hexes do
68623: LD_ADDR_VAR 0 7
68627: PUSH
68628: DOUBLE
68629: LD_INT 1
68631: DEC
68632: ST_TO_ADDR
68633: LD_VAR 0 12
68637: PUSH
68638: FOR_TO
68639: IFFALSE 68983
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
68641: LD_VAR 0 12
68645: PUSH
68646: LD_VAR 0 7
68650: ARRAY
68651: PUSH
68652: LD_INT 1
68654: ARRAY
68655: PPUSH
68656: LD_VAR 0 12
68660: PUSH
68661: LD_VAR 0 7
68665: ARRAY
68666: PUSH
68667: LD_INT 2
68669: ARRAY
68670: PPUSH
68671: CALL_OW 488
68675: NOT
68676: IFTRUE 68718
68678: PUSH
68679: LD_VAR 0 12
68683: PUSH
68684: LD_VAR 0 7
68688: ARRAY
68689: PUSH
68690: LD_INT 1
68692: ARRAY
68693: PPUSH
68694: LD_VAR 0 12
68698: PUSH
68699: LD_VAR 0 7
68703: ARRAY
68704: PUSH
68705: LD_INT 2
68707: ARRAY
68708: PPUSH
68709: CALL_OW 428
68713: PUSH
68714: LD_INT 0
68716: GREATER
68717: OR
68718: IFTRUE 68756
68720: PUSH
68721: LD_VAR 0 12
68725: PUSH
68726: LD_VAR 0 7
68730: ARRAY
68731: PUSH
68732: LD_INT 1
68734: ARRAY
68735: PPUSH
68736: LD_VAR 0 12
68740: PUSH
68741: LD_VAR 0 7
68745: ARRAY
68746: PUSH
68747: LD_INT 2
68749: ARRAY
68750: PPUSH
68751: CALL_OW 351
68755: OR
68756: IFFALSE 68762
// exit ;
68758: POP
68759: POP
68760: GO 69066
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
68762: LD_ADDR_VAR 0 8
68766: PUSH
68767: LD_VAR 0 12
68771: PUSH
68772: LD_VAR 0 7
68776: ARRAY
68777: PUSH
68778: LD_INT 1
68780: ARRAY
68781: PPUSH
68782: LD_VAR 0 12
68786: PUSH
68787: LD_VAR 0 7
68791: ARRAY
68792: PUSH
68793: LD_INT 2
68795: ARRAY
68796: PPUSH
68797: CALL_OW 546
68801: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
68802: LD_VAR 0 8
68806: PUSH
68807: LD_INT 1
68809: ARRAY
68810: IFTRUE 68832
68812: PUSH
68813: LD_VAR 0 8
68817: PUSH
68818: LD_INT 2
68820: ARRAY
68821: PUSH
68822: LD_VAR 0 13
68826: PUSH
68827: LD_INT 2
68829: PLUS
68830: GREATER
68831: OR
68832: IFTRUE 68854
68834: PUSH
68835: LD_VAR 0 8
68839: PUSH
68840: LD_INT 2
68842: ARRAY
68843: PUSH
68844: LD_VAR 0 13
68848: PUSH
68849: LD_INT 2
68851: MINUS
68852: LESS
68853: OR
68854: IFTRUE 68922
68856: PUSH
68857: LD_VAR 0 8
68861: PUSH
68862: LD_INT 3
68864: ARRAY
68865: PUSH
68866: LD_INT 0
68868: PUSH
68869: LD_INT 8
68871: PUSH
68872: LD_INT 9
68874: PUSH
68875: LD_INT 10
68877: PUSH
68878: LD_INT 11
68880: PUSH
68881: LD_INT 12
68883: PUSH
68884: LD_INT 13
68886: PUSH
68887: LD_INT 16
68889: PUSH
68890: LD_INT 17
68892: PUSH
68893: LD_INT 18
68895: PUSH
68896: LD_INT 19
68898: PUSH
68899: LD_INT 20
68901: PUSH
68902: LD_INT 21
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: IN
68920: NOT
68921: OR
68922: IFTRUE 68935
68924: PUSH
68925: LD_VAR 0 8
68929: PUSH
68930: LD_INT 5
68932: ARRAY
68933: NOT
68934: OR
68935: IFTRUE 68975
68937: PUSH
68938: LD_VAR 0 8
68942: PUSH
68943: LD_INT 6
68945: ARRAY
68946: PUSH
68947: LD_INT 1
68949: PUSH
68950: LD_INT 2
68952: PUSH
68953: LD_INT 7
68955: PUSH
68956: LD_INT 9
68958: PUSH
68959: LD_INT 10
68961: PUSH
68962: LD_INT 11
68964: PUSH
68965: EMPTY
68966: LIST
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: IN
68973: NOT
68974: OR
68975: IFFALSE 68981
// exit ;
68977: POP
68978: POP
68979: GO 69066
// end ;
68981: GO 68638
68983: POP
68984: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
68985: LD_VAR 0 9
68989: PPUSH
68990: LD_VAR 0 3
68994: PPUSH
68995: LD_VAR 0 4
68999: PPUSH
69000: LD_INT 20
69002: PPUSH
69003: CALL 60885 0 4
69007: PUSH
69008: LD_INT 4
69010: ARRAY
69011: IFFALSE 69015
// exit ;
69013: GO 69066
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
69015: LD_VAR 0 2
69019: PUSH
69020: LD_INT 29
69022: PUSH
69023: LD_INT 30
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: IN
69030: IFFALSE 69054
69032: PUSH
69033: LD_VAR 0 3
69037: PPUSH
69038: LD_VAR 0 4
69042: PPUSH
69043: LD_VAR 0 9
69047: PPUSH
69048: CALL_OW 440
69052: NOT
69053: AND
69054: IFFALSE 69058
// exit ;
69056: GO 69066
// result := true ;
69058: LD_ADDR_VAR 0 6
69062: PUSH
69063: LD_INT 1
69065: ST_TO_ADDR
// end ;
69066: LD_VAR 0 6
69070: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
69071: LD_INT 0
69073: PPUSH
69074: PPUSH
69075: PPUSH
69076: PPUSH
69077: PPUSH
69078: PPUSH
69079: PPUSH
69080: PPUSH
69081: PPUSH
69082: PPUSH
69083: PPUSH
69084: PPUSH
69085: PPUSH
69086: PPUSH
69087: PPUSH
69088: PPUSH
69089: PPUSH
69090: PPUSH
69091: PPUSH
69092: PPUSH
69093: PPUSH
69094: PPUSH
69095: PPUSH
69096: PPUSH
69097: PPUSH
69098: PPUSH
69099: PPUSH
69100: PPUSH
69101: PPUSH
69102: PPUSH
69103: PPUSH
69104: PPUSH
69105: PPUSH
69106: PPUSH
69107: PPUSH
69108: PPUSH
69109: PPUSH
69110: PPUSH
69111: PPUSH
69112: PPUSH
69113: PPUSH
69114: PPUSH
69115: PPUSH
69116: PPUSH
69117: PPUSH
69118: PPUSH
69119: PPUSH
69120: PPUSH
69121: PPUSH
69122: PPUSH
69123: PPUSH
69124: PPUSH
69125: PPUSH
69126: PPUSH
69127: PPUSH
69128: PPUSH
69129: PPUSH
69130: PPUSH
// result = [ ] ;
69131: LD_ADDR_VAR 0 7
69135: PUSH
69136: EMPTY
69137: ST_TO_ADDR
// temp_list = [ ] ;
69138: LD_ADDR_VAR 0 9
69142: PUSH
69143: EMPTY
69144: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
69145: LD_VAR 0 4
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: LD_INT 1
69155: PUSH
69156: LD_INT 2
69158: PUSH
69159: LD_INT 3
69161: PUSH
69162: LD_INT 4
69164: PUSH
69165: LD_INT 5
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: IN
69176: NOT
69177: IFTRUE 69220
69179: PUSH
69180: LD_VAR 0 1
69184: PUSH
69185: LD_INT 0
69187: PUSH
69188: LD_INT 1
69190: PUSH
69191: EMPTY
69192: LIST
69193: LIST
69194: IN
69195: IFFALSE 69219
69197: PUSH
69198: LD_VAR 0 5
69202: PUSH
69203: LD_INT 1
69205: PUSH
69206: LD_INT 2
69208: PUSH
69209: LD_INT 3
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: LIST
69216: IN
69217: NOT
69218: AND
69219: OR
69220: IFFALSE 69224
// exit ;
69222: GO 87623
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
69224: LD_VAR 0 1
69228: PUSH
69229: LD_INT 6
69231: PUSH
69232: LD_INT 7
69234: PUSH
69235: LD_INT 8
69237: PUSH
69238: LD_INT 13
69240: PUSH
69241: LD_INT 12
69243: PUSH
69244: LD_INT 15
69246: PUSH
69247: LD_INT 11
69249: PUSH
69250: LD_INT 14
69252: PUSH
69253: LD_INT 10
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: LIST
69263: LIST
69264: LIST
69265: LIST
69266: IN
69267: IFFALSE 69277
// btype = b_lab ;
69269: LD_ADDR_VAR 0 1
69273: PUSH
69274: LD_INT 6
69276: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
69277: LD_VAR 0 6
69281: PUSH
69282: LD_INT 0
69284: PUSH
69285: LD_INT 1
69287: PUSH
69288: LD_INT 2
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: LIST
69295: IN
69296: NOT
69297: IFTRUE 69365
69299: PUSH
69300: LD_VAR 0 1
69304: PUSH
69305: LD_INT 0
69307: PUSH
69308: LD_INT 1
69310: PUSH
69311: LD_INT 2
69313: PUSH
69314: LD_INT 3
69316: PUSH
69317: LD_INT 6
69319: PUSH
69320: LD_INT 36
69322: PUSH
69323: LD_INT 4
69325: PUSH
69326: LD_INT 5
69328: PUSH
69329: LD_INT 31
69331: PUSH
69332: LD_INT 32
69334: PUSH
69335: LD_INT 33
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: IN
69351: NOT
69352: IFFALSE 69364
69354: PUSH
69355: LD_VAR 0 6
69359: PUSH
69360: LD_INT 1
69362: EQUAL
69363: AND
69364: OR
69365: IFTRUE 69397
69367: PUSH
69368: LD_VAR 0 1
69372: PUSH
69373: LD_INT 2
69375: PUSH
69376: LD_INT 3
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: IN
69383: NOT
69384: IFFALSE 69396
69386: PUSH
69387: LD_VAR 0 6
69391: PUSH
69392: LD_INT 2
69394: EQUAL
69395: AND
69396: OR
69397: IFFALSE 69407
// mode = 0 ;
69399: LD_ADDR_VAR 0 6
69403: PUSH
69404: LD_INT 0
69406: ST_TO_ADDR
// case mode of 0 :
69407: LD_VAR 0 6
69411: PUSH
69412: LD_INT 0
69414: DOUBLE
69415: EQUAL
69416: IFTRUE 69420
69418: GO 80873
69420: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
69421: LD_ADDR_VAR 0 11
69425: PUSH
69426: LD_INT 0
69428: PUSH
69429: LD_INT 0
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 0
69438: PUSH
69439: LD_INT 1
69441: NEG
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 1
69449: PUSH
69450: LD_INT 0
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 1
69459: PUSH
69460: LD_INT 1
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 0
69469: PUSH
69470: LD_INT 1
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 1
69479: NEG
69480: PUSH
69481: LD_INT 0
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 1
69490: NEG
69491: PUSH
69492: LD_INT 1
69494: NEG
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: LD_INT 1
69502: NEG
69503: PUSH
69504: LD_INT 2
69506: NEG
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 0
69514: PUSH
69515: LD_INT 2
69517: NEG
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: LD_INT 1
69525: PUSH
69526: LD_INT 1
69528: NEG
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 1
69536: PUSH
69537: LD_INT 2
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 0
69546: PUSH
69547: LD_INT 2
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 1
69556: NEG
69557: PUSH
69558: LD_INT 1
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 1
69567: PUSH
69568: LD_INT 3
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 0
69577: PUSH
69578: LD_INT 3
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 1
69587: NEG
69588: PUSH
69589: LD_INT 2
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: LIST
69609: LIST
69610: LIST
69611: LIST
69612: LIST
69613: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69614: LD_ADDR_VAR 0 12
69618: PUSH
69619: LD_INT 0
69621: PUSH
69622: LD_INT 0
69624: PUSH
69625: EMPTY
69626: LIST
69627: LIST
69628: PUSH
69629: LD_INT 0
69631: PUSH
69632: LD_INT 1
69634: NEG
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 1
69642: PUSH
69643: LD_INT 0
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 1
69652: PUSH
69653: LD_INT 1
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: LD_INT 0
69662: PUSH
69663: LD_INT 1
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 1
69672: NEG
69673: PUSH
69674: LD_INT 0
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 1
69683: NEG
69684: PUSH
69685: LD_INT 1
69687: NEG
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: LD_INT 1
69695: PUSH
69696: LD_INT 1
69698: NEG
69699: PUSH
69700: EMPTY
69701: LIST
69702: LIST
69703: PUSH
69704: LD_INT 2
69706: PUSH
69707: LD_INT 0
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 2
69716: PUSH
69717: LD_INT 1
69719: PUSH
69720: EMPTY
69721: LIST
69722: LIST
69723: PUSH
69724: LD_INT 1
69726: NEG
69727: PUSH
69728: LD_INT 1
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 2
69737: NEG
69738: PUSH
69739: LD_INT 0
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 2
69748: NEG
69749: PUSH
69750: LD_INT 1
69752: NEG
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 2
69760: NEG
69761: PUSH
69762: LD_INT 1
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 3
69771: NEG
69772: PUSH
69773: LD_INT 0
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: PUSH
69780: LD_INT 3
69782: NEG
69783: PUSH
69784: LD_INT 1
69786: NEG
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: LIST
69796: LIST
69797: LIST
69798: LIST
69799: LIST
69800: LIST
69801: LIST
69802: LIST
69803: LIST
69804: LIST
69805: LIST
69806: LIST
69807: LIST
69808: LIST
69809: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69810: LD_ADDR_VAR 0 13
69814: PUSH
69815: LD_INT 0
69817: PUSH
69818: LD_INT 0
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: LD_INT 0
69827: PUSH
69828: LD_INT 1
69830: NEG
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: PUSH
69836: LD_INT 1
69838: PUSH
69839: LD_INT 0
69841: PUSH
69842: EMPTY
69843: LIST
69844: LIST
69845: PUSH
69846: LD_INT 1
69848: PUSH
69849: LD_INT 1
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 0
69858: PUSH
69859: LD_INT 1
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 1
69868: NEG
69869: PUSH
69870: LD_INT 0
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 1
69879: NEG
69880: PUSH
69881: LD_INT 1
69883: NEG
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 1
69891: NEG
69892: PUSH
69893: LD_INT 2
69895: NEG
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 2
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 2
69913: PUSH
69914: LD_INT 2
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 1
69923: PUSH
69924: LD_INT 2
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 2
69933: NEG
69934: PUSH
69935: LD_INT 1
69937: NEG
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 2
69945: NEG
69946: PUSH
69947: LD_INT 2
69949: NEG
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 2
69957: NEG
69958: PUSH
69959: LD_INT 3
69961: NEG
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 3
69969: NEG
69970: PUSH
69971: LD_INT 2
69973: NEG
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 3
69981: NEG
69982: PUSH
69983: LD_INT 3
69985: NEG
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: LIST
69995: LIST
69996: LIST
69997: LIST
69998: LIST
69999: LIST
70000: LIST
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
70009: LD_ADDR_VAR 0 14
70013: PUSH
70014: LD_INT 0
70016: PUSH
70017: LD_INT 0
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 0
70026: PUSH
70027: LD_INT 1
70029: NEG
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: LD_INT 1
70037: PUSH
70038: LD_INT 0
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 1
70047: PUSH
70048: LD_INT 1
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 0
70057: PUSH
70058: LD_INT 1
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 1
70067: NEG
70068: PUSH
70069: LD_INT 0
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 1
70078: NEG
70079: PUSH
70080: LD_INT 1
70082: NEG
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: LD_INT 1
70090: NEG
70091: PUSH
70092: LD_INT 2
70094: NEG
70095: PUSH
70096: EMPTY
70097: LIST
70098: LIST
70099: PUSH
70100: LD_INT 0
70102: PUSH
70103: LD_INT 2
70105: NEG
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 1
70113: PUSH
70114: LD_INT 1
70116: NEG
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 1
70124: PUSH
70125: LD_INT 2
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 0
70134: PUSH
70135: LD_INT 2
70137: PUSH
70138: EMPTY
70139: LIST
70140: LIST
70141: PUSH
70142: LD_INT 1
70144: NEG
70145: PUSH
70146: LD_INT 1
70148: PUSH
70149: EMPTY
70150: LIST
70151: LIST
70152: PUSH
70153: LD_INT 1
70155: NEG
70156: PUSH
70157: LD_INT 3
70159: NEG
70160: PUSH
70161: EMPTY
70162: LIST
70163: LIST
70164: PUSH
70165: LD_INT 0
70167: PUSH
70168: LD_INT 3
70170: NEG
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 1
70178: PUSH
70179: LD_INT 2
70181: NEG
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
70205: LD_ADDR_VAR 0 15
70209: PUSH
70210: LD_INT 0
70212: PUSH
70213: LD_INT 0
70215: PUSH
70216: EMPTY
70217: LIST
70218: LIST
70219: PUSH
70220: LD_INT 0
70222: PUSH
70223: LD_INT 1
70225: NEG
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: PUSH
70231: LD_INT 1
70233: PUSH
70234: LD_INT 0
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PUSH
70241: LD_INT 1
70243: PUSH
70244: LD_INT 1
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: LD_INT 0
70253: PUSH
70254: LD_INT 1
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: PUSH
70261: LD_INT 1
70263: NEG
70264: PUSH
70265: LD_INT 0
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: LD_INT 1
70278: NEG
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 1
70286: PUSH
70287: LD_INT 1
70289: NEG
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 2
70297: PUSH
70298: LD_INT 0
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 2
70307: PUSH
70308: LD_INT 1
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: LD_INT 1
70317: NEG
70318: PUSH
70319: LD_INT 1
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 2
70328: NEG
70329: PUSH
70330: LD_INT 0
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 2
70339: NEG
70340: PUSH
70341: LD_INT 1
70343: NEG
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 2
70351: PUSH
70352: LD_INT 1
70354: NEG
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 3
70362: PUSH
70363: LD_INT 0
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 3
70372: PUSH
70373: LD_INT 1
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
70398: LD_ADDR_VAR 0 16
70402: PUSH
70403: LD_INT 0
70405: PUSH
70406: LD_INT 0
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 0
70415: PUSH
70416: LD_INT 1
70418: NEG
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: PUSH
70424: LD_INT 1
70426: PUSH
70427: LD_INT 0
70429: PUSH
70430: EMPTY
70431: LIST
70432: LIST
70433: PUSH
70434: LD_INT 1
70436: PUSH
70437: LD_INT 1
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: LD_INT 0
70446: PUSH
70447: LD_INT 1
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 1
70456: NEG
70457: PUSH
70458: LD_INT 0
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PUSH
70465: LD_INT 1
70467: NEG
70468: PUSH
70469: LD_INT 1
70471: NEG
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 1
70479: NEG
70480: PUSH
70481: LD_INT 2
70483: NEG
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 2
70491: PUSH
70492: LD_INT 1
70494: PUSH
70495: EMPTY
70496: LIST
70497: LIST
70498: PUSH
70499: LD_INT 2
70501: PUSH
70502: LD_INT 2
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: PUSH
70509: LD_INT 1
70511: PUSH
70512: LD_INT 2
70514: PUSH
70515: EMPTY
70516: LIST
70517: LIST
70518: PUSH
70519: LD_INT 2
70521: NEG
70522: PUSH
70523: LD_INT 1
70525: NEG
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PUSH
70531: LD_INT 2
70533: NEG
70534: PUSH
70535: LD_INT 2
70537: NEG
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PUSH
70543: LD_INT 3
70545: PUSH
70546: LD_INT 2
70548: PUSH
70549: EMPTY
70550: LIST
70551: LIST
70552: PUSH
70553: LD_INT 3
70555: PUSH
70556: LD_INT 3
70558: PUSH
70559: EMPTY
70560: LIST
70561: LIST
70562: PUSH
70563: LD_INT 2
70565: PUSH
70566: LD_INT 3
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70591: LD_ADDR_VAR 0 17
70595: PUSH
70596: LD_INT 0
70598: PUSH
70599: LD_INT 0
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 0
70608: PUSH
70609: LD_INT 1
70611: NEG
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 1
70619: PUSH
70620: LD_INT 0
70622: PUSH
70623: EMPTY
70624: LIST
70625: LIST
70626: PUSH
70627: LD_INT 1
70629: PUSH
70630: LD_INT 1
70632: PUSH
70633: EMPTY
70634: LIST
70635: LIST
70636: PUSH
70637: LD_INT 0
70639: PUSH
70640: LD_INT 1
70642: PUSH
70643: EMPTY
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 1
70649: NEG
70650: PUSH
70651: LD_INT 0
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: LD_INT 1
70660: NEG
70661: PUSH
70662: LD_INT 1
70664: NEG
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: LD_INT 2
70676: NEG
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: LD_INT 2
70687: NEG
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: LD_INT 1
70695: PUSH
70696: LD_INT 1
70698: NEG
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 2
70706: PUSH
70707: LD_INT 0
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 2
70716: PUSH
70717: LD_INT 1
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 2
70726: PUSH
70727: LD_INT 2
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 1
70736: PUSH
70737: LD_INT 2
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 0
70746: PUSH
70747: LD_INT 2
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 1
70756: NEG
70757: PUSH
70758: LD_INT 1
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 2
70767: NEG
70768: PUSH
70769: LD_INT 0
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 2
70778: NEG
70779: PUSH
70780: LD_INT 1
70782: NEG
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 2
70790: NEG
70791: PUSH
70792: LD_INT 2
70794: NEG
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70821: LD_ADDR_VAR 0 18
70825: PUSH
70826: LD_INT 0
70828: PUSH
70829: LD_INT 0
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 0
70838: PUSH
70839: LD_INT 1
70841: NEG
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 1
70849: PUSH
70850: LD_INT 0
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 1
70859: PUSH
70860: LD_INT 1
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: LD_INT 0
70869: PUSH
70870: LD_INT 1
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 1
70879: NEG
70880: PUSH
70881: LD_INT 0
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PUSH
70888: LD_INT 1
70890: NEG
70891: PUSH
70892: LD_INT 1
70894: NEG
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 1
70902: NEG
70903: PUSH
70904: LD_INT 2
70906: NEG
70907: PUSH
70908: EMPTY
70909: LIST
70910: LIST
70911: PUSH
70912: LD_INT 0
70914: PUSH
70915: LD_INT 2
70917: NEG
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: PUSH
70923: LD_INT 1
70925: PUSH
70926: LD_INT 1
70928: NEG
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 2
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 2
70946: PUSH
70947: LD_INT 1
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 2
70956: PUSH
70957: LD_INT 2
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: PUSH
70964: LD_INT 1
70966: PUSH
70967: LD_INT 2
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 0
70976: PUSH
70977: LD_INT 2
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 1
70986: NEG
70987: PUSH
70988: LD_INT 1
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PUSH
70995: LD_INT 2
70997: NEG
70998: PUSH
70999: LD_INT 0
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PUSH
71006: LD_INT 2
71008: NEG
71009: PUSH
71010: LD_INT 1
71012: NEG
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 2
71020: NEG
71021: PUSH
71022: LD_INT 2
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: LIST
71048: LIST
71049: LIST
71050: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71051: LD_ADDR_VAR 0 19
71055: PUSH
71056: LD_INT 0
71058: PUSH
71059: LD_INT 0
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PUSH
71066: LD_INT 0
71068: PUSH
71069: LD_INT 1
71071: NEG
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 1
71079: PUSH
71080: LD_INT 0
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 1
71089: PUSH
71090: LD_INT 1
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: PUSH
71097: LD_INT 0
71099: PUSH
71100: LD_INT 1
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 1
71109: NEG
71110: PUSH
71111: LD_INT 0
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 1
71120: NEG
71121: PUSH
71122: LD_INT 1
71124: NEG
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: LD_INT 1
71132: NEG
71133: PUSH
71134: LD_INT 2
71136: NEG
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: PUSH
71142: LD_INT 0
71144: PUSH
71145: LD_INT 2
71147: NEG
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: LD_INT 1
71155: PUSH
71156: LD_INT 1
71158: NEG
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PUSH
71164: LD_INT 2
71166: PUSH
71167: LD_INT 0
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 2
71176: PUSH
71177: LD_INT 1
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 2
71186: PUSH
71187: LD_INT 2
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 1
71196: PUSH
71197: LD_INT 2
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 0
71206: PUSH
71207: LD_INT 2
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 1
71216: NEG
71217: PUSH
71218: LD_INT 1
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PUSH
71225: LD_INT 2
71227: NEG
71228: PUSH
71229: LD_INT 0
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 2
71238: NEG
71239: PUSH
71240: LD_INT 1
71242: NEG
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 2
71250: NEG
71251: PUSH
71252: LD_INT 2
71254: NEG
71255: PUSH
71256: EMPTY
71257: LIST
71258: LIST
71259: PUSH
71260: EMPTY
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71281: LD_ADDR_VAR 0 20
71285: PUSH
71286: LD_INT 0
71288: PUSH
71289: LD_INT 0
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: PUSH
71296: LD_INT 0
71298: PUSH
71299: LD_INT 1
71301: NEG
71302: PUSH
71303: EMPTY
71304: LIST
71305: LIST
71306: PUSH
71307: LD_INT 1
71309: PUSH
71310: LD_INT 0
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PUSH
71317: LD_INT 1
71319: PUSH
71320: LD_INT 1
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 0
71329: PUSH
71330: LD_INT 1
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 1
71339: NEG
71340: PUSH
71341: LD_INT 0
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PUSH
71348: LD_INT 1
71350: NEG
71351: PUSH
71352: LD_INT 1
71354: NEG
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: LD_INT 1
71362: NEG
71363: PUSH
71364: LD_INT 2
71366: NEG
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: PUSH
71372: LD_INT 0
71374: PUSH
71375: LD_INT 2
71377: NEG
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: PUSH
71383: LD_INT 1
71385: PUSH
71386: LD_INT 1
71388: NEG
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 2
71396: PUSH
71397: LD_INT 0
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 2
71406: PUSH
71407: LD_INT 1
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: LD_INT 2
71416: PUSH
71417: LD_INT 2
71419: PUSH
71420: EMPTY
71421: LIST
71422: LIST
71423: PUSH
71424: LD_INT 1
71426: PUSH
71427: LD_INT 2
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 0
71436: PUSH
71437: LD_INT 2
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PUSH
71444: LD_INT 1
71446: NEG
71447: PUSH
71448: LD_INT 1
71450: PUSH
71451: EMPTY
71452: LIST
71453: LIST
71454: PUSH
71455: LD_INT 2
71457: NEG
71458: PUSH
71459: LD_INT 0
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: PUSH
71466: LD_INT 2
71468: NEG
71469: PUSH
71470: LD_INT 1
71472: NEG
71473: PUSH
71474: EMPTY
71475: LIST
71476: LIST
71477: PUSH
71478: LD_INT 2
71480: NEG
71481: PUSH
71482: LD_INT 2
71484: NEG
71485: PUSH
71486: EMPTY
71487: LIST
71488: LIST
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: LIST
71507: LIST
71508: LIST
71509: LIST
71510: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71511: LD_ADDR_VAR 0 21
71515: PUSH
71516: LD_INT 0
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: EMPTY
71523: LIST
71524: LIST
71525: PUSH
71526: LD_INT 0
71528: PUSH
71529: LD_INT 1
71531: NEG
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 1
71539: PUSH
71540: LD_INT 0
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 1
71549: PUSH
71550: LD_INT 1
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 0
71559: PUSH
71560: LD_INT 1
71562: PUSH
71563: EMPTY
71564: LIST
71565: LIST
71566: PUSH
71567: LD_INT 1
71569: NEG
71570: PUSH
71571: LD_INT 0
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: LD_INT 1
71580: NEG
71581: PUSH
71582: LD_INT 1
71584: NEG
71585: PUSH
71586: EMPTY
71587: LIST
71588: LIST
71589: PUSH
71590: LD_INT 1
71592: NEG
71593: PUSH
71594: LD_INT 2
71596: NEG
71597: PUSH
71598: EMPTY
71599: LIST
71600: LIST
71601: PUSH
71602: LD_INT 0
71604: PUSH
71605: LD_INT 2
71607: NEG
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: LD_INT 1
71615: PUSH
71616: LD_INT 1
71618: NEG
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 2
71626: PUSH
71627: LD_INT 0
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 2
71636: PUSH
71637: LD_INT 1
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 2
71646: PUSH
71647: LD_INT 2
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 1
71656: PUSH
71657: LD_INT 2
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: PUSH
71664: LD_INT 0
71666: PUSH
71667: LD_INT 2
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: LD_INT 1
71676: NEG
71677: PUSH
71678: LD_INT 1
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: PUSH
71685: LD_INT 2
71687: NEG
71688: PUSH
71689: LD_INT 0
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: LD_INT 2
71698: NEG
71699: PUSH
71700: LD_INT 1
71702: NEG
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: PUSH
71708: LD_INT 2
71710: NEG
71711: PUSH
71712: LD_INT 2
71714: NEG
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: LIST
71736: LIST
71737: LIST
71738: LIST
71739: LIST
71740: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71741: LD_ADDR_VAR 0 22
71745: PUSH
71746: LD_INT 0
71748: PUSH
71749: LD_INT 0
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 0
71758: PUSH
71759: LD_INT 1
71761: NEG
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: LD_INT 1
71769: PUSH
71770: LD_INT 0
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: PUSH
71777: LD_INT 1
71779: PUSH
71780: LD_INT 1
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: PUSH
71787: LD_INT 0
71789: PUSH
71790: LD_INT 1
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: PUSH
71797: LD_INT 1
71799: NEG
71800: PUSH
71801: LD_INT 0
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: PUSH
71808: LD_INT 1
71810: NEG
71811: PUSH
71812: LD_INT 1
71814: NEG
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: PUSH
71820: LD_INT 1
71822: NEG
71823: PUSH
71824: LD_INT 2
71826: NEG
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 0
71834: PUSH
71835: LD_INT 2
71837: NEG
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 1
71845: PUSH
71846: LD_INT 1
71848: NEG
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 2
71856: PUSH
71857: LD_INT 0
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: LD_INT 2
71866: PUSH
71867: LD_INT 1
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: LD_INT 2
71876: PUSH
71877: LD_INT 2
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 1
71886: PUSH
71887: LD_INT 2
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 0
71896: PUSH
71897: LD_INT 2
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 1
71906: NEG
71907: PUSH
71908: LD_INT 1
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 2
71917: NEG
71918: PUSH
71919: LD_INT 0
71921: PUSH
71922: EMPTY
71923: LIST
71924: LIST
71925: PUSH
71926: LD_INT 2
71928: NEG
71929: PUSH
71930: LD_INT 1
71932: NEG
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PUSH
71938: LD_INT 2
71940: NEG
71941: PUSH
71942: LD_INT 2
71944: NEG
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: LIST
71970: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
71971: LD_ADDR_VAR 0 23
71975: PUSH
71976: LD_INT 0
71978: PUSH
71979: LD_INT 0
71981: PUSH
71982: EMPTY
71983: LIST
71984: LIST
71985: PUSH
71986: LD_INT 0
71988: PUSH
71989: LD_INT 1
71991: NEG
71992: PUSH
71993: EMPTY
71994: LIST
71995: LIST
71996: PUSH
71997: LD_INT 1
71999: PUSH
72000: LD_INT 0
72002: PUSH
72003: EMPTY
72004: LIST
72005: LIST
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: LD_INT 1
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: LD_INT 0
72019: PUSH
72020: LD_INT 1
72022: PUSH
72023: EMPTY
72024: LIST
72025: LIST
72026: PUSH
72027: LD_INT 1
72029: NEG
72030: PUSH
72031: LD_INT 0
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 1
72040: NEG
72041: PUSH
72042: LD_INT 1
72044: NEG
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: PUSH
72050: LD_INT 1
72052: NEG
72053: PUSH
72054: LD_INT 2
72056: NEG
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: PUSH
72062: LD_INT 0
72064: PUSH
72065: LD_INT 2
72067: NEG
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: PUSH
72073: LD_INT 1
72075: PUSH
72076: LD_INT 1
72078: NEG
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: PUSH
72084: LD_INT 2
72086: PUSH
72087: LD_INT 0
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: LD_INT 2
72096: PUSH
72097: LD_INT 1
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 2
72106: PUSH
72107: LD_INT 2
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 1
72116: PUSH
72117: LD_INT 2
72119: PUSH
72120: EMPTY
72121: LIST
72122: LIST
72123: PUSH
72124: LD_INT 0
72126: PUSH
72127: LD_INT 2
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 1
72136: NEG
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 2
72147: NEG
72148: PUSH
72149: LD_INT 0
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 2
72158: NEG
72159: PUSH
72160: LD_INT 1
72162: NEG
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 2
72170: NEG
72171: PUSH
72172: LD_INT 2
72174: NEG
72175: PUSH
72176: EMPTY
72177: LIST
72178: LIST
72179: PUSH
72180: LD_INT 2
72182: NEG
72183: PUSH
72184: LD_INT 3
72186: NEG
72187: PUSH
72188: EMPTY
72189: LIST
72190: LIST
72191: PUSH
72192: LD_INT 1
72194: NEG
72195: PUSH
72196: LD_INT 3
72198: NEG
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 1
72206: PUSH
72207: LD_INT 2
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 2
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: LIST
72230: LIST
72231: LIST
72232: LIST
72233: LIST
72234: LIST
72235: LIST
72236: LIST
72237: LIST
72238: LIST
72239: LIST
72240: LIST
72241: LIST
72242: LIST
72243: LIST
72244: LIST
72245: LIST
72246: LIST
72247: LIST
72248: LIST
72249: LIST
72250: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
72251: LD_ADDR_VAR 0 24
72255: PUSH
72256: LD_INT 0
72258: PUSH
72259: LD_INT 0
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: PUSH
72266: LD_INT 0
72268: PUSH
72269: LD_INT 1
72271: NEG
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 1
72279: PUSH
72280: LD_INT 0
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 1
72289: PUSH
72290: LD_INT 1
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 0
72299: PUSH
72300: LD_INT 1
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 1
72309: NEG
72310: PUSH
72311: LD_INT 0
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: PUSH
72318: LD_INT 1
72320: NEG
72321: PUSH
72322: LD_INT 1
72324: NEG
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: LD_INT 1
72332: NEG
72333: PUSH
72334: LD_INT 2
72336: NEG
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: LD_INT 0
72344: PUSH
72345: LD_INT 2
72347: NEG
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: PUSH
72353: LD_INT 1
72355: PUSH
72356: LD_INT 1
72358: NEG
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: PUSH
72364: LD_INT 2
72366: PUSH
72367: LD_INT 0
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 2
72376: PUSH
72377: LD_INT 1
72379: PUSH
72380: EMPTY
72381: LIST
72382: LIST
72383: PUSH
72384: LD_INT 2
72386: PUSH
72387: LD_INT 2
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: PUSH
72394: LD_INT 1
72396: PUSH
72397: LD_INT 2
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: PUSH
72404: LD_INT 0
72406: PUSH
72407: LD_INT 2
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 1
72416: NEG
72417: PUSH
72418: LD_INT 1
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 2
72427: NEG
72428: PUSH
72429: LD_INT 0
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: LD_INT 2
72438: NEG
72439: PUSH
72440: LD_INT 1
72442: NEG
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: PUSH
72448: LD_INT 2
72450: NEG
72451: PUSH
72452: LD_INT 2
72454: NEG
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: PUSH
72460: LD_INT 1
72462: PUSH
72463: LD_INT 2
72465: NEG
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: LD_INT 2
72473: PUSH
72474: LD_INT 1
72476: NEG
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 3
72484: PUSH
72485: LD_INT 1
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 3
72494: PUSH
72495: LD_INT 2
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: EMPTY
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: LIST
72513: LIST
72514: LIST
72515: LIST
72516: LIST
72517: LIST
72518: LIST
72519: LIST
72520: LIST
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
72527: LD_ADDR_VAR 0 25
72531: PUSH
72532: LD_INT 0
72534: PUSH
72535: LD_INT 0
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 0
72544: PUSH
72545: LD_INT 1
72547: NEG
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: LD_INT 0
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 1
72565: PUSH
72566: LD_INT 1
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 0
72575: PUSH
72576: LD_INT 1
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 1
72585: NEG
72586: PUSH
72587: LD_INT 0
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 1
72596: NEG
72597: PUSH
72598: LD_INT 1
72600: NEG
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 1
72608: NEG
72609: PUSH
72610: LD_INT 2
72612: NEG
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: PUSH
72618: LD_INT 0
72620: PUSH
72621: LD_INT 2
72623: NEG
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PUSH
72629: LD_INT 1
72631: PUSH
72632: LD_INT 1
72634: NEG
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 2
72642: PUSH
72643: LD_INT 0
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 2
72652: PUSH
72653: LD_INT 1
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: LD_INT 2
72662: PUSH
72663: LD_INT 2
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: PUSH
72670: LD_INT 1
72672: PUSH
72673: LD_INT 2
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: PUSH
72680: LD_INT 0
72682: PUSH
72683: LD_INT 2
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 1
72692: NEG
72693: PUSH
72694: LD_INT 1
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: PUSH
72701: LD_INT 2
72703: NEG
72704: PUSH
72705: LD_INT 0
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: LD_INT 2
72714: NEG
72715: PUSH
72716: LD_INT 1
72718: NEG
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: LD_INT 2
72726: NEG
72727: PUSH
72728: LD_INT 2
72730: NEG
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 3
72738: PUSH
72739: LD_INT 1
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 3
72748: PUSH
72749: LD_INT 2
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 2
72758: PUSH
72759: LD_INT 3
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: PUSH
72766: LD_INT 1
72768: PUSH
72769: LD_INT 3
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: LIST
72783: LIST
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: LIST
72789: LIST
72790: LIST
72791: LIST
72792: LIST
72793: LIST
72794: LIST
72795: LIST
72796: LIST
72797: LIST
72798: LIST
72799: LIST
72800: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
72801: LD_ADDR_VAR 0 26
72805: PUSH
72806: LD_INT 0
72808: PUSH
72809: LD_INT 0
72811: PUSH
72812: EMPTY
72813: LIST
72814: LIST
72815: PUSH
72816: LD_INT 0
72818: PUSH
72819: LD_INT 1
72821: NEG
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 1
72829: PUSH
72830: LD_INT 0
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: LD_INT 1
72839: PUSH
72840: LD_INT 1
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PUSH
72847: LD_INT 0
72849: PUSH
72850: LD_INT 1
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 1
72859: NEG
72860: PUSH
72861: LD_INT 0
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: PUSH
72868: LD_INT 1
72870: NEG
72871: PUSH
72872: LD_INT 1
72874: NEG
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 1
72882: NEG
72883: PUSH
72884: LD_INT 2
72886: NEG
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 0
72894: PUSH
72895: LD_INT 2
72897: NEG
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 1
72905: PUSH
72906: LD_INT 1
72908: NEG
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: PUSH
72914: LD_INT 2
72916: PUSH
72917: LD_INT 0
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: PUSH
72924: LD_INT 2
72926: PUSH
72927: LD_INT 1
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 2
72936: PUSH
72937: LD_INT 2
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 1
72946: PUSH
72947: LD_INT 2
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: PUSH
72954: LD_INT 0
72956: PUSH
72957: LD_INT 2
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: LD_INT 1
72966: NEG
72967: PUSH
72968: LD_INT 1
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 2
72977: NEG
72978: PUSH
72979: LD_INT 0
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 2
72988: NEG
72989: PUSH
72990: LD_INT 1
72992: NEG
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 2
73000: NEG
73001: PUSH
73002: LD_INT 2
73004: NEG
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 2
73012: PUSH
73013: LD_INT 3
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 1
73022: PUSH
73023: LD_INT 3
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 1
73032: NEG
73033: PUSH
73034: LD_INT 2
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 2
73043: NEG
73044: PUSH
73045: LD_INT 1
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
73077: LD_ADDR_VAR 0 27
73081: PUSH
73082: LD_INT 0
73084: PUSH
73085: LD_INT 0
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 0
73094: PUSH
73095: LD_INT 1
73097: NEG
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: PUSH
73103: LD_INT 1
73105: PUSH
73106: LD_INT 0
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 1
73115: PUSH
73116: LD_INT 1
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PUSH
73123: LD_INT 0
73125: PUSH
73126: LD_INT 1
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 1
73135: NEG
73136: PUSH
73137: LD_INT 0
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 1
73146: NEG
73147: PUSH
73148: LD_INT 1
73150: NEG
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 1
73158: NEG
73159: PUSH
73160: LD_INT 2
73162: NEG
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 0
73170: PUSH
73171: LD_INT 2
73173: NEG
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: LD_INT 1
73181: PUSH
73182: LD_INT 1
73184: NEG
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: LD_INT 2
73192: PUSH
73193: LD_INT 0
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: LD_INT 2
73202: PUSH
73203: LD_INT 1
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: PUSH
73210: LD_INT 2
73212: PUSH
73213: LD_INT 2
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 1
73222: PUSH
73223: LD_INT 2
73225: PUSH
73226: EMPTY
73227: LIST
73228: LIST
73229: PUSH
73230: LD_INT 0
73232: PUSH
73233: LD_INT 2
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PUSH
73240: LD_INT 1
73242: NEG
73243: PUSH
73244: LD_INT 1
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: LD_INT 2
73253: NEG
73254: PUSH
73255: LD_INT 0
73257: PUSH
73258: EMPTY
73259: LIST
73260: LIST
73261: PUSH
73262: LD_INT 2
73264: NEG
73265: PUSH
73266: LD_INT 1
73268: NEG
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: PUSH
73274: LD_INT 2
73276: NEG
73277: PUSH
73278: LD_INT 2
73280: NEG
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 1
73288: NEG
73289: PUSH
73290: LD_INT 2
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: PUSH
73297: LD_INT 2
73299: NEG
73300: PUSH
73301: LD_INT 1
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 3
73310: NEG
73311: PUSH
73312: LD_INT 1
73314: NEG
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 3
73322: NEG
73323: PUSH
73324: LD_INT 2
73326: NEG
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: LIST
73336: LIST
73337: LIST
73338: LIST
73339: LIST
73340: LIST
73341: LIST
73342: LIST
73343: LIST
73344: LIST
73345: LIST
73346: LIST
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
73357: LD_ADDR_VAR 0 28
73361: PUSH
73362: LD_INT 0
73364: PUSH
73365: LD_INT 0
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 0
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 1
73385: PUSH
73386: LD_INT 0
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 1
73395: PUSH
73396: LD_INT 1
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 0
73405: PUSH
73406: LD_INT 1
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 1
73415: NEG
73416: PUSH
73417: LD_INT 0
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: LD_INT 1
73426: NEG
73427: PUSH
73428: LD_INT 1
73430: NEG
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: PUSH
73436: LD_INT 1
73438: NEG
73439: PUSH
73440: LD_INT 2
73442: NEG
73443: PUSH
73444: EMPTY
73445: LIST
73446: LIST
73447: PUSH
73448: LD_INT 0
73450: PUSH
73451: LD_INT 2
73453: NEG
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: PUSH
73459: LD_INT 1
73461: PUSH
73462: LD_INT 1
73464: NEG
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 2
73472: PUSH
73473: LD_INT 0
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: PUSH
73480: LD_INT 2
73482: PUSH
73483: LD_INT 1
73485: PUSH
73486: EMPTY
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 2
73492: PUSH
73493: LD_INT 2
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: LD_INT 1
73502: PUSH
73503: LD_INT 2
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: LD_INT 0
73512: PUSH
73513: LD_INT 2
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: PUSH
73520: LD_INT 1
73522: NEG
73523: PUSH
73524: LD_INT 1
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: PUSH
73531: LD_INT 2
73533: NEG
73534: PUSH
73535: LD_INT 0
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: PUSH
73542: LD_INT 2
73544: NEG
73545: PUSH
73546: LD_INT 1
73548: NEG
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 2
73556: NEG
73557: PUSH
73558: LD_INT 2
73560: NEG
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 2
73568: NEG
73569: PUSH
73570: LD_INT 3
73572: NEG
73573: PUSH
73574: EMPTY
73575: LIST
73576: LIST
73577: PUSH
73578: LD_INT 1
73580: NEG
73581: PUSH
73582: LD_INT 3
73584: NEG
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 3
73592: NEG
73593: PUSH
73594: LD_INT 1
73596: NEG
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: LD_INT 3
73604: NEG
73605: PUSH
73606: LD_INT 2
73608: NEG
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: LIST
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: LIST
73628: LIST
73629: LIST
73630: LIST
73631: LIST
73632: LIST
73633: LIST
73634: LIST
73635: LIST
73636: LIST
73637: LIST
73638: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73639: LD_ADDR_VAR 0 29
73643: PUSH
73644: LD_INT 0
73646: PUSH
73647: LD_INT 0
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PUSH
73654: LD_INT 0
73656: PUSH
73657: LD_INT 1
73659: NEG
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: LD_INT 1
73667: PUSH
73668: LD_INT 0
73670: PUSH
73671: EMPTY
73672: LIST
73673: LIST
73674: PUSH
73675: LD_INT 1
73677: PUSH
73678: LD_INT 1
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: PUSH
73685: LD_INT 0
73687: PUSH
73688: LD_INT 1
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 1
73697: NEG
73698: PUSH
73699: LD_INT 0
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PUSH
73706: LD_INT 1
73708: NEG
73709: PUSH
73710: LD_INT 1
73712: NEG
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: LD_INT 1
73720: NEG
73721: PUSH
73722: LD_INT 2
73724: NEG
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PUSH
73730: LD_INT 0
73732: PUSH
73733: LD_INT 2
73735: NEG
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: LD_INT 1
73743: PUSH
73744: LD_INT 1
73746: NEG
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: PUSH
73752: LD_INT 2
73754: PUSH
73755: LD_INT 0
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: PUSH
73762: LD_INT 2
73764: PUSH
73765: LD_INT 1
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 1
73774: PUSH
73775: LD_INT 2
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 0
73784: PUSH
73785: LD_INT 2
73787: PUSH
73788: EMPTY
73789: LIST
73790: LIST
73791: PUSH
73792: LD_INT 1
73794: NEG
73795: PUSH
73796: LD_INT 1
73798: PUSH
73799: EMPTY
73800: LIST
73801: LIST
73802: PUSH
73803: LD_INT 2
73805: NEG
73806: PUSH
73807: LD_INT 1
73809: NEG
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 2
73817: NEG
73818: PUSH
73819: LD_INT 2
73821: NEG
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 2
73829: NEG
73830: PUSH
73831: LD_INT 3
73833: NEG
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 2
73841: PUSH
73842: LD_INT 1
73844: NEG
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 3
73852: PUSH
73853: LD_INT 1
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 1
73862: PUSH
73863: LD_INT 3
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 1
73872: NEG
73873: PUSH
73874: LD_INT 2
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 3
73883: NEG
73884: PUSH
73885: LD_INT 2
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73918: LD_ADDR_VAR 0 30
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: LD_INT 0
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 0
73935: PUSH
73936: LD_INT 1
73938: NEG
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PUSH
73944: LD_INT 1
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: PUSH
73954: LD_INT 1
73956: PUSH
73957: LD_INT 1
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: PUSH
73964: LD_INT 0
73966: PUSH
73967: LD_INT 1
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: LD_INT 1
73976: NEG
73977: PUSH
73978: LD_INT 0
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: PUSH
73985: LD_INT 1
73987: NEG
73988: PUSH
73989: LD_INT 1
73991: NEG
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 1
73999: NEG
74000: PUSH
74001: LD_INT 2
74003: NEG
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 0
74011: PUSH
74012: LD_INT 2
74014: NEG
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 1
74022: PUSH
74023: LD_INT 1
74025: NEG
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 2
74033: PUSH
74034: LD_INT 0
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 2
74043: PUSH
74044: LD_INT 1
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 2
74053: PUSH
74054: LD_INT 2
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: LD_INT 1
74063: PUSH
74064: LD_INT 2
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: PUSH
74071: LD_INT 1
74073: NEG
74074: PUSH
74075: LD_INT 1
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 2
74084: NEG
74085: PUSH
74086: LD_INT 0
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: LD_INT 2
74095: NEG
74096: PUSH
74097: LD_INT 1
74099: NEG
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: PUSH
74105: LD_INT 1
74107: NEG
74108: PUSH
74109: LD_INT 3
74111: NEG
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: PUSH
74117: LD_INT 1
74119: PUSH
74120: LD_INT 2
74122: NEG
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: LD_INT 3
74130: PUSH
74131: LD_INT 2
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 2
74140: PUSH
74141: LD_INT 3
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: PUSH
74148: LD_INT 2
74150: NEG
74151: PUSH
74152: LD_INT 1
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 3
74161: NEG
74162: PUSH
74163: LD_INT 1
74165: NEG
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: LIST
74175: LIST
74176: LIST
74177: LIST
74178: LIST
74179: LIST
74180: LIST
74181: LIST
74182: LIST
74183: LIST
74184: LIST
74185: LIST
74186: LIST
74187: LIST
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
74196: LD_ADDR_VAR 0 31
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: LD_INT 1
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 1
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: LD_INT 1
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 1
74277: NEG
74278: PUSH
74279: LD_INT 2
74281: NEG
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 1
74289: PUSH
74290: LD_INT 1
74292: NEG
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 2
74300: PUSH
74301: LD_INT 0
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 2
74310: PUSH
74311: LD_INT 1
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 2
74320: PUSH
74321: LD_INT 2
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: LD_INT 1
74330: PUSH
74331: LD_INT 2
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PUSH
74338: LD_INT 0
74340: PUSH
74341: LD_INT 2
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: PUSH
74348: LD_INT 1
74350: NEG
74351: PUSH
74352: LD_INT 1
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: LD_INT 2
74361: NEG
74362: PUSH
74363: LD_INT 1
74365: NEG
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 2
74373: NEG
74374: PUSH
74375: LD_INT 2
74377: NEG
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 2
74385: NEG
74386: PUSH
74387: LD_INT 3
74389: NEG
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 2
74397: PUSH
74398: LD_INT 1
74400: NEG
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 3
74408: PUSH
74409: LD_INT 1
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: LD_INT 1
74418: PUSH
74419: LD_INT 3
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: PUSH
74426: LD_INT 1
74428: NEG
74429: PUSH
74430: LD_INT 2
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: LD_INT 3
74439: NEG
74440: PUSH
74441: LD_INT 2
74443: NEG
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: LIST
74459: LIST
74460: LIST
74461: LIST
74462: LIST
74463: LIST
74464: LIST
74465: LIST
74466: LIST
74467: LIST
74468: LIST
74469: LIST
74470: LIST
74471: LIST
74472: LIST
74473: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74474: LD_ADDR_VAR 0 32
74478: PUSH
74479: LD_INT 0
74481: PUSH
74482: LD_INT 0
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 1
74502: PUSH
74503: LD_INT 0
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: LD_INT 1
74512: PUSH
74513: LD_INT 1
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 0
74522: PUSH
74523: LD_INT 1
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 1
74532: NEG
74533: PUSH
74534: LD_INT 0
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: PUSH
74541: LD_INT 1
74543: NEG
74544: PUSH
74545: LD_INT 1
74547: NEG
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 1
74555: NEG
74556: PUSH
74557: LD_INT 2
74559: NEG
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 0
74567: PUSH
74568: LD_INT 2
74570: NEG
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 1
74578: PUSH
74579: LD_INT 1
74581: NEG
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 2
74589: PUSH
74590: LD_INT 1
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 2
74599: PUSH
74600: LD_INT 2
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 1
74609: PUSH
74610: LD_INT 2
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: LD_INT 0
74619: PUSH
74620: LD_INT 2
74622: PUSH
74623: EMPTY
74624: LIST
74625: LIST
74626: PUSH
74627: LD_INT 1
74629: NEG
74630: PUSH
74631: LD_INT 1
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: PUSH
74638: LD_INT 2
74640: NEG
74641: PUSH
74642: LD_INT 0
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 2
74651: NEG
74652: PUSH
74653: LD_INT 1
74655: NEG
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 1
74663: NEG
74664: PUSH
74665: LD_INT 3
74667: NEG
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: LD_INT 1
74675: PUSH
74676: LD_INT 2
74678: NEG
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 3
74686: PUSH
74687: LD_INT 2
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 2
74696: PUSH
74697: LD_INT 3
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 2
74706: NEG
74707: PUSH
74708: LD_INT 1
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: PUSH
74715: LD_INT 3
74717: NEG
74718: PUSH
74719: LD_INT 1
74721: NEG
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: LIST
74731: LIST
74732: LIST
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: LIST
74751: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
74752: LD_ADDR_VAR 0 33
74756: PUSH
74757: LD_INT 0
74759: PUSH
74760: LD_INT 0
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: PUSH
74767: LD_INT 0
74769: PUSH
74770: LD_INT 1
74772: NEG
74773: PUSH
74774: EMPTY
74775: LIST
74776: LIST
74777: PUSH
74778: LD_INT 1
74780: PUSH
74781: LD_INT 0
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: LD_INT 1
74790: PUSH
74791: LD_INT 1
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: PUSH
74798: LD_INT 0
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: LD_INT 1
74810: NEG
74811: PUSH
74812: LD_INT 0
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 1
74821: NEG
74822: PUSH
74823: LD_INT 1
74825: NEG
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 1
74833: NEG
74834: PUSH
74835: LD_INT 2
74837: NEG
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: LD_INT 1
74845: PUSH
74846: LD_INT 1
74848: NEG
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: PUSH
74854: LD_INT 2
74856: PUSH
74857: LD_INT 0
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 2
74866: PUSH
74867: LD_INT 1
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: LD_INT 1
74876: PUSH
74877: LD_INT 2
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: PUSH
74884: LD_INT 0
74886: PUSH
74887: LD_INT 2
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: LD_INT 1
74896: NEG
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 2
74907: NEG
74908: PUSH
74909: LD_INT 0
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: PUSH
74916: LD_INT 2
74918: NEG
74919: PUSH
74920: LD_INT 1
74922: NEG
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: LD_INT 2
74930: NEG
74931: PUSH
74932: LD_INT 2
74934: NEG
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 2
74942: NEG
74943: PUSH
74944: LD_INT 3
74946: NEG
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 2
74954: PUSH
74955: LD_INT 1
74957: NEG
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: LD_INT 3
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 1
74975: PUSH
74976: LD_INT 3
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 1
74985: NEG
74986: PUSH
74987: LD_INT 2
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 3
74996: NEG
74997: PUSH
74998: LD_INT 2
75000: NEG
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75031: LD_ADDR_VAR 0 34
75035: PUSH
75036: LD_INT 0
75038: PUSH
75039: LD_INT 0
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 0
75048: PUSH
75049: LD_INT 1
75051: NEG
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 1
75059: PUSH
75060: LD_INT 0
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 1
75069: PUSH
75070: LD_INT 1
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 0
75079: PUSH
75080: LD_INT 1
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 1
75089: NEG
75090: PUSH
75091: LD_INT 0
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 1
75100: NEG
75101: PUSH
75102: LD_INT 1
75104: NEG
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: LD_INT 1
75112: NEG
75113: PUSH
75114: LD_INT 2
75116: NEG
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: LD_INT 0
75124: PUSH
75125: LD_INT 2
75127: NEG
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: PUSH
75133: LD_INT 1
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 2
75146: PUSH
75147: LD_INT 1
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: PUSH
75154: LD_INT 2
75156: PUSH
75157: LD_INT 2
75159: PUSH
75160: EMPTY
75161: LIST
75162: LIST
75163: PUSH
75164: LD_INT 1
75166: PUSH
75167: LD_INT 2
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: PUSH
75174: LD_INT 1
75176: NEG
75177: PUSH
75178: LD_INT 1
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: LD_INT 2
75187: NEG
75188: PUSH
75189: LD_INT 0
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 2
75198: NEG
75199: PUSH
75200: LD_INT 1
75202: NEG
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 2
75210: NEG
75211: PUSH
75212: LD_INT 2
75214: NEG
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 1
75222: NEG
75223: PUSH
75224: LD_INT 3
75226: NEG
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 1
75234: PUSH
75235: LD_INT 2
75237: NEG
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 3
75245: PUSH
75246: LD_INT 2
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: LD_INT 2
75255: PUSH
75256: LD_INT 3
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 2
75265: NEG
75266: PUSH
75267: LD_INT 1
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: LD_INT 3
75276: NEG
75277: PUSH
75278: LD_INT 1
75280: NEG
75281: PUSH
75282: EMPTY
75283: LIST
75284: LIST
75285: PUSH
75286: EMPTY
75287: LIST
75288: LIST
75289: LIST
75290: LIST
75291: LIST
75292: LIST
75293: LIST
75294: LIST
75295: LIST
75296: LIST
75297: LIST
75298: LIST
75299: LIST
75300: LIST
75301: LIST
75302: LIST
75303: LIST
75304: LIST
75305: LIST
75306: LIST
75307: LIST
75308: LIST
75309: LIST
75310: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
75311: LD_ADDR_VAR 0 35
75315: PUSH
75316: LD_INT 0
75318: PUSH
75319: LD_INT 0
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 0
75328: PUSH
75329: LD_INT 1
75331: NEG
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PUSH
75337: LD_INT 1
75339: PUSH
75340: LD_INT 0
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 1
75349: PUSH
75350: LD_INT 1
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: LD_INT 0
75359: PUSH
75360: LD_INT 1
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 1
75369: NEG
75370: PUSH
75371: LD_INT 0
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 1
75380: NEG
75381: PUSH
75382: LD_INT 1
75384: NEG
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 2
75392: PUSH
75393: LD_INT 1
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 2
75402: NEG
75403: PUSH
75404: LD_INT 1
75406: NEG
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: LIST
75418: LIST
75419: LIST
75420: LIST
75421: LIST
75422: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
75423: LD_ADDR_VAR 0 36
75427: PUSH
75428: LD_INT 0
75430: PUSH
75431: LD_INT 0
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 0
75440: PUSH
75441: LD_INT 1
75443: NEG
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: LD_INT 1
75451: PUSH
75452: LD_INT 0
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: LD_INT 1
75461: PUSH
75462: LD_INT 1
75464: PUSH
75465: EMPTY
75466: LIST
75467: LIST
75468: PUSH
75469: LD_INT 0
75471: PUSH
75472: LD_INT 1
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: PUSH
75479: LD_INT 1
75481: NEG
75482: PUSH
75483: LD_INT 0
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: PUSH
75490: LD_INT 1
75492: NEG
75493: PUSH
75494: LD_INT 1
75496: NEG
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PUSH
75502: LD_INT 1
75504: NEG
75505: PUSH
75506: LD_INT 2
75508: NEG
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 1
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
75535: LD_ADDR_VAR 0 37
75539: PUSH
75540: LD_INT 0
75542: PUSH
75543: LD_INT 0
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 0
75552: PUSH
75553: LD_INT 1
75555: NEG
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 1
75563: PUSH
75564: LD_INT 0
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 1
75573: PUSH
75574: LD_INT 1
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: LD_INT 0
75583: PUSH
75584: LD_INT 1
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 1
75593: NEG
75594: PUSH
75595: LD_INT 0
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 1
75604: NEG
75605: PUSH
75606: LD_INT 1
75608: NEG
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 1
75616: PUSH
75617: LD_INT 1
75619: NEG
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: LD_INT 1
75627: NEG
75628: PUSH
75629: LD_INT 1
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: LIST
75640: LIST
75641: LIST
75642: LIST
75643: LIST
75644: LIST
75645: LIST
75646: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
75647: LD_ADDR_VAR 0 38
75651: PUSH
75652: LD_INT 0
75654: PUSH
75655: LD_INT 0
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: PUSH
75662: LD_INT 0
75664: PUSH
75665: LD_INT 1
75667: NEG
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 1
75675: PUSH
75676: LD_INT 0
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: LD_INT 1
75685: PUSH
75686: LD_INT 1
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 0
75695: PUSH
75696: LD_INT 1
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 1
75705: NEG
75706: PUSH
75707: LD_INT 0
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 1
75716: NEG
75717: PUSH
75718: LD_INT 1
75720: NEG
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: PUSH
75726: LD_INT 2
75728: PUSH
75729: LD_INT 1
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: PUSH
75736: LD_INT 2
75738: NEG
75739: PUSH
75740: LD_INT 1
75742: NEG
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
75759: LD_ADDR_VAR 0 39
75763: PUSH
75764: LD_INT 0
75766: PUSH
75767: LD_INT 0
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: LD_INT 1
75779: NEG
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 1
75787: PUSH
75788: LD_INT 0
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 1
75797: PUSH
75798: LD_INT 1
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 0
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 1
75817: NEG
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: PUSH
75826: LD_INT 1
75828: NEG
75829: PUSH
75830: LD_INT 1
75832: NEG
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: LD_INT 1
75840: NEG
75841: PUSH
75842: LD_INT 2
75844: NEG
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 1
75852: PUSH
75853: LD_INT 2
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: LIST
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: LIST
75870: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
75871: LD_ADDR_VAR 0 40
75875: PUSH
75876: LD_INT 0
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 0
75888: PUSH
75889: LD_INT 1
75891: NEG
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 1
75899: PUSH
75900: LD_INT 0
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 1
75909: PUSH
75910: LD_INT 1
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: LD_INT 0
75919: PUSH
75920: LD_INT 1
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 1
75929: NEG
75930: PUSH
75931: LD_INT 0
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 1
75940: NEG
75941: PUSH
75942: LD_INT 1
75944: NEG
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: LD_INT 1
75952: PUSH
75953: LD_INT 1
75955: NEG
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 1
75963: NEG
75964: PUSH
75965: LD_INT 1
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75983: LD_ADDR_VAR 0 41
75987: PUSH
75988: LD_INT 0
75990: PUSH
75991: LD_INT 0
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: PUSH
75998: LD_INT 0
76000: PUSH
76001: LD_INT 1
76003: NEG
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: PUSH
76009: LD_INT 1
76011: PUSH
76012: LD_INT 0
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 1
76021: PUSH
76022: LD_INT 1
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 0
76031: PUSH
76032: LD_INT 1
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PUSH
76039: LD_INT 1
76041: NEG
76042: PUSH
76043: LD_INT 0
76045: PUSH
76046: EMPTY
76047: LIST
76048: LIST
76049: PUSH
76050: LD_INT 1
76052: NEG
76053: PUSH
76054: LD_INT 1
76056: NEG
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: PUSH
76062: LD_INT 1
76064: NEG
76065: PUSH
76066: LD_INT 2
76068: NEG
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 1
76076: PUSH
76077: LD_INT 1
76079: NEG
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 2
76087: PUSH
76088: LD_INT 0
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 2
76097: PUSH
76098: LD_INT 1
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 2
76107: PUSH
76108: LD_INT 2
76110: PUSH
76111: EMPTY
76112: LIST
76113: LIST
76114: PUSH
76115: LD_INT 1
76117: PUSH
76118: LD_INT 2
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 1
76127: NEG
76128: PUSH
76129: LD_INT 1
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 2
76138: NEG
76139: PUSH
76140: LD_INT 0
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: LD_INT 2
76149: NEG
76150: PUSH
76151: LD_INT 1
76153: NEG
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 2
76161: NEG
76162: PUSH
76163: LD_INT 2
76165: NEG
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 2
76173: NEG
76174: PUSH
76175: LD_INT 3
76177: NEG
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: PUSH
76183: LD_INT 2
76185: PUSH
76186: LD_INT 1
76188: NEG
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PUSH
76194: LD_INT 3
76196: PUSH
76197: LD_INT 0
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 3
76206: PUSH
76207: LD_INT 1
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 3
76216: PUSH
76217: LD_INT 2
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 3
76226: PUSH
76227: LD_INT 3
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 2
76236: PUSH
76237: LD_INT 3
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 2
76246: NEG
76247: PUSH
76248: LD_INT 1
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: LD_INT 3
76257: NEG
76258: PUSH
76259: LD_INT 0
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: LD_INT 3
76268: NEG
76269: PUSH
76270: LD_INT 1
76272: NEG
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: LD_INT 3
76280: NEG
76281: PUSH
76282: LD_INT 2
76284: NEG
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: LD_INT 3
76292: NEG
76293: PUSH
76294: LD_INT 3
76296: NEG
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: LIST
76306: LIST
76307: LIST
76308: LIST
76309: LIST
76310: LIST
76311: LIST
76312: LIST
76313: LIST
76314: LIST
76315: LIST
76316: LIST
76317: LIST
76318: LIST
76319: LIST
76320: LIST
76321: LIST
76322: LIST
76323: LIST
76324: LIST
76325: LIST
76326: LIST
76327: LIST
76328: LIST
76329: LIST
76330: LIST
76331: LIST
76332: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76333: LD_ADDR_VAR 0 42
76337: PUSH
76338: LD_INT 0
76340: PUSH
76341: LD_INT 0
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 0
76350: PUSH
76351: LD_INT 1
76353: NEG
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 1
76361: PUSH
76362: LD_INT 0
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: PUSH
76369: LD_INT 1
76371: PUSH
76372: LD_INT 1
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 0
76381: PUSH
76382: LD_INT 1
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 1
76391: NEG
76392: PUSH
76393: LD_INT 0
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PUSH
76400: LD_INT 1
76402: NEG
76403: PUSH
76404: LD_INT 1
76406: NEG
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 1
76414: NEG
76415: PUSH
76416: LD_INT 2
76418: NEG
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 0
76426: PUSH
76427: LD_INT 2
76429: NEG
76430: PUSH
76431: EMPTY
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 1
76437: PUSH
76438: LD_INT 1
76440: NEG
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: PUSH
76446: LD_INT 2
76448: PUSH
76449: LD_INT 1
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: PUSH
76456: LD_INT 2
76458: PUSH
76459: LD_INT 2
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 1
76468: PUSH
76469: LD_INT 2
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 0
76478: PUSH
76479: LD_INT 2
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 1
76488: NEG
76489: PUSH
76490: LD_INT 1
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 2
76499: NEG
76500: PUSH
76501: LD_INT 1
76503: NEG
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 2
76511: NEG
76512: PUSH
76513: LD_INT 2
76515: NEG
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: PUSH
76521: LD_INT 2
76523: NEG
76524: PUSH
76525: LD_INT 3
76527: NEG
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 1
76535: NEG
76536: PUSH
76537: LD_INT 3
76539: NEG
76540: PUSH
76541: EMPTY
76542: LIST
76543: LIST
76544: PUSH
76545: LD_INT 0
76547: PUSH
76548: LD_INT 3
76550: NEG
76551: PUSH
76552: EMPTY
76553: LIST
76554: LIST
76555: PUSH
76556: LD_INT 1
76558: PUSH
76559: LD_INT 2
76561: NEG
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 3
76569: PUSH
76570: LD_INT 2
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 3
76579: PUSH
76580: LD_INT 3
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: PUSH
76587: LD_INT 2
76589: PUSH
76590: LD_INT 3
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PUSH
76597: LD_INT 1
76599: PUSH
76600: LD_INT 3
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: PUSH
76607: LD_INT 0
76609: PUSH
76610: LD_INT 3
76612: PUSH
76613: EMPTY
76614: LIST
76615: LIST
76616: PUSH
76617: LD_INT 1
76619: NEG
76620: PUSH
76621: LD_INT 2
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: PUSH
76628: LD_INT 3
76630: NEG
76631: PUSH
76632: LD_INT 2
76634: NEG
76635: PUSH
76636: EMPTY
76637: LIST
76638: LIST
76639: PUSH
76640: LD_INT 3
76642: NEG
76643: PUSH
76644: LD_INT 3
76646: NEG
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: LIST
76682: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76683: LD_ADDR_VAR 0 43
76687: PUSH
76688: LD_INT 0
76690: PUSH
76691: LD_INT 0
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: LD_INT 0
76700: PUSH
76701: LD_INT 1
76703: NEG
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: LD_INT 1
76711: PUSH
76712: LD_INT 0
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 1
76721: PUSH
76722: LD_INT 1
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 0
76731: PUSH
76732: LD_INT 1
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 1
76741: NEG
76742: PUSH
76743: LD_INT 0
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 1
76752: NEG
76753: PUSH
76754: LD_INT 1
76756: NEG
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: LD_INT 1
76764: NEG
76765: PUSH
76766: LD_INT 2
76768: NEG
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 0
76776: PUSH
76777: LD_INT 2
76779: NEG
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 1
76787: PUSH
76788: LD_INT 1
76790: NEG
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 2
76798: PUSH
76799: LD_INT 0
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 2
76808: PUSH
76809: LD_INT 1
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: LD_INT 2
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 0
76828: PUSH
76829: LD_INT 2
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 1
76838: NEG
76839: PUSH
76840: LD_INT 1
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: PUSH
76847: LD_INT 2
76849: NEG
76850: PUSH
76851: LD_INT 0
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 2
76860: NEG
76861: PUSH
76862: LD_INT 1
76864: NEG
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 1
76872: NEG
76873: PUSH
76874: LD_INT 3
76876: NEG
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: PUSH
76882: LD_INT 0
76884: PUSH
76885: LD_INT 3
76887: NEG
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: LD_INT 1
76895: PUSH
76896: LD_INT 2
76898: NEG
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 2
76906: PUSH
76907: LD_INT 1
76909: NEG
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 3
76917: PUSH
76918: LD_INT 0
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: LD_INT 3
76927: PUSH
76928: LD_INT 1
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 1
76937: PUSH
76938: LD_INT 3
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: PUSH
76945: LD_INT 0
76947: PUSH
76948: LD_INT 3
76950: PUSH
76951: EMPTY
76952: LIST
76953: LIST
76954: PUSH
76955: LD_INT 1
76957: NEG
76958: PUSH
76959: LD_INT 2
76961: PUSH
76962: EMPTY
76963: LIST
76964: LIST
76965: PUSH
76966: LD_INT 2
76968: NEG
76969: PUSH
76970: LD_INT 1
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: LD_INT 3
76979: NEG
76980: PUSH
76981: LD_INT 0
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 3
76990: NEG
76991: PUSH
76992: LD_INT 1
76994: NEG
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: LIST
77004: LIST
77005: LIST
77006: LIST
77007: LIST
77008: LIST
77009: LIST
77010: LIST
77011: LIST
77012: LIST
77013: LIST
77014: LIST
77015: LIST
77016: LIST
77017: LIST
77018: LIST
77019: LIST
77020: LIST
77021: LIST
77022: LIST
77023: LIST
77024: LIST
77025: LIST
77026: LIST
77027: LIST
77028: LIST
77029: LIST
77030: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77031: LD_ADDR_VAR 0 44
77035: PUSH
77036: LD_INT 0
77038: PUSH
77039: LD_INT 0
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 0
77048: PUSH
77049: LD_INT 1
77051: NEG
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: PUSH
77057: LD_INT 1
77059: PUSH
77060: LD_INT 0
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 1
77069: PUSH
77070: LD_INT 1
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 0
77079: PUSH
77080: LD_INT 1
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 1
77089: NEG
77090: PUSH
77091: LD_INT 0
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: LD_INT 1
77100: NEG
77101: PUSH
77102: LD_INT 1
77104: NEG
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 1
77112: NEG
77113: PUSH
77114: LD_INT 2
77116: NEG
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 1
77124: PUSH
77125: LD_INT 1
77127: NEG
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 2
77135: PUSH
77136: LD_INT 0
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: LD_INT 2
77145: PUSH
77146: LD_INT 1
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 2
77155: PUSH
77156: LD_INT 2
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 1
77165: PUSH
77166: LD_INT 2
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 1
77175: NEG
77176: PUSH
77177: LD_INT 1
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: LD_INT 2
77186: NEG
77187: PUSH
77188: LD_INT 0
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: PUSH
77195: LD_INT 2
77197: NEG
77198: PUSH
77199: LD_INT 1
77201: NEG
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 2
77209: NEG
77210: PUSH
77211: LD_INT 2
77213: NEG
77214: PUSH
77215: EMPTY
77216: LIST
77217: LIST
77218: PUSH
77219: LD_INT 2
77221: NEG
77222: PUSH
77223: LD_INT 3
77225: NEG
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 2
77233: PUSH
77234: LD_INT 1
77236: NEG
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 3
77244: PUSH
77245: LD_INT 0
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 3
77254: PUSH
77255: LD_INT 1
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: PUSH
77262: LD_INT 3
77264: PUSH
77265: LD_INT 2
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: LD_INT 3
77274: PUSH
77275: LD_INT 3
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: PUSH
77282: LD_INT 2
77284: PUSH
77285: LD_INT 3
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 2
77294: NEG
77295: PUSH
77296: LD_INT 1
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 3
77305: NEG
77306: PUSH
77307: LD_INT 0
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: LD_INT 3
77316: NEG
77317: PUSH
77318: LD_INT 1
77320: NEG
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 3
77328: NEG
77329: PUSH
77330: LD_INT 2
77332: NEG
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: PUSH
77338: LD_INT 3
77340: NEG
77341: PUSH
77342: LD_INT 3
77344: NEG
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: LIST
77354: LIST
77355: LIST
77356: LIST
77357: LIST
77358: LIST
77359: LIST
77360: LIST
77361: LIST
77362: LIST
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: LIST
77368: LIST
77369: LIST
77370: LIST
77371: LIST
77372: LIST
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77381: LD_ADDR_VAR 0 45
77385: PUSH
77386: LD_INT 0
77388: PUSH
77389: LD_INT 0
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 0
77398: PUSH
77399: LD_INT 1
77401: NEG
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 1
77409: PUSH
77410: LD_INT 0
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 1
77419: PUSH
77420: LD_INT 1
77422: PUSH
77423: EMPTY
77424: LIST
77425: LIST
77426: PUSH
77427: LD_INT 0
77429: PUSH
77430: LD_INT 1
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 1
77439: NEG
77440: PUSH
77441: LD_INT 0
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 1
77450: NEG
77451: PUSH
77452: LD_INT 1
77454: NEG
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 1
77462: NEG
77463: PUSH
77464: LD_INT 2
77466: NEG
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 0
77474: PUSH
77475: LD_INT 2
77477: NEG
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 1
77485: PUSH
77486: LD_INT 1
77488: NEG
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: LD_INT 2
77496: PUSH
77497: LD_INT 1
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 2
77506: PUSH
77507: LD_INT 2
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 1
77516: PUSH
77517: LD_INT 2
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 0
77526: PUSH
77527: LD_INT 2
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 1
77536: NEG
77537: PUSH
77538: LD_INT 1
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: LD_INT 2
77547: NEG
77548: PUSH
77549: LD_INT 1
77551: NEG
77552: PUSH
77553: EMPTY
77554: LIST
77555: LIST
77556: PUSH
77557: LD_INT 2
77559: NEG
77560: PUSH
77561: LD_INT 2
77563: NEG
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 2
77571: NEG
77572: PUSH
77573: LD_INT 3
77575: NEG
77576: PUSH
77577: EMPTY
77578: LIST
77579: LIST
77580: PUSH
77581: LD_INT 1
77583: NEG
77584: PUSH
77585: LD_INT 3
77587: NEG
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 0
77595: PUSH
77596: LD_INT 3
77598: NEG
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: LD_INT 1
77606: PUSH
77607: LD_INT 2
77609: NEG
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 3
77617: PUSH
77618: LD_INT 2
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 3
77627: PUSH
77628: LD_INT 3
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 2
77637: PUSH
77638: LD_INT 3
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: PUSH
77645: LD_INT 1
77647: PUSH
77648: LD_INT 3
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: LD_INT 0
77657: PUSH
77658: LD_INT 3
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: LD_INT 1
77667: NEG
77668: PUSH
77669: LD_INT 2
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 3
77678: NEG
77679: PUSH
77680: LD_INT 2
77682: NEG
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 3
77690: NEG
77691: PUSH
77692: LD_INT 3
77694: NEG
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77731: LD_ADDR_VAR 0 46
77735: PUSH
77736: LD_INT 0
77738: PUSH
77739: LD_INT 0
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: LD_INT 0
77748: PUSH
77749: LD_INT 1
77751: NEG
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 1
77759: PUSH
77760: LD_INT 0
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 1
77769: PUSH
77770: LD_INT 1
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 0
77779: PUSH
77780: LD_INT 1
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: LD_INT 1
77789: NEG
77790: PUSH
77791: LD_INT 0
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: LD_INT 1
77800: NEG
77801: PUSH
77802: LD_INT 1
77804: NEG
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: LD_INT 1
77812: NEG
77813: PUSH
77814: LD_INT 2
77816: NEG
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 0
77824: PUSH
77825: LD_INT 2
77827: NEG
77828: PUSH
77829: EMPTY
77830: LIST
77831: LIST
77832: PUSH
77833: LD_INT 1
77835: PUSH
77836: LD_INT 1
77838: NEG
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 2
77846: PUSH
77847: LD_INT 0
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: LD_INT 2
77856: PUSH
77857: LD_INT 1
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 1
77866: PUSH
77867: LD_INT 2
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 0
77876: PUSH
77877: LD_INT 2
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 1
77886: NEG
77887: PUSH
77888: LD_INT 1
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 2
77897: NEG
77898: PUSH
77899: LD_INT 0
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 2
77908: NEG
77909: PUSH
77910: LD_INT 1
77912: NEG
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 1
77920: NEG
77921: PUSH
77922: LD_INT 3
77924: NEG
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 0
77932: PUSH
77933: LD_INT 3
77935: NEG
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 1
77943: PUSH
77944: LD_INT 2
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 2
77954: PUSH
77955: LD_INT 1
77957: NEG
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 3
77965: PUSH
77966: LD_INT 0
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 3
77975: PUSH
77976: LD_INT 1
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: PUSH
77983: LD_INT 1
77985: PUSH
77986: LD_INT 3
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: LD_INT 0
77995: PUSH
77996: LD_INT 3
77998: PUSH
77999: EMPTY
78000: LIST
78001: LIST
78002: PUSH
78003: LD_INT 1
78005: NEG
78006: PUSH
78007: LD_INT 2
78009: PUSH
78010: EMPTY
78011: LIST
78012: LIST
78013: PUSH
78014: LD_INT 2
78016: NEG
78017: PUSH
78018: LD_INT 1
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PUSH
78025: LD_INT 3
78027: NEG
78028: PUSH
78029: LD_INT 0
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 3
78038: NEG
78039: PUSH
78040: LD_INT 1
78042: NEG
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: LIST
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: LIST
78062: LIST
78063: LIST
78064: LIST
78065: LIST
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: LIST
78071: LIST
78072: LIST
78073: LIST
78074: LIST
78075: LIST
78076: LIST
78077: LIST
78078: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78079: LD_ADDR_VAR 0 47
78083: PUSH
78084: LD_INT 0
78086: PUSH
78087: LD_INT 0
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 0
78096: PUSH
78097: LD_INT 1
78099: NEG
78100: PUSH
78101: EMPTY
78102: LIST
78103: LIST
78104: PUSH
78105: LD_INT 1
78107: PUSH
78108: LD_INT 0
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 1
78117: PUSH
78118: LD_INT 1
78120: PUSH
78121: EMPTY
78122: LIST
78123: LIST
78124: PUSH
78125: LD_INT 0
78127: PUSH
78128: LD_INT 1
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 1
78137: NEG
78138: PUSH
78139: LD_INT 0
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PUSH
78146: LD_INT 1
78148: NEG
78149: PUSH
78150: LD_INT 1
78152: NEG
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 1
78160: NEG
78161: PUSH
78162: LD_INT 2
78164: NEG
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 0
78172: PUSH
78173: LD_INT 2
78175: NEG
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PUSH
78181: LD_INT 1
78183: PUSH
78184: LD_INT 1
78186: NEG
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 2
78194: NEG
78195: PUSH
78196: LD_INT 1
78198: NEG
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 2
78206: NEG
78207: PUSH
78208: LD_INT 2
78210: NEG
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78230: LD_ADDR_VAR 0 48
78234: PUSH
78235: LD_INT 0
78237: PUSH
78238: LD_INT 0
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 0
78247: PUSH
78248: LD_INT 1
78250: NEG
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 1
78258: PUSH
78259: LD_INT 0
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 1
78268: PUSH
78269: LD_INT 1
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 0
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 1
78288: NEG
78289: PUSH
78290: LD_INT 0
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 1
78299: NEG
78300: PUSH
78301: LD_INT 1
78303: NEG
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 1
78311: NEG
78312: PUSH
78313: LD_INT 2
78315: NEG
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 0
78323: PUSH
78324: LD_INT 2
78326: NEG
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 1
78334: PUSH
78335: LD_INT 1
78337: NEG
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 2
78345: PUSH
78346: LD_INT 0
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 2
78355: PUSH
78356: LD_INT 1
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: LIST
78375: LIST
78376: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78377: LD_ADDR_VAR 0 49
78381: PUSH
78382: LD_INT 0
78384: PUSH
78385: LD_INT 0
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 0
78394: PUSH
78395: LD_INT 1
78397: NEG
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: LD_INT 1
78405: PUSH
78406: LD_INT 0
78408: PUSH
78409: EMPTY
78410: LIST
78411: LIST
78412: PUSH
78413: LD_INT 1
78415: PUSH
78416: LD_INT 1
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: LD_INT 0
78425: PUSH
78426: LD_INT 1
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 1
78435: NEG
78436: PUSH
78437: LD_INT 0
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 1
78446: NEG
78447: PUSH
78448: LD_INT 1
78450: NEG
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 1
78458: PUSH
78459: LD_INT 1
78461: NEG
78462: PUSH
78463: EMPTY
78464: LIST
78465: LIST
78466: PUSH
78467: LD_INT 2
78469: PUSH
78470: LD_INT 0
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 2
78479: PUSH
78480: LD_INT 1
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 2
78489: PUSH
78490: LD_INT 2
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 1
78499: PUSH
78500: LD_INT 2
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: LIST
78511: LIST
78512: LIST
78513: LIST
78514: LIST
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78521: LD_ADDR_VAR 0 50
78525: PUSH
78526: LD_INT 0
78528: PUSH
78529: LD_INT 0
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 0
78538: PUSH
78539: LD_INT 1
78541: NEG
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 1
78549: PUSH
78550: LD_INT 0
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 1
78559: PUSH
78560: LD_INT 1
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 0
78569: PUSH
78570: LD_INT 1
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 1
78579: NEG
78580: PUSH
78581: LD_INT 0
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: PUSH
78588: LD_INT 1
78590: NEG
78591: PUSH
78592: LD_INT 1
78594: NEG
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 2
78602: PUSH
78603: LD_INT 1
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: PUSH
78610: LD_INT 2
78612: PUSH
78613: LD_INT 2
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: LD_INT 1
78622: PUSH
78623: LD_INT 2
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 0
78632: PUSH
78633: LD_INT 2
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 1
78642: NEG
78643: PUSH
78644: LD_INT 1
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: LIST
78655: LIST
78656: LIST
78657: LIST
78658: LIST
78659: LIST
78660: LIST
78661: LIST
78662: LIST
78663: LIST
78664: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78665: LD_ADDR_VAR 0 51
78669: PUSH
78670: LD_INT 0
78672: PUSH
78673: LD_INT 0
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 0
78682: PUSH
78683: LD_INT 1
78685: NEG
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: LD_INT 1
78693: PUSH
78694: LD_INT 0
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: PUSH
78701: LD_INT 1
78703: PUSH
78704: LD_INT 1
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 0
78713: PUSH
78714: LD_INT 1
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 1
78723: NEG
78724: PUSH
78725: LD_INT 0
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 1
78734: NEG
78735: PUSH
78736: LD_INT 1
78738: NEG
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: LD_INT 1
78746: PUSH
78747: LD_INT 2
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 0
78756: PUSH
78757: LD_INT 2
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 1
78766: NEG
78767: PUSH
78768: LD_INT 1
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 2
78777: NEG
78778: PUSH
78779: LD_INT 0
78781: PUSH
78782: EMPTY
78783: LIST
78784: LIST
78785: PUSH
78786: LD_INT 2
78788: NEG
78789: PUSH
78790: LD_INT 1
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78812: LD_ADDR_VAR 0 52
78816: PUSH
78817: LD_INT 0
78819: PUSH
78820: LD_INT 0
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 0
78829: PUSH
78830: LD_INT 1
78832: NEG
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 1
78840: PUSH
78841: LD_INT 0
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: PUSH
78851: LD_INT 1
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 0
78860: PUSH
78861: LD_INT 1
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 1
78870: NEG
78871: PUSH
78872: LD_INT 0
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: LD_INT 1
78885: NEG
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: PUSH
78891: LD_INT 1
78893: NEG
78894: PUSH
78895: LD_INT 2
78897: NEG
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: LD_INT 1
78905: NEG
78906: PUSH
78907: LD_INT 1
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 2
78916: NEG
78917: PUSH
78918: LD_INT 0
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 2
78927: NEG
78928: PUSH
78929: LD_INT 1
78931: NEG
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 2
78939: NEG
78940: PUSH
78941: LD_INT 2
78943: NEG
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: LIST
78953: LIST
78954: LIST
78955: LIST
78956: LIST
78957: LIST
78958: LIST
78959: LIST
78960: LIST
78961: LIST
78962: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78963: LD_ADDR_VAR 0 53
78967: PUSH
78968: LD_INT 0
78970: PUSH
78971: LD_INT 0
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: LD_INT 0
78980: PUSH
78981: LD_INT 1
78983: NEG
78984: PUSH
78985: EMPTY
78986: LIST
78987: LIST
78988: PUSH
78989: LD_INT 1
78991: PUSH
78992: LD_INT 0
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: LD_INT 1
79001: PUSH
79002: LD_INT 1
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 0
79011: PUSH
79012: LD_INT 1
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: LD_INT 1
79021: NEG
79022: PUSH
79023: LD_INT 0
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_INT 1
79032: NEG
79033: PUSH
79034: LD_INT 1
79036: NEG
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 1
79044: NEG
79045: PUSH
79046: LD_INT 2
79048: NEG
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 0
79056: PUSH
79057: LD_INT 2
79059: NEG
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 1
79067: PUSH
79068: LD_INT 1
79070: NEG
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 2
79078: PUSH
79079: LD_INT 0
79081: PUSH
79082: EMPTY
79083: LIST
79084: LIST
79085: PUSH
79086: LD_INT 2
79088: PUSH
79089: LD_INT 1
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 2
79098: PUSH
79099: LD_INT 2
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 1
79108: PUSH
79109: LD_INT 2
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 0
79118: PUSH
79119: LD_INT 2
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 1
79128: NEG
79129: PUSH
79130: LD_INT 1
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 2
79139: NEG
79140: PUSH
79141: LD_INT 0
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 2
79150: NEG
79151: PUSH
79152: LD_INT 1
79154: NEG
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 2
79162: NEG
79163: PUSH
79164: LD_INT 2
79166: NEG
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: LIST
79176: LIST
79177: LIST
79178: LIST
79179: LIST
79180: LIST
79181: LIST
79182: LIST
79183: LIST
79184: LIST
79185: LIST
79186: LIST
79187: LIST
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79193: LD_ADDR_VAR 0 54
79197: PUSH
79198: LD_INT 0
79200: PUSH
79201: LD_INT 0
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 0
79210: PUSH
79211: LD_INT 1
79213: NEG
79214: PUSH
79215: EMPTY
79216: LIST
79217: LIST
79218: PUSH
79219: LD_INT 1
79221: PUSH
79222: LD_INT 0
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 1
79231: PUSH
79232: LD_INT 1
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 0
79241: PUSH
79242: LD_INT 1
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 1
79251: NEG
79252: PUSH
79253: LD_INT 0
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 1
79262: NEG
79263: PUSH
79264: LD_INT 1
79266: NEG
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 1
79274: NEG
79275: PUSH
79276: LD_INT 2
79278: NEG
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 0
79286: PUSH
79287: LD_INT 2
79289: NEG
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 1
79297: PUSH
79298: LD_INT 1
79300: NEG
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 2
79308: PUSH
79309: LD_INT 0
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 2
79318: PUSH
79319: LD_INT 1
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 2
79328: PUSH
79329: LD_INT 2
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 1
79338: PUSH
79339: LD_INT 2
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 0
79348: PUSH
79349: LD_INT 2
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 1
79358: NEG
79359: PUSH
79360: LD_INT 1
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 2
79369: NEG
79370: PUSH
79371: LD_INT 0
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: PUSH
79378: LD_INT 2
79380: NEG
79381: PUSH
79382: LD_INT 1
79384: NEG
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 2
79392: NEG
79393: PUSH
79394: LD_INT 2
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79423: LD_ADDR_VAR 0 55
79427: PUSH
79428: LD_INT 0
79430: PUSH
79431: LD_INT 0
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 0
79440: PUSH
79441: LD_INT 1
79443: NEG
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 1
79451: PUSH
79452: LD_INT 0
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 1
79461: PUSH
79462: LD_INT 1
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 0
79471: PUSH
79472: LD_INT 1
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 1
79481: NEG
79482: PUSH
79483: LD_INT 0
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: NEG
79493: PUSH
79494: LD_INT 1
79496: NEG
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: LD_INT 1
79504: NEG
79505: PUSH
79506: LD_INT 2
79508: NEG
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 0
79516: PUSH
79517: LD_INT 2
79519: NEG
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 1
79527: PUSH
79528: LD_INT 1
79530: NEG
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PUSH
79536: LD_INT 2
79538: PUSH
79539: LD_INT 0
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: LD_INT 2
79548: PUSH
79549: LD_INT 1
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 2
79558: PUSH
79559: LD_INT 2
79561: PUSH
79562: EMPTY
79563: LIST
79564: LIST
79565: PUSH
79566: LD_INT 1
79568: PUSH
79569: LD_INT 2
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 0
79578: PUSH
79579: LD_INT 2
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 1
79588: NEG
79589: PUSH
79590: LD_INT 1
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 2
79599: NEG
79600: PUSH
79601: LD_INT 0
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 2
79610: NEG
79611: PUSH
79612: LD_INT 1
79614: NEG
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 2
79622: NEG
79623: PUSH
79624: LD_INT 2
79626: NEG
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: LIST
79646: LIST
79647: LIST
79648: LIST
79649: LIST
79650: LIST
79651: LIST
79652: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79653: LD_ADDR_VAR 0 56
79657: PUSH
79658: LD_INT 0
79660: PUSH
79661: LD_INT 0
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 0
79670: PUSH
79671: LD_INT 1
79673: NEG
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 1
79681: PUSH
79682: LD_INT 0
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 1
79691: PUSH
79692: LD_INT 1
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 0
79701: PUSH
79702: LD_INT 1
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 1
79711: NEG
79712: PUSH
79713: LD_INT 0
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PUSH
79720: LD_INT 1
79722: NEG
79723: PUSH
79724: LD_INT 1
79726: NEG
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 1
79734: NEG
79735: PUSH
79736: LD_INT 2
79738: NEG
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: LD_INT 0
79746: PUSH
79747: LD_INT 2
79749: NEG
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 1
79757: PUSH
79758: LD_INT 1
79760: NEG
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: PUSH
79766: LD_INT 2
79768: PUSH
79769: LD_INT 0
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: LD_INT 2
79778: PUSH
79779: LD_INT 1
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 2
79788: PUSH
79789: LD_INT 2
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 1
79798: PUSH
79799: LD_INT 2
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 0
79808: PUSH
79809: LD_INT 2
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 1
79818: NEG
79819: PUSH
79820: LD_INT 1
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: PUSH
79827: LD_INT 2
79829: NEG
79830: PUSH
79831: LD_INT 0
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 2
79840: NEG
79841: PUSH
79842: LD_INT 1
79844: NEG
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 2
79852: NEG
79853: PUSH
79854: LD_INT 2
79856: NEG
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79883: LD_ADDR_VAR 0 57
79887: PUSH
79888: LD_INT 0
79890: PUSH
79891: LD_INT 0
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 0
79900: PUSH
79901: LD_INT 1
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: LD_INT 0
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 1
79921: PUSH
79922: LD_INT 1
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 0
79931: PUSH
79932: LD_INT 1
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 1
79941: NEG
79942: PUSH
79943: LD_INT 0
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 1
79952: NEG
79953: PUSH
79954: LD_INT 1
79956: NEG
79957: PUSH
79958: EMPTY
79959: LIST
79960: LIST
79961: PUSH
79962: LD_INT 1
79964: NEG
79965: PUSH
79966: LD_INT 2
79968: NEG
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 0
79976: PUSH
79977: LD_INT 2
79979: NEG
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 1
79987: PUSH
79988: LD_INT 1
79990: NEG
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 2
79998: PUSH
79999: LD_INT 0
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: PUSH
80006: LD_INT 2
80008: PUSH
80009: LD_INT 1
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 2
80018: PUSH
80019: LD_INT 2
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: LD_INT 2
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 0
80038: PUSH
80039: LD_INT 2
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 1
80048: NEG
80049: PUSH
80050: LD_INT 1
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 2
80059: NEG
80060: PUSH
80061: LD_INT 0
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 2
80070: NEG
80071: PUSH
80072: LD_INT 1
80074: NEG
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 2
80082: NEG
80083: PUSH
80084: LD_INT 2
80086: NEG
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80113: LD_ADDR_VAR 0 58
80117: PUSH
80118: LD_INT 0
80120: PUSH
80121: LD_INT 0
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 0
80130: PUSH
80131: LD_INT 1
80133: NEG
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: LD_INT 1
80141: PUSH
80142: LD_INT 0
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: PUSH
80152: LD_INT 1
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PUSH
80159: LD_INT 0
80161: PUSH
80162: LD_INT 1
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 1
80171: NEG
80172: PUSH
80173: LD_INT 0
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 1
80182: NEG
80183: PUSH
80184: LD_INT 1
80186: NEG
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 1
80194: NEG
80195: PUSH
80196: LD_INT 2
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 0
80206: PUSH
80207: LD_INT 2
80209: NEG
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 1
80217: PUSH
80218: LD_INT 1
80220: NEG
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 2
80228: PUSH
80229: LD_INT 0
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 2
80238: PUSH
80239: LD_INT 1
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: PUSH
80246: LD_INT 2
80248: PUSH
80249: LD_INT 2
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 1
80258: PUSH
80259: LD_INT 2
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 0
80268: PUSH
80269: LD_INT 2
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: PUSH
80276: LD_INT 1
80278: NEG
80279: PUSH
80280: LD_INT 1
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 2
80289: NEG
80290: PUSH
80291: LD_INT 0
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 2
80300: NEG
80301: PUSH
80302: LD_INT 1
80304: NEG
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 2
80312: NEG
80313: PUSH
80314: LD_INT 2
80316: NEG
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: LIST
80326: LIST
80327: LIST
80328: LIST
80329: LIST
80330: LIST
80331: LIST
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80343: LD_ADDR_VAR 0 59
80347: PUSH
80348: LD_INT 0
80350: PUSH
80351: LD_INT 0
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 0
80360: PUSH
80361: LD_INT 1
80363: NEG
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 1
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 1
80381: PUSH
80382: LD_INT 1
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 0
80391: PUSH
80392: LD_INT 1
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: LD_INT 1
80401: NEG
80402: PUSH
80403: LD_INT 0
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 1
80412: NEG
80413: PUSH
80414: LD_INT 1
80416: NEG
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: LIST
80426: LIST
80427: LIST
80428: LIST
80429: LIST
80430: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80431: LD_ADDR_VAR 0 60
80435: PUSH
80436: LD_INT 0
80438: PUSH
80439: LD_INT 0
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 0
80448: PUSH
80449: LD_INT 1
80451: NEG
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 1
80459: PUSH
80460: LD_INT 0
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: LD_INT 1
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 0
80479: PUSH
80480: LD_INT 1
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 1
80489: NEG
80490: PUSH
80491: LD_INT 0
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 1
80500: NEG
80501: PUSH
80502: LD_INT 1
80504: NEG
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PUSH
80510: EMPTY
80511: LIST
80512: LIST
80513: LIST
80514: LIST
80515: LIST
80516: LIST
80517: LIST
80518: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80519: LD_ADDR_VAR 0 61
80523: PUSH
80524: LD_INT 0
80526: PUSH
80527: LD_INT 0
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 0
80536: PUSH
80537: LD_INT 1
80539: NEG
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 1
80547: PUSH
80548: LD_INT 0
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: PUSH
80555: LD_INT 1
80557: PUSH
80558: LD_INT 1
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 0
80567: PUSH
80568: LD_INT 1
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 1
80577: NEG
80578: PUSH
80579: LD_INT 0
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 1
80588: NEG
80589: PUSH
80590: LD_INT 1
80592: NEG
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80607: LD_ADDR_VAR 0 62
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: LD_INT 0
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: LD_INT 0
80624: PUSH
80625: LD_INT 1
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 1
80635: PUSH
80636: LD_INT 0
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 1
80645: PUSH
80646: LD_INT 1
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: LD_INT 0
80655: PUSH
80656: LD_INT 1
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PUSH
80663: LD_INT 1
80665: NEG
80666: PUSH
80667: LD_INT 0
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 1
80676: NEG
80677: PUSH
80678: LD_INT 1
80680: NEG
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80695: LD_ADDR_VAR 0 63
80699: PUSH
80700: LD_INT 0
80702: PUSH
80703: LD_INT 0
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 0
80712: PUSH
80713: LD_INT 1
80715: NEG
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 1
80723: PUSH
80724: LD_INT 0
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 1
80733: PUSH
80734: LD_INT 1
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 0
80743: PUSH
80744: LD_INT 1
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 1
80753: NEG
80754: PUSH
80755: LD_INT 0
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 1
80764: NEG
80765: PUSH
80766: LD_INT 1
80768: NEG
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
80783: LD_ADDR_VAR 0 64
80787: PUSH
80788: LD_INT 0
80790: PUSH
80791: LD_INT 0
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: LD_INT 1
80803: NEG
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 1
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 1
80821: PUSH
80822: LD_INT 1
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 0
80831: PUSH
80832: LD_INT 1
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 1
80841: NEG
80842: PUSH
80843: LD_INT 0
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: ST_TO_ADDR
// end ; 1 :
80871: GO 86768
80873: LD_INT 1
80875: DOUBLE
80876: EQUAL
80877: IFTRUE 80881
80879: GO 83504
80881: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80882: LD_ADDR_VAR 0 11
80886: PUSH
80887: LD_INT 1
80889: NEG
80890: PUSH
80891: LD_INT 3
80893: NEG
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 0
80901: PUSH
80902: LD_INT 3
80904: NEG
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 1
80912: PUSH
80913: LD_INT 2
80915: NEG
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: LIST
80925: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80926: LD_ADDR_VAR 0 12
80930: PUSH
80931: LD_INT 2
80933: PUSH
80934: LD_INT 1
80936: NEG
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 3
80944: PUSH
80945: LD_INT 0
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PUSH
80952: LD_INT 3
80954: PUSH
80955: LD_INT 1
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: LIST
80966: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80967: LD_ADDR_VAR 0 13
80971: PUSH
80972: LD_INT 3
80974: PUSH
80975: LD_INT 2
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 3
80984: PUSH
80985: LD_INT 3
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 2
80994: PUSH
80995: LD_INT 3
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: LIST
81006: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81007: LD_ADDR_VAR 0 14
81011: PUSH
81012: LD_INT 1
81014: PUSH
81015: LD_INT 3
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: LD_INT 3
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: LD_INT 2
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: LIST
81047: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81048: LD_ADDR_VAR 0 15
81052: PUSH
81053: LD_INT 2
81055: NEG
81056: PUSH
81057: LD_INT 1
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 3
81066: NEG
81067: PUSH
81068: LD_INT 0
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 3
81077: NEG
81078: PUSH
81079: LD_INT 1
81081: NEG
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: LIST
81091: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81092: LD_ADDR_VAR 0 16
81096: PUSH
81097: LD_INT 2
81099: NEG
81100: PUSH
81101: LD_INT 3
81103: NEG
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: PUSH
81109: LD_INT 3
81111: NEG
81112: PUSH
81113: LD_INT 2
81115: NEG
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 3
81123: NEG
81124: PUSH
81125: LD_INT 3
81127: NEG
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: LIST
81137: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81138: LD_ADDR_VAR 0 17
81142: PUSH
81143: LD_INT 1
81145: NEG
81146: PUSH
81147: LD_INT 3
81149: NEG
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PUSH
81155: LD_INT 0
81157: PUSH
81158: LD_INT 3
81160: NEG
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 1
81168: PUSH
81169: LD_INT 2
81171: NEG
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: LIST
81181: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81182: LD_ADDR_VAR 0 18
81186: PUSH
81187: LD_INT 2
81189: PUSH
81190: LD_INT 1
81192: NEG
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 3
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 3
81210: PUSH
81211: LD_INT 1
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: LIST
81222: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81223: LD_ADDR_VAR 0 19
81227: PUSH
81228: LD_INT 3
81230: PUSH
81231: LD_INT 2
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 3
81240: PUSH
81241: LD_INT 3
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 2
81250: PUSH
81251: LD_INT 3
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: LIST
81262: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81263: LD_ADDR_VAR 0 20
81267: PUSH
81268: LD_INT 1
81270: PUSH
81271: LD_INT 3
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 0
81280: PUSH
81281: LD_INT 3
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 1
81290: NEG
81291: PUSH
81292: LD_INT 2
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: LIST
81303: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81304: LD_ADDR_VAR 0 21
81308: PUSH
81309: LD_INT 2
81311: NEG
81312: PUSH
81313: LD_INT 1
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 3
81322: NEG
81323: PUSH
81324: LD_INT 0
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 3
81333: NEG
81334: PUSH
81335: LD_INT 1
81337: NEG
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: LIST
81347: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81348: LD_ADDR_VAR 0 22
81352: PUSH
81353: LD_INT 2
81355: NEG
81356: PUSH
81357: LD_INT 3
81359: NEG
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 3
81367: NEG
81368: PUSH
81369: LD_INT 2
81371: NEG
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 3
81379: NEG
81380: PUSH
81381: LD_INT 3
81383: NEG
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: LIST
81393: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
81394: LD_ADDR_VAR 0 23
81398: PUSH
81399: LD_INT 0
81401: PUSH
81402: LD_INT 3
81404: NEG
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: PUSH
81410: LD_INT 1
81412: NEG
81413: PUSH
81414: LD_INT 4
81416: NEG
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 1
81424: PUSH
81425: LD_INT 3
81427: NEG
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: LIST
81437: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
81438: LD_ADDR_VAR 0 24
81442: PUSH
81443: LD_INT 3
81445: PUSH
81446: LD_INT 0
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PUSH
81453: LD_INT 3
81455: PUSH
81456: LD_INT 1
81458: NEG
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 4
81466: PUSH
81467: LD_INT 1
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: LIST
81478: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
81479: LD_ADDR_VAR 0 25
81483: PUSH
81484: LD_INT 3
81486: PUSH
81487: LD_INT 3
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 4
81496: PUSH
81497: LD_INT 3
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 3
81506: PUSH
81507: LD_INT 4
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: LIST
81518: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
81519: LD_ADDR_VAR 0 26
81523: PUSH
81524: LD_INT 0
81526: PUSH
81527: LD_INT 3
81529: PUSH
81530: EMPTY
81531: LIST
81532: LIST
81533: PUSH
81534: LD_INT 1
81536: PUSH
81537: LD_INT 4
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 1
81546: NEG
81547: PUSH
81548: LD_INT 3
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: LIST
81559: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
81560: LD_ADDR_VAR 0 27
81564: PUSH
81565: LD_INT 3
81567: NEG
81568: PUSH
81569: LD_INT 0
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: PUSH
81576: LD_INT 3
81578: NEG
81579: PUSH
81580: LD_INT 1
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 4
81589: NEG
81590: PUSH
81591: LD_INT 1
81593: NEG
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: LIST
81603: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
81604: LD_ADDR_VAR 0 28
81608: PUSH
81609: LD_INT 3
81611: NEG
81612: PUSH
81613: LD_INT 3
81615: NEG
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 3
81623: NEG
81624: PUSH
81625: LD_INT 4
81627: NEG
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 4
81635: NEG
81636: PUSH
81637: LD_INT 3
81639: NEG
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: LIST
81649: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
81650: LD_ADDR_VAR 0 29
81654: PUSH
81655: LD_INT 1
81657: NEG
81658: PUSH
81659: LD_INT 3
81661: NEG
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_INT 0
81669: PUSH
81670: LD_INT 3
81672: NEG
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 1
81680: PUSH
81681: LD_INT 2
81683: NEG
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 1
81691: NEG
81692: PUSH
81693: LD_INT 4
81695: NEG
81696: PUSH
81697: EMPTY
81698: LIST
81699: LIST
81700: PUSH
81701: LD_INT 0
81703: PUSH
81704: LD_INT 4
81706: NEG
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: PUSH
81712: LD_INT 1
81714: PUSH
81715: LD_INT 3
81717: NEG
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: PUSH
81723: LD_INT 1
81725: NEG
81726: PUSH
81727: LD_INT 5
81729: NEG
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 0
81737: PUSH
81738: LD_INT 5
81740: NEG
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 1
81748: PUSH
81749: LD_INT 4
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 1
81759: NEG
81760: PUSH
81761: LD_INT 6
81763: NEG
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 0
81771: PUSH
81772: LD_INT 6
81774: NEG
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 1
81782: PUSH
81783: LD_INT 5
81785: NEG
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
81805: LD_ADDR_VAR 0 30
81809: PUSH
81810: LD_INT 2
81812: PUSH
81813: LD_INT 1
81815: NEG
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 3
81823: PUSH
81824: LD_INT 0
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 3
81833: PUSH
81834: LD_INT 1
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 3
81843: PUSH
81844: LD_INT 1
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 4
81854: PUSH
81855: LD_INT 0
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 4
81864: PUSH
81865: LD_INT 1
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 4
81874: PUSH
81875: LD_INT 1
81877: NEG
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 5
81885: PUSH
81886: LD_INT 0
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 5
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 5
81905: PUSH
81906: LD_INT 1
81908: NEG
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 6
81916: PUSH
81917: LD_INT 0
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: LD_INT 6
81926: PUSH
81927: LD_INT 1
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
81948: LD_ADDR_VAR 0 31
81952: PUSH
81953: LD_INT 3
81955: PUSH
81956: LD_INT 2
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 3
81965: PUSH
81966: LD_INT 3
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PUSH
81973: LD_INT 2
81975: PUSH
81976: LD_INT 3
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 4
81985: PUSH
81986: LD_INT 3
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 4
81995: PUSH
81996: LD_INT 4
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 3
82005: PUSH
82006: LD_INT 4
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 5
82015: PUSH
82016: LD_INT 4
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_INT 5
82025: PUSH
82026: LD_INT 5
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 4
82035: PUSH
82036: LD_INT 5
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 6
82045: PUSH
82046: LD_INT 5
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 6
82055: PUSH
82056: LD_INT 6
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 5
82065: PUSH
82066: LD_INT 6
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
82087: LD_ADDR_VAR 0 32
82091: PUSH
82092: LD_INT 1
82094: PUSH
82095: LD_INT 3
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 0
82104: PUSH
82105: LD_INT 3
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 1
82114: NEG
82115: PUSH
82116: LD_INT 2
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 1
82125: PUSH
82126: LD_INT 4
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 0
82135: PUSH
82136: LD_INT 4
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 1
82145: NEG
82146: PUSH
82147: LD_INT 3
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 1
82156: PUSH
82157: LD_INT 5
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PUSH
82164: LD_INT 0
82166: PUSH
82167: LD_INT 5
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 1
82176: NEG
82177: PUSH
82178: LD_INT 4
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 1
82187: PUSH
82188: LD_INT 6
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 0
82197: PUSH
82198: LD_INT 6
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 1
82207: NEG
82208: PUSH
82209: LD_INT 5
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
82230: LD_ADDR_VAR 0 33
82234: PUSH
82235: LD_INT 2
82237: NEG
82238: PUSH
82239: LD_INT 1
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: LD_INT 3
82248: NEG
82249: PUSH
82250: LD_INT 0
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: PUSH
82257: LD_INT 3
82259: NEG
82260: PUSH
82261: LD_INT 1
82263: NEG
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 3
82271: NEG
82272: PUSH
82273: LD_INT 1
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 4
82282: NEG
82283: PUSH
82284: LD_INT 0
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 4
82293: NEG
82294: PUSH
82295: LD_INT 1
82297: NEG
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: LD_INT 4
82305: NEG
82306: PUSH
82307: LD_INT 1
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 5
82316: NEG
82317: PUSH
82318: LD_INT 0
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 5
82327: NEG
82328: PUSH
82329: LD_INT 1
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 5
82339: NEG
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 6
82350: NEG
82351: PUSH
82352: LD_INT 0
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 6
82361: NEG
82362: PUSH
82363: LD_INT 1
82365: NEG
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
82385: LD_ADDR_VAR 0 34
82389: PUSH
82390: LD_INT 2
82392: NEG
82393: PUSH
82394: LD_INT 3
82396: NEG
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 3
82404: NEG
82405: PUSH
82406: LD_INT 2
82408: NEG
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 3
82416: NEG
82417: PUSH
82418: LD_INT 3
82420: NEG
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 3
82428: NEG
82429: PUSH
82430: LD_INT 4
82432: NEG
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 4
82440: NEG
82441: PUSH
82442: LD_INT 3
82444: NEG
82445: PUSH
82446: EMPTY
82447: LIST
82448: LIST
82449: PUSH
82450: LD_INT 4
82452: NEG
82453: PUSH
82454: LD_INT 4
82456: NEG
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 4
82464: NEG
82465: PUSH
82466: LD_INT 5
82468: NEG
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 5
82476: NEG
82477: PUSH
82478: LD_INT 4
82480: NEG
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 5
82488: NEG
82489: PUSH
82490: LD_INT 5
82492: NEG
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 5
82500: NEG
82501: PUSH
82502: LD_INT 6
82504: NEG
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 6
82512: NEG
82513: PUSH
82514: LD_INT 5
82516: NEG
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 6
82524: NEG
82525: PUSH
82526: LD_INT 6
82528: NEG
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
82548: LD_ADDR_VAR 0 41
82552: PUSH
82553: LD_INT 0
82555: PUSH
82556: LD_INT 2
82558: NEG
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 1
82566: NEG
82567: PUSH
82568: LD_INT 3
82570: NEG
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: LD_INT 1
82578: PUSH
82579: LD_INT 2
82581: NEG
82582: PUSH
82583: EMPTY
82584: LIST
82585: LIST
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: LIST
82591: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
82592: LD_ADDR_VAR 0 42
82596: PUSH
82597: LD_INT 2
82599: PUSH
82600: LD_INT 0
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 2
82609: PUSH
82610: LD_INT 1
82612: NEG
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 3
82620: PUSH
82621: LD_INT 1
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: LIST
82632: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
82633: LD_ADDR_VAR 0 43
82637: PUSH
82638: LD_INT 2
82640: PUSH
82641: LD_INT 2
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 3
82650: PUSH
82651: LD_INT 2
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 2
82660: PUSH
82661: LD_INT 3
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: LIST
82672: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
82673: LD_ADDR_VAR 0 44
82677: PUSH
82678: LD_INT 0
82680: PUSH
82681: LD_INT 2
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PUSH
82688: LD_INT 1
82690: PUSH
82691: LD_INT 3
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 1
82700: NEG
82701: PUSH
82702: LD_INT 2
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: EMPTY
82710: LIST
82711: LIST
82712: LIST
82713: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82714: LD_ADDR_VAR 0 45
82718: PUSH
82719: LD_INT 2
82721: NEG
82722: PUSH
82723: LD_INT 0
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 2
82732: NEG
82733: PUSH
82734: LD_INT 1
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 3
82743: NEG
82744: PUSH
82745: LD_INT 1
82747: NEG
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: LIST
82757: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
82758: LD_ADDR_VAR 0 46
82762: PUSH
82763: LD_INT 2
82765: NEG
82766: PUSH
82767: LD_INT 2
82769: NEG
82770: PUSH
82771: EMPTY
82772: LIST
82773: LIST
82774: PUSH
82775: LD_INT 2
82777: NEG
82778: PUSH
82779: LD_INT 3
82781: NEG
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 3
82789: NEG
82790: PUSH
82791: LD_INT 2
82793: NEG
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: LIST
82803: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
82804: LD_ADDR_VAR 0 47
82808: PUSH
82809: LD_INT 2
82811: NEG
82812: PUSH
82813: LD_INT 3
82815: NEG
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: NEG
82824: PUSH
82825: LD_INT 3
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82837: LD_ADDR_VAR 0 48
82841: PUSH
82842: LD_INT 1
82844: PUSH
82845: LD_INT 2
82847: NEG
82848: PUSH
82849: EMPTY
82850: LIST
82851: LIST
82852: PUSH
82853: LD_INT 2
82855: PUSH
82856: LD_INT 1
82858: NEG
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
82868: LD_ADDR_VAR 0 49
82872: PUSH
82873: LD_INT 3
82875: PUSH
82876: LD_INT 1
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 3
82885: PUSH
82886: LD_INT 2
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
82897: LD_ADDR_VAR 0 50
82901: PUSH
82902: LD_INT 2
82904: PUSH
82905: LD_INT 3
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: LD_INT 1
82914: PUSH
82915: LD_INT 3
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82926: LD_ADDR_VAR 0 51
82930: PUSH
82931: LD_INT 1
82933: NEG
82934: PUSH
82935: LD_INT 2
82937: PUSH
82938: EMPTY
82939: LIST
82940: LIST
82941: PUSH
82942: LD_INT 2
82944: NEG
82945: PUSH
82946: LD_INT 1
82948: PUSH
82949: EMPTY
82950: LIST
82951: LIST
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82957: LD_ADDR_VAR 0 52
82961: PUSH
82962: LD_INT 3
82964: NEG
82965: PUSH
82966: LD_INT 1
82968: NEG
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 3
82976: NEG
82977: PUSH
82978: LD_INT 2
82980: NEG
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82990: LD_ADDR_VAR 0 53
82994: PUSH
82995: LD_INT 1
82997: NEG
82998: PUSH
82999: LD_INT 3
83001: NEG
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 0
83009: PUSH
83010: LD_INT 3
83012: NEG
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 1
83020: PUSH
83021: LD_INT 2
83023: NEG
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: LIST
83033: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
83034: LD_ADDR_VAR 0 54
83038: PUSH
83039: LD_INT 2
83041: PUSH
83042: LD_INT 1
83044: NEG
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 3
83052: PUSH
83053: LD_INT 0
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 3
83062: PUSH
83063: LD_INT 1
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: LIST
83074: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
83075: LD_ADDR_VAR 0 55
83079: PUSH
83080: LD_INT 3
83082: PUSH
83083: LD_INT 2
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 3
83092: PUSH
83093: LD_INT 3
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 2
83102: PUSH
83103: LD_INT 3
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: LIST
83114: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83115: LD_ADDR_VAR 0 56
83119: PUSH
83120: LD_INT 1
83122: PUSH
83123: LD_INT 3
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 0
83132: PUSH
83133: LD_INT 3
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 1
83142: NEG
83143: PUSH
83144: LD_INT 2
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: LIST
83155: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83156: LD_ADDR_VAR 0 57
83160: PUSH
83161: LD_INT 2
83163: NEG
83164: PUSH
83165: LD_INT 1
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 3
83174: NEG
83175: PUSH
83176: LD_INT 0
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 3
83185: NEG
83186: PUSH
83187: LD_INT 1
83189: NEG
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: LIST
83199: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83200: LD_ADDR_VAR 0 58
83204: PUSH
83205: LD_INT 2
83207: NEG
83208: PUSH
83209: LD_INT 3
83211: NEG
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 3
83219: NEG
83220: PUSH
83221: LD_INT 2
83223: NEG
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 3
83231: NEG
83232: PUSH
83233: LD_INT 3
83235: NEG
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: LIST
83245: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
83246: LD_ADDR_VAR 0 59
83250: PUSH
83251: LD_INT 1
83253: NEG
83254: PUSH
83255: LD_INT 2
83257: NEG
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 0
83265: PUSH
83266: LD_INT 2
83268: NEG
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 1
83276: PUSH
83277: LD_INT 1
83279: NEG
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: LIST
83289: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
83290: LD_ADDR_VAR 0 60
83294: PUSH
83295: LD_INT 1
83297: PUSH
83298: LD_INT 1
83300: NEG
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 2
83308: PUSH
83309: LD_INT 0
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 2
83318: PUSH
83319: LD_INT 1
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: LIST
83330: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
83331: LD_ADDR_VAR 0 61
83335: PUSH
83336: LD_INT 2
83338: PUSH
83339: LD_INT 1
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 2
83348: PUSH
83349: LD_INT 2
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 1
83358: PUSH
83359: LD_INT 2
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: LIST
83370: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
83371: LD_ADDR_VAR 0 62
83375: PUSH
83376: LD_INT 1
83378: PUSH
83379: LD_INT 2
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 0
83388: PUSH
83389: LD_INT 2
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 1
83398: NEG
83399: PUSH
83400: LD_INT 1
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: LIST
83411: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
83412: LD_ADDR_VAR 0 63
83416: PUSH
83417: LD_INT 1
83419: NEG
83420: PUSH
83421: LD_INT 1
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 2
83430: NEG
83431: PUSH
83432: LD_INT 0
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 2
83441: NEG
83442: PUSH
83443: LD_INT 1
83445: NEG
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: LIST
83455: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83456: LD_ADDR_VAR 0 64
83460: PUSH
83461: LD_INT 1
83463: NEG
83464: PUSH
83465: LD_INT 2
83467: NEG
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 2
83475: NEG
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 2
83487: NEG
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: LIST
83501: ST_TO_ADDR
// end ; 2 :
83502: GO 86768
83504: LD_INT 2
83506: DOUBLE
83507: EQUAL
83508: IFTRUE 83512
83510: GO 86767
83512: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
83513: LD_ADDR_VAR 0 29
83517: PUSH
83518: LD_INT 4
83520: PUSH
83521: LD_INT 0
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 4
83530: PUSH
83531: LD_INT 1
83533: NEG
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 5
83541: PUSH
83542: LD_INT 0
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 5
83551: PUSH
83552: LD_INT 1
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 4
83561: PUSH
83562: LD_INT 1
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: LD_INT 3
83571: PUSH
83572: LD_INT 0
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 3
83581: PUSH
83582: LD_INT 1
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 3
83592: PUSH
83593: LD_INT 2
83595: NEG
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 5
83603: PUSH
83604: LD_INT 2
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 3
83613: PUSH
83614: LD_INT 3
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 3
83623: PUSH
83624: LD_INT 2
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 4
83633: PUSH
83634: LD_INT 3
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: PUSH
83641: LD_INT 4
83643: PUSH
83644: LD_INT 4
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 3
83653: PUSH
83654: LD_INT 4
83656: PUSH
83657: EMPTY
83658: LIST
83659: LIST
83660: PUSH
83661: LD_INT 2
83663: PUSH
83664: LD_INT 3
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: LD_INT 2
83673: PUSH
83674: LD_INT 2
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 4
83683: PUSH
83684: LD_INT 2
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: PUSH
83691: LD_INT 2
83693: PUSH
83694: LD_INT 4
83696: PUSH
83697: EMPTY
83698: LIST
83699: LIST
83700: PUSH
83701: LD_INT 0
83703: PUSH
83704: LD_INT 4
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: PUSH
83711: LD_INT 0
83713: PUSH
83714: LD_INT 3
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PUSH
83721: LD_INT 1
83723: PUSH
83724: LD_INT 4
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: PUSH
83731: LD_INT 1
83733: PUSH
83734: LD_INT 5
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 0
83743: PUSH
83744: LD_INT 5
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 1
83753: NEG
83754: PUSH
83755: LD_INT 4
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 1
83764: NEG
83765: PUSH
83766: LD_INT 3
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 2
83775: PUSH
83776: LD_INT 5
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 2
83785: NEG
83786: PUSH
83787: LD_INT 3
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 3
83796: NEG
83797: PUSH
83798: LD_INT 0
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: PUSH
83805: LD_INT 3
83807: NEG
83808: PUSH
83809: LD_INT 1
83811: NEG
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: LD_INT 2
83819: NEG
83820: PUSH
83821: LD_INT 0
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: PUSH
83828: LD_INT 2
83830: NEG
83831: PUSH
83832: LD_INT 1
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: PUSH
83839: LD_INT 3
83841: NEG
83842: PUSH
83843: LD_INT 1
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: PUSH
83850: LD_INT 4
83852: NEG
83853: PUSH
83854: LD_INT 0
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: PUSH
83861: LD_INT 4
83863: NEG
83864: PUSH
83865: LD_INT 1
83867: NEG
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 4
83875: NEG
83876: PUSH
83877: LD_INT 2
83879: NEG
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: LD_INT 2
83887: NEG
83888: PUSH
83889: LD_INT 2
83891: PUSH
83892: EMPTY
83893: LIST
83894: LIST
83895: PUSH
83896: LD_INT 4
83898: NEG
83899: PUSH
83900: LD_INT 4
83902: NEG
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: PUSH
83908: LD_INT 4
83910: NEG
83911: PUSH
83912: LD_INT 5
83914: NEG
83915: PUSH
83916: EMPTY
83917: LIST
83918: LIST
83919: PUSH
83920: LD_INT 3
83922: NEG
83923: PUSH
83924: LD_INT 4
83926: NEG
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: PUSH
83932: LD_INT 3
83934: NEG
83935: PUSH
83936: LD_INT 3
83938: NEG
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PUSH
83944: LD_INT 4
83946: NEG
83947: PUSH
83948: LD_INT 3
83950: NEG
83951: PUSH
83952: EMPTY
83953: LIST
83954: LIST
83955: PUSH
83956: LD_INT 5
83958: NEG
83959: PUSH
83960: LD_INT 4
83962: NEG
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: PUSH
83968: LD_INT 5
83970: NEG
83971: PUSH
83972: LD_INT 5
83974: NEG
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: LD_INT 3
83982: NEG
83983: PUSH
83984: LD_INT 5
83986: NEG
83987: PUSH
83988: EMPTY
83989: LIST
83990: LIST
83991: PUSH
83992: LD_INT 5
83994: NEG
83995: PUSH
83996: LD_INT 3
83998: NEG
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: EMPTY
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: LIST
84025: LIST
84026: LIST
84027: LIST
84028: LIST
84029: LIST
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: LIST
84048: LIST
84049: LIST
84050: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
84051: LD_ADDR_VAR 0 30
84055: PUSH
84056: LD_INT 4
84058: PUSH
84059: LD_INT 4
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 4
84068: PUSH
84069: LD_INT 3
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 5
84078: PUSH
84079: LD_INT 4
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 5
84088: PUSH
84089: LD_INT 5
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 4
84098: PUSH
84099: LD_INT 5
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 3
84108: PUSH
84109: LD_INT 4
84111: PUSH
84112: EMPTY
84113: LIST
84114: LIST
84115: PUSH
84116: LD_INT 3
84118: PUSH
84119: LD_INT 3
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 5
84128: PUSH
84129: LD_INT 3
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: PUSH
84136: LD_INT 3
84138: PUSH
84139: LD_INT 5
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 0
84148: PUSH
84149: LD_INT 3
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: PUSH
84156: LD_INT 0
84158: PUSH
84159: LD_INT 2
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 1
84168: PUSH
84169: LD_INT 3
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 1
84178: PUSH
84179: LD_INT 4
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 0
84188: PUSH
84189: LD_INT 4
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: PUSH
84196: LD_INT 1
84198: NEG
84199: PUSH
84200: LD_INT 3
84202: PUSH
84203: EMPTY
84204: LIST
84205: LIST
84206: PUSH
84207: LD_INT 1
84209: NEG
84210: PUSH
84211: LD_INT 2
84213: PUSH
84214: EMPTY
84215: LIST
84216: LIST
84217: PUSH
84218: LD_INT 2
84220: PUSH
84221: LD_INT 4
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: LD_INT 2
84230: NEG
84231: PUSH
84232: LD_INT 2
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 4
84241: NEG
84242: PUSH
84243: LD_INT 0
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 4
84252: NEG
84253: PUSH
84254: LD_INT 1
84256: NEG
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 3
84264: NEG
84265: PUSH
84266: LD_INT 0
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 3
84275: NEG
84276: PUSH
84277: LD_INT 1
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: PUSH
84284: LD_INT 4
84286: NEG
84287: PUSH
84288: LD_INT 1
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 5
84297: NEG
84298: PUSH
84299: LD_INT 0
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PUSH
84306: LD_INT 5
84308: NEG
84309: PUSH
84310: LD_INT 1
84312: NEG
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 5
84320: NEG
84321: PUSH
84322: LD_INT 2
84324: NEG
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: PUSH
84330: LD_INT 3
84332: NEG
84333: PUSH
84334: LD_INT 2
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 3
84343: NEG
84344: PUSH
84345: LD_INT 3
84347: NEG
84348: PUSH
84349: EMPTY
84350: LIST
84351: LIST
84352: PUSH
84353: LD_INT 3
84355: NEG
84356: PUSH
84357: LD_INT 4
84359: NEG
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: PUSH
84365: LD_INT 2
84367: NEG
84368: PUSH
84369: LD_INT 3
84371: NEG
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: PUSH
84377: LD_INT 2
84379: NEG
84380: PUSH
84381: LD_INT 2
84383: NEG
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: LD_INT 3
84391: NEG
84392: PUSH
84393: LD_INT 2
84395: NEG
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 4
84403: NEG
84404: PUSH
84405: LD_INT 3
84407: NEG
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 4
84415: NEG
84416: PUSH
84417: LD_INT 4
84419: NEG
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 2
84427: NEG
84428: PUSH
84429: LD_INT 4
84431: NEG
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: LD_INT 4
84439: NEG
84440: PUSH
84441: LD_INT 2
84443: NEG
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 0
84451: PUSH
84452: LD_INT 4
84454: NEG
84455: PUSH
84456: EMPTY
84457: LIST
84458: LIST
84459: PUSH
84460: LD_INT 0
84462: PUSH
84463: LD_INT 5
84465: NEG
84466: PUSH
84467: EMPTY
84468: LIST
84469: LIST
84470: PUSH
84471: LD_INT 1
84473: PUSH
84474: LD_INT 4
84476: NEG
84477: PUSH
84478: EMPTY
84479: LIST
84480: LIST
84481: PUSH
84482: LD_INT 1
84484: PUSH
84485: LD_INT 3
84487: NEG
84488: PUSH
84489: EMPTY
84490: LIST
84491: LIST
84492: PUSH
84493: LD_INT 0
84495: PUSH
84496: LD_INT 3
84498: NEG
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: PUSH
84504: LD_INT 1
84506: NEG
84507: PUSH
84508: LD_INT 4
84510: NEG
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: PUSH
84516: LD_INT 1
84518: NEG
84519: PUSH
84520: LD_INT 5
84522: NEG
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_INT 2
84530: PUSH
84531: LD_INT 3
84533: NEG
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: PUSH
84539: LD_INT 2
84541: NEG
84542: PUSH
84543: LD_INT 5
84545: NEG
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: LIST
84555: LIST
84556: LIST
84557: LIST
84558: LIST
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
84598: LD_ADDR_VAR 0 31
84602: PUSH
84603: LD_INT 0
84605: PUSH
84606: LD_INT 4
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 0
84615: PUSH
84616: LD_INT 3
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 1
84625: PUSH
84626: LD_INT 4
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 1
84635: PUSH
84636: LD_INT 5
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 0
84645: PUSH
84646: LD_INT 5
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 1
84655: NEG
84656: PUSH
84657: LD_INT 4
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 1
84666: NEG
84667: PUSH
84668: LD_INT 3
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 2
84677: PUSH
84678: LD_INT 5
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: PUSH
84685: LD_INT 2
84687: NEG
84688: PUSH
84689: LD_INT 3
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 3
84698: NEG
84699: PUSH
84700: LD_INT 0
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 3
84709: NEG
84710: PUSH
84711: LD_INT 1
84713: NEG
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 2
84721: NEG
84722: PUSH
84723: LD_INT 0
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: PUSH
84730: LD_INT 2
84732: NEG
84733: PUSH
84734: LD_INT 1
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: LD_INT 3
84743: NEG
84744: PUSH
84745: LD_INT 1
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 4
84754: NEG
84755: PUSH
84756: LD_INT 0
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 4
84765: NEG
84766: PUSH
84767: LD_INT 1
84769: NEG
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 4
84777: NEG
84778: PUSH
84779: LD_INT 2
84781: NEG
84782: PUSH
84783: EMPTY
84784: LIST
84785: LIST
84786: PUSH
84787: LD_INT 2
84789: NEG
84790: PUSH
84791: LD_INT 2
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: PUSH
84798: LD_INT 4
84800: NEG
84801: PUSH
84802: LD_INT 4
84804: NEG
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: PUSH
84810: LD_INT 4
84812: NEG
84813: PUSH
84814: LD_INT 5
84816: NEG
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 3
84824: NEG
84825: PUSH
84826: LD_INT 4
84828: NEG
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: PUSH
84834: LD_INT 3
84836: NEG
84837: PUSH
84838: LD_INT 3
84840: NEG
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 4
84848: NEG
84849: PUSH
84850: LD_INT 3
84852: NEG
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 5
84860: NEG
84861: PUSH
84862: LD_INT 4
84864: NEG
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: PUSH
84870: LD_INT 5
84872: NEG
84873: PUSH
84874: LD_INT 5
84876: NEG
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PUSH
84882: LD_INT 3
84884: NEG
84885: PUSH
84886: LD_INT 5
84888: NEG
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 5
84896: NEG
84897: PUSH
84898: LD_INT 3
84900: NEG
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 0
84908: PUSH
84909: LD_INT 3
84911: NEG
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 0
84919: PUSH
84920: LD_INT 4
84922: NEG
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 1
84930: PUSH
84931: LD_INT 3
84933: NEG
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 1
84941: PUSH
84942: LD_INT 2
84944: NEG
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: LD_INT 2
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 1
84963: NEG
84964: PUSH
84965: LD_INT 3
84967: NEG
84968: PUSH
84969: EMPTY
84970: LIST
84971: LIST
84972: PUSH
84973: LD_INT 1
84975: NEG
84976: PUSH
84977: LD_INT 4
84979: NEG
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 2
84987: PUSH
84988: LD_INT 2
84990: NEG
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: PUSH
84996: LD_INT 2
84998: NEG
84999: PUSH
85000: LD_INT 4
85002: NEG
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 4
85010: PUSH
85011: LD_INT 0
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 4
85020: PUSH
85021: LD_INT 1
85023: NEG
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 5
85031: PUSH
85032: LD_INT 0
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 5
85041: PUSH
85042: LD_INT 1
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: LD_INT 4
85051: PUSH
85052: LD_INT 1
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 3
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 3
85071: PUSH
85072: LD_INT 1
85074: NEG
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 3
85082: PUSH
85083: LD_INT 2
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 5
85093: PUSH
85094: LD_INT 2
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: LIST
85145: LIST
85146: LIST
85147: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
85148: LD_ADDR_VAR 0 32
85152: PUSH
85153: LD_INT 4
85155: NEG
85156: PUSH
85157: LD_INT 0
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 4
85166: NEG
85167: PUSH
85168: LD_INT 1
85170: NEG
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 3
85178: NEG
85179: PUSH
85180: LD_INT 0
85182: PUSH
85183: EMPTY
85184: LIST
85185: LIST
85186: PUSH
85187: LD_INT 3
85189: NEG
85190: PUSH
85191: LD_INT 1
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: PUSH
85198: LD_INT 4
85200: NEG
85201: PUSH
85202: LD_INT 1
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: PUSH
85209: LD_INT 5
85211: NEG
85212: PUSH
85213: LD_INT 0
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: PUSH
85220: LD_INT 5
85222: NEG
85223: PUSH
85224: LD_INT 1
85226: NEG
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 5
85234: NEG
85235: PUSH
85236: LD_INT 2
85238: NEG
85239: PUSH
85240: EMPTY
85241: LIST
85242: LIST
85243: PUSH
85244: LD_INT 3
85246: NEG
85247: PUSH
85248: LD_INT 2
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 3
85257: NEG
85258: PUSH
85259: LD_INT 3
85261: NEG
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_INT 3
85269: NEG
85270: PUSH
85271: LD_INT 4
85273: NEG
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 2
85281: NEG
85282: PUSH
85283: LD_INT 3
85285: NEG
85286: PUSH
85287: EMPTY
85288: LIST
85289: LIST
85290: PUSH
85291: LD_INT 2
85293: NEG
85294: PUSH
85295: LD_INT 2
85297: NEG
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: PUSH
85303: LD_INT 3
85305: NEG
85306: PUSH
85307: LD_INT 2
85309: NEG
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: LD_INT 4
85317: NEG
85318: PUSH
85319: LD_INT 3
85321: NEG
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 4
85329: NEG
85330: PUSH
85331: LD_INT 4
85333: NEG
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 2
85341: NEG
85342: PUSH
85343: LD_INT 4
85345: NEG
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: LD_INT 4
85353: NEG
85354: PUSH
85355: LD_INT 2
85357: NEG
85358: PUSH
85359: EMPTY
85360: LIST
85361: LIST
85362: PUSH
85363: LD_INT 0
85365: PUSH
85366: LD_INT 4
85368: NEG
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 0
85376: PUSH
85377: LD_INT 5
85379: NEG
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 1
85387: PUSH
85388: LD_INT 4
85390: NEG
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: PUSH
85399: LD_INT 3
85401: NEG
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 0
85409: PUSH
85410: LD_INT 3
85412: NEG
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 1
85420: NEG
85421: PUSH
85422: LD_INT 4
85424: NEG
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 1
85432: NEG
85433: PUSH
85434: LD_INT 5
85436: NEG
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 2
85444: PUSH
85445: LD_INT 3
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 2
85455: NEG
85456: PUSH
85457: LD_INT 5
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 3
85467: PUSH
85468: LD_INT 0
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 3
85477: PUSH
85478: LD_INT 1
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 4
85488: PUSH
85489: LD_INT 0
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: LD_INT 4
85498: PUSH
85499: LD_INT 1
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 3
85508: PUSH
85509: LD_INT 1
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 2
85518: PUSH
85519: LD_INT 0
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: LD_INT 2
85528: PUSH
85529: LD_INT 1
85531: NEG
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 2
85539: PUSH
85540: LD_INT 2
85542: NEG
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 4
85550: PUSH
85551: LD_INT 2
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 4
85560: PUSH
85561: LD_INT 4
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PUSH
85568: LD_INT 4
85570: PUSH
85571: LD_INT 3
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 5
85580: PUSH
85581: LD_INT 4
85583: PUSH
85584: EMPTY
85585: LIST
85586: LIST
85587: PUSH
85588: LD_INT 5
85590: PUSH
85591: LD_INT 5
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: LD_INT 4
85600: PUSH
85601: LD_INT 5
85603: PUSH
85604: EMPTY
85605: LIST
85606: LIST
85607: PUSH
85608: LD_INT 3
85610: PUSH
85611: LD_INT 4
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 3
85620: PUSH
85621: LD_INT 3
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: PUSH
85628: LD_INT 5
85630: PUSH
85631: LD_INT 3
85633: PUSH
85634: EMPTY
85635: LIST
85636: LIST
85637: PUSH
85638: LD_INT 3
85640: PUSH
85641: LD_INT 5
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: LIST
85657: LIST
85658: LIST
85659: LIST
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
85695: LD_ADDR_VAR 0 33
85699: PUSH
85700: LD_INT 4
85702: NEG
85703: PUSH
85704: LD_INT 4
85706: NEG
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 4
85714: NEG
85715: PUSH
85716: LD_INT 5
85718: NEG
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PUSH
85724: LD_INT 3
85726: NEG
85727: PUSH
85728: LD_INT 4
85730: NEG
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 3
85738: NEG
85739: PUSH
85740: LD_INT 3
85742: NEG
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 4
85750: NEG
85751: PUSH
85752: LD_INT 3
85754: NEG
85755: PUSH
85756: EMPTY
85757: LIST
85758: LIST
85759: PUSH
85760: LD_INT 5
85762: NEG
85763: PUSH
85764: LD_INT 4
85766: NEG
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 5
85774: NEG
85775: PUSH
85776: LD_INT 5
85778: NEG
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: PUSH
85784: LD_INT 3
85786: NEG
85787: PUSH
85788: LD_INT 5
85790: NEG
85791: PUSH
85792: EMPTY
85793: LIST
85794: LIST
85795: PUSH
85796: LD_INT 5
85798: NEG
85799: PUSH
85800: LD_INT 3
85802: NEG
85803: PUSH
85804: EMPTY
85805: LIST
85806: LIST
85807: PUSH
85808: LD_INT 0
85810: PUSH
85811: LD_INT 3
85813: NEG
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: PUSH
85819: LD_INT 0
85821: PUSH
85822: LD_INT 4
85824: NEG
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 1
85832: PUSH
85833: LD_INT 3
85835: NEG
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PUSH
85841: LD_INT 1
85843: PUSH
85844: LD_INT 2
85846: NEG
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: PUSH
85852: LD_INT 0
85854: PUSH
85855: LD_INT 2
85857: NEG
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: PUSH
85863: LD_INT 1
85865: NEG
85866: PUSH
85867: LD_INT 3
85869: NEG
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 1
85877: NEG
85878: PUSH
85879: LD_INT 4
85881: NEG
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 2
85889: PUSH
85890: LD_INT 2
85892: NEG
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 2
85900: NEG
85901: PUSH
85902: LD_INT 4
85904: NEG
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 4
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 4
85922: PUSH
85923: LD_INT 1
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 5
85933: PUSH
85934: LD_INT 0
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 5
85943: PUSH
85944: LD_INT 1
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 4
85953: PUSH
85954: LD_INT 1
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 3
85963: PUSH
85964: LD_INT 0
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 3
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 3
85984: PUSH
85985: LD_INT 2
85987: NEG
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 5
85995: PUSH
85996: LD_INT 2
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 3
86005: PUSH
86006: LD_INT 3
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 3
86015: PUSH
86016: LD_INT 2
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 4
86025: PUSH
86026: LD_INT 3
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 4
86035: PUSH
86036: LD_INT 4
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 3
86045: PUSH
86046: LD_INT 4
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 2
86055: PUSH
86056: LD_INT 3
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 2
86065: PUSH
86066: LD_INT 2
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 4
86075: PUSH
86076: LD_INT 2
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 2
86085: PUSH
86086: LD_INT 4
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: LD_INT 4
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 0
86105: PUSH
86106: LD_INT 3
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: LD_INT 4
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: LD_INT 5
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 0
86135: PUSH
86136: LD_INT 5
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 1
86145: NEG
86146: PUSH
86147: LD_INT 4
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: LD_INT 1
86156: NEG
86157: PUSH
86158: LD_INT 3
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 2
86167: PUSH
86168: LD_INT 5
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: LD_INT 2
86177: NEG
86178: PUSH
86179: LD_INT 3
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
86233: LD_ADDR_VAR 0 34
86237: PUSH
86238: LD_INT 0
86240: PUSH
86241: LD_INT 4
86243: NEG
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 0
86251: PUSH
86252: LD_INT 5
86254: NEG
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 1
86262: PUSH
86263: LD_INT 4
86265: NEG
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 1
86273: PUSH
86274: LD_INT 3
86276: NEG
86277: PUSH
86278: EMPTY
86279: LIST
86280: LIST
86281: PUSH
86282: LD_INT 0
86284: PUSH
86285: LD_INT 3
86287: NEG
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: PUSH
86293: LD_INT 1
86295: NEG
86296: PUSH
86297: LD_INT 4
86299: NEG
86300: PUSH
86301: EMPTY
86302: LIST
86303: LIST
86304: PUSH
86305: LD_INT 1
86307: NEG
86308: PUSH
86309: LD_INT 5
86311: NEG
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: PUSH
86317: LD_INT 2
86319: PUSH
86320: LD_INT 3
86322: NEG
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: LD_INT 2
86330: NEG
86331: PUSH
86332: LD_INT 5
86334: NEG
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: PUSH
86340: LD_INT 3
86342: PUSH
86343: LD_INT 0
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 3
86352: PUSH
86353: LD_INT 1
86355: NEG
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PUSH
86361: LD_INT 4
86363: PUSH
86364: LD_INT 0
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 4
86373: PUSH
86374: LD_INT 1
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 3
86383: PUSH
86384: LD_INT 1
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 2
86393: PUSH
86394: LD_INT 0
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 2
86403: PUSH
86404: LD_INT 1
86406: NEG
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: LD_INT 2
86414: PUSH
86415: LD_INT 2
86417: NEG
86418: PUSH
86419: EMPTY
86420: LIST
86421: LIST
86422: PUSH
86423: LD_INT 4
86425: PUSH
86426: LD_INT 2
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: LD_INT 4
86435: PUSH
86436: LD_INT 4
86438: PUSH
86439: EMPTY
86440: LIST
86441: LIST
86442: PUSH
86443: LD_INT 4
86445: PUSH
86446: LD_INT 3
86448: PUSH
86449: EMPTY
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 5
86455: PUSH
86456: LD_INT 4
86458: PUSH
86459: EMPTY
86460: LIST
86461: LIST
86462: PUSH
86463: LD_INT 5
86465: PUSH
86466: LD_INT 5
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: PUSH
86473: LD_INT 4
86475: PUSH
86476: LD_INT 5
86478: PUSH
86479: EMPTY
86480: LIST
86481: LIST
86482: PUSH
86483: LD_INT 3
86485: PUSH
86486: LD_INT 4
86488: PUSH
86489: EMPTY
86490: LIST
86491: LIST
86492: PUSH
86493: LD_INT 3
86495: PUSH
86496: LD_INT 3
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 5
86505: PUSH
86506: LD_INT 3
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 3
86515: PUSH
86516: LD_INT 5
86518: PUSH
86519: EMPTY
86520: LIST
86521: LIST
86522: PUSH
86523: LD_INT 0
86525: PUSH
86526: LD_INT 3
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 0
86535: PUSH
86536: LD_INT 2
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: PUSH
86543: LD_INT 1
86545: PUSH
86546: LD_INT 3
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 1
86555: PUSH
86556: LD_INT 4
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: LD_INT 4
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 1
86575: NEG
86576: PUSH
86577: LD_INT 3
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 1
86586: NEG
86587: PUSH
86588: LD_INT 2
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 2
86597: PUSH
86598: LD_INT 4
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: LD_INT 2
86607: NEG
86608: PUSH
86609: LD_INT 2
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 4
86618: NEG
86619: PUSH
86620: LD_INT 0
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: PUSH
86627: LD_INT 4
86629: NEG
86630: PUSH
86631: LD_INT 1
86633: NEG
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 3
86641: NEG
86642: PUSH
86643: LD_INT 0
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: PUSH
86650: LD_INT 3
86652: NEG
86653: PUSH
86654: LD_INT 1
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: PUSH
86661: LD_INT 4
86663: NEG
86664: PUSH
86665: LD_INT 1
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 5
86674: NEG
86675: PUSH
86676: LD_INT 0
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: PUSH
86683: LD_INT 5
86685: NEG
86686: PUSH
86687: LD_INT 1
86689: NEG
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: PUSH
86695: LD_INT 5
86697: NEG
86698: PUSH
86699: LD_INT 2
86701: NEG
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: LD_INT 3
86709: NEG
86710: PUSH
86711: LD_INT 2
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: LIST
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: LIST
86758: LIST
86759: LIST
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: ST_TO_ADDR
// end ; end ;
86765: GO 86768
86767: POP
// case btype of b_depot , b_warehouse :
86768: LD_VAR 0 1
86772: PUSH
86773: LD_INT 0
86775: DOUBLE
86776: EQUAL
86777: IFTRUE 86787
86779: LD_INT 1
86781: DOUBLE
86782: EQUAL
86783: IFTRUE 86787
86785: GO 86988
86787: POP
// case nation of nation_american :
86788: LD_VAR 0 5
86792: PUSH
86793: LD_INT 1
86795: DOUBLE
86796: EQUAL
86797: IFTRUE 86801
86799: GO 86857
86801: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
86802: LD_ADDR_VAR 0 9
86806: PUSH
86807: LD_VAR 0 11
86811: PUSH
86812: LD_VAR 0 12
86816: PUSH
86817: LD_VAR 0 13
86821: PUSH
86822: LD_VAR 0 14
86826: PUSH
86827: LD_VAR 0 15
86831: PUSH
86832: LD_VAR 0 16
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: LIST
86841: LIST
86842: LIST
86843: LIST
86844: PUSH
86845: LD_VAR 0 4
86849: PUSH
86850: LD_INT 1
86852: PLUS
86853: ARRAY
86854: ST_TO_ADDR
86855: GO 86986
86857: LD_INT 2
86859: DOUBLE
86860: EQUAL
86861: IFTRUE 86865
86863: GO 86921
86865: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
86866: LD_ADDR_VAR 0 9
86870: PUSH
86871: LD_VAR 0 17
86875: PUSH
86876: LD_VAR 0 18
86880: PUSH
86881: LD_VAR 0 19
86885: PUSH
86886: LD_VAR 0 20
86890: PUSH
86891: LD_VAR 0 21
86895: PUSH
86896: LD_VAR 0 22
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: PUSH
86909: LD_VAR 0 4
86913: PUSH
86914: LD_INT 1
86916: PLUS
86917: ARRAY
86918: ST_TO_ADDR
86919: GO 86986
86921: LD_INT 3
86923: DOUBLE
86924: EQUAL
86925: IFTRUE 86929
86927: GO 86985
86929: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
86930: LD_ADDR_VAR 0 9
86934: PUSH
86935: LD_VAR 0 23
86939: PUSH
86940: LD_VAR 0 24
86944: PUSH
86945: LD_VAR 0 25
86949: PUSH
86950: LD_VAR 0 26
86954: PUSH
86955: LD_VAR 0 27
86959: PUSH
86960: LD_VAR 0 28
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: PUSH
86973: LD_VAR 0 4
86977: PUSH
86978: LD_INT 1
86980: PLUS
86981: ARRAY
86982: ST_TO_ADDR
86983: GO 86986
86985: POP
86986: GO 87541
86988: LD_INT 2
86990: DOUBLE
86991: EQUAL
86992: IFTRUE 87002
86994: LD_INT 3
86996: DOUBLE
86997: EQUAL
86998: IFTRUE 87002
87000: GO 87058
87002: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
87003: LD_ADDR_VAR 0 9
87007: PUSH
87008: LD_VAR 0 29
87012: PUSH
87013: LD_VAR 0 30
87017: PUSH
87018: LD_VAR 0 31
87022: PUSH
87023: LD_VAR 0 32
87027: PUSH
87028: LD_VAR 0 33
87032: PUSH
87033: LD_VAR 0 34
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: PUSH
87046: LD_VAR 0 4
87050: PUSH
87051: LD_INT 1
87053: PLUS
87054: ARRAY
87055: ST_TO_ADDR
87056: GO 87541
87058: LD_INT 16
87060: DOUBLE
87061: EQUAL
87062: IFTRUE 87120
87064: LD_INT 17
87066: DOUBLE
87067: EQUAL
87068: IFTRUE 87120
87070: LD_INT 18
87072: DOUBLE
87073: EQUAL
87074: IFTRUE 87120
87076: LD_INT 19
87078: DOUBLE
87079: EQUAL
87080: IFTRUE 87120
87082: LD_INT 22
87084: DOUBLE
87085: EQUAL
87086: IFTRUE 87120
87088: LD_INT 20
87090: DOUBLE
87091: EQUAL
87092: IFTRUE 87120
87094: LD_INT 21
87096: DOUBLE
87097: EQUAL
87098: IFTRUE 87120
87100: LD_INT 23
87102: DOUBLE
87103: EQUAL
87104: IFTRUE 87120
87106: LD_INT 24
87108: DOUBLE
87109: EQUAL
87110: IFTRUE 87120
87112: LD_INT 25
87114: DOUBLE
87115: EQUAL
87116: IFTRUE 87120
87118: GO 87176
87120: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
87121: LD_ADDR_VAR 0 9
87125: PUSH
87126: LD_VAR 0 35
87130: PUSH
87131: LD_VAR 0 36
87135: PUSH
87136: LD_VAR 0 37
87140: PUSH
87141: LD_VAR 0 38
87145: PUSH
87146: LD_VAR 0 39
87150: PUSH
87151: LD_VAR 0 40
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: PUSH
87164: LD_VAR 0 4
87168: PUSH
87169: LD_INT 1
87171: PLUS
87172: ARRAY
87173: ST_TO_ADDR
87174: GO 87541
87176: LD_INT 6
87178: DOUBLE
87179: EQUAL
87180: IFTRUE 87232
87182: LD_INT 7
87184: DOUBLE
87185: EQUAL
87186: IFTRUE 87232
87188: LD_INT 8
87190: DOUBLE
87191: EQUAL
87192: IFTRUE 87232
87194: LD_INT 13
87196: DOUBLE
87197: EQUAL
87198: IFTRUE 87232
87200: LD_INT 12
87202: DOUBLE
87203: EQUAL
87204: IFTRUE 87232
87206: LD_INT 15
87208: DOUBLE
87209: EQUAL
87210: IFTRUE 87232
87212: LD_INT 11
87214: DOUBLE
87215: EQUAL
87216: IFTRUE 87232
87218: LD_INT 14
87220: DOUBLE
87221: EQUAL
87222: IFTRUE 87232
87224: LD_INT 10
87226: DOUBLE
87227: EQUAL
87228: IFTRUE 87232
87230: GO 87288
87232: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
87233: LD_ADDR_VAR 0 9
87237: PUSH
87238: LD_VAR 0 41
87242: PUSH
87243: LD_VAR 0 42
87247: PUSH
87248: LD_VAR 0 43
87252: PUSH
87253: LD_VAR 0 44
87257: PUSH
87258: LD_VAR 0 45
87262: PUSH
87263: LD_VAR 0 46
87267: PUSH
87268: EMPTY
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: PUSH
87276: LD_VAR 0 4
87280: PUSH
87281: LD_INT 1
87283: PLUS
87284: ARRAY
87285: ST_TO_ADDR
87286: GO 87541
87288: LD_INT 36
87290: DOUBLE
87291: EQUAL
87292: IFTRUE 87296
87294: GO 87352
87296: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
87297: LD_ADDR_VAR 0 9
87301: PUSH
87302: LD_VAR 0 47
87306: PUSH
87307: LD_VAR 0 48
87311: PUSH
87312: LD_VAR 0 49
87316: PUSH
87317: LD_VAR 0 50
87321: PUSH
87322: LD_VAR 0 51
87326: PUSH
87327: LD_VAR 0 52
87331: PUSH
87332: EMPTY
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: PUSH
87340: LD_VAR 0 4
87344: PUSH
87345: LD_INT 1
87347: PLUS
87348: ARRAY
87349: ST_TO_ADDR
87350: GO 87541
87352: LD_INT 4
87354: DOUBLE
87355: EQUAL
87356: IFTRUE 87378
87358: LD_INT 5
87360: DOUBLE
87361: EQUAL
87362: IFTRUE 87378
87364: LD_INT 34
87366: DOUBLE
87367: EQUAL
87368: IFTRUE 87378
87370: LD_INT 37
87372: DOUBLE
87373: EQUAL
87374: IFTRUE 87378
87376: GO 87434
87378: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
87379: LD_ADDR_VAR 0 9
87383: PUSH
87384: LD_VAR 0 53
87388: PUSH
87389: LD_VAR 0 54
87393: PUSH
87394: LD_VAR 0 55
87398: PUSH
87399: LD_VAR 0 56
87403: PUSH
87404: LD_VAR 0 57
87408: PUSH
87409: LD_VAR 0 58
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: PUSH
87422: LD_VAR 0 4
87426: PUSH
87427: LD_INT 1
87429: PLUS
87430: ARRAY
87431: ST_TO_ADDR
87432: GO 87541
87434: LD_INT 31
87436: DOUBLE
87437: EQUAL
87438: IFTRUE 87484
87440: LD_INT 32
87442: DOUBLE
87443: EQUAL
87444: IFTRUE 87484
87446: LD_INT 33
87448: DOUBLE
87449: EQUAL
87450: IFTRUE 87484
87452: LD_INT 27
87454: DOUBLE
87455: EQUAL
87456: IFTRUE 87484
87458: LD_INT 26
87460: DOUBLE
87461: EQUAL
87462: IFTRUE 87484
87464: LD_INT 28
87466: DOUBLE
87467: EQUAL
87468: IFTRUE 87484
87470: LD_INT 29
87472: DOUBLE
87473: EQUAL
87474: IFTRUE 87484
87476: LD_INT 30
87478: DOUBLE
87479: EQUAL
87480: IFTRUE 87484
87482: GO 87540
87484: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
87485: LD_ADDR_VAR 0 9
87489: PUSH
87490: LD_VAR 0 59
87494: PUSH
87495: LD_VAR 0 60
87499: PUSH
87500: LD_VAR 0 61
87504: PUSH
87505: LD_VAR 0 62
87509: PUSH
87510: LD_VAR 0 63
87514: PUSH
87515: LD_VAR 0 64
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: PUSH
87528: LD_VAR 0 4
87532: PUSH
87533: LD_INT 1
87535: PLUS
87536: ARRAY
87537: ST_TO_ADDR
87538: GO 87541
87540: POP
// temp_list2 = [ ] ;
87541: LD_ADDR_VAR 0 10
87545: PUSH
87546: EMPTY
87547: ST_TO_ADDR
// for i in temp_list do
87548: LD_ADDR_VAR 0 8
87552: PUSH
87553: LD_VAR 0 9
87557: PUSH
87558: FOR_IN
87559: IFFALSE 87611
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
87561: LD_ADDR_VAR 0 10
87565: PUSH
87566: LD_VAR 0 10
87570: PUSH
87571: LD_VAR 0 8
87575: PUSH
87576: LD_INT 1
87578: ARRAY
87579: PUSH
87580: LD_VAR 0 2
87584: PLUS
87585: PUSH
87586: LD_VAR 0 8
87590: PUSH
87591: LD_INT 2
87593: ARRAY
87594: PUSH
87595: LD_VAR 0 3
87599: PLUS
87600: PUSH
87601: EMPTY
87602: LIST
87603: LIST
87604: PUSH
87605: EMPTY
87606: LIST
87607: ADD
87608: ST_TO_ADDR
87609: GO 87558
87611: POP
87612: POP
// result = temp_list2 ;
87613: LD_ADDR_VAR 0 7
87617: PUSH
87618: LD_VAR 0 10
87622: ST_TO_ADDR
// end ;
87623: LD_VAR 0 7
87627: RET
// export function EnemyInRange ( unit , dist ) ; begin
87628: LD_INT 0
87630: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
87631: LD_ADDR_VAR 0 3
87635: PUSH
87636: LD_VAR 0 1
87640: PPUSH
87641: CALL_OW 255
87645: PPUSH
87646: LD_VAR 0 1
87650: PPUSH
87651: CALL_OW 250
87655: PPUSH
87656: LD_VAR 0 1
87660: PPUSH
87661: CALL_OW 251
87665: PPUSH
87666: LD_VAR 0 2
87670: PPUSH
87671: CALL 60885 0 4
87675: PUSH
87676: LD_INT 4
87678: ARRAY
87679: ST_TO_ADDR
// end ;
87680: LD_VAR 0 3
87684: RET
// export function PlayerSeeMe ( unit ) ; begin
87685: LD_INT 0
87687: PPUSH
// result := See ( your_side , unit ) ;
87688: LD_ADDR_VAR 0 2
87692: PUSH
87693: LD_OWVAR 2
87697: PPUSH
87698: LD_VAR 0 1
87702: PPUSH
87703: CALL_OW 292
87707: ST_TO_ADDR
// end ;
87708: LD_VAR 0 2
87712: RET
// export function ReverseDir ( unit ) ; begin
87713: LD_INT 0
87715: PPUSH
// if not unit then
87716: LD_VAR 0 1
87720: NOT
87721: IFFALSE 87725
// exit ;
87723: GO 87748
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
87725: LD_ADDR_VAR 0 2
87729: PUSH
87730: LD_VAR 0 1
87734: PPUSH
87735: CALL_OW 254
87739: PUSH
87740: LD_INT 3
87742: PLUS
87743: PUSH
87744: LD_INT 6
87746: MOD
87747: ST_TO_ADDR
// end ;
87748: LD_VAR 0 2
87752: RET
// export function ReverseArray ( array ) ; var i ; begin
87753: LD_INT 0
87755: PPUSH
87756: PPUSH
// if not array then
87757: LD_VAR 0 1
87761: NOT
87762: IFFALSE 87766
// exit ;
87764: GO 87821
// result := [ ] ;
87766: LD_ADDR_VAR 0 2
87770: PUSH
87771: EMPTY
87772: ST_TO_ADDR
// for i := array downto 1 do
87773: LD_ADDR_VAR 0 3
87777: PUSH
87778: DOUBLE
87779: LD_VAR 0 1
87783: INC
87784: ST_TO_ADDR
87785: LD_INT 1
87787: PUSH
87788: FOR_DOWNTO
87789: IFFALSE 87819
// result := Join ( result , array [ i ] ) ;
87791: LD_ADDR_VAR 0 2
87795: PUSH
87796: LD_VAR 0 2
87800: PPUSH
87801: LD_VAR 0 1
87805: PUSH
87806: LD_VAR 0 3
87810: ARRAY
87811: PPUSH
87812: CALL 92673 0 2
87816: ST_TO_ADDR
87817: GO 87788
87819: POP
87820: POP
// end ;
87821: LD_VAR 0 2
87825: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
87826: LD_INT 0
87828: PPUSH
87829: PPUSH
87830: PPUSH
87831: PPUSH
87832: PPUSH
87833: PPUSH
// if not unit or not hexes then
87834: LD_VAR 0 1
87838: NOT
87839: IFTRUE 87848
87841: PUSH
87842: LD_VAR 0 2
87846: NOT
87847: OR
87848: IFFALSE 87852
// exit ;
87850: GO 87975
// dist := 9999 ;
87852: LD_ADDR_VAR 0 5
87856: PUSH
87857: LD_INT 9999
87859: ST_TO_ADDR
// for i = 1 to hexes do
87860: LD_ADDR_VAR 0 4
87864: PUSH
87865: DOUBLE
87866: LD_INT 1
87868: DEC
87869: ST_TO_ADDR
87870: LD_VAR 0 2
87874: PUSH
87875: FOR_TO
87876: IFFALSE 87963
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
87878: LD_ADDR_VAR 0 6
87882: PUSH
87883: LD_VAR 0 1
87887: PPUSH
87888: LD_VAR 0 2
87892: PUSH
87893: LD_VAR 0 4
87897: ARRAY
87898: PUSH
87899: LD_INT 1
87901: ARRAY
87902: PPUSH
87903: LD_VAR 0 2
87907: PUSH
87908: LD_VAR 0 4
87912: ARRAY
87913: PUSH
87914: LD_INT 2
87916: ARRAY
87917: PPUSH
87918: CALL_OW 297
87922: ST_TO_ADDR
// if tdist < dist then
87923: LD_VAR 0 6
87927: PUSH
87928: LD_VAR 0 5
87932: LESS
87933: IFFALSE 87961
// begin hex := hexes [ i ] ;
87935: LD_ADDR_VAR 0 8
87939: PUSH
87940: LD_VAR 0 2
87944: PUSH
87945: LD_VAR 0 4
87949: ARRAY
87950: ST_TO_ADDR
// dist := tdist ;
87951: LD_ADDR_VAR 0 5
87955: PUSH
87956: LD_VAR 0 6
87960: ST_TO_ADDR
// end ; end ;
87961: GO 87875
87963: POP
87964: POP
// result := hex ;
87965: LD_ADDR_VAR 0 3
87969: PUSH
87970: LD_VAR 0 8
87974: ST_TO_ADDR
// end ;
87975: LD_VAR 0 3
87979: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
87980: LD_INT 0
87982: PPUSH
87983: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87984: LD_VAR 0 1
87988: NOT
87989: IFTRUE 88028
87991: PUSH
87992: LD_VAR 0 1
87996: PUSH
87997: LD_INT 21
87999: PUSH
88000: LD_INT 2
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: LD_INT 23
88009: PUSH
88010: LD_INT 2
88012: PUSH
88013: EMPTY
88014: LIST
88015: LIST
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PPUSH
88021: CALL_OW 69
88025: IN
88026: NOT
88027: OR
88028: IFFALSE 88032
// exit ;
88030: GO 88079
// for i = 1 to 3 do
88032: LD_ADDR_VAR 0 3
88036: PUSH
88037: DOUBLE
88038: LD_INT 1
88040: DEC
88041: ST_TO_ADDR
88042: LD_INT 3
88044: PUSH
88045: FOR_TO
88046: IFFALSE 88077
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
88048: LD_VAR 0 1
88052: PPUSH
88053: CALL_OW 250
88057: PPUSH
88058: LD_VAR 0 1
88062: PPUSH
88063: CALL_OW 251
88067: PPUSH
88068: LD_INT 1
88070: PPUSH
88071: CALL_OW 453
88075: GO 88045
88077: POP
88078: POP
// end ;
88079: LD_VAR 0 2
88083: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
88084: LD_INT 0
88086: PPUSH
88087: PPUSH
88088: PPUSH
88089: PPUSH
88090: PPUSH
88091: PPUSH
// if not unit or not enemy_unit then
88092: LD_VAR 0 1
88096: NOT
88097: IFTRUE 88106
88099: PUSH
88100: LD_VAR 0 2
88104: NOT
88105: OR
88106: IFFALSE 88110
// exit ;
88108: GO 88591
// if GetLives ( i ) < 250 then
88110: LD_VAR 0 4
88114: PPUSH
88115: CALL_OW 256
88119: PUSH
88120: LD_INT 250
88122: LESS
88123: IFFALSE 88136
// begin ComAutodestruct ( i ) ;
88125: LD_VAR 0 4
88129: PPUSH
88130: CALL 87980 0 1
// exit ;
88134: GO 88591
// end ; x := GetX ( enemy_unit ) ;
88136: LD_ADDR_VAR 0 7
88140: PUSH
88141: LD_VAR 0 2
88145: PPUSH
88146: CALL_OW 250
88150: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
88151: LD_ADDR_VAR 0 8
88155: PUSH
88156: LD_VAR 0 2
88160: PPUSH
88161: CALL_OW 251
88165: ST_TO_ADDR
// if not x or not y then
88166: LD_VAR 0 7
88170: NOT
88171: IFTRUE 88180
88173: PUSH
88174: LD_VAR 0 8
88178: NOT
88179: OR
88180: IFFALSE 88184
// exit ;
88182: GO 88591
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
88184: LD_ADDR_VAR 0 6
88188: PUSH
88189: LD_VAR 0 7
88193: PPUSH
88194: LD_INT 0
88196: PPUSH
88197: LD_INT 4
88199: PPUSH
88200: CALL_OW 272
88204: PUSH
88205: LD_VAR 0 8
88209: PPUSH
88210: LD_INT 0
88212: PPUSH
88213: LD_INT 4
88215: PPUSH
88216: CALL_OW 273
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: PUSH
88225: LD_VAR 0 7
88229: PPUSH
88230: LD_INT 1
88232: PPUSH
88233: LD_INT 4
88235: PPUSH
88236: CALL_OW 272
88240: PUSH
88241: LD_VAR 0 8
88245: PPUSH
88246: LD_INT 1
88248: PPUSH
88249: LD_INT 4
88251: PPUSH
88252: CALL_OW 273
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: LD_VAR 0 7
88265: PPUSH
88266: LD_INT 2
88268: PPUSH
88269: LD_INT 4
88271: PPUSH
88272: CALL_OW 272
88276: PUSH
88277: LD_VAR 0 8
88281: PPUSH
88282: LD_INT 2
88284: PPUSH
88285: LD_INT 4
88287: PPUSH
88288: CALL_OW 273
88292: PUSH
88293: EMPTY
88294: LIST
88295: LIST
88296: PUSH
88297: LD_VAR 0 7
88301: PPUSH
88302: LD_INT 3
88304: PPUSH
88305: LD_INT 4
88307: PPUSH
88308: CALL_OW 272
88312: PUSH
88313: LD_VAR 0 8
88317: PPUSH
88318: LD_INT 3
88320: PPUSH
88321: LD_INT 4
88323: PPUSH
88324: CALL_OW 273
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: LD_VAR 0 7
88337: PPUSH
88338: LD_INT 4
88340: PPUSH
88341: LD_INT 4
88343: PPUSH
88344: CALL_OW 272
88348: PUSH
88349: LD_VAR 0 8
88353: PPUSH
88354: LD_INT 4
88356: PPUSH
88357: LD_INT 4
88359: PPUSH
88360: CALL_OW 273
88364: PUSH
88365: EMPTY
88366: LIST
88367: LIST
88368: PUSH
88369: LD_VAR 0 7
88373: PPUSH
88374: LD_INT 5
88376: PPUSH
88377: LD_INT 4
88379: PPUSH
88380: CALL_OW 272
88384: PUSH
88385: LD_VAR 0 8
88389: PPUSH
88390: LD_INT 5
88392: PPUSH
88393: LD_INT 4
88395: PPUSH
88396: CALL_OW 273
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: ST_TO_ADDR
// for i = tmp downto 1 do
88413: LD_ADDR_VAR 0 4
88417: PUSH
88418: DOUBLE
88419: LD_VAR 0 6
88423: INC
88424: ST_TO_ADDR
88425: LD_INT 1
88427: PUSH
88428: FOR_DOWNTO
88429: IFFALSE 88532
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
88431: LD_VAR 0 6
88435: PUSH
88436: LD_VAR 0 4
88440: ARRAY
88441: PUSH
88442: LD_INT 1
88444: ARRAY
88445: PPUSH
88446: LD_VAR 0 6
88450: PUSH
88451: LD_VAR 0 4
88455: ARRAY
88456: PUSH
88457: LD_INT 2
88459: ARRAY
88460: PPUSH
88461: CALL_OW 488
88465: NOT
88466: IFTRUE 88508
88468: PUSH
88469: LD_VAR 0 6
88473: PUSH
88474: LD_VAR 0 4
88478: ARRAY
88479: PUSH
88480: LD_INT 1
88482: ARRAY
88483: PPUSH
88484: LD_VAR 0 6
88488: PUSH
88489: LD_VAR 0 4
88493: ARRAY
88494: PUSH
88495: LD_INT 2
88497: ARRAY
88498: PPUSH
88499: CALL_OW 428
88503: PUSH
88504: LD_INT 0
88506: NONEQUAL
88507: OR
88508: IFFALSE 88530
// tmp := Delete ( tmp , i ) ;
88510: LD_ADDR_VAR 0 6
88514: PUSH
88515: LD_VAR 0 6
88519: PPUSH
88520: LD_VAR 0 4
88524: PPUSH
88525: CALL_OW 3
88529: ST_TO_ADDR
88530: GO 88428
88532: POP
88533: POP
// j := GetClosestHex ( unit , tmp ) ;
88534: LD_ADDR_VAR 0 5
88538: PUSH
88539: LD_VAR 0 1
88543: PPUSH
88544: LD_VAR 0 6
88548: PPUSH
88549: CALL 87826 0 2
88553: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
88554: LD_VAR 0 1
88558: PPUSH
88559: LD_VAR 0 5
88563: PUSH
88564: LD_INT 1
88566: ARRAY
88567: PPUSH
88568: LD_VAR 0 5
88572: PUSH
88573: LD_INT 2
88575: ARRAY
88576: PPUSH
88577: CALL_OW 111
// result := j ;
88581: LD_ADDR_VAR 0 3
88585: PUSH
88586: LD_VAR 0 5
88590: ST_TO_ADDR
// end ;
88591: LD_VAR 0 3
88595: RET
// export function PrepareApemanSoldier ( ) ; begin
88596: LD_INT 0
88598: PPUSH
// uc_nation := 0 ;
88599: LD_ADDR_OWVAR 21
88603: PUSH
88604: LD_INT 0
88606: ST_TO_ADDR
// hc_sex := sex_male ;
88607: LD_ADDR_OWVAR 27
88611: PUSH
88612: LD_INT 1
88614: ST_TO_ADDR
// hc_name :=  ;
88615: LD_ADDR_OWVAR 26
88619: PUSH
88620: LD_STRING 
88622: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
88623: LD_ADDR_OWVAR 28
88627: PUSH
88628: LD_INT 15
88630: ST_TO_ADDR
// hc_gallery :=  ;
88631: LD_ADDR_OWVAR 33
88635: PUSH
88636: LD_STRING 
88638: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
88639: LD_ADDR_OWVAR 31
88643: PUSH
88644: LD_INT 0
88646: PPUSH
88647: LD_INT 3
88649: PPUSH
88650: CALL_OW 12
88654: PUSH
88655: LD_INT 0
88657: PPUSH
88658: LD_INT 3
88660: PPUSH
88661: CALL_OW 12
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: LD_INT 0
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
88678: LD_ADDR_OWVAR 29
88682: PUSH
88683: LD_INT 10
88685: PUSH
88686: LD_INT 12
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: ST_TO_ADDR
// end ;
88693: LD_VAR 0 1
88697: RET
// export function PrepareApemanEngineer ( ) ; begin
88698: LD_INT 0
88700: PPUSH
// uc_nation := 0 ;
88701: LD_ADDR_OWVAR 21
88705: PUSH
88706: LD_INT 0
88708: ST_TO_ADDR
// hc_sex := sex_male ;
88709: LD_ADDR_OWVAR 27
88713: PUSH
88714: LD_INT 1
88716: ST_TO_ADDR
// hc_name :=  ;
88717: LD_ADDR_OWVAR 26
88721: PUSH
88722: LD_STRING 
88724: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
88725: LD_ADDR_OWVAR 28
88729: PUSH
88730: LD_INT 16
88732: ST_TO_ADDR
// hc_gallery :=  ;
88733: LD_ADDR_OWVAR 33
88737: PUSH
88738: LD_STRING 
88740: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
88741: LD_ADDR_OWVAR 31
88745: PUSH
88746: LD_INT 0
88748: PPUSH
88749: LD_INT 3
88751: PPUSH
88752: CALL_OW 12
88756: PUSH
88757: LD_INT 0
88759: PPUSH
88760: LD_INT 3
88762: PPUSH
88763: CALL_OW 12
88767: PUSH
88768: LD_INT 0
88770: PUSH
88771: LD_INT 0
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
88780: LD_ADDR_OWVAR 29
88784: PUSH
88785: LD_INT 10
88787: PUSH
88788: LD_INT 12
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: ST_TO_ADDR
// end ;
88795: LD_VAR 0 1
88799: RET
// export function PrepareApeman ( agressivity ) ; begin
88800: LD_INT 0
88802: PPUSH
// uc_side := 0 ;
88803: LD_ADDR_OWVAR 20
88807: PUSH
88808: LD_INT 0
88810: ST_TO_ADDR
// uc_nation := 0 ;
88811: LD_ADDR_OWVAR 21
88815: PUSH
88816: LD_INT 0
88818: ST_TO_ADDR
// hc_sex := sex_male ;
88819: LD_ADDR_OWVAR 27
88823: PUSH
88824: LD_INT 1
88826: ST_TO_ADDR
// hc_class := class_apeman ;
88827: LD_ADDR_OWVAR 28
88831: PUSH
88832: LD_INT 12
88834: ST_TO_ADDR
// hc_gallery :=  ;
88835: LD_ADDR_OWVAR 33
88839: PUSH
88840: LD_STRING 
88842: ST_TO_ADDR
// hc_name :=  ;
88843: LD_ADDR_OWVAR 26
88847: PUSH
88848: LD_STRING 
88850: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
88851: LD_ADDR_OWVAR 29
88855: PUSH
88856: LD_INT 10
88858: PUSH
88859: LD_INT 12
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: ST_TO_ADDR
// if agressivity = 0 then
88866: LD_VAR 0 1
88870: PUSH
88871: LD_INT 0
88873: EQUAL
88874: IFFALSE 88886
// hc_agressivity := 0 else
88876: LD_ADDR_OWVAR 35
88880: PUSH
88881: LD_INT 0
88883: ST_TO_ADDR
88884: GO 88907
// hc_agressivity := rand ( - agressivity , agressivity ) ;
88886: LD_ADDR_OWVAR 35
88890: PUSH
88891: LD_VAR 0 1
88895: NEG
88896: PPUSH
88897: LD_VAR 0 1
88901: PPUSH
88902: CALL_OW 12
88906: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
88907: LD_ADDR_OWVAR 31
88911: PUSH
88912: LD_INT 0
88914: PPUSH
88915: LD_INT 3
88917: PPUSH
88918: CALL_OW 12
88922: PUSH
88923: LD_INT 0
88925: PPUSH
88926: LD_INT 3
88928: PPUSH
88929: CALL_OW 12
88933: PUSH
88934: LD_INT 0
88936: PUSH
88937: LD_INT 0
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: ST_TO_ADDR
// end ;
88946: LD_VAR 0 2
88950: RET
// export function PrepareTiger ( agressivity ) ; begin
88951: LD_INT 0
88953: PPUSH
// uc_side := 0 ;
88954: LD_ADDR_OWVAR 20
88958: PUSH
88959: LD_INT 0
88961: ST_TO_ADDR
// uc_nation := 0 ;
88962: LD_ADDR_OWVAR 21
88966: PUSH
88967: LD_INT 0
88969: ST_TO_ADDR
// InitHc ;
88970: CALL_OW 19
// hc_class := class_tiger ;
88974: LD_ADDR_OWVAR 28
88978: PUSH
88979: LD_INT 14
88981: ST_TO_ADDR
// hc_gallery :=  ;
88982: LD_ADDR_OWVAR 33
88986: PUSH
88987: LD_STRING 
88989: ST_TO_ADDR
// hc_name :=  ;
88990: LD_ADDR_OWVAR 26
88994: PUSH
88995: LD_STRING 
88997: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
88998: LD_ADDR_OWVAR 35
89002: PUSH
89003: LD_VAR 0 1
89007: NEG
89008: PPUSH
89009: LD_VAR 0 1
89013: PPUSH
89014: CALL_OW 12
89018: ST_TO_ADDR
// end ;
89019: LD_VAR 0 2
89023: RET
// export function PrepareEnchidna ( ) ; begin
89024: LD_INT 0
89026: PPUSH
// uc_side := 0 ;
89027: LD_ADDR_OWVAR 20
89031: PUSH
89032: LD_INT 0
89034: ST_TO_ADDR
// uc_nation := 0 ;
89035: LD_ADDR_OWVAR 21
89039: PUSH
89040: LD_INT 0
89042: ST_TO_ADDR
// InitHc ;
89043: CALL_OW 19
// hc_class := class_baggie ;
89047: LD_ADDR_OWVAR 28
89051: PUSH
89052: LD_INT 13
89054: ST_TO_ADDR
// hc_gallery :=  ;
89055: LD_ADDR_OWVAR 33
89059: PUSH
89060: LD_STRING 
89062: ST_TO_ADDR
// hc_name :=  ;
89063: LD_ADDR_OWVAR 26
89067: PUSH
89068: LD_STRING 
89070: ST_TO_ADDR
// end ;
89071: LD_VAR 0 1
89075: RET
// export function PrepareFrog ( ) ; begin
89076: LD_INT 0
89078: PPUSH
// uc_side := 0 ;
89079: LD_ADDR_OWVAR 20
89083: PUSH
89084: LD_INT 0
89086: ST_TO_ADDR
// uc_nation := 0 ;
89087: LD_ADDR_OWVAR 21
89091: PUSH
89092: LD_INT 0
89094: ST_TO_ADDR
// InitHc ;
89095: CALL_OW 19
// hc_class := class_frog ;
89099: LD_ADDR_OWVAR 28
89103: PUSH
89104: LD_INT 19
89106: ST_TO_ADDR
// hc_gallery :=  ;
89107: LD_ADDR_OWVAR 33
89111: PUSH
89112: LD_STRING 
89114: ST_TO_ADDR
// hc_name :=  ;
89115: LD_ADDR_OWVAR 26
89119: PUSH
89120: LD_STRING 
89122: ST_TO_ADDR
// end ;
89123: LD_VAR 0 1
89127: RET
// export function PrepareFish ( ) ; begin
89128: LD_INT 0
89130: PPUSH
// uc_side := 0 ;
89131: LD_ADDR_OWVAR 20
89135: PUSH
89136: LD_INT 0
89138: ST_TO_ADDR
// uc_nation := 0 ;
89139: LD_ADDR_OWVAR 21
89143: PUSH
89144: LD_INT 0
89146: ST_TO_ADDR
// InitHc ;
89147: CALL_OW 19
// hc_class := class_fish ;
89151: LD_ADDR_OWVAR 28
89155: PUSH
89156: LD_INT 20
89158: ST_TO_ADDR
// hc_gallery :=  ;
89159: LD_ADDR_OWVAR 33
89163: PUSH
89164: LD_STRING 
89166: ST_TO_ADDR
// hc_name :=  ;
89167: LD_ADDR_OWVAR 26
89171: PUSH
89172: LD_STRING 
89174: ST_TO_ADDR
// end ;
89175: LD_VAR 0 1
89179: RET
// export function PrepareBird ( ) ; begin
89180: LD_INT 0
89182: PPUSH
// uc_side := 0 ;
89183: LD_ADDR_OWVAR 20
89187: PUSH
89188: LD_INT 0
89190: ST_TO_ADDR
// uc_nation := 0 ;
89191: LD_ADDR_OWVAR 21
89195: PUSH
89196: LD_INT 0
89198: ST_TO_ADDR
// InitHc ;
89199: CALL_OW 19
// hc_class := class_phororhacos ;
89203: LD_ADDR_OWVAR 28
89207: PUSH
89208: LD_INT 18
89210: ST_TO_ADDR
// hc_gallery :=  ;
89211: LD_ADDR_OWVAR 33
89215: PUSH
89216: LD_STRING 
89218: ST_TO_ADDR
// hc_name :=  ;
89219: LD_ADDR_OWVAR 26
89223: PUSH
89224: LD_STRING 
89226: ST_TO_ADDR
// end ;
89227: LD_VAR 0 1
89231: RET
// export function PrepareHorse ( ) ; begin
89232: LD_INT 0
89234: PPUSH
// uc_side := 0 ;
89235: LD_ADDR_OWVAR 20
89239: PUSH
89240: LD_INT 0
89242: ST_TO_ADDR
// uc_nation := 0 ;
89243: LD_ADDR_OWVAR 21
89247: PUSH
89248: LD_INT 0
89250: ST_TO_ADDR
// InitHc ;
89251: CALL_OW 19
// hc_class := class_horse ;
89255: LD_ADDR_OWVAR 28
89259: PUSH
89260: LD_INT 21
89262: ST_TO_ADDR
// hc_gallery :=  ;
89263: LD_ADDR_OWVAR 33
89267: PUSH
89268: LD_STRING 
89270: ST_TO_ADDR
// hc_name :=  ;
89271: LD_ADDR_OWVAR 26
89275: PUSH
89276: LD_STRING 
89278: ST_TO_ADDR
// end ;
89279: LD_VAR 0 1
89283: RET
// export function PrepareMastodont ( ) ; begin
89284: LD_INT 0
89286: PPUSH
// uc_side := 0 ;
89287: LD_ADDR_OWVAR 20
89291: PUSH
89292: LD_INT 0
89294: ST_TO_ADDR
// uc_nation := 0 ;
89295: LD_ADDR_OWVAR 21
89299: PUSH
89300: LD_INT 0
89302: ST_TO_ADDR
// vc_chassis := class_mastodont ;
89303: LD_ADDR_OWVAR 37
89307: PUSH
89308: LD_INT 31
89310: ST_TO_ADDR
// vc_control := control_rider ;
89311: LD_ADDR_OWVAR 38
89315: PUSH
89316: LD_INT 4
89318: ST_TO_ADDR
// end ;
89319: LD_VAR 0 1
89323: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
89324: LD_INT 0
89326: PPUSH
89327: PPUSH
89328: PPUSH
// uc_side = 0 ;
89329: LD_ADDR_OWVAR 20
89333: PUSH
89334: LD_INT 0
89336: ST_TO_ADDR
// uc_nation = 0 ;
89337: LD_ADDR_OWVAR 21
89341: PUSH
89342: LD_INT 0
89344: ST_TO_ADDR
// InitHc_All ( ) ;
89345: CALL_OW 584
// InitVc ;
89349: CALL_OW 20
// if mastodonts then
89353: LD_VAR 0 6
89357: IFFALSE 89424
// for i = 1 to mastodonts do
89359: LD_ADDR_VAR 0 11
89363: PUSH
89364: DOUBLE
89365: LD_INT 1
89367: DEC
89368: ST_TO_ADDR
89369: LD_VAR 0 6
89373: PUSH
89374: FOR_TO
89375: IFFALSE 89422
// begin vc_chassis := 31 ;
89377: LD_ADDR_OWVAR 37
89381: PUSH
89382: LD_INT 31
89384: ST_TO_ADDR
// vc_control := control_rider ;
89385: LD_ADDR_OWVAR 38
89389: PUSH
89390: LD_INT 4
89392: ST_TO_ADDR
// animal := CreateVehicle ;
89393: LD_ADDR_VAR 0 12
89397: PUSH
89398: CALL_OW 45
89402: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89403: LD_VAR 0 12
89407: PPUSH
89408: LD_VAR 0 8
89412: PPUSH
89413: LD_INT 0
89415: PPUSH
89416: CALL 91566 0 3
// end ;
89420: GO 89374
89422: POP
89423: POP
// if horses then
89424: LD_VAR 0 5
89428: IFFALSE 89495
// for i = 1 to horses do
89430: LD_ADDR_VAR 0 11
89434: PUSH
89435: DOUBLE
89436: LD_INT 1
89438: DEC
89439: ST_TO_ADDR
89440: LD_VAR 0 5
89444: PUSH
89445: FOR_TO
89446: IFFALSE 89493
// begin hc_class := 21 ;
89448: LD_ADDR_OWVAR 28
89452: PUSH
89453: LD_INT 21
89455: ST_TO_ADDR
// hc_gallery :=  ;
89456: LD_ADDR_OWVAR 33
89460: PUSH
89461: LD_STRING 
89463: ST_TO_ADDR
// animal := CreateHuman ;
89464: LD_ADDR_VAR 0 12
89468: PUSH
89469: CALL_OW 44
89473: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89474: LD_VAR 0 12
89478: PPUSH
89479: LD_VAR 0 8
89483: PPUSH
89484: LD_INT 0
89486: PPUSH
89487: CALL 91566 0 3
// end ;
89491: GO 89445
89493: POP
89494: POP
// if birds then
89495: LD_VAR 0 1
89499: IFFALSE 89566
// for i = 1 to birds do
89501: LD_ADDR_VAR 0 11
89505: PUSH
89506: DOUBLE
89507: LD_INT 1
89509: DEC
89510: ST_TO_ADDR
89511: LD_VAR 0 1
89515: PUSH
89516: FOR_TO
89517: IFFALSE 89564
// begin hc_class := 18 ;
89519: LD_ADDR_OWVAR 28
89523: PUSH
89524: LD_INT 18
89526: ST_TO_ADDR
// hc_gallery =  ;
89527: LD_ADDR_OWVAR 33
89531: PUSH
89532: LD_STRING 
89534: ST_TO_ADDR
// animal := CreateHuman ;
89535: LD_ADDR_VAR 0 12
89539: PUSH
89540: CALL_OW 44
89544: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89545: LD_VAR 0 12
89549: PPUSH
89550: LD_VAR 0 8
89554: PPUSH
89555: LD_INT 0
89557: PPUSH
89558: CALL 91566 0 3
// end ;
89562: GO 89516
89564: POP
89565: POP
// if tigers then
89566: LD_VAR 0 2
89570: IFFALSE 89654
// for i = 1 to tigers do
89572: LD_ADDR_VAR 0 11
89576: PUSH
89577: DOUBLE
89578: LD_INT 1
89580: DEC
89581: ST_TO_ADDR
89582: LD_VAR 0 2
89586: PUSH
89587: FOR_TO
89588: IFFALSE 89652
// begin hc_class = class_tiger ;
89590: LD_ADDR_OWVAR 28
89594: PUSH
89595: LD_INT 14
89597: ST_TO_ADDR
// hc_gallery =  ;
89598: LD_ADDR_OWVAR 33
89602: PUSH
89603: LD_STRING 
89605: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
89606: LD_ADDR_OWVAR 35
89610: PUSH
89611: LD_INT 7
89613: NEG
89614: PPUSH
89615: LD_INT 7
89617: PPUSH
89618: CALL_OW 12
89622: ST_TO_ADDR
// animal := CreateHuman ;
89623: LD_ADDR_VAR 0 12
89627: PUSH
89628: CALL_OW 44
89632: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89633: LD_VAR 0 12
89637: PPUSH
89638: LD_VAR 0 8
89642: PPUSH
89643: LD_INT 0
89645: PPUSH
89646: CALL 91566 0 3
// end ;
89650: GO 89587
89652: POP
89653: POP
// if apemans then
89654: LD_VAR 0 3
89658: IFFALSE 89781
// for i = 1 to apemans do
89660: LD_ADDR_VAR 0 11
89664: PUSH
89665: DOUBLE
89666: LD_INT 1
89668: DEC
89669: ST_TO_ADDR
89670: LD_VAR 0 3
89674: PUSH
89675: FOR_TO
89676: IFFALSE 89779
// begin hc_class = class_apeman ;
89678: LD_ADDR_OWVAR 28
89682: PUSH
89683: LD_INT 12
89685: ST_TO_ADDR
// hc_gallery =  ;
89686: LD_ADDR_OWVAR 33
89690: PUSH
89691: LD_STRING 
89693: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
89694: LD_ADDR_OWVAR 35
89698: PUSH
89699: LD_INT 2
89701: NEG
89702: PPUSH
89703: LD_INT 2
89705: PPUSH
89706: CALL_OW 12
89710: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
89711: LD_ADDR_OWVAR 31
89715: PUSH
89716: LD_INT 1
89718: PPUSH
89719: LD_INT 3
89721: PPUSH
89722: CALL_OW 12
89726: PUSH
89727: LD_INT 1
89729: PPUSH
89730: LD_INT 3
89732: PPUSH
89733: CALL_OW 12
89737: PUSH
89738: LD_INT 0
89740: PUSH
89741: LD_INT 0
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: ST_TO_ADDR
// animal := CreateHuman ;
89750: LD_ADDR_VAR 0 12
89754: PUSH
89755: CALL_OW 44
89759: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89760: LD_VAR 0 12
89764: PPUSH
89765: LD_VAR 0 8
89769: PPUSH
89770: LD_INT 0
89772: PPUSH
89773: CALL 91566 0 3
// end ;
89777: GO 89675
89779: POP
89780: POP
// if enchidnas then
89781: LD_VAR 0 4
89785: IFFALSE 89852
// for i = 1 to enchidnas do
89787: LD_ADDR_VAR 0 11
89791: PUSH
89792: DOUBLE
89793: LD_INT 1
89795: DEC
89796: ST_TO_ADDR
89797: LD_VAR 0 4
89801: PUSH
89802: FOR_TO
89803: IFFALSE 89850
// begin hc_class = 13 ;
89805: LD_ADDR_OWVAR 28
89809: PUSH
89810: LD_INT 13
89812: ST_TO_ADDR
// hc_gallery =  ;
89813: LD_ADDR_OWVAR 33
89817: PUSH
89818: LD_STRING 
89820: ST_TO_ADDR
// animal := CreateHuman ;
89821: LD_ADDR_VAR 0 12
89825: PUSH
89826: CALL_OW 44
89830: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
89831: LD_VAR 0 12
89835: PPUSH
89836: LD_VAR 0 8
89840: PPUSH
89841: LD_INT 0
89843: PPUSH
89844: CALL 91566 0 3
// end ;
89848: GO 89802
89850: POP
89851: POP
// if fishes then
89852: LD_VAR 0 7
89856: IFFALSE 89923
// for i = 1 to fishes do
89858: LD_ADDR_VAR 0 11
89862: PUSH
89863: DOUBLE
89864: LD_INT 1
89866: DEC
89867: ST_TO_ADDR
89868: LD_VAR 0 7
89872: PUSH
89873: FOR_TO
89874: IFFALSE 89921
// begin hc_class = 20 ;
89876: LD_ADDR_OWVAR 28
89880: PUSH
89881: LD_INT 20
89883: ST_TO_ADDR
// hc_gallery =  ;
89884: LD_ADDR_OWVAR 33
89888: PUSH
89889: LD_STRING 
89891: ST_TO_ADDR
// animal := CreateHuman ;
89892: LD_ADDR_VAR 0 12
89896: PUSH
89897: CALL_OW 44
89901: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
89902: LD_VAR 0 12
89906: PPUSH
89907: LD_VAR 0 9
89911: PPUSH
89912: LD_INT 0
89914: PPUSH
89915: CALL 91566 0 3
// end ;
89919: GO 89873
89921: POP
89922: POP
// end ;
89923: LD_VAR 0 10
89927: RET
// export function WantHeal ( sci , unit ) ; begin
89928: LD_INT 0
89930: PPUSH
// if GetTaskList ( sci ) > 0 then
89931: LD_VAR 0 1
89935: PPUSH
89936: CALL_OW 437
89940: PUSH
89941: LD_INT 0
89943: GREATER
89944: IFFALSE 90016
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
89946: LD_VAR 0 1
89950: PPUSH
89951: CALL_OW 437
89955: PUSH
89956: LD_INT 1
89958: ARRAY
89959: PUSH
89960: LD_INT 1
89962: ARRAY
89963: PUSH
89964: LD_STRING l
89966: EQUAL
89967: IFFALSE 89994
89969: PUSH
89970: LD_VAR 0 1
89974: PPUSH
89975: CALL_OW 437
89979: PUSH
89980: LD_INT 1
89982: ARRAY
89983: PUSH
89984: LD_INT 4
89986: ARRAY
89987: PUSH
89988: LD_VAR 0 2
89992: EQUAL
89993: AND
89994: IFFALSE 90006
// result := true else
89996: LD_ADDR_VAR 0 3
90000: PUSH
90001: LD_INT 1
90003: ST_TO_ADDR
90004: GO 90014
// result := false ;
90006: LD_ADDR_VAR 0 3
90010: PUSH
90011: LD_INT 0
90013: ST_TO_ADDR
// end else
90014: GO 90024
// result := false ;
90016: LD_ADDR_VAR 0 3
90020: PUSH
90021: LD_INT 0
90023: ST_TO_ADDR
// end ;
90024: LD_VAR 0 3
90028: RET
// export function HealTarget ( sci ) ; begin
90029: LD_INT 0
90031: PPUSH
// if not sci then
90032: LD_VAR 0 1
90036: NOT
90037: IFFALSE 90041
// exit ;
90039: GO 90106
// result := 0 ;
90041: LD_ADDR_VAR 0 2
90045: PUSH
90046: LD_INT 0
90048: ST_TO_ADDR
// if GetTaskList ( sci ) then
90049: LD_VAR 0 1
90053: PPUSH
90054: CALL_OW 437
90058: IFFALSE 90106
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
90060: LD_VAR 0 1
90064: PPUSH
90065: CALL_OW 437
90069: PUSH
90070: LD_INT 1
90072: ARRAY
90073: PUSH
90074: LD_INT 1
90076: ARRAY
90077: PUSH
90078: LD_STRING l
90080: EQUAL
90081: IFFALSE 90106
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
90083: LD_ADDR_VAR 0 2
90087: PUSH
90088: LD_VAR 0 1
90092: PPUSH
90093: CALL_OW 437
90097: PUSH
90098: LD_INT 1
90100: ARRAY
90101: PUSH
90102: LD_INT 4
90104: ARRAY
90105: ST_TO_ADDR
// end ;
90106: LD_VAR 0 2
90110: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90111: LD_INT 0
90113: PPUSH
90114: PPUSH
90115: PPUSH
90116: PPUSH
// if not base_units then
90117: LD_VAR 0 1
90121: NOT
90122: IFFALSE 90126
// exit ;
90124: GO 90213
// result := false ;
90126: LD_ADDR_VAR 0 2
90130: PUSH
90131: LD_INT 0
90133: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90134: LD_ADDR_VAR 0 5
90138: PUSH
90139: LD_VAR 0 1
90143: PPUSH
90144: LD_INT 21
90146: PUSH
90147: LD_INT 3
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PPUSH
90154: CALL_OW 72
90158: ST_TO_ADDR
// if not tmp then
90159: LD_VAR 0 5
90163: NOT
90164: IFFALSE 90168
// exit ;
90166: GO 90213
// for i in tmp do
90168: LD_ADDR_VAR 0 3
90172: PUSH
90173: LD_VAR 0 5
90177: PUSH
90178: FOR_IN
90179: IFFALSE 90211
// begin result := EnemyInRange ( i , 22 ) ;
90181: LD_ADDR_VAR 0 2
90185: PUSH
90186: LD_VAR 0 3
90190: PPUSH
90191: LD_INT 22
90193: PPUSH
90194: CALL 87628 0 2
90198: ST_TO_ADDR
// if result then
90199: LD_VAR 0 2
90203: IFFALSE 90209
// exit ;
90205: POP
90206: POP
90207: GO 90213
// end ;
90209: GO 90178
90211: POP
90212: POP
// end ;
90213: LD_VAR 0 2
90217: RET
// export function FilterByTag ( units , tag ) ; begin
90218: LD_INT 0
90220: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
90221: LD_ADDR_VAR 0 3
90225: PUSH
90226: LD_VAR 0 1
90230: PPUSH
90231: LD_INT 120
90233: PUSH
90234: LD_VAR 0 2
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PPUSH
90243: CALL_OW 72
90247: ST_TO_ADDR
// end ;
90248: LD_VAR 0 3
90252: RET
// export function IsDriver ( un ) ; begin
90253: LD_INT 0
90255: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90256: LD_ADDR_VAR 0 2
90260: PUSH
90261: LD_VAR 0 1
90265: PUSH
90266: LD_INT 55
90268: PUSH
90269: EMPTY
90270: LIST
90271: PPUSH
90272: CALL_OW 69
90276: IN
90277: ST_TO_ADDR
// end ;
90278: LD_VAR 0 2
90282: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90283: LD_INT 0
90285: PPUSH
90286: PPUSH
// list := [ ] ;
90287: LD_ADDR_VAR 0 5
90291: PUSH
90292: EMPTY
90293: ST_TO_ADDR
// case d of 0 :
90294: LD_VAR 0 3
90298: PUSH
90299: LD_INT 0
90301: DOUBLE
90302: EQUAL
90303: IFTRUE 90307
90305: GO 90440
90307: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90308: LD_ADDR_VAR 0 5
90312: PUSH
90313: LD_VAR 0 1
90317: PUSH
90318: LD_INT 4
90320: MINUS
90321: PUSH
90322: LD_VAR 0 2
90326: PUSH
90327: LD_INT 4
90329: MINUS
90330: PUSH
90331: LD_INT 2
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: LIST
90338: PUSH
90339: LD_VAR 0 1
90343: PUSH
90344: LD_INT 3
90346: MINUS
90347: PUSH
90348: LD_VAR 0 2
90352: PUSH
90353: LD_INT 1
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: LIST
90360: PUSH
90361: LD_VAR 0 1
90365: PUSH
90366: LD_INT 4
90368: PLUS
90369: PUSH
90370: LD_VAR 0 2
90374: PUSH
90375: LD_INT 4
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: LIST
90382: PUSH
90383: LD_VAR 0 1
90387: PUSH
90388: LD_INT 3
90390: PLUS
90391: PUSH
90392: LD_VAR 0 2
90396: PUSH
90397: LD_INT 3
90399: PLUS
90400: PUSH
90401: LD_INT 5
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: LIST
90408: PUSH
90409: LD_VAR 0 1
90413: PUSH
90414: LD_VAR 0 2
90418: PUSH
90419: LD_INT 4
90421: PLUS
90422: PUSH
90423: LD_INT 0
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: LIST
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: ST_TO_ADDR
// end ; 1 :
90438: GO 91138
90440: LD_INT 1
90442: DOUBLE
90443: EQUAL
90444: IFTRUE 90448
90446: GO 90581
90448: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
90449: LD_ADDR_VAR 0 5
90453: PUSH
90454: LD_VAR 0 1
90458: PUSH
90459: LD_VAR 0 2
90463: PUSH
90464: LD_INT 4
90466: MINUS
90467: PUSH
90468: LD_INT 3
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: LIST
90475: PUSH
90476: LD_VAR 0 1
90480: PUSH
90481: LD_INT 3
90483: MINUS
90484: PUSH
90485: LD_VAR 0 2
90489: PUSH
90490: LD_INT 3
90492: MINUS
90493: PUSH
90494: LD_INT 2
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: LIST
90501: PUSH
90502: LD_VAR 0 1
90506: PUSH
90507: LD_INT 4
90509: MINUS
90510: PUSH
90511: LD_VAR 0 2
90515: PUSH
90516: LD_INT 1
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: LIST
90523: PUSH
90524: LD_VAR 0 1
90528: PUSH
90529: LD_VAR 0 2
90533: PUSH
90534: LD_INT 3
90536: PLUS
90537: PUSH
90538: LD_INT 0
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: LIST
90545: PUSH
90546: LD_VAR 0 1
90550: PUSH
90551: LD_INT 4
90553: PLUS
90554: PUSH
90555: LD_VAR 0 2
90559: PUSH
90560: LD_INT 4
90562: PLUS
90563: PUSH
90564: LD_INT 5
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: LIST
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: ST_TO_ADDR
// end ; 2 :
90579: GO 91138
90581: LD_INT 2
90583: DOUBLE
90584: EQUAL
90585: IFTRUE 90589
90587: GO 90718
90589: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
90590: LD_ADDR_VAR 0 5
90594: PUSH
90595: LD_VAR 0 1
90599: PUSH
90600: LD_VAR 0 2
90604: PUSH
90605: LD_INT 3
90607: MINUS
90608: PUSH
90609: LD_INT 3
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: LIST
90616: PUSH
90617: LD_VAR 0 1
90621: PUSH
90622: LD_INT 4
90624: PLUS
90625: PUSH
90626: LD_VAR 0 2
90630: PUSH
90631: LD_INT 4
90633: PUSH
90634: EMPTY
90635: LIST
90636: LIST
90637: LIST
90638: PUSH
90639: LD_VAR 0 1
90643: PUSH
90644: LD_VAR 0 2
90648: PUSH
90649: LD_INT 4
90651: PLUS
90652: PUSH
90653: LD_INT 0
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: LIST
90660: PUSH
90661: LD_VAR 0 1
90665: PUSH
90666: LD_INT 3
90668: MINUS
90669: PUSH
90670: LD_VAR 0 2
90674: PUSH
90675: LD_INT 1
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: LIST
90682: PUSH
90683: LD_VAR 0 1
90687: PUSH
90688: LD_INT 4
90690: MINUS
90691: PUSH
90692: LD_VAR 0 2
90696: PUSH
90697: LD_INT 4
90699: MINUS
90700: PUSH
90701: LD_INT 2
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: LIST
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: ST_TO_ADDR
// end ; 3 :
90716: GO 91138
90718: LD_INT 3
90720: DOUBLE
90721: EQUAL
90722: IFTRUE 90726
90724: GO 90859
90726: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
90727: LD_ADDR_VAR 0 5
90731: PUSH
90732: LD_VAR 0 1
90736: PUSH
90737: LD_INT 3
90739: PLUS
90740: PUSH
90741: LD_VAR 0 2
90745: PUSH
90746: LD_INT 4
90748: PUSH
90749: EMPTY
90750: LIST
90751: LIST
90752: LIST
90753: PUSH
90754: LD_VAR 0 1
90758: PUSH
90759: LD_INT 4
90761: PLUS
90762: PUSH
90763: LD_VAR 0 2
90767: PUSH
90768: LD_INT 4
90770: PLUS
90771: PUSH
90772: LD_INT 5
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: LIST
90779: PUSH
90780: LD_VAR 0 1
90784: PUSH
90785: LD_INT 4
90787: MINUS
90788: PUSH
90789: LD_VAR 0 2
90793: PUSH
90794: LD_INT 1
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: LIST
90801: PUSH
90802: LD_VAR 0 1
90806: PUSH
90807: LD_VAR 0 2
90811: PUSH
90812: LD_INT 4
90814: MINUS
90815: PUSH
90816: LD_INT 3
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: LIST
90823: PUSH
90824: LD_VAR 0 1
90828: PUSH
90829: LD_INT 3
90831: MINUS
90832: PUSH
90833: LD_VAR 0 2
90837: PUSH
90838: LD_INT 3
90840: MINUS
90841: PUSH
90842: LD_INT 2
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: LIST
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: ST_TO_ADDR
// end ; 4 :
90857: GO 91138
90859: LD_INT 4
90861: DOUBLE
90862: EQUAL
90863: IFTRUE 90867
90865: GO 91000
90867: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
90868: LD_ADDR_VAR 0 5
90872: PUSH
90873: LD_VAR 0 1
90877: PUSH
90878: LD_VAR 0 2
90882: PUSH
90883: LD_INT 4
90885: PLUS
90886: PUSH
90887: LD_INT 0
90889: PUSH
90890: EMPTY
90891: LIST
90892: LIST
90893: LIST
90894: PUSH
90895: LD_VAR 0 1
90899: PUSH
90900: LD_INT 3
90902: PLUS
90903: PUSH
90904: LD_VAR 0 2
90908: PUSH
90909: LD_INT 3
90911: PLUS
90912: PUSH
90913: LD_INT 5
90915: PUSH
90916: EMPTY
90917: LIST
90918: LIST
90919: LIST
90920: PUSH
90921: LD_VAR 0 1
90925: PUSH
90926: LD_INT 4
90928: PLUS
90929: PUSH
90930: LD_VAR 0 2
90934: PUSH
90935: LD_INT 4
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: LIST
90942: PUSH
90943: LD_VAR 0 1
90947: PUSH
90948: LD_VAR 0 2
90952: PUSH
90953: LD_INT 3
90955: MINUS
90956: PUSH
90957: LD_INT 3
90959: PUSH
90960: EMPTY
90961: LIST
90962: LIST
90963: LIST
90964: PUSH
90965: LD_VAR 0 1
90969: PUSH
90970: LD_INT 4
90972: MINUS
90973: PUSH
90974: LD_VAR 0 2
90978: PUSH
90979: LD_INT 4
90981: MINUS
90982: PUSH
90983: LD_INT 2
90985: PUSH
90986: EMPTY
90987: LIST
90988: LIST
90989: LIST
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: ST_TO_ADDR
// end ; 5 :
90998: GO 91138
91000: LD_INT 5
91002: DOUBLE
91003: EQUAL
91004: IFTRUE 91008
91006: GO 91137
91008: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91009: LD_ADDR_VAR 0 5
91013: PUSH
91014: LD_VAR 0 1
91018: PUSH
91019: LD_INT 4
91021: MINUS
91022: PUSH
91023: LD_VAR 0 2
91027: PUSH
91028: LD_INT 1
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: LIST
91035: PUSH
91036: LD_VAR 0 1
91040: PUSH
91041: LD_VAR 0 2
91045: PUSH
91046: LD_INT 4
91048: MINUS
91049: PUSH
91050: LD_INT 3
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: LIST
91057: PUSH
91058: LD_VAR 0 1
91062: PUSH
91063: LD_INT 4
91065: PLUS
91066: PUSH
91067: LD_VAR 0 2
91071: PUSH
91072: LD_INT 4
91074: PLUS
91075: PUSH
91076: LD_INT 5
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: LIST
91083: PUSH
91084: LD_VAR 0 1
91088: PUSH
91089: LD_INT 3
91091: PLUS
91092: PUSH
91093: LD_VAR 0 2
91097: PUSH
91098: LD_INT 4
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: LIST
91105: PUSH
91106: LD_VAR 0 1
91110: PUSH
91111: LD_VAR 0 2
91115: PUSH
91116: LD_INT 3
91118: PLUS
91119: PUSH
91120: LD_INT 0
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: LIST
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: ST_TO_ADDR
// end ; end ;
91135: GO 91138
91137: POP
// result := list ;
91138: LD_ADDR_VAR 0 4
91142: PUSH
91143: LD_VAR 0 5
91147: ST_TO_ADDR
// end ;
91148: LD_VAR 0 4
91152: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91153: LD_INT 0
91155: PPUSH
91156: PPUSH
91157: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91158: LD_VAR 0 1
91162: NOT
91163: IFTRUE 91191
91165: PUSH
91166: LD_VAR 0 2
91170: PUSH
91171: LD_INT 1
91173: PUSH
91174: LD_INT 2
91176: PUSH
91177: LD_INT 3
91179: PUSH
91180: LD_INT 4
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: IN
91189: NOT
91190: OR
91191: IFFALSE 91195
// exit ;
91193: GO 91278
// tmp := [ ] ;
91195: LD_ADDR_VAR 0 5
91199: PUSH
91200: EMPTY
91201: ST_TO_ADDR
// for i in units do
91202: LD_ADDR_VAR 0 4
91206: PUSH
91207: LD_VAR 0 1
91211: PUSH
91212: FOR_IN
91213: IFFALSE 91247
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
91215: LD_ADDR_VAR 0 5
91219: PUSH
91220: LD_VAR 0 5
91224: PPUSH
91225: LD_VAR 0 4
91229: PPUSH
91230: LD_VAR 0 2
91234: PPUSH
91235: CALL_OW 259
91239: PPUSH
91240: CALL 92673 0 2
91244: ST_TO_ADDR
91245: GO 91212
91247: POP
91248: POP
// if not tmp then
91249: LD_VAR 0 5
91253: NOT
91254: IFFALSE 91258
// exit ;
91256: GO 91278
// result := SortListByListDesc ( units , tmp ) ;
91258: LD_ADDR_VAR 0 3
91262: PUSH
91263: LD_VAR 0 1
91267: PPUSH
91268: LD_VAR 0 5
91272: PPUSH
91273: CALL_OW 77
91277: ST_TO_ADDR
// end ;
91278: LD_VAR 0 3
91282: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91283: LD_INT 0
91285: PPUSH
91286: PPUSH
91287: PPUSH
// result := false ;
91288: LD_ADDR_VAR 0 3
91292: PUSH
91293: LD_INT 0
91295: ST_TO_ADDR
// if not building then
91296: LD_VAR 0 2
91300: NOT
91301: IFFALSE 91305
// exit ;
91303: GO 91449
// x := GetX ( building ) ;
91305: LD_ADDR_VAR 0 4
91309: PUSH
91310: LD_VAR 0 2
91314: PPUSH
91315: CALL_OW 250
91319: ST_TO_ADDR
// y := GetY ( building ) ;
91320: LD_ADDR_VAR 0 5
91324: PUSH
91325: LD_VAR 0 2
91329: PPUSH
91330: CALL_OW 251
91334: ST_TO_ADDR
// if not x or not y then
91335: LD_VAR 0 4
91339: NOT
91340: IFTRUE 91349
91342: PUSH
91343: LD_VAR 0 5
91347: NOT
91348: OR
91349: IFFALSE 91353
// exit ;
91351: GO 91449
// if GetTaskList ( unit ) then
91353: LD_VAR 0 1
91357: PPUSH
91358: CALL_OW 437
91362: IFFALSE 91449
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91364: LD_STRING e
91366: PUSH
91367: LD_VAR 0 1
91371: PPUSH
91372: CALL_OW 437
91376: PUSH
91377: LD_INT 1
91379: ARRAY
91380: PUSH
91381: LD_INT 1
91383: ARRAY
91384: EQUAL
91385: IFFALSE 91412
91387: PUSH
91388: LD_VAR 0 4
91392: PUSH
91393: LD_VAR 0 1
91397: PPUSH
91398: CALL_OW 437
91402: PUSH
91403: LD_INT 1
91405: ARRAY
91406: PUSH
91407: LD_INT 2
91409: ARRAY
91410: EQUAL
91411: AND
91412: IFFALSE 91439
91414: PUSH
91415: LD_VAR 0 5
91419: PUSH
91420: LD_VAR 0 1
91424: PPUSH
91425: CALL_OW 437
91429: PUSH
91430: LD_INT 1
91432: ARRAY
91433: PUSH
91434: LD_INT 3
91436: ARRAY
91437: EQUAL
91438: AND
91439: IFFALSE 91449
// result := true end ;
91441: LD_ADDR_VAR 0 3
91445: PUSH
91446: LD_INT 1
91448: ST_TO_ADDR
// end ;
91449: LD_VAR 0 3
91453: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
91454: LD_INT 0
91456: PPUSH
// result := false ;
91457: LD_ADDR_VAR 0 4
91461: PUSH
91462: LD_INT 0
91464: ST_TO_ADDR
// if GetTaskList ( unit ) then
91465: LD_VAR 0 1
91469: PPUSH
91470: CALL_OW 437
91474: IFFALSE 91561
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91476: LD_STRING M
91478: PUSH
91479: LD_VAR 0 1
91483: PPUSH
91484: CALL_OW 437
91488: PUSH
91489: LD_INT 1
91491: ARRAY
91492: PUSH
91493: LD_INT 1
91495: ARRAY
91496: EQUAL
91497: IFFALSE 91524
91499: PUSH
91500: LD_VAR 0 2
91504: PUSH
91505: LD_VAR 0 1
91509: PPUSH
91510: CALL_OW 437
91514: PUSH
91515: LD_INT 1
91517: ARRAY
91518: PUSH
91519: LD_INT 2
91521: ARRAY
91522: EQUAL
91523: AND
91524: IFFALSE 91551
91526: PUSH
91527: LD_VAR 0 3
91531: PUSH
91532: LD_VAR 0 1
91536: PPUSH
91537: CALL_OW 437
91541: PUSH
91542: LD_INT 1
91544: ARRAY
91545: PUSH
91546: LD_INT 3
91548: ARRAY
91549: EQUAL
91550: AND
91551: IFFALSE 91561
// result := true ;
91553: LD_ADDR_VAR 0 4
91557: PUSH
91558: LD_INT 1
91560: ST_TO_ADDR
// end ; end ;
91561: LD_VAR 0 4
91565: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
91566: LD_INT 0
91568: PPUSH
91569: PPUSH
91570: PPUSH
91571: PPUSH
// if not unit or not area then
91572: LD_VAR 0 1
91576: NOT
91577: IFTRUE 91586
91579: PUSH
91580: LD_VAR 0 2
91584: NOT
91585: OR
91586: IFFALSE 91590
// exit ;
91588: GO 91766
// tmp := AreaToList ( area , i ) ;
91590: LD_ADDR_VAR 0 6
91594: PUSH
91595: LD_VAR 0 2
91599: PPUSH
91600: LD_VAR 0 5
91604: PPUSH
91605: CALL_OW 517
91609: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
91610: LD_ADDR_VAR 0 5
91614: PUSH
91615: DOUBLE
91616: LD_INT 1
91618: DEC
91619: ST_TO_ADDR
91620: LD_VAR 0 6
91624: PUSH
91625: LD_INT 1
91627: ARRAY
91628: PUSH
91629: FOR_TO
91630: IFFALSE 91764
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
91632: LD_ADDR_VAR 0 7
91636: PUSH
91637: LD_VAR 0 6
91641: PUSH
91642: LD_INT 1
91644: ARRAY
91645: PUSH
91646: LD_VAR 0 5
91650: ARRAY
91651: PUSH
91652: LD_VAR 0 6
91656: PUSH
91657: LD_INT 2
91659: ARRAY
91660: PUSH
91661: LD_VAR 0 5
91665: ARRAY
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
91671: LD_INT 92
91673: PUSH
91674: LD_VAR 0 7
91678: PUSH
91679: LD_INT 1
91681: ARRAY
91682: PUSH
91683: LD_VAR 0 7
91687: PUSH
91688: LD_INT 2
91690: ARRAY
91691: PUSH
91692: LD_INT 2
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: PPUSH
91701: CALL_OW 69
91705: PUSH
91706: LD_INT 0
91708: EQUAL
91709: IFFALSE 91762
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
91711: LD_VAR 0 1
91715: PPUSH
91716: LD_VAR 0 7
91720: PUSH
91721: LD_INT 1
91723: ARRAY
91724: PPUSH
91725: LD_VAR 0 7
91729: PUSH
91730: LD_INT 2
91732: ARRAY
91733: PPUSH
91734: LD_VAR 0 3
91738: PPUSH
91739: CALL_OW 48
// result := IsPlaced ( unit ) ;
91743: LD_ADDR_VAR 0 4
91747: PUSH
91748: LD_VAR 0 1
91752: PPUSH
91753: CALL_OW 305
91757: ST_TO_ADDR
// exit ;
91758: POP
91759: POP
91760: GO 91766
// end ; end ;
91762: GO 91629
91764: POP
91765: POP
// end ;
91766: LD_VAR 0 4
91770: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
91771: LD_INT 0
91773: PPUSH
91774: PPUSH
91775: PPUSH
// if not side or side > 8 then
91776: LD_VAR 0 1
91780: NOT
91781: IFTRUE 91793
91783: PUSH
91784: LD_VAR 0 1
91788: PUSH
91789: LD_INT 8
91791: GREATER
91792: OR
91793: IFFALSE 91797
// exit ;
91795: GO 91984
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
91797: LD_ADDR_VAR 0 4
91801: PUSH
91802: LD_INT 22
91804: PUSH
91805: LD_VAR 0 1
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: PUSH
91814: LD_INT 21
91816: PUSH
91817: LD_INT 3
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PPUSH
91828: CALL_OW 69
91832: ST_TO_ADDR
// if not tmp then
91833: LD_VAR 0 4
91837: NOT
91838: IFFALSE 91842
// exit ;
91840: GO 91984
// enable_addtolog := true ;
91842: LD_ADDR_OWVAR 81
91846: PUSH
91847: LD_INT 1
91849: ST_TO_ADDR
// AddToLog ( [ ) ;
91850: LD_STRING [
91852: PPUSH
91853: CALL_OW 561
// for i in tmp do
91857: LD_ADDR_VAR 0 3
91861: PUSH
91862: LD_VAR 0 4
91866: PUSH
91867: FOR_IN
91868: IFFALSE 91975
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
91870: LD_STRING [
91872: PUSH
91873: LD_VAR 0 3
91877: PPUSH
91878: CALL_OW 266
91882: STR
91883: PUSH
91884: LD_STRING , 
91886: STR
91887: PUSH
91888: LD_VAR 0 3
91892: PPUSH
91893: CALL_OW 250
91897: STR
91898: PUSH
91899: LD_STRING , 
91901: STR
91902: PUSH
91903: LD_VAR 0 3
91907: PPUSH
91908: CALL_OW 251
91912: STR
91913: PUSH
91914: LD_STRING , 
91916: STR
91917: PUSH
91918: LD_VAR 0 3
91922: PPUSH
91923: CALL_OW 254
91927: STR
91928: PUSH
91929: LD_STRING , 
91931: STR
91932: PUSH
91933: LD_VAR 0 3
91937: PPUSH
91938: LD_INT 1
91940: PPUSH
91941: CALL_OW 268
91945: STR
91946: PUSH
91947: LD_STRING , 
91949: STR
91950: PUSH
91951: LD_VAR 0 3
91955: PPUSH
91956: LD_INT 2
91958: PPUSH
91959: CALL_OW 268
91963: STR
91964: PUSH
91965: LD_STRING ],
91967: STR
91968: PPUSH
91969: CALL_OW 561
// end ;
91973: GO 91867
91975: POP
91976: POP
// AddToLog ( ]; ) ;
91977: LD_STRING ];
91979: PPUSH
91980: CALL_OW 561
// end ;
91984: LD_VAR 0 2
91988: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
91989: LD_INT 0
91991: PPUSH
91992: PPUSH
91993: PPUSH
91994: PPUSH
91995: PPUSH
// if not area or not rate or not max then
91996: LD_VAR 0 1
92000: NOT
92001: IFTRUE 92010
92003: PUSH
92004: LD_VAR 0 2
92008: NOT
92009: OR
92010: IFTRUE 92019
92012: PUSH
92013: LD_VAR 0 4
92017: NOT
92018: OR
92019: IFFALSE 92023
// exit ;
92021: GO 92212
// while 1 do
92023: LD_INT 1
92025: IFFALSE 92212
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92027: LD_ADDR_VAR 0 9
92031: PUSH
92032: LD_VAR 0 1
92036: PPUSH
92037: LD_INT 1
92039: PPUSH
92040: CALL_OW 287
92044: PUSH
92045: LD_INT 10
92047: MUL
92048: ST_TO_ADDR
// r := rate / 10 ;
92049: LD_ADDR_VAR 0 7
92053: PUSH
92054: LD_VAR 0 2
92058: PUSH
92059: LD_INT 10
92061: DIVREAL
92062: ST_TO_ADDR
// time := 1 1$00 ;
92063: LD_ADDR_VAR 0 8
92067: PUSH
92068: LD_INT 2100
92070: ST_TO_ADDR
// if amount < min then
92071: LD_VAR 0 9
92075: PUSH
92076: LD_VAR 0 3
92080: LESS
92081: IFFALSE 92099
// r := r * 2 else
92083: LD_ADDR_VAR 0 7
92087: PUSH
92088: LD_VAR 0 7
92092: PUSH
92093: LD_INT 2
92095: MUL
92096: ST_TO_ADDR
92097: GO 92125
// if amount > max then
92099: LD_VAR 0 9
92103: PUSH
92104: LD_VAR 0 4
92108: GREATER
92109: IFFALSE 92125
// r := r / 2 ;
92111: LD_ADDR_VAR 0 7
92115: PUSH
92116: LD_VAR 0 7
92120: PUSH
92121: LD_INT 2
92123: DIVREAL
92124: ST_TO_ADDR
// time := time / r ;
92125: LD_ADDR_VAR 0 8
92129: PUSH
92130: LD_VAR 0 8
92134: PUSH
92135: LD_VAR 0 7
92139: DIVREAL
92140: ST_TO_ADDR
// if time < 0 then
92141: LD_VAR 0 8
92145: PUSH
92146: LD_INT 0
92148: LESS
92149: IFFALSE 92166
// time := time * - 1 ;
92151: LD_ADDR_VAR 0 8
92155: PUSH
92156: LD_VAR 0 8
92160: PUSH
92161: LD_INT 1
92163: NEG
92164: MUL
92165: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
92166: LD_VAR 0 8
92170: PUSH
92171: LD_INT 35
92173: PPUSH
92174: LD_INT 875
92176: PPUSH
92177: CALL_OW 12
92181: PLUS
92182: PPUSH
92183: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92187: LD_INT 1
92189: PPUSH
92190: LD_INT 5
92192: PPUSH
92193: CALL_OW 12
92197: PPUSH
92198: LD_VAR 0 1
92202: PPUSH
92203: LD_INT 1
92205: PPUSH
92206: CALL_OW 55
// end ;
92210: GO 92023
// end ;
92212: LD_VAR 0 5
92216: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92217: LD_INT 0
92219: PPUSH
92220: PPUSH
92221: PPUSH
92222: PPUSH
92223: PPUSH
92224: PPUSH
92225: PPUSH
92226: PPUSH
// if not turrets or not factories then
92227: LD_VAR 0 1
92231: NOT
92232: IFTRUE 92241
92234: PUSH
92235: LD_VAR 0 2
92239: NOT
92240: OR
92241: IFFALSE 92245
// exit ;
92243: GO 92552
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92245: LD_ADDR_VAR 0 10
92249: PUSH
92250: LD_INT 5
92252: PUSH
92253: LD_INT 6
92255: PUSH
92256: EMPTY
92257: LIST
92258: LIST
92259: PUSH
92260: LD_INT 2
92262: PUSH
92263: LD_INT 4
92265: PUSH
92266: EMPTY
92267: LIST
92268: LIST
92269: PUSH
92270: LD_INT 3
92272: PUSH
92273: LD_INT 5
92275: PUSH
92276: EMPTY
92277: LIST
92278: LIST
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: LIST
92284: PUSH
92285: LD_INT 24
92287: PUSH
92288: LD_INT 25
92290: PUSH
92291: EMPTY
92292: LIST
92293: LIST
92294: PUSH
92295: LD_INT 23
92297: PUSH
92298: LD_INT 27
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: LD_INT 42
92311: PUSH
92312: LD_INT 43
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 44
92321: PUSH
92322: LD_INT 46
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 45
92331: PUSH
92332: LD_INT 47
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: LIST
92343: PUSH
92344: EMPTY
92345: LIST
92346: LIST
92347: LIST
92348: ST_TO_ADDR
// result := [ ] ;
92349: LD_ADDR_VAR 0 3
92353: PUSH
92354: EMPTY
92355: ST_TO_ADDR
// for i in turrets do
92356: LD_ADDR_VAR 0 4
92360: PUSH
92361: LD_VAR 0 1
92365: PUSH
92366: FOR_IN
92367: IFFALSE 92550
// begin nat := GetNation ( i ) ;
92369: LD_ADDR_VAR 0 7
92373: PUSH
92374: LD_VAR 0 4
92378: PPUSH
92379: CALL_OW 248
92383: ST_TO_ADDR
// weapon := 0 ;
92384: LD_ADDR_VAR 0 8
92388: PUSH
92389: LD_INT 0
92391: ST_TO_ADDR
// if not nat then
92392: LD_VAR 0 7
92396: NOT
92397: IFFALSE 92401
// continue ;
92399: GO 92366
// for j in list [ nat ] do
92401: LD_ADDR_VAR 0 5
92405: PUSH
92406: LD_VAR 0 10
92410: PUSH
92411: LD_VAR 0 7
92415: ARRAY
92416: PUSH
92417: FOR_IN
92418: IFFALSE 92459
// if GetBWeapon ( i ) = j [ 1 ] then
92420: LD_VAR 0 4
92424: PPUSH
92425: CALL_OW 269
92429: PUSH
92430: LD_VAR 0 5
92434: PUSH
92435: LD_INT 1
92437: ARRAY
92438: EQUAL
92439: IFFALSE 92457
// begin weapon := j [ 2 ] ;
92441: LD_ADDR_VAR 0 8
92445: PUSH
92446: LD_VAR 0 5
92450: PUSH
92451: LD_INT 2
92453: ARRAY
92454: ST_TO_ADDR
// break ;
92455: GO 92459
// end ;
92457: GO 92417
92459: POP
92460: POP
// if not weapon then
92461: LD_VAR 0 8
92465: NOT
92466: IFFALSE 92470
// continue ;
92468: GO 92366
// for k in factories do
92470: LD_ADDR_VAR 0 6
92474: PUSH
92475: LD_VAR 0 2
92479: PUSH
92480: FOR_IN
92481: IFFALSE 92546
// begin weapons := AvailableWeaponList ( k ) ;
92483: LD_ADDR_VAR 0 9
92487: PUSH
92488: LD_VAR 0 6
92492: PPUSH
92493: CALL_OW 478
92497: ST_TO_ADDR
// if not weapons then
92498: LD_VAR 0 9
92502: NOT
92503: IFFALSE 92507
// continue ;
92505: GO 92480
// if weapon in weapons then
92507: LD_VAR 0 8
92511: PUSH
92512: LD_VAR 0 9
92516: IN
92517: IFFALSE 92544
// begin result := [ i , weapon ] ;
92519: LD_ADDR_VAR 0 3
92523: PUSH
92524: LD_VAR 0 4
92528: PUSH
92529: LD_VAR 0 8
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: ST_TO_ADDR
// exit ;
92538: POP
92539: POP
92540: POP
92541: POP
92542: GO 92552
// end ; end ;
92544: GO 92480
92546: POP
92547: POP
// end ;
92548: GO 92366
92550: POP
92551: POP
// end ;
92552: LD_VAR 0 3
92556: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
92557: LD_INT 0
92559: PPUSH
// if not side or side > 8 then
92560: LD_VAR 0 3
92564: NOT
92565: IFTRUE 92577
92567: PUSH
92568: LD_VAR 0 3
92572: PUSH
92573: LD_INT 8
92575: GREATER
92576: OR
92577: IFFALSE 92581
// exit ;
92579: GO 92640
// if not range then
92581: LD_VAR 0 4
92585: NOT
92586: IFFALSE 92597
// range := - 12 ;
92588: LD_ADDR_VAR 0 4
92592: PUSH
92593: LD_INT 12
92595: NEG
92596: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
92597: LD_VAR 0 1
92601: PPUSH
92602: LD_VAR 0 2
92606: PPUSH
92607: LD_VAR 0 3
92611: PPUSH
92612: LD_VAR 0 4
92616: PPUSH
92617: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
92621: LD_VAR 0 1
92625: PPUSH
92626: LD_VAR 0 2
92630: PPUSH
92631: LD_VAR 0 3
92635: PPUSH
92636: CALL_OW 331
// end ;
92640: LD_VAR 0 5
92644: RET
// export function Video ( mode ) ; begin
92645: LD_INT 0
92647: PPUSH
// ingame_video = mode ;
92648: LD_ADDR_OWVAR 52
92652: PUSH
92653: LD_VAR 0 1
92657: ST_TO_ADDR
// interface_hidden = mode ;
92658: LD_ADDR_OWVAR 54
92662: PUSH
92663: LD_VAR 0 1
92667: ST_TO_ADDR
// end ;
92668: LD_VAR 0 2
92672: RET
// export function Join ( array , element ) ; begin
92673: LD_INT 0
92675: PPUSH
// result := Replace ( array , array + 1 , element ) ;
92676: LD_ADDR_VAR 0 3
92680: PUSH
92681: LD_VAR 0 1
92685: PPUSH
92686: LD_VAR 0 1
92690: PUSH
92691: LD_INT 1
92693: PLUS
92694: PPUSH
92695: LD_VAR 0 2
92699: PPUSH
92700: CALL_OW 1
92704: ST_TO_ADDR
// end ;
92705: LD_VAR 0 3
92709: RET
// export function JoinUnion ( array , element ) ; begin
92710: LD_INT 0
92712: PPUSH
// result := array union element ;
92713: LD_ADDR_VAR 0 3
92717: PUSH
92718: LD_VAR 0 1
92722: PUSH
92723: LD_VAR 0 2
92727: UNION
92728: ST_TO_ADDR
// end ;
92729: LD_VAR 0 3
92733: RET
// export function GetBehemoths ( side ) ; begin
92734: LD_INT 0
92736: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
92737: LD_ADDR_VAR 0 2
92741: PUSH
92742: LD_INT 22
92744: PUSH
92745: LD_VAR 0 1
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 31
92756: PUSH
92757: LD_INT 25
92759: PUSH
92760: EMPTY
92761: LIST
92762: LIST
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PPUSH
92768: CALL_OW 69
92772: ST_TO_ADDR
// end ;
92773: LD_VAR 0 2
92777: RET
// export function Shuffle ( array ) ; var i , index ; begin
92778: LD_INT 0
92780: PPUSH
92781: PPUSH
92782: PPUSH
// result := [ ] ;
92783: LD_ADDR_VAR 0 2
92787: PUSH
92788: EMPTY
92789: ST_TO_ADDR
// if not array then
92790: LD_VAR 0 1
92794: NOT
92795: IFFALSE 92799
// exit ;
92797: GO 92898
// Randomize ;
92799: CALL_OW 10
// for i = array downto 1 do
92803: LD_ADDR_VAR 0 3
92807: PUSH
92808: DOUBLE
92809: LD_VAR 0 1
92813: INC
92814: ST_TO_ADDR
92815: LD_INT 1
92817: PUSH
92818: FOR_DOWNTO
92819: IFFALSE 92896
// begin index := rand ( 1 , array ) ;
92821: LD_ADDR_VAR 0 4
92825: PUSH
92826: LD_INT 1
92828: PPUSH
92829: LD_VAR 0 1
92833: PPUSH
92834: CALL_OW 12
92838: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
92839: LD_ADDR_VAR 0 2
92843: PUSH
92844: LD_VAR 0 2
92848: PPUSH
92849: LD_VAR 0 2
92853: PUSH
92854: LD_INT 1
92856: PLUS
92857: PPUSH
92858: LD_VAR 0 1
92862: PUSH
92863: LD_VAR 0 4
92867: ARRAY
92868: PPUSH
92869: CALL_OW 2
92873: ST_TO_ADDR
// array := Delete ( array , index ) ;
92874: LD_ADDR_VAR 0 1
92878: PUSH
92879: LD_VAR 0 1
92883: PPUSH
92884: LD_VAR 0 4
92888: PPUSH
92889: CALL_OW 3
92893: ST_TO_ADDR
// end ;
92894: GO 92818
92896: POP
92897: POP
// end ;
92898: LD_VAR 0 2
92902: RET
// export function GetBaseMaterials ( base ) ; begin
92903: LD_INT 0
92905: PPUSH
// result := [ 0 , 0 , 0 ] ;
92906: LD_ADDR_VAR 0 2
92910: PUSH
92911: LD_INT 0
92913: PUSH
92914: LD_INT 0
92916: PUSH
92917: LD_INT 0
92919: PUSH
92920: EMPTY
92921: LIST
92922: LIST
92923: LIST
92924: ST_TO_ADDR
// if not base then
92925: LD_VAR 0 1
92929: NOT
92930: IFFALSE 92934
// exit ;
92932: GO 92983
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
92934: LD_ADDR_VAR 0 2
92938: PUSH
92939: LD_VAR 0 1
92943: PPUSH
92944: LD_INT 1
92946: PPUSH
92947: CALL_OW 275
92951: PUSH
92952: LD_VAR 0 1
92956: PPUSH
92957: LD_INT 2
92959: PPUSH
92960: CALL_OW 275
92964: PUSH
92965: LD_VAR 0 1
92969: PPUSH
92970: LD_INT 3
92972: PPUSH
92973: CALL_OW 275
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: LIST
92982: ST_TO_ADDR
// end ;
92983: LD_VAR 0 2
92987: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
92988: LD_INT 0
92990: PPUSH
92991: PPUSH
// result := array ;
92992: LD_ADDR_VAR 0 3
92996: PUSH
92997: LD_VAR 0 1
93001: ST_TO_ADDR
// if size >= result then
93002: LD_VAR 0 2
93006: PUSH
93007: LD_VAR 0 3
93011: GREATEREQUAL
93012: IFFALSE 93016
// exit ;
93014: GO 93066
// if size then
93016: LD_VAR 0 2
93020: IFFALSE 93066
// for i := array downto size do
93022: LD_ADDR_VAR 0 4
93026: PUSH
93027: DOUBLE
93028: LD_VAR 0 1
93032: INC
93033: ST_TO_ADDR
93034: LD_VAR 0 2
93038: PUSH
93039: FOR_DOWNTO
93040: IFFALSE 93064
// result := Delete ( result , result ) ;
93042: LD_ADDR_VAR 0 3
93046: PUSH
93047: LD_VAR 0 3
93051: PPUSH
93052: LD_VAR 0 3
93056: PPUSH
93057: CALL_OW 3
93061: ST_TO_ADDR
93062: GO 93039
93064: POP
93065: POP
// end ;
93066: LD_VAR 0 3
93070: RET
// export function ComExit ( unit ) ; var tmp ; begin
93071: LD_INT 0
93073: PPUSH
93074: PPUSH
// if not IsInUnit ( unit ) then
93075: LD_VAR 0 1
93079: PPUSH
93080: CALL_OW 310
93084: NOT
93085: IFFALSE 93089
// exit ;
93087: GO 93149
// tmp := IsInUnit ( unit ) ;
93089: LD_ADDR_VAR 0 3
93093: PUSH
93094: LD_VAR 0 1
93098: PPUSH
93099: CALL_OW 310
93103: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
93104: LD_VAR 0 3
93108: PPUSH
93109: CALL_OW 247
93113: PUSH
93114: LD_INT 2
93116: EQUAL
93117: IFFALSE 93130
// ComExitVehicle ( unit ) else
93119: LD_VAR 0 1
93123: PPUSH
93124: CALL_OW 121
93128: GO 93139
// ComExitBuilding ( unit ) ;
93130: LD_VAR 0 1
93134: PPUSH
93135: CALL_OW 122
// result := tmp ;
93139: LD_ADDR_VAR 0 2
93143: PUSH
93144: LD_VAR 0 3
93148: ST_TO_ADDR
// end ;
93149: LD_VAR 0 2
93153: RET
// export function ComExitAll ( units ) ; var i ; begin
93154: LD_INT 0
93156: PPUSH
93157: PPUSH
// if not units then
93158: LD_VAR 0 1
93162: NOT
93163: IFFALSE 93167
// exit ;
93165: GO 93193
// for i in units do
93167: LD_ADDR_VAR 0 3
93171: PUSH
93172: LD_VAR 0 1
93176: PUSH
93177: FOR_IN
93178: IFFALSE 93191
// ComExit ( i ) ;
93180: LD_VAR 0 3
93184: PPUSH
93185: CALL 93071 0 1
93189: GO 93177
93191: POP
93192: POP
// end ;
93193: LD_VAR 0 2
93197: RET
// export function ResetHc ; begin
93198: LD_INT 0
93200: PPUSH
// InitHc ;
93201: CALL_OW 19
// hc_importance := 0 ;
93205: LD_ADDR_OWVAR 32
93209: PUSH
93210: LD_INT 0
93212: ST_TO_ADDR
// end ;
93213: LD_VAR 0 1
93217: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
93218: LD_INT 0
93220: PPUSH
93221: PPUSH
93222: PPUSH
// _x := ( x1 + x2 ) div 2 ;
93223: LD_ADDR_VAR 0 6
93227: PUSH
93228: LD_VAR 0 1
93232: PUSH
93233: LD_VAR 0 3
93237: PLUS
93238: PUSH
93239: LD_INT 2
93241: DIV
93242: ST_TO_ADDR
// if _x < 0 then
93243: LD_VAR 0 6
93247: PUSH
93248: LD_INT 0
93250: LESS
93251: IFFALSE 93268
// _x := _x * - 1 ;
93253: LD_ADDR_VAR 0 6
93257: PUSH
93258: LD_VAR 0 6
93262: PUSH
93263: LD_INT 1
93265: NEG
93266: MUL
93267: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
93268: LD_ADDR_VAR 0 7
93272: PUSH
93273: LD_VAR 0 2
93277: PUSH
93278: LD_VAR 0 4
93282: PLUS
93283: PUSH
93284: LD_INT 2
93286: DIV
93287: ST_TO_ADDR
// if _y < 0 then
93288: LD_VAR 0 7
93292: PUSH
93293: LD_INT 0
93295: LESS
93296: IFFALSE 93313
// _y := _y * - 1 ;
93298: LD_ADDR_VAR 0 7
93302: PUSH
93303: LD_VAR 0 7
93307: PUSH
93308: LD_INT 1
93310: NEG
93311: MUL
93312: ST_TO_ADDR
// result := [ _x , _y ] ;
93313: LD_ADDR_VAR 0 5
93317: PUSH
93318: LD_VAR 0 6
93322: PUSH
93323: LD_VAR 0 7
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: ST_TO_ADDR
// end ;
93332: LD_VAR 0 5
93336: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
93337: LD_INT 0
93339: PPUSH
93340: PPUSH
93341: PPUSH
93342: PPUSH
// task := GetTaskList ( unit ) ;
93343: LD_ADDR_VAR 0 7
93347: PUSH
93348: LD_VAR 0 1
93352: PPUSH
93353: CALL_OW 437
93357: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
93358: LD_VAR 0 7
93362: NOT
93363: IFFALSE 93382
93365: PUSH
93366: LD_VAR 0 1
93370: PPUSH
93371: LD_VAR 0 2
93375: PPUSH
93376: CALL_OW 308
93380: NOT
93381: AND
93382: IFFALSE 93386
// exit ;
93384: GO 93504
// if IsInArea ( unit , area ) then
93386: LD_VAR 0 1
93390: PPUSH
93391: LD_VAR 0 2
93395: PPUSH
93396: CALL_OW 308
93400: IFFALSE 93418
// begin ComMoveToArea ( unit , goAway ) ;
93402: LD_VAR 0 1
93406: PPUSH
93407: LD_VAR 0 3
93411: PPUSH
93412: CALL_OW 113
// exit ;
93416: GO 93504
// end ; if task [ 1 ] [ 1 ] <> M then
93418: LD_VAR 0 7
93422: PUSH
93423: LD_INT 1
93425: ARRAY
93426: PUSH
93427: LD_INT 1
93429: ARRAY
93430: PUSH
93431: LD_STRING M
93433: NONEQUAL
93434: IFFALSE 93438
// exit ;
93436: GO 93504
// x := task [ 1 ] [ 2 ] ;
93438: LD_ADDR_VAR 0 5
93442: PUSH
93443: LD_VAR 0 7
93447: PUSH
93448: LD_INT 1
93450: ARRAY
93451: PUSH
93452: LD_INT 2
93454: ARRAY
93455: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
93456: LD_ADDR_VAR 0 6
93460: PUSH
93461: LD_VAR 0 7
93465: PUSH
93466: LD_INT 1
93468: ARRAY
93469: PUSH
93470: LD_INT 3
93472: ARRAY
93473: ST_TO_ADDR
// if InArea ( x , y , area ) then
93474: LD_VAR 0 5
93478: PPUSH
93479: LD_VAR 0 6
93483: PPUSH
93484: LD_VAR 0 2
93488: PPUSH
93489: CALL_OW 309
93493: IFFALSE 93504
// ComStop ( unit ) ;
93495: LD_VAR 0 1
93499: PPUSH
93500: CALL_OW 141
// end ;
93504: LD_VAR 0 4
93508: RET
// export function Abs ( value ) ; begin
93509: LD_INT 0
93511: PPUSH
// result := value ;
93512: LD_ADDR_VAR 0 2
93516: PUSH
93517: LD_VAR 0 1
93521: ST_TO_ADDR
// if value < 0 then
93522: LD_VAR 0 1
93526: PUSH
93527: LD_INT 0
93529: LESS
93530: IFFALSE 93547
// result := value * - 1 ;
93532: LD_ADDR_VAR 0 2
93536: PUSH
93537: LD_VAR 0 1
93541: PUSH
93542: LD_INT 1
93544: NEG
93545: MUL
93546: ST_TO_ADDR
// end ;
93547: LD_VAR 0 2
93551: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
93552: LD_INT 0
93554: PPUSH
93555: PPUSH
93556: PPUSH
93557: PPUSH
93558: PPUSH
93559: PPUSH
93560: PPUSH
93561: PPUSH
// if not unit or not building then
93562: LD_VAR 0 1
93566: NOT
93567: IFTRUE 93576
93569: PUSH
93570: LD_VAR 0 2
93574: NOT
93575: OR
93576: IFFALSE 93580
// exit ;
93578: GO 93808
// x := GetX ( building ) ;
93580: LD_ADDR_VAR 0 4
93584: PUSH
93585: LD_VAR 0 2
93589: PPUSH
93590: CALL_OW 250
93594: ST_TO_ADDR
// y := GetY ( building ) ;
93595: LD_ADDR_VAR 0 6
93599: PUSH
93600: LD_VAR 0 2
93604: PPUSH
93605: CALL_OW 251
93609: ST_TO_ADDR
// d := GetDir ( building ) ;
93610: LD_ADDR_VAR 0 8
93614: PUSH
93615: LD_VAR 0 2
93619: PPUSH
93620: CALL_OW 254
93624: ST_TO_ADDR
// r := 4 ;
93625: LD_ADDR_VAR 0 9
93629: PUSH
93630: LD_INT 4
93632: ST_TO_ADDR
// for i := 1 to 5 do
93633: LD_ADDR_VAR 0 10
93637: PUSH
93638: DOUBLE
93639: LD_INT 1
93641: DEC
93642: ST_TO_ADDR
93643: LD_INT 5
93645: PUSH
93646: FOR_TO
93647: IFFALSE 93806
// begin _x := ShiftX ( x , d , r + i ) ;
93649: LD_ADDR_VAR 0 5
93653: PUSH
93654: LD_VAR 0 4
93658: PPUSH
93659: LD_VAR 0 8
93663: PPUSH
93664: LD_VAR 0 9
93668: PUSH
93669: LD_VAR 0 10
93673: PLUS
93674: PPUSH
93675: CALL_OW 272
93679: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
93680: LD_ADDR_VAR 0 7
93684: PUSH
93685: LD_VAR 0 6
93689: PPUSH
93690: LD_VAR 0 8
93694: PPUSH
93695: LD_VAR 0 9
93699: PUSH
93700: LD_VAR 0 10
93704: PLUS
93705: PPUSH
93706: CALL_OW 273
93710: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
93711: LD_VAR 0 5
93715: PPUSH
93716: LD_VAR 0 7
93720: PPUSH
93721: CALL_OW 488
93725: IFFALSE 93760
93727: PUSH
93728: LD_VAR 0 5
93732: PPUSH
93733: LD_VAR 0 7
93737: PPUSH
93738: CALL_OW 428
93742: PPUSH
93743: CALL_OW 247
93747: PUSH
93748: LD_INT 3
93750: PUSH
93751: LD_INT 2
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: IN
93758: NOT
93759: AND
93760: IFFALSE 93804
// begin ComMoveXY ( unit , _x , _y ) ;
93762: LD_VAR 0 1
93766: PPUSH
93767: LD_VAR 0 5
93771: PPUSH
93772: LD_VAR 0 7
93776: PPUSH
93777: CALL_OW 111
// result := [ _x , _y ] ;
93781: LD_ADDR_VAR 0 3
93785: PUSH
93786: LD_VAR 0 5
93790: PUSH
93791: LD_VAR 0 7
93795: PUSH
93796: EMPTY
93797: LIST
93798: LIST
93799: ST_TO_ADDR
// exit ;
93800: POP
93801: POP
93802: GO 93808
// end ; end ;
93804: GO 93646
93806: POP
93807: POP
// end ;
93808: LD_VAR 0 3
93812: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
93813: LD_INT 0
93815: PPUSH
93816: PPUSH
93817: PPUSH
// result := 0 ;
93818: LD_ADDR_VAR 0 3
93822: PUSH
93823: LD_INT 0
93825: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
93826: LD_VAR 0 1
93830: PUSH
93831: LD_INT 0
93833: LESS
93834: IFTRUE 93846
93836: PUSH
93837: LD_VAR 0 1
93841: PUSH
93842: LD_INT 8
93844: GREATER
93845: OR
93846: IFTRUE 93858
93848: PUSH
93849: LD_VAR 0 2
93853: PUSH
93854: LD_INT 0
93856: LESS
93857: OR
93858: IFTRUE 93870
93860: PUSH
93861: LD_VAR 0 2
93865: PUSH
93866: LD_INT 8
93868: GREATER
93869: OR
93870: IFFALSE 93874
// exit ;
93872: GO 93949
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
93874: LD_ADDR_VAR 0 4
93878: PUSH
93879: LD_INT 22
93881: PUSH
93882: LD_VAR 0 2
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: PPUSH
93891: CALL_OW 69
93895: PUSH
93896: FOR_IN
93897: IFFALSE 93947
// begin un := UnitShoot ( i ) ;
93899: LD_ADDR_VAR 0 5
93903: PUSH
93904: LD_VAR 0 4
93908: PPUSH
93909: CALL_OW 504
93913: ST_TO_ADDR
// if GetSide ( un ) = side1 then
93914: LD_VAR 0 5
93918: PPUSH
93919: CALL_OW 255
93923: PUSH
93924: LD_VAR 0 1
93928: EQUAL
93929: IFFALSE 93945
// begin result := un ;
93931: LD_ADDR_VAR 0 3
93935: PUSH
93936: LD_VAR 0 5
93940: ST_TO_ADDR
// exit ;
93941: POP
93942: POP
93943: GO 93949
// end ; end ;
93945: GO 93896
93947: POP
93948: POP
// end ;
93949: LD_VAR 0 3
93953: RET
// export function GetCargoBay ( units ) ; begin
93954: LD_INT 0
93956: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
93957: LD_ADDR_VAR 0 2
93961: PUSH
93962: LD_VAR 0 1
93966: PPUSH
93967: LD_INT 2
93969: PUSH
93970: LD_INT 34
93972: PUSH
93973: LD_INT 12
93975: PUSH
93976: EMPTY
93977: LIST
93978: LIST
93979: PUSH
93980: LD_INT 34
93982: PUSH
93983: LD_INT 51
93985: PUSH
93986: EMPTY
93987: LIST
93988: LIST
93989: PUSH
93990: LD_INT 34
93992: PUSH
93993: LD_INT 32
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 34
94002: PUSH
94003: LD_INT 89
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: EMPTY
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: PPUSH
94017: CALL_OW 72
94021: ST_TO_ADDR
// end ;
94022: LD_VAR 0 2
94026: RET
// export function Negate ( value ) ; begin
94027: LD_INT 0
94029: PPUSH
// result := not value ;
94030: LD_ADDR_VAR 0 2
94034: PUSH
94035: LD_VAR 0 1
94039: NOT
94040: ST_TO_ADDR
// end ;
94041: LD_VAR 0 2
94045: RET
// export function Inc ( value ) ; begin
94046: LD_INT 0
94048: PPUSH
// result := value + 1 ;
94049: LD_ADDR_VAR 0 2
94053: PUSH
94054: LD_VAR 0 1
94058: PUSH
94059: LD_INT 1
94061: PLUS
94062: ST_TO_ADDR
// end ;
94063: LD_VAR 0 2
94067: RET
// export function Dec ( value ) ; begin
94068: LD_INT 0
94070: PPUSH
// result := value - 1 ;
94071: LD_ADDR_VAR 0 2
94075: PUSH
94076: LD_VAR 0 1
94080: PUSH
94081: LD_INT 1
94083: MINUS
94084: ST_TO_ADDR
// end ;
94085: LD_VAR 0 2
94089: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
94090: LD_INT 0
94092: PPUSH
94093: PPUSH
94094: PPUSH
94095: PPUSH
94096: PPUSH
94097: PPUSH
94098: PPUSH
94099: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
94100: LD_VAR 0 1
94104: PPUSH
94105: LD_VAR 0 2
94109: PPUSH
94110: CALL_OW 488
94114: NOT
94115: IFTRUE 94134
94117: PUSH
94118: LD_VAR 0 3
94122: PPUSH
94123: LD_VAR 0 4
94127: PPUSH
94128: CALL_OW 488
94132: NOT
94133: OR
94134: IFFALSE 94147
// begin result := - 1 ;
94136: LD_ADDR_VAR 0 5
94140: PUSH
94141: LD_INT 1
94143: NEG
94144: ST_TO_ADDR
// exit ;
94145: GO 94382
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
94147: LD_ADDR_VAR 0 12
94151: PUSH
94152: LD_VAR 0 1
94156: PPUSH
94157: LD_VAR 0 2
94161: PPUSH
94162: LD_VAR 0 3
94166: PPUSH
94167: LD_VAR 0 4
94171: PPUSH
94172: CALL 93218 0 4
94176: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
94177: LD_ADDR_VAR 0 11
94181: PUSH
94182: LD_VAR 0 1
94186: PPUSH
94187: LD_VAR 0 2
94191: PPUSH
94192: LD_VAR 0 12
94196: PUSH
94197: LD_INT 1
94199: ARRAY
94200: PPUSH
94201: LD_VAR 0 12
94205: PUSH
94206: LD_INT 2
94208: ARRAY
94209: PPUSH
94210: CALL_OW 298
94214: ST_TO_ADDR
// distance := 9999 ;
94215: LD_ADDR_VAR 0 10
94219: PUSH
94220: LD_INT 9999
94222: ST_TO_ADDR
// for i := 0 to 5 do
94223: LD_ADDR_VAR 0 6
94227: PUSH
94228: DOUBLE
94229: LD_INT 0
94231: DEC
94232: ST_TO_ADDR
94233: LD_INT 5
94235: PUSH
94236: FOR_TO
94237: IFFALSE 94380
// begin _x := ShiftX ( x1 , i , centerDist ) ;
94239: LD_ADDR_VAR 0 7
94243: PUSH
94244: LD_VAR 0 1
94248: PPUSH
94249: LD_VAR 0 6
94253: PPUSH
94254: LD_VAR 0 11
94258: PPUSH
94259: CALL_OW 272
94263: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
94264: LD_ADDR_VAR 0 8
94268: PUSH
94269: LD_VAR 0 2
94273: PPUSH
94274: LD_VAR 0 6
94278: PPUSH
94279: LD_VAR 0 11
94283: PPUSH
94284: CALL_OW 273
94288: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94289: LD_VAR 0 7
94293: PPUSH
94294: LD_VAR 0 8
94298: PPUSH
94299: CALL_OW 488
94303: NOT
94304: IFFALSE 94308
// continue ;
94306: GO 94236
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
94308: LD_ADDR_VAR 0 9
94312: PUSH
94313: LD_VAR 0 12
94317: PUSH
94318: LD_INT 1
94320: ARRAY
94321: PPUSH
94322: LD_VAR 0 12
94326: PUSH
94327: LD_INT 2
94329: ARRAY
94330: PPUSH
94331: LD_VAR 0 7
94335: PPUSH
94336: LD_VAR 0 8
94340: PPUSH
94341: CALL_OW 298
94345: ST_TO_ADDR
// if tmp < distance then
94346: LD_VAR 0 9
94350: PUSH
94351: LD_VAR 0 10
94355: LESS
94356: IFFALSE 94378
// begin result := i ;
94358: LD_ADDR_VAR 0 5
94362: PUSH
94363: LD_VAR 0 6
94367: ST_TO_ADDR
// distance := tmp ;
94368: LD_ADDR_VAR 0 10
94372: PUSH
94373: LD_VAR 0 9
94377: ST_TO_ADDR
// end ; end ;
94378: GO 94236
94380: POP
94381: POP
// end ;
94382: LD_VAR 0 5
94386: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
94387: LD_INT 0
94389: PPUSH
94390: PPUSH
// if not driver or not IsInUnit ( driver ) then
94391: LD_VAR 0 1
94395: NOT
94396: IFTRUE 94410
94398: PUSH
94399: LD_VAR 0 1
94403: PPUSH
94404: CALL_OW 310
94408: NOT
94409: OR
94410: IFFALSE 94414
// exit ;
94412: GO 94504
// vehicle := IsInUnit ( driver ) ;
94414: LD_ADDR_VAR 0 3
94418: PUSH
94419: LD_VAR 0 1
94423: PPUSH
94424: CALL_OW 310
94428: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
94429: LD_VAR 0 1
94433: PPUSH
94434: LD_STRING \
94436: PUSH
94437: LD_INT 0
94439: PUSH
94440: LD_INT 0
94442: PUSH
94443: LD_INT 0
94445: PUSH
94446: LD_INT 0
94448: PUSH
94449: LD_INT 0
94451: PUSH
94452: LD_INT 0
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: PUSH
94464: LD_STRING E
94466: PUSH
94467: LD_INT 0
94469: PUSH
94470: LD_INT 0
94472: PUSH
94473: LD_VAR 0 3
94477: PUSH
94478: LD_INT 0
94480: PUSH
94481: LD_INT 0
94483: PUSH
94484: LD_INT 0
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: PPUSH
94500: CALL_OW 446
// end ;
94504: LD_VAR 0 2
94508: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
94509: LD_INT 0
94511: PPUSH
94512: PPUSH
// if not driver or not IsInUnit ( driver ) then
94513: LD_VAR 0 1
94517: NOT
94518: IFTRUE 94532
94520: PUSH
94521: LD_VAR 0 1
94525: PPUSH
94526: CALL_OW 310
94530: NOT
94531: OR
94532: IFFALSE 94536
// exit ;
94534: GO 94626
// vehicle := IsInUnit ( driver ) ;
94536: LD_ADDR_VAR 0 3
94540: PUSH
94541: LD_VAR 0 1
94545: PPUSH
94546: CALL_OW 310
94550: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
94551: LD_VAR 0 1
94555: PPUSH
94556: LD_STRING \
94558: PUSH
94559: LD_INT 0
94561: PUSH
94562: LD_INT 0
94564: PUSH
94565: LD_INT 0
94567: PUSH
94568: LD_INT 0
94570: PUSH
94571: LD_INT 0
94573: PUSH
94574: LD_INT 0
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: PUSH
94586: LD_STRING E
94588: PUSH
94589: LD_INT 0
94591: PUSH
94592: LD_INT 0
94594: PUSH
94595: LD_VAR 0 3
94599: PUSH
94600: LD_INT 0
94602: PUSH
94603: LD_INT 0
94605: PUSH
94606: LD_INT 0
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: PPUSH
94622: CALL_OW 447
// end ;
94626: LD_VAR 0 2
94630: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
94631: LD_INT 0
94633: PPUSH
94634: PPUSH
94635: PPUSH
// tmp := [ ] ;
94636: LD_ADDR_VAR 0 5
94640: PUSH
94641: EMPTY
94642: ST_TO_ADDR
// for i in units do
94643: LD_ADDR_VAR 0 4
94647: PUSH
94648: LD_VAR 0 1
94652: PUSH
94653: FOR_IN
94654: IFFALSE 94692
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
94656: LD_ADDR_VAR 0 5
94660: PUSH
94661: LD_VAR 0 5
94665: PPUSH
94666: LD_VAR 0 5
94670: PUSH
94671: LD_INT 1
94673: PLUS
94674: PPUSH
94675: LD_VAR 0 4
94679: PPUSH
94680: CALL_OW 256
94684: PPUSH
94685: CALL_OW 2
94689: ST_TO_ADDR
94690: GO 94653
94692: POP
94693: POP
// if not tmp then
94694: LD_VAR 0 5
94698: NOT
94699: IFFALSE 94703
// exit ;
94701: GO 94751
// if asc then
94703: LD_VAR 0 2
94707: IFFALSE 94731
// result := SortListByListAsc ( units , tmp ) else
94709: LD_ADDR_VAR 0 3
94713: PUSH
94714: LD_VAR 0 1
94718: PPUSH
94719: LD_VAR 0 5
94723: PPUSH
94724: CALL_OW 76
94728: ST_TO_ADDR
94729: GO 94751
// result := SortListByListDesc ( units , tmp ) ;
94731: LD_ADDR_VAR 0 3
94735: PUSH
94736: LD_VAR 0 1
94740: PPUSH
94741: LD_VAR 0 5
94745: PPUSH
94746: CALL_OW 77
94750: ST_TO_ADDR
// end ;
94751: LD_VAR 0 3
94755: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
94756: LD_INT 0
94758: PPUSH
94759: PPUSH
// task := GetTaskList ( mech ) ;
94760: LD_ADDR_VAR 0 4
94764: PUSH
94765: LD_VAR 0 1
94769: PPUSH
94770: CALL_OW 437
94774: ST_TO_ADDR
// if not task then
94775: LD_VAR 0 4
94779: NOT
94780: IFFALSE 94784
// exit ;
94782: GO 94828
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
94784: LD_ADDR_VAR 0 3
94788: PUSH
94789: LD_VAR 0 4
94793: PUSH
94794: LD_INT 1
94796: ARRAY
94797: PUSH
94798: LD_INT 1
94800: ARRAY
94801: PUSH
94802: LD_STRING r
94804: EQUAL
94805: IFFALSE 94827
94807: PUSH
94808: LD_VAR 0 4
94812: PUSH
94813: LD_INT 1
94815: ARRAY
94816: PUSH
94817: LD_INT 4
94819: ARRAY
94820: PUSH
94821: LD_VAR 0 2
94825: EQUAL
94826: AND
94827: ST_TO_ADDR
// end ;
94828: LD_VAR 0 3
94832: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
94833: LD_INT 0
94835: PPUSH
// SetDir ( unit , d ) ;
94836: LD_VAR 0 1
94840: PPUSH
94841: LD_VAR 0 4
94845: PPUSH
94846: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
94850: LD_ADDR_VAR 0 6
94854: PUSH
94855: LD_VAR 0 1
94859: PPUSH
94860: LD_VAR 0 2
94864: PPUSH
94865: LD_VAR 0 3
94869: PPUSH
94870: LD_VAR 0 5
94874: PPUSH
94875: CALL_OW 48
94879: ST_TO_ADDR
// end ;
94880: LD_VAR 0 6
94884: RET
// export function ToNaturalNumber ( number ) ; begin
94885: LD_INT 0
94887: PPUSH
// result := number div 1 ;
94888: LD_ADDR_VAR 0 2
94892: PUSH
94893: LD_VAR 0 1
94897: PUSH
94898: LD_INT 1
94900: DIV
94901: ST_TO_ADDR
// if number < 0 then
94902: LD_VAR 0 1
94906: PUSH
94907: LD_INT 0
94909: LESS
94910: IFFALSE 94920
// result := 0 ;
94912: LD_ADDR_VAR 0 2
94916: PUSH
94917: LD_INT 0
94919: ST_TO_ADDR
// end ;
94920: LD_VAR 0 2
94924: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
94925: LD_INT 0
94927: PPUSH
94928: PPUSH
94929: PPUSH
// if not buildings then
94930: LD_VAR 0 1
94934: NOT
94935: IFFALSE 94939
// exit ;
94937: GO 95054
// tmp := [ ] ;
94939: LD_ADDR_VAR 0 5
94943: PUSH
94944: EMPTY
94945: ST_TO_ADDR
// for b in buildings do
94946: LD_ADDR_VAR 0 4
94950: PUSH
94951: LD_VAR 0 1
94955: PUSH
94956: FOR_IN
94957: IFFALSE 94995
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
94959: LD_ADDR_VAR 0 5
94963: PUSH
94964: LD_VAR 0 5
94968: PPUSH
94969: LD_VAR 0 5
94973: PUSH
94974: LD_INT 1
94976: PLUS
94977: PPUSH
94978: LD_VAR 0 4
94982: PPUSH
94983: CALL_OW 266
94987: PPUSH
94988: CALL_OW 1
94992: ST_TO_ADDR
94993: GO 94956
94995: POP
94996: POP
// if not tmp then
94997: LD_VAR 0 5
95001: NOT
95002: IFFALSE 95006
// exit ;
95004: GO 95054
// if asc then
95006: LD_VAR 0 2
95010: IFFALSE 95034
// result := SortListByListAsc ( buildings , tmp ) else
95012: LD_ADDR_VAR 0 3
95016: PUSH
95017: LD_VAR 0 1
95021: PPUSH
95022: LD_VAR 0 5
95026: PPUSH
95027: CALL_OW 76
95031: ST_TO_ADDR
95032: GO 95054
// result := SortListByListDesc ( buildings , tmp ) ;
95034: LD_ADDR_VAR 0 3
95038: PUSH
95039: LD_VAR 0 1
95043: PPUSH
95044: LD_VAR 0 5
95048: PPUSH
95049: CALL_OW 77
95053: ST_TO_ADDR
// end ;
95054: LD_VAR 0 3
95058: RET
// export function SortByClass ( units , class ) ; var un ; begin
95059: LD_INT 0
95061: PPUSH
95062: PPUSH
// if not units or not class then
95063: LD_VAR 0 1
95067: NOT
95068: IFTRUE 95077
95070: PUSH
95071: LD_VAR 0 2
95075: NOT
95076: OR
95077: IFFALSE 95081
// exit ;
95079: GO 95176
// result := [ ] ;
95081: LD_ADDR_VAR 0 3
95085: PUSH
95086: EMPTY
95087: ST_TO_ADDR
// for un in units do
95088: LD_ADDR_VAR 0 4
95092: PUSH
95093: LD_VAR 0 1
95097: PUSH
95098: FOR_IN
95099: IFFALSE 95174
// if GetClass ( un ) = class then
95101: LD_VAR 0 4
95105: PPUSH
95106: CALL_OW 257
95110: PUSH
95111: LD_VAR 0 2
95115: EQUAL
95116: IFFALSE 95143
// result := Insert ( result , 1 , un ) else
95118: LD_ADDR_VAR 0 3
95122: PUSH
95123: LD_VAR 0 3
95127: PPUSH
95128: LD_INT 1
95130: PPUSH
95131: LD_VAR 0 4
95135: PPUSH
95136: CALL_OW 2
95140: ST_TO_ADDR
95141: GO 95172
// result := Replace ( result , result + 1 , un ) ;
95143: LD_ADDR_VAR 0 3
95147: PUSH
95148: LD_VAR 0 3
95152: PPUSH
95153: LD_VAR 0 3
95157: PUSH
95158: LD_INT 1
95160: PLUS
95161: PPUSH
95162: LD_VAR 0 4
95166: PPUSH
95167: CALL_OW 1
95171: ST_TO_ADDR
95172: GO 95098
95174: POP
95175: POP
// end ;
95176: LD_VAR 0 3
95180: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
95181: LD_INT 0
95183: PPUSH
95184: PPUSH
95185: PPUSH
95186: PPUSH
95187: PPUSH
95188: PPUSH
95189: PPUSH
// result := [ ] ;
95190: LD_ADDR_VAR 0 4
95194: PUSH
95195: EMPTY
95196: ST_TO_ADDR
// if x - r < 0 then
95197: LD_VAR 0 1
95201: PUSH
95202: LD_VAR 0 3
95206: MINUS
95207: PUSH
95208: LD_INT 0
95210: LESS
95211: IFFALSE 95223
// min_x := 0 else
95213: LD_ADDR_VAR 0 8
95217: PUSH
95218: LD_INT 0
95220: ST_TO_ADDR
95221: GO 95239
// min_x := x - r ;
95223: LD_ADDR_VAR 0 8
95227: PUSH
95228: LD_VAR 0 1
95232: PUSH
95233: LD_VAR 0 3
95237: MINUS
95238: ST_TO_ADDR
// if y - r < 0 then
95239: LD_VAR 0 2
95243: PUSH
95244: LD_VAR 0 3
95248: MINUS
95249: PUSH
95250: LD_INT 0
95252: LESS
95253: IFFALSE 95265
// min_y := 0 else
95255: LD_ADDR_VAR 0 7
95259: PUSH
95260: LD_INT 0
95262: ST_TO_ADDR
95263: GO 95281
// min_y := y - r ;
95265: LD_ADDR_VAR 0 7
95269: PUSH
95270: LD_VAR 0 2
95274: PUSH
95275: LD_VAR 0 3
95279: MINUS
95280: ST_TO_ADDR
// max_x := x + r ;
95281: LD_ADDR_VAR 0 9
95285: PUSH
95286: LD_VAR 0 1
95290: PUSH
95291: LD_VAR 0 3
95295: PLUS
95296: ST_TO_ADDR
// max_y := y + r ;
95297: LD_ADDR_VAR 0 10
95301: PUSH
95302: LD_VAR 0 2
95306: PUSH
95307: LD_VAR 0 3
95311: PLUS
95312: ST_TO_ADDR
// for _x = min_x to max_x do
95313: LD_ADDR_VAR 0 5
95317: PUSH
95318: DOUBLE
95319: LD_VAR 0 8
95323: DEC
95324: ST_TO_ADDR
95325: LD_VAR 0 9
95329: PUSH
95330: FOR_TO
95331: IFFALSE 95432
// for _y = min_y to max_y do
95333: LD_ADDR_VAR 0 6
95337: PUSH
95338: DOUBLE
95339: LD_VAR 0 7
95343: DEC
95344: ST_TO_ADDR
95345: LD_VAR 0 10
95349: PUSH
95350: FOR_TO
95351: IFFALSE 95428
// begin if not ValidHex ( _x , _y ) then
95353: LD_VAR 0 5
95357: PPUSH
95358: LD_VAR 0 6
95362: PPUSH
95363: CALL_OW 488
95367: NOT
95368: IFFALSE 95372
// continue ;
95370: GO 95350
// if GetResourceTypeXY ( _x , _y ) then
95372: LD_VAR 0 5
95376: PPUSH
95377: LD_VAR 0 6
95381: PPUSH
95382: CALL_OW 283
95386: IFFALSE 95426
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
95388: LD_ADDR_VAR 0 4
95392: PUSH
95393: LD_VAR 0 4
95397: PPUSH
95398: LD_VAR 0 4
95402: PUSH
95403: LD_INT 1
95405: PLUS
95406: PPUSH
95407: LD_VAR 0 5
95411: PUSH
95412: LD_VAR 0 6
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: PPUSH
95421: CALL_OW 1
95425: ST_TO_ADDR
// end ;
95426: GO 95350
95428: POP
95429: POP
95430: GO 95330
95432: POP
95433: POP
// end ;
95434: LD_VAR 0 4
95438: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
95439: LD_INT 0
95441: PPUSH
95442: PPUSH
95443: PPUSH
95444: PPUSH
95445: PPUSH
95446: PPUSH
95447: PPUSH
95448: PPUSH
// if not units then
95449: LD_VAR 0 1
95453: NOT
95454: IFFALSE 95458
// exit ;
95456: GO 95990
// result := UnitFilter ( units , [ f_ok ] ) ;
95458: LD_ADDR_VAR 0 3
95462: PUSH
95463: LD_VAR 0 1
95467: PPUSH
95468: LD_INT 50
95470: PUSH
95471: EMPTY
95472: LIST
95473: PPUSH
95474: CALL_OW 72
95478: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
95479: LD_ADDR_VAR 0 8
95483: PUSH
95484: LD_VAR 0 1
95488: PUSH
95489: LD_INT 1
95491: ARRAY
95492: PPUSH
95493: CALL_OW 255
95497: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
95498: LD_ADDR_VAR 0 10
95502: PUSH
95503: LD_INT 29
95505: PUSH
95506: LD_INT 91
95508: PUSH
95509: LD_INT 49
95511: PUSH
95512: EMPTY
95513: LIST
95514: LIST
95515: LIST
95516: ST_TO_ADDR
// if not result then
95517: LD_VAR 0 3
95521: NOT
95522: IFFALSE 95526
// exit ;
95524: GO 95990
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
95526: LD_ADDR_VAR 0 5
95530: PUSH
95531: LD_INT 81
95533: PUSH
95534: LD_VAR 0 8
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PPUSH
95543: CALL_OW 69
95547: ST_TO_ADDR
// for i in result do
95548: LD_ADDR_VAR 0 4
95552: PUSH
95553: LD_VAR 0 3
95557: PUSH
95558: FOR_IN
95559: IFFALSE 95988
// begin tag := GetTag ( i ) + 1 ;
95561: LD_ADDR_VAR 0 9
95565: PUSH
95566: LD_VAR 0 4
95570: PPUSH
95571: CALL_OW 110
95575: PUSH
95576: LD_INT 1
95578: PLUS
95579: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
95580: LD_ADDR_VAR 0 7
95584: PUSH
95585: LD_VAR 0 4
95589: PPUSH
95590: CALL_OW 250
95594: PPUSH
95595: LD_VAR 0 4
95599: PPUSH
95600: CALL_OW 251
95604: PPUSH
95605: LD_INT 4
95607: PPUSH
95608: CALL 95181 0 3
95612: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
95613: LD_VAR 0 4
95617: PPUSH
95618: CALL_OW 247
95622: PUSH
95623: LD_INT 2
95625: EQUAL
95626: IFFALSE 95638
95628: PUSH
95629: LD_VAR 0 7
95633: PUSH
95634: LD_INT 2
95636: GREATER
95637: AND
95638: IFFALSE 95658
95640: PUSH
95641: LD_VAR 0 4
95645: PPUSH
95646: CALL_OW 264
95650: PUSH
95651: LD_VAR 0 10
95655: IN
95656: NOT
95657: AND
95658: IFFALSE 95697
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
95660: LD_VAR 0 4
95664: PPUSH
95665: LD_VAR 0 7
95669: PUSH
95670: LD_INT 1
95672: ARRAY
95673: PUSH
95674: LD_INT 1
95676: ARRAY
95677: PPUSH
95678: LD_VAR 0 7
95682: PUSH
95683: LD_INT 1
95685: ARRAY
95686: PUSH
95687: LD_INT 2
95689: ARRAY
95690: PPUSH
95691: CALL_OW 116
95695: GO 95986
// if path > tag then
95697: LD_VAR 0 2
95701: PUSH
95702: LD_VAR 0 9
95706: GREATER
95707: IFFALSE 95915
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
95709: LD_ADDR_VAR 0 6
95713: PUSH
95714: LD_VAR 0 5
95718: PPUSH
95719: LD_INT 91
95721: PUSH
95722: LD_VAR 0 4
95726: PUSH
95727: LD_INT 8
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: LIST
95734: PPUSH
95735: CALL_OW 72
95739: ST_TO_ADDR
// if nearEnemy then
95740: LD_VAR 0 6
95744: IFFALSE 95813
// begin if GetWeapon ( i ) = ru_time_lapser then
95746: LD_VAR 0 4
95750: PPUSH
95751: CALL_OW 264
95755: PUSH
95756: LD_INT 49
95758: EQUAL
95759: IFFALSE 95787
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
95761: LD_VAR 0 4
95765: PPUSH
95766: LD_VAR 0 6
95770: PPUSH
95771: LD_VAR 0 4
95775: PPUSH
95776: CALL_OW 74
95780: PPUSH
95781: CALL_OW 112
95785: GO 95811
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
95787: LD_VAR 0 4
95791: PPUSH
95792: LD_VAR 0 6
95796: PPUSH
95797: LD_VAR 0 4
95801: PPUSH
95802: CALL_OW 74
95806: PPUSH
95807: CALL 97071 0 2
// end else
95811: GO 95913
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
95813: LD_VAR 0 4
95817: PPUSH
95818: LD_VAR 0 2
95822: PUSH
95823: LD_VAR 0 9
95827: ARRAY
95828: PUSH
95829: LD_INT 1
95831: ARRAY
95832: PPUSH
95833: LD_VAR 0 2
95837: PUSH
95838: LD_VAR 0 9
95842: ARRAY
95843: PUSH
95844: LD_INT 2
95846: ARRAY
95847: PPUSH
95848: CALL_OW 297
95852: PUSH
95853: LD_INT 6
95855: GREATER
95856: IFFALSE 95899
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
95858: LD_VAR 0 4
95862: PPUSH
95863: LD_VAR 0 2
95867: PUSH
95868: LD_VAR 0 9
95872: ARRAY
95873: PUSH
95874: LD_INT 1
95876: ARRAY
95877: PPUSH
95878: LD_VAR 0 2
95882: PUSH
95883: LD_VAR 0 9
95887: ARRAY
95888: PUSH
95889: LD_INT 2
95891: ARRAY
95892: PPUSH
95893: CALL_OW 114
95897: GO 95913
// SetTag ( i , tag ) ;
95899: LD_VAR 0 4
95903: PPUSH
95904: LD_VAR 0 9
95908: PPUSH
95909: CALL_OW 109
// end else
95913: GO 95986
// if enemy then
95915: LD_VAR 0 5
95919: IFFALSE 95986
// begin if GetWeapon ( i ) = ru_time_lapser then
95921: LD_VAR 0 4
95925: PPUSH
95926: CALL_OW 264
95930: PUSH
95931: LD_INT 49
95933: EQUAL
95934: IFFALSE 95962
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
95936: LD_VAR 0 4
95940: PPUSH
95941: LD_VAR 0 5
95945: PPUSH
95946: LD_VAR 0 4
95950: PPUSH
95951: CALL_OW 74
95955: PPUSH
95956: CALL_OW 112
95960: GO 95986
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
95962: LD_VAR 0 4
95966: PPUSH
95967: LD_VAR 0 5
95971: PPUSH
95972: LD_VAR 0 4
95976: PPUSH
95977: CALL_OW 74
95981: PPUSH
95982: CALL 97071 0 2
// end ; end ;
95986: GO 95558
95988: POP
95989: POP
// end ;
95990: LD_VAR 0 3
95994: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
95995: LD_INT 0
95997: PPUSH
95998: PPUSH
95999: PPUSH
// if not unit or IsInUnit ( unit ) then
96000: LD_VAR 0 1
96004: NOT
96005: IFTRUE 96018
96007: PUSH
96008: LD_VAR 0 1
96012: PPUSH
96013: CALL_OW 310
96017: OR
96018: IFFALSE 96022
// exit ;
96020: GO 96113
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
96022: LD_ADDR_VAR 0 4
96026: PUSH
96027: LD_VAR 0 1
96031: PPUSH
96032: CALL_OW 250
96036: PPUSH
96037: LD_VAR 0 2
96041: PPUSH
96042: LD_INT 1
96044: PPUSH
96045: CALL_OW 272
96049: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
96050: LD_ADDR_VAR 0 5
96054: PUSH
96055: LD_VAR 0 1
96059: PPUSH
96060: CALL_OW 251
96064: PPUSH
96065: LD_VAR 0 2
96069: PPUSH
96070: LD_INT 1
96072: PPUSH
96073: CALL_OW 273
96077: ST_TO_ADDR
// if ValidHex ( x , y ) then
96078: LD_VAR 0 4
96082: PPUSH
96083: LD_VAR 0 5
96087: PPUSH
96088: CALL_OW 488
96092: IFFALSE 96113
// ComTurnXY ( unit , x , y ) ;
96094: LD_VAR 0 1
96098: PPUSH
96099: LD_VAR 0 4
96103: PPUSH
96104: LD_VAR 0 5
96108: PPUSH
96109: CALL_OW 118
// end ;
96113: LD_VAR 0 3
96117: RET
// export function SeeUnits ( side , units ) ; var i ; begin
96118: LD_INT 0
96120: PPUSH
96121: PPUSH
// result := false ;
96122: LD_ADDR_VAR 0 3
96126: PUSH
96127: LD_INT 0
96129: ST_TO_ADDR
// if not units then
96130: LD_VAR 0 2
96134: NOT
96135: IFFALSE 96139
// exit ;
96137: GO 96184
// for i in units do
96139: LD_ADDR_VAR 0 4
96143: PUSH
96144: LD_VAR 0 2
96148: PUSH
96149: FOR_IN
96150: IFFALSE 96182
// if See ( side , i ) then
96152: LD_VAR 0 1
96156: PPUSH
96157: LD_VAR 0 4
96161: PPUSH
96162: CALL_OW 292
96166: IFFALSE 96180
// begin result := true ;
96168: LD_ADDR_VAR 0 3
96172: PUSH
96173: LD_INT 1
96175: ST_TO_ADDR
// exit ;
96176: POP
96177: POP
96178: GO 96184
// end ;
96180: GO 96149
96182: POP
96183: POP
// end ;
96184: LD_VAR 0 3
96188: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
96189: LD_INT 0
96191: PPUSH
96192: PPUSH
96193: PPUSH
96194: PPUSH
// if not unit or not points then
96195: LD_VAR 0 1
96199: NOT
96200: IFTRUE 96209
96202: PUSH
96203: LD_VAR 0 2
96207: NOT
96208: OR
96209: IFFALSE 96213
// exit ;
96211: GO 96303
// dist := 99999 ;
96213: LD_ADDR_VAR 0 5
96217: PUSH
96218: LD_INT 99999
96220: ST_TO_ADDR
// for i in points do
96221: LD_ADDR_VAR 0 4
96225: PUSH
96226: LD_VAR 0 2
96230: PUSH
96231: FOR_IN
96232: IFFALSE 96301
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
96234: LD_ADDR_VAR 0 6
96238: PUSH
96239: LD_VAR 0 1
96243: PPUSH
96244: LD_VAR 0 4
96248: PUSH
96249: LD_INT 1
96251: ARRAY
96252: PPUSH
96253: LD_VAR 0 4
96257: PUSH
96258: LD_INT 2
96260: ARRAY
96261: PPUSH
96262: CALL_OW 297
96266: ST_TO_ADDR
// if tmpDist < dist then
96267: LD_VAR 0 6
96271: PUSH
96272: LD_VAR 0 5
96276: LESS
96277: IFFALSE 96299
// begin result := i ;
96279: LD_ADDR_VAR 0 3
96283: PUSH
96284: LD_VAR 0 4
96288: ST_TO_ADDR
// dist := tmpDist ;
96289: LD_ADDR_VAR 0 5
96293: PUSH
96294: LD_VAR 0 6
96298: ST_TO_ADDR
// end ; end ;
96299: GO 96231
96301: POP
96302: POP
// end ;
96303: LD_VAR 0 3
96307: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
96308: LD_INT 0
96310: PPUSH
// uc_side := side ;
96311: LD_ADDR_OWVAR 20
96315: PUSH
96316: LD_VAR 0 1
96320: ST_TO_ADDR
// uc_nation := 3 ;
96321: LD_ADDR_OWVAR 21
96325: PUSH
96326: LD_INT 3
96328: ST_TO_ADDR
// vc_chassis := 25 ;
96329: LD_ADDR_OWVAR 37
96333: PUSH
96334: LD_INT 25
96336: ST_TO_ADDR
// vc_engine := engine_siberite ;
96337: LD_ADDR_OWVAR 39
96341: PUSH
96342: LD_INT 3
96344: ST_TO_ADDR
// vc_control := control_computer ;
96345: LD_ADDR_OWVAR 38
96349: PUSH
96350: LD_INT 3
96352: ST_TO_ADDR
// vc_weapon := 59 ;
96353: LD_ADDR_OWVAR 40
96357: PUSH
96358: LD_INT 59
96360: ST_TO_ADDR
// result := CreateVehicle ;
96361: LD_ADDR_VAR 0 5
96365: PUSH
96366: CALL_OW 45
96370: ST_TO_ADDR
// SetDir ( result , d ) ;
96371: LD_VAR 0 5
96375: PPUSH
96376: LD_VAR 0 4
96380: PPUSH
96381: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
96385: LD_VAR 0 5
96389: PPUSH
96390: LD_VAR 0 2
96394: PPUSH
96395: LD_VAR 0 3
96399: PPUSH
96400: LD_INT 0
96402: PPUSH
96403: CALL_OW 48
// end ;
96407: LD_VAR 0 5
96411: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
96412: LD_INT 0
96414: PPUSH
96415: PPUSH
96416: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
96417: LD_ADDR_VAR 0 2
96421: PUSH
96422: LD_INT 0
96424: PUSH
96425: LD_INT 0
96427: PUSH
96428: LD_INT 0
96430: PUSH
96431: LD_INT 0
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
96440: LD_VAR 0 1
96444: NOT
96445: IFTRUE 96478
96447: PUSH
96448: LD_VAR 0 1
96452: PPUSH
96453: CALL_OW 264
96457: PUSH
96458: LD_INT 12
96460: PUSH
96461: LD_INT 51
96463: PUSH
96464: LD_INT 32
96466: PUSH
96467: LD_INT 89
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: IN
96476: NOT
96477: OR
96478: IFFALSE 96482
// exit ;
96480: GO 96580
// for i := 1 to 3 do
96482: LD_ADDR_VAR 0 3
96486: PUSH
96487: DOUBLE
96488: LD_INT 1
96490: DEC
96491: ST_TO_ADDR
96492: LD_INT 3
96494: PUSH
96495: FOR_TO
96496: IFFALSE 96578
// begin tmp := GetCargo ( cargo , i ) ;
96498: LD_ADDR_VAR 0 4
96502: PUSH
96503: LD_VAR 0 1
96507: PPUSH
96508: LD_VAR 0 3
96512: PPUSH
96513: CALL_OW 289
96517: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
96518: LD_ADDR_VAR 0 2
96522: PUSH
96523: LD_VAR 0 2
96527: PPUSH
96528: LD_VAR 0 3
96532: PPUSH
96533: LD_VAR 0 4
96537: PPUSH
96538: CALL_OW 1
96542: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
96543: LD_ADDR_VAR 0 2
96547: PUSH
96548: LD_VAR 0 2
96552: PPUSH
96553: LD_INT 4
96555: PPUSH
96556: LD_VAR 0 2
96560: PUSH
96561: LD_INT 4
96563: ARRAY
96564: PUSH
96565: LD_VAR 0 4
96569: PLUS
96570: PPUSH
96571: CALL_OW 1
96575: ST_TO_ADDR
// end ;
96576: GO 96495
96578: POP
96579: POP
// end ;
96580: LD_VAR 0 2
96584: RET
// export function Length ( array ) ; begin
96585: LD_INT 0
96587: PPUSH
// result := array + 0 ;
96588: LD_ADDR_VAR 0 2
96592: PUSH
96593: LD_VAR 0 1
96597: PUSH
96598: LD_INT 0
96600: PLUS
96601: ST_TO_ADDR
// end ;
96602: LD_VAR 0 2
96606: RET
// export function PrepareArray ( array ) ; begin
96607: LD_INT 0
96609: PPUSH
// result := array diff 0 ;
96610: LD_ADDR_VAR 0 2
96614: PUSH
96615: LD_VAR 0 1
96619: PUSH
96620: LD_INT 0
96622: DIFF
96623: ST_TO_ADDR
// if not result [ 1 ] then
96624: LD_VAR 0 2
96628: PUSH
96629: LD_INT 1
96631: ARRAY
96632: NOT
96633: IFFALSE 96653
// result := Delete ( result , 1 ) ;
96635: LD_ADDR_VAR 0 2
96639: PUSH
96640: LD_VAR 0 2
96644: PPUSH
96645: LD_INT 1
96647: PPUSH
96648: CALL_OW 3
96652: ST_TO_ADDR
// end ;
96653: LD_VAR 0 2
96657: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
96658: LD_INT 0
96660: PPUSH
96661: PPUSH
96662: PPUSH
96663: PPUSH
// sibRocketRange := 25 ;
96664: LD_ADDR_VAR 0 6
96668: PUSH
96669: LD_INT 25
96671: ST_TO_ADDR
// result := false ;
96672: LD_ADDR_VAR 0 4
96676: PUSH
96677: LD_INT 0
96679: ST_TO_ADDR
// for i := 0 to 5 do
96680: LD_ADDR_VAR 0 5
96684: PUSH
96685: DOUBLE
96686: LD_INT 0
96688: DEC
96689: ST_TO_ADDR
96690: LD_INT 5
96692: PUSH
96693: FOR_TO
96694: IFFALSE 96761
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
96696: LD_VAR 0 1
96700: PPUSH
96701: LD_VAR 0 5
96705: PPUSH
96706: LD_VAR 0 6
96710: PPUSH
96711: CALL_OW 272
96715: PPUSH
96716: LD_VAR 0 2
96720: PPUSH
96721: LD_VAR 0 5
96725: PPUSH
96726: LD_VAR 0 6
96730: PPUSH
96731: CALL_OW 273
96735: PPUSH
96736: LD_VAR 0 3
96740: PPUSH
96741: CALL_OW 309
96745: IFFALSE 96759
// begin result := true ;
96747: LD_ADDR_VAR 0 4
96751: PUSH
96752: LD_INT 1
96754: ST_TO_ADDR
// exit ;
96755: POP
96756: POP
96757: GO 96763
// end ;
96759: GO 96693
96761: POP
96762: POP
// end ;
96763: LD_VAR 0 4
96767: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
96768: LD_INT 0
96770: PPUSH
96771: PPUSH
96772: PPUSH
// if btype = b_depot then
96773: LD_VAR 0 2
96777: PUSH
96778: LD_INT 0
96780: EQUAL
96781: IFFALSE 96793
// begin result := true ;
96783: LD_ADDR_VAR 0 3
96787: PUSH
96788: LD_INT 1
96790: ST_TO_ADDR
// exit ;
96791: GO 96913
// end ; pom := GetBase ( depot ) ;
96793: LD_ADDR_VAR 0 4
96797: PUSH
96798: LD_VAR 0 1
96802: PPUSH
96803: CALL_OW 274
96807: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
96808: LD_ADDR_VAR 0 5
96812: PUSH
96813: LD_VAR 0 2
96817: PPUSH
96818: LD_VAR 0 1
96822: PPUSH
96823: CALL_OW 248
96827: PPUSH
96828: CALL_OW 450
96832: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
96833: LD_ADDR_VAR 0 3
96837: PUSH
96838: LD_VAR 0 4
96842: PPUSH
96843: LD_INT 1
96845: PPUSH
96846: CALL_OW 275
96850: PUSH
96851: LD_VAR 0 5
96855: PUSH
96856: LD_INT 1
96858: ARRAY
96859: GREATEREQUAL
96860: IFFALSE 96886
96862: PUSH
96863: LD_VAR 0 4
96867: PPUSH
96868: LD_INT 2
96870: PPUSH
96871: CALL_OW 275
96875: PUSH
96876: LD_VAR 0 5
96880: PUSH
96881: LD_INT 2
96883: ARRAY
96884: GREATEREQUAL
96885: AND
96886: IFFALSE 96912
96888: PUSH
96889: LD_VAR 0 4
96893: PPUSH
96894: LD_INT 3
96896: PPUSH
96897: CALL_OW 275
96901: PUSH
96902: LD_VAR 0 5
96906: PUSH
96907: LD_INT 3
96909: ARRAY
96910: GREATEREQUAL
96911: AND
96912: ST_TO_ADDR
// end ;
96913: LD_VAR 0 3
96917: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
96918: LD_INT 0
96920: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
96921: LD_VAR 0 1
96925: PPUSH
96926: LD_VAR 0 2
96930: PPUSH
96931: LD_INT 0
96933: PPUSH
96934: LD_INT 0
96936: PPUSH
96937: LD_INT 1
96939: PPUSH
96940: LD_INT 0
96942: PPUSH
96943: CALL_OW 587
// end ;
96947: LD_VAR 0 3
96951: RET
// export function CenterOnNow ( unit ) ; begin
96952: LD_INT 0
96954: PPUSH
// result := IsInUnit ( unit ) ;
96955: LD_ADDR_VAR 0 2
96959: PUSH
96960: LD_VAR 0 1
96964: PPUSH
96965: CALL_OW 310
96969: ST_TO_ADDR
// if not result then
96970: LD_VAR 0 2
96974: NOT
96975: IFFALSE 96987
// result := unit ;
96977: LD_ADDR_VAR 0 2
96981: PUSH
96982: LD_VAR 0 1
96986: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
96987: LD_VAR 0 1
96991: PPUSH
96992: CALL_OW 87
// end ;
96996: LD_VAR 0 2
97000: RET
// export function ComMoveHex ( unit , hex ) ; begin
97001: LD_INT 0
97003: PPUSH
// if not hex then
97004: LD_VAR 0 2
97008: NOT
97009: IFFALSE 97013
// exit ;
97011: GO 97066
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
97013: LD_VAR 0 2
97017: PUSH
97018: LD_INT 1
97020: ARRAY
97021: PPUSH
97022: LD_VAR 0 2
97026: PUSH
97027: LD_INT 2
97029: ARRAY
97030: PPUSH
97031: CALL_OW 428
97035: IFFALSE 97039
// exit ;
97037: GO 97066
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
97039: LD_VAR 0 1
97043: PPUSH
97044: LD_VAR 0 2
97048: PUSH
97049: LD_INT 1
97051: ARRAY
97052: PPUSH
97053: LD_VAR 0 2
97057: PUSH
97058: LD_INT 2
97060: ARRAY
97061: PPUSH
97062: CALL_OW 111
// end ;
97066: LD_VAR 0 3
97070: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
97071: LD_INT 0
97073: PPUSH
97074: PPUSH
97075: PPUSH
// if not unit or not enemy then
97076: LD_VAR 0 1
97080: NOT
97081: IFTRUE 97090
97083: PUSH
97084: LD_VAR 0 2
97088: NOT
97089: OR
97090: IFFALSE 97094
// exit ;
97092: GO 97220
// x := GetX ( enemy ) ;
97094: LD_ADDR_VAR 0 4
97098: PUSH
97099: LD_VAR 0 2
97103: PPUSH
97104: CALL_OW 250
97108: ST_TO_ADDR
// y := GetY ( enemy ) ;
97109: LD_ADDR_VAR 0 5
97113: PUSH
97114: LD_VAR 0 2
97118: PPUSH
97119: CALL_OW 251
97123: ST_TO_ADDR
// if ValidHex ( x , y ) then
97124: LD_VAR 0 4
97128: PPUSH
97129: LD_VAR 0 5
97133: PPUSH
97134: CALL_OW 488
97138: IFFALSE 97220
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
97140: LD_VAR 0 2
97144: PPUSH
97145: CALL_OW 247
97149: PUSH
97150: LD_INT 3
97152: PUSH
97153: LD_INT 2
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: IN
97160: IFTRUE 97183
97162: PUSH
97163: LD_VAR 0 1
97167: PPUSH
97168: CALL_OW 255
97172: PPUSH
97173: LD_VAR 0 2
97177: PPUSH
97178: CALL_OW 292
97182: OR
97183: IFFALSE 97201
// ComAttackUnit ( unit , enemy ) else
97185: LD_VAR 0 1
97189: PPUSH
97190: LD_VAR 0 2
97194: PPUSH
97195: CALL_OW 115
97199: GO 97220
// ComAgressiveMove ( unit , x , y ) ;
97201: LD_VAR 0 1
97205: PPUSH
97206: LD_VAR 0 4
97210: PPUSH
97211: LD_VAR 0 5
97215: PPUSH
97216: CALL_OW 114
// end ;
97220: LD_VAR 0 3
97224: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
97225: LD_INT 0
97227: PPUSH
97228: PPUSH
97229: PPUSH
// list := AreaToList ( area , 0 ) ;
97230: LD_ADDR_VAR 0 5
97234: PUSH
97235: LD_VAR 0 1
97239: PPUSH
97240: LD_INT 0
97242: PPUSH
97243: CALL_OW 517
97247: ST_TO_ADDR
// if not list then
97248: LD_VAR 0 5
97252: NOT
97253: IFFALSE 97257
// exit ;
97255: GO 97387
// if all then
97257: LD_VAR 0 2
97261: IFFALSE 97349
// begin for i := 1 to list [ 1 ] do
97263: LD_ADDR_VAR 0 4
97267: PUSH
97268: DOUBLE
97269: LD_INT 1
97271: DEC
97272: ST_TO_ADDR
97273: LD_VAR 0 5
97277: PUSH
97278: LD_INT 1
97280: ARRAY
97281: PUSH
97282: FOR_TO
97283: IFFALSE 97345
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
97285: LD_ADDR_VAR 0 3
97289: PUSH
97290: LD_VAR 0 3
97294: PPUSH
97295: LD_VAR 0 3
97299: PUSH
97300: LD_INT 1
97302: PLUS
97303: PPUSH
97304: LD_VAR 0 5
97308: PUSH
97309: LD_INT 1
97311: ARRAY
97312: PUSH
97313: LD_VAR 0 4
97317: ARRAY
97318: PUSH
97319: LD_VAR 0 5
97323: PUSH
97324: LD_INT 2
97326: ARRAY
97327: PUSH
97328: LD_VAR 0 4
97332: ARRAY
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PPUSH
97338: CALL_OW 1
97342: ST_TO_ADDR
97343: GO 97282
97345: POP
97346: POP
// exit ;
97347: GO 97387
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
97349: LD_ADDR_VAR 0 3
97353: PUSH
97354: LD_VAR 0 5
97358: PUSH
97359: LD_INT 1
97361: ARRAY
97362: PUSH
97363: LD_INT 1
97365: ARRAY
97366: PUSH
97367: LD_VAR 0 5
97371: PUSH
97372: LD_INT 2
97374: ARRAY
97375: PUSH
97376: LD_INT 1
97378: ARRAY
97379: PUSH
97380: EMPTY
97381: LIST
97382: LIST
97383: PUSH
97384: EMPTY
97385: LIST
97386: ST_TO_ADDR
// end ;
97387: LD_VAR 0 3
97391: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
97392: LD_INT 0
97394: PPUSH
97395: PPUSH
// list := AreaToList ( area , 0 ) ;
97396: LD_ADDR_VAR 0 4
97400: PUSH
97401: LD_VAR 0 1
97405: PPUSH
97406: LD_INT 0
97408: PPUSH
97409: CALL_OW 517
97413: ST_TO_ADDR
// if not list then
97414: LD_VAR 0 4
97418: NOT
97419: IFFALSE 97423
// exit ;
97421: GO 97464
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
97423: LD_ADDR_VAR 0 3
97427: PUSH
97428: LD_VAR 0 4
97432: PUSH
97433: LD_INT 1
97435: ARRAY
97436: PUSH
97437: LD_INT 1
97439: ARRAY
97440: PUSH
97441: LD_VAR 0 4
97445: PUSH
97446: LD_INT 2
97448: ARRAY
97449: PUSH
97450: LD_INT 1
97452: ARRAY
97453: PUSH
97454: LD_VAR 0 2
97458: PUSH
97459: EMPTY
97460: LIST
97461: LIST
97462: LIST
97463: ST_TO_ADDR
// end ;
97464: LD_VAR 0 3
97468: RET
// export function First ( array ) ; begin
97469: LD_INT 0
97471: PPUSH
// if not array then
97472: LD_VAR 0 1
97476: NOT
97477: IFFALSE 97481
// exit ;
97479: GO 97495
// result := array [ 1 ] ;
97481: LD_ADDR_VAR 0 2
97485: PUSH
97486: LD_VAR 0 1
97490: PUSH
97491: LD_INT 1
97493: ARRAY
97494: ST_TO_ADDR
// end ;
97495: LD_VAR 0 2
97499: RET
// export function Last ( array ) ; begin
97500: LD_INT 0
97502: PPUSH
// if not array then
97503: LD_VAR 0 1
97507: NOT
97508: IFFALSE 97512
// exit ;
97510: GO 97528
// result := array [ array ] ;
97512: LD_ADDR_VAR 0 2
97516: PUSH
97517: LD_VAR 0 1
97521: PUSH
97522: LD_VAR 0 1
97526: ARRAY
97527: ST_TO_ADDR
// end ;
97528: LD_VAR 0 2
97532: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
97533: LD_INT 0
97535: PPUSH
97536: PPUSH
// result := [ ] ;
97537: LD_ADDR_VAR 0 5
97541: PUSH
97542: EMPTY
97543: ST_TO_ADDR
// if not array then
97544: LD_VAR 0 1
97548: NOT
97549: IFFALSE 97553
// exit ;
97551: GO 97665
// for i := 1 to array do
97553: LD_ADDR_VAR 0 6
97557: PUSH
97558: DOUBLE
97559: LD_INT 1
97561: DEC
97562: ST_TO_ADDR
97563: LD_VAR 0 1
97567: PUSH
97568: FOR_TO
97569: IFFALSE 97663
// if array [ i ] [ index ] = value then
97571: LD_VAR 0 1
97575: PUSH
97576: LD_VAR 0 6
97580: ARRAY
97581: PUSH
97582: LD_VAR 0 2
97586: ARRAY
97587: PUSH
97588: LD_VAR 0 3
97592: EQUAL
97593: IFFALSE 97661
// begin if indexColumn then
97595: LD_VAR 0 4
97599: IFFALSE 97635
// result := Join ( result , array [ i ] [ indexColumn ] ) else
97601: LD_ADDR_VAR 0 5
97605: PUSH
97606: LD_VAR 0 5
97610: PPUSH
97611: LD_VAR 0 1
97615: PUSH
97616: LD_VAR 0 6
97620: ARRAY
97621: PUSH
97622: LD_VAR 0 4
97626: ARRAY
97627: PPUSH
97628: CALL 92673 0 2
97632: ST_TO_ADDR
97633: GO 97661
// result := Join ( result , array [ i ] ) ;
97635: LD_ADDR_VAR 0 5
97639: PUSH
97640: LD_VAR 0 5
97644: PPUSH
97645: LD_VAR 0 1
97649: PUSH
97650: LD_VAR 0 6
97654: ARRAY
97655: PPUSH
97656: CALL 92673 0 2
97660: ST_TO_ADDR
// end ;
97661: GO 97568
97663: POP
97664: POP
// end ;
97665: LD_VAR 0 5
97669: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
97670: LD_INT 0
97672: PPUSH
// if not vehicles or not parkingPoint then
97673: LD_VAR 0 1
97677: NOT
97678: IFTRUE 97687
97680: PUSH
97681: LD_VAR 0 2
97685: NOT
97686: OR
97687: IFFALSE 97691
// exit ;
97689: GO 97789
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
97691: LD_ADDR_VAR 0 1
97695: PUSH
97696: LD_VAR 0 1
97700: PPUSH
97701: LD_INT 50
97703: PUSH
97704: EMPTY
97705: LIST
97706: PUSH
97707: LD_INT 3
97709: PUSH
97710: LD_INT 92
97712: PUSH
97713: LD_VAR 0 2
97717: PUSH
97718: LD_INT 1
97720: ARRAY
97721: PUSH
97722: LD_VAR 0 2
97726: PUSH
97727: LD_INT 2
97729: ARRAY
97730: PUSH
97731: LD_INT 8
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: PUSH
97740: EMPTY
97741: LIST
97742: LIST
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PPUSH
97748: CALL_OW 72
97752: ST_TO_ADDR
// if not vehicles then
97753: LD_VAR 0 1
97757: NOT
97758: IFFALSE 97762
// exit ;
97760: GO 97789
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
97762: LD_VAR 0 1
97766: PPUSH
97767: LD_VAR 0 2
97771: PUSH
97772: LD_INT 1
97774: ARRAY
97775: PPUSH
97776: LD_VAR 0 2
97780: PUSH
97781: LD_INT 2
97783: ARRAY
97784: PPUSH
97785: CALL_OW 111
// end ;
97789: LD_VAR 0 3
97793: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
97794: LD_INT 0
97796: PPUSH
97797: PPUSH
97798: PPUSH
// if not side or not area then
97799: LD_VAR 0 1
97803: NOT
97804: IFTRUE 97813
97806: PUSH
97807: LD_VAR 0 2
97811: NOT
97812: OR
97813: IFFALSE 97817
// exit ;
97815: GO 97936
// tmp := AreaToList ( area , 0 ) ;
97817: LD_ADDR_VAR 0 5
97821: PUSH
97822: LD_VAR 0 2
97826: PPUSH
97827: LD_INT 0
97829: PPUSH
97830: CALL_OW 517
97834: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
97835: LD_ADDR_VAR 0 4
97839: PUSH
97840: DOUBLE
97841: LD_INT 1
97843: DEC
97844: ST_TO_ADDR
97845: LD_VAR 0 5
97849: PUSH
97850: LD_INT 1
97852: ARRAY
97853: PUSH
97854: FOR_TO
97855: IFFALSE 97934
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
97857: LD_VAR 0 5
97861: PUSH
97862: LD_INT 1
97864: ARRAY
97865: PUSH
97866: LD_VAR 0 4
97870: ARRAY
97871: PPUSH
97872: LD_VAR 0 5
97876: PUSH
97877: LD_INT 2
97879: ARRAY
97880: PUSH
97881: LD_VAR 0 4
97885: ARRAY
97886: PPUSH
97887: CALL_OW 351
97891: IFFALSE 97932
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
97893: LD_VAR 0 5
97897: PUSH
97898: LD_INT 1
97900: ARRAY
97901: PUSH
97902: LD_VAR 0 4
97906: ARRAY
97907: PPUSH
97908: LD_VAR 0 5
97912: PUSH
97913: LD_INT 2
97915: ARRAY
97916: PUSH
97917: LD_VAR 0 4
97921: ARRAY
97922: PPUSH
97923: LD_VAR 0 1
97927: PPUSH
97928: CALL_OW 244
// end ;
97932: GO 97854
97934: POP
97935: POP
// end ;
97936: LD_VAR 0 3
97940: RET
// export function UniqueArray ( array ) ; var i ; begin
97941: LD_INT 0
97943: PPUSH
97944: PPUSH
// result := [ ] ;
97945: LD_ADDR_VAR 0 2
97949: PUSH
97950: EMPTY
97951: ST_TO_ADDR
// if not array then
97952: LD_VAR 0 1
97956: NOT
97957: IFFALSE 97961
// exit ;
97959: GO 98022
// for i := 1 to array do
97961: LD_ADDR_VAR 0 3
97965: PUSH
97966: DOUBLE
97967: LD_INT 1
97969: DEC
97970: ST_TO_ADDR
97971: LD_VAR 0 1
97975: PUSH
97976: FOR_TO
97977: IFFALSE 98020
// if not array [ i ] in result then
97979: LD_VAR 0 1
97983: PUSH
97984: LD_VAR 0 3
97988: ARRAY
97989: PUSH
97990: LD_VAR 0 2
97994: IN
97995: NOT
97996: IFFALSE 98018
// result := Join ( result , i ) ;
97998: LD_ADDR_VAR 0 2
98002: PUSH
98003: LD_VAR 0 2
98007: PPUSH
98008: LD_VAR 0 3
98012: PPUSH
98013: CALL 92673 0 2
98017: ST_TO_ADDR
98018: GO 97976
98020: POP
98021: POP
// end ; end_of_file end_of_file
98022: LD_VAR 0 2
98026: RET
// export globalGameSaveCounter ; every 0 0$1 do
98027: GO 98029
98029: DISABLE
// begin enable ;
98030: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
98031: LD_STRING updateTimer(
98033: PUSH
98034: LD_OWVAR 1
98038: STR
98039: PUSH
98040: LD_STRING );
98042: STR
98043: PPUSH
98044: CALL_OW 559
// end ;
98048: END
// every 0 0$1 do
98049: GO 98051
98051: DISABLE
// begin globalGameSaveCounter := 0 ;
98052: LD_ADDR_EXP 125
98056: PUSH
98057: LD_INT 0
98059: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
98060: LD_STRING setGameSaveCounter(0)
98062: PPUSH
98063: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
98067: LD_STRING initStreamRollete();
98069: PPUSH
98070: CALL_OW 559
// InitStreamMode ;
98074: CALL 99426 0 0
// DefineStreamItems ( false ) ;
98078: LD_INT 0
98080: PPUSH
98081: CALL 99890 0 1
// end ;
98085: END
// export function SOS_MapStart ( ) ; begin
98086: LD_INT 0
98088: PPUSH
// if streamModeActive then
98089: LD_EXP 126
98093: IFFALSE 98102
// DefineStreamItems ( true ) ;
98095: LD_INT 1
98097: PPUSH
98098: CALL 99890 0 1
// ToLua ( LFC_UNITS_CUSTOM_ICON = {}; ) ;
98102: LD_STRING LFC_UNITS_CUSTOM_ICON = {};
98104: PPUSH
98105: CALL_OW 559
// UpdateLuaVariables ( ) ;
98109: CALL 98126 0 0
// UpdateFactoryWaypoints ( ) ;
98113: CALL 113012 0 0
// UpdateWarehouseGatheringPoints ( ) ;
98117: CALL 113264 0 0
// end ;
98121: LD_VAR 0 1
98125: RET
// function UpdateLuaVariables ( ) ; begin
98126: LD_INT 0
98128: PPUSH
// if globalGameSaveCounter then
98129: LD_EXP 125
98133: IFFALSE 98167
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
98135: LD_ADDR_EXP 125
98139: PUSH
98140: LD_EXP 125
98144: PPUSH
98145: CALL 94046 0 1
98149: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
98150: LD_STRING setGameSaveCounter(
98152: PUSH
98153: LD_EXP 125
98157: STR
98158: PUSH
98159: LD_STRING )
98161: STR
98162: PPUSH
98163: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
98167: LD_STRING setGameDifficulty(
98169: PUSH
98170: LD_OWVAR 67
98174: STR
98175: PUSH
98176: LD_STRING )
98178: STR
98179: PPUSH
98180: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
98184: LD_STRING displayDifficulty(
98186: PUSH
98187: LD_OWVAR 67
98191: STR
98192: PUSH
98193: LD_STRING )
98195: STR
98196: PPUSH
98197: CALL_OW 559
// end ;
98201: LD_VAR 0 1
98205: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98206: LD_INT 0
98208: PPUSH
// if p2 = stream_mode then
98209: LD_VAR 0 2
98213: PUSH
98214: LD_INT 100
98216: EQUAL
98217: IFFALSE 99220
// begin if not StreamModeActive then
98219: LD_EXP 126
98223: NOT
98224: IFFALSE 98234
// StreamModeActive := true ;
98226: LD_ADDR_EXP 126
98230: PUSH
98231: LD_INT 1
98233: ST_TO_ADDR
// if p3 = 0 then
98234: LD_VAR 0 3
98238: PUSH
98239: LD_INT 0
98241: EQUAL
98242: IFFALSE 98248
// InitStreamMode ;
98244: CALL 99426 0 0
// if p3 = 1 then
98248: LD_VAR 0 3
98252: PUSH
98253: LD_INT 1
98255: EQUAL
98256: IFFALSE 98266
// sRocket := true ;
98258: LD_ADDR_EXP 131
98262: PUSH
98263: LD_INT 1
98265: ST_TO_ADDR
// if p3 = 2 then
98266: LD_VAR 0 3
98270: PUSH
98271: LD_INT 2
98273: EQUAL
98274: IFFALSE 98284
// sSpeed := true ;
98276: LD_ADDR_EXP 130
98280: PUSH
98281: LD_INT 1
98283: ST_TO_ADDR
// if p3 = 3 then
98284: LD_VAR 0 3
98288: PUSH
98289: LD_INT 3
98291: EQUAL
98292: IFFALSE 98302
// sEngine := true ;
98294: LD_ADDR_EXP 132
98298: PUSH
98299: LD_INT 1
98301: ST_TO_ADDR
// if p3 = 4 then
98302: LD_VAR 0 3
98306: PUSH
98307: LD_INT 4
98309: EQUAL
98310: IFFALSE 98320
// sSpec := true ;
98312: LD_ADDR_EXP 129
98316: PUSH
98317: LD_INT 1
98319: ST_TO_ADDR
// if p3 = 5 then
98320: LD_VAR 0 3
98324: PUSH
98325: LD_INT 5
98327: EQUAL
98328: IFFALSE 98338
// sLevel := true ;
98330: LD_ADDR_EXP 133
98334: PUSH
98335: LD_INT 1
98337: ST_TO_ADDR
// if p3 = 6 then
98338: LD_VAR 0 3
98342: PUSH
98343: LD_INT 6
98345: EQUAL
98346: IFFALSE 98356
// sArmoury := true ;
98348: LD_ADDR_EXP 134
98352: PUSH
98353: LD_INT 1
98355: ST_TO_ADDR
// if p3 = 7 then
98356: LD_VAR 0 3
98360: PUSH
98361: LD_INT 7
98363: EQUAL
98364: IFFALSE 98374
// sRadar := true ;
98366: LD_ADDR_EXP 135
98370: PUSH
98371: LD_INT 1
98373: ST_TO_ADDR
// if p3 = 8 then
98374: LD_VAR 0 3
98378: PUSH
98379: LD_INT 8
98381: EQUAL
98382: IFFALSE 98392
// sBunker := true ;
98384: LD_ADDR_EXP 136
98388: PUSH
98389: LD_INT 1
98391: ST_TO_ADDR
// if p3 = 9 then
98392: LD_VAR 0 3
98396: PUSH
98397: LD_INT 9
98399: EQUAL
98400: IFFALSE 98410
// sHack := true ;
98402: LD_ADDR_EXP 137
98406: PUSH
98407: LD_INT 1
98409: ST_TO_ADDR
// if p3 = 10 then
98410: LD_VAR 0 3
98414: PUSH
98415: LD_INT 10
98417: EQUAL
98418: IFFALSE 98428
// sFire := true ;
98420: LD_ADDR_EXP 138
98424: PUSH
98425: LD_INT 1
98427: ST_TO_ADDR
// if p3 = 11 then
98428: LD_VAR 0 3
98432: PUSH
98433: LD_INT 11
98435: EQUAL
98436: IFFALSE 98446
// sRefresh := true ;
98438: LD_ADDR_EXP 139
98442: PUSH
98443: LD_INT 1
98445: ST_TO_ADDR
// if p3 = 12 then
98446: LD_VAR 0 3
98450: PUSH
98451: LD_INT 12
98453: EQUAL
98454: IFFALSE 98464
// sExp := true ;
98456: LD_ADDR_EXP 140
98460: PUSH
98461: LD_INT 1
98463: ST_TO_ADDR
// if p3 = 13 then
98464: LD_VAR 0 3
98468: PUSH
98469: LD_INT 13
98471: EQUAL
98472: IFFALSE 98482
// sDepot := true ;
98474: LD_ADDR_EXP 141
98478: PUSH
98479: LD_INT 1
98481: ST_TO_ADDR
// if p3 = 14 then
98482: LD_VAR 0 3
98486: PUSH
98487: LD_INT 14
98489: EQUAL
98490: IFFALSE 98500
// sFlag := true ;
98492: LD_ADDR_EXP 142
98496: PUSH
98497: LD_INT 1
98499: ST_TO_ADDR
// if p3 = 15 then
98500: LD_VAR 0 3
98504: PUSH
98505: LD_INT 15
98507: EQUAL
98508: IFFALSE 98518
// sKamikadze := true ;
98510: LD_ADDR_EXP 150
98514: PUSH
98515: LD_INT 1
98517: ST_TO_ADDR
// if p3 = 16 then
98518: LD_VAR 0 3
98522: PUSH
98523: LD_INT 16
98525: EQUAL
98526: IFFALSE 98536
// sTroll := true ;
98528: LD_ADDR_EXP 151
98532: PUSH
98533: LD_INT 1
98535: ST_TO_ADDR
// if p3 = 17 then
98536: LD_VAR 0 3
98540: PUSH
98541: LD_INT 17
98543: EQUAL
98544: IFFALSE 98554
// sSlow := true ;
98546: LD_ADDR_EXP 152
98550: PUSH
98551: LD_INT 1
98553: ST_TO_ADDR
// if p3 = 18 then
98554: LD_VAR 0 3
98558: PUSH
98559: LD_INT 18
98561: EQUAL
98562: IFFALSE 98572
// sLack := true ;
98564: LD_ADDR_EXP 153
98568: PUSH
98569: LD_INT 1
98571: ST_TO_ADDR
// if p3 = 19 then
98572: LD_VAR 0 3
98576: PUSH
98577: LD_INT 19
98579: EQUAL
98580: IFFALSE 98590
// sTank := true ;
98582: LD_ADDR_EXP 155
98586: PUSH
98587: LD_INT 1
98589: ST_TO_ADDR
// if p3 = 20 then
98590: LD_VAR 0 3
98594: PUSH
98595: LD_INT 20
98597: EQUAL
98598: IFFALSE 98608
// sRemote := true ;
98600: LD_ADDR_EXP 156
98604: PUSH
98605: LD_INT 1
98607: ST_TO_ADDR
// if p3 = 21 then
98608: LD_VAR 0 3
98612: PUSH
98613: LD_INT 21
98615: EQUAL
98616: IFFALSE 98626
// sPowell := true ;
98618: LD_ADDR_EXP 157
98622: PUSH
98623: LD_INT 1
98625: ST_TO_ADDR
// if p3 = 22 then
98626: LD_VAR 0 3
98630: PUSH
98631: LD_INT 22
98633: EQUAL
98634: IFFALSE 98644
// sTeleport := true ;
98636: LD_ADDR_EXP 160
98640: PUSH
98641: LD_INT 1
98643: ST_TO_ADDR
// if p3 = 23 then
98644: LD_VAR 0 3
98648: PUSH
98649: LD_INT 23
98651: EQUAL
98652: IFFALSE 98662
// sOilTower := true ;
98654: LD_ADDR_EXP 162
98658: PUSH
98659: LD_INT 1
98661: ST_TO_ADDR
// if p3 = 24 then
98662: LD_VAR 0 3
98666: PUSH
98667: LD_INT 24
98669: EQUAL
98670: IFFALSE 98680
// sShovel := true ;
98672: LD_ADDR_EXP 163
98676: PUSH
98677: LD_INT 1
98679: ST_TO_ADDR
// if p3 = 25 then
98680: LD_VAR 0 3
98684: PUSH
98685: LD_INT 25
98687: EQUAL
98688: IFFALSE 98698
// sSheik := true ;
98690: LD_ADDR_EXP 164
98694: PUSH
98695: LD_INT 1
98697: ST_TO_ADDR
// if p3 = 26 then
98698: LD_VAR 0 3
98702: PUSH
98703: LD_INT 26
98705: EQUAL
98706: IFFALSE 98716
// sEarthquake := true ;
98708: LD_ADDR_EXP 166
98712: PUSH
98713: LD_INT 1
98715: ST_TO_ADDR
// if p3 = 27 then
98716: LD_VAR 0 3
98720: PUSH
98721: LD_INT 27
98723: EQUAL
98724: IFFALSE 98734
// sAI := true ;
98726: LD_ADDR_EXP 167
98730: PUSH
98731: LD_INT 1
98733: ST_TO_ADDR
// if p3 = 28 then
98734: LD_VAR 0 3
98738: PUSH
98739: LD_INT 28
98741: EQUAL
98742: IFFALSE 98752
// sCargo := true ;
98744: LD_ADDR_EXP 170
98748: PUSH
98749: LD_INT 1
98751: ST_TO_ADDR
// if p3 = 29 then
98752: LD_VAR 0 3
98756: PUSH
98757: LD_INT 29
98759: EQUAL
98760: IFFALSE 98770
// sDLaser := true ;
98762: LD_ADDR_EXP 171
98766: PUSH
98767: LD_INT 1
98769: ST_TO_ADDR
// if p3 = 30 then
98770: LD_VAR 0 3
98774: PUSH
98775: LD_INT 30
98777: EQUAL
98778: IFFALSE 98788
// sExchange := true ;
98780: LD_ADDR_EXP 172
98784: PUSH
98785: LD_INT 1
98787: ST_TO_ADDR
// if p3 = 31 then
98788: LD_VAR 0 3
98792: PUSH
98793: LD_INT 31
98795: EQUAL
98796: IFFALSE 98806
// sFac := true ;
98798: LD_ADDR_EXP 173
98802: PUSH
98803: LD_INT 1
98805: ST_TO_ADDR
// if p3 = 32 then
98806: LD_VAR 0 3
98810: PUSH
98811: LD_INT 32
98813: EQUAL
98814: IFFALSE 98824
// sPower := true ;
98816: LD_ADDR_EXP 174
98820: PUSH
98821: LD_INT 1
98823: ST_TO_ADDR
// if p3 = 33 then
98824: LD_VAR 0 3
98828: PUSH
98829: LD_INT 33
98831: EQUAL
98832: IFFALSE 98842
// sRandom := true ;
98834: LD_ADDR_EXP 175
98838: PUSH
98839: LD_INT 1
98841: ST_TO_ADDR
// if p3 = 34 then
98842: LD_VAR 0 3
98846: PUSH
98847: LD_INT 34
98849: EQUAL
98850: IFFALSE 98860
// sShield := true ;
98852: LD_ADDR_EXP 176
98856: PUSH
98857: LD_INT 1
98859: ST_TO_ADDR
// if p3 = 35 then
98860: LD_VAR 0 3
98864: PUSH
98865: LD_INT 35
98867: EQUAL
98868: IFFALSE 98878
// sTime := true ;
98870: LD_ADDR_EXP 177
98874: PUSH
98875: LD_INT 1
98877: ST_TO_ADDR
// if p3 = 36 then
98878: LD_VAR 0 3
98882: PUSH
98883: LD_INT 36
98885: EQUAL
98886: IFFALSE 98896
// sTools := true ;
98888: LD_ADDR_EXP 178
98892: PUSH
98893: LD_INT 1
98895: ST_TO_ADDR
// if p3 = 101 then
98896: LD_VAR 0 3
98900: PUSH
98901: LD_INT 101
98903: EQUAL
98904: IFFALSE 98914
// sSold := true ;
98906: LD_ADDR_EXP 143
98910: PUSH
98911: LD_INT 1
98913: ST_TO_ADDR
// if p3 = 102 then
98914: LD_VAR 0 3
98918: PUSH
98919: LD_INT 102
98921: EQUAL
98922: IFFALSE 98932
// sDiff := true ;
98924: LD_ADDR_EXP 144
98928: PUSH
98929: LD_INT 1
98931: ST_TO_ADDR
// if p3 = 103 then
98932: LD_VAR 0 3
98936: PUSH
98937: LD_INT 103
98939: EQUAL
98940: IFFALSE 98950
// sFog := true ;
98942: LD_ADDR_EXP 147
98946: PUSH
98947: LD_INT 1
98949: ST_TO_ADDR
// if p3 = 104 then
98950: LD_VAR 0 3
98954: PUSH
98955: LD_INT 104
98957: EQUAL
98958: IFFALSE 98968
// sReset := true ;
98960: LD_ADDR_EXP 148
98964: PUSH
98965: LD_INT 1
98967: ST_TO_ADDR
// if p3 = 105 then
98968: LD_VAR 0 3
98972: PUSH
98973: LD_INT 105
98975: EQUAL
98976: IFFALSE 98986
// sSun := true ;
98978: LD_ADDR_EXP 149
98982: PUSH
98983: LD_INT 1
98985: ST_TO_ADDR
// if p3 = 106 then
98986: LD_VAR 0 3
98990: PUSH
98991: LD_INT 106
98993: EQUAL
98994: IFFALSE 99004
// sTiger := true ;
98996: LD_ADDR_EXP 145
99000: PUSH
99001: LD_INT 1
99003: ST_TO_ADDR
// if p3 = 107 then
99004: LD_VAR 0 3
99008: PUSH
99009: LD_INT 107
99011: EQUAL
99012: IFFALSE 99022
// sBomb := true ;
99014: LD_ADDR_EXP 146
99018: PUSH
99019: LD_INT 1
99021: ST_TO_ADDR
// if p3 = 108 then
99022: LD_VAR 0 3
99026: PUSH
99027: LD_INT 108
99029: EQUAL
99030: IFFALSE 99040
// sWound := true ;
99032: LD_ADDR_EXP 154
99036: PUSH
99037: LD_INT 1
99039: ST_TO_ADDR
// if p3 = 109 then
99040: LD_VAR 0 3
99044: PUSH
99045: LD_INT 109
99047: EQUAL
99048: IFFALSE 99058
// sBetray := true ;
99050: LD_ADDR_EXP 158
99054: PUSH
99055: LD_INT 1
99057: ST_TO_ADDR
// if p3 = 110 then
99058: LD_VAR 0 3
99062: PUSH
99063: LD_INT 110
99065: EQUAL
99066: IFFALSE 99076
// sContamin := true ;
99068: LD_ADDR_EXP 159
99072: PUSH
99073: LD_INT 1
99075: ST_TO_ADDR
// if p3 = 111 then
99076: LD_VAR 0 3
99080: PUSH
99081: LD_INT 111
99083: EQUAL
99084: IFFALSE 99094
// sOil := true ;
99086: LD_ADDR_EXP 161
99090: PUSH
99091: LD_INT 1
99093: ST_TO_ADDR
// if p3 = 112 then
99094: LD_VAR 0 3
99098: PUSH
99099: LD_INT 112
99101: EQUAL
99102: IFFALSE 99112
// sStu := true ;
99104: LD_ADDR_EXP 165
99108: PUSH
99109: LD_INT 1
99111: ST_TO_ADDR
// if p3 = 113 then
99112: LD_VAR 0 3
99116: PUSH
99117: LD_INT 113
99119: EQUAL
99120: IFFALSE 99130
// sBazooka := true ;
99122: LD_ADDR_EXP 168
99126: PUSH
99127: LD_INT 1
99129: ST_TO_ADDR
// if p3 = 114 then
99130: LD_VAR 0 3
99134: PUSH
99135: LD_INT 114
99137: EQUAL
99138: IFFALSE 99148
// sMortar := true ;
99140: LD_ADDR_EXP 169
99144: PUSH
99145: LD_INT 1
99147: ST_TO_ADDR
// if p3 = 115 then
99148: LD_VAR 0 3
99152: PUSH
99153: LD_INT 115
99155: EQUAL
99156: IFFALSE 99166
// sRanger := true ;
99158: LD_ADDR_EXP 179
99162: PUSH
99163: LD_INT 1
99165: ST_TO_ADDR
// if p3 = 116 then
99166: LD_VAR 0 3
99170: PUSH
99171: LD_INT 116
99173: EQUAL
99174: IFFALSE 99184
// sComputer := true ;
99176: LD_ADDR_EXP 180
99180: PUSH
99181: LD_INT 1
99183: ST_TO_ADDR
// if p3 = 117 then
99184: LD_VAR 0 3
99188: PUSH
99189: LD_INT 117
99191: EQUAL
99192: IFFALSE 99202
// s30 := true ;
99194: LD_ADDR_EXP 181
99198: PUSH
99199: LD_INT 1
99201: ST_TO_ADDR
// if p3 = 118 then
99202: LD_VAR 0 3
99206: PUSH
99207: LD_INT 118
99209: EQUAL
99210: IFFALSE 99220
// s60 := true ;
99212: LD_ADDR_EXP 182
99216: PUSH
99217: LD_INT 1
99219: ST_TO_ADDR
// end ; if p2 = hack_mode then
99220: LD_VAR 0 2
99224: PUSH
99225: LD_INT 101
99227: EQUAL
99228: IFFALSE 99356
// begin case p3 of 1 :
99230: LD_VAR 0 3
99234: PUSH
99235: LD_INT 1
99237: DOUBLE
99238: EQUAL
99239: IFTRUE 99243
99241: GO 99250
99243: POP
// hHackUnlimitedResources ; 2 :
99244: CALL 111619 0 0
99248: GO 99356
99250: LD_INT 2
99252: DOUBLE
99253: EQUAL
99254: IFTRUE 99258
99256: GO 99265
99258: POP
// hHackSetLevel10 ; 3 :
99259: CALL 111752 0 0
99263: GO 99356
99265: LD_INT 3
99267: DOUBLE
99268: EQUAL
99269: IFTRUE 99273
99271: GO 99280
99273: POP
// hHackSetLevel10YourUnits ; 4 :
99274: CALL 111837 0 0
99278: GO 99356
99280: LD_INT 4
99282: DOUBLE
99283: EQUAL
99284: IFTRUE 99288
99286: GO 99295
99288: POP
// hHackInvincible ; 5 :
99289: CALL 112285 0 0
99293: GO 99356
99295: LD_INT 5
99297: DOUBLE
99298: EQUAL
99299: IFTRUE 99303
99301: GO 99310
99303: POP
// hHackInvisible ; 6 :
99304: CALL 112396 0 0
99308: GO 99356
99310: LD_INT 6
99312: DOUBLE
99313: EQUAL
99314: IFTRUE 99318
99316: GO 99325
99318: POP
// hHackChangeYourSide ; 7 :
99319: CALL 112453 0 0
99323: GO 99356
99325: LD_INT 7
99327: DOUBLE
99328: EQUAL
99329: IFTRUE 99333
99331: GO 99340
99333: POP
// hHackChangeUnitSide ; 8 :
99334: CALL 112495 0 0
99338: GO 99356
99340: LD_INT 8
99342: DOUBLE
99343: EQUAL
99344: IFTRUE 99348
99346: GO 99355
99348: POP
// hHackFog ; end ;
99349: CALL 112596 0 0
99353: GO 99356
99355: POP
// end ; if p2 = game_save_mode then
99356: LD_VAR 0 2
99360: PUSH
99361: LD_INT 102
99363: EQUAL
99364: IFFALSE 99421
// begin if p3 = 1 then
99366: LD_VAR 0 3
99370: PUSH
99371: LD_INT 1
99373: EQUAL
99374: IFFALSE 99386
// globalGameSaveCounter := p4 ;
99376: LD_ADDR_EXP 125
99380: PUSH
99381: LD_VAR 0 4
99385: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
99386: LD_VAR 0 3
99390: PUSH
99391: LD_INT 2
99393: EQUAL
99394: IFFALSE 99402
99396: PUSH
99397: LD_EXP 125
99401: AND
99402: IFFALSE 99421
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
99404: LD_STRING setGameSaveCounter(
99406: PUSH
99407: LD_EXP 125
99411: STR
99412: PUSH
99413: LD_STRING )
99415: STR
99416: PPUSH
99417: CALL_OW 559
// end ; end ;
99421: LD_VAR 0 7
99425: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
99426: LD_INT 0
99428: PPUSH
// streamModeActive := false ;
99429: LD_ADDR_EXP 126
99433: PUSH
99434: LD_INT 0
99436: ST_TO_ADDR
// normalCounter := 36 ;
99437: LD_ADDR_EXP 127
99441: PUSH
99442: LD_INT 36
99444: ST_TO_ADDR
// hardcoreCounter := 18 ;
99445: LD_ADDR_EXP 128
99449: PUSH
99450: LD_INT 18
99452: ST_TO_ADDR
// sRocket := false ;
99453: LD_ADDR_EXP 131
99457: PUSH
99458: LD_INT 0
99460: ST_TO_ADDR
// sSpeed := false ;
99461: LD_ADDR_EXP 130
99465: PUSH
99466: LD_INT 0
99468: ST_TO_ADDR
// sEngine := false ;
99469: LD_ADDR_EXP 132
99473: PUSH
99474: LD_INT 0
99476: ST_TO_ADDR
// sSpec := false ;
99477: LD_ADDR_EXP 129
99481: PUSH
99482: LD_INT 0
99484: ST_TO_ADDR
// sLevel := false ;
99485: LD_ADDR_EXP 133
99489: PUSH
99490: LD_INT 0
99492: ST_TO_ADDR
// sArmoury := false ;
99493: LD_ADDR_EXP 134
99497: PUSH
99498: LD_INT 0
99500: ST_TO_ADDR
// sRadar := false ;
99501: LD_ADDR_EXP 135
99505: PUSH
99506: LD_INT 0
99508: ST_TO_ADDR
// sBunker := false ;
99509: LD_ADDR_EXP 136
99513: PUSH
99514: LD_INT 0
99516: ST_TO_ADDR
// sHack := false ;
99517: LD_ADDR_EXP 137
99521: PUSH
99522: LD_INT 0
99524: ST_TO_ADDR
// sFire := false ;
99525: LD_ADDR_EXP 138
99529: PUSH
99530: LD_INT 0
99532: ST_TO_ADDR
// sRefresh := false ;
99533: LD_ADDR_EXP 139
99537: PUSH
99538: LD_INT 0
99540: ST_TO_ADDR
// sExp := false ;
99541: LD_ADDR_EXP 140
99545: PUSH
99546: LD_INT 0
99548: ST_TO_ADDR
// sDepot := false ;
99549: LD_ADDR_EXP 141
99553: PUSH
99554: LD_INT 0
99556: ST_TO_ADDR
// sFlag := false ;
99557: LD_ADDR_EXP 142
99561: PUSH
99562: LD_INT 0
99564: ST_TO_ADDR
// sKamikadze := false ;
99565: LD_ADDR_EXP 150
99569: PUSH
99570: LD_INT 0
99572: ST_TO_ADDR
// sTroll := false ;
99573: LD_ADDR_EXP 151
99577: PUSH
99578: LD_INT 0
99580: ST_TO_ADDR
// sSlow := false ;
99581: LD_ADDR_EXP 152
99585: PUSH
99586: LD_INT 0
99588: ST_TO_ADDR
// sLack := false ;
99589: LD_ADDR_EXP 153
99593: PUSH
99594: LD_INT 0
99596: ST_TO_ADDR
// sTank := false ;
99597: LD_ADDR_EXP 155
99601: PUSH
99602: LD_INT 0
99604: ST_TO_ADDR
// sRemote := false ;
99605: LD_ADDR_EXP 156
99609: PUSH
99610: LD_INT 0
99612: ST_TO_ADDR
// sPowell := false ;
99613: LD_ADDR_EXP 157
99617: PUSH
99618: LD_INT 0
99620: ST_TO_ADDR
// sTeleport := false ;
99621: LD_ADDR_EXP 160
99625: PUSH
99626: LD_INT 0
99628: ST_TO_ADDR
// sOilTower := false ;
99629: LD_ADDR_EXP 162
99633: PUSH
99634: LD_INT 0
99636: ST_TO_ADDR
// sShovel := false ;
99637: LD_ADDR_EXP 163
99641: PUSH
99642: LD_INT 0
99644: ST_TO_ADDR
// sSheik := false ;
99645: LD_ADDR_EXP 164
99649: PUSH
99650: LD_INT 0
99652: ST_TO_ADDR
// sEarthquake := false ;
99653: LD_ADDR_EXP 166
99657: PUSH
99658: LD_INT 0
99660: ST_TO_ADDR
// sAI := false ;
99661: LD_ADDR_EXP 167
99665: PUSH
99666: LD_INT 0
99668: ST_TO_ADDR
// sCargo := false ;
99669: LD_ADDR_EXP 170
99673: PUSH
99674: LD_INT 0
99676: ST_TO_ADDR
// sDLaser := false ;
99677: LD_ADDR_EXP 171
99681: PUSH
99682: LD_INT 0
99684: ST_TO_ADDR
// sExchange := false ;
99685: LD_ADDR_EXP 172
99689: PUSH
99690: LD_INT 0
99692: ST_TO_ADDR
// sFac := false ;
99693: LD_ADDR_EXP 173
99697: PUSH
99698: LD_INT 0
99700: ST_TO_ADDR
// sPower := false ;
99701: LD_ADDR_EXP 174
99705: PUSH
99706: LD_INT 0
99708: ST_TO_ADDR
// sRandom := false ;
99709: LD_ADDR_EXP 175
99713: PUSH
99714: LD_INT 0
99716: ST_TO_ADDR
// sShield := false ;
99717: LD_ADDR_EXP 176
99721: PUSH
99722: LD_INT 0
99724: ST_TO_ADDR
// sTime := false ;
99725: LD_ADDR_EXP 177
99729: PUSH
99730: LD_INT 0
99732: ST_TO_ADDR
// sTools := false ;
99733: LD_ADDR_EXP 178
99737: PUSH
99738: LD_INT 0
99740: ST_TO_ADDR
// sSold := false ;
99741: LD_ADDR_EXP 143
99745: PUSH
99746: LD_INT 0
99748: ST_TO_ADDR
// sDiff := false ;
99749: LD_ADDR_EXP 144
99753: PUSH
99754: LD_INT 0
99756: ST_TO_ADDR
// sFog := false ;
99757: LD_ADDR_EXP 147
99761: PUSH
99762: LD_INT 0
99764: ST_TO_ADDR
// sReset := false ;
99765: LD_ADDR_EXP 148
99769: PUSH
99770: LD_INT 0
99772: ST_TO_ADDR
// sSun := false ;
99773: LD_ADDR_EXP 149
99777: PUSH
99778: LD_INT 0
99780: ST_TO_ADDR
// sTiger := false ;
99781: LD_ADDR_EXP 145
99785: PUSH
99786: LD_INT 0
99788: ST_TO_ADDR
// sBomb := false ;
99789: LD_ADDR_EXP 146
99793: PUSH
99794: LD_INT 0
99796: ST_TO_ADDR
// sWound := false ;
99797: LD_ADDR_EXP 154
99801: PUSH
99802: LD_INT 0
99804: ST_TO_ADDR
// sBetray := false ;
99805: LD_ADDR_EXP 158
99809: PUSH
99810: LD_INT 0
99812: ST_TO_ADDR
// sContamin := false ;
99813: LD_ADDR_EXP 159
99817: PUSH
99818: LD_INT 0
99820: ST_TO_ADDR
// sOil := false ;
99821: LD_ADDR_EXP 161
99825: PUSH
99826: LD_INT 0
99828: ST_TO_ADDR
// sStu := false ;
99829: LD_ADDR_EXP 165
99833: PUSH
99834: LD_INT 0
99836: ST_TO_ADDR
// sBazooka := false ;
99837: LD_ADDR_EXP 168
99841: PUSH
99842: LD_INT 0
99844: ST_TO_ADDR
// sMortar := false ;
99845: LD_ADDR_EXP 169
99849: PUSH
99850: LD_INT 0
99852: ST_TO_ADDR
// sRanger := false ;
99853: LD_ADDR_EXP 179
99857: PUSH
99858: LD_INT 0
99860: ST_TO_ADDR
// sComputer := false ;
99861: LD_ADDR_EXP 180
99865: PUSH
99866: LD_INT 0
99868: ST_TO_ADDR
// s30 := false ;
99869: LD_ADDR_EXP 181
99873: PUSH
99874: LD_INT 0
99876: ST_TO_ADDR
// s60 := false ;
99877: LD_ADDR_EXP 182
99881: PUSH
99882: LD_INT 0
99884: ST_TO_ADDR
// end ;
99885: LD_VAR 0 1
99889: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
99890: LD_INT 0
99892: PPUSH
99893: PPUSH
99894: PPUSH
99895: PPUSH
99896: PPUSH
99897: PPUSH
99898: PPUSH
// result := [ ] ;
99899: LD_ADDR_VAR 0 2
99903: PUSH
99904: EMPTY
99905: ST_TO_ADDR
// if campaign_id = 1 then
99906: LD_OWVAR 69
99910: PUSH
99911: LD_INT 1
99913: EQUAL
99914: IFFALSE 103080
// begin case mission_number of 1 :
99916: LD_OWVAR 70
99920: PUSH
99921: LD_INT 1
99923: DOUBLE
99924: EQUAL
99925: IFTRUE 99929
99927: GO 100005
99929: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
99930: LD_ADDR_VAR 0 2
99934: PUSH
99935: LD_INT 2
99937: PUSH
99938: LD_INT 4
99940: PUSH
99941: LD_INT 11
99943: PUSH
99944: LD_INT 12
99946: PUSH
99947: LD_INT 15
99949: PUSH
99950: LD_INT 16
99952: PUSH
99953: LD_INT 22
99955: PUSH
99956: LD_INT 23
99958: PUSH
99959: LD_INT 26
99961: PUSH
99962: EMPTY
99963: LIST
99964: LIST
99965: LIST
99966: LIST
99967: LIST
99968: LIST
99969: LIST
99970: LIST
99971: LIST
99972: PUSH
99973: LD_INT 101
99975: PUSH
99976: LD_INT 102
99978: PUSH
99979: LD_INT 106
99981: PUSH
99982: LD_INT 116
99984: PUSH
99985: LD_INT 117
99987: PUSH
99988: LD_INT 118
99990: PUSH
99991: EMPTY
99992: LIST
99993: LIST
99994: LIST
99995: LIST
99996: LIST
99997: LIST
99998: PUSH
99999: EMPTY
100000: LIST
100001: LIST
100002: ST_TO_ADDR
100003: GO 103078
100005: LD_INT 2
100007: DOUBLE
100008: EQUAL
100009: IFTRUE 100013
100011: GO 100097
100013: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
100014: LD_ADDR_VAR 0 2
100018: PUSH
100019: LD_INT 2
100021: PUSH
100022: LD_INT 4
100024: PUSH
100025: LD_INT 11
100027: PUSH
100028: LD_INT 12
100030: PUSH
100031: LD_INT 15
100033: PUSH
100034: LD_INT 16
100036: PUSH
100037: LD_INT 22
100039: PUSH
100040: LD_INT 23
100042: PUSH
100043: LD_INT 26
100045: PUSH
100046: EMPTY
100047: LIST
100048: LIST
100049: LIST
100050: LIST
100051: LIST
100052: LIST
100053: LIST
100054: LIST
100055: LIST
100056: PUSH
100057: LD_INT 101
100059: PUSH
100060: LD_INT 102
100062: PUSH
100063: LD_INT 105
100065: PUSH
100066: LD_INT 106
100068: PUSH
100069: LD_INT 108
100071: PUSH
100072: LD_INT 116
100074: PUSH
100075: LD_INT 117
100077: PUSH
100078: LD_INT 118
100080: PUSH
100081: EMPTY
100082: LIST
100083: LIST
100084: LIST
100085: LIST
100086: LIST
100087: LIST
100088: LIST
100089: LIST
100090: PUSH
100091: EMPTY
100092: LIST
100093: LIST
100094: ST_TO_ADDR
100095: GO 103078
100097: LD_INT 3
100099: DOUBLE
100100: EQUAL
100101: IFTRUE 100105
100103: GO 100193
100105: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
100106: LD_ADDR_VAR 0 2
100110: PUSH
100111: LD_INT 2
100113: PUSH
100114: LD_INT 4
100116: PUSH
100117: LD_INT 5
100119: PUSH
100120: LD_INT 11
100122: PUSH
100123: LD_INT 12
100125: PUSH
100126: LD_INT 15
100128: PUSH
100129: LD_INT 16
100131: PUSH
100132: LD_INT 22
100134: PUSH
100135: LD_INT 26
100137: PUSH
100138: LD_INT 36
100140: PUSH
100141: EMPTY
100142: LIST
100143: LIST
100144: LIST
100145: LIST
100146: LIST
100147: LIST
100148: LIST
100149: LIST
100150: LIST
100151: LIST
100152: PUSH
100153: LD_INT 101
100155: PUSH
100156: LD_INT 102
100158: PUSH
100159: LD_INT 105
100161: PUSH
100162: LD_INT 106
100164: PUSH
100165: LD_INT 108
100167: PUSH
100168: LD_INT 116
100170: PUSH
100171: LD_INT 117
100173: PUSH
100174: LD_INT 118
100176: PUSH
100177: EMPTY
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: LIST
100183: LIST
100184: LIST
100185: LIST
100186: PUSH
100187: EMPTY
100188: LIST
100189: LIST
100190: ST_TO_ADDR
100191: GO 103078
100193: LD_INT 4
100195: DOUBLE
100196: EQUAL
100197: IFTRUE 100201
100199: GO 100297
100201: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
100202: LD_ADDR_VAR 0 2
100206: PUSH
100207: LD_INT 2
100209: PUSH
100210: LD_INT 4
100212: PUSH
100213: LD_INT 5
100215: PUSH
100216: LD_INT 8
100218: PUSH
100219: LD_INT 11
100221: PUSH
100222: LD_INT 12
100224: PUSH
100225: LD_INT 15
100227: PUSH
100228: LD_INT 16
100230: PUSH
100231: LD_INT 22
100233: PUSH
100234: LD_INT 23
100236: PUSH
100237: LD_INT 26
100239: PUSH
100240: LD_INT 36
100242: PUSH
100243: EMPTY
100244: LIST
100245: LIST
100246: LIST
100247: LIST
100248: LIST
100249: LIST
100250: LIST
100251: LIST
100252: LIST
100253: LIST
100254: LIST
100255: LIST
100256: PUSH
100257: LD_INT 101
100259: PUSH
100260: LD_INT 102
100262: PUSH
100263: LD_INT 105
100265: PUSH
100266: LD_INT 106
100268: PUSH
100269: LD_INT 108
100271: PUSH
100272: LD_INT 116
100274: PUSH
100275: LD_INT 117
100277: PUSH
100278: LD_INT 118
100280: PUSH
100281: EMPTY
100282: LIST
100283: LIST
100284: LIST
100285: LIST
100286: LIST
100287: LIST
100288: LIST
100289: LIST
100290: PUSH
100291: EMPTY
100292: LIST
100293: LIST
100294: ST_TO_ADDR
100295: GO 103078
100297: LD_INT 5
100299: DOUBLE
100300: EQUAL
100301: IFTRUE 100305
100303: GO 100417
100305: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
100306: LD_ADDR_VAR 0 2
100310: PUSH
100311: LD_INT 2
100313: PUSH
100314: LD_INT 4
100316: PUSH
100317: LD_INT 5
100319: PUSH
100320: LD_INT 6
100322: PUSH
100323: LD_INT 8
100325: PUSH
100326: LD_INT 11
100328: PUSH
100329: LD_INT 12
100331: PUSH
100332: LD_INT 15
100334: PUSH
100335: LD_INT 16
100337: PUSH
100338: LD_INT 22
100340: PUSH
100341: LD_INT 23
100343: PUSH
100344: LD_INT 25
100346: PUSH
100347: LD_INT 26
100349: PUSH
100350: LD_INT 36
100352: PUSH
100353: EMPTY
100354: LIST
100355: LIST
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: LIST
100361: LIST
100362: LIST
100363: LIST
100364: LIST
100365: LIST
100366: LIST
100367: LIST
100368: PUSH
100369: LD_INT 101
100371: PUSH
100372: LD_INT 102
100374: PUSH
100375: LD_INT 105
100377: PUSH
100378: LD_INT 106
100380: PUSH
100381: LD_INT 108
100383: PUSH
100384: LD_INT 109
100386: PUSH
100387: LD_INT 112
100389: PUSH
100390: LD_INT 116
100392: PUSH
100393: LD_INT 117
100395: PUSH
100396: LD_INT 118
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: LIST
100403: LIST
100404: LIST
100405: LIST
100406: LIST
100407: LIST
100408: LIST
100409: LIST
100410: PUSH
100411: EMPTY
100412: LIST
100413: LIST
100414: ST_TO_ADDR
100415: GO 103078
100417: LD_INT 6
100419: DOUBLE
100420: EQUAL
100421: IFTRUE 100425
100423: GO 100557
100425: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
100426: LD_ADDR_VAR 0 2
100430: PUSH
100431: LD_INT 2
100433: PUSH
100434: LD_INT 4
100436: PUSH
100437: LD_INT 5
100439: PUSH
100440: LD_INT 6
100442: PUSH
100443: LD_INT 8
100445: PUSH
100446: LD_INT 11
100448: PUSH
100449: LD_INT 12
100451: PUSH
100452: LD_INT 15
100454: PUSH
100455: LD_INT 16
100457: PUSH
100458: LD_INT 20
100460: PUSH
100461: LD_INT 21
100463: PUSH
100464: LD_INT 22
100466: PUSH
100467: LD_INT 23
100469: PUSH
100470: LD_INT 25
100472: PUSH
100473: LD_INT 26
100475: PUSH
100476: LD_INT 30
100478: PUSH
100479: LD_INT 31
100481: PUSH
100482: LD_INT 32
100484: PUSH
100485: LD_INT 36
100487: PUSH
100488: EMPTY
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: LIST
100507: LIST
100508: PUSH
100509: LD_INT 101
100511: PUSH
100512: LD_INT 102
100514: PUSH
100515: LD_INT 105
100517: PUSH
100518: LD_INT 106
100520: PUSH
100521: LD_INT 108
100523: PUSH
100524: LD_INT 109
100526: PUSH
100527: LD_INT 112
100529: PUSH
100530: LD_INT 116
100532: PUSH
100533: LD_INT 117
100535: PUSH
100536: LD_INT 118
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: LIST
100543: LIST
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: LIST
100549: LIST
100550: PUSH
100551: EMPTY
100552: LIST
100553: LIST
100554: ST_TO_ADDR
100555: GO 103078
100557: LD_INT 7
100559: DOUBLE
100560: EQUAL
100561: IFTRUE 100565
100563: GO 100677
100565: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
100566: LD_ADDR_VAR 0 2
100570: PUSH
100571: LD_INT 2
100573: PUSH
100574: LD_INT 4
100576: PUSH
100577: LD_INT 5
100579: PUSH
100580: LD_INT 7
100582: PUSH
100583: LD_INT 11
100585: PUSH
100586: LD_INT 12
100588: PUSH
100589: LD_INT 15
100591: PUSH
100592: LD_INT 16
100594: PUSH
100595: LD_INT 20
100597: PUSH
100598: LD_INT 21
100600: PUSH
100601: LD_INT 22
100603: PUSH
100604: LD_INT 23
100606: PUSH
100607: LD_INT 25
100609: PUSH
100610: LD_INT 26
100612: PUSH
100613: EMPTY
100614: LIST
100615: LIST
100616: LIST
100617: LIST
100618: LIST
100619: LIST
100620: LIST
100621: LIST
100622: LIST
100623: LIST
100624: LIST
100625: LIST
100626: LIST
100627: LIST
100628: PUSH
100629: LD_INT 101
100631: PUSH
100632: LD_INT 102
100634: PUSH
100635: LD_INT 103
100637: PUSH
100638: LD_INT 105
100640: PUSH
100641: LD_INT 106
100643: PUSH
100644: LD_INT 108
100646: PUSH
100647: LD_INT 112
100649: PUSH
100650: LD_INT 116
100652: PUSH
100653: LD_INT 117
100655: PUSH
100656: LD_INT 118
100658: PUSH
100659: EMPTY
100660: LIST
100661: LIST
100662: LIST
100663: LIST
100664: LIST
100665: LIST
100666: LIST
100667: LIST
100668: LIST
100669: LIST
100670: PUSH
100671: EMPTY
100672: LIST
100673: LIST
100674: ST_TO_ADDR
100675: GO 103078
100677: LD_INT 8
100679: DOUBLE
100680: EQUAL
100681: IFTRUE 100685
100683: GO 100825
100685: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
100686: LD_ADDR_VAR 0 2
100690: PUSH
100691: LD_INT 2
100693: PUSH
100694: LD_INT 4
100696: PUSH
100697: LD_INT 5
100699: PUSH
100700: LD_INT 6
100702: PUSH
100703: LD_INT 7
100705: PUSH
100706: LD_INT 8
100708: PUSH
100709: LD_INT 11
100711: PUSH
100712: LD_INT 12
100714: PUSH
100715: LD_INT 15
100717: PUSH
100718: LD_INT 16
100720: PUSH
100721: LD_INT 20
100723: PUSH
100724: LD_INT 21
100726: PUSH
100727: LD_INT 22
100729: PUSH
100730: LD_INT 23
100732: PUSH
100733: LD_INT 25
100735: PUSH
100736: LD_INT 26
100738: PUSH
100739: LD_INT 30
100741: PUSH
100742: LD_INT 31
100744: PUSH
100745: LD_INT 32
100747: PUSH
100748: LD_INT 36
100750: PUSH
100751: EMPTY
100752: LIST
100753: LIST
100754: LIST
100755: LIST
100756: LIST
100757: LIST
100758: LIST
100759: LIST
100760: LIST
100761: LIST
100762: LIST
100763: LIST
100764: LIST
100765: LIST
100766: LIST
100767: LIST
100768: LIST
100769: LIST
100770: LIST
100771: LIST
100772: PUSH
100773: LD_INT 101
100775: PUSH
100776: LD_INT 102
100778: PUSH
100779: LD_INT 103
100781: PUSH
100782: LD_INT 105
100784: PUSH
100785: LD_INT 106
100787: PUSH
100788: LD_INT 108
100790: PUSH
100791: LD_INT 109
100793: PUSH
100794: LD_INT 112
100796: PUSH
100797: LD_INT 116
100799: PUSH
100800: LD_INT 117
100802: PUSH
100803: LD_INT 118
100805: PUSH
100806: EMPTY
100807: LIST
100808: LIST
100809: LIST
100810: LIST
100811: LIST
100812: LIST
100813: LIST
100814: LIST
100815: LIST
100816: LIST
100817: LIST
100818: PUSH
100819: EMPTY
100820: LIST
100821: LIST
100822: ST_TO_ADDR
100823: GO 103078
100825: LD_INT 9
100827: DOUBLE
100828: EQUAL
100829: IFTRUE 100833
100831: GO 100981
100833: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
100834: LD_ADDR_VAR 0 2
100838: PUSH
100839: LD_INT 2
100841: PUSH
100842: LD_INT 4
100844: PUSH
100845: LD_INT 5
100847: PUSH
100848: LD_INT 6
100850: PUSH
100851: LD_INT 7
100853: PUSH
100854: LD_INT 8
100856: PUSH
100857: LD_INT 11
100859: PUSH
100860: LD_INT 12
100862: PUSH
100863: LD_INT 15
100865: PUSH
100866: LD_INT 16
100868: PUSH
100869: LD_INT 20
100871: PUSH
100872: LD_INT 21
100874: PUSH
100875: LD_INT 22
100877: PUSH
100878: LD_INT 23
100880: PUSH
100881: LD_INT 25
100883: PUSH
100884: LD_INT 26
100886: PUSH
100887: LD_INT 28
100889: PUSH
100890: LD_INT 30
100892: PUSH
100893: LD_INT 31
100895: PUSH
100896: LD_INT 32
100898: PUSH
100899: LD_INT 36
100901: PUSH
100902: EMPTY
100903: LIST
100904: LIST
100905: LIST
100906: LIST
100907: LIST
100908: LIST
100909: LIST
100910: LIST
100911: LIST
100912: LIST
100913: LIST
100914: LIST
100915: LIST
100916: LIST
100917: LIST
100918: LIST
100919: LIST
100920: LIST
100921: LIST
100922: LIST
100923: LIST
100924: PUSH
100925: LD_INT 101
100927: PUSH
100928: LD_INT 102
100930: PUSH
100931: LD_INT 103
100933: PUSH
100934: LD_INT 105
100936: PUSH
100937: LD_INT 106
100939: PUSH
100940: LD_INT 108
100942: PUSH
100943: LD_INT 109
100945: PUSH
100946: LD_INT 112
100948: PUSH
100949: LD_INT 114
100951: PUSH
100952: LD_INT 116
100954: PUSH
100955: LD_INT 117
100957: PUSH
100958: LD_INT 118
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: LIST
100965: LIST
100966: LIST
100967: LIST
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: LIST
100973: LIST
100974: PUSH
100975: EMPTY
100976: LIST
100977: LIST
100978: ST_TO_ADDR
100979: GO 103078
100981: LD_INT 10
100983: DOUBLE
100984: EQUAL
100985: IFTRUE 100989
100987: GO 101185
100989: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
100990: LD_ADDR_VAR 0 2
100994: PUSH
100995: LD_INT 2
100997: PUSH
100998: LD_INT 4
101000: PUSH
101001: LD_INT 5
101003: PUSH
101004: LD_INT 6
101006: PUSH
101007: LD_INT 7
101009: PUSH
101010: LD_INT 8
101012: PUSH
101013: LD_INT 9
101015: PUSH
101016: LD_INT 10
101018: PUSH
101019: LD_INT 11
101021: PUSH
101022: LD_INT 12
101024: PUSH
101025: LD_INT 13
101027: PUSH
101028: LD_INT 14
101030: PUSH
101031: LD_INT 15
101033: PUSH
101034: LD_INT 16
101036: PUSH
101037: LD_INT 17
101039: PUSH
101040: LD_INT 18
101042: PUSH
101043: LD_INT 19
101045: PUSH
101046: LD_INT 20
101048: PUSH
101049: LD_INT 21
101051: PUSH
101052: LD_INT 22
101054: PUSH
101055: LD_INT 23
101057: PUSH
101058: LD_INT 24
101060: PUSH
101061: LD_INT 25
101063: PUSH
101064: LD_INT 26
101066: PUSH
101067: LD_INT 28
101069: PUSH
101070: LD_INT 30
101072: PUSH
101073: LD_INT 31
101075: PUSH
101076: LD_INT 32
101078: PUSH
101079: LD_INT 36
101081: PUSH
101082: EMPTY
101083: LIST
101084: LIST
101085: LIST
101086: LIST
101087: LIST
101088: LIST
101089: LIST
101090: LIST
101091: LIST
101092: LIST
101093: LIST
101094: LIST
101095: LIST
101096: LIST
101097: LIST
101098: LIST
101099: LIST
101100: LIST
101101: LIST
101102: LIST
101103: LIST
101104: LIST
101105: LIST
101106: LIST
101107: LIST
101108: LIST
101109: LIST
101110: LIST
101111: LIST
101112: PUSH
101113: LD_INT 101
101115: PUSH
101116: LD_INT 102
101118: PUSH
101119: LD_INT 103
101121: PUSH
101122: LD_INT 104
101124: PUSH
101125: LD_INT 105
101127: PUSH
101128: LD_INT 106
101130: PUSH
101131: LD_INT 107
101133: PUSH
101134: LD_INT 108
101136: PUSH
101137: LD_INT 109
101139: PUSH
101140: LD_INT 110
101142: PUSH
101143: LD_INT 111
101145: PUSH
101146: LD_INT 112
101148: PUSH
101149: LD_INT 114
101151: PUSH
101152: LD_INT 116
101154: PUSH
101155: LD_INT 117
101157: PUSH
101158: LD_INT 118
101160: PUSH
101161: EMPTY
101162: LIST
101163: LIST
101164: LIST
101165: LIST
101166: LIST
101167: LIST
101168: LIST
101169: LIST
101170: LIST
101171: LIST
101172: LIST
101173: LIST
101174: LIST
101175: LIST
101176: LIST
101177: LIST
101178: PUSH
101179: EMPTY
101180: LIST
101181: LIST
101182: ST_TO_ADDR
101183: GO 103078
101185: LD_INT 11
101187: DOUBLE
101188: EQUAL
101189: IFTRUE 101193
101191: GO 101397
101193: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
101194: LD_ADDR_VAR 0 2
101198: PUSH
101199: LD_INT 2
101201: PUSH
101202: LD_INT 3
101204: PUSH
101205: LD_INT 4
101207: PUSH
101208: LD_INT 5
101210: PUSH
101211: LD_INT 6
101213: PUSH
101214: LD_INT 7
101216: PUSH
101217: LD_INT 8
101219: PUSH
101220: LD_INT 9
101222: PUSH
101223: LD_INT 10
101225: PUSH
101226: LD_INT 11
101228: PUSH
101229: LD_INT 12
101231: PUSH
101232: LD_INT 13
101234: PUSH
101235: LD_INT 14
101237: PUSH
101238: LD_INT 15
101240: PUSH
101241: LD_INT 16
101243: PUSH
101244: LD_INT 17
101246: PUSH
101247: LD_INT 18
101249: PUSH
101250: LD_INT 19
101252: PUSH
101253: LD_INT 20
101255: PUSH
101256: LD_INT 21
101258: PUSH
101259: LD_INT 22
101261: PUSH
101262: LD_INT 23
101264: PUSH
101265: LD_INT 24
101267: PUSH
101268: LD_INT 25
101270: PUSH
101271: LD_INT 26
101273: PUSH
101274: LD_INT 28
101276: PUSH
101277: LD_INT 30
101279: PUSH
101280: LD_INT 31
101282: PUSH
101283: LD_INT 32
101285: PUSH
101286: LD_INT 34
101288: PUSH
101289: LD_INT 36
101291: PUSH
101292: EMPTY
101293: LIST
101294: LIST
101295: LIST
101296: LIST
101297: LIST
101298: LIST
101299: LIST
101300: LIST
101301: LIST
101302: LIST
101303: LIST
101304: LIST
101305: LIST
101306: LIST
101307: LIST
101308: LIST
101309: LIST
101310: LIST
101311: LIST
101312: LIST
101313: LIST
101314: LIST
101315: LIST
101316: LIST
101317: LIST
101318: LIST
101319: LIST
101320: LIST
101321: LIST
101322: LIST
101323: LIST
101324: PUSH
101325: LD_INT 101
101327: PUSH
101328: LD_INT 102
101330: PUSH
101331: LD_INT 103
101333: PUSH
101334: LD_INT 104
101336: PUSH
101337: LD_INT 105
101339: PUSH
101340: LD_INT 106
101342: PUSH
101343: LD_INT 107
101345: PUSH
101346: LD_INT 108
101348: PUSH
101349: LD_INT 109
101351: PUSH
101352: LD_INT 110
101354: PUSH
101355: LD_INT 111
101357: PUSH
101358: LD_INT 112
101360: PUSH
101361: LD_INT 114
101363: PUSH
101364: LD_INT 116
101366: PUSH
101367: LD_INT 117
101369: PUSH
101370: LD_INT 118
101372: PUSH
101373: EMPTY
101374: LIST
101375: LIST
101376: LIST
101377: LIST
101378: LIST
101379: LIST
101380: LIST
101381: LIST
101382: LIST
101383: LIST
101384: LIST
101385: LIST
101386: LIST
101387: LIST
101388: LIST
101389: LIST
101390: PUSH
101391: EMPTY
101392: LIST
101393: LIST
101394: ST_TO_ADDR
101395: GO 103078
101397: LD_INT 12
101399: DOUBLE
101400: EQUAL
101401: IFTRUE 101405
101403: GO 101625
101405: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
101406: LD_ADDR_VAR 0 2
101410: PUSH
101411: LD_INT 1
101413: PUSH
101414: LD_INT 2
101416: PUSH
101417: LD_INT 3
101419: PUSH
101420: LD_INT 4
101422: PUSH
101423: LD_INT 5
101425: PUSH
101426: LD_INT 6
101428: PUSH
101429: LD_INT 7
101431: PUSH
101432: LD_INT 8
101434: PUSH
101435: LD_INT 9
101437: PUSH
101438: LD_INT 10
101440: PUSH
101441: LD_INT 11
101443: PUSH
101444: LD_INT 12
101446: PUSH
101447: LD_INT 13
101449: PUSH
101450: LD_INT 14
101452: PUSH
101453: LD_INT 15
101455: PUSH
101456: LD_INT 16
101458: PUSH
101459: LD_INT 17
101461: PUSH
101462: LD_INT 18
101464: PUSH
101465: LD_INT 19
101467: PUSH
101468: LD_INT 20
101470: PUSH
101471: LD_INT 21
101473: PUSH
101474: LD_INT 22
101476: PUSH
101477: LD_INT 23
101479: PUSH
101480: LD_INT 24
101482: PUSH
101483: LD_INT 25
101485: PUSH
101486: LD_INT 26
101488: PUSH
101489: LD_INT 27
101491: PUSH
101492: LD_INT 28
101494: PUSH
101495: LD_INT 30
101497: PUSH
101498: LD_INT 31
101500: PUSH
101501: LD_INT 32
101503: PUSH
101504: LD_INT 33
101506: PUSH
101507: LD_INT 34
101509: PUSH
101510: LD_INT 36
101512: PUSH
101513: EMPTY
101514: LIST
101515: LIST
101516: LIST
101517: LIST
101518: LIST
101519: LIST
101520: LIST
101521: LIST
101522: LIST
101523: LIST
101524: LIST
101525: LIST
101526: LIST
101527: LIST
101528: LIST
101529: LIST
101530: LIST
101531: LIST
101532: LIST
101533: LIST
101534: LIST
101535: LIST
101536: LIST
101537: LIST
101538: LIST
101539: LIST
101540: LIST
101541: LIST
101542: LIST
101543: LIST
101544: LIST
101545: LIST
101546: LIST
101547: LIST
101548: PUSH
101549: LD_INT 101
101551: PUSH
101552: LD_INT 102
101554: PUSH
101555: LD_INT 103
101557: PUSH
101558: LD_INT 104
101560: PUSH
101561: LD_INT 105
101563: PUSH
101564: LD_INT 106
101566: PUSH
101567: LD_INT 107
101569: PUSH
101570: LD_INT 108
101572: PUSH
101573: LD_INT 109
101575: PUSH
101576: LD_INT 110
101578: PUSH
101579: LD_INT 111
101581: PUSH
101582: LD_INT 112
101584: PUSH
101585: LD_INT 113
101587: PUSH
101588: LD_INT 114
101590: PUSH
101591: LD_INT 116
101593: PUSH
101594: LD_INT 117
101596: PUSH
101597: LD_INT 118
101599: PUSH
101600: EMPTY
101601: LIST
101602: LIST
101603: LIST
101604: LIST
101605: LIST
101606: LIST
101607: LIST
101608: LIST
101609: LIST
101610: LIST
101611: LIST
101612: LIST
101613: LIST
101614: LIST
101615: LIST
101616: LIST
101617: LIST
101618: PUSH
101619: EMPTY
101620: LIST
101621: LIST
101622: ST_TO_ADDR
101623: GO 103078
101625: LD_INT 13
101627: DOUBLE
101628: EQUAL
101629: IFTRUE 101633
101631: GO 101841
101633: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
101634: LD_ADDR_VAR 0 2
101638: PUSH
101639: LD_INT 1
101641: PUSH
101642: LD_INT 2
101644: PUSH
101645: LD_INT 3
101647: PUSH
101648: LD_INT 4
101650: PUSH
101651: LD_INT 5
101653: PUSH
101654: LD_INT 8
101656: PUSH
101657: LD_INT 9
101659: PUSH
101660: LD_INT 10
101662: PUSH
101663: LD_INT 11
101665: PUSH
101666: LD_INT 12
101668: PUSH
101669: LD_INT 14
101671: PUSH
101672: LD_INT 15
101674: PUSH
101675: LD_INT 16
101677: PUSH
101678: LD_INT 17
101680: PUSH
101681: LD_INT 18
101683: PUSH
101684: LD_INT 19
101686: PUSH
101687: LD_INT 20
101689: PUSH
101690: LD_INT 21
101692: PUSH
101693: LD_INT 22
101695: PUSH
101696: LD_INT 23
101698: PUSH
101699: LD_INT 24
101701: PUSH
101702: LD_INT 25
101704: PUSH
101705: LD_INT 26
101707: PUSH
101708: LD_INT 27
101710: PUSH
101711: LD_INT 28
101713: PUSH
101714: LD_INT 30
101716: PUSH
101717: LD_INT 31
101719: PUSH
101720: LD_INT 32
101722: PUSH
101723: LD_INT 33
101725: PUSH
101726: LD_INT 34
101728: PUSH
101729: LD_INT 36
101731: PUSH
101732: EMPTY
101733: LIST
101734: LIST
101735: LIST
101736: LIST
101737: LIST
101738: LIST
101739: LIST
101740: LIST
101741: LIST
101742: LIST
101743: LIST
101744: LIST
101745: LIST
101746: LIST
101747: LIST
101748: LIST
101749: LIST
101750: LIST
101751: LIST
101752: LIST
101753: LIST
101754: LIST
101755: LIST
101756: LIST
101757: LIST
101758: LIST
101759: LIST
101760: LIST
101761: LIST
101762: LIST
101763: LIST
101764: PUSH
101765: LD_INT 101
101767: PUSH
101768: LD_INT 102
101770: PUSH
101771: LD_INT 103
101773: PUSH
101774: LD_INT 104
101776: PUSH
101777: LD_INT 105
101779: PUSH
101780: LD_INT 106
101782: PUSH
101783: LD_INT 107
101785: PUSH
101786: LD_INT 108
101788: PUSH
101789: LD_INT 109
101791: PUSH
101792: LD_INT 110
101794: PUSH
101795: LD_INT 111
101797: PUSH
101798: LD_INT 112
101800: PUSH
101801: LD_INT 113
101803: PUSH
101804: LD_INT 114
101806: PUSH
101807: LD_INT 116
101809: PUSH
101810: LD_INT 117
101812: PUSH
101813: LD_INT 118
101815: PUSH
101816: EMPTY
101817: LIST
101818: LIST
101819: LIST
101820: LIST
101821: LIST
101822: LIST
101823: LIST
101824: LIST
101825: LIST
101826: LIST
101827: LIST
101828: LIST
101829: LIST
101830: LIST
101831: LIST
101832: LIST
101833: LIST
101834: PUSH
101835: EMPTY
101836: LIST
101837: LIST
101838: ST_TO_ADDR
101839: GO 103078
101841: LD_INT 14
101843: DOUBLE
101844: EQUAL
101845: IFTRUE 101849
101847: GO 102073
101849: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
101850: LD_ADDR_VAR 0 2
101854: PUSH
101855: LD_INT 1
101857: PUSH
101858: LD_INT 2
101860: PUSH
101861: LD_INT 3
101863: PUSH
101864: LD_INT 4
101866: PUSH
101867: LD_INT 5
101869: PUSH
101870: LD_INT 6
101872: PUSH
101873: LD_INT 7
101875: PUSH
101876: LD_INT 8
101878: PUSH
101879: LD_INT 9
101881: PUSH
101882: LD_INT 10
101884: PUSH
101885: LD_INT 11
101887: PUSH
101888: LD_INT 12
101890: PUSH
101891: LD_INT 13
101893: PUSH
101894: LD_INT 14
101896: PUSH
101897: LD_INT 15
101899: PUSH
101900: LD_INT 16
101902: PUSH
101903: LD_INT 17
101905: PUSH
101906: LD_INT 18
101908: PUSH
101909: LD_INT 19
101911: PUSH
101912: LD_INT 20
101914: PUSH
101915: LD_INT 21
101917: PUSH
101918: LD_INT 22
101920: PUSH
101921: LD_INT 23
101923: PUSH
101924: LD_INT 24
101926: PUSH
101927: LD_INT 25
101929: PUSH
101930: LD_INT 26
101932: PUSH
101933: LD_INT 27
101935: PUSH
101936: LD_INT 28
101938: PUSH
101939: LD_INT 29
101941: PUSH
101942: LD_INT 30
101944: PUSH
101945: LD_INT 31
101947: PUSH
101948: LD_INT 32
101950: PUSH
101951: LD_INT 33
101953: PUSH
101954: LD_INT 34
101956: PUSH
101957: LD_INT 36
101959: PUSH
101960: EMPTY
101961: LIST
101962: LIST
101963: LIST
101964: LIST
101965: LIST
101966: LIST
101967: LIST
101968: LIST
101969: LIST
101970: LIST
101971: LIST
101972: LIST
101973: LIST
101974: LIST
101975: LIST
101976: LIST
101977: LIST
101978: LIST
101979: LIST
101980: LIST
101981: LIST
101982: LIST
101983: LIST
101984: LIST
101985: LIST
101986: LIST
101987: LIST
101988: LIST
101989: LIST
101990: LIST
101991: LIST
101992: LIST
101993: LIST
101994: LIST
101995: LIST
101996: PUSH
101997: LD_INT 101
101999: PUSH
102000: LD_INT 102
102002: PUSH
102003: LD_INT 103
102005: PUSH
102006: LD_INT 104
102008: PUSH
102009: LD_INT 105
102011: PUSH
102012: LD_INT 106
102014: PUSH
102015: LD_INT 107
102017: PUSH
102018: LD_INT 108
102020: PUSH
102021: LD_INT 109
102023: PUSH
102024: LD_INT 110
102026: PUSH
102027: LD_INT 111
102029: PUSH
102030: LD_INT 112
102032: PUSH
102033: LD_INT 113
102035: PUSH
102036: LD_INT 114
102038: PUSH
102039: LD_INT 116
102041: PUSH
102042: LD_INT 117
102044: PUSH
102045: LD_INT 118
102047: PUSH
102048: EMPTY
102049: LIST
102050: LIST
102051: LIST
102052: LIST
102053: LIST
102054: LIST
102055: LIST
102056: LIST
102057: LIST
102058: LIST
102059: LIST
102060: LIST
102061: LIST
102062: LIST
102063: LIST
102064: LIST
102065: LIST
102066: PUSH
102067: EMPTY
102068: LIST
102069: LIST
102070: ST_TO_ADDR
102071: GO 103078
102073: LD_INT 15
102075: DOUBLE
102076: EQUAL
102077: IFTRUE 102081
102079: GO 102305
102081: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
102082: LD_ADDR_VAR 0 2
102086: PUSH
102087: LD_INT 1
102089: PUSH
102090: LD_INT 2
102092: PUSH
102093: LD_INT 3
102095: PUSH
102096: LD_INT 4
102098: PUSH
102099: LD_INT 5
102101: PUSH
102102: LD_INT 6
102104: PUSH
102105: LD_INT 7
102107: PUSH
102108: LD_INT 8
102110: PUSH
102111: LD_INT 9
102113: PUSH
102114: LD_INT 10
102116: PUSH
102117: LD_INT 11
102119: PUSH
102120: LD_INT 12
102122: PUSH
102123: LD_INT 13
102125: PUSH
102126: LD_INT 14
102128: PUSH
102129: LD_INT 15
102131: PUSH
102132: LD_INT 16
102134: PUSH
102135: LD_INT 17
102137: PUSH
102138: LD_INT 18
102140: PUSH
102141: LD_INT 19
102143: PUSH
102144: LD_INT 20
102146: PUSH
102147: LD_INT 21
102149: PUSH
102150: LD_INT 22
102152: PUSH
102153: LD_INT 23
102155: PUSH
102156: LD_INT 24
102158: PUSH
102159: LD_INT 25
102161: PUSH
102162: LD_INT 26
102164: PUSH
102165: LD_INT 27
102167: PUSH
102168: LD_INT 28
102170: PUSH
102171: LD_INT 29
102173: PUSH
102174: LD_INT 30
102176: PUSH
102177: LD_INT 31
102179: PUSH
102180: LD_INT 32
102182: PUSH
102183: LD_INT 33
102185: PUSH
102186: LD_INT 34
102188: PUSH
102189: LD_INT 36
102191: PUSH
102192: EMPTY
102193: LIST
102194: LIST
102195: LIST
102196: LIST
102197: LIST
102198: LIST
102199: LIST
102200: LIST
102201: LIST
102202: LIST
102203: LIST
102204: LIST
102205: LIST
102206: LIST
102207: LIST
102208: LIST
102209: LIST
102210: LIST
102211: LIST
102212: LIST
102213: LIST
102214: LIST
102215: LIST
102216: LIST
102217: LIST
102218: LIST
102219: LIST
102220: LIST
102221: LIST
102222: LIST
102223: LIST
102224: LIST
102225: LIST
102226: LIST
102227: LIST
102228: PUSH
102229: LD_INT 101
102231: PUSH
102232: LD_INT 102
102234: PUSH
102235: LD_INT 103
102237: PUSH
102238: LD_INT 104
102240: PUSH
102241: LD_INT 105
102243: PUSH
102244: LD_INT 106
102246: PUSH
102247: LD_INT 107
102249: PUSH
102250: LD_INT 108
102252: PUSH
102253: LD_INT 109
102255: PUSH
102256: LD_INT 110
102258: PUSH
102259: LD_INT 111
102261: PUSH
102262: LD_INT 112
102264: PUSH
102265: LD_INT 113
102267: PUSH
102268: LD_INT 114
102270: PUSH
102271: LD_INT 116
102273: PUSH
102274: LD_INT 117
102276: PUSH
102277: LD_INT 118
102279: PUSH
102280: EMPTY
102281: LIST
102282: LIST
102283: LIST
102284: LIST
102285: LIST
102286: LIST
102287: LIST
102288: LIST
102289: LIST
102290: LIST
102291: LIST
102292: LIST
102293: LIST
102294: LIST
102295: LIST
102296: LIST
102297: LIST
102298: PUSH
102299: EMPTY
102300: LIST
102301: LIST
102302: ST_TO_ADDR
102303: GO 103078
102305: LD_INT 16
102307: DOUBLE
102308: EQUAL
102309: IFTRUE 102313
102311: GO 102449
102313: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
102314: LD_ADDR_VAR 0 2
102318: PUSH
102319: LD_INT 2
102321: PUSH
102322: LD_INT 4
102324: PUSH
102325: LD_INT 5
102327: PUSH
102328: LD_INT 7
102330: PUSH
102331: LD_INT 11
102333: PUSH
102334: LD_INT 12
102336: PUSH
102337: LD_INT 15
102339: PUSH
102340: LD_INT 16
102342: PUSH
102343: LD_INT 20
102345: PUSH
102346: LD_INT 21
102348: PUSH
102349: LD_INT 22
102351: PUSH
102352: LD_INT 23
102354: PUSH
102355: LD_INT 25
102357: PUSH
102358: LD_INT 26
102360: PUSH
102361: LD_INT 30
102363: PUSH
102364: LD_INT 31
102366: PUSH
102367: LD_INT 32
102369: PUSH
102370: LD_INT 33
102372: PUSH
102373: LD_INT 34
102375: PUSH
102376: EMPTY
102377: LIST
102378: LIST
102379: LIST
102380: LIST
102381: LIST
102382: LIST
102383: LIST
102384: LIST
102385: LIST
102386: LIST
102387: LIST
102388: LIST
102389: LIST
102390: LIST
102391: LIST
102392: LIST
102393: LIST
102394: LIST
102395: LIST
102396: PUSH
102397: LD_INT 101
102399: PUSH
102400: LD_INT 102
102402: PUSH
102403: LD_INT 103
102405: PUSH
102406: LD_INT 106
102408: PUSH
102409: LD_INT 108
102411: PUSH
102412: LD_INT 112
102414: PUSH
102415: LD_INT 113
102417: PUSH
102418: LD_INT 114
102420: PUSH
102421: LD_INT 116
102423: PUSH
102424: LD_INT 117
102426: PUSH
102427: LD_INT 118
102429: PUSH
102430: EMPTY
102431: LIST
102432: LIST
102433: LIST
102434: LIST
102435: LIST
102436: LIST
102437: LIST
102438: LIST
102439: LIST
102440: LIST
102441: LIST
102442: PUSH
102443: EMPTY
102444: LIST
102445: LIST
102446: ST_TO_ADDR
102447: GO 103078
102449: LD_INT 17
102451: DOUBLE
102452: EQUAL
102453: IFTRUE 102457
102455: GO 102681
102457: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
102458: LD_ADDR_VAR 0 2
102462: PUSH
102463: LD_INT 1
102465: PUSH
102466: LD_INT 2
102468: PUSH
102469: LD_INT 3
102471: PUSH
102472: LD_INT 4
102474: PUSH
102475: LD_INT 5
102477: PUSH
102478: LD_INT 6
102480: PUSH
102481: LD_INT 7
102483: PUSH
102484: LD_INT 8
102486: PUSH
102487: LD_INT 9
102489: PUSH
102490: LD_INT 10
102492: PUSH
102493: LD_INT 11
102495: PUSH
102496: LD_INT 12
102498: PUSH
102499: LD_INT 13
102501: PUSH
102502: LD_INT 14
102504: PUSH
102505: LD_INT 15
102507: PUSH
102508: LD_INT 16
102510: PUSH
102511: LD_INT 17
102513: PUSH
102514: LD_INT 18
102516: PUSH
102517: LD_INT 19
102519: PUSH
102520: LD_INT 20
102522: PUSH
102523: LD_INT 21
102525: PUSH
102526: LD_INT 22
102528: PUSH
102529: LD_INT 23
102531: PUSH
102532: LD_INT 24
102534: PUSH
102535: LD_INT 25
102537: PUSH
102538: LD_INT 26
102540: PUSH
102541: LD_INT 27
102543: PUSH
102544: LD_INT 28
102546: PUSH
102547: LD_INT 29
102549: PUSH
102550: LD_INT 30
102552: PUSH
102553: LD_INT 31
102555: PUSH
102556: LD_INT 32
102558: PUSH
102559: LD_INT 33
102561: PUSH
102562: LD_INT 34
102564: PUSH
102565: LD_INT 36
102567: PUSH
102568: EMPTY
102569: LIST
102570: LIST
102571: LIST
102572: LIST
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: LIST
102578: LIST
102579: LIST
102580: LIST
102581: LIST
102582: LIST
102583: LIST
102584: LIST
102585: LIST
102586: LIST
102587: LIST
102588: LIST
102589: LIST
102590: LIST
102591: LIST
102592: LIST
102593: LIST
102594: LIST
102595: LIST
102596: LIST
102597: LIST
102598: LIST
102599: LIST
102600: LIST
102601: LIST
102602: LIST
102603: LIST
102604: PUSH
102605: LD_INT 101
102607: PUSH
102608: LD_INT 102
102610: PUSH
102611: LD_INT 103
102613: PUSH
102614: LD_INT 104
102616: PUSH
102617: LD_INT 105
102619: PUSH
102620: LD_INT 106
102622: PUSH
102623: LD_INT 107
102625: PUSH
102626: LD_INT 108
102628: PUSH
102629: LD_INT 109
102631: PUSH
102632: LD_INT 110
102634: PUSH
102635: LD_INT 111
102637: PUSH
102638: LD_INT 112
102640: PUSH
102641: LD_INT 113
102643: PUSH
102644: LD_INT 114
102646: PUSH
102647: LD_INT 116
102649: PUSH
102650: LD_INT 117
102652: PUSH
102653: LD_INT 118
102655: PUSH
102656: EMPTY
102657: LIST
102658: LIST
102659: LIST
102660: LIST
102661: LIST
102662: LIST
102663: LIST
102664: LIST
102665: LIST
102666: LIST
102667: LIST
102668: LIST
102669: LIST
102670: LIST
102671: LIST
102672: LIST
102673: LIST
102674: PUSH
102675: EMPTY
102676: LIST
102677: LIST
102678: ST_TO_ADDR
102679: GO 103078
102681: LD_INT 18
102683: DOUBLE
102684: EQUAL
102685: IFTRUE 102689
102687: GO 102837
102689: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
102690: LD_ADDR_VAR 0 2
102694: PUSH
102695: LD_INT 2
102697: PUSH
102698: LD_INT 4
102700: PUSH
102701: LD_INT 5
102703: PUSH
102704: LD_INT 7
102706: PUSH
102707: LD_INT 11
102709: PUSH
102710: LD_INT 12
102712: PUSH
102713: LD_INT 15
102715: PUSH
102716: LD_INT 16
102718: PUSH
102719: LD_INT 20
102721: PUSH
102722: LD_INT 21
102724: PUSH
102725: LD_INT 22
102727: PUSH
102728: LD_INT 23
102730: PUSH
102731: LD_INT 25
102733: PUSH
102734: LD_INT 26
102736: PUSH
102737: LD_INT 30
102739: PUSH
102740: LD_INT 31
102742: PUSH
102743: LD_INT 32
102745: PUSH
102746: LD_INT 33
102748: PUSH
102749: LD_INT 34
102751: PUSH
102752: LD_INT 35
102754: PUSH
102755: LD_INT 36
102757: PUSH
102758: EMPTY
102759: LIST
102760: LIST
102761: LIST
102762: LIST
102763: LIST
102764: LIST
102765: LIST
102766: LIST
102767: LIST
102768: LIST
102769: LIST
102770: LIST
102771: LIST
102772: LIST
102773: LIST
102774: LIST
102775: LIST
102776: LIST
102777: LIST
102778: LIST
102779: LIST
102780: PUSH
102781: LD_INT 101
102783: PUSH
102784: LD_INT 102
102786: PUSH
102787: LD_INT 103
102789: PUSH
102790: LD_INT 106
102792: PUSH
102793: LD_INT 108
102795: PUSH
102796: LD_INT 112
102798: PUSH
102799: LD_INT 113
102801: PUSH
102802: LD_INT 114
102804: PUSH
102805: LD_INT 115
102807: PUSH
102808: LD_INT 116
102810: PUSH
102811: LD_INT 117
102813: PUSH
102814: LD_INT 118
102816: PUSH
102817: EMPTY
102818: LIST
102819: LIST
102820: LIST
102821: LIST
102822: LIST
102823: LIST
102824: LIST
102825: LIST
102826: LIST
102827: LIST
102828: LIST
102829: LIST
102830: PUSH
102831: EMPTY
102832: LIST
102833: LIST
102834: ST_TO_ADDR
102835: GO 103078
102837: LD_INT 19
102839: DOUBLE
102840: EQUAL
102841: IFTRUE 102845
102843: GO 103077
102845: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
102846: LD_ADDR_VAR 0 2
102850: PUSH
102851: LD_INT 1
102853: PUSH
102854: LD_INT 2
102856: PUSH
102857: LD_INT 3
102859: PUSH
102860: LD_INT 4
102862: PUSH
102863: LD_INT 5
102865: PUSH
102866: LD_INT 6
102868: PUSH
102869: LD_INT 7
102871: PUSH
102872: LD_INT 8
102874: PUSH
102875: LD_INT 9
102877: PUSH
102878: LD_INT 10
102880: PUSH
102881: LD_INT 11
102883: PUSH
102884: LD_INT 12
102886: PUSH
102887: LD_INT 13
102889: PUSH
102890: LD_INT 14
102892: PUSH
102893: LD_INT 15
102895: PUSH
102896: LD_INT 16
102898: PUSH
102899: LD_INT 17
102901: PUSH
102902: LD_INT 18
102904: PUSH
102905: LD_INT 19
102907: PUSH
102908: LD_INT 20
102910: PUSH
102911: LD_INT 21
102913: PUSH
102914: LD_INT 22
102916: PUSH
102917: LD_INT 23
102919: PUSH
102920: LD_INT 24
102922: PUSH
102923: LD_INT 25
102925: PUSH
102926: LD_INT 26
102928: PUSH
102929: LD_INT 27
102931: PUSH
102932: LD_INT 28
102934: PUSH
102935: LD_INT 29
102937: PUSH
102938: LD_INT 30
102940: PUSH
102941: LD_INT 31
102943: PUSH
102944: LD_INT 32
102946: PUSH
102947: LD_INT 33
102949: PUSH
102950: LD_INT 34
102952: PUSH
102953: LD_INT 35
102955: PUSH
102956: LD_INT 36
102958: PUSH
102959: EMPTY
102960: LIST
102961: LIST
102962: LIST
102963: LIST
102964: LIST
102965: LIST
102966: LIST
102967: LIST
102968: LIST
102969: LIST
102970: LIST
102971: LIST
102972: LIST
102973: LIST
102974: LIST
102975: LIST
102976: LIST
102977: LIST
102978: LIST
102979: LIST
102980: LIST
102981: LIST
102982: LIST
102983: LIST
102984: LIST
102985: LIST
102986: LIST
102987: LIST
102988: LIST
102989: LIST
102990: LIST
102991: LIST
102992: LIST
102993: LIST
102994: LIST
102995: LIST
102996: PUSH
102997: LD_INT 101
102999: PUSH
103000: LD_INT 102
103002: PUSH
103003: LD_INT 103
103005: PUSH
103006: LD_INT 104
103008: PUSH
103009: LD_INT 105
103011: PUSH
103012: LD_INT 106
103014: PUSH
103015: LD_INT 107
103017: PUSH
103018: LD_INT 108
103020: PUSH
103021: LD_INT 109
103023: PUSH
103024: LD_INT 110
103026: PUSH
103027: LD_INT 111
103029: PUSH
103030: LD_INT 112
103032: PUSH
103033: LD_INT 113
103035: PUSH
103036: LD_INT 114
103038: PUSH
103039: LD_INT 115
103041: PUSH
103042: LD_INT 116
103044: PUSH
103045: LD_INT 117
103047: PUSH
103048: LD_INT 118
103050: PUSH
103051: EMPTY
103052: LIST
103053: LIST
103054: LIST
103055: LIST
103056: LIST
103057: LIST
103058: LIST
103059: LIST
103060: LIST
103061: LIST
103062: LIST
103063: LIST
103064: LIST
103065: LIST
103066: LIST
103067: LIST
103068: LIST
103069: LIST
103070: PUSH
103071: EMPTY
103072: LIST
103073: LIST
103074: ST_TO_ADDR
103075: GO 103078
103077: POP
// end else
103078: GO 103309
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
103080: LD_ADDR_VAR 0 2
103084: PUSH
103085: LD_INT 1
103087: PUSH
103088: LD_INT 2
103090: PUSH
103091: LD_INT 3
103093: PUSH
103094: LD_INT 4
103096: PUSH
103097: LD_INT 5
103099: PUSH
103100: LD_INT 6
103102: PUSH
103103: LD_INT 7
103105: PUSH
103106: LD_INT 8
103108: PUSH
103109: LD_INT 9
103111: PUSH
103112: LD_INT 10
103114: PUSH
103115: LD_INT 11
103117: PUSH
103118: LD_INT 12
103120: PUSH
103121: LD_INT 13
103123: PUSH
103124: LD_INT 14
103126: PUSH
103127: LD_INT 15
103129: PUSH
103130: LD_INT 16
103132: PUSH
103133: LD_INT 17
103135: PUSH
103136: LD_INT 18
103138: PUSH
103139: LD_INT 19
103141: PUSH
103142: LD_INT 20
103144: PUSH
103145: LD_INT 21
103147: PUSH
103148: LD_INT 22
103150: PUSH
103151: LD_INT 23
103153: PUSH
103154: LD_INT 24
103156: PUSH
103157: LD_INT 25
103159: PUSH
103160: LD_INT 26
103162: PUSH
103163: LD_INT 27
103165: PUSH
103166: LD_INT 28
103168: PUSH
103169: LD_INT 29
103171: PUSH
103172: LD_INT 30
103174: PUSH
103175: LD_INT 31
103177: PUSH
103178: LD_INT 32
103180: PUSH
103181: LD_INT 33
103183: PUSH
103184: LD_INT 34
103186: PUSH
103187: LD_INT 35
103189: PUSH
103190: LD_INT 36
103192: PUSH
103193: EMPTY
103194: LIST
103195: LIST
103196: LIST
103197: LIST
103198: LIST
103199: LIST
103200: LIST
103201: LIST
103202: LIST
103203: LIST
103204: LIST
103205: LIST
103206: LIST
103207: LIST
103208: LIST
103209: LIST
103210: LIST
103211: LIST
103212: LIST
103213: LIST
103214: LIST
103215: LIST
103216: LIST
103217: LIST
103218: LIST
103219: LIST
103220: LIST
103221: LIST
103222: LIST
103223: LIST
103224: LIST
103225: LIST
103226: LIST
103227: LIST
103228: LIST
103229: LIST
103230: PUSH
103231: LD_INT 101
103233: PUSH
103234: LD_INT 102
103236: PUSH
103237: LD_INT 103
103239: PUSH
103240: LD_INT 104
103242: PUSH
103243: LD_INT 105
103245: PUSH
103246: LD_INT 106
103248: PUSH
103249: LD_INT 107
103251: PUSH
103252: LD_INT 108
103254: PUSH
103255: LD_INT 109
103257: PUSH
103258: LD_INT 110
103260: PUSH
103261: LD_INT 111
103263: PUSH
103264: LD_INT 112
103266: PUSH
103267: LD_INT 113
103269: PUSH
103270: LD_INT 114
103272: PUSH
103273: LD_INT 115
103275: PUSH
103276: LD_INT 116
103278: PUSH
103279: LD_INT 117
103281: PUSH
103282: LD_INT 118
103284: PUSH
103285: EMPTY
103286: LIST
103287: LIST
103288: LIST
103289: LIST
103290: LIST
103291: LIST
103292: LIST
103293: LIST
103294: LIST
103295: LIST
103296: LIST
103297: LIST
103298: LIST
103299: LIST
103300: LIST
103301: LIST
103302: LIST
103303: LIST
103304: PUSH
103305: EMPTY
103306: LIST
103307: LIST
103308: ST_TO_ADDR
// if result then
103309: LD_VAR 0 2
103313: IFFALSE 104099
// begin normal :=  ;
103315: LD_ADDR_VAR 0 5
103319: PUSH
103320: LD_STRING 
103322: ST_TO_ADDR
// hardcore :=  ;
103323: LD_ADDR_VAR 0 6
103327: PUSH
103328: LD_STRING 
103330: ST_TO_ADDR
// active :=  ;
103331: LD_ADDR_VAR 0 7
103335: PUSH
103336: LD_STRING 
103338: ST_TO_ADDR
// for i = 1 to normalCounter do
103339: LD_ADDR_VAR 0 8
103343: PUSH
103344: DOUBLE
103345: LD_INT 1
103347: DEC
103348: ST_TO_ADDR
103349: LD_EXP 127
103353: PUSH
103354: FOR_TO
103355: IFFALSE 103456
// begin tmp := 0 ;
103357: LD_ADDR_VAR 0 3
103361: PUSH
103362: LD_STRING 0
103364: ST_TO_ADDR
// if result [ 1 ] then
103365: LD_VAR 0 2
103369: PUSH
103370: LD_INT 1
103372: ARRAY
103373: IFFALSE 103438
// if result [ 1 ] [ 1 ] = i then
103375: LD_VAR 0 2
103379: PUSH
103380: LD_INT 1
103382: ARRAY
103383: PUSH
103384: LD_INT 1
103386: ARRAY
103387: PUSH
103388: LD_VAR 0 8
103392: EQUAL
103393: IFFALSE 103438
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
103395: LD_ADDR_VAR 0 2
103399: PUSH
103400: LD_VAR 0 2
103404: PPUSH
103405: LD_INT 1
103407: PPUSH
103408: LD_VAR 0 2
103412: PUSH
103413: LD_INT 1
103415: ARRAY
103416: PPUSH
103417: LD_INT 1
103419: PPUSH
103420: CALL_OW 3
103424: PPUSH
103425: CALL_OW 1
103429: ST_TO_ADDR
// tmp := 1 ;
103430: LD_ADDR_VAR 0 3
103434: PUSH
103435: LD_STRING 1
103437: ST_TO_ADDR
// end ; normal := normal & tmp ;
103438: LD_ADDR_VAR 0 5
103442: PUSH
103443: LD_VAR 0 5
103447: PUSH
103448: LD_VAR 0 3
103452: STR
103453: ST_TO_ADDR
// end ;
103454: GO 103354
103456: POP
103457: POP
// for i = 1 to hardcoreCounter do
103458: LD_ADDR_VAR 0 8
103462: PUSH
103463: DOUBLE
103464: LD_INT 1
103466: DEC
103467: ST_TO_ADDR
103468: LD_EXP 128
103472: PUSH
103473: FOR_TO
103474: IFFALSE 103579
// begin tmp := 0 ;
103476: LD_ADDR_VAR 0 3
103480: PUSH
103481: LD_STRING 0
103483: ST_TO_ADDR
// if result [ 2 ] then
103484: LD_VAR 0 2
103488: PUSH
103489: LD_INT 2
103491: ARRAY
103492: IFFALSE 103561
// if result [ 2 ] [ 1 ] = 100 + i then
103494: LD_VAR 0 2
103498: PUSH
103499: LD_INT 2
103501: ARRAY
103502: PUSH
103503: LD_INT 1
103505: ARRAY
103506: PUSH
103507: LD_INT 100
103509: PUSH
103510: LD_VAR 0 8
103514: PLUS
103515: EQUAL
103516: IFFALSE 103561
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
103518: LD_ADDR_VAR 0 2
103522: PUSH
103523: LD_VAR 0 2
103527: PPUSH
103528: LD_INT 2
103530: PPUSH
103531: LD_VAR 0 2
103535: PUSH
103536: LD_INT 2
103538: ARRAY
103539: PPUSH
103540: LD_INT 1
103542: PPUSH
103543: CALL_OW 3
103547: PPUSH
103548: CALL_OW 1
103552: ST_TO_ADDR
// tmp := 1 ;
103553: LD_ADDR_VAR 0 3
103557: PUSH
103558: LD_STRING 1
103560: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
103561: LD_ADDR_VAR 0 6
103565: PUSH
103566: LD_VAR 0 6
103570: PUSH
103571: LD_VAR 0 3
103575: STR
103576: ST_TO_ADDR
// end ;
103577: GO 103473
103579: POP
103580: POP
// if isGameLoad then
103581: LD_VAR 0 1
103585: IFFALSE 104060
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
103587: LD_ADDR_VAR 0 4
103591: PUSH
103592: LD_EXP 131
103596: PUSH
103597: LD_EXP 130
103601: PUSH
103602: LD_EXP 132
103606: PUSH
103607: LD_EXP 129
103611: PUSH
103612: LD_EXP 133
103616: PUSH
103617: LD_EXP 134
103621: PUSH
103622: LD_EXP 135
103626: PUSH
103627: LD_EXP 136
103631: PUSH
103632: LD_EXP 137
103636: PUSH
103637: LD_EXP 138
103641: PUSH
103642: LD_EXP 139
103646: PUSH
103647: LD_EXP 140
103651: PUSH
103652: LD_EXP 141
103656: PUSH
103657: LD_EXP 142
103661: PUSH
103662: LD_EXP 150
103666: PUSH
103667: LD_EXP 151
103671: PUSH
103672: LD_EXP 152
103676: PUSH
103677: LD_EXP 153
103681: PUSH
103682: LD_EXP 155
103686: PUSH
103687: LD_EXP 156
103691: PUSH
103692: LD_EXP 157
103696: PUSH
103697: LD_EXP 160
103701: PUSH
103702: LD_EXP 162
103706: PUSH
103707: LD_EXP 163
103711: PUSH
103712: LD_EXP 164
103716: PUSH
103717: LD_EXP 166
103721: PUSH
103722: LD_EXP 167
103726: PUSH
103727: LD_EXP 170
103731: PUSH
103732: LD_EXP 171
103736: PUSH
103737: LD_EXP 172
103741: PUSH
103742: LD_EXP 173
103746: PUSH
103747: LD_EXP 174
103751: PUSH
103752: LD_EXP 175
103756: PUSH
103757: LD_EXP 176
103761: PUSH
103762: LD_EXP 177
103766: PUSH
103767: LD_EXP 178
103771: PUSH
103772: LD_EXP 143
103776: PUSH
103777: LD_EXP 144
103781: PUSH
103782: LD_EXP 147
103786: PUSH
103787: LD_EXP 148
103791: PUSH
103792: LD_EXP 149
103796: PUSH
103797: LD_EXP 145
103801: PUSH
103802: LD_EXP 146
103806: PUSH
103807: LD_EXP 154
103811: PUSH
103812: LD_EXP 158
103816: PUSH
103817: LD_EXP 159
103821: PUSH
103822: LD_EXP 161
103826: PUSH
103827: LD_EXP 165
103831: PUSH
103832: LD_EXP 168
103836: PUSH
103837: LD_EXP 169
103841: PUSH
103842: LD_EXP 179
103846: PUSH
103847: LD_EXP 180
103851: PUSH
103852: LD_EXP 181
103856: PUSH
103857: LD_EXP 182
103861: PUSH
103862: EMPTY
103863: LIST
103864: LIST
103865: LIST
103866: LIST
103867: LIST
103868: LIST
103869: LIST
103870: LIST
103871: LIST
103872: LIST
103873: LIST
103874: LIST
103875: LIST
103876: LIST
103877: LIST
103878: LIST
103879: LIST
103880: LIST
103881: LIST
103882: LIST
103883: LIST
103884: LIST
103885: LIST
103886: LIST
103887: LIST
103888: LIST
103889: LIST
103890: LIST
103891: LIST
103892: LIST
103893: LIST
103894: LIST
103895: LIST
103896: LIST
103897: LIST
103898: LIST
103899: LIST
103900: LIST
103901: LIST
103902: LIST
103903: LIST
103904: LIST
103905: LIST
103906: LIST
103907: LIST
103908: LIST
103909: LIST
103910: LIST
103911: LIST
103912: LIST
103913: LIST
103914: LIST
103915: LIST
103916: LIST
103917: ST_TO_ADDR
// tmp :=  ;
103918: LD_ADDR_VAR 0 3
103922: PUSH
103923: LD_STRING 
103925: ST_TO_ADDR
// for i = 1 to normalCounter do
103926: LD_ADDR_VAR 0 8
103930: PUSH
103931: DOUBLE
103932: LD_INT 1
103934: DEC
103935: ST_TO_ADDR
103936: LD_EXP 127
103940: PUSH
103941: FOR_TO
103942: IFFALSE 103978
// begin if flags [ i ] then
103944: LD_VAR 0 4
103948: PUSH
103949: LD_VAR 0 8
103953: ARRAY
103954: IFFALSE 103976
// tmp := tmp & i & ; ;
103956: LD_ADDR_VAR 0 3
103960: PUSH
103961: LD_VAR 0 3
103965: PUSH
103966: LD_VAR 0 8
103970: STR
103971: PUSH
103972: LD_STRING ;
103974: STR
103975: ST_TO_ADDR
// end ;
103976: GO 103941
103978: POP
103979: POP
// for i = 1 to hardcoreCounter do
103980: LD_ADDR_VAR 0 8
103984: PUSH
103985: DOUBLE
103986: LD_INT 1
103988: DEC
103989: ST_TO_ADDR
103990: LD_EXP 128
103994: PUSH
103995: FOR_TO
103996: IFFALSE 104042
// begin if flags [ normalCounter + i ] then
103998: LD_VAR 0 4
104002: PUSH
104003: LD_EXP 127
104007: PUSH
104008: LD_VAR 0 8
104012: PLUS
104013: ARRAY
104014: IFFALSE 104040
// tmp := tmp & ( 100 + i ) & ; ;
104016: LD_ADDR_VAR 0 3
104020: PUSH
104021: LD_VAR 0 3
104025: PUSH
104026: LD_INT 100
104028: PUSH
104029: LD_VAR 0 8
104033: PLUS
104034: STR
104035: PUSH
104036: LD_STRING ;
104038: STR
104039: ST_TO_ADDR
// end ;
104040: GO 103995
104042: POP
104043: POP
// if tmp then
104044: LD_VAR 0 3
104048: IFFALSE 104060
// active := tmp ;
104050: LD_ADDR_VAR 0 7
104054: PUSH
104055: LD_VAR 0 3
104059: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
104060: LD_STRING getStreamItemsFromMission("
104062: PUSH
104063: LD_VAR 0 5
104067: STR
104068: PUSH
104069: LD_STRING ","
104071: STR
104072: PUSH
104073: LD_VAR 0 6
104077: STR
104078: PUSH
104079: LD_STRING ","
104081: STR
104082: PUSH
104083: LD_VAR 0 7
104087: STR
104088: PUSH
104089: LD_STRING ")
104091: STR
104092: PPUSH
104093: CALL_OW 559
// end else
104097: GO 104106
// ToLua ( getStreamItemsFromMission("","","") ) ;
104099: LD_STRING getStreamItemsFromMission("","","")
104101: PPUSH
104102: CALL_OW 559
// end ;
104106: LD_VAR 0 2
104110: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
104111: LD_EXP 126
104115: IFFALSE 104123
104117: PUSH
104118: LD_EXP 131
104122: AND
104123: IFFALSE 104247
104125: GO 104127
104127: DISABLE
104128: LD_INT 0
104130: PPUSH
104131: PPUSH
// begin enable ;
104132: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
104133: LD_ADDR_VAR 0 2
104137: PUSH
104138: LD_INT 22
104140: PUSH
104141: LD_OWVAR 2
104145: PUSH
104146: EMPTY
104147: LIST
104148: LIST
104149: PUSH
104150: LD_INT 2
104152: PUSH
104153: LD_INT 34
104155: PUSH
104156: LD_INT 7
104158: PUSH
104159: EMPTY
104160: LIST
104161: LIST
104162: PUSH
104163: LD_INT 34
104165: PUSH
104166: LD_INT 45
104168: PUSH
104169: EMPTY
104170: LIST
104171: LIST
104172: PUSH
104173: LD_INT 34
104175: PUSH
104176: LD_INT 28
104178: PUSH
104179: EMPTY
104180: LIST
104181: LIST
104182: PUSH
104183: LD_INT 34
104185: PUSH
104186: LD_INT 47
104188: PUSH
104189: EMPTY
104190: LIST
104191: LIST
104192: PUSH
104193: EMPTY
104194: LIST
104195: LIST
104196: LIST
104197: LIST
104198: LIST
104199: PUSH
104200: EMPTY
104201: LIST
104202: LIST
104203: PPUSH
104204: CALL_OW 69
104208: ST_TO_ADDR
// if not tmp then
104209: LD_VAR 0 2
104213: NOT
104214: IFFALSE 104218
// exit ;
104216: GO 104247
// for i in tmp do
104218: LD_ADDR_VAR 0 1
104222: PUSH
104223: LD_VAR 0 2
104227: PUSH
104228: FOR_IN
104229: IFFALSE 104245
// begin SetLives ( i , 0 ) ;
104231: LD_VAR 0 1
104235: PPUSH
104236: LD_INT 0
104238: PPUSH
104239: CALL_OW 234
// end ;
104243: GO 104228
104245: POP
104246: POP
// end ;
104247: PPOPN 2
104249: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
104250: LD_EXP 126
104254: IFFALSE 104262
104256: PUSH
104257: LD_EXP 132
104261: AND
104262: IFFALSE 104346
104264: GO 104266
104266: DISABLE
104267: LD_INT 0
104269: PPUSH
104270: PPUSH
// begin enable ;
104271: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
104272: LD_ADDR_VAR 0 2
104276: PUSH
104277: LD_INT 22
104279: PUSH
104280: LD_OWVAR 2
104284: PUSH
104285: EMPTY
104286: LIST
104287: LIST
104288: PUSH
104289: LD_INT 32
104291: PUSH
104292: LD_INT 3
104294: PUSH
104295: EMPTY
104296: LIST
104297: LIST
104298: PUSH
104299: EMPTY
104300: LIST
104301: LIST
104302: PPUSH
104303: CALL_OW 69
104307: ST_TO_ADDR
// if not tmp then
104308: LD_VAR 0 2
104312: NOT
104313: IFFALSE 104317
// exit ;
104315: GO 104346
// for i in tmp do
104317: LD_ADDR_VAR 0 1
104321: PUSH
104322: LD_VAR 0 2
104326: PUSH
104327: FOR_IN
104328: IFFALSE 104344
// begin SetLives ( i , 0 ) ;
104330: LD_VAR 0 1
104334: PPUSH
104335: LD_INT 0
104337: PPUSH
104338: CALL_OW 234
// end ;
104342: GO 104327
104344: POP
104345: POP
// end ;
104346: PPOPN 2
104348: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
104349: LD_EXP 126
104353: IFFALSE 104361
104355: PUSH
104356: LD_EXP 129
104360: AND
104361: IFFALSE 104454
104363: GO 104365
104365: DISABLE
104366: LD_INT 0
104368: PPUSH
// begin enable ;
104369: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
104370: LD_ADDR_VAR 0 1
104374: PUSH
104375: LD_INT 22
104377: PUSH
104378: LD_OWVAR 2
104382: PUSH
104383: EMPTY
104384: LIST
104385: LIST
104386: PUSH
104387: LD_INT 2
104389: PUSH
104390: LD_INT 25
104392: PUSH
104393: LD_INT 5
104395: PUSH
104396: EMPTY
104397: LIST
104398: LIST
104399: PUSH
104400: LD_INT 25
104402: PUSH
104403: LD_INT 9
104405: PUSH
104406: EMPTY
104407: LIST
104408: LIST
104409: PUSH
104410: LD_INT 25
104412: PUSH
104413: LD_INT 8
104415: PUSH
104416: EMPTY
104417: LIST
104418: LIST
104419: PUSH
104420: EMPTY
104421: LIST
104422: LIST
104423: LIST
104424: LIST
104425: PUSH
104426: EMPTY
104427: LIST
104428: LIST
104429: PPUSH
104430: CALL_OW 69
104434: PUSH
104435: FOR_IN
104436: IFFALSE 104452
// begin SetClass ( i , 1 ) ;
104438: LD_VAR 0 1
104442: PPUSH
104443: LD_INT 1
104445: PPUSH
104446: CALL_OW 336
// end ;
104450: GO 104435
104452: POP
104453: POP
// end ;
104454: PPOPN 1
104456: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
104457: LD_EXP 126
104461: IFFALSE 104469
104463: PUSH
104464: LD_EXP 130
104468: AND
104469: IFFALSE 104481
104471: PUSH
104472: LD_OWVAR 65
104476: PUSH
104477: LD_INT 7
104479: LESS
104480: AND
104481: IFFALSE 104495
104483: GO 104485
104485: DISABLE
// begin enable ;
104486: ENABLE
// game_speed := 7 ;
104487: LD_ADDR_OWVAR 65
104491: PUSH
104492: LD_INT 7
104494: ST_TO_ADDR
// end ;
104495: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
104496: LD_EXP 126
104500: IFFALSE 104508
104502: PUSH
104503: LD_EXP 133
104507: AND
104508: IFFALSE 104710
104510: GO 104512
104512: DISABLE
104513: LD_INT 0
104515: PPUSH
104516: PPUSH
104517: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104518: LD_ADDR_VAR 0 3
104522: PUSH
104523: LD_INT 81
104525: PUSH
104526: LD_OWVAR 2
104530: PUSH
104531: EMPTY
104532: LIST
104533: LIST
104534: PUSH
104535: LD_INT 21
104537: PUSH
104538: LD_INT 1
104540: PUSH
104541: EMPTY
104542: LIST
104543: LIST
104544: PUSH
104545: EMPTY
104546: LIST
104547: LIST
104548: PPUSH
104549: CALL_OW 69
104553: ST_TO_ADDR
// if not tmp then
104554: LD_VAR 0 3
104558: NOT
104559: IFFALSE 104563
// exit ;
104561: GO 104710
// if tmp > 5 then
104563: LD_VAR 0 3
104567: PUSH
104568: LD_INT 5
104570: GREATER
104571: IFFALSE 104583
// k := 5 else
104573: LD_ADDR_VAR 0 2
104577: PUSH
104578: LD_INT 5
104580: ST_TO_ADDR
104581: GO 104593
// k := tmp ;
104583: LD_ADDR_VAR 0 2
104587: PUSH
104588: LD_VAR 0 3
104592: ST_TO_ADDR
// for i := 1 to k do
104593: LD_ADDR_VAR 0 1
104597: PUSH
104598: DOUBLE
104599: LD_INT 1
104601: DEC
104602: ST_TO_ADDR
104603: LD_VAR 0 2
104607: PUSH
104608: FOR_TO
104609: IFFALSE 104708
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
104611: LD_VAR 0 3
104615: PUSH
104616: LD_VAR 0 1
104620: ARRAY
104621: PPUSH
104622: LD_VAR 0 1
104626: PUSH
104627: LD_INT 4
104629: MOD
104630: PUSH
104631: LD_INT 1
104633: PLUS
104634: PPUSH
104635: CALL_OW 259
104639: PUSH
104640: LD_INT 10
104642: LESS
104643: IFFALSE 104706
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
104645: LD_VAR 0 3
104649: PUSH
104650: LD_VAR 0 1
104654: ARRAY
104655: PPUSH
104656: LD_VAR 0 1
104660: PUSH
104661: LD_INT 4
104663: MOD
104664: PUSH
104665: LD_INT 1
104667: PLUS
104668: PPUSH
104669: LD_VAR 0 3
104673: PUSH
104674: LD_VAR 0 1
104678: ARRAY
104679: PPUSH
104680: LD_VAR 0 1
104684: PUSH
104685: LD_INT 4
104687: MOD
104688: PUSH
104689: LD_INT 1
104691: PLUS
104692: PPUSH
104693: CALL_OW 259
104697: PUSH
104698: LD_INT 1
104700: PLUS
104701: PPUSH
104702: CALL_OW 237
104706: GO 104608
104708: POP
104709: POP
// end ;
104710: PPOPN 3
104712: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
104713: LD_EXP 126
104717: IFFALSE 104725
104719: PUSH
104720: LD_EXP 134
104724: AND
104725: IFFALSE 104745
104727: GO 104729
104729: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
104730: LD_INT 4
104732: PPUSH
104733: LD_OWVAR 2
104737: PPUSH
104738: LD_INT 0
104740: PPUSH
104741: CALL_OW 324
104745: END
// every 0 0$1 trigger StreamModeActive and sShovel do
104746: LD_EXP 126
104750: IFFALSE 104758
104752: PUSH
104753: LD_EXP 163
104757: AND
104758: IFFALSE 104778
104760: GO 104762
104762: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
104763: LD_INT 19
104765: PPUSH
104766: LD_OWVAR 2
104770: PPUSH
104771: LD_INT 0
104773: PPUSH
104774: CALL_OW 324
104778: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
104779: LD_EXP 126
104783: IFFALSE 104791
104785: PUSH
104786: LD_EXP 135
104790: AND
104791: IFFALSE 104893
104793: GO 104795
104795: DISABLE
104796: LD_INT 0
104798: PPUSH
104799: PPUSH
// begin enable ;
104800: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
104801: LD_ADDR_VAR 0 2
104805: PUSH
104806: LD_INT 22
104808: PUSH
104809: LD_OWVAR 2
104813: PUSH
104814: EMPTY
104815: LIST
104816: LIST
104817: PUSH
104818: LD_INT 2
104820: PUSH
104821: LD_INT 34
104823: PUSH
104824: LD_INT 11
104826: PUSH
104827: EMPTY
104828: LIST
104829: LIST
104830: PUSH
104831: LD_INT 34
104833: PUSH
104834: LD_INT 30
104836: PUSH
104837: EMPTY
104838: LIST
104839: LIST
104840: PUSH
104841: EMPTY
104842: LIST
104843: LIST
104844: LIST
104845: PUSH
104846: EMPTY
104847: LIST
104848: LIST
104849: PPUSH
104850: CALL_OW 69
104854: ST_TO_ADDR
// if not tmp then
104855: LD_VAR 0 2
104859: NOT
104860: IFFALSE 104864
// exit ;
104862: GO 104893
// for i in tmp do
104864: LD_ADDR_VAR 0 1
104868: PUSH
104869: LD_VAR 0 2
104873: PUSH
104874: FOR_IN
104875: IFFALSE 104891
// begin SetLives ( i , 0 ) ;
104877: LD_VAR 0 1
104881: PPUSH
104882: LD_INT 0
104884: PPUSH
104885: CALL_OW 234
// end ;
104889: GO 104874
104891: POP
104892: POP
// end ;
104893: PPOPN 2
104895: END
// every 0 0$1 trigger StreamModeActive and sBunker do
104896: LD_EXP 126
104900: IFFALSE 104908
104902: PUSH
104903: LD_EXP 136
104907: AND
104908: IFFALSE 104928
104910: GO 104912
104912: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
104913: LD_INT 32
104915: PPUSH
104916: LD_OWVAR 2
104920: PPUSH
104921: LD_INT 0
104923: PPUSH
104924: CALL_OW 324
104928: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
104929: LD_EXP 126
104933: IFFALSE 104941
104935: PUSH
104936: LD_EXP 137
104940: AND
104941: IFFALSE 105124
104943: GO 104945
104945: DISABLE
104946: LD_INT 0
104948: PPUSH
104949: PPUSH
104950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
104951: LD_ADDR_VAR 0 2
104955: PUSH
104956: LD_INT 22
104958: PUSH
104959: LD_OWVAR 2
104963: PUSH
104964: EMPTY
104965: LIST
104966: LIST
104967: PUSH
104968: LD_INT 33
104970: PUSH
104971: LD_INT 3
104973: PUSH
104974: EMPTY
104975: LIST
104976: LIST
104977: PUSH
104978: EMPTY
104979: LIST
104980: LIST
104981: PPUSH
104982: CALL_OW 69
104986: ST_TO_ADDR
// if not tmp then
104987: LD_VAR 0 2
104991: NOT
104992: IFFALSE 104996
// exit ;
104994: GO 105124
// side := 0 ;
104996: LD_ADDR_VAR 0 3
105000: PUSH
105001: LD_INT 0
105003: ST_TO_ADDR
// for i := 1 to 8 do
105004: LD_ADDR_VAR 0 1
105008: PUSH
105009: DOUBLE
105010: LD_INT 1
105012: DEC
105013: ST_TO_ADDR
105014: LD_INT 8
105016: PUSH
105017: FOR_TO
105018: IFFALSE 105068
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
105020: LD_OWVAR 2
105024: PUSH
105025: LD_VAR 0 1
105029: NONEQUAL
105030: IFFALSE 105052
105032: PUSH
105033: LD_OWVAR 2
105037: PPUSH
105038: LD_VAR 0 1
105042: PPUSH
105043: CALL_OW 81
105047: PUSH
105048: LD_INT 2
105050: EQUAL
105051: AND
105052: IFFALSE 105066
// begin side := i ;
105054: LD_ADDR_VAR 0 3
105058: PUSH
105059: LD_VAR 0 1
105063: ST_TO_ADDR
// break ;
105064: GO 105068
// end ;
105066: GO 105017
105068: POP
105069: POP
// if not side then
105070: LD_VAR 0 3
105074: NOT
105075: IFFALSE 105079
// exit ;
105077: GO 105124
// for i := 1 to tmp do
105079: LD_ADDR_VAR 0 1
105083: PUSH
105084: DOUBLE
105085: LD_INT 1
105087: DEC
105088: ST_TO_ADDR
105089: LD_VAR 0 2
105093: PUSH
105094: FOR_TO
105095: IFFALSE 105122
// if Prob ( 60 ) then
105097: LD_INT 60
105099: PPUSH
105100: CALL_OW 13
105104: IFFALSE 105120
// SetSide ( i , side ) ;
105106: LD_VAR 0 1
105110: PPUSH
105111: LD_VAR 0 3
105115: PPUSH
105116: CALL_OW 235
105120: GO 105094
105122: POP
105123: POP
// end ;
105124: PPOPN 3
105126: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
105127: LD_EXP 126
105131: IFFALSE 105139
105133: PUSH
105134: LD_EXP 139
105138: AND
105139: IFFALSE 105258
105141: GO 105143
105143: DISABLE
105144: LD_INT 0
105146: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
105147: LD_ADDR_VAR 0 1
105151: PUSH
105152: LD_INT 22
105154: PUSH
105155: LD_OWVAR 2
105159: PUSH
105160: EMPTY
105161: LIST
105162: LIST
105163: PUSH
105164: LD_INT 21
105166: PUSH
105167: LD_INT 1
105169: PUSH
105170: EMPTY
105171: LIST
105172: LIST
105173: PUSH
105174: LD_INT 3
105176: PUSH
105177: LD_INT 23
105179: PUSH
105180: LD_INT 0
105182: PUSH
105183: EMPTY
105184: LIST
105185: LIST
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: PUSH
105191: EMPTY
105192: LIST
105193: LIST
105194: LIST
105195: PPUSH
105196: CALL_OW 69
105200: PUSH
105201: FOR_IN
105202: IFFALSE 105256
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
105204: LD_VAR 0 1
105208: PPUSH
105209: CALL_OW 257
105213: PUSH
105214: LD_INT 1
105216: PUSH
105217: LD_INT 2
105219: PUSH
105220: LD_INT 3
105222: PUSH
105223: LD_INT 4
105225: PUSH
105226: EMPTY
105227: LIST
105228: LIST
105229: LIST
105230: LIST
105231: IN
105232: IFFALSE 105254
// SetClass ( un , rand ( 1 , 4 ) ) ;
105234: LD_VAR 0 1
105238: PPUSH
105239: LD_INT 1
105241: PPUSH
105242: LD_INT 4
105244: PPUSH
105245: CALL_OW 12
105249: PPUSH
105250: CALL_OW 336
105254: GO 105201
105256: POP
105257: POP
// end ;
105258: PPOPN 1
105260: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
105261: LD_EXP 126
105265: IFFALSE 105273
105267: PUSH
105268: LD_EXP 138
105272: AND
105273: IFFALSE 105352
105275: GO 105277
105277: DISABLE
105278: LD_INT 0
105280: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
105281: LD_ADDR_VAR 0 1
105285: PUSH
105286: LD_INT 22
105288: PUSH
105289: LD_OWVAR 2
105293: PUSH
105294: EMPTY
105295: LIST
105296: LIST
105297: PUSH
105298: LD_INT 21
105300: PUSH
105301: LD_INT 3
105303: PUSH
105304: EMPTY
105305: LIST
105306: LIST
105307: PUSH
105308: EMPTY
105309: LIST
105310: LIST
105311: PPUSH
105312: CALL_OW 69
105316: ST_TO_ADDR
// if not tmp then
105317: LD_VAR 0 1
105321: NOT
105322: IFFALSE 105326
// exit ;
105324: GO 105352
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
105326: LD_VAR 0 1
105330: PUSH
105331: LD_INT 1
105333: PPUSH
105334: LD_VAR 0 1
105338: PPUSH
105339: CALL_OW 12
105343: ARRAY
105344: PPUSH
105345: LD_INT 100
105347: PPUSH
105348: CALL_OW 234
// end ;
105352: PPOPN 1
105354: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
105355: LD_EXP 126
105359: IFFALSE 105367
105361: PUSH
105362: LD_EXP 140
105366: AND
105367: IFFALSE 105465
105369: GO 105371
105371: DISABLE
105372: LD_INT 0
105374: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105375: LD_ADDR_VAR 0 1
105379: PUSH
105380: LD_INT 22
105382: PUSH
105383: LD_OWVAR 2
105387: PUSH
105388: EMPTY
105389: LIST
105390: LIST
105391: PUSH
105392: LD_INT 21
105394: PUSH
105395: LD_INT 1
105397: PUSH
105398: EMPTY
105399: LIST
105400: LIST
105401: PUSH
105402: EMPTY
105403: LIST
105404: LIST
105405: PPUSH
105406: CALL_OW 69
105410: ST_TO_ADDR
// if not tmp then
105411: LD_VAR 0 1
105415: NOT
105416: IFFALSE 105420
// exit ;
105418: GO 105465
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
105420: LD_VAR 0 1
105424: PUSH
105425: LD_INT 1
105427: PPUSH
105428: LD_VAR 0 1
105432: PPUSH
105433: CALL_OW 12
105437: ARRAY
105438: PPUSH
105439: LD_INT 1
105441: PPUSH
105442: LD_INT 4
105444: PPUSH
105445: CALL_OW 12
105449: PPUSH
105450: LD_INT 3000
105452: PPUSH
105453: LD_INT 9000
105455: PPUSH
105456: CALL_OW 12
105460: PPUSH
105461: CALL_OW 492
// end ;
105465: PPOPN 1
105467: END
// every 0 0$1 trigger StreamModeActive and sDepot do
105468: LD_EXP 126
105472: IFFALSE 105480
105474: PUSH
105475: LD_EXP 141
105479: AND
105480: IFFALSE 105500
105482: GO 105484
105484: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
105485: LD_INT 1
105487: PPUSH
105488: LD_OWVAR 2
105492: PPUSH
105493: LD_INT 0
105495: PPUSH
105496: CALL_OW 324
105500: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
105501: LD_EXP 126
105505: IFFALSE 105513
105507: PUSH
105508: LD_EXP 142
105512: AND
105513: IFFALSE 105596
105515: GO 105517
105517: DISABLE
105518: LD_INT 0
105520: PPUSH
105521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
105522: LD_ADDR_VAR 0 2
105526: PUSH
105527: LD_INT 22
105529: PUSH
105530: LD_OWVAR 2
105534: PUSH
105535: EMPTY
105536: LIST
105537: LIST
105538: PUSH
105539: LD_INT 21
105541: PUSH
105542: LD_INT 3
105544: PUSH
105545: EMPTY
105546: LIST
105547: LIST
105548: PUSH
105549: EMPTY
105550: LIST
105551: LIST
105552: PPUSH
105553: CALL_OW 69
105557: ST_TO_ADDR
// if not tmp then
105558: LD_VAR 0 2
105562: NOT
105563: IFFALSE 105567
// exit ;
105565: GO 105596
// for i in tmp do
105567: LD_ADDR_VAR 0 1
105571: PUSH
105572: LD_VAR 0 2
105576: PUSH
105577: FOR_IN
105578: IFFALSE 105594
// SetBLevel ( i , 10 ) ;
105580: LD_VAR 0 1
105584: PPUSH
105585: LD_INT 10
105587: PPUSH
105588: CALL_OW 241
105592: GO 105577
105594: POP
105595: POP
// end ;
105596: PPOPN 2
105598: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
105599: LD_EXP 126
105603: IFFALSE 105611
105605: PUSH
105606: LD_EXP 143
105610: AND
105611: IFFALSE 105722
105613: GO 105615
105615: DISABLE
105616: LD_INT 0
105618: PPUSH
105619: PPUSH
105620: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105621: LD_ADDR_VAR 0 3
105625: PUSH
105626: LD_INT 22
105628: PUSH
105629: LD_OWVAR 2
105633: PUSH
105634: EMPTY
105635: LIST
105636: LIST
105637: PUSH
105638: LD_INT 25
105640: PUSH
105641: LD_INT 1
105643: PUSH
105644: EMPTY
105645: LIST
105646: LIST
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: PPUSH
105652: CALL_OW 69
105656: ST_TO_ADDR
// if not tmp then
105657: LD_VAR 0 3
105661: NOT
105662: IFFALSE 105666
// exit ;
105664: GO 105722
// un := tmp [ rand ( 1 , tmp ) ] ;
105666: LD_ADDR_VAR 0 2
105670: PUSH
105671: LD_VAR 0 3
105675: PUSH
105676: LD_INT 1
105678: PPUSH
105679: LD_VAR 0 3
105683: PPUSH
105684: CALL_OW 12
105688: ARRAY
105689: ST_TO_ADDR
// if Crawls ( un ) then
105690: LD_VAR 0 2
105694: PPUSH
105695: CALL_OW 318
105699: IFFALSE 105710
// ComWalk ( un ) ;
105701: LD_VAR 0 2
105705: PPUSH
105706: CALL_OW 138
// SetClass ( un , class_sniper ) ;
105710: LD_VAR 0 2
105714: PPUSH
105715: LD_INT 5
105717: PPUSH
105718: CALL_OW 336
// end ;
105722: PPOPN 3
105724: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
105725: LD_EXP 126
105729: IFFALSE 105737
105731: PUSH
105732: LD_EXP 144
105736: AND
105737: IFFALSE 105749
105739: PUSH
105740: LD_OWVAR 67
105744: PUSH
105745: LD_INT 4
105747: LESS
105748: AND
105749: IFFALSE 105768
105751: GO 105753
105753: DISABLE
// begin Difficulty := Difficulty + 1 ;
105754: LD_ADDR_OWVAR 67
105758: PUSH
105759: LD_OWVAR 67
105763: PUSH
105764: LD_INT 1
105766: PLUS
105767: ST_TO_ADDR
// end ;
105768: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
105769: LD_EXP 126
105773: IFFALSE 105781
105775: PUSH
105776: LD_EXP 145
105780: AND
105781: IFFALSE 105884
105783: GO 105785
105785: DISABLE
105786: LD_INT 0
105788: PPUSH
// begin for i := 1 to 5 do
105789: LD_ADDR_VAR 0 1
105793: PUSH
105794: DOUBLE
105795: LD_INT 1
105797: DEC
105798: ST_TO_ADDR
105799: LD_INT 5
105801: PUSH
105802: FOR_TO
105803: IFFALSE 105882
// begin uc_nation := nation_nature ;
105805: LD_ADDR_OWVAR 21
105809: PUSH
105810: LD_INT 0
105812: ST_TO_ADDR
// uc_side := 0 ;
105813: LD_ADDR_OWVAR 20
105817: PUSH
105818: LD_INT 0
105820: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105821: LD_ADDR_OWVAR 29
105825: PUSH
105826: LD_INT 12
105828: PUSH
105829: LD_INT 12
105831: PUSH
105832: EMPTY
105833: LIST
105834: LIST
105835: ST_TO_ADDR
// hc_agressivity := 20 ;
105836: LD_ADDR_OWVAR 35
105840: PUSH
105841: LD_INT 20
105843: ST_TO_ADDR
// hc_class := class_tiger ;
105844: LD_ADDR_OWVAR 28
105848: PUSH
105849: LD_INT 14
105851: ST_TO_ADDR
// hc_gallery :=  ;
105852: LD_ADDR_OWVAR 33
105856: PUSH
105857: LD_STRING 
105859: ST_TO_ADDR
// hc_name :=  ;
105860: LD_ADDR_OWVAR 26
105864: PUSH
105865: LD_STRING 
105867: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
105868: CALL_OW 44
105872: PPUSH
105873: LD_INT 0
105875: PPUSH
105876: CALL_OW 51
// end ;
105880: GO 105802
105882: POP
105883: POP
// end ;
105884: PPOPN 1
105886: END
// every 0 0$1 trigger StreamModeActive and sBomb do
105887: LD_EXP 126
105891: IFFALSE 105899
105893: PUSH
105894: LD_EXP 146
105898: AND
105899: IFFALSE 105908
105901: GO 105903
105903: DISABLE
// StreamSibBomb ;
105904: CALL 105909 0 0
105908: END
// export function StreamSibBomb ; var i , x , y ; begin
105909: LD_INT 0
105911: PPUSH
105912: PPUSH
105913: PPUSH
105914: PPUSH
// result := false ;
105915: LD_ADDR_VAR 0 1
105919: PUSH
105920: LD_INT 0
105922: ST_TO_ADDR
// for i := 1 to 16 do
105923: LD_ADDR_VAR 0 2
105927: PUSH
105928: DOUBLE
105929: LD_INT 1
105931: DEC
105932: ST_TO_ADDR
105933: LD_INT 16
105935: PUSH
105936: FOR_TO
105937: IFFALSE 106136
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
105939: LD_ADDR_VAR 0 3
105943: PUSH
105944: LD_INT 10
105946: PUSH
105947: LD_INT 20
105949: PUSH
105950: LD_INT 30
105952: PUSH
105953: LD_INT 40
105955: PUSH
105956: LD_INT 50
105958: PUSH
105959: LD_INT 60
105961: PUSH
105962: LD_INT 70
105964: PUSH
105965: LD_INT 80
105967: PUSH
105968: LD_INT 90
105970: PUSH
105971: LD_INT 100
105973: PUSH
105974: LD_INT 110
105976: PUSH
105977: LD_INT 120
105979: PUSH
105980: LD_INT 130
105982: PUSH
105983: LD_INT 140
105985: PUSH
105986: LD_INT 150
105988: PUSH
105989: EMPTY
105990: LIST
105991: LIST
105992: LIST
105993: LIST
105994: LIST
105995: LIST
105996: LIST
105997: LIST
105998: LIST
105999: LIST
106000: LIST
106001: LIST
106002: LIST
106003: LIST
106004: LIST
106005: PUSH
106006: LD_INT 1
106008: PPUSH
106009: LD_INT 15
106011: PPUSH
106012: CALL_OW 12
106016: ARRAY
106017: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
106018: LD_ADDR_VAR 0 4
106022: PUSH
106023: LD_INT 10
106025: PUSH
106026: LD_INT 20
106028: PUSH
106029: LD_INT 30
106031: PUSH
106032: LD_INT 40
106034: PUSH
106035: LD_INT 50
106037: PUSH
106038: LD_INT 60
106040: PUSH
106041: LD_INT 70
106043: PUSH
106044: LD_INT 80
106046: PUSH
106047: LD_INT 90
106049: PUSH
106050: LD_INT 100
106052: PUSH
106053: LD_INT 110
106055: PUSH
106056: LD_INT 120
106058: PUSH
106059: LD_INT 130
106061: PUSH
106062: LD_INT 140
106064: PUSH
106065: LD_INT 150
106067: PUSH
106068: EMPTY
106069: LIST
106070: LIST
106071: LIST
106072: LIST
106073: LIST
106074: LIST
106075: LIST
106076: LIST
106077: LIST
106078: LIST
106079: LIST
106080: LIST
106081: LIST
106082: LIST
106083: LIST
106084: PUSH
106085: LD_INT 1
106087: PPUSH
106088: LD_INT 15
106090: PPUSH
106091: CALL_OW 12
106095: ARRAY
106096: ST_TO_ADDR
// if ValidHex ( x , y ) then
106097: LD_VAR 0 3
106101: PPUSH
106102: LD_VAR 0 4
106106: PPUSH
106107: CALL_OW 488
106111: IFFALSE 106134
// begin result := [ x , y ] ;
106113: LD_ADDR_VAR 0 1
106117: PUSH
106118: LD_VAR 0 3
106122: PUSH
106123: LD_VAR 0 4
106127: PUSH
106128: EMPTY
106129: LIST
106130: LIST
106131: ST_TO_ADDR
// break ;
106132: GO 106136
// end ; end ;
106134: GO 105936
106136: POP
106137: POP
// if result then
106138: LD_VAR 0 1
106142: IFFALSE 106202
// begin ToLua ( playSibBomb() ) ;
106144: LD_STRING playSibBomb()
106146: PPUSH
106147: CALL_OW 559
// wait ( 0 0$14 ) ;
106151: LD_INT 490
106153: PPUSH
106154: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
106158: LD_VAR 0 1
106162: PUSH
106163: LD_INT 1
106165: ARRAY
106166: PPUSH
106167: LD_VAR 0 1
106171: PUSH
106172: LD_INT 2
106174: ARRAY
106175: PPUSH
106176: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
106180: LD_VAR 0 1
106184: PUSH
106185: LD_INT 1
106187: ARRAY
106188: PPUSH
106189: LD_VAR 0 1
106193: PUSH
106194: LD_INT 2
106196: ARRAY
106197: PPUSH
106198: CALL_OW 429
// end ; end ;
106202: LD_VAR 0 1
106206: RET
// every 0 0$1 trigger StreamModeActive and sReset do
106207: LD_EXP 126
106211: IFFALSE 106219
106213: PUSH
106214: LD_EXP 148
106218: AND
106219: IFFALSE 106231
106221: GO 106223
106223: DISABLE
// YouLost (  ) ;
106224: LD_STRING 
106226: PPUSH
106227: CALL_OW 104
106231: END
// every 0 0$1 trigger StreamModeActive and sFog do
106232: LD_EXP 126
106236: IFFALSE 106244
106238: PUSH
106239: LD_EXP 147
106243: AND
106244: IFFALSE 106258
106246: GO 106248
106248: DISABLE
// FogOff ( your_side ) ;
106249: LD_OWVAR 2
106253: PPUSH
106254: CALL_OW 344
106258: END
// every 0 0$1 trigger StreamModeActive and sSun do
106259: LD_EXP 126
106263: IFFALSE 106271
106265: PUSH
106266: LD_EXP 149
106270: AND
106271: IFFALSE 106299
106273: GO 106275
106275: DISABLE
// begin solar_recharge_percent := 0 ;
106276: LD_ADDR_OWVAR 79
106280: PUSH
106281: LD_INT 0
106283: ST_TO_ADDR
// wait ( 5 5$00 ) ;
106284: LD_INT 10500
106286: PPUSH
106287: CALL_OW 67
// solar_recharge_percent := 100 ;
106291: LD_ADDR_OWVAR 79
106295: PUSH
106296: LD_INT 100
106298: ST_TO_ADDR
// end ;
106299: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
106300: LD_EXP 126
106304: IFFALSE 106312
106306: PUSH
106307: LD_EXP 150
106311: AND
106312: IFFALSE 106551
106314: GO 106316
106316: DISABLE
106317: LD_INT 0
106319: PPUSH
106320: PPUSH
106321: PPUSH
// begin tmp := [ ] ;
106322: LD_ADDR_VAR 0 3
106326: PUSH
106327: EMPTY
106328: ST_TO_ADDR
// for i := 1 to 6 do
106329: LD_ADDR_VAR 0 1
106333: PUSH
106334: DOUBLE
106335: LD_INT 1
106337: DEC
106338: ST_TO_ADDR
106339: LD_INT 6
106341: PUSH
106342: FOR_TO
106343: IFFALSE 106448
// begin uc_nation := nation_nature ;
106345: LD_ADDR_OWVAR 21
106349: PUSH
106350: LD_INT 0
106352: ST_TO_ADDR
// uc_side := 0 ;
106353: LD_ADDR_OWVAR 20
106357: PUSH
106358: LD_INT 0
106360: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
106361: LD_ADDR_OWVAR 29
106365: PUSH
106366: LD_INT 12
106368: PUSH
106369: LD_INT 12
106371: PUSH
106372: EMPTY
106373: LIST
106374: LIST
106375: ST_TO_ADDR
// hc_agressivity := 20 ;
106376: LD_ADDR_OWVAR 35
106380: PUSH
106381: LD_INT 20
106383: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
106384: LD_ADDR_OWVAR 28
106388: PUSH
106389: LD_INT 17
106391: ST_TO_ADDR
// hc_gallery :=  ;
106392: LD_ADDR_OWVAR 33
106396: PUSH
106397: LD_STRING 
106399: ST_TO_ADDR
// hc_name :=  ;
106400: LD_ADDR_OWVAR 26
106404: PUSH
106405: LD_STRING 
106407: ST_TO_ADDR
// un := CreateHuman ;
106408: LD_ADDR_VAR 0 2
106412: PUSH
106413: CALL_OW 44
106417: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
106418: LD_VAR 0 2
106422: PPUSH
106423: LD_INT 1
106425: PPUSH
106426: CALL_OW 51
// tmp := tmp ^ un ;
106430: LD_ADDR_VAR 0 3
106434: PUSH
106435: LD_VAR 0 3
106439: PUSH
106440: LD_VAR 0 2
106444: ADD
106445: ST_TO_ADDR
// end ;
106446: GO 106342
106448: POP
106449: POP
// repeat wait ( 0 0$1 ) ;
106450: LD_INT 35
106452: PPUSH
106453: CALL_OW 67
// for un in tmp do
106457: LD_ADDR_VAR 0 2
106461: PUSH
106462: LD_VAR 0 3
106466: PUSH
106467: FOR_IN
106468: IFFALSE 106542
// begin if IsDead ( un ) then
106470: LD_VAR 0 2
106474: PPUSH
106475: CALL_OW 301
106479: IFFALSE 106499
// begin tmp := tmp diff un ;
106481: LD_ADDR_VAR 0 3
106485: PUSH
106486: LD_VAR 0 3
106490: PUSH
106491: LD_VAR 0 2
106495: DIFF
106496: ST_TO_ADDR
// continue ;
106497: GO 106467
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
106499: LD_VAR 0 2
106503: PPUSH
106504: LD_INT 3
106506: PUSH
106507: LD_INT 22
106509: PUSH
106510: LD_INT 0
106512: PUSH
106513: EMPTY
106514: LIST
106515: LIST
106516: PUSH
106517: EMPTY
106518: LIST
106519: LIST
106520: PPUSH
106521: CALL_OW 69
106525: PPUSH
106526: LD_VAR 0 2
106530: PPUSH
106531: CALL_OW 74
106535: PPUSH
106536: CALL_OW 115
// end ;
106540: GO 106467
106542: POP
106543: POP
// until not tmp ;
106544: LD_VAR 0 3
106548: NOT
106549: IFFALSE 106450
// end ;
106551: PPOPN 3
106553: END
// every 0 0$1 trigger StreamModeActive and sTroll do
106554: LD_EXP 126
106558: IFFALSE 106566
106560: PUSH
106561: LD_EXP 151
106565: AND
106566: IFFALSE 106620
106568: GO 106570
106570: DISABLE
// begin ToLua ( displayTroll(); ) ;
106571: LD_STRING displayTroll();
106573: PPUSH
106574: CALL_OW 559
// wait ( 3 3$00 ) ;
106578: LD_INT 6300
106580: PPUSH
106581: CALL_OW 67
// ToLua ( hideTroll(); ) ;
106585: LD_STRING hideTroll();
106587: PPUSH
106588: CALL_OW 559
// wait ( 1 1$00 ) ;
106592: LD_INT 2100
106594: PPUSH
106595: CALL_OW 67
// ToLua ( displayTroll(); ) ;
106599: LD_STRING displayTroll();
106601: PPUSH
106602: CALL_OW 559
// wait ( 1 1$00 ) ;
106606: LD_INT 2100
106608: PPUSH
106609: CALL_OW 67
// ToLua ( hideTroll(); ) ;
106613: LD_STRING hideTroll();
106615: PPUSH
106616: CALL_OW 559
// end ;
106620: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
106621: LD_EXP 126
106625: IFFALSE 106633
106627: PUSH
106628: LD_EXP 152
106632: AND
106633: IFFALSE 106696
106635: GO 106637
106637: DISABLE
106638: LD_INT 0
106640: PPUSH
// begin p := 0 ;
106641: LD_ADDR_VAR 0 1
106645: PUSH
106646: LD_INT 0
106648: ST_TO_ADDR
// repeat game_speed := 1 ;
106649: LD_ADDR_OWVAR 65
106653: PUSH
106654: LD_INT 1
106656: ST_TO_ADDR
// wait ( 0 0$1 ) ;
106657: LD_INT 35
106659: PPUSH
106660: CALL_OW 67
// p := p + 1 ;
106664: LD_ADDR_VAR 0 1
106668: PUSH
106669: LD_VAR 0 1
106673: PUSH
106674: LD_INT 1
106676: PLUS
106677: ST_TO_ADDR
// until p >= 60 ;
106678: LD_VAR 0 1
106682: PUSH
106683: LD_INT 60
106685: GREATEREQUAL
106686: IFFALSE 106649
// game_speed := 4 ;
106688: LD_ADDR_OWVAR 65
106692: PUSH
106693: LD_INT 4
106695: ST_TO_ADDR
// end ;
106696: PPOPN 1
106698: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
106699: LD_EXP 126
106703: IFFALSE 106711
106705: PUSH
106706: LD_EXP 153
106710: AND
106711: IFFALSE 106857
106713: GO 106715
106715: DISABLE
106716: LD_INT 0
106718: PPUSH
106719: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106720: LD_ADDR_VAR 0 1
106724: PUSH
106725: LD_INT 22
106727: PUSH
106728: LD_OWVAR 2
106732: PUSH
106733: EMPTY
106734: LIST
106735: LIST
106736: PUSH
106737: LD_INT 2
106739: PUSH
106740: LD_INT 30
106742: PUSH
106743: LD_INT 0
106745: PUSH
106746: EMPTY
106747: LIST
106748: LIST
106749: PUSH
106750: LD_INT 30
106752: PUSH
106753: LD_INT 1
106755: PUSH
106756: EMPTY
106757: LIST
106758: LIST
106759: PUSH
106760: EMPTY
106761: LIST
106762: LIST
106763: LIST
106764: PUSH
106765: EMPTY
106766: LIST
106767: LIST
106768: PPUSH
106769: CALL_OW 69
106773: ST_TO_ADDR
// if not depot then
106774: LD_VAR 0 1
106778: NOT
106779: IFFALSE 106783
// exit ;
106781: GO 106857
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
106783: LD_ADDR_VAR 0 2
106787: PUSH
106788: LD_VAR 0 1
106792: PUSH
106793: LD_INT 1
106795: PPUSH
106796: LD_VAR 0 1
106800: PPUSH
106801: CALL_OW 12
106805: ARRAY
106806: PPUSH
106807: CALL_OW 274
106811: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
106812: LD_VAR 0 2
106816: PPUSH
106817: LD_INT 1
106819: PPUSH
106820: LD_INT 0
106822: PPUSH
106823: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
106827: LD_VAR 0 2
106831: PPUSH
106832: LD_INT 2
106834: PPUSH
106835: LD_INT 0
106837: PPUSH
106838: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
106842: LD_VAR 0 2
106846: PPUSH
106847: LD_INT 3
106849: PPUSH
106850: LD_INT 0
106852: PPUSH
106853: CALL_OW 277
// end ;
106857: PPOPN 2
106859: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
106860: LD_EXP 126
106864: IFFALSE 106872
106866: PUSH
106867: LD_EXP 154
106871: AND
106872: IFFALSE 106969
106874: GO 106876
106876: DISABLE
106877: LD_INT 0
106879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106880: LD_ADDR_VAR 0 1
106884: PUSH
106885: LD_INT 22
106887: PUSH
106888: LD_OWVAR 2
106892: PUSH
106893: EMPTY
106894: LIST
106895: LIST
106896: PUSH
106897: LD_INT 21
106899: PUSH
106900: LD_INT 1
106902: PUSH
106903: EMPTY
106904: LIST
106905: LIST
106906: PUSH
106907: LD_INT 3
106909: PUSH
106910: LD_INT 23
106912: PUSH
106913: LD_INT 0
106915: PUSH
106916: EMPTY
106917: LIST
106918: LIST
106919: PUSH
106920: EMPTY
106921: LIST
106922: LIST
106923: PUSH
106924: EMPTY
106925: LIST
106926: LIST
106927: LIST
106928: PPUSH
106929: CALL_OW 69
106933: ST_TO_ADDR
// if not tmp then
106934: LD_VAR 0 1
106938: NOT
106939: IFFALSE 106943
// exit ;
106941: GO 106969
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
106943: LD_VAR 0 1
106947: PUSH
106948: LD_INT 1
106950: PPUSH
106951: LD_VAR 0 1
106955: PPUSH
106956: CALL_OW 12
106960: ARRAY
106961: PPUSH
106962: LD_INT 200
106964: PPUSH
106965: CALL_OW 234
// end ;
106969: PPOPN 1
106971: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
106972: LD_EXP 126
106976: IFFALSE 106984
106978: PUSH
106979: LD_EXP 155
106983: AND
106984: IFFALSE 107063
106986: GO 106988
106988: DISABLE
106989: LD_INT 0
106991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
106992: LD_ADDR_VAR 0 1
106996: PUSH
106997: LD_INT 22
106999: PUSH
107000: LD_OWVAR 2
107004: PUSH
107005: EMPTY
107006: LIST
107007: LIST
107008: PUSH
107009: LD_INT 21
107011: PUSH
107012: LD_INT 2
107014: PUSH
107015: EMPTY
107016: LIST
107017: LIST
107018: PUSH
107019: EMPTY
107020: LIST
107021: LIST
107022: PPUSH
107023: CALL_OW 69
107027: ST_TO_ADDR
// if not tmp then
107028: LD_VAR 0 1
107032: NOT
107033: IFFALSE 107037
// exit ;
107035: GO 107063
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
107037: LD_VAR 0 1
107041: PUSH
107042: LD_INT 1
107044: PPUSH
107045: LD_VAR 0 1
107049: PPUSH
107050: CALL_OW 12
107054: ARRAY
107055: PPUSH
107056: LD_INT 60
107058: PPUSH
107059: CALL_OW 234
// end ;
107063: PPOPN 1
107065: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
107066: LD_EXP 126
107070: IFFALSE 107078
107072: PUSH
107073: LD_EXP 156
107077: AND
107078: IFFALSE 107177
107080: GO 107082
107082: DISABLE
107083: LD_INT 0
107085: PPUSH
107086: PPUSH
// begin enable ;
107087: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
107088: LD_ADDR_VAR 0 1
107092: PUSH
107093: LD_INT 22
107095: PUSH
107096: LD_OWVAR 2
107100: PUSH
107101: EMPTY
107102: LIST
107103: LIST
107104: PUSH
107105: LD_INT 61
107107: PUSH
107108: EMPTY
107109: LIST
107110: PUSH
107111: LD_INT 33
107113: PUSH
107114: LD_INT 2
107116: PUSH
107117: EMPTY
107118: LIST
107119: LIST
107120: PUSH
107121: EMPTY
107122: LIST
107123: LIST
107124: LIST
107125: PPUSH
107126: CALL_OW 69
107130: ST_TO_ADDR
// if not tmp then
107131: LD_VAR 0 1
107135: NOT
107136: IFFALSE 107140
// exit ;
107138: GO 107177
// for i in tmp do
107140: LD_ADDR_VAR 0 2
107144: PUSH
107145: LD_VAR 0 1
107149: PUSH
107150: FOR_IN
107151: IFFALSE 107175
// if IsControledBy ( i ) then
107153: LD_VAR 0 2
107157: PPUSH
107158: CALL_OW 312
107162: IFFALSE 107173
// ComUnlink ( i ) ;
107164: LD_VAR 0 2
107168: PPUSH
107169: CALL_OW 136
107173: GO 107150
107175: POP
107176: POP
// end ;
107177: PPOPN 2
107179: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
107180: LD_EXP 126
107184: IFFALSE 107192
107186: PUSH
107187: LD_EXP 157
107191: AND
107192: IFFALSE 107332
107194: GO 107196
107196: DISABLE
107197: LD_INT 0
107199: PPUSH
107200: PPUSH
// begin ToLua ( displayPowell(); ) ;
107201: LD_STRING displayPowell();
107203: PPUSH
107204: CALL_OW 559
// uc_side := 0 ;
107208: LD_ADDR_OWVAR 20
107212: PUSH
107213: LD_INT 0
107215: ST_TO_ADDR
// uc_nation := 2 ;
107216: LD_ADDR_OWVAR 21
107220: PUSH
107221: LD_INT 2
107223: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
107224: LD_ADDR_OWVAR 37
107228: PUSH
107229: LD_INT 14
107231: ST_TO_ADDR
// vc_engine := engine_siberite ;
107232: LD_ADDR_OWVAR 39
107236: PUSH
107237: LD_INT 3
107239: ST_TO_ADDR
// vc_control := control_apeman ;
107240: LD_ADDR_OWVAR 38
107244: PUSH
107245: LD_INT 5
107247: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
107248: LD_ADDR_OWVAR 40
107252: PUSH
107253: LD_INT 29
107255: ST_TO_ADDR
// un := CreateVehicle ;
107256: LD_ADDR_VAR 0 2
107260: PUSH
107261: CALL_OW 45
107265: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
107266: LD_VAR 0 2
107270: PPUSH
107271: LD_INT 1
107273: PPUSH
107274: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
107278: LD_INT 35
107280: PPUSH
107281: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
107285: LD_VAR 0 2
107289: PPUSH
107290: LD_INT 22
107292: PUSH
107293: LD_OWVAR 2
107297: PUSH
107298: EMPTY
107299: LIST
107300: LIST
107301: PPUSH
107302: CALL_OW 69
107306: PPUSH
107307: LD_VAR 0 2
107311: PPUSH
107312: CALL_OW 74
107316: PPUSH
107317: CALL_OW 115
// until IsDead ( un ) ;
107321: LD_VAR 0 2
107325: PPUSH
107326: CALL_OW 301
107330: IFFALSE 107278
// end ;
107332: PPOPN 2
107334: END
// every 0 0$1 trigger StreamModeActive and sStu do
107335: LD_EXP 126
107339: IFFALSE 107347
107341: PUSH
107342: LD_EXP 165
107346: AND
107347: IFFALSE 107363
107349: GO 107351
107351: DISABLE
// begin ToLua ( displayStucuk(); ) ;
107352: LD_STRING displayStucuk();
107354: PPUSH
107355: CALL_OW 559
// ResetFog ;
107359: CALL_OW 335
// end ;
107363: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
107364: LD_EXP 126
107368: IFFALSE 107376
107370: PUSH
107371: LD_EXP 158
107375: AND
107376: IFFALSE 107517
107378: GO 107380
107380: DISABLE
107381: LD_INT 0
107383: PPUSH
107384: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107385: LD_ADDR_VAR 0 2
107389: PUSH
107390: LD_INT 22
107392: PUSH
107393: LD_OWVAR 2
107397: PUSH
107398: EMPTY
107399: LIST
107400: LIST
107401: PUSH
107402: LD_INT 21
107404: PUSH
107405: LD_INT 1
107407: PUSH
107408: EMPTY
107409: LIST
107410: LIST
107411: PUSH
107412: EMPTY
107413: LIST
107414: LIST
107415: PPUSH
107416: CALL_OW 69
107420: ST_TO_ADDR
// if not tmp then
107421: LD_VAR 0 2
107425: NOT
107426: IFFALSE 107430
// exit ;
107428: GO 107517
// un := tmp [ rand ( 1 , tmp ) ] ;
107430: LD_ADDR_VAR 0 1
107434: PUSH
107435: LD_VAR 0 2
107439: PUSH
107440: LD_INT 1
107442: PPUSH
107443: LD_VAR 0 2
107447: PPUSH
107448: CALL_OW 12
107452: ARRAY
107453: ST_TO_ADDR
// SetSide ( un , 0 ) ;
107454: LD_VAR 0 1
107458: PPUSH
107459: LD_INT 0
107461: PPUSH
107462: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
107466: LD_VAR 0 1
107470: PPUSH
107471: LD_OWVAR 3
107475: PUSH
107476: LD_VAR 0 1
107480: DIFF
107481: PPUSH
107482: LD_VAR 0 1
107486: PPUSH
107487: CALL_OW 74
107491: PPUSH
107492: CALL_OW 115
// wait ( 0 0$20 ) ;
107496: LD_INT 700
107498: PPUSH
107499: CALL_OW 67
// SetSide ( un , your_side ) ;
107503: LD_VAR 0 1
107507: PPUSH
107508: LD_OWVAR 2
107512: PPUSH
107513: CALL_OW 235
// end ;
107517: PPOPN 2
107519: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
107520: LD_EXP 126
107524: IFFALSE 107532
107526: PUSH
107527: LD_EXP 159
107531: AND
107532: IFFALSE 107638
107534: GO 107536
107536: DISABLE
107537: LD_INT 0
107539: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107540: LD_ADDR_VAR 0 1
107544: PUSH
107545: LD_INT 22
107547: PUSH
107548: LD_OWVAR 2
107552: PUSH
107553: EMPTY
107554: LIST
107555: LIST
107556: PUSH
107557: LD_INT 2
107559: PUSH
107560: LD_INT 30
107562: PUSH
107563: LD_INT 0
107565: PUSH
107566: EMPTY
107567: LIST
107568: LIST
107569: PUSH
107570: LD_INT 30
107572: PUSH
107573: LD_INT 1
107575: PUSH
107576: EMPTY
107577: LIST
107578: LIST
107579: PUSH
107580: EMPTY
107581: LIST
107582: LIST
107583: LIST
107584: PUSH
107585: EMPTY
107586: LIST
107587: LIST
107588: PPUSH
107589: CALL_OW 69
107593: ST_TO_ADDR
// if not depot then
107594: LD_VAR 0 1
107598: NOT
107599: IFFALSE 107603
// exit ;
107601: GO 107638
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
107603: LD_VAR 0 1
107607: PUSH
107608: LD_INT 1
107610: ARRAY
107611: PPUSH
107612: CALL_OW 250
107616: PPUSH
107617: LD_VAR 0 1
107621: PUSH
107622: LD_INT 1
107624: ARRAY
107625: PPUSH
107626: CALL_OW 251
107630: PPUSH
107631: LD_INT 70
107633: PPUSH
107634: CALL_OW 495
// end ;
107638: PPOPN 1
107640: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
107641: LD_EXP 126
107645: IFFALSE 107653
107647: PUSH
107648: LD_EXP 160
107652: AND
107653: IFFALSE 107864
107655: GO 107657
107657: DISABLE
107658: LD_INT 0
107660: PPUSH
107661: PPUSH
107662: PPUSH
107663: PPUSH
107664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107665: LD_ADDR_VAR 0 5
107669: PUSH
107670: LD_INT 22
107672: PUSH
107673: LD_OWVAR 2
107677: PUSH
107678: EMPTY
107679: LIST
107680: LIST
107681: PUSH
107682: LD_INT 21
107684: PUSH
107685: LD_INT 1
107687: PUSH
107688: EMPTY
107689: LIST
107690: LIST
107691: PUSH
107692: EMPTY
107693: LIST
107694: LIST
107695: PPUSH
107696: CALL_OW 69
107700: ST_TO_ADDR
// if not tmp then
107701: LD_VAR 0 5
107705: NOT
107706: IFFALSE 107710
// exit ;
107708: GO 107864
// for i in tmp do
107710: LD_ADDR_VAR 0 1
107714: PUSH
107715: LD_VAR 0 5
107719: PUSH
107720: FOR_IN
107721: IFFALSE 107862
// begin d := rand ( 0 , 5 ) ;
107723: LD_ADDR_VAR 0 4
107727: PUSH
107728: LD_INT 0
107730: PPUSH
107731: LD_INT 5
107733: PPUSH
107734: CALL_OW 12
107738: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
107739: LD_ADDR_VAR 0 2
107743: PUSH
107744: LD_VAR 0 1
107748: PPUSH
107749: CALL_OW 250
107753: PPUSH
107754: LD_VAR 0 4
107758: PPUSH
107759: LD_INT 3
107761: PPUSH
107762: LD_INT 12
107764: PPUSH
107765: CALL_OW 12
107769: PPUSH
107770: CALL_OW 272
107774: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
107775: LD_ADDR_VAR 0 3
107779: PUSH
107780: LD_VAR 0 1
107784: PPUSH
107785: CALL_OW 251
107789: PPUSH
107790: LD_VAR 0 4
107794: PPUSH
107795: LD_INT 3
107797: PPUSH
107798: LD_INT 12
107800: PPUSH
107801: CALL_OW 12
107805: PPUSH
107806: CALL_OW 273
107810: ST_TO_ADDR
// if ValidHex ( x , y ) then
107811: LD_VAR 0 2
107815: PPUSH
107816: LD_VAR 0 3
107820: PPUSH
107821: CALL_OW 488
107825: IFFALSE 107860
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
107827: LD_VAR 0 1
107831: PPUSH
107832: LD_VAR 0 2
107836: PPUSH
107837: LD_VAR 0 3
107841: PPUSH
107842: LD_INT 3
107844: PPUSH
107845: LD_INT 6
107847: PPUSH
107848: CALL_OW 12
107852: PPUSH
107853: LD_INT 1
107855: PPUSH
107856: CALL_OW 483
// end ;
107860: GO 107720
107862: POP
107863: POP
// end ;
107864: PPOPN 5
107866: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
107867: LD_EXP 126
107871: IFFALSE 107879
107873: PUSH
107874: LD_EXP 161
107878: AND
107879: IFFALSE 107973
107881: GO 107883
107883: DISABLE
107884: LD_INT 0
107886: PPUSH
107887: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
107888: LD_ADDR_VAR 0 2
107892: PUSH
107893: LD_INT 22
107895: PUSH
107896: LD_OWVAR 2
107900: PUSH
107901: EMPTY
107902: LIST
107903: LIST
107904: PUSH
107905: LD_INT 32
107907: PUSH
107908: LD_INT 1
107910: PUSH
107911: EMPTY
107912: LIST
107913: LIST
107914: PUSH
107915: LD_INT 21
107917: PUSH
107918: LD_INT 2
107920: PUSH
107921: EMPTY
107922: LIST
107923: LIST
107924: PUSH
107925: EMPTY
107926: LIST
107927: LIST
107928: LIST
107929: PPUSH
107930: CALL_OW 69
107934: ST_TO_ADDR
// if not tmp then
107935: LD_VAR 0 2
107939: NOT
107940: IFFALSE 107944
// exit ;
107942: GO 107973
// for i in tmp do
107944: LD_ADDR_VAR 0 1
107948: PUSH
107949: LD_VAR 0 2
107953: PUSH
107954: FOR_IN
107955: IFFALSE 107971
// SetFuel ( i , 0 ) ;
107957: LD_VAR 0 1
107961: PPUSH
107962: LD_INT 0
107964: PPUSH
107965: CALL_OW 240
107969: GO 107954
107971: POP
107972: POP
// end ;
107973: PPOPN 2
107975: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
107976: LD_EXP 126
107980: IFFALSE 107988
107982: PUSH
107983: LD_EXP 162
107987: AND
107988: IFFALSE 108054
107990: GO 107992
107992: DISABLE
107993: LD_INT 0
107995: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
107996: LD_ADDR_VAR 0 1
108000: PUSH
108001: LD_INT 22
108003: PUSH
108004: LD_OWVAR 2
108008: PUSH
108009: EMPTY
108010: LIST
108011: LIST
108012: PUSH
108013: LD_INT 30
108015: PUSH
108016: LD_INT 29
108018: PUSH
108019: EMPTY
108020: LIST
108021: LIST
108022: PUSH
108023: EMPTY
108024: LIST
108025: LIST
108026: PPUSH
108027: CALL_OW 69
108031: ST_TO_ADDR
// if not tmp then
108032: LD_VAR 0 1
108036: NOT
108037: IFFALSE 108041
// exit ;
108039: GO 108054
// DestroyUnit ( tmp [ 1 ] ) ;
108041: LD_VAR 0 1
108045: PUSH
108046: LD_INT 1
108048: ARRAY
108049: PPUSH
108050: CALL_OW 65
// end ;
108054: PPOPN 1
108056: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
108057: LD_EXP 126
108061: IFFALSE 108069
108063: PUSH
108064: LD_EXP 164
108068: AND
108069: IFFALSE 108198
108071: GO 108073
108073: DISABLE
108074: LD_INT 0
108076: PPUSH
// begin uc_side := 0 ;
108077: LD_ADDR_OWVAR 20
108081: PUSH
108082: LD_INT 0
108084: ST_TO_ADDR
// uc_nation := nation_arabian ;
108085: LD_ADDR_OWVAR 21
108089: PUSH
108090: LD_INT 2
108092: ST_TO_ADDR
// hc_gallery :=  ;
108093: LD_ADDR_OWVAR 33
108097: PUSH
108098: LD_STRING 
108100: ST_TO_ADDR
// hc_name :=  ;
108101: LD_ADDR_OWVAR 26
108105: PUSH
108106: LD_STRING 
108108: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
108109: LD_INT 1
108111: PPUSH
108112: LD_INT 11
108114: PPUSH
108115: LD_INT 10
108117: PPUSH
108118: CALL_OW 380
// un := CreateHuman ;
108122: LD_ADDR_VAR 0 1
108126: PUSH
108127: CALL_OW 44
108131: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
108132: LD_VAR 0 1
108136: PPUSH
108137: LD_INT 1
108139: PPUSH
108140: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
108144: LD_INT 35
108146: PPUSH
108147: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
108151: LD_VAR 0 1
108155: PPUSH
108156: LD_INT 22
108158: PUSH
108159: LD_OWVAR 2
108163: PUSH
108164: EMPTY
108165: LIST
108166: LIST
108167: PPUSH
108168: CALL_OW 69
108172: PPUSH
108173: LD_VAR 0 1
108177: PPUSH
108178: CALL_OW 74
108182: PPUSH
108183: CALL_OW 115
// until IsDead ( un ) ;
108187: LD_VAR 0 1
108191: PPUSH
108192: CALL_OW 301
108196: IFFALSE 108144
// end ;
108198: PPOPN 1
108200: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
108201: LD_EXP 126
108205: IFFALSE 108213
108207: PUSH
108208: LD_EXP 166
108212: AND
108213: IFFALSE 108225
108215: GO 108217
108217: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
108218: LD_STRING earthquake(getX(game), 0, 32)
108220: PPUSH
108221: CALL_OW 559
108225: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
108226: LD_EXP 126
108230: IFFALSE 108238
108232: PUSH
108233: LD_EXP 167
108237: AND
108238: IFFALSE 108329
108240: GO 108242
108242: DISABLE
108243: LD_INT 0
108245: PPUSH
// begin enable ;
108246: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
108247: LD_ADDR_VAR 0 1
108251: PUSH
108252: LD_INT 22
108254: PUSH
108255: LD_OWVAR 2
108259: PUSH
108260: EMPTY
108261: LIST
108262: LIST
108263: PUSH
108264: LD_INT 21
108266: PUSH
108267: LD_INT 2
108269: PUSH
108270: EMPTY
108271: LIST
108272: LIST
108273: PUSH
108274: LD_INT 33
108276: PUSH
108277: LD_INT 3
108279: PUSH
108280: EMPTY
108281: LIST
108282: LIST
108283: PUSH
108284: EMPTY
108285: LIST
108286: LIST
108287: LIST
108288: PPUSH
108289: CALL_OW 69
108293: ST_TO_ADDR
// if not tmp then
108294: LD_VAR 0 1
108298: NOT
108299: IFFALSE 108303
// exit ;
108301: GO 108329
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
108303: LD_VAR 0 1
108307: PUSH
108308: LD_INT 1
108310: PPUSH
108311: LD_VAR 0 1
108315: PPUSH
108316: CALL_OW 12
108320: ARRAY
108321: PPUSH
108322: LD_INT 1
108324: PPUSH
108325: CALL_OW 234
// end ;
108329: PPOPN 1
108331: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
108332: LD_EXP 126
108336: IFFALSE 108344
108338: PUSH
108339: LD_EXP 168
108343: AND
108344: IFFALSE 108485
108346: GO 108348
108348: DISABLE
108349: LD_INT 0
108351: PPUSH
108352: PPUSH
108353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108354: LD_ADDR_VAR 0 3
108358: PUSH
108359: LD_INT 22
108361: PUSH
108362: LD_OWVAR 2
108366: PUSH
108367: EMPTY
108368: LIST
108369: LIST
108370: PUSH
108371: LD_INT 25
108373: PUSH
108374: LD_INT 1
108376: PUSH
108377: EMPTY
108378: LIST
108379: LIST
108380: PUSH
108381: EMPTY
108382: LIST
108383: LIST
108384: PPUSH
108385: CALL_OW 69
108389: ST_TO_ADDR
// if not tmp then
108390: LD_VAR 0 3
108394: NOT
108395: IFFALSE 108399
// exit ;
108397: GO 108485
// un := tmp [ rand ( 1 , tmp ) ] ;
108399: LD_ADDR_VAR 0 2
108403: PUSH
108404: LD_VAR 0 3
108408: PUSH
108409: LD_INT 1
108411: PPUSH
108412: LD_VAR 0 3
108416: PPUSH
108417: CALL_OW 12
108421: ARRAY
108422: ST_TO_ADDR
// if Crawls ( un ) then
108423: LD_VAR 0 2
108427: PPUSH
108428: CALL_OW 318
108432: IFFALSE 108443
// ComWalk ( un ) ;
108434: LD_VAR 0 2
108438: PPUSH
108439: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
108443: LD_VAR 0 2
108447: PPUSH
108448: LD_INT 9
108450: PPUSH
108451: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
108455: LD_INT 28
108457: PPUSH
108458: LD_OWVAR 2
108462: PPUSH
108463: LD_INT 2
108465: PPUSH
108466: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
108470: LD_INT 29
108472: PPUSH
108473: LD_OWVAR 2
108477: PPUSH
108478: LD_INT 2
108480: PPUSH
108481: CALL_OW 322
// end ;
108485: PPOPN 3
108487: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
108488: LD_EXP 126
108492: IFFALSE 108500
108494: PUSH
108495: LD_EXP 169
108499: AND
108500: IFFALSE 108611
108502: GO 108504
108504: DISABLE
108505: LD_INT 0
108507: PPUSH
108508: PPUSH
108509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108510: LD_ADDR_VAR 0 3
108514: PUSH
108515: LD_INT 22
108517: PUSH
108518: LD_OWVAR 2
108522: PUSH
108523: EMPTY
108524: LIST
108525: LIST
108526: PUSH
108527: LD_INT 25
108529: PUSH
108530: LD_INT 1
108532: PUSH
108533: EMPTY
108534: LIST
108535: LIST
108536: PUSH
108537: EMPTY
108538: LIST
108539: LIST
108540: PPUSH
108541: CALL_OW 69
108545: ST_TO_ADDR
// if not tmp then
108546: LD_VAR 0 3
108550: NOT
108551: IFFALSE 108555
// exit ;
108553: GO 108611
// un := tmp [ rand ( 1 , tmp ) ] ;
108555: LD_ADDR_VAR 0 2
108559: PUSH
108560: LD_VAR 0 3
108564: PUSH
108565: LD_INT 1
108567: PPUSH
108568: LD_VAR 0 3
108572: PPUSH
108573: CALL_OW 12
108577: ARRAY
108578: ST_TO_ADDR
// if Crawls ( un ) then
108579: LD_VAR 0 2
108583: PPUSH
108584: CALL_OW 318
108588: IFFALSE 108599
// ComWalk ( un ) ;
108590: LD_VAR 0 2
108594: PPUSH
108595: CALL_OW 138
// SetClass ( un , class_mortar ) ;
108599: LD_VAR 0 2
108603: PPUSH
108604: LD_INT 8
108606: PPUSH
108607: CALL_OW 336
// end ;
108611: PPOPN 3
108613: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
108614: LD_EXP 126
108618: IFFALSE 108626
108620: PUSH
108621: LD_EXP 170
108625: AND
108626: IFFALSE 108770
108628: GO 108630
108630: DISABLE
108631: LD_INT 0
108633: PPUSH
108634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
108635: LD_ADDR_VAR 0 2
108639: PUSH
108640: LD_INT 22
108642: PUSH
108643: LD_OWVAR 2
108647: PUSH
108648: EMPTY
108649: LIST
108650: LIST
108651: PUSH
108652: LD_INT 21
108654: PUSH
108655: LD_INT 2
108657: PUSH
108658: EMPTY
108659: LIST
108660: LIST
108661: PUSH
108662: LD_INT 2
108664: PUSH
108665: LD_INT 34
108667: PUSH
108668: LD_INT 12
108670: PUSH
108671: EMPTY
108672: LIST
108673: LIST
108674: PUSH
108675: LD_INT 34
108677: PUSH
108678: LD_INT 51
108680: PUSH
108681: EMPTY
108682: LIST
108683: LIST
108684: PUSH
108685: LD_INT 34
108687: PUSH
108688: LD_INT 32
108690: PUSH
108691: EMPTY
108692: LIST
108693: LIST
108694: PUSH
108695: EMPTY
108696: LIST
108697: LIST
108698: LIST
108699: LIST
108700: PUSH
108701: EMPTY
108702: LIST
108703: LIST
108704: LIST
108705: PPUSH
108706: CALL_OW 69
108710: ST_TO_ADDR
// if not tmp then
108711: LD_VAR 0 2
108715: NOT
108716: IFFALSE 108720
// exit ;
108718: GO 108770
// for i in tmp do
108720: LD_ADDR_VAR 0 1
108724: PUSH
108725: LD_VAR 0 2
108729: PUSH
108730: FOR_IN
108731: IFFALSE 108768
// if GetCargo ( i , mat_artifact ) = 0 then
108733: LD_VAR 0 1
108737: PPUSH
108738: LD_INT 4
108740: PPUSH
108741: CALL_OW 289
108745: PUSH
108746: LD_INT 0
108748: EQUAL
108749: IFFALSE 108766
// SetCargo ( i , mat_siberit , 100 ) ;
108751: LD_VAR 0 1
108755: PPUSH
108756: LD_INT 3
108758: PPUSH
108759: LD_INT 100
108761: PPUSH
108762: CALL_OW 290
108766: GO 108730
108768: POP
108769: POP
// end ;
108770: PPOPN 2
108772: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
108773: LD_EXP 126
108777: IFFALSE 108785
108779: PUSH
108780: LD_EXP 171
108784: AND
108785: IFFALSE 108968
108787: GO 108789
108789: DISABLE
108790: LD_INT 0
108792: PPUSH
108793: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108794: LD_ADDR_VAR 0 2
108798: PUSH
108799: LD_INT 22
108801: PUSH
108802: LD_OWVAR 2
108806: PUSH
108807: EMPTY
108808: LIST
108809: LIST
108810: PPUSH
108811: CALL_OW 69
108815: ST_TO_ADDR
// if not tmp then
108816: LD_VAR 0 2
108820: NOT
108821: IFFALSE 108825
// exit ;
108823: GO 108968
// for i := 1 to 2 do
108825: LD_ADDR_VAR 0 1
108829: PUSH
108830: DOUBLE
108831: LD_INT 1
108833: DEC
108834: ST_TO_ADDR
108835: LD_INT 2
108837: PUSH
108838: FOR_TO
108839: IFFALSE 108966
// begin uc_side := your_side ;
108841: LD_ADDR_OWVAR 20
108845: PUSH
108846: LD_OWVAR 2
108850: ST_TO_ADDR
// uc_nation := nation_american ;
108851: LD_ADDR_OWVAR 21
108855: PUSH
108856: LD_INT 1
108858: ST_TO_ADDR
// vc_chassis := us_morphling ;
108859: LD_ADDR_OWVAR 37
108863: PUSH
108864: LD_INT 5
108866: ST_TO_ADDR
// vc_engine := engine_siberite ;
108867: LD_ADDR_OWVAR 39
108871: PUSH
108872: LD_INT 3
108874: ST_TO_ADDR
// vc_control := control_computer ;
108875: LD_ADDR_OWVAR 38
108879: PUSH
108880: LD_INT 3
108882: ST_TO_ADDR
// vc_weapon := us_double_laser ;
108883: LD_ADDR_OWVAR 40
108887: PUSH
108888: LD_INT 10
108890: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
108891: LD_VAR 0 2
108895: PUSH
108896: LD_INT 1
108898: ARRAY
108899: PPUSH
108900: CALL_OW 310
108904: NOT
108905: IFFALSE 108952
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
108907: CALL_OW 45
108911: PPUSH
108912: LD_VAR 0 2
108916: PUSH
108917: LD_INT 1
108919: ARRAY
108920: PPUSH
108921: CALL_OW 250
108925: PPUSH
108926: LD_VAR 0 2
108930: PUSH
108931: LD_INT 1
108933: ARRAY
108934: PPUSH
108935: CALL_OW 251
108939: PPUSH
108940: LD_INT 12
108942: PPUSH
108943: LD_INT 1
108945: PPUSH
108946: CALL_OW 50
108950: GO 108964
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
108952: CALL_OW 45
108956: PPUSH
108957: LD_INT 1
108959: PPUSH
108960: CALL_OW 51
// end ;
108964: GO 108838
108966: POP
108967: POP
// end ;
108968: PPOPN 2
108970: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
108971: LD_EXP 126
108975: IFFALSE 108983
108977: PUSH
108978: LD_EXP 172
108982: AND
108983: IFFALSE 109205
108985: GO 108987
108987: DISABLE
108988: LD_INT 0
108990: PPUSH
108991: PPUSH
108992: PPUSH
108993: PPUSH
108994: PPUSH
108995: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108996: LD_ADDR_VAR 0 6
109000: PUSH
109001: LD_INT 22
109003: PUSH
109004: LD_OWVAR 2
109008: PUSH
109009: EMPTY
109010: LIST
109011: LIST
109012: PUSH
109013: LD_INT 21
109015: PUSH
109016: LD_INT 1
109018: PUSH
109019: EMPTY
109020: LIST
109021: LIST
109022: PUSH
109023: LD_INT 3
109025: PUSH
109026: LD_INT 23
109028: PUSH
109029: LD_INT 0
109031: PUSH
109032: EMPTY
109033: LIST
109034: LIST
109035: PUSH
109036: EMPTY
109037: LIST
109038: LIST
109039: PUSH
109040: EMPTY
109041: LIST
109042: LIST
109043: LIST
109044: PPUSH
109045: CALL_OW 69
109049: ST_TO_ADDR
// if not tmp then
109050: LD_VAR 0 6
109054: NOT
109055: IFFALSE 109059
// exit ;
109057: GO 109205
// s1 := rand ( 1 , 4 ) ;
109059: LD_ADDR_VAR 0 2
109063: PUSH
109064: LD_INT 1
109066: PPUSH
109067: LD_INT 4
109069: PPUSH
109070: CALL_OW 12
109074: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
109075: LD_ADDR_VAR 0 4
109079: PUSH
109080: LD_VAR 0 6
109084: PUSH
109085: LD_INT 1
109087: ARRAY
109088: PPUSH
109089: LD_VAR 0 2
109093: PPUSH
109094: CALL_OW 259
109098: ST_TO_ADDR
// if s1 = 1 then
109099: LD_VAR 0 2
109103: PUSH
109104: LD_INT 1
109106: EQUAL
109107: IFFALSE 109127
// s2 := rand ( 2 , 4 ) else
109109: LD_ADDR_VAR 0 3
109113: PUSH
109114: LD_INT 2
109116: PPUSH
109117: LD_INT 4
109119: PPUSH
109120: CALL_OW 12
109124: ST_TO_ADDR
109125: GO 109135
// s2 := 1 ;
109127: LD_ADDR_VAR 0 3
109131: PUSH
109132: LD_INT 1
109134: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
109135: LD_ADDR_VAR 0 5
109139: PUSH
109140: LD_VAR 0 6
109144: PUSH
109145: LD_INT 1
109147: ARRAY
109148: PPUSH
109149: LD_VAR 0 3
109153: PPUSH
109154: CALL_OW 259
109158: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
109159: LD_VAR 0 6
109163: PUSH
109164: LD_INT 1
109166: ARRAY
109167: PPUSH
109168: LD_VAR 0 2
109172: PPUSH
109173: LD_VAR 0 5
109177: PPUSH
109178: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
109182: LD_VAR 0 6
109186: PUSH
109187: LD_INT 1
109189: ARRAY
109190: PPUSH
109191: LD_VAR 0 3
109195: PPUSH
109196: LD_VAR 0 4
109200: PPUSH
109201: CALL_OW 237
// end ;
109205: PPOPN 6
109207: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
109208: LD_EXP 126
109212: IFFALSE 109220
109214: PUSH
109215: LD_EXP 173
109219: AND
109220: IFFALSE 109299
109222: GO 109224
109224: DISABLE
109225: LD_INT 0
109227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
109228: LD_ADDR_VAR 0 1
109232: PUSH
109233: LD_INT 22
109235: PUSH
109236: LD_OWVAR 2
109240: PUSH
109241: EMPTY
109242: LIST
109243: LIST
109244: PUSH
109245: LD_INT 30
109247: PUSH
109248: LD_INT 3
109250: PUSH
109251: EMPTY
109252: LIST
109253: LIST
109254: PUSH
109255: EMPTY
109256: LIST
109257: LIST
109258: PPUSH
109259: CALL_OW 69
109263: ST_TO_ADDR
// if not tmp then
109264: LD_VAR 0 1
109268: NOT
109269: IFFALSE 109273
// exit ;
109271: GO 109299
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
109273: LD_VAR 0 1
109277: PUSH
109278: LD_INT 1
109280: PPUSH
109281: LD_VAR 0 1
109285: PPUSH
109286: CALL_OW 12
109290: ARRAY
109291: PPUSH
109292: LD_INT 1
109294: PPUSH
109295: CALL_OW 234
// end ;
109299: PPOPN 1
109301: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
109302: LD_EXP 126
109306: IFFALSE 109314
109308: PUSH
109309: LD_EXP 174
109313: AND
109314: IFFALSE 109426
109316: GO 109318
109318: DISABLE
109319: LD_INT 0
109321: PPUSH
109322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
109323: LD_ADDR_VAR 0 2
109327: PUSH
109328: LD_INT 22
109330: PUSH
109331: LD_OWVAR 2
109335: PUSH
109336: EMPTY
109337: LIST
109338: LIST
109339: PUSH
109340: LD_INT 2
109342: PUSH
109343: LD_INT 30
109345: PUSH
109346: LD_INT 27
109348: PUSH
109349: EMPTY
109350: LIST
109351: LIST
109352: PUSH
109353: LD_INT 30
109355: PUSH
109356: LD_INT 26
109358: PUSH
109359: EMPTY
109360: LIST
109361: LIST
109362: PUSH
109363: LD_INT 30
109365: PUSH
109366: LD_INT 28
109368: PUSH
109369: EMPTY
109370: LIST
109371: LIST
109372: PUSH
109373: EMPTY
109374: LIST
109375: LIST
109376: LIST
109377: LIST
109378: PUSH
109379: EMPTY
109380: LIST
109381: LIST
109382: PPUSH
109383: CALL_OW 69
109387: ST_TO_ADDR
// if not tmp then
109388: LD_VAR 0 2
109392: NOT
109393: IFFALSE 109397
// exit ;
109395: GO 109426
// for i in tmp do
109397: LD_ADDR_VAR 0 1
109401: PUSH
109402: LD_VAR 0 2
109406: PUSH
109407: FOR_IN
109408: IFFALSE 109424
// SetLives ( i , 1 ) ;
109410: LD_VAR 0 1
109414: PPUSH
109415: LD_INT 1
109417: PPUSH
109418: CALL_OW 234
109422: GO 109407
109424: POP
109425: POP
// end ;
109426: PPOPN 2
109428: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
109429: LD_EXP 126
109433: IFFALSE 109441
109435: PUSH
109436: LD_EXP 175
109440: AND
109441: IFFALSE 109728
109443: GO 109445
109445: DISABLE
109446: LD_INT 0
109448: PPUSH
109449: PPUSH
109450: PPUSH
// begin i := rand ( 1 , 7 ) ;
109451: LD_ADDR_VAR 0 1
109455: PUSH
109456: LD_INT 1
109458: PPUSH
109459: LD_INT 7
109461: PPUSH
109462: CALL_OW 12
109466: ST_TO_ADDR
// case i of 1 :
109467: LD_VAR 0 1
109471: PUSH
109472: LD_INT 1
109474: DOUBLE
109475: EQUAL
109476: IFTRUE 109480
109478: GO 109490
109480: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
109481: LD_STRING earthquake(getX(game), 0, 32)
109483: PPUSH
109484: CALL_OW 559
109488: GO 109728
109490: LD_INT 2
109492: DOUBLE
109493: EQUAL
109494: IFTRUE 109498
109496: GO 109512
109498: POP
// begin ToLua ( displayStucuk(); ) ;
109499: LD_STRING displayStucuk();
109501: PPUSH
109502: CALL_OW 559
// ResetFog ;
109506: CALL_OW 335
// end ; 3 :
109510: GO 109728
109512: LD_INT 3
109514: DOUBLE
109515: EQUAL
109516: IFTRUE 109520
109518: GO 109624
109520: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
109521: LD_ADDR_VAR 0 2
109525: PUSH
109526: LD_INT 22
109528: PUSH
109529: LD_OWVAR 2
109533: PUSH
109534: EMPTY
109535: LIST
109536: LIST
109537: PUSH
109538: LD_INT 25
109540: PUSH
109541: LD_INT 1
109543: PUSH
109544: EMPTY
109545: LIST
109546: LIST
109547: PUSH
109548: EMPTY
109549: LIST
109550: LIST
109551: PPUSH
109552: CALL_OW 69
109556: ST_TO_ADDR
// if not tmp then
109557: LD_VAR 0 2
109561: NOT
109562: IFFALSE 109566
// exit ;
109564: GO 109728
// un := tmp [ rand ( 1 , tmp ) ] ;
109566: LD_ADDR_VAR 0 3
109570: PUSH
109571: LD_VAR 0 2
109575: PUSH
109576: LD_INT 1
109578: PPUSH
109579: LD_VAR 0 2
109583: PPUSH
109584: CALL_OW 12
109588: ARRAY
109589: ST_TO_ADDR
// if Crawls ( un ) then
109590: LD_VAR 0 3
109594: PPUSH
109595: CALL_OW 318
109599: IFFALSE 109610
// ComWalk ( un ) ;
109601: LD_VAR 0 3
109605: PPUSH
109606: CALL_OW 138
// SetClass ( un , class_mortar ) ;
109610: LD_VAR 0 3
109614: PPUSH
109615: LD_INT 8
109617: PPUSH
109618: CALL_OW 336
// end ; 4 :
109622: GO 109728
109624: LD_INT 4
109626: DOUBLE
109627: EQUAL
109628: IFTRUE 109632
109630: GO 109706
109632: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
109633: LD_ADDR_VAR 0 2
109637: PUSH
109638: LD_INT 22
109640: PUSH
109641: LD_OWVAR 2
109645: PUSH
109646: EMPTY
109647: LIST
109648: LIST
109649: PUSH
109650: LD_INT 30
109652: PUSH
109653: LD_INT 29
109655: PUSH
109656: EMPTY
109657: LIST
109658: LIST
109659: PUSH
109660: EMPTY
109661: LIST
109662: LIST
109663: PPUSH
109664: CALL_OW 69
109668: ST_TO_ADDR
// if not tmp then
109669: LD_VAR 0 2
109673: NOT
109674: IFFALSE 109678
// exit ;
109676: GO 109728
// CenterNowOnUnits ( tmp [ 1 ] ) ;
109678: LD_VAR 0 2
109682: PUSH
109683: LD_INT 1
109685: ARRAY
109686: PPUSH
109687: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
109691: LD_VAR 0 2
109695: PUSH
109696: LD_INT 1
109698: ARRAY
109699: PPUSH
109700: CALL_OW 65
// end ; 5 .. 7 :
109704: GO 109728
109706: LD_INT 5
109708: DOUBLE
109709: GREATEREQUAL
109710: IFFALSE 109718
109712: LD_INT 7
109714: DOUBLE
109715: LESSEQUAL
109716: IFTRUE 109720
109718: GO 109727
109720: POP
// StreamSibBomb ; end ;
109721: CALL 105909 0 0
109725: GO 109728
109727: POP
// end ;
109728: PPOPN 3
109730: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
109731: LD_EXP 126
109735: IFFALSE 109743
109737: PUSH
109738: LD_EXP 176
109742: AND
109743: IFFALSE 109899
109745: GO 109747
109747: DISABLE
109748: LD_INT 0
109750: PPUSH
109751: PPUSH
109752: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
109753: LD_ADDR_VAR 0 2
109757: PUSH
109758: LD_INT 81
109760: PUSH
109761: LD_OWVAR 2
109765: PUSH
109766: EMPTY
109767: LIST
109768: LIST
109769: PUSH
109770: LD_INT 2
109772: PUSH
109773: LD_INT 21
109775: PUSH
109776: LD_INT 1
109778: PUSH
109779: EMPTY
109780: LIST
109781: LIST
109782: PUSH
109783: LD_INT 21
109785: PUSH
109786: LD_INT 2
109788: PUSH
109789: EMPTY
109790: LIST
109791: LIST
109792: PUSH
109793: EMPTY
109794: LIST
109795: LIST
109796: LIST
109797: PUSH
109798: EMPTY
109799: LIST
109800: LIST
109801: PPUSH
109802: CALL_OW 69
109806: ST_TO_ADDR
// if not tmp then
109807: LD_VAR 0 2
109811: NOT
109812: IFFALSE 109816
// exit ;
109814: GO 109899
// p := 0 ;
109816: LD_ADDR_VAR 0 3
109820: PUSH
109821: LD_INT 0
109823: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
109824: LD_INT 35
109826: PPUSH
109827: CALL_OW 67
// p := p + 1 ;
109831: LD_ADDR_VAR 0 3
109835: PUSH
109836: LD_VAR 0 3
109840: PUSH
109841: LD_INT 1
109843: PLUS
109844: ST_TO_ADDR
// for i in tmp do
109845: LD_ADDR_VAR 0 1
109849: PUSH
109850: LD_VAR 0 2
109854: PUSH
109855: FOR_IN
109856: IFFALSE 109887
// if GetLives ( i ) < 1000 then
109858: LD_VAR 0 1
109862: PPUSH
109863: CALL_OW 256
109867: PUSH
109868: LD_INT 1000
109870: LESS
109871: IFFALSE 109885
// SetLives ( i , 1000 ) ;
109873: LD_VAR 0 1
109877: PPUSH
109878: LD_INT 1000
109880: PPUSH
109881: CALL_OW 234
109885: GO 109855
109887: POP
109888: POP
// until p > 20 ;
109889: LD_VAR 0 3
109893: PUSH
109894: LD_INT 20
109896: GREATER
109897: IFFALSE 109824
// end ;
109899: PPOPN 3
109901: END
// every 0 0$1 trigger StreamModeActive and sTime do
109902: LD_EXP 126
109906: IFFALSE 109914
109908: PUSH
109909: LD_EXP 177
109913: AND
109914: IFFALSE 109949
109916: GO 109918
109918: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
109919: LD_INT 28
109921: PPUSH
109922: LD_OWVAR 2
109926: PPUSH
109927: LD_INT 2
109929: PPUSH
109930: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
109934: LD_INT 30
109936: PPUSH
109937: LD_OWVAR 2
109941: PPUSH
109942: LD_INT 2
109944: PPUSH
109945: CALL_OW 322
// end ;
109949: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
109950: LD_EXP 126
109954: IFFALSE 109962
109956: PUSH
109957: LD_EXP 178
109961: AND
109962: IFFALSE 110083
109964: GO 109966
109966: DISABLE
109967: LD_INT 0
109969: PPUSH
109970: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
109971: LD_ADDR_VAR 0 2
109975: PUSH
109976: LD_INT 22
109978: PUSH
109979: LD_OWVAR 2
109983: PUSH
109984: EMPTY
109985: LIST
109986: LIST
109987: PUSH
109988: LD_INT 21
109990: PUSH
109991: LD_INT 1
109993: PUSH
109994: EMPTY
109995: LIST
109996: LIST
109997: PUSH
109998: LD_INT 3
110000: PUSH
110001: LD_INT 23
110003: PUSH
110004: LD_INT 0
110006: PUSH
110007: EMPTY
110008: LIST
110009: LIST
110010: PUSH
110011: EMPTY
110012: LIST
110013: LIST
110014: PUSH
110015: EMPTY
110016: LIST
110017: LIST
110018: LIST
110019: PPUSH
110020: CALL_OW 69
110024: ST_TO_ADDR
// if not tmp then
110025: LD_VAR 0 2
110029: NOT
110030: IFFALSE 110034
// exit ;
110032: GO 110083
// for i in tmp do
110034: LD_ADDR_VAR 0 1
110038: PUSH
110039: LD_VAR 0 2
110043: PUSH
110044: FOR_IN
110045: IFFALSE 110081
// begin if Crawls ( i ) then
110047: LD_VAR 0 1
110051: PPUSH
110052: CALL_OW 318
110056: IFFALSE 110067
// ComWalk ( i ) ;
110058: LD_VAR 0 1
110062: PPUSH
110063: CALL_OW 138
// SetClass ( i , 2 ) ;
110067: LD_VAR 0 1
110071: PPUSH
110072: LD_INT 2
110074: PPUSH
110075: CALL_OW 336
// end ;
110079: GO 110044
110081: POP
110082: POP
// end ;
110083: PPOPN 2
110085: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
110086: LD_EXP 126
110090: IFFALSE 110098
110092: PUSH
110093: LD_EXP 179
110097: AND
110098: IFFALSE 110388
110100: GO 110102
110102: DISABLE
110103: LD_INT 0
110105: PPUSH
110106: PPUSH
110107: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
110108: LD_OWVAR 2
110112: PPUSH
110113: LD_INT 9
110115: PPUSH
110116: LD_INT 1
110118: PPUSH
110119: LD_INT 1
110121: PPUSH
110122: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
110126: LD_INT 9
110128: PPUSH
110129: LD_OWVAR 2
110133: PPUSH
110134: CALL_OW 343
// uc_side := 9 ;
110138: LD_ADDR_OWVAR 20
110142: PUSH
110143: LD_INT 9
110145: ST_TO_ADDR
// uc_nation := 2 ;
110146: LD_ADDR_OWVAR 21
110150: PUSH
110151: LD_INT 2
110153: ST_TO_ADDR
// hc_name := Dark Warrior ;
110154: LD_ADDR_OWVAR 26
110158: PUSH
110159: LD_STRING Dark Warrior
110161: ST_TO_ADDR
// hc_gallery :=  ;
110162: LD_ADDR_OWVAR 33
110166: PUSH
110167: LD_STRING 
110169: ST_TO_ADDR
// hc_noskilllimit := true ;
110170: LD_ADDR_OWVAR 76
110174: PUSH
110175: LD_INT 1
110177: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
110178: LD_ADDR_OWVAR 31
110182: PUSH
110183: LD_INT 30
110185: PUSH
110186: LD_INT 30
110188: PUSH
110189: LD_INT 30
110191: PUSH
110192: LD_INT 30
110194: PUSH
110195: EMPTY
110196: LIST
110197: LIST
110198: LIST
110199: LIST
110200: ST_TO_ADDR
// un := CreateHuman ;
110201: LD_ADDR_VAR 0 3
110205: PUSH
110206: CALL_OW 44
110210: ST_TO_ADDR
// hc_noskilllimit := false ;
110211: LD_ADDR_OWVAR 76
110215: PUSH
110216: LD_INT 0
110218: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110219: LD_VAR 0 3
110223: PPUSH
110224: LD_INT 1
110226: PPUSH
110227: CALL_OW 51
// ToLua ( playRanger() ) ;
110231: LD_STRING playRanger()
110233: PPUSH
110234: CALL_OW 559
// p := 0 ;
110238: LD_ADDR_VAR 0 2
110242: PUSH
110243: LD_INT 0
110245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
110246: LD_INT 35
110248: PPUSH
110249: CALL_OW 67
// p := p + 1 ;
110253: LD_ADDR_VAR 0 2
110257: PUSH
110258: LD_VAR 0 2
110262: PUSH
110263: LD_INT 1
110265: PLUS
110266: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
110267: LD_VAR 0 3
110271: PPUSH
110272: CALL_OW 256
110276: PUSH
110277: LD_INT 1000
110279: LESS
110280: IFFALSE 110294
// SetLives ( un , 1000 ) ;
110282: LD_VAR 0 3
110286: PPUSH
110287: LD_INT 1000
110289: PPUSH
110290: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
110294: LD_VAR 0 3
110298: PPUSH
110299: LD_INT 81
110301: PUSH
110302: LD_OWVAR 2
110306: PUSH
110307: EMPTY
110308: LIST
110309: LIST
110310: PUSH
110311: LD_INT 91
110313: PUSH
110314: LD_VAR 0 3
110318: PUSH
110319: LD_INT 30
110321: PUSH
110322: EMPTY
110323: LIST
110324: LIST
110325: LIST
110326: PUSH
110327: EMPTY
110328: LIST
110329: LIST
110330: PPUSH
110331: CALL_OW 69
110335: PPUSH
110336: LD_VAR 0 3
110340: PPUSH
110341: CALL_OW 74
110345: PPUSH
110346: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
110350: LD_VAR 0 2
110354: PUSH
110355: LD_INT 80
110357: GREATER
110358: IFTRUE 110371
110360: PUSH
110361: LD_VAR 0 3
110365: PPUSH
110366: CALL_OW 301
110370: OR
110371: IFFALSE 110246
// if un then
110373: LD_VAR 0 3
110377: IFFALSE 110388
// RemoveUnit ( un ) ;
110379: LD_VAR 0 3
110383: PPUSH
110384: CALL_OW 64
// end ;
110388: PPOPN 3
110390: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
110391: LD_EXP 180
110395: IFFALSE 110511
110397: GO 110399
110399: DISABLE
110400: LD_INT 0
110402: PPUSH
110403: PPUSH
110404: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
110405: LD_ADDR_VAR 0 2
110409: PUSH
110410: LD_INT 81
110412: PUSH
110413: LD_OWVAR 2
110417: PUSH
110418: EMPTY
110419: LIST
110420: LIST
110421: PUSH
110422: LD_INT 21
110424: PUSH
110425: LD_INT 1
110427: PUSH
110428: EMPTY
110429: LIST
110430: LIST
110431: PUSH
110432: EMPTY
110433: LIST
110434: LIST
110435: PPUSH
110436: CALL_OW 69
110440: ST_TO_ADDR
// ToLua ( playComputer() ) ;
110441: LD_STRING playComputer()
110443: PPUSH
110444: CALL_OW 559
// if not tmp then
110448: LD_VAR 0 2
110452: NOT
110453: IFFALSE 110457
// exit ;
110455: GO 110511
// for i in tmp do
110457: LD_ADDR_VAR 0 1
110461: PUSH
110462: LD_VAR 0 2
110466: PUSH
110467: FOR_IN
110468: IFFALSE 110509
// for j := 1 to 4 do
110470: LD_ADDR_VAR 0 3
110474: PUSH
110475: DOUBLE
110476: LD_INT 1
110478: DEC
110479: ST_TO_ADDR
110480: LD_INT 4
110482: PUSH
110483: FOR_TO
110484: IFFALSE 110505
// SetSkill ( i , j , 10 ) ;
110486: LD_VAR 0 1
110490: PPUSH
110491: LD_VAR 0 3
110495: PPUSH
110496: LD_INT 10
110498: PPUSH
110499: CALL_OW 237
110503: GO 110483
110505: POP
110506: POP
110507: GO 110467
110509: POP
110510: POP
// end ;
110511: PPOPN 3
110513: END
// every 0 0$1 trigger s30 do var i , tmp ;
110514: LD_EXP 181
110518: IFFALSE 110587
110520: GO 110522
110522: DISABLE
110523: LD_INT 0
110525: PPUSH
110526: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110527: LD_ADDR_VAR 0 2
110531: PUSH
110532: LD_INT 22
110534: PUSH
110535: LD_OWVAR 2
110539: PUSH
110540: EMPTY
110541: LIST
110542: LIST
110543: PPUSH
110544: CALL_OW 69
110548: ST_TO_ADDR
// if not tmp then
110549: LD_VAR 0 2
110553: NOT
110554: IFFALSE 110558
// exit ;
110556: GO 110587
// for i in tmp do
110558: LD_ADDR_VAR 0 1
110562: PUSH
110563: LD_VAR 0 2
110567: PUSH
110568: FOR_IN
110569: IFFALSE 110585
// SetLives ( i , 300 ) ;
110571: LD_VAR 0 1
110575: PPUSH
110576: LD_INT 300
110578: PPUSH
110579: CALL_OW 234
110583: GO 110568
110585: POP
110586: POP
// end ;
110587: PPOPN 2
110589: END
// every 0 0$1 trigger s60 do var i , tmp ;
110590: LD_EXP 182
110594: IFFALSE 110663
110596: GO 110598
110598: DISABLE
110599: LD_INT 0
110601: PPUSH
110602: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110603: LD_ADDR_VAR 0 2
110607: PUSH
110608: LD_INT 22
110610: PUSH
110611: LD_OWVAR 2
110615: PUSH
110616: EMPTY
110617: LIST
110618: LIST
110619: PPUSH
110620: CALL_OW 69
110624: ST_TO_ADDR
// if not tmp then
110625: LD_VAR 0 2
110629: NOT
110630: IFFALSE 110634
// exit ;
110632: GO 110663
// for i in tmp do
110634: LD_ADDR_VAR 0 1
110638: PUSH
110639: LD_VAR 0 2
110643: PUSH
110644: FOR_IN
110645: IFFALSE 110661
// SetLives ( i , 600 ) ;
110647: LD_VAR 0 1
110651: PPUSH
110652: LD_INT 600
110654: PPUSH
110655: CALL_OW 234
110659: GO 110644
110661: POP
110662: POP
// end ;
110663: PPOPN 2
110665: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
110666: LD_INT 0
110668: PPUSH
// case cmd of 301 :
110669: LD_VAR 0 1
110673: PUSH
110674: LD_INT 301
110676: DOUBLE
110677: EQUAL
110678: IFTRUE 110682
110680: GO 110714
110682: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
110683: LD_VAR 0 6
110687: PPUSH
110688: LD_VAR 0 7
110692: PPUSH
110693: LD_VAR 0 8
110697: PPUSH
110698: LD_VAR 0 4
110702: PPUSH
110703: LD_VAR 0 5
110707: PPUSH
110708: CALL 111927 0 5
110712: GO 110835
110714: LD_INT 302
110716: DOUBLE
110717: EQUAL
110718: IFTRUE 110722
110720: GO 110759
110722: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
110723: LD_VAR 0 6
110727: PPUSH
110728: LD_VAR 0 7
110732: PPUSH
110733: LD_VAR 0 8
110737: PPUSH
110738: LD_VAR 0 9
110742: PPUSH
110743: LD_VAR 0 4
110747: PPUSH
110748: LD_VAR 0 5
110752: PPUSH
110753: CALL 112018 0 6
110757: GO 110835
110759: LD_INT 303
110761: DOUBLE
110762: EQUAL
110763: IFTRUE 110767
110765: GO 110804
110767: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
110768: LD_VAR 0 6
110772: PPUSH
110773: LD_VAR 0 7
110777: PPUSH
110778: LD_VAR 0 8
110782: PPUSH
110783: LD_VAR 0 9
110787: PPUSH
110788: LD_VAR 0 4
110792: PPUSH
110793: LD_VAR 0 5
110797: PPUSH
110798: CALL 110840 0 6
110802: GO 110835
110804: LD_INT 304
110806: DOUBLE
110807: EQUAL
110808: IFTRUE 110812
110810: GO 110834
110812: POP
// hHackTeleport ( unit , x , y ) ; end ;
110813: LD_VAR 0 2
110817: PPUSH
110818: LD_VAR 0 4
110822: PPUSH
110823: LD_VAR 0 5
110827: PPUSH
110828: CALL 112611 0 3
110832: GO 110835
110834: POP
// end ;
110835: LD_VAR 0 12
110839: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
110840: LD_INT 0
110842: PPUSH
110843: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
110844: LD_VAR 0 1
110848: PUSH
110849: LD_INT 1
110851: LESS
110852: IFTRUE 110864
110854: PUSH
110855: LD_VAR 0 1
110859: PUSH
110860: LD_INT 3
110862: GREATER
110863: OR
110864: IFTRUE 110882
110866: PUSH
110867: LD_VAR 0 5
110871: PPUSH
110872: LD_VAR 0 6
110876: PPUSH
110877: CALL_OW 428
110881: OR
110882: IFFALSE 110886
// exit ;
110884: GO 111614
// uc_side := your_side ;
110886: LD_ADDR_OWVAR 20
110890: PUSH
110891: LD_OWVAR 2
110895: ST_TO_ADDR
// uc_nation := nation ;
110896: LD_ADDR_OWVAR 21
110900: PUSH
110901: LD_VAR 0 1
110905: ST_TO_ADDR
// bc_level = 1 ;
110906: LD_ADDR_OWVAR 43
110910: PUSH
110911: LD_INT 1
110913: ST_TO_ADDR
// case btype of 1 :
110914: LD_VAR 0 2
110918: PUSH
110919: LD_INT 1
110921: DOUBLE
110922: EQUAL
110923: IFTRUE 110927
110925: GO 110938
110927: POP
// bc_type := b_depot ; 2 :
110928: LD_ADDR_OWVAR 42
110932: PUSH
110933: LD_INT 0
110935: ST_TO_ADDR
110936: GO 111558
110938: LD_INT 2
110940: DOUBLE
110941: EQUAL
110942: IFTRUE 110946
110944: GO 110957
110946: POP
// bc_type := b_warehouse ; 3 :
110947: LD_ADDR_OWVAR 42
110951: PUSH
110952: LD_INT 1
110954: ST_TO_ADDR
110955: GO 111558
110957: LD_INT 3
110959: DOUBLE
110960: EQUAL
110961: IFTRUE 110965
110963: GO 110976
110965: POP
// bc_type := b_lab ; 4 .. 9 :
110966: LD_ADDR_OWVAR 42
110970: PUSH
110971: LD_INT 6
110973: ST_TO_ADDR
110974: GO 111558
110976: LD_INT 4
110978: DOUBLE
110979: GREATEREQUAL
110980: IFFALSE 110988
110982: LD_INT 9
110984: DOUBLE
110985: LESSEQUAL
110986: IFTRUE 110990
110988: GO 111050
110990: POP
// begin bc_type := b_lab_half ;
110991: LD_ADDR_OWVAR 42
110995: PUSH
110996: LD_INT 7
110998: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
110999: LD_ADDR_OWVAR 44
111003: PUSH
111004: LD_INT 10
111006: PUSH
111007: LD_INT 11
111009: PUSH
111010: LD_INT 12
111012: PUSH
111013: LD_INT 15
111015: PUSH
111016: LD_INT 14
111018: PUSH
111019: LD_INT 13
111021: PUSH
111022: EMPTY
111023: LIST
111024: LIST
111025: LIST
111026: LIST
111027: LIST
111028: LIST
111029: PUSH
111030: LD_VAR 0 2
111034: PUSH
111035: LD_INT 3
111037: MINUS
111038: ARRAY
111039: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
111040: LD_ADDR_OWVAR 45
111044: PUSH
111045: LD_INT 9
111047: ST_TO_ADDR
// end ; 10 .. 13 :
111048: GO 111558
111050: LD_INT 10
111052: DOUBLE
111053: GREATEREQUAL
111054: IFFALSE 111062
111056: LD_INT 13
111058: DOUBLE
111059: LESSEQUAL
111060: IFTRUE 111064
111062: GO 111141
111064: POP
// begin bc_type := b_lab_full ;
111065: LD_ADDR_OWVAR 42
111069: PUSH
111070: LD_INT 8
111072: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
111073: LD_ADDR_OWVAR 44
111077: PUSH
111078: LD_INT 10
111080: PUSH
111081: LD_INT 12
111083: PUSH
111084: LD_INT 14
111086: PUSH
111087: LD_INT 13
111089: PUSH
111090: EMPTY
111091: LIST
111092: LIST
111093: LIST
111094: LIST
111095: PUSH
111096: LD_VAR 0 2
111100: PUSH
111101: LD_INT 9
111103: MINUS
111104: ARRAY
111105: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
111106: LD_ADDR_OWVAR 45
111110: PUSH
111111: LD_INT 11
111113: PUSH
111114: LD_INT 15
111116: PUSH
111117: LD_INT 12
111119: PUSH
111120: LD_INT 15
111122: PUSH
111123: EMPTY
111124: LIST
111125: LIST
111126: LIST
111127: LIST
111128: PUSH
111129: LD_VAR 0 2
111133: PUSH
111134: LD_INT 9
111136: MINUS
111137: ARRAY
111138: ST_TO_ADDR
// end ; 14 :
111139: GO 111558
111141: LD_INT 14
111143: DOUBLE
111144: EQUAL
111145: IFTRUE 111149
111147: GO 111160
111149: POP
// bc_type := b_workshop ; 15 :
111150: LD_ADDR_OWVAR 42
111154: PUSH
111155: LD_INT 2
111157: ST_TO_ADDR
111158: GO 111558
111160: LD_INT 15
111162: DOUBLE
111163: EQUAL
111164: IFTRUE 111168
111166: GO 111179
111168: POP
// bc_type := b_factory ; 16 :
111169: LD_ADDR_OWVAR 42
111173: PUSH
111174: LD_INT 3
111176: ST_TO_ADDR
111177: GO 111558
111179: LD_INT 16
111181: DOUBLE
111182: EQUAL
111183: IFTRUE 111187
111185: GO 111198
111187: POP
// bc_type := b_ext_gun ; 17 :
111188: LD_ADDR_OWVAR 42
111192: PUSH
111193: LD_INT 17
111195: ST_TO_ADDR
111196: GO 111558
111198: LD_INT 17
111200: DOUBLE
111201: EQUAL
111202: IFTRUE 111206
111204: GO 111234
111206: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
111207: LD_ADDR_OWVAR 42
111211: PUSH
111212: LD_INT 19
111214: PUSH
111215: LD_INT 23
111217: PUSH
111218: LD_INT 19
111220: PUSH
111221: EMPTY
111222: LIST
111223: LIST
111224: LIST
111225: PUSH
111226: LD_VAR 0 1
111230: ARRAY
111231: ST_TO_ADDR
111232: GO 111558
111234: LD_INT 18
111236: DOUBLE
111237: EQUAL
111238: IFTRUE 111242
111240: GO 111253
111242: POP
// bc_type := b_ext_radar ; 19 :
111243: LD_ADDR_OWVAR 42
111247: PUSH
111248: LD_INT 20
111250: ST_TO_ADDR
111251: GO 111558
111253: LD_INT 19
111255: DOUBLE
111256: EQUAL
111257: IFTRUE 111261
111259: GO 111272
111261: POP
// bc_type := b_ext_radio ; 20 :
111262: LD_ADDR_OWVAR 42
111266: PUSH
111267: LD_INT 22
111269: ST_TO_ADDR
111270: GO 111558
111272: LD_INT 20
111274: DOUBLE
111275: EQUAL
111276: IFTRUE 111280
111278: GO 111291
111280: POP
// bc_type := b_ext_siberium ; 21 :
111281: LD_ADDR_OWVAR 42
111285: PUSH
111286: LD_INT 21
111288: ST_TO_ADDR
111289: GO 111558
111291: LD_INT 21
111293: DOUBLE
111294: EQUAL
111295: IFTRUE 111299
111297: GO 111310
111299: POP
// bc_type := b_ext_computer ; 22 :
111300: LD_ADDR_OWVAR 42
111304: PUSH
111305: LD_INT 24
111307: ST_TO_ADDR
111308: GO 111558
111310: LD_INT 22
111312: DOUBLE
111313: EQUAL
111314: IFTRUE 111318
111316: GO 111329
111318: POP
// bc_type := b_ext_track ; 23 :
111319: LD_ADDR_OWVAR 42
111323: PUSH
111324: LD_INT 16
111326: ST_TO_ADDR
111327: GO 111558
111329: LD_INT 23
111331: DOUBLE
111332: EQUAL
111333: IFTRUE 111337
111335: GO 111348
111337: POP
// bc_type := b_ext_laser ; 24 :
111338: LD_ADDR_OWVAR 42
111342: PUSH
111343: LD_INT 25
111345: ST_TO_ADDR
111346: GO 111558
111348: LD_INT 24
111350: DOUBLE
111351: EQUAL
111352: IFTRUE 111356
111354: GO 111367
111356: POP
// bc_type := b_control_tower ; 25 :
111357: LD_ADDR_OWVAR 42
111361: PUSH
111362: LD_INT 36
111364: ST_TO_ADDR
111365: GO 111558
111367: LD_INT 25
111369: DOUBLE
111370: EQUAL
111371: IFTRUE 111375
111373: GO 111386
111375: POP
// bc_type := b_breastwork ; 26 :
111376: LD_ADDR_OWVAR 42
111380: PUSH
111381: LD_INT 31
111383: ST_TO_ADDR
111384: GO 111558
111386: LD_INT 26
111388: DOUBLE
111389: EQUAL
111390: IFTRUE 111394
111392: GO 111405
111394: POP
// bc_type := b_bunker ; 27 :
111395: LD_ADDR_OWVAR 42
111399: PUSH
111400: LD_INT 32
111402: ST_TO_ADDR
111403: GO 111558
111405: LD_INT 27
111407: DOUBLE
111408: EQUAL
111409: IFTRUE 111413
111411: GO 111424
111413: POP
// bc_type := b_turret ; 28 :
111414: LD_ADDR_OWVAR 42
111418: PUSH
111419: LD_INT 33
111421: ST_TO_ADDR
111422: GO 111558
111424: LD_INT 28
111426: DOUBLE
111427: EQUAL
111428: IFTRUE 111432
111430: GO 111443
111432: POP
// bc_type := b_armoury ; 29 :
111433: LD_ADDR_OWVAR 42
111437: PUSH
111438: LD_INT 4
111440: ST_TO_ADDR
111441: GO 111558
111443: LD_INT 29
111445: DOUBLE
111446: EQUAL
111447: IFTRUE 111451
111449: GO 111462
111451: POP
// bc_type := b_barracks ; 30 :
111452: LD_ADDR_OWVAR 42
111456: PUSH
111457: LD_INT 5
111459: ST_TO_ADDR
111460: GO 111558
111462: LD_INT 30
111464: DOUBLE
111465: EQUAL
111466: IFTRUE 111470
111468: GO 111481
111470: POP
// bc_type := b_solar_power ; 31 :
111471: LD_ADDR_OWVAR 42
111475: PUSH
111476: LD_INT 27
111478: ST_TO_ADDR
111479: GO 111558
111481: LD_INT 31
111483: DOUBLE
111484: EQUAL
111485: IFTRUE 111489
111487: GO 111500
111489: POP
// bc_type := b_oil_power ; 32 :
111490: LD_ADDR_OWVAR 42
111494: PUSH
111495: LD_INT 26
111497: ST_TO_ADDR
111498: GO 111558
111500: LD_INT 32
111502: DOUBLE
111503: EQUAL
111504: IFTRUE 111508
111506: GO 111519
111508: POP
// bc_type := b_siberite_power ; 33 :
111509: LD_ADDR_OWVAR 42
111513: PUSH
111514: LD_INT 28
111516: ST_TO_ADDR
111517: GO 111558
111519: LD_INT 33
111521: DOUBLE
111522: EQUAL
111523: IFTRUE 111527
111525: GO 111538
111527: POP
// bc_type := b_oil_mine ; 34 :
111528: LD_ADDR_OWVAR 42
111532: PUSH
111533: LD_INT 29
111535: ST_TO_ADDR
111536: GO 111558
111538: LD_INT 34
111540: DOUBLE
111541: EQUAL
111542: IFTRUE 111546
111544: GO 111557
111546: POP
// bc_type := b_siberite_mine ; end ;
111547: LD_ADDR_OWVAR 42
111551: PUSH
111552: LD_INT 30
111554: ST_TO_ADDR
111555: GO 111558
111557: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
111558: LD_ADDR_VAR 0 8
111562: PUSH
111563: LD_VAR 0 5
111567: PPUSH
111568: LD_VAR 0 6
111572: PPUSH
111573: LD_VAR 0 3
111577: PPUSH
111578: CALL_OW 47
111582: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
111583: LD_OWVAR 42
111587: PUSH
111588: LD_INT 32
111590: PUSH
111591: LD_INT 33
111593: PUSH
111594: EMPTY
111595: LIST
111596: LIST
111597: IN
111598: IFFALSE 111614
// PlaceWeaponTurret ( b , weapon ) ;
111600: LD_VAR 0 8
111604: PPUSH
111605: LD_VAR 0 4
111609: PPUSH
111610: CALL_OW 431
// end ;
111614: LD_VAR 0 7
111618: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
111619: LD_INT 0
111621: PPUSH
111622: PPUSH
111623: PPUSH
111624: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
111625: LD_ADDR_VAR 0 4
111629: PUSH
111630: LD_INT 22
111632: PUSH
111633: LD_OWVAR 2
111637: PUSH
111638: EMPTY
111639: LIST
111640: LIST
111641: PUSH
111642: LD_INT 2
111644: PUSH
111645: LD_INT 30
111647: PUSH
111648: LD_INT 0
111650: PUSH
111651: EMPTY
111652: LIST
111653: LIST
111654: PUSH
111655: LD_INT 30
111657: PUSH
111658: LD_INT 1
111660: PUSH
111661: EMPTY
111662: LIST
111663: LIST
111664: PUSH
111665: EMPTY
111666: LIST
111667: LIST
111668: LIST
111669: PUSH
111670: EMPTY
111671: LIST
111672: LIST
111673: PPUSH
111674: CALL_OW 69
111678: ST_TO_ADDR
// if not tmp then
111679: LD_VAR 0 4
111683: NOT
111684: IFFALSE 111688
// exit ;
111686: GO 111747
// for i in tmp do
111688: LD_ADDR_VAR 0 2
111692: PUSH
111693: LD_VAR 0 4
111697: PUSH
111698: FOR_IN
111699: IFFALSE 111745
// for j = 1 to 3 do
111701: LD_ADDR_VAR 0 3
111705: PUSH
111706: DOUBLE
111707: LD_INT 1
111709: DEC
111710: ST_TO_ADDR
111711: LD_INT 3
111713: PUSH
111714: FOR_TO
111715: IFFALSE 111741
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
111717: LD_VAR 0 2
111721: PPUSH
111722: CALL_OW 274
111726: PPUSH
111727: LD_VAR 0 3
111731: PPUSH
111732: LD_INT 99999
111734: PPUSH
111735: CALL_OW 277
111739: GO 111714
111741: POP
111742: POP
111743: GO 111698
111745: POP
111746: POP
// end ;
111747: LD_VAR 0 1
111751: RET
// export function hHackSetLevel10 ; var i , j ; begin
111752: LD_INT 0
111754: PPUSH
111755: PPUSH
111756: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
111757: LD_ADDR_VAR 0 2
111761: PUSH
111762: LD_INT 21
111764: PUSH
111765: LD_INT 1
111767: PUSH
111768: EMPTY
111769: LIST
111770: LIST
111771: PPUSH
111772: CALL_OW 69
111776: PUSH
111777: FOR_IN
111778: IFFALSE 111830
// if IsSelected ( i ) then
111780: LD_VAR 0 2
111784: PPUSH
111785: CALL_OW 306
111789: IFFALSE 111828
// begin for j := 1 to 4 do
111791: LD_ADDR_VAR 0 3
111795: PUSH
111796: DOUBLE
111797: LD_INT 1
111799: DEC
111800: ST_TO_ADDR
111801: LD_INT 4
111803: PUSH
111804: FOR_TO
111805: IFFALSE 111826
// SetSkill ( i , j , 10 ) ;
111807: LD_VAR 0 2
111811: PPUSH
111812: LD_VAR 0 3
111816: PPUSH
111817: LD_INT 10
111819: PPUSH
111820: CALL_OW 237
111824: GO 111804
111826: POP
111827: POP
// end ;
111828: GO 111777
111830: POP
111831: POP
// end ;
111832: LD_VAR 0 1
111836: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
111837: LD_INT 0
111839: PPUSH
111840: PPUSH
111841: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
111842: LD_ADDR_VAR 0 2
111846: PUSH
111847: LD_INT 22
111849: PUSH
111850: LD_OWVAR 2
111854: PUSH
111855: EMPTY
111856: LIST
111857: LIST
111858: PUSH
111859: LD_INT 21
111861: PUSH
111862: LD_INT 1
111864: PUSH
111865: EMPTY
111866: LIST
111867: LIST
111868: PUSH
111869: EMPTY
111870: LIST
111871: LIST
111872: PPUSH
111873: CALL_OW 69
111877: PUSH
111878: FOR_IN
111879: IFFALSE 111920
// begin for j := 1 to 4 do
111881: LD_ADDR_VAR 0 3
111885: PUSH
111886: DOUBLE
111887: LD_INT 1
111889: DEC
111890: ST_TO_ADDR
111891: LD_INT 4
111893: PUSH
111894: FOR_TO
111895: IFFALSE 111916
// SetSkill ( i , j , 10 ) ;
111897: LD_VAR 0 2
111901: PPUSH
111902: LD_VAR 0 3
111906: PPUSH
111907: LD_INT 10
111909: PPUSH
111910: CALL_OW 237
111914: GO 111894
111916: POP
111917: POP
// end ;
111918: GO 111878
111920: POP
111921: POP
// end ;
111922: LD_VAR 0 1
111926: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
111927: LD_INT 0
111929: PPUSH
// uc_side := your_side ;
111930: LD_ADDR_OWVAR 20
111934: PUSH
111935: LD_OWVAR 2
111939: ST_TO_ADDR
// uc_nation := nation ;
111940: LD_ADDR_OWVAR 21
111944: PUSH
111945: LD_VAR 0 1
111949: ST_TO_ADDR
// InitHc ;
111950: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
111954: LD_INT 0
111956: PPUSH
111957: LD_VAR 0 2
111961: PPUSH
111962: LD_VAR 0 3
111966: PPUSH
111967: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
111971: LD_VAR 0 4
111975: PPUSH
111976: LD_VAR 0 5
111980: PPUSH
111981: CALL_OW 428
111985: PUSH
111986: LD_INT 0
111988: EQUAL
111989: IFFALSE 112013
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
111991: CALL_OW 44
111995: PPUSH
111996: LD_VAR 0 4
112000: PPUSH
112001: LD_VAR 0 5
112005: PPUSH
112006: LD_INT 1
112008: PPUSH
112009: CALL_OW 48
// end ;
112013: LD_VAR 0 6
112017: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
112018: LD_INT 0
112020: PPUSH
112021: PPUSH
// uc_side := your_side ;
112022: LD_ADDR_OWVAR 20
112026: PUSH
112027: LD_OWVAR 2
112031: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
112032: LD_VAR 0 1
112036: PUSH
112037: LD_INT 1
112039: PUSH
112040: LD_INT 2
112042: PUSH
112043: LD_INT 3
112045: PUSH
112046: LD_INT 4
112048: PUSH
112049: LD_INT 5
112051: PUSH
112052: EMPTY
112053: LIST
112054: LIST
112055: LIST
112056: LIST
112057: LIST
112058: IN
112059: IFFALSE 112071
// uc_nation := nation_american else
112061: LD_ADDR_OWVAR 21
112065: PUSH
112066: LD_INT 1
112068: ST_TO_ADDR
112069: GO 112114
// if chassis in [ 11 , 12 , 13 , 14 ] then
112071: LD_VAR 0 1
112075: PUSH
112076: LD_INT 11
112078: PUSH
112079: LD_INT 12
112081: PUSH
112082: LD_INT 13
112084: PUSH
112085: LD_INT 14
112087: PUSH
112088: EMPTY
112089: LIST
112090: LIST
112091: LIST
112092: LIST
112093: IN
112094: IFFALSE 112106
// uc_nation := nation_arabian else
112096: LD_ADDR_OWVAR 21
112100: PUSH
112101: LD_INT 2
112103: ST_TO_ADDR
112104: GO 112114
// uc_nation := nation_russian ;
112106: LD_ADDR_OWVAR 21
112110: PUSH
112111: LD_INT 3
112113: ST_TO_ADDR
// vc_chassis := chassis ;
112114: LD_ADDR_OWVAR 37
112118: PUSH
112119: LD_VAR 0 1
112123: ST_TO_ADDR
// vc_engine := engine ;
112124: LD_ADDR_OWVAR 39
112128: PUSH
112129: LD_VAR 0 2
112133: ST_TO_ADDR
// vc_control := control ;
112134: LD_ADDR_OWVAR 38
112138: PUSH
112139: LD_VAR 0 3
112143: ST_TO_ADDR
// vc_weapon := weapon ;
112144: LD_ADDR_OWVAR 40
112148: PUSH
112149: LD_VAR 0 4
112153: ST_TO_ADDR
// un := CreateVehicle ;
112154: LD_ADDR_VAR 0 8
112158: PUSH
112159: CALL_OW 45
112163: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
112164: LD_VAR 0 8
112168: PPUSH
112169: LD_INT 0
112171: PPUSH
112172: LD_INT 5
112174: PPUSH
112175: CALL_OW 12
112179: PPUSH
112180: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
112184: LD_VAR 0 8
112188: PPUSH
112189: LD_VAR 0 5
112193: PPUSH
112194: LD_VAR 0 6
112198: PPUSH
112199: LD_INT 1
112201: PPUSH
112202: CALL_OW 48
// end ;
112206: LD_VAR 0 7
112210: RET
// export hInvincible ; every 1 do
112211: GO 112213
112213: DISABLE
// hInvincible := [ ] ;
112214: LD_ADDR_EXP 183
112218: PUSH
112219: EMPTY
112220: ST_TO_ADDR
112221: END
// every 10 do var i ;
112222: GO 112224
112224: DISABLE
112225: LD_INT 0
112227: PPUSH
// begin enable ;
112228: ENABLE
// if not hInvincible then
112229: LD_EXP 183
112233: NOT
112234: IFFALSE 112238
// exit ;
112236: GO 112282
// for i in hInvincible do
112238: LD_ADDR_VAR 0 1
112242: PUSH
112243: LD_EXP 183
112247: PUSH
112248: FOR_IN
112249: IFFALSE 112280
// if GetLives ( i ) < 1000 then
112251: LD_VAR 0 1
112255: PPUSH
112256: CALL_OW 256
112260: PUSH
112261: LD_INT 1000
112263: LESS
112264: IFFALSE 112278
// SetLives ( i , 1000 ) ;
112266: LD_VAR 0 1
112270: PPUSH
112271: LD_INT 1000
112273: PPUSH
112274: CALL_OW 234
112278: GO 112248
112280: POP
112281: POP
// end ;
112282: PPOPN 1
112284: END
// export function hHackInvincible ; var i ; begin
112285: LD_INT 0
112287: PPUSH
112288: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
112289: LD_ADDR_VAR 0 2
112293: PUSH
112294: LD_INT 2
112296: PUSH
112297: LD_INT 21
112299: PUSH
112300: LD_INT 1
112302: PUSH
112303: EMPTY
112304: LIST
112305: LIST
112306: PUSH
112307: LD_INT 21
112309: PUSH
112310: LD_INT 2
112312: PUSH
112313: EMPTY
112314: LIST
112315: LIST
112316: PUSH
112317: EMPTY
112318: LIST
112319: LIST
112320: LIST
112321: PPUSH
112322: CALL_OW 69
112326: PUSH
112327: FOR_IN
112328: IFFALSE 112389
// if IsSelected ( i ) then
112330: LD_VAR 0 2
112334: PPUSH
112335: CALL_OW 306
112339: IFFALSE 112387
// begin if i in hInvincible then
112341: LD_VAR 0 2
112345: PUSH
112346: LD_EXP 183
112350: IN
112351: IFFALSE 112371
// hInvincible := hInvincible diff i else
112353: LD_ADDR_EXP 183
112357: PUSH
112358: LD_EXP 183
112362: PUSH
112363: LD_VAR 0 2
112367: DIFF
112368: ST_TO_ADDR
112369: GO 112387
// hInvincible := hInvincible union i ;
112371: LD_ADDR_EXP 183
112375: PUSH
112376: LD_EXP 183
112380: PUSH
112381: LD_VAR 0 2
112385: UNION
112386: ST_TO_ADDR
// end ;
112387: GO 112327
112389: POP
112390: POP
// end ;
112391: LD_VAR 0 1
112395: RET
// export function hHackInvisible ; var i , j ; begin
112396: LD_INT 0
112398: PPUSH
112399: PPUSH
112400: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
112401: LD_ADDR_VAR 0 2
112405: PUSH
112406: LD_INT 21
112408: PUSH
112409: LD_INT 1
112411: PUSH
112412: EMPTY
112413: LIST
112414: LIST
112415: PPUSH
112416: CALL_OW 69
112420: PUSH
112421: FOR_IN
112422: IFFALSE 112446
// if IsSelected ( i ) then
112424: LD_VAR 0 2
112428: PPUSH
112429: CALL_OW 306
112433: IFFALSE 112444
// ComForceInvisible ( i ) ;
112435: LD_VAR 0 2
112439: PPUSH
112440: CALL_OW 496
112444: GO 112421
112446: POP
112447: POP
// end ;
112448: LD_VAR 0 1
112452: RET
// export function hHackChangeYourSide ; begin
112453: LD_INT 0
112455: PPUSH
// if your_side = 8 then
112456: LD_OWVAR 2
112460: PUSH
112461: LD_INT 8
112463: EQUAL
112464: IFFALSE 112476
// your_side := 0 else
112466: LD_ADDR_OWVAR 2
112470: PUSH
112471: LD_INT 0
112473: ST_TO_ADDR
112474: GO 112490
// your_side := your_side + 1 ;
112476: LD_ADDR_OWVAR 2
112480: PUSH
112481: LD_OWVAR 2
112485: PUSH
112486: LD_INT 1
112488: PLUS
112489: ST_TO_ADDR
// end ;
112490: LD_VAR 0 1
112494: RET
// export function hHackChangeUnitSide ; var i , j ; begin
112495: LD_INT 0
112497: PPUSH
112498: PPUSH
112499: PPUSH
// for i in all_units do
112500: LD_ADDR_VAR 0 2
112504: PUSH
112505: LD_OWVAR 3
112509: PUSH
112510: FOR_IN
112511: IFFALSE 112589
// if IsSelected ( i ) then
112513: LD_VAR 0 2
112517: PPUSH
112518: CALL_OW 306
112522: IFFALSE 112587
// begin j := GetSide ( i ) ;
112524: LD_ADDR_VAR 0 3
112528: PUSH
112529: LD_VAR 0 2
112533: PPUSH
112534: CALL_OW 255
112538: ST_TO_ADDR
// if j = 8 then
112539: LD_VAR 0 3
112543: PUSH
112544: LD_INT 8
112546: EQUAL
112547: IFFALSE 112559
// j := 0 else
112549: LD_ADDR_VAR 0 3
112553: PUSH
112554: LD_INT 0
112556: ST_TO_ADDR
112557: GO 112573
// j := j + 1 ;
112559: LD_ADDR_VAR 0 3
112563: PUSH
112564: LD_VAR 0 3
112568: PUSH
112569: LD_INT 1
112571: PLUS
112572: ST_TO_ADDR
// SetSide ( i , j ) ;
112573: LD_VAR 0 2
112577: PPUSH
112578: LD_VAR 0 3
112582: PPUSH
112583: CALL_OW 235
// end ;
112587: GO 112510
112589: POP
112590: POP
// end ;
112591: LD_VAR 0 1
112595: RET
// export function hHackFog ; begin
112596: LD_INT 0
112598: PPUSH
// FogOff ( true ) ;
112599: LD_INT 1
112601: PPUSH
112602: CALL_OW 344
// end ;
112606: LD_VAR 0 1
112610: RET
// export function hHackTeleport ( unit , x , y ) ; begin
112611: LD_INT 0
112613: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
112614: LD_VAR 0 1
112618: PPUSH
112619: LD_VAR 0 2
112623: PPUSH
112624: LD_VAR 0 3
112628: PPUSH
112629: LD_INT 1
112631: PPUSH
112632: LD_INT 1
112634: PPUSH
112635: CALL_OW 483
// CenterOnXY ( x , y ) ;
112639: LD_VAR 0 2
112643: PPUSH
112644: LD_VAR 0 3
112648: PPUSH
112649: CALL_OW 84
// end ;
112653: LD_VAR 0 4
112657: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
112658: LD_INT 0
112660: PPUSH
112661: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
112662: LD_VAR 0 1
112666: NOT
112667: IFTRUE 112686
112669: PUSH
112670: LD_VAR 0 2
112674: PPUSH
112675: LD_VAR 0 3
112679: PPUSH
112680: CALL_OW 488
112684: NOT
112685: OR
112686: IFTRUE 112721
112688: PUSH
112689: LD_VAR 0 1
112693: PPUSH
112694: CALL_OW 266
112698: PUSH
112699: LD_INT 3
112701: NONEQUAL
112702: IFFALSE 112720
112704: PUSH
112705: LD_VAR 0 1
112709: PPUSH
112710: CALL_OW 247
112714: PUSH
112715: LD_INT 1
112717: EQUAL
112718: NOT
112719: AND
112720: OR
112721: IFFALSE 112725
// exit ;
112723: GO 113007
// if GetType ( factory ) = unit_human then
112725: LD_VAR 0 1
112729: PPUSH
112730: CALL_OW 247
112734: PUSH
112735: LD_INT 1
112737: EQUAL
112738: IFFALSE 112755
// factory := IsInUnit ( factory ) ;
112740: LD_ADDR_VAR 0 1
112744: PUSH
112745: LD_VAR 0 1
112749: PPUSH
112750: CALL_OW 310
112754: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
112755: LD_VAR 0 1
112759: PPUSH
112760: CALL_OW 266
112764: PUSH
112765: LD_INT 3
112767: NONEQUAL
112768: IFFALSE 112772
// exit ;
112770: GO 113007
// for i := 1 to Count ( factoryWaypoints ) do
112772: LD_ADDR_VAR 0 5
112776: PUSH
112777: DOUBLE
112778: LD_INT 1
112780: DEC
112781: ST_TO_ADDR
112782: LD_EXP 184
112786: PPUSH
112787: CALL 56697 0 1
112791: PUSH
112792: FOR_TO
112793: IFFALSE 112955
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
112795: LD_VAR 0 2
112799: PPUSH
112800: LD_VAR 0 3
112804: PPUSH
112805: CALL_OW 428
112809: PUSH
112810: LD_EXP 184
112814: PUSH
112815: LD_VAR 0 5
112819: ARRAY
112820: PUSH
112821: LD_INT 2
112823: ARRAY
112824: EQUAL
112825: IFFALSE 112857
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
112827: LD_ADDR_EXP 184
112831: PUSH
112832: LD_EXP 184
112836: PPUSH
112837: LD_VAR 0 5
112841: PPUSH
112842: CALL_OW 3
112846: ST_TO_ADDR
// UpdateFactoryWaypoints ;
112847: CALL 113012 0 0
// exit ;
112851: POP
112852: POP
112853: GO 113007
// end else
112855: GO 112953
// if factory = factoryWaypoints [ i ] [ 2 ] then
112857: LD_VAR 0 1
112861: PUSH
112862: LD_EXP 184
112866: PUSH
112867: LD_VAR 0 5
112871: ARRAY
112872: PUSH
112873: LD_INT 2
112875: ARRAY
112876: EQUAL
112877: IFFALSE 112953
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
112879: LD_ADDR_EXP 184
112883: PUSH
112884: LD_EXP 184
112888: PPUSH
112889: LD_VAR 0 5
112893: PPUSH
112894: CALL_OW 3
112898: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
112899: LD_ADDR_EXP 184
112903: PUSH
112904: LD_EXP 184
112908: PPUSH
112909: LD_VAR 0 1
112913: PPUSH
112914: CALL_OW 255
112918: PUSH
112919: LD_VAR 0 1
112923: PUSH
112924: LD_VAR 0 2
112928: PUSH
112929: LD_VAR 0 3
112933: PUSH
112934: EMPTY
112935: LIST
112936: LIST
112937: LIST
112938: LIST
112939: PPUSH
112940: CALL 92673 0 2
112944: ST_TO_ADDR
// UpdateFactoryWaypoints ;
112945: CALL 113012 0 0
// exit ;
112949: POP
112950: POP
112951: GO 113007
// end ; end ;
112953: GO 112792
112955: POP
112956: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
112957: LD_ADDR_EXP 184
112961: PUSH
112962: LD_EXP 184
112966: PPUSH
112967: LD_VAR 0 1
112971: PPUSH
112972: CALL_OW 255
112976: PUSH
112977: LD_VAR 0 1
112981: PUSH
112982: LD_VAR 0 2
112986: PUSH
112987: LD_VAR 0 3
112991: PUSH
112992: EMPTY
112993: LIST
112994: LIST
112995: LIST
112996: LIST
112997: PPUSH
112998: CALL 92673 0 2
113002: ST_TO_ADDR
// UpdateFactoryWaypoints ;
113003: CALL 113012 0 0
// end ;
113007: LD_VAR 0 4
113011: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
113012: LD_INT 0
113014: PPUSH
113015: PPUSH
113016: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
113017: LD_STRING resetFactoryWaypoint();
113019: PPUSH
113020: CALL_OW 559
// if factoryWaypoints then
113024: LD_EXP 184
113028: IFFALSE 113149
// begin list := factoryWaypoints ;
113030: LD_ADDR_VAR 0 3
113034: PUSH
113035: LD_EXP 184
113039: ST_TO_ADDR
// for i := 1 to list do
113040: LD_ADDR_VAR 0 2
113044: PUSH
113045: DOUBLE
113046: LD_INT 1
113048: DEC
113049: ST_TO_ADDR
113050: LD_VAR 0 3
113054: PUSH
113055: FOR_TO
113056: IFFALSE 113147
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
113058: LD_STRING setFactoryWaypointXY(
113060: PUSH
113061: LD_VAR 0 3
113065: PUSH
113066: LD_VAR 0 2
113070: ARRAY
113071: PUSH
113072: LD_INT 1
113074: ARRAY
113075: STR
113076: PUSH
113077: LD_STRING ,
113079: STR
113080: PUSH
113081: LD_VAR 0 3
113085: PUSH
113086: LD_VAR 0 2
113090: ARRAY
113091: PUSH
113092: LD_INT 2
113094: ARRAY
113095: STR
113096: PUSH
113097: LD_STRING ,
113099: STR
113100: PUSH
113101: LD_VAR 0 3
113105: PUSH
113106: LD_VAR 0 2
113110: ARRAY
113111: PUSH
113112: LD_INT 3
113114: ARRAY
113115: STR
113116: PUSH
113117: LD_STRING ,
113119: STR
113120: PUSH
113121: LD_VAR 0 3
113125: PUSH
113126: LD_VAR 0 2
113130: ARRAY
113131: PUSH
113132: LD_INT 4
113134: ARRAY
113135: STR
113136: PUSH
113137: LD_STRING )
113139: STR
113140: PPUSH
113141: CALL_OW 559
113145: GO 113055
113147: POP
113148: POP
// end ; end ;
113149: LD_VAR 0 1
113153: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
113154: LD_INT 0
113156: PPUSH
// if HexInfo ( x , y ) = warehouse then
113157: LD_VAR 0 2
113161: PPUSH
113162: LD_VAR 0 3
113166: PPUSH
113167: CALL_OW 428
113171: PUSH
113172: LD_VAR 0 1
113176: EQUAL
113177: IFFALSE 113204
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
113179: LD_ADDR_EXP 186
113183: PUSH
113184: LD_EXP 186
113188: PPUSH
113189: LD_VAR 0 1
113193: PPUSH
113194: LD_INT 0
113196: PPUSH
113197: CALL_OW 1
113201: ST_TO_ADDR
113202: GO 113255
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
113204: LD_ADDR_EXP 186
113208: PUSH
113209: LD_EXP 186
113213: PPUSH
113214: LD_VAR 0 1
113218: PPUSH
113219: LD_VAR 0 1
113223: PPUSH
113224: CALL_OW 255
113228: PUSH
113229: LD_VAR 0 1
113233: PUSH
113234: LD_VAR 0 2
113238: PUSH
113239: LD_VAR 0 3
113243: PUSH
113244: EMPTY
113245: LIST
113246: LIST
113247: LIST
113248: LIST
113249: PPUSH
113250: CALL_OW 1
113254: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
113255: CALL 113264 0 0
// end ;
113259: LD_VAR 0 4
113263: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
113264: LD_INT 0
113266: PPUSH
113267: PPUSH
113268: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
113269: LD_STRING resetWarehouseGatheringPoints();
113271: PPUSH
113272: CALL_OW 559
// if warehouseGatheringPoints then
113276: LD_EXP 186
113280: IFFALSE 113406
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
113282: LD_ADDR_VAR 0 3
113286: PUSH
113287: LD_EXP 186
113291: PPUSH
113292: CALL 96607 0 1
113296: ST_TO_ADDR
// for i := 1 to list do
113297: LD_ADDR_VAR 0 2
113301: PUSH
113302: DOUBLE
113303: LD_INT 1
113305: DEC
113306: ST_TO_ADDR
113307: LD_VAR 0 3
113311: PUSH
113312: FOR_TO
113313: IFFALSE 113404
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
113315: LD_STRING setWarehouseGatheringPointXY(
113317: PUSH
113318: LD_VAR 0 3
113322: PUSH
113323: LD_VAR 0 2
113327: ARRAY
113328: PUSH
113329: LD_INT 1
113331: ARRAY
113332: STR
113333: PUSH
113334: LD_STRING ,
113336: STR
113337: PUSH
113338: LD_VAR 0 3
113342: PUSH
113343: LD_VAR 0 2
113347: ARRAY
113348: PUSH
113349: LD_INT 2
113351: ARRAY
113352: STR
113353: PUSH
113354: LD_STRING ,
113356: STR
113357: PUSH
113358: LD_VAR 0 3
113362: PUSH
113363: LD_VAR 0 2
113367: ARRAY
113368: PUSH
113369: LD_INT 3
113371: ARRAY
113372: STR
113373: PUSH
113374: LD_STRING ,
113376: STR
113377: PUSH
113378: LD_VAR 0 3
113382: PUSH
113383: LD_VAR 0 2
113387: ARRAY
113388: PUSH
113389: LD_INT 4
113391: ARRAY
113392: STR
113393: PUSH
113394: LD_STRING )
113396: STR
113397: PPUSH
113398: CALL_OW 559
113402: GO 113312
113404: POP
113405: POP
// end ; end ;
113406: LD_VAR 0 1
113410: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
113411: LD_EXP 186
113415: IFFALSE 114110
113417: GO 113419
113419: DISABLE
113420: LD_INT 0
113422: PPUSH
113423: PPUSH
113424: PPUSH
113425: PPUSH
113426: PPUSH
113427: PPUSH
113428: PPUSH
113429: PPUSH
113430: PPUSH
// begin enable ;
113431: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
113432: LD_ADDR_VAR 0 3
113436: PUSH
113437: LD_EXP 186
113441: PPUSH
113442: CALL 96607 0 1
113446: ST_TO_ADDR
// if not list then
113447: LD_VAR 0 3
113451: NOT
113452: IFFALSE 113456
// exit ;
113454: GO 114110
// for i := 1 to list do
113456: LD_ADDR_VAR 0 1
113460: PUSH
113461: DOUBLE
113462: LD_INT 1
113464: DEC
113465: ST_TO_ADDR
113466: LD_VAR 0 3
113470: PUSH
113471: FOR_TO
113472: IFFALSE 114108
// begin depot := list [ i ] [ 2 ] ;
113474: LD_ADDR_VAR 0 8
113478: PUSH
113479: LD_VAR 0 3
113483: PUSH
113484: LD_VAR 0 1
113488: ARRAY
113489: PUSH
113490: LD_INT 2
113492: ARRAY
113493: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
113494: LD_ADDR_VAR 0 5
113498: PUSH
113499: LD_VAR 0 3
113503: PUSH
113504: LD_VAR 0 1
113508: ARRAY
113509: PUSH
113510: LD_INT 1
113512: ARRAY
113513: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
113514: LD_VAR 0 8
113518: PPUSH
113519: CALL_OW 301
113523: IFTRUE 113542
113525: PUSH
113526: LD_VAR 0 5
113530: PUSH
113531: LD_VAR 0 8
113535: PPUSH
113536: CALL_OW 255
113540: NONEQUAL
113541: OR
113542: IFFALSE 113571
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
113544: LD_ADDR_EXP 186
113548: PUSH
113549: LD_EXP 186
113553: PPUSH
113554: LD_VAR 0 8
113558: PPUSH
113559: LD_INT 0
113561: PPUSH
113562: CALL_OW 1
113566: ST_TO_ADDR
// exit ;
113567: POP
113568: POP
113569: GO 114110
// end ; x := list [ i ] [ 3 ] ;
113571: LD_ADDR_VAR 0 6
113575: PUSH
113576: LD_VAR 0 3
113580: PUSH
113581: LD_VAR 0 1
113585: ARRAY
113586: PUSH
113587: LD_INT 3
113589: ARRAY
113590: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
113591: LD_ADDR_VAR 0 7
113595: PUSH
113596: LD_VAR 0 3
113600: PUSH
113601: LD_VAR 0 1
113605: ARRAY
113606: PUSH
113607: LD_INT 4
113609: ARRAY
113610: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
113611: LD_ADDR_VAR 0 9
113615: PUSH
113616: LD_VAR 0 6
113620: PPUSH
113621: LD_VAR 0 7
113625: PPUSH
113626: LD_INT 16
113628: PPUSH
113629: CALL 95181 0 3
113633: ST_TO_ADDR
// if not cratesNearbyPoint then
113634: LD_VAR 0 9
113638: NOT
113639: IFFALSE 113645
// exit ;
113641: POP
113642: POP
113643: GO 114110
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
113645: LD_ADDR_VAR 0 4
113649: PUSH
113650: LD_INT 22
113652: PUSH
113653: LD_VAR 0 5
113657: PUSH
113658: EMPTY
113659: LIST
113660: LIST
113661: PUSH
113662: LD_INT 3
113664: PUSH
113665: LD_INT 60
113667: PUSH
113668: EMPTY
113669: LIST
113670: PUSH
113671: EMPTY
113672: LIST
113673: LIST
113674: PUSH
113675: LD_INT 91
113677: PUSH
113678: LD_VAR 0 8
113682: PUSH
113683: LD_INT 6
113685: PUSH
113686: EMPTY
113687: LIST
113688: LIST
113689: LIST
113690: PUSH
113691: LD_INT 2
113693: PUSH
113694: LD_INT 25
113696: PUSH
113697: LD_INT 2
113699: PUSH
113700: EMPTY
113701: LIST
113702: LIST
113703: PUSH
113704: LD_INT 25
113706: PUSH
113707: LD_INT 16
113709: PUSH
113710: EMPTY
113711: LIST
113712: LIST
113713: PUSH
113714: EMPTY
113715: LIST
113716: LIST
113717: LIST
113718: PUSH
113719: EMPTY
113720: LIST
113721: LIST
113722: LIST
113723: LIST
113724: PPUSH
113725: CALL_OW 69
113729: PUSH
113730: LD_VAR 0 8
113734: PPUSH
113735: CALL_OW 313
113739: PPUSH
113740: LD_INT 3
113742: PUSH
113743: LD_INT 60
113745: PUSH
113746: EMPTY
113747: LIST
113748: PUSH
113749: EMPTY
113750: LIST
113751: LIST
113752: PUSH
113753: LD_INT 2
113755: PUSH
113756: LD_INT 25
113758: PUSH
113759: LD_INT 2
113761: PUSH
113762: EMPTY
113763: LIST
113764: LIST
113765: PUSH
113766: LD_INT 25
113768: PUSH
113769: LD_INT 16
113771: PUSH
113772: EMPTY
113773: LIST
113774: LIST
113775: PUSH
113776: EMPTY
113777: LIST
113778: LIST
113779: LIST
113780: PUSH
113781: EMPTY
113782: LIST
113783: LIST
113784: PPUSH
113785: CALL_OW 72
113789: UNION
113790: ST_TO_ADDR
// if tmp then
113791: LD_VAR 0 4
113795: IFFALSE 113875
// begin tmp := ShrinkArray ( tmp , 3 ) ;
113797: LD_ADDR_VAR 0 4
113801: PUSH
113802: LD_VAR 0 4
113806: PPUSH
113807: LD_INT 3
113809: PPUSH
113810: CALL 92988 0 2
113814: ST_TO_ADDR
// for j in tmp do
113815: LD_ADDR_VAR 0 2
113819: PUSH
113820: LD_VAR 0 4
113824: PUSH
113825: FOR_IN
113826: IFFALSE 113869
// begin if IsInUnit ( j ) then
113828: LD_VAR 0 2
113832: PPUSH
113833: CALL_OW 310
113837: IFFALSE 113848
// ComExit ( j ) ;
113839: LD_VAR 0 2
113843: PPUSH
113844: CALL 93071 0 1
// AddComCollect ( j , x , y ) ;
113848: LD_VAR 0 2
113852: PPUSH
113853: LD_VAR 0 6
113857: PPUSH
113858: LD_VAR 0 7
113862: PPUSH
113863: CALL_OW 177
// end ;
113867: GO 113825
113869: POP
113870: POP
// exit ;
113871: POP
113872: POP
113873: GO 114110
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
113875: LD_ADDR_VAR 0 4
113879: PUSH
113880: LD_INT 22
113882: PUSH
113883: LD_VAR 0 5
113887: PUSH
113888: EMPTY
113889: LIST
113890: LIST
113891: PUSH
113892: LD_INT 91
113894: PUSH
113895: LD_VAR 0 8
113899: PUSH
113900: LD_INT 8
113902: PUSH
113903: EMPTY
113904: LIST
113905: LIST
113906: LIST
113907: PUSH
113908: LD_INT 2
113910: PUSH
113911: LD_INT 34
113913: PUSH
113914: LD_INT 12
113916: PUSH
113917: EMPTY
113918: LIST
113919: LIST
113920: PUSH
113921: LD_INT 34
113923: PUSH
113924: LD_INT 51
113926: PUSH
113927: EMPTY
113928: LIST
113929: LIST
113930: PUSH
113931: LD_INT 34
113933: PUSH
113934: LD_INT 32
113936: PUSH
113937: EMPTY
113938: LIST
113939: LIST
113940: PUSH
113941: LD_INT 34
113943: PUSH
113944: LD_INT 89
113946: PUSH
113947: EMPTY
113948: LIST
113949: LIST
113950: PUSH
113951: EMPTY
113952: LIST
113953: LIST
113954: LIST
113955: LIST
113956: LIST
113957: PUSH
113958: EMPTY
113959: LIST
113960: LIST
113961: LIST
113962: PPUSH
113963: CALL_OW 69
113967: ST_TO_ADDR
// if tmp then
113968: LD_VAR 0 4
113972: IFFALSE 114106
// begin for j in tmp do
113974: LD_ADDR_VAR 0 2
113978: PUSH
113979: LD_VAR 0 4
113983: PUSH
113984: FOR_IN
113985: IFFALSE 114104
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
113987: LD_VAR 0 2
113991: PPUSH
113992: CALL_OW 262
113996: PUSH
113997: LD_INT 3
113999: EQUAL
114000: IFTRUE 114017
114002: PUSH
114003: LD_VAR 0 2
114007: PPUSH
114008: CALL_OW 261
114012: PUSH
114013: LD_INT 20
114015: GREATER
114016: OR
114017: IFFALSE 114031
114019: PUSH
114020: LD_VAR 0 2
114024: PPUSH
114025: CALL_OW 314
114029: NOT
114030: AND
114031: IFFALSE 114061
114033: PUSH
114034: LD_VAR 0 2
114038: PPUSH
114039: CALL_OW 263
114043: PUSH
114044: LD_INT 1
114046: NONEQUAL
114047: IFTRUE 114060
114049: PUSH
114050: LD_VAR 0 2
114054: PPUSH
114055: CALL_OW 311
114059: OR
114060: AND
114061: IFFALSE 114102
// begin ComCollect ( j , x , y ) ;
114063: LD_VAR 0 2
114067: PPUSH
114068: LD_VAR 0 6
114072: PPUSH
114073: LD_VAR 0 7
114077: PPUSH
114078: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
114082: LD_VAR 0 2
114086: PPUSH
114087: LD_VAR 0 8
114091: PPUSH
114092: CALL_OW 172
// exit ;
114096: POP
114097: POP
114098: POP
114099: POP
114100: GO 114110
// end ;
114102: GO 113984
114104: POP
114105: POP
// end ; end ;
114106: GO 113471
114108: POP
114109: POP
// end ; end_of_file
114110: PPOPN 9
114112: END
// export function SOS_UnitDestroyed ( un ) ; begin
114113: LD_INT 0
114115: PPUSH
// ComRadiation ( un ) ;
114116: LD_VAR 0 1
114120: PPUSH
114121: CALL 115283 0 1
// end ;
114125: LD_VAR 0 2
114129: RET
// export function SOS_UnitKamikazed ( un ) ; begin
114130: LD_INT 0
114132: PPUSH
// ComRadiation ( un ) ;
114133: LD_VAR 0 1
114137: PPUSH
114138: CALL 115283 0 1
// end ;
114142: LD_VAR 0 2
114146: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
114147: LD_INT 0
114149: PPUSH
// end ;
114150: LD_VAR 0 4
114154: RET
// export function SOS_Command ( cmd ) ; begin
114155: LD_INT 0
114157: PPUSH
// end ;
114158: LD_VAR 0 2
114162: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
114163: LD_INT 0
114165: PPUSH
// end ;
114166: LD_VAR 0 6
114170: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex , weapon ; begin
114171: LD_INT 0
114173: PPUSH
114174: PPUSH
114175: PPUSH
114176: PPUSH
114177: PPUSH
// if not vehicle or not factory then
114178: LD_VAR 0 1
114182: NOT
114183: IFTRUE 114192
114185: PUSH
114186: LD_VAR 0 2
114190: NOT
114191: OR
114192: IFFALSE 114196
// exit ;
114194: GO 114858
// weapon := GetWeapon ( vehicle ) ;
114196: LD_ADDR_VAR 0 7
114200: PUSH
114201: LD_VAR 0 1
114205: PPUSH
114206: CALL_OW 264
114210: ST_TO_ADDR
// if weapon = ar_miner then
114211: LD_VAR 0 7
114215: PUSH
114216: LD_INT 81
114218: EQUAL
114219: IFFALSE 114276
// begin minersList := Replace ( minersList , minersList + 1 , vehicle ) ;
114221: LD_ADDR_EXP 195
114225: PUSH
114226: LD_EXP 195
114230: PPUSH
114231: LD_EXP 195
114235: PUSH
114236: LD_INT 1
114238: PLUS
114239: PPUSH
114240: LD_VAR 0 1
114244: PPUSH
114245: CALL_OW 1
114249: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
114250: LD_ADDR_EXP 196
114254: PUSH
114255: LD_EXP 196
114259: PPUSH
114260: LD_EXP 196
114264: PUSH
114265: LD_INT 1
114267: PLUS
114268: PPUSH
114269: EMPTY
114270: PPUSH
114271: CALL_OW 1
114275: ST_TO_ADDR
// end ; if not factoryWaypoints then
114276: LD_EXP 184
114280: NOT
114281: IFFALSE 114285
// exit ;
114283: GO 114858
// for i := 1 to Count ( factoryWaypoints ) do
114285: LD_ADDR_VAR 0 4
114289: PUSH
114290: DOUBLE
114291: LD_INT 1
114293: DEC
114294: ST_TO_ADDR
114295: LD_EXP 184
114299: PPUSH
114300: CALL 56697 0 1
114304: PUSH
114305: FOR_TO
114306: IFFALSE 114856
// if factoryWaypoints [ i ] [ 2 ] = factory then
114308: LD_EXP 184
114312: PUSH
114313: LD_VAR 0 4
114317: ARRAY
114318: PUSH
114319: LD_INT 2
114321: ARRAY
114322: PUSH
114323: LD_VAR 0 2
114327: EQUAL
114328: IFFALSE 114854
// begin if GetControl ( vehicle ) = control_manual then
114330: LD_VAR 0 1
114334: PPUSH
114335: CALL_OW 263
114339: PUSH
114340: LD_INT 1
114342: EQUAL
114343: IFFALSE 114707
// begin driver := IsDrivenBy ( vehicle ) ;
114345: LD_ADDR_VAR 0 5
114349: PUSH
114350: LD_VAR 0 1
114354: PPUSH
114355: CALL_OW 311
114359: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
114360: LD_VAR 0 5
114364: PUSH
114365: LD_EXP 185
114369: IN
114370: IFTRUE 114384
114372: PUSH
114373: LD_VAR 0 1
114377: PUSH
114378: LD_EXP 185
114382: IN
114383: OR
114384: IFFALSE 114390
// exit ;
114386: POP
114387: POP
114388: GO 114858
// if not HasTask ( driver ) then
114390: LD_VAR 0 5
114394: PPUSH
114395: CALL_OW 314
114399: NOT
114400: IFFALSE 114705
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
114402: LD_ADDR_EXP 185
114406: PUSH
114407: LD_EXP 185
114411: PPUSH
114412: LD_VAR 0 5
114416: PPUSH
114417: CALL 92673 0 2
114421: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
114422: LD_ADDR_EXP 185
114426: PUSH
114427: LD_EXP 185
114431: PPUSH
114432: LD_VAR 0 1
114436: PPUSH
114437: CALL 92673 0 2
114441: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
114442: LD_ADDR_VAR 0 6
114446: PUSH
114447: LD_EXP 184
114451: PUSH
114452: LD_VAR 0 4
114456: ARRAY
114457: PUSH
114458: LD_INT 3
114460: ARRAY
114461: PPUSH
114462: LD_EXP 184
114466: PUSH
114467: LD_VAR 0 4
114471: ARRAY
114472: PUSH
114473: LD_INT 4
114475: ARRAY
114476: PPUSH
114477: CALL_OW 428
114481: ST_TO_ADDR
// if hex then
114482: LD_VAR 0 6
114486: IFFALSE 114504
// ComMoveUnit ( driver , hex ) else
114488: LD_VAR 0 5
114492: PPUSH
114493: LD_VAR 0 6
114497: PPUSH
114498: CALL_OW 112
114502: GO 114588
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
114504: LD_VAR 0 1
114508: PPUSH
114509: LD_EXP 184
114513: PUSH
114514: LD_VAR 0 4
114518: ARRAY
114519: PUSH
114520: LD_INT 3
114522: ARRAY
114523: PPUSH
114524: LD_EXP 184
114528: PUSH
114529: LD_VAR 0 4
114533: ARRAY
114534: PUSH
114535: LD_INT 4
114537: ARRAY
114538: PPUSH
114539: CALL_OW 297
114543: PUSH
114544: LD_INT 0
114546: GREATER
114547: IFFALSE 114588
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
114549: LD_VAR 0 5
114553: PPUSH
114554: LD_EXP 184
114558: PUSH
114559: LD_VAR 0 4
114563: ARRAY
114564: PUSH
114565: LD_INT 3
114567: ARRAY
114568: PPUSH
114569: LD_EXP 184
114573: PUSH
114574: LD_VAR 0 4
114578: ARRAY
114579: PUSH
114580: LD_INT 4
114582: ARRAY
114583: PPUSH
114584: CALL_OW 111
// AddComExitVehicle ( driver ) ;
114588: LD_VAR 0 5
114592: PPUSH
114593: CALL_OW 181
// if Multiplayer then
114597: LD_OWVAR 4
114601: IFFALSE 114650
// begin repeat wait ( 10 ) ;
114603: LD_INT 10
114605: PPUSH
114606: CALL_OW 67
// until not IsInUnit ( driver ) ;
114610: LD_VAR 0 5
114614: PPUSH
114615: CALL_OW 310
114619: NOT
114620: IFFALSE 114603
// if not HasTask ( driver ) then
114622: LD_VAR 0 5
114626: PPUSH
114627: CALL_OW 314
114631: NOT
114632: IFFALSE 114648
// ComEnterUnit ( driver , factory ) ;
114634: LD_VAR 0 5
114638: PPUSH
114639: LD_VAR 0 2
114643: PPUSH
114644: CALL_OW 120
// end else
114648: GO 114664
// AddComEnterUnit ( driver , factory ) ;
114650: LD_VAR 0 5
114654: PPUSH
114655: LD_VAR 0 2
114659: PPUSH
114660: CALL_OW 180
// wait ( 0 0$1 ) ;
114664: LD_INT 35
114666: PPUSH
114667: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
114671: LD_ADDR_EXP 185
114675: PUSH
114676: LD_EXP 185
114680: PUSH
114681: LD_VAR 0 5
114685: DIFF
114686: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
114687: LD_ADDR_EXP 185
114691: PUSH
114692: LD_EXP 185
114696: PUSH
114697: LD_VAR 0 1
114701: DIFF
114702: ST_TO_ADDR
// break ;
114703: GO 114856
// end ; end else
114705: GO 114854
// if GetControl ( vehicle ) = control_remote then
114707: LD_VAR 0 1
114711: PPUSH
114712: CALL_OW 263
114716: PUSH
114717: LD_INT 2
114719: EQUAL
114720: IFFALSE 114806
// begin wait ( 0 0$2 ) ;
114722: LD_INT 70
114724: PPUSH
114725: CALL_OW 67
// repeat wait ( 10 ) ;
114729: LD_INT 10
114731: PPUSH
114732: CALL_OW 67
// Connect ( vehicle ) ;
114736: LD_VAR 0 1
114740: PPUSH
114741: CALL 62975 0 1
// until IsControledBy ( vehicle ) ;
114745: LD_VAR 0 1
114749: PPUSH
114750: CALL_OW 312
114754: IFFALSE 114729
// wait ( 10 ) ;
114756: LD_INT 10
114758: PPUSH
114759: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
114763: LD_VAR 0 1
114767: PPUSH
114768: LD_EXP 184
114772: PUSH
114773: LD_VAR 0 4
114777: ARRAY
114778: PUSH
114779: LD_INT 3
114781: ARRAY
114782: PPUSH
114783: LD_EXP 184
114787: PUSH
114788: LD_VAR 0 4
114792: ARRAY
114793: PUSH
114794: LD_INT 4
114796: ARRAY
114797: PPUSH
114798: CALL_OW 111
// break ;
114802: GO 114856
// end else
114804: GO 114854
// begin wait ( 0 0$3 ) ;
114806: LD_INT 105
114808: PPUSH
114809: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
114813: LD_VAR 0 1
114817: PPUSH
114818: LD_EXP 184
114822: PUSH
114823: LD_VAR 0 4
114827: ARRAY
114828: PUSH
114829: LD_INT 3
114831: ARRAY
114832: PPUSH
114833: LD_EXP 184
114837: PUSH
114838: LD_VAR 0 4
114842: ARRAY
114843: PUSH
114844: LD_INT 4
114846: ARRAY
114847: PPUSH
114848: CALL_OW 111
// break ;
114852: GO 114856
// end ; end ;
114854: GO 114305
114856: POP
114857: POP
// end ;
114858: LD_VAR 0 3
114862: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
114863: LD_INT 0
114865: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
114866: LD_VAR 0 1
114870: PUSH
114871: LD_INT 250
114873: EQUAL
114874: IFFALSE 114891
114876: PUSH
114877: LD_VAR 0 2
114881: PPUSH
114882: CALL_OW 264
114886: PUSH
114887: LD_INT 81
114889: EQUAL
114890: AND
114891: IFFALSE 114912
// MinerPlaceMine ( unit , x , y ) ;
114893: LD_VAR 0 2
114897: PPUSH
114898: LD_VAR 0 4
114902: PPUSH
114903: LD_VAR 0 5
114907: PPUSH
114908: CALL 118258 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
114912: LD_VAR 0 1
114916: PUSH
114917: LD_INT 251
114919: EQUAL
114920: IFFALSE 114937
114922: PUSH
114923: LD_VAR 0 2
114927: PPUSH
114928: CALL_OW 264
114932: PUSH
114933: LD_INT 81
114935: EQUAL
114936: AND
114937: IFFALSE 114958
// MinerDetonateMine ( unit , x , y ) ;
114939: LD_VAR 0 2
114943: PPUSH
114944: LD_VAR 0 4
114948: PPUSH
114949: LD_VAR 0 5
114953: PPUSH
114954: CALL 118665 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
114958: LD_VAR 0 1
114962: PUSH
114963: LD_INT 252
114965: EQUAL
114966: IFFALSE 114983
114968: PUSH
114969: LD_VAR 0 2
114973: PPUSH
114974: CALL_OW 264
114978: PUSH
114979: LD_INT 81
114981: EQUAL
114982: AND
114983: IFFALSE 115004
// MinerCreateMinefield ( unit , x , y ) ;
114985: LD_VAR 0 2
114989: PPUSH
114990: LD_VAR 0 4
114994: PPUSH
114995: LD_VAR 0 5
114999: PPUSH
115000: CALL 118897 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
115004: LD_VAR 0 1
115008: PUSH
115009: LD_INT 253
115011: EQUAL
115012: IFFALSE 115029
115014: PUSH
115015: LD_VAR 0 2
115019: PPUSH
115020: CALL_OW 257
115024: PUSH
115025: LD_INT 5
115027: EQUAL
115028: AND
115029: IFFALSE 115050
// ComBinocular ( unit , x , y ) ;
115031: LD_VAR 0 2
115035: PPUSH
115036: LD_VAR 0 4
115040: PPUSH
115041: LD_VAR 0 5
115045: PPUSH
115046: CALL 119272 0 3
// if selectedUnit then
115050: LD_VAR 0 3
115054: IFFALSE 115114
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
115056: LD_VAR 0 1
115060: PUSH
115061: LD_INT 254
115063: EQUAL
115064: IFFALSE 115081
115066: PUSH
115067: LD_VAR 0 2
115071: PPUSH
115072: CALL_OW 264
115076: PUSH
115077: LD_INT 99
115079: EQUAL
115080: AND
115081: IFFALSE 115098
115083: PUSH
115084: LD_VAR 0 3
115088: PPUSH
115089: CALL_OW 263
115093: PUSH
115094: LD_INT 3
115096: EQUAL
115097: AND
115098: IFFALSE 115114
// HackDestroyVehicle ( unit , selectedUnit ) ;
115100: LD_VAR 0 2
115104: PPUSH
115105: LD_VAR 0 3
115109: PPUSH
115110: CALL 117448 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
115114: LD_VAR 0 1
115118: PUSH
115119: LD_INT 255
115121: EQUAL
115122: IFFALSE 115146
115124: PUSH
115125: LD_VAR 0 2
115129: PPUSH
115130: CALL_OW 264
115134: PUSH
115135: LD_INT 14
115137: PUSH
115138: LD_INT 53
115140: PUSH
115141: EMPTY
115142: LIST
115143: LIST
115144: IN
115145: AND
115146: IFFALSE 115164
115148: PUSH
115149: LD_VAR 0 4
115153: PPUSH
115154: LD_VAR 0 5
115158: PPUSH
115159: CALL_OW 488
115163: AND
115164: IFFALSE 115188
// CutTreeXYR ( unit , x , y , 12 ) ;
115166: LD_VAR 0 2
115170: PPUSH
115171: LD_VAR 0 4
115175: PPUSH
115176: LD_VAR 0 5
115180: PPUSH
115181: LD_INT 12
115183: PPUSH
115184: CALL 115379 0 4
// if cmd = 256 then
115188: LD_VAR 0 1
115192: PUSH
115193: LD_INT 256
115195: EQUAL
115196: IFFALSE 115217
// SetFactoryWaypoint ( unit , x , y ) ;
115198: LD_VAR 0 2
115202: PPUSH
115203: LD_VAR 0 4
115207: PPUSH
115208: LD_VAR 0 5
115212: PPUSH
115213: CALL 112658 0 3
// if cmd = 257 then
115217: LD_VAR 0 1
115221: PUSH
115222: LD_INT 257
115224: EQUAL
115225: IFFALSE 115246
// SetWarehouseGatheringPoint ( unit , x , y ) ;
115227: LD_VAR 0 2
115231: PPUSH
115232: LD_VAR 0 4
115236: PPUSH
115237: LD_VAR 0 5
115241: PPUSH
115242: CALL 113154 0 3
// if cmd = 258 then
115246: LD_VAR 0 1
115250: PUSH
115251: LD_INT 258
115253: EQUAL
115254: IFFALSE 115278
// BurnTreeXYR ( unit , x , y , 8 ) ;
115256: LD_VAR 0 2
115260: PPUSH
115261: LD_VAR 0 4
115265: PPUSH
115266: LD_VAR 0 5
115270: PPUSH
115271: LD_INT 8
115273: PPUSH
115274: CALL 115801 0 4
// end ;
115278: LD_VAR 0 6
115282: RET
// export function ComRadiation ( un ) ; var eff ; begin
115283: LD_INT 0
115285: PPUSH
115286: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
115287: LD_VAR 0 1
115291: PPUSH
115292: CALL_OW 264
115296: PUSH
115297: LD_INT 91
115299: NONEQUAL
115300: IFFALSE 115304
// exit ;
115302: GO 115374
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
115304: LD_INT 68
115306: PPUSH
115307: LD_VAR 0 1
115311: PPUSH
115312: CALL_OW 255
115316: PPUSH
115317: CALL_OW 321
115321: PUSH
115322: LD_INT 2
115324: EQUAL
115325: IFFALSE 115337
// eff := 50 else
115327: LD_ADDR_VAR 0 3
115331: PUSH
115332: LD_INT 50
115334: ST_TO_ADDR
115335: GO 115345
// eff := 25 ;
115337: LD_ADDR_VAR 0 3
115341: PUSH
115342: LD_INT 25
115344: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
115345: LD_VAR 0 1
115349: PPUSH
115350: CALL_OW 250
115354: PPUSH
115355: LD_VAR 0 1
115359: PPUSH
115360: CALL_OW 251
115364: PPUSH
115365: LD_VAR 0 3
115369: PPUSH
115370: CALL_OW 495
// end ;
115374: LD_VAR 0 2
115378: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
115379: LD_INT 0
115381: PPUSH
115382: PPUSH
115383: PPUSH
115384: PPUSH
115385: PPUSH
115386: PPUSH
115387: PPUSH
115388: PPUSH
115389: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
115390: LD_VAR 0 1
115394: PPUSH
115395: CALL_OW 302
115399: NOT
115400: IFTRUE 115419
115402: PUSH
115403: LD_VAR 0 2
115407: PPUSH
115408: LD_VAR 0 3
115412: PPUSH
115413: CALL_OW 488
115417: NOT
115418: OR
115419: IFTRUE 115428
115421: PUSH
115422: LD_VAR 0 4
115426: NOT
115427: OR
115428: IFFALSE 115432
// exit ;
115430: GO 115796
// if Count ( GetTaskList ( bulldozer ) ) > 10 then
115432: LD_VAR 0 1
115436: PPUSH
115437: CALL_OW 437
115441: PPUSH
115442: CALL 56697 0 1
115446: PUSH
115447: LD_INT 10
115449: GREATER
115450: IFFALSE 115454
// exit ;
115452: GO 115796
// list := [ ] ;
115454: LD_ADDR_VAR 0 13
115458: PUSH
115459: EMPTY
115460: ST_TO_ADDR
// if x - r < 0 then
115461: LD_VAR 0 2
115465: PUSH
115466: LD_VAR 0 4
115470: MINUS
115471: PUSH
115472: LD_INT 0
115474: LESS
115475: IFFALSE 115487
// min_x := 0 else
115477: LD_ADDR_VAR 0 7
115481: PUSH
115482: LD_INT 0
115484: ST_TO_ADDR
115485: GO 115503
// min_x := x - r ;
115487: LD_ADDR_VAR 0 7
115491: PUSH
115492: LD_VAR 0 2
115496: PUSH
115497: LD_VAR 0 4
115501: MINUS
115502: ST_TO_ADDR
// if y - r < 0 then
115503: LD_VAR 0 3
115507: PUSH
115508: LD_VAR 0 4
115512: MINUS
115513: PUSH
115514: LD_INT 0
115516: LESS
115517: IFFALSE 115529
// min_y := 0 else
115519: LD_ADDR_VAR 0 8
115523: PUSH
115524: LD_INT 0
115526: ST_TO_ADDR
115527: GO 115545
// min_y := y - r ;
115529: LD_ADDR_VAR 0 8
115533: PUSH
115534: LD_VAR 0 3
115538: PUSH
115539: LD_VAR 0 4
115543: MINUS
115544: ST_TO_ADDR
// max_x := x + r ;
115545: LD_ADDR_VAR 0 9
115549: PUSH
115550: LD_VAR 0 2
115554: PUSH
115555: LD_VAR 0 4
115559: PLUS
115560: ST_TO_ADDR
// max_y := y + r ;
115561: LD_ADDR_VAR 0 10
115565: PUSH
115566: LD_VAR 0 3
115570: PUSH
115571: LD_VAR 0 4
115575: PLUS
115576: ST_TO_ADDR
// for _x = min_x to max_x do
115577: LD_ADDR_VAR 0 11
115581: PUSH
115582: DOUBLE
115583: LD_VAR 0 7
115587: DEC
115588: ST_TO_ADDR
115589: LD_VAR 0 9
115593: PUSH
115594: FOR_TO
115595: IFFALSE 115714
// for _y = min_y to max_y do
115597: LD_ADDR_VAR 0 12
115601: PUSH
115602: DOUBLE
115603: LD_VAR 0 8
115607: DEC
115608: ST_TO_ADDR
115609: LD_VAR 0 10
115613: PUSH
115614: FOR_TO
115615: IFFALSE 115710
// begin if not ValidHex ( _x , _y ) then
115617: LD_VAR 0 11
115621: PPUSH
115622: LD_VAR 0 12
115626: PPUSH
115627: CALL_OW 488
115631: NOT
115632: IFFALSE 115636
// continue ;
115634: GO 115614
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
115636: LD_VAR 0 11
115640: PPUSH
115641: LD_VAR 0 12
115645: PPUSH
115646: CALL_OW 351
115650: IFFALSE 115668
115652: PUSH
115653: LD_VAR 0 11
115657: PPUSH
115658: LD_VAR 0 12
115662: PPUSH
115663: CALL_OW 554
115667: AND
115668: IFFALSE 115708
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
115670: LD_ADDR_VAR 0 13
115674: PUSH
115675: LD_VAR 0 13
115679: PPUSH
115680: LD_VAR 0 13
115684: PUSH
115685: LD_INT 1
115687: PLUS
115688: PPUSH
115689: LD_VAR 0 11
115693: PUSH
115694: LD_VAR 0 12
115698: PUSH
115699: EMPTY
115700: LIST
115701: LIST
115702: PPUSH
115703: CALL_OW 2
115707: ST_TO_ADDR
// end ;
115708: GO 115614
115710: POP
115711: POP
115712: GO 115594
115714: POP
115715: POP
// if not list then
115716: LD_VAR 0 13
115720: NOT
115721: IFFALSE 115725
// exit ;
115723: GO 115796
// for i in list do
115725: LD_ADDR_VAR 0 6
115729: PUSH
115730: LD_VAR 0 13
115734: PUSH
115735: FOR_IN
115736: IFFALSE 115794
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
115738: LD_VAR 0 1
115742: PPUSH
115743: LD_STRING M
115745: PUSH
115746: LD_VAR 0 6
115750: PUSH
115751: LD_INT 1
115753: ARRAY
115754: PUSH
115755: LD_VAR 0 6
115759: PUSH
115760: LD_INT 2
115762: ARRAY
115763: PUSH
115764: LD_INT 0
115766: PUSH
115767: LD_INT 0
115769: PUSH
115770: LD_INT 0
115772: PUSH
115773: LD_INT 0
115775: PUSH
115776: EMPTY
115777: LIST
115778: LIST
115779: LIST
115780: LIST
115781: LIST
115782: LIST
115783: LIST
115784: PUSH
115785: EMPTY
115786: LIST
115787: PPUSH
115788: CALL_OW 447
115792: GO 115735
115794: POP
115795: POP
// end ;
115796: LD_VAR 0 5
115800: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
115801: LD_INT 0
115803: PPUSH
115804: PPUSH
115805: PPUSH
115806: PPUSH
115807: PPUSH
115808: PPUSH
115809: PPUSH
115810: PPUSH
115811: PPUSH
115812: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
115813: LD_VAR 0 1
115817: PPUSH
115818: CALL_OW 302
115822: NOT
115823: IFTRUE 115842
115825: PUSH
115826: LD_VAR 0 2
115830: PPUSH
115831: LD_VAR 0 3
115835: PPUSH
115836: CALL_OW 488
115840: NOT
115841: OR
115842: IFTRUE 115851
115844: PUSH
115845: LD_VAR 0 4
115849: NOT
115850: OR
115851: IFFALSE 115855
// exit ;
115853: GO 116394
// if Count ( GetTaskList ( flame ) ) > 10 then
115855: LD_VAR 0 1
115859: PPUSH
115860: CALL_OW 437
115864: PPUSH
115865: CALL 56697 0 1
115869: PUSH
115870: LD_INT 10
115872: GREATER
115873: IFFALSE 115877
// exit ;
115875: GO 116394
// list := [ ] ;
115877: LD_ADDR_VAR 0 13
115881: PUSH
115882: EMPTY
115883: ST_TO_ADDR
// if x - r < 0 then
115884: LD_VAR 0 2
115888: PUSH
115889: LD_VAR 0 4
115893: MINUS
115894: PUSH
115895: LD_INT 0
115897: LESS
115898: IFFALSE 115910
// min_x := 0 else
115900: LD_ADDR_VAR 0 7
115904: PUSH
115905: LD_INT 0
115907: ST_TO_ADDR
115908: GO 115926
// min_x := x - r ;
115910: LD_ADDR_VAR 0 7
115914: PUSH
115915: LD_VAR 0 2
115919: PUSH
115920: LD_VAR 0 4
115924: MINUS
115925: ST_TO_ADDR
// if y - r < 0 then
115926: LD_VAR 0 3
115930: PUSH
115931: LD_VAR 0 4
115935: MINUS
115936: PUSH
115937: LD_INT 0
115939: LESS
115940: IFFALSE 115952
// min_y := 0 else
115942: LD_ADDR_VAR 0 8
115946: PUSH
115947: LD_INT 0
115949: ST_TO_ADDR
115950: GO 115968
// min_y := y - r ;
115952: LD_ADDR_VAR 0 8
115956: PUSH
115957: LD_VAR 0 3
115961: PUSH
115962: LD_VAR 0 4
115966: MINUS
115967: ST_TO_ADDR
// max_x := x + r ;
115968: LD_ADDR_VAR 0 9
115972: PUSH
115973: LD_VAR 0 2
115977: PUSH
115978: LD_VAR 0 4
115982: PLUS
115983: ST_TO_ADDR
// max_y := y + r ;
115984: LD_ADDR_VAR 0 10
115988: PUSH
115989: LD_VAR 0 3
115993: PUSH
115994: LD_VAR 0 4
115998: PLUS
115999: ST_TO_ADDR
// for _x = min_x to max_x do
116000: LD_ADDR_VAR 0 11
116004: PUSH
116005: DOUBLE
116006: LD_VAR 0 7
116010: DEC
116011: ST_TO_ADDR
116012: LD_VAR 0 9
116016: PUSH
116017: FOR_TO
116018: IFFALSE 116137
// for _y = min_y to max_y do
116020: LD_ADDR_VAR 0 12
116024: PUSH
116025: DOUBLE
116026: LD_VAR 0 8
116030: DEC
116031: ST_TO_ADDR
116032: LD_VAR 0 10
116036: PUSH
116037: FOR_TO
116038: IFFALSE 116133
// begin if not ValidHex ( _x , _y ) then
116040: LD_VAR 0 11
116044: PPUSH
116045: LD_VAR 0 12
116049: PPUSH
116050: CALL_OW 488
116054: NOT
116055: IFFALSE 116059
// continue ;
116057: GO 116037
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
116059: LD_VAR 0 11
116063: PPUSH
116064: LD_VAR 0 12
116068: PPUSH
116069: CALL_OW 351
116073: IFFALSE 116091
116075: PUSH
116076: LD_VAR 0 11
116080: PPUSH
116081: LD_VAR 0 12
116085: PPUSH
116086: CALL_OW 554
116090: AND
116091: IFFALSE 116131
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
116093: LD_ADDR_VAR 0 13
116097: PUSH
116098: LD_VAR 0 13
116102: PPUSH
116103: LD_VAR 0 13
116107: PUSH
116108: LD_INT 1
116110: PLUS
116111: PPUSH
116112: LD_VAR 0 11
116116: PUSH
116117: LD_VAR 0 12
116121: PUSH
116122: EMPTY
116123: LIST
116124: LIST
116125: PPUSH
116126: CALL_OW 2
116130: ST_TO_ADDR
// end ;
116131: GO 116037
116133: POP
116134: POP
116135: GO 116017
116137: POP
116138: POP
// if not list then
116139: LD_VAR 0 13
116143: NOT
116144: IFFALSE 116148
// exit ;
116146: GO 116394
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
116148: LD_ADDR_VAR 0 13
116152: PUSH
116153: LD_VAR 0 1
116157: PPUSH
116158: LD_VAR 0 13
116162: PPUSH
116163: LD_INT 1
116165: PPUSH
116166: LD_INT 1
116168: PPUSH
116169: CALL 60103 0 4
116173: ST_TO_ADDR
// ComStop ( flame ) ;
116174: LD_VAR 0 1
116178: PPUSH
116179: CALL_OW 141
// for i in list do
116183: LD_ADDR_VAR 0 6
116187: PUSH
116188: LD_VAR 0 13
116192: PUSH
116193: FOR_IN
116194: IFFALSE 116225
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
116196: LD_VAR 0 1
116200: PPUSH
116201: LD_VAR 0 6
116205: PUSH
116206: LD_INT 1
116208: ARRAY
116209: PPUSH
116210: LD_VAR 0 6
116214: PUSH
116215: LD_INT 2
116217: ARRAY
116218: PPUSH
116219: CALL_OW 176
116223: GO 116193
116225: POP
116226: POP
// repeat wait ( 0 0$1 ) ;
116227: LD_INT 35
116229: PPUSH
116230: CALL_OW 67
// task := GetTaskList ( flame ) ;
116234: LD_ADDR_VAR 0 14
116238: PUSH
116239: LD_VAR 0 1
116243: PPUSH
116244: CALL_OW 437
116248: ST_TO_ADDR
// if not task then
116249: LD_VAR 0 14
116253: NOT
116254: IFFALSE 116258
// exit ;
116256: GO 116394
// if task [ 1 ] [ 1 ] <> | then
116258: LD_VAR 0 14
116262: PUSH
116263: LD_INT 1
116265: ARRAY
116266: PUSH
116267: LD_INT 1
116269: ARRAY
116270: PUSH
116271: LD_STRING |
116273: NONEQUAL
116274: IFFALSE 116278
// exit ;
116276: GO 116394
// _x := task [ 1 ] [ 2 ] ;
116278: LD_ADDR_VAR 0 11
116282: PUSH
116283: LD_VAR 0 14
116287: PUSH
116288: LD_INT 1
116290: ARRAY
116291: PUSH
116292: LD_INT 2
116294: ARRAY
116295: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
116296: LD_ADDR_VAR 0 12
116300: PUSH
116301: LD_VAR 0 14
116305: PUSH
116306: LD_INT 1
116308: ARRAY
116309: PUSH
116310: LD_INT 3
116312: ARRAY
116313: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
116314: LD_VAR 0 11
116318: PPUSH
116319: LD_VAR 0 12
116323: PPUSH
116324: CALL_OW 351
116328: NOT
116329: IFTRUE 116348
116331: PUSH
116332: LD_VAR 0 11
116336: PPUSH
116337: LD_VAR 0 12
116341: PPUSH
116342: CALL_OW 554
116346: NOT
116347: OR
116348: IFFALSE 116382
// begin task := Delete ( task , 1 ) ;
116350: LD_ADDR_VAR 0 14
116354: PUSH
116355: LD_VAR 0 14
116359: PPUSH
116360: LD_INT 1
116362: PPUSH
116363: CALL_OW 3
116367: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
116368: LD_VAR 0 1
116372: PPUSH
116373: LD_VAR 0 14
116377: PPUSH
116378: CALL_OW 446
// end ; until not HasTask ( flame ) ;
116382: LD_VAR 0 1
116386: PPUSH
116387: CALL_OW 314
116391: NOT
116392: IFFALSE 116227
// end ;
116394: LD_VAR 0 5
116398: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
116399: LD_EXP 188
116403: NOT
116404: IFFALSE 116454
116406: GO 116408
116408: DISABLE
// begin initHack := true ;
116409: LD_ADDR_EXP 188
116413: PUSH
116414: LD_INT 1
116416: ST_TO_ADDR
// hackTanks := [ ] ;
116417: LD_ADDR_EXP 189
116421: PUSH
116422: EMPTY
116423: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
116424: LD_ADDR_EXP 190
116428: PUSH
116429: EMPTY
116430: ST_TO_ADDR
// hackLimit := 3 ;
116431: LD_ADDR_EXP 191
116435: PUSH
116436: LD_INT 3
116438: ST_TO_ADDR
// hackDist := 12 ;
116439: LD_ADDR_EXP 192
116443: PUSH
116444: LD_INT 12
116446: ST_TO_ADDR
// hackCounter := [ ] ;
116447: LD_ADDR_EXP 193
116451: PUSH
116452: EMPTY
116453: ST_TO_ADDR
// end ;
116454: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
116455: LD_EXP 188
116459: IFFALSE 116477
116461: PUSH
116462: LD_INT 34
116464: PUSH
116465: LD_INT 99
116467: PUSH
116468: EMPTY
116469: LIST
116470: LIST
116471: PPUSH
116472: CALL_OW 69
116476: AND
116477: IFFALSE 116730
116479: GO 116481
116481: DISABLE
116482: LD_INT 0
116484: PPUSH
116485: PPUSH
// begin enable ;
116486: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
116487: LD_ADDR_VAR 0 1
116491: PUSH
116492: LD_INT 34
116494: PUSH
116495: LD_INT 99
116497: PUSH
116498: EMPTY
116499: LIST
116500: LIST
116501: PPUSH
116502: CALL_OW 69
116506: PUSH
116507: FOR_IN
116508: IFFALSE 116728
// begin if not i in hackTanks then
116510: LD_VAR 0 1
116514: PUSH
116515: LD_EXP 189
116519: IN
116520: NOT
116521: IFFALSE 116604
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
116523: LD_ADDR_EXP 189
116527: PUSH
116528: LD_EXP 189
116532: PPUSH
116533: LD_EXP 189
116537: PUSH
116538: LD_INT 1
116540: PLUS
116541: PPUSH
116542: LD_VAR 0 1
116546: PPUSH
116547: CALL_OW 1
116551: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
116552: LD_ADDR_EXP 190
116556: PUSH
116557: LD_EXP 190
116561: PPUSH
116562: LD_EXP 190
116566: PUSH
116567: LD_INT 1
116569: PLUS
116570: PPUSH
116571: EMPTY
116572: PPUSH
116573: CALL_OW 1
116577: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
116578: LD_ADDR_EXP 193
116582: PUSH
116583: LD_EXP 193
116587: PPUSH
116588: LD_EXP 193
116592: PUSH
116593: LD_INT 1
116595: PLUS
116596: PPUSH
116597: EMPTY
116598: PPUSH
116599: CALL_OW 1
116603: ST_TO_ADDR
// end ; if not IsOk ( i ) then
116604: LD_VAR 0 1
116608: PPUSH
116609: CALL_OW 302
116613: NOT
116614: IFFALSE 116627
// begin HackUnlinkAll ( i ) ;
116616: LD_VAR 0 1
116620: PPUSH
116621: CALL 116733 0 1
// continue ;
116625: GO 116507
// end ; HackCheckCapturedStatus ( i ) ;
116627: LD_VAR 0 1
116631: PPUSH
116632: CALL 117178 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
116636: LD_ADDR_VAR 0 2
116640: PUSH
116641: LD_INT 81
116643: PUSH
116644: LD_VAR 0 1
116648: PPUSH
116649: CALL_OW 255
116653: PUSH
116654: EMPTY
116655: LIST
116656: LIST
116657: PUSH
116658: LD_INT 33
116660: PUSH
116661: LD_INT 3
116663: PUSH
116664: EMPTY
116665: LIST
116666: LIST
116667: PUSH
116668: LD_INT 91
116670: PUSH
116671: LD_VAR 0 1
116675: PUSH
116676: LD_EXP 192
116680: PUSH
116681: EMPTY
116682: LIST
116683: LIST
116684: LIST
116685: PUSH
116686: LD_INT 50
116688: PUSH
116689: EMPTY
116690: LIST
116691: PUSH
116692: EMPTY
116693: LIST
116694: LIST
116695: LIST
116696: LIST
116697: PPUSH
116698: CALL_OW 69
116702: ST_TO_ADDR
// if not tmp then
116703: LD_VAR 0 2
116707: NOT
116708: IFFALSE 116712
// continue ;
116710: GO 116507
// HackLink ( i , tmp ) ;
116712: LD_VAR 0 1
116716: PPUSH
116717: LD_VAR 0 2
116721: PPUSH
116722: CALL 116869 0 2
// end ;
116726: GO 116507
116728: POP
116729: POP
// end ;
116730: PPOPN 2
116732: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
116733: LD_INT 0
116735: PPUSH
116736: PPUSH
116737: PPUSH
// if not hack in hackTanks then
116738: LD_VAR 0 1
116742: PUSH
116743: LD_EXP 189
116747: IN
116748: NOT
116749: IFFALSE 116753
// exit ;
116751: GO 116864
// index := GetElementIndex ( hackTanks , hack ) ;
116753: LD_ADDR_VAR 0 4
116757: PUSH
116758: LD_EXP 189
116762: PPUSH
116763: LD_VAR 0 1
116767: PPUSH
116768: CALL 59398 0 2
116772: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
116773: LD_EXP 190
116777: PUSH
116778: LD_VAR 0 4
116782: ARRAY
116783: IFFALSE 116864
// begin for i in hackTanksCaptured [ index ] do
116785: LD_ADDR_VAR 0 3
116789: PUSH
116790: LD_EXP 190
116794: PUSH
116795: LD_VAR 0 4
116799: ARRAY
116800: PUSH
116801: FOR_IN
116802: IFFALSE 116828
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
116804: LD_VAR 0 3
116808: PUSH
116809: LD_INT 1
116811: ARRAY
116812: PPUSH
116813: LD_VAR 0 3
116817: PUSH
116818: LD_INT 2
116820: ARRAY
116821: PPUSH
116822: CALL_OW 235
116826: GO 116801
116828: POP
116829: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
116830: LD_ADDR_EXP 190
116834: PUSH
116835: LD_EXP 190
116839: PPUSH
116840: LD_VAR 0 4
116844: PPUSH
116845: EMPTY
116846: PPUSH
116847: CALL_OW 1
116851: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
116852: LD_VAR 0 1
116856: PPUSH
116857: LD_INT 0
116859: PPUSH
116860: CALL_OW 505
// end ; end ;
116864: LD_VAR 0 2
116868: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
116869: LD_INT 0
116871: PPUSH
116872: PPUSH
116873: PPUSH
// if not hack in hackTanks or not vehicles then
116874: LD_VAR 0 1
116878: PUSH
116879: LD_EXP 189
116883: IN
116884: NOT
116885: IFTRUE 116894
116887: PUSH
116888: LD_VAR 0 2
116892: NOT
116893: OR
116894: IFFALSE 116898
// exit ;
116896: GO 117173
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
116898: LD_ADDR_VAR 0 2
116902: PUSH
116903: LD_VAR 0 1
116907: PPUSH
116908: LD_VAR 0 2
116912: PPUSH
116913: LD_INT 1
116915: PPUSH
116916: LD_INT 1
116918: PPUSH
116919: CALL 60050 0 4
116923: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
116924: LD_ADDR_VAR 0 5
116928: PUSH
116929: LD_EXP 189
116933: PPUSH
116934: LD_VAR 0 1
116938: PPUSH
116939: CALL 59398 0 2
116943: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
116944: LD_EXP 190
116948: PUSH
116949: LD_VAR 0 5
116953: ARRAY
116954: PUSH
116955: LD_EXP 191
116959: LESS
116960: IFFALSE 117149
// begin for i := 1 to vehicles do
116962: LD_ADDR_VAR 0 4
116966: PUSH
116967: DOUBLE
116968: LD_INT 1
116970: DEC
116971: ST_TO_ADDR
116972: LD_VAR 0 2
116976: PUSH
116977: FOR_TO
116978: IFFALSE 117147
// begin if hackTanksCaptured [ index ] = hackLimit then
116980: LD_EXP 190
116984: PUSH
116985: LD_VAR 0 5
116989: ARRAY
116990: PUSH
116991: LD_EXP 191
116995: EQUAL
116996: IFFALSE 117000
// break ;
116998: GO 117147
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
117000: LD_ADDR_EXP 193
117004: PUSH
117005: LD_EXP 193
117009: PPUSH
117010: LD_VAR 0 5
117014: PPUSH
117015: LD_EXP 193
117019: PUSH
117020: LD_VAR 0 5
117024: ARRAY
117025: PUSH
117026: LD_INT 1
117028: PLUS
117029: PPUSH
117030: CALL_OW 1
117034: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
117035: LD_ADDR_EXP 190
117039: PUSH
117040: LD_EXP 190
117044: PPUSH
117045: LD_VAR 0 5
117049: PUSH
117050: LD_EXP 190
117054: PUSH
117055: LD_VAR 0 5
117059: ARRAY
117060: PUSH
117061: LD_INT 1
117063: PLUS
117064: PUSH
117065: EMPTY
117066: LIST
117067: LIST
117068: PPUSH
117069: LD_VAR 0 2
117073: PUSH
117074: LD_VAR 0 4
117078: ARRAY
117079: PUSH
117080: LD_VAR 0 2
117084: PUSH
117085: LD_VAR 0 4
117089: ARRAY
117090: PPUSH
117091: CALL_OW 255
117095: PUSH
117096: EMPTY
117097: LIST
117098: LIST
117099: PPUSH
117100: CALL 59615 0 3
117104: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
117105: LD_VAR 0 2
117109: PUSH
117110: LD_VAR 0 4
117114: ARRAY
117115: PPUSH
117116: LD_VAR 0 1
117120: PPUSH
117121: CALL_OW 255
117125: PPUSH
117126: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
117130: LD_VAR 0 2
117134: PUSH
117135: LD_VAR 0 4
117139: ARRAY
117140: PPUSH
117141: CALL_OW 141
// end ;
117145: GO 116977
117147: POP
117148: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117149: LD_VAR 0 1
117153: PPUSH
117154: LD_EXP 190
117158: PUSH
117159: LD_VAR 0 5
117163: ARRAY
117164: PUSH
117165: LD_INT 0
117167: PLUS
117168: PPUSH
117169: CALL_OW 505
// end ;
117173: LD_VAR 0 3
117177: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
117178: LD_INT 0
117180: PPUSH
117181: PPUSH
117182: PPUSH
117183: PPUSH
// if not hack in hackTanks then
117184: LD_VAR 0 1
117188: PUSH
117189: LD_EXP 189
117193: IN
117194: NOT
117195: IFFALSE 117199
// exit ;
117197: GO 117443
// index := GetElementIndex ( hackTanks , hack ) ;
117199: LD_ADDR_VAR 0 4
117203: PUSH
117204: LD_EXP 189
117208: PPUSH
117209: LD_VAR 0 1
117213: PPUSH
117214: CALL 59398 0 2
117218: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
117219: LD_ADDR_VAR 0 3
117223: PUSH
117224: DOUBLE
117225: LD_EXP 190
117229: PUSH
117230: LD_VAR 0 4
117234: ARRAY
117235: INC
117236: ST_TO_ADDR
117237: LD_INT 1
117239: PUSH
117240: FOR_DOWNTO
117241: IFFALSE 117417
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
117243: LD_ADDR_VAR 0 5
117247: PUSH
117248: LD_EXP 190
117252: PUSH
117253: LD_VAR 0 4
117257: ARRAY
117258: PUSH
117259: LD_VAR 0 3
117263: ARRAY
117264: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
117265: LD_VAR 0 5
117269: PUSH
117270: LD_INT 1
117272: ARRAY
117273: PPUSH
117274: CALL_OW 302
117278: NOT
117279: IFTRUE 117307
117281: PUSH
117282: LD_VAR 0 5
117286: PUSH
117287: LD_INT 1
117289: ARRAY
117290: PPUSH
117291: CALL_OW 255
117295: PUSH
117296: LD_VAR 0 1
117300: PPUSH
117301: CALL_OW 255
117305: NONEQUAL
117306: OR
117307: IFFALSE 117415
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
117309: LD_VAR 0 5
117313: PUSH
117314: LD_INT 1
117316: ARRAY
117317: PPUSH
117318: CALL_OW 305
117322: IFFALSE 117350
117324: PUSH
117325: LD_VAR 0 5
117329: PUSH
117330: LD_INT 1
117332: ARRAY
117333: PPUSH
117334: CALL_OW 255
117338: PUSH
117339: LD_VAR 0 1
117343: PPUSH
117344: CALL_OW 255
117348: EQUAL
117349: AND
117350: IFFALSE 117374
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
117352: LD_VAR 0 5
117356: PUSH
117357: LD_INT 1
117359: ARRAY
117360: PPUSH
117361: LD_VAR 0 5
117365: PUSH
117366: LD_INT 2
117368: ARRAY
117369: PPUSH
117370: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
117374: LD_ADDR_EXP 190
117378: PUSH
117379: LD_EXP 190
117383: PPUSH
117384: LD_VAR 0 4
117388: PPUSH
117389: LD_EXP 190
117393: PUSH
117394: LD_VAR 0 4
117398: ARRAY
117399: PPUSH
117400: LD_VAR 0 3
117404: PPUSH
117405: CALL_OW 3
117409: PPUSH
117410: CALL_OW 1
117414: ST_TO_ADDR
// end ; end ;
117415: GO 117240
117417: POP
117418: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
117419: LD_VAR 0 1
117423: PPUSH
117424: LD_EXP 190
117428: PUSH
117429: LD_VAR 0 4
117433: ARRAY
117434: PUSH
117435: LD_INT 0
117437: PLUS
117438: PPUSH
117439: CALL_OW 505
// end ;
117443: LD_VAR 0 2
117447: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
117448: LD_INT 0
117450: PPUSH
117451: PPUSH
117452: PPUSH
117453: PPUSH
// if not hack in hackTanks then
117454: LD_VAR 0 1
117458: PUSH
117459: LD_EXP 189
117463: IN
117464: NOT
117465: IFFALSE 117469
// exit ;
117467: GO 117554
// index := GetElementIndex ( hackTanks , hack ) ;
117469: LD_ADDR_VAR 0 5
117473: PUSH
117474: LD_EXP 189
117478: PPUSH
117479: LD_VAR 0 1
117483: PPUSH
117484: CALL 59398 0 2
117488: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
117489: LD_ADDR_VAR 0 4
117493: PUSH
117494: DOUBLE
117495: LD_INT 1
117497: DEC
117498: ST_TO_ADDR
117499: LD_EXP 190
117503: PUSH
117504: LD_VAR 0 5
117508: ARRAY
117509: PUSH
117510: FOR_TO
117511: IFFALSE 117552
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
117513: LD_EXP 190
117517: PUSH
117518: LD_VAR 0 5
117522: ARRAY
117523: PUSH
117524: LD_VAR 0 4
117528: ARRAY
117529: PUSH
117530: LD_INT 1
117532: ARRAY
117533: PUSH
117534: LD_VAR 0 2
117538: EQUAL
117539: IFFALSE 117550
// KillUnit ( vehicle ) ;
117541: LD_VAR 0 2
117545: PPUSH
117546: CALL_OW 66
117550: GO 117510
117552: POP
117553: POP
// end ;
117554: LD_VAR 0 3
117558: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do var i ;
117559: LD_EXP 194
117563: NOT
117564: IFFALSE 117697
117566: GO 117568
117568: DISABLE
117569: LD_INT 0
117571: PPUSH
// begin initMiner := true ;
117572: LD_ADDR_EXP 194
117576: PUSH
117577: LD_INT 1
117579: ST_TO_ADDR
// minersList := [ ] ;
117580: LD_ADDR_EXP 195
117584: PUSH
117585: EMPTY
117586: ST_TO_ADDR
// minerMinesList := [ ] ;
117587: LD_ADDR_EXP 196
117591: PUSH
117592: EMPTY
117593: ST_TO_ADDR
// minesLimitPerVehicle := 10 ;
117594: LD_ADDR_EXP 197
117598: PUSH
117599: LD_INT 10
117601: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
117602: LD_ADDR_VAR 0 1
117606: PUSH
117607: LD_INT 34
117609: PUSH
117610: LD_INT 81
117612: PUSH
117613: EMPTY
117614: LIST
117615: LIST
117616: PPUSH
117617: CALL_OW 69
117621: PUSH
117622: FOR_IN
117623: IFFALSE 117695
// begin if not i in minersList then
117625: LD_VAR 0 1
117629: PUSH
117630: LD_EXP 195
117634: IN
117635: NOT
117636: IFFALSE 117693
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
117638: LD_ADDR_EXP 195
117642: PUSH
117643: LD_EXP 195
117647: PPUSH
117648: LD_EXP 195
117652: PUSH
117653: LD_INT 1
117655: PLUS
117656: PPUSH
117657: LD_VAR 0 1
117661: PPUSH
117662: CALL_OW 1
117666: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
117667: LD_ADDR_EXP 196
117671: PUSH
117672: LD_EXP 196
117676: PPUSH
117677: LD_EXP 196
117681: PUSH
117682: LD_INT 1
117684: PLUS
117685: PPUSH
117686: EMPTY
117687: PPUSH
117688: CALL_OW 1
117692: ST_TO_ADDR
// end end ;
117693: GO 117622
117695: POP
117696: POP
// end ;
117697: PPOPN 1
117699: END
// every 0 0$1 trigger initMiner and ( Count ( minerMinesList ) or FilterAllUnits ( [ f_weapon , ar_miner ] ) ) do var i , j , side , tmp ;
117700: LD_EXP 194
117704: IFFALSE 117735
117706: PUSH
117707: LD_EXP 196
117711: PPUSH
117712: CALL 56697 0 1
117716: IFTRUE 117734
117718: PUSH
117719: LD_INT 34
117721: PUSH
117722: LD_INT 81
117724: PUSH
117725: EMPTY
117726: LIST
117727: LIST
117728: PPUSH
117729: CALL_OW 69
117733: OR
117734: AND
117735: IFFALSE 118255
117737: GO 117739
117739: DISABLE
117740: LD_INT 0
117742: PPUSH
117743: PPUSH
117744: PPUSH
117745: PPUSH
// begin enable ;
117746: ENABLE
// for i := minerMinesList downto 1 do
117747: LD_ADDR_VAR 0 1
117751: PUSH
117752: DOUBLE
117753: LD_EXP 196
117757: INC
117758: ST_TO_ADDR
117759: LD_INT 1
117761: PUSH
117762: FOR_DOWNTO
117763: IFFALSE 118253
// begin side := GetSide ( minersList [ i ] ) ;
117765: LD_ADDR_VAR 0 3
117769: PUSH
117770: LD_EXP 195
117774: PUSH
117775: LD_VAR 0 1
117779: ARRAY
117780: PPUSH
117781: CALL_OW 255
117785: ST_TO_ADDR
// if IsLive ( minersList [ i ] ) and side in [ your_side , 9 ] then
117786: LD_EXP 195
117790: PUSH
117791: LD_VAR 0 1
117795: ARRAY
117796: PPUSH
117797: CALL_OW 300
117801: IFFALSE 117822
117803: PUSH
117804: LD_VAR 0 3
117808: PUSH
117809: LD_OWVAR 2
117813: PUSH
117814: LD_INT 9
117816: PUSH
117817: EMPTY
117818: LIST
117819: LIST
117820: IN
117821: AND
117822: IFFALSE 117855
// SetUnitDisplayNumber ( minersList [ i ] , Count ( minerMinesList [ i ] ) ) ;
117824: LD_EXP 195
117828: PUSH
117829: LD_VAR 0 1
117833: ARRAY
117834: PPUSH
117835: LD_EXP 196
117839: PUSH
117840: LD_VAR 0 1
117844: ARRAY
117845: PPUSH
117846: CALL 56697 0 1
117850: PPUSH
117851: CALL_OW 505
// if not minerMinesList [ i ] then
117855: LD_EXP 196
117859: PUSH
117860: LD_VAR 0 1
117864: ARRAY
117865: NOT
117866: IFFALSE 117870
// continue ;
117868: GO 117762
// for j := minerMinesList [ i ] downto 1 do
117870: LD_ADDR_VAR 0 2
117874: PUSH
117875: DOUBLE
117876: LD_EXP 196
117880: PUSH
117881: LD_VAR 0 1
117885: ARRAY
117886: INC
117887: ST_TO_ADDR
117888: LD_INT 1
117890: PUSH
117891: FOR_DOWNTO
117892: IFFALSE 118249
// begin if IsDead ( minersList [ i ] ) or not IsPlaced ( minersList [ i ] ) then
117894: LD_EXP 195
117898: PUSH
117899: LD_VAR 0 1
117903: ARRAY
117904: PPUSH
117905: CALL_OW 301
117909: IFTRUE 117929
117911: PUSH
117912: LD_EXP 195
117916: PUSH
117917: LD_VAR 0 1
117921: ARRAY
117922: PPUSH
117923: CALL_OW 305
117927: NOT
117928: OR
117929: IFFALSE 118020
// begin RemoveMineXY ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
117931: LD_EXP 196
117935: PUSH
117936: LD_VAR 0 1
117940: ARRAY
117941: PUSH
117942: LD_VAR 0 2
117946: ARRAY
117947: PUSH
117948: LD_INT 1
117950: ARRAY
117951: PPUSH
117952: LD_EXP 196
117956: PUSH
117957: LD_VAR 0 1
117961: ARRAY
117962: PUSH
117963: LD_VAR 0 2
117967: ARRAY
117968: PUSH
117969: LD_INT 2
117971: ARRAY
117972: PPUSH
117973: CALL_OW 612
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
117977: LD_ADDR_EXP 196
117981: PUSH
117982: LD_EXP 196
117986: PPUSH
117987: LD_VAR 0 1
117991: PPUSH
117992: LD_EXP 196
117996: PUSH
117997: LD_VAR 0 1
118001: ARRAY
118002: PPUSH
118003: LD_VAR 0 2
118007: PPUSH
118008: CALL_OW 3
118012: PPUSH
118013: CALL_OW 1
118017: ST_TO_ADDR
// continue ;
118018: GO 117891
// end ; tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
118020: LD_ADDR_VAR 0 4
118024: PUSH
118025: LD_EXP 196
118029: PUSH
118030: LD_VAR 0 1
118034: ARRAY
118035: PUSH
118036: LD_VAR 0 2
118040: ARRAY
118041: PUSH
118042: LD_INT 1
118044: ARRAY
118045: PPUSH
118046: LD_EXP 196
118050: PUSH
118051: LD_VAR 0 1
118055: ARRAY
118056: PUSH
118057: LD_VAR 0 2
118061: ARRAY
118062: PUSH
118063: LD_INT 2
118065: ARRAY
118066: PPUSH
118067: CALL_OW 428
118071: ST_TO_ADDR
// if not tmp then
118072: LD_VAR 0 4
118076: NOT
118077: IFFALSE 118081
// continue ;
118079: GO 117891
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
118081: LD_VAR 0 4
118085: PUSH
118086: LD_INT 81
118088: PUSH
118089: LD_VAR 0 3
118093: PUSH
118094: EMPTY
118095: LIST
118096: LIST
118097: PPUSH
118098: CALL_OW 69
118102: IN
118103: IFFALSE 118153
118105: PUSH
118106: LD_EXP 196
118110: PUSH
118111: LD_VAR 0 1
118115: ARRAY
118116: PUSH
118117: LD_VAR 0 2
118121: ARRAY
118122: PUSH
118123: LD_INT 1
118125: ARRAY
118126: PPUSH
118127: LD_EXP 196
118131: PUSH
118132: LD_VAR 0 1
118136: ARRAY
118137: PUSH
118138: LD_VAR 0 2
118142: ARRAY
118143: PUSH
118144: LD_INT 2
118146: ARRAY
118147: PPUSH
118148: CALL_OW 458
118152: AND
118153: IFFALSE 118247
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
118155: LD_EXP 196
118159: PUSH
118160: LD_VAR 0 1
118164: ARRAY
118165: PUSH
118166: LD_VAR 0 2
118170: ARRAY
118171: PUSH
118172: LD_INT 1
118174: ARRAY
118175: PPUSH
118176: LD_EXP 196
118180: PUSH
118181: LD_VAR 0 1
118185: ARRAY
118186: PUSH
118187: LD_VAR 0 2
118191: ARRAY
118192: PUSH
118193: LD_INT 2
118195: ARRAY
118196: PPUSH
118197: LD_VAR 0 3
118201: PPUSH
118202: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
118206: LD_ADDR_EXP 196
118210: PUSH
118211: LD_EXP 196
118215: PPUSH
118216: LD_VAR 0 1
118220: PPUSH
118221: LD_EXP 196
118225: PUSH
118226: LD_VAR 0 1
118230: ARRAY
118231: PPUSH
118232: LD_VAR 0 2
118236: PPUSH
118237: CALL_OW 3
118241: PPUSH
118242: CALL_OW 1
118246: ST_TO_ADDR
// end ; end ;
118247: GO 117891
118249: POP
118250: POP
// end ;
118251: GO 117762
118253: POP
118254: POP
// end ;
118255: PPOPN 4
118257: END
// export function MinerPlaceMine ( unit , x , y ) ; var index , side , i ; begin
118258: LD_INT 0
118260: PPUSH
118261: PPUSH
118262: PPUSH
118263: PPUSH
// result := false ;
118264: LD_ADDR_VAR 0 4
118268: PUSH
118269: LD_INT 0
118271: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
118272: LD_VAR 0 1
118276: PPUSH
118277: CALL_OW 264
118281: PUSH
118282: LD_INT 81
118284: EQUAL
118285: NOT
118286: IFFALSE 118290
// exit ;
118288: GO 118660
// side := GetSide ( unit ) ;
118290: LD_ADDR_VAR 0 6
118294: PUSH
118295: LD_VAR 0 1
118299: PPUSH
118300: CALL_OW 255
118304: ST_TO_ADDR
// index := GetElementIndex ( minersList , unit ) ;
118305: LD_ADDR_VAR 0 5
118309: PUSH
118310: LD_EXP 195
118314: PPUSH
118315: LD_VAR 0 1
118319: PPUSH
118320: CALL 59398 0 2
118324: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
118325: LD_EXP 196
118329: PUSH
118330: LD_VAR 0 5
118334: ARRAY
118335: PUSH
118336: LD_EXP 197
118340: GREATEREQUAL
118341: IFFALSE 118345
// exit ;
118343: GO 118660
// ComMoveXY ( unit , x , y ) ;
118345: LD_VAR 0 1
118349: PPUSH
118350: LD_VAR 0 2
118354: PPUSH
118355: LD_VAR 0 3
118359: PPUSH
118360: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
118364: LD_INT 35
118366: PPUSH
118367: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
118371: LD_VAR 0 1
118375: PPUSH
118376: LD_VAR 0 2
118380: PPUSH
118381: LD_VAR 0 3
118385: PPUSH
118386: CALL 91454 0 3
118390: NOT
118391: IFFALSE 118404
118393: PUSH
118394: LD_VAR 0 1
118398: PPUSH
118399: CALL_OW 314
118403: AND
118404: IFFALSE 118408
// exit ;
118406: GO 118660
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
118408: LD_VAR 0 2
118412: PPUSH
118413: LD_VAR 0 3
118417: PPUSH
118418: CALL_OW 428
118422: PUSH
118423: LD_VAR 0 1
118427: EQUAL
118428: IFFALSE 118442
118430: PUSH
118431: LD_VAR 0 1
118435: PPUSH
118436: CALL_OW 314
118440: NOT
118441: AND
118442: IFFALSE 118364
// if MineAtPos ( x , y ) then
118444: LD_VAR 0 2
118448: PPUSH
118449: LD_VAR 0 3
118453: PPUSH
118454: CALL_OW 458
118458: IFFALSE 118462
// exit ;
118460: GO 118660
// if your_side = side then
118462: LD_OWVAR 2
118466: PUSH
118467: LD_VAR 0 6
118471: EQUAL
118472: IFFALSE 118491
// PlaySoundXY ( x , y , PlantMine ) ;
118474: LD_VAR 0 2
118478: PPUSH
118479: LD_VAR 0 3
118483: PPUSH
118484: LD_STRING PlantMine
118486: PPUSH
118487: CALL_OW 366
// repeat wait ( 1 ) ;
118491: LD_INT 1
118493: PPUSH
118494: CALL_OW 67
// until PlaceMine ( x , y , side , 0 ) ;
118498: LD_VAR 0 2
118502: PPUSH
118503: LD_VAR 0 3
118507: PPUSH
118508: LD_VAR 0 6
118512: PPUSH
118513: LD_INT 0
118515: PPUSH
118516: CALL_OW 454
118520: IFFALSE 118491
// if MineAtPos ( x , y ) then
118522: LD_VAR 0 2
118526: PPUSH
118527: LD_VAR 0 3
118531: PPUSH
118532: CALL_OW 458
118536: IFFALSE 118652
// begin for i in minerMinesList [ index ] do
118538: LD_ADDR_VAR 0 7
118542: PUSH
118543: LD_EXP 196
118547: PUSH
118548: LD_VAR 0 5
118552: ARRAY
118553: PUSH
118554: FOR_IN
118555: IFFALSE 118597
// if i [ 1 ] = x and i [ 2 ] = y then
118557: LD_VAR 0 7
118561: PUSH
118562: LD_INT 1
118564: ARRAY
118565: PUSH
118566: LD_VAR 0 2
118570: EQUAL
118571: IFFALSE 118589
118573: PUSH
118574: LD_VAR 0 7
118578: PUSH
118579: LD_INT 2
118581: ARRAY
118582: PUSH
118583: LD_VAR 0 3
118587: EQUAL
118588: AND
118589: IFFALSE 118595
// exit ;
118591: POP
118592: POP
118593: GO 118660
118595: GO 118554
118597: POP
118598: POP
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
118599: LD_ADDR_EXP 196
118603: PUSH
118604: LD_EXP 196
118608: PPUSH
118609: LD_VAR 0 5
118613: PUSH
118614: LD_EXP 196
118618: PUSH
118619: LD_VAR 0 5
118623: ARRAY
118624: PUSH
118625: LD_INT 1
118627: PLUS
118628: PUSH
118629: EMPTY
118630: LIST
118631: LIST
118632: PPUSH
118633: LD_VAR 0 2
118637: PUSH
118638: LD_VAR 0 3
118642: PUSH
118643: EMPTY
118644: LIST
118645: LIST
118646: PPUSH
118647: CALL 59615 0 3
118651: ST_TO_ADDR
// end ; result := true ;
118652: LD_ADDR_VAR 0 4
118656: PUSH
118657: LD_INT 1
118659: ST_TO_ADDR
// end ;
118660: LD_VAR 0 4
118664: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
118665: LD_INT 0
118667: PPUSH
118668: PPUSH
118669: PPUSH
// if not unit in minersList then
118670: LD_VAR 0 1
118674: PUSH
118675: LD_EXP 195
118679: IN
118680: NOT
118681: IFFALSE 118685
// exit ;
118683: GO 118892
// index := GetElementIndex ( minersList , unit ) ;
118685: LD_ADDR_VAR 0 6
118689: PUSH
118690: LD_EXP 195
118694: PPUSH
118695: LD_VAR 0 1
118699: PPUSH
118700: CALL 59398 0 2
118704: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
118705: LD_ADDR_VAR 0 5
118709: PUSH
118710: DOUBLE
118711: LD_EXP 196
118715: PUSH
118716: LD_VAR 0 6
118720: ARRAY
118721: INC
118722: ST_TO_ADDR
118723: LD_INT 1
118725: PUSH
118726: FOR_DOWNTO
118727: IFFALSE 118890
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
118729: LD_EXP 196
118733: PUSH
118734: LD_VAR 0 6
118738: ARRAY
118739: PUSH
118740: LD_VAR 0 5
118744: ARRAY
118745: PUSH
118746: LD_INT 1
118748: ARRAY
118749: PPUSH
118750: LD_EXP 196
118754: PUSH
118755: LD_VAR 0 6
118759: ARRAY
118760: PUSH
118761: LD_VAR 0 5
118765: ARRAY
118766: PUSH
118767: LD_INT 2
118769: ARRAY
118770: PPUSH
118771: LD_VAR 0 2
118775: PPUSH
118776: LD_VAR 0 3
118780: PPUSH
118781: CALL_OW 298
118785: PUSH
118786: LD_INT 6
118788: LESS
118789: IFFALSE 118888
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
118791: LD_EXP 196
118795: PUSH
118796: LD_VAR 0 6
118800: ARRAY
118801: PUSH
118802: LD_VAR 0 5
118806: ARRAY
118807: PUSH
118808: LD_INT 1
118810: ARRAY
118811: PPUSH
118812: LD_EXP 196
118816: PUSH
118817: LD_VAR 0 6
118821: ARRAY
118822: PUSH
118823: LD_VAR 0 5
118827: ARRAY
118828: PUSH
118829: LD_INT 2
118831: ARRAY
118832: PPUSH
118833: LD_VAR 0 1
118837: PPUSH
118838: CALL_OW 255
118842: PPUSH
118843: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
118847: LD_ADDR_EXP 196
118851: PUSH
118852: LD_EXP 196
118856: PPUSH
118857: LD_VAR 0 6
118861: PPUSH
118862: LD_EXP 196
118866: PUSH
118867: LD_VAR 0 6
118871: ARRAY
118872: PPUSH
118873: LD_VAR 0 5
118877: PPUSH
118878: CALL_OW 3
118882: PPUSH
118883: CALL_OW 1
118887: ST_TO_ADDR
// end ; end ;
118888: GO 118726
118890: POP
118891: POP
// end ;
118892: LD_VAR 0 4
118896: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
118897: LD_INT 0
118899: PPUSH
118900: PPUSH
118901: PPUSH
118902: PPUSH
118903: PPUSH
118904: PPUSH
118905: PPUSH
118906: PPUSH
118907: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
118908: LD_VAR 0 1
118912: PPUSH
118913: CALL_OW 264
118917: PUSH
118918: LD_INT 81
118920: EQUAL
118921: NOT
118922: IFTRUE 118937
118924: PUSH
118925: LD_VAR 0 1
118929: PUSH
118930: LD_EXP 195
118934: IN
118935: NOT
118936: OR
118937: IFFALSE 118941
// exit ;
118939: GO 119267
// index := GetElementIndex ( minersList , unit ) ;
118941: LD_ADDR_VAR 0 6
118945: PUSH
118946: LD_EXP 195
118950: PPUSH
118951: LD_VAR 0 1
118955: PPUSH
118956: CALL 59398 0 2
118960: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
118961: LD_ADDR_VAR 0 8
118965: PUSH
118966: LD_EXP 197
118970: PUSH
118971: LD_EXP 196
118975: PUSH
118976: LD_VAR 0 6
118980: ARRAY
118981: MINUS
118982: ST_TO_ADDR
// if not minesFreeAmount then
118983: LD_VAR 0 8
118987: NOT
118988: IFFALSE 118992
// exit ;
118990: GO 119267
// tmp := [ ] ;
118992: LD_ADDR_VAR 0 7
118996: PUSH
118997: EMPTY
118998: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
118999: LD_ADDR_VAR 0 5
119003: PUSH
119004: DOUBLE
119005: LD_INT 1
119007: DEC
119008: ST_TO_ADDR
119009: LD_VAR 0 8
119013: PUSH
119014: FOR_TO
119015: IFFALSE 119214
// begin _d := rand ( 0 , 5 ) ;
119017: LD_ADDR_VAR 0 11
119021: PUSH
119022: LD_INT 0
119024: PPUSH
119025: LD_INT 5
119027: PPUSH
119028: CALL_OW 12
119032: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
119033: LD_ADDR_VAR 0 12
119037: PUSH
119038: LD_INT 2
119040: PPUSH
119041: LD_INT 6
119043: PPUSH
119044: CALL_OW 12
119048: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
119049: LD_ADDR_VAR 0 9
119053: PUSH
119054: LD_VAR 0 2
119058: PPUSH
119059: LD_VAR 0 11
119063: PPUSH
119064: LD_VAR 0 12
119068: PPUSH
119069: CALL_OW 272
119073: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
119074: LD_ADDR_VAR 0 10
119078: PUSH
119079: LD_VAR 0 3
119083: PPUSH
119084: LD_VAR 0 11
119088: PPUSH
119089: LD_VAR 0 12
119093: PPUSH
119094: CALL_OW 273
119098: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
119099: LD_VAR 0 9
119103: PPUSH
119104: LD_VAR 0 10
119108: PPUSH
119109: CALL_OW 488
119113: IFFALSE 119137
119115: PUSH
119116: LD_VAR 0 9
119120: PUSH
119121: LD_VAR 0 10
119125: PUSH
119126: EMPTY
119127: LIST
119128: LIST
119129: PUSH
119130: LD_VAR 0 7
119134: IN
119135: NOT
119136: AND
119137: IFFALSE 119156
119139: PUSH
119140: LD_VAR 0 9
119144: PPUSH
119145: LD_VAR 0 10
119149: PPUSH
119150: CALL_OW 458
119154: NOT
119155: AND
119156: IFFALSE 119198
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
119158: LD_ADDR_VAR 0 7
119162: PUSH
119163: LD_VAR 0 7
119167: PPUSH
119168: LD_VAR 0 7
119172: PUSH
119173: LD_INT 1
119175: PLUS
119176: PPUSH
119177: LD_VAR 0 9
119181: PUSH
119182: LD_VAR 0 10
119186: PUSH
119187: EMPTY
119188: LIST
119189: LIST
119190: PPUSH
119191: CALL_OW 1
119195: ST_TO_ADDR
119196: GO 119212
// i := i - 1 ;
119198: LD_ADDR_VAR 0 5
119202: PUSH
119203: LD_VAR 0 5
119207: PUSH
119208: LD_INT 1
119210: MINUS
119211: ST_TO_ADDR
// end ;
119212: GO 119014
119214: POP
119215: POP
// for i in tmp do
119216: LD_ADDR_VAR 0 5
119220: PUSH
119221: LD_VAR 0 7
119225: PUSH
119226: FOR_IN
119227: IFFALSE 119265
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
119229: LD_VAR 0 1
119233: PPUSH
119234: LD_VAR 0 5
119238: PUSH
119239: LD_INT 1
119241: ARRAY
119242: PPUSH
119243: LD_VAR 0 5
119247: PUSH
119248: LD_INT 2
119250: ARRAY
119251: PPUSH
119252: CALL 118258 0 3
119256: NOT
119257: IFFALSE 119263
// exit ;
119259: POP
119260: POP
119261: GO 119267
119263: GO 119226
119265: POP
119266: POP
// end ;
119267: LD_VAR 0 4
119271: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
119272: LD_INT 0
119274: PPUSH
119275: PPUSH
119276: PPUSH
119277: PPUSH
119278: PPUSH
119279: PPUSH
119280: PPUSH
119281: PPUSH
119282: PPUSH
// if GetClass ( unit ) <> class_sniper then
119283: LD_VAR 0 1
119287: PPUSH
119288: CALL_OW 257
119292: PUSH
119293: LD_INT 5
119295: NONEQUAL
119296: IFFALSE 119300
// exit ;
119298: GO 119770
// dist := 8 ;
119300: LD_ADDR_VAR 0 5
119304: PUSH
119305: LD_INT 8
119307: ST_TO_ADDR
// viewRange := 12 ;
119308: LD_ADDR_VAR 0 8
119312: PUSH
119313: LD_INT 12
119315: ST_TO_ADDR
// side := GetSide ( unit ) ;
119316: LD_ADDR_VAR 0 6
119320: PUSH
119321: LD_VAR 0 1
119325: PPUSH
119326: CALL_OW 255
119330: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
119331: LD_INT 61
119333: PPUSH
119334: LD_VAR 0 6
119338: PPUSH
119339: CALL_OW 321
119343: PUSH
119344: LD_INT 2
119346: EQUAL
119347: IFFALSE 119357
// viewRange := 16 ;
119349: LD_ADDR_VAR 0 8
119353: PUSH
119354: LD_INT 16
119356: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
119357: LD_VAR 0 1
119361: PPUSH
119362: LD_VAR 0 2
119366: PPUSH
119367: LD_VAR 0 3
119371: PPUSH
119372: CALL_OW 297
119376: PUSH
119377: LD_VAR 0 5
119381: GREATER
119382: IFFALSE 119461
// begin ComMoveXY ( unit , x , y ) ;
119384: LD_VAR 0 1
119388: PPUSH
119389: LD_VAR 0 2
119393: PPUSH
119394: LD_VAR 0 3
119398: PPUSH
119399: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
119403: LD_INT 35
119405: PPUSH
119406: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
119410: LD_VAR 0 1
119414: PPUSH
119415: LD_VAR 0 2
119419: PPUSH
119420: LD_VAR 0 3
119424: PPUSH
119425: CALL 91454 0 3
119429: NOT
119430: IFFALSE 119434
// exit ;
119432: GO 119770
// until GetDistUnitXY ( unit , x , y ) < dist ;
119434: LD_VAR 0 1
119438: PPUSH
119439: LD_VAR 0 2
119443: PPUSH
119444: LD_VAR 0 3
119448: PPUSH
119449: CALL_OW 297
119453: PUSH
119454: LD_VAR 0 5
119458: LESS
119459: IFFALSE 119403
// end ; ComTurnXY ( unit , x , y ) ;
119461: LD_VAR 0 1
119465: PPUSH
119466: LD_VAR 0 2
119470: PPUSH
119471: LD_VAR 0 3
119475: PPUSH
119476: CALL_OW 118
// repeat if Multiplayer then
119480: LD_OWVAR 4
119484: IFFALSE 119495
// wait ( 35 ) else
119486: LD_INT 35
119488: PPUSH
119489: CALL_OW 67
119493: GO 119502
// wait ( 5 ) ;
119495: LD_INT 5
119497: PPUSH
119498: CALL_OW 67
// _d := GetDir ( unit ) ;
119502: LD_ADDR_VAR 0 11
119506: PUSH
119507: LD_VAR 0 1
119511: PPUSH
119512: CALL_OW 254
119516: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
119517: LD_ADDR_VAR 0 7
119521: PUSH
119522: LD_VAR 0 1
119526: PPUSH
119527: CALL_OW 250
119531: PPUSH
119532: LD_VAR 0 1
119536: PPUSH
119537: CALL_OW 251
119541: PPUSH
119542: LD_VAR 0 2
119546: PPUSH
119547: LD_VAR 0 3
119551: PPUSH
119552: CALL 94090 0 4
119556: ST_TO_ADDR
// until dir = _d ;
119557: LD_VAR 0 7
119561: PUSH
119562: LD_VAR 0 11
119566: EQUAL
119567: IFFALSE 119480
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
119569: LD_ADDR_VAR 0 9
119573: PUSH
119574: LD_VAR 0 1
119578: PPUSH
119579: CALL_OW 250
119583: PPUSH
119584: LD_VAR 0 7
119588: PPUSH
119589: LD_VAR 0 5
119593: PPUSH
119594: CALL_OW 272
119598: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
119599: LD_ADDR_VAR 0 10
119603: PUSH
119604: LD_VAR 0 1
119608: PPUSH
119609: CALL_OW 251
119613: PPUSH
119614: LD_VAR 0 7
119618: PPUSH
119619: LD_VAR 0 5
119623: PPUSH
119624: CALL_OW 273
119628: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
119629: LD_VAR 0 9
119633: PPUSH
119634: LD_VAR 0 10
119638: PPUSH
119639: CALL_OW 488
119643: NOT
119644: IFFALSE 119648
// exit ;
119646: GO 119770
// ComAnimCustom ( unit , 1 ) ;
119648: LD_VAR 0 1
119652: PPUSH
119653: LD_INT 1
119655: PPUSH
119656: CALL_OW 592
// p := 0 ;
119660: LD_ADDR_VAR 0 12
119664: PUSH
119665: LD_INT 0
119667: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
119668: LD_VAR 0 9
119672: PPUSH
119673: LD_VAR 0 10
119677: PPUSH
119678: LD_VAR 0 6
119682: PPUSH
119683: LD_VAR 0 8
119687: PPUSH
119688: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
119692: LD_INT 35
119694: PPUSH
119695: CALL_OW 67
// p := Inc ( p ) ;
119699: LD_ADDR_VAR 0 12
119703: PUSH
119704: LD_VAR 0 12
119708: PPUSH
119709: CALL 94046 0 1
119713: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
119714: LD_VAR 0 12
119718: PUSH
119719: LD_INT 3
119721: EQUAL
119722: IFTRUE 119736
119724: PUSH
119725: LD_VAR 0 1
119729: PPUSH
119730: CALL_OW 302
119734: NOT
119735: OR
119736: IFTRUE 119749
119738: PUSH
119739: LD_VAR 0 1
119743: PPUSH
119744: CALL_OW 301
119748: OR
119749: IFFALSE 119692
// RemoveSeeing ( _x , _y , side ) ;
119751: LD_VAR 0 9
119755: PPUSH
119756: LD_VAR 0 10
119760: PPUSH
119761: LD_VAR 0 6
119765: PPUSH
119766: CALL_OW 331
// end ;
119770: LD_VAR 0 4
119774: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
119775: LD_INT 0
119777: PPUSH
119778: PPUSH
119779: PPUSH
119780: PPUSH
119781: PPUSH
119782: PPUSH
119783: PPUSH
119784: PPUSH
119785: PPUSH
119786: PPUSH
119787: PPUSH
// if not unit then
119788: LD_VAR 0 1
119792: NOT
119793: IFFALSE 119797
// exit ;
119795: GO 120068
// side := GetSide ( unit ) ;
119797: LD_ADDR_VAR 0 3
119801: PUSH
119802: LD_VAR 0 1
119806: PPUSH
119807: CALL_OW 255
119811: ST_TO_ADDR
// x := GetX ( unit ) ;
119812: LD_ADDR_VAR 0 5
119816: PUSH
119817: LD_VAR 0 1
119821: PPUSH
119822: CALL_OW 250
119826: ST_TO_ADDR
// y := GetY ( unit ) ;
119827: LD_ADDR_VAR 0 6
119831: PUSH
119832: LD_VAR 0 1
119836: PPUSH
119837: CALL_OW 251
119841: ST_TO_ADDR
// r := 8 ;
119842: LD_ADDR_VAR 0 4
119846: PUSH
119847: LD_INT 8
119849: ST_TO_ADDR
// if x - r < 0 then
119850: LD_VAR 0 5
119854: PUSH
119855: LD_VAR 0 4
119859: MINUS
119860: PUSH
119861: LD_INT 0
119863: LESS
119864: IFFALSE 119876
// min_x := 0 else
119866: LD_ADDR_VAR 0 7
119870: PUSH
119871: LD_INT 0
119873: ST_TO_ADDR
119874: GO 119892
// min_x := x - r ;
119876: LD_ADDR_VAR 0 7
119880: PUSH
119881: LD_VAR 0 5
119885: PUSH
119886: LD_VAR 0 4
119890: MINUS
119891: ST_TO_ADDR
// if y - r < 0 then
119892: LD_VAR 0 6
119896: PUSH
119897: LD_VAR 0 4
119901: MINUS
119902: PUSH
119903: LD_INT 0
119905: LESS
119906: IFFALSE 119918
// min_y := 0 else
119908: LD_ADDR_VAR 0 8
119912: PUSH
119913: LD_INT 0
119915: ST_TO_ADDR
119916: GO 119934
// min_y := y - r ;
119918: LD_ADDR_VAR 0 8
119922: PUSH
119923: LD_VAR 0 6
119927: PUSH
119928: LD_VAR 0 4
119932: MINUS
119933: ST_TO_ADDR
// max_x := x + r ;
119934: LD_ADDR_VAR 0 9
119938: PUSH
119939: LD_VAR 0 5
119943: PUSH
119944: LD_VAR 0 4
119948: PLUS
119949: ST_TO_ADDR
// max_y := y + r ;
119950: LD_ADDR_VAR 0 10
119954: PUSH
119955: LD_VAR 0 6
119959: PUSH
119960: LD_VAR 0 4
119964: PLUS
119965: ST_TO_ADDR
// for _x = min_x to max_x do
119966: LD_ADDR_VAR 0 11
119970: PUSH
119971: DOUBLE
119972: LD_VAR 0 7
119976: DEC
119977: ST_TO_ADDR
119978: LD_VAR 0 9
119982: PUSH
119983: FOR_TO
119984: IFFALSE 120066
// for _y = min_y to max_y do
119986: LD_ADDR_VAR 0 12
119990: PUSH
119991: DOUBLE
119992: LD_VAR 0 8
119996: DEC
119997: ST_TO_ADDR
119998: LD_VAR 0 10
120002: PUSH
120003: FOR_TO
120004: IFFALSE 120062
// begin if not ValidHex ( _x , _y ) then
120006: LD_VAR 0 11
120010: PPUSH
120011: LD_VAR 0 12
120015: PPUSH
120016: CALL_OW 488
120020: NOT
120021: IFFALSE 120025
// continue ;
120023: GO 120003
// if MineAtPos ( _x , _y ) then
120025: LD_VAR 0 11
120029: PPUSH
120030: LD_VAR 0 12
120034: PPUSH
120035: CALL_OW 458
120039: IFFALSE 120060
// ViewMineAtPos ( _x , _y , side ) ;
120041: LD_VAR 0 11
120045: PPUSH
120046: LD_VAR 0 12
120050: PPUSH
120051: LD_VAR 0 3
120055: PPUSH
120056: CALL_OW 457
// end ;
120060: GO 120003
120062: POP
120063: POP
120064: GO 119983
120066: POP
120067: POP
// end ;
120068: LD_VAR 0 2
120072: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer , side ; begin
120073: LD_INT 0
120075: PPUSH
120076: PPUSH
120077: PPUSH
120078: PPUSH
120079: PPUSH
120080: PPUSH
120081: PPUSH
// if not units then
120082: LD_VAR 0 1
120086: NOT
120087: IFFALSE 120091
// exit ;
120089: GO 120555
// scaners := [ ] ;
120091: LD_ADDR_VAR 0 6
120095: PUSH
120096: EMPTY
120097: ST_TO_ADDR
// for i in units do
120098: LD_ADDR_VAR 0 3
120102: PUSH
120103: LD_VAR 0 1
120107: PUSH
120108: FOR_IN
120109: IFFALSE 120266
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
120111: LD_VAR 0 3
120115: PPUSH
120116: CALL_OW 264
120120: PUSH
120121: LD_INT 11
120123: NONEQUAL
120124: IFTRUE 120138
120126: PUSH
120127: LD_VAR 0 3
120131: PPUSH
120132: CALL_OW 302
120136: NOT
120137: OR
120138: IFTRUE 120155
120140: PUSH
120141: LD_VAR 0 3
120145: PPUSH
120146: CALL_OW 110
120150: PUSH
120151: LD_INT 502
120153: EQUAL
120154: OR
120155: IFFALSE 120159
// continue ;
120157: GO 120108
// ComStop ( i ) ;
120159: LD_VAR 0 3
120163: PPUSH
120164: CALL_OW 141
// x := GetX ( i ) ;
120168: LD_ADDR_VAR 0 4
120172: PUSH
120173: LD_VAR 0 3
120177: PPUSH
120178: CALL_OW 250
120182: ST_TO_ADDR
// y := GetY ( i ) ;
120183: LD_ADDR_VAR 0 5
120187: PUSH
120188: LD_VAR 0 3
120192: PPUSH
120193: CALL_OW 251
120197: ST_TO_ADDR
// if GetSide ( i ) = your_side then
120198: LD_VAR 0 3
120202: PPUSH
120203: CALL_OW 255
120207: PUSH
120208: LD_OWVAR 2
120212: EQUAL
120213: IFFALSE 120232
// PlaySoundXY ( x , y , mineDetector ) ;
120215: LD_VAR 0 4
120219: PPUSH
120220: LD_VAR 0 5
120224: PPUSH
120225: LD_STRING mineDetector
120227: PPUSH
120228: CALL_OW 366
// scaners := Join ( scaners , i ) ;
120232: LD_ADDR_VAR 0 6
120236: PUSH
120237: LD_VAR 0 6
120241: PPUSH
120242: LD_VAR 0 3
120246: PPUSH
120247: CALL 92673 0 2
120251: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
120252: LD_VAR 0 3
120256: PPUSH
120257: LD_INT 502
120259: PPUSH
120260: CALL_OW 109
// end ;
120264: GO 120108
120266: POP
120267: POP
// if not scaners then
120268: LD_VAR 0 6
120272: NOT
120273: IFFALSE 120277
// exit ;
120275: GO 120555
// wait ( 3 ) ;
120277: LD_INT 3
120279: PPUSH
120280: CALL_OW 67
// timer := 6 ;
120284: LD_ADDR_VAR 0 7
120288: PUSH
120289: LD_INT 6
120291: ST_TO_ADDR
// repeat for i in scaners do
120292: LD_ADDR_VAR 0 3
120296: PUSH
120297: LD_VAR 0 6
120301: PUSH
120302: FOR_IN
120303: IFFALSE 120453
// begin side := GetSide ( i ) ;
120305: LD_ADDR_VAR 0 8
120309: PUSH
120310: LD_VAR 0 3
120314: PPUSH
120315: CALL_OW 255
120319: ST_TO_ADDR
// if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
120320: LD_VAR 0 3
120324: PPUSH
120325: CALL_OW 302
120329: NOT
120330: IFTRUE 120343
120332: PUSH
120333: LD_VAR 0 3
120337: PPUSH
120338: CALL_OW 314
120342: OR
120343: IFTRUE 120374
120345: PUSH
120346: LD_VAR 0 3
120350: PPUSH
120351: CALL_OW 263
120355: PUSH
120356: LD_INT 1
120358: EQUAL
120359: IFFALSE 120373
120361: PUSH
120362: LD_VAR 0 3
120366: PPUSH
120367: CALL_OW 311
120371: NOT
120372: AND
120373: OR
120374: IFFALSE 120418
// begin SetUnitDisplayNumber ( i , 0 ) ;
120376: LD_VAR 0 3
120380: PPUSH
120381: LD_INT 0
120383: PPUSH
120384: CALL_OW 505
// SetTag ( i , 0 ) ;
120388: LD_VAR 0 3
120392: PPUSH
120393: LD_INT 0
120395: PPUSH
120396: CALL_OW 109
// scaners := scaners diff i ;
120400: LD_ADDR_VAR 0 6
120404: PUSH
120405: LD_VAR 0 6
120409: PUSH
120410: LD_VAR 0 3
120414: DIFF
120415: ST_TO_ADDR
// continue ;
120416: GO 120302
// end ; if side in [ your_side , 9 ] then
120418: LD_VAR 0 8
120422: PUSH
120423: LD_OWVAR 2
120427: PUSH
120428: LD_INT 9
120430: PUSH
120431: EMPTY
120432: LIST
120433: LIST
120434: IN
120435: IFFALSE 120451
// SetUnitDisplayNumber ( i , timer ) ;
120437: LD_VAR 0 3
120441: PPUSH
120442: LD_VAR 0 7
120446: PPUSH
120447: CALL_OW 505
// end ;
120451: GO 120302
120453: POP
120454: POP
// if not scaners then
120455: LD_VAR 0 6
120459: NOT
120460: IFFALSE 120464
// exit ;
120462: GO 120555
// timer := Dec ( timer ) ;
120464: LD_ADDR_VAR 0 7
120468: PUSH
120469: LD_VAR 0 7
120473: PPUSH
120474: CALL 94068 0 1
120478: ST_TO_ADDR
// wait ( 0 0$1 ) ;
120479: LD_INT 35
120481: PPUSH
120482: CALL_OW 67
// until timer = 0 ;
120486: LD_VAR 0 7
120490: PUSH
120491: LD_INT 0
120493: EQUAL
120494: IFFALSE 120292
// if not scaners then
120496: LD_VAR 0 6
120500: NOT
120501: IFFALSE 120505
// exit ;
120503: GO 120555
// for i in scaners do
120505: LD_ADDR_VAR 0 3
120509: PUSH
120510: LD_VAR 0 6
120514: PUSH
120515: FOR_IN
120516: IFFALSE 120553
// begin SetUnitDisplayNumber ( i , 0 ) ;
120518: LD_VAR 0 3
120522: PPUSH
120523: LD_INT 0
120525: PPUSH
120526: CALL_OW 505
// SetTag ( i , 0 ) ;
120530: LD_VAR 0 3
120534: PPUSH
120535: LD_INT 0
120537: PPUSH
120538: CALL_OW 109
// RevealDetectorMine ( i ) ;
120542: LD_VAR 0 3
120546: PPUSH
120547: CALL 119775 0 1
// end ;
120551: GO 120515
120553: POP
120554: POP
// end ;
120555: LD_VAR 0 2
120559: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
120560: LD_INT 0
120562: PPUSH
// if p1 = mine_detector_mode then
120563: LD_VAR 0 2
120567: PUSH
120568: LD_INT 103
120570: EQUAL
120571: IFFALSE 120582
// DetectMine ( units ) ;
120573: LD_VAR 0 1
120577: PPUSH
120578: CALL 120073 0 1
// end ; end_of_file
120582: LD_VAR 0 7
120586: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
120587: LD_INT 0
120589: PPUSH
120590: PPUSH
120591: PPUSH
120592: PPUSH
120593: PPUSH
120594: PPUSH
120595: PPUSH
120596: PPUSH
120597: PPUSH
120598: PPUSH
120599: PPUSH
120600: PPUSH
120601: PPUSH
120602: PPUSH
120603: PPUSH
120604: PPUSH
120605: PPUSH
120606: PPUSH
120607: PPUSH
120608: PPUSH
120609: PPUSH
120610: PPUSH
120611: PPUSH
120612: PPUSH
120613: PPUSH
120614: PPUSH
120615: PPUSH
120616: PPUSH
120617: PPUSH
120618: PPUSH
120619: PPUSH
120620: PPUSH
120621: PPUSH
120622: PPUSH
// if not list then
120623: LD_VAR 0 1
120627: NOT
120628: IFFALSE 120632
// exit ;
120630: GO 125351
// base := list [ 1 ] ;
120632: LD_ADDR_VAR 0 3
120636: PUSH
120637: LD_VAR 0 1
120641: PUSH
120642: LD_INT 1
120644: ARRAY
120645: ST_TO_ADDR
// group := list [ 2 ] ;
120646: LD_ADDR_VAR 0 4
120650: PUSH
120651: LD_VAR 0 1
120655: PUSH
120656: LD_INT 2
120658: ARRAY
120659: ST_TO_ADDR
// path := list [ 3 ] ;
120660: LD_ADDR_VAR 0 5
120664: PUSH
120665: LD_VAR 0 1
120669: PUSH
120670: LD_INT 3
120672: ARRAY
120673: ST_TO_ADDR
// flags := list [ 4 ] ;
120674: LD_ADDR_VAR 0 6
120678: PUSH
120679: LD_VAR 0 1
120683: PUSH
120684: LD_INT 4
120686: ARRAY
120687: ST_TO_ADDR
// mined := [ ] ;
120688: LD_ADDR_VAR 0 27
120692: PUSH
120693: EMPTY
120694: ST_TO_ADDR
// bombed := [ ] ;
120695: LD_ADDR_VAR 0 28
120699: PUSH
120700: EMPTY
120701: ST_TO_ADDR
// healers := [ ] ;
120702: LD_ADDR_VAR 0 31
120706: PUSH
120707: EMPTY
120708: ST_TO_ADDR
// to_heal := [ ] ;
120709: LD_ADDR_VAR 0 30
120713: PUSH
120714: EMPTY
120715: ST_TO_ADDR
// repairs := [ ] ;
120716: LD_ADDR_VAR 0 33
120720: PUSH
120721: EMPTY
120722: ST_TO_ADDR
// to_repair := [ ] ;
120723: LD_ADDR_VAR 0 32
120727: PUSH
120728: EMPTY
120729: ST_TO_ADDR
// if not group or not path then
120730: LD_VAR 0 4
120734: NOT
120735: IFTRUE 120744
120737: PUSH
120738: LD_VAR 0 5
120742: NOT
120743: OR
120744: IFFALSE 120748
// exit ;
120746: GO 125351
// side := GetSide ( group [ 1 ] ) ;
120748: LD_ADDR_VAR 0 35
120752: PUSH
120753: LD_VAR 0 4
120757: PUSH
120758: LD_INT 1
120760: ARRAY
120761: PPUSH
120762: CALL_OW 255
120766: ST_TO_ADDR
// if flags then
120767: LD_VAR 0 6
120771: IFFALSE 120915
// begin f_ignore_area := flags [ 1 ] ;
120773: LD_ADDR_VAR 0 17
120777: PUSH
120778: LD_VAR 0 6
120782: PUSH
120783: LD_INT 1
120785: ARRAY
120786: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
120787: LD_ADDR_VAR 0 18
120791: PUSH
120792: LD_VAR 0 6
120796: PUSH
120797: LD_INT 2
120799: ARRAY
120800: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
120801: LD_ADDR_VAR 0 19
120805: PUSH
120806: LD_VAR 0 6
120810: PUSH
120811: LD_INT 3
120813: ARRAY
120814: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
120815: LD_ADDR_VAR 0 20
120819: PUSH
120820: LD_VAR 0 6
120824: PUSH
120825: LD_INT 4
120827: ARRAY
120828: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
120829: LD_ADDR_VAR 0 21
120833: PUSH
120834: LD_VAR 0 6
120838: PUSH
120839: LD_INT 5
120841: ARRAY
120842: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
120843: LD_ADDR_VAR 0 22
120847: PUSH
120848: LD_VAR 0 6
120852: PUSH
120853: LD_INT 6
120855: ARRAY
120856: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
120857: LD_ADDR_VAR 0 23
120861: PUSH
120862: LD_VAR 0 6
120866: PUSH
120867: LD_INT 7
120869: ARRAY
120870: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
120871: LD_ADDR_VAR 0 24
120875: PUSH
120876: LD_VAR 0 6
120880: PUSH
120881: LD_INT 8
120883: ARRAY
120884: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
120885: LD_ADDR_VAR 0 25
120889: PUSH
120890: LD_VAR 0 6
120894: PUSH
120895: LD_INT 9
120897: ARRAY
120898: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
120899: LD_ADDR_VAR 0 26
120903: PUSH
120904: LD_VAR 0 6
120908: PUSH
120909: LD_INT 10
120911: ARRAY
120912: ST_TO_ADDR
// end else
120913: GO 120995
// begin f_ignore_area := false ;
120915: LD_ADDR_VAR 0 17
120919: PUSH
120920: LD_INT 0
120922: ST_TO_ADDR
// f_capture := false ;
120923: LD_ADDR_VAR 0 18
120927: PUSH
120928: LD_INT 0
120930: ST_TO_ADDR
// f_ignore_civ := false ;
120931: LD_ADDR_VAR 0 19
120935: PUSH
120936: LD_INT 0
120938: ST_TO_ADDR
// f_murder := false ;
120939: LD_ADDR_VAR 0 20
120943: PUSH
120944: LD_INT 0
120946: ST_TO_ADDR
// f_mines := false ;
120947: LD_ADDR_VAR 0 21
120951: PUSH
120952: LD_INT 0
120954: ST_TO_ADDR
// f_repair := false ;
120955: LD_ADDR_VAR 0 22
120959: PUSH
120960: LD_INT 0
120962: ST_TO_ADDR
// f_heal := false ;
120963: LD_ADDR_VAR 0 23
120967: PUSH
120968: LD_INT 0
120970: ST_TO_ADDR
// f_spacetime := false ;
120971: LD_ADDR_VAR 0 24
120975: PUSH
120976: LD_INT 0
120978: ST_TO_ADDR
// f_attack_depot := false ;
120979: LD_ADDR_VAR 0 25
120983: PUSH
120984: LD_INT 0
120986: ST_TO_ADDR
// f_crawl := false ;
120987: LD_ADDR_VAR 0 26
120991: PUSH
120992: LD_INT 0
120994: ST_TO_ADDR
// end ; if f_heal then
120995: LD_VAR 0 23
120999: IFFALSE 121026
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
121001: LD_ADDR_VAR 0 31
121005: PUSH
121006: LD_VAR 0 4
121010: PPUSH
121011: LD_INT 25
121013: PUSH
121014: LD_INT 4
121016: PUSH
121017: EMPTY
121018: LIST
121019: LIST
121020: PPUSH
121021: CALL_OW 72
121025: ST_TO_ADDR
// if f_repair then
121026: LD_VAR 0 22
121030: IFFALSE 121057
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
121032: LD_ADDR_VAR 0 33
121036: PUSH
121037: LD_VAR 0 4
121041: PPUSH
121042: LD_INT 25
121044: PUSH
121045: LD_INT 3
121047: PUSH
121048: EMPTY
121049: LIST
121050: LIST
121051: PPUSH
121052: CALL_OW 72
121056: ST_TO_ADDR
// units_path := [ ] ;
121057: LD_ADDR_VAR 0 16
121061: PUSH
121062: EMPTY
121063: ST_TO_ADDR
// for i = 1 to group do
121064: LD_ADDR_VAR 0 7
121068: PUSH
121069: DOUBLE
121070: LD_INT 1
121072: DEC
121073: ST_TO_ADDR
121074: LD_VAR 0 4
121078: PUSH
121079: FOR_TO
121080: IFFALSE 121109
// units_path := Replace ( units_path , i , path ) ;
121082: LD_ADDR_VAR 0 16
121086: PUSH
121087: LD_VAR 0 16
121091: PPUSH
121092: LD_VAR 0 7
121096: PPUSH
121097: LD_VAR 0 5
121101: PPUSH
121102: CALL_OW 1
121106: ST_TO_ADDR
121107: GO 121079
121109: POP
121110: POP
// repeat for i = group downto 1 do
121111: LD_ADDR_VAR 0 7
121115: PUSH
121116: DOUBLE
121117: LD_VAR 0 4
121121: INC
121122: ST_TO_ADDR
121123: LD_INT 1
121125: PUSH
121126: FOR_DOWNTO
121127: IFFALSE 125303
// begin wait ( 5 ) ;
121129: LD_INT 5
121131: PPUSH
121132: CALL_OW 67
// tmp := [ ] ;
121136: LD_ADDR_VAR 0 14
121140: PUSH
121141: EMPTY
121142: ST_TO_ADDR
// attacking := false ;
121143: LD_ADDR_VAR 0 29
121147: PUSH
121148: LD_INT 0
121150: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
121151: LD_VAR 0 4
121155: PUSH
121156: LD_VAR 0 7
121160: ARRAY
121161: PPUSH
121162: CALL_OW 301
121166: IFTRUE 121181
121168: PUSH
121169: LD_VAR 0 4
121173: PUSH
121174: LD_VAR 0 7
121178: ARRAY
121179: NOT
121180: OR
121181: IFFALSE 121290
// begin if GetType ( group [ i ] ) = unit_human then
121183: LD_VAR 0 4
121187: PUSH
121188: LD_VAR 0 7
121192: ARRAY
121193: PPUSH
121194: CALL_OW 247
121198: PUSH
121199: LD_INT 1
121201: EQUAL
121202: IFFALSE 121248
// begin to_heal := to_heal diff group [ i ] ;
121204: LD_ADDR_VAR 0 30
121208: PUSH
121209: LD_VAR 0 30
121213: PUSH
121214: LD_VAR 0 4
121218: PUSH
121219: LD_VAR 0 7
121223: ARRAY
121224: DIFF
121225: ST_TO_ADDR
// healers := healers diff group [ i ] ;
121226: LD_ADDR_VAR 0 31
121230: PUSH
121231: LD_VAR 0 31
121235: PUSH
121236: LD_VAR 0 4
121240: PUSH
121241: LD_VAR 0 7
121245: ARRAY
121246: DIFF
121247: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
121248: LD_ADDR_VAR 0 4
121252: PUSH
121253: LD_VAR 0 4
121257: PPUSH
121258: LD_VAR 0 7
121262: PPUSH
121263: CALL_OW 3
121267: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
121268: LD_ADDR_VAR 0 16
121272: PUSH
121273: LD_VAR 0 16
121277: PPUSH
121278: LD_VAR 0 7
121282: PPUSH
121283: CALL_OW 3
121287: ST_TO_ADDR
// continue ;
121288: GO 121126
// end ; if f_repair then
121290: LD_VAR 0 22
121294: IFFALSE 121791
// begin if GetType ( group [ i ] ) = unit_vehicle then
121296: LD_VAR 0 4
121300: PUSH
121301: LD_VAR 0 7
121305: ARRAY
121306: PPUSH
121307: CALL_OW 247
121311: PUSH
121312: LD_INT 2
121314: EQUAL
121315: IFFALSE 121509
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
121317: LD_VAR 0 4
121321: PUSH
121322: LD_VAR 0 7
121326: ARRAY
121327: PPUSH
121328: CALL_OW 256
121332: PUSH
121333: LD_INT 700
121335: LESS
121336: IFFALSE 121357
121338: PUSH
121339: LD_VAR 0 4
121343: PUSH
121344: LD_VAR 0 7
121348: ARRAY
121349: PUSH
121350: LD_VAR 0 32
121354: IN
121355: NOT
121356: AND
121357: IFFALSE 121381
// to_repair := to_repair union group [ i ] ;
121359: LD_ADDR_VAR 0 32
121363: PUSH
121364: LD_VAR 0 32
121368: PUSH
121369: LD_VAR 0 4
121373: PUSH
121374: LD_VAR 0 7
121378: ARRAY
121379: UNION
121380: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
121381: LD_VAR 0 4
121385: PUSH
121386: LD_VAR 0 7
121390: ARRAY
121391: PPUSH
121392: CALL_OW 256
121396: PUSH
121397: LD_INT 1000
121399: EQUAL
121400: IFFALSE 121420
121402: PUSH
121403: LD_VAR 0 4
121407: PUSH
121408: LD_VAR 0 7
121412: ARRAY
121413: PUSH
121414: LD_VAR 0 32
121418: IN
121419: AND
121420: IFFALSE 121444
// to_repair := to_repair diff group [ i ] ;
121422: LD_ADDR_VAR 0 32
121426: PUSH
121427: LD_VAR 0 32
121431: PUSH
121432: LD_VAR 0 4
121436: PUSH
121437: LD_VAR 0 7
121441: ARRAY
121442: DIFF
121443: ST_TO_ADDR
// if group [ i ] in to_repair then
121444: LD_VAR 0 4
121448: PUSH
121449: LD_VAR 0 7
121453: ARRAY
121454: PUSH
121455: LD_VAR 0 32
121459: IN
121460: IFFALSE 121507
// begin if not IsInArea ( group [ i ] , f_repair ) then
121462: LD_VAR 0 4
121466: PUSH
121467: LD_VAR 0 7
121471: ARRAY
121472: PPUSH
121473: LD_VAR 0 22
121477: PPUSH
121478: CALL_OW 308
121482: NOT
121483: IFFALSE 121505
// ComMoveToArea ( group [ i ] , f_repair ) ;
121485: LD_VAR 0 4
121489: PUSH
121490: LD_VAR 0 7
121494: ARRAY
121495: PPUSH
121496: LD_VAR 0 22
121500: PPUSH
121501: CALL_OW 113
// continue ;
121505: GO 121126
// end ; end else
121507: GO 121791
// if group [ i ] in repairs then
121509: LD_VAR 0 4
121513: PUSH
121514: LD_VAR 0 7
121518: ARRAY
121519: PUSH
121520: LD_VAR 0 33
121524: IN
121525: IFFALSE 121791
// begin if IsInUnit ( group [ i ] ) then
121527: LD_VAR 0 4
121531: PUSH
121532: LD_VAR 0 7
121536: ARRAY
121537: PPUSH
121538: CALL_OW 310
121542: IFFALSE 121612
// begin z := IsInUnit ( group [ i ] ) ;
121544: LD_ADDR_VAR 0 13
121548: PUSH
121549: LD_VAR 0 4
121553: PUSH
121554: LD_VAR 0 7
121558: ARRAY
121559: PPUSH
121560: CALL_OW 310
121564: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
121565: LD_VAR 0 13
121569: PUSH
121570: LD_VAR 0 32
121574: IN
121575: IFFALSE 121593
121577: PUSH
121578: LD_VAR 0 13
121582: PPUSH
121583: LD_VAR 0 22
121587: PPUSH
121588: CALL_OW 308
121592: AND
121593: IFFALSE 121610
// ComExitVehicle ( group [ i ] ) ;
121595: LD_VAR 0 4
121599: PUSH
121600: LD_VAR 0 7
121604: ARRAY
121605: PPUSH
121606: CALL_OW 121
// end else
121610: GO 121791
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
121612: LD_ADDR_VAR 0 13
121616: PUSH
121617: LD_VAR 0 4
121621: PPUSH
121622: LD_INT 95
121624: PUSH
121625: LD_VAR 0 22
121629: PUSH
121630: EMPTY
121631: LIST
121632: LIST
121633: PUSH
121634: LD_INT 58
121636: PUSH
121637: EMPTY
121638: LIST
121639: PUSH
121640: EMPTY
121641: LIST
121642: LIST
121643: PPUSH
121644: CALL_OW 72
121648: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
121649: LD_VAR 0 4
121653: PUSH
121654: LD_VAR 0 7
121658: ARRAY
121659: PPUSH
121660: CALL_OW 314
121664: NOT
121665: IFFALSE 121789
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
121667: LD_ADDR_VAR 0 10
121671: PUSH
121672: LD_VAR 0 13
121676: PPUSH
121677: LD_VAR 0 4
121681: PUSH
121682: LD_VAR 0 7
121686: ARRAY
121687: PPUSH
121688: CALL_OW 74
121692: ST_TO_ADDR
// if not x then
121693: LD_VAR 0 10
121697: NOT
121698: IFFALSE 121702
// continue ;
121700: GO 121126
// if GetLives ( x ) < 1000 then
121702: LD_VAR 0 10
121706: PPUSH
121707: CALL_OW 256
121711: PUSH
121712: LD_INT 1000
121714: LESS
121715: IFFALSE 121739
// ComRepairVehicle ( group [ i ] , x ) else
121717: LD_VAR 0 4
121721: PUSH
121722: LD_VAR 0 7
121726: ARRAY
121727: PPUSH
121728: LD_VAR 0 10
121732: PPUSH
121733: CALL_OW 129
121737: GO 121789
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
121739: LD_VAR 0 23
121743: IFFALSE 121766
121745: PUSH
121746: LD_VAR 0 4
121750: PUSH
121751: LD_VAR 0 7
121755: ARRAY
121756: PPUSH
121757: CALL_OW 256
121761: PUSH
121762: LD_INT 1000
121764: LESS
121765: AND
121766: NOT
121767: IFFALSE 121789
// ComEnterUnit ( group [ i ] , x ) ;
121769: LD_VAR 0 4
121773: PUSH
121774: LD_VAR 0 7
121778: ARRAY
121779: PPUSH
121780: LD_VAR 0 10
121784: PPUSH
121785: CALL_OW 120
// end ; continue ;
121789: GO 121126
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
121791: LD_VAR 0 23
121795: IFFALSE 121818
121797: PUSH
121798: LD_VAR 0 4
121802: PUSH
121803: LD_VAR 0 7
121807: ARRAY
121808: PPUSH
121809: CALL_OW 247
121813: PUSH
121814: LD_INT 1
121816: EQUAL
121817: AND
121818: IFFALSE 122302
// begin if group [ i ] in healers then
121820: LD_VAR 0 4
121824: PUSH
121825: LD_VAR 0 7
121829: ARRAY
121830: PUSH
121831: LD_VAR 0 31
121835: IN
121836: IFFALSE 122113
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
121838: LD_VAR 0 4
121842: PUSH
121843: LD_VAR 0 7
121847: ARRAY
121848: PPUSH
121849: LD_VAR 0 23
121853: PPUSH
121854: CALL_OW 308
121858: NOT
121859: IFFALSE 121879
121861: PUSH
121862: LD_VAR 0 4
121866: PUSH
121867: LD_VAR 0 7
121871: ARRAY
121872: PPUSH
121873: CALL_OW 314
121877: NOT
121878: AND
121879: IFFALSE 121903
// ComMoveToArea ( group [ i ] , f_heal ) else
121881: LD_VAR 0 4
121885: PUSH
121886: LD_VAR 0 7
121890: ARRAY
121891: PPUSH
121892: LD_VAR 0 23
121896: PPUSH
121897: CALL_OW 113
121901: GO 122111
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
121903: LD_VAR 0 4
121907: PUSH
121908: LD_VAR 0 7
121912: ARRAY
121913: PPUSH
121914: CALL 90029 0 1
121918: PPUSH
121919: CALL_OW 256
121923: PUSH
121924: LD_INT 1000
121926: EQUAL
121927: IFFALSE 121946
// ComStop ( group [ i ] ) else
121929: LD_VAR 0 4
121933: PUSH
121934: LD_VAR 0 7
121938: ARRAY
121939: PPUSH
121940: CALL_OW 141
121944: GO 122111
// if not HasTask ( group [ i ] ) and to_heal then
121946: LD_VAR 0 4
121950: PUSH
121951: LD_VAR 0 7
121955: ARRAY
121956: PPUSH
121957: CALL_OW 314
121961: NOT
121962: IFFALSE 121970
121964: PUSH
121965: LD_VAR 0 30
121969: AND
121970: IFFALSE 122111
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
121972: LD_ADDR_VAR 0 13
121976: PUSH
121977: LD_VAR 0 30
121981: PPUSH
121982: LD_INT 3
121984: PUSH
121985: LD_INT 54
121987: PUSH
121988: EMPTY
121989: LIST
121990: PUSH
121991: EMPTY
121992: LIST
121993: LIST
121994: PPUSH
121995: CALL_OW 72
121999: PPUSH
122000: LD_VAR 0 4
122004: PUSH
122005: LD_VAR 0 7
122009: ARRAY
122010: PPUSH
122011: CALL_OW 74
122015: ST_TO_ADDR
// if z then
122016: LD_VAR 0 13
122020: IFFALSE 122111
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
122022: LD_INT 91
122024: PUSH
122025: LD_VAR 0 13
122029: PUSH
122030: LD_INT 10
122032: PUSH
122033: EMPTY
122034: LIST
122035: LIST
122036: LIST
122037: PUSH
122038: LD_INT 81
122040: PUSH
122041: LD_VAR 0 13
122045: PPUSH
122046: CALL_OW 255
122050: PUSH
122051: EMPTY
122052: LIST
122053: LIST
122054: PUSH
122055: EMPTY
122056: LIST
122057: LIST
122058: PPUSH
122059: CALL_OW 69
122063: PUSH
122064: LD_INT 0
122066: EQUAL
122067: IFFALSE 122091
// ComHeal ( group [ i ] , z ) else
122069: LD_VAR 0 4
122073: PUSH
122074: LD_VAR 0 7
122078: ARRAY
122079: PPUSH
122080: LD_VAR 0 13
122084: PPUSH
122085: CALL_OW 128
122089: GO 122111
// ComMoveToArea ( group [ i ] , f_heal ) ;
122091: LD_VAR 0 4
122095: PUSH
122096: LD_VAR 0 7
122100: ARRAY
122101: PPUSH
122102: LD_VAR 0 23
122106: PPUSH
122107: CALL_OW 113
// end ; continue ;
122111: GO 121126
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
122113: LD_VAR 0 4
122117: PUSH
122118: LD_VAR 0 7
122122: ARRAY
122123: PPUSH
122124: CALL_OW 256
122128: PUSH
122129: LD_INT 700
122131: LESS
122132: IFFALSE 122153
122134: PUSH
122135: LD_VAR 0 4
122139: PUSH
122140: LD_VAR 0 7
122144: ARRAY
122145: PUSH
122146: LD_VAR 0 30
122150: IN
122151: NOT
122152: AND
122153: IFFALSE 122177
// to_heal := to_heal union group [ i ] ;
122155: LD_ADDR_VAR 0 30
122159: PUSH
122160: LD_VAR 0 30
122164: PUSH
122165: LD_VAR 0 4
122169: PUSH
122170: LD_VAR 0 7
122174: ARRAY
122175: UNION
122176: ST_TO_ADDR
// if group [ i ] in to_heal then
122177: LD_VAR 0 4
122181: PUSH
122182: LD_VAR 0 7
122186: ARRAY
122187: PUSH
122188: LD_VAR 0 30
122192: IN
122193: IFFALSE 122302
// begin if GetLives ( group [ i ] ) = 1000 then
122195: LD_VAR 0 4
122199: PUSH
122200: LD_VAR 0 7
122204: ARRAY
122205: PPUSH
122206: CALL_OW 256
122210: PUSH
122211: LD_INT 1000
122213: EQUAL
122214: IFFALSE 122240
// to_heal := to_heal diff group [ i ] else
122216: LD_ADDR_VAR 0 30
122220: PUSH
122221: LD_VAR 0 30
122225: PUSH
122226: LD_VAR 0 4
122230: PUSH
122231: LD_VAR 0 7
122235: ARRAY
122236: DIFF
122237: ST_TO_ADDR
122238: GO 122302
// begin if not IsInArea ( group [ i ] , to_heal ) then
122240: LD_VAR 0 4
122244: PUSH
122245: LD_VAR 0 7
122249: ARRAY
122250: PPUSH
122251: LD_VAR 0 30
122255: PPUSH
122256: CALL_OW 308
122260: NOT
122261: IFFALSE 122285
// ComMoveToArea ( group [ i ] , f_heal ) else
122263: LD_VAR 0 4
122267: PUSH
122268: LD_VAR 0 7
122272: ARRAY
122273: PPUSH
122274: LD_VAR 0 23
122278: PPUSH
122279: CALL_OW 113
122283: GO 122300
// ComHold ( group [ i ] ) ;
122285: LD_VAR 0 4
122289: PUSH
122290: LD_VAR 0 7
122294: ARRAY
122295: PPUSH
122296: CALL_OW 140
// continue ;
122300: GO 121126
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
122302: LD_VAR 0 4
122306: PUSH
122307: LD_VAR 0 7
122311: ARRAY
122312: PPUSH
122313: LD_INT 10
122315: PPUSH
122316: CALL 87628 0 2
122320: NOT
122321: IFFALSE 122339
122323: PUSH
122324: LD_VAR 0 16
122328: PUSH
122329: LD_VAR 0 7
122333: ARRAY
122334: PUSH
122335: EMPTY
122336: EQUAL
122337: NOT
122338: AND
122339: IFFALSE 122605
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
122341: LD_VAR 0 4
122345: PUSH
122346: LD_VAR 0 7
122350: ARRAY
122351: PPUSH
122352: CALL_OW 262
122356: PUSH
122357: LD_INT 1
122359: PUSH
122360: LD_INT 2
122362: PUSH
122363: EMPTY
122364: LIST
122365: LIST
122366: IN
122367: IFFALSE 122408
// if GetFuel ( group [ i ] ) < 10 then
122369: LD_VAR 0 4
122373: PUSH
122374: LD_VAR 0 7
122378: ARRAY
122379: PPUSH
122380: CALL_OW 261
122384: PUSH
122385: LD_INT 10
122387: LESS
122388: IFFALSE 122408
// SetFuel ( group [ i ] , 12 ) ;
122390: LD_VAR 0 4
122394: PUSH
122395: LD_VAR 0 7
122399: ARRAY
122400: PPUSH
122401: LD_INT 12
122403: PPUSH
122404: CALL_OW 240
// if units_path [ i ] then
122408: LD_VAR 0 16
122412: PUSH
122413: LD_VAR 0 7
122417: ARRAY
122418: IFFALSE 122603
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
122420: LD_VAR 0 4
122424: PUSH
122425: LD_VAR 0 7
122429: ARRAY
122430: PPUSH
122431: LD_VAR 0 16
122435: PUSH
122436: LD_VAR 0 7
122440: ARRAY
122441: PUSH
122442: LD_INT 1
122444: ARRAY
122445: PUSH
122446: LD_INT 1
122448: ARRAY
122449: PPUSH
122450: LD_VAR 0 16
122454: PUSH
122455: LD_VAR 0 7
122459: ARRAY
122460: PUSH
122461: LD_INT 1
122463: ARRAY
122464: PUSH
122465: LD_INT 2
122467: ARRAY
122468: PPUSH
122469: CALL_OW 297
122473: PUSH
122474: LD_INT 6
122476: GREATER
122477: IFFALSE 122552
// begin if not HasTask ( group [ i ] ) then
122479: LD_VAR 0 4
122483: PUSH
122484: LD_VAR 0 7
122488: ARRAY
122489: PPUSH
122490: CALL_OW 314
122494: NOT
122495: IFFALSE 122550
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
122497: LD_VAR 0 4
122501: PUSH
122502: LD_VAR 0 7
122506: ARRAY
122507: PPUSH
122508: LD_VAR 0 16
122512: PUSH
122513: LD_VAR 0 7
122517: ARRAY
122518: PUSH
122519: LD_INT 1
122521: ARRAY
122522: PUSH
122523: LD_INT 1
122525: ARRAY
122526: PPUSH
122527: LD_VAR 0 16
122531: PUSH
122532: LD_VAR 0 7
122536: ARRAY
122537: PUSH
122538: LD_INT 1
122540: ARRAY
122541: PUSH
122542: LD_INT 2
122544: ARRAY
122545: PPUSH
122546: CALL_OW 114
// end else
122550: GO 122603
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
122552: LD_ADDR_VAR 0 15
122556: PUSH
122557: LD_VAR 0 16
122561: PUSH
122562: LD_VAR 0 7
122566: ARRAY
122567: PPUSH
122568: LD_INT 1
122570: PPUSH
122571: CALL_OW 3
122575: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
122576: LD_ADDR_VAR 0 16
122580: PUSH
122581: LD_VAR 0 16
122585: PPUSH
122586: LD_VAR 0 7
122590: PPUSH
122591: LD_VAR 0 15
122595: PPUSH
122596: CALL_OW 1
122600: ST_TO_ADDR
// continue ;
122601: GO 121126
// end ; end ; end else
122603: GO 125301
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
122605: LD_ADDR_VAR 0 14
122609: PUSH
122610: LD_INT 81
122612: PUSH
122613: LD_VAR 0 4
122617: PUSH
122618: LD_VAR 0 7
122622: ARRAY
122623: PPUSH
122624: CALL_OW 255
122628: PUSH
122629: EMPTY
122630: LIST
122631: LIST
122632: PPUSH
122633: CALL_OW 69
122637: ST_TO_ADDR
// if not tmp then
122638: LD_VAR 0 14
122642: NOT
122643: IFFALSE 122647
// continue ;
122645: GO 121126
// if f_ignore_area then
122647: LD_VAR 0 17
122651: IFFALSE 122739
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
122653: LD_ADDR_VAR 0 15
122657: PUSH
122658: LD_VAR 0 14
122662: PPUSH
122663: LD_INT 3
122665: PUSH
122666: LD_INT 92
122668: PUSH
122669: LD_VAR 0 17
122673: PUSH
122674: LD_INT 1
122676: ARRAY
122677: PUSH
122678: LD_VAR 0 17
122682: PUSH
122683: LD_INT 2
122685: ARRAY
122686: PUSH
122687: LD_VAR 0 17
122691: PUSH
122692: LD_INT 3
122694: ARRAY
122695: PUSH
122696: EMPTY
122697: LIST
122698: LIST
122699: LIST
122700: LIST
122701: PUSH
122702: EMPTY
122703: LIST
122704: LIST
122705: PPUSH
122706: CALL_OW 72
122710: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
122711: LD_VAR 0 14
122715: PUSH
122716: LD_VAR 0 15
122720: DIFF
122721: IFFALSE 122739
// tmp := tmp diff tmp2 ;
122723: LD_ADDR_VAR 0 14
122727: PUSH
122728: LD_VAR 0 14
122732: PUSH
122733: LD_VAR 0 15
122737: DIFF
122738: ST_TO_ADDR
// end ; if not f_murder then
122739: LD_VAR 0 20
122743: NOT
122744: IFFALSE 122802
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
122746: LD_ADDR_VAR 0 15
122750: PUSH
122751: LD_VAR 0 14
122755: PPUSH
122756: LD_INT 3
122758: PUSH
122759: LD_INT 50
122761: PUSH
122762: EMPTY
122763: LIST
122764: PUSH
122765: EMPTY
122766: LIST
122767: LIST
122768: PPUSH
122769: CALL_OW 72
122773: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
122774: LD_VAR 0 14
122778: PUSH
122779: LD_VAR 0 15
122783: DIFF
122784: IFFALSE 122802
// tmp := tmp diff tmp2 ;
122786: LD_ADDR_VAR 0 14
122790: PUSH
122791: LD_VAR 0 14
122795: PUSH
122796: LD_VAR 0 15
122800: DIFF
122801: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
122802: LD_ADDR_VAR 0 14
122806: PUSH
122807: LD_VAR 0 4
122811: PUSH
122812: LD_VAR 0 7
122816: ARRAY
122817: PPUSH
122818: LD_VAR 0 14
122822: PPUSH
122823: LD_INT 1
122825: PPUSH
122826: LD_INT 1
122828: PPUSH
122829: CALL 60050 0 4
122833: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
122834: LD_VAR 0 4
122838: PUSH
122839: LD_VAR 0 7
122843: ARRAY
122844: PPUSH
122845: CALL_OW 257
122849: PUSH
122850: LD_INT 1
122852: EQUAL
122853: IFFALSE 123313
// begin if WantPlant ( group [ i ] ) then
122855: LD_VAR 0 4
122859: PUSH
122860: LD_VAR 0 7
122864: ARRAY
122865: PPUSH
122866: CALL 59551 0 1
122870: IFFALSE 122874
// continue ;
122872: GO 121126
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
122874: LD_VAR 0 18
122878: IFFALSE 122898
122880: PUSH
122881: LD_VAR 0 4
122885: PUSH
122886: LD_VAR 0 7
122890: ARRAY
122891: PPUSH
122892: CALL_OW 310
122896: NOT
122897: AND
122898: IFFALSE 122941
122900: PUSH
122901: LD_VAR 0 14
122905: PUSH
122906: LD_INT 1
122908: ARRAY
122909: PUSH
122910: LD_VAR 0 14
122914: PPUSH
122915: LD_INT 21
122917: PUSH
122918: LD_INT 2
122920: PUSH
122921: EMPTY
122922: LIST
122923: LIST
122924: PUSH
122925: LD_INT 58
122927: PUSH
122928: EMPTY
122929: LIST
122930: PUSH
122931: EMPTY
122932: LIST
122933: LIST
122934: PPUSH
122935: CALL_OW 72
122939: IN
122940: AND
122941: IFFALSE 122977
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
122943: LD_VAR 0 4
122947: PUSH
122948: LD_VAR 0 7
122952: ARRAY
122953: PPUSH
122954: LD_VAR 0 14
122958: PUSH
122959: LD_INT 1
122961: ARRAY
122962: PPUSH
122963: CALL_OW 120
// attacking := true ;
122967: LD_ADDR_VAR 0 29
122971: PUSH
122972: LD_INT 1
122974: ST_TO_ADDR
// continue ;
122975: GO 121126
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
122977: LD_VAR 0 26
122981: IFFALSE 123004
122983: PUSH
122984: LD_VAR 0 4
122988: PUSH
122989: LD_VAR 0 7
122993: ARRAY
122994: PPUSH
122995: CALL_OW 257
122999: PUSH
123000: LD_INT 1
123002: EQUAL
123003: AND
123004: IFFALSE 123027
123006: PUSH
123007: LD_VAR 0 4
123011: PUSH
123012: LD_VAR 0 7
123016: ARRAY
123017: PPUSH
123018: CALL_OW 256
123022: PUSH
123023: LD_INT 800
123025: LESS
123026: AND
123027: IFFALSE 123047
123029: PUSH
123030: LD_VAR 0 4
123034: PUSH
123035: LD_VAR 0 7
123039: ARRAY
123040: PPUSH
123041: CALL_OW 318
123045: NOT
123046: AND
123047: IFFALSE 123064
// ComCrawl ( group [ i ] ) ;
123049: LD_VAR 0 4
123053: PUSH
123054: LD_VAR 0 7
123058: ARRAY
123059: PPUSH
123060: CALL_OW 137
// if f_mines then
123064: LD_VAR 0 21
123068: IFFALSE 123313
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
123070: LD_VAR 0 14
123074: PUSH
123075: LD_INT 1
123077: ARRAY
123078: PPUSH
123079: CALL_OW 247
123083: PUSH
123084: LD_INT 3
123086: EQUAL
123087: IFFALSE 123106
123089: PUSH
123090: LD_VAR 0 14
123094: PUSH
123095: LD_INT 1
123097: ARRAY
123098: PUSH
123099: LD_VAR 0 27
123103: IN
123104: NOT
123105: AND
123106: IFFALSE 123313
// begin x := GetX ( tmp [ 1 ] ) ;
123108: LD_ADDR_VAR 0 10
123112: PUSH
123113: LD_VAR 0 14
123117: PUSH
123118: LD_INT 1
123120: ARRAY
123121: PPUSH
123122: CALL_OW 250
123126: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
123127: LD_ADDR_VAR 0 11
123131: PUSH
123132: LD_VAR 0 14
123136: PUSH
123137: LD_INT 1
123139: ARRAY
123140: PPUSH
123141: CALL_OW 251
123145: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
123146: LD_ADDR_VAR 0 12
123150: PUSH
123151: LD_VAR 0 4
123155: PUSH
123156: LD_VAR 0 7
123160: ARRAY
123161: PPUSH
123162: CALL 87713 0 1
123166: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
123167: LD_VAR 0 4
123171: PUSH
123172: LD_VAR 0 7
123176: ARRAY
123177: PPUSH
123178: LD_VAR 0 10
123182: PPUSH
123183: LD_VAR 0 11
123187: PPUSH
123188: LD_VAR 0 14
123192: PUSH
123193: LD_INT 1
123195: ARRAY
123196: PPUSH
123197: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
123201: LD_VAR 0 4
123205: PUSH
123206: LD_VAR 0 7
123210: ARRAY
123211: PPUSH
123212: LD_VAR 0 10
123216: PPUSH
123217: LD_VAR 0 12
123221: PPUSH
123222: LD_INT 7
123224: PPUSH
123225: CALL_OW 272
123229: PPUSH
123230: LD_VAR 0 11
123234: PPUSH
123235: LD_VAR 0 12
123239: PPUSH
123240: LD_INT 7
123242: PPUSH
123243: CALL_OW 273
123247: PPUSH
123248: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
123252: LD_VAR 0 4
123256: PUSH
123257: LD_VAR 0 7
123261: ARRAY
123262: PPUSH
123263: LD_INT 71
123265: PPUSH
123266: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
123270: LD_ADDR_VAR 0 27
123274: PUSH
123275: LD_VAR 0 27
123279: PPUSH
123280: LD_VAR 0 27
123284: PUSH
123285: LD_INT 1
123287: PLUS
123288: PPUSH
123289: LD_VAR 0 14
123293: PUSH
123294: LD_INT 1
123296: ARRAY
123297: PPUSH
123298: CALL_OW 1
123302: ST_TO_ADDR
// attacking := true ;
123303: LD_ADDR_VAR 0 29
123307: PUSH
123308: LD_INT 1
123310: ST_TO_ADDR
// continue ;
123311: GO 121126
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
123313: LD_VAR 0 4
123317: PUSH
123318: LD_VAR 0 7
123322: ARRAY
123323: PPUSH
123324: CALL_OW 257
123328: PUSH
123329: LD_INT 17
123331: EQUAL
123332: IFFALSE 123356
123334: PUSH
123335: LD_VAR 0 4
123339: PUSH
123340: LD_VAR 0 7
123344: ARRAY
123345: PPUSH
123346: CALL_OW 110
123350: PUSH
123351: LD_INT 71
123353: EQUAL
123354: NOT
123355: AND
123356: IFFALSE 123502
// begin attacking := false ;
123358: LD_ADDR_VAR 0 29
123362: PUSH
123363: LD_INT 0
123365: ST_TO_ADDR
// k := 5 ;
123366: LD_ADDR_VAR 0 9
123370: PUSH
123371: LD_INT 5
123373: ST_TO_ADDR
// if tmp < k then
123374: LD_VAR 0 14
123378: PUSH
123379: LD_VAR 0 9
123383: LESS
123384: IFFALSE 123396
// k := tmp ;
123386: LD_ADDR_VAR 0 9
123390: PUSH
123391: LD_VAR 0 14
123395: ST_TO_ADDR
// for j = 1 to k do
123396: LD_ADDR_VAR 0 8
123400: PUSH
123401: DOUBLE
123402: LD_INT 1
123404: DEC
123405: ST_TO_ADDR
123406: LD_VAR 0 9
123410: PUSH
123411: FOR_TO
123412: IFFALSE 123500
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
123414: LD_VAR 0 14
123418: PUSH
123419: LD_VAR 0 8
123423: ARRAY
123424: PUSH
123425: LD_VAR 0 14
123429: PPUSH
123430: LD_INT 58
123432: PUSH
123433: EMPTY
123434: LIST
123435: PPUSH
123436: CALL_OW 72
123440: IN
123441: NOT
123442: IFFALSE 123498
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123444: LD_VAR 0 4
123448: PUSH
123449: LD_VAR 0 7
123453: ARRAY
123454: PPUSH
123455: LD_VAR 0 14
123459: PUSH
123460: LD_VAR 0 8
123464: ARRAY
123465: PPUSH
123466: CALL_OW 115
// attacking := true ;
123470: LD_ADDR_VAR 0 29
123474: PUSH
123475: LD_INT 1
123477: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
123478: LD_VAR 0 4
123482: PUSH
123483: LD_VAR 0 7
123487: ARRAY
123488: PPUSH
123489: LD_INT 71
123491: PPUSH
123492: CALL_OW 109
// continue ;
123496: GO 123411
// end ; end ;
123498: GO 123411
123500: POP
123501: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
123502: LD_VAR 0 4
123506: PUSH
123507: LD_VAR 0 7
123511: ARRAY
123512: PPUSH
123513: CALL_OW 257
123517: PUSH
123518: LD_INT 8
123520: EQUAL
123521: IFTRUE 123559
123523: PUSH
123524: LD_VAR 0 4
123528: PUSH
123529: LD_VAR 0 7
123533: ARRAY
123534: PPUSH
123535: CALL_OW 264
123539: PUSH
123540: LD_INT 28
123542: PUSH
123543: LD_INT 45
123545: PUSH
123546: LD_INT 7
123548: PUSH
123549: LD_INT 47
123551: PUSH
123552: EMPTY
123553: LIST
123554: LIST
123555: LIST
123556: LIST
123557: IN
123558: OR
123559: IFFALSE 123815
// begin attacking := false ;
123561: LD_ADDR_VAR 0 29
123565: PUSH
123566: LD_INT 0
123568: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
123569: LD_VAR 0 14
123573: PUSH
123574: LD_INT 1
123576: ARRAY
123577: PPUSH
123578: CALL_OW 266
123582: PUSH
123583: LD_INT 32
123585: PUSH
123586: LD_INT 31
123588: PUSH
123589: LD_INT 33
123591: PUSH
123592: LD_INT 4
123594: PUSH
123595: LD_INT 5
123597: PUSH
123598: EMPTY
123599: LIST
123600: LIST
123601: LIST
123602: LIST
123603: LIST
123604: IN
123605: IFFALSE 123791
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
123607: LD_ADDR_VAR 0 9
123611: PUSH
123612: LD_VAR 0 14
123616: PUSH
123617: LD_INT 1
123619: ARRAY
123620: PPUSH
123621: CALL_OW 266
123625: PPUSH
123626: LD_VAR 0 14
123630: PUSH
123631: LD_INT 1
123633: ARRAY
123634: PPUSH
123635: CALL_OW 250
123639: PPUSH
123640: LD_VAR 0 14
123644: PUSH
123645: LD_INT 1
123647: ARRAY
123648: PPUSH
123649: CALL_OW 251
123653: PPUSH
123654: LD_VAR 0 14
123658: PUSH
123659: LD_INT 1
123661: ARRAY
123662: PPUSH
123663: CALL_OW 254
123667: PPUSH
123668: LD_VAR 0 14
123672: PUSH
123673: LD_INT 1
123675: ARRAY
123676: PPUSH
123677: CALL_OW 248
123681: PPUSH
123682: LD_INT 0
123684: PPUSH
123685: CALL 69071 0 6
123689: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
123690: LD_ADDR_VAR 0 8
123694: PUSH
123695: LD_VAR 0 4
123699: PUSH
123700: LD_VAR 0 7
123704: ARRAY
123705: PPUSH
123706: LD_VAR 0 9
123710: PPUSH
123711: CALL 87826 0 2
123715: ST_TO_ADDR
// if j then
123716: LD_VAR 0 8
123720: IFFALSE 123789
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
123722: LD_VAR 0 8
123726: PUSH
123727: LD_INT 1
123729: ARRAY
123730: PPUSH
123731: LD_VAR 0 8
123735: PUSH
123736: LD_INT 2
123738: ARRAY
123739: PPUSH
123740: CALL_OW 488
123744: IFFALSE 123789
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
123746: LD_VAR 0 4
123750: PUSH
123751: LD_VAR 0 7
123755: ARRAY
123756: PPUSH
123757: LD_VAR 0 8
123761: PUSH
123762: LD_INT 1
123764: ARRAY
123765: PPUSH
123766: LD_VAR 0 8
123770: PUSH
123771: LD_INT 2
123773: ARRAY
123774: PPUSH
123775: CALL_OW 116
// attacking := true ;
123779: LD_ADDR_VAR 0 29
123783: PUSH
123784: LD_INT 1
123786: ST_TO_ADDR
// continue ;
123787: GO 121126
// end ; end else
123789: GO 123815
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
123791: LD_VAR 0 4
123795: PUSH
123796: LD_VAR 0 7
123800: ARRAY
123801: PPUSH
123802: LD_VAR 0 14
123806: PUSH
123807: LD_INT 1
123809: ARRAY
123810: PPUSH
123811: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
123815: LD_VAR 0 4
123819: PUSH
123820: LD_VAR 0 7
123824: ARRAY
123825: PPUSH
123826: CALL_OW 265
123830: PUSH
123831: LD_INT 11
123833: EQUAL
123834: IFFALSE 124112
// begin k := 10 ;
123836: LD_ADDR_VAR 0 9
123840: PUSH
123841: LD_INT 10
123843: ST_TO_ADDR
// x := 0 ;
123844: LD_ADDR_VAR 0 10
123848: PUSH
123849: LD_INT 0
123851: ST_TO_ADDR
// if tmp < k then
123852: LD_VAR 0 14
123856: PUSH
123857: LD_VAR 0 9
123861: LESS
123862: IFFALSE 123874
// k := tmp ;
123864: LD_ADDR_VAR 0 9
123868: PUSH
123869: LD_VAR 0 14
123873: ST_TO_ADDR
// for j = k downto 1 do
123874: LD_ADDR_VAR 0 8
123878: PUSH
123879: DOUBLE
123880: LD_VAR 0 9
123884: INC
123885: ST_TO_ADDR
123886: LD_INT 1
123888: PUSH
123889: FOR_DOWNTO
123890: IFFALSE 123965
// begin if GetType ( tmp [ j ] ) = unit_human then
123892: LD_VAR 0 14
123896: PUSH
123897: LD_VAR 0 8
123901: ARRAY
123902: PPUSH
123903: CALL_OW 247
123907: PUSH
123908: LD_INT 1
123910: EQUAL
123911: IFFALSE 123963
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
123913: LD_VAR 0 4
123917: PUSH
123918: LD_VAR 0 7
123922: ARRAY
123923: PPUSH
123924: LD_VAR 0 14
123928: PUSH
123929: LD_VAR 0 8
123933: ARRAY
123934: PPUSH
123935: CALL 88084 0 2
// x := tmp [ j ] ;
123939: LD_ADDR_VAR 0 10
123943: PUSH
123944: LD_VAR 0 14
123948: PUSH
123949: LD_VAR 0 8
123953: ARRAY
123954: ST_TO_ADDR
// attacking := true ;
123955: LD_ADDR_VAR 0 29
123959: PUSH
123960: LD_INT 1
123962: ST_TO_ADDR
// end ; end ;
123963: GO 123889
123965: POP
123966: POP
// if not x then
123967: LD_VAR 0 10
123971: NOT
123972: IFFALSE 124112
// begin attacking := true ;
123974: LD_ADDR_VAR 0 29
123978: PUSH
123979: LD_INT 1
123981: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
123982: LD_VAR 0 4
123986: PUSH
123987: LD_VAR 0 7
123991: ARRAY
123992: PPUSH
123993: CALL_OW 250
123997: PPUSH
123998: LD_VAR 0 4
124002: PUSH
124003: LD_VAR 0 7
124007: ARRAY
124008: PPUSH
124009: CALL_OW 251
124013: PPUSH
124014: CALL_OW 546
124018: PUSH
124019: LD_INT 2
124021: ARRAY
124022: PUSH
124023: LD_VAR 0 14
124027: PUSH
124028: LD_INT 1
124030: ARRAY
124031: PPUSH
124032: CALL_OW 250
124036: PPUSH
124037: LD_VAR 0 14
124041: PUSH
124042: LD_INT 1
124044: ARRAY
124045: PPUSH
124046: CALL_OW 251
124050: PPUSH
124051: CALL_OW 546
124055: PUSH
124056: LD_INT 2
124058: ARRAY
124059: EQUAL
124060: IFFALSE 124088
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
124062: LD_VAR 0 4
124066: PUSH
124067: LD_VAR 0 7
124071: ARRAY
124072: PPUSH
124073: LD_VAR 0 14
124077: PUSH
124078: LD_INT 1
124080: ARRAY
124081: PPUSH
124082: CALL 88084 0 2
124086: GO 124112
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124088: LD_VAR 0 4
124092: PUSH
124093: LD_VAR 0 7
124097: ARRAY
124098: PPUSH
124099: LD_VAR 0 14
124103: PUSH
124104: LD_INT 1
124106: ARRAY
124107: PPUSH
124108: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
124112: LD_VAR 0 4
124116: PUSH
124117: LD_VAR 0 7
124121: ARRAY
124122: PPUSH
124123: CALL_OW 264
124127: PUSH
124128: LD_INT 29
124130: EQUAL
124131: IFFALSE 124501
// begin if WantsToAttack ( group [ i ] ) in bombed then
124133: LD_VAR 0 4
124137: PUSH
124138: LD_VAR 0 7
124142: ARRAY
124143: PPUSH
124144: CALL_OW 319
124148: PUSH
124149: LD_VAR 0 28
124153: IN
124154: IFFALSE 124158
// continue ;
124156: GO 121126
// k := 8 ;
124158: LD_ADDR_VAR 0 9
124162: PUSH
124163: LD_INT 8
124165: ST_TO_ADDR
// x := 0 ;
124166: LD_ADDR_VAR 0 10
124170: PUSH
124171: LD_INT 0
124173: ST_TO_ADDR
// if tmp < k then
124174: LD_VAR 0 14
124178: PUSH
124179: LD_VAR 0 9
124183: LESS
124184: IFFALSE 124196
// k := tmp ;
124186: LD_ADDR_VAR 0 9
124190: PUSH
124191: LD_VAR 0 14
124195: ST_TO_ADDR
// for j = 1 to k do
124196: LD_ADDR_VAR 0 8
124200: PUSH
124201: DOUBLE
124202: LD_INT 1
124204: DEC
124205: ST_TO_ADDR
124206: LD_VAR 0 9
124210: PUSH
124211: FOR_TO
124212: IFFALSE 124346
// begin if GetType ( tmp [ j ] ) = unit_building then
124214: LD_VAR 0 14
124218: PUSH
124219: LD_VAR 0 8
124223: ARRAY
124224: PPUSH
124225: CALL_OW 247
124229: PUSH
124230: LD_INT 3
124232: EQUAL
124233: IFFALSE 124344
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
124235: LD_VAR 0 14
124239: PUSH
124240: LD_VAR 0 8
124244: ARRAY
124245: PUSH
124246: LD_VAR 0 28
124250: IN
124251: NOT
124252: IFFALSE 124271
124254: PUSH
124255: LD_VAR 0 14
124259: PUSH
124260: LD_VAR 0 8
124264: ARRAY
124265: PPUSH
124266: CALL_OW 313
124270: AND
124271: IFFALSE 124344
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
124273: LD_VAR 0 4
124277: PUSH
124278: LD_VAR 0 7
124282: ARRAY
124283: PPUSH
124284: LD_VAR 0 14
124288: PUSH
124289: LD_VAR 0 8
124293: ARRAY
124294: PPUSH
124295: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
124299: LD_ADDR_VAR 0 28
124303: PUSH
124304: LD_VAR 0 28
124308: PPUSH
124309: LD_VAR 0 28
124313: PUSH
124314: LD_INT 1
124316: PLUS
124317: PPUSH
124318: LD_VAR 0 14
124322: PUSH
124323: LD_VAR 0 8
124327: ARRAY
124328: PPUSH
124329: CALL_OW 1
124333: ST_TO_ADDR
// attacking := true ;
124334: LD_ADDR_VAR 0 29
124338: PUSH
124339: LD_INT 1
124341: ST_TO_ADDR
// break ;
124342: GO 124346
// end ; end ;
124344: GO 124211
124346: POP
124347: POP
// if not attacking and f_attack_depot then
124348: LD_VAR 0 29
124352: NOT
124353: IFFALSE 124361
124355: PUSH
124356: LD_VAR 0 25
124360: AND
124361: IFFALSE 124456
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
124363: LD_ADDR_VAR 0 13
124367: PUSH
124368: LD_VAR 0 14
124372: PPUSH
124373: LD_INT 2
124375: PUSH
124376: LD_INT 30
124378: PUSH
124379: LD_INT 0
124381: PUSH
124382: EMPTY
124383: LIST
124384: LIST
124385: PUSH
124386: LD_INT 30
124388: PUSH
124389: LD_INT 1
124391: PUSH
124392: EMPTY
124393: LIST
124394: LIST
124395: PUSH
124396: EMPTY
124397: LIST
124398: LIST
124399: LIST
124400: PPUSH
124401: CALL_OW 72
124405: ST_TO_ADDR
// if z then
124406: LD_VAR 0 13
124410: IFFALSE 124456
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
124412: LD_VAR 0 4
124416: PUSH
124417: LD_VAR 0 7
124421: ARRAY
124422: PPUSH
124423: LD_VAR 0 13
124427: PPUSH
124428: LD_VAR 0 4
124432: PUSH
124433: LD_VAR 0 7
124437: ARRAY
124438: PPUSH
124439: CALL_OW 74
124443: PPUSH
124444: CALL_OW 115
// attacking := true ;
124448: LD_ADDR_VAR 0 29
124452: PUSH
124453: LD_INT 1
124455: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
124456: LD_VAR 0 4
124460: PUSH
124461: LD_VAR 0 7
124465: ARRAY
124466: PPUSH
124467: CALL_OW 256
124471: PUSH
124472: LD_INT 500
124474: LESS
124475: IFFALSE 124501
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124477: LD_VAR 0 4
124481: PUSH
124482: LD_VAR 0 7
124486: ARRAY
124487: PPUSH
124488: LD_VAR 0 14
124492: PUSH
124493: LD_INT 1
124495: ARRAY
124496: PPUSH
124497: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
124501: LD_VAR 0 4
124505: PUSH
124506: LD_VAR 0 7
124510: ARRAY
124511: PPUSH
124512: CALL_OW 264
124516: PUSH
124517: LD_INT 49
124519: EQUAL
124520: IFFALSE 124641
// begin if not HasTask ( group [ i ] ) then
124522: LD_VAR 0 4
124526: PUSH
124527: LD_VAR 0 7
124531: ARRAY
124532: PPUSH
124533: CALL_OW 314
124537: NOT
124538: IFFALSE 124641
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
124540: LD_ADDR_VAR 0 9
124544: PUSH
124545: LD_INT 81
124547: PUSH
124548: LD_VAR 0 4
124552: PUSH
124553: LD_VAR 0 7
124557: ARRAY
124558: PPUSH
124559: CALL_OW 255
124563: PUSH
124564: EMPTY
124565: LIST
124566: LIST
124567: PPUSH
124568: CALL_OW 69
124572: PPUSH
124573: LD_VAR 0 4
124577: PUSH
124578: LD_VAR 0 7
124582: ARRAY
124583: PPUSH
124584: CALL_OW 74
124588: ST_TO_ADDR
// if k then
124589: LD_VAR 0 9
124593: IFFALSE 124641
// if GetDistUnits ( group [ i ] , k ) > 10 then
124595: LD_VAR 0 4
124599: PUSH
124600: LD_VAR 0 7
124604: ARRAY
124605: PPUSH
124606: LD_VAR 0 9
124610: PPUSH
124611: CALL_OW 296
124615: PUSH
124616: LD_INT 10
124618: GREATER
124619: IFFALSE 124641
// ComMoveUnit ( group [ i ] , k ) ;
124621: LD_VAR 0 4
124625: PUSH
124626: LD_VAR 0 7
124630: ARRAY
124631: PPUSH
124632: LD_VAR 0 9
124636: PPUSH
124637: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
124641: LD_VAR 0 4
124645: PUSH
124646: LD_VAR 0 7
124650: ARRAY
124651: PPUSH
124652: CALL_OW 256
124656: PUSH
124657: LD_INT 250
124659: LESS
124660: IFFALSE 124704
124662: PUSH
124663: LD_VAR 0 4
124667: PUSH
124668: LD_VAR 0 7
124672: ARRAY
124673: PUSH
124674: LD_INT 21
124676: PUSH
124677: LD_INT 2
124679: PUSH
124680: EMPTY
124681: LIST
124682: LIST
124683: PUSH
124684: LD_INT 23
124686: PUSH
124687: LD_INT 2
124689: PUSH
124690: EMPTY
124691: LIST
124692: LIST
124693: PUSH
124694: EMPTY
124695: LIST
124696: LIST
124697: PPUSH
124698: CALL_OW 69
124702: IN
124703: AND
124704: IFFALSE 124831
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
124706: LD_ADDR_VAR 0 9
124710: PUSH
124711: LD_OWVAR 3
124715: PUSH
124716: LD_VAR 0 4
124720: PUSH
124721: LD_VAR 0 7
124725: ARRAY
124726: DIFF
124727: PPUSH
124728: LD_VAR 0 4
124732: PUSH
124733: LD_VAR 0 7
124737: ARRAY
124738: PPUSH
124739: CALL_OW 74
124743: ST_TO_ADDR
// if not k then
124744: LD_VAR 0 9
124748: NOT
124749: IFFALSE 124753
// continue ;
124751: GO 121126
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
124753: LD_VAR 0 9
124757: PUSH
124758: LD_INT 81
124760: PUSH
124761: LD_VAR 0 4
124765: PUSH
124766: LD_VAR 0 7
124770: ARRAY
124771: PPUSH
124772: CALL_OW 255
124776: PUSH
124777: EMPTY
124778: LIST
124779: LIST
124780: PPUSH
124781: CALL_OW 69
124785: IN
124786: IFFALSE 124814
124788: PUSH
124789: LD_VAR 0 9
124793: PPUSH
124794: LD_VAR 0 4
124798: PUSH
124799: LD_VAR 0 7
124803: ARRAY
124804: PPUSH
124805: CALL_OW 296
124809: PUSH
124810: LD_INT 5
124812: LESS
124813: AND
124814: IFFALSE 124831
// ComAutodestruct ( group [ i ] ) ;
124816: LD_VAR 0 4
124820: PUSH
124821: LD_VAR 0 7
124825: ARRAY
124826: PPUSH
124827: CALL 87980 0 1
// end ; if f_attack_depot then
124831: LD_VAR 0 25
124835: IFFALSE 124947
// begin k := 6 ;
124837: LD_ADDR_VAR 0 9
124841: PUSH
124842: LD_INT 6
124844: ST_TO_ADDR
// if tmp < k then
124845: LD_VAR 0 14
124849: PUSH
124850: LD_VAR 0 9
124854: LESS
124855: IFFALSE 124867
// k := tmp ;
124857: LD_ADDR_VAR 0 9
124861: PUSH
124862: LD_VAR 0 14
124866: ST_TO_ADDR
// for j = 1 to k do
124867: LD_ADDR_VAR 0 8
124871: PUSH
124872: DOUBLE
124873: LD_INT 1
124875: DEC
124876: ST_TO_ADDR
124877: LD_VAR 0 9
124881: PUSH
124882: FOR_TO
124883: IFFALSE 124945
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
124885: LD_VAR 0 8
124889: PPUSH
124890: CALL_OW 266
124894: PUSH
124895: LD_INT 0
124897: PUSH
124898: LD_INT 1
124900: PUSH
124901: EMPTY
124902: LIST
124903: LIST
124904: IN
124905: IFFALSE 124943
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
124907: LD_VAR 0 4
124911: PUSH
124912: LD_VAR 0 7
124916: ARRAY
124917: PPUSH
124918: LD_VAR 0 14
124922: PUSH
124923: LD_VAR 0 8
124927: ARRAY
124928: PPUSH
124929: CALL_OW 115
// attacking := true ;
124933: LD_ADDR_VAR 0 29
124937: PUSH
124938: LD_INT 1
124940: ST_TO_ADDR
// break ;
124941: GO 124945
// end ;
124943: GO 124882
124945: POP
124946: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
124947: LD_VAR 0 4
124951: PUSH
124952: LD_VAR 0 7
124956: ARRAY
124957: PPUSH
124958: CALL_OW 302
124962: IFFALSE 124971
124964: PUSH
124965: LD_VAR 0 29
124969: NOT
124970: AND
124971: IFFALSE 125301
// begin if GetTag ( group [ i ] ) = 71 then
124973: LD_VAR 0 4
124977: PUSH
124978: LD_VAR 0 7
124982: ARRAY
124983: PPUSH
124984: CALL_OW 110
124988: PUSH
124989: LD_INT 71
124991: EQUAL
124992: IFFALSE 125033
// begin if HasTask ( group [ i ] ) then
124994: LD_VAR 0 4
124998: PUSH
124999: LD_VAR 0 7
125003: ARRAY
125004: PPUSH
125005: CALL_OW 314
125009: IFFALSE 125015
// continue else
125011: GO 121126
125013: GO 125033
// SetTag ( group [ i ] , 0 ) ;
125015: LD_VAR 0 4
125019: PUSH
125020: LD_VAR 0 7
125024: ARRAY
125025: PPUSH
125026: LD_INT 0
125028: PPUSH
125029: CALL_OW 109
// end ; k := 8 ;
125033: LD_ADDR_VAR 0 9
125037: PUSH
125038: LD_INT 8
125040: ST_TO_ADDR
// x := 0 ;
125041: LD_ADDR_VAR 0 10
125045: PUSH
125046: LD_INT 0
125048: ST_TO_ADDR
// if tmp < k then
125049: LD_VAR 0 14
125053: PUSH
125054: LD_VAR 0 9
125058: LESS
125059: IFFALSE 125071
// k := tmp ;
125061: LD_ADDR_VAR 0 9
125065: PUSH
125066: LD_VAR 0 14
125070: ST_TO_ADDR
// for j = 1 to k do
125071: LD_ADDR_VAR 0 8
125075: PUSH
125076: DOUBLE
125077: LD_INT 1
125079: DEC
125080: ST_TO_ADDR
125081: LD_VAR 0 9
125085: PUSH
125086: FOR_TO
125087: IFFALSE 125193
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
125089: LD_VAR 0 14
125093: PUSH
125094: LD_VAR 0 8
125098: ARRAY
125099: PPUSH
125100: CALL_OW 247
125104: PUSH
125105: LD_INT 1
125107: EQUAL
125108: IFFALSE 125171
125110: PUSH
125111: LD_VAR 0 14
125115: PUSH
125116: LD_VAR 0 8
125120: ARRAY
125121: PPUSH
125122: CALL_OW 256
125126: PUSH
125127: LD_INT 250
125129: LESS
125130: IFFALSE 125138
125132: PUSH
125133: LD_VAR 0 20
125137: AND
125138: IFTRUE 125170
125140: PUSH
125141: LD_VAR 0 20
125145: NOT
125146: IFFALSE 125169
125148: PUSH
125149: LD_VAR 0 14
125153: PUSH
125154: LD_VAR 0 8
125158: ARRAY
125159: PPUSH
125160: CALL_OW 256
125164: PUSH
125165: LD_INT 250
125167: GREATEREQUAL
125168: AND
125169: OR
125170: AND
125171: IFFALSE 125191
// begin x := tmp [ j ] ;
125173: LD_ADDR_VAR 0 10
125177: PUSH
125178: LD_VAR 0 14
125182: PUSH
125183: LD_VAR 0 8
125187: ARRAY
125188: ST_TO_ADDR
// break ;
125189: GO 125193
// end ;
125191: GO 125086
125193: POP
125194: POP
// if x then
125195: LD_VAR 0 10
125199: IFFALSE 125223
// ComAttackUnit ( group [ i ] , x ) else
125201: LD_VAR 0 4
125205: PUSH
125206: LD_VAR 0 7
125210: ARRAY
125211: PPUSH
125212: LD_VAR 0 10
125216: PPUSH
125217: CALL_OW 115
125221: GO 125247
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125223: LD_VAR 0 4
125227: PUSH
125228: LD_VAR 0 7
125232: ARRAY
125233: PPUSH
125234: LD_VAR 0 14
125238: PUSH
125239: LD_INT 1
125241: ARRAY
125242: PPUSH
125243: CALL_OW 115
// if not HasTask ( group [ i ] ) then
125247: LD_VAR 0 4
125251: PUSH
125252: LD_VAR 0 7
125256: ARRAY
125257: PPUSH
125258: CALL_OW 314
125262: NOT
125263: IFFALSE 125301
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
125265: LD_VAR 0 4
125269: PUSH
125270: LD_VAR 0 7
125274: ARRAY
125275: PPUSH
125276: LD_VAR 0 14
125280: PPUSH
125281: LD_VAR 0 4
125285: PUSH
125286: LD_VAR 0 7
125290: ARRAY
125291: PPUSH
125292: CALL_OW 74
125296: PPUSH
125297: CALL_OW 115
// end ; end ; end ;
125301: GO 121126
125303: POP
125304: POP
// wait ( 0 0$2 ) ;
125305: LD_INT 70
125307: PPUSH
125308: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
125312: LD_VAR 0 4
125316: NOT
125317: IFTRUE 125328
125319: PUSH
125320: LD_VAR 0 4
125324: PUSH
125325: EMPTY
125326: EQUAL
125327: OR
125328: IFTRUE 125349
125330: PUSH
125331: LD_INT 81
125333: PUSH
125334: LD_VAR 0 35
125338: PUSH
125339: EMPTY
125340: LIST
125341: LIST
125342: PPUSH
125343: CALL_OW 69
125347: NOT
125348: OR
125349: IFFALSE 121111
// end ;
125351: LD_VAR 0 2
125355: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
125356: LD_INT 0
125358: PPUSH
125359: PPUSH
125360: PPUSH
125361: PPUSH
125362: PPUSH
125363: PPUSH
// if not base or not mc_bases [ base ] or not solds then
125364: LD_VAR 0 1
125368: NOT
125369: IFTRUE 125384
125371: PUSH
125372: LD_EXP 80
125376: PUSH
125377: LD_VAR 0 1
125381: ARRAY
125382: NOT
125383: OR
125384: IFTRUE 125393
125386: PUSH
125387: LD_VAR 0 2
125391: NOT
125392: OR
125393: IFFALSE 125397
// exit ;
125395: GO 125955
// side := mc_sides [ base ] ;
125397: LD_ADDR_VAR 0 6
125401: PUSH
125402: LD_EXP 106
125406: PUSH
125407: LD_VAR 0 1
125411: ARRAY
125412: ST_TO_ADDR
// if not side then
125413: LD_VAR 0 6
125417: NOT
125418: IFFALSE 125422
// exit ;
125420: GO 125955
// for i in solds do
125422: LD_ADDR_VAR 0 7
125426: PUSH
125427: LD_VAR 0 2
125431: PUSH
125432: FOR_IN
125433: IFFALSE 125494
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
125435: LD_VAR 0 7
125439: PPUSH
125440: CALL_OW 310
125444: PPUSH
125445: CALL_OW 266
125449: PUSH
125450: LD_INT 32
125452: PUSH
125453: LD_INT 31
125455: PUSH
125456: EMPTY
125457: LIST
125458: LIST
125459: IN
125460: IFFALSE 125480
// solds := solds diff i else
125462: LD_ADDR_VAR 0 2
125466: PUSH
125467: LD_VAR 0 2
125471: PUSH
125472: LD_VAR 0 7
125476: DIFF
125477: ST_TO_ADDR
125478: GO 125492
// SetTag ( i , 18 ) ;
125480: LD_VAR 0 7
125484: PPUSH
125485: LD_INT 18
125487: PPUSH
125488: CALL_OW 109
125492: GO 125432
125494: POP
125495: POP
// if not solds then
125496: LD_VAR 0 2
125500: NOT
125501: IFFALSE 125505
// exit ;
125503: GO 125955
// repeat wait ( 0 0$2 ) ;
125505: LD_INT 70
125507: PPUSH
125508: CALL_OW 67
// enemy := mc_scan [ base ] ;
125512: LD_ADDR_VAR 0 4
125516: PUSH
125517: LD_EXP 103
125521: PUSH
125522: LD_VAR 0 1
125526: ARRAY
125527: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
125528: LD_EXP 80
125532: PUSH
125533: LD_VAR 0 1
125537: ARRAY
125538: NOT
125539: IFTRUE 125556
125541: PUSH
125542: LD_EXP 80
125546: PUSH
125547: LD_VAR 0 1
125551: ARRAY
125552: PUSH
125553: EMPTY
125554: EQUAL
125555: OR
125556: IFFALSE 125593
// begin for i in solds do
125558: LD_ADDR_VAR 0 7
125562: PUSH
125563: LD_VAR 0 2
125567: PUSH
125568: FOR_IN
125569: IFFALSE 125582
// ComStop ( i ) ;
125571: LD_VAR 0 7
125575: PPUSH
125576: CALL_OW 141
125580: GO 125568
125582: POP
125583: POP
// solds := [ ] ;
125584: LD_ADDR_VAR 0 2
125588: PUSH
125589: EMPTY
125590: ST_TO_ADDR
// exit ;
125591: GO 125955
// end ; for i in solds do
125593: LD_ADDR_VAR 0 7
125597: PUSH
125598: LD_VAR 0 2
125602: PUSH
125603: FOR_IN
125604: IFFALSE 125925
// begin if IsInUnit ( i ) then
125606: LD_VAR 0 7
125610: PPUSH
125611: CALL_OW 310
125615: IFFALSE 125626
// ComExitBuilding ( i ) ;
125617: LD_VAR 0 7
125621: PPUSH
125622: CALL_OW 122
// if GetLives ( i ) > 500 then
125626: LD_VAR 0 7
125630: PPUSH
125631: CALL_OW 256
125635: PUSH
125636: LD_INT 500
125638: GREATER
125639: IFFALSE 125692
// begin e := NearestUnitToUnit ( enemy , i ) ;
125641: LD_ADDR_VAR 0 5
125645: PUSH
125646: LD_VAR 0 4
125650: PPUSH
125651: LD_VAR 0 7
125655: PPUSH
125656: CALL_OW 74
125660: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
125661: LD_VAR 0 7
125665: PPUSH
125666: LD_VAR 0 5
125670: PPUSH
125671: CALL_OW 250
125675: PPUSH
125676: LD_VAR 0 5
125680: PPUSH
125681: CALL_OW 251
125685: PPUSH
125686: CALL_OW 114
// end else
125690: GO 125923
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
125692: LD_VAR 0 7
125696: PPUSH
125697: LD_EXP 80
125701: PUSH
125702: LD_VAR 0 1
125706: ARRAY
125707: PPUSH
125708: LD_INT 2
125710: PUSH
125711: LD_INT 30
125713: PUSH
125714: LD_INT 0
125716: PUSH
125717: EMPTY
125718: LIST
125719: LIST
125720: PUSH
125721: LD_INT 30
125723: PUSH
125724: LD_INT 1
125726: PUSH
125727: EMPTY
125728: LIST
125729: LIST
125730: PUSH
125731: LD_INT 30
125733: PUSH
125734: LD_INT 6
125736: PUSH
125737: EMPTY
125738: LIST
125739: LIST
125740: PUSH
125741: EMPTY
125742: LIST
125743: LIST
125744: LIST
125745: LIST
125746: PPUSH
125747: CALL_OW 72
125751: PPUSH
125752: LD_VAR 0 7
125756: PPUSH
125757: CALL_OW 74
125761: PPUSH
125762: CALL_OW 296
125766: PUSH
125767: LD_INT 10
125769: GREATER
125770: IFFALSE 125923
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
125772: LD_ADDR_VAR 0 8
125776: PUSH
125777: LD_EXP 80
125781: PUSH
125782: LD_VAR 0 1
125786: ARRAY
125787: PPUSH
125788: LD_INT 2
125790: PUSH
125791: LD_INT 30
125793: PUSH
125794: LD_INT 0
125796: PUSH
125797: EMPTY
125798: LIST
125799: LIST
125800: PUSH
125801: LD_INT 30
125803: PUSH
125804: LD_INT 1
125806: PUSH
125807: EMPTY
125808: LIST
125809: LIST
125810: PUSH
125811: LD_INT 30
125813: PUSH
125814: LD_INT 6
125816: PUSH
125817: EMPTY
125818: LIST
125819: LIST
125820: PUSH
125821: EMPTY
125822: LIST
125823: LIST
125824: LIST
125825: LIST
125826: PPUSH
125827: CALL_OW 72
125831: PPUSH
125832: LD_VAR 0 7
125836: PPUSH
125837: CALL_OW 74
125841: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
125842: LD_VAR 0 7
125846: PPUSH
125847: LD_VAR 0 8
125851: PPUSH
125852: CALL_OW 250
125856: PPUSH
125857: LD_INT 3
125859: PPUSH
125860: LD_INT 5
125862: PPUSH
125863: CALL_OW 272
125867: PPUSH
125868: LD_VAR 0 8
125872: PPUSH
125873: CALL_OW 251
125877: PPUSH
125878: LD_INT 3
125880: PPUSH
125881: LD_INT 5
125883: PPUSH
125884: CALL_OW 273
125888: PPUSH
125889: CALL_OW 111
// SetTag ( i , 0 ) ;
125893: LD_VAR 0 7
125897: PPUSH
125898: LD_INT 0
125900: PPUSH
125901: CALL_OW 109
// solds := solds diff i ;
125905: LD_ADDR_VAR 0 2
125909: PUSH
125910: LD_VAR 0 2
125914: PUSH
125915: LD_VAR 0 7
125919: DIFF
125920: ST_TO_ADDR
// continue ;
125921: GO 125603
// end ; end ;
125923: GO 125603
125925: POP
125926: POP
// until not solds or not enemy ;
125927: LD_VAR 0 2
125931: NOT
125932: IFTRUE 125941
125934: PUSH
125935: LD_VAR 0 4
125939: NOT
125940: OR
125941: IFFALSE 125505
// MC_Reset ( base , 18 ) ;
125943: LD_VAR 0 1
125947: PPUSH
125948: LD_INT 18
125950: PPUSH
125951: CALL 27580 0 2
// end ;
125955: LD_VAR 0 3
125959: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
125960: LD_INT 0
125962: PPUSH
125963: PPUSH
125964: PPUSH
125965: PPUSH
125966: PPUSH
125967: PPUSH
125968: PPUSH
125969: PPUSH
125970: PPUSH
125971: PPUSH
125972: PPUSH
125973: PPUSH
125974: PPUSH
125975: PPUSH
125976: PPUSH
125977: PPUSH
125978: PPUSH
125979: PPUSH
125980: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
125981: LD_ADDR_VAR 0 12
125985: PUSH
125986: LD_EXP 80
125990: PUSH
125991: LD_VAR 0 1
125995: ARRAY
125996: PPUSH
125997: LD_INT 25
125999: PUSH
126000: LD_INT 3
126002: PUSH
126003: EMPTY
126004: LIST
126005: LIST
126006: PPUSH
126007: CALL_OW 72
126011: ST_TO_ADDR
// if mc_remote_driver [ base ] then
126012: LD_EXP 120
126016: PUSH
126017: LD_VAR 0 1
126021: ARRAY
126022: IFFALSE 126046
// mechs := mechs diff mc_remote_driver [ base ] ;
126024: LD_ADDR_VAR 0 12
126028: PUSH
126029: LD_VAR 0 12
126033: PUSH
126034: LD_EXP 120
126038: PUSH
126039: LD_VAR 0 1
126043: ARRAY
126044: DIFF
126045: ST_TO_ADDR
// for i in mechs do
126046: LD_ADDR_VAR 0 4
126050: PUSH
126051: LD_VAR 0 12
126055: PUSH
126056: FOR_IN
126057: IFFALSE 126092
// if GetTag ( i ) > 0 then
126059: LD_VAR 0 4
126063: PPUSH
126064: CALL_OW 110
126068: PUSH
126069: LD_INT 0
126071: GREATER
126072: IFFALSE 126090
// mechs := mechs diff i ;
126074: LD_ADDR_VAR 0 12
126078: PUSH
126079: LD_VAR 0 12
126083: PUSH
126084: LD_VAR 0 4
126088: DIFF
126089: ST_TO_ADDR
126090: GO 126056
126092: POP
126093: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
126094: LD_ADDR_VAR 0 8
126098: PUSH
126099: LD_EXP 80
126103: PUSH
126104: LD_VAR 0 1
126108: ARRAY
126109: PPUSH
126110: LD_INT 2
126112: PUSH
126113: LD_INT 25
126115: PUSH
126116: LD_INT 1
126118: PUSH
126119: EMPTY
126120: LIST
126121: LIST
126122: PUSH
126123: LD_INT 25
126125: PUSH
126126: LD_INT 5
126128: PUSH
126129: EMPTY
126130: LIST
126131: LIST
126132: PUSH
126133: LD_INT 25
126135: PUSH
126136: LD_INT 8
126138: PUSH
126139: EMPTY
126140: LIST
126141: LIST
126142: PUSH
126143: LD_INT 25
126145: PUSH
126146: LD_INT 9
126148: PUSH
126149: EMPTY
126150: LIST
126151: LIST
126152: PUSH
126153: EMPTY
126154: LIST
126155: LIST
126156: LIST
126157: LIST
126158: LIST
126159: PPUSH
126160: CALL_OW 72
126164: ST_TO_ADDR
// if not defenders and not solds then
126165: LD_VAR 0 2
126169: NOT
126170: IFFALSE 126179
126172: PUSH
126173: LD_VAR 0 8
126177: NOT
126178: AND
126179: IFFALSE 126183
// exit ;
126181: GO 128005
// depot_under_attack := false ;
126183: LD_ADDR_VAR 0 16
126187: PUSH
126188: LD_INT 0
126190: ST_TO_ADDR
// sold_defenders := [ ] ;
126191: LD_ADDR_VAR 0 17
126195: PUSH
126196: EMPTY
126197: ST_TO_ADDR
// if mechs then
126198: LD_VAR 0 12
126202: IFFALSE 126357
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
126204: LD_ADDR_VAR 0 4
126208: PUSH
126209: LD_VAR 0 2
126213: PPUSH
126214: LD_INT 21
126216: PUSH
126217: LD_INT 2
126219: PUSH
126220: EMPTY
126221: LIST
126222: LIST
126223: PPUSH
126224: CALL_OW 72
126228: PUSH
126229: FOR_IN
126230: IFFALSE 126355
// begin if GetTag ( i ) <> 20 then
126232: LD_VAR 0 4
126236: PPUSH
126237: CALL_OW 110
126241: PUSH
126242: LD_INT 20
126244: NONEQUAL
126245: IFFALSE 126259
// SetTag ( i , 20 ) ;
126247: LD_VAR 0 4
126251: PPUSH
126252: LD_INT 20
126254: PPUSH
126255: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
126259: LD_VAR 0 4
126263: PPUSH
126264: CALL_OW 263
126268: PUSH
126269: LD_INT 1
126271: EQUAL
126272: IFFALSE 126286
126274: PUSH
126275: LD_VAR 0 4
126279: PPUSH
126280: CALL_OW 311
126284: NOT
126285: AND
126286: IFFALSE 126353
// begin un := mechs [ 1 ] ;
126288: LD_ADDR_VAR 0 10
126292: PUSH
126293: LD_VAR 0 12
126297: PUSH
126298: LD_INT 1
126300: ARRAY
126301: ST_TO_ADDR
// ComExit ( un ) ;
126302: LD_VAR 0 10
126306: PPUSH
126307: CALL 93071 0 1
// AddComEnterUnit ( un , i ) ;
126311: LD_VAR 0 10
126315: PPUSH
126316: LD_VAR 0 4
126320: PPUSH
126321: CALL_OW 180
// SetTag ( un , 19 ) ;
126325: LD_VAR 0 10
126329: PPUSH
126330: LD_INT 19
126332: PPUSH
126333: CALL_OW 109
// mechs := mechs diff un ;
126337: LD_ADDR_VAR 0 12
126341: PUSH
126342: LD_VAR 0 12
126346: PUSH
126347: LD_VAR 0 10
126351: DIFF
126352: ST_TO_ADDR
// end ; end ;
126353: GO 126229
126355: POP
126356: POP
// if solds then
126357: LD_VAR 0 8
126361: IFFALSE 126420
// for i in solds do
126363: LD_ADDR_VAR 0 4
126367: PUSH
126368: LD_VAR 0 8
126372: PUSH
126373: FOR_IN
126374: IFFALSE 126418
// if not GetTag ( i ) then
126376: LD_VAR 0 4
126380: PPUSH
126381: CALL_OW 110
126385: NOT
126386: IFFALSE 126416
// begin defenders := defenders union i ;
126388: LD_ADDR_VAR 0 2
126392: PUSH
126393: LD_VAR 0 2
126397: PUSH
126398: LD_VAR 0 4
126402: UNION
126403: ST_TO_ADDR
// SetTag ( i , 18 ) ;
126404: LD_VAR 0 4
126408: PPUSH
126409: LD_INT 18
126411: PPUSH
126412: CALL_OW 109
// end ;
126416: GO 126373
126418: POP
126419: POP
// repeat wait ( 0 0$2 ) ;
126420: LD_INT 70
126422: PPUSH
126423: CALL_OW 67
// enemy := mc_scan [ base ] ;
126427: LD_ADDR_VAR 0 21
126431: PUSH
126432: LD_EXP 103
126436: PUSH
126437: LD_VAR 0 1
126441: ARRAY
126442: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126443: LD_EXP 80
126447: PUSH
126448: LD_VAR 0 1
126452: ARRAY
126453: NOT
126454: IFTRUE 126471
126456: PUSH
126457: LD_EXP 80
126461: PUSH
126462: LD_VAR 0 1
126466: ARRAY
126467: PUSH
126468: EMPTY
126469: EQUAL
126470: OR
126471: IFFALSE 126508
// begin for i in defenders do
126473: LD_ADDR_VAR 0 4
126477: PUSH
126478: LD_VAR 0 2
126482: PUSH
126483: FOR_IN
126484: IFFALSE 126497
// ComStop ( i ) ;
126486: LD_VAR 0 4
126490: PPUSH
126491: CALL_OW 141
126495: GO 126483
126497: POP
126498: POP
// defenders := [ ] ;
126499: LD_ADDR_VAR 0 2
126503: PUSH
126504: EMPTY
126505: ST_TO_ADDR
// exit ;
126506: GO 128005
// end ; for i in defenders do
126508: LD_ADDR_VAR 0 4
126512: PUSH
126513: LD_VAR 0 2
126517: PUSH
126518: FOR_IN
126519: IFFALSE 127453
// begin e := NearestUnitToUnit ( enemy , i ) ;
126521: LD_ADDR_VAR 0 13
126525: PUSH
126526: LD_VAR 0 21
126530: PPUSH
126531: LD_VAR 0 4
126535: PPUSH
126536: CALL_OW 74
126540: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
126541: LD_ADDR_VAR 0 7
126545: PUSH
126546: LD_EXP 80
126550: PUSH
126551: LD_VAR 0 1
126555: ARRAY
126556: PPUSH
126557: LD_INT 2
126559: PUSH
126560: LD_INT 30
126562: PUSH
126563: LD_INT 0
126565: PUSH
126566: EMPTY
126567: LIST
126568: LIST
126569: PUSH
126570: LD_INT 30
126572: PUSH
126573: LD_INT 1
126575: PUSH
126576: EMPTY
126577: LIST
126578: LIST
126579: PUSH
126580: EMPTY
126581: LIST
126582: LIST
126583: LIST
126584: PPUSH
126585: CALL_OW 72
126589: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
126590: LD_ADDR_VAR 0 16
126594: PUSH
126595: LD_VAR 0 7
126599: NOT
126600: IFTRUE 126630
126602: PUSH
126603: LD_VAR 0 7
126607: PPUSH
126608: LD_INT 3
126610: PUSH
126611: LD_INT 24
126613: PUSH
126614: LD_INT 600
126616: PUSH
126617: EMPTY
126618: LIST
126619: LIST
126620: PUSH
126621: EMPTY
126622: LIST
126623: LIST
126624: PPUSH
126625: CALL_OW 72
126629: OR
126630: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
126631: LD_VAR 0 4
126635: PPUSH
126636: CALL_OW 247
126640: PUSH
126641: LD_INT 2
126643: DOUBLE
126644: EQUAL
126645: IFTRUE 126649
126647: GO 127065
126649: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
126650: LD_VAR 0 4
126654: PPUSH
126655: CALL_OW 256
126659: PUSH
126660: LD_INT 1000
126662: EQUAL
126663: IFFALSE 126709
126665: PUSH
126666: LD_VAR 0 4
126670: PPUSH
126671: LD_VAR 0 13
126675: PPUSH
126676: CALL_OW 296
126680: PUSH
126681: LD_INT 40
126683: LESS
126684: IFTRUE 126708
126686: PUSH
126687: LD_VAR 0 13
126691: PPUSH
126692: LD_EXP 105
126696: PUSH
126697: LD_VAR 0 1
126701: ARRAY
126702: PPUSH
126703: CALL_OW 308
126707: OR
126708: AND
126709: IFFALSE 126835
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
126711: LD_VAR 0 4
126715: PPUSH
126716: CALL_OW 262
126720: PUSH
126721: LD_INT 1
126723: EQUAL
126724: IFFALSE 126741
126726: PUSH
126727: LD_VAR 0 4
126731: PPUSH
126732: CALL_OW 261
126736: PUSH
126737: LD_INT 30
126739: LESS
126740: AND
126741: IFFALSE 126749
126743: PUSH
126744: LD_VAR 0 7
126748: AND
126749: IFFALSE 126819
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
126751: LD_VAR 0 4
126755: PPUSH
126756: LD_VAR 0 7
126760: PPUSH
126761: LD_VAR 0 4
126765: PPUSH
126766: CALL_OW 74
126770: PPUSH
126771: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
126775: LD_VAR 0 4
126779: PPUSH
126780: LD_VAR 0 7
126784: PPUSH
126785: LD_VAR 0 4
126789: PPUSH
126790: CALL_OW 74
126794: PPUSH
126795: CALL_OW 296
126799: PUSH
126800: LD_INT 6
126802: LESS
126803: IFFALSE 126817
// SetFuel ( i , 100 ) ;
126805: LD_VAR 0 4
126809: PPUSH
126810: LD_INT 100
126812: PPUSH
126813: CALL_OW 240
// end else
126817: GO 126833
// ComAttackUnit ( i , e ) ;
126819: LD_VAR 0 4
126823: PPUSH
126824: LD_VAR 0 13
126828: PPUSH
126829: CALL_OW 115
// end else
126833: GO 126942
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
126835: LD_VAR 0 13
126839: PPUSH
126840: LD_EXP 105
126844: PUSH
126845: LD_VAR 0 1
126849: ARRAY
126850: PPUSH
126851: CALL_OW 308
126855: NOT
126856: IFFALSE 126878
126858: PUSH
126859: LD_VAR 0 4
126863: PPUSH
126864: LD_VAR 0 13
126868: PPUSH
126869: CALL_OW 296
126873: PUSH
126874: LD_INT 40
126876: GREATEREQUAL
126877: AND
126878: IFTRUE 126895
126880: PUSH
126881: LD_VAR 0 4
126885: PPUSH
126886: CALL_OW 256
126890: PUSH
126891: LD_INT 650
126893: LESSEQUAL
126894: OR
126895: IFFALSE 126920
126897: PUSH
126898: LD_VAR 0 4
126902: PPUSH
126903: LD_EXP 104
126907: PUSH
126908: LD_VAR 0 1
126912: ARRAY
126913: PPUSH
126914: CALL_OW 308
126918: NOT
126919: AND
126920: IFFALSE 126942
// ComMoveToArea ( i , mc_parking [ base ] ) ;
126922: LD_VAR 0 4
126926: PPUSH
126927: LD_EXP 104
126931: PUSH
126932: LD_VAR 0 1
126936: ARRAY
126937: PPUSH
126938: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
126942: LD_VAR 0 4
126946: PPUSH
126947: CALL_OW 256
126951: PUSH
126952: LD_INT 1000
126954: LESS
126955: IFFALSE 126972
126957: PUSH
126958: LD_VAR 0 4
126962: PPUSH
126963: CALL_OW 263
126967: PUSH
126968: LD_INT 1
126970: EQUAL
126971: AND
126972: IFFALSE 126985
126974: PUSH
126975: LD_VAR 0 4
126979: PPUSH
126980: CALL_OW 311
126984: AND
126985: IFFALSE 127009
126987: PUSH
126988: LD_VAR 0 4
126992: PPUSH
126993: LD_EXP 104
126997: PUSH
126998: LD_VAR 0 1
127002: ARRAY
127003: PPUSH
127004: CALL_OW 308
127008: AND
127009: IFFALSE 127063
// begin mech := IsDrivenBy ( i ) ;
127011: LD_ADDR_VAR 0 9
127015: PUSH
127016: LD_VAR 0 4
127020: PPUSH
127021: CALL_OW 311
127025: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
127026: LD_VAR 0 9
127030: PPUSH
127031: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
127035: LD_VAR 0 9
127039: PPUSH
127040: LD_VAR 0 4
127044: PPUSH
127045: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
127049: LD_VAR 0 9
127053: PPUSH
127054: LD_VAR 0 4
127058: PPUSH
127059: CALL_OW 180
// end ; end ; unit_human :
127063: GO 127424
127065: LD_INT 1
127067: DOUBLE
127068: EQUAL
127069: IFTRUE 127073
127071: GO 127423
127073: POP
// begin b := IsInUnit ( i ) ;
127074: LD_ADDR_VAR 0 18
127078: PUSH
127079: LD_VAR 0 4
127083: PPUSH
127084: CALL_OW 310
127088: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
127089: LD_ADDR_VAR 0 19
127093: PUSH
127094: LD_VAR 0 18
127098: NOT
127099: IFTRUE 127123
127101: PUSH
127102: LD_VAR 0 18
127106: PPUSH
127107: CALL_OW 266
127111: PUSH
127112: LD_INT 32
127114: PUSH
127115: LD_INT 31
127117: PUSH
127118: EMPTY
127119: LIST
127120: LIST
127121: IN
127122: OR
127123: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
127124: LD_VAR 0 18
127128: PPUSH
127129: CALL_OW 266
127133: PUSH
127134: LD_INT 5
127136: EQUAL
127137: IFFALSE 127169
127139: PUSH
127140: LD_VAR 0 4
127144: PPUSH
127145: CALL_OW 257
127149: PUSH
127150: LD_INT 1
127152: PUSH
127153: LD_INT 2
127155: PUSH
127156: LD_INT 3
127158: PUSH
127159: LD_INT 4
127161: PUSH
127162: EMPTY
127163: LIST
127164: LIST
127165: LIST
127166: LIST
127167: IN
127168: AND
127169: IFFALSE 127206
// begin class := AllowSpecClass ( i ) ;
127171: LD_ADDR_VAR 0 20
127175: PUSH
127176: LD_VAR 0 4
127180: PPUSH
127181: CALL 56381 0 1
127185: ST_TO_ADDR
// if class then
127186: LD_VAR 0 20
127190: IFFALSE 127206
// ComChangeProfession ( i , class ) ;
127192: LD_VAR 0 4
127196: PPUSH
127197: LD_VAR 0 20
127201: PPUSH
127202: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
127206: LD_VAR 0 16
127210: IFTRUE 127237
127212: PUSH
127213: LD_VAR 0 2
127217: PPUSH
127218: LD_INT 21
127220: PUSH
127221: LD_INT 2
127223: PUSH
127224: EMPTY
127225: LIST
127226: LIST
127227: PPUSH
127228: CALL_OW 72
127232: PUSH
127233: LD_INT 1
127235: LESSEQUAL
127236: OR
127237: IFFALSE 127245
127239: PUSH
127240: LD_VAR 0 19
127244: AND
127245: IFFALSE 127260
127247: PUSH
127248: LD_VAR 0 4
127252: PUSH
127253: LD_VAR 0 17
127257: IN
127258: NOT
127259: AND
127260: IFFALSE 127355
// begin if b then
127262: LD_VAR 0 18
127266: IFFALSE 127317
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
127268: LD_VAR 0 18
127272: PPUSH
127273: LD_VAR 0 21
127277: PPUSH
127278: LD_VAR 0 18
127282: PPUSH
127283: CALL_OW 74
127287: PPUSH
127288: CALL_OW 296
127292: PUSH
127293: LD_INT 10
127295: LESS
127296: IFFALSE 127313
127298: PUSH
127299: LD_VAR 0 18
127303: PPUSH
127304: CALL_OW 461
127308: PUSH
127309: LD_INT 7
127311: NONEQUAL
127312: AND
127313: IFFALSE 127317
// continue ;
127315: GO 126518
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
127317: LD_ADDR_VAR 0 17
127321: PUSH
127322: LD_VAR 0 17
127326: PPUSH
127327: LD_VAR 0 17
127331: PUSH
127332: LD_INT 1
127334: PLUS
127335: PPUSH
127336: LD_VAR 0 4
127340: PPUSH
127341: CALL_OW 1
127345: ST_TO_ADDR
// ComExitBuilding ( i ) ;
127346: LD_VAR 0 4
127350: PPUSH
127351: CALL_OW 122
// end ; if sold_defenders then
127355: LD_VAR 0 17
127359: IFFALSE 127421
// if i in sold_defenders then
127361: LD_VAR 0 4
127365: PUSH
127366: LD_VAR 0 17
127370: IN
127371: IFFALSE 127421
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
127373: LD_VAR 0 4
127377: PPUSH
127378: CALL_OW 314
127382: NOT
127383: IFFALSE 127405
127385: PUSH
127386: LD_VAR 0 4
127390: PPUSH
127391: LD_VAR 0 13
127395: PPUSH
127396: CALL_OW 296
127400: PUSH
127401: LD_INT 30
127403: LESS
127404: AND
127405: IFFALSE 127421
// ComAttackUnit ( i , e ) ;
127407: LD_VAR 0 4
127411: PPUSH
127412: LD_VAR 0 13
127416: PPUSH
127417: CALL_OW 115
// end ; end ; end ;
127421: GO 127424
127423: POP
// if IsDead ( i ) then
127424: LD_VAR 0 4
127428: PPUSH
127429: CALL_OW 301
127433: IFFALSE 127451
// defenders := defenders diff i ;
127435: LD_ADDR_VAR 0 2
127439: PUSH
127440: LD_VAR 0 2
127444: PUSH
127445: LD_VAR 0 4
127449: DIFF
127450: ST_TO_ADDR
// end ;
127451: GO 126518
127453: POP
127454: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
127455: LD_VAR 0 21
127459: NOT
127460: IFTRUE 127469
127462: PUSH
127463: LD_VAR 0 2
127467: NOT
127468: OR
127469: IFTRUE 127484
127471: PUSH
127472: LD_EXP 80
127476: PUSH
127477: LD_VAR 0 1
127481: ARRAY
127482: NOT
127483: OR
127484: IFFALSE 126420
// MC_Reset ( base , 18 ) ;
127486: LD_VAR 0 1
127490: PPUSH
127491: LD_INT 18
127493: PPUSH
127494: CALL 27580 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
127498: LD_ADDR_VAR 0 2
127502: PUSH
127503: LD_VAR 0 2
127507: PUSH
127508: LD_VAR 0 2
127512: PPUSH
127513: LD_INT 2
127515: PUSH
127516: LD_INT 25
127518: PUSH
127519: LD_INT 1
127521: PUSH
127522: EMPTY
127523: LIST
127524: LIST
127525: PUSH
127526: LD_INT 25
127528: PUSH
127529: LD_INT 5
127531: PUSH
127532: EMPTY
127533: LIST
127534: LIST
127535: PUSH
127536: LD_INT 25
127538: PUSH
127539: LD_INT 8
127541: PUSH
127542: EMPTY
127543: LIST
127544: LIST
127545: PUSH
127546: LD_INT 25
127548: PUSH
127549: LD_INT 9
127551: PUSH
127552: EMPTY
127553: LIST
127554: LIST
127555: PUSH
127556: EMPTY
127557: LIST
127558: LIST
127559: LIST
127560: LIST
127561: LIST
127562: PPUSH
127563: CALL_OW 72
127567: DIFF
127568: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
127569: LD_VAR 0 21
127573: NOT
127574: IFFALSE 127597
127576: PUSH
127577: LD_VAR 0 2
127581: PPUSH
127582: LD_INT 21
127584: PUSH
127585: LD_INT 2
127587: PUSH
127588: EMPTY
127589: LIST
127590: LIST
127591: PPUSH
127592: CALL_OW 72
127596: AND
127597: IFFALSE 127941
// begin tmp := FilterByTag ( defenders , 19 ) ;
127599: LD_ADDR_VAR 0 11
127603: PUSH
127604: LD_VAR 0 2
127608: PPUSH
127609: LD_INT 19
127611: PPUSH
127612: CALL 90218 0 2
127616: ST_TO_ADDR
// if tmp then
127617: LD_VAR 0 11
127621: IFFALSE 127691
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
127623: LD_ADDR_VAR 0 11
127627: PUSH
127628: LD_VAR 0 11
127632: PPUSH
127633: LD_INT 25
127635: PUSH
127636: LD_INT 3
127638: PUSH
127639: EMPTY
127640: LIST
127641: LIST
127642: PPUSH
127643: CALL_OW 72
127647: ST_TO_ADDR
// if tmp then
127648: LD_VAR 0 11
127652: IFFALSE 127691
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
127654: LD_ADDR_EXP 92
127658: PUSH
127659: LD_EXP 92
127663: PPUSH
127664: LD_VAR 0 1
127668: PPUSH
127669: LD_EXP 92
127673: PUSH
127674: LD_VAR 0 1
127678: ARRAY
127679: PUSH
127680: LD_VAR 0 11
127684: UNION
127685: PPUSH
127686: CALL_OW 1
127690: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
127691: LD_VAR 0 1
127695: PPUSH
127696: LD_INT 19
127698: PPUSH
127699: CALL 27580 0 2
// repeat wait ( 0 0$1 ) ;
127703: LD_INT 35
127705: PPUSH
127706: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
127710: LD_EXP 80
127714: PUSH
127715: LD_VAR 0 1
127719: ARRAY
127720: NOT
127721: IFTRUE 127738
127723: PUSH
127724: LD_EXP 80
127728: PUSH
127729: LD_VAR 0 1
127733: ARRAY
127734: PUSH
127735: EMPTY
127736: EQUAL
127737: OR
127738: IFFALSE 127775
// begin for i in defenders do
127740: LD_ADDR_VAR 0 4
127744: PUSH
127745: LD_VAR 0 2
127749: PUSH
127750: FOR_IN
127751: IFFALSE 127764
// ComStop ( i ) ;
127753: LD_VAR 0 4
127757: PPUSH
127758: CALL_OW 141
127762: GO 127750
127764: POP
127765: POP
// defenders := [ ] ;
127766: LD_ADDR_VAR 0 2
127770: PUSH
127771: EMPTY
127772: ST_TO_ADDR
// exit ;
127773: GO 128005
// end ; for i in defenders do
127775: LD_ADDR_VAR 0 4
127779: PUSH
127780: LD_VAR 0 2
127784: PUSH
127785: FOR_IN
127786: IFFALSE 127875
// begin if not IsInArea ( i , mc_parking [ base ] ) then
127788: LD_VAR 0 4
127792: PPUSH
127793: LD_EXP 104
127797: PUSH
127798: LD_VAR 0 1
127802: ARRAY
127803: PPUSH
127804: CALL_OW 308
127808: NOT
127809: IFFALSE 127833
// ComMoveToArea ( i , mc_parking [ base ] ) else
127811: LD_VAR 0 4
127815: PPUSH
127816: LD_EXP 104
127820: PUSH
127821: LD_VAR 0 1
127825: ARRAY
127826: PPUSH
127827: CALL_OW 113
127831: GO 127873
// if GetControl ( i ) = control_manual then
127833: LD_VAR 0 4
127837: PPUSH
127838: CALL_OW 263
127842: PUSH
127843: LD_INT 1
127845: EQUAL
127846: IFFALSE 127873
// if IsDrivenBy ( i ) then
127848: LD_VAR 0 4
127852: PPUSH
127853: CALL_OW 311
127857: IFFALSE 127873
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
127859: LD_VAR 0 4
127863: PPUSH
127864: CALL_OW 311
127868: PPUSH
127869: CALL_OW 121
// end ;
127873: GO 127785
127875: POP
127876: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
127877: LD_VAR 0 2
127881: PPUSH
127882: LD_INT 95
127884: PUSH
127885: LD_EXP 104
127889: PUSH
127890: LD_VAR 0 1
127894: ARRAY
127895: PUSH
127896: EMPTY
127897: LIST
127898: LIST
127899: PPUSH
127900: CALL_OW 72
127904: PUSH
127905: LD_VAR 0 2
127909: EQUAL
127910: IFTRUE 127924
127912: PUSH
127913: LD_EXP 103
127917: PUSH
127918: LD_VAR 0 1
127922: ARRAY
127923: OR
127924: IFTRUE 127939
127926: PUSH
127927: LD_EXP 80
127931: PUSH
127932: LD_VAR 0 1
127936: ARRAY
127937: NOT
127938: OR
127939: IFFALSE 127703
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
127941: LD_ADDR_EXP 102
127945: PUSH
127946: LD_EXP 102
127950: PPUSH
127951: LD_VAR 0 1
127955: PPUSH
127956: LD_VAR 0 2
127960: PPUSH
127961: LD_INT 21
127963: PUSH
127964: LD_INT 2
127966: PUSH
127967: EMPTY
127968: LIST
127969: LIST
127970: PPUSH
127971: CALL_OW 72
127975: PPUSH
127976: CALL_OW 1
127980: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
127981: LD_VAR 0 1
127985: PPUSH
127986: LD_INT 19
127988: PPUSH
127989: CALL 27580 0 2
// MC_Reset ( base , 20 ) ;
127993: LD_VAR 0 1
127997: PPUSH
127998: LD_INT 20
128000: PPUSH
128001: CALL 27580 0 2
// end ; end_of_file
128005: LD_VAR 0 3
128009: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
128010: LD_VAR 0 1
128014: PUSH
128015: LD_INT 200
128017: DOUBLE
128018: GREATEREQUAL
128019: IFFALSE 128027
128021: LD_INT 299
128023: DOUBLE
128024: LESSEQUAL
128025: IFTRUE 128029
128027: GO 128061
128029: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
128030: LD_VAR 0 1
128034: PPUSH
128035: LD_VAR 0 2
128039: PPUSH
128040: LD_VAR 0 3
128044: PPUSH
128045: LD_VAR 0 4
128049: PPUSH
128050: LD_VAR 0 5
128054: PPUSH
128055: CALL 114863 0 5
128059: GO 128138
128061: LD_INT 300
128063: DOUBLE
128064: GREATEREQUAL
128065: IFFALSE 128073
128067: LD_INT 399
128069: DOUBLE
128070: LESSEQUAL
128071: IFTRUE 128075
128073: GO 128137
128075: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
128076: LD_VAR 0 1
128080: PPUSH
128081: LD_VAR 0 2
128085: PPUSH
128086: LD_VAR 0 3
128090: PPUSH
128091: LD_VAR 0 4
128095: PPUSH
128096: LD_VAR 0 5
128100: PPUSH
128101: LD_VAR 0 6
128105: PPUSH
128106: LD_VAR 0 7
128110: PPUSH
128111: LD_VAR 0 8
128115: PPUSH
128116: LD_VAR 0 9
128120: PPUSH
128121: LD_VAR 0 10
128125: PPUSH
128126: LD_VAR 0 11
128130: PPUSH
128131: CALL 110666 0 11
128135: GO 128138
128137: POP
// end ;
128138: PPOPN 11
128140: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
128141: LD_VAR 0 1
128145: PPUSH
128146: LD_VAR 0 2
128150: PPUSH
128151: LD_VAR 0 3
128155: PPUSH
128156: LD_VAR 0 4
128160: PPUSH
128161: LD_VAR 0 5
128165: PPUSH
128166: CALL 114163 0 5
// end ; end_of_file
128170: PPOPN 5
128172: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
128173: LD_VAR 0 1
128177: PPUSH
128178: LD_VAR 0 2
128182: PPUSH
128183: LD_VAR 0 3
128187: PPUSH
128188: LD_VAR 0 4
128192: PPUSH
128193: LD_VAR 0 5
128197: PPUSH
128198: LD_VAR 0 6
128202: PPUSH
128203: CALL 98206 0 6
// end ;
128207: PPOPN 6
128209: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
128210: LD_INT 0
128212: PPUSH
// begin if not units then
128213: LD_VAR 0 1
128217: NOT
128218: IFFALSE 128222
// exit ;
128220: GO 128256
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
128222: LD_VAR 0 1
128226: PPUSH
128227: LD_VAR 0 2
128231: PPUSH
128232: LD_VAR 0 3
128236: PPUSH
128237: LD_VAR 0 4
128241: PPUSH
128242: LD_VAR 0 5
128246: PPUSH
128247: LD_VAR 0 6
128251: PPUSH
128252: CALL 120560 0 6
// end ;
128256: PPOPN 7
128258: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
128259: CALL 98086 0 0
// end ;
128263: PPOPN 1
128265: END
