// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20578 0 0
// InitNature ;
  19: CALL 17140 0 0
// InitArtifact ;
  23: CALL 17753 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4579 0 0
// PrepareAlliance ;
  44: CALL 1375 0 0
// PrepareArabian ;
  48: CALL 6347 0 0
// PrepareRussian ;
  52: CALL 8332 0 0
// PrepareLegion ;
  56: CALL 6775 0 0
// Action ;
  60: CALL 10885 0 0
// MC_Start ( ) ;
  64: CALL 22690 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// export function CustomInitMacro ( ) ; begin
 213: LD_INT 0
 215: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 216: LD_ADDR_EXP 111
 220: PUSH
 221: LD_INT 26
 223: PUSH
 224: LD_INT 1
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 8
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 239: LD_ADDR_EXP 112
 243: PUSH
 244: LD_INT 27
 246: PUSH
 247: LD_INT 2
 249: PUSH
 250: LD_INT 3
 252: PUSH
 253: LD_INT 7
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 262: LD_INT 1
 264: PPUSH
 265: LD_INT 6
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: LD_INT 9
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: PPUSH
 285: LD_INT 28
 287: PPUSH
 288: CALL 43891 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 10
 297: PUSH
 298: LD_INT 11
 300: PUSH
 301: LD_INT 13
 303: PUSH
 304: LD_INT 15
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL 44951 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 29
 322: PUSH
 323: EMPTY
 324: LIST
 325: PPUSH
 326: CALL 45044 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 330: LD_ADDR_EXP 116
 334: PUSH
 335: LD_EXP 116
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 2
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 25
 355: PUSH
 356: LD_INT 15
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PPUSH
 367: CALL_OW 69
 371: PPUSH
 372: CALL_OW 1
 376: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 377: LD_INT 1
 379: PPUSH
 380: LD_INT 13
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 1
 388: PUSH
 389: LD_INT 31
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: PUSH
 398: LD_INT 13
 400: PUSH
 401: LD_INT 2
 403: PUSH
 404: LD_INT 1
 406: PUSH
 407: LD_INT 31
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 13
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 1
 424: PUSH
 425: LD_INT 28
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 13
 436: PUSH
 437: LD_INT 1
 439: PUSH
 440: LD_INT 1
 442: PUSH
 443: LD_INT 28
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_INT 13
 454: PUSH
 455: LD_INT 1
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: LD_INT 28
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: PUSH
 470: LD_INT 13
 472: PUSH
 473: LD_INT 1
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: LD_INT 28
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: LIST
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PPUSH
 496: CALL 44209 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 500: LD_INT 1
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL 44394 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 510: LD_INT 2
 512: PPUSH
 513: LD_INT 10
 515: PUSH
 516: LD_INT 11
 518: PUSH
 519: LD_INT 12
 521: PUSH
 522: LD_INT 14
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PPUSH
 531: CALL 44951 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 14
 540: PUSH
 541: EMPTY
 542: LIST
 543: PPUSH
 544: CALL 45044 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 21
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 51
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 22
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 52
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 22
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 3
 595: PUSH
 596: LD_INT 52
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 3
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 24
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 3
 631: PUSH
 632: LD_INT 47
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 47
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 24
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 47
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 24
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 3
 685: PUSH
 686: LD_INT 47
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: LIST
 703: LIST
 704: PPUSH
 705: CALL 44209 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 709: LD_INT 2
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL 44394 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 719: LD_INT 2
 721: PPUSH
 722: LD_INT 0
 724: PPUSH
 725: CALL 44824 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 729: LD_INT 3
 731: PPUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PPUSH
 752: LD_INT 24
 754: PPUSH
 755: CALL 43891 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 759: LD_INT 3
 761: PPUSH
 762: LD_INT 10
 764: PUSH
 765: LD_INT 11
 767: PUSH
 768: LD_INT 13
 770: PUSH
 771: LD_INT 15
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: LIST
 779: PPUSH
 780: CALL 44951 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 13
 789: PUSH
 790: EMPTY
 791: LIST
 792: PPUSH
 793: CALL 45044 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 797: LD_ADDR_EXP 116
 801: PUSH
 802: LD_EXP 116
 806: PPUSH
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 22
 812: PUSH
 813: LD_INT 8
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 25
 822: PUSH
 823: LD_INT 15
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: CALL_OW 1
 843: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 844: LD_INT 3
 846: PPUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 31
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 13
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 32
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_INT 14
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: LD_INT 28
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 14
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 28
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 14
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: LD_INT 28
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 14
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 28
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PPUSH
 982: CALL 44209 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 986: LD_INT 3
 988: PPUSH
 989: LD_INT 4
 991: PPUSH
 992: CALL 44394 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: LD_INT 11
1007: PUSH
1008: LD_INT 15
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL 44951 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1021: LD_INT 4
1023: PPUSH
1024: LD_INT 33
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL 45044 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1034: LD_INT 4
1036: PPUSH
1037: LD_INT 5
1039: PUSH
1040: LD_INT 6
1042: PUSH
1043: LD_INT 7
1045: PUSH
1046: LD_INT 9
1048: PUSH
1049: LD_INT 10
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PPUSH
1059: CALL 45362 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1063: LD_INT 4
1065: PPUSH
1066: LD_INT 54
1068: PPUSH
1069: LD_INT 85
1071: PPUSH
1072: LD_INT 2
1074: PPUSH
1075: LD_INT 25
1077: PUSH
1078: LD_INT 16
1080: PUSH
1081: LD_INT 17
1083: PUSH
1084: LD_INT 18
1086: PUSH
1087: LD_INT 22
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: LIST
1096: PPUSH
1097: CALL 45156 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1101: LD_INT 4
1103: PPUSH
1104: LD_INT 5
1106: PUSH
1107: LD_INT 1
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: LD_INT 7
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 1
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: LD_INT 6
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 5
1142: PUSH
1143: LD_INT 1
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: LD_INT 7
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 6
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 3
1184: PUSH
1185: LD_INT 12
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 3
1202: PUSH
1203: LD_INT 13
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PPUSH
1220: CALL 44209 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1224: LD_INT 4
1226: PPUSH
1227: LD_INT 4
1229: PPUSH
1230: CALL 44394 0 2
// MC_SetTame ( 4 , powellApe ) ;
1234: LD_INT 4
1236: PPUSH
1237: LD_INT 11
1239: PPUSH
1240: CALL 44775 0 2
// end ;
1244: LD_VAR 0 1
1248: RET
// every 0 0$1 trigger debug do var i ;
1249: LD_EXP 1
1253: IFFALSE 1351
1255: GO 1257
1257: DISABLE
1258: LD_INT 0
1260: PPUSH
// begin enable ;
1261: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1262: LD_ADDR_VAR 0 1
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 7
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 21
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: LD_INT 24
1310: PUSH
1311: LD_INT 1000
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL_OW 69
1331: PUSH
1332: FOR_IN
1333: IFFALSE 1349
// SetLives ( i , 1000 ) ;
1335: LD_VAR 0 1
1339: PPUSH
1340: LD_INT 1000
1342: PPUSH
1343: CALL_OW 234
1347: GO 1332
1349: POP
1350: POP
// end ;
1351: PPOPN 1
1353: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1354: LD_EXP 16
1358: PUSH
1359: LD_INT 5
1361: GREATEREQUAL
1362: IFFALSE 1374
1364: GO 1366
1366: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1367: LD_STRING ACH_ARTIFACT
1369: PPUSH
1370: CALL_OW 543
1374: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// uc_side := 7 ;
1382: LD_ADDR_OWVAR 20
1386: PUSH
1387: LD_INT 7
1389: ST_TO_ADDR
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 5
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1397: LD_ADDR_EXP 17
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: LD_STRING 14a_
1413: PPUSH
1414: CALL 50601 0 3
1418: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1419: LD_ADDR_EXP 49
1423: PUSH
1424: LD_STRING Burlak
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 14a_
1435: PPUSH
1436: CALL 50601 0 3
1440: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1441: LD_ADDR_EXP 32
1445: PUSH
1446: LD_STRING Joan
1448: PPUSH
1449: LD_EXP 1
1453: NOT
1454: PPUSH
1455: LD_STRING 13a_
1457: PPUSH
1458: CALL 50601 0 3
1462: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 18
1467: PUSH
1468: LD_STRING Roth
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 50601 0 3
1484: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1485: LD_ADDR_EXP 35
1489: PUSH
1490: LD_STRING Gossudarov
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 13a_
1501: PPUSH
1502: CALL 50601 0 3
1506: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_STRING Denis
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 50601 0 3
1528: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1529: LD_ADDR_EXP 33
1533: PUSH
1534: LD_STRING DeltaDoctor
1536: PPUSH
1537: LD_EXP 1
1541: NOT
1542: PPUSH
1543: LD_STRING 13a_
1545: PPUSH
1546: CALL 50601 0 3
1550: ST_TO_ADDR
// if DeltaDoctor then
1551: LD_EXP 33
1555: IFFALSE 1573
// tmp := tmp ^ DeltaDoctor ;
1557: LD_ADDR_VAR 0 5
1561: PUSH
1562: LD_VAR 0 5
1566: PUSH
1567: LD_EXP 33
1571: ADD
1572: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 13a_
1589: PPUSH
1590: CALL 50601 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 31
1599: IFFALSE 1617
// tmp := tmp ^ Simms ;
1601: LD_ADDR_VAR 0 5
1605: PUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_EXP 31
1615: ADD
1616: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1617: LD_ADDR_EXP 29
1621: PUSH
1622: LD_STRING Frank
1624: PPUSH
1625: LD_EXP 1
1629: NOT
1630: PPUSH
1631: LD_STRING 13a_
1633: PPUSH
1634: CALL 50601 0 3
1638: ST_TO_ADDR
// if Frank then
1639: LD_EXP 29
1643: IFFALSE 1661
// tmp := tmp ^ Frank ;
1645: LD_ADDR_VAR 0 5
1649: PUSH
1650: LD_VAR 0 5
1654: PUSH
1655: LD_EXP 29
1659: ADD
1660: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1661: LD_ADDR_EXP 36
1665: PUSH
1666: LD_STRING Kirilenkova
1668: PPUSH
1669: LD_EXP 1
1673: NOT
1674: PPUSH
1675: LD_STRING 13a_
1677: PPUSH
1678: CALL 50601 0 3
1682: ST_TO_ADDR
// if Kirilenkova then
1683: LD_EXP 36
1687: IFFALSE 1705
// tmp := tmp ^ Kirilenkova ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_VAR 0 5
1698: PUSH
1699: LD_EXP 36
1703: ADD
1704: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1705: LD_ADDR_EXP 37
1709: PUSH
1710: LD_STRING Titov
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 13a_
1721: PPUSH
1722: CALL 50601 0 3
1726: ST_TO_ADDR
// if Titov then
1727: LD_EXP 37
1731: IFFALSE 1749
// tmp := tmp ^ Titov ;
1733: LD_ADDR_VAR 0 5
1737: PUSH
1738: LD_VAR 0 5
1742: PUSH
1743: LD_EXP 37
1747: ADD
1748: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Fadeev
1756: PPUSH
1757: LD_EXP 1
1761: NOT
1762: PPUSH
1763: LD_STRING 13a_
1765: PPUSH
1766: CALL 50601 0 3
1770: ST_TO_ADDR
// if Fadeev then
1771: LD_EXP 38
1775: IFFALSE 1793
// tmp := tmp ^ Fadeev ;
1777: LD_ADDR_VAR 0 5
1781: PUSH
1782: LD_VAR 0 5
1786: PUSH
1787: LD_EXP 38
1791: ADD
1792: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1793: LD_ADDR_EXP 39
1797: PUSH
1798: LD_STRING Dolgov
1800: PPUSH
1801: LD_EXP 1
1805: NOT
1806: PPUSH
1807: LD_STRING 13a_
1809: PPUSH
1810: CALL 50601 0 3
1814: ST_TO_ADDR
// if Dolgov then
1815: LD_EXP 39
1819: IFFALSE 1837
// tmp := tmp ^ Dolgov ;
1821: LD_ADDR_VAR 0 5
1825: PUSH
1826: LD_VAR 0 5
1830: PUSH
1831: LD_EXP 39
1835: ADD
1836: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING Petrosyan
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 13a_
1853: PPUSH
1854: CALL 50601 0 3
1858: ST_TO_ADDR
// if Petrosyan then
1859: LD_EXP 40
1863: IFFALSE 1881
// tmp := tmp ^ Petrosyan ;
1865: LD_ADDR_VAR 0 5
1869: PUSH
1870: LD_VAR 0 5
1874: PUSH
1875: LD_EXP 40
1879: ADD
1880: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1881: LD_ADDR_EXP 41
1885: PUSH
1886: LD_STRING Scholtze
1888: PPUSH
1889: LD_EXP 1
1893: NOT
1894: PPUSH
1895: LD_STRING 13a_
1897: PPUSH
1898: CALL 50601 0 3
1902: ST_TO_ADDR
// if Scholtze then
1903: LD_EXP 41
1907: IFFALSE 1925
// tmp := tmp ^ Scholtze ;
1909: LD_ADDR_VAR 0 5
1913: PUSH
1914: LD_VAR 0 5
1918: PUSH
1919: LD_EXP 41
1923: ADD
1924: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1925: LD_ADDR_EXP 42
1929: PUSH
1930: LD_STRING Oblukov
1932: PPUSH
1933: LD_EXP 1
1937: NOT
1938: PPUSH
1939: LD_STRING 13a_
1941: PPUSH
1942: CALL 50601 0 3
1946: ST_TO_ADDR
// if Oblukov then
1947: LD_EXP 42
1951: IFFALSE 1969
// tmp := tmp ^ Oblukov ;
1953: LD_ADDR_VAR 0 5
1957: PUSH
1958: LD_VAR 0 5
1962: PUSH
1963: LD_EXP 42
1967: ADD
1968: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1969: LD_ADDR_EXP 43
1973: PUSH
1974: LD_STRING Kapitsova
1976: PPUSH
1977: LD_EXP 1
1981: NOT
1982: PPUSH
1983: LD_STRING 13a_
1985: PPUSH
1986: CALL 50601 0 3
1990: ST_TO_ADDR
// if Kapitsova then
1991: LD_EXP 43
1995: IFFALSE 2013
// tmp := tmp ^ Kapitsova ;
1997: LD_ADDR_VAR 0 5
2001: PUSH
2002: LD_VAR 0 5
2006: PUSH
2007: LD_EXP 43
2011: ADD
2012: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2013: LD_ADDR_EXP 44
2017: PUSH
2018: LD_STRING Lipshchin
2020: PPUSH
2021: LD_EXP 1
2025: NOT
2026: PPUSH
2027: LD_STRING 13a_
2029: PPUSH
2030: CALL 50601 0 3
2034: ST_TO_ADDR
// if Lipshchin then
2035: LD_EXP 44
2039: IFFALSE 2057
// tmp := tmp ^ Lipshchin ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 5
2050: PUSH
2051: LD_EXP 44
2055: ADD
2056: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2057: LD_ADDR_EXP 45
2061: PUSH
2062: LD_STRING Petrovova
2064: PPUSH
2065: LD_EXP 1
2069: NOT
2070: PPUSH
2071: LD_STRING 13a_
2073: PPUSH
2074: CALL 50601 0 3
2078: ST_TO_ADDR
// if Petrovova then
2079: LD_EXP 45
2083: IFFALSE 2101
// tmp := tmp ^ Petrovova ;
2085: LD_ADDR_VAR 0 5
2089: PUSH
2090: LD_VAR 0 5
2094: PUSH
2095: LD_EXP 45
2099: ADD
2100: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2101: LD_ADDR_EXP 46
2105: PUSH
2106: LD_STRING Kovalyuk
2108: PPUSH
2109: LD_EXP 1
2113: NOT
2114: PPUSH
2115: LD_STRING 13a_
2117: PPUSH
2118: CALL 50601 0 3
2122: ST_TO_ADDR
// if Kovalyuk then
2123: LD_EXP 46
2127: IFFALSE 2145
// tmp := tmp ^ Kovalyuk ;
2129: LD_ADDR_VAR 0 5
2133: PUSH
2134: LD_VAR 0 5
2138: PUSH
2139: LD_EXP 46
2143: ADD
2144: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2145: LD_ADDR_EXP 47
2149: PUSH
2150: LD_STRING Kuzmov
2152: PPUSH
2153: LD_EXP 1
2157: NOT
2158: PPUSH
2159: LD_STRING 13a_
2161: PPUSH
2162: CALL 50601 0 3
2166: ST_TO_ADDR
// if Kuzmov then
2167: LD_EXP 47
2171: IFFALSE 2189
// tmp := tmp ^ Kuzmov ;
2173: LD_ADDR_VAR 0 5
2177: PUSH
2178: LD_VAR 0 5
2182: PUSH
2183: LD_EXP 47
2187: ADD
2188: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2189: LD_ADDR_EXP 48
2193: PUSH
2194: LD_STRING Karamazov
2196: PPUSH
2197: LD_EXP 1
2201: NOT
2202: PPUSH
2203: LD_STRING 13a_
2205: PPUSH
2206: CALL 50601 0 3
2210: ST_TO_ADDR
// if Karamazov then
2211: LD_EXP 48
2215: IFFALSE 2233
// tmp := tmp ^ Karamazov ;
2217: LD_ADDR_VAR 0 5
2221: PUSH
2222: LD_VAR 0 5
2226: PUSH
2227: LD_EXP 48
2231: ADD
2232: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 50
2237: PUSH
2238: LD_STRING Belkov
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 50601 0 3
2254: ST_TO_ADDR
// if Belkov then
2255: LD_EXP 50
2259: IFFALSE 2277
// tmp := tmp ^ Belkov ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 50
2275: ADD
2276: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2277: LD_ADDR_EXP 51
2281: PUSH
2282: LD_STRING Gnyevko
2284: PPUSH
2285: LD_EXP 1
2289: NOT
2290: PPUSH
2291: LD_STRING 13a_
2293: PPUSH
2294: CALL 50601 0 3
2298: ST_TO_ADDR
// if Gnyevko then
2299: LD_EXP 51
2303: IFFALSE 2321
// tmp := tmp ^ Gnyevko ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 51
2319: ADD
2320: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2321: LD_ADDR_EXP 34
2325: PUSH
2326: LD_STRING Coonie
2328: PPUSH
2329: CALL_OW 25
2333: ST_TO_ADDR
// if not Lisa then
2334: LD_EXP 19
2338: NOT
2339: IFFALSE 2385
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2341: LD_ADDR_EXP 19
2345: PUSH
2346: LD_STRING Lisa
2348: PPUSH
2349: LD_EXP 1
2353: NOT
2354: PPUSH
2355: LD_STRING 13a_
2357: PPUSH
2358: CALL 50601 0 3
2362: ST_TO_ADDR
// if Lisa then
2363: LD_EXP 19
2367: IFFALSE 2385
// tmp := tmp ^ Lisa ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_EXP 19
2383: ADD
2384: ST_TO_ADDR
// end ; if not Donaldson then
2385: LD_EXP 20
2389: NOT
2390: IFFALSE 2436
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2392: LD_ADDR_EXP 20
2396: PUSH
2397: LD_STRING Donaldson
2399: PPUSH
2400: LD_EXP 1
2404: NOT
2405: PPUSH
2406: LD_STRING 13a_
2408: PPUSH
2409: CALL 50601 0 3
2413: ST_TO_ADDR
// if Donaldson then
2414: LD_EXP 20
2418: IFFALSE 2436
// tmp := tmp ^ Donaldson ;
2420: LD_ADDR_VAR 0 5
2424: PUSH
2425: LD_VAR 0 5
2429: PUSH
2430: LD_EXP 20
2434: ADD
2435: ST_TO_ADDR
// end ; if not Bobby then
2436: LD_EXP 21
2440: NOT
2441: IFFALSE 2487
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2443: LD_ADDR_EXP 21
2447: PUSH
2448: LD_STRING Bobby
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_STRING 13a_
2459: PPUSH
2460: CALL 50601 0 3
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 21
2469: IFFALSE 2487
// tmp := tmp ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 21
2485: ADD
2486: ST_TO_ADDR
// end ; if not Cyrus then
2487: LD_EXP 22
2491: NOT
2492: IFFALSE 2538
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2494: LD_ADDR_EXP 22
2498: PUSH
2499: LD_STRING Cyrus
2501: PPUSH
2502: LD_EXP 1
2506: NOT
2507: PPUSH
2508: LD_STRING 13a_
2510: PPUSH
2511: CALL 50601 0 3
2515: ST_TO_ADDR
// if Cyrus then
2516: LD_EXP 22
2520: IFFALSE 2538
// tmp := tmp ^ Cyrus ;
2522: LD_ADDR_VAR 0 5
2526: PUSH
2527: LD_VAR 0 5
2531: PUSH
2532: LD_EXP 22
2536: ADD
2537: ST_TO_ADDR
// end ; if not Brown then
2538: LD_EXP 24
2542: NOT
2543: IFFALSE 2589
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2545: LD_ADDR_EXP 24
2549: PUSH
2550: LD_STRING Brown
2552: PPUSH
2553: LD_EXP 1
2557: NOT
2558: PPUSH
2559: LD_STRING 13a_
2561: PPUSH
2562: CALL 50601 0 3
2566: ST_TO_ADDR
// if Brown then
2567: LD_EXP 24
2571: IFFALSE 2589
// tmp := tmp ^ Brown ;
2573: LD_ADDR_VAR 0 5
2577: PUSH
2578: LD_VAR 0 5
2582: PUSH
2583: LD_EXP 24
2587: ADD
2588: ST_TO_ADDR
// end ; if not Gladstone then
2589: LD_EXP 25
2593: NOT
2594: IFFALSE 2640
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2596: LD_ADDR_EXP 25
2600: PUSH
2601: LD_STRING Gladstone
2603: PPUSH
2604: LD_EXP 1
2608: NOT
2609: PPUSH
2610: LD_STRING 13a_
2612: PPUSH
2613: CALL 50601 0 3
2617: ST_TO_ADDR
// if Gladstone then
2618: LD_EXP 25
2622: IFFALSE 2640
// tmp := tmp ^ Gladstone ;
2624: LD_ADDR_VAR 0 5
2628: PUSH
2629: LD_VAR 0 5
2633: PUSH
2634: LD_EXP 25
2638: ADD
2639: ST_TO_ADDR
// end ; if not Cornel then
2640: LD_EXP 27
2644: NOT
2645: IFFALSE 2691
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2647: LD_ADDR_EXP 27
2651: PUSH
2652: LD_STRING Cornel
2654: PPUSH
2655: LD_EXP 1
2659: NOT
2660: PPUSH
2661: LD_STRING 13a_
2663: PPUSH
2664: CALL 50601 0 3
2668: ST_TO_ADDR
// if Cornel then
2669: LD_EXP 27
2673: IFFALSE 2691
// tmp := tmp ^ Cornel ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_EXP 27
2689: ADD
2690: ST_TO_ADDR
// end ; if not Houten then
2691: LD_EXP 26
2695: NOT
2696: IFFALSE 2742
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2698: LD_ADDR_EXP 26
2702: PUSH
2703: LD_STRING Houten
2705: PPUSH
2706: LD_EXP 1
2710: NOT
2711: PPUSH
2712: LD_STRING 13a_
2714: PPUSH
2715: CALL 50601 0 3
2719: ST_TO_ADDR
// if Houten then
2720: LD_EXP 26
2724: IFFALSE 2742
// tmp := tmp ^ Houten ;
2726: LD_ADDR_VAR 0 5
2730: PUSH
2731: LD_VAR 0 5
2735: PUSH
2736: LD_EXP 26
2740: ADD
2741: ST_TO_ADDR
// end ; if not Gary then
2742: LD_EXP 28
2746: NOT
2747: IFFALSE 2793
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2749: LD_ADDR_EXP 28
2753: PUSH
2754: LD_STRING Gary
2756: PPUSH
2757: LD_EXP 1
2761: NOT
2762: PPUSH
2763: LD_STRING 13a_
2765: PPUSH
2766: CALL 50601 0 3
2770: ST_TO_ADDR
// if Gary then
2771: LD_EXP 28
2775: IFFALSE 2793
// tmp := tmp ^ Gary ;
2777: LD_ADDR_VAR 0 5
2781: PUSH
2782: LD_VAR 0 5
2786: PUSH
2787: LD_EXP 28
2791: ADD
2792: ST_TO_ADDR
// end ; if not Kikuchi then
2793: LD_EXP 30
2797: NOT
2798: IFFALSE 2844
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2800: LD_ADDR_EXP 30
2804: PUSH
2805: LD_STRING Kikuchi
2807: PPUSH
2808: LD_EXP 1
2812: NOT
2813: PPUSH
2814: LD_STRING 13a_
2816: PPUSH
2817: CALL 50601 0 3
2821: ST_TO_ADDR
// if Kikuchi then
2822: LD_EXP 30
2826: IFFALSE 2844
// tmp := tmp ^ Kikuchi ;
2828: LD_ADDR_VAR 0 5
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: LD_EXP 30
2842: ADD
2843: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_VAR 0 5
2853: PUSH
2854: LD_STRING 13a_others
2856: PPUSH
2857: CALL_OW 31
2861: UNION
2862: ST_TO_ADDR
// tmp := tmp diff 0 ;
2863: LD_ADDR_VAR 0 5
2867: PUSH
2868: LD_VAR 0 5
2872: PUSH
2873: LD_INT 0
2875: DIFF
2876: ST_TO_ADDR
// if tmp < 15 then
2877: LD_VAR 0 5
2881: PUSH
2882: LD_INT 15
2884: LESS
2885: IFFALSE 2973
// for i = 15 downto tmp do
2887: LD_ADDR_VAR 0 2
2891: PUSH
2892: DOUBLE
2893: LD_INT 15
2895: INC
2896: ST_TO_ADDR
2897: LD_VAR 0 5
2901: PUSH
2902: FOR_DOWNTO
2903: IFFALSE 2971
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2905: LD_ADDR_OWVAR 21
2909: PUSH
2910: LD_INT 1
2912: PUSH
2913: LD_INT 3
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: CALL_OW 12
2930: ARRAY
2931: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2932: LD_INT 0
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 4
2940: PPUSH
2941: CALL_OW 12
2945: PPUSH
2946: LD_INT 8
2948: PPUSH
2949: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2953: LD_ADDR_VAR 0 5
2957: PUSH
2958: LD_VAR 0 5
2962: PUSH
2963: CALL_OW 44
2967: ADD
2968: ST_TO_ADDR
// end ;
2969: GO 2902
2971: POP
2972: POP
// if not debug then
2973: LD_EXP 1
2977: NOT
2978: IFFALSE 3150
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2980: LD_ADDR_VAR 0 4
2984: PUSH
2985: LD_STRING 
2987: PPUSH
2988: LD_INT 15
2990: PUSH
2991: LD_INT 14
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: LD_OWVAR 67
3006: ARRAY
3007: PPUSH
3008: LD_INT 15
3010: PUSH
3011: LD_INT 14
3013: PUSH
3014: LD_INT 13
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_OWVAR 67
3026: ARRAY
3027: PPUSH
3028: LD_INT -6
3030: PUSH
3031: LD_EXP 17
3035: PUSH
3036: LD_EXP 49
3040: PUSH
3041: LD_EXP 18
3045: PUSH
3046: LD_EXP 32
3050: PUSH
3051: LD_EXP 23
3055: PUSH
3056: LD_EXP 35
3060: PUSH
3061: LD_INT -2
3063: PUSH
3064: LD_INT -3
3066: PUSH
3067: LD_INT -5
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: LD_VAR 0 5
3086: ADD
3087: PPUSH
3088: LD_INT 1
3090: PUSH
3091: LD_INT 4
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: LD_INT 5
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 9
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 3
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 42
3147: ST_TO_ADDR
3148: GO 3229
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3150: LD_ADDR_VAR 0 4
3154: PUSH
3155: LD_EXP 37
3159: PUSH
3160: LD_EXP 38
3164: PUSH
3165: LD_EXP 39
3169: PUSH
3170: LD_EXP 40
3174: PUSH
3175: LD_EXP 41
3179: PUSH
3180: LD_EXP 42
3184: PUSH
3185: LD_EXP 43
3189: PUSH
3190: LD_EXP 44
3194: PUSH
3195: LD_EXP 45
3199: PUSH
3200: LD_EXP 46
3204: PUSH
3205: LD_EXP 47
3209: PUSH
3210: LD_EXP 48
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3237: LD_INT 5
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: LD_INT 6
3248: PPUSH
3249: LD_INT 100
3251: PPUSH
3252: CALL 55425 0 5
// veh := CreateVehicle ;
3256: LD_ADDR_VAR 0 3
3260: PUSH
3261: CALL_OW 45
3265: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3266: LD_VAR 0 3
3270: PPUSH
3271: LD_INT 7
3273: NEG
3274: PPUSH
3275: CALL_OW 242
// SetDir ( veh , 3 ) ;
3279: LD_VAR 0 3
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3291: LD_VAR 0 3
3295: PPUSH
3296: LD_INT 31
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3306: LD_EXP 17
3310: PPUSH
3311: LD_VAR 0 3
3315: PPUSH
3316: CALL_OW 52
// if Joan then
3320: LD_EXP 32
3324: IFFALSE 3396
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3326: LD_INT 3
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: LD_INT 1
3334: PPUSH
3335: LD_INT 11
3337: PPUSH
3338: LD_INT 100
3340: PPUSH
3341: CALL 55425 0 5
// veh := CreateVehicle ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL_OW 45
3354: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3355: LD_VAR 0 3
3359: PPUSH
3360: LD_INT 3
3362: PPUSH
3363: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3367: LD_VAR 0 3
3371: PPUSH
3372: LD_INT 30
3374: PPUSH
3375: LD_INT 0
3377: PPUSH
3378: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3382: LD_EXP 32
3386: PPUSH
3387: LD_VAR 0 3
3391: PPUSH
3392: CALL_OW 52
// end ; if Roth then
3396: LD_EXP 18
3400: IFFALSE 3472
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3402: LD_INT 3
3404: PPUSH
3405: LD_INT 3
3407: PPUSH
3408: LD_INT 1
3410: PPUSH
3411: LD_INT 11
3413: PPUSH
3414: LD_INT 100
3416: PPUSH
3417: CALL 55425 0 5
// veh := CreateVehicle ;
3421: LD_ADDR_VAR 0 3
3425: PUSH
3426: CALL_OW 45
3430: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3431: LD_VAR 0 3
3435: PPUSH
3436: LD_INT 3
3438: PPUSH
3439: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3443: LD_VAR 0 3
3447: PPUSH
3448: LD_INT 30
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3458: LD_EXP 18
3462: PPUSH
3463: LD_VAR 0 3
3467: PPUSH
3468: CALL_OW 52
// end ; if Denis then
3472: LD_EXP 23
3476: IFFALSE 3548
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3478: LD_INT 5
3480: PPUSH
3481: LD_INT 3
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 9
3489: PPUSH
3490: LD_INT 100
3492: PPUSH
3493: CALL 55425 0 5
// veh := CreateVehicle ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: CALL_OW 45
3506: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3507: LD_VAR 0 3
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3519: LD_VAR 0 3
3523: PPUSH
3524: LD_INT 30
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3534: LD_EXP 23
3538: PPUSH
3539: LD_VAR 0 3
3543: PPUSH
3544: CALL_OW 52
// end ; uc_nation := 3 ;
3548: LD_ADDR_OWVAR 21
3552: PUSH
3553: LD_INT 3
3555: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3556: LD_INT 22
3558: PPUSH
3559: LD_INT 3
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 45
3567: PPUSH
3568: LD_INT 100
3570: PPUSH
3571: CALL 55425 0 5
// veh := CreateVehicle ;
3575: LD_ADDR_VAR 0 3
3579: PUSH
3580: CALL_OW 45
3584: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3585: LD_VAR 0 3
3589: PPUSH
3590: LD_INT 7
3592: NEG
3593: PPUSH
3594: CALL_OW 242
// SetDir ( veh , 3 ) ;
3598: LD_VAR 0 3
3602: PPUSH
3603: LD_INT 3
3605: PPUSH
3606: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3610: LD_VAR 0 3
3614: PPUSH
3615: LD_INT 31
3617: PPUSH
3618: LD_INT 0
3620: PPUSH
3621: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3625: LD_EXP 49
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL_OW 52
// if Gossudarov then
3639: LD_EXP 35
3643: IFFALSE 3730
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3645: LD_INT 22
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_INT 51
3656: PPUSH
3657: LD_INT 100
3659: PPUSH
3660: CALL 55425 0 5
// veh := CreateVehicle ;
3664: LD_ADDR_VAR 0 3
3668: PUSH
3669: CALL_OW 45
3673: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3674: LD_VAR 0 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3686: LD_VAR 0 3
3690: PPUSH
3691: LD_INT 30
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3701: LD_EXP 35
3705: PPUSH
3706: LD_VAR 0 3
3710: PPUSH
3711: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3715: LD_VAR 0 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_INT 100
3725: PPUSH
3726: CALL_OW 290
// end ; for i in selected do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: PUSH
3740: FOR_IN
3741: IFFALSE 4299
// begin uc_nation := GetNation ( i ) ;
3743: LD_ADDR_OWVAR 21
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 248
3757: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_EXP 19
3767: PUSH
3768: LD_EXP 20
3772: PUSH
3773: LD_EXP 22
3777: PUSH
3778: LD_EXP 21
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3812
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3791: LD_INT 5
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 6
3802: PPUSH
3803: LD_INT 100
3805: PPUSH
3806: CALL 55425 0 5
3810: GO 4246
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3812: LD_VAR 0 2
3816: PUSH
3817: LD_EXP 42
3821: PUSH
3822: LD_EXP 47
3826: PUSH
3827: LD_EXP 45
3831: PUSH
3832: LD_EXP 37
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: IN
3843: IFFALSE 3874
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3845: LD_INT 24
3847: PPUSH
3848: LD_INT 1
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 46
3856: PPUSH
3857: LD_INT 65
3859: PPUSH
3860: LD_INT 75
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL 55425 0 5
3872: GO 4246
// if i = Karamazov then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 48
3883: EQUAL
3884: IFFALSE 3907
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3886: LD_INT 22
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: LD_INT 1
3894: PPUSH
3895: LD_INT 52
3897: PPUSH
3898: LD_INT 100
3900: PPUSH
3901: CALL 55425 0 5
3905: GO 4246
// if i = Brown then
3907: LD_VAR 0 2
3911: PUSH
3912: LD_EXP 24
3916: EQUAL
3917: IFFALSE 3940
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 13
3930: PPUSH
3931: LD_INT 100
3933: PPUSH
3934: CALL 55425 0 5
3938: GO 4246
// if uc_nation = nation_american then
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 1
3947: EQUAL
3948: IFFALSE 4099
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3950: LD_INT 3
3952: PUSH
3953: LD_INT 5
3955: PUSH
3956: LD_INT 5
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 21
3968: PUSH
3969: LD_INT 3
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 1
3980: PUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: LIST
3991: PUSH
3992: LD_OWVAR 21
3996: PUSH
3997: LD_INT 3
3999: MOD
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: ARRAY
4005: PPUSH
4006: LD_INT 1
4008: PPUSH
4009: LD_INT 11
4011: PUSH
4012: LD_INT 4
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: PUSH
4023: LD_INT 6
4025: PUSH
4026: LD_INT 7
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 6
4039: PUSH
4040: LD_INT 9
4042: PUSH
4043: LD_INT 12
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_OWVAR 21
4060: PUSH
4061: LD_INT 3
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 3
4075: PPUSH
4076: CALL_OW 12
4080: ARRAY
4081: PPUSH
4082: LD_INT 65
4084: PPUSH
4085: LD_INT 75
4087: PPUSH
4088: CALL_OW 12
4092: PPUSH
4093: CALL 55425 0 5
// end else
4097: GO 4246
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4099: LD_INT 22
4101: PUSH
4102: LD_INT 23
4104: PUSH
4105: LD_INT 23
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_OWVAR 21
4117: PUSH
4118: LD_INT 3
4120: MOD
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: ARRAY
4126: PPUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: PUSH
4141: LD_OWVAR 21
4145: PUSH
4146: LD_INT 3
4148: MOD
4149: PUSH
4150: LD_INT 1
4152: PLUS
4153: ARRAY
4154: PPUSH
4155: LD_INT 1
4157: PPUSH
4158: LD_INT 45
4160: PUSH
4161: LD_INT 43
4163: PUSH
4164: LD_INT 44
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 46
4174: PUSH
4175: LD_INT 45
4177: PUSH
4178: LD_INT 44
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 46
4188: PUSH
4189: LD_INT 43
4191: PUSH
4192: LD_INT 45
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: LD_OWVAR 21
4209: PUSH
4210: LD_INT 3
4212: MOD
4213: PUSH
4214: LD_INT 1
4216: PLUS
4217: ARRAY
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 65
4233: PPUSH
4234: LD_INT 75
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 55425 0 5
// end ; veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4256: LD_VAR 0 3
4260: PPUSH
4261: LD_INT 3
4263: PPUSH
4264: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4268: LD_VAR 0 3
4272: PPUSH
4273: LD_INT 30
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 52
// end ;
4297: GO 3740
4299: POP
4300: POP
// if artifactArCaptured then
4301: LD_EXP 9
4305: IFFALSE 4391
// begin uc_nation := nation_american ;
4307: LD_ADDR_OWVAR 21
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4315: LD_INT 3
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: LD_INT 3
4323: PPUSH
4324: LD_INT 12
4326: PPUSH
4327: LD_INT 100
4329: PPUSH
4330: CALL 55425 0 5
// veh := CreateVehicle ;
4334: LD_ADDR_VAR 0 3
4338: PUSH
4339: CALL_OW 45
4343: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_INT 3
4351: PPUSH
4352: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4356: LD_VAR 0 3
4360: PPUSH
4361: LD_INT 198
4363: PPUSH
4364: LD_INT 22
4366: PPUSH
4367: LD_INT 0
4369: PPUSH
4370: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4374: LD_VAR 0 3
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: LD_INT 50
4384: PPUSH
4385: CALL_OW 290
// end else
4389: GO 4410
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4391: LD_INT 4
4393: PPUSH
4394: LD_INT 267
4396: PPUSH
4397: LD_INT 226
4399: PPUSH
4400: LD_INT 5
4402: PPUSH
4403: LD_INT 0
4405: PPUSH
4406: CALL_OW 58
// end ; uc_nation := nation_american ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 1
4417: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4418: LD_INT 3
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 3
4426: PPUSH
4427: LD_INT 12
4429: PPUSH
4430: LD_INT 100
4432: PPUSH
4433: CALL 55425 0 5
// veh := CreateVehicle ;
4437: LD_ADDR_VAR 0 3
4441: PUSH
4442: CALL_OW 45
4446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4447: LD_VAR 0 3
4451: PPUSH
4452: LD_INT 3
4454: PPUSH
4455: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 218
4466: PPUSH
4467: LD_INT 23
4469: PPUSH
4470: LD_INT 0
4472: PPUSH
4473: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4477: LD_VAR 0 3
4481: PPUSH
4482: LD_INT 4
4484: PPUSH
4485: LD_INT 30
4487: PPUSH
4488: CALL_OW 290
// uc_nation := nation_russian ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4500: LD_INT 22
4502: PPUSH
4503: LD_INT 3
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: LD_INT 51
4511: PPUSH
4512: LD_INT 100
4514: PPUSH
4515: CALL 55425 0 5
// veh := CreateVehicle ;
4519: LD_ADDR_VAR 0 3
4523: PUSH
4524: CALL_OW 45
4528: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4529: LD_VAR 0 3
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_INT 214
4548: PPUSH
4549: LD_INT 20
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 4
4566: PPUSH
4567: LD_INT 40
4569: PPUSH
4570: CALL_OW 290
// end ; end_of_file
4574: LD_VAR 0 1
4578: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4579: LD_INT 0
4581: PPUSH
4582: PPUSH
4583: PPUSH
4584: PPUSH
4585: PPUSH
4586: PPUSH
4587: PPUSH
4588: PPUSH
4589: PPUSH
4590: PPUSH
// InitHc ;
4591: CALL_OW 19
// uc_side := 1 ;
4595: LD_ADDR_OWVAR 20
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// uc_nation := 1 ;
4603: LD_ADDR_OWVAR 21
4607: PUSH
4608: LD_INT 1
4610: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4611: LD_ADDR_VAR 0 2
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: LD_INT 21
4628: PUSH
4629: LD_INT 3
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: PUSH
4645: FOR_IN
4646: IFFALSE 4662
// SetBLevel ( i , 10 ) ;
4648: LD_VAR 0 2
4652: PPUSH
4653: LD_INT 10
4655: PPUSH
4656: CALL_OW 241
4660: GO 4645
4662: POP
4663: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4664: LD_INT 387
4666: PPUSH
4667: CALL_OW 274
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_INT 7500
4677: PPUSH
4678: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4682: LD_INT 387
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 2
4692: PPUSH
4693: LD_INT 4000
4695: PPUSH
4696: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4700: LD_INT 387
4702: PPUSH
4703: CALL_OW 274
4707: PPUSH
4708: LD_INT 3
4710: PPUSH
4711: LD_INT 50
4713: PPUSH
4714: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4718: LD_INT 476
4720: PPUSH
4721: CALL_OW 274
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: LD_INT 5500
4731: PPUSH
4732: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4736: LD_INT 476
4738: PPUSH
4739: CALL_OW 274
4743: PPUSH
4744: LD_INT 2
4746: PPUSH
4747: LD_INT 4000
4749: PPUSH
4750: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4754: LD_INT 476
4756: PPUSH
4757: CALL_OW 274
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4772: LD_ADDR_EXP 52
4776: PUSH
4777: LD_STRING Powell
4779: PPUSH
4780: CALL_OW 25
4784: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4785: LD_EXP 52
4789: PPUSH
4790: LD_INT 387
4792: PPUSH
4793: CALL_OW 52
// tmp := [ ] ;
4797: LD_ADDR_VAR 0 6
4801: PUSH
4802: EMPTY
4803: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4804: LD_ADDR_EXP 19
4808: PUSH
4809: LD_STRING Lisa
4811: PPUSH
4812: LD_EXP 1
4816: NOT
4817: PPUSH
4818: LD_STRING 12p_
4820: PPUSH
4821: CALL 50601 0 3
4825: ST_TO_ADDR
// if Lisa then
4826: LD_EXP 19
4830: IFFALSE 4848
// tmp := tmp ^ Lisa ;
4832: LD_ADDR_VAR 0 6
4836: PUSH
4837: LD_VAR 0 6
4841: PUSH
4842: LD_EXP 19
4846: ADD
4847: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4848: LD_ADDR_EXP 20
4852: PUSH
4853: LD_STRING Donaldson
4855: PPUSH
4856: LD_EXP 1
4860: NOT
4861: PPUSH
4862: LD_STRING 12p_
4864: PPUSH
4865: CALL 50601 0 3
4869: ST_TO_ADDR
// if Donaldson then
4870: LD_EXP 20
4874: IFFALSE 4892
// tmp := tmp ^ Donaldson ;
4876: LD_ADDR_VAR 0 6
4880: PUSH
4881: LD_VAR 0 6
4885: PUSH
4886: LD_EXP 20
4890: ADD
4891: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4892: LD_ADDR_EXP 21
4896: PUSH
4897: LD_STRING Bobby
4899: PPUSH
4900: LD_EXP 1
4904: NOT
4905: PPUSH
4906: LD_STRING 12p_
4908: PPUSH
4909: CALL 50601 0 3
4913: ST_TO_ADDR
// if Bobby then
4914: LD_EXP 21
4918: IFFALSE 4936
// tmp := tmp ^ Bobby ;
4920: LD_ADDR_VAR 0 6
4924: PUSH
4925: LD_VAR 0 6
4929: PUSH
4930: LD_EXP 21
4934: ADD
4935: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4936: LD_ADDR_EXP 22
4940: PUSH
4941: LD_STRING Cyrus
4943: PPUSH
4944: LD_EXP 1
4948: NOT
4949: PPUSH
4950: LD_STRING 12p_
4952: PPUSH
4953: CALL 50601 0 3
4957: ST_TO_ADDR
// if Cyrus then
4958: LD_EXP 22
4962: IFFALSE 4980
// tmp := tmp ^ Cyrus ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_VAR 0 6
4973: PUSH
4974: LD_EXP 22
4978: ADD
4979: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4980: LD_ADDR_EXP 24
4984: PUSH
4985: LD_STRING Brown
4987: PPUSH
4988: LD_EXP 1
4992: NOT
4993: PPUSH
4994: LD_STRING 12p_
4996: PPUSH
4997: CALL 50601 0 3
5001: ST_TO_ADDR
// if Brown then
5002: LD_EXP 24
5006: IFFALSE 5024
// tmp := tmp ^ Brown ;
5008: LD_ADDR_VAR 0 6
5012: PUSH
5013: LD_VAR 0 6
5017: PUSH
5018: LD_EXP 24
5022: ADD
5023: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5024: LD_ADDR_EXP 25
5028: PUSH
5029: LD_STRING Gladstone
5031: PPUSH
5032: LD_EXP 1
5036: NOT
5037: PPUSH
5038: LD_STRING 12p_
5040: PPUSH
5041: CALL 50601 0 3
5045: ST_TO_ADDR
// if Gladstone then
5046: LD_EXP 25
5050: IFFALSE 5068
// tmp := tmp ^ Gladstone ;
5052: LD_ADDR_VAR 0 6
5056: PUSH
5057: LD_VAR 0 6
5061: PUSH
5062: LD_EXP 25
5066: ADD
5067: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5068: LD_ADDR_EXP 26
5072: PUSH
5073: LD_STRING Houten
5075: PPUSH
5076: LD_EXP 1
5080: NOT
5081: PPUSH
5082: LD_STRING 12p_
5084: PPUSH
5085: CALL 50601 0 3
5089: ST_TO_ADDR
// if Houten then
5090: LD_EXP 26
5094: IFFALSE 5112
// tmp := tmp ^ Houten ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: LD_VAR 0 6
5105: PUSH
5106: LD_EXP 26
5110: ADD
5111: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5112: LD_ADDR_EXP 27
5116: PUSH
5117: LD_STRING Cornel
5119: PPUSH
5120: LD_EXP 1
5124: NOT
5125: PPUSH
5126: LD_STRING 12p_
5128: PPUSH
5129: CALL 50601 0 3
5133: ST_TO_ADDR
// if Cornel then
5134: LD_EXP 27
5138: IFFALSE 5156
// tmp := tmp ^ Cornel ;
5140: LD_ADDR_VAR 0 6
5144: PUSH
5145: LD_VAR 0 6
5149: PUSH
5150: LD_EXP 27
5154: ADD
5155: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5156: LD_ADDR_EXP 28
5160: PUSH
5161: LD_STRING Gary
5163: PPUSH
5164: LD_EXP 1
5168: NOT
5169: PPUSH
5170: LD_STRING 12p_
5172: PPUSH
5173: CALL 50601 0 3
5177: ST_TO_ADDR
// if Gary then
5178: LD_EXP 28
5182: IFFALSE 5200
// tmp := tmp ^ Gary ;
5184: LD_ADDR_VAR 0 6
5188: PUSH
5189: LD_VAR 0 6
5193: PUSH
5194: LD_EXP 28
5198: ADD
5199: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5200: LD_ADDR_EXP 30
5204: PUSH
5205: LD_STRING Kikuchi
5207: PPUSH
5208: LD_EXP 1
5212: NOT
5213: PPUSH
5214: LD_STRING 12p_
5216: PPUSH
5217: CALL 50601 0 3
5221: ST_TO_ADDR
// if Kikuchi then
5222: LD_EXP 30
5226: IFFALSE 5244
// tmp := tmp ^ Kikuchi ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_VAR 0 6
5237: PUSH
5238: LD_EXP 30
5242: ADD
5243: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5244: LD_ADDR_VAR 0 6
5248: PUSH
5249: LD_VAR 0 6
5253: PUSH
5254: LD_STRING 12p_others
5256: PPUSH
5257: CALL_OW 31
5261: UNION
5262: ST_TO_ADDR
// if tmp < 36 then
5263: LD_VAR 0 6
5267: PUSH
5268: LD_INT 36
5270: LESS
5271: IFFALSE 5338
// for i = 1 to 36 - tmp do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 36
5285: PUSH
5286: LD_VAR 0 6
5290: MINUS
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5336
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5295: LD_INT 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: MOD
5306: PUSH
5307: LD_INT 1
5309: PLUS
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5318: LD_ADDR_VAR 0 6
5322: PUSH
5323: LD_VAR 0 6
5327: PUSH
5328: CALL_OW 44
5332: ADD
5333: ST_TO_ADDR
// end ;
5334: GO 5292
5336: POP
5337: POP
// for i in tmp do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_VAR 0 6
5347: PUSH
5348: FOR_IN
5349: IFFALSE 5374
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5351: LD_VAR 0 2
5355: PPUSH
5356: LD_INT 62
5358: PPUSH
5359: LD_INT 93
5361: PPUSH
5362: LD_INT 9
5364: PPUSH
5365: LD_INT 0
5367: PPUSH
5368: CALL_OW 50
5372: GO 5348
5374: POP
5375: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5376: LD_ADDR_EXP 87
5380: PUSH
5381: LD_EXP 87
5385: PPUSH
5386: LD_INT 4
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 1
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_EXP 52
5408: DIFF
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// uc_side := 0 ;
5415: LD_ADDR_OWVAR 20
5419: PUSH
5420: LD_INT 0
5422: ST_TO_ADDR
// uc_nation := 0 ;
5423: LD_ADDR_OWVAR 21
5427: PUSH
5428: LD_INT 0
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5476
// begin InitHc ;
5447: CALL_OW 19
// hc_class := class_apeman ;
5451: LD_ADDR_OWVAR 28
5455: PUSH
5456: LD_INT 12
5458: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5459: CALL_OW 44
5463: PPUSH
5464: LD_INT 11
5466: PPUSH
5467: LD_INT 0
5469: PPUSH
5470: CALL_OW 49
// end ;
5474: GO 5444
5476: POP
5477: POP
// end ;
5478: LD_VAR 0 1
5482: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5483: LD_EXP 4
5487: NOT
5488: PUSH
5489: LD_INT 4
5491: PPUSH
5492: LD_INT 1
5494: PPUSH
5495: CALL 45675 0 2
5499: NOT
5500: AND
5501: IFFALSE 6273
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
// begin enable ;
5511: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5512: LD_INT 22
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 23
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: LD_INT 30
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PPUSH
5547: CALL_OW 69
5551: NOT
5552: IFFALSE 5556
// exit ;
5554: GO 6273
// if Prob ( 40 ) then
5556: LD_INT 40
5558: PPUSH
5559: CALL_OW 13
5563: IFFALSE 5690
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5565: LD_INT 4
5567: PPUSH
5568: LD_INT 5
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 7
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 5
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: LD_INT 7
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 7
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 5
5624: PUSH
5625: LD_INT 1
5627: PUSH
5628: LD_INT 2
5630: PUSH
5631: LD_INT 6
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 6
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: PUSH
5658: LD_INT 5
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL 44257 0 2
// end else
5688: GO 5813
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5690: LD_INT 4
5692: PPUSH
5693: LD_INT 5
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 7
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 5
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 2
5719: PUSH
5720: LD_INT 9
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 9
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 6
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 5
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 6
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL 44257 0 2
// end ; repeat wait ( 0 0$1 ) ;
5813: LD_INT 35
5815: PPUSH
5816: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5820: LD_INT 4
5822: PPUSH
5823: LD_INT 1
5825: PPUSH
5826: CALL 45675 0 2
5830: PUSH
5831: LD_INT 6
5833: GREATEREQUAL
5834: IFFALSE 5813
// wait ( 0 0$30 ) ;
5836: LD_INT 1050
5838: PPUSH
5839: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 4
5850: PPUSH
5851: LD_INT 1
5853: PPUSH
5854: CALL 45675 0 2
5858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5859: LD_ADDR_EXP 106
5863: PUSH
5864: LD_EXP 106
5868: PPUSH
5869: LD_INT 4
5871: PPUSH
5872: LD_EXP 106
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: LD_VAR 0 2
5885: DIFF
5886: PPUSH
5887: CALL_OW 1
5891: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_INT 0
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: CALL_OW 12
5907: ST_TO_ADDR
// if target then
5908: LD_VAR 0 3
5912: IFFALSE 6040
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5914: LD_ADDR_VAR 0 2
5918: PUSH
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 24
5926: PUSH
5927: LD_INT 250
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 72
5938: ST_TO_ADDR
// for i in tmp do
5939: LD_ADDR_VAR 0 1
5943: PUSH
5944: LD_VAR 0 2
5948: PUSH
5949: FOR_IN
5950: IFFALSE 5990
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5952: LD_VAR 0 1
5956: PPUSH
5957: LD_INT 114
5959: PPUSH
5960: LD_INT 108
5962: PPUSH
5963: CALL_OW 297
5967: PUSH
5968: LD_INT 9
5970: GREATER
5971: IFFALSE 5988
// ComMoveXY ( i , 114 , 108 ) ;
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 114
5980: PPUSH
5981: LD_INT 108
5983: PPUSH
5984: CALL_OW 111
5988: GO 5949
5990: POP
5991: POP
// wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 92
6006: PUSH
6007: LD_INT 114
6009: PUSH
6010: LD_INT 108
6012: PUSH
6013: LD_INT 9
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PPUSH
6022: CALL_OW 72
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: GREATEREQUAL
6036: IFFALSE 5914
// end else
6038: GO 6164
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 24
6052: PUSH
6053: LD_INT 250
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL_OW 72
6064: ST_TO_ADDR
// for i in tmp do
6065: LD_ADDR_VAR 0 1
6069: PUSH
6070: LD_VAR 0 2
6074: PUSH
6075: FOR_IN
6076: IFFALSE 6116
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 129
6085: PPUSH
6086: LD_INT 139
6088: PPUSH
6089: CALL_OW 297
6093: PUSH
6094: LD_INT 9
6096: GREATER
6097: IFFALSE 6114
// ComMoveXY ( i , 129 , 139 ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_INT 129
6106: PPUSH
6107: LD_INT 139
6109: PPUSH
6110: CALL_OW 111
6114: GO 6075
6116: POP
6117: POP
// wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6125: LD_VAR 0 2
6129: PPUSH
6130: LD_INT 92
6132: PUSH
6133: LD_INT 129
6135: PUSH
6136: LD_INT 139
6138: PUSH
6139: LD_INT 9
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 72
6152: PUSH
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 1
6160: MINUS
6161: GREATEREQUAL
6162: IFFALSE 6040
// end ; repeat wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6264
// begin if GetLives ( i ) > 251 then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 256
6193: PUSH
6194: LD_INT 251
6196: GREATER
6197: IFFALSE 6235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6199: LD_VAR 0 1
6203: PPUSH
6204: LD_INT 81
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: PPUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 74
6228: PPUSH
6229: CALL_OW 115
6233: GO 6262
// if IsDead ( i ) then
6235: LD_VAR 0 1
6239: PPUSH
6240: CALL_OW 301
6244: IFFALSE 6262
// tmp := tmp diff i ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PUSH
6256: LD_VAR 0 1
6260: DIFF
6261: ST_TO_ADDR
// end ;
6262: GO 6181
6264: POP
6265: POP
// until not tmp ;
6266: LD_VAR 0 2
6270: NOT
6271: IFFALSE 6164
// end ;
6273: PPOPN 3
6275: END
// every 30 30$00 trigger not americanDestroyed do
6276: LD_EXP 4
6280: NOT
6281: IFFALSE 6346
6283: GO 6285
6285: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6286: LD_INT 63000
6288: PUSH
6289: LD_INT 42000
6291: PUSH
6292: LD_INT 21000
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PPUSH
6306: CALL_OW 67
// if americanDestroyed then
6310: LD_EXP 4
6314: IFFALSE 6318
// exit ;
6316: GO 6346
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6318: LD_INT 4
6320: PPUSH
6321: LD_INT 5
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 8
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: EMPTY
6340: LIST
6341: PPUSH
6342: CALL 44257 0 2
// end ; end_of_file
6346: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
// side := 2 ;
6354: LD_ADDR_VAR 0 5
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// InitHc ;
6362: CALL_OW 19
// uc_side := side ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_VAR 0 5
6375: ST_TO_ADDR
// uc_nation := 2 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 2
6383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 2
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 3
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6435
// SetBLevel ( i , 10 ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 10
6428: PPUSH
6429: CALL_OW 241
6433: GO 6418
6435: POP
6436: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6437: LD_ADDR_VAR 0 4
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_VAR 0 5
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 30
6456: PUSH
6457: LD_INT 32
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 58
6466: PUSH
6467: EMPTY
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL_OW 69
6479: ST_TO_ADDR
// for i = 1 to 10 do
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: DOUBLE
6486: LD_INT 1
6488: DEC
6489: ST_TO_ADDR
6490: LD_INT 10
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6566
// begin uc_nation := nation_nature ;
6496: LD_ADDR_OWVAR 21
6500: PUSH
6501: LD_INT 0
6503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6504: LD_ADDR_OWVAR 28
6508: PUSH
6509: LD_INT 15
6511: ST_TO_ADDR
// hc_gallery :=  ;
6512: LD_ADDR_OWVAR 33
6516: PUSH
6517: LD_STRING 
6519: ST_TO_ADDR
// hc_name :=  ;
6520: LD_ADDR_OWVAR 26
6524: PUSH
6525: LD_STRING 
6527: ST_TO_ADDR
// un := CreateHuman ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: CALL_OW 44
6537: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_VAR 0 4
6552: PUSH
6553: LD_VAR 0 2
6557: MINUS
6558: ARRAY
6559: PPUSH
6560: CALL_OW 52
// end ;
6564: GO 6493
6566: POP
6567: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6568: LD_INT 503
6570: PPUSH
6571: LD_INT 27
6573: PPUSH
6574: LD_STRING 
6576: PPUSH
6577: LD_INT 8
6579: PUSH
6580: LD_INT 9
6582: PUSH
6583: LD_INT 10
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: PUSH
6591: LD_OWVAR 67
6595: ARRAY
6596: PPUSH
6597: LD_INT 3000
6599: PUSH
6600: LD_INT 500
6602: PUSH
6603: LD_INT 150
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PPUSH
6611: LD_INT 16
6613: PUSH
6614: LD_INT 6
6616: PUSH
6617: LD_INT 6
6619: PUSH
6620: LD_INT 6
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PPUSH
6629: CALL 58834 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6633: LD_ADDR_EXP 87
6637: PUSH
6638: LD_EXP 87
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 22
6648: PUSH
6649: LD_VAR 0 5
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 23
6660: PUSH
6661: LD_INT 2
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 69
6694: PPUSH
6695: CALL_OW 1
6699: ST_TO_ADDR
// end ;
6700: LD_VAR 0 1
6704: RET
// export Omar ; export function PrepareOmarAli ; begin
6705: LD_INT 0
6707: PPUSH
// uc_side := 5 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 5
6715: ST_TO_ADDR
// uc_nation := 2 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 2
6723: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6724: LD_ADDR_EXP 53
6728: PUSH
6729: LD_STRING Omar
6731: PPUSH
6732: CALL_OW 25
6736: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6737: LD_EXP 53
6741: PPUSH
6742: LD_INT 330
6744: PPUSH
6745: LD_INT 244
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6755: LD_EXP 53
6759: PPUSH
6760: LD_INT 252
6762: PPUSH
6763: LD_INT 220
6765: PPUSH
6766: CALL_OW 111
// end ; end_of_file
6770: LD_VAR 0 1
6774: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
// side := 8 ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_INT 8
6789: ST_TO_ADDR
// InitHc ;
6790: CALL_OW 19
// uc_side := side ;
6794: LD_ADDR_OWVAR 20
6798: PUSH
6799: LD_VAR 0 3
6803: ST_TO_ADDR
// uc_nation := 2 ;
6804: LD_ADDR_OWVAR 21
6808: PUSH
6809: LD_INT 2
6811: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 69
6847: PUSH
6848: FOR_IN
6849: IFFALSE 6865
// SetBLevel ( i , 10 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 10
6858: PPUSH
6859: CALL_OW 241
6863: GO 6848
6865: POP
6866: POP
// Schulz := NewCharacter ( Schulz ) ;
6867: LD_ADDR_EXP 54
6871: PUSH
6872: LD_STRING Schulz
6874: PPUSH
6875: CALL_OW 25
6879: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6880: LD_ADDR_EXP 55
6884: PUSH
6885: LD_STRING Kozlov
6887: PPUSH
6888: LD_INT 0
6890: PPUSH
6891: LD_STRING 
6893: PPUSH
6894: CALL 50601 0 3
6898: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6899: LD_EXP 55
6903: PPUSH
6904: LD_INT 22
6906: PUSH
6907: LD_INT 8
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PUSH
6914: LD_INT 23
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 30
6926: PUSH
6927: LD_INT 8
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: PPUSH
6939: CALL_OW 69
6943: PUSH
6944: LD_INT 1
6946: ARRAY
6947: PPUSH
6948: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6952: LD_EXP 55
6956: PPUSH
6957: LD_INT 3
6959: PPUSH
6960: LD_INT 10
6962: PPUSH
6963: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6967: LD_ADDR_VAR 0 5
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_VAR 0 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 32
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 58
6996: PUSH
6997: EMPTY
6998: LIST
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: LIST
7004: PPUSH
7005: CALL_OW 69
7009: ST_TO_ADDR
// for i = 1 to 10 do
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: DOUBLE
7016: LD_INT 1
7018: DEC
7019: ST_TO_ADDR
7020: LD_INT 10
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7096
// begin uc_nation := nation_nature ;
7026: LD_ADDR_OWVAR 21
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7034: LD_ADDR_OWVAR 28
7038: PUSH
7039: LD_INT 15
7041: ST_TO_ADDR
// hc_gallery :=  ;
7042: LD_ADDR_OWVAR 33
7046: PUSH
7047: LD_STRING 
7049: ST_TO_ADDR
// hc_name :=  ;
7050: LD_ADDR_OWVAR 26
7054: PUSH
7055: LD_STRING 
7057: ST_TO_ADDR
// un := CreateHuman ;
7058: LD_ADDR_VAR 0 4
7062: PUSH
7063: CALL_OW 44
7067: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: LD_VAR 0 5
7077: PUSH
7078: LD_VAR 0 5
7082: PUSH
7083: LD_VAR 0 2
7087: MINUS
7088: ARRAY
7089: PPUSH
7090: CALL_OW 52
// end ;
7094: GO 7023
7096: POP
7097: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7098: LD_INT 324
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: LD_STRING 
7106: PPUSH
7107: LD_INT 8
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PPUSH
7127: LD_INT 3000
7129: PUSH
7130: LD_INT 500
7132: PUSH
7133: LD_INT 150
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PPUSH
7141: LD_INT 16
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 6
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: PPUSH
7159: CALL 58834 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7163: LD_ADDR_EXP 87
7167: PUSH
7168: LD_EXP 87
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_INT 22
7178: PUSH
7179: LD_VAR 0 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 23
7190: PUSH
7191: LD_INT 2
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 3
7200: PUSH
7201: LD_INT 21
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: PUSH
7225: LD_EXP 54
7229: DIFF
7230: PPUSH
7231: CALL_OW 1
7235: ST_TO_ADDR
// end ;
7236: LD_VAR 0 1
7240: RET
// export function BuildKozlovBomb ; begin
7241: LD_INT 0
7243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7244: LD_INT 332
7246: PPUSH
7247: CALL_OW 302
7251: NOT
7252: PUSH
7253: LD_INT 336
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7266
// exit ;
7264: GO 7363
// ComChangeProfession ( Kozlov , 4 ) ;
7266: LD_EXP 55
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7278: LD_INT 336
7280: PPUSH
7281: LD_INT 25
7283: PPUSH
7284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7288: LD_INT 35
7290: PPUSH
7291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7295: LD_INT 25
7297: PPUSH
7298: LD_INT 8
7300: PPUSH
7301: CALL_OW 321
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7288
// ComExitBuilding ( Kozlov ) ;
7311: LD_EXP 55
7315: PPUSH
7316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7320: LD_EXP 55
7324: PPUSH
7325: LD_INT 332
7327: PPUSH
7328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7332: LD_EXP 55
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7344: LD_INT 332
7346: PPUSH
7347: LD_INT 23
7349: PPUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: LD_INT 48
7358: PPUSH
7359: CALL_OW 125
// end ;
7363: LD_VAR 0 1
7367: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7368: LD_EXP 3
7372: NOT
7373: PUSH
7374: LD_INT 3
7376: PPUSH
7377: LD_INT 1
7379: PPUSH
7380: CALL 45675 0 2
7384: NOT
7385: AND
7386: IFFALSE 8226
7388: GO 7390
7390: DISABLE
7391: LD_INT 0
7393: PPUSH
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7397: LD_INT 22
7399: PUSH
7400: LD_INT 8
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 23
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 30
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 69
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 8226
// if Prob ( 40 ) then
7441: LD_INT 40
7443: PPUSH
7444: CALL_OW 13
7448: IFFALSE 7575
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7450: LD_INT 3
7452: PPUSH
7453: LD_INT 14
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 28
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 14
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 28
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 14
7491: PUSH
7492: LD_INT 1
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 28
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 14
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 28
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 14
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 28
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 14
7545: PUSH
7546: LD_INT 1
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: LD_INT 26
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL 44257 0 2
// end else
7573: GO 7766
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 14
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 2
7586: PUSH
7587: LD_INT 27
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: LD_INT 26
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: LD_OWVAR 67
7605: ARRAY
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 14
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 2
7621: PUSH
7622: LD_INT 27
7624: PUSH
7625: LD_INT 26
7627: PUSH
7628: LD_INT 26
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_OWVAR 67
7640: ARRAY
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 14
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 2
7656: PUSH
7657: LD_INT 26
7659: PUSH
7660: LD_INT 26
7662: PUSH
7663: LD_INT 29
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_OWVAR 67
7675: ARRAY
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: LD_INT 2
7691: PUSH
7692: LD_INT 26
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: PUSH
7706: LD_OWVAR 67
7710: ARRAY
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 13
7720: PUSH
7721: LD_INT 1
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 29
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 14
7738: PUSH
7739: LD_INT 1
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: LD_INT 26
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PPUSH
7762: CALL 44257 0 2
// end ; repeat wait ( 0 0$1 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: CALL 45675 0 2
7783: PUSH
7784: LD_INT 6
7786: GREATEREQUAL
7787: IFFALSE 7766
// wait ( 0 0$30 ) ;
7789: LD_INT 1050
7791: PPUSH
7792: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7796: LD_ADDR_VAR 0 2
7800: PUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL 45675 0 2
7811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7812: LD_ADDR_EXP 106
7816: PUSH
7817: LD_EXP 106
7821: PPUSH
7822: LD_INT 3
7824: PPUSH
7825: LD_EXP 106
7829: PUSH
7830: LD_INT 3
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 2
7838: DIFF
7839: PPUSH
7840: CALL_OW 1
7844: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7845: LD_ADDR_VAR 0 3
7849: PUSH
7850: LD_INT 0
7852: PPUSH
7853: LD_INT 2
7855: PPUSH
7856: CALL_OW 12
7860: ST_TO_ADDR
// if target then
7861: LD_VAR 0 3
7865: IFFALSE 7993
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_VAR 0 2
7876: PPUSH
7877: LD_INT 24
7879: PUSH
7880: LD_INT 250
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 72
7891: ST_TO_ADDR
// for i in tmp do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: FOR_IN
7903: IFFALSE 7943
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 89
7912: PPUSH
7913: LD_INT 71
7915: PPUSH
7916: CALL_OW 297
7920: PUSH
7921: LD_INT 9
7923: GREATER
7924: IFFALSE 7941
// ComMoveXY ( i , 89 , 71 ) ;
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 89
7933: PPUSH
7934: LD_INT 71
7936: PPUSH
7937: CALL_OW 111
7941: GO 7902
7943: POP
7944: POP
// wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 89
7962: PUSH
7963: LD_INT 71
7965: PUSH
7966: LD_INT 9
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PPUSH
7975: CALL_OW 72
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_INT 1
7987: MINUS
7988: GREATEREQUAL
7989: IFFALSE 7867
// end else
7991: GO 8117
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 24
8005: PUSH
8006: LD_INT 250
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 1
8022: PUSH
8023: LD_VAR 0 2
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8069
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 147
8038: PPUSH
8039: LD_INT 4
8041: PPUSH
8042: CALL_OW 297
8046: PUSH
8047: LD_INT 9
8049: GREATER
8050: IFFALSE 8067
// ComMoveXY ( i , 147 , 4 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 147
8059: PPUSH
8060: LD_INT 4
8062: PPUSH
8063: CALL_OW 111
8067: GO 8028
8069: POP
8070: POP
// wait ( 0 0$1 ) ;
8071: LD_INT 35
8073: PPUSH
8074: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8078: LD_VAR 0 2
8082: PPUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 147
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 9
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 72
8105: PUSH
8106: LD_VAR 0 2
8110: PUSH
8111: LD_INT 1
8113: MINUS
8114: GREATEREQUAL
8115: IFFALSE 7993
// end ; repeat wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// for i in tmp do
8124: LD_ADDR_VAR 0 1
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: FOR_IN
8135: IFFALSE 8217
// begin if GetLives ( i ) > 251 then
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL_OW 256
8146: PUSH
8147: LD_INT 251
8149: GREATER
8150: IFFALSE 8188
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8152: LD_VAR 0 1
8156: PPUSH
8157: LD_INT 81
8159: PUSH
8160: LD_INT 8
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PPUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: CALL_OW 74
8181: PPUSH
8182: CALL_OW 115
8186: GO 8215
// if IsDead ( i ) then
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 301
8197: IFFALSE 8215
// tmp := tmp diff i ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_VAR 0 2
8208: PUSH
8209: LD_VAR 0 1
8213: DIFF
8214: ST_TO_ADDR
// end ;
8215: GO 8134
8217: POP
8218: POP
// until not tmp ;
8219: LD_VAR 0 2
8223: NOT
8224: IFFALSE 8117
// end ;
8226: PPOPN 3
8228: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8229: LD_EXP 55
8233: PPUSH
8234: CALL_OW 302
8238: PUSH
8239: LD_EXP 3
8243: NOT
8244: AND
8245: IFFALSE 8254
8247: GO 8249
8249: DISABLE
// BuildKozlovBomb ;
8250: CALL 7241 0 0
8254: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8255: LD_INT 22
8257: PUSH
8258: LD_INT 8
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 34
8267: PUSH
8268: LD_INT 48
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: IFFALSE 8331
8285: GO 8287
8287: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8288: LD_INT 22
8290: PUSH
8291: LD_INT 8
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 34
8300: PUSH
8301: LD_INT 48
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: LD_INT 173
8323: PPUSH
8324: LD_INT 96
8326: PPUSH
8327: CALL_OW 116
// end ; end_of_file
8331: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
8338: PPUSH
8339: PPUSH
8340: PPUSH
8341: PPUSH
8342: PPUSH
// side := 3 ;
8343: LD_ADDR_VAR 0 6
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// InitHc ;
8351: CALL_OW 19
// uc_side := side ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_VAR 0 6
8364: ST_TO_ADDR
// uc_nation := 3 ;
8365: LD_ADDR_OWVAR 21
8369: PUSH
8370: LD_INT 3
8372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_VAR 0 6
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 21
8392: PUSH
8393: LD_INT 3
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 69
8408: PUSH
8409: FOR_IN
8410: IFFALSE 8426
// SetBLevel ( i , 10 ) ;
8412: LD_VAR 0 2
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 241
8424: GO 8409
8426: POP
8427: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8428: LD_ADDR_VAR 0 9
8432: PUSH
8433: LD_INT 22
8435: PUSH
8436: LD_VAR 0 6
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 30
8447: PUSH
8448: LD_INT 34
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PPUSH
8459: CALL_OW 69
8463: ST_TO_ADDR
// if teleport then
8464: LD_VAR 0 9
8468: IFFALSE 8489
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8470: LD_VAR 0 9
8474: PUSH
8475: LD_INT 1
8477: ARRAY
8478: PPUSH
8479: LD_INT 123
8481: PPUSH
8482: LD_INT 122
8484: PPUSH
8485: CALL_OW 243
// hc_importance := 0 ;
8489: LD_ADDR_OWVAR 32
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8497: LD_ADDR_EXP 56
8501: PUSH
8502: LD_STRING Platonov
8504: PPUSH
8505: CALL_OW 25
8509: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8510: LD_ADDR_EXP 57
8514: PUSH
8515: LD_STRING Yakotich
8517: PPUSH
8518: CALL_OW 25
8522: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8523: LD_ADDR_EXP 58
8527: PUSH
8528: LD_STRING Gleb
8530: PPUSH
8531: CALL_OW 25
8535: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8536: LD_STRING 03_Cornel
8538: PPUSH
8539: CALL_OW 28
8543: IFFALSE 8591
// begin Bierezov := NewCharacter ( Mikhail ) ;
8545: LD_ADDR_EXP 59
8549: PUSH
8550: LD_STRING Mikhail
8552: PPUSH
8553: CALL_OW 25
8557: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8558: LD_EXP 59
8562: PPUSH
8563: LD_INT 197
8565: PPUSH
8566: LD_INT 111
8568: PPUSH
8569: LD_INT 9
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8579: LD_EXP 59
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8591: LD_EXP 56
8595: PPUSH
8596: LD_INT 126
8598: PPUSH
8599: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8603: LD_EXP 57
8607: PPUSH
8608: LD_INT 197
8610: PPUSH
8611: LD_INT 111
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 0
8619: PPUSH
8620: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8624: LD_EXP 58
8628: PPUSH
8629: LD_INT 197
8631: PPUSH
8632: LD_INT 111
8634: PPUSH
8635: LD_INT 9
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8645: LD_ADDR_VAR 0 5
8649: PUSH
8650: LD_INT 126
8652: PPUSH
8653: LD_INT 2
8655: PPUSH
8656: LD_STRING zhukov
8658: PPUSH
8659: LD_INT 9
8661: PUSH
8662: LD_INT 10
8664: PUSH
8665: LD_INT 10
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_OWVAR 67
8677: ARRAY
8678: PPUSH
8679: LD_INT 9000
8681: PUSH
8682: LD_INT 1000
8684: PUSH
8685: LD_INT 300
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: LD_INT 21
8695: PUSH
8696: LD_INT 8
8698: PUSH
8699: LD_INT 13
8701: PUSH
8702: LD_INT 8
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL 58834 0 6
8715: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: LD_INT 267
8723: PPUSH
8724: CALL_OW 274
8728: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 5000
8739: PPUSH
8740: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: LD_INT 200
8754: PPUSH
8755: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_INT 3
8766: PPUSH
8767: LD_INT 200
8769: PPUSH
8770: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8774: LD_ADDR_EXP 87
8778: PUSH
8779: LD_EXP 87
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 22
8794: PUSH
8795: LD_VAR 0 6
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PPUSH
8825: CALL_OW 69
8829: UNION
8830: PUSH
8831: LD_EXP 56
8835: DIFF
8836: PPUSH
8837: CALL_OW 1
8841: ST_TO_ADDR
// behemoths := [ ] ;
8842: LD_ADDR_EXP 60
8846: PUSH
8847: EMPTY
8848: ST_TO_ADDR
// behemothBuilders := [ ] ;
8849: LD_ADDR_EXP 61
8853: PUSH
8854: EMPTY
8855: ST_TO_ADDR
// j := 3 ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_INT 3
8863: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8864: LD_ADDR_VAR 0 2
8868: PUSH
8869: LD_INT 22
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 25
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8949
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8901: LD_ADDR_EXP 61
8905: PUSH
8906: LD_EXP 61
8910: PPUSH
8911: LD_VAR 0 2
8915: PPUSH
8916: CALL 86471 0 2
8920: ST_TO_ADDR
// j := j - 1 ;
8921: LD_ADDR_VAR 0 3
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 1
8933: MINUS
8934: ST_TO_ADDR
// if j = 0 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 0
8942: EQUAL
8943: IFFALSE 8947
// break ;
8945: GO 8949
// end ;
8947: GO 8898
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8956: LD_INT 0
8958: PPUSH
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8963: LD_ADDR_VAR 0 4
8967: PUSH
8968: LD_INT 209
8970: PUSH
8971: LD_INT 149
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: LD_INT 219
8980: PUSH
8981: LD_INT 154
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PUSH
8988: LD_INT 223
8990: PUSH
8991: LD_INT 149
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: PUSH
8998: LD_INT 232
9000: PUSH
9001: LD_INT 155
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: ST_TO_ADDR
// if not behemothBuilders then
9014: LD_EXP 61
9018: NOT
9019: IFFALSE 9023
// exit ;
9021: GO 9127
// j := 1 ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ST_TO_ADDR
// for i in behemothBuilders do
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_EXP 61
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9125
// begin if IsInUnit ( i ) then
9044: LD_VAR 0 2
9048: PPUSH
9049: CALL_OW 310
9053: IFFALSE 9064
// ComExitBuilding ( i ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 37
9071: PPUSH
9072: LD_VAR 0 4
9076: PUSH
9077: LD_VAR 0 3
9081: ARRAY
9082: PUSH
9083: LD_INT 1
9085: ARRAY
9086: PPUSH
9087: LD_VAR 0 4
9091: PUSH
9092: LD_VAR 0 3
9096: ARRAY
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_INT 0
9104: PPUSH
9105: CALL_OW 230
// j := j + 1 ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_VAR 0 3
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: ST_TO_ADDR
// end ;
9123: GO 9041
9125: POP
9126: POP
// end ;
9127: LD_VAR 0 1
9131: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9132: LD_INT 3
9134: PPUSH
9135: CALL 86519 0 1
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 30
9152: PUSH
9153: LD_INT 37
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: NOT
9169: AND
9170: IFFALSE 9356
9172: GO 9174
9174: DISABLE
9175: LD_INT 0
9177: PPUSH
9178: PPUSH
// begin enable ;
9179: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9180: LD_ADDR_VAR 0 2
9184: PUSH
9185: LD_INT 3
9187: PPUSH
9188: CALL 86519 0 1
9192: ST_TO_ADDR
// for i in tmp do
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: LD_VAR 0 2
9202: PUSH
9203: FOR_IN
9204: IFFALSE 9354
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_INT 7
9213: PPUSH
9214: CALL_OW 308
9218: PUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: CALL_OW 110
9228: PUSH
9229: LD_INT 2
9231: EQUAL
9232: NOT
9233: AND
9234: IFFALSE 9248
// SetTag ( i , 2 ) ;
9236: LD_VAR 0 1
9240: PPUSH
9241: LD_INT 2
9243: PPUSH
9244: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9248: LD_INT 81
9250: PUSH
9251: LD_INT 3
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 91
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_INT 12
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: NOT
9283: PUSH
9284: LD_VAR 0 1
9288: PPUSH
9289: CALL_OW 110
9293: PUSH
9294: LD_INT 2
9296: EQUAL
9297: NOT
9298: AND
9299: IFFALSE 9318
// ComAgressiveMove ( i , 64 , 93 ) else
9301: LD_VAR 0 1
9305: PPUSH
9306: LD_INT 64
9308: PPUSH
9309: LD_INT 93
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 3
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9203
9354: POP
9355: POP
// end ;
9356: PPOPN 2
9358: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9359: LD_EXP 2
9363: NOT
9364: PUSH
9365: LD_INT 2
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL 45675 0 2
9375: NOT
9376: AND
9377: IFFALSE 10297
9379: GO 9381
9381: DISABLE
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin enable ;
9388: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 30
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: NOT
9418: IFFALSE 9422
// exit ;
9420: GO 10297
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9422: LD_ADDR_VAR 0 4
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 30
9439: PUSH
9440: LD_INT 34
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// if Prob ( 40 ) then
9456: LD_INT 40
9458: PPUSH
9459: CALL_OW 13
9463: IFFALSE 9590
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9465: LD_INT 2
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 49
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 22
9488: PUSH
9489: LD_INT 3
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 49
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 49
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: PUSH
9522: LD_INT 24
9524: PUSH
9525: LD_INT 3
9527: PUSH
9528: LD_INT 3
9530: PUSH
9531: LD_INT 46
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 24
9542: PUSH
9543: LD_INT 3
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 46
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 24
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: LD_INT 46
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PPUSH
9584: CALL 44257 0 2
// end else
9588: GO 9713
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9590: LD_INT 2
9592: PPUSH
9593: LD_INT 24
9595: PUSH
9596: LD_INT 3
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: LD_INT 47
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 24
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 3
9619: PUSH
9620: LD_INT 47
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 24
9631: PUSH
9632: LD_INT 3
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: LD_INT 47
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 24
9649: PUSH
9650: LD_INT 3
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 24
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: LD_INT 3
9673: PUSH
9674: LD_INT 46
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 24
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: LD_INT 46
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: PPUSH
9709: CALL 44257 0 2
// end ; if Difficulty > 1 then
9713: LD_OWVAR 67
9717: PUSH
9718: LD_INT 1
9720: GREATER
9721: IFFALSE 9751
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9723: LD_INT 2
9725: PPUSH
9726: LD_INT 24
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 47
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: PPUSH
9747: CALL 44257 0 2
// repeat wait ( 0 0$1 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9758: LD_INT 2
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL 45675 0 2
9768: PUSH
9769: LD_INT 6
9771: PUSH
9772: LD_INT 7
9774: PUSH
9775: LD_INT 7
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_OWVAR 67
9787: ARRAY
9788: GREATEREQUAL
9789: IFFALSE 9751
// wait ( 0 0$30 ) ;
9791: LD_INT 1050
9793: PPUSH
9794: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 2
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 45675 0 2
9813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9814: LD_ADDR_EXP 106
9818: PUSH
9819: LD_EXP 106
9823: PPUSH
9824: LD_INT 2
9826: PPUSH
9827: LD_EXP 106
9831: PUSH
9832: LD_INT 2
9834: ARRAY
9835: PUSH
9836: LD_VAR 0 2
9840: DIFF
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_INT 0
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 12
9862: ST_TO_ADDR
// if target then
9863: LD_VAR 0 3
9867: IFFALSE 9995
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 2
9878: PPUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 250
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 72
9893: ST_TO_ADDR
// for i in tmp do
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: FOR_IN
9905: IFFALSE 9945
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 139
9914: PPUSH
9915: LD_INT 89
9917: PPUSH
9918: CALL_OW 297
9922: PUSH
9923: LD_INT 9
9925: GREATER
9926: IFFALSE 9943
// ComMoveXY ( i , 139 , 89 ) ;
9928: LD_VAR 0 1
9932: PPUSH
9933: LD_INT 139
9935: PPUSH
9936: LD_INT 89
9938: PPUSH
9939: CALL_OW 111
9943: GO 9904
9945: POP
9946: POP
// wait ( 0 0$1 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9954: LD_VAR 0 2
9958: PPUSH
9959: LD_INT 92
9961: PUSH
9962: LD_INT 139
9964: PUSH
9965: LD_INT 89
9967: PUSH
9968: LD_INT 9
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: PPUSH
9977: CALL_OW 72
9981: PUSH
9982: LD_VAR 0 2
9986: PUSH
9987: LD_INT 1
9989: MINUS
9990: GREATEREQUAL
9991: IFFALSE 9869
// end else
9993: GO 10137
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_VAR 0 4
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PPUSH
10009: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10013: LD_ADDR_VAR 0 2
10017: PUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: LD_INT 24
10025: PUSH
10026: LD_INT 250
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// for i in tmp do
10038: LD_ADDR_VAR 0 1
10042: PUSH
10043: LD_VAR 0 2
10047: PUSH
10048: FOR_IN
10049: IFFALSE 10089
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 124
10058: PPUSH
10059: LD_INT 139
10061: PPUSH
10062: CALL_OW 297
10066: PUSH
10067: LD_INT 9
10069: GREATER
10070: IFFALSE 10087
// ComMoveXY ( i , 124 , 139 ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 124
10079: PPUSH
10080: LD_INT 139
10082: PPUSH
10083: CALL_OW 111
10087: GO 10048
10089: POP
10090: POP
// wait ( 0 0$1 ) ;
10091: LD_INT 35
10093: PPUSH
10094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10098: LD_VAR 0 2
10102: PPUSH
10103: LD_INT 92
10105: PUSH
10106: LD_INT 124
10108: PUSH
10109: LD_INT 139
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 72
10125: PUSH
10126: LD_VAR 0 2
10130: PUSH
10131: LD_INT 1
10133: MINUS
10134: GREATEREQUAL
10135: IFFALSE 10013
// end ; repeat wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// for i in tmp do
10144: LD_ADDR_VAR 0 1
10148: PUSH
10149: LD_VAR 0 2
10153: PUSH
10154: FOR_IN
10155: IFFALSE 10288
// begin if GetLives ( i ) > 251 then
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 256
10166: PUSH
10167: LD_INT 251
10169: GREATER
10170: IFFALSE 10259
// begin if GetWeapon ( i ) = ru_time_lapser then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 264
10181: PUSH
10182: LD_INT 49
10184: EQUAL
10185: IFFALSE 10223
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10187: LD_VAR 0 1
10191: PPUSH
10192: LD_INT 81
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: PPUSH
10207: LD_VAR 0 1
10211: PPUSH
10212: CALL_OW 74
10216: PPUSH
10217: CALL_OW 112
10221: GO 10257
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 81
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 69
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 74
10252: PPUSH
10253: CALL_OW 115
// end else
10257: GO 10286
// if IsDead ( i ) then
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 301
10268: IFFALSE 10286
// tmp := tmp diff i ;
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_VAR 0 2
10279: PUSH
10280: LD_VAR 0 1
10284: DIFF
10285: ST_TO_ADDR
// end ;
10286: GO 10154
10288: POP
10289: POP
// until not tmp ;
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10137
// end ;
10297: PPOPN 4
10299: END
// every 30 30$00 trigger not russianDestroyed do
10300: LD_EXP 2
10304: NOT
10305: IFFALSE 10370
10307: GO 10309
10309: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10310: LD_INT 105000
10312: PUSH
10313: LD_INT 84000
10315: PUSH
10316: LD_INT 63000
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_OWVAR 67
10328: ARRAY
10329: PPUSH
10330: CALL_OW 67
// if russianDestroyed then
10334: LD_EXP 2
10338: IFFALSE 10342
// exit ;
10340: GO 10370
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 23
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 48
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: PPUSH
10366: CALL 44257 0 2
// end ; end_of_file
10370: END
// export function CustomEvent ( event ) ; begin
10371: LD_INT 0
10373: PPUSH
// end ;
10374: LD_VAR 0 2
10378: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10379: LD_VAR 0 2
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: LD_INT 15
10391: PPUSH
10392: CALL_OW 309
10396: IFFALSE 10405
// YouLost ( MothContaminate ) ;
10398: LD_STRING MothContaminate
10400: PPUSH
10401: CALL_OW 104
// end ;
10405: PPOPN 3
10407: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 15
10420: PPUSH
10421: CALL_OW 309
10425: IFFALSE 10441
// begin wait ( 0 0$6 ) ;
10427: LD_INT 210
10429: PPUSH
10430: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10434: LD_STRING MothContaminateBomb
10436: PPUSH
10437: CALL_OW 104
// end ; end ;
10441: PPOPN 3
10443: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10444: LD_VAR 0 1
10448: PUSH
10449: LD_EXP 17
10453: EQUAL
10454: IFFALSE 10465
// begin YouLost ( JMM ) ;
10456: LD_STRING JMM
10458: PPUSH
10459: CALL_OW 104
// exit ;
10463: GO 10564
// end ; if un = Powell then
10465: LD_VAR 0 1
10469: PUSH
10470: LD_EXP 52
10474: EQUAL
10475: IFFALSE 10485
// americanDestroyed := true ;
10477: LD_ADDR_EXP 4
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// if un = Platonov then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 56
10494: EQUAL
10495: IFFALSE 10505
// russianDestroyed := true ;
10497: LD_ADDR_EXP 2
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 22
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 21
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IN
10539: IFFALSE 10555
// vehicleLostCounter := vehicleLostCounter + 1 ;
10541: LD_ADDR_EXP 15
10545: PUSH
10546: LD_EXP 15
10550: PUSH
10551: LD_INT 1
10553: PLUS
10554: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL 47649 0 1
// end ;
10564: PPOPN 1
10566: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_VAR 0 2
10576: PPUSH
10577: CALL 49983 0 2
// end ;
10581: PPOPN 2
10583: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL 49051 0 1
// end ;
10593: PPOPN 1
10595: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10596: LD_VAR 0 1
10600: PUSH
10601: LD_INT 22
10603: PUSH
10604: LD_INT 8
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 23
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10668
// begin ComUpgrade ( building ) ;
10643: LD_VAR 0 1
10647: PPUSH
10648: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10652: LD_EXP 55
10656: PPUSH
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 58398 0 2
// exit ;
10666: GO 10677
// end ; MCE_BuildingComplete ( building ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 49292 0 1
// end ;
10677: PPOPN 1
10679: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10680: LD_VAR 0 1
10684: PPUSH
10685: LD_VAR 0 2
10689: PPUSH
10690: CALL 47345 0 2
// end ;
10694: PPOPN 2
10696: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_VAR 0 2
10706: PPUSH
10707: LD_VAR 0 3
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_VAR 0 5
10721: PPUSH
10722: CALL 46965 0 5
// end ;
10726: PPOPN 5
10728: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10729: LD_VAR 0 1
10733: PPUSH
10734: LD_VAR 0 2
10738: PPUSH
10739: CALL 46561 0 2
// end ;
10743: PPOPN 2
10745: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: LD_VAR 0 4
10765: PPUSH
10766: CALL 46399 0 4
// end ;
10770: PPOPN 4
10772: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: LD_VAR 0 3
10787: PPUSH
10788: CALL 46174 0 3
// end ;
10792: PPOPN 3
10794: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL 46059 0 2
// end ;
10809: PPOPN 2
10811: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_VAR 0 2
10821: PPUSH
10822: CALL 50244 0 2
// end ;
10826: PPOPN 2
10828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_VAR 0 3
10843: PPUSH
10844: LD_VAR 0 4
10848: PPUSH
10849: CALL 50460 0 4
// end ;
10853: PPOPN 4
10855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL 45868 0 2
// end ;
10870: PPOPN 2
10872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL 97973 0 1
// end ; end_of_file
10882: PPOPN 1
10884: END
// export function Action ; begin
10885: LD_INT 0
10887: PPUSH
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10892: LD_INT 206
10894: PPUSH
10895: LD_INT 11
10897: PPUSH
10898: CALL_OW 86
// wait ( 0 0$1 ) ;
10902: LD_INT 35
10904: PPUSH
10905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10909: LD_EXP 17
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-1
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10921: LD_EXP 49
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-1
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10933: LD_EXP 17
10937: PPUSH
10938: LD_STRING DStart-JMM-JMM-2
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10945: LD_EXP 49
10949: PPUSH
10950: LD_STRING DStart-JMM-Bur-2
10952: PPUSH
10953: CALL_OW 88
// InGameOff ;
10957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10961: LD_STRING MStart
10963: PPUSH
10964: CALL_OW 337
// end ;
10968: LD_VAR 0 1
10972: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10973: LD_INT 7
10975: PPUSH
10976: LD_INT 255
10978: PPUSH
10979: LD_INT 219
10981: PPUSH
10982: CALL_OW 293
10986: IFFALSE 11595
10988: GO 10990
10990: DISABLE
10991: LD_INT 0
10993: PPUSH
// begin wait ( 0 0$3 ) ;
10994: LD_INT 105
10996: PPUSH
10997: CALL_OW 67
// alienSpotted := true ;
11001: LD_ADDR_EXP 10
11005: PUSH
11006: LD_INT 1
11008: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11009: LD_ADDR_VAR 0 1
11013: PUSH
11014: LD_INT 22
11016: PUSH
11017: LD_INT 7
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PUSH
11024: LD_INT 23
11026: PUSH
11027: LD_INT 3
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: PUSH
11034: LD_INT 21
11036: PUSH
11037: LD_INT 1
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: PUSH
11044: LD_INT 26
11046: PUSH
11047: LD_INT 1
11049: PUSH
11050: EMPTY
11051: LIST
11052: LIST
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: LIST
11058: LIST
11059: PPUSH
11060: CALL_OW 69
11064: PUSH
11065: LD_EXP 49
11069: PUSH
11070: LD_EXP 37
11074: PUSH
11075: LD_EXP 39
11079: PUSH
11080: LD_EXP 40
11084: PUSH
11085: LD_EXP 47
11089: PUSH
11090: LD_EXP 46
11094: PUSH
11095: LD_EXP 41
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: LIST
11108: DIFF
11109: ST_TO_ADDR
// DialogueOn ;
11110: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11114: LD_INT 255
11116: PPUSH
11117: LD_INT 219
11119: PPUSH
11120: LD_INT 7
11122: PPUSH
11123: LD_INT 20
11125: NEG
11126: PPUSH
11127: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11131: LD_INT 255
11133: PPUSH
11134: LD_INT 219
11136: PPUSH
11137: CALL_OW 86
// if speaker then
11141: LD_VAR 0 1
11145: IFFALSE 11163
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11147: LD_VAR 0 1
11151: PUSH
11152: LD_INT 1
11154: ARRAY
11155: PPUSH
11156: LD_STRING DAlienBase-RSol1-1
11158: PPUSH
11159: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11163: LD_EXP 17
11167: PPUSH
11168: LD_STRING DAlienBase-JMM-1
11170: PPUSH
11171: CALL_OW 88
// if IsOk ( Burlak ) then
11175: LD_EXP 49
11179: PPUSH
11180: CALL_OW 302
11184: IFFALSE 11205
// begin dwait ( 0 0$1 ) ;
11186: LD_INT 35
11188: PPUSH
11189: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11193: LD_EXP 49
11197: PPUSH
11198: LD_STRING DAlienBase-Bur-1
11200: PPUSH
11201: CALL_OW 88
// end ; if IsOk ( Roth ) then
11205: LD_EXP 18
11209: PPUSH
11210: CALL_OW 302
11214: IFFALSE 11228
// Say ( Roth , DAlienBase-Roth-1 ) ;
11216: LD_EXP 18
11220: PPUSH
11221: LD_STRING DAlienBase-Roth-1
11223: PPUSH
11224: CALL_OW 88
// if IsOk ( Gossudarov ) then
11228: LD_EXP 35
11232: PPUSH
11233: CALL_OW 302
11237: IFFALSE 11253
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11239: LD_EXP 35
11243: PPUSH
11244: LD_STRING DAlienBase-Gos-1
11246: PPUSH
11247: CALL_OW 88
11251: GO 11370
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11253: LD_ADDR_VAR 0 1
11257: PUSH
11258: LD_INT 22
11260: PUSH
11261: LD_INT 7
11263: PUSH
11264: EMPTY
11265: LIST
11266: LIST
11267: PUSH
11268: LD_INT 25
11270: PUSH
11271: LD_INT 4
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: PUSH
11278: LD_INT 21
11280: PUSH
11281: LD_INT 1
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 26
11290: PUSH
11291: LD_INT 1
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: PPUSH
11304: CALL_OW 69
11308: PUSH
11309: LD_EXP 18
11313: PUSH
11314: LD_EXP 17
11318: PUSH
11319: LD_EXP 49
11323: PUSH
11324: LD_EXP 37
11328: PUSH
11329: LD_EXP 47
11333: PUSH
11334: LD_EXP 46
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: LIST
11346: DIFF
11347: ST_TO_ADDR
// if speaker then
11348: LD_VAR 0 1
11352: IFFALSE 11370
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11354: LD_VAR 0 1
11358: PUSH
11359: LD_INT 1
11361: ARRAY
11362: PPUSH
11363: LD_STRING DAlienBase-Sci1-1
11365: PPUSH
11366: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11370: LD_INT 255
11372: PPUSH
11373: LD_INT 219
11375: PPUSH
11376: LD_INT 7
11378: PPUSH
11379: CALL_OW 331
// DialogueOff ;
11383: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11387: LD_INT 35
11389: PPUSH
11390: CALL_OW 67
// until IsSelected ( alien ) ;
11394: LD_INT 1
11396: PPUSH
11397: CALL_OW 306
11401: IFFALSE 11387
// if not artifactIResearched or not artifactIIResearched then
11403: LD_EXP 12
11407: NOT
11408: PUSH
11409: LD_EXP 13
11413: NOT
11414: OR
11415: IFFALSE 11595
// begin if IsOk ( Roth ) then
11417: LD_EXP 18
11421: PPUSH
11422: CALL_OW 302
11426: IFFALSE 11442
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11428: LD_EXP 18
11432: PPUSH
11433: LD_STRING DAlieBaseNotReady-Roth-1
11435: PPUSH
11436: CALL_OW 88
11440: GO 11595
// if IsOk ( Gossudarov ) then
11442: LD_EXP 35
11446: PPUSH
11447: CALL_OW 302
11451: IFFALSE 11467
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11453: LD_EXP 35
11457: PPUSH
11458: LD_STRING DAlieBaseNotReady-Gos-1
11460: PPUSH
11461: CALL_OW 88
11465: GO 11595
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11467: LD_ADDR_VAR 0 1
11471: PUSH
11472: LD_INT 22
11474: PUSH
11475: LD_INT 7
11477: PUSH
11478: EMPTY
11479: LIST
11480: LIST
11481: PUSH
11482: LD_INT 23
11484: PUSH
11485: LD_INT 3
11487: PUSH
11488: EMPTY
11489: LIST
11490: LIST
11491: PUSH
11492: LD_INT 25
11494: PUSH
11495: LD_INT 4
11497: PUSH
11498: EMPTY
11499: LIST
11500: LIST
11501: PUSH
11502: LD_INT 21
11504: PUSH
11505: LD_INT 1
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PUSH
11512: LD_INT 26
11514: PUSH
11515: LD_INT 1
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: PPUSH
11529: CALL_OW 69
11533: PUSH
11534: LD_EXP 18
11538: PUSH
11539: LD_EXP 17
11543: PUSH
11544: LD_EXP 49
11548: PUSH
11549: LD_EXP 37
11553: PUSH
11554: LD_EXP 47
11558: PUSH
11559: LD_EXP 46
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: DIFF
11572: ST_TO_ADDR
// if speaker then
11573: LD_VAR 0 1
11577: IFFALSE 11595
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11579: LD_VAR 0 1
11583: PUSH
11584: LD_INT 1
11586: ARRAY
11587: PPUSH
11588: LD_STRING DAlieBaseNotReady-RSci1-1
11590: PPUSH
11591: CALL_OW 88
// end ; end ; end ;
11595: PPOPN 1
11597: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11598: LD_INT 24
11600: PPUSH
11601: LD_INT 7
11603: PPUSH
11604: CALL_OW 321
11608: PUSH
11609: LD_INT 2
11611: EQUAL
11612: IFFALSE 12303
11614: GO 11616
11616: DISABLE
11617: LD_INT 0
11619: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11620: LD_ADDR_VAR 0 1
11624: PUSH
11625: LD_INT 22
11627: PUSH
11628: LD_INT 7
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: PUSH
11635: LD_INT 23
11637: PUSH
11638: LD_INT 3
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: PUSH
11645: LD_INT 25
11647: PUSH
11648: LD_INT 4
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 21
11657: PUSH
11658: LD_INT 1
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: LD_INT 26
11667: PUSH
11668: LD_INT 1
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: PPUSH
11682: CALL_OW 69
11686: PUSH
11687: LD_EXP 18
11691: PUSH
11692: LD_EXP 17
11696: PUSH
11697: LD_EXP 49
11701: PUSH
11702: LD_EXP 37
11706: PUSH
11707: LD_EXP 47
11711: PUSH
11712: LD_EXP 46
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: DIFF
11725: ST_TO_ADDR
// if not speaker then
11726: LD_VAR 0 1
11730: NOT
11731: IFFALSE 11735
// exit ;
11733: GO 12303
// DialogueOn ;
11735: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11739: LD_VAR 0 1
11743: PUSH
11744: LD_INT 1
11746: ARRAY
11747: PPUSH
11748: LD_STRING DArtefTechnology-RSci1-1
11750: PPUSH
11751: CALL_OW 88
// if IsOk ( Burlak ) then
11755: LD_EXP 49
11759: PPUSH
11760: CALL_OW 302
11764: IFFALSE 11778
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11766: LD_EXP 49
11770: PPUSH
11771: LD_STRING DArtefTechnology-Bur-1
11773: PPUSH
11774: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11778: LD_VAR 0 1
11782: PUSH
11783: LD_INT 1
11785: ARRAY
11786: PPUSH
11787: LD_STRING DArtefTechnology-RSci1-2
11789: PPUSH
11790: CALL_OW 88
// if Denis then
11794: LD_EXP 23
11798: IFFALSE 11815
// speaker := [ Denis ] else
11800: LD_ADDR_VAR 0 1
11804: PUSH
11805: LD_EXP 23
11809: PUSH
11810: EMPTY
11811: LIST
11812: ST_TO_ADDR
11813: GO 11921
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_INT 7
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: LD_INT 23
11832: PUSH
11833: LD_INT 1
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 25
11842: PUSH
11843: LD_INT 4
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 1
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 26
11862: PUSH
11863: LD_INT 1
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: PPUSH
11877: CALL_OW 69
11881: PUSH
11882: LD_EXP 18
11886: PUSH
11887: LD_EXP 17
11891: PUSH
11892: LD_EXP 49
11896: PUSH
11897: LD_EXP 37
11901: PUSH
11902: LD_EXP 47
11906: PUSH
11907: LD_EXP 46
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: LIST
11916: LIST
11917: LIST
11918: LIST
11919: DIFF
11920: ST_TO_ADDR
// if speaker then
11921: LD_VAR 0 1
11925: IFFALSE 11943
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11927: LD_VAR 0 1
11931: PUSH
11932: LD_INT 1
11934: ARRAY
11935: PPUSH
11936: LD_STRING DArtefTechnology-Sci1-2
11938: PPUSH
11939: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11943: LD_ADDR_VAR 0 1
11947: PUSH
11948: LD_INT 22
11950: PUSH
11951: LD_INT 7
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: PUSH
11958: LD_INT 23
11960: PUSH
11961: LD_INT 3
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: LD_INT 25
11970: PUSH
11971: LD_INT 4
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: PUSH
11978: LD_INT 21
11980: PUSH
11981: LD_INT 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 26
11990: PUSH
11991: LD_INT 1
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: PPUSH
12005: CALL_OW 69
12009: PUSH
12010: LD_EXP 18
12014: PUSH
12015: LD_EXP 17
12019: PUSH
12020: LD_EXP 49
12024: PUSH
12025: LD_EXP 37
12029: PUSH
12030: LD_EXP 47
12034: PUSH
12035: LD_EXP 46
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: DIFF
12048: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12049: LD_VAR 0 1
12053: PUSH
12054: LD_EXP 9
12058: PUSH
12059: LD_EXP 5
12063: OR
12064: AND
12065: IFFALSE 12299
// begin if arabianDestroyed and IsOk ( Burlak ) then
12067: LD_EXP 5
12071: PUSH
12072: LD_EXP 49
12076: PPUSH
12077: CALL_OW 302
12081: AND
12082: IFFALSE 12098
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12084: LD_EXP 49
12088: PPUSH
12089: LD_STRING DArtefTechnology-Bur-2
12091: PPUSH
12092: CALL_OW 88
12096: GO 12110
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12098: LD_EXP 17
12102: PPUSH
12103: LD_STRING DArtefTechnology-JMM-2
12105: PPUSH
12106: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12110: LD_VAR 0 1
12114: PUSH
12115: LD_INT 1
12117: ARRAY
12118: PPUSH
12119: LD_STRING DArtefTechnology-RSci1-3
12121: PPUSH
12122: CALL_OW 88
// if Denis then
12126: LD_EXP 23
12130: IFFALSE 12147
// speaker := [ Denis ] else
12132: LD_ADDR_VAR 0 1
12136: PUSH
12137: LD_EXP 23
12141: PUSH
12142: EMPTY
12143: LIST
12144: ST_TO_ADDR
12145: GO 12253
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12147: LD_ADDR_VAR 0 1
12151: PUSH
12152: LD_INT 22
12154: PUSH
12155: LD_INT 7
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 23
12164: PUSH
12165: LD_INT 1
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: PUSH
12172: LD_INT 25
12174: PUSH
12175: LD_INT 4
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 21
12184: PUSH
12185: LD_INT 1
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: LD_INT 26
12194: PUSH
12195: LD_INT 1
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: LIST
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL_OW 69
12213: PUSH
12214: LD_EXP 18
12218: PUSH
12219: LD_EXP 17
12223: PUSH
12224: LD_EXP 49
12228: PUSH
12229: LD_EXP 37
12233: PUSH
12234: LD_EXP 47
12238: PUSH
12239: LD_EXP 46
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: DIFF
12252: ST_TO_ADDR
// if speaker then
12253: LD_VAR 0 1
12257: IFFALSE 12299
// if alienSpotted then
12259: LD_EXP 10
12263: IFFALSE 12283
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12265: LD_VAR 0 1
12269: PUSH
12270: LD_INT 1
12272: ARRAY
12273: PPUSH
12274: LD_STRING DArtefTechnology-Sci1-3
12276: PPUSH
12277: CALL_OW 88
12281: GO 12299
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12283: LD_VAR 0 1
12287: PUSH
12288: LD_INT 1
12290: ARRAY
12291: PPUSH
12292: LD_STRING DArtefTechnology-Sci1-3a
12294: PPUSH
12295: CALL_OW 88
// end ; DialogueOff ;
12299: CALL_OW 7
// end ;
12303: PPOPN 1
12305: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12306: LD_EXP 12
12310: IFFALSE 12505
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin if Denis then
12318: LD_EXP 23
12322: IFFALSE 12339
// speaker := [ Denis ] else
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: LD_EXP 23
12333: PUSH
12334: EMPTY
12335: LIST
12336: ST_TO_ADDR
12337: GO 12445
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12339: LD_ADDR_VAR 0 1
12343: PUSH
12344: LD_INT 22
12346: PUSH
12347: LD_INT 7
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 23
12356: PUSH
12357: LD_INT 1
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: LD_INT 25
12366: PUSH
12367: LD_INT 4
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: PUSH
12374: LD_INT 21
12376: PUSH
12377: LD_INT 1
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: PUSH
12384: LD_INT 26
12386: PUSH
12387: LD_INT 1
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: PPUSH
12401: CALL_OW 69
12405: PUSH
12406: LD_EXP 18
12410: PUSH
12411: LD_EXP 17
12415: PUSH
12416: LD_EXP 49
12420: PUSH
12421: LD_EXP 37
12425: PUSH
12426: LD_EXP 47
12430: PUSH
12431: LD_EXP 46
12435: PUSH
12436: EMPTY
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: DIFF
12444: ST_TO_ADDR
// if not speaker then
12445: LD_VAR 0 1
12449: NOT
12450: IFFALSE 12454
// exit ;
12452: GO 12505
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12454: LD_VAR 0 1
12458: PUSH
12459: LD_INT 1
12461: ARRAY
12462: PPUSH
12463: LD_STRING DArtefTechnologyAm-Sci1-1
12465: PPUSH
12466: CALL_OW 88
// if IsOk ( Burlak ) then
12470: LD_EXP 49
12474: PPUSH
12475: CALL_OW 302
12479: IFFALSE 12493
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12481: LD_EXP 49
12485: PPUSH
12486: LD_STRING DArtefTechnologyAm-Bur-1
12488: PPUSH
12489: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12493: LD_EXP 17
12497: PPUSH
12498: LD_STRING DArtefTechnologyAm-JMM-1
12500: PPUSH
12501: CALL_OW 88
// end ;
12505: PPOPN 1
12507: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12508: LD_EXP 13
12512: IFFALSE 12702
12514: GO 12516
12516: DISABLE
12517: LD_INT 0
12519: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12520: LD_ADDR_VAR 0 1
12524: PUSH
12525: LD_INT 22
12527: PUSH
12528: LD_INT 7
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PUSH
12535: LD_INT 23
12537: PUSH
12538: LD_INT 3
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: PUSH
12545: LD_INT 25
12547: PUSH
12548: LD_INT 4
12550: PUSH
12551: EMPTY
12552: LIST
12553: LIST
12554: PUSH
12555: LD_INT 21
12557: PUSH
12558: LD_INT 1
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: PUSH
12565: LD_INT 26
12567: PUSH
12568: LD_INT 1
12570: PUSH
12571: EMPTY
12572: LIST
12573: LIST
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: PPUSH
12582: CALL_OW 69
12586: PUSH
12587: LD_EXP 18
12591: PUSH
12592: LD_EXP 17
12596: PUSH
12597: LD_EXP 49
12601: PUSH
12602: LD_EXP 37
12606: PUSH
12607: LD_EXP 47
12611: PUSH
12612: LD_EXP 46
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: DIFF
12625: ST_TO_ADDR
// if not speaker then
12626: LD_VAR 0 1
12630: NOT
12631: IFFALSE 12635
// exit ;
12633: GO 12702
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12635: LD_VAR 0 1
12639: PUSH
12640: LD_INT 1
12642: ARRAY
12643: PPUSH
12644: LD_STRING DArtefTechnologyRu-RSci1-1
12646: PPUSH
12647: CALL_OW 88
// if IsOk ( Burlak ) then
12651: LD_EXP 49
12655: PPUSH
12656: CALL_OW 302
12660: IFFALSE 12674
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12662: LD_EXP 49
12666: PPUSH
12667: LD_STRING DArtefTechnologyRu-Bur-1
12669: PPUSH
12670: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12674: LD_VAR 0 1
12678: PUSH
12679: LD_INT 1
12681: ARRAY
12682: PPUSH
12683: LD_STRING DArtefTechnologyRu-RSci1-2
12685: PPUSH
12686: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12690: LD_EXP 17
12694: PPUSH
12695: LD_STRING DArtefTechnologyRu-JMM-1
12697: PPUSH
12698: CALL_OW 88
// end ;
12702: PPOPN 1
12704: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12705: LD_INT 24
12707: PPUSH
12708: LD_INT 7
12710: PPUSH
12711: CALL_OW 321
12715: PUSH
12716: LD_INT 2
12718: EQUAL
12719: PUSH
12720: LD_INT 1
12722: PPUSH
12723: CALL_OW 255
12727: PUSH
12728: LD_INT 7
12730: EQUAL
12731: AND
12732: IFFALSE 12892
12734: GO 12736
12736: DISABLE
12737: LD_INT 0
12739: PPUSH
// begin if Denis then
12740: LD_EXP 23
12744: IFFALSE 12761
// speaker := [ Denis ] else
12746: LD_ADDR_VAR 0 1
12750: PUSH
12751: LD_EXP 23
12755: PUSH
12756: EMPTY
12757: LIST
12758: ST_TO_ADDR
12759: GO 12867
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12761: LD_ADDR_VAR 0 1
12765: PUSH
12766: LD_INT 22
12768: PUSH
12769: LD_INT 7
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PUSH
12776: LD_INT 23
12778: PUSH
12779: LD_INT 1
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 25
12788: PUSH
12789: LD_INT 4
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: PUSH
12796: LD_INT 21
12798: PUSH
12799: LD_INT 1
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: LD_INT 26
12808: PUSH
12809: LD_INT 1
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: PPUSH
12823: CALL_OW 69
12827: PUSH
12828: LD_EXP 18
12832: PUSH
12833: LD_EXP 17
12837: PUSH
12838: LD_EXP 49
12842: PUSH
12843: LD_EXP 37
12847: PUSH
12848: LD_EXP 47
12852: PUSH
12853: LD_EXP 46
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: LIST
12862: LIST
12863: LIST
12864: LIST
12865: DIFF
12866: ST_TO_ADDR
// if not speaker then
12867: LD_VAR 0 1
12871: NOT
12872: IFFALSE 12876
// exit ;
12874: GO 12892
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12876: LD_VAR 0 1
12880: PUSH
12881: LD_INT 1
12883: ARRAY
12884: PPUSH
12885: LD_STRING DArtefTechnologyArStart-Sci1-1
12887: PPUSH
12888: CALL_OW 88
// end ;
12892: PPOPN 1
12894: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12895: LD_EXP 14
12899: IFFALSE 13180
12901: GO 12903
12903: DISABLE
12904: LD_INT 0
12906: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12907: LD_ADDR_VAR 0 1
12911: PUSH
12912: LD_INT 22
12914: PUSH
12915: LD_INT 7
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: LD_INT 23
12924: PUSH
12925: LD_INT 3
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PUSH
12932: LD_INT 25
12934: PUSH
12935: LD_INT 4
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PUSH
12942: LD_INT 21
12944: PUSH
12945: LD_INT 1
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PUSH
12952: LD_INT 26
12954: PUSH
12955: LD_INT 1
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: PUSH
12974: LD_EXP 18
12978: PUSH
12979: LD_EXP 17
12983: PUSH
12984: LD_EXP 49
12988: PUSH
12989: LD_EXP 37
12993: PUSH
12994: LD_EXP 47
12998: PUSH
12999: LD_EXP 46
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: DIFF
13012: ST_TO_ADDR
// if not speaker then
13013: LD_VAR 0 1
13017: NOT
13018: IFFALSE 13022
// exit ;
13020: GO 13180
// DialogueOn ;
13022: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13026: LD_VAR 0 1
13030: PUSH
13031: LD_INT 1
13033: ARRAY
13034: PPUSH
13035: LD_STRING DArtefTechnologyAr-RSci1-1
13037: PPUSH
13038: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13042: LD_EXP 17
13046: PPUSH
13047: LD_STRING DArtefTechnologyAr-JMM-1
13049: PPUSH
13050: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13054: LD_VAR 0 1
13058: PUSH
13059: LD_INT 1
13061: ARRAY
13062: PPUSH
13063: LD_STRING DArtefTechnologyAr-RSci1-2
13065: PPUSH
13066: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13070: LD_EXP 17
13074: PPUSH
13075: LD_STRING DArtefTechnologyAr-JMM-2
13077: PPUSH
13078: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13082: LD_VAR 0 1
13086: PUSH
13087: LD_INT 1
13089: ARRAY
13090: PPUSH
13091: LD_STRING DArtefTechnologyAr-RSci1-3
13093: PPUSH
13094: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13098: LD_EXP 17
13102: PPUSH
13103: LD_STRING DArtefTechnologyAr-JMM-3
13105: PPUSH
13106: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13110: LD_VAR 0 1
13114: PUSH
13115: LD_INT 1
13117: ARRAY
13118: PPUSH
13119: LD_STRING DArtefTechnologyAr-RSci1-4
13121: PPUSH
13122: CALL_OW 88
// if IsOk ( Burlak ) then
13126: LD_EXP 49
13130: PPUSH
13131: CALL_OW 302
13135: IFFALSE 13149
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13137: LD_EXP 49
13141: PPUSH
13142: LD_STRING DArtefTechnologyAr-Bur-4
13144: PPUSH
13145: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13149: LD_EXP 17
13153: PPUSH
13154: LD_STRING DArtefTechnologyAr-JMM-4
13156: PPUSH
13157: CALL_OW 88
// DialogueOff ;
13161: CALL_OW 7
// wait ( 0 0$45 ) ;
13165: LD_INT 1575
13167: PPUSH
13168: CALL_OW 67
// spawnOmar := true ;
13172: LD_ADDR_EXP 11
13176: PUSH
13177: LD_INT 1
13179: ST_TO_ADDR
// end ;
13180: PPOPN 1
13182: END
// every 0 0$1 trigger spawnOmar do
13183: LD_EXP 11
13187: IFFALSE 13567
13189: GO 13191
13191: DISABLE
// begin PrepareOmarAli ;
13192: CALL 6705 0 0
// if not HasTask ( Omar ) then
13196: LD_EXP 53
13200: PPUSH
13201: CALL_OW 314
13205: NOT
13206: IFFALSE 13223
// ComMoveXY ( Omar , 252 , 220 ) ;
13208: LD_EXP 53
13212: PPUSH
13213: LD_INT 252
13215: PPUSH
13216: LD_INT 220
13218: PPUSH
13219: CALL_OW 111
// if not Omar then
13223: LD_EXP 53
13227: NOT
13228: IFFALSE 13232
// exit ;
13230: GO 13567
// repeat wait ( 0 0$1 ) ;
13232: LD_INT 35
13234: PPUSH
13235: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13239: LD_EXP 53
13243: PPUSH
13244: CALL_OW 314
13248: NOT
13249: PUSH
13250: LD_EXP 53
13254: PPUSH
13255: LD_INT 252
13257: PPUSH
13258: LD_INT 220
13260: PPUSH
13261: CALL_OW 297
13265: PUSH
13266: LD_INT 6
13268: GREATER
13269: AND
13270: IFFALSE 13287
// ComMoveXY ( Omar , 252 , 220 ) ;
13272: LD_EXP 53
13276: PPUSH
13277: LD_INT 252
13279: PPUSH
13280: LD_INT 220
13282: PPUSH
13283: CALL_OW 111
// until See ( 7 , Omar ) ;
13287: LD_INT 7
13289: PPUSH
13290: LD_EXP 53
13294: PPUSH
13295: CALL_OW 292
13299: IFFALSE 13232
// CenterNowOnUnits ( Omar ) ;
13301: LD_EXP 53
13305: PPUSH
13306: CALL_OW 87
// DialogueOn ;
13310: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13314: LD_EXP 53
13318: PPUSH
13319: LD_STRING DOmar-Omar-1
13321: PPUSH
13322: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13326: LD_EXP 17
13330: PPUSH
13331: LD_STRING DOmar-JMM-1
13333: PPUSH
13334: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13338: LD_EXP 53
13342: PPUSH
13343: LD_STRING DOmar-Omar-2
13345: PPUSH
13346: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13350: LD_EXP 17
13354: PPUSH
13355: LD_STRING DOmar-JMM-2
13357: PPUSH
13358: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13362: LD_EXP 53
13366: PPUSH
13367: LD_STRING DOmar-Omar-3
13369: PPUSH
13370: CALL_OW 88
// if IsOk ( Burlak ) then
13374: LD_EXP 49
13378: PPUSH
13379: CALL_OW 302
13383: IFFALSE 13399
// Say ( Burlak , DOmar-Bur-3 ) else
13385: LD_EXP 49
13389: PPUSH
13390: LD_STRING DOmar-Bur-3
13392: PPUSH
13393: CALL_OW 88
13397: GO 13411
// Say ( JMM , DOmar-JMM-3 ) ;
13399: LD_EXP 17
13403: PPUSH
13404: LD_STRING DOmar-JMM-3
13406: PPUSH
13407: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13411: LD_EXP 53
13415: PPUSH
13416: LD_STRING DOmar-Omar-4
13418: PPUSH
13419: CALL_OW 88
// case Query ( QAccept ) of 1 :
13423: LD_STRING QAccept
13425: PPUSH
13426: CALL_OW 97
13430: PUSH
13431: LD_INT 1
13433: DOUBLE
13434: EQUAL
13435: IFTRUE 13439
13437: GO 13475
13439: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13440: LD_EXP 17
13444: PPUSH
13445: LD_STRING DQrAccept#1-JMM-1
13447: PPUSH
13448: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13452: LD_EXP 53
13456: PPUSH
13457: LD_INT 7
13459: PPUSH
13460: CALL_OW 235
// ComStop ( Omar ) ;
13464: LD_EXP 53
13468: PPUSH
13469: CALL_OW 141
// end ; 2 :
13473: GO 13524
13475: LD_INT 2
13477: DOUBLE
13478: EQUAL
13479: IFTRUE 13483
13481: GO 13523
13483: POP
// begin if IsOk ( Burlak ) then
13484: LD_EXP 49
13488: PPUSH
13489: CALL_OW 302
13493: IFFALSE 13509
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13495: LD_EXP 49
13499: PPUSH
13500: LD_STRING DQrAccept#2-Bur-1
13502: PPUSH
13503: CALL_OW 88
13507: GO 13521
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13509: LD_EXP 17
13513: PPUSH
13514: LD_STRING DQrAccept#2-JMM-1
13516: PPUSH
13517: CALL_OW 88
// end ; end ;
13521: GO 13524
13523: POP
// DialogueOff ;
13524: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13528: LD_EXP 53
13532: PPUSH
13533: CALL_OW 255
13537: PUSH
13538: LD_INT 7
13540: EQUAL
13541: IFFALSE 13552
// begin SetAchievement ( ACH_OMAR ) ;
13543: LD_STRING ACH_OMAR
13545: PPUSH
13546: CALL_OW 543
// exit ;
13550: GO 13567
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13552: LD_EXP 53
13556: PPUSH
13557: LD_INT 202
13559: PPUSH
13560: LD_INT 115
13562: PPUSH
13563: CALL_OW 111
// end ;
13567: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13568: LD_EXP 53
13572: PPUSH
13573: LD_INT 200
13575: PPUSH
13576: LD_INT 98
13578: PPUSH
13579: CALL_OW 297
13583: PUSH
13584: LD_INT 40
13586: LESS
13587: PUSH
13588: LD_EXP 2
13592: AND
13593: IFFALSE 13811
13595: GO 13597
13597: DISABLE
// begin SetSide ( Omar , 5 ) ;
13598: LD_EXP 53
13602: PPUSH
13603: LD_INT 5
13605: PPUSH
13606: CALL_OW 235
// if IsInUnit ( Omar ) then
13610: LD_EXP 53
13614: PPUSH
13615: CALL_OW 310
13619: IFFALSE 13630
// ComExitVehicle ( Omar ) ;
13621: LD_EXP 53
13625: PPUSH
13626: CALL_OW 121
// if IsInUnit ( Omar ) then
13630: LD_EXP 53
13634: PPUSH
13635: CALL_OW 310
13639: IFFALSE 13650
// ComExitBuilding ( Omar ) ;
13641: LD_EXP 53
13645: PPUSH
13646: CALL_OW 122
// wait ( 0 0$1 ) ;
13650: LD_INT 35
13652: PPUSH
13653: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13657: LD_EXP 53
13661: PPUSH
13662: LD_INT 203
13664: PPUSH
13665: LD_INT 120
13667: PPUSH
13668: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13672: LD_INT 35
13674: PPUSH
13675: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13679: LD_EXP 53
13683: PPUSH
13684: CALL_OW 306
13688: PUSH
13689: LD_EXP 53
13693: PPUSH
13694: LD_INT 203
13696: PPUSH
13697: LD_INT 120
13699: PPUSH
13700: CALL_OW 297
13704: PUSH
13705: LD_INT 6
13707: LESS
13708: OR
13709: IFFALSE 13672
// CenterNowOnUnits ( Omar ) ;
13711: LD_EXP 53
13715: PPUSH
13716: CALL_OW 87
// DialogueOn ;
13720: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13724: LD_EXP 17
13728: PPUSH
13729: LD_STRING DOmarContam-JMM-1
13731: PPUSH
13732: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13736: LD_EXP 53
13740: PPUSH
13741: LD_STRING DOmarContam-Omar-1
13743: PPUSH
13744: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13748: LD_EXP 17
13752: PPUSH
13753: LD_STRING DOmarContam-JMM-2
13755: PPUSH
13756: CALL_OW 88
// DialogueOff ;
13760: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13764: LD_INT 5
13766: PPUSH
13767: LD_INT 7
13769: PPUSH
13770: LD_INT 2
13772: PPUSH
13773: LD_INT 1
13775: PPUSH
13776: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13780: LD_INT 105
13782: PPUSH
13783: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13787: LD_EXP 53
13791: PPUSH
13792: LD_INT 203
13794: PPUSH
13795: LD_INT 120
13797: PPUSH
13798: CALL_OW 307
13802: IFFALSE 13780
// YouLost ( MothContaminate ) ;
13804: LD_STRING MothContaminate
13806: PPUSH
13807: CALL_OW 104
// end ;
13811: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13812: LD_EXP 4
13816: NOT
13817: PUSH
13818: LD_INT 22
13820: PUSH
13821: LD_INT 1
13823: PUSH
13824: EMPTY
13825: LIST
13826: LIST
13827: PUSH
13828: LD_INT 34
13830: PUSH
13831: LD_INT 8
13833: PUSH
13834: EMPTY
13835: LIST
13836: LIST
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PPUSH
13842: CALL_OW 69
13846: AND
13847: IFFALSE 13928
13849: GO 13851
13851: DISABLE
// begin if not IsOk ( Powell ) then
13852: LD_EXP 52
13856: PPUSH
13857: CALL_OW 302
13861: NOT
13862: IFFALSE 13866
// exit ;
13864: GO 13928
// DialogueOn ;
13866: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13870: LD_EXP 52
13874: PPUSH
13875: LD_STRING DWinAmericans-Pow-1
13877: PPUSH
13878: CALL_OW 94
// if IsOk ( Burlak ) then
13882: LD_EXP 49
13886: PPUSH
13887: CALL_OW 302
13891: IFFALSE 13905
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13893: LD_EXP 49
13897: PPUSH
13898: LD_STRING DWinAmericans-Bur-1
13900: PPUSH
13901: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13905: LD_EXP 17
13909: PPUSH
13910: LD_STRING DWinAmericans-JMM-1
13912: PPUSH
13913: CALL_OW 88
// DialogueOff ;
13917: CALL_OW 7
// YouLost ( AmBomb ) ;
13921: LD_STRING AmBomb
13923: PPUSH
13924: CALL_OW 104
// end ;
13928: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13929: LD_EXP 2
13933: NOT
13934: PUSH
13935: LD_INT 22
13937: PUSH
13938: LD_INT 3
13940: PUSH
13941: EMPTY
13942: LIST
13943: LIST
13944: PUSH
13945: LD_INT 34
13947: PUSH
13948: LD_INT 48
13950: PUSH
13951: EMPTY
13952: LIST
13953: LIST
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PPUSH
13959: CALL_OW 69
13963: AND
13964: IFFALSE 14045
13966: GO 13968
13968: DISABLE
// begin if not IsOk ( Platonov ) then
13969: LD_EXP 56
13973: PPUSH
13974: CALL_OW 302
13978: NOT
13979: IFFALSE 13983
// exit ;
13981: GO 14045
// DialogueOn ;
13983: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13987: LD_EXP 56
13991: PPUSH
13992: LD_STRING DWinRussians-Pla-1
13994: PPUSH
13995: CALL_OW 94
// if IsOk ( Burlak ) then
13999: LD_EXP 49
14003: PPUSH
14004: CALL_OW 302
14008: IFFALSE 14022
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14010: LD_EXP 49
14014: PPUSH
14015: LD_STRING DWinRussians-Bur-1
14017: PPUSH
14018: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14022: LD_EXP 17
14026: PPUSH
14027: LD_STRING DWinRussians-JMM-1
14029: PPUSH
14030: CALL_OW 88
// DialogueOff ;
14034: CALL_OW 7
// YouLost ( RuBomb ) ;
14038: LD_STRING RuBomb
14040: PPUSH
14041: CALL_OW 104
// end ;
14045: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14046: LD_INT 7
14048: PPUSH
14049: LD_INT 22
14051: PUSH
14052: LD_INT 7
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: PPUSH
14059: CALL_OW 70
14063: PUSH
14064: LD_EXP 4
14068: NOT
14069: AND
14070: IFFALSE 14099
14072: GO 14074
14074: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14075: LD_EXP 52
14079: PPUSH
14080: LD_STRING DSurrenderAmericans-Pow-1
14082: PPUSH
14083: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14087: LD_EXP 17
14091: PPUSH
14092: LD_STRING DSurrenderAmericans-JMM-1
14094: PPUSH
14095: CALL_OW 88
// end ;
14099: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14100: LD_INT 2
14102: PPUSH
14103: LD_INT 22
14105: PUSH
14106: LD_INT 7
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: PPUSH
14113: CALL_OW 70
14117: PUSH
14118: LD_EXP 2
14122: NOT
14123: AND
14124: PUSH
14125: LD_EXP 49
14129: AND
14130: IFFALSE 14159
14132: GO 14134
14134: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14135: LD_EXP 56
14139: PPUSH
14140: LD_STRING DSurrenderRussians-Pla-1
14142: PPUSH
14143: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14147: LD_EXP 49
14151: PPUSH
14152: LD_STRING DSurrenderRussians-Bur-1
14154: PPUSH
14155: CALL_OW 88
// end ;
14159: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14160: LD_EXP 4
14164: IFFALSE 14547
14166: GO 14168
14168: DISABLE
14169: LD_INT 0
14171: PPUSH
14172: PPUSH
14173: PPUSH
// begin MC_Kill ( 4 ) ;
14174: LD_INT 4
14176: PPUSH
14177: CALL 20813 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14181: LD_INT 1
14183: PPUSH
14184: LD_INT 7
14186: PPUSH
14187: LD_INT 1
14189: PPUSH
14190: LD_INT 1
14192: PPUSH
14193: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14197: LD_ADDR_VAR 0 3
14201: PUSH
14202: LD_INT 22
14204: PUSH
14205: LD_INT 1
14207: PUSH
14208: EMPTY
14209: LIST
14210: LIST
14211: PUSH
14212: LD_INT 26
14214: PUSH
14215: LD_INT 1
14217: PUSH
14218: EMPTY
14219: LIST
14220: LIST
14221: PUSH
14222: LD_INT 23
14224: PUSH
14225: LD_INT 1
14227: PUSH
14228: EMPTY
14229: LIST
14230: LIST
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: LIST
14236: PPUSH
14237: CALL_OW 69
14241: PUSH
14242: LD_EXP 52
14246: PUSH
14247: LD_EXP 25
14251: PUSH
14252: LD_EXP 22
14256: PUSH
14257: LD_EXP 21
14261: PUSH
14262: LD_EXP 28
14266: PUSH
14267: LD_EXP 26
14271: PUSH
14272: EMPTY
14273: LIST
14274: LIST
14275: LIST
14276: LIST
14277: LIST
14278: LIST
14279: DIFF
14280: ST_TO_ADDR
// if speaker then
14281: LD_VAR 0 3
14285: IFFALSE 14311
// begin DialogueOn ;
14287: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14291: LD_VAR 0 3
14295: PUSH
14296: LD_INT 1
14298: ARRAY
14299: PPUSH
14300: LD_STRING DSurrenderAmericans-Sol1-1a
14302: PPUSH
14303: CALL_OW 94
// DialogueOff ;
14307: CALL_OW 7
// end ; americanCapitulated := true ;
14311: LD_ADDR_EXP 6
14315: PUSH
14316: LD_INT 1
14318: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14319: LD_ADDR_VAR 0 2
14323: PUSH
14324: LD_INT 22
14326: PUSH
14327: LD_INT 1
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 21
14336: PUSH
14337: LD_INT 1
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PPUSH
14348: CALL_OW 69
14352: PUSH
14353: LD_INT 22
14355: PUSH
14356: LD_INT 1
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: LD_INT 21
14365: PUSH
14366: LD_INT 2
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 1
14375: PUSH
14376: EMPTY
14377: LIST
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: LIST
14383: PPUSH
14384: CALL_OW 69
14388: ADD
14389: ST_TO_ADDR
// if tmp then
14390: LD_VAR 0 2
14394: IFFALSE 14547
// repeat wait ( 0 0$1 ) ;
14396: LD_INT 35
14398: PPUSH
14399: CALL_OW 67
// for i in tmp do
14403: LD_ADDR_VAR 0 1
14407: PUSH
14408: LD_VAR 0 2
14412: PUSH
14413: FOR_IN
14414: IFFALSE 14496
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14416: LD_VAR 0 1
14420: PPUSH
14421: CALL_OW 310
14425: PUSH
14426: LD_VAR 0 1
14430: PPUSH
14431: CALL_OW 310
14435: PPUSH
14436: CALL_OW 247
14440: PUSH
14441: LD_INT 3
14443: EQUAL
14444: AND
14445: IFFALSE 14456
// ComExitBuilding ( i ) ;
14447: LD_VAR 0 1
14451: PPUSH
14452: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14456: LD_VAR 0 1
14460: PPUSH
14461: LD_INT 122
14463: PPUSH
14464: LD_INT 242
14466: PPUSH
14467: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14471: LD_VAR 0 1
14475: PPUSH
14476: LD_INT 35
14478: PPUSH
14479: CALL_OW 308
14483: IFFALSE 14494
// RemoveUnit ( i ) ;
14485: LD_VAR 0 1
14489: PPUSH
14490: CALL_OW 64
// end ;
14494: GO 14413
14496: POP
14497: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14498: LD_INT 22
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: PUSH
14508: LD_INT 2
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: LD_INT 33
14523: PUSH
14524: LD_INT 1
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: LIST
14535: PUSH
14536: EMPTY
14537: LIST
14538: LIST
14539: PPUSH
14540: CALL_OW 69
14544: NOT
14545: IFFALSE 14396
// end ;
14547: PPOPN 3
14549: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14550: LD_EXP 2
14554: IFFALSE 14955
14556: GO 14558
14558: DISABLE
14559: LD_INT 0
14561: PPUSH
14562: PPUSH
14563: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14564: LD_INT 35
14566: PPUSH
14567: CALL_OW 67
// until IsDead ( Yakotich ) ;
14571: LD_EXP 57
14575: PPUSH
14576: CALL_OW 301
14580: IFFALSE 14564
// MC_Kill ( 2 ) ;
14582: LD_INT 2
14584: PPUSH
14585: CALL 20813 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14589: LD_INT 3
14591: PPUSH
14592: LD_INT 7
14594: PPUSH
14595: LD_INT 1
14597: PPUSH
14598: LD_INT 1
14600: PPUSH
14601: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14605: LD_ADDR_VAR 0 3
14609: PUSH
14610: LD_INT 22
14612: PUSH
14613: LD_INT 3
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PUSH
14620: LD_INT 26
14622: PUSH
14623: LD_INT 1
14625: PUSH
14626: EMPTY
14627: LIST
14628: LIST
14629: PUSH
14630: LD_INT 23
14632: PUSH
14633: LD_INT 3
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: LIST
14644: PPUSH
14645: CALL_OW 69
14649: PUSH
14650: LD_EXP 56
14654: PUSH
14655: LD_EXP 57
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: DIFF
14664: ST_TO_ADDR
// if speaker then
14665: LD_VAR 0 3
14669: IFFALSE 14719
// begin DialogueOn ;
14671: CALL_OW 6
// if Burlak then
14675: LD_EXP 49
14679: IFFALSE 14699
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14681: LD_VAR 0 3
14685: PUSH
14686: LD_INT 1
14688: ARRAY
14689: PPUSH
14690: LD_STRING DSurrenderRussians-RSol1-1
14692: PPUSH
14693: CALL_OW 94
14697: GO 14715
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14699: LD_VAR 0 3
14703: PUSH
14704: LD_INT 1
14706: ARRAY
14707: PPUSH
14708: LD_STRING DSurrenderRussians-RSol1-1a
14710: PPUSH
14711: CALL_OW 94
// DialogueOff ;
14715: CALL_OW 7
// end ; russianCapitulated := true ;
14719: LD_ADDR_EXP 7
14723: PUSH
14724: LD_INT 1
14726: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14727: LD_ADDR_VAR 0 2
14731: PUSH
14732: LD_INT 22
14734: PUSH
14735: LD_INT 3
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PUSH
14742: LD_INT 21
14744: PUSH
14745: LD_INT 1
14747: PUSH
14748: EMPTY
14749: LIST
14750: LIST
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PPUSH
14756: CALL_OW 69
14760: PUSH
14761: LD_INT 22
14763: PUSH
14764: LD_INT 3
14766: PUSH
14767: EMPTY
14768: LIST
14769: LIST
14770: PUSH
14771: LD_INT 21
14773: PUSH
14774: LD_INT 2
14776: PUSH
14777: EMPTY
14778: LIST
14779: LIST
14780: PUSH
14781: LD_INT 1
14783: PUSH
14784: EMPTY
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: LIST
14791: PPUSH
14792: CALL_OW 69
14796: ADD
14797: ST_TO_ADDR
// if tmp then
14798: LD_VAR 0 2
14802: IFFALSE 14955
// repeat wait ( 0 0$1 ) ;
14804: LD_INT 35
14806: PPUSH
14807: CALL_OW 67
// for i in tmp do
14811: LD_ADDR_VAR 0 1
14815: PUSH
14816: LD_VAR 0 2
14820: PUSH
14821: FOR_IN
14822: IFFALSE 14904
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14824: LD_VAR 0 1
14828: PPUSH
14829: CALL_OW 310
14833: PUSH
14834: LD_VAR 0 1
14838: PPUSH
14839: CALL_OW 310
14843: PPUSH
14844: CALL_OW 247
14848: PUSH
14849: LD_INT 3
14851: EQUAL
14852: AND
14853: IFFALSE 14864
// ComExitBuilding ( i ) ;
14855: LD_VAR 0 1
14859: PPUSH
14860: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14864: LD_VAR 0 1
14868: PPUSH
14869: LD_INT 154
14871: PPUSH
14872: LD_INT 1
14874: PPUSH
14875: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14879: LD_VAR 0 1
14883: PPUSH
14884: LD_INT 36
14886: PPUSH
14887: CALL_OW 308
14891: IFFALSE 14902
// RemoveUnit ( i ) ;
14893: LD_VAR 0 1
14897: PPUSH
14898: CALL_OW 64
// end ;
14902: GO 14821
14904: POP
14905: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14906: LD_INT 22
14908: PUSH
14909: LD_INT 3
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: PUSH
14916: LD_INT 2
14918: PUSH
14919: LD_INT 21
14921: PUSH
14922: LD_INT 1
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PUSH
14929: LD_INT 33
14931: PUSH
14932: LD_INT 1
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: LIST
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: NOT
14953: IFFALSE 14804
// end ;
14955: PPOPN 3
14957: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14958: LD_INT 22
14960: PUSH
14961: LD_INT 8
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: PUSH
14968: LD_INT 21
14970: PUSH
14971: LD_INT 1
14973: PUSH
14974: EMPTY
14975: LIST
14976: LIST
14977: PUSH
14978: LD_INT 23
14980: PUSH
14981: LD_INT 2
14983: PUSH
14984: EMPTY
14985: LIST
14986: LIST
14987: PUSH
14988: EMPTY
14989: LIST
14990: LIST
14991: LIST
14992: PPUSH
14993: CALL_OW 69
14997: PUSH
14998: LD_INT 18
15000: LESS
15001: PUSH
15002: LD_EXP 55
15006: PPUSH
15007: CALL_OW 301
15011: OR
15012: PUSH
15013: LD_INT 324
15015: PPUSH
15016: CALL_OW 255
15020: PUSH
15021: LD_INT 7
15023: EQUAL
15024: OR
15025: IFFALSE 15038
15027: GO 15029
15029: DISABLE
// legionDestroyed := true ;
15030: LD_ADDR_EXP 3
15034: PUSH
15035: LD_INT 1
15037: ST_TO_ADDR
15038: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15039: LD_INT 22
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: PUSH
15049: LD_INT 21
15051: PUSH
15052: LD_INT 1
15054: PUSH
15055: EMPTY
15056: LIST
15057: LIST
15058: PUSH
15059: LD_INT 23
15061: PUSH
15062: LD_INT 2
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: PUSH
15079: LD_INT 9
15081: LESS
15082: IFFALSE 15095
15084: GO 15086
15086: DISABLE
// arabianDestroyed := true ;
15087: LD_ADDR_EXP 5
15091: PUSH
15092: LD_INT 1
15094: ST_TO_ADDR
15095: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15096: LD_EXP 5
15100: IFFALSE 15344
15102: GO 15104
15104: DISABLE
15105: LD_INT 0
15107: PPUSH
15108: PPUSH
// begin MC_Kill ( 1 ) ;
15109: LD_INT 1
15111: PPUSH
15112: CALL 20813 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15116: LD_ADDR_VAR 0 2
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 2
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PUSH
15131: LD_INT 21
15133: PUSH
15134: LD_INT 1
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PPUSH
15145: CALL_OW 69
15149: PUSH
15150: LD_INT 22
15152: PUSH
15153: LD_INT 8
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PUSH
15160: LD_INT 21
15162: PUSH
15163: LD_INT 2
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: LD_INT 1
15172: PUSH
15173: EMPTY
15174: LIST
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: LIST
15180: PPUSH
15181: CALL_OW 69
15185: ADD
15186: ST_TO_ADDR
// if tmp then
15187: LD_VAR 0 2
15191: IFFALSE 15344
// repeat wait ( 0 0$1 ) ;
15193: LD_INT 35
15195: PPUSH
15196: CALL_OW 67
// for i in tmp do
15200: LD_ADDR_VAR 0 1
15204: PUSH
15205: LD_VAR 0 2
15209: PUSH
15210: FOR_IN
15211: IFFALSE 15293
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15213: LD_VAR 0 1
15217: PPUSH
15218: CALL_OW 310
15222: PUSH
15223: LD_VAR 0 1
15227: PPUSH
15228: CALL_OW 310
15232: PPUSH
15233: CALL_OW 247
15237: PUSH
15238: LD_INT 3
15240: EQUAL
15241: AND
15242: IFFALSE 15253
// ComExitBuilding ( i ) ;
15244: LD_VAR 0 1
15248: PPUSH
15249: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15253: LD_VAR 0 1
15257: PPUSH
15258: LD_INT 254
15260: PPUSH
15261: LD_INT 268
15263: PPUSH
15264: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15268: LD_VAR 0 1
15272: PPUSH
15273: LD_INT 34
15275: PPUSH
15276: CALL_OW 308
15280: IFFALSE 15291
// RemoveUnit ( i ) ;
15282: LD_VAR 0 1
15286: PPUSH
15287: CALL_OW 64
// end ;
15291: GO 15210
15293: POP
15294: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15295: LD_INT 22
15297: PUSH
15298: LD_INT 2
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: PUSH
15305: LD_INT 2
15307: PUSH
15308: LD_INT 21
15310: PUSH
15311: LD_INT 1
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PUSH
15318: LD_INT 33
15320: PUSH
15321: LD_INT 1
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: LIST
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PPUSH
15337: CALL_OW 69
15341: NOT
15342: IFFALSE 15193
// end ;
15344: PPOPN 2
15346: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15347: LD_EXP 3
15351: IFFALSE 15703
15353: GO 15355
15355: DISABLE
15356: LD_INT 0
15358: PPUSH
15359: PPUSH
// begin MC_Kill ( 3 ) ;
15360: LD_INT 3
15362: PPUSH
15363: CALL 20813 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15367: LD_INT 8
15369: PPUSH
15370: LD_INT 7
15372: PPUSH
15373: LD_INT 1
15375: PPUSH
15376: LD_INT 1
15378: PPUSH
15379: CALL_OW 80
// DialogueOn ;
15383: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15387: LD_EXP 54
15391: PPUSH
15392: LD_STRING D15-Szulc-1
15394: PPUSH
15395: CALL_OW 94
// DialogueOff ;
15399: CALL_OW 7
// legionCapitulated := true ;
15403: LD_ADDR_EXP 8
15407: PUSH
15408: LD_INT 1
15410: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15411: LD_ADDR_VAR 0 1
15415: PUSH
15416: LD_INT 22
15418: PUSH
15419: LD_INT 8
15421: PUSH
15422: EMPTY
15423: LIST
15424: LIST
15425: PUSH
15426: LD_INT 21
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 23
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: LIST
15450: PPUSH
15451: CALL_OW 69
15455: PUSH
15456: FOR_IN
15457: IFFALSE 15473
// SetLives ( i , 3 ) ;
15459: LD_VAR 0 1
15463: PPUSH
15464: LD_INT 3
15466: PPUSH
15467: CALL_OW 234
15471: GO 15456
15473: POP
15474: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15475: LD_ADDR_VAR 0 2
15479: PUSH
15480: LD_INT 22
15482: PUSH
15483: LD_INT 8
15485: PUSH
15486: EMPTY
15487: LIST
15488: LIST
15489: PUSH
15490: LD_INT 21
15492: PUSH
15493: LD_INT 1
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PPUSH
15504: CALL_OW 69
15508: PUSH
15509: LD_INT 22
15511: PUSH
15512: LD_INT 8
15514: PUSH
15515: EMPTY
15516: LIST
15517: LIST
15518: PUSH
15519: LD_INT 21
15521: PUSH
15522: LD_INT 2
15524: PUSH
15525: EMPTY
15526: LIST
15527: LIST
15528: PUSH
15529: LD_INT 1
15531: PUSH
15532: EMPTY
15533: LIST
15534: PUSH
15535: EMPTY
15536: LIST
15537: LIST
15538: LIST
15539: PPUSH
15540: CALL_OW 69
15544: ADD
15545: ST_TO_ADDR
// if tmp then
15546: LD_VAR 0 2
15550: IFFALSE 15703
// repeat wait ( 0 0$1 ) ;
15552: LD_INT 35
15554: PPUSH
15555: CALL_OW 67
// for i in tmp do
15559: LD_ADDR_VAR 0 1
15563: PUSH
15564: LD_VAR 0 2
15568: PUSH
15569: FOR_IN
15570: IFFALSE 15652
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15572: LD_VAR 0 1
15576: PPUSH
15577: CALL_OW 310
15581: PUSH
15582: LD_VAR 0 1
15586: PPUSH
15587: CALL_OW 310
15591: PPUSH
15592: CALL_OW 247
15596: PUSH
15597: LD_INT 3
15599: EQUAL
15600: AND
15601: IFFALSE 15612
// ComExitBuilding ( i ) ;
15603: LD_VAR 0 1
15607: PPUSH
15608: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15612: LD_VAR 0 1
15616: PPUSH
15617: LD_INT 10
15619: PPUSH
15620: LD_INT 1
15622: PPUSH
15623: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15627: LD_VAR 0 1
15631: PPUSH
15632: LD_INT 32
15634: PPUSH
15635: CALL_OW 308
15639: IFFALSE 15650
// RemoveUnit ( i ) ;
15641: LD_VAR 0 1
15645: PPUSH
15646: CALL_OW 64
// end ;
15650: GO 15569
15652: POP
15653: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15654: LD_INT 22
15656: PUSH
15657: LD_INT 8
15659: PUSH
15660: EMPTY
15661: LIST
15662: LIST
15663: PUSH
15664: LD_INT 2
15666: PUSH
15667: LD_INT 21
15669: PUSH
15670: LD_INT 1
15672: PUSH
15673: EMPTY
15674: LIST
15675: LIST
15676: PUSH
15677: LD_INT 33
15679: PUSH
15680: LD_INT 1
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: LIST
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: PPUSH
15696: CALL_OW 69
15700: NOT
15701: IFFALSE 15552
// end ;
15703: PPOPN 2
15705: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated do var med1 , med2 ;
15706: LD_EXP 4
15710: PUSH
15711: LD_EXP 2
15715: AND
15716: PUSH
15717: LD_EXP 3
15721: AND
15722: PUSH
15723: LD_EXP 5
15727: AND
15728: PUSH
15729: LD_EXP 6
15733: AND
15734: PUSH
15735: LD_EXP 7
15739: AND
15740: PUSH
15741: LD_EXP 8
15745: AND
15746: IFFALSE 17137
15748: GO 15750
15750: DISABLE
15751: LD_INT 0
15753: PPUSH
15754: PPUSH
// begin wait ( 0 0$5 ) ;
15755: LD_INT 175
15757: PPUSH
15758: CALL_OW 67
// music_class := 5 ;
15762: LD_ADDR_OWVAR 72
15766: PUSH
15767: LD_INT 5
15769: ST_TO_ADDR
// music_nat := 5 ;
15770: LD_ADDR_OWVAR 71
15774: PUSH
15775: LD_INT 5
15777: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15778: LD_EXP 15
15782: PUSH
15783: LD_INT 3
15785: LESS
15786: IFFALSE 15795
// SetAchievement ( ACH_ECONOMY ) ;
15788: LD_STRING ACH_ECONOMY
15790: PPUSH
15791: CALL_OW 543
// if tick < 60 60$00 then
15795: LD_OWVAR 1
15799: PUSH
15800: LD_INT 126000
15802: LESS
15803: IFFALSE 15819
// begin wait ( 3 ) ;
15805: LD_INT 3
15807: PPUSH
15808: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15812: LD_STRING ACH_ASPEED_19
15814: PPUSH
15815: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15819: LD_EXP 17
15823: PPUSH
15824: CALL_OW 87
// InGameOn ;
15828: CALL_OW 8
// DialogueOn ;
15832: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15836: LD_EXP 17
15840: PPUSH
15841: LD_STRING DEnd-JMM-JMM-1
15843: PPUSH
15844: CALL_OW 88
// if Joan then
15848: LD_EXP 32
15852: IFFALSE 15868
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15854: LD_EXP 32
15858: PPUSH
15859: LD_STRING DEnd-JMM-Joan-1
15861: PPUSH
15862: CALL_OW 88
15866: GO 15912
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15868: LD_EXP 19
15872: PUSH
15873: LD_EXP 19
15877: PPUSH
15878: CALL_OW 255
15882: PUSH
15883: LD_INT 7
15885: EQUAL
15886: AND
15887: PUSH
15888: LD_EXP 19
15892: PPUSH
15893: CALL_OW 305
15897: AND
15898: IFFALSE 15912
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15900: LD_EXP 19
15904: PPUSH
15905: LD_STRING DEnd-JMM-Lisa-1
15907: PPUSH
15908: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15912: LD_EXP 29
15916: PUSH
15917: LD_EXP 29
15921: PPUSH
15922: CALL_OW 305
15926: AND
15927: IFFALSE 15941
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15929: LD_EXP 29
15933: PPUSH
15934: LD_STRING DEnd-JMM-Frank-1
15936: PPUSH
15937: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15941: LD_EXP 22
15945: PUSH
15946: LD_EXP 22
15950: PPUSH
15951: CALL_OW 255
15955: PUSH
15956: LD_INT 7
15958: EQUAL
15959: AND
15960: PUSH
15961: LD_EXP 22
15965: PPUSH
15966: CALL_OW 305
15970: AND
15971: IFFALSE 15985
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15973: LD_EXP 22
15977: PPUSH
15978: LD_STRING DEnd-JMM-Cyrus-1
15980: PPUSH
15981: CALL_OW 88
// if Burlak then
15985: LD_EXP 49
15989: IFFALSE 16003
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15991: LD_EXP 49
15995: PPUSH
15996: LD_STRING DEnd-JMM-Bur-1
15998: PPUSH
15999: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16003: LD_EXP 32
16007: PUSH
16008: LD_EXP 19
16012: AND
16013: PUSH
16014: LD_EXP 19
16018: PPUSH
16019: CALL_OW 255
16023: PUSH
16024: LD_INT 7
16026: EQUAL
16027: AND
16028: PUSH
16029: LD_EXP 19
16033: PPUSH
16034: CALL_OW 305
16038: AND
16039: IFFALSE 16053
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16041: LD_EXP 19
16045: PPUSH
16046: LD_STRING DEnd-Burlak-Lisa-1
16048: PPUSH
16049: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16053: LD_EXP 50
16057: PUSH
16058: LD_EXP 50
16062: PPUSH
16063: CALL_OW 305
16067: AND
16068: IFFALSE 16082
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16070: LD_EXP 50
16074: PPUSH
16075: LD_STRING DEnd-JMM-Bel-1
16077: PPUSH
16078: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16082: LD_EXP 51
16086: PUSH
16087: LD_EXP 51
16091: PPUSH
16092: CALL_OW 305
16096: AND
16097: IFFALSE 16111
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16099: LD_EXP 51
16103: PPUSH
16104: LD_STRING DEnd-JMM-Gny-1
16106: PPUSH
16107: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16111: LD_EXP 27
16115: PUSH
16116: LD_EXP 27
16120: PPUSH
16121: CALL_OW 255
16125: PUSH
16126: LD_INT 7
16128: EQUAL
16129: AND
16130: PUSH
16131: LD_EXP 27
16135: PPUSH
16136: CALL_OW 305
16140: AND
16141: IFFALSE 16155
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16143: LD_EXP 27
16147: PPUSH
16148: LD_STRING DEnd-JMM-Corn-1
16150: PPUSH
16151: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16155: LD_EXP 20
16159: PUSH
16160: LD_EXP 20
16164: PPUSH
16165: CALL_OW 255
16169: PUSH
16170: LD_INT 7
16172: EQUAL
16173: AND
16174: PUSH
16175: LD_EXP 20
16179: PPUSH
16180: CALL_OW 305
16184: AND
16185: IFFALSE 16199
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16187: LD_EXP 20
16191: PPUSH
16192: LD_STRING DEnd-JMM-Don-1
16194: PPUSH
16195: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16199: LD_EXP 21
16203: PUSH
16204: LD_EXP 21
16208: PPUSH
16209: CALL_OW 255
16213: PUSH
16214: LD_INT 7
16216: EQUAL
16217: AND
16218: PUSH
16219: LD_EXP 21
16223: PPUSH
16224: CALL_OW 305
16228: AND
16229: IFFALSE 16243
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16231: LD_EXP 21
16235: PPUSH
16236: LD_STRING DEnd-JMM-Bobby-1
16238: PPUSH
16239: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16243: LD_EXP 23
16247: PUSH
16248: LD_EXP 23
16252: PPUSH
16253: CALL_OW 255
16257: PUSH
16258: LD_INT 7
16260: EQUAL
16261: AND
16262: PUSH
16263: LD_EXP 23
16267: PPUSH
16268: CALL_OW 305
16272: AND
16273: IFFALSE 16287
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16275: LD_EXP 23
16279: PPUSH
16280: LD_STRING DEnd-JMM-Den-1
16282: PPUSH
16283: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16287: LD_EXP 25
16291: PUSH
16292: LD_EXP 25
16296: PPUSH
16297: CALL_OW 255
16301: PUSH
16302: LD_INT 7
16304: EQUAL
16305: AND
16306: PUSH
16307: LD_EXP 25
16311: PPUSH
16312: CALL_OW 305
16316: AND
16317: IFFALSE 16331
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16319: LD_EXP 25
16323: PPUSH
16324: LD_STRING DEnd-JMM-Glad-1
16326: PPUSH
16327: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16331: LD_EXP 30
16335: PUSH
16336: LD_EXP 30
16340: PPUSH
16341: CALL_OW 255
16345: PUSH
16346: LD_INT 7
16348: EQUAL
16349: AND
16350: PUSH
16351: LD_EXP 30
16355: PPUSH
16356: CALL_OW 305
16360: AND
16361: IFFALSE 16375
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16363: LD_EXP 30
16367: PPUSH
16368: LD_STRING DEnd-JMM-Yam-1
16370: PPUSH
16371: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16375: LD_EXP 24
16379: PUSH
16380: LD_EXP 24
16384: PPUSH
16385: CALL_OW 255
16389: PUSH
16390: LD_INT 7
16392: EQUAL
16393: AND
16394: PUSH
16395: LD_EXP 24
16399: PPUSH
16400: CALL_OW 305
16404: AND
16405: IFFALSE 16419
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16407: LD_EXP 24
16411: PPUSH
16412: LD_STRING DEnd-JMM-Brown-1
16414: PPUSH
16415: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16419: LD_EXP 34
16423: PUSH
16424: LD_EXP 34
16428: PPUSH
16429: CALL_OW 255
16433: PUSH
16434: LD_INT 7
16436: EQUAL
16437: AND
16438: PUSH
16439: LD_EXP 34
16443: PPUSH
16444: CALL_OW 305
16448: AND
16449: IFFALSE 16463
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16451: LD_EXP 34
16455: PPUSH
16456: LD_STRING DEnd-JMM-Con-1
16458: PPUSH
16459: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16463: LD_EXP 28
16467: PUSH
16468: LD_EXP 28
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 7
16480: EQUAL
16481: AND
16482: PUSH
16483: LD_EXP 28
16487: PPUSH
16488: CALL_OW 305
16492: AND
16493: IFFALSE 16507
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16495: LD_EXP 28
16499: PPUSH
16500: LD_STRING DEnd-JMM-Gary-1
16502: PPUSH
16503: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16507: LD_EXP 31
16511: PUSH
16512: LD_EXP 18
16516: AND
16517: PUSH
16518: LD_EXP 31
16522: PPUSH
16523: CALL_OW 305
16527: AND
16528: IFFALSE 16542
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16530: LD_EXP 31
16534: PPUSH
16535: LD_STRING DEnd-JMM-Sim-1
16537: PPUSH
16538: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16542: LD_EXP 26
16546: PUSH
16547: LD_EXP 26
16551: PPUSH
16552: CALL_OW 255
16556: PUSH
16557: LD_INT 7
16559: EQUAL
16560: AND
16561: PUSH
16562: LD_EXP 26
16566: PPUSH
16567: CALL_OW 305
16571: AND
16572: IFFALSE 16586
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16574: LD_EXP 26
16578: PPUSH
16579: LD_STRING DEnd-JMM-VanH-1
16581: PPUSH
16582: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16586: LD_EXP 39
16590: PUSH
16591: LD_EXP 39
16595: PPUSH
16596: CALL_OW 305
16600: AND
16601: IFFALSE 16615
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16603: LD_EXP 39
16607: PPUSH
16608: LD_STRING DEnd-JMM-Dol-1
16610: PPUSH
16611: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16615: LD_EXP 43
16619: PUSH
16620: LD_EXP 43
16624: PPUSH
16625: CALL_OW 305
16629: AND
16630: IFFALSE 16644
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16632: LD_EXP 43
16636: PPUSH
16637: LD_STRING DEnd-JMM-Kap-1
16639: PPUSH
16640: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16644: LD_EXP 46
16648: PUSH
16649: LD_EXP 46
16653: PPUSH
16654: CALL_OW 305
16658: AND
16659: IFFALSE 16673
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16661: LD_EXP 46
16665: PPUSH
16666: LD_STRING DEnd-JMM-Kov-1
16668: PPUSH
16669: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16673: LD_EXP 41
16677: PUSH
16678: LD_EXP 41
16682: PPUSH
16683: CALL_OW 305
16687: AND
16688: IFFALSE 16702
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16690: LD_EXP 41
16694: PPUSH
16695: LD_STRING DEnd-JMM-Sch-1
16697: PPUSH
16698: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16702: LD_EXP 37
16706: PUSH
16707: LD_EXP 37
16711: PPUSH
16712: CALL_OW 305
16716: AND
16717: IFFALSE 16731
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16719: LD_EXP 37
16723: PPUSH
16724: LD_STRING DEnd-JMM-Tit-1
16726: PPUSH
16727: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16731: LD_EXP 42
16735: PUSH
16736: LD_EXP 42
16740: PPUSH
16741: CALL_OW 305
16745: AND
16746: IFFALSE 16760
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16748: LD_EXP 42
16752: PPUSH
16753: LD_STRING DEnd-JMM-Obl-1
16755: PPUSH
16756: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16760: LD_EXP 44
16764: PUSH
16765: LD_EXP 44
16769: PPUSH
16770: CALL_OW 305
16774: AND
16775: IFFALSE 16789
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16777: LD_EXP 44
16781: PPUSH
16782: LD_STRING DEnd-JMM-Lip-1
16784: PPUSH
16785: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16789: LD_EXP 38
16793: PUSH
16794: LD_EXP 38
16798: PPUSH
16799: CALL_OW 305
16803: AND
16804: PUSH
16805: LD_EXP 49
16809: AND
16810: IFFALSE 16824
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16812: LD_EXP 38
16816: PPUSH
16817: LD_STRING DEnd-Burlak-Fad-1
16819: PPUSH
16820: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16824: LD_EXP 45
16828: PUSH
16829: LD_EXP 45
16833: PPUSH
16834: CALL_OW 305
16838: AND
16839: IFFALSE 16853
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16841: LD_EXP 45
16845: PPUSH
16846: LD_STRING DEnd-Burlak-Ptr-1
16848: PPUSH
16849: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16853: LD_EXP 47
16857: PUSH
16858: LD_EXP 47
16862: PPUSH
16863: CALL_OW 305
16867: AND
16868: IFFALSE 16882
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16870: LD_EXP 47
16874: PPUSH
16875: LD_STRING DEnd-Burlak-Kuz-1
16877: PPUSH
16878: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16882: LD_EXP 36
16886: PUSH
16887: LD_EXP 36
16891: PPUSH
16892: CALL_OW 305
16896: AND
16897: PUSH
16898: LD_EXP 49
16902: AND
16903: IFFALSE 16917
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16905: LD_EXP 36
16909: PPUSH
16910: LD_STRING DEnd-Burlak-Kir-1
16912: PPUSH
16913: CALL_OW 88
// if Burlak then
16917: LD_EXP 49
16921: IFFALSE 16935
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16923: LD_EXP 17
16927: PPUSH
16928: LD_STRING DEnd-Burlak-JMM-1
16930: PPUSH
16931: CALL_OW 88
// dwait ( 0 0$2 ) ;
16935: LD_INT 70
16937: PPUSH
16938: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16942: LD_EXP 54
16946: PPUSH
16947: LD_STRING DEnd-Szulc
16949: PPUSH
16950: CALL_OW 94
// dwait ( 0 0$1 ) ;
16954: LD_INT 35
16956: PPUSH
16957: CALL_OW 68
// if IsLive ( Burlak ) then
16961: LD_EXP 49
16965: PPUSH
16966: CALL_OW 300
16970: IFFALSE 16982
// med1 := 1 else
16972: LD_ADDR_VAR 0 1
16976: PUSH
16977: LD_INT 1
16979: ST_TO_ADDR
16980: GO 16991
// med1 := - 1 ;
16982: LD_ADDR_VAR 0 1
16986: PUSH
16987: LD_INT 1
16989: NEG
16990: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16991: LD_EXP 12
16995: PUSH
16996: LD_EXP 13
17000: AND
17001: PUSH
17002: LD_EXP 14
17006: AND
17007: IFFALSE 17019
// med2 := 1 else
17009: LD_ADDR_VAR 0 2
17013: PUSH
17014: LD_INT 1
17016: ST_TO_ADDR
17017: GO 17028
// med2 := - 1 ;
17019: LD_ADDR_VAR 0 2
17023: PUSH
17024: LD_INT 1
17026: NEG
17027: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17028: LD_STRING Hero
17030: PPUSH
17031: LD_INT 1
17033: PPUSH
17034: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17038: LD_STRING Artefact
17040: PPUSH
17041: LD_VAR 0 2
17045: PPUSH
17046: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17050: LD_STRING ReconcileBurlak
17052: PPUSH
17053: LD_VAR 0 1
17057: PPUSH
17058: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17062: LD_OWVAR 67
17066: PUSH
17067: LD_INT 3
17069: EQUAL
17070: PUSH
17071: LD_VAR 0 1
17075: PUSH
17076: LD_INT 1
17078: EQUAL
17079: AND
17080: PUSH
17081: LD_VAR 0 2
17085: PUSH
17086: LD_INT 1
17088: EQUAL
17089: AND
17090: IFFALSE 17102
// SetAchievementEX ( ACH_AMER , 19 ) ;
17092: LD_STRING ACH_AMER
17094: PPUSH
17095: LD_INT 19
17097: PPUSH
17098: CALL_OW 564
// GiveMedals ( MAIN ) ;
17102: LD_STRING MAIN
17104: PPUSH
17105: CALL_OW 102
// InGameOff ;
17109: CALL_OW 9
// DialogueOff ;
17113: CALL_OW 7
// music_nat := 1 ;
17117: LD_ADDR_OWVAR 71
17121: PUSH
17122: LD_INT 1
17124: ST_TO_ADDR
// music_class := 4 ;
17125: LD_ADDR_OWVAR 72
17129: PUSH
17130: LD_INT 4
17132: ST_TO_ADDR
// YouWin ;
17133: CALL_OW 103
// end ; end_of_file
17137: PPOPN 2
17139: END
// export function InitNature ; begin
17140: LD_INT 0
17142: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17143: LD_INT 3
17145: PPUSH
17146: LD_INT 3
17148: PPUSH
17149: LD_INT 2
17151: PPUSH
17152: LD_INT 1
17154: PPUSH
17155: LD_INT 1
17157: PPUSH
17158: LD_INT 0
17160: PPUSH
17161: LD_INT 0
17163: PPUSH
17164: LD_INT 17
17166: PPUSH
17167: LD_INT 0
17169: PPUSH
17170: CALL 83216 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17174: LD_INT 2
17176: PPUSH
17177: LD_INT 1
17179: PPUSH
17180: LD_INT 1
17182: PPUSH
17183: LD_INT 1
17185: PPUSH
17186: LD_INT 1
17188: PPUSH
17189: LD_INT 0
17191: PPUSH
17192: LD_INT 0
17194: PPUSH
17195: LD_INT 18
17197: PPUSH
17198: LD_INT 0
17200: PPUSH
17201: CALL 83216 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17205: LD_INT 4
17207: PPUSH
17208: LD_INT 1
17210: PPUSH
17211: LD_INT 2
17213: PPUSH
17214: LD_INT 4
17216: PPUSH
17217: LD_INT 2
17219: PPUSH
17220: LD_INT 1
17222: PPUSH
17223: LD_INT 0
17225: PPUSH
17226: LD_INT 19
17228: PPUSH
17229: LD_INT 0
17231: PPUSH
17232: CALL 83216 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17236: LD_INT 0
17238: PPUSH
17239: LD_INT 0
17241: PPUSH
17242: LD_INT 0
17244: PPUSH
17245: LD_INT 0
17247: PPUSH
17248: LD_INT 0
17250: PPUSH
17251: LD_INT 0
17253: PPUSH
17254: LD_INT 9
17256: PPUSH
17257: LD_INT 0
17259: PPUSH
17260: LD_INT 20
17262: PPUSH
17263: CALL 83216 0 9
// end ; end_of_file
17267: LD_VAR 0 1
17271: RET
// every 0 0$30 do var time ;
17272: GO 17274
17274: DISABLE
17275: LD_INT 0
17277: PPUSH
// begin time := 0 0$50 ;
17278: LD_ADDR_VAR 0 1
17282: PUSH
17283: LD_INT 1750
17285: ST_TO_ADDR
// repeat wait ( time ) ;
17286: LD_VAR 0 1
17290: PPUSH
17291: CALL_OW 67
// if Prob ( 50 ) then
17295: LD_INT 50
17297: PPUSH
17298: CALL_OW 13
17302: IFFALSE 17331
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17304: LD_INT 1
17306: PPUSH
17307: LD_INT 5
17309: PPUSH
17310: CALL_OW 12
17314: PPUSH
17315: LD_INT 106
17317: PPUSH
17318: LD_INT 89
17320: PPUSH
17321: LD_INT 45
17323: PPUSH
17324: LD_INT 1
17326: PPUSH
17327: CALL_OW 56
// time := time + 0 0$3 ;
17331: LD_ADDR_VAR 0 1
17335: PUSH
17336: LD_VAR 0 1
17340: PUSH
17341: LD_INT 105
17343: PLUS
17344: ST_TO_ADDR
// if Prob ( 30 ) then
17345: LD_INT 30
17347: PPUSH
17348: CALL_OW 13
17352: IFFALSE 17398
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17354: LD_INT 525
17356: PPUSH
17357: LD_INT 735
17359: PPUSH
17360: CALL_OW 12
17364: PPUSH
17365: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17369: LD_INT 1
17371: PPUSH
17372: LD_INT 5
17374: PPUSH
17375: CALL_OW 12
17379: PPUSH
17380: LD_INT 21
17382: PPUSH
17383: LD_INT 26
17385: PPUSH
17386: LD_INT 12
17388: PPUSH
17389: LD_INT 1
17391: PPUSH
17392: CALL_OW 56
// end else
17396: GO 17434
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17398: LD_INT 700
17400: PPUSH
17401: LD_INT 1225
17403: PPUSH
17404: CALL_OW 12
17408: PPUSH
17409: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17413: LD_INT 1
17415: PPUSH
17416: LD_INT 5
17418: PPUSH
17419: CALL_OW 12
17423: PPUSH
17424: LD_INT 14
17426: PPUSH
17427: LD_INT 1
17429: PPUSH
17430: CALL_OW 55
// end ; if Prob ( 50 ) then
17434: LD_INT 50
17436: PPUSH
17437: CALL_OW 13
17441: IFFALSE 17487
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17443: LD_INT 700
17445: PPUSH
17446: LD_INT 1050
17448: PPUSH
17449: CALL_OW 12
17453: PPUSH
17454: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17458: LD_INT 1
17460: PPUSH
17461: LD_INT 5
17463: PPUSH
17464: CALL_OW 12
17468: PPUSH
17469: LD_INT 181
17471: PPUSH
17472: LD_INT 218
17474: PPUSH
17475: LD_INT 16
17477: PPUSH
17478: LD_INT 1
17480: PPUSH
17481: CALL_OW 56
// end else
17485: GO 17559
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17487: LD_INT 350
17489: PPUSH
17490: LD_INT 525
17492: PPUSH
17493: CALL_OW 12
17497: PPUSH
17498: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17502: LD_INT 1
17504: PPUSH
17505: LD_INT 5
17507: PPUSH
17508: CALL_OW 12
17512: PPUSH
17513: LD_INT 13
17515: PPUSH
17516: LD_INT 1
17518: PPUSH
17519: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17523: LD_INT 350
17525: PPUSH
17526: LD_INT 700
17528: PPUSH
17529: CALL_OW 12
17533: PPUSH
17534: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17538: LD_INT 1
17540: PPUSH
17541: LD_INT 5
17543: PPUSH
17544: CALL_OW 12
17548: PPUSH
17549: LD_INT 33
17551: PPUSH
17552: LD_INT 1
17554: PPUSH
17555: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17559: LD_INT 65
17561: PUSH
17562: LD_INT 62
17564: PUSH
17565: LD_INT 55
17567: PUSH
17568: EMPTY
17569: LIST
17570: LIST
17571: LIST
17572: PUSH
17573: LD_OWVAR 67
17577: ARRAY
17578: PPUSH
17579: CALL_OW 13
17583: IFFALSE 17629
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17585: LD_INT 525
17587: PPUSH
17588: LD_INT 875
17590: PPUSH
17591: CALL_OW 12
17595: PPUSH
17596: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17600: LD_INT 1
17602: PPUSH
17603: LD_INT 5
17605: PPUSH
17606: CALL_OW 12
17610: PPUSH
17611: LD_INT 294
17613: PPUSH
17614: LD_INT 211
17616: PPUSH
17617: LD_INT 30
17619: PPUSH
17620: LD_INT 1
17622: PPUSH
17623: CALL_OW 56
// end else
17627: GO 17671
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17629: LD_INT 420
17631: PPUSH
17632: LD_INT 770
17634: PPUSH
17635: CALL_OW 12
17639: PPUSH
17640: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17644: LD_INT 1
17646: PPUSH
17647: LD_INT 5
17649: PPUSH
17650: CALL_OW 12
17654: PPUSH
17655: LD_INT 294
17657: PPUSH
17658: LD_INT 211
17660: PPUSH
17661: LD_INT 30
17663: PPUSH
17664: LD_INT 1
17666: PPUSH
17667: CALL_OW 56
// end ; if time > 2 2$20 then
17671: LD_VAR 0 1
17675: PUSH
17676: LD_INT 4900
17678: GREATER
17679: IFFALSE 17689
// time := 0 0$50 ;
17681: LD_ADDR_VAR 0 1
17685: PUSH
17686: LD_INT 1750
17688: ST_TO_ADDR
// until false ;
17689: LD_INT 0
17691: IFFALSE 17286
// end ;
17693: PPOPN 1
17695: END
// every 0 0$45 trigger tick < 10 10$00 do
17696: LD_OWVAR 1
17700: PUSH
17701: LD_INT 21000
17703: LESS
17704: IFFALSE 17752
17706: GO 17708
17708: DISABLE
// begin enable ;
17709: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17710: LD_INT 350
17712: PPUSH
17713: LD_INT 700
17715: PPUSH
17716: CALL_OW 12
17720: PPUSH
17721: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17725: LD_INT 3
17727: PPUSH
17728: LD_INT 5
17730: PPUSH
17731: CALL_OW 12
17735: PPUSH
17736: LD_INT 181
17738: PPUSH
17739: LD_INT 13
17741: PPUSH
17742: LD_INT 20
17744: PPUSH
17745: LD_INT 1
17747: PPUSH
17748: CALL_OW 56
// end ; end_of_file
17752: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17753: LD_INT 0
17755: PPUSH
// SetArtifactRes ( 7 , true ) ;
17756: LD_INT 7
17758: PPUSH
17759: LD_INT 1
17761: PPUSH
17762: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17766: LD_ADDR_EXP 62
17770: PUSH
17771: EMPTY
17772: PUSH
17773: EMPTY
17774: PUSH
17775: EMPTY
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: LIST
17781: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17782: LD_ADDR_EXP 63
17786: PUSH
17787: LD_INT 1050
17789: PUSH
17790: LD_OWVAR 67
17794: MUL
17795: PUSH
17796: LD_INT 2800
17798: PUSH
17799: LD_OWVAR 67
17803: MUL
17804: PUSH
17805: LD_INT 1
17807: NEG
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: LIST
17813: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17814: LD_ADDR_EXP 64
17818: PUSH
17819: LD_INT 10
17821: PUSH
17822: LD_INT 35
17824: PUSH
17825: LD_INT 100
17827: PUSH
17828: EMPTY
17829: LIST
17830: LIST
17831: LIST
17832: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17833: LD_ADDR_EXP 65
17837: PUSH
17838: LD_INT 0
17840: PUSH
17841: LD_INT 0
17843: PUSH
17844: LD_INT 0
17846: PUSH
17847: EMPTY
17848: LIST
17849: LIST
17850: LIST
17851: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17852: LD_ADDR_EXP 67
17856: PUSH
17857: LD_INT 300
17859: PUSH
17860: LD_INT 500
17862: PUSH
17863: LD_INT 800
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: LIST
17870: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17871: LD_ADDR_EXP 68
17875: PUSH
17876: LD_INT 0
17878: PUSH
17879: LD_INT 0
17881: PUSH
17882: LD_INT 0
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: LIST
17889: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17890: LD_ADDR_EXP 69
17894: PUSH
17895: LD_INT 0
17897: PUSH
17898: LD_INT 0
17900: PUSH
17901: LD_INT 0
17903: PUSH
17904: EMPTY
17905: LIST
17906: LIST
17907: LIST
17908: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17909: LD_ADDR_EXP 66
17913: PUSH
17914: LD_INT 0
17916: PUSH
17917: LD_INT 0
17919: PUSH
17920: LD_INT 0
17922: PUSH
17923: EMPTY
17924: LIST
17925: LIST
17926: LIST
17927: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17928: LD_ADDR_EXP 70
17932: PUSH
17933: LD_INT 4
17935: PUSH
17936: LD_INT 3
17938: PUSH
17939: LD_INT 1
17941: PUSH
17942: EMPTY
17943: LIST
17944: LIST
17945: LIST
17946: PUSH
17947: LD_INT 5
17949: PUSH
17950: LD_INT 4
17952: PUSH
17953: LD_INT 2
17955: PUSH
17956: EMPTY
17957: LIST
17958: LIST
17959: LIST
17960: PUSH
17961: LD_INT 6
17963: PUSH
17964: LD_INT 3
17966: PUSH
17967: LD_INT 3
17969: PUSH
17970: EMPTY
17971: LIST
17972: LIST
17973: LIST
17974: PUSH
17975: EMPTY
17976: LIST
17977: LIST
17978: LIST
17979: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17980: LD_ADDR_EXP 71
17984: PUSH
17985: LD_INT 0
17987: PUSH
17988: LD_INT 0
17990: PUSH
17991: LD_INT 0
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: LIST
17998: ST_TO_ADDR
// end ;
17999: LD_VAR 0 1
18003: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18004: LD_INT 24
18006: PPUSH
18007: LD_INT 7
18009: PPUSH
18010: CALL_OW 321
18014: PUSH
18015: LD_INT 2
18017: EQUAL
18018: IFFALSE 18944
18020: GO 18022
18022: DISABLE
18023: LD_INT 0
18025: PPUSH
18026: PPUSH
18027: PPUSH
18028: PPUSH
18029: PPUSH
// begin enable ;
18030: ENABLE
// for i = 1 to 3 do
18031: LD_ADDR_VAR 0 1
18035: PUSH
18036: DOUBLE
18037: LD_INT 1
18039: DEC
18040: ST_TO_ADDR
18041: LD_INT 3
18043: PUSH
18044: FOR_TO
18045: IFFALSE 18942
// begin pos := FindArtifact ( i + 2 ) ;
18047: LD_ADDR_VAR 0 2
18051: PUSH
18052: LD_VAR 0 1
18056: PUSH
18057: LD_INT 2
18059: PLUS
18060: PPUSH
18061: CALL_OW 469
18065: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18066: LD_ADDR_EXP 62
18070: PUSH
18071: LD_EXP 62
18075: PPUSH
18076: LD_VAR 0 1
18080: PPUSH
18081: LD_VAR 0 2
18085: PPUSH
18086: CALL_OW 1
18090: ST_TO_ADDR
// if pos then
18091: LD_VAR 0 2
18095: IFFALSE 18803
// begin case i of 1 :
18097: LD_VAR 0 1
18101: PUSH
18102: LD_INT 1
18104: DOUBLE
18105: EQUAL
18106: IFTRUE 18110
18108: GO 18187
18110: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18111: LD_ADDR_VAR 0 4
18115: PUSH
18116: LD_INT 22
18118: PUSH
18119: LD_INT 7
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: PUSH
18126: LD_INT 23
18128: PUSH
18129: LD_INT 1
18131: PUSH
18132: EMPTY
18133: LIST
18134: LIST
18135: PUSH
18136: LD_INT 2
18138: PUSH
18139: LD_INT 30
18141: PUSH
18142: LD_INT 8
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: PUSH
18149: LD_INT 30
18151: PUSH
18152: LD_INT 7
18154: PUSH
18155: EMPTY
18156: LIST
18157: LIST
18158: PUSH
18159: LD_INT 30
18161: PUSH
18162: LD_INT 11
18164: PUSH
18165: EMPTY
18166: LIST
18167: LIST
18168: PUSH
18169: EMPTY
18170: LIST
18171: LIST
18172: LIST
18173: LIST
18174: PUSH
18175: EMPTY
18176: LIST
18177: LIST
18178: LIST
18179: PPUSH
18180: CALL_OW 69
18184: ST_TO_ADDR
18185: GO 18295
18187: LD_INT 2
18189: DOUBLE
18190: EQUAL
18191: IFTRUE 18195
18193: GO 18272
18195: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18196: LD_ADDR_VAR 0 4
18200: PUSH
18201: LD_INT 22
18203: PUSH
18204: LD_INT 7
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PUSH
18211: LD_INT 23
18213: PUSH
18214: LD_INT 3
18216: PUSH
18217: EMPTY
18218: LIST
18219: LIST
18220: PUSH
18221: LD_INT 2
18223: PUSH
18224: LD_INT 30
18226: PUSH
18227: LD_INT 8
18229: PUSH
18230: EMPTY
18231: LIST
18232: LIST
18233: PUSH
18234: LD_INT 30
18236: PUSH
18237: LD_INT 7
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: PUSH
18244: LD_INT 30
18246: PUSH
18247: LD_INT 11
18249: PUSH
18250: EMPTY
18251: LIST
18252: LIST
18253: PUSH
18254: EMPTY
18255: LIST
18256: LIST
18257: LIST
18258: LIST
18259: PUSH
18260: EMPTY
18261: LIST
18262: LIST
18263: LIST
18264: PPUSH
18265: CALL_OW 69
18269: ST_TO_ADDR
18270: GO 18295
18272: LD_INT 3
18274: DOUBLE
18275: EQUAL
18276: IFTRUE 18280
18278: GO 18294
18280: POP
// labs := [ alien ] ; end ;
18281: LD_ADDR_VAR 0 4
18285: PUSH
18286: LD_INT 1
18288: PUSH
18289: EMPTY
18290: LIST
18291: ST_TO_ADDR
18292: GO 18295
18294: POP
// if not labs then
18295: LD_VAR 0 4
18299: NOT
18300: IFFALSE 18304
// continue ;
18302: GO 18044
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18304: LD_ADDR_VAR 0 5
18308: PUSH
18309: LD_VAR 0 4
18313: PPUSH
18314: LD_EXP 62
18318: PUSH
18319: LD_VAR 0 1
18323: ARRAY
18324: PUSH
18325: LD_INT 1
18327: ARRAY
18328: PPUSH
18329: LD_EXP 62
18333: PUSH
18334: LD_VAR 0 1
18338: ARRAY
18339: PUSH
18340: LD_INT 2
18342: ARRAY
18343: PPUSH
18344: CALL_OW 73
18348: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18349: LD_VAR 0 5
18353: NOT
18354: PUSH
18355: LD_VAR 0 5
18359: PUSH
18360: LD_EXP 69
18364: PUSH
18365: LD_VAR 0 1
18369: ARRAY
18370: NONEQUAL
18371: OR
18372: IFFALSE 18477
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18374: LD_INT 7
18376: PPUSH
18377: LD_EXP 70
18381: PUSH
18382: LD_VAR 0 1
18386: ARRAY
18387: PUSH
18388: LD_INT 3
18390: ARRAY
18391: PPUSH
18392: LD_INT 0
18394: PPUSH
18395: LD_EXP 69
18399: PUSH
18400: LD_VAR 0 1
18404: ARRAY
18405: PPUSH
18406: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18410: LD_INT 7
18412: PPUSH
18413: LD_EXP 70
18417: PUSH
18418: LD_VAR 0 1
18422: ARRAY
18423: PUSH
18424: LD_INT 1
18426: ARRAY
18427: PPUSH
18428: LD_INT 0
18430: PPUSH
18431: LD_EXP 69
18435: PUSH
18436: LD_VAR 0 1
18440: ARRAY
18441: PPUSH
18442: CALL_OW 468
// if nearestLab then
18446: LD_VAR 0 5
18450: IFFALSE 18477
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18452: LD_ADDR_EXP 69
18456: PUSH
18457: LD_EXP 69
18461: PPUSH
18462: LD_VAR 0 1
18466: PPUSH
18467: LD_VAR 0 5
18471: PPUSH
18472: CALL_OW 1
18476: ST_TO_ADDR
// end ; if not nearestLab then
18477: LD_VAR 0 5
18481: NOT
18482: IFFALSE 18486
// continue ;
18484: GO 18044
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18486: LD_VAR 0 5
18490: PPUSH
18491: LD_EXP 62
18495: PUSH
18496: LD_VAR 0 1
18500: ARRAY
18501: PUSH
18502: LD_INT 1
18504: ARRAY
18505: PPUSH
18506: LD_EXP 62
18510: PUSH
18511: LD_VAR 0 1
18515: ARRAY
18516: PUSH
18517: LD_INT 2
18519: ARRAY
18520: PPUSH
18521: CALL_OW 297
18525: PUSH
18526: LD_INT 8
18528: LESS
18529: IFFALSE 18726
// begin if not artifactsResearched [ i ] then
18531: LD_EXP 65
18535: PUSH
18536: LD_VAR 0 1
18540: ARRAY
18541: NOT
18542: IFFALSE 18623
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18544: LD_VAR 0 5
18548: PPUSH
18549: CALL_OW 461
18553: PUSH
18554: LD_INT 2
18556: EQUAL
18557: IFFALSE 18591
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18559: LD_INT 7
18561: PPUSH
18562: LD_EXP 70
18566: PUSH
18567: LD_VAR 0 1
18571: ARRAY
18572: PUSH
18573: LD_INT 3
18575: ARRAY
18576: PPUSH
18577: LD_INT 2
18579: PPUSH
18580: LD_VAR 0 5
18584: PPUSH
18585: CALL_OW 468
18589: GO 18621
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18591: LD_INT 7
18593: PPUSH
18594: LD_EXP 70
18598: PUSH
18599: LD_VAR 0 1
18603: ARRAY
18604: PUSH
18605: LD_INT 3
18607: ARRAY
18608: PPUSH
18609: LD_INT 1
18611: PPUSH
18612: LD_VAR 0 5
18616: PPUSH
18617: CALL_OW 468
// end else
18621: GO 18724
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18623: LD_VAR 0 5
18627: PPUSH
18628: CALL_OW 461
18632: PUSH
18633: LD_INT 2
18635: EQUAL
18636: PUSH
18637: LD_EXP 71
18641: PUSH
18642: LD_VAR 0 1
18646: ARRAY
18647: AND
18648: IFFALSE 18694
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18650: LD_INT 7
18652: PPUSH
18653: LD_EXP 70
18657: PUSH
18658: LD_VAR 0 1
18662: ARRAY
18663: PUSH
18664: LD_INT 1
18666: ARRAY
18667: PPUSH
18668: LD_EXP 70
18672: PUSH
18673: LD_VAR 0 1
18677: ARRAY
18678: PUSH
18679: LD_INT 2
18681: ARRAY
18682: PPUSH
18683: LD_VAR 0 5
18687: PPUSH
18688: CALL_OW 468
18692: GO 18724
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18694: LD_INT 7
18696: PPUSH
18697: LD_EXP 70
18701: PUSH
18702: LD_VAR 0 1
18706: ARRAY
18707: PUSH
18708: LD_INT 1
18710: ARRAY
18711: PPUSH
18712: LD_INT 1
18714: PPUSH
18715: LD_VAR 0 5
18719: PPUSH
18720: CALL_OW 468
// end else
18724: GO 18801
// begin if not artifactsResearched [ i ] then
18726: LD_EXP 65
18730: PUSH
18731: LD_VAR 0 1
18735: ARRAY
18736: NOT
18737: IFFALSE 18771
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18739: LD_INT 7
18741: PPUSH
18742: LD_EXP 70
18746: PUSH
18747: LD_VAR 0 1
18751: ARRAY
18752: PUSH
18753: LD_INT 3
18755: ARRAY
18756: PPUSH
18757: LD_INT 0
18759: PPUSH
18760: LD_VAR 0 5
18764: PPUSH
18765: CALL_OW 468
18769: GO 18801
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18771: LD_INT 7
18773: PPUSH
18774: LD_EXP 70
18778: PUSH
18779: LD_VAR 0 1
18783: ARRAY
18784: PUSH
18785: LD_INT 1
18787: ARRAY
18788: PPUSH
18789: LD_INT 0
18791: PPUSH
18792: LD_VAR 0 5
18796: PPUSH
18797: CALL_OW 468
// end ; end else
18801: GO 18940
// begin if not artifactsLabs [ i ] then
18803: LD_EXP 69
18807: PUSH
18808: LD_VAR 0 1
18812: ARRAY
18813: NOT
18814: IFFALSE 18818
// continue ;
18816: GO 18044
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18818: LD_INT 7
18820: PPUSH
18821: LD_EXP 70
18825: PUSH
18826: LD_VAR 0 1
18830: ARRAY
18831: PUSH
18832: LD_INT 3
18834: ARRAY
18835: PPUSH
18836: LD_INT 0
18838: PPUSH
18839: LD_EXP 69
18843: PUSH
18844: LD_VAR 0 1
18848: ARRAY
18849: PPUSH
18850: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18854: LD_INT 7
18856: PPUSH
18857: LD_EXP 70
18861: PUSH
18862: LD_VAR 0 1
18866: ARRAY
18867: PUSH
18868: LD_INT 1
18870: ARRAY
18871: PPUSH
18872: LD_INT 0
18874: PPUSH
18875: LD_EXP 69
18879: PUSH
18880: LD_VAR 0 1
18884: ARRAY
18885: PPUSH
18886: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18890: LD_EXP 66
18894: PUSH
18895: LD_VAR 0 1
18899: ARRAY
18900: IFFALSE 18940
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18902: LD_ADDR_EXP 66
18906: PUSH
18907: LD_EXP 66
18911: PPUSH
18912: LD_VAR 0 1
18916: PPUSH
18917: LD_INT 0
18919: PPUSH
18920: CALL_OW 1
18924: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18925: LD_EXP 69
18929: PUSH
18930: LD_VAR 0 1
18934: ARRAY
18935: PPUSH
18936: CALL_OW 127
// end ; end ; end ;
18940: GO 18044
18942: POP
18943: POP
// end ;
18944: PPOPN 5
18946: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18947: LD_INT 0
18949: PPUSH
18950: PPUSH
18951: PPUSH
18952: PPUSH
18953: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18954: LD_VAR 0 2
18958: PUSH
18959: LD_EXP 70
18963: PUSH
18964: LD_INT 1
18966: ARRAY
18967: PUSH
18968: LD_INT 3
18970: ARRAY
18971: EQUAL
18972: IFFALSE 19095
// begin lab := artifactsLabs [ 1 ] ;
18974: LD_ADDR_VAR 0 6
18978: PUSH
18979: LD_EXP 69
18983: PUSH
18984: LD_INT 1
18986: ARRAY
18987: ST_TO_ADDR
// if not lab then
18988: LD_VAR 0 6
18992: NOT
18993: IFFALSE 18997
// exit ;
18995: GO 20075
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18997: LD_VAR 0 6
19001: PPUSH
19002: LD_EXP 67
19006: PUSH
19007: LD_INT 1
19009: ARRAY
19010: PPUSH
19011: LD_INT 1
19013: PPUSH
19014: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19018: LD_EXP 68
19022: PUSH
19023: LD_INT 1
19025: ARRAY
19026: IFFALSE 19046
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19028: LD_VAR 0 6
19032: PPUSH
19033: LD_EXP 68
19037: PUSH
19038: LD_INT 1
19040: ARRAY
19041: PPUSH
19042: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19046: LD_ADDR_EXP 66
19050: PUSH
19051: LD_EXP 66
19055: PPUSH
19056: LD_INT 1
19058: PPUSH
19059: LD_INT 1
19061: PPUSH
19062: CALL_OW 1
19066: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19067: LD_INT 7
19069: PPUSH
19070: LD_EXP 70
19074: PUSH
19075: LD_INT 1
19077: ARRAY
19078: PUSH
19079: LD_INT 3
19081: ARRAY
19082: PPUSH
19083: LD_INT 0
19085: PPUSH
19086: LD_VAR 0 6
19090: PPUSH
19091: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19095: LD_VAR 0 2
19099: PUSH
19100: LD_EXP 70
19104: PUSH
19105: LD_INT 2
19107: ARRAY
19108: PUSH
19109: LD_INT 3
19111: ARRAY
19112: EQUAL
19113: IFFALSE 19236
// begin lab := artifactsLabs [ 2 ] ;
19115: LD_ADDR_VAR 0 6
19119: PUSH
19120: LD_EXP 69
19124: PUSH
19125: LD_INT 2
19127: ARRAY
19128: ST_TO_ADDR
// if not lab then
19129: LD_VAR 0 6
19133: NOT
19134: IFFALSE 19138
// exit ;
19136: GO 20075
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19138: LD_VAR 0 6
19142: PPUSH
19143: LD_EXP 67
19147: PUSH
19148: LD_INT 2
19150: ARRAY
19151: PPUSH
19152: LD_INT 1
19154: PPUSH
19155: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19159: LD_EXP 68
19163: PUSH
19164: LD_INT 2
19166: ARRAY
19167: IFFALSE 19187
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19169: LD_VAR 0 6
19173: PPUSH
19174: LD_EXP 68
19178: PUSH
19179: LD_INT 2
19181: ARRAY
19182: PPUSH
19183: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19187: LD_ADDR_EXP 66
19191: PUSH
19192: LD_EXP 66
19196: PPUSH
19197: LD_INT 2
19199: PPUSH
19200: LD_INT 1
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19208: LD_INT 7
19210: PPUSH
19211: LD_EXP 70
19215: PUSH
19216: LD_INT 2
19218: ARRAY
19219: PUSH
19220: LD_INT 3
19222: ARRAY
19223: PPUSH
19224: LD_INT 0
19226: PPUSH
19227: LD_VAR 0 6
19231: PPUSH
19232: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19236: LD_VAR 0 2
19240: PUSH
19241: LD_EXP 70
19245: PUSH
19246: LD_INT 3
19248: ARRAY
19249: PUSH
19250: LD_INT 3
19252: ARRAY
19253: EQUAL
19254: IFFALSE 19377
// begin lab := artifactsLabs [ 3 ] ;
19256: LD_ADDR_VAR 0 6
19260: PUSH
19261: LD_EXP 69
19265: PUSH
19266: LD_INT 3
19268: ARRAY
19269: ST_TO_ADDR
// if not lab then
19270: LD_VAR 0 6
19274: NOT
19275: IFFALSE 19279
// exit ;
19277: GO 20075
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19279: LD_VAR 0 6
19283: PPUSH
19284: LD_EXP 67
19288: PUSH
19289: LD_INT 3
19291: ARRAY
19292: PPUSH
19293: LD_INT 1
19295: PPUSH
19296: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19300: LD_EXP 68
19304: PUSH
19305: LD_INT 3
19307: ARRAY
19308: IFFALSE 19328
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19310: LD_VAR 0 6
19314: PPUSH
19315: LD_EXP 68
19319: PUSH
19320: LD_INT 3
19322: ARRAY
19323: PPUSH
19324: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19328: LD_ADDR_EXP 66
19332: PUSH
19333: LD_EXP 66
19337: PPUSH
19338: LD_INT 3
19340: PPUSH
19341: LD_INT 1
19343: PPUSH
19344: CALL_OW 1
19348: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19349: LD_INT 7
19351: PPUSH
19352: LD_EXP 70
19356: PUSH
19357: LD_INT 3
19359: ARRAY
19360: PUSH
19361: LD_INT 3
19363: ARRAY
19364: PPUSH
19365: LD_INT 0
19367: PPUSH
19368: LD_VAR 0 6
19372: PPUSH
19373: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19377: LD_VAR 0 2
19381: PUSH
19382: LD_EXP 70
19386: PUSH
19387: LD_INT 1
19389: ARRAY
19390: PUSH
19391: LD_INT 1
19393: ARRAY
19394: EQUAL
19395: IFFALSE 19553
// begin lab := artifactsLabs [ 1 ] ;
19397: LD_ADDR_VAR 0 6
19401: PUSH
19402: LD_EXP 69
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19411: LD_VAR 0 6
19415: PPUSH
19416: CALL_OW 274
19420: PPUSH
19421: CALL 86688 0 1
19425: PUSH
19426: LD_INT 3
19428: ARRAY
19429: PUSH
19430: LD_EXP 64
19434: PUSH
19435: LD_INT 1
19437: ARRAY
19438: LESS
19439: IFFALSE 19453
// begin HintSpec ( ArtifactCost , 2 ) ;
19441: LD_STRING ArtifactCost
19443: PPUSH
19444: LD_INT 2
19446: PPUSH
19447: CALL_OW 338
// exit ;
19451: GO 20075
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19453: LD_ADDR_EXP 71
19457: PUSH
19458: LD_EXP 71
19462: PPUSH
19463: LD_INT 1
19465: PPUSH
19466: LD_INT 0
19468: PPUSH
19469: CALL_OW 1
19473: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19474: LD_VAR 0 3
19478: PPUSH
19479: LD_VAR 0 4
19483: PPUSH
19484: LD_INT 7
19486: PPUSH
19487: LD_INT 12
19489: NEG
19490: PPUSH
19491: CALL_OW 330
// wait ( 0 0$30 ) ;
19495: LD_INT 1050
19497: PPUSH
19498: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19502: LD_VAR 0 3
19506: PPUSH
19507: LD_VAR 0 4
19511: PPUSH
19512: LD_INT 7
19514: PPUSH
19515: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19519: LD_EXP 63
19523: PUSH
19524: LD_INT 1
19526: ARRAY
19527: PPUSH
19528: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19532: LD_ADDR_EXP 71
19536: PUSH
19537: LD_EXP 71
19541: PPUSH
19542: LD_INT 1
19544: PPUSH
19545: LD_INT 1
19547: PPUSH
19548: CALL_OW 1
19552: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19553: LD_VAR 0 2
19557: PUSH
19558: LD_EXP 70
19562: PUSH
19563: LD_INT 2
19565: ARRAY
19566: PUSH
19567: LD_INT 1
19569: ARRAY
19570: EQUAL
19571: IFFALSE 19808
// begin lab := artifactsLabs [ 2 ] ;
19573: LD_ADDR_VAR 0 6
19577: PUSH
19578: LD_EXP 69
19582: PUSH
19583: LD_INT 2
19585: ARRAY
19586: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19587: LD_VAR 0 3
19591: PUSH
19592: LD_INT 81
19594: PUSH
19595: LD_INT 7
19597: PUSH
19598: EMPTY
19599: LIST
19600: LIST
19601: PUSH
19602: LD_INT 2
19604: PUSH
19605: LD_INT 32
19607: PUSH
19608: LD_INT 3
19610: PUSH
19611: EMPTY
19612: LIST
19613: LIST
19614: PUSH
19615: LD_INT 30
19617: PUSH
19618: LD_INT 28
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: PUSH
19625: LD_INT 30
19627: PUSH
19628: LD_INT 30
19630: PUSH
19631: EMPTY
19632: LIST
19633: LIST
19634: PUSH
19635: LD_INT 35
19637: PUSH
19638: LD_INT 49
19640: PUSH
19641: EMPTY
19642: LIST
19643: LIST
19644: PUSH
19645: LD_INT 34
19647: PUSH
19648: LD_INT 49
19650: PUSH
19651: EMPTY
19652: LIST
19653: LIST
19654: PUSH
19655: LD_INT 30
19657: PUSH
19658: LD_INT 21
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: PUSH
19665: EMPTY
19666: LIST
19667: LIST
19668: LIST
19669: LIST
19670: LIST
19671: LIST
19672: LIST
19673: PUSH
19674: EMPTY
19675: LIST
19676: LIST
19677: PPUSH
19678: CALL_OW 69
19682: IN
19683: NOT
19684: IFFALSE 19688
// exit ;
19686: GO 20075
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19688: LD_VAR 0 6
19692: PPUSH
19693: CALL_OW 274
19697: PPUSH
19698: CALL 86688 0 1
19702: PUSH
19703: LD_INT 3
19705: ARRAY
19706: PUSH
19707: LD_EXP 64
19711: PUSH
19712: LD_INT 2
19714: ARRAY
19715: LESS
19716: IFFALSE 19730
// begin HintSpec ( ArtifactCost , 2 ) ;
19718: LD_STRING ArtifactCost
19720: PPUSH
19721: LD_INT 2
19723: PPUSH
19724: CALL_OW 338
// exit ;
19728: GO 20075
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19730: LD_ADDR_EXP 71
19734: PUSH
19735: LD_EXP 71
19739: PPUSH
19740: LD_INT 2
19742: PPUSH
19743: LD_INT 0
19745: PPUSH
19746: CALL_OW 1
19750: ST_TO_ADDR
// KillUnit ( x ) ;
19751: LD_VAR 0 3
19755: PPUSH
19756: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19760: LD_ADDR_EXP 16
19764: PUSH
19765: LD_EXP 16
19769: PUSH
19770: LD_INT 1
19772: PLUS
19773: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19774: LD_EXP 63
19778: PUSH
19779: LD_INT 2
19781: ARRAY
19782: PPUSH
19783: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19787: LD_ADDR_EXP 71
19791: PUSH
19792: LD_EXP 71
19796: PPUSH
19797: LD_INT 2
19799: PPUSH
19800: LD_INT 1
19802: PPUSH
19803: CALL_OW 1
19807: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19808: LD_VAR 0 2
19812: PUSH
19813: LD_EXP 70
19817: PUSH
19818: LD_INT 3
19820: ARRAY
19821: PUSH
19822: LD_INT 1
19824: ARRAY
19825: EQUAL
19826: IFFALSE 20075
// begin lab := artifactsLabs [ 3 ] ;
19828: LD_ADDR_VAR 0 6
19832: PUSH
19833: LD_EXP 69
19837: PUSH
19838: LD_INT 3
19840: ARRAY
19841: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19842: LD_VAR 0 6
19846: PPUSH
19847: CALL_OW 274
19851: PPUSH
19852: CALL 86688 0 1
19856: PUSH
19857: LD_INT 3
19859: ARRAY
19860: PUSH
19861: LD_EXP 64
19865: PUSH
19866: LD_INT 3
19868: ARRAY
19869: LESS
19870: IFFALSE 19884
// begin HintSpec ( ArtifactCost , 2 ) ;
19872: LD_STRING ArtifactCost
19874: PPUSH
19875: LD_INT 2
19877: PPUSH
19878: CALL_OW 338
// exit ;
19882: GO 20075
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19884: LD_INT 37
19886: PPUSH
19887: LD_INT 1
19889: PPUSH
19890: CALL_OW 424
// time := 0 0$30 ;
19894: LD_ADDR_VAR 0 7
19898: PUSH
19899: LD_INT 1050
19901: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
19902: LD_ADDR_EXP 71
19906: PUSH
19907: LD_EXP 71
19911: PPUSH
19912: LD_INT 3
19914: PPUSH
19915: LD_INT 0
19917: PPUSH
19918: CALL_OW 1
19922: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
19923: LD_ADDR_OWVAR 47
19927: PUSH
19928: LD_STRING #Am15a-1
19930: PUSH
19931: LD_VAR 0 7
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19940: LD_INT 35
19942: PPUSH
19943: CALL_OW 67
// time := time - 0 0$1 ;
19947: LD_ADDR_VAR 0 7
19951: PUSH
19952: LD_VAR 0 7
19956: PUSH
19957: LD_INT 35
19959: MINUS
19960: ST_TO_ADDR
// until time = 0 0$00 ;
19961: LD_VAR 0 7
19965: PUSH
19966: LD_INT 0
19968: EQUAL
19969: IFFALSE 19923
// display_strings :=  ;
19971: LD_ADDR_OWVAR 47
19975: PUSH
19976: LD_STRING 
19978: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19979: LD_INT 37
19981: PPUSH
19982: LD_INT 0
19984: PPUSH
19985: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19989: LD_ADDR_VAR 0 8
19993: PUSH
19994: LD_INT 37
19996: PPUSH
19997: LD_INT 3
19999: PUSH
20000: LD_INT 21
20002: PUSH
20003: LD_INT 3
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PUSH
20010: EMPTY
20011: LIST
20012: LIST
20013: PPUSH
20014: CALL_OW 70
20018: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20019: LD_VAR 0 3
20023: PPUSH
20024: LD_VAR 0 4
20028: PPUSH
20029: CALL_OW 84
// for un in list do
20033: LD_ADDR_VAR 0 9
20037: PUSH
20038: LD_VAR 0 8
20042: PUSH
20043: FOR_IN
20044: IFFALSE 20073
// TeleportUnit ( un , x , y , 12 , true ) ;
20046: LD_VAR 0 9
20050: PPUSH
20051: LD_VAR 0 3
20055: PPUSH
20056: LD_VAR 0 4
20060: PPUSH
20061: LD_INT 12
20063: PPUSH
20064: LD_INT 1
20066: PPUSH
20067: CALL_OW 483
20071: GO 20043
20073: POP
20074: POP
// end ; end ;
20075: PPOPN 9
20077: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20078: LD_INT 0
20080: PPUSH
20081: PPUSH
// begin labNum := 0 ;
20082: LD_ADDR_VAR 0 4
20086: PUSH
20087: LD_INT 0
20089: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20090: LD_ADDR_VAR 0 3
20094: PUSH
20095: DOUBLE
20096: LD_INT 1
20098: DEC
20099: ST_TO_ADDR
20100: LD_EXP 69
20104: PUSH
20105: FOR_TO
20106: IFFALSE 20140
// if artifactsLabs [ i ] = lab then
20108: LD_EXP 69
20112: PUSH
20113: LD_VAR 0 3
20117: ARRAY
20118: PUSH
20119: LD_VAR 0 1
20123: EQUAL
20124: IFFALSE 20138
// begin labNum := i ;
20126: LD_ADDR_VAR 0 4
20130: PUSH
20131: LD_VAR 0 3
20135: ST_TO_ADDR
// break ;
20136: GO 20140
// end ;
20138: GO 20105
20140: POP
20141: POP
// if not labNum then
20142: LD_VAR 0 4
20146: NOT
20147: IFFALSE 20151
// exit ;
20149: GO 20229
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20151: LD_INT 7
20153: PPUSH
20154: LD_EXP 70
20158: PUSH
20159: LD_VAR 0 4
20163: ARRAY
20164: PUSH
20165: LD_INT 3
20167: ARRAY
20168: PPUSH
20169: LD_INT 2
20171: PPUSH
20172: LD_VAR 0 1
20176: PPUSH
20177: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20181: LD_ADDR_EXP 68
20185: PUSH
20186: LD_EXP 68
20190: PPUSH
20191: LD_VAR 0 4
20195: PPUSH
20196: LD_VAR 0 2
20200: PPUSH
20201: CALL_OW 1
20205: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20206: LD_ADDR_EXP 66
20210: PUSH
20211: LD_EXP 66
20215: PPUSH
20216: LD_VAR 0 4
20220: PPUSH
20221: LD_INT 0
20223: PPUSH
20224: CALL_OW 1
20228: ST_TO_ADDR
// end ;
20229: PPOPN 4
20231: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20232: LD_INT 0
20234: PPUSH
20235: PPUSH
// begin labNum := 0 ;
20236: LD_ADDR_VAR 0 3
20240: PUSH
20241: LD_INT 0
20243: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20244: LD_ADDR_VAR 0 2
20248: PUSH
20249: DOUBLE
20250: LD_INT 1
20252: DEC
20253: ST_TO_ADDR
20254: LD_EXP 69
20258: PUSH
20259: FOR_TO
20260: IFFALSE 20294
// if artifactsLabs [ i ] = lab then
20262: LD_EXP 69
20266: PUSH
20267: LD_VAR 0 2
20271: ARRAY
20272: PUSH
20273: LD_VAR 0 1
20277: EQUAL
20278: IFFALSE 20292
// begin labNum := i ;
20280: LD_ADDR_VAR 0 3
20284: PUSH
20285: LD_VAR 0 2
20289: ST_TO_ADDR
// break ;
20290: GO 20294
// end ;
20292: GO 20259
20294: POP
20295: POP
// if not labNum then
20296: LD_VAR 0 3
20300: NOT
20301: IFFALSE 20305
// exit ;
20303: GO 20467
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20305: LD_INT 7
20307: PPUSH
20308: LD_EXP 70
20312: PUSH
20313: LD_VAR 0 3
20317: ARRAY
20318: PUSH
20319: LD_INT 3
20321: ARRAY
20322: PPUSH
20323: LD_INT 0
20325: PPUSH
20326: LD_VAR 0 1
20330: PPUSH
20331: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20335: LD_ADDR_EXP 65
20339: PUSH
20340: LD_EXP 65
20344: PPUSH
20345: LD_VAR 0 3
20349: PPUSH
20350: LD_INT 1
20352: PPUSH
20353: CALL_OW 1
20357: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20358: LD_ADDR_EXP 71
20362: PUSH
20363: LD_EXP 71
20367: PPUSH
20368: LD_VAR 0 3
20372: PPUSH
20373: LD_INT 1
20375: PPUSH
20376: CALL_OW 1
20380: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20381: LD_ADDR_EXP 66
20385: PUSH
20386: LD_EXP 66
20390: PPUSH
20391: LD_VAR 0 3
20395: PPUSH
20396: LD_INT 0
20398: PPUSH
20399: CALL_OW 1
20403: ST_TO_ADDR
// case labNum of 1 :
20404: LD_VAR 0 3
20408: PUSH
20409: LD_INT 1
20411: DOUBLE
20412: EQUAL
20413: IFTRUE 20417
20415: GO 20428
20417: POP
// artifactIResearched := true ; 2 :
20418: LD_ADDR_EXP 12
20422: PUSH
20423: LD_INT 1
20425: ST_TO_ADDR
20426: GO 20467
20428: LD_INT 2
20430: DOUBLE
20431: EQUAL
20432: IFTRUE 20436
20434: GO 20447
20436: POP
// artifactIIResearched := true ; 3 :
20437: LD_ADDR_EXP 13
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
20445: GO 20467
20447: LD_INT 3
20449: DOUBLE
20450: EQUAL
20451: IFTRUE 20455
20453: GO 20466
20455: POP
// artifactIIIResearched := true ; end ;
20456: LD_ADDR_EXP 14
20460: PUSH
20461: LD_INT 1
20463: ST_TO_ADDR
20464: GO 20467
20466: POP
// end ; end_of_file
20467: PPOPN 3
20469: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
20470: GO 20472
20472: DISABLE
// begin ru_radar := 98 ;
20473: LD_ADDR_EXP 72
20477: PUSH
20478: LD_INT 98
20480: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20481: LD_ADDR_EXP 73
20485: PUSH
20486: LD_INT 89
20488: ST_TO_ADDR
// us_hack := 99 ;
20489: LD_ADDR_EXP 74
20493: PUSH
20494: LD_INT 99
20496: ST_TO_ADDR
// us_artillery := 97 ;
20497: LD_ADDR_EXP 75
20501: PUSH
20502: LD_INT 97
20504: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20505: LD_ADDR_EXP 76
20509: PUSH
20510: LD_INT 91
20512: ST_TO_ADDR
// tech_Artillery := 80 ;
20513: LD_ADDR_EXP 77
20517: PUSH
20518: LD_INT 80
20520: ST_TO_ADDR
// tech_RadMat := 81 ;
20521: LD_ADDR_EXP 78
20525: PUSH
20526: LD_INT 81
20528: ST_TO_ADDR
// tech_BasicTools := 82 ;
20529: LD_ADDR_EXP 79
20533: PUSH
20534: LD_INT 82
20536: ST_TO_ADDR
// tech_Cargo := 83 ;
20537: LD_ADDR_EXP 80
20541: PUSH
20542: LD_INT 83
20544: ST_TO_ADDR
// tech_Track := 84 ;
20545: LD_ADDR_EXP 81
20549: PUSH
20550: LD_INT 84
20552: ST_TO_ADDR
// tech_Crane := 85 ;
20553: LD_ADDR_EXP 82
20557: PUSH
20558: LD_INT 85
20560: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20561: LD_ADDR_EXP 83
20565: PUSH
20566: LD_INT 86
20568: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20569: LD_ADDR_EXP 84
20573: PUSH
20574: LD_INT 87
20576: ST_TO_ADDR
// end ; end_of_file
20577: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20578: LD_INT 0
20580: PPUSH
20581: PPUSH
// skirmish := false ;
20582: LD_ADDR_EXP 85
20586: PUSH
20587: LD_INT 0
20589: ST_TO_ADDR
// debug_mc := false ;
20590: LD_ADDR_EXP 86
20594: PUSH
20595: LD_INT 0
20597: ST_TO_ADDR
// mc_bases := [ ] ;
20598: LD_ADDR_EXP 87
20602: PUSH
20603: EMPTY
20604: ST_TO_ADDR
// mc_sides := [ ] ;
20605: LD_ADDR_EXP 113
20609: PUSH
20610: EMPTY
20611: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20612: LD_ADDR_EXP 88
20616: PUSH
20617: EMPTY
20618: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20619: LD_ADDR_EXP 89
20623: PUSH
20624: EMPTY
20625: ST_TO_ADDR
// mc_need_heal := [ ] ;
20626: LD_ADDR_EXP 90
20630: PUSH
20631: EMPTY
20632: ST_TO_ADDR
// mc_healers := [ ] ;
20633: LD_ADDR_EXP 91
20637: PUSH
20638: EMPTY
20639: ST_TO_ADDR
// mc_build_list := [ ] ;
20640: LD_ADDR_EXP 92
20644: PUSH
20645: EMPTY
20646: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20647: LD_ADDR_EXP 119
20651: PUSH
20652: EMPTY
20653: ST_TO_ADDR
// mc_builders := [ ] ;
20654: LD_ADDR_EXP 93
20658: PUSH
20659: EMPTY
20660: ST_TO_ADDR
// mc_construct_list := [ ] ;
20661: LD_ADDR_EXP 94
20665: PUSH
20666: EMPTY
20667: ST_TO_ADDR
// mc_turret_list := [ ] ;
20668: LD_ADDR_EXP 95
20672: PUSH
20673: EMPTY
20674: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20675: LD_ADDR_EXP 96
20679: PUSH
20680: EMPTY
20681: ST_TO_ADDR
// mc_miners := [ ] ;
20682: LD_ADDR_EXP 101
20686: PUSH
20687: EMPTY
20688: ST_TO_ADDR
// mc_mines := [ ] ;
20689: LD_ADDR_EXP 100
20693: PUSH
20694: EMPTY
20695: ST_TO_ADDR
// mc_minefields := [ ] ;
20696: LD_ADDR_EXP 102
20700: PUSH
20701: EMPTY
20702: ST_TO_ADDR
// mc_crates := [ ] ;
20703: LD_ADDR_EXP 103
20707: PUSH
20708: EMPTY
20709: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20710: LD_ADDR_EXP 104
20714: PUSH
20715: EMPTY
20716: ST_TO_ADDR
// mc_crates_area := [ ] ;
20717: LD_ADDR_EXP 105
20721: PUSH
20722: EMPTY
20723: ST_TO_ADDR
// mc_vehicles := [ ] ;
20724: LD_ADDR_EXP 106
20728: PUSH
20729: EMPTY
20730: ST_TO_ADDR
// mc_attack := [ ] ;
20731: LD_ADDR_EXP 107
20735: PUSH
20736: EMPTY
20737: ST_TO_ADDR
// mc_produce := [ ] ;
20738: LD_ADDR_EXP 108
20742: PUSH
20743: EMPTY
20744: ST_TO_ADDR
// mc_defender := [ ] ;
20745: LD_ADDR_EXP 109
20749: PUSH
20750: EMPTY
20751: ST_TO_ADDR
// mc_parking := [ ] ;
20752: LD_ADDR_EXP 111
20756: PUSH
20757: EMPTY
20758: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20759: LD_ADDR_EXP 97
20763: PUSH
20764: EMPTY
20765: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20766: LD_ADDR_EXP 99
20770: PUSH
20771: EMPTY
20772: ST_TO_ADDR
// mc_scan := [ ] ;
20773: LD_ADDR_EXP 110
20777: PUSH
20778: EMPTY
20779: ST_TO_ADDR
// mc_scan_area := [ ] ;
20780: LD_ADDR_EXP 112
20784: PUSH
20785: EMPTY
20786: ST_TO_ADDR
// mc_tech := [ ] ;
20787: LD_ADDR_EXP 114
20791: PUSH
20792: EMPTY
20793: ST_TO_ADDR
// mc_class := [ ] ;
20794: LD_ADDR_EXP 128
20798: PUSH
20799: EMPTY
20800: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20801: LD_ADDR_EXP 129
20805: PUSH
20806: EMPTY
20807: ST_TO_ADDR
// end ;
20808: LD_VAR 0 1
20812: RET
// export function MC_Kill ( base ) ; begin
20813: LD_INT 0
20815: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20816: LD_ADDR_EXP 87
20820: PUSH
20821: LD_EXP 87
20825: PPUSH
20826: LD_VAR 0 1
20830: PPUSH
20831: EMPTY
20832: PPUSH
20833: CALL_OW 1
20837: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20838: LD_ADDR_EXP 88
20842: PUSH
20843: LD_EXP 88
20847: PPUSH
20848: LD_VAR 0 1
20852: PPUSH
20853: EMPTY
20854: PPUSH
20855: CALL_OW 1
20859: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20860: LD_ADDR_EXP 89
20864: PUSH
20865: LD_EXP 89
20869: PPUSH
20870: LD_VAR 0 1
20874: PPUSH
20875: EMPTY
20876: PPUSH
20877: CALL_OW 1
20881: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20882: LD_ADDR_EXP 90
20886: PUSH
20887: LD_EXP 90
20891: PPUSH
20892: LD_VAR 0 1
20896: PPUSH
20897: EMPTY
20898: PPUSH
20899: CALL_OW 1
20903: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20904: LD_ADDR_EXP 91
20908: PUSH
20909: LD_EXP 91
20913: PPUSH
20914: LD_VAR 0 1
20918: PPUSH
20919: EMPTY
20920: PPUSH
20921: CALL_OW 1
20925: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20926: LD_ADDR_EXP 92
20930: PUSH
20931: LD_EXP 92
20935: PPUSH
20936: LD_VAR 0 1
20940: PPUSH
20941: EMPTY
20942: PPUSH
20943: CALL_OW 1
20947: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20948: LD_ADDR_EXP 93
20952: PUSH
20953: LD_EXP 93
20957: PPUSH
20958: LD_VAR 0 1
20962: PPUSH
20963: EMPTY
20964: PPUSH
20965: CALL_OW 1
20969: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20970: LD_ADDR_EXP 94
20974: PUSH
20975: LD_EXP 94
20979: PPUSH
20980: LD_VAR 0 1
20984: PPUSH
20985: EMPTY
20986: PPUSH
20987: CALL_OW 1
20991: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20992: LD_ADDR_EXP 95
20996: PUSH
20997: LD_EXP 95
21001: PPUSH
21002: LD_VAR 0 1
21006: PPUSH
21007: EMPTY
21008: PPUSH
21009: CALL_OW 1
21013: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21014: LD_ADDR_EXP 96
21018: PUSH
21019: LD_EXP 96
21023: PPUSH
21024: LD_VAR 0 1
21028: PPUSH
21029: EMPTY
21030: PPUSH
21031: CALL_OW 1
21035: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21036: LD_ADDR_EXP 97
21040: PUSH
21041: LD_EXP 97
21045: PPUSH
21046: LD_VAR 0 1
21050: PPUSH
21051: EMPTY
21052: PPUSH
21053: CALL_OW 1
21057: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21058: LD_ADDR_EXP 98
21062: PUSH
21063: LD_EXP 98
21067: PPUSH
21068: LD_VAR 0 1
21072: PPUSH
21073: LD_INT 0
21075: PPUSH
21076: CALL_OW 1
21080: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21081: LD_ADDR_EXP 99
21085: PUSH
21086: LD_EXP 99
21090: PPUSH
21091: LD_VAR 0 1
21095: PPUSH
21096: EMPTY
21097: PPUSH
21098: CALL_OW 1
21102: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21103: LD_ADDR_EXP 100
21107: PUSH
21108: LD_EXP 100
21112: PPUSH
21113: LD_VAR 0 1
21117: PPUSH
21118: EMPTY
21119: PPUSH
21120: CALL_OW 1
21124: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21125: LD_ADDR_EXP 101
21129: PUSH
21130: LD_EXP 101
21134: PPUSH
21135: LD_VAR 0 1
21139: PPUSH
21140: EMPTY
21141: PPUSH
21142: CALL_OW 1
21146: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21147: LD_ADDR_EXP 102
21151: PUSH
21152: LD_EXP 102
21156: PPUSH
21157: LD_VAR 0 1
21161: PPUSH
21162: EMPTY
21163: PPUSH
21164: CALL_OW 1
21168: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21169: LD_ADDR_EXP 103
21173: PUSH
21174: LD_EXP 103
21178: PPUSH
21179: LD_VAR 0 1
21183: PPUSH
21184: EMPTY
21185: PPUSH
21186: CALL_OW 1
21190: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21191: LD_ADDR_EXP 104
21195: PUSH
21196: LD_EXP 104
21200: PPUSH
21201: LD_VAR 0 1
21205: PPUSH
21206: EMPTY
21207: PPUSH
21208: CALL_OW 1
21212: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21213: LD_ADDR_EXP 105
21217: PUSH
21218: LD_EXP 105
21222: PPUSH
21223: LD_VAR 0 1
21227: PPUSH
21228: EMPTY
21229: PPUSH
21230: CALL_OW 1
21234: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21235: LD_ADDR_EXP 106
21239: PUSH
21240: LD_EXP 106
21244: PPUSH
21245: LD_VAR 0 1
21249: PPUSH
21250: EMPTY
21251: PPUSH
21252: CALL_OW 1
21256: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21257: LD_ADDR_EXP 107
21261: PUSH
21262: LD_EXP 107
21266: PPUSH
21267: LD_VAR 0 1
21271: PPUSH
21272: EMPTY
21273: PPUSH
21274: CALL_OW 1
21278: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21279: LD_ADDR_EXP 108
21283: PUSH
21284: LD_EXP 108
21288: PPUSH
21289: LD_VAR 0 1
21293: PPUSH
21294: EMPTY
21295: PPUSH
21296: CALL_OW 1
21300: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21301: LD_ADDR_EXP 109
21305: PUSH
21306: LD_EXP 109
21310: PPUSH
21311: LD_VAR 0 1
21315: PPUSH
21316: EMPTY
21317: PPUSH
21318: CALL_OW 1
21322: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21323: LD_ADDR_EXP 110
21327: PUSH
21328: LD_EXP 110
21332: PPUSH
21333: LD_VAR 0 1
21337: PPUSH
21338: EMPTY
21339: PPUSH
21340: CALL_OW 1
21344: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21345: LD_ADDR_EXP 111
21349: PUSH
21350: LD_EXP 111
21354: PPUSH
21355: LD_VAR 0 1
21359: PPUSH
21360: EMPTY
21361: PPUSH
21362: CALL_OW 1
21366: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21367: LD_ADDR_EXP 112
21371: PUSH
21372: LD_EXP 112
21376: PPUSH
21377: LD_VAR 0 1
21381: PPUSH
21382: EMPTY
21383: PPUSH
21384: CALL_OW 1
21388: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21389: LD_ADDR_EXP 114
21393: PUSH
21394: LD_EXP 114
21398: PPUSH
21399: LD_VAR 0 1
21403: PPUSH
21404: EMPTY
21405: PPUSH
21406: CALL_OW 1
21410: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21411: LD_ADDR_EXP 116
21415: PUSH
21416: LD_EXP 116
21420: PPUSH
21421: LD_VAR 0 1
21425: PPUSH
21426: EMPTY
21427: PPUSH
21428: CALL_OW 1
21432: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21433: LD_ADDR_EXP 117
21437: PUSH
21438: LD_EXP 117
21442: PPUSH
21443: LD_VAR 0 1
21447: PPUSH
21448: EMPTY
21449: PPUSH
21450: CALL_OW 1
21454: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21455: LD_ADDR_EXP 118
21459: PUSH
21460: LD_EXP 118
21464: PPUSH
21465: LD_VAR 0 1
21469: PPUSH
21470: EMPTY
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21477: LD_ADDR_EXP 119
21481: PUSH
21482: LD_EXP 119
21486: PPUSH
21487: LD_VAR 0 1
21491: PPUSH
21492: EMPTY
21493: PPUSH
21494: CALL_OW 1
21498: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21499: LD_ADDR_EXP 120
21503: PUSH
21504: LD_EXP 120
21508: PPUSH
21509: LD_VAR 0 1
21513: PPUSH
21514: EMPTY
21515: PPUSH
21516: CALL_OW 1
21520: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21521: LD_ADDR_EXP 121
21525: PUSH
21526: LD_EXP 121
21530: PPUSH
21531: LD_VAR 0 1
21535: PPUSH
21536: EMPTY
21537: PPUSH
21538: CALL_OW 1
21542: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21543: LD_ADDR_EXP 122
21547: PUSH
21548: LD_EXP 122
21552: PPUSH
21553: LD_VAR 0 1
21557: PPUSH
21558: EMPTY
21559: PPUSH
21560: CALL_OW 1
21564: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21565: LD_ADDR_EXP 123
21569: PUSH
21570: LD_EXP 123
21574: PPUSH
21575: LD_VAR 0 1
21579: PPUSH
21580: EMPTY
21581: PPUSH
21582: CALL_OW 1
21586: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21587: LD_ADDR_EXP 124
21591: PUSH
21592: LD_EXP 124
21596: PPUSH
21597: LD_VAR 0 1
21601: PPUSH
21602: EMPTY
21603: PPUSH
21604: CALL_OW 1
21608: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21609: LD_ADDR_EXP 125
21613: PUSH
21614: LD_EXP 125
21618: PPUSH
21619: LD_VAR 0 1
21623: PPUSH
21624: EMPTY
21625: PPUSH
21626: CALL_OW 1
21630: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21631: LD_ADDR_EXP 126
21635: PUSH
21636: LD_EXP 126
21640: PPUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: EMPTY
21647: PPUSH
21648: CALL_OW 1
21652: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21653: LD_ADDR_EXP 127
21657: PUSH
21658: LD_EXP 127
21662: PPUSH
21663: LD_VAR 0 1
21667: PPUSH
21668: EMPTY
21669: PPUSH
21670: CALL_OW 1
21674: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21675: LD_ADDR_EXP 128
21679: PUSH
21680: LD_EXP 128
21684: PPUSH
21685: LD_VAR 0 1
21689: PPUSH
21690: EMPTY
21691: PPUSH
21692: CALL_OW 1
21696: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21697: LD_ADDR_EXP 129
21701: PUSH
21702: LD_EXP 129
21706: PPUSH
21707: LD_VAR 0 1
21711: PPUSH
21712: LD_INT 0
21714: PPUSH
21715: CALL_OW 1
21719: ST_TO_ADDR
// end ;
21720: LD_VAR 0 2
21724: RET
// export function MC_Add ( side , units ) ; var base ; begin
21725: LD_INT 0
21727: PPUSH
21728: PPUSH
// base := mc_bases + 1 ;
21729: LD_ADDR_VAR 0 4
21733: PUSH
21734: LD_EXP 87
21738: PUSH
21739: LD_INT 1
21741: PLUS
21742: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21743: LD_ADDR_EXP 113
21747: PUSH
21748: LD_EXP 113
21752: PPUSH
21753: LD_VAR 0 4
21757: PPUSH
21758: LD_VAR 0 1
21762: PPUSH
21763: CALL_OW 1
21767: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21768: LD_ADDR_EXP 87
21772: PUSH
21773: LD_EXP 87
21777: PPUSH
21778: LD_VAR 0 4
21782: PPUSH
21783: LD_VAR 0 2
21787: PPUSH
21788: CALL_OW 1
21792: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21793: LD_ADDR_EXP 88
21797: PUSH
21798: LD_EXP 88
21802: PPUSH
21803: LD_VAR 0 4
21807: PPUSH
21808: EMPTY
21809: PPUSH
21810: CALL_OW 1
21814: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21815: LD_ADDR_EXP 89
21819: PUSH
21820: LD_EXP 89
21824: PPUSH
21825: LD_VAR 0 4
21829: PPUSH
21830: EMPTY
21831: PPUSH
21832: CALL_OW 1
21836: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21837: LD_ADDR_EXP 90
21841: PUSH
21842: LD_EXP 90
21846: PPUSH
21847: LD_VAR 0 4
21851: PPUSH
21852: EMPTY
21853: PPUSH
21854: CALL_OW 1
21858: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21859: LD_ADDR_EXP 91
21863: PUSH
21864: LD_EXP 91
21868: PPUSH
21869: LD_VAR 0 4
21873: PPUSH
21874: EMPTY
21875: PPUSH
21876: CALL_OW 1
21880: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21881: LD_ADDR_EXP 92
21885: PUSH
21886: LD_EXP 92
21890: PPUSH
21891: LD_VAR 0 4
21895: PPUSH
21896: EMPTY
21897: PPUSH
21898: CALL_OW 1
21902: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21903: LD_ADDR_EXP 93
21907: PUSH
21908: LD_EXP 93
21912: PPUSH
21913: LD_VAR 0 4
21917: PPUSH
21918: EMPTY
21919: PPUSH
21920: CALL_OW 1
21924: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21925: LD_ADDR_EXP 94
21929: PUSH
21930: LD_EXP 94
21934: PPUSH
21935: LD_VAR 0 4
21939: PPUSH
21940: EMPTY
21941: PPUSH
21942: CALL_OW 1
21946: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21947: LD_ADDR_EXP 95
21951: PUSH
21952: LD_EXP 95
21956: PPUSH
21957: LD_VAR 0 4
21961: PPUSH
21962: EMPTY
21963: PPUSH
21964: CALL_OW 1
21968: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21969: LD_ADDR_EXP 96
21973: PUSH
21974: LD_EXP 96
21978: PPUSH
21979: LD_VAR 0 4
21983: PPUSH
21984: EMPTY
21985: PPUSH
21986: CALL_OW 1
21990: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21991: LD_ADDR_EXP 97
21995: PUSH
21996: LD_EXP 97
22000: PPUSH
22001: LD_VAR 0 4
22005: PPUSH
22006: EMPTY
22007: PPUSH
22008: CALL_OW 1
22012: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22013: LD_ADDR_EXP 98
22017: PUSH
22018: LD_EXP 98
22022: PPUSH
22023: LD_VAR 0 4
22027: PPUSH
22028: LD_INT 0
22030: PPUSH
22031: CALL_OW 1
22035: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22036: LD_ADDR_EXP 99
22040: PUSH
22041: LD_EXP 99
22045: PPUSH
22046: LD_VAR 0 4
22050: PPUSH
22051: EMPTY
22052: PPUSH
22053: CALL_OW 1
22057: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22058: LD_ADDR_EXP 100
22062: PUSH
22063: LD_EXP 100
22067: PPUSH
22068: LD_VAR 0 4
22072: PPUSH
22073: EMPTY
22074: PPUSH
22075: CALL_OW 1
22079: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22080: LD_ADDR_EXP 101
22084: PUSH
22085: LD_EXP 101
22089: PPUSH
22090: LD_VAR 0 4
22094: PPUSH
22095: EMPTY
22096: PPUSH
22097: CALL_OW 1
22101: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22102: LD_ADDR_EXP 102
22106: PUSH
22107: LD_EXP 102
22111: PPUSH
22112: LD_VAR 0 4
22116: PPUSH
22117: EMPTY
22118: PPUSH
22119: CALL_OW 1
22123: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22124: LD_ADDR_EXP 103
22128: PUSH
22129: LD_EXP 103
22133: PPUSH
22134: LD_VAR 0 4
22138: PPUSH
22139: EMPTY
22140: PPUSH
22141: CALL_OW 1
22145: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22146: LD_ADDR_EXP 104
22150: PUSH
22151: LD_EXP 104
22155: PPUSH
22156: LD_VAR 0 4
22160: PPUSH
22161: EMPTY
22162: PPUSH
22163: CALL_OW 1
22167: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22168: LD_ADDR_EXP 105
22172: PUSH
22173: LD_EXP 105
22177: PPUSH
22178: LD_VAR 0 4
22182: PPUSH
22183: EMPTY
22184: PPUSH
22185: CALL_OW 1
22189: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22190: LD_ADDR_EXP 106
22194: PUSH
22195: LD_EXP 106
22199: PPUSH
22200: LD_VAR 0 4
22204: PPUSH
22205: EMPTY
22206: PPUSH
22207: CALL_OW 1
22211: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22212: LD_ADDR_EXP 107
22216: PUSH
22217: LD_EXP 107
22221: PPUSH
22222: LD_VAR 0 4
22226: PPUSH
22227: EMPTY
22228: PPUSH
22229: CALL_OW 1
22233: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22234: LD_ADDR_EXP 108
22238: PUSH
22239: LD_EXP 108
22243: PPUSH
22244: LD_VAR 0 4
22248: PPUSH
22249: EMPTY
22250: PPUSH
22251: CALL_OW 1
22255: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22256: LD_ADDR_EXP 109
22260: PUSH
22261: LD_EXP 109
22265: PPUSH
22266: LD_VAR 0 4
22270: PPUSH
22271: EMPTY
22272: PPUSH
22273: CALL_OW 1
22277: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22278: LD_ADDR_EXP 110
22282: PUSH
22283: LD_EXP 110
22287: PPUSH
22288: LD_VAR 0 4
22292: PPUSH
22293: EMPTY
22294: PPUSH
22295: CALL_OW 1
22299: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22300: LD_ADDR_EXP 111
22304: PUSH
22305: LD_EXP 111
22309: PPUSH
22310: LD_VAR 0 4
22314: PPUSH
22315: EMPTY
22316: PPUSH
22317: CALL_OW 1
22321: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22322: LD_ADDR_EXP 112
22326: PUSH
22327: LD_EXP 112
22331: PPUSH
22332: LD_VAR 0 4
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL_OW 1
22343: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22344: LD_ADDR_EXP 114
22348: PUSH
22349: LD_EXP 114
22353: PPUSH
22354: LD_VAR 0 4
22358: PPUSH
22359: EMPTY
22360: PPUSH
22361: CALL_OW 1
22365: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22366: LD_ADDR_EXP 116
22370: PUSH
22371: LD_EXP 116
22375: PPUSH
22376: LD_VAR 0 4
22380: PPUSH
22381: EMPTY
22382: PPUSH
22383: CALL_OW 1
22387: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22388: LD_ADDR_EXP 117
22392: PUSH
22393: LD_EXP 117
22397: PPUSH
22398: LD_VAR 0 4
22402: PPUSH
22403: EMPTY
22404: PPUSH
22405: CALL_OW 1
22409: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22410: LD_ADDR_EXP 118
22414: PUSH
22415: LD_EXP 118
22419: PPUSH
22420: LD_VAR 0 4
22424: PPUSH
22425: EMPTY
22426: PPUSH
22427: CALL_OW 1
22431: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22432: LD_ADDR_EXP 119
22436: PUSH
22437: LD_EXP 119
22441: PPUSH
22442: LD_VAR 0 4
22446: PPUSH
22447: EMPTY
22448: PPUSH
22449: CALL_OW 1
22453: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22454: LD_ADDR_EXP 120
22458: PUSH
22459: LD_EXP 120
22463: PPUSH
22464: LD_VAR 0 4
22468: PPUSH
22469: EMPTY
22470: PPUSH
22471: CALL_OW 1
22475: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22476: LD_ADDR_EXP 121
22480: PUSH
22481: LD_EXP 121
22485: PPUSH
22486: LD_VAR 0 4
22490: PPUSH
22491: EMPTY
22492: PPUSH
22493: CALL_OW 1
22497: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22498: LD_ADDR_EXP 122
22502: PUSH
22503: LD_EXP 122
22507: PPUSH
22508: LD_VAR 0 4
22512: PPUSH
22513: EMPTY
22514: PPUSH
22515: CALL_OW 1
22519: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22520: LD_ADDR_EXP 123
22524: PUSH
22525: LD_EXP 123
22529: PPUSH
22530: LD_VAR 0 4
22534: PPUSH
22535: EMPTY
22536: PPUSH
22537: CALL_OW 1
22541: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22542: LD_ADDR_EXP 124
22546: PUSH
22547: LD_EXP 124
22551: PPUSH
22552: LD_VAR 0 4
22556: PPUSH
22557: EMPTY
22558: PPUSH
22559: CALL_OW 1
22563: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22564: LD_ADDR_EXP 125
22568: PUSH
22569: LD_EXP 125
22573: PPUSH
22574: LD_VAR 0 4
22578: PPUSH
22579: EMPTY
22580: PPUSH
22581: CALL_OW 1
22585: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22586: LD_ADDR_EXP 126
22590: PUSH
22591: LD_EXP 126
22595: PPUSH
22596: LD_VAR 0 4
22600: PPUSH
22601: EMPTY
22602: PPUSH
22603: CALL_OW 1
22607: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22608: LD_ADDR_EXP 127
22612: PUSH
22613: LD_EXP 127
22617: PPUSH
22618: LD_VAR 0 4
22622: PPUSH
22623: EMPTY
22624: PPUSH
22625: CALL_OW 1
22629: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22630: LD_ADDR_EXP 128
22634: PUSH
22635: LD_EXP 128
22639: PPUSH
22640: LD_VAR 0 4
22644: PPUSH
22645: EMPTY
22646: PPUSH
22647: CALL_OW 1
22651: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22652: LD_ADDR_EXP 129
22656: PUSH
22657: LD_EXP 129
22661: PPUSH
22662: LD_VAR 0 4
22666: PPUSH
22667: LD_INT 0
22669: PPUSH
22670: CALL_OW 1
22674: ST_TO_ADDR
// result := base ;
22675: LD_ADDR_VAR 0 3
22679: PUSH
22680: LD_VAR 0 4
22684: ST_TO_ADDR
// end ;
22685: LD_VAR 0 3
22689: RET
// export function MC_Start ( ) ; var i ; begin
22690: LD_INT 0
22692: PPUSH
22693: PPUSH
// for i = 1 to mc_bases do
22694: LD_ADDR_VAR 0 2
22698: PUSH
22699: DOUBLE
22700: LD_INT 1
22702: DEC
22703: ST_TO_ADDR
22704: LD_EXP 87
22708: PUSH
22709: FOR_TO
22710: IFFALSE 23787
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22712: LD_ADDR_EXP 87
22716: PUSH
22717: LD_EXP 87
22721: PPUSH
22722: LD_VAR 0 2
22726: PPUSH
22727: LD_EXP 87
22731: PUSH
22732: LD_VAR 0 2
22736: ARRAY
22737: PUSH
22738: LD_INT 0
22740: DIFF
22741: PPUSH
22742: CALL_OW 1
22746: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22747: LD_ADDR_EXP 88
22751: PUSH
22752: LD_EXP 88
22756: PPUSH
22757: LD_VAR 0 2
22761: PPUSH
22762: EMPTY
22763: PPUSH
22764: CALL_OW 1
22768: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22769: LD_ADDR_EXP 89
22773: PUSH
22774: LD_EXP 89
22778: PPUSH
22779: LD_VAR 0 2
22783: PPUSH
22784: EMPTY
22785: PPUSH
22786: CALL_OW 1
22790: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22791: LD_ADDR_EXP 90
22795: PUSH
22796: LD_EXP 90
22800: PPUSH
22801: LD_VAR 0 2
22805: PPUSH
22806: EMPTY
22807: PPUSH
22808: CALL_OW 1
22812: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22813: LD_ADDR_EXP 91
22817: PUSH
22818: LD_EXP 91
22822: PPUSH
22823: LD_VAR 0 2
22827: PPUSH
22828: EMPTY
22829: PUSH
22830: EMPTY
22831: PUSH
22832: EMPTY
22833: LIST
22834: LIST
22835: PPUSH
22836: CALL_OW 1
22840: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22841: LD_ADDR_EXP 92
22845: PUSH
22846: LD_EXP 92
22850: PPUSH
22851: LD_VAR 0 2
22855: PPUSH
22856: EMPTY
22857: PPUSH
22858: CALL_OW 1
22862: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22863: LD_ADDR_EXP 119
22867: PUSH
22868: LD_EXP 119
22872: PPUSH
22873: LD_VAR 0 2
22877: PPUSH
22878: EMPTY
22879: PPUSH
22880: CALL_OW 1
22884: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22885: LD_ADDR_EXP 93
22889: PUSH
22890: LD_EXP 93
22894: PPUSH
22895: LD_VAR 0 2
22899: PPUSH
22900: EMPTY
22901: PPUSH
22902: CALL_OW 1
22906: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22907: LD_ADDR_EXP 94
22911: PUSH
22912: LD_EXP 94
22916: PPUSH
22917: LD_VAR 0 2
22921: PPUSH
22922: EMPTY
22923: PPUSH
22924: CALL_OW 1
22928: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22929: LD_ADDR_EXP 95
22933: PUSH
22934: LD_EXP 95
22938: PPUSH
22939: LD_VAR 0 2
22943: PPUSH
22944: LD_EXP 87
22948: PUSH
22949: LD_VAR 0 2
22953: ARRAY
22954: PPUSH
22955: LD_INT 2
22957: PUSH
22958: LD_INT 30
22960: PUSH
22961: LD_INT 32
22963: PUSH
22964: EMPTY
22965: LIST
22966: LIST
22967: PUSH
22968: LD_INT 30
22970: PUSH
22971: LD_INT 33
22973: PUSH
22974: EMPTY
22975: LIST
22976: LIST
22977: PUSH
22978: EMPTY
22979: LIST
22980: LIST
22981: LIST
22982: PPUSH
22983: CALL_OW 72
22987: PPUSH
22988: CALL_OW 1
22992: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22993: LD_ADDR_EXP 96
22997: PUSH
22998: LD_EXP 96
23002: PPUSH
23003: LD_VAR 0 2
23007: PPUSH
23008: LD_EXP 87
23012: PUSH
23013: LD_VAR 0 2
23017: ARRAY
23018: PPUSH
23019: LD_INT 2
23021: PUSH
23022: LD_INT 30
23024: PUSH
23025: LD_INT 32
23027: PUSH
23028: EMPTY
23029: LIST
23030: LIST
23031: PUSH
23032: LD_INT 30
23034: PUSH
23035: LD_INT 31
23037: PUSH
23038: EMPTY
23039: LIST
23040: LIST
23041: PUSH
23042: EMPTY
23043: LIST
23044: LIST
23045: LIST
23046: PUSH
23047: LD_INT 58
23049: PUSH
23050: EMPTY
23051: LIST
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PPUSH
23057: CALL_OW 72
23061: PPUSH
23062: CALL_OW 1
23066: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23067: LD_ADDR_EXP 97
23071: PUSH
23072: LD_EXP 97
23076: PPUSH
23077: LD_VAR 0 2
23081: PPUSH
23082: EMPTY
23083: PPUSH
23084: CALL_OW 1
23088: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23089: LD_ADDR_EXP 101
23093: PUSH
23094: LD_EXP 101
23098: PPUSH
23099: LD_VAR 0 2
23103: PPUSH
23104: EMPTY
23105: PPUSH
23106: CALL_OW 1
23110: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23111: LD_ADDR_EXP 100
23115: PUSH
23116: LD_EXP 100
23120: PPUSH
23121: LD_VAR 0 2
23125: PPUSH
23126: EMPTY
23127: PPUSH
23128: CALL_OW 1
23132: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23133: LD_ADDR_EXP 102
23137: PUSH
23138: LD_EXP 102
23142: PPUSH
23143: LD_VAR 0 2
23147: PPUSH
23148: EMPTY
23149: PPUSH
23150: CALL_OW 1
23154: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23155: LD_ADDR_EXP 103
23159: PUSH
23160: LD_EXP 103
23164: PPUSH
23165: LD_VAR 0 2
23169: PPUSH
23170: EMPTY
23171: PPUSH
23172: CALL_OW 1
23176: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23177: LD_ADDR_EXP 104
23181: PUSH
23182: LD_EXP 104
23186: PPUSH
23187: LD_VAR 0 2
23191: PPUSH
23192: EMPTY
23193: PPUSH
23194: CALL_OW 1
23198: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23199: LD_ADDR_EXP 105
23203: PUSH
23204: LD_EXP 105
23208: PPUSH
23209: LD_VAR 0 2
23213: PPUSH
23214: EMPTY
23215: PPUSH
23216: CALL_OW 1
23220: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23221: LD_ADDR_EXP 106
23225: PUSH
23226: LD_EXP 106
23230: PPUSH
23231: LD_VAR 0 2
23235: PPUSH
23236: EMPTY
23237: PPUSH
23238: CALL_OW 1
23242: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23243: LD_ADDR_EXP 107
23247: PUSH
23248: LD_EXP 107
23252: PPUSH
23253: LD_VAR 0 2
23257: PPUSH
23258: EMPTY
23259: PPUSH
23260: CALL_OW 1
23264: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23265: LD_ADDR_EXP 108
23269: PUSH
23270: LD_EXP 108
23274: PPUSH
23275: LD_VAR 0 2
23279: PPUSH
23280: EMPTY
23281: PPUSH
23282: CALL_OW 1
23286: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23287: LD_ADDR_EXP 109
23291: PUSH
23292: LD_EXP 109
23296: PPUSH
23297: LD_VAR 0 2
23301: PPUSH
23302: EMPTY
23303: PPUSH
23304: CALL_OW 1
23308: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23309: LD_ADDR_EXP 98
23313: PUSH
23314: LD_EXP 98
23318: PPUSH
23319: LD_VAR 0 2
23323: PPUSH
23324: LD_INT 0
23326: PPUSH
23327: CALL_OW 1
23331: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23332: LD_ADDR_EXP 111
23336: PUSH
23337: LD_EXP 111
23341: PPUSH
23342: LD_VAR 0 2
23346: PPUSH
23347: LD_INT 0
23349: PPUSH
23350: CALL_OW 1
23354: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23355: LD_ADDR_EXP 99
23359: PUSH
23360: LD_EXP 99
23364: PPUSH
23365: LD_VAR 0 2
23369: PPUSH
23370: EMPTY
23371: PPUSH
23372: CALL_OW 1
23376: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23377: LD_ADDR_EXP 110
23381: PUSH
23382: LD_EXP 110
23386: PPUSH
23387: LD_VAR 0 2
23391: PPUSH
23392: LD_INT 0
23394: PPUSH
23395: CALL_OW 1
23399: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23400: LD_ADDR_EXP 112
23404: PUSH
23405: LD_EXP 112
23409: PPUSH
23410: LD_VAR 0 2
23414: PPUSH
23415: EMPTY
23416: PPUSH
23417: CALL_OW 1
23421: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23422: LD_ADDR_EXP 115
23426: PUSH
23427: LD_EXP 115
23431: PPUSH
23432: LD_VAR 0 2
23436: PPUSH
23437: LD_INT 0
23439: PPUSH
23440: CALL_OW 1
23444: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23445: LD_ADDR_EXP 116
23449: PUSH
23450: LD_EXP 116
23454: PPUSH
23455: LD_VAR 0 2
23459: PPUSH
23460: EMPTY
23461: PPUSH
23462: CALL_OW 1
23466: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23467: LD_ADDR_EXP 117
23471: PUSH
23472: LD_EXP 117
23476: PPUSH
23477: LD_VAR 0 2
23481: PPUSH
23482: EMPTY
23483: PPUSH
23484: CALL_OW 1
23488: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23489: LD_ADDR_EXP 118
23493: PUSH
23494: LD_EXP 118
23498: PPUSH
23499: LD_VAR 0 2
23503: PPUSH
23504: EMPTY
23505: PPUSH
23506: CALL_OW 1
23510: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23511: LD_ADDR_EXP 120
23515: PUSH
23516: LD_EXP 120
23520: PPUSH
23521: LD_VAR 0 2
23525: PPUSH
23526: LD_EXP 87
23530: PUSH
23531: LD_VAR 0 2
23535: ARRAY
23536: PPUSH
23537: LD_INT 2
23539: PUSH
23540: LD_INT 30
23542: PUSH
23543: LD_INT 6
23545: PUSH
23546: EMPTY
23547: LIST
23548: LIST
23549: PUSH
23550: LD_INT 30
23552: PUSH
23553: LD_INT 7
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: PUSH
23560: LD_INT 30
23562: PUSH
23563: LD_INT 8
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: LIST
23574: LIST
23575: PPUSH
23576: CALL_OW 72
23580: PPUSH
23581: CALL_OW 1
23585: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23586: LD_ADDR_EXP 121
23590: PUSH
23591: LD_EXP 121
23595: PPUSH
23596: LD_VAR 0 2
23600: PPUSH
23601: EMPTY
23602: PPUSH
23603: CALL_OW 1
23607: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23608: LD_ADDR_EXP 122
23612: PUSH
23613: LD_EXP 122
23617: PPUSH
23618: LD_VAR 0 2
23622: PPUSH
23623: EMPTY
23624: PPUSH
23625: CALL_OW 1
23629: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23630: LD_ADDR_EXP 123
23634: PUSH
23635: LD_EXP 123
23639: PPUSH
23640: LD_VAR 0 2
23644: PPUSH
23645: EMPTY
23646: PPUSH
23647: CALL_OW 1
23651: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23652: LD_ADDR_EXP 124
23656: PUSH
23657: LD_EXP 124
23661: PPUSH
23662: LD_VAR 0 2
23666: PPUSH
23667: EMPTY
23668: PPUSH
23669: CALL_OW 1
23673: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23674: LD_ADDR_EXP 125
23678: PUSH
23679: LD_EXP 125
23683: PPUSH
23684: LD_VAR 0 2
23688: PPUSH
23689: EMPTY
23690: PPUSH
23691: CALL_OW 1
23695: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23696: LD_ADDR_EXP 126
23700: PUSH
23701: LD_EXP 126
23705: PPUSH
23706: LD_VAR 0 2
23710: PPUSH
23711: EMPTY
23712: PPUSH
23713: CALL_OW 1
23717: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23718: LD_ADDR_EXP 127
23722: PUSH
23723: LD_EXP 127
23727: PPUSH
23728: LD_VAR 0 2
23732: PPUSH
23733: EMPTY
23734: PPUSH
23735: CALL_OW 1
23739: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23740: LD_ADDR_EXP 128
23744: PUSH
23745: LD_EXP 128
23749: PPUSH
23750: LD_VAR 0 2
23754: PPUSH
23755: EMPTY
23756: PPUSH
23757: CALL_OW 1
23761: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23762: LD_ADDR_EXP 129
23766: PUSH
23767: LD_EXP 129
23771: PPUSH
23772: LD_VAR 0 2
23776: PPUSH
23777: LD_INT 0
23779: PPUSH
23780: CALL_OW 1
23784: ST_TO_ADDR
// end ;
23785: GO 22709
23787: POP
23788: POP
// MC_InitSides ( ) ;
23789: CALL 24075 0 0
// MC_InitResearch ( ) ;
23793: CALL 23814 0 0
// CustomInitMacro ( ) ;
23797: CALL 213 0 0
// skirmish := true ;
23801: LD_ADDR_EXP 85
23805: PUSH
23806: LD_INT 1
23808: ST_TO_ADDR
// end ;
23809: LD_VAR 0 1
23813: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23814: LD_INT 0
23816: PPUSH
23817: PPUSH
23818: PPUSH
23819: PPUSH
23820: PPUSH
23821: PPUSH
// if not mc_bases then
23822: LD_EXP 87
23826: NOT
23827: IFFALSE 23831
// exit ;
23829: GO 24070
// for i = 1 to 8 do
23831: LD_ADDR_VAR 0 2
23835: PUSH
23836: DOUBLE
23837: LD_INT 1
23839: DEC
23840: ST_TO_ADDR
23841: LD_INT 8
23843: PUSH
23844: FOR_TO
23845: IFFALSE 23871
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23847: LD_ADDR_EXP 114
23851: PUSH
23852: LD_EXP 114
23856: PPUSH
23857: LD_VAR 0 2
23861: PPUSH
23862: EMPTY
23863: PPUSH
23864: CALL_OW 1
23868: ST_TO_ADDR
23869: GO 23844
23871: POP
23872: POP
// tmp := [ ] ;
23873: LD_ADDR_VAR 0 5
23877: PUSH
23878: EMPTY
23879: ST_TO_ADDR
// for i = 1 to mc_sides do
23880: LD_ADDR_VAR 0 2
23884: PUSH
23885: DOUBLE
23886: LD_INT 1
23888: DEC
23889: ST_TO_ADDR
23890: LD_EXP 113
23894: PUSH
23895: FOR_TO
23896: IFFALSE 23954
// if not mc_sides [ i ] in tmp then
23898: LD_EXP 113
23902: PUSH
23903: LD_VAR 0 2
23907: ARRAY
23908: PUSH
23909: LD_VAR 0 5
23913: IN
23914: NOT
23915: IFFALSE 23952
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23917: LD_ADDR_VAR 0 5
23921: PUSH
23922: LD_VAR 0 5
23926: PPUSH
23927: LD_VAR 0 5
23931: PUSH
23932: LD_INT 1
23934: PLUS
23935: PPUSH
23936: LD_EXP 113
23940: PUSH
23941: LD_VAR 0 2
23945: ARRAY
23946: PPUSH
23947: CALL_OW 2
23951: ST_TO_ADDR
23952: GO 23895
23954: POP
23955: POP
// if not tmp then
23956: LD_VAR 0 5
23960: NOT
23961: IFFALSE 23965
// exit ;
23963: GO 24070
// for j in tmp do
23965: LD_ADDR_VAR 0 3
23969: PUSH
23970: LD_VAR 0 5
23974: PUSH
23975: FOR_IN
23976: IFFALSE 24068
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23978: LD_ADDR_VAR 0 6
23982: PUSH
23983: LD_INT 22
23985: PUSH
23986: LD_VAR 0 3
23990: PUSH
23991: EMPTY
23992: LIST
23993: LIST
23994: PPUSH
23995: CALL_OW 69
23999: ST_TO_ADDR
// if not un then
24000: LD_VAR 0 6
24004: NOT
24005: IFFALSE 24009
// continue ;
24007: GO 23975
// nation := GetNation ( un [ 1 ] ) ;
24009: LD_ADDR_VAR 0 4
24013: PUSH
24014: LD_VAR 0 6
24018: PUSH
24019: LD_INT 1
24021: ARRAY
24022: PPUSH
24023: CALL_OW 248
24027: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24028: LD_ADDR_EXP 114
24032: PUSH
24033: LD_EXP 114
24037: PPUSH
24038: LD_VAR 0 3
24042: PPUSH
24043: LD_VAR 0 3
24047: PPUSH
24048: LD_VAR 0 4
24052: PPUSH
24053: LD_INT 1
24055: PPUSH
24056: CALL 50664 0 3
24060: PPUSH
24061: CALL_OW 1
24065: ST_TO_ADDR
// end ;
24066: GO 23975
24068: POP
24069: POP
// end ;
24070: LD_VAR 0 1
24074: RET
// export function MC_InitSides ( ) ; var i ; begin
24075: LD_INT 0
24077: PPUSH
24078: PPUSH
// if not mc_bases then
24079: LD_EXP 87
24083: NOT
24084: IFFALSE 24088
// exit ;
24086: GO 24162
// for i = 1 to mc_bases do
24088: LD_ADDR_VAR 0 2
24092: PUSH
24093: DOUBLE
24094: LD_INT 1
24096: DEC
24097: ST_TO_ADDR
24098: LD_EXP 87
24102: PUSH
24103: FOR_TO
24104: IFFALSE 24160
// if mc_bases [ i ] then
24106: LD_EXP 87
24110: PUSH
24111: LD_VAR 0 2
24115: ARRAY
24116: IFFALSE 24158
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24118: LD_ADDR_EXP 113
24122: PUSH
24123: LD_EXP 113
24127: PPUSH
24128: LD_VAR 0 2
24132: PPUSH
24133: LD_EXP 87
24137: PUSH
24138: LD_VAR 0 2
24142: ARRAY
24143: PUSH
24144: LD_INT 1
24146: ARRAY
24147: PPUSH
24148: CALL_OW 255
24152: PPUSH
24153: CALL_OW 1
24157: ST_TO_ADDR
24158: GO 24103
24160: POP
24161: POP
// end ;
24162: LD_VAR 0 1
24166: RET
// every 0 0$01 trigger skirmish do
24167: LD_EXP 85
24171: IFFALSE 24325
24173: GO 24175
24175: DISABLE
// begin enable ;
24176: ENABLE
// MC_CheckBuildings ( ) ;
24177: CALL 28823 0 0
// MC_CheckPeopleLife ( ) ;
24181: CALL 28948 0 0
// RaiseSailEvent ( 100 ) ;
24185: LD_INT 100
24187: PPUSH
24188: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24192: LD_INT 103
24194: PPUSH
24195: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24199: LD_INT 104
24201: PPUSH
24202: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24206: LD_INT 105
24208: PPUSH
24209: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24213: LD_INT 106
24215: PPUSH
24216: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24220: LD_INT 107
24222: PPUSH
24223: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24227: LD_INT 108
24229: PPUSH
24230: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24234: LD_INT 109
24236: PPUSH
24237: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24241: LD_INT 110
24243: PPUSH
24244: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24248: LD_INT 111
24250: PPUSH
24251: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24255: LD_INT 112
24257: PPUSH
24258: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24262: LD_INT 113
24264: PPUSH
24265: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24269: LD_INT 120
24271: PPUSH
24272: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24276: LD_INT 121
24278: PPUSH
24279: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24283: LD_INT 122
24285: PPUSH
24286: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24290: LD_INT 123
24292: PPUSH
24293: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24297: LD_INT 124
24299: PPUSH
24300: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24304: LD_INT 125
24306: PPUSH
24307: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24311: LD_INT 126
24313: PPUSH
24314: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24318: LD_INT 200
24320: PPUSH
24321: CALL_OW 427
// end ;
24325: END
// on SailEvent ( event ) do begin if event < 100 then
24326: LD_VAR 0 1
24330: PUSH
24331: LD_INT 100
24333: LESS
24334: IFFALSE 24345
// CustomEvent ( event ) ;
24336: LD_VAR 0 1
24340: PPUSH
24341: CALL 10371 0 1
// if event = 100 then
24345: LD_VAR 0 1
24349: PUSH
24350: LD_INT 100
24352: EQUAL
24353: IFFALSE 24359
// MC_ClassManager ( ) ;
24355: CALL 24751 0 0
// if event = 101 then
24359: LD_VAR 0 1
24363: PUSH
24364: LD_INT 101
24366: EQUAL
24367: IFFALSE 24373
// MC_RepairBuildings ( ) ;
24369: CALL 29533 0 0
// if event = 102 then
24373: LD_VAR 0 1
24377: PUSH
24378: LD_INT 102
24380: EQUAL
24381: IFFALSE 24387
// MC_Heal ( ) ;
24383: CALL 30392 0 0
// if event = 103 then
24387: LD_VAR 0 1
24391: PUSH
24392: LD_INT 103
24394: EQUAL
24395: IFFALSE 24401
// MC_Build ( ) ;
24397: CALL 30814 0 0
// if event = 104 then
24401: LD_VAR 0 1
24405: PUSH
24406: LD_INT 104
24408: EQUAL
24409: IFFALSE 24415
// MC_TurretWeapon ( ) ;
24411: CALL 32427 0 0
// if event = 105 then
24415: LD_VAR 0 1
24419: PUSH
24420: LD_INT 105
24422: EQUAL
24423: IFFALSE 24429
// MC_BuildUpgrade ( ) ;
24425: CALL 31978 0 0
// if event = 106 then
24429: LD_VAR 0 1
24433: PUSH
24434: LD_INT 106
24436: EQUAL
24437: IFFALSE 24443
// MC_PlantMines ( ) ;
24439: CALL 32857 0 0
// if event = 107 then
24443: LD_VAR 0 1
24447: PUSH
24448: LD_INT 107
24450: EQUAL
24451: IFFALSE 24457
// MC_CollectCrates ( ) ;
24453: CALL 33655 0 0
// if event = 108 then
24457: LD_VAR 0 1
24461: PUSH
24462: LD_INT 108
24464: EQUAL
24465: IFFALSE 24471
// MC_LinkRemoteControl ( ) ;
24467: CALL 35431 0 0
// if event = 109 then
24471: LD_VAR 0 1
24475: PUSH
24476: LD_INT 109
24478: EQUAL
24479: IFFALSE 24485
// MC_ProduceVehicle ( ) ;
24481: CALL 35612 0 0
// if event = 110 then
24485: LD_VAR 0 1
24489: PUSH
24490: LD_INT 110
24492: EQUAL
24493: IFFALSE 24499
// MC_SendAttack ( ) ;
24495: CALL 36078 0 0
// if event = 111 then
24499: LD_VAR 0 1
24503: PUSH
24504: LD_INT 111
24506: EQUAL
24507: IFFALSE 24513
// MC_Defend ( ) ;
24509: CALL 36186 0 0
// if event = 112 then
24513: LD_VAR 0 1
24517: PUSH
24518: LD_INT 112
24520: EQUAL
24521: IFFALSE 24527
// MC_Research ( ) ;
24523: CALL 36791 0 0
// if event = 113 then
24527: LD_VAR 0 1
24531: PUSH
24532: LD_INT 113
24534: EQUAL
24535: IFFALSE 24541
// MC_MinesTrigger ( ) ;
24537: CALL 37905 0 0
// if event = 120 then
24541: LD_VAR 0 1
24545: PUSH
24546: LD_INT 120
24548: EQUAL
24549: IFFALSE 24555
// MC_RepairVehicle ( ) ;
24551: CALL 38004 0 0
// if event = 121 then
24555: LD_VAR 0 1
24559: PUSH
24560: LD_INT 121
24562: EQUAL
24563: IFFALSE 24569
// MC_TameApe ( ) ;
24565: CALL 38734 0 0
// if event = 122 then
24569: LD_VAR 0 1
24573: PUSH
24574: LD_INT 122
24576: EQUAL
24577: IFFALSE 24583
// MC_ChangeApeClass ( ) ;
24579: CALL 39563 0 0
// if event = 123 then
24583: LD_VAR 0 1
24587: PUSH
24588: LD_INT 123
24590: EQUAL
24591: IFFALSE 24597
// MC_Bazooka ( ) ;
24593: CALL 40213 0 0
// if event = 124 then
24597: LD_VAR 0 1
24601: PUSH
24602: LD_INT 124
24604: EQUAL
24605: IFFALSE 24611
// MC_TeleportExit ( ) ;
24607: CALL 40411 0 0
// if event = 125 then
24611: LD_VAR 0 1
24615: PUSH
24616: LD_INT 125
24618: EQUAL
24619: IFFALSE 24625
// MC_Deposits ( ) ;
24621: CALL 41058 0 0
// if event = 126 then
24625: LD_VAR 0 1
24629: PUSH
24630: LD_INT 126
24632: EQUAL
24633: IFFALSE 24639
// MC_RemoteDriver ( ) ;
24635: CALL 41683 0 0
// if event = 200 then
24639: LD_VAR 0 1
24643: PUSH
24644: LD_INT 200
24646: EQUAL
24647: IFFALSE 24653
// MC_Idle ( ) ;
24649: CALL 43632 0 0
// end ;
24653: PPOPN 1
24655: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24656: LD_INT 0
24658: PPUSH
24659: PPUSH
// if not mc_bases [ base ] or not tag then
24660: LD_EXP 87
24664: PUSH
24665: LD_VAR 0 1
24669: ARRAY
24670: NOT
24671: PUSH
24672: LD_VAR 0 2
24676: NOT
24677: OR
24678: IFFALSE 24682
// exit ;
24680: GO 24746
// for i in mc_bases [ base ] union mc_ape [ base ] do
24682: LD_ADDR_VAR 0 4
24686: PUSH
24687: LD_EXP 87
24691: PUSH
24692: LD_VAR 0 1
24696: ARRAY
24697: PUSH
24698: LD_EXP 116
24702: PUSH
24703: LD_VAR 0 1
24707: ARRAY
24708: UNION
24709: PUSH
24710: FOR_IN
24711: IFFALSE 24744
// if GetTag ( i ) = tag then
24713: LD_VAR 0 4
24717: PPUSH
24718: CALL_OW 110
24722: PUSH
24723: LD_VAR 0 2
24727: EQUAL
24728: IFFALSE 24742
// SetTag ( i , 0 ) ;
24730: LD_VAR 0 4
24734: PPUSH
24735: LD_INT 0
24737: PPUSH
24738: CALL_OW 109
24742: GO 24710
24744: POP
24745: POP
// end ;
24746: LD_VAR 0 3
24750: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24751: LD_INT 0
24753: PPUSH
24754: PPUSH
24755: PPUSH
24756: PPUSH
24757: PPUSH
24758: PPUSH
24759: PPUSH
24760: PPUSH
// if not mc_bases then
24761: LD_EXP 87
24765: NOT
24766: IFFALSE 24770
// exit ;
24768: GO 25228
// for i = 1 to mc_bases do
24770: LD_ADDR_VAR 0 2
24774: PUSH
24775: DOUBLE
24776: LD_INT 1
24778: DEC
24779: ST_TO_ADDR
24780: LD_EXP 87
24784: PUSH
24785: FOR_TO
24786: IFFALSE 25226
// begin tmp := MC_ClassCheckReq ( i ) ;
24788: LD_ADDR_VAR 0 4
24792: PUSH
24793: LD_VAR 0 2
24797: PPUSH
24798: CALL 25233 0 1
24802: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24803: LD_ADDR_EXP 128
24807: PUSH
24808: LD_EXP 128
24812: PPUSH
24813: LD_VAR 0 2
24817: PPUSH
24818: LD_VAR 0 4
24822: PPUSH
24823: CALL_OW 1
24827: ST_TO_ADDR
// if not tmp then
24828: LD_VAR 0 4
24832: NOT
24833: IFFALSE 24837
// continue ;
24835: GO 24785
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24837: LD_ADDR_VAR 0 6
24841: PUSH
24842: LD_EXP 87
24846: PUSH
24847: LD_VAR 0 2
24851: ARRAY
24852: PPUSH
24853: LD_INT 2
24855: PUSH
24856: LD_INT 30
24858: PUSH
24859: LD_INT 4
24861: PUSH
24862: EMPTY
24863: LIST
24864: LIST
24865: PUSH
24866: LD_INT 30
24868: PUSH
24869: LD_INT 5
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: LIST
24880: PPUSH
24881: CALL_OW 72
24885: PUSH
24886: LD_EXP 87
24890: PUSH
24891: LD_VAR 0 2
24895: ARRAY
24896: PPUSH
24897: LD_INT 2
24899: PUSH
24900: LD_INT 30
24902: PUSH
24903: LD_INT 0
24905: PUSH
24906: EMPTY
24907: LIST
24908: LIST
24909: PUSH
24910: LD_INT 30
24912: PUSH
24913: LD_INT 1
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: EMPTY
24921: LIST
24922: LIST
24923: LIST
24924: PPUSH
24925: CALL_OW 72
24929: PUSH
24930: LD_EXP 87
24934: PUSH
24935: LD_VAR 0 2
24939: ARRAY
24940: PPUSH
24941: LD_INT 30
24943: PUSH
24944: LD_INT 3
24946: PUSH
24947: EMPTY
24948: LIST
24949: LIST
24950: PPUSH
24951: CALL_OW 72
24955: PUSH
24956: LD_EXP 87
24960: PUSH
24961: LD_VAR 0 2
24965: ARRAY
24966: PPUSH
24967: LD_INT 2
24969: PUSH
24970: LD_INT 30
24972: PUSH
24973: LD_INT 6
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 30
24982: PUSH
24983: LD_INT 7
24985: PUSH
24986: EMPTY
24987: LIST
24988: LIST
24989: PUSH
24990: LD_INT 30
24992: PUSH
24993: LD_INT 8
24995: PUSH
24996: EMPTY
24997: LIST
24998: LIST
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: LIST
25004: LIST
25005: PPUSH
25006: CALL_OW 72
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: LIST
25015: LIST
25016: ST_TO_ADDR
// for j = 1 to 4 do
25017: LD_ADDR_VAR 0 3
25021: PUSH
25022: DOUBLE
25023: LD_INT 1
25025: DEC
25026: ST_TO_ADDR
25027: LD_INT 4
25029: PUSH
25030: FOR_TO
25031: IFFALSE 25222
// begin if not tmp [ j ] then
25033: LD_VAR 0 4
25037: PUSH
25038: LD_VAR 0 3
25042: ARRAY
25043: NOT
25044: IFFALSE 25048
// continue ;
25046: GO 25030
// for p in tmp [ j ] do
25048: LD_ADDR_VAR 0 5
25052: PUSH
25053: LD_VAR 0 4
25057: PUSH
25058: LD_VAR 0 3
25062: ARRAY
25063: PUSH
25064: FOR_IN
25065: IFFALSE 25218
// begin if not b [ j ] then
25067: LD_VAR 0 6
25071: PUSH
25072: LD_VAR 0 3
25076: ARRAY
25077: NOT
25078: IFFALSE 25082
// break ;
25080: GO 25218
// e := 0 ;
25082: LD_ADDR_VAR 0 7
25086: PUSH
25087: LD_INT 0
25089: ST_TO_ADDR
// for k in b [ j ] do
25090: LD_ADDR_VAR 0 8
25094: PUSH
25095: LD_VAR 0 6
25099: PUSH
25100: LD_VAR 0 3
25104: ARRAY
25105: PUSH
25106: FOR_IN
25107: IFFALSE 25134
// if IsNotFull ( k ) then
25109: LD_VAR 0 8
25113: PPUSH
25114: CALL 52813 0 1
25118: IFFALSE 25132
// begin e := k ;
25120: LD_ADDR_VAR 0 7
25124: PUSH
25125: LD_VAR 0 8
25129: ST_TO_ADDR
// break ;
25130: GO 25134
// end ;
25132: GO 25106
25134: POP
25135: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25136: LD_VAR 0 7
25140: PUSH
25141: LD_VAR 0 5
25145: PPUSH
25146: LD_VAR 0 7
25150: PPUSH
25151: CALL 85233 0 2
25155: NOT
25156: AND
25157: IFFALSE 25216
// begin if IsInUnit ( p ) then
25159: LD_VAR 0 5
25163: PPUSH
25164: CALL_OW 310
25168: IFFALSE 25179
// ComExitBuilding ( p ) ;
25170: LD_VAR 0 5
25174: PPUSH
25175: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25179: LD_VAR 0 5
25183: PPUSH
25184: LD_VAR 0 7
25188: PPUSH
25189: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25193: LD_VAR 0 5
25197: PPUSH
25198: LD_VAR 0 3
25202: PPUSH
25203: CALL_OW 183
// AddComExitBuilding ( p ) ;
25207: LD_VAR 0 5
25211: PPUSH
25212: CALL_OW 182
// end ; end ;
25216: GO 25064
25218: POP
25219: POP
// end ;
25220: GO 25030
25222: POP
25223: POP
// end ;
25224: GO 24785
25226: POP
25227: POP
// end ;
25228: LD_VAR 0 1
25232: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25233: LD_INT 0
25235: PPUSH
25236: PPUSH
25237: PPUSH
25238: PPUSH
25239: PPUSH
25240: PPUSH
25241: PPUSH
25242: PPUSH
25243: PPUSH
25244: PPUSH
25245: PPUSH
25246: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25247: LD_VAR 0 1
25251: NOT
25252: PUSH
25253: LD_EXP 87
25257: PUSH
25258: LD_VAR 0 1
25262: ARRAY
25263: NOT
25264: OR
25265: PUSH
25266: LD_EXP 87
25270: PUSH
25271: LD_VAR 0 1
25275: ARRAY
25276: PPUSH
25277: LD_INT 2
25279: PUSH
25280: LD_INT 30
25282: PUSH
25283: LD_INT 0
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 30
25292: PUSH
25293: LD_INT 1
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: EMPTY
25301: LIST
25302: LIST
25303: LIST
25304: PPUSH
25305: CALL_OW 72
25309: NOT
25310: OR
25311: IFFALSE 25315
// exit ;
25313: GO 28818
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25315: LD_ADDR_VAR 0 4
25319: PUSH
25320: LD_EXP 87
25324: PUSH
25325: LD_VAR 0 1
25329: ARRAY
25330: PPUSH
25331: LD_INT 2
25333: PUSH
25334: LD_INT 25
25336: PUSH
25337: LD_INT 1
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: PUSH
25344: LD_INT 25
25346: PUSH
25347: LD_INT 2
25349: PUSH
25350: EMPTY
25351: LIST
25352: LIST
25353: PUSH
25354: LD_INT 25
25356: PUSH
25357: LD_INT 3
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: PUSH
25364: LD_INT 25
25366: PUSH
25367: LD_INT 4
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PUSH
25374: LD_INT 25
25376: PUSH
25377: LD_INT 5
25379: PUSH
25380: EMPTY
25381: LIST
25382: LIST
25383: PUSH
25384: LD_INT 25
25386: PUSH
25387: LD_INT 8
25389: PUSH
25390: EMPTY
25391: LIST
25392: LIST
25393: PUSH
25394: LD_INT 25
25396: PUSH
25397: LD_INT 9
25399: PUSH
25400: EMPTY
25401: LIST
25402: LIST
25403: PUSH
25404: EMPTY
25405: LIST
25406: LIST
25407: LIST
25408: LIST
25409: LIST
25410: LIST
25411: LIST
25412: LIST
25413: PPUSH
25414: CALL_OW 72
25418: ST_TO_ADDR
// if not tmp then
25419: LD_VAR 0 4
25423: NOT
25424: IFFALSE 25428
// exit ;
25426: GO 28818
// for i in tmp do
25428: LD_ADDR_VAR 0 3
25432: PUSH
25433: LD_VAR 0 4
25437: PUSH
25438: FOR_IN
25439: IFFALSE 25470
// if GetTag ( i ) then
25441: LD_VAR 0 3
25445: PPUSH
25446: CALL_OW 110
25450: IFFALSE 25468
// tmp := tmp diff i ;
25452: LD_ADDR_VAR 0 4
25456: PUSH
25457: LD_VAR 0 4
25461: PUSH
25462: LD_VAR 0 3
25466: DIFF
25467: ST_TO_ADDR
25468: GO 25438
25470: POP
25471: POP
// if not tmp then
25472: LD_VAR 0 4
25476: NOT
25477: IFFALSE 25481
// exit ;
25479: GO 28818
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25481: LD_ADDR_VAR 0 5
25485: PUSH
25486: LD_EXP 87
25490: PUSH
25491: LD_VAR 0 1
25495: ARRAY
25496: PPUSH
25497: LD_INT 2
25499: PUSH
25500: LD_INT 25
25502: PUSH
25503: LD_INT 1
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: LD_INT 25
25512: PUSH
25513: LD_INT 5
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 25
25522: PUSH
25523: LD_INT 8
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 25
25532: PUSH
25533: LD_INT 9
25535: PUSH
25536: EMPTY
25537: LIST
25538: LIST
25539: PUSH
25540: EMPTY
25541: LIST
25542: LIST
25543: LIST
25544: LIST
25545: LIST
25546: PPUSH
25547: CALL_OW 72
25551: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25552: LD_ADDR_VAR 0 6
25556: PUSH
25557: LD_EXP 87
25561: PUSH
25562: LD_VAR 0 1
25566: ARRAY
25567: PPUSH
25568: LD_INT 25
25570: PUSH
25571: LD_INT 2
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PPUSH
25578: CALL_OW 72
25582: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25583: LD_ADDR_VAR 0 7
25587: PUSH
25588: LD_EXP 87
25592: PUSH
25593: LD_VAR 0 1
25597: ARRAY
25598: PPUSH
25599: LD_INT 25
25601: PUSH
25602: LD_INT 3
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: PPUSH
25609: CALL_OW 72
25613: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25614: LD_ADDR_VAR 0 8
25618: PUSH
25619: LD_EXP 87
25623: PUSH
25624: LD_VAR 0 1
25628: ARRAY
25629: PPUSH
25630: LD_INT 25
25632: PUSH
25633: LD_INT 4
25635: PUSH
25636: EMPTY
25637: LIST
25638: LIST
25639: PUSH
25640: LD_INT 24
25642: PUSH
25643: LD_INT 251
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PPUSH
25654: CALL_OW 72
25658: ST_TO_ADDR
// if mc_scan [ base ] then
25659: LD_EXP 110
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: IFFALSE 26130
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25671: LD_ADDR_EXP 129
25675: PUSH
25676: LD_EXP 129
25680: PPUSH
25681: LD_VAR 0 1
25685: PPUSH
25686: LD_INT 4
25688: PPUSH
25689: CALL_OW 1
25693: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25694: LD_ADDR_VAR 0 12
25698: PUSH
25699: LD_EXP 87
25703: PUSH
25704: LD_VAR 0 1
25708: ARRAY
25709: PPUSH
25710: LD_INT 2
25712: PUSH
25713: LD_INT 30
25715: PUSH
25716: LD_INT 4
25718: PUSH
25719: EMPTY
25720: LIST
25721: LIST
25722: PUSH
25723: LD_INT 30
25725: PUSH
25726: LD_INT 5
25728: PUSH
25729: EMPTY
25730: LIST
25731: LIST
25732: PUSH
25733: EMPTY
25734: LIST
25735: LIST
25736: LIST
25737: PPUSH
25738: CALL_OW 72
25742: ST_TO_ADDR
// if not b then
25743: LD_VAR 0 12
25747: NOT
25748: IFFALSE 25752
// exit ;
25750: GO 28818
// p := [ ] ;
25752: LD_ADDR_VAR 0 11
25756: PUSH
25757: EMPTY
25758: ST_TO_ADDR
// if sci >= 2 then
25759: LD_VAR 0 8
25763: PUSH
25764: LD_INT 2
25766: GREATEREQUAL
25767: IFFALSE 25798
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25769: LD_ADDR_VAR 0 8
25773: PUSH
25774: LD_VAR 0 8
25778: PUSH
25779: LD_INT 1
25781: ARRAY
25782: PUSH
25783: LD_VAR 0 8
25787: PUSH
25788: LD_INT 2
25790: ARRAY
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: ST_TO_ADDR
25796: GO 25859
// if sci = 1 then
25798: LD_VAR 0 8
25802: PUSH
25803: LD_INT 1
25805: EQUAL
25806: IFFALSE 25827
// sci := [ sci [ 1 ] ] else
25808: LD_ADDR_VAR 0 8
25812: PUSH
25813: LD_VAR 0 8
25817: PUSH
25818: LD_INT 1
25820: ARRAY
25821: PUSH
25822: EMPTY
25823: LIST
25824: ST_TO_ADDR
25825: GO 25859
// if sci = 0 then
25827: LD_VAR 0 8
25831: PUSH
25832: LD_INT 0
25834: EQUAL
25835: IFFALSE 25859
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25837: LD_ADDR_VAR 0 11
25841: PUSH
25842: LD_VAR 0 4
25846: PPUSH
25847: LD_INT 4
25849: PPUSH
25850: CALL 85096 0 2
25854: PUSH
25855: LD_INT 1
25857: ARRAY
25858: ST_TO_ADDR
// if eng > 4 then
25859: LD_VAR 0 6
25863: PUSH
25864: LD_INT 4
25866: GREATER
25867: IFFALSE 25913
// for i = eng downto 4 do
25869: LD_ADDR_VAR 0 3
25873: PUSH
25874: DOUBLE
25875: LD_VAR 0 6
25879: INC
25880: ST_TO_ADDR
25881: LD_INT 4
25883: PUSH
25884: FOR_DOWNTO
25885: IFFALSE 25911
// eng := eng diff eng [ i ] ;
25887: LD_ADDR_VAR 0 6
25891: PUSH
25892: LD_VAR 0 6
25896: PUSH
25897: LD_VAR 0 6
25901: PUSH
25902: LD_VAR 0 3
25906: ARRAY
25907: DIFF
25908: ST_TO_ADDR
25909: GO 25884
25911: POP
25912: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25913: LD_ADDR_VAR 0 4
25917: PUSH
25918: LD_VAR 0 4
25922: PUSH
25923: LD_VAR 0 5
25927: PUSH
25928: LD_VAR 0 6
25932: UNION
25933: PUSH
25934: LD_VAR 0 7
25938: UNION
25939: PUSH
25940: LD_VAR 0 8
25944: UNION
25945: DIFF
25946: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25947: LD_ADDR_VAR 0 13
25951: PUSH
25952: LD_EXP 87
25956: PUSH
25957: LD_VAR 0 1
25961: ARRAY
25962: PPUSH
25963: LD_INT 2
25965: PUSH
25966: LD_INT 30
25968: PUSH
25969: LD_INT 32
25971: PUSH
25972: EMPTY
25973: LIST
25974: LIST
25975: PUSH
25976: LD_INT 30
25978: PUSH
25979: LD_INT 31
25981: PUSH
25982: EMPTY
25983: LIST
25984: LIST
25985: PUSH
25986: EMPTY
25987: LIST
25988: LIST
25989: LIST
25990: PPUSH
25991: CALL_OW 72
25995: PUSH
25996: LD_EXP 87
26000: PUSH
26001: LD_VAR 0 1
26005: ARRAY
26006: PPUSH
26007: LD_INT 2
26009: PUSH
26010: LD_INT 30
26012: PUSH
26013: LD_INT 4
26015: PUSH
26016: EMPTY
26017: LIST
26018: LIST
26019: PUSH
26020: LD_INT 30
26022: PUSH
26023: LD_INT 5
26025: PUSH
26026: EMPTY
26027: LIST
26028: LIST
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: LIST
26034: PPUSH
26035: CALL_OW 72
26039: PUSH
26040: LD_INT 6
26042: MUL
26043: PLUS
26044: ST_TO_ADDR
// if bcount < tmp then
26045: LD_VAR 0 13
26049: PUSH
26050: LD_VAR 0 4
26054: LESS
26055: IFFALSE 26101
// for i = tmp downto bcount do
26057: LD_ADDR_VAR 0 3
26061: PUSH
26062: DOUBLE
26063: LD_VAR 0 4
26067: INC
26068: ST_TO_ADDR
26069: LD_VAR 0 13
26073: PUSH
26074: FOR_DOWNTO
26075: IFFALSE 26099
// tmp := Delete ( tmp , tmp ) ;
26077: LD_ADDR_VAR 0 4
26081: PUSH
26082: LD_VAR 0 4
26086: PPUSH
26087: LD_VAR 0 4
26091: PPUSH
26092: CALL_OW 3
26096: ST_TO_ADDR
26097: GO 26074
26099: POP
26100: POP
// result := [ tmp , 0 , 0 , p ] ;
26101: LD_ADDR_VAR 0 2
26105: PUSH
26106: LD_VAR 0 4
26110: PUSH
26111: LD_INT 0
26113: PUSH
26114: LD_INT 0
26116: PUSH
26117: LD_VAR 0 11
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: LIST
26126: LIST
26127: ST_TO_ADDR
// exit ;
26128: GO 28818
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26130: LD_EXP 87
26134: PUSH
26135: LD_VAR 0 1
26139: ARRAY
26140: PPUSH
26141: LD_INT 2
26143: PUSH
26144: LD_INT 30
26146: PUSH
26147: LD_INT 6
26149: PUSH
26150: EMPTY
26151: LIST
26152: LIST
26153: PUSH
26154: LD_INT 30
26156: PUSH
26157: LD_INT 7
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: PUSH
26164: LD_INT 30
26166: PUSH
26167: LD_INT 8
26169: PUSH
26170: EMPTY
26171: LIST
26172: LIST
26173: PUSH
26174: EMPTY
26175: LIST
26176: LIST
26177: LIST
26178: LIST
26179: PPUSH
26180: CALL_OW 72
26184: NOT
26185: PUSH
26186: LD_EXP 87
26190: PUSH
26191: LD_VAR 0 1
26195: ARRAY
26196: PPUSH
26197: LD_INT 30
26199: PUSH
26200: LD_INT 3
26202: PUSH
26203: EMPTY
26204: LIST
26205: LIST
26206: PPUSH
26207: CALL_OW 72
26211: NOT
26212: AND
26213: IFFALSE 26285
// begin if eng = tmp then
26215: LD_VAR 0 6
26219: PUSH
26220: LD_VAR 0 4
26224: EQUAL
26225: IFFALSE 26229
// exit ;
26227: GO 28818
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26229: LD_ADDR_EXP 129
26233: PUSH
26234: LD_EXP 129
26238: PPUSH
26239: LD_VAR 0 1
26243: PPUSH
26244: LD_INT 1
26246: PPUSH
26247: CALL_OW 1
26251: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26252: LD_ADDR_VAR 0 2
26256: PUSH
26257: LD_INT 0
26259: PUSH
26260: LD_VAR 0 4
26264: PUSH
26265: LD_VAR 0 6
26269: DIFF
26270: PUSH
26271: LD_INT 0
26273: PUSH
26274: LD_INT 0
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: LIST
26281: LIST
26282: ST_TO_ADDR
// exit ;
26283: GO 28818
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26285: LD_EXP 114
26289: PUSH
26290: LD_EXP 113
26294: PUSH
26295: LD_VAR 0 1
26299: ARRAY
26300: ARRAY
26301: PUSH
26302: LD_EXP 87
26306: PUSH
26307: LD_VAR 0 1
26311: ARRAY
26312: PPUSH
26313: LD_INT 2
26315: PUSH
26316: LD_INT 30
26318: PUSH
26319: LD_INT 6
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: PUSH
26326: LD_INT 30
26328: PUSH
26329: LD_INT 7
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 30
26338: PUSH
26339: LD_INT 8
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: LIST
26350: LIST
26351: PPUSH
26352: CALL_OW 72
26356: AND
26357: PUSH
26358: LD_EXP 87
26362: PUSH
26363: LD_VAR 0 1
26367: ARRAY
26368: PPUSH
26369: LD_INT 30
26371: PUSH
26372: LD_INT 3
26374: PUSH
26375: EMPTY
26376: LIST
26377: LIST
26378: PPUSH
26379: CALL_OW 72
26383: NOT
26384: AND
26385: IFFALSE 26599
// begin if sci >= 6 then
26387: LD_VAR 0 8
26391: PUSH
26392: LD_INT 6
26394: GREATEREQUAL
26395: IFFALSE 26399
// exit ;
26397: GO 28818
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26399: LD_ADDR_EXP 129
26403: PUSH
26404: LD_EXP 129
26408: PPUSH
26409: LD_VAR 0 1
26413: PPUSH
26414: LD_INT 2
26416: PPUSH
26417: CALL_OW 1
26421: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26422: LD_ADDR_VAR 0 9
26426: PUSH
26427: LD_VAR 0 4
26431: PUSH
26432: LD_VAR 0 8
26436: DIFF
26437: PPUSH
26438: LD_INT 4
26440: PPUSH
26441: CALL 85096 0 2
26445: ST_TO_ADDR
// p := [ ] ;
26446: LD_ADDR_VAR 0 11
26450: PUSH
26451: EMPTY
26452: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26453: LD_VAR 0 8
26457: PUSH
26458: LD_INT 6
26460: LESS
26461: PUSH
26462: LD_VAR 0 9
26466: PUSH
26467: LD_INT 6
26469: GREATER
26470: AND
26471: IFFALSE 26552
// begin for i = 1 to 6 - sci do
26473: LD_ADDR_VAR 0 3
26477: PUSH
26478: DOUBLE
26479: LD_INT 1
26481: DEC
26482: ST_TO_ADDR
26483: LD_INT 6
26485: PUSH
26486: LD_VAR 0 8
26490: MINUS
26491: PUSH
26492: FOR_TO
26493: IFFALSE 26548
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26495: LD_ADDR_VAR 0 11
26499: PUSH
26500: LD_VAR 0 11
26504: PPUSH
26505: LD_VAR 0 11
26509: PUSH
26510: LD_INT 1
26512: PLUS
26513: PPUSH
26514: LD_VAR 0 9
26518: PUSH
26519: LD_INT 1
26521: ARRAY
26522: PPUSH
26523: CALL_OW 2
26527: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26528: LD_ADDR_VAR 0 9
26532: PUSH
26533: LD_VAR 0 9
26537: PPUSH
26538: LD_INT 1
26540: PPUSH
26541: CALL_OW 3
26545: ST_TO_ADDR
// end ;
26546: GO 26492
26548: POP
26549: POP
// end else
26550: GO 26572
// if sort then
26552: LD_VAR 0 9
26556: IFFALSE 26572
// p := sort [ 1 ] ;
26558: LD_ADDR_VAR 0 11
26562: PUSH
26563: LD_VAR 0 9
26567: PUSH
26568: LD_INT 1
26570: ARRAY
26571: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26572: LD_ADDR_VAR 0 2
26576: PUSH
26577: LD_INT 0
26579: PUSH
26580: LD_INT 0
26582: PUSH
26583: LD_INT 0
26585: PUSH
26586: LD_VAR 0 11
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: LIST
26595: LIST
26596: ST_TO_ADDR
// exit ;
26597: GO 28818
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26599: LD_EXP 114
26603: PUSH
26604: LD_EXP 113
26608: PUSH
26609: LD_VAR 0 1
26613: ARRAY
26614: ARRAY
26615: PUSH
26616: LD_EXP 87
26620: PUSH
26621: LD_VAR 0 1
26625: ARRAY
26626: PPUSH
26627: LD_INT 2
26629: PUSH
26630: LD_INT 30
26632: PUSH
26633: LD_INT 6
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: PUSH
26640: LD_INT 30
26642: PUSH
26643: LD_INT 7
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 30
26652: PUSH
26653: LD_INT 8
26655: PUSH
26656: EMPTY
26657: LIST
26658: LIST
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: PPUSH
26666: CALL_OW 72
26670: AND
26671: PUSH
26672: LD_EXP 87
26676: PUSH
26677: LD_VAR 0 1
26681: ARRAY
26682: PPUSH
26683: LD_INT 30
26685: PUSH
26686: LD_INT 3
26688: PUSH
26689: EMPTY
26690: LIST
26691: LIST
26692: PPUSH
26693: CALL_OW 72
26697: AND
26698: IFFALSE 27432
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26700: LD_ADDR_EXP 129
26704: PUSH
26705: LD_EXP 129
26709: PPUSH
26710: LD_VAR 0 1
26714: PPUSH
26715: LD_INT 3
26717: PPUSH
26718: CALL_OW 1
26722: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26723: LD_ADDR_VAR 0 2
26727: PUSH
26728: LD_INT 0
26730: PUSH
26731: LD_INT 0
26733: PUSH
26734: LD_INT 0
26736: PUSH
26737: LD_INT 0
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: LIST
26744: LIST
26745: ST_TO_ADDR
// if not eng then
26746: LD_VAR 0 6
26750: NOT
26751: IFFALSE 26814
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26753: LD_ADDR_VAR 0 11
26757: PUSH
26758: LD_VAR 0 4
26762: PPUSH
26763: LD_INT 2
26765: PPUSH
26766: CALL 85096 0 2
26770: PUSH
26771: LD_INT 1
26773: ARRAY
26774: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26775: LD_ADDR_VAR 0 2
26779: PUSH
26780: LD_VAR 0 2
26784: PPUSH
26785: LD_INT 2
26787: PPUSH
26788: LD_VAR 0 11
26792: PPUSH
26793: CALL_OW 1
26797: ST_TO_ADDR
// tmp := tmp diff p ;
26798: LD_ADDR_VAR 0 4
26802: PUSH
26803: LD_VAR 0 4
26807: PUSH
26808: LD_VAR 0 11
26812: DIFF
26813: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26814: LD_VAR 0 4
26818: PUSH
26819: LD_VAR 0 8
26823: PUSH
26824: LD_INT 6
26826: LESS
26827: AND
26828: IFFALSE 27016
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26830: LD_ADDR_VAR 0 9
26834: PUSH
26835: LD_VAR 0 4
26839: PUSH
26840: LD_VAR 0 8
26844: PUSH
26845: LD_VAR 0 7
26849: UNION
26850: DIFF
26851: PPUSH
26852: LD_INT 4
26854: PPUSH
26855: CALL 85096 0 2
26859: ST_TO_ADDR
// p := [ ] ;
26860: LD_ADDR_VAR 0 11
26864: PUSH
26865: EMPTY
26866: ST_TO_ADDR
// if sort then
26867: LD_VAR 0 9
26871: IFFALSE 26987
// for i = 1 to 6 - sci do
26873: LD_ADDR_VAR 0 3
26877: PUSH
26878: DOUBLE
26879: LD_INT 1
26881: DEC
26882: ST_TO_ADDR
26883: LD_INT 6
26885: PUSH
26886: LD_VAR 0 8
26890: MINUS
26891: PUSH
26892: FOR_TO
26893: IFFALSE 26985
// begin if i = sort then
26895: LD_VAR 0 3
26899: PUSH
26900: LD_VAR 0 9
26904: EQUAL
26905: IFFALSE 26909
// break ;
26907: GO 26985
// if GetClass ( i ) = 4 then
26909: LD_VAR 0 3
26913: PPUSH
26914: CALL_OW 257
26918: PUSH
26919: LD_INT 4
26921: EQUAL
26922: IFFALSE 26926
// continue ;
26924: GO 26892
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26926: LD_ADDR_VAR 0 11
26930: PUSH
26931: LD_VAR 0 11
26935: PPUSH
26936: LD_VAR 0 11
26940: PUSH
26941: LD_INT 1
26943: PLUS
26944: PPUSH
26945: LD_VAR 0 9
26949: PUSH
26950: LD_VAR 0 3
26954: ARRAY
26955: PPUSH
26956: CALL_OW 2
26960: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26961: LD_ADDR_VAR 0 4
26965: PUSH
26966: LD_VAR 0 4
26970: PUSH
26971: LD_VAR 0 9
26975: PUSH
26976: LD_VAR 0 3
26980: ARRAY
26981: DIFF
26982: ST_TO_ADDR
// end ;
26983: GO 26892
26985: POP
26986: POP
// if p then
26987: LD_VAR 0 11
26991: IFFALSE 27016
// result := Replace ( result , 4 , p ) ;
26993: LD_ADDR_VAR 0 2
26997: PUSH
26998: LD_VAR 0 2
27002: PPUSH
27003: LD_INT 4
27005: PPUSH
27006: LD_VAR 0 11
27010: PPUSH
27011: CALL_OW 1
27015: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27016: LD_VAR 0 4
27020: PUSH
27021: LD_VAR 0 7
27025: PUSH
27026: LD_INT 6
27028: LESS
27029: AND
27030: IFFALSE 27218
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27032: LD_ADDR_VAR 0 9
27036: PUSH
27037: LD_VAR 0 4
27041: PUSH
27042: LD_VAR 0 8
27046: PUSH
27047: LD_VAR 0 7
27051: UNION
27052: DIFF
27053: PPUSH
27054: LD_INT 3
27056: PPUSH
27057: CALL 85096 0 2
27061: ST_TO_ADDR
// p := [ ] ;
27062: LD_ADDR_VAR 0 11
27066: PUSH
27067: EMPTY
27068: ST_TO_ADDR
// if sort then
27069: LD_VAR 0 9
27073: IFFALSE 27189
// for i = 1 to 6 - mech do
27075: LD_ADDR_VAR 0 3
27079: PUSH
27080: DOUBLE
27081: LD_INT 1
27083: DEC
27084: ST_TO_ADDR
27085: LD_INT 6
27087: PUSH
27088: LD_VAR 0 7
27092: MINUS
27093: PUSH
27094: FOR_TO
27095: IFFALSE 27187
// begin if i = sort then
27097: LD_VAR 0 3
27101: PUSH
27102: LD_VAR 0 9
27106: EQUAL
27107: IFFALSE 27111
// break ;
27109: GO 27187
// if GetClass ( i ) = 3 then
27111: LD_VAR 0 3
27115: PPUSH
27116: CALL_OW 257
27120: PUSH
27121: LD_INT 3
27123: EQUAL
27124: IFFALSE 27128
// continue ;
27126: GO 27094
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27128: LD_ADDR_VAR 0 11
27132: PUSH
27133: LD_VAR 0 11
27137: PPUSH
27138: LD_VAR 0 11
27142: PUSH
27143: LD_INT 1
27145: PLUS
27146: PPUSH
27147: LD_VAR 0 9
27151: PUSH
27152: LD_VAR 0 3
27156: ARRAY
27157: PPUSH
27158: CALL_OW 2
27162: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27163: LD_ADDR_VAR 0 4
27167: PUSH
27168: LD_VAR 0 4
27172: PUSH
27173: LD_VAR 0 9
27177: PUSH
27178: LD_VAR 0 3
27182: ARRAY
27183: DIFF
27184: ST_TO_ADDR
// end ;
27185: GO 27094
27187: POP
27188: POP
// if p then
27189: LD_VAR 0 11
27193: IFFALSE 27218
// result := Replace ( result , 3 , p ) ;
27195: LD_ADDR_VAR 0 2
27199: PUSH
27200: LD_VAR 0 2
27204: PPUSH
27205: LD_INT 3
27207: PPUSH
27208: LD_VAR 0 11
27212: PPUSH
27213: CALL_OW 1
27217: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27218: LD_VAR 0 4
27222: PUSH
27223: LD_INT 6
27225: GREATER
27226: PUSH
27227: LD_VAR 0 6
27231: PUSH
27232: LD_INT 6
27234: LESS
27235: AND
27236: IFFALSE 27430
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27238: LD_ADDR_VAR 0 9
27242: PUSH
27243: LD_VAR 0 4
27247: PUSH
27248: LD_VAR 0 8
27252: PUSH
27253: LD_VAR 0 7
27257: UNION
27258: PUSH
27259: LD_VAR 0 6
27263: UNION
27264: DIFF
27265: PPUSH
27266: LD_INT 2
27268: PPUSH
27269: CALL 85096 0 2
27273: ST_TO_ADDR
// p := [ ] ;
27274: LD_ADDR_VAR 0 11
27278: PUSH
27279: EMPTY
27280: ST_TO_ADDR
// if sort then
27281: LD_VAR 0 9
27285: IFFALSE 27401
// for i = 1 to 6 - eng do
27287: LD_ADDR_VAR 0 3
27291: PUSH
27292: DOUBLE
27293: LD_INT 1
27295: DEC
27296: ST_TO_ADDR
27297: LD_INT 6
27299: PUSH
27300: LD_VAR 0 6
27304: MINUS
27305: PUSH
27306: FOR_TO
27307: IFFALSE 27399
// begin if i = sort then
27309: LD_VAR 0 3
27313: PUSH
27314: LD_VAR 0 9
27318: EQUAL
27319: IFFALSE 27323
// break ;
27321: GO 27399
// if GetClass ( i ) = 2 then
27323: LD_VAR 0 3
27327: PPUSH
27328: CALL_OW 257
27332: PUSH
27333: LD_INT 2
27335: EQUAL
27336: IFFALSE 27340
// continue ;
27338: GO 27306
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27340: LD_ADDR_VAR 0 11
27344: PUSH
27345: LD_VAR 0 11
27349: PPUSH
27350: LD_VAR 0 11
27354: PUSH
27355: LD_INT 1
27357: PLUS
27358: PPUSH
27359: LD_VAR 0 9
27363: PUSH
27364: LD_VAR 0 3
27368: ARRAY
27369: PPUSH
27370: CALL_OW 2
27374: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27375: LD_ADDR_VAR 0 4
27379: PUSH
27380: LD_VAR 0 4
27384: PUSH
27385: LD_VAR 0 9
27389: PUSH
27390: LD_VAR 0 3
27394: ARRAY
27395: DIFF
27396: ST_TO_ADDR
// end ;
27397: GO 27306
27399: POP
27400: POP
// if p then
27401: LD_VAR 0 11
27405: IFFALSE 27430
// result := Replace ( result , 2 , p ) ;
27407: LD_ADDR_VAR 0 2
27411: PUSH
27412: LD_VAR 0 2
27416: PPUSH
27417: LD_INT 2
27419: PPUSH
27420: LD_VAR 0 11
27424: PPUSH
27425: CALL_OW 1
27429: ST_TO_ADDR
// end ; exit ;
27430: GO 28818
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27432: LD_EXP 114
27436: PUSH
27437: LD_EXP 113
27441: PUSH
27442: LD_VAR 0 1
27446: ARRAY
27447: ARRAY
27448: NOT
27449: PUSH
27450: LD_EXP 87
27454: PUSH
27455: LD_VAR 0 1
27459: ARRAY
27460: PPUSH
27461: LD_INT 30
27463: PUSH
27464: LD_INT 3
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: PPUSH
27471: CALL_OW 72
27475: AND
27476: PUSH
27477: LD_EXP 92
27481: PUSH
27482: LD_VAR 0 1
27486: ARRAY
27487: AND
27488: IFFALSE 28096
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27490: LD_ADDR_EXP 129
27494: PUSH
27495: LD_EXP 129
27499: PPUSH
27500: LD_VAR 0 1
27504: PPUSH
27505: LD_INT 5
27507: PPUSH
27508: CALL_OW 1
27512: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27513: LD_ADDR_VAR 0 2
27517: PUSH
27518: LD_INT 0
27520: PUSH
27521: LD_INT 0
27523: PUSH
27524: LD_INT 0
27526: PUSH
27527: LD_INT 0
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: LIST
27534: LIST
27535: ST_TO_ADDR
// if sci > 1 then
27536: LD_VAR 0 8
27540: PUSH
27541: LD_INT 1
27543: GREATER
27544: IFFALSE 27572
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27546: LD_ADDR_VAR 0 4
27550: PUSH
27551: LD_VAR 0 4
27555: PUSH
27556: LD_VAR 0 8
27560: PUSH
27561: LD_VAR 0 8
27565: PUSH
27566: LD_INT 1
27568: ARRAY
27569: DIFF
27570: DIFF
27571: ST_TO_ADDR
// if tmp and not sci then
27572: LD_VAR 0 4
27576: PUSH
27577: LD_VAR 0 8
27581: NOT
27582: AND
27583: IFFALSE 27652
// begin sort := SortBySkill ( tmp , 4 ) ;
27585: LD_ADDR_VAR 0 9
27589: PUSH
27590: LD_VAR 0 4
27594: PPUSH
27595: LD_INT 4
27597: PPUSH
27598: CALL 85096 0 2
27602: ST_TO_ADDR
// if sort then
27603: LD_VAR 0 9
27607: IFFALSE 27623
// p := sort [ 1 ] ;
27609: LD_ADDR_VAR 0 11
27613: PUSH
27614: LD_VAR 0 9
27618: PUSH
27619: LD_INT 1
27621: ARRAY
27622: ST_TO_ADDR
// if p then
27623: LD_VAR 0 11
27627: IFFALSE 27652
// result := Replace ( result , 4 , p ) ;
27629: LD_ADDR_VAR 0 2
27633: PUSH
27634: LD_VAR 0 2
27638: PPUSH
27639: LD_INT 4
27641: PPUSH
27642: LD_VAR 0 11
27646: PPUSH
27647: CALL_OW 1
27651: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27652: LD_ADDR_VAR 0 4
27656: PUSH
27657: LD_VAR 0 4
27661: PUSH
27662: LD_VAR 0 7
27666: DIFF
27667: ST_TO_ADDR
// if tmp and mech < 6 then
27668: LD_VAR 0 4
27672: PUSH
27673: LD_VAR 0 7
27677: PUSH
27678: LD_INT 6
27680: LESS
27681: AND
27682: IFFALSE 27870
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27684: LD_ADDR_VAR 0 9
27688: PUSH
27689: LD_VAR 0 4
27693: PUSH
27694: LD_VAR 0 8
27698: PUSH
27699: LD_VAR 0 7
27703: UNION
27704: DIFF
27705: PPUSH
27706: LD_INT 3
27708: PPUSH
27709: CALL 85096 0 2
27713: ST_TO_ADDR
// p := [ ] ;
27714: LD_ADDR_VAR 0 11
27718: PUSH
27719: EMPTY
27720: ST_TO_ADDR
// if sort then
27721: LD_VAR 0 9
27725: IFFALSE 27841
// for i = 1 to 6 - mech do
27727: LD_ADDR_VAR 0 3
27731: PUSH
27732: DOUBLE
27733: LD_INT 1
27735: DEC
27736: ST_TO_ADDR
27737: LD_INT 6
27739: PUSH
27740: LD_VAR 0 7
27744: MINUS
27745: PUSH
27746: FOR_TO
27747: IFFALSE 27839
// begin if i = sort then
27749: LD_VAR 0 3
27753: PUSH
27754: LD_VAR 0 9
27758: EQUAL
27759: IFFALSE 27763
// break ;
27761: GO 27839
// if GetClass ( i ) = 3 then
27763: LD_VAR 0 3
27767: PPUSH
27768: CALL_OW 257
27772: PUSH
27773: LD_INT 3
27775: EQUAL
27776: IFFALSE 27780
// continue ;
27778: GO 27746
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27780: LD_ADDR_VAR 0 11
27784: PUSH
27785: LD_VAR 0 11
27789: PPUSH
27790: LD_VAR 0 11
27794: PUSH
27795: LD_INT 1
27797: PLUS
27798: PPUSH
27799: LD_VAR 0 9
27803: PUSH
27804: LD_VAR 0 3
27808: ARRAY
27809: PPUSH
27810: CALL_OW 2
27814: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27815: LD_ADDR_VAR 0 4
27819: PUSH
27820: LD_VAR 0 4
27824: PUSH
27825: LD_VAR 0 9
27829: PUSH
27830: LD_VAR 0 3
27834: ARRAY
27835: DIFF
27836: ST_TO_ADDR
// end ;
27837: GO 27746
27839: POP
27840: POP
// if p then
27841: LD_VAR 0 11
27845: IFFALSE 27870
// result := Replace ( result , 3 , p ) ;
27847: LD_ADDR_VAR 0 2
27851: PUSH
27852: LD_VAR 0 2
27856: PPUSH
27857: LD_INT 3
27859: PPUSH
27860: LD_VAR 0 11
27864: PPUSH
27865: CALL_OW 1
27869: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27870: LD_ADDR_VAR 0 4
27874: PUSH
27875: LD_VAR 0 4
27879: PUSH
27880: LD_VAR 0 6
27884: DIFF
27885: ST_TO_ADDR
// if tmp and eng < 6 then
27886: LD_VAR 0 4
27890: PUSH
27891: LD_VAR 0 6
27895: PUSH
27896: LD_INT 6
27898: LESS
27899: AND
27900: IFFALSE 28094
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27902: LD_ADDR_VAR 0 9
27906: PUSH
27907: LD_VAR 0 4
27911: PUSH
27912: LD_VAR 0 8
27916: PUSH
27917: LD_VAR 0 7
27921: UNION
27922: PUSH
27923: LD_VAR 0 6
27927: UNION
27928: DIFF
27929: PPUSH
27930: LD_INT 2
27932: PPUSH
27933: CALL 85096 0 2
27937: ST_TO_ADDR
// p := [ ] ;
27938: LD_ADDR_VAR 0 11
27942: PUSH
27943: EMPTY
27944: ST_TO_ADDR
// if sort then
27945: LD_VAR 0 9
27949: IFFALSE 28065
// for i = 1 to 6 - eng do
27951: LD_ADDR_VAR 0 3
27955: PUSH
27956: DOUBLE
27957: LD_INT 1
27959: DEC
27960: ST_TO_ADDR
27961: LD_INT 6
27963: PUSH
27964: LD_VAR 0 6
27968: MINUS
27969: PUSH
27970: FOR_TO
27971: IFFALSE 28063
// begin if i = sort then
27973: LD_VAR 0 3
27977: PUSH
27978: LD_VAR 0 9
27982: EQUAL
27983: IFFALSE 27987
// break ;
27985: GO 28063
// if GetClass ( i ) = 2 then
27987: LD_VAR 0 3
27991: PPUSH
27992: CALL_OW 257
27996: PUSH
27997: LD_INT 2
27999: EQUAL
28000: IFFALSE 28004
// continue ;
28002: GO 27970
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28004: LD_ADDR_VAR 0 11
28008: PUSH
28009: LD_VAR 0 11
28013: PPUSH
28014: LD_VAR 0 11
28018: PUSH
28019: LD_INT 1
28021: PLUS
28022: PPUSH
28023: LD_VAR 0 9
28027: PUSH
28028: LD_VAR 0 3
28032: ARRAY
28033: PPUSH
28034: CALL_OW 2
28038: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28039: LD_ADDR_VAR 0 4
28043: PUSH
28044: LD_VAR 0 4
28048: PUSH
28049: LD_VAR 0 9
28053: PUSH
28054: LD_VAR 0 3
28058: ARRAY
28059: DIFF
28060: ST_TO_ADDR
// end ;
28061: GO 27970
28063: POP
28064: POP
// if p then
28065: LD_VAR 0 11
28069: IFFALSE 28094
// result := Replace ( result , 2 , p ) ;
28071: LD_ADDR_VAR 0 2
28075: PUSH
28076: LD_VAR 0 2
28080: PPUSH
28081: LD_INT 2
28083: PPUSH
28084: LD_VAR 0 11
28088: PPUSH
28089: CALL_OW 1
28093: ST_TO_ADDR
// end ; exit ;
28094: GO 28818
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28096: LD_EXP 114
28100: PUSH
28101: LD_EXP 113
28105: PUSH
28106: LD_VAR 0 1
28110: ARRAY
28111: ARRAY
28112: NOT
28113: PUSH
28114: LD_EXP 87
28118: PUSH
28119: LD_VAR 0 1
28123: ARRAY
28124: PPUSH
28125: LD_INT 30
28127: PUSH
28128: LD_INT 3
28130: PUSH
28131: EMPTY
28132: LIST
28133: LIST
28134: PPUSH
28135: CALL_OW 72
28139: AND
28140: PUSH
28141: LD_EXP 92
28145: PUSH
28146: LD_VAR 0 1
28150: ARRAY
28151: NOT
28152: AND
28153: IFFALSE 28818
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28155: LD_ADDR_EXP 129
28159: PUSH
28160: LD_EXP 129
28164: PPUSH
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 6
28172: PPUSH
28173: CALL_OW 1
28177: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28178: LD_ADDR_VAR 0 2
28182: PUSH
28183: LD_INT 0
28185: PUSH
28186: LD_INT 0
28188: PUSH
28189: LD_INT 0
28191: PUSH
28192: LD_INT 0
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: ST_TO_ADDR
// if sci >= 1 then
28201: LD_VAR 0 8
28205: PUSH
28206: LD_INT 1
28208: GREATEREQUAL
28209: IFFALSE 28231
// tmp := tmp diff sci [ 1 ] ;
28211: LD_ADDR_VAR 0 4
28215: PUSH
28216: LD_VAR 0 4
28220: PUSH
28221: LD_VAR 0 8
28225: PUSH
28226: LD_INT 1
28228: ARRAY
28229: DIFF
28230: ST_TO_ADDR
// if tmp and not sci then
28231: LD_VAR 0 4
28235: PUSH
28236: LD_VAR 0 8
28240: NOT
28241: AND
28242: IFFALSE 28311
// begin sort := SortBySkill ( tmp , 4 ) ;
28244: LD_ADDR_VAR 0 9
28248: PUSH
28249: LD_VAR 0 4
28253: PPUSH
28254: LD_INT 4
28256: PPUSH
28257: CALL 85096 0 2
28261: ST_TO_ADDR
// if sort then
28262: LD_VAR 0 9
28266: IFFALSE 28282
// p := sort [ 1 ] ;
28268: LD_ADDR_VAR 0 11
28272: PUSH
28273: LD_VAR 0 9
28277: PUSH
28278: LD_INT 1
28280: ARRAY
28281: ST_TO_ADDR
// if p then
28282: LD_VAR 0 11
28286: IFFALSE 28311
// result := Replace ( result , 4 , p ) ;
28288: LD_ADDR_VAR 0 2
28292: PUSH
28293: LD_VAR 0 2
28297: PPUSH
28298: LD_INT 4
28300: PPUSH
28301: LD_VAR 0 11
28305: PPUSH
28306: CALL_OW 1
28310: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28311: LD_ADDR_VAR 0 4
28315: PUSH
28316: LD_VAR 0 4
28320: PUSH
28321: LD_VAR 0 7
28325: DIFF
28326: ST_TO_ADDR
// if tmp and mech < 6 then
28327: LD_VAR 0 4
28331: PUSH
28332: LD_VAR 0 7
28336: PUSH
28337: LD_INT 6
28339: LESS
28340: AND
28341: IFFALSE 28523
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28343: LD_ADDR_VAR 0 9
28347: PUSH
28348: LD_VAR 0 4
28352: PUSH
28353: LD_VAR 0 7
28357: DIFF
28358: PPUSH
28359: LD_INT 3
28361: PPUSH
28362: CALL 85096 0 2
28366: ST_TO_ADDR
// p := [ ] ;
28367: LD_ADDR_VAR 0 11
28371: PUSH
28372: EMPTY
28373: ST_TO_ADDR
// if sort then
28374: LD_VAR 0 9
28378: IFFALSE 28494
// for i = 1 to 6 - mech do
28380: LD_ADDR_VAR 0 3
28384: PUSH
28385: DOUBLE
28386: LD_INT 1
28388: DEC
28389: ST_TO_ADDR
28390: LD_INT 6
28392: PUSH
28393: LD_VAR 0 7
28397: MINUS
28398: PUSH
28399: FOR_TO
28400: IFFALSE 28492
// begin if i = sort then
28402: LD_VAR 0 3
28406: PUSH
28407: LD_VAR 0 9
28411: EQUAL
28412: IFFALSE 28416
// break ;
28414: GO 28492
// if GetClass ( i ) = 3 then
28416: LD_VAR 0 3
28420: PPUSH
28421: CALL_OW 257
28425: PUSH
28426: LD_INT 3
28428: EQUAL
28429: IFFALSE 28433
// continue ;
28431: GO 28399
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28433: LD_ADDR_VAR 0 11
28437: PUSH
28438: LD_VAR 0 11
28442: PPUSH
28443: LD_VAR 0 11
28447: PUSH
28448: LD_INT 1
28450: PLUS
28451: PPUSH
28452: LD_VAR 0 9
28456: PUSH
28457: LD_VAR 0 3
28461: ARRAY
28462: PPUSH
28463: CALL_OW 2
28467: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28468: LD_ADDR_VAR 0 4
28472: PUSH
28473: LD_VAR 0 4
28477: PUSH
28478: LD_VAR 0 9
28482: PUSH
28483: LD_VAR 0 3
28487: ARRAY
28488: DIFF
28489: ST_TO_ADDR
// end ;
28490: GO 28399
28492: POP
28493: POP
// if p then
28494: LD_VAR 0 11
28498: IFFALSE 28523
// result := Replace ( result , 3 , p ) ;
28500: LD_ADDR_VAR 0 2
28504: PUSH
28505: LD_VAR 0 2
28509: PPUSH
28510: LD_INT 3
28512: PPUSH
28513: LD_VAR 0 11
28517: PPUSH
28518: CALL_OW 1
28522: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28523: LD_ADDR_VAR 0 4
28527: PUSH
28528: LD_VAR 0 4
28532: PUSH
28533: LD_VAR 0 6
28537: DIFF
28538: ST_TO_ADDR
// if tmp and eng < 4 then
28539: LD_VAR 0 4
28543: PUSH
28544: LD_VAR 0 6
28548: PUSH
28549: LD_INT 4
28551: LESS
28552: AND
28553: IFFALSE 28743
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28555: LD_ADDR_VAR 0 9
28559: PUSH
28560: LD_VAR 0 4
28564: PUSH
28565: LD_VAR 0 7
28569: PUSH
28570: LD_VAR 0 6
28574: UNION
28575: DIFF
28576: PPUSH
28577: LD_INT 2
28579: PPUSH
28580: CALL 85096 0 2
28584: ST_TO_ADDR
// p := [ ] ;
28585: LD_ADDR_VAR 0 11
28589: PUSH
28590: EMPTY
28591: ST_TO_ADDR
// if sort then
28592: LD_VAR 0 9
28596: IFFALSE 28712
// for i = 1 to 4 - eng do
28598: LD_ADDR_VAR 0 3
28602: PUSH
28603: DOUBLE
28604: LD_INT 1
28606: DEC
28607: ST_TO_ADDR
28608: LD_INT 4
28610: PUSH
28611: LD_VAR 0 6
28615: MINUS
28616: PUSH
28617: FOR_TO
28618: IFFALSE 28710
// begin if i = sort then
28620: LD_VAR 0 3
28624: PUSH
28625: LD_VAR 0 9
28629: EQUAL
28630: IFFALSE 28634
// break ;
28632: GO 28710
// if GetClass ( i ) = 2 then
28634: LD_VAR 0 3
28638: PPUSH
28639: CALL_OW 257
28643: PUSH
28644: LD_INT 2
28646: EQUAL
28647: IFFALSE 28651
// continue ;
28649: GO 28617
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28651: LD_ADDR_VAR 0 11
28655: PUSH
28656: LD_VAR 0 11
28660: PPUSH
28661: LD_VAR 0 11
28665: PUSH
28666: LD_INT 1
28668: PLUS
28669: PPUSH
28670: LD_VAR 0 9
28674: PUSH
28675: LD_VAR 0 3
28679: ARRAY
28680: PPUSH
28681: CALL_OW 2
28685: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28686: LD_ADDR_VAR 0 4
28690: PUSH
28691: LD_VAR 0 4
28695: PUSH
28696: LD_VAR 0 9
28700: PUSH
28701: LD_VAR 0 3
28705: ARRAY
28706: DIFF
28707: ST_TO_ADDR
// end ;
28708: GO 28617
28710: POP
28711: POP
// if p then
28712: LD_VAR 0 11
28716: IFFALSE 28741
// result := Replace ( result , 2 , p ) ;
28718: LD_ADDR_VAR 0 2
28722: PUSH
28723: LD_VAR 0 2
28727: PPUSH
28728: LD_INT 2
28730: PPUSH
28731: LD_VAR 0 11
28735: PPUSH
28736: CALL_OW 1
28740: ST_TO_ADDR
// end else
28741: GO 28787
// for i = eng downto 5 do
28743: LD_ADDR_VAR 0 3
28747: PUSH
28748: DOUBLE
28749: LD_VAR 0 6
28753: INC
28754: ST_TO_ADDR
28755: LD_INT 5
28757: PUSH
28758: FOR_DOWNTO
28759: IFFALSE 28785
// tmp := tmp union eng [ i ] ;
28761: LD_ADDR_VAR 0 4
28765: PUSH
28766: LD_VAR 0 4
28770: PUSH
28771: LD_VAR 0 6
28775: PUSH
28776: LD_VAR 0 3
28780: ARRAY
28781: UNION
28782: ST_TO_ADDR
28783: GO 28758
28785: POP
28786: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28787: LD_ADDR_VAR 0 2
28791: PUSH
28792: LD_VAR 0 2
28796: PPUSH
28797: LD_INT 1
28799: PPUSH
28800: LD_VAR 0 4
28804: PUSH
28805: LD_VAR 0 5
28809: DIFF
28810: PPUSH
28811: CALL_OW 1
28815: ST_TO_ADDR
// exit ;
28816: GO 28818
// end ; end ;
28818: LD_VAR 0 2
28822: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28823: LD_INT 0
28825: PPUSH
28826: PPUSH
28827: PPUSH
// if not mc_bases then
28828: LD_EXP 87
28832: NOT
28833: IFFALSE 28837
// exit ;
28835: GO 28943
// for i = 1 to mc_bases do
28837: LD_ADDR_VAR 0 2
28841: PUSH
28842: DOUBLE
28843: LD_INT 1
28845: DEC
28846: ST_TO_ADDR
28847: LD_EXP 87
28851: PUSH
28852: FOR_TO
28853: IFFALSE 28934
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28855: LD_ADDR_VAR 0 3
28859: PUSH
28860: LD_EXP 87
28864: PUSH
28865: LD_VAR 0 2
28869: ARRAY
28870: PPUSH
28871: LD_INT 21
28873: PUSH
28874: LD_INT 3
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 3
28883: PUSH
28884: LD_INT 24
28886: PUSH
28887: LD_INT 1000
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PPUSH
28902: CALL_OW 72
28906: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28907: LD_ADDR_EXP 88
28911: PUSH
28912: LD_EXP 88
28916: PPUSH
28917: LD_VAR 0 2
28921: PPUSH
28922: LD_VAR 0 3
28926: PPUSH
28927: CALL_OW 1
28931: ST_TO_ADDR
// end ;
28932: GO 28852
28934: POP
28935: POP
// RaiseSailEvent ( 101 ) ;
28936: LD_INT 101
28938: PPUSH
28939: CALL_OW 427
// end ;
28943: LD_VAR 0 1
28947: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28948: LD_INT 0
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
28954: PPUSH
28955: PPUSH
28956: PPUSH
// if not mc_bases then
28957: LD_EXP 87
28961: NOT
28962: IFFALSE 28966
// exit ;
28964: GO 29528
// for i = 1 to mc_bases do
28966: LD_ADDR_VAR 0 2
28970: PUSH
28971: DOUBLE
28972: LD_INT 1
28974: DEC
28975: ST_TO_ADDR
28976: LD_EXP 87
28980: PUSH
28981: FOR_TO
28982: IFFALSE 29519
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28984: LD_ADDR_VAR 0 5
28988: PUSH
28989: LD_EXP 87
28993: PUSH
28994: LD_VAR 0 2
28998: ARRAY
28999: PUSH
29000: LD_EXP 116
29004: PUSH
29005: LD_VAR 0 2
29009: ARRAY
29010: UNION
29011: PPUSH
29012: LD_INT 21
29014: PUSH
29015: LD_INT 1
29017: PUSH
29018: EMPTY
29019: LIST
29020: LIST
29021: PUSH
29022: LD_INT 1
29024: PUSH
29025: LD_INT 3
29027: PUSH
29028: LD_INT 54
29030: PUSH
29031: EMPTY
29032: LIST
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: LD_INT 3
29040: PUSH
29041: LD_INT 24
29043: PUSH
29044: LD_INT 800
29046: PUSH
29047: EMPTY
29048: LIST
29049: LIST
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: LIST
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PPUSH
29064: CALL_OW 72
29068: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29069: LD_ADDR_VAR 0 6
29073: PUSH
29074: LD_EXP 87
29078: PUSH
29079: LD_VAR 0 2
29083: ARRAY
29084: PPUSH
29085: LD_INT 21
29087: PUSH
29088: LD_INT 1
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: LD_INT 3
29100: PUSH
29101: LD_INT 54
29103: PUSH
29104: EMPTY
29105: LIST
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 3
29113: PUSH
29114: LD_INT 24
29116: PUSH
29117: LD_INT 250
29119: PUSH
29120: EMPTY
29121: LIST
29122: LIST
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: LIST
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PPUSH
29137: CALL_OW 72
29141: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29142: LD_ADDR_VAR 0 7
29146: PUSH
29147: LD_VAR 0 5
29151: PUSH
29152: LD_VAR 0 6
29156: DIFF
29157: ST_TO_ADDR
// if not need_heal_1 then
29158: LD_VAR 0 6
29162: NOT
29163: IFFALSE 29196
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29165: LD_ADDR_EXP 90
29169: PUSH
29170: LD_EXP 90
29174: PPUSH
29175: LD_VAR 0 2
29179: PUSH
29180: LD_INT 1
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PPUSH
29187: EMPTY
29188: PPUSH
29189: CALL 55547 0 3
29193: ST_TO_ADDR
29194: GO 29266
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29196: LD_ADDR_EXP 90
29200: PUSH
29201: LD_EXP 90
29205: PPUSH
29206: LD_VAR 0 2
29210: PUSH
29211: LD_INT 1
29213: PUSH
29214: EMPTY
29215: LIST
29216: LIST
29217: PPUSH
29218: LD_EXP 90
29222: PUSH
29223: LD_VAR 0 2
29227: ARRAY
29228: PUSH
29229: LD_INT 1
29231: ARRAY
29232: PPUSH
29233: LD_INT 3
29235: PUSH
29236: LD_INT 24
29238: PUSH
29239: LD_INT 1000
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PPUSH
29250: CALL_OW 72
29254: PUSH
29255: LD_VAR 0 6
29259: UNION
29260: PPUSH
29261: CALL 55547 0 3
29265: ST_TO_ADDR
// if not need_heal_2 then
29266: LD_VAR 0 7
29270: NOT
29271: IFFALSE 29304
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29273: LD_ADDR_EXP 90
29277: PUSH
29278: LD_EXP 90
29282: PPUSH
29283: LD_VAR 0 2
29287: PUSH
29288: LD_INT 2
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PPUSH
29295: EMPTY
29296: PPUSH
29297: CALL 55547 0 3
29301: ST_TO_ADDR
29302: GO 29336
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29304: LD_ADDR_EXP 90
29308: PUSH
29309: LD_EXP 90
29313: PPUSH
29314: LD_VAR 0 2
29318: PUSH
29319: LD_INT 2
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PPUSH
29326: LD_VAR 0 7
29330: PPUSH
29331: CALL 55547 0 3
29335: ST_TO_ADDR
// if need_heal_2 then
29336: LD_VAR 0 7
29340: IFFALSE 29501
// for j in need_heal_2 do
29342: LD_ADDR_VAR 0 3
29346: PUSH
29347: LD_VAR 0 7
29351: PUSH
29352: FOR_IN
29353: IFFALSE 29499
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29355: LD_ADDR_VAR 0 5
29359: PUSH
29360: LD_EXP 87
29364: PUSH
29365: LD_VAR 0 2
29369: ARRAY
29370: PPUSH
29371: LD_INT 2
29373: PUSH
29374: LD_INT 30
29376: PUSH
29377: LD_INT 6
29379: PUSH
29380: EMPTY
29381: LIST
29382: LIST
29383: PUSH
29384: LD_INT 30
29386: PUSH
29387: LD_INT 7
29389: PUSH
29390: EMPTY
29391: LIST
29392: LIST
29393: PUSH
29394: LD_INT 30
29396: PUSH
29397: LD_INT 8
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 30
29406: PUSH
29407: LD_INT 0
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: LD_INT 30
29416: PUSH
29417: LD_INT 1
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: LIST
29428: LIST
29429: LIST
29430: LIST
29431: PPUSH
29432: CALL_OW 72
29436: ST_TO_ADDR
// if tmp then
29437: LD_VAR 0 5
29441: IFFALSE 29497
// begin k := NearestUnitToUnit ( tmp , j ) ;
29443: LD_ADDR_VAR 0 4
29447: PUSH
29448: LD_VAR 0 5
29452: PPUSH
29453: LD_VAR 0 3
29457: PPUSH
29458: CALL_OW 74
29462: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29463: LD_VAR 0 3
29467: PPUSH
29468: LD_VAR 0 4
29472: PPUSH
29473: CALL_OW 296
29477: PUSH
29478: LD_INT 5
29480: GREATER
29481: IFFALSE 29497
// ComMoveUnit ( j , k ) ;
29483: LD_VAR 0 3
29487: PPUSH
29488: LD_VAR 0 4
29492: PPUSH
29493: CALL_OW 112
// end ; end ;
29497: GO 29352
29499: POP
29500: POP
// if not need_heal_1 and not need_heal_2 then
29501: LD_VAR 0 6
29505: NOT
29506: PUSH
29507: LD_VAR 0 7
29511: NOT
29512: AND
29513: IFFALSE 29517
// continue ;
29515: GO 28981
// end ;
29517: GO 28981
29519: POP
29520: POP
// RaiseSailEvent ( 102 ) ;
29521: LD_INT 102
29523: PPUSH
29524: CALL_OW 427
// end ;
29528: LD_VAR 0 1
29532: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29533: LD_INT 0
29535: PPUSH
29536: PPUSH
29537: PPUSH
29538: PPUSH
29539: PPUSH
29540: PPUSH
29541: PPUSH
29542: PPUSH
// if not mc_bases then
29543: LD_EXP 87
29547: NOT
29548: IFFALSE 29552
// exit ;
29550: GO 30387
// for i = 1 to mc_bases do
29552: LD_ADDR_VAR 0 2
29556: PUSH
29557: DOUBLE
29558: LD_INT 1
29560: DEC
29561: ST_TO_ADDR
29562: LD_EXP 87
29566: PUSH
29567: FOR_TO
29568: IFFALSE 30385
// begin if not mc_building_need_repair [ i ] then
29570: LD_EXP 88
29574: PUSH
29575: LD_VAR 0 2
29579: ARRAY
29580: NOT
29581: IFFALSE 29755
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29583: LD_ADDR_VAR 0 6
29587: PUSH
29588: LD_EXP 106
29592: PUSH
29593: LD_VAR 0 2
29597: ARRAY
29598: PPUSH
29599: LD_INT 3
29601: PUSH
29602: LD_INT 24
29604: PUSH
29605: LD_INT 1000
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 2
29618: PUSH
29619: LD_INT 34
29621: PUSH
29622: LD_INT 13
29624: PUSH
29625: EMPTY
29626: LIST
29627: LIST
29628: PUSH
29629: LD_INT 34
29631: PUSH
29632: LD_INT 52
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: LIST
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PPUSH
29648: CALL_OW 72
29652: ST_TO_ADDR
// if cranes then
29653: LD_VAR 0 6
29657: IFFALSE 29719
// for j in cranes do
29659: LD_ADDR_VAR 0 3
29663: PUSH
29664: LD_VAR 0 6
29668: PUSH
29669: FOR_IN
29670: IFFALSE 29717
// if not IsInArea ( j , mc_parking [ i ] ) then
29672: LD_VAR 0 3
29676: PPUSH
29677: LD_EXP 111
29681: PUSH
29682: LD_VAR 0 2
29686: ARRAY
29687: PPUSH
29688: CALL_OW 308
29692: NOT
29693: IFFALSE 29715
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29695: LD_VAR 0 3
29699: PPUSH
29700: LD_EXP 111
29704: PUSH
29705: LD_VAR 0 2
29709: ARRAY
29710: PPUSH
29711: CALL_OW 113
29715: GO 29669
29717: POP
29718: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29719: LD_ADDR_EXP 89
29723: PUSH
29724: LD_EXP 89
29728: PPUSH
29729: LD_VAR 0 2
29733: PPUSH
29734: EMPTY
29735: PPUSH
29736: CALL_OW 1
29740: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29741: LD_VAR 0 2
29745: PPUSH
29746: LD_INT 101
29748: PPUSH
29749: CALL 24656 0 2
// continue ;
29753: GO 29567
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29755: LD_ADDR_EXP 93
29759: PUSH
29760: LD_EXP 93
29764: PPUSH
29765: LD_VAR 0 2
29769: PPUSH
29770: EMPTY
29771: PPUSH
29772: CALL_OW 1
29776: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29777: LD_VAR 0 2
29781: PPUSH
29782: LD_INT 103
29784: PPUSH
29785: CALL 24656 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
29789: LD_ADDR_VAR 0 5
29793: PUSH
29794: LD_EXP 87
29798: PUSH
29799: LD_VAR 0 2
29803: ARRAY
29804: PUSH
29805: LD_EXP 116
29809: PUSH
29810: LD_VAR 0 2
29814: ARRAY
29815: UNION
29816: PPUSH
29817: LD_INT 2
29819: PUSH
29820: LD_INT 25
29822: PUSH
29823: LD_INT 2
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 25
29832: PUSH
29833: LD_INT 16
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: LIST
29844: PUSH
29845: EMPTY
29846: LIST
29847: PPUSH
29848: CALL_OW 72
29852: PUSH
29853: LD_EXP 90
29857: PUSH
29858: LD_VAR 0 2
29862: ARRAY
29863: PUSH
29864: LD_INT 1
29866: ARRAY
29867: PUSH
29868: LD_EXP 90
29872: PUSH
29873: LD_VAR 0 2
29877: ARRAY
29878: PUSH
29879: LD_INT 2
29881: ARRAY
29882: UNION
29883: DIFF
29884: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29885: LD_ADDR_VAR 0 6
29889: PUSH
29890: LD_EXP 106
29894: PUSH
29895: LD_VAR 0 2
29899: ARRAY
29900: PPUSH
29901: LD_INT 2
29903: PUSH
29904: LD_INT 34
29906: PUSH
29907: LD_INT 13
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 34
29916: PUSH
29917: LD_INT 52
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: LIST
29928: PPUSH
29929: CALL_OW 72
29933: ST_TO_ADDR
// if cranes then
29934: LD_VAR 0 6
29938: IFFALSE 30074
// begin for j in cranes do
29940: LD_ADDR_VAR 0 3
29944: PUSH
29945: LD_VAR 0 6
29949: PUSH
29950: FOR_IN
29951: IFFALSE 30072
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29953: LD_VAR 0 3
29957: PPUSH
29958: CALL_OW 256
29962: PUSH
29963: LD_INT 500
29965: GREATEREQUAL
29966: PUSH
29967: LD_VAR 0 3
29971: PPUSH
29972: CALL_OW 314
29976: NOT
29977: AND
29978: IFFALSE 30012
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29980: LD_VAR 0 3
29984: PPUSH
29985: LD_EXP 88
29989: PUSH
29990: LD_VAR 0 2
29994: ARRAY
29995: PPUSH
29996: LD_VAR 0 3
30000: PPUSH
30001: CALL_OW 74
30005: PPUSH
30006: CALL_OW 130
30010: GO 30070
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30012: LD_VAR 0 3
30016: PPUSH
30017: CALL_OW 256
30021: PUSH
30022: LD_INT 500
30024: LESS
30025: PUSH
30026: LD_VAR 0 3
30030: PPUSH
30031: LD_EXP 111
30035: PUSH
30036: LD_VAR 0 2
30040: ARRAY
30041: PPUSH
30042: CALL_OW 308
30046: NOT
30047: AND
30048: IFFALSE 30070
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30050: LD_VAR 0 3
30054: PPUSH
30055: LD_EXP 111
30059: PUSH
30060: LD_VAR 0 2
30064: ARRAY
30065: PPUSH
30066: CALL_OW 113
30070: GO 29950
30072: POP
30073: POP
// end ; if tmp > 3 then
30074: LD_VAR 0 5
30078: PUSH
30079: LD_INT 3
30081: GREATER
30082: IFFALSE 30102
// tmp := ShrinkArray ( tmp , 4 ) ;
30084: LD_ADDR_VAR 0 5
30088: PUSH
30089: LD_VAR 0 5
30093: PPUSH
30094: LD_INT 4
30096: PPUSH
30097: CALL 86773 0 2
30101: ST_TO_ADDR
// if not tmp then
30102: LD_VAR 0 5
30106: NOT
30107: IFFALSE 30111
// continue ;
30109: GO 29567
// for j in tmp do
30111: LD_ADDR_VAR 0 3
30115: PUSH
30116: LD_VAR 0 5
30120: PUSH
30121: FOR_IN
30122: IFFALSE 30381
// begin if IsInUnit ( j ) then
30124: LD_VAR 0 3
30128: PPUSH
30129: CALL_OW 310
30133: IFFALSE 30144
// ComExitBuilding ( j ) ;
30135: LD_VAR 0 3
30139: PPUSH
30140: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30144: LD_VAR 0 3
30148: PUSH
30149: LD_EXP 89
30153: PUSH
30154: LD_VAR 0 2
30158: ARRAY
30159: IN
30160: NOT
30161: IFFALSE 30219
// begin SetTag ( j , 101 ) ;
30163: LD_VAR 0 3
30167: PPUSH
30168: LD_INT 101
30170: PPUSH
30171: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30175: LD_ADDR_EXP 89
30179: PUSH
30180: LD_EXP 89
30184: PPUSH
30185: LD_VAR 0 2
30189: PUSH
30190: LD_EXP 89
30194: PUSH
30195: LD_VAR 0 2
30199: ARRAY
30200: PUSH
30201: LD_INT 1
30203: PLUS
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PPUSH
30209: LD_VAR 0 3
30213: PPUSH
30214: CALL 55547 0 3
30218: ST_TO_ADDR
// end ; wait ( 1 ) ;
30219: LD_INT 1
30221: PPUSH
30222: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30226: LD_ADDR_VAR 0 7
30230: PUSH
30231: LD_EXP 88
30235: PUSH
30236: LD_VAR 0 2
30240: ARRAY
30241: ST_TO_ADDR
// if mc_scan [ i ] then
30242: LD_EXP 110
30246: PUSH
30247: LD_VAR 0 2
30251: ARRAY
30252: IFFALSE 30314
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30254: LD_ADDR_VAR 0 7
30258: PUSH
30259: LD_EXP 88
30263: PUSH
30264: LD_VAR 0 2
30268: ARRAY
30269: PPUSH
30270: LD_INT 3
30272: PUSH
30273: LD_INT 30
30275: PUSH
30276: LD_INT 32
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 30
30285: PUSH
30286: LD_INT 33
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 30
30295: PUSH
30296: LD_INT 31
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: PPUSH
30309: CALL_OW 72
30313: ST_TO_ADDR
// if not to_repair_tmp then
30314: LD_VAR 0 7
30318: NOT
30319: IFFALSE 30323
// continue ;
30321: GO 30121
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30323: LD_ADDR_VAR 0 8
30327: PUSH
30328: LD_VAR 0 7
30332: PPUSH
30333: LD_VAR 0 3
30337: PPUSH
30338: CALL_OW 74
30342: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
30343: LD_VAR 0 8
30347: PPUSH
30348: LD_INT 16
30350: PPUSH
30351: CALL 58140 0 2
30355: PUSH
30356: LD_INT 4
30358: ARRAY
30359: PUSH
30360: LD_INT 5
30362: LESS
30363: IFFALSE 30379
// ComRepairBuilding ( j , to_repair ) ;
30365: LD_VAR 0 3
30369: PPUSH
30370: LD_VAR 0 8
30374: PPUSH
30375: CALL_OW 130
// end ;
30379: GO 30121
30381: POP
30382: POP
// end ;
30383: GO 29567
30385: POP
30386: POP
// end ;
30387: LD_VAR 0 1
30391: RET
// export function MC_Heal ; var i , j , tmp ; begin
30392: LD_INT 0
30394: PPUSH
30395: PPUSH
30396: PPUSH
30397: PPUSH
// if not mc_bases then
30398: LD_EXP 87
30402: NOT
30403: IFFALSE 30407
// exit ;
30405: GO 30809
// for i = 1 to mc_bases do
30407: LD_ADDR_VAR 0 2
30411: PUSH
30412: DOUBLE
30413: LD_INT 1
30415: DEC
30416: ST_TO_ADDR
30417: LD_EXP 87
30421: PUSH
30422: FOR_TO
30423: IFFALSE 30807
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30425: LD_EXP 90
30429: PUSH
30430: LD_VAR 0 2
30434: ARRAY
30435: PUSH
30436: LD_INT 1
30438: ARRAY
30439: NOT
30440: PUSH
30441: LD_EXP 90
30445: PUSH
30446: LD_VAR 0 2
30450: ARRAY
30451: PUSH
30452: LD_INT 2
30454: ARRAY
30455: NOT
30456: AND
30457: IFFALSE 30495
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30459: LD_ADDR_EXP 91
30463: PUSH
30464: LD_EXP 91
30468: PPUSH
30469: LD_VAR 0 2
30473: PPUSH
30474: EMPTY
30475: PPUSH
30476: CALL_OW 1
30480: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30481: LD_VAR 0 2
30485: PPUSH
30486: LD_INT 102
30488: PPUSH
30489: CALL 24656 0 2
// continue ;
30493: GO 30422
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30495: LD_ADDR_VAR 0 4
30499: PUSH
30500: LD_EXP 87
30504: PUSH
30505: LD_VAR 0 2
30509: ARRAY
30510: PPUSH
30511: LD_INT 25
30513: PUSH
30514: LD_INT 4
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PPUSH
30521: CALL_OW 72
30525: ST_TO_ADDR
// if not tmp then
30526: LD_VAR 0 4
30530: NOT
30531: IFFALSE 30535
// continue ;
30533: GO 30422
// if mc_taming [ i ] then
30535: LD_EXP 118
30539: PUSH
30540: LD_VAR 0 2
30544: ARRAY
30545: IFFALSE 30569
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30547: LD_ADDR_EXP 118
30551: PUSH
30552: LD_EXP 118
30556: PPUSH
30557: LD_VAR 0 2
30561: PPUSH
30562: EMPTY
30563: PPUSH
30564: CALL_OW 1
30568: ST_TO_ADDR
// for j in tmp do
30569: LD_ADDR_VAR 0 3
30573: PUSH
30574: LD_VAR 0 4
30578: PUSH
30579: FOR_IN
30580: IFFALSE 30803
// begin if IsInUnit ( j ) then
30582: LD_VAR 0 3
30586: PPUSH
30587: CALL_OW 310
30591: IFFALSE 30602
// ComExitBuilding ( j ) ;
30593: LD_VAR 0 3
30597: PPUSH
30598: CALL_OW 122
// if not j in mc_healers [ i ] then
30602: LD_VAR 0 3
30606: PUSH
30607: LD_EXP 91
30611: PUSH
30612: LD_VAR 0 2
30616: ARRAY
30617: IN
30618: NOT
30619: IFFALSE 30665
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30621: LD_ADDR_EXP 91
30625: PUSH
30626: LD_EXP 91
30630: PPUSH
30631: LD_VAR 0 2
30635: PUSH
30636: LD_EXP 91
30640: PUSH
30641: LD_VAR 0 2
30645: ARRAY
30646: PUSH
30647: LD_INT 1
30649: PLUS
30650: PUSH
30651: EMPTY
30652: LIST
30653: LIST
30654: PPUSH
30655: LD_VAR 0 3
30659: PPUSH
30660: CALL 55547 0 3
30664: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30665: LD_VAR 0 3
30669: PPUSH
30670: CALL_OW 110
30674: PUSH
30675: LD_INT 102
30677: NONEQUAL
30678: IFFALSE 30692
// SetTag ( j , 102 ) ;
30680: LD_VAR 0 3
30684: PPUSH
30685: LD_INT 102
30687: PPUSH
30688: CALL_OW 109
// Wait ( 3 ) ;
30692: LD_INT 3
30694: PPUSH
30695: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30699: LD_EXP 90
30703: PUSH
30704: LD_VAR 0 2
30708: ARRAY
30709: PUSH
30710: LD_INT 1
30712: ARRAY
30713: IFFALSE 30745
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30715: LD_VAR 0 3
30719: PPUSH
30720: LD_EXP 90
30724: PUSH
30725: LD_VAR 0 2
30729: ARRAY
30730: PUSH
30731: LD_INT 1
30733: ARRAY
30734: PUSH
30735: LD_INT 1
30737: ARRAY
30738: PPUSH
30739: CALL_OW 128
30743: GO 30801
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30745: LD_VAR 0 3
30749: PPUSH
30750: CALL_OW 314
30754: NOT
30755: PUSH
30756: LD_EXP 90
30760: PUSH
30761: LD_VAR 0 2
30765: ARRAY
30766: PUSH
30767: LD_INT 2
30769: ARRAY
30770: AND
30771: IFFALSE 30801
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30773: LD_VAR 0 3
30777: PPUSH
30778: LD_EXP 90
30782: PUSH
30783: LD_VAR 0 2
30787: ARRAY
30788: PUSH
30789: LD_INT 2
30791: ARRAY
30792: PUSH
30793: LD_INT 1
30795: ARRAY
30796: PPUSH
30797: CALL_OW 128
// end ;
30801: GO 30579
30803: POP
30804: POP
// end ;
30805: GO 30422
30807: POP
30808: POP
// end ;
30809: LD_VAR 0 1
30813: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30814: LD_INT 0
30816: PPUSH
30817: PPUSH
30818: PPUSH
30819: PPUSH
30820: PPUSH
// if not mc_bases then
30821: LD_EXP 87
30825: NOT
30826: IFFALSE 30830
// exit ;
30828: GO 31973
// for i = 1 to mc_bases do
30830: LD_ADDR_VAR 0 2
30834: PUSH
30835: DOUBLE
30836: LD_INT 1
30838: DEC
30839: ST_TO_ADDR
30840: LD_EXP 87
30844: PUSH
30845: FOR_TO
30846: IFFALSE 31971
// begin if mc_scan [ i ] then
30848: LD_EXP 110
30852: PUSH
30853: LD_VAR 0 2
30857: ARRAY
30858: IFFALSE 30862
// continue ;
30860: GO 30845
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30862: LD_EXP 92
30866: PUSH
30867: LD_VAR 0 2
30871: ARRAY
30872: NOT
30873: PUSH
30874: LD_EXP 94
30878: PUSH
30879: LD_VAR 0 2
30883: ARRAY
30884: NOT
30885: AND
30886: PUSH
30887: LD_EXP 93
30891: PUSH
30892: LD_VAR 0 2
30896: ARRAY
30897: AND
30898: IFFALSE 30936
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30900: LD_ADDR_EXP 93
30904: PUSH
30905: LD_EXP 93
30909: PPUSH
30910: LD_VAR 0 2
30914: PPUSH
30915: EMPTY
30916: PPUSH
30917: CALL_OW 1
30921: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30922: LD_VAR 0 2
30926: PPUSH
30927: LD_INT 103
30929: PPUSH
30930: CALL 24656 0 2
// continue ;
30934: GO 30845
// end ; if mc_construct_list [ i ] then
30936: LD_EXP 94
30940: PUSH
30941: LD_VAR 0 2
30945: ARRAY
30946: IFFALSE 31166
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30948: LD_ADDR_VAR 0 4
30952: PUSH
30953: LD_EXP 87
30957: PUSH
30958: LD_VAR 0 2
30962: ARRAY
30963: PPUSH
30964: LD_INT 25
30966: PUSH
30967: LD_INT 2
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PPUSH
30974: CALL_OW 72
30978: PUSH
30979: LD_EXP 89
30983: PUSH
30984: LD_VAR 0 2
30988: ARRAY
30989: DIFF
30990: ST_TO_ADDR
// if not tmp then
30991: LD_VAR 0 4
30995: NOT
30996: IFFALSE 31000
// continue ;
30998: GO 30845
// for j in tmp do
31000: LD_ADDR_VAR 0 3
31004: PUSH
31005: LD_VAR 0 4
31009: PUSH
31010: FOR_IN
31011: IFFALSE 31162
// begin if not mc_builders [ i ] then
31013: LD_EXP 93
31017: PUSH
31018: LD_VAR 0 2
31022: ARRAY
31023: NOT
31024: IFFALSE 31082
// begin SetTag ( j , 103 ) ;
31026: LD_VAR 0 3
31030: PPUSH
31031: LD_INT 103
31033: PPUSH
31034: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31038: LD_ADDR_EXP 93
31042: PUSH
31043: LD_EXP 93
31047: PPUSH
31048: LD_VAR 0 2
31052: PUSH
31053: LD_EXP 93
31057: PUSH
31058: LD_VAR 0 2
31062: ARRAY
31063: PUSH
31064: LD_INT 1
31066: PLUS
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PPUSH
31072: LD_VAR 0 3
31076: PPUSH
31077: CALL 55547 0 3
31081: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31082: LD_VAR 0 3
31086: PPUSH
31087: CALL_OW 310
31091: IFFALSE 31102
// ComExitBuilding ( j ) ;
31093: LD_VAR 0 3
31097: PPUSH
31098: CALL_OW 122
// wait ( 3 ) ;
31102: LD_INT 3
31104: PPUSH
31105: CALL_OW 67
// if not mc_construct_list [ i ] then
31109: LD_EXP 94
31113: PUSH
31114: LD_VAR 0 2
31118: ARRAY
31119: NOT
31120: IFFALSE 31124
// break ;
31122: GO 31162
// if not HasTask ( j ) then
31124: LD_VAR 0 3
31128: PPUSH
31129: CALL_OW 314
31133: NOT
31134: IFFALSE 31160
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31136: LD_VAR 0 3
31140: PPUSH
31141: LD_EXP 94
31145: PUSH
31146: LD_VAR 0 2
31150: ARRAY
31151: PUSH
31152: LD_INT 1
31154: ARRAY
31155: PPUSH
31156: CALL 58398 0 2
// end ;
31160: GO 31010
31162: POP
31163: POP
// end else
31164: GO 31969
// if mc_build_list [ i ] then
31166: LD_EXP 92
31170: PUSH
31171: LD_VAR 0 2
31175: ARRAY
31176: IFFALSE 31969
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31178: LD_ADDR_VAR 0 5
31182: PUSH
31183: LD_EXP 87
31187: PUSH
31188: LD_VAR 0 2
31192: ARRAY
31193: PPUSH
31194: LD_INT 2
31196: PUSH
31197: LD_INT 30
31199: PUSH
31200: LD_INT 0
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: PUSH
31207: LD_INT 30
31209: PUSH
31210: LD_INT 1
31212: PUSH
31213: EMPTY
31214: LIST
31215: LIST
31216: PUSH
31217: EMPTY
31218: LIST
31219: LIST
31220: LIST
31221: PPUSH
31222: CALL_OW 72
31226: ST_TO_ADDR
// if depot then
31227: LD_VAR 0 5
31231: IFFALSE 31249
// depot := depot [ 1 ] else
31233: LD_ADDR_VAR 0 5
31237: PUSH
31238: LD_VAR 0 5
31242: PUSH
31243: LD_INT 1
31245: ARRAY
31246: ST_TO_ADDR
31247: GO 31257
// depot := 0 ;
31249: LD_ADDR_VAR 0 5
31253: PUSH
31254: LD_INT 0
31256: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31257: LD_EXP 92
31261: PUSH
31262: LD_VAR 0 2
31266: ARRAY
31267: PUSH
31268: LD_INT 1
31270: ARRAY
31271: PUSH
31272: LD_INT 1
31274: ARRAY
31275: PPUSH
31276: CALL 58228 0 1
31280: PUSH
31281: LD_EXP 87
31285: PUSH
31286: LD_VAR 0 2
31290: ARRAY
31291: PPUSH
31292: LD_INT 2
31294: PUSH
31295: LD_INT 30
31297: PUSH
31298: LD_INT 2
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: PUSH
31305: LD_INT 30
31307: PUSH
31308: LD_INT 3
31310: PUSH
31311: EMPTY
31312: LIST
31313: LIST
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: LIST
31319: PPUSH
31320: CALL_OW 72
31324: NOT
31325: AND
31326: IFFALSE 31431
// begin for j = 1 to mc_build_list [ i ] do
31328: LD_ADDR_VAR 0 3
31332: PUSH
31333: DOUBLE
31334: LD_INT 1
31336: DEC
31337: ST_TO_ADDR
31338: LD_EXP 92
31342: PUSH
31343: LD_VAR 0 2
31347: ARRAY
31348: PUSH
31349: FOR_TO
31350: IFFALSE 31429
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31352: LD_EXP 92
31356: PUSH
31357: LD_VAR 0 2
31361: ARRAY
31362: PUSH
31363: LD_VAR 0 3
31367: ARRAY
31368: PUSH
31369: LD_INT 1
31371: ARRAY
31372: PUSH
31373: LD_INT 2
31375: EQUAL
31376: IFFALSE 31427
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31378: LD_ADDR_EXP 92
31382: PUSH
31383: LD_EXP 92
31387: PPUSH
31388: LD_VAR 0 2
31392: PPUSH
31393: LD_EXP 92
31397: PUSH
31398: LD_VAR 0 2
31402: ARRAY
31403: PPUSH
31404: LD_VAR 0 3
31408: PPUSH
31409: LD_INT 1
31411: PPUSH
31412: LD_INT 0
31414: PPUSH
31415: CALL 54965 0 4
31419: PPUSH
31420: CALL_OW 1
31424: ST_TO_ADDR
// break ;
31425: GO 31429
// end ;
31427: GO 31349
31429: POP
31430: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31431: LD_EXP 92
31435: PUSH
31436: LD_VAR 0 2
31440: ARRAY
31441: PUSH
31442: LD_INT 1
31444: ARRAY
31445: PUSH
31446: LD_INT 1
31448: ARRAY
31449: PUSH
31450: LD_INT 0
31452: EQUAL
31453: PUSH
31454: LD_VAR 0 5
31458: PUSH
31459: LD_VAR 0 5
31463: PPUSH
31464: LD_EXP 92
31468: PUSH
31469: LD_VAR 0 2
31473: ARRAY
31474: PUSH
31475: LD_INT 1
31477: ARRAY
31478: PUSH
31479: LD_INT 1
31481: ARRAY
31482: PPUSH
31483: LD_EXP 92
31487: PUSH
31488: LD_VAR 0 2
31492: ARRAY
31493: PUSH
31494: LD_INT 1
31496: ARRAY
31497: PUSH
31498: LD_INT 2
31500: ARRAY
31501: PPUSH
31502: LD_EXP 92
31506: PUSH
31507: LD_VAR 0 2
31511: ARRAY
31512: PUSH
31513: LD_INT 1
31515: ARRAY
31516: PUSH
31517: LD_INT 3
31519: ARRAY
31520: PPUSH
31521: LD_EXP 92
31525: PUSH
31526: LD_VAR 0 2
31530: ARRAY
31531: PUSH
31532: LD_INT 1
31534: ARRAY
31535: PUSH
31536: LD_INT 4
31538: ARRAY
31539: PPUSH
31540: CALL 62962 0 5
31544: AND
31545: OR
31546: IFFALSE 31827
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31548: LD_ADDR_VAR 0 4
31552: PUSH
31553: LD_EXP 87
31557: PUSH
31558: LD_VAR 0 2
31562: ARRAY
31563: PPUSH
31564: LD_INT 25
31566: PUSH
31567: LD_INT 2
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PPUSH
31574: CALL_OW 72
31578: PUSH
31579: LD_EXP 89
31583: PUSH
31584: LD_VAR 0 2
31588: ARRAY
31589: DIFF
31590: ST_TO_ADDR
// if not tmp then
31591: LD_VAR 0 4
31595: NOT
31596: IFFALSE 31600
// continue ;
31598: GO 30845
// for j in tmp do
31600: LD_ADDR_VAR 0 3
31604: PUSH
31605: LD_VAR 0 4
31609: PUSH
31610: FOR_IN
31611: IFFALSE 31823
// begin if not mc_builders [ i ] then
31613: LD_EXP 93
31617: PUSH
31618: LD_VAR 0 2
31622: ARRAY
31623: NOT
31624: IFFALSE 31682
// begin SetTag ( j , 103 ) ;
31626: LD_VAR 0 3
31630: PPUSH
31631: LD_INT 103
31633: PPUSH
31634: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31638: LD_ADDR_EXP 93
31642: PUSH
31643: LD_EXP 93
31647: PPUSH
31648: LD_VAR 0 2
31652: PUSH
31653: LD_EXP 93
31657: PUSH
31658: LD_VAR 0 2
31662: ARRAY
31663: PUSH
31664: LD_INT 1
31666: PLUS
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PPUSH
31672: LD_VAR 0 3
31676: PPUSH
31677: CALL 55547 0 3
31681: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31682: LD_VAR 0 3
31686: PPUSH
31687: CALL_OW 310
31691: IFFALSE 31702
// ComExitBuilding ( j ) ;
31693: LD_VAR 0 3
31697: PPUSH
31698: CALL_OW 122
// wait ( 3 ) ;
31702: LD_INT 3
31704: PPUSH
31705: CALL_OW 67
// if not mc_build_list [ i ] then
31709: LD_EXP 92
31713: PUSH
31714: LD_VAR 0 2
31718: ARRAY
31719: NOT
31720: IFFALSE 31724
// break ;
31722: GO 31823
// if not HasTask ( j ) then
31724: LD_VAR 0 3
31728: PPUSH
31729: CALL_OW 314
31733: NOT
31734: IFFALSE 31821
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31736: LD_VAR 0 3
31740: PPUSH
31741: LD_EXP 92
31745: PUSH
31746: LD_VAR 0 2
31750: ARRAY
31751: PUSH
31752: LD_INT 1
31754: ARRAY
31755: PUSH
31756: LD_INT 1
31758: ARRAY
31759: PPUSH
31760: LD_EXP 92
31764: PUSH
31765: LD_VAR 0 2
31769: ARRAY
31770: PUSH
31771: LD_INT 1
31773: ARRAY
31774: PUSH
31775: LD_INT 2
31777: ARRAY
31778: PPUSH
31779: LD_EXP 92
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: PUSH
31790: LD_INT 1
31792: ARRAY
31793: PUSH
31794: LD_INT 3
31796: ARRAY
31797: PPUSH
31798: LD_EXP 92
31802: PUSH
31803: LD_VAR 0 2
31807: ARRAY
31808: PUSH
31809: LD_INT 1
31811: ARRAY
31812: PUSH
31813: LD_INT 4
31815: ARRAY
31816: PPUSH
31817: CALL_OW 145
// end ;
31821: GO 31610
31823: POP
31824: POP
// end else
31825: GO 31969
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31827: LD_EXP 87
31831: PUSH
31832: LD_VAR 0 2
31836: ARRAY
31837: PPUSH
31838: LD_EXP 92
31842: PUSH
31843: LD_VAR 0 2
31847: ARRAY
31848: PUSH
31849: LD_INT 1
31851: ARRAY
31852: PUSH
31853: LD_INT 1
31855: ARRAY
31856: PPUSH
31857: LD_EXP 92
31861: PUSH
31862: LD_VAR 0 2
31866: ARRAY
31867: PUSH
31868: LD_INT 1
31870: ARRAY
31871: PUSH
31872: LD_INT 2
31874: ARRAY
31875: PPUSH
31876: LD_EXP 92
31880: PUSH
31881: LD_VAR 0 2
31885: ARRAY
31886: PUSH
31887: LD_INT 1
31889: ARRAY
31890: PUSH
31891: LD_INT 3
31893: ARRAY
31894: PPUSH
31895: LD_EXP 92
31899: PUSH
31900: LD_VAR 0 2
31904: ARRAY
31905: PUSH
31906: LD_INT 1
31908: ARRAY
31909: PUSH
31910: LD_INT 4
31912: ARRAY
31913: PPUSH
31914: CALL 62298 0 5
31918: NOT
31919: IFFALSE 31969
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31921: LD_ADDR_EXP 92
31925: PUSH
31926: LD_EXP 92
31930: PPUSH
31931: LD_VAR 0 2
31935: PPUSH
31936: LD_EXP 92
31940: PUSH
31941: LD_VAR 0 2
31945: ARRAY
31946: PPUSH
31947: LD_INT 1
31949: PPUSH
31950: LD_INT 1
31952: NEG
31953: PPUSH
31954: LD_INT 0
31956: PPUSH
31957: CALL 54965 0 4
31961: PPUSH
31962: CALL_OW 1
31966: ST_TO_ADDR
// continue ;
31967: GO 30845
// end ; end ; end ;
31969: GO 30845
31971: POP
31972: POP
// end ;
31973: LD_VAR 0 1
31977: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31978: LD_INT 0
31980: PPUSH
31981: PPUSH
31982: PPUSH
31983: PPUSH
31984: PPUSH
31985: PPUSH
// if not mc_bases then
31986: LD_EXP 87
31990: NOT
31991: IFFALSE 31995
// exit ;
31993: GO 32422
// for i = 1 to mc_bases do
31995: LD_ADDR_VAR 0 2
31999: PUSH
32000: DOUBLE
32001: LD_INT 1
32003: DEC
32004: ST_TO_ADDR
32005: LD_EXP 87
32009: PUSH
32010: FOR_TO
32011: IFFALSE 32420
// begin tmp := mc_build_upgrade [ i ] ;
32013: LD_ADDR_VAR 0 4
32017: PUSH
32018: LD_EXP 119
32022: PUSH
32023: LD_VAR 0 2
32027: ARRAY
32028: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32029: LD_ADDR_VAR 0 6
32033: PUSH
32034: LD_EXP 120
32038: PUSH
32039: LD_VAR 0 2
32043: ARRAY
32044: PPUSH
32045: LD_INT 2
32047: PUSH
32048: LD_INT 30
32050: PUSH
32051: LD_INT 6
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: LD_INT 30
32060: PUSH
32061: LD_INT 7
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: LIST
32072: PPUSH
32073: CALL_OW 72
32077: ST_TO_ADDR
// if not tmp and not lab then
32078: LD_VAR 0 4
32082: NOT
32083: PUSH
32084: LD_VAR 0 6
32088: NOT
32089: AND
32090: IFFALSE 32094
// continue ;
32092: GO 32010
// if tmp then
32094: LD_VAR 0 4
32098: IFFALSE 32218
// for j in tmp do
32100: LD_ADDR_VAR 0 3
32104: PUSH
32105: LD_VAR 0 4
32109: PUSH
32110: FOR_IN
32111: IFFALSE 32216
// begin if UpgradeCost ( j ) then
32113: LD_VAR 0 3
32117: PPUSH
32118: CALL 61958 0 1
32122: IFFALSE 32214
// begin ComUpgrade ( j ) ;
32124: LD_VAR 0 3
32128: PPUSH
32129: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32133: LD_ADDR_EXP 119
32137: PUSH
32138: LD_EXP 119
32142: PPUSH
32143: LD_VAR 0 2
32147: PPUSH
32148: LD_EXP 119
32152: PUSH
32153: LD_VAR 0 2
32157: ARRAY
32158: PUSH
32159: LD_VAR 0 3
32163: DIFF
32164: PPUSH
32165: CALL_OW 1
32169: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32170: LD_ADDR_EXP 94
32174: PUSH
32175: LD_EXP 94
32179: PPUSH
32180: LD_VAR 0 2
32184: PUSH
32185: LD_EXP 94
32189: PUSH
32190: LD_VAR 0 2
32194: ARRAY
32195: PUSH
32196: LD_INT 1
32198: PLUS
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PPUSH
32204: LD_VAR 0 3
32208: PPUSH
32209: CALL 55547 0 3
32213: ST_TO_ADDR
// end ; end ;
32214: GO 32110
32216: POP
32217: POP
// if not lab or not mc_lab_upgrade [ i ] then
32218: LD_VAR 0 6
32222: NOT
32223: PUSH
32224: LD_EXP 121
32228: PUSH
32229: LD_VAR 0 2
32233: ARRAY
32234: NOT
32235: OR
32236: IFFALSE 32240
// continue ;
32238: GO 32010
// for j in lab do
32240: LD_ADDR_VAR 0 3
32244: PUSH
32245: LD_VAR 0 6
32249: PUSH
32250: FOR_IN
32251: IFFALSE 32416
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32253: LD_VAR 0 3
32257: PPUSH
32258: CALL_OW 266
32262: PUSH
32263: LD_INT 6
32265: PUSH
32266: LD_INT 7
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: IN
32273: PUSH
32274: LD_VAR 0 3
32278: PPUSH
32279: CALL_OW 461
32283: PUSH
32284: LD_INT 1
32286: NONEQUAL
32287: AND
32288: IFFALSE 32414
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32290: LD_VAR 0 3
32294: PPUSH
32295: LD_EXP 121
32299: PUSH
32300: LD_VAR 0 2
32304: ARRAY
32305: PUSH
32306: LD_INT 1
32308: ARRAY
32309: PPUSH
32310: CALL 62163 0 2
32314: IFFALSE 32414
// begin ComCancel ( j ) ;
32316: LD_VAR 0 3
32320: PPUSH
32321: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32325: LD_VAR 0 3
32329: PPUSH
32330: LD_EXP 121
32334: PUSH
32335: LD_VAR 0 2
32339: ARRAY
32340: PUSH
32341: LD_INT 1
32343: ARRAY
32344: PPUSH
32345: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32349: LD_VAR 0 3
32353: PUSH
32354: LD_EXP 94
32358: PUSH
32359: LD_VAR 0 2
32363: ARRAY
32364: IN
32365: NOT
32366: IFFALSE 32412
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32368: LD_ADDR_EXP 94
32372: PUSH
32373: LD_EXP 94
32377: PPUSH
32378: LD_VAR 0 2
32382: PUSH
32383: LD_EXP 94
32387: PUSH
32388: LD_VAR 0 2
32392: ARRAY
32393: PUSH
32394: LD_INT 1
32396: PLUS
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PPUSH
32402: LD_VAR 0 3
32406: PPUSH
32407: CALL 55547 0 3
32411: ST_TO_ADDR
// break ;
32412: GO 32416
// end ; end ; end ;
32414: GO 32250
32416: POP
32417: POP
// end ;
32418: GO 32010
32420: POP
32421: POP
// end ;
32422: LD_VAR 0 1
32426: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32427: LD_INT 0
32429: PPUSH
32430: PPUSH
32431: PPUSH
32432: PPUSH
32433: PPUSH
32434: PPUSH
32435: PPUSH
32436: PPUSH
32437: PPUSH
// if not mc_bases then
32438: LD_EXP 87
32442: NOT
32443: IFFALSE 32447
// exit ;
32445: GO 32852
// for i = 1 to mc_bases do
32447: LD_ADDR_VAR 0 2
32451: PUSH
32452: DOUBLE
32453: LD_INT 1
32455: DEC
32456: ST_TO_ADDR
32457: LD_EXP 87
32461: PUSH
32462: FOR_TO
32463: IFFALSE 32850
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32465: LD_EXP 95
32469: PUSH
32470: LD_VAR 0 2
32474: ARRAY
32475: NOT
32476: PUSH
32477: LD_EXP 87
32481: PUSH
32482: LD_VAR 0 2
32486: ARRAY
32487: PPUSH
32488: LD_INT 30
32490: PUSH
32491: LD_INT 3
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PPUSH
32498: CALL_OW 72
32502: NOT
32503: OR
32504: IFFALSE 32508
// continue ;
32506: GO 32462
// busy := false ;
32508: LD_ADDR_VAR 0 8
32512: PUSH
32513: LD_INT 0
32515: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32516: LD_ADDR_VAR 0 4
32520: PUSH
32521: LD_EXP 87
32525: PUSH
32526: LD_VAR 0 2
32530: ARRAY
32531: PPUSH
32532: LD_INT 30
32534: PUSH
32535: LD_INT 3
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PPUSH
32542: CALL_OW 72
32546: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32547: LD_ADDR_VAR 0 6
32551: PUSH
32552: LD_EXP 95
32556: PUSH
32557: LD_VAR 0 2
32561: ARRAY
32562: PPUSH
32563: LD_INT 2
32565: PUSH
32566: LD_INT 30
32568: PUSH
32569: LD_INT 32
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 30
32578: PUSH
32579: LD_INT 33
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: EMPTY
32587: LIST
32588: LIST
32589: LIST
32590: PPUSH
32591: CALL_OW 72
32595: ST_TO_ADDR
// if not t then
32596: LD_VAR 0 6
32600: NOT
32601: IFFALSE 32605
// continue ;
32603: GO 32462
// for j in tmp do
32605: LD_ADDR_VAR 0 3
32609: PUSH
32610: LD_VAR 0 4
32614: PUSH
32615: FOR_IN
32616: IFFALSE 32646
// if not BuildingStatus ( j ) = bs_idle then
32618: LD_VAR 0 3
32622: PPUSH
32623: CALL_OW 461
32627: PUSH
32628: LD_INT 2
32630: EQUAL
32631: NOT
32632: IFFALSE 32644
// begin busy := true ;
32634: LD_ADDR_VAR 0 8
32638: PUSH
32639: LD_INT 1
32641: ST_TO_ADDR
// break ;
32642: GO 32646
// end ;
32644: GO 32615
32646: POP
32647: POP
// if busy then
32648: LD_VAR 0 8
32652: IFFALSE 32656
// continue ;
32654: GO 32462
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32656: LD_ADDR_VAR 0 7
32660: PUSH
32661: LD_VAR 0 6
32665: PPUSH
32666: LD_INT 35
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PPUSH
32676: CALL_OW 72
32680: ST_TO_ADDR
// if tw then
32681: LD_VAR 0 7
32685: IFFALSE 32762
// begin tw := tw [ 1 ] ;
32687: LD_ADDR_VAR 0 7
32691: PUSH
32692: LD_VAR 0 7
32696: PUSH
32697: LD_INT 1
32699: ARRAY
32700: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32701: LD_ADDR_VAR 0 9
32705: PUSH
32706: LD_VAR 0 7
32710: PPUSH
32711: LD_EXP 112
32715: PUSH
32716: LD_VAR 0 2
32720: ARRAY
32721: PPUSH
32722: CALL 60517 0 2
32726: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32727: LD_EXP 126
32731: PUSH
32732: LD_VAR 0 2
32736: ARRAY
32737: IFFALSE 32760
// if not weapon in mc_allowed_tower_weapons [ i ] then
32739: LD_VAR 0 9
32743: PUSH
32744: LD_EXP 126
32748: PUSH
32749: LD_VAR 0 2
32753: ARRAY
32754: IN
32755: NOT
32756: IFFALSE 32760
// continue ;
32758: GO 32462
// end else
32760: GO 32825
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32762: LD_ADDR_VAR 0 5
32766: PUSH
32767: LD_EXP 95
32771: PUSH
32772: LD_VAR 0 2
32776: ARRAY
32777: PPUSH
32778: LD_VAR 0 4
32782: PPUSH
32783: CALL 86019 0 2
32787: ST_TO_ADDR
// if not tmp2 then
32788: LD_VAR 0 5
32792: NOT
32793: IFFALSE 32797
// continue ;
32795: GO 32462
// tw := tmp2 [ 1 ] ;
32797: LD_ADDR_VAR 0 7
32801: PUSH
32802: LD_VAR 0 5
32806: PUSH
32807: LD_INT 1
32809: ARRAY
32810: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32811: LD_ADDR_VAR 0 9
32815: PUSH
32816: LD_VAR 0 5
32820: PUSH
32821: LD_INT 2
32823: ARRAY
32824: ST_TO_ADDR
// end ; if not weapon then
32825: LD_VAR 0 9
32829: NOT
32830: IFFALSE 32834
// continue ;
32832: GO 32462
// ComPlaceWeapon ( tw , weapon ) ;
32834: LD_VAR 0 7
32838: PPUSH
32839: LD_VAR 0 9
32843: PPUSH
32844: CALL_OW 148
// end ;
32848: GO 32462
32850: POP
32851: POP
// end ;
32852: LD_VAR 0 1
32856: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32857: LD_INT 0
32859: PPUSH
32860: PPUSH
32861: PPUSH
32862: PPUSH
32863: PPUSH
32864: PPUSH
// if not mc_bases then
32865: LD_EXP 87
32869: NOT
32870: IFFALSE 32874
// exit ;
32872: GO 33650
// for i = 1 to mc_bases do
32874: LD_ADDR_VAR 0 2
32878: PUSH
32879: DOUBLE
32880: LD_INT 1
32882: DEC
32883: ST_TO_ADDR
32884: LD_EXP 87
32888: PUSH
32889: FOR_TO
32890: IFFALSE 33648
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32892: LD_EXP 100
32896: PUSH
32897: LD_VAR 0 2
32901: ARRAY
32902: NOT
32903: PUSH
32904: LD_EXP 100
32908: PUSH
32909: LD_VAR 0 2
32913: ARRAY
32914: PUSH
32915: LD_EXP 101
32919: PUSH
32920: LD_VAR 0 2
32924: ARRAY
32925: EQUAL
32926: OR
32927: PUSH
32928: LD_EXP 110
32932: PUSH
32933: LD_VAR 0 2
32937: ARRAY
32938: OR
32939: IFFALSE 32943
// continue ;
32941: GO 32889
// if mc_miners [ i ] then
32943: LD_EXP 101
32947: PUSH
32948: LD_VAR 0 2
32952: ARRAY
32953: IFFALSE 33335
// begin for j = mc_miners [ i ] downto 1 do
32955: LD_ADDR_VAR 0 3
32959: PUSH
32960: DOUBLE
32961: LD_EXP 101
32965: PUSH
32966: LD_VAR 0 2
32970: ARRAY
32971: INC
32972: ST_TO_ADDR
32973: LD_INT 1
32975: PUSH
32976: FOR_DOWNTO
32977: IFFALSE 33333
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32979: LD_EXP 101
32983: PUSH
32984: LD_VAR 0 2
32988: ARRAY
32989: PUSH
32990: LD_VAR 0 3
32994: ARRAY
32995: PPUSH
32996: CALL_OW 301
33000: PUSH
33001: LD_EXP 101
33005: PUSH
33006: LD_VAR 0 2
33010: ARRAY
33011: PUSH
33012: LD_VAR 0 3
33016: ARRAY
33017: PPUSH
33018: CALL_OW 257
33022: PUSH
33023: LD_INT 1
33025: NONEQUAL
33026: OR
33027: IFFALSE 33090
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33029: LD_ADDR_VAR 0 5
33033: PUSH
33034: LD_EXP 101
33038: PUSH
33039: LD_VAR 0 2
33043: ARRAY
33044: PUSH
33045: LD_EXP 101
33049: PUSH
33050: LD_VAR 0 2
33054: ARRAY
33055: PUSH
33056: LD_VAR 0 3
33060: ARRAY
33061: DIFF
33062: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33063: LD_ADDR_EXP 101
33067: PUSH
33068: LD_EXP 101
33072: PPUSH
33073: LD_VAR 0 2
33077: PPUSH
33078: LD_VAR 0 5
33082: PPUSH
33083: CALL_OW 1
33087: ST_TO_ADDR
// continue ;
33088: GO 32976
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33090: LD_EXP 101
33094: PUSH
33095: LD_VAR 0 2
33099: ARRAY
33100: PUSH
33101: LD_VAR 0 3
33105: ARRAY
33106: PPUSH
33107: CALL_OW 257
33111: PUSH
33112: LD_INT 1
33114: EQUAL
33115: PUSH
33116: LD_EXP 101
33120: PUSH
33121: LD_VAR 0 2
33125: ARRAY
33126: PUSH
33127: LD_VAR 0 3
33131: ARRAY
33132: PPUSH
33133: CALL_OW 459
33137: NOT
33138: AND
33139: PUSH
33140: LD_EXP 101
33144: PUSH
33145: LD_VAR 0 2
33149: ARRAY
33150: PUSH
33151: LD_VAR 0 3
33155: ARRAY
33156: PPUSH
33157: CALL_OW 314
33161: NOT
33162: AND
33163: IFFALSE 33331
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33165: LD_EXP 101
33169: PUSH
33170: LD_VAR 0 2
33174: ARRAY
33175: PUSH
33176: LD_VAR 0 3
33180: ARRAY
33181: PPUSH
33182: CALL_OW 310
33186: IFFALSE 33209
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33188: LD_EXP 101
33192: PUSH
33193: LD_VAR 0 2
33197: ARRAY
33198: PUSH
33199: LD_VAR 0 3
33203: ARRAY
33204: PPUSH
33205: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33209: LD_EXP 101
33213: PUSH
33214: LD_VAR 0 2
33218: ARRAY
33219: PUSH
33220: LD_VAR 0 3
33224: ARRAY
33225: PPUSH
33226: CALL_OW 314
33230: NOT
33231: IFFALSE 33331
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33233: LD_EXP 101
33237: PUSH
33238: LD_VAR 0 2
33242: ARRAY
33243: PUSH
33244: LD_VAR 0 3
33248: ARRAY
33249: PPUSH
33250: LD_EXP 100
33254: PUSH
33255: LD_VAR 0 2
33259: ARRAY
33260: PUSH
33261: LD_VAR 0 3
33265: PUSH
33266: LD_EXP 100
33270: PUSH
33271: LD_VAR 0 2
33275: ARRAY
33276: MOD
33277: PUSH
33278: LD_INT 1
33280: PLUS
33281: ARRAY
33282: PUSH
33283: LD_INT 1
33285: ARRAY
33286: PPUSH
33287: LD_EXP 100
33291: PUSH
33292: LD_VAR 0 2
33296: ARRAY
33297: PUSH
33298: LD_VAR 0 3
33302: PUSH
33303: LD_EXP 100
33307: PUSH
33308: LD_VAR 0 2
33312: ARRAY
33313: MOD
33314: PUSH
33315: LD_INT 1
33317: PLUS
33318: ARRAY
33319: PUSH
33320: LD_INT 2
33322: ARRAY
33323: PPUSH
33324: LD_INT 0
33326: PPUSH
33327: CALL_OW 193
// end ; end ;
33331: GO 32976
33333: POP
33334: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33335: LD_ADDR_VAR 0 5
33339: PUSH
33340: LD_EXP 87
33344: PUSH
33345: LD_VAR 0 2
33349: ARRAY
33350: PPUSH
33351: LD_INT 2
33353: PUSH
33354: LD_INT 30
33356: PUSH
33357: LD_INT 4
33359: PUSH
33360: EMPTY
33361: LIST
33362: LIST
33363: PUSH
33364: LD_INT 30
33366: PUSH
33367: LD_INT 5
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PUSH
33374: LD_INT 30
33376: PUSH
33377: LD_INT 32
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: PPUSH
33390: CALL_OW 72
33394: ST_TO_ADDR
// if not tmp then
33395: LD_VAR 0 5
33399: NOT
33400: IFFALSE 33404
// continue ;
33402: GO 32889
// list := [ ] ;
33404: LD_ADDR_VAR 0 6
33408: PUSH
33409: EMPTY
33410: ST_TO_ADDR
// for j in tmp do
33411: LD_ADDR_VAR 0 3
33415: PUSH
33416: LD_VAR 0 5
33420: PUSH
33421: FOR_IN
33422: IFFALSE 33491
// begin for k in UnitsInside ( j ) do
33424: LD_ADDR_VAR 0 4
33428: PUSH
33429: LD_VAR 0 3
33433: PPUSH
33434: CALL_OW 313
33438: PUSH
33439: FOR_IN
33440: IFFALSE 33487
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33442: LD_VAR 0 4
33446: PPUSH
33447: CALL_OW 257
33451: PUSH
33452: LD_INT 1
33454: EQUAL
33455: PUSH
33456: LD_VAR 0 4
33460: PPUSH
33461: CALL_OW 459
33465: NOT
33466: AND
33467: IFFALSE 33485
// list := list ^ k ;
33469: LD_ADDR_VAR 0 6
33473: PUSH
33474: LD_VAR 0 6
33478: PUSH
33479: LD_VAR 0 4
33483: ADD
33484: ST_TO_ADDR
33485: GO 33439
33487: POP
33488: POP
// end ;
33489: GO 33421
33491: POP
33492: POP
// list := list diff mc_miners [ i ] ;
33493: LD_ADDR_VAR 0 6
33497: PUSH
33498: LD_VAR 0 6
33502: PUSH
33503: LD_EXP 101
33507: PUSH
33508: LD_VAR 0 2
33512: ARRAY
33513: DIFF
33514: ST_TO_ADDR
// if not list then
33515: LD_VAR 0 6
33519: NOT
33520: IFFALSE 33524
// continue ;
33522: GO 32889
// k := mc_mines [ i ] - mc_miners [ i ] ;
33524: LD_ADDR_VAR 0 4
33528: PUSH
33529: LD_EXP 100
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: PUSH
33540: LD_EXP 101
33544: PUSH
33545: LD_VAR 0 2
33549: ARRAY
33550: MINUS
33551: ST_TO_ADDR
// if k > list then
33552: LD_VAR 0 4
33556: PUSH
33557: LD_VAR 0 6
33561: GREATER
33562: IFFALSE 33574
// k := list ;
33564: LD_ADDR_VAR 0 4
33568: PUSH
33569: LD_VAR 0 6
33573: ST_TO_ADDR
// for j = 1 to k do
33574: LD_ADDR_VAR 0 3
33578: PUSH
33579: DOUBLE
33580: LD_INT 1
33582: DEC
33583: ST_TO_ADDR
33584: LD_VAR 0 4
33588: PUSH
33589: FOR_TO
33590: IFFALSE 33644
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33592: LD_ADDR_EXP 101
33596: PUSH
33597: LD_EXP 101
33601: PPUSH
33602: LD_VAR 0 2
33606: PUSH
33607: LD_EXP 101
33611: PUSH
33612: LD_VAR 0 2
33616: ARRAY
33617: PUSH
33618: LD_INT 1
33620: PLUS
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PPUSH
33626: LD_VAR 0 6
33630: PUSH
33631: LD_VAR 0 3
33635: ARRAY
33636: PPUSH
33637: CALL 55547 0 3
33641: ST_TO_ADDR
33642: GO 33589
33644: POP
33645: POP
// end ;
33646: GO 32889
33648: POP
33649: POP
// end ;
33650: LD_VAR 0 1
33654: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33655: LD_INT 0
33657: PPUSH
33658: PPUSH
33659: PPUSH
33660: PPUSH
33661: PPUSH
33662: PPUSH
33663: PPUSH
33664: PPUSH
33665: PPUSH
33666: PPUSH
// if not mc_bases then
33667: LD_EXP 87
33671: NOT
33672: IFFALSE 33676
// exit ;
33674: GO 35426
// for i = 1 to mc_bases do
33676: LD_ADDR_VAR 0 2
33680: PUSH
33681: DOUBLE
33682: LD_INT 1
33684: DEC
33685: ST_TO_ADDR
33686: LD_EXP 87
33690: PUSH
33691: FOR_TO
33692: IFFALSE 35424
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33694: LD_EXP 87
33698: PUSH
33699: LD_VAR 0 2
33703: ARRAY
33704: NOT
33705: PUSH
33706: LD_EXP 94
33710: PUSH
33711: LD_VAR 0 2
33715: ARRAY
33716: OR
33717: IFFALSE 33721
// continue ;
33719: GO 33691
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33721: LD_EXP 103
33725: PUSH
33726: LD_VAR 0 2
33730: ARRAY
33731: NOT
33732: PUSH
33733: LD_EXP 104
33737: PUSH
33738: LD_VAR 0 2
33742: ARRAY
33743: AND
33744: IFFALSE 33782
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33746: LD_ADDR_EXP 104
33750: PUSH
33751: LD_EXP 104
33755: PPUSH
33756: LD_VAR 0 2
33760: PPUSH
33761: EMPTY
33762: PPUSH
33763: CALL_OW 1
33767: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33768: LD_VAR 0 2
33772: PPUSH
33773: LD_INT 107
33775: PPUSH
33776: CALL 24656 0 2
// continue ;
33780: GO 33691
// end ; target := [ ] ;
33782: LD_ADDR_VAR 0 6
33786: PUSH
33787: EMPTY
33788: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33789: LD_ADDR_VAR 0 3
33793: PUSH
33794: DOUBLE
33795: LD_EXP 103
33799: PUSH
33800: LD_VAR 0 2
33804: ARRAY
33805: INC
33806: ST_TO_ADDR
33807: LD_INT 1
33809: PUSH
33810: FOR_DOWNTO
33811: IFFALSE 34071
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33813: LD_EXP 103
33817: PUSH
33818: LD_VAR 0 2
33822: ARRAY
33823: PUSH
33824: LD_VAR 0 3
33828: ARRAY
33829: PUSH
33830: LD_INT 2
33832: ARRAY
33833: PPUSH
33834: LD_EXP 103
33838: PUSH
33839: LD_VAR 0 2
33843: ARRAY
33844: PUSH
33845: LD_VAR 0 3
33849: ARRAY
33850: PUSH
33851: LD_INT 3
33853: ARRAY
33854: PPUSH
33855: CALL_OW 488
33859: PUSH
33860: LD_EXP 103
33864: PUSH
33865: LD_VAR 0 2
33869: ARRAY
33870: PUSH
33871: LD_VAR 0 3
33875: ARRAY
33876: PUSH
33877: LD_INT 2
33879: ARRAY
33880: PPUSH
33881: LD_EXP 103
33885: PUSH
33886: LD_VAR 0 2
33890: ARRAY
33891: PUSH
33892: LD_VAR 0 3
33896: ARRAY
33897: PUSH
33898: LD_INT 3
33900: ARRAY
33901: PPUSH
33902: CALL_OW 284
33906: PUSH
33907: LD_INT 0
33909: EQUAL
33910: AND
33911: IFFALSE 33966
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33913: LD_ADDR_VAR 0 5
33917: PUSH
33918: LD_EXP 103
33922: PUSH
33923: LD_VAR 0 2
33927: ARRAY
33928: PPUSH
33929: LD_VAR 0 3
33933: PPUSH
33934: CALL_OW 3
33938: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33939: LD_ADDR_EXP 103
33943: PUSH
33944: LD_EXP 103
33948: PPUSH
33949: LD_VAR 0 2
33953: PPUSH
33954: LD_VAR 0 5
33958: PPUSH
33959: CALL_OW 1
33963: ST_TO_ADDR
// continue ;
33964: GO 33810
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33966: LD_EXP 87
33970: PUSH
33971: LD_VAR 0 2
33975: ARRAY
33976: PUSH
33977: LD_INT 1
33979: ARRAY
33980: PPUSH
33981: CALL_OW 255
33985: PPUSH
33986: LD_EXP 103
33990: PUSH
33991: LD_VAR 0 2
33995: ARRAY
33996: PUSH
33997: LD_VAR 0 3
34001: ARRAY
34002: PUSH
34003: LD_INT 2
34005: ARRAY
34006: PPUSH
34007: LD_EXP 103
34011: PUSH
34012: LD_VAR 0 2
34016: ARRAY
34017: PUSH
34018: LD_VAR 0 3
34022: ARRAY
34023: PUSH
34024: LD_INT 3
34026: ARRAY
34027: PPUSH
34028: LD_INT 30
34030: PPUSH
34031: CALL 56443 0 4
34035: PUSH
34036: LD_INT 4
34038: ARRAY
34039: PUSH
34040: LD_INT 0
34042: EQUAL
34043: IFFALSE 34069
// begin target := mc_crates [ i ] [ j ] ;
34045: LD_ADDR_VAR 0 6
34049: PUSH
34050: LD_EXP 103
34054: PUSH
34055: LD_VAR 0 2
34059: ARRAY
34060: PUSH
34061: LD_VAR 0 3
34065: ARRAY
34066: ST_TO_ADDR
// break ;
34067: GO 34071
// end ; end ;
34069: GO 33810
34071: POP
34072: POP
// if not target then
34073: LD_VAR 0 6
34077: NOT
34078: IFFALSE 34082
// continue ;
34080: GO 33691
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34082: LD_ADDR_VAR 0 7
34086: PUSH
34087: LD_EXP 106
34091: PUSH
34092: LD_VAR 0 2
34096: ARRAY
34097: PPUSH
34098: LD_INT 2
34100: PUSH
34101: LD_INT 3
34103: PUSH
34104: LD_INT 58
34106: PUSH
34107: EMPTY
34108: LIST
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 61
34116: PUSH
34117: EMPTY
34118: LIST
34119: PUSH
34120: LD_INT 33
34122: PUSH
34123: LD_INT 5
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 33
34132: PUSH
34133: LD_INT 3
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: LIST
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 2
34149: PUSH
34150: LD_INT 34
34152: PUSH
34153: LD_INT 32
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 34
34162: PUSH
34163: LD_INT 51
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 34
34172: PUSH
34173: LD_INT 12
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PPUSH
34190: CALL_OW 72
34194: ST_TO_ADDR
// if not cargo then
34195: LD_VAR 0 7
34199: NOT
34200: IFFALSE 34843
// begin if mc_crates_collector [ i ] < 5 then
34202: LD_EXP 104
34206: PUSH
34207: LD_VAR 0 2
34211: ARRAY
34212: PUSH
34213: LD_INT 5
34215: LESS
34216: IFFALSE 34582
// begin if mc_ape [ i ] then
34218: LD_EXP 116
34222: PUSH
34223: LD_VAR 0 2
34227: ARRAY
34228: IFFALSE 34275
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34230: LD_ADDR_VAR 0 5
34234: PUSH
34235: LD_EXP 116
34239: PUSH
34240: LD_VAR 0 2
34244: ARRAY
34245: PPUSH
34246: LD_INT 25
34248: PUSH
34249: LD_INT 16
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 24
34258: PUSH
34259: LD_INT 750
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PPUSH
34270: CALL_OW 72
34274: ST_TO_ADDR
// if not tmp then
34275: LD_VAR 0 5
34279: NOT
34280: IFFALSE 34327
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34282: LD_ADDR_VAR 0 5
34286: PUSH
34287: LD_EXP 87
34291: PUSH
34292: LD_VAR 0 2
34296: ARRAY
34297: PPUSH
34298: LD_INT 25
34300: PUSH
34301: LD_INT 2
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 24
34310: PUSH
34311: LD_INT 750
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PPUSH
34322: CALL_OW 72
34326: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34327: LD_EXP 116
34331: PUSH
34332: LD_VAR 0 2
34336: ARRAY
34337: PUSH
34338: LD_EXP 87
34342: PUSH
34343: LD_VAR 0 2
34347: ARRAY
34348: PPUSH
34349: LD_INT 25
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 24
34361: PUSH
34362: LD_INT 750
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PPUSH
34373: CALL_OW 72
34377: AND
34378: PUSH
34379: LD_VAR 0 5
34383: PUSH
34384: LD_INT 5
34386: LESS
34387: AND
34388: IFFALSE 34470
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34390: LD_ADDR_VAR 0 3
34394: PUSH
34395: LD_EXP 87
34399: PUSH
34400: LD_VAR 0 2
34404: ARRAY
34405: PPUSH
34406: LD_INT 25
34408: PUSH
34409: LD_INT 2
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 24
34418: PUSH
34419: LD_INT 750
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PPUSH
34430: CALL_OW 72
34434: PUSH
34435: FOR_IN
34436: IFFALSE 34468
// begin tmp := tmp union j ;
34438: LD_ADDR_VAR 0 5
34442: PUSH
34443: LD_VAR 0 5
34447: PUSH
34448: LD_VAR 0 3
34452: UNION
34453: ST_TO_ADDR
// if tmp >= 5 then
34454: LD_VAR 0 5
34458: PUSH
34459: LD_INT 5
34461: GREATEREQUAL
34462: IFFALSE 34466
// break ;
34464: GO 34468
// end ;
34466: GO 34435
34468: POP
34469: POP
// end ; if not tmp then
34470: LD_VAR 0 5
34474: NOT
34475: IFFALSE 34479
// continue ;
34477: GO 33691
// for j in tmp do
34479: LD_ADDR_VAR 0 3
34483: PUSH
34484: LD_VAR 0 5
34488: PUSH
34489: FOR_IN
34490: IFFALSE 34580
// if not GetTag ( j ) then
34492: LD_VAR 0 3
34496: PPUSH
34497: CALL_OW 110
34501: NOT
34502: IFFALSE 34578
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34504: LD_ADDR_EXP 104
34508: PUSH
34509: LD_EXP 104
34513: PPUSH
34514: LD_VAR 0 2
34518: PUSH
34519: LD_EXP 104
34523: PUSH
34524: LD_VAR 0 2
34528: ARRAY
34529: PUSH
34530: LD_INT 1
34532: PLUS
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PPUSH
34538: LD_VAR 0 3
34542: PPUSH
34543: CALL 55547 0 3
34547: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34548: LD_VAR 0 3
34552: PPUSH
34553: LD_INT 107
34555: PPUSH
34556: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34560: LD_EXP 104
34564: PUSH
34565: LD_VAR 0 2
34569: ARRAY
34570: PUSH
34571: LD_INT 5
34573: GREATEREQUAL
34574: IFFALSE 34578
// break ;
34576: GO 34580
// end ;
34578: GO 34489
34580: POP
34581: POP
// end ; if mc_crates_collector [ i ] and target then
34582: LD_EXP 104
34586: PUSH
34587: LD_VAR 0 2
34591: ARRAY
34592: PUSH
34593: LD_VAR 0 6
34597: AND
34598: IFFALSE 34841
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34600: LD_EXP 104
34604: PUSH
34605: LD_VAR 0 2
34609: ARRAY
34610: PUSH
34611: LD_VAR 0 6
34615: PUSH
34616: LD_INT 1
34618: ARRAY
34619: LESS
34620: IFFALSE 34640
// tmp := mc_crates_collector [ i ] else
34622: LD_ADDR_VAR 0 5
34626: PUSH
34627: LD_EXP 104
34631: PUSH
34632: LD_VAR 0 2
34636: ARRAY
34637: ST_TO_ADDR
34638: GO 34654
// tmp := target [ 1 ] ;
34640: LD_ADDR_VAR 0 5
34644: PUSH
34645: LD_VAR 0 6
34649: PUSH
34650: LD_INT 1
34652: ARRAY
34653: ST_TO_ADDR
// k := 0 ;
34654: LD_ADDR_VAR 0 4
34658: PUSH
34659: LD_INT 0
34661: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34662: LD_ADDR_VAR 0 3
34666: PUSH
34667: LD_EXP 104
34671: PUSH
34672: LD_VAR 0 2
34676: ARRAY
34677: PUSH
34678: FOR_IN
34679: IFFALSE 34839
// begin k := k + 1 ;
34681: LD_ADDR_VAR 0 4
34685: PUSH
34686: LD_VAR 0 4
34690: PUSH
34691: LD_INT 1
34693: PLUS
34694: ST_TO_ADDR
// if k > tmp then
34695: LD_VAR 0 4
34699: PUSH
34700: LD_VAR 0 5
34704: GREATER
34705: IFFALSE 34709
// break ;
34707: GO 34839
// if not GetClass ( j ) in [ 2 , 16 ] then
34709: LD_VAR 0 3
34713: PPUSH
34714: CALL_OW 257
34718: PUSH
34719: LD_INT 2
34721: PUSH
34722: LD_INT 16
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: IN
34729: NOT
34730: IFFALSE 34783
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34732: LD_ADDR_EXP 104
34736: PUSH
34737: LD_EXP 104
34741: PPUSH
34742: LD_VAR 0 2
34746: PPUSH
34747: LD_EXP 104
34751: PUSH
34752: LD_VAR 0 2
34756: ARRAY
34757: PUSH
34758: LD_VAR 0 3
34762: DIFF
34763: PPUSH
34764: CALL_OW 1
34768: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34769: LD_VAR 0 3
34773: PPUSH
34774: LD_INT 0
34776: PPUSH
34777: CALL_OW 109
// continue ;
34781: GO 34678
// end ; if IsInUnit ( j ) then
34783: LD_VAR 0 3
34787: PPUSH
34788: CALL_OW 310
34792: IFFALSE 34803
// ComExitBuilding ( j ) ;
34794: LD_VAR 0 3
34798: PPUSH
34799: CALL_OW 122
// wait ( 3 ) ;
34803: LD_INT 3
34805: PPUSH
34806: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34810: LD_VAR 0 3
34814: PPUSH
34815: LD_VAR 0 6
34819: PUSH
34820: LD_INT 2
34822: ARRAY
34823: PPUSH
34824: LD_VAR 0 6
34828: PUSH
34829: LD_INT 3
34831: ARRAY
34832: PPUSH
34833: CALL_OW 117
// end ;
34837: GO 34678
34839: POP
34840: POP
// end ; end else
34841: GO 35422
// begin for j in cargo do
34843: LD_ADDR_VAR 0 3
34847: PUSH
34848: LD_VAR 0 7
34852: PUSH
34853: FOR_IN
34854: IFFALSE 35420
// begin if GetTag ( j ) <> 0 then
34856: LD_VAR 0 3
34860: PPUSH
34861: CALL_OW 110
34865: PUSH
34866: LD_INT 0
34868: NONEQUAL
34869: IFFALSE 34873
// continue ;
34871: GO 34853
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34873: LD_VAR 0 3
34877: PPUSH
34878: CALL_OW 256
34882: PUSH
34883: LD_INT 1000
34885: LESS
34886: PUSH
34887: LD_VAR 0 3
34891: PPUSH
34892: LD_EXP 111
34896: PUSH
34897: LD_VAR 0 2
34901: ARRAY
34902: PPUSH
34903: CALL_OW 308
34907: NOT
34908: AND
34909: IFFALSE 34931
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34911: LD_VAR 0 3
34915: PPUSH
34916: LD_EXP 111
34920: PUSH
34921: LD_VAR 0 2
34925: ARRAY
34926: PPUSH
34927: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34931: LD_VAR 0 3
34935: PPUSH
34936: CALL_OW 256
34940: PUSH
34941: LD_INT 1000
34943: LESS
34944: PUSH
34945: LD_VAR 0 3
34949: PPUSH
34950: LD_EXP 111
34954: PUSH
34955: LD_VAR 0 2
34959: ARRAY
34960: PPUSH
34961: CALL_OW 308
34965: AND
34966: IFFALSE 34970
// continue ;
34968: GO 34853
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34970: LD_VAR 0 3
34974: PPUSH
34975: CALL_OW 262
34979: PUSH
34980: LD_INT 2
34982: EQUAL
34983: PUSH
34984: LD_VAR 0 3
34988: PPUSH
34989: CALL_OW 261
34993: PUSH
34994: LD_INT 15
34996: LESS
34997: AND
34998: IFFALSE 35002
// continue ;
35000: GO 34853
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35002: LD_VAR 0 3
35006: PPUSH
35007: CALL_OW 262
35011: PUSH
35012: LD_INT 1
35014: EQUAL
35015: PUSH
35016: LD_VAR 0 3
35020: PPUSH
35021: CALL_OW 261
35025: PUSH
35026: LD_INT 10
35028: LESS
35029: AND
35030: IFFALSE 35359
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35032: LD_ADDR_VAR 0 8
35036: PUSH
35037: LD_EXP 87
35041: PUSH
35042: LD_VAR 0 2
35046: ARRAY
35047: PPUSH
35048: LD_INT 2
35050: PUSH
35051: LD_INT 30
35053: PUSH
35054: LD_INT 0
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 30
35063: PUSH
35064: LD_INT 1
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: LIST
35075: PPUSH
35076: CALL_OW 72
35080: ST_TO_ADDR
// if not depot then
35081: LD_VAR 0 8
35085: NOT
35086: IFFALSE 35090
// continue ;
35088: GO 34853
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35090: LD_VAR 0 3
35094: PPUSH
35095: LD_VAR 0 8
35099: PPUSH
35100: LD_VAR 0 3
35104: PPUSH
35105: CALL_OW 74
35109: PPUSH
35110: CALL_OW 296
35114: PUSH
35115: LD_INT 6
35117: LESS
35118: IFFALSE 35134
// SetFuel ( j , 100 ) else
35120: LD_VAR 0 3
35124: PPUSH
35125: LD_INT 100
35127: PPUSH
35128: CALL_OW 240
35132: GO 35359
// if GetFuel ( j ) = 0 then
35134: LD_VAR 0 3
35138: PPUSH
35139: CALL_OW 261
35143: PUSH
35144: LD_INT 0
35146: EQUAL
35147: IFFALSE 35359
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35149: LD_ADDR_EXP 106
35153: PUSH
35154: LD_EXP 106
35158: PPUSH
35159: LD_VAR 0 2
35163: PPUSH
35164: LD_EXP 106
35168: PUSH
35169: LD_VAR 0 2
35173: ARRAY
35174: PUSH
35175: LD_VAR 0 3
35179: DIFF
35180: PPUSH
35181: CALL_OW 1
35185: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35186: LD_VAR 0 3
35190: PPUSH
35191: CALL_OW 263
35195: PUSH
35196: LD_INT 1
35198: EQUAL
35199: IFFALSE 35215
// ComExitVehicle ( IsInUnit ( j ) ) ;
35201: LD_VAR 0 3
35205: PPUSH
35206: CALL_OW 310
35210: PPUSH
35211: CALL_OW 121
// if GetControl ( j ) = control_remote then
35215: LD_VAR 0 3
35219: PPUSH
35220: CALL_OW 263
35224: PUSH
35225: LD_INT 2
35227: EQUAL
35228: IFFALSE 35239
// ComUnlink ( j ) ;
35230: LD_VAR 0 3
35234: PPUSH
35235: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35239: LD_ADDR_VAR 0 9
35243: PUSH
35244: LD_VAR 0 2
35248: PPUSH
35249: LD_INT 3
35251: PPUSH
35252: CALL 44712 0 2
35256: ST_TO_ADDR
// if fac then
35257: LD_VAR 0 9
35261: IFFALSE 35357
// begin for k in fac do
35263: LD_ADDR_VAR 0 4
35267: PUSH
35268: LD_VAR 0 9
35272: PUSH
35273: FOR_IN
35274: IFFALSE 35355
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35276: LD_ADDR_VAR 0 10
35280: PUSH
35281: LD_VAR 0 9
35285: PPUSH
35286: LD_VAR 0 3
35290: PPUSH
35291: CALL_OW 265
35295: PPUSH
35296: LD_VAR 0 3
35300: PPUSH
35301: CALL_OW 262
35305: PPUSH
35306: LD_VAR 0 3
35310: PPUSH
35311: CALL_OW 263
35315: PPUSH
35316: LD_VAR 0 3
35320: PPUSH
35321: CALL_OW 264
35325: PPUSH
35326: CALL 53079 0 5
35330: ST_TO_ADDR
// if components then
35331: LD_VAR 0 10
35335: IFFALSE 35353
// begin MC_InsertProduceList ( i , components ) ;
35337: LD_VAR 0 2
35341: PPUSH
35342: LD_VAR 0 10
35346: PPUSH
35347: CALL 44257 0 2
// break ;
35351: GO 35355
// end ; end ;
35353: GO 35273
35355: POP
35356: POP
// end ; continue ;
35357: GO 34853
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35359: LD_VAR 0 3
35363: PPUSH
35364: LD_INT 1
35366: PPUSH
35367: CALL_OW 289
35371: PUSH
35372: LD_INT 100
35374: LESS
35375: PUSH
35376: LD_VAR 0 3
35380: PPUSH
35381: CALL_OW 314
35385: NOT
35386: AND
35387: IFFALSE 35416
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35389: LD_VAR 0 3
35393: PPUSH
35394: LD_VAR 0 6
35398: PUSH
35399: LD_INT 2
35401: ARRAY
35402: PPUSH
35403: LD_VAR 0 6
35407: PUSH
35408: LD_INT 3
35410: ARRAY
35411: PPUSH
35412: CALL_OW 117
// break ;
35416: GO 35420
// end ;
35418: GO 34853
35420: POP
35421: POP
// end ; end ;
35422: GO 33691
35424: POP
35425: POP
// end ;
35426: LD_VAR 0 1
35430: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35431: LD_INT 0
35433: PPUSH
35434: PPUSH
35435: PPUSH
35436: PPUSH
// if not mc_bases then
35437: LD_EXP 87
35441: NOT
35442: IFFALSE 35446
// exit ;
35444: GO 35607
// for i = 1 to mc_bases do
35446: LD_ADDR_VAR 0 2
35450: PUSH
35451: DOUBLE
35452: LD_INT 1
35454: DEC
35455: ST_TO_ADDR
35456: LD_EXP 87
35460: PUSH
35461: FOR_TO
35462: IFFALSE 35605
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35464: LD_ADDR_VAR 0 4
35468: PUSH
35469: LD_EXP 106
35473: PUSH
35474: LD_VAR 0 2
35478: ARRAY
35479: PUSH
35480: LD_EXP 109
35484: PUSH
35485: LD_VAR 0 2
35489: ARRAY
35490: UNION
35491: PPUSH
35492: LD_INT 33
35494: PUSH
35495: LD_INT 2
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PPUSH
35502: CALL_OW 72
35506: ST_TO_ADDR
// if tmp then
35507: LD_VAR 0 4
35511: IFFALSE 35603
// for j in tmp do
35513: LD_ADDR_VAR 0 3
35517: PUSH
35518: LD_VAR 0 4
35522: PUSH
35523: FOR_IN
35524: IFFALSE 35601
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35526: LD_VAR 0 3
35530: PPUSH
35531: CALL_OW 312
35535: NOT
35536: PUSH
35537: LD_VAR 0 3
35541: PPUSH
35542: CALL_OW 256
35546: PUSH
35547: LD_INT 250
35549: GREATEREQUAL
35550: AND
35551: IFFALSE 35564
// Connect ( j ) else
35553: LD_VAR 0 3
35557: PPUSH
35558: CALL 58480 0 1
35562: GO 35599
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35564: LD_VAR 0 3
35568: PPUSH
35569: CALL_OW 256
35573: PUSH
35574: LD_INT 250
35576: LESS
35577: PUSH
35578: LD_VAR 0 3
35582: PPUSH
35583: CALL_OW 312
35587: AND
35588: IFFALSE 35599
// ComUnlink ( j ) ;
35590: LD_VAR 0 3
35594: PPUSH
35595: CALL_OW 136
35599: GO 35523
35601: POP
35602: POP
// end ;
35603: GO 35461
35605: POP
35606: POP
// end ;
35607: LD_VAR 0 1
35611: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35612: LD_INT 0
35614: PPUSH
35615: PPUSH
35616: PPUSH
35617: PPUSH
35618: PPUSH
// if not mc_bases then
35619: LD_EXP 87
35623: NOT
35624: IFFALSE 35628
// exit ;
35626: GO 36073
// for i = 1 to mc_bases do
35628: LD_ADDR_VAR 0 2
35632: PUSH
35633: DOUBLE
35634: LD_INT 1
35636: DEC
35637: ST_TO_ADDR
35638: LD_EXP 87
35642: PUSH
35643: FOR_TO
35644: IFFALSE 36071
// begin if not mc_produce [ i ] then
35646: LD_EXP 108
35650: PUSH
35651: LD_VAR 0 2
35655: ARRAY
35656: NOT
35657: IFFALSE 35661
// continue ;
35659: GO 35643
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35661: LD_ADDR_VAR 0 5
35665: PUSH
35666: LD_EXP 87
35670: PUSH
35671: LD_VAR 0 2
35675: ARRAY
35676: PPUSH
35677: LD_INT 30
35679: PUSH
35680: LD_INT 3
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PPUSH
35687: CALL_OW 72
35691: ST_TO_ADDR
// if not fac then
35692: LD_VAR 0 5
35696: NOT
35697: IFFALSE 35701
// continue ;
35699: GO 35643
// for j in fac do
35701: LD_ADDR_VAR 0 3
35705: PUSH
35706: LD_VAR 0 5
35710: PUSH
35711: FOR_IN
35712: IFFALSE 36067
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35714: LD_VAR 0 3
35718: PPUSH
35719: CALL_OW 461
35723: PUSH
35724: LD_INT 2
35726: NONEQUAL
35727: PUSH
35728: LD_VAR 0 3
35732: PPUSH
35733: LD_INT 15
35735: PPUSH
35736: CALL 58140 0 2
35740: PUSH
35741: LD_INT 4
35743: ARRAY
35744: OR
35745: IFFALSE 35749
// continue ;
35747: GO 35711
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35749: LD_VAR 0 3
35753: PPUSH
35754: LD_EXP 108
35758: PUSH
35759: LD_VAR 0 2
35763: ARRAY
35764: PUSH
35765: LD_INT 1
35767: ARRAY
35768: PUSH
35769: LD_INT 1
35771: ARRAY
35772: PPUSH
35773: LD_EXP 108
35777: PUSH
35778: LD_VAR 0 2
35782: ARRAY
35783: PUSH
35784: LD_INT 1
35786: ARRAY
35787: PUSH
35788: LD_INT 2
35790: ARRAY
35791: PPUSH
35792: LD_EXP 108
35796: PUSH
35797: LD_VAR 0 2
35801: ARRAY
35802: PUSH
35803: LD_INT 1
35805: ARRAY
35806: PUSH
35807: LD_INT 3
35809: ARRAY
35810: PPUSH
35811: LD_EXP 108
35815: PUSH
35816: LD_VAR 0 2
35820: ARRAY
35821: PUSH
35822: LD_INT 1
35824: ARRAY
35825: PUSH
35826: LD_INT 4
35828: ARRAY
35829: PPUSH
35830: CALL_OW 448
35834: PUSH
35835: LD_VAR 0 3
35839: PPUSH
35840: LD_EXP 108
35844: PUSH
35845: LD_VAR 0 2
35849: ARRAY
35850: PUSH
35851: LD_INT 1
35853: ARRAY
35854: PUSH
35855: LD_INT 1
35857: ARRAY
35858: PUSH
35859: LD_EXP 108
35863: PUSH
35864: LD_VAR 0 2
35868: ARRAY
35869: PUSH
35870: LD_INT 1
35872: ARRAY
35873: PUSH
35874: LD_INT 2
35876: ARRAY
35877: PUSH
35878: LD_EXP 108
35882: PUSH
35883: LD_VAR 0 2
35887: ARRAY
35888: PUSH
35889: LD_INT 1
35891: ARRAY
35892: PUSH
35893: LD_INT 3
35895: ARRAY
35896: PUSH
35897: LD_EXP 108
35901: PUSH
35902: LD_VAR 0 2
35906: ARRAY
35907: PUSH
35908: LD_INT 1
35910: ARRAY
35911: PUSH
35912: LD_INT 4
35914: ARRAY
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: LIST
35920: LIST
35921: PPUSH
35922: CALL 61811 0 2
35926: AND
35927: IFFALSE 36065
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35929: LD_VAR 0 3
35933: PPUSH
35934: LD_EXP 108
35938: PUSH
35939: LD_VAR 0 2
35943: ARRAY
35944: PUSH
35945: LD_INT 1
35947: ARRAY
35948: PUSH
35949: LD_INT 1
35951: ARRAY
35952: PPUSH
35953: LD_EXP 108
35957: PUSH
35958: LD_VAR 0 2
35962: ARRAY
35963: PUSH
35964: LD_INT 1
35966: ARRAY
35967: PUSH
35968: LD_INT 2
35970: ARRAY
35971: PPUSH
35972: LD_EXP 108
35976: PUSH
35977: LD_VAR 0 2
35981: ARRAY
35982: PUSH
35983: LD_INT 1
35985: ARRAY
35986: PUSH
35987: LD_INT 3
35989: ARRAY
35990: PPUSH
35991: LD_EXP 108
35995: PUSH
35996: LD_VAR 0 2
36000: ARRAY
36001: PUSH
36002: LD_INT 1
36004: ARRAY
36005: PUSH
36006: LD_INT 4
36008: ARRAY
36009: PPUSH
36010: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36014: LD_ADDR_VAR 0 4
36018: PUSH
36019: LD_EXP 108
36023: PUSH
36024: LD_VAR 0 2
36028: ARRAY
36029: PPUSH
36030: LD_INT 1
36032: PPUSH
36033: CALL_OW 3
36037: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36038: LD_ADDR_EXP 108
36042: PUSH
36043: LD_EXP 108
36047: PPUSH
36048: LD_VAR 0 2
36052: PPUSH
36053: LD_VAR 0 4
36057: PPUSH
36058: CALL_OW 1
36062: ST_TO_ADDR
// break ;
36063: GO 36067
// end ; end ;
36065: GO 35711
36067: POP
36068: POP
// end ;
36069: GO 35643
36071: POP
36072: POP
// end ;
36073: LD_VAR 0 1
36077: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36078: LD_INT 0
36080: PPUSH
36081: PPUSH
36082: PPUSH
// if not mc_bases then
36083: LD_EXP 87
36087: NOT
36088: IFFALSE 36092
// exit ;
36090: GO 36181
// for i = 1 to mc_bases do
36092: LD_ADDR_VAR 0 2
36096: PUSH
36097: DOUBLE
36098: LD_INT 1
36100: DEC
36101: ST_TO_ADDR
36102: LD_EXP 87
36106: PUSH
36107: FOR_TO
36108: IFFALSE 36179
// begin if mc_attack [ i ] then
36110: LD_EXP 107
36114: PUSH
36115: LD_VAR 0 2
36119: ARRAY
36120: IFFALSE 36177
// begin tmp := mc_attack [ i ] [ 1 ] ;
36122: LD_ADDR_VAR 0 3
36126: PUSH
36127: LD_EXP 107
36131: PUSH
36132: LD_VAR 0 2
36136: ARRAY
36137: PUSH
36138: LD_INT 1
36140: ARRAY
36141: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36142: LD_ADDR_EXP 107
36146: PUSH
36147: LD_EXP 107
36151: PPUSH
36152: LD_VAR 0 2
36156: PPUSH
36157: EMPTY
36158: PPUSH
36159: CALL_OW 1
36163: ST_TO_ADDR
// Attack ( tmp ) ;
36164: LD_VAR 0 3
36168: PPUSH
36169: CALL 98443 0 1
// exit ;
36173: POP
36174: POP
36175: GO 36181
// end ; end ;
36177: GO 36107
36179: POP
36180: POP
// end ;
36181: LD_VAR 0 1
36185: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36186: LD_INT 0
36188: PPUSH
36189: PPUSH
36190: PPUSH
36191: PPUSH
36192: PPUSH
36193: PPUSH
36194: PPUSH
// if not mc_bases then
36195: LD_EXP 87
36199: NOT
36200: IFFALSE 36204
// exit ;
36202: GO 36786
// for i = 1 to mc_bases do
36204: LD_ADDR_VAR 0 2
36208: PUSH
36209: DOUBLE
36210: LD_INT 1
36212: DEC
36213: ST_TO_ADDR
36214: LD_EXP 87
36218: PUSH
36219: FOR_TO
36220: IFFALSE 36784
// begin if not mc_bases [ i ] then
36222: LD_EXP 87
36226: PUSH
36227: LD_VAR 0 2
36231: ARRAY
36232: NOT
36233: IFFALSE 36237
// continue ;
36235: GO 36219
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36237: LD_ADDR_VAR 0 7
36241: PUSH
36242: LD_EXP 87
36246: PUSH
36247: LD_VAR 0 2
36251: ARRAY
36252: PUSH
36253: LD_INT 1
36255: ARRAY
36256: PPUSH
36257: CALL 52383 0 1
36261: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36262: LD_ADDR_EXP 110
36266: PUSH
36267: LD_EXP 110
36271: PPUSH
36272: LD_VAR 0 2
36276: PPUSH
36277: LD_EXP 87
36281: PUSH
36282: LD_VAR 0 2
36286: ARRAY
36287: PUSH
36288: LD_INT 1
36290: ARRAY
36291: PPUSH
36292: CALL_OW 255
36296: PPUSH
36297: LD_EXP 112
36301: PUSH
36302: LD_VAR 0 2
36306: ARRAY
36307: PPUSH
36308: CALL 52348 0 2
36312: PPUSH
36313: CALL_OW 1
36317: ST_TO_ADDR
// if not mc_scan [ i ] then
36318: LD_EXP 110
36322: PUSH
36323: LD_VAR 0 2
36327: ARRAY
36328: NOT
36329: IFFALSE 36484
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36331: LD_ADDR_VAR 0 4
36335: PUSH
36336: LD_EXP 87
36340: PUSH
36341: LD_VAR 0 2
36345: ARRAY
36346: PPUSH
36347: LD_INT 2
36349: PUSH
36350: LD_INT 25
36352: PUSH
36353: LD_INT 5
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 25
36362: PUSH
36363: LD_INT 8
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: LD_INT 25
36372: PUSH
36373: LD_INT 9
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: LIST
36384: LIST
36385: PPUSH
36386: CALL_OW 72
36390: ST_TO_ADDR
// if not tmp then
36391: LD_VAR 0 4
36395: NOT
36396: IFFALSE 36400
// continue ;
36398: GO 36219
// for j in tmp do
36400: LD_ADDR_VAR 0 3
36404: PUSH
36405: LD_VAR 0 4
36409: PUSH
36410: FOR_IN
36411: IFFALSE 36482
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36413: LD_VAR 0 3
36417: PPUSH
36418: CALL_OW 310
36422: PPUSH
36423: CALL_OW 266
36427: PUSH
36428: LD_INT 5
36430: EQUAL
36431: PUSH
36432: LD_VAR 0 3
36436: PPUSH
36437: CALL_OW 257
36441: PUSH
36442: LD_INT 1
36444: EQUAL
36445: AND
36446: PUSH
36447: LD_VAR 0 3
36451: PPUSH
36452: CALL_OW 459
36456: NOT
36457: AND
36458: PUSH
36459: LD_VAR 0 7
36463: AND
36464: IFFALSE 36480
// ComChangeProfession ( j , class ) ;
36466: LD_VAR 0 3
36470: PPUSH
36471: LD_VAR 0 7
36475: PPUSH
36476: CALL_OW 123
36480: GO 36410
36482: POP
36483: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36484: LD_EXP 110
36488: PUSH
36489: LD_VAR 0 2
36493: ARRAY
36494: PUSH
36495: LD_EXP 109
36499: PUSH
36500: LD_VAR 0 2
36504: ARRAY
36505: NOT
36506: AND
36507: PUSH
36508: LD_EXP 87
36512: PUSH
36513: LD_VAR 0 2
36517: ARRAY
36518: PPUSH
36519: LD_INT 30
36521: PUSH
36522: LD_INT 32
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PPUSH
36529: CALL_OW 72
36533: NOT
36534: AND
36535: PUSH
36536: LD_EXP 87
36540: PUSH
36541: LD_VAR 0 2
36545: ARRAY
36546: PPUSH
36547: LD_INT 2
36549: PUSH
36550: LD_INT 30
36552: PUSH
36553: LD_INT 4
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 30
36562: PUSH
36563: LD_INT 5
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: LIST
36574: PPUSH
36575: CALL_OW 72
36579: NOT
36580: AND
36581: IFFALSE 36713
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36583: LD_ADDR_VAR 0 4
36587: PUSH
36588: LD_EXP 87
36592: PUSH
36593: LD_VAR 0 2
36597: ARRAY
36598: PPUSH
36599: LD_INT 2
36601: PUSH
36602: LD_INT 25
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 25
36614: PUSH
36615: LD_INT 5
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 25
36624: PUSH
36625: LD_INT 8
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: LD_INT 25
36634: PUSH
36635: LD_INT 9
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: PPUSH
36649: CALL_OW 72
36653: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36654: LD_ADDR_VAR 0 4
36658: PUSH
36659: LD_VAR 0 4
36663: PUSH
36664: LD_VAR 0 4
36668: PPUSH
36669: LD_INT 18
36671: PPUSH
36672: CALL 84108 0 2
36676: DIFF
36677: ST_TO_ADDR
// if tmp then
36678: LD_VAR 0 4
36682: IFFALSE 36713
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36684: LD_VAR 0 2
36688: PPUSH
36689: LD_VAR 0 4
36693: PPUSH
36694: LD_EXP 112
36698: PUSH
36699: LD_VAR 0 2
36703: ARRAY
36704: PPUSH
36705: CALL 103152 0 3
// exit ;
36709: POP
36710: POP
36711: GO 36786
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36713: LD_EXP 110
36717: PUSH
36718: LD_VAR 0 2
36722: ARRAY
36723: PUSH
36724: LD_EXP 109
36728: PUSH
36729: LD_VAR 0 2
36733: ARRAY
36734: AND
36735: IFFALSE 36782
// begin tmp := mc_defender [ i ] ;
36737: LD_ADDR_VAR 0 4
36741: PUSH
36742: LD_EXP 109
36746: PUSH
36747: LD_VAR 0 2
36751: ARRAY
36752: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36753: LD_VAR 0 2
36757: PPUSH
36758: LD_VAR 0 4
36762: PPUSH
36763: LD_EXP 110
36767: PUSH
36768: LD_VAR 0 2
36772: ARRAY
36773: PPUSH
36774: CALL 103713 0 3
// exit ;
36778: POP
36779: POP
36780: GO 36786
// end ; end ;
36782: GO 36219
36784: POP
36785: POP
// end ;
36786: LD_VAR 0 1
36790: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36791: LD_INT 0
36793: PPUSH
36794: PPUSH
36795: PPUSH
36796: PPUSH
36797: PPUSH
36798: PPUSH
36799: PPUSH
36800: PPUSH
36801: PPUSH
36802: PPUSH
36803: PPUSH
// if not mc_bases then
36804: LD_EXP 87
36808: NOT
36809: IFFALSE 36813
// exit ;
36811: GO 37900
// for i = 1 to mc_bases do
36813: LD_ADDR_VAR 0 2
36817: PUSH
36818: DOUBLE
36819: LD_INT 1
36821: DEC
36822: ST_TO_ADDR
36823: LD_EXP 87
36827: PUSH
36828: FOR_TO
36829: IFFALSE 37898
// begin tmp := mc_lab [ i ] ;
36831: LD_ADDR_VAR 0 6
36835: PUSH
36836: LD_EXP 120
36840: PUSH
36841: LD_VAR 0 2
36845: ARRAY
36846: ST_TO_ADDR
// if not tmp then
36847: LD_VAR 0 6
36851: NOT
36852: IFFALSE 36856
// continue ;
36854: GO 36828
// idle_lab := 0 ;
36856: LD_ADDR_VAR 0 11
36860: PUSH
36861: LD_INT 0
36863: ST_TO_ADDR
// for j in tmp do
36864: LD_ADDR_VAR 0 3
36868: PUSH
36869: LD_VAR 0 6
36873: PUSH
36874: FOR_IN
36875: IFFALSE 37894
// begin researching := false ;
36877: LD_ADDR_VAR 0 10
36881: PUSH
36882: LD_INT 0
36884: ST_TO_ADDR
// side := GetSide ( j ) ;
36885: LD_ADDR_VAR 0 4
36889: PUSH
36890: LD_VAR 0 3
36894: PPUSH
36895: CALL_OW 255
36899: ST_TO_ADDR
// if not mc_tech [ side ] then
36900: LD_EXP 114
36904: PUSH
36905: LD_VAR 0 4
36909: ARRAY
36910: NOT
36911: IFFALSE 36915
// continue ;
36913: GO 36874
// if BuildingStatus ( j ) = bs_idle then
36915: LD_VAR 0 3
36919: PPUSH
36920: CALL_OW 461
36924: PUSH
36925: LD_INT 2
36927: EQUAL
36928: IFFALSE 37116
// begin if idle_lab and UnitsInside ( j ) < 6 then
36930: LD_VAR 0 11
36934: PUSH
36935: LD_VAR 0 3
36939: PPUSH
36940: CALL_OW 313
36944: PUSH
36945: LD_INT 6
36947: LESS
36948: AND
36949: IFFALSE 37020
// begin tmp2 := UnitsInside ( idle_lab ) ;
36951: LD_ADDR_VAR 0 9
36955: PUSH
36956: LD_VAR 0 11
36960: PPUSH
36961: CALL_OW 313
36965: ST_TO_ADDR
// if tmp2 then
36966: LD_VAR 0 9
36970: IFFALSE 37012
// for x in tmp2 do
36972: LD_ADDR_VAR 0 7
36976: PUSH
36977: LD_VAR 0 9
36981: PUSH
36982: FOR_IN
36983: IFFALSE 37010
// begin ComExitBuilding ( x ) ;
36985: LD_VAR 0 7
36989: PPUSH
36990: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36994: LD_VAR 0 7
36998: PPUSH
36999: LD_VAR 0 3
37003: PPUSH
37004: CALL_OW 180
// end ;
37008: GO 36982
37010: POP
37011: POP
// idle_lab := 0 ;
37012: LD_ADDR_VAR 0 11
37016: PUSH
37017: LD_INT 0
37019: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37020: LD_ADDR_VAR 0 5
37024: PUSH
37025: LD_EXP 114
37029: PUSH
37030: LD_VAR 0 4
37034: ARRAY
37035: PUSH
37036: FOR_IN
37037: IFFALSE 37097
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37039: LD_VAR 0 3
37043: PPUSH
37044: LD_VAR 0 5
37048: PPUSH
37049: CALL_OW 430
37053: PUSH
37054: LD_VAR 0 4
37058: PPUSH
37059: LD_VAR 0 5
37063: PPUSH
37064: CALL 51453 0 2
37068: AND
37069: IFFALSE 37095
// begin researching := true ;
37071: LD_ADDR_VAR 0 10
37075: PUSH
37076: LD_INT 1
37078: ST_TO_ADDR
// ComResearch ( j , t ) ;
37079: LD_VAR 0 3
37083: PPUSH
37084: LD_VAR 0 5
37088: PPUSH
37089: CALL_OW 124
// break ;
37093: GO 37097
// end ;
37095: GO 37036
37097: POP
37098: POP
// if not researching then
37099: LD_VAR 0 10
37103: NOT
37104: IFFALSE 37116
// idle_lab := j ;
37106: LD_ADDR_VAR 0 11
37110: PUSH
37111: LD_VAR 0 3
37115: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37116: LD_VAR 0 3
37120: PPUSH
37121: CALL_OW 461
37125: PUSH
37126: LD_INT 10
37128: EQUAL
37129: IFFALSE 37717
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37131: LD_EXP 116
37135: PUSH
37136: LD_VAR 0 2
37140: ARRAY
37141: NOT
37142: PUSH
37143: LD_EXP 117
37147: PUSH
37148: LD_VAR 0 2
37152: ARRAY
37153: NOT
37154: AND
37155: PUSH
37156: LD_EXP 114
37160: PUSH
37161: LD_VAR 0 4
37165: ARRAY
37166: PUSH
37167: LD_INT 1
37169: GREATER
37170: AND
37171: IFFALSE 37302
// begin ComCancel ( j ) ;
37173: LD_VAR 0 3
37177: PPUSH
37178: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37182: LD_ADDR_EXP 114
37186: PUSH
37187: LD_EXP 114
37191: PPUSH
37192: LD_VAR 0 4
37196: PPUSH
37197: LD_EXP 114
37201: PUSH
37202: LD_VAR 0 4
37206: ARRAY
37207: PPUSH
37208: LD_EXP 114
37212: PUSH
37213: LD_VAR 0 4
37217: ARRAY
37218: PUSH
37219: LD_INT 1
37221: MINUS
37222: PPUSH
37223: LD_EXP 114
37227: PUSH
37228: LD_VAR 0 4
37232: ARRAY
37233: PPUSH
37234: LD_INT 0
37236: PPUSH
37237: CALL 54965 0 4
37241: PPUSH
37242: CALL_OW 1
37246: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37247: LD_ADDR_EXP 114
37251: PUSH
37252: LD_EXP 114
37256: PPUSH
37257: LD_VAR 0 4
37261: PPUSH
37262: LD_EXP 114
37266: PUSH
37267: LD_VAR 0 4
37271: ARRAY
37272: PPUSH
37273: LD_EXP 114
37277: PUSH
37278: LD_VAR 0 4
37282: ARRAY
37283: PPUSH
37284: LD_INT 1
37286: PPUSH
37287: LD_INT 0
37289: PPUSH
37290: CALL 54965 0 4
37294: PPUSH
37295: CALL_OW 1
37299: ST_TO_ADDR
// continue ;
37300: GO 36874
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37302: LD_EXP 116
37306: PUSH
37307: LD_VAR 0 2
37311: ARRAY
37312: PUSH
37313: LD_EXP 117
37317: PUSH
37318: LD_VAR 0 2
37322: ARRAY
37323: NOT
37324: AND
37325: IFFALSE 37452
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37327: LD_ADDR_EXP 117
37331: PUSH
37332: LD_EXP 117
37336: PPUSH
37337: LD_VAR 0 2
37341: PUSH
37342: LD_EXP 117
37346: PUSH
37347: LD_VAR 0 2
37351: ARRAY
37352: PUSH
37353: LD_INT 1
37355: PLUS
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PPUSH
37361: LD_EXP 116
37365: PUSH
37366: LD_VAR 0 2
37370: ARRAY
37371: PUSH
37372: LD_INT 1
37374: ARRAY
37375: PPUSH
37376: CALL 55547 0 3
37380: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37381: LD_EXP 116
37385: PUSH
37386: LD_VAR 0 2
37390: ARRAY
37391: PUSH
37392: LD_INT 1
37394: ARRAY
37395: PPUSH
37396: LD_INT 112
37398: PPUSH
37399: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37403: LD_ADDR_VAR 0 9
37407: PUSH
37408: LD_EXP 116
37412: PUSH
37413: LD_VAR 0 2
37417: ARRAY
37418: PPUSH
37419: LD_INT 1
37421: PPUSH
37422: CALL_OW 3
37426: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37427: LD_ADDR_EXP 116
37431: PUSH
37432: LD_EXP 116
37436: PPUSH
37437: LD_VAR 0 2
37441: PPUSH
37442: LD_VAR 0 9
37446: PPUSH
37447: CALL_OW 1
37451: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37452: LD_EXP 116
37456: PUSH
37457: LD_VAR 0 2
37461: ARRAY
37462: PUSH
37463: LD_EXP 117
37467: PUSH
37468: LD_VAR 0 2
37472: ARRAY
37473: AND
37474: PUSH
37475: LD_EXP 117
37479: PUSH
37480: LD_VAR 0 2
37484: ARRAY
37485: PUSH
37486: LD_INT 1
37488: ARRAY
37489: PPUSH
37490: CALL_OW 310
37494: NOT
37495: AND
37496: PUSH
37497: LD_VAR 0 3
37501: PPUSH
37502: CALL_OW 313
37506: PUSH
37507: LD_INT 6
37509: EQUAL
37510: AND
37511: IFFALSE 37567
// begin tmp2 := UnitsInside ( j ) ;
37513: LD_ADDR_VAR 0 9
37517: PUSH
37518: LD_VAR 0 3
37522: PPUSH
37523: CALL_OW 313
37527: ST_TO_ADDR
// if tmp2 = 6 then
37528: LD_VAR 0 9
37532: PUSH
37533: LD_INT 6
37535: EQUAL
37536: IFFALSE 37567
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37538: LD_VAR 0 9
37542: PUSH
37543: LD_INT 1
37545: ARRAY
37546: PPUSH
37547: LD_INT 112
37549: PPUSH
37550: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37554: LD_VAR 0 9
37558: PUSH
37559: LD_INT 1
37561: ARRAY
37562: PPUSH
37563: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37567: LD_EXP 117
37571: PUSH
37572: LD_VAR 0 2
37576: ARRAY
37577: PUSH
37578: LD_EXP 117
37582: PUSH
37583: LD_VAR 0 2
37587: ARRAY
37588: PUSH
37589: LD_INT 1
37591: ARRAY
37592: PPUSH
37593: CALL_OW 314
37597: NOT
37598: AND
37599: PUSH
37600: LD_EXP 117
37604: PUSH
37605: LD_VAR 0 2
37609: ARRAY
37610: PUSH
37611: LD_INT 1
37613: ARRAY
37614: PPUSH
37615: CALL_OW 310
37619: NOT
37620: AND
37621: IFFALSE 37647
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37623: LD_EXP 117
37627: PUSH
37628: LD_VAR 0 2
37632: ARRAY
37633: PUSH
37634: LD_INT 1
37636: ARRAY
37637: PPUSH
37638: LD_VAR 0 3
37642: PPUSH
37643: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37647: LD_EXP 117
37651: PUSH
37652: LD_VAR 0 2
37656: ARRAY
37657: PUSH
37658: LD_INT 1
37660: ARRAY
37661: PPUSH
37662: CALL_OW 310
37666: PUSH
37667: LD_EXP 117
37671: PUSH
37672: LD_VAR 0 2
37676: ARRAY
37677: PUSH
37678: LD_INT 1
37680: ARRAY
37681: PPUSH
37682: CALL_OW 310
37686: PPUSH
37687: CALL_OW 461
37691: PUSH
37692: LD_INT 3
37694: NONEQUAL
37695: AND
37696: IFFALSE 37717
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37698: LD_EXP 117
37702: PUSH
37703: LD_VAR 0 2
37707: ARRAY
37708: PUSH
37709: LD_INT 1
37711: ARRAY
37712: PPUSH
37713: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37717: LD_VAR 0 3
37721: PPUSH
37722: CALL_OW 461
37726: PUSH
37727: LD_INT 6
37729: EQUAL
37730: PUSH
37731: LD_VAR 0 6
37735: PUSH
37736: LD_INT 1
37738: GREATER
37739: AND
37740: IFFALSE 37892
// begin sci := [ ] ;
37742: LD_ADDR_VAR 0 8
37746: PUSH
37747: EMPTY
37748: ST_TO_ADDR
// for x in ( tmp diff j ) do
37749: LD_ADDR_VAR 0 7
37753: PUSH
37754: LD_VAR 0 6
37758: PUSH
37759: LD_VAR 0 3
37763: DIFF
37764: PUSH
37765: FOR_IN
37766: IFFALSE 37818
// begin if sci = 6 then
37768: LD_VAR 0 8
37772: PUSH
37773: LD_INT 6
37775: EQUAL
37776: IFFALSE 37780
// break ;
37778: GO 37818
// if BuildingStatus ( x ) = bs_idle then
37780: LD_VAR 0 7
37784: PPUSH
37785: CALL_OW 461
37789: PUSH
37790: LD_INT 2
37792: EQUAL
37793: IFFALSE 37816
// sci := sci ^ UnitsInside ( x ) ;
37795: LD_ADDR_VAR 0 8
37799: PUSH
37800: LD_VAR 0 8
37804: PUSH
37805: LD_VAR 0 7
37809: PPUSH
37810: CALL_OW 313
37814: ADD
37815: ST_TO_ADDR
// end ;
37816: GO 37765
37818: POP
37819: POP
// if not sci then
37820: LD_VAR 0 8
37824: NOT
37825: IFFALSE 37829
// continue ;
37827: GO 36874
// for x in sci do
37829: LD_ADDR_VAR 0 7
37833: PUSH
37834: LD_VAR 0 8
37838: PUSH
37839: FOR_IN
37840: IFFALSE 37890
// if IsInUnit ( x ) and not HasTask ( x ) then
37842: LD_VAR 0 7
37846: PPUSH
37847: CALL_OW 310
37851: PUSH
37852: LD_VAR 0 7
37856: PPUSH
37857: CALL_OW 314
37861: NOT
37862: AND
37863: IFFALSE 37888
// begin ComExitBuilding ( x ) ;
37865: LD_VAR 0 7
37869: PPUSH
37870: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37874: LD_VAR 0 7
37878: PPUSH
37879: LD_VAR 0 3
37883: PPUSH
37884: CALL_OW 180
// end ;
37888: GO 37839
37890: POP
37891: POP
// end ; end ;
37892: GO 36874
37894: POP
37895: POP
// end ;
37896: GO 36828
37898: POP
37899: POP
// end ;
37900: LD_VAR 0 1
37904: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37905: LD_INT 0
37907: PPUSH
37908: PPUSH
// if not mc_bases then
37909: LD_EXP 87
37913: NOT
37914: IFFALSE 37918
// exit ;
37916: GO 37999
// for i = 1 to mc_bases do
37918: LD_ADDR_VAR 0 2
37922: PUSH
37923: DOUBLE
37924: LD_INT 1
37926: DEC
37927: ST_TO_ADDR
37928: LD_EXP 87
37932: PUSH
37933: FOR_TO
37934: IFFALSE 37997
// if mc_mines [ i ] and mc_miners [ i ] then
37936: LD_EXP 100
37940: PUSH
37941: LD_VAR 0 2
37945: ARRAY
37946: PUSH
37947: LD_EXP 101
37951: PUSH
37952: LD_VAR 0 2
37956: ARRAY
37957: AND
37958: IFFALSE 37995
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37960: LD_EXP 101
37964: PUSH
37965: LD_VAR 0 2
37969: ARRAY
37970: PUSH
37971: LD_INT 1
37973: ARRAY
37974: PPUSH
37975: CALL_OW 255
37979: PPUSH
37980: LD_EXP 100
37984: PUSH
37985: LD_VAR 0 2
37989: ARRAY
37990: PPUSH
37991: CALL 52536 0 2
37995: GO 37933
37997: POP
37998: POP
// end ;
37999: LD_VAR 0 1
38003: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38004: LD_INT 0
38006: PPUSH
38007: PPUSH
38008: PPUSH
38009: PPUSH
38010: PPUSH
38011: PPUSH
38012: PPUSH
38013: PPUSH
// if not mc_bases or not mc_parking then
38014: LD_EXP 87
38018: NOT
38019: PUSH
38020: LD_EXP 111
38024: NOT
38025: OR
38026: IFFALSE 38030
// exit ;
38028: GO 38729
// for i = 1 to mc_bases do
38030: LD_ADDR_VAR 0 2
38034: PUSH
38035: DOUBLE
38036: LD_INT 1
38038: DEC
38039: ST_TO_ADDR
38040: LD_EXP 87
38044: PUSH
38045: FOR_TO
38046: IFFALSE 38727
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38048: LD_EXP 87
38052: PUSH
38053: LD_VAR 0 2
38057: ARRAY
38058: NOT
38059: PUSH
38060: LD_EXP 111
38064: PUSH
38065: LD_VAR 0 2
38069: ARRAY
38070: NOT
38071: OR
38072: IFFALSE 38076
// continue ;
38074: GO 38045
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38076: LD_ADDR_VAR 0 5
38080: PUSH
38081: LD_EXP 87
38085: PUSH
38086: LD_VAR 0 2
38090: ARRAY
38091: PUSH
38092: LD_INT 1
38094: ARRAY
38095: PPUSH
38096: CALL_OW 255
38100: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38101: LD_ADDR_VAR 0 6
38105: PUSH
38106: LD_EXP 87
38110: PUSH
38111: LD_VAR 0 2
38115: ARRAY
38116: PPUSH
38117: LD_INT 30
38119: PUSH
38120: LD_INT 3
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PPUSH
38127: CALL_OW 72
38131: ST_TO_ADDR
// if not fac then
38132: LD_VAR 0 6
38136: NOT
38137: IFFALSE 38188
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38139: LD_ADDR_VAR 0 6
38143: PUSH
38144: LD_EXP 87
38148: PUSH
38149: LD_VAR 0 2
38153: ARRAY
38154: PPUSH
38155: LD_INT 2
38157: PUSH
38158: LD_INT 30
38160: PUSH
38161: LD_INT 0
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 30
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: LIST
38182: PPUSH
38183: CALL_OW 72
38187: ST_TO_ADDR
// if not fac then
38188: LD_VAR 0 6
38192: NOT
38193: IFFALSE 38197
// continue ;
38195: GO 38045
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38197: LD_ADDR_VAR 0 7
38201: PUSH
38202: LD_EXP 111
38206: PUSH
38207: LD_VAR 0 2
38211: ARRAY
38212: PPUSH
38213: LD_INT 22
38215: PUSH
38216: LD_VAR 0 5
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: PUSH
38225: LD_INT 21
38227: PUSH
38228: LD_INT 2
38230: PUSH
38231: EMPTY
38232: LIST
38233: LIST
38234: PUSH
38235: LD_INT 3
38237: PUSH
38238: LD_INT 24
38240: PUSH
38241: LD_INT 1000
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: LIST
38256: PPUSH
38257: CALL_OW 70
38261: ST_TO_ADDR
// for j in fac do
38262: LD_ADDR_VAR 0 3
38266: PUSH
38267: LD_VAR 0 6
38271: PUSH
38272: FOR_IN
38273: IFFALSE 38354
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38275: LD_ADDR_VAR 0 7
38279: PUSH
38280: LD_VAR 0 7
38284: PUSH
38285: LD_INT 22
38287: PUSH
38288: LD_VAR 0 5
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: PUSH
38297: LD_INT 91
38299: PUSH
38300: LD_VAR 0 3
38304: PUSH
38305: LD_INT 15
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 21
38315: PUSH
38316: LD_INT 2
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 3
38325: PUSH
38326: LD_INT 24
38328: PUSH
38329: LD_INT 1000
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: LIST
38344: LIST
38345: PPUSH
38346: CALL_OW 69
38350: UNION
38351: ST_TO_ADDR
38352: GO 38272
38354: POP
38355: POP
// if not vehs then
38356: LD_VAR 0 7
38360: NOT
38361: IFFALSE 38387
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38363: LD_ADDR_EXP 99
38367: PUSH
38368: LD_EXP 99
38372: PPUSH
38373: LD_VAR 0 2
38377: PPUSH
38378: EMPTY
38379: PPUSH
38380: CALL_OW 1
38384: ST_TO_ADDR
// continue ;
38385: GO 38045
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38387: LD_ADDR_VAR 0 8
38391: PUSH
38392: LD_EXP 87
38396: PUSH
38397: LD_VAR 0 2
38401: ARRAY
38402: PPUSH
38403: LD_INT 30
38405: PUSH
38406: LD_INT 3
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PPUSH
38413: CALL_OW 72
38417: ST_TO_ADDR
// if tmp then
38418: LD_VAR 0 8
38422: IFFALSE 38525
// begin for j in tmp do
38424: LD_ADDR_VAR 0 3
38428: PUSH
38429: LD_VAR 0 8
38433: PUSH
38434: FOR_IN
38435: IFFALSE 38523
// for k in UnitsInside ( j ) do
38437: LD_ADDR_VAR 0 4
38441: PUSH
38442: LD_VAR 0 3
38446: PPUSH
38447: CALL_OW 313
38451: PUSH
38452: FOR_IN
38453: IFFALSE 38519
// if k then
38455: LD_VAR 0 4
38459: IFFALSE 38517
// if not k in mc_repair_vehicle [ i ] then
38461: LD_VAR 0 4
38465: PUSH
38466: LD_EXP 99
38470: PUSH
38471: LD_VAR 0 2
38475: ARRAY
38476: IN
38477: NOT
38478: IFFALSE 38517
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38480: LD_ADDR_EXP 99
38484: PUSH
38485: LD_EXP 99
38489: PPUSH
38490: LD_VAR 0 2
38494: PPUSH
38495: LD_EXP 99
38499: PUSH
38500: LD_VAR 0 2
38504: ARRAY
38505: PUSH
38506: LD_VAR 0 4
38510: UNION
38511: PPUSH
38512: CALL_OW 1
38516: ST_TO_ADDR
38517: GO 38452
38519: POP
38520: POP
38521: GO 38434
38523: POP
38524: POP
// end ; if not mc_repair_vehicle [ i ] then
38525: LD_EXP 99
38529: PUSH
38530: LD_VAR 0 2
38534: ARRAY
38535: NOT
38536: IFFALSE 38540
// continue ;
38538: GO 38045
// for j in mc_repair_vehicle [ i ] do
38540: LD_ADDR_VAR 0 3
38544: PUSH
38545: LD_EXP 99
38549: PUSH
38550: LD_VAR 0 2
38554: ARRAY
38555: PUSH
38556: FOR_IN
38557: IFFALSE 38723
// begin if GetClass ( j ) <> 3 then
38559: LD_VAR 0 3
38563: PPUSH
38564: CALL_OW 257
38568: PUSH
38569: LD_INT 3
38571: NONEQUAL
38572: IFFALSE 38613
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38574: LD_ADDR_EXP 99
38578: PUSH
38579: LD_EXP 99
38583: PPUSH
38584: LD_VAR 0 2
38588: PPUSH
38589: LD_EXP 99
38593: PUSH
38594: LD_VAR 0 2
38598: ARRAY
38599: PUSH
38600: LD_VAR 0 3
38604: DIFF
38605: PPUSH
38606: CALL_OW 1
38610: ST_TO_ADDR
// continue ;
38611: GO 38556
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38613: LD_VAR 0 3
38617: PPUSH
38618: CALL_OW 311
38622: NOT
38623: PUSH
38624: LD_VAR 0 3
38628: PUSH
38629: LD_EXP 90
38633: PUSH
38634: LD_VAR 0 2
38638: ARRAY
38639: PUSH
38640: LD_INT 1
38642: ARRAY
38643: IN
38644: NOT
38645: AND
38646: PUSH
38647: LD_VAR 0 3
38651: PUSH
38652: LD_EXP 90
38656: PUSH
38657: LD_VAR 0 2
38661: ARRAY
38662: PUSH
38663: LD_INT 2
38665: ARRAY
38666: IN
38667: NOT
38668: AND
38669: IFFALSE 38721
// begin if IsInUnit ( j ) then
38671: LD_VAR 0 3
38675: PPUSH
38676: CALL_OW 310
38680: IFFALSE 38691
// ComExitBuilding ( j ) ;
38682: LD_VAR 0 3
38686: PPUSH
38687: CALL_OW 122
// if not HasTask ( j ) then
38691: LD_VAR 0 3
38695: PPUSH
38696: CALL_OW 314
38700: NOT
38701: IFFALSE 38721
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38703: LD_VAR 0 3
38707: PPUSH
38708: LD_VAR 0 7
38712: PUSH
38713: LD_INT 1
38715: ARRAY
38716: PPUSH
38717: CALL_OW 189
// end ; end ;
38721: GO 38556
38723: POP
38724: POP
// end ;
38725: GO 38045
38727: POP
38728: POP
// end ;
38729: LD_VAR 0 1
38733: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38734: LD_INT 0
38736: PPUSH
38737: PPUSH
38738: PPUSH
38739: PPUSH
38740: PPUSH
38741: PPUSH
38742: PPUSH
38743: PPUSH
38744: PPUSH
38745: PPUSH
38746: PPUSH
// if not mc_bases then
38747: LD_EXP 87
38751: NOT
38752: IFFALSE 38756
// exit ;
38754: GO 39558
// for i = 1 to mc_bases do
38756: LD_ADDR_VAR 0 2
38760: PUSH
38761: DOUBLE
38762: LD_INT 1
38764: DEC
38765: ST_TO_ADDR
38766: LD_EXP 87
38770: PUSH
38771: FOR_TO
38772: IFFALSE 39556
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38774: LD_EXP 115
38778: PUSH
38779: LD_VAR 0 2
38783: ARRAY
38784: NOT
38785: PUSH
38786: LD_EXP 90
38790: PUSH
38791: LD_VAR 0 2
38795: ARRAY
38796: PUSH
38797: LD_INT 1
38799: ARRAY
38800: OR
38801: PUSH
38802: LD_EXP 90
38806: PUSH
38807: LD_VAR 0 2
38811: ARRAY
38812: PUSH
38813: LD_INT 2
38815: ARRAY
38816: OR
38817: PUSH
38818: LD_EXP 113
38822: PUSH
38823: LD_VAR 0 2
38827: ARRAY
38828: PPUSH
38829: LD_INT 1
38831: PPUSH
38832: CALL_OW 325
38836: NOT
38837: OR
38838: PUSH
38839: LD_EXP 110
38843: PUSH
38844: LD_VAR 0 2
38848: ARRAY
38849: OR
38850: IFFALSE 38854
// continue ;
38852: GO 38771
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38854: LD_ADDR_VAR 0 8
38858: PUSH
38859: LD_EXP 87
38863: PUSH
38864: LD_VAR 0 2
38868: ARRAY
38869: PPUSH
38870: LD_INT 25
38872: PUSH
38873: LD_INT 4
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 50
38882: PUSH
38883: EMPTY
38884: LIST
38885: PUSH
38886: LD_INT 3
38888: PUSH
38889: LD_INT 60
38891: PUSH
38892: EMPTY
38893: LIST
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: LIST
38903: PPUSH
38904: CALL_OW 72
38908: PUSH
38909: LD_EXP 91
38913: PUSH
38914: LD_VAR 0 2
38918: ARRAY
38919: DIFF
38920: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38921: LD_ADDR_VAR 0 9
38925: PUSH
38926: LD_EXP 87
38930: PUSH
38931: LD_VAR 0 2
38935: ARRAY
38936: PPUSH
38937: LD_INT 2
38939: PUSH
38940: LD_INT 30
38942: PUSH
38943: LD_INT 0
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 30
38952: PUSH
38953: LD_INT 1
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: LIST
38964: PPUSH
38965: CALL_OW 72
38969: ST_TO_ADDR
// if not tmp or not dep then
38970: LD_VAR 0 8
38974: NOT
38975: PUSH
38976: LD_VAR 0 9
38980: NOT
38981: OR
38982: IFFALSE 38986
// continue ;
38984: GO 38771
// side := GetSide ( tmp [ 1 ] ) ;
38986: LD_ADDR_VAR 0 11
38990: PUSH
38991: LD_VAR 0 8
38995: PUSH
38996: LD_INT 1
38998: ARRAY
38999: PPUSH
39000: CALL_OW 255
39004: ST_TO_ADDR
// dep := dep [ 1 ] ;
39005: LD_ADDR_VAR 0 9
39009: PUSH
39010: LD_VAR 0 9
39014: PUSH
39015: LD_INT 1
39017: ARRAY
39018: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39019: LD_ADDR_VAR 0 7
39023: PUSH
39024: LD_EXP 115
39028: PUSH
39029: LD_VAR 0 2
39033: ARRAY
39034: PPUSH
39035: LD_INT 22
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 25
39047: PUSH
39048: LD_INT 12
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: PPUSH
39059: CALL_OW 70
39063: PUSH
39064: LD_INT 22
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 25
39076: PUSH
39077: LD_INT 12
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 91
39086: PUSH
39087: LD_VAR 0 9
39091: PUSH
39092: LD_INT 20
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: LIST
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: LIST
39104: PPUSH
39105: CALL_OW 69
39109: UNION
39110: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39111: LD_ADDR_VAR 0 10
39115: PUSH
39116: LD_EXP 115
39120: PUSH
39121: LD_VAR 0 2
39125: ARRAY
39126: PPUSH
39127: LD_INT 81
39129: PUSH
39130: LD_VAR 0 11
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PPUSH
39139: CALL_OW 70
39143: ST_TO_ADDR
// if not apes or danger_at_area then
39144: LD_VAR 0 7
39148: NOT
39149: PUSH
39150: LD_VAR 0 10
39154: OR
39155: IFFALSE 39205
// begin if mc_taming [ i ] then
39157: LD_EXP 118
39161: PUSH
39162: LD_VAR 0 2
39166: ARRAY
39167: IFFALSE 39203
// begin MC_Reset ( i , 121 ) ;
39169: LD_VAR 0 2
39173: PPUSH
39174: LD_INT 121
39176: PPUSH
39177: CALL 24656 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39181: LD_ADDR_EXP 118
39185: PUSH
39186: LD_EXP 118
39190: PPUSH
39191: LD_VAR 0 2
39195: PPUSH
39196: EMPTY
39197: PPUSH
39198: CALL_OW 1
39202: ST_TO_ADDR
// end ; continue ;
39203: GO 38771
// end ; for j in tmp do
39205: LD_ADDR_VAR 0 3
39209: PUSH
39210: LD_VAR 0 8
39214: PUSH
39215: FOR_IN
39216: IFFALSE 39552
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39218: LD_VAR 0 3
39222: PUSH
39223: LD_EXP 118
39227: PUSH
39228: LD_VAR 0 2
39232: ARRAY
39233: IN
39234: NOT
39235: PUSH
39236: LD_EXP 118
39240: PUSH
39241: LD_VAR 0 2
39245: ARRAY
39246: PUSH
39247: LD_INT 3
39249: LESS
39250: AND
39251: IFFALSE 39309
// begin SetTag ( j , 121 ) ;
39253: LD_VAR 0 3
39257: PPUSH
39258: LD_INT 121
39260: PPUSH
39261: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39265: LD_ADDR_EXP 118
39269: PUSH
39270: LD_EXP 118
39274: PPUSH
39275: LD_VAR 0 2
39279: PUSH
39280: LD_EXP 118
39284: PUSH
39285: LD_VAR 0 2
39289: ARRAY
39290: PUSH
39291: LD_INT 1
39293: PLUS
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PPUSH
39299: LD_VAR 0 3
39303: PPUSH
39304: CALL 55547 0 3
39308: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39309: LD_VAR 0 3
39313: PUSH
39314: LD_EXP 118
39318: PUSH
39319: LD_VAR 0 2
39323: ARRAY
39324: IN
39325: IFFALSE 39550
// begin if GetClass ( j ) <> 4 then
39327: LD_VAR 0 3
39331: PPUSH
39332: CALL_OW 257
39336: PUSH
39337: LD_INT 4
39339: NONEQUAL
39340: IFFALSE 39393
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39342: LD_ADDR_EXP 118
39346: PUSH
39347: LD_EXP 118
39351: PPUSH
39352: LD_VAR 0 2
39356: PPUSH
39357: LD_EXP 118
39361: PUSH
39362: LD_VAR 0 2
39366: ARRAY
39367: PUSH
39368: LD_VAR 0 3
39372: DIFF
39373: PPUSH
39374: CALL_OW 1
39378: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39379: LD_VAR 0 3
39383: PPUSH
39384: LD_INT 0
39386: PPUSH
39387: CALL_OW 109
// continue ;
39391: GO 39215
// end ; if IsInUnit ( j ) then
39393: LD_VAR 0 3
39397: PPUSH
39398: CALL_OW 310
39402: IFFALSE 39413
// ComExitBuilding ( j ) ;
39404: LD_VAR 0 3
39408: PPUSH
39409: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39413: LD_ADDR_VAR 0 6
39417: PUSH
39418: LD_VAR 0 7
39422: PPUSH
39423: LD_VAR 0 3
39427: PPUSH
39428: CALL_OW 74
39432: ST_TO_ADDR
// if not ape then
39433: LD_VAR 0 6
39437: NOT
39438: IFFALSE 39442
// break ;
39440: GO 39552
// x := GetX ( ape ) ;
39442: LD_ADDR_VAR 0 4
39446: PUSH
39447: LD_VAR 0 6
39451: PPUSH
39452: CALL_OW 250
39456: ST_TO_ADDR
// y := GetY ( ape ) ;
39457: LD_ADDR_VAR 0 5
39461: PUSH
39462: LD_VAR 0 6
39466: PPUSH
39467: CALL_OW 251
39471: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39472: LD_VAR 0 4
39476: PPUSH
39477: LD_VAR 0 5
39481: PPUSH
39482: CALL_OW 488
39486: NOT
39487: PUSH
39488: LD_VAR 0 11
39492: PPUSH
39493: LD_VAR 0 4
39497: PPUSH
39498: LD_VAR 0 5
39502: PPUSH
39503: LD_INT 20
39505: PPUSH
39506: CALL 56443 0 4
39510: PUSH
39511: LD_INT 4
39513: ARRAY
39514: OR
39515: IFFALSE 39519
// break ;
39517: GO 39552
// if not HasTask ( j ) then
39519: LD_VAR 0 3
39523: PPUSH
39524: CALL_OW 314
39528: NOT
39529: IFFALSE 39550
// ComTameXY ( j , x , y ) ;
39531: LD_VAR 0 3
39535: PPUSH
39536: LD_VAR 0 4
39540: PPUSH
39541: LD_VAR 0 5
39545: PPUSH
39546: CALL_OW 131
// end ; end ;
39550: GO 39215
39552: POP
39553: POP
// end ;
39554: GO 38771
39556: POP
39557: POP
// end ;
39558: LD_VAR 0 1
39562: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39563: LD_INT 0
39565: PPUSH
39566: PPUSH
39567: PPUSH
39568: PPUSH
39569: PPUSH
39570: PPUSH
39571: PPUSH
39572: PPUSH
// if not mc_bases then
39573: LD_EXP 87
39577: NOT
39578: IFFALSE 39582
// exit ;
39580: GO 40208
// for i = 1 to mc_bases do
39582: LD_ADDR_VAR 0 2
39586: PUSH
39587: DOUBLE
39588: LD_INT 1
39590: DEC
39591: ST_TO_ADDR
39592: LD_EXP 87
39596: PUSH
39597: FOR_TO
39598: IFFALSE 40206
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39600: LD_EXP 116
39604: PUSH
39605: LD_VAR 0 2
39609: ARRAY
39610: NOT
39611: PUSH
39612: LD_EXP 116
39616: PUSH
39617: LD_VAR 0 2
39621: ARRAY
39622: PPUSH
39623: LD_INT 25
39625: PUSH
39626: LD_INT 12
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PPUSH
39633: CALL_OW 72
39637: NOT
39638: OR
39639: IFFALSE 39643
// continue ;
39641: GO 39597
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39643: LD_ADDR_VAR 0 5
39647: PUSH
39648: LD_EXP 116
39652: PUSH
39653: LD_VAR 0 2
39657: ARRAY
39658: PUSH
39659: LD_INT 1
39661: ARRAY
39662: PPUSH
39663: CALL_OW 255
39667: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39668: LD_VAR 0 5
39672: PPUSH
39673: LD_INT 2
39675: PPUSH
39676: CALL_OW 325
39680: IFFALSE 39933
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39682: LD_ADDR_VAR 0 4
39686: PUSH
39687: LD_EXP 116
39691: PUSH
39692: LD_VAR 0 2
39696: ARRAY
39697: PPUSH
39698: LD_INT 25
39700: PUSH
39701: LD_INT 16
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PPUSH
39708: CALL_OW 72
39712: ST_TO_ADDR
// if tmp < 6 then
39713: LD_VAR 0 4
39717: PUSH
39718: LD_INT 6
39720: LESS
39721: IFFALSE 39933
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39723: LD_ADDR_VAR 0 6
39727: PUSH
39728: LD_EXP 87
39732: PUSH
39733: LD_VAR 0 2
39737: ARRAY
39738: PPUSH
39739: LD_INT 2
39741: PUSH
39742: LD_INT 30
39744: PUSH
39745: LD_INT 0
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 30
39754: PUSH
39755: LD_INT 1
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: LIST
39766: PPUSH
39767: CALL_OW 72
39771: ST_TO_ADDR
// if depot then
39772: LD_VAR 0 6
39776: IFFALSE 39933
// begin selected := 0 ;
39778: LD_ADDR_VAR 0 7
39782: PUSH
39783: LD_INT 0
39785: ST_TO_ADDR
// for j in depot do
39786: LD_ADDR_VAR 0 3
39790: PUSH
39791: LD_VAR 0 6
39795: PUSH
39796: FOR_IN
39797: IFFALSE 39828
// begin if UnitsInside ( j ) < 6 then
39799: LD_VAR 0 3
39803: PPUSH
39804: CALL_OW 313
39808: PUSH
39809: LD_INT 6
39811: LESS
39812: IFFALSE 39826
// begin selected := j ;
39814: LD_ADDR_VAR 0 7
39818: PUSH
39819: LD_VAR 0 3
39823: ST_TO_ADDR
// break ;
39824: GO 39828
// end ; end ;
39826: GO 39796
39828: POP
39829: POP
// if selected then
39830: LD_VAR 0 7
39834: IFFALSE 39933
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39836: LD_ADDR_VAR 0 3
39840: PUSH
39841: LD_EXP 116
39845: PUSH
39846: LD_VAR 0 2
39850: ARRAY
39851: PPUSH
39852: LD_INT 25
39854: PUSH
39855: LD_INT 12
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PPUSH
39862: CALL_OW 72
39866: PUSH
39867: FOR_IN
39868: IFFALSE 39931
// if not HasTask ( j ) then
39870: LD_VAR 0 3
39874: PPUSH
39875: CALL_OW 314
39879: NOT
39880: IFFALSE 39929
// begin if not IsInUnit ( j ) then
39882: LD_VAR 0 3
39886: PPUSH
39887: CALL_OW 310
39891: NOT
39892: IFFALSE 39908
// ComEnterUnit ( j , selected ) ;
39894: LD_VAR 0 3
39898: PPUSH
39899: LD_VAR 0 7
39903: PPUSH
39904: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39908: LD_VAR 0 3
39912: PPUSH
39913: LD_INT 16
39915: PPUSH
39916: CALL_OW 183
// AddComExitBuilding ( j ) ;
39920: LD_VAR 0 3
39924: PPUSH
39925: CALL_OW 182
// end ;
39929: GO 39867
39931: POP
39932: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39933: LD_VAR 0 5
39937: PPUSH
39938: LD_INT 11
39940: PPUSH
39941: CALL_OW 325
39945: IFFALSE 40204
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39947: LD_ADDR_VAR 0 4
39951: PUSH
39952: LD_EXP 116
39956: PUSH
39957: LD_VAR 0 2
39961: ARRAY
39962: PPUSH
39963: LD_INT 25
39965: PUSH
39966: LD_INT 16
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PPUSH
39973: CALL_OW 72
39977: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39978: LD_VAR 0 4
39982: PUSH
39983: LD_INT 6
39985: GREATEREQUAL
39986: PUSH
39987: LD_VAR 0 5
39991: PPUSH
39992: LD_INT 2
39994: PPUSH
39995: CALL_OW 325
39999: NOT
40000: OR
40001: IFFALSE 40204
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40003: LD_ADDR_VAR 0 8
40007: PUSH
40008: LD_EXP 87
40012: PUSH
40013: LD_VAR 0 2
40017: ARRAY
40018: PPUSH
40019: LD_INT 2
40021: PUSH
40022: LD_INT 30
40024: PUSH
40025: LD_INT 4
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 30
40034: PUSH
40035: LD_INT 5
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: LIST
40046: PPUSH
40047: CALL_OW 72
40051: ST_TO_ADDR
// if barracks then
40052: LD_VAR 0 8
40056: IFFALSE 40204
// begin selected := 0 ;
40058: LD_ADDR_VAR 0 7
40062: PUSH
40063: LD_INT 0
40065: ST_TO_ADDR
// for j in barracks do
40066: LD_ADDR_VAR 0 3
40070: PUSH
40071: LD_VAR 0 8
40075: PUSH
40076: FOR_IN
40077: IFFALSE 40108
// begin if UnitsInside ( j ) < 6 then
40079: LD_VAR 0 3
40083: PPUSH
40084: CALL_OW 313
40088: PUSH
40089: LD_INT 6
40091: LESS
40092: IFFALSE 40106
// begin selected := j ;
40094: LD_ADDR_VAR 0 7
40098: PUSH
40099: LD_VAR 0 3
40103: ST_TO_ADDR
// break ;
40104: GO 40108
// end ; end ;
40106: GO 40076
40108: POP
40109: POP
// if selected then
40110: LD_VAR 0 7
40114: IFFALSE 40204
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40116: LD_ADDR_VAR 0 3
40120: PUSH
40121: LD_EXP 116
40125: PUSH
40126: LD_VAR 0 2
40130: ARRAY
40131: PPUSH
40132: LD_INT 25
40134: PUSH
40135: LD_INT 12
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PPUSH
40142: CALL_OW 72
40146: PUSH
40147: FOR_IN
40148: IFFALSE 40202
// if not IsInUnit ( j ) and not HasTask ( j ) then
40150: LD_VAR 0 3
40154: PPUSH
40155: CALL_OW 310
40159: NOT
40160: PUSH
40161: LD_VAR 0 3
40165: PPUSH
40166: CALL_OW 314
40170: NOT
40171: AND
40172: IFFALSE 40200
// begin ComEnterUnit ( j , selected ) ;
40174: LD_VAR 0 3
40178: PPUSH
40179: LD_VAR 0 7
40183: PPUSH
40184: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40188: LD_VAR 0 3
40192: PPUSH
40193: LD_INT 15
40195: PPUSH
40196: CALL_OW 183
// end ;
40200: GO 40147
40202: POP
40203: POP
// end ; end ; end ; end ; end ;
40204: GO 39597
40206: POP
40207: POP
// end ;
40208: LD_VAR 0 1
40212: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40213: LD_INT 0
40215: PPUSH
40216: PPUSH
40217: PPUSH
40218: PPUSH
// if not mc_bases then
40219: LD_EXP 87
40223: NOT
40224: IFFALSE 40228
// exit ;
40226: GO 40406
// for i = 1 to mc_bases do
40228: LD_ADDR_VAR 0 2
40232: PUSH
40233: DOUBLE
40234: LD_INT 1
40236: DEC
40237: ST_TO_ADDR
40238: LD_EXP 87
40242: PUSH
40243: FOR_TO
40244: IFFALSE 40404
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40246: LD_ADDR_VAR 0 4
40250: PUSH
40251: LD_EXP 87
40255: PUSH
40256: LD_VAR 0 2
40260: ARRAY
40261: PPUSH
40262: LD_INT 25
40264: PUSH
40265: LD_INT 9
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PPUSH
40272: CALL_OW 72
40276: ST_TO_ADDR
// if not tmp then
40277: LD_VAR 0 4
40281: NOT
40282: IFFALSE 40286
// continue ;
40284: GO 40243
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40286: LD_EXP 113
40290: PUSH
40291: LD_VAR 0 2
40295: ARRAY
40296: PPUSH
40297: LD_INT 29
40299: PPUSH
40300: CALL_OW 325
40304: NOT
40305: PUSH
40306: LD_EXP 113
40310: PUSH
40311: LD_VAR 0 2
40315: ARRAY
40316: PPUSH
40317: LD_INT 28
40319: PPUSH
40320: CALL_OW 325
40324: NOT
40325: AND
40326: IFFALSE 40330
// continue ;
40328: GO 40243
// for j in tmp do
40330: LD_ADDR_VAR 0 3
40334: PUSH
40335: LD_VAR 0 4
40339: PUSH
40340: FOR_IN
40341: IFFALSE 40400
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40343: LD_VAR 0 3
40347: PUSH
40348: LD_EXP 90
40352: PUSH
40353: LD_VAR 0 2
40357: ARRAY
40358: PUSH
40359: LD_INT 1
40361: ARRAY
40362: IN
40363: NOT
40364: PUSH
40365: LD_VAR 0 3
40369: PUSH
40370: LD_EXP 90
40374: PUSH
40375: LD_VAR 0 2
40379: ARRAY
40380: PUSH
40381: LD_INT 2
40383: ARRAY
40384: IN
40385: NOT
40386: AND
40387: IFFALSE 40398
// ComSpaceTimeShoot ( j ) ;
40389: LD_VAR 0 3
40393: PPUSH
40394: CALL 51544 0 1
40398: GO 40340
40400: POP
40401: POP
// end ;
40402: GO 40243
40404: POP
40405: POP
// end ;
40406: LD_VAR 0 1
40410: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40411: LD_INT 0
40413: PPUSH
40414: PPUSH
40415: PPUSH
40416: PPUSH
40417: PPUSH
40418: PPUSH
40419: PPUSH
40420: PPUSH
40421: PPUSH
// if not mc_bases then
40422: LD_EXP 87
40426: NOT
40427: IFFALSE 40431
// exit ;
40429: GO 41053
// for i = 1 to mc_bases do
40431: LD_ADDR_VAR 0 2
40435: PUSH
40436: DOUBLE
40437: LD_INT 1
40439: DEC
40440: ST_TO_ADDR
40441: LD_EXP 87
40445: PUSH
40446: FOR_TO
40447: IFFALSE 41051
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40449: LD_EXP 122
40453: PUSH
40454: LD_VAR 0 2
40458: ARRAY
40459: NOT
40460: PUSH
40461: LD_INT 38
40463: PPUSH
40464: LD_EXP 113
40468: PUSH
40469: LD_VAR 0 2
40473: ARRAY
40474: PPUSH
40475: CALL_OW 321
40479: PUSH
40480: LD_INT 2
40482: NONEQUAL
40483: OR
40484: IFFALSE 40488
// continue ;
40486: GO 40446
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40488: LD_ADDR_VAR 0 8
40492: PUSH
40493: LD_EXP 87
40497: PUSH
40498: LD_VAR 0 2
40502: ARRAY
40503: PPUSH
40504: LD_INT 30
40506: PUSH
40507: LD_INT 34
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PPUSH
40514: CALL_OW 72
40518: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40519: LD_ADDR_VAR 0 9
40523: PUSH
40524: LD_EXP 87
40528: PUSH
40529: LD_VAR 0 2
40533: ARRAY
40534: PPUSH
40535: LD_INT 25
40537: PUSH
40538: LD_INT 4
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PPUSH
40545: CALL_OW 72
40549: PPUSH
40550: LD_INT 0
40552: PPUSH
40553: CALL 84108 0 2
40557: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40558: LD_VAR 0 9
40562: NOT
40563: PUSH
40564: LD_VAR 0 8
40568: NOT
40569: OR
40570: PUSH
40571: LD_EXP 87
40575: PUSH
40576: LD_VAR 0 2
40580: ARRAY
40581: PPUSH
40582: LD_INT 124
40584: PPUSH
40585: CALL 84108 0 2
40589: OR
40590: IFFALSE 40594
// continue ;
40592: GO 40446
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40594: LD_EXP 123
40598: PUSH
40599: LD_VAR 0 2
40603: ARRAY
40604: PUSH
40605: LD_EXP 122
40609: PUSH
40610: LD_VAR 0 2
40614: ARRAY
40615: LESS
40616: PUSH
40617: LD_EXP 123
40621: PUSH
40622: LD_VAR 0 2
40626: ARRAY
40627: PUSH
40628: LD_VAR 0 8
40632: LESS
40633: AND
40634: IFFALSE 41049
// begin tmp := sci [ 1 ] ;
40636: LD_ADDR_VAR 0 7
40640: PUSH
40641: LD_VAR 0 9
40645: PUSH
40646: LD_INT 1
40648: ARRAY
40649: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40650: LD_VAR 0 7
40654: PPUSH
40655: LD_INT 124
40657: PPUSH
40658: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40662: LD_ADDR_VAR 0 3
40666: PUSH
40667: DOUBLE
40668: LD_EXP 122
40672: PUSH
40673: LD_VAR 0 2
40677: ARRAY
40678: INC
40679: ST_TO_ADDR
40680: LD_EXP 122
40684: PUSH
40685: LD_VAR 0 2
40689: ARRAY
40690: PUSH
40691: FOR_DOWNTO
40692: IFFALSE 41035
// begin if IsInUnit ( tmp ) then
40694: LD_VAR 0 7
40698: PPUSH
40699: CALL_OW 310
40703: IFFALSE 40714
// ComExitBuilding ( tmp ) ;
40705: LD_VAR 0 7
40709: PPUSH
40710: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40714: LD_INT 35
40716: PPUSH
40717: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40721: LD_VAR 0 7
40725: PPUSH
40726: CALL_OW 310
40730: NOT
40731: PUSH
40732: LD_VAR 0 7
40736: PPUSH
40737: CALL_OW 314
40741: NOT
40742: AND
40743: IFFALSE 40714
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40745: LD_ADDR_VAR 0 6
40749: PUSH
40750: LD_VAR 0 7
40754: PPUSH
40755: CALL_OW 250
40759: PUSH
40760: LD_VAR 0 7
40764: PPUSH
40765: CALL_OW 251
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40774: LD_INT 35
40776: PPUSH
40777: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40781: LD_ADDR_VAR 0 4
40785: PUSH
40786: LD_EXP 122
40790: PUSH
40791: LD_VAR 0 2
40795: ARRAY
40796: PUSH
40797: LD_VAR 0 3
40801: ARRAY
40802: PUSH
40803: LD_INT 1
40805: ARRAY
40806: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40807: LD_ADDR_VAR 0 5
40811: PUSH
40812: LD_EXP 122
40816: PUSH
40817: LD_VAR 0 2
40821: ARRAY
40822: PUSH
40823: LD_VAR 0 3
40827: ARRAY
40828: PUSH
40829: LD_INT 2
40831: ARRAY
40832: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40833: LD_VAR 0 7
40837: PPUSH
40838: LD_INT 10
40840: PPUSH
40841: CALL 58140 0 2
40845: PUSH
40846: LD_INT 4
40848: ARRAY
40849: IFFALSE 40887
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40851: LD_VAR 0 7
40855: PPUSH
40856: LD_VAR 0 6
40860: PUSH
40861: LD_INT 1
40863: ARRAY
40864: PPUSH
40865: LD_VAR 0 6
40869: PUSH
40870: LD_INT 2
40872: ARRAY
40873: PPUSH
40874: CALL_OW 111
// wait ( 0 0$10 ) ;
40878: LD_INT 350
40880: PPUSH
40881: CALL_OW 67
// end else
40885: GO 40913
// begin ComMoveXY ( tmp , x , y ) ;
40887: LD_VAR 0 7
40891: PPUSH
40892: LD_VAR 0 4
40896: PPUSH
40897: LD_VAR 0 5
40901: PPUSH
40902: CALL_OW 111
// wait ( 0 0$3 ) ;
40906: LD_INT 105
40908: PPUSH
40909: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40913: LD_VAR 0 7
40917: PPUSH
40918: LD_VAR 0 4
40922: PPUSH
40923: LD_VAR 0 5
40927: PPUSH
40928: CALL_OW 307
40932: IFFALSE 40774
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40934: LD_VAR 0 7
40938: PPUSH
40939: LD_VAR 0 4
40943: PPUSH
40944: LD_VAR 0 5
40948: PPUSH
40949: LD_VAR 0 8
40953: PUSH
40954: LD_VAR 0 3
40958: ARRAY
40959: PPUSH
40960: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40964: LD_INT 35
40966: PPUSH
40967: CALL_OW 67
// until not HasTask ( tmp ) ;
40971: LD_VAR 0 7
40975: PPUSH
40976: CALL_OW 314
40980: NOT
40981: IFFALSE 40964
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40983: LD_ADDR_EXP 123
40987: PUSH
40988: LD_EXP 123
40992: PPUSH
40993: LD_VAR 0 2
40997: PUSH
40998: LD_EXP 123
41002: PUSH
41003: LD_VAR 0 2
41007: ARRAY
41008: PUSH
41009: LD_INT 1
41011: PLUS
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PPUSH
41017: LD_VAR 0 8
41021: PUSH
41022: LD_VAR 0 3
41026: ARRAY
41027: PPUSH
41028: CALL 55547 0 3
41032: ST_TO_ADDR
// end ;
41033: GO 40691
41035: POP
41036: POP
// MC_Reset ( i , 124 ) ;
41037: LD_VAR 0 2
41041: PPUSH
41042: LD_INT 124
41044: PPUSH
41045: CALL 24656 0 2
// end ; end ;
41049: GO 40446
41051: POP
41052: POP
// end ;
41053: LD_VAR 0 1
41057: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41058: LD_INT 0
41060: PPUSH
41061: PPUSH
41062: PPUSH
// if not mc_bases then
41063: LD_EXP 87
41067: NOT
41068: IFFALSE 41072
// exit ;
41070: GO 41678
// for i = 1 to mc_bases do
41072: LD_ADDR_VAR 0 2
41076: PUSH
41077: DOUBLE
41078: LD_INT 1
41080: DEC
41081: ST_TO_ADDR
41082: LD_EXP 87
41086: PUSH
41087: FOR_TO
41088: IFFALSE 41676
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41090: LD_ADDR_VAR 0 3
41094: PUSH
41095: LD_EXP 87
41099: PUSH
41100: LD_VAR 0 2
41104: ARRAY
41105: PPUSH
41106: LD_INT 25
41108: PUSH
41109: LD_INT 4
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PPUSH
41116: CALL_OW 72
41120: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41121: LD_VAR 0 3
41125: NOT
41126: PUSH
41127: LD_EXP 124
41131: PUSH
41132: LD_VAR 0 2
41136: ARRAY
41137: NOT
41138: OR
41139: PUSH
41140: LD_EXP 87
41144: PUSH
41145: LD_VAR 0 2
41149: ARRAY
41150: PPUSH
41151: LD_INT 2
41153: PUSH
41154: LD_INT 30
41156: PUSH
41157: LD_INT 0
41159: PUSH
41160: EMPTY
41161: LIST
41162: LIST
41163: PUSH
41164: LD_INT 30
41166: PUSH
41167: LD_INT 1
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: LIST
41178: PPUSH
41179: CALL_OW 72
41183: NOT
41184: OR
41185: IFFALSE 41235
// begin if mc_deposits_finder [ i ] then
41187: LD_EXP 125
41191: PUSH
41192: LD_VAR 0 2
41196: ARRAY
41197: IFFALSE 41233
// begin MC_Reset ( i , 125 ) ;
41199: LD_VAR 0 2
41203: PPUSH
41204: LD_INT 125
41206: PPUSH
41207: CALL 24656 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41211: LD_ADDR_EXP 125
41215: PUSH
41216: LD_EXP 125
41220: PPUSH
41221: LD_VAR 0 2
41225: PPUSH
41226: EMPTY
41227: PPUSH
41228: CALL_OW 1
41232: ST_TO_ADDR
// end ; continue ;
41233: GO 41087
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41235: LD_EXP 124
41239: PUSH
41240: LD_VAR 0 2
41244: ARRAY
41245: PUSH
41246: LD_INT 1
41248: ARRAY
41249: PUSH
41250: LD_INT 3
41252: ARRAY
41253: PUSH
41254: LD_INT 1
41256: EQUAL
41257: PUSH
41258: LD_INT 20
41260: PPUSH
41261: LD_EXP 113
41265: PUSH
41266: LD_VAR 0 2
41270: ARRAY
41271: PPUSH
41272: CALL_OW 321
41276: PUSH
41277: LD_INT 2
41279: NONEQUAL
41280: AND
41281: IFFALSE 41331
// begin if mc_deposits_finder [ i ] then
41283: LD_EXP 125
41287: PUSH
41288: LD_VAR 0 2
41292: ARRAY
41293: IFFALSE 41329
// begin MC_Reset ( i , 125 ) ;
41295: LD_VAR 0 2
41299: PPUSH
41300: LD_INT 125
41302: PPUSH
41303: CALL 24656 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41307: LD_ADDR_EXP 125
41311: PUSH
41312: LD_EXP 125
41316: PPUSH
41317: LD_VAR 0 2
41321: PPUSH
41322: EMPTY
41323: PPUSH
41324: CALL_OW 1
41328: ST_TO_ADDR
// end ; continue ;
41329: GO 41087
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41331: LD_EXP 124
41335: PUSH
41336: LD_VAR 0 2
41340: ARRAY
41341: PUSH
41342: LD_INT 1
41344: ARRAY
41345: PUSH
41346: LD_INT 1
41348: ARRAY
41349: PPUSH
41350: LD_EXP 124
41354: PUSH
41355: LD_VAR 0 2
41359: ARRAY
41360: PUSH
41361: LD_INT 1
41363: ARRAY
41364: PUSH
41365: LD_INT 2
41367: ARRAY
41368: PPUSH
41369: LD_EXP 113
41373: PUSH
41374: LD_VAR 0 2
41378: ARRAY
41379: PPUSH
41380: CALL_OW 440
41384: IFFALSE 41427
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41386: LD_ADDR_EXP 124
41390: PUSH
41391: LD_EXP 124
41395: PPUSH
41396: LD_VAR 0 2
41400: PPUSH
41401: LD_EXP 124
41405: PUSH
41406: LD_VAR 0 2
41410: ARRAY
41411: PPUSH
41412: LD_INT 1
41414: PPUSH
41415: CALL_OW 3
41419: PPUSH
41420: CALL_OW 1
41424: ST_TO_ADDR
41425: GO 41674
// begin if not mc_deposits_finder [ i ] then
41427: LD_EXP 125
41431: PUSH
41432: LD_VAR 0 2
41436: ARRAY
41437: NOT
41438: IFFALSE 41490
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41440: LD_ADDR_EXP 125
41444: PUSH
41445: LD_EXP 125
41449: PPUSH
41450: LD_VAR 0 2
41454: PPUSH
41455: LD_VAR 0 3
41459: PUSH
41460: LD_INT 1
41462: ARRAY
41463: PUSH
41464: EMPTY
41465: LIST
41466: PPUSH
41467: CALL_OW 1
41471: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41472: LD_VAR 0 3
41476: PUSH
41477: LD_INT 1
41479: ARRAY
41480: PPUSH
41481: LD_INT 125
41483: PPUSH
41484: CALL_OW 109
// end else
41488: GO 41674
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41490: LD_EXP 125
41494: PUSH
41495: LD_VAR 0 2
41499: ARRAY
41500: PUSH
41501: LD_INT 1
41503: ARRAY
41504: PPUSH
41505: CALL_OW 310
41509: IFFALSE 41532
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41511: LD_EXP 125
41515: PUSH
41516: LD_VAR 0 2
41520: ARRAY
41521: PUSH
41522: LD_INT 1
41524: ARRAY
41525: PPUSH
41526: CALL_OW 122
41530: GO 41674
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41532: LD_EXP 125
41536: PUSH
41537: LD_VAR 0 2
41541: ARRAY
41542: PUSH
41543: LD_INT 1
41545: ARRAY
41546: PPUSH
41547: CALL_OW 314
41551: NOT
41552: PUSH
41553: LD_EXP 125
41557: PUSH
41558: LD_VAR 0 2
41562: ARRAY
41563: PUSH
41564: LD_INT 1
41566: ARRAY
41567: PPUSH
41568: LD_EXP 124
41572: PUSH
41573: LD_VAR 0 2
41577: ARRAY
41578: PUSH
41579: LD_INT 1
41581: ARRAY
41582: PUSH
41583: LD_INT 1
41585: ARRAY
41586: PPUSH
41587: LD_EXP 124
41591: PUSH
41592: LD_VAR 0 2
41596: ARRAY
41597: PUSH
41598: LD_INT 1
41600: ARRAY
41601: PUSH
41602: LD_INT 2
41604: ARRAY
41605: PPUSH
41606: CALL_OW 297
41610: PUSH
41611: LD_INT 6
41613: GREATER
41614: AND
41615: IFFALSE 41674
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41617: LD_EXP 125
41621: PUSH
41622: LD_VAR 0 2
41626: ARRAY
41627: PUSH
41628: LD_INT 1
41630: ARRAY
41631: PPUSH
41632: LD_EXP 124
41636: PUSH
41637: LD_VAR 0 2
41641: ARRAY
41642: PUSH
41643: LD_INT 1
41645: ARRAY
41646: PUSH
41647: LD_INT 1
41649: ARRAY
41650: PPUSH
41651: LD_EXP 124
41655: PUSH
41656: LD_VAR 0 2
41660: ARRAY
41661: PUSH
41662: LD_INT 1
41664: ARRAY
41665: PUSH
41666: LD_INT 2
41668: ARRAY
41669: PPUSH
41670: CALL_OW 111
// end ; end ; end ;
41674: GO 41087
41676: POP
41677: POP
// end ;
41678: LD_VAR 0 1
41682: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41683: LD_INT 0
41685: PPUSH
41686: PPUSH
41687: PPUSH
41688: PPUSH
41689: PPUSH
41690: PPUSH
41691: PPUSH
41692: PPUSH
41693: PPUSH
41694: PPUSH
41695: PPUSH
// if not mc_bases then
41696: LD_EXP 87
41700: NOT
41701: IFFALSE 41705
// exit ;
41703: GO 42645
// for i = 1 to mc_bases do
41705: LD_ADDR_VAR 0 2
41709: PUSH
41710: DOUBLE
41711: LD_INT 1
41713: DEC
41714: ST_TO_ADDR
41715: LD_EXP 87
41719: PUSH
41720: FOR_TO
41721: IFFALSE 42643
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41723: LD_EXP 87
41727: PUSH
41728: LD_VAR 0 2
41732: ARRAY
41733: NOT
41734: PUSH
41735: LD_EXP 110
41739: PUSH
41740: LD_VAR 0 2
41744: ARRAY
41745: OR
41746: IFFALSE 41750
// continue ;
41748: GO 41720
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41750: LD_ADDR_VAR 0 7
41754: PUSH
41755: LD_EXP 87
41759: PUSH
41760: LD_VAR 0 2
41764: ARRAY
41765: PUSH
41766: LD_INT 1
41768: ARRAY
41769: PPUSH
41770: CALL_OW 248
41774: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41775: LD_VAR 0 7
41779: PUSH
41780: LD_INT 3
41782: EQUAL
41783: PUSH
41784: LD_EXP 106
41788: PUSH
41789: LD_VAR 0 2
41793: ARRAY
41794: PUSH
41795: LD_EXP 109
41799: PUSH
41800: LD_VAR 0 2
41804: ARRAY
41805: UNION
41806: PPUSH
41807: LD_INT 33
41809: PUSH
41810: LD_INT 2
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PPUSH
41817: CALL_OW 72
41821: NOT
41822: OR
41823: IFFALSE 41827
// continue ;
41825: GO 41720
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41827: LD_ADDR_VAR 0 9
41831: PUSH
41832: LD_EXP 87
41836: PUSH
41837: LD_VAR 0 2
41841: ARRAY
41842: PPUSH
41843: LD_INT 30
41845: PUSH
41846: LD_INT 36
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PPUSH
41853: CALL_OW 72
41857: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41858: LD_ADDR_VAR 0 10
41862: PUSH
41863: LD_EXP 106
41867: PUSH
41868: LD_VAR 0 2
41872: ARRAY
41873: PPUSH
41874: LD_INT 34
41876: PUSH
41877: LD_INT 31
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PPUSH
41884: CALL_OW 72
41888: ST_TO_ADDR
// if not cts and not mcts then
41889: LD_VAR 0 9
41893: NOT
41894: PUSH
41895: LD_VAR 0 10
41899: NOT
41900: AND
41901: IFFALSE 41905
// continue ;
41903: GO 41720
// x := cts ;
41905: LD_ADDR_VAR 0 11
41909: PUSH
41910: LD_VAR 0 9
41914: ST_TO_ADDR
// if not x then
41915: LD_VAR 0 11
41919: NOT
41920: IFFALSE 41932
// x := mcts ;
41922: LD_ADDR_VAR 0 11
41926: PUSH
41927: LD_VAR 0 10
41931: ST_TO_ADDR
// if not x then
41932: LD_VAR 0 11
41936: NOT
41937: IFFALSE 41941
// continue ;
41939: GO 41720
// if mc_remote_driver [ i ] then
41941: LD_EXP 127
41945: PUSH
41946: LD_VAR 0 2
41950: ARRAY
41951: IFFALSE 42338
// for j in mc_remote_driver [ i ] do
41953: LD_ADDR_VAR 0 3
41957: PUSH
41958: LD_EXP 127
41962: PUSH
41963: LD_VAR 0 2
41967: ARRAY
41968: PUSH
41969: FOR_IN
41970: IFFALSE 42336
// begin if GetClass ( j ) <> 3 then
41972: LD_VAR 0 3
41976: PPUSH
41977: CALL_OW 257
41981: PUSH
41982: LD_INT 3
41984: NONEQUAL
41985: IFFALSE 42038
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41987: LD_ADDR_EXP 127
41991: PUSH
41992: LD_EXP 127
41996: PPUSH
41997: LD_VAR 0 2
42001: PPUSH
42002: LD_EXP 127
42006: PUSH
42007: LD_VAR 0 2
42011: ARRAY
42012: PUSH
42013: LD_VAR 0 3
42017: DIFF
42018: PPUSH
42019: CALL_OW 1
42023: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42024: LD_VAR 0 3
42028: PPUSH
42029: LD_INT 0
42031: PPUSH
42032: CALL_OW 109
// continue ;
42036: GO 41969
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42038: LD_EXP 106
42042: PUSH
42043: LD_VAR 0 2
42047: ARRAY
42048: PPUSH
42049: LD_INT 34
42051: PUSH
42052: LD_INT 31
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 58
42061: PUSH
42062: EMPTY
42063: LIST
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PPUSH
42069: CALL_OW 72
42073: PUSH
42074: LD_VAR 0 3
42078: PPUSH
42079: CALL 84196 0 1
42083: NOT
42084: AND
42085: IFFALSE 42156
// begin if IsInUnit ( j ) then
42087: LD_VAR 0 3
42091: PPUSH
42092: CALL_OW 310
42096: IFFALSE 42107
// ComExitBuilding ( j ) ;
42098: LD_VAR 0 3
42102: PPUSH
42103: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42107: LD_VAR 0 3
42111: PPUSH
42112: LD_EXP 106
42116: PUSH
42117: LD_VAR 0 2
42121: ARRAY
42122: PPUSH
42123: LD_INT 34
42125: PUSH
42126: LD_INT 31
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 58
42135: PUSH
42136: EMPTY
42137: LIST
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PPUSH
42143: CALL_OW 72
42147: PUSH
42148: LD_INT 1
42150: ARRAY
42151: PPUSH
42152: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42156: LD_VAR 0 3
42160: PPUSH
42161: CALL_OW 310
42165: NOT
42166: PUSH
42167: LD_VAR 0 3
42171: PPUSH
42172: CALL_OW 310
42176: PPUSH
42177: CALL_OW 266
42181: PUSH
42182: LD_INT 36
42184: NONEQUAL
42185: PUSH
42186: LD_VAR 0 3
42190: PPUSH
42191: CALL 84196 0 1
42195: NOT
42196: AND
42197: OR
42198: IFFALSE 42334
// begin if IsInUnit ( j ) then
42200: LD_VAR 0 3
42204: PPUSH
42205: CALL_OW 310
42209: IFFALSE 42220
// ComExitBuilding ( j ) ;
42211: LD_VAR 0 3
42215: PPUSH
42216: CALL_OW 122
// ct := 0 ;
42220: LD_ADDR_VAR 0 8
42224: PUSH
42225: LD_INT 0
42227: ST_TO_ADDR
// for k in x do
42228: LD_ADDR_VAR 0 4
42232: PUSH
42233: LD_VAR 0 11
42237: PUSH
42238: FOR_IN
42239: IFFALSE 42312
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42241: LD_VAR 0 4
42245: PPUSH
42246: CALL_OW 264
42250: PUSH
42251: LD_INT 31
42253: EQUAL
42254: PUSH
42255: LD_VAR 0 4
42259: PPUSH
42260: CALL_OW 311
42264: NOT
42265: AND
42266: PUSH
42267: LD_VAR 0 4
42271: PPUSH
42272: CALL_OW 266
42276: PUSH
42277: LD_INT 36
42279: EQUAL
42280: PUSH
42281: LD_VAR 0 4
42285: PPUSH
42286: CALL_OW 313
42290: PUSH
42291: LD_INT 3
42293: LESS
42294: AND
42295: OR
42296: IFFALSE 42310
// begin ct := k ;
42298: LD_ADDR_VAR 0 8
42302: PUSH
42303: LD_VAR 0 4
42307: ST_TO_ADDR
// break ;
42308: GO 42312
// end ;
42310: GO 42238
42312: POP
42313: POP
// if ct then
42314: LD_VAR 0 8
42318: IFFALSE 42334
// ComEnterUnit ( j , ct ) ;
42320: LD_VAR 0 3
42324: PPUSH
42325: LD_VAR 0 8
42329: PPUSH
42330: CALL_OW 120
// end ; end ;
42334: GO 41969
42336: POP
42337: POP
// places := 0 ;
42338: LD_ADDR_VAR 0 5
42342: PUSH
42343: LD_INT 0
42345: ST_TO_ADDR
// for j = 1 to x do
42346: LD_ADDR_VAR 0 3
42350: PUSH
42351: DOUBLE
42352: LD_INT 1
42354: DEC
42355: ST_TO_ADDR
42356: LD_VAR 0 11
42360: PUSH
42361: FOR_TO
42362: IFFALSE 42438
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42364: LD_VAR 0 11
42368: PUSH
42369: LD_VAR 0 3
42373: ARRAY
42374: PPUSH
42375: CALL_OW 264
42379: PUSH
42380: LD_INT 31
42382: EQUAL
42383: IFFALSE 42401
// places := places + 1 else
42385: LD_ADDR_VAR 0 5
42389: PUSH
42390: LD_VAR 0 5
42394: PUSH
42395: LD_INT 1
42397: PLUS
42398: ST_TO_ADDR
42399: GO 42436
// if GetBType ( x [ j ] ) = b_control_tower then
42401: LD_VAR 0 11
42405: PUSH
42406: LD_VAR 0 3
42410: ARRAY
42411: PPUSH
42412: CALL_OW 266
42416: PUSH
42417: LD_INT 36
42419: EQUAL
42420: IFFALSE 42436
// places := places + 3 ;
42422: LD_ADDR_VAR 0 5
42426: PUSH
42427: LD_VAR 0 5
42431: PUSH
42432: LD_INT 3
42434: PLUS
42435: ST_TO_ADDR
42436: GO 42361
42438: POP
42439: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42440: LD_VAR 0 5
42444: PUSH
42445: LD_INT 0
42447: EQUAL
42448: PUSH
42449: LD_VAR 0 5
42453: PUSH
42454: LD_EXP 127
42458: PUSH
42459: LD_VAR 0 2
42463: ARRAY
42464: LESSEQUAL
42465: OR
42466: IFFALSE 42470
// continue ;
42468: GO 41720
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42470: LD_ADDR_VAR 0 6
42474: PUSH
42475: LD_EXP 87
42479: PUSH
42480: LD_VAR 0 2
42484: ARRAY
42485: PPUSH
42486: LD_INT 25
42488: PUSH
42489: LD_INT 3
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PPUSH
42496: CALL_OW 72
42500: PUSH
42501: LD_EXP 127
42505: PUSH
42506: LD_VAR 0 2
42510: ARRAY
42511: DIFF
42512: PPUSH
42513: LD_INT 3
42515: PPUSH
42516: CALL 85096 0 2
42520: ST_TO_ADDR
// for j in tmp do
42521: LD_ADDR_VAR 0 3
42525: PUSH
42526: LD_VAR 0 6
42530: PUSH
42531: FOR_IN
42532: IFFALSE 42567
// if GetTag ( j ) > 0 then
42534: LD_VAR 0 3
42538: PPUSH
42539: CALL_OW 110
42543: PUSH
42544: LD_INT 0
42546: GREATER
42547: IFFALSE 42565
// tmp := tmp diff j ;
42549: LD_ADDR_VAR 0 6
42553: PUSH
42554: LD_VAR 0 6
42558: PUSH
42559: LD_VAR 0 3
42563: DIFF
42564: ST_TO_ADDR
42565: GO 42531
42567: POP
42568: POP
// if not tmp then
42569: LD_VAR 0 6
42573: NOT
42574: IFFALSE 42578
// continue ;
42576: GO 41720
// if places then
42578: LD_VAR 0 5
42582: IFFALSE 42641
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42584: LD_ADDR_EXP 127
42588: PUSH
42589: LD_EXP 127
42593: PPUSH
42594: LD_VAR 0 2
42598: PPUSH
42599: LD_EXP 127
42603: PUSH
42604: LD_VAR 0 2
42608: ARRAY
42609: PUSH
42610: LD_VAR 0 6
42614: PUSH
42615: LD_INT 1
42617: ARRAY
42618: UNION
42619: PPUSH
42620: CALL_OW 1
42624: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42625: LD_VAR 0 6
42629: PUSH
42630: LD_INT 1
42632: ARRAY
42633: PPUSH
42634: LD_INT 126
42636: PPUSH
42637: CALL_OW 109
// end ; end ;
42641: GO 41720
42643: POP
42644: POP
// end ;
42645: LD_VAR 0 1
42649: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42650: LD_INT 0
42652: PPUSH
42653: PPUSH
42654: PPUSH
42655: PPUSH
42656: PPUSH
42657: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42658: LD_VAR 0 1
42662: NOT
42663: PUSH
42664: LD_VAR 0 2
42668: NOT
42669: OR
42670: PUSH
42671: LD_VAR 0 3
42675: NOT
42676: OR
42677: PUSH
42678: LD_VAR 0 4
42682: PUSH
42683: LD_INT 1
42685: PUSH
42686: LD_INT 2
42688: PUSH
42689: LD_INT 3
42691: PUSH
42692: LD_INT 4
42694: PUSH
42695: LD_INT 5
42697: PUSH
42698: LD_INT 8
42700: PUSH
42701: LD_INT 9
42703: PUSH
42704: LD_INT 15
42706: PUSH
42707: LD_INT 16
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: LIST
42714: LIST
42715: LIST
42716: LIST
42717: LIST
42718: LIST
42719: LIST
42720: IN
42721: NOT
42722: OR
42723: IFFALSE 42727
// exit ;
42725: GO 43627
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42727: LD_ADDR_VAR 0 2
42731: PUSH
42732: LD_VAR 0 2
42736: PPUSH
42737: LD_INT 21
42739: PUSH
42740: LD_INT 3
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 24
42749: PUSH
42750: LD_INT 250
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PPUSH
42761: CALL_OW 72
42765: ST_TO_ADDR
// case class of 1 , 15 :
42766: LD_VAR 0 4
42770: PUSH
42771: LD_INT 1
42773: DOUBLE
42774: EQUAL
42775: IFTRUE 42785
42777: LD_INT 15
42779: DOUBLE
42780: EQUAL
42781: IFTRUE 42785
42783: GO 42870
42785: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42786: LD_ADDR_VAR 0 8
42790: PUSH
42791: LD_VAR 0 2
42795: PPUSH
42796: LD_INT 2
42798: PUSH
42799: LD_INT 30
42801: PUSH
42802: LD_INT 32
42804: PUSH
42805: EMPTY
42806: LIST
42807: LIST
42808: PUSH
42809: LD_INT 30
42811: PUSH
42812: LD_INT 31
42814: PUSH
42815: EMPTY
42816: LIST
42817: LIST
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: LIST
42823: PPUSH
42824: CALL_OW 72
42828: PUSH
42829: LD_VAR 0 2
42833: PPUSH
42834: LD_INT 2
42836: PUSH
42837: LD_INT 30
42839: PUSH
42840: LD_INT 4
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: LD_INT 30
42849: PUSH
42850: LD_INT 5
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: LIST
42861: PPUSH
42862: CALL_OW 72
42866: ADD
42867: ST_TO_ADDR
42868: GO 43116
42870: LD_INT 2
42872: DOUBLE
42873: EQUAL
42874: IFTRUE 42884
42876: LD_INT 16
42878: DOUBLE
42879: EQUAL
42880: IFTRUE 42884
42882: GO 42930
42884: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42885: LD_ADDR_VAR 0 8
42889: PUSH
42890: LD_VAR 0 2
42894: PPUSH
42895: LD_INT 2
42897: PUSH
42898: LD_INT 30
42900: PUSH
42901: LD_INT 0
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 30
42910: PUSH
42911: LD_INT 1
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: LIST
42922: PPUSH
42923: CALL_OW 72
42927: ST_TO_ADDR
42928: GO 43116
42930: LD_INT 3
42932: DOUBLE
42933: EQUAL
42934: IFTRUE 42938
42936: GO 42984
42938: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42939: LD_ADDR_VAR 0 8
42943: PUSH
42944: LD_VAR 0 2
42948: PPUSH
42949: LD_INT 2
42951: PUSH
42952: LD_INT 30
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 30
42964: PUSH
42965: LD_INT 3
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: LIST
42976: PPUSH
42977: CALL_OW 72
42981: ST_TO_ADDR
42982: GO 43116
42984: LD_INT 4
42986: DOUBLE
42987: EQUAL
42988: IFTRUE 42992
42990: GO 43049
42992: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42993: LD_ADDR_VAR 0 8
42997: PUSH
42998: LD_VAR 0 2
43002: PPUSH
43003: LD_INT 2
43005: PUSH
43006: LD_INT 30
43008: PUSH
43009: LD_INT 6
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 30
43018: PUSH
43019: LD_INT 7
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 30
43028: PUSH
43029: LD_INT 8
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: PPUSH
43042: CALL_OW 72
43046: ST_TO_ADDR
43047: GO 43116
43049: LD_INT 5
43051: DOUBLE
43052: EQUAL
43053: IFTRUE 43069
43055: LD_INT 8
43057: DOUBLE
43058: EQUAL
43059: IFTRUE 43069
43061: LD_INT 9
43063: DOUBLE
43064: EQUAL
43065: IFTRUE 43069
43067: GO 43115
43069: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43070: LD_ADDR_VAR 0 8
43074: PUSH
43075: LD_VAR 0 2
43079: PPUSH
43080: LD_INT 2
43082: PUSH
43083: LD_INT 30
43085: PUSH
43086: LD_INT 4
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 30
43095: PUSH
43096: LD_INT 5
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: PPUSH
43108: CALL_OW 72
43112: ST_TO_ADDR
43113: GO 43116
43115: POP
// if not tmp then
43116: LD_VAR 0 8
43120: NOT
43121: IFFALSE 43125
// exit ;
43123: GO 43627
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43125: LD_VAR 0 4
43129: PUSH
43130: LD_INT 1
43132: PUSH
43133: LD_INT 15
43135: PUSH
43136: EMPTY
43137: LIST
43138: LIST
43139: IN
43140: PUSH
43141: LD_EXP 96
43145: PUSH
43146: LD_VAR 0 1
43150: ARRAY
43151: AND
43152: IFFALSE 43308
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43154: LD_ADDR_VAR 0 9
43158: PUSH
43159: LD_EXP 96
43163: PUSH
43164: LD_VAR 0 1
43168: ARRAY
43169: PUSH
43170: LD_INT 1
43172: ARRAY
43173: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43174: LD_VAR 0 9
43178: PUSH
43179: LD_EXP 97
43183: PUSH
43184: LD_VAR 0 1
43188: ARRAY
43189: IN
43190: NOT
43191: IFFALSE 43306
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43193: LD_ADDR_EXP 97
43197: PUSH
43198: LD_EXP 97
43202: PPUSH
43203: LD_VAR 0 1
43207: PUSH
43208: LD_EXP 97
43212: PUSH
43213: LD_VAR 0 1
43217: ARRAY
43218: PUSH
43219: LD_INT 1
43221: PLUS
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PPUSH
43227: LD_VAR 0 9
43231: PPUSH
43232: CALL 55547 0 3
43236: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43237: LD_ADDR_EXP 96
43241: PUSH
43242: LD_EXP 96
43246: PPUSH
43247: LD_VAR 0 1
43251: PPUSH
43252: LD_EXP 96
43256: PUSH
43257: LD_VAR 0 1
43261: ARRAY
43262: PUSH
43263: LD_VAR 0 9
43267: DIFF
43268: PPUSH
43269: CALL_OW 1
43273: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43274: LD_VAR 0 3
43278: PPUSH
43279: LD_EXP 97
43283: PUSH
43284: LD_VAR 0 1
43288: ARRAY
43289: PUSH
43290: LD_EXP 97
43294: PUSH
43295: LD_VAR 0 1
43299: ARRAY
43300: ARRAY
43301: PPUSH
43302: CALL_OW 120
// end ; exit ;
43306: GO 43627
// end ; if tmp > 1 then
43308: LD_VAR 0 8
43312: PUSH
43313: LD_INT 1
43315: GREATER
43316: IFFALSE 43420
// for i = 2 to tmp do
43318: LD_ADDR_VAR 0 6
43322: PUSH
43323: DOUBLE
43324: LD_INT 2
43326: DEC
43327: ST_TO_ADDR
43328: LD_VAR 0 8
43332: PUSH
43333: FOR_TO
43334: IFFALSE 43418
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43336: LD_VAR 0 8
43340: PUSH
43341: LD_VAR 0 6
43345: ARRAY
43346: PPUSH
43347: CALL_OW 461
43351: PUSH
43352: LD_INT 6
43354: EQUAL
43355: IFFALSE 43416
// begin x := tmp [ i ] ;
43357: LD_ADDR_VAR 0 9
43361: PUSH
43362: LD_VAR 0 8
43366: PUSH
43367: LD_VAR 0 6
43371: ARRAY
43372: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43373: LD_ADDR_VAR 0 8
43377: PUSH
43378: LD_VAR 0 8
43382: PPUSH
43383: LD_VAR 0 6
43387: PPUSH
43388: CALL_OW 3
43392: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43393: LD_ADDR_VAR 0 8
43397: PUSH
43398: LD_VAR 0 8
43402: PPUSH
43403: LD_INT 1
43405: PPUSH
43406: LD_VAR 0 9
43410: PPUSH
43411: CALL_OW 2
43415: ST_TO_ADDR
// end ;
43416: GO 43333
43418: POP
43419: POP
// for i in tmp do
43420: LD_ADDR_VAR 0 6
43424: PUSH
43425: LD_VAR 0 8
43429: PUSH
43430: FOR_IN
43431: IFFALSE 43500
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43433: LD_VAR 0 6
43437: PPUSH
43438: CALL_OW 313
43442: PUSH
43443: LD_INT 6
43445: LESS
43446: PUSH
43447: LD_VAR 0 6
43451: PPUSH
43452: CALL_OW 266
43456: PUSH
43457: LD_INT 31
43459: PUSH
43460: LD_INT 32
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: IN
43467: NOT
43468: AND
43469: PUSH
43470: LD_VAR 0 6
43474: PPUSH
43475: CALL_OW 313
43479: PUSH
43480: LD_INT 0
43482: EQUAL
43483: OR
43484: IFFALSE 43498
// begin j := i ;
43486: LD_ADDR_VAR 0 7
43490: PUSH
43491: LD_VAR 0 6
43495: ST_TO_ADDR
// break ;
43496: GO 43500
// end ; end ;
43498: GO 43430
43500: POP
43501: POP
// if j then
43502: LD_VAR 0 7
43506: IFFALSE 43524
// ComEnterUnit ( unit , j ) else
43508: LD_VAR 0 3
43512: PPUSH
43513: LD_VAR 0 7
43517: PPUSH
43518: CALL_OW 120
43522: GO 43627
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43524: LD_ADDR_VAR 0 10
43528: PUSH
43529: LD_VAR 0 2
43533: PPUSH
43534: LD_INT 2
43536: PUSH
43537: LD_INT 30
43539: PUSH
43540: LD_INT 0
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 30
43549: PUSH
43550: LD_INT 1
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: LIST
43561: PPUSH
43562: CALL_OW 72
43566: ST_TO_ADDR
// if depot then
43567: LD_VAR 0 10
43571: IFFALSE 43627
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43573: LD_ADDR_VAR 0 10
43577: PUSH
43578: LD_VAR 0 10
43582: PPUSH
43583: LD_VAR 0 3
43587: PPUSH
43588: CALL_OW 74
43592: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43593: LD_VAR 0 3
43597: PPUSH
43598: LD_VAR 0 10
43602: PPUSH
43603: CALL_OW 296
43607: PUSH
43608: LD_INT 10
43610: GREATER
43611: IFFALSE 43627
// ComStandNearbyBuilding ( unit , depot ) ;
43613: LD_VAR 0 3
43617: PPUSH
43618: LD_VAR 0 10
43622: PPUSH
43623: CALL 52161 0 2
// end ; end ; end ;
43627: LD_VAR 0 5
43631: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43632: LD_INT 0
43634: PPUSH
43635: PPUSH
43636: PPUSH
43637: PPUSH
// if not mc_bases then
43638: LD_EXP 87
43642: NOT
43643: IFFALSE 43647
// exit ;
43645: GO 43886
// for i = 1 to mc_bases do
43647: LD_ADDR_VAR 0 2
43651: PUSH
43652: DOUBLE
43653: LD_INT 1
43655: DEC
43656: ST_TO_ADDR
43657: LD_EXP 87
43661: PUSH
43662: FOR_TO
43663: IFFALSE 43884
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43665: LD_ADDR_VAR 0 4
43669: PUSH
43670: LD_EXP 87
43674: PUSH
43675: LD_VAR 0 2
43679: ARRAY
43680: PPUSH
43681: LD_INT 21
43683: PUSH
43684: LD_INT 1
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PPUSH
43691: CALL_OW 72
43695: PUSH
43696: LD_EXP 116
43700: PUSH
43701: LD_VAR 0 2
43705: ARRAY
43706: UNION
43707: ST_TO_ADDR
// if not tmp then
43708: LD_VAR 0 4
43712: NOT
43713: IFFALSE 43717
// continue ;
43715: GO 43662
// for j in tmp do
43717: LD_ADDR_VAR 0 3
43721: PUSH
43722: LD_VAR 0 4
43726: PUSH
43727: FOR_IN
43728: IFFALSE 43880
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43730: LD_VAR 0 3
43734: PPUSH
43735: CALL_OW 110
43739: NOT
43740: PUSH
43741: LD_VAR 0 3
43745: PPUSH
43746: CALL_OW 314
43750: NOT
43751: AND
43752: PUSH
43753: LD_VAR 0 3
43757: PPUSH
43758: CALL_OW 311
43762: NOT
43763: AND
43764: PUSH
43765: LD_VAR 0 3
43769: PPUSH
43770: CALL_OW 310
43774: NOT
43775: AND
43776: PUSH
43777: LD_VAR 0 3
43781: PUSH
43782: LD_EXP 90
43786: PUSH
43787: LD_VAR 0 2
43791: ARRAY
43792: PUSH
43793: LD_INT 1
43795: ARRAY
43796: IN
43797: NOT
43798: AND
43799: PUSH
43800: LD_VAR 0 3
43804: PUSH
43805: LD_EXP 90
43809: PUSH
43810: LD_VAR 0 2
43814: ARRAY
43815: PUSH
43816: LD_INT 2
43818: ARRAY
43819: IN
43820: NOT
43821: AND
43822: PUSH
43823: LD_VAR 0 3
43827: PUSH
43828: LD_EXP 99
43832: PUSH
43833: LD_VAR 0 2
43837: ARRAY
43838: IN
43839: NOT
43840: AND
43841: IFFALSE 43878
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43843: LD_VAR 0 2
43847: PPUSH
43848: LD_EXP 87
43852: PUSH
43853: LD_VAR 0 2
43857: ARRAY
43858: PPUSH
43859: LD_VAR 0 3
43863: PPUSH
43864: LD_VAR 0 3
43868: PPUSH
43869: CALL_OW 257
43873: PPUSH
43874: CALL 42650 0 4
// end ;
43878: GO 43727
43880: POP
43881: POP
// end ;
43882: GO 43662
43884: POP
43885: POP
// end ;
43886: LD_VAR 0 1
43890: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43891: LD_INT 0
43893: PPUSH
43894: PPUSH
43895: PPUSH
43896: PPUSH
43897: PPUSH
43898: PPUSH
// if not mc_bases [ base ] then
43899: LD_EXP 87
43903: PUSH
43904: LD_VAR 0 1
43908: ARRAY
43909: NOT
43910: IFFALSE 43914
// exit ;
43912: GO 44096
// tmp := [ ] ;
43914: LD_ADDR_VAR 0 6
43918: PUSH
43919: EMPTY
43920: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43921: LD_ADDR_VAR 0 7
43925: PUSH
43926: LD_VAR 0 3
43930: PPUSH
43931: LD_INT 0
43933: PPUSH
43934: CALL_OW 517
43938: ST_TO_ADDR
// if not list then
43939: LD_VAR 0 7
43943: NOT
43944: IFFALSE 43948
// exit ;
43946: GO 44096
// for i = 1 to amount do
43948: LD_ADDR_VAR 0 5
43952: PUSH
43953: DOUBLE
43954: LD_INT 1
43956: DEC
43957: ST_TO_ADDR
43958: LD_VAR 0 2
43962: PUSH
43963: FOR_TO
43964: IFFALSE 44044
// begin x := rand ( 1 , list [ 1 ] ) ;
43966: LD_ADDR_VAR 0 8
43970: PUSH
43971: LD_INT 1
43973: PPUSH
43974: LD_VAR 0 7
43978: PUSH
43979: LD_INT 1
43981: ARRAY
43982: PPUSH
43983: CALL_OW 12
43987: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43988: LD_ADDR_VAR 0 6
43992: PUSH
43993: LD_VAR 0 6
43997: PPUSH
43998: LD_VAR 0 5
44002: PPUSH
44003: LD_VAR 0 7
44007: PUSH
44008: LD_INT 1
44010: ARRAY
44011: PUSH
44012: LD_VAR 0 8
44016: ARRAY
44017: PUSH
44018: LD_VAR 0 7
44022: PUSH
44023: LD_INT 2
44025: ARRAY
44026: PUSH
44027: LD_VAR 0 8
44031: ARRAY
44032: PUSH
44033: EMPTY
44034: LIST
44035: LIST
44036: PPUSH
44037: CALL_OW 1
44041: ST_TO_ADDR
// end ;
44042: GO 43963
44044: POP
44045: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44046: LD_ADDR_EXP 100
44050: PUSH
44051: LD_EXP 100
44055: PPUSH
44056: LD_VAR 0 1
44060: PPUSH
44061: LD_VAR 0 6
44065: PPUSH
44066: CALL_OW 1
44070: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44071: LD_ADDR_EXP 102
44075: PUSH
44076: LD_EXP 102
44080: PPUSH
44081: LD_VAR 0 1
44085: PPUSH
44086: LD_VAR 0 3
44090: PPUSH
44091: CALL_OW 1
44095: ST_TO_ADDR
// end ;
44096: LD_VAR 0 4
44100: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44101: LD_INT 0
44103: PPUSH
// if not mc_bases [ base ] then
44104: LD_EXP 87
44108: PUSH
44109: LD_VAR 0 1
44113: ARRAY
44114: NOT
44115: IFFALSE 44119
// exit ;
44117: GO 44144
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44119: LD_ADDR_EXP 92
44123: PUSH
44124: LD_EXP 92
44128: PPUSH
44129: LD_VAR 0 1
44133: PPUSH
44134: LD_VAR 0 2
44138: PPUSH
44139: CALL_OW 1
44143: ST_TO_ADDR
// end ;
44144: LD_VAR 0 3
44148: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44149: LD_INT 0
44151: PPUSH
// if not mc_bases [ base ] then
44152: LD_EXP 87
44156: PUSH
44157: LD_VAR 0 1
44161: ARRAY
44162: NOT
44163: IFFALSE 44167
// exit ;
44165: GO 44204
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44167: LD_ADDR_EXP 92
44171: PUSH
44172: LD_EXP 92
44176: PPUSH
44177: LD_VAR 0 1
44181: PPUSH
44182: LD_EXP 92
44186: PUSH
44187: LD_VAR 0 1
44191: ARRAY
44192: PUSH
44193: LD_VAR 0 2
44197: UNION
44198: PPUSH
44199: CALL_OW 1
44203: ST_TO_ADDR
// end ;
44204: LD_VAR 0 3
44208: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44209: LD_INT 0
44211: PPUSH
// if not mc_bases [ base ] then
44212: LD_EXP 87
44216: PUSH
44217: LD_VAR 0 1
44221: ARRAY
44222: NOT
44223: IFFALSE 44227
// exit ;
44225: GO 44252
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44227: LD_ADDR_EXP 108
44231: PUSH
44232: LD_EXP 108
44236: PPUSH
44237: LD_VAR 0 1
44241: PPUSH
44242: LD_VAR 0 2
44246: PPUSH
44247: CALL_OW 1
44251: ST_TO_ADDR
// end ;
44252: LD_VAR 0 3
44256: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44257: LD_INT 0
44259: PPUSH
// if not mc_bases [ base ] then
44260: LD_EXP 87
44264: PUSH
44265: LD_VAR 0 1
44269: ARRAY
44270: NOT
44271: IFFALSE 44275
// exit ;
44273: GO 44312
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44275: LD_ADDR_EXP 108
44279: PUSH
44280: LD_EXP 108
44284: PPUSH
44285: LD_VAR 0 1
44289: PPUSH
44290: LD_EXP 108
44294: PUSH
44295: LD_VAR 0 1
44299: ARRAY
44300: PUSH
44301: LD_VAR 0 2
44305: ADD
44306: PPUSH
44307: CALL_OW 1
44311: ST_TO_ADDR
// end ;
44312: LD_VAR 0 3
44316: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44317: LD_INT 0
44319: PPUSH
// if not mc_bases [ base ] then
44320: LD_EXP 87
44324: PUSH
44325: LD_VAR 0 1
44329: ARRAY
44330: NOT
44331: IFFALSE 44335
// exit ;
44333: GO 44389
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44335: LD_ADDR_EXP 109
44339: PUSH
44340: LD_EXP 109
44344: PPUSH
44345: LD_VAR 0 1
44349: PPUSH
44350: LD_VAR 0 2
44354: PPUSH
44355: CALL_OW 1
44359: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44360: LD_ADDR_EXP 98
44364: PUSH
44365: LD_EXP 98
44369: PPUSH
44370: LD_VAR 0 1
44374: PPUSH
44375: LD_VAR 0 2
44379: PUSH
44380: LD_INT 0
44382: PLUS
44383: PPUSH
44384: CALL_OW 1
44388: ST_TO_ADDR
// end ;
44389: LD_VAR 0 3
44393: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44394: LD_INT 0
44396: PPUSH
// if not mc_bases [ base ] then
44397: LD_EXP 87
44401: PUSH
44402: LD_VAR 0 1
44406: ARRAY
44407: NOT
44408: IFFALSE 44412
// exit ;
44410: GO 44437
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44412: LD_ADDR_EXP 98
44416: PUSH
44417: LD_EXP 98
44421: PPUSH
44422: LD_VAR 0 1
44426: PPUSH
44427: LD_VAR 0 2
44431: PPUSH
44432: CALL_OW 1
44436: ST_TO_ADDR
// end ;
44437: LD_VAR 0 3
44441: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44442: LD_INT 0
44444: PPUSH
44445: PPUSH
44446: PPUSH
44447: PPUSH
// if not mc_bases [ base ] then
44448: LD_EXP 87
44452: PUSH
44453: LD_VAR 0 1
44457: ARRAY
44458: NOT
44459: IFFALSE 44463
// exit ;
44461: GO 44528
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44463: LD_ADDR_EXP 107
44467: PUSH
44468: LD_EXP 107
44472: PPUSH
44473: LD_VAR 0 1
44477: PUSH
44478: LD_EXP 107
44482: PUSH
44483: LD_VAR 0 1
44487: ARRAY
44488: PUSH
44489: LD_INT 1
44491: PLUS
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: PPUSH
44497: LD_VAR 0 1
44501: PUSH
44502: LD_VAR 0 2
44506: PUSH
44507: LD_VAR 0 3
44511: PUSH
44512: LD_VAR 0 4
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: PPUSH
44523: CALL 55547 0 3
44527: ST_TO_ADDR
// end ;
44528: LD_VAR 0 5
44532: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44533: LD_INT 0
44535: PPUSH
// if not mc_bases [ base ] then
44536: LD_EXP 87
44540: PUSH
44541: LD_VAR 0 1
44545: ARRAY
44546: NOT
44547: IFFALSE 44551
// exit ;
44549: GO 44576
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44551: LD_ADDR_EXP 124
44555: PUSH
44556: LD_EXP 124
44560: PPUSH
44561: LD_VAR 0 1
44565: PPUSH
44566: LD_VAR 0 2
44570: PPUSH
44571: CALL_OW 1
44575: ST_TO_ADDR
// end ;
44576: LD_VAR 0 3
44580: RET
// export function MC_GetMinesField ( base ) ; begin
44581: LD_INT 0
44583: PPUSH
// result := mc_mines [ base ] ;
44584: LD_ADDR_VAR 0 2
44588: PUSH
44589: LD_EXP 100
44593: PUSH
44594: LD_VAR 0 1
44598: ARRAY
44599: ST_TO_ADDR
// end ;
44600: LD_VAR 0 2
44604: RET
// export function MC_GetProduceList ( base ) ; begin
44605: LD_INT 0
44607: PPUSH
// result := mc_produce [ base ] ;
44608: LD_ADDR_VAR 0 2
44612: PUSH
44613: LD_EXP 108
44617: PUSH
44618: LD_VAR 0 1
44622: ARRAY
44623: ST_TO_ADDR
// end ;
44624: LD_VAR 0 2
44628: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44629: LD_INT 0
44631: PPUSH
44632: PPUSH
// if not mc_bases then
44633: LD_EXP 87
44637: NOT
44638: IFFALSE 44642
// exit ;
44640: GO 44707
// if mc_bases [ base ] then
44642: LD_EXP 87
44646: PUSH
44647: LD_VAR 0 1
44651: ARRAY
44652: IFFALSE 44707
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44654: LD_ADDR_VAR 0 3
44658: PUSH
44659: LD_EXP 87
44663: PUSH
44664: LD_VAR 0 1
44668: ARRAY
44669: PPUSH
44670: LD_INT 30
44672: PUSH
44673: LD_VAR 0 2
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: PPUSH
44682: CALL_OW 72
44686: ST_TO_ADDR
// if result then
44687: LD_VAR 0 3
44691: IFFALSE 44707
// result := result [ 1 ] ;
44693: LD_ADDR_VAR 0 3
44697: PUSH
44698: LD_VAR 0 3
44702: PUSH
44703: LD_INT 1
44705: ARRAY
44706: ST_TO_ADDR
// end ; end ;
44707: LD_VAR 0 3
44711: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44712: LD_INT 0
44714: PPUSH
44715: PPUSH
// if not mc_bases then
44716: LD_EXP 87
44720: NOT
44721: IFFALSE 44725
// exit ;
44723: GO 44770
// if mc_bases [ base ] then
44725: LD_EXP 87
44729: PUSH
44730: LD_VAR 0 1
44734: ARRAY
44735: IFFALSE 44770
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44737: LD_ADDR_VAR 0 3
44741: PUSH
44742: LD_EXP 87
44746: PUSH
44747: LD_VAR 0 1
44751: ARRAY
44752: PPUSH
44753: LD_INT 30
44755: PUSH
44756: LD_VAR 0 2
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PPUSH
44765: CALL_OW 72
44769: ST_TO_ADDR
// end ;
44770: LD_VAR 0 3
44774: RET
// export function MC_SetTame ( base , area ) ; begin
44775: LD_INT 0
44777: PPUSH
// if not mc_bases or not base then
44778: LD_EXP 87
44782: NOT
44783: PUSH
44784: LD_VAR 0 1
44788: NOT
44789: OR
44790: IFFALSE 44794
// exit ;
44792: GO 44819
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44794: LD_ADDR_EXP 115
44798: PUSH
44799: LD_EXP 115
44803: PPUSH
44804: LD_VAR 0 1
44808: PPUSH
44809: LD_VAR 0 2
44813: PPUSH
44814: CALL_OW 1
44818: ST_TO_ADDR
// end ;
44819: LD_VAR 0 3
44823: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44824: LD_INT 0
44826: PPUSH
44827: PPUSH
// if not mc_bases or not base then
44828: LD_EXP 87
44832: NOT
44833: PUSH
44834: LD_VAR 0 1
44838: NOT
44839: OR
44840: IFFALSE 44844
// exit ;
44842: GO 44946
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44844: LD_ADDR_VAR 0 4
44848: PUSH
44849: LD_EXP 87
44853: PUSH
44854: LD_VAR 0 1
44858: ARRAY
44859: PPUSH
44860: LD_INT 30
44862: PUSH
44863: LD_VAR 0 2
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PPUSH
44872: CALL_OW 72
44876: ST_TO_ADDR
// if not tmp then
44877: LD_VAR 0 4
44881: NOT
44882: IFFALSE 44886
// exit ;
44884: GO 44946
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44886: LD_ADDR_EXP 119
44890: PUSH
44891: LD_EXP 119
44895: PPUSH
44896: LD_VAR 0 1
44900: PPUSH
44901: LD_EXP 119
44905: PUSH
44906: LD_VAR 0 1
44910: ARRAY
44911: PPUSH
44912: LD_EXP 119
44916: PUSH
44917: LD_VAR 0 1
44921: ARRAY
44922: PUSH
44923: LD_INT 1
44925: PLUS
44926: PPUSH
44927: LD_VAR 0 4
44931: PUSH
44932: LD_INT 1
44934: ARRAY
44935: PPUSH
44936: CALL_OW 2
44940: PPUSH
44941: CALL_OW 1
44945: ST_TO_ADDR
// end ;
44946: LD_VAR 0 3
44950: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44951: LD_INT 0
44953: PPUSH
44954: PPUSH
// if not mc_bases or not base or not kinds then
44955: LD_EXP 87
44959: NOT
44960: PUSH
44961: LD_VAR 0 1
44965: NOT
44966: OR
44967: PUSH
44968: LD_VAR 0 2
44972: NOT
44973: OR
44974: IFFALSE 44978
// exit ;
44976: GO 45039
// for i in kinds do
44978: LD_ADDR_VAR 0 4
44982: PUSH
44983: LD_VAR 0 2
44987: PUSH
44988: FOR_IN
44989: IFFALSE 45037
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44991: LD_ADDR_EXP 121
44995: PUSH
44996: LD_EXP 121
45000: PPUSH
45001: LD_VAR 0 1
45005: PUSH
45006: LD_EXP 121
45010: PUSH
45011: LD_VAR 0 1
45015: ARRAY
45016: PUSH
45017: LD_INT 1
45019: PLUS
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: PPUSH
45025: LD_VAR 0 4
45029: PPUSH
45030: CALL 55547 0 3
45034: ST_TO_ADDR
45035: GO 44988
45037: POP
45038: POP
// end ;
45039: LD_VAR 0 3
45043: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45044: LD_INT 0
45046: PPUSH
// if not mc_bases or not base or not areas then
45047: LD_EXP 87
45051: NOT
45052: PUSH
45053: LD_VAR 0 1
45057: NOT
45058: OR
45059: PUSH
45060: LD_VAR 0 2
45064: NOT
45065: OR
45066: IFFALSE 45070
// exit ;
45068: GO 45095
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45070: LD_ADDR_EXP 105
45074: PUSH
45075: LD_EXP 105
45079: PPUSH
45080: LD_VAR 0 1
45084: PPUSH
45085: LD_VAR 0 2
45089: PPUSH
45090: CALL_OW 1
45094: ST_TO_ADDR
// end ;
45095: LD_VAR 0 3
45099: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45100: LD_INT 0
45102: PPUSH
// if not mc_bases or not base or not teleports_exit then
45103: LD_EXP 87
45107: NOT
45108: PUSH
45109: LD_VAR 0 1
45113: NOT
45114: OR
45115: PUSH
45116: LD_VAR 0 2
45120: NOT
45121: OR
45122: IFFALSE 45126
// exit ;
45124: GO 45151
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45126: LD_ADDR_EXP 122
45130: PUSH
45131: LD_EXP 122
45135: PPUSH
45136: LD_VAR 0 1
45140: PPUSH
45141: LD_VAR 0 2
45145: PPUSH
45146: CALL_OW 1
45150: ST_TO_ADDR
// end ;
45151: LD_VAR 0 3
45155: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45156: LD_INT 0
45158: PPUSH
45159: PPUSH
45160: PPUSH
// if not mc_bases or not base or not ext_list then
45161: LD_EXP 87
45165: NOT
45166: PUSH
45167: LD_VAR 0 1
45171: NOT
45172: OR
45173: PUSH
45174: LD_VAR 0 5
45178: NOT
45179: OR
45180: IFFALSE 45184
// exit ;
45182: GO 45357
// tmp := GetFacExtXYD ( x , y , d ) ;
45184: LD_ADDR_VAR 0 8
45188: PUSH
45189: LD_VAR 0 2
45193: PPUSH
45194: LD_VAR 0 3
45198: PPUSH
45199: LD_VAR 0 4
45203: PPUSH
45204: CALL 84226 0 3
45208: ST_TO_ADDR
// if not tmp then
45209: LD_VAR 0 8
45213: NOT
45214: IFFALSE 45218
// exit ;
45216: GO 45357
// for i in tmp do
45218: LD_ADDR_VAR 0 7
45222: PUSH
45223: LD_VAR 0 8
45227: PUSH
45228: FOR_IN
45229: IFFALSE 45355
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45231: LD_ADDR_EXP 92
45235: PUSH
45236: LD_EXP 92
45240: PPUSH
45241: LD_VAR 0 1
45245: PPUSH
45246: LD_EXP 92
45250: PUSH
45251: LD_VAR 0 1
45255: ARRAY
45256: PPUSH
45257: LD_EXP 92
45261: PUSH
45262: LD_VAR 0 1
45266: ARRAY
45267: PUSH
45268: LD_INT 1
45270: PLUS
45271: PPUSH
45272: LD_VAR 0 5
45276: PUSH
45277: LD_INT 1
45279: ARRAY
45280: PUSH
45281: LD_VAR 0 7
45285: PUSH
45286: LD_INT 1
45288: ARRAY
45289: PUSH
45290: LD_VAR 0 7
45294: PUSH
45295: LD_INT 2
45297: ARRAY
45298: PUSH
45299: LD_VAR 0 7
45303: PUSH
45304: LD_INT 3
45306: ARRAY
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: PPUSH
45314: CALL_OW 2
45318: PPUSH
45319: CALL_OW 1
45323: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45324: LD_ADDR_VAR 0 5
45328: PUSH
45329: LD_VAR 0 5
45333: PPUSH
45334: LD_INT 1
45336: PPUSH
45337: CALL_OW 3
45341: ST_TO_ADDR
// if not ext_list then
45342: LD_VAR 0 5
45346: NOT
45347: IFFALSE 45353
// exit ;
45349: POP
45350: POP
45351: GO 45357
// end ;
45353: GO 45228
45355: POP
45356: POP
// end ;
45357: LD_VAR 0 6
45361: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45362: LD_INT 0
45364: PPUSH
// if not mc_bases or not base or not weapon_list then
45365: LD_EXP 87
45369: NOT
45370: PUSH
45371: LD_VAR 0 1
45375: NOT
45376: OR
45377: PUSH
45378: LD_VAR 0 2
45382: NOT
45383: OR
45384: IFFALSE 45388
// exit ;
45386: GO 45413
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45388: LD_ADDR_EXP 126
45392: PUSH
45393: LD_EXP 126
45397: PPUSH
45398: LD_VAR 0 1
45402: PPUSH
45403: LD_VAR 0 2
45407: PPUSH
45408: CALL_OW 1
45412: ST_TO_ADDR
// end ;
45413: LD_VAR 0 3
45417: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45418: LD_INT 0
45420: PPUSH
// if not mc_bases or not base or not tech_list then
45421: LD_EXP 87
45425: NOT
45426: PUSH
45427: LD_VAR 0 1
45431: NOT
45432: OR
45433: PUSH
45434: LD_VAR 0 2
45438: NOT
45439: OR
45440: IFFALSE 45444
// exit ;
45442: GO 45469
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45444: LD_ADDR_EXP 114
45448: PUSH
45449: LD_EXP 114
45453: PPUSH
45454: LD_VAR 0 1
45458: PPUSH
45459: LD_VAR 0 2
45463: PPUSH
45464: CALL_OW 1
45468: ST_TO_ADDR
// end ;
45469: LD_VAR 0 3
45473: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45474: LD_INT 0
45476: PPUSH
// if not mc_bases or not parking_area or not base then
45477: LD_EXP 87
45481: NOT
45482: PUSH
45483: LD_VAR 0 2
45487: NOT
45488: OR
45489: PUSH
45490: LD_VAR 0 1
45494: NOT
45495: OR
45496: IFFALSE 45500
// exit ;
45498: GO 45525
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45500: LD_ADDR_EXP 111
45504: PUSH
45505: LD_EXP 111
45509: PPUSH
45510: LD_VAR 0 1
45514: PPUSH
45515: LD_VAR 0 2
45519: PPUSH
45520: CALL_OW 1
45524: ST_TO_ADDR
// end ;
45525: LD_VAR 0 3
45529: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45530: LD_INT 0
45532: PPUSH
// if not mc_bases or not base or not scan_area then
45533: LD_EXP 87
45537: NOT
45538: PUSH
45539: LD_VAR 0 1
45543: NOT
45544: OR
45545: PUSH
45546: LD_VAR 0 2
45550: NOT
45551: OR
45552: IFFALSE 45556
// exit ;
45554: GO 45581
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45556: LD_ADDR_EXP 112
45560: PUSH
45561: LD_EXP 112
45565: PPUSH
45566: LD_VAR 0 1
45570: PPUSH
45571: LD_VAR 0 2
45575: PPUSH
45576: CALL_OW 1
45580: ST_TO_ADDR
// end ;
45581: LD_VAR 0 3
45585: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45586: LD_INT 0
45588: PPUSH
45589: PPUSH
// if not mc_bases or not base then
45590: LD_EXP 87
45594: NOT
45595: PUSH
45596: LD_VAR 0 1
45600: NOT
45601: OR
45602: IFFALSE 45606
// exit ;
45604: GO 45670
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45606: LD_ADDR_VAR 0 3
45610: PUSH
45611: LD_INT 1
45613: PUSH
45614: LD_INT 2
45616: PUSH
45617: LD_INT 3
45619: PUSH
45620: LD_INT 4
45622: PUSH
45623: LD_INT 11
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45633: LD_ADDR_EXP 114
45637: PUSH
45638: LD_EXP 114
45642: PPUSH
45643: LD_VAR 0 1
45647: PPUSH
45648: LD_EXP 114
45652: PUSH
45653: LD_VAR 0 1
45657: ARRAY
45658: PUSH
45659: LD_VAR 0 3
45663: DIFF
45664: PPUSH
45665: CALL_OW 1
45669: ST_TO_ADDR
// end ;
45670: LD_VAR 0 2
45674: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45675: LD_INT 0
45677: PPUSH
// result := mc_vehicles [ base ] ;
45678: LD_ADDR_VAR 0 3
45682: PUSH
45683: LD_EXP 106
45687: PUSH
45688: LD_VAR 0 1
45692: ARRAY
45693: ST_TO_ADDR
// if onlyCombat then
45694: LD_VAR 0 2
45698: IFFALSE 45863
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45700: LD_ADDR_VAR 0 3
45704: PUSH
45705: LD_VAR 0 3
45709: PUSH
45710: LD_VAR 0 3
45714: PPUSH
45715: LD_INT 2
45717: PUSH
45718: LD_INT 34
45720: PUSH
45721: LD_INT 12
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PUSH
45728: LD_INT 34
45730: PUSH
45731: LD_INT 51
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 34
45740: PUSH
45741: LD_EXP 73
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PUSH
45750: LD_INT 34
45752: PUSH
45753: LD_INT 32
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 34
45762: PUSH
45763: LD_INT 13
45765: PUSH
45766: EMPTY
45767: LIST
45768: LIST
45769: PUSH
45770: LD_INT 34
45772: PUSH
45773: LD_INT 52
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 34
45782: PUSH
45783: LD_INT 14
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: LD_INT 34
45792: PUSH
45793: LD_INT 53
45795: PUSH
45796: EMPTY
45797: LIST
45798: LIST
45799: PUSH
45800: LD_INT 34
45802: PUSH
45803: LD_EXP 72
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: PUSH
45812: LD_INT 34
45814: PUSH
45815: LD_INT 31
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 34
45824: PUSH
45825: LD_INT 48
45827: PUSH
45828: EMPTY
45829: LIST
45830: LIST
45831: PUSH
45832: LD_INT 34
45834: PUSH
45835: LD_INT 8
45837: PUSH
45838: EMPTY
45839: LIST
45840: LIST
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: LIST
45855: LIST
45856: PPUSH
45857: CALL_OW 72
45861: DIFF
45862: ST_TO_ADDR
// end ; end_of_file
45863: LD_VAR 0 3
45867: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45868: LD_INT 0
45870: PPUSH
45871: PPUSH
45872: PPUSH
// if not mc_bases or not skirmish then
45873: LD_EXP 87
45877: NOT
45878: PUSH
45879: LD_EXP 85
45883: NOT
45884: OR
45885: IFFALSE 45889
// exit ;
45887: GO 46054
// for i = 1 to mc_bases do
45889: LD_ADDR_VAR 0 4
45893: PUSH
45894: DOUBLE
45895: LD_INT 1
45897: DEC
45898: ST_TO_ADDR
45899: LD_EXP 87
45903: PUSH
45904: FOR_TO
45905: IFFALSE 46052
// begin if sci in mc_bases [ i ] then
45907: LD_VAR 0 2
45911: PUSH
45912: LD_EXP 87
45916: PUSH
45917: LD_VAR 0 4
45921: ARRAY
45922: IN
45923: IFFALSE 46050
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45925: LD_ADDR_EXP 116
45929: PUSH
45930: LD_EXP 116
45934: PPUSH
45935: LD_VAR 0 4
45939: PUSH
45940: LD_EXP 116
45944: PUSH
45945: LD_VAR 0 4
45949: ARRAY
45950: PUSH
45951: LD_INT 1
45953: PLUS
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PPUSH
45959: LD_VAR 0 1
45963: PPUSH
45964: CALL 55547 0 3
45968: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45969: LD_ADDR_VAR 0 5
45973: PUSH
45974: LD_EXP 87
45978: PUSH
45979: LD_VAR 0 4
45983: ARRAY
45984: PPUSH
45985: LD_INT 2
45987: PUSH
45988: LD_INT 30
45990: PUSH
45991: LD_INT 0
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 30
46000: PUSH
46001: LD_INT 1
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: EMPTY
46009: LIST
46010: LIST
46011: LIST
46012: PPUSH
46013: CALL_OW 72
46017: PPUSH
46018: LD_VAR 0 1
46022: PPUSH
46023: CALL_OW 74
46027: ST_TO_ADDR
// if tmp then
46028: LD_VAR 0 5
46032: IFFALSE 46048
// ComStandNearbyBuilding ( ape , tmp ) ;
46034: LD_VAR 0 1
46038: PPUSH
46039: LD_VAR 0 5
46043: PPUSH
46044: CALL 52161 0 2
// break ;
46048: GO 46052
// end ; end ;
46050: GO 45904
46052: POP
46053: POP
// end ;
46054: LD_VAR 0 3
46058: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46059: LD_INT 0
46061: PPUSH
46062: PPUSH
46063: PPUSH
// if not mc_bases or not skirmish then
46064: LD_EXP 87
46068: NOT
46069: PUSH
46070: LD_EXP 85
46074: NOT
46075: OR
46076: IFFALSE 46080
// exit ;
46078: GO 46169
// for i = 1 to mc_bases do
46080: LD_ADDR_VAR 0 4
46084: PUSH
46085: DOUBLE
46086: LD_INT 1
46088: DEC
46089: ST_TO_ADDR
46090: LD_EXP 87
46094: PUSH
46095: FOR_TO
46096: IFFALSE 46167
// begin if building in mc_busy_turret_list [ i ] then
46098: LD_VAR 0 1
46102: PUSH
46103: LD_EXP 97
46107: PUSH
46108: LD_VAR 0 4
46112: ARRAY
46113: IN
46114: IFFALSE 46165
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46116: LD_ADDR_VAR 0 5
46120: PUSH
46121: LD_EXP 97
46125: PUSH
46126: LD_VAR 0 4
46130: ARRAY
46131: PUSH
46132: LD_VAR 0 1
46136: DIFF
46137: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46138: LD_ADDR_EXP 97
46142: PUSH
46143: LD_EXP 97
46147: PPUSH
46148: LD_VAR 0 4
46152: PPUSH
46153: LD_VAR 0 5
46157: PPUSH
46158: CALL_OW 1
46162: ST_TO_ADDR
// break ;
46163: GO 46167
// end ; end ;
46165: GO 46095
46167: POP
46168: POP
// end ;
46169: LD_VAR 0 3
46173: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46174: LD_INT 0
46176: PPUSH
46177: PPUSH
46178: PPUSH
// if not mc_bases or not skirmish then
46179: LD_EXP 87
46183: NOT
46184: PUSH
46185: LD_EXP 85
46189: NOT
46190: OR
46191: IFFALSE 46195
// exit ;
46193: GO 46394
// for i = 1 to mc_bases do
46195: LD_ADDR_VAR 0 5
46199: PUSH
46200: DOUBLE
46201: LD_INT 1
46203: DEC
46204: ST_TO_ADDR
46205: LD_EXP 87
46209: PUSH
46210: FOR_TO
46211: IFFALSE 46392
// if building in mc_bases [ i ] then
46213: LD_VAR 0 1
46217: PUSH
46218: LD_EXP 87
46222: PUSH
46223: LD_VAR 0 5
46227: ARRAY
46228: IN
46229: IFFALSE 46390
// begin tmp := mc_bases [ i ] diff building ;
46231: LD_ADDR_VAR 0 6
46235: PUSH
46236: LD_EXP 87
46240: PUSH
46241: LD_VAR 0 5
46245: ARRAY
46246: PUSH
46247: LD_VAR 0 1
46251: DIFF
46252: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46253: LD_ADDR_EXP 87
46257: PUSH
46258: LD_EXP 87
46262: PPUSH
46263: LD_VAR 0 5
46267: PPUSH
46268: LD_VAR 0 6
46272: PPUSH
46273: CALL_OW 1
46277: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46278: LD_VAR 0 1
46282: PUSH
46283: LD_EXP 95
46287: PUSH
46288: LD_VAR 0 5
46292: ARRAY
46293: IN
46294: IFFALSE 46333
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46296: LD_ADDR_EXP 95
46300: PUSH
46301: LD_EXP 95
46305: PPUSH
46306: LD_VAR 0 5
46310: PPUSH
46311: LD_EXP 95
46315: PUSH
46316: LD_VAR 0 5
46320: ARRAY
46321: PUSH
46322: LD_VAR 0 1
46326: DIFF
46327: PPUSH
46328: CALL_OW 1
46332: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46333: LD_VAR 0 1
46337: PUSH
46338: LD_EXP 96
46342: PUSH
46343: LD_VAR 0 5
46347: ARRAY
46348: IN
46349: IFFALSE 46388
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46351: LD_ADDR_EXP 96
46355: PUSH
46356: LD_EXP 96
46360: PPUSH
46361: LD_VAR 0 5
46365: PPUSH
46366: LD_EXP 96
46370: PUSH
46371: LD_VAR 0 5
46375: ARRAY
46376: PUSH
46377: LD_VAR 0 1
46381: DIFF
46382: PPUSH
46383: CALL_OW 1
46387: ST_TO_ADDR
// break ;
46388: GO 46392
// end ;
46390: GO 46210
46392: POP
46393: POP
// end ;
46394: LD_VAR 0 4
46398: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46399: LD_INT 0
46401: PPUSH
46402: PPUSH
46403: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46404: LD_EXP 87
46408: NOT
46409: PUSH
46410: LD_EXP 85
46414: NOT
46415: OR
46416: PUSH
46417: LD_VAR 0 3
46421: PUSH
46422: LD_EXP 113
46426: IN
46427: NOT
46428: OR
46429: IFFALSE 46433
// exit ;
46431: GO 46556
// for i = 1 to mc_vehicles do
46433: LD_ADDR_VAR 0 6
46437: PUSH
46438: DOUBLE
46439: LD_INT 1
46441: DEC
46442: ST_TO_ADDR
46443: LD_EXP 106
46447: PUSH
46448: FOR_TO
46449: IFFALSE 46554
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46451: LD_VAR 0 2
46455: PUSH
46456: LD_EXP 106
46460: PUSH
46461: LD_VAR 0 6
46465: ARRAY
46466: IN
46467: PUSH
46468: LD_VAR 0 1
46472: PUSH
46473: LD_EXP 106
46477: PUSH
46478: LD_VAR 0 6
46482: ARRAY
46483: IN
46484: OR
46485: IFFALSE 46552
// begin tmp := mc_vehicles [ i ] diff old ;
46487: LD_ADDR_VAR 0 7
46491: PUSH
46492: LD_EXP 106
46496: PUSH
46497: LD_VAR 0 6
46501: ARRAY
46502: PUSH
46503: LD_VAR 0 2
46507: DIFF
46508: ST_TO_ADDR
// tmp := tmp diff new ;
46509: LD_ADDR_VAR 0 7
46513: PUSH
46514: LD_VAR 0 7
46518: PUSH
46519: LD_VAR 0 1
46523: DIFF
46524: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46525: LD_ADDR_EXP 106
46529: PUSH
46530: LD_EXP 106
46534: PPUSH
46535: LD_VAR 0 6
46539: PPUSH
46540: LD_VAR 0 7
46544: PPUSH
46545: CALL_OW 1
46549: ST_TO_ADDR
// break ;
46550: GO 46554
// end ;
46552: GO 46448
46554: POP
46555: POP
// end ;
46556: LD_VAR 0 5
46560: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46561: LD_INT 0
46563: PPUSH
46564: PPUSH
46565: PPUSH
46566: PPUSH
// if not mc_bases or not skirmish then
46567: LD_EXP 87
46571: NOT
46572: PUSH
46573: LD_EXP 85
46577: NOT
46578: OR
46579: IFFALSE 46583
// exit ;
46581: GO 46960
// side := GetSide ( vehicle ) ;
46583: LD_ADDR_VAR 0 5
46587: PUSH
46588: LD_VAR 0 1
46592: PPUSH
46593: CALL_OW 255
46597: ST_TO_ADDR
// for i = 1 to mc_bases do
46598: LD_ADDR_VAR 0 4
46602: PUSH
46603: DOUBLE
46604: LD_INT 1
46606: DEC
46607: ST_TO_ADDR
46608: LD_EXP 87
46612: PUSH
46613: FOR_TO
46614: IFFALSE 46958
// begin if factory in mc_bases [ i ] then
46616: LD_VAR 0 2
46620: PUSH
46621: LD_EXP 87
46625: PUSH
46626: LD_VAR 0 4
46630: ARRAY
46631: IN
46632: IFFALSE 46956
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46634: LD_EXP 109
46638: PUSH
46639: LD_VAR 0 4
46643: ARRAY
46644: PUSH
46645: LD_EXP 98
46649: PUSH
46650: LD_VAR 0 4
46654: ARRAY
46655: LESS
46656: PUSH
46657: LD_VAR 0 1
46661: PPUSH
46662: CALL_OW 264
46666: PUSH
46667: LD_INT 31
46669: PUSH
46670: LD_INT 32
46672: PUSH
46673: LD_INT 51
46675: PUSH
46676: LD_EXP 73
46680: PUSH
46681: LD_INT 12
46683: PUSH
46684: LD_INT 30
46686: PUSH
46687: LD_EXP 72
46691: PUSH
46692: LD_INT 11
46694: PUSH
46695: LD_INT 53
46697: PUSH
46698: LD_INT 14
46700: PUSH
46701: LD_EXP 76
46705: PUSH
46706: LD_INT 29
46708: PUSH
46709: LD_EXP 74
46713: PUSH
46714: LD_INT 13
46716: PUSH
46717: LD_INT 52
46719: PUSH
46720: LD_INT 48
46722: PUSH
46723: LD_INT 8
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: IN
46745: NOT
46746: AND
46747: IFFALSE 46795
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46749: LD_ADDR_EXP 109
46753: PUSH
46754: LD_EXP 109
46758: PPUSH
46759: LD_VAR 0 4
46763: PUSH
46764: LD_EXP 109
46768: PUSH
46769: LD_VAR 0 4
46773: ARRAY
46774: PUSH
46775: LD_INT 1
46777: PLUS
46778: PUSH
46779: EMPTY
46780: LIST
46781: LIST
46782: PPUSH
46783: LD_VAR 0 1
46787: PPUSH
46788: CALL 55547 0 3
46792: ST_TO_ADDR
46793: GO 46839
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46795: LD_ADDR_EXP 106
46799: PUSH
46800: LD_EXP 106
46804: PPUSH
46805: LD_VAR 0 4
46809: PUSH
46810: LD_EXP 106
46814: PUSH
46815: LD_VAR 0 4
46819: ARRAY
46820: PUSH
46821: LD_INT 1
46823: PLUS
46824: PUSH
46825: EMPTY
46826: LIST
46827: LIST
46828: PPUSH
46829: LD_VAR 0 1
46833: PPUSH
46834: CALL 55547 0 3
46838: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46839: LD_VAR 0 1
46843: PPUSH
46844: CALL_OW 263
46848: PUSH
46849: LD_INT 2
46851: EQUAL
46852: IFFALSE 46872
// begin repeat wait ( 0 0$1 ) ;
46854: LD_INT 35
46856: PPUSH
46857: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46861: LD_VAR 0 1
46865: PPUSH
46866: CALL_OW 312
46870: IFFALSE 46854
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46872: LD_VAR 0 1
46876: PPUSH
46877: LD_EXP 111
46881: PUSH
46882: LD_VAR 0 4
46886: ARRAY
46887: PPUSH
46888: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46892: LD_VAR 0 1
46896: PPUSH
46897: CALL_OW 263
46901: PUSH
46902: LD_INT 1
46904: NONEQUAL
46905: IFFALSE 46909
// break ;
46907: GO 46958
// repeat wait ( 0 0$1 ) ;
46909: LD_INT 35
46911: PPUSH
46912: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46916: LD_VAR 0 1
46920: PPUSH
46921: LD_EXP 111
46925: PUSH
46926: LD_VAR 0 4
46930: ARRAY
46931: PPUSH
46932: CALL_OW 308
46936: IFFALSE 46909
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46938: LD_VAR 0 1
46942: PPUSH
46943: CALL_OW 311
46947: PPUSH
46948: CALL_OW 121
// exit ;
46952: POP
46953: POP
46954: GO 46960
// end ; end ;
46956: GO 46613
46958: POP
46959: POP
// end ;
46960: LD_VAR 0 3
46964: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46965: LD_INT 0
46967: PPUSH
46968: PPUSH
46969: PPUSH
46970: PPUSH
// if not mc_bases or not skirmish then
46971: LD_EXP 87
46975: NOT
46976: PUSH
46977: LD_EXP 85
46981: NOT
46982: OR
46983: IFFALSE 46987
// exit ;
46985: GO 47340
// repeat wait ( 0 0$1 ) ;
46987: LD_INT 35
46989: PPUSH
46990: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46994: LD_VAR 0 2
46998: PPUSH
46999: LD_VAR 0 3
47003: PPUSH
47004: CALL_OW 284
47008: IFFALSE 46987
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47010: LD_VAR 0 2
47014: PPUSH
47015: LD_VAR 0 3
47019: PPUSH
47020: CALL_OW 283
47024: PUSH
47025: LD_INT 4
47027: EQUAL
47028: IFFALSE 47032
// exit ;
47030: GO 47340
// for i = 1 to mc_bases do
47032: LD_ADDR_VAR 0 7
47036: PUSH
47037: DOUBLE
47038: LD_INT 1
47040: DEC
47041: ST_TO_ADDR
47042: LD_EXP 87
47046: PUSH
47047: FOR_TO
47048: IFFALSE 47338
// begin if mc_crates_area [ i ] then
47050: LD_EXP 105
47054: PUSH
47055: LD_VAR 0 7
47059: ARRAY
47060: IFFALSE 47171
// for j in mc_crates_area [ i ] do
47062: LD_ADDR_VAR 0 8
47066: PUSH
47067: LD_EXP 105
47071: PUSH
47072: LD_VAR 0 7
47076: ARRAY
47077: PUSH
47078: FOR_IN
47079: IFFALSE 47169
// if InArea ( x , y , j ) then
47081: LD_VAR 0 2
47085: PPUSH
47086: LD_VAR 0 3
47090: PPUSH
47091: LD_VAR 0 8
47095: PPUSH
47096: CALL_OW 309
47100: IFFALSE 47167
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47102: LD_ADDR_EXP 103
47106: PUSH
47107: LD_EXP 103
47111: PPUSH
47112: LD_VAR 0 7
47116: PUSH
47117: LD_EXP 103
47121: PUSH
47122: LD_VAR 0 7
47126: ARRAY
47127: PUSH
47128: LD_INT 1
47130: PLUS
47131: PUSH
47132: EMPTY
47133: LIST
47134: LIST
47135: PPUSH
47136: LD_VAR 0 4
47140: PUSH
47141: LD_VAR 0 2
47145: PUSH
47146: LD_VAR 0 3
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: LIST
47155: PPUSH
47156: CALL 55547 0 3
47160: ST_TO_ADDR
// exit ;
47161: POP
47162: POP
47163: POP
47164: POP
47165: GO 47340
// end ;
47167: GO 47078
47169: POP
47170: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47171: LD_ADDR_VAR 0 9
47175: PUSH
47176: LD_EXP 87
47180: PUSH
47181: LD_VAR 0 7
47185: ARRAY
47186: PPUSH
47187: LD_INT 2
47189: PUSH
47190: LD_INT 30
47192: PUSH
47193: LD_INT 0
47195: PUSH
47196: EMPTY
47197: LIST
47198: LIST
47199: PUSH
47200: LD_INT 30
47202: PUSH
47203: LD_INT 1
47205: PUSH
47206: EMPTY
47207: LIST
47208: LIST
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: LIST
47214: PPUSH
47215: CALL_OW 72
47219: ST_TO_ADDR
// if not depot then
47220: LD_VAR 0 9
47224: NOT
47225: IFFALSE 47229
// continue ;
47227: GO 47047
// for j in depot do
47229: LD_ADDR_VAR 0 8
47233: PUSH
47234: LD_VAR 0 9
47238: PUSH
47239: FOR_IN
47240: IFFALSE 47334
// if GetDistUnitXY ( j , x , y ) < 30 then
47242: LD_VAR 0 8
47246: PPUSH
47247: LD_VAR 0 2
47251: PPUSH
47252: LD_VAR 0 3
47256: PPUSH
47257: CALL_OW 297
47261: PUSH
47262: LD_INT 30
47264: LESS
47265: IFFALSE 47332
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47267: LD_ADDR_EXP 103
47271: PUSH
47272: LD_EXP 103
47276: PPUSH
47277: LD_VAR 0 7
47281: PUSH
47282: LD_EXP 103
47286: PUSH
47287: LD_VAR 0 7
47291: ARRAY
47292: PUSH
47293: LD_INT 1
47295: PLUS
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: PPUSH
47301: LD_VAR 0 4
47305: PUSH
47306: LD_VAR 0 2
47310: PUSH
47311: LD_VAR 0 3
47315: PUSH
47316: EMPTY
47317: LIST
47318: LIST
47319: LIST
47320: PPUSH
47321: CALL 55547 0 3
47325: ST_TO_ADDR
// exit ;
47326: POP
47327: POP
47328: POP
47329: POP
47330: GO 47340
// end ;
47332: GO 47239
47334: POP
47335: POP
// end ;
47336: GO 47047
47338: POP
47339: POP
// end ;
47340: LD_VAR 0 6
47344: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47345: LD_INT 0
47347: PPUSH
47348: PPUSH
47349: PPUSH
47350: PPUSH
// if not mc_bases or not skirmish then
47351: LD_EXP 87
47355: NOT
47356: PUSH
47357: LD_EXP 85
47361: NOT
47362: OR
47363: IFFALSE 47367
// exit ;
47365: GO 47644
// side := GetSide ( lab ) ;
47367: LD_ADDR_VAR 0 4
47371: PUSH
47372: LD_VAR 0 2
47376: PPUSH
47377: CALL_OW 255
47381: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47382: LD_VAR 0 4
47386: PUSH
47387: LD_EXP 113
47391: IN
47392: NOT
47393: PUSH
47394: LD_EXP 114
47398: NOT
47399: OR
47400: PUSH
47401: LD_EXP 87
47405: NOT
47406: OR
47407: IFFALSE 47411
// exit ;
47409: GO 47644
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47411: LD_ADDR_EXP 114
47415: PUSH
47416: LD_EXP 114
47420: PPUSH
47421: LD_VAR 0 4
47425: PPUSH
47426: LD_EXP 114
47430: PUSH
47431: LD_VAR 0 4
47435: ARRAY
47436: PUSH
47437: LD_VAR 0 1
47441: DIFF
47442: PPUSH
47443: CALL_OW 1
47447: ST_TO_ADDR
// for i = 1 to mc_bases do
47448: LD_ADDR_VAR 0 5
47452: PUSH
47453: DOUBLE
47454: LD_INT 1
47456: DEC
47457: ST_TO_ADDR
47458: LD_EXP 87
47462: PUSH
47463: FOR_TO
47464: IFFALSE 47642
// begin if lab in mc_bases [ i ] then
47466: LD_VAR 0 2
47470: PUSH
47471: LD_EXP 87
47475: PUSH
47476: LD_VAR 0 5
47480: ARRAY
47481: IN
47482: IFFALSE 47640
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47484: LD_VAR 0 1
47488: PUSH
47489: LD_INT 11
47491: PUSH
47492: LD_INT 4
47494: PUSH
47495: LD_INT 3
47497: PUSH
47498: LD_INT 2
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: IN
47507: PUSH
47508: LD_EXP 117
47512: PUSH
47513: LD_VAR 0 5
47517: ARRAY
47518: AND
47519: IFFALSE 47640
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47521: LD_ADDR_VAR 0 6
47525: PUSH
47526: LD_EXP 117
47530: PUSH
47531: LD_VAR 0 5
47535: ARRAY
47536: PUSH
47537: LD_INT 1
47539: ARRAY
47540: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47541: LD_ADDR_EXP 117
47545: PUSH
47546: LD_EXP 117
47550: PPUSH
47551: LD_VAR 0 5
47555: PPUSH
47556: EMPTY
47557: PPUSH
47558: CALL_OW 1
47562: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47563: LD_VAR 0 6
47567: PPUSH
47568: LD_INT 0
47570: PPUSH
47571: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47575: LD_VAR 0 6
47579: PPUSH
47580: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47584: LD_ADDR_EXP 116
47588: PUSH
47589: LD_EXP 116
47593: PPUSH
47594: LD_VAR 0 5
47598: PPUSH
47599: LD_EXP 116
47603: PUSH
47604: LD_VAR 0 5
47608: ARRAY
47609: PPUSH
47610: LD_INT 1
47612: PPUSH
47613: LD_VAR 0 6
47617: PPUSH
47618: CALL_OW 2
47622: PPUSH
47623: CALL_OW 1
47627: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47628: LD_VAR 0 5
47632: PPUSH
47633: LD_INT 112
47635: PPUSH
47636: CALL 24656 0 2
// end ; end ; end ;
47640: GO 47463
47642: POP
47643: POP
// end ;
47644: LD_VAR 0 3
47648: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47649: LD_INT 0
47651: PPUSH
47652: PPUSH
47653: PPUSH
47654: PPUSH
47655: PPUSH
47656: PPUSH
47657: PPUSH
47658: PPUSH
// if not mc_bases or not skirmish then
47659: LD_EXP 87
47663: NOT
47664: PUSH
47665: LD_EXP 85
47669: NOT
47670: OR
47671: IFFALSE 47675
// exit ;
47673: GO 49046
// for i = 1 to mc_bases do
47675: LD_ADDR_VAR 0 3
47679: PUSH
47680: DOUBLE
47681: LD_INT 1
47683: DEC
47684: ST_TO_ADDR
47685: LD_EXP 87
47689: PUSH
47690: FOR_TO
47691: IFFALSE 49044
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47693: LD_VAR 0 1
47697: PUSH
47698: LD_EXP 87
47702: PUSH
47703: LD_VAR 0 3
47707: ARRAY
47708: IN
47709: PUSH
47710: LD_VAR 0 1
47714: PUSH
47715: LD_EXP 94
47719: PUSH
47720: LD_VAR 0 3
47724: ARRAY
47725: IN
47726: OR
47727: PUSH
47728: LD_VAR 0 1
47732: PUSH
47733: LD_EXP 109
47737: PUSH
47738: LD_VAR 0 3
47742: ARRAY
47743: IN
47744: OR
47745: PUSH
47746: LD_VAR 0 1
47750: PUSH
47751: LD_EXP 106
47755: PUSH
47756: LD_VAR 0 3
47760: ARRAY
47761: IN
47762: OR
47763: PUSH
47764: LD_VAR 0 1
47768: PUSH
47769: LD_EXP 116
47773: PUSH
47774: LD_VAR 0 3
47778: ARRAY
47779: IN
47780: OR
47781: PUSH
47782: LD_VAR 0 1
47786: PUSH
47787: LD_EXP 117
47791: PUSH
47792: LD_VAR 0 3
47796: ARRAY
47797: IN
47798: OR
47799: IFFALSE 49042
// begin if un in mc_ape [ i ] then
47801: LD_VAR 0 1
47805: PUSH
47806: LD_EXP 116
47810: PUSH
47811: LD_VAR 0 3
47815: ARRAY
47816: IN
47817: IFFALSE 47856
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47819: LD_ADDR_EXP 116
47823: PUSH
47824: LD_EXP 116
47828: PPUSH
47829: LD_VAR 0 3
47833: PPUSH
47834: LD_EXP 116
47838: PUSH
47839: LD_VAR 0 3
47843: ARRAY
47844: PUSH
47845: LD_VAR 0 1
47849: DIFF
47850: PPUSH
47851: CALL_OW 1
47855: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47856: LD_VAR 0 1
47860: PUSH
47861: LD_EXP 117
47865: PUSH
47866: LD_VAR 0 3
47870: ARRAY
47871: IN
47872: IFFALSE 47896
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47874: LD_ADDR_EXP 117
47878: PUSH
47879: LD_EXP 117
47883: PPUSH
47884: LD_VAR 0 3
47888: PPUSH
47889: EMPTY
47890: PPUSH
47891: CALL_OW 1
47895: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47896: LD_VAR 0 1
47900: PPUSH
47901: CALL_OW 247
47905: PUSH
47906: LD_INT 2
47908: EQUAL
47909: PUSH
47910: LD_VAR 0 1
47914: PPUSH
47915: CALL_OW 110
47919: PUSH
47920: LD_INT 20
47922: EQUAL
47923: PUSH
47924: LD_VAR 0 1
47928: PUSH
47929: LD_EXP 109
47933: PUSH
47934: LD_VAR 0 3
47938: ARRAY
47939: IN
47940: OR
47941: PUSH
47942: LD_VAR 0 1
47946: PPUSH
47947: CALL_OW 264
47951: PUSH
47952: LD_INT 12
47954: PUSH
47955: LD_INT 51
47957: PUSH
47958: LD_EXP 73
47962: PUSH
47963: LD_INT 32
47965: PUSH
47966: LD_INT 13
47968: PUSH
47969: LD_INT 52
47971: PUSH
47972: LD_INT 31
47974: PUSH
47975: EMPTY
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: IN
47984: OR
47985: AND
47986: IFFALSE 48294
// begin if un in mc_defender [ i ] then
47988: LD_VAR 0 1
47992: PUSH
47993: LD_EXP 109
47997: PUSH
47998: LD_VAR 0 3
48002: ARRAY
48003: IN
48004: IFFALSE 48043
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48006: LD_ADDR_EXP 109
48010: PUSH
48011: LD_EXP 109
48015: PPUSH
48016: LD_VAR 0 3
48020: PPUSH
48021: LD_EXP 109
48025: PUSH
48026: LD_VAR 0 3
48030: ARRAY
48031: PUSH
48032: LD_VAR 0 1
48036: DIFF
48037: PPUSH
48038: CALL_OW 1
48042: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48043: LD_ADDR_VAR 0 8
48047: PUSH
48048: LD_VAR 0 3
48052: PPUSH
48053: LD_INT 3
48055: PPUSH
48056: CALL 44712 0 2
48060: ST_TO_ADDR
// if fac then
48061: LD_VAR 0 8
48065: IFFALSE 48294
// begin for j in fac do
48067: LD_ADDR_VAR 0 4
48071: PUSH
48072: LD_VAR 0 8
48076: PUSH
48077: FOR_IN
48078: IFFALSE 48292
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48080: LD_ADDR_VAR 0 9
48084: PUSH
48085: LD_VAR 0 8
48089: PPUSH
48090: LD_VAR 0 1
48094: PPUSH
48095: CALL_OW 265
48099: PPUSH
48100: LD_VAR 0 1
48104: PPUSH
48105: CALL_OW 262
48109: PPUSH
48110: LD_VAR 0 1
48114: PPUSH
48115: CALL_OW 263
48119: PPUSH
48120: LD_VAR 0 1
48124: PPUSH
48125: CALL_OW 264
48129: PPUSH
48130: CALL 53079 0 5
48134: ST_TO_ADDR
// if components then
48135: LD_VAR 0 9
48139: IFFALSE 48290
// begin if GetWeapon ( un ) = ar_control_tower then
48141: LD_VAR 0 1
48145: PPUSH
48146: CALL_OW 264
48150: PUSH
48151: LD_INT 31
48153: EQUAL
48154: IFFALSE 48271
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48156: LD_VAR 0 1
48160: PPUSH
48161: CALL_OW 311
48165: PPUSH
48166: LD_INT 0
48168: PPUSH
48169: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48173: LD_ADDR_EXP 127
48177: PUSH
48178: LD_EXP 127
48182: PPUSH
48183: LD_VAR 0 3
48187: PPUSH
48188: LD_EXP 127
48192: PUSH
48193: LD_VAR 0 3
48197: ARRAY
48198: PUSH
48199: LD_VAR 0 1
48203: PPUSH
48204: CALL_OW 311
48208: DIFF
48209: PPUSH
48210: CALL_OW 1
48214: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48215: LD_ADDR_VAR 0 7
48219: PUSH
48220: LD_EXP 108
48224: PUSH
48225: LD_VAR 0 3
48229: ARRAY
48230: PPUSH
48231: LD_INT 1
48233: PPUSH
48234: LD_VAR 0 9
48238: PPUSH
48239: CALL_OW 2
48243: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48244: LD_ADDR_EXP 108
48248: PUSH
48249: LD_EXP 108
48253: PPUSH
48254: LD_VAR 0 3
48258: PPUSH
48259: LD_VAR 0 7
48263: PPUSH
48264: CALL_OW 1
48268: ST_TO_ADDR
// end else
48269: GO 48288
// MC_InsertProduceList ( i , [ components ] ) ;
48271: LD_VAR 0 3
48275: PPUSH
48276: LD_VAR 0 9
48280: PUSH
48281: EMPTY
48282: LIST
48283: PPUSH
48284: CALL 44257 0 2
// break ;
48288: GO 48292
// end ; end ;
48290: GO 48077
48292: POP
48293: POP
// end ; end ; if GetType ( un ) = unit_building then
48294: LD_VAR 0 1
48298: PPUSH
48299: CALL_OW 247
48303: PUSH
48304: LD_INT 3
48306: EQUAL
48307: IFFALSE 48710
// begin btype := GetBType ( un ) ;
48309: LD_ADDR_VAR 0 5
48313: PUSH
48314: LD_VAR 0 1
48318: PPUSH
48319: CALL_OW 266
48323: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48324: LD_VAR 0 5
48328: PUSH
48329: LD_INT 29
48331: PUSH
48332: LD_INT 30
48334: PUSH
48335: EMPTY
48336: LIST
48337: LIST
48338: IN
48339: IFFALSE 48412
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48341: LD_VAR 0 1
48345: PPUSH
48346: CALL_OW 250
48350: PPUSH
48351: LD_VAR 0 1
48355: PPUSH
48356: CALL_OW 251
48360: PPUSH
48361: LD_VAR 0 1
48365: PPUSH
48366: CALL_OW 255
48370: PPUSH
48371: CALL_OW 440
48375: NOT
48376: IFFALSE 48412
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48378: LD_VAR 0 1
48382: PPUSH
48383: CALL_OW 250
48387: PPUSH
48388: LD_VAR 0 1
48392: PPUSH
48393: CALL_OW 251
48397: PPUSH
48398: LD_VAR 0 1
48402: PPUSH
48403: CALL_OW 255
48407: PPUSH
48408: CALL_OW 441
// end ; if btype = b_warehouse then
48412: LD_VAR 0 5
48416: PUSH
48417: LD_INT 1
48419: EQUAL
48420: IFFALSE 48438
// begin btype := b_depot ;
48422: LD_ADDR_VAR 0 5
48426: PUSH
48427: LD_INT 0
48429: ST_TO_ADDR
// pos := 1 ;
48430: LD_ADDR_VAR 0 6
48434: PUSH
48435: LD_INT 1
48437: ST_TO_ADDR
// end ; if btype = b_factory then
48438: LD_VAR 0 5
48442: PUSH
48443: LD_INT 3
48445: EQUAL
48446: IFFALSE 48464
// begin btype := b_workshop ;
48448: LD_ADDR_VAR 0 5
48452: PUSH
48453: LD_INT 2
48455: ST_TO_ADDR
// pos := 1 ;
48456: LD_ADDR_VAR 0 6
48460: PUSH
48461: LD_INT 1
48463: ST_TO_ADDR
// end ; if btype = b_barracks then
48464: LD_VAR 0 5
48468: PUSH
48469: LD_INT 5
48471: EQUAL
48472: IFFALSE 48482
// btype := b_armoury ;
48474: LD_ADDR_VAR 0 5
48478: PUSH
48479: LD_INT 4
48481: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48482: LD_VAR 0 5
48486: PUSH
48487: LD_INT 7
48489: PUSH
48490: LD_INT 8
48492: PUSH
48493: EMPTY
48494: LIST
48495: LIST
48496: IN
48497: IFFALSE 48507
// btype := b_lab ;
48499: LD_ADDR_VAR 0 5
48503: PUSH
48504: LD_INT 6
48506: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48507: LD_ADDR_EXP 92
48511: PUSH
48512: LD_EXP 92
48516: PPUSH
48517: LD_VAR 0 3
48521: PUSH
48522: LD_EXP 92
48526: PUSH
48527: LD_VAR 0 3
48531: ARRAY
48532: PUSH
48533: LD_INT 1
48535: PLUS
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PPUSH
48541: LD_VAR 0 5
48545: PUSH
48546: LD_VAR 0 1
48550: PPUSH
48551: CALL_OW 250
48555: PUSH
48556: LD_VAR 0 1
48560: PPUSH
48561: CALL_OW 251
48565: PUSH
48566: LD_VAR 0 1
48570: PPUSH
48571: CALL_OW 254
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: LIST
48580: LIST
48581: PPUSH
48582: CALL 55547 0 3
48586: ST_TO_ADDR
// if pos = 1 then
48587: LD_VAR 0 6
48591: PUSH
48592: LD_INT 1
48594: EQUAL
48595: IFFALSE 48710
// begin tmp := mc_build_list [ i ] ;
48597: LD_ADDR_VAR 0 7
48601: PUSH
48602: LD_EXP 92
48606: PUSH
48607: LD_VAR 0 3
48611: ARRAY
48612: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48613: LD_VAR 0 7
48617: PPUSH
48618: LD_INT 2
48620: PUSH
48621: LD_INT 30
48623: PUSH
48624: LD_INT 0
48626: PUSH
48627: EMPTY
48628: LIST
48629: LIST
48630: PUSH
48631: LD_INT 30
48633: PUSH
48634: LD_INT 1
48636: PUSH
48637: EMPTY
48638: LIST
48639: LIST
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: LIST
48645: PPUSH
48646: CALL_OW 72
48650: IFFALSE 48660
// pos := 2 ;
48652: LD_ADDR_VAR 0 6
48656: PUSH
48657: LD_INT 2
48659: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48660: LD_ADDR_VAR 0 7
48664: PUSH
48665: LD_VAR 0 7
48669: PPUSH
48670: LD_VAR 0 6
48674: PPUSH
48675: LD_VAR 0 7
48679: PPUSH
48680: CALL 55873 0 3
48684: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48685: LD_ADDR_EXP 92
48689: PUSH
48690: LD_EXP 92
48694: PPUSH
48695: LD_VAR 0 3
48699: PPUSH
48700: LD_VAR 0 7
48704: PPUSH
48705: CALL_OW 1
48709: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48710: LD_VAR 0 1
48714: PUSH
48715: LD_EXP 87
48719: PUSH
48720: LD_VAR 0 3
48724: ARRAY
48725: IN
48726: IFFALSE 48765
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48728: LD_ADDR_EXP 87
48732: PUSH
48733: LD_EXP 87
48737: PPUSH
48738: LD_VAR 0 3
48742: PPUSH
48743: LD_EXP 87
48747: PUSH
48748: LD_VAR 0 3
48752: ARRAY
48753: PUSH
48754: LD_VAR 0 1
48758: DIFF
48759: PPUSH
48760: CALL_OW 1
48764: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48765: LD_VAR 0 1
48769: PUSH
48770: LD_EXP 94
48774: PUSH
48775: LD_VAR 0 3
48779: ARRAY
48780: IN
48781: IFFALSE 48820
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48783: LD_ADDR_EXP 94
48787: PUSH
48788: LD_EXP 94
48792: PPUSH
48793: LD_VAR 0 3
48797: PPUSH
48798: LD_EXP 94
48802: PUSH
48803: LD_VAR 0 3
48807: ARRAY
48808: PUSH
48809: LD_VAR 0 1
48813: DIFF
48814: PPUSH
48815: CALL_OW 1
48819: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48820: LD_VAR 0 1
48824: PUSH
48825: LD_EXP 106
48829: PUSH
48830: LD_VAR 0 3
48834: ARRAY
48835: IN
48836: IFFALSE 48875
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48838: LD_ADDR_EXP 106
48842: PUSH
48843: LD_EXP 106
48847: PPUSH
48848: LD_VAR 0 3
48852: PPUSH
48853: LD_EXP 106
48857: PUSH
48858: LD_VAR 0 3
48862: ARRAY
48863: PUSH
48864: LD_VAR 0 1
48868: DIFF
48869: PPUSH
48870: CALL_OW 1
48874: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48875: LD_VAR 0 1
48879: PUSH
48880: LD_EXP 109
48884: PUSH
48885: LD_VAR 0 3
48889: ARRAY
48890: IN
48891: IFFALSE 48930
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48893: LD_ADDR_EXP 109
48897: PUSH
48898: LD_EXP 109
48902: PPUSH
48903: LD_VAR 0 3
48907: PPUSH
48908: LD_EXP 109
48912: PUSH
48913: LD_VAR 0 3
48917: ARRAY
48918: PUSH
48919: LD_VAR 0 1
48923: DIFF
48924: PPUSH
48925: CALL_OW 1
48929: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48930: LD_VAR 0 1
48934: PUSH
48935: LD_EXP 96
48939: PUSH
48940: LD_VAR 0 3
48944: ARRAY
48945: IN
48946: IFFALSE 48985
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48948: LD_ADDR_EXP 96
48952: PUSH
48953: LD_EXP 96
48957: PPUSH
48958: LD_VAR 0 3
48962: PPUSH
48963: LD_EXP 96
48967: PUSH
48968: LD_VAR 0 3
48972: ARRAY
48973: PUSH
48974: LD_VAR 0 1
48978: DIFF
48979: PPUSH
48980: CALL_OW 1
48984: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48985: LD_VAR 0 1
48989: PUSH
48990: LD_EXP 95
48994: PUSH
48995: LD_VAR 0 3
48999: ARRAY
49000: IN
49001: IFFALSE 49040
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49003: LD_ADDR_EXP 95
49007: PUSH
49008: LD_EXP 95
49012: PPUSH
49013: LD_VAR 0 3
49017: PPUSH
49018: LD_EXP 95
49022: PUSH
49023: LD_VAR 0 3
49027: ARRAY
49028: PUSH
49029: LD_VAR 0 1
49033: DIFF
49034: PPUSH
49035: CALL_OW 1
49039: ST_TO_ADDR
// end ; break ;
49040: GO 49044
// end ;
49042: GO 47690
49044: POP
49045: POP
// end ;
49046: LD_VAR 0 2
49050: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49051: LD_INT 0
49053: PPUSH
49054: PPUSH
49055: PPUSH
// if not mc_bases or not skirmish then
49056: LD_EXP 87
49060: NOT
49061: PUSH
49062: LD_EXP 85
49066: NOT
49067: OR
49068: IFFALSE 49072
// exit ;
49070: GO 49287
// for i = 1 to mc_bases do
49072: LD_ADDR_VAR 0 3
49076: PUSH
49077: DOUBLE
49078: LD_INT 1
49080: DEC
49081: ST_TO_ADDR
49082: LD_EXP 87
49086: PUSH
49087: FOR_TO
49088: IFFALSE 49285
// begin if building in mc_construct_list [ i ] then
49090: LD_VAR 0 1
49094: PUSH
49095: LD_EXP 94
49099: PUSH
49100: LD_VAR 0 3
49104: ARRAY
49105: IN
49106: IFFALSE 49283
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49108: LD_ADDR_EXP 94
49112: PUSH
49113: LD_EXP 94
49117: PPUSH
49118: LD_VAR 0 3
49122: PPUSH
49123: LD_EXP 94
49127: PUSH
49128: LD_VAR 0 3
49132: ARRAY
49133: PUSH
49134: LD_VAR 0 1
49138: DIFF
49139: PPUSH
49140: CALL_OW 1
49144: ST_TO_ADDR
// if building in mc_lab [ i ] then
49145: LD_VAR 0 1
49149: PUSH
49150: LD_EXP 120
49154: PUSH
49155: LD_VAR 0 3
49159: ARRAY
49160: IN
49161: IFFALSE 49216
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49163: LD_ADDR_EXP 121
49167: PUSH
49168: LD_EXP 121
49172: PPUSH
49173: LD_VAR 0 3
49177: PPUSH
49178: LD_EXP 121
49182: PUSH
49183: LD_VAR 0 3
49187: ARRAY
49188: PPUSH
49189: LD_INT 1
49191: PPUSH
49192: LD_EXP 121
49196: PUSH
49197: LD_VAR 0 3
49201: ARRAY
49202: PPUSH
49203: LD_INT 0
49205: PPUSH
49206: CALL 54965 0 4
49210: PPUSH
49211: CALL_OW 1
49215: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49216: LD_VAR 0 1
49220: PUSH
49221: LD_EXP 87
49225: PUSH
49226: LD_VAR 0 3
49230: ARRAY
49231: IN
49232: NOT
49233: IFFALSE 49279
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49235: LD_ADDR_EXP 87
49239: PUSH
49240: LD_EXP 87
49244: PPUSH
49245: LD_VAR 0 3
49249: PUSH
49250: LD_EXP 87
49254: PUSH
49255: LD_VAR 0 3
49259: ARRAY
49260: PUSH
49261: LD_INT 1
49263: PLUS
49264: PUSH
49265: EMPTY
49266: LIST
49267: LIST
49268: PPUSH
49269: LD_VAR 0 1
49273: PPUSH
49274: CALL 55547 0 3
49278: ST_TO_ADDR
// exit ;
49279: POP
49280: POP
49281: GO 49287
// end ; end ;
49283: GO 49087
49285: POP
49286: POP
// end ;
49287: LD_VAR 0 2
49291: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49292: LD_INT 0
49294: PPUSH
49295: PPUSH
49296: PPUSH
49297: PPUSH
49298: PPUSH
49299: PPUSH
49300: PPUSH
// if not mc_bases or not skirmish then
49301: LD_EXP 87
49305: NOT
49306: PUSH
49307: LD_EXP 85
49311: NOT
49312: OR
49313: IFFALSE 49317
// exit ;
49315: GO 49978
// for i = 1 to mc_bases do
49317: LD_ADDR_VAR 0 3
49321: PUSH
49322: DOUBLE
49323: LD_INT 1
49325: DEC
49326: ST_TO_ADDR
49327: LD_EXP 87
49331: PUSH
49332: FOR_TO
49333: IFFALSE 49976
// begin if building in mc_construct_list [ i ] then
49335: LD_VAR 0 1
49339: PUSH
49340: LD_EXP 94
49344: PUSH
49345: LD_VAR 0 3
49349: ARRAY
49350: IN
49351: IFFALSE 49974
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49353: LD_ADDR_EXP 94
49357: PUSH
49358: LD_EXP 94
49362: PPUSH
49363: LD_VAR 0 3
49367: PPUSH
49368: LD_EXP 94
49372: PUSH
49373: LD_VAR 0 3
49377: ARRAY
49378: PUSH
49379: LD_VAR 0 1
49383: DIFF
49384: PPUSH
49385: CALL_OW 1
49389: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49390: LD_ADDR_EXP 87
49394: PUSH
49395: LD_EXP 87
49399: PPUSH
49400: LD_VAR 0 3
49404: PUSH
49405: LD_EXP 87
49409: PUSH
49410: LD_VAR 0 3
49414: ARRAY
49415: PUSH
49416: LD_INT 1
49418: PLUS
49419: PUSH
49420: EMPTY
49421: LIST
49422: LIST
49423: PPUSH
49424: LD_VAR 0 1
49428: PPUSH
49429: CALL 55547 0 3
49433: ST_TO_ADDR
// btype := GetBType ( building ) ;
49434: LD_ADDR_VAR 0 5
49438: PUSH
49439: LD_VAR 0 1
49443: PPUSH
49444: CALL_OW 266
49448: ST_TO_ADDR
// side := GetSide ( building ) ;
49449: LD_ADDR_VAR 0 8
49453: PUSH
49454: LD_VAR 0 1
49458: PPUSH
49459: CALL_OW 255
49463: ST_TO_ADDR
// if btype = b_lab then
49464: LD_VAR 0 5
49468: PUSH
49469: LD_INT 6
49471: EQUAL
49472: IFFALSE 49522
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49474: LD_ADDR_EXP 120
49478: PUSH
49479: LD_EXP 120
49483: PPUSH
49484: LD_VAR 0 3
49488: PUSH
49489: LD_EXP 120
49493: PUSH
49494: LD_VAR 0 3
49498: ARRAY
49499: PUSH
49500: LD_INT 1
49502: PLUS
49503: PUSH
49504: EMPTY
49505: LIST
49506: LIST
49507: PPUSH
49508: LD_VAR 0 1
49512: PPUSH
49513: CALL 55547 0 3
49517: ST_TO_ADDR
// exit ;
49518: POP
49519: POP
49520: GO 49978
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49522: LD_VAR 0 5
49526: PUSH
49527: LD_INT 0
49529: PUSH
49530: LD_INT 2
49532: PUSH
49533: LD_INT 4
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: LIST
49540: IN
49541: IFFALSE 49665
// begin if btype = b_armoury then
49543: LD_VAR 0 5
49547: PUSH
49548: LD_INT 4
49550: EQUAL
49551: IFFALSE 49561
// btype := b_barracks ;
49553: LD_ADDR_VAR 0 5
49557: PUSH
49558: LD_INT 5
49560: ST_TO_ADDR
// if btype = b_depot then
49561: LD_VAR 0 5
49565: PUSH
49566: LD_INT 0
49568: EQUAL
49569: IFFALSE 49579
// btype := b_warehouse ;
49571: LD_ADDR_VAR 0 5
49575: PUSH
49576: LD_INT 1
49578: ST_TO_ADDR
// if btype = b_workshop then
49579: LD_VAR 0 5
49583: PUSH
49584: LD_INT 2
49586: EQUAL
49587: IFFALSE 49597
// btype := b_factory ;
49589: LD_ADDR_VAR 0 5
49593: PUSH
49594: LD_INT 3
49596: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49597: LD_VAR 0 5
49601: PPUSH
49602: LD_VAR 0 8
49606: PPUSH
49607: CALL_OW 323
49611: PUSH
49612: LD_INT 1
49614: EQUAL
49615: IFFALSE 49661
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49617: LD_ADDR_EXP 119
49621: PUSH
49622: LD_EXP 119
49626: PPUSH
49627: LD_VAR 0 3
49631: PUSH
49632: LD_EXP 119
49636: PUSH
49637: LD_VAR 0 3
49641: ARRAY
49642: PUSH
49643: LD_INT 1
49645: PLUS
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: PPUSH
49651: LD_VAR 0 1
49655: PPUSH
49656: CALL 55547 0 3
49660: ST_TO_ADDR
// exit ;
49661: POP
49662: POP
49663: GO 49978
// end ; if btype in [ b_bunker , b_turret ] then
49665: LD_VAR 0 5
49669: PUSH
49670: LD_INT 32
49672: PUSH
49673: LD_INT 33
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: IN
49680: IFFALSE 49970
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49682: LD_ADDR_EXP 95
49686: PUSH
49687: LD_EXP 95
49691: PPUSH
49692: LD_VAR 0 3
49696: PUSH
49697: LD_EXP 95
49701: PUSH
49702: LD_VAR 0 3
49706: ARRAY
49707: PUSH
49708: LD_INT 1
49710: PLUS
49711: PUSH
49712: EMPTY
49713: LIST
49714: LIST
49715: PPUSH
49716: LD_VAR 0 1
49720: PPUSH
49721: CALL 55547 0 3
49725: ST_TO_ADDR
// if btype = b_bunker then
49726: LD_VAR 0 5
49730: PUSH
49731: LD_INT 32
49733: EQUAL
49734: IFFALSE 49970
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49736: LD_ADDR_EXP 96
49740: PUSH
49741: LD_EXP 96
49745: PPUSH
49746: LD_VAR 0 3
49750: PUSH
49751: LD_EXP 96
49755: PUSH
49756: LD_VAR 0 3
49760: ARRAY
49761: PUSH
49762: LD_INT 1
49764: PLUS
49765: PUSH
49766: EMPTY
49767: LIST
49768: LIST
49769: PPUSH
49770: LD_VAR 0 1
49774: PPUSH
49775: CALL 55547 0 3
49779: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49780: LD_ADDR_VAR 0 6
49784: PUSH
49785: LD_EXP 87
49789: PUSH
49790: LD_VAR 0 3
49794: ARRAY
49795: PPUSH
49796: LD_INT 25
49798: PUSH
49799: LD_INT 1
49801: PUSH
49802: EMPTY
49803: LIST
49804: LIST
49805: PUSH
49806: LD_INT 3
49808: PUSH
49809: LD_INT 54
49811: PUSH
49812: EMPTY
49813: LIST
49814: PUSH
49815: EMPTY
49816: LIST
49817: LIST
49818: PUSH
49819: EMPTY
49820: LIST
49821: LIST
49822: PPUSH
49823: CALL_OW 72
49827: ST_TO_ADDR
// if tmp then
49828: LD_VAR 0 6
49832: IFFALSE 49838
// exit ;
49834: POP
49835: POP
49836: GO 49978
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49838: LD_ADDR_VAR 0 6
49842: PUSH
49843: LD_EXP 87
49847: PUSH
49848: LD_VAR 0 3
49852: ARRAY
49853: PPUSH
49854: LD_INT 2
49856: PUSH
49857: LD_INT 30
49859: PUSH
49860: LD_INT 4
49862: PUSH
49863: EMPTY
49864: LIST
49865: LIST
49866: PUSH
49867: LD_INT 30
49869: PUSH
49870: LD_INT 5
49872: PUSH
49873: EMPTY
49874: LIST
49875: LIST
49876: PUSH
49877: EMPTY
49878: LIST
49879: LIST
49880: LIST
49881: PPUSH
49882: CALL_OW 72
49886: ST_TO_ADDR
// if not tmp then
49887: LD_VAR 0 6
49891: NOT
49892: IFFALSE 49898
// exit ;
49894: POP
49895: POP
49896: GO 49978
// for j in tmp do
49898: LD_ADDR_VAR 0 4
49902: PUSH
49903: LD_VAR 0 6
49907: PUSH
49908: FOR_IN
49909: IFFALSE 49968
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49911: LD_ADDR_VAR 0 7
49915: PUSH
49916: LD_VAR 0 4
49920: PPUSH
49921: CALL_OW 313
49925: PPUSH
49926: LD_INT 25
49928: PUSH
49929: LD_INT 1
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: PPUSH
49936: CALL_OW 72
49940: ST_TO_ADDR
// if units then
49941: LD_VAR 0 7
49945: IFFALSE 49966
// begin ComExitBuilding ( units [ 1 ] ) ;
49947: LD_VAR 0 7
49951: PUSH
49952: LD_INT 1
49954: ARRAY
49955: PPUSH
49956: CALL_OW 122
// exit ;
49960: POP
49961: POP
49962: POP
49963: POP
49964: GO 49978
// end ; end ;
49966: GO 49908
49968: POP
49969: POP
// end ; end ; exit ;
49970: POP
49971: POP
49972: GO 49978
// end ; end ;
49974: GO 49332
49976: POP
49977: POP
// end ;
49978: LD_VAR 0 2
49982: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49983: LD_INT 0
49985: PPUSH
49986: PPUSH
49987: PPUSH
49988: PPUSH
49989: PPUSH
49990: PPUSH
49991: PPUSH
// if not mc_bases or not skirmish then
49992: LD_EXP 87
49996: NOT
49997: PUSH
49998: LD_EXP 85
50002: NOT
50003: OR
50004: IFFALSE 50008
// exit ;
50006: GO 50239
// btype := GetBType ( building ) ;
50008: LD_ADDR_VAR 0 6
50012: PUSH
50013: LD_VAR 0 1
50017: PPUSH
50018: CALL_OW 266
50022: ST_TO_ADDR
// x := GetX ( building ) ;
50023: LD_ADDR_VAR 0 7
50027: PUSH
50028: LD_VAR 0 1
50032: PPUSH
50033: CALL_OW 250
50037: ST_TO_ADDR
// y := GetY ( building ) ;
50038: LD_ADDR_VAR 0 8
50042: PUSH
50043: LD_VAR 0 1
50047: PPUSH
50048: CALL_OW 251
50052: ST_TO_ADDR
// d := GetDir ( building ) ;
50053: LD_ADDR_VAR 0 9
50057: PUSH
50058: LD_VAR 0 1
50062: PPUSH
50063: CALL_OW 254
50067: ST_TO_ADDR
// for i = 1 to mc_bases do
50068: LD_ADDR_VAR 0 4
50072: PUSH
50073: DOUBLE
50074: LD_INT 1
50076: DEC
50077: ST_TO_ADDR
50078: LD_EXP 87
50082: PUSH
50083: FOR_TO
50084: IFFALSE 50237
// begin if not mc_build_list [ i ] then
50086: LD_EXP 92
50090: PUSH
50091: LD_VAR 0 4
50095: ARRAY
50096: NOT
50097: IFFALSE 50101
// continue ;
50099: GO 50083
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50101: LD_VAR 0 6
50105: PUSH
50106: LD_VAR 0 7
50110: PUSH
50111: LD_VAR 0 8
50115: PUSH
50116: LD_VAR 0 9
50120: PUSH
50121: EMPTY
50122: LIST
50123: LIST
50124: LIST
50125: LIST
50126: PPUSH
50127: LD_EXP 92
50131: PUSH
50132: LD_VAR 0 4
50136: ARRAY
50137: PUSH
50138: LD_INT 1
50140: ARRAY
50141: PPUSH
50142: CALL 61716 0 2
50146: IFFALSE 50235
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50148: LD_ADDR_EXP 92
50152: PUSH
50153: LD_EXP 92
50157: PPUSH
50158: LD_VAR 0 4
50162: PPUSH
50163: LD_EXP 92
50167: PUSH
50168: LD_VAR 0 4
50172: ARRAY
50173: PPUSH
50174: LD_INT 1
50176: PPUSH
50177: CALL_OW 3
50181: PPUSH
50182: CALL_OW 1
50186: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50187: LD_ADDR_EXP 94
50191: PUSH
50192: LD_EXP 94
50196: PPUSH
50197: LD_VAR 0 4
50201: PUSH
50202: LD_EXP 94
50206: PUSH
50207: LD_VAR 0 4
50211: ARRAY
50212: PUSH
50213: LD_INT 1
50215: PLUS
50216: PUSH
50217: EMPTY
50218: LIST
50219: LIST
50220: PPUSH
50221: LD_VAR 0 1
50225: PPUSH
50226: CALL 55547 0 3
50230: ST_TO_ADDR
// exit ;
50231: POP
50232: POP
50233: GO 50239
// end ; end ;
50235: GO 50083
50237: POP
50238: POP
// end ;
50239: LD_VAR 0 3
50243: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50244: LD_INT 0
50246: PPUSH
50247: PPUSH
50248: PPUSH
// if not mc_bases or not skirmish then
50249: LD_EXP 87
50253: NOT
50254: PUSH
50255: LD_EXP 85
50259: NOT
50260: OR
50261: IFFALSE 50265
// exit ;
50263: GO 50455
// for i = 1 to mc_bases do
50265: LD_ADDR_VAR 0 4
50269: PUSH
50270: DOUBLE
50271: LD_INT 1
50273: DEC
50274: ST_TO_ADDR
50275: LD_EXP 87
50279: PUSH
50280: FOR_TO
50281: IFFALSE 50368
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50283: LD_VAR 0 1
50287: PUSH
50288: LD_EXP 95
50292: PUSH
50293: LD_VAR 0 4
50297: ARRAY
50298: IN
50299: PUSH
50300: LD_VAR 0 1
50304: PUSH
50305: LD_EXP 96
50309: PUSH
50310: LD_VAR 0 4
50314: ARRAY
50315: IN
50316: NOT
50317: AND
50318: IFFALSE 50366
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50320: LD_ADDR_EXP 96
50324: PUSH
50325: LD_EXP 96
50329: PPUSH
50330: LD_VAR 0 4
50334: PUSH
50335: LD_EXP 96
50339: PUSH
50340: LD_VAR 0 4
50344: ARRAY
50345: PUSH
50346: LD_INT 1
50348: PLUS
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: PPUSH
50354: LD_VAR 0 1
50358: PPUSH
50359: CALL 55547 0 3
50363: ST_TO_ADDR
// break ;
50364: GO 50368
// end ; end ;
50366: GO 50280
50368: POP
50369: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50370: LD_VAR 0 1
50374: PPUSH
50375: CALL_OW 257
50379: PUSH
50380: LD_EXP 113
50384: IN
50385: PUSH
50386: LD_VAR 0 1
50390: PPUSH
50391: CALL_OW 266
50395: PUSH
50396: LD_INT 5
50398: EQUAL
50399: AND
50400: PUSH
50401: LD_VAR 0 2
50405: PPUSH
50406: CALL_OW 110
50410: PUSH
50411: LD_INT 18
50413: NONEQUAL
50414: AND
50415: IFFALSE 50455
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50417: LD_VAR 0 2
50421: PPUSH
50422: CALL_OW 257
50426: PUSH
50427: LD_INT 5
50429: PUSH
50430: LD_INT 8
50432: PUSH
50433: LD_INT 9
50435: PUSH
50436: EMPTY
50437: LIST
50438: LIST
50439: LIST
50440: IN
50441: IFFALSE 50455
// SetClass ( unit , 1 ) ;
50443: LD_VAR 0 2
50447: PPUSH
50448: LD_INT 1
50450: PPUSH
50451: CALL_OW 336
// end ;
50455: LD_VAR 0 3
50459: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50460: LD_INT 0
50462: PPUSH
50463: PPUSH
// if not mc_bases or not skirmish then
50464: LD_EXP 87
50468: NOT
50469: PUSH
50470: LD_EXP 85
50474: NOT
50475: OR
50476: IFFALSE 50480
// exit ;
50478: GO 50596
// if GetLives ( abandoned_vehicle ) > 250 then
50480: LD_VAR 0 2
50484: PPUSH
50485: CALL_OW 256
50489: PUSH
50490: LD_INT 250
50492: GREATER
50493: IFFALSE 50497
// exit ;
50495: GO 50596
// for i = 1 to mc_bases do
50497: LD_ADDR_VAR 0 6
50501: PUSH
50502: DOUBLE
50503: LD_INT 1
50505: DEC
50506: ST_TO_ADDR
50507: LD_EXP 87
50511: PUSH
50512: FOR_TO
50513: IFFALSE 50594
// begin if driver in mc_bases [ i ] then
50515: LD_VAR 0 1
50519: PUSH
50520: LD_EXP 87
50524: PUSH
50525: LD_VAR 0 6
50529: ARRAY
50530: IN
50531: IFFALSE 50592
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50533: LD_VAR 0 1
50537: PPUSH
50538: LD_EXP 87
50542: PUSH
50543: LD_VAR 0 6
50547: ARRAY
50548: PPUSH
50549: LD_INT 2
50551: PUSH
50552: LD_INT 30
50554: PUSH
50555: LD_INT 0
50557: PUSH
50558: EMPTY
50559: LIST
50560: LIST
50561: PUSH
50562: LD_INT 30
50564: PUSH
50565: LD_INT 1
50567: PUSH
50568: EMPTY
50569: LIST
50570: LIST
50571: PUSH
50572: EMPTY
50573: LIST
50574: LIST
50575: LIST
50576: PPUSH
50577: CALL_OW 72
50581: PUSH
50582: LD_INT 1
50584: ARRAY
50585: PPUSH
50586: CALL_OW 112
// break ;
50590: GO 50594
// end ; end ;
50592: GO 50512
50594: POP
50595: POP
// end ; end_of_file
50596: LD_VAR 0 5
50600: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50601: LD_INT 0
50603: PPUSH
50604: PPUSH
// if exist_mode then
50605: LD_VAR 0 2
50609: IFFALSE 50634
// unit := CreateCharacter ( prefix & ident ) else
50611: LD_ADDR_VAR 0 5
50615: PUSH
50616: LD_VAR 0 3
50620: PUSH
50621: LD_VAR 0 1
50625: STR
50626: PPUSH
50627: CALL_OW 34
50631: ST_TO_ADDR
50632: GO 50649
// unit := NewCharacter ( ident ) ;
50634: LD_ADDR_VAR 0 5
50638: PUSH
50639: LD_VAR 0 1
50643: PPUSH
50644: CALL_OW 25
50648: ST_TO_ADDR
// result := unit ;
50649: LD_ADDR_VAR 0 4
50653: PUSH
50654: LD_VAR 0 5
50658: ST_TO_ADDR
// end ;
50659: LD_VAR 0 4
50663: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50664: LD_INT 0
50666: PPUSH
50667: PPUSH
// if not side or not nation then
50668: LD_VAR 0 1
50672: NOT
50673: PUSH
50674: LD_VAR 0 2
50678: NOT
50679: OR
50680: IFFALSE 50684
// exit ;
50682: GO 51448
// case nation of nation_american :
50684: LD_VAR 0 2
50688: PUSH
50689: LD_INT 1
50691: DOUBLE
50692: EQUAL
50693: IFTRUE 50697
50695: GO 50911
50697: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
50698: LD_ADDR_VAR 0 4
50702: PUSH
50703: LD_INT 35
50705: PUSH
50706: LD_INT 45
50708: PUSH
50709: LD_INT 46
50711: PUSH
50712: LD_INT 47
50714: PUSH
50715: LD_INT 82
50717: PUSH
50718: LD_INT 83
50720: PUSH
50721: LD_INT 84
50723: PUSH
50724: LD_INT 85
50726: PUSH
50727: LD_INT 86
50729: PUSH
50730: LD_INT 1
50732: PUSH
50733: LD_INT 2
50735: PUSH
50736: LD_INT 6
50738: PUSH
50739: LD_INT 15
50741: PUSH
50742: LD_INT 16
50744: PUSH
50745: LD_INT 7
50747: PUSH
50748: LD_INT 12
50750: PUSH
50751: LD_INT 13
50753: PUSH
50754: LD_INT 10
50756: PUSH
50757: LD_INT 14
50759: PUSH
50760: LD_INT 20
50762: PUSH
50763: LD_INT 21
50765: PUSH
50766: LD_INT 22
50768: PUSH
50769: LD_INT 25
50771: PUSH
50772: LD_INT 32
50774: PUSH
50775: LD_INT 27
50777: PUSH
50778: LD_INT 36
50780: PUSH
50781: LD_INT 69
50783: PUSH
50784: LD_INT 39
50786: PUSH
50787: LD_INT 34
50789: PUSH
50790: LD_INT 40
50792: PUSH
50793: LD_INT 48
50795: PUSH
50796: LD_INT 49
50798: PUSH
50799: LD_INT 50
50801: PUSH
50802: LD_INT 51
50804: PUSH
50805: LD_INT 52
50807: PUSH
50808: LD_INT 53
50810: PUSH
50811: LD_INT 54
50813: PUSH
50814: LD_INT 55
50816: PUSH
50817: LD_INT 56
50819: PUSH
50820: LD_INT 57
50822: PUSH
50823: LD_INT 58
50825: PUSH
50826: LD_INT 59
50828: PUSH
50829: LD_INT 60
50831: PUSH
50832: LD_INT 61
50834: PUSH
50835: LD_INT 62
50837: PUSH
50838: LD_INT 80
50840: PUSH
50841: LD_INT 82
50843: PUSH
50844: LD_INT 83
50846: PUSH
50847: LD_INT 84
50849: PUSH
50850: LD_INT 85
50852: PUSH
50853: LD_INT 86
50855: PUSH
50856: EMPTY
50857: LIST
50858: LIST
50859: LIST
50860: LIST
50861: LIST
50862: LIST
50863: LIST
50864: LIST
50865: LIST
50866: LIST
50867: LIST
50868: LIST
50869: LIST
50870: LIST
50871: LIST
50872: LIST
50873: LIST
50874: LIST
50875: LIST
50876: LIST
50877: LIST
50878: LIST
50879: LIST
50880: LIST
50881: LIST
50882: LIST
50883: LIST
50884: LIST
50885: LIST
50886: LIST
50887: LIST
50888: LIST
50889: LIST
50890: LIST
50891: LIST
50892: LIST
50893: LIST
50894: LIST
50895: LIST
50896: LIST
50897: LIST
50898: LIST
50899: LIST
50900: LIST
50901: LIST
50902: LIST
50903: LIST
50904: LIST
50905: LIST
50906: LIST
50907: LIST
50908: ST_TO_ADDR
50909: GO 51372
50911: LD_INT 2
50913: DOUBLE
50914: EQUAL
50915: IFTRUE 50919
50917: GO 51141
50919: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
50920: LD_ADDR_VAR 0 4
50924: PUSH
50925: LD_INT 35
50927: PUSH
50928: LD_INT 45
50930: PUSH
50931: LD_INT 46
50933: PUSH
50934: LD_INT 47
50936: PUSH
50937: LD_INT 82
50939: PUSH
50940: LD_INT 83
50942: PUSH
50943: LD_INT 84
50945: PUSH
50946: LD_INT 85
50948: PUSH
50949: LD_INT 87
50951: PUSH
50952: LD_INT 70
50954: PUSH
50955: LD_INT 1
50957: PUSH
50958: LD_INT 11
50960: PUSH
50961: LD_INT 3
50963: PUSH
50964: LD_INT 4
50966: PUSH
50967: LD_INT 5
50969: PUSH
50970: LD_INT 6
50972: PUSH
50973: LD_INT 15
50975: PUSH
50976: LD_INT 18
50978: PUSH
50979: LD_INT 7
50981: PUSH
50982: LD_INT 17
50984: PUSH
50985: LD_INT 8
50987: PUSH
50988: LD_INT 20
50990: PUSH
50991: LD_INT 21
50993: PUSH
50994: LD_INT 22
50996: PUSH
50997: LD_INT 72
50999: PUSH
51000: LD_INT 26
51002: PUSH
51003: LD_INT 69
51005: PUSH
51006: LD_INT 39
51008: PUSH
51009: LD_INT 40
51011: PUSH
51012: LD_INT 41
51014: PUSH
51015: LD_INT 42
51017: PUSH
51018: LD_INT 43
51020: PUSH
51021: LD_INT 48
51023: PUSH
51024: LD_INT 49
51026: PUSH
51027: LD_INT 50
51029: PUSH
51030: LD_INT 51
51032: PUSH
51033: LD_INT 52
51035: PUSH
51036: LD_INT 53
51038: PUSH
51039: LD_INT 54
51041: PUSH
51042: LD_INT 55
51044: PUSH
51045: LD_INT 56
51047: PUSH
51048: LD_INT 60
51050: PUSH
51051: LD_INT 61
51053: PUSH
51054: LD_INT 62
51056: PUSH
51057: LD_INT 66
51059: PUSH
51060: LD_INT 67
51062: PUSH
51063: LD_INT 68
51065: PUSH
51066: LD_INT 81
51068: PUSH
51069: LD_INT 82
51071: PUSH
51072: LD_INT 83
51074: PUSH
51075: LD_INT 84
51077: PUSH
51078: LD_INT 85
51080: PUSH
51081: LD_INT 87
51083: PUSH
51084: EMPTY
51085: LIST
51086: LIST
51087: LIST
51088: LIST
51089: LIST
51090: LIST
51091: LIST
51092: LIST
51093: LIST
51094: LIST
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: LIST
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: LIST
51138: ST_TO_ADDR
51139: GO 51372
51141: LD_INT 3
51143: DOUBLE
51144: EQUAL
51145: IFTRUE 51149
51147: GO 51371
51149: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51150: LD_ADDR_VAR 0 4
51154: PUSH
51155: LD_INT 46
51157: PUSH
51158: LD_INT 47
51160: PUSH
51161: LD_INT 1
51163: PUSH
51164: LD_INT 2
51166: PUSH
51167: LD_INT 82
51169: PUSH
51170: LD_INT 83
51172: PUSH
51173: LD_INT 84
51175: PUSH
51176: LD_INT 85
51178: PUSH
51179: LD_INT 86
51181: PUSH
51182: LD_INT 11
51184: PUSH
51185: LD_INT 9
51187: PUSH
51188: LD_INT 20
51190: PUSH
51191: LD_INT 19
51193: PUSH
51194: LD_INT 21
51196: PUSH
51197: LD_INT 24
51199: PUSH
51200: LD_INT 22
51202: PUSH
51203: LD_INT 25
51205: PUSH
51206: LD_INT 28
51208: PUSH
51209: LD_INT 29
51211: PUSH
51212: LD_INT 30
51214: PUSH
51215: LD_INT 31
51217: PUSH
51218: LD_INT 37
51220: PUSH
51221: LD_INT 38
51223: PUSH
51224: LD_INT 32
51226: PUSH
51227: LD_INT 27
51229: PUSH
51230: LD_INT 33
51232: PUSH
51233: LD_INT 69
51235: PUSH
51236: LD_INT 39
51238: PUSH
51239: LD_INT 34
51241: PUSH
51242: LD_INT 40
51244: PUSH
51245: LD_INT 71
51247: PUSH
51248: LD_INT 23
51250: PUSH
51251: LD_INT 44
51253: PUSH
51254: LD_INT 48
51256: PUSH
51257: LD_INT 49
51259: PUSH
51260: LD_INT 50
51262: PUSH
51263: LD_INT 51
51265: PUSH
51266: LD_INT 52
51268: PUSH
51269: LD_INT 53
51271: PUSH
51272: LD_INT 54
51274: PUSH
51275: LD_INT 55
51277: PUSH
51278: LD_INT 56
51280: PUSH
51281: LD_INT 57
51283: PUSH
51284: LD_INT 58
51286: PUSH
51287: LD_INT 59
51289: PUSH
51290: LD_INT 63
51292: PUSH
51293: LD_INT 64
51295: PUSH
51296: LD_INT 65
51298: PUSH
51299: LD_INT 82
51301: PUSH
51302: LD_INT 83
51304: PUSH
51305: LD_INT 84
51307: PUSH
51308: LD_INT 85
51310: PUSH
51311: LD_INT 86
51313: PUSH
51314: EMPTY
51315: LIST
51316: LIST
51317: LIST
51318: LIST
51319: LIST
51320: LIST
51321: LIST
51322: LIST
51323: LIST
51324: LIST
51325: LIST
51326: LIST
51327: LIST
51328: LIST
51329: LIST
51330: LIST
51331: LIST
51332: LIST
51333: LIST
51334: LIST
51335: LIST
51336: LIST
51337: LIST
51338: LIST
51339: LIST
51340: LIST
51341: LIST
51342: LIST
51343: LIST
51344: LIST
51345: LIST
51346: LIST
51347: LIST
51348: LIST
51349: LIST
51350: LIST
51351: LIST
51352: LIST
51353: LIST
51354: LIST
51355: LIST
51356: LIST
51357: LIST
51358: LIST
51359: LIST
51360: LIST
51361: LIST
51362: LIST
51363: LIST
51364: LIST
51365: LIST
51366: LIST
51367: LIST
51368: ST_TO_ADDR
51369: GO 51372
51371: POP
// if state > - 1 and state < 3 then
51372: LD_VAR 0 3
51376: PUSH
51377: LD_INT 1
51379: NEG
51380: GREATER
51381: PUSH
51382: LD_VAR 0 3
51386: PUSH
51387: LD_INT 3
51389: LESS
51390: AND
51391: IFFALSE 51448
// for i in result do
51393: LD_ADDR_VAR 0 5
51397: PUSH
51398: LD_VAR 0 4
51402: PUSH
51403: FOR_IN
51404: IFFALSE 51446
// if GetTech ( i , side ) <> state then
51406: LD_VAR 0 5
51410: PPUSH
51411: LD_VAR 0 1
51415: PPUSH
51416: CALL_OW 321
51420: PUSH
51421: LD_VAR 0 3
51425: NONEQUAL
51426: IFFALSE 51444
// result := result diff i ;
51428: LD_ADDR_VAR 0 4
51432: PUSH
51433: LD_VAR 0 4
51437: PUSH
51438: LD_VAR 0 5
51442: DIFF
51443: ST_TO_ADDR
51444: GO 51403
51446: POP
51447: POP
// end ;
51448: LD_VAR 0 4
51452: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51453: LD_INT 0
51455: PPUSH
51456: PPUSH
51457: PPUSH
// result := true ;
51458: LD_ADDR_VAR 0 3
51462: PUSH
51463: LD_INT 1
51465: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51466: LD_ADDR_VAR 0 5
51470: PUSH
51471: LD_VAR 0 2
51475: PPUSH
51476: CALL_OW 480
51480: ST_TO_ADDR
// if not tmp then
51481: LD_VAR 0 5
51485: NOT
51486: IFFALSE 51490
// exit ;
51488: GO 51539
// for i in tmp do
51490: LD_ADDR_VAR 0 4
51494: PUSH
51495: LD_VAR 0 5
51499: PUSH
51500: FOR_IN
51501: IFFALSE 51537
// if GetTech ( i , side ) <> state_researched then
51503: LD_VAR 0 4
51507: PPUSH
51508: LD_VAR 0 1
51512: PPUSH
51513: CALL_OW 321
51517: PUSH
51518: LD_INT 2
51520: NONEQUAL
51521: IFFALSE 51535
// begin result := false ;
51523: LD_ADDR_VAR 0 3
51527: PUSH
51528: LD_INT 0
51530: ST_TO_ADDR
// exit ;
51531: POP
51532: POP
51533: GO 51539
// end ;
51535: GO 51500
51537: POP
51538: POP
// end ;
51539: LD_VAR 0 3
51543: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51544: LD_INT 0
51546: PPUSH
51547: PPUSH
51548: PPUSH
51549: PPUSH
51550: PPUSH
51551: PPUSH
51552: PPUSH
51553: PPUSH
51554: PPUSH
51555: PPUSH
51556: PPUSH
51557: PPUSH
51558: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51559: LD_VAR 0 1
51563: NOT
51564: PUSH
51565: LD_VAR 0 1
51569: PPUSH
51570: CALL_OW 257
51574: PUSH
51575: LD_INT 9
51577: NONEQUAL
51578: OR
51579: IFFALSE 51583
// exit ;
51581: GO 52156
// side := GetSide ( unit ) ;
51583: LD_ADDR_VAR 0 9
51587: PUSH
51588: LD_VAR 0 1
51592: PPUSH
51593: CALL_OW 255
51597: ST_TO_ADDR
// tech_space := tech_spacanom ;
51598: LD_ADDR_VAR 0 12
51602: PUSH
51603: LD_INT 29
51605: ST_TO_ADDR
// tech_time := tech_taurad ;
51606: LD_ADDR_VAR 0 13
51610: PUSH
51611: LD_INT 28
51613: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51614: LD_ADDR_VAR 0 11
51618: PUSH
51619: LD_VAR 0 1
51623: PPUSH
51624: CALL_OW 310
51628: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51629: LD_VAR 0 11
51633: PPUSH
51634: CALL_OW 247
51638: PUSH
51639: LD_INT 2
51641: EQUAL
51642: IFFALSE 51646
// exit ;
51644: GO 52156
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51646: LD_ADDR_VAR 0 8
51650: PUSH
51651: LD_INT 81
51653: PUSH
51654: LD_VAR 0 9
51658: PUSH
51659: EMPTY
51660: LIST
51661: LIST
51662: PUSH
51663: LD_INT 3
51665: PUSH
51666: LD_INT 21
51668: PUSH
51669: LD_INT 3
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PUSH
51680: EMPTY
51681: LIST
51682: LIST
51683: PPUSH
51684: CALL_OW 69
51688: ST_TO_ADDR
// if not tmp then
51689: LD_VAR 0 8
51693: NOT
51694: IFFALSE 51698
// exit ;
51696: GO 52156
// if in_unit then
51698: LD_VAR 0 11
51702: IFFALSE 51726
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51704: LD_ADDR_VAR 0 10
51708: PUSH
51709: LD_VAR 0 8
51713: PPUSH
51714: LD_VAR 0 11
51718: PPUSH
51719: CALL_OW 74
51723: ST_TO_ADDR
51724: GO 51746
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51726: LD_ADDR_VAR 0 10
51730: PUSH
51731: LD_VAR 0 8
51735: PPUSH
51736: LD_VAR 0 1
51740: PPUSH
51741: CALL_OW 74
51745: ST_TO_ADDR
// if not enemy then
51746: LD_VAR 0 10
51750: NOT
51751: IFFALSE 51755
// exit ;
51753: GO 52156
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51755: LD_VAR 0 11
51759: PUSH
51760: LD_VAR 0 11
51764: PPUSH
51765: LD_VAR 0 10
51769: PPUSH
51770: CALL_OW 296
51774: PUSH
51775: LD_INT 13
51777: GREATER
51778: AND
51779: PUSH
51780: LD_VAR 0 1
51784: PPUSH
51785: LD_VAR 0 10
51789: PPUSH
51790: CALL_OW 296
51794: PUSH
51795: LD_INT 12
51797: GREATER
51798: OR
51799: IFFALSE 51803
// exit ;
51801: GO 52156
// missile := [ 1 ] ;
51803: LD_ADDR_VAR 0 14
51807: PUSH
51808: LD_INT 1
51810: PUSH
51811: EMPTY
51812: LIST
51813: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51814: LD_VAR 0 9
51818: PPUSH
51819: LD_VAR 0 12
51823: PPUSH
51824: CALL_OW 325
51828: IFFALSE 51857
// missile := Insert ( missile , missile + 1 , 2 ) ;
51830: LD_ADDR_VAR 0 14
51834: PUSH
51835: LD_VAR 0 14
51839: PPUSH
51840: LD_VAR 0 14
51844: PUSH
51845: LD_INT 1
51847: PLUS
51848: PPUSH
51849: LD_INT 2
51851: PPUSH
51852: CALL_OW 2
51856: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51857: LD_VAR 0 9
51861: PPUSH
51862: LD_VAR 0 13
51866: PPUSH
51867: CALL_OW 325
51871: PUSH
51872: LD_VAR 0 10
51876: PPUSH
51877: CALL_OW 255
51881: PPUSH
51882: LD_VAR 0 13
51886: PPUSH
51887: CALL_OW 325
51891: NOT
51892: AND
51893: IFFALSE 51922
// missile := Insert ( missile , missile + 1 , 3 ) ;
51895: LD_ADDR_VAR 0 14
51899: PUSH
51900: LD_VAR 0 14
51904: PPUSH
51905: LD_VAR 0 14
51909: PUSH
51910: LD_INT 1
51912: PLUS
51913: PPUSH
51914: LD_INT 3
51916: PPUSH
51917: CALL_OW 2
51921: ST_TO_ADDR
// if missile < 2 then
51922: LD_VAR 0 14
51926: PUSH
51927: LD_INT 2
51929: LESS
51930: IFFALSE 51934
// exit ;
51932: GO 52156
// x := GetX ( enemy ) ;
51934: LD_ADDR_VAR 0 4
51938: PUSH
51939: LD_VAR 0 10
51943: PPUSH
51944: CALL_OW 250
51948: ST_TO_ADDR
// y := GetY ( enemy ) ;
51949: LD_ADDR_VAR 0 5
51953: PUSH
51954: LD_VAR 0 10
51958: PPUSH
51959: CALL_OW 251
51963: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51964: LD_ADDR_VAR 0 6
51968: PUSH
51969: LD_VAR 0 4
51973: PUSH
51974: LD_INT 1
51976: NEG
51977: PPUSH
51978: LD_INT 1
51980: PPUSH
51981: CALL_OW 12
51985: PLUS
51986: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51987: LD_ADDR_VAR 0 7
51991: PUSH
51992: LD_VAR 0 5
51996: PUSH
51997: LD_INT 1
51999: NEG
52000: PPUSH
52001: LD_INT 1
52003: PPUSH
52004: CALL_OW 12
52008: PLUS
52009: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52010: LD_VAR 0 6
52014: PPUSH
52015: LD_VAR 0 7
52019: PPUSH
52020: CALL_OW 488
52024: NOT
52025: IFFALSE 52047
// begin _x := x ;
52027: LD_ADDR_VAR 0 6
52031: PUSH
52032: LD_VAR 0 4
52036: ST_TO_ADDR
// _y := y ;
52037: LD_ADDR_VAR 0 7
52041: PUSH
52042: LD_VAR 0 5
52046: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52047: LD_ADDR_VAR 0 3
52051: PUSH
52052: LD_INT 1
52054: PPUSH
52055: LD_VAR 0 14
52059: PPUSH
52060: CALL_OW 12
52064: ST_TO_ADDR
// case i of 1 :
52065: LD_VAR 0 3
52069: PUSH
52070: LD_INT 1
52072: DOUBLE
52073: EQUAL
52074: IFTRUE 52078
52076: GO 52095
52078: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52079: LD_VAR 0 1
52083: PPUSH
52084: LD_VAR 0 10
52088: PPUSH
52089: CALL_OW 115
52093: GO 52156
52095: LD_INT 2
52097: DOUBLE
52098: EQUAL
52099: IFTRUE 52103
52101: GO 52125
52103: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52104: LD_VAR 0 1
52108: PPUSH
52109: LD_VAR 0 6
52113: PPUSH
52114: LD_VAR 0 7
52118: PPUSH
52119: CALL_OW 153
52123: GO 52156
52125: LD_INT 3
52127: DOUBLE
52128: EQUAL
52129: IFTRUE 52133
52131: GO 52155
52133: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52134: LD_VAR 0 1
52138: PPUSH
52139: LD_VAR 0 6
52143: PPUSH
52144: LD_VAR 0 7
52148: PPUSH
52149: CALL_OW 154
52153: GO 52156
52155: POP
// end ;
52156: LD_VAR 0 2
52160: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52161: LD_INT 0
52163: PPUSH
52164: PPUSH
52165: PPUSH
52166: PPUSH
52167: PPUSH
52168: PPUSH
// if not unit or not building then
52169: LD_VAR 0 1
52173: NOT
52174: PUSH
52175: LD_VAR 0 2
52179: NOT
52180: OR
52181: IFFALSE 52185
// exit ;
52183: GO 52343
// x := GetX ( building ) ;
52185: LD_ADDR_VAR 0 5
52189: PUSH
52190: LD_VAR 0 2
52194: PPUSH
52195: CALL_OW 250
52199: ST_TO_ADDR
// y := GetY ( building ) ;
52200: LD_ADDR_VAR 0 6
52204: PUSH
52205: LD_VAR 0 2
52209: PPUSH
52210: CALL_OW 251
52214: ST_TO_ADDR
// for i = 0 to 5 do
52215: LD_ADDR_VAR 0 4
52219: PUSH
52220: DOUBLE
52221: LD_INT 0
52223: DEC
52224: ST_TO_ADDR
52225: LD_INT 5
52227: PUSH
52228: FOR_TO
52229: IFFALSE 52341
// begin _x := ShiftX ( x , i , 3 ) ;
52231: LD_ADDR_VAR 0 7
52235: PUSH
52236: LD_VAR 0 5
52240: PPUSH
52241: LD_VAR 0 4
52245: PPUSH
52246: LD_INT 3
52248: PPUSH
52249: CALL_OW 272
52253: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52254: LD_ADDR_VAR 0 8
52258: PUSH
52259: LD_VAR 0 6
52263: PPUSH
52264: LD_VAR 0 4
52268: PPUSH
52269: LD_INT 3
52271: PPUSH
52272: CALL_OW 273
52276: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52277: LD_VAR 0 7
52281: PPUSH
52282: LD_VAR 0 8
52286: PPUSH
52287: CALL_OW 488
52291: NOT
52292: IFFALSE 52296
// continue ;
52294: GO 52228
// if HexInfo ( _x , _y ) = 0 then
52296: LD_VAR 0 7
52300: PPUSH
52301: LD_VAR 0 8
52305: PPUSH
52306: CALL_OW 428
52310: PUSH
52311: LD_INT 0
52313: EQUAL
52314: IFFALSE 52339
// begin ComMoveXY ( unit , _x , _y ) ;
52316: LD_VAR 0 1
52320: PPUSH
52321: LD_VAR 0 7
52325: PPUSH
52326: LD_VAR 0 8
52330: PPUSH
52331: CALL_OW 111
// exit ;
52335: POP
52336: POP
52337: GO 52343
// end ; end ;
52339: GO 52228
52341: POP
52342: POP
// end ;
52343: LD_VAR 0 3
52347: RET
// export function ScanBase ( side , base_area ) ; begin
52348: LD_INT 0
52350: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52351: LD_ADDR_VAR 0 3
52355: PUSH
52356: LD_VAR 0 2
52360: PPUSH
52361: LD_INT 81
52363: PUSH
52364: LD_VAR 0 1
52368: PUSH
52369: EMPTY
52370: LIST
52371: LIST
52372: PPUSH
52373: CALL_OW 70
52377: ST_TO_ADDR
// end ;
52378: LD_VAR 0 3
52382: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
52383: LD_INT 0
52385: PPUSH
52386: PPUSH
52387: PPUSH
52388: PPUSH
// result := false ;
52389: LD_ADDR_VAR 0 2
52393: PUSH
52394: LD_INT 0
52396: ST_TO_ADDR
// side := GetSide ( unit ) ;
52397: LD_ADDR_VAR 0 3
52401: PUSH
52402: LD_VAR 0 1
52406: PPUSH
52407: CALL_OW 255
52411: ST_TO_ADDR
// nat := GetNation ( unit ) ;
52412: LD_ADDR_VAR 0 4
52416: PUSH
52417: LD_VAR 0 1
52421: PPUSH
52422: CALL_OW 248
52426: ST_TO_ADDR
// case nat of 1 :
52427: LD_VAR 0 4
52431: PUSH
52432: LD_INT 1
52434: DOUBLE
52435: EQUAL
52436: IFTRUE 52440
52438: GO 52451
52440: POP
// tech := tech_lassight ; 2 :
52441: LD_ADDR_VAR 0 5
52445: PUSH
52446: LD_INT 12
52448: ST_TO_ADDR
52449: GO 52490
52451: LD_INT 2
52453: DOUBLE
52454: EQUAL
52455: IFTRUE 52459
52457: GO 52470
52459: POP
// tech := tech_mortar ; 3 :
52460: LD_ADDR_VAR 0 5
52464: PUSH
52465: LD_INT 41
52467: ST_TO_ADDR
52468: GO 52490
52470: LD_INT 3
52472: DOUBLE
52473: EQUAL
52474: IFTRUE 52478
52476: GO 52489
52478: POP
// tech := tech_bazooka ; end ;
52479: LD_ADDR_VAR 0 5
52483: PUSH
52484: LD_INT 44
52486: ST_TO_ADDR
52487: GO 52490
52489: POP
// if Researched ( side , tech ) then
52490: LD_VAR 0 3
52494: PPUSH
52495: LD_VAR 0 5
52499: PPUSH
52500: CALL_OW 325
52504: IFFALSE 52531
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
52506: LD_ADDR_VAR 0 2
52510: PUSH
52511: LD_INT 5
52513: PUSH
52514: LD_INT 8
52516: PUSH
52517: LD_INT 9
52519: PUSH
52520: EMPTY
52521: LIST
52522: LIST
52523: LIST
52524: PUSH
52525: LD_VAR 0 4
52529: ARRAY
52530: ST_TO_ADDR
// end ;
52531: LD_VAR 0 2
52535: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
52536: LD_INT 0
52538: PPUSH
52539: PPUSH
52540: PPUSH
// if not mines then
52541: LD_VAR 0 2
52545: NOT
52546: IFFALSE 52550
// exit ;
52548: GO 52694
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52550: LD_ADDR_VAR 0 5
52554: PUSH
52555: LD_INT 81
52557: PUSH
52558: LD_VAR 0 1
52562: PUSH
52563: EMPTY
52564: LIST
52565: LIST
52566: PUSH
52567: LD_INT 3
52569: PUSH
52570: LD_INT 21
52572: PUSH
52573: LD_INT 3
52575: PUSH
52576: EMPTY
52577: LIST
52578: LIST
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: PPUSH
52588: CALL_OW 69
52592: ST_TO_ADDR
// for i in mines do
52593: LD_ADDR_VAR 0 4
52597: PUSH
52598: LD_VAR 0 2
52602: PUSH
52603: FOR_IN
52604: IFFALSE 52692
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
52606: LD_VAR 0 4
52610: PUSH
52611: LD_INT 1
52613: ARRAY
52614: PPUSH
52615: LD_VAR 0 4
52619: PUSH
52620: LD_INT 2
52622: ARRAY
52623: PPUSH
52624: CALL_OW 458
52628: NOT
52629: IFFALSE 52633
// continue ;
52631: GO 52603
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
52633: LD_VAR 0 4
52637: PUSH
52638: LD_INT 1
52640: ARRAY
52641: PPUSH
52642: LD_VAR 0 4
52646: PUSH
52647: LD_INT 2
52649: ARRAY
52650: PPUSH
52651: CALL_OW 428
52655: PUSH
52656: LD_VAR 0 5
52660: IN
52661: IFFALSE 52690
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
52663: LD_VAR 0 4
52667: PUSH
52668: LD_INT 1
52670: ARRAY
52671: PPUSH
52672: LD_VAR 0 4
52676: PUSH
52677: LD_INT 2
52679: ARRAY
52680: PPUSH
52681: LD_VAR 0 1
52685: PPUSH
52686: CALL_OW 456
// end ;
52690: GO 52603
52692: POP
52693: POP
// end ;
52694: LD_VAR 0 3
52698: RET
// export function Count ( array ) ; var i ; begin
52699: LD_INT 0
52701: PPUSH
52702: PPUSH
// result := 0 ;
52703: LD_ADDR_VAR 0 2
52707: PUSH
52708: LD_INT 0
52710: ST_TO_ADDR
// for i in array do
52711: LD_ADDR_VAR 0 3
52715: PUSH
52716: LD_VAR 0 1
52720: PUSH
52721: FOR_IN
52722: IFFALSE 52746
// if i then
52724: LD_VAR 0 3
52728: IFFALSE 52744
// result := result + 1 ;
52730: LD_ADDR_VAR 0 2
52734: PUSH
52735: LD_VAR 0 2
52739: PUSH
52740: LD_INT 1
52742: PLUS
52743: ST_TO_ADDR
52744: GO 52721
52746: POP
52747: POP
// end ;
52748: LD_VAR 0 2
52752: RET
// export function IsEmpty ( building ) ; begin
52753: LD_INT 0
52755: PPUSH
// if not building then
52756: LD_VAR 0 1
52760: NOT
52761: IFFALSE 52765
// exit ;
52763: GO 52808
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
52765: LD_ADDR_VAR 0 2
52769: PUSH
52770: LD_VAR 0 1
52774: PUSH
52775: LD_INT 22
52777: PUSH
52778: LD_VAR 0 1
52782: PPUSH
52783: CALL_OW 255
52787: PUSH
52788: EMPTY
52789: LIST
52790: LIST
52791: PUSH
52792: LD_INT 58
52794: PUSH
52795: EMPTY
52796: LIST
52797: PUSH
52798: EMPTY
52799: LIST
52800: LIST
52801: PPUSH
52802: CALL_OW 69
52806: IN
52807: ST_TO_ADDR
// end ;
52808: LD_VAR 0 2
52812: RET
// export function IsNotFull ( building ) ; begin
52813: LD_INT 0
52815: PPUSH
// if not building then
52816: LD_VAR 0 1
52820: NOT
52821: IFFALSE 52825
// exit ;
52823: GO 52844
// result := UnitsInside ( building ) < 6 ;
52825: LD_ADDR_VAR 0 2
52829: PUSH
52830: LD_VAR 0 1
52834: PPUSH
52835: CALL_OW 313
52839: PUSH
52840: LD_INT 6
52842: LESS
52843: ST_TO_ADDR
// end ;
52844: LD_VAR 0 2
52848: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
52849: LD_INT 0
52851: PPUSH
52852: PPUSH
52853: PPUSH
52854: PPUSH
// tmp := [ ] ;
52855: LD_ADDR_VAR 0 3
52859: PUSH
52860: EMPTY
52861: ST_TO_ADDR
// list := [ ] ;
52862: LD_ADDR_VAR 0 5
52866: PUSH
52867: EMPTY
52868: ST_TO_ADDR
// for i = 16 to 25 do
52869: LD_ADDR_VAR 0 4
52873: PUSH
52874: DOUBLE
52875: LD_INT 16
52877: DEC
52878: ST_TO_ADDR
52879: LD_INT 25
52881: PUSH
52882: FOR_TO
52883: IFFALSE 52956
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
52885: LD_ADDR_VAR 0 3
52889: PUSH
52890: LD_VAR 0 3
52894: PUSH
52895: LD_INT 22
52897: PUSH
52898: LD_VAR 0 1
52902: PPUSH
52903: CALL_OW 255
52907: PUSH
52908: EMPTY
52909: LIST
52910: LIST
52911: PUSH
52912: LD_INT 91
52914: PUSH
52915: LD_VAR 0 1
52919: PUSH
52920: LD_INT 6
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: LIST
52927: PUSH
52928: LD_INT 30
52930: PUSH
52931: LD_VAR 0 4
52935: PUSH
52936: EMPTY
52937: LIST
52938: LIST
52939: PUSH
52940: EMPTY
52941: LIST
52942: LIST
52943: LIST
52944: PUSH
52945: EMPTY
52946: LIST
52947: PPUSH
52948: CALL_OW 69
52952: ADD
52953: ST_TO_ADDR
52954: GO 52882
52956: POP
52957: POP
// for i = 1 to tmp do
52958: LD_ADDR_VAR 0 4
52962: PUSH
52963: DOUBLE
52964: LD_INT 1
52966: DEC
52967: ST_TO_ADDR
52968: LD_VAR 0 3
52972: PUSH
52973: FOR_TO
52974: IFFALSE 53062
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
52976: LD_ADDR_VAR 0 5
52980: PUSH
52981: LD_VAR 0 5
52985: PUSH
52986: LD_VAR 0 3
52990: PUSH
52991: LD_VAR 0 4
52995: ARRAY
52996: PPUSH
52997: CALL_OW 266
53001: PUSH
53002: LD_VAR 0 3
53006: PUSH
53007: LD_VAR 0 4
53011: ARRAY
53012: PPUSH
53013: CALL_OW 250
53017: PUSH
53018: LD_VAR 0 3
53022: PUSH
53023: LD_VAR 0 4
53027: ARRAY
53028: PPUSH
53029: CALL_OW 251
53033: PUSH
53034: LD_VAR 0 3
53038: PUSH
53039: LD_VAR 0 4
53043: ARRAY
53044: PPUSH
53045: CALL_OW 254
53049: PUSH
53050: EMPTY
53051: LIST
53052: LIST
53053: LIST
53054: LIST
53055: PUSH
53056: EMPTY
53057: LIST
53058: ADD
53059: ST_TO_ADDR
53060: GO 52973
53062: POP
53063: POP
// result := list ;
53064: LD_ADDR_VAR 0 2
53068: PUSH
53069: LD_VAR 0 5
53073: ST_TO_ADDR
// end ;
53074: LD_VAR 0 2
53078: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53079: LD_INT 0
53081: PPUSH
53082: PPUSH
53083: PPUSH
53084: PPUSH
53085: PPUSH
53086: PPUSH
53087: PPUSH
// if not factory then
53088: LD_VAR 0 1
53092: NOT
53093: IFFALSE 53097
// exit ;
53095: GO 53690
// if control = control_apeman then
53097: LD_VAR 0 4
53101: PUSH
53102: LD_INT 5
53104: EQUAL
53105: IFFALSE 53214
// begin tmp := UnitsInside ( factory ) ;
53107: LD_ADDR_VAR 0 8
53111: PUSH
53112: LD_VAR 0 1
53116: PPUSH
53117: CALL_OW 313
53121: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53122: LD_VAR 0 8
53126: PPUSH
53127: LD_INT 25
53129: PUSH
53130: LD_INT 12
53132: PUSH
53133: EMPTY
53134: LIST
53135: LIST
53136: PPUSH
53137: CALL_OW 72
53141: NOT
53142: IFFALSE 53152
// control := control_manual ;
53144: LD_ADDR_VAR 0 4
53148: PUSH
53149: LD_INT 1
53151: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53152: LD_ADDR_VAR 0 8
53156: PUSH
53157: LD_VAR 0 1
53161: PPUSH
53162: CALL 52849 0 1
53166: ST_TO_ADDR
// if tmp then
53167: LD_VAR 0 8
53171: IFFALSE 53214
// begin for i in tmp do
53173: LD_ADDR_VAR 0 7
53177: PUSH
53178: LD_VAR 0 8
53182: PUSH
53183: FOR_IN
53184: IFFALSE 53212
// if i [ 1 ] = b_ext_radio then
53186: LD_VAR 0 7
53190: PUSH
53191: LD_INT 1
53193: ARRAY
53194: PUSH
53195: LD_INT 22
53197: EQUAL
53198: IFFALSE 53210
// begin control := control_remote ;
53200: LD_ADDR_VAR 0 4
53204: PUSH
53205: LD_INT 2
53207: ST_TO_ADDR
// break ;
53208: GO 53212
// end ;
53210: GO 53183
53212: POP
53213: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53214: LD_VAR 0 1
53218: PPUSH
53219: LD_VAR 0 2
53223: PPUSH
53224: LD_VAR 0 3
53228: PPUSH
53229: LD_VAR 0 4
53233: PPUSH
53234: LD_VAR 0 5
53238: PPUSH
53239: CALL_OW 448
53243: IFFALSE 53278
// begin result := [ chassis , engine , control , weapon ] ;
53245: LD_ADDR_VAR 0 6
53249: PUSH
53250: LD_VAR 0 2
53254: PUSH
53255: LD_VAR 0 3
53259: PUSH
53260: LD_VAR 0 4
53264: PUSH
53265: LD_VAR 0 5
53269: PUSH
53270: EMPTY
53271: LIST
53272: LIST
53273: LIST
53274: LIST
53275: ST_TO_ADDR
// exit ;
53276: GO 53690
// end ; _chassis := AvailableChassisList ( factory ) ;
53278: LD_ADDR_VAR 0 9
53282: PUSH
53283: LD_VAR 0 1
53287: PPUSH
53288: CALL_OW 475
53292: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53293: LD_ADDR_VAR 0 11
53297: PUSH
53298: LD_VAR 0 1
53302: PPUSH
53303: CALL_OW 476
53307: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53308: LD_ADDR_VAR 0 12
53312: PUSH
53313: LD_VAR 0 1
53317: PPUSH
53318: CALL_OW 477
53322: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
53323: LD_ADDR_VAR 0 10
53327: PUSH
53328: LD_VAR 0 1
53332: PPUSH
53333: CALL_OW 478
53337: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
53338: LD_VAR 0 9
53342: NOT
53343: PUSH
53344: LD_VAR 0 11
53348: NOT
53349: OR
53350: PUSH
53351: LD_VAR 0 12
53355: NOT
53356: OR
53357: PUSH
53358: LD_VAR 0 10
53362: NOT
53363: OR
53364: IFFALSE 53399
// begin result := [ chassis , engine , control , weapon ] ;
53366: LD_ADDR_VAR 0 6
53370: PUSH
53371: LD_VAR 0 2
53375: PUSH
53376: LD_VAR 0 3
53380: PUSH
53381: LD_VAR 0 4
53385: PUSH
53386: LD_VAR 0 5
53390: PUSH
53391: EMPTY
53392: LIST
53393: LIST
53394: LIST
53395: LIST
53396: ST_TO_ADDR
// exit ;
53397: GO 53690
// end ; if not chassis in _chassis then
53399: LD_VAR 0 2
53403: PUSH
53404: LD_VAR 0 9
53408: IN
53409: NOT
53410: IFFALSE 53436
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
53412: LD_ADDR_VAR 0 2
53416: PUSH
53417: LD_VAR 0 9
53421: PUSH
53422: LD_INT 1
53424: PPUSH
53425: LD_VAR 0 9
53429: PPUSH
53430: CALL_OW 12
53434: ARRAY
53435: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
53436: LD_VAR 0 2
53440: PPUSH
53441: LD_VAR 0 3
53445: PPUSH
53446: CALL 53695 0 2
53450: NOT
53451: IFFALSE 53510
// repeat engine := _engine [ 1 ] ;
53453: LD_ADDR_VAR 0 3
53457: PUSH
53458: LD_VAR 0 11
53462: PUSH
53463: LD_INT 1
53465: ARRAY
53466: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
53467: LD_ADDR_VAR 0 11
53471: PUSH
53472: LD_VAR 0 11
53476: PPUSH
53477: LD_INT 1
53479: PPUSH
53480: CALL_OW 3
53484: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
53485: LD_VAR 0 2
53489: PPUSH
53490: LD_VAR 0 3
53494: PPUSH
53495: CALL 53695 0 2
53499: PUSH
53500: LD_VAR 0 11
53504: PUSH
53505: EMPTY
53506: EQUAL
53507: OR
53508: IFFALSE 53453
// if not control in _control then
53510: LD_VAR 0 4
53514: PUSH
53515: LD_VAR 0 12
53519: IN
53520: NOT
53521: IFFALSE 53547
// control := _control [ rand ( 1 , _control ) ] ;
53523: LD_ADDR_VAR 0 4
53527: PUSH
53528: LD_VAR 0 12
53532: PUSH
53533: LD_INT 1
53535: PPUSH
53536: LD_VAR 0 12
53540: PPUSH
53541: CALL_OW 12
53545: ARRAY
53546: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
53547: LD_VAR 0 2
53551: PPUSH
53552: LD_VAR 0 5
53556: PPUSH
53557: CALL 53915 0 2
53561: NOT
53562: IFFALSE 53621
// repeat weapon := _weapon [ 1 ] ;
53564: LD_ADDR_VAR 0 5
53568: PUSH
53569: LD_VAR 0 10
53573: PUSH
53574: LD_INT 1
53576: ARRAY
53577: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
53578: LD_ADDR_VAR 0 10
53582: PUSH
53583: LD_VAR 0 10
53587: PPUSH
53588: LD_INT 1
53590: PPUSH
53591: CALL_OW 3
53595: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
53596: LD_VAR 0 2
53600: PPUSH
53601: LD_VAR 0 5
53605: PPUSH
53606: CALL 53915 0 2
53610: PUSH
53611: LD_VAR 0 10
53615: PUSH
53616: EMPTY
53617: EQUAL
53618: OR
53619: IFFALSE 53564
// result := [ ] ;
53621: LD_ADDR_VAR 0 6
53625: PUSH
53626: EMPTY
53627: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53628: LD_VAR 0 1
53632: PPUSH
53633: LD_VAR 0 2
53637: PPUSH
53638: LD_VAR 0 3
53642: PPUSH
53643: LD_VAR 0 4
53647: PPUSH
53648: LD_VAR 0 5
53652: PPUSH
53653: CALL_OW 448
53657: IFFALSE 53690
// result := [ chassis , engine , control , weapon ] ;
53659: LD_ADDR_VAR 0 6
53663: PUSH
53664: LD_VAR 0 2
53668: PUSH
53669: LD_VAR 0 3
53673: PUSH
53674: LD_VAR 0 4
53678: PUSH
53679: LD_VAR 0 5
53683: PUSH
53684: EMPTY
53685: LIST
53686: LIST
53687: LIST
53688: LIST
53689: ST_TO_ADDR
// end ;
53690: LD_VAR 0 6
53694: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
53695: LD_INT 0
53697: PPUSH
// if not chassis or not engine then
53698: LD_VAR 0 1
53702: NOT
53703: PUSH
53704: LD_VAR 0 2
53708: NOT
53709: OR
53710: IFFALSE 53714
// exit ;
53712: GO 53910
// case engine of engine_solar :
53714: LD_VAR 0 2
53718: PUSH
53719: LD_INT 2
53721: DOUBLE
53722: EQUAL
53723: IFTRUE 53727
53725: GO 53765
53727: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
53728: LD_ADDR_VAR 0 3
53732: PUSH
53733: LD_INT 11
53735: PUSH
53736: LD_INT 12
53738: PUSH
53739: LD_INT 13
53741: PUSH
53742: LD_INT 14
53744: PUSH
53745: LD_INT 1
53747: PUSH
53748: LD_INT 2
53750: PUSH
53751: LD_INT 3
53753: PUSH
53754: EMPTY
53755: LIST
53756: LIST
53757: LIST
53758: LIST
53759: LIST
53760: LIST
53761: LIST
53762: ST_TO_ADDR
53763: GO 53894
53765: LD_INT 1
53767: DOUBLE
53768: EQUAL
53769: IFTRUE 53773
53771: GO 53835
53773: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
53774: LD_ADDR_VAR 0 3
53778: PUSH
53779: LD_INT 11
53781: PUSH
53782: LD_INT 12
53784: PUSH
53785: LD_INT 13
53787: PUSH
53788: LD_INT 14
53790: PUSH
53791: LD_INT 1
53793: PUSH
53794: LD_INT 2
53796: PUSH
53797: LD_INT 3
53799: PUSH
53800: LD_INT 4
53802: PUSH
53803: LD_INT 5
53805: PUSH
53806: LD_INT 21
53808: PUSH
53809: LD_INT 23
53811: PUSH
53812: LD_INT 22
53814: PUSH
53815: LD_INT 24
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: LIST
53822: LIST
53823: LIST
53824: LIST
53825: LIST
53826: LIST
53827: LIST
53828: LIST
53829: LIST
53830: LIST
53831: LIST
53832: ST_TO_ADDR
53833: GO 53894
53835: LD_INT 3
53837: DOUBLE
53838: EQUAL
53839: IFTRUE 53843
53841: GO 53893
53843: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53844: LD_ADDR_VAR 0 3
53848: PUSH
53849: LD_INT 13
53851: PUSH
53852: LD_INT 14
53854: PUSH
53855: LD_INT 2
53857: PUSH
53858: LD_INT 3
53860: PUSH
53861: LD_INT 4
53863: PUSH
53864: LD_INT 5
53866: PUSH
53867: LD_INT 21
53869: PUSH
53870: LD_INT 22
53872: PUSH
53873: LD_INT 23
53875: PUSH
53876: LD_INT 24
53878: PUSH
53879: EMPTY
53880: LIST
53881: LIST
53882: LIST
53883: LIST
53884: LIST
53885: LIST
53886: LIST
53887: LIST
53888: LIST
53889: LIST
53890: ST_TO_ADDR
53891: GO 53894
53893: POP
// result := ( chassis in result ) ;
53894: LD_ADDR_VAR 0 3
53898: PUSH
53899: LD_VAR 0 1
53903: PUSH
53904: LD_VAR 0 3
53908: IN
53909: ST_TO_ADDR
// end ;
53910: LD_VAR 0 3
53914: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
53915: LD_INT 0
53917: PPUSH
// if not chassis or not weapon then
53918: LD_VAR 0 1
53922: NOT
53923: PUSH
53924: LD_VAR 0 2
53928: NOT
53929: OR
53930: IFFALSE 53934
// exit ;
53932: GO 54960
// case weapon of us_machine_gun :
53934: LD_VAR 0 2
53938: PUSH
53939: LD_INT 2
53941: DOUBLE
53942: EQUAL
53943: IFTRUE 53947
53945: GO 53977
53947: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
53948: LD_ADDR_VAR 0 3
53952: PUSH
53953: LD_INT 1
53955: PUSH
53956: LD_INT 2
53958: PUSH
53959: LD_INT 3
53961: PUSH
53962: LD_INT 4
53964: PUSH
53965: LD_INT 5
53967: PUSH
53968: EMPTY
53969: LIST
53970: LIST
53971: LIST
53972: LIST
53973: LIST
53974: ST_TO_ADDR
53975: GO 54944
53977: LD_INT 3
53979: DOUBLE
53980: EQUAL
53981: IFTRUE 53985
53983: GO 54015
53985: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
53986: LD_ADDR_VAR 0 3
53990: PUSH
53991: LD_INT 1
53993: PUSH
53994: LD_INT 2
53996: PUSH
53997: LD_INT 3
53999: PUSH
54000: LD_INT 4
54002: PUSH
54003: LD_INT 5
54005: PUSH
54006: EMPTY
54007: LIST
54008: LIST
54009: LIST
54010: LIST
54011: LIST
54012: ST_TO_ADDR
54013: GO 54944
54015: LD_INT 11
54017: DOUBLE
54018: EQUAL
54019: IFTRUE 54023
54021: GO 54053
54023: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54024: LD_ADDR_VAR 0 3
54028: PUSH
54029: LD_INT 1
54031: PUSH
54032: LD_INT 2
54034: PUSH
54035: LD_INT 3
54037: PUSH
54038: LD_INT 4
54040: PUSH
54041: LD_INT 5
54043: PUSH
54044: EMPTY
54045: LIST
54046: LIST
54047: LIST
54048: LIST
54049: LIST
54050: ST_TO_ADDR
54051: GO 54944
54053: LD_INT 4
54055: DOUBLE
54056: EQUAL
54057: IFTRUE 54061
54059: GO 54087
54061: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54062: LD_ADDR_VAR 0 3
54066: PUSH
54067: LD_INT 2
54069: PUSH
54070: LD_INT 3
54072: PUSH
54073: LD_INT 4
54075: PUSH
54076: LD_INT 5
54078: PUSH
54079: EMPTY
54080: LIST
54081: LIST
54082: LIST
54083: LIST
54084: ST_TO_ADDR
54085: GO 54944
54087: LD_INT 5
54089: DOUBLE
54090: EQUAL
54091: IFTRUE 54095
54093: GO 54121
54095: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54096: LD_ADDR_VAR 0 3
54100: PUSH
54101: LD_INT 2
54103: PUSH
54104: LD_INT 3
54106: PUSH
54107: LD_INT 4
54109: PUSH
54110: LD_INT 5
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: LIST
54117: LIST
54118: ST_TO_ADDR
54119: GO 54944
54121: LD_INT 9
54123: DOUBLE
54124: EQUAL
54125: IFTRUE 54129
54127: GO 54155
54129: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54130: LD_ADDR_VAR 0 3
54134: PUSH
54135: LD_INT 2
54137: PUSH
54138: LD_INT 3
54140: PUSH
54141: LD_INT 4
54143: PUSH
54144: LD_INT 5
54146: PUSH
54147: EMPTY
54148: LIST
54149: LIST
54150: LIST
54151: LIST
54152: ST_TO_ADDR
54153: GO 54944
54155: LD_INT 7
54157: DOUBLE
54158: EQUAL
54159: IFTRUE 54163
54161: GO 54189
54163: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54164: LD_ADDR_VAR 0 3
54168: PUSH
54169: LD_INT 2
54171: PUSH
54172: LD_INT 3
54174: PUSH
54175: LD_INT 4
54177: PUSH
54178: LD_INT 5
54180: PUSH
54181: EMPTY
54182: LIST
54183: LIST
54184: LIST
54185: LIST
54186: ST_TO_ADDR
54187: GO 54944
54189: LD_INT 12
54191: DOUBLE
54192: EQUAL
54193: IFTRUE 54197
54195: GO 54223
54197: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54198: LD_ADDR_VAR 0 3
54202: PUSH
54203: LD_INT 2
54205: PUSH
54206: LD_INT 3
54208: PUSH
54209: LD_INT 4
54211: PUSH
54212: LD_INT 5
54214: PUSH
54215: EMPTY
54216: LIST
54217: LIST
54218: LIST
54219: LIST
54220: ST_TO_ADDR
54221: GO 54944
54223: LD_INT 13
54225: DOUBLE
54226: EQUAL
54227: IFTRUE 54231
54229: GO 54257
54231: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54232: LD_ADDR_VAR 0 3
54236: PUSH
54237: LD_INT 2
54239: PUSH
54240: LD_INT 3
54242: PUSH
54243: LD_INT 4
54245: PUSH
54246: LD_INT 5
54248: PUSH
54249: EMPTY
54250: LIST
54251: LIST
54252: LIST
54253: LIST
54254: ST_TO_ADDR
54255: GO 54944
54257: LD_INT 14
54259: DOUBLE
54260: EQUAL
54261: IFTRUE 54265
54263: GO 54283
54265: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54266: LD_ADDR_VAR 0 3
54270: PUSH
54271: LD_INT 4
54273: PUSH
54274: LD_INT 5
54276: PUSH
54277: EMPTY
54278: LIST
54279: LIST
54280: ST_TO_ADDR
54281: GO 54944
54283: LD_INT 6
54285: DOUBLE
54286: EQUAL
54287: IFTRUE 54291
54289: GO 54309
54291: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54292: LD_ADDR_VAR 0 3
54296: PUSH
54297: LD_INT 4
54299: PUSH
54300: LD_INT 5
54302: PUSH
54303: EMPTY
54304: LIST
54305: LIST
54306: ST_TO_ADDR
54307: GO 54944
54309: LD_INT 10
54311: DOUBLE
54312: EQUAL
54313: IFTRUE 54317
54315: GO 54335
54317: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
54318: LD_ADDR_VAR 0 3
54322: PUSH
54323: LD_INT 4
54325: PUSH
54326: LD_INT 5
54328: PUSH
54329: EMPTY
54330: LIST
54331: LIST
54332: ST_TO_ADDR
54333: GO 54944
54335: LD_INT 22
54337: DOUBLE
54338: EQUAL
54339: IFTRUE 54343
54341: GO 54369
54343: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
54344: LD_ADDR_VAR 0 3
54348: PUSH
54349: LD_INT 11
54351: PUSH
54352: LD_INT 12
54354: PUSH
54355: LD_INT 13
54357: PUSH
54358: LD_INT 14
54360: PUSH
54361: EMPTY
54362: LIST
54363: LIST
54364: LIST
54365: LIST
54366: ST_TO_ADDR
54367: GO 54944
54369: LD_INT 23
54371: DOUBLE
54372: EQUAL
54373: IFTRUE 54377
54375: GO 54403
54377: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
54378: LD_ADDR_VAR 0 3
54382: PUSH
54383: LD_INT 11
54385: PUSH
54386: LD_INT 12
54388: PUSH
54389: LD_INT 13
54391: PUSH
54392: LD_INT 14
54394: PUSH
54395: EMPTY
54396: LIST
54397: LIST
54398: LIST
54399: LIST
54400: ST_TO_ADDR
54401: GO 54944
54403: LD_INT 24
54405: DOUBLE
54406: EQUAL
54407: IFTRUE 54411
54409: GO 54437
54411: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
54412: LD_ADDR_VAR 0 3
54416: PUSH
54417: LD_INT 11
54419: PUSH
54420: LD_INT 12
54422: PUSH
54423: LD_INT 13
54425: PUSH
54426: LD_INT 14
54428: PUSH
54429: EMPTY
54430: LIST
54431: LIST
54432: LIST
54433: LIST
54434: ST_TO_ADDR
54435: GO 54944
54437: LD_INT 30
54439: DOUBLE
54440: EQUAL
54441: IFTRUE 54445
54443: GO 54471
54445: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
54446: LD_ADDR_VAR 0 3
54450: PUSH
54451: LD_INT 11
54453: PUSH
54454: LD_INT 12
54456: PUSH
54457: LD_INT 13
54459: PUSH
54460: LD_INT 14
54462: PUSH
54463: EMPTY
54464: LIST
54465: LIST
54466: LIST
54467: LIST
54468: ST_TO_ADDR
54469: GO 54944
54471: LD_INT 25
54473: DOUBLE
54474: EQUAL
54475: IFTRUE 54479
54477: GO 54497
54479: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
54480: LD_ADDR_VAR 0 3
54484: PUSH
54485: LD_INT 13
54487: PUSH
54488: LD_INT 14
54490: PUSH
54491: EMPTY
54492: LIST
54493: LIST
54494: ST_TO_ADDR
54495: GO 54944
54497: LD_INT 27
54499: DOUBLE
54500: EQUAL
54501: IFTRUE 54505
54503: GO 54523
54505: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
54506: LD_ADDR_VAR 0 3
54510: PUSH
54511: LD_INT 13
54513: PUSH
54514: LD_INT 14
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: ST_TO_ADDR
54521: GO 54944
54523: LD_INT 28
54525: DOUBLE
54526: EQUAL
54527: IFTRUE 54531
54529: GO 54549
54531: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
54532: LD_ADDR_VAR 0 3
54536: PUSH
54537: LD_INT 13
54539: PUSH
54540: LD_INT 14
54542: PUSH
54543: EMPTY
54544: LIST
54545: LIST
54546: ST_TO_ADDR
54547: GO 54944
54549: LD_INT 29
54551: DOUBLE
54552: EQUAL
54553: IFTRUE 54557
54555: GO 54575
54557: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
54558: LD_ADDR_VAR 0 3
54562: PUSH
54563: LD_INT 13
54565: PUSH
54566: LD_INT 14
54568: PUSH
54569: EMPTY
54570: LIST
54571: LIST
54572: ST_TO_ADDR
54573: GO 54944
54575: LD_INT 31
54577: DOUBLE
54578: EQUAL
54579: IFTRUE 54583
54581: GO 54601
54583: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
54584: LD_ADDR_VAR 0 3
54588: PUSH
54589: LD_INT 13
54591: PUSH
54592: LD_INT 14
54594: PUSH
54595: EMPTY
54596: LIST
54597: LIST
54598: ST_TO_ADDR
54599: GO 54944
54601: LD_INT 26
54603: DOUBLE
54604: EQUAL
54605: IFTRUE 54609
54607: GO 54627
54609: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
54610: LD_ADDR_VAR 0 3
54614: PUSH
54615: LD_INT 13
54617: PUSH
54618: LD_INT 14
54620: PUSH
54621: EMPTY
54622: LIST
54623: LIST
54624: ST_TO_ADDR
54625: GO 54944
54627: LD_INT 42
54629: DOUBLE
54630: EQUAL
54631: IFTRUE 54635
54633: GO 54661
54635: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
54636: LD_ADDR_VAR 0 3
54640: PUSH
54641: LD_INT 21
54643: PUSH
54644: LD_INT 22
54646: PUSH
54647: LD_INT 23
54649: PUSH
54650: LD_INT 24
54652: PUSH
54653: EMPTY
54654: LIST
54655: LIST
54656: LIST
54657: LIST
54658: ST_TO_ADDR
54659: GO 54944
54661: LD_INT 43
54663: DOUBLE
54664: EQUAL
54665: IFTRUE 54669
54667: GO 54695
54669: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
54670: LD_ADDR_VAR 0 3
54674: PUSH
54675: LD_INT 21
54677: PUSH
54678: LD_INT 22
54680: PUSH
54681: LD_INT 23
54683: PUSH
54684: LD_INT 24
54686: PUSH
54687: EMPTY
54688: LIST
54689: LIST
54690: LIST
54691: LIST
54692: ST_TO_ADDR
54693: GO 54944
54695: LD_INT 44
54697: DOUBLE
54698: EQUAL
54699: IFTRUE 54703
54701: GO 54729
54703: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
54704: LD_ADDR_VAR 0 3
54708: PUSH
54709: LD_INT 21
54711: PUSH
54712: LD_INT 22
54714: PUSH
54715: LD_INT 23
54717: PUSH
54718: LD_INT 24
54720: PUSH
54721: EMPTY
54722: LIST
54723: LIST
54724: LIST
54725: LIST
54726: ST_TO_ADDR
54727: GO 54944
54729: LD_INT 45
54731: DOUBLE
54732: EQUAL
54733: IFTRUE 54737
54735: GO 54763
54737: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
54738: LD_ADDR_VAR 0 3
54742: PUSH
54743: LD_INT 21
54745: PUSH
54746: LD_INT 22
54748: PUSH
54749: LD_INT 23
54751: PUSH
54752: LD_INT 24
54754: PUSH
54755: EMPTY
54756: LIST
54757: LIST
54758: LIST
54759: LIST
54760: ST_TO_ADDR
54761: GO 54944
54763: LD_INT 49
54765: DOUBLE
54766: EQUAL
54767: IFTRUE 54771
54769: GO 54797
54771: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
54772: LD_ADDR_VAR 0 3
54776: PUSH
54777: LD_INT 21
54779: PUSH
54780: LD_INT 22
54782: PUSH
54783: LD_INT 23
54785: PUSH
54786: LD_INT 24
54788: PUSH
54789: EMPTY
54790: LIST
54791: LIST
54792: LIST
54793: LIST
54794: ST_TO_ADDR
54795: GO 54944
54797: LD_INT 51
54799: DOUBLE
54800: EQUAL
54801: IFTRUE 54805
54803: GO 54831
54805: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
54806: LD_ADDR_VAR 0 3
54810: PUSH
54811: LD_INT 21
54813: PUSH
54814: LD_INT 22
54816: PUSH
54817: LD_INT 23
54819: PUSH
54820: LD_INT 24
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: LIST
54827: LIST
54828: ST_TO_ADDR
54829: GO 54944
54831: LD_INT 52
54833: DOUBLE
54834: EQUAL
54835: IFTRUE 54839
54837: GO 54865
54839: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
54840: LD_ADDR_VAR 0 3
54844: PUSH
54845: LD_INT 21
54847: PUSH
54848: LD_INT 22
54850: PUSH
54851: LD_INT 23
54853: PUSH
54854: LD_INT 24
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: LIST
54861: LIST
54862: ST_TO_ADDR
54863: GO 54944
54865: LD_INT 53
54867: DOUBLE
54868: EQUAL
54869: IFTRUE 54873
54871: GO 54891
54873: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
54874: LD_ADDR_VAR 0 3
54878: PUSH
54879: LD_INT 23
54881: PUSH
54882: LD_INT 24
54884: PUSH
54885: EMPTY
54886: LIST
54887: LIST
54888: ST_TO_ADDR
54889: GO 54944
54891: LD_INT 46
54893: DOUBLE
54894: EQUAL
54895: IFTRUE 54899
54897: GO 54917
54899: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
54900: LD_ADDR_VAR 0 3
54904: PUSH
54905: LD_INT 23
54907: PUSH
54908: LD_INT 24
54910: PUSH
54911: EMPTY
54912: LIST
54913: LIST
54914: ST_TO_ADDR
54915: GO 54944
54917: LD_INT 47
54919: DOUBLE
54920: EQUAL
54921: IFTRUE 54925
54923: GO 54943
54925: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54926: LD_ADDR_VAR 0 3
54930: PUSH
54931: LD_INT 23
54933: PUSH
54934: LD_INT 24
54936: PUSH
54937: EMPTY
54938: LIST
54939: LIST
54940: ST_TO_ADDR
54941: GO 54944
54943: POP
// result := ( chassis in result ) ;
54944: LD_ADDR_VAR 0 3
54948: PUSH
54949: LD_VAR 0 1
54953: PUSH
54954: LD_VAR 0 3
54958: IN
54959: ST_TO_ADDR
// end ;
54960: LD_VAR 0 3
54964: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
54965: LD_INT 0
54967: PPUSH
54968: PPUSH
54969: PPUSH
54970: PPUSH
54971: PPUSH
54972: PPUSH
54973: PPUSH
// result := array ;
54974: LD_ADDR_VAR 0 5
54978: PUSH
54979: LD_VAR 0 1
54983: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
54984: LD_VAR 0 1
54988: NOT
54989: PUSH
54990: LD_VAR 0 2
54994: NOT
54995: OR
54996: PUSH
54997: LD_VAR 0 3
55001: NOT
55002: OR
55003: PUSH
55004: LD_VAR 0 2
55008: PUSH
55009: LD_VAR 0 1
55013: GREATER
55014: OR
55015: PUSH
55016: LD_VAR 0 3
55020: PUSH
55021: LD_VAR 0 1
55025: GREATER
55026: OR
55027: IFFALSE 55031
// exit ;
55029: GO 55327
// if direction then
55031: LD_VAR 0 4
55035: IFFALSE 55099
// begin d := 1 ;
55037: LD_ADDR_VAR 0 9
55041: PUSH
55042: LD_INT 1
55044: ST_TO_ADDR
// if i_from > i_to then
55045: LD_VAR 0 2
55049: PUSH
55050: LD_VAR 0 3
55054: GREATER
55055: IFFALSE 55081
// length := ( array - i_from ) + i_to else
55057: LD_ADDR_VAR 0 11
55061: PUSH
55062: LD_VAR 0 1
55066: PUSH
55067: LD_VAR 0 2
55071: MINUS
55072: PUSH
55073: LD_VAR 0 3
55077: PLUS
55078: ST_TO_ADDR
55079: GO 55097
// length := i_to - i_from ;
55081: LD_ADDR_VAR 0 11
55085: PUSH
55086: LD_VAR 0 3
55090: PUSH
55091: LD_VAR 0 2
55095: MINUS
55096: ST_TO_ADDR
// end else
55097: GO 55160
// begin d := - 1 ;
55099: LD_ADDR_VAR 0 9
55103: PUSH
55104: LD_INT 1
55106: NEG
55107: ST_TO_ADDR
// if i_from > i_to then
55108: LD_VAR 0 2
55112: PUSH
55113: LD_VAR 0 3
55117: GREATER
55118: IFFALSE 55138
// length := i_from - i_to else
55120: LD_ADDR_VAR 0 11
55124: PUSH
55125: LD_VAR 0 2
55129: PUSH
55130: LD_VAR 0 3
55134: MINUS
55135: ST_TO_ADDR
55136: GO 55160
// length := ( array - i_to ) + i_from ;
55138: LD_ADDR_VAR 0 11
55142: PUSH
55143: LD_VAR 0 1
55147: PUSH
55148: LD_VAR 0 3
55152: MINUS
55153: PUSH
55154: LD_VAR 0 2
55158: PLUS
55159: ST_TO_ADDR
// end ; if not length then
55160: LD_VAR 0 11
55164: NOT
55165: IFFALSE 55169
// exit ;
55167: GO 55327
// tmp := array ;
55169: LD_ADDR_VAR 0 10
55173: PUSH
55174: LD_VAR 0 1
55178: ST_TO_ADDR
// for i = 1 to length do
55179: LD_ADDR_VAR 0 6
55183: PUSH
55184: DOUBLE
55185: LD_INT 1
55187: DEC
55188: ST_TO_ADDR
55189: LD_VAR 0 11
55193: PUSH
55194: FOR_TO
55195: IFFALSE 55315
// begin for j = 1 to array do
55197: LD_ADDR_VAR 0 7
55201: PUSH
55202: DOUBLE
55203: LD_INT 1
55205: DEC
55206: ST_TO_ADDR
55207: LD_VAR 0 1
55211: PUSH
55212: FOR_TO
55213: IFFALSE 55301
// begin k := j + d ;
55215: LD_ADDR_VAR 0 8
55219: PUSH
55220: LD_VAR 0 7
55224: PUSH
55225: LD_VAR 0 9
55229: PLUS
55230: ST_TO_ADDR
// if k > array then
55231: LD_VAR 0 8
55235: PUSH
55236: LD_VAR 0 1
55240: GREATER
55241: IFFALSE 55251
// k := 1 ;
55243: LD_ADDR_VAR 0 8
55247: PUSH
55248: LD_INT 1
55250: ST_TO_ADDR
// if not k then
55251: LD_VAR 0 8
55255: NOT
55256: IFFALSE 55268
// k := array ;
55258: LD_ADDR_VAR 0 8
55262: PUSH
55263: LD_VAR 0 1
55267: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55268: LD_ADDR_VAR 0 10
55272: PUSH
55273: LD_VAR 0 10
55277: PPUSH
55278: LD_VAR 0 8
55282: PPUSH
55283: LD_VAR 0 1
55287: PUSH
55288: LD_VAR 0 7
55292: ARRAY
55293: PPUSH
55294: CALL_OW 1
55298: ST_TO_ADDR
// end ;
55299: GO 55212
55301: POP
55302: POP
// array := tmp ;
55303: LD_ADDR_VAR 0 1
55307: PUSH
55308: LD_VAR 0 10
55312: ST_TO_ADDR
// end ;
55313: GO 55194
55315: POP
55316: POP
// result := array ;
55317: LD_ADDR_VAR 0 5
55321: PUSH
55322: LD_VAR 0 1
55326: ST_TO_ADDR
// end ;
55327: LD_VAR 0 5
55331: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
55332: LD_INT 0
55334: PPUSH
55335: PPUSH
// result := 0 ;
55336: LD_ADDR_VAR 0 3
55340: PUSH
55341: LD_INT 0
55343: ST_TO_ADDR
// if not array or not value in array then
55344: LD_VAR 0 1
55348: NOT
55349: PUSH
55350: LD_VAR 0 2
55354: PUSH
55355: LD_VAR 0 1
55359: IN
55360: NOT
55361: OR
55362: IFFALSE 55366
// exit ;
55364: GO 55420
// for i = 1 to array do
55366: LD_ADDR_VAR 0 4
55370: PUSH
55371: DOUBLE
55372: LD_INT 1
55374: DEC
55375: ST_TO_ADDR
55376: LD_VAR 0 1
55380: PUSH
55381: FOR_TO
55382: IFFALSE 55418
// if value = array [ i ] then
55384: LD_VAR 0 2
55388: PUSH
55389: LD_VAR 0 1
55393: PUSH
55394: LD_VAR 0 4
55398: ARRAY
55399: EQUAL
55400: IFFALSE 55416
// begin result := i ;
55402: LD_ADDR_VAR 0 3
55406: PUSH
55407: LD_VAR 0 4
55411: ST_TO_ADDR
// exit ;
55412: POP
55413: POP
55414: GO 55420
// end ;
55416: GO 55381
55418: POP
55419: POP
// end ;
55420: LD_VAR 0 3
55424: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
55425: LD_INT 0
55427: PPUSH
// vc_chassis := chassis ;
55428: LD_ADDR_OWVAR 37
55432: PUSH
55433: LD_VAR 0 1
55437: ST_TO_ADDR
// vc_engine := engine ;
55438: LD_ADDR_OWVAR 39
55442: PUSH
55443: LD_VAR 0 2
55447: ST_TO_ADDR
// vc_control := control ;
55448: LD_ADDR_OWVAR 38
55452: PUSH
55453: LD_VAR 0 3
55457: ST_TO_ADDR
// vc_weapon := weapon ;
55458: LD_ADDR_OWVAR 40
55462: PUSH
55463: LD_VAR 0 4
55467: ST_TO_ADDR
// vc_fuel_battery := fuel ;
55468: LD_ADDR_OWVAR 41
55472: PUSH
55473: LD_VAR 0 5
55477: ST_TO_ADDR
// end ;
55478: LD_VAR 0 6
55482: RET
// export function WantPlant ( unit ) ; var task ; begin
55483: LD_INT 0
55485: PPUSH
55486: PPUSH
// result := false ;
55487: LD_ADDR_VAR 0 2
55491: PUSH
55492: LD_INT 0
55494: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
55495: LD_ADDR_VAR 0 3
55499: PUSH
55500: LD_VAR 0 1
55504: PPUSH
55505: CALL_OW 437
55509: ST_TO_ADDR
// if task then
55510: LD_VAR 0 3
55514: IFFALSE 55542
// if task [ 1 ] [ 1 ] = p then
55516: LD_VAR 0 3
55520: PUSH
55521: LD_INT 1
55523: ARRAY
55524: PUSH
55525: LD_INT 1
55527: ARRAY
55528: PUSH
55529: LD_STRING p
55531: EQUAL
55532: IFFALSE 55542
// result := true ;
55534: LD_ADDR_VAR 0 2
55538: PUSH
55539: LD_INT 1
55541: ST_TO_ADDR
// end ;
55542: LD_VAR 0 2
55546: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
55547: LD_INT 0
55549: PPUSH
55550: PPUSH
55551: PPUSH
55552: PPUSH
// if pos < 1 then
55553: LD_VAR 0 2
55557: PUSH
55558: LD_INT 1
55560: LESS
55561: IFFALSE 55565
// exit ;
55563: GO 55868
// if pos = 1 then
55565: LD_VAR 0 2
55569: PUSH
55570: LD_INT 1
55572: EQUAL
55573: IFFALSE 55606
// result := Replace ( arr , pos [ 1 ] , value ) else
55575: LD_ADDR_VAR 0 4
55579: PUSH
55580: LD_VAR 0 1
55584: PPUSH
55585: LD_VAR 0 2
55589: PUSH
55590: LD_INT 1
55592: ARRAY
55593: PPUSH
55594: LD_VAR 0 3
55598: PPUSH
55599: CALL_OW 1
55603: ST_TO_ADDR
55604: GO 55868
// begin tmp := arr ;
55606: LD_ADDR_VAR 0 6
55610: PUSH
55611: LD_VAR 0 1
55615: ST_TO_ADDR
// s_arr := [ tmp ] ;
55616: LD_ADDR_VAR 0 7
55620: PUSH
55621: LD_VAR 0 6
55625: PUSH
55626: EMPTY
55627: LIST
55628: ST_TO_ADDR
// for i = 1 to pos - 1 do
55629: LD_ADDR_VAR 0 5
55633: PUSH
55634: DOUBLE
55635: LD_INT 1
55637: DEC
55638: ST_TO_ADDR
55639: LD_VAR 0 2
55643: PUSH
55644: LD_INT 1
55646: MINUS
55647: PUSH
55648: FOR_TO
55649: IFFALSE 55694
// begin tmp := tmp [ pos [ i ] ] ;
55651: LD_ADDR_VAR 0 6
55655: PUSH
55656: LD_VAR 0 6
55660: PUSH
55661: LD_VAR 0 2
55665: PUSH
55666: LD_VAR 0 5
55670: ARRAY
55671: ARRAY
55672: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
55673: LD_ADDR_VAR 0 7
55677: PUSH
55678: LD_VAR 0 7
55682: PUSH
55683: LD_VAR 0 6
55687: PUSH
55688: EMPTY
55689: LIST
55690: ADD
55691: ST_TO_ADDR
// end ;
55692: GO 55648
55694: POP
55695: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
55696: LD_ADDR_VAR 0 6
55700: PUSH
55701: LD_VAR 0 6
55705: PPUSH
55706: LD_VAR 0 2
55710: PUSH
55711: LD_VAR 0 2
55715: ARRAY
55716: PPUSH
55717: LD_VAR 0 3
55721: PPUSH
55722: CALL_OW 1
55726: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
55727: LD_ADDR_VAR 0 7
55731: PUSH
55732: LD_VAR 0 7
55736: PPUSH
55737: LD_VAR 0 7
55741: PPUSH
55742: LD_VAR 0 6
55746: PPUSH
55747: CALL_OW 1
55751: ST_TO_ADDR
// for i = s_arr downto 2 do
55752: LD_ADDR_VAR 0 5
55756: PUSH
55757: DOUBLE
55758: LD_VAR 0 7
55762: INC
55763: ST_TO_ADDR
55764: LD_INT 2
55766: PUSH
55767: FOR_DOWNTO
55768: IFFALSE 55852
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
55770: LD_ADDR_VAR 0 6
55774: PUSH
55775: LD_VAR 0 7
55779: PUSH
55780: LD_VAR 0 5
55784: PUSH
55785: LD_INT 1
55787: MINUS
55788: ARRAY
55789: PPUSH
55790: LD_VAR 0 2
55794: PUSH
55795: LD_VAR 0 5
55799: PUSH
55800: LD_INT 1
55802: MINUS
55803: ARRAY
55804: PPUSH
55805: LD_VAR 0 7
55809: PUSH
55810: LD_VAR 0 5
55814: ARRAY
55815: PPUSH
55816: CALL_OW 1
55820: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
55821: LD_ADDR_VAR 0 7
55825: PUSH
55826: LD_VAR 0 7
55830: PPUSH
55831: LD_VAR 0 5
55835: PUSH
55836: LD_INT 1
55838: MINUS
55839: PPUSH
55840: LD_VAR 0 6
55844: PPUSH
55845: CALL_OW 1
55849: ST_TO_ADDR
// end ;
55850: GO 55767
55852: POP
55853: POP
// result := s_arr [ 1 ] ;
55854: LD_ADDR_VAR 0 4
55858: PUSH
55859: LD_VAR 0 7
55863: PUSH
55864: LD_INT 1
55866: ARRAY
55867: ST_TO_ADDR
// end ; end ;
55868: LD_VAR 0 4
55872: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
55873: LD_INT 0
55875: PPUSH
55876: PPUSH
// if not list then
55877: LD_VAR 0 1
55881: NOT
55882: IFFALSE 55886
// exit ;
55884: GO 55977
// i := list [ pos1 ] ;
55886: LD_ADDR_VAR 0 5
55890: PUSH
55891: LD_VAR 0 1
55895: PUSH
55896: LD_VAR 0 2
55900: ARRAY
55901: ST_TO_ADDR
// if not i then
55902: LD_VAR 0 5
55906: NOT
55907: IFFALSE 55911
// exit ;
55909: GO 55977
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
55911: LD_ADDR_VAR 0 1
55915: PUSH
55916: LD_VAR 0 1
55920: PPUSH
55921: LD_VAR 0 2
55925: PPUSH
55926: LD_VAR 0 1
55930: PUSH
55931: LD_VAR 0 3
55935: ARRAY
55936: PPUSH
55937: CALL_OW 1
55941: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
55942: LD_ADDR_VAR 0 1
55946: PUSH
55947: LD_VAR 0 1
55951: PPUSH
55952: LD_VAR 0 3
55956: PPUSH
55957: LD_VAR 0 5
55961: PPUSH
55962: CALL_OW 1
55966: ST_TO_ADDR
// result := list ;
55967: LD_ADDR_VAR 0 4
55971: PUSH
55972: LD_VAR 0 1
55976: ST_TO_ADDR
// end ;
55977: LD_VAR 0 4
55981: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
55982: LD_INT 0
55984: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
55985: LD_ADDR_VAR 0 5
55989: PUSH
55990: LD_VAR 0 1
55994: PPUSH
55995: CALL_OW 250
55999: PPUSH
56000: LD_VAR 0 1
56004: PPUSH
56005: CALL_OW 251
56009: PPUSH
56010: LD_VAR 0 2
56014: PPUSH
56015: LD_VAR 0 3
56019: PPUSH
56020: LD_VAR 0 4
56024: PPUSH
56025: CALL 56035 0 5
56029: ST_TO_ADDR
// end ;
56030: LD_VAR 0 5
56034: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56035: LD_INT 0
56037: PPUSH
56038: PPUSH
56039: PPUSH
56040: PPUSH
// if not list then
56041: LD_VAR 0 3
56045: NOT
56046: IFFALSE 56050
// exit ;
56048: GO 56438
// result := [ ] ;
56050: LD_ADDR_VAR 0 6
56054: PUSH
56055: EMPTY
56056: ST_TO_ADDR
// for i in list do
56057: LD_ADDR_VAR 0 7
56061: PUSH
56062: LD_VAR 0 3
56066: PUSH
56067: FOR_IN
56068: IFFALSE 56270
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56070: LD_ADDR_VAR 0 9
56074: PUSH
56075: LD_VAR 0 7
56079: PPUSH
56080: LD_VAR 0 1
56084: PPUSH
56085: LD_VAR 0 2
56089: PPUSH
56090: CALL_OW 297
56094: ST_TO_ADDR
// if not result then
56095: LD_VAR 0 6
56099: NOT
56100: IFFALSE 56126
// result := [ [ i , tmp ] ] else
56102: LD_ADDR_VAR 0 6
56106: PUSH
56107: LD_VAR 0 7
56111: PUSH
56112: LD_VAR 0 9
56116: PUSH
56117: EMPTY
56118: LIST
56119: LIST
56120: PUSH
56121: EMPTY
56122: LIST
56123: ST_TO_ADDR
56124: GO 56268
// begin if result [ result ] [ 2 ] < tmp then
56126: LD_VAR 0 6
56130: PUSH
56131: LD_VAR 0 6
56135: ARRAY
56136: PUSH
56137: LD_INT 2
56139: ARRAY
56140: PUSH
56141: LD_VAR 0 9
56145: LESS
56146: IFFALSE 56188
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56148: LD_ADDR_VAR 0 6
56152: PUSH
56153: LD_VAR 0 6
56157: PPUSH
56158: LD_VAR 0 6
56162: PUSH
56163: LD_INT 1
56165: PLUS
56166: PPUSH
56167: LD_VAR 0 7
56171: PUSH
56172: LD_VAR 0 9
56176: PUSH
56177: EMPTY
56178: LIST
56179: LIST
56180: PPUSH
56181: CALL_OW 2
56185: ST_TO_ADDR
56186: GO 56268
// for j = 1 to result do
56188: LD_ADDR_VAR 0 8
56192: PUSH
56193: DOUBLE
56194: LD_INT 1
56196: DEC
56197: ST_TO_ADDR
56198: LD_VAR 0 6
56202: PUSH
56203: FOR_TO
56204: IFFALSE 56266
// begin if tmp < result [ j ] [ 2 ] then
56206: LD_VAR 0 9
56210: PUSH
56211: LD_VAR 0 6
56215: PUSH
56216: LD_VAR 0 8
56220: ARRAY
56221: PUSH
56222: LD_INT 2
56224: ARRAY
56225: LESS
56226: IFFALSE 56264
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56228: LD_ADDR_VAR 0 6
56232: PUSH
56233: LD_VAR 0 6
56237: PPUSH
56238: LD_VAR 0 8
56242: PPUSH
56243: LD_VAR 0 7
56247: PUSH
56248: LD_VAR 0 9
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: PPUSH
56257: CALL_OW 2
56261: ST_TO_ADDR
// break ;
56262: GO 56266
// end ; end ;
56264: GO 56203
56266: POP
56267: POP
// end ; end ;
56268: GO 56067
56270: POP
56271: POP
// if result and not asc then
56272: LD_VAR 0 6
56276: PUSH
56277: LD_VAR 0 4
56281: NOT
56282: AND
56283: IFFALSE 56358
// begin tmp := result ;
56285: LD_ADDR_VAR 0 9
56289: PUSH
56290: LD_VAR 0 6
56294: ST_TO_ADDR
// for i = tmp downto 1 do
56295: LD_ADDR_VAR 0 7
56299: PUSH
56300: DOUBLE
56301: LD_VAR 0 9
56305: INC
56306: ST_TO_ADDR
56307: LD_INT 1
56309: PUSH
56310: FOR_DOWNTO
56311: IFFALSE 56356
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
56313: LD_ADDR_VAR 0 6
56317: PUSH
56318: LD_VAR 0 6
56322: PPUSH
56323: LD_VAR 0 9
56327: PUSH
56328: LD_VAR 0 7
56332: MINUS
56333: PUSH
56334: LD_INT 1
56336: PLUS
56337: PPUSH
56338: LD_VAR 0 9
56342: PUSH
56343: LD_VAR 0 7
56347: ARRAY
56348: PPUSH
56349: CALL_OW 1
56353: ST_TO_ADDR
56354: GO 56310
56356: POP
56357: POP
// end ; tmp := [ ] ;
56358: LD_ADDR_VAR 0 9
56362: PUSH
56363: EMPTY
56364: ST_TO_ADDR
// if mode then
56365: LD_VAR 0 5
56369: IFFALSE 56438
// begin for i = 1 to result do
56371: LD_ADDR_VAR 0 7
56375: PUSH
56376: DOUBLE
56377: LD_INT 1
56379: DEC
56380: ST_TO_ADDR
56381: LD_VAR 0 6
56385: PUSH
56386: FOR_TO
56387: IFFALSE 56426
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
56389: LD_ADDR_VAR 0 9
56393: PUSH
56394: LD_VAR 0 9
56398: PPUSH
56399: LD_VAR 0 7
56403: PPUSH
56404: LD_VAR 0 6
56408: PUSH
56409: LD_VAR 0 7
56413: ARRAY
56414: PUSH
56415: LD_INT 1
56417: ARRAY
56418: PPUSH
56419: CALL_OW 1
56423: ST_TO_ADDR
56424: GO 56386
56426: POP
56427: POP
// result := tmp ;
56428: LD_ADDR_VAR 0 6
56432: PUSH
56433: LD_VAR 0 9
56437: ST_TO_ADDR
// end ; end ;
56438: LD_VAR 0 6
56442: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
56443: LD_INT 0
56445: PPUSH
56446: PPUSH
56447: PPUSH
56448: PPUSH
56449: PPUSH
56450: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
56451: LD_ADDR_VAR 0 5
56455: PUSH
56456: LD_INT 0
56458: PUSH
56459: LD_INT 0
56461: PUSH
56462: LD_INT 0
56464: PUSH
56465: EMPTY
56466: PUSH
56467: EMPTY
56468: LIST
56469: LIST
56470: LIST
56471: LIST
56472: ST_TO_ADDR
// if not x or not y then
56473: LD_VAR 0 2
56477: NOT
56478: PUSH
56479: LD_VAR 0 3
56483: NOT
56484: OR
56485: IFFALSE 56489
// exit ;
56487: GO 58135
// if not range then
56489: LD_VAR 0 4
56493: NOT
56494: IFFALSE 56504
// range := 10 ;
56496: LD_ADDR_VAR 0 4
56500: PUSH
56501: LD_INT 10
56503: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
56504: LD_ADDR_VAR 0 8
56508: PUSH
56509: LD_INT 81
56511: PUSH
56512: LD_VAR 0 1
56516: PUSH
56517: EMPTY
56518: LIST
56519: LIST
56520: PUSH
56521: LD_INT 92
56523: PUSH
56524: LD_VAR 0 2
56528: PUSH
56529: LD_VAR 0 3
56533: PUSH
56534: LD_VAR 0 4
56538: PUSH
56539: EMPTY
56540: LIST
56541: LIST
56542: LIST
56543: LIST
56544: PUSH
56545: LD_INT 3
56547: PUSH
56548: LD_INT 21
56550: PUSH
56551: LD_INT 3
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: PUSH
56558: EMPTY
56559: LIST
56560: LIST
56561: PUSH
56562: EMPTY
56563: LIST
56564: LIST
56565: LIST
56566: PPUSH
56567: CALL_OW 69
56571: ST_TO_ADDR
// if not tmp then
56572: LD_VAR 0 8
56576: NOT
56577: IFFALSE 56581
// exit ;
56579: GO 58135
// for i in tmp do
56581: LD_ADDR_VAR 0 6
56585: PUSH
56586: LD_VAR 0 8
56590: PUSH
56591: FOR_IN
56592: IFFALSE 58110
// begin points := [ 0 , 0 , 0 ] ;
56594: LD_ADDR_VAR 0 9
56598: PUSH
56599: LD_INT 0
56601: PUSH
56602: LD_INT 0
56604: PUSH
56605: LD_INT 0
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: LIST
56612: ST_TO_ADDR
// bpoints := 1 ;
56613: LD_ADDR_VAR 0 10
56617: PUSH
56618: LD_INT 1
56620: ST_TO_ADDR
// case GetType ( i ) of unit_human :
56621: LD_VAR 0 6
56625: PPUSH
56626: CALL_OW 247
56630: PUSH
56631: LD_INT 1
56633: DOUBLE
56634: EQUAL
56635: IFTRUE 56639
56637: GO 57217
56639: POP
// begin if GetClass ( i ) = 1 then
56640: LD_VAR 0 6
56644: PPUSH
56645: CALL_OW 257
56649: PUSH
56650: LD_INT 1
56652: EQUAL
56653: IFFALSE 56674
// points := [ 10 , 5 , 3 ] ;
56655: LD_ADDR_VAR 0 9
56659: PUSH
56660: LD_INT 10
56662: PUSH
56663: LD_INT 5
56665: PUSH
56666: LD_INT 3
56668: PUSH
56669: EMPTY
56670: LIST
56671: LIST
56672: LIST
56673: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
56674: LD_VAR 0 6
56678: PPUSH
56679: CALL_OW 257
56683: PUSH
56684: LD_INT 2
56686: PUSH
56687: LD_INT 3
56689: PUSH
56690: LD_INT 4
56692: PUSH
56693: EMPTY
56694: LIST
56695: LIST
56696: LIST
56697: IN
56698: IFFALSE 56719
// points := [ 3 , 2 , 1 ] ;
56700: LD_ADDR_VAR 0 9
56704: PUSH
56705: LD_INT 3
56707: PUSH
56708: LD_INT 2
56710: PUSH
56711: LD_INT 1
56713: PUSH
56714: EMPTY
56715: LIST
56716: LIST
56717: LIST
56718: ST_TO_ADDR
// if GetClass ( i ) = 5 then
56719: LD_VAR 0 6
56723: PPUSH
56724: CALL_OW 257
56728: PUSH
56729: LD_INT 5
56731: EQUAL
56732: IFFALSE 56753
// points := [ 130 , 5 , 2 ] ;
56734: LD_ADDR_VAR 0 9
56738: PUSH
56739: LD_INT 130
56741: PUSH
56742: LD_INT 5
56744: PUSH
56745: LD_INT 2
56747: PUSH
56748: EMPTY
56749: LIST
56750: LIST
56751: LIST
56752: ST_TO_ADDR
// if GetClass ( i ) = 8 then
56753: LD_VAR 0 6
56757: PPUSH
56758: CALL_OW 257
56762: PUSH
56763: LD_INT 8
56765: EQUAL
56766: IFFALSE 56787
// points := [ 35 , 35 , 30 ] ;
56768: LD_ADDR_VAR 0 9
56772: PUSH
56773: LD_INT 35
56775: PUSH
56776: LD_INT 35
56778: PUSH
56779: LD_INT 30
56781: PUSH
56782: EMPTY
56783: LIST
56784: LIST
56785: LIST
56786: ST_TO_ADDR
// if GetClass ( i ) = 9 then
56787: LD_VAR 0 6
56791: PPUSH
56792: CALL_OW 257
56796: PUSH
56797: LD_INT 9
56799: EQUAL
56800: IFFALSE 56821
// points := [ 20 , 55 , 40 ] ;
56802: LD_ADDR_VAR 0 9
56806: PUSH
56807: LD_INT 20
56809: PUSH
56810: LD_INT 55
56812: PUSH
56813: LD_INT 40
56815: PUSH
56816: EMPTY
56817: LIST
56818: LIST
56819: LIST
56820: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
56821: LD_VAR 0 6
56825: PPUSH
56826: CALL_OW 257
56830: PUSH
56831: LD_INT 12
56833: PUSH
56834: LD_INT 16
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: IN
56841: IFFALSE 56862
// points := [ 5 , 3 , 2 ] ;
56843: LD_ADDR_VAR 0 9
56847: PUSH
56848: LD_INT 5
56850: PUSH
56851: LD_INT 3
56853: PUSH
56854: LD_INT 2
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: LIST
56861: ST_TO_ADDR
// if GetClass ( i ) = 17 then
56862: LD_VAR 0 6
56866: PPUSH
56867: CALL_OW 257
56871: PUSH
56872: LD_INT 17
56874: EQUAL
56875: IFFALSE 56896
// points := [ 100 , 50 , 75 ] ;
56877: LD_ADDR_VAR 0 9
56881: PUSH
56882: LD_INT 100
56884: PUSH
56885: LD_INT 50
56887: PUSH
56888: LD_INT 75
56890: PUSH
56891: EMPTY
56892: LIST
56893: LIST
56894: LIST
56895: ST_TO_ADDR
// if GetClass ( i ) = 15 then
56896: LD_VAR 0 6
56900: PPUSH
56901: CALL_OW 257
56905: PUSH
56906: LD_INT 15
56908: EQUAL
56909: IFFALSE 56930
// points := [ 10 , 5 , 3 ] ;
56911: LD_ADDR_VAR 0 9
56915: PUSH
56916: LD_INT 10
56918: PUSH
56919: LD_INT 5
56921: PUSH
56922: LD_INT 3
56924: PUSH
56925: EMPTY
56926: LIST
56927: LIST
56928: LIST
56929: ST_TO_ADDR
// if GetClass ( i ) = 14 then
56930: LD_VAR 0 6
56934: PPUSH
56935: CALL_OW 257
56939: PUSH
56940: LD_INT 14
56942: EQUAL
56943: IFFALSE 56964
// points := [ 10 , 0 , 0 ] ;
56945: LD_ADDR_VAR 0 9
56949: PUSH
56950: LD_INT 10
56952: PUSH
56953: LD_INT 0
56955: PUSH
56956: LD_INT 0
56958: PUSH
56959: EMPTY
56960: LIST
56961: LIST
56962: LIST
56963: ST_TO_ADDR
// if GetClass ( i ) = 11 then
56964: LD_VAR 0 6
56968: PPUSH
56969: CALL_OW 257
56973: PUSH
56974: LD_INT 11
56976: EQUAL
56977: IFFALSE 56998
// points := [ 30 , 10 , 5 ] ;
56979: LD_ADDR_VAR 0 9
56983: PUSH
56984: LD_INT 30
56986: PUSH
56987: LD_INT 10
56989: PUSH
56990: LD_INT 5
56992: PUSH
56993: EMPTY
56994: LIST
56995: LIST
56996: LIST
56997: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
56998: LD_VAR 0 1
57002: PPUSH
57003: LD_INT 5
57005: PPUSH
57006: CALL_OW 321
57010: PUSH
57011: LD_INT 2
57013: EQUAL
57014: IFFALSE 57031
// bpoints := bpoints * 1.8 ;
57016: LD_ADDR_VAR 0 10
57020: PUSH
57021: LD_VAR 0 10
57025: PUSH
57026: LD_REAL  1.80000000000000E+0000
57029: MUL
57030: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57031: LD_VAR 0 6
57035: PPUSH
57036: CALL_OW 257
57040: PUSH
57041: LD_INT 1
57043: PUSH
57044: LD_INT 2
57046: PUSH
57047: LD_INT 3
57049: PUSH
57050: LD_INT 4
57052: PUSH
57053: EMPTY
57054: LIST
57055: LIST
57056: LIST
57057: LIST
57058: IN
57059: PUSH
57060: LD_VAR 0 1
57064: PPUSH
57065: LD_INT 51
57067: PPUSH
57068: CALL_OW 321
57072: PUSH
57073: LD_INT 2
57075: EQUAL
57076: AND
57077: IFFALSE 57094
// bpoints := bpoints * 1.2 ;
57079: LD_ADDR_VAR 0 10
57083: PUSH
57084: LD_VAR 0 10
57088: PUSH
57089: LD_REAL  1.20000000000000E+0000
57092: MUL
57093: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57094: LD_VAR 0 6
57098: PPUSH
57099: CALL_OW 257
57103: PUSH
57104: LD_INT 5
57106: PUSH
57107: LD_INT 7
57109: PUSH
57110: LD_INT 9
57112: PUSH
57113: EMPTY
57114: LIST
57115: LIST
57116: LIST
57117: IN
57118: PUSH
57119: LD_VAR 0 1
57123: PPUSH
57124: LD_INT 52
57126: PPUSH
57127: CALL_OW 321
57131: PUSH
57132: LD_INT 2
57134: EQUAL
57135: AND
57136: IFFALSE 57153
// bpoints := bpoints * 1.5 ;
57138: LD_ADDR_VAR 0 10
57142: PUSH
57143: LD_VAR 0 10
57147: PUSH
57148: LD_REAL  1.50000000000000E+0000
57151: MUL
57152: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57153: LD_VAR 0 1
57157: PPUSH
57158: LD_INT 66
57160: PPUSH
57161: CALL_OW 321
57165: PUSH
57166: LD_INT 2
57168: EQUAL
57169: IFFALSE 57186
// bpoints := bpoints * 1.1 ;
57171: LD_ADDR_VAR 0 10
57175: PUSH
57176: LD_VAR 0 10
57180: PUSH
57181: LD_REAL  1.10000000000000E+0000
57184: MUL
57185: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57186: LD_ADDR_VAR 0 10
57190: PUSH
57191: LD_VAR 0 10
57195: PUSH
57196: LD_VAR 0 6
57200: PPUSH
57201: LD_INT 1
57203: PPUSH
57204: CALL_OW 259
57208: PUSH
57209: LD_REAL  1.15000000000000E+0000
57212: MUL
57213: MUL
57214: ST_TO_ADDR
// end ; unit_vehicle :
57215: GO 58039
57217: LD_INT 2
57219: DOUBLE
57220: EQUAL
57221: IFTRUE 57225
57223: GO 58027
57225: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57226: LD_VAR 0 6
57230: PPUSH
57231: CALL_OW 264
57235: PUSH
57236: LD_INT 2
57238: PUSH
57239: LD_INT 42
57241: PUSH
57242: LD_INT 24
57244: PUSH
57245: EMPTY
57246: LIST
57247: LIST
57248: LIST
57249: IN
57250: IFFALSE 57271
// points := [ 25 , 5 , 3 ] ;
57252: LD_ADDR_VAR 0 9
57256: PUSH
57257: LD_INT 25
57259: PUSH
57260: LD_INT 5
57262: PUSH
57263: LD_INT 3
57265: PUSH
57266: EMPTY
57267: LIST
57268: LIST
57269: LIST
57270: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57271: LD_VAR 0 6
57275: PPUSH
57276: CALL_OW 264
57280: PUSH
57281: LD_INT 4
57283: PUSH
57284: LD_INT 43
57286: PUSH
57287: LD_INT 25
57289: PUSH
57290: EMPTY
57291: LIST
57292: LIST
57293: LIST
57294: IN
57295: IFFALSE 57316
// points := [ 40 , 15 , 5 ] ;
57297: LD_ADDR_VAR 0 9
57301: PUSH
57302: LD_INT 40
57304: PUSH
57305: LD_INT 15
57307: PUSH
57308: LD_INT 5
57310: PUSH
57311: EMPTY
57312: LIST
57313: LIST
57314: LIST
57315: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
57316: LD_VAR 0 6
57320: PPUSH
57321: CALL_OW 264
57325: PUSH
57326: LD_INT 3
57328: PUSH
57329: LD_INT 23
57331: PUSH
57332: EMPTY
57333: LIST
57334: LIST
57335: IN
57336: IFFALSE 57357
// points := [ 7 , 25 , 8 ] ;
57338: LD_ADDR_VAR 0 9
57342: PUSH
57343: LD_INT 7
57345: PUSH
57346: LD_INT 25
57348: PUSH
57349: LD_INT 8
57351: PUSH
57352: EMPTY
57353: LIST
57354: LIST
57355: LIST
57356: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
57357: LD_VAR 0 6
57361: PPUSH
57362: CALL_OW 264
57366: PUSH
57367: LD_INT 5
57369: PUSH
57370: LD_INT 27
57372: PUSH
57373: LD_INT 44
57375: PUSH
57376: EMPTY
57377: LIST
57378: LIST
57379: LIST
57380: IN
57381: IFFALSE 57402
// points := [ 14 , 50 , 16 ] ;
57383: LD_ADDR_VAR 0 9
57387: PUSH
57388: LD_INT 14
57390: PUSH
57391: LD_INT 50
57393: PUSH
57394: LD_INT 16
57396: PUSH
57397: EMPTY
57398: LIST
57399: LIST
57400: LIST
57401: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
57402: LD_VAR 0 6
57406: PPUSH
57407: CALL_OW 264
57411: PUSH
57412: LD_INT 6
57414: PUSH
57415: LD_INT 46
57417: PUSH
57418: EMPTY
57419: LIST
57420: LIST
57421: IN
57422: IFFALSE 57443
// points := [ 32 , 120 , 70 ] ;
57424: LD_ADDR_VAR 0 9
57428: PUSH
57429: LD_INT 32
57431: PUSH
57432: LD_INT 120
57434: PUSH
57435: LD_INT 70
57437: PUSH
57438: EMPTY
57439: LIST
57440: LIST
57441: LIST
57442: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
57443: LD_VAR 0 6
57447: PPUSH
57448: CALL_OW 264
57452: PUSH
57453: LD_INT 7
57455: PUSH
57456: LD_INT 28
57458: PUSH
57459: LD_INT 45
57461: PUSH
57462: EMPTY
57463: LIST
57464: LIST
57465: LIST
57466: IN
57467: IFFALSE 57488
// points := [ 35 , 20 , 45 ] ;
57469: LD_ADDR_VAR 0 9
57473: PUSH
57474: LD_INT 35
57476: PUSH
57477: LD_INT 20
57479: PUSH
57480: LD_INT 45
57482: PUSH
57483: EMPTY
57484: LIST
57485: LIST
57486: LIST
57487: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
57488: LD_VAR 0 6
57492: PPUSH
57493: CALL_OW 264
57497: PUSH
57498: LD_INT 47
57500: PUSH
57501: EMPTY
57502: LIST
57503: IN
57504: IFFALSE 57525
// points := [ 67 , 45 , 75 ] ;
57506: LD_ADDR_VAR 0 9
57510: PUSH
57511: LD_INT 67
57513: PUSH
57514: LD_INT 45
57516: PUSH
57517: LD_INT 75
57519: PUSH
57520: EMPTY
57521: LIST
57522: LIST
57523: LIST
57524: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
57525: LD_VAR 0 6
57529: PPUSH
57530: CALL_OW 264
57534: PUSH
57535: LD_INT 26
57537: PUSH
57538: EMPTY
57539: LIST
57540: IN
57541: IFFALSE 57562
// points := [ 120 , 30 , 80 ] ;
57543: LD_ADDR_VAR 0 9
57547: PUSH
57548: LD_INT 120
57550: PUSH
57551: LD_INT 30
57553: PUSH
57554: LD_INT 80
57556: PUSH
57557: EMPTY
57558: LIST
57559: LIST
57560: LIST
57561: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
57562: LD_VAR 0 6
57566: PPUSH
57567: CALL_OW 264
57571: PUSH
57572: LD_INT 22
57574: PUSH
57575: EMPTY
57576: LIST
57577: IN
57578: IFFALSE 57599
// points := [ 40 , 1 , 1 ] ;
57580: LD_ADDR_VAR 0 9
57584: PUSH
57585: LD_INT 40
57587: PUSH
57588: LD_INT 1
57590: PUSH
57591: LD_INT 1
57593: PUSH
57594: EMPTY
57595: LIST
57596: LIST
57597: LIST
57598: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
57599: LD_VAR 0 6
57603: PPUSH
57604: CALL_OW 264
57608: PUSH
57609: LD_INT 29
57611: PUSH
57612: EMPTY
57613: LIST
57614: IN
57615: IFFALSE 57636
// points := [ 70 , 200 , 400 ] ;
57617: LD_ADDR_VAR 0 9
57621: PUSH
57622: LD_INT 70
57624: PUSH
57625: LD_INT 200
57627: PUSH
57628: LD_INT 400
57630: PUSH
57631: EMPTY
57632: LIST
57633: LIST
57634: LIST
57635: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
57636: LD_VAR 0 6
57640: PPUSH
57641: CALL_OW 264
57645: PUSH
57646: LD_INT 14
57648: PUSH
57649: LD_INT 53
57651: PUSH
57652: EMPTY
57653: LIST
57654: LIST
57655: IN
57656: IFFALSE 57677
// points := [ 40 , 10 , 20 ] ;
57658: LD_ADDR_VAR 0 9
57662: PUSH
57663: LD_INT 40
57665: PUSH
57666: LD_INT 10
57668: PUSH
57669: LD_INT 20
57671: PUSH
57672: EMPTY
57673: LIST
57674: LIST
57675: LIST
57676: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
57677: LD_VAR 0 6
57681: PPUSH
57682: CALL_OW 264
57686: PUSH
57687: LD_INT 9
57689: PUSH
57690: EMPTY
57691: LIST
57692: IN
57693: IFFALSE 57714
// points := [ 5 , 70 , 20 ] ;
57695: LD_ADDR_VAR 0 9
57699: PUSH
57700: LD_INT 5
57702: PUSH
57703: LD_INT 70
57705: PUSH
57706: LD_INT 20
57708: PUSH
57709: EMPTY
57710: LIST
57711: LIST
57712: LIST
57713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
57714: LD_VAR 0 6
57718: PPUSH
57719: CALL_OW 264
57723: PUSH
57724: LD_INT 10
57726: PUSH
57727: EMPTY
57728: LIST
57729: IN
57730: IFFALSE 57751
// points := [ 35 , 110 , 70 ] ;
57732: LD_ADDR_VAR 0 9
57736: PUSH
57737: LD_INT 35
57739: PUSH
57740: LD_INT 110
57742: PUSH
57743: LD_INT 70
57745: PUSH
57746: EMPTY
57747: LIST
57748: LIST
57749: LIST
57750: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
57751: LD_VAR 0 6
57755: PPUSH
57756: CALL_OW 265
57760: PUSH
57761: LD_INT 25
57763: EQUAL
57764: IFFALSE 57785
// points := [ 80 , 65 , 100 ] ;
57766: LD_ADDR_VAR 0 9
57770: PUSH
57771: LD_INT 80
57773: PUSH
57774: LD_INT 65
57776: PUSH
57777: LD_INT 100
57779: PUSH
57780: EMPTY
57781: LIST
57782: LIST
57783: LIST
57784: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
57785: LD_VAR 0 6
57789: PPUSH
57790: CALL_OW 263
57794: PUSH
57795: LD_INT 1
57797: EQUAL
57798: IFFALSE 57833
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
57800: LD_ADDR_VAR 0 10
57804: PUSH
57805: LD_VAR 0 10
57809: PUSH
57810: LD_VAR 0 6
57814: PPUSH
57815: CALL_OW 311
57819: PPUSH
57820: LD_INT 3
57822: PPUSH
57823: CALL_OW 259
57827: PUSH
57828: LD_INT 4
57830: MUL
57831: MUL
57832: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
57833: LD_VAR 0 6
57837: PPUSH
57838: CALL_OW 263
57842: PUSH
57843: LD_INT 2
57845: EQUAL
57846: IFFALSE 57897
// begin j := IsControledBy ( i ) ;
57848: LD_ADDR_VAR 0 7
57852: PUSH
57853: LD_VAR 0 6
57857: PPUSH
57858: CALL_OW 312
57862: ST_TO_ADDR
// if j then
57863: LD_VAR 0 7
57867: IFFALSE 57897
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
57869: LD_ADDR_VAR 0 10
57873: PUSH
57874: LD_VAR 0 10
57878: PUSH
57879: LD_VAR 0 7
57883: PPUSH
57884: LD_INT 3
57886: PPUSH
57887: CALL_OW 259
57891: PUSH
57892: LD_INT 3
57894: MUL
57895: MUL
57896: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
57897: LD_VAR 0 6
57901: PPUSH
57902: CALL_OW 264
57906: PUSH
57907: LD_INT 5
57909: PUSH
57910: LD_INT 6
57912: PUSH
57913: LD_INT 46
57915: PUSH
57916: LD_INT 44
57918: PUSH
57919: LD_INT 47
57921: PUSH
57922: LD_INT 45
57924: PUSH
57925: LD_INT 28
57927: PUSH
57928: LD_INT 7
57930: PUSH
57931: LD_INT 27
57933: PUSH
57934: LD_INT 29
57936: PUSH
57937: EMPTY
57938: LIST
57939: LIST
57940: LIST
57941: LIST
57942: LIST
57943: LIST
57944: LIST
57945: LIST
57946: LIST
57947: LIST
57948: IN
57949: PUSH
57950: LD_VAR 0 1
57954: PPUSH
57955: LD_INT 52
57957: PPUSH
57958: CALL_OW 321
57962: PUSH
57963: LD_INT 2
57965: EQUAL
57966: AND
57967: IFFALSE 57984
// bpoints := bpoints * 1.2 ;
57969: LD_ADDR_VAR 0 10
57973: PUSH
57974: LD_VAR 0 10
57978: PUSH
57979: LD_REAL  1.20000000000000E+0000
57982: MUL
57983: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
57984: LD_VAR 0 6
57988: PPUSH
57989: CALL_OW 264
57993: PUSH
57994: LD_INT 6
57996: PUSH
57997: LD_INT 46
57999: PUSH
58000: LD_INT 47
58002: PUSH
58003: EMPTY
58004: LIST
58005: LIST
58006: LIST
58007: IN
58008: IFFALSE 58025
// bpoints := bpoints * 1.2 ;
58010: LD_ADDR_VAR 0 10
58014: PUSH
58015: LD_VAR 0 10
58019: PUSH
58020: LD_REAL  1.20000000000000E+0000
58023: MUL
58024: ST_TO_ADDR
// end ; unit_building :
58025: GO 58039
58027: LD_INT 3
58029: DOUBLE
58030: EQUAL
58031: IFTRUE 58035
58033: GO 58038
58035: POP
// ; end ;
58036: GO 58039
58038: POP
// for j = 1 to 3 do
58039: LD_ADDR_VAR 0 7
58043: PUSH
58044: DOUBLE
58045: LD_INT 1
58047: DEC
58048: ST_TO_ADDR
58049: LD_INT 3
58051: PUSH
58052: FOR_TO
58053: IFFALSE 58106
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58055: LD_ADDR_VAR 0 5
58059: PUSH
58060: LD_VAR 0 5
58064: PPUSH
58065: LD_VAR 0 7
58069: PPUSH
58070: LD_VAR 0 5
58074: PUSH
58075: LD_VAR 0 7
58079: ARRAY
58080: PUSH
58081: LD_VAR 0 9
58085: PUSH
58086: LD_VAR 0 7
58090: ARRAY
58091: PUSH
58092: LD_VAR 0 10
58096: MUL
58097: PLUS
58098: PPUSH
58099: CALL_OW 1
58103: ST_TO_ADDR
58104: GO 58052
58106: POP
58107: POP
// end ;
58108: GO 56591
58110: POP
58111: POP
// result := Replace ( result , 4 , tmp ) ;
58112: LD_ADDR_VAR 0 5
58116: PUSH
58117: LD_VAR 0 5
58121: PPUSH
58122: LD_INT 4
58124: PPUSH
58125: LD_VAR 0 8
58129: PPUSH
58130: CALL_OW 1
58134: ST_TO_ADDR
// end ;
58135: LD_VAR 0 5
58139: RET
// export function DangerAtRange ( unit , range ) ; begin
58140: LD_INT 0
58142: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58143: LD_ADDR_VAR 0 3
58147: PUSH
58148: LD_VAR 0 1
58152: PPUSH
58153: CALL_OW 255
58157: PPUSH
58158: LD_VAR 0 1
58162: PPUSH
58163: CALL_OW 250
58167: PPUSH
58168: LD_VAR 0 1
58172: PPUSH
58173: CALL_OW 251
58177: PPUSH
58178: LD_VAR 0 2
58182: PPUSH
58183: CALL 56443 0 4
58187: ST_TO_ADDR
// end ;
58188: LD_VAR 0 3
58192: RET
// export function DangerInArea ( side , area ) ; begin
58193: LD_INT 0
58195: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58196: LD_ADDR_VAR 0 3
58200: PUSH
58201: LD_VAR 0 2
58205: PPUSH
58206: LD_INT 81
58208: PUSH
58209: LD_VAR 0 1
58213: PUSH
58214: EMPTY
58215: LIST
58216: LIST
58217: PPUSH
58218: CALL_OW 70
58222: ST_TO_ADDR
// end ;
58223: LD_VAR 0 3
58227: RET
// export function IsExtension ( b ) ; begin
58228: LD_INT 0
58230: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58231: LD_ADDR_VAR 0 2
58235: PUSH
58236: LD_VAR 0 1
58240: PUSH
58241: LD_INT 23
58243: PUSH
58244: LD_INT 20
58246: PUSH
58247: LD_INT 22
58249: PUSH
58250: LD_INT 17
58252: PUSH
58253: LD_INT 24
58255: PUSH
58256: LD_INT 21
58258: PUSH
58259: LD_INT 19
58261: PUSH
58262: LD_INT 16
58264: PUSH
58265: LD_INT 25
58267: PUSH
58268: LD_INT 18
58270: PUSH
58271: EMPTY
58272: LIST
58273: LIST
58274: LIST
58275: LIST
58276: LIST
58277: LIST
58278: LIST
58279: LIST
58280: LIST
58281: LIST
58282: IN
58283: ST_TO_ADDR
// end ;
58284: LD_VAR 0 2
58288: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
58289: LD_INT 0
58291: PPUSH
58292: PPUSH
58293: PPUSH
// result := [ ] ;
58294: LD_ADDR_VAR 0 3
58298: PUSH
58299: EMPTY
58300: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
58301: LD_ADDR_VAR 0 4
58305: PUSH
58306: LD_VAR 0 2
58310: PPUSH
58311: LD_INT 21
58313: PUSH
58314: LD_INT 3
58316: PUSH
58317: EMPTY
58318: LIST
58319: LIST
58320: PPUSH
58321: CALL_OW 70
58325: ST_TO_ADDR
// if not tmp then
58326: LD_VAR 0 4
58330: NOT
58331: IFFALSE 58335
// exit ;
58333: GO 58393
// for i in tmp do
58335: LD_ADDR_VAR 0 5
58339: PUSH
58340: LD_VAR 0 4
58344: PUSH
58345: FOR_IN
58346: IFFALSE 58381
// if GetBase ( i ) <> base then
58348: LD_VAR 0 5
58352: PPUSH
58353: CALL_OW 274
58357: PUSH
58358: LD_VAR 0 1
58362: NONEQUAL
58363: IFFALSE 58379
// ComLinkToBase ( base , i ) ;
58365: LD_VAR 0 1
58369: PPUSH
58370: LD_VAR 0 5
58374: PPUSH
58375: CALL_OW 169
58379: GO 58345
58381: POP
58382: POP
// result := tmp ;
58383: LD_ADDR_VAR 0 3
58387: PUSH
58388: LD_VAR 0 4
58392: ST_TO_ADDR
// end ;
58393: LD_VAR 0 3
58397: RET
// export function ComComplete ( unit , b ) ; var i ; begin
58398: LD_INT 0
58400: PPUSH
58401: PPUSH
// if BuildingStatus ( b ) = bs_build then
58402: LD_VAR 0 2
58406: PPUSH
58407: CALL_OW 461
58411: PUSH
58412: LD_INT 1
58414: EQUAL
58415: IFFALSE 58475
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
58417: LD_VAR 0 1
58421: PPUSH
58422: LD_STRING h
58424: PUSH
58425: LD_VAR 0 2
58429: PPUSH
58430: CALL_OW 250
58434: PUSH
58435: LD_VAR 0 2
58439: PPUSH
58440: CALL_OW 251
58444: PUSH
58445: LD_VAR 0 2
58449: PUSH
58450: LD_INT 0
58452: PUSH
58453: LD_INT 0
58455: PUSH
58456: LD_INT 0
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: LIST
58463: LIST
58464: LIST
58465: LIST
58466: LIST
58467: PUSH
58468: EMPTY
58469: LIST
58470: PPUSH
58471: CALL_OW 446
// end ;
58475: LD_VAR 0 3
58479: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
58480: LD_INT 0
58482: PPUSH
58483: PPUSH
58484: PPUSH
58485: PPUSH
58486: PPUSH
58487: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
58488: LD_VAR 0 1
58492: NOT
58493: PUSH
58494: LD_VAR 0 1
58498: PPUSH
58499: CALL_OW 263
58503: PUSH
58504: LD_INT 2
58506: EQUAL
58507: NOT
58508: OR
58509: IFFALSE 58513
// exit ;
58511: GO 58829
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
58513: LD_ADDR_VAR 0 6
58517: PUSH
58518: LD_INT 22
58520: PUSH
58521: LD_VAR 0 1
58525: PPUSH
58526: CALL_OW 255
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: PUSH
58535: LD_INT 2
58537: PUSH
58538: LD_INT 30
58540: PUSH
58541: LD_INT 36
58543: PUSH
58544: EMPTY
58545: LIST
58546: LIST
58547: PUSH
58548: LD_INT 34
58550: PUSH
58551: LD_INT 31
58553: PUSH
58554: EMPTY
58555: LIST
58556: LIST
58557: PUSH
58558: EMPTY
58559: LIST
58560: LIST
58561: LIST
58562: PUSH
58563: EMPTY
58564: LIST
58565: LIST
58566: PPUSH
58567: CALL_OW 69
58571: ST_TO_ADDR
// if not tmp then
58572: LD_VAR 0 6
58576: NOT
58577: IFFALSE 58581
// exit ;
58579: GO 58829
// result := [ ] ;
58581: LD_ADDR_VAR 0 2
58585: PUSH
58586: EMPTY
58587: ST_TO_ADDR
// for i in tmp do
58588: LD_ADDR_VAR 0 3
58592: PUSH
58593: LD_VAR 0 6
58597: PUSH
58598: FOR_IN
58599: IFFALSE 58670
// begin t := UnitsInside ( i ) ;
58601: LD_ADDR_VAR 0 4
58605: PUSH
58606: LD_VAR 0 3
58610: PPUSH
58611: CALL_OW 313
58615: ST_TO_ADDR
// if t then
58616: LD_VAR 0 4
58620: IFFALSE 58668
// for j in t do
58622: LD_ADDR_VAR 0 7
58626: PUSH
58627: LD_VAR 0 4
58631: PUSH
58632: FOR_IN
58633: IFFALSE 58666
// result := Insert ( result , result + 1 , j ) ;
58635: LD_ADDR_VAR 0 2
58639: PUSH
58640: LD_VAR 0 2
58644: PPUSH
58645: LD_VAR 0 2
58649: PUSH
58650: LD_INT 1
58652: PLUS
58653: PPUSH
58654: LD_VAR 0 7
58658: PPUSH
58659: CALL_OW 2
58663: ST_TO_ADDR
58664: GO 58632
58666: POP
58667: POP
// end ;
58668: GO 58598
58670: POP
58671: POP
// if not result then
58672: LD_VAR 0 2
58676: NOT
58677: IFFALSE 58681
// exit ;
58679: GO 58829
// mech := result [ 1 ] ;
58681: LD_ADDR_VAR 0 5
58685: PUSH
58686: LD_VAR 0 2
58690: PUSH
58691: LD_INT 1
58693: ARRAY
58694: ST_TO_ADDR
// if result > 1 then
58695: LD_VAR 0 2
58699: PUSH
58700: LD_INT 1
58702: GREATER
58703: IFFALSE 58815
// for i = 2 to result do
58705: LD_ADDR_VAR 0 3
58709: PUSH
58710: DOUBLE
58711: LD_INT 2
58713: DEC
58714: ST_TO_ADDR
58715: LD_VAR 0 2
58719: PUSH
58720: FOR_TO
58721: IFFALSE 58813
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
58723: LD_ADDR_VAR 0 4
58727: PUSH
58728: LD_VAR 0 2
58732: PUSH
58733: LD_VAR 0 3
58737: ARRAY
58738: PPUSH
58739: LD_INT 3
58741: PPUSH
58742: CALL_OW 259
58746: PUSH
58747: LD_VAR 0 2
58751: PUSH
58752: LD_VAR 0 3
58756: ARRAY
58757: PPUSH
58758: CALL_OW 432
58762: MINUS
58763: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
58764: LD_VAR 0 4
58768: PUSH
58769: LD_VAR 0 5
58773: PPUSH
58774: LD_INT 3
58776: PPUSH
58777: CALL_OW 259
58781: PUSH
58782: LD_VAR 0 5
58786: PPUSH
58787: CALL_OW 432
58791: MINUS
58792: GREATEREQUAL
58793: IFFALSE 58811
// mech := result [ i ] ;
58795: LD_ADDR_VAR 0 5
58799: PUSH
58800: LD_VAR 0 2
58804: PUSH
58805: LD_VAR 0 3
58809: ARRAY
58810: ST_TO_ADDR
// end ;
58811: GO 58720
58813: POP
58814: POP
// ComLinkTo ( vehicle , mech ) ;
58815: LD_VAR 0 1
58819: PPUSH
58820: LD_VAR 0 5
58824: PPUSH
58825: CALL_OW 135
// end ;
58829: LD_VAR 0 2
58833: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
58834: LD_INT 0
58836: PPUSH
58837: PPUSH
58838: PPUSH
58839: PPUSH
58840: PPUSH
58841: PPUSH
58842: PPUSH
58843: PPUSH
58844: PPUSH
58845: PPUSH
58846: PPUSH
58847: PPUSH
58848: PPUSH
// result := [ ] ;
58849: LD_ADDR_VAR 0 7
58853: PUSH
58854: EMPTY
58855: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
58856: LD_VAR 0 1
58860: PPUSH
58861: CALL_OW 266
58865: PUSH
58866: LD_INT 0
58868: PUSH
58869: LD_INT 1
58871: PUSH
58872: EMPTY
58873: LIST
58874: LIST
58875: IN
58876: NOT
58877: IFFALSE 58881
// exit ;
58879: GO 60512
// if name then
58881: LD_VAR 0 3
58885: IFFALSE 58901
// SetBName ( base_dep , name ) ;
58887: LD_VAR 0 1
58891: PPUSH
58892: LD_VAR 0 3
58896: PPUSH
58897: CALL_OW 500
// base := GetBase ( base_dep ) ;
58901: LD_ADDR_VAR 0 15
58905: PUSH
58906: LD_VAR 0 1
58910: PPUSH
58911: CALL_OW 274
58915: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
58916: LD_ADDR_VAR 0 16
58920: PUSH
58921: LD_VAR 0 1
58925: PPUSH
58926: CALL_OW 255
58930: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
58931: LD_ADDR_VAR 0 17
58935: PUSH
58936: LD_VAR 0 1
58940: PPUSH
58941: CALL_OW 248
58945: ST_TO_ADDR
// if sources then
58946: LD_VAR 0 5
58950: IFFALSE 58997
// for i = 1 to 3 do
58952: LD_ADDR_VAR 0 8
58956: PUSH
58957: DOUBLE
58958: LD_INT 1
58960: DEC
58961: ST_TO_ADDR
58962: LD_INT 3
58964: PUSH
58965: FOR_TO
58966: IFFALSE 58995
// AddResourceType ( base , i , sources [ i ] ) ;
58968: LD_VAR 0 15
58972: PPUSH
58973: LD_VAR 0 8
58977: PPUSH
58978: LD_VAR 0 5
58982: PUSH
58983: LD_VAR 0 8
58987: ARRAY
58988: PPUSH
58989: CALL_OW 276
58993: GO 58965
58995: POP
58996: POP
// buildings := GetBaseBuildings ( base , area ) ;
58997: LD_ADDR_VAR 0 18
59001: PUSH
59002: LD_VAR 0 15
59006: PPUSH
59007: LD_VAR 0 2
59011: PPUSH
59012: CALL 58289 0 2
59016: ST_TO_ADDR
// InitHc ;
59017: CALL_OW 19
// InitUc ;
59021: CALL_OW 18
// uc_side := side ;
59025: LD_ADDR_OWVAR 20
59029: PUSH
59030: LD_VAR 0 16
59034: ST_TO_ADDR
// uc_nation := nation ;
59035: LD_ADDR_OWVAR 21
59039: PUSH
59040: LD_VAR 0 17
59044: ST_TO_ADDR
// if buildings then
59045: LD_VAR 0 18
59049: IFFALSE 60371
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59051: LD_ADDR_VAR 0 19
59055: PUSH
59056: LD_VAR 0 18
59060: PPUSH
59061: LD_INT 2
59063: PUSH
59064: LD_INT 30
59066: PUSH
59067: LD_INT 29
59069: PUSH
59070: EMPTY
59071: LIST
59072: LIST
59073: PUSH
59074: LD_INT 30
59076: PUSH
59077: LD_INT 30
59079: PUSH
59080: EMPTY
59081: LIST
59082: LIST
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: LIST
59088: PPUSH
59089: CALL_OW 72
59093: ST_TO_ADDR
// if tmp then
59094: LD_VAR 0 19
59098: IFFALSE 59146
// for i in tmp do
59100: LD_ADDR_VAR 0 8
59104: PUSH
59105: LD_VAR 0 19
59109: PUSH
59110: FOR_IN
59111: IFFALSE 59144
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59113: LD_VAR 0 8
59117: PPUSH
59118: CALL_OW 250
59122: PPUSH
59123: LD_VAR 0 8
59127: PPUSH
59128: CALL_OW 251
59132: PPUSH
59133: LD_VAR 0 16
59137: PPUSH
59138: CALL_OW 441
59142: GO 59110
59144: POP
59145: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59146: LD_VAR 0 18
59150: PPUSH
59151: LD_INT 2
59153: PUSH
59154: LD_INT 30
59156: PUSH
59157: LD_INT 32
59159: PUSH
59160: EMPTY
59161: LIST
59162: LIST
59163: PUSH
59164: LD_INT 30
59166: PUSH
59167: LD_INT 33
59169: PUSH
59170: EMPTY
59171: LIST
59172: LIST
59173: PUSH
59174: EMPTY
59175: LIST
59176: LIST
59177: LIST
59178: PPUSH
59179: CALL_OW 72
59183: IFFALSE 59271
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59185: LD_ADDR_VAR 0 8
59189: PUSH
59190: LD_VAR 0 18
59194: PPUSH
59195: LD_INT 2
59197: PUSH
59198: LD_INT 30
59200: PUSH
59201: LD_INT 32
59203: PUSH
59204: EMPTY
59205: LIST
59206: LIST
59207: PUSH
59208: LD_INT 30
59210: PUSH
59211: LD_INT 33
59213: PUSH
59214: EMPTY
59215: LIST
59216: LIST
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: LIST
59222: PPUSH
59223: CALL_OW 72
59227: PUSH
59228: FOR_IN
59229: IFFALSE 59269
// begin if not GetBWeapon ( i ) then
59231: LD_VAR 0 8
59235: PPUSH
59236: CALL_OW 269
59240: NOT
59241: IFFALSE 59267
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
59243: LD_VAR 0 8
59247: PPUSH
59248: LD_VAR 0 8
59252: PPUSH
59253: LD_VAR 0 2
59257: PPUSH
59258: CALL 60517 0 2
59262: PPUSH
59263: CALL_OW 431
// end ;
59267: GO 59228
59269: POP
59270: POP
// end ; for i = 1 to personel do
59271: LD_ADDR_VAR 0 8
59275: PUSH
59276: DOUBLE
59277: LD_INT 1
59279: DEC
59280: ST_TO_ADDR
59281: LD_VAR 0 6
59285: PUSH
59286: FOR_TO
59287: IFFALSE 60351
// begin if i > 4 then
59289: LD_VAR 0 8
59293: PUSH
59294: LD_INT 4
59296: GREATER
59297: IFFALSE 59301
// break ;
59299: GO 60351
// case i of 1 :
59301: LD_VAR 0 8
59305: PUSH
59306: LD_INT 1
59308: DOUBLE
59309: EQUAL
59310: IFTRUE 59314
59312: GO 59394
59314: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
59315: LD_ADDR_VAR 0 12
59319: PUSH
59320: LD_VAR 0 18
59324: PPUSH
59325: LD_INT 22
59327: PUSH
59328: LD_VAR 0 16
59332: PUSH
59333: EMPTY
59334: LIST
59335: LIST
59336: PUSH
59337: LD_INT 58
59339: PUSH
59340: EMPTY
59341: LIST
59342: PUSH
59343: LD_INT 2
59345: PUSH
59346: LD_INT 30
59348: PUSH
59349: LD_INT 32
59351: PUSH
59352: EMPTY
59353: LIST
59354: LIST
59355: PUSH
59356: LD_INT 30
59358: PUSH
59359: LD_INT 4
59361: PUSH
59362: EMPTY
59363: LIST
59364: LIST
59365: PUSH
59366: LD_INT 30
59368: PUSH
59369: LD_INT 5
59371: PUSH
59372: EMPTY
59373: LIST
59374: LIST
59375: PUSH
59376: EMPTY
59377: LIST
59378: LIST
59379: LIST
59380: LIST
59381: PUSH
59382: EMPTY
59383: LIST
59384: LIST
59385: LIST
59386: PPUSH
59387: CALL_OW 72
59391: ST_TO_ADDR
59392: GO 59616
59394: LD_INT 2
59396: DOUBLE
59397: EQUAL
59398: IFTRUE 59402
59400: GO 59464
59402: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
59403: LD_ADDR_VAR 0 12
59407: PUSH
59408: LD_VAR 0 18
59412: PPUSH
59413: LD_INT 22
59415: PUSH
59416: LD_VAR 0 16
59420: PUSH
59421: EMPTY
59422: LIST
59423: LIST
59424: PUSH
59425: LD_INT 2
59427: PUSH
59428: LD_INT 30
59430: PUSH
59431: LD_INT 0
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: PUSH
59438: LD_INT 30
59440: PUSH
59441: LD_INT 1
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: LIST
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PPUSH
59457: CALL_OW 72
59461: ST_TO_ADDR
59462: GO 59616
59464: LD_INT 3
59466: DOUBLE
59467: EQUAL
59468: IFTRUE 59472
59470: GO 59534
59472: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
59473: LD_ADDR_VAR 0 12
59477: PUSH
59478: LD_VAR 0 18
59482: PPUSH
59483: LD_INT 22
59485: PUSH
59486: LD_VAR 0 16
59490: PUSH
59491: EMPTY
59492: LIST
59493: LIST
59494: PUSH
59495: LD_INT 2
59497: PUSH
59498: LD_INT 30
59500: PUSH
59501: LD_INT 2
59503: PUSH
59504: EMPTY
59505: LIST
59506: LIST
59507: PUSH
59508: LD_INT 30
59510: PUSH
59511: LD_INT 3
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: LIST
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: PPUSH
59527: CALL_OW 72
59531: ST_TO_ADDR
59532: GO 59616
59534: LD_INT 4
59536: DOUBLE
59537: EQUAL
59538: IFTRUE 59542
59540: GO 59615
59542: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
59543: LD_ADDR_VAR 0 12
59547: PUSH
59548: LD_VAR 0 18
59552: PPUSH
59553: LD_INT 22
59555: PUSH
59556: LD_VAR 0 16
59560: PUSH
59561: EMPTY
59562: LIST
59563: LIST
59564: PUSH
59565: LD_INT 2
59567: PUSH
59568: LD_INT 30
59570: PUSH
59571: LD_INT 6
59573: PUSH
59574: EMPTY
59575: LIST
59576: LIST
59577: PUSH
59578: LD_INT 30
59580: PUSH
59581: LD_INT 7
59583: PUSH
59584: EMPTY
59585: LIST
59586: LIST
59587: PUSH
59588: LD_INT 30
59590: PUSH
59591: LD_INT 8
59593: PUSH
59594: EMPTY
59595: LIST
59596: LIST
59597: PUSH
59598: EMPTY
59599: LIST
59600: LIST
59601: LIST
59602: LIST
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: PPUSH
59608: CALL_OW 72
59612: ST_TO_ADDR
59613: GO 59616
59615: POP
// if i = 1 then
59616: LD_VAR 0 8
59620: PUSH
59621: LD_INT 1
59623: EQUAL
59624: IFFALSE 59735
// begin tmp := [ ] ;
59626: LD_ADDR_VAR 0 19
59630: PUSH
59631: EMPTY
59632: ST_TO_ADDR
// for j in f do
59633: LD_ADDR_VAR 0 9
59637: PUSH
59638: LD_VAR 0 12
59642: PUSH
59643: FOR_IN
59644: IFFALSE 59717
// if GetBType ( j ) = b_bunker then
59646: LD_VAR 0 9
59650: PPUSH
59651: CALL_OW 266
59655: PUSH
59656: LD_INT 32
59658: EQUAL
59659: IFFALSE 59686
// tmp := Insert ( tmp , 1 , j ) else
59661: LD_ADDR_VAR 0 19
59665: PUSH
59666: LD_VAR 0 19
59670: PPUSH
59671: LD_INT 1
59673: PPUSH
59674: LD_VAR 0 9
59678: PPUSH
59679: CALL_OW 2
59683: ST_TO_ADDR
59684: GO 59715
// tmp := Insert ( tmp , tmp + 1 , j ) ;
59686: LD_ADDR_VAR 0 19
59690: PUSH
59691: LD_VAR 0 19
59695: PPUSH
59696: LD_VAR 0 19
59700: PUSH
59701: LD_INT 1
59703: PLUS
59704: PPUSH
59705: LD_VAR 0 9
59709: PPUSH
59710: CALL_OW 2
59714: ST_TO_ADDR
59715: GO 59643
59717: POP
59718: POP
// if tmp then
59719: LD_VAR 0 19
59723: IFFALSE 59735
// f := tmp ;
59725: LD_ADDR_VAR 0 12
59729: PUSH
59730: LD_VAR 0 19
59734: ST_TO_ADDR
// end ; x := personel [ i ] ;
59735: LD_ADDR_VAR 0 13
59739: PUSH
59740: LD_VAR 0 6
59744: PUSH
59745: LD_VAR 0 8
59749: ARRAY
59750: ST_TO_ADDR
// if x = - 1 then
59751: LD_VAR 0 13
59755: PUSH
59756: LD_INT 1
59758: NEG
59759: EQUAL
59760: IFFALSE 59969
// begin for j in f do
59762: LD_ADDR_VAR 0 9
59766: PUSH
59767: LD_VAR 0 12
59771: PUSH
59772: FOR_IN
59773: IFFALSE 59965
// repeat InitHc ;
59775: CALL_OW 19
// if GetBType ( j ) = b_barracks then
59779: LD_VAR 0 9
59783: PPUSH
59784: CALL_OW 266
59788: PUSH
59789: LD_INT 5
59791: EQUAL
59792: IFFALSE 59862
// begin if UnitsInside ( j ) < 3 then
59794: LD_VAR 0 9
59798: PPUSH
59799: CALL_OW 313
59803: PUSH
59804: LD_INT 3
59806: LESS
59807: IFFALSE 59843
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59809: LD_INT 0
59811: PPUSH
59812: LD_INT 5
59814: PUSH
59815: LD_INT 8
59817: PUSH
59818: LD_INT 9
59820: PUSH
59821: EMPTY
59822: LIST
59823: LIST
59824: LIST
59825: PUSH
59826: LD_VAR 0 17
59830: ARRAY
59831: PPUSH
59832: LD_VAR 0 4
59836: PPUSH
59837: CALL_OW 380
59841: GO 59860
// PrepareHuman ( false , i , skill ) ;
59843: LD_INT 0
59845: PPUSH
59846: LD_VAR 0 8
59850: PPUSH
59851: LD_VAR 0 4
59855: PPUSH
59856: CALL_OW 380
// end else
59860: GO 59879
// PrepareHuman ( false , i , skill ) ;
59862: LD_INT 0
59864: PPUSH
59865: LD_VAR 0 8
59869: PPUSH
59870: LD_VAR 0 4
59874: PPUSH
59875: CALL_OW 380
// un := CreateHuman ;
59879: LD_ADDR_VAR 0 14
59883: PUSH
59884: CALL_OW 44
59888: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59889: LD_ADDR_VAR 0 7
59893: PUSH
59894: LD_VAR 0 7
59898: PPUSH
59899: LD_INT 1
59901: PPUSH
59902: LD_VAR 0 14
59906: PPUSH
59907: CALL_OW 2
59911: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
59912: LD_VAR 0 14
59916: PPUSH
59917: LD_VAR 0 9
59921: PPUSH
59922: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
59926: LD_VAR 0 9
59930: PPUSH
59931: CALL_OW 313
59935: PUSH
59936: LD_INT 6
59938: EQUAL
59939: PUSH
59940: LD_VAR 0 9
59944: PPUSH
59945: CALL_OW 266
59949: PUSH
59950: LD_INT 32
59952: PUSH
59953: LD_INT 31
59955: PUSH
59956: EMPTY
59957: LIST
59958: LIST
59959: IN
59960: OR
59961: IFFALSE 59775
59963: GO 59772
59965: POP
59966: POP
// end else
59967: GO 60349
// for j = 1 to x do
59969: LD_ADDR_VAR 0 9
59973: PUSH
59974: DOUBLE
59975: LD_INT 1
59977: DEC
59978: ST_TO_ADDR
59979: LD_VAR 0 13
59983: PUSH
59984: FOR_TO
59985: IFFALSE 60347
// begin InitHc ;
59987: CALL_OW 19
// if not f then
59991: LD_VAR 0 12
59995: NOT
59996: IFFALSE 60085
// begin PrepareHuman ( false , i , skill ) ;
59998: LD_INT 0
60000: PPUSH
60001: LD_VAR 0 8
60005: PPUSH
60006: LD_VAR 0 4
60010: PPUSH
60011: CALL_OW 380
// un := CreateHuman ;
60015: LD_ADDR_VAR 0 14
60019: PUSH
60020: CALL_OW 44
60024: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60025: LD_ADDR_VAR 0 7
60029: PUSH
60030: LD_VAR 0 7
60034: PPUSH
60035: LD_INT 1
60037: PPUSH
60038: LD_VAR 0 14
60042: PPUSH
60043: CALL_OW 2
60047: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60048: LD_VAR 0 14
60052: PPUSH
60053: LD_VAR 0 1
60057: PPUSH
60058: CALL_OW 250
60062: PPUSH
60063: LD_VAR 0 1
60067: PPUSH
60068: CALL_OW 251
60072: PPUSH
60073: LD_INT 10
60075: PPUSH
60076: LD_INT 0
60078: PPUSH
60079: CALL_OW 50
// continue ;
60083: GO 59984
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60085: LD_VAR 0 12
60089: PUSH
60090: LD_INT 1
60092: ARRAY
60093: PPUSH
60094: CALL_OW 313
60098: PUSH
60099: LD_VAR 0 12
60103: PUSH
60104: LD_INT 1
60106: ARRAY
60107: PPUSH
60108: CALL_OW 266
60112: PUSH
60113: LD_INT 32
60115: PUSH
60116: LD_INT 31
60118: PUSH
60119: EMPTY
60120: LIST
60121: LIST
60122: IN
60123: AND
60124: PUSH
60125: LD_VAR 0 12
60129: PUSH
60130: LD_INT 1
60132: ARRAY
60133: PPUSH
60134: CALL_OW 313
60138: PUSH
60139: LD_INT 6
60141: EQUAL
60142: OR
60143: IFFALSE 60163
// f := Delete ( f , 1 ) ;
60145: LD_ADDR_VAR 0 12
60149: PUSH
60150: LD_VAR 0 12
60154: PPUSH
60155: LD_INT 1
60157: PPUSH
60158: CALL_OW 3
60162: ST_TO_ADDR
// if not f then
60163: LD_VAR 0 12
60167: NOT
60168: IFFALSE 60186
// begin x := x + 2 ;
60170: LD_ADDR_VAR 0 13
60174: PUSH
60175: LD_VAR 0 13
60179: PUSH
60180: LD_INT 2
60182: PLUS
60183: ST_TO_ADDR
// continue ;
60184: GO 59984
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60186: LD_VAR 0 12
60190: PUSH
60191: LD_INT 1
60193: ARRAY
60194: PPUSH
60195: CALL_OW 266
60199: PUSH
60200: LD_INT 5
60202: EQUAL
60203: IFFALSE 60277
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60205: LD_VAR 0 12
60209: PUSH
60210: LD_INT 1
60212: ARRAY
60213: PPUSH
60214: CALL_OW 313
60218: PUSH
60219: LD_INT 3
60221: LESS
60222: IFFALSE 60258
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60224: LD_INT 0
60226: PPUSH
60227: LD_INT 5
60229: PUSH
60230: LD_INT 8
60232: PUSH
60233: LD_INT 9
60235: PUSH
60236: EMPTY
60237: LIST
60238: LIST
60239: LIST
60240: PUSH
60241: LD_VAR 0 17
60245: ARRAY
60246: PPUSH
60247: LD_VAR 0 4
60251: PPUSH
60252: CALL_OW 380
60256: GO 60275
// PrepareHuman ( false , i , skill ) ;
60258: LD_INT 0
60260: PPUSH
60261: LD_VAR 0 8
60265: PPUSH
60266: LD_VAR 0 4
60270: PPUSH
60271: CALL_OW 380
// end else
60275: GO 60294
// PrepareHuman ( false , i , skill ) ;
60277: LD_INT 0
60279: PPUSH
60280: LD_VAR 0 8
60284: PPUSH
60285: LD_VAR 0 4
60289: PPUSH
60290: CALL_OW 380
// un := CreateHuman ;
60294: LD_ADDR_VAR 0 14
60298: PUSH
60299: CALL_OW 44
60303: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60304: LD_ADDR_VAR 0 7
60308: PUSH
60309: LD_VAR 0 7
60313: PPUSH
60314: LD_INT 1
60316: PPUSH
60317: LD_VAR 0 14
60321: PPUSH
60322: CALL_OW 2
60326: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
60327: LD_VAR 0 14
60331: PPUSH
60332: LD_VAR 0 12
60336: PUSH
60337: LD_INT 1
60339: ARRAY
60340: PPUSH
60341: CALL_OW 52
// end ;
60345: GO 59984
60347: POP
60348: POP
// end ;
60349: GO 59286
60351: POP
60352: POP
// result := result ^ buildings ;
60353: LD_ADDR_VAR 0 7
60357: PUSH
60358: LD_VAR 0 7
60362: PUSH
60363: LD_VAR 0 18
60367: ADD
60368: ST_TO_ADDR
// end else
60369: GO 60512
// begin for i = 1 to personel do
60371: LD_ADDR_VAR 0 8
60375: PUSH
60376: DOUBLE
60377: LD_INT 1
60379: DEC
60380: ST_TO_ADDR
60381: LD_VAR 0 6
60385: PUSH
60386: FOR_TO
60387: IFFALSE 60510
// begin if i > 4 then
60389: LD_VAR 0 8
60393: PUSH
60394: LD_INT 4
60396: GREATER
60397: IFFALSE 60401
// break ;
60399: GO 60510
// x := personel [ i ] ;
60401: LD_ADDR_VAR 0 13
60405: PUSH
60406: LD_VAR 0 6
60410: PUSH
60411: LD_VAR 0 8
60415: ARRAY
60416: ST_TO_ADDR
// if x = - 1 then
60417: LD_VAR 0 13
60421: PUSH
60422: LD_INT 1
60424: NEG
60425: EQUAL
60426: IFFALSE 60430
// continue ;
60428: GO 60386
// PrepareHuman ( false , i , skill ) ;
60430: LD_INT 0
60432: PPUSH
60433: LD_VAR 0 8
60437: PPUSH
60438: LD_VAR 0 4
60442: PPUSH
60443: CALL_OW 380
// un := CreateHuman ;
60447: LD_ADDR_VAR 0 14
60451: PUSH
60452: CALL_OW 44
60456: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60457: LD_VAR 0 14
60461: PPUSH
60462: LD_VAR 0 1
60466: PPUSH
60467: CALL_OW 250
60471: PPUSH
60472: LD_VAR 0 1
60476: PPUSH
60477: CALL_OW 251
60481: PPUSH
60482: LD_INT 10
60484: PPUSH
60485: LD_INT 0
60487: PPUSH
60488: CALL_OW 50
// result := result ^ un ;
60492: LD_ADDR_VAR 0 7
60496: PUSH
60497: LD_VAR 0 7
60501: PUSH
60502: LD_VAR 0 14
60506: ADD
60507: ST_TO_ADDR
// end ;
60508: GO 60386
60510: POP
60511: POP
// end ; end ;
60512: LD_VAR 0 7
60516: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
60517: LD_INT 0
60519: PPUSH
60520: PPUSH
60521: PPUSH
60522: PPUSH
60523: PPUSH
60524: PPUSH
60525: PPUSH
60526: PPUSH
60527: PPUSH
60528: PPUSH
60529: PPUSH
60530: PPUSH
60531: PPUSH
60532: PPUSH
60533: PPUSH
60534: PPUSH
// result := false ;
60535: LD_ADDR_VAR 0 3
60539: PUSH
60540: LD_INT 0
60542: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
60543: LD_VAR 0 1
60547: NOT
60548: PUSH
60549: LD_VAR 0 1
60553: PPUSH
60554: CALL_OW 266
60558: PUSH
60559: LD_INT 32
60561: PUSH
60562: LD_INT 33
60564: PUSH
60565: EMPTY
60566: LIST
60567: LIST
60568: IN
60569: NOT
60570: OR
60571: IFFALSE 60575
// exit ;
60573: GO 61711
// nat := GetNation ( tower ) ;
60575: LD_ADDR_VAR 0 12
60579: PUSH
60580: LD_VAR 0 1
60584: PPUSH
60585: CALL_OW 248
60589: ST_TO_ADDR
// side := GetSide ( tower ) ;
60590: LD_ADDR_VAR 0 16
60594: PUSH
60595: LD_VAR 0 1
60599: PPUSH
60600: CALL_OW 255
60604: ST_TO_ADDR
// x := GetX ( tower ) ;
60605: LD_ADDR_VAR 0 10
60609: PUSH
60610: LD_VAR 0 1
60614: PPUSH
60615: CALL_OW 250
60619: ST_TO_ADDR
// y := GetY ( tower ) ;
60620: LD_ADDR_VAR 0 11
60624: PUSH
60625: LD_VAR 0 1
60629: PPUSH
60630: CALL_OW 251
60634: ST_TO_ADDR
// if not x or not y then
60635: LD_VAR 0 10
60639: NOT
60640: PUSH
60641: LD_VAR 0 11
60645: NOT
60646: OR
60647: IFFALSE 60651
// exit ;
60649: GO 61711
// weapon := 0 ;
60651: LD_ADDR_VAR 0 18
60655: PUSH
60656: LD_INT 0
60658: ST_TO_ADDR
// fac_list := [ ] ;
60659: LD_ADDR_VAR 0 17
60663: PUSH
60664: EMPTY
60665: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
60666: LD_ADDR_VAR 0 6
60670: PUSH
60671: LD_VAR 0 1
60675: PPUSH
60676: CALL_OW 274
60680: PPUSH
60681: LD_VAR 0 2
60685: PPUSH
60686: CALL 58289 0 2
60690: PPUSH
60691: LD_INT 30
60693: PUSH
60694: LD_INT 3
60696: PUSH
60697: EMPTY
60698: LIST
60699: LIST
60700: PPUSH
60701: CALL_OW 72
60705: ST_TO_ADDR
// if not factories then
60706: LD_VAR 0 6
60710: NOT
60711: IFFALSE 60715
// exit ;
60713: GO 61711
// for i in factories do
60715: LD_ADDR_VAR 0 8
60719: PUSH
60720: LD_VAR 0 6
60724: PUSH
60725: FOR_IN
60726: IFFALSE 60751
// fac_list := fac_list union AvailableWeaponList ( i ) ;
60728: LD_ADDR_VAR 0 17
60732: PUSH
60733: LD_VAR 0 17
60737: PUSH
60738: LD_VAR 0 8
60742: PPUSH
60743: CALL_OW 478
60747: UNION
60748: ST_TO_ADDR
60749: GO 60725
60751: POP
60752: POP
// if not fac_list then
60753: LD_VAR 0 17
60757: NOT
60758: IFFALSE 60762
// exit ;
60760: GO 61711
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
60762: LD_ADDR_VAR 0 5
60766: PUSH
60767: LD_INT 4
60769: PUSH
60770: LD_INT 5
60772: PUSH
60773: LD_INT 9
60775: PUSH
60776: LD_INT 10
60778: PUSH
60779: LD_INT 6
60781: PUSH
60782: LD_INT 7
60784: PUSH
60785: LD_INT 11
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: LIST
60792: LIST
60793: LIST
60794: LIST
60795: LIST
60796: PUSH
60797: LD_INT 27
60799: PUSH
60800: LD_INT 28
60802: PUSH
60803: LD_INT 26
60805: PUSH
60806: LD_INT 30
60808: PUSH
60809: EMPTY
60810: LIST
60811: LIST
60812: LIST
60813: LIST
60814: PUSH
60815: LD_INT 43
60817: PUSH
60818: LD_INT 44
60820: PUSH
60821: LD_INT 46
60823: PUSH
60824: LD_INT 45
60826: PUSH
60827: LD_INT 47
60829: PUSH
60830: LD_INT 49
60832: PUSH
60833: EMPTY
60834: LIST
60835: LIST
60836: LIST
60837: LIST
60838: LIST
60839: LIST
60840: PUSH
60841: EMPTY
60842: LIST
60843: LIST
60844: LIST
60845: PUSH
60846: LD_VAR 0 12
60850: ARRAY
60851: ST_TO_ADDR
// for i in list do
60852: LD_ADDR_VAR 0 8
60856: PUSH
60857: LD_VAR 0 5
60861: PUSH
60862: FOR_IN
60863: IFFALSE 60896
// if not i in fac_list then
60865: LD_VAR 0 8
60869: PUSH
60870: LD_VAR 0 17
60874: IN
60875: NOT
60876: IFFALSE 60894
// list := list diff i ;
60878: LD_ADDR_VAR 0 5
60882: PUSH
60883: LD_VAR 0 5
60887: PUSH
60888: LD_VAR 0 8
60892: DIFF
60893: ST_TO_ADDR
60894: GO 60862
60896: POP
60897: POP
// if not list then
60898: LD_VAR 0 5
60902: NOT
60903: IFFALSE 60907
// exit ;
60905: GO 61711
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
60907: LD_VAR 0 12
60911: PUSH
60912: LD_INT 3
60914: EQUAL
60915: PUSH
60916: LD_INT 49
60918: PUSH
60919: LD_VAR 0 5
60923: IN
60924: AND
60925: PUSH
60926: LD_INT 31
60928: PPUSH
60929: LD_VAR 0 16
60933: PPUSH
60934: CALL_OW 321
60938: PUSH
60939: LD_INT 2
60941: EQUAL
60942: AND
60943: IFFALSE 61003
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
60945: LD_INT 22
60947: PUSH
60948: LD_VAR 0 16
60952: PUSH
60953: EMPTY
60954: LIST
60955: LIST
60956: PUSH
60957: LD_INT 35
60959: PUSH
60960: LD_INT 49
60962: PUSH
60963: EMPTY
60964: LIST
60965: LIST
60966: PUSH
60967: LD_INT 91
60969: PUSH
60970: LD_VAR 0 1
60974: PUSH
60975: LD_INT 10
60977: PUSH
60978: EMPTY
60979: LIST
60980: LIST
60981: LIST
60982: PUSH
60983: EMPTY
60984: LIST
60985: LIST
60986: LIST
60987: PPUSH
60988: CALL_OW 69
60992: NOT
60993: IFFALSE 61003
// weapon := ru_time_lapser ;
60995: LD_ADDR_VAR 0 18
60999: PUSH
61000: LD_INT 49
61002: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61003: LD_VAR 0 12
61007: PUSH
61008: LD_INT 1
61010: PUSH
61011: LD_INT 2
61013: PUSH
61014: EMPTY
61015: LIST
61016: LIST
61017: IN
61018: PUSH
61019: LD_INT 11
61021: PUSH
61022: LD_VAR 0 5
61026: IN
61027: PUSH
61028: LD_INT 30
61030: PUSH
61031: LD_VAR 0 5
61035: IN
61036: OR
61037: AND
61038: PUSH
61039: LD_INT 6
61041: PPUSH
61042: LD_VAR 0 16
61046: PPUSH
61047: CALL_OW 321
61051: PUSH
61052: LD_INT 2
61054: EQUAL
61055: AND
61056: IFFALSE 61221
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61058: LD_INT 22
61060: PUSH
61061: LD_VAR 0 16
61065: PUSH
61066: EMPTY
61067: LIST
61068: LIST
61069: PUSH
61070: LD_INT 2
61072: PUSH
61073: LD_INT 35
61075: PUSH
61076: LD_INT 11
61078: PUSH
61079: EMPTY
61080: LIST
61081: LIST
61082: PUSH
61083: LD_INT 35
61085: PUSH
61086: LD_INT 30
61088: PUSH
61089: EMPTY
61090: LIST
61091: LIST
61092: PUSH
61093: EMPTY
61094: LIST
61095: LIST
61096: LIST
61097: PUSH
61098: LD_INT 91
61100: PUSH
61101: LD_VAR 0 1
61105: PUSH
61106: LD_INT 18
61108: PUSH
61109: EMPTY
61110: LIST
61111: LIST
61112: LIST
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: LIST
61118: PPUSH
61119: CALL_OW 69
61123: NOT
61124: PUSH
61125: LD_INT 22
61127: PUSH
61128: LD_VAR 0 16
61132: PUSH
61133: EMPTY
61134: LIST
61135: LIST
61136: PUSH
61137: LD_INT 2
61139: PUSH
61140: LD_INT 30
61142: PUSH
61143: LD_INT 32
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PUSH
61150: LD_INT 30
61152: PUSH
61153: LD_INT 33
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: PUSH
61160: EMPTY
61161: LIST
61162: LIST
61163: LIST
61164: PUSH
61165: LD_INT 91
61167: PUSH
61168: LD_VAR 0 1
61172: PUSH
61173: LD_INT 12
61175: PUSH
61176: EMPTY
61177: LIST
61178: LIST
61179: LIST
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: LIST
61185: PUSH
61186: EMPTY
61187: LIST
61188: PPUSH
61189: CALL_OW 69
61193: PUSH
61194: LD_INT 2
61196: GREATER
61197: AND
61198: IFFALSE 61221
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61200: LD_ADDR_VAR 0 18
61204: PUSH
61205: LD_INT 11
61207: PUSH
61208: LD_INT 30
61210: PUSH
61211: EMPTY
61212: LIST
61213: LIST
61214: PUSH
61215: LD_VAR 0 12
61219: ARRAY
61220: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61221: LD_VAR 0 18
61225: NOT
61226: PUSH
61227: LD_INT 40
61229: PPUSH
61230: LD_VAR 0 16
61234: PPUSH
61235: CALL_OW 321
61239: PUSH
61240: LD_INT 2
61242: EQUAL
61243: AND
61244: PUSH
61245: LD_INT 7
61247: PUSH
61248: LD_VAR 0 5
61252: IN
61253: PUSH
61254: LD_INT 28
61256: PUSH
61257: LD_VAR 0 5
61261: IN
61262: OR
61263: PUSH
61264: LD_INT 45
61266: PUSH
61267: LD_VAR 0 5
61271: IN
61272: OR
61273: AND
61274: IFFALSE 61528
// begin hex := GetHexInfo ( x , y ) ;
61276: LD_ADDR_VAR 0 4
61280: PUSH
61281: LD_VAR 0 10
61285: PPUSH
61286: LD_VAR 0 11
61290: PPUSH
61291: CALL_OW 546
61295: ST_TO_ADDR
// if hex [ 1 ] then
61296: LD_VAR 0 4
61300: PUSH
61301: LD_INT 1
61303: ARRAY
61304: IFFALSE 61308
// exit ;
61306: GO 61711
// height := hex [ 2 ] ;
61308: LD_ADDR_VAR 0 15
61312: PUSH
61313: LD_VAR 0 4
61317: PUSH
61318: LD_INT 2
61320: ARRAY
61321: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
61322: LD_ADDR_VAR 0 14
61326: PUSH
61327: LD_INT 0
61329: PUSH
61330: LD_INT 2
61332: PUSH
61333: LD_INT 3
61335: PUSH
61336: LD_INT 5
61338: PUSH
61339: EMPTY
61340: LIST
61341: LIST
61342: LIST
61343: LIST
61344: ST_TO_ADDR
// for i in tmp do
61345: LD_ADDR_VAR 0 8
61349: PUSH
61350: LD_VAR 0 14
61354: PUSH
61355: FOR_IN
61356: IFFALSE 61526
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
61358: LD_ADDR_VAR 0 9
61362: PUSH
61363: LD_VAR 0 10
61367: PPUSH
61368: LD_VAR 0 8
61372: PPUSH
61373: LD_INT 5
61375: PPUSH
61376: CALL_OW 272
61380: PUSH
61381: LD_VAR 0 11
61385: PPUSH
61386: LD_VAR 0 8
61390: PPUSH
61391: LD_INT 5
61393: PPUSH
61394: CALL_OW 273
61398: PUSH
61399: EMPTY
61400: LIST
61401: LIST
61402: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
61403: LD_VAR 0 9
61407: PUSH
61408: LD_INT 1
61410: ARRAY
61411: PPUSH
61412: LD_VAR 0 9
61416: PUSH
61417: LD_INT 2
61419: ARRAY
61420: PPUSH
61421: CALL_OW 488
61425: IFFALSE 61524
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
61427: LD_ADDR_VAR 0 4
61431: PUSH
61432: LD_VAR 0 9
61436: PUSH
61437: LD_INT 1
61439: ARRAY
61440: PPUSH
61441: LD_VAR 0 9
61445: PUSH
61446: LD_INT 2
61448: ARRAY
61449: PPUSH
61450: CALL_OW 546
61454: ST_TO_ADDR
// if hex [ 1 ] then
61455: LD_VAR 0 4
61459: PUSH
61460: LD_INT 1
61462: ARRAY
61463: IFFALSE 61467
// continue ;
61465: GO 61355
// h := hex [ 2 ] ;
61467: LD_ADDR_VAR 0 13
61471: PUSH
61472: LD_VAR 0 4
61476: PUSH
61477: LD_INT 2
61479: ARRAY
61480: ST_TO_ADDR
// if h + 7 < height then
61481: LD_VAR 0 13
61485: PUSH
61486: LD_INT 7
61488: PLUS
61489: PUSH
61490: LD_VAR 0 15
61494: LESS
61495: IFFALSE 61524
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
61497: LD_ADDR_VAR 0 18
61501: PUSH
61502: LD_INT 7
61504: PUSH
61505: LD_INT 28
61507: PUSH
61508: LD_INT 45
61510: PUSH
61511: EMPTY
61512: LIST
61513: LIST
61514: LIST
61515: PUSH
61516: LD_VAR 0 12
61520: ARRAY
61521: ST_TO_ADDR
// break ;
61522: GO 61526
// end ; end ; end ;
61524: GO 61355
61526: POP
61527: POP
// end ; if not weapon then
61528: LD_VAR 0 18
61532: NOT
61533: IFFALSE 61593
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
61535: LD_ADDR_VAR 0 5
61539: PUSH
61540: LD_VAR 0 5
61544: PUSH
61545: LD_INT 11
61547: PUSH
61548: LD_INT 30
61550: PUSH
61551: LD_INT 49
61553: PUSH
61554: EMPTY
61555: LIST
61556: LIST
61557: LIST
61558: DIFF
61559: ST_TO_ADDR
// if not list then
61560: LD_VAR 0 5
61564: NOT
61565: IFFALSE 61569
// exit ;
61567: GO 61711
// weapon := list [ rand ( 1 , list ) ] ;
61569: LD_ADDR_VAR 0 18
61573: PUSH
61574: LD_VAR 0 5
61578: PUSH
61579: LD_INT 1
61581: PPUSH
61582: LD_VAR 0 5
61586: PPUSH
61587: CALL_OW 12
61591: ARRAY
61592: ST_TO_ADDR
// end ; if weapon then
61593: LD_VAR 0 18
61597: IFFALSE 61711
// begin tmp := CostOfWeapon ( weapon ) ;
61599: LD_ADDR_VAR 0 14
61603: PUSH
61604: LD_VAR 0 18
61608: PPUSH
61609: CALL_OW 451
61613: ST_TO_ADDR
// j := GetBase ( tower ) ;
61614: LD_ADDR_VAR 0 9
61618: PUSH
61619: LD_VAR 0 1
61623: PPUSH
61624: CALL_OW 274
61628: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
61629: LD_VAR 0 9
61633: PPUSH
61634: LD_INT 1
61636: PPUSH
61637: CALL_OW 275
61641: PUSH
61642: LD_VAR 0 14
61646: PUSH
61647: LD_INT 1
61649: ARRAY
61650: GREATEREQUAL
61651: PUSH
61652: LD_VAR 0 9
61656: PPUSH
61657: LD_INT 2
61659: PPUSH
61660: CALL_OW 275
61664: PUSH
61665: LD_VAR 0 14
61669: PUSH
61670: LD_INT 2
61672: ARRAY
61673: GREATEREQUAL
61674: AND
61675: PUSH
61676: LD_VAR 0 9
61680: PPUSH
61681: LD_INT 3
61683: PPUSH
61684: CALL_OW 275
61688: PUSH
61689: LD_VAR 0 14
61693: PUSH
61694: LD_INT 3
61696: ARRAY
61697: GREATEREQUAL
61698: AND
61699: IFFALSE 61711
// result := weapon ;
61701: LD_ADDR_VAR 0 3
61705: PUSH
61706: LD_VAR 0 18
61710: ST_TO_ADDR
// end ; end ;
61711: LD_VAR 0 3
61715: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
61716: LD_INT 0
61718: PPUSH
61719: PPUSH
// result := true ;
61720: LD_ADDR_VAR 0 3
61724: PUSH
61725: LD_INT 1
61727: ST_TO_ADDR
// if array1 = array2 then
61728: LD_VAR 0 1
61732: PUSH
61733: LD_VAR 0 2
61737: EQUAL
61738: IFFALSE 61798
// begin for i = 1 to array1 do
61740: LD_ADDR_VAR 0 4
61744: PUSH
61745: DOUBLE
61746: LD_INT 1
61748: DEC
61749: ST_TO_ADDR
61750: LD_VAR 0 1
61754: PUSH
61755: FOR_TO
61756: IFFALSE 61794
// if array1 [ i ] <> array2 [ i ] then
61758: LD_VAR 0 1
61762: PUSH
61763: LD_VAR 0 4
61767: ARRAY
61768: PUSH
61769: LD_VAR 0 2
61773: PUSH
61774: LD_VAR 0 4
61778: ARRAY
61779: NONEQUAL
61780: IFFALSE 61792
// begin result := false ;
61782: LD_ADDR_VAR 0 3
61786: PUSH
61787: LD_INT 0
61789: ST_TO_ADDR
// break ;
61790: GO 61794
// end ;
61792: GO 61755
61794: POP
61795: POP
// end else
61796: GO 61806
// result := false ;
61798: LD_ADDR_VAR 0 3
61802: PUSH
61803: LD_INT 0
61805: ST_TO_ADDR
// end ;
61806: LD_VAR 0 3
61810: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
61811: LD_INT 0
61813: PPUSH
61814: PPUSH
61815: PPUSH
// pom := GetBase ( fac ) ;
61816: LD_ADDR_VAR 0 5
61820: PUSH
61821: LD_VAR 0 1
61825: PPUSH
61826: CALL_OW 274
61830: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
61831: LD_ADDR_VAR 0 4
61835: PUSH
61836: LD_VAR 0 2
61840: PUSH
61841: LD_INT 1
61843: ARRAY
61844: PPUSH
61845: LD_VAR 0 2
61849: PUSH
61850: LD_INT 2
61852: ARRAY
61853: PPUSH
61854: LD_VAR 0 2
61858: PUSH
61859: LD_INT 3
61861: ARRAY
61862: PPUSH
61863: LD_VAR 0 2
61867: PUSH
61868: LD_INT 4
61870: ARRAY
61871: PPUSH
61872: CALL_OW 449
61876: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61877: LD_ADDR_VAR 0 3
61881: PUSH
61882: LD_VAR 0 5
61886: PPUSH
61887: LD_INT 1
61889: PPUSH
61890: CALL_OW 275
61894: PUSH
61895: LD_VAR 0 4
61899: PUSH
61900: LD_INT 1
61902: ARRAY
61903: GREATEREQUAL
61904: PUSH
61905: LD_VAR 0 5
61909: PPUSH
61910: LD_INT 2
61912: PPUSH
61913: CALL_OW 275
61917: PUSH
61918: LD_VAR 0 4
61922: PUSH
61923: LD_INT 2
61925: ARRAY
61926: GREATEREQUAL
61927: AND
61928: PUSH
61929: LD_VAR 0 5
61933: PPUSH
61934: LD_INT 3
61936: PPUSH
61937: CALL_OW 275
61941: PUSH
61942: LD_VAR 0 4
61946: PUSH
61947: LD_INT 3
61949: ARRAY
61950: GREATEREQUAL
61951: AND
61952: ST_TO_ADDR
// end ;
61953: LD_VAR 0 3
61957: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
61958: LD_INT 0
61960: PPUSH
61961: PPUSH
61962: PPUSH
61963: PPUSH
// pom := GetBase ( building ) ;
61964: LD_ADDR_VAR 0 3
61968: PUSH
61969: LD_VAR 0 1
61973: PPUSH
61974: CALL_OW 274
61978: ST_TO_ADDR
// if not pom then
61979: LD_VAR 0 3
61983: NOT
61984: IFFALSE 61988
// exit ;
61986: GO 62158
// btype := GetBType ( building ) ;
61988: LD_ADDR_VAR 0 5
61992: PUSH
61993: LD_VAR 0 1
61997: PPUSH
61998: CALL_OW 266
62002: ST_TO_ADDR
// if btype = b_armoury then
62003: LD_VAR 0 5
62007: PUSH
62008: LD_INT 4
62010: EQUAL
62011: IFFALSE 62021
// btype := b_barracks ;
62013: LD_ADDR_VAR 0 5
62017: PUSH
62018: LD_INT 5
62020: ST_TO_ADDR
// if btype = b_depot then
62021: LD_VAR 0 5
62025: PUSH
62026: LD_INT 0
62028: EQUAL
62029: IFFALSE 62039
// btype := b_warehouse ;
62031: LD_ADDR_VAR 0 5
62035: PUSH
62036: LD_INT 1
62038: ST_TO_ADDR
// if btype = b_workshop then
62039: LD_VAR 0 5
62043: PUSH
62044: LD_INT 2
62046: EQUAL
62047: IFFALSE 62057
// btype := b_factory ;
62049: LD_ADDR_VAR 0 5
62053: PUSH
62054: LD_INT 3
62056: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62057: LD_ADDR_VAR 0 4
62061: PUSH
62062: LD_VAR 0 5
62066: PPUSH
62067: LD_VAR 0 1
62071: PPUSH
62072: CALL_OW 248
62076: PPUSH
62077: CALL_OW 450
62081: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62082: LD_ADDR_VAR 0 2
62086: PUSH
62087: LD_VAR 0 3
62091: PPUSH
62092: LD_INT 1
62094: PPUSH
62095: CALL_OW 275
62099: PUSH
62100: LD_VAR 0 4
62104: PUSH
62105: LD_INT 1
62107: ARRAY
62108: GREATEREQUAL
62109: PUSH
62110: LD_VAR 0 3
62114: PPUSH
62115: LD_INT 2
62117: PPUSH
62118: CALL_OW 275
62122: PUSH
62123: LD_VAR 0 4
62127: PUSH
62128: LD_INT 2
62130: ARRAY
62131: GREATEREQUAL
62132: AND
62133: PUSH
62134: LD_VAR 0 3
62138: PPUSH
62139: LD_INT 3
62141: PPUSH
62142: CALL_OW 275
62146: PUSH
62147: LD_VAR 0 4
62151: PUSH
62152: LD_INT 3
62154: ARRAY
62155: GREATEREQUAL
62156: AND
62157: ST_TO_ADDR
// end ;
62158: LD_VAR 0 2
62162: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62163: LD_INT 0
62165: PPUSH
62166: PPUSH
62167: PPUSH
// pom := GetBase ( building ) ;
62168: LD_ADDR_VAR 0 4
62172: PUSH
62173: LD_VAR 0 1
62177: PPUSH
62178: CALL_OW 274
62182: ST_TO_ADDR
// if not pom then
62183: LD_VAR 0 4
62187: NOT
62188: IFFALSE 62192
// exit ;
62190: GO 62293
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62192: LD_ADDR_VAR 0 5
62196: PUSH
62197: LD_VAR 0 2
62201: PPUSH
62202: LD_VAR 0 1
62206: PPUSH
62207: CALL_OW 248
62211: PPUSH
62212: CALL_OW 450
62216: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62217: LD_ADDR_VAR 0 3
62221: PUSH
62222: LD_VAR 0 4
62226: PPUSH
62227: LD_INT 1
62229: PPUSH
62230: CALL_OW 275
62234: PUSH
62235: LD_VAR 0 5
62239: PUSH
62240: LD_INT 1
62242: ARRAY
62243: GREATEREQUAL
62244: PUSH
62245: LD_VAR 0 4
62249: PPUSH
62250: LD_INT 2
62252: PPUSH
62253: CALL_OW 275
62257: PUSH
62258: LD_VAR 0 5
62262: PUSH
62263: LD_INT 2
62265: ARRAY
62266: GREATEREQUAL
62267: AND
62268: PUSH
62269: LD_VAR 0 4
62273: PPUSH
62274: LD_INT 3
62276: PPUSH
62277: CALL_OW 275
62281: PUSH
62282: LD_VAR 0 5
62286: PUSH
62287: LD_INT 3
62289: ARRAY
62290: GREATEREQUAL
62291: AND
62292: ST_TO_ADDR
// end ;
62293: LD_VAR 0 3
62297: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
62298: LD_INT 0
62300: PPUSH
62301: PPUSH
62302: PPUSH
62303: PPUSH
62304: PPUSH
62305: PPUSH
62306: PPUSH
62307: PPUSH
62308: PPUSH
62309: PPUSH
// result := false ;
62310: LD_ADDR_VAR 0 6
62314: PUSH
62315: LD_INT 0
62317: ST_TO_ADDR
// if not base or not btype or not x or not y then
62318: LD_VAR 0 1
62322: NOT
62323: PUSH
62324: LD_VAR 0 2
62328: NOT
62329: OR
62330: PUSH
62331: LD_VAR 0 3
62335: NOT
62336: OR
62337: PUSH
62338: LD_VAR 0 4
62342: NOT
62343: OR
62344: IFFALSE 62348
// exit ;
62346: GO 62957
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
62348: LD_ADDR_VAR 0 12
62352: PUSH
62353: LD_VAR 0 2
62357: PPUSH
62358: LD_VAR 0 3
62362: PPUSH
62363: LD_VAR 0 4
62367: PPUSH
62368: LD_VAR 0 5
62372: PPUSH
62373: LD_VAR 0 1
62377: PUSH
62378: LD_INT 1
62380: ARRAY
62381: PPUSH
62382: CALL_OW 248
62386: PPUSH
62387: LD_INT 0
62389: PPUSH
62390: CALL 63794 0 6
62394: ST_TO_ADDR
// if not hexes then
62395: LD_VAR 0 12
62399: NOT
62400: IFFALSE 62404
// exit ;
62402: GO 62957
// for i = 1 to hexes do
62404: LD_ADDR_VAR 0 7
62408: PUSH
62409: DOUBLE
62410: LD_INT 1
62412: DEC
62413: ST_TO_ADDR
62414: LD_VAR 0 12
62418: PUSH
62419: FOR_TO
62420: IFFALSE 62955
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62422: LD_ADDR_VAR 0 11
62426: PUSH
62427: LD_VAR 0 12
62431: PUSH
62432: LD_VAR 0 7
62436: ARRAY
62437: PUSH
62438: LD_INT 1
62440: ARRAY
62441: PPUSH
62442: LD_VAR 0 12
62446: PUSH
62447: LD_VAR 0 7
62451: ARRAY
62452: PUSH
62453: LD_INT 2
62455: ARRAY
62456: PPUSH
62457: CALL_OW 428
62461: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
62462: LD_VAR 0 12
62466: PUSH
62467: LD_VAR 0 7
62471: ARRAY
62472: PUSH
62473: LD_INT 1
62475: ARRAY
62476: PPUSH
62477: LD_VAR 0 12
62481: PUSH
62482: LD_VAR 0 7
62486: ARRAY
62487: PUSH
62488: LD_INT 2
62490: ARRAY
62491: PPUSH
62492: CALL_OW 351
62496: PUSH
62497: LD_VAR 0 12
62501: PUSH
62502: LD_VAR 0 7
62506: ARRAY
62507: PUSH
62508: LD_INT 1
62510: ARRAY
62511: PPUSH
62512: LD_VAR 0 12
62516: PUSH
62517: LD_VAR 0 7
62521: ARRAY
62522: PUSH
62523: LD_INT 2
62525: ARRAY
62526: PPUSH
62527: CALL_OW 488
62531: NOT
62532: OR
62533: PUSH
62534: LD_VAR 0 11
62538: PPUSH
62539: CALL_OW 247
62543: PUSH
62544: LD_INT 3
62546: EQUAL
62547: OR
62548: IFFALSE 62554
// exit ;
62550: POP
62551: POP
62552: GO 62957
// if not tmp or not tmp in base then
62554: LD_VAR 0 11
62558: NOT
62559: PUSH
62560: LD_VAR 0 11
62564: PUSH
62565: LD_VAR 0 1
62569: IN
62570: NOT
62571: OR
62572: IFFALSE 62576
// continue ;
62574: GO 62419
// result := true ;
62576: LD_ADDR_VAR 0 6
62580: PUSH
62581: LD_INT 1
62583: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
62584: LD_ADDR_VAR 0 15
62588: PUSH
62589: LD_VAR 0 1
62593: PPUSH
62594: LD_INT 22
62596: PUSH
62597: LD_VAR 0 11
62601: PPUSH
62602: CALL_OW 255
62606: PUSH
62607: EMPTY
62608: LIST
62609: LIST
62610: PUSH
62611: LD_INT 2
62613: PUSH
62614: LD_INT 30
62616: PUSH
62617: LD_INT 0
62619: PUSH
62620: EMPTY
62621: LIST
62622: LIST
62623: PUSH
62624: LD_INT 30
62626: PUSH
62627: LD_INT 1
62629: PUSH
62630: EMPTY
62631: LIST
62632: LIST
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: LIST
62638: PUSH
62639: EMPTY
62640: LIST
62641: LIST
62642: PPUSH
62643: CALL_OW 72
62647: ST_TO_ADDR
// if dep then
62648: LD_VAR 0 15
62652: IFFALSE 62788
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
62654: LD_ADDR_VAR 0 14
62658: PUSH
62659: LD_VAR 0 15
62663: PUSH
62664: LD_INT 1
62666: ARRAY
62667: PPUSH
62668: CALL_OW 250
62672: PPUSH
62673: LD_VAR 0 15
62677: PUSH
62678: LD_INT 1
62680: ARRAY
62681: PPUSH
62682: CALL_OW 254
62686: PPUSH
62687: LD_INT 5
62689: PPUSH
62690: CALL_OW 272
62694: PUSH
62695: LD_VAR 0 15
62699: PUSH
62700: LD_INT 1
62702: ARRAY
62703: PPUSH
62704: CALL_OW 251
62708: PPUSH
62709: LD_VAR 0 15
62713: PUSH
62714: LD_INT 1
62716: ARRAY
62717: PPUSH
62718: CALL_OW 254
62722: PPUSH
62723: LD_INT 5
62725: PPUSH
62726: CALL_OW 273
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62735: LD_VAR 0 14
62739: PUSH
62740: LD_INT 1
62742: ARRAY
62743: PPUSH
62744: LD_VAR 0 14
62748: PUSH
62749: LD_INT 2
62751: ARRAY
62752: PPUSH
62753: CALL_OW 488
62757: IFFALSE 62788
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62759: LD_VAR 0 11
62763: PPUSH
62764: LD_VAR 0 14
62768: PUSH
62769: LD_INT 1
62771: ARRAY
62772: PPUSH
62773: LD_VAR 0 14
62777: PUSH
62778: LD_INT 2
62780: ARRAY
62781: PPUSH
62782: CALL_OW 111
// continue ;
62786: GO 62419
// end ; end ; r := GetDir ( tmp ) ;
62788: LD_ADDR_VAR 0 13
62792: PUSH
62793: LD_VAR 0 11
62797: PPUSH
62798: CALL_OW 254
62802: ST_TO_ADDR
// if r = 5 then
62803: LD_VAR 0 13
62807: PUSH
62808: LD_INT 5
62810: EQUAL
62811: IFFALSE 62821
// r := 0 ;
62813: LD_ADDR_VAR 0 13
62817: PUSH
62818: LD_INT 0
62820: ST_TO_ADDR
// for j = r to 5 do
62821: LD_ADDR_VAR 0 8
62825: PUSH
62826: DOUBLE
62827: LD_VAR 0 13
62831: DEC
62832: ST_TO_ADDR
62833: LD_INT 5
62835: PUSH
62836: FOR_TO
62837: IFFALSE 62951
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62839: LD_ADDR_VAR 0 9
62843: PUSH
62844: LD_VAR 0 11
62848: PPUSH
62849: CALL_OW 250
62853: PPUSH
62854: LD_VAR 0 8
62858: PPUSH
62859: LD_INT 2
62861: PPUSH
62862: CALL_OW 272
62866: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62867: LD_ADDR_VAR 0 10
62871: PUSH
62872: LD_VAR 0 11
62876: PPUSH
62877: CALL_OW 251
62881: PPUSH
62882: LD_VAR 0 8
62886: PPUSH
62887: LD_INT 2
62889: PPUSH
62890: CALL_OW 273
62894: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62895: LD_VAR 0 9
62899: PPUSH
62900: LD_VAR 0 10
62904: PPUSH
62905: CALL_OW 488
62909: PUSH
62910: LD_VAR 0 9
62914: PPUSH
62915: LD_VAR 0 10
62919: PPUSH
62920: CALL_OW 428
62924: NOT
62925: AND
62926: IFFALSE 62949
// begin ComMoveXY ( tmp , _x , _y ) ;
62928: LD_VAR 0 11
62932: PPUSH
62933: LD_VAR 0 9
62937: PPUSH
62938: LD_VAR 0 10
62942: PPUSH
62943: CALL_OW 111
// break ;
62947: GO 62951
// end ; end ;
62949: GO 62836
62951: POP
62952: POP
// end ;
62953: GO 62419
62955: POP
62956: POP
// end ;
62957: LD_VAR 0 6
62961: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
62962: LD_INT 0
62964: PPUSH
62965: PPUSH
62966: PPUSH
62967: PPUSH
62968: PPUSH
62969: PPUSH
62970: PPUSH
62971: PPUSH
62972: PPUSH
62973: PPUSH
// result := false ;
62974: LD_ADDR_VAR 0 6
62978: PUSH
62979: LD_INT 0
62981: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62982: LD_VAR 0 1
62986: NOT
62987: PUSH
62988: LD_VAR 0 1
62992: PPUSH
62993: CALL_OW 266
62997: PUSH
62998: LD_INT 0
63000: PUSH
63001: LD_INT 1
63003: PUSH
63004: EMPTY
63005: LIST
63006: LIST
63007: IN
63008: NOT
63009: OR
63010: PUSH
63011: LD_VAR 0 2
63015: NOT
63016: OR
63017: PUSH
63018: LD_VAR 0 5
63022: PUSH
63023: LD_INT 0
63025: PUSH
63026: LD_INT 1
63028: PUSH
63029: LD_INT 2
63031: PUSH
63032: LD_INT 3
63034: PUSH
63035: LD_INT 4
63037: PUSH
63038: LD_INT 5
63040: PUSH
63041: EMPTY
63042: LIST
63043: LIST
63044: LIST
63045: LIST
63046: LIST
63047: LIST
63048: IN
63049: NOT
63050: OR
63051: PUSH
63052: LD_VAR 0 3
63056: PPUSH
63057: LD_VAR 0 4
63061: PPUSH
63062: CALL_OW 488
63066: NOT
63067: OR
63068: IFFALSE 63072
// exit ;
63070: GO 63789
// pom := GetBase ( depot ) ;
63072: LD_ADDR_VAR 0 10
63076: PUSH
63077: LD_VAR 0 1
63081: PPUSH
63082: CALL_OW 274
63086: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
63087: LD_ADDR_VAR 0 11
63091: PUSH
63092: LD_VAR 0 2
63096: PPUSH
63097: LD_VAR 0 1
63101: PPUSH
63102: CALL_OW 248
63106: PPUSH
63107: CALL_OW 450
63111: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
63112: LD_VAR 0 10
63116: PPUSH
63117: LD_INT 1
63119: PPUSH
63120: CALL_OW 275
63124: PUSH
63125: LD_VAR 0 11
63129: PUSH
63130: LD_INT 1
63132: ARRAY
63133: GREATEREQUAL
63134: PUSH
63135: LD_VAR 0 10
63139: PPUSH
63140: LD_INT 2
63142: PPUSH
63143: CALL_OW 275
63147: PUSH
63148: LD_VAR 0 11
63152: PUSH
63153: LD_INT 2
63155: ARRAY
63156: GREATEREQUAL
63157: AND
63158: PUSH
63159: LD_VAR 0 10
63163: PPUSH
63164: LD_INT 3
63166: PPUSH
63167: CALL_OW 275
63171: PUSH
63172: LD_VAR 0 11
63176: PUSH
63177: LD_INT 3
63179: ARRAY
63180: GREATEREQUAL
63181: AND
63182: NOT
63183: IFFALSE 63187
// exit ;
63185: GO 63789
// if GetBType ( depot ) = b_depot then
63187: LD_VAR 0 1
63191: PPUSH
63192: CALL_OW 266
63196: PUSH
63197: LD_INT 0
63199: EQUAL
63200: IFFALSE 63212
// dist := 28 else
63202: LD_ADDR_VAR 0 14
63206: PUSH
63207: LD_INT 28
63209: ST_TO_ADDR
63210: GO 63220
// dist := 36 ;
63212: LD_ADDR_VAR 0 14
63216: PUSH
63217: LD_INT 36
63219: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
63220: LD_VAR 0 1
63224: PPUSH
63225: LD_VAR 0 3
63229: PPUSH
63230: LD_VAR 0 4
63234: PPUSH
63235: CALL_OW 297
63239: PUSH
63240: LD_VAR 0 14
63244: GREATER
63245: IFFALSE 63249
// exit ;
63247: GO 63789
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
63249: LD_ADDR_VAR 0 12
63253: PUSH
63254: LD_VAR 0 2
63258: PPUSH
63259: LD_VAR 0 3
63263: PPUSH
63264: LD_VAR 0 4
63268: PPUSH
63269: LD_VAR 0 5
63273: PPUSH
63274: LD_VAR 0 1
63278: PPUSH
63279: CALL_OW 248
63283: PPUSH
63284: LD_INT 0
63286: PPUSH
63287: CALL 63794 0 6
63291: ST_TO_ADDR
// if not hexes then
63292: LD_VAR 0 12
63296: NOT
63297: IFFALSE 63301
// exit ;
63299: GO 63789
// hex := GetHexInfo ( x , y ) ;
63301: LD_ADDR_VAR 0 15
63305: PUSH
63306: LD_VAR 0 3
63310: PPUSH
63311: LD_VAR 0 4
63315: PPUSH
63316: CALL_OW 546
63320: ST_TO_ADDR
// if hex [ 1 ] then
63321: LD_VAR 0 15
63325: PUSH
63326: LD_INT 1
63328: ARRAY
63329: IFFALSE 63333
// exit ;
63331: GO 63789
// height := hex [ 2 ] ;
63333: LD_ADDR_VAR 0 13
63337: PUSH
63338: LD_VAR 0 15
63342: PUSH
63343: LD_INT 2
63345: ARRAY
63346: ST_TO_ADDR
// for i = 1 to hexes do
63347: LD_ADDR_VAR 0 7
63351: PUSH
63352: DOUBLE
63353: LD_INT 1
63355: DEC
63356: ST_TO_ADDR
63357: LD_VAR 0 12
63361: PUSH
63362: FOR_TO
63363: IFFALSE 63693
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63365: LD_VAR 0 12
63369: PUSH
63370: LD_VAR 0 7
63374: ARRAY
63375: PUSH
63376: LD_INT 1
63378: ARRAY
63379: PPUSH
63380: LD_VAR 0 12
63384: PUSH
63385: LD_VAR 0 7
63389: ARRAY
63390: PUSH
63391: LD_INT 2
63393: ARRAY
63394: PPUSH
63395: CALL_OW 488
63399: NOT
63400: PUSH
63401: LD_VAR 0 12
63405: PUSH
63406: LD_VAR 0 7
63410: ARRAY
63411: PUSH
63412: LD_INT 1
63414: ARRAY
63415: PPUSH
63416: LD_VAR 0 12
63420: PUSH
63421: LD_VAR 0 7
63425: ARRAY
63426: PUSH
63427: LD_INT 2
63429: ARRAY
63430: PPUSH
63431: CALL_OW 428
63435: PUSH
63436: LD_INT 0
63438: GREATER
63439: OR
63440: PUSH
63441: LD_VAR 0 12
63445: PUSH
63446: LD_VAR 0 7
63450: ARRAY
63451: PUSH
63452: LD_INT 1
63454: ARRAY
63455: PPUSH
63456: LD_VAR 0 12
63460: PUSH
63461: LD_VAR 0 7
63465: ARRAY
63466: PUSH
63467: LD_INT 2
63469: ARRAY
63470: PPUSH
63471: CALL_OW 351
63475: OR
63476: IFFALSE 63482
// exit ;
63478: POP
63479: POP
63480: GO 63789
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63482: LD_ADDR_VAR 0 8
63486: PUSH
63487: LD_VAR 0 12
63491: PUSH
63492: LD_VAR 0 7
63496: ARRAY
63497: PUSH
63498: LD_INT 1
63500: ARRAY
63501: PPUSH
63502: LD_VAR 0 12
63506: PUSH
63507: LD_VAR 0 7
63511: ARRAY
63512: PUSH
63513: LD_INT 2
63515: ARRAY
63516: PPUSH
63517: CALL_OW 546
63521: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63522: LD_VAR 0 8
63526: PUSH
63527: LD_INT 1
63529: ARRAY
63530: PUSH
63531: LD_VAR 0 8
63535: PUSH
63536: LD_INT 2
63538: ARRAY
63539: PUSH
63540: LD_VAR 0 13
63544: PUSH
63545: LD_INT 2
63547: PLUS
63548: GREATER
63549: OR
63550: PUSH
63551: LD_VAR 0 8
63555: PUSH
63556: LD_INT 2
63558: ARRAY
63559: PUSH
63560: LD_VAR 0 13
63564: PUSH
63565: LD_INT 2
63567: MINUS
63568: LESS
63569: OR
63570: PUSH
63571: LD_VAR 0 8
63575: PUSH
63576: LD_INT 3
63578: ARRAY
63579: PUSH
63580: LD_INT 0
63582: PUSH
63583: LD_INT 8
63585: PUSH
63586: LD_INT 9
63588: PUSH
63589: LD_INT 10
63591: PUSH
63592: LD_INT 11
63594: PUSH
63595: LD_INT 12
63597: PUSH
63598: LD_INT 13
63600: PUSH
63601: LD_INT 16
63603: PUSH
63604: LD_INT 17
63606: PUSH
63607: LD_INT 18
63609: PUSH
63610: LD_INT 19
63612: PUSH
63613: LD_INT 20
63615: PUSH
63616: LD_INT 21
63618: PUSH
63619: EMPTY
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: IN
63634: NOT
63635: OR
63636: PUSH
63637: LD_VAR 0 8
63641: PUSH
63642: LD_INT 5
63644: ARRAY
63645: NOT
63646: OR
63647: PUSH
63648: LD_VAR 0 8
63652: PUSH
63653: LD_INT 6
63655: ARRAY
63656: PUSH
63657: LD_INT 1
63659: PUSH
63660: LD_INT 2
63662: PUSH
63663: LD_INT 7
63665: PUSH
63666: LD_INT 9
63668: PUSH
63669: LD_INT 10
63671: PUSH
63672: LD_INT 11
63674: PUSH
63675: EMPTY
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: IN
63683: NOT
63684: OR
63685: IFFALSE 63691
// exit ;
63687: POP
63688: POP
63689: GO 63789
// end ;
63691: GO 63362
63693: POP
63694: POP
// side := GetSide ( depot ) ;
63695: LD_ADDR_VAR 0 9
63699: PUSH
63700: LD_VAR 0 1
63704: PPUSH
63705: CALL_OW 255
63709: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63710: LD_VAR 0 9
63714: PPUSH
63715: LD_VAR 0 3
63719: PPUSH
63720: LD_VAR 0 4
63724: PPUSH
63725: LD_INT 20
63727: PPUSH
63728: CALL 56443 0 4
63732: PUSH
63733: LD_INT 4
63735: ARRAY
63736: IFFALSE 63740
// exit ;
63738: GO 63789
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63740: LD_VAR 0 2
63744: PUSH
63745: LD_INT 29
63747: PUSH
63748: LD_INT 30
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: IN
63755: PUSH
63756: LD_VAR 0 3
63760: PPUSH
63761: LD_VAR 0 4
63765: PPUSH
63766: LD_VAR 0 9
63770: PPUSH
63771: CALL_OW 440
63775: NOT
63776: AND
63777: IFFALSE 63781
// exit ;
63779: GO 63789
// result := true ;
63781: LD_ADDR_VAR 0 6
63785: PUSH
63786: LD_INT 1
63788: ST_TO_ADDR
// end ;
63789: LD_VAR 0 6
63793: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
63794: LD_INT 0
63796: PPUSH
63797: PPUSH
63798: PPUSH
63799: PPUSH
63800: PPUSH
63801: PPUSH
63802: PPUSH
63803: PPUSH
63804: PPUSH
63805: PPUSH
63806: PPUSH
63807: PPUSH
63808: PPUSH
63809: PPUSH
63810: PPUSH
63811: PPUSH
63812: PPUSH
63813: PPUSH
63814: PPUSH
63815: PPUSH
63816: PPUSH
63817: PPUSH
63818: PPUSH
63819: PPUSH
63820: PPUSH
63821: PPUSH
63822: PPUSH
63823: PPUSH
63824: PPUSH
63825: PPUSH
63826: PPUSH
63827: PPUSH
63828: PPUSH
63829: PPUSH
63830: PPUSH
63831: PPUSH
63832: PPUSH
63833: PPUSH
63834: PPUSH
63835: PPUSH
63836: PPUSH
63837: PPUSH
63838: PPUSH
63839: PPUSH
63840: PPUSH
63841: PPUSH
63842: PPUSH
63843: PPUSH
63844: PPUSH
63845: PPUSH
63846: PPUSH
63847: PPUSH
63848: PPUSH
63849: PPUSH
63850: PPUSH
63851: PPUSH
63852: PPUSH
63853: PPUSH
// result = [ ] ;
63854: LD_ADDR_VAR 0 7
63858: PUSH
63859: EMPTY
63860: ST_TO_ADDR
// temp_list = [ ] ;
63861: LD_ADDR_VAR 0 9
63865: PUSH
63866: EMPTY
63867: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63868: LD_VAR 0 4
63872: PUSH
63873: LD_INT 0
63875: PUSH
63876: LD_INT 1
63878: PUSH
63879: LD_INT 2
63881: PUSH
63882: LD_INT 3
63884: PUSH
63885: LD_INT 4
63887: PUSH
63888: LD_INT 5
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: IN
63899: NOT
63900: PUSH
63901: LD_VAR 0 1
63905: PUSH
63906: LD_INT 0
63908: PUSH
63909: LD_INT 1
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: IN
63916: PUSH
63917: LD_VAR 0 5
63921: PUSH
63922: LD_INT 1
63924: PUSH
63925: LD_INT 2
63927: PUSH
63928: LD_INT 3
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: LIST
63935: IN
63936: NOT
63937: AND
63938: OR
63939: IFFALSE 63943
// exit ;
63941: GO 82334
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63943: LD_VAR 0 1
63947: PUSH
63948: LD_INT 6
63950: PUSH
63951: LD_INT 7
63953: PUSH
63954: LD_INT 8
63956: PUSH
63957: LD_INT 13
63959: PUSH
63960: LD_INT 12
63962: PUSH
63963: LD_INT 15
63965: PUSH
63966: LD_INT 11
63968: PUSH
63969: LD_INT 14
63971: PUSH
63972: LD_INT 10
63974: PUSH
63975: EMPTY
63976: LIST
63977: LIST
63978: LIST
63979: LIST
63980: LIST
63981: LIST
63982: LIST
63983: LIST
63984: LIST
63985: IN
63986: IFFALSE 63996
// btype = b_lab ;
63988: LD_ADDR_VAR 0 1
63992: PUSH
63993: LD_INT 6
63995: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63996: LD_VAR 0 6
64000: PUSH
64001: LD_INT 0
64003: PUSH
64004: LD_INT 1
64006: PUSH
64007: LD_INT 2
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: LIST
64014: IN
64015: NOT
64016: PUSH
64017: LD_VAR 0 1
64021: PUSH
64022: LD_INT 0
64024: PUSH
64025: LD_INT 1
64027: PUSH
64028: LD_INT 2
64030: PUSH
64031: LD_INT 3
64033: PUSH
64034: LD_INT 6
64036: PUSH
64037: LD_INT 36
64039: PUSH
64040: LD_INT 4
64042: PUSH
64043: LD_INT 5
64045: PUSH
64046: LD_INT 31
64048: PUSH
64049: LD_INT 32
64051: PUSH
64052: LD_INT 33
64054: PUSH
64055: EMPTY
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: LIST
64061: LIST
64062: LIST
64063: LIST
64064: LIST
64065: LIST
64066: LIST
64067: IN
64068: NOT
64069: PUSH
64070: LD_VAR 0 6
64074: PUSH
64075: LD_INT 1
64077: EQUAL
64078: AND
64079: OR
64080: PUSH
64081: LD_VAR 0 1
64085: PUSH
64086: LD_INT 2
64088: PUSH
64089: LD_INT 3
64091: PUSH
64092: EMPTY
64093: LIST
64094: LIST
64095: IN
64096: NOT
64097: PUSH
64098: LD_VAR 0 6
64102: PUSH
64103: LD_INT 2
64105: EQUAL
64106: AND
64107: OR
64108: IFFALSE 64118
// mode = 0 ;
64110: LD_ADDR_VAR 0 6
64114: PUSH
64115: LD_INT 0
64117: ST_TO_ADDR
// case mode of 0 :
64118: LD_VAR 0 6
64122: PUSH
64123: LD_INT 0
64125: DOUBLE
64126: EQUAL
64127: IFTRUE 64131
64129: GO 75584
64131: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
64132: LD_ADDR_VAR 0 11
64136: PUSH
64137: LD_INT 0
64139: PUSH
64140: LD_INT 0
64142: PUSH
64143: EMPTY
64144: LIST
64145: LIST
64146: PUSH
64147: LD_INT 0
64149: PUSH
64150: LD_INT 1
64152: NEG
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: PUSH
64158: LD_INT 1
64160: PUSH
64161: LD_INT 0
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: PUSH
64168: LD_INT 1
64170: PUSH
64171: LD_INT 1
64173: PUSH
64174: EMPTY
64175: LIST
64176: LIST
64177: PUSH
64178: LD_INT 0
64180: PUSH
64181: LD_INT 1
64183: PUSH
64184: EMPTY
64185: LIST
64186: LIST
64187: PUSH
64188: LD_INT 1
64190: NEG
64191: PUSH
64192: LD_INT 0
64194: PUSH
64195: EMPTY
64196: LIST
64197: LIST
64198: PUSH
64199: LD_INT 1
64201: NEG
64202: PUSH
64203: LD_INT 1
64205: NEG
64206: PUSH
64207: EMPTY
64208: LIST
64209: LIST
64210: PUSH
64211: LD_INT 1
64213: NEG
64214: PUSH
64215: LD_INT 2
64217: NEG
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: PUSH
64223: LD_INT 0
64225: PUSH
64226: LD_INT 2
64228: NEG
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PUSH
64234: LD_INT 1
64236: PUSH
64237: LD_INT 1
64239: NEG
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PUSH
64245: LD_INT 1
64247: PUSH
64248: LD_INT 2
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: LD_INT 0
64257: PUSH
64258: LD_INT 2
64260: PUSH
64261: EMPTY
64262: LIST
64263: LIST
64264: PUSH
64265: LD_INT 1
64267: NEG
64268: PUSH
64269: LD_INT 1
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: PUSH
64276: LD_INT 1
64278: PUSH
64279: LD_INT 3
64281: PUSH
64282: EMPTY
64283: LIST
64284: LIST
64285: PUSH
64286: LD_INT 0
64288: PUSH
64289: LD_INT 3
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: PUSH
64296: LD_INT 1
64298: NEG
64299: PUSH
64300: LD_INT 2
64302: PUSH
64303: EMPTY
64304: LIST
64305: LIST
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64325: LD_ADDR_VAR 0 12
64329: PUSH
64330: LD_INT 0
64332: PUSH
64333: LD_INT 0
64335: PUSH
64336: EMPTY
64337: LIST
64338: LIST
64339: PUSH
64340: LD_INT 0
64342: PUSH
64343: LD_INT 1
64345: NEG
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: LD_INT 1
64353: PUSH
64354: LD_INT 0
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: PUSH
64361: LD_INT 1
64363: PUSH
64364: LD_INT 1
64366: PUSH
64367: EMPTY
64368: LIST
64369: LIST
64370: PUSH
64371: LD_INT 0
64373: PUSH
64374: LD_INT 1
64376: PUSH
64377: EMPTY
64378: LIST
64379: LIST
64380: PUSH
64381: LD_INT 1
64383: NEG
64384: PUSH
64385: LD_INT 0
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: PUSH
64392: LD_INT 1
64394: NEG
64395: PUSH
64396: LD_INT 1
64398: NEG
64399: PUSH
64400: EMPTY
64401: LIST
64402: LIST
64403: PUSH
64404: LD_INT 1
64406: PUSH
64407: LD_INT 1
64409: NEG
64410: PUSH
64411: EMPTY
64412: LIST
64413: LIST
64414: PUSH
64415: LD_INT 2
64417: PUSH
64418: LD_INT 0
64420: PUSH
64421: EMPTY
64422: LIST
64423: LIST
64424: PUSH
64425: LD_INT 2
64427: PUSH
64428: LD_INT 1
64430: PUSH
64431: EMPTY
64432: LIST
64433: LIST
64434: PUSH
64435: LD_INT 1
64437: NEG
64438: PUSH
64439: LD_INT 1
64441: PUSH
64442: EMPTY
64443: LIST
64444: LIST
64445: PUSH
64446: LD_INT 2
64448: NEG
64449: PUSH
64450: LD_INT 0
64452: PUSH
64453: EMPTY
64454: LIST
64455: LIST
64456: PUSH
64457: LD_INT 2
64459: NEG
64460: PUSH
64461: LD_INT 1
64463: NEG
64464: PUSH
64465: EMPTY
64466: LIST
64467: LIST
64468: PUSH
64469: LD_INT 2
64471: NEG
64472: PUSH
64473: LD_INT 1
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: PUSH
64480: LD_INT 3
64482: NEG
64483: PUSH
64484: LD_INT 0
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PUSH
64491: LD_INT 3
64493: NEG
64494: PUSH
64495: LD_INT 1
64497: NEG
64498: PUSH
64499: EMPTY
64500: LIST
64501: LIST
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64521: LD_ADDR_VAR 0 13
64525: PUSH
64526: LD_INT 0
64528: PUSH
64529: LD_INT 0
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: PUSH
64536: LD_INT 0
64538: PUSH
64539: LD_INT 1
64541: NEG
64542: PUSH
64543: EMPTY
64544: LIST
64545: LIST
64546: PUSH
64547: LD_INT 1
64549: PUSH
64550: LD_INT 0
64552: PUSH
64553: EMPTY
64554: LIST
64555: LIST
64556: PUSH
64557: LD_INT 1
64559: PUSH
64560: LD_INT 1
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: LD_INT 0
64569: PUSH
64570: LD_INT 1
64572: PUSH
64573: EMPTY
64574: LIST
64575: LIST
64576: PUSH
64577: LD_INT 1
64579: NEG
64580: PUSH
64581: LD_INT 0
64583: PUSH
64584: EMPTY
64585: LIST
64586: LIST
64587: PUSH
64588: LD_INT 1
64590: NEG
64591: PUSH
64592: LD_INT 1
64594: NEG
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PUSH
64600: LD_INT 1
64602: NEG
64603: PUSH
64604: LD_INT 2
64606: NEG
64607: PUSH
64608: EMPTY
64609: LIST
64610: LIST
64611: PUSH
64612: LD_INT 2
64614: PUSH
64615: LD_INT 1
64617: PUSH
64618: EMPTY
64619: LIST
64620: LIST
64621: PUSH
64622: LD_INT 2
64624: PUSH
64625: LD_INT 2
64627: PUSH
64628: EMPTY
64629: LIST
64630: LIST
64631: PUSH
64632: LD_INT 1
64634: PUSH
64635: LD_INT 2
64637: PUSH
64638: EMPTY
64639: LIST
64640: LIST
64641: PUSH
64642: LD_INT 2
64644: NEG
64645: PUSH
64646: LD_INT 1
64648: NEG
64649: PUSH
64650: EMPTY
64651: LIST
64652: LIST
64653: PUSH
64654: LD_INT 2
64656: NEG
64657: PUSH
64658: LD_INT 2
64660: NEG
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PUSH
64666: LD_INT 2
64668: NEG
64669: PUSH
64670: LD_INT 3
64672: NEG
64673: PUSH
64674: EMPTY
64675: LIST
64676: LIST
64677: PUSH
64678: LD_INT 3
64680: NEG
64681: PUSH
64682: LD_INT 2
64684: NEG
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: LD_INT 3
64692: NEG
64693: PUSH
64694: LD_INT 3
64696: NEG
64697: PUSH
64698: EMPTY
64699: LIST
64700: LIST
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64720: LD_ADDR_VAR 0 14
64724: PUSH
64725: LD_INT 0
64727: PUSH
64728: LD_INT 0
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: PUSH
64735: LD_INT 0
64737: PUSH
64738: LD_INT 1
64740: NEG
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: PUSH
64746: LD_INT 1
64748: PUSH
64749: LD_INT 0
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: LD_INT 1
64758: PUSH
64759: LD_INT 1
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: PUSH
64766: LD_INT 0
64768: PUSH
64769: LD_INT 1
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: LD_INT 1
64778: NEG
64779: PUSH
64780: LD_INT 0
64782: PUSH
64783: EMPTY
64784: LIST
64785: LIST
64786: PUSH
64787: LD_INT 1
64789: NEG
64790: PUSH
64791: LD_INT 1
64793: NEG
64794: PUSH
64795: EMPTY
64796: LIST
64797: LIST
64798: PUSH
64799: LD_INT 1
64801: NEG
64802: PUSH
64803: LD_INT 2
64805: NEG
64806: PUSH
64807: EMPTY
64808: LIST
64809: LIST
64810: PUSH
64811: LD_INT 0
64813: PUSH
64814: LD_INT 2
64816: NEG
64817: PUSH
64818: EMPTY
64819: LIST
64820: LIST
64821: PUSH
64822: LD_INT 1
64824: PUSH
64825: LD_INT 1
64827: NEG
64828: PUSH
64829: EMPTY
64830: LIST
64831: LIST
64832: PUSH
64833: LD_INT 1
64835: PUSH
64836: LD_INT 2
64838: PUSH
64839: EMPTY
64840: LIST
64841: LIST
64842: PUSH
64843: LD_INT 0
64845: PUSH
64846: LD_INT 2
64848: PUSH
64849: EMPTY
64850: LIST
64851: LIST
64852: PUSH
64853: LD_INT 1
64855: NEG
64856: PUSH
64857: LD_INT 1
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: PUSH
64864: LD_INT 1
64866: NEG
64867: PUSH
64868: LD_INT 3
64870: NEG
64871: PUSH
64872: EMPTY
64873: LIST
64874: LIST
64875: PUSH
64876: LD_INT 0
64878: PUSH
64879: LD_INT 3
64881: NEG
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: LD_INT 1
64889: PUSH
64890: LD_INT 2
64892: NEG
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: LIST
64902: LIST
64903: LIST
64904: LIST
64905: LIST
64906: LIST
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64916: LD_ADDR_VAR 0 15
64920: PUSH
64921: LD_INT 0
64923: PUSH
64924: LD_INT 0
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: PUSH
64931: LD_INT 0
64933: PUSH
64934: LD_INT 1
64936: NEG
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 1
64944: PUSH
64945: LD_INT 0
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: PUSH
64952: LD_INT 1
64954: PUSH
64955: LD_INT 1
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 0
64964: PUSH
64965: LD_INT 1
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: PUSH
64972: LD_INT 1
64974: NEG
64975: PUSH
64976: LD_INT 0
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: PUSH
64983: LD_INT 1
64985: NEG
64986: PUSH
64987: LD_INT 1
64989: NEG
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: PUSH
64995: LD_INT 1
64997: PUSH
64998: LD_INT 1
65000: NEG
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: LD_INT 2
65008: PUSH
65009: LD_INT 0
65011: PUSH
65012: EMPTY
65013: LIST
65014: LIST
65015: PUSH
65016: LD_INT 2
65018: PUSH
65019: LD_INT 1
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: LD_INT 1
65028: NEG
65029: PUSH
65030: LD_INT 1
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 2
65039: NEG
65040: PUSH
65041: LD_INT 0
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: LD_INT 2
65050: NEG
65051: PUSH
65052: LD_INT 1
65054: NEG
65055: PUSH
65056: EMPTY
65057: LIST
65058: LIST
65059: PUSH
65060: LD_INT 2
65062: PUSH
65063: LD_INT 1
65065: NEG
65066: PUSH
65067: EMPTY
65068: LIST
65069: LIST
65070: PUSH
65071: LD_INT 3
65073: PUSH
65074: LD_INT 0
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: PUSH
65081: LD_INT 3
65083: PUSH
65084: LD_INT 1
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: PUSH
65091: EMPTY
65092: LIST
65093: LIST
65094: LIST
65095: LIST
65096: LIST
65097: LIST
65098: LIST
65099: LIST
65100: LIST
65101: LIST
65102: LIST
65103: LIST
65104: LIST
65105: LIST
65106: LIST
65107: LIST
65108: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
65109: LD_ADDR_VAR 0 16
65113: PUSH
65114: LD_INT 0
65116: PUSH
65117: LD_INT 0
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 0
65126: PUSH
65127: LD_INT 1
65129: NEG
65130: PUSH
65131: EMPTY
65132: LIST
65133: LIST
65134: PUSH
65135: LD_INT 1
65137: PUSH
65138: LD_INT 0
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: LD_INT 1
65147: PUSH
65148: LD_INT 1
65150: PUSH
65151: EMPTY
65152: LIST
65153: LIST
65154: PUSH
65155: LD_INT 0
65157: PUSH
65158: LD_INT 1
65160: PUSH
65161: EMPTY
65162: LIST
65163: LIST
65164: PUSH
65165: LD_INT 1
65167: NEG
65168: PUSH
65169: LD_INT 0
65171: PUSH
65172: EMPTY
65173: LIST
65174: LIST
65175: PUSH
65176: LD_INT 1
65178: NEG
65179: PUSH
65180: LD_INT 1
65182: NEG
65183: PUSH
65184: EMPTY
65185: LIST
65186: LIST
65187: PUSH
65188: LD_INT 1
65190: NEG
65191: PUSH
65192: LD_INT 2
65194: NEG
65195: PUSH
65196: EMPTY
65197: LIST
65198: LIST
65199: PUSH
65200: LD_INT 2
65202: PUSH
65203: LD_INT 1
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 2
65212: PUSH
65213: LD_INT 2
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: PUSH
65220: LD_INT 1
65222: PUSH
65223: LD_INT 2
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: LD_INT 2
65232: NEG
65233: PUSH
65234: LD_INT 1
65236: NEG
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: PUSH
65242: LD_INT 2
65244: NEG
65245: PUSH
65246: LD_INT 2
65248: NEG
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: PUSH
65254: LD_INT 3
65256: PUSH
65257: LD_INT 2
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: LD_INT 3
65266: PUSH
65267: LD_INT 3
65269: PUSH
65270: EMPTY
65271: LIST
65272: LIST
65273: PUSH
65274: LD_INT 2
65276: PUSH
65277: LD_INT 3
65279: PUSH
65280: EMPTY
65281: LIST
65282: LIST
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: LIST
65288: LIST
65289: LIST
65290: LIST
65291: LIST
65292: LIST
65293: LIST
65294: LIST
65295: LIST
65296: LIST
65297: LIST
65298: LIST
65299: LIST
65300: LIST
65301: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65302: LD_ADDR_VAR 0 17
65306: PUSH
65307: LD_INT 0
65309: PUSH
65310: LD_INT 0
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 0
65319: PUSH
65320: LD_INT 1
65322: NEG
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: LD_INT 1
65330: PUSH
65331: LD_INT 0
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: LD_INT 1
65340: PUSH
65341: LD_INT 1
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: LD_INT 0
65350: PUSH
65351: LD_INT 1
65353: PUSH
65354: EMPTY
65355: LIST
65356: LIST
65357: PUSH
65358: LD_INT 1
65360: NEG
65361: PUSH
65362: LD_INT 0
65364: PUSH
65365: EMPTY
65366: LIST
65367: LIST
65368: PUSH
65369: LD_INT 1
65371: NEG
65372: PUSH
65373: LD_INT 1
65375: NEG
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: LD_INT 1
65383: NEG
65384: PUSH
65385: LD_INT 2
65387: NEG
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: LD_INT 0
65395: PUSH
65396: LD_INT 2
65398: NEG
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PUSH
65404: LD_INT 1
65406: PUSH
65407: LD_INT 1
65409: NEG
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 2
65417: PUSH
65418: LD_INT 0
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: PUSH
65425: LD_INT 2
65427: PUSH
65428: LD_INT 1
65430: PUSH
65431: EMPTY
65432: LIST
65433: LIST
65434: PUSH
65435: LD_INT 2
65437: PUSH
65438: LD_INT 2
65440: PUSH
65441: EMPTY
65442: LIST
65443: LIST
65444: PUSH
65445: LD_INT 1
65447: PUSH
65448: LD_INT 2
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: PUSH
65455: LD_INT 0
65457: PUSH
65458: LD_INT 2
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: PUSH
65465: LD_INT 1
65467: NEG
65468: PUSH
65469: LD_INT 1
65471: PUSH
65472: EMPTY
65473: LIST
65474: LIST
65475: PUSH
65476: LD_INT 2
65478: NEG
65479: PUSH
65480: LD_INT 0
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 2
65489: NEG
65490: PUSH
65491: LD_INT 1
65493: NEG
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 2
65501: NEG
65502: PUSH
65503: LD_INT 2
65505: NEG
65506: PUSH
65507: EMPTY
65508: LIST
65509: LIST
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: LIST
65518: LIST
65519: LIST
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: LIST
65526: LIST
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65532: LD_ADDR_VAR 0 18
65536: PUSH
65537: LD_INT 0
65539: PUSH
65540: LD_INT 0
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: PUSH
65547: LD_INT 0
65549: PUSH
65550: LD_INT 1
65552: NEG
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: PUSH
65558: LD_INT 1
65560: PUSH
65561: LD_INT 0
65563: PUSH
65564: EMPTY
65565: LIST
65566: LIST
65567: PUSH
65568: LD_INT 1
65570: PUSH
65571: LD_INT 1
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 0
65580: PUSH
65581: LD_INT 1
65583: PUSH
65584: EMPTY
65585: LIST
65586: LIST
65587: PUSH
65588: LD_INT 1
65590: NEG
65591: PUSH
65592: LD_INT 0
65594: PUSH
65595: EMPTY
65596: LIST
65597: LIST
65598: PUSH
65599: LD_INT 1
65601: NEG
65602: PUSH
65603: LD_INT 1
65605: NEG
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: PUSH
65611: LD_INT 1
65613: NEG
65614: PUSH
65615: LD_INT 2
65617: NEG
65618: PUSH
65619: EMPTY
65620: LIST
65621: LIST
65622: PUSH
65623: LD_INT 0
65625: PUSH
65626: LD_INT 2
65628: NEG
65629: PUSH
65630: EMPTY
65631: LIST
65632: LIST
65633: PUSH
65634: LD_INT 1
65636: PUSH
65637: LD_INT 1
65639: NEG
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: PUSH
65645: LD_INT 2
65647: PUSH
65648: LD_INT 0
65650: PUSH
65651: EMPTY
65652: LIST
65653: LIST
65654: PUSH
65655: LD_INT 2
65657: PUSH
65658: LD_INT 1
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PUSH
65665: LD_INT 2
65667: PUSH
65668: LD_INT 2
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PUSH
65675: LD_INT 1
65677: PUSH
65678: LD_INT 2
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: LD_INT 0
65687: PUSH
65688: LD_INT 2
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PUSH
65695: LD_INT 1
65697: NEG
65698: PUSH
65699: LD_INT 1
65701: PUSH
65702: EMPTY
65703: LIST
65704: LIST
65705: PUSH
65706: LD_INT 2
65708: NEG
65709: PUSH
65710: LD_INT 0
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 2
65719: NEG
65720: PUSH
65721: LD_INT 1
65723: NEG
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 2
65731: NEG
65732: PUSH
65733: LD_INT 2
65735: NEG
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: LIST
65748: LIST
65749: LIST
65750: LIST
65751: LIST
65752: LIST
65753: LIST
65754: LIST
65755: LIST
65756: LIST
65757: LIST
65758: LIST
65759: LIST
65760: LIST
65761: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65762: LD_ADDR_VAR 0 19
65766: PUSH
65767: LD_INT 0
65769: PUSH
65770: LD_INT 0
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: LD_INT 0
65779: PUSH
65780: LD_INT 1
65782: NEG
65783: PUSH
65784: EMPTY
65785: LIST
65786: LIST
65787: PUSH
65788: LD_INT 1
65790: PUSH
65791: LD_INT 0
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: PUSH
65798: LD_INT 1
65800: PUSH
65801: LD_INT 1
65803: PUSH
65804: EMPTY
65805: LIST
65806: LIST
65807: PUSH
65808: LD_INT 0
65810: PUSH
65811: LD_INT 1
65813: PUSH
65814: EMPTY
65815: LIST
65816: LIST
65817: PUSH
65818: LD_INT 1
65820: NEG
65821: PUSH
65822: LD_INT 0
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: PUSH
65829: LD_INT 1
65831: NEG
65832: PUSH
65833: LD_INT 1
65835: NEG
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 1
65843: NEG
65844: PUSH
65845: LD_INT 2
65847: NEG
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 0
65855: PUSH
65856: LD_INT 2
65858: NEG
65859: PUSH
65860: EMPTY
65861: LIST
65862: LIST
65863: PUSH
65864: LD_INT 1
65866: PUSH
65867: LD_INT 1
65869: NEG
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PUSH
65875: LD_INT 2
65877: PUSH
65878: LD_INT 0
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: PUSH
65885: LD_INT 2
65887: PUSH
65888: LD_INT 1
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 2
65897: PUSH
65898: LD_INT 2
65900: PUSH
65901: EMPTY
65902: LIST
65903: LIST
65904: PUSH
65905: LD_INT 1
65907: PUSH
65908: LD_INT 2
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: PUSH
65915: LD_INT 0
65917: PUSH
65918: LD_INT 2
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: PUSH
65925: LD_INT 1
65927: NEG
65928: PUSH
65929: LD_INT 1
65931: PUSH
65932: EMPTY
65933: LIST
65934: LIST
65935: PUSH
65936: LD_INT 2
65938: NEG
65939: PUSH
65940: LD_INT 0
65942: PUSH
65943: EMPTY
65944: LIST
65945: LIST
65946: PUSH
65947: LD_INT 2
65949: NEG
65950: PUSH
65951: LD_INT 1
65953: NEG
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: LD_INT 2
65961: NEG
65962: PUSH
65963: LD_INT 2
65965: NEG
65966: PUSH
65967: EMPTY
65968: LIST
65969: LIST
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: LIST
65987: LIST
65988: LIST
65989: LIST
65990: LIST
65991: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65992: LD_ADDR_VAR 0 20
65996: PUSH
65997: LD_INT 0
65999: PUSH
66000: LD_INT 0
66002: PUSH
66003: EMPTY
66004: LIST
66005: LIST
66006: PUSH
66007: LD_INT 0
66009: PUSH
66010: LD_INT 1
66012: NEG
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 1
66020: PUSH
66021: LD_INT 0
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: LD_INT 1
66030: PUSH
66031: LD_INT 1
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 0
66040: PUSH
66041: LD_INT 1
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PUSH
66048: LD_INT 1
66050: NEG
66051: PUSH
66052: LD_INT 0
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: LD_INT 1
66061: NEG
66062: PUSH
66063: LD_INT 1
66065: NEG
66066: PUSH
66067: EMPTY
66068: LIST
66069: LIST
66070: PUSH
66071: LD_INT 1
66073: NEG
66074: PUSH
66075: LD_INT 2
66077: NEG
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 0
66085: PUSH
66086: LD_INT 2
66088: NEG
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: PUSH
66094: LD_INT 1
66096: PUSH
66097: LD_INT 1
66099: NEG
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: PUSH
66105: LD_INT 2
66107: PUSH
66108: LD_INT 0
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 2
66117: PUSH
66118: LD_INT 1
66120: PUSH
66121: EMPTY
66122: LIST
66123: LIST
66124: PUSH
66125: LD_INT 2
66127: PUSH
66128: LD_INT 2
66130: PUSH
66131: EMPTY
66132: LIST
66133: LIST
66134: PUSH
66135: LD_INT 1
66137: PUSH
66138: LD_INT 2
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: LD_INT 0
66147: PUSH
66148: LD_INT 2
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: LD_INT 1
66157: NEG
66158: PUSH
66159: LD_INT 1
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 2
66168: NEG
66169: PUSH
66170: LD_INT 0
66172: PUSH
66173: EMPTY
66174: LIST
66175: LIST
66176: PUSH
66177: LD_INT 2
66179: NEG
66180: PUSH
66181: LD_INT 1
66183: NEG
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 2
66191: NEG
66192: PUSH
66193: LD_INT 2
66195: NEG
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66222: LD_ADDR_VAR 0 21
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: LD_INT 0
66232: PUSH
66233: EMPTY
66234: LIST
66235: LIST
66236: PUSH
66237: LD_INT 0
66239: PUSH
66240: LD_INT 1
66242: NEG
66243: PUSH
66244: EMPTY
66245: LIST
66246: LIST
66247: PUSH
66248: LD_INT 1
66250: PUSH
66251: LD_INT 0
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: PUSH
66258: LD_INT 1
66260: PUSH
66261: LD_INT 1
66263: PUSH
66264: EMPTY
66265: LIST
66266: LIST
66267: PUSH
66268: LD_INT 0
66270: PUSH
66271: LD_INT 1
66273: PUSH
66274: EMPTY
66275: LIST
66276: LIST
66277: PUSH
66278: LD_INT 1
66280: NEG
66281: PUSH
66282: LD_INT 0
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: LD_INT 1
66291: NEG
66292: PUSH
66293: LD_INT 1
66295: NEG
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PUSH
66301: LD_INT 1
66303: NEG
66304: PUSH
66305: LD_INT 2
66307: NEG
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 0
66315: PUSH
66316: LD_INT 2
66318: NEG
66319: PUSH
66320: EMPTY
66321: LIST
66322: LIST
66323: PUSH
66324: LD_INT 1
66326: PUSH
66327: LD_INT 1
66329: NEG
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PUSH
66335: LD_INT 2
66337: PUSH
66338: LD_INT 0
66340: PUSH
66341: EMPTY
66342: LIST
66343: LIST
66344: PUSH
66345: LD_INT 2
66347: PUSH
66348: LD_INT 1
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: PUSH
66355: LD_INT 2
66357: PUSH
66358: LD_INT 2
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: PUSH
66365: LD_INT 1
66367: PUSH
66368: LD_INT 2
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 0
66377: PUSH
66378: LD_INT 2
66380: PUSH
66381: EMPTY
66382: LIST
66383: LIST
66384: PUSH
66385: LD_INT 1
66387: NEG
66388: PUSH
66389: LD_INT 1
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PUSH
66396: LD_INT 2
66398: NEG
66399: PUSH
66400: LD_INT 0
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 2
66409: NEG
66410: PUSH
66411: LD_INT 1
66413: NEG
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 2
66421: NEG
66422: PUSH
66423: LD_INT 2
66425: NEG
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66452: LD_ADDR_VAR 0 22
66456: PUSH
66457: LD_INT 0
66459: PUSH
66460: LD_INT 0
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PUSH
66467: LD_INT 0
66469: PUSH
66470: LD_INT 1
66472: NEG
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 1
66480: PUSH
66481: LD_INT 0
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: PUSH
66491: LD_INT 1
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 0
66500: PUSH
66501: LD_INT 1
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: LD_INT 0
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 1
66521: NEG
66522: PUSH
66523: LD_INT 1
66525: NEG
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: LD_INT 1
66533: NEG
66534: PUSH
66535: LD_INT 2
66537: NEG
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: LD_INT 0
66545: PUSH
66546: LD_INT 2
66548: NEG
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 1
66556: PUSH
66557: LD_INT 1
66559: NEG
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 2
66567: PUSH
66568: LD_INT 0
66570: PUSH
66571: EMPTY
66572: LIST
66573: LIST
66574: PUSH
66575: LD_INT 2
66577: PUSH
66578: LD_INT 1
66580: PUSH
66581: EMPTY
66582: LIST
66583: LIST
66584: PUSH
66585: LD_INT 2
66587: PUSH
66588: LD_INT 2
66590: PUSH
66591: EMPTY
66592: LIST
66593: LIST
66594: PUSH
66595: LD_INT 1
66597: PUSH
66598: LD_INT 2
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: LD_INT 2
66610: PUSH
66611: EMPTY
66612: LIST
66613: LIST
66614: PUSH
66615: LD_INT 1
66617: NEG
66618: PUSH
66619: LD_INT 1
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 2
66628: NEG
66629: PUSH
66630: LD_INT 0
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: PUSH
66637: LD_INT 2
66639: NEG
66640: PUSH
66641: LD_INT 1
66643: NEG
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: PUSH
66649: LD_INT 2
66651: NEG
66652: PUSH
66653: LD_INT 2
66655: NEG
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: LIST
66674: LIST
66675: LIST
66676: LIST
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66682: LD_ADDR_VAR 0 23
66686: PUSH
66687: LD_INT 0
66689: PUSH
66690: LD_INT 0
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 0
66699: PUSH
66700: LD_INT 1
66702: NEG
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 1
66710: PUSH
66711: LD_INT 0
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 1
66720: PUSH
66721: LD_INT 1
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 0
66730: PUSH
66731: LD_INT 1
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: LD_INT 1
66740: NEG
66741: PUSH
66742: LD_INT 0
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: LD_INT 1
66751: NEG
66752: PUSH
66753: LD_INT 1
66755: NEG
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 1
66763: NEG
66764: PUSH
66765: LD_INT 2
66767: NEG
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 0
66775: PUSH
66776: LD_INT 2
66778: NEG
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 1
66786: PUSH
66787: LD_INT 1
66789: NEG
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 2
66797: PUSH
66798: LD_INT 0
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: PUSH
66805: LD_INT 2
66807: PUSH
66808: LD_INT 1
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: LD_INT 2
66817: PUSH
66818: LD_INT 2
66820: PUSH
66821: EMPTY
66822: LIST
66823: LIST
66824: PUSH
66825: LD_INT 1
66827: PUSH
66828: LD_INT 2
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 0
66837: PUSH
66838: LD_INT 2
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 1
66847: NEG
66848: PUSH
66849: LD_INT 1
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: LD_INT 2
66858: NEG
66859: PUSH
66860: LD_INT 0
66862: PUSH
66863: EMPTY
66864: LIST
66865: LIST
66866: PUSH
66867: LD_INT 2
66869: NEG
66870: PUSH
66871: LD_INT 1
66873: NEG
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PUSH
66879: LD_INT 2
66881: NEG
66882: PUSH
66883: LD_INT 2
66885: NEG
66886: PUSH
66887: EMPTY
66888: LIST
66889: LIST
66890: PUSH
66891: LD_INT 2
66893: NEG
66894: PUSH
66895: LD_INT 3
66897: NEG
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 1
66905: NEG
66906: PUSH
66907: LD_INT 3
66909: NEG
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: PUSH
66915: LD_INT 1
66917: PUSH
66918: LD_INT 2
66920: NEG
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 2
66928: PUSH
66929: LD_INT 1
66931: NEG
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: LIST
66961: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66962: LD_ADDR_VAR 0 24
66966: PUSH
66967: LD_INT 0
66969: PUSH
66970: LD_INT 0
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: PUSH
66977: LD_INT 0
66979: PUSH
66980: LD_INT 1
66982: NEG
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: PUSH
66988: LD_INT 1
66990: PUSH
66991: LD_INT 0
66993: PUSH
66994: EMPTY
66995: LIST
66996: LIST
66997: PUSH
66998: LD_INT 1
67000: PUSH
67001: LD_INT 1
67003: PUSH
67004: EMPTY
67005: LIST
67006: LIST
67007: PUSH
67008: LD_INT 0
67010: PUSH
67011: LD_INT 1
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: PUSH
67018: LD_INT 1
67020: NEG
67021: PUSH
67022: LD_INT 0
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PUSH
67029: LD_INT 1
67031: NEG
67032: PUSH
67033: LD_INT 1
67035: NEG
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PUSH
67041: LD_INT 1
67043: NEG
67044: PUSH
67045: LD_INT 2
67047: NEG
67048: PUSH
67049: EMPTY
67050: LIST
67051: LIST
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: LD_INT 2
67058: NEG
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 1
67066: PUSH
67067: LD_INT 1
67069: NEG
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 2
67077: PUSH
67078: LD_INT 0
67080: PUSH
67081: EMPTY
67082: LIST
67083: LIST
67084: PUSH
67085: LD_INT 2
67087: PUSH
67088: LD_INT 1
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: LD_INT 2
67097: PUSH
67098: LD_INT 2
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: PUSH
67105: LD_INT 1
67107: PUSH
67108: LD_INT 2
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 0
67117: PUSH
67118: LD_INT 2
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 1
67127: NEG
67128: PUSH
67129: LD_INT 1
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: PUSH
67136: LD_INT 2
67138: NEG
67139: PUSH
67140: LD_INT 0
67142: PUSH
67143: EMPTY
67144: LIST
67145: LIST
67146: PUSH
67147: LD_INT 2
67149: NEG
67150: PUSH
67151: LD_INT 1
67153: NEG
67154: PUSH
67155: EMPTY
67156: LIST
67157: LIST
67158: PUSH
67159: LD_INT 2
67161: NEG
67162: PUSH
67163: LD_INT 2
67165: NEG
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 1
67173: PUSH
67174: LD_INT 2
67176: NEG
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 2
67184: PUSH
67185: LD_INT 1
67187: NEG
67188: PUSH
67189: EMPTY
67190: LIST
67191: LIST
67192: PUSH
67193: LD_INT 3
67195: PUSH
67196: LD_INT 1
67198: PUSH
67199: EMPTY
67200: LIST
67201: LIST
67202: PUSH
67203: LD_INT 3
67205: PUSH
67206: LD_INT 2
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
67238: LD_ADDR_VAR 0 25
67242: PUSH
67243: LD_INT 0
67245: PUSH
67246: LD_INT 0
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: LD_INT 0
67255: PUSH
67256: LD_INT 1
67258: NEG
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: LD_INT 1
67266: PUSH
67267: LD_INT 0
67269: PUSH
67270: EMPTY
67271: LIST
67272: LIST
67273: PUSH
67274: LD_INT 1
67276: PUSH
67277: LD_INT 1
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 0
67286: PUSH
67287: LD_INT 1
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 1
67296: NEG
67297: PUSH
67298: LD_INT 0
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PUSH
67305: LD_INT 1
67307: NEG
67308: PUSH
67309: LD_INT 1
67311: NEG
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 1
67319: NEG
67320: PUSH
67321: LD_INT 2
67323: NEG
67324: PUSH
67325: EMPTY
67326: LIST
67327: LIST
67328: PUSH
67329: LD_INT 0
67331: PUSH
67332: LD_INT 2
67334: NEG
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 1
67342: PUSH
67343: LD_INT 1
67345: NEG
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: LD_INT 2
67353: PUSH
67354: LD_INT 0
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 2
67363: PUSH
67364: LD_INT 1
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 2
67373: PUSH
67374: LD_INT 2
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 1
67383: PUSH
67384: LD_INT 2
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 0
67393: PUSH
67394: LD_INT 2
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: LD_INT 1
67403: NEG
67404: PUSH
67405: LD_INT 1
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PUSH
67412: LD_INT 2
67414: NEG
67415: PUSH
67416: LD_INT 0
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: PUSH
67423: LD_INT 2
67425: NEG
67426: PUSH
67427: LD_INT 1
67429: NEG
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: PUSH
67435: LD_INT 2
67437: NEG
67438: PUSH
67439: LD_INT 2
67441: NEG
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 3
67449: PUSH
67450: LD_INT 1
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: LD_INT 3
67459: PUSH
67460: LD_INT 2
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: PUSH
67467: LD_INT 2
67469: PUSH
67470: LD_INT 3
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 1
67479: PUSH
67480: LD_INT 3
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: LIST
67511: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67512: LD_ADDR_VAR 0 26
67516: PUSH
67517: LD_INT 0
67519: PUSH
67520: LD_INT 0
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: LD_INT 0
67529: PUSH
67530: LD_INT 1
67532: NEG
67533: PUSH
67534: EMPTY
67535: LIST
67536: LIST
67537: PUSH
67538: LD_INT 1
67540: PUSH
67541: LD_INT 0
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 1
67550: PUSH
67551: LD_INT 1
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: LD_INT 1
67563: PUSH
67564: EMPTY
67565: LIST
67566: LIST
67567: PUSH
67568: LD_INT 1
67570: NEG
67571: PUSH
67572: LD_INT 0
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 1
67581: NEG
67582: PUSH
67583: LD_INT 1
67585: NEG
67586: PUSH
67587: EMPTY
67588: LIST
67589: LIST
67590: PUSH
67591: LD_INT 1
67593: NEG
67594: PUSH
67595: LD_INT 2
67597: NEG
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: PUSH
67603: LD_INT 0
67605: PUSH
67606: LD_INT 2
67608: NEG
67609: PUSH
67610: EMPTY
67611: LIST
67612: LIST
67613: PUSH
67614: LD_INT 1
67616: PUSH
67617: LD_INT 1
67619: NEG
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: PUSH
67625: LD_INT 2
67627: PUSH
67628: LD_INT 0
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 2
67637: PUSH
67638: LD_INT 1
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: PUSH
67645: LD_INT 2
67647: PUSH
67648: LD_INT 2
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 1
67657: PUSH
67658: LD_INT 2
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 0
67667: PUSH
67668: LD_INT 2
67670: PUSH
67671: EMPTY
67672: LIST
67673: LIST
67674: PUSH
67675: LD_INT 1
67677: NEG
67678: PUSH
67679: LD_INT 1
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 2
67688: NEG
67689: PUSH
67690: LD_INT 0
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: PUSH
67697: LD_INT 2
67699: NEG
67700: PUSH
67701: LD_INT 1
67703: NEG
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 2
67711: NEG
67712: PUSH
67713: LD_INT 2
67715: NEG
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: PUSH
67721: LD_INT 2
67723: PUSH
67724: LD_INT 3
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 1
67733: PUSH
67734: LD_INT 3
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 1
67743: NEG
67744: PUSH
67745: LD_INT 2
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PUSH
67752: LD_INT 2
67754: NEG
67755: PUSH
67756: LD_INT 1
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: PUSH
67763: EMPTY
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: LIST
67779: LIST
67780: LIST
67781: LIST
67782: LIST
67783: LIST
67784: LIST
67785: LIST
67786: LIST
67787: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67788: LD_ADDR_VAR 0 27
67792: PUSH
67793: LD_INT 0
67795: PUSH
67796: LD_INT 0
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 0
67805: PUSH
67806: LD_INT 1
67808: NEG
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 1
67816: PUSH
67817: LD_INT 0
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 1
67826: PUSH
67827: LD_INT 1
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: LD_INT 0
67836: PUSH
67837: LD_INT 1
67839: PUSH
67840: EMPTY
67841: LIST
67842: LIST
67843: PUSH
67844: LD_INT 1
67846: NEG
67847: PUSH
67848: LD_INT 0
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 1
67857: NEG
67858: PUSH
67859: LD_INT 1
67861: NEG
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 1
67869: NEG
67870: PUSH
67871: LD_INT 2
67873: NEG
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 0
67881: PUSH
67882: LD_INT 2
67884: NEG
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: LD_INT 1
67895: NEG
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 2
67903: PUSH
67904: LD_INT 0
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PUSH
67911: LD_INT 2
67913: PUSH
67914: LD_INT 1
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: LD_INT 2
67923: PUSH
67924: LD_INT 2
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: LD_INT 1
67933: PUSH
67934: LD_INT 2
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 0
67943: PUSH
67944: LD_INT 2
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 1
67953: NEG
67954: PUSH
67955: LD_INT 1
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: PUSH
67962: LD_INT 2
67964: NEG
67965: PUSH
67966: LD_INT 0
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: LD_INT 2
67975: NEG
67976: PUSH
67977: LD_INT 1
67979: NEG
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: PUSH
67985: LD_INT 2
67987: NEG
67988: PUSH
67989: LD_INT 2
67991: NEG
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: PUSH
67997: LD_INT 1
67999: NEG
68000: PUSH
68001: LD_INT 2
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: LD_INT 2
68010: NEG
68011: PUSH
68012: LD_INT 1
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 3
68021: NEG
68022: PUSH
68023: LD_INT 1
68025: NEG
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 3
68033: NEG
68034: PUSH
68035: LD_INT 2
68037: NEG
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
68068: LD_ADDR_VAR 0 28
68072: PUSH
68073: LD_INT 0
68075: PUSH
68076: LD_INT 0
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 0
68085: PUSH
68086: LD_INT 1
68088: NEG
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 1
68096: PUSH
68097: LD_INT 0
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: LD_INT 1
68106: PUSH
68107: LD_INT 1
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 0
68116: PUSH
68117: LD_INT 1
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: PUSH
68124: LD_INT 1
68126: NEG
68127: PUSH
68128: LD_INT 0
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PUSH
68135: LD_INT 1
68137: NEG
68138: PUSH
68139: LD_INT 1
68141: NEG
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: LD_INT 1
68149: NEG
68150: PUSH
68151: LD_INT 2
68153: NEG
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: LD_INT 0
68161: PUSH
68162: LD_INT 2
68164: NEG
68165: PUSH
68166: EMPTY
68167: LIST
68168: LIST
68169: PUSH
68170: LD_INT 1
68172: PUSH
68173: LD_INT 1
68175: NEG
68176: PUSH
68177: EMPTY
68178: LIST
68179: LIST
68180: PUSH
68181: LD_INT 2
68183: PUSH
68184: LD_INT 0
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 2
68193: PUSH
68194: LD_INT 1
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 2
68203: PUSH
68204: LD_INT 2
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 1
68213: PUSH
68214: LD_INT 2
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 0
68223: PUSH
68224: LD_INT 2
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: LD_INT 1
68233: NEG
68234: PUSH
68235: LD_INT 1
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 2
68244: NEG
68245: PUSH
68246: LD_INT 0
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 2
68255: NEG
68256: PUSH
68257: LD_INT 1
68259: NEG
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: PUSH
68265: LD_INT 2
68267: NEG
68268: PUSH
68269: LD_INT 2
68271: NEG
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 2
68279: NEG
68280: PUSH
68281: LD_INT 3
68283: NEG
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 1
68291: NEG
68292: PUSH
68293: LD_INT 3
68295: NEG
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 3
68303: NEG
68304: PUSH
68305: LD_INT 1
68307: NEG
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 3
68315: NEG
68316: PUSH
68317: LD_INT 2
68319: NEG
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: EMPTY
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68350: LD_ADDR_VAR 0 29
68354: PUSH
68355: LD_INT 0
68357: PUSH
68358: LD_INT 0
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: LD_INT 0
68367: PUSH
68368: LD_INT 1
68370: NEG
68371: PUSH
68372: EMPTY
68373: LIST
68374: LIST
68375: PUSH
68376: LD_INT 1
68378: PUSH
68379: LD_INT 0
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: LD_INT 1
68388: PUSH
68389: LD_INT 1
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 0
68398: PUSH
68399: LD_INT 1
68401: PUSH
68402: EMPTY
68403: LIST
68404: LIST
68405: PUSH
68406: LD_INT 1
68408: NEG
68409: PUSH
68410: LD_INT 0
68412: PUSH
68413: EMPTY
68414: LIST
68415: LIST
68416: PUSH
68417: LD_INT 1
68419: NEG
68420: PUSH
68421: LD_INT 1
68423: NEG
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: PUSH
68429: LD_INT 1
68431: NEG
68432: PUSH
68433: LD_INT 2
68435: NEG
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: LD_INT 2
68446: NEG
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PUSH
68452: LD_INT 1
68454: PUSH
68455: LD_INT 1
68457: NEG
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 2
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 2
68475: PUSH
68476: LD_INT 1
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 1
68485: PUSH
68486: LD_INT 2
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PUSH
68493: LD_INT 0
68495: PUSH
68496: LD_INT 2
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 1
68505: NEG
68506: PUSH
68507: LD_INT 1
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 2
68516: NEG
68517: PUSH
68518: LD_INT 1
68520: NEG
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 2
68528: NEG
68529: PUSH
68530: LD_INT 2
68532: NEG
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 2
68540: NEG
68541: PUSH
68542: LD_INT 3
68544: NEG
68545: PUSH
68546: EMPTY
68547: LIST
68548: LIST
68549: PUSH
68550: LD_INT 2
68552: PUSH
68553: LD_INT 1
68555: NEG
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 3
68563: PUSH
68564: LD_INT 1
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 1
68573: PUSH
68574: LD_INT 3
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 1
68583: NEG
68584: PUSH
68585: LD_INT 2
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 3
68594: NEG
68595: PUSH
68596: LD_INT 2
68598: NEG
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68629: LD_ADDR_VAR 0 30
68633: PUSH
68634: LD_INT 0
68636: PUSH
68637: LD_INT 0
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: PUSH
68644: LD_INT 0
68646: PUSH
68647: LD_INT 1
68649: NEG
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 1
68657: PUSH
68658: LD_INT 0
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: LD_INT 1
68667: PUSH
68668: LD_INT 1
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: PUSH
68675: LD_INT 0
68677: PUSH
68678: LD_INT 1
68680: PUSH
68681: EMPTY
68682: LIST
68683: LIST
68684: PUSH
68685: LD_INT 1
68687: NEG
68688: PUSH
68689: LD_INT 0
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: PUSH
68696: LD_INT 1
68698: NEG
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 1
68710: NEG
68711: PUSH
68712: LD_INT 2
68714: NEG
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: PUSH
68720: LD_INT 0
68722: PUSH
68723: LD_INT 2
68725: NEG
68726: PUSH
68727: EMPTY
68728: LIST
68729: LIST
68730: PUSH
68731: LD_INT 1
68733: PUSH
68734: LD_INT 1
68736: NEG
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: LD_INT 2
68744: PUSH
68745: LD_INT 0
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: LD_INT 2
68754: PUSH
68755: LD_INT 1
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 2
68764: PUSH
68765: LD_INT 2
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 1
68774: PUSH
68775: LD_INT 2
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 1
68784: NEG
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 2
68795: NEG
68796: PUSH
68797: LD_INT 0
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 2
68806: NEG
68807: PUSH
68808: LD_INT 1
68810: NEG
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 1
68818: NEG
68819: PUSH
68820: LD_INT 3
68822: NEG
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 1
68830: PUSH
68831: LD_INT 2
68833: NEG
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 3
68841: PUSH
68842: LD_INT 2
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: LD_INT 2
68851: PUSH
68852: LD_INT 3
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 2
68861: NEG
68862: PUSH
68863: LD_INT 1
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: PUSH
68870: LD_INT 3
68872: NEG
68873: PUSH
68874: LD_INT 1
68876: NEG
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68907: LD_ADDR_VAR 0 31
68911: PUSH
68912: LD_INT 0
68914: PUSH
68915: LD_INT 0
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 0
68924: PUSH
68925: LD_INT 1
68927: NEG
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 1
68935: PUSH
68936: LD_INT 0
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: PUSH
68943: LD_INT 1
68945: PUSH
68946: LD_INT 1
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: PUSH
68953: LD_INT 0
68955: PUSH
68956: LD_INT 1
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 1
68965: NEG
68966: PUSH
68967: LD_INT 0
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: NEG
68977: PUSH
68978: LD_INT 1
68980: NEG
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 1
68988: NEG
68989: PUSH
68990: LD_INT 2
68992: NEG
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: LD_INT 1
69003: NEG
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: LD_INT 2
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 2
69021: PUSH
69022: LD_INT 1
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 2
69031: PUSH
69032: LD_INT 2
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 1
69041: PUSH
69042: LD_INT 2
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 0
69051: PUSH
69052: LD_INT 2
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 1
69061: NEG
69062: PUSH
69063: LD_INT 1
69065: PUSH
69066: EMPTY
69067: LIST
69068: LIST
69069: PUSH
69070: LD_INT 2
69072: NEG
69073: PUSH
69074: LD_INT 1
69076: NEG
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 2
69084: NEG
69085: PUSH
69086: LD_INT 2
69088: NEG
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: PUSH
69094: LD_INT 2
69096: NEG
69097: PUSH
69098: LD_INT 3
69100: NEG
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 2
69108: PUSH
69109: LD_INT 1
69111: NEG
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: LD_INT 3
69119: PUSH
69120: LD_INT 1
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 1
69129: PUSH
69130: LD_INT 3
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 1
69139: NEG
69140: PUSH
69141: LD_INT 2
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: LD_INT 3
69150: NEG
69151: PUSH
69152: LD_INT 2
69154: NEG
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69185: LD_ADDR_VAR 0 32
69189: PUSH
69190: LD_INT 0
69192: PUSH
69193: LD_INT 0
69195: PUSH
69196: EMPTY
69197: LIST
69198: LIST
69199: PUSH
69200: LD_INT 0
69202: PUSH
69203: LD_INT 1
69205: NEG
69206: PUSH
69207: EMPTY
69208: LIST
69209: LIST
69210: PUSH
69211: LD_INT 1
69213: PUSH
69214: LD_INT 0
69216: PUSH
69217: EMPTY
69218: LIST
69219: LIST
69220: PUSH
69221: LD_INT 1
69223: PUSH
69224: LD_INT 1
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 0
69233: PUSH
69234: LD_INT 1
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 1
69243: NEG
69244: PUSH
69245: LD_INT 0
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PUSH
69252: LD_INT 1
69254: NEG
69255: PUSH
69256: LD_INT 1
69258: NEG
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 1
69266: NEG
69267: PUSH
69268: LD_INT 2
69270: NEG
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: LD_INT 0
69278: PUSH
69279: LD_INT 2
69281: NEG
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PUSH
69287: LD_INT 1
69289: PUSH
69290: LD_INT 1
69292: NEG
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 2
69300: PUSH
69301: LD_INT 1
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: PUSH
69308: LD_INT 2
69310: PUSH
69311: LD_INT 2
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 1
69320: PUSH
69321: LD_INT 2
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 0
69330: PUSH
69331: LD_INT 2
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 1
69340: NEG
69341: PUSH
69342: LD_INT 1
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 2
69351: NEG
69352: PUSH
69353: LD_INT 0
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 2
69362: NEG
69363: PUSH
69364: LD_INT 1
69366: NEG
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 1
69374: NEG
69375: PUSH
69376: LD_INT 3
69378: NEG
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 1
69386: PUSH
69387: LD_INT 2
69389: NEG
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 3
69397: PUSH
69398: LD_INT 2
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: PUSH
69405: LD_INT 2
69407: PUSH
69408: LD_INT 3
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: LD_INT 2
69417: NEG
69418: PUSH
69419: LD_INT 1
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 3
69428: NEG
69429: PUSH
69430: LD_INT 1
69432: NEG
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: LIST
69442: LIST
69443: LIST
69444: LIST
69445: LIST
69446: LIST
69447: LIST
69448: LIST
69449: LIST
69450: LIST
69451: LIST
69452: LIST
69453: LIST
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: LIST
69460: LIST
69461: LIST
69462: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69463: LD_ADDR_VAR 0 33
69467: PUSH
69468: LD_INT 0
69470: PUSH
69471: LD_INT 0
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 0
69480: PUSH
69481: LD_INT 1
69483: NEG
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: LD_INT 1
69491: PUSH
69492: LD_INT 0
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: PUSH
69499: LD_INT 1
69501: PUSH
69502: LD_INT 1
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: PUSH
69509: LD_INT 0
69511: PUSH
69512: LD_INT 1
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: PUSH
69519: LD_INT 1
69521: NEG
69522: PUSH
69523: LD_INT 0
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 1
69532: NEG
69533: PUSH
69534: LD_INT 1
69536: NEG
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 1
69544: NEG
69545: PUSH
69546: LD_INT 2
69548: NEG
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 2
69567: PUSH
69568: LD_INT 0
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 2
69577: PUSH
69578: LD_INT 1
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 1
69587: PUSH
69588: LD_INT 2
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: PUSH
69595: LD_INT 0
69597: PUSH
69598: LD_INT 2
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: LD_INT 1
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 2
69618: NEG
69619: PUSH
69620: LD_INT 0
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 2
69629: NEG
69630: PUSH
69631: LD_INT 1
69633: NEG
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: PUSH
69639: LD_INT 2
69641: NEG
69642: PUSH
69643: LD_INT 2
69645: NEG
69646: PUSH
69647: EMPTY
69648: LIST
69649: LIST
69650: PUSH
69651: LD_INT 2
69653: NEG
69654: PUSH
69655: LD_INT 3
69657: NEG
69658: PUSH
69659: EMPTY
69660: LIST
69661: LIST
69662: PUSH
69663: LD_INT 2
69665: PUSH
69666: LD_INT 1
69668: NEG
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 3
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 1
69686: PUSH
69687: LD_INT 3
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 1
69696: NEG
69697: PUSH
69698: LD_INT 2
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 3
69707: NEG
69708: PUSH
69709: LD_INT 2
69711: NEG
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: LIST
69723: LIST
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69742: LD_ADDR_VAR 0 34
69746: PUSH
69747: LD_INT 0
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 0
69759: PUSH
69760: LD_INT 1
69762: NEG
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 1
69770: PUSH
69771: LD_INT 0
69773: PUSH
69774: EMPTY
69775: LIST
69776: LIST
69777: PUSH
69778: LD_INT 1
69780: PUSH
69781: LD_INT 1
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 0
69790: PUSH
69791: LD_INT 1
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: LD_INT 1
69800: NEG
69801: PUSH
69802: LD_INT 0
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: NEG
69812: PUSH
69813: LD_INT 1
69815: NEG
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 1
69823: NEG
69824: PUSH
69825: LD_INT 2
69827: NEG
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 0
69835: PUSH
69836: LD_INT 2
69838: NEG
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 1
69846: PUSH
69847: LD_INT 1
69849: NEG
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 2
69857: PUSH
69858: LD_INT 1
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: PUSH
69865: LD_INT 2
69867: PUSH
69868: LD_INT 2
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 1
69877: PUSH
69878: LD_INT 2
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PUSH
69885: LD_INT 1
69887: NEG
69888: PUSH
69889: LD_INT 1
69891: PUSH
69892: EMPTY
69893: LIST
69894: LIST
69895: PUSH
69896: LD_INT 2
69898: NEG
69899: PUSH
69900: LD_INT 0
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 2
69909: NEG
69910: PUSH
69911: LD_INT 1
69913: NEG
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 2
69921: NEG
69922: PUSH
69923: LD_INT 2
69925: NEG
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 1
69933: NEG
69934: PUSH
69935: LD_INT 3
69937: NEG
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PUSH
69943: LD_INT 1
69945: PUSH
69946: LD_INT 2
69948: NEG
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: PUSH
69954: LD_INT 3
69956: PUSH
69957: LD_INT 2
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 2
69966: PUSH
69967: LD_INT 3
69969: PUSH
69970: EMPTY
69971: LIST
69972: LIST
69973: PUSH
69974: LD_INT 2
69976: NEG
69977: PUSH
69978: LD_INT 1
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 3
69987: NEG
69988: PUSH
69989: LD_INT 1
69991: NEG
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: LIST
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70022: LD_ADDR_VAR 0 35
70026: PUSH
70027: LD_INT 0
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 0
70039: PUSH
70040: LD_INT 1
70042: NEG
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PUSH
70048: LD_INT 1
70050: PUSH
70051: LD_INT 0
70053: PUSH
70054: EMPTY
70055: LIST
70056: LIST
70057: PUSH
70058: LD_INT 1
70060: PUSH
70061: LD_INT 1
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 0
70070: PUSH
70071: LD_INT 1
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 1
70080: NEG
70081: PUSH
70082: LD_INT 0
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: LD_INT 1
70091: NEG
70092: PUSH
70093: LD_INT 1
70095: NEG
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 2
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: NEG
70114: PUSH
70115: LD_INT 1
70117: NEG
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70134: LD_ADDR_VAR 0 36
70138: PUSH
70139: LD_INT 0
70141: PUSH
70142: LD_INT 0
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PUSH
70149: LD_INT 0
70151: PUSH
70152: LD_INT 1
70154: NEG
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 1
70162: PUSH
70163: LD_INT 0
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: PUSH
70170: LD_INT 1
70172: PUSH
70173: LD_INT 1
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 0
70182: PUSH
70183: LD_INT 1
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 1
70192: NEG
70193: PUSH
70194: LD_INT 0
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: NEG
70204: PUSH
70205: LD_INT 1
70207: NEG
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: LD_INT 1
70215: NEG
70216: PUSH
70217: LD_INT 2
70219: NEG
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: PUSH
70225: LD_INT 1
70227: PUSH
70228: LD_INT 2
70230: PUSH
70231: EMPTY
70232: LIST
70233: LIST
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70246: LD_ADDR_VAR 0 37
70250: PUSH
70251: LD_INT 0
70253: PUSH
70254: LD_INT 0
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 1
70274: PUSH
70275: LD_INT 0
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 1
70284: PUSH
70285: LD_INT 1
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: LD_INT 0
70294: PUSH
70295: LD_INT 1
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: LD_INT 1
70304: NEG
70305: PUSH
70306: LD_INT 0
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: LD_INT 1
70319: NEG
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 1
70327: PUSH
70328: LD_INT 1
70330: NEG
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 1
70338: NEG
70339: PUSH
70340: LD_INT 1
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: LIST
70351: LIST
70352: LIST
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70358: LD_ADDR_VAR 0 38
70362: PUSH
70363: LD_INT 0
70365: PUSH
70366: LD_INT 0
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: LD_INT 1
70378: NEG
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: LD_INT 0
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 1
70396: PUSH
70397: LD_INT 1
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 0
70406: PUSH
70407: LD_INT 1
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: LD_INT 1
70416: NEG
70417: PUSH
70418: LD_INT 0
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 1
70427: NEG
70428: PUSH
70429: LD_INT 1
70431: NEG
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 2
70439: PUSH
70440: LD_INT 1
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 2
70449: NEG
70450: PUSH
70451: LD_INT 1
70453: NEG
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70470: LD_ADDR_VAR 0 39
70474: PUSH
70475: LD_INT 0
70477: PUSH
70478: LD_INT 0
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 0
70487: PUSH
70488: LD_INT 1
70490: NEG
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: PUSH
70496: LD_INT 1
70498: PUSH
70499: LD_INT 0
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: PUSH
70506: LD_INT 1
70508: PUSH
70509: LD_INT 1
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: PUSH
70516: LD_INT 0
70518: PUSH
70519: LD_INT 1
70521: PUSH
70522: EMPTY
70523: LIST
70524: LIST
70525: PUSH
70526: LD_INT 1
70528: NEG
70529: PUSH
70530: LD_INT 0
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 1
70539: NEG
70540: PUSH
70541: LD_INT 1
70543: NEG
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 1
70551: NEG
70552: PUSH
70553: LD_INT 2
70555: NEG
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: PUSH
70561: LD_INT 1
70563: PUSH
70564: LD_INT 2
70566: PUSH
70567: EMPTY
70568: LIST
70569: LIST
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70582: LD_ADDR_VAR 0 40
70586: PUSH
70587: LD_INT 0
70589: PUSH
70590: LD_INT 0
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PUSH
70597: LD_INT 0
70599: PUSH
70600: LD_INT 1
70602: NEG
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 1
70610: PUSH
70611: LD_INT 0
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 1
70620: PUSH
70621: LD_INT 1
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: LD_INT 0
70630: PUSH
70631: LD_INT 1
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: PUSH
70638: LD_INT 1
70640: NEG
70641: PUSH
70642: LD_INT 0
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 1
70651: NEG
70652: PUSH
70653: LD_INT 1
70655: NEG
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: LD_INT 1
70663: PUSH
70664: LD_INT 1
70666: NEG
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 1
70674: NEG
70675: PUSH
70676: LD_INT 1
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70694: LD_ADDR_VAR 0 41
70698: PUSH
70699: LD_INT 0
70701: PUSH
70702: LD_INT 0
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 0
70711: PUSH
70712: LD_INT 1
70714: NEG
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 1
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: PUSH
70733: LD_INT 1
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 0
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 1
70752: NEG
70753: PUSH
70754: LD_INT 0
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 1
70763: NEG
70764: PUSH
70765: LD_INT 1
70767: NEG
70768: PUSH
70769: EMPTY
70770: LIST
70771: LIST
70772: PUSH
70773: LD_INT 1
70775: NEG
70776: PUSH
70777: LD_INT 2
70779: NEG
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 1
70787: PUSH
70788: LD_INT 1
70790: NEG
70791: PUSH
70792: EMPTY
70793: LIST
70794: LIST
70795: PUSH
70796: LD_INT 2
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PUSH
70806: LD_INT 2
70808: PUSH
70809: LD_INT 1
70811: PUSH
70812: EMPTY
70813: LIST
70814: LIST
70815: PUSH
70816: LD_INT 2
70818: PUSH
70819: LD_INT 2
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: PUSH
70826: LD_INT 1
70828: PUSH
70829: LD_INT 2
70831: PUSH
70832: EMPTY
70833: LIST
70834: LIST
70835: PUSH
70836: LD_INT 1
70838: NEG
70839: PUSH
70840: LD_INT 1
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PUSH
70847: LD_INT 2
70849: NEG
70850: PUSH
70851: LD_INT 0
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 2
70860: NEG
70861: PUSH
70862: LD_INT 1
70864: NEG
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 2
70872: NEG
70873: PUSH
70874: LD_INT 2
70876: NEG
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: NEG
70885: PUSH
70886: LD_INT 3
70888: NEG
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: LD_INT 2
70896: PUSH
70897: LD_INT 1
70899: NEG
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 3
70907: PUSH
70908: LD_INT 0
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 3
70917: PUSH
70918: LD_INT 1
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 3
70927: PUSH
70928: LD_INT 2
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 3
70937: PUSH
70938: LD_INT 3
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 2
70947: PUSH
70948: LD_INT 3
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 2
70957: NEG
70958: PUSH
70959: LD_INT 1
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 3
70968: NEG
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 3
70979: NEG
70980: PUSH
70981: LD_INT 1
70983: NEG
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 3
70991: NEG
70992: PUSH
70993: LD_INT 2
70995: NEG
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 3
71003: NEG
71004: PUSH
71005: LD_INT 3
71007: NEG
71008: PUSH
71009: EMPTY
71010: LIST
71011: LIST
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: LIST
71042: LIST
71043: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71044: LD_ADDR_VAR 0 42
71048: PUSH
71049: LD_INT 0
71051: PUSH
71052: LD_INT 0
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 0
71061: PUSH
71062: LD_INT 1
71064: NEG
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: LD_INT 1
71072: PUSH
71073: LD_INT 0
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 1
71082: PUSH
71083: LD_INT 1
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: LD_INT 0
71092: PUSH
71093: LD_INT 1
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 1
71102: NEG
71103: PUSH
71104: LD_INT 0
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PUSH
71111: LD_INT 1
71113: NEG
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 1
71125: NEG
71126: PUSH
71127: LD_INT 2
71129: NEG
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 0
71137: PUSH
71138: LD_INT 2
71140: NEG
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 1
71148: PUSH
71149: LD_INT 1
71151: NEG
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 2
71159: PUSH
71160: LD_INT 1
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 2
71169: PUSH
71170: LD_INT 2
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 1
71179: PUSH
71180: LD_INT 2
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: PUSH
71187: LD_INT 0
71189: PUSH
71190: LD_INT 2
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 1
71199: NEG
71200: PUSH
71201: LD_INT 1
71203: PUSH
71204: EMPTY
71205: LIST
71206: LIST
71207: PUSH
71208: LD_INT 2
71210: NEG
71211: PUSH
71212: LD_INT 1
71214: NEG
71215: PUSH
71216: EMPTY
71217: LIST
71218: LIST
71219: PUSH
71220: LD_INT 2
71222: NEG
71223: PUSH
71224: LD_INT 2
71226: NEG
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 2
71234: NEG
71235: PUSH
71236: LD_INT 3
71238: NEG
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 1
71246: NEG
71247: PUSH
71248: LD_INT 3
71250: NEG
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: LD_INT 0
71258: PUSH
71259: LD_INT 3
71261: NEG
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 1
71269: PUSH
71270: LD_INT 2
71272: NEG
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 3
71280: PUSH
71281: LD_INT 2
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 3
71290: PUSH
71291: LD_INT 3
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: PUSH
71298: LD_INT 2
71300: PUSH
71301: LD_INT 3
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 1
71310: PUSH
71311: LD_INT 3
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 0
71320: PUSH
71321: LD_INT 3
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 1
71330: NEG
71331: PUSH
71332: LD_INT 2
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PUSH
71339: LD_INT 3
71341: NEG
71342: PUSH
71343: LD_INT 2
71345: NEG
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 3
71353: NEG
71354: PUSH
71355: LD_INT 3
71357: NEG
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: LIST
71386: LIST
71387: LIST
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: LIST
71393: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71394: LD_ADDR_VAR 0 43
71398: PUSH
71399: LD_INT 0
71401: PUSH
71402: LD_INT 0
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 0
71411: PUSH
71412: LD_INT 1
71414: NEG
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: PUSH
71420: LD_INT 1
71422: PUSH
71423: LD_INT 0
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: PUSH
71430: LD_INT 1
71432: PUSH
71433: LD_INT 1
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: PUSH
71440: LD_INT 0
71442: PUSH
71443: LD_INT 1
71445: PUSH
71446: EMPTY
71447: LIST
71448: LIST
71449: PUSH
71450: LD_INT 1
71452: NEG
71453: PUSH
71454: LD_INT 0
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: LD_INT 1
71463: NEG
71464: PUSH
71465: LD_INT 1
71467: NEG
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 1
71475: NEG
71476: PUSH
71477: LD_INT 2
71479: NEG
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 0
71487: PUSH
71488: LD_INT 2
71490: NEG
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 1
71498: PUSH
71499: LD_INT 1
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 2
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 2
71519: PUSH
71520: LD_INT 1
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 1
71529: PUSH
71530: LD_INT 2
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: PUSH
71537: LD_INT 0
71539: PUSH
71540: LD_INT 2
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 1
71549: NEG
71550: PUSH
71551: LD_INT 1
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PUSH
71558: LD_INT 2
71560: NEG
71561: PUSH
71562: LD_INT 0
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 2
71571: NEG
71572: PUSH
71573: LD_INT 1
71575: NEG
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: LD_INT 3
71587: NEG
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 0
71595: PUSH
71596: LD_INT 3
71598: NEG
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 1
71606: PUSH
71607: LD_INT 2
71609: NEG
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 2
71617: PUSH
71618: LD_INT 1
71620: NEG
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 3
71628: PUSH
71629: LD_INT 0
71631: PUSH
71632: EMPTY
71633: LIST
71634: LIST
71635: PUSH
71636: LD_INT 3
71638: PUSH
71639: LD_INT 1
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PUSH
71646: LD_INT 1
71648: PUSH
71649: LD_INT 3
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 0
71658: PUSH
71659: LD_INT 3
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 1
71668: NEG
71669: PUSH
71670: LD_INT 2
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 2
71679: NEG
71680: PUSH
71681: LD_INT 1
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 3
71690: NEG
71691: PUSH
71692: LD_INT 0
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 3
71701: NEG
71702: PUSH
71703: LD_INT 1
71705: NEG
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: LIST
71734: LIST
71735: LIST
71736: LIST
71737: LIST
71738: LIST
71739: LIST
71740: LIST
71741: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71742: LD_ADDR_VAR 0 44
71746: PUSH
71747: LD_INT 0
71749: PUSH
71750: LD_INT 0
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 0
71759: PUSH
71760: LD_INT 1
71762: NEG
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 1
71770: PUSH
71771: LD_INT 0
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 1
71780: PUSH
71781: LD_INT 1
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 0
71790: PUSH
71791: LD_INT 1
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: LD_INT 1
71800: NEG
71801: PUSH
71802: LD_INT 0
71804: PUSH
71805: EMPTY
71806: LIST
71807: LIST
71808: PUSH
71809: LD_INT 1
71811: NEG
71812: PUSH
71813: LD_INT 1
71815: NEG
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PUSH
71821: LD_INT 1
71823: NEG
71824: PUSH
71825: LD_INT 2
71827: NEG
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PUSH
71833: LD_INT 1
71835: PUSH
71836: LD_INT 1
71838: NEG
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 2
71846: PUSH
71847: LD_INT 0
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 2
71856: PUSH
71857: LD_INT 1
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: LD_INT 2
71866: PUSH
71867: LD_INT 2
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: LD_INT 1
71876: PUSH
71877: LD_INT 2
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 1
71886: NEG
71887: PUSH
71888: LD_INT 1
71890: PUSH
71891: EMPTY
71892: LIST
71893: LIST
71894: PUSH
71895: LD_INT 2
71897: NEG
71898: PUSH
71899: LD_INT 0
71901: PUSH
71902: EMPTY
71903: LIST
71904: LIST
71905: PUSH
71906: LD_INT 2
71908: NEG
71909: PUSH
71910: LD_INT 1
71912: NEG
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: LD_INT 2
71920: NEG
71921: PUSH
71922: LD_INT 2
71924: NEG
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 2
71932: NEG
71933: PUSH
71934: LD_INT 3
71936: NEG
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PUSH
71942: LD_INT 2
71944: PUSH
71945: LD_INT 1
71947: NEG
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: LD_INT 3
71955: PUSH
71956: LD_INT 0
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 3
71965: PUSH
71966: LD_INT 1
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 3
71975: PUSH
71976: LD_INT 2
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: PUSH
71983: LD_INT 3
71985: PUSH
71986: LD_INT 3
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 2
71995: PUSH
71996: LD_INT 3
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 2
72005: NEG
72006: PUSH
72007: LD_INT 1
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 3
72016: NEG
72017: PUSH
72018: LD_INT 0
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 3
72027: NEG
72028: PUSH
72029: LD_INT 1
72031: NEG
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: PUSH
72037: LD_INT 3
72039: NEG
72040: PUSH
72041: LD_INT 2
72043: NEG
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 3
72051: NEG
72052: PUSH
72053: LD_INT 3
72055: NEG
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: LIST
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: LIST
72083: LIST
72084: LIST
72085: LIST
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72092: LD_ADDR_VAR 0 45
72096: PUSH
72097: LD_INT 0
72099: PUSH
72100: LD_INT 0
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: LD_INT 1
72112: NEG
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: LD_INT 1
72120: PUSH
72121: LD_INT 0
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: PUSH
72131: LD_INT 1
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 0
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 1
72150: NEG
72151: PUSH
72152: LD_INT 0
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: LD_INT 1
72161: NEG
72162: PUSH
72163: LD_INT 1
72165: NEG
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 1
72173: NEG
72174: PUSH
72175: LD_INT 2
72177: NEG
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: LD_INT 0
72185: PUSH
72186: LD_INT 2
72188: NEG
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 1
72196: PUSH
72197: LD_INT 1
72199: NEG
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 2
72207: PUSH
72208: LD_INT 1
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 2
72217: PUSH
72218: LD_INT 2
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 1
72227: PUSH
72228: LD_INT 2
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 0
72237: PUSH
72238: LD_INT 2
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 1
72247: NEG
72248: PUSH
72249: LD_INT 1
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 2
72258: NEG
72259: PUSH
72260: LD_INT 1
72262: NEG
72263: PUSH
72264: EMPTY
72265: LIST
72266: LIST
72267: PUSH
72268: LD_INT 2
72270: NEG
72271: PUSH
72272: LD_INT 2
72274: NEG
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: PUSH
72280: LD_INT 2
72282: NEG
72283: PUSH
72284: LD_INT 3
72286: NEG
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 1
72294: NEG
72295: PUSH
72296: LD_INT 3
72298: NEG
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 0
72306: PUSH
72307: LD_INT 3
72309: NEG
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 1
72317: PUSH
72318: LD_INT 2
72320: NEG
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: LD_INT 3
72328: PUSH
72329: LD_INT 2
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PUSH
72336: LD_INT 3
72338: PUSH
72339: LD_INT 3
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 2
72348: PUSH
72349: LD_INT 3
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 1
72358: PUSH
72359: LD_INT 3
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 0
72368: PUSH
72369: LD_INT 3
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 1
72378: NEG
72379: PUSH
72380: LD_INT 2
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 3
72389: NEG
72390: PUSH
72391: LD_INT 2
72393: NEG
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 3
72401: NEG
72402: PUSH
72403: LD_INT 3
72405: NEG
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: LIST
72441: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72442: LD_ADDR_VAR 0 46
72446: PUSH
72447: LD_INT 0
72449: PUSH
72450: LD_INT 0
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 0
72459: PUSH
72460: LD_INT 1
72462: NEG
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: LD_INT 0
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 1
72480: PUSH
72481: LD_INT 1
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 0
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: NEG
72501: PUSH
72502: LD_INT 0
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: LD_INT 1
72515: NEG
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: PUSH
72521: LD_INT 1
72523: NEG
72524: PUSH
72525: LD_INT 2
72527: NEG
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 0
72535: PUSH
72536: LD_INT 2
72538: NEG
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: PUSH
72547: LD_INT 1
72549: NEG
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: PUSH
72555: LD_INT 2
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 2
72567: PUSH
72568: LD_INT 1
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: LD_INT 1
72577: PUSH
72578: LD_INT 2
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 0
72587: PUSH
72588: LD_INT 2
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 1
72597: NEG
72598: PUSH
72599: LD_INT 1
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 2
72608: NEG
72609: PUSH
72610: LD_INT 0
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 2
72619: NEG
72620: PUSH
72621: LD_INT 1
72623: NEG
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PUSH
72629: LD_INT 1
72631: NEG
72632: PUSH
72633: LD_INT 3
72635: NEG
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: PUSH
72641: LD_INT 0
72643: PUSH
72644: LD_INT 3
72646: NEG
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 1
72654: PUSH
72655: LD_INT 2
72657: NEG
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: LD_INT 2
72665: PUSH
72666: LD_INT 1
72668: NEG
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 3
72676: PUSH
72677: LD_INT 0
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 3
72686: PUSH
72687: LD_INT 1
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 1
72696: PUSH
72697: LD_INT 3
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 0
72706: PUSH
72707: LD_INT 3
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 1
72716: NEG
72717: PUSH
72718: LD_INT 2
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 2
72727: NEG
72728: PUSH
72729: LD_INT 1
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 3
72738: NEG
72739: PUSH
72740: LD_INT 0
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: PUSH
72747: LD_INT 3
72749: NEG
72750: PUSH
72751: LD_INT 1
72753: NEG
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: LIST
72763: LIST
72764: LIST
72765: LIST
72766: LIST
72767: LIST
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: LIST
72783: LIST
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: LIST
72789: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72790: LD_ADDR_VAR 0 47
72794: PUSH
72795: LD_INT 0
72797: PUSH
72798: LD_INT 0
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: PUSH
72805: LD_INT 0
72807: PUSH
72808: LD_INT 1
72810: NEG
72811: PUSH
72812: EMPTY
72813: LIST
72814: LIST
72815: PUSH
72816: LD_INT 1
72818: PUSH
72819: LD_INT 0
72821: PUSH
72822: EMPTY
72823: LIST
72824: LIST
72825: PUSH
72826: LD_INT 1
72828: PUSH
72829: LD_INT 1
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 0
72838: PUSH
72839: LD_INT 1
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PUSH
72846: LD_INT 1
72848: NEG
72849: PUSH
72850: LD_INT 0
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 1
72859: NEG
72860: PUSH
72861: LD_INT 1
72863: NEG
72864: PUSH
72865: EMPTY
72866: LIST
72867: LIST
72868: PUSH
72869: LD_INT 1
72871: NEG
72872: PUSH
72873: LD_INT 2
72875: NEG
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: PUSH
72881: LD_INT 0
72883: PUSH
72884: LD_INT 2
72886: NEG
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: LD_INT 1
72894: PUSH
72895: LD_INT 1
72897: NEG
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 2
72905: NEG
72906: PUSH
72907: LD_INT 1
72909: NEG
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 2
72917: NEG
72918: PUSH
72919: LD_INT 2
72921: NEG
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: LIST
72931: LIST
72932: LIST
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: LIST
72939: LIST
72940: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72941: LD_ADDR_VAR 0 48
72945: PUSH
72946: LD_INT 0
72948: PUSH
72949: LD_INT 0
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: PUSH
72956: LD_INT 0
72958: PUSH
72959: LD_INT 1
72961: NEG
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 1
72969: PUSH
72970: LD_INT 0
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: LD_INT 1
72979: PUSH
72980: LD_INT 1
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 0
72989: PUSH
72990: LD_INT 1
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 1
72999: NEG
73000: PUSH
73001: LD_INT 0
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: LD_INT 1
73010: NEG
73011: PUSH
73012: LD_INT 1
73014: NEG
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 1
73022: NEG
73023: PUSH
73024: LD_INT 2
73026: NEG
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 0
73034: PUSH
73035: LD_INT 2
73037: NEG
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 1
73045: PUSH
73046: LD_INT 1
73048: NEG
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PUSH
73054: LD_INT 2
73056: PUSH
73057: LD_INT 0
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PUSH
73064: LD_INT 2
73066: PUSH
73067: LD_INT 1
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: LIST
73078: LIST
73079: LIST
73080: LIST
73081: LIST
73082: LIST
73083: LIST
73084: LIST
73085: LIST
73086: LIST
73087: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
73088: LD_ADDR_VAR 0 49
73092: PUSH
73093: LD_INT 0
73095: PUSH
73096: LD_INT 0
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: LD_INT 1
73108: NEG
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 1
73116: PUSH
73117: LD_INT 0
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 1
73126: PUSH
73127: LD_INT 1
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 0
73136: PUSH
73137: LD_INT 1
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 1
73146: NEG
73147: PUSH
73148: LD_INT 0
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 1
73157: NEG
73158: PUSH
73159: LD_INT 1
73161: NEG
73162: PUSH
73163: EMPTY
73164: LIST
73165: LIST
73166: PUSH
73167: LD_INT 1
73169: PUSH
73170: LD_INT 1
73172: NEG
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: LD_INT 2
73180: PUSH
73181: LD_INT 0
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PUSH
73188: LD_INT 2
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: LD_INT 2
73200: PUSH
73201: LD_INT 2
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: LD_INT 1
73210: PUSH
73211: LD_INT 2
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
73232: LD_ADDR_VAR 0 50
73236: PUSH
73237: LD_INT 0
73239: PUSH
73240: LD_INT 0
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 0
73249: PUSH
73250: LD_INT 1
73252: NEG
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 1
73260: PUSH
73261: LD_INT 0
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 1
73270: PUSH
73271: LD_INT 1
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 0
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 1
73290: NEG
73291: PUSH
73292: LD_INT 0
73294: PUSH
73295: EMPTY
73296: LIST
73297: LIST
73298: PUSH
73299: LD_INT 1
73301: NEG
73302: PUSH
73303: LD_INT 1
73305: NEG
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 2
73313: PUSH
73314: LD_INT 1
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: LD_INT 2
73323: PUSH
73324: LD_INT 2
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 1
73333: PUSH
73334: LD_INT 2
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: LD_INT 0
73343: PUSH
73344: LD_INT 2
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: PUSH
73351: LD_INT 1
73353: NEG
73354: PUSH
73355: LD_INT 1
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73376: LD_ADDR_VAR 0 51
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: LD_INT 0
73393: PUSH
73394: LD_INT 1
73396: NEG
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 1
73404: PUSH
73405: LD_INT 0
73407: PUSH
73408: EMPTY
73409: LIST
73410: LIST
73411: PUSH
73412: LD_INT 1
73414: PUSH
73415: LD_INT 1
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 0
73424: PUSH
73425: LD_INT 1
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: LD_INT 1
73434: NEG
73435: PUSH
73436: LD_INT 0
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 1
73445: NEG
73446: PUSH
73447: LD_INT 1
73449: NEG
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 1
73457: PUSH
73458: LD_INT 2
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 0
73467: PUSH
73468: LD_INT 2
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 1
73477: NEG
73478: PUSH
73479: LD_INT 1
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 2
73488: NEG
73489: PUSH
73490: LD_INT 0
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: PUSH
73497: LD_INT 2
73499: NEG
73500: PUSH
73501: LD_INT 1
73503: NEG
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73523: LD_ADDR_VAR 0 52
73527: PUSH
73528: LD_INT 0
73530: PUSH
73531: LD_INT 0
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 0
73540: PUSH
73541: LD_INT 1
73543: NEG
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: PUSH
73549: LD_INT 1
73551: PUSH
73552: LD_INT 0
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 1
73561: PUSH
73562: LD_INT 1
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 0
73571: PUSH
73572: LD_INT 1
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 1
73581: NEG
73582: PUSH
73583: LD_INT 0
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 1
73592: NEG
73593: PUSH
73594: LD_INT 1
73596: NEG
73597: PUSH
73598: EMPTY
73599: LIST
73600: LIST
73601: PUSH
73602: LD_INT 1
73604: NEG
73605: PUSH
73606: LD_INT 2
73608: NEG
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 1
73616: NEG
73617: PUSH
73618: LD_INT 1
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 2
73627: NEG
73628: PUSH
73629: LD_INT 0
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 2
73638: NEG
73639: PUSH
73640: LD_INT 1
73642: NEG
73643: PUSH
73644: EMPTY
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 2
73650: NEG
73651: PUSH
73652: LD_INT 2
73654: NEG
73655: PUSH
73656: EMPTY
73657: LIST
73658: LIST
73659: PUSH
73660: EMPTY
73661: LIST
73662: LIST
73663: LIST
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: LIST
73671: LIST
73672: LIST
73673: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73674: LD_ADDR_VAR 0 53
73678: PUSH
73679: LD_INT 0
73681: PUSH
73682: LD_INT 0
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 0
73691: PUSH
73692: LD_INT 1
73694: NEG
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 1
73702: PUSH
73703: LD_INT 0
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 1
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 0
73722: PUSH
73723: LD_INT 1
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PUSH
73730: LD_INT 1
73732: NEG
73733: PUSH
73734: LD_INT 0
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: LD_INT 1
73743: NEG
73744: PUSH
73745: LD_INT 1
73747: NEG
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 1
73755: NEG
73756: PUSH
73757: LD_INT 2
73759: NEG
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 0
73767: PUSH
73768: LD_INT 2
73770: NEG
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: LD_INT 1
73778: PUSH
73779: LD_INT 1
73781: NEG
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: PUSH
73787: LD_INT 2
73789: PUSH
73790: LD_INT 0
73792: PUSH
73793: EMPTY
73794: LIST
73795: LIST
73796: PUSH
73797: LD_INT 2
73799: PUSH
73800: LD_INT 1
73802: PUSH
73803: EMPTY
73804: LIST
73805: LIST
73806: PUSH
73807: LD_INT 2
73809: PUSH
73810: LD_INT 2
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: LD_INT 2
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 0
73829: PUSH
73830: LD_INT 2
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: PUSH
73837: LD_INT 1
73839: NEG
73840: PUSH
73841: LD_INT 1
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: PUSH
73848: LD_INT 2
73850: NEG
73851: PUSH
73852: LD_INT 0
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 2
73861: NEG
73862: PUSH
73863: LD_INT 1
73865: NEG
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 2
73873: NEG
73874: PUSH
73875: LD_INT 2
73877: NEG
73878: PUSH
73879: EMPTY
73880: LIST
73881: LIST
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: LIST
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73904: LD_ADDR_VAR 0 54
73908: PUSH
73909: LD_INT 0
73911: PUSH
73912: LD_INT 0
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: LD_INT 0
73921: PUSH
73922: LD_INT 1
73924: NEG
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 1
73932: PUSH
73933: LD_INT 0
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 1
73942: PUSH
73943: LD_INT 1
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 0
73952: PUSH
73953: LD_INT 1
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: PUSH
73960: LD_INT 1
73962: NEG
73963: PUSH
73964: LD_INT 0
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 1
73973: NEG
73974: PUSH
73975: LD_INT 1
73977: NEG
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 1
73985: NEG
73986: PUSH
73987: LD_INT 2
73989: NEG
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 0
73997: PUSH
73998: LD_INT 2
74000: NEG
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 1
74008: PUSH
74009: LD_INT 1
74011: NEG
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 2
74019: PUSH
74020: LD_INT 0
74022: PUSH
74023: EMPTY
74024: LIST
74025: LIST
74026: PUSH
74027: LD_INT 2
74029: PUSH
74030: LD_INT 1
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: LD_INT 2
74039: PUSH
74040: LD_INT 2
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PUSH
74047: LD_INT 1
74049: PUSH
74050: LD_INT 2
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 0
74059: PUSH
74060: LD_INT 2
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: PUSH
74067: LD_INT 1
74069: NEG
74070: PUSH
74071: LD_INT 1
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PUSH
74078: LD_INT 2
74080: NEG
74081: PUSH
74082: LD_INT 0
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: LD_INT 2
74091: NEG
74092: PUSH
74093: LD_INT 1
74095: NEG
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 2
74103: NEG
74104: PUSH
74105: LD_INT 2
74107: NEG
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: LIST
74117: LIST
74118: LIST
74119: LIST
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74134: LD_ADDR_VAR 0 55
74138: PUSH
74139: LD_INT 0
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 0
74151: PUSH
74152: LD_INT 1
74154: NEG
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 1
74162: PUSH
74163: LD_INT 0
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: PUSH
74170: LD_INT 1
74172: PUSH
74173: LD_INT 1
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 0
74182: PUSH
74183: LD_INT 1
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 1
74192: NEG
74193: PUSH
74194: LD_INT 0
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: LD_INT 1
74203: NEG
74204: PUSH
74205: LD_INT 1
74207: NEG
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 1
74215: NEG
74216: PUSH
74217: LD_INT 2
74219: NEG
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: LD_INT 2
74230: NEG
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: PUSH
74236: LD_INT 1
74238: PUSH
74239: LD_INT 1
74241: NEG
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 2
74249: PUSH
74250: LD_INT 0
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: LD_INT 2
74259: PUSH
74260: LD_INT 1
74262: PUSH
74263: EMPTY
74264: LIST
74265: LIST
74266: PUSH
74267: LD_INT 2
74269: PUSH
74270: LD_INT 2
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: PUSH
74277: LD_INT 1
74279: PUSH
74280: LD_INT 2
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 0
74289: PUSH
74290: LD_INT 2
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: LD_INT 1
74299: NEG
74300: PUSH
74301: LD_INT 1
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 2
74310: NEG
74311: PUSH
74312: LD_INT 0
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: LD_INT 2
74321: NEG
74322: PUSH
74323: LD_INT 1
74325: NEG
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 2
74333: NEG
74334: PUSH
74335: LD_INT 2
74337: NEG
74338: PUSH
74339: EMPTY
74340: LIST
74341: LIST
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: LIST
74359: LIST
74360: LIST
74361: LIST
74362: LIST
74363: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74364: LD_ADDR_VAR 0 56
74368: PUSH
74369: LD_INT 0
74371: PUSH
74372: LD_INT 0
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 0
74381: PUSH
74382: LD_INT 1
74384: NEG
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 1
74392: PUSH
74393: LD_INT 0
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: PUSH
74400: LD_INT 1
74402: PUSH
74403: LD_INT 1
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PUSH
74410: LD_INT 0
74412: PUSH
74413: LD_INT 1
74415: PUSH
74416: EMPTY
74417: LIST
74418: LIST
74419: PUSH
74420: LD_INT 1
74422: NEG
74423: PUSH
74424: LD_INT 0
74426: PUSH
74427: EMPTY
74428: LIST
74429: LIST
74430: PUSH
74431: LD_INT 1
74433: NEG
74434: PUSH
74435: LD_INT 1
74437: NEG
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: LD_INT 2
74449: NEG
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 0
74457: PUSH
74458: LD_INT 2
74460: NEG
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PUSH
74466: LD_INT 1
74468: PUSH
74469: LD_INT 1
74471: NEG
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 2
74479: PUSH
74480: LD_INT 0
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: PUSH
74487: LD_INT 2
74489: PUSH
74490: LD_INT 1
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: PUSH
74497: LD_INT 2
74499: PUSH
74500: LD_INT 2
74502: PUSH
74503: EMPTY
74504: LIST
74505: LIST
74506: PUSH
74507: LD_INT 1
74509: PUSH
74510: LD_INT 2
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 0
74519: PUSH
74520: LD_INT 2
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 1
74529: NEG
74530: PUSH
74531: LD_INT 1
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 2
74540: NEG
74541: PUSH
74542: LD_INT 0
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 2
74551: NEG
74552: PUSH
74553: LD_INT 1
74555: NEG
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 2
74563: NEG
74564: PUSH
74565: LD_INT 2
74567: NEG
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: LIST
74580: LIST
74581: LIST
74582: LIST
74583: LIST
74584: LIST
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: LIST
74590: LIST
74591: LIST
74592: LIST
74593: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74594: LD_ADDR_VAR 0 57
74598: PUSH
74599: LD_INT 0
74601: PUSH
74602: LD_INT 0
74604: PUSH
74605: EMPTY
74606: LIST
74607: LIST
74608: PUSH
74609: LD_INT 0
74611: PUSH
74612: LD_INT 1
74614: NEG
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: LD_INT 1
74622: PUSH
74623: LD_INT 0
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 1
74632: PUSH
74633: LD_INT 1
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: PUSH
74640: LD_INT 0
74642: PUSH
74643: LD_INT 1
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: PUSH
74650: LD_INT 1
74652: NEG
74653: PUSH
74654: LD_INT 0
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 1
74663: NEG
74664: PUSH
74665: LD_INT 1
74667: NEG
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: LD_INT 1
74675: NEG
74676: PUSH
74677: LD_INT 2
74679: NEG
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: PUSH
74685: LD_INT 0
74687: PUSH
74688: LD_INT 2
74690: NEG
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 1
74698: PUSH
74699: LD_INT 1
74701: NEG
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: PUSH
74707: LD_INT 2
74709: PUSH
74710: LD_INT 0
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 2
74719: PUSH
74720: LD_INT 1
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 2
74729: PUSH
74730: LD_INT 2
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: PUSH
74737: LD_INT 1
74739: PUSH
74740: LD_INT 2
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: LD_INT 0
74749: PUSH
74750: LD_INT 2
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: LD_INT 1
74759: NEG
74760: PUSH
74761: LD_INT 1
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: LD_INT 2
74770: NEG
74771: PUSH
74772: LD_INT 0
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 2
74781: NEG
74782: PUSH
74783: LD_INT 1
74785: NEG
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 2
74793: NEG
74794: PUSH
74795: LD_INT 2
74797: NEG
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: LIST
74807: LIST
74808: LIST
74809: LIST
74810: LIST
74811: LIST
74812: LIST
74813: LIST
74814: LIST
74815: LIST
74816: LIST
74817: LIST
74818: LIST
74819: LIST
74820: LIST
74821: LIST
74822: LIST
74823: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74824: LD_ADDR_VAR 0 58
74828: PUSH
74829: LD_INT 0
74831: PUSH
74832: LD_INT 0
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 0
74841: PUSH
74842: LD_INT 1
74844: NEG
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: LD_INT 1
74852: PUSH
74853: LD_INT 0
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: PUSH
74860: LD_INT 1
74862: PUSH
74863: LD_INT 1
74865: PUSH
74866: EMPTY
74867: LIST
74868: LIST
74869: PUSH
74870: LD_INT 0
74872: PUSH
74873: LD_INT 1
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: PUSH
74880: LD_INT 1
74882: NEG
74883: PUSH
74884: LD_INT 0
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: PUSH
74891: LD_INT 1
74893: NEG
74894: PUSH
74895: LD_INT 1
74897: NEG
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 1
74905: NEG
74906: PUSH
74907: LD_INT 2
74909: NEG
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: PUSH
74915: LD_INT 0
74917: PUSH
74918: LD_INT 2
74920: NEG
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: PUSH
74926: LD_INT 1
74928: PUSH
74929: LD_INT 1
74931: NEG
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: LD_INT 2
74939: PUSH
74940: LD_INT 0
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PUSH
74947: LD_INT 2
74949: PUSH
74950: LD_INT 1
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: PUSH
74957: LD_INT 2
74959: PUSH
74960: LD_INT 2
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PUSH
74967: LD_INT 1
74969: PUSH
74970: LD_INT 2
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: LD_INT 0
74979: PUSH
74980: LD_INT 2
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: LD_INT 1
74989: NEG
74990: PUSH
74991: LD_INT 1
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: LD_INT 2
75000: NEG
75001: PUSH
75002: LD_INT 0
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 2
75011: NEG
75012: PUSH
75013: LD_INT 1
75015: NEG
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 2
75023: NEG
75024: PUSH
75025: LD_INT 2
75027: NEG
75028: PUSH
75029: EMPTY
75030: LIST
75031: LIST
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: LIST
75040: LIST
75041: LIST
75042: LIST
75043: LIST
75044: LIST
75045: LIST
75046: LIST
75047: LIST
75048: LIST
75049: LIST
75050: LIST
75051: LIST
75052: LIST
75053: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75054: LD_ADDR_VAR 0 59
75058: PUSH
75059: LD_INT 0
75061: PUSH
75062: LD_INT 0
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 0
75071: PUSH
75072: LD_INT 1
75074: NEG
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: LD_INT 1
75082: PUSH
75083: LD_INT 0
75085: PUSH
75086: EMPTY
75087: LIST
75088: LIST
75089: PUSH
75090: LD_INT 1
75092: PUSH
75093: LD_INT 1
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 0
75102: PUSH
75103: LD_INT 1
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: LD_INT 1
75112: NEG
75113: PUSH
75114: LD_INT 0
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: LD_INT 1
75123: NEG
75124: PUSH
75125: LD_INT 1
75127: NEG
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75142: LD_ADDR_VAR 0 60
75146: PUSH
75147: LD_INT 0
75149: PUSH
75150: LD_INT 0
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: PUSH
75157: LD_INT 0
75159: PUSH
75160: LD_INT 1
75162: NEG
75163: PUSH
75164: EMPTY
75165: LIST
75166: LIST
75167: PUSH
75168: LD_INT 1
75170: PUSH
75171: LD_INT 0
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 1
75180: PUSH
75181: LD_INT 1
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 0
75190: PUSH
75191: LD_INT 1
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: PUSH
75198: LD_INT 1
75200: NEG
75201: PUSH
75202: LD_INT 0
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: LD_INT 1
75211: NEG
75212: PUSH
75213: LD_INT 1
75215: NEG
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: LIST
75225: LIST
75226: LIST
75227: LIST
75228: LIST
75229: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75230: LD_ADDR_VAR 0 61
75234: PUSH
75235: LD_INT 0
75237: PUSH
75238: LD_INT 0
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 0
75247: PUSH
75248: LD_INT 1
75250: NEG
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 1
75258: PUSH
75259: LD_INT 0
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: LD_INT 1
75268: PUSH
75269: LD_INT 1
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 0
75278: PUSH
75279: LD_INT 1
75281: PUSH
75282: EMPTY
75283: LIST
75284: LIST
75285: PUSH
75286: LD_INT 1
75288: NEG
75289: PUSH
75290: LD_INT 0
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PUSH
75297: LD_INT 1
75299: NEG
75300: PUSH
75301: LD_INT 1
75303: NEG
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: LIST
75313: LIST
75314: LIST
75315: LIST
75316: LIST
75317: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75318: LD_ADDR_VAR 0 62
75322: PUSH
75323: LD_INT 0
75325: PUSH
75326: LD_INT 0
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 0
75335: PUSH
75336: LD_INT 1
75338: NEG
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 1
75346: PUSH
75347: LD_INT 0
75349: PUSH
75350: EMPTY
75351: LIST
75352: LIST
75353: PUSH
75354: LD_INT 1
75356: PUSH
75357: LD_INT 1
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 0
75366: PUSH
75367: LD_INT 1
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: LD_INT 1
75376: NEG
75377: PUSH
75378: LD_INT 0
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: PUSH
75385: LD_INT 1
75387: NEG
75388: PUSH
75389: LD_INT 1
75391: NEG
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75406: LD_ADDR_VAR 0 63
75410: PUSH
75411: LD_INT 0
75413: PUSH
75414: LD_INT 0
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 0
75423: PUSH
75424: LD_INT 1
75426: NEG
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 1
75434: PUSH
75435: LD_INT 0
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 1
75444: PUSH
75445: LD_INT 1
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 0
75454: PUSH
75455: LD_INT 1
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 1
75464: NEG
75465: PUSH
75466: LD_INT 0
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 1
75475: NEG
75476: PUSH
75477: LD_INT 1
75479: NEG
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75494: LD_ADDR_VAR 0 64
75498: PUSH
75499: LD_INT 0
75501: PUSH
75502: LD_INT 0
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 0
75511: PUSH
75512: LD_INT 1
75514: NEG
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: LD_INT 1
75522: PUSH
75523: LD_INT 0
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: LD_INT 1
75532: PUSH
75533: LD_INT 1
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 0
75542: PUSH
75543: LD_INT 1
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 1
75552: NEG
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 1
75563: NEG
75564: PUSH
75565: LD_INT 1
75567: NEG
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: LIST
75577: LIST
75578: LIST
75579: LIST
75580: LIST
75581: ST_TO_ADDR
// end ; 1 :
75582: GO 81479
75584: LD_INT 1
75586: DOUBLE
75587: EQUAL
75588: IFTRUE 75592
75590: GO 78215
75592: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75593: LD_ADDR_VAR 0 11
75597: PUSH
75598: LD_INT 1
75600: NEG
75601: PUSH
75602: LD_INT 3
75604: NEG
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: LD_INT 0
75612: PUSH
75613: LD_INT 3
75615: NEG
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 1
75623: PUSH
75624: LD_INT 2
75626: NEG
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: LIST
75636: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75637: LD_ADDR_VAR 0 12
75641: PUSH
75642: LD_INT 2
75644: PUSH
75645: LD_INT 1
75647: NEG
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 3
75655: PUSH
75656: LD_INT 0
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 3
75665: PUSH
75666: LD_INT 1
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: EMPTY
75674: LIST
75675: LIST
75676: LIST
75677: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75678: LD_ADDR_VAR 0 13
75682: PUSH
75683: LD_INT 3
75685: PUSH
75686: LD_INT 2
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 3
75695: PUSH
75696: LD_INT 3
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 2
75705: PUSH
75706: LD_INT 3
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: LIST
75717: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75718: LD_ADDR_VAR 0 14
75722: PUSH
75723: LD_INT 1
75725: PUSH
75726: LD_INT 3
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 0
75735: PUSH
75736: LD_INT 3
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: LD_INT 1
75745: NEG
75746: PUSH
75747: LD_INT 2
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: EMPTY
75755: LIST
75756: LIST
75757: LIST
75758: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75759: LD_ADDR_VAR 0 15
75763: PUSH
75764: LD_INT 2
75766: NEG
75767: PUSH
75768: LD_INT 1
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 3
75777: NEG
75778: PUSH
75779: LD_INT 0
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 3
75788: NEG
75789: PUSH
75790: LD_INT 1
75792: NEG
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: LIST
75802: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75803: LD_ADDR_VAR 0 16
75807: PUSH
75808: LD_INT 2
75810: NEG
75811: PUSH
75812: LD_INT 3
75814: NEG
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: PUSH
75820: LD_INT 3
75822: NEG
75823: PUSH
75824: LD_INT 2
75826: NEG
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 3
75834: NEG
75835: PUSH
75836: LD_INT 3
75838: NEG
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: LIST
75848: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75849: LD_ADDR_VAR 0 17
75853: PUSH
75854: LD_INT 1
75856: NEG
75857: PUSH
75858: LD_INT 3
75860: NEG
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: PUSH
75866: LD_INT 0
75868: PUSH
75869: LD_INT 3
75871: NEG
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: LD_INT 1
75879: PUSH
75880: LD_INT 2
75882: NEG
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: LIST
75892: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75893: LD_ADDR_VAR 0 18
75897: PUSH
75898: LD_INT 2
75900: PUSH
75901: LD_INT 1
75903: NEG
75904: PUSH
75905: EMPTY
75906: LIST
75907: LIST
75908: PUSH
75909: LD_INT 3
75911: PUSH
75912: LD_INT 0
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 3
75921: PUSH
75922: LD_INT 1
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: LIST
75933: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75934: LD_ADDR_VAR 0 19
75938: PUSH
75939: LD_INT 3
75941: PUSH
75942: LD_INT 2
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 3
75951: PUSH
75952: LD_INT 3
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: LD_INT 2
75961: PUSH
75962: LD_INT 3
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: LIST
75973: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75974: LD_ADDR_VAR 0 20
75978: PUSH
75979: LD_INT 1
75981: PUSH
75982: LD_INT 3
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 0
75991: PUSH
75992: LD_INT 3
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PUSH
75999: LD_INT 1
76001: NEG
76002: PUSH
76003: LD_INT 2
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: LIST
76014: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76015: LD_ADDR_VAR 0 21
76019: PUSH
76020: LD_INT 2
76022: NEG
76023: PUSH
76024: LD_INT 1
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 3
76033: NEG
76034: PUSH
76035: LD_INT 0
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 3
76044: NEG
76045: PUSH
76046: LD_INT 1
76048: NEG
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: EMPTY
76055: LIST
76056: LIST
76057: LIST
76058: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76059: LD_ADDR_VAR 0 22
76063: PUSH
76064: LD_INT 2
76066: NEG
76067: PUSH
76068: LD_INT 3
76070: NEG
76071: PUSH
76072: EMPTY
76073: LIST
76074: LIST
76075: PUSH
76076: LD_INT 3
76078: NEG
76079: PUSH
76080: LD_INT 2
76082: NEG
76083: PUSH
76084: EMPTY
76085: LIST
76086: LIST
76087: PUSH
76088: LD_INT 3
76090: NEG
76091: PUSH
76092: LD_INT 3
76094: NEG
76095: PUSH
76096: EMPTY
76097: LIST
76098: LIST
76099: PUSH
76100: EMPTY
76101: LIST
76102: LIST
76103: LIST
76104: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
76105: LD_ADDR_VAR 0 23
76109: PUSH
76110: LD_INT 0
76112: PUSH
76113: LD_INT 3
76115: NEG
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 1
76123: NEG
76124: PUSH
76125: LD_INT 4
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: LD_INT 3
76138: NEG
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: LIST
76148: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
76149: LD_ADDR_VAR 0 24
76153: PUSH
76154: LD_INT 3
76156: PUSH
76157: LD_INT 0
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 3
76166: PUSH
76167: LD_INT 1
76169: NEG
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 4
76177: PUSH
76178: LD_INT 1
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: LIST
76189: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
76190: LD_ADDR_VAR 0 25
76194: PUSH
76195: LD_INT 3
76197: PUSH
76198: LD_INT 3
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: PUSH
76205: LD_INT 4
76207: PUSH
76208: LD_INT 3
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 3
76217: PUSH
76218: LD_INT 4
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: LIST
76229: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
76230: LD_ADDR_VAR 0 26
76234: PUSH
76235: LD_INT 0
76237: PUSH
76238: LD_INT 3
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 1
76247: PUSH
76248: LD_INT 4
76250: PUSH
76251: EMPTY
76252: LIST
76253: LIST
76254: PUSH
76255: LD_INT 1
76257: NEG
76258: PUSH
76259: LD_INT 3
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: EMPTY
76267: LIST
76268: LIST
76269: LIST
76270: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
76271: LD_ADDR_VAR 0 27
76275: PUSH
76276: LD_INT 3
76278: NEG
76279: PUSH
76280: LD_INT 0
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 3
76289: NEG
76290: PUSH
76291: LD_INT 1
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 4
76300: NEG
76301: PUSH
76302: LD_INT 1
76304: NEG
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: LIST
76314: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76315: LD_ADDR_VAR 0 28
76319: PUSH
76320: LD_INT 3
76322: NEG
76323: PUSH
76324: LD_INT 3
76326: NEG
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 3
76334: NEG
76335: PUSH
76336: LD_INT 4
76338: NEG
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: LD_INT 4
76346: NEG
76347: PUSH
76348: LD_INT 3
76350: NEG
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: LIST
76360: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76361: LD_ADDR_VAR 0 29
76365: PUSH
76366: LD_INT 1
76368: NEG
76369: PUSH
76370: LD_INT 3
76372: NEG
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: LD_INT 0
76380: PUSH
76381: LD_INT 3
76383: NEG
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 1
76391: PUSH
76392: LD_INT 2
76394: NEG
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PUSH
76400: LD_INT 1
76402: NEG
76403: PUSH
76404: LD_INT 4
76406: NEG
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 0
76414: PUSH
76415: LD_INT 4
76417: NEG
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 1
76425: PUSH
76426: LD_INT 3
76428: NEG
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PUSH
76434: LD_INT 1
76436: NEG
76437: PUSH
76438: LD_INT 5
76440: NEG
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: PUSH
76446: LD_INT 0
76448: PUSH
76449: LD_INT 5
76451: NEG
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: LD_INT 1
76459: PUSH
76460: LD_INT 4
76462: NEG
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: PUSH
76468: LD_INT 1
76470: NEG
76471: PUSH
76472: LD_INT 6
76474: NEG
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: PUSH
76480: LD_INT 0
76482: PUSH
76483: LD_INT 6
76485: NEG
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: PUSH
76491: LD_INT 1
76493: PUSH
76494: LD_INT 5
76496: NEG
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: LIST
76506: LIST
76507: LIST
76508: LIST
76509: LIST
76510: LIST
76511: LIST
76512: LIST
76513: LIST
76514: LIST
76515: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76516: LD_ADDR_VAR 0 30
76520: PUSH
76521: LD_INT 2
76523: PUSH
76524: LD_INT 1
76526: NEG
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 3
76534: PUSH
76535: LD_INT 0
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PUSH
76542: LD_INT 3
76544: PUSH
76545: LD_INT 1
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 3
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 4
76565: PUSH
76566: LD_INT 0
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: LD_INT 4
76575: PUSH
76576: LD_INT 1
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_INT 4
76585: PUSH
76586: LD_INT 1
76588: NEG
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 5
76596: PUSH
76597: LD_INT 0
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 5
76606: PUSH
76607: LD_INT 1
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 5
76616: PUSH
76617: LD_INT 1
76619: NEG
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 6
76627: PUSH
76628: LD_INT 0
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 6
76637: PUSH
76638: LD_INT 1
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: LIST
76649: LIST
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: LIST
76658: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76659: LD_ADDR_VAR 0 31
76663: PUSH
76664: LD_INT 3
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 3
76676: PUSH
76677: LD_INT 3
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 2
76686: PUSH
76687: LD_INT 3
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 4
76696: PUSH
76697: LD_INT 3
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 4
76706: PUSH
76707: LD_INT 4
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 3
76716: PUSH
76717: LD_INT 4
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 5
76726: PUSH
76727: LD_INT 4
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 5
76736: PUSH
76737: LD_INT 5
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 4
76746: PUSH
76747: LD_INT 5
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 6
76756: PUSH
76757: LD_INT 5
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 6
76766: PUSH
76767: LD_INT 6
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 5
76776: PUSH
76777: LD_INT 6
76779: PUSH
76780: EMPTY
76781: LIST
76782: LIST
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: LIST
76788: LIST
76789: LIST
76790: LIST
76791: LIST
76792: LIST
76793: LIST
76794: LIST
76795: LIST
76796: LIST
76797: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76798: LD_ADDR_VAR 0 32
76802: PUSH
76803: LD_INT 1
76805: PUSH
76806: LD_INT 3
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 0
76815: PUSH
76816: LD_INT 3
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 1
76825: NEG
76826: PUSH
76827: LD_INT 2
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 1
76836: PUSH
76837: LD_INT 4
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 0
76846: PUSH
76847: LD_INT 4
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 1
76856: NEG
76857: PUSH
76858: LD_INT 3
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 1
76867: PUSH
76868: LD_INT 5
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: LD_INT 0
76877: PUSH
76878: LD_INT 5
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: LD_INT 1
76887: NEG
76888: PUSH
76889: LD_INT 4
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 1
76898: PUSH
76899: LD_INT 6
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 0
76908: PUSH
76909: LD_INT 6
76911: PUSH
76912: EMPTY
76913: LIST
76914: LIST
76915: PUSH
76916: LD_INT 1
76918: NEG
76919: PUSH
76920: LD_INT 5
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: EMPTY
76928: LIST
76929: LIST
76930: LIST
76931: LIST
76932: LIST
76933: LIST
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: LIST
76939: LIST
76940: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76941: LD_ADDR_VAR 0 33
76945: PUSH
76946: LD_INT 2
76948: NEG
76949: PUSH
76950: LD_INT 1
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 3
76959: NEG
76960: PUSH
76961: LD_INT 0
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 3
76970: NEG
76971: PUSH
76972: LD_INT 1
76974: NEG
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 3
76982: NEG
76983: PUSH
76984: LD_INT 1
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: PUSH
76991: LD_INT 4
76993: NEG
76994: PUSH
76995: LD_INT 0
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PUSH
77002: LD_INT 4
77004: NEG
77005: PUSH
77006: LD_INT 1
77008: NEG
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 4
77016: NEG
77017: PUSH
77018: LD_INT 1
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 5
77027: NEG
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 5
77038: NEG
77039: PUSH
77040: LD_INT 1
77042: NEG
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 5
77050: NEG
77051: PUSH
77052: LD_INT 1
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: LD_INT 6
77061: NEG
77062: PUSH
77063: LD_INT 0
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: PUSH
77070: LD_INT 6
77072: NEG
77073: PUSH
77074: LD_INT 1
77076: NEG
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: LIST
77086: LIST
77087: LIST
77088: LIST
77089: LIST
77090: LIST
77091: LIST
77092: LIST
77093: LIST
77094: LIST
77095: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
77096: LD_ADDR_VAR 0 34
77100: PUSH
77101: LD_INT 2
77103: NEG
77104: PUSH
77105: LD_INT 3
77107: NEG
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 3
77115: NEG
77116: PUSH
77117: LD_INT 2
77119: NEG
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: PUSH
77125: LD_INT 3
77127: NEG
77128: PUSH
77129: LD_INT 3
77131: NEG
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 3
77139: NEG
77140: PUSH
77141: LD_INT 4
77143: NEG
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 4
77151: NEG
77152: PUSH
77153: LD_INT 3
77155: NEG
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: LD_INT 4
77163: NEG
77164: PUSH
77165: LD_INT 4
77167: NEG
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 4
77175: NEG
77176: PUSH
77177: LD_INT 5
77179: NEG
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 5
77187: NEG
77188: PUSH
77189: LD_INT 4
77191: NEG
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PUSH
77197: LD_INT 5
77199: NEG
77200: PUSH
77201: LD_INT 5
77203: NEG
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 5
77211: NEG
77212: PUSH
77213: LD_INT 6
77215: NEG
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 6
77223: NEG
77224: PUSH
77225: LD_INT 5
77227: NEG
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: PUSH
77233: LD_INT 6
77235: NEG
77236: PUSH
77237: LD_INT 6
77239: NEG
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: EMPTY
77246: LIST
77247: LIST
77248: LIST
77249: LIST
77250: LIST
77251: LIST
77252: LIST
77253: LIST
77254: LIST
77255: LIST
77256: LIST
77257: LIST
77258: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
77259: LD_ADDR_VAR 0 41
77263: PUSH
77264: LD_INT 0
77266: PUSH
77267: LD_INT 2
77269: NEG
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 1
77277: NEG
77278: PUSH
77279: LD_INT 3
77281: NEG
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PUSH
77287: LD_INT 1
77289: PUSH
77290: LD_INT 2
77292: NEG
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: EMPTY
77299: LIST
77300: LIST
77301: LIST
77302: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77303: LD_ADDR_VAR 0 42
77307: PUSH
77308: LD_INT 2
77310: PUSH
77311: LD_INT 0
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 2
77320: PUSH
77321: LD_INT 1
77323: NEG
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 3
77331: PUSH
77332: LD_INT 1
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: EMPTY
77340: LIST
77341: LIST
77342: LIST
77343: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77344: LD_ADDR_VAR 0 43
77348: PUSH
77349: LD_INT 2
77351: PUSH
77352: LD_INT 2
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 3
77361: PUSH
77362: LD_INT 2
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 2
77371: PUSH
77372: LD_INT 3
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: LIST
77383: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77384: LD_ADDR_VAR 0 44
77388: PUSH
77389: LD_INT 0
77391: PUSH
77392: LD_INT 2
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 1
77401: PUSH
77402: LD_INT 3
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: LD_INT 2
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: LIST
77424: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77425: LD_ADDR_VAR 0 45
77429: PUSH
77430: LD_INT 2
77432: NEG
77433: PUSH
77434: LD_INT 0
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 2
77443: NEG
77444: PUSH
77445: LD_INT 1
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 3
77454: NEG
77455: PUSH
77456: LD_INT 1
77458: NEG
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: LIST
77468: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77469: LD_ADDR_VAR 0 46
77473: PUSH
77474: LD_INT 2
77476: NEG
77477: PUSH
77478: LD_INT 2
77480: NEG
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 2
77488: NEG
77489: PUSH
77490: LD_INT 3
77492: NEG
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: PUSH
77498: LD_INT 3
77500: NEG
77501: PUSH
77502: LD_INT 2
77504: NEG
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: LIST
77514: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77515: LD_ADDR_VAR 0 47
77519: PUSH
77520: LD_INT 2
77522: NEG
77523: PUSH
77524: LD_INT 3
77526: NEG
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: LD_INT 1
77534: NEG
77535: PUSH
77536: LD_INT 3
77538: NEG
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77548: LD_ADDR_VAR 0 48
77552: PUSH
77553: LD_INT 1
77555: PUSH
77556: LD_INT 2
77558: NEG
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: LD_INT 2
77566: PUSH
77567: LD_INT 1
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77579: LD_ADDR_VAR 0 49
77583: PUSH
77584: LD_INT 3
77586: PUSH
77587: LD_INT 1
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 3
77596: PUSH
77597: LD_INT 2
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77608: LD_ADDR_VAR 0 50
77612: PUSH
77613: LD_INT 2
77615: PUSH
77616: LD_INT 3
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 1
77625: PUSH
77626: LD_INT 3
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77637: LD_ADDR_VAR 0 51
77641: PUSH
77642: LD_INT 1
77644: NEG
77645: PUSH
77646: LD_INT 2
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: LD_INT 2
77655: NEG
77656: PUSH
77657: LD_INT 1
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: PUSH
77664: EMPTY
77665: LIST
77666: LIST
77667: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77668: LD_ADDR_VAR 0 52
77672: PUSH
77673: LD_INT 3
77675: NEG
77676: PUSH
77677: LD_INT 1
77679: NEG
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 3
77687: NEG
77688: PUSH
77689: LD_INT 2
77691: NEG
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77701: LD_ADDR_VAR 0 53
77705: PUSH
77706: LD_INT 1
77708: NEG
77709: PUSH
77710: LD_INT 3
77712: NEG
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 0
77720: PUSH
77721: LD_INT 3
77723: NEG
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: LD_INT 1
77731: PUSH
77732: LD_INT 2
77734: NEG
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: LIST
77744: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77745: LD_ADDR_VAR 0 54
77749: PUSH
77750: LD_INT 2
77752: PUSH
77753: LD_INT 1
77755: NEG
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 3
77763: PUSH
77764: LD_INT 0
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 3
77773: PUSH
77774: LD_INT 1
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: LIST
77785: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77786: LD_ADDR_VAR 0 55
77790: PUSH
77791: LD_INT 3
77793: PUSH
77794: LD_INT 2
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 3
77803: PUSH
77804: LD_INT 3
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 2
77813: PUSH
77814: LD_INT 3
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: EMPTY
77822: LIST
77823: LIST
77824: LIST
77825: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77826: LD_ADDR_VAR 0 56
77830: PUSH
77831: LD_INT 1
77833: PUSH
77834: LD_INT 3
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 0
77843: PUSH
77844: LD_INT 3
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 1
77853: NEG
77854: PUSH
77855: LD_INT 2
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: LIST
77866: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77867: LD_ADDR_VAR 0 57
77871: PUSH
77872: LD_INT 2
77874: NEG
77875: PUSH
77876: LD_INT 1
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 3
77885: NEG
77886: PUSH
77887: LD_INT 0
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 3
77896: NEG
77897: PUSH
77898: LD_INT 1
77900: NEG
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: EMPTY
77907: LIST
77908: LIST
77909: LIST
77910: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77911: LD_ADDR_VAR 0 58
77915: PUSH
77916: LD_INT 2
77918: NEG
77919: PUSH
77920: LD_INT 3
77922: NEG
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 3
77930: NEG
77931: PUSH
77932: LD_INT 2
77934: NEG
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 3
77942: NEG
77943: PUSH
77944: LD_INT 3
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: LIST
77956: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77957: LD_ADDR_VAR 0 59
77961: PUSH
77962: LD_INT 1
77964: NEG
77965: PUSH
77966: LD_INT 2
77968: NEG
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 0
77976: PUSH
77977: LD_INT 2
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 1
77987: PUSH
77988: LD_INT 1
77990: NEG
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: LIST
78000: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
78001: LD_ADDR_VAR 0 60
78005: PUSH
78006: LD_INT 1
78008: PUSH
78009: LD_INT 1
78011: NEG
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: LD_INT 2
78019: PUSH
78020: LD_INT 0
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: PUSH
78027: LD_INT 2
78029: PUSH
78030: LD_INT 1
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: LIST
78041: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
78042: LD_ADDR_VAR 0 61
78046: PUSH
78047: LD_INT 2
78049: PUSH
78050: LD_INT 1
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 2
78059: PUSH
78060: LD_INT 2
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 1
78069: PUSH
78070: LD_INT 2
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: LIST
78081: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
78082: LD_ADDR_VAR 0 62
78086: PUSH
78087: LD_INT 1
78089: PUSH
78090: LD_INT 2
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 0
78099: PUSH
78100: LD_INT 2
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: LD_INT 1
78109: NEG
78110: PUSH
78111: LD_INT 1
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: LIST
78122: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
78123: LD_ADDR_VAR 0 63
78127: PUSH
78128: LD_INT 1
78130: NEG
78131: PUSH
78132: LD_INT 1
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 2
78141: NEG
78142: PUSH
78143: LD_INT 0
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 2
78152: NEG
78153: PUSH
78154: LD_INT 1
78156: NEG
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: LIST
78166: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78167: LD_ADDR_VAR 0 64
78171: PUSH
78172: LD_INT 1
78174: NEG
78175: PUSH
78176: LD_INT 2
78178: NEG
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PUSH
78184: LD_INT 2
78186: NEG
78187: PUSH
78188: LD_INT 1
78190: NEG
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: LD_INT 2
78198: NEG
78199: PUSH
78200: LD_INT 2
78202: NEG
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: LIST
78212: ST_TO_ADDR
// end ; 2 :
78213: GO 81479
78215: LD_INT 2
78217: DOUBLE
78218: EQUAL
78219: IFTRUE 78223
78221: GO 81478
78223: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
78224: LD_ADDR_VAR 0 29
78228: PUSH
78229: LD_INT 4
78231: PUSH
78232: LD_INT 0
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: PUSH
78239: LD_INT 4
78241: PUSH
78242: LD_INT 1
78244: NEG
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 5
78252: PUSH
78253: LD_INT 0
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 5
78262: PUSH
78263: LD_INT 1
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 4
78272: PUSH
78273: LD_INT 1
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 3
78282: PUSH
78283: LD_INT 0
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 3
78292: PUSH
78293: LD_INT 1
78295: NEG
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 3
78303: PUSH
78304: LD_INT 2
78306: NEG
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 5
78314: PUSH
78315: LD_INT 2
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 3
78324: PUSH
78325: LD_INT 3
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 3
78334: PUSH
78335: LD_INT 2
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 4
78344: PUSH
78345: LD_INT 3
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 4
78354: PUSH
78355: LD_INT 4
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 3
78364: PUSH
78365: LD_INT 4
78367: PUSH
78368: EMPTY
78369: LIST
78370: LIST
78371: PUSH
78372: LD_INT 2
78374: PUSH
78375: LD_INT 3
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 2
78384: PUSH
78385: LD_INT 2
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 4
78394: PUSH
78395: LD_INT 2
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: LD_INT 2
78404: PUSH
78405: LD_INT 4
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 0
78414: PUSH
78415: LD_INT 4
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 0
78424: PUSH
78425: LD_INT 3
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: PUSH
78432: LD_INT 1
78434: PUSH
78435: LD_INT 4
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 1
78444: PUSH
78445: LD_INT 5
78447: PUSH
78448: EMPTY
78449: LIST
78450: LIST
78451: PUSH
78452: LD_INT 0
78454: PUSH
78455: LD_INT 5
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 1
78464: NEG
78465: PUSH
78466: LD_INT 4
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: PUSH
78473: LD_INT 1
78475: NEG
78476: PUSH
78477: LD_INT 3
78479: PUSH
78480: EMPTY
78481: LIST
78482: LIST
78483: PUSH
78484: LD_INT 2
78486: PUSH
78487: LD_INT 5
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 2
78496: NEG
78497: PUSH
78498: LD_INT 3
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 3
78507: NEG
78508: PUSH
78509: LD_INT 0
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 3
78518: NEG
78519: PUSH
78520: LD_INT 1
78522: NEG
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 2
78530: NEG
78531: PUSH
78532: LD_INT 0
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: LD_INT 2
78541: NEG
78542: PUSH
78543: LD_INT 1
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: PUSH
78550: LD_INT 3
78552: NEG
78553: PUSH
78554: LD_INT 1
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: LD_INT 4
78563: NEG
78564: PUSH
78565: LD_INT 0
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 4
78574: NEG
78575: PUSH
78576: LD_INT 1
78578: NEG
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 4
78586: NEG
78587: PUSH
78588: LD_INT 2
78590: NEG
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 2
78598: NEG
78599: PUSH
78600: LD_INT 2
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 4
78609: NEG
78610: PUSH
78611: LD_INT 4
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 4
78621: NEG
78622: PUSH
78623: LD_INT 5
78625: NEG
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: LD_INT 3
78633: NEG
78634: PUSH
78635: LD_INT 4
78637: NEG
78638: PUSH
78639: EMPTY
78640: LIST
78641: LIST
78642: PUSH
78643: LD_INT 3
78645: NEG
78646: PUSH
78647: LD_INT 3
78649: NEG
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 4
78657: NEG
78658: PUSH
78659: LD_INT 3
78661: NEG
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 5
78669: NEG
78670: PUSH
78671: LD_INT 4
78673: NEG
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 5
78681: NEG
78682: PUSH
78683: LD_INT 5
78685: NEG
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: LD_INT 3
78693: NEG
78694: PUSH
78695: LD_INT 5
78697: NEG
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 5
78705: NEG
78706: PUSH
78707: LD_INT 3
78709: NEG
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: LIST
78719: LIST
78720: LIST
78721: LIST
78722: LIST
78723: LIST
78724: LIST
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: LIST
78731: LIST
78732: LIST
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: LIST
78752: LIST
78753: LIST
78754: LIST
78755: LIST
78756: LIST
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78762: LD_ADDR_VAR 0 30
78766: PUSH
78767: LD_INT 4
78769: PUSH
78770: LD_INT 4
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 4
78779: PUSH
78780: LD_INT 3
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 5
78789: PUSH
78790: LD_INT 4
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 5
78799: PUSH
78800: LD_INT 5
78802: PUSH
78803: EMPTY
78804: LIST
78805: LIST
78806: PUSH
78807: LD_INT 4
78809: PUSH
78810: LD_INT 5
78812: PUSH
78813: EMPTY
78814: LIST
78815: LIST
78816: PUSH
78817: LD_INT 3
78819: PUSH
78820: LD_INT 4
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 3
78829: PUSH
78830: LD_INT 3
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 5
78839: PUSH
78840: LD_INT 3
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 3
78849: PUSH
78850: LD_INT 5
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 0
78859: PUSH
78860: LD_INT 3
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 0
78869: PUSH
78870: LD_INT 2
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 1
78879: PUSH
78880: LD_INT 3
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 1
78889: PUSH
78890: LD_INT 4
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: LD_INT 0
78899: PUSH
78900: LD_INT 4
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 1
78909: NEG
78910: PUSH
78911: LD_INT 3
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 1
78920: NEG
78921: PUSH
78922: LD_INT 2
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: PUSH
78932: LD_INT 4
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 2
78941: NEG
78942: PUSH
78943: LD_INT 2
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 4
78952: NEG
78953: PUSH
78954: LD_INT 0
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 4
78963: NEG
78964: PUSH
78965: LD_INT 1
78967: NEG
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: LD_INT 3
78975: NEG
78976: PUSH
78977: LD_INT 0
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: LD_INT 3
78986: NEG
78987: PUSH
78988: LD_INT 1
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 4
78997: NEG
78998: PUSH
78999: LD_INT 1
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 5
79008: NEG
79009: PUSH
79010: LD_INT 0
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 5
79019: NEG
79020: PUSH
79021: LD_INT 1
79023: NEG
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PUSH
79029: LD_INT 5
79031: NEG
79032: PUSH
79033: LD_INT 2
79035: NEG
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 3
79043: NEG
79044: PUSH
79045: LD_INT 2
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 3
79054: NEG
79055: PUSH
79056: LD_INT 3
79058: NEG
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 3
79066: NEG
79067: PUSH
79068: LD_INT 4
79070: NEG
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: LD_INT 2
79078: NEG
79079: PUSH
79080: LD_INT 3
79082: NEG
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 2
79090: NEG
79091: PUSH
79092: LD_INT 2
79094: NEG
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 3
79102: NEG
79103: PUSH
79104: LD_INT 2
79106: NEG
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 4
79114: NEG
79115: PUSH
79116: LD_INT 3
79118: NEG
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 4
79126: NEG
79127: PUSH
79128: LD_INT 4
79130: NEG
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PUSH
79136: LD_INT 2
79138: NEG
79139: PUSH
79140: LD_INT 4
79142: NEG
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 4
79150: NEG
79151: PUSH
79152: LD_INT 2
79154: NEG
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 0
79162: PUSH
79163: LD_INT 4
79165: NEG
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 0
79173: PUSH
79174: LD_INT 5
79176: NEG
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 1
79184: PUSH
79185: LD_INT 4
79187: NEG
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 1
79195: PUSH
79196: LD_INT 3
79198: NEG
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: PUSH
79204: LD_INT 0
79206: PUSH
79207: LD_INT 3
79209: NEG
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 1
79217: NEG
79218: PUSH
79219: LD_INT 4
79221: NEG
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 1
79229: NEG
79230: PUSH
79231: LD_INT 5
79233: NEG
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 2
79241: PUSH
79242: LD_INT 3
79244: NEG
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 2
79252: NEG
79253: PUSH
79254: LD_INT 5
79256: NEG
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: LIST
79269: LIST
79270: LIST
79271: LIST
79272: LIST
79273: LIST
79274: LIST
79275: LIST
79276: LIST
79277: LIST
79278: LIST
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: LIST
79295: LIST
79296: LIST
79297: LIST
79298: LIST
79299: LIST
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79309: LD_ADDR_VAR 0 31
79313: PUSH
79314: LD_INT 0
79316: PUSH
79317: LD_INT 4
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 0
79326: PUSH
79327: LD_INT 3
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 1
79336: PUSH
79337: LD_INT 4
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 1
79346: PUSH
79347: LD_INT 5
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 0
79356: PUSH
79357: LD_INT 5
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 1
79366: NEG
79367: PUSH
79368: LD_INT 4
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 1
79377: NEG
79378: PUSH
79379: LD_INT 3
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: LD_INT 2
79388: PUSH
79389: LD_INT 5
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 2
79398: NEG
79399: PUSH
79400: LD_INT 3
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 3
79409: NEG
79410: PUSH
79411: LD_INT 0
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 3
79420: NEG
79421: PUSH
79422: LD_INT 1
79424: NEG
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: LD_INT 2
79432: NEG
79433: PUSH
79434: LD_INT 0
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: LD_INT 2
79443: NEG
79444: PUSH
79445: LD_INT 1
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: LD_INT 3
79454: NEG
79455: PUSH
79456: LD_INT 1
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 4
79465: NEG
79466: PUSH
79467: LD_INT 0
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: LD_INT 4
79476: NEG
79477: PUSH
79478: LD_INT 1
79480: NEG
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 4
79488: NEG
79489: PUSH
79490: LD_INT 2
79492: NEG
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: LD_INT 2
79500: NEG
79501: PUSH
79502: LD_INT 2
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 4
79511: NEG
79512: PUSH
79513: LD_INT 4
79515: NEG
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: PUSH
79521: LD_INT 4
79523: NEG
79524: PUSH
79525: LD_INT 5
79527: NEG
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 3
79535: NEG
79536: PUSH
79537: LD_INT 4
79539: NEG
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 3
79547: NEG
79548: PUSH
79549: LD_INT 3
79551: NEG
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 4
79559: NEG
79560: PUSH
79561: LD_INT 3
79563: NEG
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 5
79571: NEG
79572: PUSH
79573: LD_INT 4
79575: NEG
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 5
79583: NEG
79584: PUSH
79585: LD_INT 5
79587: NEG
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 3
79595: NEG
79596: PUSH
79597: LD_INT 5
79599: NEG
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PUSH
79605: LD_INT 5
79607: NEG
79608: PUSH
79609: LD_INT 3
79611: NEG
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 0
79619: PUSH
79620: LD_INT 3
79622: NEG
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 0
79630: PUSH
79631: LD_INT 4
79633: NEG
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 1
79641: PUSH
79642: LD_INT 3
79644: NEG
79645: PUSH
79646: EMPTY
79647: LIST
79648: LIST
79649: PUSH
79650: LD_INT 1
79652: PUSH
79653: LD_INT 2
79655: NEG
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 0
79663: PUSH
79664: LD_INT 2
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 1
79674: NEG
79675: PUSH
79676: LD_INT 3
79678: NEG
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 1
79686: NEG
79687: PUSH
79688: LD_INT 4
79690: NEG
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 2
79698: PUSH
79699: LD_INT 2
79701: NEG
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 2
79709: NEG
79710: PUSH
79711: LD_INT 4
79713: NEG
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 4
79721: PUSH
79722: LD_INT 0
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 4
79731: PUSH
79732: LD_INT 1
79734: NEG
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 5
79742: PUSH
79743: LD_INT 0
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 5
79752: PUSH
79753: LD_INT 1
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 4
79762: PUSH
79763: LD_INT 1
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 3
79772: PUSH
79773: LD_INT 0
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: LD_INT 3
79782: PUSH
79783: LD_INT 1
79785: NEG
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 3
79793: PUSH
79794: LD_INT 2
79796: NEG
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 5
79804: PUSH
79805: LD_INT 2
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: LIST
79816: LIST
79817: LIST
79818: LIST
79819: LIST
79820: LIST
79821: LIST
79822: LIST
79823: LIST
79824: LIST
79825: LIST
79826: LIST
79827: LIST
79828: LIST
79829: LIST
79830: LIST
79831: LIST
79832: LIST
79833: LIST
79834: LIST
79835: LIST
79836: LIST
79837: LIST
79838: LIST
79839: LIST
79840: LIST
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79859: LD_ADDR_VAR 0 32
79863: PUSH
79864: LD_INT 4
79866: NEG
79867: PUSH
79868: LD_INT 0
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 4
79877: NEG
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: PUSH
79887: LD_INT 3
79889: NEG
79890: PUSH
79891: LD_INT 0
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 3
79900: NEG
79901: PUSH
79902: LD_INT 1
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 4
79911: NEG
79912: PUSH
79913: LD_INT 1
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 5
79922: NEG
79923: PUSH
79924: LD_INT 0
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 5
79933: NEG
79934: PUSH
79935: LD_INT 1
79937: NEG
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 5
79945: NEG
79946: PUSH
79947: LD_INT 2
79949: NEG
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 3
79957: NEG
79958: PUSH
79959: LD_INT 2
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 3
79968: NEG
79969: PUSH
79970: LD_INT 3
79972: NEG
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 3
79980: NEG
79981: PUSH
79982: LD_INT 4
79984: NEG
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 2
79992: NEG
79993: PUSH
79994: LD_INT 3
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 2
80004: NEG
80005: PUSH
80006: LD_INT 2
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 3
80016: NEG
80017: PUSH
80018: LD_INT 2
80020: NEG
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 4
80028: NEG
80029: PUSH
80030: LD_INT 3
80032: NEG
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 4
80040: NEG
80041: PUSH
80042: LD_INT 4
80044: NEG
80045: PUSH
80046: EMPTY
80047: LIST
80048: LIST
80049: PUSH
80050: LD_INT 2
80052: NEG
80053: PUSH
80054: LD_INT 4
80056: NEG
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PUSH
80062: LD_INT 4
80064: NEG
80065: PUSH
80066: LD_INT 2
80068: NEG
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 0
80076: PUSH
80077: LD_INT 4
80079: NEG
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 0
80087: PUSH
80088: LD_INT 5
80090: NEG
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: LD_INT 1
80098: PUSH
80099: LD_INT 4
80101: NEG
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 1
80109: PUSH
80110: LD_INT 3
80112: NEG
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 0
80120: PUSH
80121: LD_INT 3
80123: NEG
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 1
80131: NEG
80132: PUSH
80133: LD_INT 4
80135: NEG
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 1
80143: NEG
80144: PUSH
80145: LD_INT 5
80147: NEG
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: LD_INT 2
80155: PUSH
80156: LD_INT 3
80158: NEG
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 2
80166: NEG
80167: PUSH
80168: LD_INT 5
80170: NEG
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 3
80178: PUSH
80179: LD_INT 0
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 3
80188: PUSH
80189: LD_INT 1
80191: NEG
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 4
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 4
80209: PUSH
80210: LD_INT 1
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 3
80219: PUSH
80220: LD_INT 1
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 2
80229: PUSH
80230: LD_INT 0
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 2
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 2
80250: PUSH
80251: LD_INT 2
80253: NEG
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 4
80261: PUSH
80262: LD_INT 2
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 4
80271: PUSH
80272: LD_INT 4
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 4
80281: PUSH
80282: LD_INT 3
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 5
80291: PUSH
80292: LD_INT 4
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 5
80301: PUSH
80302: LD_INT 5
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 4
80311: PUSH
80312: LD_INT 5
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 3
80321: PUSH
80322: LD_INT 4
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 3
80331: PUSH
80332: LD_INT 3
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 5
80341: PUSH
80342: LD_INT 3
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: LD_INT 3
80351: PUSH
80352: LD_INT 5
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80406: LD_ADDR_VAR 0 33
80410: PUSH
80411: LD_INT 4
80413: NEG
80414: PUSH
80415: LD_INT 4
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 4
80425: NEG
80426: PUSH
80427: LD_INT 5
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 3
80437: NEG
80438: PUSH
80439: LD_INT 4
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 3
80449: NEG
80450: PUSH
80451: LD_INT 3
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 4
80461: NEG
80462: PUSH
80463: LD_INT 3
80465: NEG
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: LD_INT 5
80473: NEG
80474: PUSH
80475: LD_INT 4
80477: NEG
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 5
80485: NEG
80486: PUSH
80487: LD_INT 5
80489: NEG
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 3
80497: NEG
80498: PUSH
80499: LD_INT 5
80501: NEG
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PUSH
80507: LD_INT 5
80509: NEG
80510: PUSH
80511: LD_INT 3
80513: NEG
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 0
80521: PUSH
80522: LD_INT 3
80524: NEG
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 0
80532: PUSH
80533: LD_INT 4
80535: NEG
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 1
80543: PUSH
80544: LD_INT 3
80546: NEG
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 1
80554: PUSH
80555: LD_INT 2
80557: NEG
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PUSH
80563: LD_INT 0
80565: PUSH
80566: LD_INT 2
80568: NEG
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 1
80576: NEG
80577: PUSH
80578: LD_INT 3
80580: NEG
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 1
80588: NEG
80589: PUSH
80590: LD_INT 4
80592: NEG
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 2
80600: PUSH
80601: LD_INT 2
80603: NEG
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 2
80611: NEG
80612: PUSH
80613: LD_INT 4
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 4
80623: PUSH
80624: LD_INT 0
80626: PUSH
80627: EMPTY
80628: LIST
80629: LIST
80630: PUSH
80631: LD_INT 4
80633: PUSH
80634: LD_INT 1
80636: NEG
80637: PUSH
80638: EMPTY
80639: LIST
80640: LIST
80641: PUSH
80642: LD_INT 5
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 5
80654: PUSH
80655: LD_INT 1
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 4
80664: PUSH
80665: LD_INT 1
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 3
80674: PUSH
80675: LD_INT 0
80677: PUSH
80678: EMPTY
80679: LIST
80680: LIST
80681: PUSH
80682: LD_INT 3
80684: PUSH
80685: LD_INT 1
80687: NEG
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 3
80695: PUSH
80696: LD_INT 2
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 5
80706: PUSH
80707: LD_INT 2
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 3
80716: PUSH
80717: LD_INT 3
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 3
80726: PUSH
80727: LD_INT 2
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 4
80736: PUSH
80737: LD_INT 3
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 4
80746: PUSH
80747: LD_INT 4
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 3
80756: PUSH
80757: LD_INT 4
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 2
80766: PUSH
80767: LD_INT 3
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 2
80776: PUSH
80777: LD_INT 2
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 4
80786: PUSH
80787: LD_INT 2
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 2
80796: PUSH
80797: LD_INT 4
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 0
80806: PUSH
80807: LD_INT 4
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: PUSH
80814: LD_INT 0
80816: PUSH
80817: LD_INT 3
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 1
80826: PUSH
80827: LD_INT 4
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: LD_INT 1
80836: PUSH
80837: LD_INT 5
80839: PUSH
80840: EMPTY
80841: LIST
80842: LIST
80843: PUSH
80844: LD_INT 0
80846: PUSH
80847: LD_INT 5
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: LD_INT 4
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 1
80867: NEG
80868: PUSH
80869: LD_INT 3
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 2
80878: PUSH
80879: LD_INT 5
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 2
80888: NEG
80889: PUSH
80890: LD_INT 3
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80944: LD_ADDR_VAR 0 34
80948: PUSH
80949: LD_INT 0
80951: PUSH
80952: LD_INT 4
80954: NEG
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 0
80962: PUSH
80963: LD_INT 5
80965: NEG
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 1
80973: PUSH
80974: LD_INT 4
80976: NEG
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 1
80984: PUSH
80985: LD_INT 3
80987: NEG
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 0
80995: PUSH
80996: LD_INT 3
80998: NEG
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 1
81006: NEG
81007: PUSH
81008: LD_INT 4
81010: NEG
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 1
81018: NEG
81019: PUSH
81020: LD_INT 5
81022: NEG
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 2
81030: PUSH
81031: LD_INT 3
81033: NEG
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 2
81041: NEG
81042: PUSH
81043: LD_INT 5
81045: NEG
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 3
81053: PUSH
81054: LD_INT 0
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 3
81063: PUSH
81064: LD_INT 1
81066: NEG
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 4
81074: PUSH
81075: LD_INT 0
81077: PUSH
81078: EMPTY
81079: LIST
81080: LIST
81081: PUSH
81082: LD_INT 4
81084: PUSH
81085: LD_INT 1
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 3
81094: PUSH
81095: LD_INT 1
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: PUSH
81102: LD_INT 2
81104: PUSH
81105: LD_INT 0
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 2
81114: PUSH
81115: LD_INT 1
81117: NEG
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 2
81125: PUSH
81126: LD_INT 2
81128: NEG
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 4
81136: PUSH
81137: LD_INT 2
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: LD_INT 4
81146: PUSH
81147: LD_INT 4
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: LD_INT 4
81156: PUSH
81157: LD_INT 3
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 5
81166: PUSH
81167: LD_INT 4
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: PUSH
81174: LD_INT 5
81176: PUSH
81177: LD_INT 5
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 4
81186: PUSH
81187: LD_INT 5
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 3
81196: PUSH
81197: LD_INT 4
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 3
81206: PUSH
81207: LD_INT 3
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 5
81216: PUSH
81217: LD_INT 3
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 3
81226: PUSH
81227: LD_INT 5
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 0
81236: PUSH
81237: LD_INT 3
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 0
81246: PUSH
81247: LD_INT 2
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 1
81256: PUSH
81257: LD_INT 3
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 1
81266: PUSH
81267: LD_INT 4
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 0
81276: PUSH
81277: LD_INT 4
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 1
81286: NEG
81287: PUSH
81288: LD_INT 3
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 1
81297: NEG
81298: PUSH
81299: LD_INT 2
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 2
81308: PUSH
81309: LD_INT 4
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 2
81318: NEG
81319: PUSH
81320: LD_INT 2
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 4
81329: NEG
81330: PUSH
81331: LD_INT 0
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 4
81340: NEG
81341: PUSH
81342: LD_INT 1
81344: NEG
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: LD_INT 3
81352: NEG
81353: PUSH
81354: LD_INT 0
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 3
81363: NEG
81364: PUSH
81365: LD_INT 1
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 4
81374: NEG
81375: PUSH
81376: LD_INT 1
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 5
81385: NEG
81386: PUSH
81387: LD_INT 0
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: PUSH
81394: LD_INT 5
81396: NEG
81397: PUSH
81398: LD_INT 1
81400: NEG
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 5
81408: NEG
81409: PUSH
81410: LD_INT 2
81412: NEG
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 3
81420: NEG
81421: PUSH
81422: LD_INT 2
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: ST_TO_ADDR
// end ; end ;
81476: GO 81479
81478: POP
// case btype of b_depot , b_warehouse :
81479: LD_VAR 0 1
81483: PUSH
81484: LD_INT 0
81486: DOUBLE
81487: EQUAL
81488: IFTRUE 81498
81490: LD_INT 1
81492: DOUBLE
81493: EQUAL
81494: IFTRUE 81498
81496: GO 81699
81498: POP
// case nation of nation_american :
81499: LD_VAR 0 5
81503: PUSH
81504: LD_INT 1
81506: DOUBLE
81507: EQUAL
81508: IFTRUE 81512
81510: GO 81568
81512: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
81513: LD_ADDR_VAR 0 9
81517: PUSH
81518: LD_VAR 0 11
81522: PUSH
81523: LD_VAR 0 12
81527: PUSH
81528: LD_VAR 0 13
81532: PUSH
81533: LD_VAR 0 14
81537: PUSH
81538: LD_VAR 0 15
81542: PUSH
81543: LD_VAR 0 16
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: PUSH
81556: LD_VAR 0 4
81560: PUSH
81561: LD_INT 1
81563: PLUS
81564: ARRAY
81565: ST_TO_ADDR
81566: GO 81697
81568: LD_INT 2
81570: DOUBLE
81571: EQUAL
81572: IFTRUE 81576
81574: GO 81632
81576: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
81577: LD_ADDR_VAR 0 9
81581: PUSH
81582: LD_VAR 0 17
81586: PUSH
81587: LD_VAR 0 18
81591: PUSH
81592: LD_VAR 0 19
81596: PUSH
81597: LD_VAR 0 20
81601: PUSH
81602: LD_VAR 0 21
81606: PUSH
81607: LD_VAR 0 22
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: PUSH
81620: LD_VAR 0 4
81624: PUSH
81625: LD_INT 1
81627: PLUS
81628: ARRAY
81629: ST_TO_ADDR
81630: GO 81697
81632: LD_INT 3
81634: DOUBLE
81635: EQUAL
81636: IFTRUE 81640
81638: GO 81696
81640: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81641: LD_ADDR_VAR 0 9
81645: PUSH
81646: LD_VAR 0 23
81650: PUSH
81651: LD_VAR 0 24
81655: PUSH
81656: LD_VAR 0 25
81660: PUSH
81661: LD_VAR 0 26
81665: PUSH
81666: LD_VAR 0 27
81670: PUSH
81671: LD_VAR 0 28
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: PUSH
81684: LD_VAR 0 4
81688: PUSH
81689: LD_INT 1
81691: PLUS
81692: ARRAY
81693: ST_TO_ADDR
81694: GO 81697
81696: POP
81697: GO 82252
81699: LD_INT 2
81701: DOUBLE
81702: EQUAL
81703: IFTRUE 81713
81705: LD_INT 3
81707: DOUBLE
81708: EQUAL
81709: IFTRUE 81713
81711: GO 81769
81713: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81714: LD_ADDR_VAR 0 9
81718: PUSH
81719: LD_VAR 0 29
81723: PUSH
81724: LD_VAR 0 30
81728: PUSH
81729: LD_VAR 0 31
81733: PUSH
81734: LD_VAR 0 32
81738: PUSH
81739: LD_VAR 0 33
81743: PUSH
81744: LD_VAR 0 34
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: PUSH
81757: LD_VAR 0 4
81761: PUSH
81762: LD_INT 1
81764: PLUS
81765: ARRAY
81766: ST_TO_ADDR
81767: GO 82252
81769: LD_INT 16
81771: DOUBLE
81772: EQUAL
81773: IFTRUE 81831
81775: LD_INT 17
81777: DOUBLE
81778: EQUAL
81779: IFTRUE 81831
81781: LD_INT 18
81783: DOUBLE
81784: EQUAL
81785: IFTRUE 81831
81787: LD_INT 19
81789: DOUBLE
81790: EQUAL
81791: IFTRUE 81831
81793: LD_INT 22
81795: DOUBLE
81796: EQUAL
81797: IFTRUE 81831
81799: LD_INT 20
81801: DOUBLE
81802: EQUAL
81803: IFTRUE 81831
81805: LD_INT 21
81807: DOUBLE
81808: EQUAL
81809: IFTRUE 81831
81811: LD_INT 23
81813: DOUBLE
81814: EQUAL
81815: IFTRUE 81831
81817: LD_INT 24
81819: DOUBLE
81820: EQUAL
81821: IFTRUE 81831
81823: LD_INT 25
81825: DOUBLE
81826: EQUAL
81827: IFTRUE 81831
81829: GO 81887
81831: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81832: LD_ADDR_VAR 0 9
81836: PUSH
81837: LD_VAR 0 35
81841: PUSH
81842: LD_VAR 0 36
81846: PUSH
81847: LD_VAR 0 37
81851: PUSH
81852: LD_VAR 0 38
81856: PUSH
81857: LD_VAR 0 39
81861: PUSH
81862: LD_VAR 0 40
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: PUSH
81875: LD_VAR 0 4
81879: PUSH
81880: LD_INT 1
81882: PLUS
81883: ARRAY
81884: ST_TO_ADDR
81885: GO 82252
81887: LD_INT 6
81889: DOUBLE
81890: EQUAL
81891: IFTRUE 81943
81893: LD_INT 7
81895: DOUBLE
81896: EQUAL
81897: IFTRUE 81943
81899: LD_INT 8
81901: DOUBLE
81902: EQUAL
81903: IFTRUE 81943
81905: LD_INT 13
81907: DOUBLE
81908: EQUAL
81909: IFTRUE 81943
81911: LD_INT 12
81913: DOUBLE
81914: EQUAL
81915: IFTRUE 81943
81917: LD_INT 15
81919: DOUBLE
81920: EQUAL
81921: IFTRUE 81943
81923: LD_INT 11
81925: DOUBLE
81926: EQUAL
81927: IFTRUE 81943
81929: LD_INT 14
81931: DOUBLE
81932: EQUAL
81933: IFTRUE 81943
81935: LD_INT 10
81937: DOUBLE
81938: EQUAL
81939: IFTRUE 81943
81941: GO 81999
81943: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
81944: LD_ADDR_VAR 0 9
81948: PUSH
81949: LD_VAR 0 41
81953: PUSH
81954: LD_VAR 0 42
81958: PUSH
81959: LD_VAR 0 43
81963: PUSH
81964: LD_VAR 0 44
81968: PUSH
81969: LD_VAR 0 45
81973: PUSH
81974: LD_VAR 0 46
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: PUSH
81987: LD_VAR 0 4
81991: PUSH
81992: LD_INT 1
81994: PLUS
81995: ARRAY
81996: ST_TO_ADDR
81997: GO 82252
81999: LD_INT 36
82001: DOUBLE
82002: EQUAL
82003: IFTRUE 82007
82005: GO 82063
82007: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
82008: LD_ADDR_VAR 0 9
82012: PUSH
82013: LD_VAR 0 47
82017: PUSH
82018: LD_VAR 0 48
82022: PUSH
82023: LD_VAR 0 49
82027: PUSH
82028: LD_VAR 0 50
82032: PUSH
82033: LD_VAR 0 51
82037: PUSH
82038: LD_VAR 0 52
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: PUSH
82051: LD_VAR 0 4
82055: PUSH
82056: LD_INT 1
82058: PLUS
82059: ARRAY
82060: ST_TO_ADDR
82061: GO 82252
82063: LD_INT 4
82065: DOUBLE
82066: EQUAL
82067: IFTRUE 82089
82069: LD_INT 5
82071: DOUBLE
82072: EQUAL
82073: IFTRUE 82089
82075: LD_INT 34
82077: DOUBLE
82078: EQUAL
82079: IFTRUE 82089
82081: LD_INT 37
82083: DOUBLE
82084: EQUAL
82085: IFTRUE 82089
82087: GO 82145
82089: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
82090: LD_ADDR_VAR 0 9
82094: PUSH
82095: LD_VAR 0 53
82099: PUSH
82100: LD_VAR 0 54
82104: PUSH
82105: LD_VAR 0 55
82109: PUSH
82110: LD_VAR 0 56
82114: PUSH
82115: LD_VAR 0 57
82119: PUSH
82120: LD_VAR 0 58
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: LIST
82132: PUSH
82133: LD_VAR 0 4
82137: PUSH
82138: LD_INT 1
82140: PLUS
82141: ARRAY
82142: ST_TO_ADDR
82143: GO 82252
82145: LD_INT 31
82147: DOUBLE
82148: EQUAL
82149: IFTRUE 82195
82151: LD_INT 32
82153: DOUBLE
82154: EQUAL
82155: IFTRUE 82195
82157: LD_INT 33
82159: DOUBLE
82160: EQUAL
82161: IFTRUE 82195
82163: LD_INT 27
82165: DOUBLE
82166: EQUAL
82167: IFTRUE 82195
82169: LD_INT 26
82171: DOUBLE
82172: EQUAL
82173: IFTRUE 82195
82175: LD_INT 28
82177: DOUBLE
82178: EQUAL
82179: IFTRUE 82195
82181: LD_INT 29
82183: DOUBLE
82184: EQUAL
82185: IFTRUE 82195
82187: LD_INT 30
82189: DOUBLE
82190: EQUAL
82191: IFTRUE 82195
82193: GO 82251
82195: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
82196: LD_ADDR_VAR 0 9
82200: PUSH
82201: LD_VAR 0 59
82205: PUSH
82206: LD_VAR 0 60
82210: PUSH
82211: LD_VAR 0 61
82215: PUSH
82216: LD_VAR 0 62
82220: PUSH
82221: LD_VAR 0 63
82225: PUSH
82226: LD_VAR 0 64
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: PUSH
82239: LD_VAR 0 4
82243: PUSH
82244: LD_INT 1
82246: PLUS
82247: ARRAY
82248: ST_TO_ADDR
82249: GO 82252
82251: POP
// temp_list2 = [ ] ;
82252: LD_ADDR_VAR 0 10
82256: PUSH
82257: EMPTY
82258: ST_TO_ADDR
// for i in temp_list do
82259: LD_ADDR_VAR 0 8
82263: PUSH
82264: LD_VAR 0 9
82268: PUSH
82269: FOR_IN
82270: IFFALSE 82322
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
82272: LD_ADDR_VAR 0 10
82276: PUSH
82277: LD_VAR 0 10
82281: PUSH
82282: LD_VAR 0 8
82286: PUSH
82287: LD_INT 1
82289: ARRAY
82290: PUSH
82291: LD_VAR 0 2
82295: PLUS
82296: PUSH
82297: LD_VAR 0 8
82301: PUSH
82302: LD_INT 2
82304: ARRAY
82305: PUSH
82306: LD_VAR 0 3
82310: PLUS
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: EMPTY
82317: LIST
82318: ADD
82319: ST_TO_ADDR
82320: GO 82269
82322: POP
82323: POP
// result = temp_list2 ;
82324: LD_ADDR_VAR 0 7
82328: PUSH
82329: LD_VAR 0 10
82333: ST_TO_ADDR
// end ;
82334: LD_VAR 0 7
82338: RET
// export function EnemyInRange ( unit , dist ) ; begin
82339: LD_INT 0
82341: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82342: LD_ADDR_VAR 0 3
82346: PUSH
82347: LD_VAR 0 1
82351: PPUSH
82352: CALL_OW 255
82356: PPUSH
82357: LD_VAR 0 1
82361: PPUSH
82362: CALL_OW 250
82366: PPUSH
82367: LD_VAR 0 1
82371: PPUSH
82372: CALL_OW 251
82376: PPUSH
82377: LD_VAR 0 2
82381: PPUSH
82382: CALL 56443 0 4
82386: PUSH
82387: LD_INT 4
82389: ARRAY
82390: ST_TO_ADDR
// end ;
82391: LD_VAR 0 3
82395: RET
// export function PlayerSeeMe ( unit ) ; begin
82396: LD_INT 0
82398: PPUSH
// result := See ( your_side , unit ) ;
82399: LD_ADDR_VAR 0 2
82403: PUSH
82404: LD_OWVAR 2
82408: PPUSH
82409: LD_VAR 0 1
82413: PPUSH
82414: CALL_OW 292
82418: ST_TO_ADDR
// end ;
82419: LD_VAR 0 2
82423: RET
// export function ReverseDir ( unit ) ; begin
82424: LD_INT 0
82426: PPUSH
// if not unit then
82427: LD_VAR 0 1
82431: NOT
82432: IFFALSE 82436
// exit ;
82434: GO 82459
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82436: LD_ADDR_VAR 0 2
82440: PUSH
82441: LD_VAR 0 1
82445: PPUSH
82446: CALL_OW 254
82450: PUSH
82451: LD_INT 3
82453: PLUS
82454: PUSH
82455: LD_INT 6
82457: MOD
82458: ST_TO_ADDR
// end ;
82459: LD_VAR 0 2
82463: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
82464: LD_INT 0
82466: PPUSH
82467: PPUSH
82468: PPUSH
82469: PPUSH
82470: PPUSH
// if not hexes then
82471: LD_VAR 0 2
82475: NOT
82476: IFFALSE 82480
// exit ;
82478: GO 82628
// dist := 9999 ;
82480: LD_ADDR_VAR 0 5
82484: PUSH
82485: LD_INT 9999
82487: ST_TO_ADDR
// for i = 1 to hexes do
82488: LD_ADDR_VAR 0 4
82492: PUSH
82493: DOUBLE
82494: LD_INT 1
82496: DEC
82497: ST_TO_ADDR
82498: LD_VAR 0 2
82502: PUSH
82503: FOR_TO
82504: IFFALSE 82616
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
82506: LD_VAR 0 1
82510: PPUSH
82511: LD_VAR 0 2
82515: PUSH
82516: LD_VAR 0 4
82520: ARRAY
82521: PUSH
82522: LD_INT 1
82524: ARRAY
82525: PPUSH
82526: LD_VAR 0 2
82530: PUSH
82531: LD_VAR 0 4
82535: ARRAY
82536: PUSH
82537: LD_INT 2
82539: ARRAY
82540: PPUSH
82541: CALL_OW 297
82545: PUSH
82546: LD_VAR 0 5
82550: LESS
82551: IFFALSE 82614
// begin hex := hexes [ i ] ;
82553: LD_ADDR_VAR 0 7
82557: PUSH
82558: LD_VAR 0 2
82562: PUSH
82563: LD_VAR 0 4
82567: ARRAY
82568: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82569: LD_ADDR_VAR 0 5
82573: PUSH
82574: LD_VAR 0 1
82578: PPUSH
82579: LD_VAR 0 2
82583: PUSH
82584: LD_VAR 0 4
82588: ARRAY
82589: PUSH
82590: LD_INT 1
82592: ARRAY
82593: PPUSH
82594: LD_VAR 0 2
82598: PUSH
82599: LD_VAR 0 4
82603: ARRAY
82604: PUSH
82605: LD_INT 2
82607: ARRAY
82608: PPUSH
82609: CALL_OW 297
82613: ST_TO_ADDR
// end ; end ;
82614: GO 82503
82616: POP
82617: POP
// result := hex ;
82618: LD_ADDR_VAR 0 3
82622: PUSH
82623: LD_VAR 0 7
82627: ST_TO_ADDR
// end ;
82628: LD_VAR 0 3
82632: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82633: LD_INT 0
82635: PPUSH
82636: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82637: LD_VAR 0 1
82641: NOT
82642: PUSH
82643: LD_VAR 0 1
82647: PUSH
82648: LD_INT 21
82650: PUSH
82651: LD_INT 2
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 23
82660: PUSH
82661: LD_INT 2
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PPUSH
82672: CALL_OW 69
82676: IN
82677: NOT
82678: OR
82679: IFFALSE 82683
// exit ;
82681: GO 82730
// for i = 1 to 3 do
82683: LD_ADDR_VAR 0 3
82687: PUSH
82688: DOUBLE
82689: LD_INT 1
82691: DEC
82692: ST_TO_ADDR
82693: LD_INT 3
82695: PUSH
82696: FOR_TO
82697: IFFALSE 82728
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82699: LD_VAR 0 1
82703: PPUSH
82704: CALL_OW 250
82708: PPUSH
82709: LD_VAR 0 1
82713: PPUSH
82714: CALL_OW 251
82718: PPUSH
82719: LD_INT 1
82721: PPUSH
82722: CALL_OW 453
82726: GO 82696
82728: POP
82729: POP
// end ;
82730: LD_VAR 0 2
82734: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82735: LD_INT 0
82737: PPUSH
82738: PPUSH
82739: PPUSH
82740: PPUSH
82741: PPUSH
82742: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82743: LD_VAR 0 1
82747: NOT
82748: PUSH
82749: LD_VAR 0 2
82753: NOT
82754: OR
82755: PUSH
82756: LD_VAR 0 1
82760: PPUSH
82761: CALL_OW 314
82765: OR
82766: IFFALSE 82770
// exit ;
82768: GO 83211
// x := GetX ( enemy_unit ) ;
82770: LD_ADDR_VAR 0 7
82774: PUSH
82775: LD_VAR 0 2
82779: PPUSH
82780: CALL_OW 250
82784: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82785: LD_ADDR_VAR 0 8
82789: PUSH
82790: LD_VAR 0 2
82794: PPUSH
82795: CALL_OW 251
82799: ST_TO_ADDR
// if not x or not y then
82800: LD_VAR 0 7
82804: NOT
82805: PUSH
82806: LD_VAR 0 8
82810: NOT
82811: OR
82812: IFFALSE 82816
// exit ;
82814: GO 83211
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82816: LD_ADDR_VAR 0 6
82820: PUSH
82821: LD_VAR 0 7
82825: PPUSH
82826: LD_INT 0
82828: PPUSH
82829: LD_INT 4
82831: PPUSH
82832: CALL_OW 272
82836: PUSH
82837: LD_VAR 0 8
82841: PPUSH
82842: LD_INT 0
82844: PPUSH
82845: LD_INT 4
82847: PPUSH
82848: CALL_OW 273
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_VAR 0 7
82861: PPUSH
82862: LD_INT 1
82864: PPUSH
82865: LD_INT 4
82867: PPUSH
82868: CALL_OW 272
82872: PUSH
82873: LD_VAR 0 8
82877: PPUSH
82878: LD_INT 1
82880: PPUSH
82881: LD_INT 4
82883: PPUSH
82884: CALL_OW 273
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_VAR 0 7
82897: PPUSH
82898: LD_INT 2
82900: PPUSH
82901: LD_INT 4
82903: PPUSH
82904: CALL_OW 272
82908: PUSH
82909: LD_VAR 0 8
82913: PPUSH
82914: LD_INT 2
82916: PPUSH
82917: LD_INT 4
82919: PPUSH
82920: CALL_OW 273
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_VAR 0 7
82933: PPUSH
82934: LD_INT 3
82936: PPUSH
82937: LD_INT 4
82939: PPUSH
82940: CALL_OW 272
82944: PUSH
82945: LD_VAR 0 8
82949: PPUSH
82950: LD_INT 3
82952: PPUSH
82953: LD_INT 4
82955: PPUSH
82956: CALL_OW 273
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: LD_VAR 0 7
82969: PPUSH
82970: LD_INT 4
82972: PPUSH
82973: LD_INT 4
82975: PPUSH
82976: CALL_OW 272
82980: PUSH
82981: LD_VAR 0 8
82985: PPUSH
82986: LD_INT 4
82988: PPUSH
82989: LD_INT 4
82991: PPUSH
82992: CALL_OW 273
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_VAR 0 7
83005: PPUSH
83006: LD_INT 5
83008: PPUSH
83009: LD_INT 4
83011: PPUSH
83012: CALL_OW 272
83016: PUSH
83017: LD_VAR 0 8
83021: PPUSH
83022: LD_INT 5
83024: PPUSH
83025: LD_INT 4
83027: PPUSH
83028: CALL_OW 273
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: ST_TO_ADDR
// for i = tmp downto 1 do
83045: LD_ADDR_VAR 0 4
83049: PUSH
83050: DOUBLE
83051: LD_VAR 0 6
83055: INC
83056: ST_TO_ADDR
83057: LD_INT 1
83059: PUSH
83060: FOR_DOWNTO
83061: IFFALSE 83162
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
83063: LD_VAR 0 6
83067: PUSH
83068: LD_VAR 0 4
83072: ARRAY
83073: PUSH
83074: LD_INT 1
83076: ARRAY
83077: PPUSH
83078: LD_VAR 0 6
83082: PUSH
83083: LD_VAR 0 4
83087: ARRAY
83088: PUSH
83089: LD_INT 2
83091: ARRAY
83092: PPUSH
83093: CALL_OW 488
83097: NOT
83098: PUSH
83099: LD_VAR 0 6
83103: PUSH
83104: LD_VAR 0 4
83108: ARRAY
83109: PUSH
83110: LD_INT 1
83112: ARRAY
83113: PPUSH
83114: LD_VAR 0 6
83118: PUSH
83119: LD_VAR 0 4
83123: ARRAY
83124: PUSH
83125: LD_INT 2
83127: ARRAY
83128: PPUSH
83129: CALL_OW 428
83133: PUSH
83134: LD_INT 0
83136: NONEQUAL
83137: OR
83138: IFFALSE 83160
// tmp := Delete ( tmp , i ) ;
83140: LD_ADDR_VAR 0 6
83144: PUSH
83145: LD_VAR 0 6
83149: PPUSH
83150: LD_VAR 0 4
83154: PPUSH
83155: CALL_OW 3
83159: ST_TO_ADDR
83160: GO 83060
83162: POP
83163: POP
// j := GetClosestHex ( unit , tmp ) ;
83164: LD_ADDR_VAR 0 5
83168: PUSH
83169: LD_VAR 0 1
83173: PPUSH
83174: LD_VAR 0 6
83178: PPUSH
83179: CALL 82464 0 2
83183: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
83184: LD_VAR 0 1
83188: PPUSH
83189: LD_VAR 0 5
83193: PUSH
83194: LD_INT 1
83196: ARRAY
83197: PPUSH
83198: LD_VAR 0 5
83202: PUSH
83203: LD_INT 2
83205: ARRAY
83206: PPUSH
83207: CALL_OW 111
// end ;
83211: LD_VAR 0 3
83215: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83216: LD_INT 0
83218: PPUSH
83219: PPUSH
83220: PPUSH
// uc_side = 0 ;
83221: LD_ADDR_OWVAR 20
83225: PUSH
83226: LD_INT 0
83228: ST_TO_ADDR
// uc_nation = 0 ;
83229: LD_ADDR_OWVAR 21
83233: PUSH
83234: LD_INT 0
83236: ST_TO_ADDR
// InitHc ;
83237: CALL_OW 19
// InitVc ;
83241: CALL_OW 20
// if mastodonts then
83245: LD_VAR 0 6
83249: IFFALSE 83316
// for i = 1 to mastodonts do
83251: LD_ADDR_VAR 0 11
83255: PUSH
83256: DOUBLE
83257: LD_INT 1
83259: DEC
83260: ST_TO_ADDR
83261: LD_VAR 0 6
83265: PUSH
83266: FOR_TO
83267: IFFALSE 83314
// begin vc_chassis := 31 ;
83269: LD_ADDR_OWVAR 37
83273: PUSH
83274: LD_INT 31
83276: ST_TO_ADDR
// vc_control := control_rider ;
83277: LD_ADDR_OWVAR 38
83281: PUSH
83282: LD_INT 4
83284: ST_TO_ADDR
// animal := CreateVehicle ;
83285: LD_ADDR_VAR 0 12
83289: PUSH
83290: CALL_OW 45
83294: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83295: LD_VAR 0 12
83299: PPUSH
83300: LD_VAR 0 8
83304: PPUSH
83305: LD_INT 0
83307: PPUSH
83308: CALL 85385 0 3
// end ;
83312: GO 83266
83314: POP
83315: POP
// if horses then
83316: LD_VAR 0 5
83320: IFFALSE 83387
// for i = 1 to horses do
83322: LD_ADDR_VAR 0 11
83326: PUSH
83327: DOUBLE
83328: LD_INT 1
83330: DEC
83331: ST_TO_ADDR
83332: LD_VAR 0 5
83336: PUSH
83337: FOR_TO
83338: IFFALSE 83385
// begin hc_class := 21 ;
83340: LD_ADDR_OWVAR 28
83344: PUSH
83345: LD_INT 21
83347: ST_TO_ADDR
// hc_gallery :=  ;
83348: LD_ADDR_OWVAR 33
83352: PUSH
83353: LD_STRING 
83355: ST_TO_ADDR
// animal := CreateHuman ;
83356: LD_ADDR_VAR 0 12
83360: PUSH
83361: CALL_OW 44
83365: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83366: LD_VAR 0 12
83370: PPUSH
83371: LD_VAR 0 8
83375: PPUSH
83376: LD_INT 0
83378: PPUSH
83379: CALL 85385 0 3
// end ;
83383: GO 83337
83385: POP
83386: POP
// if birds then
83387: LD_VAR 0 1
83391: IFFALSE 83458
// for i = 1 to birds do
83393: LD_ADDR_VAR 0 11
83397: PUSH
83398: DOUBLE
83399: LD_INT 1
83401: DEC
83402: ST_TO_ADDR
83403: LD_VAR 0 1
83407: PUSH
83408: FOR_TO
83409: IFFALSE 83456
// begin hc_class = 18 ;
83411: LD_ADDR_OWVAR 28
83415: PUSH
83416: LD_INT 18
83418: ST_TO_ADDR
// hc_gallery =  ;
83419: LD_ADDR_OWVAR 33
83423: PUSH
83424: LD_STRING 
83426: ST_TO_ADDR
// animal := CreateHuman ;
83427: LD_ADDR_VAR 0 12
83431: PUSH
83432: CALL_OW 44
83436: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83437: LD_VAR 0 12
83441: PPUSH
83442: LD_VAR 0 8
83446: PPUSH
83447: LD_INT 0
83449: PPUSH
83450: CALL 85385 0 3
// end ;
83454: GO 83408
83456: POP
83457: POP
// if tigers then
83458: LD_VAR 0 2
83462: IFFALSE 83546
// for i = 1 to tigers do
83464: LD_ADDR_VAR 0 11
83468: PUSH
83469: DOUBLE
83470: LD_INT 1
83472: DEC
83473: ST_TO_ADDR
83474: LD_VAR 0 2
83478: PUSH
83479: FOR_TO
83480: IFFALSE 83544
// begin hc_class = class_tiger ;
83482: LD_ADDR_OWVAR 28
83486: PUSH
83487: LD_INT 14
83489: ST_TO_ADDR
// hc_gallery =  ;
83490: LD_ADDR_OWVAR 33
83494: PUSH
83495: LD_STRING 
83497: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83498: LD_ADDR_OWVAR 35
83502: PUSH
83503: LD_INT 7
83505: NEG
83506: PPUSH
83507: LD_INT 7
83509: PPUSH
83510: CALL_OW 12
83514: ST_TO_ADDR
// animal := CreateHuman ;
83515: LD_ADDR_VAR 0 12
83519: PUSH
83520: CALL_OW 44
83524: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83525: LD_VAR 0 12
83529: PPUSH
83530: LD_VAR 0 8
83534: PPUSH
83535: LD_INT 0
83537: PPUSH
83538: CALL 85385 0 3
// end ;
83542: GO 83479
83544: POP
83545: POP
// if apemans then
83546: LD_VAR 0 3
83550: IFFALSE 83673
// for i = 1 to apemans do
83552: LD_ADDR_VAR 0 11
83556: PUSH
83557: DOUBLE
83558: LD_INT 1
83560: DEC
83561: ST_TO_ADDR
83562: LD_VAR 0 3
83566: PUSH
83567: FOR_TO
83568: IFFALSE 83671
// begin hc_class = class_apeman ;
83570: LD_ADDR_OWVAR 28
83574: PUSH
83575: LD_INT 12
83577: ST_TO_ADDR
// hc_gallery =  ;
83578: LD_ADDR_OWVAR 33
83582: PUSH
83583: LD_STRING 
83585: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
83586: LD_ADDR_OWVAR 35
83590: PUSH
83591: LD_INT 5
83593: NEG
83594: PPUSH
83595: LD_INT 5
83597: PPUSH
83598: CALL_OW 12
83602: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83603: LD_ADDR_OWVAR 31
83607: PUSH
83608: LD_INT 1
83610: PPUSH
83611: LD_INT 3
83613: PPUSH
83614: CALL_OW 12
83618: PUSH
83619: LD_INT 1
83621: PPUSH
83622: LD_INT 3
83624: PPUSH
83625: CALL_OW 12
83629: PUSH
83630: LD_INT 0
83632: PUSH
83633: LD_INT 0
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: ST_TO_ADDR
// animal := CreateHuman ;
83642: LD_ADDR_VAR 0 12
83646: PUSH
83647: CALL_OW 44
83651: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83652: LD_VAR 0 12
83656: PPUSH
83657: LD_VAR 0 8
83661: PPUSH
83662: LD_INT 0
83664: PPUSH
83665: CALL 85385 0 3
// end ;
83669: GO 83567
83671: POP
83672: POP
// if enchidnas then
83673: LD_VAR 0 4
83677: IFFALSE 83744
// for i = 1 to enchidnas do
83679: LD_ADDR_VAR 0 11
83683: PUSH
83684: DOUBLE
83685: LD_INT 1
83687: DEC
83688: ST_TO_ADDR
83689: LD_VAR 0 4
83693: PUSH
83694: FOR_TO
83695: IFFALSE 83742
// begin hc_class = 13 ;
83697: LD_ADDR_OWVAR 28
83701: PUSH
83702: LD_INT 13
83704: ST_TO_ADDR
// hc_gallery =  ;
83705: LD_ADDR_OWVAR 33
83709: PUSH
83710: LD_STRING 
83712: ST_TO_ADDR
// animal := CreateHuman ;
83713: LD_ADDR_VAR 0 12
83717: PUSH
83718: CALL_OW 44
83722: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83723: LD_VAR 0 12
83727: PPUSH
83728: LD_VAR 0 8
83732: PPUSH
83733: LD_INT 0
83735: PPUSH
83736: CALL 85385 0 3
// end ;
83740: GO 83694
83742: POP
83743: POP
// if fishes then
83744: LD_VAR 0 7
83748: IFFALSE 83815
// for i = 1 to fishes do
83750: LD_ADDR_VAR 0 11
83754: PUSH
83755: DOUBLE
83756: LD_INT 1
83758: DEC
83759: ST_TO_ADDR
83760: LD_VAR 0 7
83764: PUSH
83765: FOR_TO
83766: IFFALSE 83813
// begin hc_class = 20 ;
83768: LD_ADDR_OWVAR 28
83772: PUSH
83773: LD_INT 20
83775: ST_TO_ADDR
// hc_gallery =  ;
83776: LD_ADDR_OWVAR 33
83780: PUSH
83781: LD_STRING 
83783: ST_TO_ADDR
// animal := CreateHuman ;
83784: LD_ADDR_VAR 0 12
83788: PUSH
83789: CALL_OW 44
83793: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83794: LD_VAR 0 12
83798: PPUSH
83799: LD_VAR 0 9
83803: PPUSH
83804: LD_INT 0
83806: PPUSH
83807: CALL 85385 0 3
// end ;
83811: GO 83765
83813: POP
83814: POP
// end ;
83815: LD_VAR 0 10
83819: RET
// export function WantHeal ( sci , unit ) ; begin
83820: LD_INT 0
83822: PPUSH
// if GetTaskList ( sci ) > 0 then
83823: LD_VAR 0 1
83827: PPUSH
83828: CALL_OW 437
83832: PUSH
83833: LD_INT 0
83835: GREATER
83836: IFFALSE 83906
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83838: LD_VAR 0 1
83842: PPUSH
83843: CALL_OW 437
83847: PUSH
83848: LD_INT 1
83850: ARRAY
83851: PUSH
83852: LD_INT 1
83854: ARRAY
83855: PUSH
83856: LD_STRING l
83858: EQUAL
83859: PUSH
83860: LD_VAR 0 1
83864: PPUSH
83865: CALL_OW 437
83869: PUSH
83870: LD_INT 1
83872: ARRAY
83873: PUSH
83874: LD_INT 4
83876: ARRAY
83877: PUSH
83878: LD_VAR 0 2
83882: EQUAL
83883: AND
83884: IFFALSE 83896
// result := true else
83886: LD_ADDR_VAR 0 3
83890: PUSH
83891: LD_INT 1
83893: ST_TO_ADDR
83894: GO 83904
// result := false ;
83896: LD_ADDR_VAR 0 3
83900: PUSH
83901: LD_INT 0
83903: ST_TO_ADDR
// end else
83904: GO 83914
// result := false ;
83906: LD_ADDR_VAR 0 3
83910: PUSH
83911: LD_INT 0
83913: ST_TO_ADDR
// end ;
83914: LD_VAR 0 3
83918: RET
// export function HealTarget ( sci ) ; begin
83919: LD_INT 0
83921: PPUSH
// if not sci then
83922: LD_VAR 0 1
83926: NOT
83927: IFFALSE 83931
// exit ;
83929: GO 83996
// result := 0 ;
83931: LD_ADDR_VAR 0 2
83935: PUSH
83936: LD_INT 0
83938: ST_TO_ADDR
// if GetTaskList ( sci ) then
83939: LD_VAR 0 1
83943: PPUSH
83944: CALL_OW 437
83948: IFFALSE 83996
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83950: LD_VAR 0 1
83954: PPUSH
83955: CALL_OW 437
83959: PUSH
83960: LD_INT 1
83962: ARRAY
83963: PUSH
83964: LD_INT 1
83966: ARRAY
83967: PUSH
83968: LD_STRING l
83970: EQUAL
83971: IFFALSE 83996
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83973: LD_ADDR_VAR 0 2
83977: PUSH
83978: LD_VAR 0 1
83982: PPUSH
83983: CALL_OW 437
83987: PUSH
83988: LD_INT 1
83990: ARRAY
83991: PUSH
83992: LD_INT 4
83994: ARRAY
83995: ST_TO_ADDR
// end ;
83996: LD_VAR 0 2
84000: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84001: LD_INT 0
84003: PPUSH
84004: PPUSH
84005: PPUSH
84006: PPUSH
// if not base_units then
84007: LD_VAR 0 1
84011: NOT
84012: IFFALSE 84016
// exit ;
84014: GO 84103
// result := false ;
84016: LD_ADDR_VAR 0 2
84020: PUSH
84021: LD_INT 0
84023: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84024: LD_ADDR_VAR 0 5
84028: PUSH
84029: LD_VAR 0 1
84033: PPUSH
84034: LD_INT 21
84036: PUSH
84037: LD_INT 3
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PPUSH
84044: CALL_OW 72
84048: ST_TO_ADDR
// if not tmp then
84049: LD_VAR 0 5
84053: NOT
84054: IFFALSE 84058
// exit ;
84056: GO 84103
// for i in tmp do
84058: LD_ADDR_VAR 0 3
84062: PUSH
84063: LD_VAR 0 5
84067: PUSH
84068: FOR_IN
84069: IFFALSE 84101
// begin result := EnemyInRange ( i , 22 ) ;
84071: LD_ADDR_VAR 0 2
84075: PUSH
84076: LD_VAR 0 3
84080: PPUSH
84081: LD_INT 22
84083: PPUSH
84084: CALL 82339 0 2
84088: ST_TO_ADDR
// if result then
84089: LD_VAR 0 2
84093: IFFALSE 84099
// exit ;
84095: POP
84096: POP
84097: GO 84103
// end ;
84099: GO 84068
84101: POP
84102: POP
// end ;
84103: LD_VAR 0 2
84107: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
84108: LD_INT 0
84110: PPUSH
84111: PPUSH
// if not units then
84112: LD_VAR 0 1
84116: NOT
84117: IFFALSE 84121
// exit ;
84119: GO 84191
// result := [ ] ;
84121: LD_ADDR_VAR 0 3
84125: PUSH
84126: EMPTY
84127: ST_TO_ADDR
// for i in units do
84128: LD_ADDR_VAR 0 4
84132: PUSH
84133: LD_VAR 0 1
84137: PUSH
84138: FOR_IN
84139: IFFALSE 84189
// if GetTag ( i ) = tag then
84141: LD_VAR 0 4
84145: PPUSH
84146: CALL_OW 110
84150: PUSH
84151: LD_VAR 0 2
84155: EQUAL
84156: IFFALSE 84187
// result := Insert ( result , result + 1 , i ) ;
84158: LD_ADDR_VAR 0 3
84162: PUSH
84163: LD_VAR 0 3
84167: PPUSH
84168: LD_VAR 0 3
84172: PUSH
84173: LD_INT 1
84175: PLUS
84176: PPUSH
84177: LD_VAR 0 4
84181: PPUSH
84182: CALL_OW 2
84186: ST_TO_ADDR
84187: GO 84138
84189: POP
84190: POP
// end ;
84191: LD_VAR 0 3
84195: RET
// export function IsDriver ( un ) ; begin
84196: LD_INT 0
84198: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84199: LD_ADDR_VAR 0 2
84203: PUSH
84204: LD_VAR 0 1
84208: PUSH
84209: LD_INT 55
84211: PUSH
84212: EMPTY
84213: LIST
84214: PPUSH
84215: CALL_OW 69
84219: IN
84220: ST_TO_ADDR
// end ;
84221: LD_VAR 0 2
84225: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84226: LD_INT 0
84228: PPUSH
84229: PPUSH
// list := [ ] ;
84230: LD_ADDR_VAR 0 5
84234: PUSH
84235: EMPTY
84236: ST_TO_ADDR
// case d of 0 :
84237: LD_VAR 0 3
84241: PUSH
84242: LD_INT 0
84244: DOUBLE
84245: EQUAL
84246: IFTRUE 84250
84248: GO 84383
84250: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84251: LD_ADDR_VAR 0 5
84255: PUSH
84256: LD_VAR 0 1
84260: PUSH
84261: LD_INT 4
84263: MINUS
84264: PUSH
84265: LD_VAR 0 2
84269: PUSH
84270: LD_INT 4
84272: MINUS
84273: PUSH
84274: LD_INT 2
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: LIST
84281: PUSH
84282: LD_VAR 0 1
84286: PUSH
84287: LD_INT 3
84289: MINUS
84290: PUSH
84291: LD_VAR 0 2
84295: PUSH
84296: LD_INT 1
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: LIST
84303: PUSH
84304: LD_VAR 0 1
84308: PUSH
84309: LD_INT 4
84311: PLUS
84312: PUSH
84313: LD_VAR 0 2
84317: PUSH
84318: LD_INT 4
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: LIST
84325: PUSH
84326: LD_VAR 0 1
84330: PUSH
84331: LD_INT 3
84333: PLUS
84334: PUSH
84335: LD_VAR 0 2
84339: PUSH
84340: LD_INT 3
84342: PLUS
84343: PUSH
84344: LD_INT 5
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: LIST
84351: PUSH
84352: LD_VAR 0 1
84356: PUSH
84357: LD_VAR 0 2
84361: PUSH
84362: LD_INT 4
84364: PLUS
84365: PUSH
84366: LD_INT 0
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: LIST
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: ST_TO_ADDR
// end ; 1 :
84381: GO 85081
84383: LD_INT 1
84385: DOUBLE
84386: EQUAL
84387: IFTRUE 84391
84389: GO 84524
84391: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84392: LD_ADDR_VAR 0 5
84396: PUSH
84397: LD_VAR 0 1
84401: PUSH
84402: LD_VAR 0 2
84406: PUSH
84407: LD_INT 4
84409: MINUS
84410: PUSH
84411: LD_INT 3
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: LIST
84418: PUSH
84419: LD_VAR 0 1
84423: PUSH
84424: LD_INT 3
84426: MINUS
84427: PUSH
84428: LD_VAR 0 2
84432: PUSH
84433: LD_INT 3
84435: MINUS
84436: PUSH
84437: LD_INT 2
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: LIST
84444: PUSH
84445: LD_VAR 0 1
84449: PUSH
84450: LD_INT 4
84452: MINUS
84453: PUSH
84454: LD_VAR 0 2
84458: PUSH
84459: LD_INT 1
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: LIST
84466: PUSH
84467: LD_VAR 0 1
84471: PUSH
84472: LD_VAR 0 2
84476: PUSH
84477: LD_INT 3
84479: PLUS
84480: PUSH
84481: LD_INT 0
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: LIST
84488: PUSH
84489: LD_VAR 0 1
84493: PUSH
84494: LD_INT 4
84496: PLUS
84497: PUSH
84498: LD_VAR 0 2
84502: PUSH
84503: LD_INT 4
84505: PLUS
84506: PUSH
84507: LD_INT 5
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: LIST
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: ST_TO_ADDR
// end ; 2 :
84522: GO 85081
84524: LD_INT 2
84526: DOUBLE
84527: EQUAL
84528: IFTRUE 84532
84530: GO 84661
84532: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84533: LD_ADDR_VAR 0 5
84537: PUSH
84538: LD_VAR 0 1
84542: PUSH
84543: LD_VAR 0 2
84547: PUSH
84548: LD_INT 3
84550: MINUS
84551: PUSH
84552: LD_INT 3
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: LIST
84559: PUSH
84560: LD_VAR 0 1
84564: PUSH
84565: LD_INT 4
84567: PLUS
84568: PUSH
84569: LD_VAR 0 2
84573: PUSH
84574: LD_INT 4
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: LIST
84581: PUSH
84582: LD_VAR 0 1
84586: PUSH
84587: LD_VAR 0 2
84591: PUSH
84592: LD_INT 4
84594: PLUS
84595: PUSH
84596: LD_INT 0
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: LIST
84603: PUSH
84604: LD_VAR 0 1
84608: PUSH
84609: LD_INT 3
84611: MINUS
84612: PUSH
84613: LD_VAR 0 2
84617: PUSH
84618: LD_INT 1
84620: PUSH
84621: EMPTY
84622: LIST
84623: LIST
84624: LIST
84625: PUSH
84626: LD_VAR 0 1
84630: PUSH
84631: LD_INT 4
84633: MINUS
84634: PUSH
84635: LD_VAR 0 2
84639: PUSH
84640: LD_INT 4
84642: MINUS
84643: PUSH
84644: LD_INT 2
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: LIST
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: ST_TO_ADDR
// end ; 3 :
84659: GO 85081
84661: LD_INT 3
84663: DOUBLE
84664: EQUAL
84665: IFTRUE 84669
84667: GO 84802
84669: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84670: LD_ADDR_VAR 0 5
84674: PUSH
84675: LD_VAR 0 1
84679: PUSH
84680: LD_INT 3
84682: PLUS
84683: PUSH
84684: LD_VAR 0 2
84688: PUSH
84689: LD_INT 4
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: LIST
84696: PUSH
84697: LD_VAR 0 1
84701: PUSH
84702: LD_INT 4
84704: PLUS
84705: PUSH
84706: LD_VAR 0 2
84710: PUSH
84711: LD_INT 4
84713: PLUS
84714: PUSH
84715: LD_INT 5
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: LIST
84722: PUSH
84723: LD_VAR 0 1
84727: PUSH
84728: LD_INT 4
84730: MINUS
84731: PUSH
84732: LD_VAR 0 2
84736: PUSH
84737: LD_INT 1
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: LIST
84744: PUSH
84745: LD_VAR 0 1
84749: PUSH
84750: LD_VAR 0 2
84754: PUSH
84755: LD_INT 4
84757: MINUS
84758: PUSH
84759: LD_INT 3
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: LIST
84766: PUSH
84767: LD_VAR 0 1
84771: PUSH
84772: LD_INT 3
84774: MINUS
84775: PUSH
84776: LD_VAR 0 2
84780: PUSH
84781: LD_INT 3
84783: MINUS
84784: PUSH
84785: LD_INT 2
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: LIST
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: LIST
84797: LIST
84798: LIST
84799: ST_TO_ADDR
// end ; 4 :
84800: GO 85081
84802: LD_INT 4
84804: DOUBLE
84805: EQUAL
84806: IFTRUE 84810
84808: GO 84943
84810: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84811: LD_ADDR_VAR 0 5
84815: PUSH
84816: LD_VAR 0 1
84820: PUSH
84821: LD_VAR 0 2
84825: PUSH
84826: LD_INT 4
84828: PLUS
84829: PUSH
84830: LD_INT 0
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: LIST
84837: PUSH
84838: LD_VAR 0 1
84842: PUSH
84843: LD_INT 3
84845: PLUS
84846: PUSH
84847: LD_VAR 0 2
84851: PUSH
84852: LD_INT 3
84854: PLUS
84855: PUSH
84856: LD_INT 5
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: LIST
84863: PUSH
84864: LD_VAR 0 1
84868: PUSH
84869: LD_INT 4
84871: PLUS
84872: PUSH
84873: LD_VAR 0 2
84877: PUSH
84878: LD_INT 4
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: LIST
84885: PUSH
84886: LD_VAR 0 1
84890: PUSH
84891: LD_VAR 0 2
84895: PUSH
84896: LD_INT 3
84898: MINUS
84899: PUSH
84900: LD_INT 3
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: LIST
84907: PUSH
84908: LD_VAR 0 1
84912: PUSH
84913: LD_INT 4
84915: MINUS
84916: PUSH
84917: LD_VAR 0 2
84921: PUSH
84922: LD_INT 4
84924: MINUS
84925: PUSH
84926: LD_INT 2
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: LIST
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: ST_TO_ADDR
// end ; 5 :
84941: GO 85081
84943: LD_INT 5
84945: DOUBLE
84946: EQUAL
84947: IFTRUE 84951
84949: GO 85080
84951: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84952: LD_ADDR_VAR 0 5
84956: PUSH
84957: LD_VAR 0 1
84961: PUSH
84962: LD_INT 4
84964: MINUS
84965: PUSH
84966: LD_VAR 0 2
84970: PUSH
84971: LD_INT 1
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: LIST
84978: PUSH
84979: LD_VAR 0 1
84983: PUSH
84984: LD_VAR 0 2
84988: PUSH
84989: LD_INT 4
84991: MINUS
84992: PUSH
84993: LD_INT 3
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: LIST
85000: PUSH
85001: LD_VAR 0 1
85005: PUSH
85006: LD_INT 4
85008: PLUS
85009: PUSH
85010: LD_VAR 0 2
85014: PUSH
85015: LD_INT 4
85017: PLUS
85018: PUSH
85019: LD_INT 5
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: LIST
85026: PUSH
85027: LD_VAR 0 1
85031: PUSH
85032: LD_INT 3
85034: PLUS
85035: PUSH
85036: LD_VAR 0 2
85040: PUSH
85041: LD_INT 4
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: LIST
85048: PUSH
85049: LD_VAR 0 1
85053: PUSH
85054: LD_VAR 0 2
85058: PUSH
85059: LD_INT 3
85061: PLUS
85062: PUSH
85063: LD_INT 0
85065: PUSH
85066: EMPTY
85067: LIST
85068: LIST
85069: LIST
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: ST_TO_ADDR
// end ; end ;
85078: GO 85081
85080: POP
// result := list ;
85081: LD_ADDR_VAR 0 4
85085: PUSH
85086: LD_VAR 0 5
85090: ST_TO_ADDR
// end ;
85091: LD_VAR 0 4
85095: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85096: LD_INT 0
85098: PPUSH
85099: PPUSH
85100: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85101: LD_VAR 0 1
85105: NOT
85106: PUSH
85107: LD_VAR 0 2
85111: PUSH
85112: LD_INT 1
85114: PUSH
85115: LD_INT 2
85117: PUSH
85118: LD_INT 3
85120: PUSH
85121: LD_INT 4
85123: PUSH
85124: EMPTY
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: IN
85130: NOT
85131: OR
85132: IFFALSE 85136
// exit ;
85134: GO 85228
// tmp := [ ] ;
85136: LD_ADDR_VAR 0 5
85140: PUSH
85141: EMPTY
85142: ST_TO_ADDR
// for i in units do
85143: LD_ADDR_VAR 0 4
85147: PUSH
85148: LD_VAR 0 1
85152: PUSH
85153: FOR_IN
85154: IFFALSE 85197
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
85156: LD_ADDR_VAR 0 5
85160: PUSH
85161: LD_VAR 0 5
85165: PPUSH
85166: LD_VAR 0 5
85170: PUSH
85171: LD_INT 1
85173: PLUS
85174: PPUSH
85175: LD_VAR 0 4
85179: PPUSH
85180: LD_VAR 0 2
85184: PPUSH
85185: CALL_OW 259
85189: PPUSH
85190: CALL_OW 2
85194: ST_TO_ADDR
85195: GO 85153
85197: POP
85198: POP
// if not tmp then
85199: LD_VAR 0 5
85203: NOT
85204: IFFALSE 85208
// exit ;
85206: GO 85228
// result := SortListByListDesc ( units , tmp ) ;
85208: LD_ADDR_VAR 0 3
85212: PUSH
85213: LD_VAR 0 1
85217: PPUSH
85218: LD_VAR 0 5
85222: PPUSH
85223: CALL_OW 77
85227: ST_TO_ADDR
// end ;
85228: LD_VAR 0 3
85232: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85233: LD_INT 0
85235: PPUSH
85236: PPUSH
85237: PPUSH
// x := GetX ( building ) ;
85238: LD_ADDR_VAR 0 4
85242: PUSH
85243: LD_VAR 0 2
85247: PPUSH
85248: CALL_OW 250
85252: ST_TO_ADDR
// y := GetY ( building ) ;
85253: LD_ADDR_VAR 0 5
85257: PUSH
85258: LD_VAR 0 2
85262: PPUSH
85263: CALL_OW 251
85267: ST_TO_ADDR
// if GetTaskList ( unit ) then
85268: LD_VAR 0 1
85272: PPUSH
85273: CALL_OW 437
85277: IFFALSE 85372
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85279: LD_STRING e
85281: PUSH
85282: LD_VAR 0 1
85286: PPUSH
85287: CALL_OW 437
85291: PUSH
85292: LD_INT 1
85294: ARRAY
85295: PUSH
85296: LD_INT 1
85298: ARRAY
85299: EQUAL
85300: PUSH
85301: LD_VAR 0 4
85305: PUSH
85306: LD_VAR 0 1
85310: PPUSH
85311: CALL_OW 437
85315: PUSH
85316: LD_INT 1
85318: ARRAY
85319: PUSH
85320: LD_INT 2
85322: ARRAY
85323: EQUAL
85324: AND
85325: PUSH
85326: LD_VAR 0 5
85330: PUSH
85331: LD_VAR 0 1
85335: PPUSH
85336: CALL_OW 437
85340: PUSH
85341: LD_INT 1
85343: ARRAY
85344: PUSH
85345: LD_INT 3
85347: ARRAY
85348: EQUAL
85349: AND
85350: IFFALSE 85362
// result := true else
85352: LD_ADDR_VAR 0 3
85356: PUSH
85357: LD_INT 1
85359: ST_TO_ADDR
85360: GO 85370
// result := false ;
85362: LD_ADDR_VAR 0 3
85366: PUSH
85367: LD_INT 0
85369: ST_TO_ADDR
// end else
85370: GO 85380
// result := false ;
85372: LD_ADDR_VAR 0 3
85376: PUSH
85377: LD_INT 0
85379: ST_TO_ADDR
// end ;
85380: LD_VAR 0 3
85384: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85385: LD_INT 0
85387: PPUSH
85388: PPUSH
85389: PPUSH
85390: PPUSH
// if not unit or not area then
85391: LD_VAR 0 1
85395: NOT
85396: PUSH
85397: LD_VAR 0 2
85401: NOT
85402: OR
85403: IFFALSE 85407
// exit ;
85405: GO 85571
// tmp := AreaToList ( area , i ) ;
85407: LD_ADDR_VAR 0 6
85411: PUSH
85412: LD_VAR 0 2
85416: PPUSH
85417: LD_VAR 0 5
85421: PPUSH
85422: CALL_OW 517
85426: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85427: LD_ADDR_VAR 0 5
85431: PUSH
85432: DOUBLE
85433: LD_INT 1
85435: DEC
85436: ST_TO_ADDR
85437: LD_VAR 0 6
85441: PUSH
85442: LD_INT 1
85444: ARRAY
85445: PUSH
85446: FOR_TO
85447: IFFALSE 85569
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85449: LD_ADDR_VAR 0 7
85453: PUSH
85454: LD_VAR 0 6
85458: PUSH
85459: LD_INT 1
85461: ARRAY
85462: PUSH
85463: LD_VAR 0 5
85467: ARRAY
85468: PUSH
85469: LD_VAR 0 6
85473: PUSH
85474: LD_INT 2
85476: ARRAY
85477: PUSH
85478: LD_VAR 0 5
85482: ARRAY
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85488: LD_VAR 0 7
85492: PUSH
85493: LD_INT 1
85495: ARRAY
85496: PPUSH
85497: LD_VAR 0 7
85501: PUSH
85502: LD_INT 2
85504: ARRAY
85505: PPUSH
85506: CALL_OW 428
85510: PUSH
85511: LD_INT 0
85513: EQUAL
85514: IFFALSE 85567
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85516: LD_VAR 0 1
85520: PPUSH
85521: LD_VAR 0 7
85525: PUSH
85526: LD_INT 1
85528: ARRAY
85529: PPUSH
85530: LD_VAR 0 7
85534: PUSH
85535: LD_INT 2
85537: ARRAY
85538: PPUSH
85539: LD_VAR 0 3
85543: PPUSH
85544: CALL_OW 48
// result := IsPlaced ( unit ) ;
85548: LD_ADDR_VAR 0 4
85552: PUSH
85553: LD_VAR 0 1
85557: PPUSH
85558: CALL_OW 305
85562: ST_TO_ADDR
// exit ;
85563: POP
85564: POP
85565: GO 85571
// end ; end ;
85567: GO 85446
85569: POP
85570: POP
// end ;
85571: LD_VAR 0 4
85575: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85576: LD_INT 0
85578: PPUSH
85579: PPUSH
85580: PPUSH
// if not side or side > 8 then
85581: LD_VAR 0 1
85585: NOT
85586: PUSH
85587: LD_VAR 0 1
85591: PUSH
85592: LD_INT 8
85594: GREATER
85595: OR
85596: IFFALSE 85600
// exit ;
85598: GO 85787
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85600: LD_ADDR_VAR 0 4
85604: PUSH
85605: LD_INT 22
85607: PUSH
85608: LD_VAR 0 1
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 21
85619: PUSH
85620: LD_INT 3
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PPUSH
85631: CALL_OW 69
85635: ST_TO_ADDR
// if not tmp then
85636: LD_VAR 0 4
85640: NOT
85641: IFFALSE 85645
// exit ;
85643: GO 85787
// enable_addtolog := true ;
85645: LD_ADDR_OWVAR 81
85649: PUSH
85650: LD_INT 1
85652: ST_TO_ADDR
// AddToLog ( [ ) ;
85653: LD_STRING [
85655: PPUSH
85656: CALL_OW 561
// for i in tmp do
85660: LD_ADDR_VAR 0 3
85664: PUSH
85665: LD_VAR 0 4
85669: PUSH
85670: FOR_IN
85671: IFFALSE 85778
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85673: LD_STRING [
85675: PUSH
85676: LD_VAR 0 3
85680: PPUSH
85681: CALL_OW 266
85685: STR
85686: PUSH
85687: LD_STRING , 
85689: STR
85690: PUSH
85691: LD_VAR 0 3
85695: PPUSH
85696: CALL_OW 250
85700: STR
85701: PUSH
85702: LD_STRING , 
85704: STR
85705: PUSH
85706: LD_VAR 0 3
85710: PPUSH
85711: CALL_OW 251
85715: STR
85716: PUSH
85717: LD_STRING , 
85719: STR
85720: PUSH
85721: LD_VAR 0 3
85725: PPUSH
85726: CALL_OW 254
85730: STR
85731: PUSH
85732: LD_STRING , 
85734: STR
85735: PUSH
85736: LD_VAR 0 3
85740: PPUSH
85741: LD_INT 1
85743: PPUSH
85744: CALL_OW 268
85748: STR
85749: PUSH
85750: LD_STRING , 
85752: STR
85753: PUSH
85754: LD_VAR 0 3
85758: PPUSH
85759: LD_INT 2
85761: PPUSH
85762: CALL_OW 268
85766: STR
85767: PUSH
85768: LD_STRING ],
85770: STR
85771: PPUSH
85772: CALL_OW 561
// end ;
85776: GO 85670
85778: POP
85779: POP
// AddToLog ( ]; ) ;
85780: LD_STRING ];
85782: PPUSH
85783: CALL_OW 561
// end ;
85787: LD_VAR 0 2
85791: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85792: LD_INT 0
85794: PPUSH
85795: PPUSH
85796: PPUSH
85797: PPUSH
85798: PPUSH
// if not area or not rate or not max then
85799: LD_VAR 0 1
85803: NOT
85804: PUSH
85805: LD_VAR 0 2
85809: NOT
85810: OR
85811: PUSH
85812: LD_VAR 0 4
85816: NOT
85817: OR
85818: IFFALSE 85822
// exit ;
85820: GO 86014
// while 1 do
85822: LD_INT 1
85824: IFFALSE 86014
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85826: LD_ADDR_VAR 0 9
85830: PUSH
85831: LD_VAR 0 1
85835: PPUSH
85836: LD_INT 1
85838: PPUSH
85839: CALL_OW 287
85843: PUSH
85844: LD_INT 10
85846: MUL
85847: ST_TO_ADDR
// r := rate / 10 ;
85848: LD_ADDR_VAR 0 7
85852: PUSH
85853: LD_VAR 0 2
85857: PUSH
85858: LD_INT 10
85860: DIVREAL
85861: ST_TO_ADDR
// time := 1 1$00 ;
85862: LD_ADDR_VAR 0 8
85866: PUSH
85867: LD_INT 2100
85869: ST_TO_ADDR
// if amount < min then
85870: LD_VAR 0 9
85874: PUSH
85875: LD_VAR 0 3
85879: LESS
85880: IFFALSE 85898
// r := r * 2 else
85882: LD_ADDR_VAR 0 7
85886: PUSH
85887: LD_VAR 0 7
85891: PUSH
85892: LD_INT 2
85894: MUL
85895: ST_TO_ADDR
85896: GO 85924
// if amount > max then
85898: LD_VAR 0 9
85902: PUSH
85903: LD_VAR 0 4
85907: GREATER
85908: IFFALSE 85924
// r := r / 2 ;
85910: LD_ADDR_VAR 0 7
85914: PUSH
85915: LD_VAR 0 7
85919: PUSH
85920: LD_INT 2
85922: DIVREAL
85923: ST_TO_ADDR
// time := time / r ;
85924: LD_ADDR_VAR 0 8
85928: PUSH
85929: LD_VAR 0 8
85933: PUSH
85934: LD_VAR 0 7
85938: DIVREAL
85939: ST_TO_ADDR
// if time < 0 then
85940: LD_VAR 0 8
85944: PUSH
85945: LD_INT 0
85947: LESS
85948: IFFALSE 85965
// time := time * - 1 ;
85950: LD_ADDR_VAR 0 8
85954: PUSH
85955: LD_VAR 0 8
85959: PUSH
85960: LD_INT 1
85962: NEG
85963: MUL
85964: ST_TO_ADDR
// wait ( time ) ;
85965: LD_VAR 0 8
85969: PPUSH
85970: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
85974: LD_INT 35
85976: PPUSH
85977: LD_INT 875
85979: PPUSH
85980: CALL_OW 12
85984: PPUSH
85985: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85989: LD_INT 1
85991: PPUSH
85992: LD_INT 5
85994: PPUSH
85995: CALL_OW 12
85999: PPUSH
86000: LD_VAR 0 1
86004: PPUSH
86005: LD_INT 1
86007: PPUSH
86008: CALL_OW 55
// end ;
86012: GO 85822
// end ;
86014: LD_VAR 0 5
86018: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86019: LD_INT 0
86021: PPUSH
86022: PPUSH
86023: PPUSH
86024: PPUSH
86025: PPUSH
86026: PPUSH
86027: PPUSH
86028: PPUSH
// if not turrets or not factories then
86029: LD_VAR 0 1
86033: NOT
86034: PUSH
86035: LD_VAR 0 2
86039: NOT
86040: OR
86041: IFFALSE 86045
// exit ;
86043: GO 86352
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86045: LD_ADDR_VAR 0 10
86049: PUSH
86050: LD_INT 5
86052: PUSH
86053: LD_INT 6
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 2
86062: PUSH
86063: LD_INT 4
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 3
86072: PUSH
86073: LD_INT 5
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 24
86087: PUSH
86088: LD_INT 25
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 23
86097: PUSH
86098: LD_INT 27
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: LD_INT 42
86111: PUSH
86112: LD_INT 43
86114: PUSH
86115: EMPTY
86116: LIST
86117: LIST
86118: PUSH
86119: LD_INT 44
86121: PUSH
86122: LD_INT 46
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PUSH
86129: LD_INT 45
86131: PUSH
86132: LD_INT 47
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: LIST
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: LIST
86148: ST_TO_ADDR
// result := [ ] ;
86149: LD_ADDR_VAR 0 3
86153: PUSH
86154: EMPTY
86155: ST_TO_ADDR
// for i in turrets do
86156: LD_ADDR_VAR 0 4
86160: PUSH
86161: LD_VAR 0 1
86165: PUSH
86166: FOR_IN
86167: IFFALSE 86350
// begin nat := GetNation ( i ) ;
86169: LD_ADDR_VAR 0 7
86173: PUSH
86174: LD_VAR 0 4
86178: PPUSH
86179: CALL_OW 248
86183: ST_TO_ADDR
// weapon := 0 ;
86184: LD_ADDR_VAR 0 8
86188: PUSH
86189: LD_INT 0
86191: ST_TO_ADDR
// if not nat then
86192: LD_VAR 0 7
86196: NOT
86197: IFFALSE 86201
// continue ;
86199: GO 86166
// for j in list [ nat ] do
86201: LD_ADDR_VAR 0 5
86205: PUSH
86206: LD_VAR 0 10
86210: PUSH
86211: LD_VAR 0 7
86215: ARRAY
86216: PUSH
86217: FOR_IN
86218: IFFALSE 86259
// if GetBWeapon ( i ) = j [ 1 ] then
86220: LD_VAR 0 4
86224: PPUSH
86225: CALL_OW 269
86229: PUSH
86230: LD_VAR 0 5
86234: PUSH
86235: LD_INT 1
86237: ARRAY
86238: EQUAL
86239: IFFALSE 86257
// begin weapon := j [ 2 ] ;
86241: LD_ADDR_VAR 0 8
86245: PUSH
86246: LD_VAR 0 5
86250: PUSH
86251: LD_INT 2
86253: ARRAY
86254: ST_TO_ADDR
// break ;
86255: GO 86259
// end ;
86257: GO 86217
86259: POP
86260: POP
// if not weapon then
86261: LD_VAR 0 8
86265: NOT
86266: IFFALSE 86270
// continue ;
86268: GO 86166
// for k in factories do
86270: LD_ADDR_VAR 0 6
86274: PUSH
86275: LD_VAR 0 2
86279: PUSH
86280: FOR_IN
86281: IFFALSE 86346
// begin weapons := AvailableWeaponList ( k ) ;
86283: LD_ADDR_VAR 0 9
86287: PUSH
86288: LD_VAR 0 6
86292: PPUSH
86293: CALL_OW 478
86297: ST_TO_ADDR
// if not weapons then
86298: LD_VAR 0 9
86302: NOT
86303: IFFALSE 86307
// continue ;
86305: GO 86280
// if weapon in weapons then
86307: LD_VAR 0 8
86311: PUSH
86312: LD_VAR 0 9
86316: IN
86317: IFFALSE 86344
// begin result := [ i , weapon ] ;
86319: LD_ADDR_VAR 0 3
86323: PUSH
86324: LD_VAR 0 4
86328: PUSH
86329: LD_VAR 0 8
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: ST_TO_ADDR
// exit ;
86338: POP
86339: POP
86340: POP
86341: POP
86342: GO 86352
// end ; end ;
86344: GO 86280
86346: POP
86347: POP
// end ;
86348: GO 86166
86350: POP
86351: POP
// end ;
86352: LD_VAR 0 3
86356: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86357: LD_INT 0
86359: PPUSH
// if not side or side > 8 then
86360: LD_VAR 0 3
86364: NOT
86365: PUSH
86366: LD_VAR 0 3
86370: PUSH
86371: LD_INT 8
86373: GREATER
86374: OR
86375: IFFALSE 86379
// exit ;
86377: GO 86438
// if not range then
86379: LD_VAR 0 4
86383: NOT
86384: IFFALSE 86395
// range := - 12 ;
86386: LD_ADDR_VAR 0 4
86390: PUSH
86391: LD_INT 12
86393: NEG
86394: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86395: LD_VAR 0 1
86399: PPUSH
86400: LD_VAR 0 2
86404: PPUSH
86405: LD_VAR 0 3
86409: PPUSH
86410: LD_VAR 0 4
86414: PPUSH
86415: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86419: LD_VAR 0 1
86423: PPUSH
86424: LD_VAR 0 2
86428: PPUSH
86429: LD_VAR 0 3
86433: PPUSH
86434: CALL_OW 331
// end ;
86438: LD_VAR 0 5
86442: RET
// export function Video ( mode ) ; begin
86443: LD_INT 0
86445: PPUSH
// ingame_video = mode ;
86446: LD_ADDR_OWVAR 52
86450: PUSH
86451: LD_VAR 0 1
86455: ST_TO_ADDR
// interface_hidden = mode ;
86456: LD_ADDR_OWVAR 54
86460: PUSH
86461: LD_VAR 0 1
86465: ST_TO_ADDR
// end ;
86466: LD_VAR 0 2
86470: RET
// export function Join ( array , element ) ; begin
86471: LD_INT 0
86473: PPUSH
// result := array ^ element ;
86474: LD_ADDR_VAR 0 3
86478: PUSH
86479: LD_VAR 0 1
86483: PUSH
86484: LD_VAR 0 2
86488: ADD
86489: ST_TO_ADDR
// end ;
86490: LD_VAR 0 3
86494: RET
// export function JoinUnion ( array , element ) ; begin
86495: LD_INT 0
86497: PPUSH
// result := array union element ;
86498: LD_ADDR_VAR 0 3
86502: PUSH
86503: LD_VAR 0 1
86507: PUSH
86508: LD_VAR 0 2
86512: UNION
86513: ST_TO_ADDR
// end ;
86514: LD_VAR 0 3
86518: RET
// export function GetBehemoths ( side ) ; begin
86519: LD_INT 0
86521: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
86522: LD_ADDR_VAR 0 2
86526: PUSH
86527: LD_INT 22
86529: PUSH
86530: LD_VAR 0 1
86534: PUSH
86535: EMPTY
86536: LIST
86537: LIST
86538: PUSH
86539: LD_INT 31
86541: PUSH
86542: LD_INT 25
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PPUSH
86553: CALL_OW 69
86557: ST_TO_ADDR
// end ;
86558: LD_VAR 0 2
86562: RET
// export function Shuffle ( array ) ; var i , index ; begin
86563: LD_INT 0
86565: PPUSH
86566: PPUSH
86567: PPUSH
// result := [ ] ;
86568: LD_ADDR_VAR 0 2
86572: PUSH
86573: EMPTY
86574: ST_TO_ADDR
// if not array then
86575: LD_VAR 0 1
86579: NOT
86580: IFFALSE 86584
// exit ;
86582: GO 86683
// Randomize ;
86584: CALL_OW 10
// for i = array downto 1 do
86588: LD_ADDR_VAR 0 3
86592: PUSH
86593: DOUBLE
86594: LD_VAR 0 1
86598: INC
86599: ST_TO_ADDR
86600: LD_INT 1
86602: PUSH
86603: FOR_DOWNTO
86604: IFFALSE 86681
// begin index := rand ( 1 , array ) ;
86606: LD_ADDR_VAR 0 4
86610: PUSH
86611: LD_INT 1
86613: PPUSH
86614: LD_VAR 0 1
86618: PPUSH
86619: CALL_OW 12
86623: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86624: LD_ADDR_VAR 0 2
86628: PUSH
86629: LD_VAR 0 2
86633: PPUSH
86634: LD_VAR 0 2
86638: PUSH
86639: LD_INT 1
86641: PLUS
86642: PPUSH
86643: LD_VAR 0 1
86647: PUSH
86648: LD_VAR 0 4
86652: ARRAY
86653: PPUSH
86654: CALL_OW 2
86658: ST_TO_ADDR
// array := Delete ( array , index ) ;
86659: LD_ADDR_VAR 0 1
86663: PUSH
86664: LD_VAR 0 1
86668: PPUSH
86669: LD_VAR 0 4
86673: PPUSH
86674: CALL_OW 3
86678: ST_TO_ADDR
// end ;
86679: GO 86603
86681: POP
86682: POP
// end ;
86683: LD_VAR 0 2
86687: RET
// export function GetBaseMaterials ( base ) ; begin
86688: LD_INT 0
86690: PPUSH
// result := [ 0 , 0 , 0 ] ;
86691: LD_ADDR_VAR 0 2
86695: PUSH
86696: LD_INT 0
86698: PUSH
86699: LD_INT 0
86701: PUSH
86702: LD_INT 0
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: LIST
86709: ST_TO_ADDR
// if not base then
86710: LD_VAR 0 1
86714: NOT
86715: IFFALSE 86719
// exit ;
86717: GO 86768
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86719: LD_ADDR_VAR 0 2
86723: PUSH
86724: LD_VAR 0 1
86728: PPUSH
86729: LD_INT 1
86731: PPUSH
86732: CALL_OW 275
86736: PUSH
86737: LD_VAR 0 1
86741: PPUSH
86742: LD_INT 2
86744: PPUSH
86745: CALL_OW 275
86749: PUSH
86750: LD_VAR 0 1
86754: PPUSH
86755: LD_INT 3
86757: PPUSH
86758: CALL_OW 275
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: LIST
86767: ST_TO_ADDR
// end ;
86768: LD_VAR 0 2
86772: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86773: LD_INT 0
86775: PPUSH
86776: PPUSH
// result := array ;
86777: LD_ADDR_VAR 0 3
86781: PUSH
86782: LD_VAR 0 1
86786: ST_TO_ADDR
// if size > 0 then
86787: LD_VAR 0 2
86791: PUSH
86792: LD_INT 0
86794: GREATER
86795: IFFALSE 86841
// for i := array downto size do
86797: LD_ADDR_VAR 0 4
86801: PUSH
86802: DOUBLE
86803: LD_VAR 0 1
86807: INC
86808: ST_TO_ADDR
86809: LD_VAR 0 2
86813: PUSH
86814: FOR_DOWNTO
86815: IFFALSE 86839
// result := Delete ( result , result ) ;
86817: LD_ADDR_VAR 0 3
86821: PUSH
86822: LD_VAR 0 3
86826: PPUSH
86827: LD_VAR 0 3
86831: PPUSH
86832: CALL_OW 3
86836: ST_TO_ADDR
86837: GO 86814
86839: POP
86840: POP
// end ; end_of_file end_of_file
86841: LD_VAR 0 3
86845: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
86846: GO 86848
86848: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86849: LD_STRING initStreamRollete();
86851: PPUSH
86852: CALL_OW 559
// InitStreamMode ;
86856: CALL 86865 0 0
// DefineStreamItems ( ) ;
86860: CALL 87305 0 0
// end ;
86864: END
// function InitStreamMode ; begin
86865: LD_INT 0
86867: PPUSH
// streamModeActive := false ;
86868: LD_ADDR_EXP 130
86872: PUSH
86873: LD_INT 0
86875: ST_TO_ADDR
// normalCounter := 36 ;
86876: LD_ADDR_EXP 131
86880: PUSH
86881: LD_INT 36
86883: ST_TO_ADDR
// hardcoreCounter := 16 ;
86884: LD_ADDR_EXP 132
86888: PUSH
86889: LD_INT 16
86891: ST_TO_ADDR
// sRocket := false ;
86892: LD_ADDR_EXP 135
86896: PUSH
86897: LD_INT 0
86899: ST_TO_ADDR
// sSpeed := false ;
86900: LD_ADDR_EXP 134
86904: PUSH
86905: LD_INT 0
86907: ST_TO_ADDR
// sEngine := false ;
86908: LD_ADDR_EXP 136
86912: PUSH
86913: LD_INT 0
86915: ST_TO_ADDR
// sSpec := false ;
86916: LD_ADDR_EXP 133
86920: PUSH
86921: LD_INT 0
86923: ST_TO_ADDR
// sLevel := false ;
86924: LD_ADDR_EXP 137
86928: PUSH
86929: LD_INT 0
86931: ST_TO_ADDR
// sArmoury := false ;
86932: LD_ADDR_EXP 138
86936: PUSH
86937: LD_INT 0
86939: ST_TO_ADDR
// sRadar := false ;
86940: LD_ADDR_EXP 139
86944: PUSH
86945: LD_INT 0
86947: ST_TO_ADDR
// sBunker := false ;
86948: LD_ADDR_EXP 140
86952: PUSH
86953: LD_INT 0
86955: ST_TO_ADDR
// sHack := false ;
86956: LD_ADDR_EXP 141
86960: PUSH
86961: LD_INT 0
86963: ST_TO_ADDR
// sFire := false ;
86964: LD_ADDR_EXP 142
86968: PUSH
86969: LD_INT 0
86971: ST_TO_ADDR
// sRefresh := false ;
86972: LD_ADDR_EXP 143
86976: PUSH
86977: LD_INT 0
86979: ST_TO_ADDR
// sExp := false ;
86980: LD_ADDR_EXP 144
86984: PUSH
86985: LD_INT 0
86987: ST_TO_ADDR
// sDepot := false ;
86988: LD_ADDR_EXP 145
86992: PUSH
86993: LD_INT 0
86995: ST_TO_ADDR
// sFlag := false ;
86996: LD_ADDR_EXP 146
87000: PUSH
87001: LD_INT 0
87003: ST_TO_ADDR
// sKamikadze := false ;
87004: LD_ADDR_EXP 154
87008: PUSH
87009: LD_INT 0
87011: ST_TO_ADDR
// sTroll := false ;
87012: LD_ADDR_EXP 155
87016: PUSH
87017: LD_INT 0
87019: ST_TO_ADDR
// sSlow := false ;
87020: LD_ADDR_EXP 156
87024: PUSH
87025: LD_INT 0
87027: ST_TO_ADDR
// sLack := false ;
87028: LD_ADDR_EXP 157
87032: PUSH
87033: LD_INT 0
87035: ST_TO_ADDR
// sTank := false ;
87036: LD_ADDR_EXP 159
87040: PUSH
87041: LD_INT 0
87043: ST_TO_ADDR
// sRemote := false ;
87044: LD_ADDR_EXP 160
87048: PUSH
87049: LD_INT 0
87051: ST_TO_ADDR
// sPowell := false ;
87052: LD_ADDR_EXP 161
87056: PUSH
87057: LD_INT 0
87059: ST_TO_ADDR
// sTeleport := false ;
87060: LD_ADDR_EXP 164
87064: PUSH
87065: LD_INT 0
87067: ST_TO_ADDR
// sOilTower := false ;
87068: LD_ADDR_EXP 166
87072: PUSH
87073: LD_INT 0
87075: ST_TO_ADDR
// sShovel := false ;
87076: LD_ADDR_EXP 167
87080: PUSH
87081: LD_INT 0
87083: ST_TO_ADDR
// sSheik := false ;
87084: LD_ADDR_EXP 168
87088: PUSH
87089: LD_INT 0
87091: ST_TO_ADDR
// sEarthquake := false ;
87092: LD_ADDR_EXP 170
87096: PUSH
87097: LD_INT 0
87099: ST_TO_ADDR
// sAI := false ;
87100: LD_ADDR_EXP 171
87104: PUSH
87105: LD_INT 0
87107: ST_TO_ADDR
// sCargo := false ;
87108: LD_ADDR_EXP 174
87112: PUSH
87113: LD_INT 0
87115: ST_TO_ADDR
// sDLaser := false ;
87116: LD_ADDR_EXP 175
87120: PUSH
87121: LD_INT 0
87123: ST_TO_ADDR
// sExchange := false ;
87124: LD_ADDR_EXP 176
87128: PUSH
87129: LD_INT 0
87131: ST_TO_ADDR
// sFac := false ;
87132: LD_ADDR_EXP 177
87136: PUSH
87137: LD_INT 0
87139: ST_TO_ADDR
// sPower := false ;
87140: LD_ADDR_EXP 178
87144: PUSH
87145: LD_INT 0
87147: ST_TO_ADDR
// sRandom := false ;
87148: LD_ADDR_EXP 179
87152: PUSH
87153: LD_INT 0
87155: ST_TO_ADDR
// sShield := false ;
87156: LD_ADDR_EXP 180
87160: PUSH
87161: LD_INT 0
87163: ST_TO_ADDR
// sTime := false ;
87164: LD_ADDR_EXP 181
87168: PUSH
87169: LD_INT 0
87171: ST_TO_ADDR
// sTools := false ;
87172: LD_ADDR_EXP 182
87176: PUSH
87177: LD_INT 0
87179: ST_TO_ADDR
// sSold := false ;
87180: LD_ADDR_EXP 147
87184: PUSH
87185: LD_INT 0
87187: ST_TO_ADDR
// sDiff := false ;
87188: LD_ADDR_EXP 148
87192: PUSH
87193: LD_INT 0
87195: ST_TO_ADDR
// sFog := false ;
87196: LD_ADDR_EXP 151
87200: PUSH
87201: LD_INT 0
87203: ST_TO_ADDR
// sReset := false ;
87204: LD_ADDR_EXP 152
87208: PUSH
87209: LD_INT 0
87211: ST_TO_ADDR
// sSun := false ;
87212: LD_ADDR_EXP 153
87216: PUSH
87217: LD_INT 0
87219: ST_TO_ADDR
// sTiger := false ;
87220: LD_ADDR_EXP 149
87224: PUSH
87225: LD_INT 0
87227: ST_TO_ADDR
// sBomb := false ;
87228: LD_ADDR_EXP 150
87232: PUSH
87233: LD_INT 0
87235: ST_TO_ADDR
// sWound := false ;
87236: LD_ADDR_EXP 158
87240: PUSH
87241: LD_INT 0
87243: ST_TO_ADDR
// sBetray := false ;
87244: LD_ADDR_EXP 162
87248: PUSH
87249: LD_INT 0
87251: ST_TO_ADDR
// sContamin := false ;
87252: LD_ADDR_EXP 163
87256: PUSH
87257: LD_INT 0
87259: ST_TO_ADDR
// sOil := false ;
87260: LD_ADDR_EXP 165
87264: PUSH
87265: LD_INT 0
87267: ST_TO_ADDR
// sStu := false ;
87268: LD_ADDR_EXP 169
87272: PUSH
87273: LD_INT 0
87275: ST_TO_ADDR
// sBazooka := false ;
87276: LD_ADDR_EXP 172
87280: PUSH
87281: LD_INT 0
87283: ST_TO_ADDR
// sMortar := false ;
87284: LD_ADDR_EXP 173
87288: PUSH
87289: LD_INT 0
87291: ST_TO_ADDR
// sRanger := false ;
87292: LD_ADDR_EXP 183
87296: PUSH
87297: LD_INT 0
87299: ST_TO_ADDR
// end ;
87300: LD_VAR 0 1
87304: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
87305: LD_INT 0
87307: PPUSH
87308: PPUSH
87309: PPUSH
87310: PPUSH
87311: PPUSH
// result := [ ] ;
87312: LD_ADDR_VAR 0 1
87316: PUSH
87317: EMPTY
87318: ST_TO_ADDR
// if campaign_id = 1 then
87319: LD_OWVAR 69
87323: PUSH
87324: LD_INT 1
87326: EQUAL
87327: IFFALSE 90265
// begin case mission_number of 1 :
87329: LD_OWVAR 70
87333: PUSH
87334: LD_INT 1
87336: DOUBLE
87337: EQUAL
87338: IFTRUE 87342
87340: GO 87406
87342: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
87343: LD_ADDR_VAR 0 1
87347: PUSH
87348: LD_INT 2
87350: PUSH
87351: LD_INT 4
87353: PUSH
87354: LD_INT 11
87356: PUSH
87357: LD_INT 12
87359: PUSH
87360: LD_INT 15
87362: PUSH
87363: LD_INT 16
87365: PUSH
87366: LD_INT 22
87368: PUSH
87369: LD_INT 23
87371: PUSH
87372: LD_INT 26
87374: PUSH
87375: EMPTY
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 101
87388: PUSH
87389: LD_INT 102
87391: PUSH
87392: LD_INT 106
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: LIST
87399: PUSH
87400: EMPTY
87401: LIST
87402: LIST
87403: ST_TO_ADDR
87404: GO 90263
87406: LD_INT 2
87408: DOUBLE
87409: EQUAL
87410: IFTRUE 87414
87412: GO 87486
87414: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
87415: LD_ADDR_VAR 0 1
87419: PUSH
87420: LD_INT 2
87422: PUSH
87423: LD_INT 4
87425: PUSH
87426: LD_INT 11
87428: PUSH
87429: LD_INT 12
87431: PUSH
87432: LD_INT 15
87434: PUSH
87435: LD_INT 16
87437: PUSH
87438: LD_INT 22
87440: PUSH
87441: LD_INT 23
87443: PUSH
87444: LD_INT 26
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: PUSH
87458: LD_INT 101
87460: PUSH
87461: LD_INT 102
87463: PUSH
87464: LD_INT 105
87466: PUSH
87467: LD_INT 106
87469: PUSH
87470: LD_INT 108
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: ST_TO_ADDR
87484: GO 90263
87486: LD_INT 3
87488: DOUBLE
87489: EQUAL
87490: IFTRUE 87494
87492: GO 87570
87494: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
87495: LD_ADDR_VAR 0 1
87499: PUSH
87500: LD_INT 2
87502: PUSH
87503: LD_INT 4
87505: PUSH
87506: LD_INT 5
87508: PUSH
87509: LD_INT 11
87511: PUSH
87512: LD_INT 12
87514: PUSH
87515: LD_INT 15
87517: PUSH
87518: LD_INT 16
87520: PUSH
87521: LD_INT 22
87523: PUSH
87524: LD_INT 26
87526: PUSH
87527: LD_INT 36
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: PUSH
87542: LD_INT 101
87544: PUSH
87545: LD_INT 102
87547: PUSH
87548: LD_INT 105
87550: PUSH
87551: LD_INT 106
87553: PUSH
87554: LD_INT 108
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: ST_TO_ADDR
87568: GO 90263
87570: LD_INT 4
87572: DOUBLE
87573: EQUAL
87574: IFTRUE 87578
87576: GO 87662
87578: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
87579: LD_ADDR_VAR 0 1
87583: PUSH
87584: LD_INT 2
87586: PUSH
87587: LD_INT 4
87589: PUSH
87590: LD_INT 5
87592: PUSH
87593: LD_INT 8
87595: PUSH
87596: LD_INT 11
87598: PUSH
87599: LD_INT 12
87601: PUSH
87602: LD_INT 15
87604: PUSH
87605: LD_INT 16
87607: PUSH
87608: LD_INT 22
87610: PUSH
87611: LD_INT 23
87613: PUSH
87614: LD_INT 26
87616: PUSH
87617: LD_INT 36
87619: PUSH
87620: EMPTY
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 101
87636: PUSH
87637: LD_INT 102
87639: PUSH
87640: LD_INT 105
87642: PUSH
87643: LD_INT 106
87645: PUSH
87646: LD_INT 108
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: LIST
87653: LIST
87654: LIST
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: ST_TO_ADDR
87660: GO 90263
87662: LD_INT 5
87664: DOUBLE
87665: EQUAL
87666: IFTRUE 87670
87668: GO 87770
87670: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
87671: LD_ADDR_VAR 0 1
87675: PUSH
87676: LD_INT 2
87678: PUSH
87679: LD_INT 4
87681: PUSH
87682: LD_INT 5
87684: PUSH
87685: LD_INT 6
87687: PUSH
87688: LD_INT 8
87690: PUSH
87691: LD_INT 11
87693: PUSH
87694: LD_INT 12
87696: PUSH
87697: LD_INT 15
87699: PUSH
87700: LD_INT 16
87702: PUSH
87703: LD_INT 22
87705: PUSH
87706: LD_INT 23
87708: PUSH
87709: LD_INT 25
87711: PUSH
87712: LD_INT 26
87714: PUSH
87715: LD_INT 36
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: PUSH
87734: LD_INT 101
87736: PUSH
87737: LD_INT 102
87739: PUSH
87740: LD_INT 105
87742: PUSH
87743: LD_INT 106
87745: PUSH
87746: LD_INT 108
87748: PUSH
87749: LD_INT 109
87751: PUSH
87752: LD_INT 112
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: ST_TO_ADDR
87768: GO 90263
87770: LD_INT 6
87772: DOUBLE
87773: EQUAL
87774: IFTRUE 87778
87776: GO 87898
87778: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
87779: LD_ADDR_VAR 0 1
87783: PUSH
87784: LD_INT 2
87786: PUSH
87787: LD_INT 4
87789: PUSH
87790: LD_INT 5
87792: PUSH
87793: LD_INT 6
87795: PUSH
87796: LD_INT 8
87798: PUSH
87799: LD_INT 11
87801: PUSH
87802: LD_INT 12
87804: PUSH
87805: LD_INT 15
87807: PUSH
87808: LD_INT 16
87810: PUSH
87811: LD_INT 20
87813: PUSH
87814: LD_INT 21
87816: PUSH
87817: LD_INT 22
87819: PUSH
87820: LD_INT 23
87822: PUSH
87823: LD_INT 25
87825: PUSH
87826: LD_INT 26
87828: PUSH
87829: LD_INT 30
87831: PUSH
87832: LD_INT 31
87834: PUSH
87835: LD_INT 32
87837: PUSH
87838: LD_INT 36
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 101
87864: PUSH
87865: LD_INT 102
87867: PUSH
87868: LD_INT 105
87870: PUSH
87871: LD_INT 106
87873: PUSH
87874: LD_INT 108
87876: PUSH
87877: LD_INT 109
87879: PUSH
87880: LD_INT 112
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: LIST
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: ST_TO_ADDR
87896: GO 90263
87898: LD_INT 7
87900: DOUBLE
87901: EQUAL
87902: IFTRUE 87906
87904: GO 88006
87906: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
87907: LD_ADDR_VAR 0 1
87911: PUSH
87912: LD_INT 2
87914: PUSH
87915: LD_INT 4
87917: PUSH
87918: LD_INT 5
87920: PUSH
87921: LD_INT 7
87923: PUSH
87924: LD_INT 11
87926: PUSH
87927: LD_INT 12
87929: PUSH
87930: LD_INT 15
87932: PUSH
87933: LD_INT 16
87935: PUSH
87936: LD_INT 20
87938: PUSH
87939: LD_INT 21
87941: PUSH
87942: LD_INT 22
87944: PUSH
87945: LD_INT 23
87947: PUSH
87948: LD_INT 25
87950: PUSH
87951: LD_INT 26
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: PUSH
87970: LD_INT 101
87972: PUSH
87973: LD_INT 102
87975: PUSH
87976: LD_INT 103
87978: PUSH
87979: LD_INT 105
87981: PUSH
87982: LD_INT 106
87984: PUSH
87985: LD_INT 108
87987: PUSH
87988: LD_INT 112
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: PUSH
88000: EMPTY
88001: LIST
88002: LIST
88003: ST_TO_ADDR
88004: GO 90263
88006: LD_INT 8
88008: DOUBLE
88009: EQUAL
88010: IFTRUE 88014
88012: GO 88142
88014: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
88015: LD_ADDR_VAR 0 1
88019: PUSH
88020: LD_INT 2
88022: PUSH
88023: LD_INT 4
88025: PUSH
88026: LD_INT 5
88028: PUSH
88029: LD_INT 6
88031: PUSH
88032: LD_INT 7
88034: PUSH
88035: LD_INT 8
88037: PUSH
88038: LD_INT 11
88040: PUSH
88041: LD_INT 12
88043: PUSH
88044: LD_INT 15
88046: PUSH
88047: LD_INT 16
88049: PUSH
88050: LD_INT 20
88052: PUSH
88053: LD_INT 21
88055: PUSH
88056: LD_INT 22
88058: PUSH
88059: LD_INT 23
88061: PUSH
88062: LD_INT 25
88064: PUSH
88065: LD_INT 26
88067: PUSH
88068: LD_INT 30
88070: PUSH
88071: LD_INT 31
88073: PUSH
88074: LD_INT 32
88076: PUSH
88077: LD_INT 36
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: PUSH
88102: LD_INT 101
88104: PUSH
88105: LD_INT 102
88107: PUSH
88108: LD_INT 103
88110: PUSH
88111: LD_INT 105
88113: PUSH
88114: LD_INT 106
88116: PUSH
88117: LD_INT 108
88119: PUSH
88120: LD_INT 109
88122: PUSH
88123: LD_INT 112
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: ST_TO_ADDR
88140: GO 90263
88142: LD_INT 9
88144: DOUBLE
88145: EQUAL
88146: IFTRUE 88150
88148: GO 88286
88150: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
88151: LD_ADDR_VAR 0 1
88155: PUSH
88156: LD_INT 2
88158: PUSH
88159: LD_INT 4
88161: PUSH
88162: LD_INT 5
88164: PUSH
88165: LD_INT 6
88167: PUSH
88168: LD_INT 7
88170: PUSH
88171: LD_INT 8
88173: PUSH
88174: LD_INT 11
88176: PUSH
88177: LD_INT 12
88179: PUSH
88180: LD_INT 15
88182: PUSH
88183: LD_INT 16
88185: PUSH
88186: LD_INT 20
88188: PUSH
88189: LD_INT 21
88191: PUSH
88192: LD_INT 22
88194: PUSH
88195: LD_INT 23
88197: PUSH
88198: LD_INT 25
88200: PUSH
88201: LD_INT 26
88203: PUSH
88204: LD_INT 28
88206: PUSH
88207: LD_INT 30
88209: PUSH
88210: LD_INT 31
88212: PUSH
88213: LD_INT 32
88215: PUSH
88216: LD_INT 36
88218: PUSH
88219: EMPTY
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: LIST
88238: LIST
88239: LIST
88240: LIST
88241: PUSH
88242: LD_INT 101
88244: PUSH
88245: LD_INT 102
88247: PUSH
88248: LD_INT 103
88250: PUSH
88251: LD_INT 105
88253: PUSH
88254: LD_INT 106
88256: PUSH
88257: LD_INT 108
88259: PUSH
88260: LD_INT 109
88262: PUSH
88263: LD_INT 112
88265: PUSH
88266: LD_INT 114
88268: PUSH
88269: EMPTY
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: PUSH
88280: EMPTY
88281: LIST
88282: LIST
88283: ST_TO_ADDR
88284: GO 90263
88286: LD_INT 10
88288: DOUBLE
88289: EQUAL
88290: IFTRUE 88294
88292: GO 88478
88294: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
88295: LD_ADDR_VAR 0 1
88299: PUSH
88300: LD_INT 2
88302: PUSH
88303: LD_INT 4
88305: PUSH
88306: LD_INT 5
88308: PUSH
88309: LD_INT 6
88311: PUSH
88312: LD_INT 7
88314: PUSH
88315: LD_INT 8
88317: PUSH
88318: LD_INT 9
88320: PUSH
88321: LD_INT 10
88323: PUSH
88324: LD_INT 11
88326: PUSH
88327: LD_INT 12
88329: PUSH
88330: LD_INT 13
88332: PUSH
88333: LD_INT 14
88335: PUSH
88336: LD_INT 15
88338: PUSH
88339: LD_INT 16
88341: PUSH
88342: LD_INT 17
88344: PUSH
88345: LD_INT 18
88347: PUSH
88348: LD_INT 19
88350: PUSH
88351: LD_INT 20
88353: PUSH
88354: LD_INT 21
88356: PUSH
88357: LD_INT 22
88359: PUSH
88360: LD_INT 23
88362: PUSH
88363: LD_INT 24
88365: PUSH
88366: LD_INT 25
88368: PUSH
88369: LD_INT 26
88371: PUSH
88372: LD_INT 28
88374: PUSH
88375: LD_INT 30
88377: PUSH
88378: LD_INT 31
88380: PUSH
88381: LD_INT 32
88383: PUSH
88384: LD_INT 36
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 101
88420: PUSH
88421: LD_INT 102
88423: PUSH
88424: LD_INT 103
88426: PUSH
88427: LD_INT 104
88429: PUSH
88430: LD_INT 105
88432: PUSH
88433: LD_INT 106
88435: PUSH
88436: LD_INT 107
88438: PUSH
88439: LD_INT 108
88441: PUSH
88442: LD_INT 109
88444: PUSH
88445: LD_INT 110
88447: PUSH
88448: LD_INT 111
88450: PUSH
88451: LD_INT 112
88453: PUSH
88454: LD_INT 114
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: ST_TO_ADDR
88476: GO 90263
88478: LD_INT 11
88480: DOUBLE
88481: EQUAL
88482: IFTRUE 88486
88484: GO 88678
88486: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
88487: LD_ADDR_VAR 0 1
88491: PUSH
88492: LD_INT 2
88494: PUSH
88495: LD_INT 3
88497: PUSH
88498: LD_INT 4
88500: PUSH
88501: LD_INT 5
88503: PUSH
88504: LD_INT 6
88506: PUSH
88507: LD_INT 7
88509: PUSH
88510: LD_INT 8
88512: PUSH
88513: LD_INT 9
88515: PUSH
88516: LD_INT 10
88518: PUSH
88519: LD_INT 11
88521: PUSH
88522: LD_INT 12
88524: PUSH
88525: LD_INT 13
88527: PUSH
88528: LD_INT 14
88530: PUSH
88531: LD_INT 15
88533: PUSH
88534: LD_INT 16
88536: PUSH
88537: LD_INT 17
88539: PUSH
88540: LD_INT 18
88542: PUSH
88543: LD_INT 19
88545: PUSH
88546: LD_INT 20
88548: PUSH
88549: LD_INT 21
88551: PUSH
88552: LD_INT 22
88554: PUSH
88555: LD_INT 23
88557: PUSH
88558: LD_INT 24
88560: PUSH
88561: LD_INT 25
88563: PUSH
88564: LD_INT 26
88566: PUSH
88567: LD_INT 28
88569: PUSH
88570: LD_INT 30
88572: PUSH
88573: LD_INT 31
88575: PUSH
88576: LD_INT 32
88578: PUSH
88579: LD_INT 34
88581: PUSH
88582: LD_INT 36
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: PUSH
88618: LD_INT 101
88620: PUSH
88621: LD_INT 102
88623: PUSH
88624: LD_INT 103
88626: PUSH
88627: LD_INT 104
88629: PUSH
88630: LD_INT 105
88632: PUSH
88633: LD_INT 106
88635: PUSH
88636: LD_INT 107
88638: PUSH
88639: LD_INT 108
88641: PUSH
88642: LD_INT 109
88644: PUSH
88645: LD_INT 110
88647: PUSH
88648: LD_INT 111
88650: PUSH
88651: LD_INT 112
88653: PUSH
88654: LD_INT 114
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: ST_TO_ADDR
88676: GO 90263
88678: LD_INT 12
88680: DOUBLE
88681: EQUAL
88682: IFTRUE 88686
88684: GO 88894
88686: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
88687: LD_ADDR_VAR 0 1
88691: PUSH
88692: LD_INT 1
88694: PUSH
88695: LD_INT 2
88697: PUSH
88698: LD_INT 3
88700: PUSH
88701: LD_INT 4
88703: PUSH
88704: LD_INT 5
88706: PUSH
88707: LD_INT 6
88709: PUSH
88710: LD_INT 7
88712: PUSH
88713: LD_INT 8
88715: PUSH
88716: LD_INT 9
88718: PUSH
88719: LD_INT 10
88721: PUSH
88722: LD_INT 11
88724: PUSH
88725: LD_INT 12
88727: PUSH
88728: LD_INT 13
88730: PUSH
88731: LD_INT 14
88733: PUSH
88734: LD_INT 15
88736: PUSH
88737: LD_INT 16
88739: PUSH
88740: LD_INT 17
88742: PUSH
88743: LD_INT 18
88745: PUSH
88746: LD_INT 19
88748: PUSH
88749: LD_INT 20
88751: PUSH
88752: LD_INT 21
88754: PUSH
88755: LD_INT 22
88757: PUSH
88758: LD_INT 23
88760: PUSH
88761: LD_INT 24
88763: PUSH
88764: LD_INT 25
88766: PUSH
88767: LD_INT 26
88769: PUSH
88770: LD_INT 27
88772: PUSH
88773: LD_INT 28
88775: PUSH
88776: LD_INT 30
88778: PUSH
88779: LD_INT 31
88781: PUSH
88782: LD_INT 32
88784: PUSH
88785: LD_INT 33
88787: PUSH
88788: LD_INT 34
88790: PUSH
88791: LD_INT 36
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: PUSH
88830: LD_INT 101
88832: PUSH
88833: LD_INT 102
88835: PUSH
88836: LD_INT 103
88838: PUSH
88839: LD_INT 104
88841: PUSH
88842: LD_INT 105
88844: PUSH
88845: LD_INT 106
88847: PUSH
88848: LD_INT 107
88850: PUSH
88851: LD_INT 108
88853: PUSH
88854: LD_INT 109
88856: PUSH
88857: LD_INT 110
88859: PUSH
88860: LD_INT 111
88862: PUSH
88863: LD_INT 112
88865: PUSH
88866: LD_INT 113
88868: PUSH
88869: LD_INT 114
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: LIST
88878: LIST
88879: LIST
88880: LIST
88881: LIST
88882: LIST
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: ST_TO_ADDR
88892: GO 90263
88894: LD_INT 13
88896: DOUBLE
88897: EQUAL
88898: IFTRUE 88902
88900: GO 89098
88902: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
88903: LD_ADDR_VAR 0 1
88907: PUSH
88908: LD_INT 1
88910: PUSH
88911: LD_INT 2
88913: PUSH
88914: LD_INT 3
88916: PUSH
88917: LD_INT 4
88919: PUSH
88920: LD_INT 5
88922: PUSH
88923: LD_INT 8
88925: PUSH
88926: LD_INT 9
88928: PUSH
88929: LD_INT 10
88931: PUSH
88932: LD_INT 11
88934: PUSH
88935: LD_INT 12
88937: PUSH
88938: LD_INT 14
88940: PUSH
88941: LD_INT 15
88943: PUSH
88944: LD_INT 16
88946: PUSH
88947: LD_INT 17
88949: PUSH
88950: LD_INT 18
88952: PUSH
88953: LD_INT 19
88955: PUSH
88956: LD_INT 20
88958: PUSH
88959: LD_INT 21
88961: PUSH
88962: LD_INT 22
88964: PUSH
88965: LD_INT 23
88967: PUSH
88968: LD_INT 24
88970: PUSH
88971: LD_INT 25
88973: PUSH
88974: LD_INT 26
88976: PUSH
88977: LD_INT 27
88979: PUSH
88980: LD_INT 28
88982: PUSH
88983: LD_INT 30
88985: PUSH
88986: LD_INT 31
88988: PUSH
88989: LD_INT 32
88991: PUSH
88992: LD_INT 33
88994: PUSH
88995: LD_INT 34
88997: PUSH
88998: LD_INT 36
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 101
89036: PUSH
89037: LD_INT 102
89039: PUSH
89040: LD_INT 103
89042: PUSH
89043: LD_INT 104
89045: PUSH
89046: LD_INT 105
89048: PUSH
89049: LD_INT 106
89051: PUSH
89052: LD_INT 107
89054: PUSH
89055: LD_INT 108
89057: PUSH
89058: LD_INT 109
89060: PUSH
89061: LD_INT 110
89063: PUSH
89064: LD_INT 111
89066: PUSH
89067: LD_INT 112
89069: PUSH
89070: LD_INT 113
89072: PUSH
89073: LD_INT 114
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: ST_TO_ADDR
89096: GO 90263
89098: LD_INT 14
89100: DOUBLE
89101: EQUAL
89102: IFTRUE 89106
89104: GO 89318
89106: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
89107: LD_ADDR_VAR 0 1
89111: PUSH
89112: LD_INT 1
89114: PUSH
89115: LD_INT 2
89117: PUSH
89118: LD_INT 3
89120: PUSH
89121: LD_INT 4
89123: PUSH
89124: LD_INT 5
89126: PUSH
89127: LD_INT 6
89129: PUSH
89130: LD_INT 7
89132: PUSH
89133: LD_INT 8
89135: PUSH
89136: LD_INT 9
89138: PUSH
89139: LD_INT 10
89141: PUSH
89142: LD_INT 11
89144: PUSH
89145: LD_INT 12
89147: PUSH
89148: LD_INT 13
89150: PUSH
89151: LD_INT 14
89153: PUSH
89154: LD_INT 15
89156: PUSH
89157: LD_INT 16
89159: PUSH
89160: LD_INT 17
89162: PUSH
89163: LD_INT 18
89165: PUSH
89166: LD_INT 19
89168: PUSH
89169: LD_INT 20
89171: PUSH
89172: LD_INT 21
89174: PUSH
89175: LD_INT 22
89177: PUSH
89178: LD_INT 23
89180: PUSH
89181: LD_INT 24
89183: PUSH
89184: LD_INT 25
89186: PUSH
89187: LD_INT 26
89189: PUSH
89190: LD_INT 27
89192: PUSH
89193: LD_INT 28
89195: PUSH
89196: LD_INT 29
89198: PUSH
89199: LD_INT 30
89201: PUSH
89202: LD_INT 31
89204: PUSH
89205: LD_INT 32
89207: PUSH
89208: LD_INT 33
89210: PUSH
89211: LD_INT 34
89213: PUSH
89214: LD_INT 36
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 101
89256: PUSH
89257: LD_INT 102
89259: PUSH
89260: LD_INT 103
89262: PUSH
89263: LD_INT 104
89265: PUSH
89266: LD_INT 105
89268: PUSH
89269: LD_INT 106
89271: PUSH
89272: LD_INT 107
89274: PUSH
89275: LD_INT 108
89277: PUSH
89278: LD_INT 109
89280: PUSH
89281: LD_INT 110
89283: PUSH
89284: LD_INT 111
89286: PUSH
89287: LD_INT 112
89289: PUSH
89290: LD_INT 113
89292: PUSH
89293: LD_INT 114
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: LIST
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: ST_TO_ADDR
89316: GO 90263
89318: LD_INT 15
89320: DOUBLE
89321: EQUAL
89322: IFTRUE 89326
89324: GO 89538
89326: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
89327: LD_ADDR_VAR 0 1
89331: PUSH
89332: LD_INT 1
89334: PUSH
89335: LD_INT 2
89337: PUSH
89338: LD_INT 3
89340: PUSH
89341: LD_INT 4
89343: PUSH
89344: LD_INT 5
89346: PUSH
89347: LD_INT 6
89349: PUSH
89350: LD_INT 7
89352: PUSH
89353: LD_INT 8
89355: PUSH
89356: LD_INT 9
89358: PUSH
89359: LD_INT 10
89361: PUSH
89362: LD_INT 11
89364: PUSH
89365: LD_INT 12
89367: PUSH
89368: LD_INT 13
89370: PUSH
89371: LD_INT 14
89373: PUSH
89374: LD_INT 15
89376: PUSH
89377: LD_INT 16
89379: PUSH
89380: LD_INT 17
89382: PUSH
89383: LD_INT 18
89385: PUSH
89386: LD_INT 19
89388: PUSH
89389: LD_INT 20
89391: PUSH
89392: LD_INT 21
89394: PUSH
89395: LD_INT 22
89397: PUSH
89398: LD_INT 23
89400: PUSH
89401: LD_INT 24
89403: PUSH
89404: LD_INT 25
89406: PUSH
89407: LD_INT 26
89409: PUSH
89410: LD_INT 27
89412: PUSH
89413: LD_INT 28
89415: PUSH
89416: LD_INT 29
89418: PUSH
89419: LD_INT 30
89421: PUSH
89422: LD_INT 31
89424: PUSH
89425: LD_INT 32
89427: PUSH
89428: LD_INT 33
89430: PUSH
89431: LD_INT 34
89433: PUSH
89434: LD_INT 36
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: PUSH
89474: LD_INT 101
89476: PUSH
89477: LD_INT 102
89479: PUSH
89480: LD_INT 103
89482: PUSH
89483: LD_INT 104
89485: PUSH
89486: LD_INT 105
89488: PUSH
89489: LD_INT 106
89491: PUSH
89492: LD_INT 107
89494: PUSH
89495: LD_INT 108
89497: PUSH
89498: LD_INT 109
89500: PUSH
89501: LD_INT 110
89503: PUSH
89504: LD_INT 111
89506: PUSH
89507: LD_INT 112
89509: PUSH
89510: LD_INT 113
89512: PUSH
89513: LD_INT 114
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: ST_TO_ADDR
89536: GO 90263
89538: LD_INT 16
89540: DOUBLE
89541: EQUAL
89542: IFTRUE 89546
89544: GO 89670
89546: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
89547: LD_ADDR_VAR 0 1
89551: PUSH
89552: LD_INT 2
89554: PUSH
89555: LD_INT 4
89557: PUSH
89558: LD_INT 5
89560: PUSH
89561: LD_INT 7
89563: PUSH
89564: LD_INT 11
89566: PUSH
89567: LD_INT 12
89569: PUSH
89570: LD_INT 15
89572: PUSH
89573: LD_INT 16
89575: PUSH
89576: LD_INT 20
89578: PUSH
89579: LD_INT 21
89581: PUSH
89582: LD_INT 22
89584: PUSH
89585: LD_INT 23
89587: PUSH
89588: LD_INT 25
89590: PUSH
89591: LD_INT 26
89593: PUSH
89594: LD_INT 30
89596: PUSH
89597: LD_INT 31
89599: PUSH
89600: LD_INT 32
89602: PUSH
89603: LD_INT 33
89605: PUSH
89606: LD_INT 34
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: PUSH
89630: LD_INT 101
89632: PUSH
89633: LD_INT 102
89635: PUSH
89636: LD_INT 103
89638: PUSH
89639: LD_INT 106
89641: PUSH
89642: LD_INT 108
89644: PUSH
89645: LD_INT 112
89647: PUSH
89648: LD_INT 113
89650: PUSH
89651: LD_INT 114
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: ST_TO_ADDR
89668: GO 90263
89670: LD_INT 17
89672: DOUBLE
89673: EQUAL
89674: IFTRUE 89678
89676: GO 89890
89678: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
89679: LD_ADDR_VAR 0 1
89683: PUSH
89684: LD_INT 1
89686: PUSH
89687: LD_INT 2
89689: PUSH
89690: LD_INT 3
89692: PUSH
89693: LD_INT 4
89695: PUSH
89696: LD_INT 5
89698: PUSH
89699: LD_INT 6
89701: PUSH
89702: LD_INT 7
89704: PUSH
89705: LD_INT 8
89707: PUSH
89708: LD_INT 9
89710: PUSH
89711: LD_INT 10
89713: PUSH
89714: LD_INT 11
89716: PUSH
89717: LD_INT 12
89719: PUSH
89720: LD_INT 13
89722: PUSH
89723: LD_INT 14
89725: PUSH
89726: LD_INT 15
89728: PUSH
89729: LD_INT 16
89731: PUSH
89732: LD_INT 17
89734: PUSH
89735: LD_INT 18
89737: PUSH
89738: LD_INT 19
89740: PUSH
89741: LD_INT 20
89743: PUSH
89744: LD_INT 21
89746: PUSH
89747: LD_INT 22
89749: PUSH
89750: LD_INT 23
89752: PUSH
89753: LD_INT 24
89755: PUSH
89756: LD_INT 25
89758: PUSH
89759: LD_INT 26
89761: PUSH
89762: LD_INT 27
89764: PUSH
89765: LD_INT 28
89767: PUSH
89768: LD_INT 29
89770: PUSH
89771: LD_INT 30
89773: PUSH
89774: LD_INT 31
89776: PUSH
89777: LD_INT 32
89779: PUSH
89780: LD_INT 33
89782: PUSH
89783: LD_INT 34
89785: PUSH
89786: LD_INT 36
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 101
89828: PUSH
89829: LD_INT 102
89831: PUSH
89832: LD_INT 103
89834: PUSH
89835: LD_INT 104
89837: PUSH
89838: LD_INT 105
89840: PUSH
89841: LD_INT 106
89843: PUSH
89844: LD_INT 107
89846: PUSH
89847: LD_INT 108
89849: PUSH
89850: LD_INT 109
89852: PUSH
89853: LD_INT 110
89855: PUSH
89856: LD_INT 111
89858: PUSH
89859: LD_INT 112
89861: PUSH
89862: LD_INT 113
89864: PUSH
89865: LD_INT 114
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: ST_TO_ADDR
89888: GO 90263
89890: LD_INT 18
89892: DOUBLE
89893: EQUAL
89894: IFTRUE 89898
89896: GO 90034
89898: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
89899: LD_ADDR_VAR 0 1
89903: PUSH
89904: LD_INT 2
89906: PUSH
89907: LD_INT 4
89909: PUSH
89910: LD_INT 5
89912: PUSH
89913: LD_INT 7
89915: PUSH
89916: LD_INT 11
89918: PUSH
89919: LD_INT 12
89921: PUSH
89922: LD_INT 15
89924: PUSH
89925: LD_INT 16
89927: PUSH
89928: LD_INT 20
89930: PUSH
89931: LD_INT 21
89933: PUSH
89934: LD_INT 22
89936: PUSH
89937: LD_INT 23
89939: PUSH
89940: LD_INT 25
89942: PUSH
89943: LD_INT 26
89945: PUSH
89946: LD_INT 30
89948: PUSH
89949: LD_INT 31
89951: PUSH
89952: LD_INT 32
89954: PUSH
89955: LD_INT 33
89957: PUSH
89958: LD_INT 34
89960: PUSH
89961: LD_INT 35
89963: PUSH
89964: LD_INT 36
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: PUSH
89990: LD_INT 101
89992: PUSH
89993: LD_INT 102
89995: PUSH
89996: LD_INT 103
89998: PUSH
89999: LD_INT 106
90001: PUSH
90002: LD_INT 108
90004: PUSH
90005: LD_INT 112
90007: PUSH
90008: LD_INT 113
90010: PUSH
90011: LD_INT 114
90013: PUSH
90014: LD_INT 115
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: LIST
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: ST_TO_ADDR
90032: GO 90263
90034: LD_INT 19
90036: DOUBLE
90037: EQUAL
90038: IFTRUE 90042
90040: GO 90262
90042: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
90043: LD_ADDR_VAR 0 1
90047: PUSH
90048: LD_INT 1
90050: PUSH
90051: LD_INT 2
90053: PUSH
90054: LD_INT 3
90056: PUSH
90057: LD_INT 4
90059: PUSH
90060: LD_INT 5
90062: PUSH
90063: LD_INT 6
90065: PUSH
90066: LD_INT 7
90068: PUSH
90069: LD_INT 8
90071: PUSH
90072: LD_INT 9
90074: PUSH
90075: LD_INT 10
90077: PUSH
90078: LD_INT 11
90080: PUSH
90081: LD_INT 12
90083: PUSH
90084: LD_INT 13
90086: PUSH
90087: LD_INT 14
90089: PUSH
90090: LD_INT 15
90092: PUSH
90093: LD_INT 16
90095: PUSH
90096: LD_INT 17
90098: PUSH
90099: LD_INT 18
90101: PUSH
90102: LD_INT 19
90104: PUSH
90105: LD_INT 20
90107: PUSH
90108: LD_INT 21
90110: PUSH
90111: LD_INT 22
90113: PUSH
90114: LD_INT 23
90116: PUSH
90117: LD_INT 24
90119: PUSH
90120: LD_INT 25
90122: PUSH
90123: LD_INT 26
90125: PUSH
90126: LD_INT 27
90128: PUSH
90129: LD_INT 28
90131: PUSH
90132: LD_INT 29
90134: PUSH
90135: LD_INT 30
90137: PUSH
90138: LD_INT 31
90140: PUSH
90141: LD_INT 32
90143: PUSH
90144: LD_INT 33
90146: PUSH
90147: LD_INT 34
90149: PUSH
90150: LD_INT 35
90152: PUSH
90153: LD_INT 36
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 101
90196: PUSH
90197: LD_INT 102
90199: PUSH
90200: LD_INT 103
90202: PUSH
90203: LD_INT 104
90205: PUSH
90206: LD_INT 105
90208: PUSH
90209: LD_INT 106
90211: PUSH
90212: LD_INT 107
90214: PUSH
90215: LD_INT 108
90217: PUSH
90218: LD_INT 109
90220: PUSH
90221: LD_INT 110
90223: PUSH
90224: LD_INT 111
90226: PUSH
90227: LD_INT 112
90229: PUSH
90230: LD_INT 113
90232: PUSH
90233: LD_INT 114
90235: PUSH
90236: LD_INT 115
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: ST_TO_ADDR
90260: GO 90263
90262: POP
// end else
90263: GO 90482
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
90265: LD_ADDR_VAR 0 1
90269: PUSH
90270: LD_INT 1
90272: PUSH
90273: LD_INT 2
90275: PUSH
90276: LD_INT 3
90278: PUSH
90279: LD_INT 4
90281: PUSH
90282: LD_INT 5
90284: PUSH
90285: LD_INT 6
90287: PUSH
90288: LD_INT 7
90290: PUSH
90291: LD_INT 8
90293: PUSH
90294: LD_INT 9
90296: PUSH
90297: LD_INT 10
90299: PUSH
90300: LD_INT 11
90302: PUSH
90303: LD_INT 12
90305: PUSH
90306: LD_INT 13
90308: PUSH
90309: LD_INT 14
90311: PUSH
90312: LD_INT 15
90314: PUSH
90315: LD_INT 16
90317: PUSH
90318: LD_INT 17
90320: PUSH
90321: LD_INT 18
90323: PUSH
90324: LD_INT 19
90326: PUSH
90327: LD_INT 20
90329: PUSH
90330: LD_INT 21
90332: PUSH
90333: LD_INT 22
90335: PUSH
90336: LD_INT 23
90338: PUSH
90339: LD_INT 24
90341: PUSH
90342: LD_INT 25
90344: PUSH
90345: LD_INT 26
90347: PUSH
90348: LD_INT 27
90350: PUSH
90351: LD_INT 28
90353: PUSH
90354: LD_INT 29
90356: PUSH
90357: LD_INT 30
90359: PUSH
90360: LD_INT 31
90362: PUSH
90363: LD_INT 32
90365: PUSH
90366: LD_INT 33
90368: PUSH
90369: LD_INT 34
90371: PUSH
90372: LD_INT 35
90374: PUSH
90375: LD_INT 36
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: PUSH
90416: LD_INT 101
90418: PUSH
90419: LD_INT 102
90421: PUSH
90422: LD_INT 103
90424: PUSH
90425: LD_INT 104
90427: PUSH
90428: LD_INT 105
90430: PUSH
90431: LD_INT 106
90433: PUSH
90434: LD_INT 107
90436: PUSH
90437: LD_INT 108
90439: PUSH
90440: LD_INT 109
90442: PUSH
90443: LD_INT 110
90445: PUSH
90446: LD_INT 111
90448: PUSH
90449: LD_INT 112
90451: PUSH
90452: LD_INT 113
90454: PUSH
90455: LD_INT 114
90457: PUSH
90458: LD_INT 115
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: ST_TO_ADDR
// if result then
90482: LD_VAR 0 1
90486: IFFALSE 90775
// begin normal :=  ;
90488: LD_ADDR_VAR 0 3
90492: PUSH
90493: LD_STRING 
90495: ST_TO_ADDR
// hardcore :=  ;
90496: LD_ADDR_VAR 0 4
90500: PUSH
90501: LD_STRING 
90503: ST_TO_ADDR
// for i = 1 to normalCounter do
90504: LD_ADDR_VAR 0 5
90508: PUSH
90509: DOUBLE
90510: LD_INT 1
90512: DEC
90513: ST_TO_ADDR
90514: LD_EXP 131
90518: PUSH
90519: FOR_TO
90520: IFFALSE 90621
// begin tmp := 0 ;
90522: LD_ADDR_VAR 0 2
90526: PUSH
90527: LD_STRING 0
90529: ST_TO_ADDR
// if result [ 1 ] then
90530: LD_VAR 0 1
90534: PUSH
90535: LD_INT 1
90537: ARRAY
90538: IFFALSE 90603
// if result [ 1 ] [ 1 ] = i then
90540: LD_VAR 0 1
90544: PUSH
90545: LD_INT 1
90547: ARRAY
90548: PUSH
90549: LD_INT 1
90551: ARRAY
90552: PUSH
90553: LD_VAR 0 5
90557: EQUAL
90558: IFFALSE 90603
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90560: LD_ADDR_VAR 0 1
90564: PUSH
90565: LD_VAR 0 1
90569: PPUSH
90570: LD_INT 1
90572: PPUSH
90573: LD_VAR 0 1
90577: PUSH
90578: LD_INT 1
90580: ARRAY
90581: PPUSH
90582: LD_INT 1
90584: PPUSH
90585: CALL_OW 3
90589: PPUSH
90590: CALL_OW 1
90594: ST_TO_ADDR
// tmp := 1 ;
90595: LD_ADDR_VAR 0 2
90599: PUSH
90600: LD_STRING 1
90602: ST_TO_ADDR
// end ; normal := normal & tmp ;
90603: LD_ADDR_VAR 0 3
90607: PUSH
90608: LD_VAR 0 3
90612: PUSH
90613: LD_VAR 0 2
90617: STR
90618: ST_TO_ADDR
// end ;
90619: GO 90519
90621: POP
90622: POP
// for i = 1 to hardcoreCounter do
90623: LD_ADDR_VAR 0 5
90627: PUSH
90628: DOUBLE
90629: LD_INT 1
90631: DEC
90632: ST_TO_ADDR
90633: LD_EXP 132
90637: PUSH
90638: FOR_TO
90639: IFFALSE 90744
// begin tmp := 0 ;
90641: LD_ADDR_VAR 0 2
90645: PUSH
90646: LD_STRING 0
90648: ST_TO_ADDR
// if result [ 2 ] then
90649: LD_VAR 0 1
90653: PUSH
90654: LD_INT 2
90656: ARRAY
90657: IFFALSE 90726
// if result [ 2 ] [ 1 ] = 100 + i then
90659: LD_VAR 0 1
90663: PUSH
90664: LD_INT 2
90666: ARRAY
90667: PUSH
90668: LD_INT 1
90670: ARRAY
90671: PUSH
90672: LD_INT 100
90674: PUSH
90675: LD_VAR 0 5
90679: PLUS
90680: EQUAL
90681: IFFALSE 90726
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90683: LD_ADDR_VAR 0 1
90687: PUSH
90688: LD_VAR 0 1
90692: PPUSH
90693: LD_INT 2
90695: PPUSH
90696: LD_VAR 0 1
90700: PUSH
90701: LD_INT 2
90703: ARRAY
90704: PPUSH
90705: LD_INT 1
90707: PPUSH
90708: CALL_OW 3
90712: PPUSH
90713: CALL_OW 1
90717: ST_TO_ADDR
// tmp := 1 ;
90718: LD_ADDR_VAR 0 2
90722: PUSH
90723: LD_STRING 1
90725: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90726: LD_ADDR_VAR 0 4
90730: PUSH
90731: LD_VAR 0 4
90735: PUSH
90736: LD_VAR 0 2
90740: STR
90741: ST_TO_ADDR
// end ;
90742: GO 90638
90744: POP
90745: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
90746: LD_STRING getStreamItemsFromMission("
90748: PUSH
90749: LD_VAR 0 3
90753: STR
90754: PUSH
90755: LD_STRING ","
90757: STR
90758: PUSH
90759: LD_VAR 0 4
90763: STR
90764: PUSH
90765: LD_STRING ")
90767: STR
90768: PPUSH
90769: CALL_OW 559
// end else
90773: GO 90782
// ToLua ( getStreamItemsFromMission("","") ) ;
90775: LD_STRING getStreamItemsFromMission("","")
90777: PPUSH
90778: CALL_OW 559
// end ;
90782: LD_VAR 0 1
90786: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
90787: LD_VAR 0 2
90791: PUSH
90792: LD_INT 100
90794: EQUAL
90795: IFFALSE 91744
// begin if not StreamModeActive then
90797: LD_EXP 130
90801: NOT
90802: IFFALSE 90812
// StreamModeActive := true ;
90804: LD_ADDR_EXP 130
90808: PUSH
90809: LD_INT 1
90811: ST_TO_ADDR
// if p3 = 0 then
90812: LD_VAR 0 3
90816: PUSH
90817: LD_INT 0
90819: EQUAL
90820: IFFALSE 90826
// InitStreamMode ;
90822: CALL 86865 0 0
// if p3 = 1 then
90826: LD_VAR 0 3
90830: PUSH
90831: LD_INT 1
90833: EQUAL
90834: IFFALSE 90844
// sRocket := true ;
90836: LD_ADDR_EXP 135
90840: PUSH
90841: LD_INT 1
90843: ST_TO_ADDR
// if p3 = 2 then
90844: LD_VAR 0 3
90848: PUSH
90849: LD_INT 2
90851: EQUAL
90852: IFFALSE 90862
// sSpeed := true ;
90854: LD_ADDR_EXP 134
90858: PUSH
90859: LD_INT 1
90861: ST_TO_ADDR
// if p3 = 3 then
90862: LD_VAR 0 3
90866: PUSH
90867: LD_INT 3
90869: EQUAL
90870: IFFALSE 90880
// sEngine := true ;
90872: LD_ADDR_EXP 136
90876: PUSH
90877: LD_INT 1
90879: ST_TO_ADDR
// if p3 = 4 then
90880: LD_VAR 0 3
90884: PUSH
90885: LD_INT 4
90887: EQUAL
90888: IFFALSE 90898
// sSpec := true ;
90890: LD_ADDR_EXP 133
90894: PUSH
90895: LD_INT 1
90897: ST_TO_ADDR
// if p3 = 5 then
90898: LD_VAR 0 3
90902: PUSH
90903: LD_INT 5
90905: EQUAL
90906: IFFALSE 90916
// sLevel := true ;
90908: LD_ADDR_EXP 137
90912: PUSH
90913: LD_INT 1
90915: ST_TO_ADDR
// if p3 = 6 then
90916: LD_VAR 0 3
90920: PUSH
90921: LD_INT 6
90923: EQUAL
90924: IFFALSE 90934
// sArmoury := true ;
90926: LD_ADDR_EXP 138
90930: PUSH
90931: LD_INT 1
90933: ST_TO_ADDR
// if p3 = 7 then
90934: LD_VAR 0 3
90938: PUSH
90939: LD_INT 7
90941: EQUAL
90942: IFFALSE 90952
// sRadar := true ;
90944: LD_ADDR_EXP 139
90948: PUSH
90949: LD_INT 1
90951: ST_TO_ADDR
// if p3 = 8 then
90952: LD_VAR 0 3
90956: PUSH
90957: LD_INT 8
90959: EQUAL
90960: IFFALSE 90970
// sBunker := true ;
90962: LD_ADDR_EXP 140
90966: PUSH
90967: LD_INT 1
90969: ST_TO_ADDR
// if p3 = 9 then
90970: LD_VAR 0 3
90974: PUSH
90975: LD_INT 9
90977: EQUAL
90978: IFFALSE 90988
// sHack := true ;
90980: LD_ADDR_EXP 141
90984: PUSH
90985: LD_INT 1
90987: ST_TO_ADDR
// if p3 = 10 then
90988: LD_VAR 0 3
90992: PUSH
90993: LD_INT 10
90995: EQUAL
90996: IFFALSE 91006
// sFire := true ;
90998: LD_ADDR_EXP 142
91002: PUSH
91003: LD_INT 1
91005: ST_TO_ADDR
// if p3 = 11 then
91006: LD_VAR 0 3
91010: PUSH
91011: LD_INT 11
91013: EQUAL
91014: IFFALSE 91024
// sRefresh := true ;
91016: LD_ADDR_EXP 143
91020: PUSH
91021: LD_INT 1
91023: ST_TO_ADDR
// if p3 = 12 then
91024: LD_VAR 0 3
91028: PUSH
91029: LD_INT 12
91031: EQUAL
91032: IFFALSE 91042
// sExp := true ;
91034: LD_ADDR_EXP 144
91038: PUSH
91039: LD_INT 1
91041: ST_TO_ADDR
// if p3 = 13 then
91042: LD_VAR 0 3
91046: PUSH
91047: LD_INT 13
91049: EQUAL
91050: IFFALSE 91060
// sDepot := true ;
91052: LD_ADDR_EXP 145
91056: PUSH
91057: LD_INT 1
91059: ST_TO_ADDR
// if p3 = 14 then
91060: LD_VAR 0 3
91064: PUSH
91065: LD_INT 14
91067: EQUAL
91068: IFFALSE 91078
// sFlag := true ;
91070: LD_ADDR_EXP 146
91074: PUSH
91075: LD_INT 1
91077: ST_TO_ADDR
// if p3 = 15 then
91078: LD_VAR 0 3
91082: PUSH
91083: LD_INT 15
91085: EQUAL
91086: IFFALSE 91096
// sKamikadze := true ;
91088: LD_ADDR_EXP 154
91092: PUSH
91093: LD_INT 1
91095: ST_TO_ADDR
// if p3 = 16 then
91096: LD_VAR 0 3
91100: PUSH
91101: LD_INT 16
91103: EQUAL
91104: IFFALSE 91114
// sTroll := true ;
91106: LD_ADDR_EXP 155
91110: PUSH
91111: LD_INT 1
91113: ST_TO_ADDR
// if p3 = 17 then
91114: LD_VAR 0 3
91118: PUSH
91119: LD_INT 17
91121: EQUAL
91122: IFFALSE 91132
// sSlow := true ;
91124: LD_ADDR_EXP 156
91128: PUSH
91129: LD_INT 1
91131: ST_TO_ADDR
// if p3 = 18 then
91132: LD_VAR 0 3
91136: PUSH
91137: LD_INT 18
91139: EQUAL
91140: IFFALSE 91150
// sLack := true ;
91142: LD_ADDR_EXP 157
91146: PUSH
91147: LD_INT 1
91149: ST_TO_ADDR
// if p3 = 19 then
91150: LD_VAR 0 3
91154: PUSH
91155: LD_INT 19
91157: EQUAL
91158: IFFALSE 91168
// sTank := true ;
91160: LD_ADDR_EXP 159
91164: PUSH
91165: LD_INT 1
91167: ST_TO_ADDR
// if p3 = 20 then
91168: LD_VAR 0 3
91172: PUSH
91173: LD_INT 20
91175: EQUAL
91176: IFFALSE 91186
// sRemote := true ;
91178: LD_ADDR_EXP 160
91182: PUSH
91183: LD_INT 1
91185: ST_TO_ADDR
// if p3 = 21 then
91186: LD_VAR 0 3
91190: PUSH
91191: LD_INT 21
91193: EQUAL
91194: IFFALSE 91204
// sPowell := true ;
91196: LD_ADDR_EXP 161
91200: PUSH
91201: LD_INT 1
91203: ST_TO_ADDR
// if p3 = 22 then
91204: LD_VAR 0 3
91208: PUSH
91209: LD_INT 22
91211: EQUAL
91212: IFFALSE 91222
// sTeleport := true ;
91214: LD_ADDR_EXP 164
91218: PUSH
91219: LD_INT 1
91221: ST_TO_ADDR
// if p3 = 23 then
91222: LD_VAR 0 3
91226: PUSH
91227: LD_INT 23
91229: EQUAL
91230: IFFALSE 91240
// sOilTower := true ;
91232: LD_ADDR_EXP 166
91236: PUSH
91237: LD_INT 1
91239: ST_TO_ADDR
// if p3 = 24 then
91240: LD_VAR 0 3
91244: PUSH
91245: LD_INT 24
91247: EQUAL
91248: IFFALSE 91258
// sShovel := true ;
91250: LD_ADDR_EXP 167
91254: PUSH
91255: LD_INT 1
91257: ST_TO_ADDR
// if p3 = 25 then
91258: LD_VAR 0 3
91262: PUSH
91263: LD_INT 25
91265: EQUAL
91266: IFFALSE 91276
// sSheik := true ;
91268: LD_ADDR_EXP 168
91272: PUSH
91273: LD_INT 1
91275: ST_TO_ADDR
// if p3 = 26 then
91276: LD_VAR 0 3
91280: PUSH
91281: LD_INT 26
91283: EQUAL
91284: IFFALSE 91294
// sEarthquake := true ;
91286: LD_ADDR_EXP 170
91290: PUSH
91291: LD_INT 1
91293: ST_TO_ADDR
// if p3 = 27 then
91294: LD_VAR 0 3
91298: PUSH
91299: LD_INT 27
91301: EQUAL
91302: IFFALSE 91312
// sAI := true ;
91304: LD_ADDR_EXP 171
91308: PUSH
91309: LD_INT 1
91311: ST_TO_ADDR
// if p3 = 28 then
91312: LD_VAR 0 3
91316: PUSH
91317: LD_INT 28
91319: EQUAL
91320: IFFALSE 91330
// sCargo := true ;
91322: LD_ADDR_EXP 174
91326: PUSH
91327: LD_INT 1
91329: ST_TO_ADDR
// if p3 = 29 then
91330: LD_VAR 0 3
91334: PUSH
91335: LD_INT 29
91337: EQUAL
91338: IFFALSE 91348
// sDLaser := true ;
91340: LD_ADDR_EXP 175
91344: PUSH
91345: LD_INT 1
91347: ST_TO_ADDR
// if p3 = 30 then
91348: LD_VAR 0 3
91352: PUSH
91353: LD_INT 30
91355: EQUAL
91356: IFFALSE 91366
// sExchange := true ;
91358: LD_ADDR_EXP 176
91362: PUSH
91363: LD_INT 1
91365: ST_TO_ADDR
// if p3 = 31 then
91366: LD_VAR 0 3
91370: PUSH
91371: LD_INT 31
91373: EQUAL
91374: IFFALSE 91384
// sFac := true ;
91376: LD_ADDR_EXP 177
91380: PUSH
91381: LD_INT 1
91383: ST_TO_ADDR
// if p3 = 32 then
91384: LD_VAR 0 3
91388: PUSH
91389: LD_INT 32
91391: EQUAL
91392: IFFALSE 91402
// sPower := true ;
91394: LD_ADDR_EXP 178
91398: PUSH
91399: LD_INT 1
91401: ST_TO_ADDR
// if p3 = 33 then
91402: LD_VAR 0 3
91406: PUSH
91407: LD_INT 33
91409: EQUAL
91410: IFFALSE 91420
// sRandom := true ;
91412: LD_ADDR_EXP 179
91416: PUSH
91417: LD_INT 1
91419: ST_TO_ADDR
// if p3 = 34 then
91420: LD_VAR 0 3
91424: PUSH
91425: LD_INT 34
91427: EQUAL
91428: IFFALSE 91438
// sShield := true ;
91430: LD_ADDR_EXP 180
91434: PUSH
91435: LD_INT 1
91437: ST_TO_ADDR
// if p3 = 35 then
91438: LD_VAR 0 3
91442: PUSH
91443: LD_INT 35
91445: EQUAL
91446: IFFALSE 91456
// sTime := true ;
91448: LD_ADDR_EXP 181
91452: PUSH
91453: LD_INT 1
91455: ST_TO_ADDR
// if p3 = 36 then
91456: LD_VAR 0 3
91460: PUSH
91461: LD_INT 36
91463: EQUAL
91464: IFFALSE 91474
// sTools := true ;
91466: LD_ADDR_EXP 182
91470: PUSH
91471: LD_INT 1
91473: ST_TO_ADDR
// if p3 = 101 then
91474: LD_VAR 0 3
91478: PUSH
91479: LD_INT 101
91481: EQUAL
91482: IFFALSE 91492
// sSold := true ;
91484: LD_ADDR_EXP 147
91488: PUSH
91489: LD_INT 1
91491: ST_TO_ADDR
// if p3 = 102 then
91492: LD_VAR 0 3
91496: PUSH
91497: LD_INT 102
91499: EQUAL
91500: IFFALSE 91510
// sDiff := true ;
91502: LD_ADDR_EXP 148
91506: PUSH
91507: LD_INT 1
91509: ST_TO_ADDR
// if p3 = 103 then
91510: LD_VAR 0 3
91514: PUSH
91515: LD_INT 103
91517: EQUAL
91518: IFFALSE 91528
// sFog := true ;
91520: LD_ADDR_EXP 151
91524: PUSH
91525: LD_INT 1
91527: ST_TO_ADDR
// if p3 = 104 then
91528: LD_VAR 0 3
91532: PUSH
91533: LD_INT 104
91535: EQUAL
91536: IFFALSE 91546
// sReset := true ;
91538: LD_ADDR_EXP 152
91542: PUSH
91543: LD_INT 1
91545: ST_TO_ADDR
// if p3 = 105 then
91546: LD_VAR 0 3
91550: PUSH
91551: LD_INT 105
91553: EQUAL
91554: IFFALSE 91564
// sSun := true ;
91556: LD_ADDR_EXP 153
91560: PUSH
91561: LD_INT 1
91563: ST_TO_ADDR
// if p3 = 106 then
91564: LD_VAR 0 3
91568: PUSH
91569: LD_INT 106
91571: EQUAL
91572: IFFALSE 91582
// sTiger := true ;
91574: LD_ADDR_EXP 149
91578: PUSH
91579: LD_INT 1
91581: ST_TO_ADDR
// if p3 = 107 then
91582: LD_VAR 0 3
91586: PUSH
91587: LD_INT 107
91589: EQUAL
91590: IFFALSE 91600
// sBomb := true ;
91592: LD_ADDR_EXP 150
91596: PUSH
91597: LD_INT 1
91599: ST_TO_ADDR
// if p3 = 108 then
91600: LD_VAR 0 3
91604: PUSH
91605: LD_INT 108
91607: EQUAL
91608: IFFALSE 91618
// sWound := true ;
91610: LD_ADDR_EXP 158
91614: PUSH
91615: LD_INT 1
91617: ST_TO_ADDR
// if p3 = 109 then
91618: LD_VAR 0 3
91622: PUSH
91623: LD_INT 109
91625: EQUAL
91626: IFFALSE 91636
// sBetray := true ;
91628: LD_ADDR_EXP 162
91632: PUSH
91633: LD_INT 1
91635: ST_TO_ADDR
// if p3 = 110 then
91636: LD_VAR 0 3
91640: PUSH
91641: LD_INT 110
91643: EQUAL
91644: IFFALSE 91654
// sContamin := true ;
91646: LD_ADDR_EXP 163
91650: PUSH
91651: LD_INT 1
91653: ST_TO_ADDR
// if p3 = 111 then
91654: LD_VAR 0 3
91658: PUSH
91659: LD_INT 111
91661: EQUAL
91662: IFFALSE 91672
// sOil := true ;
91664: LD_ADDR_EXP 165
91668: PUSH
91669: LD_INT 1
91671: ST_TO_ADDR
// if p3 = 112 then
91672: LD_VAR 0 3
91676: PUSH
91677: LD_INT 112
91679: EQUAL
91680: IFFALSE 91690
// sStu := true ;
91682: LD_ADDR_EXP 169
91686: PUSH
91687: LD_INT 1
91689: ST_TO_ADDR
// if p3 = 113 then
91690: LD_VAR 0 3
91694: PUSH
91695: LD_INT 113
91697: EQUAL
91698: IFFALSE 91708
// sBazooka := true ;
91700: LD_ADDR_EXP 172
91704: PUSH
91705: LD_INT 1
91707: ST_TO_ADDR
// if p3 = 114 then
91708: LD_VAR 0 3
91712: PUSH
91713: LD_INT 114
91715: EQUAL
91716: IFFALSE 91726
// sMortar := true ;
91718: LD_ADDR_EXP 173
91722: PUSH
91723: LD_INT 1
91725: ST_TO_ADDR
// if p3 = 115 then
91726: LD_VAR 0 3
91730: PUSH
91731: LD_INT 115
91733: EQUAL
91734: IFFALSE 91744
// sRanger := true ;
91736: LD_ADDR_EXP 183
91740: PUSH
91741: LD_INT 1
91743: ST_TO_ADDR
// end ; end ;
91744: PPOPN 6
91746: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91747: LD_EXP 130
91751: PUSH
91752: LD_EXP 135
91756: AND
91757: IFFALSE 91881
91759: GO 91761
91761: DISABLE
91762: LD_INT 0
91764: PPUSH
91765: PPUSH
// begin enable ;
91766: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91767: LD_ADDR_VAR 0 2
91771: PUSH
91772: LD_INT 22
91774: PUSH
91775: LD_OWVAR 2
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 2
91786: PUSH
91787: LD_INT 34
91789: PUSH
91790: LD_INT 7
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: PUSH
91797: LD_INT 34
91799: PUSH
91800: LD_INT 45
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 34
91809: PUSH
91810: LD_INT 28
91812: PUSH
91813: EMPTY
91814: LIST
91815: LIST
91816: PUSH
91817: LD_INT 34
91819: PUSH
91820: LD_INT 47
91822: PUSH
91823: EMPTY
91824: LIST
91825: LIST
91826: PUSH
91827: EMPTY
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: PUSH
91834: EMPTY
91835: LIST
91836: LIST
91837: PPUSH
91838: CALL_OW 69
91842: ST_TO_ADDR
// if not tmp then
91843: LD_VAR 0 2
91847: NOT
91848: IFFALSE 91852
// exit ;
91850: GO 91881
// for i in tmp do
91852: LD_ADDR_VAR 0 1
91856: PUSH
91857: LD_VAR 0 2
91861: PUSH
91862: FOR_IN
91863: IFFALSE 91879
// begin SetLives ( i , 0 ) ;
91865: LD_VAR 0 1
91869: PPUSH
91870: LD_INT 0
91872: PPUSH
91873: CALL_OW 234
// end ;
91877: GO 91862
91879: POP
91880: POP
// end ;
91881: PPOPN 2
91883: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91884: LD_EXP 130
91888: PUSH
91889: LD_EXP 136
91893: AND
91894: IFFALSE 91978
91896: GO 91898
91898: DISABLE
91899: LD_INT 0
91901: PPUSH
91902: PPUSH
// begin enable ;
91903: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
91904: LD_ADDR_VAR 0 2
91908: PUSH
91909: LD_INT 22
91911: PUSH
91912: LD_OWVAR 2
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 32
91923: PUSH
91924: LD_INT 3
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PPUSH
91935: CALL_OW 69
91939: ST_TO_ADDR
// if not tmp then
91940: LD_VAR 0 2
91944: NOT
91945: IFFALSE 91949
// exit ;
91947: GO 91978
// for i in tmp do
91949: LD_ADDR_VAR 0 1
91953: PUSH
91954: LD_VAR 0 2
91958: PUSH
91959: FOR_IN
91960: IFFALSE 91976
// begin SetLives ( i , 0 ) ;
91962: LD_VAR 0 1
91966: PPUSH
91967: LD_INT 0
91969: PPUSH
91970: CALL_OW 234
// end ;
91974: GO 91959
91976: POP
91977: POP
// end ;
91978: PPOPN 2
91980: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91981: LD_EXP 130
91985: PUSH
91986: LD_EXP 133
91990: AND
91991: IFFALSE 92084
91993: GO 91995
91995: DISABLE
91996: LD_INT 0
91998: PPUSH
// begin enable ;
91999: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92000: LD_ADDR_VAR 0 1
92004: PUSH
92005: LD_INT 22
92007: PUSH
92008: LD_OWVAR 2
92012: PUSH
92013: EMPTY
92014: LIST
92015: LIST
92016: PUSH
92017: LD_INT 2
92019: PUSH
92020: LD_INT 25
92022: PUSH
92023: LD_INT 5
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 25
92032: PUSH
92033: LD_INT 9
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 25
92042: PUSH
92043: LD_INT 8
92045: PUSH
92046: EMPTY
92047: LIST
92048: LIST
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: LIST
92054: LIST
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: PPUSH
92060: CALL_OW 69
92064: PUSH
92065: FOR_IN
92066: IFFALSE 92082
// begin SetClass ( i , 1 ) ;
92068: LD_VAR 0 1
92072: PPUSH
92073: LD_INT 1
92075: PPUSH
92076: CALL_OW 336
// end ;
92080: GO 92065
92082: POP
92083: POP
// end ;
92084: PPOPN 1
92086: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92087: LD_EXP 130
92091: PUSH
92092: LD_EXP 134
92096: AND
92097: PUSH
92098: LD_OWVAR 65
92102: PUSH
92103: LD_INT 7
92105: LESS
92106: AND
92107: IFFALSE 92121
92109: GO 92111
92111: DISABLE
// begin enable ;
92112: ENABLE
// game_speed := 7 ;
92113: LD_ADDR_OWVAR 65
92117: PUSH
92118: LD_INT 7
92120: ST_TO_ADDR
// end ;
92121: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92122: LD_EXP 130
92126: PUSH
92127: LD_EXP 137
92131: AND
92132: IFFALSE 92334
92134: GO 92136
92136: DISABLE
92137: LD_INT 0
92139: PPUSH
92140: PPUSH
92141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92142: LD_ADDR_VAR 0 3
92146: PUSH
92147: LD_INT 81
92149: PUSH
92150: LD_OWVAR 2
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 21
92161: PUSH
92162: LD_INT 1
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: EMPTY
92170: LIST
92171: LIST
92172: PPUSH
92173: CALL_OW 69
92177: ST_TO_ADDR
// if not tmp then
92178: LD_VAR 0 3
92182: NOT
92183: IFFALSE 92187
// exit ;
92185: GO 92334
// if tmp > 5 then
92187: LD_VAR 0 3
92191: PUSH
92192: LD_INT 5
92194: GREATER
92195: IFFALSE 92207
// k := 5 else
92197: LD_ADDR_VAR 0 2
92201: PUSH
92202: LD_INT 5
92204: ST_TO_ADDR
92205: GO 92217
// k := tmp ;
92207: LD_ADDR_VAR 0 2
92211: PUSH
92212: LD_VAR 0 3
92216: ST_TO_ADDR
// for i := 1 to k do
92217: LD_ADDR_VAR 0 1
92221: PUSH
92222: DOUBLE
92223: LD_INT 1
92225: DEC
92226: ST_TO_ADDR
92227: LD_VAR 0 2
92231: PUSH
92232: FOR_TO
92233: IFFALSE 92332
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92235: LD_VAR 0 3
92239: PUSH
92240: LD_VAR 0 1
92244: ARRAY
92245: PPUSH
92246: LD_VAR 0 1
92250: PUSH
92251: LD_INT 4
92253: MOD
92254: PUSH
92255: LD_INT 1
92257: PLUS
92258: PPUSH
92259: CALL_OW 259
92263: PUSH
92264: LD_INT 10
92266: LESS
92267: IFFALSE 92330
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92269: LD_VAR 0 3
92273: PUSH
92274: LD_VAR 0 1
92278: ARRAY
92279: PPUSH
92280: LD_VAR 0 1
92284: PUSH
92285: LD_INT 4
92287: MOD
92288: PUSH
92289: LD_INT 1
92291: PLUS
92292: PPUSH
92293: LD_VAR 0 3
92297: PUSH
92298: LD_VAR 0 1
92302: ARRAY
92303: PPUSH
92304: LD_VAR 0 1
92308: PUSH
92309: LD_INT 4
92311: MOD
92312: PUSH
92313: LD_INT 1
92315: PLUS
92316: PPUSH
92317: CALL_OW 259
92321: PUSH
92322: LD_INT 1
92324: PLUS
92325: PPUSH
92326: CALL_OW 237
92330: GO 92232
92332: POP
92333: POP
// end ;
92334: PPOPN 3
92336: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92337: LD_EXP 130
92341: PUSH
92342: LD_EXP 138
92346: AND
92347: IFFALSE 92367
92349: GO 92351
92351: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92352: LD_INT 4
92354: PPUSH
92355: LD_OWVAR 2
92359: PPUSH
92360: LD_INT 0
92362: PPUSH
92363: CALL_OW 324
92367: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92368: LD_EXP 130
92372: PUSH
92373: LD_EXP 167
92377: AND
92378: IFFALSE 92398
92380: GO 92382
92382: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92383: LD_INT 19
92385: PPUSH
92386: LD_OWVAR 2
92390: PPUSH
92391: LD_INT 0
92393: PPUSH
92394: CALL_OW 324
92398: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92399: LD_EXP 130
92403: PUSH
92404: LD_EXP 139
92408: AND
92409: IFFALSE 92511
92411: GO 92413
92413: DISABLE
92414: LD_INT 0
92416: PPUSH
92417: PPUSH
// begin enable ;
92418: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92419: LD_ADDR_VAR 0 2
92423: PUSH
92424: LD_INT 22
92426: PUSH
92427: LD_OWVAR 2
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 2
92438: PUSH
92439: LD_INT 34
92441: PUSH
92442: LD_INT 11
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: PUSH
92449: LD_INT 34
92451: PUSH
92452: LD_INT 30
92454: PUSH
92455: EMPTY
92456: LIST
92457: LIST
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: LIST
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: PPUSH
92468: CALL_OW 69
92472: ST_TO_ADDR
// if not tmp then
92473: LD_VAR 0 2
92477: NOT
92478: IFFALSE 92482
// exit ;
92480: GO 92511
// for i in tmp do
92482: LD_ADDR_VAR 0 1
92486: PUSH
92487: LD_VAR 0 2
92491: PUSH
92492: FOR_IN
92493: IFFALSE 92509
// begin SetLives ( i , 0 ) ;
92495: LD_VAR 0 1
92499: PPUSH
92500: LD_INT 0
92502: PPUSH
92503: CALL_OW 234
// end ;
92507: GO 92492
92509: POP
92510: POP
// end ;
92511: PPOPN 2
92513: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92514: LD_EXP 130
92518: PUSH
92519: LD_EXP 140
92523: AND
92524: IFFALSE 92544
92526: GO 92528
92528: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92529: LD_INT 32
92531: PPUSH
92532: LD_OWVAR 2
92536: PPUSH
92537: LD_INT 0
92539: PPUSH
92540: CALL_OW 324
92544: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92545: LD_EXP 130
92549: PUSH
92550: LD_EXP 141
92554: AND
92555: IFFALSE 92736
92557: GO 92559
92559: DISABLE
92560: LD_INT 0
92562: PPUSH
92563: PPUSH
92564: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92565: LD_ADDR_VAR 0 2
92569: PUSH
92570: LD_INT 22
92572: PUSH
92573: LD_OWVAR 2
92577: PUSH
92578: EMPTY
92579: LIST
92580: LIST
92581: PUSH
92582: LD_INT 33
92584: PUSH
92585: LD_INT 3
92587: PUSH
92588: EMPTY
92589: LIST
92590: LIST
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PPUSH
92596: CALL_OW 69
92600: ST_TO_ADDR
// if not tmp then
92601: LD_VAR 0 2
92605: NOT
92606: IFFALSE 92610
// exit ;
92608: GO 92736
// side := 0 ;
92610: LD_ADDR_VAR 0 3
92614: PUSH
92615: LD_INT 0
92617: ST_TO_ADDR
// for i := 1 to 8 do
92618: LD_ADDR_VAR 0 1
92622: PUSH
92623: DOUBLE
92624: LD_INT 1
92626: DEC
92627: ST_TO_ADDR
92628: LD_INT 8
92630: PUSH
92631: FOR_TO
92632: IFFALSE 92680
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92634: LD_OWVAR 2
92638: PUSH
92639: LD_VAR 0 1
92643: NONEQUAL
92644: PUSH
92645: LD_OWVAR 2
92649: PPUSH
92650: LD_VAR 0 1
92654: PPUSH
92655: CALL_OW 81
92659: PUSH
92660: LD_INT 2
92662: EQUAL
92663: AND
92664: IFFALSE 92678
// begin side := i ;
92666: LD_ADDR_VAR 0 3
92670: PUSH
92671: LD_VAR 0 1
92675: ST_TO_ADDR
// break ;
92676: GO 92680
// end ;
92678: GO 92631
92680: POP
92681: POP
// if not side then
92682: LD_VAR 0 3
92686: NOT
92687: IFFALSE 92691
// exit ;
92689: GO 92736
// for i := 1 to tmp do
92691: LD_ADDR_VAR 0 1
92695: PUSH
92696: DOUBLE
92697: LD_INT 1
92699: DEC
92700: ST_TO_ADDR
92701: LD_VAR 0 2
92705: PUSH
92706: FOR_TO
92707: IFFALSE 92734
// if Prob ( 60 ) then
92709: LD_INT 60
92711: PPUSH
92712: CALL_OW 13
92716: IFFALSE 92732
// SetSide ( i , side ) ;
92718: LD_VAR 0 1
92722: PPUSH
92723: LD_VAR 0 3
92727: PPUSH
92728: CALL_OW 235
92732: GO 92706
92734: POP
92735: POP
// end ;
92736: PPOPN 3
92738: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92739: LD_EXP 130
92743: PUSH
92744: LD_EXP 143
92748: AND
92749: IFFALSE 92868
92751: GO 92753
92753: DISABLE
92754: LD_INT 0
92756: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92757: LD_ADDR_VAR 0 1
92761: PUSH
92762: LD_INT 22
92764: PUSH
92765: LD_OWVAR 2
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: PUSH
92774: LD_INT 21
92776: PUSH
92777: LD_INT 1
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PUSH
92784: LD_INT 3
92786: PUSH
92787: LD_INT 23
92789: PUSH
92790: LD_INT 0
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: LIST
92805: PPUSH
92806: CALL_OW 69
92810: PUSH
92811: FOR_IN
92812: IFFALSE 92866
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92814: LD_VAR 0 1
92818: PPUSH
92819: CALL_OW 257
92823: PUSH
92824: LD_INT 1
92826: PUSH
92827: LD_INT 2
92829: PUSH
92830: LD_INT 3
92832: PUSH
92833: LD_INT 4
92835: PUSH
92836: EMPTY
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: IN
92842: IFFALSE 92864
// SetClass ( un , rand ( 1 , 4 ) ) ;
92844: LD_VAR 0 1
92848: PPUSH
92849: LD_INT 1
92851: PPUSH
92852: LD_INT 4
92854: PPUSH
92855: CALL_OW 12
92859: PPUSH
92860: CALL_OW 336
92864: GO 92811
92866: POP
92867: POP
// end ;
92868: PPOPN 1
92870: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
92871: LD_EXP 130
92875: PUSH
92876: LD_EXP 142
92880: AND
92881: IFFALSE 92960
92883: GO 92885
92885: DISABLE
92886: LD_INT 0
92888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92889: LD_ADDR_VAR 0 1
92893: PUSH
92894: LD_INT 22
92896: PUSH
92897: LD_OWVAR 2
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 21
92908: PUSH
92909: LD_INT 3
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PPUSH
92920: CALL_OW 69
92924: ST_TO_ADDR
// if not tmp then
92925: LD_VAR 0 1
92929: NOT
92930: IFFALSE 92934
// exit ;
92932: GO 92960
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
92934: LD_VAR 0 1
92938: PUSH
92939: LD_INT 1
92941: PPUSH
92942: LD_VAR 0 1
92946: PPUSH
92947: CALL_OW 12
92951: ARRAY
92952: PPUSH
92953: LD_INT 100
92955: PPUSH
92956: CALL_OW 234
// end ;
92960: PPOPN 1
92962: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92963: LD_EXP 130
92967: PUSH
92968: LD_EXP 144
92972: AND
92973: IFFALSE 93071
92975: GO 92977
92977: DISABLE
92978: LD_INT 0
92980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92981: LD_ADDR_VAR 0 1
92985: PUSH
92986: LD_INT 22
92988: PUSH
92989: LD_OWVAR 2
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 21
93000: PUSH
93001: LD_INT 1
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PPUSH
93012: CALL_OW 69
93016: ST_TO_ADDR
// if not tmp then
93017: LD_VAR 0 1
93021: NOT
93022: IFFALSE 93026
// exit ;
93024: GO 93071
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93026: LD_VAR 0 1
93030: PUSH
93031: LD_INT 1
93033: PPUSH
93034: LD_VAR 0 1
93038: PPUSH
93039: CALL_OW 12
93043: ARRAY
93044: PPUSH
93045: LD_INT 1
93047: PPUSH
93048: LD_INT 4
93050: PPUSH
93051: CALL_OW 12
93055: PPUSH
93056: LD_INT 3000
93058: PPUSH
93059: LD_INT 9000
93061: PPUSH
93062: CALL_OW 12
93066: PPUSH
93067: CALL_OW 492
// end ;
93071: PPOPN 1
93073: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93074: LD_EXP 130
93078: PUSH
93079: LD_EXP 145
93083: AND
93084: IFFALSE 93104
93086: GO 93088
93088: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93089: LD_INT 1
93091: PPUSH
93092: LD_OWVAR 2
93096: PPUSH
93097: LD_INT 0
93099: PPUSH
93100: CALL_OW 324
93104: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93105: LD_EXP 130
93109: PUSH
93110: LD_EXP 146
93114: AND
93115: IFFALSE 93198
93117: GO 93119
93119: DISABLE
93120: LD_INT 0
93122: PPUSH
93123: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93124: LD_ADDR_VAR 0 2
93128: PUSH
93129: LD_INT 22
93131: PUSH
93132: LD_OWVAR 2
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: PUSH
93141: LD_INT 21
93143: PUSH
93144: LD_INT 3
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: PPUSH
93155: CALL_OW 69
93159: ST_TO_ADDR
// if not tmp then
93160: LD_VAR 0 2
93164: NOT
93165: IFFALSE 93169
// exit ;
93167: GO 93198
// for i in tmp do
93169: LD_ADDR_VAR 0 1
93173: PUSH
93174: LD_VAR 0 2
93178: PUSH
93179: FOR_IN
93180: IFFALSE 93196
// SetBLevel ( i , 10 ) ;
93182: LD_VAR 0 1
93186: PPUSH
93187: LD_INT 10
93189: PPUSH
93190: CALL_OW 241
93194: GO 93179
93196: POP
93197: POP
// end ;
93198: PPOPN 2
93200: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93201: LD_EXP 130
93205: PUSH
93206: LD_EXP 147
93210: AND
93211: IFFALSE 93322
93213: GO 93215
93215: DISABLE
93216: LD_INT 0
93218: PPUSH
93219: PPUSH
93220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93221: LD_ADDR_VAR 0 3
93225: PUSH
93226: LD_INT 22
93228: PUSH
93229: LD_OWVAR 2
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 25
93240: PUSH
93241: LD_INT 1
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: EMPTY
93249: LIST
93250: LIST
93251: PPUSH
93252: CALL_OW 69
93256: ST_TO_ADDR
// if not tmp then
93257: LD_VAR 0 3
93261: NOT
93262: IFFALSE 93266
// exit ;
93264: GO 93322
// un := tmp [ rand ( 1 , tmp ) ] ;
93266: LD_ADDR_VAR 0 2
93270: PUSH
93271: LD_VAR 0 3
93275: PUSH
93276: LD_INT 1
93278: PPUSH
93279: LD_VAR 0 3
93283: PPUSH
93284: CALL_OW 12
93288: ARRAY
93289: ST_TO_ADDR
// if Crawls ( un ) then
93290: LD_VAR 0 2
93294: PPUSH
93295: CALL_OW 318
93299: IFFALSE 93310
// ComWalk ( un ) ;
93301: LD_VAR 0 2
93305: PPUSH
93306: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93310: LD_VAR 0 2
93314: PPUSH
93315: LD_INT 5
93317: PPUSH
93318: CALL_OW 336
// end ;
93322: PPOPN 3
93324: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
93325: LD_EXP 130
93329: PUSH
93330: LD_EXP 148
93334: AND
93335: PUSH
93336: LD_OWVAR 67
93340: PUSH
93341: LD_INT 3
93343: LESS
93344: AND
93345: IFFALSE 93364
93347: GO 93349
93349: DISABLE
// Difficulty := Difficulty + 1 ;
93350: LD_ADDR_OWVAR 67
93354: PUSH
93355: LD_OWVAR 67
93359: PUSH
93360: LD_INT 1
93362: PLUS
93363: ST_TO_ADDR
93364: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93365: LD_EXP 130
93369: PUSH
93370: LD_EXP 149
93374: AND
93375: IFFALSE 93478
93377: GO 93379
93379: DISABLE
93380: LD_INT 0
93382: PPUSH
// begin for i := 1 to 5 do
93383: LD_ADDR_VAR 0 1
93387: PUSH
93388: DOUBLE
93389: LD_INT 1
93391: DEC
93392: ST_TO_ADDR
93393: LD_INT 5
93395: PUSH
93396: FOR_TO
93397: IFFALSE 93476
// begin uc_nation := nation_nature ;
93399: LD_ADDR_OWVAR 21
93403: PUSH
93404: LD_INT 0
93406: ST_TO_ADDR
// uc_side := 0 ;
93407: LD_ADDR_OWVAR 20
93411: PUSH
93412: LD_INT 0
93414: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93415: LD_ADDR_OWVAR 29
93419: PUSH
93420: LD_INT 12
93422: PUSH
93423: LD_INT 12
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: ST_TO_ADDR
// hc_agressivity := 20 ;
93430: LD_ADDR_OWVAR 35
93434: PUSH
93435: LD_INT 20
93437: ST_TO_ADDR
// hc_class := class_tiger ;
93438: LD_ADDR_OWVAR 28
93442: PUSH
93443: LD_INT 14
93445: ST_TO_ADDR
// hc_gallery :=  ;
93446: LD_ADDR_OWVAR 33
93450: PUSH
93451: LD_STRING 
93453: ST_TO_ADDR
// hc_name :=  ;
93454: LD_ADDR_OWVAR 26
93458: PUSH
93459: LD_STRING 
93461: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93462: CALL_OW 44
93466: PPUSH
93467: LD_INT 0
93469: PPUSH
93470: CALL_OW 51
// end ;
93474: GO 93396
93476: POP
93477: POP
// end ;
93478: PPOPN 1
93480: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93481: LD_EXP 130
93485: PUSH
93486: LD_EXP 150
93490: AND
93491: IFFALSE 93500
93493: GO 93495
93495: DISABLE
// StreamSibBomb ;
93496: CALL 93501 0 0
93500: END
// export function StreamSibBomb ; var i , x , y ; begin
93501: LD_INT 0
93503: PPUSH
93504: PPUSH
93505: PPUSH
93506: PPUSH
// result := false ;
93507: LD_ADDR_VAR 0 1
93511: PUSH
93512: LD_INT 0
93514: ST_TO_ADDR
// for i := 1 to 16 do
93515: LD_ADDR_VAR 0 2
93519: PUSH
93520: DOUBLE
93521: LD_INT 1
93523: DEC
93524: ST_TO_ADDR
93525: LD_INT 16
93527: PUSH
93528: FOR_TO
93529: IFFALSE 93728
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93531: LD_ADDR_VAR 0 3
93535: PUSH
93536: LD_INT 10
93538: PUSH
93539: LD_INT 20
93541: PUSH
93542: LD_INT 30
93544: PUSH
93545: LD_INT 40
93547: PUSH
93548: LD_INT 50
93550: PUSH
93551: LD_INT 60
93553: PUSH
93554: LD_INT 70
93556: PUSH
93557: LD_INT 80
93559: PUSH
93560: LD_INT 90
93562: PUSH
93563: LD_INT 100
93565: PUSH
93566: LD_INT 110
93568: PUSH
93569: LD_INT 120
93571: PUSH
93572: LD_INT 130
93574: PUSH
93575: LD_INT 140
93577: PUSH
93578: LD_INT 150
93580: PUSH
93581: EMPTY
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: PUSH
93598: LD_INT 1
93600: PPUSH
93601: LD_INT 15
93603: PPUSH
93604: CALL_OW 12
93608: ARRAY
93609: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93610: LD_ADDR_VAR 0 4
93614: PUSH
93615: LD_INT 10
93617: PUSH
93618: LD_INT 20
93620: PUSH
93621: LD_INT 30
93623: PUSH
93624: LD_INT 40
93626: PUSH
93627: LD_INT 50
93629: PUSH
93630: LD_INT 60
93632: PUSH
93633: LD_INT 70
93635: PUSH
93636: LD_INT 80
93638: PUSH
93639: LD_INT 90
93641: PUSH
93642: LD_INT 100
93644: PUSH
93645: LD_INT 110
93647: PUSH
93648: LD_INT 120
93650: PUSH
93651: LD_INT 130
93653: PUSH
93654: LD_INT 140
93656: PUSH
93657: LD_INT 150
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: LIST
93664: LIST
93665: LIST
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 1
93679: PPUSH
93680: LD_INT 15
93682: PPUSH
93683: CALL_OW 12
93687: ARRAY
93688: ST_TO_ADDR
// if ValidHex ( x , y ) then
93689: LD_VAR 0 3
93693: PPUSH
93694: LD_VAR 0 4
93698: PPUSH
93699: CALL_OW 488
93703: IFFALSE 93726
// begin result := [ x , y ] ;
93705: LD_ADDR_VAR 0 1
93709: PUSH
93710: LD_VAR 0 3
93714: PUSH
93715: LD_VAR 0 4
93719: PUSH
93720: EMPTY
93721: LIST
93722: LIST
93723: ST_TO_ADDR
// break ;
93724: GO 93728
// end ; end ;
93726: GO 93528
93728: POP
93729: POP
// if result then
93730: LD_VAR 0 1
93734: IFFALSE 93794
// begin ToLua ( playSibBomb() ) ;
93736: LD_STRING playSibBomb()
93738: PPUSH
93739: CALL_OW 559
// wait ( 0 0$14 ) ;
93743: LD_INT 490
93745: PPUSH
93746: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93750: LD_VAR 0 1
93754: PUSH
93755: LD_INT 1
93757: ARRAY
93758: PPUSH
93759: LD_VAR 0 1
93763: PUSH
93764: LD_INT 2
93766: ARRAY
93767: PPUSH
93768: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93772: LD_VAR 0 1
93776: PUSH
93777: LD_INT 1
93779: ARRAY
93780: PPUSH
93781: LD_VAR 0 1
93785: PUSH
93786: LD_INT 2
93788: ARRAY
93789: PPUSH
93790: CALL_OW 429
// end ; end ;
93794: LD_VAR 0 1
93798: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93799: LD_EXP 130
93803: PUSH
93804: LD_EXP 152
93808: AND
93809: IFFALSE 93821
93811: GO 93813
93813: DISABLE
// YouLost (  ) ;
93814: LD_STRING 
93816: PPUSH
93817: CALL_OW 104
93821: END
// every 0 0$1 trigger StreamModeActive and sFog do
93822: LD_EXP 130
93826: PUSH
93827: LD_EXP 151
93831: AND
93832: IFFALSE 93846
93834: GO 93836
93836: DISABLE
// FogOff ( your_side ) ;
93837: LD_OWVAR 2
93841: PPUSH
93842: CALL_OW 344
93846: END
// every 0 0$1 trigger StreamModeActive and sSun do
93847: LD_EXP 130
93851: PUSH
93852: LD_EXP 153
93856: AND
93857: IFFALSE 93885
93859: GO 93861
93861: DISABLE
// begin solar_recharge_percent := 0 ;
93862: LD_ADDR_OWVAR 79
93866: PUSH
93867: LD_INT 0
93869: ST_TO_ADDR
// wait ( 5 5$00 ) ;
93870: LD_INT 10500
93872: PPUSH
93873: CALL_OW 67
// solar_recharge_percent := 100 ;
93877: LD_ADDR_OWVAR 79
93881: PUSH
93882: LD_INT 100
93884: ST_TO_ADDR
// end ;
93885: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
93886: LD_EXP 130
93890: PUSH
93891: LD_EXP 154
93895: AND
93896: IFFALSE 94135
93898: GO 93900
93900: DISABLE
93901: LD_INT 0
93903: PPUSH
93904: PPUSH
93905: PPUSH
// begin tmp := [ ] ;
93906: LD_ADDR_VAR 0 3
93910: PUSH
93911: EMPTY
93912: ST_TO_ADDR
// for i := 1 to 6 do
93913: LD_ADDR_VAR 0 1
93917: PUSH
93918: DOUBLE
93919: LD_INT 1
93921: DEC
93922: ST_TO_ADDR
93923: LD_INT 6
93925: PUSH
93926: FOR_TO
93927: IFFALSE 94032
// begin uc_nation := nation_nature ;
93929: LD_ADDR_OWVAR 21
93933: PUSH
93934: LD_INT 0
93936: ST_TO_ADDR
// uc_side := 0 ;
93937: LD_ADDR_OWVAR 20
93941: PUSH
93942: LD_INT 0
93944: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93945: LD_ADDR_OWVAR 29
93949: PUSH
93950: LD_INT 12
93952: PUSH
93953: LD_INT 12
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: ST_TO_ADDR
// hc_agressivity := 20 ;
93960: LD_ADDR_OWVAR 35
93964: PUSH
93965: LD_INT 20
93967: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
93968: LD_ADDR_OWVAR 28
93972: PUSH
93973: LD_INT 17
93975: ST_TO_ADDR
// hc_gallery :=  ;
93976: LD_ADDR_OWVAR 33
93980: PUSH
93981: LD_STRING 
93983: ST_TO_ADDR
// hc_name :=  ;
93984: LD_ADDR_OWVAR 26
93988: PUSH
93989: LD_STRING 
93991: ST_TO_ADDR
// un := CreateHuman ;
93992: LD_ADDR_VAR 0 2
93996: PUSH
93997: CALL_OW 44
94001: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94002: LD_VAR 0 2
94006: PPUSH
94007: LD_INT 1
94009: PPUSH
94010: CALL_OW 51
// tmp := tmp ^ un ;
94014: LD_ADDR_VAR 0 3
94018: PUSH
94019: LD_VAR 0 3
94023: PUSH
94024: LD_VAR 0 2
94028: ADD
94029: ST_TO_ADDR
// end ;
94030: GO 93926
94032: POP
94033: POP
// repeat wait ( 0 0$1 ) ;
94034: LD_INT 35
94036: PPUSH
94037: CALL_OW 67
// for un in tmp do
94041: LD_ADDR_VAR 0 2
94045: PUSH
94046: LD_VAR 0 3
94050: PUSH
94051: FOR_IN
94052: IFFALSE 94126
// begin if IsDead ( un ) then
94054: LD_VAR 0 2
94058: PPUSH
94059: CALL_OW 301
94063: IFFALSE 94083
// begin tmp := tmp diff un ;
94065: LD_ADDR_VAR 0 3
94069: PUSH
94070: LD_VAR 0 3
94074: PUSH
94075: LD_VAR 0 2
94079: DIFF
94080: ST_TO_ADDR
// continue ;
94081: GO 94051
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94083: LD_VAR 0 2
94087: PPUSH
94088: LD_INT 3
94090: PUSH
94091: LD_INT 22
94093: PUSH
94094: LD_INT 0
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: PPUSH
94105: CALL_OW 69
94109: PPUSH
94110: LD_VAR 0 2
94114: PPUSH
94115: CALL_OW 74
94119: PPUSH
94120: CALL_OW 115
// end ;
94124: GO 94051
94126: POP
94127: POP
// until not tmp ;
94128: LD_VAR 0 3
94132: NOT
94133: IFFALSE 94034
// end ;
94135: PPOPN 3
94137: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94138: LD_EXP 130
94142: PUSH
94143: LD_EXP 155
94147: AND
94148: IFFALSE 94202
94150: GO 94152
94152: DISABLE
// begin ToLua ( displayTroll(); ) ;
94153: LD_STRING displayTroll();
94155: PPUSH
94156: CALL_OW 559
// wait ( 3 3$00 ) ;
94160: LD_INT 6300
94162: PPUSH
94163: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94167: LD_STRING hideTroll();
94169: PPUSH
94170: CALL_OW 559
// wait ( 1 1$00 ) ;
94174: LD_INT 2100
94176: PPUSH
94177: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94181: LD_STRING displayTroll();
94183: PPUSH
94184: CALL_OW 559
// wait ( 1 1$00 ) ;
94188: LD_INT 2100
94190: PPUSH
94191: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94195: LD_STRING hideTroll();
94197: PPUSH
94198: CALL_OW 559
// end ;
94202: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94203: LD_EXP 130
94207: PUSH
94208: LD_EXP 156
94212: AND
94213: IFFALSE 94276
94215: GO 94217
94217: DISABLE
94218: LD_INT 0
94220: PPUSH
// begin p := 0 ;
94221: LD_ADDR_VAR 0 1
94225: PUSH
94226: LD_INT 0
94228: ST_TO_ADDR
// repeat game_speed := 1 ;
94229: LD_ADDR_OWVAR 65
94233: PUSH
94234: LD_INT 1
94236: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94237: LD_INT 35
94239: PPUSH
94240: CALL_OW 67
// p := p + 1 ;
94244: LD_ADDR_VAR 0 1
94248: PUSH
94249: LD_VAR 0 1
94253: PUSH
94254: LD_INT 1
94256: PLUS
94257: ST_TO_ADDR
// until p >= 60 ;
94258: LD_VAR 0 1
94262: PUSH
94263: LD_INT 60
94265: GREATEREQUAL
94266: IFFALSE 94229
// game_speed := 4 ;
94268: LD_ADDR_OWVAR 65
94272: PUSH
94273: LD_INT 4
94275: ST_TO_ADDR
// end ;
94276: PPOPN 1
94278: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94279: LD_EXP 130
94283: PUSH
94284: LD_EXP 157
94288: AND
94289: IFFALSE 94435
94291: GO 94293
94293: DISABLE
94294: LD_INT 0
94296: PPUSH
94297: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94298: LD_ADDR_VAR 0 1
94302: PUSH
94303: LD_INT 22
94305: PUSH
94306: LD_OWVAR 2
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: PUSH
94315: LD_INT 2
94317: PUSH
94318: LD_INT 30
94320: PUSH
94321: LD_INT 0
94323: PUSH
94324: EMPTY
94325: LIST
94326: LIST
94327: PUSH
94328: LD_INT 30
94330: PUSH
94331: LD_INT 1
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: LIST
94342: PUSH
94343: EMPTY
94344: LIST
94345: LIST
94346: PPUSH
94347: CALL_OW 69
94351: ST_TO_ADDR
// if not depot then
94352: LD_VAR 0 1
94356: NOT
94357: IFFALSE 94361
// exit ;
94359: GO 94435
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94361: LD_ADDR_VAR 0 2
94365: PUSH
94366: LD_VAR 0 1
94370: PUSH
94371: LD_INT 1
94373: PPUSH
94374: LD_VAR 0 1
94378: PPUSH
94379: CALL_OW 12
94383: ARRAY
94384: PPUSH
94385: CALL_OW 274
94389: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94390: LD_VAR 0 2
94394: PPUSH
94395: LD_INT 1
94397: PPUSH
94398: LD_INT 0
94400: PPUSH
94401: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94405: LD_VAR 0 2
94409: PPUSH
94410: LD_INT 2
94412: PPUSH
94413: LD_INT 0
94415: PPUSH
94416: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94420: LD_VAR 0 2
94424: PPUSH
94425: LD_INT 3
94427: PPUSH
94428: LD_INT 0
94430: PPUSH
94431: CALL_OW 277
// end ;
94435: PPOPN 2
94437: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94438: LD_EXP 130
94442: PUSH
94443: LD_EXP 158
94447: AND
94448: IFFALSE 94545
94450: GO 94452
94452: DISABLE
94453: LD_INT 0
94455: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94456: LD_ADDR_VAR 0 1
94460: PUSH
94461: LD_INT 22
94463: PUSH
94464: LD_OWVAR 2
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 21
94475: PUSH
94476: LD_INT 1
94478: PUSH
94479: EMPTY
94480: LIST
94481: LIST
94482: PUSH
94483: LD_INT 3
94485: PUSH
94486: LD_INT 23
94488: PUSH
94489: LD_INT 0
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: LIST
94504: PPUSH
94505: CALL_OW 69
94509: ST_TO_ADDR
// if not tmp then
94510: LD_VAR 0 1
94514: NOT
94515: IFFALSE 94519
// exit ;
94517: GO 94545
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94519: LD_VAR 0 1
94523: PUSH
94524: LD_INT 1
94526: PPUSH
94527: LD_VAR 0 1
94531: PPUSH
94532: CALL_OW 12
94536: ARRAY
94537: PPUSH
94538: LD_INT 200
94540: PPUSH
94541: CALL_OW 234
// end ;
94545: PPOPN 1
94547: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94548: LD_EXP 130
94552: PUSH
94553: LD_EXP 159
94557: AND
94558: IFFALSE 94637
94560: GO 94562
94562: DISABLE
94563: LD_INT 0
94565: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94566: LD_ADDR_VAR 0 1
94570: PUSH
94571: LD_INT 22
94573: PUSH
94574: LD_OWVAR 2
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 21
94585: PUSH
94586: LD_INT 2
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: PPUSH
94597: CALL_OW 69
94601: ST_TO_ADDR
// if not tmp then
94602: LD_VAR 0 1
94606: NOT
94607: IFFALSE 94611
// exit ;
94609: GO 94637
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94611: LD_VAR 0 1
94615: PUSH
94616: LD_INT 1
94618: PPUSH
94619: LD_VAR 0 1
94623: PPUSH
94624: CALL_OW 12
94628: ARRAY
94629: PPUSH
94630: LD_INT 60
94632: PPUSH
94633: CALL_OW 234
// end ;
94637: PPOPN 1
94639: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94640: LD_EXP 130
94644: PUSH
94645: LD_EXP 160
94649: AND
94650: IFFALSE 94749
94652: GO 94654
94654: DISABLE
94655: LD_INT 0
94657: PPUSH
94658: PPUSH
// begin enable ;
94659: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94660: LD_ADDR_VAR 0 1
94664: PUSH
94665: LD_INT 22
94667: PUSH
94668: LD_OWVAR 2
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 61
94679: PUSH
94680: EMPTY
94681: LIST
94682: PUSH
94683: LD_INT 33
94685: PUSH
94686: LD_INT 2
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: EMPTY
94694: LIST
94695: LIST
94696: LIST
94697: PPUSH
94698: CALL_OW 69
94702: ST_TO_ADDR
// if not tmp then
94703: LD_VAR 0 1
94707: NOT
94708: IFFALSE 94712
// exit ;
94710: GO 94749
// for i in tmp do
94712: LD_ADDR_VAR 0 2
94716: PUSH
94717: LD_VAR 0 1
94721: PUSH
94722: FOR_IN
94723: IFFALSE 94747
// if IsControledBy ( i ) then
94725: LD_VAR 0 2
94729: PPUSH
94730: CALL_OW 312
94734: IFFALSE 94745
// ComUnlink ( i ) ;
94736: LD_VAR 0 2
94740: PPUSH
94741: CALL_OW 136
94745: GO 94722
94747: POP
94748: POP
// end ;
94749: PPOPN 2
94751: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94752: LD_EXP 130
94756: PUSH
94757: LD_EXP 161
94761: AND
94762: IFFALSE 94902
94764: GO 94766
94766: DISABLE
94767: LD_INT 0
94769: PPUSH
94770: PPUSH
// begin ToLua ( displayPowell(); ) ;
94771: LD_STRING displayPowell();
94773: PPUSH
94774: CALL_OW 559
// uc_side := 0 ;
94778: LD_ADDR_OWVAR 20
94782: PUSH
94783: LD_INT 0
94785: ST_TO_ADDR
// uc_nation := 2 ;
94786: LD_ADDR_OWVAR 21
94790: PUSH
94791: LD_INT 2
94793: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94794: LD_ADDR_OWVAR 37
94798: PUSH
94799: LD_INT 14
94801: ST_TO_ADDR
// vc_engine := engine_siberite ;
94802: LD_ADDR_OWVAR 39
94806: PUSH
94807: LD_INT 3
94809: ST_TO_ADDR
// vc_control := control_apeman ;
94810: LD_ADDR_OWVAR 38
94814: PUSH
94815: LD_INT 5
94817: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94818: LD_ADDR_OWVAR 40
94822: PUSH
94823: LD_INT 29
94825: ST_TO_ADDR
// un := CreateVehicle ;
94826: LD_ADDR_VAR 0 2
94830: PUSH
94831: CALL_OW 45
94835: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94836: LD_VAR 0 2
94840: PPUSH
94841: LD_INT 1
94843: PPUSH
94844: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94848: LD_INT 35
94850: PPUSH
94851: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94855: LD_VAR 0 2
94859: PPUSH
94860: LD_INT 22
94862: PUSH
94863: LD_OWVAR 2
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: PPUSH
94872: CALL_OW 69
94876: PPUSH
94877: LD_VAR 0 2
94881: PPUSH
94882: CALL_OW 74
94886: PPUSH
94887: CALL_OW 115
// until IsDead ( un ) ;
94891: LD_VAR 0 2
94895: PPUSH
94896: CALL_OW 301
94900: IFFALSE 94848
// end ;
94902: PPOPN 2
94904: END
// every 0 0$1 trigger StreamModeActive and sStu do
94905: LD_EXP 130
94909: PUSH
94910: LD_EXP 169
94914: AND
94915: IFFALSE 94931
94917: GO 94919
94919: DISABLE
// begin ToLua ( displayStucuk(); ) ;
94920: LD_STRING displayStucuk();
94922: PPUSH
94923: CALL_OW 559
// ResetFog ;
94927: CALL_OW 335
// end ;
94931: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
94932: LD_EXP 130
94936: PUSH
94937: LD_EXP 162
94941: AND
94942: IFFALSE 95083
94944: GO 94946
94946: DISABLE
94947: LD_INT 0
94949: PPUSH
94950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94951: LD_ADDR_VAR 0 2
94955: PUSH
94956: LD_INT 22
94958: PUSH
94959: LD_OWVAR 2
94963: PUSH
94964: EMPTY
94965: LIST
94966: LIST
94967: PUSH
94968: LD_INT 21
94970: PUSH
94971: LD_INT 1
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PPUSH
94982: CALL_OW 69
94986: ST_TO_ADDR
// if not tmp then
94987: LD_VAR 0 2
94991: NOT
94992: IFFALSE 94996
// exit ;
94994: GO 95083
// un := tmp [ rand ( 1 , tmp ) ] ;
94996: LD_ADDR_VAR 0 1
95000: PUSH
95001: LD_VAR 0 2
95005: PUSH
95006: LD_INT 1
95008: PPUSH
95009: LD_VAR 0 2
95013: PPUSH
95014: CALL_OW 12
95018: ARRAY
95019: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95020: LD_VAR 0 1
95024: PPUSH
95025: LD_INT 0
95027: PPUSH
95028: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95032: LD_VAR 0 1
95036: PPUSH
95037: LD_OWVAR 3
95041: PUSH
95042: LD_VAR 0 1
95046: DIFF
95047: PPUSH
95048: LD_VAR 0 1
95052: PPUSH
95053: CALL_OW 74
95057: PPUSH
95058: CALL_OW 115
// wait ( 0 0$20 ) ;
95062: LD_INT 700
95064: PPUSH
95065: CALL_OW 67
// SetSide ( un , your_side ) ;
95069: LD_VAR 0 1
95073: PPUSH
95074: LD_OWVAR 2
95078: PPUSH
95079: CALL_OW 235
// end ;
95083: PPOPN 2
95085: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95086: LD_EXP 130
95090: PUSH
95091: LD_EXP 163
95095: AND
95096: IFFALSE 95202
95098: GO 95100
95100: DISABLE
95101: LD_INT 0
95103: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95104: LD_ADDR_VAR 0 1
95108: PUSH
95109: LD_INT 22
95111: PUSH
95112: LD_OWVAR 2
95116: PUSH
95117: EMPTY
95118: LIST
95119: LIST
95120: PUSH
95121: LD_INT 2
95123: PUSH
95124: LD_INT 30
95126: PUSH
95127: LD_INT 0
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: PUSH
95134: LD_INT 30
95136: PUSH
95137: LD_INT 1
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: EMPTY
95145: LIST
95146: LIST
95147: LIST
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PPUSH
95153: CALL_OW 69
95157: ST_TO_ADDR
// if not depot then
95158: LD_VAR 0 1
95162: NOT
95163: IFFALSE 95167
// exit ;
95165: GO 95202
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95167: LD_VAR 0 1
95171: PUSH
95172: LD_INT 1
95174: ARRAY
95175: PPUSH
95176: CALL_OW 250
95180: PPUSH
95181: LD_VAR 0 1
95185: PUSH
95186: LD_INT 1
95188: ARRAY
95189: PPUSH
95190: CALL_OW 251
95194: PPUSH
95195: LD_INT 70
95197: PPUSH
95198: CALL_OW 495
// end ;
95202: PPOPN 1
95204: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95205: LD_EXP 130
95209: PUSH
95210: LD_EXP 164
95214: AND
95215: IFFALSE 95426
95217: GO 95219
95219: DISABLE
95220: LD_INT 0
95222: PPUSH
95223: PPUSH
95224: PPUSH
95225: PPUSH
95226: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95227: LD_ADDR_VAR 0 5
95231: PUSH
95232: LD_INT 22
95234: PUSH
95235: LD_OWVAR 2
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 21
95246: PUSH
95247: LD_INT 1
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: PPUSH
95258: CALL_OW 69
95262: ST_TO_ADDR
// if not tmp then
95263: LD_VAR 0 5
95267: NOT
95268: IFFALSE 95272
// exit ;
95270: GO 95426
// for i in tmp do
95272: LD_ADDR_VAR 0 1
95276: PUSH
95277: LD_VAR 0 5
95281: PUSH
95282: FOR_IN
95283: IFFALSE 95424
// begin d := rand ( 0 , 5 ) ;
95285: LD_ADDR_VAR 0 4
95289: PUSH
95290: LD_INT 0
95292: PPUSH
95293: LD_INT 5
95295: PPUSH
95296: CALL_OW 12
95300: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95301: LD_ADDR_VAR 0 2
95305: PUSH
95306: LD_VAR 0 1
95310: PPUSH
95311: CALL_OW 250
95315: PPUSH
95316: LD_VAR 0 4
95320: PPUSH
95321: LD_INT 3
95323: PPUSH
95324: LD_INT 12
95326: PPUSH
95327: CALL_OW 12
95331: PPUSH
95332: CALL_OW 272
95336: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95337: LD_ADDR_VAR 0 3
95341: PUSH
95342: LD_VAR 0 1
95346: PPUSH
95347: CALL_OW 251
95351: PPUSH
95352: LD_VAR 0 4
95356: PPUSH
95357: LD_INT 3
95359: PPUSH
95360: LD_INT 12
95362: PPUSH
95363: CALL_OW 12
95367: PPUSH
95368: CALL_OW 273
95372: ST_TO_ADDR
// if ValidHex ( x , y ) then
95373: LD_VAR 0 2
95377: PPUSH
95378: LD_VAR 0 3
95382: PPUSH
95383: CALL_OW 488
95387: IFFALSE 95422
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95389: LD_VAR 0 1
95393: PPUSH
95394: LD_VAR 0 2
95398: PPUSH
95399: LD_VAR 0 3
95403: PPUSH
95404: LD_INT 3
95406: PPUSH
95407: LD_INT 6
95409: PPUSH
95410: CALL_OW 12
95414: PPUSH
95415: LD_INT 1
95417: PPUSH
95418: CALL_OW 483
// end ;
95422: GO 95282
95424: POP
95425: POP
// end ;
95426: PPOPN 5
95428: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95429: LD_EXP 130
95433: PUSH
95434: LD_EXP 165
95438: AND
95439: IFFALSE 95533
95441: GO 95443
95443: DISABLE
95444: LD_INT 0
95446: PPUSH
95447: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95448: LD_ADDR_VAR 0 2
95452: PUSH
95453: LD_INT 22
95455: PUSH
95456: LD_OWVAR 2
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 32
95467: PUSH
95468: LD_INT 1
95470: PUSH
95471: EMPTY
95472: LIST
95473: LIST
95474: PUSH
95475: LD_INT 21
95477: PUSH
95478: LD_INT 2
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: PUSH
95485: EMPTY
95486: LIST
95487: LIST
95488: LIST
95489: PPUSH
95490: CALL_OW 69
95494: ST_TO_ADDR
// if not tmp then
95495: LD_VAR 0 2
95499: NOT
95500: IFFALSE 95504
// exit ;
95502: GO 95533
// for i in tmp do
95504: LD_ADDR_VAR 0 1
95508: PUSH
95509: LD_VAR 0 2
95513: PUSH
95514: FOR_IN
95515: IFFALSE 95531
// SetFuel ( i , 0 ) ;
95517: LD_VAR 0 1
95521: PPUSH
95522: LD_INT 0
95524: PPUSH
95525: CALL_OW 240
95529: GO 95514
95531: POP
95532: POP
// end ;
95533: PPOPN 2
95535: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95536: LD_EXP 130
95540: PUSH
95541: LD_EXP 166
95545: AND
95546: IFFALSE 95612
95548: GO 95550
95550: DISABLE
95551: LD_INT 0
95553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95554: LD_ADDR_VAR 0 1
95558: PUSH
95559: LD_INT 22
95561: PUSH
95562: LD_OWVAR 2
95566: PUSH
95567: EMPTY
95568: LIST
95569: LIST
95570: PUSH
95571: LD_INT 30
95573: PUSH
95574: LD_INT 29
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: PPUSH
95585: CALL_OW 69
95589: ST_TO_ADDR
// if not tmp then
95590: LD_VAR 0 1
95594: NOT
95595: IFFALSE 95599
// exit ;
95597: GO 95612
// DestroyUnit ( tmp [ 1 ] ) ;
95599: LD_VAR 0 1
95603: PUSH
95604: LD_INT 1
95606: ARRAY
95607: PPUSH
95608: CALL_OW 65
// end ;
95612: PPOPN 1
95614: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95615: LD_EXP 130
95619: PUSH
95620: LD_EXP 168
95624: AND
95625: IFFALSE 95754
95627: GO 95629
95629: DISABLE
95630: LD_INT 0
95632: PPUSH
// begin uc_side := 0 ;
95633: LD_ADDR_OWVAR 20
95637: PUSH
95638: LD_INT 0
95640: ST_TO_ADDR
// uc_nation := nation_arabian ;
95641: LD_ADDR_OWVAR 21
95645: PUSH
95646: LD_INT 2
95648: ST_TO_ADDR
// hc_gallery :=  ;
95649: LD_ADDR_OWVAR 33
95653: PUSH
95654: LD_STRING 
95656: ST_TO_ADDR
// hc_name :=  ;
95657: LD_ADDR_OWVAR 26
95661: PUSH
95662: LD_STRING 
95664: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95665: LD_INT 1
95667: PPUSH
95668: LD_INT 11
95670: PPUSH
95671: LD_INT 10
95673: PPUSH
95674: CALL_OW 380
// un := CreateHuman ;
95678: LD_ADDR_VAR 0 1
95682: PUSH
95683: CALL_OW 44
95687: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95688: LD_VAR 0 1
95692: PPUSH
95693: LD_INT 1
95695: PPUSH
95696: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95700: LD_INT 35
95702: PPUSH
95703: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95707: LD_VAR 0 1
95711: PPUSH
95712: LD_INT 22
95714: PUSH
95715: LD_OWVAR 2
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PPUSH
95724: CALL_OW 69
95728: PPUSH
95729: LD_VAR 0 1
95733: PPUSH
95734: CALL_OW 74
95738: PPUSH
95739: CALL_OW 115
// until IsDead ( un ) ;
95743: LD_VAR 0 1
95747: PPUSH
95748: CALL_OW 301
95752: IFFALSE 95700
// end ;
95754: PPOPN 1
95756: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95757: LD_EXP 130
95761: PUSH
95762: LD_EXP 170
95766: AND
95767: IFFALSE 95779
95769: GO 95771
95771: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95772: LD_STRING earthquake(getX(game), 0, 32)
95774: PPUSH
95775: CALL_OW 559
95779: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95780: LD_EXP 130
95784: PUSH
95785: LD_EXP 171
95789: AND
95790: IFFALSE 95881
95792: GO 95794
95794: DISABLE
95795: LD_INT 0
95797: PPUSH
// begin enable ;
95798: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95799: LD_ADDR_VAR 0 1
95803: PUSH
95804: LD_INT 22
95806: PUSH
95807: LD_OWVAR 2
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: LD_INT 21
95818: PUSH
95819: LD_INT 2
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 33
95828: PUSH
95829: LD_INT 3
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: LIST
95840: PPUSH
95841: CALL_OW 69
95845: ST_TO_ADDR
// if not tmp then
95846: LD_VAR 0 1
95850: NOT
95851: IFFALSE 95855
// exit ;
95853: GO 95881
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95855: LD_VAR 0 1
95859: PUSH
95860: LD_INT 1
95862: PPUSH
95863: LD_VAR 0 1
95867: PPUSH
95868: CALL_OW 12
95872: ARRAY
95873: PPUSH
95874: LD_INT 1
95876: PPUSH
95877: CALL_OW 234
// end ;
95881: PPOPN 1
95883: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
95884: LD_EXP 130
95888: PUSH
95889: LD_EXP 172
95893: AND
95894: IFFALSE 96035
95896: GO 95898
95898: DISABLE
95899: LD_INT 0
95901: PPUSH
95902: PPUSH
95903: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95904: LD_ADDR_VAR 0 3
95908: PUSH
95909: LD_INT 22
95911: PUSH
95912: LD_OWVAR 2
95916: PUSH
95917: EMPTY
95918: LIST
95919: LIST
95920: PUSH
95921: LD_INT 25
95923: PUSH
95924: LD_INT 1
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: PPUSH
95935: CALL_OW 69
95939: ST_TO_ADDR
// if not tmp then
95940: LD_VAR 0 3
95944: NOT
95945: IFFALSE 95949
// exit ;
95947: GO 96035
// un := tmp [ rand ( 1 , tmp ) ] ;
95949: LD_ADDR_VAR 0 2
95953: PUSH
95954: LD_VAR 0 3
95958: PUSH
95959: LD_INT 1
95961: PPUSH
95962: LD_VAR 0 3
95966: PPUSH
95967: CALL_OW 12
95971: ARRAY
95972: ST_TO_ADDR
// if Crawls ( un ) then
95973: LD_VAR 0 2
95977: PPUSH
95978: CALL_OW 318
95982: IFFALSE 95993
// ComWalk ( un ) ;
95984: LD_VAR 0 2
95988: PPUSH
95989: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
95993: LD_VAR 0 2
95997: PPUSH
95998: LD_INT 9
96000: PPUSH
96001: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96005: LD_INT 28
96007: PPUSH
96008: LD_OWVAR 2
96012: PPUSH
96013: LD_INT 2
96015: PPUSH
96016: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96020: LD_INT 29
96022: PPUSH
96023: LD_OWVAR 2
96027: PPUSH
96028: LD_INT 2
96030: PPUSH
96031: CALL_OW 322
// end ;
96035: PPOPN 3
96037: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96038: LD_EXP 130
96042: PUSH
96043: LD_EXP 173
96047: AND
96048: IFFALSE 96159
96050: GO 96052
96052: DISABLE
96053: LD_INT 0
96055: PPUSH
96056: PPUSH
96057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96058: LD_ADDR_VAR 0 3
96062: PUSH
96063: LD_INT 22
96065: PUSH
96066: LD_OWVAR 2
96070: PUSH
96071: EMPTY
96072: LIST
96073: LIST
96074: PUSH
96075: LD_INT 25
96077: PUSH
96078: LD_INT 1
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: PPUSH
96089: CALL_OW 69
96093: ST_TO_ADDR
// if not tmp then
96094: LD_VAR 0 3
96098: NOT
96099: IFFALSE 96103
// exit ;
96101: GO 96159
// un := tmp [ rand ( 1 , tmp ) ] ;
96103: LD_ADDR_VAR 0 2
96107: PUSH
96108: LD_VAR 0 3
96112: PUSH
96113: LD_INT 1
96115: PPUSH
96116: LD_VAR 0 3
96120: PPUSH
96121: CALL_OW 12
96125: ARRAY
96126: ST_TO_ADDR
// if Crawls ( un ) then
96127: LD_VAR 0 2
96131: PPUSH
96132: CALL_OW 318
96136: IFFALSE 96147
// ComWalk ( un ) ;
96138: LD_VAR 0 2
96142: PPUSH
96143: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96147: LD_VAR 0 2
96151: PPUSH
96152: LD_INT 8
96154: PPUSH
96155: CALL_OW 336
// end ;
96159: PPOPN 3
96161: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96162: LD_EXP 130
96166: PUSH
96167: LD_EXP 174
96171: AND
96172: IFFALSE 96316
96174: GO 96176
96176: DISABLE
96177: LD_INT 0
96179: PPUSH
96180: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96181: LD_ADDR_VAR 0 2
96185: PUSH
96186: LD_INT 22
96188: PUSH
96189: LD_OWVAR 2
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: PUSH
96198: LD_INT 21
96200: PUSH
96201: LD_INT 2
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 2
96210: PUSH
96211: LD_INT 34
96213: PUSH
96214: LD_INT 12
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 34
96223: PUSH
96224: LD_INT 51
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 34
96233: PUSH
96234: LD_INT 32
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: EMPTY
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: LIST
96251: PPUSH
96252: CALL_OW 69
96256: ST_TO_ADDR
// if not tmp then
96257: LD_VAR 0 2
96261: NOT
96262: IFFALSE 96266
// exit ;
96264: GO 96316
// for i in tmp do
96266: LD_ADDR_VAR 0 1
96270: PUSH
96271: LD_VAR 0 2
96275: PUSH
96276: FOR_IN
96277: IFFALSE 96314
// if GetCargo ( i , mat_artifact ) = 0 then
96279: LD_VAR 0 1
96283: PPUSH
96284: LD_INT 4
96286: PPUSH
96287: CALL_OW 289
96291: PUSH
96292: LD_INT 0
96294: EQUAL
96295: IFFALSE 96312
// SetCargo ( i , mat_siberit , 100 ) ;
96297: LD_VAR 0 1
96301: PPUSH
96302: LD_INT 3
96304: PPUSH
96305: LD_INT 100
96307: PPUSH
96308: CALL_OW 290
96312: GO 96276
96314: POP
96315: POP
// end ;
96316: PPOPN 2
96318: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96319: LD_EXP 130
96323: PUSH
96324: LD_EXP 175
96328: AND
96329: IFFALSE 96482
96331: GO 96333
96333: DISABLE
96334: LD_INT 0
96336: PPUSH
96337: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96338: LD_ADDR_VAR 0 2
96342: PUSH
96343: LD_INT 22
96345: PUSH
96346: LD_OWVAR 2
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: PPUSH
96355: CALL_OW 69
96359: ST_TO_ADDR
// if not tmp then
96360: LD_VAR 0 2
96364: NOT
96365: IFFALSE 96369
// exit ;
96367: GO 96482
// for i := 1 to 2 do
96369: LD_ADDR_VAR 0 1
96373: PUSH
96374: DOUBLE
96375: LD_INT 1
96377: DEC
96378: ST_TO_ADDR
96379: LD_INT 2
96381: PUSH
96382: FOR_TO
96383: IFFALSE 96480
// begin uc_side := your_side ;
96385: LD_ADDR_OWVAR 20
96389: PUSH
96390: LD_OWVAR 2
96394: ST_TO_ADDR
// uc_nation := nation_american ;
96395: LD_ADDR_OWVAR 21
96399: PUSH
96400: LD_INT 1
96402: ST_TO_ADDR
// vc_chassis := us_morphling ;
96403: LD_ADDR_OWVAR 37
96407: PUSH
96408: LD_INT 5
96410: ST_TO_ADDR
// vc_engine := engine_siberite ;
96411: LD_ADDR_OWVAR 39
96415: PUSH
96416: LD_INT 3
96418: ST_TO_ADDR
// vc_control := control_computer ;
96419: LD_ADDR_OWVAR 38
96423: PUSH
96424: LD_INT 3
96426: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96427: LD_ADDR_OWVAR 40
96431: PUSH
96432: LD_INT 10
96434: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
96435: CALL_OW 45
96439: PPUSH
96440: LD_VAR 0 2
96444: PUSH
96445: LD_INT 1
96447: ARRAY
96448: PPUSH
96449: CALL_OW 250
96453: PPUSH
96454: LD_VAR 0 2
96458: PUSH
96459: LD_INT 1
96461: ARRAY
96462: PPUSH
96463: CALL_OW 251
96467: PPUSH
96468: LD_INT 12
96470: PPUSH
96471: LD_INT 1
96473: PPUSH
96474: CALL_OW 50
// end ;
96478: GO 96382
96480: POP
96481: POP
// end ;
96482: PPOPN 2
96484: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96485: LD_EXP 130
96489: PUSH
96490: LD_EXP 176
96494: AND
96495: IFFALSE 96717
96497: GO 96499
96499: DISABLE
96500: LD_INT 0
96502: PPUSH
96503: PPUSH
96504: PPUSH
96505: PPUSH
96506: PPUSH
96507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96508: LD_ADDR_VAR 0 6
96512: PUSH
96513: LD_INT 22
96515: PUSH
96516: LD_OWVAR 2
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: PUSH
96525: LD_INT 21
96527: PUSH
96528: LD_INT 1
96530: PUSH
96531: EMPTY
96532: LIST
96533: LIST
96534: PUSH
96535: LD_INT 3
96537: PUSH
96538: LD_INT 23
96540: PUSH
96541: LD_INT 0
96543: PUSH
96544: EMPTY
96545: LIST
96546: LIST
96547: PUSH
96548: EMPTY
96549: LIST
96550: LIST
96551: PUSH
96552: EMPTY
96553: LIST
96554: LIST
96555: LIST
96556: PPUSH
96557: CALL_OW 69
96561: ST_TO_ADDR
// if not tmp then
96562: LD_VAR 0 6
96566: NOT
96567: IFFALSE 96571
// exit ;
96569: GO 96717
// s1 := rand ( 1 , 4 ) ;
96571: LD_ADDR_VAR 0 2
96575: PUSH
96576: LD_INT 1
96578: PPUSH
96579: LD_INT 4
96581: PPUSH
96582: CALL_OW 12
96586: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96587: LD_ADDR_VAR 0 4
96591: PUSH
96592: LD_VAR 0 6
96596: PUSH
96597: LD_INT 1
96599: ARRAY
96600: PPUSH
96601: LD_VAR 0 2
96605: PPUSH
96606: CALL_OW 259
96610: ST_TO_ADDR
// if s1 = 1 then
96611: LD_VAR 0 2
96615: PUSH
96616: LD_INT 1
96618: EQUAL
96619: IFFALSE 96639
// s2 := rand ( 2 , 4 ) else
96621: LD_ADDR_VAR 0 3
96625: PUSH
96626: LD_INT 2
96628: PPUSH
96629: LD_INT 4
96631: PPUSH
96632: CALL_OW 12
96636: ST_TO_ADDR
96637: GO 96647
// s2 := 1 ;
96639: LD_ADDR_VAR 0 3
96643: PUSH
96644: LD_INT 1
96646: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96647: LD_ADDR_VAR 0 5
96651: PUSH
96652: LD_VAR 0 6
96656: PUSH
96657: LD_INT 1
96659: ARRAY
96660: PPUSH
96661: LD_VAR 0 3
96665: PPUSH
96666: CALL_OW 259
96670: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96671: LD_VAR 0 6
96675: PUSH
96676: LD_INT 1
96678: ARRAY
96679: PPUSH
96680: LD_VAR 0 2
96684: PPUSH
96685: LD_VAR 0 5
96689: PPUSH
96690: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96694: LD_VAR 0 6
96698: PUSH
96699: LD_INT 1
96701: ARRAY
96702: PPUSH
96703: LD_VAR 0 3
96707: PPUSH
96708: LD_VAR 0 4
96712: PPUSH
96713: CALL_OW 237
// end ;
96717: PPOPN 6
96719: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96720: LD_EXP 130
96724: PUSH
96725: LD_EXP 177
96729: AND
96730: IFFALSE 96809
96732: GO 96734
96734: DISABLE
96735: LD_INT 0
96737: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96738: LD_ADDR_VAR 0 1
96742: PUSH
96743: LD_INT 22
96745: PUSH
96746: LD_OWVAR 2
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: LD_INT 30
96757: PUSH
96758: LD_INT 3
96760: PUSH
96761: EMPTY
96762: LIST
96763: LIST
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: PPUSH
96769: CALL_OW 69
96773: ST_TO_ADDR
// if not tmp then
96774: LD_VAR 0 1
96778: NOT
96779: IFFALSE 96783
// exit ;
96781: GO 96809
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96783: LD_VAR 0 1
96787: PUSH
96788: LD_INT 1
96790: PPUSH
96791: LD_VAR 0 1
96795: PPUSH
96796: CALL_OW 12
96800: ARRAY
96801: PPUSH
96802: LD_INT 1
96804: PPUSH
96805: CALL_OW 234
// end ;
96809: PPOPN 1
96811: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
96812: LD_EXP 130
96816: PUSH
96817: LD_EXP 178
96821: AND
96822: IFFALSE 96934
96824: GO 96826
96826: DISABLE
96827: LD_INT 0
96829: PPUSH
96830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
96831: LD_ADDR_VAR 0 2
96835: PUSH
96836: LD_INT 22
96838: PUSH
96839: LD_OWVAR 2
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PUSH
96848: LD_INT 2
96850: PUSH
96851: LD_INT 30
96853: PUSH
96854: LD_INT 27
96856: PUSH
96857: EMPTY
96858: LIST
96859: LIST
96860: PUSH
96861: LD_INT 30
96863: PUSH
96864: LD_INT 26
96866: PUSH
96867: EMPTY
96868: LIST
96869: LIST
96870: PUSH
96871: LD_INT 30
96873: PUSH
96874: LD_INT 28
96876: PUSH
96877: EMPTY
96878: LIST
96879: LIST
96880: PUSH
96881: EMPTY
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: PUSH
96887: EMPTY
96888: LIST
96889: LIST
96890: PPUSH
96891: CALL_OW 69
96895: ST_TO_ADDR
// if not tmp then
96896: LD_VAR 0 2
96900: NOT
96901: IFFALSE 96905
// exit ;
96903: GO 96934
// for i in tmp do
96905: LD_ADDR_VAR 0 1
96909: PUSH
96910: LD_VAR 0 2
96914: PUSH
96915: FOR_IN
96916: IFFALSE 96932
// SetLives ( i , 1 ) ;
96918: LD_VAR 0 1
96922: PPUSH
96923: LD_INT 1
96925: PPUSH
96926: CALL_OW 234
96930: GO 96915
96932: POP
96933: POP
// end ;
96934: PPOPN 2
96936: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
96937: LD_EXP 130
96941: PUSH
96942: LD_EXP 179
96946: AND
96947: IFFALSE 97221
96949: GO 96951
96951: DISABLE
96952: LD_INT 0
96954: PPUSH
96955: PPUSH
96956: PPUSH
// begin i := rand ( 1 , 7 ) ;
96957: LD_ADDR_VAR 0 1
96961: PUSH
96962: LD_INT 1
96964: PPUSH
96965: LD_INT 7
96967: PPUSH
96968: CALL_OW 12
96972: ST_TO_ADDR
// case i of 1 :
96973: LD_VAR 0 1
96977: PUSH
96978: LD_INT 1
96980: DOUBLE
96981: EQUAL
96982: IFTRUE 96986
96984: GO 96996
96986: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
96987: LD_STRING earthquake(getX(game), 0, 32)
96989: PPUSH
96990: CALL_OW 559
96994: GO 97221
96996: LD_INT 2
96998: DOUBLE
96999: EQUAL
97000: IFTRUE 97004
97002: GO 97018
97004: POP
// begin ToLua ( displayStucuk(); ) ;
97005: LD_STRING displayStucuk();
97007: PPUSH
97008: CALL_OW 559
// ResetFog ;
97012: CALL_OW 335
// end ; 3 :
97016: GO 97221
97018: LD_INT 3
97020: DOUBLE
97021: EQUAL
97022: IFTRUE 97026
97024: GO 97130
97026: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97027: LD_ADDR_VAR 0 2
97031: PUSH
97032: LD_INT 22
97034: PUSH
97035: LD_OWVAR 2
97039: PUSH
97040: EMPTY
97041: LIST
97042: LIST
97043: PUSH
97044: LD_INT 25
97046: PUSH
97047: LD_INT 1
97049: PUSH
97050: EMPTY
97051: LIST
97052: LIST
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PPUSH
97058: CALL_OW 69
97062: ST_TO_ADDR
// if not tmp then
97063: LD_VAR 0 2
97067: NOT
97068: IFFALSE 97072
// exit ;
97070: GO 97221
// un := tmp [ rand ( 1 , tmp ) ] ;
97072: LD_ADDR_VAR 0 3
97076: PUSH
97077: LD_VAR 0 2
97081: PUSH
97082: LD_INT 1
97084: PPUSH
97085: LD_VAR 0 2
97089: PPUSH
97090: CALL_OW 12
97094: ARRAY
97095: ST_TO_ADDR
// if Crawls ( un ) then
97096: LD_VAR 0 3
97100: PPUSH
97101: CALL_OW 318
97105: IFFALSE 97116
// ComWalk ( un ) ;
97107: LD_VAR 0 3
97111: PPUSH
97112: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97116: LD_VAR 0 3
97120: PPUSH
97121: LD_INT 8
97123: PPUSH
97124: CALL_OW 336
// end ; 4 :
97128: GO 97221
97130: LD_INT 4
97132: DOUBLE
97133: EQUAL
97134: IFTRUE 97138
97136: GO 97199
97138: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97139: LD_ADDR_VAR 0 2
97143: PUSH
97144: LD_INT 22
97146: PUSH
97147: LD_OWVAR 2
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: PUSH
97156: LD_INT 30
97158: PUSH
97159: LD_INT 29
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PPUSH
97170: CALL_OW 69
97174: ST_TO_ADDR
// if not tmp then
97175: LD_VAR 0 2
97179: NOT
97180: IFFALSE 97184
// exit ;
97182: GO 97221
// DestroyUnit ( tmp [ 1 ] ) ;
97184: LD_VAR 0 2
97188: PUSH
97189: LD_INT 1
97191: ARRAY
97192: PPUSH
97193: CALL_OW 65
// end ; 5 .. 7 :
97197: GO 97221
97199: LD_INT 5
97201: DOUBLE
97202: GREATEREQUAL
97203: IFFALSE 97211
97205: LD_INT 7
97207: DOUBLE
97208: LESSEQUAL
97209: IFTRUE 97213
97211: GO 97220
97213: POP
// StreamSibBomb ; end ;
97214: CALL 93501 0 0
97218: GO 97221
97220: POP
// end ;
97221: PPOPN 3
97223: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97224: LD_EXP 130
97228: PUSH
97229: LD_EXP 180
97233: AND
97234: IFFALSE 97390
97236: GO 97238
97238: DISABLE
97239: LD_INT 0
97241: PPUSH
97242: PPUSH
97243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97244: LD_ADDR_VAR 0 2
97248: PUSH
97249: LD_INT 81
97251: PUSH
97252: LD_OWVAR 2
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: PUSH
97261: LD_INT 2
97263: PUSH
97264: LD_INT 21
97266: PUSH
97267: LD_INT 1
97269: PUSH
97270: EMPTY
97271: LIST
97272: LIST
97273: PUSH
97274: LD_INT 21
97276: PUSH
97277: LD_INT 2
97279: PUSH
97280: EMPTY
97281: LIST
97282: LIST
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: LIST
97288: PUSH
97289: EMPTY
97290: LIST
97291: LIST
97292: PPUSH
97293: CALL_OW 69
97297: ST_TO_ADDR
// if not tmp then
97298: LD_VAR 0 2
97302: NOT
97303: IFFALSE 97307
// exit ;
97305: GO 97390
// p := 0 ;
97307: LD_ADDR_VAR 0 3
97311: PUSH
97312: LD_INT 0
97314: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97315: LD_INT 35
97317: PPUSH
97318: CALL_OW 67
// p := p + 1 ;
97322: LD_ADDR_VAR 0 3
97326: PUSH
97327: LD_VAR 0 3
97331: PUSH
97332: LD_INT 1
97334: PLUS
97335: ST_TO_ADDR
// for i in tmp do
97336: LD_ADDR_VAR 0 1
97340: PUSH
97341: LD_VAR 0 2
97345: PUSH
97346: FOR_IN
97347: IFFALSE 97378
// if GetLives ( i ) < 1000 then
97349: LD_VAR 0 1
97353: PPUSH
97354: CALL_OW 256
97358: PUSH
97359: LD_INT 1000
97361: LESS
97362: IFFALSE 97376
// SetLives ( i , 1000 ) ;
97364: LD_VAR 0 1
97368: PPUSH
97369: LD_INT 1000
97371: PPUSH
97372: CALL_OW 234
97376: GO 97346
97378: POP
97379: POP
// until p > 20 ;
97380: LD_VAR 0 3
97384: PUSH
97385: LD_INT 20
97387: GREATER
97388: IFFALSE 97315
// end ;
97390: PPOPN 3
97392: END
// every 0 0$1 trigger StreamModeActive and sTime do
97393: LD_EXP 130
97397: PUSH
97398: LD_EXP 181
97402: AND
97403: IFFALSE 97438
97405: GO 97407
97407: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97408: LD_INT 28
97410: PPUSH
97411: LD_OWVAR 2
97415: PPUSH
97416: LD_INT 2
97418: PPUSH
97419: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97423: LD_INT 30
97425: PPUSH
97426: LD_OWVAR 2
97430: PPUSH
97431: LD_INT 2
97433: PPUSH
97434: CALL_OW 322
// end ;
97438: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97439: LD_EXP 130
97443: PUSH
97444: LD_EXP 182
97448: AND
97449: IFFALSE 97570
97451: GO 97453
97453: DISABLE
97454: LD_INT 0
97456: PPUSH
97457: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97458: LD_ADDR_VAR 0 2
97462: PUSH
97463: LD_INT 22
97465: PUSH
97466: LD_OWVAR 2
97470: PUSH
97471: EMPTY
97472: LIST
97473: LIST
97474: PUSH
97475: LD_INT 21
97477: PUSH
97478: LD_INT 1
97480: PUSH
97481: EMPTY
97482: LIST
97483: LIST
97484: PUSH
97485: LD_INT 3
97487: PUSH
97488: LD_INT 23
97490: PUSH
97491: LD_INT 0
97493: PUSH
97494: EMPTY
97495: LIST
97496: LIST
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: PUSH
97502: EMPTY
97503: LIST
97504: LIST
97505: LIST
97506: PPUSH
97507: CALL_OW 69
97511: ST_TO_ADDR
// if not tmp then
97512: LD_VAR 0 2
97516: NOT
97517: IFFALSE 97521
// exit ;
97519: GO 97570
// for i in tmp do
97521: LD_ADDR_VAR 0 1
97525: PUSH
97526: LD_VAR 0 2
97530: PUSH
97531: FOR_IN
97532: IFFALSE 97568
// begin if Crawls ( i ) then
97534: LD_VAR 0 1
97538: PPUSH
97539: CALL_OW 318
97543: IFFALSE 97554
// ComWalk ( i ) ;
97545: LD_VAR 0 1
97549: PPUSH
97550: CALL_OW 138
// SetClass ( i , 2 ) ;
97554: LD_VAR 0 1
97558: PPUSH
97559: LD_INT 2
97561: PPUSH
97562: CALL_OW 336
// end ;
97566: GO 97531
97568: POP
97569: POP
// end ;
97570: PPOPN 2
97572: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97573: LD_EXP 130
97577: PUSH
97578: LD_EXP 183
97582: AND
97583: IFFALSE 97864
97585: GO 97587
97587: DISABLE
97588: LD_INT 0
97590: PPUSH
97591: PPUSH
97592: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97593: LD_OWVAR 2
97597: PPUSH
97598: LD_INT 9
97600: PPUSH
97601: LD_INT 1
97603: PPUSH
97604: LD_INT 1
97606: PPUSH
97607: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97611: LD_INT 9
97613: PPUSH
97614: LD_OWVAR 2
97618: PPUSH
97619: CALL_OW 343
// uc_side := 9 ;
97623: LD_ADDR_OWVAR 20
97627: PUSH
97628: LD_INT 9
97630: ST_TO_ADDR
// uc_nation := 2 ;
97631: LD_ADDR_OWVAR 21
97635: PUSH
97636: LD_INT 2
97638: ST_TO_ADDR
// hc_name := Dark Warrior ;
97639: LD_ADDR_OWVAR 26
97643: PUSH
97644: LD_STRING Dark Warrior
97646: ST_TO_ADDR
// hc_gallery :=  ;
97647: LD_ADDR_OWVAR 33
97651: PUSH
97652: LD_STRING 
97654: ST_TO_ADDR
// hc_noskilllimit := true ;
97655: LD_ADDR_OWVAR 76
97659: PUSH
97660: LD_INT 1
97662: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97663: LD_ADDR_OWVAR 31
97667: PUSH
97668: LD_INT 30
97670: PUSH
97671: LD_INT 30
97673: PUSH
97674: LD_INT 30
97676: PUSH
97677: LD_INT 30
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: ST_TO_ADDR
// un := CreateHuman ;
97686: LD_ADDR_VAR 0 3
97690: PUSH
97691: CALL_OW 44
97695: ST_TO_ADDR
// hc_noskilllimit := false ;
97696: LD_ADDR_OWVAR 76
97700: PUSH
97701: LD_INT 0
97703: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97704: LD_VAR 0 3
97708: PPUSH
97709: LD_INT 1
97711: PPUSH
97712: CALL_OW 51
// p := 0 ;
97716: LD_ADDR_VAR 0 2
97720: PUSH
97721: LD_INT 0
97723: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97724: LD_INT 35
97726: PPUSH
97727: CALL_OW 67
// p := p + 1 ;
97731: LD_ADDR_VAR 0 2
97735: PUSH
97736: LD_VAR 0 2
97740: PUSH
97741: LD_INT 1
97743: PLUS
97744: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97745: LD_VAR 0 3
97749: PPUSH
97750: CALL_OW 256
97754: PUSH
97755: LD_INT 1000
97757: LESS
97758: IFFALSE 97772
// SetLives ( un , 1000 ) ;
97760: LD_VAR 0 3
97764: PPUSH
97765: LD_INT 1000
97767: PPUSH
97768: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97772: LD_VAR 0 3
97776: PPUSH
97777: LD_INT 81
97779: PUSH
97780: LD_OWVAR 2
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: PUSH
97789: LD_INT 91
97791: PUSH
97792: LD_VAR 0 3
97796: PUSH
97797: LD_INT 30
97799: PUSH
97800: EMPTY
97801: LIST
97802: LIST
97803: LIST
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PPUSH
97809: CALL_OW 69
97813: PPUSH
97814: LD_VAR 0 3
97818: PPUSH
97819: CALL_OW 74
97823: PPUSH
97824: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
97828: LD_VAR 0 2
97832: PUSH
97833: LD_INT 60
97835: GREATER
97836: PUSH
97837: LD_VAR 0 3
97841: PPUSH
97842: CALL_OW 301
97846: OR
97847: IFFALSE 97724
// if un then
97849: LD_VAR 0 3
97853: IFFALSE 97864
// RemoveUnit ( un ) ;
97855: LD_VAR 0 3
97859: PPUSH
97860: CALL_OW 64
// end ; end_of_file
97864: PPOPN 3
97866: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
97867: LD_INT 0
97869: PPUSH
97870: PPUSH
97871: PPUSH
97872: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
97873: LD_VAR 0 1
97877: PPUSH
97878: CALL_OW 264
97882: PUSH
97883: LD_EXP 76
97887: EQUAL
97888: IFFALSE 97960
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
97890: LD_INT 68
97892: PPUSH
97893: LD_VAR 0 1
97897: PPUSH
97898: CALL_OW 255
97902: PPUSH
97903: CALL_OW 321
97907: PUSH
97908: LD_INT 2
97910: EQUAL
97911: IFFALSE 97923
// eff := 70 else
97913: LD_ADDR_VAR 0 4
97917: PUSH
97918: LD_INT 70
97920: ST_TO_ADDR
97921: GO 97931
// eff := 30 ;
97923: LD_ADDR_VAR 0 4
97927: PUSH
97928: LD_INT 30
97930: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
97931: LD_VAR 0 1
97935: PPUSH
97936: CALL_OW 250
97940: PPUSH
97941: LD_VAR 0 1
97945: PPUSH
97946: CALL_OW 251
97950: PPUSH
97951: LD_VAR 0 4
97955: PPUSH
97956: CALL_OW 495
// end ; end ;
97960: LD_VAR 0 2
97964: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
97965: LD_INT 0
97967: PPUSH
// end ;
97968: LD_VAR 0 4
97972: RET
// export function SOS_Command ( cmd ) ; begin
97973: LD_INT 0
97975: PPUSH
// end ;
97976: LD_VAR 0 2
97980: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
97981: LD_VAR 0 1
97985: PUSH
97986: LD_INT 255
97988: EQUAL
97989: PUSH
97990: LD_VAR 0 2
97994: PPUSH
97995: CALL_OW 264
97999: PUSH
98000: LD_INT 14
98002: PUSH
98003: LD_INT 53
98005: PUSH
98006: EMPTY
98007: LIST
98008: LIST
98009: IN
98010: AND
98011: PUSH
98012: LD_VAR 0 4
98016: PPUSH
98017: LD_VAR 0 5
98021: PPUSH
98022: CALL_OW 488
98026: AND
98027: IFFALSE 98051
// CutTreeXYR ( unit , x , y , 12 ) ;
98029: LD_VAR 0 2
98033: PPUSH
98034: LD_VAR 0 4
98038: PPUSH
98039: LD_VAR 0 5
98043: PPUSH
98044: LD_INT 12
98046: PPUSH
98047: CALL 98054 0 4
// end ;
98051: PPOPN 5
98053: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98054: LD_INT 0
98056: PPUSH
98057: PPUSH
98058: PPUSH
98059: PPUSH
98060: PPUSH
98061: PPUSH
98062: PPUSH
98063: PPUSH
98064: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98065: LD_VAR 0 1
98069: NOT
98070: PUSH
98071: LD_VAR 0 2
98075: PPUSH
98076: LD_VAR 0 3
98080: PPUSH
98081: CALL_OW 488
98085: NOT
98086: OR
98087: PUSH
98088: LD_VAR 0 4
98092: NOT
98093: OR
98094: IFFALSE 98098
// exit ;
98096: GO 98438
// list := [ ] ;
98098: LD_ADDR_VAR 0 13
98102: PUSH
98103: EMPTY
98104: ST_TO_ADDR
// if x - r < 0 then
98105: LD_VAR 0 2
98109: PUSH
98110: LD_VAR 0 4
98114: MINUS
98115: PUSH
98116: LD_INT 0
98118: LESS
98119: IFFALSE 98131
// min_x := 0 else
98121: LD_ADDR_VAR 0 7
98125: PUSH
98126: LD_INT 0
98128: ST_TO_ADDR
98129: GO 98147
// min_x := x - r ;
98131: LD_ADDR_VAR 0 7
98135: PUSH
98136: LD_VAR 0 2
98140: PUSH
98141: LD_VAR 0 4
98145: MINUS
98146: ST_TO_ADDR
// if y - r < 0 then
98147: LD_VAR 0 3
98151: PUSH
98152: LD_VAR 0 4
98156: MINUS
98157: PUSH
98158: LD_INT 0
98160: LESS
98161: IFFALSE 98173
// min_y := 0 else
98163: LD_ADDR_VAR 0 8
98167: PUSH
98168: LD_INT 0
98170: ST_TO_ADDR
98171: GO 98189
// min_y := y - r ;
98173: LD_ADDR_VAR 0 8
98177: PUSH
98178: LD_VAR 0 3
98182: PUSH
98183: LD_VAR 0 4
98187: MINUS
98188: ST_TO_ADDR
// max_x := x + r ;
98189: LD_ADDR_VAR 0 9
98193: PUSH
98194: LD_VAR 0 2
98198: PUSH
98199: LD_VAR 0 4
98203: PLUS
98204: ST_TO_ADDR
// max_y := y + r ;
98205: LD_ADDR_VAR 0 10
98209: PUSH
98210: LD_VAR 0 3
98214: PUSH
98215: LD_VAR 0 4
98219: PLUS
98220: ST_TO_ADDR
// for _x = min_x to max_x do
98221: LD_ADDR_VAR 0 11
98225: PUSH
98226: DOUBLE
98227: LD_VAR 0 7
98231: DEC
98232: ST_TO_ADDR
98233: LD_VAR 0 9
98237: PUSH
98238: FOR_TO
98239: IFFALSE 98356
// for _y = min_y to max_y do
98241: LD_ADDR_VAR 0 12
98245: PUSH
98246: DOUBLE
98247: LD_VAR 0 8
98251: DEC
98252: ST_TO_ADDR
98253: LD_VAR 0 10
98257: PUSH
98258: FOR_TO
98259: IFFALSE 98352
// begin if not ValidHex ( _x , _y ) then
98261: LD_VAR 0 11
98265: PPUSH
98266: LD_VAR 0 12
98270: PPUSH
98271: CALL_OW 488
98275: NOT
98276: IFFALSE 98280
// continue ;
98278: GO 98258
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98280: LD_VAR 0 11
98284: PPUSH
98285: LD_VAR 0 12
98289: PPUSH
98290: CALL_OW 351
98294: PUSH
98295: LD_VAR 0 11
98299: PPUSH
98300: LD_VAR 0 12
98304: PPUSH
98305: CALL_OW 554
98309: AND
98310: IFFALSE 98350
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98312: LD_ADDR_VAR 0 13
98316: PUSH
98317: LD_VAR 0 13
98321: PPUSH
98322: LD_VAR 0 13
98326: PUSH
98327: LD_INT 1
98329: PLUS
98330: PPUSH
98331: LD_VAR 0 11
98335: PUSH
98336: LD_VAR 0 12
98340: PUSH
98341: EMPTY
98342: LIST
98343: LIST
98344: PPUSH
98345: CALL_OW 2
98349: ST_TO_ADDR
// end ;
98350: GO 98258
98352: POP
98353: POP
98354: GO 98238
98356: POP
98357: POP
// if not list then
98358: LD_VAR 0 13
98362: NOT
98363: IFFALSE 98367
// exit ;
98365: GO 98438
// for i in list do
98367: LD_ADDR_VAR 0 6
98371: PUSH
98372: LD_VAR 0 13
98376: PUSH
98377: FOR_IN
98378: IFFALSE 98436
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98380: LD_VAR 0 1
98384: PPUSH
98385: LD_STRING M
98387: PUSH
98388: LD_VAR 0 6
98392: PUSH
98393: LD_INT 1
98395: ARRAY
98396: PUSH
98397: LD_VAR 0 6
98401: PUSH
98402: LD_INT 2
98404: ARRAY
98405: PUSH
98406: LD_INT 0
98408: PUSH
98409: LD_INT 0
98411: PUSH
98412: LD_INT 0
98414: PUSH
98415: LD_INT 0
98417: PUSH
98418: EMPTY
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: PUSH
98427: EMPTY
98428: LIST
98429: PPUSH
98430: CALL_OW 447
98434: GO 98377
98436: POP
98437: POP
// end ; end_of_file
98438: LD_VAR 0 5
98442: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98443: LD_INT 0
98445: PPUSH
98446: PPUSH
98447: PPUSH
98448: PPUSH
98449: PPUSH
98450: PPUSH
98451: PPUSH
98452: PPUSH
98453: PPUSH
98454: PPUSH
98455: PPUSH
98456: PPUSH
98457: PPUSH
98458: PPUSH
98459: PPUSH
98460: PPUSH
98461: PPUSH
98462: PPUSH
98463: PPUSH
98464: PPUSH
98465: PPUSH
98466: PPUSH
98467: PPUSH
98468: PPUSH
98469: PPUSH
98470: PPUSH
98471: PPUSH
98472: PPUSH
98473: PPUSH
98474: PPUSH
98475: PPUSH
98476: PPUSH
98477: PPUSH
98478: PPUSH
// if not list then
98479: LD_VAR 0 1
98483: NOT
98484: IFFALSE 98488
// exit ;
98486: GO 103147
// base := list [ 1 ] ;
98488: LD_ADDR_VAR 0 3
98492: PUSH
98493: LD_VAR 0 1
98497: PUSH
98498: LD_INT 1
98500: ARRAY
98501: ST_TO_ADDR
// group := list [ 2 ] ;
98502: LD_ADDR_VAR 0 4
98506: PUSH
98507: LD_VAR 0 1
98511: PUSH
98512: LD_INT 2
98514: ARRAY
98515: ST_TO_ADDR
// path := list [ 3 ] ;
98516: LD_ADDR_VAR 0 5
98520: PUSH
98521: LD_VAR 0 1
98525: PUSH
98526: LD_INT 3
98528: ARRAY
98529: ST_TO_ADDR
// flags := list [ 4 ] ;
98530: LD_ADDR_VAR 0 6
98534: PUSH
98535: LD_VAR 0 1
98539: PUSH
98540: LD_INT 4
98542: ARRAY
98543: ST_TO_ADDR
// mined := [ ] ;
98544: LD_ADDR_VAR 0 27
98548: PUSH
98549: EMPTY
98550: ST_TO_ADDR
// bombed := [ ] ;
98551: LD_ADDR_VAR 0 28
98555: PUSH
98556: EMPTY
98557: ST_TO_ADDR
// healers := [ ] ;
98558: LD_ADDR_VAR 0 31
98562: PUSH
98563: EMPTY
98564: ST_TO_ADDR
// to_heal := [ ] ;
98565: LD_ADDR_VAR 0 30
98569: PUSH
98570: EMPTY
98571: ST_TO_ADDR
// repairs := [ ] ;
98572: LD_ADDR_VAR 0 33
98576: PUSH
98577: EMPTY
98578: ST_TO_ADDR
// to_repair := [ ] ;
98579: LD_ADDR_VAR 0 32
98583: PUSH
98584: EMPTY
98585: ST_TO_ADDR
// if not group or not path then
98586: LD_VAR 0 4
98590: NOT
98591: PUSH
98592: LD_VAR 0 5
98596: NOT
98597: OR
98598: IFFALSE 98602
// exit ;
98600: GO 103147
// side := GetSide ( group [ 1 ] ) ;
98602: LD_ADDR_VAR 0 35
98606: PUSH
98607: LD_VAR 0 4
98611: PUSH
98612: LD_INT 1
98614: ARRAY
98615: PPUSH
98616: CALL_OW 255
98620: ST_TO_ADDR
// if flags then
98621: LD_VAR 0 6
98625: IFFALSE 98769
// begin f_ignore_area := flags [ 1 ] ;
98627: LD_ADDR_VAR 0 17
98631: PUSH
98632: LD_VAR 0 6
98636: PUSH
98637: LD_INT 1
98639: ARRAY
98640: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98641: LD_ADDR_VAR 0 18
98645: PUSH
98646: LD_VAR 0 6
98650: PUSH
98651: LD_INT 2
98653: ARRAY
98654: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98655: LD_ADDR_VAR 0 19
98659: PUSH
98660: LD_VAR 0 6
98664: PUSH
98665: LD_INT 3
98667: ARRAY
98668: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98669: LD_ADDR_VAR 0 20
98673: PUSH
98674: LD_VAR 0 6
98678: PUSH
98679: LD_INT 4
98681: ARRAY
98682: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98683: LD_ADDR_VAR 0 21
98687: PUSH
98688: LD_VAR 0 6
98692: PUSH
98693: LD_INT 5
98695: ARRAY
98696: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98697: LD_ADDR_VAR 0 22
98701: PUSH
98702: LD_VAR 0 6
98706: PUSH
98707: LD_INT 6
98709: ARRAY
98710: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98711: LD_ADDR_VAR 0 23
98715: PUSH
98716: LD_VAR 0 6
98720: PUSH
98721: LD_INT 7
98723: ARRAY
98724: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98725: LD_ADDR_VAR 0 24
98729: PUSH
98730: LD_VAR 0 6
98734: PUSH
98735: LD_INT 8
98737: ARRAY
98738: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98739: LD_ADDR_VAR 0 25
98743: PUSH
98744: LD_VAR 0 6
98748: PUSH
98749: LD_INT 9
98751: ARRAY
98752: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98753: LD_ADDR_VAR 0 26
98757: PUSH
98758: LD_VAR 0 6
98762: PUSH
98763: LD_INT 10
98765: ARRAY
98766: ST_TO_ADDR
// end else
98767: GO 98849
// begin f_ignore_area := false ;
98769: LD_ADDR_VAR 0 17
98773: PUSH
98774: LD_INT 0
98776: ST_TO_ADDR
// f_capture := false ;
98777: LD_ADDR_VAR 0 18
98781: PUSH
98782: LD_INT 0
98784: ST_TO_ADDR
// f_ignore_civ := false ;
98785: LD_ADDR_VAR 0 19
98789: PUSH
98790: LD_INT 0
98792: ST_TO_ADDR
// f_murder := false ;
98793: LD_ADDR_VAR 0 20
98797: PUSH
98798: LD_INT 0
98800: ST_TO_ADDR
// f_mines := false ;
98801: LD_ADDR_VAR 0 21
98805: PUSH
98806: LD_INT 0
98808: ST_TO_ADDR
// f_repair := false ;
98809: LD_ADDR_VAR 0 22
98813: PUSH
98814: LD_INT 0
98816: ST_TO_ADDR
// f_heal := false ;
98817: LD_ADDR_VAR 0 23
98821: PUSH
98822: LD_INT 0
98824: ST_TO_ADDR
// f_spacetime := false ;
98825: LD_ADDR_VAR 0 24
98829: PUSH
98830: LD_INT 0
98832: ST_TO_ADDR
// f_attack_depot := false ;
98833: LD_ADDR_VAR 0 25
98837: PUSH
98838: LD_INT 0
98840: ST_TO_ADDR
// f_crawl := false ;
98841: LD_ADDR_VAR 0 26
98845: PUSH
98846: LD_INT 0
98848: ST_TO_ADDR
// end ; if f_heal then
98849: LD_VAR 0 23
98853: IFFALSE 98880
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98855: LD_ADDR_VAR 0 31
98859: PUSH
98860: LD_VAR 0 4
98864: PPUSH
98865: LD_INT 25
98867: PUSH
98868: LD_INT 4
98870: PUSH
98871: EMPTY
98872: LIST
98873: LIST
98874: PPUSH
98875: CALL_OW 72
98879: ST_TO_ADDR
// if f_repair then
98880: LD_VAR 0 22
98884: IFFALSE 98911
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98886: LD_ADDR_VAR 0 33
98890: PUSH
98891: LD_VAR 0 4
98895: PPUSH
98896: LD_INT 25
98898: PUSH
98899: LD_INT 3
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: PPUSH
98906: CALL_OW 72
98910: ST_TO_ADDR
// units_path := [ ] ;
98911: LD_ADDR_VAR 0 16
98915: PUSH
98916: EMPTY
98917: ST_TO_ADDR
// for i = 1 to group do
98918: LD_ADDR_VAR 0 7
98922: PUSH
98923: DOUBLE
98924: LD_INT 1
98926: DEC
98927: ST_TO_ADDR
98928: LD_VAR 0 4
98932: PUSH
98933: FOR_TO
98934: IFFALSE 98963
// units_path := Replace ( units_path , i , path ) ;
98936: LD_ADDR_VAR 0 16
98940: PUSH
98941: LD_VAR 0 16
98945: PPUSH
98946: LD_VAR 0 7
98950: PPUSH
98951: LD_VAR 0 5
98955: PPUSH
98956: CALL_OW 1
98960: ST_TO_ADDR
98961: GO 98933
98963: POP
98964: POP
// repeat for i = group downto 1 do
98965: LD_ADDR_VAR 0 7
98969: PUSH
98970: DOUBLE
98971: LD_VAR 0 4
98975: INC
98976: ST_TO_ADDR
98977: LD_INT 1
98979: PUSH
98980: FOR_DOWNTO
98981: IFFALSE 103103
// begin wait ( 5 ) ;
98983: LD_INT 5
98985: PPUSH
98986: CALL_OW 67
// tmp := [ ] ;
98990: LD_ADDR_VAR 0 14
98994: PUSH
98995: EMPTY
98996: ST_TO_ADDR
// attacking := false ;
98997: LD_ADDR_VAR 0 29
99001: PUSH
99002: LD_INT 0
99004: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99005: LD_VAR 0 4
99009: PUSH
99010: LD_VAR 0 7
99014: ARRAY
99015: PPUSH
99016: CALL_OW 301
99020: PUSH
99021: LD_VAR 0 4
99025: PUSH
99026: LD_VAR 0 7
99030: ARRAY
99031: NOT
99032: OR
99033: IFFALSE 99142
// begin if GetType ( group [ i ] ) = unit_human then
99035: LD_VAR 0 4
99039: PUSH
99040: LD_VAR 0 7
99044: ARRAY
99045: PPUSH
99046: CALL_OW 247
99050: PUSH
99051: LD_INT 1
99053: EQUAL
99054: IFFALSE 99100
// begin to_heal := to_heal diff group [ i ] ;
99056: LD_ADDR_VAR 0 30
99060: PUSH
99061: LD_VAR 0 30
99065: PUSH
99066: LD_VAR 0 4
99070: PUSH
99071: LD_VAR 0 7
99075: ARRAY
99076: DIFF
99077: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99078: LD_ADDR_VAR 0 31
99082: PUSH
99083: LD_VAR 0 31
99087: PUSH
99088: LD_VAR 0 4
99092: PUSH
99093: LD_VAR 0 7
99097: ARRAY
99098: DIFF
99099: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99100: LD_ADDR_VAR 0 4
99104: PUSH
99105: LD_VAR 0 4
99109: PPUSH
99110: LD_VAR 0 7
99114: PPUSH
99115: CALL_OW 3
99119: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99120: LD_ADDR_VAR 0 16
99124: PUSH
99125: LD_VAR 0 16
99129: PPUSH
99130: LD_VAR 0 7
99134: PPUSH
99135: CALL_OW 3
99139: ST_TO_ADDR
// continue ;
99140: GO 98980
// end ; if f_repair then
99142: LD_VAR 0 22
99146: IFFALSE 99635
// begin if GetType ( group [ i ] ) = unit_vehicle then
99148: LD_VAR 0 4
99152: PUSH
99153: LD_VAR 0 7
99157: ARRAY
99158: PPUSH
99159: CALL_OW 247
99163: PUSH
99164: LD_INT 2
99166: EQUAL
99167: IFFALSE 99357
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99169: LD_VAR 0 4
99173: PUSH
99174: LD_VAR 0 7
99178: ARRAY
99179: PPUSH
99180: CALL_OW 256
99184: PUSH
99185: LD_INT 700
99187: LESS
99188: PUSH
99189: LD_VAR 0 4
99193: PUSH
99194: LD_VAR 0 7
99198: ARRAY
99199: PUSH
99200: LD_VAR 0 32
99204: IN
99205: NOT
99206: AND
99207: IFFALSE 99231
// to_repair := to_repair union group [ i ] ;
99209: LD_ADDR_VAR 0 32
99213: PUSH
99214: LD_VAR 0 32
99218: PUSH
99219: LD_VAR 0 4
99223: PUSH
99224: LD_VAR 0 7
99228: ARRAY
99229: UNION
99230: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99231: LD_VAR 0 4
99235: PUSH
99236: LD_VAR 0 7
99240: ARRAY
99241: PPUSH
99242: CALL_OW 256
99246: PUSH
99247: LD_INT 1000
99249: EQUAL
99250: PUSH
99251: LD_VAR 0 4
99255: PUSH
99256: LD_VAR 0 7
99260: ARRAY
99261: PUSH
99262: LD_VAR 0 32
99266: IN
99267: AND
99268: IFFALSE 99292
// to_repair := to_repair diff group [ i ] ;
99270: LD_ADDR_VAR 0 32
99274: PUSH
99275: LD_VAR 0 32
99279: PUSH
99280: LD_VAR 0 4
99284: PUSH
99285: LD_VAR 0 7
99289: ARRAY
99290: DIFF
99291: ST_TO_ADDR
// if group [ i ] in to_repair then
99292: LD_VAR 0 4
99296: PUSH
99297: LD_VAR 0 7
99301: ARRAY
99302: PUSH
99303: LD_VAR 0 32
99307: IN
99308: IFFALSE 99355
// begin if not IsInArea ( group [ i ] , f_repair ) then
99310: LD_VAR 0 4
99314: PUSH
99315: LD_VAR 0 7
99319: ARRAY
99320: PPUSH
99321: LD_VAR 0 22
99325: PPUSH
99326: CALL_OW 308
99330: NOT
99331: IFFALSE 99353
// ComMoveToArea ( group [ i ] , f_repair ) ;
99333: LD_VAR 0 4
99337: PUSH
99338: LD_VAR 0 7
99342: ARRAY
99343: PPUSH
99344: LD_VAR 0 22
99348: PPUSH
99349: CALL_OW 113
// continue ;
99353: GO 98980
// end ; end else
99355: GO 99635
// if group [ i ] in repairs then
99357: LD_VAR 0 4
99361: PUSH
99362: LD_VAR 0 7
99366: ARRAY
99367: PUSH
99368: LD_VAR 0 33
99372: IN
99373: IFFALSE 99635
// begin if IsInUnit ( group [ i ] ) then
99375: LD_VAR 0 4
99379: PUSH
99380: LD_VAR 0 7
99384: ARRAY
99385: PPUSH
99386: CALL_OW 310
99390: IFFALSE 99458
// begin z := IsInUnit ( group [ i ] ) ;
99392: LD_ADDR_VAR 0 13
99396: PUSH
99397: LD_VAR 0 4
99401: PUSH
99402: LD_VAR 0 7
99406: ARRAY
99407: PPUSH
99408: CALL_OW 310
99412: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99413: LD_VAR 0 13
99417: PUSH
99418: LD_VAR 0 32
99422: IN
99423: PUSH
99424: LD_VAR 0 13
99428: PPUSH
99429: LD_VAR 0 22
99433: PPUSH
99434: CALL_OW 308
99438: AND
99439: IFFALSE 99456
// ComExitVehicle ( group [ i ] ) ;
99441: LD_VAR 0 4
99445: PUSH
99446: LD_VAR 0 7
99450: ARRAY
99451: PPUSH
99452: CALL_OW 121
// end else
99456: GO 99635
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99458: LD_ADDR_VAR 0 13
99462: PUSH
99463: LD_VAR 0 4
99467: PPUSH
99468: LD_INT 95
99470: PUSH
99471: LD_VAR 0 22
99475: PUSH
99476: EMPTY
99477: LIST
99478: LIST
99479: PUSH
99480: LD_INT 58
99482: PUSH
99483: EMPTY
99484: LIST
99485: PUSH
99486: EMPTY
99487: LIST
99488: LIST
99489: PPUSH
99490: CALL_OW 72
99494: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99495: LD_VAR 0 4
99499: PUSH
99500: LD_VAR 0 7
99504: ARRAY
99505: PPUSH
99506: CALL_OW 314
99510: NOT
99511: IFFALSE 99633
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99513: LD_ADDR_VAR 0 10
99517: PUSH
99518: LD_VAR 0 13
99522: PPUSH
99523: LD_VAR 0 4
99527: PUSH
99528: LD_VAR 0 7
99532: ARRAY
99533: PPUSH
99534: CALL_OW 74
99538: ST_TO_ADDR
// if not x then
99539: LD_VAR 0 10
99543: NOT
99544: IFFALSE 99548
// continue ;
99546: GO 98980
// if GetLives ( x ) < 1000 then
99548: LD_VAR 0 10
99552: PPUSH
99553: CALL_OW 256
99557: PUSH
99558: LD_INT 1000
99560: LESS
99561: IFFALSE 99585
// ComRepairVehicle ( group [ i ] , x ) else
99563: LD_VAR 0 4
99567: PUSH
99568: LD_VAR 0 7
99572: ARRAY
99573: PPUSH
99574: LD_VAR 0 10
99578: PPUSH
99579: CALL_OW 129
99583: GO 99633
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99585: LD_VAR 0 23
99589: PUSH
99590: LD_VAR 0 4
99594: PUSH
99595: LD_VAR 0 7
99599: ARRAY
99600: PPUSH
99601: CALL_OW 256
99605: PUSH
99606: LD_INT 1000
99608: LESS
99609: AND
99610: NOT
99611: IFFALSE 99633
// ComEnterUnit ( group [ i ] , x ) ;
99613: LD_VAR 0 4
99617: PUSH
99618: LD_VAR 0 7
99622: ARRAY
99623: PPUSH
99624: LD_VAR 0 10
99628: PPUSH
99629: CALL_OW 120
// end ; continue ;
99633: GO 98980
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99635: LD_VAR 0 23
99639: PUSH
99640: LD_VAR 0 4
99644: PUSH
99645: LD_VAR 0 7
99649: ARRAY
99650: PPUSH
99651: CALL_OW 247
99655: PUSH
99656: LD_INT 1
99658: EQUAL
99659: AND
99660: IFFALSE 100138
// begin if group [ i ] in healers then
99662: LD_VAR 0 4
99666: PUSH
99667: LD_VAR 0 7
99671: ARRAY
99672: PUSH
99673: LD_VAR 0 31
99677: IN
99678: IFFALSE 99951
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99680: LD_VAR 0 4
99684: PUSH
99685: LD_VAR 0 7
99689: ARRAY
99690: PPUSH
99691: LD_VAR 0 23
99695: PPUSH
99696: CALL_OW 308
99700: NOT
99701: PUSH
99702: LD_VAR 0 4
99706: PUSH
99707: LD_VAR 0 7
99711: ARRAY
99712: PPUSH
99713: CALL_OW 314
99717: NOT
99718: AND
99719: IFFALSE 99743
// ComMoveToArea ( group [ i ] , f_heal ) else
99721: LD_VAR 0 4
99725: PUSH
99726: LD_VAR 0 7
99730: ARRAY
99731: PPUSH
99732: LD_VAR 0 23
99736: PPUSH
99737: CALL_OW 113
99741: GO 99949
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99743: LD_VAR 0 4
99747: PUSH
99748: LD_VAR 0 7
99752: ARRAY
99753: PPUSH
99754: CALL 83919 0 1
99758: PPUSH
99759: CALL_OW 256
99763: PUSH
99764: LD_INT 1000
99766: EQUAL
99767: IFFALSE 99786
// ComStop ( group [ i ] ) else
99769: LD_VAR 0 4
99773: PUSH
99774: LD_VAR 0 7
99778: ARRAY
99779: PPUSH
99780: CALL_OW 141
99784: GO 99949
// if not HasTask ( group [ i ] ) and to_heal then
99786: LD_VAR 0 4
99790: PUSH
99791: LD_VAR 0 7
99795: ARRAY
99796: PPUSH
99797: CALL_OW 314
99801: NOT
99802: PUSH
99803: LD_VAR 0 30
99807: AND
99808: IFFALSE 99949
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99810: LD_ADDR_VAR 0 13
99814: PUSH
99815: LD_VAR 0 30
99819: PPUSH
99820: LD_INT 3
99822: PUSH
99823: LD_INT 54
99825: PUSH
99826: EMPTY
99827: LIST
99828: PUSH
99829: EMPTY
99830: LIST
99831: LIST
99832: PPUSH
99833: CALL_OW 72
99837: PPUSH
99838: LD_VAR 0 4
99842: PUSH
99843: LD_VAR 0 7
99847: ARRAY
99848: PPUSH
99849: CALL_OW 74
99853: ST_TO_ADDR
// if z then
99854: LD_VAR 0 13
99858: IFFALSE 99949
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99860: LD_INT 91
99862: PUSH
99863: LD_VAR 0 13
99867: PUSH
99868: LD_INT 10
99870: PUSH
99871: EMPTY
99872: LIST
99873: LIST
99874: LIST
99875: PUSH
99876: LD_INT 81
99878: PUSH
99879: LD_VAR 0 13
99883: PPUSH
99884: CALL_OW 255
99888: PUSH
99889: EMPTY
99890: LIST
99891: LIST
99892: PUSH
99893: EMPTY
99894: LIST
99895: LIST
99896: PPUSH
99897: CALL_OW 69
99901: PUSH
99902: LD_INT 0
99904: EQUAL
99905: IFFALSE 99929
// ComHeal ( group [ i ] , z ) else
99907: LD_VAR 0 4
99911: PUSH
99912: LD_VAR 0 7
99916: ARRAY
99917: PPUSH
99918: LD_VAR 0 13
99922: PPUSH
99923: CALL_OW 128
99927: GO 99949
// ComMoveToArea ( group [ i ] , f_heal ) ;
99929: LD_VAR 0 4
99933: PUSH
99934: LD_VAR 0 7
99938: ARRAY
99939: PPUSH
99940: LD_VAR 0 23
99944: PPUSH
99945: CALL_OW 113
// end ; continue ;
99949: GO 98980
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99951: LD_VAR 0 4
99955: PUSH
99956: LD_VAR 0 7
99960: ARRAY
99961: PPUSH
99962: CALL_OW 256
99966: PUSH
99967: LD_INT 700
99969: LESS
99970: PUSH
99971: LD_VAR 0 4
99975: PUSH
99976: LD_VAR 0 7
99980: ARRAY
99981: PUSH
99982: LD_VAR 0 30
99986: IN
99987: NOT
99988: AND
99989: IFFALSE 100013
// to_heal := to_heal union group [ i ] ;
99991: LD_ADDR_VAR 0 30
99995: PUSH
99996: LD_VAR 0 30
100000: PUSH
100001: LD_VAR 0 4
100005: PUSH
100006: LD_VAR 0 7
100010: ARRAY
100011: UNION
100012: ST_TO_ADDR
// if group [ i ] in to_heal then
100013: LD_VAR 0 4
100017: PUSH
100018: LD_VAR 0 7
100022: ARRAY
100023: PUSH
100024: LD_VAR 0 30
100028: IN
100029: IFFALSE 100138
// begin if GetLives ( group [ i ] ) = 1000 then
100031: LD_VAR 0 4
100035: PUSH
100036: LD_VAR 0 7
100040: ARRAY
100041: PPUSH
100042: CALL_OW 256
100046: PUSH
100047: LD_INT 1000
100049: EQUAL
100050: IFFALSE 100076
// to_heal := to_heal diff group [ i ] else
100052: LD_ADDR_VAR 0 30
100056: PUSH
100057: LD_VAR 0 30
100061: PUSH
100062: LD_VAR 0 4
100066: PUSH
100067: LD_VAR 0 7
100071: ARRAY
100072: DIFF
100073: ST_TO_ADDR
100074: GO 100138
// begin if not IsInArea ( group [ i ] , to_heal ) then
100076: LD_VAR 0 4
100080: PUSH
100081: LD_VAR 0 7
100085: ARRAY
100086: PPUSH
100087: LD_VAR 0 30
100091: PPUSH
100092: CALL_OW 308
100096: NOT
100097: IFFALSE 100121
// ComMoveToArea ( group [ i ] , f_heal ) else
100099: LD_VAR 0 4
100103: PUSH
100104: LD_VAR 0 7
100108: ARRAY
100109: PPUSH
100110: LD_VAR 0 23
100114: PPUSH
100115: CALL_OW 113
100119: GO 100136
// ComHold ( group [ i ] ) ;
100121: LD_VAR 0 4
100125: PUSH
100126: LD_VAR 0 7
100130: ARRAY
100131: PPUSH
100132: CALL_OW 140
// continue ;
100136: GO 98980
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100138: LD_VAR 0 4
100142: PUSH
100143: LD_VAR 0 7
100147: ARRAY
100148: PPUSH
100149: LD_INT 10
100151: PPUSH
100152: CALL 82339 0 2
100156: NOT
100157: PUSH
100158: LD_VAR 0 16
100162: PUSH
100163: LD_VAR 0 7
100167: ARRAY
100168: PUSH
100169: EMPTY
100170: EQUAL
100171: NOT
100172: AND
100173: IFFALSE 100439
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100175: LD_VAR 0 4
100179: PUSH
100180: LD_VAR 0 7
100184: ARRAY
100185: PPUSH
100186: CALL_OW 262
100190: PUSH
100191: LD_INT 1
100193: PUSH
100194: LD_INT 2
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: IN
100201: IFFALSE 100242
// if GetFuel ( group [ i ] ) < 10 then
100203: LD_VAR 0 4
100207: PUSH
100208: LD_VAR 0 7
100212: ARRAY
100213: PPUSH
100214: CALL_OW 261
100218: PUSH
100219: LD_INT 10
100221: LESS
100222: IFFALSE 100242
// SetFuel ( group [ i ] , 12 ) ;
100224: LD_VAR 0 4
100228: PUSH
100229: LD_VAR 0 7
100233: ARRAY
100234: PPUSH
100235: LD_INT 12
100237: PPUSH
100238: CALL_OW 240
// if units_path [ i ] then
100242: LD_VAR 0 16
100246: PUSH
100247: LD_VAR 0 7
100251: ARRAY
100252: IFFALSE 100437
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100254: LD_VAR 0 4
100258: PUSH
100259: LD_VAR 0 7
100263: ARRAY
100264: PPUSH
100265: LD_VAR 0 16
100269: PUSH
100270: LD_VAR 0 7
100274: ARRAY
100275: PUSH
100276: LD_INT 1
100278: ARRAY
100279: PUSH
100280: LD_INT 1
100282: ARRAY
100283: PPUSH
100284: LD_VAR 0 16
100288: PUSH
100289: LD_VAR 0 7
100293: ARRAY
100294: PUSH
100295: LD_INT 1
100297: ARRAY
100298: PUSH
100299: LD_INT 2
100301: ARRAY
100302: PPUSH
100303: CALL_OW 297
100307: PUSH
100308: LD_INT 6
100310: GREATER
100311: IFFALSE 100386
// begin if not HasTask ( group [ i ] ) then
100313: LD_VAR 0 4
100317: PUSH
100318: LD_VAR 0 7
100322: ARRAY
100323: PPUSH
100324: CALL_OW 314
100328: NOT
100329: IFFALSE 100384
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100331: LD_VAR 0 4
100335: PUSH
100336: LD_VAR 0 7
100340: ARRAY
100341: PPUSH
100342: LD_VAR 0 16
100346: PUSH
100347: LD_VAR 0 7
100351: ARRAY
100352: PUSH
100353: LD_INT 1
100355: ARRAY
100356: PUSH
100357: LD_INT 1
100359: ARRAY
100360: PPUSH
100361: LD_VAR 0 16
100365: PUSH
100366: LD_VAR 0 7
100370: ARRAY
100371: PUSH
100372: LD_INT 1
100374: ARRAY
100375: PUSH
100376: LD_INT 2
100378: ARRAY
100379: PPUSH
100380: CALL_OW 114
// end else
100384: GO 100437
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100386: LD_ADDR_VAR 0 15
100390: PUSH
100391: LD_VAR 0 16
100395: PUSH
100396: LD_VAR 0 7
100400: ARRAY
100401: PPUSH
100402: LD_INT 1
100404: PPUSH
100405: CALL_OW 3
100409: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100410: LD_ADDR_VAR 0 16
100414: PUSH
100415: LD_VAR 0 16
100419: PPUSH
100420: LD_VAR 0 7
100424: PPUSH
100425: LD_VAR 0 15
100429: PPUSH
100430: CALL_OW 1
100434: ST_TO_ADDR
// continue ;
100435: GO 98980
// end ; end ; end else
100437: GO 103101
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100439: LD_ADDR_VAR 0 14
100443: PUSH
100444: LD_INT 81
100446: PUSH
100447: LD_VAR 0 4
100451: PUSH
100452: LD_VAR 0 7
100456: ARRAY
100457: PPUSH
100458: CALL_OW 255
100462: PUSH
100463: EMPTY
100464: LIST
100465: LIST
100466: PPUSH
100467: CALL_OW 69
100471: ST_TO_ADDR
// if not tmp then
100472: LD_VAR 0 14
100476: NOT
100477: IFFALSE 100481
// continue ;
100479: GO 98980
// if f_ignore_area then
100481: LD_VAR 0 17
100485: IFFALSE 100573
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100487: LD_ADDR_VAR 0 15
100491: PUSH
100492: LD_VAR 0 14
100496: PPUSH
100497: LD_INT 3
100499: PUSH
100500: LD_INT 92
100502: PUSH
100503: LD_VAR 0 17
100507: PUSH
100508: LD_INT 1
100510: ARRAY
100511: PUSH
100512: LD_VAR 0 17
100516: PUSH
100517: LD_INT 2
100519: ARRAY
100520: PUSH
100521: LD_VAR 0 17
100525: PUSH
100526: LD_INT 3
100528: ARRAY
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: LIST
100534: LIST
100535: PUSH
100536: EMPTY
100537: LIST
100538: LIST
100539: PPUSH
100540: CALL_OW 72
100544: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100545: LD_VAR 0 14
100549: PUSH
100550: LD_VAR 0 15
100554: DIFF
100555: IFFALSE 100573
// tmp := tmp diff tmp2 ;
100557: LD_ADDR_VAR 0 14
100561: PUSH
100562: LD_VAR 0 14
100566: PUSH
100567: LD_VAR 0 15
100571: DIFF
100572: ST_TO_ADDR
// end ; if not f_murder then
100573: LD_VAR 0 20
100577: NOT
100578: IFFALSE 100636
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100580: LD_ADDR_VAR 0 15
100584: PUSH
100585: LD_VAR 0 14
100589: PPUSH
100590: LD_INT 3
100592: PUSH
100593: LD_INT 50
100595: PUSH
100596: EMPTY
100597: LIST
100598: PUSH
100599: EMPTY
100600: LIST
100601: LIST
100602: PPUSH
100603: CALL_OW 72
100607: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100608: LD_VAR 0 14
100612: PUSH
100613: LD_VAR 0 15
100617: DIFF
100618: IFFALSE 100636
// tmp := tmp diff tmp2 ;
100620: LD_ADDR_VAR 0 14
100624: PUSH
100625: LD_VAR 0 14
100629: PUSH
100630: LD_VAR 0 15
100634: DIFF
100635: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100636: LD_ADDR_VAR 0 14
100640: PUSH
100641: LD_VAR 0 4
100645: PUSH
100646: LD_VAR 0 7
100650: ARRAY
100651: PPUSH
100652: LD_VAR 0 14
100656: PPUSH
100657: LD_INT 1
100659: PPUSH
100660: LD_INT 1
100662: PPUSH
100663: CALL 55982 0 4
100667: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100668: LD_VAR 0 4
100672: PUSH
100673: LD_VAR 0 7
100677: ARRAY
100678: PPUSH
100679: CALL_OW 257
100683: PUSH
100684: LD_INT 1
100686: EQUAL
100687: IFFALSE 101135
// begin if WantPlant ( group [ i ] ) then
100689: LD_VAR 0 4
100693: PUSH
100694: LD_VAR 0 7
100698: ARRAY
100699: PPUSH
100700: CALL 55483 0 1
100704: IFFALSE 100708
// continue ;
100706: GO 98980
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100708: LD_VAR 0 18
100712: PUSH
100713: LD_VAR 0 4
100717: PUSH
100718: LD_VAR 0 7
100722: ARRAY
100723: PPUSH
100724: CALL_OW 310
100728: NOT
100729: AND
100730: PUSH
100731: LD_VAR 0 14
100735: PUSH
100736: LD_INT 1
100738: ARRAY
100739: PUSH
100740: LD_VAR 0 14
100744: PPUSH
100745: LD_INT 21
100747: PUSH
100748: LD_INT 2
100750: PUSH
100751: EMPTY
100752: LIST
100753: LIST
100754: PUSH
100755: LD_INT 58
100757: PUSH
100758: EMPTY
100759: LIST
100760: PUSH
100761: EMPTY
100762: LIST
100763: LIST
100764: PPUSH
100765: CALL_OW 72
100769: IN
100770: AND
100771: IFFALSE 100807
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100773: LD_VAR 0 4
100777: PUSH
100778: LD_VAR 0 7
100782: ARRAY
100783: PPUSH
100784: LD_VAR 0 14
100788: PUSH
100789: LD_INT 1
100791: ARRAY
100792: PPUSH
100793: CALL_OW 120
// attacking := true ;
100797: LD_ADDR_VAR 0 29
100801: PUSH
100802: LD_INT 1
100804: ST_TO_ADDR
// continue ;
100805: GO 98980
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100807: LD_VAR 0 26
100811: PUSH
100812: LD_VAR 0 4
100816: PUSH
100817: LD_VAR 0 7
100821: ARRAY
100822: PPUSH
100823: CALL_OW 257
100827: PUSH
100828: LD_INT 1
100830: EQUAL
100831: AND
100832: PUSH
100833: LD_VAR 0 4
100837: PUSH
100838: LD_VAR 0 7
100842: ARRAY
100843: PPUSH
100844: CALL_OW 256
100848: PUSH
100849: LD_INT 800
100851: LESS
100852: AND
100853: PUSH
100854: LD_VAR 0 4
100858: PUSH
100859: LD_VAR 0 7
100863: ARRAY
100864: PPUSH
100865: CALL_OW 318
100869: NOT
100870: AND
100871: IFFALSE 100888
// ComCrawl ( group [ i ] ) ;
100873: LD_VAR 0 4
100877: PUSH
100878: LD_VAR 0 7
100882: ARRAY
100883: PPUSH
100884: CALL_OW 137
// if f_mines then
100888: LD_VAR 0 21
100892: IFFALSE 101135
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100894: LD_VAR 0 14
100898: PUSH
100899: LD_INT 1
100901: ARRAY
100902: PPUSH
100903: CALL_OW 247
100907: PUSH
100908: LD_INT 3
100910: EQUAL
100911: PUSH
100912: LD_VAR 0 14
100916: PUSH
100917: LD_INT 1
100919: ARRAY
100920: PUSH
100921: LD_VAR 0 27
100925: IN
100926: NOT
100927: AND
100928: IFFALSE 101135
// begin x := GetX ( tmp [ 1 ] ) ;
100930: LD_ADDR_VAR 0 10
100934: PUSH
100935: LD_VAR 0 14
100939: PUSH
100940: LD_INT 1
100942: ARRAY
100943: PPUSH
100944: CALL_OW 250
100948: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100949: LD_ADDR_VAR 0 11
100953: PUSH
100954: LD_VAR 0 14
100958: PUSH
100959: LD_INT 1
100961: ARRAY
100962: PPUSH
100963: CALL_OW 251
100967: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100968: LD_ADDR_VAR 0 12
100972: PUSH
100973: LD_VAR 0 4
100977: PUSH
100978: LD_VAR 0 7
100982: ARRAY
100983: PPUSH
100984: CALL 82424 0 1
100988: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100989: LD_VAR 0 4
100993: PUSH
100994: LD_VAR 0 7
100998: ARRAY
100999: PPUSH
101000: LD_VAR 0 10
101004: PPUSH
101005: LD_VAR 0 11
101009: PPUSH
101010: LD_VAR 0 14
101014: PUSH
101015: LD_INT 1
101017: ARRAY
101018: PPUSH
101019: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101023: LD_VAR 0 4
101027: PUSH
101028: LD_VAR 0 7
101032: ARRAY
101033: PPUSH
101034: LD_VAR 0 10
101038: PPUSH
101039: LD_VAR 0 12
101043: PPUSH
101044: LD_INT 7
101046: PPUSH
101047: CALL_OW 272
101051: PPUSH
101052: LD_VAR 0 11
101056: PPUSH
101057: LD_VAR 0 12
101061: PPUSH
101062: LD_INT 7
101064: PPUSH
101065: CALL_OW 273
101069: PPUSH
101070: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101074: LD_VAR 0 4
101078: PUSH
101079: LD_VAR 0 7
101083: ARRAY
101084: PPUSH
101085: LD_INT 71
101087: PPUSH
101088: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101092: LD_ADDR_VAR 0 27
101096: PUSH
101097: LD_VAR 0 27
101101: PPUSH
101102: LD_VAR 0 27
101106: PUSH
101107: LD_INT 1
101109: PLUS
101110: PPUSH
101111: LD_VAR 0 14
101115: PUSH
101116: LD_INT 1
101118: ARRAY
101119: PPUSH
101120: CALL_OW 1
101124: ST_TO_ADDR
// attacking := true ;
101125: LD_ADDR_VAR 0 29
101129: PUSH
101130: LD_INT 1
101132: ST_TO_ADDR
// continue ;
101133: GO 98980
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101135: LD_VAR 0 4
101139: PUSH
101140: LD_VAR 0 7
101144: ARRAY
101145: PPUSH
101146: CALL_OW 257
101150: PUSH
101151: LD_INT 17
101153: EQUAL
101154: PUSH
101155: LD_VAR 0 4
101159: PUSH
101160: LD_VAR 0 7
101164: ARRAY
101165: PPUSH
101166: CALL_OW 110
101170: PUSH
101171: LD_INT 71
101173: EQUAL
101174: NOT
101175: AND
101176: IFFALSE 101322
// begin attacking := false ;
101178: LD_ADDR_VAR 0 29
101182: PUSH
101183: LD_INT 0
101185: ST_TO_ADDR
// k := 5 ;
101186: LD_ADDR_VAR 0 9
101190: PUSH
101191: LD_INT 5
101193: ST_TO_ADDR
// if tmp < k then
101194: LD_VAR 0 14
101198: PUSH
101199: LD_VAR 0 9
101203: LESS
101204: IFFALSE 101216
// k := tmp ;
101206: LD_ADDR_VAR 0 9
101210: PUSH
101211: LD_VAR 0 14
101215: ST_TO_ADDR
// for j = 1 to k do
101216: LD_ADDR_VAR 0 8
101220: PUSH
101221: DOUBLE
101222: LD_INT 1
101224: DEC
101225: ST_TO_ADDR
101226: LD_VAR 0 9
101230: PUSH
101231: FOR_TO
101232: IFFALSE 101320
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101234: LD_VAR 0 14
101238: PUSH
101239: LD_VAR 0 8
101243: ARRAY
101244: PUSH
101245: LD_VAR 0 14
101249: PPUSH
101250: LD_INT 58
101252: PUSH
101253: EMPTY
101254: LIST
101255: PPUSH
101256: CALL_OW 72
101260: IN
101261: NOT
101262: IFFALSE 101318
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101264: LD_VAR 0 4
101268: PUSH
101269: LD_VAR 0 7
101273: ARRAY
101274: PPUSH
101275: LD_VAR 0 14
101279: PUSH
101280: LD_VAR 0 8
101284: ARRAY
101285: PPUSH
101286: CALL_OW 115
// attacking := true ;
101290: LD_ADDR_VAR 0 29
101294: PUSH
101295: LD_INT 1
101297: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101298: LD_VAR 0 4
101302: PUSH
101303: LD_VAR 0 7
101307: ARRAY
101308: PPUSH
101309: LD_INT 71
101311: PPUSH
101312: CALL_OW 109
// continue ;
101316: GO 101231
// end ; end ;
101318: GO 101231
101320: POP
101321: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101322: LD_VAR 0 4
101326: PUSH
101327: LD_VAR 0 7
101331: ARRAY
101332: PPUSH
101333: CALL_OW 257
101337: PUSH
101338: LD_INT 8
101340: EQUAL
101341: PUSH
101342: LD_VAR 0 4
101346: PUSH
101347: LD_VAR 0 7
101351: ARRAY
101352: PPUSH
101353: CALL_OW 264
101357: PUSH
101358: LD_INT 28
101360: PUSH
101361: LD_INT 45
101363: PUSH
101364: LD_INT 7
101366: PUSH
101367: LD_INT 47
101369: PUSH
101370: EMPTY
101371: LIST
101372: LIST
101373: LIST
101374: LIST
101375: IN
101376: OR
101377: IFFALSE 101633
// begin attacking := false ;
101379: LD_ADDR_VAR 0 29
101383: PUSH
101384: LD_INT 0
101386: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101387: LD_VAR 0 14
101391: PUSH
101392: LD_INT 1
101394: ARRAY
101395: PPUSH
101396: CALL_OW 266
101400: PUSH
101401: LD_INT 32
101403: PUSH
101404: LD_INT 31
101406: PUSH
101407: LD_INT 33
101409: PUSH
101410: LD_INT 4
101412: PUSH
101413: LD_INT 5
101415: PUSH
101416: EMPTY
101417: LIST
101418: LIST
101419: LIST
101420: LIST
101421: LIST
101422: IN
101423: IFFALSE 101609
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101425: LD_ADDR_VAR 0 9
101429: PUSH
101430: LD_VAR 0 14
101434: PUSH
101435: LD_INT 1
101437: ARRAY
101438: PPUSH
101439: CALL_OW 266
101443: PPUSH
101444: LD_VAR 0 14
101448: PUSH
101449: LD_INT 1
101451: ARRAY
101452: PPUSH
101453: CALL_OW 250
101457: PPUSH
101458: LD_VAR 0 14
101462: PUSH
101463: LD_INT 1
101465: ARRAY
101466: PPUSH
101467: CALL_OW 251
101471: PPUSH
101472: LD_VAR 0 14
101476: PUSH
101477: LD_INT 1
101479: ARRAY
101480: PPUSH
101481: CALL_OW 254
101485: PPUSH
101486: LD_VAR 0 14
101490: PUSH
101491: LD_INT 1
101493: ARRAY
101494: PPUSH
101495: CALL_OW 248
101499: PPUSH
101500: LD_INT 0
101502: PPUSH
101503: CALL 63794 0 6
101507: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101508: LD_ADDR_VAR 0 8
101512: PUSH
101513: LD_VAR 0 4
101517: PUSH
101518: LD_VAR 0 7
101522: ARRAY
101523: PPUSH
101524: LD_VAR 0 9
101528: PPUSH
101529: CALL 82464 0 2
101533: ST_TO_ADDR
// if j then
101534: LD_VAR 0 8
101538: IFFALSE 101607
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101540: LD_VAR 0 8
101544: PUSH
101545: LD_INT 1
101547: ARRAY
101548: PPUSH
101549: LD_VAR 0 8
101553: PUSH
101554: LD_INT 2
101556: ARRAY
101557: PPUSH
101558: CALL_OW 488
101562: IFFALSE 101607
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101564: LD_VAR 0 4
101568: PUSH
101569: LD_VAR 0 7
101573: ARRAY
101574: PPUSH
101575: LD_VAR 0 8
101579: PUSH
101580: LD_INT 1
101582: ARRAY
101583: PPUSH
101584: LD_VAR 0 8
101588: PUSH
101589: LD_INT 2
101591: ARRAY
101592: PPUSH
101593: CALL_OW 116
// attacking := true ;
101597: LD_ADDR_VAR 0 29
101601: PUSH
101602: LD_INT 1
101604: ST_TO_ADDR
// continue ;
101605: GO 98980
// end ; end else
101607: GO 101633
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101609: LD_VAR 0 4
101613: PUSH
101614: LD_VAR 0 7
101618: ARRAY
101619: PPUSH
101620: LD_VAR 0 14
101624: PUSH
101625: LD_INT 1
101627: ARRAY
101628: PPUSH
101629: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101633: LD_VAR 0 4
101637: PUSH
101638: LD_VAR 0 7
101642: ARRAY
101643: PPUSH
101644: CALL_OW 265
101648: PUSH
101649: LD_INT 11
101651: EQUAL
101652: IFFALSE 101930
// begin k := 10 ;
101654: LD_ADDR_VAR 0 9
101658: PUSH
101659: LD_INT 10
101661: ST_TO_ADDR
// x := 0 ;
101662: LD_ADDR_VAR 0 10
101666: PUSH
101667: LD_INT 0
101669: ST_TO_ADDR
// if tmp < k then
101670: LD_VAR 0 14
101674: PUSH
101675: LD_VAR 0 9
101679: LESS
101680: IFFALSE 101692
// k := tmp ;
101682: LD_ADDR_VAR 0 9
101686: PUSH
101687: LD_VAR 0 14
101691: ST_TO_ADDR
// for j = k downto 1 do
101692: LD_ADDR_VAR 0 8
101696: PUSH
101697: DOUBLE
101698: LD_VAR 0 9
101702: INC
101703: ST_TO_ADDR
101704: LD_INT 1
101706: PUSH
101707: FOR_DOWNTO
101708: IFFALSE 101783
// begin if GetType ( tmp [ j ] ) = unit_human then
101710: LD_VAR 0 14
101714: PUSH
101715: LD_VAR 0 8
101719: ARRAY
101720: PPUSH
101721: CALL_OW 247
101725: PUSH
101726: LD_INT 1
101728: EQUAL
101729: IFFALSE 101781
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101731: LD_VAR 0 4
101735: PUSH
101736: LD_VAR 0 7
101740: ARRAY
101741: PPUSH
101742: LD_VAR 0 14
101746: PUSH
101747: LD_VAR 0 8
101751: ARRAY
101752: PPUSH
101753: CALL 82735 0 2
// x := tmp [ j ] ;
101757: LD_ADDR_VAR 0 10
101761: PUSH
101762: LD_VAR 0 14
101766: PUSH
101767: LD_VAR 0 8
101771: ARRAY
101772: ST_TO_ADDR
// attacking := true ;
101773: LD_ADDR_VAR 0 29
101777: PUSH
101778: LD_INT 1
101780: ST_TO_ADDR
// end ; end ;
101781: GO 101707
101783: POP
101784: POP
// if not x then
101785: LD_VAR 0 10
101789: NOT
101790: IFFALSE 101930
// begin attacking := true ;
101792: LD_ADDR_VAR 0 29
101796: PUSH
101797: LD_INT 1
101799: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101800: LD_VAR 0 4
101804: PUSH
101805: LD_VAR 0 7
101809: ARRAY
101810: PPUSH
101811: CALL_OW 250
101815: PPUSH
101816: LD_VAR 0 4
101820: PUSH
101821: LD_VAR 0 7
101825: ARRAY
101826: PPUSH
101827: CALL_OW 251
101831: PPUSH
101832: CALL_OW 546
101836: PUSH
101837: LD_INT 2
101839: ARRAY
101840: PUSH
101841: LD_VAR 0 14
101845: PUSH
101846: LD_INT 1
101848: ARRAY
101849: PPUSH
101850: CALL_OW 250
101854: PPUSH
101855: LD_VAR 0 14
101859: PUSH
101860: LD_INT 1
101862: ARRAY
101863: PPUSH
101864: CALL_OW 251
101868: PPUSH
101869: CALL_OW 546
101873: PUSH
101874: LD_INT 2
101876: ARRAY
101877: EQUAL
101878: IFFALSE 101906
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101880: LD_VAR 0 4
101884: PUSH
101885: LD_VAR 0 7
101889: ARRAY
101890: PPUSH
101891: LD_VAR 0 14
101895: PUSH
101896: LD_INT 1
101898: ARRAY
101899: PPUSH
101900: CALL 82735 0 2
101904: GO 101930
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101906: LD_VAR 0 4
101910: PUSH
101911: LD_VAR 0 7
101915: ARRAY
101916: PPUSH
101917: LD_VAR 0 14
101921: PUSH
101922: LD_INT 1
101924: ARRAY
101925: PPUSH
101926: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101930: LD_VAR 0 4
101934: PUSH
101935: LD_VAR 0 7
101939: ARRAY
101940: PPUSH
101941: CALL_OW 264
101945: PUSH
101946: LD_INT 29
101948: EQUAL
101949: IFFALSE 102315
// begin if WantsToAttack ( group [ i ] ) in bombed then
101951: LD_VAR 0 4
101955: PUSH
101956: LD_VAR 0 7
101960: ARRAY
101961: PPUSH
101962: CALL_OW 319
101966: PUSH
101967: LD_VAR 0 28
101971: IN
101972: IFFALSE 101976
// continue ;
101974: GO 98980
// k := 8 ;
101976: LD_ADDR_VAR 0 9
101980: PUSH
101981: LD_INT 8
101983: ST_TO_ADDR
// x := 0 ;
101984: LD_ADDR_VAR 0 10
101988: PUSH
101989: LD_INT 0
101991: ST_TO_ADDR
// if tmp < k then
101992: LD_VAR 0 14
101996: PUSH
101997: LD_VAR 0 9
102001: LESS
102002: IFFALSE 102014
// k := tmp ;
102004: LD_ADDR_VAR 0 9
102008: PUSH
102009: LD_VAR 0 14
102013: ST_TO_ADDR
// for j = 1 to k do
102014: LD_ADDR_VAR 0 8
102018: PUSH
102019: DOUBLE
102020: LD_INT 1
102022: DEC
102023: ST_TO_ADDR
102024: LD_VAR 0 9
102028: PUSH
102029: FOR_TO
102030: IFFALSE 102162
// begin if GetType ( tmp [ j ] ) = unit_building then
102032: LD_VAR 0 14
102036: PUSH
102037: LD_VAR 0 8
102041: ARRAY
102042: PPUSH
102043: CALL_OW 247
102047: PUSH
102048: LD_INT 3
102050: EQUAL
102051: IFFALSE 102160
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102053: LD_VAR 0 14
102057: PUSH
102058: LD_VAR 0 8
102062: ARRAY
102063: PUSH
102064: LD_VAR 0 28
102068: IN
102069: NOT
102070: PUSH
102071: LD_VAR 0 14
102075: PUSH
102076: LD_VAR 0 8
102080: ARRAY
102081: PPUSH
102082: CALL_OW 313
102086: AND
102087: IFFALSE 102160
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102089: LD_VAR 0 4
102093: PUSH
102094: LD_VAR 0 7
102098: ARRAY
102099: PPUSH
102100: LD_VAR 0 14
102104: PUSH
102105: LD_VAR 0 8
102109: ARRAY
102110: PPUSH
102111: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102115: LD_ADDR_VAR 0 28
102119: PUSH
102120: LD_VAR 0 28
102124: PPUSH
102125: LD_VAR 0 28
102129: PUSH
102130: LD_INT 1
102132: PLUS
102133: PPUSH
102134: LD_VAR 0 14
102138: PUSH
102139: LD_VAR 0 8
102143: ARRAY
102144: PPUSH
102145: CALL_OW 1
102149: ST_TO_ADDR
// attacking := true ;
102150: LD_ADDR_VAR 0 29
102154: PUSH
102155: LD_INT 1
102157: ST_TO_ADDR
// break ;
102158: GO 102162
// end ; end ;
102160: GO 102029
102162: POP
102163: POP
// if not attacking and f_attack_depot then
102164: LD_VAR 0 29
102168: NOT
102169: PUSH
102170: LD_VAR 0 25
102174: AND
102175: IFFALSE 102270
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102177: LD_ADDR_VAR 0 13
102181: PUSH
102182: LD_VAR 0 14
102186: PPUSH
102187: LD_INT 2
102189: PUSH
102190: LD_INT 30
102192: PUSH
102193: LD_INT 0
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: PUSH
102200: LD_INT 30
102202: PUSH
102203: LD_INT 1
102205: PUSH
102206: EMPTY
102207: LIST
102208: LIST
102209: PUSH
102210: EMPTY
102211: LIST
102212: LIST
102213: LIST
102214: PPUSH
102215: CALL_OW 72
102219: ST_TO_ADDR
// if z then
102220: LD_VAR 0 13
102224: IFFALSE 102270
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102226: LD_VAR 0 4
102230: PUSH
102231: LD_VAR 0 7
102235: ARRAY
102236: PPUSH
102237: LD_VAR 0 13
102241: PPUSH
102242: LD_VAR 0 4
102246: PUSH
102247: LD_VAR 0 7
102251: ARRAY
102252: PPUSH
102253: CALL_OW 74
102257: PPUSH
102258: CALL_OW 115
// attacking := true ;
102262: LD_ADDR_VAR 0 29
102266: PUSH
102267: LD_INT 1
102269: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102270: LD_VAR 0 4
102274: PUSH
102275: LD_VAR 0 7
102279: ARRAY
102280: PPUSH
102281: CALL_OW 256
102285: PUSH
102286: LD_INT 500
102288: LESS
102289: IFFALSE 102315
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102291: LD_VAR 0 4
102295: PUSH
102296: LD_VAR 0 7
102300: ARRAY
102301: PPUSH
102302: LD_VAR 0 14
102306: PUSH
102307: LD_INT 1
102309: ARRAY
102310: PPUSH
102311: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102315: LD_VAR 0 4
102319: PUSH
102320: LD_VAR 0 7
102324: ARRAY
102325: PPUSH
102326: CALL_OW 264
102330: PUSH
102331: LD_INT 49
102333: EQUAL
102334: IFFALSE 102455
// begin if not HasTask ( group [ i ] ) then
102336: LD_VAR 0 4
102340: PUSH
102341: LD_VAR 0 7
102345: ARRAY
102346: PPUSH
102347: CALL_OW 314
102351: NOT
102352: IFFALSE 102455
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102354: LD_ADDR_VAR 0 9
102358: PUSH
102359: LD_INT 81
102361: PUSH
102362: LD_VAR 0 4
102366: PUSH
102367: LD_VAR 0 7
102371: ARRAY
102372: PPUSH
102373: CALL_OW 255
102377: PUSH
102378: EMPTY
102379: LIST
102380: LIST
102381: PPUSH
102382: CALL_OW 69
102386: PPUSH
102387: LD_VAR 0 4
102391: PUSH
102392: LD_VAR 0 7
102396: ARRAY
102397: PPUSH
102398: CALL_OW 74
102402: ST_TO_ADDR
// if k then
102403: LD_VAR 0 9
102407: IFFALSE 102455
// if GetDistUnits ( group [ i ] , k ) > 10 then
102409: LD_VAR 0 4
102413: PUSH
102414: LD_VAR 0 7
102418: ARRAY
102419: PPUSH
102420: LD_VAR 0 9
102424: PPUSH
102425: CALL_OW 296
102429: PUSH
102430: LD_INT 10
102432: GREATER
102433: IFFALSE 102455
// ComMoveUnit ( group [ i ] , k ) ;
102435: LD_VAR 0 4
102439: PUSH
102440: LD_VAR 0 7
102444: ARRAY
102445: PPUSH
102446: LD_VAR 0 9
102450: PPUSH
102451: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102455: LD_VAR 0 4
102459: PUSH
102460: LD_VAR 0 7
102464: ARRAY
102465: PPUSH
102466: CALL_OW 256
102470: PUSH
102471: LD_INT 250
102473: LESS
102474: PUSH
102475: LD_VAR 0 4
102479: PUSH
102480: LD_VAR 0 7
102484: ARRAY
102485: PUSH
102486: LD_INT 21
102488: PUSH
102489: LD_INT 2
102491: PUSH
102492: EMPTY
102493: LIST
102494: LIST
102495: PUSH
102496: LD_INT 23
102498: PUSH
102499: LD_INT 2
102501: PUSH
102502: EMPTY
102503: LIST
102504: LIST
102505: PUSH
102506: EMPTY
102507: LIST
102508: LIST
102509: PPUSH
102510: CALL_OW 69
102514: IN
102515: AND
102516: IFFALSE 102641
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102518: LD_ADDR_VAR 0 9
102522: PUSH
102523: LD_OWVAR 3
102527: PUSH
102528: LD_VAR 0 4
102532: PUSH
102533: LD_VAR 0 7
102537: ARRAY
102538: DIFF
102539: PPUSH
102540: LD_VAR 0 4
102544: PUSH
102545: LD_VAR 0 7
102549: ARRAY
102550: PPUSH
102551: CALL_OW 74
102555: ST_TO_ADDR
// if not k then
102556: LD_VAR 0 9
102560: NOT
102561: IFFALSE 102565
// continue ;
102563: GO 98980
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102565: LD_VAR 0 9
102569: PUSH
102570: LD_INT 81
102572: PUSH
102573: LD_VAR 0 4
102577: PUSH
102578: LD_VAR 0 7
102582: ARRAY
102583: PPUSH
102584: CALL_OW 255
102588: PUSH
102589: EMPTY
102590: LIST
102591: LIST
102592: PPUSH
102593: CALL_OW 69
102597: IN
102598: PUSH
102599: LD_VAR 0 9
102603: PPUSH
102604: LD_VAR 0 4
102608: PUSH
102609: LD_VAR 0 7
102613: ARRAY
102614: PPUSH
102615: CALL_OW 296
102619: PUSH
102620: LD_INT 5
102622: LESS
102623: AND
102624: IFFALSE 102641
// ComAutodestruct ( group [ i ] ) ;
102626: LD_VAR 0 4
102630: PUSH
102631: LD_VAR 0 7
102635: ARRAY
102636: PPUSH
102637: CALL 82633 0 1
// end ; if f_attack_depot then
102641: LD_VAR 0 25
102645: IFFALSE 102757
// begin k := 6 ;
102647: LD_ADDR_VAR 0 9
102651: PUSH
102652: LD_INT 6
102654: ST_TO_ADDR
// if tmp < k then
102655: LD_VAR 0 14
102659: PUSH
102660: LD_VAR 0 9
102664: LESS
102665: IFFALSE 102677
// k := tmp ;
102667: LD_ADDR_VAR 0 9
102671: PUSH
102672: LD_VAR 0 14
102676: ST_TO_ADDR
// for j = 1 to k do
102677: LD_ADDR_VAR 0 8
102681: PUSH
102682: DOUBLE
102683: LD_INT 1
102685: DEC
102686: ST_TO_ADDR
102687: LD_VAR 0 9
102691: PUSH
102692: FOR_TO
102693: IFFALSE 102755
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102695: LD_VAR 0 8
102699: PPUSH
102700: CALL_OW 266
102704: PUSH
102705: LD_INT 0
102707: PUSH
102708: LD_INT 1
102710: PUSH
102711: EMPTY
102712: LIST
102713: LIST
102714: IN
102715: IFFALSE 102753
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102717: LD_VAR 0 4
102721: PUSH
102722: LD_VAR 0 7
102726: ARRAY
102727: PPUSH
102728: LD_VAR 0 14
102732: PUSH
102733: LD_VAR 0 8
102737: ARRAY
102738: PPUSH
102739: CALL_OW 115
// attacking := true ;
102743: LD_ADDR_VAR 0 29
102747: PUSH
102748: LD_INT 1
102750: ST_TO_ADDR
// break ;
102751: GO 102755
// end ;
102753: GO 102692
102755: POP
102756: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102757: LD_VAR 0 4
102761: PUSH
102762: LD_VAR 0 7
102766: ARRAY
102767: PPUSH
102768: CALL_OW 302
102772: PUSH
102773: LD_VAR 0 29
102777: NOT
102778: AND
102779: IFFALSE 103101
// begin if GetTag ( group [ i ] ) = 71 then
102781: LD_VAR 0 4
102785: PUSH
102786: LD_VAR 0 7
102790: ARRAY
102791: PPUSH
102792: CALL_OW 110
102796: PUSH
102797: LD_INT 71
102799: EQUAL
102800: IFFALSE 102841
// begin if HasTask ( group [ i ] ) then
102802: LD_VAR 0 4
102806: PUSH
102807: LD_VAR 0 7
102811: ARRAY
102812: PPUSH
102813: CALL_OW 314
102817: IFFALSE 102823
// continue else
102819: GO 98980
102821: GO 102841
// SetTag ( group [ i ] , 0 ) ;
102823: LD_VAR 0 4
102827: PUSH
102828: LD_VAR 0 7
102832: ARRAY
102833: PPUSH
102834: LD_INT 0
102836: PPUSH
102837: CALL_OW 109
// end ; k := 8 ;
102841: LD_ADDR_VAR 0 9
102845: PUSH
102846: LD_INT 8
102848: ST_TO_ADDR
// x := 0 ;
102849: LD_ADDR_VAR 0 10
102853: PUSH
102854: LD_INT 0
102856: ST_TO_ADDR
// if tmp < k then
102857: LD_VAR 0 14
102861: PUSH
102862: LD_VAR 0 9
102866: LESS
102867: IFFALSE 102879
// k := tmp ;
102869: LD_ADDR_VAR 0 9
102873: PUSH
102874: LD_VAR 0 14
102878: ST_TO_ADDR
// for j = 1 to k do
102879: LD_ADDR_VAR 0 8
102883: PUSH
102884: DOUBLE
102885: LD_INT 1
102887: DEC
102888: ST_TO_ADDR
102889: LD_VAR 0 9
102893: PUSH
102894: FOR_TO
102895: IFFALSE 102993
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102897: LD_VAR 0 14
102901: PUSH
102902: LD_VAR 0 8
102906: ARRAY
102907: PPUSH
102908: CALL_OW 247
102912: PUSH
102913: LD_INT 1
102915: EQUAL
102916: PUSH
102917: LD_VAR 0 14
102921: PUSH
102922: LD_VAR 0 8
102926: ARRAY
102927: PPUSH
102928: CALL_OW 256
102932: PUSH
102933: LD_INT 250
102935: LESS
102936: PUSH
102937: LD_VAR 0 20
102941: AND
102942: PUSH
102943: LD_VAR 0 20
102947: NOT
102948: PUSH
102949: LD_VAR 0 14
102953: PUSH
102954: LD_VAR 0 8
102958: ARRAY
102959: PPUSH
102960: CALL_OW 256
102964: PUSH
102965: LD_INT 250
102967: GREATEREQUAL
102968: AND
102969: OR
102970: AND
102971: IFFALSE 102991
// begin x := tmp [ j ] ;
102973: LD_ADDR_VAR 0 10
102977: PUSH
102978: LD_VAR 0 14
102982: PUSH
102983: LD_VAR 0 8
102987: ARRAY
102988: ST_TO_ADDR
// break ;
102989: GO 102993
// end ;
102991: GO 102894
102993: POP
102994: POP
// if x then
102995: LD_VAR 0 10
102999: IFFALSE 103023
// ComAttackUnit ( group [ i ] , x ) else
103001: LD_VAR 0 4
103005: PUSH
103006: LD_VAR 0 7
103010: ARRAY
103011: PPUSH
103012: LD_VAR 0 10
103016: PPUSH
103017: CALL_OW 115
103021: GO 103047
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103023: LD_VAR 0 4
103027: PUSH
103028: LD_VAR 0 7
103032: ARRAY
103033: PPUSH
103034: LD_VAR 0 14
103038: PUSH
103039: LD_INT 1
103041: ARRAY
103042: PPUSH
103043: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103047: LD_VAR 0 4
103051: PUSH
103052: LD_VAR 0 7
103056: ARRAY
103057: PPUSH
103058: CALL_OW 314
103062: NOT
103063: IFFALSE 103101
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103065: LD_VAR 0 4
103069: PUSH
103070: LD_VAR 0 7
103074: ARRAY
103075: PPUSH
103076: LD_VAR 0 14
103080: PPUSH
103081: LD_VAR 0 4
103085: PUSH
103086: LD_VAR 0 7
103090: ARRAY
103091: PPUSH
103092: CALL_OW 74
103096: PPUSH
103097: CALL_OW 115
// end ; end ; end ;
103101: GO 98980
103103: POP
103104: POP
// wait ( 0 0$2 ) ;
103105: LD_INT 70
103107: PPUSH
103108: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103112: LD_VAR 0 4
103116: NOT
103117: PUSH
103118: LD_VAR 0 4
103122: PUSH
103123: EMPTY
103124: EQUAL
103125: OR
103126: PUSH
103127: LD_INT 81
103129: PUSH
103130: LD_VAR 0 35
103134: PUSH
103135: EMPTY
103136: LIST
103137: LIST
103138: PPUSH
103139: CALL_OW 69
103143: NOT
103144: OR
103145: IFFALSE 98965
// end ;
103147: LD_VAR 0 2
103151: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
103152: LD_INT 0
103154: PPUSH
103155: PPUSH
103156: PPUSH
103157: PPUSH
103158: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
103159: LD_VAR 0 1
103163: NOT
103164: PUSH
103165: LD_EXP 87
103169: PUSH
103170: LD_VAR 0 1
103174: ARRAY
103175: NOT
103176: OR
103177: PUSH
103178: LD_VAR 0 2
103182: NOT
103183: OR
103184: PUSH
103185: LD_VAR 0 3
103189: NOT
103190: OR
103191: IFFALSE 103195
// exit ;
103193: GO 103708
// side := mc_sides [ base ] ;
103195: LD_ADDR_VAR 0 6
103199: PUSH
103200: LD_EXP 113
103204: PUSH
103205: LD_VAR 0 1
103209: ARRAY
103210: ST_TO_ADDR
// if not side then
103211: LD_VAR 0 6
103215: NOT
103216: IFFALSE 103220
// exit ;
103218: GO 103708
// for i in solds do
103220: LD_ADDR_VAR 0 7
103224: PUSH
103225: LD_VAR 0 2
103229: PUSH
103230: FOR_IN
103231: IFFALSE 103292
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
103233: LD_VAR 0 7
103237: PPUSH
103238: CALL_OW 310
103242: PPUSH
103243: CALL_OW 266
103247: PUSH
103248: LD_INT 32
103250: PUSH
103251: LD_INT 31
103253: PUSH
103254: EMPTY
103255: LIST
103256: LIST
103257: IN
103258: IFFALSE 103278
// solds := solds diff i else
103260: LD_ADDR_VAR 0 2
103264: PUSH
103265: LD_VAR 0 2
103269: PUSH
103270: LD_VAR 0 7
103274: DIFF
103275: ST_TO_ADDR
103276: GO 103290
// SetTag ( i , 18 ) ;
103278: LD_VAR 0 7
103282: PPUSH
103283: LD_INT 18
103285: PPUSH
103286: CALL_OW 109
103290: GO 103230
103292: POP
103293: POP
// if not solds then
103294: LD_VAR 0 2
103298: NOT
103299: IFFALSE 103303
// exit ;
103301: GO 103708
// repeat wait ( 0 0$1 ) ;
103303: LD_INT 35
103305: PPUSH
103306: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
103310: LD_ADDR_VAR 0 5
103314: PUSH
103315: LD_VAR 0 6
103319: PPUSH
103320: LD_VAR 0 3
103324: PPUSH
103325: CALL 52348 0 2
103329: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103330: LD_EXP 87
103334: PUSH
103335: LD_VAR 0 1
103339: ARRAY
103340: NOT
103341: PUSH
103342: LD_EXP 87
103346: PUSH
103347: LD_VAR 0 1
103351: ARRAY
103352: PUSH
103353: EMPTY
103354: EQUAL
103355: OR
103356: IFFALSE 103393
// begin for i in solds do
103358: LD_ADDR_VAR 0 7
103362: PUSH
103363: LD_VAR 0 2
103367: PUSH
103368: FOR_IN
103369: IFFALSE 103382
// ComStop ( i ) ;
103371: LD_VAR 0 7
103375: PPUSH
103376: CALL_OW 141
103380: GO 103368
103382: POP
103383: POP
// solds := [ ] ;
103384: LD_ADDR_VAR 0 2
103388: PUSH
103389: EMPTY
103390: ST_TO_ADDR
// exit ;
103391: GO 103708
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
103393: LD_VAR 0 5
103397: NOT
103398: PUSH
103399: LD_VAR 0 5
103403: PUSH
103404: LD_INT 3
103406: GREATER
103407: OR
103408: PUSH
103409: LD_EXP 109
103413: PUSH
103414: LD_VAR 0 1
103418: ARRAY
103419: OR
103420: IFFALSE 103461
// begin for i in solds do
103422: LD_ADDR_VAR 0 7
103426: PUSH
103427: LD_VAR 0 2
103431: PUSH
103432: FOR_IN
103433: IFFALSE 103457
// if HasTask ( i ) then
103435: LD_VAR 0 7
103439: PPUSH
103440: CALL_OW 314
103444: IFFALSE 103455
// ComStop ( i ) ;
103446: LD_VAR 0 7
103450: PPUSH
103451: CALL_OW 141
103455: GO 103432
103457: POP
103458: POP
// break ;
103459: GO 103696
// end ; for i in solds do
103461: LD_ADDR_VAR 0 7
103465: PUSH
103466: LD_VAR 0 2
103470: PUSH
103471: FOR_IN
103472: IFFALSE 103688
// begin if IsInUnit ( i ) then
103474: LD_VAR 0 7
103478: PPUSH
103479: CALL_OW 310
103483: IFFALSE 103494
// ComExitBuilding ( i ) ;
103485: LD_VAR 0 7
103489: PPUSH
103490: CALL_OW 122
// if GetLives ( i ) > 333 then
103494: LD_VAR 0 7
103498: PPUSH
103499: CALL_OW 256
103503: PUSH
103504: LD_INT 333
103506: GREATER
103507: IFFALSE 103535
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103509: LD_VAR 0 7
103513: PPUSH
103514: LD_VAR 0 5
103518: PPUSH
103519: LD_VAR 0 7
103523: PPUSH
103524: CALL_OW 74
103528: PPUSH
103529: CALL_OW 115
103533: GO 103686
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
103535: LD_ADDR_VAR 0 8
103539: PUSH
103540: LD_EXP 87
103544: PUSH
103545: LD_VAR 0 1
103549: ARRAY
103550: PPUSH
103551: LD_INT 2
103553: PUSH
103554: LD_INT 30
103556: PUSH
103557: LD_INT 0
103559: PUSH
103560: EMPTY
103561: LIST
103562: LIST
103563: PUSH
103564: LD_INT 30
103566: PUSH
103567: LD_INT 1
103569: PUSH
103570: EMPTY
103571: LIST
103572: LIST
103573: PUSH
103574: LD_INT 30
103576: PUSH
103577: LD_INT 6
103579: PUSH
103580: EMPTY
103581: LIST
103582: LIST
103583: PUSH
103584: EMPTY
103585: LIST
103586: LIST
103587: LIST
103588: LIST
103589: PPUSH
103590: CALL_OW 72
103594: PPUSH
103595: LD_VAR 0 7
103599: PPUSH
103600: CALL_OW 74
103604: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
103605: LD_VAR 0 7
103609: PPUSH
103610: LD_VAR 0 8
103614: PPUSH
103615: CALL_OW 250
103619: PPUSH
103620: LD_INT 3
103622: PPUSH
103623: LD_INT 5
103625: PPUSH
103626: CALL_OW 272
103630: PPUSH
103631: LD_VAR 0 8
103635: PPUSH
103636: CALL_OW 251
103640: PPUSH
103641: LD_INT 3
103643: PPUSH
103644: LD_INT 5
103646: PPUSH
103647: CALL_OW 273
103651: PPUSH
103652: CALL_OW 111
// SetTag ( i , 0 ) ;
103656: LD_VAR 0 7
103660: PPUSH
103661: LD_INT 0
103663: PPUSH
103664: CALL_OW 109
// solds := solds diff i ;
103668: LD_ADDR_VAR 0 2
103672: PUSH
103673: LD_VAR 0 2
103677: PUSH
103678: LD_VAR 0 7
103682: DIFF
103683: ST_TO_ADDR
// continue ;
103684: GO 103471
// end ; end ;
103686: GO 103471
103688: POP
103689: POP
// until solds ;
103690: LD_VAR 0 2
103694: IFFALSE 103303
// MC_Reset ( base , 18 ) ;
103696: LD_VAR 0 1
103700: PPUSH
103701: LD_INT 18
103703: PPUSH
103704: CALL 24656 0 2
// end ;
103708: LD_VAR 0 4
103712: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
103713: LD_INT 0
103715: PPUSH
103716: PPUSH
103717: PPUSH
103718: PPUSH
103719: PPUSH
103720: PPUSH
103721: PPUSH
103722: PPUSH
103723: PPUSH
103724: PPUSH
103725: PPUSH
103726: PPUSH
103727: PPUSH
103728: PPUSH
103729: PPUSH
103730: PPUSH
103731: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
103732: LD_ADDR_VAR 0 13
103736: PUSH
103737: LD_EXP 87
103741: PUSH
103742: LD_VAR 0 1
103746: ARRAY
103747: PPUSH
103748: LD_INT 25
103750: PUSH
103751: LD_INT 3
103753: PUSH
103754: EMPTY
103755: LIST
103756: LIST
103757: PPUSH
103758: CALL_OW 72
103762: ST_TO_ADDR
// if mc_remote_driver [ base ] then
103763: LD_EXP 127
103767: PUSH
103768: LD_VAR 0 1
103772: ARRAY
103773: IFFALSE 103797
// mechs := mechs diff mc_remote_driver [ base ] ;
103775: LD_ADDR_VAR 0 13
103779: PUSH
103780: LD_VAR 0 13
103784: PUSH
103785: LD_EXP 127
103789: PUSH
103790: LD_VAR 0 1
103794: ARRAY
103795: DIFF
103796: ST_TO_ADDR
// for i in mechs do
103797: LD_ADDR_VAR 0 5
103801: PUSH
103802: LD_VAR 0 13
103806: PUSH
103807: FOR_IN
103808: IFFALSE 103843
// if GetTag ( i ) > 0 then
103810: LD_VAR 0 5
103814: PPUSH
103815: CALL_OW 110
103819: PUSH
103820: LD_INT 0
103822: GREATER
103823: IFFALSE 103841
// mechs := mechs diff i ;
103825: LD_ADDR_VAR 0 13
103829: PUSH
103830: LD_VAR 0 13
103834: PUSH
103835: LD_VAR 0 5
103839: DIFF
103840: ST_TO_ADDR
103841: GO 103807
103843: POP
103844: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
103845: LD_ADDR_VAR 0 9
103849: PUSH
103850: LD_EXP 87
103854: PUSH
103855: LD_VAR 0 1
103859: ARRAY
103860: PPUSH
103861: LD_INT 2
103863: PUSH
103864: LD_INT 25
103866: PUSH
103867: LD_INT 1
103869: PUSH
103870: EMPTY
103871: LIST
103872: LIST
103873: PUSH
103874: LD_INT 25
103876: PUSH
103877: LD_INT 5
103879: PUSH
103880: EMPTY
103881: LIST
103882: LIST
103883: PUSH
103884: LD_INT 25
103886: PUSH
103887: LD_INT 8
103889: PUSH
103890: EMPTY
103891: LIST
103892: LIST
103893: PUSH
103894: LD_INT 25
103896: PUSH
103897: LD_INT 9
103899: PUSH
103900: EMPTY
103901: LIST
103902: LIST
103903: PUSH
103904: EMPTY
103905: LIST
103906: LIST
103907: LIST
103908: LIST
103909: LIST
103910: PPUSH
103911: CALL_OW 72
103915: ST_TO_ADDR
// if not defenders and not solds then
103916: LD_VAR 0 2
103920: NOT
103921: PUSH
103922: LD_VAR 0 9
103926: NOT
103927: AND
103928: IFFALSE 103932
// exit ;
103930: GO 105558
// depot_under_attack := false ;
103932: LD_ADDR_VAR 0 17
103936: PUSH
103937: LD_INT 0
103939: ST_TO_ADDR
// sold_defenders := [ ] ;
103940: LD_ADDR_VAR 0 18
103944: PUSH
103945: EMPTY
103946: ST_TO_ADDR
// if mechs then
103947: LD_VAR 0 13
103951: IFFALSE 104080
// for i in defenders do
103953: LD_ADDR_VAR 0 5
103957: PUSH
103958: LD_VAR 0 2
103962: PUSH
103963: FOR_IN
103964: IFFALSE 104078
// begin SetTag ( i , 20 ) ;
103966: LD_VAR 0 5
103970: PPUSH
103971: LD_INT 20
103973: PPUSH
103974: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
103978: LD_VAR 0 5
103982: PPUSH
103983: CALL_OW 263
103987: PUSH
103988: LD_INT 1
103990: EQUAL
103991: PUSH
103992: LD_VAR 0 5
103996: PPUSH
103997: CALL_OW 311
104001: NOT
104002: AND
104003: PUSH
104004: LD_VAR 0 13
104008: AND
104009: IFFALSE 104076
// begin un := mechs [ 1 ] ;
104011: LD_ADDR_VAR 0 11
104015: PUSH
104016: LD_VAR 0 13
104020: PUSH
104021: LD_INT 1
104023: ARRAY
104024: ST_TO_ADDR
// ComExitBuilding ( un ) ;
104025: LD_VAR 0 11
104029: PPUSH
104030: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
104034: LD_VAR 0 11
104038: PPUSH
104039: LD_VAR 0 5
104043: PPUSH
104044: CALL_OW 180
// SetTag ( un , 19 ) ;
104048: LD_VAR 0 11
104052: PPUSH
104053: LD_INT 19
104055: PPUSH
104056: CALL_OW 109
// mechs := mechs diff un ;
104060: LD_ADDR_VAR 0 13
104064: PUSH
104065: LD_VAR 0 13
104069: PUSH
104070: LD_VAR 0 11
104074: DIFF
104075: ST_TO_ADDR
// end ; end ;
104076: GO 103963
104078: POP
104079: POP
// if solds then
104080: LD_VAR 0 9
104084: IFFALSE 104143
// for i in solds do
104086: LD_ADDR_VAR 0 5
104090: PUSH
104091: LD_VAR 0 9
104095: PUSH
104096: FOR_IN
104097: IFFALSE 104141
// if not GetTag ( i ) then
104099: LD_VAR 0 5
104103: PPUSH
104104: CALL_OW 110
104108: NOT
104109: IFFALSE 104139
// begin defenders := defenders union i ;
104111: LD_ADDR_VAR 0 2
104115: PUSH
104116: LD_VAR 0 2
104120: PUSH
104121: LD_VAR 0 5
104125: UNION
104126: ST_TO_ADDR
// SetTag ( i , 18 ) ;
104127: LD_VAR 0 5
104131: PPUSH
104132: LD_INT 18
104134: PPUSH
104135: CALL_OW 109
// end ;
104139: GO 104096
104141: POP
104142: POP
// repeat wait ( 0 0$1 ) ;
104143: LD_INT 35
104145: PPUSH
104146: CALL_OW 67
// enemy := mc_scan [ base ] ;
104150: LD_ADDR_VAR 0 3
104154: PUSH
104155: LD_EXP 110
104159: PUSH
104160: LD_VAR 0 1
104164: ARRAY
104165: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104166: LD_EXP 87
104170: PUSH
104171: LD_VAR 0 1
104175: ARRAY
104176: NOT
104177: PUSH
104178: LD_EXP 87
104182: PUSH
104183: LD_VAR 0 1
104187: ARRAY
104188: PUSH
104189: EMPTY
104190: EQUAL
104191: OR
104192: IFFALSE 104229
// begin for i in defenders do
104194: LD_ADDR_VAR 0 5
104198: PUSH
104199: LD_VAR 0 2
104203: PUSH
104204: FOR_IN
104205: IFFALSE 104218
// ComStop ( i ) ;
104207: LD_VAR 0 5
104211: PPUSH
104212: CALL_OW 141
104216: GO 104204
104218: POP
104219: POP
// defenders := [ ] ;
104220: LD_ADDR_VAR 0 2
104224: PUSH
104225: EMPTY
104226: ST_TO_ADDR
// exit ;
104227: GO 105558
// end ; for i in defenders do
104229: LD_ADDR_VAR 0 5
104233: PUSH
104234: LD_VAR 0 2
104238: PUSH
104239: FOR_IN
104240: IFFALSE 105058
// begin e := NearestUnitToUnit ( enemy , i ) ;
104242: LD_ADDR_VAR 0 14
104246: PUSH
104247: LD_VAR 0 3
104251: PPUSH
104252: LD_VAR 0 5
104256: PPUSH
104257: CALL_OW 74
104261: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104262: LD_ADDR_VAR 0 8
104266: PUSH
104267: LD_EXP 87
104271: PUSH
104272: LD_VAR 0 1
104276: ARRAY
104277: PPUSH
104278: LD_INT 2
104280: PUSH
104281: LD_INT 30
104283: PUSH
104284: LD_INT 0
104286: PUSH
104287: EMPTY
104288: LIST
104289: LIST
104290: PUSH
104291: LD_INT 30
104293: PUSH
104294: LD_INT 1
104296: PUSH
104297: EMPTY
104298: LIST
104299: LIST
104300: PUSH
104301: EMPTY
104302: LIST
104303: LIST
104304: LIST
104305: PPUSH
104306: CALL_OW 72
104310: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
104311: LD_ADDR_VAR 0 17
104315: PUSH
104316: LD_VAR 0 8
104320: NOT
104321: PUSH
104322: LD_VAR 0 8
104326: PPUSH
104327: LD_INT 3
104329: PUSH
104330: LD_INT 24
104332: PUSH
104333: LD_INT 600
104335: PUSH
104336: EMPTY
104337: LIST
104338: LIST
104339: PUSH
104340: EMPTY
104341: LIST
104342: LIST
104343: PPUSH
104344: CALL_OW 72
104348: OR
104349: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
104350: LD_VAR 0 5
104354: PPUSH
104355: CALL_OW 247
104359: PUSH
104360: LD_INT 2
104362: DOUBLE
104363: EQUAL
104364: IFTRUE 104368
104366: GO 104764
104368: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
104369: LD_VAR 0 5
104373: PPUSH
104374: CALL_OW 256
104378: PUSH
104379: LD_INT 650
104381: GREATER
104382: PUSH
104383: LD_VAR 0 5
104387: PPUSH
104388: LD_VAR 0 14
104392: PPUSH
104393: CALL_OW 296
104397: PUSH
104398: LD_INT 40
104400: LESS
104401: PUSH
104402: LD_VAR 0 14
104406: PPUSH
104407: LD_EXP 112
104411: PUSH
104412: LD_VAR 0 1
104416: ARRAY
104417: PPUSH
104418: CALL_OW 308
104422: OR
104423: AND
104424: IFFALSE 104546
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
104426: LD_VAR 0 5
104430: PPUSH
104431: CALL_OW 262
104435: PUSH
104436: LD_INT 1
104438: EQUAL
104439: PUSH
104440: LD_VAR 0 5
104444: PPUSH
104445: CALL_OW 261
104449: PUSH
104450: LD_INT 30
104452: LESS
104453: AND
104454: PUSH
104455: LD_VAR 0 8
104459: AND
104460: IFFALSE 104530
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
104462: LD_VAR 0 5
104466: PPUSH
104467: LD_VAR 0 8
104471: PPUSH
104472: LD_VAR 0 5
104476: PPUSH
104477: CALL_OW 74
104481: PPUSH
104482: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
104486: LD_VAR 0 5
104490: PPUSH
104491: LD_VAR 0 8
104495: PPUSH
104496: LD_VAR 0 5
104500: PPUSH
104501: CALL_OW 74
104505: PPUSH
104506: CALL_OW 296
104510: PUSH
104511: LD_INT 6
104513: LESS
104514: IFFALSE 104528
// SetFuel ( i , 100 ) ;
104516: LD_VAR 0 5
104520: PPUSH
104521: LD_INT 100
104523: PPUSH
104524: CALL_OW 240
// end else
104528: GO 104544
// ComAttackUnit ( i , e ) ;
104530: LD_VAR 0 5
104534: PPUSH
104535: LD_VAR 0 14
104539: PPUSH
104540: CALL_OW 115
// end else
104544: GO 104647
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
104546: LD_VAR 0 14
104550: PPUSH
104551: LD_EXP 112
104555: PUSH
104556: LD_VAR 0 1
104560: ARRAY
104561: PPUSH
104562: CALL_OW 308
104566: NOT
104567: PUSH
104568: LD_VAR 0 5
104572: PPUSH
104573: LD_VAR 0 14
104577: PPUSH
104578: CALL_OW 296
104582: PUSH
104583: LD_INT 40
104585: GREATEREQUAL
104586: AND
104587: PUSH
104588: LD_VAR 0 5
104592: PPUSH
104593: CALL_OW 256
104597: PUSH
104598: LD_INT 650
104600: LESSEQUAL
104601: OR
104602: PUSH
104603: LD_VAR 0 5
104607: PPUSH
104608: LD_EXP 111
104612: PUSH
104613: LD_VAR 0 1
104617: ARRAY
104618: PPUSH
104619: CALL_OW 308
104623: NOT
104624: AND
104625: IFFALSE 104647
// ComMoveToArea ( i , mc_parking [ base ] ) ;
104627: LD_VAR 0 5
104631: PPUSH
104632: LD_EXP 111
104636: PUSH
104637: LD_VAR 0 1
104641: ARRAY
104642: PPUSH
104643: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
104647: LD_VAR 0 5
104651: PPUSH
104652: CALL_OW 256
104656: PUSH
104657: LD_INT 998
104659: LESS
104660: PUSH
104661: LD_VAR 0 5
104665: PPUSH
104666: CALL_OW 263
104670: PUSH
104671: LD_INT 1
104673: EQUAL
104674: AND
104675: PUSH
104676: LD_VAR 0 5
104680: PPUSH
104681: CALL_OW 311
104685: AND
104686: PUSH
104687: LD_VAR 0 5
104691: PPUSH
104692: LD_EXP 111
104696: PUSH
104697: LD_VAR 0 1
104701: ARRAY
104702: PPUSH
104703: CALL_OW 308
104707: AND
104708: IFFALSE 104762
// begin mech := IsDrivenBy ( i ) ;
104710: LD_ADDR_VAR 0 10
104714: PUSH
104715: LD_VAR 0 5
104719: PPUSH
104720: CALL_OW 311
104724: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
104725: LD_VAR 0 10
104729: PPUSH
104730: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
104734: LD_VAR 0 10
104738: PPUSH
104739: LD_VAR 0 5
104743: PPUSH
104744: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
104748: LD_VAR 0 10
104752: PPUSH
104753: LD_VAR 0 5
104757: PPUSH
104758: CALL_OW 180
// end ; end ; unit_human :
104762: GO 105029
104764: LD_INT 1
104766: DOUBLE
104767: EQUAL
104768: IFTRUE 104772
104770: GO 105028
104772: POP
// begin b := IsInUnit ( i ) ;
104773: LD_ADDR_VAR 0 19
104777: PUSH
104778: LD_VAR 0 5
104782: PPUSH
104783: CALL_OW 310
104787: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
104788: LD_ADDR_VAR 0 20
104792: PUSH
104793: LD_VAR 0 19
104797: NOT
104798: PUSH
104799: LD_VAR 0 19
104803: PPUSH
104804: CALL_OW 266
104808: PUSH
104809: LD_INT 32
104811: PUSH
104812: LD_INT 31
104814: PUSH
104815: EMPTY
104816: LIST
104817: LIST
104818: IN
104819: OR
104820: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
104821: LD_VAR 0 17
104825: PUSH
104826: LD_VAR 0 2
104830: PPUSH
104831: LD_INT 21
104833: PUSH
104834: LD_INT 2
104836: PUSH
104837: EMPTY
104838: LIST
104839: LIST
104840: PPUSH
104841: CALL_OW 72
104845: PUSH
104846: LD_INT 1
104848: LESSEQUAL
104849: OR
104850: PUSH
104851: LD_VAR 0 20
104855: AND
104856: PUSH
104857: LD_VAR 0 5
104861: PUSH
104862: LD_VAR 0 18
104866: IN
104867: NOT
104868: AND
104869: IFFALSE 104962
// begin if b then
104871: LD_VAR 0 19
104875: IFFALSE 104924
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
104877: LD_VAR 0 19
104881: PPUSH
104882: LD_VAR 0 3
104886: PPUSH
104887: LD_VAR 0 19
104891: PPUSH
104892: CALL_OW 74
104896: PPUSH
104897: CALL_OW 296
104901: PUSH
104902: LD_INT 10
104904: LESS
104905: PUSH
104906: LD_VAR 0 19
104910: PPUSH
104911: CALL_OW 461
104915: PUSH
104916: LD_INT 7
104918: NONEQUAL
104919: AND
104920: IFFALSE 104924
// continue ;
104922: GO 104239
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
104924: LD_ADDR_VAR 0 18
104928: PUSH
104929: LD_VAR 0 18
104933: PPUSH
104934: LD_VAR 0 18
104938: PUSH
104939: LD_INT 1
104941: PLUS
104942: PPUSH
104943: LD_VAR 0 5
104947: PPUSH
104948: CALL_OW 1
104952: ST_TO_ADDR
// ComExitBuilding ( i ) ;
104953: LD_VAR 0 5
104957: PPUSH
104958: CALL_OW 122
// end ; if sold_defenders then
104962: LD_VAR 0 18
104966: IFFALSE 105026
// if i in sold_defenders then
104968: LD_VAR 0 5
104972: PUSH
104973: LD_VAR 0 18
104977: IN
104978: IFFALSE 105026
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
104980: LD_VAR 0 5
104984: PPUSH
104985: CALL_OW 314
104989: NOT
104990: PUSH
104991: LD_VAR 0 5
104995: PPUSH
104996: LD_VAR 0 14
105000: PPUSH
105001: CALL_OW 296
105005: PUSH
105006: LD_INT 30
105008: LESS
105009: AND
105010: IFFALSE 105026
// ComAttackUnit ( i , e ) ;
105012: LD_VAR 0 5
105016: PPUSH
105017: LD_VAR 0 14
105021: PPUSH
105022: CALL_OW 115
// end ; end ; end ;
105026: GO 105029
105028: POP
// if IsDead ( i ) then
105029: LD_VAR 0 5
105033: PPUSH
105034: CALL_OW 301
105038: IFFALSE 105056
// defenders := defenders diff i ;
105040: LD_ADDR_VAR 0 2
105044: PUSH
105045: LD_VAR 0 2
105049: PUSH
105050: LD_VAR 0 5
105054: DIFF
105055: ST_TO_ADDR
// end ;
105056: GO 104239
105058: POP
105059: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
105060: LD_VAR 0 3
105064: NOT
105065: PUSH
105066: LD_VAR 0 2
105070: NOT
105071: OR
105072: PUSH
105073: LD_EXP 87
105077: PUSH
105078: LD_VAR 0 1
105082: ARRAY
105083: NOT
105084: OR
105085: IFFALSE 104143
// MC_Reset ( base , 18 ) ;
105087: LD_VAR 0 1
105091: PPUSH
105092: LD_INT 18
105094: PPUSH
105095: CALL 24656 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105099: LD_ADDR_VAR 0 2
105103: PUSH
105104: LD_VAR 0 2
105108: PUSH
105109: LD_VAR 0 2
105113: PPUSH
105114: LD_INT 2
105116: PUSH
105117: LD_INT 25
105119: PUSH
105120: LD_INT 1
105122: PUSH
105123: EMPTY
105124: LIST
105125: LIST
105126: PUSH
105127: LD_INT 25
105129: PUSH
105130: LD_INT 5
105132: PUSH
105133: EMPTY
105134: LIST
105135: LIST
105136: PUSH
105137: LD_INT 25
105139: PUSH
105140: LD_INT 8
105142: PUSH
105143: EMPTY
105144: LIST
105145: LIST
105146: PUSH
105147: LD_INT 25
105149: PUSH
105150: LD_INT 9
105152: PUSH
105153: EMPTY
105154: LIST
105155: LIST
105156: PUSH
105157: EMPTY
105158: LIST
105159: LIST
105160: LIST
105161: LIST
105162: LIST
105163: PPUSH
105164: CALL_OW 72
105168: DIFF
105169: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
105170: LD_VAR 0 3
105174: NOT
105175: PUSH
105176: LD_VAR 0 2
105180: PPUSH
105181: LD_INT 21
105183: PUSH
105184: LD_INT 2
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: PPUSH
105191: CALL_OW 72
105195: AND
105196: IFFALSE 105534
// begin tmp := FilterByTag ( defenders , 19 ) ;
105198: LD_ADDR_VAR 0 12
105202: PUSH
105203: LD_VAR 0 2
105207: PPUSH
105208: LD_INT 19
105210: PPUSH
105211: CALL 84108 0 2
105215: ST_TO_ADDR
// if tmp then
105216: LD_VAR 0 12
105220: IFFALSE 105290
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
105222: LD_ADDR_VAR 0 12
105226: PUSH
105227: LD_VAR 0 12
105231: PPUSH
105232: LD_INT 25
105234: PUSH
105235: LD_INT 3
105237: PUSH
105238: EMPTY
105239: LIST
105240: LIST
105241: PPUSH
105242: CALL_OW 72
105246: ST_TO_ADDR
// if tmp then
105247: LD_VAR 0 12
105251: IFFALSE 105290
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
105253: LD_ADDR_EXP 99
105257: PUSH
105258: LD_EXP 99
105262: PPUSH
105263: LD_VAR 0 1
105267: PPUSH
105268: LD_EXP 99
105272: PUSH
105273: LD_VAR 0 1
105277: ARRAY
105278: PUSH
105279: LD_VAR 0 12
105283: UNION
105284: PPUSH
105285: CALL_OW 1
105289: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
105290: LD_VAR 0 1
105294: PPUSH
105295: LD_INT 19
105297: PPUSH
105298: CALL 24656 0 2
// repeat wait ( 0 0$1 ) ;
105302: LD_INT 35
105304: PPUSH
105305: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105309: LD_EXP 87
105313: PUSH
105314: LD_VAR 0 1
105318: ARRAY
105319: NOT
105320: PUSH
105321: LD_EXP 87
105325: PUSH
105326: LD_VAR 0 1
105330: ARRAY
105331: PUSH
105332: EMPTY
105333: EQUAL
105334: OR
105335: IFFALSE 105372
// begin for i in defenders do
105337: LD_ADDR_VAR 0 5
105341: PUSH
105342: LD_VAR 0 2
105346: PUSH
105347: FOR_IN
105348: IFFALSE 105361
// ComStop ( i ) ;
105350: LD_VAR 0 5
105354: PPUSH
105355: CALL_OW 141
105359: GO 105347
105361: POP
105362: POP
// defenders := [ ] ;
105363: LD_ADDR_VAR 0 2
105367: PUSH
105368: EMPTY
105369: ST_TO_ADDR
// exit ;
105370: GO 105558
// end ; for i in defenders do
105372: LD_ADDR_VAR 0 5
105376: PUSH
105377: LD_VAR 0 2
105381: PUSH
105382: FOR_IN
105383: IFFALSE 105472
// begin if not IsInArea ( i , mc_parking [ base ] ) then
105385: LD_VAR 0 5
105389: PPUSH
105390: LD_EXP 111
105394: PUSH
105395: LD_VAR 0 1
105399: ARRAY
105400: PPUSH
105401: CALL_OW 308
105405: NOT
105406: IFFALSE 105430
// ComMoveToArea ( i , mc_parking [ base ] ) else
105408: LD_VAR 0 5
105412: PPUSH
105413: LD_EXP 111
105417: PUSH
105418: LD_VAR 0 1
105422: ARRAY
105423: PPUSH
105424: CALL_OW 113
105428: GO 105470
// if GetControl ( i ) = control_manual then
105430: LD_VAR 0 5
105434: PPUSH
105435: CALL_OW 263
105439: PUSH
105440: LD_INT 1
105442: EQUAL
105443: IFFALSE 105470
// if IsDrivenBy ( i ) then
105445: LD_VAR 0 5
105449: PPUSH
105450: CALL_OW 311
105454: IFFALSE 105470
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
105456: LD_VAR 0 5
105460: PPUSH
105461: CALL_OW 311
105465: PPUSH
105466: CALL_OW 121
// end ;
105470: GO 105382
105472: POP
105473: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
105474: LD_VAR 0 2
105478: PPUSH
105479: LD_INT 95
105481: PUSH
105482: LD_EXP 111
105486: PUSH
105487: LD_VAR 0 1
105491: ARRAY
105492: PUSH
105493: EMPTY
105494: LIST
105495: LIST
105496: PPUSH
105497: CALL_OW 72
105501: PUSH
105502: LD_VAR 0 2
105506: EQUAL
105507: PUSH
105508: LD_EXP 110
105512: PUSH
105513: LD_VAR 0 1
105517: ARRAY
105518: OR
105519: PUSH
105520: LD_EXP 87
105524: PUSH
105525: LD_VAR 0 1
105529: ARRAY
105530: NOT
105531: OR
105532: IFFALSE 105302
// end ; MC_Reset ( base , 19 ) ;
105534: LD_VAR 0 1
105538: PPUSH
105539: LD_INT 19
105541: PPUSH
105542: CALL 24656 0 2
// MC_Reset ( base , 20 ) ;
105546: LD_VAR 0 1
105550: PPUSH
105551: LD_INT 20
105553: PPUSH
105554: CALL 24656 0 2
// end ;
105558: LD_VAR 0 4
105562: RET
