// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20256 0 0
// InitNature ;
  19: CALL 16914 0 0
// InitArtifact ;
  23: CALL 17527 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4533 0 0
// PrepareAlliance ;
  44: CALL 1351 0 0
// PrepareArabian ;
  48: CALL 6242 0 0
// PrepareRussian ;
  52: CALL 8193 0 0
// PrepareLegion ;
  56: CALL 6636 0 0
// Action ;
  60: CALL 10746 0 0
// MC_Start ( ) ;
  64: CALL 22368 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ;
 184: LD_VAR 0 1
 188: RET
// export function CustomInitMacro ( ) ; begin
 189: LD_INT 0
 191: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 192: LD_ADDR_EXP 100
 196: PUSH
 197: LD_INT 26
 199: PUSH
 200: LD_INT 1
 202: PUSH
 203: LD_INT 4
 205: PUSH
 206: LD_INT 8
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 215: LD_ADDR_EXP 101
 219: PUSH
 220: LD_INT 27
 222: PUSH
 223: LD_INT 2
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 7
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_INT 6
 243: PUSH
 244: LD_INT 7
 246: PUSH
 247: LD_INT 9
 249: PUSH
 250: EMPTY
 251: LIST
 252: LIST
 253: LIST
 254: PUSH
 255: LD_OWVAR 67
 259: ARRAY
 260: PPUSH
 261: LD_INT 28
 263: PPUSH
 264: CALL 43689 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 268: LD_INT 1
 270: PPUSH
 271: LD_INT 10
 273: PUSH
 274: LD_INT 11
 276: PUSH
 277: LD_INT 13
 279: PUSH
 280: LD_INT 15
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: PPUSH
 289: CALL 44749 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 293: LD_INT 1
 295: PPUSH
 296: LD_INT 29
 298: PUSH
 299: EMPTY
 300: LIST
 301: PPUSH
 302: CALL 44842 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 306: LD_ADDR_EXP 105
 310: PUSH
 311: LD_EXP 105
 315: PPUSH
 316: LD_INT 1
 318: PPUSH
 319: LD_INT 22
 321: PUSH
 322: LD_INT 2
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PUSH
 329: LD_INT 25
 331: PUSH
 332: LD_INT 15
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PUSH
 339: EMPTY
 340: LIST
 341: LIST
 342: PPUSH
 343: CALL_OW 69
 347: PPUSH
 348: CALL_OW 1
 352: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 353: LD_INT 1
 355: PPUSH
 356: LD_INT 13
 358: PUSH
 359: LD_INT 2
 361: PUSH
 362: LD_INT 1
 364: PUSH
 365: LD_INT 31
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: LIST
 372: LIST
 373: PUSH
 374: LD_INT 13
 376: PUSH
 377: LD_INT 2
 379: PUSH
 380: LD_INT 1
 382: PUSH
 383: LD_INT 31
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: PUSH
 392: LD_INT 13
 394: PUSH
 395: LD_INT 1
 397: PUSH
 398: LD_INT 1
 400: PUSH
 401: LD_INT 28
 403: PUSH
 404: EMPTY
 405: LIST
 406: LIST
 407: LIST
 408: LIST
 409: PUSH
 410: LD_INT 13
 412: PUSH
 413: LD_INT 1
 415: PUSH
 416: LD_INT 1
 418: PUSH
 419: LD_INT 28
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: LIST
 426: LIST
 427: PUSH
 428: LD_INT 13
 430: PUSH
 431: LD_INT 1
 433: PUSH
 434: LD_INT 1
 436: PUSH
 437: LD_INT 28
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: PUSH
 446: LD_INT 13
 448: PUSH
 449: LD_INT 1
 451: PUSH
 452: LD_INT 1
 454: PUSH
 455: LD_INT 28
 457: PUSH
 458: EMPTY
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PPUSH
 472: CALL 44007 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 476: LD_INT 1
 478: PPUSH
 479: LD_INT 4
 481: PPUSH
 482: CALL 44192 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 486: LD_INT 2
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 44749 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 511: LD_INT 2
 513: PPUSH
 514: LD_INT 14
 516: PUSH
 517: EMPTY
 518: LIST
 519: PPUSH
 520: CALL 44842 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 524: LD_INT 2
 526: PPUSH
 527: LD_INT 21
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 3
 535: PUSH
 536: LD_INT 51
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PUSH
 545: LD_INT 22
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: LD_INT 3
 553: PUSH
 554: LD_INT 52
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PUSH
 563: LD_INT 22
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 52
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 3
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 3
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: LD_INT 24
 655: PUSH
 656: LD_INT 3
 658: PUSH
 659: LD_INT 3
 661: PUSH
 662: LD_INT 47
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 44007 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 5
 690: PPUSH
 691: CALL 44192 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 0
 700: PPUSH
 701: CALL 44622 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 705: LD_INT 3
 707: PPUSH
 708: LD_INT 10
 710: PUSH
 711: LD_INT 12
 713: PUSH
 714: LD_INT 15
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: PPUSH
 728: LD_INT 24
 730: PPUSH
 731: CALL 43689 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 735: LD_INT 3
 737: PPUSH
 738: LD_INT 10
 740: PUSH
 741: LD_INT 11
 743: PUSH
 744: LD_INT 13
 746: PUSH
 747: LD_INT 15
 749: PUSH
 750: EMPTY
 751: LIST
 752: LIST
 753: LIST
 754: LIST
 755: PPUSH
 756: CALL 44749 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 760: LD_INT 3
 762: PPUSH
 763: LD_INT 13
 765: PUSH
 766: EMPTY
 767: LIST
 768: PPUSH
 769: CALL 44842 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 773: LD_ADDR_EXP 105
 777: PUSH
 778: LD_EXP 105
 782: PPUSH
 783: LD_INT 3
 785: PPUSH
 786: LD_INT 22
 788: PUSH
 789: LD_INT 8
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 25
 798: PUSH
 799: LD_INT 15
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: PPUSH
 810: CALL_OW 69
 814: PPUSH
 815: CALL_OW 1
 819: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 820: LD_INT 3
 822: PPUSH
 823: LD_INT 13
 825: PUSH
 826: LD_INT 2
 828: PUSH
 829: LD_INT 1
 831: PUSH
 832: LD_INT 31
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 13
 843: PUSH
 844: LD_INT 2
 846: PUSH
 847: LD_INT 1
 849: PUSH
 850: LD_INT 31
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_INT 13
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: LD_INT 32
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_INT 14
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: LD_INT 28
 888: PUSH
 889: EMPTY
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: PUSH
 895: LD_INT 14
 897: PUSH
 898: LD_INT 1
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 28
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 14
 915: PUSH
 916: LD_INT 1
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 28
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 14
 933: PUSH
 934: LD_INT 1
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 28
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PPUSH
 958: CALL 44007 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 962: LD_INT 3
 964: PPUSH
 965: LD_INT 4
 967: PPUSH
 968: CALL 44192 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 972: LD_INT 4
 974: PPUSH
 975: LD_INT 10
 977: PUSH
 978: LD_INT 12
 980: PUSH
 981: LD_INT 11
 983: PUSH
 984: LD_INT 15
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL 44749 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 997: LD_INT 4
 999: PPUSH
1000: LD_INT 33
1002: PUSH
1003: EMPTY
1004: LIST
1005: PPUSH
1006: CALL 44842 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1010: LD_INT 4
1012: PPUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 6
1018: PUSH
1019: LD_INT 7
1021: PUSH
1022: LD_INT 9
1024: PUSH
1025: LD_INT 10
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 45160 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 54
1044: PPUSH
1045: LD_INT 85
1047: PPUSH
1048: LD_INT 2
1050: PPUSH
1051: LD_INT 25
1053: PUSH
1054: LD_INT 16
1056: PUSH
1057: LD_INT 17
1059: PUSH
1060: LD_INT 18
1062: PUSH
1063: LD_INT 22
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: PPUSH
1073: CALL 44954 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1077: LD_INT 4
1079: PPUSH
1080: LD_INT 5
1082: PUSH
1083: LD_INT 1
1085: PUSH
1086: LD_INT 1
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: LIST
1096: LIST
1097: PUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 1
1103: PUSH
1104: LD_INT 1
1106: PUSH
1107: LD_INT 6
1109: PUSH
1110: EMPTY
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: PUSH
1116: LD_INT 5
1118: PUSH
1119: LD_INT 1
1121: PUSH
1122: LD_INT 1
1124: PUSH
1125: LD_INT 7
1127: PUSH
1128: EMPTY
1129: LIST
1130: LIST
1131: LIST
1132: LIST
1133: PUSH
1134: LD_INT 5
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 1
1142: PUSH
1143: LD_INT 6
1145: PUSH
1146: EMPTY
1147: LIST
1148: LIST
1149: LIST
1150: LIST
1151: PUSH
1152: LD_INT 5
1154: PUSH
1155: LD_INT 1
1157: PUSH
1158: LD_INT 3
1160: PUSH
1161: LD_INT 12
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: PUSH
1170: LD_INT 3
1172: PUSH
1173: LD_INT 1
1175: PUSH
1176: LD_INT 3
1178: PUSH
1179: LD_INT 13
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: LIST
1194: LIST
1195: PPUSH
1196: CALL 44007 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1200: LD_INT 4
1202: PPUSH
1203: LD_INT 4
1205: PPUSH
1206: CALL 44192 0 2
// MC_SetTame ( 4 , powellApe ) ;
1210: LD_INT 4
1212: PPUSH
1213: LD_INT 11
1215: PPUSH
1216: CALL 44573 0 2
// end ;
1220: LD_VAR 0 1
1224: RET
// every 0 0$1 trigger debug do var i ;
1225: LD_EXP 1
1229: IFFALSE 1327
1231: GO 1233
1233: DISABLE
1234: LD_INT 0
1236: PPUSH
// begin enable ;
1237: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1238: LD_ADDR_VAR 0 1
1242: PUSH
1243: LD_INT 22
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: LD_INT 21
1258: PUSH
1259: LD_INT 1
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 21
1268: PUSH
1269: LD_INT 2
1271: PUSH
1272: EMPTY
1273: LIST
1274: LIST
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: LD_INT 24
1286: PUSH
1287: LD_INT 1000
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: PUSH
1298: EMPTY
1299: LIST
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: PUSH
1308: FOR_IN
1309: IFFALSE 1325
// SetLives ( i , 1000 ) ;
1311: LD_VAR 0 1
1315: PPUSH
1316: LD_INT 1000
1318: PPUSH
1319: CALL_OW 234
1323: GO 1308
1325: POP
1326: POP
// end ;
1327: PPOPN 1
1329: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1330: LD_EXP 13
1334: PUSH
1335: LD_INT 5
1337: GREATEREQUAL
1338: IFFALSE 1350
1340: GO 1342
1342: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1343: LD_STRING ACH_ARTIFACT
1345: PPUSH
1346: CALL_OW 543
1350: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1351: LD_INT 0
1353: PPUSH
1354: PPUSH
1355: PPUSH
1356: PPUSH
1357: PPUSH
// uc_side := 7 ;
1358: LD_ADDR_OWVAR 20
1362: PUSH
1363: LD_INT 7
1365: ST_TO_ADDR
// tmp := [ ] ;
1366: LD_ADDR_VAR 0 5
1370: PUSH
1371: EMPTY
1372: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1373: LD_ADDR_EXP 14
1377: PUSH
1378: LD_STRING JMM
1380: PPUSH
1381: LD_EXP 1
1385: NOT
1386: PPUSH
1387: LD_STRING 14a_
1389: PPUSH
1390: CALL 50399 0 3
1394: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1395: LD_ADDR_EXP 46
1399: PUSH
1400: LD_STRING Burlak
1402: PPUSH
1403: LD_EXP 1
1407: NOT
1408: PPUSH
1409: LD_STRING 14a_
1411: PPUSH
1412: CALL 50399 0 3
1416: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1417: LD_ADDR_EXP 29
1421: PUSH
1422: LD_STRING Joan
1424: PPUSH
1425: LD_EXP 1
1429: NOT
1430: PPUSH
1431: LD_STRING 13a_
1433: PPUSH
1434: CALL 50399 0 3
1438: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1439: LD_ADDR_EXP 15
1443: PUSH
1444: LD_STRING Roth
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: LD_STRING 13a_
1455: PPUSH
1456: CALL 50399 0 3
1460: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1461: LD_ADDR_EXP 32
1465: PUSH
1466: LD_STRING Gossudarov
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 13a_
1477: PPUSH
1478: CALL 50399 0 3
1482: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1483: LD_ADDR_EXP 30
1487: PUSH
1488: LD_STRING DeltaDoctor
1490: PPUSH
1491: LD_EXP 1
1495: NOT
1496: PPUSH
1497: LD_STRING 13a_
1499: PPUSH
1500: CALL 50399 0 3
1504: ST_TO_ADDR
// if DeltaDoctor then
1505: LD_EXP 30
1509: IFFALSE 1527
// tmp := tmp ^ DeltaDoctor ;
1511: LD_ADDR_VAR 0 5
1515: PUSH
1516: LD_VAR 0 5
1520: PUSH
1521: LD_EXP 30
1525: ADD
1526: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1527: LD_ADDR_EXP 28
1531: PUSH
1532: LD_STRING Simms
1534: PPUSH
1535: LD_EXP 1
1539: NOT
1540: PPUSH
1541: LD_STRING 13a_
1543: PPUSH
1544: CALL 50399 0 3
1548: ST_TO_ADDR
// if Simms then
1549: LD_EXP 28
1553: IFFALSE 1571
// tmp := tmp ^ Simms ;
1555: LD_ADDR_VAR 0 5
1559: PUSH
1560: LD_VAR 0 5
1564: PUSH
1565: LD_EXP 28
1569: ADD
1570: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1571: LD_ADDR_EXP 26
1575: PUSH
1576: LD_STRING Frank
1578: PPUSH
1579: LD_EXP 1
1583: NOT
1584: PPUSH
1585: LD_STRING 13a_
1587: PPUSH
1588: CALL 50399 0 3
1592: ST_TO_ADDR
// if Frank then
1593: LD_EXP 26
1597: IFFALSE 1615
// tmp := tmp ^ Frank ;
1599: LD_ADDR_VAR 0 5
1603: PUSH
1604: LD_VAR 0 5
1608: PUSH
1609: LD_EXP 26
1613: ADD
1614: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1615: LD_ADDR_EXP 33
1619: PUSH
1620: LD_STRING Kirilenkova
1622: PPUSH
1623: LD_EXP 1
1627: NOT
1628: PPUSH
1629: LD_STRING 13a_
1631: PPUSH
1632: CALL 50399 0 3
1636: ST_TO_ADDR
// if Kirilenkova then
1637: LD_EXP 33
1641: IFFALSE 1659
// tmp := tmp ^ Kirilenkova ;
1643: LD_ADDR_VAR 0 5
1647: PUSH
1648: LD_VAR 0 5
1652: PUSH
1653: LD_EXP 33
1657: ADD
1658: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1659: LD_ADDR_EXP 34
1663: PUSH
1664: LD_STRING Titov
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 13a_
1675: PPUSH
1676: CALL 50399 0 3
1680: ST_TO_ADDR
// if Titov then
1681: LD_EXP 34
1685: IFFALSE 1703
// tmp := tmp ^ Titov ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: LD_EXP 34
1701: ADD
1702: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1703: LD_ADDR_EXP 35
1707: PUSH
1708: LD_STRING Fadeev
1710: PPUSH
1711: LD_EXP 1
1715: NOT
1716: PPUSH
1717: LD_STRING 13a_
1719: PPUSH
1720: CALL 50399 0 3
1724: ST_TO_ADDR
// if Fadeev then
1725: LD_EXP 35
1729: IFFALSE 1747
// tmp := tmp ^ Fadeev ;
1731: LD_ADDR_VAR 0 5
1735: PUSH
1736: LD_VAR 0 5
1740: PUSH
1741: LD_EXP 35
1745: ADD
1746: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1747: LD_ADDR_EXP 36
1751: PUSH
1752: LD_STRING Dolgov
1754: PPUSH
1755: LD_EXP 1
1759: NOT
1760: PPUSH
1761: LD_STRING 13a_
1763: PPUSH
1764: CALL 50399 0 3
1768: ST_TO_ADDR
// if Dolgov then
1769: LD_EXP 36
1773: IFFALSE 1791
// tmp := tmp ^ Dolgov ;
1775: LD_ADDR_VAR 0 5
1779: PUSH
1780: LD_VAR 0 5
1784: PUSH
1785: LD_EXP 36
1789: ADD
1790: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1791: LD_ADDR_EXP 37
1795: PUSH
1796: LD_STRING Petrosyan
1798: PPUSH
1799: LD_EXP 1
1803: NOT
1804: PPUSH
1805: LD_STRING 13a_
1807: PPUSH
1808: CALL 50399 0 3
1812: ST_TO_ADDR
// if Petrosyan then
1813: LD_EXP 37
1817: IFFALSE 1835
// tmp := tmp ^ Petrosyan ;
1819: LD_ADDR_VAR 0 5
1823: PUSH
1824: LD_VAR 0 5
1828: PUSH
1829: LD_EXP 37
1833: ADD
1834: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1835: LD_ADDR_EXP 38
1839: PUSH
1840: LD_STRING Scholtze
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 13a_
1851: PPUSH
1852: CALL 50399 0 3
1856: ST_TO_ADDR
// if Scholtze then
1857: LD_EXP 38
1861: IFFALSE 1879
// tmp := tmp ^ Scholtze ;
1863: LD_ADDR_VAR 0 5
1867: PUSH
1868: LD_VAR 0 5
1872: PUSH
1873: LD_EXP 38
1877: ADD
1878: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1879: LD_ADDR_EXP 39
1883: PUSH
1884: LD_STRING Oblukov
1886: PPUSH
1887: LD_EXP 1
1891: NOT
1892: PPUSH
1893: LD_STRING 13a_
1895: PPUSH
1896: CALL 50399 0 3
1900: ST_TO_ADDR
// if Oblukov then
1901: LD_EXP 39
1905: IFFALSE 1923
// tmp := tmp ^ Oblukov ;
1907: LD_ADDR_VAR 0 5
1911: PUSH
1912: LD_VAR 0 5
1916: PUSH
1917: LD_EXP 39
1921: ADD
1922: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1923: LD_ADDR_EXP 40
1927: PUSH
1928: LD_STRING Kapitsova
1930: PPUSH
1931: LD_EXP 1
1935: NOT
1936: PPUSH
1937: LD_STRING 13a_
1939: PPUSH
1940: CALL 50399 0 3
1944: ST_TO_ADDR
// if Kapitsova then
1945: LD_EXP 40
1949: IFFALSE 1967
// tmp := tmp ^ Kapitsova ;
1951: LD_ADDR_VAR 0 5
1955: PUSH
1956: LD_VAR 0 5
1960: PUSH
1961: LD_EXP 40
1965: ADD
1966: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1967: LD_ADDR_EXP 41
1971: PUSH
1972: LD_STRING Lipshchin
1974: PPUSH
1975: LD_EXP 1
1979: NOT
1980: PPUSH
1981: LD_STRING 13a_
1983: PPUSH
1984: CALL 50399 0 3
1988: ST_TO_ADDR
// if Lipshchin then
1989: LD_EXP 41
1993: IFFALSE 2011
// tmp := tmp ^ Lipshchin ;
1995: LD_ADDR_VAR 0 5
1999: PUSH
2000: LD_VAR 0 5
2004: PUSH
2005: LD_EXP 41
2009: ADD
2010: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2011: LD_ADDR_EXP 42
2015: PUSH
2016: LD_STRING Petrovova
2018: PPUSH
2019: LD_EXP 1
2023: NOT
2024: PPUSH
2025: LD_STRING 13a_
2027: PPUSH
2028: CALL 50399 0 3
2032: ST_TO_ADDR
// if Petrovova then
2033: LD_EXP 42
2037: IFFALSE 2055
// tmp := tmp ^ Petrovova ;
2039: LD_ADDR_VAR 0 5
2043: PUSH
2044: LD_VAR 0 5
2048: PUSH
2049: LD_EXP 42
2053: ADD
2054: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2055: LD_ADDR_EXP 43
2059: PUSH
2060: LD_STRING Kovalyuk
2062: PPUSH
2063: LD_EXP 1
2067: NOT
2068: PPUSH
2069: LD_STRING 13a_
2071: PPUSH
2072: CALL 50399 0 3
2076: ST_TO_ADDR
// if Kovalyuk then
2077: LD_EXP 43
2081: IFFALSE 2099
// tmp := tmp ^ Kovalyuk ;
2083: LD_ADDR_VAR 0 5
2087: PUSH
2088: LD_VAR 0 5
2092: PUSH
2093: LD_EXP 43
2097: ADD
2098: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2099: LD_ADDR_EXP 44
2103: PUSH
2104: LD_STRING Kuzmov
2106: PPUSH
2107: LD_EXP 1
2111: NOT
2112: PPUSH
2113: LD_STRING 13a_
2115: PPUSH
2116: CALL 50399 0 3
2120: ST_TO_ADDR
// if Kuzmov then
2121: LD_EXP 44
2125: IFFALSE 2143
// tmp := tmp ^ Kuzmov ;
2127: LD_ADDR_VAR 0 5
2131: PUSH
2132: LD_VAR 0 5
2136: PUSH
2137: LD_EXP 44
2141: ADD
2142: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2143: LD_ADDR_EXP 45
2147: PUSH
2148: LD_STRING Karamazov
2150: PPUSH
2151: LD_EXP 1
2155: NOT
2156: PPUSH
2157: LD_STRING 13a_
2159: PPUSH
2160: CALL 50399 0 3
2164: ST_TO_ADDR
// if Karamazov then
2165: LD_EXP 45
2169: IFFALSE 2187
// tmp := tmp ^ Karamazov ;
2171: LD_ADDR_VAR 0 5
2175: PUSH
2176: LD_VAR 0 5
2180: PUSH
2181: LD_EXP 45
2185: ADD
2186: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2187: LD_ADDR_EXP 47
2191: PUSH
2192: LD_STRING Belkov
2194: PPUSH
2195: LD_EXP 1
2199: NOT
2200: PPUSH
2201: LD_STRING 13a_
2203: PPUSH
2204: CALL 50399 0 3
2208: ST_TO_ADDR
// if Belkov then
2209: LD_EXP 47
2213: IFFALSE 2231
// tmp := tmp ^ Belkov ;
2215: LD_ADDR_VAR 0 5
2219: PUSH
2220: LD_VAR 0 5
2224: PUSH
2225: LD_EXP 47
2229: ADD
2230: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2231: LD_ADDR_EXP 48
2235: PUSH
2236: LD_STRING Gnyevko
2238: PPUSH
2239: LD_EXP 1
2243: NOT
2244: PPUSH
2245: LD_STRING 13a_
2247: PPUSH
2248: CALL 50399 0 3
2252: ST_TO_ADDR
// if Gnyevko then
2253: LD_EXP 48
2257: IFFALSE 2275
// tmp := tmp ^ Gnyevko ;
2259: LD_ADDR_VAR 0 5
2263: PUSH
2264: LD_VAR 0 5
2268: PUSH
2269: LD_EXP 48
2273: ADD
2274: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2275: LD_ADDR_EXP 31
2279: PUSH
2280: LD_STRING Coonie
2282: PPUSH
2283: CALL_OW 25
2287: ST_TO_ADDR
// if not Lisa then
2288: LD_EXP 16
2292: NOT
2293: IFFALSE 2339
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2295: LD_ADDR_EXP 16
2299: PUSH
2300: LD_STRING Lisa
2302: PPUSH
2303: LD_EXP 1
2307: NOT
2308: PPUSH
2309: LD_STRING 13a_
2311: PPUSH
2312: CALL 50399 0 3
2316: ST_TO_ADDR
// if Lisa then
2317: LD_EXP 16
2321: IFFALSE 2339
// tmp := tmp ^ Lisa ;
2323: LD_ADDR_VAR 0 5
2327: PUSH
2328: LD_VAR 0 5
2332: PUSH
2333: LD_EXP 16
2337: ADD
2338: ST_TO_ADDR
// end ; if not Donaldson then
2339: LD_EXP 17
2343: NOT
2344: IFFALSE 2390
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 17
2350: PUSH
2351: LD_STRING Donaldson
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 50399 0 3
2367: ST_TO_ADDR
// if Donaldson then
2368: LD_EXP 17
2372: IFFALSE 2390
// tmp := tmp ^ Donaldson ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 17
2388: ADD
2389: ST_TO_ADDR
// end ; if not Bobby then
2390: LD_EXP 18
2394: NOT
2395: IFFALSE 2441
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2397: LD_ADDR_EXP 18
2401: PUSH
2402: LD_STRING Bobby
2404: PPUSH
2405: LD_EXP 1
2409: NOT
2410: PPUSH
2411: LD_STRING 13a_
2413: PPUSH
2414: CALL 50399 0 3
2418: ST_TO_ADDR
// if Bobby then
2419: LD_EXP 18
2423: IFFALSE 2441
// tmp := tmp ^ Bobby ;
2425: LD_ADDR_VAR 0 5
2429: PUSH
2430: LD_VAR 0 5
2434: PUSH
2435: LD_EXP 18
2439: ADD
2440: ST_TO_ADDR
// end ; if not Cyrus then
2441: LD_EXP 19
2445: NOT
2446: IFFALSE 2492
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2448: LD_ADDR_EXP 19
2452: PUSH
2453: LD_STRING Cyrus
2455: PPUSH
2456: LD_EXP 1
2460: NOT
2461: PPUSH
2462: LD_STRING 13a_
2464: PPUSH
2465: CALL 50399 0 3
2469: ST_TO_ADDR
// if Cyrus then
2470: LD_EXP 19
2474: IFFALSE 2492
// tmp := tmp ^ Cyrus ;
2476: LD_ADDR_VAR 0 5
2480: PUSH
2481: LD_VAR 0 5
2485: PUSH
2486: LD_EXP 19
2490: ADD
2491: ST_TO_ADDR
// end ; if not Brown then
2492: LD_EXP 21
2496: NOT
2497: IFFALSE 2543
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2499: LD_ADDR_EXP 21
2503: PUSH
2504: LD_STRING Brown
2506: PPUSH
2507: LD_EXP 1
2511: NOT
2512: PPUSH
2513: LD_STRING 13a_
2515: PPUSH
2516: CALL 50399 0 3
2520: ST_TO_ADDR
// if Brown then
2521: LD_EXP 21
2525: IFFALSE 2543
// tmp := tmp ^ Brown ;
2527: LD_ADDR_VAR 0 5
2531: PUSH
2532: LD_VAR 0 5
2536: PUSH
2537: LD_EXP 21
2541: ADD
2542: ST_TO_ADDR
// end ; if not Gladstone then
2543: LD_EXP 22
2547: NOT
2548: IFFALSE 2594
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2550: LD_ADDR_EXP 22
2554: PUSH
2555: LD_STRING Gladstone
2557: PPUSH
2558: LD_EXP 1
2562: NOT
2563: PPUSH
2564: LD_STRING 13a_
2566: PPUSH
2567: CALL 50399 0 3
2571: ST_TO_ADDR
// if Gladstone then
2572: LD_EXP 22
2576: IFFALSE 2594
// tmp := tmp ^ Gladstone ;
2578: LD_ADDR_VAR 0 5
2582: PUSH
2583: LD_VAR 0 5
2587: PUSH
2588: LD_EXP 22
2592: ADD
2593: ST_TO_ADDR
// end ; if not Cornel then
2594: LD_EXP 24
2598: NOT
2599: IFFALSE 2645
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2601: LD_ADDR_EXP 24
2605: PUSH
2606: LD_STRING Cornel
2608: PPUSH
2609: LD_EXP 1
2613: NOT
2614: PPUSH
2615: LD_STRING 13a_
2617: PPUSH
2618: CALL 50399 0 3
2622: ST_TO_ADDR
// if Cornel then
2623: LD_EXP 24
2627: IFFALSE 2645
// tmp := tmp ^ Cornel ;
2629: LD_ADDR_VAR 0 5
2633: PUSH
2634: LD_VAR 0 5
2638: PUSH
2639: LD_EXP 24
2643: ADD
2644: ST_TO_ADDR
// end ; if not Houten then
2645: LD_EXP 23
2649: NOT
2650: IFFALSE 2696
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2652: LD_ADDR_EXP 23
2656: PUSH
2657: LD_STRING Houten
2659: PPUSH
2660: LD_EXP 1
2664: NOT
2665: PPUSH
2666: LD_STRING 13a_
2668: PPUSH
2669: CALL 50399 0 3
2673: ST_TO_ADDR
// if Houten then
2674: LD_EXP 23
2678: IFFALSE 2696
// tmp := tmp ^ Houten ;
2680: LD_ADDR_VAR 0 5
2684: PUSH
2685: LD_VAR 0 5
2689: PUSH
2690: LD_EXP 23
2694: ADD
2695: ST_TO_ADDR
// end ; if not Gary then
2696: LD_EXP 25
2700: NOT
2701: IFFALSE 2747
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2703: LD_ADDR_EXP 25
2707: PUSH
2708: LD_STRING Gary
2710: PPUSH
2711: LD_EXP 1
2715: NOT
2716: PPUSH
2717: LD_STRING 13a_
2719: PPUSH
2720: CALL 50399 0 3
2724: ST_TO_ADDR
// if Gary then
2725: LD_EXP 25
2729: IFFALSE 2747
// tmp := tmp ^ Gary ;
2731: LD_ADDR_VAR 0 5
2735: PUSH
2736: LD_VAR 0 5
2740: PUSH
2741: LD_EXP 25
2745: ADD
2746: ST_TO_ADDR
// end ; if not Kikuchi then
2747: LD_EXP 27
2751: NOT
2752: IFFALSE 2798
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2754: LD_ADDR_EXP 27
2758: PUSH
2759: LD_STRING Kikuchi
2761: PPUSH
2762: LD_EXP 1
2766: NOT
2767: PPUSH
2768: LD_STRING 13a_
2770: PPUSH
2771: CALL 50399 0 3
2775: ST_TO_ADDR
// if Kikuchi then
2776: LD_EXP 27
2780: IFFALSE 2798
// tmp := tmp ^ Kikuchi ;
2782: LD_ADDR_VAR 0 5
2786: PUSH
2787: LD_VAR 0 5
2791: PUSH
2792: LD_EXP 27
2796: ADD
2797: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2798: LD_ADDR_VAR 0 5
2802: PUSH
2803: LD_VAR 0 5
2807: PUSH
2808: LD_STRING 13a_others
2810: PPUSH
2811: CALL_OW 31
2815: UNION
2816: ST_TO_ADDR
// tmp := tmp diff 0 ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: LD_VAR 0 5
2826: PUSH
2827: LD_INT 0
2829: DIFF
2830: ST_TO_ADDR
// if tmp < 15 then
2831: LD_VAR 0 5
2835: PUSH
2836: LD_INT 15
2838: LESS
2839: IFFALSE 2927
// for i = 15 downto tmp do
2841: LD_ADDR_VAR 0 2
2845: PUSH
2846: DOUBLE
2847: LD_INT 15
2849: INC
2850: ST_TO_ADDR
2851: LD_VAR 0 5
2855: PUSH
2856: FOR_DOWNTO
2857: IFFALSE 2925
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2859: LD_ADDR_OWVAR 21
2863: PUSH
2864: LD_INT 1
2866: PUSH
2867: LD_INT 3
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: PUSH
2874: LD_INT 1
2876: PPUSH
2877: LD_INT 2
2879: PPUSH
2880: CALL_OW 12
2884: ARRAY
2885: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 1
2891: PPUSH
2892: LD_INT 4
2894: PPUSH
2895: CALL_OW 12
2899: PPUSH
2900: LD_INT 8
2902: PPUSH
2903: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2907: LD_ADDR_VAR 0 5
2911: PUSH
2912: LD_VAR 0 5
2916: PUSH
2917: CALL_OW 44
2921: ADD
2922: ST_TO_ADDR
// end ;
2923: GO 2856
2925: POP
2926: POP
// if not debug then
2927: LD_EXP 1
2931: NOT
2932: IFFALSE 3104
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2934: LD_ADDR_VAR 0 4
2938: PUSH
2939: LD_STRING 
2941: PPUSH
2942: LD_INT 15
2944: PUSH
2945: LD_INT 14
2947: PUSH
2948: LD_INT 13
2950: PUSH
2951: EMPTY
2952: LIST
2953: LIST
2954: LIST
2955: PUSH
2956: LD_OWVAR 67
2960: ARRAY
2961: PPUSH
2962: LD_INT 15
2964: PUSH
2965: LD_INT 14
2967: PUSH
2968: LD_INT 13
2970: PUSH
2971: EMPTY
2972: LIST
2973: LIST
2974: LIST
2975: PUSH
2976: LD_OWVAR 67
2980: ARRAY
2981: PPUSH
2982: LD_INT -6
2984: PUSH
2985: LD_EXP 14
2989: PUSH
2990: LD_EXP 46
2994: PUSH
2995: LD_EXP 15
2999: PUSH
3000: LD_EXP 29
3004: PUSH
3005: LD_EXP 20
3009: PUSH
3010: LD_EXP 32
3014: PUSH
3015: LD_INT -2
3017: PUSH
3018: LD_INT -3
3020: PUSH
3021: LD_INT -5
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: LIST
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: PUSH
3036: LD_VAR 0 5
3040: ADD
3041: PPUSH
3042: LD_INT 1
3044: PUSH
3045: LD_INT 4
3047: PUSH
3048: LD_INT 2
3050: PUSH
3051: LD_INT 1
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 5
3063: PUSH
3064: LD_INT 0
3066: PUSH
3067: LD_INT 3
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_INT 9
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: LD_INT 3
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PPUSH
3097: CALL_OW 42
3101: ST_TO_ADDR
3102: GO 3183
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3104: LD_ADDR_VAR 0 4
3108: PUSH
3109: LD_EXP 34
3113: PUSH
3114: LD_EXP 35
3118: PUSH
3119: LD_EXP 36
3123: PUSH
3124: LD_EXP 37
3128: PUSH
3129: LD_EXP 38
3133: PUSH
3134: LD_EXP 39
3138: PUSH
3139: LD_EXP 40
3143: PUSH
3144: LD_EXP 41
3148: PUSH
3149: LD_EXP 42
3153: PUSH
3154: LD_EXP 43
3158: PUSH
3159: LD_EXP 44
3163: PUSH
3164: LD_EXP 45
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: ST_TO_ADDR
// uc_nation := 1 ;
3183: LD_ADDR_OWVAR 21
3187: PUSH
3188: LD_INT 1
3190: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3191: LD_INT 5
3193: PPUSH
3194: LD_INT 3
3196: PPUSH
3197: LD_INT 1
3199: PPUSH
3200: LD_INT 6
3202: PPUSH
3203: LD_INT 100
3205: PPUSH
3206: CALL 57514 0 5
// veh := CreateVehicle ;
3210: LD_ADDR_VAR 0 3
3214: PUSH
3215: CALL_OW 45
3219: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3220: LD_VAR 0 3
3224: PPUSH
3225: LD_INT 7
3227: NEG
3228: PPUSH
3229: CALL_OW 242
// SetDir ( veh , 3 ) ;
3233: LD_VAR 0 3
3237: PPUSH
3238: LD_INT 3
3240: PPUSH
3241: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3245: LD_VAR 0 3
3249: PPUSH
3250: LD_INT 31
3252: PPUSH
3253: LD_INT 0
3255: PPUSH
3256: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3260: LD_EXP 14
3264: PPUSH
3265: LD_VAR 0 3
3269: PPUSH
3270: CALL_OW 52
// if Joan then
3274: LD_EXP 29
3278: IFFALSE 3350
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3280: LD_INT 3
3282: PPUSH
3283: LD_INT 3
3285: PPUSH
3286: LD_INT 1
3288: PPUSH
3289: LD_INT 11
3291: PPUSH
3292: LD_INT 100
3294: PPUSH
3295: CALL 57514 0 5
// veh := CreateVehicle ;
3299: LD_ADDR_VAR 0 3
3303: PUSH
3304: CALL_OW 45
3308: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3309: LD_VAR 0 3
3313: PPUSH
3314: LD_INT 3
3316: PPUSH
3317: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3321: LD_VAR 0 3
3325: PPUSH
3326: LD_INT 30
3328: PPUSH
3329: LD_INT 0
3331: PPUSH
3332: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3336: LD_EXP 29
3340: PPUSH
3341: LD_VAR 0 3
3345: PPUSH
3346: CALL_OW 52
// end ; if Roth then
3350: LD_EXP 15
3354: IFFALSE 3426
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3356: LD_INT 3
3358: PPUSH
3359: LD_INT 3
3361: PPUSH
3362: LD_INT 1
3364: PPUSH
3365: LD_INT 11
3367: PPUSH
3368: LD_INT 100
3370: PPUSH
3371: CALL 57514 0 5
// veh := CreateVehicle ;
3375: LD_ADDR_VAR 0 3
3379: PUSH
3380: CALL_OW 45
3384: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3385: LD_VAR 0 3
3389: PPUSH
3390: LD_INT 3
3392: PPUSH
3393: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3397: LD_VAR 0 3
3401: PPUSH
3402: LD_INT 30
3404: PPUSH
3405: LD_INT 0
3407: PPUSH
3408: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3412: LD_EXP 15
3416: PPUSH
3417: LD_VAR 0 3
3421: PPUSH
3422: CALL_OW 52
// end ; if Denis then
3426: LD_EXP 20
3430: IFFALSE 3502
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3432: LD_INT 5
3434: PPUSH
3435: LD_INT 3
3437: PPUSH
3438: LD_INT 1
3440: PPUSH
3441: LD_INT 9
3443: PPUSH
3444: LD_INT 100
3446: PPUSH
3447: CALL 57514 0 5
// veh := CreateVehicle ;
3451: LD_ADDR_VAR 0 3
3455: PUSH
3456: CALL_OW 45
3460: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3461: LD_VAR 0 3
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3473: LD_VAR 0 3
3477: PPUSH
3478: LD_INT 30
3480: PPUSH
3481: LD_INT 0
3483: PPUSH
3484: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3488: LD_EXP 20
3492: PPUSH
3493: LD_VAR 0 3
3497: PPUSH
3498: CALL_OW 52
// end ; uc_nation := 3 ;
3502: LD_ADDR_OWVAR 21
3506: PUSH
3507: LD_INT 3
3509: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3510: LD_INT 22
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 1
3518: PPUSH
3519: LD_INT 45
3521: PPUSH
3522: LD_INT 100
3524: PPUSH
3525: CALL 57514 0 5
// veh := CreateVehicle ;
3529: LD_ADDR_VAR 0 3
3533: PUSH
3534: CALL_OW 45
3538: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3539: LD_VAR 0 3
3543: PPUSH
3544: LD_INT 7
3546: NEG
3547: PPUSH
3548: CALL_OW 242
// SetDir ( veh , 3 ) ;
3552: LD_VAR 0 3
3556: PPUSH
3557: LD_INT 3
3559: PPUSH
3560: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3564: LD_VAR 0 3
3568: PPUSH
3569: LD_INT 31
3571: PPUSH
3572: LD_INT 0
3574: PPUSH
3575: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3579: LD_EXP 46
3583: PPUSH
3584: LD_VAR 0 3
3588: PPUSH
3589: CALL_OW 52
// if Gossudarov then
3593: LD_EXP 32
3597: IFFALSE 3684
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3599: LD_INT 22
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: LD_INT 51
3610: PPUSH
3611: LD_INT 100
3613: PPUSH
3614: CALL 57514 0 5
// veh := CreateVehicle ;
3618: LD_ADDR_VAR 0 3
3622: PUSH
3623: CALL_OW 45
3627: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3628: LD_VAR 0 3
3632: PPUSH
3633: LD_INT 3
3635: PPUSH
3636: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3640: LD_VAR 0 3
3644: PPUSH
3645: LD_INT 30
3647: PPUSH
3648: LD_INT 0
3650: PPUSH
3651: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3655: LD_EXP 32
3659: PPUSH
3660: LD_VAR 0 3
3664: PPUSH
3665: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3669: LD_VAR 0 3
3673: PPUSH
3674: LD_INT 1
3676: PPUSH
3677: LD_INT 100
3679: PPUSH
3680: CALL_OW 290
// end ; for i in selected do
3684: LD_ADDR_VAR 0 2
3688: PUSH
3689: LD_VAR 0 4
3693: PUSH
3694: FOR_IN
3695: IFFALSE 4253
// begin uc_nation := GetNation ( i ) ;
3697: LD_ADDR_OWVAR 21
3701: PUSH
3702: LD_VAR 0 2
3706: PPUSH
3707: CALL_OW 248
3711: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3712: LD_VAR 0 2
3716: PUSH
3717: LD_EXP 16
3721: PUSH
3722: LD_EXP 17
3726: PUSH
3727: LD_EXP 19
3731: PUSH
3732: LD_EXP 18
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: LIST
3742: IN
3743: IFFALSE 3766
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3745: LD_INT 5
3747: PPUSH
3748: LD_INT 3
3750: PPUSH
3751: LD_INT 1
3753: PPUSH
3754: LD_INT 6
3756: PPUSH
3757: LD_INT 100
3759: PPUSH
3760: CALL 57514 0 5
3764: GO 4200
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3766: LD_VAR 0 2
3770: PUSH
3771: LD_EXP 39
3775: PUSH
3776: LD_EXP 44
3780: PUSH
3781: LD_EXP 42
3785: PUSH
3786: LD_EXP 34
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: IN
3797: IFFALSE 3828
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3799: LD_INT 24
3801: PPUSH
3802: LD_INT 1
3804: PPUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 46
3810: PPUSH
3811: LD_INT 65
3813: PPUSH
3814: LD_INT 75
3816: PPUSH
3817: CALL_OW 12
3821: PPUSH
3822: CALL 57514 0 5
3826: GO 4200
// if i = Karamazov then
3828: LD_VAR 0 2
3832: PUSH
3833: LD_EXP 45
3837: EQUAL
3838: IFFALSE 3861
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3840: LD_INT 22
3842: PPUSH
3843: LD_INT 3
3845: PPUSH
3846: LD_INT 1
3848: PPUSH
3849: LD_INT 52
3851: PPUSH
3852: LD_INT 100
3854: PPUSH
3855: CALL 57514 0 5
3859: GO 4200
// if i = Brown then
3861: LD_VAR 0 2
3865: PUSH
3866: LD_EXP 21
3870: EQUAL
3871: IFFALSE 3894
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3873: LD_INT 3
3875: PPUSH
3876: LD_INT 3
3878: PPUSH
3879: LD_INT 1
3881: PPUSH
3882: LD_INT 13
3884: PPUSH
3885: LD_INT 100
3887: PPUSH
3888: CALL 57514 0 5
3892: GO 4200
// if uc_nation = nation_american then
3894: LD_OWVAR 21
3898: PUSH
3899: LD_INT 1
3901: EQUAL
3902: IFFALSE 4053
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3904: LD_INT 3
3906: PUSH
3907: LD_INT 5
3909: PUSH
3910: LD_INT 5
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: LIST
3917: PUSH
3918: LD_OWVAR 21
3922: PUSH
3923: LD_INT 3
3925: MOD
3926: PUSH
3927: LD_INT 1
3929: PLUS
3930: ARRAY
3931: PPUSH
3932: LD_INT 1
3934: PUSH
3935: LD_INT 3
3937: PUSH
3938: LD_INT 1
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: LIST
3945: PUSH
3946: LD_OWVAR 21
3950: PUSH
3951: LD_INT 3
3953: MOD
3954: PUSH
3955: LD_INT 1
3957: PLUS
3958: ARRAY
3959: PPUSH
3960: LD_INT 1
3962: PPUSH
3963: LD_INT 11
3965: PUSH
3966: LD_INT 4
3968: PUSH
3969: LD_INT 5
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_INT 6
3979: PUSH
3980: LD_INT 7
3982: PUSH
3983: LD_INT 9
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: LIST
3990: PUSH
3991: LD_INT 6
3993: PUSH
3994: LD_INT 9
3996: PUSH
3997: LD_INT 12
3999: PUSH
4000: EMPTY
4001: LIST
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 3
4029: PPUSH
4030: CALL_OW 12
4034: ARRAY
4035: PPUSH
4036: LD_INT 65
4038: PPUSH
4039: LD_INT 75
4041: PPUSH
4042: CALL_OW 12
4046: PPUSH
4047: CALL 57514 0 5
// end else
4051: GO 4200
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4053: LD_INT 22
4055: PUSH
4056: LD_INT 23
4058: PUSH
4059: LD_INT 23
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: PUSH
4067: LD_OWVAR 21
4071: PUSH
4072: LD_INT 3
4074: MOD
4075: PUSH
4076: LD_INT 1
4078: PLUS
4079: ARRAY
4080: PPUSH
4081: LD_INT 1
4083: PUSH
4084: LD_INT 3
4086: PUSH
4087: LD_INT 1
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: LIST
4094: PUSH
4095: LD_OWVAR 21
4099: PUSH
4100: LD_INT 3
4102: MOD
4103: PUSH
4104: LD_INT 1
4106: PLUS
4107: ARRAY
4108: PPUSH
4109: LD_INT 1
4111: PPUSH
4112: LD_INT 45
4114: PUSH
4115: LD_INT 43
4117: PUSH
4118: LD_INT 44
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: LIST
4125: PUSH
4126: LD_INT 46
4128: PUSH
4129: LD_INT 45
4131: PUSH
4132: LD_INT 44
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: LIST
4139: PUSH
4140: LD_INT 46
4142: PUSH
4143: LD_INT 43
4145: PUSH
4146: LD_INT 45
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PUSH
4173: LD_INT 1
4175: PPUSH
4176: LD_INT 3
4178: PPUSH
4179: CALL_OW 12
4183: ARRAY
4184: PPUSH
4185: LD_INT 65
4187: PPUSH
4188: LD_INT 75
4190: PPUSH
4191: CALL_OW 12
4195: PPUSH
4196: CALL 57514 0 5
// end ; veh := CreateVehicle ;
4200: LD_ADDR_VAR 0 3
4204: PUSH
4205: CALL_OW 45
4209: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4210: LD_VAR 0 3
4214: PPUSH
4215: LD_INT 3
4217: PPUSH
4218: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4222: LD_VAR 0 3
4226: PPUSH
4227: LD_INT 30
4229: PPUSH
4230: LD_INT 0
4232: PPUSH
4233: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4237: LD_VAR 0 2
4241: PPUSH
4242: LD_VAR 0 3
4246: PPUSH
4247: CALL_OW 52
// end ;
4251: GO 3694
4253: POP
4254: POP
// if artifactArCaptured then
4255: LD_EXP 6
4259: IFFALSE 4345
// begin uc_nation := nation_american ;
4261: LD_ADDR_OWVAR 21
4265: PUSH
4266: LD_INT 1
4268: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4269: LD_INT 3
4271: PPUSH
4272: LD_INT 3
4274: PPUSH
4275: LD_INT 3
4277: PPUSH
4278: LD_INT 12
4280: PPUSH
4281: LD_INT 100
4283: PPUSH
4284: CALL 57514 0 5
// veh := CreateVehicle ;
4288: LD_ADDR_VAR 0 3
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4298: LD_VAR 0 3
4302: PPUSH
4303: LD_INT 3
4305: PPUSH
4306: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4310: LD_VAR 0 3
4314: PPUSH
4315: LD_INT 198
4317: PPUSH
4318: LD_INT 22
4320: PPUSH
4321: LD_INT 0
4323: PPUSH
4324: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4328: LD_VAR 0 3
4332: PPUSH
4333: LD_INT 4
4335: PPUSH
4336: LD_INT 50
4338: PPUSH
4339: CALL_OW 290
// end else
4343: GO 4364
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4345: LD_INT 4
4347: PPUSH
4348: LD_INT 267
4350: PPUSH
4351: LD_INT 226
4353: PPUSH
4354: LD_INT 5
4356: PPUSH
4357: LD_INT 0
4359: PPUSH
4360: CALL_OW 58
// end ; uc_nation := nation_american ;
4364: LD_ADDR_OWVAR 21
4368: PUSH
4369: LD_INT 1
4371: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4372: LD_INT 3
4374: PPUSH
4375: LD_INT 3
4377: PPUSH
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 12
4383: PPUSH
4384: LD_INT 100
4386: PPUSH
4387: CALL 57514 0 5
// veh := CreateVehicle ;
4391: LD_ADDR_VAR 0 3
4395: PUSH
4396: CALL_OW 45
4400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4401: LD_VAR 0 3
4405: PPUSH
4406: LD_INT 3
4408: PPUSH
4409: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4413: LD_VAR 0 3
4417: PPUSH
4418: LD_INT 218
4420: PPUSH
4421: LD_INT 23
4423: PPUSH
4424: LD_INT 0
4426: PPUSH
4427: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4431: LD_VAR 0 3
4435: PPUSH
4436: LD_INT 4
4438: PPUSH
4439: LD_INT 30
4441: PPUSH
4442: CALL_OW 290
// uc_nation := nation_russian ;
4446: LD_ADDR_OWVAR 21
4450: PUSH
4451: LD_INT 3
4453: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4454: LD_INT 22
4456: PPUSH
4457: LD_INT 3
4459: PPUSH
4460: LD_INT 3
4462: PPUSH
4463: LD_INT 51
4465: PPUSH
4466: LD_INT 100
4468: PPUSH
4469: CALL 57514 0 5
// veh := CreateVehicle ;
4473: LD_ADDR_VAR 0 3
4477: PUSH
4478: CALL_OW 45
4482: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4483: LD_VAR 0 3
4487: PPUSH
4488: LD_INT 3
4490: PPUSH
4491: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4495: LD_VAR 0 3
4499: PPUSH
4500: LD_INT 214
4502: PPUSH
4503: LD_INT 20
4505: PPUSH
4506: LD_INT 0
4508: PPUSH
4509: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4513: LD_VAR 0 3
4517: PPUSH
4518: LD_INT 4
4520: PPUSH
4521: LD_INT 40
4523: PPUSH
4524: CALL_OW 290
// end ; end_of_file
4528: LD_VAR 0 1
4532: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4533: LD_INT 0
4535: PPUSH
4536: PPUSH
4537: PPUSH
4538: PPUSH
4539: PPUSH
4540: PPUSH
4541: PPUSH
4542: PPUSH
4543: PPUSH
4544: PPUSH
// InitHc ;
4545: CALL_OW 19
// uc_side := 1 ;
4549: LD_ADDR_OWVAR 20
4553: PUSH
4554: LD_INT 1
4556: ST_TO_ADDR
// uc_nation := 1 ;
4557: LD_ADDR_OWVAR 21
4561: PUSH
4562: LD_INT 1
4564: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4565: LD_INT 387
4567: PPUSH
4568: CALL_OW 274
4572: PPUSH
4573: LD_INT 1
4575: PPUSH
4576: LD_INT 25500
4578: PPUSH
4579: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4583: LD_INT 387
4585: PPUSH
4586: CALL_OW 274
4590: PPUSH
4591: LD_INT 2
4593: PPUSH
4594: LD_INT 4000
4596: PPUSH
4597: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4601: LD_INT 387
4603: PPUSH
4604: CALL_OW 274
4608: PPUSH
4609: LD_INT 3
4611: PPUSH
4612: LD_INT 50
4614: PPUSH
4615: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4619: LD_INT 476
4621: PPUSH
4622: CALL_OW 274
4626: PPUSH
4627: LD_INT 1
4629: PPUSH
4630: LD_INT 7500
4632: PPUSH
4633: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4637: LD_INT 476
4639: PPUSH
4640: CALL_OW 274
4644: PPUSH
4645: LD_INT 2
4647: PPUSH
4648: LD_INT 4000
4650: PPUSH
4651: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4655: LD_INT 476
4657: PPUSH
4658: CALL_OW 274
4662: PPUSH
4663: LD_INT 3
4665: PPUSH
4666: LD_INT 10
4668: PPUSH
4669: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4673: LD_ADDR_EXP 49
4677: PUSH
4678: LD_STRING Powell
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4686: LD_EXP 49
4690: PPUSH
4691: LD_INT 387
4693: PPUSH
4694: CALL_OW 52
// tmp := [ ] ;
4698: LD_ADDR_VAR 0 6
4702: PUSH
4703: EMPTY
4704: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4705: LD_ADDR_EXP 16
4709: PUSH
4710: LD_STRING Lisa
4712: PPUSH
4713: LD_EXP 1
4717: NOT
4718: PPUSH
4719: LD_STRING 12p_
4721: PPUSH
4722: CALL 50399 0 3
4726: ST_TO_ADDR
// if Lisa then
4727: LD_EXP 16
4731: IFFALSE 4749
// tmp := tmp ^ Lisa ;
4733: LD_ADDR_VAR 0 6
4737: PUSH
4738: LD_VAR 0 6
4742: PUSH
4743: LD_EXP 16
4747: ADD
4748: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4749: LD_ADDR_EXP 17
4753: PUSH
4754: LD_STRING Donaldson
4756: PPUSH
4757: LD_EXP 1
4761: NOT
4762: PPUSH
4763: LD_STRING 12p_
4765: PPUSH
4766: CALL 50399 0 3
4770: ST_TO_ADDR
// if Donaldson then
4771: LD_EXP 17
4775: IFFALSE 4793
// tmp := tmp ^ Donaldson ;
4777: LD_ADDR_VAR 0 6
4781: PUSH
4782: LD_VAR 0 6
4786: PUSH
4787: LD_EXP 17
4791: ADD
4792: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4793: LD_ADDR_EXP 18
4797: PUSH
4798: LD_STRING Bobby
4800: PPUSH
4801: LD_EXP 1
4805: NOT
4806: PPUSH
4807: LD_STRING 12p_
4809: PPUSH
4810: CALL 50399 0 3
4814: ST_TO_ADDR
// if Bobby then
4815: LD_EXP 18
4819: IFFALSE 4837
// tmp := tmp ^ Bobby ;
4821: LD_ADDR_VAR 0 6
4825: PUSH
4826: LD_VAR 0 6
4830: PUSH
4831: LD_EXP 18
4835: ADD
4836: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4837: LD_ADDR_EXP 19
4841: PUSH
4842: LD_STRING Cyrus
4844: PPUSH
4845: LD_EXP 1
4849: NOT
4850: PPUSH
4851: LD_STRING 12p_
4853: PPUSH
4854: CALL 50399 0 3
4858: ST_TO_ADDR
// if Cyrus then
4859: LD_EXP 19
4863: IFFALSE 4881
// tmp := tmp ^ Cyrus ;
4865: LD_ADDR_VAR 0 6
4869: PUSH
4870: LD_VAR 0 6
4874: PUSH
4875: LD_EXP 19
4879: ADD
4880: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4881: LD_ADDR_EXP 21
4885: PUSH
4886: LD_STRING Brown
4888: PPUSH
4889: LD_EXP 1
4893: NOT
4894: PPUSH
4895: LD_STRING 12p_
4897: PPUSH
4898: CALL 50399 0 3
4902: ST_TO_ADDR
// if Brown then
4903: LD_EXP 21
4907: IFFALSE 4925
// tmp := tmp ^ Brown ;
4909: LD_ADDR_VAR 0 6
4913: PUSH
4914: LD_VAR 0 6
4918: PUSH
4919: LD_EXP 21
4923: ADD
4924: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4925: LD_ADDR_EXP 22
4929: PUSH
4930: LD_STRING Gladstone
4932: PPUSH
4933: LD_EXP 1
4937: NOT
4938: PPUSH
4939: LD_STRING 12p_
4941: PPUSH
4942: CALL 50399 0 3
4946: ST_TO_ADDR
// if Gladstone then
4947: LD_EXP 22
4951: IFFALSE 4969
// tmp := tmp ^ Gladstone ;
4953: LD_ADDR_VAR 0 6
4957: PUSH
4958: LD_VAR 0 6
4962: PUSH
4963: LD_EXP 22
4967: ADD
4968: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4969: LD_ADDR_EXP 23
4973: PUSH
4974: LD_STRING Houten
4976: PPUSH
4977: LD_EXP 1
4981: NOT
4982: PPUSH
4983: LD_STRING 12p_
4985: PPUSH
4986: CALL 50399 0 3
4990: ST_TO_ADDR
// if Houten then
4991: LD_EXP 23
4995: IFFALSE 5013
// tmp := tmp ^ Houten ;
4997: LD_ADDR_VAR 0 6
5001: PUSH
5002: LD_VAR 0 6
5006: PUSH
5007: LD_EXP 23
5011: ADD
5012: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5013: LD_ADDR_EXP 24
5017: PUSH
5018: LD_STRING Cornel
5020: PPUSH
5021: LD_EXP 1
5025: NOT
5026: PPUSH
5027: LD_STRING 12p_
5029: PPUSH
5030: CALL 50399 0 3
5034: ST_TO_ADDR
// if Cornel then
5035: LD_EXP 24
5039: IFFALSE 5057
// tmp := tmp ^ Cornel ;
5041: LD_ADDR_VAR 0 6
5045: PUSH
5046: LD_VAR 0 6
5050: PUSH
5051: LD_EXP 24
5055: ADD
5056: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5057: LD_ADDR_EXP 25
5061: PUSH
5062: LD_STRING Gary
5064: PPUSH
5065: LD_EXP 1
5069: NOT
5070: PPUSH
5071: LD_STRING 12p_
5073: PPUSH
5074: CALL 50399 0 3
5078: ST_TO_ADDR
// if Gary then
5079: LD_EXP 25
5083: IFFALSE 5101
// tmp := tmp ^ Gary ;
5085: LD_ADDR_VAR 0 6
5089: PUSH
5090: LD_VAR 0 6
5094: PUSH
5095: LD_EXP 25
5099: ADD
5100: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5101: LD_ADDR_EXP 27
5105: PUSH
5106: LD_STRING Kikuchi
5108: PPUSH
5109: LD_EXP 1
5113: NOT
5114: PPUSH
5115: LD_STRING 12p_
5117: PPUSH
5118: CALL 50399 0 3
5122: ST_TO_ADDR
// if Kikuchi then
5123: LD_EXP 27
5127: IFFALSE 5145
// tmp := tmp ^ Kikuchi ;
5129: LD_ADDR_VAR 0 6
5133: PUSH
5134: LD_VAR 0 6
5138: PUSH
5139: LD_EXP 27
5143: ADD
5144: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5145: LD_ADDR_VAR 0 6
5149: PUSH
5150: LD_VAR 0 6
5154: PUSH
5155: LD_STRING 12p_others
5157: PPUSH
5158: CALL_OW 31
5162: UNION
5163: ST_TO_ADDR
// if tmp < 36 then
5164: LD_VAR 0 6
5168: PUSH
5169: LD_INT 36
5171: LESS
5172: IFFALSE 5239
// for i = 1 to 36 - tmp do
5174: LD_ADDR_VAR 0 2
5178: PUSH
5179: DOUBLE
5180: LD_INT 1
5182: DEC
5183: ST_TO_ADDR
5184: LD_INT 36
5186: PUSH
5187: LD_VAR 0 6
5191: MINUS
5192: PUSH
5193: FOR_TO
5194: IFFALSE 5237
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5196: LD_INT 1
5198: PPUSH
5199: LD_VAR 0 2
5203: PUSH
5204: LD_INT 4
5206: MOD
5207: PUSH
5208: LD_INT 1
5210: PLUS
5211: PPUSH
5212: LD_INT 10
5214: PPUSH
5215: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5219: LD_ADDR_VAR 0 6
5223: PUSH
5224: LD_VAR 0 6
5228: PUSH
5229: CALL_OW 44
5233: ADD
5234: ST_TO_ADDR
// end ;
5235: GO 5193
5237: POP
5238: POP
// for i in tmp do
5239: LD_ADDR_VAR 0 2
5243: PUSH
5244: LD_VAR 0 6
5248: PUSH
5249: FOR_IN
5250: IFFALSE 5275
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5252: LD_VAR 0 2
5256: PPUSH
5257: LD_INT 62
5259: PPUSH
5260: LD_INT 93
5262: PPUSH
5263: LD_INT 9
5265: PPUSH
5266: LD_INT 0
5268: PPUSH
5269: CALL_OW 50
5273: GO 5249
5275: POP
5276: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
5277: LD_ADDR_EXP 76
5281: PUSH
5282: LD_EXP 76
5286: PPUSH
5287: LD_INT 4
5289: PPUSH
5290: LD_INT 22
5292: PUSH
5293: LD_INT 1
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: PPUSH
5305: CALL_OW 1
5309: ST_TO_ADDR
// uc_side := 0 ;
5310: LD_ADDR_OWVAR 20
5314: PUSH
5315: LD_INT 0
5317: ST_TO_ADDR
// uc_nation := 0 ;
5318: LD_ADDR_OWVAR 21
5322: PUSH
5323: LD_INT 0
5325: ST_TO_ADDR
// for i = 1 to 4 do
5326: LD_ADDR_VAR 0 2
5330: PUSH
5331: DOUBLE
5332: LD_INT 1
5334: DEC
5335: ST_TO_ADDR
5336: LD_INT 4
5338: PUSH
5339: FOR_TO
5340: IFFALSE 5371
// begin InitHc ;
5342: CALL_OW 19
// hc_class := class_apeman ;
5346: LD_ADDR_OWVAR 28
5350: PUSH
5351: LD_INT 12
5353: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5354: CALL_OW 44
5358: PPUSH
5359: LD_INT 11
5361: PPUSH
5362: LD_INT 0
5364: PPUSH
5365: CALL_OW 49
// end ;
5369: GO 5339
5371: POP
5372: POP
// end ;
5373: LD_VAR 0 1
5377: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5378: LD_EXP 4
5382: NOT
5383: PUSH
5384: LD_INT 4
5386: PPUSH
5387: LD_INT 1
5389: PPUSH
5390: CALL 45473 0 2
5394: NOT
5395: AND
5396: IFFALSE 6168
5398: GO 5400
5400: DISABLE
5401: LD_INT 0
5403: PPUSH
5404: PPUSH
5405: PPUSH
// begin enable ;
5406: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5407: LD_INT 22
5409: PUSH
5410: LD_INT 1
5412: PUSH
5413: EMPTY
5414: LIST
5415: LIST
5416: PUSH
5417: LD_INT 23
5419: PUSH
5420: LD_INT 1
5422: PUSH
5423: EMPTY
5424: LIST
5425: LIST
5426: PUSH
5427: LD_INT 30
5429: PUSH
5430: LD_INT 3
5432: PUSH
5433: EMPTY
5434: LIST
5435: LIST
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: LIST
5441: PPUSH
5442: CALL_OW 69
5446: NOT
5447: IFFALSE 5451
// exit ;
5449: GO 6168
// if Prob ( 40 ) then
5451: LD_INT 40
5453: PPUSH
5454: CALL_OW 13
5458: IFFALSE 5585
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5460: LD_INT 4
5462: PPUSH
5463: LD_INT 5
5465: PUSH
5466: LD_INT 1
5468: PUSH
5469: LD_INT 2
5471: PUSH
5472: LD_INT 7
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: PUSH
5481: LD_INT 5
5483: PUSH
5484: LD_INT 1
5486: PUSH
5487: LD_INT 2
5489: PUSH
5490: LD_INT 7
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: LIST
5497: LIST
5498: PUSH
5499: LD_INT 5
5501: PUSH
5502: LD_INT 1
5504: PUSH
5505: LD_INT 2
5507: PUSH
5508: LD_INT 7
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 5
5519: PUSH
5520: LD_INT 1
5522: PUSH
5523: LD_INT 2
5525: PUSH
5526: LD_INT 6
5528: PUSH
5529: EMPTY
5530: LIST
5531: LIST
5532: LIST
5533: LIST
5534: PUSH
5535: LD_INT 5
5537: PUSH
5538: LD_INT 1
5540: PUSH
5541: LD_INT 2
5543: PUSH
5544: LD_INT 6
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: LIST
5552: PUSH
5553: LD_INT 5
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 6
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 44055 0 2
// end else
5583: GO 5708
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5585: LD_INT 4
5587: PPUSH
5588: LD_INT 5
5590: PUSH
5591: LD_INT 1
5593: PUSH
5594: LD_INT 2
5596: PUSH
5597: LD_INT 7
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 5
5608: PUSH
5609: LD_INT 1
5611: PUSH
5612: LD_INT 2
5614: PUSH
5615: LD_INT 9
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 5
5626: PUSH
5627: LD_INT 1
5629: PUSH
5630: LD_INT 2
5632: PUSH
5633: LD_INT 9
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: PUSH
5642: LD_INT 5
5644: PUSH
5645: LD_INT 1
5647: PUSH
5648: LD_INT 2
5650: PUSH
5651: LD_INT 6
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: LIST
5658: LIST
5659: PUSH
5660: LD_INT 5
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 6
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 5
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 6
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PPUSH
5704: CALL 44055 0 2
// end ; repeat wait ( 0 0$1 ) ;
5708: LD_INT 35
5710: PPUSH
5711: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5715: LD_INT 4
5717: PPUSH
5718: LD_INT 1
5720: PPUSH
5721: CALL 45473 0 2
5725: PUSH
5726: LD_INT 6
5728: GREATEREQUAL
5729: IFFALSE 5708
// wait ( 0 0$30 ) ;
5731: LD_INT 1050
5733: PPUSH
5734: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5738: LD_ADDR_VAR 0 2
5742: PUSH
5743: LD_INT 4
5745: PPUSH
5746: LD_INT 1
5748: PPUSH
5749: CALL 45473 0 2
5753: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5754: LD_ADDR_EXP 95
5758: PUSH
5759: LD_EXP 95
5763: PPUSH
5764: LD_INT 4
5766: PPUSH
5767: LD_EXP 95
5771: PUSH
5772: LD_INT 4
5774: ARRAY
5775: PUSH
5776: LD_VAR 0 2
5780: DIFF
5781: PPUSH
5782: CALL_OW 1
5786: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5787: LD_ADDR_VAR 0 3
5791: PUSH
5792: LD_INT 0
5794: PPUSH
5795: LD_INT 2
5797: PPUSH
5798: CALL_OW 12
5802: ST_TO_ADDR
// if target then
5803: LD_VAR 0 3
5807: IFFALSE 5935
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5809: LD_ADDR_VAR 0 2
5813: PUSH
5814: LD_VAR 0 2
5818: PPUSH
5819: LD_INT 24
5821: PUSH
5822: LD_INT 250
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PPUSH
5829: CALL_OW 72
5833: ST_TO_ADDR
// for i in tmp do
5834: LD_ADDR_VAR 0 1
5838: PUSH
5839: LD_VAR 0 2
5843: PUSH
5844: FOR_IN
5845: IFFALSE 5885
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5847: LD_VAR 0 1
5851: PPUSH
5852: LD_INT 114
5854: PPUSH
5855: LD_INT 108
5857: PPUSH
5858: CALL_OW 297
5862: PUSH
5863: LD_INT 9
5865: GREATER
5866: IFFALSE 5883
// ComMoveXY ( i , 114 , 108 ) ;
5868: LD_VAR 0 1
5872: PPUSH
5873: LD_INT 114
5875: PPUSH
5876: LD_INT 108
5878: PPUSH
5879: CALL_OW 111
5883: GO 5844
5885: POP
5886: POP
// wait ( 0 0$1 ) ;
5887: LD_INT 35
5889: PPUSH
5890: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5894: LD_VAR 0 2
5898: PPUSH
5899: LD_INT 92
5901: PUSH
5902: LD_INT 114
5904: PUSH
5905: LD_INT 108
5907: PUSH
5908: LD_INT 9
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PPUSH
5917: CALL_OW 72
5921: PUSH
5922: LD_VAR 0 2
5926: PUSH
5927: LD_INT 1
5929: MINUS
5930: GREATEREQUAL
5931: IFFALSE 5809
// end else
5933: GO 6059
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5935: LD_ADDR_VAR 0 2
5939: PUSH
5940: LD_VAR 0 2
5944: PPUSH
5945: LD_INT 24
5947: PUSH
5948: LD_INT 250
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PPUSH
5955: CALL_OW 72
5959: ST_TO_ADDR
// for i in tmp do
5960: LD_ADDR_VAR 0 1
5964: PUSH
5965: LD_VAR 0 2
5969: PUSH
5970: FOR_IN
5971: IFFALSE 6011
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 129
5980: PPUSH
5981: LD_INT 139
5983: PPUSH
5984: CALL_OW 297
5988: PUSH
5989: LD_INT 9
5991: GREATER
5992: IFFALSE 6009
// ComMoveXY ( i , 129 , 139 ) ;
5994: LD_VAR 0 1
5998: PPUSH
5999: LD_INT 129
6001: PPUSH
6002: LD_INT 139
6004: PPUSH
6005: CALL_OW 111
6009: GO 5970
6011: POP
6012: POP
// wait ( 0 0$1 ) ;
6013: LD_INT 35
6015: PPUSH
6016: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6020: LD_VAR 0 2
6024: PPUSH
6025: LD_INT 92
6027: PUSH
6028: LD_INT 129
6030: PUSH
6031: LD_INT 139
6033: PUSH
6034: LD_INT 9
6036: PUSH
6037: EMPTY
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: PPUSH
6043: CALL_OW 72
6047: PUSH
6048: LD_VAR 0 2
6052: PUSH
6053: LD_INT 1
6055: MINUS
6056: GREATEREQUAL
6057: IFFALSE 5935
// end ; repeat wait ( 0 0$1 ) ;
6059: LD_INT 35
6061: PPUSH
6062: CALL_OW 67
// for i in tmp do
6066: LD_ADDR_VAR 0 1
6070: PUSH
6071: LD_VAR 0 2
6075: PUSH
6076: FOR_IN
6077: IFFALSE 6159
// begin if GetLives ( i ) > 251 then
6079: LD_VAR 0 1
6083: PPUSH
6084: CALL_OW 256
6088: PUSH
6089: LD_INT 251
6091: GREATER
6092: IFFALSE 6130
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6094: LD_VAR 0 1
6098: PPUSH
6099: LD_INT 81
6101: PUSH
6102: LD_INT 1
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PPUSH
6109: CALL_OW 69
6113: PPUSH
6114: LD_VAR 0 1
6118: PPUSH
6119: CALL_OW 74
6123: PPUSH
6124: CALL_OW 115
6128: GO 6157
// if IsDead ( i ) then
6130: LD_VAR 0 1
6134: PPUSH
6135: CALL_OW 301
6139: IFFALSE 6157
// tmp := tmp diff i ;
6141: LD_ADDR_VAR 0 2
6145: PUSH
6146: LD_VAR 0 2
6150: PUSH
6151: LD_VAR 0 1
6155: DIFF
6156: ST_TO_ADDR
// end ;
6157: GO 6076
6159: POP
6160: POP
// until not tmp ;
6161: LD_VAR 0 2
6165: NOT
6166: IFFALSE 6059
// end ;
6168: PPOPN 3
6170: END
// every 30 30$00 trigger not americanDestroyed do
6171: LD_EXP 4
6175: NOT
6176: IFFALSE 6241
6178: GO 6180
6180: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6181: LD_INT 63000
6183: PUSH
6184: LD_INT 42000
6186: PUSH
6187: LD_INT 21000
6189: PUSH
6190: EMPTY
6191: LIST
6192: LIST
6193: LIST
6194: PUSH
6195: LD_OWVAR 67
6199: ARRAY
6200: PPUSH
6201: CALL_OW 67
// if americanDestroyed then
6205: LD_EXP 4
6209: IFFALSE 6213
// exit ;
6211: GO 6241
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6213: LD_INT 4
6215: PPUSH
6216: LD_INT 5
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: LD_INT 1
6224: PUSH
6225: LD_INT 8
6227: PUSH
6228: EMPTY
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: EMPTY
6235: LIST
6236: PPUSH
6237: CALL 44055 0 2
// end ; end_of_file
6241: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6242: LD_INT 0
6244: PPUSH
6245: PPUSH
6246: PPUSH
6247: PPUSH
6248: PPUSH
// side := 2 ;
6249: LD_ADDR_VAR 0 5
6253: PUSH
6254: LD_INT 2
6256: ST_TO_ADDR
// InitHc ;
6257: CALL_OW 19
// uc_side := side ;
6261: LD_ADDR_OWVAR 20
6265: PUSH
6266: LD_VAR 0 5
6270: ST_TO_ADDR
// uc_nation := 2 ;
6271: LD_ADDR_OWVAR 21
6275: PUSH
6276: LD_INT 2
6278: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6279: LD_ADDR_VAR 0 4
6283: PUSH
6284: LD_INT 22
6286: PUSH
6287: LD_VAR 0 5
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PUSH
6296: LD_INT 30
6298: PUSH
6299: LD_INT 32
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: PUSH
6306: LD_INT 58
6308: PUSH
6309: EMPTY
6310: LIST
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: PPUSH
6317: CALL_OW 69
6321: ST_TO_ADDR
// for i = 1 to 10 do
6322: LD_ADDR_VAR 0 2
6326: PUSH
6327: DOUBLE
6328: LD_INT 1
6330: DEC
6331: ST_TO_ADDR
6332: LD_INT 10
6334: PUSH
6335: FOR_TO
6336: IFFALSE 6408
// begin uc_nation := nation_nature ;
6338: LD_ADDR_OWVAR 21
6342: PUSH
6343: LD_INT 0
6345: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6346: LD_ADDR_OWVAR 28
6350: PUSH
6351: LD_INT 15
6353: ST_TO_ADDR
// hc_gallery :=  ;
6354: LD_ADDR_OWVAR 33
6358: PUSH
6359: LD_STRING 
6361: ST_TO_ADDR
// hc_name :=  ;
6362: LD_ADDR_OWVAR 26
6366: PUSH
6367: LD_STRING 
6369: ST_TO_ADDR
// un := CreateHuman ;
6370: LD_ADDR_VAR 0 3
6374: PUSH
6375: CALL_OW 44
6379: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6380: LD_VAR 0 3
6384: PPUSH
6385: LD_VAR 0 4
6389: PUSH
6390: LD_VAR 0 4
6394: PUSH
6395: LD_VAR 0 2
6399: MINUS
6400: ARRAY
6401: PPUSH
6402: CALL_OW 52
// end ;
6406: GO 6335
6408: POP
6409: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6410: LD_INT 503
6412: PPUSH
6413: LD_INT 27
6415: PPUSH
6416: LD_STRING 
6418: PPUSH
6419: LD_INT 8
6421: PUSH
6422: LD_INT 9
6424: PUSH
6425: LD_INT 10
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: LIST
6432: PUSH
6433: LD_OWVAR 67
6437: ARRAY
6438: PPUSH
6439: LD_INT 3000
6441: PUSH
6442: LD_INT 500
6444: PUSH
6445: LD_INT 150
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: PPUSH
6453: LD_INT 16
6455: PUSH
6456: LD_INT 6
6458: PUSH
6459: LD_INT 6
6461: PUSH
6462: LD_INT 6
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: PPUSH
6471: CALL 60923 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6475: LD_ADDR_EXP 76
6479: PUSH
6480: LD_EXP 76
6484: PPUSH
6485: LD_INT 1
6487: PPUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 23
6502: PUSH
6503: LD_INT 2
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 3
6512: PUSH
6513: LD_INT 21
6515: PUSH
6516: LD_INT 2
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: PUSH
6523: EMPTY
6524: LIST
6525: LIST
6526: PUSH
6527: EMPTY
6528: LIST
6529: LIST
6530: LIST
6531: PPUSH
6532: CALL_OW 69
6536: PPUSH
6537: CALL_OW 1
6541: ST_TO_ADDR
// end ;
6542: LD_VAR 0 1
6546: RET
// export Omar ; export function PrepareOmarAli ; begin
6547: LD_INT 0
6549: PPUSH
// uc_side := 5 ;
6550: LD_ADDR_OWVAR 20
6554: PUSH
6555: LD_INT 5
6557: ST_TO_ADDR
// uc_nation := 2 ;
6558: LD_ADDR_OWVAR 21
6562: PUSH
6563: LD_INT 2
6565: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6566: LD_ADDR_EXP 50
6570: PUSH
6571: LD_STRING Omar
6573: PPUSH
6574: CALL_OW 25
6578: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6579: LD_EXP 50
6583: PPUSH
6584: LD_INT 330
6586: PPUSH
6587: LD_INT 244
6589: PPUSH
6590: LD_INT 0
6592: PPUSH
6593: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6597: LD_EXP 50
6601: PPUSH
6602: LD_INT 22
6604: PUSH
6605: LD_INT 7
6607: PUSH
6608: EMPTY
6609: LIST
6610: LIST
6611: PPUSH
6612: CALL_OW 69
6616: PPUSH
6617: LD_EXP 50
6621: PPUSH
6622: CALL_OW 74
6626: PPUSH
6627: CALL_OW 112
// end ; end_of_file
6631: LD_VAR 0 1
6635: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6636: LD_INT 0
6638: PPUSH
6639: PPUSH
6640: PPUSH
6641: PPUSH
6642: PPUSH
// side := 8 ;
6643: LD_ADDR_VAR 0 3
6647: PUSH
6648: LD_INT 8
6650: ST_TO_ADDR
// InitHc ;
6651: CALL_OW 19
// uc_side := side ;
6655: LD_ADDR_OWVAR 20
6659: PUSH
6660: LD_VAR 0 3
6664: ST_TO_ADDR
// uc_nation := 2 ;
6665: LD_ADDR_OWVAR 21
6669: PUSH
6670: LD_INT 2
6672: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6673: LD_ADDR_VAR 0 2
6677: PUSH
6678: LD_INT 22
6680: PUSH
6681: LD_VAR 0 3
6685: PUSH
6686: EMPTY
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 21
6692: PUSH
6693: LD_INT 3
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PPUSH
6704: CALL_OW 69
6708: PUSH
6709: FOR_IN
6710: IFFALSE 6726
// SetBLevel ( i , 10 ) ;
6712: LD_VAR 0 2
6716: PPUSH
6717: LD_INT 10
6719: PPUSH
6720: CALL_OW 241
6724: GO 6709
6726: POP
6727: POP
// Schulz := NewCharacter ( Schulz ) ;
6728: LD_ADDR_EXP 51
6732: PUSH
6733: LD_STRING Schulz
6735: PPUSH
6736: CALL_OW 25
6740: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6741: LD_ADDR_EXP 52
6745: PUSH
6746: LD_STRING Kozlov
6748: PPUSH
6749: LD_INT 0
6751: PPUSH
6752: LD_STRING 
6754: PPUSH
6755: CALL 50399 0 3
6759: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6760: LD_EXP 52
6764: PPUSH
6765: LD_INT 22
6767: PUSH
6768: LD_INT 8
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: PUSH
6775: LD_INT 23
6777: PUSH
6778: LD_INT 3
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: PUSH
6785: LD_INT 30
6787: PUSH
6788: LD_INT 8
6790: PUSH
6791: EMPTY
6792: LIST
6793: LIST
6794: PUSH
6795: EMPTY
6796: LIST
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PUSH
6805: LD_INT 1
6807: ARRAY
6808: PPUSH
6809: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6813: LD_EXP 52
6817: PPUSH
6818: LD_INT 3
6820: PPUSH
6821: LD_INT 10
6823: PPUSH
6824: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6828: LD_ADDR_VAR 0 5
6832: PUSH
6833: LD_INT 22
6835: PUSH
6836: LD_VAR 0 3
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: PUSH
6845: LD_INT 30
6847: PUSH
6848: LD_INT 32
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 58
6857: PUSH
6858: EMPTY
6859: LIST
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: LIST
6865: PPUSH
6866: CALL_OW 69
6870: ST_TO_ADDR
// for i = 1 to 10 do
6871: LD_ADDR_VAR 0 2
6875: PUSH
6876: DOUBLE
6877: LD_INT 1
6879: DEC
6880: ST_TO_ADDR
6881: LD_INT 10
6883: PUSH
6884: FOR_TO
6885: IFFALSE 6957
// begin uc_nation := nation_nature ;
6887: LD_ADDR_OWVAR 21
6891: PUSH
6892: LD_INT 0
6894: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6895: LD_ADDR_OWVAR 28
6899: PUSH
6900: LD_INT 15
6902: ST_TO_ADDR
// hc_gallery :=  ;
6903: LD_ADDR_OWVAR 33
6907: PUSH
6908: LD_STRING 
6910: ST_TO_ADDR
// hc_name :=  ;
6911: LD_ADDR_OWVAR 26
6915: PUSH
6916: LD_STRING 
6918: ST_TO_ADDR
// un := CreateHuman ;
6919: LD_ADDR_VAR 0 4
6923: PUSH
6924: CALL_OW 44
6928: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6929: LD_VAR 0 4
6933: PPUSH
6934: LD_VAR 0 5
6938: PUSH
6939: LD_VAR 0 5
6943: PUSH
6944: LD_VAR 0 2
6948: MINUS
6949: ARRAY
6950: PPUSH
6951: CALL_OW 52
// end ;
6955: GO 6884
6957: POP
6958: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6959: LD_INT 324
6961: PPUSH
6962: LD_INT 3
6964: PPUSH
6965: LD_STRING 
6967: PPUSH
6968: LD_INT 8
6970: PUSH
6971: LD_INT 9
6973: PUSH
6974: LD_INT 10
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: LIST
6981: PUSH
6982: LD_OWVAR 67
6986: ARRAY
6987: PPUSH
6988: LD_INT 3000
6990: PUSH
6991: LD_INT 500
6993: PUSH
6994: LD_INT 150
6996: PUSH
6997: EMPTY
6998: LIST
6999: LIST
7000: LIST
7001: PPUSH
7002: LD_INT 16
7004: PUSH
7005: LD_INT 6
7007: PUSH
7008: LD_INT 6
7010: PUSH
7011: LD_INT 8
7013: PUSH
7014: EMPTY
7015: LIST
7016: LIST
7017: LIST
7018: LIST
7019: PPUSH
7020: CALL 60923 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7024: LD_ADDR_EXP 76
7028: PUSH
7029: LD_EXP 76
7033: PPUSH
7034: LD_INT 3
7036: PPUSH
7037: LD_INT 22
7039: PUSH
7040: LD_VAR 0 3
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PUSH
7049: LD_INT 23
7051: PUSH
7052: LD_INT 2
7054: PUSH
7055: EMPTY
7056: LIST
7057: LIST
7058: PUSH
7059: LD_INT 3
7061: PUSH
7062: LD_INT 21
7064: PUSH
7065: LD_INT 2
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: LIST
7080: PPUSH
7081: CALL_OW 69
7085: PUSH
7086: LD_EXP 51
7090: DIFF
7091: PPUSH
7092: CALL_OW 1
7096: ST_TO_ADDR
// end ;
7097: LD_VAR 0 1
7101: RET
// export function BuildKozlovBomb ; begin
7102: LD_INT 0
7104: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7105: LD_INT 332
7107: PPUSH
7108: CALL_OW 302
7112: NOT
7113: PUSH
7114: LD_INT 336
7116: PPUSH
7117: CALL_OW 302
7121: NOT
7122: OR
7123: IFFALSE 7127
// exit ;
7125: GO 7224
// ComChangeProfession ( Kozlov , 4 ) ;
7127: LD_EXP 52
7131: PPUSH
7132: LD_INT 4
7134: PPUSH
7135: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7139: LD_INT 336
7141: PPUSH
7142: LD_INT 25
7144: PPUSH
7145: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7149: LD_INT 35
7151: PPUSH
7152: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7156: LD_INT 25
7158: PPUSH
7159: LD_INT 8
7161: PPUSH
7162: CALL_OW 321
7166: PUSH
7167: LD_INT 2
7169: EQUAL
7170: IFFALSE 7149
// ComExitBuilding ( Kozlov ) ;
7172: LD_EXP 52
7176: PPUSH
7177: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7181: LD_EXP 52
7185: PPUSH
7186: LD_INT 332
7188: PPUSH
7189: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7193: LD_EXP 52
7197: PPUSH
7198: LD_INT 3
7200: PPUSH
7201: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7205: LD_INT 332
7207: PPUSH
7208: LD_INT 23
7210: PPUSH
7211: LD_INT 3
7213: PPUSH
7214: LD_INT 1
7216: PPUSH
7217: LD_INT 48
7219: PPUSH
7220: CALL_OW 125
// end ;
7224: LD_VAR 0 1
7228: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7229: LD_EXP 3
7233: NOT
7234: PUSH
7235: LD_INT 3
7237: PPUSH
7238: LD_INT 1
7240: PPUSH
7241: CALL 45473 0 2
7245: NOT
7246: AND
7247: IFFALSE 8087
7249: GO 7251
7251: DISABLE
7252: LD_INT 0
7254: PPUSH
7255: PPUSH
7256: PPUSH
// begin enable ;
7257: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7258: LD_INT 22
7260: PUSH
7261: LD_INT 8
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: LD_INT 23
7270: PUSH
7271: LD_INT 2
7273: PUSH
7274: EMPTY
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 30
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: EMPTY
7285: LIST
7286: LIST
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: LIST
7292: PPUSH
7293: CALL_OW 69
7297: NOT
7298: IFFALSE 7302
// exit ;
7300: GO 8087
// if Prob ( 40 ) then
7302: LD_INT 40
7304: PPUSH
7305: CALL_OW 13
7309: IFFALSE 7436
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7311: LD_INT 3
7313: PPUSH
7314: LD_INT 14
7316: PUSH
7317: LD_INT 1
7319: PUSH
7320: LD_INT 2
7322: PUSH
7323: LD_INT 28
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: LIST
7330: LIST
7331: PUSH
7332: LD_INT 14
7334: PUSH
7335: LD_INT 1
7337: PUSH
7338: LD_INT 2
7340: PUSH
7341: LD_INT 28
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: LIST
7348: LIST
7349: PUSH
7350: LD_INT 14
7352: PUSH
7353: LD_INT 1
7355: PUSH
7356: LD_INT 2
7358: PUSH
7359: LD_INT 28
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: PUSH
7368: LD_INT 14
7370: PUSH
7371: LD_INT 1
7373: PUSH
7374: LD_INT 2
7376: PUSH
7377: LD_INT 28
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 14
7388: PUSH
7389: LD_INT 1
7391: PUSH
7392: LD_INT 2
7394: PUSH
7395: LD_INT 28
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: PUSH
7404: LD_INT 14
7406: PUSH
7407: LD_INT 1
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: LD_INT 26
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: LIST
7420: LIST
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PPUSH
7430: CALL 44055 0 2
// end else
7434: GO 7627
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7436: LD_INT 3
7438: PPUSH
7439: LD_INT 14
7441: PUSH
7442: LD_INT 1
7444: PUSH
7445: LD_INT 2
7447: PUSH
7448: LD_INT 27
7450: PUSH
7451: LD_INT 26
7453: PUSH
7454: LD_INT 26
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: LIST
7461: PUSH
7462: LD_OWVAR 67
7466: ARRAY
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: LD_INT 14
7476: PUSH
7477: LD_INT 1
7479: PUSH
7480: LD_INT 2
7482: PUSH
7483: LD_INT 27
7485: PUSH
7486: LD_INT 26
7488: PUSH
7489: LD_INT 26
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: LIST
7496: PUSH
7497: LD_OWVAR 67
7501: ARRAY
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 14
7511: PUSH
7512: LD_INT 1
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: LD_INT 26
7520: PUSH
7521: LD_INT 26
7523: PUSH
7524: LD_INT 29
7526: PUSH
7527: EMPTY
7528: LIST
7529: LIST
7530: LIST
7531: PUSH
7532: LD_OWVAR 67
7536: ARRAY
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: LIST
7542: LIST
7543: PUSH
7544: LD_INT 13
7546: PUSH
7547: LD_INT 1
7549: PUSH
7550: LD_INT 2
7552: PUSH
7553: LD_INT 26
7555: PUSH
7556: LD_INT 29
7558: PUSH
7559: LD_INT 29
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: LIST
7566: PUSH
7567: LD_OWVAR 67
7571: ARRAY
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 13
7581: PUSH
7582: LD_INT 1
7584: PUSH
7585: LD_INT 2
7587: PUSH
7588: LD_INT 29
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: LD_INT 14
7599: PUSH
7600: LD_INT 1
7602: PUSH
7603: LD_INT 2
7605: PUSH
7606: LD_INT 26
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: PPUSH
7623: CALL 44055 0 2
// end ; repeat wait ( 0 0$1 ) ;
7627: LD_INT 35
7629: PPUSH
7630: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7634: LD_INT 3
7636: PPUSH
7637: LD_INT 1
7639: PPUSH
7640: CALL 45473 0 2
7644: PUSH
7645: LD_INT 6
7647: GREATEREQUAL
7648: IFFALSE 7627
// wait ( 0 0$30 ) ;
7650: LD_INT 1050
7652: PPUSH
7653: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7657: LD_ADDR_VAR 0 2
7661: PUSH
7662: LD_INT 3
7664: PPUSH
7665: LD_INT 1
7667: PPUSH
7668: CALL 45473 0 2
7672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7673: LD_ADDR_EXP 95
7677: PUSH
7678: LD_EXP 95
7682: PPUSH
7683: LD_INT 3
7685: PPUSH
7686: LD_EXP 95
7690: PUSH
7691: LD_INT 3
7693: ARRAY
7694: PUSH
7695: LD_VAR 0 2
7699: DIFF
7700: PPUSH
7701: CALL_OW 1
7705: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7706: LD_ADDR_VAR 0 3
7710: PUSH
7711: LD_INT 0
7713: PPUSH
7714: LD_INT 2
7716: PPUSH
7717: CALL_OW 12
7721: ST_TO_ADDR
// if target then
7722: LD_VAR 0 3
7726: IFFALSE 7854
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7728: LD_ADDR_VAR 0 2
7732: PUSH
7733: LD_VAR 0 2
7737: PPUSH
7738: LD_INT 24
7740: PUSH
7741: LD_INT 250
7743: PUSH
7744: EMPTY
7745: LIST
7746: LIST
7747: PPUSH
7748: CALL_OW 72
7752: ST_TO_ADDR
// for i in tmp do
7753: LD_ADDR_VAR 0 1
7757: PUSH
7758: LD_VAR 0 2
7762: PUSH
7763: FOR_IN
7764: IFFALSE 7804
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7766: LD_VAR 0 1
7770: PPUSH
7771: LD_INT 89
7773: PPUSH
7774: LD_INT 71
7776: PPUSH
7777: CALL_OW 297
7781: PUSH
7782: LD_INT 9
7784: GREATER
7785: IFFALSE 7802
// ComMoveXY ( i , 89 , 71 ) ;
7787: LD_VAR 0 1
7791: PPUSH
7792: LD_INT 89
7794: PPUSH
7795: LD_INT 71
7797: PPUSH
7798: CALL_OW 111
7802: GO 7763
7804: POP
7805: POP
// wait ( 0 0$1 ) ;
7806: LD_INT 35
7808: PPUSH
7809: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7813: LD_VAR 0 2
7817: PPUSH
7818: LD_INT 92
7820: PUSH
7821: LD_INT 89
7823: PUSH
7824: LD_INT 71
7826: PUSH
7827: LD_INT 9
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: PPUSH
7836: CALL_OW 72
7840: PUSH
7841: LD_VAR 0 2
7845: PUSH
7846: LD_INT 1
7848: MINUS
7849: GREATEREQUAL
7850: IFFALSE 7728
// end else
7852: GO 7978
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_VAR 0 2
7863: PPUSH
7864: LD_INT 24
7866: PUSH
7867: LD_INT 250
7869: PUSH
7870: EMPTY
7871: LIST
7872: LIST
7873: PPUSH
7874: CALL_OW 72
7878: ST_TO_ADDR
// for i in tmp do
7879: LD_ADDR_VAR 0 1
7883: PUSH
7884: LD_VAR 0 2
7888: PUSH
7889: FOR_IN
7890: IFFALSE 7930
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7892: LD_VAR 0 1
7896: PPUSH
7897: LD_INT 147
7899: PPUSH
7900: LD_INT 4
7902: PPUSH
7903: CALL_OW 297
7907: PUSH
7908: LD_INT 9
7910: GREATER
7911: IFFALSE 7928
// ComMoveXY ( i , 147 , 4 ) ;
7913: LD_VAR 0 1
7917: PPUSH
7918: LD_INT 147
7920: PPUSH
7921: LD_INT 4
7923: PPUSH
7924: CALL_OW 111
7928: GO 7889
7930: POP
7931: POP
// wait ( 0 0$1 ) ;
7932: LD_INT 35
7934: PPUSH
7935: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7939: LD_VAR 0 2
7943: PPUSH
7944: LD_INT 92
7946: PUSH
7947: LD_INT 147
7949: PUSH
7950: LD_INT 4
7952: PUSH
7953: LD_INT 9
7955: PUSH
7956: EMPTY
7957: LIST
7958: LIST
7959: LIST
7960: LIST
7961: PPUSH
7962: CALL_OW 72
7966: PUSH
7967: LD_VAR 0 2
7971: PUSH
7972: LD_INT 1
7974: MINUS
7975: GREATEREQUAL
7976: IFFALSE 7854
// end ; repeat wait ( 0 0$1 ) ;
7978: LD_INT 35
7980: PPUSH
7981: CALL_OW 67
// for i in tmp do
7985: LD_ADDR_VAR 0 1
7989: PUSH
7990: LD_VAR 0 2
7994: PUSH
7995: FOR_IN
7996: IFFALSE 8078
// begin if GetLives ( i ) > 251 then
7998: LD_VAR 0 1
8002: PPUSH
8003: CALL_OW 256
8007: PUSH
8008: LD_INT 251
8010: GREATER
8011: IFFALSE 8049
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8013: LD_VAR 0 1
8017: PPUSH
8018: LD_INT 81
8020: PUSH
8021: LD_INT 8
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PPUSH
8028: CALL_OW 69
8032: PPUSH
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 74
8042: PPUSH
8043: CALL_OW 115
8047: GO 8076
// if IsDead ( i ) then
8049: LD_VAR 0 1
8053: PPUSH
8054: CALL_OW 301
8058: IFFALSE 8076
// tmp := tmp diff i ;
8060: LD_ADDR_VAR 0 2
8064: PUSH
8065: LD_VAR 0 2
8069: PUSH
8070: LD_VAR 0 1
8074: DIFF
8075: ST_TO_ADDR
// end ;
8076: GO 7995
8078: POP
8079: POP
// until not tmp ;
8080: LD_VAR 0 2
8084: NOT
8085: IFFALSE 7978
// end ;
8087: PPOPN 3
8089: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8090: LD_EXP 52
8094: PPUSH
8095: CALL_OW 302
8099: PUSH
8100: LD_EXP 3
8104: NOT
8105: AND
8106: IFFALSE 8115
8108: GO 8110
8110: DISABLE
// BuildKozlovBomb ;
8111: CALL 7102 0 0
8115: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8116: LD_INT 22
8118: PUSH
8119: LD_INT 8
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: PUSH
8126: LD_INT 34
8128: PUSH
8129: LD_INT 48
8131: PUSH
8132: EMPTY
8133: LIST
8134: LIST
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: PPUSH
8140: CALL_OW 69
8144: IFFALSE 8192
8146: GO 8148
8148: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8149: LD_INT 22
8151: PUSH
8152: LD_INT 8
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PUSH
8159: LD_INT 34
8161: PUSH
8162: LD_INT 48
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 69
8177: PUSH
8178: LD_INT 1
8180: ARRAY
8181: PPUSH
8182: LD_INT 173
8184: PPUSH
8185: LD_INT 96
8187: PPUSH
8188: CALL_OW 116
// end ; end_of_file
8192: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8193: LD_INT 0
8195: PPUSH
8196: PPUSH
8197: PPUSH
8198: PPUSH
8199: PPUSH
8200: PPUSH
8201: PPUSH
8202: PPUSH
8203: PPUSH
// side := 3 ;
8204: LD_ADDR_VAR 0 6
8208: PUSH
8209: LD_INT 3
8211: ST_TO_ADDR
// InitHc ;
8212: CALL_OW 19
// uc_side := side ;
8216: LD_ADDR_OWVAR 20
8220: PUSH
8221: LD_VAR 0 6
8225: ST_TO_ADDR
// uc_nation := 3 ;
8226: LD_ADDR_OWVAR 21
8230: PUSH
8231: LD_INT 3
8233: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8234: LD_ADDR_VAR 0 2
8238: PUSH
8239: LD_INT 22
8241: PUSH
8242: LD_VAR 0 6
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: LD_INT 21
8253: PUSH
8254: LD_INT 3
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PPUSH
8265: CALL_OW 69
8269: PUSH
8270: FOR_IN
8271: IFFALSE 8287
// SetBLevel ( i , 10 ) ;
8273: LD_VAR 0 2
8277: PPUSH
8278: LD_INT 10
8280: PPUSH
8281: CALL_OW 241
8285: GO 8270
8287: POP
8288: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8289: LD_ADDR_VAR 0 9
8293: PUSH
8294: LD_INT 22
8296: PUSH
8297: LD_VAR 0 6
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PUSH
8306: LD_INT 30
8308: PUSH
8309: LD_INT 34
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: PPUSH
8320: CALL_OW 69
8324: ST_TO_ADDR
// if teleport then
8325: LD_VAR 0 9
8329: IFFALSE 8350
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8331: LD_VAR 0 9
8335: PUSH
8336: LD_INT 1
8338: ARRAY
8339: PPUSH
8340: LD_INT 123
8342: PPUSH
8343: LD_INT 122
8345: PPUSH
8346: CALL_OW 243
// hc_importance := 0 ;
8350: LD_ADDR_OWVAR 32
8354: PUSH
8355: LD_INT 0
8357: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8358: LD_ADDR_EXP 53
8362: PUSH
8363: LD_STRING Platonov
8365: PPUSH
8366: CALL_OW 25
8370: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8371: LD_ADDR_EXP 54
8375: PUSH
8376: LD_STRING Yakotich
8378: PPUSH
8379: CALL_OW 25
8383: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8384: LD_ADDR_EXP 55
8388: PUSH
8389: LD_STRING Gleb
8391: PPUSH
8392: CALL_OW 25
8396: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8397: LD_STRING 03_Cornel
8399: PPUSH
8400: CALL_OW 28
8404: IFFALSE 8452
// begin Bierezov := NewCharacter ( Mikhail ) ;
8406: LD_ADDR_EXP 56
8410: PUSH
8411: LD_STRING Mikhail
8413: PPUSH
8414: CALL_OW 25
8418: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8419: LD_EXP 56
8423: PPUSH
8424: LD_INT 197
8426: PPUSH
8427: LD_INT 111
8429: PPUSH
8430: LD_INT 9
8432: PPUSH
8433: LD_INT 0
8435: PPUSH
8436: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8440: LD_EXP 56
8444: PPUSH
8445: LD_INT 3
8447: PPUSH
8448: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8452: LD_EXP 53
8456: PPUSH
8457: LD_INT 126
8459: PPUSH
8460: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8464: LD_EXP 54
8468: PPUSH
8469: LD_INT 197
8471: PPUSH
8472: LD_INT 111
8474: PPUSH
8475: LD_INT 9
8477: PPUSH
8478: LD_INT 0
8480: PPUSH
8481: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8485: LD_EXP 55
8489: PPUSH
8490: LD_INT 197
8492: PPUSH
8493: LD_INT 111
8495: PPUSH
8496: LD_INT 9
8498: PPUSH
8499: LD_INT 0
8501: PPUSH
8502: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8506: LD_ADDR_VAR 0 5
8510: PUSH
8511: LD_INT 126
8513: PPUSH
8514: LD_INT 2
8516: PPUSH
8517: LD_STRING zhukov
8519: PPUSH
8520: LD_INT 9
8522: PUSH
8523: LD_INT 10
8525: PUSH
8526: LD_INT 10
8528: PUSH
8529: EMPTY
8530: LIST
8531: LIST
8532: LIST
8533: PUSH
8534: LD_OWVAR 67
8538: ARRAY
8539: PPUSH
8540: LD_INT 90000
8542: PUSH
8543: LD_INT 1000
8545: PUSH
8546: LD_INT 300
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: LIST
8553: PPUSH
8554: LD_INT 21
8556: PUSH
8557: LD_INT 8
8559: PUSH
8560: LD_INT 13
8562: PUSH
8563: LD_INT 8
8565: PUSH
8566: EMPTY
8567: LIST
8568: LIST
8569: LIST
8570: LIST
8571: PPUSH
8572: CALL 60923 0 6
8576: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8577: LD_ADDR_VAR 0 4
8581: PUSH
8582: LD_INT 267
8584: PPUSH
8585: CALL_OW 274
8589: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8590: LD_VAR 0 4
8594: PPUSH
8595: LD_INT 1
8597: PPUSH
8598: LD_INT 5000
8600: PPUSH
8601: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8605: LD_VAR 0 4
8609: PPUSH
8610: LD_INT 2
8612: PPUSH
8613: LD_INT 200
8615: PPUSH
8616: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8620: LD_VAR 0 4
8624: PPUSH
8625: LD_INT 3
8627: PPUSH
8628: LD_INT 200
8630: PPUSH
8631: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8635: LD_ADDR_EXP 76
8639: PUSH
8640: LD_EXP 76
8644: PPUSH
8645: LD_INT 2
8647: PPUSH
8648: LD_VAR 0 5
8652: PUSH
8653: LD_INT 22
8655: PUSH
8656: LD_VAR 0 6
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: PUSH
8665: LD_INT 3
8667: PUSH
8668: LD_INT 21
8670: PUSH
8671: LD_INT 2
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: PPUSH
8686: CALL_OW 69
8690: UNION
8691: PUSH
8692: LD_EXP 53
8696: DIFF
8697: PPUSH
8698: CALL_OW 1
8702: ST_TO_ADDR
// behemoths := [ ] ;
8703: LD_ADDR_EXP 57
8707: PUSH
8708: EMPTY
8709: ST_TO_ADDR
// behemothBuilders := [ ] ;
8710: LD_ADDR_EXP 58
8714: PUSH
8715: EMPTY
8716: ST_TO_ADDR
// j := 3 ;
8717: LD_ADDR_VAR 0 3
8721: PUSH
8722: LD_INT 3
8724: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8725: LD_ADDR_VAR 0 2
8729: PUSH
8730: LD_INT 22
8732: PUSH
8733: LD_INT 3
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: LD_INT 25
8742: PUSH
8743: LD_INT 3
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: PUSH
8750: EMPTY
8751: LIST
8752: LIST
8753: PPUSH
8754: CALL_OW 69
8758: PUSH
8759: FOR_IN
8760: IFFALSE 8810
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8762: LD_ADDR_EXP 58
8766: PUSH
8767: LD_EXP 58
8771: PPUSH
8772: LD_VAR 0 2
8776: PPUSH
8777: CALL 93259 0 2
8781: ST_TO_ADDR
// j := j - 1 ;
8782: LD_ADDR_VAR 0 3
8786: PUSH
8787: LD_VAR 0 3
8791: PUSH
8792: LD_INT 1
8794: MINUS
8795: ST_TO_ADDR
// if j = 0 then
8796: LD_VAR 0 3
8800: PUSH
8801: LD_INT 0
8803: EQUAL
8804: IFFALSE 8808
// break ;
8806: GO 8810
// end ;
8808: GO 8759
8810: POP
8811: POP
// end ;
8812: LD_VAR 0 1
8816: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8817: LD_INT 0
8819: PPUSH
8820: PPUSH
8821: PPUSH
8822: PPUSH
8823: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8824: LD_ADDR_VAR 0 4
8828: PUSH
8829: LD_INT 209
8831: PUSH
8832: LD_INT 149
8834: PUSH
8835: EMPTY
8836: LIST
8837: LIST
8838: PUSH
8839: LD_INT 219
8841: PUSH
8842: LD_INT 154
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PUSH
8849: LD_INT 223
8851: PUSH
8852: LD_INT 149
8854: PUSH
8855: EMPTY
8856: LIST
8857: LIST
8858: PUSH
8859: LD_INT 232
8861: PUSH
8862: LD_INT 155
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: LIST
8873: LIST
8874: ST_TO_ADDR
// if not behemothBuilders then
8875: LD_EXP 58
8879: NOT
8880: IFFALSE 8884
// exit ;
8882: GO 8988
// j := 1 ;
8884: LD_ADDR_VAR 0 3
8888: PUSH
8889: LD_INT 1
8891: ST_TO_ADDR
// for i in behemothBuilders do
8892: LD_ADDR_VAR 0 2
8896: PUSH
8897: LD_EXP 58
8901: PUSH
8902: FOR_IN
8903: IFFALSE 8986
// begin if IsInUnit ( i ) then
8905: LD_VAR 0 2
8909: PPUSH
8910: CALL_OW 310
8914: IFFALSE 8925
// ComExitBuilding ( i ) ;
8916: LD_VAR 0 2
8920: PPUSH
8921: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8925: LD_VAR 0 2
8929: PPUSH
8930: LD_INT 37
8932: PPUSH
8933: LD_VAR 0 4
8937: PUSH
8938: LD_VAR 0 3
8942: ARRAY
8943: PUSH
8944: LD_INT 1
8946: ARRAY
8947: PPUSH
8948: LD_VAR 0 4
8952: PUSH
8953: LD_VAR 0 3
8957: ARRAY
8958: PUSH
8959: LD_INT 2
8961: ARRAY
8962: PPUSH
8963: LD_INT 0
8965: PPUSH
8966: CALL_OW 230
// j := j + 1 ;
8970: LD_ADDR_VAR 0 3
8974: PUSH
8975: LD_VAR 0 3
8979: PUSH
8980: LD_INT 1
8982: PLUS
8983: ST_TO_ADDR
// end ;
8984: GO 8902
8986: POP
8987: POP
// end ;
8988: LD_VAR 0 1
8992: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8993: LD_INT 3
8995: PPUSH
8996: CALL 93307 0 1
9000: PUSH
9001: LD_INT 22
9003: PUSH
9004: LD_INT 3
9006: PUSH
9007: EMPTY
9008: LIST
9009: LIST
9010: PUSH
9011: LD_INT 30
9013: PUSH
9014: LD_INT 37
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: PUSH
9021: EMPTY
9022: LIST
9023: LIST
9024: PPUSH
9025: CALL_OW 69
9029: NOT
9030: AND
9031: IFFALSE 9217
9033: GO 9035
9035: DISABLE
9036: LD_INT 0
9038: PPUSH
9039: PPUSH
// begin enable ;
9040: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9041: LD_ADDR_VAR 0 2
9045: PUSH
9046: LD_INT 3
9048: PPUSH
9049: CALL 93307 0 1
9053: ST_TO_ADDR
// for i in tmp do
9054: LD_ADDR_VAR 0 1
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: FOR_IN
9065: IFFALSE 9215
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9067: LD_VAR 0 1
9071: PPUSH
9072: LD_INT 7
9074: PPUSH
9075: CALL_OW 308
9079: PUSH
9080: LD_VAR 0 1
9084: PPUSH
9085: CALL_OW 110
9089: PUSH
9090: LD_INT 2
9092: EQUAL
9093: NOT
9094: AND
9095: IFFALSE 9109
// SetTag ( i , 2 ) ;
9097: LD_VAR 0 1
9101: PPUSH
9102: LD_INT 2
9104: PPUSH
9105: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9109: LD_INT 81
9111: PUSH
9112: LD_INT 3
9114: PUSH
9115: EMPTY
9116: LIST
9117: LIST
9118: PUSH
9119: LD_INT 91
9121: PUSH
9122: LD_VAR 0 1
9126: PUSH
9127: LD_INT 12
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: LIST
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: PPUSH
9139: CALL_OW 69
9143: NOT
9144: PUSH
9145: LD_VAR 0 1
9149: PPUSH
9150: CALL_OW 110
9154: PUSH
9155: LD_INT 2
9157: EQUAL
9158: NOT
9159: AND
9160: IFFALSE 9179
// ComAgressiveMove ( i , 64 , 93 ) else
9162: LD_VAR 0 1
9166: PPUSH
9167: LD_INT 64
9169: PPUSH
9170: LD_INT 93
9172: PPUSH
9173: CALL_OW 114
9177: GO 9213
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9179: LD_VAR 0 1
9183: PPUSH
9184: LD_INT 81
9186: PUSH
9187: LD_INT 3
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: PPUSH
9194: CALL_OW 69
9198: PPUSH
9199: LD_VAR 0 1
9203: PPUSH
9204: CALL_OW 74
9208: PPUSH
9209: CALL_OW 115
// end ;
9213: GO 9064
9215: POP
9216: POP
// end ;
9217: PPOPN 2
9219: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9220: LD_EXP 2
9224: NOT
9225: PUSH
9226: LD_INT 2
9228: PPUSH
9229: LD_INT 1
9231: PPUSH
9232: CALL 45473 0 2
9236: NOT
9237: AND
9238: IFFALSE 10158
9240: GO 9242
9242: DISABLE
9243: LD_INT 0
9245: PPUSH
9246: PPUSH
9247: PPUSH
9248: PPUSH
// begin enable ;
9249: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9250: LD_INT 22
9252: PUSH
9253: LD_INT 3
9255: PUSH
9256: EMPTY
9257: LIST
9258: LIST
9259: PUSH
9260: LD_INT 30
9262: PUSH
9263: LD_INT 3
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: PUSH
9270: EMPTY
9271: LIST
9272: LIST
9273: PPUSH
9274: CALL_OW 69
9278: NOT
9279: IFFALSE 9283
// exit ;
9281: GO 10158
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9283: LD_ADDR_VAR 0 4
9287: PUSH
9288: LD_INT 22
9290: PUSH
9291: LD_INT 3
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: PUSH
9298: LD_INT 30
9300: PUSH
9301: LD_INT 34
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: PPUSH
9312: CALL_OW 69
9316: ST_TO_ADDR
// if Prob ( 40 ) then
9317: LD_INT 40
9319: PPUSH
9320: CALL_OW 13
9324: IFFALSE 9451
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9326: LD_INT 2
9328: PPUSH
9329: LD_INT 22
9331: PUSH
9332: LD_INT 3
9334: PUSH
9335: LD_INT 3
9337: PUSH
9338: LD_INT 49
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: PUSH
9347: LD_INT 22
9349: PUSH
9350: LD_INT 3
9352: PUSH
9353: LD_INT 3
9355: PUSH
9356: LD_INT 49
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: LIST
9364: PUSH
9365: LD_INT 22
9367: PUSH
9368: LD_INT 3
9370: PUSH
9371: LD_INT 3
9373: PUSH
9374: LD_INT 49
9376: PUSH
9377: EMPTY
9378: LIST
9379: LIST
9380: LIST
9381: LIST
9382: PUSH
9383: LD_INT 24
9385: PUSH
9386: LD_INT 3
9388: PUSH
9389: LD_INT 3
9391: PUSH
9392: LD_INT 46
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: LIST
9400: PUSH
9401: LD_INT 24
9403: PUSH
9404: LD_INT 3
9406: PUSH
9407: LD_INT 3
9409: PUSH
9410: LD_INT 46
9412: PUSH
9413: EMPTY
9414: LIST
9415: LIST
9416: LIST
9417: LIST
9418: PUSH
9419: LD_INT 24
9421: PUSH
9422: LD_INT 3
9424: PUSH
9425: LD_INT 3
9427: PUSH
9428: LD_INT 46
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: LIST
9436: PUSH
9437: EMPTY
9438: LIST
9439: LIST
9440: LIST
9441: LIST
9442: LIST
9443: LIST
9444: PPUSH
9445: CALL 44055 0 2
// end else
9449: GO 9574
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9451: LD_INT 2
9453: PPUSH
9454: LD_INT 24
9456: PUSH
9457: LD_INT 3
9459: PUSH
9460: LD_INT 3
9462: PUSH
9463: LD_INT 47
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: LIST
9470: LIST
9471: PUSH
9472: LD_INT 24
9474: PUSH
9475: LD_INT 3
9477: PUSH
9478: LD_INT 3
9480: PUSH
9481: LD_INT 47
9483: PUSH
9484: EMPTY
9485: LIST
9486: LIST
9487: LIST
9488: LIST
9489: PUSH
9490: LD_INT 24
9492: PUSH
9493: LD_INT 3
9495: PUSH
9496: LD_INT 3
9498: PUSH
9499: LD_INT 47
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 24
9510: PUSH
9511: LD_INT 3
9513: PUSH
9514: LD_INT 3
9516: PUSH
9517: LD_INT 46
9519: PUSH
9520: EMPTY
9521: LIST
9522: LIST
9523: LIST
9524: LIST
9525: PUSH
9526: LD_INT 24
9528: PUSH
9529: LD_INT 3
9531: PUSH
9532: LD_INT 3
9534: PUSH
9535: LD_INT 46
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: LIST
9543: PUSH
9544: LD_INT 24
9546: PUSH
9547: LD_INT 3
9549: PUSH
9550: LD_INT 3
9552: PUSH
9553: LD_INT 46
9555: PUSH
9556: EMPTY
9557: LIST
9558: LIST
9559: LIST
9560: LIST
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: LIST
9569: PPUSH
9570: CALL 44055 0 2
// end ; if Difficulty > 1 then
9574: LD_OWVAR 67
9578: PUSH
9579: LD_INT 1
9581: GREATER
9582: IFFALSE 9612
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9584: LD_INT 2
9586: PPUSH
9587: LD_INT 24
9589: PUSH
9590: LD_INT 3
9592: PUSH
9593: LD_INT 3
9595: PUSH
9596: LD_INT 47
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: LIST
9603: LIST
9604: PUSH
9605: EMPTY
9606: LIST
9607: PPUSH
9608: CALL 44055 0 2
// repeat wait ( 0 0$1 ) ;
9612: LD_INT 35
9614: PPUSH
9615: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9619: LD_INT 2
9621: PPUSH
9622: LD_INT 1
9624: PPUSH
9625: CALL 45473 0 2
9629: PUSH
9630: LD_INT 6
9632: PUSH
9633: LD_INT 7
9635: PUSH
9636: LD_INT 7
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: PUSH
9644: LD_OWVAR 67
9648: ARRAY
9649: GREATEREQUAL
9650: IFFALSE 9612
// wait ( 0 0$30 ) ;
9652: LD_INT 1050
9654: PPUSH
9655: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9659: LD_ADDR_VAR 0 2
9663: PUSH
9664: LD_INT 2
9666: PPUSH
9667: LD_INT 1
9669: PPUSH
9670: CALL 45473 0 2
9674: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9675: LD_ADDR_EXP 95
9679: PUSH
9680: LD_EXP 95
9684: PPUSH
9685: LD_INT 2
9687: PPUSH
9688: LD_EXP 95
9692: PUSH
9693: LD_INT 2
9695: ARRAY
9696: PUSH
9697: LD_VAR 0 2
9701: DIFF
9702: PPUSH
9703: CALL_OW 1
9707: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9708: LD_ADDR_VAR 0 3
9712: PUSH
9713: LD_INT 0
9715: PPUSH
9716: LD_INT 1
9718: PPUSH
9719: CALL_OW 12
9723: ST_TO_ADDR
// if target then
9724: LD_VAR 0 3
9728: IFFALSE 9856
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9730: LD_ADDR_VAR 0 2
9734: PUSH
9735: LD_VAR 0 2
9739: PPUSH
9740: LD_INT 24
9742: PUSH
9743: LD_INT 250
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PPUSH
9750: CALL_OW 72
9754: ST_TO_ADDR
// for i in tmp do
9755: LD_ADDR_VAR 0 1
9759: PUSH
9760: LD_VAR 0 2
9764: PUSH
9765: FOR_IN
9766: IFFALSE 9806
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9768: LD_VAR 0 1
9772: PPUSH
9773: LD_INT 139
9775: PPUSH
9776: LD_INT 89
9778: PPUSH
9779: CALL_OW 297
9783: PUSH
9784: LD_INT 9
9786: GREATER
9787: IFFALSE 9804
// ComMoveXY ( i , 139 , 89 ) ;
9789: LD_VAR 0 1
9793: PPUSH
9794: LD_INT 139
9796: PPUSH
9797: LD_INT 89
9799: PPUSH
9800: CALL_OW 111
9804: GO 9765
9806: POP
9807: POP
// wait ( 0 0$1 ) ;
9808: LD_INT 35
9810: PPUSH
9811: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9815: LD_VAR 0 2
9819: PPUSH
9820: LD_INT 92
9822: PUSH
9823: LD_INT 139
9825: PUSH
9826: LD_INT 89
9828: PUSH
9829: LD_INT 9
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: PPUSH
9838: CALL_OW 72
9842: PUSH
9843: LD_VAR 0 2
9847: PUSH
9848: LD_INT 1
9850: MINUS
9851: GREATEREQUAL
9852: IFFALSE 9730
// end else
9854: GO 9998
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9856: LD_VAR 0 2
9860: PPUSH
9861: LD_VAR 0 4
9865: PUSH
9866: LD_INT 1
9868: ARRAY
9869: PPUSH
9870: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9874: LD_ADDR_VAR 0 2
9878: PUSH
9879: LD_VAR 0 2
9883: PPUSH
9884: LD_INT 24
9886: PUSH
9887: LD_INT 250
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PPUSH
9894: CALL_OW 72
9898: ST_TO_ADDR
// for i in tmp do
9899: LD_ADDR_VAR 0 1
9903: PUSH
9904: LD_VAR 0 2
9908: PUSH
9909: FOR_IN
9910: IFFALSE 9950
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9912: LD_VAR 0 1
9916: PPUSH
9917: LD_INT 124
9919: PPUSH
9920: LD_INT 139
9922: PPUSH
9923: CALL_OW 297
9927: PUSH
9928: LD_INT 9
9930: GREATER
9931: IFFALSE 9948
// ComMoveXY ( i , 124 , 139 ) ;
9933: LD_VAR 0 1
9937: PPUSH
9938: LD_INT 124
9940: PPUSH
9941: LD_INT 139
9943: PPUSH
9944: CALL_OW 111
9948: GO 9909
9950: POP
9951: POP
// wait ( 0 0$1 ) ;
9952: LD_INT 35
9954: PPUSH
9955: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9959: LD_VAR 0 2
9963: PPUSH
9964: LD_INT 92
9966: PUSH
9967: LD_INT 124
9969: PUSH
9970: LD_INT 139
9972: PUSH
9973: LD_INT 9
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: LIST
9980: LIST
9981: PPUSH
9982: CALL_OW 72
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 1
9994: MINUS
9995: GREATEREQUAL
9996: IFFALSE 9874
// end ; repeat wait ( 0 0$1 ) ;
9998: LD_INT 35
10000: PPUSH
10001: CALL_OW 67
// for i in tmp do
10005: LD_ADDR_VAR 0 1
10009: PUSH
10010: LD_VAR 0 2
10014: PUSH
10015: FOR_IN
10016: IFFALSE 10149
// begin if GetLives ( i ) > 251 then
10018: LD_VAR 0 1
10022: PPUSH
10023: CALL_OW 256
10027: PUSH
10028: LD_INT 251
10030: GREATER
10031: IFFALSE 10120
// begin if GetWeapon ( i ) = ru_time_lapser then
10033: LD_VAR 0 1
10037: PPUSH
10038: CALL_OW 264
10042: PUSH
10043: LD_INT 49
10045: EQUAL
10046: IFFALSE 10084
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10048: LD_VAR 0 1
10052: PPUSH
10053: LD_INT 81
10055: PUSH
10056: LD_INT 3
10058: PUSH
10059: EMPTY
10060: LIST
10061: LIST
10062: PPUSH
10063: CALL_OW 69
10067: PPUSH
10068: LD_VAR 0 1
10072: PPUSH
10073: CALL_OW 74
10077: PPUSH
10078: CALL_OW 112
10082: GO 10118
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10084: LD_VAR 0 1
10088: PPUSH
10089: LD_INT 81
10091: PUSH
10092: LD_INT 3
10094: PUSH
10095: EMPTY
10096: LIST
10097: LIST
10098: PPUSH
10099: CALL_OW 69
10103: PPUSH
10104: LD_VAR 0 1
10108: PPUSH
10109: CALL_OW 74
10113: PPUSH
10114: CALL_OW 115
// end else
10118: GO 10147
// if IsDead ( i ) then
10120: LD_VAR 0 1
10124: PPUSH
10125: CALL_OW 301
10129: IFFALSE 10147
// tmp := tmp diff i ;
10131: LD_ADDR_VAR 0 2
10135: PUSH
10136: LD_VAR 0 2
10140: PUSH
10141: LD_VAR 0 1
10145: DIFF
10146: ST_TO_ADDR
// end ;
10147: GO 10015
10149: POP
10150: POP
// until not tmp ;
10151: LD_VAR 0 2
10155: NOT
10156: IFFALSE 9998
// end ;
10158: PPOPN 4
10160: END
// every 30 30$00 trigger not russianDestroyed do
10161: LD_EXP 2
10165: NOT
10166: IFFALSE 10231
10168: GO 10170
10170: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10171: LD_INT 105000
10173: PUSH
10174: LD_INT 84000
10176: PUSH
10177: LD_INT 63000
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: LIST
10184: PUSH
10185: LD_OWVAR 67
10189: ARRAY
10190: PPUSH
10191: CALL_OW 67
// if russianDestroyed then
10195: LD_EXP 2
10199: IFFALSE 10203
// exit ;
10201: GO 10231
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10203: LD_INT 2
10205: PPUSH
10206: LD_INT 23
10208: PUSH
10209: LD_INT 3
10211: PUSH
10212: LD_INT 1
10214: PUSH
10215: LD_INT 48
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: LIST
10222: LIST
10223: PUSH
10224: EMPTY
10225: LIST
10226: PPUSH
10227: CALL 44055 0 2
// end ; end_of_file
10231: END
// export function CustomEvent ( event ) ; begin
10232: LD_INT 0
10234: PPUSH
// end ;
10235: LD_VAR 0 2
10239: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10240: LD_VAR 0 2
10244: PPUSH
10245: LD_VAR 0 3
10249: PPUSH
10250: LD_INT 15
10252: PPUSH
10253: CALL_OW 309
10257: IFFALSE 10266
// YouLost ( MothContaminate ) ;
10259: LD_STRING MothContaminate
10261: PPUSH
10262: CALL_OW 104
// end ;
10266: PPOPN 3
10268: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10269: LD_VAR 0 2
10273: PPUSH
10274: LD_VAR 0 3
10278: PPUSH
10279: LD_INT 15
10281: PPUSH
10282: CALL_OW 309
10286: IFFALSE 10302
// begin wait ( 0 0$6 ) ;
10288: LD_INT 210
10290: PPUSH
10291: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10295: LD_STRING MothContaminateBomb
10297: PPUSH
10298: CALL_OW 104
// end ; end ;
10302: PPOPN 3
10304: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10305: LD_VAR 0 1
10309: PUSH
10310: LD_EXP 14
10314: EQUAL
10315: IFFALSE 10326
// begin YouLost ( JMM ) ;
10317: LD_STRING JMM
10319: PPUSH
10320: CALL_OW 104
// exit ;
10324: GO 10425
// end ; if un = Powell then
10326: LD_VAR 0 1
10330: PUSH
10331: LD_EXP 49
10335: EQUAL
10336: IFFALSE 10346
// americanDestroyed := true ;
10338: LD_ADDR_EXP 4
10342: PUSH
10343: LD_INT 1
10345: ST_TO_ADDR
// if un = Platonov then
10346: LD_VAR 0 1
10350: PUSH
10351: LD_EXP 53
10355: EQUAL
10356: IFFALSE 10366
// russianDestroyed := true ;
10358: LD_ADDR_EXP 2
10362: PUSH
10363: LD_INT 1
10365: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10366: LD_VAR 0 1
10370: PUSH
10371: LD_INT 22
10373: PUSH
10374: LD_INT 7
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: PUSH
10381: LD_INT 21
10383: PUSH
10384: LD_INT 2
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PPUSH
10395: CALL_OW 69
10399: IN
10400: IFFALSE 10416
// vehicleLostCounter := vehicleLostCounter + 1 ;
10402: LD_ADDR_EXP 12
10406: PUSH
10407: LD_EXP 12
10411: PUSH
10412: LD_INT 1
10414: PLUS
10415: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10416: LD_VAR 0 1
10420: PPUSH
10421: CALL 47447 0 1
// end ;
10425: PPOPN 1
10427: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10428: LD_VAR 0 1
10432: PPUSH
10433: LD_VAR 0 2
10437: PPUSH
10438: CALL 49781 0 2
// end ;
10442: PPOPN 2
10444: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL 48849 0 1
// end ;
10454: PPOPN 1
10456: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10457: LD_VAR 0 1
10461: PUSH
10462: LD_INT 22
10464: PUSH
10465: LD_INT 8
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PUSH
10472: LD_INT 30
10474: PUSH
10475: LD_INT 2
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PUSH
10482: LD_INT 23
10484: PUSH
10485: LD_INT 3
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: LIST
10496: PPUSH
10497: CALL_OW 69
10501: IN
10502: IFFALSE 10529
// begin ComUpgrade ( building ) ;
10504: LD_VAR 0 1
10508: PPUSH
10509: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10513: LD_EXP 52
10517: PPUSH
10518: LD_VAR 0 1
10522: PPUSH
10523: CALL 60487 0 2
// exit ;
10527: GO 10538
// end ; MCE_BuildingComplete ( building ) ;
10529: LD_VAR 0 1
10533: PPUSH
10534: CALL 49090 0 1
// end ;
10538: PPOPN 1
10540: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10541: LD_VAR 0 1
10545: PPUSH
10546: LD_VAR 0 2
10550: PPUSH
10551: CALL 47143 0 2
// end ;
10555: PPOPN 2
10557: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10558: LD_VAR 0 1
10562: PPUSH
10563: LD_VAR 0 2
10567: PPUSH
10568: LD_VAR 0 3
10572: PPUSH
10573: LD_VAR 0 4
10577: PPUSH
10578: LD_VAR 0 5
10582: PPUSH
10583: CALL 46763 0 5
// end ;
10587: PPOPN 5
10589: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10590: LD_VAR 0 1
10594: PPUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: CALL 46359 0 2
// end ;
10604: PPOPN 2
10606: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10607: LD_VAR 0 1
10611: PPUSH
10612: LD_VAR 0 2
10616: PPUSH
10617: LD_VAR 0 3
10621: PPUSH
10622: LD_VAR 0 4
10626: PPUSH
10627: CALL 46197 0 4
// end ;
10631: PPOPN 4
10633: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10634: LD_VAR 0 1
10638: PPUSH
10639: LD_VAR 0 2
10643: PPUSH
10644: LD_VAR 0 3
10648: PPUSH
10649: CALL 45972 0 3
// end ;
10653: PPOPN 3
10655: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10656: LD_VAR 0 1
10660: PPUSH
10661: LD_VAR 0 2
10665: PPUSH
10666: CALL 45857 0 2
// end ;
10670: PPOPN 2
10672: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10673: LD_VAR 0 1
10677: PPUSH
10678: LD_VAR 0 2
10682: PPUSH
10683: CALL 50042 0 2
// end ;
10687: PPOPN 2
10689: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10690: LD_VAR 0 1
10694: PPUSH
10695: LD_VAR 0 2
10699: PPUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 4
10709: PPUSH
10710: CALL 50258 0 4
// end ;
10714: PPOPN 4
10716: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10717: LD_VAR 0 1
10721: PPUSH
10722: LD_VAR 0 2
10726: PPUSH
10727: CALL 45666 0 2
// end ;
10731: PPOPN 2
10733: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10734: LD_VAR 0 1
10738: PPUSH
10739: CALL 93659 0 1
// end ; end_of_file
10743: PPOPN 1
10745: END
// export function Action ; begin
10746: LD_INT 0
10748: PPUSH
// InGameOn ;
10749: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10753: LD_INT 206
10755: PPUSH
10756: LD_INT 11
10758: PPUSH
10759: CALL_OW 86
// wait ( 0 0$1 ) ;
10763: LD_INT 35
10765: PPUSH
10766: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10770: LD_EXP 14
10774: PPUSH
10775: LD_STRING DStart-JMM-JMM-1
10777: PPUSH
10778: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10782: LD_EXP 46
10786: PPUSH
10787: LD_STRING DStart-JMM-Bur-1
10789: PPUSH
10790: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10794: LD_EXP 14
10798: PPUSH
10799: LD_STRING DStart-JMM-JMM-2
10801: PPUSH
10802: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10806: LD_EXP 46
10810: PPUSH
10811: LD_STRING DStart-JMM-Bur-2
10813: PPUSH
10814: CALL_OW 88
// InGameOff ;
10818: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10822: LD_STRING MStart
10824: PPUSH
10825: CALL_OW 337
// end ;
10829: LD_VAR 0 1
10833: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10834: LD_INT 7
10836: PPUSH
10837: LD_INT 255
10839: PPUSH
10840: LD_INT 219
10842: PPUSH
10843: CALL_OW 293
10847: IFFALSE 11456
10849: GO 10851
10851: DISABLE
10852: LD_INT 0
10854: PPUSH
// begin wait ( 0 0$3 ) ;
10855: LD_INT 105
10857: PPUSH
10858: CALL_OW 67
// alienSpotted := true ;
10862: LD_ADDR_EXP 7
10866: PUSH
10867: LD_INT 1
10869: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10870: LD_ADDR_VAR 0 1
10874: PUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 7
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PUSH
10885: LD_INT 23
10887: PUSH
10888: LD_INT 3
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: LD_INT 21
10897: PUSH
10898: LD_INT 1
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: PUSH
10905: LD_INT 26
10907: PUSH
10908: LD_INT 1
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: PPUSH
10921: CALL_OW 69
10925: PUSH
10926: LD_EXP 46
10930: PUSH
10931: LD_EXP 34
10935: PUSH
10936: LD_EXP 36
10940: PUSH
10941: LD_EXP 37
10945: PUSH
10946: LD_EXP 44
10950: PUSH
10951: LD_EXP 43
10955: PUSH
10956: LD_EXP 38
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: LIST
10965: LIST
10966: LIST
10967: LIST
10968: LIST
10969: DIFF
10970: ST_TO_ADDR
// DialogueOn ;
10971: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10975: LD_INT 255
10977: PPUSH
10978: LD_INT 219
10980: PPUSH
10981: LD_INT 7
10983: PPUSH
10984: LD_INT 20
10986: NEG
10987: PPUSH
10988: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10992: LD_INT 255
10994: PPUSH
10995: LD_INT 219
10997: PPUSH
10998: CALL_OW 86
// if speaker then
11002: LD_VAR 0 1
11006: IFFALSE 11024
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11008: LD_VAR 0 1
11012: PUSH
11013: LD_INT 1
11015: ARRAY
11016: PPUSH
11017: LD_STRING DAlienBase-RSol1-1
11019: PPUSH
11020: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11024: LD_EXP 14
11028: PPUSH
11029: LD_STRING DAlienBase-JMM-1
11031: PPUSH
11032: CALL_OW 88
// if IsOk ( Burlak ) then
11036: LD_EXP 46
11040: PPUSH
11041: CALL_OW 302
11045: IFFALSE 11066
// begin dwait ( 0 0$1 ) ;
11047: LD_INT 35
11049: PPUSH
11050: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11054: LD_EXP 46
11058: PPUSH
11059: LD_STRING DAlienBase-Bur-1
11061: PPUSH
11062: CALL_OW 88
// end ; if IsOk ( Roth ) then
11066: LD_EXP 15
11070: PPUSH
11071: CALL_OW 302
11075: IFFALSE 11089
// Say ( Roth , DAlienBase-Roth-1 ) ;
11077: LD_EXP 15
11081: PPUSH
11082: LD_STRING DAlienBase-Roth-1
11084: PPUSH
11085: CALL_OW 88
// if IsOk ( Gossudarov ) then
11089: LD_EXP 32
11093: PPUSH
11094: CALL_OW 302
11098: IFFALSE 11114
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11100: LD_EXP 32
11104: PPUSH
11105: LD_STRING DAlienBase-Gos-1
11107: PPUSH
11108: CALL_OW 88
11112: GO 11231
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11114: LD_ADDR_VAR 0 1
11118: PUSH
11119: LD_INT 22
11121: PUSH
11122: LD_INT 7
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 25
11131: PUSH
11132: LD_INT 4
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: PUSH
11139: LD_INT 21
11141: PUSH
11142: LD_INT 1
11144: PUSH
11145: EMPTY
11146: LIST
11147: LIST
11148: PUSH
11149: LD_INT 26
11151: PUSH
11152: LD_INT 1
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: EMPTY
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: PPUSH
11165: CALL_OW 69
11169: PUSH
11170: LD_EXP 15
11174: PUSH
11175: LD_EXP 14
11179: PUSH
11180: LD_EXP 46
11184: PUSH
11185: LD_EXP 34
11189: PUSH
11190: LD_EXP 44
11194: PUSH
11195: LD_EXP 43
11199: PUSH
11200: EMPTY
11201: LIST
11202: LIST
11203: LIST
11204: LIST
11205: LIST
11206: LIST
11207: DIFF
11208: ST_TO_ADDR
// if speaker then
11209: LD_VAR 0 1
11213: IFFALSE 11231
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11215: LD_VAR 0 1
11219: PUSH
11220: LD_INT 1
11222: ARRAY
11223: PPUSH
11224: LD_STRING DAlienBase-Sci1-1
11226: PPUSH
11227: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11231: LD_INT 255
11233: PPUSH
11234: LD_INT 219
11236: PPUSH
11237: LD_INT 7
11239: PPUSH
11240: CALL_OW 331
// DialogueOff ;
11244: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11248: LD_INT 35
11250: PPUSH
11251: CALL_OW 67
// until IsSelected ( alien ) ;
11255: LD_INT 1
11257: PPUSH
11258: CALL_OW 306
11262: IFFALSE 11248
// if not artifactIResearched or not artifactIIResearched then
11264: LD_EXP 9
11268: NOT
11269: PUSH
11270: LD_EXP 10
11274: NOT
11275: OR
11276: IFFALSE 11456
// begin if IsOk ( Roth ) then
11278: LD_EXP 15
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11289: LD_EXP 15
11293: PPUSH
11294: LD_STRING DAlieBaseNotReady-Roth-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11456
// if IsOk ( Gossudarov ) then
11303: LD_EXP 32
11307: PPUSH
11308: CALL_OW 302
11312: IFFALSE 11328
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11314: LD_EXP 32
11318: PPUSH
11319: LD_STRING DAlieBaseNotReady-Gos-1
11321: PPUSH
11322: CALL_OW 88
11326: GO 11456
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11328: LD_ADDR_VAR 0 1
11332: PUSH
11333: LD_INT 22
11335: PUSH
11336: LD_INT 7
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: PUSH
11343: LD_INT 23
11345: PUSH
11346: LD_INT 3
11348: PUSH
11349: EMPTY
11350: LIST
11351: LIST
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 4
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 21
11365: PUSH
11366: LD_INT 1
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 26
11375: PUSH
11376: LD_INT 1
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: PPUSH
11390: CALL_OW 69
11394: PUSH
11395: LD_EXP 15
11399: PUSH
11400: LD_EXP 14
11404: PUSH
11405: LD_EXP 46
11409: PUSH
11410: LD_EXP 34
11414: PUSH
11415: LD_EXP 44
11419: PUSH
11420: LD_EXP 43
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: DIFF
11433: ST_TO_ADDR
// if speaker then
11434: LD_VAR 0 1
11438: IFFALSE 11456
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11440: LD_VAR 0 1
11444: PUSH
11445: LD_INT 1
11447: ARRAY
11448: PPUSH
11449: LD_STRING DAlieBaseNotReady-RSci1-1
11451: PPUSH
11452: CALL_OW 88
// end ; end ; end ;
11456: PPOPN 1
11458: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11459: LD_INT 24
11461: PPUSH
11462: LD_INT 7
11464: PPUSH
11465: CALL_OW 321
11469: PUSH
11470: LD_INT 2
11472: EQUAL
11473: IFFALSE 12164
11475: GO 11477
11477: DISABLE
11478: LD_INT 0
11480: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11481: LD_ADDR_VAR 0 1
11485: PUSH
11486: LD_INT 22
11488: PUSH
11489: LD_INT 7
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 23
11498: PUSH
11499: LD_INT 3
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: PUSH
11506: LD_INT 25
11508: PUSH
11509: LD_INT 4
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: PUSH
11516: LD_INT 21
11518: PUSH
11519: LD_INT 1
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: PUSH
11526: LD_INT 26
11528: PUSH
11529: LD_INT 1
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: PUSH
11536: EMPTY
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: PPUSH
11543: CALL_OW 69
11547: PUSH
11548: LD_EXP 15
11552: PUSH
11553: LD_EXP 14
11557: PUSH
11558: LD_EXP 46
11562: PUSH
11563: LD_EXP 34
11567: PUSH
11568: LD_EXP 44
11572: PUSH
11573: LD_EXP 43
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: LIST
11582: LIST
11583: LIST
11584: LIST
11585: DIFF
11586: ST_TO_ADDR
// if not speaker then
11587: LD_VAR 0 1
11591: NOT
11592: IFFALSE 11596
// exit ;
11594: GO 12164
// DialogueOn ;
11596: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11600: LD_VAR 0 1
11604: PUSH
11605: LD_INT 1
11607: ARRAY
11608: PPUSH
11609: LD_STRING DArtefTechnology-RSci1-1
11611: PPUSH
11612: CALL_OW 88
// if IsOk ( Burlak ) then
11616: LD_EXP 46
11620: PPUSH
11621: CALL_OW 302
11625: IFFALSE 11639
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11627: LD_EXP 46
11631: PPUSH
11632: LD_STRING DArtefTechnology-Bur-1
11634: PPUSH
11635: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11639: LD_VAR 0 1
11643: PUSH
11644: LD_INT 1
11646: ARRAY
11647: PPUSH
11648: LD_STRING DArtefTechnology-RSci1-2
11650: PPUSH
11651: CALL_OW 88
// if Denis then
11655: LD_EXP 20
11659: IFFALSE 11676
// speaker := [ Denis ] else
11661: LD_ADDR_VAR 0 1
11665: PUSH
11666: LD_EXP 20
11670: PUSH
11671: EMPTY
11672: LIST
11673: ST_TO_ADDR
11674: GO 11782
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11676: LD_ADDR_VAR 0 1
11680: PUSH
11681: LD_INT 22
11683: PUSH
11684: LD_INT 7
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 23
11693: PUSH
11694: LD_INT 1
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PUSH
11701: LD_INT 25
11703: PUSH
11704: LD_INT 4
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: PUSH
11711: LD_INT 21
11713: PUSH
11714: LD_INT 1
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: PUSH
11721: LD_INT 26
11723: PUSH
11724: LD_INT 1
11726: PUSH
11727: EMPTY
11728: LIST
11729: LIST
11730: PUSH
11731: EMPTY
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: PPUSH
11738: CALL_OW 69
11742: PUSH
11743: LD_EXP 15
11747: PUSH
11748: LD_EXP 14
11752: PUSH
11753: LD_EXP 46
11757: PUSH
11758: LD_EXP 34
11762: PUSH
11763: LD_EXP 44
11767: PUSH
11768: LD_EXP 43
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: DIFF
11781: ST_TO_ADDR
// if speaker then
11782: LD_VAR 0 1
11786: IFFALSE 11804
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11788: LD_VAR 0 1
11792: PUSH
11793: LD_INT 1
11795: ARRAY
11796: PPUSH
11797: LD_STRING DArtefTechnology-Sci1-2
11799: PPUSH
11800: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11804: LD_ADDR_VAR 0 1
11808: PUSH
11809: LD_INT 22
11811: PUSH
11812: LD_INT 7
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 23
11821: PUSH
11822: LD_INT 3
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 4
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 21
11841: PUSH
11842: LD_INT 1
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: LD_INT 26
11851: PUSH
11852: LD_INT 1
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: PUSH
11871: LD_EXP 15
11875: PUSH
11876: LD_EXP 14
11880: PUSH
11881: LD_EXP 46
11885: PUSH
11886: LD_EXP 34
11890: PUSH
11891: LD_EXP 44
11895: PUSH
11896: LD_EXP 43
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: LIST
11905: LIST
11906: LIST
11907: LIST
11908: DIFF
11909: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11910: LD_VAR 0 1
11914: PUSH
11915: LD_EXP 6
11919: PUSH
11920: LD_EXP 5
11924: OR
11925: AND
11926: IFFALSE 12160
// begin if arabianDestroyed and IsOk ( Burlak ) then
11928: LD_EXP 5
11932: PUSH
11933: LD_EXP 46
11937: PPUSH
11938: CALL_OW 302
11942: AND
11943: IFFALSE 11959
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11945: LD_EXP 46
11949: PPUSH
11950: LD_STRING DArtefTechnology-Bur-2
11952: PPUSH
11953: CALL_OW 88
11957: GO 11971
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11959: LD_EXP 14
11963: PPUSH
11964: LD_STRING DArtefTechnology-JMM-2
11966: PPUSH
11967: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11971: LD_VAR 0 1
11975: PUSH
11976: LD_INT 1
11978: ARRAY
11979: PPUSH
11980: LD_STRING DArtefTechnology-RSci1-3
11982: PPUSH
11983: CALL_OW 88
// if Denis then
11987: LD_EXP 20
11991: IFFALSE 12008
// speaker := [ Denis ] else
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_EXP 20
12002: PUSH
12003: EMPTY
12004: LIST
12005: ST_TO_ADDR
12006: GO 12114
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12008: LD_ADDR_VAR 0 1
12012: PUSH
12013: LD_INT 22
12015: PUSH
12016: LD_INT 7
12018: PUSH
12019: EMPTY
12020: LIST
12021: LIST
12022: PUSH
12023: LD_INT 23
12025: PUSH
12026: LD_INT 1
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: LD_INT 25
12035: PUSH
12036: LD_INT 4
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: LD_INT 21
12045: PUSH
12046: LD_INT 1
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PUSH
12053: LD_INT 26
12055: PUSH
12056: LD_INT 1
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL_OW 69
12074: PUSH
12075: LD_EXP 15
12079: PUSH
12080: LD_EXP 14
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: LD_EXP 34
12094: PUSH
12095: LD_EXP 44
12099: PUSH
12100: LD_EXP 43
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: DIFF
12113: ST_TO_ADDR
// if speaker then
12114: LD_VAR 0 1
12118: IFFALSE 12160
// if alienSpotted then
12120: LD_EXP 7
12124: IFFALSE 12144
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12126: LD_VAR 0 1
12130: PUSH
12131: LD_INT 1
12133: ARRAY
12134: PPUSH
12135: LD_STRING DArtefTechnology-Sci1-3
12137: PPUSH
12138: CALL_OW 88
12142: GO 12160
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 1
12151: ARRAY
12152: PPUSH
12153: LD_STRING DArtefTechnology-Sci1-3a
12155: PPUSH
12156: CALL_OW 88
// end ; DialogueOff ;
12160: CALL_OW 7
// end ;
12164: PPOPN 1
12166: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12167: LD_EXP 9
12171: IFFALSE 12366
12173: GO 12175
12175: DISABLE
12176: LD_INT 0
12178: PPUSH
// begin if Denis then
12179: LD_EXP 20
12183: IFFALSE 12200
// speaker := [ Denis ] else
12185: LD_ADDR_VAR 0 1
12189: PUSH
12190: LD_EXP 20
12194: PUSH
12195: EMPTY
12196: LIST
12197: ST_TO_ADDR
12198: GO 12306
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12200: LD_ADDR_VAR 0 1
12204: PUSH
12205: LD_INT 22
12207: PUSH
12208: LD_INT 7
12210: PUSH
12211: EMPTY
12212: LIST
12213: LIST
12214: PUSH
12215: LD_INT 23
12217: PUSH
12218: LD_INT 1
12220: PUSH
12221: EMPTY
12222: LIST
12223: LIST
12224: PUSH
12225: LD_INT 25
12227: PUSH
12228: LD_INT 4
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: PUSH
12235: LD_INT 21
12237: PUSH
12238: LD_INT 1
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 26
12247: PUSH
12248: LD_INT 1
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: PUSH
12255: EMPTY
12256: LIST
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: PPUSH
12262: CALL_OW 69
12266: PUSH
12267: LD_EXP 15
12271: PUSH
12272: LD_EXP 14
12276: PUSH
12277: LD_EXP 46
12281: PUSH
12282: LD_EXP 34
12286: PUSH
12287: LD_EXP 44
12291: PUSH
12292: LD_EXP 43
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: DIFF
12305: ST_TO_ADDR
// if not speaker then
12306: LD_VAR 0 1
12310: NOT
12311: IFFALSE 12315
// exit ;
12313: GO 12366
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnologyAm-Sci1-1
12326: PPUSH
12327: CALL_OW 88
// if IsOk ( Burlak ) then
12331: LD_EXP 46
12335: PPUSH
12336: CALL_OW 302
12340: IFFALSE 12354
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12342: LD_EXP 46
12346: PPUSH
12347: LD_STRING DArtefTechnologyAm-Bur-1
12349: PPUSH
12350: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12354: LD_EXP 14
12358: PPUSH
12359: LD_STRING DArtefTechnologyAm-JMM-1
12361: PPUSH
12362: CALL_OW 88
// end ;
12366: PPOPN 1
12368: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12369: LD_EXP 10
12373: IFFALSE 12584
12375: GO 12377
12377: DISABLE
12378: LD_INT 0
12380: PPUSH
// begin if Denis then
12381: LD_EXP 20
12385: IFFALSE 12402
// speaker := [ Denis ] else
12387: LD_ADDR_VAR 0 1
12391: PUSH
12392: LD_EXP 20
12396: PUSH
12397: EMPTY
12398: LIST
12399: ST_TO_ADDR
12400: GO 12508
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12402: LD_ADDR_VAR 0 1
12406: PUSH
12407: LD_INT 22
12409: PUSH
12410: LD_INT 7
12412: PUSH
12413: EMPTY
12414: LIST
12415: LIST
12416: PUSH
12417: LD_INT 23
12419: PUSH
12420: LD_INT 3
12422: PUSH
12423: EMPTY
12424: LIST
12425: LIST
12426: PUSH
12427: LD_INT 25
12429: PUSH
12430: LD_INT 4
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: PUSH
12437: LD_INT 21
12439: PUSH
12440: LD_INT 1
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PUSH
12447: LD_INT 26
12449: PUSH
12450: LD_INT 1
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: LIST
12463: PPUSH
12464: CALL_OW 69
12468: PUSH
12469: LD_EXP 15
12473: PUSH
12474: LD_EXP 14
12478: PUSH
12479: LD_EXP 46
12483: PUSH
12484: LD_EXP 34
12488: PUSH
12489: LD_EXP 44
12493: PUSH
12494: LD_EXP 43
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: DIFF
12507: ST_TO_ADDR
// if not speaker then
12508: LD_VAR 0 1
12512: NOT
12513: IFFALSE 12517
// exit ;
12515: GO 12584
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12517: LD_VAR 0 1
12521: PUSH
12522: LD_INT 1
12524: ARRAY
12525: PPUSH
12526: LD_STRING DArtefTechnologyRu-RSci1-1
12528: PPUSH
12529: CALL_OW 88
// if IsOk ( Burlak ) then
12533: LD_EXP 46
12537: PPUSH
12538: CALL_OW 302
12542: IFFALSE 12556
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12544: LD_EXP 46
12548: PPUSH
12549: LD_STRING DArtefTechnologyRu-Bur-1
12551: PPUSH
12552: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12556: LD_VAR 0 1
12560: PUSH
12561: LD_INT 1
12563: ARRAY
12564: PPUSH
12565: LD_STRING DArtefTechnologyRu-RSci1-2
12567: PPUSH
12568: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12572: LD_EXP 14
12576: PPUSH
12577: LD_STRING DArtefTechnologyRu-JMM-1
12579: PPUSH
12580: CALL_OW 88
// end ;
12584: PPOPN 1
12586: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12587: LD_INT 24
12589: PPUSH
12590: LD_INT 7
12592: PPUSH
12593: CALL_OW 321
12597: PUSH
12598: LD_INT 2
12600: EQUAL
12601: PUSH
12602: LD_INT 1
12604: PPUSH
12605: CALL_OW 255
12609: PUSH
12610: LD_INT 7
12612: EQUAL
12613: AND
12614: IFFALSE 12774
12616: GO 12618
12618: DISABLE
12619: LD_INT 0
12621: PPUSH
// begin if Denis then
12622: LD_EXP 20
12626: IFFALSE 12643
// speaker := [ Denis ] else
12628: LD_ADDR_VAR 0 1
12632: PUSH
12633: LD_EXP 20
12637: PUSH
12638: EMPTY
12639: LIST
12640: ST_TO_ADDR
12641: GO 12749
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12643: LD_ADDR_VAR 0 1
12647: PUSH
12648: LD_INT 22
12650: PUSH
12651: LD_INT 7
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PUSH
12658: LD_INT 23
12660: PUSH
12661: LD_INT 1
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: PUSH
12668: LD_INT 25
12670: PUSH
12671: LD_INT 4
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: PUSH
12678: LD_INT 21
12680: PUSH
12681: LD_INT 1
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: PUSH
12688: LD_INT 26
12690: PUSH
12691: LD_INT 1
12693: PUSH
12694: EMPTY
12695: LIST
12696: LIST
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: LIST
12702: LIST
12703: LIST
12704: PPUSH
12705: CALL_OW 69
12709: PUSH
12710: LD_EXP 15
12714: PUSH
12715: LD_EXP 14
12719: PUSH
12720: LD_EXP 46
12724: PUSH
12725: LD_EXP 34
12729: PUSH
12730: LD_EXP 44
12734: PUSH
12735: LD_EXP 43
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: LIST
12744: LIST
12745: LIST
12746: LIST
12747: DIFF
12748: ST_TO_ADDR
// if not speaker then
12749: LD_VAR 0 1
12753: NOT
12754: IFFALSE 12758
// exit ;
12756: GO 12774
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12758: LD_VAR 0 1
12762: PUSH
12763: LD_INT 1
12765: ARRAY
12766: PPUSH
12767: LD_STRING DArtefTechnologyArStart-Sci1-1
12769: PPUSH
12770: CALL_OW 88
// end ;
12774: PPOPN 1
12776: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12777: LD_EXP 11
12781: IFFALSE 13062
12783: GO 12785
12785: DISABLE
12786: LD_INT 0
12788: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12789: LD_ADDR_VAR 0 1
12793: PUSH
12794: LD_INT 22
12796: PUSH
12797: LD_INT 7
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 23
12806: PUSH
12807: LD_INT 3
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 25
12816: PUSH
12817: LD_INT 4
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: LD_INT 21
12826: PUSH
12827: LD_INT 1
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PUSH
12834: LD_INT 26
12836: PUSH
12837: LD_INT 1
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: LIST
12848: LIST
12849: LIST
12850: PPUSH
12851: CALL_OW 69
12855: PUSH
12856: LD_EXP 15
12860: PUSH
12861: LD_EXP 14
12865: PUSH
12866: LD_EXP 46
12870: PUSH
12871: LD_EXP 34
12875: PUSH
12876: LD_EXP 44
12880: PUSH
12881: LD_EXP 43
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: LIST
12893: DIFF
12894: ST_TO_ADDR
// if not speaker then
12895: LD_VAR 0 1
12899: NOT
12900: IFFALSE 12904
// exit ;
12902: GO 13062
// DialogueOn ;
12904: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12908: LD_VAR 0 1
12912: PUSH
12913: LD_INT 1
12915: ARRAY
12916: PPUSH
12917: LD_STRING DArtefTechnologyAr-RSci1-1
12919: PPUSH
12920: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12924: LD_EXP 14
12928: PPUSH
12929: LD_STRING DArtefTechnologyAr-JMM-1
12931: PPUSH
12932: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12936: LD_VAR 0 1
12940: PUSH
12941: LD_INT 1
12943: ARRAY
12944: PPUSH
12945: LD_STRING DArtefTechnologyAr-RSci1-2
12947: PPUSH
12948: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12952: LD_EXP 14
12956: PPUSH
12957: LD_STRING DArtefTechnologyAr-JMM-2
12959: PPUSH
12960: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12964: LD_VAR 0 1
12968: PUSH
12969: LD_INT 1
12971: ARRAY
12972: PPUSH
12973: LD_STRING DArtefTechnologyAr-RSci1-3
12975: PPUSH
12976: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12980: LD_EXP 14
12984: PPUSH
12985: LD_STRING DArtefTechnologyAr-JMM-3
12987: PPUSH
12988: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12992: LD_VAR 0 1
12996: PUSH
12997: LD_INT 1
12999: ARRAY
13000: PPUSH
13001: LD_STRING DArtefTechnologyAr-RSci1-4
13003: PPUSH
13004: CALL_OW 88
// if IsOk ( Burlak ) then
13008: LD_EXP 46
13012: PPUSH
13013: CALL_OW 302
13017: IFFALSE 13031
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13019: LD_EXP 46
13023: PPUSH
13024: LD_STRING DArtefTechnologyAr-Bur-4
13026: PPUSH
13027: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13031: LD_EXP 14
13035: PPUSH
13036: LD_STRING DArtefTechnologyAr-JMM-4
13038: PPUSH
13039: CALL_OW 88
// DialogueOff ;
13043: CALL_OW 7
// wait ( 0 0$45 ) ;
13047: LD_INT 1575
13049: PPUSH
13050: CALL_OW 67
// spawnOmar := true ;
13054: LD_ADDR_EXP 8
13058: PUSH
13059: LD_INT 1
13061: ST_TO_ADDR
// end ;
13062: PPOPN 1
13064: END
// every 0 0$1 trigger spawnOmar do
13065: LD_EXP 8
13069: IFFALSE 13374
13071: GO 13073
13073: DISABLE
// begin PrepareOmarAli ;
13074: CALL 6547 0 0
// if not Omar then
13078: LD_EXP 50
13082: NOT
13083: IFFALSE 13087
// exit ;
13085: GO 13374
// repeat wait ( 0 0$1 ) ;
13087: LD_INT 35
13089: PPUSH
13090: CALL_OW 67
// until See ( 7 , Omar ) ;
13094: LD_INT 7
13096: PPUSH
13097: LD_EXP 50
13101: PPUSH
13102: CALL_OW 292
13106: IFFALSE 13087
// CenterNowOnUnits ( Omar ) ;
13108: LD_EXP 50
13112: PPUSH
13113: CALL_OW 87
// DialogueOn ;
13117: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13121: LD_EXP 50
13125: PPUSH
13126: LD_STRING DOmar-Omar-1
13128: PPUSH
13129: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13133: LD_EXP 14
13137: PPUSH
13138: LD_STRING DOmar-JMM-1
13140: PPUSH
13141: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13145: LD_EXP 50
13149: PPUSH
13150: LD_STRING DOmar-Omar-2
13152: PPUSH
13153: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13157: LD_EXP 14
13161: PPUSH
13162: LD_STRING DOmar-JMM-2
13164: PPUSH
13165: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13169: LD_EXP 50
13173: PPUSH
13174: LD_STRING DOmar-Omar-3
13176: PPUSH
13177: CALL_OW 88
// if IsOk ( Burlak ) then
13181: LD_EXP 46
13185: PPUSH
13186: CALL_OW 302
13190: IFFALSE 13206
// Say ( Burlak , DOmar-Bur-3 ) else
13192: LD_EXP 46
13196: PPUSH
13197: LD_STRING DOmar-Bur-3
13199: PPUSH
13200: CALL_OW 88
13204: GO 13218
// Say ( JMM , DOmar-JMM-3 ) ;
13206: LD_EXP 14
13210: PPUSH
13211: LD_STRING DOmar-JMM-3
13213: PPUSH
13214: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13218: LD_EXP 50
13222: PPUSH
13223: LD_STRING DOmar-Omar-4
13225: PPUSH
13226: CALL_OW 88
// case Query ( QAccept ) of 1 :
13230: LD_STRING QAccept
13232: PPUSH
13233: CALL_OW 97
13237: PUSH
13238: LD_INT 1
13240: DOUBLE
13241: EQUAL
13242: IFTRUE 13246
13244: GO 13282
13246: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13247: LD_EXP 14
13251: PPUSH
13252: LD_STRING DQrAccept#1-JMM-1
13254: PPUSH
13255: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13259: LD_EXP 50
13263: PPUSH
13264: LD_INT 7
13266: PPUSH
13267: CALL_OW 235
// ComStop ( Omar ) ;
13271: LD_EXP 50
13275: PPUSH
13276: CALL_OW 141
// end ; 2 :
13280: GO 13331
13282: LD_INT 2
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13290
13288: GO 13330
13290: POP
// begin if IsOk ( Burlak ) then
13291: LD_EXP 46
13295: PPUSH
13296: CALL_OW 302
13300: IFFALSE 13316
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13302: LD_EXP 46
13306: PPUSH
13307: LD_STRING DQrAccept#2-Bur-1
13309: PPUSH
13310: CALL_OW 88
13314: GO 13328
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13316: LD_EXP 14
13320: PPUSH
13321: LD_STRING DQrAccept#2-JMM-1
13323: PPUSH
13324: CALL_OW 88
// end ; end ;
13328: GO 13331
13330: POP
// DialogueOff ;
13331: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13335: LD_EXP 50
13339: PPUSH
13340: CALL_OW 255
13344: PUSH
13345: LD_INT 7
13347: EQUAL
13348: IFFALSE 13359
// begin SetAchievement ( ACH_OMAR ) ;
13350: LD_STRING ACH_OMAR
13352: PPUSH
13353: CALL_OW 543
// exit ;
13357: GO 13374
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13359: LD_EXP 50
13363: PPUSH
13364: LD_INT 202
13366: PPUSH
13367: LD_INT 115
13369: PPUSH
13370: CALL_OW 111
// end ;
13374: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13375: LD_EXP 50
13379: PPUSH
13380: LD_INT 200
13382: PPUSH
13383: LD_INT 98
13385: PPUSH
13386: CALL_OW 297
13390: PUSH
13391: LD_INT 40
13393: LESS
13394: PUSH
13395: LD_EXP 2
13399: AND
13400: IFFALSE 13618
13402: GO 13404
13404: DISABLE
// begin SetSide ( Omar , 5 ) ;
13405: LD_EXP 50
13409: PPUSH
13410: LD_INT 5
13412: PPUSH
13413: CALL_OW 235
// if IsInUnit ( Omar ) then
13417: LD_EXP 50
13421: PPUSH
13422: CALL_OW 310
13426: IFFALSE 13437
// ComExitVehicle ( Omar ) ;
13428: LD_EXP 50
13432: PPUSH
13433: CALL_OW 121
// if IsInUnit ( Omar ) then
13437: LD_EXP 50
13441: PPUSH
13442: CALL_OW 310
13446: IFFALSE 13457
// ComExitBuilding ( Omar ) ;
13448: LD_EXP 50
13452: PPUSH
13453: CALL_OW 122
// wait ( 0 0$1 ) ;
13457: LD_INT 35
13459: PPUSH
13460: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13464: LD_EXP 50
13468: PPUSH
13469: LD_INT 203
13471: PPUSH
13472: LD_INT 120
13474: PPUSH
13475: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13479: LD_INT 35
13481: PPUSH
13482: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13486: LD_EXP 50
13490: PPUSH
13491: CALL_OW 306
13495: PUSH
13496: LD_EXP 50
13500: PPUSH
13501: LD_INT 203
13503: PPUSH
13504: LD_INT 120
13506: PPUSH
13507: CALL_OW 297
13511: PUSH
13512: LD_INT 6
13514: LESS
13515: OR
13516: IFFALSE 13479
// CenterNowOnUnits ( Omar ) ;
13518: LD_EXP 50
13522: PPUSH
13523: CALL_OW 87
// DialogueOn ;
13527: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13531: LD_EXP 14
13535: PPUSH
13536: LD_STRING DOmarContam-JMM-1
13538: PPUSH
13539: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13543: LD_EXP 50
13547: PPUSH
13548: LD_STRING DOmarContam-Omar-1
13550: PPUSH
13551: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13555: LD_EXP 14
13559: PPUSH
13560: LD_STRING DOmarContam-JMM-2
13562: PPUSH
13563: CALL_OW 88
// DialogueOff ;
13567: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13571: LD_INT 5
13573: PPUSH
13574: LD_INT 7
13576: PPUSH
13577: LD_INT 2
13579: PPUSH
13580: LD_INT 1
13582: PPUSH
13583: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13587: LD_INT 105
13589: PPUSH
13590: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13594: LD_EXP 50
13598: PPUSH
13599: LD_INT 203
13601: PPUSH
13602: LD_INT 120
13604: PPUSH
13605: CALL_OW 307
13609: IFFALSE 13587
// YouLost ( MothContaminate ) ;
13611: LD_STRING MothContaminate
13613: PPUSH
13614: CALL_OW 104
// end ;
13618: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13619: LD_EXP 4
13623: NOT
13624: PUSH
13625: LD_INT 22
13627: PUSH
13628: LD_INT 1
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PUSH
13635: LD_INT 34
13637: PUSH
13638: LD_INT 8
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 69
13653: AND
13654: IFFALSE 13735
13656: GO 13658
13658: DISABLE
// begin if not IsOk ( Powell ) then
13659: LD_EXP 49
13663: PPUSH
13664: CALL_OW 302
13668: NOT
13669: IFFALSE 13673
// exit ;
13671: GO 13735
// DialogueOn ;
13673: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13677: LD_EXP 49
13681: PPUSH
13682: LD_STRING DWinAmericans-Pow-1
13684: PPUSH
13685: CALL_OW 94
// if IsOk ( Burlak ) then
13689: LD_EXP 46
13693: PPUSH
13694: CALL_OW 302
13698: IFFALSE 13712
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13700: LD_EXP 46
13704: PPUSH
13705: LD_STRING DWinAmericans-Bur-1
13707: PPUSH
13708: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13712: LD_EXP 14
13716: PPUSH
13717: LD_STRING DWinAmericans-JMM-1
13719: PPUSH
13720: CALL_OW 88
// DialogueOff ;
13724: CALL_OW 7
// YouLost ( AmBomb ) ;
13728: LD_STRING AmBomb
13730: PPUSH
13731: CALL_OW 104
// end ;
13735: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13736: LD_EXP 2
13740: NOT
13741: PUSH
13742: LD_INT 22
13744: PUSH
13745: LD_INT 3
13747: PUSH
13748: EMPTY
13749: LIST
13750: LIST
13751: PUSH
13752: LD_INT 34
13754: PUSH
13755: LD_INT 48
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: PUSH
13762: EMPTY
13763: LIST
13764: LIST
13765: PPUSH
13766: CALL_OW 69
13770: AND
13771: IFFALSE 13852
13773: GO 13775
13775: DISABLE
// begin if not IsOk ( Platonov ) then
13776: LD_EXP 53
13780: PPUSH
13781: CALL_OW 302
13785: NOT
13786: IFFALSE 13790
// exit ;
13788: GO 13852
// DialogueOn ;
13790: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13794: LD_EXP 53
13798: PPUSH
13799: LD_STRING DWinRussians-Pla-1
13801: PPUSH
13802: CALL_OW 94
// if IsOk ( Burlak ) then
13806: LD_EXP 46
13810: PPUSH
13811: CALL_OW 302
13815: IFFALSE 13829
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13817: LD_EXP 46
13821: PPUSH
13822: LD_STRING DWinRussians-Bur-1
13824: PPUSH
13825: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13829: LD_EXP 14
13833: PPUSH
13834: LD_STRING DWinRussians-JMM-1
13836: PPUSH
13837: CALL_OW 88
// DialogueOff ;
13841: CALL_OW 7
// YouLost ( RuBomb ) ;
13845: LD_STRING RuBomb
13847: PPUSH
13848: CALL_OW 104
// end ;
13852: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13853: LD_INT 7
13855: PPUSH
13856: LD_INT 22
13858: PUSH
13859: LD_INT 7
13861: PUSH
13862: EMPTY
13863: LIST
13864: LIST
13865: PPUSH
13866: CALL_OW 70
13870: PUSH
13871: LD_EXP 4
13875: NOT
13876: AND
13877: IFFALSE 13906
13879: GO 13881
13881: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13882: LD_EXP 49
13886: PPUSH
13887: LD_STRING DSurrenderAmericans-Pow-1
13889: PPUSH
13890: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13894: LD_EXP 14
13898: PPUSH
13899: LD_STRING DSurrenderAmericans-JMM-1
13901: PPUSH
13902: CALL_OW 88
// end ;
13906: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13907: LD_INT 2
13909: PPUSH
13910: LD_INT 22
13912: PUSH
13913: LD_INT 7
13915: PUSH
13916: EMPTY
13917: LIST
13918: LIST
13919: PPUSH
13920: CALL_OW 70
13924: PUSH
13925: LD_EXP 2
13929: NOT
13930: AND
13931: PUSH
13932: LD_EXP 46
13936: AND
13937: IFFALSE 13966
13939: GO 13941
13941: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13942: LD_EXP 53
13946: PPUSH
13947: LD_STRING DSurrenderRussians-Pla-1
13949: PPUSH
13950: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13954: LD_EXP 46
13958: PPUSH
13959: LD_STRING DSurrenderRussians-Bur-1
13961: PPUSH
13962: CALL_OW 88
// end ;
13966: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13967: LD_EXP 4
13971: IFFALSE 14346
13973: GO 13975
13975: DISABLE
13976: LD_INT 0
13978: PPUSH
13979: PPUSH
13980: PPUSH
// begin MC_Kill ( 4 ) ;
13981: LD_INT 4
13983: PPUSH
13984: CALL 20491 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
13988: LD_INT 1
13990: PPUSH
13991: LD_INT 7
13993: PPUSH
13994: LD_INT 1
13996: PPUSH
13997: LD_INT 1
13999: PPUSH
14000: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14004: LD_ADDR_VAR 0 3
14008: PUSH
14009: LD_INT 22
14011: PUSH
14012: LD_INT 1
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: PUSH
14019: LD_INT 26
14021: PUSH
14022: LD_INT 1
14024: PUSH
14025: EMPTY
14026: LIST
14027: LIST
14028: PUSH
14029: LD_INT 23
14031: PUSH
14032: LD_INT 1
14034: PUSH
14035: EMPTY
14036: LIST
14037: LIST
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: LIST
14043: PPUSH
14044: CALL_OW 69
14048: PUSH
14049: LD_EXP 49
14053: PUSH
14054: LD_EXP 22
14058: PUSH
14059: LD_EXP 19
14063: PUSH
14064: LD_EXP 18
14068: PUSH
14069: LD_EXP 25
14073: PUSH
14074: LD_EXP 23
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: LIST
14086: DIFF
14087: ST_TO_ADDR
// if speaker then
14088: LD_VAR 0 3
14092: IFFALSE 14118
// begin DialogueOn ;
14094: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14098: LD_VAR 0 3
14102: PUSH
14103: LD_INT 1
14105: ARRAY
14106: PPUSH
14107: LD_STRING DSurrenderAmericans-Sol1-1a
14109: PPUSH
14110: CALL_OW 94
// DialogueOff ;
14114: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14118: LD_ADDR_VAR 0 2
14122: PUSH
14123: LD_INT 22
14125: PUSH
14126: LD_INT 1
14128: PUSH
14129: EMPTY
14130: LIST
14131: LIST
14132: PUSH
14133: LD_INT 21
14135: PUSH
14136: LD_INT 1
14138: PUSH
14139: EMPTY
14140: LIST
14141: LIST
14142: PUSH
14143: EMPTY
14144: LIST
14145: LIST
14146: PPUSH
14147: CALL_OW 69
14151: PUSH
14152: LD_INT 22
14154: PUSH
14155: LD_INT 1
14157: PUSH
14158: EMPTY
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 21
14164: PUSH
14165: LD_INT 2
14167: PUSH
14168: EMPTY
14169: LIST
14170: LIST
14171: PUSH
14172: LD_INT 1
14174: PUSH
14175: EMPTY
14176: LIST
14177: PUSH
14178: EMPTY
14179: LIST
14180: LIST
14181: LIST
14182: PPUSH
14183: CALL_OW 69
14187: ADD
14188: ST_TO_ADDR
// if tmp then
14189: LD_VAR 0 2
14193: IFFALSE 14346
// repeat wait ( 0 0$1 ) ;
14195: LD_INT 35
14197: PPUSH
14198: CALL_OW 67
// for i in tmp do
14202: LD_ADDR_VAR 0 1
14206: PUSH
14207: LD_VAR 0 2
14211: PUSH
14212: FOR_IN
14213: IFFALSE 14295
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14215: LD_VAR 0 1
14219: PPUSH
14220: CALL_OW 310
14224: PUSH
14225: LD_VAR 0 1
14229: PPUSH
14230: CALL_OW 310
14234: PPUSH
14235: CALL_OW 247
14239: PUSH
14240: LD_INT 3
14242: EQUAL
14243: AND
14244: IFFALSE 14255
// ComExitBuilding ( i ) ;
14246: LD_VAR 0 1
14250: PPUSH
14251: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14255: LD_VAR 0 1
14259: PPUSH
14260: LD_INT 122
14262: PPUSH
14263: LD_INT 242
14265: PPUSH
14266: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14270: LD_VAR 0 1
14274: PPUSH
14275: LD_INT 35
14277: PPUSH
14278: CALL_OW 308
14282: IFFALSE 14293
// RemoveUnit ( i ) ;
14284: LD_VAR 0 1
14288: PPUSH
14289: CALL_OW 64
// end ;
14293: GO 14212
14295: POP
14296: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14297: LD_INT 22
14299: PUSH
14300: LD_INT 1
14302: PUSH
14303: EMPTY
14304: LIST
14305: LIST
14306: PUSH
14307: LD_INT 2
14309: PUSH
14310: LD_INT 21
14312: PUSH
14313: LD_INT 1
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: PUSH
14320: LD_INT 33
14322: PUSH
14323: LD_INT 1
14325: PUSH
14326: EMPTY
14327: LIST
14328: LIST
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: LIST
14334: PUSH
14335: EMPTY
14336: LIST
14337: LIST
14338: PPUSH
14339: CALL_OW 69
14343: NOT
14344: IFFALSE 14195
// end ;
14346: PPOPN 3
14348: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14349: LD_EXP 2
14353: IFFALSE 14746
14355: GO 14357
14357: DISABLE
14358: LD_INT 0
14360: PPUSH
14361: PPUSH
14362: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14363: LD_INT 35
14365: PPUSH
14366: CALL_OW 67
// until IsDead ( Yakotich ) ;
14370: LD_EXP 54
14374: PPUSH
14375: CALL_OW 301
14379: IFFALSE 14363
// MC_Kill ( 2 ) ;
14381: LD_INT 2
14383: PPUSH
14384: CALL 20491 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14388: LD_INT 3
14390: PPUSH
14391: LD_INT 7
14393: PPUSH
14394: LD_INT 1
14396: PPUSH
14397: LD_INT 1
14399: PPUSH
14400: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14404: LD_ADDR_VAR 0 3
14408: PUSH
14409: LD_INT 22
14411: PUSH
14412: LD_INT 3
14414: PUSH
14415: EMPTY
14416: LIST
14417: LIST
14418: PUSH
14419: LD_INT 26
14421: PUSH
14422: LD_INT 1
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PUSH
14429: LD_INT 23
14431: PUSH
14432: LD_INT 3
14434: PUSH
14435: EMPTY
14436: LIST
14437: LIST
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: LIST
14443: PPUSH
14444: CALL_OW 69
14448: PUSH
14449: LD_EXP 53
14453: PUSH
14454: LD_EXP 54
14458: PUSH
14459: EMPTY
14460: LIST
14461: LIST
14462: DIFF
14463: ST_TO_ADDR
// if speaker then
14464: LD_VAR 0 3
14468: IFFALSE 14518
// begin DialogueOn ;
14470: CALL_OW 6
// if Burlak then
14474: LD_EXP 46
14478: IFFALSE 14498
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14480: LD_VAR 0 3
14484: PUSH
14485: LD_INT 1
14487: ARRAY
14488: PPUSH
14489: LD_STRING DSurrenderRussians-RSol1-1
14491: PPUSH
14492: CALL_OW 94
14496: GO 14514
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14498: LD_VAR 0 3
14502: PUSH
14503: LD_INT 1
14505: ARRAY
14506: PPUSH
14507: LD_STRING DSurrenderRussians-RSol1-1a
14509: PPUSH
14510: CALL_OW 94
// DialogueOff ;
14514: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14518: LD_ADDR_VAR 0 2
14522: PUSH
14523: LD_INT 22
14525: PUSH
14526: LD_INT 3
14528: PUSH
14529: EMPTY
14530: LIST
14531: LIST
14532: PUSH
14533: LD_INT 21
14535: PUSH
14536: LD_INT 1
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PPUSH
14547: CALL_OW 69
14551: PUSH
14552: LD_INT 22
14554: PUSH
14555: LD_INT 3
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 21
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: LD_INT 1
14574: PUSH
14575: EMPTY
14576: LIST
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: LIST
14582: PPUSH
14583: CALL_OW 69
14587: ADD
14588: ST_TO_ADDR
// if tmp then
14589: LD_VAR 0 2
14593: IFFALSE 14746
// repeat wait ( 0 0$1 ) ;
14595: LD_INT 35
14597: PPUSH
14598: CALL_OW 67
// for i in tmp do
14602: LD_ADDR_VAR 0 1
14606: PUSH
14607: LD_VAR 0 2
14611: PUSH
14612: FOR_IN
14613: IFFALSE 14695
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14615: LD_VAR 0 1
14619: PPUSH
14620: CALL_OW 310
14624: PUSH
14625: LD_VAR 0 1
14629: PPUSH
14630: CALL_OW 310
14634: PPUSH
14635: CALL_OW 247
14639: PUSH
14640: LD_INT 3
14642: EQUAL
14643: AND
14644: IFFALSE 14655
// ComExitBuilding ( i ) ;
14646: LD_VAR 0 1
14650: PPUSH
14651: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14655: LD_VAR 0 1
14659: PPUSH
14660: LD_INT 154
14662: PPUSH
14663: LD_INT 1
14665: PPUSH
14666: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14670: LD_VAR 0 1
14674: PPUSH
14675: LD_INT 36
14677: PPUSH
14678: CALL_OW 308
14682: IFFALSE 14693
// RemoveUnit ( i ) ;
14684: LD_VAR 0 1
14688: PPUSH
14689: CALL_OW 64
// end ;
14693: GO 14612
14695: POP
14696: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14697: LD_INT 22
14699: PUSH
14700: LD_INT 3
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: PUSH
14707: LD_INT 2
14709: PUSH
14710: LD_INT 21
14712: PUSH
14713: LD_INT 1
14715: PUSH
14716: EMPTY
14717: LIST
14718: LIST
14719: PUSH
14720: LD_INT 33
14722: PUSH
14723: LD_INT 1
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: LIST
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: PPUSH
14739: CALL_OW 69
14743: NOT
14744: IFFALSE 14595
// end ;
14746: PPOPN 3
14748: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14749: LD_INT 22
14751: PUSH
14752: LD_INT 8
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 21
14761: PUSH
14762: LD_INT 1
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: PUSH
14769: LD_INT 23
14771: PUSH
14772: LD_INT 2
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PUSH
14779: EMPTY
14780: LIST
14781: LIST
14782: LIST
14783: PPUSH
14784: CALL_OW 69
14788: PUSH
14789: LD_INT 18
14791: LESS
14792: PUSH
14793: LD_EXP 52
14797: PPUSH
14798: CALL_OW 301
14802: OR
14803: PUSH
14804: LD_INT 324
14806: PPUSH
14807: CALL_OW 255
14811: PUSH
14812: LD_INT 7
14814: EQUAL
14815: OR
14816: IFFALSE 14829
14818: GO 14820
14820: DISABLE
// legionDestroyed := true ;
14821: LD_ADDR_EXP 3
14825: PUSH
14826: LD_INT 1
14828: ST_TO_ADDR
14829: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14830: LD_INT 22
14832: PUSH
14833: LD_INT 2
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: PUSH
14840: LD_INT 21
14842: PUSH
14843: LD_INT 1
14845: PUSH
14846: EMPTY
14847: LIST
14848: LIST
14849: PUSH
14850: LD_INT 23
14852: PUSH
14853: LD_INT 2
14855: PUSH
14856: EMPTY
14857: LIST
14858: LIST
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: LIST
14864: PPUSH
14865: CALL_OW 69
14869: PUSH
14870: LD_INT 9
14872: LESS
14873: IFFALSE 14886
14875: GO 14877
14877: DISABLE
// arabianDestroyed := true ;
14878: LD_ADDR_EXP 5
14882: PUSH
14883: LD_INT 1
14885: ST_TO_ADDR
14886: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14887: LD_EXP 5
14891: IFFALSE 15151
14893: GO 14895
14895: DISABLE
14896: LD_INT 0
14898: PPUSH
14899: PPUSH
// begin MC_Kill ( 1 ) ;
14900: LD_INT 1
14902: PPUSH
14903: CALL 20491 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14907: LD_INT 2
14909: PPUSH
14910: LD_INT 7
14912: PPUSH
14913: LD_INT 1
14915: PPUSH
14916: LD_INT 1
14918: PPUSH
14919: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14923: LD_ADDR_VAR 0 2
14927: PUSH
14928: LD_INT 22
14930: PUSH
14931: LD_INT 2
14933: PUSH
14934: EMPTY
14935: LIST
14936: LIST
14937: PUSH
14938: LD_INT 21
14940: PUSH
14941: LD_INT 1
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PUSH
14948: EMPTY
14949: LIST
14950: LIST
14951: PPUSH
14952: CALL_OW 69
14956: PUSH
14957: LD_INT 22
14959: PUSH
14960: LD_INT 8
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 21
14969: PUSH
14970: LD_INT 2
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: PUSH
14977: LD_INT 1
14979: PUSH
14980: EMPTY
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: LIST
14987: PPUSH
14988: CALL_OW 69
14992: ADD
14993: ST_TO_ADDR
// if tmp then
14994: LD_VAR 0 2
14998: IFFALSE 15151
// repeat wait ( 0 0$1 ) ;
15000: LD_INT 35
15002: PPUSH
15003: CALL_OW 67
// for i in tmp do
15007: LD_ADDR_VAR 0 1
15011: PUSH
15012: LD_VAR 0 2
15016: PUSH
15017: FOR_IN
15018: IFFALSE 15100
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15020: LD_VAR 0 1
15024: PPUSH
15025: CALL_OW 310
15029: PUSH
15030: LD_VAR 0 1
15034: PPUSH
15035: CALL_OW 310
15039: PPUSH
15040: CALL_OW 247
15044: PUSH
15045: LD_INT 3
15047: EQUAL
15048: AND
15049: IFFALSE 15060
// ComExitBuilding ( i ) ;
15051: LD_VAR 0 1
15055: PPUSH
15056: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15060: LD_VAR 0 1
15064: PPUSH
15065: LD_INT 254
15067: PPUSH
15068: LD_INT 268
15070: PPUSH
15071: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15075: LD_VAR 0 1
15079: PPUSH
15080: LD_INT 34
15082: PPUSH
15083: CALL_OW 308
15087: IFFALSE 15098
// RemoveUnit ( i ) ;
15089: LD_VAR 0 1
15093: PPUSH
15094: CALL_OW 64
// end ;
15098: GO 15017
15100: POP
15101: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15102: LD_INT 22
15104: PUSH
15105: LD_INT 2
15107: PUSH
15108: EMPTY
15109: LIST
15110: LIST
15111: PUSH
15112: LD_INT 2
15114: PUSH
15115: LD_INT 21
15117: PUSH
15118: LD_INT 1
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: PUSH
15125: LD_INT 33
15127: PUSH
15128: LD_INT 1
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: LIST
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PPUSH
15144: CALL_OW 69
15148: NOT
15149: IFFALSE 15000
// end ;
15151: PPOPN 2
15153: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15154: LD_EXP 3
15158: IFFALSE 15502
15160: GO 15162
15162: DISABLE
15163: LD_INT 0
15165: PPUSH
15166: PPUSH
// begin MC_Kill ( 3 ) ;
15167: LD_INT 3
15169: PPUSH
15170: CALL 20491 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15174: LD_INT 8
15176: PPUSH
15177: LD_INT 7
15179: PPUSH
15180: LD_INT 1
15182: PPUSH
15183: LD_INT 1
15185: PPUSH
15186: CALL_OW 80
// DialogueOn ;
15190: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15194: LD_EXP 51
15198: PPUSH
15199: LD_STRING D15-Szulc-1
15201: PPUSH
15202: CALL_OW 94
// DialogueOff ;
15206: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15210: LD_ADDR_VAR 0 1
15214: PUSH
15215: LD_INT 22
15217: PUSH
15218: LD_INT 8
15220: PUSH
15221: EMPTY
15222: LIST
15223: LIST
15224: PUSH
15225: LD_INT 21
15227: PUSH
15228: LD_INT 3
15230: PUSH
15231: EMPTY
15232: LIST
15233: LIST
15234: PUSH
15235: LD_INT 23
15237: PUSH
15238: LD_INT 3
15240: PUSH
15241: EMPTY
15242: LIST
15243: LIST
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: LIST
15249: PPUSH
15250: CALL_OW 69
15254: PUSH
15255: FOR_IN
15256: IFFALSE 15272
// SetLives ( i , 3 ) ;
15258: LD_VAR 0 1
15262: PPUSH
15263: LD_INT 3
15265: PPUSH
15266: CALL_OW 234
15270: GO 15255
15272: POP
15273: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15274: LD_ADDR_VAR 0 2
15278: PUSH
15279: LD_INT 22
15281: PUSH
15282: LD_INT 8
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: PUSH
15289: LD_INT 21
15291: PUSH
15292: LD_INT 1
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: PUSH
15299: EMPTY
15300: LIST
15301: LIST
15302: PPUSH
15303: CALL_OW 69
15307: PUSH
15308: LD_INT 22
15310: PUSH
15311: LD_INT 8
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PUSH
15318: LD_INT 21
15320: PUSH
15321: LD_INT 2
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PUSH
15328: LD_INT 1
15330: PUSH
15331: EMPTY
15332: LIST
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: LIST
15338: PPUSH
15339: CALL_OW 69
15343: ADD
15344: ST_TO_ADDR
// if tmp then
15345: LD_VAR 0 2
15349: IFFALSE 15502
// repeat wait ( 0 0$1 ) ;
15351: LD_INT 35
15353: PPUSH
15354: CALL_OW 67
// for i in tmp do
15358: LD_ADDR_VAR 0 1
15362: PUSH
15363: LD_VAR 0 2
15367: PUSH
15368: FOR_IN
15369: IFFALSE 15451
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15371: LD_VAR 0 1
15375: PPUSH
15376: CALL_OW 310
15380: PUSH
15381: LD_VAR 0 1
15385: PPUSH
15386: CALL_OW 310
15390: PPUSH
15391: CALL_OW 247
15395: PUSH
15396: LD_INT 3
15398: EQUAL
15399: AND
15400: IFFALSE 15411
// ComExitBuilding ( i ) ;
15402: LD_VAR 0 1
15406: PPUSH
15407: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15411: LD_VAR 0 1
15415: PPUSH
15416: LD_INT 10
15418: PPUSH
15419: LD_INT 1
15421: PPUSH
15422: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15426: LD_VAR 0 1
15430: PPUSH
15431: LD_INT 32
15433: PPUSH
15434: CALL_OW 308
15438: IFFALSE 15449
// RemoveUnit ( i ) ;
15440: LD_VAR 0 1
15444: PPUSH
15445: CALL_OW 64
// end ;
15449: GO 15368
15451: POP
15452: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15453: LD_INT 22
15455: PUSH
15456: LD_INT 8
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PUSH
15463: LD_INT 2
15465: PUSH
15466: LD_INT 21
15468: PUSH
15469: LD_INT 1
15471: PUSH
15472: EMPTY
15473: LIST
15474: LIST
15475: PUSH
15476: LD_INT 33
15478: PUSH
15479: LD_INT 1
15481: PUSH
15482: EMPTY
15483: LIST
15484: LIST
15485: PUSH
15486: EMPTY
15487: LIST
15488: LIST
15489: LIST
15490: PUSH
15491: EMPTY
15492: LIST
15493: LIST
15494: PPUSH
15495: CALL_OW 69
15499: NOT
15500: IFFALSE 15351
// end ;
15502: PPOPN 2
15504: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15505: LD_EXP 4
15509: PUSH
15510: LD_EXP 2
15514: AND
15515: PUSH
15516: LD_EXP 3
15520: AND
15521: PUSH
15522: LD_EXP 5
15526: AND
15527: IFFALSE 16911
15529: GO 15531
15531: DISABLE
15532: LD_INT 0
15534: PPUSH
15535: PPUSH
// begin music_class := 5 ;
15536: LD_ADDR_OWVAR 72
15540: PUSH
15541: LD_INT 5
15543: ST_TO_ADDR
// music_nat := 5 ;
15544: LD_ADDR_OWVAR 71
15548: PUSH
15549: LD_INT 5
15551: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15552: LD_EXP 12
15556: PUSH
15557: LD_INT 3
15559: LESS
15560: IFFALSE 15569
// SetAchievement ( ACH_ECONOMY ) ;
15562: LD_STRING ACH_ECONOMY
15564: PPUSH
15565: CALL_OW 543
// if tick < 60 60$00 then
15569: LD_OWVAR 1
15573: PUSH
15574: LD_INT 126000
15576: LESS
15577: IFFALSE 15593
// begin wait ( 3 ) ;
15579: LD_INT 3
15581: PPUSH
15582: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15586: LD_STRING ACH_ASPEED_19
15588: PPUSH
15589: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15593: LD_EXP 14
15597: PPUSH
15598: CALL_OW 87
// InGameOn ;
15602: CALL_OW 8
// DialogueOn ;
15606: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15610: LD_EXP 14
15614: PPUSH
15615: LD_STRING DEnd-JMM-JMM-1
15617: PPUSH
15618: CALL_OW 88
// if Joan then
15622: LD_EXP 29
15626: IFFALSE 15642
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15628: LD_EXP 29
15632: PPUSH
15633: LD_STRING DEnd-JMM-Joan-1
15635: PPUSH
15636: CALL_OW 88
15640: GO 15686
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15642: LD_EXP 16
15646: PUSH
15647: LD_EXP 16
15651: PPUSH
15652: CALL_OW 255
15656: PUSH
15657: LD_INT 7
15659: EQUAL
15660: AND
15661: PUSH
15662: LD_EXP 16
15666: PPUSH
15667: CALL_OW 305
15671: AND
15672: IFFALSE 15686
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15674: LD_EXP 16
15678: PPUSH
15679: LD_STRING DEnd-JMM-Lisa-1
15681: PPUSH
15682: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15686: LD_EXP 26
15690: PUSH
15691: LD_EXP 26
15695: PPUSH
15696: CALL_OW 305
15700: AND
15701: IFFALSE 15715
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15703: LD_EXP 26
15707: PPUSH
15708: LD_STRING DEnd-JMM-Frank-1
15710: PPUSH
15711: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15715: LD_EXP 19
15719: PUSH
15720: LD_EXP 19
15724: PPUSH
15725: CALL_OW 255
15729: PUSH
15730: LD_INT 7
15732: EQUAL
15733: AND
15734: PUSH
15735: LD_EXP 19
15739: PPUSH
15740: CALL_OW 305
15744: AND
15745: IFFALSE 15759
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15747: LD_EXP 19
15751: PPUSH
15752: LD_STRING DEnd-JMM-Cyrus-1
15754: PPUSH
15755: CALL_OW 88
// if Burlak then
15759: LD_EXP 46
15763: IFFALSE 15777
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15765: LD_EXP 46
15769: PPUSH
15770: LD_STRING DEnd-JMM-Bur-1
15772: PPUSH
15773: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15777: LD_EXP 29
15781: PUSH
15782: LD_EXP 16
15786: AND
15787: PUSH
15788: LD_EXP 16
15792: PPUSH
15793: CALL_OW 255
15797: PUSH
15798: LD_INT 7
15800: EQUAL
15801: AND
15802: PUSH
15803: LD_EXP 16
15807: PPUSH
15808: CALL_OW 305
15812: AND
15813: IFFALSE 15827
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15815: LD_EXP 16
15819: PPUSH
15820: LD_STRING DEnd-Burlak-Lisa-1
15822: PPUSH
15823: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15827: LD_EXP 47
15831: PUSH
15832: LD_EXP 47
15836: PPUSH
15837: CALL_OW 305
15841: AND
15842: IFFALSE 15856
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15844: LD_EXP 47
15848: PPUSH
15849: LD_STRING DEnd-JMM-Bel-1
15851: PPUSH
15852: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15856: LD_EXP 48
15860: PUSH
15861: LD_EXP 48
15865: PPUSH
15866: CALL_OW 305
15870: AND
15871: IFFALSE 15885
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15873: LD_EXP 48
15877: PPUSH
15878: LD_STRING DEnd-JMM-Gny-1
15880: PPUSH
15881: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15885: LD_EXP 24
15889: PUSH
15890: LD_EXP 24
15894: PPUSH
15895: CALL_OW 255
15899: PUSH
15900: LD_INT 7
15902: EQUAL
15903: AND
15904: PUSH
15905: LD_EXP 24
15909: PPUSH
15910: CALL_OW 305
15914: AND
15915: IFFALSE 15929
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15917: LD_EXP 24
15921: PPUSH
15922: LD_STRING DEnd-JMM-Corn-1
15924: PPUSH
15925: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15929: LD_EXP 17
15933: PUSH
15934: LD_EXP 17
15938: PPUSH
15939: CALL_OW 255
15943: PUSH
15944: LD_INT 7
15946: EQUAL
15947: AND
15948: PUSH
15949: LD_EXP 17
15953: PPUSH
15954: CALL_OW 305
15958: AND
15959: IFFALSE 15973
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15961: LD_EXP 17
15965: PPUSH
15966: LD_STRING DEnd-JMM-Don-1
15968: PPUSH
15969: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15973: LD_EXP 18
15977: PUSH
15978: LD_EXP 18
15982: PPUSH
15983: CALL_OW 255
15987: PUSH
15988: LD_INT 7
15990: EQUAL
15991: AND
15992: PUSH
15993: LD_EXP 18
15997: PPUSH
15998: CALL_OW 305
16002: AND
16003: IFFALSE 16017
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16005: LD_EXP 18
16009: PPUSH
16010: LD_STRING DEnd-JMM-Bobby-1
16012: PPUSH
16013: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16017: LD_EXP 20
16021: PUSH
16022: LD_EXP 20
16026: PPUSH
16027: CALL_OW 255
16031: PUSH
16032: LD_INT 7
16034: EQUAL
16035: AND
16036: PUSH
16037: LD_EXP 20
16041: PPUSH
16042: CALL_OW 305
16046: AND
16047: IFFALSE 16061
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16049: LD_EXP 20
16053: PPUSH
16054: LD_STRING DEnd-JMM-Den-1
16056: PPUSH
16057: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16061: LD_EXP 22
16065: PUSH
16066: LD_EXP 22
16070: PPUSH
16071: CALL_OW 255
16075: PUSH
16076: LD_INT 7
16078: EQUAL
16079: AND
16080: PUSH
16081: LD_EXP 22
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16093: LD_EXP 22
16097: PPUSH
16098: LD_STRING DEnd-JMM-Glad-1
16100: PPUSH
16101: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16105: LD_EXP 27
16109: PUSH
16110: LD_EXP 27
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 27
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16137: LD_EXP 27
16141: PPUSH
16142: LD_STRING DEnd-JMM-Yam-1
16144: PPUSH
16145: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16149: LD_EXP 21
16153: PUSH
16154: LD_EXP 21
16158: PPUSH
16159: CALL_OW 255
16163: PUSH
16164: LD_INT 7
16166: EQUAL
16167: AND
16168: PUSH
16169: LD_EXP 21
16173: PPUSH
16174: CALL_OW 305
16178: AND
16179: IFFALSE 16193
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16181: LD_EXP 21
16185: PPUSH
16186: LD_STRING DEnd-JMM-Brown-1
16188: PPUSH
16189: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16193: LD_EXP 31
16197: PUSH
16198: LD_EXP 31
16202: PPUSH
16203: CALL_OW 255
16207: PUSH
16208: LD_INT 7
16210: EQUAL
16211: AND
16212: PUSH
16213: LD_EXP 31
16217: PPUSH
16218: CALL_OW 305
16222: AND
16223: IFFALSE 16237
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16225: LD_EXP 31
16229: PPUSH
16230: LD_STRING DEnd-JMM-Con-1
16232: PPUSH
16233: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16237: LD_EXP 25
16241: PUSH
16242: LD_EXP 25
16246: PPUSH
16247: CALL_OW 255
16251: PUSH
16252: LD_INT 7
16254: EQUAL
16255: AND
16256: PUSH
16257: LD_EXP 25
16261: PPUSH
16262: CALL_OW 305
16266: AND
16267: IFFALSE 16281
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16269: LD_EXP 25
16273: PPUSH
16274: LD_STRING DEnd-JMM-Gary-1
16276: PPUSH
16277: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16281: LD_EXP 28
16285: PUSH
16286: LD_EXP 15
16290: AND
16291: PUSH
16292: LD_EXP 28
16296: PPUSH
16297: CALL_OW 305
16301: AND
16302: IFFALSE 16316
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16304: LD_EXP 28
16308: PPUSH
16309: LD_STRING DEnd-JMM-Sim-1
16311: PPUSH
16312: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16316: LD_EXP 23
16320: PUSH
16321: LD_EXP 23
16325: PPUSH
16326: CALL_OW 255
16330: PUSH
16331: LD_INT 7
16333: EQUAL
16334: AND
16335: PUSH
16336: LD_EXP 23
16340: PPUSH
16341: CALL_OW 305
16345: AND
16346: IFFALSE 16360
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16348: LD_EXP 23
16352: PPUSH
16353: LD_STRING DEnd-JMM-VanH-1
16355: PPUSH
16356: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16360: LD_EXP 36
16364: PUSH
16365: LD_EXP 36
16369: PPUSH
16370: CALL_OW 305
16374: AND
16375: IFFALSE 16389
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16377: LD_EXP 36
16381: PPUSH
16382: LD_STRING DEnd-JMM-Dol-1
16384: PPUSH
16385: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16389: LD_EXP 40
16393: PUSH
16394: LD_EXP 40
16398: PPUSH
16399: CALL_OW 305
16403: AND
16404: IFFALSE 16418
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16406: LD_EXP 40
16410: PPUSH
16411: LD_STRING DEnd-JMM-Kap-1
16413: PPUSH
16414: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16418: LD_EXP 43
16422: PUSH
16423: LD_EXP 43
16427: PPUSH
16428: CALL_OW 305
16432: AND
16433: IFFALSE 16447
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16435: LD_EXP 43
16439: PPUSH
16440: LD_STRING DEnd-JMM-Kov-1
16442: PPUSH
16443: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16447: LD_EXP 38
16451: PUSH
16452: LD_EXP 38
16456: PPUSH
16457: CALL_OW 305
16461: AND
16462: IFFALSE 16476
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16464: LD_EXP 38
16468: PPUSH
16469: LD_STRING DEnd-JMM-Sch-1
16471: PPUSH
16472: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16476: LD_EXP 34
16480: PUSH
16481: LD_EXP 34
16485: PPUSH
16486: CALL_OW 305
16490: AND
16491: IFFALSE 16505
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16493: LD_EXP 34
16497: PPUSH
16498: LD_STRING DEnd-JMM-Tit-1
16500: PPUSH
16501: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16505: LD_EXP 39
16509: PUSH
16510: LD_EXP 39
16514: PPUSH
16515: CALL_OW 305
16519: AND
16520: IFFALSE 16534
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16522: LD_EXP 39
16526: PPUSH
16527: LD_STRING DEnd-JMM-Obl-1
16529: PPUSH
16530: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16534: LD_EXP 41
16538: PUSH
16539: LD_EXP 41
16543: PPUSH
16544: CALL_OW 305
16548: AND
16549: IFFALSE 16563
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16551: LD_EXP 41
16555: PPUSH
16556: LD_STRING DEnd-JMM-Lip-1
16558: PPUSH
16559: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16563: LD_EXP 35
16567: PUSH
16568: LD_EXP 35
16572: PPUSH
16573: CALL_OW 305
16577: AND
16578: PUSH
16579: LD_EXP 46
16583: AND
16584: IFFALSE 16598
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16586: LD_EXP 35
16590: PPUSH
16591: LD_STRING DEnd-Burlak-Fad-1
16593: PPUSH
16594: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16598: LD_EXP 42
16602: PUSH
16603: LD_EXP 42
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16615: LD_EXP 42
16619: PPUSH
16620: LD_STRING DEnd-Burlak-Ptr-1
16622: PPUSH
16623: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16627: LD_EXP 44
16631: PUSH
16632: LD_EXP 44
16636: PPUSH
16637: CALL_OW 305
16641: AND
16642: IFFALSE 16656
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16644: LD_EXP 44
16648: PPUSH
16649: LD_STRING DEnd-Burlak-Kuz-1
16651: PPUSH
16652: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16656: LD_EXP 33
16660: PUSH
16661: LD_EXP 33
16665: PPUSH
16666: CALL_OW 305
16670: AND
16671: PUSH
16672: LD_EXP 46
16676: AND
16677: IFFALSE 16691
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16679: LD_EXP 33
16683: PPUSH
16684: LD_STRING DEnd-Burlak-Kir-1
16686: PPUSH
16687: CALL_OW 88
// if Burlak then
16691: LD_EXP 46
16695: IFFALSE 16709
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16697: LD_EXP 14
16701: PPUSH
16702: LD_STRING DEnd-Burlak-JMM-1
16704: PPUSH
16705: CALL_OW 88
// dwait ( 0 0$2 ) ;
16709: LD_INT 70
16711: PPUSH
16712: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16716: LD_EXP 51
16720: PPUSH
16721: LD_STRING DEnd-Szulc
16723: PPUSH
16724: CALL_OW 94
// dwait ( 0 0$1 ) ;
16728: LD_INT 35
16730: PPUSH
16731: CALL_OW 68
// if IsLive ( Burlak ) then
16735: LD_EXP 46
16739: PPUSH
16740: CALL_OW 300
16744: IFFALSE 16756
// med1 := 1 else
16746: LD_ADDR_VAR 0 1
16750: PUSH
16751: LD_INT 1
16753: ST_TO_ADDR
16754: GO 16765
// med1 := - 1 ;
16756: LD_ADDR_VAR 0 1
16760: PUSH
16761: LD_INT 1
16763: NEG
16764: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16765: LD_EXP 9
16769: PUSH
16770: LD_EXP 10
16774: AND
16775: PUSH
16776: LD_EXP 11
16780: AND
16781: IFFALSE 16793
// med2 := 1 else
16783: LD_ADDR_VAR 0 2
16787: PUSH
16788: LD_INT 1
16790: ST_TO_ADDR
16791: GO 16802
// med2 := - 1 ;
16793: LD_ADDR_VAR 0 2
16797: PUSH
16798: LD_INT 1
16800: NEG
16801: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16802: LD_STRING Hero
16804: PPUSH
16805: LD_INT 1
16807: PPUSH
16808: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16812: LD_STRING Artefact
16814: PPUSH
16815: LD_VAR 0 2
16819: PPUSH
16820: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16824: LD_STRING ReconcileBurlak
16826: PPUSH
16827: LD_VAR 0 1
16831: PPUSH
16832: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
16836: LD_OWVAR 67
16840: PUSH
16841: LD_INT 3
16843: EQUAL
16844: PUSH
16845: LD_VAR 0 1
16849: PUSH
16850: LD_INT 1
16852: EQUAL
16853: AND
16854: PUSH
16855: LD_VAR 0 2
16859: PUSH
16860: LD_INT 1
16862: EQUAL
16863: AND
16864: IFFALSE 16876
// SetAchievementEX ( ACH_AMER , 19 ) ;
16866: LD_STRING ACH_AMER
16868: PPUSH
16869: LD_INT 19
16871: PPUSH
16872: CALL_OW 564
// GiveMedals ( MAIN ) ;
16876: LD_STRING MAIN
16878: PPUSH
16879: CALL_OW 102
// InGameOff ;
16883: CALL_OW 9
// DialogueOff ;
16887: CALL_OW 7
// music_nat := 1 ;
16891: LD_ADDR_OWVAR 71
16895: PUSH
16896: LD_INT 1
16898: ST_TO_ADDR
// music_class := 4 ;
16899: LD_ADDR_OWVAR 72
16903: PUSH
16904: LD_INT 4
16906: ST_TO_ADDR
// YouWin ;
16907: CALL_OW 103
// end ; end_of_file
16911: PPOPN 2
16913: END
// export function InitNature ; begin
16914: LD_INT 0
16916: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16917: LD_INT 3
16919: PPUSH
16920: LD_INT 3
16922: PPUSH
16923: LD_INT 2
16925: PPUSH
16926: LD_INT 1
16928: PPUSH
16929: LD_INT 1
16931: PPUSH
16932: LD_INT 0
16934: PPUSH
16935: LD_INT 0
16937: PPUSH
16938: LD_INT 17
16940: PPUSH
16941: LD_INT 0
16943: PPUSH
16944: CALL 85328 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16948: LD_INT 2
16950: PPUSH
16951: LD_INT 1
16953: PPUSH
16954: LD_INT 1
16956: PPUSH
16957: LD_INT 1
16959: PPUSH
16960: LD_INT 1
16962: PPUSH
16963: LD_INT 0
16965: PPUSH
16966: LD_INT 0
16968: PPUSH
16969: LD_INT 18
16971: PPUSH
16972: LD_INT 0
16974: PPUSH
16975: CALL 85328 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16979: LD_INT 4
16981: PPUSH
16982: LD_INT 1
16984: PPUSH
16985: LD_INT 2
16987: PPUSH
16988: LD_INT 4
16990: PPUSH
16991: LD_INT 2
16993: PPUSH
16994: LD_INT 1
16996: PPUSH
16997: LD_INT 0
16999: PPUSH
17000: LD_INT 19
17002: PPUSH
17003: LD_INT 0
17005: PPUSH
17006: CALL 85328 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17010: LD_INT 0
17012: PPUSH
17013: LD_INT 0
17015: PPUSH
17016: LD_INT 0
17018: PPUSH
17019: LD_INT 0
17021: PPUSH
17022: LD_INT 0
17024: PPUSH
17025: LD_INT 0
17027: PPUSH
17028: LD_INT 9
17030: PPUSH
17031: LD_INT 0
17033: PPUSH
17034: LD_INT 20
17036: PPUSH
17037: CALL 85328 0 9
// end ; end_of_file
17041: LD_VAR 0 1
17045: RET
// every 0 0$30 do var time ;
17046: GO 17048
17048: DISABLE
17049: LD_INT 0
17051: PPUSH
// begin time := 0 0$50 ;
17052: LD_ADDR_VAR 0 1
17056: PUSH
17057: LD_INT 1750
17059: ST_TO_ADDR
// repeat wait ( time ) ;
17060: LD_VAR 0 1
17064: PPUSH
17065: CALL_OW 67
// if Prob ( 50 ) then
17069: LD_INT 50
17071: PPUSH
17072: CALL_OW 13
17076: IFFALSE 17105
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17078: LD_INT 1
17080: PPUSH
17081: LD_INT 5
17083: PPUSH
17084: CALL_OW 12
17088: PPUSH
17089: LD_INT 106
17091: PPUSH
17092: LD_INT 89
17094: PPUSH
17095: LD_INT 45
17097: PPUSH
17098: LD_INT 1
17100: PPUSH
17101: CALL_OW 56
// time := time + 0 0$3 ;
17105: LD_ADDR_VAR 0 1
17109: PUSH
17110: LD_VAR 0 1
17114: PUSH
17115: LD_INT 105
17117: PLUS
17118: ST_TO_ADDR
// if Prob ( 30 ) then
17119: LD_INT 30
17121: PPUSH
17122: CALL_OW 13
17126: IFFALSE 17172
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17128: LD_INT 525
17130: PPUSH
17131: LD_INT 735
17133: PPUSH
17134: CALL_OW 12
17138: PPUSH
17139: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17143: LD_INT 1
17145: PPUSH
17146: LD_INT 5
17148: PPUSH
17149: CALL_OW 12
17153: PPUSH
17154: LD_INT 21
17156: PPUSH
17157: LD_INT 26
17159: PPUSH
17160: LD_INT 12
17162: PPUSH
17163: LD_INT 1
17165: PPUSH
17166: CALL_OW 56
// end else
17170: GO 17208
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17172: LD_INT 700
17174: PPUSH
17175: LD_INT 1225
17177: PPUSH
17178: CALL_OW 12
17182: PPUSH
17183: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17187: LD_INT 1
17189: PPUSH
17190: LD_INT 5
17192: PPUSH
17193: CALL_OW 12
17197: PPUSH
17198: LD_INT 14
17200: PPUSH
17201: LD_INT 1
17203: PPUSH
17204: CALL_OW 55
// end ; if Prob ( 50 ) then
17208: LD_INT 50
17210: PPUSH
17211: CALL_OW 13
17215: IFFALSE 17261
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17217: LD_INT 700
17219: PPUSH
17220: LD_INT 1050
17222: PPUSH
17223: CALL_OW 12
17227: PPUSH
17228: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17232: LD_INT 1
17234: PPUSH
17235: LD_INT 5
17237: PPUSH
17238: CALL_OW 12
17242: PPUSH
17243: LD_INT 181
17245: PPUSH
17246: LD_INT 218
17248: PPUSH
17249: LD_INT 16
17251: PPUSH
17252: LD_INT 1
17254: PPUSH
17255: CALL_OW 56
// end else
17259: GO 17333
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17261: LD_INT 350
17263: PPUSH
17264: LD_INT 525
17266: PPUSH
17267: CALL_OW 12
17271: PPUSH
17272: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17276: LD_INT 1
17278: PPUSH
17279: LD_INT 5
17281: PPUSH
17282: CALL_OW 12
17286: PPUSH
17287: LD_INT 13
17289: PPUSH
17290: LD_INT 1
17292: PPUSH
17293: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17297: LD_INT 350
17299: PPUSH
17300: LD_INT 700
17302: PPUSH
17303: CALL_OW 12
17307: PPUSH
17308: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17312: LD_INT 1
17314: PPUSH
17315: LD_INT 5
17317: PPUSH
17318: CALL_OW 12
17322: PPUSH
17323: LD_INT 33
17325: PPUSH
17326: LD_INT 1
17328: PPUSH
17329: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17333: LD_INT 65
17335: PUSH
17336: LD_INT 62
17338: PUSH
17339: LD_INT 55
17341: PUSH
17342: EMPTY
17343: LIST
17344: LIST
17345: LIST
17346: PUSH
17347: LD_OWVAR 67
17351: ARRAY
17352: PPUSH
17353: CALL_OW 13
17357: IFFALSE 17403
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17359: LD_INT 525
17361: PPUSH
17362: LD_INT 875
17364: PPUSH
17365: CALL_OW 12
17369: PPUSH
17370: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17374: LD_INT 1
17376: PPUSH
17377: LD_INT 5
17379: PPUSH
17380: CALL_OW 12
17384: PPUSH
17385: LD_INT 294
17387: PPUSH
17388: LD_INT 211
17390: PPUSH
17391: LD_INT 30
17393: PPUSH
17394: LD_INT 1
17396: PPUSH
17397: CALL_OW 56
// end else
17401: GO 17445
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17403: LD_INT 420
17405: PPUSH
17406: LD_INT 770
17408: PPUSH
17409: CALL_OW 12
17413: PPUSH
17414: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17418: LD_INT 1
17420: PPUSH
17421: LD_INT 5
17423: PPUSH
17424: CALL_OW 12
17428: PPUSH
17429: LD_INT 294
17431: PPUSH
17432: LD_INT 211
17434: PPUSH
17435: LD_INT 30
17437: PPUSH
17438: LD_INT 1
17440: PPUSH
17441: CALL_OW 56
// end ; if time > 2 2$20 then
17445: LD_VAR 0 1
17449: PUSH
17450: LD_INT 4900
17452: GREATER
17453: IFFALSE 17463
// time := 0 0$50 ;
17455: LD_ADDR_VAR 0 1
17459: PUSH
17460: LD_INT 1750
17462: ST_TO_ADDR
// until false ;
17463: LD_INT 0
17465: IFFALSE 17060
// end ;
17467: PPOPN 1
17469: END
// every 0 0$45 trigger tick < 10 10$00 do
17470: LD_OWVAR 1
17474: PUSH
17475: LD_INT 21000
17477: LESS
17478: IFFALSE 17526
17480: GO 17482
17482: DISABLE
// begin enable ;
17483: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17484: LD_INT 350
17486: PPUSH
17487: LD_INT 700
17489: PPUSH
17490: CALL_OW 12
17494: PPUSH
17495: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17499: LD_INT 3
17501: PPUSH
17502: LD_INT 5
17504: PPUSH
17505: CALL_OW 12
17509: PPUSH
17510: LD_INT 181
17512: PPUSH
17513: LD_INT 13
17515: PPUSH
17516: LD_INT 20
17518: PPUSH
17519: LD_INT 1
17521: PPUSH
17522: CALL_OW 56
// end ; end_of_file
17526: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17527: LD_INT 0
17529: PPUSH
// SetArtifactRes ( 7 , true ) ;
17530: LD_INT 7
17532: PPUSH
17533: LD_INT 1
17535: PPUSH
17536: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17540: LD_ADDR_EXP 59
17544: PUSH
17545: EMPTY
17546: PUSH
17547: EMPTY
17548: PUSH
17549: EMPTY
17550: PUSH
17551: EMPTY
17552: LIST
17553: LIST
17554: LIST
17555: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17556: LD_ADDR_EXP 60
17560: PUSH
17561: LD_INT 1050
17563: PUSH
17564: LD_OWVAR 67
17568: MUL
17569: PUSH
17570: LD_INT 2800
17572: PUSH
17573: LD_OWVAR 67
17577: MUL
17578: PUSH
17579: LD_INT 1
17581: NEG
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: LIST
17587: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17588: LD_ADDR_EXP 61
17592: PUSH
17593: LD_INT 10
17595: PUSH
17596: LD_INT 35
17598: PUSH
17599: LD_INT 100
17601: PUSH
17602: EMPTY
17603: LIST
17604: LIST
17605: LIST
17606: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17607: LD_ADDR_EXP 62
17611: PUSH
17612: LD_INT 0
17614: PUSH
17615: LD_INT 0
17617: PUSH
17618: LD_INT 0
17620: PUSH
17621: EMPTY
17622: LIST
17623: LIST
17624: LIST
17625: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17626: LD_ADDR_EXP 64
17630: PUSH
17631: LD_INT 300
17633: PUSH
17634: LD_INT 500
17636: PUSH
17637: LD_INT 800
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: LIST
17644: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17645: LD_ADDR_EXP 65
17649: PUSH
17650: LD_INT 0
17652: PUSH
17653: LD_INT 0
17655: PUSH
17656: LD_INT 0
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: LIST
17663: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17664: LD_ADDR_EXP 66
17668: PUSH
17669: LD_INT 0
17671: PUSH
17672: LD_INT 0
17674: PUSH
17675: LD_INT 0
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: LIST
17682: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17683: LD_ADDR_EXP 63
17687: PUSH
17688: LD_INT 0
17690: PUSH
17691: LD_INT 0
17693: PUSH
17694: LD_INT 0
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: LIST
17701: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17702: LD_ADDR_EXP 67
17706: PUSH
17707: LD_INT 4
17709: PUSH
17710: LD_INT 3
17712: PUSH
17713: LD_INT 1
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: LIST
17720: PUSH
17721: LD_INT 5
17723: PUSH
17724: LD_INT 4
17726: PUSH
17727: LD_INT 2
17729: PUSH
17730: EMPTY
17731: LIST
17732: LIST
17733: LIST
17734: PUSH
17735: LD_INT 6
17737: PUSH
17738: LD_INT 3
17740: PUSH
17741: LD_INT 3
17743: PUSH
17744: EMPTY
17745: LIST
17746: LIST
17747: LIST
17748: PUSH
17749: EMPTY
17750: LIST
17751: LIST
17752: LIST
17753: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17754: LD_ADDR_EXP 68
17758: PUSH
17759: LD_INT 0
17761: PUSH
17762: LD_INT 0
17764: PUSH
17765: LD_INT 0
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: LIST
17772: ST_TO_ADDR
// end ;
17773: LD_VAR 0 1
17777: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17778: LD_INT 24
17780: PPUSH
17781: LD_INT 7
17783: PPUSH
17784: CALL_OW 321
17788: PUSH
17789: LD_INT 2
17791: EQUAL
17792: IFFALSE 18718
17794: GO 17796
17796: DISABLE
17797: LD_INT 0
17799: PPUSH
17800: PPUSH
17801: PPUSH
17802: PPUSH
17803: PPUSH
// begin enable ;
17804: ENABLE
// for i = 1 to 3 do
17805: LD_ADDR_VAR 0 1
17809: PUSH
17810: DOUBLE
17811: LD_INT 1
17813: DEC
17814: ST_TO_ADDR
17815: LD_INT 3
17817: PUSH
17818: FOR_TO
17819: IFFALSE 18716
// begin pos := FindArtifact ( i + 2 ) ;
17821: LD_ADDR_VAR 0 2
17825: PUSH
17826: LD_VAR 0 1
17830: PUSH
17831: LD_INT 2
17833: PLUS
17834: PPUSH
17835: CALL_OW 469
17839: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17840: LD_ADDR_EXP 59
17844: PUSH
17845: LD_EXP 59
17849: PPUSH
17850: LD_VAR 0 1
17854: PPUSH
17855: LD_VAR 0 2
17859: PPUSH
17860: CALL_OW 1
17864: ST_TO_ADDR
// if pos then
17865: LD_VAR 0 2
17869: IFFALSE 18577
// begin case i of 1 :
17871: LD_VAR 0 1
17875: PUSH
17876: LD_INT 1
17878: DOUBLE
17879: EQUAL
17880: IFTRUE 17884
17882: GO 17961
17884: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17885: LD_ADDR_VAR 0 4
17889: PUSH
17890: LD_INT 22
17892: PUSH
17893: LD_INT 7
17895: PUSH
17896: EMPTY
17897: LIST
17898: LIST
17899: PUSH
17900: LD_INT 23
17902: PUSH
17903: LD_INT 1
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: PUSH
17910: LD_INT 2
17912: PUSH
17913: LD_INT 30
17915: PUSH
17916: LD_INT 8
17918: PUSH
17919: EMPTY
17920: LIST
17921: LIST
17922: PUSH
17923: LD_INT 30
17925: PUSH
17926: LD_INT 7
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: PUSH
17933: LD_INT 30
17935: PUSH
17936: LD_INT 11
17938: PUSH
17939: EMPTY
17940: LIST
17941: LIST
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: LIST
17947: LIST
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: LIST
17953: PPUSH
17954: CALL_OW 69
17958: ST_TO_ADDR
17959: GO 18069
17961: LD_INT 2
17963: DOUBLE
17964: EQUAL
17965: IFTRUE 17969
17967: GO 18046
17969: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17970: LD_ADDR_VAR 0 4
17974: PUSH
17975: LD_INT 22
17977: PUSH
17978: LD_INT 7
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PUSH
17985: LD_INT 23
17987: PUSH
17988: LD_INT 3
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PUSH
17995: LD_INT 2
17997: PUSH
17998: LD_INT 30
18000: PUSH
18001: LD_INT 8
18003: PUSH
18004: EMPTY
18005: LIST
18006: LIST
18007: PUSH
18008: LD_INT 30
18010: PUSH
18011: LD_INT 7
18013: PUSH
18014: EMPTY
18015: LIST
18016: LIST
18017: PUSH
18018: LD_INT 30
18020: PUSH
18021: LD_INT 11
18023: PUSH
18024: EMPTY
18025: LIST
18026: LIST
18027: PUSH
18028: EMPTY
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: LIST
18038: PPUSH
18039: CALL_OW 69
18043: ST_TO_ADDR
18044: GO 18069
18046: LD_INT 3
18048: DOUBLE
18049: EQUAL
18050: IFTRUE 18054
18052: GO 18068
18054: POP
// labs := [ alien ] ; end ;
18055: LD_ADDR_VAR 0 4
18059: PUSH
18060: LD_INT 1
18062: PUSH
18063: EMPTY
18064: LIST
18065: ST_TO_ADDR
18066: GO 18069
18068: POP
// if not labs then
18069: LD_VAR 0 4
18073: NOT
18074: IFFALSE 18078
// continue ;
18076: GO 17818
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18078: LD_ADDR_VAR 0 5
18082: PUSH
18083: LD_VAR 0 4
18087: PPUSH
18088: LD_EXP 59
18092: PUSH
18093: LD_VAR 0 1
18097: ARRAY
18098: PUSH
18099: LD_INT 1
18101: ARRAY
18102: PPUSH
18103: LD_EXP 59
18107: PUSH
18108: LD_VAR 0 1
18112: ARRAY
18113: PUSH
18114: LD_INT 2
18116: ARRAY
18117: PPUSH
18118: CALL_OW 73
18122: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18123: LD_VAR 0 5
18127: NOT
18128: PUSH
18129: LD_VAR 0 5
18133: PUSH
18134: LD_EXP 66
18138: PUSH
18139: LD_VAR 0 1
18143: ARRAY
18144: NONEQUAL
18145: OR
18146: IFFALSE 18251
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18148: LD_INT 7
18150: PPUSH
18151: LD_EXP 67
18155: PUSH
18156: LD_VAR 0 1
18160: ARRAY
18161: PUSH
18162: LD_INT 3
18164: ARRAY
18165: PPUSH
18166: LD_INT 0
18168: PPUSH
18169: LD_EXP 66
18173: PUSH
18174: LD_VAR 0 1
18178: ARRAY
18179: PPUSH
18180: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18184: LD_INT 7
18186: PPUSH
18187: LD_EXP 67
18191: PUSH
18192: LD_VAR 0 1
18196: ARRAY
18197: PUSH
18198: LD_INT 1
18200: ARRAY
18201: PPUSH
18202: LD_INT 0
18204: PPUSH
18205: LD_EXP 66
18209: PUSH
18210: LD_VAR 0 1
18214: ARRAY
18215: PPUSH
18216: CALL_OW 468
// if nearestLab then
18220: LD_VAR 0 5
18224: IFFALSE 18251
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18226: LD_ADDR_EXP 66
18230: PUSH
18231: LD_EXP 66
18235: PPUSH
18236: LD_VAR 0 1
18240: PPUSH
18241: LD_VAR 0 5
18245: PPUSH
18246: CALL_OW 1
18250: ST_TO_ADDR
// end ; if not nearestLab then
18251: LD_VAR 0 5
18255: NOT
18256: IFFALSE 18260
// continue ;
18258: GO 17818
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18260: LD_VAR 0 5
18264: PPUSH
18265: LD_EXP 59
18269: PUSH
18270: LD_VAR 0 1
18274: ARRAY
18275: PUSH
18276: LD_INT 1
18278: ARRAY
18279: PPUSH
18280: LD_EXP 59
18284: PUSH
18285: LD_VAR 0 1
18289: ARRAY
18290: PUSH
18291: LD_INT 2
18293: ARRAY
18294: PPUSH
18295: CALL_OW 297
18299: PUSH
18300: LD_INT 8
18302: LESS
18303: IFFALSE 18500
// begin if not artifactsResearched [ i ] then
18305: LD_EXP 62
18309: PUSH
18310: LD_VAR 0 1
18314: ARRAY
18315: NOT
18316: IFFALSE 18397
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18318: LD_VAR 0 5
18322: PPUSH
18323: CALL_OW 461
18327: PUSH
18328: LD_INT 2
18330: EQUAL
18331: IFFALSE 18365
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18333: LD_INT 7
18335: PPUSH
18336: LD_EXP 67
18340: PUSH
18341: LD_VAR 0 1
18345: ARRAY
18346: PUSH
18347: LD_INT 3
18349: ARRAY
18350: PPUSH
18351: LD_INT 2
18353: PPUSH
18354: LD_VAR 0 5
18358: PPUSH
18359: CALL_OW 468
18363: GO 18395
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18365: LD_INT 7
18367: PPUSH
18368: LD_EXP 67
18372: PUSH
18373: LD_VAR 0 1
18377: ARRAY
18378: PUSH
18379: LD_INT 3
18381: ARRAY
18382: PPUSH
18383: LD_INT 1
18385: PPUSH
18386: LD_VAR 0 5
18390: PPUSH
18391: CALL_OW 468
// end else
18395: GO 18498
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18397: LD_VAR 0 5
18401: PPUSH
18402: CALL_OW 461
18406: PUSH
18407: LD_INT 2
18409: EQUAL
18410: PUSH
18411: LD_EXP 68
18415: PUSH
18416: LD_VAR 0 1
18420: ARRAY
18421: AND
18422: IFFALSE 18468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18424: LD_INT 7
18426: PPUSH
18427: LD_EXP 67
18431: PUSH
18432: LD_VAR 0 1
18436: ARRAY
18437: PUSH
18438: LD_INT 1
18440: ARRAY
18441: PPUSH
18442: LD_EXP 67
18446: PUSH
18447: LD_VAR 0 1
18451: ARRAY
18452: PUSH
18453: LD_INT 2
18455: ARRAY
18456: PPUSH
18457: LD_VAR 0 5
18461: PPUSH
18462: CALL_OW 468
18466: GO 18498
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18468: LD_INT 7
18470: PPUSH
18471: LD_EXP 67
18475: PUSH
18476: LD_VAR 0 1
18480: ARRAY
18481: PUSH
18482: LD_INT 1
18484: ARRAY
18485: PPUSH
18486: LD_INT 1
18488: PPUSH
18489: LD_VAR 0 5
18493: PPUSH
18494: CALL_OW 468
// end else
18498: GO 18575
// begin if not artifactsResearched [ i ] then
18500: LD_EXP 62
18504: PUSH
18505: LD_VAR 0 1
18509: ARRAY
18510: NOT
18511: IFFALSE 18545
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18513: LD_INT 7
18515: PPUSH
18516: LD_EXP 67
18520: PUSH
18521: LD_VAR 0 1
18525: ARRAY
18526: PUSH
18527: LD_INT 3
18529: ARRAY
18530: PPUSH
18531: LD_INT 0
18533: PPUSH
18534: LD_VAR 0 5
18538: PPUSH
18539: CALL_OW 468
18543: GO 18575
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18545: LD_INT 7
18547: PPUSH
18548: LD_EXP 67
18552: PUSH
18553: LD_VAR 0 1
18557: ARRAY
18558: PUSH
18559: LD_INT 1
18561: ARRAY
18562: PPUSH
18563: LD_INT 0
18565: PPUSH
18566: LD_VAR 0 5
18570: PPUSH
18571: CALL_OW 468
// end ; end else
18575: GO 18714
// begin if not artifactsLabs [ i ] then
18577: LD_EXP 66
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: NOT
18588: IFFALSE 18592
// continue ;
18590: GO 17818
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18592: LD_INT 7
18594: PPUSH
18595: LD_EXP 67
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PUSH
18606: LD_INT 3
18608: ARRAY
18609: PPUSH
18610: LD_INT 0
18612: PPUSH
18613: LD_EXP 66
18617: PUSH
18618: LD_VAR 0 1
18622: ARRAY
18623: PPUSH
18624: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18628: LD_INT 7
18630: PPUSH
18631: LD_EXP 67
18635: PUSH
18636: LD_VAR 0 1
18640: ARRAY
18641: PUSH
18642: LD_INT 1
18644: ARRAY
18645: PPUSH
18646: LD_INT 0
18648: PPUSH
18649: LD_EXP 66
18653: PUSH
18654: LD_VAR 0 1
18658: ARRAY
18659: PPUSH
18660: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18664: LD_EXP 63
18668: PUSH
18669: LD_VAR 0 1
18673: ARRAY
18674: IFFALSE 18714
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18676: LD_ADDR_EXP 63
18680: PUSH
18681: LD_EXP 63
18685: PPUSH
18686: LD_VAR 0 1
18690: PPUSH
18691: LD_INT 0
18693: PPUSH
18694: CALL_OW 1
18698: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18699: LD_EXP 66
18703: PUSH
18704: LD_VAR 0 1
18708: ARRAY
18709: PPUSH
18710: CALL_OW 127
// end ; end ; end ;
18714: GO 17818
18716: POP
18717: POP
// end ;
18718: PPOPN 5
18720: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18721: LD_INT 0
18723: PPUSH
18724: PPUSH
18725: PPUSH
18726: PPUSH
18727: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18728: LD_VAR 0 2
18732: PUSH
18733: LD_EXP 67
18737: PUSH
18738: LD_INT 1
18740: ARRAY
18741: PUSH
18742: LD_INT 3
18744: ARRAY
18745: EQUAL
18746: IFFALSE 18869
// begin lab := artifactsLabs [ 1 ] ;
18748: LD_ADDR_VAR 0 6
18752: PUSH
18753: LD_EXP 66
18757: PUSH
18758: LD_INT 1
18760: ARRAY
18761: ST_TO_ADDR
// if not lab then
18762: LD_VAR 0 6
18766: NOT
18767: IFFALSE 18771
// exit ;
18769: GO 19817
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18771: LD_VAR 0 6
18775: PPUSH
18776: LD_EXP 64
18780: PUSH
18781: LD_INT 1
18783: ARRAY
18784: PPUSH
18785: LD_INT 1
18787: PPUSH
18788: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18792: LD_EXP 65
18796: PUSH
18797: LD_INT 1
18799: ARRAY
18800: IFFALSE 18820
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18802: LD_VAR 0 6
18806: PPUSH
18807: LD_EXP 65
18811: PUSH
18812: LD_INT 1
18814: ARRAY
18815: PPUSH
18816: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18820: LD_ADDR_EXP 63
18824: PUSH
18825: LD_EXP 63
18829: PPUSH
18830: LD_INT 1
18832: PPUSH
18833: LD_INT 1
18835: PPUSH
18836: CALL_OW 1
18840: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18841: LD_INT 7
18843: PPUSH
18844: LD_EXP 67
18848: PUSH
18849: LD_INT 1
18851: ARRAY
18852: PUSH
18853: LD_INT 3
18855: ARRAY
18856: PPUSH
18857: LD_INT 0
18859: PPUSH
18860: LD_VAR 0 6
18864: PPUSH
18865: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18869: LD_VAR 0 2
18873: PUSH
18874: LD_EXP 67
18878: PUSH
18879: LD_INT 2
18881: ARRAY
18882: PUSH
18883: LD_INT 3
18885: ARRAY
18886: EQUAL
18887: IFFALSE 19010
// begin lab := artifactsLabs [ 2 ] ;
18889: LD_ADDR_VAR 0 6
18893: PUSH
18894: LD_EXP 66
18898: PUSH
18899: LD_INT 2
18901: ARRAY
18902: ST_TO_ADDR
// if not lab then
18903: LD_VAR 0 6
18907: NOT
18908: IFFALSE 18912
// exit ;
18910: GO 19817
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18912: LD_VAR 0 6
18916: PPUSH
18917: LD_EXP 64
18921: PUSH
18922: LD_INT 2
18924: ARRAY
18925: PPUSH
18926: LD_INT 1
18928: PPUSH
18929: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18933: LD_EXP 65
18937: PUSH
18938: LD_INT 2
18940: ARRAY
18941: IFFALSE 18961
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18943: LD_VAR 0 6
18947: PPUSH
18948: LD_EXP 65
18952: PUSH
18953: LD_INT 2
18955: ARRAY
18956: PPUSH
18957: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18961: LD_ADDR_EXP 63
18965: PUSH
18966: LD_EXP 63
18970: PPUSH
18971: LD_INT 2
18973: PPUSH
18974: LD_INT 1
18976: PPUSH
18977: CALL_OW 1
18981: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 67
18989: PUSH
18990: LD_INT 2
18992: ARRAY
18993: PUSH
18994: LD_INT 3
18996: ARRAY
18997: PPUSH
18998: LD_INT 0
19000: PPUSH
19001: LD_VAR 0 6
19005: PPUSH
19006: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19010: LD_VAR 0 2
19014: PUSH
19015: LD_EXP 67
19019: PUSH
19020: LD_INT 3
19022: ARRAY
19023: PUSH
19024: LD_INT 3
19026: ARRAY
19027: EQUAL
19028: IFFALSE 19151
// begin lab := artifactsLabs [ 3 ] ;
19030: LD_ADDR_VAR 0 6
19034: PUSH
19035: LD_EXP 66
19039: PUSH
19040: LD_INT 3
19042: ARRAY
19043: ST_TO_ADDR
// if not lab then
19044: LD_VAR 0 6
19048: NOT
19049: IFFALSE 19053
// exit ;
19051: GO 19817
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19053: LD_VAR 0 6
19057: PPUSH
19058: LD_EXP 64
19062: PUSH
19063: LD_INT 3
19065: ARRAY
19066: PPUSH
19067: LD_INT 1
19069: PPUSH
19070: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19074: LD_EXP 65
19078: PUSH
19079: LD_INT 3
19081: ARRAY
19082: IFFALSE 19102
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19084: LD_VAR 0 6
19088: PPUSH
19089: LD_EXP 65
19093: PUSH
19094: LD_INT 3
19096: ARRAY
19097: PPUSH
19098: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19102: LD_ADDR_EXP 63
19106: PUSH
19107: LD_EXP 63
19111: PPUSH
19112: LD_INT 3
19114: PPUSH
19115: LD_INT 1
19117: PPUSH
19118: CALL_OW 1
19122: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19123: LD_INT 7
19125: PPUSH
19126: LD_EXP 67
19130: PUSH
19131: LD_INT 3
19133: ARRAY
19134: PUSH
19135: LD_INT 3
19137: ARRAY
19138: PPUSH
19139: LD_INT 0
19141: PPUSH
19142: LD_VAR 0 6
19146: PPUSH
19147: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19151: LD_VAR 0 2
19155: PUSH
19156: LD_EXP 67
19160: PUSH
19161: LD_INT 1
19163: ARRAY
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: EQUAL
19169: IFFALSE 19327
// begin lab := artifactsLabs [ 1 ] ;
19171: LD_ADDR_VAR 0 6
19175: PUSH
19176: LD_EXP 66
19180: PUSH
19181: LD_INT 1
19183: ARRAY
19184: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19185: LD_VAR 0 6
19189: PPUSH
19190: CALL_OW 274
19194: PPUSH
19195: CALL 93476 0 1
19199: PUSH
19200: LD_INT 3
19202: ARRAY
19203: PUSH
19204: LD_EXP 61
19208: PUSH
19209: LD_INT 1
19211: ARRAY
19212: LESS
19213: IFFALSE 19227
// begin HintSpec ( ArtifactCost , 2 ) ;
19215: LD_STRING ArtifactCost
19217: PPUSH
19218: LD_INT 2
19220: PPUSH
19221: CALL_OW 338
// exit ;
19225: GO 19817
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19227: LD_ADDR_EXP 68
19231: PUSH
19232: LD_EXP 68
19236: PPUSH
19237: LD_INT 1
19239: PPUSH
19240: LD_INT 0
19242: PPUSH
19243: CALL_OW 1
19247: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19248: LD_VAR 0 3
19252: PPUSH
19253: LD_VAR 0 4
19257: PPUSH
19258: LD_INT 7
19260: PPUSH
19261: LD_INT 12
19263: NEG
19264: PPUSH
19265: CALL_OW 330
// wait ( 0 0$30 ) ;
19269: LD_INT 1050
19271: PPUSH
19272: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19276: LD_VAR 0 3
19280: PPUSH
19281: LD_VAR 0 4
19285: PPUSH
19286: LD_INT 7
19288: PPUSH
19289: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19293: LD_EXP 60
19297: PUSH
19298: LD_INT 1
19300: ARRAY
19301: PPUSH
19302: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19306: LD_ADDR_EXP 68
19310: PUSH
19311: LD_EXP 68
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: LD_INT 1
19321: PPUSH
19322: CALL_OW 1
19326: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19327: LD_VAR 0 2
19331: PUSH
19332: LD_EXP 67
19336: PUSH
19337: LD_INT 2
19339: ARRAY
19340: PUSH
19341: LD_INT 1
19343: ARRAY
19344: EQUAL
19345: IFFALSE 19571
// begin lab := artifactsLabs [ 2 ] ;
19347: LD_ADDR_VAR 0 6
19351: PUSH
19352: LD_EXP 66
19356: PUSH
19357: LD_INT 2
19359: ARRAY
19360: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19361: LD_VAR 0 3
19365: PUSH
19366: LD_INT 81
19368: PUSH
19369: LD_INT 7
19371: PUSH
19372: EMPTY
19373: LIST
19374: LIST
19375: PUSH
19376: LD_INT 2
19378: PUSH
19379: LD_INT 32
19381: PUSH
19382: LD_INT 3
19384: PUSH
19385: EMPTY
19386: LIST
19387: LIST
19388: PUSH
19389: LD_INT 30
19391: PUSH
19392: LD_INT 28
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: PUSH
19399: LD_INT 30
19401: PUSH
19402: LD_INT 30
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: PUSH
19409: LD_INT 35
19411: PUSH
19412: LD_INT 49
19414: PUSH
19415: EMPTY
19416: LIST
19417: LIST
19418: PUSH
19419: LD_INT 34
19421: PUSH
19422: LD_INT 49
19424: PUSH
19425: EMPTY
19426: LIST
19427: LIST
19428: PUSH
19429: EMPTY
19430: LIST
19431: LIST
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: PUSH
19437: EMPTY
19438: LIST
19439: LIST
19440: PPUSH
19441: CALL_OW 69
19445: IN
19446: NOT
19447: IFFALSE 19451
// exit ;
19449: GO 19817
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19451: LD_VAR 0 6
19455: PPUSH
19456: CALL_OW 274
19460: PPUSH
19461: CALL 93476 0 1
19465: PUSH
19466: LD_INT 3
19468: ARRAY
19469: PUSH
19470: LD_EXP 61
19474: PUSH
19475: LD_INT 2
19477: ARRAY
19478: LESS
19479: IFFALSE 19493
// begin HintSpec ( ArtifactCost , 2 ) ;
19481: LD_STRING ArtifactCost
19483: PPUSH
19484: LD_INT 2
19486: PPUSH
19487: CALL_OW 338
// exit ;
19491: GO 19817
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19493: LD_ADDR_EXP 68
19497: PUSH
19498: LD_EXP 68
19502: PPUSH
19503: LD_INT 2
19505: PPUSH
19506: LD_INT 0
19508: PPUSH
19509: CALL_OW 1
19513: ST_TO_ADDR
// KillUnit ( x ) ;
19514: LD_VAR 0 3
19518: PPUSH
19519: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19523: LD_ADDR_EXP 13
19527: PUSH
19528: LD_EXP 13
19532: PUSH
19533: LD_INT 1
19535: PLUS
19536: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19537: LD_EXP 60
19541: PUSH
19542: LD_INT 2
19544: ARRAY
19545: PPUSH
19546: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19550: LD_ADDR_EXP 68
19554: PUSH
19555: LD_EXP 68
19559: PPUSH
19560: LD_INT 2
19562: PPUSH
19563: LD_INT 1
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19571: LD_VAR 0 2
19575: PUSH
19576: LD_EXP 67
19580: PUSH
19581: LD_INT 3
19583: ARRAY
19584: PUSH
19585: LD_INT 1
19587: ARRAY
19588: EQUAL
19589: IFFALSE 19817
// begin lab := artifactsLabs [ 3 ] ;
19591: LD_ADDR_VAR 0 6
19595: PUSH
19596: LD_EXP 66
19600: PUSH
19601: LD_INT 3
19603: ARRAY
19604: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19605: LD_VAR 0 6
19609: PPUSH
19610: CALL_OW 274
19614: PPUSH
19615: CALL 93476 0 1
19619: PUSH
19620: LD_INT 3
19622: ARRAY
19623: PUSH
19624: LD_EXP 61
19628: PUSH
19629: LD_INT 3
19631: ARRAY
19632: LESS
19633: IFFALSE 19647
// begin HintSpec ( ArtifactCost , 2 ) ;
19635: LD_STRING ArtifactCost
19637: PPUSH
19638: LD_INT 2
19640: PPUSH
19641: CALL_OW 338
// exit ;
19645: GO 19817
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19647: LD_INT 37
19649: PPUSH
19650: LD_INT 1
19652: PPUSH
19653: CALL_OW 424
// time := 0 0$30 ;
19657: LD_ADDR_VAR 0 7
19661: PUSH
19662: LD_INT 1050
19664: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19665: LD_ADDR_OWVAR 47
19669: PUSH
19670: LD_STRING Am15a-1
19672: PUSH
19673: LD_VAR 0 7
19677: PUSH
19678: EMPTY
19679: LIST
19680: LIST
19681: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19682: LD_INT 35
19684: PPUSH
19685: CALL_OW 67
// time := time - 0 0$1 ;
19689: LD_ADDR_VAR 0 7
19693: PUSH
19694: LD_VAR 0 7
19698: PUSH
19699: LD_INT 35
19701: MINUS
19702: ST_TO_ADDR
// until time = 0 0$00 ;
19703: LD_VAR 0 7
19707: PUSH
19708: LD_INT 0
19710: EQUAL
19711: IFFALSE 19665
// display_strings :=  ;
19713: LD_ADDR_OWVAR 47
19717: PUSH
19718: LD_STRING 
19720: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19721: LD_INT 37
19723: PPUSH
19724: LD_INT 0
19726: PPUSH
19727: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19731: LD_ADDR_VAR 0 8
19735: PUSH
19736: LD_INT 37
19738: PPUSH
19739: LD_INT 3
19741: PUSH
19742: LD_INT 21
19744: PUSH
19745: LD_INT 3
19747: PUSH
19748: EMPTY
19749: LIST
19750: LIST
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PPUSH
19756: CALL_OW 70
19760: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19761: LD_VAR 0 3
19765: PPUSH
19766: LD_VAR 0 4
19770: PPUSH
19771: CALL_OW 84
// for un in list do
19775: LD_ADDR_VAR 0 9
19779: PUSH
19780: LD_VAR 0 8
19784: PUSH
19785: FOR_IN
19786: IFFALSE 19815
// TeleportUnit ( un , x , y , 12 , true ) ;
19788: LD_VAR 0 9
19792: PPUSH
19793: LD_VAR 0 3
19797: PPUSH
19798: LD_VAR 0 4
19802: PPUSH
19803: LD_INT 12
19805: PPUSH
19806: LD_INT 1
19808: PPUSH
19809: CALL_OW 483
19813: GO 19785
19815: POP
19816: POP
// end ; end ;
19817: PPOPN 9
19819: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19820: LD_INT 0
19822: PPUSH
19823: PPUSH
// begin labNum := 0 ;
19824: LD_ADDR_VAR 0 4
19828: PUSH
19829: LD_INT 0
19831: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19832: LD_ADDR_VAR 0 3
19836: PUSH
19837: DOUBLE
19838: LD_INT 1
19840: DEC
19841: ST_TO_ADDR
19842: LD_EXP 66
19846: PUSH
19847: FOR_TO
19848: IFFALSE 19882
// if artifactsLabs [ i ] = lab then
19850: LD_EXP 66
19854: PUSH
19855: LD_VAR 0 3
19859: ARRAY
19860: PUSH
19861: LD_VAR 0 1
19865: EQUAL
19866: IFFALSE 19880
// begin labNum := i ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: LD_VAR 0 3
19877: ST_TO_ADDR
// break ;
19878: GO 19882
// end ;
19880: GO 19847
19882: POP
19883: POP
// if not labNum then
19884: LD_VAR 0 4
19888: NOT
19889: IFFALSE 19893
// exit ;
19891: GO 19971
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19893: LD_INT 7
19895: PPUSH
19896: LD_EXP 67
19900: PUSH
19901: LD_VAR 0 4
19905: ARRAY
19906: PUSH
19907: LD_INT 3
19909: ARRAY
19910: PPUSH
19911: LD_INT 2
19913: PPUSH
19914: LD_VAR 0 1
19918: PPUSH
19919: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19923: LD_ADDR_EXP 65
19927: PUSH
19928: LD_EXP 65
19932: PPUSH
19933: LD_VAR 0 4
19937: PPUSH
19938: LD_VAR 0 2
19942: PPUSH
19943: CALL_OW 1
19947: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19948: LD_ADDR_EXP 63
19952: PUSH
19953: LD_EXP 63
19957: PPUSH
19958: LD_VAR 0 4
19962: PPUSH
19963: LD_INT 0
19965: PPUSH
19966: CALL_OW 1
19970: ST_TO_ADDR
// end ;
19971: PPOPN 4
19973: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19974: LD_INT 0
19976: PPUSH
19977: PPUSH
// begin labNum := 0 ;
19978: LD_ADDR_VAR 0 3
19982: PUSH
19983: LD_INT 0
19985: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19986: LD_ADDR_VAR 0 2
19990: PUSH
19991: DOUBLE
19992: LD_INT 1
19994: DEC
19995: ST_TO_ADDR
19996: LD_EXP 66
20000: PUSH
20001: FOR_TO
20002: IFFALSE 20036
// if artifactsLabs [ i ] = lab then
20004: LD_EXP 66
20008: PUSH
20009: LD_VAR 0 2
20013: ARRAY
20014: PUSH
20015: LD_VAR 0 1
20019: EQUAL
20020: IFFALSE 20034
// begin labNum := i ;
20022: LD_ADDR_VAR 0 3
20026: PUSH
20027: LD_VAR 0 2
20031: ST_TO_ADDR
// break ;
20032: GO 20036
// end ;
20034: GO 20001
20036: POP
20037: POP
// if not labNum then
20038: LD_VAR 0 3
20042: NOT
20043: IFFALSE 20047
// exit ;
20045: GO 20209
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20047: LD_INT 7
20049: PPUSH
20050: LD_EXP 67
20054: PUSH
20055: LD_VAR 0 3
20059: ARRAY
20060: PUSH
20061: LD_INT 3
20063: ARRAY
20064: PPUSH
20065: LD_INT 0
20067: PPUSH
20068: LD_VAR 0 1
20072: PPUSH
20073: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20077: LD_ADDR_EXP 62
20081: PUSH
20082: LD_EXP 62
20086: PPUSH
20087: LD_VAR 0 3
20091: PPUSH
20092: LD_INT 1
20094: PPUSH
20095: CALL_OW 1
20099: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20100: LD_ADDR_EXP 68
20104: PUSH
20105: LD_EXP 68
20109: PPUSH
20110: LD_VAR 0 3
20114: PPUSH
20115: LD_INT 1
20117: PPUSH
20118: CALL_OW 1
20122: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20123: LD_ADDR_EXP 63
20127: PUSH
20128: LD_EXP 63
20132: PPUSH
20133: LD_VAR 0 3
20137: PPUSH
20138: LD_INT 0
20140: PPUSH
20141: CALL_OW 1
20145: ST_TO_ADDR
// case labNum of 1 :
20146: LD_VAR 0 3
20150: PUSH
20151: LD_INT 1
20153: DOUBLE
20154: EQUAL
20155: IFTRUE 20159
20157: GO 20170
20159: POP
// artifactIResearched := true ; 2 :
20160: LD_ADDR_EXP 9
20164: PUSH
20165: LD_INT 1
20167: ST_TO_ADDR
20168: GO 20209
20170: LD_INT 2
20172: DOUBLE
20173: EQUAL
20174: IFTRUE 20178
20176: GO 20189
20178: POP
// artifactIIResearched := true ; 3 :
20179: LD_ADDR_EXP 10
20183: PUSH
20184: LD_INT 1
20186: ST_TO_ADDR
20187: GO 20209
20189: LD_INT 3
20191: DOUBLE
20192: EQUAL
20193: IFTRUE 20197
20195: GO 20208
20197: POP
// artifactIIIResearched := true ; end ;
20198: LD_ADDR_EXP 11
20202: PUSH
20203: LD_INT 1
20205: ST_TO_ADDR
20206: GO 20209
20208: POP
// end ; end_of_file
20209: PPOPN 3
20211: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20212: GO 20214
20214: DISABLE
// begin ru_radar := 98 ;
20215: LD_ADDR_EXP 69
20219: PUSH
20220: LD_INT 98
20222: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20223: LD_ADDR_EXP 70
20227: PUSH
20228: LD_INT 89
20230: ST_TO_ADDR
// us_hack := 99 ;
20231: LD_ADDR_EXP 71
20235: PUSH
20236: LD_INT 99
20238: ST_TO_ADDR
// us_artillery := 97 ;
20239: LD_ADDR_EXP 72
20243: PUSH
20244: LD_INT 97
20246: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20247: LD_ADDR_EXP 73
20251: PUSH
20252: LD_INT 91
20254: ST_TO_ADDR
// end ; end_of_file
20255: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20256: LD_INT 0
20258: PPUSH
20259: PPUSH
// skirmish := false ;
20260: LD_ADDR_EXP 74
20264: PUSH
20265: LD_INT 0
20267: ST_TO_ADDR
// debug_mc := false ;
20268: LD_ADDR_EXP 75
20272: PUSH
20273: LD_INT 0
20275: ST_TO_ADDR
// mc_bases := [ ] ;
20276: LD_ADDR_EXP 76
20280: PUSH
20281: EMPTY
20282: ST_TO_ADDR
// mc_sides := [ ] ;
20283: LD_ADDR_EXP 102
20287: PUSH
20288: EMPTY
20289: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20290: LD_ADDR_EXP 77
20294: PUSH
20295: EMPTY
20296: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20297: LD_ADDR_EXP 78
20301: PUSH
20302: EMPTY
20303: ST_TO_ADDR
// mc_need_heal := [ ] ;
20304: LD_ADDR_EXP 79
20308: PUSH
20309: EMPTY
20310: ST_TO_ADDR
// mc_healers := [ ] ;
20311: LD_ADDR_EXP 80
20315: PUSH
20316: EMPTY
20317: ST_TO_ADDR
// mc_build_list := [ ] ;
20318: LD_ADDR_EXP 81
20322: PUSH
20323: EMPTY
20324: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20325: LD_ADDR_EXP 108
20329: PUSH
20330: EMPTY
20331: ST_TO_ADDR
// mc_builders := [ ] ;
20332: LD_ADDR_EXP 82
20336: PUSH
20337: EMPTY
20338: ST_TO_ADDR
// mc_construct_list := [ ] ;
20339: LD_ADDR_EXP 83
20343: PUSH
20344: EMPTY
20345: ST_TO_ADDR
// mc_turret_list := [ ] ;
20346: LD_ADDR_EXP 84
20350: PUSH
20351: EMPTY
20352: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20353: LD_ADDR_EXP 85
20357: PUSH
20358: EMPTY
20359: ST_TO_ADDR
// mc_miners := [ ] ;
20360: LD_ADDR_EXP 90
20364: PUSH
20365: EMPTY
20366: ST_TO_ADDR
// mc_mines := [ ] ;
20367: LD_ADDR_EXP 89
20371: PUSH
20372: EMPTY
20373: ST_TO_ADDR
// mc_minefields := [ ] ;
20374: LD_ADDR_EXP 91
20378: PUSH
20379: EMPTY
20380: ST_TO_ADDR
// mc_crates := [ ] ;
20381: LD_ADDR_EXP 92
20385: PUSH
20386: EMPTY
20387: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20388: LD_ADDR_EXP 93
20392: PUSH
20393: EMPTY
20394: ST_TO_ADDR
// mc_crates_area := [ ] ;
20395: LD_ADDR_EXP 94
20399: PUSH
20400: EMPTY
20401: ST_TO_ADDR
// mc_vehicles := [ ] ;
20402: LD_ADDR_EXP 95
20406: PUSH
20407: EMPTY
20408: ST_TO_ADDR
// mc_attack := [ ] ;
20409: LD_ADDR_EXP 96
20413: PUSH
20414: EMPTY
20415: ST_TO_ADDR
// mc_produce := [ ] ;
20416: LD_ADDR_EXP 97
20420: PUSH
20421: EMPTY
20422: ST_TO_ADDR
// mc_defender := [ ] ;
20423: LD_ADDR_EXP 98
20427: PUSH
20428: EMPTY
20429: ST_TO_ADDR
// mc_parking := [ ] ;
20430: LD_ADDR_EXP 100
20434: PUSH
20435: EMPTY
20436: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20437: LD_ADDR_EXP 86
20441: PUSH
20442: EMPTY
20443: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20444: LD_ADDR_EXP 88
20448: PUSH
20449: EMPTY
20450: ST_TO_ADDR
// mc_scan := [ ] ;
20451: LD_ADDR_EXP 99
20455: PUSH
20456: EMPTY
20457: ST_TO_ADDR
// mc_scan_area := [ ] ;
20458: LD_ADDR_EXP 101
20462: PUSH
20463: EMPTY
20464: ST_TO_ADDR
// mc_tech := [ ] ;
20465: LD_ADDR_EXP 103
20469: PUSH
20470: EMPTY
20471: ST_TO_ADDR
// mc_class := [ ] ;
20472: LD_ADDR_EXP 117
20476: PUSH
20477: EMPTY
20478: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20479: LD_ADDR_EXP 118
20483: PUSH
20484: EMPTY
20485: ST_TO_ADDR
// end ;
20486: LD_VAR 0 1
20490: RET
// export function MC_Kill ( base ) ; begin
20491: LD_INT 0
20493: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20494: LD_ADDR_EXP 76
20498: PUSH
20499: LD_EXP 76
20503: PPUSH
20504: LD_VAR 0 1
20508: PPUSH
20509: EMPTY
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20516: LD_ADDR_EXP 77
20520: PUSH
20521: LD_EXP 77
20525: PPUSH
20526: LD_VAR 0 1
20530: PPUSH
20531: EMPTY
20532: PPUSH
20533: CALL_OW 1
20537: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20538: LD_ADDR_EXP 78
20542: PUSH
20543: LD_EXP 78
20547: PPUSH
20548: LD_VAR 0 1
20552: PPUSH
20553: EMPTY
20554: PPUSH
20555: CALL_OW 1
20559: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20560: LD_ADDR_EXP 79
20564: PUSH
20565: LD_EXP 79
20569: PPUSH
20570: LD_VAR 0 1
20574: PPUSH
20575: EMPTY
20576: PPUSH
20577: CALL_OW 1
20581: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20582: LD_ADDR_EXP 80
20586: PUSH
20587: LD_EXP 80
20591: PPUSH
20592: LD_VAR 0 1
20596: PPUSH
20597: EMPTY
20598: PPUSH
20599: CALL_OW 1
20603: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20604: LD_ADDR_EXP 81
20608: PUSH
20609: LD_EXP 81
20613: PPUSH
20614: LD_VAR 0 1
20618: PPUSH
20619: EMPTY
20620: PPUSH
20621: CALL_OW 1
20625: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20626: LD_ADDR_EXP 82
20630: PUSH
20631: LD_EXP 82
20635: PPUSH
20636: LD_VAR 0 1
20640: PPUSH
20641: EMPTY
20642: PPUSH
20643: CALL_OW 1
20647: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20648: LD_ADDR_EXP 83
20652: PUSH
20653: LD_EXP 83
20657: PPUSH
20658: LD_VAR 0 1
20662: PPUSH
20663: EMPTY
20664: PPUSH
20665: CALL_OW 1
20669: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20670: LD_ADDR_EXP 84
20674: PUSH
20675: LD_EXP 84
20679: PPUSH
20680: LD_VAR 0 1
20684: PPUSH
20685: EMPTY
20686: PPUSH
20687: CALL_OW 1
20691: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20692: LD_ADDR_EXP 85
20696: PUSH
20697: LD_EXP 85
20701: PPUSH
20702: LD_VAR 0 1
20706: PPUSH
20707: EMPTY
20708: PPUSH
20709: CALL_OW 1
20713: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20714: LD_ADDR_EXP 86
20718: PUSH
20719: LD_EXP 86
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: EMPTY
20730: PPUSH
20731: CALL_OW 1
20735: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20736: LD_ADDR_EXP 87
20740: PUSH
20741: LD_EXP 87
20745: PPUSH
20746: LD_VAR 0 1
20750: PPUSH
20751: LD_INT 0
20753: PPUSH
20754: CALL_OW 1
20758: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20759: LD_ADDR_EXP 88
20763: PUSH
20764: LD_EXP 88
20768: PPUSH
20769: LD_VAR 0 1
20773: PPUSH
20774: EMPTY
20775: PPUSH
20776: CALL_OW 1
20780: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20781: LD_ADDR_EXP 89
20785: PUSH
20786: LD_EXP 89
20790: PPUSH
20791: LD_VAR 0 1
20795: PPUSH
20796: EMPTY
20797: PPUSH
20798: CALL_OW 1
20802: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20803: LD_ADDR_EXP 90
20807: PUSH
20808: LD_EXP 90
20812: PPUSH
20813: LD_VAR 0 1
20817: PPUSH
20818: EMPTY
20819: PPUSH
20820: CALL_OW 1
20824: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20825: LD_ADDR_EXP 91
20829: PUSH
20830: LD_EXP 91
20834: PPUSH
20835: LD_VAR 0 1
20839: PPUSH
20840: EMPTY
20841: PPUSH
20842: CALL_OW 1
20846: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20847: LD_ADDR_EXP 92
20851: PUSH
20852: LD_EXP 92
20856: PPUSH
20857: LD_VAR 0 1
20861: PPUSH
20862: EMPTY
20863: PPUSH
20864: CALL_OW 1
20868: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20869: LD_ADDR_EXP 93
20873: PUSH
20874: LD_EXP 93
20878: PPUSH
20879: LD_VAR 0 1
20883: PPUSH
20884: EMPTY
20885: PPUSH
20886: CALL_OW 1
20890: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20891: LD_ADDR_EXP 94
20895: PUSH
20896: LD_EXP 94
20900: PPUSH
20901: LD_VAR 0 1
20905: PPUSH
20906: EMPTY
20907: PPUSH
20908: CALL_OW 1
20912: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20913: LD_ADDR_EXP 95
20917: PUSH
20918: LD_EXP 95
20922: PPUSH
20923: LD_VAR 0 1
20927: PPUSH
20928: EMPTY
20929: PPUSH
20930: CALL_OW 1
20934: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20935: LD_ADDR_EXP 96
20939: PUSH
20940: LD_EXP 96
20944: PPUSH
20945: LD_VAR 0 1
20949: PPUSH
20950: EMPTY
20951: PPUSH
20952: CALL_OW 1
20956: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20957: LD_ADDR_EXP 97
20961: PUSH
20962: LD_EXP 97
20966: PPUSH
20967: LD_VAR 0 1
20971: PPUSH
20972: EMPTY
20973: PPUSH
20974: CALL_OW 1
20978: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20979: LD_ADDR_EXP 98
20983: PUSH
20984: LD_EXP 98
20988: PPUSH
20989: LD_VAR 0 1
20993: PPUSH
20994: EMPTY
20995: PPUSH
20996: CALL_OW 1
21000: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21001: LD_ADDR_EXP 99
21005: PUSH
21006: LD_EXP 99
21010: PPUSH
21011: LD_VAR 0 1
21015: PPUSH
21016: EMPTY
21017: PPUSH
21018: CALL_OW 1
21022: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21023: LD_ADDR_EXP 100
21027: PUSH
21028: LD_EXP 100
21032: PPUSH
21033: LD_VAR 0 1
21037: PPUSH
21038: EMPTY
21039: PPUSH
21040: CALL_OW 1
21044: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21045: LD_ADDR_EXP 101
21049: PUSH
21050: LD_EXP 101
21054: PPUSH
21055: LD_VAR 0 1
21059: PPUSH
21060: EMPTY
21061: PPUSH
21062: CALL_OW 1
21066: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21067: LD_ADDR_EXP 103
21071: PUSH
21072: LD_EXP 103
21076: PPUSH
21077: LD_VAR 0 1
21081: PPUSH
21082: EMPTY
21083: PPUSH
21084: CALL_OW 1
21088: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21089: LD_ADDR_EXP 105
21093: PUSH
21094: LD_EXP 105
21098: PPUSH
21099: LD_VAR 0 1
21103: PPUSH
21104: EMPTY
21105: PPUSH
21106: CALL_OW 1
21110: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21111: LD_ADDR_EXP 106
21115: PUSH
21116: LD_EXP 106
21120: PPUSH
21121: LD_VAR 0 1
21125: PPUSH
21126: EMPTY
21127: PPUSH
21128: CALL_OW 1
21132: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21133: LD_ADDR_EXP 107
21137: PUSH
21138: LD_EXP 107
21142: PPUSH
21143: LD_VAR 0 1
21147: PPUSH
21148: EMPTY
21149: PPUSH
21150: CALL_OW 1
21154: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21155: LD_ADDR_EXP 108
21159: PUSH
21160: LD_EXP 108
21164: PPUSH
21165: LD_VAR 0 1
21169: PPUSH
21170: EMPTY
21171: PPUSH
21172: CALL_OW 1
21176: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21177: LD_ADDR_EXP 109
21181: PUSH
21182: LD_EXP 109
21186: PPUSH
21187: LD_VAR 0 1
21191: PPUSH
21192: EMPTY
21193: PPUSH
21194: CALL_OW 1
21198: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21199: LD_ADDR_EXP 110
21203: PUSH
21204: LD_EXP 110
21208: PPUSH
21209: LD_VAR 0 1
21213: PPUSH
21214: EMPTY
21215: PPUSH
21216: CALL_OW 1
21220: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21221: LD_ADDR_EXP 111
21225: PUSH
21226: LD_EXP 111
21230: PPUSH
21231: LD_VAR 0 1
21235: PPUSH
21236: EMPTY
21237: PPUSH
21238: CALL_OW 1
21242: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21243: LD_ADDR_EXP 112
21247: PUSH
21248: LD_EXP 112
21252: PPUSH
21253: LD_VAR 0 1
21257: PPUSH
21258: EMPTY
21259: PPUSH
21260: CALL_OW 1
21264: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21265: LD_ADDR_EXP 113
21269: PUSH
21270: LD_EXP 113
21274: PPUSH
21275: LD_VAR 0 1
21279: PPUSH
21280: EMPTY
21281: PPUSH
21282: CALL_OW 1
21286: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21287: LD_ADDR_EXP 114
21291: PUSH
21292: LD_EXP 114
21296: PPUSH
21297: LD_VAR 0 1
21301: PPUSH
21302: EMPTY
21303: PPUSH
21304: CALL_OW 1
21308: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21309: LD_ADDR_EXP 115
21313: PUSH
21314: LD_EXP 115
21318: PPUSH
21319: LD_VAR 0 1
21323: PPUSH
21324: EMPTY
21325: PPUSH
21326: CALL_OW 1
21330: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21331: LD_ADDR_EXP 116
21335: PUSH
21336: LD_EXP 116
21340: PPUSH
21341: LD_VAR 0 1
21345: PPUSH
21346: EMPTY
21347: PPUSH
21348: CALL_OW 1
21352: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21353: LD_ADDR_EXP 117
21357: PUSH
21358: LD_EXP 117
21362: PPUSH
21363: LD_VAR 0 1
21367: PPUSH
21368: EMPTY
21369: PPUSH
21370: CALL_OW 1
21374: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21375: LD_ADDR_EXP 118
21379: PUSH
21380: LD_EXP 118
21384: PPUSH
21385: LD_VAR 0 1
21389: PPUSH
21390: LD_INT 0
21392: PPUSH
21393: CALL_OW 1
21397: ST_TO_ADDR
// end ;
21398: LD_VAR 0 2
21402: RET
// export function MC_Add ( side , units ) ; var base ; begin
21403: LD_INT 0
21405: PPUSH
21406: PPUSH
// base := mc_bases + 1 ;
21407: LD_ADDR_VAR 0 4
21411: PUSH
21412: LD_EXP 76
21416: PUSH
21417: LD_INT 1
21419: PLUS
21420: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21421: LD_ADDR_EXP 102
21425: PUSH
21426: LD_EXP 102
21430: PPUSH
21431: LD_VAR 0 4
21435: PPUSH
21436: LD_VAR 0 1
21440: PPUSH
21441: CALL_OW 1
21445: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21446: LD_ADDR_EXP 76
21450: PUSH
21451: LD_EXP 76
21455: PPUSH
21456: LD_VAR 0 4
21460: PPUSH
21461: LD_VAR 0 2
21465: PPUSH
21466: CALL_OW 1
21470: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21471: LD_ADDR_EXP 77
21475: PUSH
21476: LD_EXP 77
21480: PPUSH
21481: LD_VAR 0 4
21485: PPUSH
21486: EMPTY
21487: PPUSH
21488: CALL_OW 1
21492: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21493: LD_ADDR_EXP 78
21497: PUSH
21498: LD_EXP 78
21502: PPUSH
21503: LD_VAR 0 4
21507: PPUSH
21508: EMPTY
21509: PPUSH
21510: CALL_OW 1
21514: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21515: LD_ADDR_EXP 79
21519: PUSH
21520: LD_EXP 79
21524: PPUSH
21525: LD_VAR 0 4
21529: PPUSH
21530: EMPTY
21531: PPUSH
21532: CALL_OW 1
21536: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21537: LD_ADDR_EXP 80
21541: PUSH
21542: LD_EXP 80
21546: PPUSH
21547: LD_VAR 0 4
21551: PPUSH
21552: EMPTY
21553: PPUSH
21554: CALL_OW 1
21558: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21559: LD_ADDR_EXP 81
21563: PUSH
21564: LD_EXP 81
21568: PPUSH
21569: LD_VAR 0 4
21573: PPUSH
21574: EMPTY
21575: PPUSH
21576: CALL_OW 1
21580: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21581: LD_ADDR_EXP 82
21585: PUSH
21586: LD_EXP 82
21590: PPUSH
21591: LD_VAR 0 4
21595: PPUSH
21596: EMPTY
21597: PPUSH
21598: CALL_OW 1
21602: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21603: LD_ADDR_EXP 83
21607: PUSH
21608: LD_EXP 83
21612: PPUSH
21613: LD_VAR 0 4
21617: PPUSH
21618: EMPTY
21619: PPUSH
21620: CALL_OW 1
21624: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21625: LD_ADDR_EXP 84
21629: PUSH
21630: LD_EXP 84
21634: PPUSH
21635: LD_VAR 0 4
21639: PPUSH
21640: EMPTY
21641: PPUSH
21642: CALL_OW 1
21646: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21647: LD_ADDR_EXP 85
21651: PUSH
21652: LD_EXP 85
21656: PPUSH
21657: LD_VAR 0 4
21661: PPUSH
21662: EMPTY
21663: PPUSH
21664: CALL_OW 1
21668: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21669: LD_ADDR_EXP 86
21673: PUSH
21674: LD_EXP 86
21678: PPUSH
21679: LD_VAR 0 4
21683: PPUSH
21684: EMPTY
21685: PPUSH
21686: CALL_OW 1
21690: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21691: LD_ADDR_EXP 87
21695: PUSH
21696: LD_EXP 87
21700: PPUSH
21701: LD_VAR 0 4
21705: PPUSH
21706: LD_INT 0
21708: PPUSH
21709: CALL_OW 1
21713: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21714: LD_ADDR_EXP 88
21718: PUSH
21719: LD_EXP 88
21723: PPUSH
21724: LD_VAR 0 4
21728: PPUSH
21729: EMPTY
21730: PPUSH
21731: CALL_OW 1
21735: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21736: LD_ADDR_EXP 89
21740: PUSH
21741: LD_EXP 89
21745: PPUSH
21746: LD_VAR 0 4
21750: PPUSH
21751: EMPTY
21752: PPUSH
21753: CALL_OW 1
21757: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21758: LD_ADDR_EXP 90
21762: PUSH
21763: LD_EXP 90
21767: PPUSH
21768: LD_VAR 0 4
21772: PPUSH
21773: EMPTY
21774: PPUSH
21775: CALL_OW 1
21779: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21780: LD_ADDR_EXP 91
21784: PUSH
21785: LD_EXP 91
21789: PPUSH
21790: LD_VAR 0 4
21794: PPUSH
21795: EMPTY
21796: PPUSH
21797: CALL_OW 1
21801: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21802: LD_ADDR_EXP 92
21806: PUSH
21807: LD_EXP 92
21811: PPUSH
21812: LD_VAR 0 4
21816: PPUSH
21817: EMPTY
21818: PPUSH
21819: CALL_OW 1
21823: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21824: LD_ADDR_EXP 93
21828: PUSH
21829: LD_EXP 93
21833: PPUSH
21834: LD_VAR 0 4
21838: PPUSH
21839: EMPTY
21840: PPUSH
21841: CALL_OW 1
21845: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21846: LD_ADDR_EXP 94
21850: PUSH
21851: LD_EXP 94
21855: PPUSH
21856: LD_VAR 0 4
21860: PPUSH
21861: EMPTY
21862: PPUSH
21863: CALL_OW 1
21867: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21868: LD_ADDR_EXP 95
21872: PUSH
21873: LD_EXP 95
21877: PPUSH
21878: LD_VAR 0 4
21882: PPUSH
21883: EMPTY
21884: PPUSH
21885: CALL_OW 1
21889: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21890: LD_ADDR_EXP 96
21894: PUSH
21895: LD_EXP 96
21899: PPUSH
21900: LD_VAR 0 4
21904: PPUSH
21905: EMPTY
21906: PPUSH
21907: CALL_OW 1
21911: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21912: LD_ADDR_EXP 97
21916: PUSH
21917: LD_EXP 97
21921: PPUSH
21922: LD_VAR 0 4
21926: PPUSH
21927: EMPTY
21928: PPUSH
21929: CALL_OW 1
21933: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21934: LD_ADDR_EXP 98
21938: PUSH
21939: LD_EXP 98
21943: PPUSH
21944: LD_VAR 0 4
21948: PPUSH
21949: EMPTY
21950: PPUSH
21951: CALL_OW 1
21955: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21956: LD_ADDR_EXP 99
21960: PUSH
21961: LD_EXP 99
21965: PPUSH
21966: LD_VAR 0 4
21970: PPUSH
21971: EMPTY
21972: PPUSH
21973: CALL_OW 1
21977: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21978: LD_ADDR_EXP 100
21982: PUSH
21983: LD_EXP 100
21987: PPUSH
21988: LD_VAR 0 4
21992: PPUSH
21993: EMPTY
21994: PPUSH
21995: CALL_OW 1
21999: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22000: LD_ADDR_EXP 101
22004: PUSH
22005: LD_EXP 101
22009: PPUSH
22010: LD_VAR 0 4
22014: PPUSH
22015: EMPTY
22016: PPUSH
22017: CALL_OW 1
22021: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22022: LD_ADDR_EXP 103
22026: PUSH
22027: LD_EXP 103
22031: PPUSH
22032: LD_VAR 0 4
22036: PPUSH
22037: EMPTY
22038: PPUSH
22039: CALL_OW 1
22043: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22044: LD_ADDR_EXP 105
22048: PUSH
22049: LD_EXP 105
22053: PPUSH
22054: LD_VAR 0 4
22058: PPUSH
22059: EMPTY
22060: PPUSH
22061: CALL_OW 1
22065: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22066: LD_ADDR_EXP 106
22070: PUSH
22071: LD_EXP 106
22075: PPUSH
22076: LD_VAR 0 4
22080: PPUSH
22081: EMPTY
22082: PPUSH
22083: CALL_OW 1
22087: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22088: LD_ADDR_EXP 107
22092: PUSH
22093: LD_EXP 107
22097: PPUSH
22098: LD_VAR 0 4
22102: PPUSH
22103: EMPTY
22104: PPUSH
22105: CALL_OW 1
22109: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22110: LD_ADDR_EXP 108
22114: PUSH
22115: LD_EXP 108
22119: PPUSH
22120: LD_VAR 0 4
22124: PPUSH
22125: EMPTY
22126: PPUSH
22127: CALL_OW 1
22131: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22132: LD_ADDR_EXP 109
22136: PUSH
22137: LD_EXP 109
22141: PPUSH
22142: LD_VAR 0 4
22146: PPUSH
22147: EMPTY
22148: PPUSH
22149: CALL_OW 1
22153: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22154: LD_ADDR_EXP 110
22158: PUSH
22159: LD_EXP 110
22163: PPUSH
22164: LD_VAR 0 4
22168: PPUSH
22169: EMPTY
22170: PPUSH
22171: CALL_OW 1
22175: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22176: LD_ADDR_EXP 111
22180: PUSH
22181: LD_EXP 111
22185: PPUSH
22186: LD_VAR 0 4
22190: PPUSH
22191: EMPTY
22192: PPUSH
22193: CALL_OW 1
22197: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22198: LD_ADDR_EXP 112
22202: PUSH
22203: LD_EXP 112
22207: PPUSH
22208: LD_VAR 0 4
22212: PPUSH
22213: EMPTY
22214: PPUSH
22215: CALL_OW 1
22219: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22220: LD_ADDR_EXP 113
22224: PUSH
22225: LD_EXP 113
22229: PPUSH
22230: LD_VAR 0 4
22234: PPUSH
22235: EMPTY
22236: PPUSH
22237: CALL_OW 1
22241: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22242: LD_ADDR_EXP 114
22246: PUSH
22247: LD_EXP 114
22251: PPUSH
22252: LD_VAR 0 4
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL_OW 1
22263: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22264: LD_ADDR_EXP 115
22268: PUSH
22269: LD_EXP 115
22273: PPUSH
22274: LD_VAR 0 4
22278: PPUSH
22279: EMPTY
22280: PPUSH
22281: CALL_OW 1
22285: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22286: LD_ADDR_EXP 116
22290: PUSH
22291: LD_EXP 116
22295: PPUSH
22296: LD_VAR 0 4
22300: PPUSH
22301: EMPTY
22302: PPUSH
22303: CALL_OW 1
22307: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22308: LD_ADDR_EXP 117
22312: PUSH
22313: LD_EXP 117
22317: PPUSH
22318: LD_VAR 0 4
22322: PPUSH
22323: EMPTY
22324: PPUSH
22325: CALL_OW 1
22329: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22330: LD_ADDR_EXP 118
22334: PUSH
22335: LD_EXP 118
22339: PPUSH
22340: LD_VAR 0 4
22344: PPUSH
22345: LD_INT 0
22347: PPUSH
22348: CALL_OW 1
22352: ST_TO_ADDR
// result := base ;
22353: LD_ADDR_VAR 0 3
22357: PUSH
22358: LD_VAR 0 4
22362: ST_TO_ADDR
// end ;
22363: LD_VAR 0 3
22367: RET
// export function MC_Start ( ) ; var i ; begin
22368: LD_INT 0
22370: PPUSH
22371: PPUSH
// for i = 1 to mc_bases do
22372: LD_ADDR_VAR 0 2
22376: PUSH
22377: DOUBLE
22378: LD_INT 1
22380: DEC
22381: ST_TO_ADDR
22382: LD_EXP 76
22386: PUSH
22387: FOR_TO
22388: IFFALSE 23465
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22390: LD_ADDR_EXP 76
22394: PUSH
22395: LD_EXP 76
22399: PPUSH
22400: LD_VAR 0 2
22404: PPUSH
22405: LD_EXP 76
22409: PUSH
22410: LD_VAR 0 2
22414: ARRAY
22415: PUSH
22416: LD_INT 0
22418: DIFF
22419: PPUSH
22420: CALL_OW 1
22424: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22425: LD_ADDR_EXP 77
22429: PUSH
22430: LD_EXP 77
22434: PPUSH
22435: LD_VAR 0 2
22439: PPUSH
22440: EMPTY
22441: PPUSH
22442: CALL_OW 1
22446: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22447: LD_ADDR_EXP 78
22451: PUSH
22452: LD_EXP 78
22456: PPUSH
22457: LD_VAR 0 2
22461: PPUSH
22462: EMPTY
22463: PPUSH
22464: CALL_OW 1
22468: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22469: LD_ADDR_EXP 79
22473: PUSH
22474: LD_EXP 79
22478: PPUSH
22479: LD_VAR 0 2
22483: PPUSH
22484: EMPTY
22485: PPUSH
22486: CALL_OW 1
22490: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22491: LD_ADDR_EXP 80
22495: PUSH
22496: LD_EXP 80
22500: PPUSH
22501: LD_VAR 0 2
22505: PPUSH
22506: EMPTY
22507: PUSH
22508: EMPTY
22509: PUSH
22510: EMPTY
22511: LIST
22512: LIST
22513: PPUSH
22514: CALL_OW 1
22518: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22519: LD_ADDR_EXP 81
22523: PUSH
22524: LD_EXP 81
22528: PPUSH
22529: LD_VAR 0 2
22533: PPUSH
22534: EMPTY
22535: PPUSH
22536: CALL_OW 1
22540: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22541: LD_ADDR_EXP 108
22545: PUSH
22546: LD_EXP 108
22550: PPUSH
22551: LD_VAR 0 2
22555: PPUSH
22556: EMPTY
22557: PPUSH
22558: CALL_OW 1
22562: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22563: LD_ADDR_EXP 82
22567: PUSH
22568: LD_EXP 82
22572: PPUSH
22573: LD_VAR 0 2
22577: PPUSH
22578: EMPTY
22579: PPUSH
22580: CALL_OW 1
22584: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22585: LD_ADDR_EXP 83
22589: PUSH
22590: LD_EXP 83
22594: PPUSH
22595: LD_VAR 0 2
22599: PPUSH
22600: EMPTY
22601: PPUSH
22602: CALL_OW 1
22606: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22607: LD_ADDR_EXP 84
22611: PUSH
22612: LD_EXP 84
22616: PPUSH
22617: LD_VAR 0 2
22621: PPUSH
22622: LD_EXP 76
22626: PUSH
22627: LD_VAR 0 2
22631: ARRAY
22632: PPUSH
22633: LD_INT 2
22635: PUSH
22636: LD_INT 30
22638: PUSH
22639: LD_INT 32
22641: PUSH
22642: EMPTY
22643: LIST
22644: LIST
22645: PUSH
22646: LD_INT 30
22648: PUSH
22649: LD_INT 33
22651: PUSH
22652: EMPTY
22653: LIST
22654: LIST
22655: PUSH
22656: EMPTY
22657: LIST
22658: LIST
22659: LIST
22660: PPUSH
22661: CALL_OW 72
22665: PPUSH
22666: CALL_OW 1
22670: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22671: LD_ADDR_EXP 85
22675: PUSH
22676: LD_EXP 85
22680: PPUSH
22681: LD_VAR 0 2
22685: PPUSH
22686: LD_EXP 76
22690: PUSH
22691: LD_VAR 0 2
22695: ARRAY
22696: PPUSH
22697: LD_INT 2
22699: PUSH
22700: LD_INT 30
22702: PUSH
22703: LD_INT 32
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PUSH
22710: LD_INT 30
22712: PUSH
22713: LD_INT 31
22715: PUSH
22716: EMPTY
22717: LIST
22718: LIST
22719: PUSH
22720: EMPTY
22721: LIST
22722: LIST
22723: LIST
22724: PUSH
22725: LD_INT 58
22727: PUSH
22728: EMPTY
22729: LIST
22730: PUSH
22731: EMPTY
22732: LIST
22733: LIST
22734: PPUSH
22735: CALL_OW 72
22739: PPUSH
22740: CALL_OW 1
22744: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22745: LD_ADDR_EXP 86
22749: PUSH
22750: LD_EXP 86
22754: PPUSH
22755: LD_VAR 0 2
22759: PPUSH
22760: EMPTY
22761: PPUSH
22762: CALL_OW 1
22766: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22767: LD_ADDR_EXP 90
22771: PUSH
22772: LD_EXP 90
22776: PPUSH
22777: LD_VAR 0 2
22781: PPUSH
22782: EMPTY
22783: PPUSH
22784: CALL_OW 1
22788: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22789: LD_ADDR_EXP 89
22793: PUSH
22794: LD_EXP 89
22798: PPUSH
22799: LD_VAR 0 2
22803: PPUSH
22804: EMPTY
22805: PPUSH
22806: CALL_OW 1
22810: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22811: LD_ADDR_EXP 91
22815: PUSH
22816: LD_EXP 91
22820: PPUSH
22821: LD_VAR 0 2
22825: PPUSH
22826: EMPTY
22827: PPUSH
22828: CALL_OW 1
22832: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22833: LD_ADDR_EXP 92
22837: PUSH
22838: LD_EXP 92
22842: PPUSH
22843: LD_VAR 0 2
22847: PPUSH
22848: EMPTY
22849: PPUSH
22850: CALL_OW 1
22854: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22855: LD_ADDR_EXP 93
22859: PUSH
22860: LD_EXP 93
22864: PPUSH
22865: LD_VAR 0 2
22869: PPUSH
22870: EMPTY
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22877: LD_ADDR_EXP 94
22881: PUSH
22882: LD_EXP 94
22886: PPUSH
22887: LD_VAR 0 2
22891: PPUSH
22892: EMPTY
22893: PPUSH
22894: CALL_OW 1
22898: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22899: LD_ADDR_EXP 95
22903: PUSH
22904: LD_EXP 95
22908: PPUSH
22909: LD_VAR 0 2
22913: PPUSH
22914: EMPTY
22915: PPUSH
22916: CALL_OW 1
22920: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22921: LD_ADDR_EXP 96
22925: PUSH
22926: LD_EXP 96
22930: PPUSH
22931: LD_VAR 0 2
22935: PPUSH
22936: EMPTY
22937: PPUSH
22938: CALL_OW 1
22942: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22943: LD_ADDR_EXP 97
22947: PUSH
22948: LD_EXP 97
22952: PPUSH
22953: LD_VAR 0 2
22957: PPUSH
22958: EMPTY
22959: PPUSH
22960: CALL_OW 1
22964: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22965: LD_ADDR_EXP 98
22969: PUSH
22970: LD_EXP 98
22974: PPUSH
22975: LD_VAR 0 2
22979: PPUSH
22980: EMPTY
22981: PPUSH
22982: CALL_OW 1
22986: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22987: LD_ADDR_EXP 87
22991: PUSH
22992: LD_EXP 87
22996: PPUSH
22997: LD_VAR 0 2
23001: PPUSH
23002: LD_INT 0
23004: PPUSH
23005: CALL_OW 1
23009: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23010: LD_ADDR_EXP 100
23014: PUSH
23015: LD_EXP 100
23019: PPUSH
23020: LD_VAR 0 2
23024: PPUSH
23025: LD_INT 0
23027: PPUSH
23028: CALL_OW 1
23032: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23033: LD_ADDR_EXP 88
23037: PUSH
23038: LD_EXP 88
23042: PPUSH
23043: LD_VAR 0 2
23047: PPUSH
23048: EMPTY
23049: PPUSH
23050: CALL_OW 1
23054: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23055: LD_ADDR_EXP 99
23059: PUSH
23060: LD_EXP 99
23064: PPUSH
23065: LD_VAR 0 2
23069: PPUSH
23070: LD_INT 0
23072: PPUSH
23073: CALL_OW 1
23077: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23078: LD_ADDR_EXP 101
23082: PUSH
23083: LD_EXP 101
23087: PPUSH
23088: LD_VAR 0 2
23092: PPUSH
23093: EMPTY
23094: PPUSH
23095: CALL_OW 1
23099: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23100: LD_ADDR_EXP 104
23104: PUSH
23105: LD_EXP 104
23109: PPUSH
23110: LD_VAR 0 2
23114: PPUSH
23115: LD_INT 0
23117: PPUSH
23118: CALL_OW 1
23122: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23123: LD_ADDR_EXP 105
23127: PUSH
23128: LD_EXP 105
23132: PPUSH
23133: LD_VAR 0 2
23137: PPUSH
23138: EMPTY
23139: PPUSH
23140: CALL_OW 1
23144: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23145: LD_ADDR_EXP 106
23149: PUSH
23150: LD_EXP 106
23154: PPUSH
23155: LD_VAR 0 2
23159: PPUSH
23160: EMPTY
23161: PPUSH
23162: CALL_OW 1
23166: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23167: LD_ADDR_EXP 107
23171: PUSH
23172: LD_EXP 107
23176: PPUSH
23177: LD_VAR 0 2
23181: PPUSH
23182: EMPTY
23183: PPUSH
23184: CALL_OW 1
23188: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23189: LD_ADDR_EXP 109
23193: PUSH
23194: LD_EXP 109
23198: PPUSH
23199: LD_VAR 0 2
23203: PPUSH
23204: LD_EXP 76
23208: PUSH
23209: LD_VAR 0 2
23213: ARRAY
23214: PPUSH
23215: LD_INT 2
23217: PUSH
23218: LD_INT 30
23220: PUSH
23221: LD_INT 6
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: PUSH
23228: LD_INT 30
23230: PUSH
23231: LD_INT 7
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: PUSH
23238: LD_INT 30
23240: PUSH
23241: LD_INT 8
23243: PUSH
23244: EMPTY
23245: LIST
23246: LIST
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: LIST
23252: LIST
23253: PPUSH
23254: CALL_OW 72
23258: PPUSH
23259: CALL_OW 1
23263: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23264: LD_ADDR_EXP 110
23268: PUSH
23269: LD_EXP 110
23273: PPUSH
23274: LD_VAR 0 2
23278: PPUSH
23279: EMPTY
23280: PPUSH
23281: CALL_OW 1
23285: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23286: LD_ADDR_EXP 111
23290: PUSH
23291: LD_EXP 111
23295: PPUSH
23296: LD_VAR 0 2
23300: PPUSH
23301: EMPTY
23302: PPUSH
23303: CALL_OW 1
23307: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23308: LD_ADDR_EXP 112
23312: PUSH
23313: LD_EXP 112
23317: PPUSH
23318: LD_VAR 0 2
23322: PPUSH
23323: EMPTY
23324: PPUSH
23325: CALL_OW 1
23329: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23330: LD_ADDR_EXP 113
23334: PUSH
23335: LD_EXP 113
23339: PPUSH
23340: LD_VAR 0 2
23344: PPUSH
23345: EMPTY
23346: PPUSH
23347: CALL_OW 1
23351: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23352: LD_ADDR_EXP 114
23356: PUSH
23357: LD_EXP 114
23361: PPUSH
23362: LD_VAR 0 2
23366: PPUSH
23367: EMPTY
23368: PPUSH
23369: CALL_OW 1
23373: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23374: LD_ADDR_EXP 115
23378: PUSH
23379: LD_EXP 115
23383: PPUSH
23384: LD_VAR 0 2
23388: PPUSH
23389: EMPTY
23390: PPUSH
23391: CALL_OW 1
23395: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23396: LD_ADDR_EXP 116
23400: PUSH
23401: LD_EXP 116
23405: PPUSH
23406: LD_VAR 0 2
23410: PPUSH
23411: EMPTY
23412: PPUSH
23413: CALL_OW 1
23417: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23418: LD_ADDR_EXP 117
23422: PUSH
23423: LD_EXP 117
23427: PPUSH
23428: LD_VAR 0 2
23432: PPUSH
23433: EMPTY
23434: PPUSH
23435: CALL_OW 1
23439: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23440: LD_ADDR_EXP 118
23444: PUSH
23445: LD_EXP 118
23449: PPUSH
23450: LD_VAR 0 2
23454: PPUSH
23455: LD_INT 0
23457: PPUSH
23458: CALL_OW 1
23462: ST_TO_ADDR
// end ;
23463: GO 22387
23465: POP
23466: POP
// MC_InitSides ( ) ;
23467: CALL 23753 0 0
// MC_InitResearch ( ) ;
23471: CALL 23492 0 0
// CustomInitMacro ( ) ;
23475: CALL 189 0 0
// skirmish := true ;
23479: LD_ADDR_EXP 74
23483: PUSH
23484: LD_INT 1
23486: ST_TO_ADDR
// end ;
23487: LD_VAR 0 1
23491: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23492: LD_INT 0
23494: PPUSH
23495: PPUSH
23496: PPUSH
23497: PPUSH
23498: PPUSH
23499: PPUSH
// if not mc_bases then
23500: LD_EXP 76
23504: NOT
23505: IFFALSE 23509
// exit ;
23507: GO 23748
// for i = 1 to 8 do
23509: LD_ADDR_VAR 0 2
23513: PUSH
23514: DOUBLE
23515: LD_INT 1
23517: DEC
23518: ST_TO_ADDR
23519: LD_INT 8
23521: PUSH
23522: FOR_TO
23523: IFFALSE 23549
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23525: LD_ADDR_EXP 103
23529: PUSH
23530: LD_EXP 103
23534: PPUSH
23535: LD_VAR 0 2
23539: PPUSH
23540: EMPTY
23541: PPUSH
23542: CALL_OW 1
23546: ST_TO_ADDR
23547: GO 23522
23549: POP
23550: POP
// tmp := [ ] ;
23551: LD_ADDR_VAR 0 5
23555: PUSH
23556: EMPTY
23557: ST_TO_ADDR
// for i = 1 to mc_sides do
23558: LD_ADDR_VAR 0 2
23562: PUSH
23563: DOUBLE
23564: LD_INT 1
23566: DEC
23567: ST_TO_ADDR
23568: LD_EXP 102
23572: PUSH
23573: FOR_TO
23574: IFFALSE 23632
// if not mc_sides [ i ] in tmp then
23576: LD_EXP 102
23580: PUSH
23581: LD_VAR 0 2
23585: ARRAY
23586: PUSH
23587: LD_VAR 0 5
23591: IN
23592: NOT
23593: IFFALSE 23630
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23595: LD_ADDR_VAR 0 5
23599: PUSH
23600: LD_VAR 0 5
23604: PPUSH
23605: LD_VAR 0 5
23609: PUSH
23610: LD_INT 1
23612: PLUS
23613: PPUSH
23614: LD_EXP 102
23618: PUSH
23619: LD_VAR 0 2
23623: ARRAY
23624: PPUSH
23625: CALL_OW 2
23629: ST_TO_ADDR
23630: GO 23573
23632: POP
23633: POP
// if not tmp then
23634: LD_VAR 0 5
23638: NOT
23639: IFFALSE 23643
// exit ;
23641: GO 23748
// for j in tmp do
23643: LD_ADDR_VAR 0 3
23647: PUSH
23648: LD_VAR 0 5
23652: PUSH
23653: FOR_IN
23654: IFFALSE 23746
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23656: LD_ADDR_VAR 0 6
23660: PUSH
23661: LD_INT 22
23663: PUSH
23664: LD_VAR 0 3
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: PPUSH
23673: CALL_OW 69
23677: ST_TO_ADDR
// if not un then
23678: LD_VAR 0 6
23682: NOT
23683: IFFALSE 23687
// continue ;
23685: GO 23653
// nation := GetNation ( un [ 1 ] ) ;
23687: LD_ADDR_VAR 0 4
23691: PUSH
23692: LD_VAR 0 6
23696: PUSH
23697: LD_INT 1
23699: ARRAY
23700: PPUSH
23701: CALL_OW 248
23705: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23706: LD_ADDR_EXP 103
23710: PUSH
23711: LD_EXP 103
23715: PPUSH
23716: LD_VAR 0 3
23720: PPUSH
23721: LD_VAR 0 3
23725: PPUSH
23726: LD_VAR 0 4
23730: PPUSH
23731: LD_INT 1
23733: PPUSH
23734: CALL 50462 0 3
23738: PPUSH
23739: CALL_OW 1
23743: ST_TO_ADDR
// end ;
23744: GO 23653
23746: POP
23747: POP
// end ;
23748: LD_VAR 0 1
23752: RET
// export function MC_InitSides ( ) ; var i ; begin
23753: LD_INT 0
23755: PPUSH
23756: PPUSH
// if not mc_bases then
23757: LD_EXP 76
23761: NOT
23762: IFFALSE 23766
// exit ;
23764: GO 23840
// for i = 1 to mc_bases do
23766: LD_ADDR_VAR 0 2
23770: PUSH
23771: DOUBLE
23772: LD_INT 1
23774: DEC
23775: ST_TO_ADDR
23776: LD_EXP 76
23780: PUSH
23781: FOR_TO
23782: IFFALSE 23838
// if mc_bases [ i ] then
23784: LD_EXP 76
23788: PUSH
23789: LD_VAR 0 2
23793: ARRAY
23794: IFFALSE 23836
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23796: LD_ADDR_EXP 102
23800: PUSH
23801: LD_EXP 102
23805: PPUSH
23806: LD_VAR 0 2
23810: PPUSH
23811: LD_EXP 76
23815: PUSH
23816: LD_VAR 0 2
23820: ARRAY
23821: PUSH
23822: LD_INT 1
23824: ARRAY
23825: PPUSH
23826: CALL_OW 255
23830: PPUSH
23831: CALL_OW 1
23835: ST_TO_ADDR
23836: GO 23781
23838: POP
23839: POP
// end ;
23840: LD_VAR 0 1
23844: RET
// every 0 0$01 trigger skirmish do
23845: LD_EXP 74
23849: IFFALSE 24003
23851: GO 23853
23853: DISABLE
// begin enable ;
23854: ENABLE
// MC_CheckBuildings ( ) ;
23855: CALL 28501 0 0
// MC_CheckPeopleLife ( ) ;
23859: CALL 28626 0 0
// RaiseSailEvent ( 100 ) ;
23863: LD_INT 100
23865: PPUSH
23866: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23870: LD_INT 103
23872: PPUSH
23873: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23877: LD_INT 104
23879: PPUSH
23880: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23884: LD_INT 105
23886: PPUSH
23887: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23891: LD_INT 106
23893: PPUSH
23894: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23898: LD_INT 107
23900: PPUSH
23901: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23905: LD_INT 108
23907: PPUSH
23908: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23912: LD_INT 109
23914: PPUSH
23915: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23919: LD_INT 110
23921: PPUSH
23922: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23926: LD_INT 111
23928: PPUSH
23929: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23933: LD_INT 112
23935: PPUSH
23936: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23940: LD_INT 113
23942: PPUSH
23943: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23947: LD_INT 120
23949: PPUSH
23950: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23954: LD_INT 121
23956: PPUSH
23957: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23961: LD_INT 122
23963: PPUSH
23964: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23968: LD_INT 123
23970: PPUSH
23971: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23975: LD_INT 124
23977: PPUSH
23978: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23982: LD_INT 125
23984: PPUSH
23985: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23989: LD_INT 126
23991: PPUSH
23992: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23996: LD_INT 200
23998: PPUSH
23999: CALL_OW 427
// end ;
24003: END
// on SailEvent ( event ) do begin if event < 100 then
24004: LD_VAR 0 1
24008: PUSH
24009: LD_INT 100
24011: LESS
24012: IFFALSE 24023
// CustomEvent ( event ) ;
24014: LD_VAR 0 1
24018: PPUSH
24019: CALL 10232 0 1
// if event = 100 then
24023: LD_VAR 0 1
24027: PUSH
24028: LD_INT 100
24030: EQUAL
24031: IFFALSE 24037
// MC_ClassManager ( ) ;
24033: CALL 24429 0 0
// if event = 101 then
24037: LD_VAR 0 1
24041: PUSH
24042: LD_INT 101
24044: EQUAL
24045: IFFALSE 24051
// MC_RepairBuildings ( ) ;
24047: CALL 29222 0 0
// if event = 102 then
24051: LD_VAR 0 1
24055: PUSH
24056: LD_INT 102
24058: EQUAL
24059: IFFALSE 24065
// MC_Heal ( ) ;
24061: CALL 29954 0 0
// if event = 103 then
24065: LD_VAR 0 1
24069: PUSH
24070: LD_INT 103
24072: EQUAL
24073: IFFALSE 24079
// MC_Build ( ) ;
24075: CALL 30376 0 0
// if event = 104 then
24079: LD_VAR 0 1
24083: PUSH
24084: LD_INT 104
24086: EQUAL
24087: IFFALSE 24093
// MC_TurretWeapon ( ) ;
24089: CALL 31989 0 0
// if event = 105 then
24093: LD_VAR 0 1
24097: PUSH
24098: LD_INT 105
24100: EQUAL
24101: IFFALSE 24107
// MC_BuildUpgrade ( ) ;
24103: CALL 31540 0 0
// if event = 106 then
24107: LD_VAR 0 1
24111: PUSH
24112: LD_INT 106
24114: EQUAL
24115: IFFALSE 24121
// MC_PlantMines ( ) ;
24117: CALL 32419 0 0
// if event = 107 then
24121: LD_VAR 0 1
24125: PUSH
24126: LD_INT 107
24128: EQUAL
24129: IFFALSE 24135
// MC_CollectCrates ( ) ;
24131: CALL 33453 0 0
// if event = 108 then
24135: LD_VAR 0 1
24139: PUSH
24140: LD_INT 108
24142: EQUAL
24143: IFFALSE 24149
// MC_LinkRemoteControl ( ) ;
24145: CALL 35229 0 0
// if event = 109 then
24149: LD_VAR 0 1
24153: PUSH
24154: LD_INT 109
24156: EQUAL
24157: IFFALSE 24163
// MC_ProduceVehicle ( ) ;
24159: CALL 35410 0 0
// if event = 110 then
24163: LD_VAR 0 1
24167: PUSH
24168: LD_INT 110
24170: EQUAL
24171: IFFALSE 24177
// MC_SendAttack ( ) ;
24173: CALL 35876 0 0
// if event = 111 then
24177: LD_VAR 0 1
24181: PUSH
24182: LD_INT 111
24184: EQUAL
24185: IFFALSE 24191
// MC_Defend ( ) ;
24187: CALL 35984 0 0
// if event = 112 then
24191: LD_VAR 0 1
24195: PUSH
24196: LD_INT 112
24198: EQUAL
24199: IFFALSE 24205
// MC_Research ( ) ;
24201: CALL 36589 0 0
// if event = 113 then
24205: LD_VAR 0 1
24209: PUSH
24210: LD_INT 113
24212: EQUAL
24213: IFFALSE 24219
// MC_MinesTrigger ( ) ;
24215: CALL 37703 0 0
// if event = 120 then
24219: LD_VAR 0 1
24223: PUSH
24224: LD_INT 120
24226: EQUAL
24227: IFFALSE 24233
// MC_RepairVehicle ( ) ;
24229: CALL 37802 0 0
// if event = 121 then
24233: LD_VAR 0 1
24237: PUSH
24238: LD_INT 121
24240: EQUAL
24241: IFFALSE 24247
// MC_TameApe ( ) ;
24243: CALL 38532 0 0
// if event = 122 then
24247: LD_VAR 0 1
24251: PUSH
24252: LD_INT 122
24254: EQUAL
24255: IFFALSE 24261
// MC_ChangeApeClass ( ) ;
24257: CALL 39361 0 0
// if event = 123 then
24261: LD_VAR 0 1
24265: PUSH
24266: LD_INT 123
24268: EQUAL
24269: IFFALSE 24275
// MC_Bazooka ( ) ;
24271: CALL 40011 0 0
// if event = 124 then
24275: LD_VAR 0 1
24279: PUSH
24280: LD_INT 124
24282: EQUAL
24283: IFFALSE 24289
// MC_TeleportExit ( ) ;
24285: CALL 40209 0 0
// if event = 125 then
24289: LD_VAR 0 1
24293: PUSH
24294: LD_INT 125
24296: EQUAL
24297: IFFALSE 24303
// MC_Deposits ( ) ;
24299: CALL 40856 0 0
// if event = 126 then
24303: LD_VAR 0 1
24307: PUSH
24308: LD_INT 126
24310: EQUAL
24311: IFFALSE 24317
// MC_RemoteDriver ( ) ;
24313: CALL 41481 0 0
// if event = 200 then
24317: LD_VAR 0 1
24321: PUSH
24322: LD_INT 200
24324: EQUAL
24325: IFFALSE 24331
// MC_Idle ( ) ;
24327: CALL 43430 0 0
// end ;
24331: PPOPN 1
24333: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24334: LD_INT 0
24336: PPUSH
24337: PPUSH
// if not mc_bases [ base ] or not tag then
24338: LD_EXP 76
24342: PUSH
24343: LD_VAR 0 1
24347: ARRAY
24348: NOT
24349: PUSH
24350: LD_VAR 0 2
24354: NOT
24355: OR
24356: IFFALSE 24360
// exit ;
24358: GO 24424
// for i in mc_bases [ base ] union mc_ape [ base ] do
24360: LD_ADDR_VAR 0 4
24364: PUSH
24365: LD_EXP 76
24369: PUSH
24370: LD_VAR 0 1
24374: ARRAY
24375: PUSH
24376: LD_EXP 105
24380: PUSH
24381: LD_VAR 0 1
24385: ARRAY
24386: UNION
24387: PUSH
24388: FOR_IN
24389: IFFALSE 24422
// if GetTag ( i ) = tag then
24391: LD_VAR 0 4
24395: PPUSH
24396: CALL_OW 110
24400: PUSH
24401: LD_VAR 0 2
24405: EQUAL
24406: IFFALSE 24420
// SetTag ( i , 0 ) ;
24408: LD_VAR 0 4
24412: PPUSH
24413: LD_INT 0
24415: PPUSH
24416: CALL_OW 109
24420: GO 24388
24422: POP
24423: POP
// end ;
24424: LD_VAR 0 3
24428: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24429: LD_INT 0
24431: PPUSH
24432: PPUSH
24433: PPUSH
24434: PPUSH
24435: PPUSH
24436: PPUSH
24437: PPUSH
24438: PPUSH
// if not mc_bases then
24439: LD_EXP 76
24443: NOT
24444: IFFALSE 24448
// exit ;
24446: GO 24906
// for i = 1 to mc_bases do
24448: LD_ADDR_VAR 0 2
24452: PUSH
24453: DOUBLE
24454: LD_INT 1
24456: DEC
24457: ST_TO_ADDR
24458: LD_EXP 76
24462: PUSH
24463: FOR_TO
24464: IFFALSE 24904
// begin tmp := MC_ClassCheckReq ( i ) ;
24466: LD_ADDR_VAR 0 4
24470: PUSH
24471: LD_VAR 0 2
24475: PPUSH
24476: CALL 24911 0 1
24480: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24481: LD_ADDR_EXP 117
24485: PUSH
24486: LD_EXP 117
24490: PPUSH
24491: LD_VAR 0 2
24495: PPUSH
24496: LD_VAR 0 4
24500: PPUSH
24501: CALL_OW 1
24505: ST_TO_ADDR
// if not tmp then
24506: LD_VAR 0 4
24510: NOT
24511: IFFALSE 24515
// continue ;
24513: GO 24463
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24515: LD_ADDR_VAR 0 6
24519: PUSH
24520: LD_EXP 76
24524: PUSH
24525: LD_VAR 0 2
24529: ARRAY
24530: PPUSH
24531: LD_INT 2
24533: PUSH
24534: LD_INT 30
24536: PUSH
24537: LD_INT 4
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: PUSH
24544: LD_INT 30
24546: PUSH
24547: LD_INT 5
24549: PUSH
24550: EMPTY
24551: LIST
24552: LIST
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: LIST
24558: PPUSH
24559: CALL_OW 72
24563: PUSH
24564: LD_EXP 76
24568: PUSH
24569: LD_VAR 0 2
24573: ARRAY
24574: PPUSH
24575: LD_INT 2
24577: PUSH
24578: LD_INT 30
24580: PUSH
24581: LD_INT 0
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: PUSH
24588: LD_INT 30
24590: PUSH
24591: LD_INT 1
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: LIST
24602: PPUSH
24603: CALL_OW 72
24607: PUSH
24608: LD_EXP 76
24612: PUSH
24613: LD_VAR 0 2
24617: ARRAY
24618: PPUSH
24619: LD_INT 30
24621: PUSH
24622: LD_INT 3
24624: PUSH
24625: EMPTY
24626: LIST
24627: LIST
24628: PPUSH
24629: CALL_OW 72
24633: PUSH
24634: LD_EXP 76
24638: PUSH
24639: LD_VAR 0 2
24643: ARRAY
24644: PPUSH
24645: LD_INT 2
24647: PUSH
24648: LD_INT 30
24650: PUSH
24651: LD_INT 6
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: PUSH
24658: LD_INT 30
24660: PUSH
24661: LD_INT 7
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: PUSH
24668: LD_INT 30
24670: PUSH
24671: LD_INT 8
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: PUSH
24678: EMPTY
24679: LIST
24680: LIST
24681: LIST
24682: LIST
24683: PPUSH
24684: CALL_OW 72
24688: PUSH
24689: EMPTY
24690: LIST
24691: LIST
24692: LIST
24693: LIST
24694: ST_TO_ADDR
// for j = 1 to 4 do
24695: LD_ADDR_VAR 0 3
24699: PUSH
24700: DOUBLE
24701: LD_INT 1
24703: DEC
24704: ST_TO_ADDR
24705: LD_INT 4
24707: PUSH
24708: FOR_TO
24709: IFFALSE 24900
// begin if not tmp [ j ] then
24711: LD_VAR 0 4
24715: PUSH
24716: LD_VAR 0 3
24720: ARRAY
24721: NOT
24722: IFFALSE 24726
// continue ;
24724: GO 24708
// for p in tmp [ j ] do
24726: LD_ADDR_VAR 0 5
24730: PUSH
24731: LD_VAR 0 4
24735: PUSH
24736: LD_VAR 0 3
24740: ARRAY
24741: PUSH
24742: FOR_IN
24743: IFFALSE 24896
// begin if not b [ j ] then
24745: LD_VAR 0 6
24749: PUSH
24750: LD_VAR 0 3
24754: ARRAY
24755: NOT
24756: IFFALSE 24760
// break ;
24758: GO 24896
// e := 0 ;
24760: LD_ADDR_VAR 0 7
24764: PUSH
24765: LD_INT 0
24767: ST_TO_ADDR
// for k in b [ j ] do
24768: LD_ADDR_VAR 0 8
24772: PUSH
24773: LD_VAR 0 6
24777: PUSH
24778: LD_VAR 0 3
24782: ARRAY
24783: PUSH
24784: FOR_IN
24785: IFFALSE 24812
// if IsNotFull ( k ) then
24787: LD_VAR 0 8
24791: PPUSH
24792: CALL 54902 0 1
24796: IFFALSE 24810
// begin e := k ;
24798: LD_ADDR_VAR 0 7
24802: PUSH
24803: LD_VAR 0 8
24807: ST_TO_ADDR
// break ;
24808: GO 24812
// end ;
24810: GO 24784
24812: POP
24813: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24814: LD_VAR 0 7
24818: PUSH
24819: LD_VAR 0 5
24823: PPUSH
24824: LD_VAR 0 7
24828: PPUSH
24829: CALL 92021 0 2
24833: NOT
24834: AND
24835: IFFALSE 24894
// begin if IsInUnit ( p ) then
24837: LD_VAR 0 5
24841: PPUSH
24842: CALL_OW 310
24846: IFFALSE 24857
// ComExitBuilding ( p ) ;
24848: LD_VAR 0 5
24852: PPUSH
24853: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24857: LD_VAR 0 5
24861: PPUSH
24862: LD_VAR 0 7
24866: PPUSH
24867: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24871: LD_VAR 0 5
24875: PPUSH
24876: LD_VAR 0 3
24880: PPUSH
24881: CALL_OW 183
// AddComExitBuilding ( p ) ;
24885: LD_VAR 0 5
24889: PPUSH
24890: CALL_OW 182
// end ; end ;
24894: GO 24742
24896: POP
24897: POP
// end ;
24898: GO 24708
24900: POP
24901: POP
// end ;
24902: GO 24463
24904: POP
24905: POP
// end ;
24906: LD_VAR 0 1
24910: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24911: LD_INT 0
24913: PPUSH
24914: PPUSH
24915: PPUSH
24916: PPUSH
24917: PPUSH
24918: PPUSH
24919: PPUSH
24920: PPUSH
24921: PPUSH
24922: PPUSH
24923: PPUSH
24924: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24925: LD_VAR 0 1
24929: NOT
24930: PUSH
24931: LD_EXP 76
24935: PUSH
24936: LD_VAR 0 1
24940: ARRAY
24941: NOT
24942: OR
24943: PUSH
24944: LD_EXP 76
24948: PUSH
24949: LD_VAR 0 1
24953: ARRAY
24954: PPUSH
24955: LD_INT 2
24957: PUSH
24958: LD_INT 30
24960: PUSH
24961: LD_INT 0
24963: PUSH
24964: EMPTY
24965: LIST
24966: LIST
24967: PUSH
24968: LD_INT 30
24970: PUSH
24971: LD_INT 1
24973: PUSH
24974: EMPTY
24975: LIST
24976: LIST
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: LIST
24982: PPUSH
24983: CALL_OW 72
24987: NOT
24988: OR
24989: IFFALSE 24993
// exit ;
24991: GO 28496
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24993: LD_ADDR_VAR 0 4
24997: PUSH
24998: LD_EXP 76
25002: PUSH
25003: LD_VAR 0 1
25007: ARRAY
25008: PPUSH
25009: LD_INT 2
25011: PUSH
25012: LD_INT 25
25014: PUSH
25015: LD_INT 1
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PUSH
25022: LD_INT 25
25024: PUSH
25025: LD_INT 2
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: PUSH
25032: LD_INT 25
25034: PUSH
25035: LD_INT 3
25037: PUSH
25038: EMPTY
25039: LIST
25040: LIST
25041: PUSH
25042: LD_INT 25
25044: PUSH
25045: LD_INT 4
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: PUSH
25052: LD_INT 25
25054: PUSH
25055: LD_INT 5
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: PUSH
25062: LD_INT 25
25064: PUSH
25065: LD_INT 8
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PUSH
25072: LD_INT 25
25074: PUSH
25075: LD_INT 9
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: LIST
25086: LIST
25087: LIST
25088: LIST
25089: LIST
25090: LIST
25091: PPUSH
25092: CALL_OW 72
25096: ST_TO_ADDR
// if not tmp then
25097: LD_VAR 0 4
25101: NOT
25102: IFFALSE 25106
// exit ;
25104: GO 28496
// for i in tmp do
25106: LD_ADDR_VAR 0 3
25110: PUSH
25111: LD_VAR 0 4
25115: PUSH
25116: FOR_IN
25117: IFFALSE 25148
// if GetTag ( i ) then
25119: LD_VAR 0 3
25123: PPUSH
25124: CALL_OW 110
25128: IFFALSE 25146
// tmp := tmp diff i ;
25130: LD_ADDR_VAR 0 4
25134: PUSH
25135: LD_VAR 0 4
25139: PUSH
25140: LD_VAR 0 3
25144: DIFF
25145: ST_TO_ADDR
25146: GO 25116
25148: POP
25149: POP
// if not tmp then
25150: LD_VAR 0 4
25154: NOT
25155: IFFALSE 25159
// exit ;
25157: GO 28496
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25159: LD_ADDR_VAR 0 5
25163: PUSH
25164: LD_EXP 76
25168: PUSH
25169: LD_VAR 0 1
25173: ARRAY
25174: PPUSH
25175: LD_INT 2
25177: PUSH
25178: LD_INT 25
25180: PUSH
25181: LD_INT 1
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PUSH
25188: LD_INT 25
25190: PUSH
25191: LD_INT 5
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 25
25200: PUSH
25201: LD_INT 8
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 25
25210: PUSH
25211: LD_INT 9
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: LIST
25222: LIST
25223: LIST
25224: PPUSH
25225: CALL_OW 72
25229: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25230: LD_ADDR_VAR 0 6
25234: PUSH
25235: LD_EXP 76
25239: PUSH
25240: LD_VAR 0 1
25244: ARRAY
25245: PPUSH
25246: LD_INT 25
25248: PUSH
25249: LD_INT 2
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: PPUSH
25256: CALL_OW 72
25260: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25261: LD_ADDR_VAR 0 7
25265: PUSH
25266: LD_EXP 76
25270: PUSH
25271: LD_VAR 0 1
25275: ARRAY
25276: PPUSH
25277: LD_INT 25
25279: PUSH
25280: LD_INT 3
25282: PUSH
25283: EMPTY
25284: LIST
25285: LIST
25286: PPUSH
25287: CALL_OW 72
25291: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25292: LD_ADDR_VAR 0 8
25296: PUSH
25297: LD_EXP 76
25301: PUSH
25302: LD_VAR 0 1
25306: ARRAY
25307: PPUSH
25308: LD_INT 25
25310: PUSH
25311: LD_INT 4
25313: PUSH
25314: EMPTY
25315: LIST
25316: LIST
25317: PUSH
25318: LD_INT 24
25320: PUSH
25321: LD_INT 251
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: PPUSH
25332: CALL_OW 72
25336: ST_TO_ADDR
// if mc_scan [ base ] then
25337: LD_EXP 99
25341: PUSH
25342: LD_VAR 0 1
25346: ARRAY
25347: IFFALSE 25808
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25349: LD_ADDR_EXP 118
25353: PUSH
25354: LD_EXP 118
25358: PPUSH
25359: LD_VAR 0 1
25363: PPUSH
25364: LD_INT 4
25366: PPUSH
25367: CALL_OW 1
25371: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25372: LD_ADDR_VAR 0 12
25376: PUSH
25377: LD_EXP 76
25381: PUSH
25382: LD_VAR 0 1
25386: ARRAY
25387: PPUSH
25388: LD_INT 2
25390: PUSH
25391: LD_INT 30
25393: PUSH
25394: LD_INT 4
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: PUSH
25401: LD_INT 30
25403: PUSH
25404: LD_INT 5
25406: PUSH
25407: EMPTY
25408: LIST
25409: LIST
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: LIST
25415: PPUSH
25416: CALL_OW 72
25420: ST_TO_ADDR
// if not b then
25421: LD_VAR 0 12
25425: NOT
25426: IFFALSE 25430
// exit ;
25428: GO 28496
// p := [ ] ;
25430: LD_ADDR_VAR 0 11
25434: PUSH
25435: EMPTY
25436: ST_TO_ADDR
// if sci >= 2 then
25437: LD_VAR 0 8
25441: PUSH
25442: LD_INT 2
25444: GREATEREQUAL
25445: IFFALSE 25476
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25447: LD_ADDR_VAR 0 8
25451: PUSH
25452: LD_VAR 0 8
25456: PUSH
25457: LD_INT 1
25459: ARRAY
25460: PUSH
25461: LD_VAR 0 8
25465: PUSH
25466: LD_INT 2
25468: ARRAY
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: ST_TO_ADDR
25474: GO 25537
// if sci = 1 then
25476: LD_VAR 0 8
25480: PUSH
25481: LD_INT 1
25483: EQUAL
25484: IFFALSE 25505
// sci := [ sci [ 1 ] ] else
25486: LD_ADDR_VAR 0 8
25490: PUSH
25491: LD_VAR 0 8
25495: PUSH
25496: LD_INT 1
25498: ARRAY
25499: PUSH
25500: EMPTY
25501: LIST
25502: ST_TO_ADDR
25503: GO 25537
// if sci = 0 then
25505: LD_VAR 0 8
25509: PUSH
25510: LD_INT 0
25512: EQUAL
25513: IFFALSE 25537
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25515: LD_ADDR_VAR 0 11
25519: PUSH
25520: LD_VAR 0 4
25524: PPUSH
25525: LD_INT 4
25527: PPUSH
25528: CALL 91884 0 2
25532: PUSH
25533: LD_INT 1
25535: ARRAY
25536: ST_TO_ADDR
// if eng > 4 then
25537: LD_VAR 0 6
25541: PUSH
25542: LD_INT 4
25544: GREATER
25545: IFFALSE 25591
// for i = eng downto 4 do
25547: LD_ADDR_VAR 0 3
25551: PUSH
25552: DOUBLE
25553: LD_VAR 0 6
25557: INC
25558: ST_TO_ADDR
25559: LD_INT 4
25561: PUSH
25562: FOR_DOWNTO
25563: IFFALSE 25589
// eng := eng diff eng [ i ] ;
25565: LD_ADDR_VAR 0 6
25569: PUSH
25570: LD_VAR 0 6
25574: PUSH
25575: LD_VAR 0 6
25579: PUSH
25580: LD_VAR 0 3
25584: ARRAY
25585: DIFF
25586: ST_TO_ADDR
25587: GO 25562
25589: POP
25590: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25591: LD_ADDR_VAR 0 4
25595: PUSH
25596: LD_VAR 0 4
25600: PUSH
25601: LD_VAR 0 5
25605: PUSH
25606: LD_VAR 0 6
25610: UNION
25611: PUSH
25612: LD_VAR 0 7
25616: UNION
25617: PUSH
25618: LD_VAR 0 8
25622: UNION
25623: DIFF
25624: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25625: LD_ADDR_VAR 0 13
25629: PUSH
25630: LD_EXP 76
25634: PUSH
25635: LD_VAR 0 1
25639: ARRAY
25640: PPUSH
25641: LD_INT 2
25643: PUSH
25644: LD_INT 30
25646: PUSH
25647: LD_INT 32
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 30
25656: PUSH
25657: LD_INT 31
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: LIST
25668: PPUSH
25669: CALL_OW 72
25673: PUSH
25674: LD_EXP 76
25678: PUSH
25679: LD_VAR 0 1
25683: ARRAY
25684: PPUSH
25685: LD_INT 2
25687: PUSH
25688: LD_INT 30
25690: PUSH
25691: LD_INT 4
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 30
25700: PUSH
25701: LD_INT 5
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: EMPTY
25709: LIST
25710: LIST
25711: LIST
25712: PPUSH
25713: CALL_OW 72
25717: PUSH
25718: LD_INT 6
25720: MUL
25721: PLUS
25722: ST_TO_ADDR
// if bcount < tmp then
25723: LD_VAR 0 13
25727: PUSH
25728: LD_VAR 0 4
25732: LESS
25733: IFFALSE 25779
// for i = tmp downto bcount do
25735: LD_ADDR_VAR 0 3
25739: PUSH
25740: DOUBLE
25741: LD_VAR 0 4
25745: INC
25746: ST_TO_ADDR
25747: LD_VAR 0 13
25751: PUSH
25752: FOR_DOWNTO
25753: IFFALSE 25777
// tmp := Delete ( tmp , tmp ) ;
25755: LD_ADDR_VAR 0 4
25759: PUSH
25760: LD_VAR 0 4
25764: PPUSH
25765: LD_VAR 0 4
25769: PPUSH
25770: CALL_OW 3
25774: ST_TO_ADDR
25775: GO 25752
25777: POP
25778: POP
// result := [ tmp , 0 , 0 , p ] ;
25779: LD_ADDR_VAR 0 2
25783: PUSH
25784: LD_VAR 0 4
25788: PUSH
25789: LD_INT 0
25791: PUSH
25792: LD_INT 0
25794: PUSH
25795: LD_VAR 0 11
25799: PUSH
25800: EMPTY
25801: LIST
25802: LIST
25803: LIST
25804: LIST
25805: ST_TO_ADDR
// exit ;
25806: GO 28496
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25808: LD_EXP 76
25812: PUSH
25813: LD_VAR 0 1
25817: ARRAY
25818: PPUSH
25819: LD_INT 2
25821: PUSH
25822: LD_INT 30
25824: PUSH
25825: LD_INT 6
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PUSH
25832: LD_INT 30
25834: PUSH
25835: LD_INT 7
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: LD_INT 30
25844: PUSH
25845: LD_INT 8
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: PUSH
25852: EMPTY
25853: LIST
25854: LIST
25855: LIST
25856: LIST
25857: PPUSH
25858: CALL_OW 72
25862: NOT
25863: PUSH
25864: LD_EXP 76
25868: PUSH
25869: LD_VAR 0 1
25873: ARRAY
25874: PPUSH
25875: LD_INT 30
25877: PUSH
25878: LD_INT 3
25880: PUSH
25881: EMPTY
25882: LIST
25883: LIST
25884: PPUSH
25885: CALL_OW 72
25889: NOT
25890: AND
25891: IFFALSE 25963
// begin if eng = tmp then
25893: LD_VAR 0 6
25897: PUSH
25898: LD_VAR 0 4
25902: EQUAL
25903: IFFALSE 25907
// exit ;
25905: GO 28496
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25907: LD_ADDR_EXP 118
25911: PUSH
25912: LD_EXP 118
25916: PPUSH
25917: LD_VAR 0 1
25921: PPUSH
25922: LD_INT 1
25924: PPUSH
25925: CALL_OW 1
25929: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25930: LD_ADDR_VAR 0 2
25934: PUSH
25935: LD_INT 0
25937: PUSH
25938: LD_VAR 0 4
25942: PUSH
25943: LD_VAR 0 6
25947: DIFF
25948: PUSH
25949: LD_INT 0
25951: PUSH
25952: LD_INT 0
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: LIST
25959: LIST
25960: ST_TO_ADDR
// exit ;
25961: GO 28496
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25963: LD_EXP 103
25967: PUSH
25968: LD_EXP 102
25972: PUSH
25973: LD_VAR 0 1
25977: ARRAY
25978: ARRAY
25979: PUSH
25980: LD_EXP 76
25984: PUSH
25985: LD_VAR 0 1
25989: ARRAY
25990: PPUSH
25991: LD_INT 2
25993: PUSH
25994: LD_INT 30
25996: PUSH
25997: LD_INT 6
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 30
26006: PUSH
26007: LD_INT 7
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: PUSH
26014: LD_INT 30
26016: PUSH
26017: LD_INT 8
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: PUSH
26024: EMPTY
26025: LIST
26026: LIST
26027: LIST
26028: LIST
26029: PPUSH
26030: CALL_OW 72
26034: AND
26035: PUSH
26036: LD_EXP 76
26040: PUSH
26041: LD_VAR 0 1
26045: ARRAY
26046: PPUSH
26047: LD_INT 30
26049: PUSH
26050: LD_INT 3
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PPUSH
26057: CALL_OW 72
26061: NOT
26062: AND
26063: IFFALSE 26277
// begin if sci >= 6 then
26065: LD_VAR 0 8
26069: PUSH
26070: LD_INT 6
26072: GREATEREQUAL
26073: IFFALSE 26077
// exit ;
26075: GO 28496
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26077: LD_ADDR_EXP 118
26081: PUSH
26082: LD_EXP 118
26086: PPUSH
26087: LD_VAR 0 1
26091: PPUSH
26092: LD_INT 2
26094: PPUSH
26095: CALL_OW 1
26099: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26100: LD_ADDR_VAR 0 9
26104: PUSH
26105: LD_VAR 0 4
26109: PUSH
26110: LD_VAR 0 8
26114: DIFF
26115: PPUSH
26116: LD_INT 4
26118: PPUSH
26119: CALL 91884 0 2
26123: ST_TO_ADDR
// p := [ ] ;
26124: LD_ADDR_VAR 0 11
26128: PUSH
26129: EMPTY
26130: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26131: LD_VAR 0 8
26135: PUSH
26136: LD_INT 6
26138: LESS
26139: PUSH
26140: LD_VAR 0 9
26144: PUSH
26145: LD_INT 6
26147: GREATER
26148: AND
26149: IFFALSE 26230
// begin for i = 1 to 6 - sci do
26151: LD_ADDR_VAR 0 3
26155: PUSH
26156: DOUBLE
26157: LD_INT 1
26159: DEC
26160: ST_TO_ADDR
26161: LD_INT 6
26163: PUSH
26164: LD_VAR 0 8
26168: MINUS
26169: PUSH
26170: FOR_TO
26171: IFFALSE 26226
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26173: LD_ADDR_VAR 0 11
26177: PUSH
26178: LD_VAR 0 11
26182: PPUSH
26183: LD_VAR 0 11
26187: PUSH
26188: LD_INT 1
26190: PLUS
26191: PPUSH
26192: LD_VAR 0 9
26196: PUSH
26197: LD_INT 1
26199: ARRAY
26200: PPUSH
26201: CALL_OW 2
26205: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26206: LD_ADDR_VAR 0 9
26210: PUSH
26211: LD_VAR 0 9
26215: PPUSH
26216: LD_INT 1
26218: PPUSH
26219: CALL_OW 3
26223: ST_TO_ADDR
// end ;
26224: GO 26170
26226: POP
26227: POP
// end else
26228: GO 26250
// if sort then
26230: LD_VAR 0 9
26234: IFFALSE 26250
// p := sort [ 1 ] ;
26236: LD_ADDR_VAR 0 11
26240: PUSH
26241: LD_VAR 0 9
26245: PUSH
26246: LD_INT 1
26248: ARRAY
26249: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26250: LD_ADDR_VAR 0 2
26254: PUSH
26255: LD_INT 0
26257: PUSH
26258: LD_INT 0
26260: PUSH
26261: LD_INT 0
26263: PUSH
26264: LD_VAR 0 11
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: LIST
26273: LIST
26274: ST_TO_ADDR
// exit ;
26275: GO 28496
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26277: LD_EXP 103
26281: PUSH
26282: LD_EXP 102
26286: PUSH
26287: LD_VAR 0 1
26291: ARRAY
26292: ARRAY
26293: PUSH
26294: LD_EXP 76
26298: PUSH
26299: LD_VAR 0 1
26303: ARRAY
26304: PPUSH
26305: LD_INT 2
26307: PUSH
26308: LD_INT 30
26310: PUSH
26311: LD_INT 6
26313: PUSH
26314: EMPTY
26315: LIST
26316: LIST
26317: PUSH
26318: LD_INT 30
26320: PUSH
26321: LD_INT 7
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: LD_INT 30
26330: PUSH
26331: LD_INT 8
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: LIST
26342: LIST
26343: PPUSH
26344: CALL_OW 72
26348: AND
26349: PUSH
26350: LD_EXP 76
26354: PUSH
26355: LD_VAR 0 1
26359: ARRAY
26360: PPUSH
26361: LD_INT 30
26363: PUSH
26364: LD_INT 3
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PPUSH
26371: CALL_OW 72
26375: AND
26376: IFFALSE 27110
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26378: LD_ADDR_EXP 118
26382: PUSH
26383: LD_EXP 118
26387: PPUSH
26388: LD_VAR 0 1
26392: PPUSH
26393: LD_INT 3
26395: PPUSH
26396: CALL_OW 1
26400: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26401: LD_ADDR_VAR 0 2
26405: PUSH
26406: LD_INT 0
26408: PUSH
26409: LD_INT 0
26411: PUSH
26412: LD_INT 0
26414: PUSH
26415: LD_INT 0
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: LIST
26422: LIST
26423: ST_TO_ADDR
// if not eng then
26424: LD_VAR 0 6
26428: NOT
26429: IFFALSE 26492
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26431: LD_ADDR_VAR 0 11
26435: PUSH
26436: LD_VAR 0 4
26440: PPUSH
26441: LD_INT 2
26443: PPUSH
26444: CALL 91884 0 2
26448: PUSH
26449: LD_INT 1
26451: ARRAY
26452: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26453: LD_ADDR_VAR 0 2
26457: PUSH
26458: LD_VAR 0 2
26462: PPUSH
26463: LD_INT 2
26465: PPUSH
26466: LD_VAR 0 11
26470: PPUSH
26471: CALL_OW 1
26475: ST_TO_ADDR
// tmp := tmp diff p ;
26476: LD_ADDR_VAR 0 4
26480: PUSH
26481: LD_VAR 0 4
26485: PUSH
26486: LD_VAR 0 11
26490: DIFF
26491: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26492: LD_VAR 0 4
26496: PUSH
26497: LD_VAR 0 8
26501: PUSH
26502: LD_INT 6
26504: LESS
26505: AND
26506: IFFALSE 26694
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26508: LD_ADDR_VAR 0 9
26512: PUSH
26513: LD_VAR 0 4
26517: PUSH
26518: LD_VAR 0 8
26522: PUSH
26523: LD_VAR 0 7
26527: UNION
26528: DIFF
26529: PPUSH
26530: LD_INT 4
26532: PPUSH
26533: CALL 91884 0 2
26537: ST_TO_ADDR
// p := [ ] ;
26538: LD_ADDR_VAR 0 11
26542: PUSH
26543: EMPTY
26544: ST_TO_ADDR
// if sort then
26545: LD_VAR 0 9
26549: IFFALSE 26665
// for i = 1 to 6 - sci do
26551: LD_ADDR_VAR 0 3
26555: PUSH
26556: DOUBLE
26557: LD_INT 1
26559: DEC
26560: ST_TO_ADDR
26561: LD_INT 6
26563: PUSH
26564: LD_VAR 0 8
26568: MINUS
26569: PUSH
26570: FOR_TO
26571: IFFALSE 26663
// begin if i = sort then
26573: LD_VAR 0 3
26577: PUSH
26578: LD_VAR 0 9
26582: EQUAL
26583: IFFALSE 26587
// break ;
26585: GO 26663
// if GetClass ( i ) = 4 then
26587: LD_VAR 0 3
26591: PPUSH
26592: CALL_OW 257
26596: PUSH
26597: LD_INT 4
26599: EQUAL
26600: IFFALSE 26604
// continue ;
26602: GO 26570
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26604: LD_ADDR_VAR 0 11
26608: PUSH
26609: LD_VAR 0 11
26613: PPUSH
26614: LD_VAR 0 11
26618: PUSH
26619: LD_INT 1
26621: PLUS
26622: PPUSH
26623: LD_VAR 0 9
26627: PUSH
26628: LD_VAR 0 3
26632: ARRAY
26633: PPUSH
26634: CALL_OW 2
26638: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26639: LD_ADDR_VAR 0 4
26643: PUSH
26644: LD_VAR 0 4
26648: PUSH
26649: LD_VAR 0 9
26653: PUSH
26654: LD_VAR 0 3
26658: ARRAY
26659: DIFF
26660: ST_TO_ADDR
// end ;
26661: GO 26570
26663: POP
26664: POP
// if p then
26665: LD_VAR 0 11
26669: IFFALSE 26694
// result := Replace ( result , 4 , p ) ;
26671: LD_ADDR_VAR 0 2
26675: PUSH
26676: LD_VAR 0 2
26680: PPUSH
26681: LD_INT 4
26683: PPUSH
26684: LD_VAR 0 11
26688: PPUSH
26689: CALL_OW 1
26693: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26694: LD_VAR 0 4
26698: PUSH
26699: LD_VAR 0 7
26703: PUSH
26704: LD_INT 6
26706: LESS
26707: AND
26708: IFFALSE 26896
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26710: LD_ADDR_VAR 0 9
26714: PUSH
26715: LD_VAR 0 4
26719: PUSH
26720: LD_VAR 0 8
26724: PUSH
26725: LD_VAR 0 7
26729: UNION
26730: DIFF
26731: PPUSH
26732: LD_INT 3
26734: PPUSH
26735: CALL 91884 0 2
26739: ST_TO_ADDR
// p := [ ] ;
26740: LD_ADDR_VAR 0 11
26744: PUSH
26745: EMPTY
26746: ST_TO_ADDR
// if sort then
26747: LD_VAR 0 9
26751: IFFALSE 26867
// for i = 1 to 6 - mech do
26753: LD_ADDR_VAR 0 3
26757: PUSH
26758: DOUBLE
26759: LD_INT 1
26761: DEC
26762: ST_TO_ADDR
26763: LD_INT 6
26765: PUSH
26766: LD_VAR 0 7
26770: MINUS
26771: PUSH
26772: FOR_TO
26773: IFFALSE 26865
// begin if i = sort then
26775: LD_VAR 0 3
26779: PUSH
26780: LD_VAR 0 9
26784: EQUAL
26785: IFFALSE 26789
// break ;
26787: GO 26865
// if GetClass ( i ) = 3 then
26789: LD_VAR 0 3
26793: PPUSH
26794: CALL_OW 257
26798: PUSH
26799: LD_INT 3
26801: EQUAL
26802: IFFALSE 26806
// continue ;
26804: GO 26772
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26806: LD_ADDR_VAR 0 11
26810: PUSH
26811: LD_VAR 0 11
26815: PPUSH
26816: LD_VAR 0 11
26820: PUSH
26821: LD_INT 1
26823: PLUS
26824: PPUSH
26825: LD_VAR 0 9
26829: PUSH
26830: LD_VAR 0 3
26834: ARRAY
26835: PPUSH
26836: CALL_OW 2
26840: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26841: LD_ADDR_VAR 0 4
26845: PUSH
26846: LD_VAR 0 4
26850: PUSH
26851: LD_VAR 0 9
26855: PUSH
26856: LD_VAR 0 3
26860: ARRAY
26861: DIFF
26862: ST_TO_ADDR
// end ;
26863: GO 26772
26865: POP
26866: POP
// if p then
26867: LD_VAR 0 11
26871: IFFALSE 26896
// result := Replace ( result , 3 , p ) ;
26873: LD_ADDR_VAR 0 2
26877: PUSH
26878: LD_VAR 0 2
26882: PPUSH
26883: LD_INT 3
26885: PPUSH
26886: LD_VAR 0 11
26890: PPUSH
26891: CALL_OW 1
26895: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26896: LD_VAR 0 4
26900: PUSH
26901: LD_INT 6
26903: GREATER
26904: PUSH
26905: LD_VAR 0 6
26909: PUSH
26910: LD_INT 6
26912: LESS
26913: AND
26914: IFFALSE 27108
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26916: LD_ADDR_VAR 0 9
26920: PUSH
26921: LD_VAR 0 4
26925: PUSH
26926: LD_VAR 0 8
26930: PUSH
26931: LD_VAR 0 7
26935: UNION
26936: PUSH
26937: LD_VAR 0 6
26941: UNION
26942: DIFF
26943: PPUSH
26944: LD_INT 2
26946: PPUSH
26947: CALL 91884 0 2
26951: ST_TO_ADDR
// p := [ ] ;
26952: LD_ADDR_VAR 0 11
26956: PUSH
26957: EMPTY
26958: ST_TO_ADDR
// if sort then
26959: LD_VAR 0 9
26963: IFFALSE 27079
// for i = 1 to 6 - eng do
26965: LD_ADDR_VAR 0 3
26969: PUSH
26970: DOUBLE
26971: LD_INT 1
26973: DEC
26974: ST_TO_ADDR
26975: LD_INT 6
26977: PUSH
26978: LD_VAR 0 6
26982: MINUS
26983: PUSH
26984: FOR_TO
26985: IFFALSE 27077
// begin if i = sort then
26987: LD_VAR 0 3
26991: PUSH
26992: LD_VAR 0 9
26996: EQUAL
26997: IFFALSE 27001
// break ;
26999: GO 27077
// if GetClass ( i ) = 2 then
27001: LD_VAR 0 3
27005: PPUSH
27006: CALL_OW 257
27010: PUSH
27011: LD_INT 2
27013: EQUAL
27014: IFFALSE 27018
// continue ;
27016: GO 26984
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27018: LD_ADDR_VAR 0 11
27022: PUSH
27023: LD_VAR 0 11
27027: PPUSH
27028: LD_VAR 0 11
27032: PUSH
27033: LD_INT 1
27035: PLUS
27036: PPUSH
27037: LD_VAR 0 9
27041: PUSH
27042: LD_VAR 0 3
27046: ARRAY
27047: PPUSH
27048: CALL_OW 2
27052: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27053: LD_ADDR_VAR 0 4
27057: PUSH
27058: LD_VAR 0 4
27062: PUSH
27063: LD_VAR 0 9
27067: PUSH
27068: LD_VAR 0 3
27072: ARRAY
27073: DIFF
27074: ST_TO_ADDR
// end ;
27075: GO 26984
27077: POP
27078: POP
// if p then
27079: LD_VAR 0 11
27083: IFFALSE 27108
// result := Replace ( result , 2 , p ) ;
27085: LD_ADDR_VAR 0 2
27089: PUSH
27090: LD_VAR 0 2
27094: PPUSH
27095: LD_INT 2
27097: PPUSH
27098: LD_VAR 0 11
27102: PPUSH
27103: CALL_OW 1
27107: ST_TO_ADDR
// end ; exit ;
27108: GO 28496
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27110: LD_EXP 103
27114: PUSH
27115: LD_EXP 102
27119: PUSH
27120: LD_VAR 0 1
27124: ARRAY
27125: ARRAY
27126: NOT
27127: PUSH
27128: LD_EXP 76
27132: PUSH
27133: LD_VAR 0 1
27137: ARRAY
27138: PPUSH
27139: LD_INT 30
27141: PUSH
27142: LD_INT 3
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: PPUSH
27149: CALL_OW 72
27153: AND
27154: PUSH
27155: LD_EXP 81
27159: PUSH
27160: LD_VAR 0 1
27164: ARRAY
27165: AND
27166: IFFALSE 27774
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27168: LD_ADDR_EXP 118
27172: PUSH
27173: LD_EXP 118
27177: PPUSH
27178: LD_VAR 0 1
27182: PPUSH
27183: LD_INT 5
27185: PPUSH
27186: CALL_OW 1
27190: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27191: LD_ADDR_VAR 0 2
27195: PUSH
27196: LD_INT 0
27198: PUSH
27199: LD_INT 0
27201: PUSH
27202: LD_INT 0
27204: PUSH
27205: LD_INT 0
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: LIST
27212: LIST
27213: ST_TO_ADDR
// if sci > 1 then
27214: LD_VAR 0 8
27218: PUSH
27219: LD_INT 1
27221: GREATER
27222: IFFALSE 27250
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27224: LD_ADDR_VAR 0 4
27228: PUSH
27229: LD_VAR 0 4
27233: PUSH
27234: LD_VAR 0 8
27238: PUSH
27239: LD_VAR 0 8
27243: PUSH
27244: LD_INT 1
27246: ARRAY
27247: DIFF
27248: DIFF
27249: ST_TO_ADDR
// if tmp and not sci then
27250: LD_VAR 0 4
27254: PUSH
27255: LD_VAR 0 8
27259: NOT
27260: AND
27261: IFFALSE 27330
// begin sort := SortBySkill ( tmp , 4 ) ;
27263: LD_ADDR_VAR 0 9
27267: PUSH
27268: LD_VAR 0 4
27272: PPUSH
27273: LD_INT 4
27275: PPUSH
27276: CALL 91884 0 2
27280: ST_TO_ADDR
// if sort then
27281: LD_VAR 0 9
27285: IFFALSE 27301
// p := sort [ 1 ] ;
27287: LD_ADDR_VAR 0 11
27291: PUSH
27292: LD_VAR 0 9
27296: PUSH
27297: LD_INT 1
27299: ARRAY
27300: ST_TO_ADDR
// if p then
27301: LD_VAR 0 11
27305: IFFALSE 27330
// result := Replace ( result , 4 , p ) ;
27307: LD_ADDR_VAR 0 2
27311: PUSH
27312: LD_VAR 0 2
27316: PPUSH
27317: LD_INT 4
27319: PPUSH
27320: LD_VAR 0 11
27324: PPUSH
27325: CALL_OW 1
27329: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27330: LD_ADDR_VAR 0 4
27334: PUSH
27335: LD_VAR 0 4
27339: PUSH
27340: LD_VAR 0 7
27344: DIFF
27345: ST_TO_ADDR
// if tmp and mech < 6 then
27346: LD_VAR 0 4
27350: PUSH
27351: LD_VAR 0 7
27355: PUSH
27356: LD_INT 6
27358: LESS
27359: AND
27360: IFFALSE 27548
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27362: LD_ADDR_VAR 0 9
27366: PUSH
27367: LD_VAR 0 4
27371: PUSH
27372: LD_VAR 0 8
27376: PUSH
27377: LD_VAR 0 7
27381: UNION
27382: DIFF
27383: PPUSH
27384: LD_INT 3
27386: PPUSH
27387: CALL 91884 0 2
27391: ST_TO_ADDR
// p := [ ] ;
27392: LD_ADDR_VAR 0 11
27396: PUSH
27397: EMPTY
27398: ST_TO_ADDR
// if sort then
27399: LD_VAR 0 9
27403: IFFALSE 27519
// for i = 1 to 6 - mech do
27405: LD_ADDR_VAR 0 3
27409: PUSH
27410: DOUBLE
27411: LD_INT 1
27413: DEC
27414: ST_TO_ADDR
27415: LD_INT 6
27417: PUSH
27418: LD_VAR 0 7
27422: MINUS
27423: PUSH
27424: FOR_TO
27425: IFFALSE 27517
// begin if i = sort then
27427: LD_VAR 0 3
27431: PUSH
27432: LD_VAR 0 9
27436: EQUAL
27437: IFFALSE 27441
// break ;
27439: GO 27517
// if GetClass ( i ) = 3 then
27441: LD_VAR 0 3
27445: PPUSH
27446: CALL_OW 257
27450: PUSH
27451: LD_INT 3
27453: EQUAL
27454: IFFALSE 27458
// continue ;
27456: GO 27424
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27458: LD_ADDR_VAR 0 11
27462: PUSH
27463: LD_VAR 0 11
27467: PPUSH
27468: LD_VAR 0 11
27472: PUSH
27473: LD_INT 1
27475: PLUS
27476: PPUSH
27477: LD_VAR 0 9
27481: PUSH
27482: LD_VAR 0 3
27486: ARRAY
27487: PPUSH
27488: CALL_OW 2
27492: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27493: LD_ADDR_VAR 0 4
27497: PUSH
27498: LD_VAR 0 4
27502: PUSH
27503: LD_VAR 0 9
27507: PUSH
27508: LD_VAR 0 3
27512: ARRAY
27513: DIFF
27514: ST_TO_ADDR
// end ;
27515: GO 27424
27517: POP
27518: POP
// if p then
27519: LD_VAR 0 11
27523: IFFALSE 27548
// result := Replace ( result , 3 , p ) ;
27525: LD_ADDR_VAR 0 2
27529: PUSH
27530: LD_VAR 0 2
27534: PPUSH
27535: LD_INT 3
27537: PPUSH
27538: LD_VAR 0 11
27542: PPUSH
27543: CALL_OW 1
27547: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27548: LD_ADDR_VAR 0 4
27552: PUSH
27553: LD_VAR 0 4
27557: PUSH
27558: LD_VAR 0 6
27562: DIFF
27563: ST_TO_ADDR
// if tmp and eng < 6 then
27564: LD_VAR 0 4
27568: PUSH
27569: LD_VAR 0 6
27573: PUSH
27574: LD_INT 6
27576: LESS
27577: AND
27578: IFFALSE 27772
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27580: LD_ADDR_VAR 0 9
27584: PUSH
27585: LD_VAR 0 4
27589: PUSH
27590: LD_VAR 0 8
27594: PUSH
27595: LD_VAR 0 7
27599: UNION
27600: PUSH
27601: LD_VAR 0 6
27605: UNION
27606: DIFF
27607: PPUSH
27608: LD_INT 2
27610: PPUSH
27611: CALL 91884 0 2
27615: ST_TO_ADDR
// p := [ ] ;
27616: LD_ADDR_VAR 0 11
27620: PUSH
27621: EMPTY
27622: ST_TO_ADDR
// if sort then
27623: LD_VAR 0 9
27627: IFFALSE 27743
// for i = 1 to 6 - eng do
27629: LD_ADDR_VAR 0 3
27633: PUSH
27634: DOUBLE
27635: LD_INT 1
27637: DEC
27638: ST_TO_ADDR
27639: LD_INT 6
27641: PUSH
27642: LD_VAR 0 6
27646: MINUS
27647: PUSH
27648: FOR_TO
27649: IFFALSE 27741
// begin if i = sort then
27651: LD_VAR 0 3
27655: PUSH
27656: LD_VAR 0 9
27660: EQUAL
27661: IFFALSE 27665
// break ;
27663: GO 27741
// if GetClass ( i ) = 2 then
27665: LD_VAR 0 3
27669: PPUSH
27670: CALL_OW 257
27674: PUSH
27675: LD_INT 2
27677: EQUAL
27678: IFFALSE 27682
// continue ;
27680: GO 27648
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27682: LD_ADDR_VAR 0 11
27686: PUSH
27687: LD_VAR 0 11
27691: PPUSH
27692: LD_VAR 0 11
27696: PUSH
27697: LD_INT 1
27699: PLUS
27700: PPUSH
27701: LD_VAR 0 9
27705: PUSH
27706: LD_VAR 0 3
27710: ARRAY
27711: PPUSH
27712: CALL_OW 2
27716: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27717: LD_ADDR_VAR 0 4
27721: PUSH
27722: LD_VAR 0 4
27726: PUSH
27727: LD_VAR 0 9
27731: PUSH
27732: LD_VAR 0 3
27736: ARRAY
27737: DIFF
27738: ST_TO_ADDR
// end ;
27739: GO 27648
27741: POP
27742: POP
// if p then
27743: LD_VAR 0 11
27747: IFFALSE 27772
// result := Replace ( result , 2 , p ) ;
27749: LD_ADDR_VAR 0 2
27753: PUSH
27754: LD_VAR 0 2
27758: PPUSH
27759: LD_INT 2
27761: PPUSH
27762: LD_VAR 0 11
27766: PPUSH
27767: CALL_OW 1
27771: ST_TO_ADDR
// end ; exit ;
27772: GO 28496
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27774: LD_EXP 103
27778: PUSH
27779: LD_EXP 102
27783: PUSH
27784: LD_VAR 0 1
27788: ARRAY
27789: ARRAY
27790: NOT
27791: PUSH
27792: LD_EXP 76
27796: PUSH
27797: LD_VAR 0 1
27801: ARRAY
27802: PPUSH
27803: LD_INT 30
27805: PUSH
27806: LD_INT 3
27808: PUSH
27809: EMPTY
27810: LIST
27811: LIST
27812: PPUSH
27813: CALL_OW 72
27817: AND
27818: PUSH
27819: LD_EXP 81
27823: PUSH
27824: LD_VAR 0 1
27828: ARRAY
27829: NOT
27830: AND
27831: IFFALSE 28496
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27833: LD_ADDR_EXP 118
27837: PUSH
27838: LD_EXP 118
27842: PPUSH
27843: LD_VAR 0 1
27847: PPUSH
27848: LD_INT 6
27850: PPUSH
27851: CALL_OW 1
27855: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27856: LD_ADDR_VAR 0 2
27860: PUSH
27861: LD_INT 0
27863: PUSH
27864: LD_INT 0
27866: PUSH
27867: LD_INT 0
27869: PUSH
27870: LD_INT 0
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: ST_TO_ADDR
// if sci >= 1 then
27879: LD_VAR 0 8
27883: PUSH
27884: LD_INT 1
27886: GREATEREQUAL
27887: IFFALSE 27909
// tmp := tmp diff sci [ 1 ] ;
27889: LD_ADDR_VAR 0 4
27893: PUSH
27894: LD_VAR 0 4
27898: PUSH
27899: LD_VAR 0 8
27903: PUSH
27904: LD_INT 1
27906: ARRAY
27907: DIFF
27908: ST_TO_ADDR
// if tmp and not sci then
27909: LD_VAR 0 4
27913: PUSH
27914: LD_VAR 0 8
27918: NOT
27919: AND
27920: IFFALSE 27989
// begin sort := SortBySkill ( tmp , 4 ) ;
27922: LD_ADDR_VAR 0 9
27926: PUSH
27927: LD_VAR 0 4
27931: PPUSH
27932: LD_INT 4
27934: PPUSH
27935: CALL 91884 0 2
27939: ST_TO_ADDR
// if sort then
27940: LD_VAR 0 9
27944: IFFALSE 27960
// p := sort [ 1 ] ;
27946: LD_ADDR_VAR 0 11
27950: PUSH
27951: LD_VAR 0 9
27955: PUSH
27956: LD_INT 1
27958: ARRAY
27959: ST_TO_ADDR
// if p then
27960: LD_VAR 0 11
27964: IFFALSE 27989
// result := Replace ( result , 4 , p ) ;
27966: LD_ADDR_VAR 0 2
27970: PUSH
27971: LD_VAR 0 2
27975: PPUSH
27976: LD_INT 4
27978: PPUSH
27979: LD_VAR 0 11
27983: PPUSH
27984: CALL_OW 1
27988: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27989: LD_ADDR_VAR 0 4
27993: PUSH
27994: LD_VAR 0 4
27998: PUSH
27999: LD_VAR 0 7
28003: DIFF
28004: ST_TO_ADDR
// if tmp and mech < 6 then
28005: LD_VAR 0 4
28009: PUSH
28010: LD_VAR 0 7
28014: PUSH
28015: LD_INT 6
28017: LESS
28018: AND
28019: IFFALSE 28201
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28021: LD_ADDR_VAR 0 9
28025: PUSH
28026: LD_VAR 0 4
28030: PUSH
28031: LD_VAR 0 7
28035: DIFF
28036: PPUSH
28037: LD_INT 3
28039: PPUSH
28040: CALL 91884 0 2
28044: ST_TO_ADDR
// p := [ ] ;
28045: LD_ADDR_VAR 0 11
28049: PUSH
28050: EMPTY
28051: ST_TO_ADDR
// if sort then
28052: LD_VAR 0 9
28056: IFFALSE 28172
// for i = 1 to 6 - mech do
28058: LD_ADDR_VAR 0 3
28062: PUSH
28063: DOUBLE
28064: LD_INT 1
28066: DEC
28067: ST_TO_ADDR
28068: LD_INT 6
28070: PUSH
28071: LD_VAR 0 7
28075: MINUS
28076: PUSH
28077: FOR_TO
28078: IFFALSE 28170
// begin if i = sort then
28080: LD_VAR 0 3
28084: PUSH
28085: LD_VAR 0 9
28089: EQUAL
28090: IFFALSE 28094
// break ;
28092: GO 28170
// if GetClass ( i ) = 3 then
28094: LD_VAR 0 3
28098: PPUSH
28099: CALL_OW 257
28103: PUSH
28104: LD_INT 3
28106: EQUAL
28107: IFFALSE 28111
// continue ;
28109: GO 28077
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28111: LD_ADDR_VAR 0 11
28115: PUSH
28116: LD_VAR 0 11
28120: PPUSH
28121: LD_VAR 0 11
28125: PUSH
28126: LD_INT 1
28128: PLUS
28129: PPUSH
28130: LD_VAR 0 9
28134: PUSH
28135: LD_VAR 0 3
28139: ARRAY
28140: PPUSH
28141: CALL_OW 2
28145: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28146: LD_ADDR_VAR 0 4
28150: PUSH
28151: LD_VAR 0 4
28155: PUSH
28156: LD_VAR 0 9
28160: PUSH
28161: LD_VAR 0 3
28165: ARRAY
28166: DIFF
28167: ST_TO_ADDR
// end ;
28168: GO 28077
28170: POP
28171: POP
// if p then
28172: LD_VAR 0 11
28176: IFFALSE 28201
// result := Replace ( result , 3 , p ) ;
28178: LD_ADDR_VAR 0 2
28182: PUSH
28183: LD_VAR 0 2
28187: PPUSH
28188: LD_INT 3
28190: PPUSH
28191: LD_VAR 0 11
28195: PPUSH
28196: CALL_OW 1
28200: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28201: LD_ADDR_VAR 0 4
28205: PUSH
28206: LD_VAR 0 4
28210: PUSH
28211: LD_VAR 0 6
28215: DIFF
28216: ST_TO_ADDR
// if tmp and eng < 4 then
28217: LD_VAR 0 4
28221: PUSH
28222: LD_VAR 0 6
28226: PUSH
28227: LD_INT 4
28229: LESS
28230: AND
28231: IFFALSE 28421
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28233: LD_ADDR_VAR 0 9
28237: PUSH
28238: LD_VAR 0 4
28242: PUSH
28243: LD_VAR 0 7
28247: PUSH
28248: LD_VAR 0 6
28252: UNION
28253: DIFF
28254: PPUSH
28255: LD_INT 2
28257: PPUSH
28258: CALL 91884 0 2
28262: ST_TO_ADDR
// p := [ ] ;
28263: LD_ADDR_VAR 0 11
28267: PUSH
28268: EMPTY
28269: ST_TO_ADDR
// if sort then
28270: LD_VAR 0 9
28274: IFFALSE 28390
// for i = 1 to 4 - eng do
28276: LD_ADDR_VAR 0 3
28280: PUSH
28281: DOUBLE
28282: LD_INT 1
28284: DEC
28285: ST_TO_ADDR
28286: LD_INT 4
28288: PUSH
28289: LD_VAR 0 6
28293: MINUS
28294: PUSH
28295: FOR_TO
28296: IFFALSE 28388
// begin if i = sort then
28298: LD_VAR 0 3
28302: PUSH
28303: LD_VAR 0 9
28307: EQUAL
28308: IFFALSE 28312
// break ;
28310: GO 28388
// if GetClass ( i ) = 2 then
28312: LD_VAR 0 3
28316: PPUSH
28317: CALL_OW 257
28321: PUSH
28322: LD_INT 2
28324: EQUAL
28325: IFFALSE 28329
// continue ;
28327: GO 28295
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28329: LD_ADDR_VAR 0 11
28333: PUSH
28334: LD_VAR 0 11
28338: PPUSH
28339: LD_VAR 0 11
28343: PUSH
28344: LD_INT 1
28346: PLUS
28347: PPUSH
28348: LD_VAR 0 9
28352: PUSH
28353: LD_VAR 0 3
28357: ARRAY
28358: PPUSH
28359: CALL_OW 2
28363: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28364: LD_ADDR_VAR 0 4
28368: PUSH
28369: LD_VAR 0 4
28373: PUSH
28374: LD_VAR 0 9
28378: PUSH
28379: LD_VAR 0 3
28383: ARRAY
28384: DIFF
28385: ST_TO_ADDR
// end ;
28386: GO 28295
28388: POP
28389: POP
// if p then
28390: LD_VAR 0 11
28394: IFFALSE 28419
// result := Replace ( result , 2 , p ) ;
28396: LD_ADDR_VAR 0 2
28400: PUSH
28401: LD_VAR 0 2
28405: PPUSH
28406: LD_INT 2
28408: PPUSH
28409: LD_VAR 0 11
28413: PPUSH
28414: CALL_OW 1
28418: ST_TO_ADDR
// end else
28419: GO 28465
// for i = eng downto 5 do
28421: LD_ADDR_VAR 0 3
28425: PUSH
28426: DOUBLE
28427: LD_VAR 0 6
28431: INC
28432: ST_TO_ADDR
28433: LD_INT 5
28435: PUSH
28436: FOR_DOWNTO
28437: IFFALSE 28463
// tmp := tmp union eng [ i ] ;
28439: LD_ADDR_VAR 0 4
28443: PUSH
28444: LD_VAR 0 4
28448: PUSH
28449: LD_VAR 0 6
28453: PUSH
28454: LD_VAR 0 3
28458: ARRAY
28459: UNION
28460: ST_TO_ADDR
28461: GO 28436
28463: POP
28464: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28465: LD_ADDR_VAR 0 2
28469: PUSH
28470: LD_VAR 0 2
28474: PPUSH
28475: LD_INT 1
28477: PPUSH
28478: LD_VAR 0 4
28482: PUSH
28483: LD_VAR 0 5
28487: DIFF
28488: PPUSH
28489: CALL_OW 1
28493: ST_TO_ADDR
// exit ;
28494: GO 28496
// end ; end ;
28496: LD_VAR 0 2
28500: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28501: LD_INT 0
28503: PPUSH
28504: PPUSH
28505: PPUSH
// if not mc_bases then
28506: LD_EXP 76
28510: NOT
28511: IFFALSE 28515
// exit ;
28513: GO 28621
// for i = 1 to mc_bases do
28515: LD_ADDR_VAR 0 2
28519: PUSH
28520: DOUBLE
28521: LD_INT 1
28523: DEC
28524: ST_TO_ADDR
28525: LD_EXP 76
28529: PUSH
28530: FOR_TO
28531: IFFALSE 28612
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28533: LD_ADDR_VAR 0 3
28537: PUSH
28538: LD_EXP 76
28542: PUSH
28543: LD_VAR 0 2
28547: ARRAY
28548: PPUSH
28549: LD_INT 21
28551: PUSH
28552: LD_INT 3
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 3
28561: PUSH
28562: LD_INT 24
28564: PUSH
28565: LD_INT 1000
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PPUSH
28580: CALL_OW 72
28584: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28585: LD_ADDR_EXP 77
28589: PUSH
28590: LD_EXP 77
28594: PPUSH
28595: LD_VAR 0 2
28599: PPUSH
28600: LD_VAR 0 3
28604: PPUSH
28605: CALL_OW 1
28609: ST_TO_ADDR
// end ;
28610: GO 28530
28612: POP
28613: POP
// RaiseSailEvent ( 101 ) ;
28614: LD_INT 101
28616: PPUSH
28617: CALL_OW 427
// end ;
28621: LD_VAR 0 1
28625: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28626: LD_INT 0
28628: PPUSH
28629: PPUSH
28630: PPUSH
28631: PPUSH
28632: PPUSH
28633: PPUSH
28634: PPUSH
// if not mc_bases then
28635: LD_EXP 76
28639: NOT
28640: IFFALSE 28644
// exit ;
28642: GO 29217
// for i = 1 to mc_bases do
28644: LD_ADDR_VAR 0 2
28648: PUSH
28649: DOUBLE
28650: LD_INT 1
28652: DEC
28653: ST_TO_ADDR
28654: LD_EXP 76
28658: PUSH
28659: FOR_TO
28660: IFFALSE 29208
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28662: LD_ADDR_VAR 0 5
28666: PUSH
28667: LD_EXP 76
28671: PUSH
28672: LD_VAR 0 2
28676: ARRAY
28677: PUSH
28678: LD_EXP 105
28682: PUSH
28683: LD_VAR 0 2
28687: ARRAY
28688: UNION
28689: PPUSH
28690: LD_INT 21
28692: PUSH
28693: LD_INT 1
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 1
28702: PUSH
28703: LD_INT 3
28705: PUSH
28706: LD_INT 54
28708: PUSH
28709: EMPTY
28710: LIST
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 3
28718: PUSH
28719: LD_INT 24
28721: PUSH
28722: LD_INT 800
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: LIST
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PPUSH
28742: CALL_OW 72
28746: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28747: LD_ADDR_VAR 0 6
28751: PUSH
28752: LD_EXP 76
28756: PUSH
28757: LD_VAR 0 2
28761: ARRAY
28762: PPUSH
28763: LD_INT 21
28765: PUSH
28766: LD_INT 1
28768: PUSH
28769: EMPTY
28770: LIST
28771: LIST
28772: PUSH
28773: LD_INT 1
28775: PUSH
28776: LD_INT 3
28778: PUSH
28779: LD_INT 54
28781: PUSH
28782: EMPTY
28783: LIST
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 3
28791: PUSH
28792: LD_INT 24
28794: PUSH
28795: LD_INT 250
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: LIST
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PPUSH
28815: CALL_OW 72
28819: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28820: LD_ADDR_VAR 0 7
28824: PUSH
28825: LD_VAR 0 5
28829: PUSH
28830: LD_VAR 0 6
28834: DIFF
28835: ST_TO_ADDR
// if not need_heal_1 then
28836: LD_VAR 0 6
28840: NOT
28841: IFFALSE 28874
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28843: LD_ADDR_EXP 79
28847: PUSH
28848: LD_EXP 79
28852: PPUSH
28853: LD_VAR 0 2
28857: PUSH
28858: LD_INT 1
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PPUSH
28865: EMPTY
28866: PPUSH
28867: CALL 57636 0 3
28871: ST_TO_ADDR
28872: GO 28944
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28874: LD_ADDR_EXP 79
28878: PUSH
28879: LD_EXP 79
28883: PPUSH
28884: LD_VAR 0 2
28888: PUSH
28889: LD_INT 1
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PPUSH
28896: LD_EXP 79
28900: PUSH
28901: LD_VAR 0 2
28905: ARRAY
28906: PUSH
28907: LD_INT 1
28909: ARRAY
28910: PPUSH
28911: LD_INT 3
28913: PUSH
28914: LD_INT 24
28916: PUSH
28917: LD_INT 1000
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PPUSH
28928: CALL_OW 72
28932: PUSH
28933: LD_VAR 0 6
28937: UNION
28938: PPUSH
28939: CALL 57636 0 3
28943: ST_TO_ADDR
// if not need_heal_2 then
28944: LD_VAR 0 7
28948: NOT
28949: IFFALSE 28982
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28951: LD_ADDR_EXP 79
28955: PUSH
28956: LD_EXP 79
28960: PPUSH
28961: LD_VAR 0 2
28965: PUSH
28966: LD_INT 2
28968: PUSH
28969: EMPTY
28970: LIST
28971: LIST
28972: PPUSH
28973: EMPTY
28974: PPUSH
28975: CALL 57636 0 3
28979: ST_TO_ADDR
28980: GO 29014
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28982: LD_ADDR_EXP 79
28986: PUSH
28987: LD_EXP 79
28991: PPUSH
28992: LD_VAR 0 2
28996: PUSH
28997: LD_INT 2
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PPUSH
29004: LD_VAR 0 7
29008: PPUSH
29009: CALL 57636 0 3
29013: ST_TO_ADDR
// if need_heal_2 then
29014: LD_VAR 0 7
29018: IFFALSE 29190
// for j in need_heal_2 do
29020: LD_ADDR_VAR 0 3
29024: PUSH
29025: LD_VAR 0 7
29029: PUSH
29030: FOR_IN
29031: IFFALSE 29188
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
29033: LD_ADDR_VAR 0 5
29037: PUSH
29038: LD_EXP 76
29042: PUSH
29043: LD_VAR 0 2
29047: ARRAY
29048: PPUSH
29049: LD_INT 2
29051: PUSH
29052: LD_INT 30
29054: PUSH
29055: LD_INT 6
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: PUSH
29062: LD_INT 30
29064: PUSH
29065: LD_INT 7
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 30
29074: PUSH
29075: LD_INT 8
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 30
29084: PUSH
29085: LD_INT 0
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 30
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 25
29104: PUSH
29105: LD_INT 4
29107: PUSH
29108: EMPTY
29109: LIST
29110: LIST
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: LIST
29116: LIST
29117: LIST
29118: LIST
29119: LIST
29120: PPUSH
29121: CALL_OW 72
29125: ST_TO_ADDR
// if tmp then
29126: LD_VAR 0 5
29130: IFFALSE 29186
// begin k := NearestUnitToUnit ( tmp , j ) ;
29132: LD_ADDR_VAR 0 4
29136: PUSH
29137: LD_VAR 0 5
29141: PPUSH
29142: LD_VAR 0 3
29146: PPUSH
29147: CALL_OW 74
29151: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29152: LD_VAR 0 3
29156: PPUSH
29157: LD_VAR 0 4
29161: PPUSH
29162: CALL_OW 296
29166: PUSH
29167: LD_INT 7
29169: GREATER
29170: IFFALSE 29186
// ComMoveUnit ( j , k ) ;
29172: LD_VAR 0 3
29176: PPUSH
29177: LD_VAR 0 4
29181: PPUSH
29182: CALL_OW 112
// end ; end ;
29186: GO 29030
29188: POP
29189: POP
// if not need_heal_1 and not need_heal_2 then
29190: LD_VAR 0 6
29194: NOT
29195: PUSH
29196: LD_VAR 0 7
29200: NOT
29201: AND
29202: IFFALSE 29206
// continue ;
29204: GO 28659
// end ;
29206: GO 28659
29208: POP
29209: POP
// RaiseSailEvent ( 102 ) ;
29210: LD_INT 102
29212: PPUSH
29213: CALL_OW 427
// end ;
29217: LD_VAR 0 1
29221: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
29222: LD_INT 0
29224: PPUSH
29225: PPUSH
29226: PPUSH
29227: PPUSH
29228: PPUSH
29229: PPUSH
// if not mc_bases then
29230: LD_EXP 76
29234: NOT
29235: IFFALSE 29239
// exit ;
29237: GO 29949
// for i = 1 to mc_bases do
29239: LD_ADDR_VAR 0 2
29243: PUSH
29244: DOUBLE
29245: LD_INT 1
29247: DEC
29248: ST_TO_ADDR
29249: LD_EXP 76
29253: PUSH
29254: FOR_TO
29255: IFFALSE 29947
// begin if not mc_building_need_repair [ i ] then
29257: LD_EXP 77
29261: PUSH
29262: LD_VAR 0 2
29266: ARRAY
29267: NOT
29268: IFFALSE 29442
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29270: LD_ADDR_VAR 0 6
29274: PUSH
29275: LD_EXP 95
29279: PUSH
29280: LD_VAR 0 2
29284: ARRAY
29285: PPUSH
29286: LD_INT 3
29288: PUSH
29289: LD_INT 24
29291: PUSH
29292: LD_INT 1000
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 2
29305: PUSH
29306: LD_INT 34
29308: PUSH
29309: LD_INT 13
29311: PUSH
29312: EMPTY
29313: LIST
29314: LIST
29315: PUSH
29316: LD_INT 34
29318: PUSH
29319: LD_INT 52
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: LIST
29330: PUSH
29331: EMPTY
29332: LIST
29333: LIST
29334: PPUSH
29335: CALL_OW 72
29339: ST_TO_ADDR
// if cranes then
29340: LD_VAR 0 6
29344: IFFALSE 29406
// for j in cranes do
29346: LD_ADDR_VAR 0 3
29350: PUSH
29351: LD_VAR 0 6
29355: PUSH
29356: FOR_IN
29357: IFFALSE 29404
// if not IsInArea ( j , mc_parking [ i ] ) then
29359: LD_VAR 0 3
29363: PPUSH
29364: LD_EXP 100
29368: PUSH
29369: LD_VAR 0 2
29373: ARRAY
29374: PPUSH
29375: CALL_OW 308
29379: NOT
29380: IFFALSE 29402
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29382: LD_VAR 0 3
29386: PPUSH
29387: LD_EXP 100
29391: PUSH
29392: LD_VAR 0 2
29396: ARRAY
29397: PPUSH
29398: CALL_OW 113
29402: GO 29356
29404: POP
29405: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29406: LD_ADDR_EXP 78
29410: PUSH
29411: LD_EXP 78
29415: PPUSH
29416: LD_VAR 0 2
29420: PPUSH
29421: EMPTY
29422: PPUSH
29423: CALL_OW 1
29427: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29428: LD_VAR 0 2
29432: PPUSH
29433: LD_INT 101
29435: PPUSH
29436: CALL 24334 0 2
// continue ;
29440: GO 29254
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29442: LD_ADDR_EXP 82
29446: PUSH
29447: LD_EXP 82
29451: PPUSH
29452: LD_VAR 0 2
29456: PPUSH
29457: EMPTY
29458: PPUSH
29459: CALL_OW 1
29463: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29464: LD_VAR 0 2
29468: PPUSH
29469: LD_INT 103
29471: PPUSH
29472: CALL 24334 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29476: LD_ADDR_VAR 0 5
29480: PUSH
29481: LD_EXP 76
29485: PUSH
29486: LD_VAR 0 2
29490: ARRAY
29491: PUSH
29492: LD_EXP 105
29496: PUSH
29497: LD_VAR 0 2
29501: ARRAY
29502: UNION
29503: PPUSH
29504: LD_INT 2
29506: PUSH
29507: LD_INT 25
29509: PUSH
29510: LD_INT 2
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 25
29519: PUSH
29520: LD_INT 16
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: LIST
29531: PUSH
29532: EMPTY
29533: LIST
29534: PPUSH
29535: CALL_OW 72
29539: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29540: LD_ADDR_VAR 0 6
29544: PUSH
29545: LD_EXP 95
29549: PUSH
29550: LD_VAR 0 2
29554: ARRAY
29555: PPUSH
29556: LD_INT 2
29558: PUSH
29559: LD_INT 34
29561: PUSH
29562: LD_INT 13
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 34
29571: PUSH
29572: LD_INT 52
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: LIST
29583: PPUSH
29584: CALL_OW 72
29588: ST_TO_ADDR
// if cranes then
29589: LD_VAR 0 6
29593: IFFALSE 29729
// begin for j in cranes do
29595: LD_ADDR_VAR 0 3
29599: PUSH
29600: LD_VAR 0 6
29604: PUSH
29605: FOR_IN
29606: IFFALSE 29727
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29608: LD_VAR 0 3
29612: PPUSH
29613: CALL_OW 256
29617: PUSH
29618: LD_INT 500
29620: GREATEREQUAL
29621: PUSH
29622: LD_VAR 0 3
29626: PPUSH
29627: CALL_OW 314
29631: NOT
29632: AND
29633: IFFALSE 29667
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29635: LD_VAR 0 3
29639: PPUSH
29640: LD_EXP 77
29644: PUSH
29645: LD_VAR 0 2
29649: ARRAY
29650: PPUSH
29651: LD_VAR 0 3
29655: PPUSH
29656: CALL_OW 74
29660: PPUSH
29661: CALL_OW 130
29665: GO 29725
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29667: LD_VAR 0 3
29671: PPUSH
29672: CALL_OW 256
29676: PUSH
29677: LD_INT 500
29679: LESS
29680: PUSH
29681: LD_VAR 0 3
29685: PPUSH
29686: LD_EXP 100
29690: PUSH
29691: LD_VAR 0 2
29695: ARRAY
29696: PPUSH
29697: CALL_OW 308
29701: NOT
29702: AND
29703: IFFALSE 29725
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29705: LD_VAR 0 3
29709: PPUSH
29710: LD_EXP 100
29714: PUSH
29715: LD_VAR 0 2
29719: ARRAY
29720: PPUSH
29721: CALL_OW 113
29725: GO 29605
29727: POP
29728: POP
// end ; if not tmp then
29729: LD_VAR 0 5
29733: NOT
29734: IFFALSE 29738
// continue ;
29736: GO 29254
// for j in tmp do
29738: LD_ADDR_VAR 0 3
29742: PUSH
29743: LD_VAR 0 5
29747: PUSH
29748: FOR_IN
29749: IFFALSE 29943
// begin if mc_need_heal [ i ] then
29751: LD_EXP 79
29755: PUSH
29756: LD_VAR 0 2
29760: ARRAY
29761: IFFALSE 29809
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29763: LD_VAR 0 3
29767: PUSH
29768: LD_EXP 79
29772: PUSH
29773: LD_VAR 0 2
29777: ARRAY
29778: PUSH
29779: LD_INT 1
29781: ARRAY
29782: IN
29783: PUSH
29784: LD_VAR 0 3
29788: PUSH
29789: LD_EXP 79
29793: PUSH
29794: LD_VAR 0 2
29798: ARRAY
29799: PUSH
29800: LD_INT 2
29802: ARRAY
29803: IN
29804: OR
29805: IFFALSE 29809
// continue ;
29807: GO 29748
// if IsInUnit ( j ) then
29809: LD_VAR 0 3
29813: PPUSH
29814: CALL_OW 310
29818: IFFALSE 29829
// ComExitBuilding ( j ) ;
29820: LD_VAR 0 3
29824: PPUSH
29825: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29829: LD_VAR 0 3
29833: PUSH
29834: LD_EXP 78
29838: PUSH
29839: LD_VAR 0 2
29843: ARRAY
29844: IN
29845: NOT
29846: IFFALSE 29904
// begin SetTag ( j , 101 ) ;
29848: LD_VAR 0 3
29852: PPUSH
29853: LD_INT 101
29855: PPUSH
29856: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29860: LD_ADDR_EXP 78
29864: PUSH
29865: LD_EXP 78
29869: PPUSH
29870: LD_VAR 0 2
29874: PUSH
29875: LD_EXP 78
29879: PUSH
29880: LD_VAR 0 2
29884: ARRAY
29885: PUSH
29886: LD_INT 1
29888: PLUS
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PPUSH
29894: LD_VAR 0 3
29898: PPUSH
29899: CALL 57636 0 3
29903: ST_TO_ADDR
// end ; wait ( 1 ) ;
29904: LD_INT 1
29906: PPUSH
29907: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29911: LD_VAR 0 3
29915: PPUSH
29916: LD_EXP 77
29920: PUSH
29921: LD_VAR 0 2
29925: ARRAY
29926: PPUSH
29927: LD_VAR 0 3
29931: PPUSH
29932: CALL_OW 74
29936: PPUSH
29937: CALL_OW 130
// end ;
29941: GO 29748
29943: POP
29944: POP
// end ;
29945: GO 29254
29947: POP
29948: POP
// end ;
29949: LD_VAR 0 1
29953: RET
// export function MC_Heal ; var i , j , tmp ; begin
29954: LD_INT 0
29956: PPUSH
29957: PPUSH
29958: PPUSH
29959: PPUSH
// if not mc_bases then
29960: LD_EXP 76
29964: NOT
29965: IFFALSE 29969
// exit ;
29967: GO 30371
// for i = 1 to mc_bases do
29969: LD_ADDR_VAR 0 2
29973: PUSH
29974: DOUBLE
29975: LD_INT 1
29977: DEC
29978: ST_TO_ADDR
29979: LD_EXP 76
29983: PUSH
29984: FOR_TO
29985: IFFALSE 30369
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29987: LD_EXP 79
29991: PUSH
29992: LD_VAR 0 2
29996: ARRAY
29997: PUSH
29998: LD_INT 1
30000: ARRAY
30001: NOT
30002: PUSH
30003: LD_EXP 79
30007: PUSH
30008: LD_VAR 0 2
30012: ARRAY
30013: PUSH
30014: LD_INT 2
30016: ARRAY
30017: NOT
30018: AND
30019: IFFALSE 30057
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30021: LD_ADDR_EXP 80
30025: PUSH
30026: LD_EXP 80
30030: PPUSH
30031: LD_VAR 0 2
30035: PPUSH
30036: EMPTY
30037: PPUSH
30038: CALL_OW 1
30042: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30043: LD_VAR 0 2
30047: PPUSH
30048: LD_INT 102
30050: PPUSH
30051: CALL 24334 0 2
// continue ;
30055: GO 29984
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30057: LD_ADDR_VAR 0 4
30061: PUSH
30062: LD_EXP 76
30066: PUSH
30067: LD_VAR 0 2
30071: ARRAY
30072: PPUSH
30073: LD_INT 25
30075: PUSH
30076: LD_INT 4
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PPUSH
30083: CALL_OW 72
30087: ST_TO_ADDR
// if not tmp then
30088: LD_VAR 0 4
30092: NOT
30093: IFFALSE 30097
// continue ;
30095: GO 29984
// if mc_taming [ i ] then
30097: LD_EXP 107
30101: PUSH
30102: LD_VAR 0 2
30106: ARRAY
30107: IFFALSE 30131
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30109: LD_ADDR_EXP 107
30113: PUSH
30114: LD_EXP 107
30118: PPUSH
30119: LD_VAR 0 2
30123: PPUSH
30124: EMPTY
30125: PPUSH
30126: CALL_OW 1
30130: ST_TO_ADDR
// for j in tmp do
30131: LD_ADDR_VAR 0 3
30135: PUSH
30136: LD_VAR 0 4
30140: PUSH
30141: FOR_IN
30142: IFFALSE 30365
// begin if IsInUnit ( j ) then
30144: LD_VAR 0 3
30148: PPUSH
30149: CALL_OW 310
30153: IFFALSE 30164
// ComExitBuilding ( j ) ;
30155: LD_VAR 0 3
30159: PPUSH
30160: CALL_OW 122
// if not j in mc_healers [ i ] then
30164: LD_VAR 0 3
30168: PUSH
30169: LD_EXP 80
30173: PUSH
30174: LD_VAR 0 2
30178: ARRAY
30179: IN
30180: NOT
30181: IFFALSE 30227
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30183: LD_ADDR_EXP 80
30187: PUSH
30188: LD_EXP 80
30192: PPUSH
30193: LD_VAR 0 2
30197: PUSH
30198: LD_EXP 80
30202: PUSH
30203: LD_VAR 0 2
30207: ARRAY
30208: PUSH
30209: LD_INT 1
30211: PLUS
30212: PUSH
30213: EMPTY
30214: LIST
30215: LIST
30216: PPUSH
30217: LD_VAR 0 3
30221: PPUSH
30222: CALL 57636 0 3
30226: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30227: LD_VAR 0 3
30231: PPUSH
30232: CALL_OW 110
30236: PUSH
30237: LD_INT 102
30239: NONEQUAL
30240: IFFALSE 30254
// SetTag ( j , 102 ) ;
30242: LD_VAR 0 3
30246: PPUSH
30247: LD_INT 102
30249: PPUSH
30250: CALL_OW 109
// Wait ( 3 ) ;
30254: LD_INT 3
30256: PPUSH
30257: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30261: LD_EXP 79
30265: PUSH
30266: LD_VAR 0 2
30270: ARRAY
30271: PUSH
30272: LD_INT 1
30274: ARRAY
30275: IFFALSE 30307
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30277: LD_VAR 0 3
30281: PPUSH
30282: LD_EXP 79
30286: PUSH
30287: LD_VAR 0 2
30291: ARRAY
30292: PUSH
30293: LD_INT 1
30295: ARRAY
30296: PUSH
30297: LD_INT 1
30299: ARRAY
30300: PPUSH
30301: CALL_OW 128
30305: GO 30363
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30307: LD_VAR 0 3
30311: PPUSH
30312: CALL_OW 314
30316: NOT
30317: PUSH
30318: LD_EXP 79
30322: PUSH
30323: LD_VAR 0 2
30327: ARRAY
30328: PUSH
30329: LD_INT 2
30331: ARRAY
30332: AND
30333: IFFALSE 30363
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30335: LD_VAR 0 3
30339: PPUSH
30340: LD_EXP 79
30344: PUSH
30345: LD_VAR 0 2
30349: ARRAY
30350: PUSH
30351: LD_INT 2
30353: ARRAY
30354: PUSH
30355: LD_INT 1
30357: ARRAY
30358: PPUSH
30359: CALL_OW 128
// end ;
30363: GO 30141
30365: POP
30366: POP
// end ;
30367: GO 29984
30369: POP
30370: POP
// end ;
30371: LD_VAR 0 1
30375: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30376: LD_INT 0
30378: PPUSH
30379: PPUSH
30380: PPUSH
30381: PPUSH
30382: PPUSH
// if not mc_bases then
30383: LD_EXP 76
30387: NOT
30388: IFFALSE 30392
// exit ;
30390: GO 31535
// for i = 1 to mc_bases do
30392: LD_ADDR_VAR 0 2
30396: PUSH
30397: DOUBLE
30398: LD_INT 1
30400: DEC
30401: ST_TO_ADDR
30402: LD_EXP 76
30406: PUSH
30407: FOR_TO
30408: IFFALSE 31533
// begin if mc_scan [ i ] then
30410: LD_EXP 99
30414: PUSH
30415: LD_VAR 0 2
30419: ARRAY
30420: IFFALSE 30424
// continue ;
30422: GO 30407
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30424: LD_EXP 81
30428: PUSH
30429: LD_VAR 0 2
30433: ARRAY
30434: NOT
30435: PUSH
30436: LD_EXP 83
30440: PUSH
30441: LD_VAR 0 2
30445: ARRAY
30446: NOT
30447: AND
30448: PUSH
30449: LD_EXP 82
30453: PUSH
30454: LD_VAR 0 2
30458: ARRAY
30459: AND
30460: IFFALSE 30498
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30462: LD_ADDR_EXP 82
30466: PUSH
30467: LD_EXP 82
30471: PPUSH
30472: LD_VAR 0 2
30476: PPUSH
30477: EMPTY
30478: PPUSH
30479: CALL_OW 1
30483: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30484: LD_VAR 0 2
30488: PPUSH
30489: LD_INT 103
30491: PPUSH
30492: CALL 24334 0 2
// continue ;
30496: GO 30407
// end ; if mc_construct_list [ i ] then
30498: LD_EXP 83
30502: PUSH
30503: LD_VAR 0 2
30507: ARRAY
30508: IFFALSE 30728
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30510: LD_ADDR_VAR 0 4
30514: PUSH
30515: LD_EXP 76
30519: PUSH
30520: LD_VAR 0 2
30524: ARRAY
30525: PPUSH
30526: LD_INT 25
30528: PUSH
30529: LD_INT 2
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PPUSH
30536: CALL_OW 72
30540: PUSH
30541: LD_EXP 78
30545: PUSH
30546: LD_VAR 0 2
30550: ARRAY
30551: DIFF
30552: ST_TO_ADDR
// if not tmp then
30553: LD_VAR 0 4
30557: NOT
30558: IFFALSE 30562
// continue ;
30560: GO 30407
// for j in tmp do
30562: LD_ADDR_VAR 0 3
30566: PUSH
30567: LD_VAR 0 4
30571: PUSH
30572: FOR_IN
30573: IFFALSE 30724
// begin if not mc_builders [ i ] then
30575: LD_EXP 82
30579: PUSH
30580: LD_VAR 0 2
30584: ARRAY
30585: NOT
30586: IFFALSE 30644
// begin SetTag ( j , 103 ) ;
30588: LD_VAR 0 3
30592: PPUSH
30593: LD_INT 103
30595: PPUSH
30596: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30600: LD_ADDR_EXP 82
30604: PUSH
30605: LD_EXP 82
30609: PPUSH
30610: LD_VAR 0 2
30614: PUSH
30615: LD_EXP 82
30619: PUSH
30620: LD_VAR 0 2
30624: ARRAY
30625: PUSH
30626: LD_INT 1
30628: PLUS
30629: PUSH
30630: EMPTY
30631: LIST
30632: LIST
30633: PPUSH
30634: LD_VAR 0 3
30638: PPUSH
30639: CALL 57636 0 3
30643: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30644: LD_VAR 0 3
30648: PPUSH
30649: CALL_OW 310
30653: IFFALSE 30664
// ComExitBuilding ( j ) ;
30655: LD_VAR 0 3
30659: PPUSH
30660: CALL_OW 122
// wait ( 3 ) ;
30664: LD_INT 3
30666: PPUSH
30667: CALL_OW 67
// if not mc_construct_list [ i ] then
30671: LD_EXP 83
30675: PUSH
30676: LD_VAR 0 2
30680: ARRAY
30681: NOT
30682: IFFALSE 30686
// break ;
30684: GO 30724
// if not HasTask ( j ) then
30686: LD_VAR 0 3
30690: PPUSH
30691: CALL_OW 314
30695: NOT
30696: IFFALSE 30722
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30698: LD_VAR 0 3
30702: PPUSH
30703: LD_EXP 83
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: PUSH
30714: LD_INT 1
30716: ARRAY
30717: PPUSH
30718: CALL 60487 0 2
// end ;
30722: GO 30572
30724: POP
30725: POP
// end else
30726: GO 31531
// if mc_build_list [ i ] then
30728: LD_EXP 81
30732: PUSH
30733: LD_VAR 0 2
30737: ARRAY
30738: IFFALSE 31531
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30740: LD_ADDR_VAR 0 5
30744: PUSH
30745: LD_EXP 76
30749: PUSH
30750: LD_VAR 0 2
30754: ARRAY
30755: PPUSH
30756: LD_INT 2
30758: PUSH
30759: LD_INT 30
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 30
30771: PUSH
30772: LD_INT 1
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: LIST
30783: PPUSH
30784: CALL_OW 72
30788: ST_TO_ADDR
// if depot then
30789: LD_VAR 0 5
30793: IFFALSE 30811
// depot := depot [ 1 ] else
30795: LD_ADDR_VAR 0 5
30799: PUSH
30800: LD_VAR 0 5
30804: PUSH
30805: LD_INT 1
30807: ARRAY
30808: ST_TO_ADDR
30809: GO 30819
// depot := 0 ;
30811: LD_ADDR_VAR 0 5
30815: PUSH
30816: LD_INT 0
30818: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30819: LD_EXP 81
30823: PUSH
30824: LD_VAR 0 2
30828: ARRAY
30829: PUSH
30830: LD_INT 1
30832: ARRAY
30833: PUSH
30834: LD_INT 1
30836: ARRAY
30837: PPUSH
30838: CALL 60317 0 1
30842: PUSH
30843: LD_EXP 76
30847: PUSH
30848: LD_VAR 0 2
30852: ARRAY
30853: PPUSH
30854: LD_INT 2
30856: PUSH
30857: LD_INT 30
30859: PUSH
30860: LD_INT 2
30862: PUSH
30863: EMPTY
30864: LIST
30865: LIST
30866: PUSH
30867: LD_INT 30
30869: PUSH
30870: LD_INT 3
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: LIST
30881: PPUSH
30882: CALL_OW 72
30886: NOT
30887: AND
30888: IFFALSE 30993
// begin for j = 1 to mc_build_list [ i ] do
30890: LD_ADDR_VAR 0 3
30894: PUSH
30895: DOUBLE
30896: LD_INT 1
30898: DEC
30899: ST_TO_ADDR
30900: LD_EXP 81
30904: PUSH
30905: LD_VAR 0 2
30909: ARRAY
30910: PUSH
30911: FOR_TO
30912: IFFALSE 30991
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30914: LD_EXP 81
30918: PUSH
30919: LD_VAR 0 2
30923: ARRAY
30924: PUSH
30925: LD_VAR 0 3
30929: ARRAY
30930: PUSH
30931: LD_INT 1
30933: ARRAY
30934: PUSH
30935: LD_INT 2
30937: EQUAL
30938: IFFALSE 30989
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30940: LD_ADDR_EXP 81
30944: PUSH
30945: LD_EXP 81
30949: PPUSH
30950: LD_VAR 0 2
30954: PPUSH
30955: LD_EXP 81
30959: PUSH
30960: LD_VAR 0 2
30964: ARRAY
30965: PPUSH
30966: LD_VAR 0 3
30970: PPUSH
30971: LD_INT 1
30973: PPUSH
30974: LD_INT 0
30976: PPUSH
30977: CALL 57054 0 4
30981: PPUSH
30982: CALL_OW 1
30986: ST_TO_ADDR
// break ;
30987: GO 30991
// end ;
30989: GO 30911
30991: POP
30992: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30993: LD_EXP 81
30997: PUSH
30998: LD_VAR 0 2
31002: ARRAY
31003: PUSH
31004: LD_INT 1
31006: ARRAY
31007: PUSH
31008: LD_INT 1
31010: ARRAY
31011: PUSH
31012: LD_INT 0
31014: EQUAL
31015: PUSH
31016: LD_VAR 0 5
31020: PUSH
31021: LD_VAR 0 5
31025: PPUSH
31026: LD_EXP 81
31030: PUSH
31031: LD_VAR 0 2
31035: ARRAY
31036: PUSH
31037: LD_INT 1
31039: ARRAY
31040: PUSH
31041: LD_INT 1
31043: ARRAY
31044: PPUSH
31045: LD_EXP 81
31049: PUSH
31050: LD_VAR 0 2
31054: ARRAY
31055: PUSH
31056: LD_INT 1
31058: ARRAY
31059: PUSH
31060: LD_INT 2
31062: ARRAY
31063: PPUSH
31064: LD_EXP 81
31068: PUSH
31069: LD_VAR 0 2
31073: ARRAY
31074: PUSH
31075: LD_INT 1
31077: ARRAY
31078: PUSH
31079: LD_INT 3
31081: ARRAY
31082: PPUSH
31083: LD_EXP 81
31087: PUSH
31088: LD_VAR 0 2
31092: ARRAY
31093: PUSH
31094: LD_INT 1
31096: ARRAY
31097: PUSH
31098: LD_INT 4
31100: ARRAY
31101: PPUSH
31102: CALL 65051 0 5
31106: AND
31107: OR
31108: IFFALSE 31389
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31110: LD_ADDR_VAR 0 4
31114: PUSH
31115: LD_EXP 76
31119: PUSH
31120: LD_VAR 0 2
31124: ARRAY
31125: PPUSH
31126: LD_INT 25
31128: PUSH
31129: LD_INT 2
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PPUSH
31136: CALL_OW 72
31140: PUSH
31141: LD_EXP 78
31145: PUSH
31146: LD_VAR 0 2
31150: ARRAY
31151: DIFF
31152: ST_TO_ADDR
// if not tmp then
31153: LD_VAR 0 4
31157: NOT
31158: IFFALSE 31162
// continue ;
31160: GO 30407
// for j in tmp do
31162: LD_ADDR_VAR 0 3
31166: PUSH
31167: LD_VAR 0 4
31171: PUSH
31172: FOR_IN
31173: IFFALSE 31385
// begin if not mc_builders [ i ] then
31175: LD_EXP 82
31179: PUSH
31180: LD_VAR 0 2
31184: ARRAY
31185: NOT
31186: IFFALSE 31244
// begin SetTag ( j , 103 ) ;
31188: LD_VAR 0 3
31192: PPUSH
31193: LD_INT 103
31195: PPUSH
31196: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31200: LD_ADDR_EXP 82
31204: PUSH
31205: LD_EXP 82
31209: PPUSH
31210: LD_VAR 0 2
31214: PUSH
31215: LD_EXP 82
31219: PUSH
31220: LD_VAR 0 2
31224: ARRAY
31225: PUSH
31226: LD_INT 1
31228: PLUS
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PPUSH
31234: LD_VAR 0 3
31238: PPUSH
31239: CALL 57636 0 3
31243: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31244: LD_VAR 0 3
31248: PPUSH
31249: CALL_OW 310
31253: IFFALSE 31264
// ComExitBuilding ( j ) ;
31255: LD_VAR 0 3
31259: PPUSH
31260: CALL_OW 122
// wait ( 3 ) ;
31264: LD_INT 3
31266: PPUSH
31267: CALL_OW 67
// if not mc_build_list [ i ] then
31271: LD_EXP 81
31275: PUSH
31276: LD_VAR 0 2
31280: ARRAY
31281: NOT
31282: IFFALSE 31286
// break ;
31284: GO 31385
// if not HasTask ( j ) then
31286: LD_VAR 0 3
31290: PPUSH
31291: CALL_OW 314
31295: NOT
31296: IFFALSE 31383
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31298: LD_VAR 0 3
31302: PPUSH
31303: LD_EXP 81
31307: PUSH
31308: LD_VAR 0 2
31312: ARRAY
31313: PUSH
31314: LD_INT 1
31316: ARRAY
31317: PUSH
31318: LD_INT 1
31320: ARRAY
31321: PPUSH
31322: LD_EXP 81
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: PUSH
31333: LD_INT 1
31335: ARRAY
31336: PUSH
31337: LD_INT 2
31339: ARRAY
31340: PPUSH
31341: LD_EXP 81
31345: PUSH
31346: LD_VAR 0 2
31350: ARRAY
31351: PUSH
31352: LD_INT 1
31354: ARRAY
31355: PUSH
31356: LD_INT 3
31358: ARRAY
31359: PPUSH
31360: LD_EXP 81
31364: PUSH
31365: LD_VAR 0 2
31369: ARRAY
31370: PUSH
31371: LD_INT 1
31373: ARRAY
31374: PUSH
31375: LD_INT 4
31377: ARRAY
31378: PPUSH
31379: CALL_OW 145
// end ;
31383: GO 31172
31385: POP
31386: POP
// end else
31387: GO 31531
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31389: LD_EXP 76
31393: PUSH
31394: LD_VAR 0 2
31398: ARRAY
31399: PPUSH
31400: LD_EXP 81
31404: PUSH
31405: LD_VAR 0 2
31409: ARRAY
31410: PUSH
31411: LD_INT 1
31413: ARRAY
31414: PUSH
31415: LD_INT 1
31417: ARRAY
31418: PPUSH
31419: LD_EXP 81
31423: PUSH
31424: LD_VAR 0 2
31428: ARRAY
31429: PUSH
31430: LD_INT 1
31432: ARRAY
31433: PUSH
31434: LD_INT 2
31436: ARRAY
31437: PPUSH
31438: LD_EXP 81
31442: PUSH
31443: LD_VAR 0 2
31447: ARRAY
31448: PUSH
31449: LD_INT 1
31451: ARRAY
31452: PUSH
31453: LD_INT 3
31455: ARRAY
31456: PPUSH
31457: LD_EXP 81
31461: PUSH
31462: LD_VAR 0 2
31466: ARRAY
31467: PUSH
31468: LD_INT 1
31470: ARRAY
31471: PUSH
31472: LD_INT 4
31474: ARRAY
31475: PPUSH
31476: CALL 64387 0 5
31480: NOT
31481: IFFALSE 31531
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31483: LD_ADDR_EXP 81
31487: PUSH
31488: LD_EXP 81
31492: PPUSH
31493: LD_VAR 0 2
31497: PPUSH
31498: LD_EXP 81
31502: PUSH
31503: LD_VAR 0 2
31507: ARRAY
31508: PPUSH
31509: LD_INT 1
31511: PPUSH
31512: LD_INT 1
31514: NEG
31515: PPUSH
31516: LD_INT 0
31518: PPUSH
31519: CALL 57054 0 4
31523: PPUSH
31524: CALL_OW 1
31528: ST_TO_ADDR
// continue ;
31529: GO 30407
// end ; end ; end ;
31531: GO 30407
31533: POP
31534: POP
// end ;
31535: LD_VAR 0 1
31539: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31540: LD_INT 0
31542: PPUSH
31543: PPUSH
31544: PPUSH
31545: PPUSH
31546: PPUSH
31547: PPUSH
// if not mc_bases then
31548: LD_EXP 76
31552: NOT
31553: IFFALSE 31557
// exit ;
31555: GO 31984
// for i = 1 to mc_bases do
31557: LD_ADDR_VAR 0 2
31561: PUSH
31562: DOUBLE
31563: LD_INT 1
31565: DEC
31566: ST_TO_ADDR
31567: LD_EXP 76
31571: PUSH
31572: FOR_TO
31573: IFFALSE 31982
// begin tmp := mc_build_upgrade [ i ] ;
31575: LD_ADDR_VAR 0 4
31579: PUSH
31580: LD_EXP 108
31584: PUSH
31585: LD_VAR 0 2
31589: ARRAY
31590: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31591: LD_ADDR_VAR 0 6
31595: PUSH
31596: LD_EXP 109
31600: PUSH
31601: LD_VAR 0 2
31605: ARRAY
31606: PPUSH
31607: LD_INT 2
31609: PUSH
31610: LD_INT 30
31612: PUSH
31613: LD_INT 6
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 30
31622: PUSH
31623: LD_INT 7
31625: PUSH
31626: EMPTY
31627: LIST
31628: LIST
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: LIST
31634: PPUSH
31635: CALL_OW 72
31639: ST_TO_ADDR
// if not tmp and not lab then
31640: LD_VAR 0 4
31644: NOT
31645: PUSH
31646: LD_VAR 0 6
31650: NOT
31651: AND
31652: IFFALSE 31656
// continue ;
31654: GO 31572
// if tmp then
31656: LD_VAR 0 4
31660: IFFALSE 31780
// for j in tmp do
31662: LD_ADDR_VAR 0 3
31666: PUSH
31667: LD_VAR 0 4
31671: PUSH
31672: FOR_IN
31673: IFFALSE 31778
// begin if UpgradeCost ( j ) then
31675: LD_VAR 0 3
31679: PPUSH
31680: CALL 64047 0 1
31684: IFFALSE 31776
// begin ComUpgrade ( j ) ;
31686: LD_VAR 0 3
31690: PPUSH
31691: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31695: LD_ADDR_EXP 108
31699: PUSH
31700: LD_EXP 108
31704: PPUSH
31705: LD_VAR 0 2
31709: PPUSH
31710: LD_EXP 108
31714: PUSH
31715: LD_VAR 0 2
31719: ARRAY
31720: PUSH
31721: LD_VAR 0 3
31725: DIFF
31726: PPUSH
31727: CALL_OW 1
31731: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31732: LD_ADDR_EXP 83
31736: PUSH
31737: LD_EXP 83
31741: PPUSH
31742: LD_VAR 0 2
31746: PUSH
31747: LD_EXP 83
31751: PUSH
31752: LD_VAR 0 2
31756: ARRAY
31757: PUSH
31758: LD_INT 1
31760: PLUS
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PPUSH
31766: LD_VAR 0 3
31770: PPUSH
31771: CALL 57636 0 3
31775: ST_TO_ADDR
// end ; end ;
31776: GO 31672
31778: POP
31779: POP
// if not lab or not mc_lab_upgrade [ i ] then
31780: LD_VAR 0 6
31784: NOT
31785: PUSH
31786: LD_EXP 110
31790: PUSH
31791: LD_VAR 0 2
31795: ARRAY
31796: NOT
31797: OR
31798: IFFALSE 31802
// continue ;
31800: GO 31572
// for j in lab do
31802: LD_ADDR_VAR 0 3
31806: PUSH
31807: LD_VAR 0 6
31811: PUSH
31812: FOR_IN
31813: IFFALSE 31978
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31815: LD_VAR 0 3
31819: PPUSH
31820: CALL_OW 266
31824: PUSH
31825: LD_INT 6
31827: PUSH
31828: LD_INT 7
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: IN
31835: PUSH
31836: LD_VAR 0 3
31840: PPUSH
31841: CALL_OW 461
31845: PUSH
31846: LD_INT 1
31848: NONEQUAL
31849: AND
31850: IFFALSE 31976
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31852: LD_VAR 0 3
31856: PPUSH
31857: LD_EXP 110
31861: PUSH
31862: LD_VAR 0 2
31866: ARRAY
31867: PUSH
31868: LD_INT 1
31870: ARRAY
31871: PPUSH
31872: CALL 64252 0 2
31876: IFFALSE 31976
// begin ComCancel ( j ) ;
31878: LD_VAR 0 3
31882: PPUSH
31883: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31887: LD_VAR 0 3
31891: PPUSH
31892: LD_EXP 110
31896: PUSH
31897: LD_VAR 0 2
31901: ARRAY
31902: PUSH
31903: LD_INT 1
31905: ARRAY
31906: PPUSH
31907: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31911: LD_VAR 0 3
31915: PUSH
31916: LD_EXP 83
31920: PUSH
31921: LD_VAR 0 2
31925: ARRAY
31926: IN
31927: NOT
31928: IFFALSE 31974
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31930: LD_ADDR_EXP 83
31934: PUSH
31935: LD_EXP 83
31939: PPUSH
31940: LD_VAR 0 2
31944: PUSH
31945: LD_EXP 83
31949: PUSH
31950: LD_VAR 0 2
31954: ARRAY
31955: PUSH
31956: LD_INT 1
31958: PLUS
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PPUSH
31964: LD_VAR 0 3
31968: PPUSH
31969: CALL 57636 0 3
31973: ST_TO_ADDR
// break ;
31974: GO 31978
// end ; end ; end ;
31976: GO 31812
31978: POP
31979: POP
// end ;
31980: GO 31572
31982: POP
31983: POP
// end ;
31984: LD_VAR 0 1
31988: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31989: LD_INT 0
31991: PPUSH
31992: PPUSH
31993: PPUSH
31994: PPUSH
31995: PPUSH
31996: PPUSH
31997: PPUSH
31998: PPUSH
31999: PPUSH
// if not mc_bases then
32000: LD_EXP 76
32004: NOT
32005: IFFALSE 32009
// exit ;
32007: GO 32414
// for i = 1 to mc_bases do
32009: LD_ADDR_VAR 0 2
32013: PUSH
32014: DOUBLE
32015: LD_INT 1
32017: DEC
32018: ST_TO_ADDR
32019: LD_EXP 76
32023: PUSH
32024: FOR_TO
32025: IFFALSE 32412
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32027: LD_EXP 84
32031: PUSH
32032: LD_VAR 0 2
32036: ARRAY
32037: NOT
32038: PUSH
32039: LD_EXP 76
32043: PUSH
32044: LD_VAR 0 2
32048: ARRAY
32049: PPUSH
32050: LD_INT 30
32052: PUSH
32053: LD_INT 3
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PPUSH
32060: CALL_OW 72
32064: NOT
32065: OR
32066: IFFALSE 32070
// continue ;
32068: GO 32024
// busy := false ;
32070: LD_ADDR_VAR 0 8
32074: PUSH
32075: LD_INT 0
32077: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32078: LD_ADDR_VAR 0 4
32082: PUSH
32083: LD_EXP 76
32087: PUSH
32088: LD_VAR 0 2
32092: ARRAY
32093: PPUSH
32094: LD_INT 30
32096: PUSH
32097: LD_INT 3
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PPUSH
32104: CALL_OW 72
32108: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32109: LD_ADDR_VAR 0 6
32113: PUSH
32114: LD_EXP 84
32118: PUSH
32119: LD_VAR 0 2
32123: ARRAY
32124: PPUSH
32125: LD_INT 2
32127: PUSH
32128: LD_INT 30
32130: PUSH
32131: LD_INT 32
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 30
32140: PUSH
32141: LD_INT 33
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: LIST
32152: PPUSH
32153: CALL_OW 72
32157: ST_TO_ADDR
// if not t then
32158: LD_VAR 0 6
32162: NOT
32163: IFFALSE 32167
// continue ;
32165: GO 32024
// for j in tmp do
32167: LD_ADDR_VAR 0 3
32171: PUSH
32172: LD_VAR 0 4
32176: PUSH
32177: FOR_IN
32178: IFFALSE 32208
// if not BuildingStatus ( j ) = bs_idle then
32180: LD_VAR 0 3
32184: PPUSH
32185: CALL_OW 461
32189: PUSH
32190: LD_INT 2
32192: EQUAL
32193: NOT
32194: IFFALSE 32206
// begin busy := true ;
32196: LD_ADDR_VAR 0 8
32200: PUSH
32201: LD_INT 1
32203: ST_TO_ADDR
// break ;
32204: GO 32208
// end ;
32206: GO 32177
32208: POP
32209: POP
// if busy then
32210: LD_VAR 0 8
32214: IFFALSE 32218
// continue ;
32216: GO 32024
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32218: LD_ADDR_VAR 0 7
32222: PUSH
32223: LD_VAR 0 6
32227: PPUSH
32228: LD_INT 35
32230: PUSH
32231: LD_INT 0
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PPUSH
32238: CALL_OW 72
32242: ST_TO_ADDR
// if tw then
32243: LD_VAR 0 7
32247: IFFALSE 32324
// begin tw := tw [ 1 ] ;
32249: LD_ADDR_VAR 0 7
32253: PUSH
32254: LD_VAR 0 7
32258: PUSH
32259: LD_INT 1
32261: ARRAY
32262: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32263: LD_ADDR_VAR 0 9
32267: PUSH
32268: LD_VAR 0 7
32272: PPUSH
32273: LD_EXP 101
32277: PUSH
32278: LD_VAR 0 2
32282: ARRAY
32283: PPUSH
32284: CALL 62606 0 2
32288: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32289: LD_EXP 115
32293: PUSH
32294: LD_VAR 0 2
32298: ARRAY
32299: IFFALSE 32322
// if not weapon in mc_allowed_tower_weapons [ i ] then
32301: LD_VAR 0 9
32305: PUSH
32306: LD_EXP 115
32310: PUSH
32311: LD_VAR 0 2
32315: ARRAY
32316: IN
32317: NOT
32318: IFFALSE 32322
// continue ;
32320: GO 32024
// end else
32322: GO 32387
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32324: LD_ADDR_VAR 0 5
32328: PUSH
32329: LD_EXP 84
32333: PUSH
32334: LD_VAR 0 2
32338: ARRAY
32339: PPUSH
32340: LD_VAR 0 4
32344: PPUSH
32345: CALL 92807 0 2
32349: ST_TO_ADDR
// if not tmp2 then
32350: LD_VAR 0 5
32354: NOT
32355: IFFALSE 32359
// continue ;
32357: GO 32024
// tw := tmp2 [ 1 ] ;
32359: LD_ADDR_VAR 0 7
32363: PUSH
32364: LD_VAR 0 5
32368: PUSH
32369: LD_INT 1
32371: ARRAY
32372: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32373: LD_ADDR_VAR 0 9
32377: PUSH
32378: LD_VAR 0 5
32382: PUSH
32383: LD_INT 2
32385: ARRAY
32386: ST_TO_ADDR
// end ; if not weapon then
32387: LD_VAR 0 9
32391: NOT
32392: IFFALSE 32396
// continue ;
32394: GO 32024
// ComPlaceWeapon ( tw , weapon ) ;
32396: LD_VAR 0 7
32400: PPUSH
32401: LD_VAR 0 9
32405: PPUSH
32406: CALL_OW 148
// end ;
32410: GO 32024
32412: POP
32413: POP
// end ;
32414: LD_VAR 0 1
32418: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32419: LD_INT 0
32421: PPUSH
32422: PPUSH
32423: PPUSH
32424: PPUSH
32425: PPUSH
32426: PPUSH
// if not mc_bases then
32427: LD_EXP 76
32431: NOT
32432: IFFALSE 32436
// exit ;
32434: GO 33448
// for i = 1 to mc_bases do
32436: LD_ADDR_VAR 0 2
32440: PUSH
32441: DOUBLE
32442: LD_INT 1
32444: DEC
32445: ST_TO_ADDR
32446: LD_EXP 76
32450: PUSH
32451: FOR_TO
32452: IFFALSE 33446
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
32454: LD_EXP 89
32458: PUSH
32459: LD_VAR 0 2
32463: ARRAY
32464: NOT
32465: PUSH
32466: LD_EXP 89
32470: PUSH
32471: LD_VAR 0 2
32475: ARRAY
32476: PUSH
32477: LD_EXP 90
32481: PUSH
32482: LD_VAR 0 2
32486: ARRAY
32487: EQUAL
32488: OR
32489: IFFALSE 32493
// continue ;
32491: GO 32451
// if mc_miners [ i ] then
32493: LD_EXP 90
32497: PUSH
32498: LD_VAR 0 2
32502: ARRAY
32503: IFFALSE 33133
// begin k := 1 ;
32505: LD_ADDR_VAR 0 4
32509: PUSH
32510: LD_INT 1
32512: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
32513: LD_ADDR_VAR 0 3
32517: PUSH
32518: DOUBLE
32519: LD_EXP 90
32523: PUSH
32524: LD_VAR 0 2
32528: ARRAY
32529: INC
32530: ST_TO_ADDR
32531: LD_INT 1
32533: PUSH
32534: FOR_DOWNTO
32535: IFFALSE 33131
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32537: LD_EXP 90
32541: PUSH
32542: LD_VAR 0 2
32546: ARRAY
32547: PUSH
32548: LD_VAR 0 3
32552: ARRAY
32553: PPUSH
32554: CALL_OW 301
32558: PUSH
32559: LD_EXP 90
32563: PUSH
32564: LD_VAR 0 2
32568: ARRAY
32569: PUSH
32570: LD_VAR 0 3
32574: ARRAY
32575: PPUSH
32576: CALL_OW 257
32580: PUSH
32581: LD_INT 1
32583: NONEQUAL
32584: OR
32585: IFFALSE 32648
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32587: LD_ADDR_VAR 0 5
32591: PUSH
32592: LD_EXP 90
32596: PUSH
32597: LD_VAR 0 2
32601: ARRAY
32602: PUSH
32603: LD_EXP 90
32607: PUSH
32608: LD_VAR 0 2
32612: ARRAY
32613: PUSH
32614: LD_VAR 0 3
32618: ARRAY
32619: DIFF
32620: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32621: LD_ADDR_EXP 90
32625: PUSH
32626: LD_EXP 90
32630: PPUSH
32631: LD_VAR 0 2
32635: PPUSH
32636: LD_VAR 0 5
32640: PPUSH
32641: CALL_OW 1
32645: ST_TO_ADDR
// continue ;
32646: GO 32534
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
32648: LD_EXP 90
32652: PUSH
32653: LD_VAR 0 2
32657: ARRAY
32658: PUSH
32659: LD_VAR 0 3
32663: ARRAY
32664: PPUSH
32665: CALL 57572 0 1
32669: PUSH
32670: LD_EXP 90
32674: PUSH
32675: LD_VAR 0 2
32679: ARRAY
32680: PUSH
32681: LD_VAR 0 3
32685: ARRAY
32686: PPUSH
32687: CALL_OW 255
32691: PPUSH
32692: LD_EXP 89
32696: PUSH
32697: LD_VAR 0 2
32701: ARRAY
32702: PUSH
32703: LD_VAR 0 4
32707: ARRAY
32708: PUSH
32709: LD_INT 1
32711: ARRAY
32712: PPUSH
32713: LD_EXP 89
32717: PUSH
32718: LD_VAR 0 2
32722: ARRAY
32723: PUSH
32724: LD_VAR 0 4
32728: ARRAY
32729: PUSH
32730: LD_INT 2
32732: ARRAY
32733: PPUSH
32734: LD_INT 15
32736: PPUSH
32737: CALL 58532 0 4
32741: PUSH
32742: LD_INT 4
32744: ARRAY
32745: PUSH
32746: LD_EXP 90
32750: PUSH
32751: LD_VAR 0 2
32755: ARRAY
32756: PUSH
32757: LD_VAR 0 3
32761: ARRAY
32762: PPUSH
32763: LD_INT 10
32765: PPUSH
32766: CALL 60229 0 2
32770: PUSH
32771: LD_INT 4
32773: ARRAY
32774: OR
32775: AND
32776: IFFALSE 32799
// ComStop ( mc_miners [ i ] [ j ] ) ;
32778: LD_EXP 90
32782: PUSH
32783: LD_VAR 0 2
32787: ARRAY
32788: PUSH
32789: LD_VAR 0 3
32793: ARRAY
32794: PPUSH
32795: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32799: LD_EXP 90
32803: PUSH
32804: LD_VAR 0 2
32808: ARRAY
32809: PUSH
32810: LD_VAR 0 3
32814: ARRAY
32815: PPUSH
32816: CALL_OW 257
32820: PUSH
32821: LD_INT 1
32823: EQUAL
32824: PUSH
32825: LD_EXP 90
32829: PUSH
32830: LD_VAR 0 2
32834: ARRAY
32835: PUSH
32836: LD_VAR 0 3
32840: ARRAY
32841: PPUSH
32842: CALL_OW 459
32846: NOT
32847: AND
32848: PUSH
32849: LD_EXP 90
32853: PUSH
32854: LD_VAR 0 2
32858: ARRAY
32859: PUSH
32860: LD_VAR 0 3
32864: ARRAY
32865: PPUSH
32866: CALL_OW 255
32870: PPUSH
32871: LD_EXP 89
32875: PUSH
32876: LD_VAR 0 2
32880: ARRAY
32881: PUSH
32882: LD_VAR 0 4
32886: ARRAY
32887: PUSH
32888: LD_INT 1
32890: ARRAY
32891: PPUSH
32892: LD_EXP 89
32896: PUSH
32897: LD_VAR 0 2
32901: ARRAY
32902: PUSH
32903: LD_VAR 0 4
32907: ARRAY
32908: PUSH
32909: LD_INT 2
32911: ARRAY
32912: PPUSH
32913: LD_INT 15
32915: PPUSH
32916: CALL 58532 0 4
32920: PUSH
32921: LD_INT 4
32923: ARRAY
32924: PUSH
32925: LD_INT 0
32927: EQUAL
32928: AND
32929: PUSH
32930: LD_EXP 90
32934: PUSH
32935: LD_VAR 0 2
32939: ARRAY
32940: PUSH
32941: LD_VAR 0 3
32945: ARRAY
32946: PPUSH
32947: CALL_OW 314
32951: NOT
32952: AND
32953: IFFALSE 33129
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32955: LD_EXP 90
32959: PUSH
32960: LD_VAR 0 2
32964: ARRAY
32965: PUSH
32966: LD_VAR 0 3
32970: ARRAY
32971: PPUSH
32972: CALL_OW 310
32976: IFFALSE 32999
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32978: LD_EXP 90
32982: PUSH
32983: LD_VAR 0 2
32987: ARRAY
32988: PUSH
32989: LD_VAR 0 3
32993: ARRAY
32994: PPUSH
32995: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32999: LD_EXP 90
33003: PUSH
33004: LD_VAR 0 2
33008: ARRAY
33009: PUSH
33010: LD_VAR 0 3
33014: ARRAY
33015: PPUSH
33016: CALL_OW 314
33020: NOT
33021: IFFALSE 33089
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
33023: LD_EXP 90
33027: PUSH
33028: LD_VAR 0 2
33032: ARRAY
33033: PUSH
33034: LD_VAR 0 3
33038: ARRAY
33039: PPUSH
33040: LD_EXP 89
33044: PUSH
33045: LD_VAR 0 2
33049: ARRAY
33050: PUSH
33051: LD_VAR 0 4
33055: ARRAY
33056: PUSH
33057: LD_INT 1
33059: ARRAY
33060: PPUSH
33061: LD_EXP 89
33065: PUSH
33066: LD_VAR 0 2
33070: ARRAY
33071: PUSH
33072: LD_VAR 0 4
33076: ARRAY
33077: PUSH
33078: LD_INT 2
33080: ARRAY
33081: PPUSH
33082: LD_INT 0
33084: PPUSH
33085: CALL_OW 193
// k := k + 1 ;
33089: LD_ADDR_VAR 0 4
33093: PUSH
33094: LD_VAR 0 4
33098: PUSH
33099: LD_INT 1
33101: PLUS
33102: ST_TO_ADDR
// if k > mc_mines [ i ] then
33103: LD_VAR 0 4
33107: PUSH
33108: LD_EXP 89
33112: PUSH
33113: LD_VAR 0 2
33117: ARRAY
33118: GREATER
33119: IFFALSE 33129
// k := 1 ;
33121: LD_ADDR_VAR 0 4
33125: PUSH
33126: LD_INT 1
33128: ST_TO_ADDR
// end ; end ;
33129: GO 32534
33131: POP
33132: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33133: LD_ADDR_VAR 0 5
33137: PUSH
33138: LD_EXP 76
33142: PUSH
33143: LD_VAR 0 2
33147: ARRAY
33148: PPUSH
33149: LD_INT 2
33151: PUSH
33152: LD_INT 30
33154: PUSH
33155: LD_INT 4
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 30
33164: PUSH
33165: LD_INT 5
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 30
33174: PUSH
33175: LD_INT 32
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: LIST
33186: LIST
33187: PPUSH
33188: CALL_OW 72
33192: ST_TO_ADDR
// if not tmp then
33193: LD_VAR 0 5
33197: NOT
33198: IFFALSE 33202
// continue ;
33200: GO 32451
// list := [ ] ;
33202: LD_ADDR_VAR 0 6
33206: PUSH
33207: EMPTY
33208: ST_TO_ADDR
// for j in tmp do
33209: LD_ADDR_VAR 0 3
33213: PUSH
33214: LD_VAR 0 5
33218: PUSH
33219: FOR_IN
33220: IFFALSE 33289
// begin for k in UnitsInside ( j ) do
33222: LD_ADDR_VAR 0 4
33226: PUSH
33227: LD_VAR 0 3
33231: PPUSH
33232: CALL_OW 313
33236: PUSH
33237: FOR_IN
33238: IFFALSE 33285
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33240: LD_VAR 0 4
33244: PPUSH
33245: CALL_OW 257
33249: PUSH
33250: LD_INT 1
33252: EQUAL
33253: PUSH
33254: LD_VAR 0 4
33258: PPUSH
33259: CALL_OW 459
33263: NOT
33264: AND
33265: IFFALSE 33283
// list := list ^ k ;
33267: LD_ADDR_VAR 0 6
33271: PUSH
33272: LD_VAR 0 6
33276: PUSH
33277: LD_VAR 0 4
33281: ADD
33282: ST_TO_ADDR
33283: GO 33237
33285: POP
33286: POP
// end ;
33287: GO 33219
33289: POP
33290: POP
// list := list diff mc_miners [ i ] ;
33291: LD_ADDR_VAR 0 6
33295: PUSH
33296: LD_VAR 0 6
33300: PUSH
33301: LD_EXP 90
33305: PUSH
33306: LD_VAR 0 2
33310: ARRAY
33311: DIFF
33312: ST_TO_ADDR
// if not list then
33313: LD_VAR 0 6
33317: NOT
33318: IFFALSE 33322
// continue ;
33320: GO 32451
// k := mc_mines [ i ] - mc_miners [ i ] ;
33322: LD_ADDR_VAR 0 4
33326: PUSH
33327: LD_EXP 89
33331: PUSH
33332: LD_VAR 0 2
33336: ARRAY
33337: PUSH
33338: LD_EXP 90
33342: PUSH
33343: LD_VAR 0 2
33347: ARRAY
33348: MINUS
33349: ST_TO_ADDR
// if k > list then
33350: LD_VAR 0 4
33354: PUSH
33355: LD_VAR 0 6
33359: GREATER
33360: IFFALSE 33372
// k := list ;
33362: LD_ADDR_VAR 0 4
33366: PUSH
33367: LD_VAR 0 6
33371: ST_TO_ADDR
// for j = 1 to k do
33372: LD_ADDR_VAR 0 3
33376: PUSH
33377: DOUBLE
33378: LD_INT 1
33380: DEC
33381: ST_TO_ADDR
33382: LD_VAR 0 4
33386: PUSH
33387: FOR_TO
33388: IFFALSE 33442
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33390: LD_ADDR_EXP 90
33394: PUSH
33395: LD_EXP 90
33399: PPUSH
33400: LD_VAR 0 2
33404: PUSH
33405: LD_EXP 90
33409: PUSH
33410: LD_VAR 0 2
33414: ARRAY
33415: PUSH
33416: LD_INT 1
33418: PLUS
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PPUSH
33424: LD_VAR 0 6
33428: PUSH
33429: LD_VAR 0 3
33433: ARRAY
33434: PPUSH
33435: CALL 57636 0 3
33439: ST_TO_ADDR
33440: GO 33387
33442: POP
33443: POP
// end ;
33444: GO 32451
33446: POP
33447: POP
// end ;
33448: LD_VAR 0 1
33452: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33453: LD_INT 0
33455: PPUSH
33456: PPUSH
33457: PPUSH
33458: PPUSH
33459: PPUSH
33460: PPUSH
33461: PPUSH
33462: PPUSH
33463: PPUSH
33464: PPUSH
// if not mc_bases then
33465: LD_EXP 76
33469: NOT
33470: IFFALSE 33474
// exit ;
33472: GO 35224
// for i = 1 to mc_bases do
33474: LD_ADDR_VAR 0 2
33478: PUSH
33479: DOUBLE
33480: LD_INT 1
33482: DEC
33483: ST_TO_ADDR
33484: LD_EXP 76
33488: PUSH
33489: FOR_TO
33490: IFFALSE 35222
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33492: LD_EXP 76
33496: PUSH
33497: LD_VAR 0 2
33501: ARRAY
33502: NOT
33503: PUSH
33504: LD_EXP 83
33508: PUSH
33509: LD_VAR 0 2
33513: ARRAY
33514: OR
33515: IFFALSE 33519
// continue ;
33517: GO 33489
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33519: LD_EXP 92
33523: PUSH
33524: LD_VAR 0 2
33528: ARRAY
33529: NOT
33530: PUSH
33531: LD_EXP 93
33535: PUSH
33536: LD_VAR 0 2
33540: ARRAY
33541: AND
33542: IFFALSE 33580
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33544: LD_ADDR_EXP 93
33548: PUSH
33549: LD_EXP 93
33553: PPUSH
33554: LD_VAR 0 2
33558: PPUSH
33559: EMPTY
33560: PPUSH
33561: CALL_OW 1
33565: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33566: LD_VAR 0 2
33570: PPUSH
33571: LD_INT 107
33573: PPUSH
33574: CALL 24334 0 2
// continue ;
33578: GO 33489
// end ; target := [ ] ;
33580: LD_ADDR_VAR 0 6
33584: PUSH
33585: EMPTY
33586: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33587: LD_ADDR_VAR 0 3
33591: PUSH
33592: DOUBLE
33593: LD_EXP 92
33597: PUSH
33598: LD_VAR 0 2
33602: ARRAY
33603: INC
33604: ST_TO_ADDR
33605: LD_INT 1
33607: PUSH
33608: FOR_DOWNTO
33609: IFFALSE 33869
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33611: LD_EXP 92
33615: PUSH
33616: LD_VAR 0 2
33620: ARRAY
33621: PUSH
33622: LD_VAR 0 3
33626: ARRAY
33627: PUSH
33628: LD_INT 2
33630: ARRAY
33631: PPUSH
33632: LD_EXP 92
33636: PUSH
33637: LD_VAR 0 2
33641: ARRAY
33642: PUSH
33643: LD_VAR 0 3
33647: ARRAY
33648: PUSH
33649: LD_INT 3
33651: ARRAY
33652: PPUSH
33653: CALL_OW 488
33657: PUSH
33658: LD_EXP 92
33662: PUSH
33663: LD_VAR 0 2
33667: ARRAY
33668: PUSH
33669: LD_VAR 0 3
33673: ARRAY
33674: PUSH
33675: LD_INT 2
33677: ARRAY
33678: PPUSH
33679: LD_EXP 92
33683: PUSH
33684: LD_VAR 0 2
33688: ARRAY
33689: PUSH
33690: LD_VAR 0 3
33694: ARRAY
33695: PUSH
33696: LD_INT 3
33698: ARRAY
33699: PPUSH
33700: CALL_OW 284
33704: PUSH
33705: LD_INT 0
33707: EQUAL
33708: AND
33709: IFFALSE 33764
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33711: LD_ADDR_VAR 0 5
33715: PUSH
33716: LD_EXP 92
33720: PUSH
33721: LD_VAR 0 2
33725: ARRAY
33726: PPUSH
33727: LD_VAR 0 3
33731: PPUSH
33732: CALL_OW 3
33736: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33737: LD_ADDR_EXP 92
33741: PUSH
33742: LD_EXP 92
33746: PPUSH
33747: LD_VAR 0 2
33751: PPUSH
33752: LD_VAR 0 5
33756: PPUSH
33757: CALL_OW 1
33761: ST_TO_ADDR
// continue ;
33762: GO 33608
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33764: LD_EXP 76
33768: PUSH
33769: LD_VAR 0 2
33773: ARRAY
33774: PUSH
33775: LD_INT 1
33777: ARRAY
33778: PPUSH
33779: CALL_OW 255
33783: PPUSH
33784: LD_EXP 92
33788: PUSH
33789: LD_VAR 0 2
33793: ARRAY
33794: PUSH
33795: LD_VAR 0 3
33799: ARRAY
33800: PUSH
33801: LD_INT 2
33803: ARRAY
33804: PPUSH
33805: LD_EXP 92
33809: PUSH
33810: LD_VAR 0 2
33814: ARRAY
33815: PUSH
33816: LD_VAR 0 3
33820: ARRAY
33821: PUSH
33822: LD_INT 3
33824: ARRAY
33825: PPUSH
33826: LD_INT 30
33828: PPUSH
33829: CALL 58532 0 4
33833: PUSH
33834: LD_INT 4
33836: ARRAY
33837: PUSH
33838: LD_INT 0
33840: EQUAL
33841: IFFALSE 33867
// begin target := mc_crates [ i ] [ j ] ;
33843: LD_ADDR_VAR 0 6
33847: PUSH
33848: LD_EXP 92
33852: PUSH
33853: LD_VAR 0 2
33857: ARRAY
33858: PUSH
33859: LD_VAR 0 3
33863: ARRAY
33864: ST_TO_ADDR
// break ;
33865: GO 33869
// end ; end ;
33867: GO 33608
33869: POP
33870: POP
// if not target then
33871: LD_VAR 0 6
33875: NOT
33876: IFFALSE 33880
// continue ;
33878: GO 33489
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33880: LD_ADDR_VAR 0 7
33884: PUSH
33885: LD_EXP 95
33889: PUSH
33890: LD_VAR 0 2
33894: ARRAY
33895: PPUSH
33896: LD_INT 2
33898: PUSH
33899: LD_INT 3
33901: PUSH
33902: LD_INT 58
33904: PUSH
33905: EMPTY
33906: LIST
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 61
33914: PUSH
33915: EMPTY
33916: LIST
33917: PUSH
33918: LD_INT 33
33920: PUSH
33921: LD_INT 5
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 33
33930: PUSH
33931: LD_INT 3
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 2
33947: PUSH
33948: LD_INT 34
33950: PUSH
33951: LD_INT 32
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 34
33960: PUSH
33961: LD_INT 51
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 34
33970: PUSH
33971: LD_INT 12
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: LIST
33982: LIST
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PPUSH
33988: CALL_OW 72
33992: ST_TO_ADDR
// if not cargo then
33993: LD_VAR 0 7
33997: NOT
33998: IFFALSE 34641
// begin if mc_crates_collector [ i ] < 5 then
34000: LD_EXP 93
34004: PUSH
34005: LD_VAR 0 2
34009: ARRAY
34010: PUSH
34011: LD_INT 5
34013: LESS
34014: IFFALSE 34380
// begin if mc_ape [ i ] then
34016: LD_EXP 105
34020: PUSH
34021: LD_VAR 0 2
34025: ARRAY
34026: IFFALSE 34073
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34028: LD_ADDR_VAR 0 5
34032: PUSH
34033: LD_EXP 105
34037: PUSH
34038: LD_VAR 0 2
34042: ARRAY
34043: PPUSH
34044: LD_INT 25
34046: PUSH
34047: LD_INT 16
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 24
34056: PUSH
34057: LD_INT 750
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PPUSH
34068: CALL_OW 72
34072: ST_TO_ADDR
// if not tmp then
34073: LD_VAR 0 5
34077: NOT
34078: IFFALSE 34125
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34080: LD_ADDR_VAR 0 5
34084: PUSH
34085: LD_EXP 76
34089: PUSH
34090: LD_VAR 0 2
34094: ARRAY
34095: PPUSH
34096: LD_INT 25
34098: PUSH
34099: LD_INT 2
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 24
34108: PUSH
34109: LD_INT 750
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PPUSH
34120: CALL_OW 72
34124: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34125: LD_EXP 105
34129: PUSH
34130: LD_VAR 0 2
34134: ARRAY
34135: PUSH
34136: LD_EXP 76
34140: PUSH
34141: LD_VAR 0 2
34145: ARRAY
34146: PPUSH
34147: LD_INT 25
34149: PUSH
34150: LD_INT 2
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 24
34159: PUSH
34160: LD_INT 750
34162: PUSH
34163: EMPTY
34164: LIST
34165: LIST
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PPUSH
34171: CALL_OW 72
34175: AND
34176: PUSH
34177: LD_VAR 0 5
34181: PUSH
34182: LD_INT 5
34184: LESS
34185: AND
34186: IFFALSE 34268
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34188: LD_ADDR_VAR 0 3
34192: PUSH
34193: LD_EXP 76
34197: PUSH
34198: LD_VAR 0 2
34202: ARRAY
34203: PPUSH
34204: LD_INT 25
34206: PUSH
34207: LD_INT 2
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 24
34216: PUSH
34217: LD_INT 750
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PPUSH
34228: CALL_OW 72
34232: PUSH
34233: FOR_IN
34234: IFFALSE 34266
// begin tmp := tmp union j ;
34236: LD_ADDR_VAR 0 5
34240: PUSH
34241: LD_VAR 0 5
34245: PUSH
34246: LD_VAR 0 3
34250: UNION
34251: ST_TO_ADDR
// if tmp >= 5 then
34252: LD_VAR 0 5
34256: PUSH
34257: LD_INT 5
34259: GREATEREQUAL
34260: IFFALSE 34264
// break ;
34262: GO 34266
// end ;
34264: GO 34233
34266: POP
34267: POP
// end ; if not tmp then
34268: LD_VAR 0 5
34272: NOT
34273: IFFALSE 34277
// continue ;
34275: GO 33489
// for j in tmp do
34277: LD_ADDR_VAR 0 3
34281: PUSH
34282: LD_VAR 0 5
34286: PUSH
34287: FOR_IN
34288: IFFALSE 34378
// if not GetTag ( j ) then
34290: LD_VAR 0 3
34294: PPUSH
34295: CALL_OW 110
34299: NOT
34300: IFFALSE 34376
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34302: LD_ADDR_EXP 93
34306: PUSH
34307: LD_EXP 93
34311: PPUSH
34312: LD_VAR 0 2
34316: PUSH
34317: LD_EXP 93
34321: PUSH
34322: LD_VAR 0 2
34326: ARRAY
34327: PUSH
34328: LD_INT 1
34330: PLUS
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PPUSH
34336: LD_VAR 0 3
34340: PPUSH
34341: CALL 57636 0 3
34345: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34346: LD_VAR 0 3
34350: PPUSH
34351: LD_INT 107
34353: PPUSH
34354: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34358: LD_EXP 93
34362: PUSH
34363: LD_VAR 0 2
34367: ARRAY
34368: PUSH
34369: LD_INT 5
34371: GREATEREQUAL
34372: IFFALSE 34376
// break ;
34374: GO 34378
// end ;
34376: GO 34287
34378: POP
34379: POP
// end ; if mc_crates_collector [ i ] and target then
34380: LD_EXP 93
34384: PUSH
34385: LD_VAR 0 2
34389: ARRAY
34390: PUSH
34391: LD_VAR 0 6
34395: AND
34396: IFFALSE 34639
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34398: LD_EXP 93
34402: PUSH
34403: LD_VAR 0 2
34407: ARRAY
34408: PUSH
34409: LD_VAR 0 6
34413: PUSH
34414: LD_INT 1
34416: ARRAY
34417: LESS
34418: IFFALSE 34438
// tmp := mc_crates_collector [ i ] else
34420: LD_ADDR_VAR 0 5
34424: PUSH
34425: LD_EXP 93
34429: PUSH
34430: LD_VAR 0 2
34434: ARRAY
34435: ST_TO_ADDR
34436: GO 34452
// tmp := target [ 1 ] ;
34438: LD_ADDR_VAR 0 5
34442: PUSH
34443: LD_VAR 0 6
34447: PUSH
34448: LD_INT 1
34450: ARRAY
34451: ST_TO_ADDR
// k := 0 ;
34452: LD_ADDR_VAR 0 4
34456: PUSH
34457: LD_INT 0
34459: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34460: LD_ADDR_VAR 0 3
34464: PUSH
34465: LD_EXP 93
34469: PUSH
34470: LD_VAR 0 2
34474: ARRAY
34475: PUSH
34476: FOR_IN
34477: IFFALSE 34637
// begin k := k + 1 ;
34479: LD_ADDR_VAR 0 4
34483: PUSH
34484: LD_VAR 0 4
34488: PUSH
34489: LD_INT 1
34491: PLUS
34492: ST_TO_ADDR
// if k > tmp then
34493: LD_VAR 0 4
34497: PUSH
34498: LD_VAR 0 5
34502: GREATER
34503: IFFALSE 34507
// break ;
34505: GO 34637
// if not GetClass ( j ) in [ 2 , 16 ] then
34507: LD_VAR 0 3
34511: PPUSH
34512: CALL_OW 257
34516: PUSH
34517: LD_INT 2
34519: PUSH
34520: LD_INT 16
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: IN
34527: NOT
34528: IFFALSE 34581
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34530: LD_ADDR_EXP 93
34534: PUSH
34535: LD_EXP 93
34539: PPUSH
34540: LD_VAR 0 2
34544: PPUSH
34545: LD_EXP 93
34549: PUSH
34550: LD_VAR 0 2
34554: ARRAY
34555: PUSH
34556: LD_VAR 0 3
34560: DIFF
34561: PPUSH
34562: CALL_OW 1
34566: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34567: LD_VAR 0 3
34571: PPUSH
34572: LD_INT 0
34574: PPUSH
34575: CALL_OW 109
// continue ;
34579: GO 34476
// end ; if IsInUnit ( j ) then
34581: LD_VAR 0 3
34585: PPUSH
34586: CALL_OW 310
34590: IFFALSE 34601
// ComExitBuilding ( j ) ;
34592: LD_VAR 0 3
34596: PPUSH
34597: CALL_OW 122
// wait ( 3 ) ;
34601: LD_INT 3
34603: PPUSH
34604: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34608: LD_VAR 0 3
34612: PPUSH
34613: LD_VAR 0 6
34617: PUSH
34618: LD_INT 2
34620: ARRAY
34621: PPUSH
34622: LD_VAR 0 6
34626: PUSH
34627: LD_INT 3
34629: ARRAY
34630: PPUSH
34631: CALL_OW 117
// end ;
34635: GO 34476
34637: POP
34638: POP
// end ; end else
34639: GO 35220
// begin for j in cargo do
34641: LD_ADDR_VAR 0 3
34645: PUSH
34646: LD_VAR 0 7
34650: PUSH
34651: FOR_IN
34652: IFFALSE 35218
// begin if GetTag ( j ) <> 0 then
34654: LD_VAR 0 3
34658: PPUSH
34659: CALL_OW 110
34663: PUSH
34664: LD_INT 0
34666: NONEQUAL
34667: IFFALSE 34671
// continue ;
34669: GO 34651
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34671: LD_VAR 0 3
34675: PPUSH
34676: CALL_OW 256
34680: PUSH
34681: LD_INT 1000
34683: LESS
34684: PUSH
34685: LD_VAR 0 3
34689: PPUSH
34690: LD_EXP 100
34694: PUSH
34695: LD_VAR 0 2
34699: ARRAY
34700: PPUSH
34701: CALL_OW 308
34705: NOT
34706: AND
34707: IFFALSE 34729
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34709: LD_VAR 0 3
34713: PPUSH
34714: LD_EXP 100
34718: PUSH
34719: LD_VAR 0 2
34723: ARRAY
34724: PPUSH
34725: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34729: LD_VAR 0 3
34733: PPUSH
34734: CALL_OW 256
34738: PUSH
34739: LD_INT 1000
34741: LESS
34742: PUSH
34743: LD_VAR 0 3
34747: PPUSH
34748: LD_EXP 100
34752: PUSH
34753: LD_VAR 0 2
34757: ARRAY
34758: PPUSH
34759: CALL_OW 308
34763: AND
34764: IFFALSE 34768
// continue ;
34766: GO 34651
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34768: LD_VAR 0 3
34772: PPUSH
34773: CALL_OW 262
34777: PUSH
34778: LD_INT 2
34780: EQUAL
34781: PUSH
34782: LD_VAR 0 3
34786: PPUSH
34787: CALL_OW 261
34791: PUSH
34792: LD_INT 15
34794: LESS
34795: AND
34796: IFFALSE 34800
// continue ;
34798: GO 34651
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34800: LD_VAR 0 3
34804: PPUSH
34805: CALL_OW 262
34809: PUSH
34810: LD_INT 1
34812: EQUAL
34813: PUSH
34814: LD_VAR 0 3
34818: PPUSH
34819: CALL_OW 261
34823: PUSH
34824: LD_INT 10
34826: LESS
34827: AND
34828: IFFALSE 35157
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34830: LD_ADDR_VAR 0 8
34834: PUSH
34835: LD_EXP 76
34839: PUSH
34840: LD_VAR 0 2
34844: ARRAY
34845: PPUSH
34846: LD_INT 2
34848: PUSH
34849: LD_INT 30
34851: PUSH
34852: LD_INT 0
34854: PUSH
34855: EMPTY
34856: LIST
34857: LIST
34858: PUSH
34859: LD_INT 30
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: LIST
34873: PPUSH
34874: CALL_OW 72
34878: ST_TO_ADDR
// if not depot then
34879: LD_VAR 0 8
34883: NOT
34884: IFFALSE 34888
// continue ;
34886: GO 34651
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34888: LD_VAR 0 3
34892: PPUSH
34893: LD_VAR 0 8
34897: PPUSH
34898: LD_VAR 0 3
34902: PPUSH
34903: CALL_OW 74
34907: PPUSH
34908: CALL_OW 296
34912: PUSH
34913: LD_INT 6
34915: LESS
34916: IFFALSE 34932
// SetFuel ( j , 100 ) else
34918: LD_VAR 0 3
34922: PPUSH
34923: LD_INT 100
34925: PPUSH
34926: CALL_OW 240
34930: GO 35157
// if GetFuel ( j ) = 0 then
34932: LD_VAR 0 3
34936: PPUSH
34937: CALL_OW 261
34941: PUSH
34942: LD_INT 0
34944: EQUAL
34945: IFFALSE 35157
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34947: LD_ADDR_EXP 95
34951: PUSH
34952: LD_EXP 95
34956: PPUSH
34957: LD_VAR 0 2
34961: PPUSH
34962: LD_EXP 95
34966: PUSH
34967: LD_VAR 0 2
34971: ARRAY
34972: PUSH
34973: LD_VAR 0 3
34977: DIFF
34978: PPUSH
34979: CALL_OW 1
34983: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34984: LD_VAR 0 3
34988: PPUSH
34989: CALL_OW 263
34993: PUSH
34994: LD_INT 1
34996: EQUAL
34997: IFFALSE 35013
// ComExitVehicle ( IsInUnit ( j ) ) ;
34999: LD_VAR 0 3
35003: PPUSH
35004: CALL_OW 310
35008: PPUSH
35009: CALL_OW 121
// if GetControl ( j ) = control_remote then
35013: LD_VAR 0 3
35017: PPUSH
35018: CALL_OW 263
35022: PUSH
35023: LD_INT 2
35025: EQUAL
35026: IFFALSE 35037
// ComUnlink ( j ) ;
35028: LD_VAR 0 3
35032: PPUSH
35033: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35037: LD_ADDR_VAR 0 9
35041: PUSH
35042: LD_VAR 0 2
35046: PPUSH
35047: LD_INT 3
35049: PPUSH
35050: CALL 44510 0 2
35054: ST_TO_ADDR
// if fac then
35055: LD_VAR 0 9
35059: IFFALSE 35155
// begin for k in fac do
35061: LD_ADDR_VAR 0 4
35065: PUSH
35066: LD_VAR 0 9
35070: PUSH
35071: FOR_IN
35072: IFFALSE 35153
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35074: LD_ADDR_VAR 0 10
35078: PUSH
35079: LD_VAR 0 9
35083: PPUSH
35084: LD_VAR 0 3
35088: PPUSH
35089: CALL_OW 265
35093: PPUSH
35094: LD_VAR 0 3
35098: PPUSH
35099: CALL_OW 262
35103: PPUSH
35104: LD_VAR 0 3
35108: PPUSH
35109: CALL_OW 263
35113: PPUSH
35114: LD_VAR 0 3
35118: PPUSH
35119: CALL_OW 264
35123: PPUSH
35124: CALL 55168 0 5
35128: ST_TO_ADDR
// if components then
35129: LD_VAR 0 10
35133: IFFALSE 35151
// begin MC_InsertProduceList ( i , components ) ;
35135: LD_VAR 0 2
35139: PPUSH
35140: LD_VAR 0 10
35144: PPUSH
35145: CALL 44055 0 2
// break ;
35149: GO 35153
// end ; end ;
35151: GO 35071
35153: POP
35154: POP
// end ; continue ;
35155: GO 34651
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35157: LD_VAR 0 3
35161: PPUSH
35162: LD_INT 1
35164: PPUSH
35165: CALL_OW 289
35169: PUSH
35170: LD_INT 100
35172: LESS
35173: PUSH
35174: LD_VAR 0 3
35178: PPUSH
35179: CALL_OW 314
35183: NOT
35184: AND
35185: IFFALSE 35214
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35187: LD_VAR 0 3
35191: PPUSH
35192: LD_VAR 0 6
35196: PUSH
35197: LD_INT 2
35199: ARRAY
35200: PPUSH
35201: LD_VAR 0 6
35205: PUSH
35206: LD_INT 3
35208: ARRAY
35209: PPUSH
35210: CALL_OW 117
// break ;
35214: GO 35218
// end ;
35216: GO 34651
35218: POP
35219: POP
// end ; end ;
35220: GO 33489
35222: POP
35223: POP
// end ;
35224: LD_VAR 0 1
35228: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35229: LD_INT 0
35231: PPUSH
35232: PPUSH
35233: PPUSH
35234: PPUSH
// if not mc_bases then
35235: LD_EXP 76
35239: NOT
35240: IFFALSE 35244
// exit ;
35242: GO 35405
// for i = 1 to mc_bases do
35244: LD_ADDR_VAR 0 2
35248: PUSH
35249: DOUBLE
35250: LD_INT 1
35252: DEC
35253: ST_TO_ADDR
35254: LD_EXP 76
35258: PUSH
35259: FOR_TO
35260: IFFALSE 35403
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35262: LD_ADDR_VAR 0 4
35266: PUSH
35267: LD_EXP 95
35271: PUSH
35272: LD_VAR 0 2
35276: ARRAY
35277: PUSH
35278: LD_EXP 98
35282: PUSH
35283: LD_VAR 0 2
35287: ARRAY
35288: UNION
35289: PPUSH
35290: LD_INT 33
35292: PUSH
35293: LD_INT 2
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PPUSH
35300: CALL_OW 72
35304: ST_TO_ADDR
// if tmp then
35305: LD_VAR 0 4
35309: IFFALSE 35401
// for j in tmp do
35311: LD_ADDR_VAR 0 3
35315: PUSH
35316: LD_VAR 0 4
35320: PUSH
35321: FOR_IN
35322: IFFALSE 35399
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35324: LD_VAR 0 3
35328: PPUSH
35329: CALL_OW 312
35333: NOT
35334: PUSH
35335: LD_VAR 0 3
35339: PPUSH
35340: CALL_OW 256
35344: PUSH
35345: LD_INT 250
35347: GREATEREQUAL
35348: AND
35349: IFFALSE 35362
// Connect ( j ) else
35351: LD_VAR 0 3
35355: PPUSH
35356: CALL 60569 0 1
35360: GO 35397
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35362: LD_VAR 0 3
35366: PPUSH
35367: CALL_OW 256
35371: PUSH
35372: LD_INT 250
35374: LESS
35375: PUSH
35376: LD_VAR 0 3
35380: PPUSH
35381: CALL_OW 312
35385: AND
35386: IFFALSE 35397
// ComUnlink ( j ) ;
35388: LD_VAR 0 3
35392: PPUSH
35393: CALL_OW 136
35397: GO 35321
35399: POP
35400: POP
// end ;
35401: GO 35259
35403: POP
35404: POP
// end ;
35405: LD_VAR 0 1
35409: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35410: LD_INT 0
35412: PPUSH
35413: PPUSH
35414: PPUSH
35415: PPUSH
35416: PPUSH
// if not mc_bases then
35417: LD_EXP 76
35421: NOT
35422: IFFALSE 35426
// exit ;
35424: GO 35871
// for i = 1 to mc_bases do
35426: LD_ADDR_VAR 0 2
35430: PUSH
35431: DOUBLE
35432: LD_INT 1
35434: DEC
35435: ST_TO_ADDR
35436: LD_EXP 76
35440: PUSH
35441: FOR_TO
35442: IFFALSE 35869
// begin if not mc_produce [ i ] then
35444: LD_EXP 97
35448: PUSH
35449: LD_VAR 0 2
35453: ARRAY
35454: NOT
35455: IFFALSE 35459
// continue ;
35457: GO 35441
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35459: LD_ADDR_VAR 0 5
35463: PUSH
35464: LD_EXP 76
35468: PUSH
35469: LD_VAR 0 2
35473: ARRAY
35474: PPUSH
35475: LD_INT 30
35477: PUSH
35478: LD_INT 3
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PPUSH
35485: CALL_OW 72
35489: ST_TO_ADDR
// if not fac then
35490: LD_VAR 0 5
35494: NOT
35495: IFFALSE 35499
// continue ;
35497: GO 35441
// for j in fac do
35499: LD_ADDR_VAR 0 3
35503: PUSH
35504: LD_VAR 0 5
35508: PUSH
35509: FOR_IN
35510: IFFALSE 35865
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35512: LD_VAR 0 3
35516: PPUSH
35517: CALL_OW 461
35521: PUSH
35522: LD_INT 2
35524: NONEQUAL
35525: PUSH
35526: LD_VAR 0 3
35530: PPUSH
35531: LD_INT 15
35533: PPUSH
35534: CALL 60229 0 2
35538: PUSH
35539: LD_INT 4
35541: ARRAY
35542: OR
35543: IFFALSE 35547
// continue ;
35545: GO 35509
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35547: LD_VAR 0 3
35551: PPUSH
35552: LD_EXP 97
35556: PUSH
35557: LD_VAR 0 2
35561: ARRAY
35562: PUSH
35563: LD_INT 1
35565: ARRAY
35566: PUSH
35567: LD_INT 1
35569: ARRAY
35570: PPUSH
35571: LD_EXP 97
35575: PUSH
35576: LD_VAR 0 2
35580: ARRAY
35581: PUSH
35582: LD_INT 1
35584: ARRAY
35585: PUSH
35586: LD_INT 2
35588: ARRAY
35589: PPUSH
35590: LD_EXP 97
35594: PUSH
35595: LD_VAR 0 2
35599: ARRAY
35600: PUSH
35601: LD_INT 1
35603: ARRAY
35604: PUSH
35605: LD_INT 3
35607: ARRAY
35608: PPUSH
35609: LD_EXP 97
35613: PUSH
35614: LD_VAR 0 2
35618: ARRAY
35619: PUSH
35620: LD_INT 1
35622: ARRAY
35623: PUSH
35624: LD_INT 4
35626: ARRAY
35627: PPUSH
35628: CALL_OW 448
35632: PUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: LD_EXP 97
35642: PUSH
35643: LD_VAR 0 2
35647: ARRAY
35648: PUSH
35649: LD_INT 1
35651: ARRAY
35652: PUSH
35653: LD_INT 1
35655: ARRAY
35656: PUSH
35657: LD_EXP 97
35661: PUSH
35662: LD_VAR 0 2
35666: ARRAY
35667: PUSH
35668: LD_INT 1
35670: ARRAY
35671: PUSH
35672: LD_INT 2
35674: ARRAY
35675: PUSH
35676: LD_EXP 97
35680: PUSH
35681: LD_VAR 0 2
35685: ARRAY
35686: PUSH
35687: LD_INT 1
35689: ARRAY
35690: PUSH
35691: LD_INT 3
35693: ARRAY
35694: PUSH
35695: LD_EXP 97
35699: PUSH
35700: LD_VAR 0 2
35704: ARRAY
35705: PUSH
35706: LD_INT 1
35708: ARRAY
35709: PUSH
35710: LD_INT 4
35712: ARRAY
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: LIST
35718: LIST
35719: PPUSH
35720: CALL 63900 0 2
35724: AND
35725: IFFALSE 35863
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35727: LD_VAR 0 3
35731: PPUSH
35732: LD_EXP 97
35736: PUSH
35737: LD_VAR 0 2
35741: ARRAY
35742: PUSH
35743: LD_INT 1
35745: ARRAY
35746: PUSH
35747: LD_INT 1
35749: ARRAY
35750: PPUSH
35751: LD_EXP 97
35755: PUSH
35756: LD_VAR 0 2
35760: ARRAY
35761: PUSH
35762: LD_INT 1
35764: ARRAY
35765: PUSH
35766: LD_INT 2
35768: ARRAY
35769: PPUSH
35770: LD_EXP 97
35774: PUSH
35775: LD_VAR 0 2
35779: ARRAY
35780: PUSH
35781: LD_INT 1
35783: ARRAY
35784: PUSH
35785: LD_INT 3
35787: ARRAY
35788: PPUSH
35789: LD_EXP 97
35793: PUSH
35794: LD_VAR 0 2
35798: ARRAY
35799: PUSH
35800: LD_INT 1
35802: ARRAY
35803: PUSH
35804: LD_INT 4
35806: ARRAY
35807: PPUSH
35808: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35812: LD_ADDR_VAR 0 4
35816: PUSH
35817: LD_EXP 97
35821: PUSH
35822: LD_VAR 0 2
35826: ARRAY
35827: PPUSH
35828: LD_INT 1
35830: PPUSH
35831: CALL_OW 3
35835: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35836: LD_ADDR_EXP 97
35840: PUSH
35841: LD_EXP 97
35845: PPUSH
35846: LD_VAR 0 2
35850: PPUSH
35851: LD_VAR 0 4
35855: PPUSH
35856: CALL_OW 1
35860: ST_TO_ADDR
// break ;
35861: GO 35865
// end ; end ;
35863: GO 35509
35865: POP
35866: POP
// end ;
35867: GO 35441
35869: POP
35870: POP
// end ;
35871: LD_VAR 0 1
35875: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35876: LD_INT 0
35878: PPUSH
35879: PPUSH
35880: PPUSH
// if not mc_bases then
35881: LD_EXP 76
35885: NOT
35886: IFFALSE 35890
// exit ;
35888: GO 35979
// for i = 1 to mc_bases do
35890: LD_ADDR_VAR 0 2
35894: PUSH
35895: DOUBLE
35896: LD_INT 1
35898: DEC
35899: ST_TO_ADDR
35900: LD_EXP 76
35904: PUSH
35905: FOR_TO
35906: IFFALSE 35977
// begin if mc_attack [ i ] then
35908: LD_EXP 96
35912: PUSH
35913: LD_VAR 0 2
35917: ARRAY
35918: IFFALSE 35975
// begin tmp := mc_attack [ i ] [ 1 ] ;
35920: LD_ADDR_VAR 0 3
35924: PUSH
35925: LD_EXP 96
35929: PUSH
35930: LD_VAR 0 2
35934: ARRAY
35935: PUSH
35936: LD_INT 1
35938: ARRAY
35939: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35940: LD_ADDR_EXP 96
35944: PUSH
35945: LD_EXP 96
35949: PPUSH
35950: LD_VAR 0 2
35954: PPUSH
35955: EMPTY
35956: PPUSH
35957: CALL_OW 1
35961: ST_TO_ADDR
// Attack ( tmp ) ;
35962: LD_VAR 0 3
35966: PPUSH
35967: CALL 86113 0 1
// exit ;
35971: POP
35972: POP
35973: GO 35979
// end ; end ;
35975: GO 35905
35977: POP
35978: POP
// end ;
35979: LD_VAR 0 1
35983: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35984: LD_INT 0
35986: PPUSH
35987: PPUSH
35988: PPUSH
35989: PPUSH
35990: PPUSH
35991: PPUSH
35992: PPUSH
// if not mc_bases then
35993: LD_EXP 76
35997: NOT
35998: IFFALSE 36002
// exit ;
36000: GO 36584
// for i = 1 to mc_bases do
36002: LD_ADDR_VAR 0 2
36006: PUSH
36007: DOUBLE
36008: LD_INT 1
36010: DEC
36011: ST_TO_ADDR
36012: LD_EXP 76
36016: PUSH
36017: FOR_TO
36018: IFFALSE 36582
// begin if not mc_bases [ i ] then
36020: LD_EXP 76
36024: PUSH
36025: LD_VAR 0 2
36029: ARRAY
36030: NOT
36031: IFFALSE 36035
// continue ;
36033: GO 36017
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36035: LD_ADDR_VAR 0 7
36039: PUSH
36040: LD_EXP 76
36044: PUSH
36045: LD_VAR 0 2
36049: ARRAY
36050: PUSH
36051: LD_INT 1
36053: ARRAY
36054: PPUSH
36055: CALL 54472 0 1
36059: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36060: LD_ADDR_EXP 99
36064: PUSH
36065: LD_EXP 99
36069: PPUSH
36070: LD_VAR 0 2
36074: PPUSH
36075: LD_EXP 76
36079: PUSH
36080: LD_VAR 0 2
36084: ARRAY
36085: PUSH
36086: LD_INT 1
36088: ARRAY
36089: PPUSH
36090: CALL_OW 255
36094: PPUSH
36095: LD_EXP 101
36099: PUSH
36100: LD_VAR 0 2
36104: ARRAY
36105: PPUSH
36106: CALL 52026 0 2
36110: PPUSH
36111: CALL_OW 1
36115: ST_TO_ADDR
// if not mc_scan [ i ] then
36116: LD_EXP 99
36120: PUSH
36121: LD_VAR 0 2
36125: ARRAY
36126: NOT
36127: IFFALSE 36282
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36129: LD_ADDR_VAR 0 4
36133: PUSH
36134: LD_EXP 76
36138: PUSH
36139: LD_VAR 0 2
36143: ARRAY
36144: PPUSH
36145: LD_INT 2
36147: PUSH
36148: LD_INT 25
36150: PUSH
36151: LD_INT 5
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: PUSH
36158: LD_INT 25
36160: PUSH
36161: LD_INT 8
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 25
36170: PUSH
36171: LD_INT 9
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: PPUSH
36184: CALL_OW 72
36188: ST_TO_ADDR
// if not tmp then
36189: LD_VAR 0 4
36193: NOT
36194: IFFALSE 36198
// continue ;
36196: GO 36017
// for j in tmp do
36198: LD_ADDR_VAR 0 3
36202: PUSH
36203: LD_VAR 0 4
36207: PUSH
36208: FOR_IN
36209: IFFALSE 36280
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36211: LD_VAR 0 3
36215: PPUSH
36216: CALL_OW 310
36220: PPUSH
36221: CALL_OW 266
36225: PUSH
36226: LD_INT 5
36228: EQUAL
36229: PUSH
36230: LD_VAR 0 3
36234: PPUSH
36235: CALL_OW 257
36239: PUSH
36240: LD_INT 1
36242: EQUAL
36243: AND
36244: PUSH
36245: LD_VAR 0 3
36249: PPUSH
36250: CALL_OW 459
36254: NOT
36255: AND
36256: PUSH
36257: LD_VAR 0 7
36261: AND
36262: IFFALSE 36278
// ComChangeProfession ( j , class ) ;
36264: LD_VAR 0 3
36268: PPUSH
36269: LD_VAR 0 7
36273: PPUSH
36274: CALL_OW 123
36278: GO 36208
36280: POP
36281: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36282: LD_EXP 99
36286: PUSH
36287: LD_VAR 0 2
36291: ARRAY
36292: PUSH
36293: LD_EXP 98
36297: PUSH
36298: LD_VAR 0 2
36302: ARRAY
36303: NOT
36304: AND
36305: PUSH
36306: LD_EXP 76
36310: PUSH
36311: LD_VAR 0 2
36315: ARRAY
36316: PPUSH
36317: LD_INT 30
36319: PUSH
36320: LD_INT 32
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PPUSH
36327: CALL_OW 72
36331: NOT
36332: AND
36333: PUSH
36334: LD_EXP 76
36338: PUSH
36339: LD_VAR 0 2
36343: ARRAY
36344: PPUSH
36345: LD_INT 2
36347: PUSH
36348: LD_INT 30
36350: PUSH
36351: LD_INT 4
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 30
36360: PUSH
36361: LD_INT 5
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: LIST
36372: PPUSH
36373: CALL_OW 72
36377: NOT
36378: AND
36379: IFFALSE 36511
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36381: LD_ADDR_VAR 0 4
36385: PUSH
36386: LD_EXP 76
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PPUSH
36397: LD_INT 2
36399: PUSH
36400: LD_INT 25
36402: PUSH
36403: LD_INT 1
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 25
36412: PUSH
36413: LD_INT 5
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 25
36422: PUSH
36423: LD_INT 8
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 25
36432: PUSH
36433: LD_INT 9
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: PPUSH
36447: CALL_OW 72
36451: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36452: LD_ADDR_VAR 0 4
36456: PUSH
36457: LD_VAR 0 4
36461: PUSH
36462: LD_VAR 0 4
36466: PPUSH
36467: LD_INT 18
36469: PPUSH
36470: CALL 90896 0 2
36474: DIFF
36475: ST_TO_ADDR
// if tmp then
36476: LD_VAR 0 4
36480: IFFALSE 36511
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36482: LD_VAR 0 2
36486: PPUSH
36487: LD_VAR 0 4
36491: PPUSH
36492: LD_EXP 101
36496: PUSH
36497: LD_VAR 0 2
36501: ARRAY
36502: PPUSH
36503: CALL 52061 0 3
// exit ;
36507: POP
36508: POP
36509: GO 36584
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36511: LD_EXP 99
36515: PUSH
36516: LD_VAR 0 2
36520: ARRAY
36521: PUSH
36522: LD_EXP 98
36526: PUSH
36527: LD_VAR 0 2
36531: ARRAY
36532: AND
36533: IFFALSE 36580
// begin tmp := mc_defender [ i ] ;
36535: LD_ADDR_VAR 0 4
36539: PUSH
36540: LD_EXP 98
36544: PUSH
36545: LD_VAR 0 2
36549: ARRAY
36550: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36551: LD_VAR 0 2
36555: PPUSH
36556: LD_VAR 0 4
36560: PPUSH
36561: LD_EXP 99
36565: PUSH
36566: LD_VAR 0 2
36570: ARRAY
36571: PPUSH
36572: CALL 52622 0 3
// exit ;
36576: POP
36577: POP
36578: GO 36584
// end ; end ;
36580: GO 36017
36582: POP
36583: POP
// end ;
36584: LD_VAR 0 1
36588: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36589: LD_INT 0
36591: PPUSH
36592: PPUSH
36593: PPUSH
36594: PPUSH
36595: PPUSH
36596: PPUSH
36597: PPUSH
36598: PPUSH
36599: PPUSH
36600: PPUSH
36601: PPUSH
// if not mc_bases then
36602: LD_EXP 76
36606: NOT
36607: IFFALSE 36611
// exit ;
36609: GO 37698
// for i = 1 to mc_bases do
36611: LD_ADDR_VAR 0 2
36615: PUSH
36616: DOUBLE
36617: LD_INT 1
36619: DEC
36620: ST_TO_ADDR
36621: LD_EXP 76
36625: PUSH
36626: FOR_TO
36627: IFFALSE 37696
// begin tmp := mc_lab [ i ] ;
36629: LD_ADDR_VAR 0 6
36633: PUSH
36634: LD_EXP 109
36638: PUSH
36639: LD_VAR 0 2
36643: ARRAY
36644: ST_TO_ADDR
// if not tmp then
36645: LD_VAR 0 6
36649: NOT
36650: IFFALSE 36654
// continue ;
36652: GO 36626
// idle_lab := 0 ;
36654: LD_ADDR_VAR 0 11
36658: PUSH
36659: LD_INT 0
36661: ST_TO_ADDR
// for j in tmp do
36662: LD_ADDR_VAR 0 3
36666: PUSH
36667: LD_VAR 0 6
36671: PUSH
36672: FOR_IN
36673: IFFALSE 37692
// begin researching := false ;
36675: LD_ADDR_VAR 0 10
36679: PUSH
36680: LD_INT 0
36682: ST_TO_ADDR
// side := GetSide ( j ) ;
36683: LD_ADDR_VAR 0 4
36687: PUSH
36688: LD_VAR 0 3
36692: PPUSH
36693: CALL_OW 255
36697: ST_TO_ADDR
// if not mc_tech [ side ] then
36698: LD_EXP 103
36702: PUSH
36703: LD_VAR 0 4
36707: ARRAY
36708: NOT
36709: IFFALSE 36713
// continue ;
36711: GO 36672
// if BuildingStatus ( j ) = bs_idle then
36713: LD_VAR 0 3
36717: PPUSH
36718: CALL_OW 461
36722: PUSH
36723: LD_INT 2
36725: EQUAL
36726: IFFALSE 36914
// begin if idle_lab and UnitsInside ( j ) < 6 then
36728: LD_VAR 0 11
36732: PUSH
36733: LD_VAR 0 3
36737: PPUSH
36738: CALL_OW 313
36742: PUSH
36743: LD_INT 6
36745: LESS
36746: AND
36747: IFFALSE 36818
// begin tmp2 := UnitsInside ( idle_lab ) ;
36749: LD_ADDR_VAR 0 9
36753: PUSH
36754: LD_VAR 0 11
36758: PPUSH
36759: CALL_OW 313
36763: ST_TO_ADDR
// if tmp2 then
36764: LD_VAR 0 9
36768: IFFALSE 36810
// for x in tmp2 do
36770: LD_ADDR_VAR 0 7
36774: PUSH
36775: LD_VAR 0 9
36779: PUSH
36780: FOR_IN
36781: IFFALSE 36808
// begin ComExitBuilding ( x ) ;
36783: LD_VAR 0 7
36787: PPUSH
36788: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36792: LD_VAR 0 7
36796: PPUSH
36797: LD_VAR 0 3
36801: PPUSH
36802: CALL_OW 180
// end ;
36806: GO 36780
36808: POP
36809: POP
// idle_lab := 0 ;
36810: LD_ADDR_VAR 0 11
36814: PUSH
36815: LD_INT 0
36817: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36818: LD_ADDR_VAR 0 5
36822: PUSH
36823: LD_EXP 103
36827: PUSH
36828: LD_VAR 0 4
36832: ARRAY
36833: PUSH
36834: FOR_IN
36835: IFFALSE 36895
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36837: LD_VAR 0 3
36841: PPUSH
36842: LD_VAR 0 5
36846: PPUSH
36847: CALL_OW 430
36851: PUSH
36852: LD_VAR 0 4
36856: PPUSH
36857: LD_VAR 0 5
36861: PPUSH
36862: CALL 51131 0 2
36866: AND
36867: IFFALSE 36893
// begin researching := true ;
36869: LD_ADDR_VAR 0 10
36873: PUSH
36874: LD_INT 1
36876: ST_TO_ADDR
// ComResearch ( j , t ) ;
36877: LD_VAR 0 3
36881: PPUSH
36882: LD_VAR 0 5
36886: PPUSH
36887: CALL_OW 124
// break ;
36891: GO 36895
// end ;
36893: GO 36834
36895: POP
36896: POP
// if not researching then
36897: LD_VAR 0 10
36901: NOT
36902: IFFALSE 36914
// idle_lab := j ;
36904: LD_ADDR_VAR 0 11
36908: PUSH
36909: LD_VAR 0 3
36913: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36914: LD_VAR 0 3
36918: PPUSH
36919: CALL_OW 461
36923: PUSH
36924: LD_INT 10
36926: EQUAL
36927: IFFALSE 37515
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36929: LD_EXP 105
36933: PUSH
36934: LD_VAR 0 2
36938: ARRAY
36939: NOT
36940: PUSH
36941: LD_EXP 106
36945: PUSH
36946: LD_VAR 0 2
36950: ARRAY
36951: NOT
36952: AND
36953: PUSH
36954: LD_EXP 103
36958: PUSH
36959: LD_VAR 0 4
36963: ARRAY
36964: PUSH
36965: LD_INT 1
36967: GREATER
36968: AND
36969: IFFALSE 37100
// begin ComCancel ( j ) ;
36971: LD_VAR 0 3
36975: PPUSH
36976: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36980: LD_ADDR_EXP 103
36984: PUSH
36985: LD_EXP 103
36989: PPUSH
36990: LD_VAR 0 4
36994: PPUSH
36995: LD_EXP 103
36999: PUSH
37000: LD_VAR 0 4
37004: ARRAY
37005: PPUSH
37006: LD_EXP 103
37010: PUSH
37011: LD_VAR 0 4
37015: ARRAY
37016: PUSH
37017: LD_INT 1
37019: MINUS
37020: PPUSH
37021: LD_EXP 103
37025: PUSH
37026: LD_VAR 0 4
37030: ARRAY
37031: PPUSH
37032: LD_INT 0
37034: PPUSH
37035: CALL 57054 0 4
37039: PPUSH
37040: CALL_OW 1
37044: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37045: LD_ADDR_EXP 103
37049: PUSH
37050: LD_EXP 103
37054: PPUSH
37055: LD_VAR 0 4
37059: PPUSH
37060: LD_EXP 103
37064: PUSH
37065: LD_VAR 0 4
37069: ARRAY
37070: PPUSH
37071: LD_EXP 103
37075: PUSH
37076: LD_VAR 0 4
37080: ARRAY
37081: PPUSH
37082: LD_INT 1
37084: PPUSH
37085: LD_INT 0
37087: PPUSH
37088: CALL 57054 0 4
37092: PPUSH
37093: CALL_OW 1
37097: ST_TO_ADDR
// continue ;
37098: GO 36672
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37100: LD_EXP 105
37104: PUSH
37105: LD_VAR 0 2
37109: ARRAY
37110: PUSH
37111: LD_EXP 106
37115: PUSH
37116: LD_VAR 0 2
37120: ARRAY
37121: NOT
37122: AND
37123: IFFALSE 37250
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37125: LD_ADDR_EXP 106
37129: PUSH
37130: LD_EXP 106
37134: PPUSH
37135: LD_VAR 0 2
37139: PUSH
37140: LD_EXP 106
37144: PUSH
37145: LD_VAR 0 2
37149: ARRAY
37150: PUSH
37151: LD_INT 1
37153: PLUS
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PPUSH
37159: LD_EXP 105
37163: PUSH
37164: LD_VAR 0 2
37168: ARRAY
37169: PUSH
37170: LD_INT 1
37172: ARRAY
37173: PPUSH
37174: CALL 57636 0 3
37178: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37179: LD_EXP 105
37183: PUSH
37184: LD_VAR 0 2
37188: ARRAY
37189: PUSH
37190: LD_INT 1
37192: ARRAY
37193: PPUSH
37194: LD_INT 112
37196: PPUSH
37197: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37201: LD_ADDR_VAR 0 9
37205: PUSH
37206: LD_EXP 105
37210: PUSH
37211: LD_VAR 0 2
37215: ARRAY
37216: PPUSH
37217: LD_INT 1
37219: PPUSH
37220: CALL_OW 3
37224: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37225: LD_ADDR_EXP 105
37229: PUSH
37230: LD_EXP 105
37234: PPUSH
37235: LD_VAR 0 2
37239: PPUSH
37240: LD_VAR 0 9
37244: PPUSH
37245: CALL_OW 1
37249: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37250: LD_EXP 105
37254: PUSH
37255: LD_VAR 0 2
37259: ARRAY
37260: PUSH
37261: LD_EXP 106
37265: PUSH
37266: LD_VAR 0 2
37270: ARRAY
37271: AND
37272: PUSH
37273: LD_EXP 106
37277: PUSH
37278: LD_VAR 0 2
37282: ARRAY
37283: PUSH
37284: LD_INT 1
37286: ARRAY
37287: PPUSH
37288: CALL_OW 310
37292: NOT
37293: AND
37294: PUSH
37295: LD_VAR 0 3
37299: PPUSH
37300: CALL_OW 313
37304: PUSH
37305: LD_INT 6
37307: EQUAL
37308: AND
37309: IFFALSE 37365
// begin tmp2 := UnitsInside ( j ) ;
37311: LD_ADDR_VAR 0 9
37315: PUSH
37316: LD_VAR 0 3
37320: PPUSH
37321: CALL_OW 313
37325: ST_TO_ADDR
// if tmp2 = 6 then
37326: LD_VAR 0 9
37330: PUSH
37331: LD_INT 6
37333: EQUAL
37334: IFFALSE 37365
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37336: LD_VAR 0 9
37340: PUSH
37341: LD_INT 1
37343: ARRAY
37344: PPUSH
37345: LD_INT 112
37347: PPUSH
37348: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37352: LD_VAR 0 9
37356: PUSH
37357: LD_INT 1
37359: ARRAY
37360: PPUSH
37361: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37365: LD_EXP 106
37369: PUSH
37370: LD_VAR 0 2
37374: ARRAY
37375: PUSH
37376: LD_EXP 106
37380: PUSH
37381: LD_VAR 0 2
37385: ARRAY
37386: PUSH
37387: LD_INT 1
37389: ARRAY
37390: PPUSH
37391: CALL_OW 314
37395: NOT
37396: AND
37397: PUSH
37398: LD_EXP 106
37402: PUSH
37403: LD_VAR 0 2
37407: ARRAY
37408: PUSH
37409: LD_INT 1
37411: ARRAY
37412: PPUSH
37413: CALL_OW 310
37417: NOT
37418: AND
37419: IFFALSE 37445
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37421: LD_EXP 106
37425: PUSH
37426: LD_VAR 0 2
37430: ARRAY
37431: PUSH
37432: LD_INT 1
37434: ARRAY
37435: PPUSH
37436: LD_VAR 0 3
37440: PPUSH
37441: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37445: LD_EXP 106
37449: PUSH
37450: LD_VAR 0 2
37454: ARRAY
37455: PUSH
37456: LD_INT 1
37458: ARRAY
37459: PPUSH
37460: CALL_OW 310
37464: PUSH
37465: LD_EXP 106
37469: PUSH
37470: LD_VAR 0 2
37474: ARRAY
37475: PUSH
37476: LD_INT 1
37478: ARRAY
37479: PPUSH
37480: CALL_OW 310
37484: PPUSH
37485: CALL_OW 461
37489: PUSH
37490: LD_INT 3
37492: NONEQUAL
37493: AND
37494: IFFALSE 37515
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37496: LD_EXP 106
37500: PUSH
37501: LD_VAR 0 2
37505: ARRAY
37506: PUSH
37507: LD_INT 1
37509: ARRAY
37510: PPUSH
37511: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37515: LD_VAR 0 3
37519: PPUSH
37520: CALL_OW 461
37524: PUSH
37525: LD_INT 6
37527: EQUAL
37528: PUSH
37529: LD_VAR 0 6
37533: PUSH
37534: LD_INT 1
37536: GREATER
37537: AND
37538: IFFALSE 37690
// begin sci := [ ] ;
37540: LD_ADDR_VAR 0 8
37544: PUSH
37545: EMPTY
37546: ST_TO_ADDR
// for x in ( tmp diff j ) do
37547: LD_ADDR_VAR 0 7
37551: PUSH
37552: LD_VAR 0 6
37556: PUSH
37557: LD_VAR 0 3
37561: DIFF
37562: PUSH
37563: FOR_IN
37564: IFFALSE 37616
// begin if sci = 6 then
37566: LD_VAR 0 8
37570: PUSH
37571: LD_INT 6
37573: EQUAL
37574: IFFALSE 37578
// break ;
37576: GO 37616
// if BuildingStatus ( x ) = bs_idle then
37578: LD_VAR 0 7
37582: PPUSH
37583: CALL_OW 461
37587: PUSH
37588: LD_INT 2
37590: EQUAL
37591: IFFALSE 37614
// sci := sci ^ UnitsInside ( x ) ;
37593: LD_ADDR_VAR 0 8
37597: PUSH
37598: LD_VAR 0 8
37602: PUSH
37603: LD_VAR 0 7
37607: PPUSH
37608: CALL_OW 313
37612: ADD
37613: ST_TO_ADDR
// end ;
37614: GO 37563
37616: POP
37617: POP
// if not sci then
37618: LD_VAR 0 8
37622: NOT
37623: IFFALSE 37627
// continue ;
37625: GO 36672
// for x in sci do
37627: LD_ADDR_VAR 0 7
37631: PUSH
37632: LD_VAR 0 8
37636: PUSH
37637: FOR_IN
37638: IFFALSE 37688
// if IsInUnit ( x ) and not HasTask ( x ) then
37640: LD_VAR 0 7
37644: PPUSH
37645: CALL_OW 310
37649: PUSH
37650: LD_VAR 0 7
37654: PPUSH
37655: CALL_OW 314
37659: NOT
37660: AND
37661: IFFALSE 37686
// begin ComExitBuilding ( x ) ;
37663: LD_VAR 0 7
37667: PPUSH
37668: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37672: LD_VAR 0 7
37676: PPUSH
37677: LD_VAR 0 3
37681: PPUSH
37682: CALL_OW 180
// end ;
37686: GO 37637
37688: POP
37689: POP
// end ; end ;
37690: GO 36672
37692: POP
37693: POP
// end ;
37694: GO 36626
37696: POP
37697: POP
// end ;
37698: LD_VAR 0 1
37702: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37703: LD_INT 0
37705: PPUSH
37706: PPUSH
// if not mc_bases then
37707: LD_EXP 76
37711: NOT
37712: IFFALSE 37716
// exit ;
37714: GO 37797
// for i = 1 to mc_bases do
37716: LD_ADDR_VAR 0 2
37720: PUSH
37721: DOUBLE
37722: LD_INT 1
37724: DEC
37725: ST_TO_ADDR
37726: LD_EXP 76
37730: PUSH
37731: FOR_TO
37732: IFFALSE 37795
// if mc_mines [ i ] and mc_miners [ i ] then
37734: LD_EXP 89
37738: PUSH
37739: LD_VAR 0 2
37743: ARRAY
37744: PUSH
37745: LD_EXP 90
37749: PUSH
37750: LD_VAR 0 2
37754: ARRAY
37755: AND
37756: IFFALSE 37793
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37758: LD_EXP 90
37762: PUSH
37763: LD_VAR 0 2
37767: ARRAY
37768: PUSH
37769: LD_INT 1
37771: ARRAY
37772: PPUSH
37773: CALL_OW 255
37777: PPUSH
37778: LD_EXP 89
37782: PUSH
37783: LD_VAR 0 2
37787: ARRAY
37788: PPUSH
37789: CALL 54625 0 2
37793: GO 37731
37795: POP
37796: POP
// end ;
37797: LD_VAR 0 1
37801: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37802: LD_INT 0
37804: PPUSH
37805: PPUSH
37806: PPUSH
37807: PPUSH
37808: PPUSH
37809: PPUSH
37810: PPUSH
37811: PPUSH
// if not mc_bases or not mc_parking then
37812: LD_EXP 76
37816: NOT
37817: PUSH
37818: LD_EXP 100
37822: NOT
37823: OR
37824: IFFALSE 37828
// exit ;
37826: GO 38527
// for i = 1 to mc_bases do
37828: LD_ADDR_VAR 0 2
37832: PUSH
37833: DOUBLE
37834: LD_INT 1
37836: DEC
37837: ST_TO_ADDR
37838: LD_EXP 76
37842: PUSH
37843: FOR_TO
37844: IFFALSE 38525
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37846: LD_EXP 76
37850: PUSH
37851: LD_VAR 0 2
37855: ARRAY
37856: NOT
37857: PUSH
37858: LD_EXP 100
37862: PUSH
37863: LD_VAR 0 2
37867: ARRAY
37868: NOT
37869: OR
37870: IFFALSE 37874
// continue ;
37872: GO 37843
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37874: LD_ADDR_VAR 0 5
37878: PUSH
37879: LD_EXP 76
37883: PUSH
37884: LD_VAR 0 2
37888: ARRAY
37889: PUSH
37890: LD_INT 1
37892: ARRAY
37893: PPUSH
37894: CALL_OW 255
37898: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37899: LD_ADDR_VAR 0 6
37903: PUSH
37904: LD_EXP 76
37908: PUSH
37909: LD_VAR 0 2
37913: ARRAY
37914: PPUSH
37915: LD_INT 30
37917: PUSH
37918: LD_INT 3
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PPUSH
37925: CALL_OW 72
37929: ST_TO_ADDR
// if not fac then
37930: LD_VAR 0 6
37934: NOT
37935: IFFALSE 37986
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37937: LD_ADDR_VAR 0 6
37941: PUSH
37942: LD_EXP 76
37946: PUSH
37947: LD_VAR 0 2
37951: ARRAY
37952: PPUSH
37953: LD_INT 2
37955: PUSH
37956: LD_INT 30
37958: PUSH
37959: LD_INT 0
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: PUSH
37966: LD_INT 30
37968: PUSH
37969: LD_INT 1
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: LIST
37980: PPUSH
37981: CALL_OW 72
37985: ST_TO_ADDR
// if not fac then
37986: LD_VAR 0 6
37990: NOT
37991: IFFALSE 37995
// continue ;
37993: GO 37843
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37995: LD_ADDR_VAR 0 7
37999: PUSH
38000: LD_EXP 100
38004: PUSH
38005: LD_VAR 0 2
38009: ARRAY
38010: PPUSH
38011: LD_INT 22
38013: PUSH
38014: LD_VAR 0 5
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 21
38025: PUSH
38026: LD_INT 2
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 3
38035: PUSH
38036: LD_INT 24
38038: PUSH
38039: LD_INT 1000
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: LIST
38054: PPUSH
38055: CALL_OW 70
38059: ST_TO_ADDR
// for j in fac do
38060: LD_ADDR_VAR 0 3
38064: PUSH
38065: LD_VAR 0 6
38069: PUSH
38070: FOR_IN
38071: IFFALSE 38152
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38073: LD_ADDR_VAR 0 7
38077: PUSH
38078: LD_VAR 0 7
38082: PUSH
38083: LD_INT 22
38085: PUSH
38086: LD_VAR 0 5
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 91
38097: PUSH
38098: LD_VAR 0 3
38102: PUSH
38103: LD_INT 15
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 21
38113: PUSH
38114: LD_INT 2
38116: PUSH
38117: EMPTY
38118: LIST
38119: LIST
38120: PUSH
38121: LD_INT 3
38123: PUSH
38124: LD_INT 24
38126: PUSH
38127: LD_INT 1000
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: PPUSH
38144: CALL_OW 69
38148: UNION
38149: ST_TO_ADDR
38150: GO 38070
38152: POP
38153: POP
// if not vehs then
38154: LD_VAR 0 7
38158: NOT
38159: IFFALSE 38185
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38161: LD_ADDR_EXP 88
38165: PUSH
38166: LD_EXP 88
38170: PPUSH
38171: LD_VAR 0 2
38175: PPUSH
38176: EMPTY
38177: PPUSH
38178: CALL_OW 1
38182: ST_TO_ADDR
// continue ;
38183: GO 37843
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38185: LD_ADDR_VAR 0 8
38189: PUSH
38190: LD_EXP 76
38194: PUSH
38195: LD_VAR 0 2
38199: ARRAY
38200: PPUSH
38201: LD_INT 30
38203: PUSH
38204: LD_INT 3
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PPUSH
38211: CALL_OW 72
38215: ST_TO_ADDR
// if tmp then
38216: LD_VAR 0 8
38220: IFFALSE 38323
// begin for j in tmp do
38222: LD_ADDR_VAR 0 3
38226: PUSH
38227: LD_VAR 0 8
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38321
// for k in UnitsInside ( j ) do
38235: LD_ADDR_VAR 0 4
38239: PUSH
38240: LD_VAR 0 3
38244: PPUSH
38245: CALL_OW 313
38249: PUSH
38250: FOR_IN
38251: IFFALSE 38317
// if k then
38253: LD_VAR 0 4
38257: IFFALSE 38315
// if not k in mc_repair_vehicle [ i ] then
38259: LD_VAR 0 4
38263: PUSH
38264: LD_EXP 88
38268: PUSH
38269: LD_VAR 0 2
38273: ARRAY
38274: IN
38275: NOT
38276: IFFALSE 38315
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38278: LD_ADDR_EXP 88
38282: PUSH
38283: LD_EXP 88
38287: PPUSH
38288: LD_VAR 0 2
38292: PPUSH
38293: LD_EXP 88
38297: PUSH
38298: LD_VAR 0 2
38302: ARRAY
38303: PUSH
38304: LD_VAR 0 4
38308: UNION
38309: PPUSH
38310: CALL_OW 1
38314: ST_TO_ADDR
38315: GO 38250
38317: POP
38318: POP
38319: GO 38232
38321: POP
38322: POP
// end ; if not mc_repair_vehicle [ i ] then
38323: LD_EXP 88
38327: PUSH
38328: LD_VAR 0 2
38332: ARRAY
38333: NOT
38334: IFFALSE 38338
// continue ;
38336: GO 37843
// for j in mc_repair_vehicle [ i ] do
38338: LD_ADDR_VAR 0 3
38342: PUSH
38343: LD_EXP 88
38347: PUSH
38348: LD_VAR 0 2
38352: ARRAY
38353: PUSH
38354: FOR_IN
38355: IFFALSE 38521
// begin if GetClass ( j ) <> 3 then
38357: LD_VAR 0 3
38361: PPUSH
38362: CALL_OW 257
38366: PUSH
38367: LD_INT 3
38369: NONEQUAL
38370: IFFALSE 38411
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38372: LD_ADDR_EXP 88
38376: PUSH
38377: LD_EXP 88
38381: PPUSH
38382: LD_VAR 0 2
38386: PPUSH
38387: LD_EXP 88
38391: PUSH
38392: LD_VAR 0 2
38396: ARRAY
38397: PUSH
38398: LD_VAR 0 3
38402: DIFF
38403: PPUSH
38404: CALL_OW 1
38408: ST_TO_ADDR
// continue ;
38409: GO 38354
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38411: LD_VAR 0 3
38415: PPUSH
38416: CALL_OW 311
38420: NOT
38421: PUSH
38422: LD_VAR 0 3
38426: PUSH
38427: LD_EXP 79
38431: PUSH
38432: LD_VAR 0 2
38436: ARRAY
38437: PUSH
38438: LD_INT 1
38440: ARRAY
38441: IN
38442: NOT
38443: AND
38444: PUSH
38445: LD_VAR 0 3
38449: PUSH
38450: LD_EXP 79
38454: PUSH
38455: LD_VAR 0 2
38459: ARRAY
38460: PUSH
38461: LD_INT 2
38463: ARRAY
38464: IN
38465: NOT
38466: AND
38467: IFFALSE 38519
// begin if IsInUnit ( j ) then
38469: LD_VAR 0 3
38473: PPUSH
38474: CALL_OW 310
38478: IFFALSE 38489
// ComExitBuilding ( j ) ;
38480: LD_VAR 0 3
38484: PPUSH
38485: CALL_OW 122
// if not HasTask ( j ) then
38489: LD_VAR 0 3
38493: PPUSH
38494: CALL_OW 314
38498: NOT
38499: IFFALSE 38519
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38501: LD_VAR 0 3
38505: PPUSH
38506: LD_VAR 0 7
38510: PUSH
38511: LD_INT 1
38513: ARRAY
38514: PPUSH
38515: CALL_OW 189
// end ; end ;
38519: GO 38354
38521: POP
38522: POP
// end ;
38523: GO 37843
38525: POP
38526: POP
// end ;
38527: LD_VAR 0 1
38531: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38532: LD_INT 0
38534: PPUSH
38535: PPUSH
38536: PPUSH
38537: PPUSH
38538: PPUSH
38539: PPUSH
38540: PPUSH
38541: PPUSH
38542: PPUSH
38543: PPUSH
38544: PPUSH
// if not mc_bases then
38545: LD_EXP 76
38549: NOT
38550: IFFALSE 38554
// exit ;
38552: GO 39356
// for i = 1 to mc_bases do
38554: LD_ADDR_VAR 0 2
38558: PUSH
38559: DOUBLE
38560: LD_INT 1
38562: DEC
38563: ST_TO_ADDR
38564: LD_EXP 76
38568: PUSH
38569: FOR_TO
38570: IFFALSE 39354
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38572: LD_EXP 104
38576: PUSH
38577: LD_VAR 0 2
38581: ARRAY
38582: NOT
38583: PUSH
38584: LD_EXP 79
38588: PUSH
38589: LD_VAR 0 2
38593: ARRAY
38594: PUSH
38595: LD_INT 1
38597: ARRAY
38598: OR
38599: PUSH
38600: LD_EXP 79
38604: PUSH
38605: LD_VAR 0 2
38609: ARRAY
38610: PUSH
38611: LD_INT 2
38613: ARRAY
38614: OR
38615: PUSH
38616: LD_EXP 102
38620: PUSH
38621: LD_VAR 0 2
38625: ARRAY
38626: PPUSH
38627: LD_INT 1
38629: PPUSH
38630: CALL_OW 325
38634: NOT
38635: OR
38636: PUSH
38637: LD_EXP 99
38641: PUSH
38642: LD_VAR 0 2
38646: ARRAY
38647: OR
38648: IFFALSE 38652
// continue ;
38650: GO 38569
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38652: LD_ADDR_VAR 0 8
38656: PUSH
38657: LD_EXP 76
38661: PUSH
38662: LD_VAR 0 2
38666: ARRAY
38667: PPUSH
38668: LD_INT 25
38670: PUSH
38671: LD_INT 4
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 50
38680: PUSH
38681: EMPTY
38682: LIST
38683: PUSH
38684: LD_INT 3
38686: PUSH
38687: LD_INT 60
38689: PUSH
38690: EMPTY
38691: LIST
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: LIST
38701: PPUSH
38702: CALL_OW 72
38706: PUSH
38707: LD_EXP 80
38711: PUSH
38712: LD_VAR 0 2
38716: ARRAY
38717: DIFF
38718: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38719: LD_ADDR_VAR 0 9
38723: PUSH
38724: LD_EXP 76
38728: PUSH
38729: LD_VAR 0 2
38733: ARRAY
38734: PPUSH
38735: LD_INT 2
38737: PUSH
38738: LD_INT 30
38740: PUSH
38741: LD_INT 0
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 30
38750: PUSH
38751: LD_INT 1
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: LIST
38762: PPUSH
38763: CALL_OW 72
38767: ST_TO_ADDR
// if not tmp or not dep then
38768: LD_VAR 0 8
38772: NOT
38773: PUSH
38774: LD_VAR 0 9
38778: NOT
38779: OR
38780: IFFALSE 38784
// continue ;
38782: GO 38569
// side := GetSide ( tmp [ 1 ] ) ;
38784: LD_ADDR_VAR 0 11
38788: PUSH
38789: LD_VAR 0 8
38793: PUSH
38794: LD_INT 1
38796: ARRAY
38797: PPUSH
38798: CALL_OW 255
38802: ST_TO_ADDR
// dep := dep [ 1 ] ;
38803: LD_ADDR_VAR 0 9
38807: PUSH
38808: LD_VAR 0 9
38812: PUSH
38813: LD_INT 1
38815: ARRAY
38816: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38817: LD_ADDR_VAR 0 7
38821: PUSH
38822: LD_EXP 104
38826: PUSH
38827: LD_VAR 0 2
38831: ARRAY
38832: PPUSH
38833: LD_INT 22
38835: PUSH
38836: LD_INT 0
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 25
38845: PUSH
38846: LD_INT 12
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PUSH
38853: EMPTY
38854: LIST
38855: LIST
38856: PPUSH
38857: CALL_OW 70
38861: PUSH
38862: LD_INT 22
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 25
38874: PUSH
38875: LD_INT 12
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 91
38884: PUSH
38885: LD_VAR 0 9
38889: PUSH
38890: LD_INT 20
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: LIST
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: LIST
38902: PPUSH
38903: CALL_OW 69
38907: UNION
38908: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38909: LD_ADDR_VAR 0 10
38913: PUSH
38914: LD_EXP 104
38918: PUSH
38919: LD_VAR 0 2
38923: ARRAY
38924: PPUSH
38925: LD_INT 81
38927: PUSH
38928: LD_VAR 0 11
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PPUSH
38937: CALL_OW 70
38941: ST_TO_ADDR
// if not apes or danger_at_area then
38942: LD_VAR 0 7
38946: NOT
38947: PUSH
38948: LD_VAR 0 10
38952: OR
38953: IFFALSE 39003
// begin if mc_taming [ i ] then
38955: LD_EXP 107
38959: PUSH
38960: LD_VAR 0 2
38964: ARRAY
38965: IFFALSE 39001
// begin MC_Reset ( i , 121 ) ;
38967: LD_VAR 0 2
38971: PPUSH
38972: LD_INT 121
38974: PPUSH
38975: CALL 24334 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38979: LD_ADDR_EXP 107
38983: PUSH
38984: LD_EXP 107
38988: PPUSH
38989: LD_VAR 0 2
38993: PPUSH
38994: EMPTY
38995: PPUSH
38996: CALL_OW 1
39000: ST_TO_ADDR
// end ; continue ;
39001: GO 38569
// end ; for j in tmp do
39003: LD_ADDR_VAR 0 3
39007: PUSH
39008: LD_VAR 0 8
39012: PUSH
39013: FOR_IN
39014: IFFALSE 39350
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39016: LD_VAR 0 3
39020: PUSH
39021: LD_EXP 107
39025: PUSH
39026: LD_VAR 0 2
39030: ARRAY
39031: IN
39032: NOT
39033: PUSH
39034: LD_EXP 107
39038: PUSH
39039: LD_VAR 0 2
39043: ARRAY
39044: PUSH
39045: LD_INT 3
39047: LESS
39048: AND
39049: IFFALSE 39107
// begin SetTag ( j , 121 ) ;
39051: LD_VAR 0 3
39055: PPUSH
39056: LD_INT 121
39058: PPUSH
39059: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39063: LD_ADDR_EXP 107
39067: PUSH
39068: LD_EXP 107
39072: PPUSH
39073: LD_VAR 0 2
39077: PUSH
39078: LD_EXP 107
39082: PUSH
39083: LD_VAR 0 2
39087: ARRAY
39088: PUSH
39089: LD_INT 1
39091: PLUS
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PPUSH
39097: LD_VAR 0 3
39101: PPUSH
39102: CALL 57636 0 3
39106: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39107: LD_VAR 0 3
39111: PUSH
39112: LD_EXP 107
39116: PUSH
39117: LD_VAR 0 2
39121: ARRAY
39122: IN
39123: IFFALSE 39348
// begin if GetClass ( j ) <> 4 then
39125: LD_VAR 0 3
39129: PPUSH
39130: CALL_OW 257
39134: PUSH
39135: LD_INT 4
39137: NONEQUAL
39138: IFFALSE 39191
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39140: LD_ADDR_EXP 107
39144: PUSH
39145: LD_EXP 107
39149: PPUSH
39150: LD_VAR 0 2
39154: PPUSH
39155: LD_EXP 107
39159: PUSH
39160: LD_VAR 0 2
39164: ARRAY
39165: PUSH
39166: LD_VAR 0 3
39170: DIFF
39171: PPUSH
39172: CALL_OW 1
39176: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39177: LD_VAR 0 3
39181: PPUSH
39182: LD_INT 0
39184: PPUSH
39185: CALL_OW 109
// continue ;
39189: GO 39013
// end ; if IsInUnit ( j ) then
39191: LD_VAR 0 3
39195: PPUSH
39196: CALL_OW 310
39200: IFFALSE 39211
// ComExitBuilding ( j ) ;
39202: LD_VAR 0 3
39206: PPUSH
39207: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39211: LD_ADDR_VAR 0 6
39215: PUSH
39216: LD_VAR 0 7
39220: PPUSH
39221: LD_VAR 0 3
39225: PPUSH
39226: CALL_OW 74
39230: ST_TO_ADDR
// if not ape then
39231: LD_VAR 0 6
39235: NOT
39236: IFFALSE 39240
// break ;
39238: GO 39350
// x := GetX ( ape ) ;
39240: LD_ADDR_VAR 0 4
39244: PUSH
39245: LD_VAR 0 6
39249: PPUSH
39250: CALL_OW 250
39254: ST_TO_ADDR
// y := GetY ( ape ) ;
39255: LD_ADDR_VAR 0 5
39259: PUSH
39260: LD_VAR 0 6
39264: PPUSH
39265: CALL_OW 251
39269: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39270: LD_VAR 0 4
39274: PPUSH
39275: LD_VAR 0 5
39279: PPUSH
39280: CALL_OW 488
39284: NOT
39285: PUSH
39286: LD_VAR 0 11
39290: PPUSH
39291: LD_VAR 0 4
39295: PPUSH
39296: LD_VAR 0 5
39300: PPUSH
39301: LD_INT 20
39303: PPUSH
39304: CALL 58532 0 4
39308: PUSH
39309: LD_INT 4
39311: ARRAY
39312: OR
39313: IFFALSE 39317
// break ;
39315: GO 39350
// if not HasTask ( j ) then
39317: LD_VAR 0 3
39321: PPUSH
39322: CALL_OW 314
39326: NOT
39327: IFFALSE 39348
// ComTameXY ( j , x , y ) ;
39329: LD_VAR 0 3
39333: PPUSH
39334: LD_VAR 0 4
39338: PPUSH
39339: LD_VAR 0 5
39343: PPUSH
39344: CALL_OW 131
// end ; end ;
39348: GO 39013
39350: POP
39351: POP
// end ;
39352: GO 38569
39354: POP
39355: POP
// end ;
39356: LD_VAR 0 1
39360: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39361: LD_INT 0
39363: PPUSH
39364: PPUSH
39365: PPUSH
39366: PPUSH
39367: PPUSH
39368: PPUSH
39369: PPUSH
39370: PPUSH
// if not mc_bases then
39371: LD_EXP 76
39375: NOT
39376: IFFALSE 39380
// exit ;
39378: GO 40006
// for i = 1 to mc_bases do
39380: LD_ADDR_VAR 0 2
39384: PUSH
39385: DOUBLE
39386: LD_INT 1
39388: DEC
39389: ST_TO_ADDR
39390: LD_EXP 76
39394: PUSH
39395: FOR_TO
39396: IFFALSE 40004
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39398: LD_EXP 105
39402: PUSH
39403: LD_VAR 0 2
39407: ARRAY
39408: NOT
39409: PUSH
39410: LD_EXP 105
39414: PUSH
39415: LD_VAR 0 2
39419: ARRAY
39420: PPUSH
39421: LD_INT 25
39423: PUSH
39424: LD_INT 12
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PPUSH
39431: CALL_OW 72
39435: NOT
39436: OR
39437: IFFALSE 39441
// continue ;
39439: GO 39395
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39441: LD_ADDR_VAR 0 5
39445: PUSH
39446: LD_EXP 105
39450: PUSH
39451: LD_VAR 0 2
39455: ARRAY
39456: PUSH
39457: LD_INT 1
39459: ARRAY
39460: PPUSH
39461: CALL_OW 255
39465: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39466: LD_VAR 0 5
39470: PPUSH
39471: LD_INT 2
39473: PPUSH
39474: CALL_OW 325
39478: IFFALSE 39731
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39480: LD_ADDR_VAR 0 4
39484: PUSH
39485: LD_EXP 105
39489: PUSH
39490: LD_VAR 0 2
39494: ARRAY
39495: PPUSH
39496: LD_INT 25
39498: PUSH
39499: LD_INT 16
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: PPUSH
39506: CALL_OW 72
39510: ST_TO_ADDR
// if tmp < 6 then
39511: LD_VAR 0 4
39515: PUSH
39516: LD_INT 6
39518: LESS
39519: IFFALSE 39731
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39521: LD_ADDR_VAR 0 6
39525: PUSH
39526: LD_EXP 76
39530: PUSH
39531: LD_VAR 0 2
39535: ARRAY
39536: PPUSH
39537: LD_INT 2
39539: PUSH
39540: LD_INT 30
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 30
39552: PUSH
39553: LD_INT 1
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: LIST
39564: PPUSH
39565: CALL_OW 72
39569: ST_TO_ADDR
// if depot then
39570: LD_VAR 0 6
39574: IFFALSE 39731
// begin selected := 0 ;
39576: LD_ADDR_VAR 0 7
39580: PUSH
39581: LD_INT 0
39583: ST_TO_ADDR
// for j in depot do
39584: LD_ADDR_VAR 0 3
39588: PUSH
39589: LD_VAR 0 6
39593: PUSH
39594: FOR_IN
39595: IFFALSE 39626
// begin if UnitsInside ( j ) < 6 then
39597: LD_VAR 0 3
39601: PPUSH
39602: CALL_OW 313
39606: PUSH
39607: LD_INT 6
39609: LESS
39610: IFFALSE 39624
// begin selected := j ;
39612: LD_ADDR_VAR 0 7
39616: PUSH
39617: LD_VAR 0 3
39621: ST_TO_ADDR
// break ;
39622: GO 39626
// end ; end ;
39624: GO 39594
39626: POP
39627: POP
// if selected then
39628: LD_VAR 0 7
39632: IFFALSE 39731
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39634: LD_ADDR_VAR 0 3
39638: PUSH
39639: LD_EXP 105
39643: PUSH
39644: LD_VAR 0 2
39648: ARRAY
39649: PPUSH
39650: LD_INT 25
39652: PUSH
39653: LD_INT 12
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PPUSH
39660: CALL_OW 72
39664: PUSH
39665: FOR_IN
39666: IFFALSE 39729
// if not HasTask ( j ) then
39668: LD_VAR 0 3
39672: PPUSH
39673: CALL_OW 314
39677: NOT
39678: IFFALSE 39727
// begin if not IsInUnit ( j ) then
39680: LD_VAR 0 3
39684: PPUSH
39685: CALL_OW 310
39689: NOT
39690: IFFALSE 39706
// ComEnterUnit ( j , selected ) ;
39692: LD_VAR 0 3
39696: PPUSH
39697: LD_VAR 0 7
39701: PPUSH
39702: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39706: LD_VAR 0 3
39710: PPUSH
39711: LD_INT 16
39713: PPUSH
39714: CALL_OW 183
// AddComExitBuilding ( j ) ;
39718: LD_VAR 0 3
39722: PPUSH
39723: CALL_OW 182
// end ;
39727: GO 39665
39729: POP
39730: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39731: LD_VAR 0 5
39735: PPUSH
39736: LD_INT 11
39738: PPUSH
39739: CALL_OW 325
39743: IFFALSE 40002
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39745: LD_ADDR_VAR 0 4
39749: PUSH
39750: LD_EXP 105
39754: PUSH
39755: LD_VAR 0 2
39759: ARRAY
39760: PPUSH
39761: LD_INT 25
39763: PUSH
39764: LD_INT 16
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PPUSH
39771: CALL_OW 72
39775: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39776: LD_VAR 0 4
39780: PUSH
39781: LD_INT 6
39783: GREATEREQUAL
39784: PUSH
39785: LD_VAR 0 5
39789: PPUSH
39790: LD_INT 2
39792: PPUSH
39793: CALL_OW 325
39797: NOT
39798: OR
39799: IFFALSE 40002
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39801: LD_ADDR_VAR 0 8
39805: PUSH
39806: LD_EXP 76
39810: PUSH
39811: LD_VAR 0 2
39815: ARRAY
39816: PPUSH
39817: LD_INT 2
39819: PUSH
39820: LD_INT 30
39822: PUSH
39823: LD_INT 4
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 30
39832: PUSH
39833: LD_INT 5
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: LIST
39844: PPUSH
39845: CALL_OW 72
39849: ST_TO_ADDR
// if barracks then
39850: LD_VAR 0 8
39854: IFFALSE 40002
// begin selected := 0 ;
39856: LD_ADDR_VAR 0 7
39860: PUSH
39861: LD_INT 0
39863: ST_TO_ADDR
// for j in barracks do
39864: LD_ADDR_VAR 0 3
39868: PUSH
39869: LD_VAR 0 8
39873: PUSH
39874: FOR_IN
39875: IFFALSE 39906
// begin if UnitsInside ( j ) < 6 then
39877: LD_VAR 0 3
39881: PPUSH
39882: CALL_OW 313
39886: PUSH
39887: LD_INT 6
39889: LESS
39890: IFFALSE 39904
// begin selected := j ;
39892: LD_ADDR_VAR 0 7
39896: PUSH
39897: LD_VAR 0 3
39901: ST_TO_ADDR
// break ;
39902: GO 39906
// end ; end ;
39904: GO 39874
39906: POP
39907: POP
// if selected then
39908: LD_VAR 0 7
39912: IFFALSE 40002
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39914: LD_ADDR_VAR 0 3
39918: PUSH
39919: LD_EXP 105
39923: PUSH
39924: LD_VAR 0 2
39928: ARRAY
39929: PPUSH
39930: LD_INT 25
39932: PUSH
39933: LD_INT 12
39935: PUSH
39936: EMPTY
39937: LIST
39938: LIST
39939: PPUSH
39940: CALL_OW 72
39944: PUSH
39945: FOR_IN
39946: IFFALSE 40000
// if not IsInUnit ( j ) and not HasTask ( j ) then
39948: LD_VAR 0 3
39952: PPUSH
39953: CALL_OW 310
39957: NOT
39958: PUSH
39959: LD_VAR 0 3
39963: PPUSH
39964: CALL_OW 314
39968: NOT
39969: AND
39970: IFFALSE 39998
// begin ComEnterUnit ( j , selected ) ;
39972: LD_VAR 0 3
39976: PPUSH
39977: LD_VAR 0 7
39981: PPUSH
39982: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39986: LD_VAR 0 3
39990: PPUSH
39991: LD_INT 15
39993: PPUSH
39994: CALL_OW 183
// end ;
39998: GO 39945
40000: POP
40001: POP
// end ; end ; end ; end ; end ;
40002: GO 39395
40004: POP
40005: POP
// end ;
40006: LD_VAR 0 1
40010: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40011: LD_INT 0
40013: PPUSH
40014: PPUSH
40015: PPUSH
40016: PPUSH
// if not mc_bases then
40017: LD_EXP 76
40021: NOT
40022: IFFALSE 40026
// exit ;
40024: GO 40204
// for i = 1 to mc_bases do
40026: LD_ADDR_VAR 0 2
40030: PUSH
40031: DOUBLE
40032: LD_INT 1
40034: DEC
40035: ST_TO_ADDR
40036: LD_EXP 76
40040: PUSH
40041: FOR_TO
40042: IFFALSE 40202
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40044: LD_ADDR_VAR 0 4
40048: PUSH
40049: LD_EXP 76
40053: PUSH
40054: LD_VAR 0 2
40058: ARRAY
40059: PPUSH
40060: LD_INT 25
40062: PUSH
40063: LD_INT 9
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PPUSH
40070: CALL_OW 72
40074: ST_TO_ADDR
// if not tmp then
40075: LD_VAR 0 4
40079: NOT
40080: IFFALSE 40084
// continue ;
40082: GO 40041
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40084: LD_EXP 102
40088: PUSH
40089: LD_VAR 0 2
40093: ARRAY
40094: PPUSH
40095: LD_INT 29
40097: PPUSH
40098: CALL_OW 325
40102: NOT
40103: PUSH
40104: LD_EXP 102
40108: PUSH
40109: LD_VAR 0 2
40113: ARRAY
40114: PPUSH
40115: LD_INT 28
40117: PPUSH
40118: CALL_OW 325
40122: NOT
40123: AND
40124: IFFALSE 40128
// continue ;
40126: GO 40041
// for j in tmp do
40128: LD_ADDR_VAR 0 3
40132: PUSH
40133: LD_VAR 0 4
40137: PUSH
40138: FOR_IN
40139: IFFALSE 40198
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40141: LD_VAR 0 3
40145: PUSH
40146: LD_EXP 79
40150: PUSH
40151: LD_VAR 0 2
40155: ARRAY
40156: PUSH
40157: LD_INT 1
40159: ARRAY
40160: IN
40161: NOT
40162: PUSH
40163: LD_VAR 0 3
40167: PUSH
40168: LD_EXP 79
40172: PUSH
40173: LD_VAR 0 2
40177: ARRAY
40178: PUSH
40179: LD_INT 2
40181: ARRAY
40182: IN
40183: NOT
40184: AND
40185: IFFALSE 40196
// ComSpaceTimeShoot ( j ) ;
40187: LD_VAR 0 3
40191: PPUSH
40192: CALL 51222 0 1
40196: GO 40138
40198: POP
40199: POP
// end ;
40200: GO 40041
40202: POP
40203: POP
// end ;
40204: LD_VAR 0 1
40208: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40209: LD_INT 0
40211: PPUSH
40212: PPUSH
40213: PPUSH
40214: PPUSH
40215: PPUSH
40216: PPUSH
40217: PPUSH
40218: PPUSH
40219: PPUSH
// if not mc_bases then
40220: LD_EXP 76
40224: NOT
40225: IFFALSE 40229
// exit ;
40227: GO 40851
// for i = 1 to mc_bases do
40229: LD_ADDR_VAR 0 2
40233: PUSH
40234: DOUBLE
40235: LD_INT 1
40237: DEC
40238: ST_TO_ADDR
40239: LD_EXP 76
40243: PUSH
40244: FOR_TO
40245: IFFALSE 40849
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40247: LD_EXP 111
40251: PUSH
40252: LD_VAR 0 2
40256: ARRAY
40257: NOT
40258: PUSH
40259: LD_INT 38
40261: PPUSH
40262: LD_EXP 102
40266: PUSH
40267: LD_VAR 0 2
40271: ARRAY
40272: PPUSH
40273: CALL_OW 321
40277: PUSH
40278: LD_INT 2
40280: NONEQUAL
40281: OR
40282: IFFALSE 40286
// continue ;
40284: GO 40244
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40286: LD_ADDR_VAR 0 8
40290: PUSH
40291: LD_EXP 76
40295: PUSH
40296: LD_VAR 0 2
40300: ARRAY
40301: PPUSH
40302: LD_INT 30
40304: PUSH
40305: LD_INT 34
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PPUSH
40312: CALL_OW 72
40316: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40317: LD_ADDR_VAR 0 9
40321: PUSH
40322: LD_EXP 76
40326: PUSH
40327: LD_VAR 0 2
40331: ARRAY
40332: PPUSH
40333: LD_INT 25
40335: PUSH
40336: LD_INT 4
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PPUSH
40343: CALL_OW 72
40347: PPUSH
40348: LD_INT 0
40350: PPUSH
40351: CALL 90896 0 2
40355: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40356: LD_VAR 0 9
40360: NOT
40361: PUSH
40362: LD_VAR 0 8
40366: NOT
40367: OR
40368: PUSH
40369: LD_EXP 76
40373: PUSH
40374: LD_VAR 0 2
40378: ARRAY
40379: PPUSH
40380: LD_INT 124
40382: PPUSH
40383: CALL 90896 0 2
40387: OR
40388: IFFALSE 40392
// continue ;
40390: GO 40244
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40392: LD_EXP 112
40396: PUSH
40397: LD_VAR 0 2
40401: ARRAY
40402: PUSH
40403: LD_EXP 111
40407: PUSH
40408: LD_VAR 0 2
40412: ARRAY
40413: LESS
40414: PUSH
40415: LD_EXP 112
40419: PUSH
40420: LD_VAR 0 2
40424: ARRAY
40425: PUSH
40426: LD_VAR 0 8
40430: LESS
40431: AND
40432: IFFALSE 40847
// begin tmp := sci [ 1 ] ;
40434: LD_ADDR_VAR 0 7
40438: PUSH
40439: LD_VAR 0 9
40443: PUSH
40444: LD_INT 1
40446: ARRAY
40447: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40448: LD_VAR 0 7
40452: PPUSH
40453: LD_INT 124
40455: PPUSH
40456: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40460: LD_ADDR_VAR 0 3
40464: PUSH
40465: DOUBLE
40466: LD_EXP 111
40470: PUSH
40471: LD_VAR 0 2
40475: ARRAY
40476: INC
40477: ST_TO_ADDR
40478: LD_EXP 111
40482: PUSH
40483: LD_VAR 0 2
40487: ARRAY
40488: PUSH
40489: FOR_DOWNTO
40490: IFFALSE 40833
// begin if IsInUnit ( tmp ) then
40492: LD_VAR 0 7
40496: PPUSH
40497: CALL_OW 310
40501: IFFALSE 40512
// ComExitBuilding ( tmp ) ;
40503: LD_VAR 0 7
40507: PPUSH
40508: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40512: LD_INT 35
40514: PPUSH
40515: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40519: LD_VAR 0 7
40523: PPUSH
40524: CALL_OW 310
40528: NOT
40529: PUSH
40530: LD_VAR 0 7
40534: PPUSH
40535: CALL_OW 314
40539: NOT
40540: AND
40541: IFFALSE 40512
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40543: LD_ADDR_VAR 0 6
40547: PUSH
40548: LD_VAR 0 7
40552: PPUSH
40553: CALL_OW 250
40557: PUSH
40558: LD_VAR 0 7
40562: PPUSH
40563: CALL_OW 251
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40572: LD_INT 35
40574: PPUSH
40575: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40579: LD_ADDR_VAR 0 4
40583: PUSH
40584: LD_EXP 111
40588: PUSH
40589: LD_VAR 0 2
40593: ARRAY
40594: PUSH
40595: LD_VAR 0 3
40599: ARRAY
40600: PUSH
40601: LD_INT 1
40603: ARRAY
40604: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40605: LD_ADDR_VAR 0 5
40609: PUSH
40610: LD_EXP 111
40614: PUSH
40615: LD_VAR 0 2
40619: ARRAY
40620: PUSH
40621: LD_VAR 0 3
40625: ARRAY
40626: PUSH
40627: LD_INT 2
40629: ARRAY
40630: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40631: LD_VAR 0 7
40635: PPUSH
40636: LD_INT 10
40638: PPUSH
40639: CALL 60229 0 2
40643: PUSH
40644: LD_INT 4
40646: ARRAY
40647: IFFALSE 40685
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40649: LD_VAR 0 7
40653: PPUSH
40654: LD_VAR 0 6
40658: PUSH
40659: LD_INT 1
40661: ARRAY
40662: PPUSH
40663: LD_VAR 0 6
40667: PUSH
40668: LD_INT 2
40670: ARRAY
40671: PPUSH
40672: CALL_OW 111
// wait ( 0 0$10 ) ;
40676: LD_INT 350
40678: PPUSH
40679: CALL_OW 67
// end else
40683: GO 40711
// begin ComMoveXY ( tmp , x , y ) ;
40685: LD_VAR 0 7
40689: PPUSH
40690: LD_VAR 0 4
40694: PPUSH
40695: LD_VAR 0 5
40699: PPUSH
40700: CALL_OW 111
// wait ( 0 0$3 ) ;
40704: LD_INT 105
40706: PPUSH
40707: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40711: LD_VAR 0 7
40715: PPUSH
40716: LD_VAR 0 4
40720: PPUSH
40721: LD_VAR 0 5
40725: PPUSH
40726: CALL_OW 307
40730: IFFALSE 40572
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40732: LD_VAR 0 7
40736: PPUSH
40737: LD_VAR 0 4
40741: PPUSH
40742: LD_VAR 0 5
40746: PPUSH
40747: LD_VAR 0 8
40751: PUSH
40752: LD_VAR 0 3
40756: ARRAY
40757: PPUSH
40758: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40762: LD_INT 35
40764: PPUSH
40765: CALL_OW 67
// until not HasTask ( tmp ) ;
40769: LD_VAR 0 7
40773: PPUSH
40774: CALL_OW 314
40778: NOT
40779: IFFALSE 40762
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40781: LD_ADDR_EXP 112
40785: PUSH
40786: LD_EXP 112
40790: PPUSH
40791: LD_VAR 0 2
40795: PUSH
40796: LD_EXP 112
40800: PUSH
40801: LD_VAR 0 2
40805: ARRAY
40806: PUSH
40807: LD_INT 1
40809: PLUS
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PPUSH
40815: LD_VAR 0 8
40819: PUSH
40820: LD_VAR 0 3
40824: ARRAY
40825: PPUSH
40826: CALL 57636 0 3
40830: ST_TO_ADDR
// end ;
40831: GO 40489
40833: POP
40834: POP
// MC_Reset ( i , 124 ) ;
40835: LD_VAR 0 2
40839: PPUSH
40840: LD_INT 124
40842: PPUSH
40843: CALL 24334 0 2
// end ; end ;
40847: GO 40244
40849: POP
40850: POP
// end ;
40851: LD_VAR 0 1
40855: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40856: LD_INT 0
40858: PPUSH
40859: PPUSH
40860: PPUSH
// if not mc_bases then
40861: LD_EXP 76
40865: NOT
40866: IFFALSE 40870
// exit ;
40868: GO 41476
// for i = 1 to mc_bases do
40870: LD_ADDR_VAR 0 2
40874: PUSH
40875: DOUBLE
40876: LD_INT 1
40878: DEC
40879: ST_TO_ADDR
40880: LD_EXP 76
40884: PUSH
40885: FOR_TO
40886: IFFALSE 41474
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40888: LD_ADDR_VAR 0 3
40892: PUSH
40893: LD_EXP 76
40897: PUSH
40898: LD_VAR 0 2
40902: ARRAY
40903: PPUSH
40904: LD_INT 25
40906: PUSH
40907: LD_INT 4
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: PPUSH
40914: CALL_OW 72
40918: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40919: LD_VAR 0 3
40923: NOT
40924: PUSH
40925: LD_EXP 113
40929: PUSH
40930: LD_VAR 0 2
40934: ARRAY
40935: NOT
40936: OR
40937: PUSH
40938: LD_EXP 76
40942: PUSH
40943: LD_VAR 0 2
40947: ARRAY
40948: PPUSH
40949: LD_INT 2
40951: PUSH
40952: LD_INT 30
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 30
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: LIST
40976: PPUSH
40977: CALL_OW 72
40981: NOT
40982: OR
40983: IFFALSE 41033
// begin if mc_deposits_finder [ i ] then
40985: LD_EXP 114
40989: PUSH
40990: LD_VAR 0 2
40994: ARRAY
40995: IFFALSE 41031
// begin MC_Reset ( i , 125 ) ;
40997: LD_VAR 0 2
41001: PPUSH
41002: LD_INT 125
41004: PPUSH
41005: CALL 24334 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41009: LD_ADDR_EXP 114
41013: PUSH
41014: LD_EXP 114
41018: PPUSH
41019: LD_VAR 0 2
41023: PPUSH
41024: EMPTY
41025: PPUSH
41026: CALL_OW 1
41030: ST_TO_ADDR
// end ; continue ;
41031: GO 40885
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41033: LD_EXP 113
41037: PUSH
41038: LD_VAR 0 2
41042: ARRAY
41043: PUSH
41044: LD_INT 1
41046: ARRAY
41047: PUSH
41048: LD_INT 3
41050: ARRAY
41051: PUSH
41052: LD_INT 1
41054: EQUAL
41055: PUSH
41056: LD_INT 20
41058: PPUSH
41059: LD_EXP 102
41063: PUSH
41064: LD_VAR 0 2
41068: ARRAY
41069: PPUSH
41070: CALL_OW 321
41074: PUSH
41075: LD_INT 2
41077: NONEQUAL
41078: AND
41079: IFFALSE 41129
// begin if mc_deposits_finder [ i ] then
41081: LD_EXP 114
41085: PUSH
41086: LD_VAR 0 2
41090: ARRAY
41091: IFFALSE 41127
// begin MC_Reset ( i , 125 ) ;
41093: LD_VAR 0 2
41097: PPUSH
41098: LD_INT 125
41100: PPUSH
41101: CALL 24334 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41105: LD_ADDR_EXP 114
41109: PUSH
41110: LD_EXP 114
41114: PPUSH
41115: LD_VAR 0 2
41119: PPUSH
41120: EMPTY
41121: PPUSH
41122: CALL_OW 1
41126: ST_TO_ADDR
// end ; continue ;
41127: GO 40885
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41129: LD_EXP 113
41133: PUSH
41134: LD_VAR 0 2
41138: ARRAY
41139: PUSH
41140: LD_INT 1
41142: ARRAY
41143: PUSH
41144: LD_INT 1
41146: ARRAY
41147: PPUSH
41148: LD_EXP 113
41152: PUSH
41153: LD_VAR 0 2
41157: ARRAY
41158: PUSH
41159: LD_INT 1
41161: ARRAY
41162: PUSH
41163: LD_INT 2
41165: ARRAY
41166: PPUSH
41167: LD_EXP 102
41171: PUSH
41172: LD_VAR 0 2
41176: ARRAY
41177: PPUSH
41178: CALL_OW 440
41182: IFFALSE 41225
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41184: LD_ADDR_EXP 113
41188: PUSH
41189: LD_EXP 113
41193: PPUSH
41194: LD_VAR 0 2
41198: PPUSH
41199: LD_EXP 113
41203: PUSH
41204: LD_VAR 0 2
41208: ARRAY
41209: PPUSH
41210: LD_INT 1
41212: PPUSH
41213: CALL_OW 3
41217: PPUSH
41218: CALL_OW 1
41222: ST_TO_ADDR
41223: GO 41472
// begin if not mc_deposits_finder [ i ] then
41225: LD_EXP 114
41229: PUSH
41230: LD_VAR 0 2
41234: ARRAY
41235: NOT
41236: IFFALSE 41288
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41238: LD_ADDR_EXP 114
41242: PUSH
41243: LD_EXP 114
41247: PPUSH
41248: LD_VAR 0 2
41252: PPUSH
41253: LD_VAR 0 3
41257: PUSH
41258: LD_INT 1
41260: ARRAY
41261: PUSH
41262: EMPTY
41263: LIST
41264: PPUSH
41265: CALL_OW 1
41269: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41270: LD_VAR 0 3
41274: PUSH
41275: LD_INT 1
41277: ARRAY
41278: PPUSH
41279: LD_INT 125
41281: PPUSH
41282: CALL_OW 109
// end else
41286: GO 41472
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41288: LD_EXP 114
41292: PUSH
41293: LD_VAR 0 2
41297: ARRAY
41298: PUSH
41299: LD_INT 1
41301: ARRAY
41302: PPUSH
41303: CALL_OW 310
41307: IFFALSE 41330
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41309: LD_EXP 114
41313: PUSH
41314: LD_VAR 0 2
41318: ARRAY
41319: PUSH
41320: LD_INT 1
41322: ARRAY
41323: PPUSH
41324: CALL_OW 122
41328: GO 41472
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41330: LD_EXP 114
41334: PUSH
41335: LD_VAR 0 2
41339: ARRAY
41340: PUSH
41341: LD_INT 1
41343: ARRAY
41344: PPUSH
41345: CALL_OW 314
41349: NOT
41350: PUSH
41351: LD_EXP 114
41355: PUSH
41356: LD_VAR 0 2
41360: ARRAY
41361: PUSH
41362: LD_INT 1
41364: ARRAY
41365: PPUSH
41366: LD_EXP 113
41370: PUSH
41371: LD_VAR 0 2
41375: ARRAY
41376: PUSH
41377: LD_INT 1
41379: ARRAY
41380: PUSH
41381: LD_INT 1
41383: ARRAY
41384: PPUSH
41385: LD_EXP 113
41389: PUSH
41390: LD_VAR 0 2
41394: ARRAY
41395: PUSH
41396: LD_INT 1
41398: ARRAY
41399: PUSH
41400: LD_INT 2
41402: ARRAY
41403: PPUSH
41404: CALL_OW 297
41408: PUSH
41409: LD_INT 6
41411: GREATER
41412: AND
41413: IFFALSE 41472
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41415: LD_EXP 114
41419: PUSH
41420: LD_VAR 0 2
41424: ARRAY
41425: PUSH
41426: LD_INT 1
41428: ARRAY
41429: PPUSH
41430: LD_EXP 113
41434: PUSH
41435: LD_VAR 0 2
41439: ARRAY
41440: PUSH
41441: LD_INT 1
41443: ARRAY
41444: PUSH
41445: LD_INT 1
41447: ARRAY
41448: PPUSH
41449: LD_EXP 113
41453: PUSH
41454: LD_VAR 0 2
41458: ARRAY
41459: PUSH
41460: LD_INT 1
41462: ARRAY
41463: PUSH
41464: LD_INT 2
41466: ARRAY
41467: PPUSH
41468: CALL_OW 111
// end ; end ; end ;
41472: GO 40885
41474: POP
41475: POP
// end ;
41476: LD_VAR 0 1
41480: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41481: LD_INT 0
41483: PPUSH
41484: PPUSH
41485: PPUSH
41486: PPUSH
41487: PPUSH
41488: PPUSH
41489: PPUSH
41490: PPUSH
41491: PPUSH
41492: PPUSH
41493: PPUSH
// if not mc_bases then
41494: LD_EXP 76
41498: NOT
41499: IFFALSE 41503
// exit ;
41501: GO 42443
// for i = 1 to mc_bases do
41503: LD_ADDR_VAR 0 2
41507: PUSH
41508: DOUBLE
41509: LD_INT 1
41511: DEC
41512: ST_TO_ADDR
41513: LD_EXP 76
41517: PUSH
41518: FOR_TO
41519: IFFALSE 42441
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41521: LD_EXP 76
41525: PUSH
41526: LD_VAR 0 2
41530: ARRAY
41531: NOT
41532: PUSH
41533: LD_EXP 99
41537: PUSH
41538: LD_VAR 0 2
41542: ARRAY
41543: OR
41544: IFFALSE 41548
// continue ;
41546: GO 41518
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41548: LD_ADDR_VAR 0 7
41552: PUSH
41553: LD_EXP 76
41557: PUSH
41558: LD_VAR 0 2
41562: ARRAY
41563: PUSH
41564: LD_INT 1
41566: ARRAY
41567: PPUSH
41568: CALL_OW 248
41572: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41573: LD_VAR 0 7
41577: PUSH
41578: LD_INT 3
41580: EQUAL
41581: PUSH
41582: LD_EXP 95
41586: PUSH
41587: LD_VAR 0 2
41591: ARRAY
41592: PUSH
41593: LD_EXP 98
41597: PUSH
41598: LD_VAR 0 2
41602: ARRAY
41603: UNION
41604: PPUSH
41605: LD_INT 33
41607: PUSH
41608: LD_INT 2
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: PPUSH
41615: CALL_OW 72
41619: NOT
41620: OR
41621: IFFALSE 41625
// continue ;
41623: GO 41518
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41625: LD_ADDR_VAR 0 9
41629: PUSH
41630: LD_EXP 76
41634: PUSH
41635: LD_VAR 0 2
41639: ARRAY
41640: PPUSH
41641: LD_INT 30
41643: PUSH
41644: LD_INT 36
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PPUSH
41651: CALL_OW 72
41655: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41656: LD_ADDR_VAR 0 10
41660: PUSH
41661: LD_EXP 95
41665: PUSH
41666: LD_VAR 0 2
41670: ARRAY
41671: PPUSH
41672: LD_INT 34
41674: PUSH
41675: LD_INT 31
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PPUSH
41682: CALL_OW 72
41686: ST_TO_ADDR
// if not cts and not mcts then
41687: LD_VAR 0 9
41691: NOT
41692: PUSH
41693: LD_VAR 0 10
41697: NOT
41698: AND
41699: IFFALSE 41703
// continue ;
41701: GO 41518
// x := cts ;
41703: LD_ADDR_VAR 0 11
41707: PUSH
41708: LD_VAR 0 9
41712: ST_TO_ADDR
// if not x then
41713: LD_VAR 0 11
41717: NOT
41718: IFFALSE 41730
// x := mcts ;
41720: LD_ADDR_VAR 0 11
41724: PUSH
41725: LD_VAR 0 10
41729: ST_TO_ADDR
// if not x then
41730: LD_VAR 0 11
41734: NOT
41735: IFFALSE 41739
// continue ;
41737: GO 41518
// if mc_remote_driver [ i ] then
41739: LD_EXP 116
41743: PUSH
41744: LD_VAR 0 2
41748: ARRAY
41749: IFFALSE 42136
// for j in mc_remote_driver [ i ] do
41751: LD_ADDR_VAR 0 3
41755: PUSH
41756: LD_EXP 116
41760: PUSH
41761: LD_VAR 0 2
41765: ARRAY
41766: PUSH
41767: FOR_IN
41768: IFFALSE 42134
// begin if GetClass ( j ) <> 3 then
41770: LD_VAR 0 3
41774: PPUSH
41775: CALL_OW 257
41779: PUSH
41780: LD_INT 3
41782: NONEQUAL
41783: IFFALSE 41836
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41785: LD_ADDR_EXP 116
41789: PUSH
41790: LD_EXP 116
41794: PPUSH
41795: LD_VAR 0 2
41799: PPUSH
41800: LD_EXP 116
41804: PUSH
41805: LD_VAR 0 2
41809: ARRAY
41810: PUSH
41811: LD_VAR 0 3
41815: DIFF
41816: PPUSH
41817: CALL_OW 1
41821: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41822: LD_VAR 0 3
41826: PPUSH
41827: LD_INT 0
41829: PPUSH
41830: CALL_OW 109
// continue ;
41834: GO 41767
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41836: LD_EXP 95
41840: PUSH
41841: LD_VAR 0 2
41845: ARRAY
41846: PPUSH
41847: LD_INT 34
41849: PUSH
41850: LD_INT 31
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 58
41859: PUSH
41860: EMPTY
41861: LIST
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PPUSH
41867: CALL_OW 72
41871: PUSH
41872: LD_VAR 0 3
41876: PPUSH
41877: CALL 90984 0 1
41881: NOT
41882: AND
41883: IFFALSE 41954
// begin if IsInUnit ( j ) then
41885: LD_VAR 0 3
41889: PPUSH
41890: CALL_OW 310
41894: IFFALSE 41905
// ComExitBuilding ( j ) ;
41896: LD_VAR 0 3
41900: PPUSH
41901: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
41905: LD_VAR 0 3
41909: PPUSH
41910: LD_EXP 95
41914: PUSH
41915: LD_VAR 0 2
41919: ARRAY
41920: PPUSH
41921: LD_INT 34
41923: PUSH
41924: LD_INT 31
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: LD_INT 58
41933: PUSH
41934: EMPTY
41935: LIST
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PPUSH
41941: CALL_OW 72
41945: PUSH
41946: LD_INT 1
41948: ARRAY
41949: PPUSH
41950: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41954: LD_VAR 0 3
41958: PPUSH
41959: CALL_OW 310
41963: NOT
41964: PUSH
41965: LD_VAR 0 3
41969: PPUSH
41970: CALL_OW 310
41974: PPUSH
41975: CALL_OW 266
41979: PUSH
41980: LD_INT 36
41982: NONEQUAL
41983: PUSH
41984: LD_VAR 0 3
41988: PPUSH
41989: CALL 90984 0 1
41993: NOT
41994: AND
41995: OR
41996: IFFALSE 42132
// begin if IsInUnit ( j ) then
41998: LD_VAR 0 3
42002: PPUSH
42003: CALL_OW 310
42007: IFFALSE 42018
// ComExitBuilding ( j ) ;
42009: LD_VAR 0 3
42013: PPUSH
42014: CALL_OW 122
// ct := 0 ;
42018: LD_ADDR_VAR 0 8
42022: PUSH
42023: LD_INT 0
42025: ST_TO_ADDR
// for k in x do
42026: LD_ADDR_VAR 0 4
42030: PUSH
42031: LD_VAR 0 11
42035: PUSH
42036: FOR_IN
42037: IFFALSE 42110
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42039: LD_VAR 0 4
42043: PPUSH
42044: CALL_OW 264
42048: PUSH
42049: LD_INT 31
42051: EQUAL
42052: PUSH
42053: LD_VAR 0 4
42057: PPUSH
42058: CALL_OW 311
42062: NOT
42063: AND
42064: PUSH
42065: LD_VAR 0 4
42069: PPUSH
42070: CALL_OW 266
42074: PUSH
42075: LD_INT 36
42077: EQUAL
42078: PUSH
42079: LD_VAR 0 4
42083: PPUSH
42084: CALL_OW 313
42088: PUSH
42089: LD_INT 3
42091: LESS
42092: AND
42093: OR
42094: IFFALSE 42108
// begin ct := k ;
42096: LD_ADDR_VAR 0 8
42100: PUSH
42101: LD_VAR 0 4
42105: ST_TO_ADDR
// break ;
42106: GO 42110
// end ;
42108: GO 42036
42110: POP
42111: POP
// if ct then
42112: LD_VAR 0 8
42116: IFFALSE 42132
// ComEnterUnit ( j , ct ) ;
42118: LD_VAR 0 3
42122: PPUSH
42123: LD_VAR 0 8
42127: PPUSH
42128: CALL_OW 120
// end ; end ;
42132: GO 41767
42134: POP
42135: POP
// places := 0 ;
42136: LD_ADDR_VAR 0 5
42140: PUSH
42141: LD_INT 0
42143: ST_TO_ADDR
// for j = 1 to x do
42144: LD_ADDR_VAR 0 3
42148: PUSH
42149: DOUBLE
42150: LD_INT 1
42152: DEC
42153: ST_TO_ADDR
42154: LD_VAR 0 11
42158: PUSH
42159: FOR_TO
42160: IFFALSE 42236
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42162: LD_VAR 0 11
42166: PUSH
42167: LD_VAR 0 3
42171: ARRAY
42172: PPUSH
42173: CALL_OW 264
42177: PUSH
42178: LD_INT 31
42180: EQUAL
42181: IFFALSE 42199
// places := places + 1 else
42183: LD_ADDR_VAR 0 5
42187: PUSH
42188: LD_VAR 0 5
42192: PUSH
42193: LD_INT 1
42195: PLUS
42196: ST_TO_ADDR
42197: GO 42234
// if GetBType ( x [ j ] ) = b_control_tower then
42199: LD_VAR 0 11
42203: PUSH
42204: LD_VAR 0 3
42208: ARRAY
42209: PPUSH
42210: CALL_OW 266
42214: PUSH
42215: LD_INT 36
42217: EQUAL
42218: IFFALSE 42234
// places := places + 3 ;
42220: LD_ADDR_VAR 0 5
42224: PUSH
42225: LD_VAR 0 5
42229: PUSH
42230: LD_INT 3
42232: PLUS
42233: ST_TO_ADDR
42234: GO 42159
42236: POP
42237: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42238: LD_VAR 0 5
42242: PUSH
42243: LD_INT 0
42245: EQUAL
42246: PUSH
42247: LD_VAR 0 5
42251: PUSH
42252: LD_EXP 116
42256: PUSH
42257: LD_VAR 0 2
42261: ARRAY
42262: LESSEQUAL
42263: OR
42264: IFFALSE 42268
// continue ;
42266: GO 41518
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42268: LD_ADDR_VAR 0 6
42272: PUSH
42273: LD_EXP 76
42277: PUSH
42278: LD_VAR 0 2
42282: ARRAY
42283: PPUSH
42284: LD_INT 25
42286: PUSH
42287: LD_INT 3
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PPUSH
42294: CALL_OW 72
42298: PUSH
42299: LD_EXP 116
42303: PUSH
42304: LD_VAR 0 2
42308: ARRAY
42309: DIFF
42310: PPUSH
42311: LD_INT 3
42313: PPUSH
42314: CALL 91884 0 2
42318: ST_TO_ADDR
// for j in tmp do
42319: LD_ADDR_VAR 0 3
42323: PUSH
42324: LD_VAR 0 6
42328: PUSH
42329: FOR_IN
42330: IFFALSE 42365
// if GetTag ( j ) > 0 then
42332: LD_VAR 0 3
42336: PPUSH
42337: CALL_OW 110
42341: PUSH
42342: LD_INT 0
42344: GREATER
42345: IFFALSE 42363
// tmp := tmp diff j ;
42347: LD_ADDR_VAR 0 6
42351: PUSH
42352: LD_VAR 0 6
42356: PUSH
42357: LD_VAR 0 3
42361: DIFF
42362: ST_TO_ADDR
42363: GO 42329
42365: POP
42366: POP
// if not tmp then
42367: LD_VAR 0 6
42371: NOT
42372: IFFALSE 42376
// continue ;
42374: GO 41518
// if places then
42376: LD_VAR 0 5
42380: IFFALSE 42439
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42382: LD_ADDR_EXP 116
42386: PUSH
42387: LD_EXP 116
42391: PPUSH
42392: LD_VAR 0 2
42396: PPUSH
42397: LD_EXP 116
42401: PUSH
42402: LD_VAR 0 2
42406: ARRAY
42407: PUSH
42408: LD_VAR 0 6
42412: PUSH
42413: LD_INT 1
42415: ARRAY
42416: UNION
42417: PPUSH
42418: CALL_OW 1
42422: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42423: LD_VAR 0 6
42427: PUSH
42428: LD_INT 1
42430: ARRAY
42431: PPUSH
42432: LD_INT 126
42434: PPUSH
42435: CALL_OW 109
// end ; end ;
42439: GO 41518
42441: POP
42442: POP
// end ;
42443: LD_VAR 0 1
42447: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42448: LD_INT 0
42450: PPUSH
42451: PPUSH
42452: PPUSH
42453: PPUSH
42454: PPUSH
42455: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42456: LD_VAR 0 1
42460: NOT
42461: PUSH
42462: LD_VAR 0 2
42466: NOT
42467: OR
42468: PUSH
42469: LD_VAR 0 3
42473: NOT
42474: OR
42475: PUSH
42476: LD_VAR 0 4
42480: PUSH
42481: LD_INT 1
42483: PUSH
42484: LD_INT 2
42486: PUSH
42487: LD_INT 3
42489: PUSH
42490: LD_INT 4
42492: PUSH
42493: LD_INT 5
42495: PUSH
42496: LD_INT 8
42498: PUSH
42499: LD_INT 9
42501: PUSH
42502: LD_INT 15
42504: PUSH
42505: LD_INT 16
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: LIST
42512: LIST
42513: LIST
42514: LIST
42515: LIST
42516: LIST
42517: LIST
42518: IN
42519: NOT
42520: OR
42521: IFFALSE 42525
// exit ;
42523: GO 43425
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42525: LD_ADDR_VAR 0 2
42529: PUSH
42530: LD_VAR 0 2
42534: PPUSH
42535: LD_INT 21
42537: PUSH
42538: LD_INT 3
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 24
42547: PUSH
42548: LD_INT 250
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PPUSH
42559: CALL_OW 72
42563: ST_TO_ADDR
// case class of 1 , 15 :
42564: LD_VAR 0 4
42568: PUSH
42569: LD_INT 1
42571: DOUBLE
42572: EQUAL
42573: IFTRUE 42583
42575: LD_INT 15
42577: DOUBLE
42578: EQUAL
42579: IFTRUE 42583
42581: GO 42668
42583: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42584: LD_ADDR_VAR 0 8
42588: PUSH
42589: LD_VAR 0 2
42593: PPUSH
42594: LD_INT 2
42596: PUSH
42597: LD_INT 30
42599: PUSH
42600: LD_INT 32
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: PUSH
42607: LD_INT 30
42609: PUSH
42610: LD_INT 31
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: LIST
42621: PPUSH
42622: CALL_OW 72
42626: PUSH
42627: LD_VAR 0 2
42631: PPUSH
42632: LD_INT 2
42634: PUSH
42635: LD_INT 30
42637: PUSH
42638: LD_INT 4
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 30
42647: PUSH
42648: LD_INT 5
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: LIST
42659: PPUSH
42660: CALL_OW 72
42664: ADD
42665: ST_TO_ADDR
42666: GO 42914
42668: LD_INT 2
42670: DOUBLE
42671: EQUAL
42672: IFTRUE 42682
42674: LD_INT 16
42676: DOUBLE
42677: EQUAL
42678: IFTRUE 42682
42680: GO 42728
42682: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42683: LD_ADDR_VAR 0 8
42687: PUSH
42688: LD_VAR 0 2
42692: PPUSH
42693: LD_INT 2
42695: PUSH
42696: LD_INT 30
42698: PUSH
42699: LD_INT 0
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: LD_INT 30
42708: PUSH
42709: LD_INT 1
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: LIST
42720: PPUSH
42721: CALL_OW 72
42725: ST_TO_ADDR
42726: GO 42914
42728: LD_INT 3
42730: DOUBLE
42731: EQUAL
42732: IFTRUE 42736
42734: GO 42782
42736: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42737: LD_ADDR_VAR 0 8
42741: PUSH
42742: LD_VAR 0 2
42746: PPUSH
42747: LD_INT 2
42749: PUSH
42750: LD_INT 30
42752: PUSH
42753: LD_INT 2
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 30
42762: PUSH
42763: LD_INT 3
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: LIST
42774: PPUSH
42775: CALL_OW 72
42779: ST_TO_ADDR
42780: GO 42914
42782: LD_INT 4
42784: DOUBLE
42785: EQUAL
42786: IFTRUE 42790
42788: GO 42847
42790: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42791: LD_ADDR_VAR 0 8
42795: PUSH
42796: LD_VAR 0 2
42800: PPUSH
42801: LD_INT 2
42803: PUSH
42804: LD_INT 30
42806: PUSH
42807: LD_INT 6
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PUSH
42814: LD_INT 30
42816: PUSH
42817: LD_INT 7
42819: PUSH
42820: EMPTY
42821: LIST
42822: LIST
42823: PUSH
42824: LD_INT 30
42826: PUSH
42827: LD_INT 8
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: PUSH
42834: EMPTY
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: PPUSH
42840: CALL_OW 72
42844: ST_TO_ADDR
42845: GO 42914
42847: LD_INT 5
42849: DOUBLE
42850: EQUAL
42851: IFTRUE 42867
42853: LD_INT 8
42855: DOUBLE
42856: EQUAL
42857: IFTRUE 42867
42859: LD_INT 9
42861: DOUBLE
42862: EQUAL
42863: IFTRUE 42867
42865: GO 42913
42867: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42868: LD_ADDR_VAR 0 8
42872: PUSH
42873: LD_VAR 0 2
42877: PPUSH
42878: LD_INT 2
42880: PUSH
42881: LD_INT 30
42883: PUSH
42884: LD_INT 4
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: LD_INT 30
42893: PUSH
42894: LD_INT 5
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: LIST
42905: PPUSH
42906: CALL_OW 72
42910: ST_TO_ADDR
42911: GO 42914
42913: POP
// if not tmp then
42914: LD_VAR 0 8
42918: NOT
42919: IFFALSE 42923
// exit ;
42921: GO 43425
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42923: LD_VAR 0 4
42927: PUSH
42928: LD_INT 1
42930: PUSH
42931: LD_INT 15
42933: PUSH
42934: EMPTY
42935: LIST
42936: LIST
42937: IN
42938: PUSH
42939: LD_EXP 85
42943: PUSH
42944: LD_VAR 0 1
42948: ARRAY
42949: AND
42950: IFFALSE 43106
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42952: LD_ADDR_VAR 0 9
42956: PUSH
42957: LD_EXP 85
42961: PUSH
42962: LD_VAR 0 1
42966: ARRAY
42967: PUSH
42968: LD_INT 1
42970: ARRAY
42971: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42972: LD_VAR 0 9
42976: PUSH
42977: LD_EXP 86
42981: PUSH
42982: LD_VAR 0 1
42986: ARRAY
42987: IN
42988: NOT
42989: IFFALSE 43104
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42991: LD_ADDR_EXP 86
42995: PUSH
42996: LD_EXP 86
43000: PPUSH
43001: LD_VAR 0 1
43005: PUSH
43006: LD_EXP 86
43010: PUSH
43011: LD_VAR 0 1
43015: ARRAY
43016: PUSH
43017: LD_INT 1
43019: PLUS
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PPUSH
43025: LD_VAR 0 9
43029: PPUSH
43030: CALL 57636 0 3
43034: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43035: LD_ADDR_EXP 85
43039: PUSH
43040: LD_EXP 85
43044: PPUSH
43045: LD_VAR 0 1
43049: PPUSH
43050: LD_EXP 85
43054: PUSH
43055: LD_VAR 0 1
43059: ARRAY
43060: PUSH
43061: LD_VAR 0 9
43065: DIFF
43066: PPUSH
43067: CALL_OW 1
43071: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43072: LD_VAR 0 3
43076: PPUSH
43077: LD_EXP 86
43081: PUSH
43082: LD_VAR 0 1
43086: ARRAY
43087: PUSH
43088: LD_EXP 86
43092: PUSH
43093: LD_VAR 0 1
43097: ARRAY
43098: ARRAY
43099: PPUSH
43100: CALL_OW 120
// end ; exit ;
43104: GO 43425
// end ; if tmp > 1 then
43106: LD_VAR 0 8
43110: PUSH
43111: LD_INT 1
43113: GREATER
43114: IFFALSE 43218
// for i = 2 to tmp do
43116: LD_ADDR_VAR 0 6
43120: PUSH
43121: DOUBLE
43122: LD_INT 2
43124: DEC
43125: ST_TO_ADDR
43126: LD_VAR 0 8
43130: PUSH
43131: FOR_TO
43132: IFFALSE 43216
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43134: LD_VAR 0 8
43138: PUSH
43139: LD_VAR 0 6
43143: ARRAY
43144: PPUSH
43145: CALL_OW 461
43149: PUSH
43150: LD_INT 6
43152: EQUAL
43153: IFFALSE 43214
// begin x := tmp [ i ] ;
43155: LD_ADDR_VAR 0 9
43159: PUSH
43160: LD_VAR 0 8
43164: PUSH
43165: LD_VAR 0 6
43169: ARRAY
43170: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43171: LD_ADDR_VAR 0 8
43175: PUSH
43176: LD_VAR 0 8
43180: PPUSH
43181: LD_VAR 0 6
43185: PPUSH
43186: CALL_OW 3
43190: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43191: LD_ADDR_VAR 0 8
43195: PUSH
43196: LD_VAR 0 8
43200: PPUSH
43201: LD_INT 1
43203: PPUSH
43204: LD_VAR 0 9
43208: PPUSH
43209: CALL_OW 2
43213: ST_TO_ADDR
// end ;
43214: GO 43131
43216: POP
43217: POP
// for i in tmp do
43218: LD_ADDR_VAR 0 6
43222: PUSH
43223: LD_VAR 0 8
43227: PUSH
43228: FOR_IN
43229: IFFALSE 43298
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43231: LD_VAR 0 6
43235: PPUSH
43236: CALL_OW 313
43240: PUSH
43241: LD_INT 6
43243: LESS
43244: PUSH
43245: LD_VAR 0 6
43249: PPUSH
43250: CALL_OW 266
43254: PUSH
43255: LD_INT 31
43257: PUSH
43258: LD_INT 32
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: IN
43265: NOT
43266: AND
43267: PUSH
43268: LD_VAR 0 6
43272: PPUSH
43273: CALL_OW 313
43277: PUSH
43278: LD_INT 0
43280: EQUAL
43281: OR
43282: IFFALSE 43296
// begin j := i ;
43284: LD_ADDR_VAR 0 7
43288: PUSH
43289: LD_VAR 0 6
43293: ST_TO_ADDR
// break ;
43294: GO 43298
// end ; end ;
43296: GO 43228
43298: POP
43299: POP
// if j then
43300: LD_VAR 0 7
43304: IFFALSE 43322
// ComEnterUnit ( unit , j ) else
43306: LD_VAR 0 3
43310: PPUSH
43311: LD_VAR 0 7
43315: PPUSH
43316: CALL_OW 120
43320: GO 43425
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43322: LD_ADDR_VAR 0 10
43326: PUSH
43327: LD_VAR 0 2
43331: PPUSH
43332: LD_INT 2
43334: PUSH
43335: LD_INT 30
43337: PUSH
43338: LD_INT 0
43340: PUSH
43341: EMPTY
43342: LIST
43343: LIST
43344: PUSH
43345: LD_INT 30
43347: PUSH
43348: LD_INT 1
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: PUSH
43355: EMPTY
43356: LIST
43357: LIST
43358: LIST
43359: PPUSH
43360: CALL_OW 72
43364: ST_TO_ADDR
// if depot then
43365: LD_VAR 0 10
43369: IFFALSE 43425
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43371: LD_ADDR_VAR 0 10
43375: PUSH
43376: LD_VAR 0 10
43380: PPUSH
43381: LD_VAR 0 3
43385: PPUSH
43386: CALL_OW 74
43390: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43391: LD_VAR 0 3
43395: PPUSH
43396: LD_VAR 0 10
43400: PPUSH
43401: CALL_OW 296
43405: PUSH
43406: LD_INT 10
43408: GREATER
43409: IFFALSE 43425
// ComStandNearbyBuilding ( unit , depot ) ;
43411: LD_VAR 0 3
43415: PPUSH
43416: LD_VAR 0 10
43420: PPUSH
43421: CALL 51839 0 2
// end ; end ; end ;
43425: LD_VAR 0 5
43429: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43430: LD_INT 0
43432: PPUSH
43433: PPUSH
43434: PPUSH
43435: PPUSH
// if not mc_bases then
43436: LD_EXP 76
43440: NOT
43441: IFFALSE 43445
// exit ;
43443: GO 43684
// for i = 1 to mc_bases do
43445: LD_ADDR_VAR 0 2
43449: PUSH
43450: DOUBLE
43451: LD_INT 1
43453: DEC
43454: ST_TO_ADDR
43455: LD_EXP 76
43459: PUSH
43460: FOR_TO
43461: IFFALSE 43682
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43463: LD_ADDR_VAR 0 4
43467: PUSH
43468: LD_EXP 76
43472: PUSH
43473: LD_VAR 0 2
43477: ARRAY
43478: PPUSH
43479: LD_INT 21
43481: PUSH
43482: LD_INT 1
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PPUSH
43489: CALL_OW 72
43493: PUSH
43494: LD_EXP 105
43498: PUSH
43499: LD_VAR 0 2
43503: ARRAY
43504: UNION
43505: ST_TO_ADDR
// if not tmp then
43506: LD_VAR 0 4
43510: NOT
43511: IFFALSE 43515
// continue ;
43513: GO 43460
// for j in tmp do
43515: LD_ADDR_VAR 0 3
43519: PUSH
43520: LD_VAR 0 4
43524: PUSH
43525: FOR_IN
43526: IFFALSE 43678
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43528: LD_VAR 0 3
43532: PPUSH
43533: CALL_OW 110
43537: NOT
43538: PUSH
43539: LD_VAR 0 3
43543: PPUSH
43544: CALL_OW 314
43548: NOT
43549: AND
43550: PUSH
43551: LD_VAR 0 3
43555: PPUSH
43556: CALL_OW 311
43560: NOT
43561: AND
43562: PUSH
43563: LD_VAR 0 3
43567: PPUSH
43568: CALL_OW 310
43572: NOT
43573: AND
43574: PUSH
43575: LD_VAR 0 3
43579: PUSH
43580: LD_EXP 79
43584: PUSH
43585: LD_VAR 0 2
43589: ARRAY
43590: PUSH
43591: LD_INT 1
43593: ARRAY
43594: IN
43595: NOT
43596: AND
43597: PUSH
43598: LD_VAR 0 3
43602: PUSH
43603: LD_EXP 79
43607: PUSH
43608: LD_VAR 0 2
43612: ARRAY
43613: PUSH
43614: LD_INT 2
43616: ARRAY
43617: IN
43618: NOT
43619: AND
43620: PUSH
43621: LD_VAR 0 3
43625: PUSH
43626: LD_EXP 88
43630: PUSH
43631: LD_VAR 0 2
43635: ARRAY
43636: IN
43637: NOT
43638: AND
43639: IFFALSE 43676
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43641: LD_VAR 0 2
43645: PPUSH
43646: LD_EXP 76
43650: PUSH
43651: LD_VAR 0 2
43655: ARRAY
43656: PPUSH
43657: LD_VAR 0 3
43661: PPUSH
43662: LD_VAR 0 3
43666: PPUSH
43667: CALL_OW 257
43671: PPUSH
43672: CALL 42448 0 4
// end ;
43676: GO 43525
43678: POP
43679: POP
// end ;
43680: GO 43460
43682: POP
43683: POP
// end ;
43684: LD_VAR 0 1
43688: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43689: LD_INT 0
43691: PPUSH
43692: PPUSH
43693: PPUSH
43694: PPUSH
43695: PPUSH
43696: PPUSH
// if not mc_bases [ base ] then
43697: LD_EXP 76
43701: PUSH
43702: LD_VAR 0 1
43706: ARRAY
43707: NOT
43708: IFFALSE 43712
// exit ;
43710: GO 43894
// tmp := [ ] ;
43712: LD_ADDR_VAR 0 6
43716: PUSH
43717: EMPTY
43718: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43719: LD_ADDR_VAR 0 7
43723: PUSH
43724: LD_VAR 0 3
43728: PPUSH
43729: LD_INT 0
43731: PPUSH
43732: CALL_OW 517
43736: ST_TO_ADDR
// if not list then
43737: LD_VAR 0 7
43741: NOT
43742: IFFALSE 43746
// exit ;
43744: GO 43894
// for i = 1 to amount do
43746: LD_ADDR_VAR 0 5
43750: PUSH
43751: DOUBLE
43752: LD_INT 1
43754: DEC
43755: ST_TO_ADDR
43756: LD_VAR 0 2
43760: PUSH
43761: FOR_TO
43762: IFFALSE 43842
// begin x := rand ( 1 , list [ 1 ] ) ;
43764: LD_ADDR_VAR 0 8
43768: PUSH
43769: LD_INT 1
43771: PPUSH
43772: LD_VAR 0 7
43776: PUSH
43777: LD_INT 1
43779: ARRAY
43780: PPUSH
43781: CALL_OW 12
43785: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43786: LD_ADDR_VAR 0 6
43790: PUSH
43791: LD_VAR 0 6
43795: PPUSH
43796: LD_VAR 0 5
43800: PPUSH
43801: LD_VAR 0 7
43805: PUSH
43806: LD_INT 1
43808: ARRAY
43809: PUSH
43810: LD_VAR 0 8
43814: ARRAY
43815: PUSH
43816: LD_VAR 0 7
43820: PUSH
43821: LD_INT 2
43823: ARRAY
43824: PUSH
43825: LD_VAR 0 8
43829: ARRAY
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PPUSH
43835: CALL_OW 1
43839: ST_TO_ADDR
// end ;
43840: GO 43761
43842: POP
43843: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43844: LD_ADDR_EXP 89
43848: PUSH
43849: LD_EXP 89
43853: PPUSH
43854: LD_VAR 0 1
43858: PPUSH
43859: LD_VAR 0 6
43863: PPUSH
43864: CALL_OW 1
43868: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43869: LD_ADDR_EXP 91
43873: PUSH
43874: LD_EXP 91
43878: PPUSH
43879: LD_VAR 0 1
43883: PPUSH
43884: LD_VAR 0 3
43888: PPUSH
43889: CALL_OW 1
43893: ST_TO_ADDR
// end ;
43894: LD_VAR 0 4
43898: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43899: LD_INT 0
43901: PPUSH
// if not mc_bases [ base ] then
43902: LD_EXP 76
43906: PUSH
43907: LD_VAR 0 1
43911: ARRAY
43912: NOT
43913: IFFALSE 43917
// exit ;
43915: GO 43942
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43917: LD_ADDR_EXP 81
43921: PUSH
43922: LD_EXP 81
43926: PPUSH
43927: LD_VAR 0 1
43931: PPUSH
43932: LD_VAR 0 2
43936: PPUSH
43937: CALL_OW 1
43941: ST_TO_ADDR
// end ;
43942: LD_VAR 0 3
43946: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43947: LD_INT 0
43949: PPUSH
// if not mc_bases [ base ] then
43950: LD_EXP 76
43954: PUSH
43955: LD_VAR 0 1
43959: ARRAY
43960: NOT
43961: IFFALSE 43965
// exit ;
43963: GO 44002
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43965: LD_ADDR_EXP 81
43969: PUSH
43970: LD_EXP 81
43974: PPUSH
43975: LD_VAR 0 1
43979: PPUSH
43980: LD_EXP 81
43984: PUSH
43985: LD_VAR 0 1
43989: ARRAY
43990: PUSH
43991: LD_VAR 0 2
43995: UNION
43996: PPUSH
43997: CALL_OW 1
44001: ST_TO_ADDR
// end ;
44002: LD_VAR 0 3
44006: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44007: LD_INT 0
44009: PPUSH
// if not mc_bases [ base ] then
44010: LD_EXP 76
44014: PUSH
44015: LD_VAR 0 1
44019: ARRAY
44020: NOT
44021: IFFALSE 44025
// exit ;
44023: GO 44050
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44025: LD_ADDR_EXP 97
44029: PUSH
44030: LD_EXP 97
44034: PPUSH
44035: LD_VAR 0 1
44039: PPUSH
44040: LD_VAR 0 2
44044: PPUSH
44045: CALL_OW 1
44049: ST_TO_ADDR
// end ;
44050: LD_VAR 0 3
44054: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44055: LD_INT 0
44057: PPUSH
// if not mc_bases [ base ] then
44058: LD_EXP 76
44062: PUSH
44063: LD_VAR 0 1
44067: ARRAY
44068: NOT
44069: IFFALSE 44073
// exit ;
44071: GO 44110
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44073: LD_ADDR_EXP 97
44077: PUSH
44078: LD_EXP 97
44082: PPUSH
44083: LD_VAR 0 1
44087: PPUSH
44088: LD_EXP 97
44092: PUSH
44093: LD_VAR 0 1
44097: ARRAY
44098: PUSH
44099: LD_VAR 0 2
44103: ADD
44104: PPUSH
44105: CALL_OW 1
44109: ST_TO_ADDR
// end ;
44110: LD_VAR 0 3
44114: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44115: LD_INT 0
44117: PPUSH
// if not mc_bases [ base ] then
44118: LD_EXP 76
44122: PUSH
44123: LD_VAR 0 1
44127: ARRAY
44128: NOT
44129: IFFALSE 44133
// exit ;
44131: GO 44187
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44133: LD_ADDR_EXP 98
44137: PUSH
44138: LD_EXP 98
44142: PPUSH
44143: LD_VAR 0 1
44147: PPUSH
44148: LD_VAR 0 2
44152: PPUSH
44153: CALL_OW 1
44157: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44158: LD_ADDR_EXP 87
44162: PUSH
44163: LD_EXP 87
44167: PPUSH
44168: LD_VAR 0 1
44172: PPUSH
44173: LD_VAR 0 2
44177: PUSH
44178: LD_INT 0
44180: PLUS
44181: PPUSH
44182: CALL_OW 1
44186: ST_TO_ADDR
// end ;
44187: LD_VAR 0 3
44191: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44192: LD_INT 0
44194: PPUSH
// if not mc_bases [ base ] then
44195: LD_EXP 76
44199: PUSH
44200: LD_VAR 0 1
44204: ARRAY
44205: NOT
44206: IFFALSE 44210
// exit ;
44208: GO 44235
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44210: LD_ADDR_EXP 87
44214: PUSH
44215: LD_EXP 87
44219: PPUSH
44220: LD_VAR 0 1
44224: PPUSH
44225: LD_VAR 0 2
44229: PPUSH
44230: CALL_OW 1
44234: ST_TO_ADDR
// end ;
44235: LD_VAR 0 3
44239: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44240: LD_INT 0
44242: PPUSH
44243: PPUSH
44244: PPUSH
44245: PPUSH
// if not mc_bases [ base ] then
44246: LD_EXP 76
44250: PUSH
44251: LD_VAR 0 1
44255: ARRAY
44256: NOT
44257: IFFALSE 44261
// exit ;
44259: GO 44326
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44261: LD_ADDR_EXP 96
44265: PUSH
44266: LD_EXP 96
44270: PPUSH
44271: LD_VAR 0 1
44275: PUSH
44276: LD_EXP 96
44280: PUSH
44281: LD_VAR 0 1
44285: ARRAY
44286: PUSH
44287: LD_INT 1
44289: PLUS
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PPUSH
44295: LD_VAR 0 1
44299: PUSH
44300: LD_VAR 0 2
44304: PUSH
44305: LD_VAR 0 3
44309: PUSH
44310: LD_VAR 0 4
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: LIST
44319: LIST
44320: PPUSH
44321: CALL 57636 0 3
44325: ST_TO_ADDR
// end ;
44326: LD_VAR 0 5
44330: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44331: LD_INT 0
44333: PPUSH
// if not mc_bases [ base ] then
44334: LD_EXP 76
44338: PUSH
44339: LD_VAR 0 1
44343: ARRAY
44344: NOT
44345: IFFALSE 44349
// exit ;
44347: GO 44374
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44349: LD_ADDR_EXP 113
44353: PUSH
44354: LD_EXP 113
44358: PPUSH
44359: LD_VAR 0 1
44363: PPUSH
44364: LD_VAR 0 2
44368: PPUSH
44369: CALL_OW 1
44373: ST_TO_ADDR
// end ;
44374: LD_VAR 0 3
44378: RET
// export function MC_GetMinesField ( base ) ; begin
44379: LD_INT 0
44381: PPUSH
// result := mc_mines [ base ] ;
44382: LD_ADDR_VAR 0 2
44386: PUSH
44387: LD_EXP 89
44391: PUSH
44392: LD_VAR 0 1
44396: ARRAY
44397: ST_TO_ADDR
// end ;
44398: LD_VAR 0 2
44402: RET
// export function MC_GetProduceList ( base ) ; begin
44403: LD_INT 0
44405: PPUSH
// result := mc_produce [ base ] ;
44406: LD_ADDR_VAR 0 2
44410: PUSH
44411: LD_EXP 97
44415: PUSH
44416: LD_VAR 0 1
44420: ARRAY
44421: ST_TO_ADDR
// end ;
44422: LD_VAR 0 2
44426: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44427: LD_INT 0
44429: PPUSH
44430: PPUSH
// if not mc_bases then
44431: LD_EXP 76
44435: NOT
44436: IFFALSE 44440
// exit ;
44438: GO 44505
// if mc_bases [ base ] then
44440: LD_EXP 76
44444: PUSH
44445: LD_VAR 0 1
44449: ARRAY
44450: IFFALSE 44505
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44452: LD_ADDR_VAR 0 3
44456: PUSH
44457: LD_EXP 76
44461: PUSH
44462: LD_VAR 0 1
44466: ARRAY
44467: PPUSH
44468: LD_INT 30
44470: PUSH
44471: LD_VAR 0 2
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PPUSH
44480: CALL_OW 72
44484: ST_TO_ADDR
// if result then
44485: LD_VAR 0 3
44489: IFFALSE 44505
// result := result [ 1 ] ;
44491: LD_ADDR_VAR 0 3
44495: PUSH
44496: LD_VAR 0 3
44500: PUSH
44501: LD_INT 1
44503: ARRAY
44504: ST_TO_ADDR
// end ; end ;
44505: LD_VAR 0 3
44509: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44510: LD_INT 0
44512: PPUSH
44513: PPUSH
// if not mc_bases then
44514: LD_EXP 76
44518: NOT
44519: IFFALSE 44523
// exit ;
44521: GO 44568
// if mc_bases [ base ] then
44523: LD_EXP 76
44527: PUSH
44528: LD_VAR 0 1
44532: ARRAY
44533: IFFALSE 44568
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44535: LD_ADDR_VAR 0 3
44539: PUSH
44540: LD_EXP 76
44544: PUSH
44545: LD_VAR 0 1
44549: ARRAY
44550: PPUSH
44551: LD_INT 30
44553: PUSH
44554: LD_VAR 0 2
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PPUSH
44563: CALL_OW 72
44567: ST_TO_ADDR
// end ;
44568: LD_VAR 0 3
44572: RET
// export function MC_SetTame ( base , area ) ; begin
44573: LD_INT 0
44575: PPUSH
// if not mc_bases or not base then
44576: LD_EXP 76
44580: NOT
44581: PUSH
44582: LD_VAR 0 1
44586: NOT
44587: OR
44588: IFFALSE 44592
// exit ;
44590: GO 44617
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44592: LD_ADDR_EXP 104
44596: PUSH
44597: LD_EXP 104
44601: PPUSH
44602: LD_VAR 0 1
44606: PPUSH
44607: LD_VAR 0 2
44611: PPUSH
44612: CALL_OW 1
44616: ST_TO_ADDR
// end ;
44617: LD_VAR 0 3
44621: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44622: LD_INT 0
44624: PPUSH
44625: PPUSH
// if not mc_bases or not base then
44626: LD_EXP 76
44630: NOT
44631: PUSH
44632: LD_VAR 0 1
44636: NOT
44637: OR
44638: IFFALSE 44642
// exit ;
44640: GO 44744
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44642: LD_ADDR_VAR 0 4
44646: PUSH
44647: LD_EXP 76
44651: PUSH
44652: LD_VAR 0 1
44656: ARRAY
44657: PPUSH
44658: LD_INT 30
44660: PUSH
44661: LD_VAR 0 2
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PPUSH
44670: CALL_OW 72
44674: ST_TO_ADDR
// if not tmp then
44675: LD_VAR 0 4
44679: NOT
44680: IFFALSE 44684
// exit ;
44682: GO 44744
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44684: LD_ADDR_EXP 108
44688: PUSH
44689: LD_EXP 108
44693: PPUSH
44694: LD_VAR 0 1
44698: PPUSH
44699: LD_EXP 108
44703: PUSH
44704: LD_VAR 0 1
44708: ARRAY
44709: PPUSH
44710: LD_EXP 108
44714: PUSH
44715: LD_VAR 0 1
44719: ARRAY
44720: PUSH
44721: LD_INT 1
44723: PLUS
44724: PPUSH
44725: LD_VAR 0 4
44729: PUSH
44730: LD_INT 1
44732: ARRAY
44733: PPUSH
44734: CALL_OW 2
44738: PPUSH
44739: CALL_OW 1
44743: ST_TO_ADDR
// end ;
44744: LD_VAR 0 3
44748: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44749: LD_INT 0
44751: PPUSH
44752: PPUSH
// if not mc_bases or not base or not kinds then
44753: LD_EXP 76
44757: NOT
44758: PUSH
44759: LD_VAR 0 1
44763: NOT
44764: OR
44765: PUSH
44766: LD_VAR 0 2
44770: NOT
44771: OR
44772: IFFALSE 44776
// exit ;
44774: GO 44837
// for i in kinds do
44776: LD_ADDR_VAR 0 4
44780: PUSH
44781: LD_VAR 0 2
44785: PUSH
44786: FOR_IN
44787: IFFALSE 44835
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44789: LD_ADDR_EXP 110
44793: PUSH
44794: LD_EXP 110
44798: PPUSH
44799: LD_VAR 0 1
44803: PUSH
44804: LD_EXP 110
44808: PUSH
44809: LD_VAR 0 1
44813: ARRAY
44814: PUSH
44815: LD_INT 1
44817: PLUS
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PPUSH
44823: LD_VAR 0 4
44827: PPUSH
44828: CALL 57636 0 3
44832: ST_TO_ADDR
44833: GO 44786
44835: POP
44836: POP
// end ;
44837: LD_VAR 0 3
44841: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44842: LD_INT 0
44844: PPUSH
// if not mc_bases or not base or not areas then
44845: LD_EXP 76
44849: NOT
44850: PUSH
44851: LD_VAR 0 1
44855: NOT
44856: OR
44857: PUSH
44858: LD_VAR 0 2
44862: NOT
44863: OR
44864: IFFALSE 44868
// exit ;
44866: GO 44893
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44868: LD_ADDR_EXP 94
44872: PUSH
44873: LD_EXP 94
44877: PPUSH
44878: LD_VAR 0 1
44882: PPUSH
44883: LD_VAR 0 2
44887: PPUSH
44888: CALL_OW 1
44892: ST_TO_ADDR
// end ;
44893: LD_VAR 0 3
44897: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44898: LD_INT 0
44900: PPUSH
// if not mc_bases or not base or not teleports_exit then
44901: LD_EXP 76
44905: NOT
44906: PUSH
44907: LD_VAR 0 1
44911: NOT
44912: OR
44913: PUSH
44914: LD_VAR 0 2
44918: NOT
44919: OR
44920: IFFALSE 44924
// exit ;
44922: GO 44949
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44924: LD_ADDR_EXP 111
44928: PUSH
44929: LD_EXP 111
44933: PPUSH
44934: LD_VAR 0 1
44938: PPUSH
44939: LD_VAR 0 2
44943: PPUSH
44944: CALL_OW 1
44948: ST_TO_ADDR
// end ;
44949: LD_VAR 0 3
44953: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44954: LD_INT 0
44956: PPUSH
44957: PPUSH
44958: PPUSH
// if not mc_bases or not base or not ext_list then
44959: LD_EXP 76
44963: NOT
44964: PUSH
44965: LD_VAR 0 1
44969: NOT
44970: OR
44971: PUSH
44972: LD_VAR 0 5
44976: NOT
44977: OR
44978: IFFALSE 44982
// exit ;
44980: GO 45155
// tmp := GetFacExtXYD ( x , y , d ) ;
44982: LD_ADDR_VAR 0 8
44986: PUSH
44987: LD_VAR 0 2
44991: PPUSH
44992: LD_VAR 0 3
44996: PPUSH
44997: LD_VAR 0 4
45001: PPUSH
45002: CALL 91014 0 3
45006: ST_TO_ADDR
// if not tmp then
45007: LD_VAR 0 8
45011: NOT
45012: IFFALSE 45016
// exit ;
45014: GO 45155
// for i in tmp do
45016: LD_ADDR_VAR 0 7
45020: PUSH
45021: LD_VAR 0 8
45025: PUSH
45026: FOR_IN
45027: IFFALSE 45153
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45029: LD_ADDR_EXP 81
45033: PUSH
45034: LD_EXP 81
45038: PPUSH
45039: LD_VAR 0 1
45043: PPUSH
45044: LD_EXP 81
45048: PUSH
45049: LD_VAR 0 1
45053: ARRAY
45054: PPUSH
45055: LD_EXP 81
45059: PUSH
45060: LD_VAR 0 1
45064: ARRAY
45065: PUSH
45066: LD_INT 1
45068: PLUS
45069: PPUSH
45070: LD_VAR 0 5
45074: PUSH
45075: LD_INT 1
45077: ARRAY
45078: PUSH
45079: LD_VAR 0 7
45083: PUSH
45084: LD_INT 1
45086: ARRAY
45087: PUSH
45088: LD_VAR 0 7
45092: PUSH
45093: LD_INT 2
45095: ARRAY
45096: PUSH
45097: LD_VAR 0 7
45101: PUSH
45102: LD_INT 3
45104: ARRAY
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: LIST
45110: LIST
45111: PPUSH
45112: CALL_OW 2
45116: PPUSH
45117: CALL_OW 1
45121: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45122: LD_ADDR_VAR 0 5
45126: PUSH
45127: LD_VAR 0 5
45131: PPUSH
45132: LD_INT 1
45134: PPUSH
45135: CALL_OW 3
45139: ST_TO_ADDR
// if not ext_list then
45140: LD_VAR 0 5
45144: NOT
45145: IFFALSE 45151
// exit ;
45147: POP
45148: POP
45149: GO 45155
// end ;
45151: GO 45026
45153: POP
45154: POP
// end ;
45155: LD_VAR 0 6
45159: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45160: LD_INT 0
45162: PPUSH
// if not mc_bases or not base or not weapon_list then
45163: LD_EXP 76
45167: NOT
45168: PUSH
45169: LD_VAR 0 1
45173: NOT
45174: OR
45175: PUSH
45176: LD_VAR 0 2
45180: NOT
45181: OR
45182: IFFALSE 45186
// exit ;
45184: GO 45211
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45186: LD_ADDR_EXP 115
45190: PUSH
45191: LD_EXP 115
45195: PPUSH
45196: LD_VAR 0 1
45200: PPUSH
45201: LD_VAR 0 2
45205: PPUSH
45206: CALL_OW 1
45210: ST_TO_ADDR
// end ;
45211: LD_VAR 0 3
45215: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45216: LD_INT 0
45218: PPUSH
// if not mc_bases or not base or not tech_list then
45219: LD_EXP 76
45223: NOT
45224: PUSH
45225: LD_VAR 0 1
45229: NOT
45230: OR
45231: PUSH
45232: LD_VAR 0 2
45236: NOT
45237: OR
45238: IFFALSE 45242
// exit ;
45240: GO 45267
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45242: LD_ADDR_EXP 103
45246: PUSH
45247: LD_EXP 103
45251: PPUSH
45252: LD_VAR 0 1
45256: PPUSH
45257: LD_VAR 0 2
45261: PPUSH
45262: CALL_OW 1
45266: ST_TO_ADDR
// end ;
45267: LD_VAR 0 3
45271: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45272: LD_INT 0
45274: PPUSH
// if not mc_bases or not parking_area or not base then
45275: LD_EXP 76
45279: NOT
45280: PUSH
45281: LD_VAR 0 2
45285: NOT
45286: OR
45287: PUSH
45288: LD_VAR 0 1
45292: NOT
45293: OR
45294: IFFALSE 45298
// exit ;
45296: GO 45323
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45298: LD_ADDR_EXP 100
45302: PUSH
45303: LD_EXP 100
45307: PPUSH
45308: LD_VAR 0 1
45312: PPUSH
45313: LD_VAR 0 2
45317: PPUSH
45318: CALL_OW 1
45322: ST_TO_ADDR
// end ;
45323: LD_VAR 0 3
45327: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45328: LD_INT 0
45330: PPUSH
// if not mc_bases or not base or not scan_area then
45331: LD_EXP 76
45335: NOT
45336: PUSH
45337: LD_VAR 0 1
45341: NOT
45342: OR
45343: PUSH
45344: LD_VAR 0 2
45348: NOT
45349: OR
45350: IFFALSE 45354
// exit ;
45352: GO 45379
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45354: LD_ADDR_EXP 101
45358: PUSH
45359: LD_EXP 101
45363: PPUSH
45364: LD_VAR 0 1
45368: PPUSH
45369: LD_VAR 0 2
45373: PPUSH
45374: CALL_OW 1
45378: ST_TO_ADDR
// end ;
45379: LD_VAR 0 3
45383: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45384: LD_INT 0
45386: PPUSH
45387: PPUSH
// if not mc_bases or not base then
45388: LD_EXP 76
45392: NOT
45393: PUSH
45394: LD_VAR 0 1
45398: NOT
45399: OR
45400: IFFALSE 45404
// exit ;
45402: GO 45468
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45404: LD_ADDR_VAR 0 3
45408: PUSH
45409: LD_INT 1
45411: PUSH
45412: LD_INT 2
45414: PUSH
45415: LD_INT 3
45417: PUSH
45418: LD_INT 4
45420: PUSH
45421: LD_INT 11
45423: PUSH
45424: EMPTY
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45431: LD_ADDR_EXP 103
45435: PUSH
45436: LD_EXP 103
45440: PPUSH
45441: LD_VAR 0 1
45445: PPUSH
45446: LD_EXP 103
45450: PUSH
45451: LD_VAR 0 1
45455: ARRAY
45456: PUSH
45457: LD_VAR 0 3
45461: DIFF
45462: PPUSH
45463: CALL_OW 1
45467: ST_TO_ADDR
// end ;
45468: LD_VAR 0 2
45472: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45473: LD_INT 0
45475: PPUSH
// result := mc_vehicles [ base ] ;
45476: LD_ADDR_VAR 0 3
45480: PUSH
45481: LD_EXP 95
45485: PUSH
45486: LD_VAR 0 1
45490: ARRAY
45491: ST_TO_ADDR
// if onlyCombat then
45492: LD_VAR 0 2
45496: IFFALSE 45661
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45498: LD_ADDR_VAR 0 3
45502: PUSH
45503: LD_VAR 0 3
45507: PUSH
45508: LD_VAR 0 3
45512: PPUSH
45513: LD_INT 2
45515: PUSH
45516: LD_INT 34
45518: PUSH
45519: LD_INT 12
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: LD_INT 34
45528: PUSH
45529: LD_INT 51
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PUSH
45536: LD_INT 34
45538: PUSH
45539: LD_EXP 70
45543: PUSH
45544: EMPTY
45545: LIST
45546: LIST
45547: PUSH
45548: LD_INT 34
45550: PUSH
45551: LD_INT 32
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: PUSH
45558: LD_INT 34
45560: PUSH
45561: LD_INT 13
45563: PUSH
45564: EMPTY
45565: LIST
45566: LIST
45567: PUSH
45568: LD_INT 34
45570: PUSH
45571: LD_INT 52
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: PUSH
45578: LD_INT 34
45580: PUSH
45581: LD_INT 14
45583: PUSH
45584: EMPTY
45585: LIST
45586: LIST
45587: PUSH
45588: LD_INT 34
45590: PUSH
45591: LD_INT 53
45593: PUSH
45594: EMPTY
45595: LIST
45596: LIST
45597: PUSH
45598: LD_INT 34
45600: PUSH
45601: LD_EXP 69
45605: PUSH
45606: EMPTY
45607: LIST
45608: LIST
45609: PUSH
45610: LD_INT 34
45612: PUSH
45613: LD_INT 31
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: PUSH
45620: LD_INT 34
45622: PUSH
45623: LD_INT 48
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: LD_INT 34
45632: PUSH
45633: LD_INT 8
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: PUSH
45640: EMPTY
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: PPUSH
45655: CALL_OW 72
45659: DIFF
45660: ST_TO_ADDR
// end ; end_of_file
45661: LD_VAR 0 3
45665: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45666: LD_INT 0
45668: PPUSH
45669: PPUSH
45670: PPUSH
// if not mc_bases or not skirmish then
45671: LD_EXP 76
45675: NOT
45676: PUSH
45677: LD_EXP 74
45681: NOT
45682: OR
45683: IFFALSE 45687
// exit ;
45685: GO 45852
// for i = 1 to mc_bases do
45687: LD_ADDR_VAR 0 4
45691: PUSH
45692: DOUBLE
45693: LD_INT 1
45695: DEC
45696: ST_TO_ADDR
45697: LD_EXP 76
45701: PUSH
45702: FOR_TO
45703: IFFALSE 45850
// begin if sci in mc_bases [ i ] then
45705: LD_VAR 0 2
45709: PUSH
45710: LD_EXP 76
45714: PUSH
45715: LD_VAR 0 4
45719: ARRAY
45720: IN
45721: IFFALSE 45848
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45723: LD_ADDR_EXP 105
45727: PUSH
45728: LD_EXP 105
45732: PPUSH
45733: LD_VAR 0 4
45737: PUSH
45738: LD_EXP 105
45742: PUSH
45743: LD_VAR 0 4
45747: ARRAY
45748: PUSH
45749: LD_INT 1
45751: PLUS
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PPUSH
45757: LD_VAR 0 1
45761: PPUSH
45762: CALL 57636 0 3
45766: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45767: LD_ADDR_VAR 0 5
45771: PUSH
45772: LD_EXP 76
45776: PUSH
45777: LD_VAR 0 4
45781: ARRAY
45782: PPUSH
45783: LD_INT 2
45785: PUSH
45786: LD_INT 30
45788: PUSH
45789: LD_INT 0
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 30
45798: PUSH
45799: LD_INT 1
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: EMPTY
45807: LIST
45808: LIST
45809: LIST
45810: PPUSH
45811: CALL_OW 72
45815: PPUSH
45816: LD_VAR 0 1
45820: PPUSH
45821: CALL_OW 74
45825: ST_TO_ADDR
// if tmp then
45826: LD_VAR 0 5
45830: IFFALSE 45846
// ComStandNearbyBuilding ( ape , tmp ) ;
45832: LD_VAR 0 1
45836: PPUSH
45837: LD_VAR 0 5
45841: PPUSH
45842: CALL 51839 0 2
// break ;
45846: GO 45850
// end ; end ;
45848: GO 45702
45850: POP
45851: POP
// end ;
45852: LD_VAR 0 3
45856: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45857: LD_INT 0
45859: PPUSH
45860: PPUSH
45861: PPUSH
// if not mc_bases or not skirmish then
45862: LD_EXP 76
45866: NOT
45867: PUSH
45868: LD_EXP 74
45872: NOT
45873: OR
45874: IFFALSE 45878
// exit ;
45876: GO 45967
// for i = 1 to mc_bases do
45878: LD_ADDR_VAR 0 4
45882: PUSH
45883: DOUBLE
45884: LD_INT 1
45886: DEC
45887: ST_TO_ADDR
45888: LD_EXP 76
45892: PUSH
45893: FOR_TO
45894: IFFALSE 45965
// begin if building in mc_busy_turret_list [ i ] then
45896: LD_VAR 0 1
45900: PUSH
45901: LD_EXP 86
45905: PUSH
45906: LD_VAR 0 4
45910: ARRAY
45911: IN
45912: IFFALSE 45963
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45914: LD_ADDR_VAR 0 5
45918: PUSH
45919: LD_EXP 86
45923: PUSH
45924: LD_VAR 0 4
45928: ARRAY
45929: PUSH
45930: LD_VAR 0 1
45934: DIFF
45935: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45936: LD_ADDR_EXP 86
45940: PUSH
45941: LD_EXP 86
45945: PPUSH
45946: LD_VAR 0 4
45950: PPUSH
45951: LD_VAR 0 5
45955: PPUSH
45956: CALL_OW 1
45960: ST_TO_ADDR
// break ;
45961: GO 45965
// end ; end ;
45963: GO 45893
45965: POP
45966: POP
// end ;
45967: LD_VAR 0 3
45971: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45972: LD_INT 0
45974: PPUSH
45975: PPUSH
45976: PPUSH
// if not mc_bases or not skirmish then
45977: LD_EXP 76
45981: NOT
45982: PUSH
45983: LD_EXP 74
45987: NOT
45988: OR
45989: IFFALSE 45993
// exit ;
45991: GO 46192
// for i = 1 to mc_bases do
45993: LD_ADDR_VAR 0 5
45997: PUSH
45998: DOUBLE
45999: LD_INT 1
46001: DEC
46002: ST_TO_ADDR
46003: LD_EXP 76
46007: PUSH
46008: FOR_TO
46009: IFFALSE 46190
// if building in mc_bases [ i ] then
46011: LD_VAR 0 1
46015: PUSH
46016: LD_EXP 76
46020: PUSH
46021: LD_VAR 0 5
46025: ARRAY
46026: IN
46027: IFFALSE 46188
// begin tmp := mc_bases [ i ] diff building ;
46029: LD_ADDR_VAR 0 6
46033: PUSH
46034: LD_EXP 76
46038: PUSH
46039: LD_VAR 0 5
46043: ARRAY
46044: PUSH
46045: LD_VAR 0 1
46049: DIFF
46050: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46051: LD_ADDR_EXP 76
46055: PUSH
46056: LD_EXP 76
46060: PPUSH
46061: LD_VAR 0 5
46065: PPUSH
46066: LD_VAR 0 6
46070: PPUSH
46071: CALL_OW 1
46075: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46076: LD_VAR 0 1
46080: PUSH
46081: LD_EXP 84
46085: PUSH
46086: LD_VAR 0 5
46090: ARRAY
46091: IN
46092: IFFALSE 46131
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46094: LD_ADDR_EXP 84
46098: PUSH
46099: LD_EXP 84
46103: PPUSH
46104: LD_VAR 0 5
46108: PPUSH
46109: LD_EXP 84
46113: PUSH
46114: LD_VAR 0 5
46118: ARRAY
46119: PUSH
46120: LD_VAR 0 1
46124: DIFF
46125: PPUSH
46126: CALL_OW 1
46130: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46131: LD_VAR 0 1
46135: PUSH
46136: LD_EXP 85
46140: PUSH
46141: LD_VAR 0 5
46145: ARRAY
46146: IN
46147: IFFALSE 46186
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46149: LD_ADDR_EXP 85
46153: PUSH
46154: LD_EXP 85
46158: PPUSH
46159: LD_VAR 0 5
46163: PPUSH
46164: LD_EXP 85
46168: PUSH
46169: LD_VAR 0 5
46173: ARRAY
46174: PUSH
46175: LD_VAR 0 1
46179: DIFF
46180: PPUSH
46181: CALL_OW 1
46185: ST_TO_ADDR
// break ;
46186: GO 46190
// end ;
46188: GO 46008
46190: POP
46191: POP
// end ;
46192: LD_VAR 0 4
46196: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46197: LD_INT 0
46199: PPUSH
46200: PPUSH
46201: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46202: LD_EXP 76
46206: NOT
46207: PUSH
46208: LD_EXP 74
46212: NOT
46213: OR
46214: PUSH
46215: LD_VAR 0 3
46219: PUSH
46220: LD_EXP 102
46224: IN
46225: NOT
46226: OR
46227: IFFALSE 46231
// exit ;
46229: GO 46354
// for i = 1 to mc_vehicles do
46231: LD_ADDR_VAR 0 6
46235: PUSH
46236: DOUBLE
46237: LD_INT 1
46239: DEC
46240: ST_TO_ADDR
46241: LD_EXP 95
46245: PUSH
46246: FOR_TO
46247: IFFALSE 46352
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46249: LD_VAR 0 2
46253: PUSH
46254: LD_EXP 95
46258: PUSH
46259: LD_VAR 0 6
46263: ARRAY
46264: IN
46265: PUSH
46266: LD_VAR 0 1
46270: PUSH
46271: LD_EXP 95
46275: PUSH
46276: LD_VAR 0 6
46280: ARRAY
46281: IN
46282: OR
46283: IFFALSE 46350
// begin tmp := mc_vehicles [ i ] diff old ;
46285: LD_ADDR_VAR 0 7
46289: PUSH
46290: LD_EXP 95
46294: PUSH
46295: LD_VAR 0 6
46299: ARRAY
46300: PUSH
46301: LD_VAR 0 2
46305: DIFF
46306: ST_TO_ADDR
// tmp := tmp diff new ;
46307: LD_ADDR_VAR 0 7
46311: PUSH
46312: LD_VAR 0 7
46316: PUSH
46317: LD_VAR 0 1
46321: DIFF
46322: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46323: LD_ADDR_EXP 95
46327: PUSH
46328: LD_EXP 95
46332: PPUSH
46333: LD_VAR 0 6
46337: PPUSH
46338: LD_VAR 0 7
46342: PPUSH
46343: CALL_OW 1
46347: ST_TO_ADDR
// break ;
46348: GO 46352
// end ;
46350: GO 46246
46352: POP
46353: POP
// end ;
46354: LD_VAR 0 5
46358: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46359: LD_INT 0
46361: PPUSH
46362: PPUSH
46363: PPUSH
46364: PPUSH
// if not mc_bases or not skirmish then
46365: LD_EXP 76
46369: NOT
46370: PUSH
46371: LD_EXP 74
46375: NOT
46376: OR
46377: IFFALSE 46381
// exit ;
46379: GO 46758
// side := GetSide ( vehicle ) ;
46381: LD_ADDR_VAR 0 5
46385: PUSH
46386: LD_VAR 0 1
46390: PPUSH
46391: CALL_OW 255
46395: ST_TO_ADDR
// for i = 1 to mc_bases do
46396: LD_ADDR_VAR 0 4
46400: PUSH
46401: DOUBLE
46402: LD_INT 1
46404: DEC
46405: ST_TO_ADDR
46406: LD_EXP 76
46410: PUSH
46411: FOR_TO
46412: IFFALSE 46756
// begin if factory in mc_bases [ i ] then
46414: LD_VAR 0 2
46418: PUSH
46419: LD_EXP 76
46423: PUSH
46424: LD_VAR 0 4
46428: ARRAY
46429: IN
46430: IFFALSE 46754
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46432: LD_EXP 98
46436: PUSH
46437: LD_VAR 0 4
46441: ARRAY
46442: PUSH
46443: LD_EXP 87
46447: PUSH
46448: LD_VAR 0 4
46452: ARRAY
46453: LESS
46454: PUSH
46455: LD_VAR 0 1
46459: PPUSH
46460: CALL_OW 264
46464: PUSH
46465: LD_INT 31
46467: PUSH
46468: LD_INT 32
46470: PUSH
46471: LD_INT 51
46473: PUSH
46474: LD_EXP 70
46478: PUSH
46479: LD_INT 12
46481: PUSH
46482: LD_INT 30
46484: PUSH
46485: LD_EXP 69
46489: PUSH
46490: LD_INT 11
46492: PUSH
46493: LD_INT 53
46495: PUSH
46496: LD_INT 14
46498: PUSH
46499: LD_EXP 73
46503: PUSH
46504: LD_INT 29
46506: PUSH
46507: LD_EXP 71
46511: PUSH
46512: LD_INT 13
46514: PUSH
46515: LD_INT 52
46517: PUSH
46518: LD_INT 48
46520: PUSH
46521: LD_INT 8
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: IN
46543: NOT
46544: AND
46545: IFFALSE 46593
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46547: LD_ADDR_EXP 98
46551: PUSH
46552: LD_EXP 98
46556: PPUSH
46557: LD_VAR 0 4
46561: PUSH
46562: LD_EXP 98
46566: PUSH
46567: LD_VAR 0 4
46571: ARRAY
46572: PUSH
46573: LD_INT 1
46575: PLUS
46576: PUSH
46577: EMPTY
46578: LIST
46579: LIST
46580: PPUSH
46581: LD_VAR 0 1
46585: PPUSH
46586: CALL 57636 0 3
46590: ST_TO_ADDR
46591: GO 46637
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46593: LD_ADDR_EXP 95
46597: PUSH
46598: LD_EXP 95
46602: PPUSH
46603: LD_VAR 0 4
46607: PUSH
46608: LD_EXP 95
46612: PUSH
46613: LD_VAR 0 4
46617: ARRAY
46618: PUSH
46619: LD_INT 1
46621: PLUS
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PPUSH
46627: LD_VAR 0 1
46631: PPUSH
46632: CALL 57636 0 3
46636: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46637: LD_VAR 0 1
46641: PPUSH
46642: CALL_OW 263
46646: PUSH
46647: LD_INT 2
46649: EQUAL
46650: IFFALSE 46670
// begin repeat wait ( 0 0$1 ) ;
46652: LD_INT 35
46654: PPUSH
46655: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46659: LD_VAR 0 1
46663: PPUSH
46664: CALL_OW 312
46668: IFFALSE 46652
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46670: LD_VAR 0 1
46674: PPUSH
46675: LD_EXP 100
46679: PUSH
46680: LD_VAR 0 4
46684: ARRAY
46685: PPUSH
46686: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46690: LD_VAR 0 1
46694: PPUSH
46695: CALL_OW 263
46699: PUSH
46700: LD_INT 1
46702: NONEQUAL
46703: IFFALSE 46707
// break ;
46705: GO 46756
// repeat wait ( 0 0$1 ) ;
46707: LD_INT 35
46709: PPUSH
46710: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46714: LD_VAR 0 1
46718: PPUSH
46719: LD_EXP 100
46723: PUSH
46724: LD_VAR 0 4
46728: ARRAY
46729: PPUSH
46730: CALL_OW 308
46734: IFFALSE 46707
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46736: LD_VAR 0 1
46740: PPUSH
46741: CALL_OW 311
46745: PPUSH
46746: CALL_OW 121
// exit ;
46750: POP
46751: POP
46752: GO 46758
// end ; end ;
46754: GO 46411
46756: POP
46757: POP
// end ;
46758: LD_VAR 0 3
46762: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46763: LD_INT 0
46765: PPUSH
46766: PPUSH
46767: PPUSH
46768: PPUSH
// if not mc_bases or not skirmish then
46769: LD_EXP 76
46773: NOT
46774: PUSH
46775: LD_EXP 74
46779: NOT
46780: OR
46781: IFFALSE 46785
// exit ;
46783: GO 47138
// repeat wait ( 0 0$1 ) ;
46785: LD_INT 35
46787: PPUSH
46788: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46792: LD_VAR 0 2
46796: PPUSH
46797: LD_VAR 0 3
46801: PPUSH
46802: CALL_OW 284
46806: IFFALSE 46785
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46808: LD_VAR 0 2
46812: PPUSH
46813: LD_VAR 0 3
46817: PPUSH
46818: CALL_OW 283
46822: PUSH
46823: LD_INT 4
46825: EQUAL
46826: IFFALSE 46830
// exit ;
46828: GO 47138
// for i = 1 to mc_bases do
46830: LD_ADDR_VAR 0 7
46834: PUSH
46835: DOUBLE
46836: LD_INT 1
46838: DEC
46839: ST_TO_ADDR
46840: LD_EXP 76
46844: PUSH
46845: FOR_TO
46846: IFFALSE 47136
// begin if mc_crates_area [ i ] then
46848: LD_EXP 94
46852: PUSH
46853: LD_VAR 0 7
46857: ARRAY
46858: IFFALSE 46969
// for j in mc_crates_area [ i ] do
46860: LD_ADDR_VAR 0 8
46864: PUSH
46865: LD_EXP 94
46869: PUSH
46870: LD_VAR 0 7
46874: ARRAY
46875: PUSH
46876: FOR_IN
46877: IFFALSE 46967
// if InArea ( x , y , j ) then
46879: LD_VAR 0 2
46883: PPUSH
46884: LD_VAR 0 3
46888: PPUSH
46889: LD_VAR 0 8
46893: PPUSH
46894: CALL_OW 309
46898: IFFALSE 46965
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46900: LD_ADDR_EXP 92
46904: PUSH
46905: LD_EXP 92
46909: PPUSH
46910: LD_VAR 0 7
46914: PUSH
46915: LD_EXP 92
46919: PUSH
46920: LD_VAR 0 7
46924: ARRAY
46925: PUSH
46926: LD_INT 1
46928: PLUS
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: PPUSH
46934: LD_VAR 0 4
46938: PUSH
46939: LD_VAR 0 2
46943: PUSH
46944: LD_VAR 0 3
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: LIST
46953: PPUSH
46954: CALL 57636 0 3
46958: ST_TO_ADDR
// exit ;
46959: POP
46960: POP
46961: POP
46962: POP
46963: GO 47138
// end ;
46965: GO 46876
46967: POP
46968: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46969: LD_ADDR_VAR 0 9
46973: PUSH
46974: LD_EXP 76
46978: PUSH
46979: LD_VAR 0 7
46983: ARRAY
46984: PPUSH
46985: LD_INT 2
46987: PUSH
46988: LD_INT 30
46990: PUSH
46991: LD_INT 0
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: PUSH
46998: LD_INT 30
47000: PUSH
47001: LD_INT 1
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: PUSH
47008: EMPTY
47009: LIST
47010: LIST
47011: LIST
47012: PPUSH
47013: CALL_OW 72
47017: ST_TO_ADDR
// if not depot then
47018: LD_VAR 0 9
47022: NOT
47023: IFFALSE 47027
// continue ;
47025: GO 46845
// for j in depot do
47027: LD_ADDR_VAR 0 8
47031: PUSH
47032: LD_VAR 0 9
47036: PUSH
47037: FOR_IN
47038: IFFALSE 47132
// if GetDistUnitXY ( j , x , y ) < 30 then
47040: LD_VAR 0 8
47044: PPUSH
47045: LD_VAR 0 2
47049: PPUSH
47050: LD_VAR 0 3
47054: PPUSH
47055: CALL_OW 297
47059: PUSH
47060: LD_INT 30
47062: LESS
47063: IFFALSE 47130
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47065: LD_ADDR_EXP 92
47069: PUSH
47070: LD_EXP 92
47074: PPUSH
47075: LD_VAR 0 7
47079: PUSH
47080: LD_EXP 92
47084: PUSH
47085: LD_VAR 0 7
47089: ARRAY
47090: PUSH
47091: LD_INT 1
47093: PLUS
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: PPUSH
47099: LD_VAR 0 4
47103: PUSH
47104: LD_VAR 0 2
47108: PUSH
47109: LD_VAR 0 3
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: LIST
47118: PPUSH
47119: CALL 57636 0 3
47123: ST_TO_ADDR
// exit ;
47124: POP
47125: POP
47126: POP
47127: POP
47128: GO 47138
// end ;
47130: GO 47037
47132: POP
47133: POP
// end ;
47134: GO 46845
47136: POP
47137: POP
// end ;
47138: LD_VAR 0 6
47142: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47143: LD_INT 0
47145: PPUSH
47146: PPUSH
47147: PPUSH
47148: PPUSH
// if not mc_bases or not skirmish then
47149: LD_EXP 76
47153: NOT
47154: PUSH
47155: LD_EXP 74
47159: NOT
47160: OR
47161: IFFALSE 47165
// exit ;
47163: GO 47442
// side := GetSide ( lab ) ;
47165: LD_ADDR_VAR 0 4
47169: PUSH
47170: LD_VAR 0 2
47174: PPUSH
47175: CALL_OW 255
47179: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47180: LD_VAR 0 4
47184: PUSH
47185: LD_EXP 102
47189: IN
47190: NOT
47191: PUSH
47192: LD_EXP 103
47196: NOT
47197: OR
47198: PUSH
47199: LD_EXP 76
47203: NOT
47204: OR
47205: IFFALSE 47209
// exit ;
47207: GO 47442
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47209: LD_ADDR_EXP 103
47213: PUSH
47214: LD_EXP 103
47218: PPUSH
47219: LD_VAR 0 4
47223: PPUSH
47224: LD_EXP 103
47228: PUSH
47229: LD_VAR 0 4
47233: ARRAY
47234: PUSH
47235: LD_VAR 0 1
47239: DIFF
47240: PPUSH
47241: CALL_OW 1
47245: ST_TO_ADDR
// for i = 1 to mc_bases do
47246: LD_ADDR_VAR 0 5
47250: PUSH
47251: DOUBLE
47252: LD_INT 1
47254: DEC
47255: ST_TO_ADDR
47256: LD_EXP 76
47260: PUSH
47261: FOR_TO
47262: IFFALSE 47440
// begin if lab in mc_bases [ i ] then
47264: LD_VAR 0 2
47268: PUSH
47269: LD_EXP 76
47273: PUSH
47274: LD_VAR 0 5
47278: ARRAY
47279: IN
47280: IFFALSE 47438
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47282: LD_VAR 0 1
47286: PUSH
47287: LD_INT 11
47289: PUSH
47290: LD_INT 4
47292: PUSH
47293: LD_INT 3
47295: PUSH
47296: LD_INT 2
47298: PUSH
47299: EMPTY
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: IN
47305: PUSH
47306: LD_EXP 106
47310: PUSH
47311: LD_VAR 0 5
47315: ARRAY
47316: AND
47317: IFFALSE 47438
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47319: LD_ADDR_VAR 0 6
47323: PUSH
47324: LD_EXP 106
47328: PUSH
47329: LD_VAR 0 5
47333: ARRAY
47334: PUSH
47335: LD_INT 1
47337: ARRAY
47338: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47339: LD_ADDR_EXP 106
47343: PUSH
47344: LD_EXP 106
47348: PPUSH
47349: LD_VAR 0 5
47353: PPUSH
47354: EMPTY
47355: PPUSH
47356: CALL_OW 1
47360: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47361: LD_VAR 0 6
47365: PPUSH
47366: LD_INT 0
47368: PPUSH
47369: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47373: LD_VAR 0 6
47377: PPUSH
47378: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47382: LD_ADDR_EXP 105
47386: PUSH
47387: LD_EXP 105
47391: PPUSH
47392: LD_VAR 0 5
47396: PPUSH
47397: LD_EXP 105
47401: PUSH
47402: LD_VAR 0 5
47406: ARRAY
47407: PPUSH
47408: LD_INT 1
47410: PPUSH
47411: LD_VAR 0 6
47415: PPUSH
47416: CALL_OW 2
47420: PPUSH
47421: CALL_OW 1
47425: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47426: LD_VAR 0 5
47430: PPUSH
47431: LD_INT 112
47433: PPUSH
47434: CALL 24334 0 2
// end ; end ; end ;
47438: GO 47261
47440: POP
47441: POP
// end ;
47442: LD_VAR 0 3
47446: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47447: LD_INT 0
47449: PPUSH
47450: PPUSH
47451: PPUSH
47452: PPUSH
47453: PPUSH
47454: PPUSH
47455: PPUSH
47456: PPUSH
// if not mc_bases or not skirmish then
47457: LD_EXP 76
47461: NOT
47462: PUSH
47463: LD_EXP 74
47467: NOT
47468: OR
47469: IFFALSE 47473
// exit ;
47471: GO 48844
// for i = 1 to mc_bases do
47473: LD_ADDR_VAR 0 3
47477: PUSH
47478: DOUBLE
47479: LD_INT 1
47481: DEC
47482: ST_TO_ADDR
47483: LD_EXP 76
47487: PUSH
47488: FOR_TO
47489: IFFALSE 48842
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47491: LD_VAR 0 1
47495: PUSH
47496: LD_EXP 76
47500: PUSH
47501: LD_VAR 0 3
47505: ARRAY
47506: IN
47507: PUSH
47508: LD_VAR 0 1
47512: PUSH
47513: LD_EXP 83
47517: PUSH
47518: LD_VAR 0 3
47522: ARRAY
47523: IN
47524: OR
47525: PUSH
47526: LD_VAR 0 1
47530: PUSH
47531: LD_EXP 98
47535: PUSH
47536: LD_VAR 0 3
47540: ARRAY
47541: IN
47542: OR
47543: PUSH
47544: LD_VAR 0 1
47548: PUSH
47549: LD_EXP 95
47553: PUSH
47554: LD_VAR 0 3
47558: ARRAY
47559: IN
47560: OR
47561: PUSH
47562: LD_VAR 0 1
47566: PUSH
47567: LD_EXP 105
47571: PUSH
47572: LD_VAR 0 3
47576: ARRAY
47577: IN
47578: OR
47579: PUSH
47580: LD_VAR 0 1
47584: PUSH
47585: LD_EXP 106
47589: PUSH
47590: LD_VAR 0 3
47594: ARRAY
47595: IN
47596: OR
47597: IFFALSE 48840
// begin if un in mc_ape [ i ] then
47599: LD_VAR 0 1
47603: PUSH
47604: LD_EXP 105
47608: PUSH
47609: LD_VAR 0 3
47613: ARRAY
47614: IN
47615: IFFALSE 47654
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47617: LD_ADDR_EXP 105
47621: PUSH
47622: LD_EXP 105
47626: PPUSH
47627: LD_VAR 0 3
47631: PPUSH
47632: LD_EXP 105
47636: PUSH
47637: LD_VAR 0 3
47641: ARRAY
47642: PUSH
47643: LD_VAR 0 1
47647: DIFF
47648: PPUSH
47649: CALL_OW 1
47653: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47654: LD_VAR 0 1
47658: PUSH
47659: LD_EXP 106
47663: PUSH
47664: LD_VAR 0 3
47668: ARRAY
47669: IN
47670: IFFALSE 47694
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47672: LD_ADDR_EXP 106
47676: PUSH
47677: LD_EXP 106
47681: PPUSH
47682: LD_VAR 0 3
47686: PPUSH
47687: EMPTY
47688: PPUSH
47689: CALL_OW 1
47693: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47694: LD_VAR 0 1
47698: PPUSH
47699: CALL_OW 247
47703: PUSH
47704: LD_INT 2
47706: EQUAL
47707: PUSH
47708: LD_VAR 0 1
47712: PPUSH
47713: CALL_OW 110
47717: PUSH
47718: LD_INT 20
47720: EQUAL
47721: PUSH
47722: LD_VAR 0 1
47726: PUSH
47727: LD_EXP 98
47731: PUSH
47732: LD_VAR 0 3
47736: ARRAY
47737: IN
47738: OR
47739: PUSH
47740: LD_VAR 0 1
47744: PPUSH
47745: CALL_OW 264
47749: PUSH
47750: LD_INT 12
47752: PUSH
47753: LD_INT 51
47755: PUSH
47756: LD_EXP 70
47760: PUSH
47761: LD_INT 32
47763: PUSH
47764: LD_INT 13
47766: PUSH
47767: LD_INT 52
47769: PUSH
47770: LD_INT 31
47772: PUSH
47773: EMPTY
47774: LIST
47775: LIST
47776: LIST
47777: LIST
47778: LIST
47779: LIST
47780: LIST
47781: IN
47782: OR
47783: AND
47784: IFFALSE 48092
// begin if un in mc_defender [ i ] then
47786: LD_VAR 0 1
47790: PUSH
47791: LD_EXP 98
47795: PUSH
47796: LD_VAR 0 3
47800: ARRAY
47801: IN
47802: IFFALSE 47841
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47804: LD_ADDR_EXP 98
47808: PUSH
47809: LD_EXP 98
47813: PPUSH
47814: LD_VAR 0 3
47818: PPUSH
47819: LD_EXP 98
47823: PUSH
47824: LD_VAR 0 3
47828: ARRAY
47829: PUSH
47830: LD_VAR 0 1
47834: DIFF
47835: PPUSH
47836: CALL_OW 1
47840: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47841: LD_ADDR_VAR 0 8
47845: PUSH
47846: LD_VAR 0 3
47850: PPUSH
47851: LD_INT 3
47853: PPUSH
47854: CALL 44510 0 2
47858: ST_TO_ADDR
// if fac then
47859: LD_VAR 0 8
47863: IFFALSE 48092
// begin for j in fac do
47865: LD_ADDR_VAR 0 4
47869: PUSH
47870: LD_VAR 0 8
47874: PUSH
47875: FOR_IN
47876: IFFALSE 48090
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47878: LD_ADDR_VAR 0 9
47882: PUSH
47883: LD_VAR 0 8
47887: PPUSH
47888: LD_VAR 0 1
47892: PPUSH
47893: CALL_OW 265
47897: PPUSH
47898: LD_VAR 0 1
47902: PPUSH
47903: CALL_OW 262
47907: PPUSH
47908: LD_VAR 0 1
47912: PPUSH
47913: CALL_OW 263
47917: PPUSH
47918: LD_VAR 0 1
47922: PPUSH
47923: CALL_OW 264
47927: PPUSH
47928: CALL 55168 0 5
47932: ST_TO_ADDR
// if components then
47933: LD_VAR 0 9
47937: IFFALSE 48088
// begin if GetWeapon ( un ) = ar_control_tower then
47939: LD_VAR 0 1
47943: PPUSH
47944: CALL_OW 264
47948: PUSH
47949: LD_INT 31
47951: EQUAL
47952: IFFALSE 48069
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
47954: LD_VAR 0 1
47958: PPUSH
47959: CALL_OW 311
47963: PPUSH
47964: LD_INT 0
47966: PPUSH
47967: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
47971: LD_ADDR_EXP 116
47975: PUSH
47976: LD_EXP 116
47980: PPUSH
47981: LD_VAR 0 3
47985: PPUSH
47986: LD_EXP 116
47990: PUSH
47991: LD_VAR 0 3
47995: ARRAY
47996: PUSH
47997: LD_VAR 0 1
48001: PPUSH
48002: CALL_OW 311
48006: DIFF
48007: PPUSH
48008: CALL_OW 1
48012: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48013: LD_ADDR_VAR 0 7
48017: PUSH
48018: LD_EXP 97
48022: PUSH
48023: LD_VAR 0 3
48027: ARRAY
48028: PPUSH
48029: LD_INT 1
48031: PPUSH
48032: LD_VAR 0 9
48036: PPUSH
48037: CALL_OW 2
48041: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48042: LD_ADDR_EXP 97
48046: PUSH
48047: LD_EXP 97
48051: PPUSH
48052: LD_VAR 0 3
48056: PPUSH
48057: LD_VAR 0 7
48061: PPUSH
48062: CALL_OW 1
48066: ST_TO_ADDR
// end else
48067: GO 48086
// MC_InsertProduceList ( i , [ components ] ) ;
48069: LD_VAR 0 3
48073: PPUSH
48074: LD_VAR 0 9
48078: PUSH
48079: EMPTY
48080: LIST
48081: PPUSH
48082: CALL 44055 0 2
// break ;
48086: GO 48090
// end ; end ;
48088: GO 47875
48090: POP
48091: POP
// end ; end ; if GetType ( un ) = unit_building then
48092: LD_VAR 0 1
48096: PPUSH
48097: CALL_OW 247
48101: PUSH
48102: LD_INT 3
48104: EQUAL
48105: IFFALSE 48508
// begin btype := GetBType ( un ) ;
48107: LD_ADDR_VAR 0 5
48111: PUSH
48112: LD_VAR 0 1
48116: PPUSH
48117: CALL_OW 266
48121: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48122: LD_VAR 0 5
48126: PUSH
48127: LD_INT 29
48129: PUSH
48130: LD_INT 30
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: IN
48137: IFFALSE 48210
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48139: LD_VAR 0 1
48143: PPUSH
48144: CALL_OW 250
48148: PPUSH
48149: LD_VAR 0 1
48153: PPUSH
48154: CALL_OW 251
48158: PPUSH
48159: LD_VAR 0 1
48163: PPUSH
48164: CALL_OW 255
48168: PPUSH
48169: CALL_OW 440
48173: NOT
48174: IFFALSE 48210
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48176: LD_VAR 0 1
48180: PPUSH
48181: CALL_OW 250
48185: PPUSH
48186: LD_VAR 0 1
48190: PPUSH
48191: CALL_OW 251
48195: PPUSH
48196: LD_VAR 0 1
48200: PPUSH
48201: CALL_OW 255
48205: PPUSH
48206: CALL_OW 441
// end ; if btype = b_warehouse then
48210: LD_VAR 0 5
48214: PUSH
48215: LD_INT 1
48217: EQUAL
48218: IFFALSE 48236
// begin btype := b_depot ;
48220: LD_ADDR_VAR 0 5
48224: PUSH
48225: LD_INT 0
48227: ST_TO_ADDR
// pos := 1 ;
48228: LD_ADDR_VAR 0 6
48232: PUSH
48233: LD_INT 1
48235: ST_TO_ADDR
// end ; if btype = b_factory then
48236: LD_VAR 0 5
48240: PUSH
48241: LD_INT 3
48243: EQUAL
48244: IFFALSE 48262
// begin btype := b_workshop ;
48246: LD_ADDR_VAR 0 5
48250: PUSH
48251: LD_INT 2
48253: ST_TO_ADDR
// pos := 1 ;
48254: LD_ADDR_VAR 0 6
48258: PUSH
48259: LD_INT 1
48261: ST_TO_ADDR
// end ; if btype = b_barracks then
48262: LD_VAR 0 5
48266: PUSH
48267: LD_INT 5
48269: EQUAL
48270: IFFALSE 48280
// btype := b_armoury ;
48272: LD_ADDR_VAR 0 5
48276: PUSH
48277: LD_INT 4
48279: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48280: LD_VAR 0 5
48284: PUSH
48285: LD_INT 7
48287: PUSH
48288: LD_INT 8
48290: PUSH
48291: EMPTY
48292: LIST
48293: LIST
48294: IN
48295: IFFALSE 48305
// btype := b_lab ;
48297: LD_ADDR_VAR 0 5
48301: PUSH
48302: LD_INT 6
48304: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48305: LD_ADDR_EXP 81
48309: PUSH
48310: LD_EXP 81
48314: PPUSH
48315: LD_VAR 0 3
48319: PUSH
48320: LD_EXP 81
48324: PUSH
48325: LD_VAR 0 3
48329: ARRAY
48330: PUSH
48331: LD_INT 1
48333: PLUS
48334: PUSH
48335: EMPTY
48336: LIST
48337: LIST
48338: PPUSH
48339: LD_VAR 0 5
48343: PUSH
48344: LD_VAR 0 1
48348: PPUSH
48349: CALL_OW 250
48353: PUSH
48354: LD_VAR 0 1
48358: PPUSH
48359: CALL_OW 251
48363: PUSH
48364: LD_VAR 0 1
48368: PPUSH
48369: CALL_OW 254
48373: PUSH
48374: EMPTY
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: PPUSH
48380: CALL 57636 0 3
48384: ST_TO_ADDR
// if pos = 1 then
48385: LD_VAR 0 6
48389: PUSH
48390: LD_INT 1
48392: EQUAL
48393: IFFALSE 48508
// begin tmp := mc_build_list [ i ] ;
48395: LD_ADDR_VAR 0 7
48399: PUSH
48400: LD_EXP 81
48404: PUSH
48405: LD_VAR 0 3
48409: ARRAY
48410: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48411: LD_VAR 0 7
48415: PPUSH
48416: LD_INT 2
48418: PUSH
48419: LD_INT 30
48421: PUSH
48422: LD_INT 0
48424: PUSH
48425: EMPTY
48426: LIST
48427: LIST
48428: PUSH
48429: LD_INT 30
48431: PUSH
48432: LD_INT 1
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: PUSH
48439: EMPTY
48440: LIST
48441: LIST
48442: LIST
48443: PPUSH
48444: CALL_OW 72
48448: IFFALSE 48458
// pos := 2 ;
48450: LD_ADDR_VAR 0 6
48454: PUSH
48455: LD_INT 2
48457: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48458: LD_ADDR_VAR 0 7
48462: PUSH
48463: LD_VAR 0 7
48467: PPUSH
48468: LD_VAR 0 6
48472: PPUSH
48473: LD_VAR 0 7
48477: PPUSH
48478: CALL 57962 0 3
48482: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48483: LD_ADDR_EXP 81
48487: PUSH
48488: LD_EXP 81
48492: PPUSH
48493: LD_VAR 0 3
48497: PPUSH
48498: LD_VAR 0 7
48502: PPUSH
48503: CALL_OW 1
48507: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48508: LD_VAR 0 1
48512: PUSH
48513: LD_EXP 76
48517: PUSH
48518: LD_VAR 0 3
48522: ARRAY
48523: IN
48524: IFFALSE 48563
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48526: LD_ADDR_EXP 76
48530: PUSH
48531: LD_EXP 76
48535: PPUSH
48536: LD_VAR 0 3
48540: PPUSH
48541: LD_EXP 76
48545: PUSH
48546: LD_VAR 0 3
48550: ARRAY
48551: PUSH
48552: LD_VAR 0 1
48556: DIFF
48557: PPUSH
48558: CALL_OW 1
48562: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48563: LD_VAR 0 1
48567: PUSH
48568: LD_EXP 83
48572: PUSH
48573: LD_VAR 0 3
48577: ARRAY
48578: IN
48579: IFFALSE 48618
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48581: LD_ADDR_EXP 83
48585: PUSH
48586: LD_EXP 83
48590: PPUSH
48591: LD_VAR 0 3
48595: PPUSH
48596: LD_EXP 83
48600: PUSH
48601: LD_VAR 0 3
48605: ARRAY
48606: PUSH
48607: LD_VAR 0 1
48611: DIFF
48612: PPUSH
48613: CALL_OW 1
48617: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48618: LD_VAR 0 1
48622: PUSH
48623: LD_EXP 95
48627: PUSH
48628: LD_VAR 0 3
48632: ARRAY
48633: IN
48634: IFFALSE 48673
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48636: LD_ADDR_EXP 95
48640: PUSH
48641: LD_EXP 95
48645: PPUSH
48646: LD_VAR 0 3
48650: PPUSH
48651: LD_EXP 95
48655: PUSH
48656: LD_VAR 0 3
48660: ARRAY
48661: PUSH
48662: LD_VAR 0 1
48666: DIFF
48667: PPUSH
48668: CALL_OW 1
48672: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48673: LD_VAR 0 1
48677: PUSH
48678: LD_EXP 98
48682: PUSH
48683: LD_VAR 0 3
48687: ARRAY
48688: IN
48689: IFFALSE 48728
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48691: LD_ADDR_EXP 98
48695: PUSH
48696: LD_EXP 98
48700: PPUSH
48701: LD_VAR 0 3
48705: PPUSH
48706: LD_EXP 98
48710: PUSH
48711: LD_VAR 0 3
48715: ARRAY
48716: PUSH
48717: LD_VAR 0 1
48721: DIFF
48722: PPUSH
48723: CALL_OW 1
48727: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48728: LD_VAR 0 1
48732: PUSH
48733: LD_EXP 85
48737: PUSH
48738: LD_VAR 0 3
48742: ARRAY
48743: IN
48744: IFFALSE 48783
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48746: LD_ADDR_EXP 85
48750: PUSH
48751: LD_EXP 85
48755: PPUSH
48756: LD_VAR 0 3
48760: PPUSH
48761: LD_EXP 85
48765: PUSH
48766: LD_VAR 0 3
48770: ARRAY
48771: PUSH
48772: LD_VAR 0 1
48776: DIFF
48777: PPUSH
48778: CALL_OW 1
48782: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48783: LD_VAR 0 1
48787: PUSH
48788: LD_EXP 84
48792: PUSH
48793: LD_VAR 0 3
48797: ARRAY
48798: IN
48799: IFFALSE 48838
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48801: LD_ADDR_EXP 84
48805: PUSH
48806: LD_EXP 84
48810: PPUSH
48811: LD_VAR 0 3
48815: PPUSH
48816: LD_EXP 84
48820: PUSH
48821: LD_VAR 0 3
48825: ARRAY
48826: PUSH
48827: LD_VAR 0 1
48831: DIFF
48832: PPUSH
48833: CALL_OW 1
48837: ST_TO_ADDR
// end ; break ;
48838: GO 48842
// end ;
48840: GO 47488
48842: POP
48843: POP
// end ;
48844: LD_VAR 0 2
48848: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48849: LD_INT 0
48851: PPUSH
48852: PPUSH
48853: PPUSH
// if not mc_bases or not skirmish then
48854: LD_EXP 76
48858: NOT
48859: PUSH
48860: LD_EXP 74
48864: NOT
48865: OR
48866: IFFALSE 48870
// exit ;
48868: GO 49085
// for i = 1 to mc_bases do
48870: LD_ADDR_VAR 0 3
48874: PUSH
48875: DOUBLE
48876: LD_INT 1
48878: DEC
48879: ST_TO_ADDR
48880: LD_EXP 76
48884: PUSH
48885: FOR_TO
48886: IFFALSE 49083
// begin if building in mc_construct_list [ i ] then
48888: LD_VAR 0 1
48892: PUSH
48893: LD_EXP 83
48897: PUSH
48898: LD_VAR 0 3
48902: ARRAY
48903: IN
48904: IFFALSE 49081
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48906: LD_ADDR_EXP 83
48910: PUSH
48911: LD_EXP 83
48915: PPUSH
48916: LD_VAR 0 3
48920: PPUSH
48921: LD_EXP 83
48925: PUSH
48926: LD_VAR 0 3
48930: ARRAY
48931: PUSH
48932: LD_VAR 0 1
48936: DIFF
48937: PPUSH
48938: CALL_OW 1
48942: ST_TO_ADDR
// if building in mc_lab [ i ] then
48943: LD_VAR 0 1
48947: PUSH
48948: LD_EXP 109
48952: PUSH
48953: LD_VAR 0 3
48957: ARRAY
48958: IN
48959: IFFALSE 49014
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48961: LD_ADDR_EXP 110
48965: PUSH
48966: LD_EXP 110
48970: PPUSH
48971: LD_VAR 0 3
48975: PPUSH
48976: LD_EXP 110
48980: PUSH
48981: LD_VAR 0 3
48985: ARRAY
48986: PPUSH
48987: LD_INT 1
48989: PPUSH
48990: LD_EXP 110
48994: PUSH
48995: LD_VAR 0 3
48999: ARRAY
49000: PPUSH
49001: LD_INT 0
49003: PPUSH
49004: CALL 57054 0 4
49008: PPUSH
49009: CALL_OW 1
49013: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49014: LD_VAR 0 1
49018: PUSH
49019: LD_EXP 76
49023: PUSH
49024: LD_VAR 0 3
49028: ARRAY
49029: IN
49030: NOT
49031: IFFALSE 49077
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49033: LD_ADDR_EXP 76
49037: PUSH
49038: LD_EXP 76
49042: PPUSH
49043: LD_VAR 0 3
49047: PUSH
49048: LD_EXP 76
49052: PUSH
49053: LD_VAR 0 3
49057: ARRAY
49058: PUSH
49059: LD_INT 1
49061: PLUS
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: PPUSH
49067: LD_VAR 0 1
49071: PPUSH
49072: CALL 57636 0 3
49076: ST_TO_ADDR
// exit ;
49077: POP
49078: POP
49079: GO 49085
// end ; end ;
49081: GO 48885
49083: POP
49084: POP
// end ;
49085: LD_VAR 0 2
49089: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49090: LD_INT 0
49092: PPUSH
49093: PPUSH
49094: PPUSH
49095: PPUSH
49096: PPUSH
49097: PPUSH
49098: PPUSH
// if not mc_bases or not skirmish then
49099: LD_EXP 76
49103: NOT
49104: PUSH
49105: LD_EXP 74
49109: NOT
49110: OR
49111: IFFALSE 49115
// exit ;
49113: GO 49776
// for i = 1 to mc_bases do
49115: LD_ADDR_VAR 0 3
49119: PUSH
49120: DOUBLE
49121: LD_INT 1
49123: DEC
49124: ST_TO_ADDR
49125: LD_EXP 76
49129: PUSH
49130: FOR_TO
49131: IFFALSE 49774
// begin if building in mc_construct_list [ i ] then
49133: LD_VAR 0 1
49137: PUSH
49138: LD_EXP 83
49142: PUSH
49143: LD_VAR 0 3
49147: ARRAY
49148: IN
49149: IFFALSE 49772
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49151: LD_ADDR_EXP 83
49155: PUSH
49156: LD_EXP 83
49160: PPUSH
49161: LD_VAR 0 3
49165: PPUSH
49166: LD_EXP 83
49170: PUSH
49171: LD_VAR 0 3
49175: ARRAY
49176: PUSH
49177: LD_VAR 0 1
49181: DIFF
49182: PPUSH
49183: CALL_OW 1
49187: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49188: LD_ADDR_EXP 76
49192: PUSH
49193: LD_EXP 76
49197: PPUSH
49198: LD_VAR 0 3
49202: PUSH
49203: LD_EXP 76
49207: PUSH
49208: LD_VAR 0 3
49212: ARRAY
49213: PUSH
49214: LD_INT 1
49216: PLUS
49217: PUSH
49218: EMPTY
49219: LIST
49220: LIST
49221: PPUSH
49222: LD_VAR 0 1
49226: PPUSH
49227: CALL 57636 0 3
49231: ST_TO_ADDR
// btype := GetBType ( building ) ;
49232: LD_ADDR_VAR 0 5
49236: PUSH
49237: LD_VAR 0 1
49241: PPUSH
49242: CALL_OW 266
49246: ST_TO_ADDR
// side := GetSide ( building ) ;
49247: LD_ADDR_VAR 0 8
49251: PUSH
49252: LD_VAR 0 1
49256: PPUSH
49257: CALL_OW 255
49261: ST_TO_ADDR
// if btype = b_lab then
49262: LD_VAR 0 5
49266: PUSH
49267: LD_INT 6
49269: EQUAL
49270: IFFALSE 49320
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49272: LD_ADDR_EXP 109
49276: PUSH
49277: LD_EXP 109
49281: PPUSH
49282: LD_VAR 0 3
49286: PUSH
49287: LD_EXP 109
49291: PUSH
49292: LD_VAR 0 3
49296: ARRAY
49297: PUSH
49298: LD_INT 1
49300: PLUS
49301: PUSH
49302: EMPTY
49303: LIST
49304: LIST
49305: PPUSH
49306: LD_VAR 0 1
49310: PPUSH
49311: CALL 57636 0 3
49315: ST_TO_ADDR
// exit ;
49316: POP
49317: POP
49318: GO 49776
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49320: LD_VAR 0 5
49324: PUSH
49325: LD_INT 0
49327: PUSH
49328: LD_INT 2
49330: PUSH
49331: LD_INT 4
49333: PUSH
49334: EMPTY
49335: LIST
49336: LIST
49337: LIST
49338: IN
49339: IFFALSE 49463
// begin if btype = b_armoury then
49341: LD_VAR 0 5
49345: PUSH
49346: LD_INT 4
49348: EQUAL
49349: IFFALSE 49359
// btype := b_barracks ;
49351: LD_ADDR_VAR 0 5
49355: PUSH
49356: LD_INT 5
49358: ST_TO_ADDR
// if btype = b_depot then
49359: LD_VAR 0 5
49363: PUSH
49364: LD_INT 0
49366: EQUAL
49367: IFFALSE 49377
// btype := b_warehouse ;
49369: LD_ADDR_VAR 0 5
49373: PUSH
49374: LD_INT 1
49376: ST_TO_ADDR
// if btype = b_workshop then
49377: LD_VAR 0 5
49381: PUSH
49382: LD_INT 2
49384: EQUAL
49385: IFFALSE 49395
// btype := b_factory ;
49387: LD_ADDR_VAR 0 5
49391: PUSH
49392: LD_INT 3
49394: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49395: LD_VAR 0 5
49399: PPUSH
49400: LD_VAR 0 8
49404: PPUSH
49405: CALL_OW 323
49409: PUSH
49410: LD_INT 1
49412: EQUAL
49413: IFFALSE 49459
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49415: LD_ADDR_EXP 108
49419: PUSH
49420: LD_EXP 108
49424: PPUSH
49425: LD_VAR 0 3
49429: PUSH
49430: LD_EXP 108
49434: PUSH
49435: LD_VAR 0 3
49439: ARRAY
49440: PUSH
49441: LD_INT 1
49443: PLUS
49444: PUSH
49445: EMPTY
49446: LIST
49447: LIST
49448: PPUSH
49449: LD_VAR 0 1
49453: PPUSH
49454: CALL 57636 0 3
49458: ST_TO_ADDR
// exit ;
49459: POP
49460: POP
49461: GO 49776
// end ; if btype in [ b_bunker , b_turret ] then
49463: LD_VAR 0 5
49467: PUSH
49468: LD_INT 32
49470: PUSH
49471: LD_INT 33
49473: PUSH
49474: EMPTY
49475: LIST
49476: LIST
49477: IN
49478: IFFALSE 49768
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49480: LD_ADDR_EXP 84
49484: PUSH
49485: LD_EXP 84
49489: PPUSH
49490: LD_VAR 0 3
49494: PUSH
49495: LD_EXP 84
49499: PUSH
49500: LD_VAR 0 3
49504: ARRAY
49505: PUSH
49506: LD_INT 1
49508: PLUS
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PPUSH
49514: LD_VAR 0 1
49518: PPUSH
49519: CALL 57636 0 3
49523: ST_TO_ADDR
// if btype = b_bunker then
49524: LD_VAR 0 5
49528: PUSH
49529: LD_INT 32
49531: EQUAL
49532: IFFALSE 49768
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49534: LD_ADDR_EXP 85
49538: PUSH
49539: LD_EXP 85
49543: PPUSH
49544: LD_VAR 0 3
49548: PUSH
49549: LD_EXP 85
49553: PUSH
49554: LD_VAR 0 3
49558: ARRAY
49559: PUSH
49560: LD_INT 1
49562: PLUS
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PPUSH
49568: LD_VAR 0 1
49572: PPUSH
49573: CALL 57636 0 3
49577: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49578: LD_ADDR_VAR 0 6
49582: PUSH
49583: LD_EXP 76
49587: PUSH
49588: LD_VAR 0 3
49592: ARRAY
49593: PPUSH
49594: LD_INT 25
49596: PUSH
49597: LD_INT 1
49599: PUSH
49600: EMPTY
49601: LIST
49602: LIST
49603: PUSH
49604: LD_INT 3
49606: PUSH
49607: LD_INT 54
49609: PUSH
49610: EMPTY
49611: LIST
49612: PUSH
49613: EMPTY
49614: LIST
49615: LIST
49616: PUSH
49617: EMPTY
49618: LIST
49619: LIST
49620: PPUSH
49621: CALL_OW 72
49625: ST_TO_ADDR
// if tmp then
49626: LD_VAR 0 6
49630: IFFALSE 49636
// exit ;
49632: POP
49633: POP
49634: GO 49776
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49636: LD_ADDR_VAR 0 6
49640: PUSH
49641: LD_EXP 76
49645: PUSH
49646: LD_VAR 0 3
49650: ARRAY
49651: PPUSH
49652: LD_INT 2
49654: PUSH
49655: LD_INT 30
49657: PUSH
49658: LD_INT 4
49660: PUSH
49661: EMPTY
49662: LIST
49663: LIST
49664: PUSH
49665: LD_INT 30
49667: PUSH
49668: LD_INT 5
49670: PUSH
49671: EMPTY
49672: LIST
49673: LIST
49674: PUSH
49675: EMPTY
49676: LIST
49677: LIST
49678: LIST
49679: PPUSH
49680: CALL_OW 72
49684: ST_TO_ADDR
// if not tmp then
49685: LD_VAR 0 6
49689: NOT
49690: IFFALSE 49696
// exit ;
49692: POP
49693: POP
49694: GO 49776
// for j in tmp do
49696: LD_ADDR_VAR 0 4
49700: PUSH
49701: LD_VAR 0 6
49705: PUSH
49706: FOR_IN
49707: IFFALSE 49766
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49709: LD_ADDR_VAR 0 7
49713: PUSH
49714: LD_VAR 0 4
49718: PPUSH
49719: CALL_OW 313
49723: PPUSH
49724: LD_INT 25
49726: PUSH
49727: LD_INT 1
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: PPUSH
49734: CALL_OW 72
49738: ST_TO_ADDR
// if units then
49739: LD_VAR 0 7
49743: IFFALSE 49764
// begin ComExitBuilding ( units [ 1 ] ) ;
49745: LD_VAR 0 7
49749: PUSH
49750: LD_INT 1
49752: ARRAY
49753: PPUSH
49754: CALL_OW 122
// exit ;
49758: POP
49759: POP
49760: POP
49761: POP
49762: GO 49776
// end ; end ;
49764: GO 49706
49766: POP
49767: POP
// end ; end ; exit ;
49768: POP
49769: POP
49770: GO 49776
// end ; end ;
49772: GO 49130
49774: POP
49775: POP
// end ;
49776: LD_VAR 0 2
49780: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49781: LD_INT 0
49783: PPUSH
49784: PPUSH
49785: PPUSH
49786: PPUSH
49787: PPUSH
49788: PPUSH
49789: PPUSH
// if not mc_bases or not skirmish then
49790: LD_EXP 76
49794: NOT
49795: PUSH
49796: LD_EXP 74
49800: NOT
49801: OR
49802: IFFALSE 49806
// exit ;
49804: GO 50037
// btype := GetBType ( building ) ;
49806: LD_ADDR_VAR 0 6
49810: PUSH
49811: LD_VAR 0 1
49815: PPUSH
49816: CALL_OW 266
49820: ST_TO_ADDR
// x := GetX ( building ) ;
49821: LD_ADDR_VAR 0 7
49825: PUSH
49826: LD_VAR 0 1
49830: PPUSH
49831: CALL_OW 250
49835: ST_TO_ADDR
// y := GetY ( building ) ;
49836: LD_ADDR_VAR 0 8
49840: PUSH
49841: LD_VAR 0 1
49845: PPUSH
49846: CALL_OW 251
49850: ST_TO_ADDR
// d := GetDir ( building ) ;
49851: LD_ADDR_VAR 0 9
49855: PUSH
49856: LD_VAR 0 1
49860: PPUSH
49861: CALL_OW 254
49865: ST_TO_ADDR
// for i = 1 to mc_bases do
49866: LD_ADDR_VAR 0 4
49870: PUSH
49871: DOUBLE
49872: LD_INT 1
49874: DEC
49875: ST_TO_ADDR
49876: LD_EXP 76
49880: PUSH
49881: FOR_TO
49882: IFFALSE 50035
// begin if not mc_build_list [ i ] then
49884: LD_EXP 81
49888: PUSH
49889: LD_VAR 0 4
49893: ARRAY
49894: NOT
49895: IFFALSE 49899
// continue ;
49897: GO 49881
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49899: LD_VAR 0 6
49903: PUSH
49904: LD_VAR 0 7
49908: PUSH
49909: LD_VAR 0 8
49913: PUSH
49914: LD_VAR 0 9
49918: PUSH
49919: EMPTY
49920: LIST
49921: LIST
49922: LIST
49923: LIST
49924: PPUSH
49925: LD_EXP 81
49929: PUSH
49930: LD_VAR 0 4
49934: ARRAY
49935: PUSH
49936: LD_INT 1
49938: ARRAY
49939: PPUSH
49940: CALL 63805 0 2
49944: IFFALSE 50033
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49946: LD_ADDR_EXP 81
49950: PUSH
49951: LD_EXP 81
49955: PPUSH
49956: LD_VAR 0 4
49960: PPUSH
49961: LD_EXP 81
49965: PUSH
49966: LD_VAR 0 4
49970: ARRAY
49971: PPUSH
49972: LD_INT 1
49974: PPUSH
49975: CALL_OW 3
49979: PPUSH
49980: CALL_OW 1
49984: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49985: LD_ADDR_EXP 83
49989: PUSH
49990: LD_EXP 83
49994: PPUSH
49995: LD_VAR 0 4
49999: PUSH
50000: LD_EXP 83
50004: PUSH
50005: LD_VAR 0 4
50009: ARRAY
50010: PUSH
50011: LD_INT 1
50013: PLUS
50014: PUSH
50015: EMPTY
50016: LIST
50017: LIST
50018: PPUSH
50019: LD_VAR 0 1
50023: PPUSH
50024: CALL 57636 0 3
50028: ST_TO_ADDR
// exit ;
50029: POP
50030: POP
50031: GO 50037
// end ; end ;
50033: GO 49881
50035: POP
50036: POP
// end ;
50037: LD_VAR 0 3
50041: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50042: LD_INT 0
50044: PPUSH
50045: PPUSH
50046: PPUSH
// if not mc_bases or not skirmish then
50047: LD_EXP 76
50051: NOT
50052: PUSH
50053: LD_EXP 74
50057: NOT
50058: OR
50059: IFFALSE 50063
// exit ;
50061: GO 50253
// for i = 1 to mc_bases do
50063: LD_ADDR_VAR 0 4
50067: PUSH
50068: DOUBLE
50069: LD_INT 1
50071: DEC
50072: ST_TO_ADDR
50073: LD_EXP 76
50077: PUSH
50078: FOR_TO
50079: IFFALSE 50166
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50081: LD_VAR 0 1
50085: PUSH
50086: LD_EXP 84
50090: PUSH
50091: LD_VAR 0 4
50095: ARRAY
50096: IN
50097: PUSH
50098: LD_VAR 0 1
50102: PUSH
50103: LD_EXP 85
50107: PUSH
50108: LD_VAR 0 4
50112: ARRAY
50113: IN
50114: NOT
50115: AND
50116: IFFALSE 50164
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50118: LD_ADDR_EXP 85
50122: PUSH
50123: LD_EXP 85
50127: PPUSH
50128: LD_VAR 0 4
50132: PUSH
50133: LD_EXP 85
50137: PUSH
50138: LD_VAR 0 4
50142: ARRAY
50143: PUSH
50144: LD_INT 1
50146: PLUS
50147: PUSH
50148: EMPTY
50149: LIST
50150: LIST
50151: PPUSH
50152: LD_VAR 0 1
50156: PPUSH
50157: CALL 57636 0 3
50161: ST_TO_ADDR
// break ;
50162: GO 50166
// end ; end ;
50164: GO 50078
50166: POP
50167: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50168: LD_VAR 0 1
50172: PPUSH
50173: CALL_OW 257
50177: PUSH
50178: LD_EXP 102
50182: IN
50183: PUSH
50184: LD_VAR 0 1
50188: PPUSH
50189: CALL_OW 266
50193: PUSH
50194: LD_INT 5
50196: EQUAL
50197: AND
50198: PUSH
50199: LD_VAR 0 2
50203: PPUSH
50204: CALL_OW 110
50208: PUSH
50209: LD_INT 18
50211: NONEQUAL
50212: AND
50213: IFFALSE 50253
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50215: LD_VAR 0 2
50219: PPUSH
50220: CALL_OW 257
50224: PUSH
50225: LD_INT 5
50227: PUSH
50228: LD_INT 8
50230: PUSH
50231: LD_INT 9
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: LIST
50238: IN
50239: IFFALSE 50253
// SetClass ( unit , 1 ) ;
50241: LD_VAR 0 2
50245: PPUSH
50246: LD_INT 1
50248: PPUSH
50249: CALL_OW 336
// end ;
50253: LD_VAR 0 3
50257: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50258: LD_INT 0
50260: PPUSH
50261: PPUSH
// if not mc_bases or not skirmish then
50262: LD_EXP 76
50266: NOT
50267: PUSH
50268: LD_EXP 74
50272: NOT
50273: OR
50274: IFFALSE 50278
// exit ;
50276: GO 50394
// if GetLives ( abandoned_vehicle ) > 250 then
50278: LD_VAR 0 2
50282: PPUSH
50283: CALL_OW 256
50287: PUSH
50288: LD_INT 250
50290: GREATER
50291: IFFALSE 50295
// exit ;
50293: GO 50394
// for i = 1 to mc_bases do
50295: LD_ADDR_VAR 0 6
50299: PUSH
50300: DOUBLE
50301: LD_INT 1
50303: DEC
50304: ST_TO_ADDR
50305: LD_EXP 76
50309: PUSH
50310: FOR_TO
50311: IFFALSE 50392
// begin if driver in mc_bases [ i ] then
50313: LD_VAR 0 1
50317: PUSH
50318: LD_EXP 76
50322: PUSH
50323: LD_VAR 0 6
50327: ARRAY
50328: IN
50329: IFFALSE 50390
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50331: LD_VAR 0 1
50335: PPUSH
50336: LD_EXP 76
50340: PUSH
50341: LD_VAR 0 6
50345: ARRAY
50346: PPUSH
50347: LD_INT 2
50349: PUSH
50350: LD_INT 30
50352: PUSH
50353: LD_INT 0
50355: PUSH
50356: EMPTY
50357: LIST
50358: LIST
50359: PUSH
50360: LD_INT 30
50362: PUSH
50363: LD_INT 1
50365: PUSH
50366: EMPTY
50367: LIST
50368: LIST
50369: PUSH
50370: EMPTY
50371: LIST
50372: LIST
50373: LIST
50374: PPUSH
50375: CALL_OW 72
50379: PUSH
50380: LD_INT 1
50382: ARRAY
50383: PPUSH
50384: CALL_OW 112
// break ;
50388: GO 50392
// end ; end ;
50390: GO 50310
50392: POP
50393: POP
// end ; end_of_file
50394: LD_VAR 0 5
50398: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50399: LD_INT 0
50401: PPUSH
50402: PPUSH
// if exist_mode then
50403: LD_VAR 0 2
50407: IFFALSE 50432
// unit := CreateCharacter ( prefix & ident ) else
50409: LD_ADDR_VAR 0 5
50413: PUSH
50414: LD_VAR 0 3
50418: PUSH
50419: LD_VAR 0 1
50423: STR
50424: PPUSH
50425: CALL_OW 34
50429: ST_TO_ADDR
50430: GO 50447
// unit := NewCharacter ( ident ) ;
50432: LD_ADDR_VAR 0 5
50436: PUSH
50437: LD_VAR 0 1
50441: PPUSH
50442: CALL_OW 25
50446: ST_TO_ADDR
// result := unit ;
50447: LD_ADDR_VAR 0 4
50451: PUSH
50452: LD_VAR 0 5
50456: ST_TO_ADDR
// end ;
50457: LD_VAR 0 4
50461: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50462: LD_INT 0
50464: PPUSH
50465: PPUSH
// if not side or not nation then
50466: LD_VAR 0 1
50470: NOT
50471: PUSH
50472: LD_VAR 0 2
50476: NOT
50477: OR
50478: IFFALSE 50482
// exit ;
50480: GO 51126
// case nation of nation_american :
50482: LD_VAR 0 2
50486: PUSH
50487: LD_INT 1
50489: DOUBLE
50490: EQUAL
50491: IFTRUE 50495
50493: GO 50669
50495: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50496: LD_ADDR_VAR 0 4
50500: PUSH
50501: LD_INT 35
50503: PUSH
50504: LD_INT 45
50506: PUSH
50507: LD_INT 46
50509: PUSH
50510: LD_INT 47
50512: PUSH
50513: LD_INT 1
50515: PUSH
50516: LD_INT 2
50518: PUSH
50519: LD_INT 6
50521: PUSH
50522: LD_INT 15
50524: PUSH
50525: LD_INT 16
50527: PUSH
50528: LD_INT 7
50530: PUSH
50531: LD_INT 12
50533: PUSH
50534: LD_INT 13
50536: PUSH
50537: LD_INT 10
50539: PUSH
50540: LD_INT 14
50542: PUSH
50543: LD_INT 20
50545: PUSH
50546: LD_INT 21
50548: PUSH
50549: LD_INT 22
50551: PUSH
50552: LD_INT 25
50554: PUSH
50555: LD_INT 32
50557: PUSH
50558: LD_INT 27
50560: PUSH
50561: LD_INT 36
50563: PUSH
50564: LD_INT 69
50566: PUSH
50567: LD_INT 39
50569: PUSH
50570: LD_INT 34
50572: PUSH
50573: LD_INT 40
50575: PUSH
50576: LD_INT 48
50578: PUSH
50579: LD_INT 49
50581: PUSH
50582: LD_INT 50
50584: PUSH
50585: LD_INT 51
50587: PUSH
50588: LD_INT 52
50590: PUSH
50591: LD_INT 53
50593: PUSH
50594: LD_INT 54
50596: PUSH
50597: LD_INT 55
50599: PUSH
50600: LD_INT 56
50602: PUSH
50603: LD_INT 57
50605: PUSH
50606: LD_INT 58
50608: PUSH
50609: LD_INT 59
50611: PUSH
50612: LD_INT 60
50614: PUSH
50615: LD_INT 61
50617: PUSH
50618: LD_INT 62
50620: PUSH
50621: LD_INT 80
50623: PUSH
50624: EMPTY
50625: LIST
50626: LIST
50627: LIST
50628: LIST
50629: LIST
50630: LIST
50631: LIST
50632: LIST
50633: LIST
50634: LIST
50635: LIST
50636: LIST
50637: LIST
50638: LIST
50639: LIST
50640: LIST
50641: LIST
50642: LIST
50643: LIST
50644: LIST
50645: LIST
50646: LIST
50647: LIST
50648: LIST
50649: LIST
50650: LIST
50651: LIST
50652: LIST
50653: LIST
50654: LIST
50655: LIST
50656: LIST
50657: LIST
50658: LIST
50659: LIST
50660: LIST
50661: LIST
50662: LIST
50663: LIST
50664: LIST
50665: LIST
50666: ST_TO_ADDR
50667: GO 51050
50669: LD_INT 2
50671: DOUBLE
50672: EQUAL
50673: IFTRUE 50677
50675: GO 50859
50677: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50678: LD_ADDR_VAR 0 4
50682: PUSH
50683: LD_INT 35
50685: PUSH
50686: LD_INT 45
50688: PUSH
50689: LD_INT 46
50691: PUSH
50692: LD_INT 47
50694: PUSH
50695: LD_INT 70
50697: PUSH
50698: LD_INT 1
50700: PUSH
50701: LD_INT 11
50703: PUSH
50704: LD_INT 3
50706: PUSH
50707: LD_INT 4
50709: PUSH
50710: LD_INT 5
50712: PUSH
50713: LD_INT 6
50715: PUSH
50716: LD_INT 15
50718: PUSH
50719: LD_INT 18
50721: PUSH
50722: LD_INT 7
50724: PUSH
50725: LD_INT 17
50727: PUSH
50728: LD_INT 8
50730: PUSH
50731: LD_INT 20
50733: PUSH
50734: LD_INT 21
50736: PUSH
50737: LD_INT 22
50739: PUSH
50740: LD_INT 72
50742: PUSH
50743: LD_INT 26
50745: PUSH
50746: LD_INT 69
50748: PUSH
50749: LD_INT 39
50751: PUSH
50752: LD_INT 40
50754: PUSH
50755: LD_INT 41
50757: PUSH
50758: LD_INT 42
50760: PUSH
50761: LD_INT 43
50763: PUSH
50764: LD_INT 48
50766: PUSH
50767: LD_INT 49
50769: PUSH
50770: LD_INT 50
50772: PUSH
50773: LD_INT 51
50775: PUSH
50776: LD_INT 52
50778: PUSH
50779: LD_INT 53
50781: PUSH
50782: LD_INT 54
50784: PUSH
50785: LD_INT 55
50787: PUSH
50788: LD_INT 56
50790: PUSH
50791: LD_INT 60
50793: PUSH
50794: LD_INT 61
50796: PUSH
50797: LD_INT 62
50799: PUSH
50800: LD_INT 66
50802: PUSH
50803: LD_INT 67
50805: PUSH
50806: LD_INT 68
50808: PUSH
50809: LD_INT 81
50811: PUSH
50812: EMPTY
50813: LIST
50814: LIST
50815: LIST
50816: LIST
50817: LIST
50818: LIST
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: LIST
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: LIST
50840: LIST
50841: LIST
50842: LIST
50843: LIST
50844: LIST
50845: LIST
50846: LIST
50847: LIST
50848: LIST
50849: LIST
50850: LIST
50851: LIST
50852: LIST
50853: LIST
50854: LIST
50855: LIST
50856: ST_TO_ADDR
50857: GO 51050
50859: LD_INT 3
50861: DOUBLE
50862: EQUAL
50863: IFTRUE 50867
50865: GO 51049
50867: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50868: LD_ADDR_VAR 0 4
50872: PUSH
50873: LD_INT 46
50875: PUSH
50876: LD_INT 47
50878: PUSH
50879: LD_INT 1
50881: PUSH
50882: LD_INT 2
50884: PUSH
50885: LD_INT 11
50887: PUSH
50888: LD_INT 9
50890: PUSH
50891: LD_INT 20
50893: PUSH
50894: LD_INT 19
50896: PUSH
50897: LD_INT 21
50899: PUSH
50900: LD_INT 24
50902: PUSH
50903: LD_INT 22
50905: PUSH
50906: LD_INT 25
50908: PUSH
50909: LD_INT 28
50911: PUSH
50912: LD_INT 29
50914: PUSH
50915: LD_INT 30
50917: PUSH
50918: LD_INT 31
50920: PUSH
50921: LD_INT 37
50923: PUSH
50924: LD_INT 38
50926: PUSH
50927: LD_INT 32
50929: PUSH
50930: LD_INT 27
50932: PUSH
50933: LD_INT 33
50935: PUSH
50936: LD_INT 69
50938: PUSH
50939: LD_INT 39
50941: PUSH
50942: LD_INT 34
50944: PUSH
50945: LD_INT 40
50947: PUSH
50948: LD_INT 71
50950: PUSH
50951: LD_INT 23
50953: PUSH
50954: LD_INT 44
50956: PUSH
50957: LD_INT 48
50959: PUSH
50960: LD_INT 49
50962: PUSH
50963: LD_INT 50
50965: PUSH
50966: LD_INT 51
50968: PUSH
50969: LD_INT 52
50971: PUSH
50972: LD_INT 53
50974: PUSH
50975: LD_INT 54
50977: PUSH
50978: LD_INT 55
50980: PUSH
50981: LD_INT 56
50983: PUSH
50984: LD_INT 57
50986: PUSH
50987: LD_INT 58
50989: PUSH
50990: LD_INT 59
50992: PUSH
50993: LD_INT 63
50995: PUSH
50996: LD_INT 64
50998: PUSH
50999: LD_INT 65
51001: PUSH
51002: EMPTY
51003: LIST
51004: LIST
51005: LIST
51006: LIST
51007: LIST
51008: LIST
51009: LIST
51010: LIST
51011: LIST
51012: LIST
51013: LIST
51014: LIST
51015: LIST
51016: LIST
51017: LIST
51018: LIST
51019: LIST
51020: LIST
51021: LIST
51022: LIST
51023: LIST
51024: LIST
51025: LIST
51026: LIST
51027: LIST
51028: LIST
51029: LIST
51030: LIST
51031: LIST
51032: LIST
51033: LIST
51034: LIST
51035: LIST
51036: LIST
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: LIST
51042: LIST
51043: LIST
51044: LIST
51045: LIST
51046: ST_TO_ADDR
51047: GO 51050
51049: POP
// if state > - 1 and state < 3 then
51050: LD_VAR 0 3
51054: PUSH
51055: LD_INT 1
51057: NEG
51058: GREATER
51059: PUSH
51060: LD_VAR 0 3
51064: PUSH
51065: LD_INT 3
51067: LESS
51068: AND
51069: IFFALSE 51126
// for i in result do
51071: LD_ADDR_VAR 0 5
51075: PUSH
51076: LD_VAR 0 4
51080: PUSH
51081: FOR_IN
51082: IFFALSE 51124
// if GetTech ( i , side ) <> state then
51084: LD_VAR 0 5
51088: PPUSH
51089: LD_VAR 0 1
51093: PPUSH
51094: CALL_OW 321
51098: PUSH
51099: LD_VAR 0 3
51103: NONEQUAL
51104: IFFALSE 51122
// result := result diff i ;
51106: LD_ADDR_VAR 0 4
51110: PUSH
51111: LD_VAR 0 4
51115: PUSH
51116: LD_VAR 0 5
51120: DIFF
51121: ST_TO_ADDR
51122: GO 51081
51124: POP
51125: POP
// end ;
51126: LD_VAR 0 4
51130: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51131: LD_INT 0
51133: PPUSH
51134: PPUSH
51135: PPUSH
// result := true ;
51136: LD_ADDR_VAR 0 3
51140: PUSH
51141: LD_INT 1
51143: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51144: LD_ADDR_VAR 0 5
51148: PUSH
51149: LD_VAR 0 2
51153: PPUSH
51154: CALL_OW 480
51158: ST_TO_ADDR
// if not tmp then
51159: LD_VAR 0 5
51163: NOT
51164: IFFALSE 51168
// exit ;
51166: GO 51217
// for i in tmp do
51168: LD_ADDR_VAR 0 4
51172: PUSH
51173: LD_VAR 0 5
51177: PUSH
51178: FOR_IN
51179: IFFALSE 51215
// if GetTech ( i , side ) <> state_researched then
51181: LD_VAR 0 4
51185: PPUSH
51186: LD_VAR 0 1
51190: PPUSH
51191: CALL_OW 321
51195: PUSH
51196: LD_INT 2
51198: NONEQUAL
51199: IFFALSE 51213
// begin result := false ;
51201: LD_ADDR_VAR 0 3
51205: PUSH
51206: LD_INT 0
51208: ST_TO_ADDR
// exit ;
51209: POP
51210: POP
51211: GO 51217
// end ;
51213: GO 51178
51215: POP
51216: POP
// end ;
51217: LD_VAR 0 3
51221: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51222: LD_INT 0
51224: PPUSH
51225: PPUSH
51226: PPUSH
51227: PPUSH
51228: PPUSH
51229: PPUSH
51230: PPUSH
51231: PPUSH
51232: PPUSH
51233: PPUSH
51234: PPUSH
51235: PPUSH
51236: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51237: LD_VAR 0 1
51241: NOT
51242: PUSH
51243: LD_VAR 0 1
51247: PPUSH
51248: CALL_OW 257
51252: PUSH
51253: LD_INT 9
51255: NONEQUAL
51256: OR
51257: IFFALSE 51261
// exit ;
51259: GO 51834
// side := GetSide ( unit ) ;
51261: LD_ADDR_VAR 0 9
51265: PUSH
51266: LD_VAR 0 1
51270: PPUSH
51271: CALL_OW 255
51275: ST_TO_ADDR
// tech_space := tech_spacanom ;
51276: LD_ADDR_VAR 0 12
51280: PUSH
51281: LD_INT 29
51283: ST_TO_ADDR
// tech_time := tech_taurad ;
51284: LD_ADDR_VAR 0 13
51288: PUSH
51289: LD_INT 28
51291: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51292: LD_ADDR_VAR 0 11
51296: PUSH
51297: LD_VAR 0 1
51301: PPUSH
51302: CALL_OW 310
51306: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51307: LD_VAR 0 11
51311: PPUSH
51312: CALL_OW 247
51316: PUSH
51317: LD_INT 2
51319: EQUAL
51320: IFFALSE 51324
// exit ;
51322: GO 51834
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51324: LD_ADDR_VAR 0 8
51328: PUSH
51329: LD_INT 81
51331: PUSH
51332: LD_VAR 0 9
51336: PUSH
51337: EMPTY
51338: LIST
51339: LIST
51340: PUSH
51341: LD_INT 3
51343: PUSH
51344: LD_INT 21
51346: PUSH
51347: LD_INT 3
51349: PUSH
51350: EMPTY
51351: LIST
51352: LIST
51353: PUSH
51354: EMPTY
51355: LIST
51356: LIST
51357: PUSH
51358: EMPTY
51359: LIST
51360: LIST
51361: PPUSH
51362: CALL_OW 69
51366: ST_TO_ADDR
// if not tmp then
51367: LD_VAR 0 8
51371: NOT
51372: IFFALSE 51376
// exit ;
51374: GO 51834
// if in_unit then
51376: LD_VAR 0 11
51380: IFFALSE 51404
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51382: LD_ADDR_VAR 0 10
51386: PUSH
51387: LD_VAR 0 8
51391: PPUSH
51392: LD_VAR 0 11
51396: PPUSH
51397: CALL_OW 74
51401: ST_TO_ADDR
51402: GO 51424
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51404: LD_ADDR_VAR 0 10
51408: PUSH
51409: LD_VAR 0 8
51413: PPUSH
51414: LD_VAR 0 1
51418: PPUSH
51419: CALL_OW 74
51423: ST_TO_ADDR
// if not enemy then
51424: LD_VAR 0 10
51428: NOT
51429: IFFALSE 51433
// exit ;
51431: GO 51834
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51433: LD_VAR 0 11
51437: PUSH
51438: LD_VAR 0 11
51442: PPUSH
51443: LD_VAR 0 10
51447: PPUSH
51448: CALL_OW 296
51452: PUSH
51453: LD_INT 13
51455: GREATER
51456: AND
51457: PUSH
51458: LD_VAR 0 1
51462: PPUSH
51463: LD_VAR 0 10
51467: PPUSH
51468: CALL_OW 296
51472: PUSH
51473: LD_INT 12
51475: GREATER
51476: OR
51477: IFFALSE 51481
// exit ;
51479: GO 51834
// missile := [ 1 ] ;
51481: LD_ADDR_VAR 0 14
51485: PUSH
51486: LD_INT 1
51488: PUSH
51489: EMPTY
51490: LIST
51491: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51492: LD_VAR 0 9
51496: PPUSH
51497: LD_VAR 0 12
51501: PPUSH
51502: CALL_OW 325
51506: IFFALSE 51535
// missile := Insert ( missile , missile + 1 , 2 ) ;
51508: LD_ADDR_VAR 0 14
51512: PUSH
51513: LD_VAR 0 14
51517: PPUSH
51518: LD_VAR 0 14
51522: PUSH
51523: LD_INT 1
51525: PLUS
51526: PPUSH
51527: LD_INT 2
51529: PPUSH
51530: CALL_OW 2
51534: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51535: LD_VAR 0 9
51539: PPUSH
51540: LD_VAR 0 13
51544: PPUSH
51545: CALL_OW 325
51549: PUSH
51550: LD_VAR 0 10
51554: PPUSH
51555: CALL_OW 255
51559: PPUSH
51560: LD_VAR 0 13
51564: PPUSH
51565: CALL_OW 325
51569: NOT
51570: AND
51571: IFFALSE 51600
// missile := Insert ( missile , missile + 1 , 3 ) ;
51573: LD_ADDR_VAR 0 14
51577: PUSH
51578: LD_VAR 0 14
51582: PPUSH
51583: LD_VAR 0 14
51587: PUSH
51588: LD_INT 1
51590: PLUS
51591: PPUSH
51592: LD_INT 3
51594: PPUSH
51595: CALL_OW 2
51599: ST_TO_ADDR
// if missile < 2 then
51600: LD_VAR 0 14
51604: PUSH
51605: LD_INT 2
51607: LESS
51608: IFFALSE 51612
// exit ;
51610: GO 51834
// x := GetX ( enemy ) ;
51612: LD_ADDR_VAR 0 4
51616: PUSH
51617: LD_VAR 0 10
51621: PPUSH
51622: CALL_OW 250
51626: ST_TO_ADDR
// y := GetY ( enemy ) ;
51627: LD_ADDR_VAR 0 5
51631: PUSH
51632: LD_VAR 0 10
51636: PPUSH
51637: CALL_OW 251
51641: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51642: LD_ADDR_VAR 0 6
51646: PUSH
51647: LD_VAR 0 4
51651: PUSH
51652: LD_INT 1
51654: NEG
51655: PPUSH
51656: LD_INT 1
51658: PPUSH
51659: CALL_OW 12
51663: PLUS
51664: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51665: LD_ADDR_VAR 0 7
51669: PUSH
51670: LD_VAR 0 5
51674: PUSH
51675: LD_INT 1
51677: NEG
51678: PPUSH
51679: LD_INT 1
51681: PPUSH
51682: CALL_OW 12
51686: PLUS
51687: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51688: LD_VAR 0 6
51692: PPUSH
51693: LD_VAR 0 7
51697: PPUSH
51698: CALL_OW 488
51702: NOT
51703: IFFALSE 51725
// begin _x := x ;
51705: LD_ADDR_VAR 0 6
51709: PUSH
51710: LD_VAR 0 4
51714: ST_TO_ADDR
// _y := y ;
51715: LD_ADDR_VAR 0 7
51719: PUSH
51720: LD_VAR 0 5
51724: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51725: LD_ADDR_VAR 0 3
51729: PUSH
51730: LD_INT 1
51732: PPUSH
51733: LD_VAR 0 14
51737: PPUSH
51738: CALL_OW 12
51742: ST_TO_ADDR
// case i of 1 :
51743: LD_VAR 0 3
51747: PUSH
51748: LD_INT 1
51750: DOUBLE
51751: EQUAL
51752: IFTRUE 51756
51754: GO 51773
51756: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51757: LD_VAR 0 1
51761: PPUSH
51762: LD_VAR 0 10
51766: PPUSH
51767: CALL_OW 115
51771: GO 51834
51773: LD_INT 2
51775: DOUBLE
51776: EQUAL
51777: IFTRUE 51781
51779: GO 51803
51781: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51782: LD_VAR 0 1
51786: PPUSH
51787: LD_VAR 0 6
51791: PPUSH
51792: LD_VAR 0 7
51796: PPUSH
51797: CALL_OW 153
51801: GO 51834
51803: LD_INT 3
51805: DOUBLE
51806: EQUAL
51807: IFTRUE 51811
51809: GO 51833
51811: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51812: LD_VAR 0 1
51816: PPUSH
51817: LD_VAR 0 6
51821: PPUSH
51822: LD_VAR 0 7
51826: PPUSH
51827: CALL_OW 154
51831: GO 51834
51833: POP
// end ;
51834: LD_VAR 0 2
51838: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51839: LD_INT 0
51841: PPUSH
51842: PPUSH
51843: PPUSH
51844: PPUSH
51845: PPUSH
51846: PPUSH
// if not unit or not building then
51847: LD_VAR 0 1
51851: NOT
51852: PUSH
51853: LD_VAR 0 2
51857: NOT
51858: OR
51859: IFFALSE 51863
// exit ;
51861: GO 52021
// x := GetX ( building ) ;
51863: LD_ADDR_VAR 0 5
51867: PUSH
51868: LD_VAR 0 2
51872: PPUSH
51873: CALL_OW 250
51877: ST_TO_ADDR
// y := GetY ( building ) ;
51878: LD_ADDR_VAR 0 6
51882: PUSH
51883: LD_VAR 0 2
51887: PPUSH
51888: CALL_OW 251
51892: ST_TO_ADDR
// for i = 0 to 5 do
51893: LD_ADDR_VAR 0 4
51897: PUSH
51898: DOUBLE
51899: LD_INT 0
51901: DEC
51902: ST_TO_ADDR
51903: LD_INT 5
51905: PUSH
51906: FOR_TO
51907: IFFALSE 52019
// begin _x := ShiftX ( x , i , 3 ) ;
51909: LD_ADDR_VAR 0 7
51913: PUSH
51914: LD_VAR 0 5
51918: PPUSH
51919: LD_VAR 0 4
51923: PPUSH
51924: LD_INT 3
51926: PPUSH
51927: CALL_OW 272
51931: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51932: LD_ADDR_VAR 0 8
51936: PUSH
51937: LD_VAR 0 6
51941: PPUSH
51942: LD_VAR 0 4
51946: PPUSH
51947: LD_INT 3
51949: PPUSH
51950: CALL_OW 273
51954: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51955: LD_VAR 0 7
51959: PPUSH
51960: LD_VAR 0 8
51964: PPUSH
51965: CALL_OW 488
51969: NOT
51970: IFFALSE 51974
// continue ;
51972: GO 51906
// if HexInfo ( _x , _y ) = 0 then
51974: LD_VAR 0 7
51978: PPUSH
51979: LD_VAR 0 8
51983: PPUSH
51984: CALL_OW 428
51988: PUSH
51989: LD_INT 0
51991: EQUAL
51992: IFFALSE 52017
// begin ComMoveXY ( unit , _x , _y ) ;
51994: LD_VAR 0 1
51998: PPUSH
51999: LD_VAR 0 7
52003: PPUSH
52004: LD_VAR 0 8
52008: PPUSH
52009: CALL_OW 111
// exit ;
52013: POP
52014: POP
52015: GO 52021
// end ; end ;
52017: GO 51906
52019: POP
52020: POP
// end ;
52021: LD_VAR 0 3
52025: RET
// export function ScanBase ( side , base_area ) ; begin
52026: LD_INT 0
52028: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52029: LD_ADDR_VAR 0 3
52033: PUSH
52034: LD_VAR 0 2
52038: PPUSH
52039: LD_INT 81
52041: PUSH
52042: LD_VAR 0 1
52046: PUSH
52047: EMPTY
52048: LIST
52049: LIST
52050: PPUSH
52051: CALL_OW 70
52055: ST_TO_ADDR
// end ;
52056: LD_VAR 0 3
52060: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
52061: LD_INT 0
52063: PPUSH
52064: PPUSH
52065: PPUSH
52066: PPUSH
52067: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
52068: LD_VAR 0 1
52072: NOT
52073: PUSH
52074: LD_EXP 76
52078: PUSH
52079: LD_VAR 0 1
52083: ARRAY
52084: NOT
52085: OR
52086: PUSH
52087: LD_VAR 0 2
52091: NOT
52092: OR
52093: PUSH
52094: LD_VAR 0 3
52098: NOT
52099: OR
52100: IFFALSE 52104
// exit ;
52102: GO 52617
// side := mc_sides [ base ] ;
52104: LD_ADDR_VAR 0 6
52108: PUSH
52109: LD_EXP 102
52113: PUSH
52114: LD_VAR 0 1
52118: ARRAY
52119: ST_TO_ADDR
// if not side then
52120: LD_VAR 0 6
52124: NOT
52125: IFFALSE 52129
// exit ;
52127: GO 52617
// for i in solds do
52129: LD_ADDR_VAR 0 7
52133: PUSH
52134: LD_VAR 0 2
52138: PUSH
52139: FOR_IN
52140: IFFALSE 52201
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
52142: LD_VAR 0 7
52146: PPUSH
52147: CALL_OW 310
52151: PPUSH
52152: CALL_OW 266
52156: PUSH
52157: LD_INT 32
52159: PUSH
52160: LD_INT 31
52162: PUSH
52163: EMPTY
52164: LIST
52165: LIST
52166: IN
52167: IFFALSE 52187
// solds := solds diff i else
52169: LD_ADDR_VAR 0 2
52173: PUSH
52174: LD_VAR 0 2
52178: PUSH
52179: LD_VAR 0 7
52183: DIFF
52184: ST_TO_ADDR
52185: GO 52199
// SetTag ( i , 18 ) ;
52187: LD_VAR 0 7
52191: PPUSH
52192: LD_INT 18
52194: PPUSH
52195: CALL_OW 109
52199: GO 52139
52201: POP
52202: POP
// if not solds then
52203: LD_VAR 0 2
52207: NOT
52208: IFFALSE 52212
// exit ;
52210: GO 52617
// repeat wait ( 0 0$1 ) ;
52212: LD_INT 35
52214: PPUSH
52215: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52219: LD_ADDR_VAR 0 5
52223: PUSH
52224: LD_VAR 0 6
52228: PPUSH
52229: LD_VAR 0 3
52233: PPUSH
52234: CALL 52026 0 2
52238: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52239: LD_EXP 76
52243: PUSH
52244: LD_VAR 0 1
52248: ARRAY
52249: NOT
52250: PUSH
52251: LD_EXP 76
52255: PUSH
52256: LD_VAR 0 1
52260: ARRAY
52261: PUSH
52262: EMPTY
52263: EQUAL
52264: OR
52265: IFFALSE 52302
// begin for i in solds do
52267: LD_ADDR_VAR 0 7
52271: PUSH
52272: LD_VAR 0 2
52276: PUSH
52277: FOR_IN
52278: IFFALSE 52291
// ComStop ( i ) ;
52280: LD_VAR 0 7
52284: PPUSH
52285: CALL_OW 141
52289: GO 52277
52291: POP
52292: POP
// solds := [ ] ;
52293: LD_ADDR_VAR 0 2
52297: PUSH
52298: EMPTY
52299: ST_TO_ADDR
// exit ;
52300: GO 52617
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52302: LD_VAR 0 5
52306: NOT
52307: PUSH
52308: LD_VAR 0 5
52312: PUSH
52313: LD_INT 3
52315: GREATER
52316: OR
52317: PUSH
52318: LD_EXP 98
52322: PUSH
52323: LD_VAR 0 1
52327: ARRAY
52328: OR
52329: IFFALSE 52370
// begin for i in solds do
52331: LD_ADDR_VAR 0 7
52335: PUSH
52336: LD_VAR 0 2
52340: PUSH
52341: FOR_IN
52342: IFFALSE 52366
// if HasTask ( i ) then
52344: LD_VAR 0 7
52348: PPUSH
52349: CALL_OW 314
52353: IFFALSE 52364
// ComStop ( i ) ;
52355: LD_VAR 0 7
52359: PPUSH
52360: CALL_OW 141
52364: GO 52341
52366: POP
52367: POP
// break ;
52368: GO 52605
// end ; for i in solds do
52370: LD_ADDR_VAR 0 7
52374: PUSH
52375: LD_VAR 0 2
52379: PUSH
52380: FOR_IN
52381: IFFALSE 52597
// begin if IsInUnit ( i ) then
52383: LD_VAR 0 7
52387: PPUSH
52388: CALL_OW 310
52392: IFFALSE 52403
// ComExitBuilding ( i ) ;
52394: LD_VAR 0 7
52398: PPUSH
52399: CALL_OW 122
// if GetLives ( i ) > 333 then
52403: LD_VAR 0 7
52407: PPUSH
52408: CALL_OW 256
52412: PUSH
52413: LD_INT 333
52415: GREATER
52416: IFFALSE 52444
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52418: LD_VAR 0 7
52422: PPUSH
52423: LD_VAR 0 5
52427: PPUSH
52428: LD_VAR 0 7
52432: PPUSH
52433: CALL_OW 74
52437: PPUSH
52438: CALL_OW 115
52442: GO 52595
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52444: LD_ADDR_VAR 0 8
52448: PUSH
52449: LD_EXP 76
52453: PUSH
52454: LD_VAR 0 1
52458: ARRAY
52459: PPUSH
52460: LD_INT 2
52462: PUSH
52463: LD_INT 30
52465: PUSH
52466: LD_INT 0
52468: PUSH
52469: EMPTY
52470: LIST
52471: LIST
52472: PUSH
52473: LD_INT 30
52475: PUSH
52476: LD_INT 1
52478: PUSH
52479: EMPTY
52480: LIST
52481: LIST
52482: PUSH
52483: LD_INT 30
52485: PUSH
52486: LD_INT 6
52488: PUSH
52489: EMPTY
52490: LIST
52491: LIST
52492: PUSH
52493: EMPTY
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: PPUSH
52499: CALL_OW 72
52503: PPUSH
52504: LD_VAR 0 7
52508: PPUSH
52509: CALL_OW 74
52513: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52514: LD_VAR 0 7
52518: PPUSH
52519: LD_VAR 0 8
52523: PPUSH
52524: CALL_OW 250
52528: PPUSH
52529: LD_INT 3
52531: PPUSH
52532: LD_INT 5
52534: PPUSH
52535: CALL_OW 272
52539: PPUSH
52540: LD_VAR 0 8
52544: PPUSH
52545: CALL_OW 251
52549: PPUSH
52550: LD_INT 3
52552: PPUSH
52553: LD_INT 5
52555: PPUSH
52556: CALL_OW 273
52560: PPUSH
52561: CALL_OW 111
// SetTag ( i , 0 ) ;
52565: LD_VAR 0 7
52569: PPUSH
52570: LD_INT 0
52572: PPUSH
52573: CALL_OW 109
// solds := solds diff i ;
52577: LD_ADDR_VAR 0 2
52581: PUSH
52582: LD_VAR 0 2
52586: PUSH
52587: LD_VAR 0 7
52591: DIFF
52592: ST_TO_ADDR
// continue ;
52593: GO 52380
// end ; end ;
52595: GO 52380
52597: POP
52598: POP
// until solds ;
52599: LD_VAR 0 2
52603: IFFALSE 52212
// MC_Reset ( base , 18 ) ;
52605: LD_VAR 0 1
52609: PPUSH
52610: LD_INT 18
52612: PPUSH
52613: CALL 24334 0 2
// end ;
52617: LD_VAR 0 4
52621: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52622: LD_INT 0
52624: PPUSH
52625: PPUSH
52626: PPUSH
52627: PPUSH
52628: PPUSH
52629: PPUSH
52630: PPUSH
52631: PPUSH
52632: PPUSH
52633: PPUSH
52634: PPUSH
52635: PPUSH
52636: PPUSH
52637: PPUSH
52638: PPUSH
52639: PPUSH
52640: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52641: LD_ADDR_VAR 0 13
52645: PUSH
52646: LD_EXP 76
52650: PUSH
52651: LD_VAR 0 1
52655: ARRAY
52656: PPUSH
52657: LD_INT 25
52659: PUSH
52660: LD_INT 3
52662: PUSH
52663: EMPTY
52664: LIST
52665: LIST
52666: PPUSH
52667: CALL_OW 72
52671: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52672: LD_EXP 116
52676: PUSH
52677: LD_VAR 0 1
52681: ARRAY
52682: IFFALSE 52706
// mechs := mechs diff mc_remote_driver [ base ] ;
52684: LD_ADDR_VAR 0 13
52688: PUSH
52689: LD_VAR 0 13
52693: PUSH
52694: LD_EXP 116
52698: PUSH
52699: LD_VAR 0 1
52703: ARRAY
52704: DIFF
52705: ST_TO_ADDR
// for i in mechs do
52706: LD_ADDR_VAR 0 5
52710: PUSH
52711: LD_VAR 0 13
52715: PUSH
52716: FOR_IN
52717: IFFALSE 52752
// if GetTag ( i ) > 0 then
52719: LD_VAR 0 5
52723: PPUSH
52724: CALL_OW 110
52728: PUSH
52729: LD_INT 0
52731: GREATER
52732: IFFALSE 52750
// mechs := mechs diff i ;
52734: LD_ADDR_VAR 0 13
52738: PUSH
52739: LD_VAR 0 13
52743: PUSH
52744: LD_VAR 0 5
52748: DIFF
52749: ST_TO_ADDR
52750: GO 52716
52752: POP
52753: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52754: LD_ADDR_VAR 0 9
52758: PUSH
52759: LD_EXP 76
52763: PUSH
52764: LD_VAR 0 1
52768: ARRAY
52769: PPUSH
52770: LD_INT 2
52772: PUSH
52773: LD_INT 25
52775: PUSH
52776: LD_INT 1
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: PUSH
52783: LD_INT 25
52785: PUSH
52786: LD_INT 5
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: PUSH
52793: LD_INT 25
52795: PUSH
52796: LD_INT 8
52798: PUSH
52799: EMPTY
52800: LIST
52801: LIST
52802: PUSH
52803: LD_INT 25
52805: PUSH
52806: LD_INT 9
52808: PUSH
52809: EMPTY
52810: LIST
52811: LIST
52812: PUSH
52813: EMPTY
52814: LIST
52815: LIST
52816: LIST
52817: LIST
52818: LIST
52819: PPUSH
52820: CALL_OW 72
52824: ST_TO_ADDR
// if not defenders and not solds then
52825: LD_VAR 0 2
52829: NOT
52830: PUSH
52831: LD_VAR 0 9
52835: NOT
52836: AND
52837: IFFALSE 52841
// exit ;
52839: GO 54467
// depot_under_attack := false ;
52841: LD_ADDR_VAR 0 17
52845: PUSH
52846: LD_INT 0
52848: ST_TO_ADDR
// sold_defenders := [ ] ;
52849: LD_ADDR_VAR 0 18
52853: PUSH
52854: EMPTY
52855: ST_TO_ADDR
// if mechs then
52856: LD_VAR 0 13
52860: IFFALSE 52989
// for i in defenders do
52862: LD_ADDR_VAR 0 5
52866: PUSH
52867: LD_VAR 0 2
52871: PUSH
52872: FOR_IN
52873: IFFALSE 52987
// begin SetTag ( i , 20 ) ;
52875: LD_VAR 0 5
52879: PPUSH
52880: LD_INT 20
52882: PPUSH
52883: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52887: LD_VAR 0 5
52891: PPUSH
52892: CALL_OW 263
52896: PUSH
52897: LD_INT 1
52899: EQUAL
52900: PUSH
52901: LD_VAR 0 5
52905: PPUSH
52906: CALL_OW 311
52910: NOT
52911: AND
52912: PUSH
52913: LD_VAR 0 13
52917: AND
52918: IFFALSE 52985
// begin un := mechs [ 1 ] ;
52920: LD_ADDR_VAR 0 11
52924: PUSH
52925: LD_VAR 0 13
52929: PUSH
52930: LD_INT 1
52932: ARRAY
52933: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52934: LD_VAR 0 11
52938: PPUSH
52939: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52943: LD_VAR 0 11
52947: PPUSH
52948: LD_VAR 0 5
52952: PPUSH
52953: CALL_OW 180
// SetTag ( un , 19 ) ;
52957: LD_VAR 0 11
52961: PPUSH
52962: LD_INT 19
52964: PPUSH
52965: CALL_OW 109
// mechs := mechs diff un ;
52969: LD_ADDR_VAR 0 13
52973: PUSH
52974: LD_VAR 0 13
52978: PUSH
52979: LD_VAR 0 11
52983: DIFF
52984: ST_TO_ADDR
// end ; end ;
52985: GO 52872
52987: POP
52988: POP
// if solds then
52989: LD_VAR 0 9
52993: IFFALSE 53052
// for i in solds do
52995: LD_ADDR_VAR 0 5
52999: PUSH
53000: LD_VAR 0 9
53004: PUSH
53005: FOR_IN
53006: IFFALSE 53050
// if not GetTag ( i ) then
53008: LD_VAR 0 5
53012: PPUSH
53013: CALL_OW 110
53017: NOT
53018: IFFALSE 53048
// begin defenders := defenders union i ;
53020: LD_ADDR_VAR 0 2
53024: PUSH
53025: LD_VAR 0 2
53029: PUSH
53030: LD_VAR 0 5
53034: UNION
53035: ST_TO_ADDR
// SetTag ( i , 18 ) ;
53036: LD_VAR 0 5
53040: PPUSH
53041: LD_INT 18
53043: PPUSH
53044: CALL_OW 109
// end ;
53048: GO 53005
53050: POP
53051: POP
// repeat wait ( 0 0$1 ) ;
53052: LD_INT 35
53054: PPUSH
53055: CALL_OW 67
// enemy := mc_scan [ base ] ;
53059: LD_ADDR_VAR 0 3
53063: PUSH
53064: LD_EXP 99
53068: PUSH
53069: LD_VAR 0 1
53073: ARRAY
53074: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53075: LD_EXP 76
53079: PUSH
53080: LD_VAR 0 1
53084: ARRAY
53085: NOT
53086: PUSH
53087: LD_EXP 76
53091: PUSH
53092: LD_VAR 0 1
53096: ARRAY
53097: PUSH
53098: EMPTY
53099: EQUAL
53100: OR
53101: IFFALSE 53138
// begin for i in defenders do
53103: LD_ADDR_VAR 0 5
53107: PUSH
53108: LD_VAR 0 2
53112: PUSH
53113: FOR_IN
53114: IFFALSE 53127
// ComStop ( i ) ;
53116: LD_VAR 0 5
53120: PPUSH
53121: CALL_OW 141
53125: GO 53113
53127: POP
53128: POP
// defenders := [ ] ;
53129: LD_ADDR_VAR 0 2
53133: PUSH
53134: EMPTY
53135: ST_TO_ADDR
// exit ;
53136: GO 54467
// end ; for i in defenders do
53138: LD_ADDR_VAR 0 5
53142: PUSH
53143: LD_VAR 0 2
53147: PUSH
53148: FOR_IN
53149: IFFALSE 53967
// begin e := NearestUnitToUnit ( enemy , i ) ;
53151: LD_ADDR_VAR 0 14
53155: PUSH
53156: LD_VAR 0 3
53160: PPUSH
53161: LD_VAR 0 5
53165: PPUSH
53166: CALL_OW 74
53170: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53171: LD_ADDR_VAR 0 8
53175: PUSH
53176: LD_EXP 76
53180: PUSH
53181: LD_VAR 0 1
53185: ARRAY
53186: PPUSH
53187: LD_INT 2
53189: PUSH
53190: LD_INT 30
53192: PUSH
53193: LD_INT 0
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: PUSH
53200: LD_INT 30
53202: PUSH
53203: LD_INT 1
53205: PUSH
53206: EMPTY
53207: LIST
53208: LIST
53209: PUSH
53210: EMPTY
53211: LIST
53212: LIST
53213: LIST
53214: PPUSH
53215: CALL_OW 72
53219: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
53220: LD_ADDR_VAR 0 17
53224: PUSH
53225: LD_VAR 0 8
53229: NOT
53230: PUSH
53231: LD_VAR 0 8
53235: PPUSH
53236: LD_INT 3
53238: PUSH
53239: LD_INT 24
53241: PUSH
53242: LD_INT 600
53244: PUSH
53245: EMPTY
53246: LIST
53247: LIST
53248: PUSH
53249: EMPTY
53250: LIST
53251: LIST
53252: PPUSH
53253: CALL_OW 72
53257: OR
53258: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53259: LD_VAR 0 5
53263: PPUSH
53264: CALL_OW 247
53268: PUSH
53269: LD_INT 2
53271: DOUBLE
53272: EQUAL
53273: IFTRUE 53277
53275: GO 53673
53277: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53278: LD_VAR 0 5
53282: PPUSH
53283: CALL_OW 256
53287: PUSH
53288: LD_INT 650
53290: GREATER
53291: PUSH
53292: LD_VAR 0 5
53296: PPUSH
53297: LD_VAR 0 14
53301: PPUSH
53302: CALL_OW 296
53306: PUSH
53307: LD_INT 40
53309: LESS
53310: PUSH
53311: LD_VAR 0 14
53315: PPUSH
53316: LD_EXP 101
53320: PUSH
53321: LD_VAR 0 1
53325: ARRAY
53326: PPUSH
53327: CALL_OW 308
53331: OR
53332: AND
53333: IFFALSE 53455
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
53335: LD_VAR 0 5
53339: PPUSH
53340: CALL_OW 262
53344: PUSH
53345: LD_INT 1
53347: EQUAL
53348: PUSH
53349: LD_VAR 0 5
53353: PPUSH
53354: CALL_OW 261
53358: PUSH
53359: LD_INT 30
53361: LESS
53362: AND
53363: PUSH
53364: LD_VAR 0 8
53368: AND
53369: IFFALSE 53439
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
53371: LD_VAR 0 5
53375: PPUSH
53376: LD_VAR 0 8
53380: PPUSH
53381: LD_VAR 0 5
53385: PPUSH
53386: CALL_OW 74
53390: PPUSH
53391: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
53395: LD_VAR 0 5
53399: PPUSH
53400: LD_VAR 0 8
53404: PPUSH
53405: LD_VAR 0 5
53409: PPUSH
53410: CALL_OW 74
53414: PPUSH
53415: CALL_OW 296
53419: PUSH
53420: LD_INT 6
53422: LESS
53423: IFFALSE 53437
// SetFuel ( i , 100 ) ;
53425: LD_VAR 0 5
53429: PPUSH
53430: LD_INT 100
53432: PPUSH
53433: CALL_OW 240
// end else
53437: GO 53453
// ComAttackUnit ( i , e ) ;
53439: LD_VAR 0 5
53443: PPUSH
53444: LD_VAR 0 14
53448: PPUSH
53449: CALL_OW 115
// end else
53453: GO 53556
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53455: LD_VAR 0 14
53459: PPUSH
53460: LD_EXP 101
53464: PUSH
53465: LD_VAR 0 1
53469: ARRAY
53470: PPUSH
53471: CALL_OW 308
53475: NOT
53476: PUSH
53477: LD_VAR 0 5
53481: PPUSH
53482: LD_VAR 0 14
53486: PPUSH
53487: CALL_OW 296
53491: PUSH
53492: LD_INT 40
53494: GREATEREQUAL
53495: AND
53496: PUSH
53497: LD_VAR 0 5
53501: PPUSH
53502: CALL_OW 256
53506: PUSH
53507: LD_INT 650
53509: LESSEQUAL
53510: OR
53511: PUSH
53512: LD_VAR 0 5
53516: PPUSH
53517: LD_EXP 100
53521: PUSH
53522: LD_VAR 0 1
53526: ARRAY
53527: PPUSH
53528: CALL_OW 308
53532: NOT
53533: AND
53534: IFFALSE 53556
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53536: LD_VAR 0 5
53540: PPUSH
53541: LD_EXP 100
53545: PUSH
53546: LD_VAR 0 1
53550: ARRAY
53551: PPUSH
53552: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53556: LD_VAR 0 5
53560: PPUSH
53561: CALL_OW 256
53565: PUSH
53566: LD_INT 998
53568: LESS
53569: PUSH
53570: LD_VAR 0 5
53574: PPUSH
53575: CALL_OW 263
53579: PUSH
53580: LD_INT 1
53582: EQUAL
53583: AND
53584: PUSH
53585: LD_VAR 0 5
53589: PPUSH
53590: CALL_OW 311
53594: AND
53595: PUSH
53596: LD_VAR 0 5
53600: PPUSH
53601: LD_EXP 100
53605: PUSH
53606: LD_VAR 0 1
53610: ARRAY
53611: PPUSH
53612: CALL_OW 308
53616: AND
53617: IFFALSE 53671
// begin mech := IsDrivenBy ( i ) ;
53619: LD_ADDR_VAR 0 10
53623: PUSH
53624: LD_VAR 0 5
53628: PPUSH
53629: CALL_OW 311
53633: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53634: LD_VAR 0 10
53638: PPUSH
53639: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53643: LD_VAR 0 10
53647: PPUSH
53648: LD_VAR 0 5
53652: PPUSH
53653: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53657: LD_VAR 0 10
53661: PPUSH
53662: LD_VAR 0 5
53666: PPUSH
53667: CALL_OW 180
// end ; end ; unit_human :
53671: GO 53938
53673: LD_INT 1
53675: DOUBLE
53676: EQUAL
53677: IFTRUE 53681
53679: GO 53937
53681: POP
// begin b := IsInUnit ( i ) ;
53682: LD_ADDR_VAR 0 19
53686: PUSH
53687: LD_VAR 0 5
53691: PPUSH
53692: CALL_OW 310
53696: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53697: LD_ADDR_VAR 0 20
53701: PUSH
53702: LD_VAR 0 19
53706: NOT
53707: PUSH
53708: LD_VAR 0 19
53712: PPUSH
53713: CALL_OW 266
53717: PUSH
53718: LD_INT 32
53720: PUSH
53721: LD_INT 31
53723: PUSH
53724: EMPTY
53725: LIST
53726: LIST
53727: IN
53728: OR
53729: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53730: LD_VAR 0 17
53734: PUSH
53735: LD_VAR 0 2
53739: PPUSH
53740: LD_INT 21
53742: PUSH
53743: LD_INT 2
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: PPUSH
53750: CALL_OW 72
53754: PUSH
53755: LD_INT 1
53757: LESSEQUAL
53758: OR
53759: PUSH
53760: LD_VAR 0 20
53764: AND
53765: PUSH
53766: LD_VAR 0 5
53770: PUSH
53771: LD_VAR 0 18
53775: IN
53776: NOT
53777: AND
53778: IFFALSE 53871
// begin if b then
53780: LD_VAR 0 19
53784: IFFALSE 53833
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53786: LD_VAR 0 19
53790: PPUSH
53791: LD_VAR 0 3
53795: PPUSH
53796: LD_VAR 0 19
53800: PPUSH
53801: CALL_OW 74
53805: PPUSH
53806: CALL_OW 296
53810: PUSH
53811: LD_INT 10
53813: LESS
53814: PUSH
53815: LD_VAR 0 19
53819: PPUSH
53820: CALL_OW 461
53824: PUSH
53825: LD_INT 7
53827: NONEQUAL
53828: AND
53829: IFFALSE 53833
// continue ;
53831: GO 53148
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53833: LD_ADDR_VAR 0 18
53837: PUSH
53838: LD_VAR 0 18
53842: PPUSH
53843: LD_VAR 0 18
53847: PUSH
53848: LD_INT 1
53850: PLUS
53851: PPUSH
53852: LD_VAR 0 5
53856: PPUSH
53857: CALL_OW 1
53861: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53862: LD_VAR 0 5
53866: PPUSH
53867: CALL_OW 122
// end ; if sold_defenders then
53871: LD_VAR 0 18
53875: IFFALSE 53935
// if i in sold_defenders then
53877: LD_VAR 0 5
53881: PUSH
53882: LD_VAR 0 18
53886: IN
53887: IFFALSE 53935
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53889: LD_VAR 0 5
53893: PPUSH
53894: CALL_OW 314
53898: NOT
53899: PUSH
53900: LD_VAR 0 5
53904: PPUSH
53905: LD_VAR 0 14
53909: PPUSH
53910: CALL_OW 296
53914: PUSH
53915: LD_INT 30
53917: LESS
53918: AND
53919: IFFALSE 53935
// ComAttackUnit ( i , e ) ;
53921: LD_VAR 0 5
53925: PPUSH
53926: LD_VAR 0 14
53930: PPUSH
53931: CALL_OW 115
// end ; end ; end ;
53935: GO 53938
53937: POP
// if IsDead ( i ) then
53938: LD_VAR 0 5
53942: PPUSH
53943: CALL_OW 301
53947: IFFALSE 53965
// defenders := defenders diff i ;
53949: LD_ADDR_VAR 0 2
53953: PUSH
53954: LD_VAR 0 2
53958: PUSH
53959: LD_VAR 0 5
53963: DIFF
53964: ST_TO_ADDR
// end ;
53965: GO 53148
53967: POP
53968: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
53969: LD_VAR 0 3
53973: NOT
53974: PUSH
53975: LD_VAR 0 2
53979: NOT
53980: OR
53981: PUSH
53982: LD_EXP 76
53986: PUSH
53987: LD_VAR 0 1
53991: ARRAY
53992: NOT
53993: OR
53994: IFFALSE 53052
// MC_Reset ( base , 18 ) ;
53996: LD_VAR 0 1
54000: PPUSH
54001: LD_INT 18
54003: PPUSH
54004: CALL 24334 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54008: LD_ADDR_VAR 0 2
54012: PUSH
54013: LD_VAR 0 2
54017: PUSH
54018: LD_VAR 0 2
54022: PPUSH
54023: LD_INT 2
54025: PUSH
54026: LD_INT 25
54028: PUSH
54029: LD_INT 1
54031: PUSH
54032: EMPTY
54033: LIST
54034: LIST
54035: PUSH
54036: LD_INT 25
54038: PUSH
54039: LD_INT 5
54041: PUSH
54042: EMPTY
54043: LIST
54044: LIST
54045: PUSH
54046: LD_INT 25
54048: PUSH
54049: LD_INT 8
54051: PUSH
54052: EMPTY
54053: LIST
54054: LIST
54055: PUSH
54056: LD_INT 25
54058: PUSH
54059: LD_INT 9
54061: PUSH
54062: EMPTY
54063: LIST
54064: LIST
54065: PUSH
54066: EMPTY
54067: LIST
54068: LIST
54069: LIST
54070: LIST
54071: LIST
54072: PPUSH
54073: CALL_OW 72
54077: DIFF
54078: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
54079: LD_VAR 0 3
54083: NOT
54084: PUSH
54085: LD_VAR 0 2
54089: PPUSH
54090: LD_INT 21
54092: PUSH
54093: LD_INT 2
54095: PUSH
54096: EMPTY
54097: LIST
54098: LIST
54099: PPUSH
54100: CALL_OW 72
54104: AND
54105: IFFALSE 54443
// begin tmp := FilterByTag ( defenders , 19 ) ;
54107: LD_ADDR_VAR 0 12
54111: PUSH
54112: LD_VAR 0 2
54116: PPUSH
54117: LD_INT 19
54119: PPUSH
54120: CALL 90896 0 2
54124: ST_TO_ADDR
// if tmp then
54125: LD_VAR 0 12
54129: IFFALSE 54199
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
54131: LD_ADDR_VAR 0 12
54135: PUSH
54136: LD_VAR 0 12
54140: PPUSH
54141: LD_INT 25
54143: PUSH
54144: LD_INT 3
54146: PUSH
54147: EMPTY
54148: LIST
54149: LIST
54150: PPUSH
54151: CALL_OW 72
54155: ST_TO_ADDR
// if tmp then
54156: LD_VAR 0 12
54160: IFFALSE 54199
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
54162: LD_ADDR_EXP 88
54166: PUSH
54167: LD_EXP 88
54171: PPUSH
54172: LD_VAR 0 1
54176: PPUSH
54177: LD_EXP 88
54181: PUSH
54182: LD_VAR 0 1
54186: ARRAY
54187: PUSH
54188: LD_VAR 0 12
54192: UNION
54193: PPUSH
54194: CALL_OW 1
54198: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
54199: LD_VAR 0 1
54203: PPUSH
54204: LD_INT 19
54206: PPUSH
54207: CALL 24334 0 2
// repeat wait ( 0 0$1 ) ;
54211: LD_INT 35
54213: PPUSH
54214: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
54218: LD_EXP 76
54222: PUSH
54223: LD_VAR 0 1
54227: ARRAY
54228: NOT
54229: PUSH
54230: LD_EXP 76
54234: PUSH
54235: LD_VAR 0 1
54239: ARRAY
54240: PUSH
54241: EMPTY
54242: EQUAL
54243: OR
54244: IFFALSE 54281
// begin for i in defenders do
54246: LD_ADDR_VAR 0 5
54250: PUSH
54251: LD_VAR 0 2
54255: PUSH
54256: FOR_IN
54257: IFFALSE 54270
// ComStop ( i ) ;
54259: LD_VAR 0 5
54263: PPUSH
54264: CALL_OW 141
54268: GO 54256
54270: POP
54271: POP
// defenders := [ ] ;
54272: LD_ADDR_VAR 0 2
54276: PUSH
54277: EMPTY
54278: ST_TO_ADDR
// exit ;
54279: GO 54467
// end ; for i in defenders do
54281: LD_ADDR_VAR 0 5
54285: PUSH
54286: LD_VAR 0 2
54290: PUSH
54291: FOR_IN
54292: IFFALSE 54381
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54294: LD_VAR 0 5
54298: PPUSH
54299: LD_EXP 100
54303: PUSH
54304: LD_VAR 0 1
54308: ARRAY
54309: PPUSH
54310: CALL_OW 308
54314: NOT
54315: IFFALSE 54339
// ComMoveToArea ( i , mc_parking [ base ] ) else
54317: LD_VAR 0 5
54321: PPUSH
54322: LD_EXP 100
54326: PUSH
54327: LD_VAR 0 1
54331: ARRAY
54332: PPUSH
54333: CALL_OW 113
54337: GO 54379
// if GetControl ( i ) = control_manual then
54339: LD_VAR 0 5
54343: PPUSH
54344: CALL_OW 263
54348: PUSH
54349: LD_INT 1
54351: EQUAL
54352: IFFALSE 54379
// if IsDrivenBy ( i ) then
54354: LD_VAR 0 5
54358: PPUSH
54359: CALL_OW 311
54363: IFFALSE 54379
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54365: LD_VAR 0 5
54369: PPUSH
54370: CALL_OW 311
54374: PPUSH
54375: CALL_OW 121
// end ;
54379: GO 54291
54381: POP
54382: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54383: LD_VAR 0 2
54387: PPUSH
54388: LD_INT 95
54390: PUSH
54391: LD_EXP 100
54395: PUSH
54396: LD_VAR 0 1
54400: ARRAY
54401: PUSH
54402: EMPTY
54403: LIST
54404: LIST
54405: PPUSH
54406: CALL_OW 72
54410: PUSH
54411: LD_VAR 0 2
54415: EQUAL
54416: PUSH
54417: LD_EXP 99
54421: PUSH
54422: LD_VAR 0 1
54426: ARRAY
54427: OR
54428: PUSH
54429: LD_EXP 76
54433: PUSH
54434: LD_VAR 0 1
54438: ARRAY
54439: NOT
54440: OR
54441: IFFALSE 54211
// end ; MC_Reset ( base , 19 ) ;
54443: LD_VAR 0 1
54447: PPUSH
54448: LD_INT 19
54450: PPUSH
54451: CALL 24334 0 2
// MC_Reset ( base , 20 ) ;
54455: LD_VAR 0 1
54459: PPUSH
54460: LD_INT 20
54462: PPUSH
54463: CALL 24334 0 2
// end ;
54467: LD_VAR 0 4
54471: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54472: LD_INT 0
54474: PPUSH
54475: PPUSH
54476: PPUSH
54477: PPUSH
// result := false ;
54478: LD_ADDR_VAR 0 2
54482: PUSH
54483: LD_INT 0
54485: ST_TO_ADDR
// side := GetSide ( unit ) ;
54486: LD_ADDR_VAR 0 3
54490: PUSH
54491: LD_VAR 0 1
54495: PPUSH
54496: CALL_OW 255
54500: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54501: LD_ADDR_VAR 0 4
54505: PUSH
54506: LD_VAR 0 1
54510: PPUSH
54511: CALL_OW 248
54515: ST_TO_ADDR
// case nat of 1 :
54516: LD_VAR 0 4
54520: PUSH
54521: LD_INT 1
54523: DOUBLE
54524: EQUAL
54525: IFTRUE 54529
54527: GO 54540
54529: POP
// tech := tech_lassight ; 2 :
54530: LD_ADDR_VAR 0 5
54534: PUSH
54535: LD_INT 12
54537: ST_TO_ADDR
54538: GO 54579
54540: LD_INT 2
54542: DOUBLE
54543: EQUAL
54544: IFTRUE 54548
54546: GO 54559
54548: POP
// tech := tech_mortar ; 3 :
54549: LD_ADDR_VAR 0 5
54553: PUSH
54554: LD_INT 41
54556: ST_TO_ADDR
54557: GO 54579
54559: LD_INT 3
54561: DOUBLE
54562: EQUAL
54563: IFTRUE 54567
54565: GO 54578
54567: POP
// tech := tech_bazooka ; end ;
54568: LD_ADDR_VAR 0 5
54572: PUSH
54573: LD_INT 44
54575: ST_TO_ADDR
54576: GO 54579
54578: POP
// if Researched ( side , tech ) then
54579: LD_VAR 0 3
54583: PPUSH
54584: LD_VAR 0 5
54588: PPUSH
54589: CALL_OW 325
54593: IFFALSE 54620
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54595: LD_ADDR_VAR 0 2
54599: PUSH
54600: LD_INT 5
54602: PUSH
54603: LD_INT 8
54605: PUSH
54606: LD_INT 9
54608: PUSH
54609: EMPTY
54610: LIST
54611: LIST
54612: LIST
54613: PUSH
54614: LD_VAR 0 4
54618: ARRAY
54619: ST_TO_ADDR
// end ;
54620: LD_VAR 0 2
54624: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54625: LD_INT 0
54627: PPUSH
54628: PPUSH
54629: PPUSH
// if not mines then
54630: LD_VAR 0 2
54634: NOT
54635: IFFALSE 54639
// exit ;
54637: GO 54783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54639: LD_ADDR_VAR 0 5
54643: PUSH
54644: LD_INT 81
54646: PUSH
54647: LD_VAR 0 1
54651: PUSH
54652: EMPTY
54653: LIST
54654: LIST
54655: PUSH
54656: LD_INT 3
54658: PUSH
54659: LD_INT 21
54661: PUSH
54662: LD_INT 3
54664: PUSH
54665: EMPTY
54666: LIST
54667: LIST
54668: PUSH
54669: EMPTY
54670: LIST
54671: LIST
54672: PUSH
54673: EMPTY
54674: LIST
54675: LIST
54676: PPUSH
54677: CALL_OW 69
54681: ST_TO_ADDR
// for i in mines do
54682: LD_ADDR_VAR 0 4
54686: PUSH
54687: LD_VAR 0 2
54691: PUSH
54692: FOR_IN
54693: IFFALSE 54781
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54695: LD_VAR 0 4
54699: PUSH
54700: LD_INT 1
54702: ARRAY
54703: PPUSH
54704: LD_VAR 0 4
54708: PUSH
54709: LD_INT 2
54711: ARRAY
54712: PPUSH
54713: CALL_OW 458
54717: NOT
54718: IFFALSE 54722
// continue ;
54720: GO 54692
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54722: LD_VAR 0 4
54726: PUSH
54727: LD_INT 1
54729: ARRAY
54730: PPUSH
54731: LD_VAR 0 4
54735: PUSH
54736: LD_INT 2
54738: ARRAY
54739: PPUSH
54740: CALL_OW 428
54744: PUSH
54745: LD_VAR 0 5
54749: IN
54750: IFFALSE 54779
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54752: LD_VAR 0 4
54756: PUSH
54757: LD_INT 1
54759: ARRAY
54760: PPUSH
54761: LD_VAR 0 4
54765: PUSH
54766: LD_INT 2
54768: ARRAY
54769: PPUSH
54770: LD_VAR 0 1
54774: PPUSH
54775: CALL_OW 456
// end ;
54779: GO 54692
54781: POP
54782: POP
// end ;
54783: LD_VAR 0 3
54787: RET
// export function Count ( array ) ; var i ; begin
54788: LD_INT 0
54790: PPUSH
54791: PPUSH
// result := 0 ;
54792: LD_ADDR_VAR 0 2
54796: PUSH
54797: LD_INT 0
54799: ST_TO_ADDR
// for i in array do
54800: LD_ADDR_VAR 0 3
54804: PUSH
54805: LD_VAR 0 1
54809: PUSH
54810: FOR_IN
54811: IFFALSE 54835
// if i then
54813: LD_VAR 0 3
54817: IFFALSE 54833
// result := result + 1 ;
54819: LD_ADDR_VAR 0 2
54823: PUSH
54824: LD_VAR 0 2
54828: PUSH
54829: LD_INT 1
54831: PLUS
54832: ST_TO_ADDR
54833: GO 54810
54835: POP
54836: POP
// end ;
54837: LD_VAR 0 2
54841: RET
// export function IsEmpty ( building ) ; begin
54842: LD_INT 0
54844: PPUSH
// if not building then
54845: LD_VAR 0 1
54849: NOT
54850: IFFALSE 54854
// exit ;
54852: GO 54897
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54854: LD_ADDR_VAR 0 2
54858: PUSH
54859: LD_VAR 0 1
54863: PUSH
54864: LD_INT 22
54866: PUSH
54867: LD_VAR 0 1
54871: PPUSH
54872: CALL_OW 255
54876: PUSH
54877: EMPTY
54878: LIST
54879: LIST
54880: PUSH
54881: LD_INT 58
54883: PUSH
54884: EMPTY
54885: LIST
54886: PUSH
54887: EMPTY
54888: LIST
54889: LIST
54890: PPUSH
54891: CALL_OW 69
54895: IN
54896: ST_TO_ADDR
// end ;
54897: LD_VAR 0 2
54901: RET
// export function IsNotFull ( building ) ; begin
54902: LD_INT 0
54904: PPUSH
// if not building then
54905: LD_VAR 0 1
54909: NOT
54910: IFFALSE 54914
// exit ;
54912: GO 54933
// result := UnitsInside ( building ) < 6 ;
54914: LD_ADDR_VAR 0 2
54918: PUSH
54919: LD_VAR 0 1
54923: PPUSH
54924: CALL_OW 313
54928: PUSH
54929: LD_INT 6
54931: LESS
54932: ST_TO_ADDR
// end ;
54933: LD_VAR 0 2
54937: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54938: LD_INT 0
54940: PPUSH
54941: PPUSH
54942: PPUSH
54943: PPUSH
// tmp := [ ] ;
54944: LD_ADDR_VAR 0 3
54948: PUSH
54949: EMPTY
54950: ST_TO_ADDR
// list := [ ] ;
54951: LD_ADDR_VAR 0 5
54955: PUSH
54956: EMPTY
54957: ST_TO_ADDR
// for i = 16 to 25 do
54958: LD_ADDR_VAR 0 4
54962: PUSH
54963: DOUBLE
54964: LD_INT 16
54966: DEC
54967: ST_TO_ADDR
54968: LD_INT 25
54970: PUSH
54971: FOR_TO
54972: IFFALSE 55045
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54974: LD_ADDR_VAR 0 3
54978: PUSH
54979: LD_VAR 0 3
54983: PUSH
54984: LD_INT 22
54986: PUSH
54987: LD_VAR 0 1
54991: PPUSH
54992: CALL_OW 255
54996: PUSH
54997: EMPTY
54998: LIST
54999: LIST
55000: PUSH
55001: LD_INT 91
55003: PUSH
55004: LD_VAR 0 1
55008: PUSH
55009: LD_INT 6
55011: PUSH
55012: EMPTY
55013: LIST
55014: LIST
55015: LIST
55016: PUSH
55017: LD_INT 30
55019: PUSH
55020: LD_VAR 0 4
55024: PUSH
55025: EMPTY
55026: LIST
55027: LIST
55028: PUSH
55029: EMPTY
55030: LIST
55031: LIST
55032: LIST
55033: PUSH
55034: EMPTY
55035: LIST
55036: PPUSH
55037: CALL_OW 69
55041: ADD
55042: ST_TO_ADDR
55043: GO 54971
55045: POP
55046: POP
// for i = 1 to tmp do
55047: LD_ADDR_VAR 0 4
55051: PUSH
55052: DOUBLE
55053: LD_INT 1
55055: DEC
55056: ST_TO_ADDR
55057: LD_VAR 0 3
55061: PUSH
55062: FOR_TO
55063: IFFALSE 55151
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55065: LD_ADDR_VAR 0 5
55069: PUSH
55070: LD_VAR 0 5
55074: PUSH
55075: LD_VAR 0 3
55079: PUSH
55080: LD_VAR 0 4
55084: ARRAY
55085: PPUSH
55086: CALL_OW 266
55090: PUSH
55091: LD_VAR 0 3
55095: PUSH
55096: LD_VAR 0 4
55100: ARRAY
55101: PPUSH
55102: CALL_OW 250
55106: PUSH
55107: LD_VAR 0 3
55111: PUSH
55112: LD_VAR 0 4
55116: ARRAY
55117: PPUSH
55118: CALL_OW 251
55122: PUSH
55123: LD_VAR 0 3
55127: PUSH
55128: LD_VAR 0 4
55132: ARRAY
55133: PPUSH
55134: CALL_OW 254
55138: PUSH
55139: EMPTY
55140: LIST
55141: LIST
55142: LIST
55143: LIST
55144: PUSH
55145: EMPTY
55146: LIST
55147: ADD
55148: ST_TO_ADDR
55149: GO 55062
55151: POP
55152: POP
// result := list ;
55153: LD_ADDR_VAR 0 2
55157: PUSH
55158: LD_VAR 0 5
55162: ST_TO_ADDR
// end ;
55163: LD_VAR 0 2
55167: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55168: LD_INT 0
55170: PPUSH
55171: PPUSH
55172: PPUSH
55173: PPUSH
55174: PPUSH
55175: PPUSH
55176: PPUSH
// if not factory then
55177: LD_VAR 0 1
55181: NOT
55182: IFFALSE 55186
// exit ;
55184: GO 55779
// if control = control_apeman then
55186: LD_VAR 0 4
55190: PUSH
55191: LD_INT 5
55193: EQUAL
55194: IFFALSE 55303
// begin tmp := UnitsInside ( factory ) ;
55196: LD_ADDR_VAR 0 8
55200: PUSH
55201: LD_VAR 0 1
55205: PPUSH
55206: CALL_OW 313
55210: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55211: LD_VAR 0 8
55215: PPUSH
55216: LD_INT 25
55218: PUSH
55219: LD_INT 12
55221: PUSH
55222: EMPTY
55223: LIST
55224: LIST
55225: PPUSH
55226: CALL_OW 72
55230: NOT
55231: IFFALSE 55241
// control := control_manual ;
55233: LD_ADDR_VAR 0 4
55237: PUSH
55238: LD_INT 1
55240: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55241: LD_ADDR_VAR 0 8
55245: PUSH
55246: LD_VAR 0 1
55250: PPUSH
55251: CALL 54938 0 1
55255: ST_TO_ADDR
// if tmp then
55256: LD_VAR 0 8
55260: IFFALSE 55303
// begin for i in tmp do
55262: LD_ADDR_VAR 0 7
55266: PUSH
55267: LD_VAR 0 8
55271: PUSH
55272: FOR_IN
55273: IFFALSE 55301
// if i [ 1 ] = b_ext_radio then
55275: LD_VAR 0 7
55279: PUSH
55280: LD_INT 1
55282: ARRAY
55283: PUSH
55284: LD_INT 22
55286: EQUAL
55287: IFFALSE 55299
// begin control := control_remote ;
55289: LD_ADDR_VAR 0 4
55293: PUSH
55294: LD_INT 2
55296: ST_TO_ADDR
// break ;
55297: GO 55301
// end ;
55299: GO 55272
55301: POP
55302: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55303: LD_VAR 0 1
55307: PPUSH
55308: LD_VAR 0 2
55312: PPUSH
55313: LD_VAR 0 3
55317: PPUSH
55318: LD_VAR 0 4
55322: PPUSH
55323: LD_VAR 0 5
55327: PPUSH
55328: CALL_OW 448
55332: IFFALSE 55367
// begin result := [ chassis , engine , control , weapon ] ;
55334: LD_ADDR_VAR 0 6
55338: PUSH
55339: LD_VAR 0 2
55343: PUSH
55344: LD_VAR 0 3
55348: PUSH
55349: LD_VAR 0 4
55353: PUSH
55354: LD_VAR 0 5
55358: PUSH
55359: EMPTY
55360: LIST
55361: LIST
55362: LIST
55363: LIST
55364: ST_TO_ADDR
// exit ;
55365: GO 55779
// end ; _chassis := AvailableChassisList ( factory ) ;
55367: LD_ADDR_VAR 0 9
55371: PUSH
55372: LD_VAR 0 1
55376: PPUSH
55377: CALL_OW 475
55381: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55382: LD_ADDR_VAR 0 11
55386: PUSH
55387: LD_VAR 0 1
55391: PPUSH
55392: CALL_OW 476
55396: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55397: LD_ADDR_VAR 0 12
55401: PUSH
55402: LD_VAR 0 1
55406: PPUSH
55407: CALL_OW 477
55411: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55412: LD_ADDR_VAR 0 10
55416: PUSH
55417: LD_VAR 0 1
55421: PPUSH
55422: CALL_OW 478
55426: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55427: LD_VAR 0 9
55431: NOT
55432: PUSH
55433: LD_VAR 0 11
55437: NOT
55438: OR
55439: PUSH
55440: LD_VAR 0 12
55444: NOT
55445: OR
55446: PUSH
55447: LD_VAR 0 10
55451: NOT
55452: OR
55453: IFFALSE 55488
// begin result := [ chassis , engine , control , weapon ] ;
55455: LD_ADDR_VAR 0 6
55459: PUSH
55460: LD_VAR 0 2
55464: PUSH
55465: LD_VAR 0 3
55469: PUSH
55470: LD_VAR 0 4
55474: PUSH
55475: LD_VAR 0 5
55479: PUSH
55480: EMPTY
55481: LIST
55482: LIST
55483: LIST
55484: LIST
55485: ST_TO_ADDR
// exit ;
55486: GO 55779
// end ; if not chassis in _chassis then
55488: LD_VAR 0 2
55492: PUSH
55493: LD_VAR 0 9
55497: IN
55498: NOT
55499: IFFALSE 55525
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55501: LD_ADDR_VAR 0 2
55505: PUSH
55506: LD_VAR 0 9
55510: PUSH
55511: LD_INT 1
55513: PPUSH
55514: LD_VAR 0 9
55518: PPUSH
55519: CALL_OW 12
55523: ARRAY
55524: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55525: LD_VAR 0 2
55529: PPUSH
55530: LD_VAR 0 3
55534: PPUSH
55535: CALL 55784 0 2
55539: NOT
55540: IFFALSE 55599
// repeat engine := _engine [ 1 ] ;
55542: LD_ADDR_VAR 0 3
55546: PUSH
55547: LD_VAR 0 11
55551: PUSH
55552: LD_INT 1
55554: ARRAY
55555: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55556: LD_ADDR_VAR 0 11
55560: PUSH
55561: LD_VAR 0 11
55565: PPUSH
55566: LD_INT 1
55568: PPUSH
55569: CALL_OW 3
55573: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55574: LD_VAR 0 2
55578: PPUSH
55579: LD_VAR 0 3
55583: PPUSH
55584: CALL 55784 0 2
55588: PUSH
55589: LD_VAR 0 11
55593: PUSH
55594: EMPTY
55595: EQUAL
55596: OR
55597: IFFALSE 55542
// if not control in _control then
55599: LD_VAR 0 4
55603: PUSH
55604: LD_VAR 0 12
55608: IN
55609: NOT
55610: IFFALSE 55636
// control := _control [ rand ( 1 , _control ) ] ;
55612: LD_ADDR_VAR 0 4
55616: PUSH
55617: LD_VAR 0 12
55621: PUSH
55622: LD_INT 1
55624: PPUSH
55625: LD_VAR 0 12
55629: PPUSH
55630: CALL_OW 12
55634: ARRAY
55635: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55636: LD_VAR 0 2
55640: PPUSH
55641: LD_VAR 0 5
55645: PPUSH
55646: CALL 56004 0 2
55650: NOT
55651: IFFALSE 55710
// repeat weapon := _weapon [ 1 ] ;
55653: LD_ADDR_VAR 0 5
55657: PUSH
55658: LD_VAR 0 10
55662: PUSH
55663: LD_INT 1
55665: ARRAY
55666: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55667: LD_ADDR_VAR 0 10
55671: PUSH
55672: LD_VAR 0 10
55676: PPUSH
55677: LD_INT 1
55679: PPUSH
55680: CALL_OW 3
55684: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55685: LD_VAR 0 2
55689: PPUSH
55690: LD_VAR 0 5
55694: PPUSH
55695: CALL 56004 0 2
55699: PUSH
55700: LD_VAR 0 10
55704: PUSH
55705: EMPTY
55706: EQUAL
55707: OR
55708: IFFALSE 55653
// result := [ ] ;
55710: LD_ADDR_VAR 0 6
55714: PUSH
55715: EMPTY
55716: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55717: LD_VAR 0 1
55721: PPUSH
55722: LD_VAR 0 2
55726: PPUSH
55727: LD_VAR 0 3
55731: PPUSH
55732: LD_VAR 0 4
55736: PPUSH
55737: LD_VAR 0 5
55741: PPUSH
55742: CALL_OW 448
55746: IFFALSE 55779
// result := [ chassis , engine , control , weapon ] ;
55748: LD_ADDR_VAR 0 6
55752: PUSH
55753: LD_VAR 0 2
55757: PUSH
55758: LD_VAR 0 3
55762: PUSH
55763: LD_VAR 0 4
55767: PUSH
55768: LD_VAR 0 5
55772: PUSH
55773: EMPTY
55774: LIST
55775: LIST
55776: LIST
55777: LIST
55778: ST_TO_ADDR
// end ;
55779: LD_VAR 0 6
55783: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55784: LD_INT 0
55786: PPUSH
// if not chassis or not engine then
55787: LD_VAR 0 1
55791: NOT
55792: PUSH
55793: LD_VAR 0 2
55797: NOT
55798: OR
55799: IFFALSE 55803
// exit ;
55801: GO 55999
// case engine of engine_solar :
55803: LD_VAR 0 2
55807: PUSH
55808: LD_INT 2
55810: DOUBLE
55811: EQUAL
55812: IFTRUE 55816
55814: GO 55854
55816: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55817: LD_ADDR_VAR 0 3
55821: PUSH
55822: LD_INT 11
55824: PUSH
55825: LD_INT 12
55827: PUSH
55828: LD_INT 13
55830: PUSH
55831: LD_INT 14
55833: PUSH
55834: LD_INT 1
55836: PUSH
55837: LD_INT 2
55839: PUSH
55840: LD_INT 3
55842: PUSH
55843: EMPTY
55844: LIST
55845: LIST
55846: LIST
55847: LIST
55848: LIST
55849: LIST
55850: LIST
55851: ST_TO_ADDR
55852: GO 55983
55854: LD_INT 1
55856: DOUBLE
55857: EQUAL
55858: IFTRUE 55862
55860: GO 55924
55862: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55863: LD_ADDR_VAR 0 3
55867: PUSH
55868: LD_INT 11
55870: PUSH
55871: LD_INT 12
55873: PUSH
55874: LD_INT 13
55876: PUSH
55877: LD_INT 14
55879: PUSH
55880: LD_INT 1
55882: PUSH
55883: LD_INT 2
55885: PUSH
55886: LD_INT 3
55888: PUSH
55889: LD_INT 4
55891: PUSH
55892: LD_INT 5
55894: PUSH
55895: LD_INT 21
55897: PUSH
55898: LD_INT 23
55900: PUSH
55901: LD_INT 22
55903: PUSH
55904: LD_INT 24
55906: PUSH
55907: EMPTY
55908: LIST
55909: LIST
55910: LIST
55911: LIST
55912: LIST
55913: LIST
55914: LIST
55915: LIST
55916: LIST
55917: LIST
55918: LIST
55919: LIST
55920: LIST
55921: ST_TO_ADDR
55922: GO 55983
55924: LD_INT 3
55926: DOUBLE
55927: EQUAL
55928: IFTRUE 55932
55930: GO 55982
55932: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55933: LD_ADDR_VAR 0 3
55937: PUSH
55938: LD_INT 13
55940: PUSH
55941: LD_INT 14
55943: PUSH
55944: LD_INT 2
55946: PUSH
55947: LD_INT 3
55949: PUSH
55950: LD_INT 4
55952: PUSH
55953: LD_INT 5
55955: PUSH
55956: LD_INT 21
55958: PUSH
55959: LD_INT 22
55961: PUSH
55962: LD_INT 23
55964: PUSH
55965: LD_INT 24
55967: PUSH
55968: EMPTY
55969: LIST
55970: LIST
55971: LIST
55972: LIST
55973: LIST
55974: LIST
55975: LIST
55976: LIST
55977: LIST
55978: LIST
55979: ST_TO_ADDR
55980: GO 55983
55982: POP
// result := ( chassis in result ) ;
55983: LD_ADDR_VAR 0 3
55987: PUSH
55988: LD_VAR 0 1
55992: PUSH
55993: LD_VAR 0 3
55997: IN
55998: ST_TO_ADDR
// end ;
55999: LD_VAR 0 3
56003: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56004: LD_INT 0
56006: PPUSH
// if not chassis or not weapon then
56007: LD_VAR 0 1
56011: NOT
56012: PUSH
56013: LD_VAR 0 2
56017: NOT
56018: OR
56019: IFFALSE 56023
// exit ;
56021: GO 57049
// case weapon of us_machine_gun :
56023: LD_VAR 0 2
56027: PUSH
56028: LD_INT 2
56030: DOUBLE
56031: EQUAL
56032: IFTRUE 56036
56034: GO 56066
56036: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56037: LD_ADDR_VAR 0 3
56041: PUSH
56042: LD_INT 1
56044: PUSH
56045: LD_INT 2
56047: PUSH
56048: LD_INT 3
56050: PUSH
56051: LD_INT 4
56053: PUSH
56054: LD_INT 5
56056: PUSH
56057: EMPTY
56058: LIST
56059: LIST
56060: LIST
56061: LIST
56062: LIST
56063: ST_TO_ADDR
56064: GO 57033
56066: LD_INT 3
56068: DOUBLE
56069: EQUAL
56070: IFTRUE 56074
56072: GO 56104
56074: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56075: LD_ADDR_VAR 0 3
56079: PUSH
56080: LD_INT 1
56082: PUSH
56083: LD_INT 2
56085: PUSH
56086: LD_INT 3
56088: PUSH
56089: LD_INT 4
56091: PUSH
56092: LD_INT 5
56094: PUSH
56095: EMPTY
56096: LIST
56097: LIST
56098: LIST
56099: LIST
56100: LIST
56101: ST_TO_ADDR
56102: GO 57033
56104: LD_INT 11
56106: DOUBLE
56107: EQUAL
56108: IFTRUE 56112
56110: GO 56142
56112: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56113: LD_ADDR_VAR 0 3
56117: PUSH
56118: LD_INT 1
56120: PUSH
56121: LD_INT 2
56123: PUSH
56124: LD_INT 3
56126: PUSH
56127: LD_INT 4
56129: PUSH
56130: LD_INT 5
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: LIST
56137: LIST
56138: LIST
56139: ST_TO_ADDR
56140: GO 57033
56142: LD_INT 4
56144: DOUBLE
56145: EQUAL
56146: IFTRUE 56150
56148: GO 56176
56150: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56151: LD_ADDR_VAR 0 3
56155: PUSH
56156: LD_INT 2
56158: PUSH
56159: LD_INT 3
56161: PUSH
56162: LD_INT 4
56164: PUSH
56165: LD_INT 5
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: LIST
56172: LIST
56173: ST_TO_ADDR
56174: GO 57033
56176: LD_INT 5
56178: DOUBLE
56179: EQUAL
56180: IFTRUE 56184
56182: GO 56210
56184: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56185: LD_ADDR_VAR 0 3
56189: PUSH
56190: LD_INT 2
56192: PUSH
56193: LD_INT 3
56195: PUSH
56196: LD_INT 4
56198: PUSH
56199: LD_INT 5
56201: PUSH
56202: EMPTY
56203: LIST
56204: LIST
56205: LIST
56206: LIST
56207: ST_TO_ADDR
56208: GO 57033
56210: LD_INT 9
56212: DOUBLE
56213: EQUAL
56214: IFTRUE 56218
56216: GO 56244
56218: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56219: LD_ADDR_VAR 0 3
56223: PUSH
56224: LD_INT 2
56226: PUSH
56227: LD_INT 3
56229: PUSH
56230: LD_INT 4
56232: PUSH
56233: LD_INT 5
56235: PUSH
56236: EMPTY
56237: LIST
56238: LIST
56239: LIST
56240: LIST
56241: ST_TO_ADDR
56242: GO 57033
56244: LD_INT 7
56246: DOUBLE
56247: EQUAL
56248: IFTRUE 56252
56250: GO 56278
56252: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56253: LD_ADDR_VAR 0 3
56257: PUSH
56258: LD_INT 2
56260: PUSH
56261: LD_INT 3
56263: PUSH
56264: LD_INT 4
56266: PUSH
56267: LD_INT 5
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: LIST
56274: LIST
56275: ST_TO_ADDR
56276: GO 57033
56278: LD_INT 12
56280: DOUBLE
56281: EQUAL
56282: IFTRUE 56286
56284: GO 56312
56286: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56287: LD_ADDR_VAR 0 3
56291: PUSH
56292: LD_INT 2
56294: PUSH
56295: LD_INT 3
56297: PUSH
56298: LD_INT 4
56300: PUSH
56301: LD_INT 5
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: LIST
56308: LIST
56309: ST_TO_ADDR
56310: GO 57033
56312: LD_INT 13
56314: DOUBLE
56315: EQUAL
56316: IFTRUE 56320
56318: GO 56346
56320: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56321: LD_ADDR_VAR 0 3
56325: PUSH
56326: LD_INT 2
56328: PUSH
56329: LD_INT 3
56331: PUSH
56332: LD_INT 4
56334: PUSH
56335: LD_INT 5
56337: PUSH
56338: EMPTY
56339: LIST
56340: LIST
56341: LIST
56342: LIST
56343: ST_TO_ADDR
56344: GO 57033
56346: LD_INT 14
56348: DOUBLE
56349: EQUAL
56350: IFTRUE 56354
56352: GO 56372
56354: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56355: LD_ADDR_VAR 0 3
56359: PUSH
56360: LD_INT 4
56362: PUSH
56363: LD_INT 5
56365: PUSH
56366: EMPTY
56367: LIST
56368: LIST
56369: ST_TO_ADDR
56370: GO 57033
56372: LD_INT 6
56374: DOUBLE
56375: EQUAL
56376: IFTRUE 56380
56378: GO 56398
56380: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56381: LD_ADDR_VAR 0 3
56385: PUSH
56386: LD_INT 4
56388: PUSH
56389: LD_INT 5
56391: PUSH
56392: EMPTY
56393: LIST
56394: LIST
56395: ST_TO_ADDR
56396: GO 57033
56398: LD_INT 10
56400: DOUBLE
56401: EQUAL
56402: IFTRUE 56406
56404: GO 56424
56406: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56407: LD_ADDR_VAR 0 3
56411: PUSH
56412: LD_INT 4
56414: PUSH
56415: LD_INT 5
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: ST_TO_ADDR
56422: GO 57033
56424: LD_INT 22
56426: DOUBLE
56427: EQUAL
56428: IFTRUE 56432
56430: GO 56458
56432: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56433: LD_ADDR_VAR 0 3
56437: PUSH
56438: LD_INT 11
56440: PUSH
56441: LD_INT 12
56443: PUSH
56444: LD_INT 13
56446: PUSH
56447: LD_INT 14
56449: PUSH
56450: EMPTY
56451: LIST
56452: LIST
56453: LIST
56454: LIST
56455: ST_TO_ADDR
56456: GO 57033
56458: LD_INT 23
56460: DOUBLE
56461: EQUAL
56462: IFTRUE 56466
56464: GO 56492
56466: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56467: LD_ADDR_VAR 0 3
56471: PUSH
56472: LD_INT 11
56474: PUSH
56475: LD_INT 12
56477: PUSH
56478: LD_INT 13
56480: PUSH
56481: LD_INT 14
56483: PUSH
56484: EMPTY
56485: LIST
56486: LIST
56487: LIST
56488: LIST
56489: ST_TO_ADDR
56490: GO 57033
56492: LD_INT 24
56494: DOUBLE
56495: EQUAL
56496: IFTRUE 56500
56498: GO 56526
56500: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56501: LD_ADDR_VAR 0 3
56505: PUSH
56506: LD_INT 11
56508: PUSH
56509: LD_INT 12
56511: PUSH
56512: LD_INT 13
56514: PUSH
56515: LD_INT 14
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: LIST
56522: LIST
56523: ST_TO_ADDR
56524: GO 57033
56526: LD_INT 30
56528: DOUBLE
56529: EQUAL
56530: IFTRUE 56534
56532: GO 56560
56534: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56535: LD_ADDR_VAR 0 3
56539: PUSH
56540: LD_INT 11
56542: PUSH
56543: LD_INT 12
56545: PUSH
56546: LD_INT 13
56548: PUSH
56549: LD_INT 14
56551: PUSH
56552: EMPTY
56553: LIST
56554: LIST
56555: LIST
56556: LIST
56557: ST_TO_ADDR
56558: GO 57033
56560: LD_INT 25
56562: DOUBLE
56563: EQUAL
56564: IFTRUE 56568
56566: GO 56586
56568: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56569: LD_ADDR_VAR 0 3
56573: PUSH
56574: LD_INT 13
56576: PUSH
56577: LD_INT 14
56579: PUSH
56580: EMPTY
56581: LIST
56582: LIST
56583: ST_TO_ADDR
56584: GO 57033
56586: LD_INT 27
56588: DOUBLE
56589: EQUAL
56590: IFTRUE 56594
56592: GO 56612
56594: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56595: LD_ADDR_VAR 0 3
56599: PUSH
56600: LD_INT 13
56602: PUSH
56603: LD_INT 14
56605: PUSH
56606: EMPTY
56607: LIST
56608: LIST
56609: ST_TO_ADDR
56610: GO 57033
56612: LD_INT 28
56614: DOUBLE
56615: EQUAL
56616: IFTRUE 56620
56618: GO 56638
56620: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56621: LD_ADDR_VAR 0 3
56625: PUSH
56626: LD_INT 13
56628: PUSH
56629: LD_INT 14
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: ST_TO_ADDR
56636: GO 57033
56638: LD_INT 29
56640: DOUBLE
56641: EQUAL
56642: IFTRUE 56646
56644: GO 56664
56646: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56647: LD_ADDR_VAR 0 3
56651: PUSH
56652: LD_INT 13
56654: PUSH
56655: LD_INT 14
56657: PUSH
56658: EMPTY
56659: LIST
56660: LIST
56661: ST_TO_ADDR
56662: GO 57033
56664: LD_INT 31
56666: DOUBLE
56667: EQUAL
56668: IFTRUE 56672
56670: GO 56690
56672: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56673: LD_ADDR_VAR 0 3
56677: PUSH
56678: LD_INT 13
56680: PUSH
56681: LD_INT 14
56683: PUSH
56684: EMPTY
56685: LIST
56686: LIST
56687: ST_TO_ADDR
56688: GO 57033
56690: LD_INT 26
56692: DOUBLE
56693: EQUAL
56694: IFTRUE 56698
56696: GO 56716
56698: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56699: LD_ADDR_VAR 0 3
56703: PUSH
56704: LD_INT 13
56706: PUSH
56707: LD_INT 14
56709: PUSH
56710: EMPTY
56711: LIST
56712: LIST
56713: ST_TO_ADDR
56714: GO 57033
56716: LD_INT 42
56718: DOUBLE
56719: EQUAL
56720: IFTRUE 56724
56722: GO 56750
56724: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56725: LD_ADDR_VAR 0 3
56729: PUSH
56730: LD_INT 21
56732: PUSH
56733: LD_INT 22
56735: PUSH
56736: LD_INT 23
56738: PUSH
56739: LD_INT 24
56741: PUSH
56742: EMPTY
56743: LIST
56744: LIST
56745: LIST
56746: LIST
56747: ST_TO_ADDR
56748: GO 57033
56750: LD_INT 43
56752: DOUBLE
56753: EQUAL
56754: IFTRUE 56758
56756: GO 56784
56758: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56759: LD_ADDR_VAR 0 3
56763: PUSH
56764: LD_INT 21
56766: PUSH
56767: LD_INT 22
56769: PUSH
56770: LD_INT 23
56772: PUSH
56773: LD_INT 24
56775: PUSH
56776: EMPTY
56777: LIST
56778: LIST
56779: LIST
56780: LIST
56781: ST_TO_ADDR
56782: GO 57033
56784: LD_INT 44
56786: DOUBLE
56787: EQUAL
56788: IFTRUE 56792
56790: GO 56818
56792: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56793: LD_ADDR_VAR 0 3
56797: PUSH
56798: LD_INT 21
56800: PUSH
56801: LD_INT 22
56803: PUSH
56804: LD_INT 23
56806: PUSH
56807: LD_INT 24
56809: PUSH
56810: EMPTY
56811: LIST
56812: LIST
56813: LIST
56814: LIST
56815: ST_TO_ADDR
56816: GO 57033
56818: LD_INT 45
56820: DOUBLE
56821: EQUAL
56822: IFTRUE 56826
56824: GO 56852
56826: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56827: LD_ADDR_VAR 0 3
56831: PUSH
56832: LD_INT 21
56834: PUSH
56835: LD_INT 22
56837: PUSH
56838: LD_INT 23
56840: PUSH
56841: LD_INT 24
56843: PUSH
56844: EMPTY
56845: LIST
56846: LIST
56847: LIST
56848: LIST
56849: ST_TO_ADDR
56850: GO 57033
56852: LD_INT 49
56854: DOUBLE
56855: EQUAL
56856: IFTRUE 56860
56858: GO 56886
56860: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56861: LD_ADDR_VAR 0 3
56865: PUSH
56866: LD_INT 21
56868: PUSH
56869: LD_INT 22
56871: PUSH
56872: LD_INT 23
56874: PUSH
56875: LD_INT 24
56877: PUSH
56878: EMPTY
56879: LIST
56880: LIST
56881: LIST
56882: LIST
56883: ST_TO_ADDR
56884: GO 57033
56886: LD_INT 51
56888: DOUBLE
56889: EQUAL
56890: IFTRUE 56894
56892: GO 56920
56894: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56895: LD_ADDR_VAR 0 3
56899: PUSH
56900: LD_INT 21
56902: PUSH
56903: LD_INT 22
56905: PUSH
56906: LD_INT 23
56908: PUSH
56909: LD_INT 24
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: LIST
56916: LIST
56917: ST_TO_ADDR
56918: GO 57033
56920: LD_INT 52
56922: DOUBLE
56923: EQUAL
56924: IFTRUE 56928
56926: GO 56954
56928: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56929: LD_ADDR_VAR 0 3
56933: PUSH
56934: LD_INT 21
56936: PUSH
56937: LD_INT 22
56939: PUSH
56940: LD_INT 23
56942: PUSH
56943: LD_INT 24
56945: PUSH
56946: EMPTY
56947: LIST
56948: LIST
56949: LIST
56950: LIST
56951: ST_TO_ADDR
56952: GO 57033
56954: LD_INT 53
56956: DOUBLE
56957: EQUAL
56958: IFTRUE 56962
56960: GO 56980
56962: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56963: LD_ADDR_VAR 0 3
56967: PUSH
56968: LD_INT 23
56970: PUSH
56971: LD_INT 24
56973: PUSH
56974: EMPTY
56975: LIST
56976: LIST
56977: ST_TO_ADDR
56978: GO 57033
56980: LD_INT 46
56982: DOUBLE
56983: EQUAL
56984: IFTRUE 56988
56986: GO 57006
56988: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56989: LD_ADDR_VAR 0 3
56993: PUSH
56994: LD_INT 23
56996: PUSH
56997: LD_INT 24
56999: PUSH
57000: EMPTY
57001: LIST
57002: LIST
57003: ST_TO_ADDR
57004: GO 57033
57006: LD_INT 47
57008: DOUBLE
57009: EQUAL
57010: IFTRUE 57014
57012: GO 57032
57014: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57015: LD_ADDR_VAR 0 3
57019: PUSH
57020: LD_INT 23
57022: PUSH
57023: LD_INT 24
57025: PUSH
57026: EMPTY
57027: LIST
57028: LIST
57029: ST_TO_ADDR
57030: GO 57033
57032: POP
// result := ( chassis in result ) ;
57033: LD_ADDR_VAR 0 3
57037: PUSH
57038: LD_VAR 0 1
57042: PUSH
57043: LD_VAR 0 3
57047: IN
57048: ST_TO_ADDR
// end ;
57049: LD_VAR 0 3
57053: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57054: LD_INT 0
57056: PPUSH
57057: PPUSH
57058: PPUSH
57059: PPUSH
57060: PPUSH
57061: PPUSH
57062: PPUSH
// result := array ;
57063: LD_ADDR_VAR 0 5
57067: PUSH
57068: LD_VAR 0 1
57072: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57073: LD_VAR 0 1
57077: NOT
57078: PUSH
57079: LD_VAR 0 2
57083: NOT
57084: OR
57085: PUSH
57086: LD_VAR 0 3
57090: NOT
57091: OR
57092: PUSH
57093: LD_VAR 0 2
57097: PUSH
57098: LD_VAR 0 1
57102: GREATER
57103: OR
57104: PUSH
57105: LD_VAR 0 3
57109: PUSH
57110: LD_VAR 0 1
57114: GREATER
57115: OR
57116: IFFALSE 57120
// exit ;
57118: GO 57416
// if direction then
57120: LD_VAR 0 4
57124: IFFALSE 57188
// begin d := 1 ;
57126: LD_ADDR_VAR 0 9
57130: PUSH
57131: LD_INT 1
57133: ST_TO_ADDR
// if i_from > i_to then
57134: LD_VAR 0 2
57138: PUSH
57139: LD_VAR 0 3
57143: GREATER
57144: IFFALSE 57170
// length := ( array - i_from ) + i_to else
57146: LD_ADDR_VAR 0 11
57150: PUSH
57151: LD_VAR 0 1
57155: PUSH
57156: LD_VAR 0 2
57160: MINUS
57161: PUSH
57162: LD_VAR 0 3
57166: PLUS
57167: ST_TO_ADDR
57168: GO 57186
// length := i_to - i_from ;
57170: LD_ADDR_VAR 0 11
57174: PUSH
57175: LD_VAR 0 3
57179: PUSH
57180: LD_VAR 0 2
57184: MINUS
57185: ST_TO_ADDR
// end else
57186: GO 57249
// begin d := - 1 ;
57188: LD_ADDR_VAR 0 9
57192: PUSH
57193: LD_INT 1
57195: NEG
57196: ST_TO_ADDR
// if i_from > i_to then
57197: LD_VAR 0 2
57201: PUSH
57202: LD_VAR 0 3
57206: GREATER
57207: IFFALSE 57227
// length := i_from - i_to else
57209: LD_ADDR_VAR 0 11
57213: PUSH
57214: LD_VAR 0 2
57218: PUSH
57219: LD_VAR 0 3
57223: MINUS
57224: ST_TO_ADDR
57225: GO 57249
// length := ( array - i_to ) + i_from ;
57227: LD_ADDR_VAR 0 11
57231: PUSH
57232: LD_VAR 0 1
57236: PUSH
57237: LD_VAR 0 3
57241: MINUS
57242: PUSH
57243: LD_VAR 0 2
57247: PLUS
57248: ST_TO_ADDR
// end ; if not length then
57249: LD_VAR 0 11
57253: NOT
57254: IFFALSE 57258
// exit ;
57256: GO 57416
// tmp := array ;
57258: LD_ADDR_VAR 0 10
57262: PUSH
57263: LD_VAR 0 1
57267: ST_TO_ADDR
// for i = 1 to length do
57268: LD_ADDR_VAR 0 6
57272: PUSH
57273: DOUBLE
57274: LD_INT 1
57276: DEC
57277: ST_TO_ADDR
57278: LD_VAR 0 11
57282: PUSH
57283: FOR_TO
57284: IFFALSE 57404
// begin for j = 1 to array do
57286: LD_ADDR_VAR 0 7
57290: PUSH
57291: DOUBLE
57292: LD_INT 1
57294: DEC
57295: ST_TO_ADDR
57296: LD_VAR 0 1
57300: PUSH
57301: FOR_TO
57302: IFFALSE 57390
// begin k := j + d ;
57304: LD_ADDR_VAR 0 8
57308: PUSH
57309: LD_VAR 0 7
57313: PUSH
57314: LD_VAR 0 9
57318: PLUS
57319: ST_TO_ADDR
// if k > array then
57320: LD_VAR 0 8
57324: PUSH
57325: LD_VAR 0 1
57329: GREATER
57330: IFFALSE 57340
// k := 1 ;
57332: LD_ADDR_VAR 0 8
57336: PUSH
57337: LD_INT 1
57339: ST_TO_ADDR
// if not k then
57340: LD_VAR 0 8
57344: NOT
57345: IFFALSE 57357
// k := array ;
57347: LD_ADDR_VAR 0 8
57351: PUSH
57352: LD_VAR 0 1
57356: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57357: LD_ADDR_VAR 0 10
57361: PUSH
57362: LD_VAR 0 10
57366: PPUSH
57367: LD_VAR 0 8
57371: PPUSH
57372: LD_VAR 0 1
57376: PUSH
57377: LD_VAR 0 7
57381: ARRAY
57382: PPUSH
57383: CALL_OW 1
57387: ST_TO_ADDR
// end ;
57388: GO 57301
57390: POP
57391: POP
// array := tmp ;
57392: LD_ADDR_VAR 0 1
57396: PUSH
57397: LD_VAR 0 10
57401: ST_TO_ADDR
// end ;
57402: GO 57283
57404: POP
57405: POP
// result := array ;
57406: LD_ADDR_VAR 0 5
57410: PUSH
57411: LD_VAR 0 1
57415: ST_TO_ADDR
// end ;
57416: LD_VAR 0 5
57420: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57421: LD_INT 0
57423: PPUSH
57424: PPUSH
// result := 0 ;
57425: LD_ADDR_VAR 0 3
57429: PUSH
57430: LD_INT 0
57432: ST_TO_ADDR
// if not array or not value in array then
57433: LD_VAR 0 1
57437: NOT
57438: PUSH
57439: LD_VAR 0 2
57443: PUSH
57444: LD_VAR 0 1
57448: IN
57449: NOT
57450: OR
57451: IFFALSE 57455
// exit ;
57453: GO 57509
// for i = 1 to array do
57455: LD_ADDR_VAR 0 4
57459: PUSH
57460: DOUBLE
57461: LD_INT 1
57463: DEC
57464: ST_TO_ADDR
57465: LD_VAR 0 1
57469: PUSH
57470: FOR_TO
57471: IFFALSE 57507
// if value = array [ i ] then
57473: LD_VAR 0 2
57477: PUSH
57478: LD_VAR 0 1
57482: PUSH
57483: LD_VAR 0 4
57487: ARRAY
57488: EQUAL
57489: IFFALSE 57505
// begin result := i ;
57491: LD_ADDR_VAR 0 3
57495: PUSH
57496: LD_VAR 0 4
57500: ST_TO_ADDR
// exit ;
57501: POP
57502: POP
57503: GO 57509
// end ;
57505: GO 57470
57507: POP
57508: POP
// end ;
57509: LD_VAR 0 3
57513: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57514: LD_INT 0
57516: PPUSH
// vc_chassis := chassis ;
57517: LD_ADDR_OWVAR 37
57521: PUSH
57522: LD_VAR 0 1
57526: ST_TO_ADDR
// vc_engine := engine ;
57527: LD_ADDR_OWVAR 39
57531: PUSH
57532: LD_VAR 0 2
57536: ST_TO_ADDR
// vc_control := control ;
57537: LD_ADDR_OWVAR 38
57541: PUSH
57542: LD_VAR 0 3
57546: ST_TO_ADDR
// vc_weapon := weapon ;
57547: LD_ADDR_OWVAR 40
57551: PUSH
57552: LD_VAR 0 4
57556: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57557: LD_ADDR_OWVAR 41
57561: PUSH
57562: LD_VAR 0 5
57566: ST_TO_ADDR
// end ;
57567: LD_VAR 0 6
57571: RET
// export function WantPlant ( unit ) ; var task ; begin
57572: LD_INT 0
57574: PPUSH
57575: PPUSH
// result := false ;
57576: LD_ADDR_VAR 0 2
57580: PUSH
57581: LD_INT 0
57583: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57584: LD_ADDR_VAR 0 3
57588: PUSH
57589: LD_VAR 0 1
57593: PPUSH
57594: CALL_OW 437
57598: ST_TO_ADDR
// if task then
57599: LD_VAR 0 3
57603: IFFALSE 57631
// if task [ 1 ] [ 1 ] = p then
57605: LD_VAR 0 3
57609: PUSH
57610: LD_INT 1
57612: ARRAY
57613: PUSH
57614: LD_INT 1
57616: ARRAY
57617: PUSH
57618: LD_STRING p
57620: EQUAL
57621: IFFALSE 57631
// result := true ;
57623: LD_ADDR_VAR 0 2
57627: PUSH
57628: LD_INT 1
57630: ST_TO_ADDR
// end ;
57631: LD_VAR 0 2
57635: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57636: LD_INT 0
57638: PPUSH
57639: PPUSH
57640: PPUSH
57641: PPUSH
// if pos < 1 then
57642: LD_VAR 0 2
57646: PUSH
57647: LD_INT 1
57649: LESS
57650: IFFALSE 57654
// exit ;
57652: GO 57957
// if pos = 1 then
57654: LD_VAR 0 2
57658: PUSH
57659: LD_INT 1
57661: EQUAL
57662: IFFALSE 57695
// result := Replace ( arr , pos [ 1 ] , value ) else
57664: LD_ADDR_VAR 0 4
57668: PUSH
57669: LD_VAR 0 1
57673: PPUSH
57674: LD_VAR 0 2
57678: PUSH
57679: LD_INT 1
57681: ARRAY
57682: PPUSH
57683: LD_VAR 0 3
57687: PPUSH
57688: CALL_OW 1
57692: ST_TO_ADDR
57693: GO 57957
// begin tmp := arr ;
57695: LD_ADDR_VAR 0 6
57699: PUSH
57700: LD_VAR 0 1
57704: ST_TO_ADDR
// s_arr := [ tmp ] ;
57705: LD_ADDR_VAR 0 7
57709: PUSH
57710: LD_VAR 0 6
57714: PUSH
57715: EMPTY
57716: LIST
57717: ST_TO_ADDR
// for i = 1 to pos - 1 do
57718: LD_ADDR_VAR 0 5
57722: PUSH
57723: DOUBLE
57724: LD_INT 1
57726: DEC
57727: ST_TO_ADDR
57728: LD_VAR 0 2
57732: PUSH
57733: LD_INT 1
57735: MINUS
57736: PUSH
57737: FOR_TO
57738: IFFALSE 57783
// begin tmp := tmp [ pos [ i ] ] ;
57740: LD_ADDR_VAR 0 6
57744: PUSH
57745: LD_VAR 0 6
57749: PUSH
57750: LD_VAR 0 2
57754: PUSH
57755: LD_VAR 0 5
57759: ARRAY
57760: ARRAY
57761: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57762: LD_ADDR_VAR 0 7
57766: PUSH
57767: LD_VAR 0 7
57771: PUSH
57772: LD_VAR 0 6
57776: PUSH
57777: EMPTY
57778: LIST
57779: ADD
57780: ST_TO_ADDR
// end ;
57781: GO 57737
57783: POP
57784: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57785: LD_ADDR_VAR 0 6
57789: PUSH
57790: LD_VAR 0 6
57794: PPUSH
57795: LD_VAR 0 2
57799: PUSH
57800: LD_VAR 0 2
57804: ARRAY
57805: PPUSH
57806: LD_VAR 0 3
57810: PPUSH
57811: CALL_OW 1
57815: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57816: LD_ADDR_VAR 0 7
57820: PUSH
57821: LD_VAR 0 7
57825: PPUSH
57826: LD_VAR 0 7
57830: PPUSH
57831: LD_VAR 0 6
57835: PPUSH
57836: CALL_OW 1
57840: ST_TO_ADDR
// for i = s_arr downto 2 do
57841: LD_ADDR_VAR 0 5
57845: PUSH
57846: DOUBLE
57847: LD_VAR 0 7
57851: INC
57852: ST_TO_ADDR
57853: LD_INT 2
57855: PUSH
57856: FOR_DOWNTO
57857: IFFALSE 57941
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57859: LD_ADDR_VAR 0 6
57863: PUSH
57864: LD_VAR 0 7
57868: PUSH
57869: LD_VAR 0 5
57873: PUSH
57874: LD_INT 1
57876: MINUS
57877: ARRAY
57878: PPUSH
57879: LD_VAR 0 2
57883: PUSH
57884: LD_VAR 0 5
57888: PUSH
57889: LD_INT 1
57891: MINUS
57892: ARRAY
57893: PPUSH
57894: LD_VAR 0 7
57898: PUSH
57899: LD_VAR 0 5
57903: ARRAY
57904: PPUSH
57905: CALL_OW 1
57909: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57910: LD_ADDR_VAR 0 7
57914: PUSH
57915: LD_VAR 0 7
57919: PPUSH
57920: LD_VAR 0 5
57924: PUSH
57925: LD_INT 1
57927: MINUS
57928: PPUSH
57929: LD_VAR 0 6
57933: PPUSH
57934: CALL_OW 1
57938: ST_TO_ADDR
// end ;
57939: GO 57856
57941: POP
57942: POP
// result := s_arr [ 1 ] ;
57943: LD_ADDR_VAR 0 4
57947: PUSH
57948: LD_VAR 0 7
57952: PUSH
57953: LD_INT 1
57955: ARRAY
57956: ST_TO_ADDR
// end ; end ;
57957: LD_VAR 0 4
57961: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57962: LD_INT 0
57964: PPUSH
57965: PPUSH
// if not list then
57966: LD_VAR 0 1
57970: NOT
57971: IFFALSE 57975
// exit ;
57973: GO 58066
// i := list [ pos1 ] ;
57975: LD_ADDR_VAR 0 5
57979: PUSH
57980: LD_VAR 0 1
57984: PUSH
57985: LD_VAR 0 2
57989: ARRAY
57990: ST_TO_ADDR
// if not i then
57991: LD_VAR 0 5
57995: NOT
57996: IFFALSE 58000
// exit ;
57998: GO 58066
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58000: LD_ADDR_VAR 0 1
58004: PUSH
58005: LD_VAR 0 1
58009: PPUSH
58010: LD_VAR 0 2
58014: PPUSH
58015: LD_VAR 0 1
58019: PUSH
58020: LD_VAR 0 3
58024: ARRAY
58025: PPUSH
58026: CALL_OW 1
58030: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58031: LD_ADDR_VAR 0 1
58035: PUSH
58036: LD_VAR 0 1
58040: PPUSH
58041: LD_VAR 0 3
58045: PPUSH
58046: LD_VAR 0 5
58050: PPUSH
58051: CALL_OW 1
58055: ST_TO_ADDR
// result := list ;
58056: LD_ADDR_VAR 0 4
58060: PUSH
58061: LD_VAR 0 1
58065: ST_TO_ADDR
// end ;
58066: LD_VAR 0 4
58070: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58071: LD_INT 0
58073: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58074: LD_ADDR_VAR 0 5
58078: PUSH
58079: LD_VAR 0 1
58083: PPUSH
58084: CALL_OW 250
58088: PPUSH
58089: LD_VAR 0 1
58093: PPUSH
58094: CALL_OW 251
58098: PPUSH
58099: LD_VAR 0 2
58103: PPUSH
58104: LD_VAR 0 3
58108: PPUSH
58109: LD_VAR 0 4
58113: PPUSH
58114: CALL 58124 0 5
58118: ST_TO_ADDR
// end ;
58119: LD_VAR 0 5
58123: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58124: LD_INT 0
58126: PPUSH
58127: PPUSH
58128: PPUSH
58129: PPUSH
// if not list then
58130: LD_VAR 0 3
58134: NOT
58135: IFFALSE 58139
// exit ;
58137: GO 58527
// result := [ ] ;
58139: LD_ADDR_VAR 0 6
58143: PUSH
58144: EMPTY
58145: ST_TO_ADDR
// for i in list do
58146: LD_ADDR_VAR 0 7
58150: PUSH
58151: LD_VAR 0 3
58155: PUSH
58156: FOR_IN
58157: IFFALSE 58359
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58159: LD_ADDR_VAR 0 9
58163: PUSH
58164: LD_VAR 0 7
58168: PPUSH
58169: LD_VAR 0 1
58173: PPUSH
58174: LD_VAR 0 2
58178: PPUSH
58179: CALL_OW 297
58183: ST_TO_ADDR
// if not result then
58184: LD_VAR 0 6
58188: NOT
58189: IFFALSE 58215
// result := [ [ i , tmp ] ] else
58191: LD_ADDR_VAR 0 6
58195: PUSH
58196: LD_VAR 0 7
58200: PUSH
58201: LD_VAR 0 9
58205: PUSH
58206: EMPTY
58207: LIST
58208: LIST
58209: PUSH
58210: EMPTY
58211: LIST
58212: ST_TO_ADDR
58213: GO 58357
// begin if result [ result ] [ 2 ] < tmp then
58215: LD_VAR 0 6
58219: PUSH
58220: LD_VAR 0 6
58224: ARRAY
58225: PUSH
58226: LD_INT 2
58228: ARRAY
58229: PUSH
58230: LD_VAR 0 9
58234: LESS
58235: IFFALSE 58277
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58237: LD_ADDR_VAR 0 6
58241: PUSH
58242: LD_VAR 0 6
58246: PPUSH
58247: LD_VAR 0 6
58251: PUSH
58252: LD_INT 1
58254: PLUS
58255: PPUSH
58256: LD_VAR 0 7
58260: PUSH
58261: LD_VAR 0 9
58265: PUSH
58266: EMPTY
58267: LIST
58268: LIST
58269: PPUSH
58270: CALL_OW 2
58274: ST_TO_ADDR
58275: GO 58357
// for j = 1 to result do
58277: LD_ADDR_VAR 0 8
58281: PUSH
58282: DOUBLE
58283: LD_INT 1
58285: DEC
58286: ST_TO_ADDR
58287: LD_VAR 0 6
58291: PUSH
58292: FOR_TO
58293: IFFALSE 58355
// begin if tmp < result [ j ] [ 2 ] then
58295: LD_VAR 0 9
58299: PUSH
58300: LD_VAR 0 6
58304: PUSH
58305: LD_VAR 0 8
58309: ARRAY
58310: PUSH
58311: LD_INT 2
58313: ARRAY
58314: LESS
58315: IFFALSE 58353
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58317: LD_ADDR_VAR 0 6
58321: PUSH
58322: LD_VAR 0 6
58326: PPUSH
58327: LD_VAR 0 8
58331: PPUSH
58332: LD_VAR 0 7
58336: PUSH
58337: LD_VAR 0 9
58341: PUSH
58342: EMPTY
58343: LIST
58344: LIST
58345: PPUSH
58346: CALL_OW 2
58350: ST_TO_ADDR
// break ;
58351: GO 58355
// end ; end ;
58353: GO 58292
58355: POP
58356: POP
// end ; end ;
58357: GO 58156
58359: POP
58360: POP
// if result and not asc then
58361: LD_VAR 0 6
58365: PUSH
58366: LD_VAR 0 4
58370: NOT
58371: AND
58372: IFFALSE 58447
// begin tmp := result ;
58374: LD_ADDR_VAR 0 9
58378: PUSH
58379: LD_VAR 0 6
58383: ST_TO_ADDR
// for i = tmp downto 1 do
58384: LD_ADDR_VAR 0 7
58388: PUSH
58389: DOUBLE
58390: LD_VAR 0 9
58394: INC
58395: ST_TO_ADDR
58396: LD_INT 1
58398: PUSH
58399: FOR_DOWNTO
58400: IFFALSE 58445
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58402: LD_ADDR_VAR 0 6
58406: PUSH
58407: LD_VAR 0 6
58411: PPUSH
58412: LD_VAR 0 9
58416: PUSH
58417: LD_VAR 0 7
58421: MINUS
58422: PUSH
58423: LD_INT 1
58425: PLUS
58426: PPUSH
58427: LD_VAR 0 9
58431: PUSH
58432: LD_VAR 0 7
58436: ARRAY
58437: PPUSH
58438: CALL_OW 1
58442: ST_TO_ADDR
58443: GO 58399
58445: POP
58446: POP
// end ; tmp := [ ] ;
58447: LD_ADDR_VAR 0 9
58451: PUSH
58452: EMPTY
58453: ST_TO_ADDR
// if mode then
58454: LD_VAR 0 5
58458: IFFALSE 58527
// begin for i = 1 to result do
58460: LD_ADDR_VAR 0 7
58464: PUSH
58465: DOUBLE
58466: LD_INT 1
58468: DEC
58469: ST_TO_ADDR
58470: LD_VAR 0 6
58474: PUSH
58475: FOR_TO
58476: IFFALSE 58515
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58478: LD_ADDR_VAR 0 9
58482: PUSH
58483: LD_VAR 0 9
58487: PPUSH
58488: LD_VAR 0 7
58492: PPUSH
58493: LD_VAR 0 6
58497: PUSH
58498: LD_VAR 0 7
58502: ARRAY
58503: PUSH
58504: LD_INT 1
58506: ARRAY
58507: PPUSH
58508: CALL_OW 1
58512: ST_TO_ADDR
58513: GO 58475
58515: POP
58516: POP
// result := tmp ;
58517: LD_ADDR_VAR 0 6
58521: PUSH
58522: LD_VAR 0 9
58526: ST_TO_ADDR
// end ; end ;
58527: LD_VAR 0 6
58531: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58532: LD_INT 0
58534: PPUSH
58535: PPUSH
58536: PPUSH
58537: PPUSH
58538: PPUSH
58539: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58540: LD_ADDR_VAR 0 5
58544: PUSH
58545: LD_INT 0
58547: PUSH
58548: LD_INT 0
58550: PUSH
58551: LD_INT 0
58553: PUSH
58554: EMPTY
58555: PUSH
58556: EMPTY
58557: LIST
58558: LIST
58559: LIST
58560: LIST
58561: ST_TO_ADDR
// if not x or not y then
58562: LD_VAR 0 2
58566: NOT
58567: PUSH
58568: LD_VAR 0 3
58572: NOT
58573: OR
58574: IFFALSE 58578
// exit ;
58576: GO 60224
// if not range then
58578: LD_VAR 0 4
58582: NOT
58583: IFFALSE 58593
// range := 10 ;
58585: LD_ADDR_VAR 0 4
58589: PUSH
58590: LD_INT 10
58592: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58593: LD_ADDR_VAR 0 8
58597: PUSH
58598: LD_INT 81
58600: PUSH
58601: LD_VAR 0 1
58605: PUSH
58606: EMPTY
58607: LIST
58608: LIST
58609: PUSH
58610: LD_INT 92
58612: PUSH
58613: LD_VAR 0 2
58617: PUSH
58618: LD_VAR 0 3
58622: PUSH
58623: LD_VAR 0 4
58627: PUSH
58628: EMPTY
58629: LIST
58630: LIST
58631: LIST
58632: LIST
58633: PUSH
58634: LD_INT 3
58636: PUSH
58637: LD_INT 21
58639: PUSH
58640: LD_INT 3
58642: PUSH
58643: EMPTY
58644: LIST
58645: LIST
58646: PUSH
58647: EMPTY
58648: LIST
58649: LIST
58650: PUSH
58651: EMPTY
58652: LIST
58653: LIST
58654: LIST
58655: PPUSH
58656: CALL_OW 69
58660: ST_TO_ADDR
// if not tmp then
58661: LD_VAR 0 8
58665: NOT
58666: IFFALSE 58670
// exit ;
58668: GO 60224
// for i in tmp do
58670: LD_ADDR_VAR 0 6
58674: PUSH
58675: LD_VAR 0 8
58679: PUSH
58680: FOR_IN
58681: IFFALSE 60199
// begin points := [ 0 , 0 , 0 ] ;
58683: LD_ADDR_VAR 0 9
58687: PUSH
58688: LD_INT 0
58690: PUSH
58691: LD_INT 0
58693: PUSH
58694: LD_INT 0
58696: PUSH
58697: EMPTY
58698: LIST
58699: LIST
58700: LIST
58701: ST_TO_ADDR
// bpoints := 1 ;
58702: LD_ADDR_VAR 0 10
58706: PUSH
58707: LD_INT 1
58709: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58710: LD_VAR 0 6
58714: PPUSH
58715: CALL_OW 247
58719: PUSH
58720: LD_INT 1
58722: DOUBLE
58723: EQUAL
58724: IFTRUE 58728
58726: GO 59306
58728: POP
// begin if GetClass ( i ) = 1 then
58729: LD_VAR 0 6
58733: PPUSH
58734: CALL_OW 257
58738: PUSH
58739: LD_INT 1
58741: EQUAL
58742: IFFALSE 58763
// points := [ 10 , 5 , 3 ] ;
58744: LD_ADDR_VAR 0 9
58748: PUSH
58749: LD_INT 10
58751: PUSH
58752: LD_INT 5
58754: PUSH
58755: LD_INT 3
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: LIST
58762: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58763: LD_VAR 0 6
58767: PPUSH
58768: CALL_OW 257
58772: PUSH
58773: LD_INT 2
58775: PUSH
58776: LD_INT 3
58778: PUSH
58779: LD_INT 4
58781: PUSH
58782: EMPTY
58783: LIST
58784: LIST
58785: LIST
58786: IN
58787: IFFALSE 58808
// points := [ 3 , 2 , 1 ] ;
58789: LD_ADDR_VAR 0 9
58793: PUSH
58794: LD_INT 3
58796: PUSH
58797: LD_INT 2
58799: PUSH
58800: LD_INT 1
58802: PUSH
58803: EMPTY
58804: LIST
58805: LIST
58806: LIST
58807: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58808: LD_VAR 0 6
58812: PPUSH
58813: CALL_OW 257
58817: PUSH
58818: LD_INT 5
58820: EQUAL
58821: IFFALSE 58842
// points := [ 130 , 5 , 2 ] ;
58823: LD_ADDR_VAR 0 9
58827: PUSH
58828: LD_INT 130
58830: PUSH
58831: LD_INT 5
58833: PUSH
58834: LD_INT 2
58836: PUSH
58837: EMPTY
58838: LIST
58839: LIST
58840: LIST
58841: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58842: LD_VAR 0 6
58846: PPUSH
58847: CALL_OW 257
58851: PUSH
58852: LD_INT 8
58854: EQUAL
58855: IFFALSE 58876
// points := [ 35 , 35 , 30 ] ;
58857: LD_ADDR_VAR 0 9
58861: PUSH
58862: LD_INT 35
58864: PUSH
58865: LD_INT 35
58867: PUSH
58868: LD_INT 30
58870: PUSH
58871: EMPTY
58872: LIST
58873: LIST
58874: LIST
58875: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58876: LD_VAR 0 6
58880: PPUSH
58881: CALL_OW 257
58885: PUSH
58886: LD_INT 9
58888: EQUAL
58889: IFFALSE 58910
// points := [ 20 , 55 , 40 ] ;
58891: LD_ADDR_VAR 0 9
58895: PUSH
58896: LD_INT 20
58898: PUSH
58899: LD_INT 55
58901: PUSH
58902: LD_INT 40
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: LIST
58909: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58910: LD_VAR 0 6
58914: PPUSH
58915: CALL_OW 257
58919: PUSH
58920: LD_INT 12
58922: PUSH
58923: LD_INT 16
58925: PUSH
58926: EMPTY
58927: LIST
58928: LIST
58929: IN
58930: IFFALSE 58951
// points := [ 5 , 3 , 2 ] ;
58932: LD_ADDR_VAR 0 9
58936: PUSH
58937: LD_INT 5
58939: PUSH
58940: LD_INT 3
58942: PUSH
58943: LD_INT 2
58945: PUSH
58946: EMPTY
58947: LIST
58948: LIST
58949: LIST
58950: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58951: LD_VAR 0 6
58955: PPUSH
58956: CALL_OW 257
58960: PUSH
58961: LD_INT 17
58963: EQUAL
58964: IFFALSE 58985
// points := [ 100 , 50 , 75 ] ;
58966: LD_ADDR_VAR 0 9
58970: PUSH
58971: LD_INT 100
58973: PUSH
58974: LD_INT 50
58976: PUSH
58977: LD_INT 75
58979: PUSH
58980: EMPTY
58981: LIST
58982: LIST
58983: LIST
58984: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58985: LD_VAR 0 6
58989: PPUSH
58990: CALL_OW 257
58994: PUSH
58995: LD_INT 15
58997: EQUAL
58998: IFFALSE 59019
// points := [ 10 , 5 , 3 ] ;
59000: LD_ADDR_VAR 0 9
59004: PUSH
59005: LD_INT 10
59007: PUSH
59008: LD_INT 5
59010: PUSH
59011: LD_INT 3
59013: PUSH
59014: EMPTY
59015: LIST
59016: LIST
59017: LIST
59018: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59019: LD_VAR 0 6
59023: PPUSH
59024: CALL_OW 257
59028: PUSH
59029: LD_INT 14
59031: EQUAL
59032: IFFALSE 59053
// points := [ 10 , 0 , 0 ] ;
59034: LD_ADDR_VAR 0 9
59038: PUSH
59039: LD_INT 10
59041: PUSH
59042: LD_INT 0
59044: PUSH
59045: LD_INT 0
59047: PUSH
59048: EMPTY
59049: LIST
59050: LIST
59051: LIST
59052: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59053: LD_VAR 0 6
59057: PPUSH
59058: CALL_OW 257
59062: PUSH
59063: LD_INT 11
59065: EQUAL
59066: IFFALSE 59087
// points := [ 30 , 10 , 5 ] ;
59068: LD_ADDR_VAR 0 9
59072: PUSH
59073: LD_INT 30
59075: PUSH
59076: LD_INT 10
59078: PUSH
59079: LD_INT 5
59081: PUSH
59082: EMPTY
59083: LIST
59084: LIST
59085: LIST
59086: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59087: LD_VAR 0 1
59091: PPUSH
59092: LD_INT 5
59094: PPUSH
59095: CALL_OW 321
59099: PUSH
59100: LD_INT 2
59102: EQUAL
59103: IFFALSE 59120
// bpoints := bpoints * 1.8 ;
59105: LD_ADDR_VAR 0 10
59109: PUSH
59110: LD_VAR 0 10
59114: PUSH
59115: LD_REAL  1.80000000000000E+0000
59118: MUL
59119: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59120: LD_VAR 0 6
59124: PPUSH
59125: CALL_OW 257
59129: PUSH
59130: LD_INT 1
59132: PUSH
59133: LD_INT 2
59135: PUSH
59136: LD_INT 3
59138: PUSH
59139: LD_INT 4
59141: PUSH
59142: EMPTY
59143: LIST
59144: LIST
59145: LIST
59146: LIST
59147: IN
59148: PUSH
59149: LD_VAR 0 1
59153: PPUSH
59154: LD_INT 51
59156: PPUSH
59157: CALL_OW 321
59161: PUSH
59162: LD_INT 2
59164: EQUAL
59165: AND
59166: IFFALSE 59183
// bpoints := bpoints * 1.2 ;
59168: LD_ADDR_VAR 0 10
59172: PUSH
59173: LD_VAR 0 10
59177: PUSH
59178: LD_REAL  1.20000000000000E+0000
59181: MUL
59182: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59183: LD_VAR 0 6
59187: PPUSH
59188: CALL_OW 257
59192: PUSH
59193: LD_INT 5
59195: PUSH
59196: LD_INT 7
59198: PUSH
59199: LD_INT 9
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: LIST
59206: IN
59207: PUSH
59208: LD_VAR 0 1
59212: PPUSH
59213: LD_INT 52
59215: PPUSH
59216: CALL_OW 321
59220: PUSH
59221: LD_INT 2
59223: EQUAL
59224: AND
59225: IFFALSE 59242
// bpoints := bpoints * 1.5 ;
59227: LD_ADDR_VAR 0 10
59231: PUSH
59232: LD_VAR 0 10
59236: PUSH
59237: LD_REAL  1.50000000000000E+0000
59240: MUL
59241: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59242: LD_VAR 0 1
59246: PPUSH
59247: LD_INT 66
59249: PPUSH
59250: CALL_OW 321
59254: PUSH
59255: LD_INT 2
59257: EQUAL
59258: IFFALSE 59275
// bpoints := bpoints * 1.1 ;
59260: LD_ADDR_VAR 0 10
59264: PUSH
59265: LD_VAR 0 10
59269: PUSH
59270: LD_REAL  1.10000000000000E+0000
59273: MUL
59274: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59275: LD_ADDR_VAR 0 10
59279: PUSH
59280: LD_VAR 0 10
59284: PUSH
59285: LD_VAR 0 6
59289: PPUSH
59290: LD_INT 1
59292: PPUSH
59293: CALL_OW 259
59297: PUSH
59298: LD_REAL  1.15000000000000E+0000
59301: MUL
59302: MUL
59303: ST_TO_ADDR
// end ; unit_vehicle :
59304: GO 60128
59306: LD_INT 2
59308: DOUBLE
59309: EQUAL
59310: IFTRUE 59314
59312: GO 60116
59314: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59315: LD_VAR 0 6
59319: PPUSH
59320: CALL_OW 264
59324: PUSH
59325: LD_INT 2
59327: PUSH
59328: LD_INT 42
59330: PUSH
59331: LD_INT 24
59333: PUSH
59334: EMPTY
59335: LIST
59336: LIST
59337: LIST
59338: IN
59339: IFFALSE 59360
// points := [ 25 , 5 , 3 ] ;
59341: LD_ADDR_VAR 0 9
59345: PUSH
59346: LD_INT 25
59348: PUSH
59349: LD_INT 5
59351: PUSH
59352: LD_INT 3
59354: PUSH
59355: EMPTY
59356: LIST
59357: LIST
59358: LIST
59359: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59360: LD_VAR 0 6
59364: PPUSH
59365: CALL_OW 264
59369: PUSH
59370: LD_INT 4
59372: PUSH
59373: LD_INT 43
59375: PUSH
59376: LD_INT 25
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: IN
59384: IFFALSE 59405
// points := [ 40 , 15 , 5 ] ;
59386: LD_ADDR_VAR 0 9
59390: PUSH
59391: LD_INT 40
59393: PUSH
59394: LD_INT 15
59396: PUSH
59397: LD_INT 5
59399: PUSH
59400: EMPTY
59401: LIST
59402: LIST
59403: LIST
59404: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59405: LD_VAR 0 6
59409: PPUSH
59410: CALL_OW 264
59414: PUSH
59415: LD_INT 3
59417: PUSH
59418: LD_INT 23
59420: PUSH
59421: EMPTY
59422: LIST
59423: LIST
59424: IN
59425: IFFALSE 59446
// points := [ 7 , 25 , 8 ] ;
59427: LD_ADDR_VAR 0 9
59431: PUSH
59432: LD_INT 7
59434: PUSH
59435: LD_INT 25
59437: PUSH
59438: LD_INT 8
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: LIST
59445: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59446: LD_VAR 0 6
59450: PPUSH
59451: CALL_OW 264
59455: PUSH
59456: LD_INT 5
59458: PUSH
59459: LD_INT 27
59461: PUSH
59462: LD_INT 44
59464: PUSH
59465: EMPTY
59466: LIST
59467: LIST
59468: LIST
59469: IN
59470: IFFALSE 59491
// points := [ 14 , 50 , 16 ] ;
59472: LD_ADDR_VAR 0 9
59476: PUSH
59477: LD_INT 14
59479: PUSH
59480: LD_INT 50
59482: PUSH
59483: LD_INT 16
59485: PUSH
59486: EMPTY
59487: LIST
59488: LIST
59489: LIST
59490: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59491: LD_VAR 0 6
59495: PPUSH
59496: CALL_OW 264
59500: PUSH
59501: LD_INT 6
59503: PUSH
59504: LD_INT 46
59506: PUSH
59507: EMPTY
59508: LIST
59509: LIST
59510: IN
59511: IFFALSE 59532
// points := [ 32 , 120 , 70 ] ;
59513: LD_ADDR_VAR 0 9
59517: PUSH
59518: LD_INT 32
59520: PUSH
59521: LD_INT 120
59523: PUSH
59524: LD_INT 70
59526: PUSH
59527: EMPTY
59528: LIST
59529: LIST
59530: LIST
59531: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59532: LD_VAR 0 6
59536: PPUSH
59537: CALL_OW 264
59541: PUSH
59542: LD_INT 7
59544: PUSH
59545: LD_INT 28
59547: PUSH
59548: LD_INT 45
59550: PUSH
59551: EMPTY
59552: LIST
59553: LIST
59554: LIST
59555: IN
59556: IFFALSE 59577
// points := [ 35 , 20 , 45 ] ;
59558: LD_ADDR_VAR 0 9
59562: PUSH
59563: LD_INT 35
59565: PUSH
59566: LD_INT 20
59568: PUSH
59569: LD_INT 45
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: LIST
59576: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59577: LD_VAR 0 6
59581: PPUSH
59582: CALL_OW 264
59586: PUSH
59587: LD_INT 47
59589: PUSH
59590: EMPTY
59591: LIST
59592: IN
59593: IFFALSE 59614
// points := [ 67 , 45 , 75 ] ;
59595: LD_ADDR_VAR 0 9
59599: PUSH
59600: LD_INT 67
59602: PUSH
59603: LD_INT 45
59605: PUSH
59606: LD_INT 75
59608: PUSH
59609: EMPTY
59610: LIST
59611: LIST
59612: LIST
59613: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59614: LD_VAR 0 6
59618: PPUSH
59619: CALL_OW 264
59623: PUSH
59624: LD_INT 26
59626: PUSH
59627: EMPTY
59628: LIST
59629: IN
59630: IFFALSE 59651
// points := [ 120 , 30 , 80 ] ;
59632: LD_ADDR_VAR 0 9
59636: PUSH
59637: LD_INT 120
59639: PUSH
59640: LD_INT 30
59642: PUSH
59643: LD_INT 80
59645: PUSH
59646: EMPTY
59647: LIST
59648: LIST
59649: LIST
59650: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59651: LD_VAR 0 6
59655: PPUSH
59656: CALL_OW 264
59660: PUSH
59661: LD_INT 22
59663: PUSH
59664: EMPTY
59665: LIST
59666: IN
59667: IFFALSE 59688
// points := [ 40 , 1 , 1 ] ;
59669: LD_ADDR_VAR 0 9
59673: PUSH
59674: LD_INT 40
59676: PUSH
59677: LD_INT 1
59679: PUSH
59680: LD_INT 1
59682: PUSH
59683: EMPTY
59684: LIST
59685: LIST
59686: LIST
59687: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59688: LD_VAR 0 6
59692: PPUSH
59693: CALL_OW 264
59697: PUSH
59698: LD_INT 29
59700: PUSH
59701: EMPTY
59702: LIST
59703: IN
59704: IFFALSE 59725
// points := [ 70 , 200 , 400 ] ;
59706: LD_ADDR_VAR 0 9
59710: PUSH
59711: LD_INT 70
59713: PUSH
59714: LD_INT 200
59716: PUSH
59717: LD_INT 400
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: LIST
59724: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59725: LD_VAR 0 6
59729: PPUSH
59730: CALL_OW 264
59734: PUSH
59735: LD_INT 14
59737: PUSH
59738: LD_INT 53
59740: PUSH
59741: EMPTY
59742: LIST
59743: LIST
59744: IN
59745: IFFALSE 59766
// points := [ 40 , 10 , 20 ] ;
59747: LD_ADDR_VAR 0 9
59751: PUSH
59752: LD_INT 40
59754: PUSH
59755: LD_INT 10
59757: PUSH
59758: LD_INT 20
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: LIST
59765: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59766: LD_VAR 0 6
59770: PPUSH
59771: CALL_OW 264
59775: PUSH
59776: LD_INT 9
59778: PUSH
59779: EMPTY
59780: LIST
59781: IN
59782: IFFALSE 59803
// points := [ 5 , 70 , 20 ] ;
59784: LD_ADDR_VAR 0 9
59788: PUSH
59789: LD_INT 5
59791: PUSH
59792: LD_INT 70
59794: PUSH
59795: LD_INT 20
59797: PUSH
59798: EMPTY
59799: LIST
59800: LIST
59801: LIST
59802: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59803: LD_VAR 0 6
59807: PPUSH
59808: CALL_OW 264
59812: PUSH
59813: LD_INT 10
59815: PUSH
59816: EMPTY
59817: LIST
59818: IN
59819: IFFALSE 59840
// points := [ 35 , 110 , 70 ] ;
59821: LD_ADDR_VAR 0 9
59825: PUSH
59826: LD_INT 35
59828: PUSH
59829: LD_INT 110
59831: PUSH
59832: LD_INT 70
59834: PUSH
59835: EMPTY
59836: LIST
59837: LIST
59838: LIST
59839: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59840: LD_VAR 0 6
59844: PPUSH
59845: CALL_OW 265
59849: PUSH
59850: LD_INT 25
59852: EQUAL
59853: IFFALSE 59874
// points := [ 80 , 65 , 100 ] ;
59855: LD_ADDR_VAR 0 9
59859: PUSH
59860: LD_INT 80
59862: PUSH
59863: LD_INT 65
59865: PUSH
59866: LD_INT 100
59868: PUSH
59869: EMPTY
59870: LIST
59871: LIST
59872: LIST
59873: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59874: LD_VAR 0 6
59878: PPUSH
59879: CALL_OW 263
59883: PUSH
59884: LD_INT 1
59886: EQUAL
59887: IFFALSE 59922
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59889: LD_ADDR_VAR 0 10
59893: PUSH
59894: LD_VAR 0 10
59898: PUSH
59899: LD_VAR 0 6
59903: PPUSH
59904: CALL_OW 311
59908: PPUSH
59909: LD_INT 3
59911: PPUSH
59912: CALL_OW 259
59916: PUSH
59917: LD_INT 4
59919: MUL
59920: MUL
59921: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59922: LD_VAR 0 6
59926: PPUSH
59927: CALL_OW 263
59931: PUSH
59932: LD_INT 2
59934: EQUAL
59935: IFFALSE 59986
// begin j := IsControledBy ( i ) ;
59937: LD_ADDR_VAR 0 7
59941: PUSH
59942: LD_VAR 0 6
59946: PPUSH
59947: CALL_OW 312
59951: ST_TO_ADDR
// if j then
59952: LD_VAR 0 7
59956: IFFALSE 59986
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59958: LD_ADDR_VAR 0 10
59962: PUSH
59963: LD_VAR 0 10
59967: PUSH
59968: LD_VAR 0 7
59972: PPUSH
59973: LD_INT 3
59975: PPUSH
59976: CALL_OW 259
59980: PUSH
59981: LD_INT 3
59983: MUL
59984: MUL
59985: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59986: LD_VAR 0 6
59990: PPUSH
59991: CALL_OW 264
59995: PUSH
59996: LD_INT 5
59998: PUSH
59999: LD_INT 6
60001: PUSH
60002: LD_INT 46
60004: PUSH
60005: LD_INT 44
60007: PUSH
60008: LD_INT 47
60010: PUSH
60011: LD_INT 45
60013: PUSH
60014: LD_INT 28
60016: PUSH
60017: LD_INT 7
60019: PUSH
60020: LD_INT 27
60022: PUSH
60023: LD_INT 29
60025: PUSH
60026: EMPTY
60027: LIST
60028: LIST
60029: LIST
60030: LIST
60031: LIST
60032: LIST
60033: LIST
60034: LIST
60035: LIST
60036: LIST
60037: IN
60038: PUSH
60039: LD_VAR 0 1
60043: PPUSH
60044: LD_INT 52
60046: PPUSH
60047: CALL_OW 321
60051: PUSH
60052: LD_INT 2
60054: EQUAL
60055: AND
60056: IFFALSE 60073
// bpoints := bpoints * 1.2 ;
60058: LD_ADDR_VAR 0 10
60062: PUSH
60063: LD_VAR 0 10
60067: PUSH
60068: LD_REAL  1.20000000000000E+0000
60071: MUL
60072: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60073: LD_VAR 0 6
60077: PPUSH
60078: CALL_OW 264
60082: PUSH
60083: LD_INT 6
60085: PUSH
60086: LD_INT 46
60088: PUSH
60089: LD_INT 47
60091: PUSH
60092: EMPTY
60093: LIST
60094: LIST
60095: LIST
60096: IN
60097: IFFALSE 60114
// bpoints := bpoints * 1.2 ;
60099: LD_ADDR_VAR 0 10
60103: PUSH
60104: LD_VAR 0 10
60108: PUSH
60109: LD_REAL  1.20000000000000E+0000
60112: MUL
60113: ST_TO_ADDR
// end ; unit_building :
60114: GO 60128
60116: LD_INT 3
60118: DOUBLE
60119: EQUAL
60120: IFTRUE 60124
60122: GO 60127
60124: POP
// ; end ;
60125: GO 60128
60127: POP
// for j = 1 to 3 do
60128: LD_ADDR_VAR 0 7
60132: PUSH
60133: DOUBLE
60134: LD_INT 1
60136: DEC
60137: ST_TO_ADDR
60138: LD_INT 3
60140: PUSH
60141: FOR_TO
60142: IFFALSE 60195
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60144: LD_ADDR_VAR 0 5
60148: PUSH
60149: LD_VAR 0 5
60153: PPUSH
60154: LD_VAR 0 7
60158: PPUSH
60159: LD_VAR 0 5
60163: PUSH
60164: LD_VAR 0 7
60168: ARRAY
60169: PUSH
60170: LD_VAR 0 9
60174: PUSH
60175: LD_VAR 0 7
60179: ARRAY
60180: PUSH
60181: LD_VAR 0 10
60185: MUL
60186: PLUS
60187: PPUSH
60188: CALL_OW 1
60192: ST_TO_ADDR
60193: GO 60141
60195: POP
60196: POP
// end ;
60197: GO 58680
60199: POP
60200: POP
// result := Replace ( result , 4 , tmp ) ;
60201: LD_ADDR_VAR 0 5
60205: PUSH
60206: LD_VAR 0 5
60210: PPUSH
60211: LD_INT 4
60213: PPUSH
60214: LD_VAR 0 8
60218: PPUSH
60219: CALL_OW 1
60223: ST_TO_ADDR
// end ;
60224: LD_VAR 0 5
60228: RET
// export function DangerAtRange ( unit , range ) ; begin
60229: LD_INT 0
60231: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60232: LD_ADDR_VAR 0 3
60236: PUSH
60237: LD_VAR 0 1
60241: PPUSH
60242: CALL_OW 255
60246: PPUSH
60247: LD_VAR 0 1
60251: PPUSH
60252: CALL_OW 250
60256: PPUSH
60257: LD_VAR 0 1
60261: PPUSH
60262: CALL_OW 251
60266: PPUSH
60267: LD_VAR 0 2
60271: PPUSH
60272: CALL 58532 0 4
60276: ST_TO_ADDR
// end ;
60277: LD_VAR 0 3
60281: RET
// export function DangerInArea ( side , area ) ; begin
60282: LD_INT 0
60284: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60285: LD_ADDR_VAR 0 3
60289: PUSH
60290: LD_VAR 0 2
60294: PPUSH
60295: LD_INT 81
60297: PUSH
60298: LD_VAR 0 1
60302: PUSH
60303: EMPTY
60304: LIST
60305: LIST
60306: PPUSH
60307: CALL_OW 70
60311: ST_TO_ADDR
// end ;
60312: LD_VAR 0 3
60316: RET
// export function IsExtension ( b ) ; begin
60317: LD_INT 0
60319: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60320: LD_ADDR_VAR 0 2
60324: PUSH
60325: LD_VAR 0 1
60329: PUSH
60330: LD_INT 23
60332: PUSH
60333: LD_INT 20
60335: PUSH
60336: LD_INT 22
60338: PUSH
60339: LD_INT 17
60341: PUSH
60342: LD_INT 24
60344: PUSH
60345: LD_INT 21
60347: PUSH
60348: LD_INT 19
60350: PUSH
60351: LD_INT 16
60353: PUSH
60354: LD_INT 25
60356: PUSH
60357: LD_INT 18
60359: PUSH
60360: EMPTY
60361: LIST
60362: LIST
60363: LIST
60364: LIST
60365: LIST
60366: LIST
60367: LIST
60368: LIST
60369: LIST
60370: LIST
60371: IN
60372: ST_TO_ADDR
// end ;
60373: LD_VAR 0 2
60377: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60378: LD_INT 0
60380: PPUSH
60381: PPUSH
60382: PPUSH
// result := [ ] ;
60383: LD_ADDR_VAR 0 3
60387: PUSH
60388: EMPTY
60389: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60390: LD_ADDR_VAR 0 4
60394: PUSH
60395: LD_VAR 0 2
60399: PPUSH
60400: LD_INT 21
60402: PUSH
60403: LD_INT 3
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: PPUSH
60410: CALL_OW 70
60414: ST_TO_ADDR
// if not tmp then
60415: LD_VAR 0 4
60419: NOT
60420: IFFALSE 60424
// exit ;
60422: GO 60482
// for i in tmp do
60424: LD_ADDR_VAR 0 5
60428: PUSH
60429: LD_VAR 0 4
60433: PUSH
60434: FOR_IN
60435: IFFALSE 60470
// if GetBase ( i ) <> base then
60437: LD_VAR 0 5
60441: PPUSH
60442: CALL_OW 274
60446: PUSH
60447: LD_VAR 0 1
60451: NONEQUAL
60452: IFFALSE 60468
// ComLinkToBase ( base , i ) ;
60454: LD_VAR 0 1
60458: PPUSH
60459: LD_VAR 0 5
60463: PPUSH
60464: CALL_OW 169
60468: GO 60434
60470: POP
60471: POP
// result := tmp ;
60472: LD_ADDR_VAR 0 3
60476: PUSH
60477: LD_VAR 0 4
60481: ST_TO_ADDR
// end ;
60482: LD_VAR 0 3
60486: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60487: LD_INT 0
60489: PPUSH
60490: PPUSH
// if BuildingStatus ( b ) = bs_build then
60491: LD_VAR 0 2
60495: PPUSH
60496: CALL_OW 461
60500: PUSH
60501: LD_INT 1
60503: EQUAL
60504: IFFALSE 60564
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60506: LD_VAR 0 1
60510: PPUSH
60511: LD_STRING h
60513: PUSH
60514: LD_VAR 0 2
60518: PPUSH
60519: CALL_OW 250
60523: PUSH
60524: LD_VAR 0 2
60528: PPUSH
60529: CALL_OW 251
60533: PUSH
60534: LD_VAR 0 2
60538: PUSH
60539: LD_INT 0
60541: PUSH
60542: LD_INT 0
60544: PUSH
60545: LD_INT 0
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: LIST
60552: LIST
60553: LIST
60554: LIST
60555: LIST
60556: PUSH
60557: EMPTY
60558: LIST
60559: PPUSH
60560: CALL_OW 446
// end ;
60564: LD_VAR 0 3
60568: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60569: LD_INT 0
60571: PPUSH
60572: PPUSH
60573: PPUSH
60574: PPUSH
60575: PPUSH
60576: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60577: LD_VAR 0 1
60581: NOT
60582: PUSH
60583: LD_VAR 0 1
60587: PPUSH
60588: CALL_OW 263
60592: PUSH
60593: LD_INT 2
60595: EQUAL
60596: NOT
60597: OR
60598: IFFALSE 60602
// exit ;
60600: GO 60918
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60602: LD_ADDR_VAR 0 6
60606: PUSH
60607: LD_INT 22
60609: PUSH
60610: LD_VAR 0 1
60614: PPUSH
60615: CALL_OW 255
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: PUSH
60624: LD_INT 2
60626: PUSH
60627: LD_INT 30
60629: PUSH
60630: LD_INT 36
60632: PUSH
60633: EMPTY
60634: LIST
60635: LIST
60636: PUSH
60637: LD_INT 34
60639: PUSH
60640: LD_INT 31
60642: PUSH
60643: EMPTY
60644: LIST
60645: LIST
60646: PUSH
60647: EMPTY
60648: LIST
60649: LIST
60650: LIST
60651: PUSH
60652: EMPTY
60653: LIST
60654: LIST
60655: PPUSH
60656: CALL_OW 69
60660: ST_TO_ADDR
// if not tmp then
60661: LD_VAR 0 6
60665: NOT
60666: IFFALSE 60670
// exit ;
60668: GO 60918
// result := [ ] ;
60670: LD_ADDR_VAR 0 2
60674: PUSH
60675: EMPTY
60676: ST_TO_ADDR
// for i in tmp do
60677: LD_ADDR_VAR 0 3
60681: PUSH
60682: LD_VAR 0 6
60686: PUSH
60687: FOR_IN
60688: IFFALSE 60759
// begin t := UnitsInside ( i ) ;
60690: LD_ADDR_VAR 0 4
60694: PUSH
60695: LD_VAR 0 3
60699: PPUSH
60700: CALL_OW 313
60704: ST_TO_ADDR
// if t then
60705: LD_VAR 0 4
60709: IFFALSE 60757
// for j in t do
60711: LD_ADDR_VAR 0 7
60715: PUSH
60716: LD_VAR 0 4
60720: PUSH
60721: FOR_IN
60722: IFFALSE 60755
// result := Insert ( result , result + 1 , j ) ;
60724: LD_ADDR_VAR 0 2
60728: PUSH
60729: LD_VAR 0 2
60733: PPUSH
60734: LD_VAR 0 2
60738: PUSH
60739: LD_INT 1
60741: PLUS
60742: PPUSH
60743: LD_VAR 0 7
60747: PPUSH
60748: CALL_OW 2
60752: ST_TO_ADDR
60753: GO 60721
60755: POP
60756: POP
// end ;
60757: GO 60687
60759: POP
60760: POP
// if not result then
60761: LD_VAR 0 2
60765: NOT
60766: IFFALSE 60770
// exit ;
60768: GO 60918
// mech := result [ 1 ] ;
60770: LD_ADDR_VAR 0 5
60774: PUSH
60775: LD_VAR 0 2
60779: PUSH
60780: LD_INT 1
60782: ARRAY
60783: ST_TO_ADDR
// if result > 1 then
60784: LD_VAR 0 2
60788: PUSH
60789: LD_INT 1
60791: GREATER
60792: IFFALSE 60904
// for i = 2 to result do
60794: LD_ADDR_VAR 0 3
60798: PUSH
60799: DOUBLE
60800: LD_INT 2
60802: DEC
60803: ST_TO_ADDR
60804: LD_VAR 0 2
60808: PUSH
60809: FOR_TO
60810: IFFALSE 60902
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60812: LD_ADDR_VAR 0 4
60816: PUSH
60817: LD_VAR 0 2
60821: PUSH
60822: LD_VAR 0 3
60826: ARRAY
60827: PPUSH
60828: LD_INT 3
60830: PPUSH
60831: CALL_OW 259
60835: PUSH
60836: LD_VAR 0 2
60840: PUSH
60841: LD_VAR 0 3
60845: ARRAY
60846: PPUSH
60847: CALL_OW 432
60851: MINUS
60852: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60853: LD_VAR 0 4
60857: PUSH
60858: LD_VAR 0 5
60862: PPUSH
60863: LD_INT 3
60865: PPUSH
60866: CALL_OW 259
60870: PUSH
60871: LD_VAR 0 5
60875: PPUSH
60876: CALL_OW 432
60880: MINUS
60881: GREATEREQUAL
60882: IFFALSE 60900
// mech := result [ i ] ;
60884: LD_ADDR_VAR 0 5
60888: PUSH
60889: LD_VAR 0 2
60893: PUSH
60894: LD_VAR 0 3
60898: ARRAY
60899: ST_TO_ADDR
// end ;
60900: GO 60809
60902: POP
60903: POP
// ComLinkTo ( vehicle , mech ) ;
60904: LD_VAR 0 1
60908: PPUSH
60909: LD_VAR 0 5
60913: PPUSH
60914: CALL_OW 135
// end ;
60918: LD_VAR 0 2
60922: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60923: LD_INT 0
60925: PPUSH
60926: PPUSH
60927: PPUSH
60928: PPUSH
60929: PPUSH
60930: PPUSH
60931: PPUSH
60932: PPUSH
60933: PPUSH
60934: PPUSH
60935: PPUSH
60936: PPUSH
60937: PPUSH
// result := [ ] ;
60938: LD_ADDR_VAR 0 7
60942: PUSH
60943: EMPTY
60944: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60945: LD_VAR 0 1
60949: PPUSH
60950: CALL_OW 266
60954: PUSH
60955: LD_INT 0
60957: PUSH
60958: LD_INT 1
60960: PUSH
60961: EMPTY
60962: LIST
60963: LIST
60964: IN
60965: NOT
60966: IFFALSE 60970
// exit ;
60968: GO 62601
// if name then
60970: LD_VAR 0 3
60974: IFFALSE 60990
// SetBName ( base_dep , name ) ;
60976: LD_VAR 0 1
60980: PPUSH
60981: LD_VAR 0 3
60985: PPUSH
60986: CALL_OW 500
// base := GetBase ( base_dep ) ;
60990: LD_ADDR_VAR 0 15
60994: PUSH
60995: LD_VAR 0 1
60999: PPUSH
61000: CALL_OW 274
61004: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61005: LD_ADDR_VAR 0 16
61009: PUSH
61010: LD_VAR 0 1
61014: PPUSH
61015: CALL_OW 255
61019: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61020: LD_ADDR_VAR 0 17
61024: PUSH
61025: LD_VAR 0 1
61029: PPUSH
61030: CALL_OW 248
61034: ST_TO_ADDR
// if sources then
61035: LD_VAR 0 5
61039: IFFALSE 61086
// for i = 1 to 3 do
61041: LD_ADDR_VAR 0 8
61045: PUSH
61046: DOUBLE
61047: LD_INT 1
61049: DEC
61050: ST_TO_ADDR
61051: LD_INT 3
61053: PUSH
61054: FOR_TO
61055: IFFALSE 61084
// AddResourceType ( base , i , sources [ i ] ) ;
61057: LD_VAR 0 15
61061: PPUSH
61062: LD_VAR 0 8
61066: PPUSH
61067: LD_VAR 0 5
61071: PUSH
61072: LD_VAR 0 8
61076: ARRAY
61077: PPUSH
61078: CALL_OW 276
61082: GO 61054
61084: POP
61085: POP
// buildings := GetBaseBuildings ( base , area ) ;
61086: LD_ADDR_VAR 0 18
61090: PUSH
61091: LD_VAR 0 15
61095: PPUSH
61096: LD_VAR 0 2
61100: PPUSH
61101: CALL 60378 0 2
61105: ST_TO_ADDR
// InitHc ;
61106: CALL_OW 19
// InitUc ;
61110: CALL_OW 18
// uc_side := side ;
61114: LD_ADDR_OWVAR 20
61118: PUSH
61119: LD_VAR 0 16
61123: ST_TO_ADDR
// uc_nation := nation ;
61124: LD_ADDR_OWVAR 21
61128: PUSH
61129: LD_VAR 0 17
61133: ST_TO_ADDR
// if buildings then
61134: LD_VAR 0 18
61138: IFFALSE 62460
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61140: LD_ADDR_VAR 0 19
61144: PUSH
61145: LD_VAR 0 18
61149: PPUSH
61150: LD_INT 2
61152: PUSH
61153: LD_INT 30
61155: PUSH
61156: LD_INT 29
61158: PUSH
61159: EMPTY
61160: LIST
61161: LIST
61162: PUSH
61163: LD_INT 30
61165: PUSH
61166: LD_INT 30
61168: PUSH
61169: EMPTY
61170: LIST
61171: LIST
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: LIST
61177: PPUSH
61178: CALL_OW 72
61182: ST_TO_ADDR
// if tmp then
61183: LD_VAR 0 19
61187: IFFALSE 61235
// for i in tmp do
61189: LD_ADDR_VAR 0 8
61193: PUSH
61194: LD_VAR 0 19
61198: PUSH
61199: FOR_IN
61200: IFFALSE 61233
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61202: LD_VAR 0 8
61206: PPUSH
61207: CALL_OW 250
61211: PPUSH
61212: LD_VAR 0 8
61216: PPUSH
61217: CALL_OW 251
61221: PPUSH
61222: LD_VAR 0 16
61226: PPUSH
61227: CALL_OW 441
61231: GO 61199
61233: POP
61234: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61235: LD_VAR 0 18
61239: PPUSH
61240: LD_INT 2
61242: PUSH
61243: LD_INT 30
61245: PUSH
61246: LD_INT 32
61248: PUSH
61249: EMPTY
61250: LIST
61251: LIST
61252: PUSH
61253: LD_INT 30
61255: PUSH
61256: LD_INT 33
61258: PUSH
61259: EMPTY
61260: LIST
61261: LIST
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: LIST
61267: PPUSH
61268: CALL_OW 72
61272: IFFALSE 61360
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61274: LD_ADDR_VAR 0 8
61278: PUSH
61279: LD_VAR 0 18
61283: PPUSH
61284: LD_INT 2
61286: PUSH
61287: LD_INT 30
61289: PUSH
61290: LD_INT 32
61292: PUSH
61293: EMPTY
61294: LIST
61295: LIST
61296: PUSH
61297: LD_INT 30
61299: PUSH
61300: LD_INT 33
61302: PUSH
61303: EMPTY
61304: LIST
61305: LIST
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: LIST
61311: PPUSH
61312: CALL_OW 72
61316: PUSH
61317: FOR_IN
61318: IFFALSE 61358
// begin if not GetBWeapon ( i ) then
61320: LD_VAR 0 8
61324: PPUSH
61325: CALL_OW 269
61329: NOT
61330: IFFALSE 61356
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61332: LD_VAR 0 8
61336: PPUSH
61337: LD_VAR 0 8
61341: PPUSH
61342: LD_VAR 0 2
61346: PPUSH
61347: CALL 62606 0 2
61351: PPUSH
61352: CALL_OW 431
// end ;
61356: GO 61317
61358: POP
61359: POP
// end ; for i = 1 to personel do
61360: LD_ADDR_VAR 0 8
61364: PUSH
61365: DOUBLE
61366: LD_INT 1
61368: DEC
61369: ST_TO_ADDR
61370: LD_VAR 0 6
61374: PUSH
61375: FOR_TO
61376: IFFALSE 62440
// begin if i > 4 then
61378: LD_VAR 0 8
61382: PUSH
61383: LD_INT 4
61385: GREATER
61386: IFFALSE 61390
// break ;
61388: GO 62440
// case i of 1 :
61390: LD_VAR 0 8
61394: PUSH
61395: LD_INT 1
61397: DOUBLE
61398: EQUAL
61399: IFTRUE 61403
61401: GO 61483
61403: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61404: LD_ADDR_VAR 0 12
61408: PUSH
61409: LD_VAR 0 18
61413: PPUSH
61414: LD_INT 22
61416: PUSH
61417: LD_VAR 0 16
61421: PUSH
61422: EMPTY
61423: LIST
61424: LIST
61425: PUSH
61426: LD_INT 58
61428: PUSH
61429: EMPTY
61430: LIST
61431: PUSH
61432: LD_INT 2
61434: PUSH
61435: LD_INT 30
61437: PUSH
61438: LD_INT 32
61440: PUSH
61441: EMPTY
61442: LIST
61443: LIST
61444: PUSH
61445: LD_INT 30
61447: PUSH
61448: LD_INT 4
61450: PUSH
61451: EMPTY
61452: LIST
61453: LIST
61454: PUSH
61455: LD_INT 30
61457: PUSH
61458: LD_INT 5
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: PUSH
61465: EMPTY
61466: LIST
61467: LIST
61468: LIST
61469: LIST
61470: PUSH
61471: EMPTY
61472: LIST
61473: LIST
61474: LIST
61475: PPUSH
61476: CALL_OW 72
61480: ST_TO_ADDR
61481: GO 61705
61483: LD_INT 2
61485: DOUBLE
61486: EQUAL
61487: IFTRUE 61491
61489: GO 61553
61491: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61492: LD_ADDR_VAR 0 12
61496: PUSH
61497: LD_VAR 0 18
61501: PPUSH
61502: LD_INT 22
61504: PUSH
61505: LD_VAR 0 16
61509: PUSH
61510: EMPTY
61511: LIST
61512: LIST
61513: PUSH
61514: LD_INT 2
61516: PUSH
61517: LD_INT 30
61519: PUSH
61520: LD_INT 0
61522: PUSH
61523: EMPTY
61524: LIST
61525: LIST
61526: PUSH
61527: LD_INT 30
61529: PUSH
61530: LD_INT 1
61532: PUSH
61533: EMPTY
61534: LIST
61535: LIST
61536: PUSH
61537: EMPTY
61538: LIST
61539: LIST
61540: LIST
61541: PUSH
61542: EMPTY
61543: LIST
61544: LIST
61545: PPUSH
61546: CALL_OW 72
61550: ST_TO_ADDR
61551: GO 61705
61553: LD_INT 3
61555: DOUBLE
61556: EQUAL
61557: IFTRUE 61561
61559: GO 61623
61561: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61562: LD_ADDR_VAR 0 12
61566: PUSH
61567: LD_VAR 0 18
61571: PPUSH
61572: LD_INT 22
61574: PUSH
61575: LD_VAR 0 16
61579: PUSH
61580: EMPTY
61581: LIST
61582: LIST
61583: PUSH
61584: LD_INT 2
61586: PUSH
61587: LD_INT 30
61589: PUSH
61590: LD_INT 2
61592: PUSH
61593: EMPTY
61594: LIST
61595: LIST
61596: PUSH
61597: LD_INT 30
61599: PUSH
61600: LD_INT 3
61602: PUSH
61603: EMPTY
61604: LIST
61605: LIST
61606: PUSH
61607: EMPTY
61608: LIST
61609: LIST
61610: LIST
61611: PUSH
61612: EMPTY
61613: LIST
61614: LIST
61615: PPUSH
61616: CALL_OW 72
61620: ST_TO_ADDR
61621: GO 61705
61623: LD_INT 4
61625: DOUBLE
61626: EQUAL
61627: IFTRUE 61631
61629: GO 61704
61631: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61632: LD_ADDR_VAR 0 12
61636: PUSH
61637: LD_VAR 0 18
61641: PPUSH
61642: LD_INT 22
61644: PUSH
61645: LD_VAR 0 16
61649: PUSH
61650: EMPTY
61651: LIST
61652: LIST
61653: PUSH
61654: LD_INT 2
61656: PUSH
61657: LD_INT 30
61659: PUSH
61660: LD_INT 6
61662: PUSH
61663: EMPTY
61664: LIST
61665: LIST
61666: PUSH
61667: LD_INT 30
61669: PUSH
61670: LD_INT 7
61672: PUSH
61673: EMPTY
61674: LIST
61675: LIST
61676: PUSH
61677: LD_INT 30
61679: PUSH
61680: LD_INT 8
61682: PUSH
61683: EMPTY
61684: LIST
61685: LIST
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: LIST
61691: LIST
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: PPUSH
61697: CALL_OW 72
61701: ST_TO_ADDR
61702: GO 61705
61704: POP
// if i = 1 then
61705: LD_VAR 0 8
61709: PUSH
61710: LD_INT 1
61712: EQUAL
61713: IFFALSE 61824
// begin tmp := [ ] ;
61715: LD_ADDR_VAR 0 19
61719: PUSH
61720: EMPTY
61721: ST_TO_ADDR
// for j in f do
61722: LD_ADDR_VAR 0 9
61726: PUSH
61727: LD_VAR 0 12
61731: PUSH
61732: FOR_IN
61733: IFFALSE 61806
// if GetBType ( j ) = b_bunker then
61735: LD_VAR 0 9
61739: PPUSH
61740: CALL_OW 266
61744: PUSH
61745: LD_INT 32
61747: EQUAL
61748: IFFALSE 61775
// tmp := Insert ( tmp , 1 , j ) else
61750: LD_ADDR_VAR 0 19
61754: PUSH
61755: LD_VAR 0 19
61759: PPUSH
61760: LD_INT 1
61762: PPUSH
61763: LD_VAR 0 9
61767: PPUSH
61768: CALL_OW 2
61772: ST_TO_ADDR
61773: GO 61804
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61775: LD_ADDR_VAR 0 19
61779: PUSH
61780: LD_VAR 0 19
61784: PPUSH
61785: LD_VAR 0 19
61789: PUSH
61790: LD_INT 1
61792: PLUS
61793: PPUSH
61794: LD_VAR 0 9
61798: PPUSH
61799: CALL_OW 2
61803: ST_TO_ADDR
61804: GO 61732
61806: POP
61807: POP
// if tmp then
61808: LD_VAR 0 19
61812: IFFALSE 61824
// f := tmp ;
61814: LD_ADDR_VAR 0 12
61818: PUSH
61819: LD_VAR 0 19
61823: ST_TO_ADDR
// end ; x := personel [ i ] ;
61824: LD_ADDR_VAR 0 13
61828: PUSH
61829: LD_VAR 0 6
61833: PUSH
61834: LD_VAR 0 8
61838: ARRAY
61839: ST_TO_ADDR
// if x = - 1 then
61840: LD_VAR 0 13
61844: PUSH
61845: LD_INT 1
61847: NEG
61848: EQUAL
61849: IFFALSE 62058
// begin for j in f do
61851: LD_ADDR_VAR 0 9
61855: PUSH
61856: LD_VAR 0 12
61860: PUSH
61861: FOR_IN
61862: IFFALSE 62054
// repeat InitHc ;
61864: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61868: LD_VAR 0 9
61872: PPUSH
61873: CALL_OW 266
61877: PUSH
61878: LD_INT 5
61880: EQUAL
61881: IFFALSE 61951
// begin if UnitsInside ( j ) < 3 then
61883: LD_VAR 0 9
61887: PPUSH
61888: CALL_OW 313
61892: PUSH
61893: LD_INT 3
61895: LESS
61896: IFFALSE 61932
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61898: LD_INT 0
61900: PPUSH
61901: LD_INT 5
61903: PUSH
61904: LD_INT 8
61906: PUSH
61907: LD_INT 9
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: LIST
61914: PUSH
61915: LD_VAR 0 17
61919: ARRAY
61920: PPUSH
61921: LD_VAR 0 4
61925: PPUSH
61926: CALL_OW 380
61930: GO 61949
// PrepareHuman ( false , i , skill ) ;
61932: LD_INT 0
61934: PPUSH
61935: LD_VAR 0 8
61939: PPUSH
61940: LD_VAR 0 4
61944: PPUSH
61945: CALL_OW 380
// end else
61949: GO 61968
// PrepareHuman ( false , i , skill ) ;
61951: LD_INT 0
61953: PPUSH
61954: LD_VAR 0 8
61958: PPUSH
61959: LD_VAR 0 4
61963: PPUSH
61964: CALL_OW 380
// un := CreateHuman ;
61968: LD_ADDR_VAR 0 14
61972: PUSH
61973: CALL_OW 44
61977: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61978: LD_ADDR_VAR 0 7
61982: PUSH
61983: LD_VAR 0 7
61987: PPUSH
61988: LD_INT 1
61990: PPUSH
61991: LD_VAR 0 14
61995: PPUSH
61996: CALL_OW 2
62000: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62001: LD_VAR 0 14
62005: PPUSH
62006: LD_VAR 0 9
62010: PPUSH
62011: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62015: LD_VAR 0 9
62019: PPUSH
62020: CALL_OW 313
62024: PUSH
62025: LD_INT 6
62027: EQUAL
62028: PUSH
62029: LD_VAR 0 9
62033: PPUSH
62034: CALL_OW 266
62038: PUSH
62039: LD_INT 32
62041: PUSH
62042: LD_INT 31
62044: PUSH
62045: EMPTY
62046: LIST
62047: LIST
62048: IN
62049: OR
62050: IFFALSE 61864
62052: GO 61861
62054: POP
62055: POP
// end else
62056: GO 62438
// for j = 1 to x do
62058: LD_ADDR_VAR 0 9
62062: PUSH
62063: DOUBLE
62064: LD_INT 1
62066: DEC
62067: ST_TO_ADDR
62068: LD_VAR 0 13
62072: PUSH
62073: FOR_TO
62074: IFFALSE 62436
// begin InitHc ;
62076: CALL_OW 19
// if not f then
62080: LD_VAR 0 12
62084: NOT
62085: IFFALSE 62174
// begin PrepareHuman ( false , i , skill ) ;
62087: LD_INT 0
62089: PPUSH
62090: LD_VAR 0 8
62094: PPUSH
62095: LD_VAR 0 4
62099: PPUSH
62100: CALL_OW 380
// un := CreateHuman ;
62104: LD_ADDR_VAR 0 14
62108: PUSH
62109: CALL_OW 44
62113: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62114: LD_ADDR_VAR 0 7
62118: PUSH
62119: LD_VAR 0 7
62123: PPUSH
62124: LD_INT 1
62126: PPUSH
62127: LD_VAR 0 14
62131: PPUSH
62132: CALL_OW 2
62136: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62137: LD_VAR 0 14
62141: PPUSH
62142: LD_VAR 0 1
62146: PPUSH
62147: CALL_OW 250
62151: PPUSH
62152: LD_VAR 0 1
62156: PPUSH
62157: CALL_OW 251
62161: PPUSH
62162: LD_INT 10
62164: PPUSH
62165: LD_INT 0
62167: PPUSH
62168: CALL_OW 50
// continue ;
62172: GO 62073
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62174: LD_VAR 0 12
62178: PUSH
62179: LD_INT 1
62181: ARRAY
62182: PPUSH
62183: CALL_OW 313
62187: PUSH
62188: LD_VAR 0 12
62192: PUSH
62193: LD_INT 1
62195: ARRAY
62196: PPUSH
62197: CALL_OW 266
62201: PUSH
62202: LD_INT 32
62204: PUSH
62205: LD_INT 31
62207: PUSH
62208: EMPTY
62209: LIST
62210: LIST
62211: IN
62212: AND
62213: PUSH
62214: LD_VAR 0 12
62218: PUSH
62219: LD_INT 1
62221: ARRAY
62222: PPUSH
62223: CALL_OW 313
62227: PUSH
62228: LD_INT 6
62230: EQUAL
62231: OR
62232: IFFALSE 62252
// f := Delete ( f , 1 ) ;
62234: LD_ADDR_VAR 0 12
62238: PUSH
62239: LD_VAR 0 12
62243: PPUSH
62244: LD_INT 1
62246: PPUSH
62247: CALL_OW 3
62251: ST_TO_ADDR
// if not f then
62252: LD_VAR 0 12
62256: NOT
62257: IFFALSE 62275
// begin x := x + 2 ;
62259: LD_ADDR_VAR 0 13
62263: PUSH
62264: LD_VAR 0 13
62268: PUSH
62269: LD_INT 2
62271: PLUS
62272: ST_TO_ADDR
// continue ;
62273: GO 62073
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62275: LD_VAR 0 12
62279: PUSH
62280: LD_INT 1
62282: ARRAY
62283: PPUSH
62284: CALL_OW 266
62288: PUSH
62289: LD_INT 5
62291: EQUAL
62292: IFFALSE 62366
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62294: LD_VAR 0 12
62298: PUSH
62299: LD_INT 1
62301: ARRAY
62302: PPUSH
62303: CALL_OW 313
62307: PUSH
62308: LD_INT 3
62310: LESS
62311: IFFALSE 62347
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62313: LD_INT 0
62315: PPUSH
62316: LD_INT 5
62318: PUSH
62319: LD_INT 8
62321: PUSH
62322: LD_INT 9
62324: PUSH
62325: EMPTY
62326: LIST
62327: LIST
62328: LIST
62329: PUSH
62330: LD_VAR 0 17
62334: ARRAY
62335: PPUSH
62336: LD_VAR 0 4
62340: PPUSH
62341: CALL_OW 380
62345: GO 62364
// PrepareHuman ( false , i , skill ) ;
62347: LD_INT 0
62349: PPUSH
62350: LD_VAR 0 8
62354: PPUSH
62355: LD_VAR 0 4
62359: PPUSH
62360: CALL_OW 380
// end else
62364: GO 62383
// PrepareHuman ( false , i , skill ) ;
62366: LD_INT 0
62368: PPUSH
62369: LD_VAR 0 8
62373: PPUSH
62374: LD_VAR 0 4
62378: PPUSH
62379: CALL_OW 380
// un := CreateHuman ;
62383: LD_ADDR_VAR 0 14
62387: PUSH
62388: CALL_OW 44
62392: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62393: LD_ADDR_VAR 0 7
62397: PUSH
62398: LD_VAR 0 7
62402: PPUSH
62403: LD_INT 1
62405: PPUSH
62406: LD_VAR 0 14
62410: PPUSH
62411: CALL_OW 2
62415: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62416: LD_VAR 0 14
62420: PPUSH
62421: LD_VAR 0 12
62425: PUSH
62426: LD_INT 1
62428: ARRAY
62429: PPUSH
62430: CALL_OW 52
// end ;
62434: GO 62073
62436: POP
62437: POP
// end ;
62438: GO 61375
62440: POP
62441: POP
// result := result ^ buildings ;
62442: LD_ADDR_VAR 0 7
62446: PUSH
62447: LD_VAR 0 7
62451: PUSH
62452: LD_VAR 0 18
62456: ADD
62457: ST_TO_ADDR
// end else
62458: GO 62601
// begin for i = 1 to personel do
62460: LD_ADDR_VAR 0 8
62464: PUSH
62465: DOUBLE
62466: LD_INT 1
62468: DEC
62469: ST_TO_ADDR
62470: LD_VAR 0 6
62474: PUSH
62475: FOR_TO
62476: IFFALSE 62599
// begin if i > 4 then
62478: LD_VAR 0 8
62482: PUSH
62483: LD_INT 4
62485: GREATER
62486: IFFALSE 62490
// break ;
62488: GO 62599
// x := personel [ i ] ;
62490: LD_ADDR_VAR 0 13
62494: PUSH
62495: LD_VAR 0 6
62499: PUSH
62500: LD_VAR 0 8
62504: ARRAY
62505: ST_TO_ADDR
// if x = - 1 then
62506: LD_VAR 0 13
62510: PUSH
62511: LD_INT 1
62513: NEG
62514: EQUAL
62515: IFFALSE 62519
// continue ;
62517: GO 62475
// PrepareHuman ( false , i , skill ) ;
62519: LD_INT 0
62521: PPUSH
62522: LD_VAR 0 8
62526: PPUSH
62527: LD_VAR 0 4
62531: PPUSH
62532: CALL_OW 380
// un := CreateHuman ;
62536: LD_ADDR_VAR 0 14
62540: PUSH
62541: CALL_OW 44
62545: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62546: LD_VAR 0 14
62550: PPUSH
62551: LD_VAR 0 1
62555: PPUSH
62556: CALL_OW 250
62560: PPUSH
62561: LD_VAR 0 1
62565: PPUSH
62566: CALL_OW 251
62570: PPUSH
62571: LD_INT 10
62573: PPUSH
62574: LD_INT 0
62576: PPUSH
62577: CALL_OW 50
// result := result ^ un ;
62581: LD_ADDR_VAR 0 7
62585: PUSH
62586: LD_VAR 0 7
62590: PUSH
62591: LD_VAR 0 14
62595: ADD
62596: ST_TO_ADDR
// end ;
62597: GO 62475
62599: POP
62600: POP
// end ; end ;
62601: LD_VAR 0 7
62605: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62606: LD_INT 0
62608: PPUSH
62609: PPUSH
62610: PPUSH
62611: PPUSH
62612: PPUSH
62613: PPUSH
62614: PPUSH
62615: PPUSH
62616: PPUSH
62617: PPUSH
62618: PPUSH
62619: PPUSH
62620: PPUSH
62621: PPUSH
62622: PPUSH
62623: PPUSH
// result := false ;
62624: LD_ADDR_VAR 0 3
62628: PUSH
62629: LD_INT 0
62631: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62632: LD_VAR 0 1
62636: NOT
62637: PUSH
62638: LD_VAR 0 1
62642: PPUSH
62643: CALL_OW 266
62647: PUSH
62648: LD_INT 32
62650: PUSH
62651: LD_INT 33
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: IN
62658: NOT
62659: OR
62660: IFFALSE 62664
// exit ;
62662: GO 63800
// nat := GetNation ( tower ) ;
62664: LD_ADDR_VAR 0 12
62668: PUSH
62669: LD_VAR 0 1
62673: PPUSH
62674: CALL_OW 248
62678: ST_TO_ADDR
// side := GetSide ( tower ) ;
62679: LD_ADDR_VAR 0 16
62683: PUSH
62684: LD_VAR 0 1
62688: PPUSH
62689: CALL_OW 255
62693: ST_TO_ADDR
// x := GetX ( tower ) ;
62694: LD_ADDR_VAR 0 10
62698: PUSH
62699: LD_VAR 0 1
62703: PPUSH
62704: CALL_OW 250
62708: ST_TO_ADDR
// y := GetY ( tower ) ;
62709: LD_ADDR_VAR 0 11
62713: PUSH
62714: LD_VAR 0 1
62718: PPUSH
62719: CALL_OW 251
62723: ST_TO_ADDR
// if not x or not y then
62724: LD_VAR 0 10
62728: NOT
62729: PUSH
62730: LD_VAR 0 11
62734: NOT
62735: OR
62736: IFFALSE 62740
// exit ;
62738: GO 63800
// weapon := 0 ;
62740: LD_ADDR_VAR 0 18
62744: PUSH
62745: LD_INT 0
62747: ST_TO_ADDR
// fac_list := [ ] ;
62748: LD_ADDR_VAR 0 17
62752: PUSH
62753: EMPTY
62754: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62755: LD_ADDR_VAR 0 6
62759: PUSH
62760: LD_VAR 0 1
62764: PPUSH
62765: CALL_OW 274
62769: PPUSH
62770: LD_VAR 0 2
62774: PPUSH
62775: CALL 60378 0 2
62779: PPUSH
62780: LD_INT 30
62782: PUSH
62783: LD_INT 3
62785: PUSH
62786: EMPTY
62787: LIST
62788: LIST
62789: PPUSH
62790: CALL_OW 72
62794: ST_TO_ADDR
// if not factories then
62795: LD_VAR 0 6
62799: NOT
62800: IFFALSE 62804
// exit ;
62802: GO 63800
// for i in factories do
62804: LD_ADDR_VAR 0 8
62808: PUSH
62809: LD_VAR 0 6
62813: PUSH
62814: FOR_IN
62815: IFFALSE 62840
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62817: LD_ADDR_VAR 0 17
62821: PUSH
62822: LD_VAR 0 17
62826: PUSH
62827: LD_VAR 0 8
62831: PPUSH
62832: CALL_OW 478
62836: UNION
62837: ST_TO_ADDR
62838: GO 62814
62840: POP
62841: POP
// if not fac_list then
62842: LD_VAR 0 17
62846: NOT
62847: IFFALSE 62851
// exit ;
62849: GO 63800
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62851: LD_ADDR_VAR 0 5
62855: PUSH
62856: LD_INT 4
62858: PUSH
62859: LD_INT 5
62861: PUSH
62862: LD_INT 9
62864: PUSH
62865: LD_INT 10
62867: PUSH
62868: LD_INT 6
62870: PUSH
62871: LD_INT 7
62873: PUSH
62874: LD_INT 11
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: LIST
62881: LIST
62882: LIST
62883: LIST
62884: LIST
62885: PUSH
62886: LD_INT 27
62888: PUSH
62889: LD_INT 28
62891: PUSH
62892: LD_INT 26
62894: PUSH
62895: LD_INT 30
62897: PUSH
62898: EMPTY
62899: LIST
62900: LIST
62901: LIST
62902: LIST
62903: PUSH
62904: LD_INT 43
62906: PUSH
62907: LD_INT 44
62909: PUSH
62910: LD_INT 46
62912: PUSH
62913: LD_INT 45
62915: PUSH
62916: LD_INT 47
62918: PUSH
62919: LD_INT 49
62921: PUSH
62922: EMPTY
62923: LIST
62924: LIST
62925: LIST
62926: LIST
62927: LIST
62928: LIST
62929: PUSH
62930: EMPTY
62931: LIST
62932: LIST
62933: LIST
62934: PUSH
62935: LD_VAR 0 12
62939: ARRAY
62940: ST_TO_ADDR
// for i in list do
62941: LD_ADDR_VAR 0 8
62945: PUSH
62946: LD_VAR 0 5
62950: PUSH
62951: FOR_IN
62952: IFFALSE 62985
// if not i in fac_list then
62954: LD_VAR 0 8
62958: PUSH
62959: LD_VAR 0 17
62963: IN
62964: NOT
62965: IFFALSE 62983
// list := list diff i ;
62967: LD_ADDR_VAR 0 5
62971: PUSH
62972: LD_VAR 0 5
62976: PUSH
62977: LD_VAR 0 8
62981: DIFF
62982: ST_TO_ADDR
62983: GO 62951
62985: POP
62986: POP
// if not list then
62987: LD_VAR 0 5
62991: NOT
62992: IFFALSE 62996
// exit ;
62994: GO 63800
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62996: LD_VAR 0 12
63000: PUSH
63001: LD_INT 3
63003: EQUAL
63004: PUSH
63005: LD_INT 49
63007: PUSH
63008: LD_VAR 0 5
63012: IN
63013: AND
63014: PUSH
63015: LD_INT 31
63017: PPUSH
63018: LD_VAR 0 16
63022: PPUSH
63023: CALL_OW 321
63027: PUSH
63028: LD_INT 2
63030: EQUAL
63031: AND
63032: IFFALSE 63092
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63034: LD_INT 22
63036: PUSH
63037: LD_VAR 0 16
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: PUSH
63046: LD_INT 35
63048: PUSH
63049: LD_INT 49
63051: PUSH
63052: EMPTY
63053: LIST
63054: LIST
63055: PUSH
63056: LD_INT 91
63058: PUSH
63059: LD_VAR 0 1
63063: PUSH
63064: LD_INT 10
63066: PUSH
63067: EMPTY
63068: LIST
63069: LIST
63070: LIST
63071: PUSH
63072: EMPTY
63073: LIST
63074: LIST
63075: LIST
63076: PPUSH
63077: CALL_OW 69
63081: NOT
63082: IFFALSE 63092
// weapon := ru_time_lapser ;
63084: LD_ADDR_VAR 0 18
63088: PUSH
63089: LD_INT 49
63091: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63092: LD_VAR 0 12
63096: PUSH
63097: LD_INT 1
63099: PUSH
63100: LD_INT 2
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: IN
63107: PUSH
63108: LD_INT 11
63110: PUSH
63111: LD_VAR 0 5
63115: IN
63116: PUSH
63117: LD_INT 30
63119: PUSH
63120: LD_VAR 0 5
63124: IN
63125: OR
63126: AND
63127: PUSH
63128: LD_INT 6
63130: PPUSH
63131: LD_VAR 0 16
63135: PPUSH
63136: CALL_OW 321
63140: PUSH
63141: LD_INT 2
63143: EQUAL
63144: AND
63145: IFFALSE 63310
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63147: LD_INT 22
63149: PUSH
63150: LD_VAR 0 16
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PUSH
63159: LD_INT 2
63161: PUSH
63162: LD_INT 35
63164: PUSH
63165: LD_INT 11
63167: PUSH
63168: EMPTY
63169: LIST
63170: LIST
63171: PUSH
63172: LD_INT 35
63174: PUSH
63175: LD_INT 30
63177: PUSH
63178: EMPTY
63179: LIST
63180: LIST
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: LIST
63186: PUSH
63187: LD_INT 91
63189: PUSH
63190: LD_VAR 0 1
63194: PUSH
63195: LD_INT 18
63197: PUSH
63198: EMPTY
63199: LIST
63200: LIST
63201: LIST
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: LIST
63207: PPUSH
63208: CALL_OW 69
63212: NOT
63213: PUSH
63214: LD_INT 22
63216: PUSH
63217: LD_VAR 0 16
63221: PUSH
63222: EMPTY
63223: LIST
63224: LIST
63225: PUSH
63226: LD_INT 2
63228: PUSH
63229: LD_INT 30
63231: PUSH
63232: LD_INT 32
63234: PUSH
63235: EMPTY
63236: LIST
63237: LIST
63238: PUSH
63239: LD_INT 30
63241: PUSH
63242: LD_INT 33
63244: PUSH
63245: EMPTY
63246: LIST
63247: LIST
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: LIST
63253: PUSH
63254: LD_INT 91
63256: PUSH
63257: LD_VAR 0 1
63261: PUSH
63262: LD_INT 12
63264: PUSH
63265: EMPTY
63266: LIST
63267: LIST
63268: LIST
63269: PUSH
63270: EMPTY
63271: LIST
63272: LIST
63273: LIST
63274: PUSH
63275: EMPTY
63276: LIST
63277: PPUSH
63278: CALL_OW 69
63282: PUSH
63283: LD_INT 2
63285: GREATER
63286: AND
63287: IFFALSE 63310
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63289: LD_ADDR_VAR 0 18
63293: PUSH
63294: LD_INT 11
63296: PUSH
63297: LD_INT 30
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: PUSH
63304: LD_VAR 0 12
63308: ARRAY
63309: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63310: LD_VAR 0 18
63314: NOT
63315: PUSH
63316: LD_INT 40
63318: PPUSH
63319: LD_VAR 0 16
63323: PPUSH
63324: CALL_OW 321
63328: PUSH
63329: LD_INT 2
63331: EQUAL
63332: AND
63333: PUSH
63334: LD_INT 7
63336: PUSH
63337: LD_VAR 0 5
63341: IN
63342: PUSH
63343: LD_INT 28
63345: PUSH
63346: LD_VAR 0 5
63350: IN
63351: OR
63352: PUSH
63353: LD_INT 45
63355: PUSH
63356: LD_VAR 0 5
63360: IN
63361: OR
63362: AND
63363: IFFALSE 63617
// begin hex := GetHexInfo ( x , y ) ;
63365: LD_ADDR_VAR 0 4
63369: PUSH
63370: LD_VAR 0 10
63374: PPUSH
63375: LD_VAR 0 11
63379: PPUSH
63380: CALL_OW 546
63384: ST_TO_ADDR
// if hex [ 1 ] then
63385: LD_VAR 0 4
63389: PUSH
63390: LD_INT 1
63392: ARRAY
63393: IFFALSE 63397
// exit ;
63395: GO 63800
// height := hex [ 2 ] ;
63397: LD_ADDR_VAR 0 15
63401: PUSH
63402: LD_VAR 0 4
63406: PUSH
63407: LD_INT 2
63409: ARRAY
63410: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63411: LD_ADDR_VAR 0 14
63415: PUSH
63416: LD_INT 0
63418: PUSH
63419: LD_INT 2
63421: PUSH
63422: LD_INT 3
63424: PUSH
63425: LD_INT 5
63427: PUSH
63428: EMPTY
63429: LIST
63430: LIST
63431: LIST
63432: LIST
63433: ST_TO_ADDR
// for i in tmp do
63434: LD_ADDR_VAR 0 8
63438: PUSH
63439: LD_VAR 0 14
63443: PUSH
63444: FOR_IN
63445: IFFALSE 63615
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63447: LD_ADDR_VAR 0 9
63451: PUSH
63452: LD_VAR 0 10
63456: PPUSH
63457: LD_VAR 0 8
63461: PPUSH
63462: LD_INT 5
63464: PPUSH
63465: CALL_OW 272
63469: PUSH
63470: LD_VAR 0 11
63474: PPUSH
63475: LD_VAR 0 8
63479: PPUSH
63480: LD_INT 5
63482: PPUSH
63483: CALL_OW 273
63487: PUSH
63488: EMPTY
63489: LIST
63490: LIST
63491: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63492: LD_VAR 0 9
63496: PUSH
63497: LD_INT 1
63499: ARRAY
63500: PPUSH
63501: LD_VAR 0 9
63505: PUSH
63506: LD_INT 2
63508: ARRAY
63509: PPUSH
63510: CALL_OW 488
63514: IFFALSE 63613
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63516: LD_ADDR_VAR 0 4
63520: PUSH
63521: LD_VAR 0 9
63525: PUSH
63526: LD_INT 1
63528: ARRAY
63529: PPUSH
63530: LD_VAR 0 9
63534: PUSH
63535: LD_INT 2
63537: ARRAY
63538: PPUSH
63539: CALL_OW 546
63543: ST_TO_ADDR
// if hex [ 1 ] then
63544: LD_VAR 0 4
63548: PUSH
63549: LD_INT 1
63551: ARRAY
63552: IFFALSE 63556
// continue ;
63554: GO 63444
// h := hex [ 2 ] ;
63556: LD_ADDR_VAR 0 13
63560: PUSH
63561: LD_VAR 0 4
63565: PUSH
63566: LD_INT 2
63568: ARRAY
63569: ST_TO_ADDR
// if h + 7 < height then
63570: LD_VAR 0 13
63574: PUSH
63575: LD_INT 7
63577: PLUS
63578: PUSH
63579: LD_VAR 0 15
63583: LESS
63584: IFFALSE 63613
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63586: LD_ADDR_VAR 0 18
63590: PUSH
63591: LD_INT 7
63593: PUSH
63594: LD_INT 28
63596: PUSH
63597: LD_INT 45
63599: PUSH
63600: EMPTY
63601: LIST
63602: LIST
63603: LIST
63604: PUSH
63605: LD_VAR 0 12
63609: ARRAY
63610: ST_TO_ADDR
// break ;
63611: GO 63615
// end ; end ; end ;
63613: GO 63444
63615: POP
63616: POP
// end ; if not weapon then
63617: LD_VAR 0 18
63621: NOT
63622: IFFALSE 63682
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63624: LD_ADDR_VAR 0 5
63628: PUSH
63629: LD_VAR 0 5
63633: PUSH
63634: LD_INT 11
63636: PUSH
63637: LD_INT 30
63639: PUSH
63640: LD_INT 49
63642: PUSH
63643: EMPTY
63644: LIST
63645: LIST
63646: LIST
63647: DIFF
63648: ST_TO_ADDR
// if not list then
63649: LD_VAR 0 5
63653: NOT
63654: IFFALSE 63658
// exit ;
63656: GO 63800
// weapon := list [ rand ( 1 , list ) ] ;
63658: LD_ADDR_VAR 0 18
63662: PUSH
63663: LD_VAR 0 5
63667: PUSH
63668: LD_INT 1
63670: PPUSH
63671: LD_VAR 0 5
63675: PPUSH
63676: CALL_OW 12
63680: ARRAY
63681: ST_TO_ADDR
// end ; if weapon then
63682: LD_VAR 0 18
63686: IFFALSE 63800
// begin tmp := CostOfWeapon ( weapon ) ;
63688: LD_ADDR_VAR 0 14
63692: PUSH
63693: LD_VAR 0 18
63697: PPUSH
63698: CALL_OW 451
63702: ST_TO_ADDR
// j := GetBase ( tower ) ;
63703: LD_ADDR_VAR 0 9
63707: PUSH
63708: LD_VAR 0 1
63712: PPUSH
63713: CALL_OW 274
63717: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63718: LD_VAR 0 9
63722: PPUSH
63723: LD_INT 1
63725: PPUSH
63726: CALL_OW 275
63730: PUSH
63731: LD_VAR 0 14
63735: PUSH
63736: LD_INT 1
63738: ARRAY
63739: GREATEREQUAL
63740: PUSH
63741: LD_VAR 0 9
63745: PPUSH
63746: LD_INT 2
63748: PPUSH
63749: CALL_OW 275
63753: PUSH
63754: LD_VAR 0 14
63758: PUSH
63759: LD_INT 2
63761: ARRAY
63762: GREATEREQUAL
63763: AND
63764: PUSH
63765: LD_VAR 0 9
63769: PPUSH
63770: LD_INT 3
63772: PPUSH
63773: CALL_OW 275
63777: PUSH
63778: LD_VAR 0 14
63782: PUSH
63783: LD_INT 3
63785: ARRAY
63786: GREATEREQUAL
63787: AND
63788: IFFALSE 63800
// result := weapon ;
63790: LD_ADDR_VAR 0 3
63794: PUSH
63795: LD_VAR 0 18
63799: ST_TO_ADDR
// end ; end ;
63800: LD_VAR 0 3
63804: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63805: LD_INT 0
63807: PPUSH
63808: PPUSH
// result := true ;
63809: LD_ADDR_VAR 0 3
63813: PUSH
63814: LD_INT 1
63816: ST_TO_ADDR
// if array1 = array2 then
63817: LD_VAR 0 1
63821: PUSH
63822: LD_VAR 0 2
63826: EQUAL
63827: IFFALSE 63887
// begin for i = 1 to array1 do
63829: LD_ADDR_VAR 0 4
63833: PUSH
63834: DOUBLE
63835: LD_INT 1
63837: DEC
63838: ST_TO_ADDR
63839: LD_VAR 0 1
63843: PUSH
63844: FOR_TO
63845: IFFALSE 63883
// if array1 [ i ] <> array2 [ i ] then
63847: LD_VAR 0 1
63851: PUSH
63852: LD_VAR 0 4
63856: ARRAY
63857: PUSH
63858: LD_VAR 0 2
63862: PUSH
63863: LD_VAR 0 4
63867: ARRAY
63868: NONEQUAL
63869: IFFALSE 63881
// begin result := false ;
63871: LD_ADDR_VAR 0 3
63875: PUSH
63876: LD_INT 0
63878: ST_TO_ADDR
// break ;
63879: GO 63883
// end ;
63881: GO 63844
63883: POP
63884: POP
// end else
63885: GO 63895
// result := false ;
63887: LD_ADDR_VAR 0 3
63891: PUSH
63892: LD_INT 0
63894: ST_TO_ADDR
// end ;
63895: LD_VAR 0 3
63899: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63900: LD_INT 0
63902: PPUSH
63903: PPUSH
63904: PPUSH
// pom := GetBase ( fac ) ;
63905: LD_ADDR_VAR 0 5
63909: PUSH
63910: LD_VAR 0 1
63914: PPUSH
63915: CALL_OW 274
63919: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63920: LD_ADDR_VAR 0 4
63924: PUSH
63925: LD_VAR 0 2
63929: PUSH
63930: LD_INT 1
63932: ARRAY
63933: PPUSH
63934: LD_VAR 0 2
63938: PUSH
63939: LD_INT 2
63941: ARRAY
63942: PPUSH
63943: LD_VAR 0 2
63947: PUSH
63948: LD_INT 3
63950: ARRAY
63951: PPUSH
63952: LD_VAR 0 2
63956: PUSH
63957: LD_INT 4
63959: ARRAY
63960: PPUSH
63961: CALL_OW 449
63965: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63966: LD_ADDR_VAR 0 3
63970: PUSH
63971: LD_VAR 0 5
63975: PPUSH
63976: LD_INT 1
63978: PPUSH
63979: CALL_OW 275
63983: PUSH
63984: LD_VAR 0 4
63988: PUSH
63989: LD_INT 1
63991: ARRAY
63992: GREATEREQUAL
63993: PUSH
63994: LD_VAR 0 5
63998: PPUSH
63999: LD_INT 2
64001: PPUSH
64002: CALL_OW 275
64006: PUSH
64007: LD_VAR 0 4
64011: PUSH
64012: LD_INT 2
64014: ARRAY
64015: GREATEREQUAL
64016: AND
64017: PUSH
64018: LD_VAR 0 5
64022: PPUSH
64023: LD_INT 3
64025: PPUSH
64026: CALL_OW 275
64030: PUSH
64031: LD_VAR 0 4
64035: PUSH
64036: LD_INT 3
64038: ARRAY
64039: GREATEREQUAL
64040: AND
64041: ST_TO_ADDR
// end ;
64042: LD_VAR 0 3
64046: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64047: LD_INT 0
64049: PPUSH
64050: PPUSH
64051: PPUSH
64052: PPUSH
// pom := GetBase ( building ) ;
64053: LD_ADDR_VAR 0 3
64057: PUSH
64058: LD_VAR 0 1
64062: PPUSH
64063: CALL_OW 274
64067: ST_TO_ADDR
// if not pom then
64068: LD_VAR 0 3
64072: NOT
64073: IFFALSE 64077
// exit ;
64075: GO 64247
// btype := GetBType ( building ) ;
64077: LD_ADDR_VAR 0 5
64081: PUSH
64082: LD_VAR 0 1
64086: PPUSH
64087: CALL_OW 266
64091: ST_TO_ADDR
// if btype = b_armoury then
64092: LD_VAR 0 5
64096: PUSH
64097: LD_INT 4
64099: EQUAL
64100: IFFALSE 64110
// btype := b_barracks ;
64102: LD_ADDR_VAR 0 5
64106: PUSH
64107: LD_INT 5
64109: ST_TO_ADDR
// if btype = b_depot then
64110: LD_VAR 0 5
64114: PUSH
64115: LD_INT 0
64117: EQUAL
64118: IFFALSE 64128
// btype := b_warehouse ;
64120: LD_ADDR_VAR 0 5
64124: PUSH
64125: LD_INT 1
64127: ST_TO_ADDR
// if btype = b_workshop then
64128: LD_VAR 0 5
64132: PUSH
64133: LD_INT 2
64135: EQUAL
64136: IFFALSE 64146
// btype := b_factory ;
64138: LD_ADDR_VAR 0 5
64142: PUSH
64143: LD_INT 3
64145: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64146: LD_ADDR_VAR 0 4
64150: PUSH
64151: LD_VAR 0 5
64155: PPUSH
64156: LD_VAR 0 1
64160: PPUSH
64161: CALL_OW 248
64165: PPUSH
64166: CALL_OW 450
64170: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64171: LD_ADDR_VAR 0 2
64175: PUSH
64176: LD_VAR 0 3
64180: PPUSH
64181: LD_INT 1
64183: PPUSH
64184: CALL_OW 275
64188: PUSH
64189: LD_VAR 0 4
64193: PUSH
64194: LD_INT 1
64196: ARRAY
64197: GREATEREQUAL
64198: PUSH
64199: LD_VAR 0 3
64203: PPUSH
64204: LD_INT 2
64206: PPUSH
64207: CALL_OW 275
64211: PUSH
64212: LD_VAR 0 4
64216: PUSH
64217: LD_INT 2
64219: ARRAY
64220: GREATEREQUAL
64221: AND
64222: PUSH
64223: LD_VAR 0 3
64227: PPUSH
64228: LD_INT 3
64230: PPUSH
64231: CALL_OW 275
64235: PUSH
64236: LD_VAR 0 4
64240: PUSH
64241: LD_INT 3
64243: ARRAY
64244: GREATEREQUAL
64245: AND
64246: ST_TO_ADDR
// end ;
64247: LD_VAR 0 2
64251: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64252: LD_INT 0
64254: PPUSH
64255: PPUSH
64256: PPUSH
// pom := GetBase ( building ) ;
64257: LD_ADDR_VAR 0 4
64261: PUSH
64262: LD_VAR 0 1
64266: PPUSH
64267: CALL_OW 274
64271: ST_TO_ADDR
// if not pom then
64272: LD_VAR 0 4
64276: NOT
64277: IFFALSE 64281
// exit ;
64279: GO 64382
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64281: LD_ADDR_VAR 0 5
64285: PUSH
64286: LD_VAR 0 2
64290: PPUSH
64291: LD_VAR 0 1
64295: PPUSH
64296: CALL_OW 248
64300: PPUSH
64301: CALL_OW 450
64305: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64306: LD_ADDR_VAR 0 3
64310: PUSH
64311: LD_VAR 0 4
64315: PPUSH
64316: LD_INT 1
64318: PPUSH
64319: CALL_OW 275
64323: PUSH
64324: LD_VAR 0 5
64328: PUSH
64329: LD_INT 1
64331: ARRAY
64332: GREATEREQUAL
64333: PUSH
64334: LD_VAR 0 4
64338: PPUSH
64339: LD_INT 2
64341: PPUSH
64342: CALL_OW 275
64346: PUSH
64347: LD_VAR 0 5
64351: PUSH
64352: LD_INT 2
64354: ARRAY
64355: GREATEREQUAL
64356: AND
64357: PUSH
64358: LD_VAR 0 4
64362: PPUSH
64363: LD_INT 3
64365: PPUSH
64366: CALL_OW 275
64370: PUSH
64371: LD_VAR 0 5
64375: PUSH
64376: LD_INT 3
64378: ARRAY
64379: GREATEREQUAL
64380: AND
64381: ST_TO_ADDR
// end ;
64382: LD_VAR 0 3
64386: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64387: LD_INT 0
64389: PPUSH
64390: PPUSH
64391: PPUSH
64392: PPUSH
64393: PPUSH
64394: PPUSH
64395: PPUSH
64396: PPUSH
64397: PPUSH
64398: PPUSH
// result := false ;
64399: LD_ADDR_VAR 0 6
64403: PUSH
64404: LD_INT 0
64406: ST_TO_ADDR
// if not base or not btype or not x or not y then
64407: LD_VAR 0 1
64411: NOT
64412: PUSH
64413: LD_VAR 0 2
64417: NOT
64418: OR
64419: PUSH
64420: LD_VAR 0 3
64424: NOT
64425: OR
64426: PUSH
64427: LD_VAR 0 4
64431: NOT
64432: OR
64433: IFFALSE 64437
// exit ;
64435: GO 65046
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64437: LD_ADDR_VAR 0 12
64441: PUSH
64442: LD_VAR 0 2
64446: PPUSH
64447: LD_VAR 0 3
64451: PPUSH
64452: LD_VAR 0 4
64456: PPUSH
64457: LD_VAR 0 5
64461: PPUSH
64462: LD_VAR 0 1
64466: PUSH
64467: LD_INT 1
64469: ARRAY
64470: PPUSH
64471: CALL_OW 248
64475: PPUSH
64476: LD_INT 0
64478: PPUSH
64479: CALL 65883 0 6
64483: ST_TO_ADDR
// if not hexes then
64484: LD_VAR 0 12
64488: NOT
64489: IFFALSE 64493
// exit ;
64491: GO 65046
// for i = 1 to hexes do
64493: LD_ADDR_VAR 0 7
64497: PUSH
64498: DOUBLE
64499: LD_INT 1
64501: DEC
64502: ST_TO_ADDR
64503: LD_VAR 0 12
64507: PUSH
64508: FOR_TO
64509: IFFALSE 65044
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64511: LD_ADDR_VAR 0 11
64515: PUSH
64516: LD_VAR 0 12
64520: PUSH
64521: LD_VAR 0 7
64525: ARRAY
64526: PUSH
64527: LD_INT 1
64529: ARRAY
64530: PPUSH
64531: LD_VAR 0 12
64535: PUSH
64536: LD_VAR 0 7
64540: ARRAY
64541: PUSH
64542: LD_INT 2
64544: ARRAY
64545: PPUSH
64546: CALL_OW 428
64550: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64551: LD_VAR 0 12
64555: PUSH
64556: LD_VAR 0 7
64560: ARRAY
64561: PUSH
64562: LD_INT 1
64564: ARRAY
64565: PPUSH
64566: LD_VAR 0 12
64570: PUSH
64571: LD_VAR 0 7
64575: ARRAY
64576: PUSH
64577: LD_INT 2
64579: ARRAY
64580: PPUSH
64581: CALL_OW 351
64585: PUSH
64586: LD_VAR 0 12
64590: PUSH
64591: LD_VAR 0 7
64595: ARRAY
64596: PUSH
64597: LD_INT 1
64599: ARRAY
64600: PPUSH
64601: LD_VAR 0 12
64605: PUSH
64606: LD_VAR 0 7
64610: ARRAY
64611: PUSH
64612: LD_INT 2
64614: ARRAY
64615: PPUSH
64616: CALL_OW 488
64620: NOT
64621: OR
64622: PUSH
64623: LD_VAR 0 11
64627: PPUSH
64628: CALL_OW 247
64632: PUSH
64633: LD_INT 3
64635: EQUAL
64636: OR
64637: IFFALSE 64643
// exit ;
64639: POP
64640: POP
64641: GO 65046
// if not tmp or not tmp in base then
64643: LD_VAR 0 11
64647: NOT
64648: PUSH
64649: LD_VAR 0 11
64653: PUSH
64654: LD_VAR 0 1
64658: IN
64659: NOT
64660: OR
64661: IFFALSE 64665
// continue ;
64663: GO 64508
// result := true ;
64665: LD_ADDR_VAR 0 6
64669: PUSH
64670: LD_INT 1
64672: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64673: LD_ADDR_VAR 0 15
64677: PUSH
64678: LD_VAR 0 1
64682: PPUSH
64683: LD_INT 22
64685: PUSH
64686: LD_VAR 0 11
64690: PPUSH
64691: CALL_OW 255
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: LD_INT 2
64702: PUSH
64703: LD_INT 30
64705: PUSH
64706: LD_INT 0
64708: PUSH
64709: EMPTY
64710: LIST
64711: LIST
64712: PUSH
64713: LD_INT 30
64715: PUSH
64716: LD_INT 1
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: PUSH
64723: EMPTY
64724: LIST
64725: LIST
64726: LIST
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PPUSH
64732: CALL_OW 72
64736: ST_TO_ADDR
// if dep then
64737: LD_VAR 0 15
64741: IFFALSE 64877
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64743: LD_ADDR_VAR 0 14
64747: PUSH
64748: LD_VAR 0 15
64752: PUSH
64753: LD_INT 1
64755: ARRAY
64756: PPUSH
64757: CALL_OW 250
64761: PPUSH
64762: LD_VAR 0 15
64766: PUSH
64767: LD_INT 1
64769: ARRAY
64770: PPUSH
64771: CALL_OW 254
64775: PPUSH
64776: LD_INT 5
64778: PPUSH
64779: CALL_OW 272
64783: PUSH
64784: LD_VAR 0 15
64788: PUSH
64789: LD_INT 1
64791: ARRAY
64792: PPUSH
64793: CALL_OW 251
64797: PPUSH
64798: LD_VAR 0 15
64802: PUSH
64803: LD_INT 1
64805: ARRAY
64806: PPUSH
64807: CALL_OW 254
64811: PPUSH
64812: LD_INT 5
64814: PPUSH
64815: CALL_OW 273
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64824: LD_VAR 0 14
64828: PUSH
64829: LD_INT 1
64831: ARRAY
64832: PPUSH
64833: LD_VAR 0 14
64837: PUSH
64838: LD_INT 2
64840: ARRAY
64841: PPUSH
64842: CALL_OW 488
64846: IFFALSE 64877
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64848: LD_VAR 0 11
64852: PPUSH
64853: LD_VAR 0 14
64857: PUSH
64858: LD_INT 1
64860: ARRAY
64861: PPUSH
64862: LD_VAR 0 14
64866: PUSH
64867: LD_INT 2
64869: ARRAY
64870: PPUSH
64871: CALL_OW 111
// continue ;
64875: GO 64508
// end ; end ; r := GetDir ( tmp ) ;
64877: LD_ADDR_VAR 0 13
64881: PUSH
64882: LD_VAR 0 11
64886: PPUSH
64887: CALL_OW 254
64891: ST_TO_ADDR
// if r = 5 then
64892: LD_VAR 0 13
64896: PUSH
64897: LD_INT 5
64899: EQUAL
64900: IFFALSE 64910
// r := 0 ;
64902: LD_ADDR_VAR 0 13
64906: PUSH
64907: LD_INT 0
64909: ST_TO_ADDR
// for j = r to 5 do
64910: LD_ADDR_VAR 0 8
64914: PUSH
64915: DOUBLE
64916: LD_VAR 0 13
64920: DEC
64921: ST_TO_ADDR
64922: LD_INT 5
64924: PUSH
64925: FOR_TO
64926: IFFALSE 65040
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64928: LD_ADDR_VAR 0 9
64932: PUSH
64933: LD_VAR 0 11
64937: PPUSH
64938: CALL_OW 250
64942: PPUSH
64943: LD_VAR 0 8
64947: PPUSH
64948: LD_INT 2
64950: PPUSH
64951: CALL_OW 272
64955: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64956: LD_ADDR_VAR 0 10
64960: PUSH
64961: LD_VAR 0 11
64965: PPUSH
64966: CALL_OW 251
64970: PPUSH
64971: LD_VAR 0 8
64975: PPUSH
64976: LD_INT 2
64978: PPUSH
64979: CALL_OW 273
64983: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64984: LD_VAR 0 9
64988: PPUSH
64989: LD_VAR 0 10
64993: PPUSH
64994: CALL_OW 488
64998: PUSH
64999: LD_VAR 0 9
65003: PPUSH
65004: LD_VAR 0 10
65008: PPUSH
65009: CALL_OW 428
65013: NOT
65014: AND
65015: IFFALSE 65038
// begin ComMoveXY ( tmp , _x , _y ) ;
65017: LD_VAR 0 11
65021: PPUSH
65022: LD_VAR 0 9
65026: PPUSH
65027: LD_VAR 0 10
65031: PPUSH
65032: CALL_OW 111
// break ;
65036: GO 65040
// end ; end ;
65038: GO 64925
65040: POP
65041: POP
// end ;
65042: GO 64508
65044: POP
65045: POP
// end ;
65046: LD_VAR 0 6
65050: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
65051: LD_INT 0
65053: PPUSH
65054: PPUSH
65055: PPUSH
65056: PPUSH
65057: PPUSH
65058: PPUSH
65059: PPUSH
65060: PPUSH
65061: PPUSH
65062: PPUSH
// result := false ;
65063: LD_ADDR_VAR 0 6
65067: PUSH
65068: LD_INT 0
65070: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65071: LD_VAR 0 1
65075: NOT
65076: PUSH
65077: LD_VAR 0 1
65081: PPUSH
65082: CALL_OW 266
65086: PUSH
65087: LD_INT 0
65089: PUSH
65090: LD_INT 1
65092: PUSH
65093: EMPTY
65094: LIST
65095: LIST
65096: IN
65097: NOT
65098: OR
65099: PUSH
65100: LD_VAR 0 2
65104: NOT
65105: OR
65106: PUSH
65107: LD_VAR 0 5
65111: PUSH
65112: LD_INT 0
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: LD_INT 2
65120: PUSH
65121: LD_INT 3
65123: PUSH
65124: LD_INT 4
65126: PUSH
65127: LD_INT 5
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: IN
65138: NOT
65139: OR
65140: PUSH
65141: LD_VAR 0 3
65145: PPUSH
65146: LD_VAR 0 4
65150: PPUSH
65151: CALL_OW 488
65155: NOT
65156: OR
65157: IFFALSE 65161
// exit ;
65159: GO 65878
// pom := GetBase ( depot ) ;
65161: LD_ADDR_VAR 0 10
65165: PUSH
65166: LD_VAR 0 1
65170: PPUSH
65171: CALL_OW 274
65175: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65176: LD_ADDR_VAR 0 11
65180: PUSH
65181: LD_VAR 0 2
65185: PPUSH
65186: LD_VAR 0 1
65190: PPUSH
65191: CALL_OW 248
65195: PPUSH
65196: CALL_OW 450
65200: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65201: LD_VAR 0 10
65205: PPUSH
65206: LD_INT 1
65208: PPUSH
65209: CALL_OW 275
65213: PUSH
65214: LD_VAR 0 11
65218: PUSH
65219: LD_INT 1
65221: ARRAY
65222: GREATEREQUAL
65223: PUSH
65224: LD_VAR 0 10
65228: PPUSH
65229: LD_INT 2
65231: PPUSH
65232: CALL_OW 275
65236: PUSH
65237: LD_VAR 0 11
65241: PUSH
65242: LD_INT 2
65244: ARRAY
65245: GREATEREQUAL
65246: AND
65247: PUSH
65248: LD_VAR 0 10
65252: PPUSH
65253: LD_INT 3
65255: PPUSH
65256: CALL_OW 275
65260: PUSH
65261: LD_VAR 0 11
65265: PUSH
65266: LD_INT 3
65268: ARRAY
65269: GREATEREQUAL
65270: AND
65271: NOT
65272: IFFALSE 65276
// exit ;
65274: GO 65878
// if GetBType ( depot ) = b_depot then
65276: LD_VAR 0 1
65280: PPUSH
65281: CALL_OW 266
65285: PUSH
65286: LD_INT 0
65288: EQUAL
65289: IFFALSE 65301
// dist := 28 else
65291: LD_ADDR_VAR 0 14
65295: PUSH
65296: LD_INT 28
65298: ST_TO_ADDR
65299: GO 65309
// dist := 36 ;
65301: LD_ADDR_VAR 0 14
65305: PUSH
65306: LD_INT 36
65308: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65309: LD_VAR 0 1
65313: PPUSH
65314: LD_VAR 0 3
65318: PPUSH
65319: LD_VAR 0 4
65323: PPUSH
65324: CALL_OW 297
65328: PUSH
65329: LD_VAR 0 14
65333: GREATER
65334: IFFALSE 65338
// exit ;
65336: GO 65878
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65338: LD_ADDR_VAR 0 12
65342: PUSH
65343: LD_VAR 0 2
65347: PPUSH
65348: LD_VAR 0 3
65352: PPUSH
65353: LD_VAR 0 4
65357: PPUSH
65358: LD_VAR 0 5
65362: PPUSH
65363: LD_VAR 0 1
65367: PPUSH
65368: CALL_OW 248
65372: PPUSH
65373: LD_INT 0
65375: PPUSH
65376: CALL 65883 0 6
65380: ST_TO_ADDR
// if not hexes then
65381: LD_VAR 0 12
65385: NOT
65386: IFFALSE 65390
// exit ;
65388: GO 65878
// hex := GetHexInfo ( x , y ) ;
65390: LD_ADDR_VAR 0 15
65394: PUSH
65395: LD_VAR 0 3
65399: PPUSH
65400: LD_VAR 0 4
65404: PPUSH
65405: CALL_OW 546
65409: ST_TO_ADDR
// if hex [ 1 ] then
65410: LD_VAR 0 15
65414: PUSH
65415: LD_INT 1
65417: ARRAY
65418: IFFALSE 65422
// exit ;
65420: GO 65878
// height := hex [ 2 ] ;
65422: LD_ADDR_VAR 0 13
65426: PUSH
65427: LD_VAR 0 15
65431: PUSH
65432: LD_INT 2
65434: ARRAY
65435: ST_TO_ADDR
// for i = 1 to hexes do
65436: LD_ADDR_VAR 0 7
65440: PUSH
65441: DOUBLE
65442: LD_INT 1
65444: DEC
65445: ST_TO_ADDR
65446: LD_VAR 0 12
65450: PUSH
65451: FOR_TO
65452: IFFALSE 65782
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65454: LD_VAR 0 12
65458: PUSH
65459: LD_VAR 0 7
65463: ARRAY
65464: PUSH
65465: LD_INT 1
65467: ARRAY
65468: PPUSH
65469: LD_VAR 0 12
65473: PUSH
65474: LD_VAR 0 7
65478: ARRAY
65479: PUSH
65480: LD_INT 2
65482: ARRAY
65483: PPUSH
65484: CALL_OW 488
65488: NOT
65489: PUSH
65490: LD_VAR 0 12
65494: PUSH
65495: LD_VAR 0 7
65499: ARRAY
65500: PUSH
65501: LD_INT 1
65503: ARRAY
65504: PPUSH
65505: LD_VAR 0 12
65509: PUSH
65510: LD_VAR 0 7
65514: ARRAY
65515: PUSH
65516: LD_INT 2
65518: ARRAY
65519: PPUSH
65520: CALL_OW 428
65524: PUSH
65525: LD_INT 0
65527: GREATER
65528: OR
65529: PUSH
65530: LD_VAR 0 12
65534: PUSH
65535: LD_VAR 0 7
65539: ARRAY
65540: PUSH
65541: LD_INT 1
65543: ARRAY
65544: PPUSH
65545: LD_VAR 0 12
65549: PUSH
65550: LD_VAR 0 7
65554: ARRAY
65555: PUSH
65556: LD_INT 2
65558: ARRAY
65559: PPUSH
65560: CALL_OW 351
65564: OR
65565: IFFALSE 65571
// exit ;
65567: POP
65568: POP
65569: GO 65878
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65571: LD_ADDR_VAR 0 8
65575: PUSH
65576: LD_VAR 0 12
65580: PUSH
65581: LD_VAR 0 7
65585: ARRAY
65586: PUSH
65587: LD_INT 1
65589: ARRAY
65590: PPUSH
65591: LD_VAR 0 12
65595: PUSH
65596: LD_VAR 0 7
65600: ARRAY
65601: PUSH
65602: LD_INT 2
65604: ARRAY
65605: PPUSH
65606: CALL_OW 546
65610: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65611: LD_VAR 0 8
65615: PUSH
65616: LD_INT 1
65618: ARRAY
65619: PUSH
65620: LD_VAR 0 8
65624: PUSH
65625: LD_INT 2
65627: ARRAY
65628: PUSH
65629: LD_VAR 0 13
65633: PUSH
65634: LD_INT 2
65636: PLUS
65637: GREATER
65638: OR
65639: PUSH
65640: LD_VAR 0 8
65644: PUSH
65645: LD_INT 2
65647: ARRAY
65648: PUSH
65649: LD_VAR 0 13
65653: PUSH
65654: LD_INT 2
65656: MINUS
65657: LESS
65658: OR
65659: PUSH
65660: LD_VAR 0 8
65664: PUSH
65665: LD_INT 3
65667: ARRAY
65668: PUSH
65669: LD_INT 0
65671: PUSH
65672: LD_INT 8
65674: PUSH
65675: LD_INT 9
65677: PUSH
65678: LD_INT 10
65680: PUSH
65681: LD_INT 11
65683: PUSH
65684: LD_INT 12
65686: PUSH
65687: LD_INT 13
65689: PUSH
65690: LD_INT 16
65692: PUSH
65693: LD_INT 17
65695: PUSH
65696: LD_INT 18
65698: PUSH
65699: LD_INT 19
65701: PUSH
65702: LD_INT 20
65704: PUSH
65705: LD_INT 21
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: IN
65723: NOT
65724: OR
65725: PUSH
65726: LD_VAR 0 8
65730: PUSH
65731: LD_INT 5
65733: ARRAY
65734: NOT
65735: OR
65736: PUSH
65737: LD_VAR 0 8
65741: PUSH
65742: LD_INT 6
65744: ARRAY
65745: PUSH
65746: LD_INT 1
65748: PUSH
65749: LD_INT 2
65751: PUSH
65752: LD_INT 7
65754: PUSH
65755: LD_INT 9
65757: PUSH
65758: LD_INT 10
65760: PUSH
65761: LD_INT 11
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: LIST
65768: LIST
65769: LIST
65770: LIST
65771: IN
65772: NOT
65773: OR
65774: IFFALSE 65780
// exit ;
65776: POP
65777: POP
65778: GO 65878
// end ;
65780: GO 65451
65782: POP
65783: POP
// side := GetSide ( depot ) ;
65784: LD_ADDR_VAR 0 9
65788: PUSH
65789: LD_VAR 0 1
65793: PPUSH
65794: CALL_OW 255
65798: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65799: LD_VAR 0 9
65803: PPUSH
65804: LD_VAR 0 3
65808: PPUSH
65809: LD_VAR 0 4
65813: PPUSH
65814: LD_INT 20
65816: PPUSH
65817: CALL 58532 0 4
65821: PUSH
65822: LD_INT 4
65824: ARRAY
65825: IFFALSE 65829
// exit ;
65827: GO 65878
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65829: LD_VAR 0 2
65833: PUSH
65834: LD_INT 29
65836: PUSH
65837: LD_INT 30
65839: PUSH
65840: EMPTY
65841: LIST
65842: LIST
65843: IN
65844: PUSH
65845: LD_VAR 0 3
65849: PPUSH
65850: LD_VAR 0 4
65854: PPUSH
65855: LD_VAR 0 9
65859: PPUSH
65860: CALL_OW 440
65864: NOT
65865: AND
65866: IFFALSE 65870
// exit ;
65868: GO 65878
// result := true ;
65870: LD_ADDR_VAR 0 6
65874: PUSH
65875: LD_INT 1
65877: ST_TO_ADDR
// end ;
65878: LD_VAR 0 6
65882: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65883: LD_INT 0
65885: PPUSH
65886: PPUSH
65887: PPUSH
65888: PPUSH
65889: PPUSH
65890: PPUSH
65891: PPUSH
65892: PPUSH
65893: PPUSH
65894: PPUSH
65895: PPUSH
65896: PPUSH
65897: PPUSH
65898: PPUSH
65899: PPUSH
65900: PPUSH
65901: PPUSH
65902: PPUSH
65903: PPUSH
65904: PPUSH
65905: PPUSH
65906: PPUSH
65907: PPUSH
65908: PPUSH
65909: PPUSH
65910: PPUSH
65911: PPUSH
65912: PPUSH
65913: PPUSH
65914: PPUSH
65915: PPUSH
65916: PPUSH
65917: PPUSH
65918: PPUSH
65919: PPUSH
65920: PPUSH
65921: PPUSH
65922: PPUSH
65923: PPUSH
65924: PPUSH
65925: PPUSH
65926: PPUSH
65927: PPUSH
65928: PPUSH
65929: PPUSH
65930: PPUSH
65931: PPUSH
65932: PPUSH
65933: PPUSH
65934: PPUSH
65935: PPUSH
65936: PPUSH
65937: PPUSH
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
65942: PPUSH
// result = [ ] ;
65943: LD_ADDR_VAR 0 7
65947: PUSH
65948: EMPTY
65949: ST_TO_ADDR
// temp_list = [ ] ;
65950: LD_ADDR_VAR 0 9
65954: PUSH
65955: EMPTY
65956: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65957: LD_VAR 0 4
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: LD_INT 1
65967: PUSH
65968: LD_INT 2
65970: PUSH
65971: LD_INT 3
65973: PUSH
65974: LD_INT 4
65976: PUSH
65977: LD_INT 5
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: LIST
65987: IN
65988: NOT
65989: PUSH
65990: LD_VAR 0 1
65994: PUSH
65995: LD_INT 0
65997: PUSH
65998: LD_INT 1
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: IN
66005: PUSH
66006: LD_VAR 0 5
66010: PUSH
66011: LD_INT 1
66013: PUSH
66014: LD_INT 2
66016: PUSH
66017: LD_INT 3
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: LIST
66024: IN
66025: NOT
66026: AND
66027: OR
66028: IFFALSE 66032
// exit ;
66030: GO 84423
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66032: LD_VAR 0 1
66036: PUSH
66037: LD_INT 6
66039: PUSH
66040: LD_INT 7
66042: PUSH
66043: LD_INT 8
66045: PUSH
66046: LD_INT 13
66048: PUSH
66049: LD_INT 12
66051: PUSH
66052: LD_INT 15
66054: PUSH
66055: LD_INT 11
66057: PUSH
66058: LD_INT 14
66060: PUSH
66061: LD_INT 10
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: IN
66075: IFFALSE 66085
// btype = b_lab ;
66077: LD_ADDR_VAR 0 1
66081: PUSH
66082: LD_INT 6
66084: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66085: LD_VAR 0 6
66089: PUSH
66090: LD_INT 0
66092: PUSH
66093: LD_INT 1
66095: PUSH
66096: LD_INT 2
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: LIST
66103: IN
66104: NOT
66105: PUSH
66106: LD_VAR 0 1
66110: PUSH
66111: LD_INT 0
66113: PUSH
66114: LD_INT 1
66116: PUSH
66117: LD_INT 2
66119: PUSH
66120: LD_INT 3
66122: PUSH
66123: LD_INT 6
66125: PUSH
66126: LD_INT 36
66128: PUSH
66129: LD_INT 4
66131: PUSH
66132: LD_INT 5
66134: PUSH
66135: LD_INT 31
66137: PUSH
66138: LD_INT 32
66140: PUSH
66141: LD_INT 33
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: IN
66157: NOT
66158: PUSH
66159: LD_VAR 0 6
66163: PUSH
66164: LD_INT 1
66166: EQUAL
66167: AND
66168: OR
66169: PUSH
66170: LD_VAR 0 1
66174: PUSH
66175: LD_INT 2
66177: PUSH
66178: LD_INT 3
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: IN
66185: NOT
66186: PUSH
66187: LD_VAR 0 6
66191: PUSH
66192: LD_INT 2
66194: EQUAL
66195: AND
66196: OR
66197: IFFALSE 66207
// mode = 0 ;
66199: LD_ADDR_VAR 0 6
66203: PUSH
66204: LD_INT 0
66206: ST_TO_ADDR
// case mode of 0 :
66207: LD_VAR 0 6
66211: PUSH
66212: LD_INT 0
66214: DOUBLE
66215: EQUAL
66216: IFTRUE 66220
66218: GO 77673
66220: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66221: LD_ADDR_VAR 0 11
66225: PUSH
66226: LD_INT 0
66228: PUSH
66229: LD_INT 0
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 0
66238: PUSH
66239: LD_INT 1
66241: NEG
66242: PUSH
66243: EMPTY
66244: LIST
66245: LIST
66246: PUSH
66247: LD_INT 1
66249: PUSH
66250: LD_INT 0
66252: PUSH
66253: EMPTY
66254: LIST
66255: LIST
66256: PUSH
66257: LD_INT 1
66259: PUSH
66260: LD_INT 1
66262: PUSH
66263: EMPTY
66264: LIST
66265: LIST
66266: PUSH
66267: LD_INT 0
66269: PUSH
66270: LD_INT 1
66272: PUSH
66273: EMPTY
66274: LIST
66275: LIST
66276: PUSH
66277: LD_INT 1
66279: NEG
66280: PUSH
66281: LD_INT 0
66283: PUSH
66284: EMPTY
66285: LIST
66286: LIST
66287: PUSH
66288: LD_INT 1
66290: NEG
66291: PUSH
66292: LD_INT 1
66294: NEG
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: LD_INT 1
66302: NEG
66303: PUSH
66304: LD_INT 2
66306: NEG
66307: PUSH
66308: EMPTY
66309: LIST
66310: LIST
66311: PUSH
66312: LD_INT 0
66314: PUSH
66315: LD_INT 2
66317: NEG
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 1
66325: PUSH
66326: LD_INT 1
66328: NEG
66329: PUSH
66330: EMPTY
66331: LIST
66332: LIST
66333: PUSH
66334: LD_INT 1
66336: PUSH
66337: LD_INT 2
66339: PUSH
66340: EMPTY
66341: LIST
66342: LIST
66343: PUSH
66344: LD_INT 0
66346: PUSH
66347: LD_INT 2
66349: PUSH
66350: EMPTY
66351: LIST
66352: LIST
66353: PUSH
66354: LD_INT 1
66356: NEG
66357: PUSH
66358: LD_INT 1
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: PUSH
66365: LD_INT 1
66367: PUSH
66368: LD_INT 3
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: LD_INT 0
66377: PUSH
66378: LD_INT 3
66380: PUSH
66381: EMPTY
66382: LIST
66383: LIST
66384: PUSH
66385: LD_INT 1
66387: NEG
66388: PUSH
66389: LD_INT 2
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66414: LD_ADDR_VAR 0 12
66418: PUSH
66419: LD_INT 0
66421: PUSH
66422: LD_INT 0
66424: PUSH
66425: EMPTY
66426: LIST
66427: LIST
66428: PUSH
66429: LD_INT 0
66431: PUSH
66432: LD_INT 1
66434: NEG
66435: PUSH
66436: EMPTY
66437: LIST
66438: LIST
66439: PUSH
66440: LD_INT 1
66442: PUSH
66443: LD_INT 0
66445: PUSH
66446: EMPTY
66447: LIST
66448: LIST
66449: PUSH
66450: LD_INT 1
66452: PUSH
66453: LD_INT 1
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: LD_INT 0
66462: PUSH
66463: LD_INT 1
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 1
66472: NEG
66473: PUSH
66474: LD_INT 0
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: LD_INT 1
66483: NEG
66484: PUSH
66485: LD_INT 1
66487: NEG
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: LD_INT 1
66495: PUSH
66496: LD_INT 1
66498: NEG
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 2
66506: PUSH
66507: LD_INT 0
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 2
66516: PUSH
66517: LD_INT 1
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 1
66526: NEG
66527: PUSH
66528: LD_INT 1
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 2
66537: NEG
66538: PUSH
66539: LD_INT 0
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 2
66548: NEG
66549: PUSH
66550: LD_INT 1
66552: NEG
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: LD_INT 2
66560: NEG
66561: PUSH
66562: LD_INT 1
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 3
66571: NEG
66572: PUSH
66573: LD_INT 0
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 3
66582: NEG
66583: PUSH
66584: LD_INT 1
66586: NEG
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: LIST
66598: LIST
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66610: LD_ADDR_VAR 0 13
66614: PUSH
66615: LD_INT 0
66617: PUSH
66618: LD_INT 0
66620: PUSH
66621: EMPTY
66622: LIST
66623: LIST
66624: PUSH
66625: LD_INT 0
66627: PUSH
66628: LD_INT 1
66630: NEG
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: LD_INT 1
66638: PUSH
66639: LD_INT 0
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 1
66648: PUSH
66649: LD_INT 1
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PUSH
66656: LD_INT 0
66658: PUSH
66659: LD_INT 1
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: PUSH
66666: LD_INT 1
66668: NEG
66669: PUSH
66670: LD_INT 0
66672: PUSH
66673: EMPTY
66674: LIST
66675: LIST
66676: PUSH
66677: LD_INT 1
66679: NEG
66680: PUSH
66681: LD_INT 1
66683: NEG
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 1
66691: NEG
66692: PUSH
66693: LD_INT 2
66695: NEG
66696: PUSH
66697: EMPTY
66698: LIST
66699: LIST
66700: PUSH
66701: LD_INT 2
66703: PUSH
66704: LD_INT 1
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: PUSH
66711: LD_INT 2
66713: PUSH
66714: LD_INT 2
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: PUSH
66721: LD_INT 1
66723: PUSH
66724: LD_INT 2
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: LD_INT 2
66733: NEG
66734: PUSH
66735: LD_INT 1
66737: NEG
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: LD_INT 2
66745: NEG
66746: PUSH
66747: LD_INT 2
66749: NEG
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: LD_INT 2
66757: NEG
66758: PUSH
66759: LD_INT 3
66761: NEG
66762: PUSH
66763: EMPTY
66764: LIST
66765: LIST
66766: PUSH
66767: LD_INT 3
66769: NEG
66770: PUSH
66771: LD_INT 2
66773: NEG
66774: PUSH
66775: EMPTY
66776: LIST
66777: LIST
66778: PUSH
66779: LD_INT 3
66781: NEG
66782: PUSH
66783: LD_INT 3
66785: NEG
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: LIST
66795: LIST
66796: LIST
66797: LIST
66798: LIST
66799: LIST
66800: LIST
66801: LIST
66802: LIST
66803: LIST
66804: LIST
66805: LIST
66806: LIST
66807: LIST
66808: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66809: LD_ADDR_VAR 0 14
66813: PUSH
66814: LD_INT 0
66816: PUSH
66817: LD_INT 0
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: PUSH
66824: LD_INT 0
66826: PUSH
66827: LD_INT 1
66829: NEG
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 1
66837: PUSH
66838: LD_INT 0
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 1
66847: PUSH
66848: LD_INT 1
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 0
66857: PUSH
66858: LD_INT 1
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 1
66867: NEG
66868: PUSH
66869: LD_INT 0
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: LD_INT 1
66878: NEG
66879: PUSH
66880: LD_INT 1
66882: NEG
66883: PUSH
66884: EMPTY
66885: LIST
66886: LIST
66887: PUSH
66888: LD_INT 1
66890: NEG
66891: PUSH
66892: LD_INT 2
66894: NEG
66895: PUSH
66896: EMPTY
66897: LIST
66898: LIST
66899: PUSH
66900: LD_INT 0
66902: PUSH
66903: LD_INT 2
66905: NEG
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 1
66913: PUSH
66914: LD_INT 1
66916: NEG
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 1
66924: PUSH
66925: LD_INT 2
66927: PUSH
66928: EMPTY
66929: LIST
66930: LIST
66931: PUSH
66932: LD_INT 0
66934: PUSH
66935: LD_INT 2
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: LD_INT 1
66944: NEG
66945: PUSH
66946: LD_INT 1
66948: PUSH
66949: EMPTY
66950: LIST
66951: LIST
66952: PUSH
66953: LD_INT 1
66955: NEG
66956: PUSH
66957: LD_INT 3
66959: NEG
66960: PUSH
66961: EMPTY
66962: LIST
66963: LIST
66964: PUSH
66965: LD_INT 0
66967: PUSH
66968: LD_INT 3
66970: NEG
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PUSH
66976: LD_INT 1
66978: PUSH
66979: LD_INT 2
66981: NEG
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67005: LD_ADDR_VAR 0 15
67009: PUSH
67010: LD_INT 0
67012: PUSH
67013: LD_INT 0
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: LD_INT 1
67025: NEG
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: LD_INT 1
67033: PUSH
67034: LD_INT 0
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PUSH
67041: LD_INT 1
67043: PUSH
67044: LD_INT 1
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 0
67053: PUSH
67054: LD_INT 1
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 1
67063: NEG
67064: PUSH
67065: LD_INT 0
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: PUSH
67072: LD_INT 1
67074: NEG
67075: PUSH
67076: LD_INT 1
67078: NEG
67079: PUSH
67080: EMPTY
67081: LIST
67082: LIST
67083: PUSH
67084: LD_INT 1
67086: PUSH
67087: LD_INT 1
67089: NEG
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: LD_INT 2
67097: PUSH
67098: LD_INT 0
67100: PUSH
67101: EMPTY
67102: LIST
67103: LIST
67104: PUSH
67105: LD_INT 2
67107: PUSH
67108: LD_INT 1
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 1
67117: NEG
67118: PUSH
67119: LD_INT 1
67121: PUSH
67122: EMPTY
67123: LIST
67124: LIST
67125: PUSH
67126: LD_INT 2
67128: NEG
67129: PUSH
67130: LD_INT 0
67132: PUSH
67133: EMPTY
67134: LIST
67135: LIST
67136: PUSH
67137: LD_INT 2
67139: NEG
67140: PUSH
67141: LD_INT 1
67143: NEG
67144: PUSH
67145: EMPTY
67146: LIST
67147: LIST
67148: PUSH
67149: LD_INT 2
67151: PUSH
67152: LD_INT 1
67154: NEG
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 3
67162: PUSH
67163: LD_INT 0
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: PUSH
67170: LD_INT 3
67172: PUSH
67173: LD_INT 1
67175: PUSH
67176: EMPTY
67177: LIST
67178: LIST
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: LIST
67184: LIST
67185: LIST
67186: LIST
67187: LIST
67188: LIST
67189: LIST
67190: LIST
67191: LIST
67192: LIST
67193: LIST
67194: LIST
67195: LIST
67196: LIST
67197: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67198: LD_ADDR_VAR 0 16
67202: PUSH
67203: LD_INT 0
67205: PUSH
67206: LD_INT 0
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: LD_INT 0
67215: PUSH
67216: LD_INT 1
67218: NEG
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 1
67226: PUSH
67227: LD_INT 0
67229: PUSH
67230: EMPTY
67231: LIST
67232: LIST
67233: PUSH
67234: LD_INT 1
67236: PUSH
67237: LD_INT 1
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 0
67246: PUSH
67247: LD_INT 1
67249: PUSH
67250: EMPTY
67251: LIST
67252: LIST
67253: PUSH
67254: LD_INT 1
67256: NEG
67257: PUSH
67258: LD_INT 0
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PUSH
67265: LD_INT 1
67267: NEG
67268: PUSH
67269: LD_INT 1
67271: NEG
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PUSH
67277: LD_INT 1
67279: NEG
67280: PUSH
67281: LD_INT 2
67283: NEG
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: PUSH
67289: LD_INT 2
67291: PUSH
67292: LD_INT 1
67294: PUSH
67295: EMPTY
67296: LIST
67297: LIST
67298: PUSH
67299: LD_INT 2
67301: PUSH
67302: LD_INT 2
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 1
67311: PUSH
67312: LD_INT 2
67314: PUSH
67315: EMPTY
67316: LIST
67317: LIST
67318: PUSH
67319: LD_INT 2
67321: NEG
67322: PUSH
67323: LD_INT 1
67325: NEG
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 2
67333: NEG
67334: PUSH
67335: LD_INT 2
67337: NEG
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 3
67345: PUSH
67346: LD_INT 2
67348: PUSH
67349: EMPTY
67350: LIST
67351: LIST
67352: PUSH
67353: LD_INT 3
67355: PUSH
67356: LD_INT 3
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: PUSH
67363: LD_INT 2
67365: PUSH
67366: LD_INT 3
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67391: LD_ADDR_VAR 0 17
67395: PUSH
67396: LD_INT 0
67398: PUSH
67399: LD_INT 0
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: PUSH
67406: LD_INT 0
67408: PUSH
67409: LD_INT 1
67411: NEG
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: LD_INT 1
67419: PUSH
67420: LD_INT 0
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 1
67429: PUSH
67430: LD_INT 1
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 0
67439: PUSH
67440: LD_INT 1
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 1
67449: NEG
67450: PUSH
67451: LD_INT 0
67453: PUSH
67454: EMPTY
67455: LIST
67456: LIST
67457: PUSH
67458: LD_INT 1
67460: NEG
67461: PUSH
67462: LD_INT 1
67464: NEG
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: LD_INT 1
67472: NEG
67473: PUSH
67474: LD_INT 2
67476: NEG
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 0
67484: PUSH
67485: LD_INT 2
67487: NEG
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 1
67495: PUSH
67496: LD_INT 1
67498: NEG
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 2
67506: PUSH
67507: LD_INT 0
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 2
67516: PUSH
67517: LD_INT 1
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 2
67526: PUSH
67527: LD_INT 2
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: LD_INT 2
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 2
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 1
67556: NEG
67557: PUSH
67558: LD_INT 1
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 2
67567: NEG
67568: PUSH
67569: LD_INT 0
67571: PUSH
67572: EMPTY
67573: LIST
67574: LIST
67575: PUSH
67576: LD_INT 2
67578: NEG
67579: PUSH
67580: LD_INT 1
67582: NEG
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 2
67590: NEG
67591: PUSH
67592: LD_INT 2
67594: NEG
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67621: LD_ADDR_VAR 0 18
67625: PUSH
67626: LD_INT 0
67628: PUSH
67629: LD_INT 0
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PUSH
67636: LD_INT 0
67638: PUSH
67639: LD_INT 1
67641: NEG
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: LD_INT 1
67649: PUSH
67650: LD_INT 0
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 1
67659: PUSH
67660: LD_INT 1
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 0
67669: PUSH
67670: LD_INT 1
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PUSH
67677: LD_INT 1
67679: NEG
67680: PUSH
67681: LD_INT 0
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: PUSH
67688: LD_INT 1
67690: NEG
67691: PUSH
67692: LD_INT 1
67694: NEG
67695: PUSH
67696: EMPTY
67697: LIST
67698: LIST
67699: PUSH
67700: LD_INT 1
67702: NEG
67703: PUSH
67704: LD_INT 2
67706: NEG
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 0
67714: PUSH
67715: LD_INT 2
67717: NEG
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: PUSH
67726: LD_INT 1
67728: NEG
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 2
67736: PUSH
67737: LD_INT 0
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 2
67746: PUSH
67747: LD_INT 1
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 2
67756: PUSH
67757: LD_INT 2
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 1
67766: PUSH
67767: LD_INT 2
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 0
67776: PUSH
67777: LD_INT 2
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 1
67786: NEG
67787: PUSH
67788: LD_INT 1
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 2
67797: NEG
67798: PUSH
67799: LD_INT 0
67801: PUSH
67802: EMPTY
67803: LIST
67804: LIST
67805: PUSH
67806: LD_INT 2
67808: NEG
67809: PUSH
67810: LD_INT 1
67812: NEG
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: PUSH
67818: LD_INT 2
67820: NEG
67821: PUSH
67822: LD_INT 2
67824: NEG
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67851: LD_ADDR_VAR 0 19
67855: PUSH
67856: LD_INT 0
67858: PUSH
67859: LD_INT 0
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: PUSH
67866: LD_INT 0
67868: PUSH
67869: LD_INT 1
67871: NEG
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: LD_INT 0
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PUSH
67887: LD_INT 1
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: LD_INT 0
67899: PUSH
67900: LD_INT 1
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 1
67909: NEG
67910: PUSH
67911: LD_INT 0
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 1
67920: NEG
67921: PUSH
67922: LD_INT 1
67924: NEG
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 1
67932: NEG
67933: PUSH
67934: LD_INT 2
67936: NEG
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 0
67944: PUSH
67945: LD_INT 2
67947: NEG
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 1
67955: PUSH
67956: LD_INT 1
67958: NEG
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 2
67966: PUSH
67967: LD_INT 0
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 2
67976: PUSH
67977: LD_INT 1
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 2
67986: PUSH
67987: LD_INT 2
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 1
67996: PUSH
67997: LD_INT 2
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 0
68006: PUSH
68007: LD_INT 2
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 1
68016: NEG
68017: PUSH
68018: LD_INT 1
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 2
68027: NEG
68028: PUSH
68029: LD_INT 0
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PUSH
68036: LD_INT 2
68038: NEG
68039: PUSH
68040: LD_INT 1
68042: NEG
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 2
68050: NEG
68051: PUSH
68052: LD_INT 2
68054: NEG
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68081: LD_ADDR_VAR 0 20
68085: PUSH
68086: LD_INT 0
68088: PUSH
68089: LD_INT 0
68091: PUSH
68092: EMPTY
68093: LIST
68094: LIST
68095: PUSH
68096: LD_INT 0
68098: PUSH
68099: LD_INT 1
68101: NEG
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: LD_INT 1
68109: PUSH
68110: LD_INT 0
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PUSH
68117: LD_INT 1
68119: PUSH
68120: LD_INT 1
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PUSH
68127: LD_INT 0
68129: PUSH
68130: LD_INT 1
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: LD_INT 1
68139: NEG
68140: PUSH
68141: LD_INT 0
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: LD_INT 1
68150: NEG
68151: PUSH
68152: LD_INT 1
68154: NEG
68155: PUSH
68156: EMPTY
68157: LIST
68158: LIST
68159: PUSH
68160: LD_INT 1
68162: NEG
68163: PUSH
68164: LD_INT 2
68166: NEG
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 0
68174: PUSH
68175: LD_INT 2
68177: NEG
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 1
68185: PUSH
68186: LD_INT 1
68188: NEG
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 2
68196: PUSH
68197: LD_INT 0
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 2
68206: PUSH
68207: LD_INT 1
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 2
68216: PUSH
68217: LD_INT 2
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 1
68226: PUSH
68227: LD_INT 2
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 0
68236: PUSH
68237: LD_INT 2
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: LD_INT 1
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 2
68257: NEG
68258: PUSH
68259: LD_INT 0
68261: PUSH
68262: EMPTY
68263: LIST
68264: LIST
68265: PUSH
68266: LD_INT 2
68268: NEG
68269: PUSH
68270: LD_INT 1
68272: NEG
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 2
68280: NEG
68281: PUSH
68282: LD_INT 2
68284: NEG
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68311: LD_ADDR_VAR 0 21
68315: PUSH
68316: LD_INT 0
68318: PUSH
68319: LD_INT 0
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 0
68328: PUSH
68329: LD_INT 1
68331: NEG
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 1
68339: PUSH
68340: LD_INT 0
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 1
68349: PUSH
68350: LD_INT 1
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 0
68359: PUSH
68360: LD_INT 1
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 1
68369: NEG
68370: PUSH
68371: LD_INT 0
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 1
68380: NEG
68381: PUSH
68382: LD_INT 1
68384: NEG
68385: PUSH
68386: EMPTY
68387: LIST
68388: LIST
68389: PUSH
68390: LD_INT 1
68392: NEG
68393: PUSH
68394: LD_INT 2
68396: NEG
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 0
68404: PUSH
68405: LD_INT 2
68407: NEG
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 1
68415: PUSH
68416: LD_INT 1
68418: NEG
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 2
68426: PUSH
68427: LD_INT 0
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 2
68436: PUSH
68437: LD_INT 1
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: LD_INT 2
68446: PUSH
68447: LD_INT 2
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 1
68456: PUSH
68457: LD_INT 2
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 0
68466: PUSH
68467: LD_INT 2
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 1
68476: NEG
68477: PUSH
68478: LD_INT 1
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: LD_INT 2
68487: NEG
68488: PUSH
68489: LD_INT 0
68491: PUSH
68492: EMPTY
68493: LIST
68494: LIST
68495: PUSH
68496: LD_INT 2
68498: NEG
68499: PUSH
68500: LD_INT 1
68502: NEG
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PUSH
68508: LD_INT 2
68510: NEG
68511: PUSH
68512: LD_INT 2
68514: NEG
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: LIST
68540: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68541: LD_ADDR_VAR 0 22
68545: PUSH
68546: LD_INT 0
68548: PUSH
68549: LD_INT 0
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PUSH
68556: LD_INT 0
68558: PUSH
68559: LD_INT 1
68561: NEG
68562: PUSH
68563: EMPTY
68564: LIST
68565: LIST
68566: PUSH
68567: LD_INT 1
68569: PUSH
68570: LD_INT 0
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 1
68579: PUSH
68580: LD_INT 1
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: PUSH
68587: LD_INT 0
68589: PUSH
68590: LD_INT 1
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 1
68599: NEG
68600: PUSH
68601: LD_INT 0
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: PUSH
68608: LD_INT 1
68610: NEG
68611: PUSH
68612: LD_INT 1
68614: NEG
68615: PUSH
68616: EMPTY
68617: LIST
68618: LIST
68619: PUSH
68620: LD_INT 1
68622: NEG
68623: PUSH
68624: LD_INT 2
68626: NEG
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 0
68634: PUSH
68635: LD_INT 2
68637: NEG
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 1
68645: PUSH
68646: LD_INT 1
68648: NEG
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: PUSH
68654: LD_INT 2
68656: PUSH
68657: LD_INT 0
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 2
68666: PUSH
68667: LD_INT 1
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: LD_INT 2
68676: PUSH
68677: LD_INT 2
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 1
68686: PUSH
68687: LD_INT 2
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 0
68696: PUSH
68697: LD_INT 2
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: LD_INT 1
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 2
68717: NEG
68718: PUSH
68719: LD_INT 0
68721: PUSH
68722: EMPTY
68723: LIST
68724: LIST
68725: PUSH
68726: LD_INT 2
68728: NEG
68729: PUSH
68730: LD_INT 1
68732: NEG
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 2
68740: NEG
68741: PUSH
68742: LD_INT 2
68744: NEG
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: LIST
68770: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68771: LD_ADDR_VAR 0 23
68775: PUSH
68776: LD_INT 0
68778: PUSH
68779: LD_INT 0
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: PUSH
68786: LD_INT 0
68788: PUSH
68789: LD_INT 1
68791: NEG
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: PUSH
68797: LD_INT 1
68799: PUSH
68800: LD_INT 0
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 1
68809: PUSH
68810: LD_INT 1
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: LD_INT 0
68819: PUSH
68820: LD_INT 1
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 1
68829: NEG
68830: PUSH
68831: LD_INT 0
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PUSH
68838: LD_INT 1
68840: NEG
68841: PUSH
68842: LD_INT 1
68844: NEG
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: LD_INT 1
68852: NEG
68853: PUSH
68854: LD_INT 2
68856: NEG
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 0
68864: PUSH
68865: LD_INT 2
68867: NEG
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 1
68875: PUSH
68876: LD_INT 1
68878: NEG
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: PUSH
68884: LD_INT 2
68886: PUSH
68887: LD_INT 0
68889: PUSH
68890: EMPTY
68891: LIST
68892: LIST
68893: PUSH
68894: LD_INT 2
68896: PUSH
68897: LD_INT 1
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 2
68906: PUSH
68907: LD_INT 2
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 1
68916: PUSH
68917: LD_INT 2
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 0
68926: PUSH
68927: LD_INT 2
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 1
68936: NEG
68937: PUSH
68938: LD_INT 1
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 2
68947: NEG
68948: PUSH
68949: LD_INT 0
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: PUSH
68956: LD_INT 2
68958: NEG
68959: PUSH
68960: LD_INT 1
68962: NEG
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: NEG
68971: PUSH
68972: LD_INT 2
68974: NEG
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 2
68982: NEG
68983: PUSH
68984: LD_INT 3
68986: NEG
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 1
68994: NEG
68995: PUSH
68996: LD_INT 3
68998: NEG
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 1
69006: PUSH
69007: LD_INT 2
69009: NEG
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 2
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: LIST
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: LIST
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69051: LD_ADDR_VAR 0 24
69055: PUSH
69056: LD_INT 0
69058: PUSH
69059: LD_INT 0
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 0
69068: PUSH
69069: LD_INT 1
69071: NEG
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: PUSH
69077: LD_INT 1
69079: PUSH
69080: LD_INT 0
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 1
69089: PUSH
69090: LD_INT 1
69092: PUSH
69093: EMPTY
69094: LIST
69095: LIST
69096: PUSH
69097: LD_INT 0
69099: PUSH
69100: LD_INT 1
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PUSH
69107: LD_INT 1
69109: NEG
69110: PUSH
69111: LD_INT 0
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 1
69120: NEG
69121: PUSH
69122: LD_INT 1
69124: NEG
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 1
69132: NEG
69133: PUSH
69134: LD_INT 2
69136: NEG
69137: PUSH
69138: EMPTY
69139: LIST
69140: LIST
69141: PUSH
69142: LD_INT 0
69144: PUSH
69145: LD_INT 2
69147: NEG
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 1
69155: PUSH
69156: LD_INT 1
69158: NEG
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: LD_INT 2
69166: PUSH
69167: LD_INT 0
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 2
69176: PUSH
69177: LD_INT 1
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 2
69186: PUSH
69187: LD_INT 2
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 1
69196: PUSH
69197: LD_INT 2
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 0
69206: PUSH
69207: LD_INT 2
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: LD_INT 1
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 2
69227: NEG
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 2
69238: NEG
69239: PUSH
69240: LD_INT 1
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 2
69250: NEG
69251: PUSH
69252: LD_INT 2
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: LD_INT 2
69265: NEG
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: LD_INT 1
69276: NEG
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 3
69284: PUSH
69285: LD_INT 1
69287: PUSH
69288: EMPTY
69289: LIST
69290: LIST
69291: PUSH
69292: LD_INT 3
69294: PUSH
69295: LD_INT 2
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69327: LD_ADDR_VAR 0 25
69331: PUSH
69332: LD_INT 0
69334: PUSH
69335: LD_INT 0
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: LD_INT 0
69344: PUSH
69345: LD_INT 1
69347: NEG
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PUSH
69353: LD_INT 1
69355: PUSH
69356: LD_INT 0
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 1
69365: PUSH
69366: LD_INT 1
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: LD_INT 0
69375: PUSH
69376: LD_INT 1
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 1
69385: NEG
69386: PUSH
69387: LD_INT 0
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 1
69396: NEG
69397: PUSH
69398: LD_INT 1
69400: NEG
69401: PUSH
69402: EMPTY
69403: LIST
69404: LIST
69405: PUSH
69406: LD_INT 1
69408: NEG
69409: PUSH
69410: LD_INT 2
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 0
69420: PUSH
69421: LD_INT 2
69423: NEG
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 1
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 2
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 2
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 2
69462: PUSH
69463: LD_INT 2
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: PUSH
69473: LD_INT 2
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 0
69482: PUSH
69483: LD_INT 2
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: LD_INT 1
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 2
69503: NEG
69504: PUSH
69505: LD_INT 0
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 2
69514: NEG
69515: PUSH
69516: LD_INT 1
69518: NEG
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 2
69526: NEG
69527: PUSH
69528: LD_INT 2
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 3
69538: PUSH
69539: LD_INT 1
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: PUSH
69546: LD_INT 3
69548: PUSH
69549: LD_INT 2
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 2
69558: PUSH
69559: LD_INT 3
69561: PUSH
69562: EMPTY
69563: LIST
69564: LIST
69565: PUSH
69566: LD_INT 1
69568: PUSH
69569: LD_INT 3
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69601: LD_ADDR_VAR 0 26
69605: PUSH
69606: LD_INT 0
69608: PUSH
69609: LD_INT 0
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 0
69618: PUSH
69619: LD_INT 1
69621: NEG
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 1
69629: PUSH
69630: LD_INT 0
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 1
69639: PUSH
69640: LD_INT 1
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 0
69649: PUSH
69650: LD_INT 1
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 1
69659: NEG
69660: PUSH
69661: LD_INT 0
69663: PUSH
69664: EMPTY
69665: LIST
69666: LIST
69667: PUSH
69668: LD_INT 1
69670: NEG
69671: PUSH
69672: LD_INT 1
69674: NEG
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: LD_INT 2
69686: NEG
69687: PUSH
69688: EMPTY
69689: LIST
69690: LIST
69691: PUSH
69692: LD_INT 0
69694: PUSH
69695: LD_INT 2
69697: NEG
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 1
69705: PUSH
69706: LD_INT 1
69708: NEG
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 2
69716: PUSH
69717: LD_INT 0
69719: PUSH
69720: EMPTY
69721: LIST
69722: LIST
69723: PUSH
69724: LD_INT 2
69726: PUSH
69727: LD_INT 1
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 2
69736: PUSH
69737: LD_INT 2
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 1
69746: PUSH
69747: LD_INT 2
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 0
69756: PUSH
69757: LD_INT 2
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: LD_INT 1
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 2
69777: NEG
69778: PUSH
69779: LD_INT 0
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: PUSH
69786: LD_INT 2
69788: NEG
69789: PUSH
69790: LD_INT 1
69792: NEG
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: LD_INT 2
69800: NEG
69801: PUSH
69802: LD_INT 2
69804: NEG
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 2
69812: PUSH
69813: LD_INT 3
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 1
69822: PUSH
69823: LD_INT 3
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 1
69832: NEG
69833: PUSH
69834: LD_INT 2
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: LD_INT 2
69843: NEG
69844: PUSH
69845: LD_INT 1
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69877: LD_ADDR_VAR 0 27
69881: PUSH
69882: LD_INT 0
69884: PUSH
69885: LD_INT 0
69887: PUSH
69888: EMPTY
69889: LIST
69890: LIST
69891: PUSH
69892: LD_INT 0
69894: PUSH
69895: LD_INT 1
69897: NEG
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: LD_INT 0
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 1
69915: PUSH
69916: LD_INT 1
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 0
69925: PUSH
69926: LD_INT 1
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 1
69935: NEG
69936: PUSH
69937: LD_INT 0
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 1
69946: NEG
69947: PUSH
69948: LD_INT 1
69950: NEG
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: PUSH
69956: LD_INT 1
69958: NEG
69959: PUSH
69960: LD_INT 2
69962: NEG
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: PUSH
69968: LD_INT 0
69970: PUSH
69971: LD_INT 2
69973: NEG
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 1
69981: PUSH
69982: LD_INT 1
69984: NEG
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 2
69992: PUSH
69993: LD_INT 0
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PUSH
70000: LD_INT 2
70002: PUSH
70003: LD_INT 1
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 2
70012: PUSH
70013: LD_INT 2
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 1
70022: PUSH
70023: LD_INT 2
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: LD_INT 2
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 1
70042: NEG
70043: PUSH
70044: LD_INT 1
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 2
70053: NEG
70054: PUSH
70055: LD_INT 0
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PUSH
70062: LD_INT 2
70064: NEG
70065: PUSH
70066: LD_INT 1
70068: NEG
70069: PUSH
70070: EMPTY
70071: LIST
70072: LIST
70073: PUSH
70074: LD_INT 2
70076: NEG
70077: PUSH
70078: LD_INT 2
70080: NEG
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: PUSH
70086: LD_INT 1
70088: NEG
70089: PUSH
70090: LD_INT 2
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 2
70099: NEG
70100: PUSH
70101: LD_INT 1
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 3
70110: NEG
70111: PUSH
70112: LD_INT 1
70114: NEG
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 3
70122: NEG
70123: PUSH
70124: LD_INT 2
70126: NEG
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: LIST
70140: LIST
70141: LIST
70142: LIST
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: LIST
70153: LIST
70154: LIST
70155: LIST
70156: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70157: LD_ADDR_VAR 0 28
70161: PUSH
70162: LD_INT 0
70164: PUSH
70165: LD_INT 0
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PUSH
70172: LD_INT 0
70174: PUSH
70175: LD_INT 1
70177: NEG
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: LD_INT 1
70185: PUSH
70186: LD_INT 0
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 1
70195: PUSH
70196: LD_INT 1
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: PUSH
70203: LD_INT 0
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: PUSH
70213: LD_INT 1
70215: NEG
70216: PUSH
70217: LD_INT 0
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: LD_INT 1
70226: NEG
70227: PUSH
70228: LD_INT 1
70230: NEG
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 1
70238: NEG
70239: PUSH
70240: LD_INT 2
70242: NEG
70243: PUSH
70244: EMPTY
70245: LIST
70246: LIST
70247: PUSH
70248: LD_INT 0
70250: PUSH
70251: LD_INT 2
70253: NEG
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 1
70261: PUSH
70262: LD_INT 1
70264: NEG
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 2
70272: PUSH
70273: LD_INT 0
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: LD_INT 2
70282: PUSH
70283: LD_INT 1
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 2
70292: PUSH
70293: LD_INT 2
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: PUSH
70300: LD_INT 1
70302: PUSH
70303: LD_INT 2
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: LD_INT 2
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: LD_INT 1
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 2
70333: NEG
70334: PUSH
70335: LD_INT 0
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: LD_INT 2
70344: NEG
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: LD_INT 2
70356: NEG
70357: PUSH
70358: LD_INT 2
70360: NEG
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 2
70368: NEG
70369: PUSH
70370: LD_INT 3
70372: NEG
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: PUSH
70378: LD_INT 1
70380: NEG
70381: PUSH
70382: LD_INT 3
70384: NEG
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 3
70392: NEG
70393: PUSH
70394: LD_INT 1
70396: NEG
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 3
70404: NEG
70405: PUSH
70406: LD_INT 2
70408: NEG
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70439: LD_ADDR_VAR 0 29
70443: PUSH
70444: LD_INT 0
70446: PUSH
70447: LD_INT 0
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 0
70456: PUSH
70457: LD_INT 1
70459: NEG
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PUSH
70465: LD_INT 1
70467: PUSH
70468: LD_INT 0
70470: PUSH
70471: EMPTY
70472: LIST
70473: LIST
70474: PUSH
70475: LD_INT 1
70477: PUSH
70478: LD_INT 1
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 0
70487: PUSH
70488: LD_INT 1
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 1
70497: NEG
70498: PUSH
70499: LD_INT 0
70501: PUSH
70502: EMPTY
70503: LIST
70504: LIST
70505: PUSH
70506: LD_INT 1
70508: NEG
70509: PUSH
70510: LD_INT 1
70512: NEG
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 1
70520: NEG
70521: PUSH
70522: LD_INT 2
70524: NEG
70525: PUSH
70526: EMPTY
70527: LIST
70528: LIST
70529: PUSH
70530: LD_INT 0
70532: PUSH
70533: LD_INT 2
70535: NEG
70536: PUSH
70537: EMPTY
70538: LIST
70539: LIST
70540: PUSH
70541: LD_INT 1
70543: PUSH
70544: LD_INT 1
70546: NEG
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: LD_INT 2
70554: PUSH
70555: LD_INT 0
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: PUSH
70562: LD_INT 2
70564: PUSH
70565: LD_INT 1
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: PUSH
70572: LD_INT 1
70574: PUSH
70575: LD_INT 2
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: LD_INT 0
70584: PUSH
70585: LD_INT 2
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: PUSH
70592: LD_INT 1
70594: NEG
70595: PUSH
70596: LD_INT 1
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: PUSH
70603: LD_INT 2
70605: NEG
70606: PUSH
70607: LD_INT 1
70609: NEG
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: PUSH
70615: LD_INT 2
70617: NEG
70618: PUSH
70619: LD_INT 2
70621: NEG
70622: PUSH
70623: EMPTY
70624: LIST
70625: LIST
70626: PUSH
70627: LD_INT 2
70629: NEG
70630: PUSH
70631: LD_INT 3
70633: NEG
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 2
70641: PUSH
70642: LD_INT 1
70644: NEG
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PUSH
70650: LD_INT 3
70652: PUSH
70653: LD_INT 1
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 1
70662: PUSH
70663: LD_INT 3
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: LD_INT 2
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 3
70683: NEG
70684: PUSH
70685: LD_INT 2
70687: NEG
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: LIST
70701: LIST
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70718: LD_ADDR_VAR 0 30
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: LD_INT 0
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 0
70735: PUSH
70736: LD_INT 1
70738: NEG
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: PUSH
70747: LD_INT 0
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 1
70756: PUSH
70757: LD_INT 1
70759: PUSH
70760: EMPTY
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 0
70766: PUSH
70767: LD_INT 1
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: LD_INT 1
70776: NEG
70777: PUSH
70778: LD_INT 0
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: LD_INT 1
70787: NEG
70788: PUSH
70789: LD_INT 1
70791: NEG
70792: PUSH
70793: EMPTY
70794: LIST
70795: LIST
70796: PUSH
70797: LD_INT 1
70799: NEG
70800: PUSH
70801: LD_INT 2
70803: NEG
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 0
70811: PUSH
70812: LD_INT 2
70814: NEG
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: LD_INT 1
70825: NEG
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 2
70833: PUSH
70834: LD_INT 0
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 2
70843: PUSH
70844: LD_INT 1
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 2
70853: PUSH
70854: LD_INT 2
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 1
70863: PUSH
70864: LD_INT 2
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: LD_INT 1
70873: NEG
70874: PUSH
70875: LD_INT 1
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 2
70884: NEG
70885: PUSH
70886: LD_INT 0
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 2
70895: NEG
70896: PUSH
70897: LD_INT 1
70899: NEG
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 1
70907: NEG
70908: PUSH
70909: LD_INT 3
70911: NEG
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: PUSH
70920: LD_INT 2
70922: NEG
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 3
70930: PUSH
70931: LD_INT 2
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 2
70940: PUSH
70941: LD_INT 3
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: LD_INT 2
70950: NEG
70951: PUSH
70952: LD_INT 1
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: LD_INT 3
70961: NEG
70962: PUSH
70963: LD_INT 1
70965: NEG
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70996: LD_ADDR_VAR 0 31
71000: PUSH
71001: LD_INT 0
71003: PUSH
71004: LD_INT 0
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 0
71013: PUSH
71014: LD_INT 1
71016: NEG
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 1
71024: PUSH
71025: LD_INT 0
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: LD_INT 1
71034: PUSH
71035: LD_INT 1
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PUSH
71042: LD_INT 0
71044: PUSH
71045: LD_INT 1
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: PUSH
71052: LD_INT 1
71054: NEG
71055: PUSH
71056: LD_INT 0
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 1
71065: NEG
71066: PUSH
71067: LD_INT 1
71069: NEG
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 1
71077: NEG
71078: PUSH
71079: LD_INT 2
71081: NEG
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 1
71089: PUSH
71090: LD_INT 1
71092: NEG
71093: PUSH
71094: EMPTY
71095: LIST
71096: LIST
71097: PUSH
71098: LD_INT 2
71100: PUSH
71101: LD_INT 0
71103: PUSH
71104: EMPTY
71105: LIST
71106: LIST
71107: PUSH
71108: LD_INT 2
71110: PUSH
71111: LD_INT 1
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 2
71120: PUSH
71121: LD_INT 2
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 1
71130: PUSH
71131: LD_INT 2
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 0
71140: PUSH
71141: LD_INT 2
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: PUSH
71148: LD_INT 1
71150: NEG
71151: PUSH
71152: LD_INT 1
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 2
71161: NEG
71162: PUSH
71163: LD_INT 1
71165: NEG
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 2
71173: NEG
71174: PUSH
71175: LD_INT 2
71177: NEG
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: PUSH
71183: LD_INT 2
71185: NEG
71186: PUSH
71187: LD_INT 3
71189: NEG
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: PUSH
71195: LD_INT 2
71197: PUSH
71198: LD_INT 1
71200: NEG
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 3
71208: PUSH
71209: LD_INT 1
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 1
71218: PUSH
71219: LD_INT 3
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: PUSH
71226: LD_INT 1
71228: NEG
71229: PUSH
71230: LD_INT 2
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 3
71239: NEG
71240: PUSH
71241: LD_INT 2
71243: NEG
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71274: LD_ADDR_VAR 0 32
71278: PUSH
71279: LD_INT 0
71281: PUSH
71282: LD_INT 0
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PUSH
71289: LD_INT 0
71291: PUSH
71292: LD_INT 1
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: LD_INT 0
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 1
71312: PUSH
71313: LD_INT 1
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 0
71322: PUSH
71323: LD_INT 1
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: LD_INT 1
71332: NEG
71333: PUSH
71334: LD_INT 0
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PUSH
71341: LD_INT 1
71343: NEG
71344: PUSH
71345: LD_INT 1
71347: NEG
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 1
71355: NEG
71356: PUSH
71357: LD_INT 2
71359: NEG
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 0
71367: PUSH
71368: LD_INT 2
71370: NEG
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 1
71378: PUSH
71379: LD_INT 1
71381: NEG
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 2
71389: PUSH
71390: LD_INT 1
71392: PUSH
71393: EMPTY
71394: LIST
71395: LIST
71396: PUSH
71397: LD_INT 2
71399: PUSH
71400: LD_INT 2
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 1
71409: PUSH
71410: LD_INT 2
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 0
71419: PUSH
71420: LD_INT 2
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 1
71429: NEG
71430: PUSH
71431: LD_INT 1
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: LD_INT 2
71440: NEG
71441: PUSH
71442: LD_INT 0
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 2
71451: NEG
71452: PUSH
71453: LD_INT 1
71455: NEG
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: LD_INT 1
71463: NEG
71464: PUSH
71465: LD_INT 3
71467: NEG
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 1
71475: PUSH
71476: LD_INT 2
71478: NEG
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: LD_INT 3
71486: PUSH
71487: LD_INT 2
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: PUSH
71494: LD_INT 2
71496: PUSH
71497: LD_INT 3
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: PUSH
71504: LD_INT 2
71506: NEG
71507: PUSH
71508: LD_INT 1
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 3
71517: NEG
71518: PUSH
71519: LD_INT 1
71521: NEG
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71552: LD_ADDR_VAR 0 33
71556: PUSH
71557: LD_INT 0
71559: PUSH
71560: LD_INT 0
71562: PUSH
71563: EMPTY
71564: LIST
71565: LIST
71566: PUSH
71567: LD_INT 0
71569: PUSH
71570: LD_INT 1
71572: NEG
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: LD_INT 1
71580: PUSH
71581: LD_INT 0
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 1
71590: PUSH
71591: LD_INT 1
71593: PUSH
71594: EMPTY
71595: LIST
71596: LIST
71597: PUSH
71598: LD_INT 0
71600: PUSH
71601: LD_INT 1
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: LD_INT 1
71610: NEG
71611: PUSH
71612: LD_INT 0
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: PUSH
71619: LD_INT 1
71621: NEG
71622: PUSH
71623: LD_INT 1
71625: NEG
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: LD_INT 1
71633: NEG
71634: PUSH
71635: LD_INT 2
71637: NEG
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: LD_INT 1
71645: PUSH
71646: LD_INT 1
71648: NEG
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 2
71656: PUSH
71657: LD_INT 0
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: PUSH
71664: LD_INT 2
71666: PUSH
71667: LD_INT 1
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: LD_INT 1
71676: PUSH
71677: LD_INT 2
71679: PUSH
71680: EMPTY
71681: LIST
71682: LIST
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: LD_INT 2
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PUSH
71694: LD_INT 1
71696: NEG
71697: PUSH
71698: LD_INT 1
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 2
71707: NEG
71708: PUSH
71709: LD_INT 0
71711: PUSH
71712: EMPTY
71713: LIST
71714: LIST
71715: PUSH
71716: LD_INT 2
71718: NEG
71719: PUSH
71720: LD_INT 1
71722: NEG
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 2
71730: NEG
71731: PUSH
71732: LD_INT 2
71734: NEG
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: PUSH
71740: LD_INT 2
71742: NEG
71743: PUSH
71744: LD_INT 3
71746: NEG
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 2
71754: PUSH
71755: LD_INT 1
71757: NEG
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 3
71765: PUSH
71766: LD_INT 1
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 1
71775: PUSH
71776: LD_INT 3
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: LD_INT 1
71785: NEG
71786: PUSH
71787: LD_INT 2
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 3
71796: NEG
71797: PUSH
71798: LD_INT 2
71800: NEG
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: LIST
71829: LIST
71830: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71831: LD_ADDR_VAR 0 34
71835: PUSH
71836: LD_INT 0
71838: PUSH
71839: LD_INT 0
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 0
71848: PUSH
71849: LD_INT 1
71851: NEG
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 1
71859: PUSH
71860: LD_INT 0
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 1
71869: PUSH
71870: LD_INT 1
71872: PUSH
71873: EMPTY
71874: LIST
71875: LIST
71876: PUSH
71877: LD_INT 0
71879: PUSH
71880: LD_INT 1
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 1
71889: NEG
71890: PUSH
71891: LD_INT 0
71893: PUSH
71894: EMPTY
71895: LIST
71896: LIST
71897: PUSH
71898: LD_INT 1
71900: NEG
71901: PUSH
71902: LD_INT 1
71904: NEG
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PUSH
71910: LD_INT 1
71912: NEG
71913: PUSH
71914: LD_INT 2
71916: NEG
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 0
71924: PUSH
71925: LD_INT 2
71927: NEG
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 1
71935: PUSH
71936: LD_INT 1
71938: NEG
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 2
71946: PUSH
71947: LD_INT 1
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: LD_INT 2
71956: PUSH
71957: LD_INT 2
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 1
71966: PUSH
71967: LD_INT 2
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: LD_INT 1
71976: NEG
71977: PUSH
71978: LD_INT 1
71980: PUSH
71981: EMPTY
71982: LIST
71983: LIST
71984: PUSH
71985: LD_INT 2
71987: NEG
71988: PUSH
71989: LD_INT 0
71991: PUSH
71992: EMPTY
71993: LIST
71994: LIST
71995: PUSH
71996: LD_INT 2
71998: NEG
71999: PUSH
72000: LD_INT 1
72002: NEG
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 2
72010: NEG
72011: PUSH
72012: LD_INT 2
72014: NEG
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 1
72022: NEG
72023: PUSH
72024: LD_INT 3
72026: NEG
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 1
72034: PUSH
72035: LD_INT 2
72037: NEG
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 3
72045: PUSH
72046: LD_INT 2
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 2
72055: PUSH
72056: LD_INT 3
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 2
72065: NEG
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 3
72076: NEG
72077: PUSH
72078: LD_INT 1
72080: NEG
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: EMPTY
72087: LIST
72088: LIST
72089: LIST
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72111: LD_ADDR_VAR 0 35
72115: PUSH
72116: LD_INT 0
72118: PUSH
72119: LD_INT 0
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 0
72128: PUSH
72129: LD_INT 1
72131: NEG
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 1
72139: PUSH
72140: LD_INT 0
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 1
72149: PUSH
72150: LD_INT 1
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: PUSH
72157: LD_INT 0
72159: PUSH
72160: LD_INT 1
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: LD_INT 0
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 1
72180: NEG
72181: PUSH
72182: LD_INT 1
72184: NEG
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: PUSH
72190: LD_INT 2
72192: PUSH
72193: LD_INT 1
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: PUSH
72200: LD_INT 2
72202: NEG
72203: PUSH
72204: LD_INT 1
72206: NEG
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: LIST
72216: LIST
72217: LIST
72218: LIST
72219: LIST
72220: LIST
72221: LIST
72222: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72223: LD_ADDR_VAR 0 36
72227: PUSH
72228: LD_INT 0
72230: PUSH
72231: LD_INT 0
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 0
72240: PUSH
72241: LD_INT 1
72243: NEG
72244: PUSH
72245: EMPTY
72246: LIST
72247: LIST
72248: PUSH
72249: LD_INT 1
72251: PUSH
72252: LD_INT 0
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: PUSH
72259: LD_INT 1
72261: PUSH
72262: LD_INT 1
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: LD_INT 0
72271: PUSH
72272: LD_INT 1
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: PUSH
72279: LD_INT 1
72281: NEG
72282: PUSH
72283: LD_INT 0
72285: PUSH
72286: EMPTY
72287: LIST
72288: LIST
72289: PUSH
72290: LD_INT 1
72292: NEG
72293: PUSH
72294: LD_INT 1
72296: NEG
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 1
72304: NEG
72305: PUSH
72306: LD_INT 2
72308: NEG
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 1
72316: PUSH
72317: LD_INT 2
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: LIST
72334: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72335: LD_ADDR_VAR 0 37
72339: PUSH
72340: LD_INT 0
72342: PUSH
72343: LD_INT 0
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 0
72352: PUSH
72353: LD_INT 1
72355: NEG
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: PUSH
72361: LD_INT 1
72363: PUSH
72364: LD_INT 0
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 1
72373: PUSH
72374: LD_INT 1
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: LD_INT 0
72383: PUSH
72384: LD_INT 1
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: LD_INT 0
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 1
72404: NEG
72405: PUSH
72406: LD_INT 1
72408: NEG
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 1
72416: PUSH
72417: LD_INT 1
72419: NEG
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 1
72427: NEG
72428: PUSH
72429: LD_INT 1
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: LIST
72440: LIST
72441: LIST
72442: LIST
72443: LIST
72444: LIST
72445: LIST
72446: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72447: LD_ADDR_VAR 0 38
72451: PUSH
72452: LD_INT 0
72454: PUSH
72455: LD_INT 0
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: PUSH
72462: LD_INT 0
72464: PUSH
72465: LD_INT 1
72467: NEG
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: LD_INT 1
72475: PUSH
72476: LD_INT 0
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 1
72485: PUSH
72486: LD_INT 1
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 0
72495: PUSH
72496: LD_INT 1
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: NEG
72506: PUSH
72507: LD_INT 0
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 1
72516: NEG
72517: PUSH
72518: LD_INT 1
72520: NEG
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 2
72528: PUSH
72529: LD_INT 1
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 2
72538: NEG
72539: PUSH
72540: LD_INT 1
72542: NEG
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: LIST
72558: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72559: LD_ADDR_VAR 0 39
72563: PUSH
72564: LD_INT 0
72566: PUSH
72567: LD_INT 0
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 0
72576: PUSH
72577: LD_INT 1
72579: NEG
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 1
72587: PUSH
72588: LD_INT 0
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 1
72597: PUSH
72598: LD_INT 1
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: LD_INT 1
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: LD_INT 1
72617: NEG
72618: PUSH
72619: LD_INT 0
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: LD_INT 1
72628: NEG
72629: PUSH
72630: LD_INT 1
72632: NEG
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: LD_INT 1
72640: NEG
72641: PUSH
72642: LD_INT 2
72644: NEG
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 1
72652: PUSH
72653: LD_INT 2
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72671: LD_ADDR_VAR 0 40
72675: PUSH
72676: LD_INT 0
72678: PUSH
72679: LD_INT 0
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 0
72688: PUSH
72689: LD_INT 1
72691: NEG
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 1
72699: PUSH
72700: LD_INT 0
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: LD_INT 1
72709: PUSH
72710: LD_INT 1
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: PUSH
72717: LD_INT 0
72719: PUSH
72720: LD_INT 1
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 1
72729: NEG
72730: PUSH
72731: LD_INT 0
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 1
72740: NEG
72741: PUSH
72742: LD_INT 1
72744: NEG
72745: PUSH
72746: EMPTY
72747: LIST
72748: LIST
72749: PUSH
72750: LD_INT 1
72752: PUSH
72753: LD_INT 1
72755: NEG
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 1
72763: NEG
72764: PUSH
72765: LD_INT 1
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72783: LD_ADDR_VAR 0 41
72787: PUSH
72788: LD_INT 0
72790: PUSH
72791: LD_INT 0
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 0
72800: PUSH
72801: LD_INT 1
72803: NEG
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: PUSH
72809: LD_INT 1
72811: PUSH
72812: LD_INT 0
72814: PUSH
72815: EMPTY
72816: LIST
72817: LIST
72818: PUSH
72819: LD_INT 1
72821: PUSH
72822: LD_INT 1
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: LD_INT 1
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 1
72841: NEG
72842: PUSH
72843: LD_INT 0
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 1
72852: NEG
72853: PUSH
72854: LD_INT 1
72856: NEG
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 1
72864: NEG
72865: PUSH
72866: LD_INT 2
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 1
72876: PUSH
72877: LD_INT 1
72879: NEG
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 2
72887: PUSH
72888: LD_INT 0
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 2
72897: PUSH
72898: LD_INT 1
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: LD_INT 2
72907: PUSH
72908: LD_INT 2
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: PUSH
72918: LD_INT 2
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: LD_INT 1
72927: NEG
72928: PUSH
72929: LD_INT 1
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 2
72938: NEG
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 2
72949: NEG
72950: PUSH
72951: LD_INT 1
72953: NEG
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 2
72961: NEG
72962: PUSH
72963: LD_INT 2
72965: NEG
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 2
72973: NEG
72974: PUSH
72975: LD_INT 3
72977: NEG
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 2
72985: PUSH
72986: LD_INT 1
72988: NEG
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: PUSH
72994: LD_INT 3
72996: PUSH
72997: LD_INT 0
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: LD_INT 3
73006: PUSH
73007: LD_INT 1
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: PUSH
73014: LD_INT 3
73016: PUSH
73017: LD_INT 2
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PUSH
73024: LD_INT 3
73026: PUSH
73027: LD_INT 3
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 2
73036: PUSH
73037: LD_INT 3
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: LD_INT 2
73046: NEG
73047: PUSH
73048: LD_INT 1
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 3
73057: NEG
73058: PUSH
73059: LD_INT 0
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: LD_INT 3
73068: NEG
73069: PUSH
73070: LD_INT 1
73072: NEG
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 3
73080: NEG
73081: PUSH
73082: LD_INT 2
73084: NEG
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 3
73092: NEG
73093: PUSH
73094: LD_INT 3
73096: NEG
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: LIST
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: LIST
73117: LIST
73118: LIST
73119: LIST
73120: LIST
73121: LIST
73122: LIST
73123: LIST
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: LIST
73129: LIST
73130: LIST
73131: LIST
73132: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73133: LD_ADDR_VAR 0 42
73137: PUSH
73138: LD_INT 0
73140: PUSH
73141: LD_INT 0
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 0
73150: PUSH
73151: LD_INT 1
73153: NEG
73154: PUSH
73155: EMPTY
73156: LIST
73157: LIST
73158: PUSH
73159: LD_INT 1
73161: PUSH
73162: LD_INT 0
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 1
73171: PUSH
73172: LD_INT 1
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: LD_INT 0
73181: PUSH
73182: LD_INT 1
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 1
73191: NEG
73192: PUSH
73193: LD_INT 0
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: LD_INT 1
73202: NEG
73203: PUSH
73204: LD_INT 1
73206: NEG
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 1
73214: NEG
73215: PUSH
73216: LD_INT 2
73218: NEG
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 0
73226: PUSH
73227: LD_INT 2
73229: NEG
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 1
73237: PUSH
73238: LD_INT 1
73240: NEG
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 2
73248: PUSH
73249: LD_INT 1
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: LD_INT 2
73258: PUSH
73259: LD_INT 2
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 1
73268: PUSH
73269: LD_INT 2
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: LD_INT 0
73278: PUSH
73279: LD_INT 2
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 1
73288: NEG
73289: PUSH
73290: LD_INT 1
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: PUSH
73297: LD_INT 2
73299: NEG
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PUSH
73309: LD_INT 2
73311: NEG
73312: PUSH
73313: LD_INT 2
73315: NEG
73316: PUSH
73317: EMPTY
73318: LIST
73319: LIST
73320: PUSH
73321: LD_INT 2
73323: NEG
73324: PUSH
73325: LD_INT 3
73327: NEG
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: PUSH
73333: LD_INT 1
73335: NEG
73336: PUSH
73337: LD_INT 3
73339: NEG
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 0
73347: PUSH
73348: LD_INT 3
73350: NEG
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 1
73358: PUSH
73359: LD_INT 2
73361: NEG
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 3
73369: PUSH
73370: LD_INT 2
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: PUSH
73377: LD_INT 3
73379: PUSH
73380: LD_INT 3
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 2
73389: PUSH
73390: LD_INT 3
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 1
73399: PUSH
73400: LD_INT 3
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 0
73409: PUSH
73410: LD_INT 3
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 1
73419: NEG
73420: PUSH
73421: LD_INT 2
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 3
73430: NEG
73431: PUSH
73432: LD_INT 2
73434: NEG
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 3
73442: NEG
73443: PUSH
73444: LD_INT 3
73446: NEG
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: LIST
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: LIST
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: LIST
73481: LIST
73482: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73483: LD_ADDR_VAR 0 43
73487: PUSH
73488: LD_INT 0
73490: PUSH
73491: LD_INT 0
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 0
73500: PUSH
73501: LD_INT 1
73503: NEG
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: LD_INT 0
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: PUSH
73519: LD_INT 1
73521: PUSH
73522: LD_INT 1
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: LD_INT 0
73531: PUSH
73532: LD_INT 1
73534: PUSH
73535: EMPTY
73536: LIST
73537: LIST
73538: PUSH
73539: LD_INT 1
73541: NEG
73542: PUSH
73543: LD_INT 0
73545: PUSH
73546: EMPTY
73547: LIST
73548: LIST
73549: PUSH
73550: LD_INT 1
73552: NEG
73553: PUSH
73554: LD_INT 1
73556: NEG
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: PUSH
73562: LD_INT 1
73564: NEG
73565: PUSH
73566: LD_INT 2
73568: NEG
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 0
73576: PUSH
73577: LD_INT 2
73579: NEG
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 1
73587: PUSH
73588: LD_INT 1
73590: NEG
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 2
73598: PUSH
73599: LD_INT 0
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 2
73608: PUSH
73609: LD_INT 1
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 2
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 0
73628: PUSH
73629: LD_INT 2
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 1
73638: NEG
73639: PUSH
73640: LD_INT 1
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PUSH
73647: LD_INT 2
73649: NEG
73650: PUSH
73651: LD_INT 0
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 2
73660: NEG
73661: PUSH
73662: LD_INT 1
73664: NEG
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 1
73672: NEG
73673: PUSH
73674: LD_INT 3
73676: NEG
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 0
73684: PUSH
73685: LD_INT 3
73687: NEG
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 1
73695: PUSH
73696: LD_INT 2
73698: NEG
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 2
73706: PUSH
73707: LD_INT 1
73709: NEG
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 3
73717: PUSH
73718: LD_INT 0
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 3
73727: PUSH
73728: LD_INT 1
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 1
73737: PUSH
73738: LD_INT 3
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 0
73747: PUSH
73748: LD_INT 3
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 1
73757: NEG
73758: PUSH
73759: LD_INT 2
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: PUSH
73766: LD_INT 2
73768: NEG
73769: PUSH
73770: LD_INT 1
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 3
73779: NEG
73780: PUSH
73781: LD_INT 0
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 3
73790: NEG
73791: PUSH
73792: LD_INT 1
73794: NEG
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: LIST
73804: LIST
73805: LIST
73806: LIST
73807: LIST
73808: LIST
73809: LIST
73810: LIST
73811: LIST
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73831: LD_ADDR_VAR 0 44
73835: PUSH
73836: LD_INT 0
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 0
73848: PUSH
73849: LD_INT 1
73851: NEG
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PUSH
73857: LD_INT 1
73859: PUSH
73860: LD_INT 0
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: LD_INT 1
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 0
73879: PUSH
73880: LD_INT 1
73882: PUSH
73883: EMPTY
73884: LIST
73885: LIST
73886: PUSH
73887: LD_INT 1
73889: NEG
73890: PUSH
73891: LD_INT 0
73893: PUSH
73894: EMPTY
73895: LIST
73896: LIST
73897: PUSH
73898: LD_INT 1
73900: NEG
73901: PUSH
73902: LD_INT 1
73904: NEG
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 1
73912: NEG
73913: PUSH
73914: LD_INT 2
73916: NEG
73917: PUSH
73918: EMPTY
73919: LIST
73920: LIST
73921: PUSH
73922: LD_INT 1
73924: PUSH
73925: LD_INT 1
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 2
73935: PUSH
73936: LD_INT 0
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 2
73945: PUSH
73946: LD_INT 1
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 2
73955: PUSH
73956: LD_INT 2
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: PUSH
73963: LD_INT 1
73965: PUSH
73966: LD_INT 2
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: PUSH
73973: LD_INT 1
73975: NEG
73976: PUSH
73977: LD_INT 1
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 2
73986: NEG
73987: PUSH
73988: LD_INT 0
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 2
73997: NEG
73998: PUSH
73999: LD_INT 1
74001: NEG
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: LD_INT 2
74009: NEG
74010: PUSH
74011: LD_INT 2
74013: NEG
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 2
74021: NEG
74022: PUSH
74023: LD_INT 3
74025: NEG
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 2
74033: PUSH
74034: LD_INT 1
74036: NEG
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 3
74044: PUSH
74045: LD_INT 0
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 3
74054: PUSH
74055: LD_INT 1
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 3
74064: PUSH
74065: LD_INT 2
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PUSH
74072: LD_INT 3
74074: PUSH
74075: LD_INT 3
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 2
74084: PUSH
74085: LD_INT 3
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: LD_INT 2
74094: NEG
74095: PUSH
74096: LD_INT 1
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 3
74105: NEG
74106: PUSH
74107: LD_INT 0
74109: PUSH
74110: EMPTY
74111: LIST
74112: LIST
74113: PUSH
74114: LD_INT 3
74116: NEG
74117: PUSH
74118: LD_INT 1
74120: NEG
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 3
74128: NEG
74129: PUSH
74130: LD_INT 2
74132: NEG
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 3
74140: NEG
74141: PUSH
74142: LD_INT 3
74144: NEG
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: LIST
74154: LIST
74155: LIST
74156: LIST
74157: LIST
74158: LIST
74159: LIST
74160: LIST
74161: LIST
74162: LIST
74163: LIST
74164: LIST
74165: LIST
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: LIST
74171: LIST
74172: LIST
74173: LIST
74174: LIST
74175: LIST
74176: LIST
74177: LIST
74178: LIST
74179: LIST
74180: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74181: LD_ADDR_VAR 0 45
74185: PUSH
74186: LD_INT 0
74188: PUSH
74189: LD_INT 0
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 0
74198: PUSH
74199: LD_INT 1
74201: NEG
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 1
74209: PUSH
74210: LD_INT 0
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 1
74219: PUSH
74220: LD_INT 1
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 0
74229: PUSH
74230: LD_INT 1
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PUSH
74237: LD_INT 1
74239: NEG
74240: PUSH
74241: LD_INT 0
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PUSH
74248: LD_INT 1
74250: NEG
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 1
74262: NEG
74263: PUSH
74264: LD_INT 2
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 0
74274: PUSH
74275: LD_INT 2
74277: NEG
74278: PUSH
74279: EMPTY
74280: LIST
74281: LIST
74282: PUSH
74283: LD_INT 1
74285: PUSH
74286: LD_INT 1
74288: NEG
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 2
74296: PUSH
74297: LD_INT 1
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 2
74306: PUSH
74307: LD_INT 2
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: LD_INT 2
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: PUSH
74324: LD_INT 0
74326: PUSH
74327: LD_INT 2
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 1
74336: NEG
74337: PUSH
74338: LD_INT 1
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: PUSH
74345: LD_INT 2
74347: NEG
74348: PUSH
74349: LD_INT 1
74351: NEG
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: PUSH
74357: LD_INT 2
74359: NEG
74360: PUSH
74361: LD_INT 2
74363: NEG
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PUSH
74369: LD_INT 2
74371: NEG
74372: PUSH
74373: LD_INT 3
74375: NEG
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: LD_INT 1
74383: NEG
74384: PUSH
74385: LD_INT 3
74387: NEG
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 0
74395: PUSH
74396: LD_INT 3
74398: NEG
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: LD_INT 1
74406: PUSH
74407: LD_INT 2
74409: NEG
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 3
74417: PUSH
74418: LD_INT 2
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 3
74427: PUSH
74428: LD_INT 3
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 2
74437: PUSH
74438: LD_INT 3
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 1
74447: PUSH
74448: LD_INT 3
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 0
74457: PUSH
74458: LD_INT 3
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 1
74467: NEG
74468: PUSH
74469: LD_INT 2
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 3
74478: NEG
74479: PUSH
74480: LD_INT 2
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 3
74490: NEG
74491: PUSH
74492: LD_INT 3
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: LIST
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74531: LD_ADDR_VAR 0 46
74535: PUSH
74536: LD_INT 0
74538: PUSH
74539: LD_INT 0
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: LD_INT 0
74548: PUSH
74549: LD_INT 1
74551: NEG
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: PUSH
74557: LD_INT 1
74559: PUSH
74560: LD_INT 0
74562: PUSH
74563: EMPTY
74564: LIST
74565: LIST
74566: PUSH
74567: LD_INT 1
74569: PUSH
74570: LD_INT 1
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 0
74579: PUSH
74580: LD_INT 1
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 1
74589: NEG
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 1
74600: NEG
74601: PUSH
74602: LD_INT 1
74604: NEG
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 1
74612: NEG
74613: PUSH
74614: LD_INT 2
74616: NEG
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 0
74624: PUSH
74625: LD_INT 2
74627: NEG
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: LD_INT 1
74635: PUSH
74636: LD_INT 1
74638: NEG
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 2
74646: PUSH
74647: LD_INT 0
74649: PUSH
74650: EMPTY
74651: LIST
74652: LIST
74653: PUSH
74654: LD_INT 2
74656: PUSH
74657: LD_INT 1
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 1
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 0
74676: PUSH
74677: LD_INT 2
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 1
74686: NEG
74687: PUSH
74688: LD_INT 1
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: LD_INT 2
74697: NEG
74698: PUSH
74699: LD_INT 0
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: LD_INT 2
74708: NEG
74709: PUSH
74710: LD_INT 1
74712: NEG
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: PUSH
74718: LD_INT 1
74720: NEG
74721: PUSH
74722: LD_INT 3
74724: NEG
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 0
74732: PUSH
74733: LD_INT 3
74735: NEG
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 1
74743: PUSH
74744: LD_INT 2
74746: NEG
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: LD_INT 2
74754: PUSH
74755: LD_INT 1
74757: NEG
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 3
74765: PUSH
74766: LD_INT 0
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 3
74775: PUSH
74776: LD_INT 1
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: LD_INT 1
74785: PUSH
74786: LD_INT 3
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PUSH
74793: LD_INT 0
74795: PUSH
74796: LD_INT 3
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PUSH
74803: LD_INT 1
74805: NEG
74806: PUSH
74807: LD_INT 2
74809: PUSH
74810: EMPTY
74811: LIST
74812: LIST
74813: PUSH
74814: LD_INT 2
74816: NEG
74817: PUSH
74818: LD_INT 1
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: LD_INT 3
74827: NEG
74828: PUSH
74829: LD_INT 0
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: PUSH
74836: LD_INT 3
74838: NEG
74839: PUSH
74840: LD_INT 1
74842: NEG
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: LIST
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: LIST
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74879: LD_ADDR_VAR 0 47
74883: PUSH
74884: LD_INT 0
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: LD_INT 0
74896: PUSH
74897: LD_INT 1
74899: NEG
74900: PUSH
74901: EMPTY
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 1
74907: PUSH
74908: LD_INT 0
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: PUSH
74915: LD_INT 1
74917: PUSH
74918: LD_INT 1
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: LD_INT 0
74927: PUSH
74928: LD_INT 1
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: PUSH
74935: LD_INT 1
74937: NEG
74938: PUSH
74939: LD_INT 0
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: LD_INT 1
74948: NEG
74949: PUSH
74950: LD_INT 1
74952: NEG
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: LD_INT 1
74960: NEG
74961: PUSH
74962: LD_INT 2
74964: NEG
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: LD_INT 0
74972: PUSH
74973: LD_INT 2
74975: NEG
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: PUSH
74981: LD_INT 1
74983: PUSH
74984: LD_INT 1
74986: NEG
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: LD_INT 2
74994: NEG
74995: PUSH
74996: LD_INT 1
74998: NEG
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 2
75006: NEG
75007: PUSH
75008: LD_INT 2
75010: NEG
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75030: LD_ADDR_VAR 0 48
75034: PUSH
75035: LD_INT 0
75037: PUSH
75038: LD_INT 0
75040: PUSH
75041: EMPTY
75042: LIST
75043: LIST
75044: PUSH
75045: LD_INT 0
75047: PUSH
75048: LD_INT 1
75050: NEG
75051: PUSH
75052: EMPTY
75053: LIST
75054: LIST
75055: PUSH
75056: LD_INT 1
75058: PUSH
75059: LD_INT 0
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: PUSH
75066: LD_INT 1
75068: PUSH
75069: LD_INT 1
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 0
75078: PUSH
75079: LD_INT 1
75081: PUSH
75082: EMPTY
75083: LIST
75084: LIST
75085: PUSH
75086: LD_INT 1
75088: NEG
75089: PUSH
75090: LD_INT 0
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: LD_INT 1
75099: NEG
75100: PUSH
75101: LD_INT 1
75103: NEG
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: PUSH
75109: LD_INT 1
75111: NEG
75112: PUSH
75113: LD_INT 2
75115: NEG
75116: PUSH
75117: EMPTY
75118: LIST
75119: LIST
75120: PUSH
75121: LD_INT 0
75123: PUSH
75124: LD_INT 2
75126: NEG
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 1
75134: PUSH
75135: LD_INT 1
75137: NEG
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: PUSH
75143: LD_INT 2
75145: PUSH
75146: LD_INT 0
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: PUSH
75153: LD_INT 2
75155: PUSH
75156: LD_INT 1
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: LIST
75167: LIST
75168: LIST
75169: LIST
75170: LIST
75171: LIST
75172: LIST
75173: LIST
75174: LIST
75175: LIST
75176: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75177: LD_ADDR_VAR 0 49
75181: PUSH
75182: LD_INT 0
75184: PUSH
75185: LD_INT 0
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 0
75194: PUSH
75195: LD_INT 1
75197: NEG
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: LD_INT 1
75205: PUSH
75206: LD_INT 0
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 1
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 0
75225: PUSH
75226: LD_INT 1
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 1
75235: NEG
75236: PUSH
75237: LD_INT 0
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 1
75246: NEG
75247: PUSH
75248: LD_INT 1
75250: NEG
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 1
75258: PUSH
75259: LD_INT 1
75261: NEG
75262: PUSH
75263: EMPTY
75264: LIST
75265: LIST
75266: PUSH
75267: LD_INT 2
75269: PUSH
75270: LD_INT 0
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 2
75279: PUSH
75280: LD_INT 1
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PUSH
75287: LD_INT 2
75289: PUSH
75290: LD_INT 2
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PUSH
75297: LD_INT 1
75299: PUSH
75300: LD_INT 2
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: LIST
75311: LIST
75312: LIST
75313: LIST
75314: LIST
75315: LIST
75316: LIST
75317: LIST
75318: LIST
75319: LIST
75320: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75321: LD_ADDR_VAR 0 50
75325: PUSH
75326: LD_INT 0
75328: PUSH
75329: LD_INT 0
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 0
75338: PUSH
75339: LD_INT 1
75341: NEG
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 1
75349: PUSH
75350: LD_INT 0
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: LD_INT 1
75359: PUSH
75360: LD_INT 1
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 0
75369: PUSH
75370: LD_INT 1
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: PUSH
75377: LD_INT 1
75379: NEG
75380: PUSH
75381: LD_INT 0
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 1
75390: NEG
75391: PUSH
75392: LD_INT 1
75394: NEG
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 2
75402: PUSH
75403: LD_INT 1
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 2
75412: PUSH
75413: LD_INT 2
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 1
75422: PUSH
75423: LD_INT 2
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 0
75432: PUSH
75433: LD_INT 2
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: NEG
75443: PUSH
75444: LD_INT 1
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75465: LD_ADDR_VAR 0 51
75469: PUSH
75470: LD_INT 0
75472: PUSH
75473: LD_INT 0
75475: PUSH
75476: EMPTY
75477: LIST
75478: LIST
75479: PUSH
75480: LD_INT 0
75482: PUSH
75483: LD_INT 1
75485: NEG
75486: PUSH
75487: EMPTY
75488: LIST
75489: LIST
75490: PUSH
75491: LD_INT 1
75493: PUSH
75494: LD_INT 0
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: PUSH
75501: LD_INT 1
75503: PUSH
75504: LD_INT 1
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: LD_INT 0
75513: PUSH
75514: LD_INT 1
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 1
75523: NEG
75524: PUSH
75525: LD_INT 0
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 1
75534: NEG
75535: PUSH
75536: LD_INT 1
75538: NEG
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: PUSH
75544: LD_INT 1
75546: PUSH
75547: LD_INT 2
75549: PUSH
75550: EMPTY
75551: LIST
75552: LIST
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: LD_INT 2
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 1
75566: NEG
75567: PUSH
75568: LD_INT 1
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 2
75577: NEG
75578: PUSH
75579: LD_INT 0
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: PUSH
75586: LD_INT 2
75588: NEG
75589: PUSH
75590: LD_INT 1
75592: NEG
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: LIST
75602: LIST
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75612: LD_ADDR_VAR 0 52
75616: PUSH
75617: LD_INT 0
75619: PUSH
75620: LD_INT 0
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: LD_INT 0
75629: PUSH
75630: LD_INT 1
75632: NEG
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 1
75640: PUSH
75641: LD_INT 0
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 1
75650: PUSH
75651: LD_INT 1
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 0
75660: PUSH
75661: LD_INT 1
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 1
75670: NEG
75671: PUSH
75672: LD_INT 0
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 1
75681: NEG
75682: PUSH
75683: LD_INT 1
75685: NEG
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 1
75693: NEG
75694: PUSH
75695: LD_INT 2
75697: NEG
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 1
75705: NEG
75706: PUSH
75707: LD_INT 1
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 2
75716: NEG
75717: PUSH
75718: LD_INT 0
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 2
75727: NEG
75728: PUSH
75729: LD_INT 1
75731: NEG
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 2
75739: NEG
75740: PUSH
75741: LD_INT 2
75743: NEG
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75763: LD_ADDR_VAR 0 53
75767: PUSH
75768: LD_INT 0
75770: PUSH
75771: LD_INT 0
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: LD_INT 0
75780: PUSH
75781: LD_INT 1
75783: NEG
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: LD_INT 1
75791: PUSH
75792: LD_INT 0
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 1
75801: PUSH
75802: LD_INT 1
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 0
75811: PUSH
75812: LD_INT 1
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 1
75821: NEG
75822: PUSH
75823: LD_INT 0
75825: PUSH
75826: EMPTY
75827: LIST
75828: LIST
75829: PUSH
75830: LD_INT 1
75832: NEG
75833: PUSH
75834: LD_INT 1
75836: NEG
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 1
75844: NEG
75845: PUSH
75846: LD_INT 2
75848: NEG
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PUSH
75854: LD_INT 0
75856: PUSH
75857: LD_INT 2
75859: NEG
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 1
75867: PUSH
75868: LD_INT 1
75870: NEG
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 2
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 2
75888: PUSH
75889: LD_INT 1
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: LD_INT 2
75898: PUSH
75899: LD_INT 2
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 1
75908: PUSH
75909: LD_INT 2
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: LD_INT 0
75918: PUSH
75919: LD_INT 2
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: LD_INT 1
75928: NEG
75929: PUSH
75930: LD_INT 1
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: PUSH
75937: LD_INT 2
75939: NEG
75940: PUSH
75941: LD_INT 0
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: PUSH
75948: LD_INT 2
75950: NEG
75951: PUSH
75952: LD_INT 1
75954: NEG
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 2
75962: NEG
75963: PUSH
75964: LD_INT 2
75966: NEG
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: LIST
75987: LIST
75988: LIST
75989: LIST
75990: LIST
75991: LIST
75992: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75993: LD_ADDR_VAR 0 54
75997: PUSH
75998: LD_INT 0
76000: PUSH
76001: LD_INT 0
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: LD_INT 0
76010: PUSH
76011: LD_INT 1
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: LD_INT 1
76021: PUSH
76022: LD_INT 0
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 1
76031: PUSH
76032: LD_INT 1
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PUSH
76039: LD_INT 0
76041: PUSH
76042: LD_INT 1
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PUSH
76049: LD_INT 1
76051: NEG
76052: PUSH
76053: LD_INT 0
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: PUSH
76060: LD_INT 1
76062: NEG
76063: PUSH
76064: LD_INT 1
76066: NEG
76067: PUSH
76068: EMPTY
76069: LIST
76070: LIST
76071: PUSH
76072: LD_INT 1
76074: NEG
76075: PUSH
76076: LD_INT 2
76078: NEG
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 0
76086: PUSH
76087: LD_INT 2
76089: NEG
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 1
76097: PUSH
76098: LD_INT 1
76100: NEG
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: LD_INT 2
76108: PUSH
76109: LD_INT 0
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: LD_INT 2
76118: PUSH
76119: LD_INT 1
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: LD_INT 2
76128: PUSH
76129: LD_INT 2
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 1
76138: PUSH
76139: LD_INT 2
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 0
76148: PUSH
76149: LD_INT 2
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 1
76158: NEG
76159: PUSH
76160: LD_INT 1
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 2
76169: NEG
76170: PUSH
76171: LD_INT 0
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: PUSH
76178: LD_INT 2
76180: NEG
76181: PUSH
76182: LD_INT 1
76184: NEG
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 2
76192: NEG
76193: PUSH
76194: LD_INT 2
76196: NEG
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: LIST
76222: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76223: LD_ADDR_VAR 0 55
76227: PUSH
76228: LD_INT 0
76230: PUSH
76231: LD_INT 0
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: LD_INT 0
76240: PUSH
76241: LD_INT 1
76243: NEG
76244: PUSH
76245: EMPTY
76246: LIST
76247: LIST
76248: PUSH
76249: LD_INT 1
76251: PUSH
76252: LD_INT 0
76254: PUSH
76255: EMPTY
76256: LIST
76257: LIST
76258: PUSH
76259: LD_INT 1
76261: PUSH
76262: LD_INT 1
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: PUSH
76269: LD_INT 0
76271: PUSH
76272: LD_INT 1
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 1
76281: NEG
76282: PUSH
76283: LD_INT 0
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: LD_INT 1
76292: NEG
76293: PUSH
76294: LD_INT 1
76296: NEG
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: PUSH
76302: LD_INT 1
76304: NEG
76305: PUSH
76306: LD_INT 2
76308: NEG
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 0
76316: PUSH
76317: LD_INT 2
76319: NEG
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 1
76327: PUSH
76328: LD_INT 1
76330: NEG
76331: PUSH
76332: EMPTY
76333: LIST
76334: LIST
76335: PUSH
76336: LD_INT 2
76338: PUSH
76339: LD_INT 0
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 2
76348: PUSH
76349: LD_INT 1
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 2
76358: PUSH
76359: LD_INT 2
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 1
76368: PUSH
76369: LD_INT 2
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 0
76378: PUSH
76379: LD_INT 2
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 1
76388: NEG
76389: PUSH
76390: LD_INT 1
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 2
76399: NEG
76400: PUSH
76401: LD_INT 0
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: LD_INT 2
76410: NEG
76411: PUSH
76412: LD_INT 1
76414: NEG
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 2
76422: NEG
76423: PUSH
76424: LD_INT 2
76426: NEG
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: LIST
76436: LIST
76437: LIST
76438: LIST
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76453: LD_ADDR_VAR 0 56
76457: PUSH
76458: LD_INT 0
76460: PUSH
76461: LD_INT 0
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: PUSH
76468: LD_INT 0
76470: PUSH
76471: LD_INT 1
76473: NEG
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 1
76481: PUSH
76482: LD_INT 0
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: LD_INT 1
76491: PUSH
76492: LD_INT 1
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: PUSH
76499: LD_INT 0
76501: PUSH
76502: LD_INT 1
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 1
76511: NEG
76512: PUSH
76513: LD_INT 0
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 1
76522: NEG
76523: PUSH
76524: LD_INT 1
76526: NEG
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 1
76534: NEG
76535: PUSH
76536: LD_INT 2
76538: NEG
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: LD_INT 0
76546: PUSH
76547: LD_INT 2
76549: NEG
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 1
76557: PUSH
76558: LD_INT 1
76560: NEG
76561: PUSH
76562: EMPTY
76563: LIST
76564: LIST
76565: PUSH
76566: LD_INT 2
76568: PUSH
76569: LD_INT 0
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 2
76578: PUSH
76579: LD_INT 1
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: LD_INT 2
76588: PUSH
76589: LD_INT 2
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 1
76598: PUSH
76599: LD_INT 2
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 0
76608: PUSH
76609: LD_INT 2
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 1
76618: NEG
76619: PUSH
76620: LD_INT 1
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: PUSH
76627: LD_INT 2
76629: NEG
76630: PUSH
76631: LD_INT 0
76633: PUSH
76634: EMPTY
76635: LIST
76636: LIST
76637: PUSH
76638: LD_INT 2
76640: NEG
76641: PUSH
76642: LD_INT 1
76644: NEG
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 2
76652: NEG
76653: PUSH
76654: LD_INT 2
76656: NEG
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: LIST
76682: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76683: LD_ADDR_VAR 0 57
76687: PUSH
76688: LD_INT 0
76690: PUSH
76691: LD_INT 0
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: LD_INT 0
76700: PUSH
76701: LD_INT 1
76703: NEG
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: LD_INT 1
76711: PUSH
76712: LD_INT 0
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 1
76721: PUSH
76722: LD_INT 1
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 0
76731: PUSH
76732: LD_INT 1
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 1
76741: NEG
76742: PUSH
76743: LD_INT 0
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 1
76752: NEG
76753: PUSH
76754: LD_INT 1
76756: NEG
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: LD_INT 1
76764: NEG
76765: PUSH
76766: LD_INT 2
76768: NEG
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 0
76776: PUSH
76777: LD_INT 2
76779: NEG
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 1
76787: PUSH
76788: LD_INT 1
76790: NEG
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 2
76798: PUSH
76799: LD_INT 0
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 2
76808: PUSH
76809: LD_INT 1
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 2
76818: PUSH
76819: LD_INT 2
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 1
76828: PUSH
76829: LD_INT 2
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 0
76838: PUSH
76839: LD_INT 2
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 1
76848: NEG
76849: PUSH
76850: LD_INT 1
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 2
76859: NEG
76860: PUSH
76861: LD_INT 0
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PUSH
76868: LD_INT 2
76870: NEG
76871: PUSH
76872: LD_INT 1
76874: NEG
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 2
76882: NEG
76883: PUSH
76884: LD_INT 2
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: LIST
76902: LIST
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: LIST
76908: LIST
76909: LIST
76910: LIST
76911: LIST
76912: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76913: LD_ADDR_VAR 0 58
76917: PUSH
76918: LD_INT 0
76920: PUSH
76921: LD_INT 0
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 0
76930: PUSH
76931: LD_INT 1
76933: NEG
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: LD_INT 1
76941: PUSH
76942: LD_INT 0
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 1
76951: PUSH
76952: LD_INT 1
76954: PUSH
76955: EMPTY
76956: LIST
76957: LIST
76958: PUSH
76959: LD_INT 0
76961: PUSH
76962: LD_INT 1
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 1
76971: NEG
76972: PUSH
76973: LD_INT 0
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 1
76982: NEG
76983: PUSH
76984: LD_INT 1
76986: NEG
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 1
76994: NEG
76995: PUSH
76996: LD_INT 2
76998: NEG
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 0
77006: PUSH
77007: LD_INT 2
77009: NEG
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 1
77017: PUSH
77018: LD_INT 1
77020: NEG
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 2
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 2
77038: PUSH
77039: LD_INT 1
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: LD_INT 2
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 1
77058: PUSH
77059: LD_INT 2
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 0
77068: PUSH
77069: LD_INT 2
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 1
77078: NEG
77079: PUSH
77080: LD_INT 1
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 2
77089: NEG
77090: PUSH
77091: LD_INT 0
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: LD_INT 2
77100: NEG
77101: PUSH
77102: LD_INT 1
77104: NEG
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 2
77112: NEG
77113: PUSH
77114: LD_INT 2
77116: NEG
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77143: LD_ADDR_VAR 0 59
77147: PUSH
77148: LD_INT 0
77150: PUSH
77151: LD_INT 0
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 0
77160: PUSH
77161: LD_INT 1
77163: NEG
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 1
77171: PUSH
77172: LD_INT 0
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 1
77181: PUSH
77182: LD_INT 1
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: PUSH
77189: LD_INT 0
77191: PUSH
77192: LD_INT 1
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 1
77201: NEG
77202: PUSH
77203: LD_INT 0
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: LD_INT 1
77212: NEG
77213: PUSH
77214: LD_INT 1
77216: NEG
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: LIST
77226: LIST
77227: LIST
77228: LIST
77229: LIST
77230: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77231: LD_ADDR_VAR 0 60
77235: PUSH
77236: LD_INT 0
77238: PUSH
77239: LD_INT 0
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 0
77248: PUSH
77249: LD_INT 1
77251: NEG
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: LD_INT 1
77259: PUSH
77260: LD_INT 0
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 1
77269: PUSH
77270: LD_INT 1
77272: PUSH
77273: EMPTY
77274: LIST
77275: LIST
77276: PUSH
77277: LD_INT 0
77279: PUSH
77280: LD_INT 1
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PUSH
77287: LD_INT 1
77289: NEG
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 1
77300: NEG
77301: PUSH
77302: LD_INT 1
77304: NEG
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77319: LD_ADDR_VAR 0 61
77323: PUSH
77324: LD_INT 0
77326: PUSH
77327: LD_INT 0
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PUSH
77334: LD_INT 0
77336: PUSH
77337: LD_INT 1
77339: NEG
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PUSH
77345: LD_INT 1
77347: PUSH
77348: LD_INT 0
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 1
77357: PUSH
77358: LD_INT 1
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 0
77367: PUSH
77368: LD_INT 1
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 1
77377: NEG
77378: PUSH
77379: LD_INT 0
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 1
77388: NEG
77389: PUSH
77390: LD_INT 1
77392: NEG
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: LIST
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77407: LD_ADDR_VAR 0 62
77411: PUSH
77412: LD_INT 0
77414: PUSH
77415: LD_INT 0
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PUSH
77422: LD_INT 0
77424: PUSH
77425: LD_INT 1
77427: NEG
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 1
77435: PUSH
77436: LD_INT 0
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: LD_INT 1
77445: PUSH
77446: LD_INT 1
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: PUSH
77453: LD_INT 0
77455: PUSH
77456: LD_INT 1
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 1
77465: NEG
77466: PUSH
77467: LD_INT 0
77469: PUSH
77470: EMPTY
77471: LIST
77472: LIST
77473: PUSH
77474: LD_INT 1
77476: NEG
77477: PUSH
77478: LD_INT 1
77480: NEG
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: LIST
77490: LIST
77491: LIST
77492: LIST
77493: LIST
77494: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77495: LD_ADDR_VAR 0 63
77499: PUSH
77500: LD_INT 0
77502: PUSH
77503: LD_INT 0
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: LD_INT 0
77512: PUSH
77513: LD_INT 1
77515: NEG
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 1
77523: PUSH
77524: LD_INT 0
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 1
77533: PUSH
77534: LD_INT 1
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 0
77543: PUSH
77544: LD_INT 1
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 1
77553: NEG
77554: PUSH
77555: LD_INT 0
77557: PUSH
77558: EMPTY
77559: LIST
77560: LIST
77561: PUSH
77562: LD_INT 1
77564: NEG
77565: PUSH
77566: LD_INT 1
77568: NEG
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: EMPTY
77575: LIST
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77583: LD_ADDR_VAR 0 64
77587: PUSH
77588: LD_INT 0
77590: PUSH
77591: LD_INT 0
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 0
77600: PUSH
77601: LD_INT 1
77603: NEG
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 1
77611: PUSH
77612: LD_INT 0
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: PUSH
77619: LD_INT 1
77621: PUSH
77622: LD_INT 1
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 0
77631: PUSH
77632: LD_INT 1
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 1
77641: NEG
77642: PUSH
77643: LD_INT 0
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 1
77652: NEG
77653: PUSH
77654: LD_INT 1
77656: NEG
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: ST_TO_ADDR
// end ; 1 :
77671: GO 83568
77673: LD_INT 1
77675: DOUBLE
77676: EQUAL
77677: IFTRUE 77681
77679: GO 80304
77681: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77682: LD_ADDR_VAR 0 11
77686: PUSH
77687: LD_INT 1
77689: NEG
77690: PUSH
77691: LD_INT 3
77693: NEG
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: PUSH
77699: LD_INT 0
77701: PUSH
77702: LD_INT 3
77704: NEG
77705: PUSH
77706: EMPTY
77707: LIST
77708: LIST
77709: PUSH
77710: LD_INT 1
77712: PUSH
77713: LD_INT 2
77715: NEG
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: LIST
77725: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77726: LD_ADDR_VAR 0 12
77730: PUSH
77731: LD_INT 2
77733: PUSH
77734: LD_INT 1
77736: NEG
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: PUSH
77742: LD_INT 3
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: EMPTY
77749: LIST
77750: LIST
77751: PUSH
77752: LD_INT 3
77754: PUSH
77755: LD_INT 1
77757: PUSH
77758: EMPTY
77759: LIST
77760: LIST
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: LIST
77766: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77767: LD_ADDR_VAR 0 13
77771: PUSH
77772: LD_INT 3
77774: PUSH
77775: LD_INT 2
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: LD_INT 3
77784: PUSH
77785: LD_INT 3
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 2
77794: PUSH
77795: LD_INT 3
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: LIST
77806: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77807: LD_ADDR_VAR 0 14
77811: PUSH
77812: LD_INT 1
77814: PUSH
77815: LD_INT 3
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 0
77824: PUSH
77825: LD_INT 3
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 1
77834: NEG
77835: PUSH
77836: LD_INT 2
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: LIST
77847: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77848: LD_ADDR_VAR 0 15
77852: PUSH
77853: LD_INT 2
77855: NEG
77856: PUSH
77857: LD_INT 1
77859: PUSH
77860: EMPTY
77861: LIST
77862: LIST
77863: PUSH
77864: LD_INT 3
77866: NEG
77867: PUSH
77868: LD_INT 0
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 3
77877: NEG
77878: PUSH
77879: LD_INT 1
77881: NEG
77882: PUSH
77883: EMPTY
77884: LIST
77885: LIST
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: LIST
77891: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77892: LD_ADDR_VAR 0 16
77896: PUSH
77897: LD_INT 2
77899: NEG
77900: PUSH
77901: LD_INT 3
77903: NEG
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 3
77911: NEG
77912: PUSH
77913: LD_INT 2
77915: NEG
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 3
77923: NEG
77924: PUSH
77925: LD_INT 3
77927: NEG
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: EMPTY
77934: LIST
77935: LIST
77936: LIST
77937: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77938: LD_ADDR_VAR 0 17
77942: PUSH
77943: LD_INT 1
77945: NEG
77946: PUSH
77947: LD_INT 3
77949: NEG
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 0
77957: PUSH
77958: LD_INT 3
77960: NEG
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: LD_INT 1
77968: PUSH
77969: LD_INT 2
77971: NEG
77972: PUSH
77973: EMPTY
77974: LIST
77975: LIST
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: LIST
77981: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77982: LD_ADDR_VAR 0 18
77986: PUSH
77987: LD_INT 2
77989: PUSH
77990: LD_INT 1
77992: NEG
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 3
78000: PUSH
78001: LD_INT 0
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: PUSH
78011: LD_INT 1
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: LIST
78022: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78023: LD_ADDR_VAR 0 19
78027: PUSH
78028: LD_INT 3
78030: PUSH
78031: LD_INT 2
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: LD_INT 3
78040: PUSH
78041: LD_INT 3
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 2
78050: PUSH
78051: LD_INT 3
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: LIST
78062: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78063: LD_ADDR_VAR 0 20
78067: PUSH
78068: LD_INT 1
78070: PUSH
78071: LD_INT 3
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 0
78080: PUSH
78081: LD_INT 3
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 1
78090: NEG
78091: PUSH
78092: LD_INT 2
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: LIST
78103: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78104: LD_ADDR_VAR 0 21
78108: PUSH
78109: LD_INT 2
78111: NEG
78112: PUSH
78113: LD_INT 1
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 3
78122: NEG
78123: PUSH
78124: LD_INT 0
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: LD_INT 3
78133: NEG
78134: PUSH
78135: LD_INT 1
78137: NEG
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: LIST
78147: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78148: LD_ADDR_VAR 0 22
78152: PUSH
78153: LD_INT 2
78155: NEG
78156: PUSH
78157: LD_INT 3
78159: NEG
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 3
78167: NEG
78168: PUSH
78169: LD_INT 2
78171: NEG
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 3
78179: NEG
78180: PUSH
78181: LD_INT 3
78183: NEG
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: LIST
78193: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78194: LD_ADDR_VAR 0 23
78198: PUSH
78199: LD_INT 0
78201: PUSH
78202: LD_INT 3
78204: NEG
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PUSH
78210: LD_INT 1
78212: NEG
78213: PUSH
78214: LD_INT 4
78216: NEG
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: PUSH
78222: LD_INT 1
78224: PUSH
78225: LD_INT 3
78227: NEG
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: PUSH
78233: EMPTY
78234: LIST
78235: LIST
78236: LIST
78237: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78238: LD_ADDR_VAR 0 24
78242: PUSH
78243: LD_INT 3
78245: PUSH
78246: LD_INT 0
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: LD_INT 3
78255: PUSH
78256: LD_INT 1
78258: NEG
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: LD_INT 4
78266: PUSH
78267: LD_INT 1
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: LIST
78278: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78279: LD_ADDR_VAR 0 25
78283: PUSH
78284: LD_INT 3
78286: PUSH
78287: LD_INT 3
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 4
78296: PUSH
78297: LD_INT 3
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: PUSH
78304: LD_INT 3
78306: PUSH
78307: LD_INT 4
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: PUSH
78314: EMPTY
78315: LIST
78316: LIST
78317: LIST
78318: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78319: LD_ADDR_VAR 0 26
78323: PUSH
78324: LD_INT 0
78326: PUSH
78327: LD_INT 3
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 1
78336: PUSH
78337: LD_INT 4
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: LD_INT 1
78346: NEG
78347: PUSH
78348: LD_INT 3
78350: PUSH
78351: EMPTY
78352: LIST
78353: LIST
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: LIST
78359: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78360: LD_ADDR_VAR 0 27
78364: PUSH
78365: LD_INT 3
78367: NEG
78368: PUSH
78369: LD_INT 0
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: LD_INT 3
78378: NEG
78379: PUSH
78380: LD_INT 1
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 4
78389: NEG
78390: PUSH
78391: LD_INT 1
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: LIST
78403: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78404: LD_ADDR_VAR 0 28
78408: PUSH
78409: LD_INT 3
78411: NEG
78412: PUSH
78413: LD_INT 3
78415: NEG
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 3
78423: NEG
78424: PUSH
78425: LD_INT 4
78427: NEG
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 4
78435: NEG
78436: PUSH
78437: LD_INT 3
78439: NEG
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: LIST
78449: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78450: LD_ADDR_VAR 0 29
78454: PUSH
78455: LD_INT 1
78457: NEG
78458: PUSH
78459: LD_INT 3
78461: NEG
78462: PUSH
78463: EMPTY
78464: LIST
78465: LIST
78466: PUSH
78467: LD_INT 0
78469: PUSH
78470: LD_INT 3
78472: NEG
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 1
78480: PUSH
78481: LD_INT 2
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 1
78491: NEG
78492: PUSH
78493: LD_INT 4
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 0
78503: PUSH
78504: LD_INT 4
78506: NEG
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 1
78514: PUSH
78515: LD_INT 3
78517: NEG
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: LD_INT 1
78525: NEG
78526: PUSH
78527: LD_INT 5
78529: NEG
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: PUSH
78535: LD_INT 0
78537: PUSH
78538: LD_INT 5
78540: NEG
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 1
78548: PUSH
78549: LD_INT 4
78551: NEG
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 1
78559: NEG
78560: PUSH
78561: LD_INT 6
78563: NEG
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 0
78571: PUSH
78572: LD_INT 6
78574: NEG
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 1
78582: PUSH
78583: LD_INT 5
78585: NEG
78586: PUSH
78587: EMPTY
78588: LIST
78589: LIST
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78605: LD_ADDR_VAR 0 30
78609: PUSH
78610: LD_INT 2
78612: PUSH
78613: LD_INT 1
78615: NEG
78616: PUSH
78617: EMPTY
78618: LIST
78619: LIST
78620: PUSH
78621: LD_INT 3
78623: PUSH
78624: LD_INT 0
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: PUSH
78631: LD_INT 3
78633: PUSH
78634: LD_INT 1
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 3
78643: PUSH
78644: LD_INT 1
78646: NEG
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 4
78654: PUSH
78655: LD_INT 0
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 4
78664: PUSH
78665: LD_INT 1
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PUSH
78672: LD_INT 4
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: EMPTY
78680: LIST
78681: LIST
78682: PUSH
78683: LD_INT 5
78685: PUSH
78686: LD_INT 0
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: LD_INT 5
78695: PUSH
78696: LD_INT 1
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 5
78705: PUSH
78706: LD_INT 1
78708: NEG
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 6
78716: PUSH
78717: LD_INT 0
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 6
78726: PUSH
78727: LD_INT 1
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78748: LD_ADDR_VAR 0 31
78752: PUSH
78753: LD_INT 3
78755: PUSH
78756: LD_INT 2
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 3
78765: PUSH
78766: LD_INT 3
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 2
78775: PUSH
78776: LD_INT 3
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 4
78785: PUSH
78786: LD_INT 3
78788: PUSH
78789: EMPTY
78790: LIST
78791: LIST
78792: PUSH
78793: LD_INT 4
78795: PUSH
78796: LD_INT 4
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 3
78805: PUSH
78806: LD_INT 4
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 5
78815: PUSH
78816: LD_INT 4
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 5
78825: PUSH
78826: LD_INT 5
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 4
78835: PUSH
78836: LD_INT 5
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 6
78845: PUSH
78846: LD_INT 5
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PUSH
78853: LD_INT 6
78855: PUSH
78856: LD_INT 6
78858: PUSH
78859: EMPTY
78860: LIST
78861: LIST
78862: PUSH
78863: LD_INT 5
78865: PUSH
78866: LD_INT 6
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: LIST
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78887: LD_ADDR_VAR 0 32
78891: PUSH
78892: LD_INT 1
78894: PUSH
78895: LD_INT 3
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 0
78904: PUSH
78905: LD_INT 3
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 1
78914: NEG
78915: PUSH
78916: LD_INT 2
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 1
78925: PUSH
78926: LD_INT 4
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: LD_INT 4
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 1
78945: NEG
78946: PUSH
78947: LD_INT 3
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 1
78956: PUSH
78957: LD_INT 5
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 0
78966: PUSH
78967: LD_INT 5
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 1
78976: NEG
78977: PUSH
78978: LD_INT 4
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PUSH
78985: LD_INT 1
78987: PUSH
78988: LD_INT 6
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 0
78997: PUSH
78998: LD_INT 6
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 1
79007: NEG
79008: PUSH
79009: LD_INT 5
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79030: LD_ADDR_VAR 0 33
79034: PUSH
79035: LD_INT 2
79037: NEG
79038: PUSH
79039: LD_INT 1
79041: PUSH
79042: EMPTY
79043: LIST
79044: LIST
79045: PUSH
79046: LD_INT 3
79048: NEG
79049: PUSH
79050: LD_INT 0
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 3
79059: NEG
79060: PUSH
79061: LD_INT 1
79063: NEG
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 3
79071: NEG
79072: PUSH
79073: LD_INT 1
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 4
79082: NEG
79083: PUSH
79084: LD_INT 0
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PUSH
79091: LD_INT 4
79093: NEG
79094: PUSH
79095: LD_INT 1
79097: NEG
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 4
79105: NEG
79106: PUSH
79107: LD_INT 1
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 5
79116: NEG
79117: PUSH
79118: LD_INT 0
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 5
79127: NEG
79128: PUSH
79129: LD_INT 1
79131: NEG
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 5
79139: NEG
79140: PUSH
79141: LD_INT 1
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 6
79150: NEG
79151: PUSH
79152: LD_INT 0
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 6
79161: NEG
79162: PUSH
79163: LD_INT 1
79165: NEG
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: LIST
79175: LIST
79176: LIST
79177: LIST
79178: LIST
79179: LIST
79180: LIST
79181: LIST
79182: LIST
79183: LIST
79184: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79185: LD_ADDR_VAR 0 34
79189: PUSH
79190: LD_INT 2
79192: NEG
79193: PUSH
79194: LD_INT 3
79196: NEG
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 3
79204: NEG
79205: PUSH
79206: LD_INT 2
79208: NEG
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 3
79216: NEG
79217: PUSH
79218: LD_INT 3
79220: NEG
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 3
79228: NEG
79229: PUSH
79230: LD_INT 4
79232: NEG
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: LD_INT 4
79240: NEG
79241: PUSH
79242: LD_INT 3
79244: NEG
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 4
79252: NEG
79253: PUSH
79254: LD_INT 4
79256: NEG
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 4
79264: NEG
79265: PUSH
79266: LD_INT 5
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 5
79276: NEG
79277: PUSH
79278: LD_INT 4
79280: NEG
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 5
79288: NEG
79289: PUSH
79290: LD_INT 5
79292: NEG
79293: PUSH
79294: EMPTY
79295: LIST
79296: LIST
79297: PUSH
79298: LD_INT 5
79300: NEG
79301: PUSH
79302: LD_INT 6
79304: NEG
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 6
79312: NEG
79313: PUSH
79314: LD_INT 5
79316: NEG
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 6
79324: NEG
79325: PUSH
79326: LD_INT 6
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79348: LD_ADDR_VAR 0 41
79352: PUSH
79353: LD_INT 0
79355: PUSH
79356: LD_INT 2
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 1
79366: NEG
79367: PUSH
79368: LD_INT 3
79370: NEG
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: PUSH
79376: LD_INT 1
79378: PUSH
79379: LD_INT 2
79381: NEG
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: LIST
79391: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79392: LD_ADDR_VAR 0 42
79396: PUSH
79397: LD_INT 2
79399: PUSH
79400: LD_INT 0
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 2
79409: PUSH
79410: LD_INT 1
79412: NEG
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 3
79420: PUSH
79421: LD_INT 1
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: EMPTY
79429: LIST
79430: LIST
79431: LIST
79432: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79433: LD_ADDR_VAR 0 43
79437: PUSH
79438: LD_INT 2
79440: PUSH
79441: LD_INT 2
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 3
79450: PUSH
79451: LD_INT 2
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 2
79460: PUSH
79461: LD_INT 3
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: LIST
79472: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79473: LD_ADDR_VAR 0 44
79477: PUSH
79478: LD_INT 0
79480: PUSH
79481: LD_INT 2
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 1
79490: PUSH
79491: LD_INT 3
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: LD_INT 1
79500: NEG
79501: PUSH
79502: LD_INT 2
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: EMPTY
79510: LIST
79511: LIST
79512: LIST
79513: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79514: LD_ADDR_VAR 0 45
79518: PUSH
79519: LD_INT 2
79521: NEG
79522: PUSH
79523: LD_INT 0
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 2
79532: NEG
79533: PUSH
79534: LD_INT 1
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 3
79543: NEG
79544: PUSH
79545: LD_INT 1
79547: NEG
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: LIST
79557: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79558: LD_ADDR_VAR 0 46
79562: PUSH
79563: LD_INT 2
79565: NEG
79566: PUSH
79567: LD_INT 2
79569: NEG
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 2
79577: NEG
79578: PUSH
79579: LD_INT 3
79581: NEG
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 3
79589: NEG
79590: PUSH
79591: LD_INT 2
79593: NEG
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79604: LD_ADDR_VAR 0 47
79608: PUSH
79609: LD_INT 2
79611: NEG
79612: PUSH
79613: LD_INT 3
79615: NEG
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 1
79623: NEG
79624: PUSH
79625: LD_INT 3
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79637: LD_ADDR_VAR 0 48
79641: PUSH
79642: LD_INT 1
79644: PUSH
79645: LD_INT 2
79647: NEG
79648: PUSH
79649: EMPTY
79650: LIST
79651: LIST
79652: PUSH
79653: LD_INT 2
79655: PUSH
79656: LD_INT 1
79658: NEG
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79668: LD_ADDR_VAR 0 49
79672: PUSH
79673: LD_INT 3
79675: PUSH
79676: LD_INT 1
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 3
79685: PUSH
79686: LD_INT 2
79688: PUSH
79689: EMPTY
79690: LIST
79691: LIST
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79697: LD_ADDR_VAR 0 50
79701: PUSH
79702: LD_INT 2
79704: PUSH
79705: LD_INT 3
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: LD_INT 3
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79726: LD_ADDR_VAR 0 51
79730: PUSH
79731: LD_INT 1
79733: NEG
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 2
79744: NEG
79745: PUSH
79746: LD_INT 1
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79757: LD_ADDR_VAR 0 52
79761: PUSH
79762: LD_INT 3
79764: NEG
79765: PUSH
79766: LD_INT 1
79768: NEG
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 3
79776: NEG
79777: PUSH
79778: LD_INT 2
79780: NEG
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79790: LD_ADDR_VAR 0 53
79794: PUSH
79795: LD_INT 1
79797: NEG
79798: PUSH
79799: LD_INT 3
79801: NEG
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 0
79809: PUSH
79810: LD_INT 3
79812: NEG
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 1
79820: PUSH
79821: LD_INT 2
79823: NEG
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: LIST
79833: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79834: LD_ADDR_VAR 0 54
79838: PUSH
79839: LD_INT 2
79841: PUSH
79842: LD_INT 1
79844: NEG
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 3
79852: PUSH
79853: LD_INT 0
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 3
79862: PUSH
79863: LD_INT 1
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: LIST
79874: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79875: LD_ADDR_VAR 0 55
79879: PUSH
79880: LD_INT 3
79882: PUSH
79883: LD_INT 2
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 3
79892: PUSH
79893: LD_INT 3
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 2
79902: PUSH
79903: LD_INT 3
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: LIST
79914: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79915: LD_ADDR_VAR 0 56
79919: PUSH
79920: LD_INT 1
79922: PUSH
79923: LD_INT 3
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 0
79932: PUSH
79933: LD_INT 3
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 1
79942: NEG
79943: PUSH
79944: LD_INT 2
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: LIST
79955: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79956: LD_ADDR_VAR 0 57
79960: PUSH
79961: LD_INT 2
79963: NEG
79964: PUSH
79965: LD_INT 1
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 3
79974: NEG
79975: PUSH
79976: LD_INT 0
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: PUSH
79983: LD_INT 3
79985: NEG
79986: PUSH
79987: LD_INT 1
79989: NEG
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: LIST
79999: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80000: LD_ADDR_VAR 0 58
80004: PUSH
80005: LD_INT 2
80007: NEG
80008: PUSH
80009: LD_INT 3
80011: NEG
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 3
80019: NEG
80020: PUSH
80021: LD_INT 2
80023: NEG
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 3
80031: NEG
80032: PUSH
80033: LD_INT 3
80035: NEG
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: LIST
80045: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80046: LD_ADDR_VAR 0 59
80050: PUSH
80051: LD_INT 1
80053: NEG
80054: PUSH
80055: LD_INT 2
80057: NEG
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 0
80065: PUSH
80066: LD_INT 2
80068: NEG
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 1
80076: PUSH
80077: LD_INT 1
80079: NEG
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: LIST
80089: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80090: LD_ADDR_VAR 0 60
80094: PUSH
80095: LD_INT 1
80097: PUSH
80098: LD_INT 1
80100: NEG
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 2
80108: PUSH
80109: LD_INT 0
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 2
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: LIST
80130: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80131: LD_ADDR_VAR 0 61
80135: PUSH
80136: LD_INT 2
80138: PUSH
80139: LD_INT 1
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 2
80148: PUSH
80149: LD_INT 2
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 1
80158: PUSH
80159: LD_INT 2
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: LIST
80170: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80171: LD_ADDR_VAR 0 62
80175: PUSH
80176: LD_INT 1
80178: PUSH
80179: LD_INT 2
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 0
80188: PUSH
80189: LD_INT 2
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 1
80198: NEG
80199: PUSH
80200: LD_INT 1
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: LIST
80211: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80212: LD_ADDR_VAR 0 63
80216: PUSH
80217: LD_INT 1
80219: NEG
80220: PUSH
80221: LD_INT 1
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 2
80230: NEG
80231: PUSH
80232: LD_INT 0
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 2
80241: NEG
80242: PUSH
80243: LD_INT 1
80245: NEG
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: LIST
80255: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80256: LD_ADDR_VAR 0 64
80260: PUSH
80261: LD_INT 1
80263: NEG
80264: PUSH
80265: LD_INT 2
80267: NEG
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 2
80275: NEG
80276: PUSH
80277: LD_INT 1
80279: NEG
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 2
80287: NEG
80288: PUSH
80289: LD_INT 2
80291: NEG
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: LIST
80301: ST_TO_ADDR
// end ; 2 :
80302: GO 83568
80304: LD_INT 2
80306: DOUBLE
80307: EQUAL
80308: IFTRUE 80312
80310: GO 83567
80312: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80313: LD_ADDR_VAR 0 29
80317: PUSH
80318: LD_INT 4
80320: PUSH
80321: LD_INT 0
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 4
80330: PUSH
80331: LD_INT 1
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 5
80341: PUSH
80342: LD_INT 0
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: LD_INT 5
80351: PUSH
80352: LD_INT 1
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: PUSH
80359: LD_INT 4
80361: PUSH
80362: LD_INT 1
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 3
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 3
80381: PUSH
80382: LD_INT 1
80384: NEG
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 3
80392: PUSH
80393: LD_INT 2
80395: NEG
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 5
80403: PUSH
80404: LD_INT 2
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 3
80413: PUSH
80414: LD_INT 3
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: PUSH
80421: LD_INT 3
80423: PUSH
80424: LD_INT 2
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 4
80433: PUSH
80434: LD_INT 3
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PUSH
80441: LD_INT 4
80443: PUSH
80444: LD_INT 4
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 3
80453: PUSH
80454: LD_INT 4
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 2
80463: PUSH
80464: LD_INT 3
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: LD_INT 2
80473: PUSH
80474: LD_INT 2
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 4
80483: PUSH
80484: LD_INT 2
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: PUSH
80491: LD_INT 2
80493: PUSH
80494: LD_INT 4
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 0
80503: PUSH
80504: LD_INT 4
80506: PUSH
80507: EMPTY
80508: LIST
80509: LIST
80510: PUSH
80511: LD_INT 0
80513: PUSH
80514: LD_INT 3
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: LD_INT 1
80523: PUSH
80524: LD_INT 4
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 1
80533: PUSH
80534: LD_INT 5
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 0
80543: PUSH
80544: LD_INT 5
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 1
80553: NEG
80554: PUSH
80555: LD_INT 4
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 1
80564: NEG
80565: PUSH
80566: LD_INT 3
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 2
80575: PUSH
80576: LD_INT 5
80578: PUSH
80579: EMPTY
80580: LIST
80581: LIST
80582: PUSH
80583: LD_INT 2
80585: NEG
80586: PUSH
80587: LD_INT 3
80589: PUSH
80590: EMPTY
80591: LIST
80592: LIST
80593: PUSH
80594: LD_INT 3
80596: NEG
80597: PUSH
80598: LD_INT 0
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 3
80607: NEG
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 2
80619: NEG
80620: PUSH
80621: LD_INT 0
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 2
80630: NEG
80631: PUSH
80632: LD_INT 1
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PUSH
80639: LD_INT 3
80641: NEG
80642: PUSH
80643: LD_INT 1
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: PUSH
80650: LD_INT 4
80652: NEG
80653: PUSH
80654: LD_INT 0
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 4
80663: NEG
80664: PUSH
80665: LD_INT 1
80667: NEG
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 4
80675: NEG
80676: PUSH
80677: LD_INT 2
80679: NEG
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 2
80687: NEG
80688: PUSH
80689: LD_INT 2
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 4
80698: NEG
80699: PUSH
80700: LD_INT 4
80702: NEG
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: LD_INT 4
80710: NEG
80711: PUSH
80712: LD_INT 5
80714: NEG
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 3
80722: NEG
80723: PUSH
80724: LD_INT 4
80726: NEG
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: PUSH
80732: LD_INT 3
80734: NEG
80735: PUSH
80736: LD_INT 3
80738: NEG
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 4
80746: NEG
80747: PUSH
80748: LD_INT 3
80750: NEG
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 5
80758: NEG
80759: PUSH
80760: LD_INT 4
80762: NEG
80763: PUSH
80764: EMPTY
80765: LIST
80766: LIST
80767: PUSH
80768: LD_INT 5
80770: NEG
80771: PUSH
80772: LD_INT 5
80774: NEG
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 3
80782: NEG
80783: PUSH
80784: LD_INT 5
80786: NEG
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 5
80794: NEG
80795: PUSH
80796: LD_INT 3
80798: NEG
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: LIST
80808: LIST
80809: LIST
80810: LIST
80811: LIST
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: LIST
80835: LIST
80836: LIST
80837: LIST
80838: LIST
80839: LIST
80840: LIST
80841: LIST
80842: LIST
80843: LIST
80844: LIST
80845: LIST
80846: LIST
80847: LIST
80848: LIST
80849: LIST
80850: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80851: LD_ADDR_VAR 0 30
80855: PUSH
80856: LD_INT 4
80858: PUSH
80859: LD_INT 4
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 4
80868: PUSH
80869: LD_INT 3
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 5
80878: PUSH
80879: LD_INT 4
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 5
80888: PUSH
80889: LD_INT 5
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: PUSH
80896: LD_INT 4
80898: PUSH
80899: LD_INT 5
80901: PUSH
80902: EMPTY
80903: LIST
80904: LIST
80905: PUSH
80906: LD_INT 3
80908: PUSH
80909: LD_INT 4
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 3
80918: PUSH
80919: LD_INT 3
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 5
80928: PUSH
80929: LD_INT 3
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 3
80938: PUSH
80939: LD_INT 5
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 0
80948: PUSH
80949: LD_INT 3
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 0
80958: PUSH
80959: LD_INT 2
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 1
80968: PUSH
80969: LD_INT 3
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 1
80978: PUSH
80979: LD_INT 4
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 0
80988: PUSH
80989: LD_INT 4
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: LD_INT 3
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 1
81009: NEG
81010: PUSH
81011: LD_INT 2
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: LD_INT 2
81020: PUSH
81021: LD_INT 4
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 2
81030: NEG
81031: PUSH
81032: LD_INT 2
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 4
81041: NEG
81042: PUSH
81043: LD_INT 0
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 4
81052: NEG
81053: PUSH
81054: LD_INT 1
81056: NEG
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 3
81064: NEG
81065: PUSH
81066: LD_INT 0
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 3
81075: NEG
81076: PUSH
81077: LD_INT 1
81079: PUSH
81080: EMPTY
81081: LIST
81082: LIST
81083: PUSH
81084: LD_INT 4
81086: NEG
81087: PUSH
81088: LD_INT 1
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 5
81097: NEG
81098: PUSH
81099: LD_INT 0
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 5
81108: NEG
81109: PUSH
81110: LD_INT 1
81112: NEG
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: LD_INT 5
81120: NEG
81121: PUSH
81122: LD_INT 2
81124: NEG
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 3
81132: NEG
81133: PUSH
81134: LD_INT 2
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 3
81143: NEG
81144: PUSH
81145: LD_INT 3
81147: NEG
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 3
81155: NEG
81156: PUSH
81157: LD_INT 4
81159: NEG
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 2
81167: NEG
81168: PUSH
81169: LD_INT 3
81171: NEG
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 2
81179: NEG
81180: PUSH
81181: LD_INT 2
81183: NEG
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 3
81191: NEG
81192: PUSH
81193: LD_INT 2
81195: NEG
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 4
81203: NEG
81204: PUSH
81205: LD_INT 3
81207: NEG
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 4
81215: NEG
81216: PUSH
81217: LD_INT 4
81219: NEG
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 2
81227: NEG
81228: PUSH
81229: LD_INT 4
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 4
81239: NEG
81240: PUSH
81241: LD_INT 2
81243: NEG
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 0
81251: PUSH
81252: LD_INT 4
81254: NEG
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 0
81262: PUSH
81263: LD_INT 5
81265: NEG
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: PUSH
81271: LD_INT 1
81273: PUSH
81274: LD_INT 4
81276: NEG
81277: PUSH
81278: EMPTY
81279: LIST
81280: LIST
81281: PUSH
81282: LD_INT 1
81284: PUSH
81285: LD_INT 3
81287: NEG
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 0
81295: PUSH
81296: LD_INT 3
81298: NEG
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 1
81306: NEG
81307: PUSH
81308: LD_INT 4
81310: NEG
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 1
81318: NEG
81319: PUSH
81320: LD_INT 5
81322: NEG
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 2
81330: PUSH
81331: LD_INT 3
81333: NEG
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: LD_INT 2
81341: NEG
81342: PUSH
81343: LD_INT 5
81345: NEG
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: LIST
81355: LIST
81356: LIST
81357: LIST
81358: LIST
81359: LIST
81360: LIST
81361: LIST
81362: LIST
81363: LIST
81364: LIST
81365: LIST
81366: LIST
81367: LIST
81368: LIST
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: LIST
81386: LIST
81387: LIST
81388: LIST
81389: LIST
81390: LIST
81391: LIST
81392: LIST
81393: LIST
81394: LIST
81395: LIST
81396: LIST
81397: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81398: LD_ADDR_VAR 0 31
81402: PUSH
81403: LD_INT 0
81405: PUSH
81406: LD_INT 4
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: LD_INT 0
81415: PUSH
81416: LD_INT 3
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PUSH
81423: LD_INT 1
81425: PUSH
81426: LD_INT 4
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: PUSH
81433: LD_INT 1
81435: PUSH
81436: LD_INT 5
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: LD_INT 0
81445: PUSH
81446: LD_INT 5
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PUSH
81453: LD_INT 1
81455: NEG
81456: PUSH
81457: LD_INT 4
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 1
81466: NEG
81467: PUSH
81468: LD_INT 3
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: LD_INT 2
81477: PUSH
81478: LD_INT 5
81480: PUSH
81481: EMPTY
81482: LIST
81483: LIST
81484: PUSH
81485: LD_INT 2
81487: NEG
81488: PUSH
81489: LD_INT 3
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: PUSH
81496: LD_INT 3
81498: NEG
81499: PUSH
81500: LD_INT 0
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 3
81509: NEG
81510: PUSH
81511: LD_INT 1
81513: NEG
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 2
81521: NEG
81522: PUSH
81523: LD_INT 0
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 2
81532: NEG
81533: PUSH
81534: LD_INT 1
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: PUSH
81541: LD_INT 3
81543: NEG
81544: PUSH
81545: LD_INT 1
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: LD_INT 4
81554: NEG
81555: PUSH
81556: LD_INT 0
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: PUSH
81563: LD_INT 4
81565: NEG
81566: PUSH
81567: LD_INT 1
81569: NEG
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 4
81577: NEG
81578: PUSH
81579: LD_INT 2
81581: NEG
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 2
81589: NEG
81590: PUSH
81591: LD_INT 2
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 4
81600: NEG
81601: PUSH
81602: LD_INT 4
81604: NEG
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 4
81612: NEG
81613: PUSH
81614: LD_INT 5
81616: NEG
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: LD_INT 3
81624: NEG
81625: PUSH
81626: LD_INT 4
81628: NEG
81629: PUSH
81630: EMPTY
81631: LIST
81632: LIST
81633: PUSH
81634: LD_INT 3
81636: NEG
81637: PUSH
81638: LD_INT 3
81640: NEG
81641: PUSH
81642: EMPTY
81643: LIST
81644: LIST
81645: PUSH
81646: LD_INT 4
81648: NEG
81649: PUSH
81650: LD_INT 3
81652: NEG
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 5
81660: NEG
81661: PUSH
81662: LD_INT 4
81664: NEG
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 5
81672: NEG
81673: PUSH
81674: LD_INT 5
81676: NEG
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 3
81684: NEG
81685: PUSH
81686: LD_INT 5
81688: NEG
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 5
81696: NEG
81697: PUSH
81698: LD_INT 3
81700: NEG
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 0
81708: PUSH
81709: LD_INT 3
81711: NEG
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 0
81719: PUSH
81720: LD_INT 4
81722: NEG
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 1
81730: PUSH
81731: LD_INT 3
81733: NEG
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: PUSH
81739: LD_INT 1
81741: PUSH
81742: LD_INT 2
81744: NEG
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 0
81752: PUSH
81753: LD_INT 2
81755: NEG
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 1
81763: NEG
81764: PUSH
81765: LD_INT 3
81767: NEG
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 1
81775: NEG
81776: PUSH
81777: LD_INT 4
81779: NEG
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 2
81787: PUSH
81788: LD_INT 2
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 2
81798: NEG
81799: PUSH
81800: LD_INT 4
81802: NEG
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 4
81810: PUSH
81811: LD_INT 0
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 4
81820: PUSH
81821: LD_INT 1
81823: NEG
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 5
81831: PUSH
81832: LD_INT 0
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 5
81841: PUSH
81842: LD_INT 1
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: LD_INT 4
81851: PUSH
81852: LD_INT 1
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: PUSH
81859: LD_INT 3
81861: PUSH
81862: LD_INT 0
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 3
81871: PUSH
81872: LD_INT 1
81874: NEG
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 3
81882: PUSH
81883: LD_INT 2
81885: NEG
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 5
81893: PUSH
81894: LD_INT 2
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: LIST
81905: LIST
81906: LIST
81907: LIST
81908: LIST
81909: LIST
81910: LIST
81911: LIST
81912: LIST
81913: LIST
81914: LIST
81915: LIST
81916: LIST
81917: LIST
81918: LIST
81919: LIST
81920: LIST
81921: LIST
81922: LIST
81923: LIST
81924: LIST
81925: LIST
81926: LIST
81927: LIST
81928: LIST
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81948: LD_ADDR_VAR 0 32
81952: PUSH
81953: LD_INT 4
81955: NEG
81956: PUSH
81957: LD_INT 0
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 4
81966: NEG
81967: PUSH
81968: LD_INT 1
81970: NEG
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 3
81978: NEG
81979: PUSH
81980: LD_INT 0
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 3
81989: NEG
81990: PUSH
81991: LD_INT 1
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 4
82000: NEG
82001: PUSH
82002: LD_INT 1
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 5
82011: NEG
82012: PUSH
82013: LD_INT 0
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 5
82022: NEG
82023: PUSH
82024: LD_INT 1
82026: NEG
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 5
82034: NEG
82035: PUSH
82036: LD_INT 2
82038: NEG
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 3
82046: NEG
82047: PUSH
82048: LD_INT 2
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 3
82057: NEG
82058: PUSH
82059: LD_INT 3
82061: NEG
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 3
82069: NEG
82070: PUSH
82071: LD_INT 4
82073: NEG
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: PUSH
82079: LD_INT 2
82081: NEG
82082: PUSH
82083: LD_INT 3
82085: NEG
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 2
82093: NEG
82094: PUSH
82095: LD_INT 2
82097: NEG
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 3
82105: NEG
82106: PUSH
82107: LD_INT 2
82109: NEG
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: LD_INT 4
82117: NEG
82118: PUSH
82119: LD_INT 3
82121: NEG
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 4
82129: NEG
82130: PUSH
82131: LD_INT 4
82133: NEG
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 2
82141: NEG
82142: PUSH
82143: LD_INT 4
82145: NEG
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 4
82153: NEG
82154: PUSH
82155: LD_INT 2
82157: NEG
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 0
82165: PUSH
82166: LD_INT 4
82168: NEG
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 0
82176: PUSH
82177: LD_INT 5
82179: NEG
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 1
82187: PUSH
82188: LD_INT 4
82190: NEG
82191: PUSH
82192: EMPTY
82193: LIST
82194: LIST
82195: PUSH
82196: LD_INT 1
82198: PUSH
82199: LD_INT 3
82201: NEG
82202: PUSH
82203: EMPTY
82204: LIST
82205: LIST
82206: PUSH
82207: LD_INT 0
82209: PUSH
82210: LD_INT 3
82212: NEG
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 1
82220: NEG
82221: PUSH
82222: LD_INT 4
82224: NEG
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 1
82232: NEG
82233: PUSH
82234: LD_INT 5
82236: NEG
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 2
82244: PUSH
82245: LD_INT 3
82247: NEG
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 2
82255: NEG
82256: PUSH
82257: LD_INT 5
82259: NEG
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 3
82267: PUSH
82268: LD_INT 0
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 3
82277: PUSH
82278: LD_INT 1
82280: NEG
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 4
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 4
82298: PUSH
82299: LD_INT 1
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: LD_INT 3
82308: PUSH
82309: LD_INT 1
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 2
82318: PUSH
82319: LD_INT 0
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 2
82328: PUSH
82329: LD_INT 1
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 2
82339: PUSH
82340: LD_INT 2
82342: NEG
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 4
82350: PUSH
82351: LD_INT 2
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 4
82360: PUSH
82361: LD_INT 4
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PUSH
82368: LD_INT 4
82370: PUSH
82371: LD_INT 3
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 5
82380: PUSH
82381: LD_INT 4
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 5
82390: PUSH
82391: LD_INT 5
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 4
82400: PUSH
82401: LD_INT 5
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: PUSH
82408: LD_INT 3
82410: PUSH
82411: LD_INT 4
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 3
82420: PUSH
82421: LD_INT 3
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 5
82430: PUSH
82431: LD_INT 3
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 3
82440: PUSH
82441: LD_INT 5
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: LIST
82452: LIST
82453: LIST
82454: LIST
82455: LIST
82456: LIST
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: LIST
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: LIST
82469: LIST
82470: LIST
82471: LIST
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: LIST
82477: LIST
82478: LIST
82479: LIST
82480: LIST
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: LIST
82486: LIST
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82495: LD_ADDR_VAR 0 33
82499: PUSH
82500: LD_INT 4
82502: NEG
82503: PUSH
82504: LD_INT 4
82506: NEG
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 4
82514: NEG
82515: PUSH
82516: LD_INT 5
82518: NEG
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 3
82526: NEG
82527: PUSH
82528: LD_INT 4
82530: NEG
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 3
82538: NEG
82539: PUSH
82540: LD_INT 3
82542: NEG
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 4
82550: NEG
82551: PUSH
82552: LD_INT 3
82554: NEG
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 5
82562: NEG
82563: PUSH
82564: LD_INT 4
82566: NEG
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 5
82574: NEG
82575: PUSH
82576: LD_INT 5
82578: NEG
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: PUSH
82584: LD_INT 3
82586: NEG
82587: PUSH
82588: LD_INT 5
82590: NEG
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 5
82598: NEG
82599: PUSH
82600: LD_INT 3
82602: NEG
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 0
82610: PUSH
82611: LD_INT 3
82613: NEG
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 0
82621: PUSH
82622: LD_INT 4
82624: NEG
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 1
82632: PUSH
82633: LD_INT 3
82635: NEG
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: PUSH
82641: LD_INT 1
82643: PUSH
82644: LD_INT 2
82646: NEG
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 0
82654: PUSH
82655: LD_INT 2
82657: NEG
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 1
82665: NEG
82666: PUSH
82667: LD_INT 3
82669: NEG
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 1
82677: NEG
82678: PUSH
82679: LD_INT 4
82681: NEG
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 2
82689: PUSH
82690: LD_INT 2
82692: NEG
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 2
82700: NEG
82701: PUSH
82702: LD_INT 4
82704: NEG
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 4
82712: PUSH
82713: LD_INT 0
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 4
82722: PUSH
82723: LD_INT 1
82725: NEG
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: PUSH
82731: LD_INT 5
82733: PUSH
82734: LD_INT 0
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 5
82743: PUSH
82744: LD_INT 1
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 4
82753: PUSH
82754: LD_INT 1
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 3
82763: PUSH
82764: LD_INT 0
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 3
82773: PUSH
82774: LD_INT 1
82776: NEG
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 3
82784: PUSH
82785: LD_INT 2
82787: NEG
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: PUSH
82793: LD_INT 5
82795: PUSH
82796: LD_INT 2
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: PUSH
82803: LD_INT 3
82805: PUSH
82806: LD_INT 3
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 3
82815: PUSH
82816: LD_INT 2
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 4
82825: PUSH
82826: LD_INT 3
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 4
82835: PUSH
82836: LD_INT 4
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 3
82845: PUSH
82846: LD_INT 4
82848: PUSH
82849: EMPTY
82850: LIST
82851: LIST
82852: PUSH
82853: LD_INT 2
82855: PUSH
82856: LD_INT 3
82858: PUSH
82859: EMPTY
82860: LIST
82861: LIST
82862: PUSH
82863: LD_INT 2
82865: PUSH
82866: LD_INT 2
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 4
82875: PUSH
82876: LD_INT 2
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 2
82885: PUSH
82886: LD_INT 4
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 0
82895: PUSH
82896: LD_INT 4
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 0
82905: PUSH
82906: LD_INT 3
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: LD_INT 1
82915: PUSH
82916: LD_INT 4
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 1
82925: PUSH
82926: LD_INT 5
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 0
82935: PUSH
82936: LD_INT 5
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: LD_INT 1
82945: NEG
82946: PUSH
82947: LD_INT 4
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 1
82956: NEG
82957: PUSH
82958: LD_INT 3
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: LD_INT 2
82967: PUSH
82968: LD_INT 5
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 2
82977: NEG
82978: PUSH
82979: LD_INT 3
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: LIST
83025: LIST
83026: LIST
83027: LIST
83028: LIST
83029: LIST
83030: LIST
83031: LIST
83032: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83033: LD_ADDR_VAR 0 34
83037: PUSH
83038: LD_INT 0
83040: PUSH
83041: LD_INT 4
83043: NEG
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 0
83051: PUSH
83052: LD_INT 5
83054: NEG
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 1
83062: PUSH
83063: LD_INT 4
83065: NEG
83066: PUSH
83067: EMPTY
83068: LIST
83069: LIST
83070: PUSH
83071: LD_INT 1
83073: PUSH
83074: LD_INT 3
83076: NEG
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 0
83084: PUSH
83085: LD_INT 3
83087: NEG
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: PUSH
83093: LD_INT 1
83095: NEG
83096: PUSH
83097: LD_INT 4
83099: NEG
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PUSH
83105: LD_INT 1
83107: NEG
83108: PUSH
83109: LD_INT 5
83111: NEG
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 2
83119: PUSH
83120: LD_INT 3
83122: NEG
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 2
83130: NEG
83131: PUSH
83132: LD_INT 5
83134: NEG
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 3
83142: PUSH
83143: LD_INT 0
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: PUSH
83150: LD_INT 3
83152: PUSH
83153: LD_INT 1
83155: NEG
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 4
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 4
83173: PUSH
83174: LD_INT 1
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: LD_INT 3
83183: PUSH
83184: LD_INT 1
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 2
83193: PUSH
83194: LD_INT 0
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 2
83203: PUSH
83204: LD_INT 1
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 2
83214: PUSH
83215: LD_INT 2
83217: NEG
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PUSH
83223: LD_INT 4
83225: PUSH
83226: LD_INT 2
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 4
83235: PUSH
83236: LD_INT 4
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 4
83245: PUSH
83246: LD_INT 3
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: PUSH
83253: LD_INT 5
83255: PUSH
83256: LD_INT 4
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 5
83265: PUSH
83266: LD_INT 5
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 4
83275: PUSH
83276: LD_INT 5
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 3
83285: PUSH
83286: LD_INT 4
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 3
83295: PUSH
83296: LD_INT 3
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 5
83305: PUSH
83306: LD_INT 3
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 3
83315: PUSH
83316: LD_INT 5
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 0
83325: PUSH
83326: LD_INT 3
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 0
83335: PUSH
83336: LD_INT 2
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: PUSH
83343: LD_INT 1
83345: PUSH
83346: LD_INT 3
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: LD_INT 1
83355: PUSH
83356: LD_INT 4
83358: PUSH
83359: EMPTY
83360: LIST
83361: LIST
83362: PUSH
83363: LD_INT 0
83365: PUSH
83366: LD_INT 4
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: LD_INT 1
83375: NEG
83376: PUSH
83377: LD_INT 3
83379: PUSH
83380: EMPTY
83381: LIST
83382: LIST
83383: PUSH
83384: LD_INT 1
83386: NEG
83387: PUSH
83388: LD_INT 2
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 2
83397: PUSH
83398: LD_INT 4
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 2
83407: NEG
83408: PUSH
83409: LD_INT 2
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 4
83418: NEG
83419: PUSH
83420: LD_INT 0
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 4
83429: NEG
83430: PUSH
83431: LD_INT 1
83433: NEG
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 3
83441: NEG
83442: PUSH
83443: LD_INT 0
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 3
83452: NEG
83453: PUSH
83454: LD_INT 1
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 4
83463: NEG
83464: PUSH
83465: LD_INT 1
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 5
83474: NEG
83475: PUSH
83476: LD_INT 0
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 5
83485: NEG
83486: PUSH
83487: LD_INT 1
83489: NEG
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 5
83497: NEG
83498: PUSH
83499: LD_INT 2
83501: NEG
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 3
83509: NEG
83510: PUSH
83511: LD_INT 2
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: ST_TO_ADDR
// end ; end ;
83565: GO 83568
83567: POP
// case btype of b_depot , b_warehouse :
83568: LD_VAR 0 1
83572: PUSH
83573: LD_INT 0
83575: DOUBLE
83576: EQUAL
83577: IFTRUE 83587
83579: LD_INT 1
83581: DOUBLE
83582: EQUAL
83583: IFTRUE 83587
83585: GO 83788
83587: POP
// case nation of nation_american :
83588: LD_VAR 0 5
83592: PUSH
83593: LD_INT 1
83595: DOUBLE
83596: EQUAL
83597: IFTRUE 83601
83599: GO 83657
83601: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83602: LD_ADDR_VAR 0 9
83606: PUSH
83607: LD_VAR 0 11
83611: PUSH
83612: LD_VAR 0 12
83616: PUSH
83617: LD_VAR 0 13
83621: PUSH
83622: LD_VAR 0 14
83626: PUSH
83627: LD_VAR 0 15
83631: PUSH
83632: LD_VAR 0 16
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: PUSH
83645: LD_VAR 0 4
83649: PUSH
83650: LD_INT 1
83652: PLUS
83653: ARRAY
83654: ST_TO_ADDR
83655: GO 83786
83657: LD_INT 2
83659: DOUBLE
83660: EQUAL
83661: IFTRUE 83665
83663: GO 83721
83665: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83666: LD_ADDR_VAR 0 9
83670: PUSH
83671: LD_VAR 0 17
83675: PUSH
83676: LD_VAR 0 18
83680: PUSH
83681: LD_VAR 0 19
83685: PUSH
83686: LD_VAR 0 20
83690: PUSH
83691: LD_VAR 0 21
83695: PUSH
83696: LD_VAR 0 22
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: PUSH
83709: LD_VAR 0 4
83713: PUSH
83714: LD_INT 1
83716: PLUS
83717: ARRAY
83718: ST_TO_ADDR
83719: GO 83786
83721: LD_INT 3
83723: DOUBLE
83724: EQUAL
83725: IFTRUE 83729
83727: GO 83785
83729: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83730: LD_ADDR_VAR 0 9
83734: PUSH
83735: LD_VAR 0 23
83739: PUSH
83740: LD_VAR 0 24
83744: PUSH
83745: LD_VAR 0 25
83749: PUSH
83750: LD_VAR 0 26
83754: PUSH
83755: LD_VAR 0 27
83759: PUSH
83760: LD_VAR 0 28
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: PUSH
83773: LD_VAR 0 4
83777: PUSH
83778: LD_INT 1
83780: PLUS
83781: ARRAY
83782: ST_TO_ADDR
83783: GO 83786
83785: POP
83786: GO 84341
83788: LD_INT 2
83790: DOUBLE
83791: EQUAL
83792: IFTRUE 83802
83794: LD_INT 3
83796: DOUBLE
83797: EQUAL
83798: IFTRUE 83802
83800: GO 83858
83802: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83803: LD_ADDR_VAR 0 9
83807: PUSH
83808: LD_VAR 0 29
83812: PUSH
83813: LD_VAR 0 30
83817: PUSH
83818: LD_VAR 0 31
83822: PUSH
83823: LD_VAR 0 32
83827: PUSH
83828: LD_VAR 0 33
83832: PUSH
83833: LD_VAR 0 34
83837: PUSH
83838: EMPTY
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: PUSH
83846: LD_VAR 0 4
83850: PUSH
83851: LD_INT 1
83853: PLUS
83854: ARRAY
83855: ST_TO_ADDR
83856: GO 84341
83858: LD_INT 16
83860: DOUBLE
83861: EQUAL
83862: IFTRUE 83920
83864: LD_INT 17
83866: DOUBLE
83867: EQUAL
83868: IFTRUE 83920
83870: LD_INT 18
83872: DOUBLE
83873: EQUAL
83874: IFTRUE 83920
83876: LD_INT 19
83878: DOUBLE
83879: EQUAL
83880: IFTRUE 83920
83882: LD_INT 22
83884: DOUBLE
83885: EQUAL
83886: IFTRUE 83920
83888: LD_INT 20
83890: DOUBLE
83891: EQUAL
83892: IFTRUE 83920
83894: LD_INT 21
83896: DOUBLE
83897: EQUAL
83898: IFTRUE 83920
83900: LD_INT 23
83902: DOUBLE
83903: EQUAL
83904: IFTRUE 83920
83906: LD_INT 24
83908: DOUBLE
83909: EQUAL
83910: IFTRUE 83920
83912: LD_INT 25
83914: DOUBLE
83915: EQUAL
83916: IFTRUE 83920
83918: GO 83976
83920: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83921: LD_ADDR_VAR 0 9
83925: PUSH
83926: LD_VAR 0 35
83930: PUSH
83931: LD_VAR 0 36
83935: PUSH
83936: LD_VAR 0 37
83940: PUSH
83941: LD_VAR 0 38
83945: PUSH
83946: LD_VAR 0 39
83950: PUSH
83951: LD_VAR 0 40
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: PUSH
83964: LD_VAR 0 4
83968: PUSH
83969: LD_INT 1
83971: PLUS
83972: ARRAY
83973: ST_TO_ADDR
83974: GO 84341
83976: LD_INT 6
83978: DOUBLE
83979: EQUAL
83980: IFTRUE 84032
83982: LD_INT 7
83984: DOUBLE
83985: EQUAL
83986: IFTRUE 84032
83988: LD_INT 8
83990: DOUBLE
83991: EQUAL
83992: IFTRUE 84032
83994: LD_INT 13
83996: DOUBLE
83997: EQUAL
83998: IFTRUE 84032
84000: LD_INT 12
84002: DOUBLE
84003: EQUAL
84004: IFTRUE 84032
84006: LD_INT 15
84008: DOUBLE
84009: EQUAL
84010: IFTRUE 84032
84012: LD_INT 11
84014: DOUBLE
84015: EQUAL
84016: IFTRUE 84032
84018: LD_INT 14
84020: DOUBLE
84021: EQUAL
84022: IFTRUE 84032
84024: LD_INT 10
84026: DOUBLE
84027: EQUAL
84028: IFTRUE 84032
84030: GO 84088
84032: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
84033: LD_ADDR_VAR 0 9
84037: PUSH
84038: LD_VAR 0 41
84042: PUSH
84043: LD_VAR 0 42
84047: PUSH
84048: LD_VAR 0 43
84052: PUSH
84053: LD_VAR 0 44
84057: PUSH
84058: LD_VAR 0 45
84062: PUSH
84063: LD_VAR 0 46
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: PUSH
84076: LD_VAR 0 4
84080: PUSH
84081: LD_INT 1
84083: PLUS
84084: ARRAY
84085: ST_TO_ADDR
84086: GO 84341
84088: LD_INT 36
84090: DOUBLE
84091: EQUAL
84092: IFTRUE 84096
84094: GO 84152
84096: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84097: LD_ADDR_VAR 0 9
84101: PUSH
84102: LD_VAR 0 47
84106: PUSH
84107: LD_VAR 0 48
84111: PUSH
84112: LD_VAR 0 49
84116: PUSH
84117: LD_VAR 0 50
84121: PUSH
84122: LD_VAR 0 51
84126: PUSH
84127: LD_VAR 0 52
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: PUSH
84140: LD_VAR 0 4
84144: PUSH
84145: LD_INT 1
84147: PLUS
84148: ARRAY
84149: ST_TO_ADDR
84150: GO 84341
84152: LD_INT 4
84154: DOUBLE
84155: EQUAL
84156: IFTRUE 84178
84158: LD_INT 5
84160: DOUBLE
84161: EQUAL
84162: IFTRUE 84178
84164: LD_INT 34
84166: DOUBLE
84167: EQUAL
84168: IFTRUE 84178
84170: LD_INT 37
84172: DOUBLE
84173: EQUAL
84174: IFTRUE 84178
84176: GO 84234
84178: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84179: LD_ADDR_VAR 0 9
84183: PUSH
84184: LD_VAR 0 53
84188: PUSH
84189: LD_VAR 0 54
84193: PUSH
84194: LD_VAR 0 55
84198: PUSH
84199: LD_VAR 0 56
84203: PUSH
84204: LD_VAR 0 57
84208: PUSH
84209: LD_VAR 0 58
84213: PUSH
84214: EMPTY
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: PUSH
84222: LD_VAR 0 4
84226: PUSH
84227: LD_INT 1
84229: PLUS
84230: ARRAY
84231: ST_TO_ADDR
84232: GO 84341
84234: LD_INT 31
84236: DOUBLE
84237: EQUAL
84238: IFTRUE 84284
84240: LD_INT 32
84242: DOUBLE
84243: EQUAL
84244: IFTRUE 84284
84246: LD_INT 33
84248: DOUBLE
84249: EQUAL
84250: IFTRUE 84284
84252: LD_INT 27
84254: DOUBLE
84255: EQUAL
84256: IFTRUE 84284
84258: LD_INT 26
84260: DOUBLE
84261: EQUAL
84262: IFTRUE 84284
84264: LD_INT 28
84266: DOUBLE
84267: EQUAL
84268: IFTRUE 84284
84270: LD_INT 29
84272: DOUBLE
84273: EQUAL
84274: IFTRUE 84284
84276: LD_INT 30
84278: DOUBLE
84279: EQUAL
84280: IFTRUE 84284
84282: GO 84340
84284: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84285: LD_ADDR_VAR 0 9
84289: PUSH
84290: LD_VAR 0 59
84294: PUSH
84295: LD_VAR 0 60
84299: PUSH
84300: LD_VAR 0 61
84304: PUSH
84305: LD_VAR 0 62
84309: PUSH
84310: LD_VAR 0 63
84314: PUSH
84315: LD_VAR 0 64
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: PUSH
84328: LD_VAR 0 4
84332: PUSH
84333: LD_INT 1
84335: PLUS
84336: ARRAY
84337: ST_TO_ADDR
84338: GO 84341
84340: POP
// temp_list2 = [ ] ;
84341: LD_ADDR_VAR 0 10
84345: PUSH
84346: EMPTY
84347: ST_TO_ADDR
// for i in temp_list do
84348: LD_ADDR_VAR 0 8
84352: PUSH
84353: LD_VAR 0 9
84357: PUSH
84358: FOR_IN
84359: IFFALSE 84411
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84361: LD_ADDR_VAR 0 10
84365: PUSH
84366: LD_VAR 0 10
84370: PUSH
84371: LD_VAR 0 8
84375: PUSH
84376: LD_INT 1
84378: ARRAY
84379: PUSH
84380: LD_VAR 0 2
84384: PLUS
84385: PUSH
84386: LD_VAR 0 8
84390: PUSH
84391: LD_INT 2
84393: ARRAY
84394: PUSH
84395: LD_VAR 0 3
84399: PLUS
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: EMPTY
84406: LIST
84407: ADD
84408: ST_TO_ADDR
84409: GO 84358
84411: POP
84412: POP
// result = temp_list2 ;
84413: LD_ADDR_VAR 0 7
84417: PUSH
84418: LD_VAR 0 10
84422: ST_TO_ADDR
// end ;
84423: LD_VAR 0 7
84427: RET
// export function EnemyInRange ( unit , dist ) ; begin
84428: LD_INT 0
84430: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84431: LD_ADDR_VAR 0 3
84435: PUSH
84436: LD_VAR 0 1
84440: PPUSH
84441: CALL_OW 255
84445: PPUSH
84446: LD_VAR 0 1
84450: PPUSH
84451: CALL_OW 250
84455: PPUSH
84456: LD_VAR 0 1
84460: PPUSH
84461: CALL_OW 251
84465: PPUSH
84466: LD_VAR 0 2
84470: PPUSH
84471: CALL 58532 0 4
84475: PUSH
84476: LD_INT 4
84478: ARRAY
84479: ST_TO_ADDR
// end ;
84480: LD_VAR 0 3
84484: RET
// export function PlayerSeeMe ( unit ) ; begin
84485: LD_INT 0
84487: PPUSH
// result := See ( your_side , unit ) ;
84488: LD_ADDR_VAR 0 2
84492: PUSH
84493: LD_OWVAR 2
84497: PPUSH
84498: LD_VAR 0 1
84502: PPUSH
84503: CALL_OW 292
84507: ST_TO_ADDR
// end ;
84508: LD_VAR 0 2
84512: RET
// export function ReverseDir ( unit ) ; begin
84513: LD_INT 0
84515: PPUSH
// if not unit then
84516: LD_VAR 0 1
84520: NOT
84521: IFFALSE 84525
// exit ;
84523: GO 84571
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
84525: LD_ADDR_VAR 0 2
84529: PUSH
84530: LD_INT 3
84532: PUSH
84533: LD_INT 4
84535: PUSH
84536: LD_INT 5
84538: PUSH
84539: LD_INT 0
84541: PUSH
84542: LD_INT 1
84544: PUSH
84545: LD_INT 2
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: PUSH
84556: LD_VAR 0 1
84560: PPUSH
84561: CALL_OW 254
84565: PUSH
84566: LD_INT 1
84568: PLUS
84569: ARRAY
84570: ST_TO_ADDR
// end ;
84571: LD_VAR 0 2
84575: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84576: LD_INT 0
84578: PPUSH
84579: PPUSH
84580: PPUSH
84581: PPUSH
84582: PPUSH
// if not hexes then
84583: LD_VAR 0 2
84587: NOT
84588: IFFALSE 84592
// exit ;
84590: GO 84740
// dist := 9999 ;
84592: LD_ADDR_VAR 0 5
84596: PUSH
84597: LD_INT 9999
84599: ST_TO_ADDR
// for i = 1 to hexes do
84600: LD_ADDR_VAR 0 4
84604: PUSH
84605: DOUBLE
84606: LD_INT 1
84608: DEC
84609: ST_TO_ADDR
84610: LD_VAR 0 2
84614: PUSH
84615: FOR_TO
84616: IFFALSE 84728
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84618: LD_VAR 0 1
84622: PPUSH
84623: LD_VAR 0 2
84627: PUSH
84628: LD_VAR 0 4
84632: ARRAY
84633: PUSH
84634: LD_INT 1
84636: ARRAY
84637: PPUSH
84638: LD_VAR 0 2
84642: PUSH
84643: LD_VAR 0 4
84647: ARRAY
84648: PUSH
84649: LD_INT 2
84651: ARRAY
84652: PPUSH
84653: CALL_OW 297
84657: PUSH
84658: LD_VAR 0 5
84662: LESS
84663: IFFALSE 84726
// begin hex := hexes [ i ] ;
84665: LD_ADDR_VAR 0 7
84669: PUSH
84670: LD_VAR 0 2
84674: PUSH
84675: LD_VAR 0 4
84679: ARRAY
84680: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84681: LD_ADDR_VAR 0 5
84685: PUSH
84686: LD_VAR 0 1
84690: PPUSH
84691: LD_VAR 0 2
84695: PUSH
84696: LD_VAR 0 4
84700: ARRAY
84701: PUSH
84702: LD_INT 1
84704: ARRAY
84705: PPUSH
84706: LD_VAR 0 2
84710: PUSH
84711: LD_VAR 0 4
84715: ARRAY
84716: PUSH
84717: LD_INT 2
84719: ARRAY
84720: PPUSH
84721: CALL_OW 297
84725: ST_TO_ADDR
// end ; end ;
84726: GO 84615
84728: POP
84729: POP
// result := hex ;
84730: LD_ADDR_VAR 0 3
84734: PUSH
84735: LD_VAR 0 7
84739: ST_TO_ADDR
// end ;
84740: LD_VAR 0 3
84744: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84745: LD_INT 0
84747: PPUSH
84748: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84749: LD_VAR 0 1
84753: NOT
84754: PUSH
84755: LD_VAR 0 1
84759: PUSH
84760: LD_INT 21
84762: PUSH
84763: LD_INT 2
84765: PUSH
84766: EMPTY
84767: LIST
84768: LIST
84769: PUSH
84770: LD_INT 23
84772: PUSH
84773: LD_INT 2
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PPUSH
84784: CALL_OW 69
84788: IN
84789: NOT
84790: OR
84791: IFFALSE 84795
// exit ;
84793: GO 84842
// for i = 1 to 3 do
84795: LD_ADDR_VAR 0 3
84799: PUSH
84800: DOUBLE
84801: LD_INT 1
84803: DEC
84804: ST_TO_ADDR
84805: LD_INT 3
84807: PUSH
84808: FOR_TO
84809: IFFALSE 84840
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84811: LD_VAR 0 1
84815: PPUSH
84816: CALL_OW 250
84820: PPUSH
84821: LD_VAR 0 1
84825: PPUSH
84826: CALL_OW 251
84830: PPUSH
84831: LD_INT 1
84833: PPUSH
84834: CALL_OW 453
84838: GO 84808
84840: POP
84841: POP
// end ;
84842: LD_VAR 0 2
84846: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84847: LD_INT 0
84849: PPUSH
84850: PPUSH
84851: PPUSH
84852: PPUSH
84853: PPUSH
84854: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84855: LD_VAR 0 1
84859: NOT
84860: PUSH
84861: LD_VAR 0 2
84865: NOT
84866: OR
84867: PUSH
84868: LD_VAR 0 1
84872: PPUSH
84873: CALL_OW 314
84877: OR
84878: IFFALSE 84882
// exit ;
84880: GO 85323
// x := GetX ( enemy_unit ) ;
84882: LD_ADDR_VAR 0 7
84886: PUSH
84887: LD_VAR 0 2
84891: PPUSH
84892: CALL_OW 250
84896: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84897: LD_ADDR_VAR 0 8
84901: PUSH
84902: LD_VAR 0 2
84906: PPUSH
84907: CALL_OW 251
84911: ST_TO_ADDR
// if not x or not y then
84912: LD_VAR 0 7
84916: NOT
84917: PUSH
84918: LD_VAR 0 8
84922: NOT
84923: OR
84924: IFFALSE 84928
// exit ;
84926: GO 85323
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84928: LD_ADDR_VAR 0 6
84932: PUSH
84933: LD_VAR 0 7
84937: PPUSH
84938: LD_INT 0
84940: PPUSH
84941: LD_INT 4
84943: PPUSH
84944: CALL_OW 272
84948: PUSH
84949: LD_VAR 0 8
84953: PPUSH
84954: LD_INT 0
84956: PPUSH
84957: LD_INT 4
84959: PPUSH
84960: CALL_OW 273
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_VAR 0 7
84973: PPUSH
84974: LD_INT 1
84976: PPUSH
84977: LD_INT 4
84979: PPUSH
84980: CALL_OW 272
84984: PUSH
84985: LD_VAR 0 8
84989: PPUSH
84990: LD_INT 1
84992: PPUSH
84993: LD_INT 4
84995: PPUSH
84996: CALL_OW 273
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: PUSH
85005: LD_VAR 0 7
85009: PPUSH
85010: LD_INT 2
85012: PPUSH
85013: LD_INT 4
85015: PPUSH
85016: CALL_OW 272
85020: PUSH
85021: LD_VAR 0 8
85025: PPUSH
85026: LD_INT 2
85028: PPUSH
85029: LD_INT 4
85031: PPUSH
85032: CALL_OW 273
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_VAR 0 7
85045: PPUSH
85046: LD_INT 3
85048: PPUSH
85049: LD_INT 4
85051: PPUSH
85052: CALL_OW 272
85056: PUSH
85057: LD_VAR 0 8
85061: PPUSH
85062: LD_INT 3
85064: PPUSH
85065: LD_INT 4
85067: PPUSH
85068: CALL_OW 273
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_VAR 0 7
85081: PPUSH
85082: LD_INT 4
85084: PPUSH
85085: LD_INT 4
85087: PPUSH
85088: CALL_OW 272
85092: PUSH
85093: LD_VAR 0 8
85097: PPUSH
85098: LD_INT 4
85100: PPUSH
85101: LD_INT 4
85103: PPUSH
85104: CALL_OW 273
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_VAR 0 7
85117: PPUSH
85118: LD_INT 5
85120: PPUSH
85121: LD_INT 4
85123: PPUSH
85124: CALL_OW 272
85128: PUSH
85129: LD_VAR 0 8
85133: PPUSH
85134: LD_INT 5
85136: PPUSH
85137: LD_INT 4
85139: PPUSH
85140: CALL_OW 273
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: ST_TO_ADDR
// for i = tmp downto 1 do
85157: LD_ADDR_VAR 0 4
85161: PUSH
85162: DOUBLE
85163: LD_VAR 0 6
85167: INC
85168: ST_TO_ADDR
85169: LD_INT 1
85171: PUSH
85172: FOR_DOWNTO
85173: IFFALSE 85274
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85175: LD_VAR 0 6
85179: PUSH
85180: LD_VAR 0 4
85184: ARRAY
85185: PUSH
85186: LD_INT 1
85188: ARRAY
85189: PPUSH
85190: LD_VAR 0 6
85194: PUSH
85195: LD_VAR 0 4
85199: ARRAY
85200: PUSH
85201: LD_INT 2
85203: ARRAY
85204: PPUSH
85205: CALL_OW 488
85209: NOT
85210: PUSH
85211: LD_VAR 0 6
85215: PUSH
85216: LD_VAR 0 4
85220: ARRAY
85221: PUSH
85222: LD_INT 1
85224: ARRAY
85225: PPUSH
85226: LD_VAR 0 6
85230: PUSH
85231: LD_VAR 0 4
85235: ARRAY
85236: PUSH
85237: LD_INT 2
85239: ARRAY
85240: PPUSH
85241: CALL_OW 428
85245: PUSH
85246: LD_INT 0
85248: NONEQUAL
85249: OR
85250: IFFALSE 85272
// tmp := Delete ( tmp , i ) ;
85252: LD_ADDR_VAR 0 6
85256: PUSH
85257: LD_VAR 0 6
85261: PPUSH
85262: LD_VAR 0 4
85266: PPUSH
85267: CALL_OW 3
85271: ST_TO_ADDR
85272: GO 85172
85274: POP
85275: POP
// j := GetClosestHex ( unit , tmp ) ;
85276: LD_ADDR_VAR 0 5
85280: PUSH
85281: LD_VAR 0 1
85285: PPUSH
85286: LD_VAR 0 6
85290: PPUSH
85291: CALL 84576 0 2
85295: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85296: LD_VAR 0 1
85300: PPUSH
85301: LD_VAR 0 5
85305: PUSH
85306: LD_INT 1
85308: ARRAY
85309: PPUSH
85310: LD_VAR 0 5
85314: PUSH
85315: LD_INT 2
85317: ARRAY
85318: PPUSH
85319: CALL_OW 111
// end ;
85323: LD_VAR 0 3
85327: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85328: LD_INT 0
85330: PPUSH
85331: PPUSH
85332: PPUSH
// uc_side = 0 ;
85333: LD_ADDR_OWVAR 20
85337: PUSH
85338: LD_INT 0
85340: ST_TO_ADDR
// uc_nation = 0 ;
85341: LD_ADDR_OWVAR 21
85345: PUSH
85346: LD_INT 0
85348: ST_TO_ADDR
// InitHc ;
85349: CALL_OW 19
// InitVc ;
85353: CALL_OW 20
// if mastodonts then
85357: LD_VAR 0 6
85361: IFFALSE 85428
// for i = 1 to mastodonts do
85363: LD_ADDR_VAR 0 11
85367: PUSH
85368: DOUBLE
85369: LD_INT 1
85371: DEC
85372: ST_TO_ADDR
85373: LD_VAR 0 6
85377: PUSH
85378: FOR_TO
85379: IFFALSE 85426
// begin vc_chassis := 31 ;
85381: LD_ADDR_OWVAR 37
85385: PUSH
85386: LD_INT 31
85388: ST_TO_ADDR
// vc_control := control_rider ;
85389: LD_ADDR_OWVAR 38
85393: PUSH
85394: LD_INT 4
85396: ST_TO_ADDR
// animal := CreateVehicle ;
85397: LD_ADDR_VAR 0 12
85401: PUSH
85402: CALL_OW 45
85406: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85407: LD_VAR 0 12
85411: PPUSH
85412: LD_VAR 0 8
85416: PPUSH
85417: LD_INT 0
85419: PPUSH
85420: CALL 92173 0 3
// end ;
85424: GO 85378
85426: POP
85427: POP
// if horses then
85428: LD_VAR 0 5
85432: IFFALSE 85499
// for i = 1 to horses do
85434: LD_ADDR_VAR 0 11
85438: PUSH
85439: DOUBLE
85440: LD_INT 1
85442: DEC
85443: ST_TO_ADDR
85444: LD_VAR 0 5
85448: PUSH
85449: FOR_TO
85450: IFFALSE 85497
// begin hc_class := 21 ;
85452: LD_ADDR_OWVAR 28
85456: PUSH
85457: LD_INT 21
85459: ST_TO_ADDR
// hc_gallery :=  ;
85460: LD_ADDR_OWVAR 33
85464: PUSH
85465: LD_STRING 
85467: ST_TO_ADDR
// animal := CreateHuman ;
85468: LD_ADDR_VAR 0 12
85472: PUSH
85473: CALL_OW 44
85477: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85478: LD_VAR 0 12
85482: PPUSH
85483: LD_VAR 0 8
85487: PPUSH
85488: LD_INT 0
85490: PPUSH
85491: CALL 92173 0 3
// end ;
85495: GO 85449
85497: POP
85498: POP
// if birds then
85499: LD_VAR 0 1
85503: IFFALSE 85570
// for i = 1 to birds do
85505: LD_ADDR_VAR 0 11
85509: PUSH
85510: DOUBLE
85511: LD_INT 1
85513: DEC
85514: ST_TO_ADDR
85515: LD_VAR 0 1
85519: PUSH
85520: FOR_TO
85521: IFFALSE 85568
// begin hc_class = 18 ;
85523: LD_ADDR_OWVAR 28
85527: PUSH
85528: LD_INT 18
85530: ST_TO_ADDR
// hc_gallery =  ;
85531: LD_ADDR_OWVAR 33
85535: PUSH
85536: LD_STRING 
85538: ST_TO_ADDR
// animal := CreateHuman ;
85539: LD_ADDR_VAR 0 12
85543: PUSH
85544: CALL_OW 44
85548: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85549: LD_VAR 0 12
85553: PPUSH
85554: LD_VAR 0 8
85558: PPUSH
85559: LD_INT 0
85561: PPUSH
85562: CALL 92173 0 3
// end ;
85566: GO 85520
85568: POP
85569: POP
// if tigers then
85570: LD_VAR 0 2
85574: IFFALSE 85658
// for i = 1 to tigers do
85576: LD_ADDR_VAR 0 11
85580: PUSH
85581: DOUBLE
85582: LD_INT 1
85584: DEC
85585: ST_TO_ADDR
85586: LD_VAR 0 2
85590: PUSH
85591: FOR_TO
85592: IFFALSE 85656
// begin hc_class = class_tiger ;
85594: LD_ADDR_OWVAR 28
85598: PUSH
85599: LD_INT 14
85601: ST_TO_ADDR
// hc_gallery =  ;
85602: LD_ADDR_OWVAR 33
85606: PUSH
85607: LD_STRING 
85609: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85610: LD_ADDR_OWVAR 35
85614: PUSH
85615: LD_INT 7
85617: NEG
85618: PPUSH
85619: LD_INT 7
85621: PPUSH
85622: CALL_OW 12
85626: ST_TO_ADDR
// animal := CreateHuman ;
85627: LD_ADDR_VAR 0 12
85631: PUSH
85632: CALL_OW 44
85636: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85637: LD_VAR 0 12
85641: PPUSH
85642: LD_VAR 0 8
85646: PPUSH
85647: LD_INT 0
85649: PPUSH
85650: CALL 92173 0 3
// end ;
85654: GO 85591
85656: POP
85657: POP
// if apemans then
85658: LD_VAR 0 3
85662: IFFALSE 85785
// for i = 1 to apemans do
85664: LD_ADDR_VAR 0 11
85668: PUSH
85669: DOUBLE
85670: LD_INT 1
85672: DEC
85673: ST_TO_ADDR
85674: LD_VAR 0 3
85678: PUSH
85679: FOR_TO
85680: IFFALSE 85783
// begin hc_class = class_apeman ;
85682: LD_ADDR_OWVAR 28
85686: PUSH
85687: LD_INT 12
85689: ST_TO_ADDR
// hc_gallery =  ;
85690: LD_ADDR_OWVAR 33
85694: PUSH
85695: LD_STRING 
85697: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85698: LD_ADDR_OWVAR 35
85702: PUSH
85703: LD_INT 5
85705: NEG
85706: PPUSH
85707: LD_INT 5
85709: PPUSH
85710: CALL_OW 12
85714: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85715: LD_ADDR_OWVAR 31
85719: PUSH
85720: LD_INT 1
85722: PPUSH
85723: LD_INT 3
85725: PPUSH
85726: CALL_OW 12
85730: PUSH
85731: LD_INT 1
85733: PPUSH
85734: LD_INT 3
85736: PPUSH
85737: CALL_OW 12
85741: PUSH
85742: LD_INT 0
85744: PUSH
85745: LD_INT 0
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: ST_TO_ADDR
// animal := CreateHuman ;
85754: LD_ADDR_VAR 0 12
85758: PUSH
85759: CALL_OW 44
85763: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85764: LD_VAR 0 12
85768: PPUSH
85769: LD_VAR 0 8
85773: PPUSH
85774: LD_INT 0
85776: PPUSH
85777: CALL 92173 0 3
// end ;
85781: GO 85679
85783: POP
85784: POP
// if enchidnas then
85785: LD_VAR 0 4
85789: IFFALSE 85856
// for i = 1 to enchidnas do
85791: LD_ADDR_VAR 0 11
85795: PUSH
85796: DOUBLE
85797: LD_INT 1
85799: DEC
85800: ST_TO_ADDR
85801: LD_VAR 0 4
85805: PUSH
85806: FOR_TO
85807: IFFALSE 85854
// begin hc_class = 13 ;
85809: LD_ADDR_OWVAR 28
85813: PUSH
85814: LD_INT 13
85816: ST_TO_ADDR
// hc_gallery =  ;
85817: LD_ADDR_OWVAR 33
85821: PUSH
85822: LD_STRING 
85824: ST_TO_ADDR
// animal := CreateHuman ;
85825: LD_ADDR_VAR 0 12
85829: PUSH
85830: CALL_OW 44
85834: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85835: LD_VAR 0 12
85839: PPUSH
85840: LD_VAR 0 8
85844: PPUSH
85845: LD_INT 0
85847: PPUSH
85848: CALL 92173 0 3
// end ;
85852: GO 85806
85854: POP
85855: POP
// if fishes then
85856: LD_VAR 0 7
85860: IFFALSE 85927
// for i = 1 to fishes do
85862: LD_ADDR_VAR 0 11
85866: PUSH
85867: DOUBLE
85868: LD_INT 1
85870: DEC
85871: ST_TO_ADDR
85872: LD_VAR 0 7
85876: PUSH
85877: FOR_TO
85878: IFFALSE 85925
// begin hc_class = 20 ;
85880: LD_ADDR_OWVAR 28
85884: PUSH
85885: LD_INT 20
85887: ST_TO_ADDR
// hc_gallery =  ;
85888: LD_ADDR_OWVAR 33
85892: PUSH
85893: LD_STRING 
85895: ST_TO_ADDR
// animal := CreateHuman ;
85896: LD_ADDR_VAR 0 12
85900: PUSH
85901: CALL_OW 44
85905: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85906: LD_VAR 0 12
85910: PPUSH
85911: LD_VAR 0 9
85915: PPUSH
85916: LD_INT 0
85918: PPUSH
85919: CALL 92173 0 3
// end ;
85923: GO 85877
85925: POP
85926: POP
// end ;
85927: LD_VAR 0 10
85931: RET
// export function WantHeal ( sci , unit ) ; begin
85932: LD_INT 0
85934: PPUSH
// if GetTaskList ( sci ) > 0 then
85935: LD_VAR 0 1
85939: PPUSH
85940: CALL_OW 437
85944: PUSH
85945: LD_INT 0
85947: GREATER
85948: IFFALSE 86018
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85950: LD_VAR 0 1
85954: PPUSH
85955: CALL_OW 437
85959: PUSH
85960: LD_INT 1
85962: ARRAY
85963: PUSH
85964: LD_INT 1
85966: ARRAY
85967: PUSH
85968: LD_STRING l
85970: EQUAL
85971: PUSH
85972: LD_VAR 0 1
85976: PPUSH
85977: CALL_OW 437
85981: PUSH
85982: LD_INT 1
85984: ARRAY
85985: PUSH
85986: LD_INT 4
85988: ARRAY
85989: PUSH
85990: LD_VAR 0 2
85994: EQUAL
85995: AND
85996: IFFALSE 86008
// result := true else
85998: LD_ADDR_VAR 0 3
86002: PUSH
86003: LD_INT 1
86005: ST_TO_ADDR
86006: GO 86016
// result := false ;
86008: LD_ADDR_VAR 0 3
86012: PUSH
86013: LD_INT 0
86015: ST_TO_ADDR
// end else
86016: GO 86026
// result := false ;
86018: LD_ADDR_VAR 0 3
86022: PUSH
86023: LD_INT 0
86025: ST_TO_ADDR
// end ;
86026: LD_VAR 0 3
86030: RET
// export function HealTarget ( sci ) ; begin
86031: LD_INT 0
86033: PPUSH
// if not sci then
86034: LD_VAR 0 1
86038: NOT
86039: IFFALSE 86043
// exit ;
86041: GO 86108
// result := 0 ;
86043: LD_ADDR_VAR 0 2
86047: PUSH
86048: LD_INT 0
86050: ST_TO_ADDR
// if GetTaskList ( sci ) then
86051: LD_VAR 0 1
86055: PPUSH
86056: CALL_OW 437
86060: IFFALSE 86108
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86062: LD_VAR 0 1
86066: PPUSH
86067: CALL_OW 437
86071: PUSH
86072: LD_INT 1
86074: ARRAY
86075: PUSH
86076: LD_INT 1
86078: ARRAY
86079: PUSH
86080: LD_STRING l
86082: EQUAL
86083: IFFALSE 86108
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86085: LD_ADDR_VAR 0 2
86089: PUSH
86090: LD_VAR 0 1
86094: PPUSH
86095: CALL_OW 437
86099: PUSH
86100: LD_INT 1
86102: ARRAY
86103: PUSH
86104: LD_INT 4
86106: ARRAY
86107: ST_TO_ADDR
// end ;
86108: LD_VAR 0 2
86112: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
86113: LD_INT 0
86115: PPUSH
86116: PPUSH
86117: PPUSH
86118: PPUSH
86119: PPUSH
86120: PPUSH
86121: PPUSH
86122: PPUSH
86123: PPUSH
86124: PPUSH
86125: PPUSH
86126: PPUSH
86127: PPUSH
86128: PPUSH
86129: PPUSH
86130: PPUSH
86131: PPUSH
86132: PPUSH
86133: PPUSH
86134: PPUSH
86135: PPUSH
86136: PPUSH
86137: PPUSH
86138: PPUSH
86139: PPUSH
86140: PPUSH
86141: PPUSH
86142: PPUSH
86143: PPUSH
86144: PPUSH
86145: PPUSH
86146: PPUSH
86147: PPUSH
86148: PPUSH
// if not list then
86149: LD_VAR 0 1
86153: NOT
86154: IFFALSE 86158
// exit ;
86156: GO 90784
// base := list [ 1 ] ;
86158: LD_ADDR_VAR 0 3
86162: PUSH
86163: LD_VAR 0 1
86167: PUSH
86168: LD_INT 1
86170: ARRAY
86171: ST_TO_ADDR
// group := list [ 2 ] ;
86172: LD_ADDR_VAR 0 4
86176: PUSH
86177: LD_VAR 0 1
86181: PUSH
86182: LD_INT 2
86184: ARRAY
86185: ST_TO_ADDR
// path := list [ 3 ] ;
86186: LD_ADDR_VAR 0 5
86190: PUSH
86191: LD_VAR 0 1
86195: PUSH
86196: LD_INT 3
86198: ARRAY
86199: ST_TO_ADDR
// flags := list [ 4 ] ;
86200: LD_ADDR_VAR 0 6
86204: PUSH
86205: LD_VAR 0 1
86209: PUSH
86210: LD_INT 4
86212: ARRAY
86213: ST_TO_ADDR
// mined := [ ] ;
86214: LD_ADDR_VAR 0 27
86218: PUSH
86219: EMPTY
86220: ST_TO_ADDR
// bombed := [ ] ;
86221: LD_ADDR_VAR 0 28
86225: PUSH
86226: EMPTY
86227: ST_TO_ADDR
// healers := [ ] ;
86228: LD_ADDR_VAR 0 31
86232: PUSH
86233: EMPTY
86234: ST_TO_ADDR
// to_heal := [ ] ;
86235: LD_ADDR_VAR 0 30
86239: PUSH
86240: EMPTY
86241: ST_TO_ADDR
// repairs := [ ] ;
86242: LD_ADDR_VAR 0 33
86246: PUSH
86247: EMPTY
86248: ST_TO_ADDR
// to_repair := [ ] ;
86249: LD_ADDR_VAR 0 32
86253: PUSH
86254: EMPTY
86255: ST_TO_ADDR
// if not group or not path then
86256: LD_VAR 0 4
86260: NOT
86261: PUSH
86262: LD_VAR 0 5
86266: NOT
86267: OR
86268: IFFALSE 86272
// exit ;
86270: GO 90784
// side := GetSide ( group [ 1 ] ) ;
86272: LD_ADDR_VAR 0 35
86276: PUSH
86277: LD_VAR 0 4
86281: PUSH
86282: LD_INT 1
86284: ARRAY
86285: PPUSH
86286: CALL_OW 255
86290: ST_TO_ADDR
// if flags then
86291: LD_VAR 0 6
86295: IFFALSE 86439
// begin f_ignore_area := flags [ 1 ] ;
86297: LD_ADDR_VAR 0 17
86301: PUSH
86302: LD_VAR 0 6
86306: PUSH
86307: LD_INT 1
86309: ARRAY
86310: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86311: LD_ADDR_VAR 0 18
86315: PUSH
86316: LD_VAR 0 6
86320: PUSH
86321: LD_INT 2
86323: ARRAY
86324: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86325: LD_ADDR_VAR 0 19
86329: PUSH
86330: LD_VAR 0 6
86334: PUSH
86335: LD_INT 3
86337: ARRAY
86338: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86339: LD_ADDR_VAR 0 20
86343: PUSH
86344: LD_VAR 0 6
86348: PUSH
86349: LD_INT 4
86351: ARRAY
86352: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86353: LD_ADDR_VAR 0 21
86357: PUSH
86358: LD_VAR 0 6
86362: PUSH
86363: LD_INT 5
86365: ARRAY
86366: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86367: LD_ADDR_VAR 0 22
86371: PUSH
86372: LD_VAR 0 6
86376: PUSH
86377: LD_INT 6
86379: ARRAY
86380: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86381: LD_ADDR_VAR 0 23
86385: PUSH
86386: LD_VAR 0 6
86390: PUSH
86391: LD_INT 7
86393: ARRAY
86394: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86395: LD_ADDR_VAR 0 24
86399: PUSH
86400: LD_VAR 0 6
86404: PUSH
86405: LD_INT 8
86407: ARRAY
86408: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86409: LD_ADDR_VAR 0 25
86413: PUSH
86414: LD_VAR 0 6
86418: PUSH
86419: LD_INT 9
86421: ARRAY
86422: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86423: LD_ADDR_VAR 0 26
86427: PUSH
86428: LD_VAR 0 6
86432: PUSH
86433: LD_INT 10
86435: ARRAY
86436: ST_TO_ADDR
// end else
86437: GO 86519
// begin f_ignore_area := false ;
86439: LD_ADDR_VAR 0 17
86443: PUSH
86444: LD_INT 0
86446: ST_TO_ADDR
// f_capture := false ;
86447: LD_ADDR_VAR 0 18
86451: PUSH
86452: LD_INT 0
86454: ST_TO_ADDR
// f_ignore_civ := false ;
86455: LD_ADDR_VAR 0 19
86459: PUSH
86460: LD_INT 0
86462: ST_TO_ADDR
// f_murder := false ;
86463: LD_ADDR_VAR 0 20
86467: PUSH
86468: LD_INT 0
86470: ST_TO_ADDR
// f_mines := false ;
86471: LD_ADDR_VAR 0 21
86475: PUSH
86476: LD_INT 0
86478: ST_TO_ADDR
// f_repair := false ;
86479: LD_ADDR_VAR 0 22
86483: PUSH
86484: LD_INT 0
86486: ST_TO_ADDR
// f_heal := false ;
86487: LD_ADDR_VAR 0 23
86491: PUSH
86492: LD_INT 0
86494: ST_TO_ADDR
// f_spacetime := false ;
86495: LD_ADDR_VAR 0 24
86499: PUSH
86500: LD_INT 0
86502: ST_TO_ADDR
// f_attack_depot := false ;
86503: LD_ADDR_VAR 0 25
86507: PUSH
86508: LD_INT 0
86510: ST_TO_ADDR
// f_crawl := false ;
86511: LD_ADDR_VAR 0 26
86515: PUSH
86516: LD_INT 0
86518: ST_TO_ADDR
// end ; if f_heal then
86519: LD_VAR 0 23
86523: IFFALSE 86550
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86525: LD_ADDR_VAR 0 31
86529: PUSH
86530: LD_VAR 0 4
86534: PPUSH
86535: LD_INT 25
86537: PUSH
86538: LD_INT 4
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PPUSH
86545: CALL_OW 72
86549: ST_TO_ADDR
// if f_repair then
86550: LD_VAR 0 22
86554: IFFALSE 86581
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86556: LD_ADDR_VAR 0 33
86560: PUSH
86561: LD_VAR 0 4
86565: PPUSH
86566: LD_INT 25
86568: PUSH
86569: LD_INT 3
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: PPUSH
86576: CALL_OW 72
86580: ST_TO_ADDR
// units_path := [ ] ;
86581: LD_ADDR_VAR 0 16
86585: PUSH
86586: EMPTY
86587: ST_TO_ADDR
// for i = 1 to group do
86588: LD_ADDR_VAR 0 7
86592: PUSH
86593: DOUBLE
86594: LD_INT 1
86596: DEC
86597: ST_TO_ADDR
86598: LD_VAR 0 4
86602: PUSH
86603: FOR_TO
86604: IFFALSE 86633
// units_path := Replace ( units_path , i , path ) ;
86606: LD_ADDR_VAR 0 16
86610: PUSH
86611: LD_VAR 0 16
86615: PPUSH
86616: LD_VAR 0 7
86620: PPUSH
86621: LD_VAR 0 5
86625: PPUSH
86626: CALL_OW 1
86630: ST_TO_ADDR
86631: GO 86603
86633: POP
86634: POP
// repeat for i = group downto 1 do
86635: LD_ADDR_VAR 0 7
86639: PUSH
86640: DOUBLE
86641: LD_VAR 0 4
86645: INC
86646: ST_TO_ADDR
86647: LD_INT 1
86649: PUSH
86650: FOR_DOWNTO
86651: IFFALSE 90747
// begin wait ( 5 ) ;
86653: LD_INT 5
86655: PPUSH
86656: CALL_OW 67
// tmp := [ ] ;
86660: LD_ADDR_VAR 0 14
86664: PUSH
86665: EMPTY
86666: ST_TO_ADDR
// attacking := false ;
86667: LD_ADDR_VAR 0 29
86671: PUSH
86672: LD_INT 0
86674: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86675: LD_VAR 0 4
86679: PUSH
86680: LD_VAR 0 7
86684: ARRAY
86685: PPUSH
86686: CALL_OW 301
86690: PUSH
86691: LD_VAR 0 4
86695: PUSH
86696: LD_VAR 0 7
86700: ARRAY
86701: NOT
86702: OR
86703: IFFALSE 86812
// begin if GetType ( group [ i ] ) = unit_human then
86705: LD_VAR 0 4
86709: PUSH
86710: LD_VAR 0 7
86714: ARRAY
86715: PPUSH
86716: CALL_OW 247
86720: PUSH
86721: LD_INT 1
86723: EQUAL
86724: IFFALSE 86770
// begin to_heal := to_heal diff group [ i ] ;
86726: LD_ADDR_VAR 0 30
86730: PUSH
86731: LD_VAR 0 30
86735: PUSH
86736: LD_VAR 0 4
86740: PUSH
86741: LD_VAR 0 7
86745: ARRAY
86746: DIFF
86747: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86748: LD_ADDR_VAR 0 31
86752: PUSH
86753: LD_VAR 0 31
86757: PUSH
86758: LD_VAR 0 4
86762: PUSH
86763: LD_VAR 0 7
86767: ARRAY
86768: DIFF
86769: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86770: LD_ADDR_VAR 0 4
86774: PUSH
86775: LD_VAR 0 4
86779: PPUSH
86780: LD_VAR 0 7
86784: PPUSH
86785: CALL_OW 3
86789: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86790: LD_ADDR_VAR 0 16
86794: PUSH
86795: LD_VAR 0 16
86799: PPUSH
86800: LD_VAR 0 7
86804: PPUSH
86805: CALL_OW 3
86809: ST_TO_ADDR
// continue ;
86810: GO 86650
// end ; if f_repair then
86812: LD_VAR 0 22
86816: IFFALSE 87305
// begin if GetType ( group [ i ] ) = unit_vehicle then
86818: LD_VAR 0 4
86822: PUSH
86823: LD_VAR 0 7
86827: ARRAY
86828: PPUSH
86829: CALL_OW 247
86833: PUSH
86834: LD_INT 2
86836: EQUAL
86837: IFFALSE 87027
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86839: LD_VAR 0 4
86843: PUSH
86844: LD_VAR 0 7
86848: ARRAY
86849: PPUSH
86850: CALL_OW 256
86854: PUSH
86855: LD_INT 700
86857: LESS
86858: PUSH
86859: LD_VAR 0 4
86863: PUSH
86864: LD_VAR 0 7
86868: ARRAY
86869: PUSH
86870: LD_VAR 0 32
86874: IN
86875: NOT
86876: AND
86877: IFFALSE 86901
// to_repair := to_repair union group [ i ] ;
86879: LD_ADDR_VAR 0 32
86883: PUSH
86884: LD_VAR 0 32
86888: PUSH
86889: LD_VAR 0 4
86893: PUSH
86894: LD_VAR 0 7
86898: ARRAY
86899: UNION
86900: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86901: LD_VAR 0 4
86905: PUSH
86906: LD_VAR 0 7
86910: ARRAY
86911: PPUSH
86912: CALL_OW 256
86916: PUSH
86917: LD_INT 1000
86919: EQUAL
86920: PUSH
86921: LD_VAR 0 4
86925: PUSH
86926: LD_VAR 0 7
86930: ARRAY
86931: PUSH
86932: LD_VAR 0 32
86936: IN
86937: AND
86938: IFFALSE 86962
// to_repair := to_repair diff group [ i ] ;
86940: LD_ADDR_VAR 0 32
86944: PUSH
86945: LD_VAR 0 32
86949: PUSH
86950: LD_VAR 0 4
86954: PUSH
86955: LD_VAR 0 7
86959: ARRAY
86960: DIFF
86961: ST_TO_ADDR
// if group [ i ] in to_repair then
86962: LD_VAR 0 4
86966: PUSH
86967: LD_VAR 0 7
86971: ARRAY
86972: PUSH
86973: LD_VAR 0 32
86977: IN
86978: IFFALSE 87025
// begin if not IsInArea ( group [ i ] , f_repair ) then
86980: LD_VAR 0 4
86984: PUSH
86985: LD_VAR 0 7
86989: ARRAY
86990: PPUSH
86991: LD_VAR 0 22
86995: PPUSH
86996: CALL_OW 308
87000: NOT
87001: IFFALSE 87023
// ComMoveToArea ( group [ i ] , f_repair ) ;
87003: LD_VAR 0 4
87007: PUSH
87008: LD_VAR 0 7
87012: ARRAY
87013: PPUSH
87014: LD_VAR 0 22
87018: PPUSH
87019: CALL_OW 113
// continue ;
87023: GO 86650
// end ; end else
87025: GO 87305
// if group [ i ] in repairs then
87027: LD_VAR 0 4
87031: PUSH
87032: LD_VAR 0 7
87036: ARRAY
87037: PUSH
87038: LD_VAR 0 33
87042: IN
87043: IFFALSE 87305
// begin if IsInUnit ( group [ i ] ) then
87045: LD_VAR 0 4
87049: PUSH
87050: LD_VAR 0 7
87054: ARRAY
87055: PPUSH
87056: CALL_OW 310
87060: IFFALSE 87128
// begin z := IsInUnit ( group [ i ] ) ;
87062: LD_ADDR_VAR 0 13
87066: PUSH
87067: LD_VAR 0 4
87071: PUSH
87072: LD_VAR 0 7
87076: ARRAY
87077: PPUSH
87078: CALL_OW 310
87082: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
87083: LD_VAR 0 13
87087: PUSH
87088: LD_VAR 0 32
87092: IN
87093: PUSH
87094: LD_VAR 0 13
87098: PPUSH
87099: LD_VAR 0 22
87103: PPUSH
87104: CALL_OW 308
87108: AND
87109: IFFALSE 87126
// ComExitVehicle ( group [ i ] ) ;
87111: LD_VAR 0 4
87115: PUSH
87116: LD_VAR 0 7
87120: ARRAY
87121: PPUSH
87122: CALL_OW 121
// end else
87126: GO 87305
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
87128: LD_ADDR_VAR 0 13
87132: PUSH
87133: LD_VAR 0 4
87137: PPUSH
87138: LD_INT 95
87140: PUSH
87141: LD_VAR 0 22
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 58
87152: PUSH
87153: EMPTY
87154: LIST
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PPUSH
87160: CALL_OW 72
87164: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
87165: LD_VAR 0 4
87169: PUSH
87170: LD_VAR 0 7
87174: ARRAY
87175: PPUSH
87176: CALL_OW 314
87180: NOT
87181: IFFALSE 87303
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
87183: LD_ADDR_VAR 0 10
87187: PUSH
87188: LD_VAR 0 13
87192: PPUSH
87193: LD_VAR 0 4
87197: PUSH
87198: LD_VAR 0 7
87202: ARRAY
87203: PPUSH
87204: CALL_OW 74
87208: ST_TO_ADDR
// if not x then
87209: LD_VAR 0 10
87213: NOT
87214: IFFALSE 87218
// continue ;
87216: GO 86650
// if GetLives ( x ) < 1000 then
87218: LD_VAR 0 10
87222: PPUSH
87223: CALL_OW 256
87227: PUSH
87228: LD_INT 1000
87230: LESS
87231: IFFALSE 87255
// ComRepairVehicle ( group [ i ] , x ) else
87233: LD_VAR 0 4
87237: PUSH
87238: LD_VAR 0 7
87242: ARRAY
87243: PPUSH
87244: LD_VAR 0 10
87248: PPUSH
87249: CALL_OW 129
87253: GO 87303
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87255: LD_VAR 0 23
87259: PUSH
87260: LD_VAR 0 4
87264: PUSH
87265: LD_VAR 0 7
87269: ARRAY
87270: PPUSH
87271: CALL_OW 256
87275: PUSH
87276: LD_INT 1000
87278: LESS
87279: AND
87280: NOT
87281: IFFALSE 87303
// ComEnterUnit ( group [ i ] , x ) ;
87283: LD_VAR 0 4
87287: PUSH
87288: LD_VAR 0 7
87292: ARRAY
87293: PPUSH
87294: LD_VAR 0 10
87298: PPUSH
87299: CALL_OW 120
// end ; continue ;
87303: GO 86650
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87305: LD_VAR 0 23
87309: PUSH
87310: LD_VAR 0 4
87314: PUSH
87315: LD_VAR 0 7
87319: ARRAY
87320: PPUSH
87321: CALL_OW 247
87325: PUSH
87326: LD_INT 1
87328: EQUAL
87329: AND
87330: IFFALSE 87808
// begin if group [ i ] in healers then
87332: LD_VAR 0 4
87336: PUSH
87337: LD_VAR 0 7
87341: ARRAY
87342: PUSH
87343: LD_VAR 0 31
87347: IN
87348: IFFALSE 87621
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87350: LD_VAR 0 4
87354: PUSH
87355: LD_VAR 0 7
87359: ARRAY
87360: PPUSH
87361: LD_VAR 0 23
87365: PPUSH
87366: CALL_OW 308
87370: NOT
87371: PUSH
87372: LD_VAR 0 4
87376: PUSH
87377: LD_VAR 0 7
87381: ARRAY
87382: PPUSH
87383: CALL_OW 314
87387: NOT
87388: AND
87389: IFFALSE 87413
// ComMoveToArea ( group [ i ] , f_heal ) else
87391: LD_VAR 0 4
87395: PUSH
87396: LD_VAR 0 7
87400: ARRAY
87401: PPUSH
87402: LD_VAR 0 23
87406: PPUSH
87407: CALL_OW 113
87411: GO 87619
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87413: LD_VAR 0 4
87417: PUSH
87418: LD_VAR 0 7
87422: ARRAY
87423: PPUSH
87424: CALL 86031 0 1
87428: PPUSH
87429: CALL_OW 256
87433: PUSH
87434: LD_INT 1000
87436: EQUAL
87437: IFFALSE 87456
// ComStop ( group [ i ] ) else
87439: LD_VAR 0 4
87443: PUSH
87444: LD_VAR 0 7
87448: ARRAY
87449: PPUSH
87450: CALL_OW 141
87454: GO 87619
// if not HasTask ( group [ i ] ) and to_heal then
87456: LD_VAR 0 4
87460: PUSH
87461: LD_VAR 0 7
87465: ARRAY
87466: PPUSH
87467: CALL_OW 314
87471: NOT
87472: PUSH
87473: LD_VAR 0 30
87477: AND
87478: IFFALSE 87619
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87480: LD_ADDR_VAR 0 13
87484: PUSH
87485: LD_VAR 0 30
87489: PPUSH
87490: LD_INT 3
87492: PUSH
87493: LD_INT 54
87495: PUSH
87496: EMPTY
87497: LIST
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PPUSH
87503: CALL_OW 72
87507: PPUSH
87508: LD_VAR 0 4
87512: PUSH
87513: LD_VAR 0 7
87517: ARRAY
87518: PPUSH
87519: CALL_OW 74
87523: ST_TO_ADDR
// if z then
87524: LD_VAR 0 13
87528: IFFALSE 87619
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87530: LD_INT 91
87532: PUSH
87533: LD_VAR 0 13
87537: PUSH
87538: LD_INT 10
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 81
87548: PUSH
87549: LD_VAR 0 13
87553: PPUSH
87554: CALL_OW 255
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PPUSH
87567: CALL_OW 69
87571: PUSH
87572: LD_INT 0
87574: EQUAL
87575: IFFALSE 87599
// ComHeal ( group [ i ] , z ) else
87577: LD_VAR 0 4
87581: PUSH
87582: LD_VAR 0 7
87586: ARRAY
87587: PPUSH
87588: LD_VAR 0 13
87592: PPUSH
87593: CALL_OW 128
87597: GO 87619
// ComMoveToArea ( group [ i ] , f_heal ) ;
87599: LD_VAR 0 4
87603: PUSH
87604: LD_VAR 0 7
87608: ARRAY
87609: PPUSH
87610: LD_VAR 0 23
87614: PPUSH
87615: CALL_OW 113
// end ; continue ;
87619: GO 86650
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87621: LD_VAR 0 4
87625: PUSH
87626: LD_VAR 0 7
87630: ARRAY
87631: PPUSH
87632: CALL_OW 256
87636: PUSH
87637: LD_INT 700
87639: LESS
87640: PUSH
87641: LD_VAR 0 4
87645: PUSH
87646: LD_VAR 0 7
87650: ARRAY
87651: PUSH
87652: LD_VAR 0 30
87656: IN
87657: NOT
87658: AND
87659: IFFALSE 87683
// to_heal := to_heal union group [ i ] ;
87661: LD_ADDR_VAR 0 30
87665: PUSH
87666: LD_VAR 0 30
87670: PUSH
87671: LD_VAR 0 4
87675: PUSH
87676: LD_VAR 0 7
87680: ARRAY
87681: UNION
87682: ST_TO_ADDR
// if group [ i ] in to_heal then
87683: LD_VAR 0 4
87687: PUSH
87688: LD_VAR 0 7
87692: ARRAY
87693: PUSH
87694: LD_VAR 0 30
87698: IN
87699: IFFALSE 87808
// begin if GetLives ( group [ i ] ) = 1000 then
87701: LD_VAR 0 4
87705: PUSH
87706: LD_VAR 0 7
87710: ARRAY
87711: PPUSH
87712: CALL_OW 256
87716: PUSH
87717: LD_INT 1000
87719: EQUAL
87720: IFFALSE 87746
// to_heal := to_heal diff group [ i ] else
87722: LD_ADDR_VAR 0 30
87726: PUSH
87727: LD_VAR 0 30
87731: PUSH
87732: LD_VAR 0 4
87736: PUSH
87737: LD_VAR 0 7
87741: ARRAY
87742: DIFF
87743: ST_TO_ADDR
87744: GO 87808
// begin if not IsInArea ( group [ i ] , to_heal ) then
87746: LD_VAR 0 4
87750: PUSH
87751: LD_VAR 0 7
87755: ARRAY
87756: PPUSH
87757: LD_VAR 0 30
87761: PPUSH
87762: CALL_OW 308
87766: NOT
87767: IFFALSE 87791
// ComMoveToArea ( group [ i ] , f_heal ) else
87769: LD_VAR 0 4
87773: PUSH
87774: LD_VAR 0 7
87778: ARRAY
87779: PPUSH
87780: LD_VAR 0 23
87784: PPUSH
87785: CALL_OW 113
87789: GO 87806
// ComHold ( group [ i ] ) ;
87791: LD_VAR 0 4
87795: PUSH
87796: LD_VAR 0 7
87800: ARRAY
87801: PPUSH
87802: CALL_OW 140
// continue ;
87806: GO 86650
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87808: LD_VAR 0 4
87812: PUSH
87813: LD_VAR 0 7
87817: ARRAY
87818: PPUSH
87819: LD_INT 10
87821: PPUSH
87822: CALL 84428 0 2
87826: NOT
87827: PUSH
87828: LD_VAR 0 16
87832: PUSH
87833: LD_VAR 0 7
87837: ARRAY
87838: PUSH
87839: EMPTY
87840: EQUAL
87841: NOT
87842: AND
87843: IFFALSE 88109
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87845: LD_VAR 0 4
87849: PUSH
87850: LD_VAR 0 7
87854: ARRAY
87855: PPUSH
87856: CALL_OW 262
87860: PUSH
87861: LD_INT 1
87863: PUSH
87864: LD_INT 2
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: IN
87871: IFFALSE 87912
// if GetFuel ( group [ i ] ) < 10 then
87873: LD_VAR 0 4
87877: PUSH
87878: LD_VAR 0 7
87882: ARRAY
87883: PPUSH
87884: CALL_OW 261
87888: PUSH
87889: LD_INT 10
87891: LESS
87892: IFFALSE 87912
// SetFuel ( group [ i ] , 12 ) ;
87894: LD_VAR 0 4
87898: PUSH
87899: LD_VAR 0 7
87903: ARRAY
87904: PPUSH
87905: LD_INT 12
87907: PPUSH
87908: CALL_OW 240
// if units_path [ i ] then
87912: LD_VAR 0 16
87916: PUSH
87917: LD_VAR 0 7
87921: ARRAY
87922: IFFALSE 88107
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87924: LD_VAR 0 4
87928: PUSH
87929: LD_VAR 0 7
87933: ARRAY
87934: PPUSH
87935: LD_VAR 0 16
87939: PUSH
87940: LD_VAR 0 7
87944: ARRAY
87945: PUSH
87946: LD_INT 1
87948: ARRAY
87949: PUSH
87950: LD_INT 1
87952: ARRAY
87953: PPUSH
87954: LD_VAR 0 16
87958: PUSH
87959: LD_VAR 0 7
87963: ARRAY
87964: PUSH
87965: LD_INT 1
87967: ARRAY
87968: PUSH
87969: LD_INT 2
87971: ARRAY
87972: PPUSH
87973: CALL_OW 297
87977: PUSH
87978: LD_INT 6
87980: GREATER
87981: IFFALSE 88056
// begin if not HasTask ( group [ i ] ) then
87983: LD_VAR 0 4
87987: PUSH
87988: LD_VAR 0 7
87992: ARRAY
87993: PPUSH
87994: CALL_OW 314
87998: NOT
87999: IFFALSE 88054
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
88001: LD_VAR 0 4
88005: PUSH
88006: LD_VAR 0 7
88010: ARRAY
88011: PPUSH
88012: LD_VAR 0 16
88016: PUSH
88017: LD_VAR 0 7
88021: ARRAY
88022: PUSH
88023: LD_INT 1
88025: ARRAY
88026: PUSH
88027: LD_INT 1
88029: ARRAY
88030: PPUSH
88031: LD_VAR 0 16
88035: PUSH
88036: LD_VAR 0 7
88040: ARRAY
88041: PUSH
88042: LD_INT 1
88044: ARRAY
88045: PUSH
88046: LD_INT 2
88048: ARRAY
88049: PPUSH
88050: CALL_OW 114
// end else
88054: GO 88107
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
88056: LD_ADDR_VAR 0 15
88060: PUSH
88061: LD_VAR 0 16
88065: PUSH
88066: LD_VAR 0 7
88070: ARRAY
88071: PPUSH
88072: LD_INT 1
88074: PPUSH
88075: CALL_OW 3
88079: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
88080: LD_ADDR_VAR 0 16
88084: PUSH
88085: LD_VAR 0 16
88089: PPUSH
88090: LD_VAR 0 7
88094: PPUSH
88095: LD_VAR 0 15
88099: PPUSH
88100: CALL_OW 1
88104: ST_TO_ADDR
// continue ;
88105: GO 86650
// end ; end ; end else
88107: GO 90745
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
88109: LD_ADDR_VAR 0 14
88113: PUSH
88114: LD_INT 81
88116: PUSH
88117: LD_VAR 0 4
88121: PUSH
88122: LD_VAR 0 7
88126: ARRAY
88127: PPUSH
88128: CALL_OW 255
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PPUSH
88137: CALL_OW 69
88141: ST_TO_ADDR
// if not tmp then
88142: LD_VAR 0 14
88146: NOT
88147: IFFALSE 88151
// continue ;
88149: GO 86650
// if f_ignore_area then
88151: LD_VAR 0 17
88155: IFFALSE 88243
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
88157: LD_ADDR_VAR 0 15
88161: PUSH
88162: LD_VAR 0 14
88166: PPUSH
88167: LD_INT 3
88169: PUSH
88170: LD_INT 92
88172: PUSH
88173: LD_VAR 0 17
88177: PUSH
88178: LD_INT 1
88180: ARRAY
88181: PUSH
88182: LD_VAR 0 17
88186: PUSH
88187: LD_INT 2
88189: ARRAY
88190: PUSH
88191: LD_VAR 0 17
88195: PUSH
88196: LD_INT 3
88198: ARRAY
88199: PUSH
88200: EMPTY
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PPUSH
88210: CALL_OW 72
88214: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88215: LD_VAR 0 14
88219: PUSH
88220: LD_VAR 0 15
88224: DIFF
88225: IFFALSE 88243
// tmp := tmp diff tmp2 ;
88227: LD_ADDR_VAR 0 14
88231: PUSH
88232: LD_VAR 0 14
88236: PUSH
88237: LD_VAR 0 15
88241: DIFF
88242: ST_TO_ADDR
// end ; if not f_murder then
88243: LD_VAR 0 20
88247: NOT
88248: IFFALSE 88306
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88250: LD_ADDR_VAR 0 15
88254: PUSH
88255: LD_VAR 0 14
88259: PPUSH
88260: LD_INT 3
88262: PUSH
88263: LD_INT 50
88265: PUSH
88266: EMPTY
88267: LIST
88268: PUSH
88269: EMPTY
88270: LIST
88271: LIST
88272: PPUSH
88273: CALL_OW 72
88277: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88278: LD_VAR 0 14
88282: PUSH
88283: LD_VAR 0 15
88287: DIFF
88288: IFFALSE 88306
// tmp := tmp diff tmp2 ;
88290: LD_ADDR_VAR 0 14
88294: PUSH
88295: LD_VAR 0 14
88299: PUSH
88300: LD_VAR 0 15
88304: DIFF
88305: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88306: LD_ADDR_VAR 0 14
88310: PUSH
88311: LD_VAR 0 4
88315: PUSH
88316: LD_VAR 0 7
88320: ARRAY
88321: PPUSH
88322: LD_VAR 0 14
88326: PPUSH
88327: LD_INT 1
88329: PPUSH
88330: LD_INT 1
88332: PPUSH
88333: CALL 58071 0 4
88337: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88338: LD_VAR 0 4
88342: PUSH
88343: LD_VAR 0 7
88347: ARRAY
88348: PPUSH
88349: CALL_OW 257
88353: PUSH
88354: LD_INT 1
88356: EQUAL
88357: IFFALSE 88805
// begin if WantPlant ( group [ i ] ) then
88359: LD_VAR 0 4
88363: PUSH
88364: LD_VAR 0 7
88368: ARRAY
88369: PPUSH
88370: CALL 57572 0 1
88374: IFFALSE 88378
// continue ;
88376: GO 86650
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88378: LD_VAR 0 18
88382: PUSH
88383: LD_VAR 0 4
88387: PUSH
88388: LD_VAR 0 7
88392: ARRAY
88393: PPUSH
88394: CALL_OW 310
88398: NOT
88399: AND
88400: PUSH
88401: LD_VAR 0 14
88405: PUSH
88406: LD_INT 1
88408: ARRAY
88409: PUSH
88410: LD_VAR 0 14
88414: PPUSH
88415: LD_INT 21
88417: PUSH
88418: LD_INT 2
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 58
88427: PUSH
88428: EMPTY
88429: LIST
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PPUSH
88435: CALL_OW 72
88439: IN
88440: AND
88441: IFFALSE 88477
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88443: LD_VAR 0 4
88447: PUSH
88448: LD_VAR 0 7
88452: ARRAY
88453: PPUSH
88454: LD_VAR 0 14
88458: PUSH
88459: LD_INT 1
88461: ARRAY
88462: PPUSH
88463: CALL_OW 120
// attacking := true ;
88467: LD_ADDR_VAR 0 29
88471: PUSH
88472: LD_INT 1
88474: ST_TO_ADDR
// continue ;
88475: GO 86650
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88477: LD_VAR 0 26
88481: PUSH
88482: LD_VAR 0 4
88486: PUSH
88487: LD_VAR 0 7
88491: ARRAY
88492: PPUSH
88493: CALL_OW 257
88497: PUSH
88498: LD_INT 1
88500: EQUAL
88501: AND
88502: PUSH
88503: LD_VAR 0 4
88507: PUSH
88508: LD_VAR 0 7
88512: ARRAY
88513: PPUSH
88514: CALL_OW 256
88518: PUSH
88519: LD_INT 800
88521: LESS
88522: AND
88523: PUSH
88524: LD_VAR 0 4
88528: PUSH
88529: LD_VAR 0 7
88533: ARRAY
88534: PPUSH
88535: CALL_OW 318
88539: NOT
88540: AND
88541: IFFALSE 88558
// ComCrawl ( group [ i ] ) ;
88543: LD_VAR 0 4
88547: PUSH
88548: LD_VAR 0 7
88552: ARRAY
88553: PPUSH
88554: CALL_OW 137
// if f_mines then
88558: LD_VAR 0 21
88562: IFFALSE 88805
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88564: LD_VAR 0 14
88568: PUSH
88569: LD_INT 1
88571: ARRAY
88572: PPUSH
88573: CALL_OW 247
88577: PUSH
88578: LD_INT 3
88580: EQUAL
88581: PUSH
88582: LD_VAR 0 14
88586: PUSH
88587: LD_INT 1
88589: ARRAY
88590: PUSH
88591: LD_VAR 0 27
88595: IN
88596: NOT
88597: AND
88598: IFFALSE 88805
// begin x := GetX ( tmp [ 1 ] ) ;
88600: LD_ADDR_VAR 0 10
88604: PUSH
88605: LD_VAR 0 14
88609: PUSH
88610: LD_INT 1
88612: ARRAY
88613: PPUSH
88614: CALL_OW 250
88618: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88619: LD_ADDR_VAR 0 11
88623: PUSH
88624: LD_VAR 0 14
88628: PUSH
88629: LD_INT 1
88631: ARRAY
88632: PPUSH
88633: CALL_OW 251
88637: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88638: LD_ADDR_VAR 0 12
88642: PUSH
88643: LD_VAR 0 4
88647: PUSH
88648: LD_VAR 0 7
88652: ARRAY
88653: PPUSH
88654: CALL 84513 0 1
88658: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88659: LD_VAR 0 4
88663: PUSH
88664: LD_VAR 0 7
88668: ARRAY
88669: PPUSH
88670: LD_VAR 0 10
88674: PPUSH
88675: LD_VAR 0 11
88679: PPUSH
88680: LD_VAR 0 14
88684: PUSH
88685: LD_INT 1
88687: ARRAY
88688: PPUSH
88689: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88693: LD_VAR 0 4
88697: PUSH
88698: LD_VAR 0 7
88702: ARRAY
88703: PPUSH
88704: LD_VAR 0 10
88708: PPUSH
88709: LD_VAR 0 12
88713: PPUSH
88714: LD_INT 7
88716: PPUSH
88717: CALL_OW 272
88721: PPUSH
88722: LD_VAR 0 11
88726: PPUSH
88727: LD_VAR 0 12
88731: PPUSH
88732: LD_INT 7
88734: PPUSH
88735: CALL_OW 273
88739: PPUSH
88740: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88744: LD_VAR 0 4
88748: PUSH
88749: LD_VAR 0 7
88753: ARRAY
88754: PPUSH
88755: LD_INT 71
88757: PPUSH
88758: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88762: LD_ADDR_VAR 0 27
88766: PUSH
88767: LD_VAR 0 27
88771: PPUSH
88772: LD_VAR 0 27
88776: PUSH
88777: LD_INT 1
88779: PLUS
88780: PPUSH
88781: LD_VAR 0 14
88785: PUSH
88786: LD_INT 1
88788: ARRAY
88789: PPUSH
88790: CALL_OW 1
88794: ST_TO_ADDR
// attacking := true ;
88795: LD_ADDR_VAR 0 29
88799: PUSH
88800: LD_INT 1
88802: ST_TO_ADDR
// continue ;
88803: GO 86650
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88805: LD_VAR 0 4
88809: PUSH
88810: LD_VAR 0 7
88814: ARRAY
88815: PPUSH
88816: CALL_OW 257
88820: PUSH
88821: LD_INT 17
88823: EQUAL
88824: PUSH
88825: LD_VAR 0 4
88829: PUSH
88830: LD_VAR 0 7
88834: ARRAY
88835: PPUSH
88836: CALL_OW 110
88840: PUSH
88841: LD_INT 71
88843: EQUAL
88844: NOT
88845: AND
88846: IFFALSE 88992
// begin attacking := false ;
88848: LD_ADDR_VAR 0 29
88852: PUSH
88853: LD_INT 0
88855: ST_TO_ADDR
// k := 5 ;
88856: LD_ADDR_VAR 0 9
88860: PUSH
88861: LD_INT 5
88863: ST_TO_ADDR
// if tmp < k then
88864: LD_VAR 0 14
88868: PUSH
88869: LD_VAR 0 9
88873: LESS
88874: IFFALSE 88886
// k := tmp ;
88876: LD_ADDR_VAR 0 9
88880: PUSH
88881: LD_VAR 0 14
88885: ST_TO_ADDR
// for j = 1 to k do
88886: LD_ADDR_VAR 0 8
88890: PUSH
88891: DOUBLE
88892: LD_INT 1
88894: DEC
88895: ST_TO_ADDR
88896: LD_VAR 0 9
88900: PUSH
88901: FOR_TO
88902: IFFALSE 88990
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88904: LD_VAR 0 14
88908: PUSH
88909: LD_VAR 0 8
88913: ARRAY
88914: PUSH
88915: LD_VAR 0 14
88919: PPUSH
88920: LD_INT 58
88922: PUSH
88923: EMPTY
88924: LIST
88925: PPUSH
88926: CALL_OW 72
88930: IN
88931: NOT
88932: IFFALSE 88988
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88934: LD_VAR 0 4
88938: PUSH
88939: LD_VAR 0 7
88943: ARRAY
88944: PPUSH
88945: LD_VAR 0 14
88949: PUSH
88950: LD_VAR 0 8
88954: ARRAY
88955: PPUSH
88956: CALL_OW 115
// attacking := true ;
88960: LD_ADDR_VAR 0 29
88964: PUSH
88965: LD_INT 1
88967: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88968: LD_VAR 0 4
88972: PUSH
88973: LD_VAR 0 7
88977: ARRAY
88978: PPUSH
88979: LD_INT 71
88981: PPUSH
88982: CALL_OW 109
// continue ;
88986: GO 88901
// end ; end ;
88988: GO 88901
88990: POP
88991: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88992: LD_VAR 0 4
88996: PUSH
88997: LD_VAR 0 7
89001: ARRAY
89002: PPUSH
89003: CALL_OW 257
89007: PUSH
89008: LD_INT 8
89010: EQUAL
89011: PUSH
89012: LD_VAR 0 4
89016: PUSH
89017: LD_VAR 0 7
89021: ARRAY
89022: PPUSH
89023: CALL_OW 264
89027: PUSH
89028: LD_INT 28
89030: PUSH
89031: LD_INT 45
89033: PUSH
89034: LD_INT 7
89036: PUSH
89037: LD_INT 47
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: LIST
89044: LIST
89045: IN
89046: OR
89047: IFFALSE 89277
// begin attacking := false ;
89049: LD_ADDR_VAR 0 29
89053: PUSH
89054: LD_INT 0
89056: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
89057: LD_VAR 0 14
89061: PUSH
89062: LD_INT 1
89064: ARRAY
89065: PPUSH
89066: CALL_OW 266
89070: PUSH
89071: LD_INT 32
89073: PUSH
89074: LD_INT 31
89076: PUSH
89077: LD_INT 33
89079: PUSH
89080: LD_INT 4
89082: PUSH
89083: LD_INT 5
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: IN
89093: IFFALSE 89277
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
89095: LD_ADDR_VAR 0 9
89099: PUSH
89100: LD_VAR 0 14
89104: PUSH
89105: LD_INT 1
89107: ARRAY
89108: PPUSH
89109: CALL_OW 266
89113: PPUSH
89114: LD_VAR 0 14
89118: PUSH
89119: LD_INT 1
89121: ARRAY
89122: PPUSH
89123: CALL_OW 250
89127: PPUSH
89128: LD_VAR 0 14
89132: PUSH
89133: LD_INT 1
89135: ARRAY
89136: PPUSH
89137: CALL_OW 251
89141: PPUSH
89142: LD_VAR 0 14
89146: PUSH
89147: LD_INT 1
89149: ARRAY
89150: PPUSH
89151: CALL_OW 254
89155: PPUSH
89156: LD_VAR 0 14
89160: PUSH
89161: LD_INT 1
89163: ARRAY
89164: PPUSH
89165: CALL_OW 248
89169: PPUSH
89170: LD_INT 0
89172: PPUSH
89173: CALL 65883 0 6
89177: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
89178: LD_ADDR_VAR 0 8
89182: PUSH
89183: LD_VAR 0 4
89187: PUSH
89188: LD_VAR 0 7
89192: ARRAY
89193: PPUSH
89194: LD_VAR 0 9
89198: PPUSH
89199: CALL 84576 0 2
89203: ST_TO_ADDR
// if j then
89204: LD_VAR 0 8
89208: IFFALSE 89277
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
89210: LD_VAR 0 8
89214: PUSH
89215: LD_INT 1
89217: ARRAY
89218: PPUSH
89219: LD_VAR 0 8
89223: PUSH
89224: LD_INT 2
89226: ARRAY
89227: PPUSH
89228: CALL_OW 488
89232: IFFALSE 89277
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89234: LD_VAR 0 4
89238: PUSH
89239: LD_VAR 0 7
89243: ARRAY
89244: PPUSH
89245: LD_VAR 0 8
89249: PUSH
89250: LD_INT 1
89252: ARRAY
89253: PPUSH
89254: LD_VAR 0 8
89258: PUSH
89259: LD_INT 2
89261: ARRAY
89262: PPUSH
89263: CALL_OW 116
// attacking := true ;
89267: LD_ADDR_VAR 0 29
89271: PUSH
89272: LD_INT 1
89274: ST_TO_ADDR
// continue ;
89275: GO 86650
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89277: LD_VAR 0 4
89281: PUSH
89282: LD_VAR 0 7
89286: ARRAY
89287: PPUSH
89288: CALL_OW 265
89292: PUSH
89293: LD_INT 11
89295: EQUAL
89296: IFFALSE 89574
// begin k := 10 ;
89298: LD_ADDR_VAR 0 9
89302: PUSH
89303: LD_INT 10
89305: ST_TO_ADDR
// x := 0 ;
89306: LD_ADDR_VAR 0 10
89310: PUSH
89311: LD_INT 0
89313: ST_TO_ADDR
// if tmp < k then
89314: LD_VAR 0 14
89318: PUSH
89319: LD_VAR 0 9
89323: LESS
89324: IFFALSE 89336
// k := tmp ;
89326: LD_ADDR_VAR 0 9
89330: PUSH
89331: LD_VAR 0 14
89335: ST_TO_ADDR
// for j = k downto 1 do
89336: LD_ADDR_VAR 0 8
89340: PUSH
89341: DOUBLE
89342: LD_VAR 0 9
89346: INC
89347: ST_TO_ADDR
89348: LD_INT 1
89350: PUSH
89351: FOR_DOWNTO
89352: IFFALSE 89427
// begin if GetType ( tmp [ j ] ) = unit_human then
89354: LD_VAR 0 14
89358: PUSH
89359: LD_VAR 0 8
89363: ARRAY
89364: PPUSH
89365: CALL_OW 247
89369: PUSH
89370: LD_INT 1
89372: EQUAL
89373: IFFALSE 89425
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89375: LD_VAR 0 4
89379: PUSH
89380: LD_VAR 0 7
89384: ARRAY
89385: PPUSH
89386: LD_VAR 0 14
89390: PUSH
89391: LD_VAR 0 8
89395: ARRAY
89396: PPUSH
89397: CALL 84847 0 2
// x := tmp [ j ] ;
89401: LD_ADDR_VAR 0 10
89405: PUSH
89406: LD_VAR 0 14
89410: PUSH
89411: LD_VAR 0 8
89415: ARRAY
89416: ST_TO_ADDR
// attacking := true ;
89417: LD_ADDR_VAR 0 29
89421: PUSH
89422: LD_INT 1
89424: ST_TO_ADDR
// end ; end ;
89425: GO 89351
89427: POP
89428: POP
// if not x then
89429: LD_VAR 0 10
89433: NOT
89434: IFFALSE 89574
// begin attacking := true ;
89436: LD_ADDR_VAR 0 29
89440: PUSH
89441: LD_INT 1
89443: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89444: LD_VAR 0 4
89448: PUSH
89449: LD_VAR 0 7
89453: ARRAY
89454: PPUSH
89455: CALL_OW 250
89459: PPUSH
89460: LD_VAR 0 4
89464: PUSH
89465: LD_VAR 0 7
89469: ARRAY
89470: PPUSH
89471: CALL_OW 251
89475: PPUSH
89476: CALL_OW 546
89480: PUSH
89481: LD_INT 2
89483: ARRAY
89484: PUSH
89485: LD_VAR 0 14
89489: PUSH
89490: LD_INT 1
89492: ARRAY
89493: PPUSH
89494: CALL_OW 250
89498: PPUSH
89499: LD_VAR 0 14
89503: PUSH
89504: LD_INT 1
89506: ARRAY
89507: PPUSH
89508: CALL_OW 251
89512: PPUSH
89513: CALL_OW 546
89517: PUSH
89518: LD_INT 2
89520: ARRAY
89521: EQUAL
89522: IFFALSE 89550
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89524: LD_VAR 0 4
89528: PUSH
89529: LD_VAR 0 7
89533: ARRAY
89534: PPUSH
89535: LD_VAR 0 14
89539: PUSH
89540: LD_INT 1
89542: ARRAY
89543: PPUSH
89544: CALL 84847 0 2
89548: GO 89574
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89550: LD_VAR 0 4
89554: PUSH
89555: LD_VAR 0 7
89559: ARRAY
89560: PPUSH
89561: LD_VAR 0 14
89565: PUSH
89566: LD_INT 1
89568: ARRAY
89569: PPUSH
89570: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89574: LD_VAR 0 4
89578: PUSH
89579: LD_VAR 0 7
89583: ARRAY
89584: PPUSH
89585: CALL_OW 264
89589: PUSH
89590: LD_INT 29
89592: EQUAL
89593: IFFALSE 89959
// begin if WantsToAttack ( group [ i ] ) in bombed then
89595: LD_VAR 0 4
89599: PUSH
89600: LD_VAR 0 7
89604: ARRAY
89605: PPUSH
89606: CALL_OW 319
89610: PUSH
89611: LD_VAR 0 28
89615: IN
89616: IFFALSE 89620
// continue ;
89618: GO 86650
// k := 8 ;
89620: LD_ADDR_VAR 0 9
89624: PUSH
89625: LD_INT 8
89627: ST_TO_ADDR
// x := 0 ;
89628: LD_ADDR_VAR 0 10
89632: PUSH
89633: LD_INT 0
89635: ST_TO_ADDR
// if tmp < k then
89636: LD_VAR 0 14
89640: PUSH
89641: LD_VAR 0 9
89645: LESS
89646: IFFALSE 89658
// k := tmp ;
89648: LD_ADDR_VAR 0 9
89652: PUSH
89653: LD_VAR 0 14
89657: ST_TO_ADDR
// for j = 1 to k do
89658: LD_ADDR_VAR 0 8
89662: PUSH
89663: DOUBLE
89664: LD_INT 1
89666: DEC
89667: ST_TO_ADDR
89668: LD_VAR 0 9
89672: PUSH
89673: FOR_TO
89674: IFFALSE 89806
// begin if GetType ( tmp [ j ] ) = unit_building then
89676: LD_VAR 0 14
89680: PUSH
89681: LD_VAR 0 8
89685: ARRAY
89686: PPUSH
89687: CALL_OW 247
89691: PUSH
89692: LD_INT 3
89694: EQUAL
89695: IFFALSE 89804
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89697: LD_VAR 0 14
89701: PUSH
89702: LD_VAR 0 8
89706: ARRAY
89707: PUSH
89708: LD_VAR 0 28
89712: IN
89713: NOT
89714: PUSH
89715: LD_VAR 0 14
89719: PUSH
89720: LD_VAR 0 8
89724: ARRAY
89725: PPUSH
89726: CALL_OW 313
89730: AND
89731: IFFALSE 89804
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89733: LD_VAR 0 4
89737: PUSH
89738: LD_VAR 0 7
89742: ARRAY
89743: PPUSH
89744: LD_VAR 0 14
89748: PUSH
89749: LD_VAR 0 8
89753: ARRAY
89754: PPUSH
89755: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89759: LD_ADDR_VAR 0 28
89763: PUSH
89764: LD_VAR 0 28
89768: PPUSH
89769: LD_VAR 0 28
89773: PUSH
89774: LD_INT 1
89776: PLUS
89777: PPUSH
89778: LD_VAR 0 14
89782: PUSH
89783: LD_VAR 0 8
89787: ARRAY
89788: PPUSH
89789: CALL_OW 1
89793: ST_TO_ADDR
// attacking := true ;
89794: LD_ADDR_VAR 0 29
89798: PUSH
89799: LD_INT 1
89801: ST_TO_ADDR
// break ;
89802: GO 89806
// end ; end ;
89804: GO 89673
89806: POP
89807: POP
// if not attacking and f_attack_depot then
89808: LD_VAR 0 29
89812: NOT
89813: PUSH
89814: LD_VAR 0 25
89818: AND
89819: IFFALSE 89914
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89821: LD_ADDR_VAR 0 13
89825: PUSH
89826: LD_VAR 0 14
89830: PPUSH
89831: LD_INT 2
89833: PUSH
89834: LD_INT 30
89836: PUSH
89837: LD_INT 0
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 30
89846: PUSH
89847: LD_INT 1
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: EMPTY
89855: LIST
89856: LIST
89857: LIST
89858: PPUSH
89859: CALL_OW 72
89863: ST_TO_ADDR
// if z then
89864: LD_VAR 0 13
89868: IFFALSE 89914
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89870: LD_VAR 0 4
89874: PUSH
89875: LD_VAR 0 7
89879: ARRAY
89880: PPUSH
89881: LD_VAR 0 13
89885: PPUSH
89886: LD_VAR 0 4
89890: PUSH
89891: LD_VAR 0 7
89895: ARRAY
89896: PPUSH
89897: CALL_OW 74
89901: PPUSH
89902: CALL_OW 115
// attacking := true ;
89906: LD_ADDR_VAR 0 29
89910: PUSH
89911: LD_INT 1
89913: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89914: LD_VAR 0 4
89918: PUSH
89919: LD_VAR 0 7
89923: ARRAY
89924: PPUSH
89925: CALL_OW 256
89929: PUSH
89930: LD_INT 500
89932: LESS
89933: IFFALSE 89959
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89935: LD_VAR 0 4
89939: PUSH
89940: LD_VAR 0 7
89944: ARRAY
89945: PPUSH
89946: LD_VAR 0 14
89950: PUSH
89951: LD_INT 1
89953: ARRAY
89954: PPUSH
89955: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89959: LD_VAR 0 4
89963: PUSH
89964: LD_VAR 0 7
89968: ARRAY
89969: PPUSH
89970: CALL_OW 264
89974: PUSH
89975: LD_INT 49
89977: EQUAL
89978: IFFALSE 90099
// begin if not HasTask ( group [ i ] ) then
89980: LD_VAR 0 4
89984: PUSH
89985: LD_VAR 0 7
89989: ARRAY
89990: PPUSH
89991: CALL_OW 314
89995: NOT
89996: IFFALSE 90099
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89998: LD_ADDR_VAR 0 9
90002: PUSH
90003: LD_INT 81
90005: PUSH
90006: LD_VAR 0 4
90010: PUSH
90011: LD_VAR 0 7
90015: ARRAY
90016: PPUSH
90017: CALL_OW 255
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PPUSH
90026: CALL_OW 69
90030: PPUSH
90031: LD_VAR 0 4
90035: PUSH
90036: LD_VAR 0 7
90040: ARRAY
90041: PPUSH
90042: CALL_OW 74
90046: ST_TO_ADDR
// if k then
90047: LD_VAR 0 9
90051: IFFALSE 90099
// if GetDistUnits ( group [ i ] , k ) > 10 then
90053: LD_VAR 0 4
90057: PUSH
90058: LD_VAR 0 7
90062: ARRAY
90063: PPUSH
90064: LD_VAR 0 9
90068: PPUSH
90069: CALL_OW 296
90073: PUSH
90074: LD_INT 10
90076: GREATER
90077: IFFALSE 90099
// ComMoveUnit ( group [ i ] , k ) ;
90079: LD_VAR 0 4
90083: PUSH
90084: LD_VAR 0 7
90088: ARRAY
90089: PPUSH
90090: LD_VAR 0 9
90094: PPUSH
90095: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
90099: LD_VAR 0 4
90103: PUSH
90104: LD_VAR 0 7
90108: ARRAY
90109: PPUSH
90110: CALL_OW 256
90114: PUSH
90115: LD_INT 250
90117: LESS
90118: PUSH
90119: LD_VAR 0 4
90123: PUSH
90124: LD_VAR 0 7
90128: ARRAY
90129: PUSH
90130: LD_INT 21
90132: PUSH
90133: LD_INT 2
90135: PUSH
90136: EMPTY
90137: LIST
90138: LIST
90139: PUSH
90140: LD_INT 23
90142: PUSH
90143: LD_INT 2
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PPUSH
90154: CALL_OW 69
90158: IN
90159: AND
90160: IFFALSE 90285
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
90162: LD_ADDR_VAR 0 9
90166: PUSH
90167: LD_OWVAR 3
90171: PUSH
90172: LD_VAR 0 4
90176: PUSH
90177: LD_VAR 0 7
90181: ARRAY
90182: DIFF
90183: PPUSH
90184: LD_VAR 0 4
90188: PUSH
90189: LD_VAR 0 7
90193: ARRAY
90194: PPUSH
90195: CALL_OW 74
90199: ST_TO_ADDR
// if not k then
90200: LD_VAR 0 9
90204: NOT
90205: IFFALSE 90209
// continue ;
90207: GO 86650
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
90209: LD_VAR 0 9
90213: PUSH
90214: LD_INT 81
90216: PUSH
90217: LD_VAR 0 4
90221: PUSH
90222: LD_VAR 0 7
90226: ARRAY
90227: PPUSH
90228: CALL_OW 255
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: PPUSH
90237: CALL_OW 69
90241: IN
90242: PUSH
90243: LD_VAR 0 9
90247: PPUSH
90248: LD_VAR 0 4
90252: PUSH
90253: LD_VAR 0 7
90257: ARRAY
90258: PPUSH
90259: CALL_OW 296
90263: PUSH
90264: LD_INT 5
90266: LESS
90267: AND
90268: IFFALSE 90285
// ComAutodestruct ( group [ i ] ) ;
90270: LD_VAR 0 4
90274: PUSH
90275: LD_VAR 0 7
90279: ARRAY
90280: PPUSH
90281: CALL 84745 0 1
// end ; if f_attack_depot then
90285: LD_VAR 0 25
90289: IFFALSE 90401
// begin k := 6 ;
90291: LD_ADDR_VAR 0 9
90295: PUSH
90296: LD_INT 6
90298: ST_TO_ADDR
// if tmp < k then
90299: LD_VAR 0 14
90303: PUSH
90304: LD_VAR 0 9
90308: LESS
90309: IFFALSE 90321
// k := tmp ;
90311: LD_ADDR_VAR 0 9
90315: PUSH
90316: LD_VAR 0 14
90320: ST_TO_ADDR
// for j = 1 to k do
90321: LD_ADDR_VAR 0 8
90325: PUSH
90326: DOUBLE
90327: LD_INT 1
90329: DEC
90330: ST_TO_ADDR
90331: LD_VAR 0 9
90335: PUSH
90336: FOR_TO
90337: IFFALSE 90399
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90339: LD_VAR 0 8
90343: PPUSH
90344: CALL_OW 266
90348: PUSH
90349: LD_INT 0
90351: PUSH
90352: LD_INT 1
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: IN
90359: IFFALSE 90397
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90361: LD_VAR 0 4
90365: PUSH
90366: LD_VAR 0 7
90370: ARRAY
90371: PPUSH
90372: LD_VAR 0 14
90376: PUSH
90377: LD_VAR 0 8
90381: ARRAY
90382: PPUSH
90383: CALL_OW 115
// attacking := true ;
90387: LD_ADDR_VAR 0 29
90391: PUSH
90392: LD_INT 1
90394: ST_TO_ADDR
// break ;
90395: GO 90399
// end ;
90397: GO 90336
90399: POP
90400: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90401: LD_VAR 0 4
90405: PUSH
90406: LD_VAR 0 7
90410: ARRAY
90411: PPUSH
90412: CALL_OW 302
90416: PUSH
90417: LD_VAR 0 29
90421: NOT
90422: AND
90423: IFFALSE 90745
// begin if GetTag ( group [ i ] ) = 71 then
90425: LD_VAR 0 4
90429: PUSH
90430: LD_VAR 0 7
90434: ARRAY
90435: PPUSH
90436: CALL_OW 110
90440: PUSH
90441: LD_INT 71
90443: EQUAL
90444: IFFALSE 90485
// begin if HasTask ( group [ i ] ) then
90446: LD_VAR 0 4
90450: PUSH
90451: LD_VAR 0 7
90455: ARRAY
90456: PPUSH
90457: CALL_OW 314
90461: IFFALSE 90467
// continue else
90463: GO 86650
90465: GO 90485
// SetTag ( group [ i ] , 0 ) ;
90467: LD_VAR 0 4
90471: PUSH
90472: LD_VAR 0 7
90476: ARRAY
90477: PPUSH
90478: LD_INT 0
90480: PPUSH
90481: CALL_OW 109
// end ; k := 8 ;
90485: LD_ADDR_VAR 0 9
90489: PUSH
90490: LD_INT 8
90492: ST_TO_ADDR
// x := 0 ;
90493: LD_ADDR_VAR 0 10
90497: PUSH
90498: LD_INT 0
90500: ST_TO_ADDR
// if tmp < k then
90501: LD_VAR 0 14
90505: PUSH
90506: LD_VAR 0 9
90510: LESS
90511: IFFALSE 90523
// k := tmp ;
90513: LD_ADDR_VAR 0 9
90517: PUSH
90518: LD_VAR 0 14
90522: ST_TO_ADDR
// for j = 1 to k do
90523: LD_ADDR_VAR 0 8
90527: PUSH
90528: DOUBLE
90529: LD_INT 1
90531: DEC
90532: ST_TO_ADDR
90533: LD_VAR 0 9
90537: PUSH
90538: FOR_TO
90539: IFFALSE 90637
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90541: LD_VAR 0 14
90545: PUSH
90546: LD_VAR 0 8
90550: ARRAY
90551: PPUSH
90552: CALL_OW 247
90556: PUSH
90557: LD_INT 1
90559: EQUAL
90560: PUSH
90561: LD_VAR 0 14
90565: PUSH
90566: LD_VAR 0 8
90570: ARRAY
90571: PPUSH
90572: CALL_OW 256
90576: PUSH
90577: LD_INT 250
90579: LESS
90580: PUSH
90581: LD_VAR 0 20
90585: AND
90586: PUSH
90587: LD_VAR 0 20
90591: NOT
90592: PUSH
90593: LD_VAR 0 14
90597: PUSH
90598: LD_VAR 0 8
90602: ARRAY
90603: PPUSH
90604: CALL_OW 256
90608: PUSH
90609: LD_INT 250
90611: GREATEREQUAL
90612: AND
90613: OR
90614: AND
90615: IFFALSE 90635
// begin x := tmp [ j ] ;
90617: LD_ADDR_VAR 0 10
90621: PUSH
90622: LD_VAR 0 14
90626: PUSH
90627: LD_VAR 0 8
90631: ARRAY
90632: ST_TO_ADDR
// break ;
90633: GO 90637
// end ;
90635: GO 90538
90637: POP
90638: POP
// if x then
90639: LD_VAR 0 10
90643: IFFALSE 90667
// ComAttackUnit ( group [ i ] , x ) else
90645: LD_VAR 0 4
90649: PUSH
90650: LD_VAR 0 7
90654: ARRAY
90655: PPUSH
90656: LD_VAR 0 10
90660: PPUSH
90661: CALL_OW 115
90665: GO 90691
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90667: LD_VAR 0 4
90671: PUSH
90672: LD_VAR 0 7
90676: ARRAY
90677: PPUSH
90678: LD_VAR 0 14
90682: PUSH
90683: LD_INT 1
90685: ARRAY
90686: PPUSH
90687: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90691: LD_VAR 0 4
90695: PUSH
90696: LD_VAR 0 7
90700: ARRAY
90701: PPUSH
90702: CALL_OW 314
90706: NOT
90707: IFFALSE 90745
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90709: LD_VAR 0 4
90713: PUSH
90714: LD_VAR 0 7
90718: ARRAY
90719: PPUSH
90720: LD_VAR 0 14
90724: PPUSH
90725: LD_VAR 0 4
90729: PUSH
90730: LD_VAR 0 7
90734: ARRAY
90735: PPUSH
90736: CALL_OW 74
90740: PPUSH
90741: CALL_OW 115
// end ; end ; end ;
90745: GO 86650
90747: POP
90748: POP
// wait ( 0 0$1 ) ;
90749: LD_INT 35
90751: PPUSH
90752: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90756: LD_VAR 0 4
90760: PUSH
90761: EMPTY
90762: EQUAL
90763: PUSH
90764: LD_INT 81
90766: PUSH
90767: LD_VAR 0 35
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PPUSH
90776: CALL_OW 69
90780: NOT
90781: OR
90782: IFFALSE 86635
// end ;
90784: LD_VAR 0 2
90788: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90789: LD_INT 0
90791: PPUSH
90792: PPUSH
90793: PPUSH
90794: PPUSH
// if not base_units then
90795: LD_VAR 0 1
90799: NOT
90800: IFFALSE 90804
// exit ;
90802: GO 90891
// result := false ;
90804: LD_ADDR_VAR 0 2
90808: PUSH
90809: LD_INT 0
90811: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90812: LD_ADDR_VAR 0 5
90816: PUSH
90817: LD_VAR 0 1
90821: PPUSH
90822: LD_INT 21
90824: PUSH
90825: LD_INT 3
90827: PUSH
90828: EMPTY
90829: LIST
90830: LIST
90831: PPUSH
90832: CALL_OW 72
90836: ST_TO_ADDR
// if not tmp then
90837: LD_VAR 0 5
90841: NOT
90842: IFFALSE 90846
// exit ;
90844: GO 90891
// for i in tmp do
90846: LD_ADDR_VAR 0 3
90850: PUSH
90851: LD_VAR 0 5
90855: PUSH
90856: FOR_IN
90857: IFFALSE 90889
// begin result := EnemyInRange ( i , 22 ) ;
90859: LD_ADDR_VAR 0 2
90863: PUSH
90864: LD_VAR 0 3
90868: PPUSH
90869: LD_INT 22
90871: PPUSH
90872: CALL 84428 0 2
90876: ST_TO_ADDR
// if result then
90877: LD_VAR 0 2
90881: IFFALSE 90887
// exit ;
90883: POP
90884: POP
90885: GO 90891
// end ;
90887: GO 90856
90889: POP
90890: POP
// end ;
90891: LD_VAR 0 2
90895: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
90896: LD_INT 0
90898: PPUSH
90899: PPUSH
// if not units then
90900: LD_VAR 0 1
90904: NOT
90905: IFFALSE 90909
// exit ;
90907: GO 90979
// result := [ ] ;
90909: LD_ADDR_VAR 0 3
90913: PUSH
90914: EMPTY
90915: ST_TO_ADDR
// for i in units do
90916: LD_ADDR_VAR 0 4
90920: PUSH
90921: LD_VAR 0 1
90925: PUSH
90926: FOR_IN
90927: IFFALSE 90977
// if GetTag ( i ) = tag then
90929: LD_VAR 0 4
90933: PPUSH
90934: CALL_OW 110
90938: PUSH
90939: LD_VAR 0 2
90943: EQUAL
90944: IFFALSE 90975
// result := Insert ( result , result + 1 , i ) ;
90946: LD_ADDR_VAR 0 3
90950: PUSH
90951: LD_VAR 0 3
90955: PPUSH
90956: LD_VAR 0 3
90960: PUSH
90961: LD_INT 1
90963: PLUS
90964: PPUSH
90965: LD_VAR 0 4
90969: PPUSH
90970: CALL_OW 2
90974: ST_TO_ADDR
90975: GO 90926
90977: POP
90978: POP
// end ;
90979: LD_VAR 0 3
90983: RET
// export function IsDriver ( un ) ; begin
90984: LD_INT 0
90986: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90987: LD_ADDR_VAR 0 2
90991: PUSH
90992: LD_VAR 0 1
90996: PUSH
90997: LD_INT 55
90999: PUSH
91000: EMPTY
91001: LIST
91002: PPUSH
91003: CALL_OW 69
91007: IN
91008: ST_TO_ADDR
// end ;
91009: LD_VAR 0 2
91013: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
91014: LD_INT 0
91016: PPUSH
91017: PPUSH
// list := [ ] ;
91018: LD_ADDR_VAR 0 5
91022: PUSH
91023: EMPTY
91024: ST_TO_ADDR
// case d of 0 :
91025: LD_VAR 0 3
91029: PUSH
91030: LD_INT 0
91032: DOUBLE
91033: EQUAL
91034: IFTRUE 91038
91036: GO 91171
91038: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
91039: LD_ADDR_VAR 0 5
91043: PUSH
91044: LD_VAR 0 1
91048: PUSH
91049: LD_INT 4
91051: MINUS
91052: PUSH
91053: LD_VAR 0 2
91057: PUSH
91058: LD_INT 4
91060: MINUS
91061: PUSH
91062: LD_INT 2
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: LIST
91069: PUSH
91070: LD_VAR 0 1
91074: PUSH
91075: LD_INT 3
91077: MINUS
91078: PUSH
91079: LD_VAR 0 2
91083: PUSH
91084: LD_INT 1
91086: PUSH
91087: EMPTY
91088: LIST
91089: LIST
91090: LIST
91091: PUSH
91092: LD_VAR 0 1
91096: PUSH
91097: LD_INT 4
91099: PLUS
91100: PUSH
91101: LD_VAR 0 2
91105: PUSH
91106: LD_INT 4
91108: PUSH
91109: EMPTY
91110: LIST
91111: LIST
91112: LIST
91113: PUSH
91114: LD_VAR 0 1
91118: PUSH
91119: LD_INT 3
91121: PLUS
91122: PUSH
91123: LD_VAR 0 2
91127: PUSH
91128: LD_INT 3
91130: PLUS
91131: PUSH
91132: LD_INT 5
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: LIST
91139: PUSH
91140: LD_VAR 0 1
91144: PUSH
91145: LD_VAR 0 2
91149: PUSH
91150: LD_INT 4
91152: PLUS
91153: PUSH
91154: LD_INT 0
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: LIST
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: ST_TO_ADDR
// end ; 1 :
91169: GO 91869
91171: LD_INT 1
91173: DOUBLE
91174: EQUAL
91175: IFTRUE 91179
91177: GO 91312
91179: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91180: LD_ADDR_VAR 0 5
91184: PUSH
91185: LD_VAR 0 1
91189: PUSH
91190: LD_VAR 0 2
91194: PUSH
91195: LD_INT 4
91197: MINUS
91198: PUSH
91199: LD_INT 3
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: LIST
91206: PUSH
91207: LD_VAR 0 1
91211: PUSH
91212: LD_INT 3
91214: MINUS
91215: PUSH
91216: LD_VAR 0 2
91220: PUSH
91221: LD_INT 3
91223: MINUS
91224: PUSH
91225: LD_INT 2
91227: PUSH
91228: EMPTY
91229: LIST
91230: LIST
91231: LIST
91232: PUSH
91233: LD_VAR 0 1
91237: PUSH
91238: LD_INT 4
91240: MINUS
91241: PUSH
91242: LD_VAR 0 2
91246: PUSH
91247: LD_INT 1
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: LIST
91254: PUSH
91255: LD_VAR 0 1
91259: PUSH
91260: LD_VAR 0 2
91264: PUSH
91265: LD_INT 3
91267: PLUS
91268: PUSH
91269: LD_INT 0
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: LIST
91276: PUSH
91277: LD_VAR 0 1
91281: PUSH
91282: LD_INT 4
91284: PLUS
91285: PUSH
91286: LD_VAR 0 2
91290: PUSH
91291: LD_INT 4
91293: PLUS
91294: PUSH
91295: LD_INT 5
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: LIST
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: ST_TO_ADDR
// end ; 2 :
91310: GO 91869
91312: LD_INT 2
91314: DOUBLE
91315: EQUAL
91316: IFTRUE 91320
91318: GO 91449
91320: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91321: LD_ADDR_VAR 0 5
91325: PUSH
91326: LD_VAR 0 1
91330: PUSH
91331: LD_VAR 0 2
91335: PUSH
91336: LD_INT 3
91338: MINUS
91339: PUSH
91340: LD_INT 3
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: LIST
91347: PUSH
91348: LD_VAR 0 1
91352: PUSH
91353: LD_INT 4
91355: PLUS
91356: PUSH
91357: LD_VAR 0 2
91361: PUSH
91362: LD_INT 4
91364: PUSH
91365: EMPTY
91366: LIST
91367: LIST
91368: LIST
91369: PUSH
91370: LD_VAR 0 1
91374: PUSH
91375: LD_VAR 0 2
91379: PUSH
91380: LD_INT 4
91382: PLUS
91383: PUSH
91384: LD_INT 0
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: LIST
91391: PUSH
91392: LD_VAR 0 1
91396: PUSH
91397: LD_INT 3
91399: MINUS
91400: PUSH
91401: LD_VAR 0 2
91405: PUSH
91406: LD_INT 1
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: LIST
91413: PUSH
91414: LD_VAR 0 1
91418: PUSH
91419: LD_INT 4
91421: MINUS
91422: PUSH
91423: LD_VAR 0 2
91427: PUSH
91428: LD_INT 4
91430: MINUS
91431: PUSH
91432: LD_INT 2
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: LIST
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: ST_TO_ADDR
// end ; 3 :
91447: GO 91869
91449: LD_INT 3
91451: DOUBLE
91452: EQUAL
91453: IFTRUE 91457
91455: GO 91590
91457: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91458: LD_ADDR_VAR 0 5
91462: PUSH
91463: LD_VAR 0 1
91467: PUSH
91468: LD_INT 3
91470: PLUS
91471: PUSH
91472: LD_VAR 0 2
91476: PUSH
91477: LD_INT 4
91479: PUSH
91480: EMPTY
91481: LIST
91482: LIST
91483: LIST
91484: PUSH
91485: LD_VAR 0 1
91489: PUSH
91490: LD_INT 4
91492: PLUS
91493: PUSH
91494: LD_VAR 0 2
91498: PUSH
91499: LD_INT 4
91501: PLUS
91502: PUSH
91503: LD_INT 5
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: LIST
91510: PUSH
91511: LD_VAR 0 1
91515: PUSH
91516: LD_INT 4
91518: MINUS
91519: PUSH
91520: LD_VAR 0 2
91524: PUSH
91525: LD_INT 1
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: LIST
91532: PUSH
91533: LD_VAR 0 1
91537: PUSH
91538: LD_VAR 0 2
91542: PUSH
91543: LD_INT 4
91545: MINUS
91546: PUSH
91547: LD_INT 3
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: LIST
91554: PUSH
91555: LD_VAR 0 1
91559: PUSH
91560: LD_INT 3
91562: MINUS
91563: PUSH
91564: LD_VAR 0 2
91568: PUSH
91569: LD_INT 3
91571: MINUS
91572: PUSH
91573: LD_INT 2
91575: PUSH
91576: EMPTY
91577: LIST
91578: LIST
91579: LIST
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: LIST
91585: LIST
91586: LIST
91587: ST_TO_ADDR
// end ; 4 :
91588: GO 91869
91590: LD_INT 4
91592: DOUBLE
91593: EQUAL
91594: IFTRUE 91598
91596: GO 91731
91598: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91599: LD_ADDR_VAR 0 5
91603: PUSH
91604: LD_VAR 0 1
91608: PUSH
91609: LD_VAR 0 2
91613: PUSH
91614: LD_INT 4
91616: PLUS
91617: PUSH
91618: LD_INT 0
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: LIST
91625: PUSH
91626: LD_VAR 0 1
91630: PUSH
91631: LD_INT 3
91633: PLUS
91634: PUSH
91635: LD_VAR 0 2
91639: PUSH
91640: LD_INT 3
91642: PLUS
91643: PUSH
91644: LD_INT 5
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: LIST
91651: PUSH
91652: LD_VAR 0 1
91656: PUSH
91657: LD_INT 4
91659: PLUS
91660: PUSH
91661: LD_VAR 0 2
91665: PUSH
91666: LD_INT 4
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: LIST
91673: PUSH
91674: LD_VAR 0 1
91678: PUSH
91679: LD_VAR 0 2
91683: PUSH
91684: LD_INT 3
91686: MINUS
91687: PUSH
91688: LD_INT 3
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: LIST
91695: PUSH
91696: LD_VAR 0 1
91700: PUSH
91701: LD_INT 4
91703: MINUS
91704: PUSH
91705: LD_VAR 0 2
91709: PUSH
91710: LD_INT 4
91712: MINUS
91713: PUSH
91714: LD_INT 2
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: LIST
91721: PUSH
91722: EMPTY
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: ST_TO_ADDR
// end ; 5 :
91729: GO 91869
91731: LD_INT 5
91733: DOUBLE
91734: EQUAL
91735: IFTRUE 91739
91737: GO 91868
91739: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91740: LD_ADDR_VAR 0 5
91744: PUSH
91745: LD_VAR 0 1
91749: PUSH
91750: LD_INT 4
91752: MINUS
91753: PUSH
91754: LD_VAR 0 2
91758: PUSH
91759: LD_INT 1
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: LIST
91766: PUSH
91767: LD_VAR 0 1
91771: PUSH
91772: LD_VAR 0 2
91776: PUSH
91777: LD_INT 4
91779: MINUS
91780: PUSH
91781: LD_INT 3
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: LIST
91788: PUSH
91789: LD_VAR 0 1
91793: PUSH
91794: LD_INT 4
91796: PLUS
91797: PUSH
91798: LD_VAR 0 2
91802: PUSH
91803: LD_INT 4
91805: PLUS
91806: PUSH
91807: LD_INT 5
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: LIST
91814: PUSH
91815: LD_VAR 0 1
91819: PUSH
91820: LD_INT 3
91822: PLUS
91823: PUSH
91824: LD_VAR 0 2
91828: PUSH
91829: LD_INT 4
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: LIST
91836: PUSH
91837: LD_VAR 0 1
91841: PUSH
91842: LD_VAR 0 2
91846: PUSH
91847: LD_INT 3
91849: PLUS
91850: PUSH
91851: LD_INT 0
91853: PUSH
91854: EMPTY
91855: LIST
91856: LIST
91857: LIST
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: ST_TO_ADDR
// end ; end ;
91866: GO 91869
91868: POP
// result := list ;
91869: LD_ADDR_VAR 0 4
91873: PUSH
91874: LD_VAR 0 5
91878: ST_TO_ADDR
// end ;
91879: LD_VAR 0 4
91883: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91884: LD_INT 0
91886: PPUSH
91887: PPUSH
91888: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91889: LD_VAR 0 1
91893: NOT
91894: PUSH
91895: LD_VAR 0 2
91899: PUSH
91900: LD_INT 1
91902: PUSH
91903: LD_INT 2
91905: PUSH
91906: LD_INT 3
91908: PUSH
91909: LD_INT 4
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: IN
91918: NOT
91919: OR
91920: IFFALSE 91924
// exit ;
91922: GO 92016
// tmp := [ ] ;
91924: LD_ADDR_VAR 0 5
91928: PUSH
91929: EMPTY
91930: ST_TO_ADDR
// for i in units do
91931: LD_ADDR_VAR 0 4
91935: PUSH
91936: LD_VAR 0 1
91940: PUSH
91941: FOR_IN
91942: IFFALSE 91985
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
91944: LD_ADDR_VAR 0 5
91948: PUSH
91949: LD_VAR 0 5
91953: PPUSH
91954: LD_VAR 0 5
91958: PUSH
91959: LD_INT 1
91961: PLUS
91962: PPUSH
91963: LD_VAR 0 4
91967: PPUSH
91968: LD_VAR 0 2
91972: PPUSH
91973: CALL_OW 259
91977: PPUSH
91978: CALL_OW 2
91982: ST_TO_ADDR
91983: GO 91941
91985: POP
91986: POP
// if not tmp then
91987: LD_VAR 0 5
91991: NOT
91992: IFFALSE 91996
// exit ;
91994: GO 92016
// result := SortListByListDesc ( units , tmp ) ;
91996: LD_ADDR_VAR 0 3
92000: PUSH
92001: LD_VAR 0 1
92005: PPUSH
92006: LD_VAR 0 5
92010: PPUSH
92011: CALL_OW 77
92015: ST_TO_ADDR
// end ;
92016: LD_VAR 0 3
92020: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
92021: LD_INT 0
92023: PPUSH
92024: PPUSH
92025: PPUSH
// x := GetX ( building ) ;
92026: LD_ADDR_VAR 0 4
92030: PUSH
92031: LD_VAR 0 2
92035: PPUSH
92036: CALL_OW 250
92040: ST_TO_ADDR
// y := GetY ( building ) ;
92041: LD_ADDR_VAR 0 5
92045: PUSH
92046: LD_VAR 0 2
92050: PPUSH
92051: CALL_OW 251
92055: ST_TO_ADDR
// if GetTaskList ( unit ) then
92056: LD_VAR 0 1
92060: PPUSH
92061: CALL_OW 437
92065: IFFALSE 92160
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
92067: LD_STRING e
92069: PUSH
92070: LD_VAR 0 1
92074: PPUSH
92075: CALL_OW 437
92079: PUSH
92080: LD_INT 1
92082: ARRAY
92083: PUSH
92084: LD_INT 1
92086: ARRAY
92087: EQUAL
92088: PUSH
92089: LD_VAR 0 4
92093: PUSH
92094: LD_VAR 0 1
92098: PPUSH
92099: CALL_OW 437
92103: PUSH
92104: LD_INT 1
92106: ARRAY
92107: PUSH
92108: LD_INT 2
92110: ARRAY
92111: EQUAL
92112: AND
92113: PUSH
92114: LD_VAR 0 5
92118: PUSH
92119: LD_VAR 0 1
92123: PPUSH
92124: CALL_OW 437
92128: PUSH
92129: LD_INT 1
92131: ARRAY
92132: PUSH
92133: LD_INT 3
92135: ARRAY
92136: EQUAL
92137: AND
92138: IFFALSE 92150
// result := true else
92140: LD_ADDR_VAR 0 3
92144: PUSH
92145: LD_INT 1
92147: ST_TO_ADDR
92148: GO 92158
// result := false ;
92150: LD_ADDR_VAR 0 3
92154: PUSH
92155: LD_INT 0
92157: ST_TO_ADDR
// end else
92158: GO 92168
// result := false ;
92160: LD_ADDR_VAR 0 3
92164: PUSH
92165: LD_INT 0
92167: ST_TO_ADDR
// end ;
92168: LD_VAR 0 3
92172: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92173: LD_INT 0
92175: PPUSH
92176: PPUSH
92177: PPUSH
92178: PPUSH
// if not unit or not area then
92179: LD_VAR 0 1
92183: NOT
92184: PUSH
92185: LD_VAR 0 2
92189: NOT
92190: OR
92191: IFFALSE 92195
// exit ;
92193: GO 92359
// tmp := AreaToList ( area , i ) ;
92195: LD_ADDR_VAR 0 6
92199: PUSH
92200: LD_VAR 0 2
92204: PPUSH
92205: LD_VAR 0 5
92209: PPUSH
92210: CALL_OW 517
92214: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92215: LD_ADDR_VAR 0 5
92219: PUSH
92220: DOUBLE
92221: LD_INT 1
92223: DEC
92224: ST_TO_ADDR
92225: LD_VAR 0 6
92229: PUSH
92230: LD_INT 1
92232: ARRAY
92233: PUSH
92234: FOR_TO
92235: IFFALSE 92357
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92237: LD_ADDR_VAR 0 7
92241: PUSH
92242: LD_VAR 0 6
92246: PUSH
92247: LD_INT 1
92249: ARRAY
92250: PUSH
92251: LD_VAR 0 5
92255: ARRAY
92256: PUSH
92257: LD_VAR 0 6
92261: PUSH
92262: LD_INT 2
92264: ARRAY
92265: PUSH
92266: LD_VAR 0 5
92270: ARRAY
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92276: LD_VAR 0 7
92280: PUSH
92281: LD_INT 1
92283: ARRAY
92284: PPUSH
92285: LD_VAR 0 7
92289: PUSH
92290: LD_INT 2
92292: ARRAY
92293: PPUSH
92294: CALL_OW 428
92298: PUSH
92299: LD_INT 0
92301: EQUAL
92302: IFFALSE 92355
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92304: LD_VAR 0 1
92308: PPUSH
92309: LD_VAR 0 7
92313: PUSH
92314: LD_INT 1
92316: ARRAY
92317: PPUSH
92318: LD_VAR 0 7
92322: PUSH
92323: LD_INT 2
92325: ARRAY
92326: PPUSH
92327: LD_VAR 0 3
92331: PPUSH
92332: CALL_OW 48
// result := IsPlaced ( unit ) ;
92336: LD_ADDR_VAR 0 4
92340: PUSH
92341: LD_VAR 0 1
92345: PPUSH
92346: CALL_OW 305
92350: ST_TO_ADDR
// exit ;
92351: POP
92352: POP
92353: GO 92359
// end ; end ;
92355: GO 92234
92357: POP
92358: POP
// end ;
92359: LD_VAR 0 4
92363: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92364: LD_INT 0
92366: PPUSH
92367: PPUSH
92368: PPUSH
// if not side or side > 8 then
92369: LD_VAR 0 1
92373: NOT
92374: PUSH
92375: LD_VAR 0 1
92379: PUSH
92380: LD_INT 8
92382: GREATER
92383: OR
92384: IFFALSE 92388
// exit ;
92386: GO 92575
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92388: LD_ADDR_VAR 0 4
92392: PUSH
92393: LD_INT 22
92395: PUSH
92396: LD_VAR 0 1
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: PUSH
92405: LD_INT 21
92407: PUSH
92408: LD_INT 3
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: PPUSH
92419: CALL_OW 69
92423: ST_TO_ADDR
// if not tmp then
92424: LD_VAR 0 4
92428: NOT
92429: IFFALSE 92433
// exit ;
92431: GO 92575
// enable_addtolog := true ;
92433: LD_ADDR_OWVAR 81
92437: PUSH
92438: LD_INT 1
92440: ST_TO_ADDR
// AddToLog ( [ ) ;
92441: LD_STRING [
92443: PPUSH
92444: CALL_OW 561
// for i in tmp do
92448: LD_ADDR_VAR 0 3
92452: PUSH
92453: LD_VAR 0 4
92457: PUSH
92458: FOR_IN
92459: IFFALSE 92566
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92461: LD_STRING [
92463: PUSH
92464: LD_VAR 0 3
92468: PPUSH
92469: CALL_OW 266
92473: STR
92474: PUSH
92475: LD_STRING , 
92477: STR
92478: PUSH
92479: LD_VAR 0 3
92483: PPUSH
92484: CALL_OW 250
92488: STR
92489: PUSH
92490: LD_STRING , 
92492: STR
92493: PUSH
92494: LD_VAR 0 3
92498: PPUSH
92499: CALL_OW 251
92503: STR
92504: PUSH
92505: LD_STRING , 
92507: STR
92508: PUSH
92509: LD_VAR 0 3
92513: PPUSH
92514: CALL_OW 254
92518: STR
92519: PUSH
92520: LD_STRING , 
92522: STR
92523: PUSH
92524: LD_VAR 0 3
92528: PPUSH
92529: LD_INT 1
92531: PPUSH
92532: CALL_OW 268
92536: STR
92537: PUSH
92538: LD_STRING , 
92540: STR
92541: PUSH
92542: LD_VAR 0 3
92546: PPUSH
92547: LD_INT 2
92549: PPUSH
92550: CALL_OW 268
92554: STR
92555: PUSH
92556: LD_STRING ],
92558: STR
92559: PPUSH
92560: CALL_OW 561
// end ;
92564: GO 92458
92566: POP
92567: POP
// AddToLog ( ]; ) ;
92568: LD_STRING ];
92570: PPUSH
92571: CALL_OW 561
// end ;
92575: LD_VAR 0 2
92579: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92580: LD_INT 0
92582: PPUSH
92583: PPUSH
92584: PPUSH
92585: PPUSH
92586: PPUSH
// if not area or not rate or not max then
92587: LD_VAR 0 1
92591: NOT
92592: PUSH
92593: LD_VAR 0 2
92597: NOT
92598: OR
92599: PUSH
92600: LD_VAR 0 4
92604: NOT
92605: OR
92606: IFFALSE 92610
// exit ;
92608: GO 92802
// while 1 do
92610: LD_INT 1
92612: IFFALSE 92802
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92614: LD_ADDR_VAR 0 9
92618: PUSH
92619: LD_VAR 0 1
92623: PPUSH
92624: LD_INT 1
92626: PPUSH
92627: CALL_OW 287
92631: PUSH
92632: LD_INT 10
92634: MUL
92635: ST_TO_ADDR
// r := rate / 10 ;
92636: LD_ADDR_VAR 0 7
92640: PUSH
92641: LD_VAR 0 2
92645: PUSH
92646: LD_INT 10
92648: DIVREAL
92649: ST_TO_ADDR
// time := 1 1$00 ;
92650: LD_ADDR_VAR 0 8
92654: PUSH
92655: LD_INT 2100
92657: ST_TO_ADDR
// if amount < min then
92658: LD_VAR 0 9
92662: PUSH
92663: LD_VAR 0 3
92667: LESS
92668: IFFALSE 92686
// r := r * 2 else
92670: LD_ADDR_VAR 0 7
92674: PUSH
92675: LD_VAR 0 7
92679: PUSH
92680: LD_INT 2
92682: MUL
92683: ST_TO_ADDR
92684: GO 92712
// if amount > max then
92686: LD_VAR 0 9
92690: PUSH
92691: LD_VAR 0 4
92695: GREATER
92696: IFFALSE 92712
// r := r / 2 ;
92698: LD_ADDR_VAR 0 7
92702: PUSH
92703: LD_VAR 0 7
92707: PUSH
92708: LD_INT 2
92710: DIVREAL
92711: ST_TO_ADDR
// time := time / r ;
92712: LD_ADDR_VAR 0 8
92716: PUSH
92717: LD_VAR 0 8
92721: PUSH
92722: LD_VAR 0 7
92726: DIVREAL
92727: ST_TO_ADDR
// if time < 0 then
92728: LD_VAR 0 8
92732: PUSH
92733: LD_INT 0
92735: LESS
92736: IFFALSE 92753
// time := time * - 1 ;
92738: LD_ADDR_VAR 0 8
92742: PUSH
92743: LD_VAR 0 8
92747: PUSH
92748: LD_INT 1
92750: NEG
92751: MUL
92752: ST_TO_ADDR
// wait ( time ) ;
92753: LD_VAR 0 8
92757: PPUSH
92758: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92762: LD_INT 35
92764: PPUSH
92765: LD_INT 875
92767: PPUSH
92768: CALL_OW 12
92772: PPUSH
92773: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92777: LD_INT 1
92779: PPUSH
92780: LD_INT 5
92782: PPUSH
92783: CALL_OW 12
92787: PPUSH
92788: LD_VAR 0 1
92792: PPUSH
92793: LD_INT 1
92795: PPUSH
92796: CALL_OW 55
// end ;
92800: GO 92610
// end ;
92802: LD_VAR 0 5
92806: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92807: LD_INT 0
92809: PPUSH
92810: PPUSH
92811: PPUSH
92812: PPUSH
92813: PPUSH
92814: PPUSH
92815: PPUSH
92816: PPUSH
// if not turrets or not factories then
92817: LD_VAR 0 1
92821: NOT
92822: PUSH
92823: LD_VAR 0 2
92827: NOT
92828: OR
92829: IFFALSE 92833
// exit ;
92831: GO 93140
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92833: LD_ADDR_VAR 0 10
92837: PUSH
92838: LD_INT 5
92840: PUSH
92841: LD_INT 6
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: LD_INT 2
92850: PUSH
92851: LD_INT 4
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: PUSH
92858: LD_INT 3
92860: PUSH
92861: LD_INT 5
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 24
92875: PUSH
92876: LD_INT 25
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 23
92885: PUSH
92886: LD_INT 27
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 42
92899: PUSH
92900: LD_INT 43
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 44
92909: PUSH
92910: LD_INT 46
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 45
92919: PUSH
92920: LD_INT 47
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: LIST
92931: PUSH
92932: EMPTY
92933: LIST
92934: LIST
92935: LIST
92936: ST_TO_ADDR
// result := [ ] ;
92937: LD_ADDR_VAR 0 3
92941: PUSH
92942: EMPTY
92943: ST_TO_ADDR
// for i in turrets do
92944: LD_ADDR_VAR 0 4
92948: PUSH
92949: LD_VAR 0 1
92953: PUSH
92954: FOR_IN
92955: IFFALSE 93138
// begin nat := GetNation ( i ) ;
92957: LD_ADDR_VAR 0 7
92961: PUSH
92962: LD_VAR 0 4
92966: PPUSH
92967: CALL_OW 248
92971: ST_TO_ADDR
// weapon := 0 ;
92972: LD_ADDR_VAR 0 8
92976: PUSH
92977: LD_INT 0
92979: ST_TO_ADDR
// if not nat then
92980: LD_VAR 0 7
92984: NOT
92985: IFFALSE 92989
// continue ;
92987: GO 92954
// for j in list [ nat ] do
92989: LD_ADDR_VAR 0 5
92993: PUSH
92994: LD_VAR 0 10
92998: PUSH
92999: LD_VAR 0 7
93003: ARRAY
93004: PUSH
93005: FOR_IN
93006: IFFALSE 93047
// if GetBWeapon ( i ) = j [ 1 ] then
93008: LD_VAR 0 4
93012: PPUSH
93013: CALL_OW 269
93017: PUSH
93018: LD_VAR 0 5
93022: PUSH
93023: LD_INT 1
93025: ARRAY
93026: EQUAL
93027: IFFALSE 93045
// begin weapon := j [ 2 ] ;
93029: LD_ADDR_VAR 0 8
93033: PUSH
93034: LD_VAR 0 5
93038: PUSH
93039: LD_INT 2
93041: ARRAY
93042: ST_TO_ADDR
// break ;
93043: GO 93047
// end ;
93045: GO 93005
93047: POP
93048: POP
// if not weapon then
93049: LD_VAR 0 8
93053: NOT
93054: IFFALSE 93058
// continue ;
93056: GO 92954
// for k in factories do
93058: LD_ADDR_VAR 0 6
93062: PUSH
93063: LD_VAR 0 2
93067: PUSH
93068: FOR_IN
93069: IFFALSE 93134
// begin weapons := AvailableWeaponList ( k ) ;
93071: LD_ADDR_VAR 0 9
93075: PUSH
93076: LD_VAR 0 6
93080: PPUSH
93081: CALL_OW 478
93085: ST_TO_ADDR
// if not weapons then
93086: LD_VAR 0 9
93090: NOT
93091: IFFALSE 93095
// continue ;
93093: GO 93068
// if weapon in weapons then
93095: LD_VAR 0 8
93099: PUSH
93100: LD_VAR 0 9
93104: IN
93105: IFFALSE 93132
// begin result := [ i , weapon ] ;
93107: LD_ADDR_VAR 0 3
93111: PUSH
93112: LD_VAR 0 4
93116: PUSH
93117: LD_VAR 0 8
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: ST_TO_ADDR
// exit ;
93126: POP
93127: POP
93128: POP
93129: POP
93130: GO 93140
// end ; end ;
93132: GO 93068
93134: POP
93135: POP
// end ;
93136: GO 92954
93138: POP
93139: POP
// end ;
93140: LD_VAR 0 3
93144: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
93145: LD_INT 0
93147: PPUSH
// if not side or side > 8 then
93148: LD_VAR 0 3
93152: NOT
93153: PUSH
93154: LD_VAR 0 3
93158: PUSH
93159: LD_INT 8
93161: GREATER
93162: OR
93163: IFFALSE 93167
// exit ;
93165: GO 93226
// if not range then
93167: LD_VAR 0 4
93171: NOT
93172: IFFALSE 93183
// range := - 12 ;
93174: LD_ADDR_VAR 0 4
93178: PUSH
93179: LD_INT 12
93181: NEG
93182: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93183: LD_VAR 0 1
93187: PPUSH
93188: LD_VAR 0 2
93192: PPUSH
93193: LD_VAR 0 3
93197: PPUSH
93198: LD_VAR 0 4
93202: PPUSH
93203: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93207: LD_VAR 0 1
93211: PPUSH
93212: LD_VAR 0 2
93216: PPUSH
93217: LD_VAR 0 3
93221: PPUSH
93222: CALL_OW 331
// end ;
93226: LD_VAR 0 5
93230: RET
// export function Video ( mode ) ; begin
93231: LD_INT 0
93233: PPUSH
// ingame_video = mode ;
93234: LD_ADDR_OWVAR 52
93238: PUSH
93239: LD_VAR 0 1
93243: ST_TO_ADDR
// interface_hidden = mode ;
93244: LD_ADDR_OWVAR 54
93248: PUSH
93249: LD_VAR 0 1
93253: ST_TO_ADDR
// end ;
93254: LD_VAR 0 2
93258: RET
// export function Join ( array , element ) ; begin
93259: LD_INT 0
93261: PPUSH
// result := array ^ element ;
93262: LD_ADDR_VAR 0 3
93266: PUSH
93267: LD_VAR 0 1
93271: PUSH
93272: LD_VAR 0 2
93276: ADD
93277: ST_TO_ADDR
// end ;
93278: LD_VAR 0 3
93282: RET
// export function JoinUnion ( array , element ) ; begin
93283: LD_INT 0
93285: PPUSH
// result := array union element ;
93286: LD_ADDR_VAR 0 3
93290: PUSH
93291: LD_VAR 0 1
93295: PUSH
93296: LD_VAR 0 2
93300: UNION
93301: ST_TO_ADDR
// end ;
93302: LD_VAR 0 3
93306: RET
// export function GetBehemoths ( side ) ; begin
93307: LD_INT 0
93309: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93310: LD_ADDR_VAR 0 2
93314: PUSH
93315: LD_INT 22
93317: PUSH
93318: LD_VAR 0 1
93322: PUSH
93323: EMPTY
93324: LIST
93325: LIST
93326: PUSH
93327: LD_INT 31
93329: PUSH
93330: LD_INT 25
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: EMPTY
93338: LIST
93339: LIST
93340: PPUSH
93341: CALL_OW 69
93345: ST_TO_ADDR
// end ;
93346: LD_VAR 0 2
93350: RET
// export function Shuffle ( array ) ; var i , index ; begin
93351: LD_INT 0
93353: PPUSH
93354: PPUSH
93355: PPUSH
// result := [ ] ;
93356: LD_ADDR_VAR 0 2
93360: PUSH
93361: EMPTY
93362: ST_TO_ADDR
// if not array then
93363: LD_VAR 0 1
93367: NOT
93368: IFFALSE 93372
// exit ;
93370: GO 93471
// Randomize ;
93372: CALL_OW 10
// for i = array downto 1 do
93376: LD_ADDR_VAR 0 3
93380: PUSH
93381: DOUBLE
93382: LD_VAR 0 1
93386: INC
93387: ST_TO_ADDR
93388: LD_INT 1
93390: PUSH
93391: FOR_DOWNTO
93392: IFFALSE 93469
// begin index := rand ( 1 , array ) ;
93394: LD_ADDR_VAR 0 4
93398: PUSH
93399: LD_INT 1
93401: PPUSH
93402: LD_VAR 0 1
93406: PPUSH
93407: CALL_OW 12
93411: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93412: LD_ADDR_VAR 0 2
93416: PUSH
93417: LD_VAR 0 2
93421: PPUSH
93422: LD_VAR 0 2
93426: PUSH
93427: LD_INT 1
93429: PLUS
93430: PPUSH
93431: LD_VAR 0 1
93435: PUSH
93436: LD_VAR 0 4
93440: ARRAY
93441: PPUSH
93442: CALL_OW 2
93446: ST_TO_ADDR
// array := Delete ( array , index ) ;
93447: LD_ADDR_VAR 0 1
93451: PUSH
93452: LD_VAR 0 1
93456: PPUSH
93457: LD_VAR 0 4
93461: PPUSH
93462: CALL_OW 3
93466: ST_TO_ADDR
// end ;
93467: GO 93391
93469: POP
93470: POP
// end ;
93471: LD_VAR 0 2
93475: RET
// export function GetBaseMaterials ( base ) ; begin
93476: LD_INT 0
93478: PPUSH
// result := [ 0 , 0 , 0 ] ;
93479: LD_ADDR_VAR 0 2
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: LD_INT 0
93489: PUSH
93490: LD_INT 0
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: LIST
93497: ST_TO_ADDR
// if not base then
93498: LD_VAR 0 1
93502: NOT
93503: IFFALSE 93507
// exit ;
93505: GO 93556
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93507: LD_ADDR_VAR 0 2
93511: PUSH
93512: LD_VAR 0 1
93516: PPUSH
93517: LD_INT 1
93519: PPUSH
93520: CALL_OW 275
93524: PUSH
93525: LD_VAR 0 1
93529: PPUSH
93530: LD_INT 2
93532: PPUSH
93533: CALL_OW 275
93537: PUSH
93538: LD_VAR 0 1
93542: PPUSH
93543: LD_INT 3
93545: PPUSH
93546: CALL_OW 275
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: LIST
93555: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
93556: LD_VAR 0 2
93560: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
93561: LD_INT 0
93563: PPUSH
93564: PPUSH
93565: PPUSH
93566: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93567: LD_VAR 0 1
93571: PPUSH
93572: CALL_OW 264
93576: PUSH
93577: LD_EXP 73
93581: EQUAL
93582: IFFALSE 93654
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93584: LD_INT 68
93586: PPUSH
93587: LD_VAR 0 1
93591: PPUSH
93592: CALL_OW 255
93596: PPUSH
93597: CALL_OW 321
93601: PUSH
93602: LD_INT 2
93604: EQUAL
93605: IFFALSE 93617
// eff := 70 else
93607: LD_ADDR_VAR 0 6
93611: PUSH
93612: LD_INT 70
93614: ST_TO_ADDR
93615: GO 93625
// eff := 30 ;
93617: LD_ADDR_VAR 0 6
93621: PUSH
93622: LD_INT 30
93624: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93625: LD_VAR 0 1
93629: PPUSH
93630: CALL_OW 250
93634: PPUSH
93635: LD_VAR 0 1
93639: PPUSH
93640: CALL_OW 251
93644: PPUSH
93645: LD_VAR 0 6
93649: PPUSH
93650: CALL_OW 495
// end ; end ;
93654: LD_VAR 0 4
93658: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
93659: LD_INT 0
93661: PPUSH
93662: PPUSH
93663: PPUSH
93664: PPUSH
93665: PPUSH
93666: PPUSH
// if cmd = 124 then
93667: LD_VAR 0 1
93671: PUSH
93672: LD_INT 124
93674: EQUAL
93675: IFFALSE 93881
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
93677: LD_ADDR_VAR 0 5
93681: PUSH
93682: LD_INT 2
93684: PUSH
93685: LD_INT 34
93687: PUSH
93688: LD_INT 53
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 34
93697: PUSH
93698: LD_INT 14
93700: PUSH
93701: EMPTY
93702: LIST
93703: LIST
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: LIST
93709: PPUSH
93710: CALL_OW 69
93714: ST_TO_ADDR
// if not tmp then
93715: LD_VAR 0 5
93719: NOT
93720: IFFALSE 93724
// exit ;
93722: GO 93881
// for i in tmp do
93724: LD_ADDR_VAR 0 3
93728: PUSH
93729: LD_VAR 0 5
93733: PUSH
93734: FOR_IN
93735: IFFALSE 93879
// begin taskList := GetTaskList ( i ) ;
93737: LD_ADDR_VAR 0 6
93741: PUSH
93742: LD_VAR 0 3
93746: PPUSH
93747: CALL_OW 437
93751: ST_TO_ADDR
// if not taskList then
93752: LD_VAR 0 6
93756: NOT
93757: IFFALSE 93761
// continue ;
93759: GO 93734
// for j = 1 to taskList do
93761: LD_ADDR_VAR 0 4
93765: PUSH
93766: DOUBLE
93767: LD_INT 1
93769: DEC
93770: ST_TO_ADDR
93771: LD_VAR 0 6
93775: PUSH
93776: FOR_TO
93777: IFFALSE 93875
// if taskList [ j ] [ 1 ] = | then
93779: LD_VAR 0 6
93783: PUSH
93784: LD_VAR 0 4
93788: ARRAY
93789: PUSH
93790: LD_INT 1
93792: ARRAY
93793: PUSH
93794: LD_STRING |
93796: EQUAL
93797: IFFALSE 93873
// begin _taskList := Delete ( taskList , 1 ) ;
93799: LD_ADDR_VAR 0 7
93803: PUSH
93804: LD_VAR 0 6
93808: PPUSH
93809: LD_INT 1
93811: PPUSH
93812: CALL_OW 3
93816: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93817: LD_VAR 0 3
93821: PPUSH
93822: LD_VAR 0 7
93826: PPUSH
93827: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93831: LD_VAR 0 3
93835: PPUSH
93836: LD_VAR 0 6
93840: PUSH
93841: LD_VAR 0 4
93845: ARRAY
93846: PUSH
93847: LD_INT 2
93849: ARRAY
93850: PPUSH
93851: LD_VAR 0 6
93855: PUSH
93856: LD_VAR 0 4
93860: ARRAY
93861: PUSH
93862: LD_INT 3
93864: ARRAY
93865: PPUSH
93866: LD_INT 8
93868: PPUSH
93869: CALL 93886 0 4
// end ;
93873: GO 93776
93875: POP
93876: POP
// end ;
93877: GO 93734
93879: POP
93880: POP
// end ; end ;
93881: LD_VAR 0 2
93885: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93886: LD_INT 0
93888: PPUSH
93889: PPUSH
93890: PPUSH
93891: PPUSH
93892: PPUSH
93893: PPUSH
93894: PPUSH
93895: PPUSH
93896: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93897: LD_VAR 0 1
93901: NOT
93902: PUSH
93903: LD_VAR 0 2
93907: PPUSH
93908: LD_VAR 0 3
93912: PPUSH
93913: CALL_OW 488
93917: NOT
93918: OR
93919: PUSH
93920: LD_VAR 0 4
93924: NOT
93925: OR
93926: IFFALSE 93930
// exit ;
93928: GO 94270
// list := [ ] ;
93930: LD_ADDR_VAR 0 13
93934: PUSH
93935: EMPTY
93936: ST_TO_ADDR
// if x - r < 0 then
93937: LD_VAR 0 2
93941: PUSH
93942: LD_VAR 0 4
93946: MINUS
93947: PUSH
93948: LD_INT 0
93950: LESS
93951: IFFALSE 93963
// min_x := 0 else
93953: LD_ADDR_VAR 0 7
93957: PUSH
93958: LD_INT 0
93960: ST_TO_ADDR
93961: GO 93979
// min_x := x - r ;
93963: LD_ADDR_VAR 0 7
93967: PUSH
93968: LD_VAR 0 2
93972: PUSH
93973: LD_VAR 0 4
93977: MINUS
93978: ST_TO_ADDR
// if y - r < 0 then
93979: LD_VAR 0 3
93983: PUSH
93984: LD_VAR 0 4
93988: MINUS
93989: PUSH
93990: LD_INT 0
93992: LESS
93993: IFFALSE 94005
// min_y := 0 else
93995: LD_ADDR_VAR 0 8
93999: PUSH
94000: LD_INT 0
94002: ST_TO_ADDR
94003: GO 94021
// min_y := y - r ;
94005: LD_ADDR_VAR 0 8
94009: PUSH
94010: LD_VAR 0 3
94014: PUSH
94015: LD_VAR 0 4
94019: MINUS
94020: ST_TO_ADDR
// max_x := x + r ;
94021: LD_ADDR_VAR 0 9
94025: PUSH
94026: LD_VAR 0 2
94030: PUSH
94031: LD_VAR 0 4
94035: PLUS
94036: ST_TO_ADDR
// max_y := y + r ;
94037: LD_ADDR_VAR 0 10
94041: PUSH
94042: LD_VAR 0 3
94046: PUSH
94047: LD_VAR 0 4
94051: PLUS
94052: ST_TO_ADDR
// for _x = min_x to max_x do
94053: LD_ADDR_VAR 0 11
94057: PUSH
94058: DOUBLE
94059: LD_VAR 0 7
94063: DEC
94064: ST_TO_ADDR
94065: LD_VAR 0 9
94069: PUSH
94070: FOR_TO
94071: IFFALSE 94188
// for _y = min_y to max_y do
94073: LD_ADDR_VAR 0 12
94077: PUSH
94078: DOUBLE
94079: LD_VAR 0 8
94083: DEC
94084: ST_TO_ADDR
94085: LD_VAR 0 10
94089: PUSH
94090: FOR_TO
94091: IFFALSE 94184
// begin if not ValidHex ( _x , _y ) then
94093: LD_VAR 0 11
94097: PPUSH
94098: LD_VAR 0 12
94102: PPUSH
94103: CALL_OW 488
94107: NOT
94108: IFFALSE 94112
// continue ;
94110: GO 94090
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94112: LD_VAR 0 11
94116: PPUSH
94117: LD_VAR 0 12
94121: PPUSH
94122: CALL_OW 351
94126: PUSH
94127: LD_VAR 0 11
94131: PPUSH
94132: LD_VAR 0 12
94136: PPUSH
94137: CALL_OW 554
94141: AND
94142: IFFALSE 94182
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94144: LD_ADDR_VAR 0 13
94148: PUSH
94149: LD_VAR 0 13
94153: PPUSH
94154: LD_VAR 0 13
94158: PUSH
94159: LD_INT 1
94161: PLUS
94162: PPUSH
94163: LD_VAR 0 11
94167: PUSH
94168: LD_VAR 0 12
94172: PUSH
94173: EMPTY
94174: LIST
94175: LIST
94176: PPUSH
94177: CALL_OW 2
94181: ST_TO_ADDR
// end ;
94182: GO 94090
94184: POP
94185: POP
94186: GO 94070
94188: POP
94189: POP
// if not list then
94190: LD_VAR 0 13
94194: NOT
94195: IFFALSE 94199
// exit ;
94197: GO 94270
// for i in list do
94199: LD_ADDR_VAR 0 6
94203: PUSH
94204: LD_VAR 0 13
94208: PUSH
94209: FOR_IN
94210: IFFALSE 94268
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94212: LD_VAR 0 1
94216: PPUSH
94217: LD_STRING M
94219: PUSH
94220: LD_VAR 0 6
94224: PUSH
94225: LD_INT 1
94227: ARRAY
94228: PUSH
94229: LD_VAR 0 6
94233: PUSH
94234: LD_INT 2
94236: ARRAY
94237: PUSH
94238: LD_INT 0
94240: PUSH
94241: LD_INT 0
94243: PUSH
94244: LD_INT 0
94246: PUSH
94247: LD_INT 0
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: LIST
94258: PUSH
94259: EMPTY
94260: LIST
94261: PPUSH
94262: CALL_OW 447
94266: GO 94209
94268: POP
94269: POP
// end ;
94270: LD_VAR 0 5
94274: RET
