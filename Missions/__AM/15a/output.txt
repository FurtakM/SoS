// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 21194 0 0
// InitMacro ;
  19: CALL 21362 0 0
// InitNature ;
  23: CALL 17860 0 0
// InitArtifact ;
  27: CALL 18477 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 5067 0 0
// PrepareAlliance ;
  48: CALL 1444 0 0
// PrepareArabian ;
  52: CALL 6839 0 0
// PrepareRussian ;
  56: CALL 8848 0 0
// PrepareLegion ;
  60: CALL 7271 0 0
// Action ;
  64: CALL 11444 0 0
// MC_Start ( ) ;
  68: CALL 23527 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// allianceTeam := [ ] ;
 212: LD_ADDR_EXP 17
 216: PUSH
 217: EMPTY
 218: ST_TO_ADDR
// arabianAttacked := false ;
 219: LD_ADDR_EXP 18
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// end ;
 227: LD_VAR 0 1
 231: RET
// export function CustomInitMacro ( ) ; begin
 232: LD_INT 0
 234: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 235: LD_ADDR_EXP 119
 239: PUSH
 240: LD_INT 26
 242: PUSH
 243: LD_INT 1
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: LD_INT 8
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 258: LD_ADDR_EXP 120
 262: PUSH
 263: LD_INT 27
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: LD_INT 3
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: EMPTY
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 281: LD_INT 1
 283: PPUSH
 284: LD_INT 6
 286: PUSH
 287: LD_INT 7
 289: PUSH
 290: LD_INT 9
 292: PUSH
 293: LD_INT 10
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: PUSH
 302: LD_OWVAR 67
 306: ARRAY
 307: PPUSH
 308: LD_INT 28
 310: PPUSH
 311: CALL 45216 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 315: LD_INT 1
 317: PPUSH
 318: LD_INT 10
 320: PUSH
 321: LD_INT 11
 323: PUSH
 324: LD_INT 13
 326: PUSH
 327: LD_INT 15
 329: PUSH
 330: EMPTY
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: PPUSH
 336: CALL 46276 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 29
 345: PUSH
 346: EMPTY
 347: LIST
 348: PPUSH
 349: CALL 46369 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 353: LD_ADDR_EXP 124
 357: PUSH
 358: LD_EXP 124
 362: PPUSH
 363: LD_INT 1
 365: PPUSH
 366: LD_INT 22
 368: PUSH
 369: LD_INT 2
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 25
 378: PUSH
 379: LD_INT 15
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL_OW 69
 394: PPUSH
 395: CALL_OW 1
 399: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 400: LD_INT 1
 402: PPUSH
 403: LD_INT 13
 405: PUSH
 406: LD_INT 2
 408: PUSH
 409: LD_INT 1
 411: PUSH
 412: LD_INT 31
 414: PUSH
 415: EMPTY
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: PUSH
 421: LD_INT 13
 423: PUSH
 424: LD_INT 2
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 31
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 13
 441: PUSH
 442: LD_INT 1
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 28
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 13
 459: PUSH
 460: LD_INT 1
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 28
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 13
 477: PUSH
 478: LD_INT 1
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 28
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 13
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 28
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 13
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_EXP 80
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PPUSH
 540: CALL 45534 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 544: LD_INT 1
 546: PPUSH
 547: LD_INT 4
 549: PPUSH
 550: CALL 45719 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 554: LD_INT 2
 556: PPUSH
 557: LD_INT 10
 559: PUSH
 560: LD_INT 11
 562: PUSH
 563: LD_INT 12
 565: PUSH
 566: LD_INT 14
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PPUSH
 575: CALL 46276 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 579: LD_INT 2
 581: PPUSH
 582: LD_INT 14
 584: PUSH
 585: EMPTY
 586: LIST
 587: PPUSH
 588: CALL 46369 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 24
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 47
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PPUSH
 749: CALL 45534 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 753: LD_INT 2
 755: PPUSH
 756: LD_INT 5
 758: PPUSH
 759: CALL 45719 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 763: LD_INT 2
 765: PPUSH
 766: LD_INT 0
 768: PPUSH
 769: CALL 46149 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 773: LD_INT 3
 775: PPUSH
 776: LD_INT 10
 778: PUSH
 779: LD_INT 12
 781: PUSH
 782: LD_INT 14
 784: PUSH
 785: LD_INT 15
 787: PUSH
 788: EMPTY
 789: LIST
 790: LIST
 791: LIST
 792: LIST
 793: PUSH
 794: LD_OWVAR 67
 798: ARRAY
 799: PPUSH
 800: LD_INT 24
 802: PPUSH
 803: CALL 45216 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 10
 812: PUSH
 813: LD_INT 11
 815: PUSH
 816: LD_INT 13
 818: PUSH
 819: LD_INT 15
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 46276 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 13
 837: PUSH
 838: EMPTY
 839: LIST
 840: PPUSH
 841: CALL 46369 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 845: LD_ADDR_EXP 124
 849: PUSH
 850: LD_EXP 124
 854: PPUSH
 855: LD_INT 3
 857: PPUSH
 858: LD_INT 22
 860: PUSH
 861: LD_INT 8
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 25
 870: PUSH
 871: LD_INT 15
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: PPUSH
 882: CALL_OW 69
 886: PPUSH
 887: CALL_OW 1
 891: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 892: LD_INT 3
 894: PPUSH
 895: LD_INT 13
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 31
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 3
 936: PUSH
 937: LD_INT 2
 939: PUSH
 940: LD_INT 32
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 14
 951: PUSH
 952: LD_INT 1
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 28
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 2
1029: PUSH
1030: LD_EXP 80
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PPUSH
1051: CALL 45534 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 4
1060: PPUSH
1061: CALL 45719 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1065: LD_INT 4
1067: PPUSH
1068: LD_INT 10
1070: PUSH
1071: LD_INT 12
1073: PUSH
1074: LD_INT 11
1076: PUSH
1077: LD_INT 15
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: PPUSH
1086: CALL 46276 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1090: LD_INT 4
1092: PPUSH
1093: LD_INT 33
1095: PUSH
1096: EMPTY
1097: LIST
1098: PPUSH
1099: CALL 46369 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1103: LD_INT 4
1105: PPUSH
1106: LD_INT 5
1108: PUSH
1109: LD_INT 6
1111: PUSH
1112: LD_INT 7
1114: PUSH
1115: LD_INT 9
1117: PUSH
1118: LD_INT 10
1120: PUSH
1121: EMPTY
1122: LIST
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PPUSH
1128: CALL 46687 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1132: LD_INT 4
1134: PPUSH
1135: LD_INT 54
1137: PPUSH
1138: LD_INT 85
1140: PPUSH
1141: LD_INT 2
1143: PPUSH
1144: LD_INT 25
1146: PUSH
1147: LD_INT 16
1149: PUSH
1150: LD_INT 17
1152: PUSH
1153: LD_INT 18
1155: PUSH
1156: LD_INT 22
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: PPUSH
1166: CALL 46481 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1170: LD_INT 4
1172: PPUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 1
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 7
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 5
1193: PUSH
1194: LD_INT 1
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 6
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 5
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 7
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: LD_INT 1
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: LD_INT 1
1250: PUSH
1251: LD_INT 3
1253: PUSH
1254: LD_INT 12
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: PUSH
1263: LD_INT 3
1265: PUSH
1266: LD_INT 1
1268: PUSH
1269: LD_INT 3
1271: PUSH
1272: LD_INT 13
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: EMPTY
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: PPUSH
1289: CALL 45534 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1293: LD_INT 4
1295: PPUSH
1296: LD_INT 4
1298: PPUSH
1299: CALL 45719 0 2
// MC_SetTame ( 4 , powellApe ) ;
1303: LD_INT 4
1305: PPUSH
1306: LD_INT 11
1308: PPUSH
1309: CALL 46100 0 2
// end ;
1313: LD_VAR 0 1
1317: RET
// every 0 0$1 trigger debug do var i ;
1318: LD_EXP 1
1322: IFFALSE 1420
1324: GO 1326
1326: DISABLE
1327: LD_INT 0
1329: PPUSH
// begin enable ;
1330: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1331: LD_ADDR_VAR 0 1
1335: PUSH
1336: LD_INT 22
1338: PUSH
1339: LD_INT 7
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 2
1348: PUSH
1349: LD_INT 21
1351: PUSH
1352: LD_INT 1
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 21
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: PUSH
1374: LD_INT 3
1376: PUSH
1377: LD_INT 24
1379: PUSH
1380: LD_INT 1000
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PUSH
1391: EMPTY
1392: LIST
1393: LIST
1394: LIST
1395: PPUSH
1396: CALL_OW 69
1400: PUSH
1401: FOR_IN
1402: IFFALSE 1418
// SetLives ( i , 1000 ) ;
1404: LD_VAR 0 1
1408: PPUSH
1409: LD_INT 1000
1411: PPUSH
1412: CALL_OW 234
1416: GO 1401
1418: POP
1419: POP
// end ;
1420: PPOPN 1
1422: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1423: LD_EXP 16
1427: PUSH
1428: LD_INT 5
1430: GREATEREQUAL
1431: IFFALSE 1443
1433: GO 1435
1435: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1436: LD_STRING ACH_ARTIFACT
1438: PPUSH
1439: CALL_OW 543
1443: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1444: LD_INT 0
1446: PPUSH
1447: PPUSH
1448: PPUSH
1449: PPUSH
1450: PPUSH
// uc_side := 7 ;
1451: LD_ADDR_OWVAR 20
1455: PUSH
1456: LD_INT 7
1458: ST_TO_ADDR
// tmp := [ ] ;
1459: LD_ADDR_VAR 0 5
1463: PUSH
1464: EMPTY
1465: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1466: LD_ADDR_EXP 19
1470: PUSH
1471: LD_STRING JMM
1473: PPUSH
1474: LD_EXP 1
1478: NOT
1479: PPUSH
1480: LD_STRING 14a_
1482: PPUSH
1483: CALL 51988 0 3
1487: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1488: LD_ADDR_EXP 51
1492: PUSH
1493: LD_STRING Burlak
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: LD_STRING 14a_
1504: PPUSH
1505: CALL 51988 0 3
1509: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1510: LD_ADDR_EXP 34
1514: PUSH
1515: LD_STRING Joan
1517: PPUSH
1518: LD_EXP 1
1522: NOT
1523: PPUSH
1524: LD_STRING 13a_
1526: PPUSH
1527: CALL 51988 0 3
1531: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1532: LD_ADDR_EXP 20
1536: PUSH
1537: LD_STRING Roth
1539: PPUSH
1540: LD_EXP 1
1544: NOT
1545: PPUSH
1546: LD_STRING 13a_
1548: PPUSH
1549: CALL 51988 0 3
1553: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1554: LD_ADDR_EXP 37
1558: PUSH
1559: LD_STRING Gossudarov
1561: PPUSH
1562: LD_EXP 1
1566: NOT
1567: PPUSH
1568: LD_STRING 13a_
1570: PPUSH
1571: CALL 51988 0 3
1575: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1576: LD_ADDR_EXP 25
1580: PUSH
1581: LD_STRING Denis
1583: PPUSH
1584: LD_EXP 1
1588: NOT
1589: PPUSH
1590: LD_STRING 13a_
1592: PPUSH
1593: CALL 51988 0 3
1597: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1598: LD_ADDR_EXP 35
1602: PUSH
1603: LD_STRING DeltaDoctor
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 13a_
1614: PPUSH
1615: CALL 51988 0 3
1619: ST_TO_ADDR
// if DeltaDoctor then
1620: LD_EXP 35
1624: IFFALSE 1642
// tmp := tmp ^ DeltaDoctor ;
1626: LD_ADDR_VAR 0 5
1630: PUSH
1631: LD_VAR 0 5
1635: PUSH
1636: LD_EXP 35
1640: ADD
1641: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1642: LD_ADDR_EXP 33
1646: PUSH
1647: LD_STRING Simms
1649: PPUSH
1650: LD_EXP 1
1654: NOT
1655: PPUSH
1656: LD_STRING 13a_
1658: PPUSH
1659: CALL 51988 0 3
1663: ST_TO_ADDR
// if Simms then
1664: LD_EXP 33
1668: IFFALSE 1686
// tmp := tmp ^ Simms ;
1670: LD_ADDR_VAR 0 5
1674: PUSH
1675: LD_VAR 0 5
1679: PUSH
1680: LD_EXP 33
1684: ADD
1685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1686: LD_ADDR_EXP 31
1690: PUSH
1691: LD_STRING Frank
1693: PPUSH
1694: LD_EXP 1
1698: NOT
1699: PPUSH
1700: LD_STRING 13a_
1702: PPUSH
1703: CALL 51988 0 3
1707: ST_TO_ADDR
// if Frank then
1708: LD_EXP 31
1712: IFFALSE 1730
// tmp := tmp ^ Frank ;
1714: LD_ADDR_VAR 0 5
1718: PUSH
1719: LD_VAR 0 5
1723: PUSH
1724: LD_EXP 31
1728: ADD
1729: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1730: LD_ADDR_EXP 38
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: LD_EXP 1
1742: NOT
1743: PPUSH
1744: LD_STRING 13a_
1746: PPUSH
1747: CALL 51988 0 3
1751: ST_TO_ADDR
// if Kirilenkova then
1752: LD_EXP 38
1756: IFFALSE 1774
// tmp := tmp ^ Kirilenkova ;
1758: LD_ADDR_VAR 0 5
1762: PUSH
1763: LD_VAR 0 5
1767: PUSH
1768: LD_EXP 38
1772: ADD
1773: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1774: LD_ADDR_EXP 39
1778: PUSH
1779: LD_STRING Titov
1781: PPUSH
1782: LD_EXP 1
1786: NOT
1787: PPUSH
1788: LD_STRING 13a_
1790: PPUSH
1791: CALL 51988 0 3
1795: ST_TO_ADDR
// if Titov then
1796: LD_EXP 39
1800: IFFALSE 1818
// tmp := tmp ^ Titov ;
1802: LD_ADDR_VAR 0 5
1806: PUSH
1807: LD_VAR 0 5
1811: PUSH
1812: LD_EXP 39
1816: ADD
1817: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1818: LD_ADDR_EXP 40
1822: PUSH
1823: LD_STRING Fadeev
1825: PPUSH
1826: LD_EXP 1
1830: NOT
1831: PPUSH
1832: LD_STRING 13a_
1834: PPUSH
1835: CALL 51988 0 3
1839: ST_TO_ADDR
// if Fadeev then
1840: LD_EXP 40
1844: IFFALSE 1862
// tmp := tmp ^ Fadeev ;
1846: LD_ADDR_VAR 0 5
1850: PUSH
1851: LD_VAR 0 5
1855: PUSH
1856: LD_EXP 40
1860: ADD
1861: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1862: LD_ADDR_EXP 41
1866: PUSH
1867: LD_STRING Dolgov
1869: PPUSH
1870: LD_EXP 1
1874: NOT
1875: PPUSH
1876: LD_STRING 13a_
1878: PPUSH
1879: CALL 51988 0 3
1883: ST_TO_ADDR
// if Dolgov then
1884: LD_EXP 41
1888: IFFALSE 1906
// tmp := tmp ^ Dolgov ;
1890: LD_ADDR_VAR 0 5
1894: PUSH
1895: LD_VAR 0 5
1899: PUSH
1900: LD_EXP 41
1904: ADD
1905: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1906: LD_ADDR_EXP 42
1910: PUSH
1911: LD_STRING Petrosyan
1913: PPUSH
1914: LD_EXP 1
1918: NOT
1919: PPUSH
1920: LD_STRING 13a_
1922: PPUSH
1923: CALL 51988 0 3
1927: ST_TO_ADDR
// if Petrosyan then
1928: LD_EXP 42
1932: IFFALSE 1950
// tmp := tmp ^ Petrosyan ;
1934: LD_ADDR_VAR 0 5
1938: PUSH
1939: LD_VAR 0 5
1943: PUSH
1944: LD_EXP 42
1948: ADD
1949: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1950: LD_ADDR_EXP 43
1954: PUSH
1955: LD_STRING Scholtze
1957: PPUSH
1958: LD_EXP 1
1962: NOT
1963: PPUSH
1964: LD_STRING 13a_
1966: PPUSH
1967: CALL 51988 0 3
1971: ST_TO_ADDR
// if Scholtze then
1972: LD_EXP 43
1976: IFFALSE 1994
// tmp := tmp ^ Scholtze ;
1978: LD_ADDR_VAR 0 5
1982: PUSH
1983: LD_VAR 0 5
1987: PUSH
1988: LD_EXP 43
1992: ADD
1993: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1994: LD_ADDR_EXP 44
1998: PUSH
1999: LD_STRING Oblukov
2001: PPUSH
2002: LD_EXP 1
2006: NOT
2007: PPUSH
2008: LD_STRING 13a_
2010: PPUSH
2011: CALL 51988 0 3
2015: ST_TO_ADDR
// if Oblukov then
2016: LD_EXP 44
2020: IFFALSE 2038
// tmp := tmp ^ Oblukov ;
2022: LD_ADDR_VAR 0 5
2026: PUSH
2027: LD_VAR 0 5
2031: PUSH
2032: LD_EXP 44
2036: ADD
2037: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2038: LD_ADDR_EXP 45
2042: PUSH
2043: LD_STRING Kapitsova
2045: PPUSH
2046: LD_EXP 1
2050: NOT
2051: PPUSH
2052: LD_STRING 13a_
2054: PPUSH
2055: CALL 51988 0 3
2059: ST_TO_ADDR
// if Kapitsova then
2060: LD_EXP 45
2064: IFFALSE 2082
// tmp := tmp ^ Kapitsova ;
2066: LD_ADDR_VAR 0 5
2070: PUSH
2071: LD_VAR 0 5
2075: PUSH
2076: LD_EXP 45
2080: ADD
2081: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2082: LD_ADDR_EXP 46
2086: PUSH
2087: LD_STRING Lipshchin
2089: PPUSH
2090: LD_EXP 1
2094: NOT
2095: PPUSH
2096: LD_STRING 13a_
2098: PPUSH
2099: CALL 51988 0 3
2103: ST_TO_ADDR
// if Lipshchin then
2104: LD_EXP 46
2108: IFFALSE 2126
// tmp := tmp ^ Lipshchin ;
2110: LD_ADDR_VAR 0 5
2114: PUSH
2115: LD_VAR 0 5
2119: PUSH
2120: LD_EXP 46
2124: ADD
2125: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2126: LD_ADDR_EXP 47
2130: PUSH
2131: LD_STRING Petrovova
2133: PPUSH
2134: LD_EXP 1
2138: NOT
2139: PPUSH
2140: LD_STRING 13a_
2142: PPUSH
2143: CALL 51988 0 3
2147: ST_TO_ADDR
// if Petrovova then
2148: LD_EXP 47
2152: IFFALSE 2170
// tmp := tmp ^ Petrovova ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 5
2163: PUSH
2164: LD_EXP 47
2168: ADD
2169: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2170: LD_ADDR_EXP 48
2174: PUSH
2175: LD_STRING Kovalyuk
2177: PPUSH
2178: LD_EXP 1
2182: NOT
2183: PPUSH
2184: LD_STRING 13a_
2186: PPUSH
2187: CALL 51988 0 3
2191: ST_TO_ADDR
// if Kovalyuk then
2192: LD_EXP 48
2196: IFFALSE 2214
// tmp := tmp ^ Kovalyuk ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_EXP 48
2212: ADD
2213: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2214: LD_ADDR_EXP 49
2218: PUSH
2219: LD_STRING Kuzmov
2221: PPUSH
2222: LD_EXP 1
2226: NOT
2227: PPUSH
2228: LD_STRING 13a_
2230: PPUSH
2231: CALL 51988 0 3
2235: ST_TO_ADDR
// if Kuzmov then
2236: LD_EXP 49
2240: IFFALSE 2258
// tmp := tmp ^ Kuzmov ;
2242: LD_ADDR_VAR 0 5
2246: PUSH
2247: LD_VAR 0 5
2251: PUSH
2252: LD_EXP 49
2256: ADD
2257: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 50
2262: PUSH
2263: LD_STRING Karamazov
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 51988 0 3
2279: ST_TO_ADDR
// if Karamazov then
2280: LD_EXP 50
2284: IFFALSE 2302
// tmp := tmp ^ Karamazov ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 50
2300: ADD
2301: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2302: LD_ADDR_EXP 52
2306: PUSH
2307: LD_STRING Belkov
2309: PPUSH
2310: LD_EXP 1
2314: NOT
2315: PPUSH
2316: LD_STRING 13a_
2318: PPUSH
2319: CALL 51988 0 3
2323: ST_TO_ADDR
// if Belkov then
2324: LD_EXP 52
2328: IFFALSE 2346
// tmp := tmp ^ Belkov ;
2330: LD_ADDR_VAR 0 5
2334: PUSH
2335: LD_VAR 0 5
2339: PUSH
2340: LD_EXP 52
2344: ADD
2345: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 53
2350: PUSH
2351: LD_STRING Gnyevko
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 51988 0 3
2367: ST_TO_ADDR
// if Gnyevko then
2368: LD_EXP 53
2372: IFFALSE 2390
// tmp := tmp ^ Gnyevko ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 53
2388: ADD
2389: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2390: LD_ADDR_EXP 36
2394: PUSH
2395: LD_STRING Coonie
2397: PPUSH
2398: CALL_OW 25
2402: ST_TO_ADDR
// if not Lisa then
2403: LD_EXP 21
2407: NOT
2408: IFFALSE 2454
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2410: LD_ADDR_EXP 21
2414: PUSH
2415: LD_STRING Lisa
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13a_
2426: PPUSH
2427: CALL 51988 0 3
2431: ST_TO_ADDR
// if Lisa then
2432: LD_EXP 21
2436: IFFALSE 2454
// tmp := tmp ^ Lisa ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 5
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: ST_TO_ADDR
// end ; if not Donaldson then
2454: LD_EXP 22
2458: NOT
2459: IFFALSE 2505
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2461: LD_ADDR_EXP 22
2465: PUSH
2466: LD_STRING Donaldson
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13a_
2477: PPUSH
2478: CALL 51988 0 3
2482: ST_TO_ADDR
// if Donaldson then
2483: LD_EXP 22
2487: IFFALSE 2505
// tmp := tmp ^ Donaldson ;
2489: LD_ADDR_VAR 0 5
2493: PUSH
2494: LD_VAR 0 5
2498: PUSH
2499: LD_EXP 22
2503: ADD
2504: ST_TO_ADDR
// end ; if not Bobby then
2505: LD_EXP 23
2509: NOT
2510: IFFALSE 2556
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2512: LD_ADDR_EXP 23
2516: PUSH
2517: LD_STRING Bobby
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13a_
2528: PPUSH
2529: CALL 51988 0 3
2533: ST_TO_ADDR
// if Bobby then
2534: LD_EXP 23
2538: IFFALSE 2556
// tmp := tmp ^ Bobby ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: LD_VAR 0 5
2549: PUSH
2550: LD_EXP 23
2554: ADD
2555: ST_TO_ADDR
// end ; if not Cyrus then
2556: LD_EXP 24
2560: NOT
2561: IFFALSE 2607
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2563: LD_ADDR_EXP 24
2567: PUSH
2568: LD_STRING Cyrus
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13a_
2579: PPUSH
2580: CALL 51988 0 3
2584: ST_TO_ADDR
// if Cyrus then
2585: LD_EXP 24
2589: IFFALSE 2607
// tmp := tmp ^ Cyrus ;
2591: LD_ADDR_VAR 0 5
2595: PUSH
2596: LD_VAR 0 5
2600: PUSH
2601: LD_EXP 24
2605: ADD
2606: ST_TO_ADDR
// end ; if not Brown then
2607: LD_EXP 26
2611: NOT
2612: IFFALSE 2658
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2614: LD_ADDR_EXP 26
2618: PUSH
2619: LD_STRING Brown
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13a_
2630: PPUSH
2631: CALL 51988 0 3
2635: ST_TO_ADDR
// if Brown then
2636: LD_EXP 26
2640: IFFALSE 2658
// tmp := tmp ^ Brown ;
2642: LD_ADDR_VAR 0 5
2646: PUSH
2647: LD_VAR 0 5
2651: PUSH
2652: LD_EXP 26
2656: ADD
2657: ST_TO_ADDR
// end ; if not Gladstone then
2658: LD_EXP 27
2662: NOT
2663: IFFALSE 2709
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2665: LD_ADDR_EXP 27
2669: PUSH
2670: LD_STRING Gladstone
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13a_
2681: PPUSH
2682: CALL 51988 0 3
2686: ST_TO_ADDR
// if Gladstone then
2687: LD_EXP 27
2691: IFFALSE 2709
// tmp := tmp ^ Gladstone ;
2693: LD_ADDR_VAR 0 5
2697: PUSH
2698: LD_VAR 0 5
2702: PUSH
2703: LD_EXP 27
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 29
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2716: LD_ADDR_EXP 29
2720: PUSH
2721: LD_STRING Cornel
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13a_
2732: PPUSH
2733: CALL 51988 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 29
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 5
2748: PUSH
2749: LD_VAR 0 5
2753: PUSH
2754: LD_EXP 29
2758: ADD
2759: ST_TO_ADDR
// end ; if not Houten then
2760: LD_EXP 28
2764: NOT
2765: IFFALSE 2811
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2767: LD_ADDR_EXP 28
2771: PUSH
2772: LD_STRING Houten
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13a_
2783: PPUSH
2784: CALL 51988 0 3
2788: ST_TO_ADDR
// if Houten then
2789: LD_EXP 28
2793: IFFALSE 2811
// tmp := tmp ^ Houten ;
2795: LD_ADDR_VAR 0 5
2799: PUSH
2800: LD_VAR 0 5
2804: PUSH
2805: LD_EXP 28
2809: ADD
2810: ST_TO_ADDR
// end ; if not Gary then
2811: LD_EXP 30
2815: NOT
2816: IFFALSE 2862
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2818: LD_ADDR_EXP 30
2822: PUSH
2823: LD_STRING Gary
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13a_
2834: PPUSH
2835: CALL 51988 0 3
2839: ST_TO_ADDR
// if Gary then
2840: LD_EXP 30
2844: IFFALSE 2862
// tmp := tmp ^ Gary ;
2846: LD_ADDR_VAR 0 5
2850: PUSH
2851: LD_VAR 0 5
2855: PUSH
2856: LD_EXP 30
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 32
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2869: LD_ADDR_EXP 32
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13a_
2885: PPUSH
2886: CALL 51988 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 32
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 5
2901: PUSH
2902: LD_VAR 0 5
2906: PUSH
2907: LD_EXP 32
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2913: LD_ADDR_VAR 0 5
2917: PUSH
2918: LD_VAR 0 5
2922: PUSH
2923: LD_STRING 13a_others
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// tmp := tmp diff 0 ;
2932: LD_ADDR_VAR 0 5
2936: PUSH
2937: LD_VAR 0 5
2941: PUSH
2942: LD_INT 0
2944: DIFF
2945: ST_TO_ADDR
// if tmp < 15 then
2946: LD_VAR 0 5
2950: PUSH
2951: LD_INT 15
2953: LESS
2954: IFFALSE 3042
// for i = 15 downto tmp do
2956: LD_ADDR_VAR 0 2
2960: PUSH
2961: DOUBLE
2962: LD_INT 15
2964: INC
2965: ST_TO_ADDR
2966: LD_VAR 0 5
2970: PUSH
2971: FOR_DOWNTO
2972: IFFALSE 3040
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2974: LD_ADDR_OWVAR 21
2978: PUSH
2979: LD_INT 1
2981: PUSH
2982: LD_INT 3
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 2
2994: PPUSH
2995: CALL_OW 12
2999: ARRAY
3000: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3001: LD_INT 0
3003: PPUSH
3004: LD_INT 1
3006: PPUSH
3007: LD_INT 4
3009: PPUSH
3010: CALL_OW 12
3014: PPUSH
3015: LD_INT 8
3017: PPUSH
3018: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3022: LD_ADDR_VAR 0 5
3026: PUSH
3027: LD_VAR 0 5
3031: PUSH
3032: CALL_OW 44
3036: ADD
3037: ST_TO_ADDR
// end ;
3038: GO 2971
3040: POP
3041: POP
// if not debug then
3042: LD_EXP 1
3046: NOT
3047: IFFALSE 3227
// selected = CharacterSelection (  , [ 15 , 14 , 13 , 12 ] [ Difficulty ] , [ 15 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3049: LD_ADDR_VAR 0 4
3053: PUSH
3054: LD_STRING 
3056: PPUSH
3057: LD_INT 15
3059: PUSH
3060: LD_INT 14
3062: PUSH
3063: LD_INT 13
3065: PUSH
3066: LD_INT 12
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_OWVAR 67
3079: ARRAY
3080: PPUSH
3081: LD_INT 15
3083: PUSH
3084: LD_INT 14
3086: PUSH
3087: LD_INT 13
3089: PUSH
3090: LD_INT 12
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: PPUSH
3105: LD_INT -5
3107: PUSH
3108: LD_EXP 19
3112: PUSH
3113: LD_EXP 51
3117: PUSH
3118: LD_EXP 20
3122: PUSH
3123: LD_EXP 34
3127: PUSH
3128: LD_EXP 25
3132: PUSH
3133: LD_EXP 37
3137: PUSH
3138: LD_INT -2
3140: PUSH
3141: LD_INT -3
3143: PUSH
3144: LD_INT -5
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: PUSH
3159: LD_VAR 0 5
3163: ADD
3164: PPUSH
3165: LD_INT 1
3167: PUSH
3168: LD_INT 4
3170: PUSH
3171: LD_INT 2
3173: PUSH
3174: LD_INT 1
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: LD_INT 5
3186: PUSH
3187: LD_INT 0
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 9
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PPUSH
3220: CALL_OW 42
3224: ST_TO_ADDR
3225: GO 3276
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3227: LD_ADDR_VAR 0 4
3231: PUSH
3232: LD_EXP 39
3236: PUSH
3237: LD_EXP 40
3241: PUSH
3242: LD_EXP 41
3246: PUSH
3247: LD_EXP 42
3251: PUSH
3252: LD_EXP 43
3256: PUSH
3257: LD_EXP 44
3261: PUSH
3262: LD_EXP 45
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3276: LD_ADDR_EXP 17
3280: PUSH
3281: LD_VAR 0 5
3285: PUSH
3286: LD_VAR 0 4
3290: DIFF
3291: ST_TO_ADDR
// uc_nation := 1 ;
3292: LD_ADDR_OWVAR 21
3296: PUSH
3297: LD_INT 1
3299: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3300: LD_INT 5
3302: PPUSH
3303: LD_INT 3
3305: PPUSH
3306: LD_INT 1
3308: PPUSH
3309: LD_INT 6
3311: PPUSH
3312: LD_INT 100
3314: PPUSH
3315: CALL 56852 0 5
// veh := CreateVehicle ;
3319: LD_ADDR_VAR 0 3
3323: PUSH
3324: CALL_OW 45
3328: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3329: LD_VAR 0 3
3333: PPUSH
3334: LD_INT 7
3336: NEG
3337: PPUSH
3338: CALL_OW 242
// SetDir ( veh , 3 ) ;
3342: LD_VAR 0 3
3346: PPUSH
3347: LD_INT 3
3349: PPUSH
3350: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3354: LD_VAR 0 3
3358: PPUSH
3359: LD_INT 31
3361: PPUSH
3362: LD_INT 0
3364: PPUSH
3365: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3369: LD_EXP 19
3373: PPUSH
3374: LD_VAR 0 3
3378: PPUSH
3379: CALL_OW 52
// if Joan then
3383: LD_EXP 34
3387: IFFALSE 3459
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3389: LD_INT 3
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: LD_INT 1
3397: PPUSH
3398: LD_INT 11
3400: PPUSH
3401: LD_INT 100
3403: PPUSH
3404: CALL 56852 0 5
// veh := CreateVehicle ;
3408: LD_ADDR_VAR 0 3
3412: PUSH
3413: CALL_OW 45
3417: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3418: LD_VAR 0 3
3422: PPUSH
3423: LD_INT 3
3425: PPUSH
3426: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3430: LD_VAR 0 3
3434: PPUSH
3435: LD_INT 30
3437: PPUSH
3438: LD_INT 0
3440: PPUSH
3441: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3445: LD_EXP 34
3449: PPUSH
3450: LD_VAR 0 3
3454: PPUSH
3455: CALL_OW 52
// end ; if Roth then
3459: LD_EXP 20
3463: IFFALSE 3535
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3465: LD_INT 3
3467: PPUSH
3468: LD_INT 3
3470: PPUSH
3471: LD_INT 1
3473: PPUSH
3474: LD_INT 11
3476: PPUSH
3477: LD_INT 100
3479: PPUSH
3480: CALL 56852 0 5
// veh := CreateVehicle ;
3484: LD_ADDR_VAR 0 3
3488: PUSH
3489: CALL_OW 45
3493: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3494: LD_VAR 0 3
3498: PPUSH
3499: LD_INT 3
3501: PPUSH
3502: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 30
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3521: LD_EXP 20
3525: PPUSH
3526: LD_VAR 0 3
3530: PPUSH
3531: CALL_OW 52
// end ; if Denis then
3535: LD_EXP 25
3539: IFFALSE 3611
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3541: LD_INT 5
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: LD_INT 1
3549: PPUSH
3550: LD_INT 9
3552: PPUSH
3553: LD_INT 100
3555: PPUSH
3556: CALL 56852 0 5
// veh := CreateVehicle ;
3560: LD_ADDR_VAR 0 3
3564: PUSH
3565: CALL_OW 45
3569: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3570: LD_VAR 0 3
3574: PPUSH
3575: LD_INT 3
3577: PPUSH
3578: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3582: LD_VAR 0 3
3586: PPUSH
3587: LD_INT 30
3589: PPUSH
3590: LD_INT 0
3592: PPUSH
3593: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3597: LD_EXP 25
3601: PPUSH
3602: LD_VAR 0 3
3606: PPUSH
3607: CALL_OW 52
// end ; uc_nation := 3 ;
3611: LD_ADDR_OWVAR 21
3615: PUSH
3616: LD_INT 3
3618: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3619: LD_INT 22
3621: PPUSH
3622: LD_INT 3
3624: PPUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 45
3630: PPUSH
3631: LD_INT 100
3633: PPUSH
3634: CALL 56852 0 5
// veh := CreateVehicle ;
3638: LD_ADDR_VAR 0 3
3642: PUSH
3643: CALL_OW 45
3647: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3648: LD_VAR 0 3
3652: PPUSH
3653: LD_INT 7
3655: NEG
3656: PPUSH
3657: CALL_OW 242
// SetDir ( veh , 3 ) ;
3661: LD_VAR 0 3
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3673: LD_VAR 0 3
3677: PPUSH
3678: LD_INT 31
3680: PPUSH
3681: LD_INT 0
3683: PPUSH
3684: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3688: LD_EXP 51
3692: PPUSH
3693: LD_VAR 0 3
3697: PPUSH
3698: CALL_OW 52
// if Gossudarov then
3702: LD_EXP 37
3706: IFFALSE 3793
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3708: LD_INT 22
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 51
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 56852 0 5
// veh := CreateVehicle ;
3727: LD_ADDR_VAR 0 3
3731: PUSH
3732: CALL_OW 45
3736: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3737: LD_VAR 0 3
3741: PPUSH
3742: LD_INT 3
3744: PPUSH
3745: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 30
3756: PPUSH
3757: LD_INT 0
3759: PPUSH
3760: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3764: LD_EXP 37
3768: PPUSH
3769: LD_VAR 0 3
3773: PPUSH
3774: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3778: LD_VAR 0 3
3782: PPUSH
3783: LD_INT 1
3785: PPUSH
3786: LD_INT 100
3788: PPUSH
3789: CALL_OW 290
// end ; for i in selected do
3793: LD_ADDR_VAR 0 2
3797: PUSH
3798: LD_VAR 0 4
3802: PUSH
3803: FOR_IN
3804: IFFALSE 4362
// begin uc_nation := GetNation ( i ) ;
3806: LD_ADDR_OWVAR 21
3810: PUSH
3811: LD_VAR 0 2
3815: PPUSH
3816: CALL_OW 248
3820: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3821: LD_VAR 0 2
3825: PUSH
3826: LD_EXP 21
3830: PUSH
3831: LD_EXP 22
3835: PUSH
3836: LD_EXP 24
3840: PUSH
3841: LD_EXP 23
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: LIST
3851: IN
3852: IFFALSE 3875
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3854: LD_INT 5
3856: PPUSH
3857: LD_INT 3
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 6
3865: PPUSH
3866: LD_INT 100
3868: PPUSH
3869: CALL 56852 0 5
3873: GO 4309
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3875: LD_VAR 0 2
3879: PUSH
3880: LD_EXP 44
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_EXP 47
3894: PUSH
3895: LD_EXP 39
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: LIST
3904: LIST
3905: IN
3906: IFFALSE 3937
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3908: LD_INT 24
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 1
3916: PPUSH
3917: LD_INT 46
3919: PPUSH
3920: LD_INT 65
3922: PPUSH
3923: LD_INT 75
3925: PPUSH
3926: CALL_OW 12
3930: PPUSH
3931: CALL 56852 0 5
3935: GO 4309
// if i = Karamazov then
3937: LD_VAR 0 2
3941: PUSH
3942: LD_EXP 50
3946: EQUAL
3947: IFFALSE 3970
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3949: LD_INT 22
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 52
3960: PPUSH
3961: LD_INT 100
3963: PPUSH
3964: CALL 56852 0 5
3968: GO 4309
// if i = Brown then
3970: LD_VAR 0 2
3974: PUSH
3975: LD_EXP 26
3979: EQUAL
3980: IFFALSE 4003
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3982: LD_INT 3
3984: PPUSH
3985: LD_INT 3
3987: PPUSH
3988: LD_INT 1
3990: PPUSH
3991: LD_INT 13
3993: PPUSH
3994: LD_INT 100
3996: PPUSH
3997: CALL 56852 0 5
4001: GO 4309
// if uc_nation = nation_american then
4003: LD_OWVAR 21
4007: PUSH
4008: LD_INT 1
4010: EQUAL
4011: IFFALSE 4162
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4013: LD_INT 3
4015: PUSH
4016: LD_INT 5
4018: PUSH
4019: LD_INT 5
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: PUSH
4027: LD_OWVAR 21
4031: PUSH
4032: LD_INT 3
4034: MOD
4035: PUSH
4036: LD_INT 1
4038: PLUS
4039: ARRAY
4040: PPUSH
4041: LD_INT 1
4043: PUSH
4044: LD_INT 3
4046: PUSH
4047: LD_INT 1
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: PUSH
4055: LD_OWVAR 21
4059: PUSH
4060: LD_INT 3
4062: MOD
4063: PUSH
4064: LD_INT 1
4066: PLUS
4067: ARRAY
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_INT 11
4074: PUSH
4075: LD_INT 4
4077: PUSH
4078: LD_INT 5
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 6
4088: PUSH
4089: LD_INT 7
4091: PUSH
4092: LD_INT 9
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 6
4102: PUSH
4103: LD_INT 9
4105: PUSH
4106: LD_INT 12
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: PUSH
4119: LD_OWVAR 21
4123: PUSH
4124: LD_INT 3
4126: MOD
4127: PUSH
4128: LD_INT 1
4130: PLUS
4131: ARRAY
4132: PUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: CALL_OW 12
4143: ARRAY
4144: PPUSH
4145: LD_INT 65
4147: PPUSH
4148: LD_INT 75
4150: PPUSH
4151: CALL_OW 12
4155: PPUSH
4156: CALL 56852 0 5
// end else
4160: GO 4309
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4162: LD_INT 22
4164: PUSH
4165: LD_INT 23
4167: PUSH
4168: LD_INT 23
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: PUSH
4176: LD_OWVAR 21
4180: PUSH
4181: LD_INT 3
4183: MOD
4184: PUSH
4185: LD_INT 1
4187: PLUS
4188: ARRAY
4189: PPUSH
4190: LD_INT 1
4192: PUSH
4193: LD_INT 3
4195: PUSH
4196: LD_INT 1
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PUSH
4204: LD_OWVAR 21
4208: PUSH
4209: LD_INT 3
4211: MOD
4212: PUSH
4213: LD_INT 1
4215: PLUS
4216: ARRAY
4217: PPUSH
4218: LD_INT 1
4220: PPUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 43
4226: PUSH
4227: LD_INT 44
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 46
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: LD_INT 44
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 46
4251: PUSH
4252: LD_INT 43
4254: PUSH
4255: LD_INT 45
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: LIST
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_OWVAR 21
4272: PUSH
4273: LD_INT 3
4275: MOD
4276: PUSH
4277: LD_INT 1
4279: PLUS
4280: ARRAY
4281: PUSH
4282: LD_INT 1
4284: PPUSH
4285: LD_INT 3
4287: PPUSH
4288: CALL_OW 12
4292: ARRAY
4293: PPUSH
4294: LD_INT 65
4296: PPUSH
4297: LD_INT 75
4299: PPUSH
4300: CALL_OW 12
4304: PPUSH
4305: CALL 56852 0 5
// end ; veh := CreateVehicle ;
4309: LD_ADDR_VAR 0 3
4313: PUSH
4314: CALL_OW 45
4318: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4319: LD_VAR 0 3
4323: PPUSH
4324: LD_INT 3
4326: PPUSH
4327: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4331: LD_VAR 0 3
4335: PPUSH
4336: LD_INT 30
4338: PPUSH
4339: LD_INT 0
4341: PPUSH
4342: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: LD_VAR 0 3
4355: PPUSH
4356: CALL_OW 52
// end ;
4360: GO 3803
4362: POP
4363: POP
// if artifactArCaptured then
4364: LD_EXP 9
4368: IFFALSE 4454
// begin uc_nation := nation_american ;
4370: LD_ADDR_OWVAR 21
4374: PUSH
4375: LD_INT 1
4377: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 3
4383: PPUSH
4384: LD_INT 3
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 100
4392: PPUSH
4393: CALL 56852 0 5
// veh := CreateVehicle ;
4397: LD_ADDR_VAR 0 3
4401: PUSH
4402: CALL_OW 45
4406: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4407: LD_VAR 0 3
4411: PPUSH
4412: LD_INT 3
4414: PPUSH
4415: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4419: LD_VAR 0 3
4423: PPUSH
4424: LD_INT 198
4426: PPUSH
4427: LD_INT 22
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4437: LD_VAR 0 3
4441: PPUSH
4442: LD_INT 4
4444: PPUSH
4445: LD_INT 50
4447: PPUSH
4448: CALL_OW 290
// end else
4452: GO 4473
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4454: LD_INT 4
4456: PPUSH
4457: LD_INT 5
4459: PPUSH
4460: LD_INT 267
4462: PPUSH
4463: LD_INT 226
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 58
// end ; uc_nation := nation_american ;
4473: LD_ADDR_OWVAR 21
4477: PUSH
4478: LD_INT 1
4480: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4481: LD_INT 3
4483: PPUSH
4484: LD_INT 3
4486: PPUSH
4487: LD_INT 3
4489: PPUSH
4490: LD_INT 12
4492: PPUSH
4493: LD_INT 100
4495: PPUSH
4496: CALL 56852 0 5
// veh := CreateVehicle ;
4500: LD_ADDR_VAR 0 3
4504: PUSH
4505: CALL_OW 45
4509: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4510: LD_VAR 0 3
4514: PPUSH
4515: LD_INT 3
4517: PPUSH
4518: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4522: LD_VAR 0 3
4526: PPUSH
4527: LD_INT 218
4529: PPUSH
4530: LD_INT 23
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4540: LD_VAR 0 3
4544: PPUSH
4545: LD_INT 4
4547: PPUSH
4548: LD_INT 30
4550: PPUSH
4551: CALL_OW 290
// uc_nation := nation_russian ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 3
4562: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4563: LD_INT 22
4565: PPUSH
4566: LD_INT 3
4568: PPUSH
4569: LD_INT 3
4571: PPUSH
4572: LD_INT 51
4574: PPUSH
4575: LD_INT 100
4577: PPUSH
4578: CALL 56852 0 5
// veh := CreateVehicle ;
4582: LD_ADDR_VAR 0 3
4586: PUSH
4587: CALL_OW 45
4591: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4592: LD_VAR 0 3
4596: PPUSH
4597: LD_INT 3
4599: PPUSH
4600: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4604: LD_VAR 0 3
4608: PPUSH
4609: LD_INT 214
4611: PPUSH
4612: LD_INT 20
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4622: LD_VAR 0 3
4626: PPUSH
4627: LD_INT 4
4629: PPUSH
4630: LD_INT 40
4632: PPUSH
4633: CALL_OW 290
// end ;
4637: LD_VAR 0 1
4641: RET
// export function AllianceSupport ; var i , veh ; begin
4642: LD_INT 0
4644: PPUSH
4645: PPUSH
4646: PPUSH
// if not allianceTeam then
4647: LD_EXP 17
4651: NOT
4652: IFFALSE 4656
// exit ;
4654: GO 5062
// for i := 1 to 6 do
4656: LD_ADDR_VAR 0 2
4660: PUSH
4661: DOUBLE
4662: LD_INT 1
4664: DEC
4665: ST_TO_ADDR
4666: LD_INT 6
4668: PUSH
4669: FOR_TO
4670: IFFALSE 4966
// begin uc_side := 7 ;
4672: LD_ADDR_OWVAR 20
4676: PUSH
4677: LD_INT 7
4679: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4680: LD_ADDR_OWVAR 21
4684: PUSH
4685: LD_INT 1
4687: PUSH
4688: LD_INT 3
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PUSH
4695: LD_VAR 0 2
4699: PUSH
4700: LD_INT 2
4702: MOD
4703: PUSH
4704: LD_INT 1
4706: PLUS
4707: ARRAY
4708: ST_TO_ADDR
// if uc_nation = 1 then
4709: LD_OWVAR 21
4713: PUSH
4714: LD_INT 1
4716: EQUAL
4717: IFFALSE 4759
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4719: LD_INT 5
4721: PPUSH
4722: LD_INT 3
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 7
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: LD_INT 1
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 12
4748: ARRAY
4749: PPUSH
4750: LD_INT 100
4752: PPUSH
4753: CALL 56852 0 5
4757: GO 4797
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4759: LD_INT 23
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 1
4767: PPUSH
4768: LD_INT 46
4770: PUSH
4771: LD_INT 47
4773: PUSH
4774: EMPTY
4775: LIST
4776: LIST
4777: PUSH
4778: LD_INT 1
4780: PPUSH
4781: LD_INT 2
4783: PPUSH
4784: CALL_OW 12
4788: ARRAY
4789: PPUSH
4790: LD_INT 100
4792: PPUSH
4793: CALL 56852 0 5
// if not allianceTeam then
4797: LD_EXP 17
4801: NOT
4802: IFFALSE 4806
// break ;
4804: GO 4966
// veh := CreateVehicle ;
4806: LD_ADDR_VAR 0 3
4810: PUSH
4811: CALL_OW 45
4815: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4816: LD_VAR 0 3
4820: PPUSH
4821: LD_INT 4
4823: PPUSH
4824: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 38
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4843: LD_EXP 17
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 3
4854: PPUSH
4855: CALL_OW 259
4859: PUSH
4860: LD_INT 4
4862: GREATER
4863: IFFALSE 4881
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4865: LD_EXP 17
4869: PUSH
4870: LD_INT 1
4872: ARRAY
4873: PPUSH
4874: LD_INT 3
4876: PPUSH
4877: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4881: LD_EXP 17
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 259
4897: PUSH
4898: LD_INT 8
4900: GREATER
4901: IFFALSE 4919
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4903: LD_EXP 17
4907: PUSH
4908: LD_INT 1
4910: ARRAY
4911: PPUSH
4912: LD_INT 4
4914: PPUSH
4915: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4919: LD_EXP 17
4923: PUSH
4924: LD_INT 1
4926: ARRAY
4927: PPUSH
4928: LD_VAR 0 3
4932: PPUSH
4933: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4937: LD_ADDR_EXP 17
4941: PUSH
4942: LD_EXP 17
4946: PPUSH
4947: LD_INT 1
4949: PPUSH
4950: CALL_OW 3
4954: ST_TO_ADDR
// ComHold ( veh ) ;
4955: LD_VAR 0 3
4959: PPUSH
4960: CALL_OW 140
// end ;
4964: GO 4669
4966: POP
4967: POP
// uc_side := 7 ;
4968: LD_ADDR_OWVAR 20
4972: PUSH
4973: LD_INT 7
4975: ST_TO_ADDR
// uc_nation := 1 ;
4976: LD_ADDR_OWVAR 21
4980: PUSH
4981: LD_INT 1
4983: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
4984: LD_INT 5
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 3
4992: PPUSH
4993: LD_INT 11
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 56852 0 5
// veh := CreateVehicle ;
5003: LD_ADDR_VAR 0 3
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5013: LD_VAR 0 3
5017: PPUSH
5018: LD_INT 4
5020: PPUSH
5021: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5025: LD_VAR 0 3
5029: PPUSH
5030: LD_INT 305
5032: PPUSH
5033: LD_INT 218
5035: PPUSH
5036: LD_INT 0
5038: PPUSH
5039: CALL_OW 48
// ComHold ( veh ) ;
5043: LD_VAR 0 3
5047: PPUSH
5048: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5052: LD_INT 313
5054: PPUSH
5055: LD_INT 220
5057: PPUSH
5058: CALL_OW 86
// end ; end_of_file
5062: LD_VAR 0 1
5066: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
5072: PPUSH
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
// InitHc ;
5079: CALL_OW 19
// uc_side := 1 ;
5083: LD_ADDR_OWVAR 20
5087: PUSH
5088: LD_INT 1
5090: ST_TO_ADDR
// uc_nation := 1 ;
5091: LD_ADDR_OWVAR 21
5095: PUSH
5096: LD_INT 1
5098: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5099: LD_ADDR_VAR 0 2
5103: PUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 1
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: FOR_IN
5134: IFFALSE 5150
// SetBLevel ( i , 10 ) ;
5136: LD_VAR 0 2
5140: PPUSH
5141: LD_INT 10
5143: PPUSH
5144: CALL_OW 241
5148: GO 5133
5150: POP
5151: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5152: LD_INT 387
5154: PPUSH
5155: CALL_OW 274
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: LD_INT 7500
5165: PPUSH
5166: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5170: LD_INT 387
5172: PPUSH
5173: CALL_OW 274
5177: PPUSH
5178: LD_INT 2
5180: PPUSH
5181: LD_INT 4000
5183: PPUSH
5184: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5188: LD_INT 387
5190: PPUSH
5191: CALL_OW 274
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 50
5201: PPUSH
5202: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5206: LD_INT 476
5208: PPUSH
5209: CALL_OW 274
5213: PPUSH
5214: LD_INT 1
5216: PPUSH
5217: LD_INT 5500
5219: PPUSH
5220: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5224: LD_INT 476
5226: PPUSH
5227: CALL_OW 274
5231: PPUSH
5232: LD_INT 2
5234: PPUSH
5235: LD_INT 4000
5237: PPUSH
5238: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5242: LD_INT 476
5244: PPUSH
5245: CALL_OW 274
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: LD_INT 10
5255: PPUSH
5256: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5260: LD_ADDR_EXP 54
5264: PUSH
5265: LD_STRING Powell
5267: PPUSH
5268: CALL_OW 25
5272: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5273: LD_EXP 54
5277: PPUSH
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 52
// tmp := [ ] ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: EMPTY
5291: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5292: LD_ADDR_EXP 21
5296: PUSH
5297: LD_STRING Lisa
5299: PPUSH
5300: LD_EXP 1
5304: NOT
5305: PPUSH
5306: LD_STRING 12p_
5308: PPUSH
5309: CALL 51988 0 3
5313: ST_TO_ADDR
// if Lisa then
5314: LD_EXP 21
5318: IFFALSE 5336
// tmp := tmp ^ Lisa ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: LD_VAR 0 6
5329: PUSH
5330: LD_EXP 21
5334: ADD
5335: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5336: LD_ADDR_EXP 22
5340: PUSH
5341: LD_STRING Donaldson
5343: PPUSH
5344: LD_EXP 1
5348: NOT
5349: PPUSH
5350: LD_STRING 12p_
5352: PPUSH
5353: CALL 51988 0 3
5357: ST_TO_ADDR
// if Donaldson then
5358: LD_EXP 22
5362: IFFALSE 5380
// tmp := tmp ^ Donaldson ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: LD_EXP 22
5378: ADD
5379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5380: LD_ADDR_EXP 23
5384: PUSH
5385: LD_STRING Bobby
5387: PPUSH
5388: LD_EXP 1
5392: NOT
5393: PPUSH
5394: LD_STRING 12p_
5396: PPUSH
5397: CALL 51988 0 3
5401: ST_TO_ADDR
// if Bobby then
5402: LD_EXP 23
5406: IFFALSE 5424
// tmp := tmp ^ Bobby ;
5408: LD_ADDR_VAR 0 6
5412: PUSH
5413: LD_VAR 0 6
5417: PUSH
5418: LD_EXP 23
5422: ADD
5423: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5424: LD_ADDR_EXP 24
5428: PUSH
5429: LD_STRING Cyrus
5431: PPUSH
5432: LD_EXP 1
5436: NOT
5437: PPUSH
5438: LD_STRING 12p_
5440: PPUSH
5441: CALL 51988 0 3
5445: ST_TO_ADDR
// if Cyrus then
5446: LD_EXP 24
5450: IFFALSE 5468
// tmp := tmp ^ Cyrus ;
5452: LD_ADDR_VAR 0 6
5456: PUSH
5457: LD_VAR 0 6
5461: PUSH
5462: LD_EXP 24
5466: ADD
5467: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5468: LD_ADDR_EXP 26
5472: PUSH
5473: LD_STRING Brown
5475: PPUSH
5476: LD_EXP 1
5480: NOT
5481: PPUSH
5482: LD_STRING 12p_
5484: PPUSH
5485: CALL 51988 0 3
5489: ST_TO_ADDR
// if Brown then
5490: LD_EXP 26
5494: IFFALSE 5512
// tmp := tmp ^ Brown ;
5496: LD_ADDR_VAR 0 6
5500: PUSH
5501: LD_VAR 0 6
5505: PUSH
5506: LD_EXP 26
5510: ADD
5511: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5512: LD_ADDR_EXP 27
5516: PUSH
5517: LD_STRING Gladstone
5519: PPUSH
5520: LD_EXP 1
5524: NOT
5525: PPUSH
5526: LD_STRING 12p_
5528: PPUSH
5529: CALL 51988 0 3
5533: ST_TO_ADDR
// if Gladstone then
5534: LD_EXP 27
5538: IFFALSE 5556
// tmp := tmp ^ Gladstone ;
5540: LD_ADDR_VAR 0 6
5544: PUSH
5545: LD_VAR 0 6
5549: PUSH
5550: LD_EXP 27
5554: ADD
5555: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5556: LD_ADDR_EXP 28
5560: PUSH
5561: LD_STRING Houten
5563: PPUSH
5564: LD_EXP 1
5568: NOT
5569: PPUSH
5570: LD_STRING 12p_
5572: PPUSH
5573: CALL 51988 0 3
5577: ST_TO_ADDR
// if Houten then
5578: LD_EXP 28
5582: IFFALSE 5600
// tmp := tmp ^ Houten ;
5584: LD_ADDR_VAR 0 6
5588: PUSH
5589: LD_VAR 0 6
5593: PUSH
5594: LD_EXP 28
5598: ADD
5599: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5600: LD_ADDR_EXP 29
5604: PUSH
5605: LD_STRING Cornel
5607: PPUSH
5608: LD_EXP 1
5612: NOT
5613: PPUSH
5614: LD_STRING 12p_
5616: PPUSH
5617: CALL 51988 0 3
5621: ST_TO_ADDR
// if Cornel then
5622: LD_EXP 29
5626: IFFALSE 5644
// tmp := tmp ^ Cornel ;
5628: LD_ADDR_VAR 0 6
5632: PUSH
5633: LD_VAR 0 6
5637: PUSH
5638: LD_EXP 29
5642: ADD
5643: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5644: LD_ADDR_EXP 30
5648: PUSH
5649: LD_STRING Gary
5651: PPUSH
5652: LD_EXP 1
5656: NOT
5657: PPUSH
5658: LD_STRING 12p_
5660: PPUSH
5661: CALL 51988 0 3
5665: ST_TO_ADDR
// if Gary then
5666: LD_EXP 30
5670: IFFALSE 5688
// tmp := tmp ^ Gary ;
5672: LD_ADDR_VAR 0 6
5676: PUSH
5677: LD_VAR 0 6
5681: PUSH
5682: LD_EXP 30
5686: ADD
5687: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5688: LD_ADDR_EXP 32
5692: PUSH
5693: LD_STRING Kikuchi
5695: PPUSH
5696: LD_EXP 1
5700: NOT
5701: PPUSH
5702: LD_STRING 12p_
5704: PPUSH
5705: CALL 51988 0 3
5709: ST_TO_ADDR
// if Kikuchi then
5710: LD_EXP 32
5714: IFFALSE 5732
// tmp := tmp ^ Kikuchi ;
5716: LD_ADDR_VAR 0 6
5720: PUSH
5721: LD_VAR 0 6
5725: PUSH
5726: LD_EXP 32
5730: ADD
5731: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5732: LD_ADDR_VAR 0 6
5736: PUSH
5737: LD_VAR 0 6
5741: PUSH
5742: LD_STRING 12p_others
5744: PPUSH
5745: CALL_OW 31
5749: UNION
5750: ST_TO_ADDR
// if tmp < 36 then
5751: LD_VAR 0 6
5755: PUSH
5756: LD_INT 36
5758: LESS
5759: IFFALSE 5826
// for i = 1 to 36 - tmp do
5761: LD_ADDR_VAR 0 2
5765: PUSH
5766: DOUBLE
5767: LD_INT 1
5769: DEC
5770: ST_TO_ADDR
5771: LD_INT 36
5773: PUSH
5774: LD_VAR 0 6
5778: MINUS
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5824
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5783: LD_INT 1
5785: PPUSH
5786: LD_VAR 0 2
5790: PUSH
5791: LD_INT 4
5793: MOD
5794: PUSH
5795: LD_INT 1
5797: PLUS
5798: PPUSH
5799: LD_INT 10
5801: PPUSH
5802: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5806: LD_ADDR_VAR 0 6
5810: PUSH
5811: LD_VAR 0 6
5815: PUSH
5816: CALL_OW 44
5820: ADD
5821: ST_TO_ADDR
// end ;
5822: GO 5780
5824: POP
5825: POP
// for i in tmp do
5826: LD_ADDR_VAR 0 2
5830: PUSH
5831: LD_VAR 0 6
5835: PUSH
5836: FOR_IN
5837: IFFALSE 5862
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5839: LD_VAR 0 2
5843: PPUSH
5844: LD_INT 62
5846: PPUSH
5847: LD_INT 93
5849: PPUSH
5850: LD_INT 9
5852: PPUSH
5853: LD_INT 0
5855: PPUSH
5856: CALL_OW 50
5860: GO 5836
5862: POP
5863: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5864: LD_ADDR_EXP 95
5868: PUSH
5869: LD_EXP 95
5873: PPUSH
5874: LD_INT 4
5876: PPUSH
5877: LD_INT 22
5879: PUSH
5880: LD_INT 1
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: PPUSH
5887: CALL_OW 69
5891: PUSH
5892: LD_EXP 54
5896: DIFF
5897: PPUSH
5898: CALL_OW 1
5902: ST_TO_ADDR
// uc_side := 0 ;
5903: LD_ADDR_OWVAR 20
5907: PUSH
5908: LD_INT 0
5910: ST_TO_ADDR
// uc_nation := 0 ;
5911: LD_ADDR_OWVAR 21
5915: PUSH
5916: LD_INT 0
5918: ST_TO_ADDR
// for i = 1 to 4 do
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: DOUBLE
5925: LD_INT 1
5927: DEC
5928: ST_TO_ADDR
5929: LD_INT 4
5931: PUSH
5932: FOR_TO
5933: IFFALSE 5964
// begin InitHc ;
5935: CALL_OW 19
// hc_class := class_apeman ;
5939: LD_ADDR_OWVAR 28
5943: PUSH
5944: LD_INT 12
5946: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5947: CALL_OW 44
5951: PPUSH
5952: LD_INT 11
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// end ;
5962: GO 5932
5964: POP
5965: POP
// end ;
5966: LD_VAR 0 1
5970: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5971: LD_EXP 4
5975: NOT
5976: PUSH
5977: LD_INT 4
5979: PPUSH
5980: LD_INT 1
5982: PPUSH
5983: CALL 47000 0 2
5987: NOT
5988: AND
5989: IFFALSE 6761
5991: GO 5993
5993: DISABLE
5994: LD_INT 0
5996: PPUSH
5997: PPUSH
5998: PPUSH
// begin enable ;
5999: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6000: LD_INT 22
6002: PUSH
6003: LD_INT 1
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PUSH
6010: LD_INT 23
6012: PUSH
6013: LD_INT 1
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 30
6022: PUSH
6023: LD_INT 3
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: PPUSH
6035: CALL_OW 69
6039: NOT
6040: IFFALSE 6044
// exit ;
6042: GO 6761
// if Prob ( 40 ) then
6044: LD_INT 40
6046: PPUSH
6047: CALL_OW 13
6051: IFFALSE 6178
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6053: LD_INT 4
6055: PPUSH
6056: LD_INT 5
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: LD_INT 2
6064: PUSH
6065: LD_INT 7
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: PUSH
6074: LD_INT 5
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: LD_INT 2
6082: PUSH
6083: LD_INT 7
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 5
6094: PUSH
6095: LD_INT 1
6097: PUSH
6098: LD_INT 2
6100: PUSH
6101: LD_INT 7
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 5
6112: PUSH
6113: LD_INT 1
6115: PUSH
6116: LD_INT 2
6118: PUSH
6119: LD_INT 6
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 5
6130: PUSH
6131: LD_INT 1
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: LD_INT 6
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: LD_INT 1
6151: PUSH
6152: LD_INT 2
6154: PUSH
6155: LD_INT 6
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: PPUSH
6172: CALL 45582 0 2
// end else
6176: GO 6301
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6178: LD_INT 4
6180: PPUSH
6181: LD_INT 5
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 7
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 5
6201: PUSH
6202: LD_INT 1
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 9
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: PUSH
6217: LD_INT 5
6219: PUSH
6220: LD_INT 1
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: LD_INT 9
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 5
6237: PUSH
6238: LD_INT 1
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: LD_INT 6
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: PUSH
6253: LD_INT 5
6255: PUSH
6256: LD_INT 1
6258: PUSH
6259: LD_INT 2
6261: PUSH
6262: LD_INT 6
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: PUSH
6271: LD_INT 5
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: LD_INT 2
6279: PUSH
6280: LD_INT 6
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL 45582 0 2
// end ; repeat wait ( 0 0$1 ) ;
6301: LD_INT 35
6303: PPUSH
6304: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6308: LD_INT 4
6310: PPUSH
6311: LD_INT 1
6313: PPUSH
6314: CALL 47000 0 2
6318: PUSH
6319: LD_INT 6
6321: GREATEREQUAL
6322: IFFALSE 6301
// wait ( 0 0$30 ) ;
6324: LD_INT 1050
6326: PPUSH
6327: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6331: LD_ADDR_VAR 0 2
6335: PUSH
6336: LD_INT 4
6338: PPUSH
6339: LD_INT 1
6341: PPUSH
6342: CALL 47000 0 2
6346: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6347: LD_ADDR_EXP 114
6351: PUSH
6352: LD_EXP 114
6356: PPUSH
6357: LD_INT 4
6359: PPUSH
6360: LD_EXP 114
6364: PUSH
6365: LD_INT 4
6367: ARRAY
6368: PUSH
6369: LD_VAR 0 2
6373: DIFF
6374: PPUSH
6375: CALL_OW 1
6379: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6380: LD_ADDR_VAR 0 3
6384: PUSH
6385: LD_INT 0
6387: PPUSH
6388: LD_INT 2
6390: PPUSH
6391: CALL_OW 12
6395: ST_TO_ADDR
// if target then
6396: LD_VAR 0 3
6400: IFFALSE 6528
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6402: LD_ADDR_VAR 0 2
6406: PUSH
6407: LD_VAR 0 2
6411: PPUSH
6412: LD_INT 24
6414: PUSH
6415: LD_INT 250
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PPUSH
6422: CALL_OW 72
6426: ST_TO_ADDR
// for i in tmp do
6427: LD_ADDR_VAR 0 1
6431: PUSH
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_IN
6438: IFFALSE 6478
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 114
6447: PPUSH
6448: LD_INT 108
6450: PPUSH
6451: CALL_OW 297
6455: PUSH
6456: LD_INT 9
6458: GREATER
6459: IFFALSE 6476
// ComMoveXY ( i , 114 , 108 ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: LD_INT 114
6468: PPUSH
6469: LD_INT 108
6471: PPUSH
6472: CALL_OW 111
6476: GO 6437
6478: POP
6479: POP
// wait ( 0 0$1 ) ;
6480: LD_INT 35
6482: PPUSH
6483: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 92
6494: PUSH
6495: LD_INT 114
6497: PUSH
6498: LD_INT 108
6500: PUSH
6501: LD_INT 9
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 72
6514: PUSH
6515: LD_VAR 0 2
6519: PUSH
6520: LD_INT 1
6522: MINUS
6523: GREATEREQUAL
6524: IFFALSE 6402
// end else
6526: GO 6652
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6528: LD_ADDR_VAR 0 2
6532: PUSH
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 250
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PPUSH
6548: CALL_OW 72
6552: ST_TO_ADDR
// for i in tmp do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: LD_VAR 0 2
6562: PUSH
6563: FOR_IN
6564: IFFALSE 6604
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6566: LD_VAR 0 1
6570: PPUSH
6571: LD_INT 129
6573: PPUSH
6574: LD_INT 139
6576: PPUSH
6577: CALL_OW 297
6581: PUSH
6582: LD_INT 9
6584: GREATER
6585: IFFALSE 6602
// ComMoveXY ( i , 129 , 139 ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: LD_INT 129
6594: PPUSH
6595: LD_INT 139
6597: PPUSH
6598: CALL_OW 111
6602: GO 6563
6604: POP
6605: POP
// wait ( 0 0$1 ) ;
6606: LD_INT 35
6608: PPUSH
6609: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6613: LD_VAR 0 2
6617: PPUSH
6618: LD_INT 92
6620: PUSH
6621: LD_INT 129
6623: PUSH
6624: LD_INT 139
6626: PUSH
6627: LD_INT 9
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 72
6640: PUSH
6641: LD_VAR 0 2
6645: PUSH
6646: LD_INT 1
6648: MINUS
6649: GREATEREQUAL
6650: IFFALSE 6528
// end ; repeat wait ( 0 0$1 ) ;
6652: LD_INT 35
6654: PPUSH
6655: CALL_OW 67
// for i in tmp do
6659: LD_ADDR_VAR 0 1
6663: PUSH
6664: LD_VAR 0 2
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6752
// begin if GetLives ( i ) > 251 then
6672: LD_VAR 0 1
6676: PPUSH
6677: CALL_OW 256
6681: PUSH
6682: LD_INT 251
6684: GREATER
6685: IFFALSE 6723
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6687: LD_VAR 0 1
6691: PPUSH
6692: LD_INT 81
6694: PUSH
6695: LD_INT 1
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: PPUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 74
6716: PPUSH
6717: CALL_OW 115
6721: GO 6750
// if IsDead ( i ) then
6723: LD_VAR 0 1
6727: PPUSH
6728: CALL_OW 301
6732: IFFALSE 6750
// tmp := tmp diff i ;
6734: LD_ADDR_VAR 0 2
6738: PUSH
6739: LD_VAR 0 2
6743: PUSH
6744: LD_VAR 0 1
6748: DIFF
6749: ST_TO_ADDR
// end ;
6750: GO 6669
6752: POP
6753: POP
// until not tmp ;
6754: LD_VAR 0 2
6758: NOT
6759: IFFALSE 6652
// end ;
6761: PPOPN 3
6763: END
// every 30 30$00 trigger not americanDestroyed do
6764: LD_EXP 4
6768: NOT
6769: IFFALSE 6838
6771: GO 6773
6773: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6774: LD_INT 63000
6776: PUSH
6777: LD_INT 42000
6779: PUSH
6780: LD_INT 31500
6782: PUSH
6783: LD_INT 21000
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: LD_OWVAR 67
6796: ARRAY
6797: PPUSH
6798: CALL_OW 67
// if americanDestroyed then
6802: LD_EXP 4
6806: IFFALSE 6810
// exit ;
6808: GO 6838
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6810: LD_INT 4
6812: PPUSH
6813: LD_INT 5
6815: PUSH
6816: LD_INT 3
6818: PUSH
6819: LD_INT 1
6821: PUSH
6822: LD_INT 8
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: EMPTY
6832: LIST
6833: PPUSH
6834: CALL 45582 0 2
// end ; end_of_file
6838: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6839: LD_INT 0
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
// side := 2 ;
6846: LD_ADDR_VAR 0 5
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// InitHc ;
6854: CALL_OW 19
// uc_side := side ;
6858: LD_ADDR_OWVAR 20
6862: PUSH
6863: LD_VAR 0 5
6867: ST_TO_ADDR
// uc_nation := 2 ;
6868: LD_ADDR_OWVAR 21
6872: PUSH
6873: LD_INT 2
6875: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6876: LD_ADDR_VAR 0 2
6880: PUSH
6881: LD_INT 22
6883: PUSH
6884: LD_INT 2
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: LD_INT 21
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: PPUSH
6905: CALL_OW 69
6909: PUSH
6910: FOR_IN
6911: IFFALSE 6927
// SetBLevel ( i , 10 ) ;
6913: LD_VAR 0 2
6917: PPUSH
6918: LD_INT 10
6920: PPUSH
6921: CALL_OW 241
6925: GO 6910
6927: POP
6928: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6929: LD_ADDR_VAR 0 4
6933: PUSH
6934: LD_INT 22
6936: PUSH
6937: LD_VAR 0 5
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 30
6948: PUSH
6949: LD_INT 32
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: LD_INT 58
6958: PUSH
6959: EMPTY
6960: LIST
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: ST_TO_ADDR
// for i = 1 to 10 do
6972: LD_ADDR_VAR 0 2
6976: PUSH
6977: DOUBLE
6978: LD_INT 1
6980: DEC
6981: ST_TO_ADDR
6982: LD_INT 10
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7058
// begin uc_nation := nation_nature ;
6988: LD_ADDR_OWVAR 21
6992: PUSH
6993: LD_INT 0
6995: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6996: LD_ADDR_OWVAR 28
7000: PUSH
7001: LD_INT 15
7003: ST_TO_ADDR
// hc_gallery :=  ;
7004: LD_ADDR_OWVAR 33
7008: PUSH
7009: LD_STRING 
7011: ST_TO_ADDR
// hc_name :=  ;
7012: LD_ADDR_OWVAR 26
7016: PUSH
7017: LD_STRING 
7019: ST_TO_ADDR
// un := CreateHuman ;
7020: LD_ADDR_VAR 0 3
7024: PUSH
7025: CALL_OW 44
7029: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7030: LD_VAR 0 3
7034: PPUSH
7035: LD_VAR 0 4
7039: PUSH
7040: LD_VAR 0 4
7044: PUSH
7045: LD_VAR 0 2
7049: MINUS
7050: ARRAY
7051: PPUSH
7052: CALL_OW 52
// end ;
7056: GO 6985
7058: POP
7059: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7060: LD_INT 503
7062: PPUSH
7063: LD_INT 27
7065: PPUSH
7066: LD_STRING 
7068: PPUSH
7069: LD_INT 8
7071: PUSH
7072: LD_INT 9
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 10
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_OWVAR 67
7091: ARRAY
7092: PPUSH
7093: LD_INT 3000
7095: PUSH
7096: LD_INT 500
7098: PUSH
7099: LD_INT 150
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: LIST
7106: PPUSH
7107: LD_INT 16
7109: PUSH
7110: LD_INT 6
7112: PUSH
7113: LD_INT 6
7115: PUSH
7116: LD_INT 6
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL 60298 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7129: LD_ADDR_EXP 95
7133: PUSH
7134: LD_EXP 95
7138: PPUSH
7139: LD_INT 1
7141: PPUSH
7142: LD_INT 22
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: LD_INT 23
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 3
7166: PUSH
7167: LD_INT 21
7169: PUSH
7170: LD_INT 2
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: CALL_OW 69
7190: PPUSH
7191: CALL_OW 1
7195: ST_TO_ADDR
// end ;
7196: LD_VAR 0 1
7200: RET
// export Omar ; export function PrepareOmarAli ; begin
7201: LD_INT 0
7203: PPUSH
// uc_side := 5 ;
7204: LD_ADDR_OWVAR 20
7208: PUSH
7209: LD_INT 5
7211: ST_TO_ADDR
// uc_nation := 2 ;
7212: LD_ADDR_OWVAR 21
7216: PUSH
7217: LD_INT 2
7219: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7220: LD_ADDR_EXP 55
7224: PUSH
7225: LD_STRING Omar
7227: PPUSH
7228: CALL_OW 25
7232: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7233: LD_EXP 55
7237: PPUSH
7238: LD_INT 330
7240: PPUSH
7241: LD_INT 244
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7251: LD_EXP 55
7255: PPUSH
7256: LD_INT 252
7258: PPUSH
7259: LD_INT 220
7261: PPUSH
7262: CALL_OW 111
// end ; end_of_file
7266: LD_VAR 0 1
7270: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7271: LD_INT 0
7273: PPUSH
7274: PPUSH
7275: PPUSH
7276: PPUSH
7277: PPUSH
// side := 8 ;
7278: LD_ADDR_VAR 0 3
7282: PUSH
7283: LD_INT 8
7285: ST_TO_ADDR
// InitHc ;
7286: CALL_OW 19
// uc_side := side ;
7290: LD_ADDR_OWVAR 20
7294: PUSH
7295: LD_VAR 0 3
7299: ST_TO_ADDR
// uc_nation := 2 ;
7300: LD_ADDR_OWVAR 21
7304: PUSH
7305: LD_INT 2
7307: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7308: LD_ADDR_VAR 0 2
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_VAR 0 3
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 3
7330: PUSH
7331: EMPTY
7332: LIST
7333: LIST
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PPUSH
7339: CALL_OW 69
7343: PUSH
7344: FOR_IN
7345: IFFALSE 7361
// SetBLevel ( i , 10 ) ;
7347: LD_VAR 0 2
7351: PPUSH
7352: LD_INT 10
7354: PPUSH
7355: CALL_OW 241
7359: GO 7344
7361: POP
7362: POP
// Schulz := NewCharacter ( Schulz ) ;
7363: LD_ADDR_EXP 56
7367: PUSH
7368: LD_STRING Schulz
7370: PPUSH
7371: CALL_OW 25
7375: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7376: LD_ADDR_EXP 57
7380: PUSH
7381: LD_STRING Kozlov
7383: PPUSH
7384: LD_INT 0
7386: PPUSH
7387: LD_STRING 
7389: PPUSH
7390: CALL 51988 0 3
7394: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7395: LD_EXP 57
7399: PPUSH
7400: LD_INT 22
7402: PUSH
7403: LD_INT 8
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: LD_INT 23
7412: PUSH
7413: LD_INT 3
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 30
7422: PUSH
7423: LD_INT 8
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: LIST
7434: PPUSH
7435: CALL_OW 69
7439: PUSH
7440: LD_INT 1
7442: ARRAY
7443: PPUSH
7444: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7448: LD_EXP 57
7452: PPUSH
7453: LD_INT 3
7455: PPUSH
7456: LD_INT 10
7458: PPUSH
7459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7463: LD_ADDR_VAR 0 5
7467: PUSH
7468: LD_INT 22
7470: PUSH
7471: LD_VAR 0 3
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 30
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 58
7492: PUSH
7493: EMPTY
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: PPUSH
7501: CALL_OW 69
7505: ST_TO_ADDR
// for i = 1 to 10 do
7506: LD_ADDR_VAR 0 2
7510: PUSH
7511: DOUBLE
7512: LD_INT 1
7514: DEC
7515: ST_TO_ADDR
7516: LD_INT 10
7518: PUSH
7519: FOR_TO
7520: IFFALSE 7592
// begin uc_nation := nation_nature ;
7522: LD_ADDR_OWVAR 21
7526: PUSH
7527: LD_INT 0
7529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7530: LD_ADDR_OWVAR 28
7534: PUSH
7535: LD_INT 15
7537: ST_TO_ADDR
// hc_gallery :=  ;
7538: LD_ADDR_OWVAR 33
7542: PUSH
7543: LD_STRING 
7545: ST_TO_ADDR
// hc_name :=  ;
7546: LD_ADDR_OWVAR 26
7550: PUSH
7551: LD_STRING 
7553: ST_TO_ADDR
// un := CreateHuman ;
7554: LD_ADDR_VAR 0 4
7558: PUSH
7559: CALL_OW 44
7563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7564: LD_VAR 0 4
7568: PPUSH
7569: LD_VAR 0 5
7573: PUSH
7574: LD_VAR 0 5
7578: PUSH
7579: LD_VAR 0 2
7583: MINUS
7584: ARRAY
7585: PPUSH
7586: CALL_OW 52
// end ;
7590: GO 7519
7592: POP
7593: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7594: LD_INT 324
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_STRING 
7602: PPUSH
7603: LD_INT 8
7605: PUSH
7606: LD_INT 9
7608: PUSH
7609: LD_INT 10
7611: PUSH
7612: LD_INT 10
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: LD_OWVAR 67
7625: ARRAY
7626: PPUSH
7627: LD_INT 3000
7629: PUSH
7630: LD_INT 500
7632: PUSH
7633: LD_INT 150
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: LIST
7640: PPUSH
7641: LD_INT 16
7643: PUSH
7644: LD_INT 6
7646: PUSH
7647: LD_INT 6
7649: PUSH
7650: LD_INT 8
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PPUSH
7659: CALL 60298 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7663: LD_ADDR_EXP 95
7667: PUSH
7668: LD_EXP 95
7672: PPUSH
7673: LD_INT 3
7675: PPUSH
7676: LD_INT 22
7678: PUSH
7679: LD_VAR 0 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 23
7690: PUSH
7691: LD_INT 2
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 21
7703: PUSH
7704: LD_INT 2
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: PUSH
7725: LD_EXP 56
7729: DIFF
7730: PPUSH
7731: CALL_OW 1
7735: ST_TO_ADDR
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildKozlovBomb ; begin
7741: LD_INT 0
7743: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7744: LD_INT 332
7746: PPUSH
7747: CALL_OW 302
7751: NOT
7752: PUSH
7753: LD_INT 336
7755: PPUSH
7756: CALL_OW 302
7760: NOT
7761: OR
7762: IFFALSE 7766
// exit ;
7764: GO 7863
// ComChangeProfession ( Kozlov , 4 ) ;
7766: LD_EXP 57
7770: PPUSH
7771: LD_INT 4
7773: PPUSH
7774: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7778: LD_INT 336
7780: PPUSH
7781: LD_INT 25
7783: PPUSH
7784: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7788: LD_INT 35
7790: PPUSH
7791: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7795: LD_INT 25
7797: PPUSH
7798: LD_INT 8
7800: PPUSH
7801: CALL_OW 321
7805: PUSH
7806: LD_INT 2
7808: EQUAL
7809: IFFALSE 7788
// ComExitBuilding ( Kozlov ) ;
7811: LD_EXP 57
7815: PPUSH
7816: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7820: LD_EXP 57
7824: PPUSH
7825: LD_INT 332
7827: PPUSH
7828: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7832: LD_EXP 57
7836: PPUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7844: LD_INT 332
7846: PPUSH
7847: LD_INT 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_INT 1
7855: PPUSH
7856: LD_INT 48
7858: PPUSH
7859: CALL_OW 125
// end ;
7863: LD_VAR 0 1
7867: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7868: LD_EXP 3
7872: NOT
7873: PUSH
7874: LD_INT 3
7876: PPUSH
7877: LD_INT 1
7879: PPUSH
7880: CALL 47000 0 2
7884: NOT
7885: AND
7886: IFFALSE 8742
7888: GO 7890
7890: DISABLE
7891: LD_INT 0
7893: PPUSH
7894: PPUSH
7895: PPUSH
// begin enable ;
7896: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7897: LD_INT 22
7899: PUSH
7900: LD_INT 8
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 23
7909: PUSH
7910: LD_INT 2
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: IFFALSE 7941
// exit ;
7939: GO 8742
// if Prob ( 40 ) then
7941: LD_INT 40
7943: PPUSH
7944: CALL_OW 13
7948: IFFALSE 8075
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7950: LD_INT 3
7952: PPUSH
7953: LD_INT 14
7955: PUSH
7956: LD_INT 1
7958: PUSH
7959: LD_INT 2
7961: PUSH
7962: LD_INT 28
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: LIST
7969: LIST
7970: PUSH
7971: LD_INT 14
7973: PUSH
7974: LD_INT 1
7976: PUSH
7977: LD_INT 2
7979: PUSH
7980: LD_INT 28
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 14
7991: PUSH
7992: LD_INT 1
7994: PUSH
7995: LD_INT 2
7997: PUSH
7998: LD_INT 28
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 14
8009: PUSH
8010: LD_INT 1
8012: PUSH
8013: LD_INT 2
8015: PUSH
8016: LD_INT 28
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: PUSH
8025: LD_INT 14
8027: PUSH
8028: LD_INT 1
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 28
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: PUSH
8043: LD_INT 14
8045: PUSH
8046: LD_INT 1
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 26
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL 45582 0 2
// end else
8073: GO 8282
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8075: LD_INT 3
8077: PPUSH
8078: LD_INT 14
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: LD_INT 2
8086: PUSH
8087: LD_INT 27
8089: PUSH
8090: LD_INT 26
8092: PUSH
8093: LD_INT 26
8095: PUSH
8096: LD_INT 28
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: LIST
8104: PUSH
8105: LD_OWVAR 67
8109: ARRAY
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: LIST
8115: LIST
8116: PUSH
8117: LD_INT 14
8119: PUSH
8120: LD_INT 1
8122: PUSH
8123: LD_INT 2
8125: PUSH
8126: LD_INT 27
8128: PUSH
8129: LD_INT 26
8131: PUSH
8132: LD_INT 26
8134: PUSH
8135: LD_INT 26
8137: PUSH
8138: EMPTY
8139: LIST
8140: LIST
8141: LIST
8142: LIST
8143: PUSH
8144: LD_OWVAR 67
8148: ARRAY
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: LIST
8154: LIST
8155: PUSH
8156: LD_INT 14
8158: PUSH
8159: LD_INT 1
8161: PUSH
8162: LD_INT 2
8164: PUSH
8165: LD_INT 26
8167: PUSH
8168: LD_INT 26
8170: PUSH
8171: LD_INT 29
8173: PUSH
8174: LD_INT 29
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: LIST
8181: LIST
8182: PUSH
8183: LD_OWVAR 67
8187: ARRAY
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: LIST
8193: LIST
8194: PUSH
8195: LD_INT 13
8197: PUSH
8198: LD_INT 1
8200: PUSH
8201: LD_INT 2
8203: PUSH
8204: LD_INT 26
8206: PUSH
8207: LD_INT 29
8209: PUSH
8210: LD_INT 29
8212: PUSH
8213: LD_INT 29
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_OWVAR 67
8226: ARRAY
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 13
8236: PUSH
8237: LD_INT 1
8239: PUSH
8240: LD_INT 2
8242: PUSH
8243: LD_INT 29
8245: PUSH
8246: EMPTY
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: PUSH
8252: LD_INT 14
8254: PUSH
8255: LD_INT 1
8257: PUSH
8258: LD_INT 2
8260: PUSH
8261: LD_INT 26
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: PPUSH
8278: CALL 45582 0 2
// end ; repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 1
8294: PPUSH
8295: CALL 47000 0 2
8299: PUSH
8300: LD_INT 6
8302: GREATEREQUAL
8303: IFFALSE 8282
// wait ( 0 0$30 ) ;
8305: LD_INT 1050
8307: PPUSH
8308: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8312: LD_ADDR_VAR 0 2
8316: PUSH
8317: LD_INT 3
8319: PPUSH
8320: LD_INT 1
8322: PPUSH
8323: CALL 47000 0 2
8327: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8328: LD_ADDR_EXP 114
8332: PUSH
8333: LD_EXP 114
8337: PPUSH
8338: LD_INT 3
8340: PPUSH
8341: LD_EXP 114
8345: PUSH
8346: LD_INT 3
8348: ARRAY
8349: PUSH
8350: LD_VAR 0 2
8354: DIFF
8355: PPUSH
8356: CALL_OW 1
8360: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8361: LD_ADDR_VAR 0 3
8365: PUSH
8366: LD_INT 0
8368: PPUSH
8369: LD_INT 2
8371: PPUSH
8372: CALL_OW 12
8376: ST_TO_ADDR
// if target then
8377: LD_VAR 0 3
8381: IFFALSE 8509
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8383: LD_ADDR_VAR 0 2
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 24
8395: PUSH
8396: LD_INT 250
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: ST_TO_ADDR
// for i in tmp do
8408: LD_ADDR_VAR 0 1
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: FOR_IN
8419: IFFALSE 8459
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8421: LD_VAR 0 1
8425: PPUSH
8426: LD_INT 89
8428: PPUSH
8429: LD_INT 71
8431: PPUSH
8432: CALL_OW 297
8436: PUSH
8437: LD_INT 9
8439: GREATER
8440: IFFALSE 8457
// ComMoveXY ( i , 89 , 71 ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: LD_INT 89
8449: PPUSH
8450: LD_INT 71
8452: PPUSH
8453: CALL_OW 111
8457: GO 8418
8459: POP
8460: POP
// wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8468: LD_VAR 0 2
8472: PPUSH
8473: LD_INT 92
8475: PUSH
8476: LD_INT 89
8478: PUSH
8479: LD_INT 71
8481: PUSH
8482: LD_INT 9
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 72
8495: PUSH
8496: LD_VAR 0 2
8500: PUSH
8501: LD_INT 1
8503: MINUS
8504: GREATEREQUAL
8505: IFFALSE 8383
// end else
8507: GO 8633
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8509: LD_ADDR_VAR 0 2
8513: PUSH
8514: LD_VAR 0 2
8518: PPUSH
8519: LD_INT 24
8521: PUSH
8522: LD_INT 250
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PPUSH
8529: CALL_OW 72
8533: ST_TO_ADDR
// for i in tmp do
8534: LD_ADDR_VAR 0 1
8538: PUSH
8539: LD_VAR 0 2
8543: PUSH
8544: FOR_IN
8545: IFFALSE 8585
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8547: LD_VAR 0 1
8551: PPUSH
8552: LD_INT 147
8554: PPUSH
8555: LD_INT 4
8557: PPUSH
8558: CALL_OW 297
8562: PUSH
8563: LD_INT 9
8565: GREATER
8566: IFFALSE 8583
// ComMoveXY ( i , 147 , 4 ) ;
8568: LD_VAR 0 1
8572: PPUSH
8573: LD_INT 147
8575: PPUSH
8576: LD_INT 4
8578: PPUSH
8579: CALL_OW 111
8583: GO 8544
8585: POP
8586: POP
// wait ( 0 0$1 ) ;
8587: LD_INT 35
8589: PPUSH
8590: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8594: LD_VAR 0 2
8598: PPUSH
8599: LD_INT 92
8601: PUSH
8602: LD_INT 147
8604: PUSH
8605: LD_INT 4
8607: PUSH
8608: LD_INT 9
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 72
8621: PUSH
8622: LD_VAR 0 2
8626: PUSH
8627: LD_INT 1
8629: MINUS
8630: GREATEREQUAL
8631: IFFALSE 8509
// end ; repeat wait ( 0 0$1 ) ;
8633: LD_INT 35
8635: PPUSH
8636: CALL_OW 67
// for i in tmp do
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: LD_VAR 0 2
8649: PUSH
8650: FOR_IN
8651: IFFALSE 8733
// begin if GetLives ( i ) > 251 then
8653: LD_VAR 0 1
8657: PPUSH
8658: CALL_OW 256
8662: PUSH
8663: LD_INT 251
8665: GREATER
8666: IFFALSE 8704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8668: LD_VAR 0 1
8672: PPUSH
8673: LD_INT 81
8675: PUSH
8676: LD_INT 8
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: PPUSH
8688: LD_VAR 0 1
8692: PPUSH
8693: CALL_OW 74
8697: PPUSH
8698: CALL_OW 115
8702: GO 8731
// if IsDead ( i ) then
8704: LD_VAR 0 1
8708: PPUSH
8709: CALL_OW 301
8713: IFFALSE 8731
// tmp := tmp diff i ;
8715: LD_ADDR_VAR 0 2
8719: PUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_VAR 0 1
8729: DIFF
8730: ST_TO_ADDR
// end ;
8731: GO 8650
8733: POP
8734: POP
// until not tmp ;
8735: LD_VAR 0 2
8739: NOT
8740: IFFALSE 8633
// end ;
8742: PPOPN 3
8744: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8745: LD_EXP 57
8749: PPUSH
8750: CALL_OW 302
8754: PUSH
8755: LD_EXP 3
8759: NOT
8760: AND
8761: IFFALSE 8770
8763: GO 8765
8765: DISABLE
// BuildKozlovBomb ;
8766: CALL 7741 0 0
8770: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8771: LD_INT 22
8773: PUSH
8774: LD_INT 8
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 34
8783: PUSH
8784: LD_INT 48
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: IFFALSE 8847
8801: GO 8803
8803: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8804: LD_INT 22
8806: PUSH
8807: LD_INT 8
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 34
8816: PUSH
8817: LD_INT 48
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: PPUSH
8828: CALL_OW 69
8832: PUSH
8833: LD_INT 1
8835: ARRAY
8836: PPUSH
8837: LD_INT 173
8839: PPUSH
8840: LD_INT 96
8842: PPUSH
8843: CALL_OW 116
// end ; end_of_file
8847: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8848: LD_INT 0
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// side := 3 ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_INT 3
8866: ST_TO_ADDR
// InitHc ;
8867: CALL_OW 19
// uc_side := side ;
8871: LD_ADDR_OWVAR 20
8875: PUSH
8876: LD_VAR 0 6
8880: ST_TO_ADDR
// uc_nation := 3 ;
8881: LD_ADDR_OWVAR 21
8885: PUSH
8886: LD_INT 3
8888: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8889: LD_ADDR_VAR 0 2
8893: PUSH
8894: LD_INT 22
8896: PUSH
8897: LD_VAR 0 6
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 21
8908: PUSH
8909: LD_INT 3
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PPUSH
8920: CALL_OW 69
8924: PUSH
8925: FOR_IN
8926: IFFALSE 8942
// SetBLevel ( i , 10 ) ;
8928: LD_VAR 0 2
8932: PPUSH
8933: LD_INT 10
8935: PPUSH
8936: CALL_OW 241
8940: GO 8925
8942: POP
8943: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8944: LD_ADDR_VAR 0 9
8948: PUSH
8949: LD_INT 22
8951: PUSH
8952: LD_VAR 0 6
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 30
8963: PUSH
8964: LD_INT 34
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PPUSH
8975: CALL_OW 69
8979: ST_TO_ADDR
// if teleport then
8980: LD_VAR 0 9
8984: IFFALSE 9005
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8986: LD_VAR 0 9
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_INT 123
8997: PPUSH
8998: LD_INT 122
9000: PPUSH
9001: CALL_OW 243
// hc_importance := 0 ;
9005: LD_ADDR_OWVAR 32
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9013: LD_ADDR_EXP 58
9017: PUSH
9018: LD_STRING Platonov
9020: PPUSH
9021: CALL_OW 25
9025: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
9026: LD_ADDR_EXP 59
9030: PUSH
9031: LD_STRING Yakotich
9033: PPUSH
9034: CALL_OW 25
9038: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9039: LD_ADDR_EXP 60
9043: PUSH
9044: LD_STRING Gleb
9046: PPUSH
9047: CALL_OW 25
9051: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9052: LD_STRING 03_Cornel
9054: PPUSH
9055: CALL_OW 28
9059: IFFALSE 9107
// begin Bierezov := NewCharacter ( Mikhail ) ;
9061: LD_ADDR_EXP 61
9065: PUSH
9066: LD_STRING Mikhail
9068: PPUSH
9069: CALL_OW 25
9073: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9074: LD_EXP 61
9078: PPUSH
9079: LD_INT 197
9081: PPUSH
9082: LD_INT 111
9084: PPUSH
9085: LD_INT 9
9087: PPUSH
9088: LD_INT 0
9090: PPUSH
9091: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9095: LD_EXP 61
9099: PPUSH
9100: LD_INT 3
9102: PPUSH
9103: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9107: LD_EXP 58
9111: PPUSH
9112: LD_INT 126
9114: PPUSH
9115: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9119: LD_EXP 59
9123: PPUSH
9124: LD_INT 197
9126: PPUSH
9127: LD_INT 111
9129: PPUSH
9130: LD_INT 9
9132: PPUSH
9133: LD_INT 0
9135: PPUSH
9136: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9140: LD_EXP 60
9144: PPUSH
9145: LD_INT 197
9147: PPUSH
9148: LD_INT 111
9150: PPUSH
9151: LD_INT 9
9153: PPUSH
9154: LD_INT 0
9156: PPUSH
9157: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9161: LD_ADDR_VAR 0 5
9165: PUSH
9166: LD_INT 126
9168: PPUSH
9169: LD_INT 2
9171: PPUSH
9172: LD_STRING zhukov
9174: PPUSH
9175: LD_INT 9
9177: PUSH
9178: LD_INT 10
9180: PUSH
9181: LD_INT 10
9183: PUSH
9184: LD_INT 10
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: LIST
9191: LIST
9192: PUSH
9193: LD_OWVAR 67
9197: ARRAY
9198: PPUSH
9199: LD_INT 9000
9201: PUSH
9202: LD_INT 1000
9204: PUSH
9205: LD_INT 300
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: LIST
9212: PPUSH
9213: LD_INT 21
9215: PUSH
9216: LD_INT 8
9218: PUSH
9219: LD_INT 13
9221: PUSH
9222: LD_INT 8
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 60298 0 6
9235: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9236: LD_ADDR_VAR 0 4
9240: PUSH
9241: LD_INT 267
9243: PPUSH
9244: CALL_OW 274
9248: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9249: LD_VAR 0 4
9253: PPUSH
9254: LD_INT 1
9256: PPUSH
9257: LD_INT 5000
9259: PPUSH
9260: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9264: LD_VAR 0 4
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: LD_INT 200
9274: PPUSH
9275: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9279: LD_VAR 0 4
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 200
9289: PPUSH
9290: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9294: LD_ADDR_EXP 95
9298: PUSH
9299: LD_EXP 95
9303: PPUSH
9304: LD_INT 2
9306: PPUSH
9307: LD_VAR 0 5
9311: PUSH
9312: LD_INT 22
9314: PUSH
9315: LD_VAR 0 6
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: LD_INT 3
9326: PUSH
9327: LD_INT 21
9329: PUSH
9330: LD_INT 2
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: PPUSH
9345: CALL_OW 69
9349: UNION
9350: PUSH
9351: LD_EXP 58
9355: DIFF
9356: PPUSH
9357: CALL_OW 1
9361: ST_TO_ADDR
// behemoths := [ ] ;
9362: LD_ADDR_EXP 62
9366: PUSH
9367: EMPTY
9368: ST_TO_ADDR
// behemothBuilders := [ ] ;
9369: LD_ADDR_EXP 63
9373: PUSH
9374: EMPTY
9375: ST_TO_ADDR
// j := 3 ;
9376: LD_ADDR_VAR 0 3
9380: PUSH
9381: LD_INT 3
9383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9384: LD_ADDR_VAR 0 2
9388: PUSH
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 25
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: PUSH
9418: FOR_IN
9419: IFFALSE 9469
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9421: LD_ADDR_EXP 63
9425: PUSH
9426: LD_EXP 63
9430: PPUSH
9431: LD_VAR 0 2
9435: PPUSH
9436: CALL 88725 0 2
9440: ST_TO_ADDR
// j := j - 1 ;
9441: LD_ADDR_VAR 0 3
9445: PUSH
9446: LD_VAR 0 3
9450: PUSH
9451: LD_INT 1
9453: MINUS
9454: ST_TO_ADDR
// if j = 0 then
9455: LD_VAR 0 3
9459: PUSH
9460: LD_INT 0
9462: EQUAL
9463: IFFALSE 9467
// break ;
9465: GO 9469
// end ;
9467: GO 9418
9469: POP
9470: POP
// end ;
9471: LD_VAR 0 1
9475: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9476: LD_INT 0
9478: PPUSH
9479: PPUSH
9480: PPUSH
9481: PPUSH
9482: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9483: LD_ADDR_VAR 0 4
9487: PUSH
9488: LD_INT 209
9490: PUSH
9491: LD_INT 149
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: PUSH
9498: LD_INT 219
9500: PUSH
9501: LD_INT 154
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 223
9510: PUSH
9511: LD_INT 149
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: PUSH
9518: LD_INT 232
9520: PUSH
9521: LD_INT 155
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: ST_TO_ADDR
// if not behemothBuilders then
9534: LD_EXP 63
9538: NOT
9539: IFFALSE 9543
// exit ;
9541: GO 9647
// j := 1 ;
9543: LD_ADDR_VAR 0 3
9547: PUSH
9548: LD_INT 1
9550: ST_TO_ADDR
// for i in behemothBuilders do
9551: LD_ADDR_VAR 0 2
9555: PUSH
9556: LD_EXP 63
9560: PUSH
9561: FOR_IN
9562: IFFALSE 9645
// begin if IsInUnit ( i ) then
9564: LD_VAR 0 2
9568: PPUSH
9569: CALL_OW 310
9573: IFFALSE 9584
// ComExitBuilding ( i ) ;
9575: LD_VAR 0 2
9579: PPUSH
9580: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9584: LD_VAR 0 2
9588: PPUSH
9589: LD_INT 37
9591: PPUSH
9592: LD_VAR 0 4
9596: PUSH
9597: LD_VAR 0 3
9601: ARRAY
9602: PUSH
9603: LD_INT 1
9605: ARRAY
9606: PPUSH
9607: LD_VAR 0 4
9611: PUSH
9612: LD_VAR 0 3
9616: ARRAY
9617: PUSH
9618: LD_INT 2
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 230
// j := j + 1 ;
9629: LD_ADDR_VAR 0 3
9633: PUSH
9634: LD_VAR 0 3
9638: PUSH
9639: LD_INT 1
9641: PLUS
9642: ST_TO_ADDR
// end ;
9643: GO 9561
9645: POP
9646: POP
// end ;
9647: LD_VAR 0 1
9651: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9652: LD_INT 3
9654: PPUSH
9655: CALL 88786 0 1
9659: PUSH
9660: LD_INT 22
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: LD_INT 30
9672: PUSH
9673: LD_INT 37
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PPUSH
9684: CALL_OW 69
9688: NOT
9689: AND
9690: IFFALSE 9876
9692: GO 9694
9694: DISABLE
9695: LD_INT 0
9697: PPUSH
9698: PPUSH
// begin enable ;
9699: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9700: LD_ADDR_VAR 0 2
9704: PUSH
9705: LD_INT 3
9707: PPUSH
9708: CALL 88786 0 1
9712: ST_TO_ADDR
// for i in tmp do
9713: LD_ADDR_VAR 0 1
9717: PUSH
9718: LD_VAR 0 2
9722: PUSH
9723: FOR_IN
9724: IFFALSE 9874
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9726: LD_VAR 0 1
9730: PPUSH
9731: LD_INT 7
9733: PPUSH
9734: CALL_OW 308
9738: PUSH
9739: LD_VAR 0 1
9743: PPUSH
9744: CALL_OW 110
9748: PUSH
9749: LD_INT 2
9751: EQUAL
9752: NOT
9753: AND
9754: IFFALSE 9768
// SetTag ( i , 2 ) ;
9756: LD_VAR 0 1
9760: PPUSH
9761: LD_INT 2
9763: PPUSH
9764: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9768: LD_INT 81
9770: PUSH
9771: LD_INT 3
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PUSH
9778: LD_INT 91
9780: PUSH
9781: LD_VAR 0 1
9785: PUSH
9786: LD_INT 12
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: PUSH
9794: EMPTY
9795: LIST
9796: LIST
9797: PPUSH
9798: CALL_OW 69
9802: NOT
9803: PUSH
9804: LD_VAR 0 1
9808: PPUSH
9809: CALL_OW 110
9813: PUSH
9814: LD_INT 2
9816: EQUAL
9817: NOT
9818: AND
9819: IFFALSE 9838
// ComAgressiveMove ( i , 64 , 93 ) else
9821: LD_VAR 0 1
9825: PPUSH
9826: LD_INT 64
9828: PPUSH
9829: LD_INT 93
9831: PPUSH
9832: CALL_OW 114
9836: GO 9872
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9838: LD_VAR 0 1
9842: PPUSH
9843: LD_INT 81
9845: PUSH
9846: LD_INT 3
9848: PUSH
9849: EMPTY
9850: LIST
9851: LIST
9852: PPUSH
9853: CALL_OW 69
9857: PPUSH
9858: LD_VAR 0 1
9862: PPUSH
9863: CALL_OW 74
9867: PPUSH
9868: CALL_OW 115
// end ;
9872: GO 9723
9874: POP
9875: POP
// end ;
9876: PPOPN 2
9878: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9879: LD_EXP 2
9883: NOT
9884: PUSH
9885: LD_INT 2
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: CALL 47000 0 2
9895: NOT
9896: AND
9897: IFFALSE 10821
9899: GO 9901
9901: DISABLE
9902: LD_INT 0
9904: PPUSH
9905: PPUSH
9906: PPUSH
9907: PPUSH
// begin enable ;
9908: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9909: LD_INT 22
9911: PUSH
9912: LD_INT 3
9914: PUSH
9915: EMPTY
9916: LIST
9917: LIST
9918: PUSH
9919: LD_INT 30
9921: PUSH
9922: LD_INT 3
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PPUSH
9933: CALL_OW 69
9937: NOT
9938: IFFALSE 9942
// exit ;
9940: GO 10821
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9942: LD_ADDR_VAR 0 4
9946: PUSH
9947: LD_INT 22
9949: PUSH
9950: LD_INT 3
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 30
9959: PUSH
9960: LD_INT 34
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PPUSH
9971: CALL_OW 69
9975: ST_TO_ADDR
// if Prob ( 40 ) then
9976: LD_INT 40
9978: PPUSH
9979: CALL_OW 13
9983: IFFALSE 10110
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9985: LD_INT 2
9987: PPUSH
9988: LD_INT 22
9990: PUSH
9991: LD_INT 3
9993: PUSH
9994: LD_INT 3
9996: PUSH
9997: LD_INT 49
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: PUSH
10006: LD_INT 22
10008: PUSH
10009: LD_INT 3
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: LD_INT 49
10017: PUSH
10018: EMPTY
10019: LIST
10020: LIST
10021: LIST
10022: LIST
10023: PUSH
10024: LD_INT 22
10026: PUSH
10027: LD_INT 3
10029: PUSH
10030: LD_INT 3
10032: PUSH
10033: LD_INT 49
10035: PUSH
10036: EMPTY
10037: LIST
10038: LIST
10039: LIST
10040: LIST
10041: PUSH
10042: LD_INT 24
10044: PUSH
10045: LD_INT 3
10047: PUSH
10048: LD_INT 3
10050: PUSH
10051: LD_INT 46
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: PUSH
10060: LD_INT 24
10062: PUSH
10063: LD_INT 3
10065: PUSH
10066: LD_INT 3
10068: PUSH
10069: LD_INT 46
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 24
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 46
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: PPUSH
10104: CALL 45582 0 2
// end else
10108: GO 10233
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10110: LD_INT 2
10112: PPUSH
10113: LD_INT 24
10115: PUSH
10116: LD_INT 3
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 47
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: LD_INT 24
10133: PUSH
10134: LD_INT 3
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 47
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: PUSH
10149: LD_INT 24
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: LD_INT 3
10157: PUSH
10158: LD_INT 47
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_INT 24
10169: PUSH
10170: LD_INT 3
10172: PUSH
10173: LD_INT 3
10175: PUSH
10176: LD_INT 46
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: LIST
10183: LIST
10184: PUSH
10185: LD_INT 24
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: LD_INT 46
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: PUSH
10203: LD_INT 24
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: LD_INT 3
10211: PUSH
10212: LD_INT 46
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: LIST
10228: PPUSH
10229: CALL 45582 0 2
// end ; if Difficulty > 1 then
10233: LD_OWVAR 67
10237: PUSH
10238: LD_INT 1
10240: GREATER
10241: IFFALSE 10271
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10243: LD_INT 2
10245: PPUSH
10246: LD_INT 24
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 47
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: EMPTY
10265: LIST
10266: PPUSH
10267: CALL 45582 0 2
// repeat wait ( 0 0$1 ) ;
10271: LD_INT 35
10273: PPUSH
10274: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10278: LD_INT 2
10280: PPUSH
10281: LD_INT 1
10283: PPUSH
10284: CALL 47000 0 2
10288: PUSH
10289: LD_INT 6
10291: PUSH
10292: LD_INT 7
10294: PUSH
10295: LD_INT 7
10297: PUSH
10298: LD_INT 7
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: LD_OWVAR 67
10311: ARRAY
10312: GREATEREQUAL
10313: IFFALSE 10271
// wait ( 0 0$30 ) ;
10315: LD_INT 1050
10317: PPUSH
10318: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10322: LD_ADDR_VAR 0 2
10326: PUSH
10327: LD_INT 2
10329: PPUSH
10330: LD_INT 1
10332: PPUSH
10333: CALL 47000 0 2
10337: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10338: LD_ADDR_EXP 114
10342: PUSH
10343: LD_EXP 114
10347: PPUSH
10348: LD_INT 2
10350: PPUSH
10351: LD_EXP 114
10355: PUSH
10356: LD_INT 2
10358: ARRAY
10359: PUSH
10360: LD_VAR 0 2
10364: DIFF
10365: PPUSH
10366: CALL_OW 1
10370: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10371: LD_ADDR_VAR 0 3
10375: PUSH
10376: LD_INT 0
10378: PPUSH
10379: LD_INT 1
10381: PPUSH
10382: CALL_OW 12
10386: ST_TO_ADDR
// if target then
10387: LD_VAR 0 3
10391: IFFALSE 10519
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10393: LD_ADDR_VAR 0 2
10397: PUSH
10398: LD_VAR 0 2
10402: PPUSH
10403: LD_INT 24
10405: PUSH
10406: LD_INT 250
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL_OW 72
10417: ST_TO_ADDR
// for i in tmp do
10418: LD_ADDR_VAR 0 1
10422: PUSH
10423: LD_VAR 0 2
10427: PUSH
10428: FOR_IN
10429: IFFALSE 10469
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10431: LD_VAR 0 1
10435: PPUSH
10436: LD_INT 139
10438: PPUSH
10439: LD_INT 89
10441: PPUSH
10442: CALL_OW 297
10446: PUSH
10447: LD_INT 9
10449: GREATER
10450: IFFALSE 10467
// ComMoveXY ( i , 139 , 89 ) ;
10452: LD_VAR 0 1
10456: PPUSH
10457: LD_INT 139
10459: PPUSH
10460: LD_INT 89
10462: PPUSH
10463: CALL_OW 111
10467: GO 10428
10469: POP
10470: POP
// wait ( 0 0$1 ) ;
10471: LD_INT 35
10473: PPUSH
10474: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10478: LD_VAR 0 2
10482: PPUSH
10483: LD_INT 92
10485: PUSH
10486: LD_INT 139
10488: PUSH
10489: LD_INT 89
10491: PUSH
10492: LD_INT 9
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: PPUSH
10501: CALL_OW 72
10505: PUSH
10506: LD_VAR 0 2
10510: PUSH
10511: LD_INT 1
10513: MINUS
10514: GREATEREQUAL
10515: IFFALSE 10393
// end else
10517: GO 10661
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10519: LD_VAR 0 2
10523: PPUSH
10524: LD_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ARRAY
10532: PPUSH
10533: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10537: LD_ADDR_VAR 0 2
10541: PUSH
10542: LD_VAR 0 2
10546: PPUSH
10547: LD_INT 24
10549: PUSH
10550: LD_INT 250
10552: PUSH
10553: EMPTY
10554: LIST
10555: LIST
10556: PPUSH
10557: CALL_OW 72
10561: ST_TO_ADDR
// for i in tmp do
10562: LD_ADDR_VAR 0 1
10566: PUSH
10567: LD_VAR 0 2
10571: PUSH
10572: FOR_IN
10573: IFFALSE 10613
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10575: LD_VAR 0 1
10579: PPUSH
10580: LD_INT 124
10582: PPUSH
10583: LD_INT 139
10585: PPUSH
10586: CALL_OW 297
10590: PUSH
10591: LD_INT 9
10593: GREATER
10594: IFFALSE 10611
// ComMoveXY ( i , 124 , 139 ) ;
10596: LD_VAR 0 1
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 139
10606: PPUSH
10607: CALL_OW 111
10611: GO 10572
10613: POP
10614: POP
// wait ( 0 0$1 ) ;
10615: LD_INT 35
10617: PPUSH
10618: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10622: LD_VAR 0 2
10626: PPUSH
10627: LD_INT 92
10629: PUSH
10630: LD_INT 124
10632: PUSH
10633: LD_INT 139
10635: PUSH
10636: LD_INT 9
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: LIST
10643: LIST
10644: PPUSH
10645: CALL_OW 72
10649: PUSH
10650: LD_VAR 0 2
10654: PUSH
10655: LD_INT 1
10657: MINUS
10658: GREATEREQUAL
10659: IFFALSE 10537
// end ; repeat wait ( 0 0$1 ) ;
10661: LD_INT 35
10663: PPUSH
10664: CALL_OW 67
// for i in tmp do
10668: LD_ADDR_VAR 0 1
10672: PUSH
10673: LD_VAR 0 2
10677: PUSH
10678: FOR_IN
10679: IFFALSE 10812
// begin if GetLives ( i ) > 251 then
10681: LD_VAR 0 1
10685: PPUSH
10686: CALL_OW 256
10690: PUSH
10691: LD_INT 251
10693: GREATER
10694: IFFALSE 10783
// begin if GetWeapon ( i ) = ru_time_lapser then
10696: LD_VAR 0 1
10700: PPUSH
10701: CALL_OW 264
10705: PUSH
10706: LD_INT 49
10708: EQUAL
10709: IFFALSE 10747
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10711: LD_VAR 0 1
10715: PPUSH
10716: LD_INT 81
10718: PUSH
10719: LD_INT 3
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: PPUSH
10726: CALL_OW 69
10730: PPUSH
10731: LD_VAR 0 1
10735: PPUSH
10736: CALL_OW 74
10740: PPUSH
10741: CALL_OW 112
10745: GO 10781
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10747: LD_VAR 0 1
10751: PPUSH
10752: LD_INT 81
10754: PUSH
10755: LD_INT 3
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: PPUSH
10762: CALL_OW 69
10766: PPUSH
10767: LD_VAR 0 1
10771: PPUSH
10772: CALL_OW 74
10776: PPUSH
10777: CALL_OW 115
// end else
10781: GO 10810
// if IsDead ( i ) then
10783: LD_VAR 0 1
10787: PPUSH
10788: CALL_OW 301
10792: IFFALSE 10810
// tmp := tmp diff i ;
10794: LD_ADDR_VAR 0 2
10798: PUSH
10799: LD_VAR 0 2
10803: PUSH
10804: LD_VAR 0 1
10808: DIFF
10809: ST_TO_ADDR
// end ;
10810: GO 10678
10812: POP
10813: POP
// until not tmp ;
10814: LD_VAR 0 2
10818: NOT
10819: IFFALSE 10661
// end ;
10821: PPOPN 4
10823: END
// every 30 30$00 trigger not russianDestroyed do
10824: LD_EXP 2
10828: NOT
10829: IFFALSE 10898
10831: GO 10833
10833: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10834: LD_INT 105000
10836: PUSH
10837: LD_INT 84000
10839: PUSH
10840: LD_INT 63000
10842: PUSH
10843: LD_INT 52500
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: PUSH
10852: LD_OWVAR 67
10856: ARRAY
10857: PPUSH
10858: CALL_OW 67
// if russianDestroyed then
10862: LD_EXP 2
10866: IFFALSE 10870
// exit ;
10868: GO 10898
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10870: LD_INT 2
10872: PPUSH
10873: LD_INT 23
10875: PUSH
10876: LD_INT 3
10878: PUSH
10879: LD_INT 1
10881: PUSH
10882: LD_INT 48
10884: PUSH
10885: EMPTY
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: PPUSH
10894: CALL 45582 0 2
// end ; end_of_file
10898: END
// export function CustomEvent ( event ) ; begin
10899: LD_INT 0
10901: PPUSH
// end ;
10902: LD_VAR 0 2
10906: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10907: LD_VAR 0 2
10911: PPUSH
10912: LD_VAR 0 3
10916: PPUSH
10917: LD_INT 15
10919: PPUSH
10920: CALL_OW 309
10924: IFFALSE 10933
// YouLost ( MothContaminate ) ;
10926: LD_STRING MothContaminate
10928: PPUSH
10929: CALL_OW 104
// end ;
10933: PPOPN 3
10935: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10936: LD_VAR 0 2
10940: PPUSH
10941: LD_VAR 0 3
10945: PPUSH
10946: LD_INT 15
10948: PPUSH
10949: CALL_OW 309
10953: IFFALSE 10969
// begin wait ( 0 0$6 ) ;
10955: LD_INT 210
10957: PPUSH
10958: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10962: LD_STRING MothContaminateBomb
10964: PPUSH
10965: CALL_OW 104
// end ; end ;
10969: PPOPN 3
10971: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10972: LD_VAR 0 1
10976: PUSH
10977: LD_EXP 19
10981: EQUAL
10982: IFFALSE 10993
// begin YouLost ( JMM ) ;
10984: LD_STRING JMM
10986: PPUSH
10987: CALL_OW 104
// exit ;
10991: GO 11092
// end ; if un = Powell then
10993: LD_VAR 0 1
10997: PUSH
10998: LD_EXP 54
11002: EQUAL
11003: IFFALSE 11013
// americanDestroyed := true ;
11005: LD_ADDR_EXP 4
11009: PUSH
11010: LD_INT 1
11012: ST_TO_ADDR
// if un = Platonov then
11013: LD_VAR 0 1
11017: PUSH
11018: LD_EXP 58
11022: EQUAL
11023: IFFALSE 11033
// russianDestroyed := true ;
11025: LD_ADDR_EXP 2
11029: PUSH
11030: LD_INT 1
11032: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11033: LD_VAR 0 1
11037: PUSH
11038: LD_INT 22
11040: PUSH
11041: LD_INT 7
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: LD_INT 21
11050: PUSH
11051: LD_INT 2
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PPUSH
11062: CALL_OW 69
11066: IN
11067: IFFALSE 11083
// vehicleLostCounter := vehicleLostCounter + 1 ;
11069: LD_ADDR_EXP 15
11073: PUSH
11074: LD_EXP 15
11078: PUSH
11079: LD_INT 1
11081: PLUS
11082: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11083: LD_VAR 0 1
11087: PPUSH
11088: CALL 49002 0 1
// end ;
11092: PPOPN 1
11094: END
// on Contact ( s1 , s2 ) do begin if s1 = 7 and s2 = 2 then
11095: LD_VAR 0 1
11099: PUSH
11100: LD_INT 7
11102: EQUAL
11103: PUSH
11104: LD_VAR 0 2
11108: PUSH
11109: LD_INT 2
11111: EQUAL
11112: AND
11113: IFFALSE 11123
// arabianAttacked := true ;
11115: LD_ADDR_EXP 18
11119: PUSH
11120: LD_INT 1
11122: ST_TO_ADDR
// end ;
11123: PPOPN 2
11125: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11126: LD_VAR 0 1
11130: PPUSH
11131: LD_VAR 0 2
11135: PPUSH
11136: CALL 51336 0 2
// end ;
11140: PPOPN 2
11142: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11143: LD_VAR 0 1
11147: PPUSH
11148: CALL 50404 0 1
// end ;
11152: PPOPN 1
11154: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11155: LD_VAR 0 1
11159: PUSH
11160: LD_INT 22
11162: PUSH
11163: LD_INT 8
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: PUSH
11170: LD_INT 30
11172: PUSH
11173: LD_INT 2
11175: PUSH
11176: EMPTY
11177: LIST
11178: LIST
11179: PUSH
11180: LD_INT 23
11182: PUSH
11183: LD_INT 3
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PUSH
11190: EMPTY
11191: LIST
11192: LIST
11193: LIST
11194: PPUSH
11195: CALL_OW 69
11199: IN
11200: IFFALSE 11227
// begin ComUpgrade ( building ) ;
11202: LD_VAR 0 1
11206: PPUSH
11207: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11211: LD_EXP 57
11215: PPUSH
11216: LD_VAR 0 1
11220: PPUSH
11221: CALL 59837 0 2
// exit ;
11225: GO 11236
// end ; MCE_BuildingComplete ( building ) ;
11227: LD_VAR 0 1
11231: PPUSH
11232: CALL 50645 0 1
// end ;
11236: PPOPN 1
11238: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11239: LD_VAR 0 1
11243: PPUSH
11244: LD_VAR 0 2
11248: PPUSH
11249: CALL 48698 0 2
// end ;
11253: PPOPN 2
11255: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11256: LD_VAR 0 1
11260: PPUSH
11261: LD_VAR 0 2
11265: PPUSH
11266: LD_VAR 0 3
11270: PPUSH
11271: LD_VAR 0 4
11275: PPUSH
11276: LD_VAR 0 5
11280: PPUSH
11281: CALL 48318 0 5
// end ;
11285: PPOPN 5
11287: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11288: LD_VAR 0 1
11292: PPUSH
11293: LD_VAR 0 2
11297: PPUSH
11298: CALL 47899 0 2
// end ;
11302: PPOPN 2
11304: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11305: LD_VAR 0 1
11309: PPUSH
11310: LD_VAR 0 2
11314: PPUSH
11315: LD_VAR 0 3
11319: PPUSH
11320: LD_VAR 0 4
11324: PPUSH
11325: CALL 47737 0 4
// end ;
11329: PPOPN 4
11331: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11332: LD_VAR 0 1
11336: PPUSH
11337: LD_VAR 0 2
11341: PPUSH
11342: LD_VAR 0 3
11346: PPUSH
11347: CALL 47512 0 3
// end ;
11351: PPOPN 3
11353: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11354: LD_VAR 0 1
11358: PPUSH
11359: LD_VAR 0 2
11363: PPUSH
11364: CALL 47397 0 2
// end ;
11368: PPOPN 2
11370: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11371: LD_VAR 0 1
11375: PPUSH
11376: LD_VAR 0 2
11380: PPUSH
11381: CALL 51631 0 2
// end ;
11385: PPOPN 2
11387: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11388: LD_VAR 0 1
11392: PPUSH
11393: LD_VAR 0 2
11397: PPUSH
11398: LD_VAR 0 3
11402: PPUSH
11403: LD_VAR 0 4
11407: PPUSH
11408: CALL 51847 0 4
// end ;
11412: PPOPN 4
11414: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11415: LD_VAR 0 1
11419: PPUSH
11420: LD_VAR 0 2
11424: PPUSH
11425: CALL 47206 0 2
// end ;
11429: PPOPN 2
11431: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11432: LD_VAR 0 1
11436: PPUSH
11437: CALL 105434 0 1
// end ; end_of_file
11441: PPOPN 1
11443: END
// export function Action ; begin
11444: LD_INT 0
11446: PPUSH
// InGameOn ;
11447: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11451: LD_INT 206
11453: PPUSH
11454: LD_INT 11
11456: PPUSH
11457: CALL_OW 86
// wait ( 0 0$1 ) ;
11461: LD_INT 35
11463: PPUSH
11464: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11468: LD_EXP 19
11472: PPUSH
11473: LD_STRING DStart-JMM-JMM-1
11475: PPUSH
11476: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11480: LD_EXP 51
11484: PPUSH
11485: LD_STRING DStart-JMM-Bur-1
11487: PPUSH
11488: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11492: LD_EXP 19
11496: PPUSH
11497: LD_STRING DStart-JMM-JMM-2
11499: PPUSH
11500: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11504: LD_EXP 51
11508: PPUSH
11509: LD_STRING DStart-JMM-Bur-2
11511: PPUSH
11512: CALL_OW 88
// InGameOff ;
11516: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11520: LD_STRING MStart
11522: PPUSH
11523: CALL_OW 337
// SaveForQuickRestart ;
11527: CALL_OW 22
// end ;
11531: LD_VAR 0 1
11535: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11536: LD_INT 7
11538: PPUSH
11539: LD_INT 255
11541: PPUSH
11542: LD_INT 219
11544: PPUSH
11545: CALL_OW 293
11549: IFFALSE 12158
11551: GO 11553
11553: DISABLE
11554: LD_INT 0
11556: PPUSH
// begin wait ( 0 0$3 ) ;
11557: LD_INT 105
11559: PPUSH
11560: CALL_OW 67
// alienSpotted := true ;
11564: LD_ADDR_EXP 10
11568: PUSH
11569: LD_INT 1
11571: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11572: LD_ADDR_VAR 0 1
11576: PUSH
11577: LD_INT 22
11579: PUSH
11580: LD_INT 7
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 23
11589: PUSH
11590: LD_INT 3
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PUSH
11597: LD_INT 21
11599: PUSH
11600: LD_INT 1
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_INT 26
11609: PUSH
11610: LD_INT 1
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: PPUSH
11623: CALL_OW 69
11627: PUSH
11628: LD_EXP 51
11632: PUSH
11633: LD_EXP 39
11637: PUSH
11638: LD_EXP 41
11642: PUSH
11643: LD_EXP 42
11647: PUSH
11648: LD_EXP 49
11652: PUSH
11653: LD_EXP 48
11657: PUSH
11658: LD_EXP 43
11662: PUSH
11663: EMPTY
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: DIFF
11672: ST_TO_ADDR
// DialogueOn ;
11673: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11677: LD_INT 255
11679: PPUSH
11680: LD_INT 219
11682: PPUSH
11683: LD_INT 7
11685: PPUSH
11686: LD_INT 20
11688: NEG
11689: PPUSH
11690: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11694: LD_INT 255
11696: PPUSH
11697: LD_INT 219
11699: PPUSH
11700: CALL_OW 86
// if speaker then
11704: LD_VAR 0 1
11708: IFFALSE 11726
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11710: LD_VAR 0 1
11714: PUSH
11715: LD_INT 1
11717: ARRAY
11718: PPUSH
11719: LD_STRING DAlienBase-RSol1-1
11721: PPUSH
11722: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11726: LD_EXP 19
11730: PPUSH
11731: LD_STRING DAlienBase-JMM-1
11733: PPUSH
11734: CALL_OW 88
// if IsOk ( Burlak ) then
11738: LD_EXP 51
11742: PPUSH
11743: CALL_OW 302
11747: IFFALSE 11768
// begin dwait ( 0 0$1 ) ;
11749: LD_INT 35
11751: PPUSH
11752: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11756: LD_EXP 51
11760: PPUSH
11761: LD_STRING DAlienBase-Bur-1
11763: PPUSH
11764: CALL_OW 88
// end ; if IsOk ( Roth ) then
11768: LD_EXP 20
11772: PPUSH
11773: CALL_OW 302
11777: IFFALSE 11791
// Say ( Roth , DAlienBase-Roth-1 ) ;
11779: LD_EXP 20
11783: PPUSH
11784: LD_STRING DAlienBase-Roth-1
11786: PPUSH
11787: CALL_OW 88
// if IsOk ( Gossudarov ) then
11791: LD_EXP 37
11795: PPUSH
11796: CALL_OW 302
11800: IFFALSE 11816
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11802: LD_EXP 37
11806: PPUSH
11807: LD_STRING DAlienBase-Gos-1
11809: PPUSH
11810: CALL_OW 88
11814: GO 11933
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11816: LD_ADDR_VAR 0 1
11820: PUSH
11821: LD_INT 22
11823: PUSH
11824: LD_INT 7
11826: PUSH
11827: EMPTY
11828: LIST
11829: LIST
11830: PUSH
11831: LD_INT 25
11833: PUSH
11834: LD_INT 4
11836: PUSH
11837: EMPTY
11838: LIST
11839: LIST
11840: PUSH
11841: LD_INT 21
11843: PUSH
11844: LD_INT 1
11846: PUSH
11847: EMPTY
11848: LIST
11849: LIST
11850: PUSH
11851: LD_INT 26
11853: PUSH
11854: LD_INT 1
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: PPUSH
11867: CALL_OW 69
11871: PUSH
11872: LD_EXP 20
11876: PUSH
11877: LD_EXP 19
11881: PUSH
11882: LD_EXP 51
11886: PUSH
11887: LD_EXP 39
11891: PUSH
11892: LD_EXP 49
11896: PUSH
11897: LD_EXP 48
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: LIST
11906: LIST
11907: LIST
11908: LIST
11909: DIFF
11910: ST_TO_ADDR
// if speaker then
11911: LD_VAR 0 1
11915: IFFALSE 11933
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11917: LD_VAR 0 1
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: LD_STRING DAlienBase-Sci1-1
11928: PPUSH
11929: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11933: LD_INT 255
11935: PPUSH
11936: LD_INT 219
11938: PPUSH
11939: LD_INT 7
11941: PPUSH
11942: CALL_OW 331
// DialogueOff ;
11946: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11950: LD_INT 35
11952: PPUSH
11953: CALL_OW 67
// until IsSelected ( alien ) ;
11957: LD_INT 1
11959: PPUSH
11960: CALL_OW 306
11964: IFFALSE 11950
// if not artifactIResearched or not artifactIIResearched then
11966: LD_EXP 12
11970: NOT
11971: PUSH
11972: LD_EXP 13
11976: NOT
11977: OR
11978: IFFALSE 12158
// begin if IsOk ( Roth ) then
11980: LD_EXP 20
11984: PPUSH
11985: CALL_OW 302
11989: IFFALSE 12005
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11991: LD_EXP 20
11995: PPUSH
11996: LD_STRING DAlieBaseNotReady-Roth-1
11998: PPUSH
11999: CALL_OW 88
12003: GO 12158
// if IsOk ( Gossudarov ) then
12005: LD_EXP 37
12009: PPUSH
12010: CALL_OW 302
12014: IFFALSE 12030
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12016: LD_EXP 37
12020: PPUSH
12021: LD_STRING DAlieBaseNotReady-Gos-1
12023: PPUSH
12024: CALL_OW 88
12028: GO 12158
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12030: LD_ADDR_VAR 0 1
12034: PUSH
12035: LD_INT 22
12037: PUSH
12038: LD_INT 7
12040: PUSH
12041: EMPTY
12042: LIST
12043: LIST
12044: PUSH
12045: LD_INT 23
12047: PUSH
12048: LD_INT 3
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: PUSH
12055: LD_INT 25
12057: PUSH
12058: LD_INT 4
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: LD_INT 21
12067: PUSH
12068: LD_INT 1
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: LD_INT 26
12077: PUSH
12078: LD_INT 1
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: PUSH
12085: EMPTY
12086: LIST
12087: LIST
12088: LIST
12089: LIST
12090: LIST
12091: PPUSH
12092: CALL_OW 69
12096: PUSH
12097: LD_EXP 20
12101: PUSH
12102: LD_EXP 19
12106: PUSH
12107: LD_EXP 51
12111: PUSH
12112: LD_EXP 39
12116: PUSH
12117: LD_EXP 49
12121: PUSH
12122: LD_EXP 48
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: LIST
12134: DIFF
12135: ST_TO_ADDR
// if speaker then
12136: LD_VAR 0 1
12140: IFFALSE 12158
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12142: LD_VAR 0 1
12146: PUSH
12147: LD_INT 1
12149: ARRAY
12150: PPUSH
12151: LD_STRING DAlieBaseNotReady-RSci1-1
12153: PPUSH
12154: CALL_OW 88
// end ; end ; end ;
12158: PPOPN 1
12160: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12161: LD_INT 24
12163: PPUSH
12164: LD_INT 7
12166: PPUSH
12167: CALL_OW 321
12171: PUSH
12172: LD_INT 2
12174: EQUAL
12175: IFFALSE 12866
12177: GO 12179
12179: DISABLE
12180: LD_INT 0
12182: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12183: LD_ADDR_VAR 0 1
12187: PUSH
12188: LD_INT 22
12190: PUSH
12191: LD_INT 7
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: LD_INT 23
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 25
12210: PUSH
12211: LD_INT 4
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 21
12220: PUSH
12221: LD_INT 1
12223: PUSH
12224: EMPTY
12225: LIST
12226: LIST
12227: PUSH
12228: LD_INT 26
12230: PUSH
12231: LD_INT 1
12233: PUSH
12234: EMPTY
12235: LIST
12236: LIST
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: LIST
12244: PPUSH
12245: CALL_OW 69
12249: PUSH
12250: LD_EXP 20
12254: PUSH
12255: LD_EXP 19
12259: PUSH
12260: LD_EXP 51
12264: PUSH
12265: LD_EXP 39
12269: PUSH
12270: LD_EXP 49
12274: PUSH
12275: LD_EXP 48
12279: PUSH
12280: EMPTY
12281: LIST
12282: LIST
12283: LIST
12284: LIST
12285: LIST
12286: LIST
12287: DIFF
12288: ST_TO_ADDR
// if not speaker then
12289: LD_VAR 0 1
12293: NOT
12294: IFFALSE 12298
// exit ;
12296: GO 12866
// DialogueOn ;
12298: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12302: LD_VAR 0 1
12306: PUSH
12307: LD_INT 1
12309: ARRAY
12310: PPUSH
12311: LD_STRING DArtefTechnology-RSci1-1
12313: PPUSH
12314: CALL_OW 88
// if IsOk ( Burlak ) then
12318: LD_EXP 51
12322: PPUSH
12323: CALL_OW 302
12327: IFFALSE 12341
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12329: LD_EXP 51
12333: PPUSH
12334: LD_STRING DArtefTechnology-Bur-1
12336: PPUSH
12337: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12341: LD_VAR 0 1
12345: PUSH
12346: LD_INT 1
12348: ARRAY
12349: PPUSH
12350: LD_STRING DArtefTechnology-RSci1-2
12352: PPUSH
12353: CALL_OW 88
// if Denis then
12357: LD_EXP 25
12361: IFFALSE 12378
// speaker := [ Denis ] else
12363: LD_ADDR_VAR 0 1
12367: PUSH
12368: LD_EXP 25
12372: PUSH
12373: EMPTY
12374: LIST
12375: ST_TO_ADDR
12376: GO 12484
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12378: LD_ADDR_VAR 0 1
12382: PUSH
12383: LD_INT 22
12385: PUSH
12386: LD_INT 7
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_INT 23
12395: PUSH
12396: LD_INT 1
12398: PUSH
12399: EMPTY
12400: LIST
12401: LIST
12402: PUSH
12403: LD_INT 25
12405: PUSH
12406: LD_INT 4
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: PUSH
12413: LD_INT 21
12415: PUSH
12416: LD_INT 1
12418: PUSH
12419: EMPTY
12420: LIST
12421: LIST
12422: PUSH
12423: LD_INT 26
12425: PUSH
12426: LD_INT 1
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: LIST
12439: PPUSH
12440: CALL_OW 69
12444: PUSH
12445: LD_EXP 20
12449: PUSH
12450: LD_EXP 19
12454: PUSH
12455: LD_EXP 51
12459: PUSH
12460: LD_EXP 39
12464: PUSH
12465: LD_EXP 49
12469: PUSH
12470: LD_EXP 48
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: LIST
12479: LIST
12480: LIST
12481: LIST
12482: DIFF
12483: ST_TO_ADDR
// if speaker then
12484: LD_VAR 0 1
12488: IFFALSE 12506
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12490: LD_VAR 0 1
12494: PUSH
12495: LD_INT 1
12497: ARRAY
12498: PPUSH
12499: LD_STRING DArtefTechnology-Sci1-2
12501: PPUSH
12502: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12506: LD_ADDR_VAR 0 1
12510: PUSH
12511: LD_INT 22
12513: PUSH
12514: LD_INT 7
12516: PUSH
12517: EMPTY
12518: LIST
12519: LIST
12520: PUSH
12521: LD_INT 23
12523: PUSH
12524: LD_INT 3
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: PUSH
12531: LD_INT 25
12533: PUSH
12534: LD_INT 4
12536: PUSH
12537: EMPTY
12538: LIST
12539: LIST
12540: PUSH
12541: LD_INT 21
12543: PUSH
12544: LD_INT 1
12546: PUSH
12547: EMPTY
12548: LIST
12549: LIST
12550: PUSH
12551: LD_INT 26
12553: PUSH
12554: LD_INT 1
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: LIST
12567: PPUSH
12568: CALL_OW 69
12572: PUSH
12573: LD_EXP 20
12577: PUSH
12578: LD_EXP 19
12582: PUSH
12583: LD_EXP 51
12587: PUSH
12588: LD_EXP 39
12592: PUSH
12593: LD_EXP 49
12597: PUSH
12598: LD_EXP 48
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: LIST
12607: LIST
12608: LIST
12609: LIST
12610: DIFF
12611: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12612: LD_VAR 0 1
12616: PUSH
12617: LD_EXP 9
12621: PUSH
12622: LD_EXP 5
12626: OR
12627: AND
12628: IFFALSE 12862
// begin if arabianDestroyed and IsOk ( Burlak ) then
12630: LD_EXP 5
12634: PUSH
12635: LD_EXP 51
12639: PPUSH
12640: CALL_OW 302
12644: AND
12645: IFFALSE 12661
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12647: LD_EXP 51
12651: PPUSH
12652: LD_STRING DArtefTechnology-Bur-2
12654: PPUSH
12655: CALL_OW 88
12659: GO 12673
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12661: LD_EXP 19
12665: PPUSH
12666: LD_STRING DArtefTechnology-JMM-2
12668: PPUSH
12669: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12673: LD_VAR 0 1
12677: PUSH
12678: LD_INT 1
12680: ARRAY
12681: PPUSH
12682: LD_STRING DArtefTechnology-RSci1-3
12684: PPUSH
12685: CALL_OW 88
// if Denis then
12689: LD_EXP 25
12693: IFFALSE 12710
// speaker := [ Denis ] else
12695: LD_ADDR_VAR 0 1
12699: PUSH
12700: LD_EXP 25
12704: PUSH
12705: EMPTY
12706: LIST
12707: ST_TO_ADDR
12708: GO 12816
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12710: LD_ADDR_VAR 0 1
12714: PUSH
12715: LD_INT 22
12717: PUSH
12718: LD_INT 7
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 23
12727: PUSH
12728: LD_INT 1
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PUSH
12735: LD_INT 25
12737: PUSH
12738: LD_INT 4
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 21
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 26
12757: PUSH
12758: LD_INT 1
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: PPUSH
12772: CALL_OW 69
12776: PUSH
12777: LD_EXP 20
12781: PUSH
12782: LD_EXP 19
12786: PUSH
12787: LD_EXP 51
12791: PUSH
12792: LD_EXP 39
12796: PUSH
12797: LD_EXP 49
12801: PUSH
12802: LD_EXP 48
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: DIFF
12815: ST_TO_ADDR
// if speaker then
12816: LD_VAR 0 1
12820: IFFALSE 12862
// if alienSpotted then
12822: LD_EXP 10
12826: IFFALSE 12846
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12828: LD_VAR 0 1
12832: PUSH
12833: LD_INT 1
12835: ARRAY
12836: PPUSH
12837: LD_STRING DArtefTechnology-Sci1-3
12839: PPUSH
12840: CALL_OW 88
12844: GO 12862
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12846: LD_VAR 0 1
12850: PUSH
12851: LD_INT 1
12853: ARRAY
12854: PPUSH
12855: LD_STRING DArtefTechnology-Sci1-3a
12857: PPUSH
12858: CALL_OW 88
// end ; DialogueOff ;
12862: CALL_OW 7
// end ;
12866: PPOPN 1
12868: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12869: LD_EXP 12
12873: IFFALSE 13068
12875: GO 12877
12877: DISABLE
12878: LD_INT 0
12880: PPUSH
// begin if Denis then
12881: LD_EXP 25
12885: IFFALSE 12902
// speaker := [ Denis ] else
12887: LD_ADDR_VAR 0 1
12891: PUSH
12892: LD_EXP 25
12896: PUSH
12897: EMPTY
12898: LIST
12899: ST_TO_ADDR
12900: GO 13008
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12902: LD_ADDR_VAR 0 1
12906: PUSH
12907: LD_INT 22
12909: PUSH
12910: LD_INT 7
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PUSH
12917: LD_INT 23
12919: PUSH
12920: LD_INT 1
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: PUSH
12927: LD_INT 25
12929: PUSH
12930: LD_INT 4
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: PUSH
12937: LD_INT 21
12939: PUSH
12940: LD_INT 1
12942: PUSH
12943: EMPTY
12944: LIST
12945: LIST
12946: PUSH
12947: LD_INT 26
12949: PUSH
12950: LD_INT 1
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: PPUSH
12964: CALL_OW 69
12968: PUSH
12969: LD_EXP 20
12973: PUSH
12974: LD_EXP 19
12978: PUSH
12979: LD_EXP 51
12983: PUSH
12984: LD_EXP 39
12988: PUSH
12989: LD_EXP 49
12993: PUSH
12994: LD_EXP 48
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: DIFF
13007: ST_TO_ADDR
// if not speaker then
13008: LD_VAR 0 1
13012: NOT
13013: IFFALSE 13017
// exit ;
13015: GO 13068
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13017: LD_VAR 0 1
13021: PUSH
13022: LD_INT 1
13024: ARRAY
13025: PPUSH
13026: LD_STRING DArtefTechnologyAm-Sci1-1
13028: PPUSH
13029: CALL_OW 88
// if IsOk ( Burlak ) then
13033: LD_EXP 51
13037: PPUSH
13038: CALL_OW 302
13042: IFFALSE 13056
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13044: LD_EXP 51
13048: PPUSH
13049: LD_STRING DArtefTechnologyAm-Bur-1
13051: PPUSH
13052: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13056: LD_EXP 19
13060: PPUSH
13061: LD_STRING DArtefTechnologyAm-JMM-1
13063: PPUSH
13064: CALL_OW 88
// end ;
13068: PPOPN 1
13070: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13071: LD_EXP 13
13075: IFFALSE 13265
13077: GO 13079
13079: DISABLE
13080: LD_INT 0
13082: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13083: LD_ADDR_VAR 0 1
13087: PUSH
13088: LD_INT 22
13090: PUSH
13091: LD_INT 7
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: LD_INT 23
13100: PUSH
13101: LD_INT 3
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: PUSH
13108: LD_INT 25
13110: PUSH
13111: LD_INT 4
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PUSH
13118: LD_INT 21
13120: PUSH
13121: LD_INT 1
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 26
13130: PUSH
13131: LD_INT 1
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: PPUSH
13145: CALL_OW 69
13149: PUSH
13150: LD_EXP 20
13154: PUSH
13155: LD_EXP 19
13159: PUSH
13160: LD_EXP 51
13164: PUSH
13165: LD_EXP 39
13169: PUSH
13170: LD_EXP 49
13174: PUSH
13175: LD_EXP 48
13179: PUSH
13180: EMPTY
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: DIFF
13188: ST_TO_ADDR
// if not speaker then
13189: LD_VAR 0 1
13193: NOT
13194: IFFALSE 13198
// exit ;
13196: GO 13265
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
13198: LD_VAR 0 1
13202: PUSH
13203: LD_INT 1
13205: ARRAY
13206: PPUSH
13207: LD_STRING DArtefTechnologyRu-RSci1-1
13209: PPUSH
13210: CALL_OW 88
// if IsOk ( Burlak ) then
13214: LD_EXP 51
13218: PPUSH
13219: CALL_OW 302
13223: IFFALSE 13237
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13225: LD_EXP 51
13229: PPUSH
13230: LD_STRING DArtefTechnologyRu-Bur-1
13232: PPUSH
13233: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
13237: LD_VAR 0 1
13241: PUSH
13242: LD_INT 1
13244: ARRAY
13245: PPUSH
13246: LD_STRING DArtefTechnologyRu-RSci1-2
13248: PPUSH
13249: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13253: LD_EXP 19
13257: PPUSH
13258: LD_STRING DArtefTechnologyRu-JMM-1
13260: PPUSH
13261: CALL_OW 88
// end ;
13265: PPOPN 1
13267: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13268: LD_INT 24
13270: PPUSH
13271: LD_INT 7
13273: PPUSH
13274: CALL_OW 321
13278: PUSH
13279: LD_INT 2
13281: EQUAL
13282: PUSH
13283: LD_INT 1
13285: PPUSH
13286: CALL_OW 255
13290: PUSH
13291: LD_INT 7
13293: EQUAL
13294: AND
13295: IFFALSE 13455
13297: GO 13299
13299: DISABLE
13300: LD_INT 0
13302: PPUSH
// begin if Denis then
13303: LD_EXP 25
13307: IFFALSE 13324
// speaker := [ Denis ] else
13309: LD_ADDR_VAR 0 1
13313: PUSH
13314: LD_EXP 25
13318: PUSH
13319: EMPTY
13320: LIST
13321: ST_TO_ADDR
13322: GO 13430
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13324: LD_ADDR_VAR 0 1
13328: PUSH
13329: LD_INT 22
13331: PUSH
13332: LD_INT 7
13334: PUSH
13335: EMPTY
13336: LIST
13337: LIST
13338: PUSH
13339: LD_INT 23
13341: PUSH
13342: LD_INT 1
13344: PUSH
13345: EMPTY
13346: LIST
13347: LIST
13348: PUSH
13349: LD_INT 25
13351: PUSH
13352: LD_INT 4
13354: PUSH
13355: EMPTY
13356: LIST
13357: LIST
13358: PUSH
13359: LD_INT 21
13361: PUSH
13362: LD_INT 1
13364: PUSH
13365: EMPTY
13366: LIST
13367: LIST
13368: PUSH
13369: LD_INT 26
13371: PUSH
13372: LD_INT 1
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: PPUSH
13386: CALL_OW 69
13390: PUSH
13391: LD_EXP 20
13395: PUSH
13396: LD_EXP 19
13400: PUSH
13401: LD_EXP 51
13405: PUSH
13406: LD_EXP 39
13410: PUSH
13411: LD_EXP 49
13415: PUSH
13416: LD_EXP 48
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: DIFF
13429: ST_TO_ADDR
// if not speaker then
13430: LD_VAR 0 1
13434: NOT
13435: IFFALSE 13439
// exit ;
13437: GO 13455
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 1
13446: ARRAY
13447: PPUSH
13448: LD_STRING DArtefTechnologyArStart-Sci1-1
13450: PPUSH
13451: CALL_OW 88
// end ;
13455: PPOPN 1
13457: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13458: LD_EXP 14
13462: IFFALSE 13743
13464: GO 13466
13466: DISABLE
13467: LD_INT 0
13469: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13470: LD_ADDR_VAR 0 1
13474: PUSH
13475: LD_INT 22
13477: PUSH
13478: LD_INT 7
13480: PUSH
13481: EMPTY
13482: LIST
13483: LIST
13484: PUSH
13485: LD_INT 23
13487: PUSH
13488: LD_INT 3
13490: PUSH
13491: EMPTY
13492: LIST
13493: LIST
13494: PUSH
13495: LD_INT 25
13497: PUSH
13498: LD_INT 4
13500: PUSH
13501: EMPTY
13502: LIST
13503: LIST
13504: PUSH
13505: LD_INT 21
13507: PUSH
13508: LD_INT 1
13510: PUSH
13511: EMPTY
13512: LIST
13513: LIST
13514: PUSH
13515: LD_INT 26
13517: PUSH
13518: LD_INT 1
13520: PUSH
13521: EMPTY
13522: LIST
13523: LIST
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: LIST
13529: LIST
13530: LIST
13531: PPUSH
13532: CALL_OW 69
13536: PUSH
13537: LD_EXP 20
13541: PUSH
13542: LD_EXP 19
13546: PUSH
13547: LD_EXP 51
13551: PUSH
13552: LD_EXP 39
13556: PUSH
13557: LD_EXP 49
13561: PUSH
13562: LD_EXP 48
13566: PUSH
13567: EMPTY
13568: LIST
13569: LIST
13570: LIST
13571: LIST
13572: LIST
13573: LIST
13574: DIFF
13575: ST_TO_ADDR
// if not speaker then
13576: LD_VAR 0 1
13580: NOT
13581: IFFALSE 13585
// exit ;
13583: GO 13743
// DialogueOn ;
13585: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13589: LD_VAR 0 1
13593: PUSH
13594: LD_INT 1
13596: ARRAY
13597: PPUSH
13598: LD_STRING DArtefTechnologyAr-RSci1-1
13600: PPUSH
13601: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13605: LD_EXP 19
13609: PPUSH
13610: LD_STRING DArtefTechnologyAr-JMM-1
13612: PPUSH
13613: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13617: LD_VAR 0 1
13621: PUSH
13622: LD_INT 1
13624: ARRAY
13625: PPUSH
13626: LD_STRING DArtefTechnologyAr-RSci1-2
13628: PPUSH
13629: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13633: LD_EXP 19
13637: PPUSH
13638: LD_STRING DArtefTechnologyAr-JMM-2
13640: PPUSH
13641: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13645: LD_VAR 0 1
13649: PUSH
13650: LD_INT 1
13652: ARRAY
13653: PPUSH
13654: LD_STRING DArtefTechnologyAr-RSci1-3
13656: PPUSH
13657: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13661: LD_EXP 19
13665: PPUSH
13666: LD_STRING DArtefTechnologyAr-JMM-3
13668: PPUSH
13669: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13673: LD_VAR 0 1
13677: PUSH
13678: LD_INT 1
13680: ARRAY
13681: PPUSH
13682: LD_STRING DArtefTechnologyAr-RSci1-4
13684: PPUSH
13685: CALL_OW 88
// if IsOk ( Burlak ) then
13689: LD_EXP 51
13693: PPUSH
13694: CALL_OW 302
13698: IFFALSE 13712
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13700: LD_EXP 51
13704: PPUSH
13705: LD_STRING DArtefTechnologyAr-Bur-4
13707: PPUSH
13708: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13712: LD_EXP 19
13716: PPUSH
13717: LD_STRING DArtefTechnologyAr-JMM-4
13719: PPUSH
13720: CALL_OW 88
// DialogueOff ;
13724: CALL_OW 7
// wait ( 0 0$45 ) ;
13728: LD_INT 1575
13730: PPUSH
13731: CALL_OW 67
// spawnOmar := true ;
13735: LD_ADDR_EXP 11
13739: PUSH
13740: LD_INT 1
13742: ST_TO_ADDR
// end ;
13743: PPOPN 1
13745: END
// every 0 0$1 trigger spawnOmar do
13746: LD_EXP 11
13750: IFFALSE 14130
13752: GO 13754
13754: DISABLE
// begin PrepareOmarAli ;
13755: CALL 7201 0 0
// if not HasTask ( Omar ) then
13759: LD_EXP 55
13763: PPUSH
13764: CALL_OW 314
13768: NOT
13769: IFFALSE 13786
// ComMoveXY ( Omar , 252 , 220 ) ;
13771: LD_EXP 55
13775: PPUSH
13776: LD_INT 252
13778: PPUSH
13779: LD_INT 220
13781: PPUSH
13782: CALL_OW 111
// if not Omar then
13786: LD_EXP 55
13790: NOT
13791: IFFALSE 13795
// exit ;
13793: GO 14130
// repeat wait ( 0 0$1 ) ;
13795: LD_INT 35
13797: PPUSH
13798: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13802: LD_EXP 55
13806: PPUSH
13807: CALL_OW 314
13811: NOT
13812: PUSH
13813: LD_EXP 55
13817: PPUSH
13818: LD_INT 252
13820: PPUSH
13821: LD_INT 220
13823: PPUSH
13824: CALL_OW 297
13828: PUSH
13829: LD_INT 6
13831: GREATER
13832: AND
13833: IFFALSE 13850
// ComMoveXY ( Omar , 252 , 220 ) ;
13835: LD_EXP 55
13839: PPUSH
13840: LD_INT 252
13842: PPUSH
13843: LD_INT 220
13845: PPUSH
13846: CALL_OW 111
// until See ( 7 , Omar ) ;
13850: LD_INT 7
13852: PPUSH
13853: LD_EXP 55
13857: PPUSH
13858: CALL_OW 292
13862: IFFALSE 13795
// CenterNowOnUnits ( Omar ) ;
13864: LD_EXP 55
13868: PPUSH
13869: CALL_OW 87
// DialogueOn ;
13873: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13877: LD_EXP 55
13881: PPUSH
13882: LD_STRING DOmar-Omar-1
13884: PPUSH
13885: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13889: LD_EXP 19
13893: PPUSH
13894: LD_STRING DOmar-JMM-1
13896: PPUSH
13897: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13901: LD_EXP 55
13905: PPUSH
13906: LD_STRING DOmar-Omar-2
13908: PPUSH
13909: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13913: LD_EXP 19
13917: PPUSH
13918: LD_STRING DOmar-JMM-2
13920: PPUSH
13921: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13925: LD_EXP 55
13929: PPUSH
13930: LD_STRING DOmar-Omar-3
13932: PPUSH
13933: CALL_OW 88
// if IsOk ( Burlak ) then
13937: LD_EXP 51
13941: PPUSH
13942: CALL_OW 302
13946: IFFALSE 13962
// Say ( Burlak , DOmar-Bur-3 ) else
13948: LD_EXP 51
13952: PPUSH
13953: LD_STRING DOmar-Bur-3
13955: PPUSH
13956: CALL_OW 88
13960: GO 13974
// Say ( JMM , DOmar-JMM-3 ) ;
13962: LD_EXP 19
13966: PPUSH
13967: LD_STRING DOmar-JMM-3
13969: PPUSH
13970: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13974: LD_EXP 55
13978: PPUSH
13979: LD_STRING DOmar-Omar-4
13981: PPUSH
13982: CALL_OW 88
// case Query ( QAccept ) of 1 :
13986: LD_STRING QAccept
13988: PPUSH
13989: CALL_OW 97
13993: PUSH
13994: LD_INT 1
13996: DOUBLE
13997: EQUAL
13998: IFTRUE 14002
14000: GO 14038
14002: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14003: LD_EXP 19
14007: PPUSH
14008: LD_STRING DQrAccept#1-JMM-1
14010: PPUSH
14011: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14015: LD_EXP 55
14019: PPUSH
14020: LD_INT 7
14022: PPUSH
14023: CALL_OW 235
// ComStop ( Omar ) ;
14027: LD_EXP 55
14031: PPUSH
14032: CALL_OW 141
// end ; 2 :
14036: GO 14087
14038: LD_INT 2
14040: DOUBLE
14041: EQUAL
14042: IFTRUE 14046
14044: GO 14086
14046: POP
// begin if IsOk ( Burlak ) then
14047: LD_EXP 51
14051: PPUSH
14052: CALL_OW 302
14056: IFFALSE 14072
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14058: LD_EXP 51
14062: PPUSH
14063: LD_STRING DQrAccept#2-Bur-1
14065: PPUSH
14066: CALL_OW 88
14070: GO 14084
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14072: LD_EXP 19
14076: PPUSH
14077: LD_STRING DQrAccept#2-JMM-1
14079: PPUSH
14080: CALL_OW 88
// end ; end ;
14084: GO 14087
14086: POP
// DialogueOff ;
14087: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14091: LD_EXP 55
14095: PPUSH
14096: CALL_OW 255
14100: PUSH
14101: LD_INT 7
14103: EQUAL
14104: IFFALSE 14115
// begin SetAchievement ( ACH_OMAR ) ;
14106: LD_STRING ACH_OMAR
14108: PPUSH
14109: CALL_OW 543
// exit ;
14113: GO 14130
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14115: LD_EXP 55
14119: PPUSH
14120: LD_INT 202
14122: PPUSH
14123: LD_INT 115
14125: PPUSH
14126: CALL_OW 111
// end ;
14130: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14131: LD_EXP 55
14135: PPUSH
14136: LD_INT 200
14138: PPUSH
14139: LD_INT 98
14141: PPUSH
14142: CALL_OW 297
14146: PUSH
14147: LD_INT 40
14149: LESS
14150: PUSH
14151: LD_EXP 2
14155: AND
14156: IFFALSE 14374
14158: GO 14160
14160: DISABLE
// begin SetSide ( Omar , 5 ) ;
14161: LD_EXP 55
14165: PPUSH
14166: LD_INT 5
14168: PPUSH
14169: CALL_OW 235
// if IsInUnit ( Omar ) then
14173: LD_EXP 55
14177: PPUSH
14178: CALL_OW 310
14182: IFFALSE 14193
// ComExitVehicle ( Omar ) ;
14184: LD_EXP 55
14188: PPUSH
14189: CALL_OW 121
// if IsInUnit ( Omar ) then
14193: LD_EXP 55
14197: PPUSH
14198: CALL_OW 310
14202: IFFALSE 14213
// ComExitBuilding ( Omar ) ;
14204: LD_EXP 55
14208: PPUSH
14209: CALL_OW 122
// wait ( 0 0$1 ) ;
14213: LD_INT 35
14215: PPUSH
14216: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14220: LD_EXP 55
14224: PPUSH
14225: LD_INT 203
14227: PPUSH
14228: LD_INT 120
14230: PPUSH
14231: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14235: LD_INT 35
14237: PPUSH
14238: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14242: LD_EXP 55
14246: PPUSH
14247: CALL_OW 306
14251: PUSH
14252: LD_EXP 55
14256: PPUSH
14257: LD_INT 203
14259: PPUSH
14260: LD_INT 120
14262: PPUSH
14263: CALL_OW 297
14267: PUSH
14268: LD_INT 6
14270: LESS
14271: OR
14272: IFFALSE 14235
// CenterNowOnUnits ( Omar ) ;
14274: LD_EXP 55
14278: PPUSH
14279: CALL_OW 87
// DialogueOn ;
14283: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14287: LD_EXP 19
14291: PPUSH
14292: LD_STRING DOmarContam-JMM-1
14294: PPUSH
14295: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14299: LD_EXP 55
14303: PPUSH
14304: LD_STRING DOmarContam-Omar-1
14306: PPUSH
14307: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14311: LD_EXP 19
14315: PPUSH
14316: LD_STRING DOmarContam-JMM-2
14318: PPUSH
14319: CALL_OW 88
// DialogueOff ;
14323: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14327: LD_INT 5
14329: PPUSH
14330: LD_INT 7
14332: PPUSH
14333: LD_INT 2
14335: PPUSH
14336: LD_INT 1
14338: PPUSH
14339: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14343: LD_INT 105
14345: PPUSH
14346: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14350: LD_EXP 55
14354: PPUSH
14355: LD_INT 203
14357: PPUSH
14358: LD_INT 120
14360: PPUSH
14361: CALL_OW 307
14365: IFFALSE 14343
// YouLost ( MothContaminate ) ;
14367: LD_STRING MothContaminate
14369: PPUSH
14370: CALL_OW 104
// end ;
14374: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14375: LD_EXP 4
14379: NOT
14380: PUSH
14381: LD_INT 22
14383: PUSH
14384: LD_INT 1
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: PUSH
14391: LD_INT 34
14393: PUSH
14394: LD_INT 8
14396: PUSH
14397: EMPTY
14398: LIST
14399: LIST
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: PPUSH
14405: CALL_OW 69
14409: AND
14410: IFFALSE 14529
14412: GO 14414
14414: DISABLE
// begin wait ( 0 0$5 ) ;
14415: LD_INT 175
14417: PPUSH
14418: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14422: LD_EXP 54
14426: PPUSH
14427: CALL_OW 302
14431: NOT
14432: PUSH
14433: LD_INT 22
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PUSH
14443: LD_INT 34
14445: PUSH
14446: LD_INT 8
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: EMPTY
14454: LIST
14455: LIST
14456: PPUSH
14457: CALL_OW 69
14461: NOT
14462: OR
14463: IFFALSE 14467
// exit ;
14465: GO 14529
// DialogueOn ;
14467: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14471: LD_EXP 54
14475: PPUSH
14476: LD_STRING DWinAmericans-Pow-1
14478: PPUSH
14479: CALL_OW 94
// if IsOk ( Burlak ) then
14483: LD_EXP 51
14487: PPUSH
14488: CALL_OW 302
14492: IFFALSE 14506
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14494: LD_EXP 51
14498: PPUSH
14499: LD_STRING DWinAmericans-Bur-1
14501: PPUSH
14502: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14506: LD_EXP 19
14510: PPUSH
14511: LD_STRING DWinAmericans-JMM-1
14513: PPUSH
14514: CALL_OW 88
// DialogueOff ;
14518: CALL_OW 7
// YouLost ( AmBomb ) ;
14522: LD_STRING AmBomb
14524: PPUSH
14525: CALL_OW 104
// end ;
14529: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14530: LD_EXP 2
14534: NOT
14535: PUSH
14536: LD_INT 22
14538: PUSH
14539: LD_INT 3
14541: PUSH
14542: EMPTY
14543: LIST
14544: LIST
14545: PUSH
14546: LD_INT 34
14548: PUSH
14549: LD_INT 48
14551: PUSH
14552: EMPTY
14553: LIST
14554: LIST
14555: PUSH
14556: EMPTY
14557: LIST
14558: LIST
14559: PPUSH
14560: CALL_OW 69
14564: AND
14565: IFFALSE 14684
14567: GO 14569
14569: DISABLE
// begin wait ( 0 0$5 ) ;
14570: LD_INT 175
14572: PPUSH
14573: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14577: LD_EXP 58
14581: PPUSH
14582: CALL_OW 302
14586: NOT
14587: PUSH
14588: LD_INT 22
14590: PUSH
14591: LD_INT 3
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: PUSH
14598: LD_INT 34
14600: PUSH
14601: LD_INT 48
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: PUSH
14608: EMPTY
14609: LIST
14610: LIST
14611: PPUSH
14612: CALL_OW 69
14616: NOT
14617: OR
14618: IFFALSE 14622
// exit ;
14620: GO 14684
// DialogueOn ;
14622: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14626: LD_EXP 58
14630: PPUSH
14631: LD_STRING DWinRussians-Pla-1
14633: PPUSH
14634: CALL_OW 94
// if IsOk ( Burlak ) then
14638: LD_EXP 51
14642: PPUSH
14643: CALL_OW 302
14647: IFFALSE 14661
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14649: LD_EXP 51
14653: PPUSH
14654: LD_STRING DWinRussians-Bur-1
14656: PPUSH
14657: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14661: LD_EXP 19
14665: PPUSH
14666: LD_STRING DWinRussians-JMM-1
14668: PPUSH
14669: CALL_OW 88
// DialogueOff ;
14673: CALL_OW 7
// YouLost ( RuBomb ) ;
14677: LD_STRING RuBomb
14679: PPUSH
14680: CALL_OW 104
// end ;
14684: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14685: LD_INT 7
14687: PPUSH
14688: LD_INT 22
14690: PUSH
14691: LD_INT 7
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PPUSH
14698: CALL_OW 70
14702: PUSH
14703: LD_EXP 4
14707: NOT
14708: AND
14709: IFFALSE 14738
14711: GO 14713
14713: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14714: LD_EXP 54
14718: PPUSH
14719: LD_STRING DSurrenderAmericans-Pow-1
14721: PPUSH
14722: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14726: LD_EXP 19
14730: PPUSH
14731: LD_STRING DSurrenderAmericans-JMM-1
14733: PPUSH
14734: CALL_OW 88
// end ;
14738: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14739: LD_INT 2
14741: PPUSH
14742: LD_INT 22
14744: PUSH
14745: LD_INT 7
14747: PUSH
14748: EMPTY
14749: LIST
14750: LIST
14751: PPUSH
14752: CALL_OW 70
14756: PUSH
14757: LD_EXP 2
14761: NOT
14762: AND
14763: PUSH
14764: LD_EXP 51
14768: AND
14769: IFFALSE 14798
14771: GO 14773
14773: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14774: LD_EXP 58
14778: PPUSH
14779: LD_STRING DSurrenderRussians-Pla-1
14781: PPUSH
14782: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14786: LD_EXP 51
14790: PPUSH
14791: LD_STRING DSurrenderRussians-Bur-1
14793: PPUSH
14794: CALL_OW 88
// end ;
14798: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14799: LD_EXP 4
14803: IFFALSE 15186
14805: GO 14807
14807: DISABLE
14808: LD_INT 0
14810: PPUSH
14811: PPUSH
14812: PPUSH
// begin MC_Kill ( 4 ) ;
14813: LD_INT 4
14815: PPUSH
14816: CALL 21604 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14820: LD_INT 1
14822: PPUSH
14823: LD_INT 7
14825: PPUSH
14826: LD_INT 1
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14836: LD_ADDR_VAR 0 3
14840: PUSH
14841: LD_INT 22
14843: PUSH
14844: LD_INT 1
14846: PUSH
14847: EMPTY
14848: LIST
14849: LIST
14850: PUSH
14851: LD_INT 26
14853: PUSH
14854: LD_INT 1
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PUSH
14861: LD_INT 23
14863: PUSH
14864: LD_INT 1
14866: PUSH
14867: EMPTY
14868: LIST
14869: LIST
14870: PUSH
14871: EMPTY
14872: LIST
14873: LIST
14874: LIST
14875: PPUSH
14876: CALL_OW 69
14880: PUSH
14881: LD_EXP 54
14885: PUSH
14886: LD_EXP 27
14890: PUSH
14891: LD_EXP 24
14895: PUSH
14896: LD_EXP 23
14900: PUSH
14901: LD_EXP 30
14905: PUSH
14906: LD_EXP 28
14910: PUSH
14911: EMPTY
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: DIFF
14919: ST_TO_ADDR
// if speaker then
14920: LD_VAR 0 3
14924: IFFALSE 14950
// begin DialogueOn ;
14926: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14930: LD_VAR 0 3
14934: PUSH
14935: LD_INT 1
14937: ARRAY
14938: PPUSH
14939: LD_STRING DSurrenderAmericans-Sol1-1a
14941: PPUSH
14942: CALL_OW 94
// DialogueOff ;
14946: CALL_OW 7
// end ; americanCapitulated := true ;
14950: LD_ADDR_EXP 6
14954: PUSH
14955: LD_INT 1
14957: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14958: LD_ADDR_VAR 0 2
14962: PUSH
14963: LD_INT 22
14965: PUSH
14966: LD_INT 1
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: LD_INT 21
14975: PUSH
14976: LD_INT 1
14978: PUSH
14979: EMPTY
14980: LIST
14981: LIST
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PPUSH
14987: CALL_OW 69
14991: PUSH
14992: LD_INT 22
14994: PUSH
14995: LD_INT 1
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: PUSH
15002: LD_INT 21
15004: PUSH
15005: LD_INT 2
15007: PUSH
15008: EMPTY
15009: LIST
15010: LIST
15011: PUSH
15012: LD_INT 1
15014: PUSH
15015: EMPTY
15016: LIST
15017: PUSH
15018: EMPTY
15019: LIST
15020: LIST
15021: LIST
15022: PPUSH
15023: CALL_OW 69
15027: ADD
15028: ST_TO_ADDR
// if tmp then
15029: LD_VAR 0 2
15033: IFFALSE 15186
// repeat wait ( 0 0$1 ) ;
15035: LD_INT 35
15037: PPUSH
15038: CALL_OW 67
// for i in tmp do
15042: LD_ADDR_VAR 0 1
15046: PUSH
15047: LD_VAR 0 2
15051: PUSH
15052: FOR_IN
15053: IFFALSE 15135
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15055: LD_VAR 0 1
15059: PPUSH
15060: CALL_OW 310
15064: PUSH
15065: LD_VAR 0 1
15069: PPUSH
15070: CALL_OW 310
15074: PPUSH
15075: CALL_OW 247
15079: PUSH
15080: LD_INT 3
15082: EQUAL
15083: AND
15084: IFFALSE 15095
// ComExitBuilding ( i ) ;
15086: LD_VAR 0 1
15090: PPUSH
15091: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15095: LD_VAR 0 1
15099: PPUSH
15100: LD_INT 122
15102: PPUSH
15103: LD_INT 242
15105: PPUSH
15106: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15110: LD_VAR 0 1
15114: PPUSH
15115: LD_INT 35
15117: PPUSH
15118: CALL_OW 308
15122: IFFALSE 15133
// RemoveUnit ( i ) ;
15124: LD_VAR 0 1
15128: PPUSH
15129: CALL_OW 64
// end ;
15133: GO 15052
15135: POP
15136: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15137: LD_INT 22
15139: PUSH
15140: LD_INT 1
15142: PUSH
15143: EMPTY
15144: LIST
15145: LIST
15146: PUSH
15147: LD_INT 2
15149: PUSH
15150: LD_INT 21
15152: PUSH
15153: LD_INT 1
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PUSH
15160: LD_INT 33
15162: PUSH
15163: LD_INT 1
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: LIST
15174: PUSH
15175: EMPTY
15176: LIST
15177: LIST
15178: PPUSH
15179: CALL_OW 69
15183: NOT
15184: IFFALSE 15035
// end ;
15186: PPOPN 3
15188: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15189: LD_EXP 2
15193: IFFALSE 15594
15195: GO 15197
15197: DISABLE
15198: LD_INT 0
15200: PPUSH
15201: PPUSH
15202: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15203: LD_INT 35
15205: PPUSH
15206: CALL_OW 67
// until IsDead ( Yakotich ) ;
15210: LD_EXP 59
15214: PPUSH
15215: CALL_OW 301
15219: IFFALSE 15203
// MC_Kill ( 2 ) ;
15221: LD_INT 2
15223: PPUSH
15224: CALL 21604 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15228: LD_INT 3
15230: PPUSH
15231: LD_INT 7
15233: PPUSH
15234: LD_INT 1
15236: PPUSH
15237: LD_INT 1
15239: PPUSH
15240: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15244: LD_ADDR_VAR 0 3
15248: PUSH
15249: LD_INT 22
15251: PUSH
15252: LD_INT 3
15254: PUSH
15255: EMPTY
15256: LIST
15257: LIST
15258: PUSH
15259: LD_INT 26
15261: PUSH
15262: LD_INT 1
15264: PUSH
15265: EMPTY
15266: LIST
15267: LIST
15268: PUSH
15269: LD_INT 23
15271: PUSH
15272: LD_INT 3
15274: PUSH
15275: EMPTY
15276: LIST
15277: LIST
15278: PUSH
15279: EMPTY
15280: LIST
15281: LIST
15282: LIST
15283: PPUSH
15284: CALL_OW 69
15288: PUSH
15289: LD_EXP 58
15293: PUSH
15294: LD_EXP 59
15298: PUSH
15299: EMPTY
15300: LIST
15301: LIST
15302: DIFF
15303: ST_TO_ADDR
// if speaker then
15304: LD_VAR 0 3
15308: IFFALSE 15358
// begin DialogueOn ;
15310: CALL_OW 6
// if Burlak then
15314: LD_EXP 51
15318: IFFALSE 15338
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15320: LD_VAR 0 3
15324: PUSH
15325: LD_INT 1
15327: ARRAY
15328: PPUSH
15329: LD_STRING DSurrenderRussians-RSol1-1
15331: PPUSH
15332: CALL_OW 94
15336: GO 15354
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15338: LD_VAR 0 3
15342: PUSH
15343: LD_INT 1
15345: ARRAY
15346: PPUSH
15347: LD_STRING DSurrenderRussians-RSol1-1a
15349: PPUSH
15350: CALL_OW 94
// DialogueOff ;
15354: CALL_OW 7
// end ; russianCapitulated := true ;
15358: LD_ADDR_EXP 7
15362: PUSH
15363: LD_INT 1
15365: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15366: LD_ADDR_VAR 0 2
15370: PUSH
15371: LD_INT 22
15373: PUSH
15374: LD_INT 3
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 21
15383: PUSH
15384: LD_INT 1
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: EMPTY
15392: LIST
15393: LIST
15394: PPUSH
15395: CALL_OW 69
15399: PUSH
15400: LD_INT 22
15402: PUSH
15403: LD_INT 3
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: PUSH
15410: LD_INT 21
15412: PUSH
15413: LD_INT 2
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: PUSH
15420: LD_INT 1
15422: PUSH
15423: EMPTY
15424: LIST
15425: PUSH
15426: EMPTY
15427: LIST
15428: LIST
15429: LIST
15430: PPUSH
15431: CALL_OW 69
15435: ADD
15436: ST_TO_ADDR
// if tmp then
15437: LD_VAR 0 2
15441: IFFALSE 15594
// repeat wait ( 0 0$1 ) ;
15443: LD_INT 35
15445: PPUSH
15446: CALL_OW 67
// for i in tmp do
15450: LD_ADDR_VAR 0 1
15454: PUSH
15455: LD_VAR 0 2
15459: PUSH
15460: FOR_IN
15461: IFFALSE 15543
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15463: LD_VAR 0 1
15467: PPUSH
15468: CALL_OW 310
15472: PUSH
15473: LD_VAR 0 1
15477: PPUSH
15478: CALL_OW 310
15482: PPUSH
15483: CALL_OW 247
15487: PUSH
15488: LD_INT 3
15490: EQUAL
15491: AND
15492: IFFALSE 15503
// ComExitBuilding ( i ) ;
15494: LD_VAR 0 1
15498: PPUSH
15499: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15503: LD_VAR 0 1
15507: PPUSH
15508: LD_INT 154
15510: PPUSH
15511: LD_INT 1
15513: PPUSH
15514: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15518: LD_VAR 0 1
15522: PPUSH
15523: LD_INT 36
15525: PPUSH
15526: CALL_OW 308
15530: IFFALSE 15541
// RemoveUnit ( i ) ;
15532: LD_VAR 0 1
15536: PPUSH
15537: CALL_OW 64
// end ;
15541: GO 15460
15543: POP
15544: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15545: LD_INT 22
15547: PUSH
15548: LD_INT 3
15550: PUSH
15551: EMPTY
15552: LIST
15553: LIST
15554: PUSH
15555: LD_INT 2
15557: PUSH
15558: LD_INT 21
15560: PUSH
15561: LD_INT 1
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: PUSH
15568: LD_INT 33
15570: PUSH
15571: LD_INT 1
15573: PUSH
15574: EMPTY
15575: LIST
15576: LIST
15577: PUSH
15578: EMPTY
15579: LIST
15580: LIST
15581: LIST
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: PPUSH
15587: CALL_OW 69
15591: NOT
15592: IFFALSE 15443
// end ;
15594: PPOPN 3
15596: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15597: LD_INT 22
15599: PUSH
15600: LD_INT 8
15602: PUSH
15603: EMPTY
15604: LIST
15605: LIST
15606: PUSH
15607: LD_INT 21
15609: PUSH
15610: LD_INT 1
15612: PUSH
15613: EMPTY
15614: LIST
15615: LIST
15616: PUSH
15617: LD_INT 23
15619: PUSH
15620: LD_INT 2
15622: PUSH
15623: EMPTY
15624: LIST
15625: LIST
15626: PUSH
15627: EMPTY
15628: LIST
15629: LIST
15630: LIST
15631: PPUSH
15632: CALL_OW 69
15636: PUSH
15637: LD_INT 18
15639: LESS
15640: PUSH
15641: LD_EXP 57
15645: PPUSH
15646: CALL_OW 301
15650: OR
15651: PUSH
15652: LD_INT 324
15654: PPUSH
15655: CALL_OW 255
15659: PUSH
15660: LD_INT 7
15662: EQUAL
15663: OR
15664: IFFALSE 15677
15666: GO 15668
15668: DISABLE
// legionDestroyed := true ;
15669: LD_ADDR_EXP 3
15673: PUSH
15674: LD_INT 1
15676: ST_TO_ADDR
15677: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15678: LD_INT 22
15680: PUSH
15681: LD_INT 2
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PUSH
15688: LD_INT 21
15690: PUSH
15691: LD_INT 1
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: LD_INT 23
15700: PUSH
15701: LD_INT 2
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: LIST
15712: PPUSH
15713: CALL_OW 69
15717: PUSH
15718: LD_INT 9
15720: LESS
15721: IFFALSE 15734
15723: GO 15725
15725: DISABLE
// arabianDestroyed := true ;
15726: LD_ADDR_EXP 5
15730: PUSH
15731: LD_INT 1
15733: ST_TO_ADDR
15734: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15735: LD_EXP 5
15739: IFFALSE 15983
15741: GO 15743
15743: DISABLE
15744: LD_INT 0
15746: PPUSH
15747: PPUSH
// begin MC_Kill ( 1 ) ;
15748: LD_INT 1
15750: PPUSH
15751: CALL 21604 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15755: LD_ADDR_VAR 0 2
15759: PUSH
15760: LD_INT 22
15762: PUSH
15763: LD_INT 2
15765: PUSH
15766: EMPTY
15767: LIST
15768: LIST
15769: PUSH
15770: LD_INT 21
15772: PUSH
15773: LD_INT 1
15775: PUSH
15776: EMPTY
15777: LIST
15778: LIST
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PPUSH
15784: CALL_OW 69
15788: PUSH
15789: LD_INT 22
15791: PUSH
15792: LD_INT 8
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: PUSH
15799: LD_INT 21
15801: PUSH
15802: LD_INT 2
15804: PUSH
15805: EMPTY
15806: LIST
15807: LIST
15808: PUSH
15809: LD_INT 1
15811: PUSH
15812: EMPTY
15813: LIST
15814: PUSH
15815: EMPTY
15816: LIST
15817: LIST
15818: LIST
15819: PPUSH
15820: CALL_OW 69
15824: ADD
15825: ST_TO_ADDR
// if tmp then
15826: LD_VAR 0 2
15830: IFFALSE 15983
// repeat wait ( 0 0$1 ) ;
15832: LD_INT 35
15834: PPUSH
15835: CALL_OW 67
// for i in tmp do
15839: LD_ADDR_VAR 0 1
15843: PUSH
15844: LD_VAR 0 2
15848: PUSH
15849: FOR_IN
15850: IFFALSE 15932
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15852: LD_VAR 0 1
15856: PPUSH
15857: CALL_OW 310
15861: PUSH
15862: LD_VAR 0 1
15866: PPUSH
15867: CALL_OW 310
15871: PPUSH
15872: CALL_OW 247
15876: PUSH
15877: LD_INT 3
15879: EQUAL
15880: AND
15881: IFFALSE 15892
// ComExitBuilding ( i ) ;
15883: LD_VAR 0 1
15887: PPUSH
15888: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15892: LD_VAR 0 1
15896: PPUSH
15897: LD_INT 254
15899: PPUSH
15900: LD_INT 268
15902: PPUSH
15903: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15907: LD_VAR 0 1
15911: PPUSH
15912: LD_INT 34
15914: PPUSH
15915: CALL_OW 308
15919: IFFALSE 15930
// RemoveUnit ( i ) ;
15921: LD_VAR 0 1
15925: PPUSH
15926: CALL_OW 64
// end ;
15930: GO 15849
15932: POP
15933: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15934: LD_INT 22
15936: PUSH
15937: LD_INT 2
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: PUSH
15944: LD_INT 2
15946: PUSH
15947: LD_INT 21
15949: PUSH
15950: LD_INT 1
15952: PUSH
15953: EMPTY
15954: LIST
15955: LIST
15956: PUSH
15957: LD_INT 33
15959: PUSH
15960: LD_INT 1
15962: PUSH
15963: EMPTY
15964: LIST
15965: LIST
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: LIST
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: PPUSH
15976: CALL_OW 69
15980: NOT
15981: IFFALSE 15832
// end ;
15983: PPOPN 2
15985: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15986: LD_EXP 3
15990: IFFALSE 16342
15992: GO 15994
15994: DISABLE
15995: LD_INT 0
15997: PPUSH
15998: PPUSH
// begin MC_Kill ( 3 ) ;
15999: LD_INT 3
16001: PPUSH
16002: CALL 21604 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16006: LD_INT 8
16008: PPUSH
16009: LD_INT 7
16011: PPUSH
16012: LD_INT 1
16014: PPUSH
16015: LD_INT 1
16017: PPUSH
16018: CALL_OW 80
// DialogueOn ;
16022: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16026: LD_EXP 56
16030: PPUSH
16031: LD_STRING D15-Szulc-1
16033: PPUSH
16034: CALL_OW 94
// DialogueOff ;
16038: CALL_OW 7
// legionCapitulated := true ;
16042: LD_ADDR_EXP 8
16046: PUSH
16047: LD_INT 1
16049: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16050: LD_ADDR_VAR 0 1
16054: PUSH
16055: LD_INT 22
16057: PUSH
16058: LD_INT 8
16060: PUSH
16061: EMPTY
16062: LIST
16063: LIST
16064: PUSH
16065: LD_INT 21
16067: PUSH
16068: LD_INT 3
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: LD_INT 23
16077: PUSH
16078: LD_INT 3
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL_OW 69
16094: PUSH
16095: FOR_IN
16096: IFFALSE 16112
// SetLives ( i , 3 ) ;
16098: LD_VAR 0 1
16102: PPUSH
16103: LD_INT 3
16105: PPUSH
16106: CALL_OW 234
16110: GO 16095
16112: POP
16113: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16114: LD_ADDR_VAR 0 2
16118: PUSH
16119: LD_INT 22
16121: PUSH
16122: LD_INT 8
16124: PUSH
16125: EMPTY
16126: LIST
16127: LIST
16128: PUSH
16129: LD_INT 21
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: EMPTY
16140: LIST
16141: LIST
16142: PPUSH
16143: CALL_OW 69
16147: PUSH
16148: LD_INT 22
16150: PUSH
16151: LD_INT 8
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: PUSH
16158: LD_INT 21
16160: PUSH
16161: LD_INT 2
16163: PUSH
16164: EMPTY
16165: LIST
16166: LIST
16167: PUSH
16168: LD_INT 1
16170: PUSH
16171: EMPTY
16172: LIST
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: LIST
16178: PPUSH
16179: CALL_OW 69
16183: ADD
16184: ST_TO_ADDR
// if tmp then
16185: LD_VAR 0 2
16189: IFFALSE 16342
// repeat wait ( 0 0$1 ) ;
16191: LD_INT 35
16193: PPUSH
16194: CALL_OW 67
// for i in tmp do
16198: LD_ADDR_VAR 0 1
16202: PUSH
16203: LD_VAR 0 2
16207: PUSH
16208: FOR_IN
16209: IFFALSE 16291
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16211: LD_VAR 0 1
16215: PPUSH
16216: CALL_OW 310
16220: PUSH
16221: LD_VAR 0 1
16225: PPUSH
16226: CALL_OW 310
16230: PPUSH
16231: CALL_OW 247
16235: PUSH
16236: LD_INT 3
16238: EQUAL
16239: AND
16240: IFFALSE 16251
// ComExitBuilding ( i ) ;
16242: LD_VAR 0 1
16246: PPUSH
16247: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16251: LD_VAR 0 1
16255: PPUSH
16256: LD_INT 10
16258: PPUSH
16259: LD_INT 1
16261: PPUSH
16262: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16266: LD_VAR 0 1
16270: PPUSH
16271: LD_INT 32
16273: PPUSH
16274: CALL_OW 308
16278: IFFALSE 16289
// RemoveUnit ( i ) ;
16280: LD_VAR 0 1
16284: PPUSH
16285: CALL_OW 64
// end ;
16289: GO 16208
16291: POP
16292: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16293: LD_INT 22
16295: PUSH
16296: LD_INT 8
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: PUSH
16303: LD_INT 2
16305: PUSH
16306: LD_INT 21
16308: PUSH
16309: LD_INT 1
16311: PUSH
16312: EMPTY
16313: LIST
16314: LIST
16315: PUSH
16316: LD_INT 33
16318: PUSH
16319: LD_INT 1
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: LIST
16330: PUSH
16331: EMPTY
16332: LIST
16333: LIST
16334: PPUSH
16335: CALL_OW 69
16339: NOT
16340: IFFALSE 16191
// end ;
16342: PPOPN 2
16344: END
// every 0 0$10 trigger legionDestroyed and americanDestroyed and arabianAttacked and not arabianDestroyed and tick >= 30 30$00 do
16345: LD_EXP 3
16349: PUSH
16350: LD_EXP 4
16354: AND
16355: PUSH
16356: LD_EXP 18
16360: AND
16361: PUSH
16362: LD_EXP 5
16366: NOT
16367: AND
16368: PUSH
16369: LD_OWVAR 1
16373: PUSH
16374: LD_INT 63000
16376: GREATEREQUAL
16377: AND
16378: IFFALSE 16387
16380: GO 16382
16382: DISABLE
// AllianceSupport ;
16383: CALL 4642 0 0
16387: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16388: LD_EXP 4
16392: PUSH
16393: LD_EXP 2
16397: AND
16398: PUSH
16399: LD_EXP 3
16403: AND
16404: PUSH
16405: LD_EXP 5
16409: AND
16410: PUSH
16411: LD_EXP 6
16415: AND
16416: PUSH
16417: LD_EXP 7
16421: AND
16422: PUSH
16423: LD_EXP 8
16427: AND
16428: PUSH
16429: LD_EXP 55
16433: PPUSH
16434: CALL_OW 255
16438: PUSH
16439: LD_INT 5
16441: NONEQUAL
16442: PUSH
16443: LD_EXP 55
16447: PPUSH
16448: CALL_OW 301
16452: OR
16453: PUSH
16454: LD_EXP 55
16458: PPUSH
16459: CALL_OW 305
16463: NOT
16464: OR
16465: AND
16466: IFFALSE 17857
16468: GO 16470
16470: DISABLE
16471: LD_INT 0
16473: PPUSH
16474: PPUSH
// begin wait ( 0 0$5 ) ;
16475: LD_INT 175
16477: PPUSH
16478: CALL_OW 67
// music_class := 5 ;
16482: LD_ADDR_OWVAR 72
16486: PUSH
16487: LD_INT 5
16489: ST_TO_ADDR
// music_nat := 5 ;
16490: LD_ADDR_OWVAR 71
16494: PUSH
16495: LD_INT 5
16497: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16498: LD_EXP 15
16502: PUSH
16503: LD_INT 3
16505: LESS
16506: IFFALSE 16515
// SetAchievement ( ACH_ECONOMY ) ;
16508: LD_STRING ACH_ECONOMY
16510: PPUSH
16511: CALL_OW 543
// if tick < 60 60$00 then
16515: LD_OWVAR 1
16519: PUSH
16520: LD_INT 126000
16522: LESS
16523: IFFALSE 16539
// begin wait ( 3 ) ;
16525: LD_INT 3
16527: PPUSH
16528: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16532: LD_STRING ACH_ASPEED_19
16534: PPUSH
16535: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16539: LD_EXP 19
16543: PPUSH
16544: CALL_OW 87
// InGameOn ;
16548: CALL_OW 8
// DialogueOn ;
16552: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16556: LD_EXP 19
16560: PPUSH
16561: LD_STRING DEnd-JMM-JMM-1
16563: PPUSH
16564: CALL_OW 88
// if Joan then
16568: LD_EXP 34
16572: IFFALSE 16588
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16574: LD_EXP 34
16578: PPUSH
16579: LD_STRING DEnd-JMM-Joan-1
16581: PPUSH
16582: CALL_OW 88
16586: GO 16632
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16588: LD_EXP 21
16592: PUSH
16593: LD_EXP 21
16597: PPUSH
16598: CALL_OW 255
16602: PUSH
16603: LD_INT 7
16605: EQUAL
16606: AND
16607: PUSH
16608: LD_EXP 21
16612: PPUSH
16613: CALL_OW 305
16617: AND
16618: IFFALSE 16632
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16620: LD_EXP 21
16624: PPUSH
16625: LD_STRING DEnd-JMM-Lisa-1
16627: PPUSH
16628: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16632: LD_EXP 31
16636: PUSH
16637: LD_EXP 31
16641: PPUSH
16642: CALL_OW 305
16646: AND
16647: IFFALSE 16661
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16649: LD_EXP 31
16653: PPUSH
16654: LD_STRING DEnd-JMM-Frank-1
16656: PPUSH
16657: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16661: LD_EXP 24
16665: PUSH
16666: LD_EXP 24
16670: PPUSH
16671: CALL_OW 255
16675: PUSH
16676: LD_INT 7
16678: EQUAL
16679: AND
16680: PUSH
16681: LD_EXP 24
16685: PPUSH
16686: CALL_OW 305
16690: AND
16691: IFFALSE 16705
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16693: LD_EXP 24
16697: PPUSH
16698: LD_STRING DEnd-JMM-Cyrus-1
16700: PPUSH
16701: CALL_OW 88
// if Burlak then
16705: LD_EXP 51
16709: IFFALSE 16723
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16711: LD_EXP 51
16715: PPUSH
16716: LD_STRING DEnd-JMM-Bur-1
16718: PPUSH
16719: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16723: LD_EXP 34
16727: PUSH
16728: LD_EXP 21
16732: AND
16733: PUSH
16734: LD_EXP 21
16738: PPUSH
16739: CALL_OW 255
16743: PUSH
16744: LD_INT 7
16746: EQUAL
16747: AND
16748: PUSH
16749: LD_EXP 21
16753: PPUSH
16754: CALL_OW 305
16758: AND
16759: IFFALSE 16773
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16761: LD_EXP 21
16765: PPUSH
16766: LD_STRING DEnd-Burlak-Lisa-1
16768: PPUSH
16769: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16773: LD_EXP 52
16777: PUSH
16778: LD_EXP 52
16782: PPUSH
16783: CALL_OW 305
16787: AND
16788: IFFALSE 16802
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16790: LD_EXP 52
16794: PPUSH
16795: LD_STRING DEnd-JMM-Bel-1
16797: PPUSH
16798: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16802: LD_EXP 53
16806: PUSH
16807: LD_EXP 53
16811: PPUSH
16812: CALL_OW 305
16816: AND
16817: IFFALSE 16831
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16819: LD_EXP 53
16823: PPUSH
16824: LD_STRING DEnd-JMM-Gny-1
16826: PPUSH
16827: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16831: LD_EXP 29
16835: PUSH
16836: LD_EXP 29
16840: PPUSH
16841: CALL_OW 255
16845: PUSH
16846: LD_INT 7
16848: EQUAL
16849: AND
16850: PUSH
16851: LD_EXP 29
16855: PPUSH
16856: CALL_OW 305
16860: AND
16861: IFFALSE 16875
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16863: LD_EXP 29
16867: PPUSH
16868: LD_STRING DEnd-JMM-Corn-1
16870: PPUSH
16871: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16875: LD_EXP 22
16879: PUSH
16880: LD_EXP 22
16884: PPUSH
16885: CALL_OW 255
16889: PUSH
16890: LD_INT 7
16892: EQUAL
16893: AND
16894: PUSH
16895: LD_EXP 22
16899: PPUSH
16900: CALL_OW 305
16904: AND
16905: IFFALSE 16919
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16907: LD_EXP 22
16911: PPUSH
16912: LD_STRING DEnd-JMM-Don-1
16914: PPUSH
16915: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16919: LD_EXP 23
16923: PUSH
16924: LD_EXP 23
16928: PPUSH
16929: CALL_OW 255
16933: PUSH
16934: LD_INT 7
16936: EQUAL
16937: AND
16938: PUSH
16939: LD_EXP 23
16943: PPUSH
16944: CALL_OW 305
16948: AND
16949: IFFALSE 16963
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16951: LD_EXP 23
16955: PPUSH
16956: LD_STRING DEnd-JMM-Bobby-1
16958: PPUSH
16959: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16963: LD_EXP 25
16967: PUSH
16968: LD_EXP 25
16972: PPUSH
16973: CALL_OW 255
16977: PUSH
16978: LD_INT 7
16980: EQUAL
16981: AND
16982: PUSH
16983: LD_EXP 25
16987: PPUSH
16988: CALL_OW 305
16992: AND
16993: IFFALSE 17007
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16995: LD_EXP 25
16999: PPUSH
17000: LD_STRING DEnd-JMM-Den-1
17002: PPUSH
17003: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17007: LD_EXP 27
17011: PUSH
17012: LD_EXP 27
17016: PPUSH
17017: CALL_OW 255
17021: PUSH
17022: LD_INT 7
17024: EQUAL
17025: AND
17026: PUSH
17027: LD_EXP 27
17031: PPUSH
17032: CALL_OW 305
17036: AND
17037: IFFALSE 17051
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17039: LD_EXP 27
17043: PPUSH
17044: LD_STRING DEnd-JMM-Glad-1
17046: PPUSH
17047: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17051: LD_EXP 32
17055: PUSH
17056: LD_EXP 32
17060: PPUSH
17061: CALL_OW 255
17065: PUSH
17066: LD_INT 7
17068: EQUAL
17069: AND
17070: PUSH
17071: LD_EXP 32
17075: PPUSH
17076: CALL_OW 305
17080: AND
17081: IFFALSE 17095
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17083: LD_EXP 32
17087: PPUSH
17088: LD_STRING DEnd-JMM-Yam-1
17090: PPUSH
17091: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17095: LD_EXP 26
17099: PUSH
17100: LD_EXP 26
17104: PPUSH
17105: CALL_OW 255
17109: PUSH
17110: LD_INT 7
17112: EQUAL
17113: AND
17114: PUSH
17115: LD_EXP 26
17119: PPUSH
17120: CALL_OW 305
17124: AND
17125: IFFALSE 17139
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17127: LD_EXP 26
17131: PPUSH
17132: LD_STRING DEnd-JMM-Brown-1
17134: PPUSH
17135: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17139: LD_EXP 36
17143: PUSH
17144: LD_EXP 36
17148: PPUSH
17149: CALL_OW 255
17153: PUSH
17154: LD_INT 7
17156: EQUAL
17157: AND
17158: PUSH
17159: LD_EXP 36
17163: PPUSH
17164: CALL_OW 305
17168: AND
17169: IFFALSE 17183
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17171: LD_EXP 36
17175: PPUSH
17176: LD_STRING DEnd-JMM-Con-1
17178: PPUSH
17179: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17183: LD_EXP 30
17187: PUSH
17188: LD_EXP 30
17192: PPUSH
17193: CALL_OW 255
17197: PUSH
17198: LD_INT 7
17200: EQUAL
17201: AND
17202: PUSH
17203: LD_EXP 30
17207: PPUSH
17208: CALL_OW 305
17212: AND
17213: IFFALSE 17227
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17215: LD_EXP 30
17219: PPUSH
17220: LD_STRING DEnd-JMM-Gary-1
17222: PPUSH
17223: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17227: LD_EXP 33
17231: PUSH
17232: LD_EXP 20
17236: AND
17237: PUSH
17238: LD_EXP 33
17242: PPUSH
17243: CALL_OW 305
17247: AND
17248: IFFALSE 17262
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17250: LD_EXP 33
17254: PPUSH
17255: LD_STRING DEnd-JMM-Sim-1
17257: PPUSH
17258: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17262: LD_EXP 28
17266: PUSH
17267: LD_EXP 28
17271: PPUSH
17272: CALL_OW 255
17276: PUSH
17277: LD_INT 7
17279: EQUAL
17280: AND
17281: PUSH
17282: LD_EXP 28
17286: PPUSH
17287: CALL_OW 305
17291: AND
17292: IFFALSE 17306
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17294: LD_EXP 28
17298: PPUSH
17299: LD_STRING DEnd-JMM-VanH-1
17301: PPUSH
17302: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17306: LD_EXP 41
17310: PUSH
17311: LD_EXP 41
17315: PPUSH
17316: CALL_OW 305
17320: AND
17321: IFFALSE 17335
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17323: LD_EXP 41
17327: PPUSH
17328: LD_STRING DEnd-JMM-Dol-1
17330: PPUSH
17331: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17335: LD_EXP 45
17339: PUSH
17340: LD_EXP 45
17344: PPUSH
17345: CALL_OW 305
17349: AND
17350: IFFALSE 17364
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17352: LD_EXP 45
17356: PPUSH
17357: LD_STRING DEnd-JMM-Kap-1
17359: PPUSH
17360: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17364: LD_EXP 48
17368: PUSH
17369: LD_EXP 48
17373: PPUSH
17374: CALL_OW 305
17378: AND
17379: IFFALSE 17393
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17381: LD_EXP 48
17385: PPUSH
17386: LD_STRING DEnd-JMM-Kov-1
17388: PPUSH
17389: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17393: LD_EXP 43
17397: PUSH
17398: LD_EXP 43
17402: PPUSH
17403: CALL_OW 305
17407: AND
17408: IFFALSE 17422
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17410: LD_EXP 43
17414: PPUSH
17415: LD_STRING DEnd-JMM-Sch-1
17417: PPUSH
17418: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17422: LD_EXP 39
17426: PUSH
17427: LD_EXP 39
17431: PPUSH
17432: CALL_OW 305
17436: AND
17437: IFFALSE 17451
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17439: LD_EXP 39
17443: PPUSH
17444: LD_STRING DEnd-JMM-Tit-1
17446: PPUSH
17447: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17451: LD_EXP 44
17455: PUSH
17456: LD_EXP 44
17460: PPUSH
17461: CALL_OW 305
17465: AND
17466: IFFALSE 17480
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17468: LD_EXP 44
17472: PPUSH
17473: LD_STRING DEnd-JMM-Obl-1
17475: PPUSH
17476: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17480: LD_EXP 46
17484: PUSH
17485: LD_EXP 46
17489: PPUSH
17490: CALL_OW 305
17494: AND
17495: IFFALSE 17509
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17497: LD_EXP 46
17501: PPUSH
17502: LD_STRING DEnd-JMM-Lip-1
17504: PPUSH
17505: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17509: LD_EXP 40
17513: PUSH
17514: LD_EXP 40
17518: PPUSH
17519: CALL_OW 305
17523: AND
17524: PUSH
17525: LD_EXP 51
17529: AND
17530: IFFALSE 17544
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17532: LD_EXP 40
17536: PPUSH
17537: LD_STRING DEnd-Burlak-Fad-1
17539: PPUSH
17540: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17544: LD_EXP 47
17548: PUSH
17549: LD_EXP 47
17553: PPUSH
17554: CALL_OW 305
17558: AND
17559: IFFALSE 17573
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17561: LD_EXP 47
17565: PPUSH
17566: LD_STRING DEnd-Burlak-Ptr-1
17568: PPUSH
17569: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17573: LD_EXP 49
17577: PUSH
17578: LD_EXP 49
17582: PPUSH
17583: CALL_OW 305
17587: AND
17588: IFFALSE 17602
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17590: LD_EXP 49
17594: PPUSH
17595: LD_STRING DEnd-Burlak-Kuz-1
17597: PPUSH
17598: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17602: LD_EXP 38
17606: PUSH
17607: LD_EXP 38
17611: PPUSH
17612: CALL_OW 305
17616: AND
17617: PUSH
17618: LD_EXP 51
17622: AND
17623: IFFALSE 17637
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17625: LD_EXP 38
17629: PPUSH
17630: LD_STRING DEnd-Burlak-Kir-1
17632: PPUSH
17633: CALL_OW 88
// if Burlak then
17637: LD_EXP 51
17641: IFFALSE 17655
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17643: LD_EXP 19
17647: PPUSH
17648: LD_STRING DEnd-Burlak-JMM-1
17650: PPUSH
17651: CALL_OW 88
// dwait ( 0 0$2 ) ;
17655: LD_INT 70
17657: PPUSH
17658: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17662: LD_EXP 56
17666: PPUSH
17667: LD_STRING DEnd-Szulc
17669: PPUSH
17670: CALL_OW 94
// dwait ( 0 0$1 ) ;
17674: LD_INT 35
17676: PPUSH
17677: CALL_OW 68
// if IsLive ( Burlak ) then
17681: LD_EXP 51
17685: PPUSH
17686: CALL_OW 300
17690: IFFALSE 17702
// med1 := 1 else
17692: LD_ADDR_VAR 0 1
17696: PUSH
17697: LD_INT 1
17699: ST_TO_ADDR
17700: GO 17711
// med1 := - 1 ;
17702: LD_ADDR_VAR 0 1
17706: PUSH
17707: LD_INT 1
17709: NEG
17710: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17711: LD_EXP 12
17715: PUSH
17716: LD_EXP 13
17720: AND
17721: PUSH
17722: LD_EXP 14
17726: AND
17727: IFFALSE 17739
// med2 := 1 else
17729: LD_ADDR_VAR 0 2
17733: PUSH
17734: LD_INT 1
17736: ST_TO_ADDR
17737: GO 17748
// med2 := - 1 ;
17739: LD_ADDR_VAR 0 2
17743: PUSH
17744: LD_INT 1
17746: NEG
17747: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17748: LD_STRING Hero
17750: PPUSH
17751: LD_INT 1
17753: PPUSH
17754: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17758: LD_STRING Artefact
17760: PPUSH
17761: LD_VAR 0 2
17765: PPUSH
17766: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17770: LD_STRING ReconcileBurlak
17772: PPUSH
17773: LD_VAR 0 1
17777: PPUSH
17778: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17782: LD_OWVAR 67
17786: PUSH
17787: LD_INT 3
17789: GREATEREQUAL
17790: PUSH
17791: LD_VAR 0 1
17795: PUSH
17796: LD_INT 1
17798: EQUAL
17799: AND
17800: PUSH
17801: LD_VAR 0 2
17805: PUSH
17806: LD_INT 1
17808: EQUAL
17809: AND
17810: IFFALSE 17822
// SetAchievementEX ( ACH_AMER , 19 ) ;
17812: LD_STRING ACH_AMER
17814: PPUSH
17815: LD_INT 19
17817: PPUSH
17818: CALL_OW 564
// GiveMedals ( MAIN ) ;
17822: LD_STRING MAIN
17824: PPUSH
17825: CALL_OW 102
// InGameOff ;
17829: CALL_OW 9
// DialogueOff ;
17833: CALL_OW 7
// music_nat := 1 ;
17837: LD_ADDR_OWVAR 71
17841: PUSH
17842: LD_INT 1
17844: ST_TO_ADDR
// music_class := 4 ;
17845: LD_ADDR_OWVAR 72
17849: PUSH
17850: LD_INT 4
17852: ST_TO_ADDR
// YouWin ;
17853: CALL_OW 103
// end ; end_of_file
17857: PPOPN 2
17859: END
// export function InitNature ; begin
17860: LD_INT 0
17862: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17863: LD_INT 3
17865: PPUSH
17866: LD_INT 3
17868: PPUSH
17869: LD_INT 2
17871: PPUSH
17872: LD_INT 1
17874: PPUSH
17875: LD_INT 1
17877: PPUSH
17878: LD_INT 0
17880: PPUSH
17881: LD_INT 0
17883: PPUSH
17884: LD_INT 17
17886: PPUSH
17887: LD_INT 0
17889: PPUSH
17890: CALL 85351 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17894: LD_INT 2
17896: PPUSH
17897: LD_INT 1
17899: PPUSH
17900: LD_INT 1
17902: PPUSH
17903: LD_INT 1
17905: PPUSH
17906: LD_INT 1
17908: PPUSH
17909: LD_INT 0
17911: PPUSH
17912: LD_INT 0
17914: PPUSH
17915: LD_INT 18
17917: PPUSH
17918: LD_INT 0
17920: PPUSH
17921: CALL 85351 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17925: LD_INT 4
17927: PPUSH
17928: LD_INT 1
17930: PPUSH
17931: LD_INT 2
17933: PPUSH
17934: LD_INT 4
17936: PPUSH
17937: LD_INT 2
17939: PPUSH
17940: LD_INT 1
17942: PPUSH
17943: LD_INT 0
17945: PPUSH
17946: LD_INT 19
17948: PPUSH
17949: LD_INT 0
17951: PPUSH
17952: CALL 85351 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17956: LD_INT 0
17958: PPUSH
17959: LD_INT 0
17961: PPUSH
17962: LD_INT 0
17964: PPUSH
17965: LD_INT 0
17967: PPUSH
17968: LD_INT 0
17970: PPUSH
17971: LD_INT 0
17973: PPUSH
17974: LD_INT 9
17976: PPUSH
17977: LD_INT 0
17979: PPUSH
17980: LD_INT 20
17982: PPUSH
17983: CALL 85351 0 9
// end ; end_of_file
17987: LD_VAR 0 1
17991: RET
// every 0 0$30 do var time ;
17992: GO 17994
17994: DISABLE
17995: LD_INT 0
17997: PPUSH
// begin time := 0 0$30 ;
17998: LD_ADDR_VAR 0 1
18002: PUSH
18003: LD_INT 1050
18005: ST_TO_ADDR
// repeat wait ( time ) ;
18006: LD_VAR 0 1
18010: PPUSH
18011: CALL_OW 67
// if Prob ( 50 ) then
18015: LD_INT 50
18017: PPUSH
18018: CALL_OW 13
18022: IFFALSE 18051
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18024: LD_INT 1
18026: PPUSH
18027: LD_INT 5
18029: PPUSH
18030: CALL_OW 12
18034: PPUSH
18035: LD_INT 106
18037: PPUSH
18038: LD_INT 89
18040: PPUSH
18041: LD_INT 45
18043: PPUSH
18044: LD_INT 1
18046: PPUSH
18047: CALL_OW 56
// time := time + 0 0$3 ;
18051: LD_ADDR_VAR 0 1
18055: PUSH
18056: LD_VAR 0 1
18060: PUSH
18061: LD_INT 105
18063: PLUS
18064: ST_TO_ADDR
// if Prob ( 30 ) then
18065: LD_INT 30
18067: PPUSH
18068: CALL_OW 13
18072: IFFALSE 18118
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18074: LD_INT 525
18076: PPUSH
18077: LD_INT 735
18079: PPUSH
18080: CALL_OW 12
18084: PPUSH
18085: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18089: LD_INT 1
18091: PPUSH
18092: LD_INT 5
18094: PPUSH
18095: CALL_OW 12
18099: PPUSH
18100: LD_INT 21
18102: PPUSH
18103: LD_INT 26
18105: PPUSH
18106: LD_INT 12
18108: PPUSH
18109: LD_INT 1
18111: PPUSH
18112: CALL_OW 56
// end else
18116: GO 18154
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18118: LD_INT 700
18120: PPUSH
18121: LD_INT 1225
18123: PPUSH
18124: CALL_OW 12
18128: PPUSH
18129: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18133: LD_INT 1
18135: PPUSH
18136: LD_INT 5
18138: PPUSH
18139: CALL_OW 12
18143: PPUSH
18144: LD_INT 14
18146: PPUSH
18147: LD_INT 1
18149: PPUSH
18150: CALL_OW 55
// end ; if Prob ( 50 ) then
18154: LD_INT 50
18156: PPUSH
18157: CALL_OW 13
18161: IFFALSE 18207
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18163: LD_INT 700
18165: PPUSH
18166: LD_INT 1050
18168: PPUSH
18169: CALL_OW 12
18173: PPUSH
18174: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18178: LD_INT 1
18180: PPUSH
18181: LD_INT 5
18183: PPUSH
18184: CALL_OW 12
18188: PPUSH
18189: LD_INT 181
18191: PPUSH
18192: LD_INT 218
18194: PPUSH
18195: LD_INT 16
18197: PPUSH
18198: LD_INT 1
18200: PPUSH
18201: CALL_OW 56
// end else
18205: GO 18279
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18207: LD_INT 350
18209: PPUSH
18210: LD_INT 525
18212: PPUSH
18213: CALL_OW 12
18217: PPUSH
18218: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18222: LD_INT 1
18224: PPUSH
18225: LD_INT 5
18227: PPUSH
18228: CALL_OW 12
18232: PPUSH
18233: LD_INT 13
18235: PPUSH
18236: LD_INT 1
18238: PPUSH
18239: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18243: LD_INT 350
18245: PPUSH
18246: LD_INT 700
18248: PPUSH
18249: CALL_OW 12
18253: PPUSH
18254: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18258: LD_INT 1
18260: PPUSH
18261: LD_INT 5
18263: PPUSH
18264: CALL_OW 12
18268: PPUSH
18269: LD_INT 33
18271: PPUSH
18272: LD_INT 1
18274: PPUSH
18275: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18279: LD_INT 65
18281: PUSH
18282: LD_INT 62
18284: PUSH
18285: LD_INT 55
18287: PUSH
18288: LD_INT 50
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: LIST
18295: LIST
18296: PUSH
18297: LD_OWVAR 67
18301: ARRAY
18302: PPUSH
18303: CALL_OW 13
18307: IFFALSE 18353
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18309: LD_INT 525
18311: PPUSH
18312: LD_INT 875
18314: PPUSH
18315: CALL_OW 12
18319: PPUSH
18320: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18324: LD_INT 1
18326: PPUSH
18327: LD_INT 5
18329: PPUSH
18330: CALL_OW 12
18334: PPUSH
18335: LD_INT 294
18337: PPUSH
18338: LD_INT 211
18340: PPUSH
18341: LD_INT 30
18343: PPUSH
18344: LD_INT 1
18346: PPUSH
18347: CALL_OW 56
// end else
18351: GO 18395
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18353: LD_INT 420
18355: PPUSH
18356: LD_INT 770
18358: PPUSH
18359: CALL_OW 12
18363: PPUSH
18364: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18368: LD_INT 1
18370: PPUSH
18371: LD_INT 5
18373: PPUSH
18374: CALL_OW 12
18378: PPUSH
18379: LD_INT 294
18381: PPUSH
18382: LD_INT 211
18384: PPUSH
18385: LD_INT 30
18387: PPUSH
18388: LD_INT 1
18390: PPUSH
18391: CALL_OW 56
// end ; if time > 2 2$20 then
18395: LD_VAR 0 1
18399: PUSH
18400: LD_INT 4900
18402: GREATER
18403: IFFALSE 18413
// time := 0 0$50 ;
18405: LD_ADDR_VAR 0 1
18409: PUSH
18410: LD_INT 1750
18412: ST_TO_ADDR
// until false ;
18413: LD_INT 0
18415: IFFALSE 18006
// end ;
18417: PPOPN 1
18419: END
// every 0 0$45 trigger tick < 10 10$00 do
18420: LD_OWVAR 1
18424: PUSH
18425: LD_INT 21000
18427: LESS
18428: IFFALSE 18476
18430: GO 18432
18432: DISABLE
// begin enable ;
18433: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18434: LD_INT 350
18436: PPUSH
18437: LD_INT 700
18439: PPUSH
18440: CALL_OW 12
18444: PPUSH
18445: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18449: LD_INT 3
18451: PPUSH
18452: LD_INT 5
18454: PPUSH
18455: CALL_OW 12
18459: PPUSH
18460: LD_INT 181
18462: PPUSH
18463: LD_INT 13
18465: PPUSH
18466: LD_INT 20
18468: PPUSH
18469: LD_INT 1
18471: PPUSH
18472: CALL_OW 56
// end ; end_of_file
18476: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18477: LD_INT 0
18479: PPUSH
// SetArtifactRes ( 7 , true ) ;
18480: LD_INT 7
18482: PPUSH
18483: LD_INT 1
18485: PPUSH
18486: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18490: LD_ADDR_EXP 64
18494: PUSH
18495: EMPTY
18496: PUSH
18497: EMPTY
18498: PUSH
18499: EMPTY
18500: PUSH
18501: EMPTY
18502: LIST
18503: LIST
18504: LIST
18505: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18506: LD_ADDR_EXP 65
18510: PUSH
18511: LD_INT 1050
18513: PUSH
18514: LD_OWVAR 67
18518: MUL
18519: PUSH
18520: LD_INT 2800
18522: PUSH
18523: LD_OWVAR 67
18527: MUL
18528: PUSH
18529: LD_INT 1
18531: NEG
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18538: LD_ADDR_EXP 66
18542: PUSH
18543: LD_INT 10
18545: PUSH
18546: LD_INT 35
18548: PUSH
18549: LD_INT 100
18551: PUSH
18552: EMPTY
18553: LIST
18554: LIST
18555: LIST
18556: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18557: LD_ADDR_EXP 67
18561: PUSH
18562: LD_INT 0
18564: PUSH
18565: LD_INT 0
18567: PUSH
18568: LD_INT 0
18570: PUSH
18571: EMPTY
18572: LIST
18573: LIST
18574: LIST
18575: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18576: LD_ADDR_EXP 69
18580: PUSH
18581: LD_INT 300
18583: PUSH
18584: LD_INT 500
18586: PUSH
18587: LD_INT 800
18589: PUSH
18590: EMPTY
18591: LIST
18592: LIST
18593: LIST
18594: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18595: LD_ADDR_EXP 70
18599: PUSH
18600: LD_INT 0
18602: PUSH
18603: LD_INT 0
18605: PUSH
18606: LD_INT 0
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: LIST
18613: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18614: LD_ADDR_EXP 71
18618: PUSH
18619: LD_INT 0
18621: PUSH
18622: LD_INT 0
18624: PUSH
18625: LD_INT 0
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: LIST
18632: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18633: LD_ADDR_EXP 68
18637: PUSH
18638: LD_INT 0
18640: PUSH
18641: LD_INT 0
18643: PUSH
18644: LD_INT 0
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: LIST
18651: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18652: LD_ADDR_EXP 72
18656: PUSH
18657: LD_INT 4
18659: PUSH
18660: LD_INT 3
18662: PUSH
18663: LD_INT 1
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: LIST
18670: PUSH
18671: LD_INT 5
18673: PUSH
18674: LD_INT 4
18676: PUSH
18677: LD_INT 2
18679: PUSH
18680: EMPTY
18681: LIST
18682: LIST
18683: LIST
18684: PUSH
18685: LD_INT 6
18687: PUSH
18688: LD_INT 3
18690: PUSH
18691: LD_INT 3
18693: PUSH
18694: EMPTY
18695: LIST
18696: LIST
18697: LIST
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: LIST
18703: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18704: LD_ADDR_EXP 73
18708: PUSH
18709: LD_INT 0
18711: PUSH
18712: LD_INT 0
18714: PUSH
18715: LD_INT 0
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: LIST
18722: ST_TO_ADDR
// end ;
18723: LD_VAR 0 1
18727: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18728: LD_INT 24
18730: PPUSH
18731: LD_INT 7
18733: PPUSH
18734: CALL_OW 321
18738: PUSH
18739: LD_INT 2
18741: EQUAL
18742: IFFALSE 19668
18744: GO 18746
18746: DISABLE
18747: LD_INT 0
18749: PPUSH
18750: PPUSH
18751: PPUSH
18752: PPUSH
18753: PPUSH
// begin enable ;
18754: ENABLE
// for i = 1 to 3 do
18755: LD_ADDR_VAR 0 1
18759: PUSH
18760: DOUBLE
18761: LD_INT 1
18763: DEC
18764: ST_TO_ADDR
18765: LD_INT 3
18767: PUSH
18768: FOR_TO
18769: IFFALSE 19666
// begin pos := FindArtifact ( i + 2 ) ;
18771: LD_ADDR_VAR 0 2
18775: PUSH
18776: LD_VAR 0 1
18780: PUSH
18781: LD_INT 2
18783: PLUS
18784: PPUSH
18785: CALL_OW 469
18789: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18790: LD_ADDR_EXP 64
18794: PUSH
18795: LD_EXP 64
18799: PPUSH
18800: LD_VAR 0 1
18804: PPUSH
18805: LD_VAR 0 2
18809: PPUSH
18810: CALL_OW 1
18814: ST_TO_ADDR
// if pos then
18815: LD_VAR 0 2
18819: IFFALSE 19527
// begin case i of 1 :
18821: LD_VAR 0 1
18825: PUSH
18826: LD_INT 1
18828: DOUBLE
18829: EQUAL
18830: IFTRUE 18834
18832: GO 18911
18834: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18835: LD_ADDR_VAR 0 4
18839: PUSH
18840: LD_INT 22
18842: PUSH
18843: LD_INT 7
18845: PUSH
18846: EMPTY
18847: LIST
18848: LIST
18849: PUSH
18850: LD_INT 23
18852: PUSH
18853: LD_INT 1
18855: PUSH
18856: EMPTY
18857: LIST
18858: LIST
18859: PUSH
18860: LD_INT 2
18862: PUSH
18863: LD_INT 30
18865: PUSH
18866: LD_INT 8
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: PUSH
18873: LD_INT 30
18875: PUSH
18876: LD_INT 7
18878: PUSH
18879: EMPTY
18880: LIST
18881: LIST
18882: PUSH
18883: LD_INT 30
18885: PUSH
18886: LD_INT 11
18888: PUSH
18889: EMPTY
18890: LIST
18891: LIST
18892: PUSH
18893: EMPTY
18894: LIST
18895: LIST
18896: LIST
18897: LIST
18898: PUSH
18899: EMPTY
18900: LIST
18901: LIST
18902: LIST
18903: PPUSH
18904: CALL_OW 69
18908: ST_TO_ADDR
18909: GO 19019
18911: LD_INT 2
18913: DOUBLE
18914: EQUAL
18915: IFTRUE 18919
18917: GO 18996
18919: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18920: LD_ADDR_VAR 0 4
18924: PUSH
18925: LD_INT 22
18927: PUSH
18928: LD_INT 7
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: PUSH
18935: LD_INT 23
18937: PUSH
18938: LD_INT 3
18940: PUSH
18941: EMPTY
18942: LIST
18943: LIST
18944: PUSH
18945: LD_INT 2
18947: PUSH
18948: LD_INT 30
18950: PUSH
18951: LD_INT 8
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: PUSH
18958: LD_INT 30
18960: PUSH
18961: LD_INT 7
18963: PUSH
18964: EMPTY
18965: LIST
18966: LIST
18967: PUSH
18968: LD_INT 30
18970: PUSH
18971: LD_INT 11
18973: PUSH
18974: EMPTY
18975: LIST
18976: LIST
18977: PUSH
18978: EMPTY
18979: LIST
18980: LIST
18981: LIST
18982: LIST
18983: PUSH
18984: EMPTY
18985: LIST
18986: LIST
18987: LIST
18988: PPUSH
18989: CALL_OW 69
18993: ST_TO_ADDR
18994: GO 19019
18996: LD_INT 3
18998: DOUBLE
18999: EQUAL
19000: IFTRUE 19004
19002: GO 19018
19004: POP
// labs := [ alien ] ; end ;
19005: LD_ADDR_VAR 0 4
19009: PUSH
19010: LD_INT 1
19012: PUSH
19013: EMPTY
19014: LIST
19015: ST_TO_ADDR
19016: GO 19019
19018: POP
// if not labs then
19019: LD_VAR 0 4
19023: NOT
19024: IFFALSE 19028
// continue ;
19026: GO 18768
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19028: LD_ADDR_VAR 0 5
19032: PUSH
19033: LD_VAR 0 4
19037: PPUSH
19038: LD_EXP 64
19042: PUSH
19043: LD_VAR 0 1
19047: ARRAY
19048: PUSH
19049: LD_INT 1
19051: ARRAY
19052: PPUSH
19053: LD_EXP 64
19057: PUSH
19058: LD_VAR 0 1
19062: ARRAY
19063: PUSH
19064: LD_INT 2
19066: ARRAY
19067: PPUSH
19068: CALL_OW 73
19072: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19073: LD_VAR 0 5
19077: NOT
19078: PUSH
19079: LD_VAR 0 5
19083: PUSH
19084: LD_EXP 71
19088: PUSH
19089: LD_VAR 0 1
19093: ARRAY
19094: NONEQUAL
19095: OR
19096: IFFALSE 19201
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19098: LD_INT 7
19100: PPUSH
19101: LD_EXP 72
19105: PUSH
19106: LD_VAR 0 1
19110: ARRAY
19111: PUSH
19112: LD_INT 3
19114: ARRAY
19115: PPUSH
19116: LD_INT 0
19118: PPUSH
19119: LD_EXP 71
19123: PUSH
19124: LD_VAR 0 1
19128: ARRAY
19129: PPUSH
19130: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19134: LD_INT 7
19136: PPUSH
19137: LD_EXP 72
19141: PUSH
19142: LD_VAR 0 1
19146: ARRAY
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: PPUSH
19152: LD_INT 0
19154: PPUSH
19155: LD_EXP 71
19159: PUSH
19160: LD_VAR 0 1
19164: ARRAY
19165: PPUSH
19166: CALL_OW 468
// if nearestLab then
19170: LD_VAR 0 5
19174: IFFALSE 19201
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19176: LD_ADDR_EXP 71
19180: PUSH
19181: LD_EXP 71
19185: PPUSH
19186: LD_VAR 0 1
19190: PPUSH
19191: LD_VAR 0 5
19195: PPUSH
19196: CALL_OW 1
19200: ST_TO_ADDR
// end ; if not nearestLab then
19201: LD_VAR 0 5
19205: NOT
19206: IFFALSE 19210
// continue ;
19208: GO 18768
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19210: LD_VAR 0 5
19214: PPUSH
19215: LD_EXP 64
19219: PUSH
19220: LD_VAR 0 1
19224: ARRAY
19225: PUSH
19226: LD_INT 1
19228: ARRAY
19229: PPUSH
19230: LD_EXP 64
19234: PUSH
19235: LD_VAR 0 1
19239: ARRAY
19240: PUSH
19241: LD_INT 2
19243: ARRAY
19244: PPUSH
19245: CALL_OW 297
19249: PUSH
19250: LD_INT 8
19252: LESS
19253: IFFALSE 19450
// begin if not artifactsResearched [ i ] then
19255: LD_EXP 67
19259: PUSH
19260: LD_VAR 0 1
19264: ARRAY
19265: NOT
19266: IFFALSE 19347
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19268: LD_VAR 0 5
19272: PPUSH
19273: CALL_OW 461
19277: PUSH
19278: LD_INT 2
19280: EQUAL
19281: IFFALSE 19315
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19283: LD_INT 7
19285: PPUSH
19286: LD_EXP 72
19290: PUSH
19291: LD_VAR 0 1
19295: ARRAY
19296: PUSH
19297: LD_INT 3
19299: ARRAY
19300: PPUSH
19301: LD_INT 2
19303: PPUSH
19304: LD_VAR 0 5
19308: PPUSH
19309: CALL_OW 468
19313: GO 19345
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19315: LD_INT 7
19317: PPUSH
19318: LD_EXP 72
19322: PUSH
19323: LD_VAR 0 1
19327: ARRAY
19328: PUSH
19329: LD_INT 3
19331: ARRAY
19332: PPUSH
19333: LD_INT 1
19335: PPUSH
19336: LD_VAR 0 5
19340: PPUSH
19341: CALL_OW 468
// end else
19345: GO 19448
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19347: LD_VAR 0 5
19351: PPUSH
19352: CALL_OW 461
19356: PUSH
19357: LD_INT 2
19359: EQUAL
19360: PUSH
19361: LD_EXP 73
19365: PUSH
19366: LD_VAR 0 1
19370: ARRAY
19371: AND
19372: IFFALSE 19418
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19374: LD_INT 7
19376: PPUSH
19377: LD_EXP 72
19381: PUSH
19382: LD_VAR 0 1
19386: ARRAY
19387: PUSH
19388: LD_INT 1
19390: ARRAY
19391: PPUSH
19392: LD_EXP 72
19396: PUSH
19397: LD_VAR 0 1
19401: ARRAY
19402: PUSH
19403: LD_INT 2
19405: ARRAY
19406: PPUSH
19407: LD_VAR 0 5
19411: PPUSH
19412: CALL_OW 468
19416: GO 19448
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19418: LD_INT 7
19420: PPUSH
19421: LD_EXP 72
19425: PUSH
19426: LD_VAR 0 1
19430: ARRAY
19431: PUSH
19432: LD_INT 1
19434: ARRAY
19435: PPUSH
19436: LD_INT 1
19438: PPUSH
19439: LD_VAR 0 5
19443: PPUSH
19444: CALL_OW 468
// end else
19448: GO 19525
// begin if not artifactsResearched [ i ] then
19450: LD_EXP 67
19454: PUSH
19455: LD_VAR 0 1
19459: ARRAY
19460: NOT
19461: IFFALSE 19495
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19463: LD_INT 7
19465: PPUSH
19466: LD_EXP 72
19470: PUSH
19471: LD_VAR 0 1
19475: ARRAY
19476: PUSH
19477: LD_INT 3
19479: ARRAY
19480: PPUSH
19481: LD_INT 0
19483: PPUSH
19484: LD_VAR 0 5
19488: PPUSH
19489: CALL_OW 468
19493: GO 19525
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19495: LD_INT 7
19497: PPUSH
19498: LD_EXP 72
19502: PUSH
19503: LD_VAR 0 1
19507: ARRAY
19508: PUSH
19509: LD_INT 1
19511: ARRAY
19512: PPUSH
19513: LD_INT 0
19515: PPUSH
19516: LD_VAR 0 5
19520: PPUSH
19521: CALL_OW 468
// end ; end else
19525: GO 19664
// begin if not artifactsLabs [ i ] then
19527: LD_EXP 71
19531: PUSH
19532: LD_VAR 0 1
19536: ARRAY
19537: NOT
19538: IFFALSE 19542
// continue ;
19540: GO 18768
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19542: LD_INT 7
19544: PPUSH
19545: LD_EXP 72
19549: PUSH
19550: LD_VAR 0 1
19554: ARRAY
19555: PUSH
19556: LD_INT 3
19558: ARRAY
19559: PPUSH
19560: LD_INT 0
19562: PPUSH
19563: LD_EXP 71
19567: PUSH
19568: LD_VAR 0 1
19572: ARRAY
19573: PPUSH
19574: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19578: LD_INT 7
19580: PPUSH
19581: LD_EXP 72
19585: PUSH
19586: LD_VAR 0 1
19590: ARRAY
19591: PUSH
19592: LD_INT 1
19594: ARRAY
19595: PPUSH
19596: LD_INT 0
19598: PPUSH
19599: LD_EXP 71
19603: PUSH
19604: LD_VAR 0 1
19608: ARRAY
19609: PPUSH
19610: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19614: LD_EXP 68
19618: PUSH
19619: LD_VAR 0 1
19623: ARRAY
19624: IFFALSE 19664
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19626: LD_ADDR_EXP 68
19630: PUSH
19631: LD_EXP 68
19635: PPUSH
19636: LD_VAR 0 1
19640: PPUSH
19641: LD_INT 0
19643: PPUSH
19644: CALL_OW 1
19648: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19649: LD_EXP 71
19653: PUSH
19654: LD_VAR 0 1
19658: ARRAY
19659: PPUSH
19660: CALL_OW 127
// end ; end ; end ;
19664: GO 18768
19666: POP
19667: POP
// end ;
19668: PPOPN 5
19670: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19671: LD_INT 0
19673: PPUSH
19674: PPUSH
19675: PPUSH
19676: PPUSH
19677: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19678: LD_VAR 0 2
19682: PUSH
19683: LD_EXP 72
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PUSH
19692: LD_INT 3
19694: ARRAY
19695: EQUAL
19696: IFFALSE 19819
// begin lab := artifactsLabs [ 1 ] ;
19698: LD_ADDR_VAR 0 6
19702: PUSH
19703: LD_EXP 71
19707: PUSH
19708: LD_INT 1
19710: ARRAY
19711: ST_TO_ADDR
// if not lab then
19712: LD_VAR 0 6
19716: NOT
19717: IFFALSE 19721
// exit ;
19719: GO 20799
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19721: LD_VAR 0 6
19725: PPUSH
19726: LD_EXP 69
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: PPUSH
19735: LD_INT 1
19737: PPUSH
19738: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19742: LD_EXP 70
19746: PUSH
19747: LD_INT 1
19749: ARRAY
19750: IFFALSE 19770
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19752: LD_VAR 0 6
19756: PPUSH
19757: LD_EXP 70
19761: PUSH
19762: LD_INT 1
19764: ARRAY
19765: PPUSH
19766: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19770: LD_ADDR_EXP 68
19774: PUSH
19775: LD_EXP 68
19779: PPUSH
19780: LD_INT 1
19782: PPUSH
19783: LD_INT 1
19785: PPUSH
19786: CALL_OW 1
19790: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19791: LD_INT 7
19793: PPUSH
19794: LD_EXP 72
19798: PUSH
19799: LD_INT 1
19801: ARRAY
19802: PUSH
19803: LD_INT 3
19805: ARRAY
19806: PPUSH
19807: LD_INT 0
19809: PPUSH
19810: LD_VAR 0 6
19814: PPUSH
19815: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19819: LD_VAR 0 2
19823: PUSH
19824: LD_EXP 72
19828: PUSH
19829: LD_INT 2
19831: ARRAY
19832: PUSH
19833: LD_INT 3
19835: ARRAY
19836: EQUAL
19837: IFFALSE 19960
// begin lab := artifactsLabs [ 2 ] ;
19839: LD_ADDR_VAR 0 6
19843: PUSH
19844: LD_EXP 71
19848: PUSH
19849: LD_INT 2
19851: ARRAY
19852: ST_TO_ADDR
// if not lab then
19853: LD_VAR 0 6
19857: NOT
19858: IFFALSE 19862
// exit ;
19860: GO 20799
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19862: LD_VAR 0 6
19866: PPUSH
19867: LD_EXP 69
19871: PUSH
19872: LD_INT 2
19874: ARRAY
19875: PPUSH
19876: LD_INT 1
19878: PPUSH
19879: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19883: LD_EXP 70
19887: PUSH
19888: LD_INT 2
19890: ARRAY
19891: IFFALSE 19911
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19893: LD_VAR 0 6
19897: PPUSH
19898: LD_EXP 70
19902: PUSH
19903: LD_INT 2
19905: ARRAY
19906: PPUSH
19907: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19911: LD_ADDR_EXP 68
19915: PUSH
19916: LD_EXP 68
19920: PPUSH
19921: LD_INT 2
19923: PPUSH
19924: LD_INT 1
19926: PPUSH
19927: CALL_OW 1
19931: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19932: LD_INT 7
19934: PPUSH
19935: LD_EXP 72
19939: PUSH
19940: LD_INT 2
19942: ARRAY
19943: PUSH
19944: LD_INT 3
19946: ARRAY
19947: PPUSH
19948: LD_INT 0
19950: PPUSH
19951: LD_VAR 0 6
19955: PPUSH
19956: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19960: LD_VAR 0 2
19964: PUSH
19965: LD_EXP 72
19969: PUSH
19970: LD_INT 3
19972: ARRAY
19973: PUSH
19974: LD_INT 3
19976: ARRAY
19977: EQUAL
19978: IFFALSE 20101
// begin lab := artifactsLabs [ 3 ] ;
19980: LD_ADDR_VAR 0 6
19984: PUSH
19985: LD_EXP 71
19989: PUSH
19990: LD_INT 3
19992: ARRAY
19993: ST_TO_ADDR
// if not lab then
19994: LD_VAR 0 6
19998: NOT
19999: IFFALSE 20003
// exit ;
20001: GO 20799
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20003: LD_VAR 0 6
20007: PPUSH
20008: LD_EXP 69
20012: PUSH
20013: LD_INT 3
20015: ARRAY
20016: PPUSH
20017: LD_INT 1
20019: PPUSH
20020: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20024: LD_EXP 70
20028: PUSH
20029: LD_INT 3
20031: ARRAY
20032: IFFALSE 20052
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20034: LD_VAR 0 6
20038: PPUSH
20039: LD_EXP 70
20043: PUSH
20044: LD_INT 3
20046: ARRAY
20047: PPUSH
20048: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20052: LD_ADDR_EXP 68
20056: PUSH
20057: LD_EXP 68
20061: PPUSH
20062: LD_INT 3
20064: PPUSH
20065: LD_INT 1
20067: PPUSH
20068: CALL_OW 1
20072: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20073: LD_INT 7
20075: PPUSH
20076: LD_EXP 72
20080: PUSH
20081: LD_INT 3
20083: ARRAY
20084: PUSH
20085: LD_INT 3
20087: ARRAY
20088: PPUSH
20089: LD_INT 0
20091: PPUSH
20092: LD_VAR 0 6
20096: PPUSH
20097: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20101: LD_VAR 0 2
20105: PUSH
20106: LD_EXP 72
20110: PUSH
20111: LD_INT 1
20113: ARRAY
20114: PUSH
20115: LD_INT 1
20117: ARRAY
20118: EQUAL
20119: IFFALSE 20277
// begin lab := artifactsLabs [ 1 ] ;
20121: LD_ADDR_VAR 0 6
20125: PUSH
20126: LD_EXP 71
20130: PUSH
20131: LD_INT 1
20133: ARRAY
20134: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20135: LD_VAR 0 6
20139: PPUSH
20140: CALL_OW 274
20144: PPUSH
20145: CALL 88955 0 1
20149: PUSH
20150: LD_INT 3
20152: ARRAY
20153: PUSH
20154: LD_EXP 66
20158: PUSH
20159: LD_INT 1
20161: ARRAY
20162: LESS
20163: IFFALSE 20177
// begin HintSpec ( ArtifactCost , 2 ) ;
20165: LD_STRING ArtifactCost
20167: PPUSH
20168: LD_INT 2
20170: PPUSH
20171: CALL_OW 338
// exit ;
20175: GO 20799
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20177: LD_ADDR_EXP 73
20181: PUSH
20182: LD_EXP 73
20186: PPUSH
20187: LD_INT 1
20189: PPUSH
20190: LD_INT 0
20192: PPUSH
20193: CALL_OW 1
20197: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20198: LD_VAR 0 3
20202: PPUSH
20203: LD_VAR 0 4
20207: PPUSH
20208: LD_INT 7
20210: PPUSH
20211: LD_INT 12
20213: NEG
20214: PPUSH
20215: CALL_OW 330
// wait ( 0 0$30 ) ;
20219: LD_INT 1050
20221: PPUSH
20222: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20226: LD_VAR 0 3
20230: PPUSH
20231: LD_VAR 0 4
20235: PPUSH
20236: LD_INT 7
20238: PPUSH
20239: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20243: LD_EXP 65
20247: PUSH
20248: LD_INT 1
20250: ARRAY
20251: PPUSH
20252: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20256: LD_ADDR_EXP 73
20260: PUSH
20261: LD_EXP 73
20265: PPUSH
20266: LD_INT 1
20268: PPUSH
20269: LD_INT 1
20271: PPUSH
20272: CALL_OW 1
20276: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20277: LD_VAR 0 2
20281: PUSH
20282: LD_EXP 72
20286: PUSH
20287: LD_INT 2
20289: ARRAY
20290: PUSH
20291: LD_INT 1
20293: ARRAY
20294: EQUAL
20295: IFFALSE 20532
// begin lab := artifactsLabs [ 2 ] ;
20297: LD_ADDR_VAR 0 6
20301: PUSH
20302: LD_EXP 71
20306: PUSH
20307: LD_INT 2
20309: ARRAY
20310: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20311: LD_VAR 0 3
20315: PUSH
20316: LD_INT 81
20318: PUSH
20319: LD_INT 7
20321: PUSH
20322: EMPTY
20323: LIST
20324: LIST
20325: PUSH
20326: LD_INT 2
20328: PUSH
20329: LD_INT 32
20331: PUSH
20332: LD_INT 3
20334: PUSH
20335: EMPTY
20336: LIST
20337: LIST
20338: PUSH
20339: LD_INT 30
20341: PUSH
20342: LD_INT 28
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: PUSH
20349: LD_INT 30
20351: PUSH
20352: LD_INT 30
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: PUSH
20359: LD_INT 35
20361: PUSH
20362: LD_INT 49
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: PUSH
20369: LD_INT 34
20371: PUSH
20372: LD_INT 49
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 30
20381: PUSH
20382: LD_INT 21
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: LIST
20393: LIST
20394: LIST
20395: LIST
20396: LIST
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PPUSH
20402: CALL_OW 69
20406: IN
20407: NOT
20408: IFFALSE 20412
// exit ;
20410: GO 20799
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20412: LD_VAR 0 6
20416: PPUSH
20417: CALL_OW 274
20421: PPUSH
20422: CALL 88955 0 1
20426: PUSH
20427: LD_INT 3
20429: ARRAY
20430: PUSH
20431: LD_EXP 66
20435: PUSH
20436: LD_INT 2
20438: ARRAY
20439: LESS
20440: IFFALSE 20454
// begin HintSpec ( ArtifactCost , 2 ) ;
20442: LD_STRING ArtifactCost
20444: PPUSH
20445: LD_INT 2
20447: PPUSH
20448: CALL_OW 338
// exit ;
20452: GO 20799
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20454: LD_ADDR_EXP 73
20458: PUSH
20459: LD_EXP 73
20463: PPUSH
20464: LD_INT 2
20466: PPUSH
20467: LD_INT 0
20469: PPUSH
20470: CALL_OW 1
20474: ST_TO_ADDR
// KillUnit ( x ) ;
20475: LD_VAR 0 3
20479: PPUSH
20480: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20484: LD_ADDR_EXP 16
20488: PUSH
20489: LD_EXP 16
20493: PUSH
20494: LD_INT 1
20496: PLUS
20497: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20498: LD_EXP 65
20502: PUSH
20503: LD_INT 2
20505: ARRAY
20506: PPUSH
20507: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20511: LD_ADDR_EXP 73
20515: PUSH
20516: LD_EXP 73
20520: PPUSH
20521: LD_INT 2
20523: PPUSH
20524: LD_INT 1
20526: PPUSH
20527: CALL_OW 1
20531: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20532: LD_VAR 0 2
20536: PUSH
20537: LD_EXP 72
20541: PUSH
20542: LD_INT 3
20544: ARRAY
20545: PUSH
20546: LD_INT 1
20548: ARRAY
20549: EQUAL
20550: IFFALSE 20799
// begin lab := artifactsLabs [ 3 ] ;
20552: LD_ADDR_VAR 0 6
20556: PUSH
20557: LD_EXP 71
20561: PUSH
20562: LD_INT 3
20564: ARRAY
20565: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20566: LD_VAR 0 6
20570: PPUSH
20571: CALL_OW 274
20575: PPUSH
20576: CALL 88955 0 1
20580: PUSH
20581: LD_INT 3
20583: ARRAY
20584: PUSH
20585: LD_EXP 66
20589: PUSH
20590: LD_INT 3
20592: ARRAY
20593: LESS
20594: IFFALSE 20608
// begin HintSpec ( ArtifactCost , 2 ) ;
20596: LD_STRING ArtifactCost
20598: PPUSH
20599: LD_INT 2
20601: PPUSH
20602: CALL_OW 338
// exit ;
20606: GO 20799
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20608: LD_INT 37
20610: PPUSH
20611: LD_INT 1
20613: PPUSH
20614: CALL_OW 424
// time := 0 0$30 ;
20618: LD_ADDR_VAR 0 7
20622: PUSH
20623: LD_INT 1050
20625: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20626: LD_ADDR_EXP 73
20630: PUSH
20631: LD_EXP 73
20635: PPUSH
20636: LD_INT 3
20638: PPUSH
20639: LD_INT 0
20641: PPUSH
20642: CALL_OW 1
20646: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20647: LD_ADDR_OWVAR 47
20651: PUSH
20652: LD_STRING #Am15a-1
20654: PUSH
20655: LD_VAR 0 7
20659: PUSH
20660: EMPTY
20661: LIST
20662: LIST
20663: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20664: LD_INT 35
20666: PPUSH
20667: CALL_OW 67
// time := time - 0 0$1 ;
20671: LD_ADDR_VAR 0 7
20675: PUSH
20676: LD_VAR 0 7
20680: PUSH
20681: LD_INT 35
20683: MINUS
20684: ST_TO_ADDR
// until time = 0 0$00 ;
20685: LD_VAR 0 7
20689: PUSH
20690: LD_INT 0
20692: EQUAL
20693: IFFALSE 20647
// display_strings :=  ;
20695: LD_ADDR_OWVAR 47
20699: PUSH
20700: LD_STRING 
20702: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20703: LD_INT 37
20705: PPUSH
20706: LD_INT 0
20708: PPUSH
20709: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20713: LD_ADDR_VAR 0 8
20717: PUSH
20718: LD_INT 37
20720: PPUSH
20721: LD_INT 3
20723: PUSH
20724: LD_INT 21
20726: PUSH
20727: LD_INT 3
20729: PUSH
20730: EMPTY
20731: LIST
20732: LIST
20733: PUSH
20734: EMPTY
20735: LIST
20736: LIST
20737: PPUSH
20738: CALL_OW 70
20742: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20743: LD_VAR 0 3
20747: PPUSH
20748: LD_VAR 0 4
20752: PPUSH
20753: CALL_OW 84
// for un in list do
20757: LD_ADDR_VAR 0 9
20761: PUSH
20762: LD_VAR 0 8
20766: PUSH
20767: FOR_IN
20768: IFFALSE 20797
// TeleportUnit ( un , x , y , 12 , true ) ;
20770: LD_VAR 0 9
20774: PPUSH
20775: LD_VAR 0 3
20779: PPUSH
20780: LD_VAR 0 4
20784: PPUSH
20785: LD_INT 12
20787: PPUSH
20788: LD_INT 1
20790: PPUSH
20791: CALL_OW 483
20795: GO 20767
20797: POP
20798: POP
// end ; end ;
20799: PPOPN 9
20801: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20802: LD_INT 0
20804: PPUSH
20805: PPUSH
// begin labNum := 0 ;
20806: LD_ADDR_VAR 0 4
20810: PUSH
20811: LD_INT 0
20813: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20814: LD_ADDR_VAR 0 3
20818: PUSH
20819: DOUBLE
20820: LD_INT 1
20822: DEC
20823: ST_TO_ADDR
20824: LD_EXP 71
20828: PUSH
20829: FOR_TO
20830: IFFALSE 20864
// if artifactsLabs [ i ] = lab then
20832: LD_EXP 71
20836: PUSH
20837: LD_VAR 0 3
20841: ARRAY
20842: PUSH
20843: LD_VAR 0 1
20847: EQUAL
20848: IFFALSE 20862
// begin labNum := i ;
20850: LD_ADDR_VAR 0 4
20854: PUSH
20855: LD_VAR 0 3
20859: ST_TO_ADDR
// break ;
20860: GO 20864
// end ;
20862: GO 20829
20864: POP
20865: POP
// if not labNum then
20866: LD_VAR 0 4
20870: NOT
20871: IFFALSE 20875
// exit ;
20873: GO 20953
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20875: LD_INT 7
20877: PPUSH
20878: LD_EXP 72
20882: PUSH
20883: LD_VAR 0 4
20887: ARRAY
20888: PUSH
20889: LD_INT 3
20891: ARRAY
20892: PPUSH
20893: LD_INT 2
20895: PPUSH
20896: LD_VAR 0 1
20900: PPUSH
20901: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20905: LD_ADDR_EXP 70
20909: PUSH
20910: LD_EXP 70
20914: PPUSH
20915: LD_VAR 0 4
20919: PPUSH
20920: LD_VAR 0 2
20924: PPUSH
20925: CALL_OW 1
20929: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20930: LD_ADDR_EXP 68
20934: PUSH
20935: LD_EXP 68
20939: PPUSH
20940: LD_VAR 0 4
20944: PPUSH
20945: LD_INT 0
20947: PPUSH
20948: CALL_OW 1
20952: ST_TO_ADDR
// end ;
20953: PPOPN 4
20955: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20956: LD_INT 0
20958: PPUSH
20959: PPUSH
// begin labNum := 0 ;
20960: LD_ADDR_VAR 0 3
20964: PUSH
20965: LD_INT 0
20967: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20968: LD_ADDR_VAR 0 2
20972: PUSH
20973: DOUBLE
20974: LD_INT 1
20976: DEC
20977: ST_TO_ADDR
20978: LD_EXP 71
20982: PUSH
20983: FOR_TO
20984: IFFALSE 21018
// if artifactsLabs [ i ] = lab then
20986: LD_EXP 71
20990: PUSH
20991: LD_VAR 0 2
20995: ARRAY
20996: PUSH
20997: LD_VAR 0 1
21001: EQUAL
21002: IFFALSE 21016
// begin labNum := i ;
21004: LD_ADDR_VAR 0 3
21008: PUSH
21009: LD_VAR 0 2
21013: ST_TO_ADDR
// break ;
21014: GO 21018
// end ;
21016: GO 20983
21018: POP
21019: POP
// if not labNum then
21020: LD_VAR 0 3
21024: NOT
21025: IFFALSE 21029
// exit ;
21027: GO 21191
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21029: LD_INT 7
21031: PPUSH
21032: LD_EXP 72
21036: PUSH
21037: LD_VAR 0 3
21041: ARRAY
21042: PUSH
21043: LD_INT 3
21045: ARRAY
21046: PPUSH
21047: LD_INT 0
21049: PPUSH
21050: LD_VAR 0 1
21054: PPUSH
21055: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21059: LD_ADDR_EXP 67
21063: PUSH
21064: LD_EXP 67
21068: PPUSH
21069: LD_VAR 0 3
21073: PPUSH
21074: LD_INT 1
21076: PPUSH
21077: CALL_OW 1
21081: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21082: LD_ADDR_EXP 73
21086: PUSH
21087: LD_EXP 73
21091: PPUSH
21092: LD_VAR 0 3
21096: PPUSH
21097: LD_INT 1
21099: PPUSH
21100: CALL_OW 1
21104: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21105: LD_ADDR_EXP 68
21109: PUSH
21110: LD_EXP 68
21114: PPUSH
21115: LD_VAR 0 3
21119: PPUSH
21120: LD_INT 0
21122: PPUSH
21123: CALL_OW 1
21127: ST_TO_ADDR
// case labNum of 1 :
21128: LD_VAR 0 3
21132: PUSH
21133: LD_INT 1
21135: DOUBLE
21136: EQUAL
21137: IFTRUE 21141
21139: GO 21152
21141: POP
// artifactIResearched := true ; 2 :
21142: LD_ADDR_EXP 12
21146: PUSH
21147: LD_INT 1
21149: ST_TO_ADDR
21150: GO 21191
21152: LD_INT 2
21154: DOUBLE
21155: EQUAL
21156: IFTRUE 21160
21158: GO 21171
21160: POP
// artifactIIResearched := true ; 3 :
21161: LD_ADDR_EXP 13
21165: PUSH
21166: LD_INT 1
21168: ST_TO_ADDR
21169: GO 21191
21171: LD_INT 3
21173: DOUBLE
21174: EQUAL
21175: IFTRUE 21179
21177: GO 21190
21179: POP
// artifactIIIResearched := true ; end ;
21180: LD_ADDR_EXP 14
21184: PUSH
21185: LD_INT 1
21187: ST_TO_ADDR
21188: GO 21191
21190: POP
// end ; end_of_file
21191: PPOPN 3
21193: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
21194: LD_INT 0
21196: PPUSH
// ar_miner := 81 ;
21197: LD_ADDR_EXP 81
21201: PUSH
21202: LD_INT 81
21204: ST_TO_ADDR
// ar_crane := 88 ;
21205: LD_ADDR_EXP 80
21209: PUSH
21210: LD_INT 88
21212: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
21213: LD_ADDR_EXP 75
21217: PUSH
21218: LD_INT 89
21220: ST_TO_ADDR
// us_hack := 99 ;
21221: LD_ADDR_EXP 76
21225: PUSH
21226: LD_INT 99
21228: ST_TO_ADDR
// us_artillery := 97 ;
21229: LD_ADDR_EXP 77
21233: PUSH
21234: LD_INT 97
21236: ST_TO_ADDR
// ar_bio_bomb := 91 ;
21237: LD_ADDR_EXP 78
21241: PUSH
21242: LD_INT 91
21244: ST_TO_ADDR
// ar_mortar := 92 ;
21245: LD_ADDR_EXP 79
21249: PUSH
21250: LD_INT 92
21252: ST_TO_ADDR
// ru_radar := 98 ;
21253: LD_ADDR_EXP 74
21257: PUSH
21258: LD_INT 98
21260: ST_TO_ADDR
// tech_Artillery := 80 ;
21261: LD_ADDR_EXP 82
21265: PUSH
21266: LD_INT 80
21268: ST_TO_ADDR
// tech_RadMat := 81 ;
21269: LD_ADDR_EXP 83
21273: PUSH
21274: LD_INT 81
21276: ST_TO_ADDR
// tech_BasicTools := 82 ;
21277: LD_ADDR_EXP 84
21281: PUSH
21282: LD_INT 82
21284: ST_TO_ADDR
// tech_Cargo := 83 ;
21285: LD_ADDR_EXP 85
21289: PUSH
21290: LD_INT 83
21292: ST_TO_ADDR
// tech_Track := 84 ;
21293: LD_ADDR_EXP 86
21297: PUSH
21298: LD_INT 84
21300: ST_TO_ADDR
// tech_Crane := 85 ;
21301: LD_ADDR_EXP 87
21305: PUSH
21306: LD_INT 85
21308: ST_TO_ADDR
// tech_Bulldozer := 86 ;
21309: LD_ADDR_EXP 88
21313: PUSH
21314: LD_INT 86
21316: ST_TO_ADDR
// tech_Hovercraft := 87 ;
21317: LD_ADDR_EXP 89
21321: PUSH
21322: LD_INT 87
21324: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
21325: LD_ADDR_EXP 90
21329: PUSH
21330: LD_INT 88
21332: ST_TO_ADDR
// class_mastodont := 31 ;
21333: LD_ADDR_EXP 91
21337: PUSH
21338: LD_INT 31
21340: ST_TO_ADDR
// class_horse := 21 ;
21341: LD_ADDR_EXP 92
21345: PUSH
21346: LD_INT 21
21348: ST_TO_ADDR
// end ;
21349: LD_VAR 0 1
21353: RET
// every 1 do
21354: GO 21356
21356: DISABLE
// InitGlobalVariables ; end_of_file
21357: CALL 21194 0 0
21361: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21362: LD_INT 0
21364: PPUSH
21365: PPUSH
// skirmish := false ;
21366: LD_ADDR_EXP 93
21370: PUSH
21371: LD_INT 0
21373: ST_TO_ADDR
// debug_mc := false ;
21374: LD_ADDR_EXP 94
21378: PUSH
21379: LD_INT 0
21381: ST_TO_ADDR
// mc_bases := [ ] ;
21382: LD_ADDR_EXP 95
21386: PUSH
21387: EMPTY
21388: ST_TO_ADDR
// mc_sides := [ ] ;
21389: LD_ADDR_EXP 121
21393: PUSH
21394: EMPTY
21395: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21396: LD_ADDR_EXP 96
21400: PUSH
21401: EMPTY
21402: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21403: LD_ADDR_EXP 97
21407: PUSH
21408: EMPTY
21409: ST_TO_ADDR
// mc_need_heal := [ ] ;
21410: LD_ADDR_EXP 98
21414: PUSH
21415: EMPTY
21416: ST_TO_ADDR
// mc_healers := [ ] ;
21417: LD_ADDR_EXP 99
21421: PUSH
21422: EMPTY
21423: ST_TO_ADDR
// mc_build_list := [ ] ;
21424: LD_ADDR_EXP 100
21428: PUSH
21429: EMPTY
21430: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21431: LD_ADDR_EXP 127
21435: PUSH
21436: EMPTY
21437: ST_TO_ADDR
// mc_builders := [ ] ;
21438: LD_ADDR_EXP 101
21442: PUSH
21443: EMPTY
21444: ST_TO_ADDR
// mc_construct_list := [ ] ;
21445: LD_ADDR_EXP 102
21449: PUSH
21450: EMPTY
21451: ST_TO_ADDR
// mc_turret_list := [ ] ;
21452: LD_ADDR_EXP 103
21456: PUSH
21457: EMPTY
21458: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21459: LD_ADDR_EXP 104
21463: PUSH
21464: EMPTY
21465: ST_TO_ADDR
// mc_miners := [ ] ;
21466: LD_ADDR_EXP 109
21470: PUSH
21471: EMPTY
21472: ST_TO_ADDR
// mc_mines := [ ] ;
21473: LD_ADDR_EXP 108
21477: PUSH
21478: EMPTY
21479: ST_TO_ADDR
// mc_minefields := [ ] ;
21480: LD_ADDR_EXP 110
21484: PUSH
21485: EMPTY
21486: ST_TO_ADDR
// mc_crates := [ ] ;
21487: LD_ADDR_EXP 111
21491: PUSH
21492: EMPTY
21493: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21494: LD_ADDR_EXP 112
21498: PUSH
21499: EMPTY
21500: ST_TO_ADDR
// mc_crates_area := [ ] ;
21501: LD_ADDR_EXP 113
21505: PUSH
21506: EMPTY
21507: ST_TO_ADDR
// mc_vehicles := [ ] ;
21508: LD_ADDR_EXP 114
21512: PUSH
21513: EMPTY
21514: ST_TO_ADDR
// mc_attack := [ ] ;
21515: LD_ADDR_EXP 115
21519: PUSH
21520: EMPTY
21521: ST_TO_ADDR
// mc_produce := [ ] ;
21522: LD_ADDR_EXP 116
21526: PUSH
21527: EMPTY
21528: ST_TO_ADDR
// mc_defender := [ ] ;
21529: LD_ADDR_EXP 117
21533: PUSH
21534: EMPTY
21535: ST_TO_ADDR
// mc_parking := [ ] ;
21536: LD_ADDR_EXP 119
21540: PUSH
21541: EMPTY
21542: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21543: LD_ADDR_EXP 105
21547: PUSH
21548: EMPTY
21549: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21550: LD_ADDR_EXP 107
21554: PUSH
21555: EMPTY
21556: ST_TO_ADDR
// mc_scan := [ ] ;
21557: LD_ADDR_EXP 118
21561: PUSH
21562: EMPTY
21563: ST_TO_ADDR
// mc_scan_area := [ ] ;
21564: LD_ADDR_EXP 120
21568: PUSH
21569: EMPTY
21570: ST_TO_ADDR
// mc_tech := [ ] ;
21571: LD_ADDR_EXP 122
21575: PUSH
21576: EMPTY
21577: ST_TO_ADDR
// mc_class := [ ] ;
21578: LD_ADDR_EXP 136
21582: PUSH
21583: EMPTY
21584: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21585: LD_ADDR_EXP 137
21589: PUSH
21590: EMPTY
21591: ST_TO_ADDR
// mc_is_defending := [ ] ;
21592: LD_ADDR_EXP 138
21596: PUSH
21597: EMPTY
21598: ST_TO_ADDR
// end ;
21599: LD_VAR 0 1
21603: RET
// export function MC_Kill ( base ) ; begin
21604: LD_INT 0
21606: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21607: LD_ADDR_EXP 95
21611: PUSH
21612: LD_EXP 95
21616: PPUSH
21617: LD_VAR 0 1
21621: PPUSH
21622: EMPTY
21623: PPUSH
21624: CALL_OW 1
21628: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21629: LD_ADDR_EXP 96
21633: PUSH
21634: LD_EXP 96
21638: PPUSH
21639: LD_VAR 0 1
21643: PPUSH
21644: EMPTY
21645: PPUSH
21646: CALL_OW 1
21650: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21651: LD_ADDR_EXP 97
21655: PUSH
21656: LD_EXP 97
21660: PPUSH
21661: LD_VAR 0 1
21665: PPUSH
21666: EMPTY
21667: PPUSH
21668: CALL_OW 1
21672: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21673: LD_ADDR_EXP 98
21677: PUSH
21678: LD_EXP 98
21682: PPUSH
21683: LD_VAR 0 1
21687: PPUSH
21688: EMPTY
21689: PPUSH
21690: CALL_OW 1
21694: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21695: LD_ADDR_EXP 99
21699: PUSH
21700: LD_EXP 99
21704: PPUSH
21705: LD_VAR 0 1
21709: PPUSH
21710: EMPTY
21711: PPUSH
21712: CALL_OW 1
21716: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21717: LD_ADDR_EXP 100
21721: PUSH
21722: LD_EXP 100
21726: PPUSH
21727: LD_VAR 0 1
21731: PPUSH
21732: EMPTY
21733: PPUSH
21734: CALL_OW 1
21738: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21739: LD_ADDR_EXP 101
21743: PUSH
21744: LD_EXP 101
21748: PPUSH
21749: LD_VAR 0 1
21753: PPUSH
21754: EMPTY
21755: PPUSH
21756: CALL_OW 1
21760: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21761: LD_ADDR_EXP 102
21765: PUSH
21766: LD_EXP 102
21770: PPUSH
21771: LD_VAR 0 1
21775: PPUSH
21776: EMPTY
21777: PPUSH
21778: CALL_OW 1
21782: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21783: LD_ADDR_EXP 103
21787: PUSH
21788: LD_EXP 103
21792: PPUSH
21793: LD_VAR 0 1
21797: PPUSH
21798: EMPTY
21799: PPUSH
21800: CALL_OW 1
21804: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21805: LD_ADDR_EXP 104
21809: PUSH
21810: LD_EXP 104
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: EMPTY
21821: PPUSH
21822: CALL_OW 1
21826: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21827: LD_ADDR_EXP 105
21831: PUSH
21832: LD_EXP 105
21836: PPUSH
21837: LD_VAR 0 1
21841: PPUSH
21842: EMPTY
21843: PPUSH
21844: CALL_OW 1
21848: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21849: LD_ADDR_EXP 106
21853: PUSH
21854: LD_EXP 106
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_INT 0
21866: PPUSH
21867: CALL_OW 1
21871: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21872: LD_ADDR_EXP 107
21876: PUSH
21877: LD_EXP 107
21881: PPUSH
21882: LD_VAR 0 1
21886: PPUSH
21887: EMPTY
21888: PPUSH
21889: CALL_OW 1
21893: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21894: LD_ADDR_EXP 108
21898: PUSH
21899: LD_EXP 108
21903: PPUSH
21904: LD_VAR 0 1
21908: PPUSH
21909: EMPTY
21910: PPUSH
21911: CALL_OW 1
21915: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21916: LD_ADDR_EXP 109
21920: PUSH
21921: LD_EXP 109
21925: PPUSH
21926: LD_VAR 0 1
21930: PPUSH
21931: EMPTY
21932: PPUSH
21933: CALL_OW 1
21937: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21938: LD_ADDR_EXP 110
21942: PUSH
21943: LD_EXP 110
21947: PPUSH
21948: LD_VAR 0 1
21952: PPUSH
21953: EMPTY
21954: PPUSH
21955: CALL_OW 1
21959: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21960: LD_ADDR_EXP 111
21964: PUSH
21965: LD_EXP 111
21969: PPUSH
21970: LD_VAR 0 1
21974: PPUSH
21975: EMPTY
21976: PPUSH
21977: CALL_OW 1
21981: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21982: LD_ADDR_EXP 112
21986: PUSH
21987: LD_EXP 112
21991: PPUSH
21992: LD_VAR 0 1
21996: PPUSH
21997: EMPTY
21998: PPUSH
21999: CALL_OW 1
22003: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22004: LD_ADDR_EXP 113
22008: PUSH
22009: LD_EXP 113
22013: PPUSH
22014: LD_VAR 0 1
22018: PPUSH
22019: EMPTY
22020: PPUSH
22021: CALL_OW 1
22025: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22026: LD_ADDR_EXP 114
22030: PUSH
22031: LD_EXP 114
22035: PPUSH
22036: LD_VAR 0 1
22040: PPUSH
22041: EMPTY
22042: PPUSH
22043: CALL_OW 1
22047: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22048: LD_ADDR_EXP 115
22052: PUSH
22053: LD_EXP 115
22057: PPUSH
22058: LD_VAR 0 1
22062: PPUSH
22063: EMPTY
22064: PPUSH
22065: CALL_OW 1
22069: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22070: LD_ADDR_EXP 116
22074: PUSH
22075: LD_EXP 116
22079: PPUSH
22080: LD_VAR 0 1
22084: PPUSH
22085: EMPTY
22086: PPUSH
22087: CALL_OW 1
22091: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22092: LD_ADDR_EXP 117
22096: PUSH
22097: LD_EXP 117
22101: PPUSH
22102: LD_VAR 0 1
22106: PPUSH
22107: EMPTY
22108: PPUSH
22109: CALL_OW 1
22113: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22114: LD_ADDR_EXP 118
22118: PUSH
22119: LD_EXP 118
22123: PPUSH
22124: LD_VAR 0 1
22128: PPUSH
22129: EMPTY
22130: PPUSH
22131: CALL_OW 1
22135: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22136: LD_ADDR_EXP 119
22140: PUSH
22141: LD_EXP 119
22145: PPUSH
22146: LD_VAR 0 1
22150: PPUSH
22151: EMPTY
22152: PPUSH
22153: CALL_OW 1
22157: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22158: LD_ADDR_EXP 120
22162: PUSH
22163: LD_EXP 120
22167: PPUSH
22168: LD_VAR 0 1
22172: PPUSH
22173: EMPTY
22174: PPUSH
22175: CALL_OW 1
22179: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22180: LD_ADDR_EXP 122
22184: PUSH
22185: LD_EXP 122
22189: PPUSH
22190: LD_VAR 0 1
22194: PPUSH
22195: EMPTY
22196: PPUSH
22197: CALL_OW 1
22201: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22202: LD_ADDR_EXP 124
22206: PUSH
22207: LD_EXP 124
22211: PPUSH
22212: LD_VAR 0 1
22216: PPUSH
22217: EMPTY
22218: PPUSH
22219: CALL_OW 1
22223: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22224: LD_ADDR_EXP 125
22228: PUSH
22229: LD_EXP 125
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: EMPTY
22240: PPUSH
22241: CALL_OW 1
22245: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22246: LD_ADDR_EXP 126
22250: PUSH
22251: LD_EXP 126
22255: PPUSH
22256: LD_VAR 0 1
22260: PPUSH
22261: EMPTY
22262: PPUSH
22263: CALL_OW 1
22267: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22268: LD_ADDR_EXP 127
22272: PUSH
22273: LD_EXP 127
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: EMPTY
22284: PPUSH
22285: CALL_OW 1
22289: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22290: LD_ADDR_EXP 128
22294: PUSH
22295: LD_EXP 128
22299: PPUSH
22300: LD_VAR 0 1
22304: PPUSH
22305: EMPTY
22306: PPUSH
22307: CALL_OW 1
22311: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22312: LD_ADDR_EXP 129
22316: PUSH
22317: LD_EXP 129
22321: PPUSH
22322: LD_VAR 0 1
22326: PPUSH
22327: EMPTY
22328: PPUSH
22329: CALL_OW 1
22333: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22334: LD_ADDR_EXP 130
22338: PUSH
22339: LD_EXP 130
22343: PPUSH
22344: LD_VAR 0 1
22348: PPUSH
22349: EMPTY
22350: PPUSH
22351: CALL_OW 1
22355: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22356: LD_ADDR_EXP 131
22360: PUSH
22361: LD_EXP 131
22365: PPUSH
22366: LD_VAR 0 1
22370: PPUSH
22371: EMPTY
22372: PPUSH
22373: CALL_OW 1
22377: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22378: LD_ADDR_EXP 132
22382: PUSH
22383: LD_EXP 132
22387: PPUSH
22388: LD_VAR 0 1
22392: PPUSH
22393: EMPTY
22394: PPUSH
22395: CALL_OW 1
22399: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22400: LD_ADDR_EXP 133
22404: PUSH
22405: LD_EXP 133
22409: PPUSH
22410: LD_VAR 0 1
22414: PPUSH
22415: EMPTY
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22422: LD_ADDR_EXP 134
22426: PUSH
22427: LD_EXP 134
22431: PPUSH
22432: LD_VAR 0 1
22436: PPUSH
22437: EMPTY
22438: PPUSH
22439: CALL_OW 1
22443: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22444: LD_ADDR_EXP 135
22448: PUSH
22449: LD_EXP 135
22453: PPUSH
22454: LD_VAR 0 1
22458: PPUSH
22459: EMPTY
22460: PPUSH
22461: CALL_OW 1
22465: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22466: LD_ADDR_EXP 136
22470: PUSH
22471: LD_EXP 136
22475: PPUSH
22476: LD_VAR 0 1
22480: PPUSH
22481: EMPTY
22482: PPUSH
22483: CALL_OW 1
22487: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22488: LD_ADDR_EXP 137
22492: PUSH
22493: LD_EXP 137
22497: PPUSH
22498: LD_VAR 0 1
22502: PPUSH
22503: LD_INT 0
22505: PPUSH
22506: CALL_OW 1
22510: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22511: LD_ADDR_EXP 138
22515: PUSH
22516: LD_EXP 138
22520: PPUSH
22521: LD_VAR 0 1
22525: PPUSH
22526: LD_INT 0
22528: PPUSH
22529: CALL_OW 1
22533: ST_TO_ADDR
// end ;
22534: LD_VAR 0 2
22538: RET
// export function MC_Add ( side , units ) ; var base ; begin
22539: LD_INT 0
22541: PPUSH
22542: PPUSH
// base := mc_bases + 1 ;
22543: LD_ADDR_VAR 0 4
22547: PUSH
22548: LD_EXP 95
22552: PUSH
22553: LD_INT 1
22555: PLUS
22556: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22557: LD_ADDR_EXP 121
22561: PUSH
22562: LD_EXP 121
22566: PPUSH
22567: LD_VAR 0 4
22571: PPUSH
22572: LD_VAR 0 1
22576: PPUSH
22577: CALL_OW 1
22581: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22582: LD_ADDR_EXP 95
22586: PUSH
22587: LD_EXP 95
22591: PPUSH
22592: LD_VAR 0 4
22596: PPUSH
22597: LD_VAR 0 2
22601: PPUSH
22602: CALL_OW 1
22606: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22607: LD_ADDR_EXP 96
22611: PUSH
22612: LD_EXP 96
22616: PPUSH
22617: LD_VAR 0 4
22621: PPUSH
22622: EMPTY
22623: PPUSH
22624: CALL_OW 1
22628: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22629: LD_ADDR_EXP 97
22633: PUSH
22634: LD_EXP 97
22638: PPUSH
22639: LD_VAR 0 4
22643: PPUSH
22644: EMPTY
22645: PPUSH
22646: CALL_OW 1
22650: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22651: LD_ADDR_EXP 98
22655: PUSH
22656: LD_EXP 98
22660: PPUSH
22661: LD_VAR 0 4
22665: PPUSH
22666: EMPTY
22667: PPUSH
22668: CALL_OW 1
22672: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22673: LD_ADDR_EXP 99
22677: PUSH
22678: LD_EXP 99
22682: PPUSH
22683: LD_VAR 0 4
22687: PPUSH
22688: EMPTY
22689: PPUSH
22690: CALL_OW 1
22694: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22695: LD_ADDR_EXP 100
22699: PUSH
22700: LD_EXP 100
22704: PPUSH
22705: LD_VAR 0 4
22709: PPUSH
22710: EMPTY
22711: PPUSH
22712: CALL_OW 1
22716: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22717: LD_ADDR_EXP 101
22721: PUSH
22722: LD_EXP 101
22726: PPUSH
22727: LD_VAR 0 4
22731: PPUSH
22732: EMPTY
22733: PPUSH
22734: CALL_OW 1
22738: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22739: LD_ADDR_EXP 102
22743: PUSH
22744: LD_EXP 102
22748: PPUSH
22749: LD_VAR 0 4
22753: PPUSH
22754: EMPTY
22755: PPUSH
22756: CALL_OW 1
22760: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22761: LD_ADDR_EXP 103
22765: PUSH
22766: LD_EXP 103
22770: PPUSH
22771: LD_VAR 0 4
22775: PPUSH
22776: EMPTY
22777: PPUSH
22778: CALL_OW 1
22782: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22783: LD_ADDR_EXP 104
22787: PUSH
22788: LD_EXP 104
22792: PPUSH
22793: LD_VAR 0 4
22797: PPUSH
22798: EMPTY
22799: PPUSH
22800: CALL_OW 1
22804: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22805: LD_ADDR_EXP 105
22809: PUSH
22810: LD_EXP 105
22814: PPUSH
22815: LD_VAR 0 4
22819: PPUSH
22820: EMPTY
22821: PPUSH
22822: CALL_OW 1
22826: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22827: LD_ADDR_EXP 106
22831: PUSH
22832: LD_EXP 106
22836: PPUSH
22837: LD_VAR 0 4
22841: PPUSH
22842: LD_INT 0
22844: PPUSH
22845: CALL_OW 1
22849: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22850: LD_ADDR_EXP 107
22854: PUSH
22855: LD_EXP 107
22859: PPUSH
22860: LD_VAR 0 4
22864: PPUSH
22865: EMPTY
22866: PPUSH
22867: CALL_OW 1
22871: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22872: LD_ADDR_EXP 108
22876: PUSH
22877: LD_EXP 108
22881: PPUSH
22882: LD_VAR 0 4
22886: PPUSH
22887: EMPTY
22888: PPUSH
22889: CALL_OW 1
22893: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22894: LD_ADDR_EXP 109
22898: PUSH
22899: LD_EXP 109
22903: PPUSH
22904: LD_VAR 0 4
22908: PPUSH
22909: EMPTY
22910: PPUSH
22911: CALL_OW 1
22915: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22916: LD_ADDR_EXP 110
22920: PUSH
22921: LD_EXP 110
22925: PPUSH
22926: LD_VAR 0 4
22930: PPUSH
22931: EMPTY
22932: PPUSH
22933: CALL_OW 1
22937: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22938: LD_ADDR_EXP 111
22942: PUSH
22943: LD_EXP 111
22947: PPUSH
22948: LD_VAR 0 4
22952: PPUSH
22953: EMPTY
22954: PPUSH
22955: CALL_OW 1
22959: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22960: LD_ADDR_EXP 112
22964: PUSH
22965: LD_EXP 112
22969: PPUSH
22970: LD_VAR 0 4
22974: PPUSH
22975: EMPTY
22976: PPUSH
22977: CALL_OW 1
22981: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22982: LD_ADDR_EXP 113
22986: PUSH
22987: LD_EXP 113
22991: PPUSH
22992: LD_VAR 0 4
22996: PPUSH
22997: EMPTY
22998: PPUSH
22999: CALL_OW 1
23003: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23004: LD_ADDR_EXP 114
23008: PUSH
23009: LD_EXP 114
23013: PPUSH
23014: LD_VAR 0 4
23018: PPUSH
23019: EMPTY
23020: PPUSH
23021: CALL_OW 1
23025: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23026: LD_ADDR_EXP 115
23030: PUSH
23031: LD_EXP 115
23035: PPUSH
23036: LD_VAR 0 4
23040: PPUSH
23041: EMPTY
23042: PPUSH
23043: CALL_OW 1
23047: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23048: LD_ADDR_EXP 116
23052: PUSH
23053: LD_EXP 116
23057: PPUSH
23058: LD_VAR 0 4
23062: PPUSH
23063: EMPTY
23064: PPUSH
23065: CALL_OW 1
23069: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23070: LD_ADDR_EXP 117
23074: PUSH
23075: LD_EXP 117
23079: PPUSH
23080: LD_VAR 0 4
23084: PPUSH
23085: EMPTY
23086: PPUSH
23087: CALL_OW 1
23091: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23092: LD_ADDR_EXP 118
23096: PUSH
23097: LD_EXP 118
23101: PPUSH
23102: LD_VAR 0 4
23106: PPUSH
23107: EMPTY
23108: PPUSH
23109: CALL_OW 1
23113: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23114: LD_ADDR_EXP 119
23118: PUSH
23119: LD_EXP 119
23123: PPUSH
23124: LD_VAR 0 4
23128: PPUSH
23129: EMPTY
23130: PPUSH
23131: CALL_OW 1
23135: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23136: LD_ADDR_EXP 120
23140: PUSH
23141: LD_EXP 120
23145: PPUSH
23146: LD_VAR 0 4
23150: PPUSH
23151: EMPTY
23152: PPUSH
23153: CALL_OW 1
23157: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23158: LD_ADDR_EXP 122
23162: PUSH
23163: LD_EXP 122
23167: PPUSH
23168: LD_VAR 0 4
23172: PPUSH
23173: EMPTY
23174: PPUSH
23175: CALL_OW 1
23179: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23180: LD_ADDR_EXP 124
23184: PUSH
23185: LD_EXP 124
23189: PPUSH
23190: LD_VAR 0 4
23194: PPUSH
23195: EMPTY
23196: PPUSH
23197: CALL_OW 1
23201: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23202: LD_ADDR_EXP 125
23206: PUSH
23207: LD_EXP 125
23211: PPUSH
23212: LD_VAR 0 4
23216: PPUSH
23217: EMPTY
23218: PPUSH
23219: CALL_OW 1
23223: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23224: LD_ADDR_EXP 126
23228: PUSH
23229: LD_EXP 126
23233: PPUSH
23234: LD_VAR 0 4
23238: PPUSH
23239: EMPTY
23240: PPUSH
23241: CALL_OW 1
23245: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23246: LD_ADDR_EXP 127
23250: PUSH
23251: LD_EXP 127
23255: PPUSH
23256: LD_VAR 0 4
23260: PPUSH
23261: EMPTY
23262: PPUSH
23263: CALL_OW 1
23267: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23268: LD_ADDR_EXP 128
23272: PUSH
23273: LD_EXP 128
23277: PPUSH
23278: LD_VAR 0 4
23282: PPUSH
23283: EMPTY
23284: PPUSH
23285: CALL_OW 1
23289: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23290: LD_ADDR_EXP 129
23294: PUSH
23295: LD_EXP 129
23299: PPUSH
23300: LD_VAR 0 4
23304: PPUSH
23305: EMPTY
23306: PPUSH
23307: CALL_OW 1
23311: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23312: LD_ADDR_EXP 130
23316: PUSH
23317: LD_EXP 130
23321: PPUSH
23322: LD_VAR 0 4
23326: PPUSH
23327: EMPTY
23328: PPUSH
23329: CALL_OW 1
23333: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23334: LD_ADDR_EXP 131
23338: PUSH
23339: LD_EXP 131
23343: PPUSH
23344: LD_VAR 0 4
23348: PPUSH
23349: EMPTY
23350: PPUSH
23351: CALL_OW 1
23355: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23356: LD_ADDR_EXP 132
23360: PUSH
23361: LD_EXP 132
23365: PPUSH
23366: LD_VAR 0 4
23370: PPUSH
23371: EMPTY
23372: PPUSH
23373: CALL_OW 1
23377: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23378: LD_ADDR_EXP 133
23382: PUSH
23383: LD_EXP 133
23387: PPUSH
23388: LD_VAR 0 4
23392: PPUSH
23393: EMPTY
23394: PPUSH
23395: CALL_OW 1
23399: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23400: LD_ADDR_EXP 134
23404: PUSH
23405: LD_EXP 134
23409: PPUSH
23410: LD_VAR 0 4
23414: PPUSH
23415: EMPTY
23416: PPUSH
23417: CALL_OW 1
23421: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23422: LD_ADDR_EXP 135
23426: PUSH
23427: LD_EXP 135
23431: PPUSH
23432: LD_VAR 0 4
23436: PPUSH
23437: EMPTY
23438: PPUSH
23439: CALL_OW 1
23443: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23444: LD_ADDR_EXP 136
23448: PUSH
23449: LD_EXP 136
23453: PPUSH
23454: LD_VAR 0 4
23458: PPUSH
23459: EMPTY
23460: PPUSH
23461: CALL_OW 1
23465: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23466: LD_ADDR_EXP 137
23470: PUSH
23471: LD_EXP 137
23475: PPUSH
23476: LD_VAR 0 4
23480: PPUSH
23481: LD_INT 0
23483: PPUSH
23484: CALL_OW 1
23488: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23489: LD_ADDR_EXP 138
23493: PUSH
23494: LD_EXP 138
23498: PPUSH
23499: LD_VAR 0 4
23503: PPUSH
23504: LD_INT 0
23506: PPUSH
23507: CALL_OW 1
23511: ST_TO_ADDR
// result := base ;
23512: LD_ADDR_VAR 0 3
23516: PUSH
23517: LD_VAR 0 4
23521: ST_TO_ADDR
// end ;
23522: LD_VAR 0 3
23526: RET
// export function MC_Start ( ) ; var i ; begin
23527: LD_INT 0
23529: PPUSH
23530: PPUSH
// for i = 1 to mc_bases do
23531: LD_ADDR_VAR 0 2
23535: PUSH
23536: DOUBLE
23537: LD_INT 1
23539: DEC
23540: ST_TO_ADDR
23541: LD_EXP 95
23545: PUSH
23546: FOR_TO
23547: IFFALSE 24647
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23549: LD_ADDR_EXP 95
23553: PUSH
23554: LD_EXP 95
23558: PPUSH
23559: LD_VAR 0 2
23563: PPUSH
23564: LD_EXP 95
23568: PUSH
23569: LD_VAR 0 2
23573: ARRAY
23574: PUSH
23575: LD_INT 0
23577: DIFF
23578: PPUSH
23579: CALL_OW 1
23583: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23584: LD_ADDR_EXP 96
23588: PUSH
23589: LD_EXP 96
23593: PPUSH
23594: LD_VAR 0 2
23598: PPUSH
23599: EMPTY
23600: PPUSH
23601: CALL_OW 1
23605: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23606: LD_ADDR_EXP 97
23610: PUSH
23611: LD_EXP 97
23615: PPUSH
23616: LD_VAR 0 2
23620: PPUSH
23621: EMPTY
23622: PPUSH
23623: CALL_OW 1
23627: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23628: LD_ADDR_EXP 98
23632: PUSH
23633: LD_EXP 98
23637: PPUSH
23638: LD_VAR 0 2
23642: PPUSH
23643: EMPTY
23644: PPUSH
23645: CALL_OW 1
23649: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23650: LD_ADDR_EXP 99
23654: PUSH
23655: LD_EXP 99
23659: PPUSH
23660: LD_VAR 0 2
23664: PPUSH
23665: EMPTY
23666: PUSH
23667: EMPTY
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: PPUSH
23673: CALL_OW 1
23677: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23678: LD_ADDR_EXP 100
23682: PUSH
23683: LD_EXP 100
23687: PPUSH
23688: LD_VAR 0 2
23692: PPUSH
23693: EMPTY
23694: PPUSH
23695: CALL_OW 1
23699: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23700: LD_ADDR_EXP 127
23704: PUSH
23705: LD_EXP 127
23709: PPUSH
23710: LD_VAR 0 2
23714: PPUSH
23715: EMPTY
23716: PPUSH
23717: CALL_OW 1
23721: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23722: LD_ADDR_EXP 101
23726: PUSH
23727: LD_EXP 101
23731: PPUSH
23732: LD_VAR 0 2
23736: PPUSH
23737: EMPTY
23738: PPUSH
23739: CALL_OW 1
23743: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23744: LD_ADDR_EXP 102
23748: PUSH
23749: LD_EXP 102
23753: PPUSH
23754: LD_VAR 0 2
23758: PPUSH
23759: EMPTY
23760: PPUSH
23761: CALL_OW 1
23765: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23766: LD_ADDR_EXP 103
23770: PUSH
23771: LD_EXP 103
23775: PPUSH
23776: LD_VAR 0 2
23780: PPUSH
23781: LD_EXP 95
23785: PUSH
23786: LD_VAR 0 2
23790: ARRAY
23791: PPUSH
23792: LD_INT 2
23794: PUSH
23795: LD_INT 30
23797: PUSH
23798: LD_INT 32
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: PUSH
23805: LD_INT 30
23807: PUSH
23808: LD_INT 33
23810: PUSH
23811: EMPTY
23812: LIST
23813: LIST
23814: PUSH
23815: EMPTY
23816: LIST
23817: LIST
23818: LIST
23819: PPUSH
23820: CALL_OW 72
23824: PPUSH
23825: CALL_OW 1
23829: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23830: LD_ADDR_EXP 104
23834: PUSH
23835: LD_EXP 104
23839: PPUSH
23840: LD_VAR 0 2
23844: PPUSH
23845: LD_EXP 95
23849: PUSH
23850: LD_VAR 0 2
23854: ARRAY
23855: PPUSH
23856: LD_INT 2
23858: PUSH
23859: LD_INT 30
23861: PUSH
23862: LD_INT 32
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: PUSH
23869: LD_INT 30
23871: PUSH
23872: LD_INT 31
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: PUSH
23879: EMPTY
23880: LIST
23881: LIST
23882: LIST
23883: PUSH
23884: LD_INT 58
23886: PUSH
23887: EMPTY
23888: LIST
23889: PUSH
23890: EMPTY
23891: LIST
23892: LIST
23893: PPUSH
23894: CALL_OW 72
23898: PPUSH
23899: CALL_OW 1
23903: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23904: LD_ADDR_EXP 105
23908: PUSH
23909: LD_EXP 105
23913: PPUSH
23914: LD_VAR 0 2
23918: PPUSH
23919: EMPTY
23920: PPUSH
23921: CALL_OW 1
23925: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23926: LD_ADDR_EXP 109
23930: PUSH
23931: LD_EXP 109
23935: PPUSH
23936: LD_VAR 0 2
23940: PPUSH
23941: EMPTY
23942: PPUSH
23943: CALL_OW 1
23947: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23948: LD_ADDR_EXP 108
23952: PUSH
23953: LD_EXP 108
23957: PPUSH
23958: LD_VAR 0 2
23962: PPUSH
23963: EMPTY
23964: PPUSH
23965: CALL_OW 1
23969: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23970: LD_ADDR_EXP 110
23974: PUSH
23975: LD_EXP 110
23979: PPUSH
23980: LD_VAR 0 2
23984: PPUSH
23985: EMPTY
23986: PPUSH
23987: CALL_OW 1
23991: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23992: LD_ADDR_EXP 111
23996: PUSH
23997: LD_EXP 111
24001: PPUSH
24002: LD_VAR 0 2
24006: PPUSH
24007: EMPTY
24008: PPUSH
24009: CALL_OW 1
24013: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24014: LD_ADDR_EXP 112
24018: PUSH
24019: LD_EXP 112
24023: PPUSH
24024: LD_VAR 0 2
24028: PPUSH
24029: EMPTY
24030: PPUSH
24031: CALL_OW 1
24035: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24036: LD_ADDR_EXP 113
24040: PUSH
24041: LD_EXP 113
24045: PPUSH
24046: LD_VAR 0 2
24050: PPUSH
24051: EMPTY
24052: PPUSH
24053: CALL_OW 1
24057: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24058: LD_ADDR_EXP 114
24062: PUSH
24063: LD_EXP 114
24067: PPUSH
24068: LD_VAR 0 2
24072: PPUSH
24073: EMPTY
24074: PPUSH
24075: CALL_OW 1
24079: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24080: LD_ADDR_EXP 115
24084: PUSH
24085: LD_EXP 115
24089: PPUSH
24090: LD_VAR 0 2
24094: PPUSH
24095: EMPTY
24096: PPUSH
24097: CALL_OW 1
24101: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24102: LD_ADDR_EXP 116
24106: PUSH
24107: LD_EXP 116
24111: PPUSH
24112: LD_VAR 0 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL_OW 1
24123: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24124: LD_ADDR_EXP 117
24128: PUSH
24129: LD_EXP 117
24133: PPUSH
24134: LD_VAR 0 2
24138: PPUSH
24139: EMPTY
24140: PPUSH
24141: CALL_OW 1
24145: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24146: LD_ADDR_EXP 106
24150: PUSH
24151: LD_EXP 106
24155: PPUSH
24156: LD_VAR 0 2
24160: PPUSH
24161: LD_INT 0
24163: PPUSH
24164: CALL_OW 1
24168: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24169: LD_ADDR_EXP 119
24173: PUSH
24174: LD_EXP 119
24178: PPUSH
24179: LD_VAR 0 2
24183: PPUSH
24184: LD_INT 0
24186: PPUSH
24187: CALL_OW 1
24191: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24192: LD_ADDR_EXP 107
24196: PUSH
24197: LD_EXP 107
24201: PPUSH
24202: LD_VAR 0 2
24206: PPUSH
24207: EMPTY
24208: PPUSH
24209: CALL_OW 1
24213: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24214: LD_ADDR_EXP 118
24218: PUSH
24219: LD_EXP 118
24223: PPUSH
24224: LD_VAR 0 2
24228: PPUSH
24229: LD_INT 0
24231: PPUSH
24232: CALL_OW 1
24236: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24237: LD_ADDR_EXP 120
24241: PUSH
24242: LD_EXP 120
24246: PPUSH
24247: LD_VAR 0 2
24251: PPUSH
24252: EMPTY
24253: PPUSH
24254: CALL_OW 1
24258: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24259: LD_ADDR_EXP 123
24263: PUSH
24264: LD_EXP 123
24268: PPUSH
24269: LD_VAR 0 2
24273: PPUSH
24274: LD_INT 0
24276: PPUSH
24277: CALL_OW 1
24281: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24282: LD_ADDR_EXP 124
24286: PUSH
24287: LD_EXP 124
24291: PPUSH
24292: LD_VAR 0 2
24296: PPUSH
24297: EMPTY
24298: PPUSH
24299: CALL_OW 1
24303: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24304: LD_ADDR_EXP 125
24308: PUSH
24309: LD_EXP 125
24313: PPUSH
24314: LD_VAR 0 2
24318: PPUSH
24319: EMPTY
24320: PPUSH
24321: CALL_OW 1
24325: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24326: LD_ADDR_EXP 126
24330: PUSH
24331: LD_EXP 126
24335: PPUSH
24336: LD_VAR 0 2
24340: PPUSH
24341: EMPTY
24342: PPUSH
24343: CALL_OW 1
24347: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24348: LD_ADDR_EXP 128
24352: PUSH
24353: LD_EXP 128
24357: PPUSH
24358: LD_VAR 0 2
24362: PPUSH
24363: LD_EXP 95
24367: PUSH
24368: LD_VAR 0 2
24372: ARRAY
24373: PPUSH
24374: LD_INT 2
24376: PUSH
24377: LD_INT 30
24379: PUSH
24380: LD_INT 6
24382: PUSH
24383: EMPTY
24384: LIST
24385: LIST
24386: PUSH
24387: LD_INT 30
24389: PUSH
24390: LD_INT 7
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: PUSH
24397: LD_INT 30
24399: PUSH
24400: LD_INT 8
24402: PUSH
24403: EMPTY
24404: LIST
24405: LIST
24406: PUSH
24407: EMPTY
24408: LIST
24409: LIST
24410: LIST
24411: LIST
24412: PPUSH
24413: CALL_OW 72
24417: PPUSH
24418: CALL_OW 1
24422: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24423: LD_ADDR_EXP 129
24427: PUSH
24428: LD_EXP 129
24432: PPUSH
24433: LD_VAR 0 2
24437: PPUSH
24438: EMPTY
24439: PPUSH
24440: CALL_OW 1
24444: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24445: LD_ADDR_EXP 130
24449: PUSH
24450: LD_EXP 130
24454: PPUSH
24455: LD_VAR 0 2
24459: PPUSH
24460: EMPTY
24461: PPUSH
24462: CALL_OW 1
24466: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24467: LD_ADDR_EXP 131
24471: PUSH
24472: LD_EXP 131
24476: PPUSH
24477: LD_VAR 0 2
24481: PPUSH
24482: EMPTY
24483: PPUSH
24484: CALL_OW 1
24488: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24489: LD_ADDR_EXP 132
24493: PUSH
24494: LD_EXP 132
24498: PPUSH
24499: LD_VAR 0 2
24503: PPUSH
24504: EMPTY
24505: PPUSH
24506: CALL_OW 1
24510: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24511: LD_ADDR_EXP 133
24515: PUSH
24516: LD_EXP 133
24520: PPUSH
24521: LD_VAR 0 2
24525: PPUSH
24526: EMPTY
24527: PPUSH
24528: CALL_OW 1
24532: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24533: LD_ADDR_EXP 134
24537: PUSH
24538: LD_EXP 134
24542: PPUSH
24543: LD_VAR 0 2
24547: PPUSH
24548: EMPTY
24549: PPUSH
24550: CALL_OW 1
24554: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24555: LD_ADDR_EXP 135
24559: PUSH
24560: LD_EXP 135
24564: PPUSH
24565: LD_VAR 0 2
24569: PPUSH
24570: EMPTY
24571: PPUSH
24572: CALL_OW 1
24576: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24577: LD_ADDR_EXP 136
24581: PUSH
24582: LD_EXP 136
24586: PPUSH
24587: LD_VAR 0 2
24591: PPUSH
24592: EMPTY
24593: PPUSH
24594: CALL_OW 1
24598: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24599: LD_ADDR_EXP 137
24603: PUSH
24604: LD_EXP 137
24608: PPUSH
24609: LD_VAR 0 2
24613: PPUSH
24614: LD_INT 0
24616: PPUSH
24617: CALL_OW 1
24621: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24622: LD_ADDR_EXP 138
24626: PUSH
24627: LD_EXP 138
24631: PPUSH
24632: LD_VAR 0 2
24636: PPUSH
24637: LD_INT 0
24639: PPUSH
24640: CALL_OW 1
24644: ST_TO_ADDR
// end ;
24645: GO 23546
24647: POP
24648: POP
// MC_InitSides ( ) ;
24649: CALL 24935 0 0
// MC_InitResearch ( ) ;
24653: CALL 24674 0 0
// CustomInitMacro ( ) ;
24657: CALL 232 0 0
// skirmish := true ;
24661: LD_ADDR_EXP 93
24665: PUSH
24666: LD_INT 1
24668: ST_TO_ADDR
// end ;
24669: LD_VAR 0 1
24673: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24674: LD_INT 0
24676: PPUSH
24677: PPUSH
24678: PPUSH
24679: PPUSH
24680: PPUSH
24681: PPUSH
// if not mc_bases then
24682: LD_EXP 95
24686: NOT
24687: IFFALSE 24691
// exit ;
24689: GO 24930
// for i = 1 to 8 do
24691: LD_ADDR_VAR 0 2
24695: PUSH
24696: DOUBLE
24697: LD_INT 1
24699: DEC
24700: ST_TO_ADDR
24701: LD_INT 8
24703: PUSH
24704: FOR_TO
24705: IFFALSE 24731
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24707: LD_ADDR_EXP 122
24711: PUSH
24712: LD_EXP 122
24716: PPUSH
24717: LD_VAR 0 2
24721: PPUSH
24722: EMPTY
24723: PPUSH
24724: CALL_OW 1
24728: ST_TO_ADDR
24729: GO 24704
24731: POP
24732: POP
// tmp := [ ] ;
24733: LD_ADDR_VAR 0 5
24737: PUSH
24738: EMPTY
24739: ST_TO_ADDR
// for i = 1 to mc_sides do
24740: LD_ADDR_VAR 0 2
24744: PUSH
24745: DOUBLE
24746: LD_INT 1
24748: DEC
24749: ST_TO_ADDR
24750: LD_EXP 121
24754: PUSH
24755: FOR_TO
24756: IFFALSE 24814
// if not mc_sides [ i ] in tmp then
24758: LD_EXP 121
24762: PUSH
24763: LD_VAR 0 2
24767: ARRAY
24768: PUSH
24769: LD_VAR 0 5
24773: IN
24774: NOT
24775: IFFALSE 24812
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24777: LD_ADDR_VAR 0 5
24781: PUSH
24782: LD_VAR 0 5
24786: PPUSH
24787: LD_VAR 0 5
24791: PUSH
24792: LD_INT 1
24794: PLUS
24795: PPUSH
24796: LD_EXP 121
24800: PUSH
24801: LD_VAR 0 2
24805: ARRAY
24806: PPUSH
24807: CALL_OW 2
24811: ST_TO_ADDR
24812: GO 24755
24814: POP
24815: POP
// if not tmp then
24816: LD_VAR 0 5
24820: NOT
24821: IFFALSE 24825
// exit ;
24823: GO 24930
// for j in tmp do
24825: LD_ADDR_VAR 0 3
24829: PUSH
24830: LD_VAR 0 5
24834: PUSH
24835: FOR_IN
24836: IFFALSE 24928
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24838: LD_ADDR_VAR 0 6
24842: PUSH
24843: LD_INT 22
24845: PUSH
24846: LD_VAR 0 3
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: ST_TO_ADDR
// if not un then
24860: LD_VAR 0 6
24864: NOT
24865: IFFALSE 24869
// continue ;
24867: GO 24835
// nation := GetNation ( un [ 1 ] ) ;
24869: LD_ADDR_VAR 0 4
24873: PUSH
24874: LD_VAR 0 6
24878: PUSH
24879: LD_INT 1
24881: ARRAY
24882: PPUSH
24883: CALL_OW 248
24887: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24888: LD_ADDR_EXP 122
24892: PUSH
24893: LD_EXP 122
24897: PPUSH
24898: LD_VAR 0 3
24902: PPUSH
24903: LD_VAR 0 3
24907: PPUSH
24908: LD_VAR 0 4
24912: PPUSH
24913: LD_INT 1
24915: PPUSH
24916: CALL 52051 0 3
24920: PPUSH
24921: CALL_OW 1
24925: ST_TO_ADDR
// end ;
24926: GO 24835
24928: POP
24929: POP
// end ;
24930: LD_VAR 0 1
24934: RET
// export function MC_InitSides ( ) ; var i ; begin
24935: LD_INT 0
24937: PPUSH
24938: PPUSH
// if not mc_bases then
24939: LD_EXP 95
24943: NOT
24944: IFFALSE 24948
// exit ;
24946: GO 25022
// for i = 1 to mc_bases do
24948: LD_ADDR_VAR 0 2
24952: PUSH
24953: DOUBLE
24954: LD_INT 1
24956: DEC
24957: ST_TO_ADDR
24958: LD_EXP 95
24962: PUSH
24963: FOR_TO
24964: IFFALSE 25020
// if mc_bases [ i ] then
24966: LD_EXP 95
24970: PUSH
24971: LD_VAR 0 2
24975: ARRAY
24976: IFFALSE 25018
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24978: LD_ADDR_EXP 121
24982: PUSH
24983: LD_EXP 121
24987: PPUSH
24988: LD_VAR 0 2
24992: PPUSH
24993: LD_EXP 95
24997: PUSH
24998: LD_VAR 0 2
25002: ARRAY
25003: PUSH
25004: LD_INT 1
25006: ARRAY
25007: PPUSH
25008: CALL_OW 255
25012: PPUSH
25013: CALL_OW 1
25017: ST_TO_ADDR
25018: GO 24963
25020: POP
25021: POP
// end ;
25022: LD_VAR 0 1
25026: RET
// every 0 0$03 trigger skirmish do
25027: LD_EXP 93
25031: IFFALSE 25185
25033: GO 25035
25035: DISABLE
// begin enable ;
25036: ENABLE
// MC_CheckBuildings ( ) ;
25037: CALL 29683 0 0
// MC_CheckPeopleLife ( ) ;
25041: CALL 29844 0 0
// RaiseSailEvent ( 100 ) ;
25045: LD_INT 100
25047: PPUSH
25048: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25052: LD_INT 103
25054: PPUSH
25055: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25059: LD_INT 104
25061: PPUSH
25062: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25066: LD_INT 105
25068: PPUSH
25069: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25073: LD_INT 106
25075: PPUSH
25076: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25080: LD_INT 107
25082: PPUSH
25083: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25087: LD_INT 108
25089: PPUSH
25090: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25094: LD_INT 109
25096: PPUSH
25097: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25101: LD_INT 110
25103: PPUSH
25104: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25108: LD_INT 111
25110: PPUSH
25111: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25115: LD_INT 112
25117: PPUSH
25118: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25122: LD_INT 113
25124: PPUSH
25125: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25129: LD_INT 120
25131: PPUSH
25132: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25136: LD_INT 121
25138: PPUSH
25139: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25143: LD_INT 122
25145: PPUSH
25146: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25150: LD_INT 123
25152: PPUSH
25153: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25157: LD_INT 124
25159: PPUSH
25160: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25164: LD_INT 125
25166: PPUSH
25167: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25171: LD_INT 126
25173: PPUSH
25174: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25178: LD_INT 200
25180: PPUSH
25181: CALL_OW 427
// end ;
25185: END
// on SailEvent ( event ) do begin if event < 100 then
25186: LD_VAR 0 1
25190: PUSH
25191: LD_INT 100
25193: LESS
25194: IFFALSE 25205
// CustomEvent ( event ) ;
25196: LD_VAR 0 1
25200: PPUSH
25201: CALL 10899 0 1
// if event = 100 then
25205: LD_VAR 0 1
25209: PUSH
25210: LD_INT 100
25212: EQUAL
25213: IFFALSE 25219
// MC_ClassManager ( ) ;
25215: CALL 25611 0 0
// if event = 101 then
25219: LD_VAR 0 1
25223: PUSH
25224: LD_INT 101
25226: EQUAL
25227: IFFALSE 25233
// MC_RepairBuildings ( ) ;
25229: CALL 30429 0 0
// if event = 102 then
25233: LD_VAR 0 1
25237: PUSH
25238: LD_INT 102
25240: EQUAL
25241: IFFALSE 25247
// MC_Heal ( ) ;
25243: CALL 31336 0 0
// if event = 103 then
25247: LD_VAR 0 1
25251: PUSH
25252: LD_INT 103
25254: EQUAL
25255: IFFALSE 25261
// MC_Build ( ) ;
25257: CALL 31758 0 0
// if event = 104 then
25261: LD_VAR 0 1
25265: PUSH
25266: LD_INT 104
25268: EQUAL
25269: IFFALSE 25275
// MC_TurretWeapon ( ) ;
25271: CALL 33399 0 0
// if event = 105 then
25275: LD_VAR 0 1
25279: PUSH
25280: LD_INT 105
25282: EQUAL
25283: IFFALSE 25289
// MC_BuildUpgrade ( ) ;
25285: CALL 32950 0 0
// if event = 106 then
25289: LD_VAR 0 1
25293: PUSH
25294: LD_INT 106
25296: EQUAL
25297: IFFALSE 25303
// MC_PlantMines ( ) ;
25299: CALL 33829 0 0
// if event = 107 then
25303: LD_VAR 0 1
25307: PUSH
25308: LD_INT 107
25310: EQUAL
25311: IFFALSE 25317
// MC_CollectCrates ( ) ;
25313: CALL 34620 0 0
// if event = 108 then
25317: LD_VAR 0 1
25321: PUSH
25322: LD_INT 108
25324: EQUAL
25325: IFFALSE 25331
// MC_LinkRemoteControl ( ) ;
25327: CALL 36470 0 0
// if event = 109 then
25331: LD_VAR 0 1
25335: PUSH
25336: LD_INT 109
25338: EQUAL
25339: IFFALSE 25345
// MC_ProduceVehicle ( ) ;
25341: CALL 36651 0 0
// if event = 110 then
25345: LD_VAR 0 1
25349: PUSH
25350: LD_INT 110
25352: EQUAL
25353: IFFALSE 25359
// MC_SendAttack ( ) ;
25355: CALL 37117 0 0
// if event = 111 then
25359: LD_VAR 0 1
25363: PUSH
25364: LD_INT 111
25366: EQUAL
25367: IFFALSE 25373
// MC_Defend ( ) ;
25369: CALL 37225 0 0
// if event = 112 then
25373: LD_VAR 0 1
25377: PUSH
25378: LD_INT 112
25380: EQUAL
25381: IFFALSE 25387
// MC_Research ( ) ;
25383: CALL 38105 0 0
// if event = 113 then
25387: LD_VAR 0 1
25391: PUSH
25392: LD_INT 113
25394: EQUAL
25395: IFFALSE 25401
// MC_MinesTrigger ( ) ;
25397: CALL 39219 0 0
// if event = 120 then
25401: LD_VAR 0 1
25405: PUSH
25406: LD_INT 120
25408: EQUAL
25409: IFFALSE 25415
// MC_RepairVehicle ( ) ;
25411: CALL 39318 0 0
// if event = 121 then
25415: LD_VAR 0 1
25419: PUSH
25420: LD_INT 121
25422: EQUAL
25423: IFFALSE 25429
// MC_TameApe ( ) ;
25425: CALL 40059 0 0
// if event = 122 then
25429: LD_VAR 0 1
25433: PUSH
25434: LD_INT 122
25436: EQUAL
25437: IFFALSE 25443
// MC_ChangeApeClass ( ) ;
25439: CALL 40888 0 0
// if event = 123 then
25443: LD_VAR 0 1
25447: PUSH
25448: LD_INT 123
25450: EQUAL
25451: IFFALSE 25457
// MC_Bazooka ( ) ;
25453: CALL 41538 0 0
// if event = 124 then
25457: LD_VAR 0 1
25461: PUSH
25462: LD_INT 124
25464: EQUAL
25465: IFFALSE 25471
// MC_TeleportExit ( ) ;
25467: CALL 41736 0 0
// if event = 125 then
25471: LD_VAR 0 1
25475: PUSH
25476: LD_INT 125
25478: EQUAL
25479: IFFALSE 25485
// MC_Deposits ( ) ;
25481: CALL 42383 0 0
// if event = 126 then
25485: LD_VAR 0 1
25489: PUSH
25490: LD_INT 126
25492: EQUAL
25493: IFFALSE 25499
// MC_RemoteDriver ( ) ;
25495: CALL 43008 0 0
// if event = 200 then
25499: LD_VAR 0 1
25503: PUSH
25504: LD_INT 200
25506: EQUAL
25507: IFFALSE 25513
// MC_Idle ( ) ;
25509: CALL 44957 0 0
// end ;
25513: PPOPN 1
25515: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25516: LD_INT 0
25518: PPUSH
25519: PPUSH
// if not mc_bases [ base ] or not tag then
25520: LD_EXP 95
25524: PUSH
25525: LD_VAR 0 1
25529: ARRAY
25530: NOT
25531: PUSH
25532: LD_VAR 0 2
25536: NOT
25537: OR
25538: IFFALSE 25542
// exit ;
25540: GO 25606
// for i in mc_bases [ base ] union mc_ape [ base ] do
25542: LD_ADDR_VAR 0 4
25546: PUSH
25547: LD_EXP 95
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PUSH
25558: LD_EXP 124
25562: PUSH
25563: LD_VAR 0 1
25567: ARRAY
25568: UNION
25569: PUSH
25570: FOR_IN
25571: IFFALSE 25604
// if GetTag ( i ) = tag then
25573: LD_VAR 0 4
25577: PPUSH
25578: CALL_OW 110
25582: PUSH
25583: LD_VAR 0 2
25587: EQUAL
25588: IFFALSE 25602
// SetTag ( i , 0 ) ;
25590: LD_VAR 0 4
25594: PPUSH
25595: LD_INT 0
25597: PPUSH
25598: CALL_OW 109
25602: GO 25570
25604: POP
25605: POP
// end ;
25606: LD_VAR 0 3
25610: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25611: LD_INT 0
25613: PPUSH
25614: PPUSH
25615: PPUSH
25616: PPUSH
25617: PPUSH
25618: PPUSH
25619: PPUSH
25620: PPUSH
// if not mc_bases then
25621: LD_EXP 95
25625: NOT
25626: IFFALSE 25630
// exit ;
25628: GO 26088
// for i = 1 to mc_bases do
25630: LD_ADDR_VAR 0 2
25634: PUSH
25635: DOUBLE
25636: LD_INT 1
25638: DEC
25639: ST_TO_ADDR
25640: LD_EXP 95
25644: PUSH
25645: FOR_TO
25646: IFFALSE 26086
// begin tmp := MC_ClassCheckReq ( i ) ;
25648: LD_ADDR_VAR 0 4
25652: PUSH
25653: LD_VAR 0 2
25657: PPUSH
25658: CALL 26093 0 1
25662: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25663: LD_ADDR_EXP 136
25667: PUSH
25668: LD_EXP 136
25672: PPUSH
25673: LD_VAR 0 2
25677: PPUSH
25678: LD_VAR 0 4
25682: PPUSH
25683: CALL_OW 1
25687: ST_TO_ADDR
// if not tmp then
25688: LD_VAR 0 4
25692: NOT
25693: IFFALSE 25697
// continue ;
25695: GO 25645
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25697: LD_ADDR_VAR 0 6
25701: PUSH
25702: LD_EXP 95
25706: PUSH
25707: LD_VAR 0 2
25711: ARRAY
25712: PPUSH
25713: LD_INT 2
25715: PUSH
25716: LD_INT 30
25718: PUSH
25719: LD_INT 4
25721: PUSH
25722: EMPTY
25723: LIST
25724: LIST
25725: PUSH
25726: LD_INT 30
25728: PUSH
25729: LD_INT 5
25731: PUSH
25732: EMPTY
25733: LIST
25734: LIST
25735: PUSH
25736: EMPTY
25737: LIST
25738: LIST
25739: LIST
25740: PPUSH
25741: CALL_OW 72
25745: PUSH
25746: LD_EXP 95
25750: PUSH
25751: LD_VAR 0 2
25755: ARRAY
25756: PPUSH
25757: LD_INT 2
25759: PUSH
25760: LD_INT 30
25762: PUSH
25763: LD_INT 0
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PUSH
25770: LD_INT 30
25772: PUSH
25773: LD_INT 1
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: PUSH
25780: EMPTY
25781: LIST
25782: LIST
25783: LIST
25784: PPUSH
25785: CALL_OW 72
25789: PUSH
25790: LD_EXP 95
25794: PUSH
25795: LD_VAR 0 2
25799: ARRAY
25800: PPUSH
25801: LD_INT 30
25803: PUSH
25804: LD_INT 3
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: PPUSH
25811: CALL_OW 72
25815: PUSH
25816: LD_EXP 95
25820: PUSH
25821: LD_VAR 0 2
25825: ARRAY
25826: PPUSH
25827: LD_INT 2
25829: PUSH
25830: LD_INT 30
25832: PUSH
25833: LD_INT 6
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 30
25842: PUSH
25843: LD_INT 7
25845: PUSH
25846: EMPTY
25847: LIST
25848: LIST
25849: PUSH
25850: LD_INT 30
25852: PUSH
25853: LD_INT 8
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: LIST
25864: LIST
25865: PPUSH
25866: CALL_OW 72
25870: PUSH
25871: EMPTY
25872: LIST
25873: LIST
25874: LIST
25875: LIST
25876: ST_TO_ADDR
// for j = 1 to 4 do
25877: LD_ADDR_VAR 0 3
25881: PUSH
25882: DOUBLE
25883: LD_INT 1
25885: DEC
25886: ST_TO_ADDR
25887: LD_INT 4
25889: PUSH
25890: FOR_TO
25891: IFFALSE 26082
// begin if not tmp [ j ] then
25893: LD_VAR 0 4
25897: PUSH
25898: LD_VAR 0 3
25902: ARRAY
25903: NOT
25904: IFFALSE 25908
// continue ;
25906: GO 25890
// for p in tmp [ j ] do
25908: LD_ADDR_VAR 0 5
25912: PUSH
25913: LD_VAR 0 4
25917: PUSH
25918: LD_VAR 0 3
25922: ARRAY
25923: PUSH
25924: FOR_IN
25925: IFFALSE 26078
// begin if not b [ j ] then
25927: LD_VAR 0 6
25931: PUSH
25932: LD_VAR 0 3
25936: ARRAY
25937: NOT
25938: IFFALSE 25942
// break ;
25940: GO 26078
// e := 0 ;
25942: LD_ADDR_VAR 0 7
25946: PUSH
25947: LD_INT 0
25949: ST_TO_ADDR
// for k in b [ j ] do
25950: LD_ADDR_VAR 0 8
25954: PUSH
25955: LD_VAR 0 6
25959: PUSH
25960: LD_VAR 0 3
25964: ARRAY
25965: PUSH
25966: FOR_IN
25967: IFFALSE 25994
// if IsNotFull ( k ) then
25969: LD_VAR 0 8
25973: PPUSH
25974: CALL 54204 0 1
25978: IFFALSE 25992
// begin e := k ;
25980: LD_ADDR_VAR 0 7
25984: PUSH
25985: LD_VAR 0 8
25989: ST_TO_ADDR
// break ;
25990: GO 25994
// end ;
25992: GO 25966
25994: POP
25995: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25996: LD_VAR 0 7
26000: PUSH
26001: LD_VAR 0 5
26005: PPUSH
26006: LD_VAR 0 7
26010: PPUSH
26011: CALL 87368 0 2
26015: NOT
26016: AND
26017: IFFALSE 26076
// begin if IsInUnit ( p ) then
26019: LD_VAR 0 5
26023: PPUSH
26024: CALL_OW 310
26028: IFFALSE 26039
// ComExitBuilding ( p ) ;
26030: LD_VAR 0 5
26034: PPUSH
26035: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26039: LD_VAR 0 5
26043: PPUSH
26044: LD_VAR 0 7
26048: PPUSH
26049: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26053: LD_VAR 0 5
26057: PPUSH
26058: LD_VAR 0 3
26062: PPUSH
26063: CALL_OW 183
// AddComExitBuilding ( p ) ;
26067: LD_VAR 0 5
26071: PPUSH
26072: CALL_OW 182
// end ; end ;
26076: GO 25924
26078: POP
26079: POP
// end ;
26080: GO 25890
26082: POP
26083: POP
// end ;
26084: GO 25645
26086: POP
26087: POP
// end ;
26088: LD_VAR 0 1
26092: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26093: LD_INT 0
26095: PPUSH
26096: PPUSH
26097: PPUSH
26098: PPUSH
26099: PPUSH
26100: PPUSH
26101: PPUSH
26102: PPUSH
26103: PPUSH
26104: PPUSH
26105: PPUSH
26106: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26107: LD_VAR 0 1
26111: NOT
26112: PUSH
26113: LD_EXP 95
26117: PUSH
26118: LD_VAR 0 1
26122: ARRAY
26123: NOT
26124: OR
26125: PUSH
26126: LD_EXP 95
26130: PUSH
26131: LD_VAR 0 1
26135: ARRAY
26136: PPUSH
26137: LD_INT 2
26139: PUSH
26140: LD_INT 30
26142: PUSH
26143: LD_INT 0
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PUSH
26150: LD_INT 30
26152: PUSH
26153: LD_INT 1
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: LIST
26164: PPUSH
26165: CALL_OW 72
26169: NOT
26170: OR
26171: IFFALSE 26175
// exit ;
26173: GO 29678
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26175: LD_ADDR_VAR 0 4
26179: PUSH
26180: LD_EXP 95
26184: PUSH
26185: LD_VAR 0 1
26189: ARRAY
26190: PPUSH
26191: LD_INT 2
26193: PUSH
26194: LD_INT 25
26196: PUSH
26197: LD_INT 1
26199: PUSH
26200: EMPTY
26201: LIST
26202: LIST
26203: PUSH
26204: LD_INT 25
26206: PUSH
26207: LD_INT 2
26209: PUSH
26210: EMPTY
26211: LIST
26212: LIST
26213: PUSH
26214: LD_INT 25
26216: PUSH
26217: LD_INT 3
26219: PUSH
26220: EMPTY
26221: LIST
26222: LIST
26223: PUSH
26224: LD_INT 25
26226: PUSH
26227: LD_INT 4
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 25
26236: PUSH
26237: LD_INT 5
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: LD_INT 25
26246: PUSH
26247: LD_INT 8
26249: PUSH
26250: EMPTY
26251: LIST
26252: LIST
26253: PUSH
26254: LD_INT 25
26256: PUSH
26257: LD_INT 9
26259: PUSH
26260: EMPTY
26261: LIST
26262: LIST
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: LIST
26268: LIST
26269: LIST
26270: LIST
26271: LIST
26272: LIST
26273: PPUSH
26274: CALL_OW 72
26278: ST_TO_ADDR
// if not tmp then
26279: LD_VAR 0 4
26283: NOT
26284: IFFALSE 26288
// exit ;
26286: GO 29678
// for i in tmp do
26288: LD_ADDR_VAR 0 3
26292: PUSH
26293: LD_VAR 0 4
26297: PUSH
26298: FOR_IN
26299: IFFALSE 26330
// if GetTag ( i ) then
26301: LD_VAR 0 3
26305: PPUSH
26306: CALL_OW 110
26310: IFFALSE 26328
// tmp := tmp diff i ;
26312: LD_ADDR_VAR 0 4
26316: PUSH
26317: LD_VAR 0 4
26321: PUSH
26322: LD_VAR 0 3
26326: DIFF
26327: ST_TO_ADDR
26328: GO 26298
26330: POP
26331: POP
// if not tmp then
26332: LD_VAR 0 4
26336: NOT
26337: IFFALSE 26341
// exit ;
26339: GO 29678
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26341: LD_ADDR_VAR 0 5
26345: PUSH
26346: LD_EXP 95
26350: PUSH
26351: LD_VAR 0 1
26355: ARRAY
26356: PPUSH
26357: LD_INT 2
26359: PUSH
26360: LD_INT 25
26362: PUSH
26363: LD_INT 1
26365: PUSH
26366: EMPTY
26367: LIST
26368: LIST
26369: PUSH
26370: LD_INT 25
26372: PUSH
26373: LD_INT 5
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: PUSH
26380: LD_INT 25
26382: PUSH
26383: LD_INT 8
26385: PUSH
26386: EMPTY
26387: LIST
26388: LIST
26389: PUSH
26390: LD_INT 25
26392: PUSH
26393: LD_INT 9
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: LIST
26404: LIST
26405: LIST
26406: PPUSH
26407: CALL_OW 72
26411: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26412: LD_ADDR_VAR 0 6
26416: PUSH
26417: LD_EXP 95
26421: PUSH
26422: LD_VAR 0 1
26426: ARRAY
26427: PPUSH
26428: LD_INT 25
26430: PUSH
26431: LD_INT 2
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: PPUSH
26438: CALL_OW 72
26442: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26443: LD_ADDR_VAR 0 7
26447: PUSH
26448: LD_EXP 95
26452: PUSH
26453: LD_VAR 0 1
26457: ARRAY
26458: PPUSH
26459: LD_INT 25
26461: PUSH
26462: LD_INT 3
26464: PUSH
26465: EMPTY
26466: LIST
26467: LIST
26468: PPUSH
26469: CALL_OW 72
26473: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26474: LD_ADDR_VAR 0 8
26478: PUSH
26479: LD_EXP 95
26483: PUSH
26484: LD_VAR 0 1
26488: ARRAY
26489: PPUSH
26490: LD_INT 25
26492: PUSH
26493: LD_INT 4
26495: PUSH
26496: EMPTY
26497: LIST
26498: LIST
26499: PUSH
26500: LD_INT 24
26502: PUSH
26503: LD_INT 251
26505: PUSH
26506: EMPTY
26507: LIST
26508: LIST
26509: PUSH
26510: EMPTY
26511: LIST
26512: LIST
26513: PPUSH
26514: CALL_OW 72
26518: ST_TO_ADDR
// if mc_is_defending [ base ] then
26519: LD_EXP 138
26523: PUSH
26524: LD_VAR 0 1
26528: ARRAY
26529: IFFALSE 26990
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26531: LD_ADDR_EXP 137
26535: PUSH
26536: LD_EXP 137
26540: PPUSH
26541: LD_VAR 0 1
26545: PPUSH
26546: LD_INT 4
26548: PPUSH
26549: CALL_OW 1
26553: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26554: LD_ADDR_VAR 0 12
26558: PUSH
26559: LD_EXP 95
26563: PUSH
26564: LD_VAR 0 1
26568: ARRAY
26569: PPUSH
26570: LD_INT 2
26572: PUSH
26573: LD_INT 30
26575: PUSH
26576: LD_INT 4
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: LD_INT 30
26585: PUSH
26586: LD_INT 5
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: LIST
26597: PPUSH
26598: CALL_OW 72
26602: ST_TO_ADDR
// if not b then
26603: LD_VAR 0 12
26607: NOT
26608: IFFALSE 26612
// exit ;
26610: GO 29678
// p := [ ] ;
26612: LD_ADDR_VAR 0 11
26616: PUSH
26617: EMPTY
26618: ST_TO_ADDR
// if sci >= 2 then
26619: LD_VAR 0 8
26623: PUSH
26624: LD_INT 2
26626: GREATEREQUAL
26627: IFFALSE 26658
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26629: LD_ADDR_VAR 0 8
26633: PUSH
26634: LD_VAR 0 8
26638: PUSH
26639: LD_INT 1
26641: ARRAY
26642: PUSH
26643: LD_VAR 0 8
26647: PUSH
26648: LD_INT 2
26650: ARRAY
26651: PUSH
26652: EMPTY
26653: LIST
26654: LIST
26655: ST_TO_ADDR
26656: GO 26719
// if sci = 1 then
26658: LD_VAR 0 8
26662: PUSH
26663: LD_INT 1
26665: EQUAL
26666: IFFALSE 26687
// sci := [ sci [ 1 ] ] else
26668: LD_ADDR_VAR 0 8
26672: PUSH
26673: LD_VAR 0 8
26677: PUSH
26678: LD_INT 1
26680: ARRAY
26681: PUSH
26682: EMPTY
26683: LIST
26684: ST_TO_ADDR
26685: GO 26719
// if sci = 0 then
26687: LD_VAR 0 8
26691: PUSH
26692: LD_INT 0
26694: EQUAL
26695: IFFALSE 26719
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26697: LD_ADDR_VAR 0 11
26701: PUSH
26702: LD_VAR 0 4
26706: PPUSH
26707: LD_INT 4
26709: PPUSH
26710: CALL 87231 0 2
26714: PUSH
26715: LD_INT 1
26717: ARRAY
26718: ST_TO_ADDR
// if eng > 4 then
26719: LD_VAR 0 6
26723: PUSH
26724: LD_INT 4
26726: GREATER
26727: IFFALSE 26773
// for i = eng downto 4 do
26729: LD_ADDR_VAR 0 3
26733: PUSH
26734: DOUBLE
26735: LD_VAR 0 6
26739: INC
26740: ST_TO_ADDR
26741: LD_INT 4
26743: PUSH
26744: FOR_DOWNTO
26745: IFFALSE 26771
// eng := eng diff eng [ i ] ;
26747: LD_ADDR_VAR 0 6
26751: PUSH
26752: LD_VAR 0 6
26756: PUSH
26757: LD_VAR 0 6
26761: PUSH
26762: LD_VAR 0 3
26766: ARRAY
26767: DIFF
26768: ST_TO_ADDR
26769: GO 26744
26771: POP
26772: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26773: LD_ADDR_VAR 0 4
26777: PUSH
26778: LD_VAR 0 4
26782: PUSH
26783: LD_VAR 0 5
26787: PUSH
26788: LD_VAR 0 6
26792: UNION
26793: PUSH
26794: LD_VAR 0 7
26798: UNION
26799: PUSH
26800: LD_VAR 0 8
26804: UNION
26805: DIFF
26806: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26807: LD_ADDR_VAR 0 13
26811: PUSH
26812: LD_EXP 95
26816: PUSH
26817: LD_VAR 0 1
26821: ARRAY
26822: PPUSH
26823: LD_INT 2
26825: PUSH
26826: LD_INT 30
26828: PUSH
26829: LD_INT 32
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 30
26838: PUSH
26839: LD_INT 31
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: LIST
26850: PPUSH
26851: CALL_OW 72
26855: PUSH
26856: LD_EXP 95
26860: PUSH
26861: LD_VAR 0 1
26865: ARRAY
26866: PPUSH
26867: LD_INT 2
26869: PUSH
26870: LD_INT 30
26872: PUSH
26873: LD_INT 4
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 30
26882: PUSH
26883: LD_INT 5
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: LIST
26894: PPUSH
26895: CALL_OW 72
26899: PUSH
26900: LD_INT 6
26902: MUL
26903: PLUS
26904: ST_TO_ADDR
// if bcount < tmp then
26905: LD_VAR 0 13
26909: PUSH
26910: LD_VAR 0 4
26914: LESS
26915: IFFALSE 26961
// for i = tmp downto bcount do
26917: LD_ADDR_VAR 0 3
26921: PUSH
26922: DOUBLE
26923: LD_VAR 0 4
26927: INC
26928: ST_TO_ADDR
26929: LD_VAR 0 13
26933: PUSH
26934: FOR_DOWNTO
26935: IFFALSE 26959
// tmp := Delete ( tmp , tmp ) ;
26937: LD_ADDR_VAR 0 4
26941: PUSH
26942: LD_VAR 0 4
26946: PPUSH
26947: LD_VAR 0 4
26951: PPUSH
26952: CALL_OW 3
26956: ST_TO_ADDR
26957: GO 26934
26959: POP
26960: POP
// result := [ tmp , 0 , 0 , p ] ;
26961: LD_ADDR_VAR 0 2
26965: PUSH
26966: LD_VAR 0 4
26970: PUSH
26971: LD_INT 0
26973: PUSH
26974: LD_INT 0
26976: PUSH
26977: LD_VAR 0 11
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: LIST
26986: LIST
26987: ST_TO_ADDR
// exit ;
26988: GO 29678
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26990: LD_EXP 95
26994: PUSH
26995: LD_VAR 0 1
26999: ARRAY
27000: PPUSH
27001: LD_INT 2
27003: PUSH
27004: LD_INT 30
27006: PUSH
27007: LD_INT 6
27009: PUSH
27010: EMPTY
27011: LIST
27012: LIST
27013: PUSH
27014: LD_INT 30
27016: PUSH
27017: LD_INT 7
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PUSH
27024: LD_INT 30
27026: PUSH
27027: LD_INT 8
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: LIST
27038: LIST
27039: PPUSH
27040: CALL_OW 72
27044: NOT
27045: PUSH
27046: LD_EXP 95
27050: PUSH
27051: LD_VAR 0 1
27055: ARRAY
27056: PPUSH
27057: LD_INT 30
27059: PUSH
27060: LD_INT 3
27062: PUSH
27063: EMPTY
27064: LIST
27065: LIST
27066: PPUSH
27067: CALL_OW 72
27071: NOT
27072: AND
27073: IFFALSE 27145
// begin if eng = tmp then
27075: LD_VAR 0 6
27079: PUSH
27080: LD_VAR 0 4
27084: EQUAL
27085: IFFALSE 27089
// exit ;
27087: GO 29678
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27089: LD_ADDR_EXP 137
27093: PUSH
27094: LD_EXP 137
27098: PPUSH
27099: LD_VAR 0 1
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: CALL_OW 1
27111: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27112: LD_ADDR_VAR 0 2
27116: PUSH
27117: LD_INT 0
27119: PUSH
27120: LD_VAR 0 4
27124: PUSH
27125: LD_VAR 0 6
27129: DIFF
27130: PUSH
27131: LD_INT 0
27133: PUSH
27134: LD_INT 0
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: LIST
27141: LIST
27142: ST_TO_ADDR
// exit ;
27143: GO 29678
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27145: LD_EXP 122
27149: PUSH
27150: LD_EXP 121
27154: PUSH
27155: LD_VAR 0 1
27159: ARRAY
27160: ARRAY
27161: PUSH
27162: LD_EXP 95
27166: PUSH
27167: LD_VAR 0 1
27171: ARRAY
27172: PPUSH
27173: LD_INT 2
27175: PUSH
27176: LD_INT 30
27178: PUSH
27179: LD_INT 6
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 30
27188: PUSH
27189: LD_INT 7
27191: PUSH
27192: EMPTY
27193: LIST
27194: LIST
27195: PUSH
27196: LD_INT 30
27198: PUSH
27199: LD_INT 8
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: LIST
27210: LIST
27211: PPUSH
27212: CALL_OW 72
27216: AND
27217: PUSH
27218: LD_EXP 95
27222: PUSH
27223: LD_VAR 0 1
27227: ARRAY
27228: PPUSH
27229: LD_INT 30
27231: PUSH
27232: LD_INT 3
27234: PUSH
27235: EMPTY
27236: LIST
27237: LIST
27238: PPUSH
27239: CALL_OW 72
27243: NOT
27244: AND
27245: IFFALSE 27459
// begin if sci >= 6 then
27247: LD_VAR 0 8
27251: PUSH
27252: LD_INT 6
27254: GREATEREQUAL
27255: IFFALSE 27259
// exit ;
27257: GO 29678
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27259: LD_ADDR_EXP 137
27263: PUSH
27264: LD_EXP 137
27268: PPUSH
27269: LD_VAR 0 1
27273: PPUSH
27274: LD_INT 2
27276: PPUSH
27277: CALL_OW 1
27281: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27282: LD_ADDR_VAR 0 9
27286: PUSH
27287: LD_VAR 0 4
27291: PUSH
27292: LD_VAR 0 8
27296: DIFF
27297: PPUSH
27298: LD_INT 4
27300: PPUSH
27301: CALL 87231 0 2
27305: ST_TO_ADDR
// p := [ ] ;
27306: LD_ADDR_VAR 0 11
27310: PUSH
27311: EMPTY
27312: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27313: LD_VAR 0 8
27317: PUSH
27318: LD_INT 6
27320: LESS
27321: PUSH
27322: LD_VAR 0 9
27326: PUSH
27327: LD_INT 6
27329: GREATER
27330: AND
27331: IFFALSE 27412
// begin for i = 1 to 6 - sci do
27333: LD_ADDR_VAR 0 3
27337: PUSH
27338: DOUBLE
27339: LD_INT 1
27341: DEC
27342: ST_TO_ADDR
27343: LD_INT 6
27345: PUSH
27346: LD_VAR 0 8
27350: MINUS
27351: PUSH
27352: FOR_TO
27353: IFFALSE 27408
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27355: LD_ADDR_VAR 0 11
27359: PUSH
27360: LD_VAR 0 11
27364: PPUSH
27365: LD_VAR 0 11
27369: PUSH
27370: LD_INT 1
27372: PLUS
27373: PPUSH
27374: LD_VAR 0 9
27378: PUSH
27379: LD_INT 1
27381: ARRAY
27382: PPUSH
27383: CALL_OW 2
27387: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27388: LD_ADDR_VAR 0 9
27392: PUSH
27393: LD_VAR 0 9
27397: PPUSH
27398: LD_INT 1
27400: PPUSH
27401: CALL_OW 3
27405: ST_TO_ADDR
// end ;
27406: GO 27352
27408: POP
27409: POP
// end else
27410: GO 27432
// if sort then
27412: LD_VAR 0 9
27416: IFFALSE 27432
// p := sort [ 1 ] ;
27418: LD_ADDR_VAR 0 11
27422: PUSH
27423: LD_VAR 0 9
27427: PUSH
27428: LD_INT 1
27430: ARRAY
27431: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27432: LD_ADDR_VAR 0 2
27436: PUSH
27437: LD_INT 0
27439: PUSH
27440: LD_INT 0
27442: PUSH
27443: LD_INT 0
27445: PUSH
27446: LD_VAR 0 11
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: LIST
27455: LIST
27456: ST_TO_ADDR
// exit ;
27457: GO 29678
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27459: LD_EXP 122
27463: PUSH
27464: LD_EXP 121
27468: PUSH
27469: LD_VAR 0 1
27473: ARRAY
27474: ARRAY
27475: PUSH
27476: LD_EXP 95
27480: PUSH
27481: LD_VAR 0 1
27485: ARRAY
27486: PPUSH
27487: LD_INT 2
27489: PUSH
27490: LD_INT 30
27492: PUSH
27493: LD_INT 6
27495: PUSH
27496: EMPTY
27497: LIST
27498: LIST
27499: PUSH
27500: LD_INT 30
27502: PUSH
27503: LD_INT 7
27505: PUSH
27506: EMPTY
27507: LIST
27508: LIST
27509: PUSH
27510: LD_INT 30
27512: PUSH
27513: LD_INT 8
27515: PUSH
27516: EMPTY
27517: LIST
27518: LIST
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: LIST
27524: LIST
27525: PPUSH
27526: CALL_OW 72
27530: AND
27531: PUSH
27532: LD_EXP 95
27536: PUSH
27537: LD_VAR 0 1
27541: ARRAY
27542: PPUSH
27543: LD_INT 30
27545: PUSH
27546: LD_INT 3
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PPUSH
27553: CALL_OW 72
27557: AND
27558: IFFALSE 28292
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27560: LD_ADDR_EXP 137
27564: PUSH
27565: LD_EXP 137
27569: PPUSH
27570: LD_VAR 0 1
27574: PPUSH
27575: LD_INT 3
27577: PPUSH
27578: CALL_OW 1
27582: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27583: LD_ADDR_VAR 0 2
27587: PUSH
27588: LD_INT 0
27590: PUSH
27591: LD_INT 0
27593: PUSH
27594: LD_INT 0
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: LIST
27604: LIST
27605: ST_TO_ADDR
// if not eng then
27606: LD_VAR 0 6
27610: NOT
27611: IFFALSE 27674
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27613: LD_ADDR_VAR 0 11
27617: PUSH
27618: LD_VAR 0 4
27622: PPUSH
27623: LD_INT 2
27625: PPUSH
27626: CALL 87231 0 2
27630: PUSH
27631: LD_INT 1
27633: ARRAY
27634: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27635: LD_ADDR_VAR 0 2
27639: PUSH
27640: LD_VAR 0 2
27644: PPUSH
27645: LD_INT 2
27647: PPUSH
27648: LD_VAR 0 11
27652: PPUSH
27653: CALL_OW 1
27657: ST_TO_ADDR
// tmp := tmp diff p ;
27658: LD_ADDR_VAR 0 4
27662: PUSH
27663: LD_VAR 0 4
27667: PUSH
27668: LD_VAR 0 11
27672: DIFF
27673: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27674: LD_VAR 0 4
27678: PUSH
27679: LD_VAR 0 8
27683: PUSH
27684: LD_INT 6
27686: LESS
27687: AND
27688: IFFALSE 27876
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27690: LD_ADDR_VAR 0 9
27694: PUSH
27695: LD_VAR 0 4
27699: PUSH
27700: LD_VAR 0 8
27704: PUSH
27705: LD_VAR 0 7
27709: UNION
27710: DIFF
27711: PPUSH
27712: LD_INT 4
27714: PPUSH
27715: CALL 87231 0 2
27719: ST_TO_ADDR
// p := [ ] ;
27720: LD_ADDR_VAR 0 11
27724: PUSH
27725: EMPTY
27726: ST_TO_ADDR
// if sort then
27727: LD_VAR 0 9
27731: IFFALSE 27847
// for i = 1 to 6 - sci do
27733: LD_ADDR_VAR 0 3
27737: PUSH
27738: DOUBLE
27739: LD_INT 1
27741: DEC
27742: ST_TO_ADDR
27743: LD_INT 6
27745: PUSH
27746: LD_VAR 0 8
27750: MINUS
27751: PUSH
27752: FOR_TO
27753: IFFALSE 27845
// begin if i = sort then
27755: LD_VAR 0 3
27759: PUSH
27760: LD_VAR 0 9
27764: EQUAL
27765: IFFALSE 27769
// break ;
27767: GO 27845
// if GetClass ( i ) = 4 then
27769: LD_VAR 0 3
27773: PPUSH
27774: CALL_OW 257
27778: PUSH
27779: LD_INT 4
27781: EQUAL
27782: IFFALSE 27786
// continue ;
27784: GO 27752
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27786: LD_ADDR_VAR 0 11
27790: PUSH
27791: LD_VAR 0 11
27795: PPUSH
27796: LD_VAR 0 11
27800: PUSH
27801: LD_INT 1
27803: PLUS
27804: PPUSH
27805: LD_VAR 0 9
27809: PUSH
27810: LD_VAR 0 3
27814: ARRAY
27815: PPUSH
27816: CALL_OW 2
27820: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27821: LD_ADDR_VAR 0 4
27825: PUSH
27826: LD_VAR 0 4
27830: PUSH
27831: LD_VAR 0 9
27835: PUSH
27836: LD_VAR 0 3
27840: ARRAY
27841: DIFF
27842: ST_TO_ADDR
// end ;
27843: GO 27752
27845: POP
27846: POP
// if p then
27847: LD_VAR 0 11
27851: IFFALSE 27876
// result := Replace ( result , 4 , p ) ;
27853: LD_ADDR_VAR 0 2
27857: PUSH
27858: LD_VAR 0 2
27862: PPUSH
27863: LD_INT 4
27865: PPUSH
27866: LD_VAR 0 11
27870: PPUSH
27871: CALL_OW 1
27875: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27876: LD_VAR 0 4
27880: PUSH
27881: LD_VAR 0 7
27885: PUSH
27886: LD_INT 6
27888: LESS
27889: AND
27890: IFFALSE 28078
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27892: LD_ADDR_VAR 0 9
27896: PUSH
27897: LD_VAR 0 4
27901: PUSH
27902: LD_VAR 0 8
27906: PUSH
27907: LD_VAR 0 7
27911: UNION
27912: DIFF
27913: PPUSH
27914: LD_INT 3
27916: PPUSH
27917: CALL 87231 0 2
27921: ST_TO_ADDR
// p := [ ] ;
27922: LD_ADDR_VAR 0 11
27926: PUSH
27927: EMPTY
27928: ST_TO_ADDR
// if sort then
27929: LD_VAR 0 9
27933: IFFALSE 28049
// for i = 1 to 6 - mech do
27935: LD_ADDR_VAR 0 3
27939: PUSH
27940: DOUBLE
27941: LD_INT 1
27943: DEC
27944: ST_TO_ADDR
27945: LD_INT 6
27947: PUSH
27948: LD_VAR 0 7
27952: MINUS
27953: PUSH
27954: FOR_TO
27955: IFFALSE 28047
// begin if i = sort then
27957: LD_VAR 0 3
27961: PUSH
27962: LD_VAR 0 9
27966: EQUAL
27967: IFFALSE 27971
// break ;
27969: GO 28047
// if GetClass ( i ) = 3 then
27971: LD_VAR 0 3
27975: PPUSH
27976: CALL_OW 257
27980: PUSH
27981: LD_INT 3
27983: EQUAL
27984: IFFALSE 27988
// continue ;
27986: GO 27954
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27988: LD_ADDR_VAR 0 11
27992: PUSH
27993: LD_VAR 0 11
27997: PPUSH
27998: LD_VAR 0 11
28002: PUSH
28003: LD_INT 1
28005: PLUS
28006: PPUSH
28007: LD_VAR 0 9
28011: PUSH
28012: LD_VAR 0 3
28016: ARRAY
28017: PPUSH
28018: CALL_OW 2
28022: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28023: LD_ADDR_VAR 0 4
28027: PUSH
28028: LD_VAR 0 4
28032: PUSH
28033: LD_VAR 0 9
28037: PUSH
28038: LD_VAR 0 3
28042: ARRAY
28043: DIFF
28044: ST_TO_ADDR
// end ;
28045: GO 27954
28047: POP
28048: POP
// if p then
28049: LD_VAR 0 11
28053: IFFALSE 28078
// result := Replace ( result , 3 , p ) ;
28055: LD_ADDR_VAR 0 2
28059: PUSH
28060: LD_VAR 0 2
28064: PPUSH
28065: LD_INT 3
28067: PPUSH
28068: LD_VAR 0 11
28072: PPUSH
28073: CALL_OW 1
28077: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28078: LD_VAR 0 4
28082: PUSH
28083: LD_INT 6
28085: GREATER
28086: PUSH
28087: LD_VAR 0 6
28091: PUSH
28092: LD_INT 6
28094: LESS
28095: AND
28096: IFFALSE 28290
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28098: LD_ADDR_VAR 0 9
28102: PUSH
28103: LD_VAR 0 4
28107: PUSH
28108: LD_VAR 0 8
28112: PUSH
28113: LD_VAR 0 7
28117: UNION
28118: PUSH
28119: LD_VAR 0 6
28123: UNION
28124: DIFF
28125: PPUSH
28126: LD_INT 2
28128: PPUSH
28129: CALL 87231 0 2
28133: ST_TO_ADDR
// p := [ ] ;
28134: LD_ADDR_VAR 0 11
28138: PUSH
28139: EMPTY
28140: ST_TO_ADDR
// if sort then
28141: LD_VAR 0 9
28145: IFFALSE 28261
// for i = 1 to 6 - eng do
28147: LD_ADDR_VAR 0 3
28151: PUSH
28152: DOUBLE
28153: LD_INT 1
28155: DEC
28156: ST_TO_ADDR
28157: LD_INT 6
28159: PUSH
28160: LD_VAR 0 6
28164: MINUS
28165: PUSH
28166: FOR_TO
28167: IFFALSE 28259
// begin if i = sort then
28169: LD_VAR 0 3
28173: PUSH
28174: LD_VAR 0 9
28178: EQUAL
28179: IFFALSE 28183
// break ;
28181: GO 28259
// if GetClass ( i ) = 2 then
28183: LD_VAR 0 3
28187: PPUSH
28188: CALL_OW 257
28192: PUSH
28193: LD_INT 2
28195: EQUAL
28196: IFFALSE 28200
// continue ;
28198: GO 28166
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28200: LD_ADDR_VAR 0 11
28204: PUSH
28205: LD_VAR 0 11
28209: PPUSH
28210: LD_VAR 0 11
28214: PUSH
28215: LD_INT 1
28217: PLUS
28218: PPUSH
28219: LD_VAR 0 9
28223: PUSH
28224: LD_VAR 0 3
28228: ARRAY
28229: PPUSH
28230: CALL_OW 2
28234: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28235: LD_ADDR_VAR 0 4
28239: PUSH
28240: LD_VAR 0 4
28244: PUSH
28245: LD_VAR 0 9
28249: PUSH
28250: LD_VAR 0 3
28254: ARRAY
28255: DIFF
28256: ST_TO_ADDR
// end ;
28257: GO 28166
28259: POP
28260: POP
// if p then
28261: LD_VAR 0 11
28265: IFFALSE 28290
// result := Replace ( result , 2 , p ) ;
28267: LD_ADDR_VAR 0 2
28271: PUSH
28272: LD_VAR 0 2
28276: PPUSH
28277: LD_INT 2
28279: PPUSH
28280: LD_VAR 0 11
28284: PPUSH
28285: CALL_OW 1
28289: ST_TO_ADDR
// end ; exit ;
28290: GO 29678
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28292: LD_EXP 122
28296: PUSH
28297: LD_EXP 121
28301: PUSH
28302: LD_VAR 0 1
28306: ARRAY
28307: ARRAY
28308: NOT
28309: PUSH
28310: LD_EXP 95
28314: PUSH
28315: LD_VAR 0 1
28319: ARRAY
28320: PPUSH
28321: LD_INT 30
28323: PUSH
28324: LD_INT 3
28326: PUSH
28327: EMPTY
28328: LIST
28329: LIST
28330: PPUSH
28331: CALL_OW 72
28335: AND
28336: PUSH
28337: LD_EXP 100
28341: PUSH
28342: LD_VAR 0 1
28346: ARRAY
28347: AND
28348: IFFALSE 28956
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28350: LD_ADDR_EXP 137
28354: PUSH
28355: LD_EXP 137
28359: PPUSH
28360: LD_VAR 0 1
28364: PPUSH
28365: LD_INT 5
28367: PPUSH
28368: CALL_OW 1
28372: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28373: LD_ADDR_VAR 0 2
28377: PUSH
28378: LD_INT 0
28380: PUSH
28381: LD_INT 0
28383: PUSH
28384: LD_INT 0
28386: PUSH
28387: LD_INT 0
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: LIST
28394: LIST
28395: ST_TO_ADDR
// if sci > 1 then
28396: LD_VAR 0 8
28400: PUSH
28401: LD_INT 1
28403: GREATER
28404: IFFALSE 28432
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28406: LD_ADDR_VAR 0 4
28410: PUSH
28411: LD_VAR 0 4
28415: PUSH
28416: LD_VAR 0 8
28420: PUSH
28421: LD_VAR 0 8
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: DIFF
28430: DIFF
28431: ST_TO_ADDR
// if tmp and not sci then
28432: LD_VAR 0 4
28436: PUSH
28437: LD_VAR 0 8
28441: NOT
28442: AND
28443: IFFALSE 28512
// begin sort := SortBySkill ( tmp , 4 ) ;
28445: LD_ADDR_VAR 0 9
28449: PUSH
28450: LD_VAR 0 4
28454: PPUSH
28455: LD_INT 4
28457: PPUSH
28458: CALL 87231 0 2
28462: ST_TO_ADDR
// if sort then
28463: LD_VAR 0 9
28467: IFFALSE 28483
// p := sort [ 1 ] ;
28469: LD_ADDR_VAR 0 11
28473: PUSH
28474: LD_VAR 0 9
28478: PUSH
28479: LD_INT 1
28481: ARRAY
28482: ST_TO_ADDR
// if p then
28483: LD_VAR 0 11
28487: IFFALSE 28512
// result := Replace ( result , 4 , p ) ;
28489: LD_ADDR_VAR 0 2
28493: PUSH
28494: LD_VAR 0 2
28498: PPUSH
28499: LD_INT 4
28501: PPUSH
28502: LD_VAR 0 11
28506: PPUSH
28507: CALL_OW 1
28511: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28512: LD_ADDR_VAR 0 4
28516: PUSH
28517: LD_VAR 0 4
28521: PUSH
28522: LD_VAR 0 7
28526: DIFF
28527: ST_TO_ADDR
// if tmp and mech < 6 then
28528: LD_VAR 0 4
28532: PUSH
28533: LD_VAR 0 7
28537: PUSH
28538: LD_INT 6
28540: LESS
28541: AND
28542: IFFALSE 28730
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28544: LD_ADDR_VAR 0 9
28548: PUSH
28549: LD_VAR 0 4
28553: PUSH
28554: LD_VAR 0 8
28558: PUSH
28559: LD_VAR 0 7
28563: UNION
28564: DIFF
28565: PPUSH
28566: LD_INT 3
28568: PPUSH
28569: CALL 87231 0 2
28573: ST_TO_ADDR
// p := [ ] ;
28574: LD_ADDR_VAR 0 11
28578: PUSH
28579: EMPTY
28580: ST_TO_ADDR
// if sort then
28581: LD_VAR 0 9
28585: IFFALSE 28701
// for i = 1 to 6 - mech do
28587: LD_ADDR_VAR 0 3
28591: PUSH
28592: DOUBLE
28593: LD_INT 1
28595: DEC
28596: ST_TO_ADDR
28597: LD_INT 6
28599: PUSH
28600: LD_VAR 0 7
28604: MINUS
28605: PUSH
28606: FOR_TO
28607: IFFALSE 28699
// begin if i = sort then
28609: LD_VAR 0 3
28613: PUSH
28614: LD_VAR 0 9
28618: EQUAL
28619: IFFALSE 28623
// break ;
28621: GO 28699
// if GetClass ( i ) = 3 then
28623: LD_VAR 0 3
28627: PPUSH
28628: CALL_OW 257
28632: PUSH
28633: LD_INT 3
28635: EQUAL
28636: IFFALSE 28640
// continue ;
28638: GO 28606
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28640: LD_ADDR_VAR 0 11
28644: PUSH
28645: LD_VAR 0 11
28649: PPUSH
28650: LD_VAR 0 11
28654: PUSH
28655: LD_INT 1
28657: PLUS
28658: PPUSH
28659: LD_VAR 0 9
28663: PUSH
28664: LD_VAR 0 3
28668: ARRAY
28669: PPUSH
28670: CALL_OW 2
28674: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28675: LD_ADDR_VAR 0 4
28679: PUSH
28680: LD_VAR 0 4
28684: PUSH
28685: LD_VAR 0 9
28689: PUSH
28690: LD_VAR 0 3
28694: ARRAY
28695: DIFF
28696: ST_TO_ADDR
// end ;
28697: GO 28606
28699: POP
28700: POP
// if p then
28701: LD_VAR 0 11
28705: IFFALSE 28730
// result := Replace ( result , 3 , p ) ;
28707: LD_ADDR_VAR 0 2
28711: PUSH
28712: LD_VAR 0 2
28716: PPUSH
28717: LD_INT 3
28719: PPUSH
28720: LD_VAR 0 11
28724: PPUSH
28725: CALL_OW 1
28729: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28730: LD_ADDR_VAR 0 4
28734: PUSH
28735: LD_VAR 0 4
28739: PUSH
28740: LD_VAR 0 6
28744: DIFF
28745: ST_TO_ADDR
// if tmp and eng < 6 then
28746: LD_VAR 0 4
28750: PUSH
28751: LD_VAR 0 6
28755: PUSH
28756: LD_INT 6
28758: LESS
28759: AND
28760: IFFALSE 28954
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28762: LD_ADDR_VAR 0 9
28766: PUSH
28767: LD_VAR 0 4
28771: PUSH
28772: LD_VAR 0 8
28776: PUSH
28777: LD_VAR 0 7
28781: UNION
28782: PUSH
28783: LD_VAR 0 6
28787: UNION
28788: DIFF
28789: PPUSH
28790: LD_INT 2
28792: PPUSH
28793: CALL 87231 0 2
28797: ST_TO_ADDR
// p := [ ] ;
28798: LD_ADDR_VAR 0 11
28802: PUSH
28803: EMPTY
28804: ST_TO_ADDR
// if sort then
28805: LD_VAR 0 9
28809: IFFALSE 28925
// for i = 1 to 6 - eng do
28811: LD_ADDR_VAR 0 3
28815: PUSH
28816: DOUBLE
28817: LD_INT 1
28819: DEC
28820: ST_TO_ADDR
28821: LD_INT 6
28823: PUSH
28824: LD_VAR 0 6
28828: MINUS
28829: PUSH
28830: FOR_TO
28831: IFFALSE 28923
// begin if i = sort then
28833: LD_VAR 0 3
28837: PUSH
28838: LD_VAR 0 9
28842: EQUAL
28843: IFFALSE 28847
// break ;
28845: GO 28923
// if GetClass ( i ) = 2 then
28847: LD_VAR 0 3
28851: PPUSH
28852: CALL_OW 257
28856: PUSH
28857: LD_INT 2
28859: EQUAL
28860: IFFALSE 28864
// continue ;
28862: GO 28830
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28864: LD_ADDR_VAR 0 11
28868: PUSH
28869: LD_VAR 0 11
28873: PPUSH
28874: LD_VAR 0 11
28878: PUSH
28879: LD_INT 1
28881: PLUS
28882: PPUSH
28883: LD_VAR 0 9
28887: PUSH
28888: LD_VAR 0 3
28892: ARRAY
28893: PPUSH
28894: CALL_OW 2
28898: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28899: LD_ADDR_VAR 0 4
28903: PUSH
28904: LD_VAR 0 4
28908: PUSH
28909: LD_VAR 0 9
28913: PUSH
28914: LD_VAR 0 3
28918: ARRAY
28919: DIFF
28920: ST_TO_ADDR
// end ;
28921: GO 28830
28923: POP
28924: POP
// if p then
28925: LD_VAR 0 11
28929: IFFALSE 28954
// result := Replace ( result , 2 , p ) ;
28931: LD_ADDR_VAR 0 2
28935: PUSH
28936: LD_VAR 0 2
28940: PPUSH
28941: LD_INT 2
28943: PPUSH
28944: LD_VAR 0 11
28948: PPUSH
28949: CALL_OW 1
28953: ST_TO_ADDR
// end ; exit ;
28954: GO 29678
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28956: LD_EXP 122
28960: PUSH
28961: LD_EXP 121
28965: PUSH
28966: LD_VAR 0 1
28970: ARRAY
28971: ARRAY
28972: NOT
28973: PUSH
28974: LD_EXP 95
28978: PUSH
28979: LD_VAR 0 1
28983: ARRAY
28984: PPUSH
28985: LD_INT 30
28987: PUSH
28988: LD_INT 3
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: PPUSH
28995: CALL_OW 72
28999: AND
29000: PUSH
29001: LD_EXP 100
29005: PUSH
29006: LD_VAR 0 1
29010: ARRAY
29011: NOT
29012: AND
29013: IFFALSE 29678
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29015: LD_ADDR_EXP 137
29019: PUSH
29020: LD_EXP 137
29024: PPUSH
29025: LD_VAR 0 1
29029: PPUSH
29030: LD_INT 6
29032: PPUSH
29033: CALL_OW 1
29037: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29038: LD_ADDR_VAR 0 2
29042: PUSH
29043: LD_INT 0
29045: PUSH
29046: LD_INT 0
29048: PUSH
29049: LD_INT 0
29051: PUSH
29052: LD_INT 0
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: LIST
29059: LIST
29060: ST_TO_ADDR
// if sci >= 1 then
29061: LD_VAR 0 8
29065: PUSH
29066: LD_INT 1
29068: GREATEREQUAL
29069: IFFALSE 29091
// tmp := tmp diff sci [ 1 ] ;
29071: LD_ADDR_VAR 0 4
29075: PUSH
29076: LD_VAR 0 4
29080: PUSH
29081: LD_VAR 0 8
29085: PUSH
29086: LD_INT 1
29088: ARRAY
29089: DIFF
29090: ST_TO_ADDR
// if tmp and not sci then
29091: LD_VAR 0 4
29095: PUSH
29096: LD_VAR 0 8
29100: NOT
29101: AND
29102: IFFALSE 29171
// begin sort := SortBySkill ( tmp , 4 ) ;
29104: LD_ADDR_VAR 0 9
29108: PUSH
29109: LD_VAR 0 4
29113: PPUSH
29114: LD_INT 4
29116: PPUSH
29117: CALL 87231 0 2
29121: ST_TO_ADDR
// if sort then
29122: LD_VAR 0 9
29126: IFFALSE 29142
// p := sort [ 1 ] ;
29128: LD_ADDR_VAR 0 11
29132: PUSH
29133: LD_VAR 0 9
29137: PUSH
29138: LD_INT 1
29140: ARRAY
29141: ST_TO_ADDR
// if p then
29142: LD_VAR 0 11
29146: IFFALSE 29171
// result := Replace ( result , 4 , p ) ;
29148: LD_ADDR_VAR 0 2
29152: PUSH
29153: LD_VAR 0 2
29157: PPUSH
29158: LD_INT 4
29160: PPUSH
29161: LD_VAR 0 11
29165: PPUSH
29166: CALL_OW 1
29170: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29171: LD_ADDR_VAR 0 4
29175: PUSH
29176: LD_VAR 0 4
29180: PUSH
29181: LD_VAR 0 7
29185: DIFF
29186: ST_TO_ADDR
// if tmp and mech < 6 then
29187: LD_VAR 0 4
29191: PUSH
29192: LD_VAR 0 7
29196: PUSH
29197: LD_INT 6
29199: LESS
29200: AND
29201: IFFALSE 29383
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29203: LD_ADDR_VAR 0 9
29207: PUSH
29208: LD_VAR 0 4
29212: PUSH
29213: LD_VAR 0 7
29217: DIFF
29218: PPUSH
29219: LD_INT 3
29221: PPUSH
29222: CALL 87231 0 2
29226: ST_TO_ADDR
// p := [ ] ;
29227: LD_ADDR_VAR 0 11
29231: PUSH
29232: EMPTY
29233: ST_TO_ADDR
// if sort then
29234: LD_VAR 0 9
29238: IFFALSE 29354
// for i = 1 to 6 - mech do
29240: LD_ADDR_VAR 0 3
29244: PUSH
29245: DOUBLE
29246: LD_INT 1
29248: DEC
29249: ST_TO_ADDR
29250: LD_INT 6
29252: PUSH
29253: LD_VAR 0 7
29257: MINUS
29258: PUSH
29259: FOR_TO
29260: IFFALSE 29352
// begin if i = sort then
29262: LD_VAR 0 3
29266: PUSH
29267: LD_VAR 0 9
29271: EQUAL
29272: IFFALSE 29276
// break ;
29274: GO 29352
// if GetClass ( i ) = 3 then
29276: LD_VAR 0 3
29280: PPUSH
29281: CALL_OW 257
29285: PUSH
29286: LD_INT 3
29288: EQUAL
29289: IFFALSE 29293
// continue ;
29291: GO 29259
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29293: LD_ADDR_VAR 0 11
29297: PUSH
29298: LD_VAR 0 11
29302: PPUSH
29303: LD_VAR 0 11
29307: PUSH
29308: LD_INT 1
29310: PLUS
29311: PPUSH
29312: LD_VAR 0 9
29316: PUSH
29317: LD_VAR 0 3
29321: ARRAY
29322: PPUSH
29323: CALL_OW 2
29327: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29328: LD_ADDR_VAR 0 4
29332: PUSH
29333: LD_VAR 0 4
29337: PUSH
29338: LD_VAR 0 9
29342: PUSH
29343: LD_VAR 0 3
29347: ARRAY
29348: DIFF
29349: ST_TO_ADDR
// end ;
29350: GO 29259
29352: POP
29353: POP
// if p then
29354: LD_VAR 0 11
29358: IFFALSE 29383
// result := Replace ( result , 3 , p ) ;
29360: LD_ADDR_VAR 0 2
29364: PUSH
29365: LD_VAR 0 2
29369: PPUSH
29370: LD_INT 3
29372: PPUSH
29373: LD_VAR 0 11
29377: PPUSH
29378: CALL_OW 1
29382: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29383: LD_ADDR_VAR 0 4
29387: PUSH
29388: LD_VAR 0 4
29392: PUSH
29393: LD_VAR 0 6
29397: DIFF
29398: ST_TO_ADDR
// if tmp and eng < 4 then
29399: LD_VAR 0 4
29403: PUSH
29404: LD_VAR 0 6
29408: PUSH
29409: LD_INT 4
29411: LESS
29412: AND
29413: IFFALSE 29603
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29415: LD_ADDR_VAR 0 9
29419: PUSH
29420: LD_VAR 0 4
29424: PUSH
29425: LD_VAR 0 7
29429: PUSH
29430: LD_VAR 0 6
29434: UNION
29435: DIFF
29436: PPUSH
29437: LD_INT 2
29439: PPUSH
29440: CALL 87231 0 2
29444: ST_TO_ADDR
// p := [ ] ;
29445: LD_ADDR_VAR 0 11
29449: PUSH
29450: EMPTY
29451: ST_TO_ADDR
// if sort then
29452: LD_VAR 0 9
29456: IFFALSE 29572
// for i = 1 to 4 - eng do
29458: LD_ADDR_VAR 0 3
29462: PUSH
29463: DOUBLE
29464: LD_INT 1
29466: DEC
29467: ST_TO_ADDR
29468: LD_INT 4
29470: PUSH
29471: LD_VAR 0 6
29475: MINUS
29476: PUSH
29477: FOR_TO
29478: IFFALSE 29570
// begin if i = sort then
29480: LD_VAR 0 3
29484: PUSH
29485: LD_VAR 0 9
29489: EQUAL
29490: IFFALSE 29494
// break ;
29492: GO 29570
// if GetClass ( i ) = 2 then
29494: LD_VAR 0 3
29498: PPUSH
29499: CALL_OW 257
29503: PUSH
29504: LD_INT 2
29506: EQUAL
29507: IFFALSE 29511
// continue ;
29509: GO 29477
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29511: LD_ADDR_VAR 0 11
29515: PUSH
29516: LD_VAR 0 11
29520: PPUSH
29521: LD_VAR 0 11
29525: PUSH
29526: LD_INT 1
29528: PLUS
29529: PPUSH
29530: LD_VAR 0 9
29534: PUSH
29535: LD_VAR 0 3
29539: ARRAY
29540: PPUSH
29541: CALL_OW 2
29545: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29546: LD_ADDR_VAR 0 4
29550: PUSH
29551: LD_VAR 0 4
29555: PUSH
29556: LD_VAR 0 9
29560: PUSH
29561: LD_VAR 0 3
29565: ARRAY
29566: DIFF
29567: ST_TO_ADDR
// end ;
29568: GO 29477
29570: POP
29571: POP
// if p then
29572: LD_VAR 0 11
29576: IFFALSE 29601
// result := Replace ( result , 2 , p ) ;
29578: LD_ADDR_VAR 0 2
29582: PUSH
29583: LD_VAR 0 2
29587: PPUSH
29588: LD_INT 2
29590: PPUSH
29591: LD_VAR 0 11
29595: PPUSH
29596: CALL_OW 1
29600: ST_TO_ADDR
// end else
29601: GO 29647
// for i = eng downto 5 do
29603: LD_ADDR_VAR 0 3
29607: PUSH
29608: DOUBLE
29609: LD_VAR 0 6
29613: INC
29614: ST_TO_ADDR
29615: LD_INT 5
29617: PUSH
29618: FOR_DOWNTO
29619: IFFALSE 29645
// tmp := tmp union eng [ i ] ;
29621: LD_ADDR_VAR 0 4
29625: PUSH
29626: LD_VAR 0 4
29630: PUSH
29631: LD_VAR 0 6
29635: PUSH
29636: LD_VAR 0 3
29640: ARRAY
29641: UNION
29642: ST_TO_ADDR
29643: GO 29618
29645: POP
29646: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29647: LD_ADDR_VAR 0 2
29651: PUSH
29652: LD_VAR 0 2
29656: PPUSH
29657: LD_INT 1
29659: PPUSH
29660: LD_VAR 0 4
29664: PUSH
29665: LD_VAR 0 5
29669: DIFF
29670: PPUSH
29671: CALL_OW 1
29675: ST_TO_ADDR
// exit ;
29676: GO 29678
// end ; end ;
29678: LD_VAR 0 2
29682: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29683: LD_INT 0
29685: PPUSH
29686: PPUSH
29687: PPUSH
// if not mc_bases then
29688: LD_EXP 95
29692: NOT
29693: IFFALSE 29697
// exit ;
29695: GO 29839
// for i = 1 to mc_bases do
29697: LD_ADDR_VAR 0 2
29701: PUSH
29702: DOUBLE
29703: LD_INT 1
29705: DEC
29706: ST_TO_ADDR
29707: LD_EXP 95
29711: PUSH
29712: FOR_TO
29713: IFFALSE 29830
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29715: LD_ADDR_VAR 0 3
29719: PUSH
29720: LD_EXP 95
29724: PUSH
29725: LD_VAR 0 2
29729: ARRAY
29730: PPUSH
29731: LD_INT 21
29733: PUSH
29734: LD_INT 3
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 3
29743: PUSH
29744: LD_INT 2
29746: PUSH
29747: LD_INT 30
29749: PUSH
29750: LD_INT 29
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: PUSH
29757: LD_INT 30
29759: PUSH
29760: LD_INT 30
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: EMPTY
29768: LIST
29769: LIST
29770: LIST
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 3
29778: PUSH
29779: LD_INT 24
29781: PUSH
29782: LD_INT 1000
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: LIST
29797: PPUSH
29798: CALL_OW 72
29802: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29803: LD_ADDR_EXP 96
29807: PUSH
29808: LD_EXP 96
29812: PPUSH
29813: LD_VAR 0 2
29817: PPUSH
29818: LD_VAR 0 3
29822: PPUSH
29823: CALL_OW 1
29827: ST_TO_ADDR
// end ;
29828: GO 29712
29830: POP
29831: POP
// RaiseSailEvent ( 101 ) ;
29832: LD_INT 101
29834: PPUSH
29835: CALL_OW 427
// end ;
29839: LD_VAR 0 1
29843: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29844: LD_INT 0
29846: PPUSH
29847: PPUSH
29848: PPUSH
29849: PPUSH
29850: PPUSH
29851: PPUSH
29852: PPUSH
// if not mc_bases then
29853: LD_EXP 95
29857: NOT
29858: IFFALSE 29862
// exit ;
29860: GO 30424
// for i = 1 to mc_bases do
29862: LD_ADDR_VAR 0 2
29866: PUSH
29867: DOUBLE
29868: LD_INT 1
29870: DEC
29871: ST_TO_ADDR
29872: LD_EXP 95
29876: PUSH
29877: FOR_TO
29878: IFFALSE 30415
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29880: LD_ADDR_VAR 0 5
29884: PUSH
29885: LD_EXP 95
29889: PUSH
29890: LD_VAR 0 2
29894: ARRAY
29895: PUSH
29896: LD_EXP 124
29900: PUSH
29901: LD_VAR 0 2
29905: ARRAY
29906: UNION
29907: PPUSH
29908: LD_INT 21
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 1
29920: PUSH
29921: LD_INT 3
29923: PUSH
29924: LD_INT 54
29926: PUSH
29927: EMPTY
29928: LIST
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 3
29936: PUSH
29937: LD_INT 24
29939: PUSH
29940: LD_INT 1000
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: LIST
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PPUSH
29960: CALL_OW 72
29964: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29965: LD_ADDR_VAR 0 6
29969: PUSH
29970: LD_EXP 95
29974: PUSH
29975: LD_VAR 0 2
29979: ARRAY
29980: PPUSH
29981: LD_INT 21
29983: PUSH
29984: LD_INT 1
29986: PUSH
29987: EMPTY
29988: LIST
29989: LIST
29990: PUSH
29991: LD_INT 1
29993: PUSH
29994: LD_INT 3
29996: PUSH
29997: LD_INT 54
29999: PUSH
30000: EMPTY
30001: LIST
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 3
30009: PUSH
30010: LD_INT 24
30012: PUSH
30013: LD_INT 250
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: LIST
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PPUSH
30033: CALL_OW 72
30037: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30038: LD_ADDR_VAR 0 7
30042: PUSH
30043: LD_VAR 0 5
30047: PUSH
30048: LD_VAR 0 6
30052: DIFF
30053: ST_TO_ADDR
// if not need_heal_1 then
30054: LD_VAR 0 6
30058: NOT
30059: IFFALSE 30092
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30061: LD_ADDR_EXP 98
30065: PUSH
30066: LD_EXP 98
30070: PPUSH
30071: LD_VAR 0 2
30075: PUSH
30076: LD_INT 1
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PPUSH
30083: EMPTY
30084: PPUSH
30085: CALL 56974 0 3
30089: ST_TO_ADDR
30090: GO 30162
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30092: LD_ADDR_EXP 98
30096: PUSH
30097: LD_EXP 98
30101: PPUSH
30102: LD_VAR 0 2
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PPUSH
30114: LD_EXP 98
30118: PUSH
30119: LD_VAR 0 2
30123: ARRAY
30124: PUSH
30125: LD_INT 1
30127: ARRAY
30128: PPUSH
30129: LD_INT 3
30131: PUSH
30132: LD_INT 24
30134: PUSH
30135: LD_INT 1000
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: PPUSH
30146: CALL_OW 72
30150: PUSH
30151: LD_VAR 0 6
30155: UNION
30156: PPUSH
30157: CALL 56974 0 3
30161: ST_TO_ADDR
// if not need_heal_2 then
30162: LD_VAR 0 7
30166: NOT
30167: IFFALSE 30200
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30169: LD_ADDR_EXP 98
30173: PUSH
30174: LD_EXP 98
30178: PPUSH
30179: LD_VAR 0 2
30183: PUSH
30184: LD_INT 2
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PPUSH
30191: EMPTY
30192: PPUSH
30193: CALL 56974 0 3
30197: ST_TO_ADDR
30198: GO 30232
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30200: LD_ADDR_EXP 98
30204: PUSH
30205: LD_EXP 98
30209: PPUSH
30210: LD_VAR 0 2
30214: PUSH
30215: LD_INT 2
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PPUSH
30222: LD_VAR 0 7
30226: PPUSH
30227: CALL 56974 0 3
30231: ST_TO_ADDR
// if need_heal_2 then
30232: LD_VAR 0 7
30236: IFFALSE 30397
// for j in need_heal_2 do
30238: LD_ADDR_VAR 0 3
30242: PUSH
30243: LD_VAR 0 7
30247: PUSH
30248: FOR_IN
30249: IFFALSE 30395
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30251: LD_ADDR_VAR 0 5
30255: PUSH
30256: LD_EXP 95
30260: PUSH
30261: LD_VAR 0 2
30265: ARRAY
30266: PPUSH
30267: LD_INT 2
30269: PUSH
30270: LD_INT 30
30272: PUSH
30273: LD_INT 6
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 30
30282: PUSH
30283: LD_INT 7
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 30
30292: PUSH
30293: LD_INT 8
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 30
30302: PUSH
30303: LD_INT 0
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 30
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: EMPTY
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: PPUSH
30328: CALL_OW 72
30332: ST_TO_ADDR
// if tmp then
30333: LD_VAR 0 5
30337: IFFALSE 30393
// begin k := NearestUnitToUnit ( tmp , j ) ;
30339: LD_ADDR_VAR 0 4
30343: PUSH
30344: LD_VAR 0 5
30348: PPUSH
30349: LD_VAR 0 3
30353: PPUSH
30354: CALL_OW 74
30358: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30359: LD_VAR 0 3
30363: PPUSH
30364: LD_VAR 0 4
30368: PPUSH
30369: CALL_OW 296
30373: PUSH
30374: LD_INT 5
30376: GREATER
30377: IFFALSE 30393
// ComMoveToNearbyEntrance ( j , k ) ;
30379: LD_VAR 0 3
30383: PPUSH
30384: LD_VAR 0 4
30388: PPUSH
30389: CALL 89592 0 2
// end ; end ;
30393: GO 30248
30395: POP
30396: POP
// if not need_heal_1 and not need_heal_2 then
30397: LD_VAR 0 6
30401: NOT
30402: PUSH
30403: LD_VAR 0 7
30407: NOT
30408: AND
30409: IFFALSE 30413
// continue ;
30411: GO 29877
// end ;
30413: GO 29877
30415: POP
30416: POP
// RaiseSailEvent ( 102 ) ;
30417: LD_INT 102
30419: PPUSH
30420: CALL_OW 427
// end ;
30424: LD_VAR 0 1
30428: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30429: LD_INT 0
30431: PPUSH
30432: PPUSH
30433: PPUSH
30434: PPUSH
30435: PPUSH
30436: PPUSH
30437: PPUSH
30438: PPUSH
// if not mc_bases then
30439: LD_EXP 95
30443: NOT
30444: IFFALSE 30448
// exit ;
30446: GO 31331
// for i = 1 to mc_bases do
30448: LD_ADDR_VAR 0 2
30452: PUSH
30453: DOUBLE
30454: LD_INT 1
30456: DEC
30457: ST_TO_ADDR
30458: LD_EXP 95
30462: PUSH
30463: FOR_TO
30464: IFFALSE 31329
// begin if not mc_building_need_repair [ i ] then
30466: LD_EXP 96
30470: PUSH
30471: LD_VAR 0 2
30475: ARRAY
30476: NOT
30477: IFFALSE 30664
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30479: LD_ADDR_VAR 0 6
30483: PUSH
30484: LD_EXP 114
30488: PUSH
30489: LD_VAR 0 2
30493: ARRAY
30494: PPUSH
30495: LD_INT 3
30497: PUSH
30498: LD_INT 24
30500: PUSH
30501: LD_INT 1000
30503: PUSH
30504: EMPTY
30505: LIST
30506: LIST
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 2
30514: PUSH
30515: LD_INT 34
30517: PUSH
30518: LD_INT 13
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_INT 34
30527: PUSH
30528: LD_INT 52
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 34
30537: PUSH
30538: LD_EXP 80
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PPUSH
30557: CALL_OW 72
30561: ST_TO_ADDR
// if cranes then
30562: LD_VAR 0 6
30566: IFFALSE 30628
// for j in cranes do
30568: LD_ADDR_VAR 0 3
30572: PUSH
30573: LD_VAR 0 6
30577: PUSH
30578: FOR_IN
30579: IFFALSE 30626
// if not IsInArea ( j , mc_parking [ i ] ) then
30581: LD_VAR 0 3
30585: PPUSH
30586: LD_EXP 119
30590: PUSH
30591: LD_VAR 0 2
30595: ARRAY
30596: PPUSH
30597: CALL_OW 308
30601: NOT
30602: IFFALSE 30624
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30604: LD_VAR 0 3
30608: PPUSH
30609: LD_EXP 119
30613: PUSH
30614: LD_VAR 0 2
30618: ARRAY
30619: PPUSH
30620: CALL_OW 113
30624: GO 30578
30626: POP
30627: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30628: LD_ADDR_EXP 97
30632: PUSH
30633: LD_EXP 97
30637: PPUSH
30638: LD_VAR 0 2
30642: PPUSH
30643: EMPTY
30644: PPUSH
30645: CALL_OW 1
30649: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30650: LD_VAR 0 2
30654: PPUSH
30655: LD_INT 101
30657: PPUSH
30658: CALL 25516 0 2
// continue ;
30662: GO 30463
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30664: LD_ADDR_EXP 101
30668: PUSH
30669: LD_EXP 101
30673: PPUSH
30674: LD_VAR 0 2
30678: PPUSH
30679: EMPTY
30680: PPUSH
30681: CALL_OW 1
30685: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30686: LD_VAR 0 2
30690: PPUSH
30691: LD_INT 103
30693: PPUSH
30694: CALL 25516 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30698: LD_ADDR_VAR 0 5
30702: PUSH
30703: LD_EXP 95
30707: PUSH
30708: LD_VAR 0 2
30712: ARRAY
30713: PUSH
30714: LD_EXP 124
30718: PUSH
30719: LD_VAR 0 2
30723: ARRAY
30724: UNION
30725: PPUSH
30726: LD_INT 2
30728: PUSH
30729: LD_INT 25
30731: PUSH
30732: LD_INT 2
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 25
30741: PUSH
30742: LD_INT 16
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: LIST
30753: PUSH
30754: EMPTY
30755: LIST
30756: PPUSH
30757: CALL_OW 72
30761: ST_TO_ADDR
// if mc_need_heal [ i ] then
30762: LD_EXP 98
30766: PUSH
30767: LD_VAR 0 2
30771: ARRAY
30772: IFFALSE 30816
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30774: LD_ADDR_VAR 0 5
30778: PUSH
30779: LD_VAR 0 5
30783: PUSH
30784: LD_EXP 98
30788: PUSH
30789: LD_VAR 0 2
30793: ARRAY
30794: PUSH
30795: LD_INT 1
30797: ARRAY
30798: PUSH
30799: LD_EXP 98
30803: PUSH
30804: LD_VAR 0 2
30808: ARRAY
30809: PUSH
30810: LD_INT 2
30812: ARRAY
30813: UNION
30814: DIFF
30815: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30816: LD_ADDR_VAR 0 6
30820: PUSH
30821: LD_EXP 114
30825: PUSH
30826: LD_VAR 0 2
30830: ARRAY
30831: PPUSH
30832: LD_INT 2
30834: PUSH
30835: LD_INT 34
30837: PUSH
30838: LD_INT 13
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 34
30847: PUSH
30848: LD_INT 52
30850: PUSH
30851: EMPTY
30852: LIST
30853: LIST
30854: PUSH
30855: LD_INT 34
30857: PUSH
30858: LD_EXP 80
30862: PUSH
30863: EMPTY
30864: LIST
30865: LIST
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: PPUSH
30873: CALL_OW 72
30877: ST_TO_ADDR
// if cranes then
30878: LD_VAR 0 6
30882: IFFALSE 31018
// begin for j in cranes do
30884: LD_ADDR_VAR 0 3
30888: PUSH
30889: LD_VAR 0 6
30893: PUSH
30894: FOR_IN
30895: IFFALSE 31016
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30897: LD_VAR 0 3
30901: PPUSH
30902: CALL_OW 256
30906: PUSH
30907: LD_INT 1000
30909: EQUAL
30910: PUSH
30911: LD_VAR 0 3
30915: PPUSH
30916: CALL_OW 314
30920: NOT
30921: AND
30922: IFFALSE 30956
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30924: LD_VAR 0 3
30928: PPUSH
30929: LD_EXP 96
30933: PUSH
30934: LD_VAR 0 2
30938: ARRAY
30939: PPUSH
30940: LD_VAR 0 3
30944: PPUSH
30945: CALL_OW 74
30949: PPUSH
30950: CALL_OW 130
30954: GO 31014
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30956: LD_VAR 0 3
30960: PPUSH
30961: CALL_OW 256
30965: PUSH
30966: LD_INT 500
30968: LESS
30969: PUSH
30970: LD_VAR 0 3
30974: PPUSH
30975: LD_EXP 119
30979: PUSH
30980: LD_VAR 0 2
30984: ARRAY
30985: PPUSH
30986: CALL_OW 308
30990: NOT
30991: AND
30992: IFFALSE 31014
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30994: LD_VAR 0 3
30998: PPUSH
30999: LD_EXP 119
31003: PUSH
31004: LD_VAR 0 2
31008: ARRAY
31009: PPUSH
31010: CALL_OW 113
// end ;
31014: GO 30894
31016: POP
31017: POP
// end ; if tmp > 3 then
31018: LD_VAR 0 5
31022: PUSH
31023: LD_INT 3
31025: GREATER
31026: IFFALSE 31046
// tmp := ShrinkArray ( tmp , 4 ) ;
31028: LD_ADDR_VAR 0 5
31032: PUSH
31033: LD_VAR 0 5
31037: PPUSH
31038: LD_INT 4
31040: PPUSH
31041: CALL 89040 0 2
31045: ST_TO_ADDR
// if not tmp then
31046: LD_VAR 0 5
31050: NOT
31051: IFFALSE 31055
// continue ;
31053: GO 30463
// for j in tmp do
31055: LD_ADDR_VAR 0 3
31059: PUSH
31060: LD_VAR 0 5
31064: PUSH
31065: FOR_IN
31066: IFFALSE 31325
// begin if IsInUnit ( j ) then
31068: LD_VAR 0 3
31072: PPUSH
31073: CALL_OW 310
31077: IFFALSE 31088
// ComExitBuilding ( j ) ;
31079: LD_VAR 0 3
31083: PPUSH
31084: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31088: LD_VAR 0 3
31092: PUSH
31093: LD_EXP 97
31097: PUSH
31098: LD_VAR 0 2
31102: ARRAY
31103: IN
31104: NOT
31105: IFFALSE 31163
// begin SetTag ( j , 101 ) ;
31107: LD_VAR 0 3
31111: PPUSH
31112: LD_INT 101
31114: PPUSH
31115: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31119: LD_ADDR_EXP 97
31123: PUSH
31124: LD_EXP 97
31128: PPUSH
31129: LD_VAR 0 2
31133: PUSH
31134: LD_EXP 97
31138: PUSH
31139: LD_VAR 0 2
31143: ARRAY
31144: PUSH
31145: LD_INT 1
31147: PLUS
31148: PUSH
31149: EMPTY
31150: LIST
31151: LIST
31152: PPUSH
31153: LD_VAR 0 3
31157: PPUSH
31158: CALL 56974 0 3
31162: ST_TO_ADDR
// end ; wait ( 1 ) ;
31163: LD_INT 1
31165: PPUSH
31166: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31170: LD_ADDR_VAR 0 7
31174: PUSH
31175: LD_EXP 96
31179: PUSH
31180: LD_VAR 0 2
31184: ARRAY
31185: ST_TO_ADDR
// if mc_scan [ i ] then
31186: LD_EXP 118
31190: PUSH
31191: LD_VAR 0 2
31195: ARRAY
31196: IFFALSE 31258
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31198: LD_ADDR_VAR 0 7
31202: PUSH
31203: LD_EXP 96
31207: PUSH
31208: LD_VAR 0 2
31212: ARRAY
31213: PPUSH
31214: LD_INT 3
31216: PUSH
31217: LD_INT 30
31219: PUSH
31220: LD_INT 32
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PUSH
31227: LD_INT 30
31229: PUSH
31230: LD_INT 33
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: LD_INT 30
31239: PUSH
31240: LD_INT 31
31242: PUSH
31243: EMPTY
31244: LIST
31245: LIST
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: PPUSH
31253: CALL_OW 72
31257: ST_TO_ADDR
// if not to_repair_tmp then
31258: LD_VAR 0 7
31262: NOT
31263: IFFALSE 31267
// continue ;
31265: GO 31065
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31267: LD_ADDR_VAR 0 8
31271: PUSH
31272: LD_VAR 0 7
31276: PPUSH
31277: LD_VAR 0 3
31281: PPUSH
31282: CALL_OW 74
31286: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31287: LD_VAR 0 8
31291: PPUSH
31292: LD_INT 16
31294: PPUSH
31295: CALL 59573 0 2
31299: PUSH
31300: LD_INT 4
31302: ARRAY
31303: PUSH
31304: LD_INT 10
31306: LESS
31307: IFFALSE 31323
// ComRepairBuilding ( j , to_repair ) ;
31309: LD_VAR 0 3
31313: PPUSH
31314: LD_VAR 0 8
31318: PPUSH
31319: CALL_OW 130
// end ;
31323: GO 31065
31325: POP
31326: POP
// end ;
31327: GO 30463
31329: POP
31330: POP
// end ;
31331: LD_VAR 0 1
31335: RET
// export function MC_Heal ; var i , j , tmp ; begin
31336: LD_INT 0
31338: PPUSH
31339: PPUSH
31340: PPUSH
31341: PPUSH
// if not mc_bases then
31342: LD_EXP 95
31346: NOT
31347: IFFALSE 31351
// exit ;
31349: GO 31753
// for i = 1 to mc_bases do
31351: LD_ADDR_VAR 0 2
31355: PUSH
31356: DOUBLE
31357: LD_INT 1
31359: DEC
31360: ST_TO_ADDR
31361: LD_EXP 95
31365: PUSH
31366: FOR_TO
31367: IFFALSE 31751
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31369: LD_EXP 98
31373: PUSH
31374: LD_VAR 0 2
31378: ARRAY
31379: PUSH
31380: LD_INT 1
31382: ARRAY
31383: NOT
31384: PUSH
31385: LD_EXP 98
31389: PUSH
31390: LD_VAR 0 2
31394: ARRAY
31395: PUSH
31396: LD_INT 2
31398: ARRAY
31399: NOT
31400: AND
31401: IFFALSE 31439
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31403: LD_ADDR_EXP 99
31407: PUSH
31408: LD_EXP 99
31412: PPUSH
31413: LD_VAR 0 2
31417: PPUSH
31418: EMPTY
31419: PPUSH
31420: CALL_OW 1
31424: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31425: LD_VAR 0 2
31429: PPUSH
31430: LD_INT 102
31432: PPUSH
31433: CALL 25516 0 2
// continue ;
31437: GO 31366
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31439: LD_ADDR_VAR 0 4
31443: PUSH
31444: LD_EXP 95
31448: PUSH
31449: LD_VAR 0 2
31453: ARRAY
31454: PPUSH
31455: LD_INT 25
31457: PUSH
31458: LD_INT 4
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PPUSH
31465: CALL_OW 72
31469: ST_TO_ADDR
// if not tmp then
31470: LD_VAR 0 4
31474: NOT
31475: IFFALSE 31479
// continue ;
31477: GO 31366
// if mc_taming [ i ] then
31479: LD_EXP 126
31483: PUSH
31484: LD_VAR 0 2
31488: ARRAY
31489: IFFALSE 31513
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31491: LD_ADDR_EXP 126
31495: PUSH
31496: LD_EXP 126
31500: PPUSH
31501: LD_VAR 0 2
31505: PPUSH
31506: EMPTY
31507: PPUSH
31508: CALL_OW 1
31512: ST_TO_ADDR
// for j in tmp do
31513: LD_ADDR_VAR 0 3
31517: PUSH
31518: LD_VAR 0 4
31522: PUSH
31523: FOR_IN
31524: IFFALSE 31747
// begin if IsInUnit ( j ) then
31526: LD_VAR 0 3
31530: PPUSH
31531: CALL_OW 310
31535: IFFALSE 31546
// ComExitBuilding ( j ) ;
31537: LD_VAR 0 3
31541: PPUSH
31542: CALL_OW 122
// if not j in mc_healers [ i ] then
31546: LD_VAR 0 3
31550: PUSH
31551: LD_EXP 99
31555: PUSH
31556: LD_VAR 0 2
31560: ARRAY
31561: IN
31562: NOT
31563: IFFALSE 31609
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31565: LD_ADDR_EXP 99
31569: PUSH
31570: LD_EXP 99
31574: PPUSH
31575: LD_VAR 0 2
31579: PUSH
31580: LD_EXP 99
31584: PUSH
31585: LD_VAR 0 2
31589: ARRAY
31590: PUSH
31591: LD_INT 1
31593: PLUS
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PPUSH
31599: LD_VAR 0 3
31603: PPUSH
31604: CALL 56974 0 3
31608: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31609: LD_VAR 0 3
31613: PPUSH
31614: CALL_OW 110
31618: PUSH
31619: LD_INT 102
31621: NONEQUAL
31622: IFFALSE 31636
// SetTag ( j , 102 ) ;
31624: LD_VAR 0 3
31628: PPUSH
31629: LD_INT 102
31631: PPUSH
31632: CALL_OW 109
// Wait ( 3 ) ;
31636: LD_INT 3
31638: PPUSH
31639: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31643: LD_EXP 98
31647: PUSH
31648: LD_VAR 0 2
31652: ARRAY
31653: PUSH
31654: LD_INT 1
31656: ARRAY
31657: IFFALSE 31689
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31659: LD_VAR 0 3
31663: PPUSH
31664: LD_EXP 98
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: PUSH
31675: LD_INT 1
31677: ARRAY
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: PPUSH
31683: CALL_OW 128
31687: GO 31745
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31689: LD_VAR 0 3
31693: PPUSH
31694: CALL_OW 314
31698: NOT
31699: PUSH
31700: LD_EXP 98
31704: PUSH
31705: LD_VAR 0 2
31709: ARRAY
31710: PUSH
31711: LD_INT 2
31713: ARRAY
31714: AND
31715: IFFALSE 31745
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31717: LD_VAR 0 3
31721: PPUSH
31722: LD_EXP 98
31726: PUSH
31727: LD_VAR 0 2
31731: ARRAY
31732: PUSH
31733: LD_INT 2
31735: ARRAY
31736: PUSH
31737: LD_INT 1
31739: ARRAY
31740: PPUSH
31741: CALL_OW 128
// end ;
31745: GO 31523
31747: POP
31748: POP
// end ;
31749: GO 31366
31751: POP
31752: POP
// end ;
31753: LD_VAR 0 1
31757: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31758: LD_INT 0
31760: PPUSH
31761: PPUSH
31762: PPUSH
31763: PPUSH
31764: PPUSH
// if not mc_bases then
31765: LD_EXP 95
31769: NOT
31770: IFFALSE 31774
// exit ;
31772: GO 32945
// for i = 1 to mc_bases do
31774: LD_ADDR_VAR 0 2
31778: PUSH
31779: DOUBLE
31780: LD_INT 1
31782: DEC
31783: ST_TO_ADDR
31784: LD_EXP 95
31788: PUSH
31789: FOR_TO
31790: IFFALSE 32943
// begin if mc_scan [ i ] then
31792: LD_EXP 118
31796: PUSH
31797: LD_VAR 0 2
31801: ARRAY
31802: IFFALSE 31806
// continue ;
31804: GO 31789
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31806: LD_EXP 100
31810: PUSH
31811: LD_VAR 0 2
31815: ARRAY
31816: NOT
31817: PUSH
31818: LD_EXP 102
31822: PUSH
31823: LD_VAR 0 2
31827: ARRAY
31828: NOT
31829: AND
31830: PUSH
31831: LD_EXP 101
31835: PUSH
31836: LD_VAR 0 2
31840: ARRAY
31841: AND
31842: IFFALSE 31880
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31844: LD_ADDR_EXP 101
31848: PUSH
31849: LD_EXP 101
31853: PPUSH
31854: LD_VAR 0 2
31858: PPUSH
31859: EMPTY
31860: PPUSH
31861: CALL_OW 1
31865: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31866: LD_VAR 0 2
31870: PPUSH
31871: LD_INT 103
31873: PPUSH
31874: CALL 25516 0 2
// continue ;
31878: GO 31789
// end ; if mc_construct_list [ i ] then
31880: LD_EXP 102
31884: PUSH
31885: LD_VAR 0 2
31889: ARRAY
31890: IFFALSE 32110
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31892: LD_ADDR_VAR 0 4
31896: PUSH
31897: LD_EXP 95
31901: PUSH
31902: LD_VAR 0 2
31906: ARRAY
31907: PPUSH
31908: LD_INT 25
31910: PUSH
31911: LD_INT 2
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: PPUSH
31918: CALL_OW 72
31922: PUSH
31923: LD_EXP 97
31927: PUSH
31928: LD_VAR 0 2
31932: ARRAY
31933: DIFF
31934: ST_TO_ADDR
// if not tmp then
31935: LD_VAR 0 4
31939: NOT
31940: IFFALSE 31944
// continue ;
31942: GO 31789
// for j in tmp do
31944: LD_ADDR_VAR 0 3
31948: PUSH
31949: LD_VAR 0 4
31953: PUSH
31954: FOR_IN
31955: IFFALSE 32106
// begin if not mc_builders [ i ] then
31957: LD_EXP 101
31961: PUSH
31962: LD_VAR 0 2
31966: ARRAY
31967: NOT
31968: IFFALSE 32026
// begin SetTag ( j , 103 ) ;
31970: LD_VAR 0 3
31974: PPUSH
31975: LD_INT 103
31977: PPUSH
31978: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31982: LD_ADDR_EXP 101
31986: PUSH
31987: LD_EXP 101
31991: PPUSH
31992: LD_VAR 0 2
31996: PUSH
31997: LD_EXP 101
32001: PUSH
32002: LD_VAR 0 2
32006: ARRAY
32007: PUSH
32008: LD_INT 1
32010: PLUS
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PPUSH
32016: LD_VAR 0 3
32020: PPUSH
32021: CALL 56974 0 3
32025: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32026: LD_VAR 0 3
32030: PPUSH
32031: CALL_OW 310
32035: IFFALSE 32046
// ComExitBuilding ( j ) ;
32037: LD_VAR 0 3
32041: PPUSH
32042: CALL_OW 122
// wait ( 3 ) ;
32046: LD_INT 3
32048: PPUSH
32049: CALL_OW 67
// if not mc_construct_list [ i ] then
32053: LD_EXP 102
32057: PUSH
32058: LD_VAR 0 2
32062: ARRAY
32063: NOT
32064: IFFALSE 32068
// break ;
32066: GO 32106
// if not HasTask ( j ) then
32068: LD_VAR 0 3
32072: PPUSH
32073: CALL_OW 314
32077: NOT
32078: IFFALSE 32104
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32080: LD_VAR 0 3
32084: PPUSH
32085: LD_EXP 102
32089: PUSH
32090: LD_VAR 0 2
32094: ARRAY
32095: PUSH
32096: LD_INT 1
32098: ARRAY
32099: PPUSH
32100: CALL 59837 0 2
// end ;
32104: GO 31954
32106: POP
32107: POP
// end else
32108: GO 32941
// if mc_build_list [ i ] then
32110: LD_EXP 100
32114: PUSH
32115: LD_VAR 0 2
32119: ARRAY
32120: IFFALSE 32941
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32122: LD_ADDR_VAR 0 5
32126: PUSH
32127: LD_EXP 95
32131: PUSH
32132: LD_VAR 0 2
32136: ARRAY
32137: PPUSH
32138: LD_INT 2
32140: PUSH
32141: LD_INT 30
32143: PUSH
32144: LD_INT 0
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 30
32153: PUSH
32154: LD_INT 1
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: LIST
32165: PPUSH
32166: CALL_OW 72
32170: ST_TO_ADDR
// if depot then
32171: LD_VAR 0 5
32175: IFFALSE 32193
// depot := depot [ 1 ] else
32177: LD_ADDR_VAR 0 5
32181: PUSH
32182: LD_VAR 0 5
32186: PUSH
32187: LD_INT 1
32189: ARRAY
32190: ST_TO_ADDR
32191: GO 32201
// depot := 0 ;
32193: LD_ADDR_VAR 0 5
32197: PUSH
32198: LD_INT 0
32200: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32201: LD_EXP 100
32205: PUSH
32206: LD_VAR 0 2
32210: ARRAY
32211: PUSH
32212: LD_INT 1
32214: ARRAY
32215: PUSH
32216: LD_INT 1
32218: ARRAY
32219: PPUSH
32220: CALL 59661 0 1
32224: PUSH
32225: LD_EXP 95
32229: PUSH
32230: LD_VAR 0 2
32234: ARRAY
32235: PPUSH
32236: LD_INT 2
32238: PUSH
32239: LD_INT 30
32241: PUSH
32242: LD_INT 2
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 30
32251: PUSH
32252: LD_INT 3
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: LIST
32263: PPUSH
32264: CALL_OW 72
32268: NOT
32269: AND
32270: IFFALSE 32375
// begin for j = 1 to mc_build_list [ i ] do
32272: LD_ADDR_VAR 0 3
32276: PUSH
32277: DOUBLE
32278: LD_INT 1
32280: DEC
32281: ST_TO_ADDR
32282: LD_EXP 100
32286: PUSH
32287: LD_VAR 0 2
32291: ARRAY
32292: PUSH
32293: FOR_TO
32294: IFFALSE 32373
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32296: LD_EXP 100
32300: PUSH
32301: LD_VAR 0 2
32305: ARRAY
32306: PUSH
32307: LD_VAR 0 3
32311: ARRAY
32312: PUSH
32313: LD_INT 1
32315: ARRAY
32316: PUSH
32317: LD_INT 2
32319: EQUAL
32320: IFFALSE 32371
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32322: LD_ADDR_EXP 100
32326: PUSH
32327: LD_EXP 100
32331: PPUSH
32332: LD_VAR 0 2
32336: PPUSH
32337: LD_EXP 100
32341: PUSH
32342: LD_VAR 0 2
32346: ARRAY
32347: PPUSH
32348: LD_VAR 0 3
32352: PPUSH
32353: LD_INT 1
32355: PPUSH
32356: LD_INT 0
32358: PPUSH
32359: CALL 56392 0 4
32363: PPUSH
32364: CALL_OW 1
32368: ST_TO_ADDR
// break ;
32369: GO 32373
// end ;
32371: GO 32293
32373: POP
32374: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
32375: LD_EXP 100
32379: PUSH
32380: LD_VAR 0 2
32384: ARRAY
32385: PUSH
32386: LD_INT 1
32388: ARRAY
32389: PUSH
32390: LD_INT 1
32392: ARRAY
32393: PUSH
32394: LD_INT 0
32396: EQUAL
32397: PUSH
32398: LD_VAR 0 5
32402: PUSH
32403: LD_VAR 0 5
32407: PPUSH
32408: LD_EXP 100
32412: PUSH
32413: LD_VAR 0 2
32417: ARRAY
32418: PUSH
32419: LD_INT 1
32421: ARRAY
32422: PUSH
32423: LD_INT 1
32425: ARRAY
32426: PPUSH
32427: LD_EXP 100
32431: PUSH
32432: LD_VAR 0 2
32436: ARRAY
32437: PUSH
32438: LD_INT 1
32440: ARRAY
32441: PUSH
32442: LD_INT 2
32444: ARRAY
32445: PPUSH
32446: LD_EXP 100
32450: PUSH
32451: LD_VAR 0 2
32455: ARRAY
32456: PUSH
32457: LD_INT 1
32459: ARRAY
32460: PUSH
32461: LD_INT 3
32463: ARRAY
32464: PPUSH
32465: LD_EXP 100
32469: PUSH
32470: LD_VAR 0 2
32474: ARRAY
32475: PUSH
32476: LD_INT 1
32478: ARRAY
32479: PUSH
32480: LD_INT 4
32482: ARRAY
32483: PPUSH
32484: CALL 65077 0 5
32488: AND
32489: OR
32490: IFFALSE 32771
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32492: LD_ADDR_VAR 0 4
32496: PUSH
32497: LD_EXP 95
32501: PUSH
32502: LD_VAR 0 2
32506: ARRAY
32507: PPUSH
32508: LD_INT 25
32510: PUSH
32511: LD_INT 2
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: PPUSH
32518: CALL_OW 72
32522: PUSH
32523: LD_EXP 97
32527: PUSH
32528: LD_VAR 0 2
32532: ARRAY
32533: DIFF
32534: ST_TO_ADDR
// if not tmp then
32535: LD_VAR 0 4
32539: NOT
32540: IFFALSE 32544
// continue ;
32542: GO 31789
// for j in tmp do
32544: LD_ADDR_VAR 0 3
32548: PUSH
32549: LD_VAR 0 4
32553: PUSH
32554: FOR_IN
32555: IFFALSE 32767
// begin if not mc_builders [ i ] then
32557: LD_EXP 101
32561: PUSH
32562: LD_VAR 0 2
32566: ARRAY
32567: NOT
32568: IFFALSE 32626
// begin SetTag ( j , 103 ) ;
32570: LD_VAR 0 3
32574: PPUSH
32575: LD_INT 103
32577: PPUSH
32578: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32582: LD_ADDR_EXP 101
32586: PUSH
32587: LD_EXP 101
32591: PPUSH
32592: LD_VAR 0 2
32596: PUSH
32597: LD_EXP 101
32601: PUSH
32602: LD_VAR 0 2
32606: ARRAY
32607: PUSH
32608: LD_INT 1
32610: PLUS
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PPUSH
32616: LD_VAR 0 3
32620: PPUSH
32621: CALL 56974 0 3
32625: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32626: LD_VAR 0 3
32630: PPUSH
32631: CALL_OW 310
32635: IFFALSE 32646
// ComExitBuilding ( j ) ;
32637: LD_VAR 0 3
32641: PPUSH
32642: CALL_OW 122
// wait ( 3 ) ;
32646: LD_INT 3
32648: PPUSH
32649: CALL_OW 67
// if not mc_build_list [ i ] then
32653: LD_EXP 100
32657: PUSH
32658: LD_VAR 0 2
32662: ARRAY
32663: NOT
32664: IFFALSE 32668
// break ;
32666: GO 32767
// if not HasTask ( j ) then
32668: LD_VAR 0 3
32672: PPUSH
32673: CALL_OW 314
32677: NOT
32678: IFFALSE 32765
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32680: LD_VAR 0 3
32684: PPUSH
32685: LD_EXP 100
32689: PUSH
32690: LD_VAR 0 2
32694: ARRAY
32695: PUSH
32696: LD_INT 1
32698: ARRAY
32699: PUSH
32700: LD_INT 1
32702: ARRAY
32703: PPUSH
32704: LD_EXP 100
32708: PUSH
32709: LD_VAR 0 2
32713: ARRAY
32714: PUSH
32715: LD_INT 1
32717: ARRAY
32718: PUSH
32719: LD_INT 2
32721: ARRAY
32722: PPUSH
32723: LD_EXP 100
32727: PUSH
32728: LD_VAR 0 2
32732: ARRAY
32733: PUSH
32734: LD_INT 1
32736: ARRAY
32737: PUSH
32738: LD_INT 3
32740: ARRAY
32741: PPUSH
32742: LD_EXP 100
32746: PUSH
32747: LD_VAR 0 2
32751: ARRAY
32752: PUSH
32753: LD_INT 1
32755: ARRAY
32756: PUSH
32757: LD_INT 4
32759: ARRAY
32760: PPUSH
32761: CALL_OW 145
// end ;
32765: GO 32554
32767: POP
32768: POP
// end else
32769: GO 32941
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32771: LD_EXP 95
32775: PUSH
32776: LD_VAR 0 2
32780: ARRAY
32781: PPUSH
32782: LD_EXP 100
32786: PUSH
32787: LD_VAR 0 2
32791: ARRAY
32792: PUSH
32793: LD_INT 1
32795: ARRAY
32796: PUSH
32797: LD_INT 1
32799: ARRAY
32800: PPUSH
32801: LD_EXP 100
32805: PUSH
32806: LD_VAR 0 2
32810: ARRAY
32811: PUSH
32812: LD_INT 1
32814: ARRAY
32815: PUSH
32816: LD_INT 2
32818: ARRAY
32819: PPUSH
32820: LD_EXP 100
32824: PUSH
32825: LD_VAR 0 2
32829: ARRAY
32830: PUSH
32831: LD_INT 1
32833: ARRAY
32834: PUSH
32835: LD_INT 3
32837: ARRAY
32838: PPUSH
32839: LD_EXP 100
32843: PUSH
32844: LD_VAR 0 2
32848: ARRAY
32849: PUSH
32850: LD_INT 1
32852: ARRAY
32853: PUSH
32854: LD_INT 4
32856: ARRAY
32857: PPUSH
32858: LD_EXP 95
32862: PUSH
32863: LD_VAR 0 2
32867: ARRAY
32868: PPUSH
32869: LD_INT 21
32871: PUSH
32872: LD_INT 3
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PPUSH
32879: CALL_OW 72
32883: PPUSH
32884: EMPTY
32885: PPUSH
32886: CALL 63827 0 7
32890: NOT
32891: IFFALSE 32941
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32893: LD_ADDR_EXP 100
32897: PUSH
32898: LD_EXP 100
32902: PPUSH
32903: LD_VAR 0 2
32907: PPUSH
32908: LD_EXP 100
32912: PUSH
32913: LD_VAR 0 2
32917: ARRAY
32918: PPUSH
32919: LD_INT 1
32921: PPUSH
32922: LD_INT 1
32924: NEG
32925: PPUSH
32926: LD_INT 0
32928: PPUSH
32929: CALL 56392 0 4
32933: PPUSH
32934: CALL_OW 1
32938: ST_TO_ADDR
// continue ;
32939: GO 31789
// end ; end ; end ;
32941: GO 31789
32943: POP
32944: POP
// end ;
32945: LD_VAR 0 1
32949: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32950: LD_INT 0
32952: PPUSH
32953: PPUSH
32954: PPUSH
32955: PPUSH
32956: PPUSH
32957: PPUSH
// if not mc_bases then
32958: LD_EXP 95
32962: NOT
32963: IFFALSE 32967
// exit ;
32965: GO 33394
// for i = 1 to mc_bases do
32967: LD_ADDR_VAR 0 2
32971: PUSH
32972: DOUBLE
32973: LD_INT 1
32975: DEC
32976: ST_TO_ADDR
32977: LD_EXP 95
32981: PUSH
32982: FOR_TO
32983: IFFALSE 33392
// begin tmp := mc_build_upgrade [ i ] ;
32985: LD_ADDR_VAR 0 4
32989: PUSH
32990: LD_EXP 127
32994: PUSH
32995: LD_VAR 0 2
32999: ARRAY
33000: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33001: LD_ADDR_VAR 0 6
33005: PUSH
33006: LD_EXP 128
33010: PUSH
33011: LD_VAR 0 2
33015: ARRAY
33016: PPUSH
33017: LD_INT 2
33019: PUSH
33020: LD_INT 30
33022: PUSH
33023: LD_INT 6
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 30
33032: PUSH
33033: LD_INT 7
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: LIST
33044: PPUSH
33045: CALL_OW 72
33049: ST_TO_ADDR
// if not tmp and not lab then
33050: LD_VAR 0 4
33054: NOT
33055: PUSH
33056: LD_VAR 0 6
33060: NOT
33061: AND
33062: IFFALSE 33066
// continue ;
33064: GO 32982
// if tmp then
33066: LD_VAR 0 4
33070: IFFALSE 33190
// for j in tmp do
33072: LD_ADDR_VAR 0 3
33076: PUSH
33077: LD_VAR 0 4
33081: PUSH
33082: FOR_IN
33083: IFFALSE 33188
// begin if UpgradeCost ( j ) then
33085: LD_VAR 0 3
33089: PPUSH
33090: CALL 63487 0 1
33094: IFFALSE 33186
// begin ComUpgrade ( j ) ;
33096: LD_VAR 0 3
33100: PPUSH
33101: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33105: LD_ADDR_EXP 127
33109: PUSH
33110: LD_EXP 127
33114: PPUSH
33115: LD_VAR 0 2
33119: PPUSH
33120: LD_EXP 127
33124: PUSH
33125: LD_VAR 0 2
33129: ARRAY
33130: PUSH
33131: LD_VAR 0 3
33135: DIFF
33136: PPUSH
33137: CALL_OW 1
33141: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33142: LD_ADDR_EXP 102
33146: PUSH
33147: LD_EXP 102
33151: PPUSH
33152: LD_VAR 0 2
33156: PUSH
33157: LD_EXP 102
33161: PUSH
33162: LD_VAR 0 2
33166: ARRAY
33167: PUSH
33168: LD_INT 1
33170: PLUS
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PPUSH
33176: LD_VAR 0 3
33180: PPUSH
33181: CALL 56974 0 3
33185: ST_TO_ADDR
// end ; end ;
33186: GO 33082
33188: POP
33189: POP
// if not lab or not mc_lab_upgrade [ i ] then
33190: LD_VAR 0 6
33194: NOT
33195: PUSH
33196: LD_EXP 129
33200: PUSH
33201: LD_VAR 0 2
33205: ARRAY
33206: NOT
33207: OR
33208: IFFALSE 33212
// continue ;
33210: GO 32982
// for j in lab do
33212: LD_ADDR_VAR 0 3
33216: PUSH
33217: LD_VAR 0 6
33221: PUSH
33222: FOR_IN
33223: IFFALSE 33388
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33225: LD_VAR 0 3
33229: PPUSH
33230: CALL_OW 266
33234: PUSH
33235: LD_INT 6
33237: PUSH
33238: LD_INT 7
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: IN
33245: PUSH
33246: LD_VAR 0 3
33250: PPUSH
33251: CALL_OW 461
33255: PUSH
33256: LD_INT 1
33258: NONEQUAL
33259: AND
33260: IFFALSE 33386
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33262: LD_VAR 0 3
33266: PPUSH
33267: LD_EXP 129
33271: PUSH
33272: LD_VAR 0 2
33276: ARRAY
33277: PUSH
33278: LD_INT 1
33280: ARRAY
33281: PPUSH
33282: CALL 63692 0 2
33286: IFFALSE 33386
// begin ComCancel ( j ) ;
33288: LD_VAR 0 3
33292: PPUSH
33293: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33297: LD_VAR 0 3
33301: PPUSH
33302: LD_EXP 129
33306: PUSH
33307: LD_VAR 0 2
33311: ARRAY
33312: PUSH
33313: LD_INT 1
33315: ARRAY
33316: PPUSH
33317: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33321: LD_VAR 0 3
33325: PUSH
33326: LD_EXP 102
33330: PUSH
33331: LD_VAR 0 2
33335: ARRAY
33336: IN
33337: NOT
33338: IFFALSE 33384
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33340: LD_ADDR_EXP 102
33344: PUSH
33345: LD_EXP 102
33349: PPUSH
33350: LD_VAR 0 2
33354: PUSH
33355: LD_EXP 102
33359: PUSH
33360: LD_VAR 0 2
33364: ARRAY
33365: PUSH
33366: LD_INT 1
33368: PLUS
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PPUSH
33374: LD_VAR 0 3
33378: PPUSH
33379: CALL 56974 0 3
33383: ST_TO_ADDR
// break ;
33384: GO 33388
// end ; end ; end ;
33386: GO 33222
33388: POP
33389: POP
// end ;
33390: GO 32982
33392: POP
33393: POP
// end ;
33394: LD_VAR 0 1
33398: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33399: LD_INT 0
33401: PPUSH
33402: PPUSH
33403: PPUSH
33404: PPUSH
33405: PPUSH
33406: PPUSH
33407: PPUSH
33408: PPUSH
33409: PPUSH
// if not mc_bases then
33410: LD_EXP 95
33414: NOT
33415: IFFALSE 33419
// exit ;
33417: GO 33824
// for i = 1 to mc_bases do
33419: LD_ADDR_VAR 0 2
33423: PUSH
33424: DOUBLE
33425: LD_INT 1
33427: DEC
33428: ST_TO_ADDR
33429: LD_EXP 95
33433: PUSH
33434: FOR_TO
33435: IFFALSE 33822
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33437: LD_EXP 103
33441: PUSH
33442: LD_VAR 0 2
33446: ARRAY
33447: NOT
33448: PUSH
33449: LD_EXP 95
33453: PUSH
33454: LD_VAR 0 2
33458: ARRAY
33459: PPUSH
33460: LD_INT 30
33462: PUSH
33463: LD_INT 3
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PPUSH
33470: CALL_OW 72
33474: NOT
33475: OR
33476: IFFALSE 33480
// continue ;
33478: GO 33434
// busy := false ;
33480: LD_ADDR_VAR 0 8
33484: PUSH
33485: LD_INT 0
33487: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33488: LD_ADDR_VAR 0 4
33492: PUSH
33493: LD_EXP 95
33497: PUSH
33498: LD_VAR 0 2
33502: ARRAY
33503: PPUSH
33504: LD_INT 30
33506: PUSH
33507: LD_INT 3
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PPUSH
33514: CALL_OW 72
33518: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33519: LD_ADDR_VAR 0 6
33523: PUSH
33524: LD_EXP 103
33528: PUSH
33529: LD_VAR 0 2
33533: ARRAY
33534: PPUSH
33535: LD_INT 2
33537: PUSH
33538: LD_INT 30
33540: PUSH
33541: LD_INT 32
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 30
33550: PUSH
33551: LD_INT 33
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: LIST
33562: PPUSH
33563: CALL_OW 72
33567: ST_TO_ADDR
// if not t then
33568: LD_VAR 0 6
33572: NOT
33573: IFFALSE 33577
// continue ;
33575: GO 33434
// for j in tmp do
33577: LD_ADDR_VAR 0 3
33581: PUSH
33582: LD_VAR 0 4
33586: PUSH
33587: FOR_IN
33588: IFFALSE 33618
// if not BuildingStatus ( j ) = bs_idle then
33590: LD_VAR 0 3
33594: PPUSH
33595: CALL_OW 461
33599: PUSH
33600: LD_INT 2
33602: EQUAL
33603: NOT
33604: IFFALSE 33616
// begin busy := true ;
33606: LD_ADDR_VAR 0 8
33610: PUSH
33611: LD_INT 1
33613: ST_TO_ADDR
// break ;
33614: GO 33618
// end ;
33616: GO 33587
33618: POP
33619: POP
// if busy then
33620: LD_VAR 0 8
33624: IFFALSE 33628
// continue ;
33626: GO 33434
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33628: LD_ADDR_VAR 0 7
33632: PUSH
33633: LD_VAR 0 6
33637: PPUSH
33638: LD_INT 35
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PPUSH
33648: CALL_OW 72
33652: ST_TO_ADDR
// if tw then
33653: LD_VAR 0 7
33657: IFFALSE 33734
// begin tw := tw [ 1 ] ;
33659: LD_ADDR_VAR 0 7
33663: PUSH
33664: LD_VAR 0 7
33668: PUSH
33669: LD_INT 1
33671: ARRAY
33672: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33673: LD_ADDR_VAR 0 9
33677: PUSH
33678: LD_VAR 0 7
33682: PPUSH
33683: LD_EXP 120
33687: PUSH
33688: LD_VAR 0 2
33692: ARRAY
33693: PPUSH
33694: CALL 61984 0 2
33698: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33699: LD_EXP 134
33703: PUSH
33704: LD_VAR 0 2
33708: ARRAY
33709: IFFALSE 33732
// if not weapon in mc_allowed_tower_weapons [ i ] then
33711: LD_VAR 0 9
33715: PUSH
33716: LD_EXP 134
33720: PUSH
33721: LD_VAR 0 2
33725: ARRAY
33726: IN
33727: NOT
33728: IFFALSE 33732
// continue ;
33730: GO 33434
// end else
33732: GO 33797
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33734: LD_ADDR_VAR 0 5
33738: PUSH
33739: LD_EXP 103
33743: PUSH
33744: LD_VAR 0 2
33748: ARRAY
33749: PPUSH
33750: LD_VAR 0 4
33754: PPUSH
33755: CALL 88273 0 2
33759: ST_TO_ADDR
// if not tmp2 then
33760: LD_VAR 0 5
33764: NOT
33765: IFFALSE 33769
// continue ;
33767: GO 33434
// tw := tmp2 [ 1 ] ;
33769: LD_ADDR_VAR 0 7
33773: PUSH
33774: LD_VAR 0 5
33778: PUSH
33779: LD_INT 1
33781: ARRAY
33782: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33783: LD_ADDR_VAR 0 9
33787: PUSH
33788: LD_VAR 0 5
33792: PUSH
33793: LD_INT 2
33795: ARRAY
33796: ST_TO_ADDR
// end ; if not weapon then
33797: LD_VAR 0 9
33801: NOT
33802: IFFALSE 33806
// continue ;
33804: GO 33434
// ComPlaceWeapon ( tw , weapon ) ;
33806: LD_VAR 0 7
33810: PPUSH
33811: LD_VAR 0 9
33815: PPUSH
33816: CALL_OW 148
// end ;
33820: GO 33434
33822: POP
33823: POP
// end ;
33824: LD_VAR 0 1
33828: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33829: LD_INT 0
33831: PPUSH
33832: PPUSH
33833: PPUSH
33834: PPUSH
33835: PPUSH
33836: PPUSH
33837: PPUSH
// if not mc_bases then
33838: LD_EXP 95
33842: NOT
33843: IFFALSE 33847
// exit ;
33845: GO 34615
// for i = 1 to mc_bases do
33847: LD_ADDR_VAR 0 2
33851: PUSH
33852: DOUBLE
33853: LD_INT 1
33855: DEC
33856: ST_TO_ADDR
33857: LD_EXP 95
33861: PUSH
33862: FOR_TO
33863: IFFALSE 34613
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33865: LD_EXP 108
33869: PUSH
33870: LD_VAR 0 2
33874: ARRAY
33875: NOT
33876: PUSH
33877: LD_EXP 108
33881: PUSH
33882: LD_VAR 0 2
33886: ARRAY
33887: PUSH
33888: LD_EXP 109
33892: PUSH
33893: LD_VAR 0 2
33897: ARRAY
33898: EQUAL
33899: OR
33900: PUSH
33901: LD_EXP 118
33905: PUSH
33906: LD_VAR 0 2
33910: ARRAY
33911: OR
33912: IFFALSE 33916
// continue ;
33914: GO 33862
// if mc_miners [ i ] then
33916: LD_EXP 109
33920: PUSH
33921: LD_VAR 0 2
33925: ARRAY
33926: IFFALSE 34300
// begin for j = mc_miners [ i ] downto 1 do
33928: LD_ADDR_VAR 0 3
33932: PUSH
33933: DOUBLE
33934: LD_EXP 109
33938: PUSH
33939: LD_VAR 0 2
33943: ARRAY
33944: INC
33945: ST_TO_ADDR
33946: LD_INT 1
33948: PUSH
33949: FOR_DOWNTO
33950: IFFALSE 34298
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33952: LD_EXP 109
33956: PUSH
33957: LD_VAR 0 2
33961: ARRAY
33962: PUSH
33963: LD_VAR 0 3
33967: ARRAY
33968: PPUSH
33969: CALL_OW 301
33973: PUSH
33974: LD_EXP 109
33978: PUSH
33979: LD_VAR 0 2
33983: ARRAY
33984: PUSH
33985: LD_VAR 0 3
33989: ARRAY
33990: PPUSH
33991: CALL_OW 257
33995: PUSH
33996: LD_INT 1
33998: NONEQUAL
33999: OR
34000: IFFALSE 34063
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34002: LD_ADDR_VAR 0 5
34006: PUSH
34007: LD_EXP 109
34011: PUSH
34012: LD_VAR 0 2
34016: ARRAY
34017: PUSH
34018: LD_EXP 109
34022: PUSH
34023: LD_VAR 0 2
34027: ARRAY
34028: PUSH
34029: LD_VAR 0 3
34033: ARRAY
34034: DIFF
34035: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34036: LD_ADDR_EXP 109
34040: PUSH
34041: LD_EXP 109
34045: PPUSH
34046: LD_VAR 0 2
34050: PPUSH
34051: LD_VAR 0 5
34055: PPUSH
34056: CALL_OW 1
34060: ST_TO_ADDR
// continue ;
34061: GO 33949
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34063: LD_EXP 109
34067: PUSH
34068: LD_VAR 0 2
34072: ARRAY
34073: PUSH
34074: LD_VAR 0 3
34078: ARRAY
34079: PPUSH
34080: CALL_OW 257
34084: PUSH
34085: LD_INT 1
34087: EQUAL
34088: PUSH
34089: LD_EXP 109
34093: PUSH
34094: LD_VAR 0 2
34098: ARRAY
34099: PUSH
34100: LD_VAR 0 3
34104: ARRAY
34105: PPUSH
34106: CALL_OW 459
34110: NOT
34111: AND
34112: PUSH
34113: LD_EXP 109
34117: PUSH
34118: LD_VAR 0 2
34122: ARRAY
34123: PUSH
34124: LD_VAR 0 3
34128: ARRAY
34129: PPUSH
34130: CALL_OW 314
34134: NOT
34135: AND
34136: IFFALSE 34296
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34138: LD_EXP 109
34142: PUSH
34143: LD_VAR 0 2
34147: ARRAY
34148: PUSH
34149: LD_VAR 0 3
34153: ARRAY
34154: PPUSH
34155: CALL_OW 310
34159: IFFALSE 34182
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34161: LD_EXP 109
34165: PUSH
34166: LD_VAR 0 2
34170: ARRAY
34171: PUSH
34172: LD_VAR 0 3
34176: ARRAY
34177: PPUSH
34178: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34182: LD_EXP 109
34186: PUSH
34187: LD_VAR 0 2
34191: ARRAY
34192: PUSH
34193: LD_VAR 0 3
34197: ARRAY
34198: PPUSH
34199: CALL_OW 314
34203: NOT
34204: IFFALSE 34296
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34206: LD_ADDR_VAR 0 7
34210: PUSH
34211: LD_INT 1
34213: PPUSH
34214: LD_EXP 108
34218: PUSH
34219: LD_VAR 0 2
34223: ARRAY
34224: PPUSH
34225: CALL_OW 12
34229: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34230: LD_EXP 109
34234: PUSH
34235: LD_VAR 0 2
34239: ARRAY
34240: PUSH
34241: LD_VAR 0 3
34245: ARRAY
34246: PPUSH
34247: LD_EXP 108
34251: PUSH
34252: LD_VAR 0 2
34256: ARRAY
34257: PUSH
34258: LD_VAR 0 7
34262: ARRAY
34263: PUSH
34264: LD_INT 1
34266: ARRAY
34267: PPUSH
34268: LD_EXP 108
34272: PUSH
34273: LD_VAR 0 2
34277: ARRAY
34278: PUSH
34279: LD_VAR 0 7
34283: ARRAY
34284: PUSH
34285: LD_INT 2
34287: ARRAY
34288: PPUSH
34289: LD_INT 0
34291: PPUSH
34292: CALL_OW 193
// end ; end ; end ;
34296: GO 33949
34298: POP
34299: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34300: LD_ADDR_VAR 0 5
34304: PUSH
34305: LD_EXP 95
34309: PUSH
34310: LD_VAR 0 2
34314: ARRAY
34315: PPUSH
34316: LD_INT 2
34318: PUSH
34319: LD_INT 30
34321: PUSH
34322: LD_INT 4
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 30
34331: PUSH
34332: LD_INT 5
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 30
34341: PUSH
34342: LD_INT 32
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: EMPTY
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: PPUSH
34355: CALL_OW 72
34359: ST_TO_ADDR
// if not tmp then
34360: LD_VAR 0 5
34364: NOT
34365: IFFALSE 34369
// continue ;
34367: GO 33862
// list := [ ] ;
34369: LD_ADDR_VAR 0 6
34373: PUSH
34374: EMPTY
34375: ST_TO_ADDR
// for j in tmp do
34376: LD_ADDR_VAR 0 3
34380: PUSH
34381: LD_VAR 0 5
34385: PUSH
34386: FOR_IN
34387: IFFALSE 34456
// begin for k in UnitsInside ( j ) do
34389: LD_ADDR_VAR 0 4
34393: PUSH
34394: LD_VAR 0 3
34398: PPUSH
34399: CALL_OW 313
34403: PUSH
34404: FOR_IN
34405: IFFALSE 34452
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34407: LD_VAR 0 4
34411: PPUSH
34412: CALL_OW 257
34416: PUSH
34417: LD_INT 1
34419: EQUAL
34420: PUSH
34421: LD_VAR 0 4
34425: PPUSH
34426: CALL_OW 459
34430: NOT
34431: AND
34432: IFFALSE 34450
// list := list ^ k ;
34434: LD_ADDR_VAR 0 6
34438: PUSH
34439: LD_VAR 0 6
34443: PUSH
34444: LD_VAR 0 4
34448: ADD
34449: ST_TO_ADDR
34450: GO 34404
34452: POP
34453: POP
// end ;
34454: GO 34386
34456: POP
34457: POP
// list := list diff mc_miners [ i ] ;
34458: LD_ADDR_VAR 0 6
34462: PUSH
34463: LD_VAR 0 6
34467: PUSH
34468: LD_EXP 109
34472: PUSH
34473: LD_VAR 0 2
34477: ARRAY
34478: DIFF
34479: ST_TO_ADDR
// if not list then
34480: LD_VAR 0 6
34484: NOT
34485: IFFALSE 34489
// continue ;
34487: GO 33862
// k := mc_mines [ i ] - mc_miners [ i ] ;
34489: LD_ADDR_VAR 0 4
34493: PUSH
34494: LD_EXP 108
34498: PUSH
34499: LD_VAR 0 2
34503: ARRAY
34504: PUSH
34505: LD_EXP 109
34509: PUSH
34510: LD_VAR 0 2
34514: ARRAY
34515: MINUS
34516: ST_TO_ADDR
// if k > list then
34517: LD_VAR 0 4
34521: PUSH
34522: LD_VAR 0 6
34526: GREATER
34527: IFFALSE 34539
// k := list ;
34529: LD_ADDR_VAR 0 4
34533: PUSH
34534: LD_VAR 0 6
34538: ST_TO_ADDR
// for j = 1 to k do
34539: LD_ADDR_VAR 0 3
34543: PUSH
34544: DOUBLE
34545: LD_INT 1
34547: DEC
34548: ST_TO_ADDR
34549: LD_VAR 0 4
34553: PUSH
34554: FOR_TO
34555: IFFALSE 34609
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34557: LD_ADDR_EXP 109
34561: PUSH
34562: LD_EXP 109
34566: PPUSH
34567: LD_VAR 0 2
34571: PUSH
34572: LD_EXP 109
34576: PUSH
34577: LD_VAR 0 2
34581: ARRAY
34582: PUSH
34583: LD_INT 1
34585: PLUS
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PPUSH
34591: LD_VAR 0 6
34595: PUSH
34596: LD_VAR 0 3
34600: ARRAY
34601: PPUSH
34602: CALL 56974 0 3
34606: ST_TO_ADDR
34607: GO 34554
34609: POP
34610: POP
// end ;
34611: GO 33862
34613: POP
34614: POP
// end ;
34615: LD_VAR 0 1
34619: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34620: LD_INT 0
34622: PPUSH
34623: PPUSH
34624: PPUSH
34625: PPUSH
34626: PPUSH
34627: PPUSH
34628: PPUSH
34629: PPUSH
34630: PPUSH
34631: PPUSH
34632: PPUSH
// if not mc_bases then
34633: LD_EXP 95
34637: NOT
34638: IFFALSE 34642
// exit ;
34640: GO 36465
// for i = 1 to mc_bases do
34642: LD_ADDR_VAR 0 2
34646: PUSH
34647: DOUBLE
34648: LD_INT 1
34650: DEC
34651: ST_TO_ADDR
34652: LD_EXP 95
34656: PUSH
34657: FOR_TO
34658: IFFALSE 36463
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34660: LD_EXP 95
34664: PUSH
34665: LD_VAR 0 2
34669: ARRAY
34670: NOT
34671: PUSH
34672: LD_EXP 102
34676: PUSH
34677: LD_VAR 0 2
34681: ARRAY
34682: OR
34683: IFFALSE 34687
// continue ;
34685: GO 34657
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34687: LD_EXP 111
34691: PUSH
34692: LD_VAR 0 2
34696: ARRAY
34697: NOT
34698: PUSH
34699: LD_EXP 112
34703: PUSH
34704: LD_VAR 0 2
34708: ARRAY
34709: AND
34710: IFFALSE 34748
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34712: LD_ADDR_EXP 112
34716: PUSH
34717: LD_EXP 112
34721: PPUSH
34722: LD_VAR 0 2
34726: PPUSH
34727: EMPTY
34728: PPUSH
34729: CALL_OW 1
34733: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34734: LD_VAR 0 2
34738: PPUSH
34739: LD_INT 107
34741: PPUSH
34742: CALL 25516 0 2
// continue ;
34746: GO 34657
// end ; target := [ ] ;
34748: LD_ADDR_VAR 0 7
34752: PUSH
34753: EMPTY
34754: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34755: LD_ADDR_VAR 0 6
34759: PUSH
34760: LD_EXP 95
34764: PUSH
34765: LD_VAR 0 2
34769: ARRAY
34770: PUSH
34771: LD_INT 1
34773: ARRAY
34774: PPUSH
34775: CALL_OW 255
34779: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34780: LD_ADDR_VAR 0 9
34784: PUSH
34785: LD_EXP 95
34789: PUSH
34790: LD_VAR 0 2
34794: ARRAY
34795: PPUSH
34796: LD_INT 2
34798: PUSH
34799: LD_INT 30
34801: PUSH
34802: LD_INT 0
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 30
34811: PUSH
34812: LD_INT 1
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: LIST
34823: PPUSH
34824: CALL_OW 72
34828: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34829: LD_ADDR_VAR 0 3
34833: PUSH
34834: DOUBLE
34835: LD_EXP 111
34839: PUSH
34840: LD_VAR 0 2
34844: ARRAY
34845: INC
34846: ST_TO_ADDR
34847: LD_INT 1
34849: PUSH
34850: FOR_DOWNTO
34851: IFFALSE 35096
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34853: LD_EXP 111
34857: PUSH
34858: LD_VAR 0 2
34862: ARRAY
34863: PUSH
34864: LD_VAR 0 3
34868: ARRAY
34869: PUSH
34870: LD_INT 2
34872: ARRAY
34873: PPUSH
34874: LD_EXP 111
34878: PUSH
34879: LD_VAR 0 2
34883: ARRAY
34884: PUSH
34885: LD_VAR 0 3
34889: ARRAY
34890: PUSH
34891: LD_INT 3
34893: ARRAY
34894: PPUSH
34895: CALL_OW 488
34899: PUSH
34900: LD_EXP 111
34904: PUSH
34905: LD_VAR 0 2
34909: ARRAY
34910: PUSH
34911: LD_VAR 0 3
34915: ARRAY
34916: PUSH
34917: LD_INT 2
34919: ARRAY
34920: PPUSH
34921: LD_EXP 111
34925: PUSH
34926: LD_VAR 0 2
34930: ARRAY
34931: PUSH
34932: LD_VAR 0 3
34936: ARRAY
34937: PUSH
34938: LD_INT 3
34940: ARRAY
34941: PPUSH
34942: CALL_OW 284
34946: PUSH
34947: LD_INT 0
34949: EQUAL
34950: AND
34951: IFFALSE 35006
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34953: LD_ADDR_VAR 0 5
34957: PUSH
34958: LD_EXP 111
34962: PUSH
34963: LD_VAR 0 2
34967: ARRAY
34968: PPUSH
34969: LD_VAR 0 3
34973: PPUSH
34974: CALL_OW 3
34978: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34979: LD_ADDR_EXP 111
34983: PUSH
34984: LD_EXP 111
34988: PPUSH
34989: LD_VAR 0 2
34993: PPUSH
34994: LD_VAR 0 5
34998: PPUSH
34999: CALL_OW 1
35003: ST_TO_ADDR
// continue ;
35004: GO 34850
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35006: LD_VAR 0 6
35010: PPUSH
35011: LD_EXP 111
35015: PUSH
35016: LD_VAR 0 2
35020: ARRAY
35021: PUSH
35022: LD_VAR 0 3
35026: ARRAY
35027: PUSH
35028: LD_INT 2
35030: ARRAY
35031: PPUSH
35032: LD_EXP 111
35036: PUSH
35037: LD_VAR 0 2
35041: ARRAY
35042: PUSH
35043: LD_VAR 0 3
35047: ARRAY
35048: PUSH
35049: LD_INT 3
35051: ARRAY
35052: PPUSH
35053: LD_INT 30
35055: PPUSH
35056: CALL 57870 0 4
35060: PUSH
35061: LD_INT 4
35063: ARRAY
35064: PUSH
35065: LD_INT 0
35067: EQUAL
35068: IFFALSE 35094
// begin target := mc_crates [ i ] [ j ] ;
35070: LD_ADDR_VAR 0 7
35074: PUSH
35075: LD_EXP 111
35079: PUSH
35080: LD_VAR 0 2
35084: ARRAY
35085: PUSH
35086: LD_VAR 0 3
35090: ARRAY
35091: ST_TO_ADDR
// break ;
35092: GO 35096
// end ; end ;
35094: GO 34850
35096: POP
35097: POP
// if not target then
35098: LD_VAR 0 7
35102: NOT
35103: IFFALSE 35107
// continue ;
35105: GO 34657
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35107: LD_ADDR_VAR 0 8
35111: PUSH
35112: LD_EXP 114
35116: PUSH
35117: LD_VAR 0 2
35121: ARRAY
35122: PPUSH
35123: LD_INT 2
35125: PUSH
35126: LD_INT 3
35128: PUSH
35129: LD_INT 58
35131: PUSH
35132: EMPTY
35133: LIST
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 61
35141: PUSH
35142: EMPTY
35143: LIST
35144: PUSH
35145: LD_INT 33
35147: PUSH
35148: LD_INT 5
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 33
35157: PUSH
35158: LD_INT 3
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: LIST
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 2
35174: PUSH
35175: LD_INT 34
35177: PUSH
35178: LD_INT 32
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 34
35187: PUSH
35188: LD_INT 51
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 34
35197: PUSH
35198: LD_INT 12
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: LIST
35209: LIST
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PPUSH
35215: CALL_OW 72
35219: ST_TO_ADDR
// if not cargo then
35220: LD_VAR 0 8
35224: NOT
35225: IFFALSE 35931
// begin if mc_crates_collector [ i ] < 5 then
35227: LD_EXP 112
35231: PUSH
35232: LD_VAR 0 2
35236: ARRAY
35237: PUSH
35238: LD_INT 5
35240: LESS
35241: IFFALSE 35607
// begin if mc_ape [ i ] then
35243: LD_EXP 124
35247: PUSH
35248: LD_VAR 0 2
35252: ARRAY
35253: IFFALSE 35300
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35255: LD_ADDR_VAR 0 5
35259: PUSH
35260: LD_EXP 124
35264: PUSH
35265: LD_VAR 0 2
35269: ARRAY
35270: PPUSH
35271: LD_INT 25
35273: PUSH
35274: LD_INT 16
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 24
35283: PUSH
35284: LD_INT 750
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PPUSH
35295: CALL_OW 72
35299: ST_TO_ADDR
// if not tmp then
35300: LD_VAR 0 5
35304: NOT
35305: IFFALSE 35352
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35307: LD_ADDR_VAR 0 5
35311: PUSH
35312: LD_EXP 95
35316: PUSH
35317: LD_VAR 0 2
35321: ARRAY
35322: PPUSH
35323: LD_INT 25
35325: PUSH
35326: LD_INT 2
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 24
35335: PUSH
35336: LD_INT 750
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PPUSH
35347: CALL_OW 72
35351: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35352: LD_EXP 124
35356: PUSH
35357: LD_VAR 0 2
35361: ARRAY
35362: PUSH
35363: LD_EXP 95
35367: PUSH
35368: LD_VAR 0 2
35372: ARRAY
35373: PPUSH
35374: LD_INT 25
35376: PUSH
35377: LD_INT 2
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 24
35386: PUSH
35387: LD_INT 750
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PPUSH
35398: CALL_OW 72
35402: AND
35403: PUSH
35404: LD_VAR 0 5
35408: PUSH
35409: LD_INT 5
35411: LESS
35412: AND
35413: IFFALSE 35495
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35415: LD_ADDR_VAR 0 3
35419: PUSH
35420: LD_EXP 95
35424: PUSH
35425: LD_VAR 0 2
35429: ARRAY
35430: PPUSH
35431: LD_INT 25
35433: PUSH
35434: LD_INT 2
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 24
35443: PUSH
35444: LD_INT 750
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PPUSH
35455: CALL_OW 72
35459: PUSH
35460: FOR_IN
35461: IFFALSE 35493
// begin tmp := tmp union j ;
35463: LD_ADDR_VAR 0 5
35467: PUSH
35468: LD_VAR 0 5
35472: PUSH
35473: LD_VAR 0 3
35477: UNION
35478: ST_TO_ADDR
// if tmp >= 5 then
35479: LD_VAR 0 5
35483: PUSH
35484: LD_INT 5
35486: GREATEREQUAL
35487: IFFALSE 35491
// break ;
35489: GO 35493
// end ;
35491: GO 35460
35493: POP
35494: POP
// end ; if not tmp then
35495: LD_VAR 0 5
35499: NOT
35500: IFFALSE 35504
// continue ;
35502: GO 34657
// for j in tmp do
35504: LD_ADDR_VAR 0 3
35508: PUSH
35509: LD_VAR 0 5
35513: PUSH
35514: FOR_IN
35515: IFFALSE 35605
// if not GetTag ( j ) then
35517: LD_VAR 0 3
35521: PPUSH
35522: CALL_OW 110
35526: NOT
35527: IFFALSE 35603
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35529: LD_ADDR_EXP 112
35533: PUSH
35534: LD_EXP 112
35538: PPUSH
35539: LD_VAR 0 2
35543: PUSH
35544: LD_EXP 112
35548: PUSH
35549: LD_VAR 0 2
35553: ARRAY
35554: PUSH
35555: LD_INT 1
35557: PLUS
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PPUSH
35563: LD_VAR 0 3
35567: PPUSH
35568: CALL 56974 0 3
35572: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35573: LD_VAR 0 3
35577: PPUSH
35578: LD_INT 107
35580: PPUSH
35581: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35585: LD_EXP 112
35589: PUSH
35590: LD_VAR 0 2
35594: ARRAY
35595: PUSH
35596: LD_INT 5
35598: GREATEREQUAL
35599: IFFALSE 35603
// break ;
35601: GO 35605
// end ;
35603: GO 35514
35605: POP
35606: POP
// end ; if mc_crates_collector [ i ] and target then
35607: LD_EXP 112
35611: PUSH
35612: LD_VAR 0 2
35616: ARRAY
35617: PUSH
35618: LD_VAR 0 7
35622: AND
35623: IFFALSE 35929
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35625: LD_EXP 112
35629: PUSH
35630: LD_VAR 0 2
35634: ARRAY
35635: PUSH
35636: LD_VAR 0 7
35640: PUSH
35641: LD_INT 1
35643: ARRAY
35644: LESS
35645: IFFALSE 35665
// tmp := mc_crates_collector [ i ] else
35647: LD_ADDR_VAR 0 5
35651: PUSH
35652: LD_EXP 112
35656: PUSH
35657: LD_VAR 0 2
35661: ARRAY
35662: ST_TO_ADDR
35663: GO 35679
// tmp := target [ 1 ] ;
35665: LD_ADDR_VAR 0 5
35669: PUSH
35670: LD_VAR 0 7
35674: PUSH
35675: LD_INT 1
35677: ARRAY
35678: ST_TO_ADDR
// k := 0 ;
35679: LD_ADDR_VAR 0 4
35683: PUSH
35684: LD_INT 0
35686: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35687: LD_ADDR_VAR 0 3
35691: PUSH
35692: LD_EXP 112
35696: PUSH
35697: LD_VAR 0 2
35701: ARRAY
35702: PUSH
35703: FOR_IN
35704: IFFALSE 35927
// begin k := k + 1 ;
35706: LD_ADDR_VAR 0 4
35710: PUSH
35711: LD_VAR 0 4
35715: PUSH
35716: LD_INT 1
35718: PLUS
35719: ST_TO_ADDR
// if k > tmp then
35720: LD_VAR 0 4
35724: PUSH
35725: LD_VAR 0 5
35729: GREATER
35730: IFFALSE 35734
// break ;
35732: GO 35927
// if not GetClass ( j ) in [ 2 , 16 ] then
35734: LD_VAR 0 3
35738: PPUSH
35739: CALL_OW 257
35743: PUSH
35744: LD_INT 2
35746: PUSH
35747: LD_INT 16
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: IN
35754: NOT
35755: IFFALSE 35808
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35757: LD_ADDR_EXP 112
35761: PUSH
35762: LD_EXP 112
35766: PPUSH
35767: LD_VAR 0 2
35771: PPUSH
35772: LD_EXP 112
35776: PUSH
35777: LD_VAR 0 2
35781: ARRAY
35782: PUSH
35783: LD_VAR 0 3
35787: DIFF
35788: PPUSH
35789: CALL_OW 1
35793: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35794: LD_VAR 0 3
35798: PPUSH
35799: LD_INT 0
35801: PPUSH
35802: CALL_OW 109
// continue ;
35806: GO 35703
// end ; if IsInUnit ( j ) then
35808: LD_VAR 0 3
35812: PPUSH
35813: CALL_OW 310
35817: IFFALSE 35828
// ComExitBuilding ( j ) ;
35819: LD_VAR 0 3
35823: PPUSH
35824: CALL_OW 122
// wait ( 3 ) ;
35828: LD_INT 3
35830: PPUSH
35831: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35835: LD_VAR 0 3
35839: PPUSH
35840: CALL_OW 314
35844: PUSH
35845: LD_VAR 0 6
35849: PPUSH
35850: LD_VAR 0 7
35854: PUSH
35855: LD_INT 2
35857: ARRAY
35858: PPUSH
35859: LD_VAR 0 7
35863: PUSH
35864: LD_INT 3
35866: ARRAY
35867: PPUSH
35868: LD_INT 30
35870: PPUSH
35871: CALL 57870 0 4
35875: PUSH
35876: LD_INT 4
35878: ARRAY
35879: AND
35880: IFFALSE 35898
// ComStandNearbyBuilding ( j , depot ) else
35882: LD_VAR 0 3
35886: PPUSH
35887: LD_VAR 0 9
35891: PPUSH
35892: CALL 53552 0 2
35896: GO 35925
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35898: LD_VAR 0 3
35902: PPUSH
35903: LD_VAR 0 7
35907: PUSH
35908: LD_INT 2
35910: ARRAY
35911: PPUSH
35912: LD_VAR 0 7
35916: PUSH
35917: LD_INT 3
35919: ARRAY
35920: PPUSH
35921: CALL_OW 117
// end ;
35925: GO 35703
35927: POP
35928: POP
// end ; end else
35929: GO 36461
// begin for j in cargo do
35931: LD_ADDR_VAR 0 3
35935: PUSH
35936: LD_VAR 0 8
35940: PUSH
35941: FOR_IN
35942: IFFALSE 36459
// begin if GetTag ( j ) <> 0 then
35944: LD_VAR 0 3
35948: PPUSH
35949: CALL_OW 110
35953: PUSH
35954: LD_INT 0
35956: NONEQUAL
35957: IFFALSE 35961
// continue ;
35959: GO 35941
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35961: LD_VAR 0 3
35965: PPUSH
35966: CALL_OW 256
35970: PUSH
35971: LD_INT 1000
35973: LESS
35974: PUSH
35975: LD_VAR 0 3
35979: PPUSH
35980: LD_EXP 119
35984: PUSH
35985: LD_VAR 0 2
35989: ARRAY
35990: PPUSH
35991: CALL_OW 308
35995: NOT
35996: AND
35997: IFFALSE 36019
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35999: LD_VAR 0 3
36003: PPUSH
36004: LD_EXP 119
36008: PUSH
36009: LD_VAR 0 2
36013: ARRAY
36014: PPUSH
36015: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36019: LD_VAR 0 3
36023: PPUSH
36024: CALL_OW 256
36028: PUSH
36029: LD_INT 1000
36031: LESS
36032: PUSH
36033: LD_VAR 0 3
36037: PPUSH
36038: LD_EXP 119
36042: PUSH
36043: LD_VAR 0 2
36047: ARRAY
36048: PPUSH
36049: CALL_OW 308
36053: AND
36054: IFFALSE 36058
// continue ;
36056: GO 35941
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36058: LD_VAR 0 3
36062: PPUSH
36063: CALL_OW 262
36067: PUSH
36068: LD_INT 2
36070: EQUAL
36071: PUSH
36072: LD_VAR 0 3
36076: PPUSH
36077: CALL_OW 261
36081: PUSH
36082: LD_INT 15
36084: LESS
36085: AND
36086: IFFALSE 36090
// continue ;
36088: GO 35941
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36090: LD_VAR 0 3
36094: PPUSH
36095: CALL_OW 262
36099: PUSH
36100: LD_INT 1
36102: EQUAL
36103: PUSH
36104: LD_VAR 0 3
36108: PPUSH
36109: CALL_OW 261
36113: PUSH
36114: LD_INT 10
36116: LESS
36117: AND
36118: IFFALSE 36398
// begin if not depot then
36120: LD_VAR 0 9
36124: NOT
36125: IFFALSE 36129
// continue ;
36127: GO 35941
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36129: LD_VAR 0 3
36133: PPUSH
36134: LD_VAR 0 9
36138: PPUSH
36139: LD_VAR 0 3
36143: PPUSH
36144: CALL_OW 74
36148: PPUSH
36149: CALL_OW 296
36153: PUSH
36154: LD_INT 6
36156: LESS
36157: IFFALSE 36173
// SetFuel ( j , 100 ) else
36159: LD_VAR 0 3
36163: PPUSH
36164: LD_INT 100
36166: PPUSH
36167: CALL_OW 240
36171: GO 36398
// if GetFuel ( j ) = 0 then
36173: LD_VAR 0 3
36177: PPUSH
36178: CALL_OW 261
36182: PUSH
36183: LD_INT 0
36185: EQUAL
36186: IFFALSE 36398
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36188: LD_ADDR_EXP 114
36192: PUSH
36193: LD_EXP 114
36197: PPUSH
36198: LD_VAR 0 2
36202: PPUSH
36203: LD_EXP 114
36207: PUSH
36208: LD_VAR 0 2
36212: ARRAY
36213: PUSH
36214: LD_VAR 0 3
36218: DIFF
36219: PPUSH
36220: CALL_OW 1
36224: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36225: LD_VAR 0 3
36229: PPUSH
36230: CALL_OW 263
36234: PUSH
36235: LD_INT 1
36237: EQUAL
36238: IFFALSE 36254
// ComExitVehicle ( IsInUnit ( j ) ) ;
36240: LD_VAR 0 3
36244: PPUSH
36245: CALL_OW 310
36249: PPUSH
36250: CALL_OW 121
// if GetControl ( j ) = control_remote then
36254: LD_VAR 0 3
36258: PPUSH
36259: CALL_OW 263
36263: PUSH
36264: LD_INT 2
36266: EQUAL
36267: IFFALSE 36278
// ComUnlink ( j ) ;
36269: LD_VAR 0 3
36273: PPUSH
36274: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36278: LD_ADDR_VAR 0 10
36282: PUSH
36283: LD_VAR 0 2
36287: PPUSH
36288: LD_INT 3
36290: PPUSH
36291: CALL 46037 0 2
36295: ST_TO_ADDR
// if fac then
36296: LD_VAR 0 10
36300: IFFALSE 36396
// begin for k in fac do
36302: LD_ADDR_VAR 0 4
36306: PUSH
36307: LD_VAR 0 10
36311: PUSH
36312: FOR_IN
36313: IFFALSE 36394
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36315: LD_ADDR_VAR 0 11
36319: PUSH
36320: LD_VAR 0 10
36324: PPUSH
36325: LD_VAR 0 3
36329: PPUSH
36330: CALL_OW 265
36334: PPUSH
36335: LD_VAR 0 3
36339: PPUSH
36340: CALL_OW 262
36344: PPUSH
36345: LD_VAR 0 3
36349: PPUSH
36350: CALL_OW 263
36354: PPUSH
36355: LD_VAR 0 3
36359: PPUSH
36360: CALL_OW 264
36364: PPUSH
36365: CALL 54470 0 5
36369: ST_TO_ADDR
// if components then
36370: LD_VAR 0 11
36374: IFFALSE 36392
// begin MC_InsertProduceList ( i , components ) ;
36376: LD_VAR 0 2
36380: PPUSH
36381: LD_VAR 0 11
36385: PPUSH
36386: CALL 45582 0 2
// break ;
36390: GO 36394
// end ; end ;
36392: GO 36312
36394: POP
36395: POP
// end ; continue ;
36396: GO 35941
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36398: LD_VAR 0 3
36402: PPUSH
36403: LD_INT 1
36405: PPUSH
36406: CALL_OW 289
36410: PUSH
36411: LD_INT 100
36413: LESS
36414: PUSH
36415: LD_VAR 0 3
36419: PPUSH
36420: CALL_OW 314
36424: NOT
36425: AND
36426: IFFALSE 36455
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36428: LD_VAR 0 3
36432: PPUSH
36433: LD_VAR 0 7
36437: PUSH
36438: LD_INT 2
36440: ARRAY
36441: PPUSH
36442: LD_VAR 0 7
36446: PUSH
36447: LD_INT 3
36449: ARRAY
36450: PPUSH
36451: CALL_OW 117
// break ;
36455: GO 36459
// end ;
36457: GO 35941
36459: POP
36460: POP
// end ; end ;
36461: GO 34657
36463: POP
36464: POP
// end ;
36465: LD_VAR 0 1
36469: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36470: LD_INT 0
36472: PPUSH
36473: PPUSH
36474: PPUSH
36475: PPUSH
// if not mc_bases then
36476: LD_EXP 95
36480: NOT
36481: IFFALSE 36485
// exit ;
36483: GO 36646
// for i = 1 to mc_bases do
36485: LD_ADDR_VAR 0 2
36489: PUSH
36490: DOUBLE
36491: LD_INT 1
36493: DEC
36494: ST_TO_ADDR
36495: LD_EXP 95
36499: PUSH
36500: FOR_TO
36501: IFFALSE 36644
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36503: LD_ADDR_VAR 0 4
36507: PUSH
36508: LD_EXP 114
36512: PUSH
36513: LD_VAR 0 2
36517: ARRAY
36518: PUSH
36519: LD_EXP 117
36523: PUSH
36524: LD_VAR 0 2
36528: ARRAY
36529: UNION
36530: PPUSH
36531: LD_INT 33
36533: PUSH
36534: LD_INT 2
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PPUSH
36541: CALL_OW 72
36545: ST_TO_ADDR
// if tmp then
36546: LD_VAR 0 4
36550: IFFALSE 36642
// for j in tmp do
36552: LD_ADDR_VAR 0 3
36556: PUSH
36557: LD_VAR 0 4
36561: PUSH
36562: FOR_IN
36563: IFFALSE 36640
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36565: LD_VAR 0 3
36569: PPUSH
36570: CALL_OW 312
36574: NOT
36575: PUSH
36576: LD_VAR 0 3
36580: PPUSH
36581: CALL_OW 256
36585: PUSH
36586: LD_INT 250
36588: GREATEREQUAL
36589: AND
36590: IFFALSE 36603
// Connect ( j ) else
36592: LD_VAR 0 3
36596: PPUSH
36597: CALL 59945 0 1
36601: GO 36638
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36603: LD_VAR 0 3
36607: PPUSH
36608: CALL_OW 256
36612: PUSH
36613: LD_INT 250
36615: LESS
36616: PUSH
36617: LD_VAR 0 3
36621: PPUSH
36622: CALL_OW 312
36626: AND
36627: IFFALSE 36638
// ComUnlink ( j ) ;
36629: LD_VAR 0 3
36633: PPUSH
36634: CALL_OW 136
36638: GO 36562
36640: POP
36641: POP
// end ;
36642: GO 36500
36644: POP
36645: POP
// end ;
36646: LD_VAR 0 1
36650: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36651: LD_INT 0
36653: PPUSH
36654: PPUSH
36655: PPUSH
36656: PPUSH
36657: PPUSH
// if not mc_bases then
36658: LD_EXP 95
36662: NOT
36663: IFFALSE 36667
// exit ;
36665: GO 37112
// for i = 1 to mc_bases do
36667: LD_ADDR_VAR 0 2
36671: PUSH
36672: DOUBLE
36673: LD_INT 1
36675: DEC
36676: ST_TO_ADDR
36677: LD_EXP 95
36681: PUSH
36682: FOR_TO
36683: IFFALSE 37110
// begin if not mc_produce [ i ] then
36685: LD_EXP 116
36689: PUSH
36690: LD_VAR 0 2
36694: ARRAY
36695: NOT
36696: IFFALSE 36700
// continue ;
36698: GO 36682
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36700: LD_ADDR_VAR 0 5
36704: PUSH
36705: LD_EXP 95
36709: PUSH
36710: LD_VAR 0 2
36714: ARRAY
36715: PPUSH
36716: LD_INT 30
36718: PUSH
36719: LD_INT 3
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PPUSH
36726: CALL_OW 72
36730: ST_TO_ADDR
// if not fac then
36731: LD_VAR 0 5
36735: NOT
36736: IFFALSE 36740
// continue ;
36738: GO 36682
// for j in fac do
36740: LD_ADDR_VAR 0 3
36744: PUSH
36745: LD_VAR 0 5
36749: PUSH
36750: FOR_IN
36751: IFFALSE 37106
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36753: LD_VAR 0 3
36757: PPUSH
36758: CALL_OW 461
36762: PUSH
36763: LD_INT 2
36765: NONEQUAL
36766: PUSH
36767: LD_VAR 0 3
36771: PPUSH
36772: LD_INT 15
36774: PPUSH
36775: CALL 59573 0 2
36779: PUSH
36780: LD_INT 4
36782: ARRAY
36783: OR
36784: IFFALSE 36788
// continue ;
36786: GO 36750
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36788: LD_VAR 0 3
36792: PPUSH
36793: LD_EXP 116
36797: PUSH
36798: LD_VAR 0 2
36802: ARRAY
36803: PUSH
36804: LD_INT 1
36806: ARRAY
36807: PUSH
36808: LD_INT 1
36810: ARRAY
36811: PPUSH
36812: LD_EXP 116
36816: PUSH
36817: LD_VAR 0 2
36821: ARRAY
36822: PUSH
36823: LD_INT 1
36825: ARRAY
36826: PUSH
36827: LD_INT 2
36829: ARRAY
36830: PPUSH
36831: LD_EXP 116
36835: PUSH
36836: LD_VAR 0 2
36840: ARRAY
36841: PUSH
36842: LD_INT 1
36844: ARRAY
36845: PUSH
36846: LD_INT 3
36848: ARRAY
36849: PPUSH
36850: LD_EXP 116
36854: PUSH
36855: LD_VAR 0 2
36859: ARRAY
36860: PUSH
36861: LD_INT 1
36863: ARRAY
36864: PUSH
36865: LD_INT 4
36867: ARRAY
36868: PPUSH
36869: CALL_OW 448
36873: PUSH
36874: LD_VAR 0 3
36878: PPUSH
36879: LD_EXP 116
36883: PUSH
36884: LD_VAR 0 2
36888: ARRAY
36889: PUSH
36890: LD_INT 1
36892: ARRAY
36893: PUSH
36894: LD_INT 1
36896: ARRAY
36897: PUSH
36898: LD_EXP 116
36902: PUSH
36903: LD_VAR 0 2
36907: ARRAY
36908: PUSH
36909: LD_INT 1
36911: ARRAY
36912: PUSH
36913: LD_INT 2
36915: ARRAY
36916: PUSH
36917: LD_EXP 116
36921: PUSH
36922: LD_VAR 0 2
36926: ARRAY
36927: PUSH
36928: LD_INT 1
36930: ARRAY
36931: PUSH
36932: LD_INT 3
36934: ARRAY
36935: PUSH
36936: LD_EXP 116
36940: PUSH
36941: LD_VAR 0 2
36945: ARRAY
36946: PUSH
36947: LD_INT 1
36949: ARRAY
36950: PUSH
36951: LD_INT 4
36953: ARRAY
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: PPUSH
36961: CALL 63340 0 2
36965: AND
36966: IFFALSE 37104
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36968: LD_VAR 0 3
36972: PPUSH
36973: LD_EXP 116
36977: PUSH
36978: LD_VAR 0 2
36982: ARRAY
36983: PUSH
36984: LD_INT 1
36986: ARRAY
36987: PUSH
36988: LD_INT 1
36990: ARRAY
36991: PPUSH
36992: LD_EXP 116
36996: PUSH
36997: LD_VAR 0 2
37001: ARRAY
37002: PUSH
37003: LD_INT 1
37005: ARRAY
37006: PUSH
37007: LD_INT 2
37009: ARRAY
37010: PPUSH
37011: LD_EXP 116
37015: PUSH
37016: LD_VAR 0 2
37020: ARRAY
37021: PUSH
37022: LD_INT 1
37024: ARRAY
37025: PUSH
37026: LD_INT 3
37028: ARRAY
37029: PPUSH
37030: LD_EXP 116
37034: PUSH
37035: LD_VAR 0 2
37039: ARRAY
37040: PUSH
37041: LD_INT 1
37043: ARRAY
37044: PUSH
37045: LD_INT 4
37047: ARRAY
37048: PPUSH
37049: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37053: LD_ADDR_VAR 0 4
37057: PUSH
37058: LD_EXP 116
37062: PUSH
37063: LD_VAR 0 2
37067: ARRAY
37068: PPUSH
37069: LD_INT 1
37071: PPUSH
37072: CALL_OW 3
37076: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37077: LD_ADDR_EXP 116
37081: PUSH
37082: LD_EXP 116
37086: PPUSH
37087: LD_VAR 0 2
37091: PPUSH
37092: LD_VAR 0 4
37096: PPUSH
37097: CALL_OW 1
37101: ST_TO_ADDR
// break ;
37102: GO 37106
// end ; end ;
37104: GO 36750
37106: POP
37107: POP
// end ;
37108: GO 36682
37110: POP
37111: POP
// end ;
37112: LD_VAR 0 1
37116: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37117: LD_INT 0
37119: PPUSH
37120: PPUSH
37121: PPUSH
// if not mc_bases then
37122: LD_EXP 95
37126: NOT
37127: IFFALSE 37131
// exit ;
37129: GO 37220
// for i = 1 to mc_bases do
37131: LD_ADDR_VAR 0 2
37135: PUSH
37136: DOUBLE
37137: LD_INT 1
37139: DEC
37140: ST_TO_ADDR
37141: LD_EXP 95
37145: PUSH
37146: FOR_TO
37147: IFFALSE 37218
// begin if mc_attack [ i ] then
37149: LD_EXP 115
37153: PUSH
37154: LD_VAR 0 2
37158: ARRAY
37159: IFFALSE 37216
// begin tmp := mc_attack [ i ] [ 1 ] ;
37161: LD_ADDR_VAR 0 3
37165: PUSH
37166: LD_EXP 115
37170: PUSH
37171: LD_VAR 0 2
37175: ARRAY
37176: PUSH
37177: LD_INT 1
37179: ARRAY
37180: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37181: LD_ADDR_EXP 115
37185: PUSH
37186: LD_EXP 115
37190: PPUSH
37191: LD_VAR 0 2
37195: PPUSH
37196: EMPTY
37197: PPUSH
37198: CALL_OW 1
37202: ST_TO_ADDR
// Attack ( tmp ) ;
37203: LD_VAR 0 3
37207: PPUSH
37208: CALL 109333 0 1
// exit ;
37212: POP
37213: POP
37214: GO 37220
// end ; end ;
37216: GO 37146
37218: POP
37219: POP
// end ;
37220: LD_VAR 0 1
37224: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37225: LD_INT 0
37227: PPUSH
37228: PPUSH
37229: PPUSH
37230: PPUSH
37231: PPUSH
37232: PPUSH
37233: PPUSH
// if not mc_bases then
37234: LD_EXP 95
37238: NOT
37239: IFFALSE 37243
// exit ;
37241: GO 38100
// for i = 1 to mc_bases do
37243: LD_ADDR_VAR 0 2
37247: PUSH
37248: DOUBLE
37249: LD_INT 1
37251: DEC
37252: ST_TO_ADDR
37253: LD_EXP 95
37257: PUSH
37258: FOR_TO
37259: IFFALSE 38098
// begin if not mc_bases [ i ] then
37261: LD_EXP 95
37265: PUSH
37266: LD_VAR 0 2
37270: ARRAY
37271: NOT
37272: IFFALSE 37276
// continue ;
37274: GO 37258
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37276: LD_ADDR_VAR 0 7
37280: PUSH
37281: LD_EXP 95
37285: PUSH
37286: LD_VAR 0 2
37290: ARRAY
37291: PUSH
37292: LD_INT 1
37294: ARRAY
37295: PPUSH
37296: CALL 53774 0 1
37300: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37301: LD_ADDR_EXP 118
37305: PUSH
37306: LD_EXP 118
37310: PPUSH
37311: LD_VAR 0 2
37315: PPUSH
37316: LD_EXP 95
37320: PUSH
37321: LD_VAR 0 2
37325: ARRAY
37326: PUSH
37327: LD_INT 1
37329: ARRAY
37330: PPUSH
37331: CALL_OW 255
37335: PPUSH
37336: LD_EXP 120
37340: PUSH
37341: LD_VAR 0 2
37345: ARRAY
37346: PPUSH
37347: CALL 53739 0 2
37351: PPUSH
37352: CALL_OW 1
37356: ST_TO_ADDR
// if not mc_scan [ i ] then
37357: LD_EXP 118
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: NOT
37368: IFFALSE 37546
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37370: LD_ADDR_EXP 138
37374: PUSH
37375: LD_EXP 138
37379: PPUSH
37380: LD_VAR 0 2
37384: PPUSH
37385: LD_INT 0
37387: PPUSH
37388: CALL_OW 1
37392: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37393: LD_ADDR_VAR 0 4
37397: PUSH
37398: LD_EXP 95
37402: PUSH
37403: LD_VAR 0 2
37407: ARRAY
37408: PPUSH
37409: LD_INT 2
37411: PUSH
37412: LD_INT 25
37414: PUSH
37415: LD_INT 5
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 25
37424: PUSH
37425: LD_INT 8
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 25
37434: PUSH
37435: LD_INT 9
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: LIST
37446: LIST
37447: PPUSH
37448: CALL_OW 72
37452: ST_TO_ADDR
// if not tmp then
37453: LD_VAR 0 4
37457: NOT
37458: IFFALSE 37462
// continue ;
37460: GO 37258
// for j in tmp do
37462: LD_ADDR_VAR 0 3
37466: PUSH
37467: LD_VAR 0 4
37471: PUSH
37472: FOR_IN
37473: IFFALSE 37544
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37475: LD_VAR 0 3
37479: PPUSH
37480: CALL_OW 310
37484: PPUSH
37485: CALL_OW 266
37489: PUSH
37490: LD_INT 5
37492: EQUAL
37493: PUSH
37494: LD_VAR 0 3
37498: PPUSH
37499: CALL_OW 257
37503: PUSH
37504: LD_INT 1
37506: EQUAL
37507: AND
37508: PUSH
37509: LD_VAR 0 3
37513: PPUSH
37514: CALL_OW 459
37518: NOT
37519: AND
37520: PUSH
37521: LD_VAR 0 7
37525: AND
37526: IFFALSE 37542
// ComChangeProfession ( j , class ) ;
37528: LD_VAR 0 3
37532: PPUSH
37533: LD_VAR 0 7
37537: PPUSH
37538: CALL_OW 123
37542: GO 37472
37544: POP
37545: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37546: LD_EXP 118
37550: PUSH
37551: LD_VAR 0 2
37555: ARRAY
37556: PUSH
37557: LD_EXP 138
37561: PUSH
37562: LD_VAR 0 2
37566: ARRAY
37567: NOT
37568: AND
37569: PUSH
37570: LD_EXP 117
37574: PUSH
37575: LD_VAR 0 2
37579: ARRAY
37580: NOT
37581: AND
37582: PUSH
37583: LD_EXP 95
37587: PUSH
37588: LD_VAR 0 2
37592: ARRAY
37593: PPUSH
37594: LD_INT 50
37596: PUSH
37597: EMPTY
37598: LIST
37599: PUSH
37600: LD_INT 2
37602: PUSH
37603: LD_INT 30
37605: PUSH
37606: LD_INT 32
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 30
37615: PUSH
37616: LD_INT 33
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 30
37625: PUSH
37626: LD_INT 4
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 30
37635: PUSH
37636: LD_INT 5
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PPUSH
37654: CALL_OW 72
37658: PUSH
37659: LD_INT 4
37661: LESS
37662: PUSH
37663: LD_EXP 95
37667: PUSH
37668: LD_VAR 0 2
37672: ARRAY
37673: PPUSH
37674: LD_INT 3
37676: PUSH
37677: LD_INT 24
37679: PUSH
37680: LD_INT 1000
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: EMPTY
37688: LIST
37689: LIST
37690: PUSH
37691: LD_INT 2
37693: PUSH
37694: LD_INT 30
37696: PUSH
37697: LD_INT 0
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PUSH
37704: LD_INT 30
37706: PUSH
37707: LD_INT 1
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: LIST
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PPUSH
37723: CALL_OW 72
37727: OR
37728: AND
37729: IFFALSE 37980
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37731: LD_ADDR_EXP 138
37735: PUSH
37736: LD_EXP 138
37740: PPUSH
37741: LD_VAR 0 2
37745: PPUSH
37746: LD_INT 1
37748: PPUSH
37749: CALL_OW 1
37753: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37754: LD_ADDR_VAR 0 4
37758: PUSH
37759: LD_EXP 95
37763: PUSH
37764: LD_VAR 0 2
37768: ARRAY
37769: PPUSH
37770: LD_INT 2
37772: PUSH
37773: LD_INT 25
37775: PUSH
37776: LD_INT 1
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 25
37785: PUSH
37786: LD_INT 5
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 25
37795: PUSH
37796: LD_INT 8
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 25
37805: PUSH
37806: LD_INT 9
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: PPUSH
37820: CALL_OW 72
37824: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37825: LD_ADDR_VAR 0 4
37829: PUSH
37830: LD_VAR 0 4
37834: PUSH
37835: LD_VAR 0 4
37839: PPUSH
37840: LD_INT 18
37842: PPUSH
37843: CALL 86243 0 2
37847: DIFF
37848: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37849: LD_VAR 0 4
37853: NOT
37854: PUSH
37855: LD_EXP 95
37859: PUSH
37860: LD_VAR 0 2
37864: ARRAY
37865: PPUSH
37866: LD_INT 2
37868: PUSH
37869: LD_INT 30
37871: PUSH
37872: LD_INT 4
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 30
37881: PUSH
37882: LD_INT 5
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: LIST
37893: PPUSH
37894: CALL_OW 72
37898: NOT
37899: AND
37900: IFFALSE 37962
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37902: LD_ADDR_VAR 0 4
37906: PUSH
37907: LD_EXP 95
37911: PUSH
37912: LD_VAR 0 2
37916: ARRAY
37917: PPUSH
37918: LD_INT 2
37920: PUSH
37921: LD_INT 25
37923: PUSH
37924: LD_INT 2
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 25
37933: PUSH
37934: LD_INT 3
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 25
37943: PUSH
37944: LD_INT 4
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: PPUSH
37957: CALL_OW 72
37961: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37962: LD_VAR 0 2
37966: PPUSH
37967: LD_VAR 0 4
37971: PPUSH
37972: CALL 114042 0 2
// exit ;
37976: POP
37977: POP
37978: GO 38100
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37980: LD_EXP 118
37984: PUSH
37985: LD_VAR 0 2
37989: ARRAY
37990: PUSH
37991: LD_EXP 138
37995: PUSH
37996: LD_VAR 0 2
38000: ARRAY
38001: NOT
38002: AND
38003: PUSH
38004: LD_EXP 117
38008: PUSH
38009: LD_VAR 0 2
38013: ARRAY
38014: AND
38015: IFFALSE 38096
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38017: LD_ADDR_EXP 138
38021: PUSH
38022: LD_EXP 138
38026: PPUSH
38027: LD_VAR 0 2
38031: PPUSH
38032: LD_INT 1
38034: PPUSH
38035: CALL_OW 1
38039: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38040: LD_ADDR_VAR 0 4
38044: PUSH
38045: LD_EXP 117
38049: PUSH
38050: LD_VAR 0 2
38054: ARRAY
38055: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38056: LD_ADDR_EXP 117
38060: PUSH
38061: LD_EXP 117
38065: PPUSH
38066: LD_VAR 0 2
38070: PPUSH
38071: EMPTY
38072: PPUSH
38073: CALL_OW 1
38077: ST_TO_ADDR
// Defend ( i , tmp ) ;
38078: LD_VAR 0 2
38082: PPUSH
38083: LD_VAR 0 4
38087: PPUSH
38088: CALL 114638 0 2
// exit ;
38092: POP
38093: POP
38094: GO 38100
// end ; end ;
38096: GO 37258
38098: POP
38099: POP
// end ;
38100: LD_VAR 0 1
38104: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38105: LD_INT 0
38107: PPUSH
38108: PPUSH
38109: PPUSH
38110: PPUSH
38111: PPUSH
38112: PPUSH
38113: PPUSH
38114: PPUSH
38115: PPUSH
38116: PPUSH
38117: PPUSH
// if not mc_bases then
38118: LD_EXP 95
38122: NOT
38123: IFFALSE 38127
// exit ;
38125: GO 39214
// for i = 1 to mc_bases do
38127: LD_ADDR_VAR 0 2
38131: PUSH
38132: DOUBLE
38133: LD_INT 1
38135: DEC
38136: ST_TO_ADDR
38137: LD_EXP 95
38141: PUSH
38142: FOR_TO
38143: IFFALSE 39212
// begin tmp := mc_lab [ i ] ;
38145: LD_ADDR_VAR 0 6
38149: PUSH
38150: LD_EXP 128
38154: PUSH
38155: LD_VAR 0 2
38159: ARRAY
38160: ST_TO_ADDR
// if not tmp then
38161: LD_VAR 0 6
38165: NOT
38166: IFFALSE 38170
// continue ;
38168: GO 38142
// idle_lab := 0 ;
38170: LD_ADDR_VAR 0 11
38174: PUSH
38175: LD_INT 0
38177: ST_TO_ADDR
// for j in tmp do
38178: LD_ADDR_VAR 0 3
38182: PUSH
38183: LD_VAR 0 6
38187: PUSH
38188: FOR_IN
38189: IFFALSE 39208
// begin researching := false ;
38191: LD_ADDR_VAR 0 10
38195: PUSH
38196: LD_INT 0
38198: ST_TO_ADDR
// side := GetSide ( j ) ;
38199: LD_ADDR_VAR 0 4
38203: PUSH
38204: LD_VAR 0 3
38208: PPUSH
38209: CALL_OW 255
38213: ST_TO_ADDR
// if not mc_tech [ side ] then
38214: LD_EXP 122
38218: PUSH
38219: LD_VAR 0 4
38223: ARRAY
38224: NOT
38225: IFFALSE 38229
// continue ;
38227: GO 38188
// if BuildingStatus ( j ) = bs_idle then
38229: LD_VAR 0 3
38233: PPUSH
38234: CALL_OW 461
38238: PUSH
38239: LD_INT 2
38241: EQUAL
38242: IFFALSE 38430
// begin if idle_lab and UnitsInside ( j ) < 6 then
38244: LD_VAR 0 11
38248: PUSH
38249: LD_VAR 0 3
38253: PPUSH
38254: CALL_OW 313
38258: PUSH
38259: LD_INT 6
38261: LESS
38262: AND
38263: IFFALSE 38334
// begin tmp2 := UnitsInside ( idle_lab ) ;
38265: LD_ADDR_VAR 0 9
38269: PUSH
38270: LD_VAR 0 11
38274: PPUSH
38275: CALL_OW 313
38279: ST_TO_ADDR
// if tmp2 then
38280: LD_VAR 0 9
38284: IFFALSE 38326
// for x in tmp2 do
38286: LD_ADDR_VAR 0 7
38290: PUSH
38291: LD_VAR 0 9
38295: PUSH
38296: FOR_IN
38297: IFFALSE 38324
// begin ComExitBuilding ( x ) ;
38299: LD_VAR 0 7
38303: PPUSH
38304: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38308: LD_VAR 0 7
38312: PPUSH
38313: LD_VAR 0 3
38317: PPUSH
38318: CALL_OW 180
// end ;
38322: GO 38296
38324: POP
38325: POP
// idle_lab := 0 ;
38326: LD_ADDR_VAR 0 11
38330: PUSH
38331: LD_INT 0
38333: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38334: LD_ADDR_VAR 0 5
38338: PUSH
38339: LD_EXP 122
38343: PUSH
38344: LD_VAR 0 4
38348: ARRAY
38349: PUSH
38350: FOR_IN
38351: IFFALSE 38411
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38353: LD_VAR 0 3
38357: PPUSH
38358: LD_VAR 0 5
38362: PPUSH
38363: CALL_OW 430
38367: PUSH
38368: LD_VAR 0 4
38372: PPUSH
38373: LD_VAR 0 5
38377: PPUSH
38378: CALL 52844 0 2
38382: AND
38383: IFFALSE 38409
// begin researching := true ;
38385: LD_ADDR_VAR 0 10
38389: PUSH
38390: LD_INT 1
38392: ST_TO_ADDR
// ComResearch ( j , t ) ;
38393: LD_VAR 0 3
38397: PPUSH
38398: LD_VAR 0 5
38402: PPUSH
38403: CALL_OW 124
// break ;
38407: GO 38411
// end ;
38409: GO 38350
38411: POP
38412: POP
// if not researching then
38413: LD_VAR 0 10
38417: NOT
38418: IFFALSE 38430
// idle_lab := j ;
38420: LD_ADDR_VAR 0 11
38424: PUSH
38425: LD_VAR 0 3
38429: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38430: LD_VAR 0 3
38434: PPUSH
38435: CALL_OW 461
38439: PUSH
38440: LD_INT 10
38442: EQUAL
38443: IFFALSE 39031
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38445: LD_EXP 124
38449: PUSH
38450: LD_VAR 0 2
38454: ARRAY
38455: NOT
38456: PUSH
38457: LD_EXP 125
38461: PUSH
38462: LD_VAR 0 2
38466: ARRAY
38467: NOT
38468: AND
38469: PUSH
38470: LD_EXP 122
38474: PUSH
38475: LD_VAR 0 4
38479: ARRAY
38480: PUSH
38481: LD_INT 1
38483: GREATER
38484: AND
38485: IFFALSE 38616
// begin ComCancel ( j ) ;
38487: LD_VAR 0 3
38491: PPUSH
38492: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38496: LD_ADDR_EXP 122
38500: PUSH
38501: LD_EXP 122
38505: PPUSH
38506: LD_VAR 0 4
38510: PPUSH
38511: LD_EXP 122
38515: PUSH
38516: LD_VAR 0 4
38520: ARRAY
38521: PPUSH
38522: LD_EXP 122
38526: PUSH
38527: LD_VAR 0 4
38531: ARRAY
38532: PUSH
38533: LD_INT 1
38535: MINUS
38536: PPUSH
38537: LD_EXP 122
38541: PUSH
38542: LD_VAR 0 4
38546: ARRAY
38547: PPUSH
38548: LD_INT 0
38550: PPUSH
38551: CALL 56392 0 4
38555: PPUSH
38556: CALL_OW 1
38560: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38561: LD_ADDR_EXP 122
38565: PUSH
38566: LD_EXP 122
38570: PPUSH
38571: LD_VAR 0 4
38575: PPUSH
38576: LD_EXP 122
38580: PUSH
38581: LD_VAR 0 4
38585: ARRAY
38586: PPUSH
38587: LD_EXP 122
38591: PUSH
38592: LD_VAR 0 4
38596: ARRAY
38597: PPUSH
38598: LD_INT 1
38600: PPUSH
38601: LD_INT 0
38603: PPUSH
38604: CALL 56392 0 4
38608: PPUSH
38609: CALL_OW 1
38613: ST_TO_ADDR
// continue ;
38614: GO 38188
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38616: LD_EXP 124
38620: PUSH
38621: LD_VAR 0 2
38625: ARRAY
38626: PUSH
38627: LD_EXP 125
38631: PUSH
38632: LD_VAR 0 2
38636: ARRAY
38637: NOT
38638: AND
38639: IFFALSE 38766
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38641: LD_ADDR_EXP 125
38645: PUSH
38646: LD_EXP 125
38650: PPUSH
38651: LD_VAR 0 2
38655: PUSH
38656: LD_EXP 125
38660: PUSH
38661: LD_VAR 0 2
38665: ARRAY
38666: PUSH
38667: LD_INT 1
38669: PLUS
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PPUSH
38675: LD_EXP 124
38679: PUSH
38680: LD_VAR 0 2
38684: ARRAY
38685: PUSH
38686: LD_INT 1
38688: ARRAY
38689: PPUSH
38690: CALL 56974 0 3
38694: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38695: LD_EXP 124
38699: PUSH
38700: LD_VAR 0 2
38704: ARRAY
38705: PUSH
38706: LD_INT 1
38708: ARRAY
38709: PPUSH
38710: LD_INT 112
38712: PPUSH
38713: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38717: LD_ADDR_VAR 0 9
38721: PUSH
38722: LD_EXP 124
38726: PUSH
38727: LD_VAR 0 2
38731: ARRAY
38732: PPUSH
38733: LD_INT 1
38735: PPUSH
38736: CALL_OW 3
38740: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38741: LD_ADDR_EXP 124
38745: PUSH
38746: LD_EXP 124
38750: PPUSH
38751: LD_VAR 0 2
38755: PPUSH
38756: LD_VAR 0 9
38760: PPUSH
38761: CALL_OW 1
38765: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38766: LD_EXP 124
38770: PUSH
38771: LD_VAR 0 2
38775: ARRAY
38776: PUSH
38777: LD_EXP 125
38781: PUSH
38782: LD_VAR 0 2
38786: ARRAY
38787: AND
38788: PUSH
38789: LD_EXP 125
38793: PUSH
38794: LD_VAR 0 2
38798: ARRAY
38799: PUSH
38800: LD_INT 1
38802: ARRAY
38803: PPUSH
38804: CALL_OW 310
38808: NOT
38809: AND
38810: PUSH
38811: LD_VAR 0 3
38815: PPUSH
38816: CALL_OW 313
38820: PUSH
38821: LD_INT 6
38823: EQUAL
38824: AND
38825: IFFALSE 38881
// begin tmp2 := UnitsInside ( j ) ;
38827: LD_ADDR_VAR 0 9
38831: PUSH
38832: LD_VAR 0 3
38836: PPUSH
38837: CALL_OW 313
38841: ST_TO_ADDR
// if tmp2 = 6 then
38842: LD_VAR 0 9
38846: PUSH
38847: LD_INT 6
38849: EQUAL
38850: IFFALSE 38881
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38852: LD_VAR 0 9
38856: PUSH
38857: LD_INT 1
38859: ARRAY
38860: PPUSH
38861: LD_INT 112
38863: PPUSH
38864: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38868: LD_VAR 0 9
38872: PUSH
38873: LD_INT 1
38875: ARRAY
38876: PPUSH
38877: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38881: LD_EXP 125
38885: PUSH
38886: LD_VAR 0 2
38890: ARRAY
38891: PUSH
38892: LD_EXP 125
38896: PUSH
38897: LD_VAR 0 2
38901: ARRAY
38902: PUSH
38903: LD_INT 1
38905: ARRAY
38906: PPUSH
38907: CALL_OW 314
38911: NOT
38912: AND
38913: PUSH
38914: LD_EXP 125
38918: PUSH
38919: LD_VAR 0 2
38923: ARRAY
38924: PUSH
38925: LD_INT 1
38927: ARRAY
38928: PPUSH
38929: CALL_OW 310
38933: NOT
38934: AND
38935: IFFALSE 38961
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38937: LD_EXP 125
38941: PUSH
38942: LD_VAR 0 2
38946: ARRAY
38947: PUSH
38948: LD_INT 1
38950: ARRAY
38951: PPUSH
38952: LD_VAR 0 3
38956: PPUSH
38957: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38961: LD_EXP 125
38965: PUSH
38966: LD_VAR 0 2
38970: ARRAY
38971: PUSH
38972: LD_INT 1
38974: ARRAY
38975: PPUSH
38976: CALL_OW 310
38980: PUSH
38981: LD_EXP 125
38985: PUSH
38986: LD_VAR 0 2
38990: ARRAY
38991: PUSH
38992: LD_INT 1
38994: ARRAY
38995: PPUSH
38996: CALL_OW 310
39000: PPUSH
39001: CALL_OW 461
39005: PUSH
39006: LD_INT 3
39008: NONEQUAL
39009: AND
39010: IFFALSE 39031
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39012: LD_EXP 125
39016: PUSH
39017: LD_VAR 0 2
39021: ARRAY
39022: PUSH
39023: LD_INT 1
39025: ARRAY
39026: PPUSH
39027: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39031: LD_VAR 0 3
39035: PPUSH
39036: CALL_OW 461
39040: PUSH
39041: LD_INT 6
39043: EQUAL
39044: PUSH
39045: LD_VAR 0 6
39049: PUSH
39050: LD_INT 1
39052: GREATER
39053: AND
39054: IFFALSE 39206
// begin sci := [ ] ;
39056: LD_ADDR_VAR 0 8
39060: PUSH
39061: EMPTY
39062: ST_TO_ADDR
// for x in ( tmp diff j ) do
39063: LD_ADDR_VAR 0 7
39067: PUSH
39068: LD_VAR 0 6
39072: PUSH
39073: LD_VAR 0 3
39077: DIFF
39078: PUSH
39079: FOR_IN
39080: IFFALSE 39132
// begin if sci = 6 then
39082: LD_VAR 0 8
39086: PUSH
39087: LD_INT 6
39089: EQUAL
39090: IFFALSE 39094
// break ;
39092: GO 39132
// if BuildingStatus ( x ) = bs_idle then
39094: LD_VAR 0 7
39098: PPUSH
39099: CALL_OW 461
39103: PUSH
39104: LD_INT 2
39106: EQUAL
39107: IFFALSE 39130
// sci := sci ^ UnitsInside ( x ) ;
39109: LD_ADDR_VAR 0 8
39113: PUSH
39114: LD_VAR 0 8
39118: PUSH
39119: LD_VAR 0 7
39123: PPUSH
39124: CALL_OW 313
39128: ADD
39129: ST_TO_ADDR
// end ;
39130: GO 39079
39132: POP
39133: POP
// if not sci then
39134: LD_VAR 0 8
39138: NOT
39139: IFFALSE 39143
// continue ;
39141: GO 38188
// for x in sci do
39143: LD_ADDR_VAR 0 7
39147: PUSH
39148: LD_VAR 0 8
39152: PUSH
39153: FOR_IN
39154: IFFALSE 39204
// if IsInUnit ( x ) and not HasTask ( x ) then
39156: LD_VAR 0 7
39160: PPUSH
39161: CALL_OW 310
39165: PUSH
39166: LD_VAR 0 7
39170: PPUSH
39171: CALL_OW 314
39175: NOT
39176: AND
39177: IFFALSE 39202
// begin ComExitBuilding ( x ) ;
39179: LD_VAR 0 7
39183: PPUSH
39184: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39188: LD_VAR 0 7
39192: PPUSH
39193: LD_VAR 0 3
39197: PPUSH
39198: CALL_OW 180
// end ;
39202: GO 39153
39204: POP
39205: POP
// end ; end ;
39206: GO 38188
39208: POP
39209: POP
// end ;
39210: GO 38142
39212: POP
39213: POP
// end ;
39214: LD_VAR 0 1
39218: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39219: LD_INT 0
39221: PPUSH
39222: PPUSH
// if not mc_bases then
39223: LD_EXP 95
39227: NOT
39228: IFFALSE 39232
// exit ;
39230: GO 39313
// for i = 1 to mc_bases do
39232: LD_ADDR_VAR 0 2
39236: PUSH
39237: DOUBLE
39238: LD_INT 1
39240: DEC
39241: ST_TO_ADDR
39242: LD_EXP 95
39246: PUSH
39247: FOR_TO
39248: IFFALSE 39311
// if mc_mines [ i ] and mc_miners [ i ] then
39250: LD_EXP 108
39254: PUSH
39255: LD_VAR 0 2
39259: ARRAY
39260: PUSH
39261: LD_EXP 109
39265: PUSH
39266: LD_VAR 0 2
39270: ARRAY
39271: AND
39272: IFFALSE 39309
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39274: LD_EXP 109
39278: PUSH
39279: LD_VAR 0 2
39283: ARRAY
39284: PUSH
39285: LD_INT 1
39287: ARRAY
39288: PPUSH
39289: CALL_OW 255
39293: PPUSH
39294: LD_EXP 108
39298: PUSH
39299: LD_VAR 0 2
39303: ARRAY
39304: PPUSH
39305: CALL 53927 0 2
39309: GO 39247
39311: POP
39312: POP
// end ;
39313: LD_VAR 0 1
39317: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39318: LD_INT 0
39320: PPUSH
39321: PPUSH
39322: PPUSH
39323: PPUSH
39324: PPUSH
39325: PPUSH
39326: PPUSH
39327: PPUSH
// if not mc_bases or not mc_parking then
39328: LD_EXP 95
39332: NOT
39333: PUSH
39334: LD_EXP 119
39338: NOT
39339: OR
39340: IFFALSE 39344
// exit ;
39342: GO 40054
// for i = 1 to mc_bases do
39344: LD_ADDR_VAR 0 2
39348: PUSH
39349: DOUBLE
39350: LD_INT 1
39352: DEC
39353: ST_TO_ADDR
39354: LD_EXP 95
39358: PUSH
39359: FOR_TO
39360: IFFALSE 40052
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39362: LD_EXP 95
39366: PUSH
39367: LD_VAR 0 2
39371: ARRAY
39372: NOT
39373: PUSH
39374: LD_EXP 119
39378: PUSH
39379: LD_VAR 0 2
39383: ARRAY
39384: NOT
39385: OR
39386: IFFALSE 39390
// continue ;
39388: GO 39359
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39390: LD_ADDR_VAR 0 5
39394: PUSH
39395: LD_EXP 95
39399: PUSH
39400: LD_VAR 0 2
39404: ARRAY
39405: PUSH
39406: LD_INT 1
39408: ARRAY
39409: PPUSH
39410: CALL_OW 255
39414: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39415: LD_ADDR_VAR 0 6
39419: PUSH
39420: LD_EXP 95
39424: PUSH
39425: LD_VAR 0 2
39429: ARRAY
39430: PPUSH
39431: LD_INT 30
39433: PUSH
39434: LD_INT 3
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PPUSH
39441: CALL_OW 72
39445: ST_TO_ADDR
// if not fac then
39446: LD_VAR 0 6
39450: NOT
39451: IFFALSE 39502
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39453: LD_ADDR_VAR 0 6
39457: PUSH
39458: LD_EXP 95
39462: PUSH
39463: LD_VAR 0 2
39467: ARRAY
39468: PPUSH
39469: LD_INT 2
39471: PUSH
39472: LD_INT 30
39474: PUSH
39475: LD_INT 0
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 30
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: LIST
39496: PPUSH
39497: CALL_OW 72
39501: ST_TO_ADDR
// if not fac then
39502: LD_VAR 0 6
39506: NOT
39507: IFFALSE 39511
// continue ;
39509: GO 39359
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39511: LD_ADDR_VAR 0 7
39515: PUSH
39516: LD_EXP 119
39520: PUSH
39521: LD_VAR 0 2
39525: ARRAY
39526: PPUSH
39527: LD_INT 22
39529: PUSH
39530: LD_VAR 0 5
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 21
39541: PUSH
39542: LD_INT 2
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 3
39551: PUSH
39552: LD_INT 24
39554: PUSH
39555: LD_INT 1000
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: EMPTY
39567: LIST
39568: LIST
39569: LIST
39570: PPUSH
39571: CALL_OW 70
39575: ST_TO_ADDR
// for j in fac do
39576: LD_ADDR_VAR 0 3
39580: PUSH
39581: LD_VAR 0 6
39585: PUSH
39586: FOR_IN
39587: IFFALSE 39668
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39589: LD_ADDR_VAR 0 7
39593: PUSH
39594: LD_VAR 0 7
39598: PUSH
39599: LD_INT 22
39601: PUSH
39602: LD_VAR 0 5
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: PUSH
39611: LD_INT 91
39613: PUSH
39614: LD_VAR 0 3
39618: PUSH
39619: LD_INT 15
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 21
39629: PUSH
39630: LD_INT 2
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 3
39639: PUSH
39640: LD_INT 24
39642: PUSH
39643: LD_INT 1000
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: PPUSH
39660: CALL_OW 69
39664: UNION
39665: ST_TO_ADDR
39666: GO 39586
39668: POP
39669: POP
// if not vehs then
39670: LD_VAR 0 7
39674: NOT
39675: IFFALSE 39701
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39677: LD_ADDR_EXP 107
39681: PUSH
39682: LD_EXP 107
39686: PPUSH
39687: LD_VAR 0 2
39691: PPUSH
39692: EMPTY
39693: PPUSH
39694: CALL_OW 1
39698: ST_TO_ADDR
// continue ;
39699: GO 39359
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39701: LD_ADDR_VAR 0 8
39705: PUSH
39706: LD_EXP 95
39710: PUSH
39711: LD_VAR 0 2
39715: ARRAY
39716: PPUSH
39717: LD_INT 30
39719: PUSH
39720: LD_INT 3
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PPUSH
39727: CALL_OW 72
39731: ST_TO_ADDR
// if tmp then
39732: LD_VAR 0 8
39736: IFFALSE 39839
// begin for j in tmp do
39738: LD_ADDR_VAR 0 3
39742: PUSH
39743: LD_VAR 0 8
39747: PUSH
39748: FOR_IN
39749: IFFALSE 39837
// for k in UnitsInside ( j ) do
39751: LD_ADDR_VAR 0 4
39755: PUSH
39756: LD_VAR 0 3
39760: PPUSH
39761: CALL_OW 313
39765: PUSH
39766: FOR_IN
39767: IFFALSE 39833
// if k then
39769: LD_VAR 0 4
39773: IFFALSE 39831
// if not k in mc_repair_vehicle [ i ] then
39775: LD_VAR 0 4
39779: PUSH
39780: LD_EXP 107
39784: PUSH
39785: LD_VAR 0 2
39789: ARRAY
39790: IN
39791: NOT
39792: IFFALSE 39831
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39794: LD_ADDR_EXP 107
39798: PUSH
39799: LD_EXP 107
39803: PPUSH
39804: LD_VAR 0 2
39808: PPUSH
39809: LD_EXP 107
39813: PUSH
39814: LD_VAR 0 2
39818: ARRAY
39819: PUSH
39820: LD_VAR 0 4
39824: UNION
39825: PPUSH
39826: CALL_OW 1
39830: ST_TO_ADDR
39831: GO 39766
39833: POP
39834: POP
39835: GO 39748
39837: POP
39838: POP
// end ; if not mc_repair_vehicle [ i ] then
39839: LD_EXP 107
39843: PUSH
39844: LD_VAR 0 2
39848: ARRAY
39849: NOT
39850: IFFALSE 39854
// continue ;
39852: GO 39359
// for j in mc_repair_vehicle [ i ] do
39854: LD_ADDR_VAR 0 3
39858: PUSH
39859: LD_EXP 107
39863: PUSH
39864: LD_VAR 0 2
39868: ARRAY
39869: PUSH
39870: FOR_IN
39871: IFFALSE 40048
// begin if GetClass ( j ) <> 3 then
39873: LD_VAR 0 3
39877: PPUSH
39878: CALL_OW 257
39882: PUSH
39883: LD_INT 3
39885: NONEQUAL
39886: IFFALSE 39927
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39888: LD_ADDR_EXP 107
39892: PUSH
39893: LD_EXP 107
39897: PPUSH
39898: LD_VAR 0 2
39902: PPUSH
39903: LD_EXP 107
39907: PUSH
39908: LD_VAR 0 2
39912: ARRAY
39913: PUSH
39914: LD_VAR 0 3
39918: DIFF
39919: PPUSH
39920: CALL_OW 1
39924: ST_TO_ADDR
// continue ;
39925: GO 39870
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39927: LD_VAR 0 3
39931: PPUSH
39932: CALL_OW 311
39936: NOT
39937: PUSH
39938: LD_VAR 0 3
39942: PUSH
39943: LD_EXP 98
39947: PUSH
39948: LD_VAR 0 2
39952: ARRAY
39953: PUSH
39954: LD_INT 1
39956: ARRAY
39957: IN
39958: NOT
39959: AND
39960: PUSH
39961: LD_VAR 0 3
39965: PUSH
39966: LD_EXP 98
39970: PUSH
39971: LD_VAR 0 2
39975: ARRAY
39976: PUSH
39977: LD_INT 2
39979: ARRAY
39980: IN
39981: NOT
39982: AND
39983: IFFALSE 40046
// begin if IsInUnit ( j ) then
39985: LD_VAR 0 3
39989: PPUSH
39990: CALL_OW 310
39994: IFFALSE 40007
// ComExitBuilding ( j ) else
39996: LD_VAR 0 3
40000: PPUSH
40001: CALL_OW 122
40005: GO 40046
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40007: LD_VAR 0 3
40011: PPUSH
40012: LD_VAR 0 7
40016: PUSH
40017: LD_INT 1
40019: ARRAY
40020: PPUSH
40021: CALL 90581 0 2
40025: NOT
40026: IFFALSE 40046
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40028: LD_VAR 0 3
40032: PPUSH
40033: LD_VAR 0 7
40037: PUSH
40038: LD_INT 1
40040: ARRAY
40041: PPUSH
40042: CALL_OW 129
// end ; end ;
40046: GO 39870
40048: POP
40049: POP
// end ;
40050: GO 39359
40052: POP
40053: POP
// end ;
40054: LD_VAR 0 1
40058: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40059: LD_INT 0
40061: PPUSH
40062: PPUSH
40063: PPUSH
40064: PPUSH
40065: PPUSH
40066: PPUSH
40067: PPUSH
40068: PPUSH
40069: PPUSH
40070: PPUSH
40071: PPUSH
// if not mc_bases then
40072: LD_EXP 95
40076: NOT
40077: IFFALSE 40081
// exit ;
40079: GO 40883
// for i = 1 to mc_bases do
40081: LD_ADDR_VAR 0 2
40085: PUSH
40086: DOUBLE
40087: LD_INT 1
40089: DEC
40090: ST_TO_ADDR
40091: LD_EXP 95
40095: PUSH
40096: FOR_TO
40097: IFFALSE 40881
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40099: LD_EXP 123
40103: PUSH
40104: LD_VAR 0 2
40108: ARRAY
40109: NOT
40110: PUSH
40111: LD_EXP 98
40115: PUSH
40116: LD_VAR 0 2
40120: ARRAY
40121: PUSH
40122: LD_INT 1
40124: ARRAY
40125: OR
40126: PUSH
40127: LD_EXP 98
40131: PUSH
40132: LD_VAR 0 2
40136: ARRAY
40137: PUSH
40138: LD_INT 2
40140: ARRAY
40141: OR
40142: PUSH
40143: LD_EXP 121
40147: PUSH
40148: LD_VAR 0 2
40152: ARRAY
40153: PPUSH
40154: LD_INT 1
40156: PPUSH
40157: CALL_OW 325
40161: NOT
40162: OR
40163: PUSH
40164: LD_EXP 118
40168: PUSH
40169: LD_VAR 0 2
40173: ARRAY
40174: OR
40175: IFFALSE 40179
// continue ;
40177: GO 40096
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40179: LD_ADDR_VAR 0 8
40183: PUSH
40184: LD_EXP 95
40188: PUSH
40189: LD_VAR 0 2
40193: ARRAY
40194: PPUSH
40195: LD_INT 25
40197: PUSH
40198: LD_INT 4
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 50
40207: PUSH
40208: EMPTY
40209: LIST
40210: PUSH
40211: LD_INT 3
40213: PUSH
40214: LD_INT 60
40216: PUSH
40217: EMPTY
40218: LIST
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: LIST
40228: PPUSH
40229: CALL_OW 72
40233: PUSH
40234: LD_EXP 99
40238: PUSH
40239: LD_VAR 0 2
40243: ARRAY
40244: DIFF
40245: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40246: LD_ADDR_VAR 0 9
40250: PUSH
40251: LD_EXP 95
40255: PUSH
40256: LD_VAR 0 2
40260: ARRAY
40261: PPUSH
40262: LD_INT 2
40264: PUSH
40265: LD_INT 30
40267: PUSH
40268: LD_INT 0
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 30
40277: PUSH
40278: LD_INT 1
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: LIST
40289: PPUSH
40290: CALL_OW 72
40294: ST_TO_ADDR
// if not tmp or not dep then
40295: LD_VAR 0 8
40299: NOT
40300: PUSH
40301: LD_VAR 0 9
40305: NOT
40306: OR
40307: IFFALSE 40311
// continue ;
40309: GO 40096
// side := GetSide ( tmp [ 1 ] ) ;
40311: LD_ADDR_VAR 0 11
40315: PUSH
40316: LD_VAR 0 8
40320: PUSH
40321: LD_INT 1
40323: ARRAY
40324: PPUSH
40325: CALL_OW 255
40329: ST_TO_ADDR
// dep := dep [ 1 ] ;
40330: LD_ADDR_VAR 0 9
40334: PUSH
40335: LD_VAR 0 9
40339: PUSH
40340: LD_INT 1
40342: ARRAY
40343: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40344: LD_ADDR_VAR 0 7
40348: PUSH
40349: LD_EXP 123
40353: PUSH
40354: LD_VAR 0 2
40358: ARRAY
40359: PPUSH
40360: LD_INT 22
40362: PUSH
40363: LD_INT 0
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 25
40372: PUSH
40373: LD_INT 12
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PPUSH
40384: CALL_OW 70
40388: PUSH
40389: LD_INT 22
40391: PUSH
40392: LD_INT 0
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 25
40401: PUSH
40402: LD_INT 12
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 91
40411: PUSH
40412: LD_VAR 0 9
40416: PUSH
40417: LD_INT 20
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: LIST
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: LIST
40429: PPUSH
40430: CALL_OW 69
40434: UNION
40435: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40436: LD_ADDR_VAR 0 10
40440: PUSH
40441: LD_EXP 123
40445: PUSH
40446: LD_VAR 0 2
40450: ARRAY
40451: PPUSH
40452: LD_INT 81
40454: PUSH
40455: LD_VAR 0 11
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PPUSH
40464: CALL_OW 70
40468: ST_TO_ADDR
// if not apes or danger_at_area then
40469: LD_VAR 0 7
40473: NOT
40474: PUSH
40475: LD_VAR 0 10
40479: OR
40480: IFFALSE 40530
// begin if mc_taming [ i ] then
40482: LD_EXP 126
40486: PUSH
40487: LD_VAR 0 2
40491: ARRAY
40492: IFFALSE 40528
// begin MC_Reset ( i , 121 ) ;
40494: LD_VAR 0 2
40498: PPUSH
40499: LD_INT 121
40501: PPUSH
40502: CALL 25516 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40506: LD_ADDR_EXP 126
40510: PUSH
40511: LD_EXP 126
40515: PPUSH
40516: LD_VAR 0 2
40520: PPUSH
40521: EMPTY
40522: PPUSH
40523: CALL_OW 1
40527: ST_TO_ADDR
// end ; continue ;
40528: GO 40096
// end ; for j in tmp do
40530: LD_ADDR_VAR 0 3
40534: PUSH
40535: LD_VAR 0 8
40539: PUSH
40540: FOR_IN
40541: IFFALSE 40877
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40543: LD_VAR 0 3
40547: PUSH
40548: LD_EXP 126
40552: PUSH
40553: LD_VAR 0 2
40557: ARRAY
40558: IN
40559: NOT
40560: PUSH
40561: LD_EXP 126
40565: PUSH
40566: LD_VAR 0 2
40570: ARRAY
40571: PUSH
40572: LD_INT 3
40574: LESS
40575: AND
40576: IFFALSE 40634
// begin SetTag ( j , 121 ) ;
40578: LD_VAR 0 3
40582: PPUSH
40583: LD_INT 121
40585: PPUSH
40586: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40590: LD_ADDR_EXP 126
40594: PUSH
40595: LD_EXP 126
40599: PPUSH
40600: LD_VAR 0 2
40604: PUSH
40605: LD_EXP 126
40609: PUSH
40610: LD_VAR 0 2
40614: ARRAY
40615: PUSH
40616: LD_INT 1
40618: PLUS
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PPUSH
40624: LD_VAR 0 3
40628: PPUSH
40629: CALL 56974 0 3
40633: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40634: LD_VAR 0 3
40638: PUSH
40639: LD_EXP 126
40643: PUSH
40644: LD_VAR 0 2
40648: ARRAY
40649: IN
40650: IFFALSE 40875
// begin if GetClass ( j ) <> 4 then
40652: LD_VAR 0 3
40656: PPUSH
40657: CALL_OW 257
40661: PUSH
40662: LD_INT 4
40664: NONEQUAL
40665: IFFALSE 40718
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40667: LD_ADDR_EXP 126
40671: PUSH
40672: LD_EXP 126
40676: PPUSH
40677: LD_VAR 0 2
40681: PPUSH
40682: LD_EXP 126
40686: PUSH
40687: LD_VAR 0 2
40691: ARRAY
40692: PUSH
40693: LD_VAR 0 3
40697: DIFF
40698: PPUSH
40699: CALL_OW 1
40703: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40704: LD_VAR 0 3
40708: PPUSH
40709: LD_INT 0
40711: PPUSH
40712: CALL_OW 109
// continue ;
40716: GO 40540
// end ; if IsInUnit ( j ) then
40718: LD_VAR 0 3
40722: PPUSH
40723: CALL_OW 310
40727: IFFALSE 40738
// ComExitBuilding ( j ) ;
40729: LD_VAR 0 3
40733: PPUSH
40734: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40738: LD_ADDR_VAR 0 6
40742: PUSH
40743: LD_VAR 0 7
40747: PPUSH
40748: LD_VAR 0 3
40752: PPUSH
40753: CALL_OW 74
40757: ST_TO_ADDR
// if not ape then
40758: LD_VAR 0 6
40762: NOT
40763: IFFALSE 40767
// break ;
40765: GO 40877
// x := GetX ( ape ) ;
40767: LD_ADDR_VAR 0 4
40771: PUSH
40772: LD_VAR 0 6
40776: PPUSH
40777: CALL_OW 250
40781: ST_TO_ADDR
// y := GetY ( ape ) ;
40782: LD_ADDR_VAR 0 5
40786: PUSH
40787: LD_VAR 0 6
40791: PPUSH
40792: CALL_OW 251
40796: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40797: LD_VAR 0 4
40801: PPUSH
40802: LD_VAR 0 5
40806: PPUSH
40807: CALL_OW 488
40811: NOT
40812: PUSH
40813: LD_VAR 0 11
40817: PPUSH
40818: LD_VAR 0 4
40822: PPUSH
40823: LD_VAR 0 5
40827: PPUSH
40828: LD_INT 20
40830: PPUSH
40831: CALL 57870 0 4
40835: PUSH
40836: LD_INT 4
40838: ARRAY
40839: OR
40840: IFFALSE 40844
// break ;
40842: GO 40877
// if not HasTask ( j ) then
40844: LD_VAR 0 3
40848: PPUSH
40849: CALL_OW 314
40853: NOT
40854: IFFALSE 40875
// ComTameXY ( j , x , y ) ;
40856: LD_VAR 0 3
40860: PPUSH
40861: LD_VAR 0 4
40865: PPUSH
40866: LD_VAR 0 5
40870: PPUSH
40871: CALL_OW 131
// end ; end ;
40875: GO 40540
40877: POP
40878: POP
// end ;
40879: GO 40096
40881: POP
40882: POP
// end ;
40883: LD_VAR 0 1
40887: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40888: LD_INT 0
40890: PPUSH
40891: PPUSH
40892: PPUSH
40893: PPUSH
40894: PPUSH
40895: PPUSH
40896: PPUSH
40897: PPUSH
// if not mc_bases then
40898: LD_EXP 95
40902: NOT
40903: IFFALSE 40907
// exit ;
40905: GO 41533
// for i = 1 to mc_bases do
40907: LD_ADDR_VAR 0 2
40911: PUSH
40912: DOUBLE
40913: LD_INT 1
40915: DEC
40916: ST_TO_ADDR
40917: LD_EXP 95
40921: PUSH
40922: FOR_TO
40923: IFFALSE 41531
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40925: LD_EXP 124
40929: PUSH
40930: LD_VAR 0 2
40934: ARRAY
40935: NOT
40936: PUSH
40937: LD_EXP 124
40941: PUSH
40942: LD_VAR 0 2
40946: ARRAY
40947: PPUSH
40948: LD_INT 25
40950: PUSH
40951: LD_INT 12
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PPUSH
40958: CALL_OW 72
40962: NOT
40963: OR
40964: IFFALSE 40968
// continue ;
40966: GO 40922
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40968: LD_ADDR_VAR 0 5
40972: PUSH
40973: LD_EXP 124
40977: PUSH
40978: LD_VAR 0 2
40982: ARRAY
40983: PUSH
40984: LD_INT 1
40986: ARRAY
40987: PPUSH
40988: CALL_OW 255
40992: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40993: LD_VAR 0 5
40997: PPUSH
40998: LD_INT 2
41000: PPUSH
41001: CALL_OW 325
41005: IFFALSE 41258
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41007: LD_ADDR_VAR 0 4
41011: PUSH
41012: LD_EXP 124
41016: PUSH
41017: LD_VAR 0 2
41021: ARRAY
41022: PPUSH
41023: LD_INT 25
41025: PUSH
41026: LD_INT 16
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PPUSH
41033: CALL_OW 72
41037: ST_TO_ADDR
// if tmp < 6 then
41038: LD_VAR 0 4
41042: PUSH
41043: LD_INT 6
41045: LESS
41046: IFFALSE 41258
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41048: LD_ADDR_VAR 0 6
41052: PUSH
41053: LD_EXP 95
41057: PUSH
41058: LD_VAR 0 2
41062: ARRAY
41063: PPUSH
41064: LD_INT 2
41066: PUSH
41067: LD_INT 30
41069: PUSH
41070: LD_INT 0
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: LD_INT 30
41079: PUSH
41080: LD_INT 1
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: LIST
41091: PPUSH
41092: CALL_OW 72
41096: ST_TO_ADDR
// if depot then
41097: LD_VAR 0 6
41101: IFFALSE 41258
// begin selected := 0 ;
41103: LD_ADDR_VAR 0 7
41107: PUSH
41108: LD_INT 0
41110: ST_TO_ADDR
// for j in depot do
41111: LD_ADDR_VAR 0 3
41115: PUSH
41116: LD_VAR 0 6
41120: PUSH
41121: FOR_IN
41122: IFFALSE 41153
// begin if UnitsInside ( j ) < 6 then
41124: LD_VAR 0 3
41128: PPUSH
41129: CALL_OW 313
41133: PUSH
41134: LD_INT 6
41136: LESS
41137: IFFALSE 41151
// begin selected := j ;
41139: LD_ADDR_VAR 0 7
41143: PUSH
41144: LD_VAR 0 3
41148: ST_TO_ADDR
// break ;
41149: GO 41153
// end ; end ;
41151: GO 41121
41153: POP
41154: POP
// if selected then
41155: LD_VAR 0 7
41159: IFFALSE 41258
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41161: LD_ADDR_VAR 0 3
41165: PUSH
41166: LD_EXP 124
41170: PUSH
41171: LD_VAR 0 2
41175: ARRAY
41176: PPUSH
41177: LD_INT 25
41179: PUSH
41180: LD_INT 12
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PPUSH
41187: CALL_OW 72
41191: PUSH
41192: FOR_IN
41193: IFFALSE 41256
// if not HasTask ( j ) then
41195: LD_VAR 0 3
41199: PPUSH
41200: CALL_OW 314
41204: NOT
41205: IFFALSE 41254
// begin if not IsInUnit ( j ) then
41207: LD_VAR 0 3
41211: PPUSH
41212: CALL_OW 310
41216: NOT
41217: IFFALSE 41233
// ComEnterUnit ( j , selected ) ;
41219: LD_VAR 0 3
41223: PPUSH
41224: LD_VAR 0 7
41228: PPUSH
41229: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41233: LD_VAR 0 3
41237: PPUSH
41238: LD_INT 16
41240: PPUSH
41241: CALL_OW 183
// AddComExitBuilding ( j ) ;
41245: LD_VAR 0 3
41249: PPUSH
41250: CALL_OW 182
// end ;
41254: GO 41192
41256: POP
41257: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41258: LD_VAR 0 5
41262: PPUSH
41263: LD_INT 11
41265: PPUSH
41266: CALL_OW 325
41270: IFFALSE 41529
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41272: LD_ADDR_VAR 0 4
41276: PUSH
41277: LD_EXP 124
41281: PUSH
41282: LD_VAR 0 2
41286: ARRAY
41287: PPUSH
41288: LD_INT 25
41290: PUSH
41291: LD_INT 16
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PPUSH
41298: CALL_OW 72
41302: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41303: LD_VAR 0 4
41307: PUSH
41308: LD_INT 6
41310: GREATEREQUAL
41311: PUSH
41312: LD_VAR 0 5
41316: PPUSH
41317: LD_INT 2
41319: PPUSH
41320: CALL_OW 325
41324: NOT
41325: OR
41326: IFFALSE 41529
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41328: LD_ADDR_VAR 0 8
41332: PUSH
41333: LD_EXP 95
41337: PUSH
41338: LD_VAR 0 2
41342: ARRAY
41343: PPUSH
41344: LD_INT 2
41346: PUSH
41347: LD_INT 30
41349: PUSH
41350: LD_INT 4
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 30
41359: PUSH
41360: LD_INT 5
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: LIST
41371: PPUSH
41372: CALL_OW 72
41376: ST_TO_ADDR
// if barracks then
41377: LD_VAR 0 8
41381: IFFALSE 41529
// begin selected := 0 ;
41383: LD_ADDR_VAR 0 7
41387: PUSH
41388: LD_INT 0
41390: ST_TO_ADDR
// for j in barracks do
41391: LD_ADDR_VAR 0 3
41395: PUSH
41396: LD_VAR 0 8
41400: PUSH
41401: FOR_IN
41402: IFFALSE 41433
// begin if UnitsInside ( j ) < 6 then
41404: LD_VAR 0 3
41408: PPUSH
41409: CALL_OW 313
41413: PUSH
41414: LD_INT 6
41416: LESS
41417: IFFALSE 41431
// begin selected := j ;
41419: LD_ADDR_VAR 0 7
41423: PUSH
41424: LD_VAR 0 3
41428: ST_TO_ADDR
// break ;
41429: GO 41433
// end ; end ;
41431: GO 41401
41433: POP
41434: POP
// if selected then
41435: LD_VAR 0 7
41439: IFFALSE 41529
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41441: LD_ADDR_VAR 0 3
41445: PUSH
41446: LD_EXP 124
41450: PUSH
41451: LD_VAR 0 2
41455: ARRAY
41456: PPUSH
41457: LD_INT 25
41459: PUSH
41460: LD_INT 12
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PPUSH
41467: CALL_OW 72
41471: PUSH
41472: FOR_IN
41473: IFFALSE 41527
// if not IsInUnit ( j ) and not HasTask ( j ) then
41475: LD_VAR 0 3
41479: PPUSH
41480: CALL_OW 310
41484: NOT
41485: PUSH
41486: LD_VAR 0 3
41490: PPUSH
41491: CALL_OW 314
41495: NOT
41496: AND
41497: IFFALSE 41525
// begin ComEnterUnit ( j , selected ) ;
41499: LD_VAR 0 3
41503: PPUSH
41504: LD_VAR 0 7
41508: PPUSH
41509: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41513: LD_VAR 0 3
41517: PPUSH
41518: LD_INT 15
41520: PPUSH
41521: CALL_OW 183
// end ;
41525: GO 41472
41527: POP
41528: POP
// end ; end ; end ; end ; end ;
41529: GO 40922
41531: POP
41532: POP
// end ;
41533: LD_VAR 0 1
41537: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41538: LD_INT 0
41540: PPUSH
41541: PPUSH
41542: PPUSH
41543: PPUSH
// if not mc_bases then
41544: LD_EXP 95
41548: NOT
41549: IFFALSE 41553
// exit ;
41551: GO 41731
// for i = 1 to mc_bases do
41553: LD_ADDR_VAR 0 2
41557: PUSH
41558: DOUBLE
41559: LD_INT 1
41561: DEC
41562: ST_TO_ADDR
41563: LD_EXP 95
41567: PUSH
41568: FOR_TO
41569: IFFALSE 41729
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41571: LD_ADDR_VAR 0 4
41575: PUSH
41576: LD_EXP 95
41580: PUSH
41581: LD_VAR 0 2
41585: ARRAY
41586: PPUSH
41587: LD_INT 25
41589: PUSH
41590: LD_INT 9
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PPUSH
41597: CALL_OW 72
41601: ST_TO_ADDR
// if not tmp then
41602: LD_VAR 0 4
41606: NOT
41607: IFFALSE 41611
// continue ;
41609: GO 41568
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41611: LD_EXP 121
41615: PUSH
41616: LD_VAR 0 2
41620: ARRAY
41621: PPUSH
41622: LD_INT 29
41624: PPUSH
41625: CALL_OW 325
41629: NOT
41630: PUSH
41631: LD_EXP 121
41635: PUSH
41636: LD_VAR 0 2
41640: ARRAY
41641: PPUSH
41642: LD_INT 28
41644: PPUSH
41645: CALL_OW 325
41649: NOT
41650: AND
41651: IFFALSE 41655
// continue ;
41653: GO 41568
// for j in tmp do
41655: LD_ADDR_VAR 0 3
41659: PUSH
41660: LD_VAR 0 4
41664: PUSH
41665: FOR_IN
41666: IFFALSE 41725
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41668: LD_VAR 0 3
41672: PUSH
41673: LD_EXP 98
41677: PUSH
41678: LD_VAR 0 2
41682: ARRAY
41683: PUSH
41684: LD_INT 1
41686: ARRAY
41687: IN
41688: NOT
41689: PUSH
41690: LD_VAR 0 3
41694: PUSH
41695: LD_EXP 98
41699: PUSH
41700: LD_VAR 0 2
41704: ARRAY
41705: PUSH
41706: LD_INT 2
41708: ARRAY
41709: IN
41710: NOT
41711: AND
41712: IFFALSE 41723
// ComSpaceTimeShoot ( j ) ;
41714: LD_VAR 0 3
41718: PPUSH
41719: CALL 52935 0 1
41723: GO 41665
41725: POP
41726: POP
// end ;
41727: GO 41568
41729: POP
41730: POP
// end ;
41731: LD_VAR 0 1
41735: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41736: LD_INT 0
41738: PPUSH
41739: PPUSH
41740: PPUSH
41741: PPUSH
41742: PPUSH
41743: PPUSH
41744: PPUSH
41745: PPUSH
41746: PPUSH
// if not mc_bases then
41747: LD_EXP 95
41751: NOT
41752: IFFALSE 41756
// exit ;
41754: GO 42378
// for i = 1 to mc_bases do
41756: LD_ADDR_VAR 0 2
41760: PUSH
41761: DOUBLE
41762: LD_INT 1
41764: DEC
41765: ST_TO_ADDR
41766: LD_EXP 95
41770: PUSH
41771: FOR_TO
41772: IFFALSE 42376
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41774: LD_EXP 130
41778: PUSH
41779: LD_VAR 0 2
41783: ARRAY
41784: NOT
41785: PUSH
41786: LD_INT 38
41788: PPUSH
41789: LD_EXP 121
41793: PUSH
41794: LD_VAR 0 2
41798: ARRAY
41799: PPUSH
41800: CALL_OW 321
41804: PUSH
41805: LD_INT 2
41807: NONEQUAL
41808: OR
41809: IFFALSE 41813
// continue ;
41811: GO 41771
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41813: LD_ADDR_VAR 0 8
41817: PUSH
41818: LD_EXP 95
41822: PUSH
41823: LD_VAR 0 2
41827: ARRAY
41828: PPUSH
41829: LD_INT 30
41831: PUSH
41832: LD_INT 34
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PPUSH
41839: CALL_OW 72
41843: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41844: LD_ADDR_VAR 0 9
41848: PUSH
41849: LD_EXP 95
41853: PUSH
41854: LD_VAR 0 2
41858: ARRAY
41859: PPUSH
41860: LD_INT 25
41862: PUSH
41863: LD_INT 4
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PPUSH
41870: CALL_OW 72
41874: PPUSH
41875: LD_INT 0
41877: PPUSH
41878: CALL 86243 0 2
41882: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41883: LD_VAR 0 9
41887: NOT
41888: PUSH
41889: LD_VAR 0 8
41893: NOT
41894: OR
41895: PUSH
41896: LD_EXP 95
41900: PUSH
41901: LD_VAR 0 2
41905: ARRAY
41906: PPUSH
41907: LD_INT 124
41909: PPUSH
41910: CALL 86243 0 2
41914: OR
41915: IFFALSE 41919
// continue ;
41917: GO 41771
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41919: LD_EXP 131
41923: PUSH
41924: LD_VAR 0 2
41928: ARRAY
41929: PUSH
41930: LD_EXP 130
41934: PUSH
41935: LD_VAR 0 2
41939: ARRAY
41940: LESS
41941: PUSH
41942: LD_EXP 131
41946: PUSH
41947: LD_VAR 0 2
41951: ARRAY
41952: PUSH
41953: LD_VAR 0 8
41957: LESS
41958: AND
41959: IFFALSE 42374
// begin tmp := sci [ 1 ] ;
41961: LD_ADDR_VAR 0 7
41965: PUSH
41966: LD_VAR 0 9
41970: PUSH
41971: LD_INT 1
41973: ARRAY
41974: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41975: LD_VAR 0 7
41979: PPUSH
41980: LD_INT 124
41982: PPUSH
41983: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41987: LD_ADDR_VAR 0 3
41991: PUSH
41992: DOUBLE
41993: LD_EXP 130
41997: PUSH
41998: LD_VAR 0 2
42002: ARRAY
42003: INC
42004: ST_TO_ADDR
42005: LD_EXP 130
42009: PUSH
42010: LD_VAR 0 2
42014: ARRAY
42015: PUSH
42016: FOR_DOWNTO
42017: IFFALSE 42360
// begin if IsInUnit ( tmp ) then
42019: LD_VAR 0 7
42023: PPUSH
42024: CALL_OW 310
42028: IFFALSE 42039
// ComExitBuilding ( tmp ) ;
42030: LD_VAR 0 7
42034: PPUSH
42035: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42039: LD_INT 35
42041: PPUSH
42042: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42046: LD_VAR 0 7
42050: PPUSH
42051: CALL_OW 310
42055: NOT
42056: PUSH
42057: LD_VAR 0 7
42061: PPUSH
42062: CALL_OW 314
42066: NOT
42067: AND
42068: IFFALSE 42039
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42070: LD_ADDR_VAR 0 6
42074: PUSH
42075: LD_VAR 0 7
42079: PPUSH
42080: CALL_OW 250
42084: PUSH
42085: LD_VAR 0 7
42089: PPUSH
42090: CALL_OW 251
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42099: LD_INT 35
42101: PPUSH
42102: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42106: LD_ADDR_VAR 0 4
42110: PUSH
42111: LD_EXP 130
42115: PUSH
42116: LD_VAR 0 2
42120: ARRAY
42121: PUSH
42122: LD_VAR 0 3
42126: ARRAY
42127: PUSH
42128: LD_INT 1
42130: ARRAY
42131: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42132: LD_ADDR_VAR 0 5
42136: PUSH
42137: LD_EXP 130
42141: PUSH
42142: LD_VAR 0 2
42146: ARRAY
42147: PUSH
42148: LD_VAR 0 3
42152: ARRAY
42153: PUSH
42154: LD_INT 2
42156: ARRAY
42157: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42158: LD_VAR 0 7
42162: PPUSH
42163: LD_INT 10
42165: PPUSH
42166: CALL 59573 0 2
42170: PUSH
42171: LD_INT 4
42173: ARRAY
42174: IFFALSE 42212
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42176: LD_VAR 0 7
42180: PPUSH
42181: LD_VAR 0 6
42185: PUSH
42186: LD_INT 1
42188: ARRAY
42189: PPUSH
42190: LD_VAR 0 6
42194: PUSH
42195: LD_INT 2
42197: ARRAY
42198: PPUSH
42199: CALL_OW 111
// wait ( 0 0$10 ) ;
42203: LD_INT 350
42205: PPUSH
42206: CALL_OW 67
// end else
42210: GO 42238
// begin ComMoveXY ( tmp , x , y ) ;
42212: LD_VAR 0 7
42216: PPUSH
42217: LD_VAR 0 4
42221: PPUSH
42222: LD_VAR 0 5
42226: PPUSH
42227: CALL_OW 111
// wait ( 0 0$3 ) ;
42231: LD_INT 105
42233: PPUSH
42234: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42238: LD_VAR 0 7
42242: PPUSH
42243: LD_VAR 0 4
42247: PPUSH
42248: LD_VAR 0 5
42252: PPUSH
42253: CALL_OW 307
42257: IFFALSE 42099
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42259: LD_VAR 0 7
42263: PPUSH
42264: LD_VAR 0 4
42268: PPUSH
42269: LD_VAR 0 5
42273: PPUSH
42274: LD_VAR 0 8
42278: PUSH
42279: LD_VAR 0 3
42283: ARRAY
42284: PPUSH
42285: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42289: LD_INT 35
42291: PPUSH
42292: CALL_OW 67
// until not HasTask ( tmp ) ;
42296: LD_VAR 0 7
42300: PPUSH
42301: CALL_OW 314
42305: NOT
42306: IFFALSE 42289
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42308: LD_ADDR_EXP 131
42312: PUSH
42313: LD_EXP 131
42317: PPUSH
42318: LD_VAR 0 2
42322: PUSH
42323: LD_EXP 131
42327: PUSH
42328: LD_VAR 0 2
42332: ARRAY
42333: PUSH
42334: LD_INT 1
42336: PLUS
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PPUSH
42342: LD_VAR 0 8
42346: PUSH
42347: LD_VAR 0 3
42351: ARRAY
42352: PPUSH
42353: CALL 56974 0 3
42357: ST_TO_ADDR
// end ;
42358: GO 42016
42360: POP
42361: POP
// MC_Reset ( i , 124 ) ;
42362: LD_VAR 0 2
42366: PPUSH
42367: LD_INT 124
42369: PPUSH
42370: CALL 25516 0 2
// end ; end ;
42374: GO 41771
42376: POP
42377: POP
// end ;
42378: LD_VAR 0 1
42382: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42383: LD_INT 0
42385: PPUSH
42386: PPUSH
42387: PPUSH
// if not mc_bases then
42388: LD_EXP 95
42392: NOT
42393: IFFALSE 42397
// exit ;
42395: GO 43003
// for i = 1 to mc_bases do
42397: LD_ADDR_VAR 0 2
42401: PUSH
42402: DOUBLE
42403: LD_INT 1
42405: DEC
42406: ST_TO_ADDR
42407: LD_EXP 95
42411: PUSH
42412: FOR_TO
42413: IFFALSE 43001
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42415: LD_ADDR_VAR 0 3
42419: PUSH
42420: LD_EXP 95
42424: PUSH
42425: LD_VAR 0 2
42429: ARRAY
42430: PPUSH
42431: LD_INT 25
42433: PUSH
42434: LD_INT 4
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PPUSH
42441: CALL_OW 72
42445: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42446: LD_VAR 0 3
42450: NOT
42451: PUSH
42452: LD_EXP 132
42456: PUSH
42457: LD_VAR 0 2
42461: ARRAY
42462: NOT
42463: OR
42464: PUSH
42465: LD_EXP 95
42469: PUSH
42470: LD_VAR 0 2
42474: ARRAY
42475: PPUSH
42476: LD_INT 2
42478: PUSH
42479: LD_INT 30
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 30
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: LIST
42503: PPUSH
42504: CALL_OW 72
42508: NOT
42509: OR
42510: IFFALSE 42560
// begin if mc_deposits_finder [ i ] then
42512: LD_EXP 133
42516: PUSH
42517: LD_VAR 0 2
42521: ARRAY
42522: IFFALSE 42558
// begin MC_Reset ( i , 125 ) ;
42524: LD_VAR 0 2
42528: PPUSH
42529: LD_INT 125
42531: PPUSH
42532: CALL 25516 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42536: LD_ADDR_EXP 133
42540: PUSH
42541: LD_EXP 133
42545: PPUSH
42546: LD_VAR 0 2
42550: PPUSH
42551: EMPTY
42552: PPUSH
42553: CALL_OW 1
42557: ST_TO_ADDR
// end ; continue ;
42558: GO 42412
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42560: LD_EXP 132
42564: PUSH
42565: LD_VAR 0 2
42569: ARRAY
42570: PUSH
42571: LD_INT 1
42573: ARRAY
42574: PUSH
42575: LD_INT 3
42577: ARRAY
42578: PUSH
42579: LD_INT 1
42581: EQUAL
42582: PUSH
42583: LD_INT 20
42585: PPUSH
42586: LD_EXP 121
42590: PUSH
42591: LD_VAR 0 2
42595: ARRAY
42596: PPUSH
42597: CALL_OW 321
42601: PUSH
42602: LD_INT 2
42604: NONEQUAL
42605: AND
42606: IFFALSE 42656
// begin if mc_deposits_finder [ i ] then
42608: LD_EXP 133
42612: PUSH
42613: LD_VAR 0 2
42617: ARRAY
42618: IFFALSE 42654
// begin MC_Reset ( i , 125 ) ;
42620: LD_VAR 0 2
42624: PPUSH
42625: LD_INT 125
42627: PPUSH
42628: CALL 25516 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42632: LD_ADDR_EXP 133
42636: PUSH
42637: LD_EXP 133
42641: PPUSH
42642: LD_VAR 0 2
42646: PPUSH
42647: EMPTY
42648: PPUSH
42649: CALL_OW 1
42653: ST_TO_ADDR
// end ; continue ;
42654: GO 42412
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42656: LD_EXP 132
42660: PUSH
42661: LD_VAR 0 2
42665: ARRAY
42666: PUSH
42667: LD_INT 1
42669: ARRAY
42670: PUSH
42671: LD_INT 1
42673: ARRAY
42674: PPUSH
42675: LD_EXP 132
42679: PUSH
42680: LD_VAR 0 2
42684: ARRAY
42685: PUSH
42686: LD_INT 1
42688: ARRAY
42689: PUSH
42690: LD_INT 2
42692: ARRAY
42693: PPUSH
42694: LD_EXP 121
42698: PUSH
42699: LD_VAR 0 2
42703: ARRAY
42704: PPUSH
42705: CALL_OW 440
42709: IFFALSE 42752
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42711: LD_ADDR_EXP 132
42715: PUSH
42716: LD_EXP 132
42720: PPUSH
42721: LD_VAR 0 2
42725: PPUSH
42726: LD_EXP 132
42730: PUSH
42731: LD_VAR 0 2
42735: ARRAY
42736: PPUSH
42737: LD_INT 1
42739: PPUSH
42740: CALL_OW 3
42744: PPUSH
42745: CALL_OW 1
42749: ST_TO_ADDR
42750: GO 42999
// begin if not mc_deposits_finder [ i ] then
42752: LD_EXP 133
42756: PUSH
42757: LD_VAR 0 2
42761: ARRAY
42762: NOT
42763: IFFALSE 42815
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42765: LD_ADDR_EXP 133
42769: PUSH
42770: LD_EXP 133
42774: PPUSH
42775: LD_VAR 0 2
42779: PPUSH
42780: LD_VAR 0 3
42784: PUSH
42785: LD_INT 1
42787: ARRAY
42788: PUSH
42789: EMPTY
42790: LIST
42791: PPUSH
42792: CALL_OW 1
42796: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42797: LD_VAR 0 3
42801: PUSH
42802: LD_INT 1
42804: ARRAY
42805: PPUSH
42806: LD_INT 125
42808: PPUSH
42809: CALL_OW 109
// end else
42813: GO 42999
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42815: LD_EXP 133
42819: PUSH
42820: LD_VAR 0 2
42824: ARRAY
42825: PUSH
42826: LD_INT 1
42828: ARRAY
42829: PPUSH
42830: CALL_OW 310
42834: IFFALSE 42857
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42836: LD_EXP 133
42840: PUSH
42841: LD_VAR 0 2
42845: ARRAY
42846: PUSH
42847: LD_INT 1
42849: ARRAY
42850: PPUSH
42851: CALL_OW 122
42855: GO 42999
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42857: LD_EXP 133
42861: PUSH
42862: LD_VAR 0 2
42866: ARRAY
42867: PUSH
42868: LD_INT 1
42870: ARRAY
42871: PPUSH
42872: CALL_OW 314
42876: NOT
42877: PUSH
42878: LD_EXP 133
42882: PUSH
42883: LD_VAR 0 2
42887: ARRAY
42888: PUSH
42889: LD_INT 1
42891: ARRAY
42892: PPUSH
42893: LD_EXP 132
42897: PUSH
42898: LD_VAR 0 2
42902: ARRAY
42903: PUSH
42904: LD_INT 1
42906: ARRAY
42907: PUSH
42908: LD_INT 1
42910: ARRAY
42911: PPUSH
42912: LD_EXP 132
42916: PUSH
42917: LD_VAR 0 2
42921: ARRAY
42922: PUSH
42923: LD_INT 1
42925: ARRAY
42926: PUSH
42927: LD_INT 2
42929: ARRAY
42930: PPUSH
42931: CALL_OW 297
42935: PUSH
42936: LD_INT 6
42938: GREATER
42939: AND
42940: IFFALSE 42999
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42942: LD_EXP 133
42946: PUSH
42947: LD_VAR 0 2
42951: ARRAY
42952: PUSH
42953: LD_INT 1
42955: ARRAY
42956: PPUSH
42957: LD_EXP 132
42961: PUSH
42962: LD_VAR 0 2
42966: ARRAY
42967: PUSH
42968: LD_INT 1
42970: ARRAY
42971: PUSH
42972: LD_INT 1
42974: ARRAY
42975: PPUSH
42976: LD_EXP 132
42980: PUSH
42981: LD_VAR 0 2
42985: ARRAY
42986: PUSH
42987: LD_INT 1
42989: ARRAY
42990: PUSH
42991: LD_INT 2
42993: ARRAY
42994: PPUSH
42995: CALL_OW 111
// end ; end ; end ;
42999: GO 42412
43001: POP
43002: POP
// end ;
43003: LD_VAR 0 1
43007: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43008: LD_INT 0
43010: PPUSH
43011: PPUSH
43012: PPUSH
43013: PPUSH
43014: PPUSH
43015: PPUSH
43016: PPUSH
43017: PPUSH
43018: PPUSH
43019: PPUSH
43020: PPUSH
// if not mc_bases then
43021: LD_EXP 95
43025: NOT
43026: IFFALSE 43030
// exit ;
43028: GO 43970
// for i = 1 to mc_bases do
43030: LD_ADDR_VAR 0 2
43034: PUSH
43035: DOUBLE
43036: LD_INT 1
43038: DEC
43039: ST_TO_ADDR
43040: LD_EXP 95
43044: PUSH
43045: FOR_TO
43046: IFFALSE 43968
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43048: LD_EXP 95
43052: PUSH
43053: LD_VAR 0 2
43057: ARRAY
43058: NOT
43059: PUSH
43060: LD_EXP 118
43064: PUSH
43065: LD_VAR 0 2
43069: ARRAY
43070: OR
43071: IFFALSE 43075
// continue ;
43073: GO 43045
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43075: LD_ADDR_VAR 0 7
43079: PUSH
43080: LD_EXP 95
43084: PUSH
43085: LD_VAR 0 2
43089: ARRAY
43090: PUSH
43091: LD_INT 1
43093: ARRAY
43094: PPUSH
43095: CALL_OW 248
43099: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43100: LD_VAR 0 7
43104: PUSH
43105: LD_INT 3
43107: EQUAL
43108: PUSH
43109: LD_EXP 114
43113: PUSH
43114: LD_VAR 0 2
43118: ARRAY
43119: PUSH
43120: LD_EXP 117
43124: PUSH
43125: LD_VAR 0 2
43129: ARRAY
43130: UNION
43131: PPUSH
43132: LD_INT 33
43134: PUSH
43135: LD_INT 2
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: PPUSH
43142: CALL_OW 72
43146: NOT
43147: OR
43148: IFFALSE 43152
// continue ;
43150: GO 43045
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43152: LD_ADDR_VAR 0 9
43156: PUSH
43157: LD_EXP 95
43161: PUSH
43162: LD_VAR 0 2
43166: ARRAY
43167: PPUSH
43168: LD_INT 30
43170: PUSH
43171: LD_INT 36
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PPUSH
43178: CALL_OW 72
43182: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43183: LD_ADDR_VAR 0 10
43187: PUSH
43188: LD_EXP 114
43192: PUSH
43193: LD_VAR 0 2
43197: ARRAY
43198: PPUSH
43199: LD_INT 34
43201: PUSH
43202: LD_INT 31
43204: PUSH
43205: EMPTY
43206: LIST
43207: LIST
43208: PPUSH
43209: CALL_OW 72
43213: ST_TO_ADDR
// if not cts and not mcts then
43214: LD_VAR 0 9
43218: NOT
43219: PUSH
43220: LD_VAR 0 10
43224: NOT
43225: AND
43226: IFFALSE 43230
// continue ;
43228: GO 43045
// x := cts ;
43230: LD_ADDR_VAR 0 11
43234: PUSH
43235: LD_VAR 0 9
43239: ST_TO_ADDR
// if not x then
43240: LD_VAR 0 11
43244: NOT
43245: IFFALSE 43257
// x := mcts ;
43247: LD_ADDR_VAR 0 11
43251: PUSH
43252: LD_VAR 0 10
43256: ST_TO_ADDR
// if not x then
43257: LD_VAR 0 11
43261: NOT
43262: IFFALSE 43266
// continue ;
43264: GO 43045
// if mc_remote_driver [ i ] then
43266: LD_EXP 135
43270: PUSH
43271: LD_VAR 0 2
43275: ARRAY
43276: IFFALSE 43663
// for j in mc_remote_driver [ i ] do
43278: LD_ADDR_VAR 0 3
43282: PUSH
43283: LD_EXP 135
43287: PUSH
43288: LD_VAR 0 2
43292: ARRAY
43293: PUSH
43294: FOR_IN
43295: IFFALSE 43661
// begin if GetClass ( j ) <> 3 then
43297: LD_VAR 0 3
43301: PPUSH
43302: CALL_OW 257
43306: PUSH
43307: LD_INT 3
43309: NONEQUAL
43310: IFFALSE 43363
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43312: LD_ADDR_EXP 135
43316: PUSH
43317: LD_EXP 135
43321: PPUSH
43322: LD_VAR 0 2
43326: PPUSH
43327: LD_EXP 135
43331: PUSH
43332: LD_VAR 0 2
43336: ARRAY
43337: PUSH
43338: LD_VAR 0 3
43342: DIFF
43343: PPUSH
43344: CALL_OW 1
43348: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43349: LD_VAR 0 3
43353: PPUSH
43354: LD_INT 0
43356: PPUSH
43357: CALL_OW 109
// continue ;
43361: GO 43294
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43363: LD_EXP 114
43367: PUSH
43368: LD_VAR 0 2
43372: ARRAY
43373: PPUSH
43374: LD_INT 34
43376: PUSH
43377: LD_INT 31
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 58
43386: PUSH
43387: EMPTY
43388: LIST
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PPUSH
43394: CALL_OW 72
43398: PUSH
43399: LD_VAR 0 3
43403: PPUSH
43404: CALL 86331 0 1
43408: NOT
43409: AND
43410: IFFALSE 43481
// begin if IsInUnit ( j ) then
43412: LD_VAR 0 3
43416: PPUSH
43417: CALL_OW 310
43421: IFFALSE 43432
// ComExitBuilding ( j ) ;
43423: LD_VAR 0 3
43427: PPUSH
43428: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43432: LD_VAR 0 3
43436: PPUSH
43437: LD_EXP 114
43441: PUSH
43442: LD_VAR 0 2
43446: ARRAY
43447: PPUSH
43448: LD_INT 34
43450: PUSH
43451: LD_INT 31
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 58
43460: PUSH
43461: EMPTY
43462: LIST
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PPUSH
43468: CALL_OW 72
43472: PUSH
43473: LD_INT 1
43475: ARRAY
43476: PPUSH
43477: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43481: LD_VAR 0 3
43485: PPUSH
43486: CALL_OW 310
43490: NOT
43491: PUSH
43492: LD_VAR 0 3
43496: PPUSH
43497: CALL_OW 310
43501: PPUSH
43502: CALL_OW 266
43506: PUSH
43507: LD_INT 36
43509: NONEQUAL
43510: PUSH
43511: LD_VAR 0 3
43515: PPUSH
43516: CALL 86331 0 1
43520: NOT
43521: AND
43522: OR
43523: IFFALSE 43659
// begin if IsInUnit ( j ) then
43525: LD_VAR 0 3
43529: PPUSH
43530: CALL_OW 310
43534: IFFALSE 43545
// ComExitBuilding ( j ) ;
43536: LD_VAR 0 3
43540: PPUSH
43541: CALL_OW 122
// ct := 0 ;
43545: LD_ADDR_VAR 0 8
43549: PUSH
43550: LD_INT 0
43552: ST_TO_ADDR
// for k in x do
43553: LD_ADDR_VAR 0 4
43557: PUSH
43558: LD_VAR 0 11
43562: PUSH
43563: FOR_IN
43564: IFFALSE 43637
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43566: LD_VAR 0 4
43570: PPUSH
43571: CALL_OW 264
43575: PUSH
43576: LD_INT 31
43578: EQUAL
43579: PUSH
43580: LD_VAR 0 4
43584: PPUSH
43585: CALL_OW 311
43589: NOT
43590: AND
43591: PUSH
43592: LD_VAR 0 4
43596: PPUSH
43597: CALL_OW 266
43601: PUSH
43602: LD_INT 36
43604: EQUAL
43605: PUSH
43606: LD_VAR 0 4
43610: PPUSH
43611: CALL_OW 313
43615: PUSH
43616: LD_INT 3
43618: LESS
43619: AND
43620: OR
43621: IFFALSE 43635
// begin ct := k ;
43623: LD_ADDR_VAR 0 8
43627: PUSH
43628: LD_VAR 0 4
43632: ST_TO_ADDR
// break ;
43633: GO 43637
// end ;
43635: GO 43563
43637: POP
43638: POP
// if ct then
43639: LD_VAR 0 8
43643: IFFALSE 43659
// ComEnterUnit ( j , ct ) ;
43645: LD_VAR 0 3
43649: PPUSH
43650: LD_VAR 0 8
43654: PPUSH
43655: CALL_OW 120
// end ; end ;
43659: GO 43294
43661: POP
43662: POP
// places := 0 ;
43663: LD_ADDR_VAR 0 5
43667: PUSH
43668: LD_INT 0
43670: ST_TO_ADDR
// for j = 1 to x do
43671: LD_ADDR_VAR 0 3
43675: PUSH
43676: DOUBLE
43677: LD_INT 1
43679: DEC
43680: ST_TO_ADDR
43681: LD_VAR 0 11
43685: PUSH
43686: FOR_TO
43687: IFFALSE 43763
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43689: LD_VAR 0 11
43693: PUSH
43694: LD_VAR 0 3
43698: ARRAY
43699: PPUSH
43700: CALL_OW 264
43704: PUSH
43705: LD_INT 31
43707: EQUAL
43708: IFFALSE 43726
// places := places + 1 else
43710: LD_ADDR_VAR 0 5
43714: PUSH
43715: LD_VAR 0 5
43719: PUSH
43720: LD_INT 1
43722: PLUS
43723: ST_TO_ADDR
43724: GO 43761
// if GetBType ( x [ j ] ) = b_control_tower then
43726: LD_VAR 0 11
43730: PUSH
43731: LD_VAR 0 3
43735: ARRAY
43736: PPUSH
43737: CALL_OW 266
43741: PUSH
43742: LD_INT 36
43744: EQUAL
43745: IFFALSE 43761
// places := places + 3 ;
43747: LD_ADDR_VAR 0 5
43751: PUSH
43752: LD_VAR 0 5
43756: PUSH
43757: LD_INT 3
43759: PLUS
43760: ST_TO_ADDR
43761: GO 43686
43763: POP
43764: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43765: LD_VAR 0 5
43769: PUSH
43770: LD_INT 0
43772: EQUAL
43773: PUSH
43774: LD_VAR 0 5
43778: PUSH
43779: LD_EXP 135
43783: PUSH
43784: LD_VAR 0 2
43788: ARRAY
43789: LESSEQUAL
43790: OR
43791: IFFALSE 43795
// continue ;
43793: GO 43045
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43795: LD_ADDR_VAR 0 6
43799: PUSH
43800: LD_EXP 95
43804: PUSH
43805: LD_VAR 0 2
43809: ARRAY
43810: PPUSH
43811: LD_INT 25
43813: PUSH
43814: LD_INT 3
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PPUSH
43821: CALL_OW 72
43825: PUSH
43826: LD_EXP 135
43830: PUSH
43831: LD_VAR 0 2
43835: ARRAY
43836: DIFF
43837: PPUSH
43838: LD_INT 3
43840: PPUSH
43841: CALL 87231 0 2
43845: ST_TO_ADDR
// for j in tmp do
43846: LD_ADDR_VAR 0 3
43850: PUSH
43851: LD_VAR 0 6
43855: PUSH
43856: FOR_IN
43857: IFFALSE 43892
// if GetTag ( j ) > 0 then
43859: LD_VAR 0 3
43863: PPUSH
43864: CALL_OW 110
43868: PUSH
43869: LD_INT 0
43871: GREATER
43872: IFFALSE 43890
// tmp := tmp diff j ;
43874: LD_ADDR_VAR 0 6
43878: PUSH
43879: LD_VAR 0 6
43883: PUSH
43884: LD_VAR 0 3
43888: DIFF
43889: ST_TO_ADDR
43890: GO 43856
43892: POP
43893: POP
// if not tmp then
43894: LD_VAR 0 6
43898: NOT
43899: IFFALSE 43903
// continue ;
43901: GO 43045
// if places then
43903: LD_VAR 0 5
43907: IFFALSE 43966
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43909: LD_ADDR_EXP 135
43913: PUSH
43914: LD_EXP 135
43918: PPUSH
43919: LD_VAR 0 2
43923: PPUSH
43924: LD_EXP 135
43928: PUSH
43929: LD_VAR 0 2
43933: ARRAY
43934: PUSH
43935: LD_VAR 0 6
43939: PUSH
43940: LD_INT 1
43942: ARRAY
43943: UNION
43944: PPUSH
43945: CALL_OW 1
43949: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43950: LD_VAR 0 6
43954: PUSH
43955: LD_INT 1
43957: ARRAY
43958: PPUSH
43959: LD_INT 126
43961: PPUSH
43962: CALL_OW 109
// end ; end ;
43966: GO 43045
43968: POP
43969: POP
// end ;
43970: LD_VAR 0 1
43974: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43975: LD_INT 0
43977: PPUSH
43978: PPUSH
43979: PPUSH
43980: PPUSH
43981: PPUSH
43982: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43983: LD_VAR 0 1
43987: NOT
43988: PUSH
43989: LD_VAR 0 2
43993: NOT
43994: OR
43995: PUSH
43996: LD_VAR 0 3
44000: NOT
44001: OR
44002: PUSH
44003: LD_VAR 0 4
44007: PUSH
44008: LD_INT 1
44010: PUSH
44011: LD_INT 2
44013: PUSH
44014: LD_INT 3
44016: PUSH
44017: LD_INT 4
44019: PUSH
44020: LD_INT 5
44022: PUSH
44023: LD_INT 8
44025: PUSH
44026: LD_INT 9
44028: PUSH
44029: LD_INT 15
44031: PUSH
44032: LD_INT 16
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: LIST
44039: LIST
44040: LIST
44041: LIST
44042: LIST
44043: LIST
44044: LIST
44045: IN
44046: NOT
44047: OR
44048: IFFALSE 44052
// exit ;
44050: GO 44952
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44052: LD_ADDR_VAR 0 2
44056: PUSH
44057: LD_VAR 0 2
44061: PPUSH
44062: LD_INT 21
44064: PUSH
44065: LD_INT 3
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 24
44074: PUSH
44075: LD_INT 250
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PPUSH
44086: CALL_OW 72
44090: ST_TO_ADDR
// case class of 1 , 15 :
44091: LD_VAR 0 4
44095: PUSH
44096: LD_INT 1
44098: DOUBLE
44099: EQUAL
44100: IFTRUE 44110
44102: LD_INT 15
44104: DOUBLE
44105: EQUAL
44106: IFTRUE 44110
44108: GO 44195
44110: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44111: LD_ADDR_VAR 0 8
44115: PUSH
44116: LD_VAR 0 2
44120: PPUSH
44121: LD_INT 2
44123: PUSH
44124: LD_INT 30
44126: PUSH
44127: LD_INT 32
44129: PUSH
44130: EMPTY
44131: LIST
44132: LIST
44133: PUSH
44134: LD_INT 30
44136: PUSH
44137: LD_INT 31
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: LIST
44148: PPUSH
44149: CALL_OW 72
44153: PUSH
44154: LD_VAR 0 2
44158: PPUSH
44159: LD_INT 2
44161: PUSH
44162: LD_INT 30
44164: PUSH
44165: LD_INT 4
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 30
44174: PUSH
44175: LD_INT 5
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: LIST
44186: PPUSH
44187: CALL_OW 72
44191: ADD
44192: ST_TO_ADDR
44193: GO 44441
44195: LD_INT 2
44197: DOUBLE
44198: EQUAL
44199: IFTRUE 44209
44201: LD_INT 16
44203: DOUBLE
44204: EQUAL
44205: IFTRUE 44209
44207: GO 44255
44209: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44210: LD_ADDR_VAR 0 8
44214: PUSH
44215: LD_VAR 0 2
44219: PPUSH
44220: LD_INT 2
44222: PUSH
44223: LD_INT 30
44225: PUSH
44226: LD_INT 0
44228: PUSH
44229: EMPTY
44230: LIST
44231: LIST
44232: PUSH
44233: LD_INT 30
44235: PUSH
44236: LD_INT 1
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: LIST
44247: PPUSH
44248: CALL_OW 72
44252: ST_TO_ADDR
44253: GO 44441
44255: LD_INT 3
44257: DOUBLE
44258: EQUAL
44259: IFTRUE 44263
44261: GO 44309
44263: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44264: LD_ADDR_VAR 0 8
44268: PUSH
44269: LD_VAR 0 2
44273: PPUSH
44274: LD_INT 2
44276: PUSH
44277: LD_INT 30
44279: PUSH
44280: LD_INT 2
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: LD_INT 30
44289: PUSH
44290: LD_INT 3
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: LIST
44301: PPUSH
44302: CALL_OW 72
44306: ST_TO_ADDR
44307: GO 44441
44309: LD_INT 4
44311: DOUBLE
44312: EQUAL
44313: IFTRUE 44317
44315: GO 44374
44317: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44318: LD_ADDR_VAR 0 8
44322: PUSH
44323: LD_VAR 0 2
44327: PPUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 30
44333: PUSH
44334: LD_INT 6
44336: PUSH
44337: EMPTY
44338: LIST
44339: LIST
44340: PUSH
44341: LD_INT 30
44343: PUSH
44344: LD_INT 7
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: LD_INT 30
44353: PUSH
44354: LD_INT 8
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: EMPTY
44362: LIST
44363: LIST
44364: LIST
44365: LIST
44366: PPUSH
44367: CALL_OW 72
44371: ST_TO_ADDR
44372: GO 44441
44374: LD_INT 5
44376: DOUBLE
44377: EQUAL
44378: IFTRUE 44394
44380: LD_INT 8
44382: DOUBLE
44383: EQUAL
44384: IFTRUE 44394
44386: LD_INT 9
44388: DOUBLE
44389: EQUAL
44390: IFTRUE 44394
44392: GO 44440
44394: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44395: LD_ADDR_VAR 0 8
44399: PUSH
44400: LD_VAR 0 2
44404: PPUSH
44405: LD_INT 2
44407: PUSH
44408: LD_INT 30
44410: PUSH
44411: LD_INT 4
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 30
44420: PUSH
44421: LD_INT 5
44423: PUSH
44424: EMPTY
44425: LIST
44426: LIST
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: LIST
44432: PPUSH
44433: CALL_OW 72
44437: ST_TO_ADDR
44438: GO 44441
44440: POP
// if not tmp then
44441: LD_VAR 0 8
44445: NOT
44446: IFFALSE 44450
// exit ;
44448: GO 44952
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44450: LD_VAR 0 4
44454: PUSH
44455: LD_INT 1
44457: PUSH
44458: LD_INT 15
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: IN
44465: PUSH
44466: LD_EXP 104
44470: PUSH
44471: LD_VAR 0 1
44475: ARRAY
44476: AND
44477: IFFALSE 44633
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44479: LD_ADDR_VAR 0 9
44483: PUSH
44484: LD_EXP 104
44488: PUSH
44489: LD_VAR 0 1
44493: ARRAY
44494: PUSH
44495: LD_INT 1
44497: ARRAY
44498: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44499: LD_VAR 0 9
44503: PUSH
44504: LD_EXP 105
44508: PUSH
44509: LD_VAR 0 1
44513: ARRAY
44514: IN
44515: NOT
44516: IFFALSE 44631
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44518: LD_ADDR_EXP 105
44522: PUSH
44523: LD_EXP 105
44527: PPUSH
44528: LD_VAR 0 1
44532: PUSH
44533: LD_EXP 105
44537: PUSH
44538: LD_VAR 0 1
44542: ARRAY
44543: PUSH
44544: LD_INT 1
44546: PLUS
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: PPUSH
44552: LD_VAR 0 9
44556: PPUSH
44557: CALL 56974 0 3
44561: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44562: LD_ADDR_EXP 104
44566: PUSH
44567: LD_EXP 104
44571: PPUSH
44572: LD_VAR 0 1
44576: PPUSH
44577: LD_EXP 104
44581: PUSH
44582: LD_VAR 0 1
44586: ARRAY
44587: PUSH
44588: LD_VAR 0 9
44592: DIFF
44593: PPUSH
44594: CALL_OW 1
44598: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44599: LD_VAR 0 3
44603: PPUSH
44604: LD_EXP 105
44608: PUSH
44609: LD_VAR 0 1
44613: ARRAY
44614: PUSH
44615: LD_EXP 105
44619: PUSH
44620: LD_VAR 0 1
44624: ARRAY
44625: ARRAY
44626: PPUSH
44627: CALL_OW 120
// end ; exit ;
44631: GO 44952
// end ; if tmp > 1 then
44633: LD_VAR 0 8
44637: PUSH
44638: LD_INT 1
44640: GREATER
44641: IFFALSE 44745
// for i = 2 to tmp do
44643: LD_ADDR_VAR 0 6
44647: PUSH
44648: DOUBLE
44649: LD_INT 2
44651: DEC
44652: ST_TO_ADDR
44653: LD_VAR 0 8
44657: PUSH
44658: FOR_TO
44659: IFFALSE 44743
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44661: LD_VAR 0 8
44665: PUSH
44666: LD_VAR 0 6
44670: ARRAY
44671: PPUSH
44672: CALL_OW 461
44676: PUSH
44677: LD_INT 6
44679: EQUAL
44680: IFFALSE 44741
// begin x := tmp [ i ] ;
44682: LD_ADDR_VAR 0 9
44686: PUSH
44687: LD_VAR 0 8
44691: PUSH
44692: LD_VAR 0 6
44696: ARRAY
44697: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44698: LD_ADDR_VAR 0 8
44702: PUSH
44703: LD_VAR 0 8
44707: PPUSH
44708: LD_VAR 0 6
44712: PPUSH
44713: CALL_OW 3
44717: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44718: LD_ADDR_VAR 0 8
44722: PUSH
44723: LD_VAR 0 8
44727: PPUSH
44728: LD_INT 1
44730: PPUSH
44731: LD_VAR 0 9
44735: PPUSH
44736: CALL_OW 2
44740: ST_TO_ADDR
// end ;
44741: GO 44658
44743: POP
44744: POP
// for i in tmp do
44745: LD_ADDR_VAR 0 6
44749: PUSH
44750: LD_VAR 0 8
44754: PUSH
44755: FOR_IN
44756: IFFALSE 44825
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44758: LD_VAR 0 6
44762: PPUSH
44763: CALL_OW 313
44767: PUSH
44768: LD_INT 6
44770: LESS
44771: PUSH
44772: LD_VAR 0 6
44776: PPUSH
44777: CALL_OW 266
44781: PUSH
44782: LD_INT 31
44784: PUSH
44785: LD_INT 32
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: IN
44792: NOT
44793: AND
44794: PUSH
44795: LD_VAR 0 6
44799: PPUSH
44800: CALL_OW 313
44804: PUSH
44805: LD_INT 0
44807: EQUAL
44808: OR
44809: IFFALSE 44823
// begin j := i ;
44811: LD_ADDR_VAR 0 7
44815: PUSH
44816: LD_VAR 0 6
44820: ST_TO_ADDR
// break ;
44821: GO 44825
// end ; end ;
44823: GO 44755
44825: POP
44826: POP
// if j then
44827: LD_VAR 0 7
44831: IFFALSE 44849
// ComEnterUnit ( unit , j ) else
44833: LD_VAR 0 3
44837: PPUSH
44838: LD_VAR 0 7
44842: PPUSH
44843: CALL_OW 120
44847: GO 44952
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44849: LD_ADDR_VAR 0 10
44853: PUSH
44854: LD_VAR 0 2
44858: PPUSH
44859: LD_INT 2
44861: PUSH
44862: LD_INT 30
44864: PUSH
44865: LD_INT 0
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 30
44874: PUSH
44875: LD_INT 1
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: LIST
44886: PPUSH
44887: CALL_OW 72
44891: ST_TO_ADDR
// if depot then
44892: LD_VAR 0 10
44896: IFFALSE 44952
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44898: LD_ADDR_VAR 0 10
44902: PUSH
44903: LD_VAR 0 10
44907: PPUSH
44908: LD_VAR 0 3
44912: PPUSH
44913: CALL_OW 74
44917: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44918: LD_VAR 0 3
44922: PPUSH
44923: LD_VAR 0 10
44927: PPUSH
44928: CALL_OW 296
44932: PUSH
44933: LD_INT 10
44935: GREATER
44936: IFFALSE 44952
// ComStandNearbyBuilding ( unit , depot ) ;
44938: LD_VAR 0 3
44942: PPUSH
44943: LD_VAR 0 10
44947: PPUSH
44948: CALL 53552 0 2
// end ; end ; end ;
44952: LD_VAR 0 5
44956: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44957: LD_INT 0
44959: PPUSH
44960: PPUSH
44961: PPUSH
44962: PPUSH
// if not mc_bases then
44963: LD_EXP 95
44967: NOT
44968: IFFALSE 44972
// exit ;
44970: GO 45211
// for i = 1 to mc_bases do
44972: LD_ADDR_VAR 0 2
44976: PUSH
44977: DOUBLE
44978: LD_INT 1
44980: DEC
44981: ST_TO_ADDR
44982: LD_EXP 95
44986: PUSH
44987: FOR_TO
44988: IFFALSE 45209
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44990: LD_ADDR_VAR 0 4
44994: PUSH
44995: LD_EXP 95
44999: PUSH
45000: LD_VAR 0 2
45004: ARRAY
45005: PPUSH
45006: LD_INT 21
45008: PUSH
45009: LD_INT 1
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PPUSH
45016: CALL_OW 72
45020: PUSH
45021: LD_EXP 124
45025: PUSH
45026: LD_VAR 0 2
45030: ARRAY
45031: UNION
45032: ST_TO_ADDR
// if not tmp then
45033: LD_VAR 0 4
45037: NOT
45038: IFFALSE 45042
// continue ;
45040: GO 44987
// for j in tmp do
45042: LD_ADDR_VAR 0 3
45046: PUSH
45047: LD_VAR 0 4
45051: PUSH
45052: FOR_IN
45053: IFFALSE 45205
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45055: LD_VAR 0 3
45059: PPUSH
45060: CALL_OW 110
45064: NOT
45065: PUSH
45066: LD_VAR 0 3
45070: PPUSH
45071: CALL_OW 314
45075: NOT
45076: AND
45077: PUSH
45078: LD_VAR 0 3
45082: PPUSH
45083: CALL_OW 311
45087: NOT
45088: AND
45089: PUSH
45090: LD_VAR 0 3
45094: PPUSH
45095: CALL_OW 310
45099: NOT
45100: AND
45101: PUSH
45102: LD_VAR 0 3
45106: PUSH
45107: LD_EXP 98
45111: PUSH
45112: LD_VAR 0 2
45116: ARRAY
45117: PUSH
45118: LD_INT 1
45120: ARRAY
45121: IN
45122: NOT
45123: AND
45124: PUSH
45125: LD_VAR 0 3
45129: PUSH
45130: LD_EXP 98
45134: PUSH
45135: LD_VAR 0 2
45139: ARRAY
45140: PUSH
45141: LD_INT 2
45143: ARRAY
45144: IN
45145: NOT
45146: AND
45147: PUSH
45148: LD_VAR 0 3
45152: PUSH
45153: LD_EXP 107
45157: PUSH
45158: LD_VAR 0 2
45162: ARRAY
45163: IN
45164: NOT
45165: AND
45166: IFFALSE 45203
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45168: LD_VAR 0 2
45172: PPUSH
45173: LD_EXP 95
45177: PUSH
45178: LD_VAR 0 2
45182: ARRAY
45183: PPUSH
45184: LD_VAR 0 3
45188: PPUSH
45189: LD_VAR 0 3
45193: PPUSH
45194: CALL_OW 257
45198: PPUSH
45199: CALL 43975 0 4
// end ;
45203: GO 45052
45205: POP
45206: POP
// end ;
45207: GO 44987
45209: POP
45210: POP
// end ;
45211: LD_VAR 0 1
45215: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45216: LD_INT 0
45218: PPUSH
45219: PPUSH
45220: PPUSH
45221: PPUSH
45222: PPUSH
45223: PPUSH
// if not mc_bases [ base ] then
45224: LD_EXP 95
45228: PUSH
45229: LD_VAR 0 1
45233: ARRAY
45234: NOT
45235: IFFALSE 45239
// exit ;
45237: GO 45421
// tmp := [ ] ;
45239: LD_ADDR_VAR 0 6
45243: PUSH
45244: EMPTY
45245: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45246: LD_ADDR_VAR 0 7
45250: PUSH
45251: LD_VAR 0 3
45255: PPUSH
45256: LD_INT 0
45258: PPUSH
45259: CALL_OW 517
45263: ST_TO_ADDR
// if not list then
45264: LD_VAR 0 7
45268: NOT
45269: IFFALSE 45273
// exit ;
45271: GO 45421
// for i = 1 to amount do
45273: LD_ADDR_VAR 0 5
45277: PUSH
45278: DOUBLE
45279: LD_INT 1
45281: DEC
45282: ST_TO_ADDR
45283: LD_VAR 0 2
45287: PUSH
45288: FOR_TO
45289: IFFALSE 45369
// begin x := rand ( 1 , list [ 1 ] ) ;
45291: LD_ADDR_VAR 0 8
45295: PUSH
45296: LD_INT 1
45298: PPUSH
45299: LD_VAR 0 7
45303: PUSH
45304: LD_INT 1
45306: ARRAY
45307: PPUSH
45308: CALL_OW 12
45312: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45313: LD_ADDR_VAR 0 6
45317: PUSH
45318: LD_VAR 0 6
45322: PPUSH
45323: LD_VAR 0 5
45327: PPUSH
45328: LD_VAR 0 7
45332: PUSH
45333: LD_INT 1
45335: ARRAY
45336: PUSH
45337: LD_VAR 0 8
45341: ARRAY
45342: PUSH
45343: LD_VAR 0 7
45347: PUSH
45348: LD_INT 2
45350: ARRAY
45351: PUSH
45352: LD_VAR 0 8
45356: ARRAY
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PPUSH
45362: CALL_OW 1
45366: ST_TO_ADDR
// end ;
45367: GO 45288
45369: POP
45370: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45371: LD_ADDR_EXP 108
45375: PUSH
45376: LD_EXP 108
45380: PPUSH
45381: LD_VAR 0 1
45385: PPUSH
45386: LD_VAR 0 6
45390: PPUSH
45391: CALL_OW 1
45395: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45396: LD_ADDR_EXP 110
45400: PUSH
45401: LD_EXP 110
45405: PPUSH
45406: LD_VAR 0 1
45410: PPUSH
45411: LD_VAR 0 3
45415: PPUSH
45416: CALL_OW 1
45420: ST_TO_ADDR
// end ;
45421: LD_VAR 0 4
45425: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45426: LD_INT 0
45428: PPUSH
// if not mc_bases [ base ] then
45429: LD_EXP 95
45433: PUSH
45434: LD_VAR 0 1
45438: ARRAY
45439: NOT
45440: IFFALSE 45444
// exit ;
45442: GO 45469
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45444: LD_ADDR_EXP 100
45448: PUSH
45449: LD_EXP 100
45453: PPUSH
45454: LD_VAR 0 1
45458: PPUSH
45459: LD_VAR 0 2
45463: PPUSH
45464: CALL_OW 1
45468: ST_TO_ADDR
// end ;
45469: LD_VAR 0 3
45473: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45474: LD_INT 0
45476: PPUSH
// if not mc_bases [ base ] then
45477: LD_EXP 95
45481: PUSH
45482: LD_VAR 0 1
45486: ARRAY
45487: NOT
45488: IFFALSE 45492
// exit ;
45490: GO 45529
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45492: LD_ADDR_EXP 100
45496: PUSH
45497: LD_EXP 100
45501: PPUSH
45502: LD_VAR 0 1
45506: PPUSH
45507: LD_EXP 100
45511: PUSH
45512: LD_VAR 0 1
45516: ARRAY
45517: PUSH
45518: LD_VAR 0 2
45522: UNION
45523: PPUSH
45524: CALL_OW 1
45528: ST_TO_ADDR
// end ;
45529: LD_VAR 0 3
45533: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45534: LD_INT 0
45536: PPUSH
// if not mc_bases [ base ] then
45537: LD_EXP 95
45541: PUSH
45542: LD_VAR 0 1
45546: ARRAY
45547: NOT
45548: IFFALSE 45552
// exit ;
45550: GO 45577
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45552: LD_ADDR_EXP 116
45556: PUSH
45557: LD_EXP 116
45561: PPUSH
45562: LD_VAR 0 1
45566: PPUSH
45567: LD_VAR 0 2
45571: PPUSH
45572: CALL_OW 1
45576: ST_TO_ADDR
// end ;
45577: LD_VAR 0 3
45581: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45582: LD_INT 0
45584: PPUSH
// if not mc_bases [ base ] then
45585: LD_EXP 95
45589: PUSH
45590: LD_VAR 0 1
45594: ARRAY
45595: NOT
45596: IFFALSE 45600
// exit ;
45598: GO 45637
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45600: LD_ADDR_EXP 116
45604: PUSH
45605: LD_EXP 116
45609: PPUSH
45610: LD_VAR 0 1
45614: PPUSH
45615: LD_EXP 116
45619: PUSH
45620: LD_VAR 0 1
45624: ARRAY
45625: PUSH
45626: LD_VAR 0 2
45630: ADD
45631: PPUSH
45632: CALL_OW 1
45636: ST_TO_ADDR
// end ;
45637: LD_VAR 0 3
45641: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45642: LD_INT 0
45644: PPUSH
// if not mc_bases [ base ] then
45645: LD_EXP 95
45649: PUSH
45650: LD_VAR 0 1
45654: ARRAY
45655: NOT
45656: IFFALSE 45660
// exit ;
45658: GO 45714
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45660: LD_ADDR_EXP 117
45664: PUSH
45665: LD_EXP 117
45669: PPUSH
45670: LD_VAR 0 1
45674: PPUSH
45675: LD_VAR 0 2
45679: PPUSH
45680: CALL_OW 1
45684: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45685: LD_ADDR_EXP 106
45689: PUSH
45690: LD_EXP 106
45694: PPUSH
45695: LD_VAR 0 1
45699: PPUSH
45700: LD_VAR 0 2
45704: PUSH
45705: LD_INT 0
45707: PLUS
45708: PPUSH
45709: CALL_OW 1
45713: ST_TO_ADDR
// end ;
45714: LD_VAR 0 3
45718: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45719: LD_INT 0
45721: PPUSH
// if not mc_bases [ base ] then
45722: LD_EXP 95
45726: PUSH
45727: LD_VAR 0 1
45731: ARRAY
45732: NOT
45733: IFFALSE 45737
// exit ;
45735: GO 45762
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45737: LD_ADDR_EXP 106
45741: PUSH
45742: LD_EXP 106
45746: PPUSH
45747: LD_VAR 0 1
45751: PPUSH
45752: LD_VAR 0 2
45756: PPUSH
45757: CALL_OW 1
45761: ST_TO_ADDR
// end ;
45762: LD_VAR 0 3
45766: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45767: LD_INT 0
45769: PPUSH
45770: PPUSH
45771: PPUSH
45772: PPUSH
// if not mc_bases [ base ] then
45773: LD_EXP 95
45777: PUSH
45778: LD_VAR 0 1
45782: ARRAY
45783: NOT
45784: IFFALSE 45788
// exit ;
45786: GO 45853
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45788: LD_ADDR_EXP 115
45792: PUSH
45793: LD_EXP 115
45797: PPUSH
45798: LD_VAR 0 1
45802: PUSH
45803: LD_EXP 115
45807: PUSH
45808: LD_VAR 0 1
45812: ARRAY
45813: PUSH
45814: LD_INT 1
45816: PLUS
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PPUSH
45822: LD_VAR 0 1
45826: PUSH
45827: LD_VAR 0 2
45831: PUSH
45832: LD_VAR 0 3
45836: PUSH
45837: LD_VAR 0 4
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: PPUSH
45848: CALL 56974 0 3
45852: ST_TO_ADDR
// end ;
45853: LD_VAR 0 5
45857: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45858: LD_INT 0
45860: PPUSH
// if not mc_bases [ base ] then
45861: LD_EXP 95
45865: PUSH
45866: LD_VAR 0 1
45870: ARRAY
45871: NOT
45872: IFFALSE 45876
// exit ;
45874: GO 45901
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45876: LD_ADDR_EXP 132
45880: PUSH
45881: LD_EXP 132
45885: PPUSH
45886: LD_VAR 0 1
45890: PPUSH
45891: LD_VAR 0 2
45895: PPUSH
45896: CALL_OW 1
45900: ST_TO_ADDR
// end ;
45901: LD_VAR 0 3
45905: RET
// export function MC_GetMinesField ( base ) ; begin
45906: LD_INT 0
45908: PPUSH
// result := mc_mines [ base ] ;
45909: LD_ADDR_VAR 0 2
45913: PUSH
45914: LD_EXP 108
45918: PUSH
45919: LD_VAR 0 1
45923: ARRAY
45924: ST_TO_ADDR
// end ;
45925: LD_VAR 0 2
45929: RET
// export function MC_GetProduceList ( base ) ; begin
45930: LD_INT 0
45932: PPUSH
// result := mc_produce [ base ] ;
45933: LD_ADDR_VAR 0 2
45937: PUSH
45938: LD_EXP 116
45942: PUSH
45943: LD_VAR 0 1
45947: ARRAY
45948: ST_TO_ADDR
// end ;
45949: LD_VAR 0 2
45953: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45954: LD_INT 0
45956: PPUSH
45957: PPUSH
// if not mc_bases then
45958: LD_EXP 95
45962: NOT
45963: IFFALSE 45967
// exit ;
45965: GO 46032
// if mc_bases [ base ] then
45967: LD_EXP 95
45971: PUSH
45972: LD_VAR 0 1
45976: ARRAY
45977: IFFALSE 46032
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45979: LD_ADDR_VAR 0 3
45983: PUSH
45984: LD_EXP 95
45988: PUSH
45989: LD_VAR 0 1
45993: ARRAY
45994: PPUSH
45995: LD_INT 30
45997: PUSH
45998: LD_VAR 0 2
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PPUSH
46007: CALL_OW 72
46011: ST_TO_ADDR
// if result then
46012: LD_VAR 0 3
46016: IFFALSE 46032
// result := result [ 1 ] ;
46018: LD_ADDR_VAR 0 3
46022: PUSH
46023: LD_VAR 0 3
46027: PUSH
46028: LD_INT 1
46030: ARRAY
46031: ST_TO_ADDR
// end ; end ;
46032: LD_VAR 0 3
46036: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46037: LD_INT 0
46039: PPUSH
46040: PPUSH
// if not mc_bases then
46041: LD_EXP 95
46045: NOT
46046: IFFALSE 46050
// exit ;
46048: GO 46095
// if mc_bases [ base ] then
46050: LD_EXP 95
46054: PUSH
46055: LD_VAR 0 1
46059: ARRAY
46060: IFFALSE 46095
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46062: LD_ADDR_VAR 0 3
46066: PUSH
46067: LD_EXP 95
46071: PUSH
46072: LD_VAR 0 1
46076: ARRAY
46077: PPUSH
46078: LD_INT 30
46080: PUSH
46081: LD_VAR 0 2
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: PPUSH
46090: CALL_OW 72
46094: ST_TO_ADDR
// end ;
46095: LD_VAR 0 3
46099: RET
// export function MC_SetTame ( base , area ) ; begin
46100: LD_INT 0
46102: PPUSH
// if not mc_bases or not base then
46103: LD_EXP 95
46107: NOT
46108: PUSH
46109: LD_VAR 0 1
46113: NOT
46114: OR
46115: IFFALSE 46119
// exit ;
46117: GO 46144
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46119: LD_ADDR_EXP 123
46123: PUSH
46124: LD_EXP 123
46128: PPUSH
46129: LD_VAR 0 1
46133: PPUSH
46134: LD_VAR 0 2
46138: PPUSH
46139: CALL_OW 1
46143: ST_TO_ADDR
// end ;
46144: LD_VAR 0 3
46148: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46149: LD_INT 0
46151: PPUSH
46152: PPUSH
// if not mc_bases or not base then
46153: LD_EXP 95
46157: NOT
46158: PUSH
46159: LD_VAR 0 1
46163: NOT
46164: OR
46165: IFFALSE 46169
// exit ;
46167: GO 46271
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46169: LD_ADDR_VAR 0 4
46173: PUSH
46174: LD_EXP 95
46178: PUSH
46179: LD_VAR 0 1
46183: ARRAY
46184: PPUSH
46185: LD_INT 30
46187: PUSH
46188: LD_VAR 0 2
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: PPUSH
46197: CALL_OW 72
46201: ST_TO_ADDR
// if not tmp then
46202: LD_VAR 0 4
46206: NOT
46207: IFFALSE 46211
// exit ;
46209: GO 46271
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46211: LD_ADDR_EXP 127
46215: PUSH
46216: LD_EXP 127
46220: PPUSH
46221: LD_VAR 0 1
46225: PPUSH
46226: LD_EXP 127
46230: PUSH
46231: LD_VAR 0 1
46235: ARRAY
46236: PPUSH
46237: LD_EXP 127
46241: PUSH
46242: LD_VAR 0 1
46246: ARRAY
46247: PUSH
46248: LD_INT 1
46250: PLUS
46251: PPUSH
46252: LD_VAR 0 4
46256: PUSH
46257: LD_INT 1
46259: ARRAY
46260: PPUSH
46261: CALL_OW 2
46265: PPUSH
46266: CALL_OW 1
46270: ST_TO_ADDR
// end ;
46271: LD_VAR 0 3
46275: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46276: LD_INT 0
46278: PPUSH
46279: PPUSH
// if not mc_bases or not base or not kinds then
46280: LD_EXP 95
46284: NOT
46285: PUSH
46286: LD_VAR 0 1
46290: NOT
46291: OR
46292: PUSH
46293: LD_VAR 0 2
46297: NOT
46298: OR
46299: IFFALSE 46303
// exit ;
46301: GO 46364
// for i in kinds do
46303: LD_ADDR_VAR 0 4
46307: PUSH
46308: LD_VAR 0 2
46312: PUSH
46313: FOR_IN
46314: IFFALSE 46362
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46316: LD_ADDR_EXP 129
46320: PUSH
46321: LD_EXP 129
46325: PPUSH
46326: LD_VAR 0 1
46330: PUSH
46331: LD_EXP 129
46335: PUSH
46336: LD_VAR 0 1
46340: ARRAY
46341: PUSH
46342: LD_INT 1
46344: PLUS
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PPUSH
46350: LD_VAR 0 4
46354: PPUSH
46355: CALL 56974 0 3
46359: ST_TO_ADDR
46360: GO 46313
46362: POP
46363: POP
// end ;
46364: LD_VAR 0 3
46368: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46369: LD_INT 0
46371: PPUSH
// if not mc_bases or not base or not areas then
46372: LD_EXP 95
46376: NOT
46377: PUSH
46378: LD_VAR 0 1
46382: NOT
46383: OR
46384: PUSH
46385: LD_VAR 0 2
46389: NOT
46390: OR
46391: IFFALSE 46395
// exit ;
46393: GO 46420
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46395: LD_ADDR_EXP 113
46399: PUSH
46400: LD_EXP 113
46404: PPUSH
46405: LD_VAR 0 1
46409: PPUSH
46410: LD_VAR 0 2
46414: PPUSH
46415: CALL_OW 1
46419: ST_TO_ADDR
// end ;
46420: LD_VAR 0 3
46424: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46425: LD_INT 0
46427: PPUSH
// if not mc_bases or not base or not teleports_exit then
46428: LD_EXP 95
46432: NOT
46433: PUSH
46434: LD_VAR 0 1
46438: NOT
46439: OR
46440: PUSH
46441: LD_VAR 0 2
46445: NOT
46446: OR
46447: IFFALSE 46451
// exit ;
46449: GO 46476
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46451: LD_ADDR_EXP 130
46455: PUSH
46456: LD_EXP 130
46460: PPUSH
46461: LD_VAR 0 1
46465: PPUSH
46466: LD_VAR 0 2
46470: PPUSH
46471: CALL_OW 1
46475: ST_TO_ADDR
// end ;
46476: LD_VAR 0 3
46480: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46481: LD_INT 0
46483: PPUSH
46484: PPUSH
46485: PPUSH
// if not mc_bases or not base or not ext_list then
46486: LD_EXP 95
46490: NOT
46491: PUSH
46492: LD_VAR 0 1
46496: NOT
46497: OR
46498: PUSH
46499: LD_VAR 0 5
46503: NOT
46504: OR
46505: IFFALSE 46509
// exit ;
46507: GO 46682
// tmp := GetFacExtXYD ( x , y , d ) ;
46509: LD_ADDR_VAR 0 8
46513: PUSH
46514: LD_VAR 0 2
46518: PPUSH
46519: LD_VAR 0 3
46523: PPUSH
46524: LD_VAR 0 4
46528: PPUSH
46529: CALL 86361 0 3
46533: ST_TO_ADDR
// if not tmp then
46534: LD_VAR 0 8
46538: NOT
46539: IFFALSE 46543
// exit ;
46541: GO 46682
// for i in tmp do
46543: LD_ADDR_VAR 0 7
46547: PUSH
46548: LD_VAR 0 8
46552: PUSH
46553: FOR_IN
46554: IFFALSE 46680
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46556: LD_ADDR_EXP 100
46560: PUSH
46561: LD_EXP 100
46565: PPUSH
46566: LD_VAR 0 1
46570: PPUSH
46571: LD_EXP 100
46575: PUSH
46576: LD_VAR 0 1
46580: ARRAY
46581: PPUSH
46582: LD_EXP 100
46586: PUSH
46587: LD_VAR 0 1
46591: ARRAY
46592: PUSH
46593: LD_INT 1
46595: PLUS
46596: PPUSH
46597: LD_VAR 0 5
46601: PUSH
46602: LD_INT 1
46604: ARRAY
46605: PUSH
46606: LD_VAR 0 7
46610: PUSH
46611: LD_INT 1
46613: ARRAY
46614: PUSH
46615: LD_VAR 0 7
46619: PUSH
46620: LD_INT 2
46622: ARRAY
46623: PUSH
46624: LD_VAR 0 7
46628: PUSH
46629: LD_INT 3
46631: ARRAY
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: LIST
46637: LIST
46638: PPUSH
46639: CALL_OW 2
46643: PPUSH
46644: CALL_OW 1
46648: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46649: LD_ADDR_VAR 0 5
46653: PUSH
46654: LD_VAR 0 5
46658: PPUSH
46659: LD_INT 1
46661: PPUSH
46662: CALL_OW 3
46666: ST_TO_ADDR
// if not ext_list then
46667: LD_VAR 0 5
46671: NOT
46672: IFFALSE 46678
// exit ;
46674: POP
46675: POP
46676: GO 46682
// end ;
46678: GO 46553
46680: POP
46681: POP
// end ;
46682: LD_VAR 0 6
46686: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46687: LD_INT 0
46689: PPUSH
// if not mc_bases or not base or not weapon_list then
46690: LD_EXP 95
46694: NOT
46695: PUSH
46696: LD_VAR 0 1
46700: NOT
46701: OR
46702: PUSH
46703: LD_VAR 0 2
46707: NOT
46708: OR
46709: IFFALSE 46713
// exit ;
46711: GO 46738
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46713: LD_ADDR_EXP 134
46717: PUSH
46718: LD_EXP 134
46722: PPUSH
46723: LD_VAR 0 1
46727: PPUSH
46728: LD_VAR 0 2
46732: PPUSH
46733: CALL_OW 1
46737: ST_TO_ADDR
// end ;
46738: LD_VAR 0 3
46742: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46743: LD_INT 0
46745: PPUSH
// if not mc_bases or not base or not tech_list then
46746: LD_EXP 95
46750: NOT
46751: PUSH
46752: LD_VAR 0 1
46756: NOT
46757: OR
46758: PUSH
46759: LD_VAR 0 2
46763: NOT
46764: OR
46765: IFFALSE 46769
// exit ;
46767: GO 46794
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46769: LD_ADDR_EXP 122
46773: PUSH
46774: LD_EXP 122
46778: PPUSH
46779: LD_VAR 0 1
46783: PPUSH
46784: LD_VAR 0 2
46788: PPUSH
46789: CALL_OW 1
46793: ST_TO_ADDR
// end ;
46794: LD_VAR 0 3
46798: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46799: LD_INT 0
46801: PPUSH
// if not mc_bases or not parking_area or not base then
46802: LD_EXP 95
46806: NOT
46807: PUSH
46808: LD_VAR 0 2
46812: NOT
46813: OR
46814: PUSH
46815: LD_VAR 0 1
46819: NOT
46820: OR
46821: IFFALSE 46825
// exit ;
46823: GO 46850
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46825: LD_ADDR_EXP 119
46829: PUSH
46830: LD_EXP 119
46834: PPUSH
46835: LD_VAR 0 1
46839: PPUSH
46840: LD_VAR 0 2
46844: PPUSH
46845: CALL_OW 1
46849: ST_TO_ADDR
// end ;
46850: LD_VAR 0 3
46854: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46855: LD_INT 0
46857: PPUSH
// if not mc_bases or not base or not scan_area then
46858: LD_EXP 95
46862: NOT
46863: PUSH
46864: LD_VAR 0 1
46868: NOT
46869: OR
46870: PUSH
46871: LD_VAR 0 2
46875: NOT
46876: OR
46877: IFFALSE 46881
// exit ;
46879: GO 46906
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46881: LD_ADDR_EXP 120
46885: PUSH
46886: LD_EXP 120
46890: PPUSH
46891: LD_VAR 0 1
46895: PPUSH
46896: LD_VAR 0 2
46900: PPUSH
46901: CALL_OW 1
46905: ST_TO_ADDR
// end ;
46906: LD_VAR 0 3
46910: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46911: LD_INT 0
46913: PPUSH
46914: PPUSH
// if not mc_bases or not base then
46915: LD_EXP 95
46919: NOT
46920: PUSH
46921: LD_VAR 0 1
46925: NOT
46926: OR
46927: IFFALSE 46931
// exit ;
46929: GO 46995
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46931: LD_ADDR_VAR 0 3
46935: PUSH
46936: LD_INT 1
46938: PUSH
46939: LD_INT 2
46941: PUSH
46942: LD_INT 3
46944: PUSH
46945: LD_INT 4
46947: PUSH
46948: LD_INT 11
46950: PUSH
46951: EMPTY
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46958: LD_ADDR_EXP 122
46962: PUSH
46963: LD_EXP 122
46967: PPUSH
46968: LD_VAR 0 1
46972: PPUSH
46973: LD_EXP 122
46977: PUSH
46978: LD_VAR 0 1
46982: ARRAY
46983: PUSH
46984: LD_VAR 0 3
46988: DIFF
46989: PPUSH
46990: CALL_OW 1
46994: ST_TO_ADDR
// end ;
46995: LD_VAR 0 2
46999: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47000: LD_INT 0
47002: PPUSH
// result := mc_vehicles [ base ] ;
47003: LD_ADDR_VAR 0 3
47007: PUSH
47008: LD_EXP 114
47012: PUSH
47013: LD_VAR 0 1
47017: ARRAY
47018: ST_TO_ADDR
// if onlyCombat then
47019: LD_VAR 0 2
47023: IFFALSE 47201
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47025: LD_ADDR_VAR 0 3
47029: PUSH
47030: LD_VAR 0 3
47034: PUSH
47035: LD_VAR 0 3
47039: PPUSH
47040: LD_INT 2
47042: PUSH
47043: LD_INT 34
47045: PUSH
47046: LD_INT 12
47048: PUSH
47049: EMPTY
47050: LIST
47051: LIST
47052: PUSH
47053: LD_INT 34
47055: PUSH
47056: LD_INT 51
47058: PUSH
47059: EMPTY
47060: LIST
47061: LIST
47062: PUSH
47063: LD_INT 34
47065: PUSH
47066: LD_EXP 75
47070: PUSH
47071: EMPTY
47072: LIST
47073: LIST
47074: PUSH
47075: LD_INT 34
47077: PUSH
47078: LD_INT 32
47080: PUSH
47081: EMPTY
47082: LIST
47083: LIST
47084: PUSH
47085: LD_INT 34
47087: PUSH
47088: LD_INT 13
47090: PUSH
47091: EMPTY
47092: LIST
47093: LIST
47094: PUSH
47095: LD_INT 34
47097: PUSH
47098: LD_INT 52
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: PUSH
47105: LD_INT 34
47107: PUSH
47108: LD_EXP 80
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PUSH
47117: LD_INT 34
47119: PUSH
47120: LD_INT 14
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: PUSH
47127: LD_INT 34
47129: PUSH
47130: LD_INT 53
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: LD_INT 34
47139: PUSH
47140: LD_EXP 74
47144: PUSH
47145: EMPTY
47146: LIST
47147: LIST
47148: PUSH
47149: LD_INT 34
47151: PUSH
47152: LD_INT 31
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: PUSH
47159: LD_INT 34
47161: PUSH
47162: LD_INT 48
47164: PUSH
47165: EMPTY
47166: LIST
47167: LIST
47168: PUSH
47169: LD_INT 34
47171: PUSH
47172: LD_INT 8
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: PUSH
47179: EMPTY
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: PPUSH
47195: CALL_OW 72
47199: DIFF
47200: ST_TO_ADDR
// end ; end_of_file
47201: LD_VAR 0 3
47205: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47206: LD_INT 0
47208: PPUSH
47209: PPUSH
47210: PPUSH
// if not mc_bases or not skirmish then
47211: LD_EXP 95
47215: NOT
47216: PUSH
47217: LD_EXP 93
47221: NOT
47222: OR
47223: IFFALSE 47227
// exit ;
47225: GO 47392
// for i = 1 to mc_bases do
47227: LD_ADDR_VAR 0 4
47231: PUSH
47232: DOUBLE
47233: LD_INT 1
47235: DEC
47236: ST_TO_ADDR
47237: LD_EXP 95
47241: PUSH
47242: FOR_TO
47243: IFFALSE 47390
// begin if sci in mc_bases [ i ] then
47245: LD_VAR 0 2
47249: PUSH
47250: LD_EXP 95
47254: PUSH
47255: LD_VAR 0 4
47259: ARRAY
47260: IN
47261: IFFALSE 47388
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47263: LD_ADDR_EXP 124
47267: PUSH
47268: LD_EXP 124
47272: PPUSH
47273: LD_VAR 0 4
47277: PUSH
47278: LD_EXP 124
47282: PUSH
47283: LD_VAR 0 4
47287: ARRAY
47288: PUSH
47289: LD_INT 1
47291: PLUS
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PPUSH
47297: LD_VAR 0 1
47301: PPUSH
47302: CALL 56974 0 3
47306: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47307: LD_ADDR_VAR 0 5
47311: PUSH
47312: LD_EXP 95
47316: PUSH
47317: LD_VAR 0 4
47321: ARRAY
47322: PPUSH
47323: LD_INT 2
47325: PUSH
47326: LD_INT 30
47328: PUSH
47329: LD_INT 0
47331: PUSH
47332: EMPTY
47333: LIST
47334: LIST
47335: PUSH
47336: LD_INT 30
47338: PUSH
47339: LD_INT 1
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: LIST
47350: PPUSH
47351: CALL_OW 72
47355: PPUSH
47356: LD_VAR 0 1
47360: PPUSH
47361: CALL_OW 74
47365: ST_TO_ADDR
// if tmp then
47366: LD_VAR 0 5
47370: IFFALSE 47386
// ComStandNearbyBuilding ( ape , tmp ) ;
47372: LD_VAR 0 1
47376: PPUSH
47377: LD_VAR 0 5
47381: PPUSH
47382: CALL 53552 0 2
// break ;
47386: GO 47390
// end ; end ;
47388: GO 47242
47390: POP
47391: POP
// end ;
47392: LD_VAR 0 3
47396: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47397: LD_INT 0
47399: PPUSH
47400: PPUSH
47401: PPUSH
// if not mc_bases or not skirmish then
47402: LD_EXP 95
47406: NOT
47407: PUSH
47408: LD_EXP 93
47412: NOT
47413: OR
47414: IFFALSE 47418
// exit ;
47416: GO 47507
// for i = 1 to mc_bases do
47418: LD_ADDR_VAR 0 4
47422: PUSH
47423: DOUBLE
47424: LD_INT 1
47426: DEC
47427: ST_TO_ADDR
47428: LD_EXP 95
47432: PUSH
47433: FOR_TO
47434: IFFALSE 47505
// begin if building in mc_busy_turret_list [ i ] then
47436: LD_VAR 0 1
47440: PUSH
47441: LD_EXP 105
47445: PUSH
47446: LD_VAR 0 4
47450: ARRAY
47451: IN
47452: IFFALSE 47503
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47454: LD_ADDR_VAR 0 5
47458: PUSH
47459: LD_EXP 105
47463: PUSH
47464: LD_VAR 0 4
47468: ARRAY
47469: PUSH
47470: LD_VAR 0 1
47474: DIFF
47475: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47476: LD_ADDR_EXP 105
47480: PUSH
47481: LD_EXP 105
47485: PPUSH
47486: LD_VAR 0 4
47490: PPUSH
47491: LD_VAR 0 5
47495: PPUSH
47496: CALL_OW 1
47500: ST_TO_ADDR
// break ;
47501: GO 47505
// end ; end ;
47503: GO 47433
47505: POP
47506: POP
// end ;
47507: LD_VAR 0 3
47511: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47512: LD_INT 0
47514: PPUSH
47515: PPUSH
47516: PPUSH
// if not mc_bases or not skirmish then
47517: LD_EXP 95
47521: NOT
47522: PUSH
47523: LD_EXP 93
47527: NOT
47528: OR
47529: IFFALSE 47533
// exit ;
47531: GO 47732
// for i = 1 to mc_bases do
47533: LD_ADDR_VAR 0 5
47537: PUSH
47538: DOUBLE
47539: LD_INT 1
47541: DEC
47542: ST_TO_ADDR
47543: LD_EXP 95
47547: PUSH
47548: FOR_TO
47549: IFFALSE 47730
// if building in mc_bases [ i ] then
47551: LD_VAR 0 1
47555: PUSH
47556: LD_EXP 95
47560: PUSH
47561: LD_VAR 0 5
47565: ARRAY
47566: IN
47567: IFFALSE 47728
// begin tmp := mc_bases [ i ] diff building ;
47569: LD_ADDR_VAR 0 6
47573: PUSH
47574: LD_EXP 95
47578: PUSH
47579: LD_VAR 0 5
47583: ARRAY
47584: PUSH
47585: LD_VAR 0 1
47589: DIFF
47590: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47591: LD_ADDR_EXP 95
47595: PUSH
47596: LD_EXP 95
47600: PPUSH
47601: LD_VAR 0 5
47605: PPUSH
47606: LD_VAR 0 6
47610: PPUSH
47611: CALL_OW 1
47615: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47616: LD_VAR 0 1
47620: PUSH
47621: LD_EXP 103
47625: PUSH
47626: LD_VAR 0 5
47630: ARRAY
47631: IN
47632: IFFALSE 47671
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47634: LD_ADDR_EXP 103
47638: PUSH
47639: LD_EXP 103
47643: PPUSH
47644: LD_VAR 0 5
47648: PPUSH
47649: LD_EXP 103
47653: PUSH
47654: LD_VAR 0 5
47658: ARRAY
47659: PUSH
47660: LD_VAR 0 1
47664: DIFF
47665: PPUSH
47666: CALL_OW 1
47670: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47671: LD_VAR 0 1
47675: PUSH
47676: LD_EXP 104
47680: PUSH
47681: LD_VAR 0 5
47685: ARRAY
47686: IN
47687: IFFALSE 47726
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47689: LD_ADDR_EXP 104
47693: PUSH
47694: LD_EXP 104
47698: PPUSH
47699: LD_VAR 0 5
47703: PPUSH
47704: LD_EXP 104
47708: PUSH
47709: LD_VAR 0 5
47713: ARRAY
47714: PUSH
47715: LD_VAR 0 1
47719: DIFF
47720: PPUSH
47721: CALL_OW 1
47725: ST_TO_ADDR
// break ;
47726: GO 47730
// end ;
47728: GO 47548
47730: POP
47731: POP
// end ;
47732: LD_VAR 0 4
47736: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47737: LD_INT 0
47739: PPUSH
47740: PPUSH
47741: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47742: LD_EXP 95
47746: NOT
47747: PUSH
47748: LD_EXP 93
47752: NOT
47753: OR
47754: PUSH
47755: LD_VAR 0 3
47759: PUSH
47760: LD_EXP 121
47764: IN
47765: NOT
47766: OR
47767: IFFALSE 47771
// exit ;
47769: GO 47894
// for i = 1 to mc_vehicles do
47771: LD_ADDR_VAR 0 6
47775: PUSH
47776: DOUBLE
47777: LD_INT 1
47779: DEC
47780: ST_TO_ADDR
47781: LD_EXP 114
47785: PUSH
47786: FOR_TO
47787: IFFALSE 47892
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47789: LD_VAR 0 2
47793: PUSH
47794: LD_EXP 114
47798: PUSH
47799: LD_VAR 0 6
47803: ARRAY
47804: IN
47805: PUSH
47806: LD_VAR 0 1
47810: PUSH
47811: LD_EXP 114
47815: PUSH
47816: LD_VAR 0 6
47820: ARRAY
47821: IN
47822: OR
47823: IFFALSE 47890
// begin tmp := mc_vehicles [ i ] diff old ;
47825: LD_ADDR_VAR 0 7
47829: PUSH
47830: LD_EXP 114
47834: PUSH
47835: LD_VAR 0 6
47839: ARRAY
47840: PUSH
47841: LD_VAR 0 2
47845: DIFF
47846: ST_TO_ADDR
// tmp := tmp diff new ;
47847: LD_ADDR_VAR 0 7
47851: PUSH
47852: LD_VAR 0 7
47856: PUSH
47857: LD_VAR 0 1
47861: DIFF
47862: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47863: LD_ADDR_EXP 114
47867: PUSH
47868: LD_EXP 114
47872: PPUSH
47873: LD_VAR 0 6
47877: PPUSH
47878: LD_VAR 0 7
47882: PPUSH
47883: CALL_OW 1
47887: ST_TO_ADDR
// break ;
47888: GO 47892
// end ;
47890: GO 47786
47892: POP
47893: POP
// end ;
47894: LD_VAR 0 5
47898: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47899: LD_INT 0
47901: PPUSH
47902: PPUSH
47903: PPUSH
47904: PPUSH
// if not mc_bases or not skirmish then
47905: LD_EXP 95
47909: NOT
47910: PUSH
47911: LD_EXP 93
47915: NOT
47916: OR
47917: IFFALSE 47921
// exit ;
47919: GO 48313
// side := GetSide ( vehicle ) ;
47921: LD_ADDR_VAR 0 5
47925: PUSH
47926: LD_VAR 0 1
47930: PPUSH
47931: CALL_OW 255
47935: ST_TO_ADDR
// for i = 1 to mc_bases do
47936: LD_ADDR_VAR 0 4
47940: PUSH
47941: DOUBLE
47942: LD_INT 1
47944: DEC
47945: ST_TO_ADDR
47946: LD_EXP 95
47950: PUSH
47951: FOR_TO
47952: IFFALSE 48311
// begin if factory in mc_bases [ i ] then
47954: LD_VAR 0 2
47958: PUSH
47959: LD_EXP 95
47963: PUSH
47964: LD_VAR 0 4
47968: ARRAY
47969: IN
47970: IFFALSE 48309
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47972: LD_EXP 117
47976: PUSH
47977: LD_VAR 0 4
47981: ARRAY
47982: PUSH
47983: LD_EXP 106
47987: PUSH
47988: LD_VAR 0 4
47992: ARRAY
47993: LESS
47994: PUSH
47995: LD_VAR 0 1
47999: PPUSH
48000: CALL_OW 264
48004: PUSH
48005: LD_INT 31
48007: PUSH
48008: LD_INT 32
48010: PUSH
48011: LD_INT 51
48013: PUSH
48014: LD_EXP 75
48018: PUSH
48019: LD_INT 12
48021: PUSH
48022: LD_INT 30
48024: PUSH
48025: LD_EXP 74
48029: PUSH
48030: LD_INT 11
48032: PUSH
48033: LD_INT 53
48035: PUSH
48036: LD_INT 14
48038: PUSH
48039: LD_EXP 78
48043: PUSH
48044: LD_INT 29
48046: PUSH
48047: LD_EXP 76
48051: PUSH
48052: LD_INT 13
48054: PUSH
48055: LD_INT 52
48057: PUSH
48058: LD_EXP 80
48062: PUSH
48063: LD_INT 48
48065: PUSH
48066: LD_INT 8
48068: PUSH
48069: EMPTY
48070: LIST
48071: LIST
48072: LIST
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: LIST
48079: LIST
48080: LIST
48081: LIST
48082: LIST
48083: LIST
48084: LIST
48085: LIST
48086: LIST
48087: LIST
48088: IN
48089: NOT
48090: AND
48091: IFFALSE 48139
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48093: LD_ADDR_EXP 117
48097: PUSH
48098: LD_EXP 117
48102: PPUSH
48103: LD_VAR 0 4
48107: PUSH
48108: LD_EXP 117
48112: PUSH
48113: LD_VAR 0 4
48117: ARRAY
48118: PUSH
48119: LD_INT 1
48121: PLUS
48122: PUSH
48123: EMPTY
48124: LIST
48125: LIST
48126: PPUSH
48127: LD_VAR 0 1
48131: PPUSH
48132: CALL 56974 0 3
48136: ST_TO_ADDR
48137: GO 48183
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48139: LD_ADDR_EXP 114
48143: PUSH
48144: LD_EXP 114
48148: PPUSH
48149: LD_VAR 0 4
48153: PUSH
48154: LD_EXP 114
48158: PUSH
48159: LD_VAR 0 4
48163: ARRAY
48164: PUSH
48165: LD_INT 1
48167: PLUS
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: PPUSH
48173: LD_VAR 0 1
48177: PPUSH
48178: CALL 56974 0 3
48182: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48183: LD_VAR 0 1
48187: PPUSH
48188: CALL_OW 263
48192: PUSH
48193: LD_INT 2
48195: EQUAL
48196: IFFALSE 48225
// begin repeat wait ( 0 0$3 ) ;
48198: LD_INT 105
48200: PPUSH
48201: CALL_OW 67
// Connect ( vehicle ) ;
48205: LD_VAR 0 1
48209: PPUSH
48210: CALL 59945 0 1
// until IsControledBy ( vehicle ) ;
48214: LD_VAR 0 1
48218: PPUSH
48219: CALL_OW 312
48223: IFFALSE 48198
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48225: LD_VAR 0 1
48229: PPUSH
48230: LD_EXP 119
48234: PUSH
48235: LD_VAR 0 4
48239: ARRAY
48240: PPUSH
48241: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48245: LD_VAR 0 1
48249: PPUSH
48250: CALL_OW 263
48254: PUSH
48255: LD_INT 1
48257: NONEQUAL
48258: IFFALSE 48262
// break ;
48260: GO 48311
// repeat wait ( 0 0$1 ) ;
48262: LD_INT 35
48264: PPUSH
48265: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48269: LD_VAR 0 1
48273: PPUSH
48274: LD_EXP 119
48278: PUSH
48279: LD_VAR 0 4
48283: ARRAY
48284: PPUSH
48285: CALL_OW 308
48289: IFFALSE 48262
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48291: LD_VAR 0 1
48295: PPUSH
48296: CALL_OW 311
48300: PPUSH
48301: CALL_OW 121
// exit ;
48305: POP
48306: POP
48307: GO 48313
// end ; end ;
48309: GO 47951
48311: POP
48312: POP
// end ;
48313: LD_VAR 0 3
48317: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48318: LD_INT 0
48320: PPUSH
48321: PPUSH
48322: PPUSH
48323: PPUSH
// if not mc_bases or not skirmish then
48324: LD_EXP 95
48328: NOT
48329: PUSH
48330: LD_EXP 93
48334: NOT
48335: OR
48336: IFFALSE 48340
// exit ;
48338: GO 48693
// repeat wait ( 0 0$1 ) ;
48340: LD_INT 35
48342: PPUSH
48343: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48347: LD_VAR 0 2
48351: PPUSH
48352: LD_VAR 0 3
48356: PPUSH
48357: CALL_OW 284
48361: IFFALSE 48340
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48363: LD_VAR 0 2
48367: PPUSH
48368: LD_VAR 0 3
48372: PPUSH
48373: CALL_OW 283
48377: PUSH
48378: LD_INT 4
48380: EQUAL
48381: IFFALSE 48385
// exit ;
48383: GO 48693
// for i = 1 to mc_bases do
48385: LD_ADDR_VAR 0 7
48389: PUSH
48390: DOUBLE
48391: LD_INT 1
48393: DEC
48394: ST_TO_ADDR
48395: LD_EXP 95
48399: PUSH
48400: FOR_TO
48401: IFFALSE 48691
// begin if mc_crates_area [ i ] then
48403: LD_EXP 113
48407: PUSH
48408: LD_VAR 0 7
48412: ARRAY
48413: IFFALSE 48524
// for j in mc_crates_area [ i ] do
48415: LD_ADDR_VAR 0 8
48419: PUSH
48420: LD_EXP 113
48424: PUSH
48425: LD_VAR 0 7
48429: ARRAY
48430: PUSH
48431: FOR_IN
48432: IFFALSE 48522
// if InArea ( x , y , j ) then
48434: LD_VAR 0 2
48438: PPUSH
48439: LD_VAR 0 3
48443: PPUSH
48444: LD_VAR 0 8
48448: PPUSH
48449: CALL_OW 309
48453: IFFALSE 48520
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48455: LD_ADDR_EXP 111
48459: PUSH
48460: LD_EXP 111
48464: PPUSH
48465: LD_VAR 0 7
48469: PUSH
48470: LD_EXP 111
48474: PUSH
48475: LD_VAR 0 7
48479: ARRAY
48480: PUSH
48481: LD_INT 1
48483: PLUS
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: PPUSH
48489: LD_VAR 0 4
48493: PUSH
48494: LD_VAR 0 2
48498: PUSH
48499: LD_VAR 0 3
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: LIST
48508: PPUSH
48509: CALL 56974 0 3
48513: ST_TO_ADDR
// exit ;
48514: POP
48515: POP
48516: POP
48517: POP
48518: GO 48693
// end ;
48520: GO 48431
48522: POP
48523: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48524: LD_ADDR_VAR 0 9
48528: PUSH
48529: LD_EXP 95
48533: PUSH
48534: LD_VAR 0 7
48538: ARRAY
48539: PPUSH
48540: LD_INT 2
48542: PUSH
48543: LD_INT 30
48545: PUSH
48546: LD_INT 0
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 30
48555: PUSH
48556: LD_INT 1
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: PUSH
48563: EMPTY
48564: LIST
48565: LIST
48566: LIST
48567: PPUSH
48568: CALL_OW 72
48572: ST_TO_ADDR
// if not depot then
48573: LD_VAR 0 9
48577: NOT
48578: IFFALSE 48582
// continue ;
48580: GO 48400
// for j in depot do
48582: LD_ADDR_VAR 0 8
48586: PUSH
48587: LD_VAR 0 9
48591: PUSH
48592: FOR_IN
48593: IFFALSE 48687
// if GetDistUnitXY ( j , x , y ) < 30 then
48595: LD_VAR 0 8
48599: PPUSH
48600: LD_VAR 0 2
48604: PPUSH
48605: LD_VAR 0 3
48609: PPUSH
48610: CALL_OW 297
48614: PUSH
48615: LD_INT 30
48617: LESS
48618: IFFALSE 48685
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48620: LD_ADDR_EXP 111
48624: PUSH
48625: LD_EXP 111
48629: PPUSH
48630: LD_VAR 0 7
48634: PUSH
48635: LD_EXP 111
48639: PUSH
48640: LD_VAR 0 7
48644: ARRAY
48645: PUSH
48646: LD_INT 1
48648: PLUS
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: PPUSH
48654: LD_VAR 0 4
48658: PUSH
48659: LD_VAR 0 2
48663: PUSH
48664: LD_VAR 0 3
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: LIST
48673: PPUSH
48674: CALL 56974 0 3
48678: ST_TO_ADDR
// exit ;
48679: POP
48680: POP
48681: POP
48682: POP
48683: GO 48693
// end ;
48685: GO 48592
48687: POP
48688: POP
// end ;
48689: GO 48400
48691: POP
48692: POP
// end ;
48693: LD_VAR 0 6
48697: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48698: LD_INT 0
48700: PPUSH
48701: PPUSH
48702: PPUSH
48703: PPUSH
// if not mc_bases or not skirmish then
48704: LD_EXP 95
48708: NOT
48709: PUSH
48710: LD_EXP 93
48714: NOT
48715: OR
48716: IFFALSE 48720
// exit ;
48718: GO 48997
// side := GetSide ( lab ) ;
48720: LD_ADDR_VAR 0 4
48724: PUSH
48725: LD_VAR 0 2
48729: PPUSH
48730: CALL_OW 255
48734: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48735: LD_VAR 0 4
48739: PUSH
48740: LD_EXP 121
48744: IN
48745: NOT
48746: PUSH
48747: LD_EXP 122
48751: NOT
48752: OR
48753: PUSH
48754: LD_EXP 95
48758: NOT
48759: OR
48760: IFFALSE 48764
// exit ;
48762: GO 48997
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48764: LD_ADDR_EXP 122
48768: PUSH
48769: LD_EXP 122
48773: PPUSH
48774: LD_VAR 0 4
48778: PPUSH
48779: LD_EXP 122
48783: PUSH
48784: LD_VAR 0 4
48788: ARRAY
48789: PUSH
48790: LD_VAR 0 1
48794: DIFF
48795: PPUSH
48796: CALL_OW 1
48800: ST_TO_ADDR
// for i = 1 to mc_bases do
48801: LD_ADDR_VAR 0 5
48805: PUSH
48806: DOUBLE
48807: LD_INT 1
48809: DEC
48810: ST_TO_ADDR
48811: LD_EXP 95
48815: PUSH
48816: FOR_TO
48817: IFFALSE 48995
// begin if lab in mc_bases [ i ] then
48819: LD_VAR 0 2
48823: PUSH
48824: LD_EXP 95
48828: PUSH
48829: LD_VAR 0 5
48833: ARRAY
48834: IN
48835: IFFALSE 48993
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48837: LD_VAR 0 1
48841: PUSH
48842: LD_INT 11
48844: PUSH
48845: LD_INT 4
48847: PUSH
48848: LD_INT 3
48850: PUSH
48851: LD_INT 2
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: LIST
48858: LIST
48859: IN
48860: PUSH
48861: LD_EXP 125
48865: PUSH
48866: LD_VAR 0 5
48870: ARRAY
48871: AND
48872: IFFALSE 48993
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48874: LD_ADDR_VAR 0 6
48878: PUSH
48879: LD_EXP 125
48883: PUSH
48884: LD_VAR 0 5
48888: ARRAY
48889: PUSH
48890: LD_INT 1
48892: ARRAY
48893: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48894: LD_ADDR_EXP 125
48898: PUSH
48899: LD_EXP 125
48903: PPUSH
48904: LD_VAR 0 5
48908: PPUSH
48909: EMPTY
48910: PPUSH
48911: CALL_OW 1
48915: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48916: LD_VAR 0 6
48920: PPUSH
48921: LD_INT 0
48923: PPUSH
48924: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48928: LD_VAR 0 6
48932: PPUSH
48933: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48937: LD_ADDR_EXP 124
48941: PUSH
48942: LD_EXP 124
48946: PPUSH
48947: LD_VAR 0 5
48951: PPUSH
48952: LD_EXP 124
48956: PUSH
48957: LD_VAR 0 5
48961: ARRAY
48962: PPUSH
48963: LD_INT 1
48965: PPUSH
48966: LD_VAR 0 6
48970: PPUSH
48971: CALL_OW 2
48975: PPUSH
48976: CALL_OW 1
48980: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48981: LD_VAR 0 5
48985: PPUSH
48986: LD_INT 112
48988: PPUSH
48989: CALL 25516 0 2
// end ; end ; end ;
48993: GO 48816
48995: POP
48996: POP
// end ;
48997: LD_VAR 0 3
49001: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49002: LD_INT 0
49004: PPUSH
49005: PPUSH
49006: PPUSH
49007: PPUSH
49008: PPUSH
49009: PPUSH
49010: PPUSH
49011: PPUSH
// if not mc_bases or not skirmish then
49012: LD_EXP 95
49016: NOT
49017: PUSH
49018: LD_EXP 93
49022: NOT
49023: OR
49024: IFFALSE 49028
// exit ;
49026: GO 50399
// for i = 1 to mc_bases do
49028: LD_ADDR_VAR 0 3
49032: PUSH
49033: DOUBLE
49034: LD_INT 1
49036: DEC
49037: ST_TO_ADDR
49038: LD_EXP 95
49042: PUSH
49043: FOR_TO
49044: IFFALSE 50397
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49046: LD_VAR 0 1
49050: PUSH
49051: LD_EXP 95
49055: PUSH
49056: LD_VAR 0 3
49060: ARRAY
49061: IN
49062: PUSH
49063: LD_VAR 0 1
49067: PUSH
49068: LD_EXP 102
49072: PUSH
49073: LD_VAR 0 3
49077: ARRAY
49078: IN
49079: OR
49080: PUSH
49081: LD_VAR 0 1
49085: PUSH
49086: LD_EXP 117
49090: PUSH
49091: LD_VAR 0 3
49095: ARRAY
49096: IN
49097: OR
49098: PUSH
49099: LD_VAR 0 1
49103: PUSH
49104: LD_EXP 114
49108: PUSH
49109: LD_VAR 0 3
49113: ARRAY
49114: IN
49115: OR
49116: PUSH
49117: LD_VAR 0 1
49121: PUSH
49122: LD_EXP 124
49126: PUSH
49127: LD_VAR 0 3
49131: ARRAY
49132: IN
49133: OR
49134: PUSH
49135: LD_VAR 0 1
49139: PUSH
49140: LD_EXP 125
49144: PUSH
49145: LD_VAR 0 3
49149: ARRAY
49150: IN
49151: OR
49152: IFFALSE 50395
// begin if un in mc_ape [ i ] then
49154: LD_VAR 0 1
49158: PUSH
49159: LD_EXP 124
49163: PUSH
49164: LD_VAR 0 3
49168: ARRAY
49169: IN
49170: IFFALSE 49209
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49172: LD_ADDR_EXP 124
49176: PUSH
49177: LD_EXP 124
49181: PPUSH
49182: LD_VAR 0 3
49186: PPUSH
49187: LD_EXP 124
49191: PUSH
49192: LD_VAR 0 3
49196: ARRAY
49197: PUSH
49198: LD_VAR 0 1
49202: DIFF
49203: PPUSH
49204: CALL_OW 1
49208: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49209: LD_VAR 0 1
49213: PUSH
49214: LD_EXP 125
49218: PUSH
49219: LD_VAR 0 3
49223: ARRAY
49224: IN
49225: IFFALSE 49249
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49227: LD_ADDR_EXP 125
49231: PUSH
49232: LD_EXP 125
49236: PPUSH
49237: LD_VAR 0 3
49241: PPUSH
49242: EMPTY
49243: PPUSH
49244: CALL_OW 1
49248: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49249: LD_VAR 0 1
49253: PPUSH
49254: CALL_OW 247
49258: PUSH
49259: LD_INT 2
49261: EQUAL
49262: PUSH
49263: LD_VAR 0 1
49267: PPUSH
49268: CALL_OW 110
49272: PUSH
49273: LD_INT 20
49275: EQUAL
49276: PUSH
49277: LD_VAR 0 1
49281: PUSH
49282: LD_EXP 117
49286: PUSH
49287: LD_VAR 0 3
49291: ARRAY
49292: IN
49293: OR
49294: PUSH
49295: LD_VAR 0 1
49299: PPUSH
49300: CALL_OW 264
49304: PUSH
49305: LD_INT 12
49307: PUSH
49308: LD_INT 51
49310: PUSH
49311: LD_EXP 75
49315: PUSH
49316: LD_INT 32
49318: PUSH
49319: LD_INT 13
49321: PUSH
49322: LD_INT 52
49324: PUSH
49325: LD_INT 31
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: IN
49337: OR
49338: AND
49339: IFFALSE 49647
// begin if un in mc_defender [ i ] then
49341: LD_VAR 0 1
49345: PUSH
49346: LD_EXP 117
49350: PUSH
49351: LD_VAR 0 3
49355: ARRAY
49356: IN
49357: IFFALSE 49396
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49359: LD_ADDR_EXP 117
49363: PUSH
49364: LD_EXP 117
49368: PPUSH
49369: LD_VAR 0 3
49373: PPUSH
49374: LD_EXP 117
49378: PUSH
49379: LD_VAR 0 3
49383: ARRAY
49384: PUSH
49385: LD_VAR 0 1
49389: DIFF
49390: PPUSH
49391: CALL_OW 1
49395: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49396: LD_ADDR_VAR 0 8
49400: PUSH
49401: LD_VAR 0 3
49405: PPUSH
49406: LD_INT 3
49408: PPUSH
49409: CALL 46037 0 2
49413: ST_TO_ADDR
// if fac then
49414: LD_VAR 0 8
49418: IFFALSE 49647
// begin for j in fac do
49420: LD_ADDR_VAR 0 4
49424: PUSH
49425: LD_VAR 0 8
49429: PUSH
49430: FOR_IN
49431: IFFALSE 49645
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49433: LD_ADDR_VAR 0 9
49437: PUSH
49438: LD_VAR 0 8
49442: PPUSH
49443: LD_VAR 0 1
49447: PPUSH
49448: CALL_OW 265
49452: PPUSH
49453: LD_VAR 0 1
49457: PPUSH
49458: CALL_OW 262
49462: PPUSH
49463: LD_VAR 0 1
49467: PPUSH
49468: CALL_OW 263
49472: PPUSH
49473: LD_VAR 0 1
49477: PPUSH
49478: CALL_OW 264
49482: PPUSH
49483: CALL 54470 0 5
49487: ST_TO_ADDR
// if components then
49488: LD_VAR 0 9
49492: IFFALSE 49643
// begin if GetWeapon ( un ) = ar_control_tower then
49494: LD_VAR 0 1
49498: PPUSH
49499: CALL_OW 264
49503: PUSH
49504: LD_INT 31
49506: EQUAL
49507: IFFALSE 49624
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49509: LD_VAR 0 1
49513: PPUSH
49514: CALL_OW 311
49518: PPUSH
49519: LD_INT 0
49521: PPUSH
49522: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49526: LD_ADDR_EXP 135
49530: PUSH
49531: LD_EXP 135
49535: PPUSH
49536: LD_VAR 0 3
49540: PPUSH
49541: LD_EXP 135
49545: PUSH
49546: LD_VAR 0 3
49550: ARRAY
49551: PUSH
49552: LD_VAR 0 1
49556: PPUSH
49557: CALL_OW 311
49561: DIFF
49562: PPUSH
49563: CALL_OW 1
49567: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49568: LD_ADDR_VAR 0 7
49572: PUSH
49573: LD_EXP 116
49577: PUSH
49578: LD_VAR 0 3
49582: ARRAY
49583: PPUSH
49584: LD_INT 1
49586: PPUSH
49587: LD_VAR 0 9
49591: PPUSH
49592: CALL_OW 2
49596: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49597: LD_ADDR_EXP 116
49601: PUSH
49602: LD_EXP 116
49606: PPUSH
49607: LD_VAR 0 3
49611: PPUSH
49612: LD_VAR 0 7
49616: PPUSH
49617: CALL_OW 1
49621: ST_TO_ADDR
// end else
49622: GO 49641
// MC_InsertProduceList ( i , [ components ] ) ;
49624: LD_VAR 0 3
49628: PPUSH
49629: LD_VAR 0 9
49633: PUSH
49634: EMPTY
49635: LIST
49636: PPUSH
49637: CALL 45582 0 2
// break ;
49641: GO 49645
// end ; end ;
49643: GO 49430
49645: POP
49646: POP
// end ; end ; if GetType ( un ) = unit_building then
49647: LD_VAR 0 1
49651: PPUSH
49652: CALL_OW 247
49656: PUSH
49657: LD_INT 3
49659: EQUAL
49660: IFFALSE 50063
// begin btype := GetBType ( un ) ;
49662: LD_ADDR_VAR 0 5
49666: PUSH
49667: LD_VAR 0 1
49671: PPUSH
49672: CALL_OW 266
49676: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49677: LD_VAR 0 5
49681: PUSH
49682: LD_INT 29
49684: PUSH
49685: LD_INT 30
49687: PUSH
49688: EMPTY
49689: LIST
49690: LIST
49691: IN
49692: IFFALSE 49765
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49694: LD_VAR 0 1
49698: PPUSH
49699: CALL_OW 250
49703: PPUSH
49704: LD_VAR 0 1
49708: PPUSH
49709: CALL_OW 251
49713: PPUSH
49714: LD_VAR 0 1
49718: PPUSH
49719: CALL_OW 255
49723: PPUSH
49724: CALL_OW 440
49728: NOT
49729: IFFALSE 49765
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49731: LD_VAR 0 1
49735: PPUSH
49736: CALL_OW 250
49740: PPUSH
49741: LD_VAR 0 1
49745: PPUSH
49746: CALL_OW 251
49750: PPUSH
49751: LD_VAR 0 1
49755: PPUSH
49756: CALL_OW 255
49760: PPUSH
49761: CALL_OW 441
// end ; if btype = b_warehouse then
49765: LD_VAR 0 5
49769: PUSH
49770: LD_INT 1
49772: EQUAL
49773: IFFALSE 49791
// begin btype := b_depot ;
49775: LD_ADDR_VAR 0 5
49779: PUSH
49780: LD_INT 0
49782: ST_TO_ADDR
// pos := 1 ;
49783: LD_ADDR_VAR 0 6
49787: PUSH
49788: LD_INT 1
49790: ST_TO_ADDR
// end ; if btype = b_factory then
49791: LD_VAR 0 5
49795: PUSH
49796: LD_INT 3
49798: EQUAL
49799: IFFALSE 49817
// begin btype := b_workshop ;
49801: LD_ADDR_VAR 0 5
49805: PUSH
49806: LD_INT 2
49808: ST_TO_ADDR
// pos := 1 ;
49809: LD_ADDR_VAR 0 6
49813: PUSH
49814: LD_INT 1
49816: ST_TO_ADDR
// end ; if btype = b_barracks then
49817: LD_VAR 0 5
49821: PUSH
49822: LD_INT 5
49824: EQUAL
49825: IFFALSE 49835
// btype := b_armoury ;
49827: LD_ADDR_VAR 0 5
49831: PUSH
49832: LD_INT 4
49834: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49835: LD_VAR 0 5
49839: PUSH
49840: LD_INT 7
49842: PUSH
49843: LD_INT 8
49845: PUSH
49846: EMPTY
49847: LIST
49848: LIST
49849: IN
49850: IFFALSE 49860
// btype := b_lab ;
49852: LD_ADDR_VAR 0 5
49856: PUSH
49857: LD_INT 6
49859: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49860: LD_ADDR_EXP 100
49864: PUSH
49865: LD_EXP 100
49869: PPUSH
49870: LD_VAR 0 3
49874: PUSH
49875: LD_EXP 100
49879: PUSH
49880: LD_VAR 0 3
49884: ARRAY
49885: PUSH
49886: LD_INT 1
49888: PLUS
49889: PUSH
49890: EMPTY
49891: LIST
49892: LIST
49893: PPUSH
49894: LD_VAR 0 5
49898: PUSH
49899: LD_VAR 0 1
49903: PPUSH
49904: CALL_OW 250
49908: PUSH
49909: LD_VAR 0 1
49913: PPUSH
49914: CALL_OW 251
49918: PUSH
49919: LD_VAR 0 1
49923: PPUSH
49924: CALL_OW 254
49928: PUSH
49929: EMPTY
49930: LIST
49931: LIST
49932: LIST
49933: LIST
49934: PPUSH
49935: CALL 56974 0 3
49939: ST_TO_ADDR
// if pos = 1 then
49940: LD_VAR 0 6
49944: PUSH
49945: LD_INT 1
49947: EQUAL
49948: IFFALSE 50063
// begin tmp := mc_build_list [ i ] ;
49950: LD_ADDR_VAR 0 7
49954: PUSH
49955: LD_EXP 100
49959: PUSH
49960: LD_VAR 0 3
49964: ARRAY
49965: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49966: LD_VAR 0 7
49970: PPUSH
49971: LD_INT 2
49973: PUSH
49974: LD_INT 30
49976: PUSH
49977: LD_INT 0
49979: PUSH
49980: EMPTY
49981: LIST
49982: LIST
49983: PUSH
49984: LD_INT 30
49986: PUSH
49987: LD_INT 1
49989: PUSH
49990: EMPTY
49991: LIST
49992: LIST
49993: PUSH
49994: EMPTY
49995: LIST
49996: LIST
49997: LIST
49998: PPUSH
49999: CALL_OW 72
50003: IFFALSE 50013
// pos := 2 ;
50005: LD_ADDR_VAR 0 6
50009: PUSH
50010: LD_INT 2
50012: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50013: LD_ADDR_VAR 0 7
50017: PUSH
50018: LD_VAR 0 7
50022: PPUSH
50023: LD_VAR 0 6
50027: PPUSH
50028: LD_VAR 0 7
50032: PPUSH
50033: CALL 57300 0 3
50037: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50038: LD_ADDR_EXP 100
50042: PUSH
50043: LD_EXP 100
50047: PPUSH
50048: LD_VAR 0 3
50052: PPUSH
50053: LD_VAR 0 7
50057: PPUSH
50058: CALL_OW 1
50062: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50063: LD_VAR 0 1
50067: PUSH
50068: LD_EXP 95
50072: PUSH
50073: LD_VAR 0 3
50077: ARRAY
50078: IN
50079: IFFALSE 50118
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50081: LD_ADDR_EXP 95
50085: PUSH
50086: LD_EXP 95
50090: PPUSH
50091: LD_VAR 0 3
50095: PPUSH
50096: LD_EXP 95
50100: PUSH
50101: LD_VAR 0 3
50105: ARRAY
50106: PUSH
50107: LD_VAR 0 1
50111: DIFF
50112: PPUSH
50113: CALL_OW 1
50117: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50118: LD_VAR 0 1
50122: PUSH
50123: LD_EXP 102
50127: PUSH
50128: LD_VAR 0 3
50132: ARRAY
50133: IN
50134: IFFALSE 50173
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50136: LD_ADDR_EXP 102
50140: PUSH
50141: LD_EXP 102
50145: PPUSH
50146: LD_VAR 0 3
50150: PPUSH
50151: LD_EXP 102
50155: PUSH
50156: LD_VAR 0 3
50160: ARRAY
50161: PUSH
50162: LD_VAR 0 1
50166: DIFF
50167: PPUSH
50168: CALL_OW 1
50172: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50173: LD_VAR 0 1
50177: PUSH
50178: LD_EXP 114
50182: PUSH
50183: LD_VAR 0 3
50187: ARRAY
50188: IN
50189: IFFALSE 50228
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50191: LD_ADDR_EXP 114
50195: PUSH
50196: LD_EXP 114
50200: PPUSH
50201: LD_VAR 0 3
50205: PPUSH
50206: LD_EXP 114
50210: PUSH
50211: LD_VAR 0 3
50215: ARRAY
50216: PUSH
50217: LD_VAR 0 1
50221: DIFF
50222: PPUSH
50223: CALL_OW 1
50227: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50228: LD_VAR 0 1
50232: PUSH
50233: LD_EXP 117
50237: PUSH
50238: LD_VAR 0 3
50242: ARRAY
50243: IN
50244: IFFALSE 50283
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50246: LD_ADDR_EXP 117
50250: PUSH
50251: LD_EXP 117
50255: PPUSH
50256: LD_VAR 0 3
50260: PPUSH
50261: LD_EXP 117
50265: PUSH
50266: LD_VAR 0 3
50270: ARRAY
50271: PUSH
50272: LD_VAR 0 1
50276: DIFF
50277: PPUSH
50278: CALL_OW 1
50282: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50283: LD_VAR 0 1
50287: PUSH
50288: LD_EXP 104
50292: PUSH
50293: LD_VAR 0 3
50297: ARRAY
50298: IN
50299: IFFALSE 50338
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50301: LD_ADDR_EXP 104
50305: PUSH
50306: LD_EXP 104
50310: PPUSH
50311: LD_VAR 0 3
50315: PPUSH
50316: LD_EXP 104
50320: PUSH
50321: LD_VAR 0 3
50325: ARRAY
50326: PUSH
50327: LD_VAR 0 1
50331: DIFF
50332: PPUSH
50333: CALL_OW 1
50337: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50338: LD_VAR 0 1
50342: PUSH
50343: LD_EXP 103
50347: PUSH
50348: LD_VAR 0 3
50352: ARRAY
50353: IN
50354: IFFALSE 50393
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50356: LD_ADDR_EXP 103
50360: PUSH
50361: LD_EXP 103
50365: PPUSH
50366: LD_VAR 0 3
50370: PPUSH
50371: LD_EXP 103
50375: PUSH
50376: LD_VAR 0 3
50380: ARRAY
50381: PUSH
50382: LD_VAR 0 1
50386: DIFF
50387: PPUSH
50388: CALL_OW 1
50392: ST_TO_ADDR
// end ; break ;
50393: GO 50397
// end ;
50395: GO 49043
50397: POP
50398: POP
// end ;
50399: LD_VAR 0 2
50403: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50404: LD_INT 0
50406: PPUSH
50407: PPUSH
50408: PPUSH
// if not mc_bases or not skirmish then
50409: LD_EXP 95
50413: NOT
50414: PUSH
50415: LD_EXP 93
50419: NOT
50420: OR
50421: IFFALSE 50425
// exit ;
50423: GO 50640
// for i = 1 to mc_bases do
50425: LD_ADDR_VAR 0 3
50429: PUSH
50430: DOUBLE
50431: LD_INT 1
50433: DEC
50434: ST_TO_ADDR
50435: LD_EXP 95
50439: PUSH
50440: FOR_TO
50441: IFFALSE 50638
// begin if building in mc_construct_list [ i ] then
50443: LD_VAR 0 1
50447: PUSH
50448: LD_EXP 102
50452: PUSH
50453: LD_VAR 0 3
50457: ARRAY
50458: IN
50459: IFFALSE 50636
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50461: LD_ADDR_EXP 102
50465: PUSH
50466: LD_EXP 102
50470: PPUSH
50471: LD_VAR 0 3
50475: PPUSH
50476: LD_EXP 102
50480: PUSH
50481: LD_VAR 0 3
50485: ARRAY
50486: PUSH
50487: LD_VAR 0 1
50491: DIFF
50492: PPUSH
50493: CALL_OW 1
50497: ST_TO_ADDR
// if building in mc_lab [ i ] then
50498: LD_VAR 0 1
50502: PUSH
50503: LD_EXP 128
50507: PUSH
50508: LD_VAR 0 3
50512: ARRAY
50513: IN
50514: IFFALSE 50569
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50516: LD_ADDR_EXP 129
50520: PUSH
50521: LD_EXP 129
50525: PPUSH
50526: LD_VAR 0 3
50530: PPUSH
50531: LD_EXP 129
50535: PUSH
50536: LD_VAR 0 3
50540: ARRAY
50541: PPUSH
50542: LD_INT 1
50544: PPUSH
50545: LD_EXP 129
50549: PUSH
50550: LD_VAR 0 3
50554: ARRAY
50555: PPUSH
50556: LD_INT 0
50558: PPUSH
50559: CALL 56392 0 4
50563: PPUSH
50564: CALL_OW 1
50568: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50569: LD_VAR 0 1
50573: PUSH
50574: LD_EXP 95
50578: PUSH
50579: LD_VAR 0 3
50583: ARRAY
50584: IN
50585: NOT
50586: IFFALSE 50632
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50588: LD_ADDR_EXP 95
50592: PUSH
50593: LD_EXP 95
50597: PPUSH
50598: LD_VAR 0 3
50602: PUSH
50603: LD_EXP 95
50607: PUSH
50608: LD_VAR 0 3
50612: ARRAY
50613: PUSH
50614: LD_INT 1
50616: PLUS
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: PPUSH
50622: LD_VAR 0 1
50626: PPUSH
50627: CALL 56974 0 3
50631: ST_TO_ADDR
// exit ;
50632: POP
50633: POP
50634: GO 50640
// end ; end ;
50636: GO 50440
50638: POP
50639: POP
// end ;
50640: LD_VAR 0 2
50644: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50645: LD_INT 0
50647: PPUSH
50648: PPUSH
50649: PPUSH
50650: PPUSH
50651: PPUSH
50652: PPUSH
50653: PPUSH
// if not mc_bases or not skirmish then
50654: LD_EXP 95
50658: NOT
50659: PUSH
50660: LD_EXP 93
50664: NOT
50665: OR
50666: IFFALSE 50670
// exit ;
50668: GO 51331
// for i = 1 to mc_bases do
50670: LD_ADDR_VAR 0 3
50674: PUSH
50675: DOUBLE
50676: LD_INT 1
50678: DEC
50679: ST_TO_ADDR
50680: LD_EXP 95
50684: PUSH
50685: FOR_TO
50686: IFFALSE 51329
// begin if building in mc_construct_list [ i ] then
50688: LD_VAR 0 1
50692: PUSH
50693: LD_EXP 102
50697: PUSH
50698: LD_VAR 0 3
50702: ARRAY
50703: IN
50704: IFFALSE 51327
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50706: LD_ADDR_EXP 102
50710: PUSH
50711: LD_EXP 102
50715: PPUSH
50716: LD_VAR 0 3
50720: PPUSH
50721: LD_EXP 102
50725: PUSH
50726: LD_VAR 0 3
50730: ARRAY
50731: PUSH
50732: LD_VAR 0 1
50736: DIFF
50737: PPUSH
50738: CALL_OW 1
50742: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50743: LD_ADDR_EXP 95
50747: PUSH
50748: LD_EXP 95
50752: PPUSH
50753: LD_VAR 0 3
50757: PUSH
50758: LD_EXP 95
50762: PUSH
50763: LD_VAR 0 3
50767: ARRAY
50768: PUSH
50769: LD_INT 1
50771: PLUS
50772: PUSH
50773: EMPTY
50774: LIST
50775: LIST
50776: PPUSH
50777: LD_VAR 0 1
50781: PPUSH
50782: CALL 56974 0 3
50786: ST_TO_ADDR
// btype := GetBType ( building ) ;
50787: LD_ADDR_VAR 0 5
50791: PUSH
50792: LD_VAR 0 1
50796: PPUSH
50797: CALL_OW 266
50801: ST_TO_ADDR
// side := GetSide ( building ) ;
50802: LD_ADDR_VAR 0 8
50806: PUSH
50807: LD_VAR 0 1
50811: PPUSH
50812: CALL_OW 255
50816: ST_TO_ADDR
// if btype = b_lab then
50817: LD_VAR 0 5
50821: PUSH
50822: LD_INT 6
50824: EQUAL
50825: IFFALSE 50875
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50827: LD_ADDR_EXP 128
50831: PUSH
50832: LD_EXP 128
50836: PPUSH
50837: LD_VAR 0 3
50841: PUSH
50842: LD_EXP 128
50846: PUSH
50847: LD_VAR 0 3
50851: ARRAY
50852: PUSH
50853: LD_INT 1
50855: PLUS
50856: PUSH
50857: EMPTY
50858: LIST
50859: LIST
50860: PPUSH
50861: LD_VAR 0 1
50865: PPUSH
50866: CALL 56974 0 3
50870: ST_TO_ADDR
// exit ;
50871: POP
50872: POP
50873: GO 51331
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50875: LD_VAR 0 5
50879: PUSH
50880: LD_INT 0
50882: PUSH
50883: LD_INT 2
50885: PUSH
50886: LD_INT 4
50888: PUSH
50889: EMPTY
50890: LIST
50891: LIST
50892: LIST
50893: IN
50894: IFFALSE 51018
// begin if btype = b_armoury then
50896: LD_VAR 0 5
50900: PUSH
50901: LD_INT 4
50903: EQUAL
50904: IFFALSE 50914
// btype := b_barracks ;
50906: LD_ADDR_VAR 0 5
50910: PUSH
50911: LD_INT 5
50913: ST_TO_ADDR
// if btype = b_depot then
50914: LD_VAR 0 5
50918: PUSH
50919: LD_INT 0
50921: EQUAL
50922: IFFALSE 50932
// btype := b_warehouse ;
50924: LD_ADDR_VAR 0 5
50928: PUSH
50929: LD_INT 1
50931: ST_TO_ADDR
// if btype = b_workshop then
50932: LD_VAR 0 5
50936: PUSH
50937: LD_INT 2
50939: EQUAL
50940: IFFALSE 50950
// btype := b_factory ;
50942: LD_ADDR_VAR 0 5
50946: PUSH
50947: LD_INT 3
50949: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50950: LD_VAR 0 5
50954: PPUSH
50955: LD_VAR 0 8
50959: PPUSH
50960: CALL_OW 323
50964: PUSH
50965: LD_INT 1
50967: EQUAL
50968: IFFALSE 51014
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50970: LD_ADDR_EXP 127
50974: PUSH
50975: LD_EXP 127
50979: PPUSH
50980: LD_VAR 0 3
50984: PUSH
50985: LD_EXP 127
50989: PUSH
50990: LD_VAR 0 3
50994: ARRAY
50995: PUSH
50996: LD_INT 1
50998: PLUS
50999: PUSH
51000: EMPTY
51001: LIST
51002: LIST
51003: PPUSH
51004: LD_VAR 0 1
51008: PPUSH
51009: CALL 56974 0 3
51013: ST_TO_ADDR
// exit ;
51014: POP
51015: POP
51016: GO 51331
// end ; if btype in [ b_bunker , b_turret ] then
51018: LD_VAR 0 5
51022: PUSH
51023: LD_INT 32
51025: PUSH
51026: LD_INT 33
51028: PUSH
51029: EMPTY
51030: LIST
51031: LIST
51032: IN
51033: IFFALSE 51323
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51035: LD_ADDR_EXP 103
51039: PUSH
51040: LD_EXP 103
51044: PPUSH
51045: LD_VAR 0 3
51049: PUSH
51050: LD_EXP 103
51054: PUSH
51055: LD_VAR 0 3
51059: ARRAY
51060: PUSH
51061: LD_INT 1
51063: PLUS
51064: PUSH
51065: EMPTY
51066: LIST
51067: LIST
51068: PPUSH
51069: LD_VAR 0 1
51073: PPUSH
51074: CALL 56974 0 3
51078: ST_TO_ADDR
// if btype = b_bunker then
51079: LD_VAR 0 5
51083: PUSH
51084: LD_INT 32
51086: EQUAL
51087: IFFALSE 51323
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51089: LD_ADDR_EXP 104
51093: PUSH
51094: LD_EXP 104
51098: PPUSH
51099: LD_VAR 0 3
51103: PUSH
51104: LD_EXP 104
51108: PUSH
51109: LD_VAR 0 3
51113: ARRAY
51114: PUSH
51115: LD_INT 1
51117: PLUS
51118: PUSH
51119: EMPTY
51120: LIST
51121: LIST
51122: PPUSH
51123: LD_VAR 0 1
51127: PPUSH
51128: CALL 56974 0 3
51132: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51133: LD_ADDR_VAR 0 6
51137: PUSH
51138: LD_EXP 95
51142: PUSH
51143: LD_VAR 0 3
51147: ARRAY
51148: PPUSH
51149: LD_INT 25
51151: PUSH
51152: LD_INT 1
51154: PUSH
51155: EMPTY
51156: LIST
51157: LIST
51158: PUSH
51159: LD_INT 3
51161: PUSH
51162: LD_INT 54
51164: PUSH
51165: EMPTY
51166: LIST
51167: PUSH
51168: EMPTY
51169: LIST
51170: LIST
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: PPUSH
51176: CALL_OW 72
51180: ST_TO_ADDR
// if tmp then
51181: LD_VAR 0 6
51185: IFFALSE 51191
// exit ;
51187: POP
51188: POP
51189: GO 51331
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51191: LD_ADDR_VAR 0 6
51195: PUSH
51196: LD_EXP 95
51200: PUSH
51201: LD_VAR 0 3
51205: ARRAY
51206: PPUSH
51207: LD_INT 2
51209: PUSH
51210: LD_INT 30
51212: PUSH
51213: LD_INT 4
51215: PUSH
51216: EMPTY
51217: LIST
51218: LIST
51219: PUSH
51220: LD_INT 30
51222: PUSH
51223: LD_INT 5
51225: PUSH
51226: EMPTY
51227: LIST
51228: LIST
51229: PUSH
51230: EMPTY
51231: LIST
51232: LIST
51233: LIST
51234: PPUSH
51235: CALL_OW 72
51239: ST_TO_ADDR
// if not tmp then
51240: LD_VAR 0 6
51244: NOT
51245: IFFALSE 51251
// exit ;
51247: POP
51248: POP
51249: GO 51331
// for j in tmp do
51251: LD_ADDR_VAR 0 4
51255: PUSH
51256: LD_VAR 0 6
51260: PUSH
51261: FOR_IN
51262: IFFALSE 51321
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51264: LD_ADDR_VAR 0 7
51268: PUSH
51269: LD_VAR 0 4
51273: PPUSH
51274: CALL_OW 313
51278: PPUSH
51279: LD_INT 25
51281: PUSH
51282: LD_INT 1
51284: PUSH
51285: EMPTY
51286: LIST
51287: LIST
51288: PPUSH
51289: CALL_OW 72
51293: ST_TO_ADDR
// if units then
51294: LD_VAR 0 7
51298: IFFALSE 51319
// begin ComExitBuilding ( units [ 1 ] ) ;
51300: LD_VAR 0 7
51304: PUSH
51305: LD_INT 1
51307: ARRAY
51308: PPUSH
51309: CALL_OW 122
// exit ;
51313: POP
51314: POP
51315: POP
51316: POP
51317: GO 51331
// end ; end ;
51319: GO 51261
51321: POP
51322: POP
// end ; end ; exit ;
51323: POP
51324: POP
51325: GO 51331
// end ; end ;
51327: GO 50685
51329: POP
51330: POP
// end ;
51331: LD_VAR 0 2
51335: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51336: LD_INT 0
51338: PPUSH
51339: PPUSH
51340: PPUSH
51341: PPUSH
51342: PPUSH
51343: PPUSH
51344: PPUSH
// if not mc_bases or not skirmish then
51345: LD_EXP 95
51349: NOT
51350: PUSH
51351: LD_EXP 93
51355: NOT
51356: OR
51357: IFFALSE 51361
// exit ;
51359: GO 51626
// btype := GetBType ( building ) ;
51361: LD_ADDR_VAR 0 6
51365: PUSH
51366: LD_VAR 0 1
51370: PPUSH
51371: CALL_OW 266
51375: ST_TO_ADDR
// x := GetX ( building ) ;
51376: LD_ADDR_VAR 0 7
51380: PUSH
51381: LD_VAR 0 1
51385: PPUSH
51386: CALL_OW 250
51390: ST_TO_ADDR
// y := GetY ( building ) ;
51391: LD_ADDR_VAR 0 8
51395: PUSH
51396: LD_VAR 0 1
51400: PPUSH
51401: CALL_OW 251
51405: ST_TO_ADDR
// d := GetDir ( building ) ;
51406: LD_ADDR_VAR 0 9
51410: PUSH
51411: LD_VAR 0 1
51415: PPUSH
51416: CALL_OW 254
51420: ST_TO_ADDR
// for i = 1 to mc_bases do
51421: LD_ADDR_VAR 0 4
51425: PUSH
51426: DOUBLE
51427: LD_INT 1
51429: DEC
51430: ST_TO_ADDR
51431: LD_EXP 95
51435: PUSH
51436: FOR_TO
51437: IFFALSE 51624
// begin if not mc_build_list [ i ] then
51439: LD_EXP 100
51443: PUSH
51444: LD_VAR 0 4
51448: ARRAY
51449: NOT
51450: IFFALSE 51454
// continue ;
51452: GO 51436
// for j := 1 to mc_build_list [ i ] do
51454: LD_ADDR_VAR 0 5
51458: PUSH
51459: DOUBLE
51460: LD_INT 1
51462: DEC
51463: ST_TO_ADDR
51464: LD_EXP 100
51468: PUSH
51469: LD_VAR 0 4
51473: ARRAY
51474: PUSH
51475: FOR_TO
51476: IFFALSE 51620
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51478: LD_VAR 0 6
51482: PUSH
51483: LD_VAR 0 7
51487: PUSH
51488: LD_VAR 0 8
51492: PUSH
51493: LD_VAR 0 9
51497: PUSH
51498: EMPTY
51499: LIST
51500: LIST
51501: LIST
51502: LIST
51503: PPUSH
51504: LD_EXP 100
51508: PUSH
51509: LD_VAR 0 4
51513: ARRAY
51514: PUSH
51515: LD_VAR 0 5
51519: ARRAY
51520: PPUSH
51521: CALL 63156 0 2
51525: IFFALSE 51618
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51527: LD_ADDR_EXP 100
51531: PUSH
51532: LD_EXP 100
51536: PPUSH
51537: LD_VAR 0 4
51541: PPUSH
51542: LD_EXP 100
51546: PUSH
51547: LD_VAR 0 4
51551: ARRAY
51552: PPUSH
51553: LD_VAR 0 5
51557: PPUSH
51558: CALL_OW 3
51562: PPUSH
51563: CALL_OW 1
51567: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51568: LD_ADDR_EXP 102
51572: PUSH
51573: LD_EXP 102
51577: PPUSH
51578: LD_VAR 0 4
51582: PUSH
51583: LD_EXP 102
51587: PUSH
51588: LD_VAR 0 4
51592: ARRAY
51593: PUSH
51594: LD_INT 1
51596: PLUS
51597: PUSH
51598: EMPTY
51599: LIST
51600: LIST
51601: PPUSH
51602: LD_VAR 0 1
51606: PPUSH
51607: CALL 56974 0 3
51611: ST_TO_ADDR
// exit ;
51612: POP
51613: POP
51614: POP
51615: POP
51616: GO 51626
// end ;
51618: GO 51475
51620: POP
51621: POP
// end ;
51622: GO 51436
51624: POP
51625: POP
// end ;
51626: LD_VAR 0 3
51630: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51631: LD_INT 0
51633: PPUSH
51634: PPUSH
51635: PPUSH
// if not mc_bases or not skirmish then
51636: LD_EXP 95
51640: NOT
51641: PUSH
51642: LD_EXP 93
51646: NOT
51647: OR
51648: IFFALSE 51652
// exit ;
51650: GO 51842
// for i = 1 to mc_bases do
51652: LD_ADDR_VAR 0 4
51656: PUSH
51657: DOUBLE
51658: LD_INT 1
51660: DEC
51661: ST_TO_ADDR
51662: LD_EXP 95
51666: PUSH
51667: FOR_TO
51668: IFFALSE 51755
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51670: LD_VAR 0 1
51674: PUSH
51675: LD_EXP 103
51679: PUSH
51680: LD_VAR 0 4
51684: ARRAY
51685: IN
51686: PUSH
51687: LD_VAR 0 1
51691: PUSH
51692: LD_EXP 104
51696: PUSH
51697: LD_VAR 0 4
51701: ARRAY
51702: IN
51703: NOT
51704: AND
51705: IFFALSE 51753
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51707: LD_ADDR_EXP 104
51711: PUSH
51712: LD_EXP 104
51716: PPUSH
51717: LD_VAR 0 4
51721: PUSH
51722: LD_EXP 104
51726: PUSH
51727: LD_VAR 0 4
51731: ARRAY
51732: PUSH
51733: LD_INT 1
51735: PLUS
51736: PUSH
51737: EMPTY
51738: LIST
51739: LIST
51740: PPUSH
51741: LD_VAR 0 1
51745: PPUSH
51746: CALL 56974 0 3
51750: ST_TO_ADDR
// break ;
51751: GO 51755
// end ; end ;
51753: GO 51667
51755: POP
51756: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51757: LD_VAR 0 1
51761: PPUSH
51762: CALL_OW 257
51766: PUSH
51767: LD_EXP 121
51771: IN
51772: PUSH
51773: LD_VAR 0 1
51777: PPUSH
51778: CALL_OW 266
51782: PUSH
51783: LD_INT 5
51785: EQUAL
51786: AND
51787: PUSH
51788: LD_VAR 0 2
51792: PPUSH
51793: CALL_OW 110
51797: PUSH
51798: LD_INT 18
51800: NONEQUAL
51801: AND
51802: IFFALSE 51842
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51804: LD_VAR 0 2
51808: PPUSH
51809: CALL_OW 257
51813: PUSH
51814: LD_INT 5
51816: PUSH
51817: LD_INT 8
51819: PUSH
51820: LD_INT 9
51822: PUSH
51823: EMPTY
51824: LIST
51825: LIST
51826: LIST
51827: IN
51828: IFFALSE 51842
// SetClass ( unit , 1 ) ;
51830: LD_VAR 0 2
51834: PPUSH
51835: LD_INT 1
51837: PPUSH
51838: CALL_OW 336
// end ;
51842: LD_VAR 0 3
51846: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51847: LD_INT 0
51849: PPUSH
51850: PPUSH
// if not mc_bases or not skirmish then
51851: LD_EXP 95
51855: NOT
51856: PUSH
51857: LD_EXP 93
51861: NOT
51862: OR
51863: IFFALSE 51867
// exit ;
51865: GO 51983
// if GetLives ( abandoned_vehicle ) > 250 then
51867: LD_VAR 0 2
51871: PPUSH
51872: CALL_OW 256
51876: PUSH
51877: LD_INT 250
51879: GREATER
51880: IFFALSE 51884
// exit ;
51882: GO 51983
// for i = 1 to mc_bases do
51884: LD_ADDR_VAR 0 6
51888: PUSH
51889: DOUBLE
51890: LD_INT 1
51892: DEC
51893: ST_TO_ADDR
51894: LD_EXP 95
51898: PUSH
51899: FOR_TO
51900: IFFALSE 51981
// begin if driver in mc_bases [ i ] then
51902: LD_VAR 0 1
51906: PUSH
51907: LD_EXP 95
51911: PUSH
51912: LD_VAR 0 6
51916: ARRAY
51917: IN
51918: IFFALSE 51979
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51920: LD_VAR 0 1
51924: PPUSH
51925: LD_EXP 95
51929: PUSH
51930: LD_VAR 0 6
51934: ARRAY
51935: PPUSH
51936: LD_INT 2
51938: PUSH
51939: LD_INT 30
51941: PUSH
51942: LD_INT 0
51944: PUSH
51945: EMPTY
51946: LIST
51947: LIST
51948: PUSH
51949: LD_INT 30
51951: PUSH
51952: LD_INT 1
51954: PUSH
51955: EMPTY
51956: LIST
51957: LIST
51958: PUSH
51959: EMPTY
51960: LIST
51961: LIST
51962: LIST
51963: PPUSH
51964: CALL_OW 72
51968: PUSH
51969: LD_INT 1
51971: ARRAY
51972: PPUSH
51973: CALL 89592 0 2
// break ;
51977: GO 51981
// end ; end ;
51979: GO 51899
51981: POP
51982: POP
// end ; end_of_file
51983: LD_VAR 0 5
51987: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51988: LD_INT 0
51990: PPUSH
51991: PPUSH
// if exist_mode then
51992: LD_VAR 0 2
51996: IFFALSE 52021
// unit := CreateCharacter ( prefix & ident ) else
51998: LD_ADDR_VAR 0 5
52002: PUSH
52003: LD_VAR 0 3
52007: PUSH
52008: LD_VAR 0 1
52012: STR
52013: PPUSH
52014: CALL_OW 34
52018: ST_TO_ADDR
52019: GO 52036
// unit := NewCharacter ( ident ) ;
52021: LD_ADDR_VAR 0 5
52025: PUSH
52026: LD_VAR 0 1
52030: PPUSH
52031: CALL_OW 25
52035: ST_TO_ADDR
// result := unit ;
52036: LD_ADDR_VAR 0 4
52040: PUSH
52041: LD_VAR 0 5
52045: ST_TO_ADDR
// end ;
52046: LD_VAR 0 4
52050: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52051: LD_INT 0
52053: PPUSH
52054: PPUSH
// if not side or not nation then
52055: LD_VAR 0 1
52059: NOT
52060: PUSH
52061: LD_VAR 0 2
52065: NOT
52066: OR
52067: IFFALSE 52071
// exit ;
52069: GO 52839
// case nation of nation_american :
52071: LD_VAR 0 2
52075: PUSH
52076: LD_INT 1
52078: DOUBLE
52079: EQUAL
52080: IFTRUE 52084
52082: GO 52298
52084: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52085: LD_ADDR_VAR 0 4
52089: PUSH
52090: LD_INT 35
52092: PUSH
52093: LD_INT 45
52095: PUSH
52096: LD_INT 46
52098: PUSH
52099: LD_INT 47
52101: PUSH
52102: LD_INT 82
52104: PUSH
52105: LD_INT 83
52107: PUSH
52108: LD_INT 84
52110: PUSH
52111: LD_INT 85
52113: PUSH
52114: LD_INT 86
52116: PUSH
52117: LD_INT 1
52119: PUSH
52120: LD_INT 2
52122: PUSH
52123: LD_INT 6
52125: PUSH
52126: LD_INT 15
52128: PUSH
52129: LD_INT 16
52131: PUSH
52132: LD_INT 7
52134: PUSH
52135: LD_INT 12
52137: PUSH
52138: LD_INT 13
52140: PUSH
52141: LD_INT 10
52143: PUSH
52144: LD_INT 14
52146: PUSH
52147: LD_INT 20
52149: PUSH
52150: LD_INT 21
52152: PUSH
52153: LD_INT 22
52155: PUSH
52156: LD_INT 25
52158: PUSH
52159: LD_INT 32
52161: PUSH
52162: LD_INT 27
52164: PUSH
52165: LD_INT 36
52167: PUSH
52168: LD_INT 69
52170: PUSH
52171: LD_INT 39
52173: PUSH
52174: LD_INT 34
52176: PUSH
52177: LD_INT 40
52179: PUSH
52180: LD_INT 48
52182: PUSH
52183: LD_INT 49
52185: PUSH
52186: LD_INT 50
52188: PUSH
52189: LD_INT 51
52191: PUSH
52192: LD_INT 52
52194: PUSH
52195: LD_INT 53
52197: PUSH
52198: LD_INT 54
52200: PUSH
52201: LD_INT 55
52203: PUSH
52204: LD_INT 56
52206: PUSH
52207: LD_INT 57
52209: PUSH
52210: LD_INT 58
52212: PUSH
52213: LD_INT 59
52215: PUSH
52216: LD_INT 60
52218: PUSH
52219: LD_INT 61
52221: PUSH
52222: LD_INT 62
52224: PUSH
52225: LD_INT 80
52227: PUSH
52228: LD_INT 82
52230: PUSH
52231: LD_INT 83
52233: PUSH
52234: LD_INT 84
52236: PUSH
52237: LD_INT 85
52239: PUSH
52240: LD_INT 86
52242: PUSH
52243: EMPTY
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: LIST
52249: LIST
52250: LIST
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: LIST
52258: LIST
52259: LIST
52260: LIST
52261: LIST
52262: LIST
52263: LIST
52264: LIST
52265: LIST
52266: LIST
52267: LIST
52268: LIST
52269: LIST
52270: LIST
52271: LIST
52272: LIST
52273: LIST
52274: LIST
52275: LIST
52276: LIST
52277: LIST
52278: LIST
52279: LIST
52280: LIST
52281: LIST
52282: LIST
52283: LIST
52284: LIST
52285: LIST
52286: LIST
52287: LIST
52288: LIST
52289: LIST
52290: LIST
52291: LIST
52292: LIST
52293: LIST
52294: LIST
52295: ST_TO_ADDR
52296: GO 52763
52298: LD_INT 2
52300: DOUBLE
52301: EQUAL
52302: IFTRUE 52306
52304: GO 52532
52306: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52307: LD_ADDR_VAR 0 4
52311: PUSH
52312: LD_INT 35
52314: PUSH
52315: LD_INT 45
52317: PUSH
52318: LD_INT 46
52320: PUSH
52321: LD_INT 47
52323: PUSH
52324: LD_INT 82
52326: PUSH
52327: LD_INT 83
52329: PUSH
52330: LD_INT 84
52332: PUSH
52333: LD_INT 85
52335: PUSH
52336: LD_INT 87
52338: PUSH
52339: LD_INT 70
52341: PUSH
52342: LD_INT 1
52344: PUSH
52345: LD_INT 11
52347: PUSH
52348: LD_INT 3
52350: PUSH
52351: LD_INT 4
52353: PUSH
52354: LD_INT 5
52356: PUSH
52357: LD_INT 6
52359: PUSH
52360: LD_INT 15
52362: PUSH
52363: LD_INT 18
52365: PUSH
52366: LD_INT 7
52368: PUSH
52369: LD_INT 17
52371: PUSH
52372: LD_INT 8
52374: PUSH
52375: LD_INT 20
52377: PUSH
52378: LD_INT 21
52380: PUSH
52381: LD_INT 22
52383: PUSH
52384: LD_INT 72
52386: PUSH
52387: LD_INT 26
52389: PUSH
52390: LD_INT 69
52392: PUSH
52393: LD_INT 39
52395: PUSH
52396: LD_INT 40
52398: PUSH
52399: LD_INT 41
52401: PUSH
52402: LD_INT 42
52404: PUSH
52405: LD_INT 43
52407: PUSH
52408: LD_INT 48
52410: PUSH
52411: LD_INT 49
52413: PUSH
52414: LD_INT 50
52416: PUSH
52417: LD_INT 51
52419: PUSH
52420: LD_INT 52
52422: PUSH
52423: LD_INT 53
52425: PUSH
52426: LD_INT 54
52428: PUSH
52429: LD_INT 55
52431: PUSH
52432: LD_INT 56
52434: PUSH
52435: LD_INT 60
52437: PUSH
52438: LD_INT 61
52440: PUSH
52441: LD_INT 62
52443: PUSH
52444: LD_INT 66
52446: PUSH
52447: LD_INT 67
52449: PUSH
52450: LD_INT 68
52452: PUSH
52453: LD_INT 81
52455: PUSH
52456: LD_INT 82
52458: PUSH
52459: LD_INT 83
52461: PUSH
52462: LD_INT 84
52464: PUSH
52465: LD_INT 85
52467: PUSH
52468: LD_INT 87
52470: PUSH
52471: LD_INT 88
52473: PUSH
52474: EMPTY
52475: LIST
52476: LIST
52477: LIST
52478: LIST
52479: LIST
52480: LIST
52481: LIST
52482: LIST
52483: LIST
52484: LIST
52485: LIST
52486: LIST
52487: LIST
52488: LIST
52489: LIST
52490: LIST
52491: LIST
52492: LIST
52493: LIST
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: LIST
52499: LIST
52500: LIST
52501: LIST
52502: LIST
52503: LIST
52504: LIST
52505: LIST
52506: LIST
52507: LIST
52508: LIST
52509: LIST
52510: LIST
52511: LIST
52512: LIST
52513: LIST
52514: LIST
52515: LIST
52516: LIST
52517: LIST
52518: LIST
52519: LIST
52520: LIST
52521: LIST
52522: LIST
52523: LIST
52524: LIST
52525: LIST
52526: LIST
52527: LIST
52528: LIST
52529: ST_TO_ADDR
52530: GO 52763
52532: LD_INT 3
52534: DOUBLE
52535: EQUAL
52536: IFTRUE 52540
52538: GO 52762
52540: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52541: LD_ADDR_VAR 0 4
52545: PUSH
52546: LD_INT 46
52548: PUSH
52549: LD_INT 47
52551: PUSH
52552: LD_INT 1
52554: PUSH
52555: LD_INT 2
52557: PUSH
52558: LD_INT 82
52560: PUSH
52561: LD_INT 83
52563: PUSH
52564: LD_INT 84
52566: PUSH
52567: LD_INT 85
52569: PUSH
52570: LD_INT 86
52572: PUSH
52573: LD_INT 11
52575: PUSH
52576: LD_INT 9
52578: PUSH
52579: LD_INT 20
52581: PUSH
52582: LD_INT 19
52584: PUSH
52585: LD_INT 21
52587: PUSH
52588: LD_INT 24
52590: PUSH
52591: LD_INT 22
52593: PUSH
52594: LD_INT 25
52596: PUSH
52597: LD_INT 28
52599: PUSH
52600: LD_INT 29
52602: PUSH
52603: LD_INT 30
52605: PUSH
52606: LD_INT 31
52608: PUSH
52609: LD_INT 37
52611: PUSH
52612: LD_INT 38
52614: PUSH
52615: LD_INT 32
52617: PUSH
52618: LD_INT 27
52620: PUSH
52621: LD_INT 33
52623: PUSH
52624: LD_INT 69
52626: PUSH
52627: LD_INT 39
52629: PUSH
52630: LD_INT 34
52632: PUSH
52633: LD_INT 40
52635: PUSH
52636: LD_INT 71
52638: PUSH
52639: LD_INT 23
52641: PUSH
52642: LD_INT 44
52644: PUSH
52645: LD_INT 48
52647: PUSH
52648: LD_INT 49
52650: PUSH
52651: LD_INT 50
52653: PUSH
52654: LD_INT 51
52656: PUSH
52657: LD_INT 52
52659: PUSH
52660: LD_INT 53
52662: PUSH
52663: LD_INT 54
52665: PUSH
52666: LD_INT 55
52668: PUSH
52669: LD_INT 56
52671: PUSH
52672: LD_INT 57
52674: PUSH
52675: LD_INT 58
52677: PUSH
52678: LD_INT 59
52680: PUSH
52681: LD_INT 63
52683: PUSH
52684: LD_INT 64
52686: PUSH
52687: LD_INT 65
52689: PUSH
52690: LD_INT 82
52692: PUSH
52693: LD_INT 83
52695: PUSH
52696: LD_INT 84
52698: PUSH
52699: LD_INT 85
52701: PUSH
52702: LD_INT 86
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: LIST
52709: LIST
52710: LIST
52711: LIST
52712: LIST
52713: LIST
52714: LIST
52715: LIST
52716: LIST
52717: LIST
52718: LIST
52719: LIST
52720: LIST
52721: LIST
52722: LIST
52723: LIST
52724: LIST
52725: LIST
52726: LIST
52727: LIST
52728: LIST
52729: LIST
52730: LIST
52731: LIST
52732: LIST
52733: LIST
52734: LIST
52735: LIST
52736: LIST
52737: LIST
52738: LIST
52739: LIST
52740: LIST
52741: LIST
52742: LIST
52743: LIST
52744: LIST
52745: LIST
52746: LIST
52747: LIST
52748: LIST
52749: LIST
52750: LIST
52751: LIST
52752: LIST
52753: LIST
52754: LIST
52755: LIST
52756: LIST
52757: LIST
52758: LIST
52759: ST_TO_ADDR
52760: GO 52763
52762: POP
// if state > - 1 and state < 3 then
52763: LD_VAR 0 3
52767: PUSH
52768: LD_INT 1
52770: NEG
52771: GREATER
52772: PUSH
52773: LD_VAR 0 3
52777: PUSH
52778: LD_INT 3
52780: LESS
52781: AND
52782: IFFALSE 52839
// for i in result do
52784: LD_ADDR_VAR 0 5
52788: PUSH
52789: LD_VAR 0 4
52793: PUSH
52794: FOR_IN
52795: IFFALSE 52837
// if GetTech ( i , side ) <> state then
52797: LD_VAR 0 5
52801: PPUSH
52802: LD_VAR 0 1
52806: PPUSH
52807: CALL_OW 321
52811: PUSH
52812: LD_VAR 0 3
52816: NONEQUAL
52817: IFFALSE 52835
// result := result diff i ;
52819: LD_ADDR_VAR 0 4
52823: PUSH
52824: LD_VAR 0 4
52828: PUSH
52829: LD_VAR 0 5
52833: DIFF
52834: ST_TO_ADDR
52835: GO 52794
52837: POP
52838: POP
// end ;
52839: LD_VAR 0 4
52843: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52844: LD_INT 0
52846: PPUSH
52847: PPUSH
52848: PPUSH
// result := true ;
52849: LD_ADDR_VAR 0 3
52853: PUSH
52854: LD_INT 1
52856: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52857: LD_ADDR_VAR 0 5
52861: PUSH
52862: LD_VAR 0 2
52866: PPUSH
52867: CALL_OW 480
52871: ST_TO_ADDR
// if not tmp then
52872: LD_VAR 0 5
52876: NOT
52877: IFFALSE 52881
// exit ;
52879: GO 52930
// for i in tmp do
52881: LD_ADDR_VAR 0 4
52885: PUSH
52886: LD_VAR 0 5
52890: PUSH
52891: FOR_IN
52892: IFFALSE 52928
// if GetTech ( i , side ) <> state_researched then
52894: LD_VAR 0 4
52898: PPUSH
52899: LD_VAR 0 1
52903: PPUSH
52904: CALL_OW 321
52908: PUSH
52909: LD_INT 2
52911: NONEQUAL
52912: IFFALSE 52926
// begin result := false ;
52914: LD_ADDR_VAR 0 3
52918: PUSH
52919: LD_INT 0
52921: ST_TO_ADDR
// exit ;
52922: POP
52923: POP
52924: GO 52930
// end ;
52926: GO 52891
52928: POP
52929: POP
// end ;
52930: LD_VAR 0 3
52934: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52935: LD_INT 0
52937: PPUSH
52938: PPUSH
52939: PPUSH
52940: PPUSH
52941: PPUSH
52942: PPUSH
52943: PPUSH
52944: PPUSH
52945: PPUSH
52946: PPUSH
52947: PPUSH
52948: PPUSH
52949: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52950: LD_VAR 0 1
52954: NOT
52955: PUSH
52956: LD_VAR 0 1
52960: PPUSH
52961: CALL_OW 257
52965: PUSH
52966: LD_INT 9
52968: NONEQUAL
52969: OR
52970: IFFALSE 52974
// exit ;
52972: GO 53547
// side := GetSide ( unit ) ;
52974: LD_ADDR_VAR 0 9
52978: PUSH
52979: LD_VAR 0 1
52983: PPUSH
52984: CALL_OW 255
52988: ST_TO_ADDR
// tech_space := tech_spacanom ;
52989: LD_ADDR_VAR 0 12
52993: PUSH
52994: LD_INT 29
52996: ST_TO_ADDR
// tech_time := tech_taurad ;
52997: LD_ADDR_VAR 0 13
53001: PUSH
53002: LD_INT 28
53004: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53005: LD_ADDR_VAR 0 11
53009: PUSH
53010: LD_VAR 0 1
53014: PPUSH
53015: CALL_OW 310
53019: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53020: LD_VAR 0 11
53024: PPUSH
53025: CALL_OW 247
53029: PUSH
53030: LD_INT 2
53032: EQUAL
53033: IFFALSE 53037
// exit ;
53035: GO 53547
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53037: LD_ADDR_VAR 0 8
53041: PUSH
53042: LD_INT 81
53044: PUSH
53045: LD_VAR 0 9
53049: PUSH
53050: EMPTY
53051: LIST
53052: LIST
53053: PUSH
53054: LD_INT 3
53056: PUSH
53057: LD_INT 21
53059: PUSH
53060: LD_INT 3
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: PUSH
53067: EMPTY
53068: LIST
53069: LIST
53070: PUSH
53071: EMPTY
53072: LIST
53073: LIST
53074: PPUSH
53075: CALL_OW 69
53079: ST_TO_ADDR
// if not tmp then
53080: LD_VAR 0 8
53084: NOT
53085: IFFALSE 53089
// exit ;
53087: GO 53547
// if in_unit then
53089: LD_VAR 0 11
53093: IFFALSE 53117
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53095: LD_ADDR_VAR 0 10
53099: PUSH
53100: LD_VAR 0 8
53104: PPUSH
53105: LD_VAR 0 11
53109: PPUSH
53110: CALL_OW 74
53114: ST_TO_ADDR
53115: GO 53137
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53117: LD_ADDR_VAR 0 10
53121: PUSH
53122: LD_VAR 0 8
53126: PPUSH
53127: LD_VAR 0 1
53131: PPUSH
53132: CALL_OW 74
53136: ST_TO_ADDR
// if not enemy then
53137: LD_VAR 0 10
53141: NOT
53142: IFFALSE 53146
// exit ;
53144: GO 53547
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53146: LD_VAR 0 11
53150: PUSH
53151: LD_VAR 0 11
53155: PPUSH
53156: LD_VAR 0 10
53160: PPUSH
53161: CALL_OW 296
53165: PUSH
53166: LD_INT 13
53168: GREATER
53169: AND
53170: PUSH
53171: LD_VAR 0 1
53175: PPUSH
53176: LD_VAR 0 10
53180: PPUSH
53181: CALL_OW 296
53185: PUSH
53186: LD_INT 12
53188: GREATER
53189: OR
53190: IFFALSE 53194
// exit ;
53192: GO 53547
// missile := [ 1 ] ;
53194: LD_ADDR_VAR 0 14
53198: PUSH
53199: LD_INT 1
53201: PUSH
53202: EMPTY
53203: LIST
53204: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53205: LD_VAR 0 9
53209: PPUSH
53210: LD_VAR 0 12
53214: PPUSH
53215: CALL_OW 325
53219: IFFALSE 53248
// missile := Insert ( missile , missile + 1 , 2 ) ;
53221: LD_ADDR_VAR 0 14
53225: PUSH
53226: LD_VAR 0 14
53230: PPUSH
53231: LD_VAR 0 14
53235: PUSH
53236: LD_INT 1
53238: PLUS
53239: PPUSH
53240: LD_INT 2
53242: PPUSH
53243: CALL_OW 2
53247: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53248: LD_VAR 0 9
53252: PPUSH
53253: LD_VAR 0 13
53257: PPUSH
53258: CALL_OW 325
53262: PUSH
53263: LD_VAR 0 10
53267: PPUSH
53268: CALL_OW 255
53272: PPUSH
53273: LD_VAR 0 13
53277: PPUSH
53278: CALL_OW 325
53282: NOT
53283: AND
53284: IFFALSE 53313
// missile := Insert ( missile , missile + 1 , 3 ) ;
53286: LD_ADDR_VAR 0 14
53290: PUSH
53291: LD_VAR 0 14
53295: PPUSH
53296: LD_VAR 0 14
53300: PUSH
53301: LD_INT 1
53303: PLUS
53304: PPUSH
53305: LD_INT 3
53307: PPUSH
53308: CALL_OW 2
53312: ST_TO_ADDR
// if missile < 2 then
53313: LD_VAR 0 14
53317: PUSH
53318: LD_INT 2
53320: LESS
53321: IFFALSE 53325
// exit ;
53323: GO 53547
// x := GetX ( enemy ) ;
53325: LD_ADDR_VAR 0 4
53329: PUSH
53330: LD_VAR 0 10
53334: PPUSH
53335: CALL_OW 250
53339: ST_TO_ADDR
// y := GetY ( enemy ) ;
53340: LD_ADDR_VAR 0 5
53344: PUSH
53345: LD_VAR 0 10
53349: PPUSH
53350: CALL_OW 251
53354: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53355: LD_ADDR_VAR 0 6
53359: PUSH
53360: LD_VAR 0 4
53364: PUSH
53365: LD_INT 1
53367: NEG
53368: PPUSH
53369: LD_INT 1
53371: PPUSH
53372: CALL_OW 12
53376: PLUS
53377: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53378: LD_ADDR_VAR 0 7
53382: PUSH
53383: LD_VAR 0 5
53387: PUSH
53388: LD_INT 1
53390: NEG
53391: PPUSH
53392: LD_INT 1
53394: PPUSH
53395: CALL_OW 12
53399: PLUS
53400: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53401: LD_VAR 0 6
53405: PPUSH
53406: LD_VAR 0 7
53410: PPUSH
53411: CALL_OW 488
53415: NOT
53416: IFFALSE 53438
// begin _x := x ;
53418: LD_ADDR_VAR 0 6
53422: PUSH
53423: LD_VAR 0 4
53427: ST_TO_ADDR
// _y := y ;
53428: LD_ADDR_VAR 0 7
53432: PUSH
53433: LD_VAR 0 5
53437: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53438: LD_ADDR_VAR 0 3
53442: PUSH
53443: LD_INT 1
53445: PPUSH
53446: LD_VAR 0 14
53450: PPUSH
53451: CALL_OW 12
53455: ST_TO_ADDR
// case i of 1 :
53456: LD_VAR 0 3
53460: PUSH
53461: LD_INT 1
53463: DOUBLE
53464: EQUAL
53465: IFTRUE 53469
53467: GO 53486
53469: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53470: LD_VAR 0 1
53474: PPUSH
53475: LD_VAR 0 10
53479: PPUSH
53480: CALL_OW 115
53484: GO 53547
53486: LD_INT 2
53488: DOUBLE
53489: EQUAL
53490: IFTRUE 53494
53492: GO 53516
53494: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53495: LD_VAR 0 1
53499: PPUSH
53500: LD_VAR 0 6
53504: PPUSH
53505: LD_VAR 0 7
53509: PPUSH
53510: CALL_OW 153
53514: GO 53547
53516: LD_INT 3
53518: DOUBLE
53519: EQUAL
53520: IFTRUE 53524
53522: GO 53546
53524: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53525: LD_VAR 0 1
53529: PPUSH
53530: LD_VAR 0 6
53534: PPUSH
53535: LD_VAR 0 7
53539: PPUSH
53540: CALL_OW 154
53544: GO 53547
53546: POP
// end ;
53547: LD_VAR 0 2
53551: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53552: LD_INT 0
53554: PPUSH
53555: PPUSH
53556: PPUSH
53557: PPUSH
53558: PPUSH
53559: PPUSH
// if not unit or not building then
53560: LD_VAR 0 1
53564: NOT
53565: PUSH
53566: LD_VAR 0 2
53570: NOT
53571: OR
53572: IFFALSE 53576
// exit ;
53574: GO 53734
// x := GetX ( building ) ;
53576: LD_ADDR_VAR 0 5
53580: PUSH
53581: LD_VAR 0 2
53585: PPUSH
53586: CALL_OW 250
53590: ST_TO_ADDR
// y := GetY ( building ) ;
53591: LD_ADDR_VAR 0 6
53595: PUSH
53596: LD_VAR 0 2
53600: PPUSH
53601: CALL_OW 251
53605: ST_TO_ADDR
// for i = 0 to 5 do
53606: LD_ADDR_VAR 0 4
53610: PUSH
53611: DOUBLE
53612: LD_INT 0
53614: DEC
53615: ST_TO_ADDR
53616: LD_INT 5
53618: PUSH
53619: FOR_TO
53620: IFFALSE 53732
// begin _x := ShiftX ( x , i , 3 ) ;
53622: LD_ADDR_VAR 0 7
53626: PUSH
53627: LD_VAR 0 5
53631: PPUSH
53632: LD_VAR 0 4
53636: PPUSH
53637: LD_INT 3
53639: PPUSH
53640: CALL_OW 272
53644: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53645: LD_ADDR_VAR 0 8
53649: PUSH
53650: LD_VAR 0 6
53654: PPUSH
53655: LD_VAR 0 4
53659: PPUSH
53660: LD_INT 3
53662: PPUSH
53663: CALL_OW 273
53667: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53668: LD_VAR 0 7
53672: PPUSH
53673: LD_VAR 0 8
53677: PPUSH
53678: CALL_OW 488
53682: NOT
53683: IFFALSE 53687
// continue ;
53685: GO 53619
// if HexInfo ( _x , _y ) = 0 then
53687: LD_VAR 0 7
53691: PPUSH
53692: LD_VAR 0 8
53696: PPUSH
53697: CALL_OW 428
53701: PUSH
53702: LD_INT 0
53704: EQUAL
53705: IFFALSE 53730
// begin ComMoveXY ( unit , _x , _y ) ;
53707: LD_VAR 0 1
53711: PPUSH
53712: LD_VAR 0 7
53716: PPUSH
53717: LD_VAR 0 8
53721: PPUSH
53722: CALL_OW 111
// exit ;
53726: POP
53727: POP
53728: GO 53734
// end ; end ;
53730: GO 53619
53732: POP
53733: POP
// end ;
53734: LD_VAR 0 3
53738: RET
// export function ScanBase ( side , base_area ) ; begin
53739: LD_INT 0
53741: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53742: LD_ADDR_VAR 0 3
53746: PUSH
53747: LD_VAR 0 2
53751: PPUSH
53752: LD_INT 81
53754: PUSH
53755: LD_VAR 0 1
53759: PUSH
53760: EMPTY
53761: LIST
53762: LIST
53763: PPUSH
53764: CALL_OW 70
53768: ST_TO_ADDR
// end ;
53769: LD_VAR 0 3
53773: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53774: LD_INT 0
53776: PPUSH
53777: PPUSH
53778: PPUSH
53779: PPUSH
// result := false ;
53780: LD_ADDR_VAR 0 2
53784: PUSH
53785: LD_INT 0
53787: ST_TO_ADDR
// side := GetSide ( unit ) ;
53788: LD_ADDR_VAR 0 3
53792: PUSH
53793: LD_VAR 0 1
53797: PPUSH
53798: CALL_OW 255
53802: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53803: LD_ADDR_VAR 0 4
53807: PUSH
53808: LD_VAR 0 1
53812: PPUSH
53813: CALL_OW 248
53817: ST_TO_ADDR
// case nat of 1 :
53818: LD_VAR 0 4
53822: PUSH
53823: LD_INT 1
53825: DOUBLE
53826: EQUAL
53827: IFTRUE 53831
53829: GO 53842
53831: POP
// tech := tech_lassight ; 2 :
53832: LD_ADDR_VAR 0 5
53836: PUSH
53837: LD_INT 12
53839: ST_TO_ADDR
53840: GO 53881
53842: LD_INT 2
53844: DOUBLE
53845: EQUAL
53846: IFTRUE 53850
53848: GO 53861
53850: POP
// tech := tech_mortar ; 3 :
53851: LD_ADDR_VAR 0 5
53855: PUSH
53856: LD_INT 41
53858: ST_TO_ADDR
53859: GO 53881
53861: LD_INT 3
53863: DOUBLE
53864: EQUAL
53865: IFTRUE 53869
53867: GO 53880
53869: POP
// tech := tech_bazooka ; end ;
53870: LD_ADDR_VAR 0 5
53874: PUSH
53875: LD_INT 44
53877: ST_TO_ADDR
53878: GO 53881
53880: POP
// if Researched ( side , tech ) then
53881: LD_VAR 0 3
53885: PPUSH
53886: LD_VAR 0 5
53890: PPUSH
53891: CALL_OW 325
53895: IFFALSE 53922
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53897: LD_ADDR_VAR 0 2
53901: PUSH
53902: LD_INT 5
53904: PUSH
53905: LD_INT 8
53907: PUSH
53908: LD_INT 9
53910: PUSH
53911: EMPTY
53912: LIST
53913: LIST
53914: LIST
53915: PUSH
53916: LD_VAR 0 4
53920: ARRAY
53921: ST_TO_ADDR
// end ;
53922: LD_VAR 0 2
53926: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53927: LD_INT 0
53929: PPUSH
53930: PPUSH
53931: PPUSH
// if not mines then
53932: LD_VAR 0 2
53936: NOT
53937: IFFALSE 53941
// exit ;
53939: GO 54085
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53941: LD_ADDR_VAR 0 5
53945: PUSH
53946: LD_INT 81
53948: PUSH
53949: LD_VAR 0 1
53953: PUSH
53954: EMPTY
53955: LIST
53956: LIST
53957: PUSH
53958: LD_INT 3
53960: PUSH
53961: LD_INT 21
53963: PUSH
53964: LD_INT 3
53966: PUSH
53967: EMPTY
53968: LIST
53969: LIST
53970: PUSH
53971: EMPTY
53972: LIST
53973: LIST
53974: PUSH
53975: EMPTY
53976: LIST
53977: LIST
53978: PPUSH
53979: CALL_OW 69
53983: ST_TO_ADDR
// for i in mines do
53984: LD_ADDR_VAR 0 4
53988: PUSH
53989: LD_VAR 0 2
53993: PUSH
53994: FOR_IN
53995: IFFALSE 54083
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53997: LD_VAR 0 4
54001: PUSH
54002: LD_INT 1
54004: ARRAY
54005: PPUSH
54006: LD_VAR 0 4
54010: PUSH
54011: LD_INT 2
54013: ARRAY
54014: PPUSH
54015: CALL_OW 458
54019: NOT
54020: IFFALSE 54024
// continue ;
54022: GO 53994
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54024: LD_VAR 0 4
54028: PUSH
54029: LD_INT 1
54031: ARRAY
54032: PPUSH
54033: LD_VAR 0 4
54037: PUSH
54038: LD_INT 2
54040: ARRAY
54041: PPUSH
54042: CALL_OW 428
54046: PUSH
54047: LD_VAR 0 5
54051: IN
54052: IFFALSE 54081
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54054: LD_VAR 0 4
54058: PUSH
54059: LD_INT 1
54061: ARRAY
54062: PPUSH
54063: LD_VAR 0 4
54067: PUSH
54068: LD_INT 2
54070: ARRAY
54071: PPUSH
54072: LD_VAR 0 1
54076: PPUSH
54077: CALL_OW 456
// end ;
54081: GO 53994
54083: POP
54084: POP
// end ;
54085: LD_VAR 0 3
54089: RET
// export function Count ( array ) ; var i ; begin
54090: LD_INT 0
54092: PPUSH
54093: PPUSH
// result := 0 ;
54094: LD_ADDR_VAR 0 2
54098: PUSH
54099: LD_INT 0
54101: ST_TO_ADDR
// for i in array do
54102: LD_ADDR_VAR 0 3
54106: PUSH
54107: LD_VAR 0 1
54111: PUSH
54112: FOR_IN
54113: IFFALSE 54137
// if i then
54115: LD_VAR 0 3
54119: IFFALSE 54135
// result := result + 1 ;
54121: LD_ADDR_VAR 0 2
54125: PUSH
54126: LD_VAR 0 2
54130: PUSH
54131: LD_INT 1
54133: PLUS
54134: ST_TO_ADDR
54135: GO 54112
54137: POP
54138: POP
// end ;
54139: LD_VAR 0 2
54143: RET
// export function IsEmpty ( building ) ; begin
54144: LD_INT 0
54146: PPUSH
// if not building then
54147: LD_VAR 0 1
54151: NOT
54152: IFFALSE 54156
// exit ;
54154: GO 54199
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54156: LD_ADDR_VAR 0 2
54160: PUSH
54161: LD_VAR 0 1
54165: PUSH
54166: LD_INT 22
54168: PUSH
54169: LD_VAR 0 1
54173: PPUSH
54174: CALL_OW 255
54178: PUSH
54179: EMPTY
54180: LIST
54181: LIST
54182: PUSH
54183: LD_INT 58
54185: PUSH
54186: EMPTY
54187: LIST
54188: PUSH
54189: EMPTY
54190: LIST
54191: LIST
54192: PPUSH
54193: CALL_OW 69
54197: IN
54198: ST_TO_ADDR
// end ;
54199: LD_VAR 0 2
54203: RET
// export function IsNotFull ( building ) ; begin
54204: LD_INT 0
54206: PPUSH
// if not building then
54207: LD_VAR 0 1
54211: NOT
54212: IFFALSE 54216
// exit ;
54214: GO 54235
// result := UnitsInside ( building ) < 6 ;
54216: LD_ADDR_VAR 0 2
54220: PUSH
54221: LD_VAR 0 1
54225: PPUSH
54226: CALL_OW 313
54230: PUSH
54231: LD_INT 6
54233: LESS
54234: ST_TO_ADDR
// end ;
54235: LD_VAR 0 2
54239: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54240: LD_INT 0
54242: PPUSH
54243: PPUSH
54244: PPUSH
54245: PPUSH
// tmp := [ ] ;
54246: LD_ADDR_VAR 0 3
54250: PUSH
54251: EMPTY
54252: ST_TO_ADDR
// list := [ ] ;
54253: LD_ADDR_VAR 0 5
54257: PUSH
54258: EMPTY
54259: ST_TO_ADDR
// for i = 16 to 25 do
54260: LD_ADDR_VAR 0 4
54264: PUSH
54265: DOUBLE
54266: LD_INT 16
54268: DEC
54269: ST_TO_ADDR
54270: LD_INT 25
54272: PUSH
54273: FOR_TO
54274: IFFALSE 54347
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54276: LD_ADDR_VAR 0 3
54280: PUSH
54281: LD_VAR 0 3
54285: PUSH
54286: LD_INT 22
54288: PUSH
54289: LD_VAR 0 1
54293: PPUSH
54294: CALL_OW 255
54298: PUSH
54299: EMPTY
54300: LIST
54301: LIST
54302: PUSH
54303: LD_INT 91
54305: PUSH
54306: LD_VAR 0 1
54310: PUSH
54311: LD_INT 6
54313: PUSH
54314: EMPTY
54315: LIST
54316: LIST
54317: LIST
54318: PUSH
54319: LD_INT 30
54321: PUSH
54322: LD_VAR 0 4
54326: PUSH
54327: EMPTY
54328: LIST
54329: LIST
54330: PUSH
54331: EMPTY
54332: LIST
54333: LIST
54334: LIST
54335: PUSH
54336: EMPTY
54337: LIST
54338: PPUSH
54339: CALL_OW 69
54343: ADD
54344: ST_TO_ADDR
54345: GO 54273
54347: POP
54348: POP
// for i = 1 to tmp do
54349: LD_ADDR_VAR 0 4
54353: PUSH
54354: DOUBLE
54355: LD_INT 1
54357: DEC
54358: ST_TO_ADDR
54359: LD_VAR 0 3
54363: PUSH
54364: FOR_TO
54365: IFFALSE 54453
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54367: LD_ADDR_VAR 0 5
54371: PUSH
54372: LD_VAR 0 5
54376: PUSH
54377: LD_VAR 0 3
54381: PUSH
54382: LD_VAR 0 4
54386: ARRAY
54387: PPUSH
54388: CALL_OW 266
54392: PUSH
54393: LD_VAR 0 3
54397: PUSH
54398: LD_VAR 0 4
54402: ARRAY
54403: PPUSH
54404: CALL_OW 250
54408: PUSH
54409: LD_VAR 0 3
54413: PUSH
54414: LD_VAR 0 4
54418: ARRAY
54419: PPUSH
54420: CALL_OW 251
54424: PUSH
54425: LD_VAR 0 3
54429: PUSH
54430: LD_VAR 0 4
54434: ARRAY
54435: PPUSH
54436: CALL_OW 254
54440: PUSH
54441: EMPTY
54442: LIST
54443: LIST
54444: LIST
54445: LIST
54446: PUSH
54447: EMPTY
54448: LIST
54449: ADD
54450: ST_TO_ADDR
54451: GO 54364
54453: POP
54454: POP
// result := list ;
54455: LD_ADDR_VAR 0 2
54459: PUSH
54460: LD_VAR 0 5
54464: ST_TO_ADDR
// end ;
54465: LD_VAR 0 2
54469: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54470: LD_INT 0
54472: PPUSH
54473: PPUSH
54474: PPUSH
54475: PPUSH
54476: PPUSH
54477: PPUSH
54478: PPUSH
// if not factory then
54479: LD_VAR 0 1
54483: NOT
54484: IFFALSE 54488
// exit ;
54486: GO 55081
// if control = control_apeman then
54488: LD_VAR 0 4
54492: PUSH
54493: LD_INT 5
54495: EQUAL
54496: IFFALSE 54605
// begin tmp := UnitsInside ( factory ) ;
54498: LD_ADDR_VAR 0 8
54502: PUSH
54503: LD_VAR 0 1
54507: PPUSH
54508: CALL_OW 313
54512: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54513: LD_VAR 0 8
54517: PPUSH
54518: LD_INT 25
54520: PUSH
54521: LD_INT 12
54523: PUSH
54524: EMPTY
54525: LIST
54526: LIST
54527: PPUSH
54528: CALL_OW 72
54532: NOT
54533: IFFALSE 54543
// control := control_manual ;
54535: LD_ADDR_VAR 0 4
54539: PUSH
54540: LD_INT 1
54542: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54543: LD_ADDR_VAR 0 8
54547: PUSH
54548: LD_VAR 0 1
54552: PPUSH
54553: CALL 54240 0 1
54557: ST_TO_ADDR
// if tmp then
54558: LD_VAR 0 8
54562: IFFALSE 54605
// begin for i in tmp do
54564: LD_ADDR_VAR 0 7
54568: PUSH
54569: LD_VAR 0 8
54573: PUSH
54574: FOR_IN
54575: IFFALSE 54603
// if i [ 1 ] = b_ext_radio then
54577: LD_VAR 0 7
54581: PUSH
54582: LD_INT 1
54584: ARRAY
54585: PUSH
54586: LD_INT 22
54588: EQUAL
54589: IFFALSE 54601
// begin control := control_remote ;
54591: LD_ADDR_VAR 0 4
54595: PUSH
54596: LD_INT 2
54598: ST_TO_ADDR
// break ;
54599: GO 54603
// end ;
54601: GO 54574
54603: POP
54604: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54605: LD_VAR 0 1
54609: PPUSH
54610: LD_VAR 0 2
54614: PPUSH
54615: LD_VAR 0 3
54619: PPUSH
54620: LD_VAR 0 4
54624: PPUSH
54625: LD_VAR 0 5
54629: PPUSH
54630: CALL_OW 448
54634: IFFALSE 54669
// begin result := [ chassis , engine , control , weapon ] ;
54636: LD_ADDR_VAR 0 6
54640: PUSH
54641: LD_VAR 0 2
54645: PUSH
54646: LD_VAR 0 3
54650: PUSH
54651: LD_VAR 0 4
54655: PUSH
54656: LD_VAR 0 5
54660: PUSH
54661: EMPTY
54662: LIST
54663: LIST
54664: LIST
54665: LIST
54666: ST_TO_ADDR
// exit ;
54667: GO 55081
// end ; _chassis := AvailableChassisList ( factory ) ;
54669: LD_ADDR_VAR 0 9
54673: PUSH
54674: LD_VAR 0 1
54678: PPUSH
54679: CALL_OW 475
54683: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54684: LD_ADDR_VAR 0 11
54688: PUSH
54689: LD_VAR 0 1
54693: PPUSH
54694: CALL_OW 476
54698: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54699: LD_ADDR_VAR 0 12
54703: PUSH
54704: LD_VAR 0 1
54708: PPUSH
54709: CALL_OW 477
54713: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54714: LD_ADDR_VAR 0 10
54718: PUSH
54719: LD_VAR 0 1
54723: PPUSH
54724: CALL_OW 478
54728: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54729: LD_VAR 0 9
54733: NOT
54734: PUSH
54735: LD_VAR 0 11
54739: NOT
54740: OR
54741: PUSH
54742: LD_VAR 0 12
54746: NOT
54747: OR
54748: PUSH
54749: LD_VAR 0 10
54753: NOT
54754: OR
54755: IFFALSE 54790
// begin result := [ chassis , engine , control , weapon ] ;
54757: LD_ADDR_VAR 0 6
54761: PUSH
54762: LD_VAR 0 2
54766: PUSH
54767: LD_VAR 0 3
54771: PUSH
54772: LD_VAR 0 4
54776: PUSH
54777: LD_VAR 0 5
54781: PUSH
54782: EMPTY
54783: LIST
54784: LIST
54785: LIST
54786: LIST
54787: ST_TO_ADDR
// exit ;
54788: GO 55081
// end ; if not chassis in _chassis then
54790: LD_VAR 0 2
54794: PUSH
54795: LD_VAR 0 9
54799: IN
54800: NOT
54801: IFFALSE 54827
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54803: LD_ADDR_VAR 0 2
54807: PUSH
54808: LD_VAR 0 9
54812: PUSH
54813: LD_INT 1
54815: PPUSH
54816: LD_VAR 0 9
54820: PPUSH
54821: CALL_OW 12
54825: ARRAY
54826: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54827: LD_VAR 0 2
54831: PPUSH
54832: LD_VAR 0 3
54836: PPUSH
54837: CALL 55086 0 2
54841: NOT
54842: IFFALSE 54901
// repeat engine := _engine [ 1 ] ;
54844: LD_ADDR_VAR 0 3
54848: PUSH
54849: LD_VAR 0 11
54853: PUSH
54854: LD_INT 1
54856: ARRAY
54857: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54858: LD_ADDR_VAR 0 11
54862: PUSH
54863: LD_VAR 0 11
54867: PPUSH
54868: LD_INT 1
54870: PPUSH
54871: CALL_OW 3
54875: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54876: LD_VAR 0 2
54880: PPUSH
54881: LD_VAR 0 3
54885: PPUSH
54886: CALL 55086 0 2
54890: PUSH
54891: LD_VAR 0 11
54895: PUSH
54896: EMPTY
54897: EQUAL
54898: OR
54899: IFFALSE 54844
// if not control in _control then
54901: LD_VAR 0 4
54905: PUSH
54906: LD_VAR 0 12
54910: IN
54911: NOT
54912: IFFALSE 54938
// control := _control [ rand ( 1 , _control ) ] ;
54914: LD_ADDR_VAR 0 4
54918: PUSH
54919: LD_VAR 0 12
54923: PUSH
54924: LD_INT 1
54926: PPUSH
54927: LD_VAR 0 12
54931: PPUSH
54932: CALL_OW 12
54936: ARRAY
54937: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54938: LD_VAR 0 2
54942: PPUSH
54943: LD_VAR 0 5
54947: PPUSH
54948: CALL 55306 0 2
54952: NOT
54953: IFFALSE 55012
// repeat weapon := _weapon [ 1 ] ;
54955: LD_ADDR_VAR 0 5
54959: PUSH
54960: LD_VAR 0 10
54964: PUSH
54965: LD_INT 1
54967: ARRAY
54968: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54969: LD_ADDR_VAR 0 10
54973: PUSH
54974: LD_VAR 0 10
54978: PPUSH
54979: LD_INT 1
54981: PPUSH
54982: CALL_OW 3
54986: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54987: LD_VAR 0 2
54991: PPUSH
54992: LD_VAR 0 5
54996: PPUSH
54997: CALL 55306 0 2
55001: PUSH
55002: LD_VAR 0 10
55006: PUSH
55007: EMPTY
55008: EQUAL
55009: OR
55010: IFFALSE 54955
// result := [ ] ;
55012: LD_ADDR_VAR 0 6
55016: PUSH
55017: EMPTY
55018: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55019: LD_VAR 0 1
55023: PPUSH
55024: LD_VAR 0 2
55028: PPUSH
55029: LD_VAR 0 3
55033: PPUSH
55034: LD_VAR 0 4
55038: PPUSH
55039: LD_VAR 0 5
55043: PPUSH
55044: CALL_OW 448
55048: IFFALSE 55081
// result := [ chassis , engine , control , weapon ] ;
55050: LD_ADDR_VAR 0 6
55054: PUSH
55055: LD_VAR 0 2
55059: PUSH
55060: LD_VAR 0 3
55064: PUSH
55065: LD_VAR 0 4
55069: PUSH
55070: LD_VAR 0 5
55074: PUSH
55075: EMPTY
55076: LIST
55077: LIST
55078: LIST
55079: LIST
55080: ST_TO_ADDR
// end ;
55081: LD_VAR 0 6
55085: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55086: LD_INT 0
55088: PPUSH
// if not chassis or not engine then
55089: LD_VAR 0 1
55093: NOT
55094: PUSH
55095: LD_VAR 0 2
55099: NOT
55100: OR
55101: IFFALSE 55105
// exit ;
55103: GO 55301
// case engine of engine_solar :
55105: LD_VAR 0 2
55109: PUSH
55110: LD_INT 2
55112: DOUBLE
55113: EQUAL
55114: IFTRUE 55118
55116: GO 55156
55118: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55119: LD_ADDR_VAR 0 3
55123: PUSH
55124: LD_INT 11
55126: PUSH
55127: LD_INT 12
55129: PUSH
55130: LD_INT 13
55132: PUSH
55133: LD_INT 14
55135: PUSH
55136: LD_INT 1
55138: PUSH
55139: LD_INT 2
55141: PUSH
55142: LD_INT 3
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: LIST
55149: LIST
55150: LIST
55151: LIST
55152: LIST
55153: ST_TO_ADDR
55154: GO 55285
55156: LD_INT 1
55158: DOUBLE
55159: EQUAL
55160: IFTRUE 55164
55162: GO 55226
55164: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55165: LD_ADDR_VAR 0 3
55169: PUSH
55170: LD_INT 11
55172: PUSH
55173: LD_INT 12
55175: PUSH
55176: LD_INT 13
55178: PUSH
55179: LD_INT 14
55181: PUSH
55182: LD_INT 1
55184: PUSH
55185: LD_INT 2
55187: PUSH
55188: LD_INT 3
55190: PUSH
55191: LD_INT 4
55193: PUSH
55194: LD_INT 5
55196: PUSH
55197: LD_INT 21
55199: PUSH
55200: LD_INT 23
55202: PUSH
55203: LD_INT 22
55205: PUSH
55206: LD_INT 24
55208: PUSH
55209: EMPTY
55210: LIST
55211: LIST
55212: LIST
55213: LIST
55214: LIST
55215: LIST
55216: LIST
55217: LIST
55218: LIST
55219: LIST
55220: LIST
55221: LIST
55222: LIST
55223: ST_TO_ADDR
55224: GO 55285
55226: LD_INT 3
55228: DOUBLE
55229: EQUAL
55230: IFTRUE 55234
55232: GO 55284
55234: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55235: LD_ADDR_VAR 0 3
55239: PUSH
55240: LD_INT 13
55242: PUSH
55243: LD_INT 14
55245: PUSH
55246: LD_INT 2
55248: PUSH
55249: LD_INT 3
55251: PUSH
55252: LD_INT 4
55254: PUSH
55255: LD_INT 5
55257: PUSH
55258: LD_INT 21
55260: PUSH
55261: LD_INT 22
55263: PUSH
55264: LD_INT 23
55266: PUSH
55267: LD_INT 24
55269: PUSH
55270: EMPTY
55271: LIST
55272: LIST
55273: LIST
55274: LIST
55275: LIST
55276: LIST
55277: LIST
55278: LIST
55279: LIST
55280: LIST
55281: ST_TO_ADDR
55282: GO 55285
55284: POP
// result := ( chassis in result ) ;
55285: LD_ADDR_VAR 0 3
55289: PUSH
55290: LD_VAR 0 1
55294: PUSH
55295: LD_VAR 0 3
55299: IN
55300: ST_TO_ADDR
// end ;
55301: LD_VAR 0 3
55305: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55306: LD_INT 0
55308: PPUSH
// if not chassis or not weapon then
55309: LD_VAR 0 1
55313: NOT
55314: PUSH
55315: LD_VAR 0 2
55319: NOT
55320: OR
55321: IFFALSE 55325
// exit ;
55323: GO 56387
// case weapon of us_machine_gun :
55325: LD_VAR 0 2
55329: PUSH
55330: LD_INT 2
55332: DOUBLE
55333: EQUAL
55334: IFTRUE 55338
55336: GO 55368
55338: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55339: LD_ADDR_VAR 0 3
55343: PUSH
55344: LD_INT 1
55346: PUSH
55347: LD_INT 2
55349: PUSH
55350: LD_INT 3
55352: PUSH
55353: LD_INT 4
55355: PUSH
55356: LD_INT 5
55358: PUSH
55359: EMPTY
55360: LIST
55361: LIST
55362: LIST
55363: LIST
55364: LIST
55365: ST_TO_ADDR
55366: GO 56371
55368: LD_INT 3
55370: DOUBLE
55371: EQUAL
55372: IFTRUE 55376
55374: GO 55406
55376: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55377: LD_ADDR_VAR 0 3
55381: PUSH
55382: LD_INT 1
55384: PUSH
55385: LD_INT 2
55387: PUSH
55388: LD_INT 3
55390: PUSH
55391: LD_INT 4
55393: PUSH
55394: LD_INT 5
55396: PUSH
55397: EMPTY
55398: LIST
55399: LIST
55400: LIST
55401: LIST
55402: LIST
55403: ST_TO_ADDR
55404: GO 56371
55406: LD_INT 11
55408: DOUBLE
55409: EQUAL
55410: IFTRUE 55414
55412: GO 55444
55414: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55415: LD_ADDR_VAR 0 3
55419: PUSH
55420: LD_INT 1
55422: PUSH
55423: LD_INT 2
55425: PUSH
55426: LD_INT 3
55428: PUSH
55429: LD_INT 4
55431: PUSH
55432: LD_INT 5
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: LIST
55439: LIST
55440: LIST
55441: ST_TO_ADDR
55442: GO 56371
55444: LD_INT 4
55446: DOUBLE
55447: EQUAL
55448: IFTRUE 55452
55450: GO 55478
55452: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55453: LD_ADDR_VAR 0 3
55457: PUSH
55458: LD_INT 2
55460: PUSH
55461: LD_INT 3
55463: PUSH
55464: LD_INT 4
55466: PUSH
55467: LD_INT 5
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: LIST
55474: LIST
55475: ST_TO_ADDR
55476: GO 56371
55478: LD_INT 5
55480: DOUBLE
55481: EQUAL
55482: IFTRUE 55486
55484: GO 55512
55486: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55487: LD_ADDR_VAR 0 3
55491: PUSH
55492: LD_INT 2
55494: PUSH
55495: LD_INT 3
55497: PUSH
55498: LD_INT 4
55500: PUSH
55501: LD_INT 5
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: LIST
55509: ST_TO_ADDR
55510: GO 56371
55512: LD_INT 9
55514: DOUBLE
55515: EQUAL
55516: IFTRUE 55520
55518: GO 55546
55520: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55521: LD_ADDR_VAR 0 3
55525: PUSH
55526: LD_INT 2
55528: PUSH
55529: LD_INT 3
55531: PUSH
55532: LD_INT 4
55534: PUSH
55535: LD_INT 5
55537: PUSH
55538: EMPTY
55539: LIST
55540: LIST
55541: LIST
55542: LIST
55543: ST_TO_ADDR
55544: GO 56371
55546: LD_INT 7
55548: DOUBLE
55549: EQUAL
55550: IFTRUE 55554
55552: GO 55580
55554: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55555: LD_ADDR_VAR 0 3
55559: PUSH
55560: LD_INT 2
55562: PUSH
55563: LD_INT 3
55565: PUSH
55566: LD_INT 4
55568: PUSH
55569: LD_INT 5
55571: PUSH
55572: EMPTY
55573: LIST
55574: LIST
55575: LIST
55576: LIST
55577: ST_TO_ADDR
55578: GO 56371
55580: LD_INT 12
55582: DOUBLE
55583: EQUAL
55584: IFTRUE 55588
55586: GO 55614
55588: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55589: LD_ADDR_VAR 0 3
55593: PUSH
55594: LD_INT 2
55596: PUSH
55597: LD_INT 3
55599: PUSH
55600: LD_INT 4
55602: PUSH
55603: LD_INT 5
55605: PUSH
55606: EMPTY
55607: LIST
55608: LIST
55609: LIST
55610: LIST
55611: ST_TO_ADDR
55612: GO 56371
55614: LD_INT 13
55616: DOUBLE
55617: EQUAL
55618: IFTRUE 55622
55620: GO 55648
55622: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55623: LD_ADDR_VAR 0 3
55627: PUSH
55628: LD_INT 2
55630: PUSH
55631: LD_INT 3
55633: PUSH
55634: LD_INT 4
55636: PUSH
55637: LD_INT 5
55639: PUSH
55640: EMPTY
55641: LIST
55642: LIST
55643: LIST
55644: LIST
55645: ST_TO_ADDR
55646: GO 56371
55648: LD_INT 14
55650: DOUBLE
55651: EQUAL
55652: IFTRUE 55656
55654: GO 55674
55656: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55657: LD_ADDR_VAR 0 3
55661: PUSH
55662: LD_INT 4
55664: PUSH
55665: LD_INT 5
55667: PUSH
55668: EMPTY
55669: LIST
55670: LIST
55671: ST_TO_ADDR
55672: GO 56371
55674: LD_INT 6
55676: DOUBLE
55677: EQUAL
55678: IFTRUE 55682
55680: GO 55700
55682: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55683: LD_ADDR_VAR 0 3
55687: PUSH
55688: LD_INT 4
55690: PUSH
55691: LD_INT 5
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: ST_TO_ADDR
55698: GO 56371
55700: LD_INT 10
55702: DOUBLE
55703: EQUAL
55704: IFTRUE 55708
55706: GO 55726
55708: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55709: LD_ADDR_VAR 0 3
55713: PUSH
55714: LD_INT 4
55716: PUSH
55717: LD_INT 5
55719: PUSH
55720: EMPTY
55721: LIST
55722: LIST
55723: ST_TO_ADDR
55724: GO 56371
55726: LD_INT 22
55728: DOUBLE
55729: EQUAL
55730: IFTRUE 55734
55732: GO 55760
55734: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55735: LD_ADDR_VAR 0 3
55739: PUSH
55740: LD_INT 11
55742: PUSH
55743: LD_INT 12
55745: PUSH
55746: LD_INT 13
55748: PUSH
55749: LD_INT 14
55751: PUSH
55752: EMPTY
55753: LIST
55754: LIST
55755: LIST
55756: LIST
55757: ST_TO_ADDR
55758: GO 56371
55760: LD_INT 23
55762: DOUBLE
55763: EQUAL
55764: IFTRUE 55768
55766: GO 55794
55768: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55769: LD_ADDR_VAR 0 3
55773: PUSH
55774: LD_INT 11
55776: PUSH
55777: LD_INT 12
55779: PUSH
55780: LD_INT 13
55782: PUSH
55783: LD_INT 14
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: LIST
55790: LIST
55791: ST_TO_ADDR
55792: GO 56371
55794: LD_INT 24
55796: DOUBLE
55797: EQUAL
55798: IFTRUE 55802
55800: GO 55828
55802: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55803: LD_ADDR_VAR 0 3
55807: PUSH
55808: LD_INT 11
55810: PUSH
55811: LD_INT 12
55813: PUSH
55814: LD_INT 13
55816: PUSH
55817: LD_INT 14
55819: PUSH
55820: EMPTY
55821: LIST
55822: LIST
55823: LIST
55824: LIST
55825: ST_TO_ADDR
55826: GO 56371
55828: LD_INT 30
55830: DOUBLE
55831: EQUAL
55832: IFTRUE 55836
55834: GO 55862
55836: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55837: LD_ADDR_VAR 0 3
55841: PUSH
55842: LD_INT 11
55844: PUSH
55845: LD_INT 12
55847: PUSH
55848: LD_INT 13
55850: PUSH
55851: LD_INT 14
55853: PUSH
55854: EMPTY
55855: LIST
55856: LIST
55857: LIST
55858: LIST
55859: ST_TO_ADDR
55860: GO 56371
55862: LD_INT 25
55864: DOUBLE
55865: EQUAL
55866: IFTRUE 55870
55868: GO 55888
55870: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55871: LD_ADDR_VAR 0 3
55875: PUSH
55876: LD_INT 13
55878: PUSH
55879: LD_INT 14
55881: PUSH
55882: EMPTY
55883: LIST
55884: LIST
55885: ST_TO_ADDR
55886: GO 56371
55888: LD_INT 27
55890: DOUBLE
55891: EQUAL
55892: IFTRUE 55896
55894: GO 55914
55896: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55897: LD_ADDR_VAR 0 3
55901: PUSH
55902: LD_INT 13
55904: PUSH
55905: LD_INT 14
55907: PUSH
55908: EMPTY
55909: LIST
55910: LIST
55911: ST_TO_ADDR
55912: GO 56371
55914: LD_EXP 79
55918: DOUBLE
55919: EQUAL
55920: IFTRUE 55924
55922: GO 55950
55924: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55925: LD_ADDR_VAR 0 3
55929: PUSH
55930: LD_INT 11
55932: PUSH
55933: LD_INT 12
55935: PUSH
55936: LD_INT 13
55938: PUSH
55939: LD_INT 14
55941: PUSH
55942: EMPTY
55943: LIST
55944: LIST
55945: LIST
55946: LIST
55947: ST_TO_ADDR
55948: GO 56371
55950: LD_INT 28
55952: DOUBLE
55953: EQUAL
55954: IFTRUE 55958
55956: GO 55976
55958: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55959: LD_ADDR_VAR 0 3
55963: PUSH
55964: LD_INT 13
55966: PUSH
55967: LD_INT 14
55969: PUSH
55970: EMPTY
55971: LIST
55972: LIST
55973: ST_TO_ADDR
55974: GO 56371
55976: LD_INT 29
55978: DOUBLE
55979: EQUAL
55980: IFTRUE 55984
55982: GO 56002
55984: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55985: LD_ADDR_VAR 0 3
55989: PUSH
55990: LD_INT 13
55992: PUSH
55993: LD_INT 14
55995: PUSH
55996: EMPTY
55997: LIST
55998: LIST
55999: ST_TO_ADDR
56000: GO 56371
56002: LD_INT 31
56004: DOUBLE
56005: EQUAL
56006: IFTRUE 56010
56008: GO 56028
56010: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56011: LD_ADDR_VAR 0 3
56015: PUSH
56016: LD_INT 13
56018: PUSH
56019: LD_INT 14
56021: PUSH
56022: EMPTY
56023: LIST
56024: LIST
56025: ST_TO_ADDR
56026: GO 56371
56028: LD_INT 26
56030: DOUBLE
56031: EQUAL
56032: IFTRUE 56036
56034: GO 56054
56036: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56037: LD_ADDR_VAR 0 3
56041: PUSH
56042: LD_INT 13
56044: PUSH
56045: LD_INT 14
56047: PUSH
56048: EMPTY
56049: LIST
56050: LIST
56051: ST_TO_ADDR
56052: GO 56371
56054: LD_INT 42
56056: DOUBLE
56057: EQUAL
56058: IFTRUE 56062
56060: GO 56088
56062: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56063: LD_ADDR_VAR 0 3
56067: PUSH
56068: LD_INT 21
56070: PUSH
56071: LD_INT 22
56073: PUSH
56074: LD_INT 23
56076: PUSH
56077: LD_INT 24
56079: PUSH
56080: EMPTY
56081: LIST
56082: LIST
56083: LIST
56084: LIST
56085: ST_TO_ADDR
56086: GO 56371
56088: LD_INT 43
56090: DOUBLE
56091: EQUAL
56092: IFTRUE 56096
56094: GO 56122
56096: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56097: LD_ADDR_VAR 0 3
56101: PUSH
56102: LD_INT 21
56104: PUSH
56105: LD_INT 22
56107: PUSH
56108: LD_INT 23
56110: PUSH
56111: LD_INT 24
56113: PUSH
56114: EMPTY
56115: LIST
56116: LIST
56117: LIST
56118: LIST
56119: ST_TO_ADDR
56120: GO 56371
56122: LD_INT 44
56124: DOUBLE
56125: EQUAL
56126: IFTRUE 56130
56128: GO 56156
56130: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56131: LD_ADDR_VAR 0 3
56135: PUSH
56136: LD_INT 21
56138: PUSH
56139: LD_INT 22
56141: PUSH
56142: LD_INT 23
56144: PUSH
56145: LD_INT 24
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: LIST
56152: LIST
56153: ST_TO_ADDR
56154: GO 56371
56156: LD_INT 45
56158: DOUBLE
56159: EQUAL
56160: IFTRUE 56164
56162: GO 56190
56164: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56165: LD_ADDR_VAR 0 3
56169: PUSH
56170: LD_INT 21
56172: PUSH
56173: LD_INT 22
56175: PUSH
56176: LD_INT 23
56178: PUSH
56179: LD_INT 24
56181: PUSH
56182: EMPTY
56183: LIST
56184: LIST
56185: LIST
56186: LIST
56187: ST_TO_ADDR
56188: GO 56371
56190: LD_INT 49
56192: DOUBLE
56193: EQUAL
56194: IFTRUE 56198
56196: GO 56224
56198: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56199: LD_ADDR_VAR 0 3
56203: PUSH
56204: LD_INT 21
56206: PUSH
56207: LD_INT 22
56209: PUSH
56210: LD_INT 23
56212: PUSH
56213: LD_INT 24
56215: PUSH
56216: EMPTY
56217: LIST
56218: LIST
56219: LIST
56220: LIST
56221: ST_TO_ADDR
56222: GO 56371
56224: LD_INT 51
56226: DOUBLE
56227: EQUAL
56228: IFTRUE 56232
56230: GO 56258
56232: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56233: LD_ADDR_VAR 0 3
56237: PUSH
56238: LD_INT 21
56240: PUSH
56241: LD_INT 22
56243: PUSH
56244: LD_INT 23
56246: PUSH
56247: LD_INT 24
56249: PUSH
56250: EMPTY
56251: LIST
56252: LIST
56253: LIST
56254: LIST
56255: ST_TO_ADDR
56256: GO 56371
56258: LD_INT 52
56260: DOUBLE
56261: EQUAL
56262: IFTRUE 56266
56264: GO 56292
56266: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56267: LD_ADDR_VAR 0 3
56271: PUSH
56272: LD_INT 21
56274: PUSH
56275: LD_INT 22
56277: PUSH
56278: LD_INT 23
56280: PUSH
56281: LD_INT 24
56283: PUSH
56284: EMPTY
56285: LIST
56286: LIST
56287: LIST
56288: LIST
56289: ST_TO_ADDR
56290: GO 56371
56292: LD_INT 53
56294: DOUBLE
56295: EQUAL
56296: IFTRUE 56300
56298: GO 56318
56300: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56301: LD_ADDR_VAR 0 3
56305: PUSH
56306: LD_INT 23
56308: PUSH
56309: LD_INT 24
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: ST_TO_ADDR
56316: GO 56371
56318: LD_INT 46
56320: DOUBLE
56321: EQUAL
56322: IFTRUE 56326
56324: GO 56344
56326: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56327: LD_ADDR_VAR 0 3
56331: PUSH
56332: LD_INT 23
56334: PUSH
56335: LD_INT 24
56337: PUSH
56338: EMPTY
56339: LIST
56340: LIST
56341: ST_TO_ADDR
56342: GO 56371
56344: LD_INT 47
56346: DOUBLE
56347: EQUAL
56348: IFTRUE 56352
56350: GO 56370
56352: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56353: LD_ADDR_VAR 0 3
56357: PUSH
56358: LD_INT 23
56360: PUSH
56361: LD_INT 24
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: ST_TO_ADDR
56368: GO 56371
56370: POP
// result := ( chassis in result ) ;
56371: LD_ADDR_VAR 0 3
56375: PUSH
56376: LD_VAR 0 1
56380: PUSH
56381: LD_VAR 0 3
56385: IN
56386: ST_TO_ADDR
// end ;
56387: LD_VAR 0 3
56391: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56392: LD_INT 0
56394: PPUSH
56395: PPUSH
56396: PPUSH
56397: PPUSH
56398: PPUSH
56399: PPUSH
56400: PPUSH
// result := array ;
56401: LD_ADDR_VAR 0 5
56405: PUSH
56406: LD_VAR 0 1
56410: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56411: LD_VAR 0 1
56415: NOT
56416: PUSH
56417: LD_VAR 0 2
56421: NOT
56422: OR
56423: PUSH
56424: LD_VAR 0 3
56428: NOT
56429: OR
56430: PUSH
56431: LD_VAR 0 2
56435: PUSH
56436: LD_VAR 0 1
56440: GREATER
56441: OR
56442: PUSH
56443: LD_VAR 0 3
56447: PUSH
56448: LD_VAR 0 1
56452: GREATER
56453: OR
56454: IFFALSE 56458
// exit ;
56456: GO 56754
// if direction then
56458: LD_VAR 0 4
56462: IFFALSE 56526
// begin d := 1 ;
56464: LD_ADDR_VAR 0 9
56468: PUSH
56469: LD_INT 1
56471: ST_TO_ADDR
// if i_from > i_to then
56472: LD_VAR 0 2
56476: PUSH
56477: LD_VAR 0 3
56481: GREATER
56482: IFFALSE 56508
// length := ( array - i_from ) + i_to else
56484: LD_ADDR_VAR 0 11
56488: PUSH
56489: LD_VAR 0 1
56493: PUSH
56494: LD_VAR 0 2
56498: MINUS
56499: PUSH
56500: LD_VAR 0 3
56504: PLUS
56505: ST_TO_ADDR
56506: GO 56524
// length := i_to - i_from ;
56508: LD_ADDR_VAR 0 11
56512: PUSH
56513: LD_VAR 0 3
56517: PUSH
56518: LD_VAR 0 2
56522: MINUS
56523: ST_TO_ADDR
// end else
56524: GO 56587
// begin d := - 1 ;
56526: LD_ADDR_VAR 0 9
56530: PUSH
56531: LD_INT 1
56533: NEG
56534: ST_TO_ADDR
// if i_from > i_to then
56535: LD_VAR 0 2
56539: PUSH
56540: LD_VAR 0 3
56544: GREATER
56545: IFFALSE 56565
// length := i_from - i_to else
56547: LD_ADDR_VAR 0 11
56551: PUSH
56552: LD_VAR 0 2
56556: PUSH
56557: LD_VAR 0 3
56561: MINUS
56562: ST_TO_ADDR
56563: GO 56587
// length := ( array - i_to ) + i_from ;
56565: LD_ADDR_VAR 0 11
56569: PUSH
56570: LD_VAR 0 1
56574: PUSH
56575: LD_VAR 0 3
56579: MINUS
56580: PUSH
56581: LD_VAR 0 2
56585: PLUS
56586: ST_TO_ADDR
// end ; if not length then
56587: LD_VAR 0 11
56591: NOT
56592: IFFALSE 56596
// exit ;
56594: GO 56754
// tmp := array ;
56596: LD_ADDR_VAR 0 10
56600: PUSH
56601: LD_VAR 0 1
56605: ST_TO_ADDR
// for i = 1 to length do
56606: LD_ADDR_VAR 0 6
56610: PUSH
56611: DOUBLE
56612: LD_INT 1
56614: DEC
56615: ST_TO_ADDR
56616: LD_VAR 0 11
56620: PUSH
56621: FOR_TO
56622: IFFALSE 56742
// begin for j = 1 to array do
56624: LD_ADDR_VAR 0 7
56628: PUSH
56629: DOUBLE
56630: LD_INT 1
56632: DEC
56633: ST_TO_ADDR
56634: LD_VAR 0 1
56638: PUSH
56639: FOR_TO
56640: IFFALSE 56728
// begin k := j + d ;
56642: LD_ADDR_VAR 0 8
56646: PUSH
56647: LD_VAR 0 7
56651: PUSH
56652: LD_VAR 0 9
56656: PLUS
56657: ST_TO_ADDR
// if k > array then
56658: LD_VAR 0 8
56662: PUSH
56663: LD_VAR 0 1
56667: GREATER
56668: IFFALSE 56678
// k := 1 ;
56670: LD_ADDR_VAR 0 8
56674: PUSH
56675: LD_INT 1
56677: ST_TO_ADDR
// if not k then
56678: LD_VAR 0 8
56682: NOT
56683: IFFALSE 56695
// k := array ;
56685: LD_ADDR_VAR 0 8
56689: PUSH
56690: LD_VAR 0 1
56694: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56695: LD_ADDR_VAR 0 10
56699: PUSH
56700: LD_VAR 0 10
56704: PPUSH
56705: LD_VAR 0 8
56709: PPUSH
56710: LD_VAR 0 1
56714: PUSH
56715: LD_VAR 0 7
56719: ARRAY
56720: PPUSH
56721: CALL_OW 1
56725: ST_TO_ADDR
// end ;
56726: GO 56639
56728: POP
56729: POP
// array := tmp ;
56730: LD_ADDR_VAR 0 1
56734: PUSH
56735: LD_VAR 0 10
56739: ST_TO_ADDR
// end ;
56740: GO 56621
56742: POP
56743: POP
// result := array ;
56744: LD_ADDR_VAR 0 5
56748: PUSH
56749: LD_VAR 0 1
56753: ST_TO_ADDR
// end ;
56754: LD_VAR 0 5
56758: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56759: LD_INT 0
56761: PPUSH
56762: PPUSH
// result := 0 ;
56763: LD_ADDR_VAR 0 3
56767: PUSH
56768: LD_INT 0
56770: ST_TO_ADDR
// if not array or not value in array then
56771: LD_VAR 0 1
56775: NOT
56776: PUSH
56777: LD_VAR 0 2
56781: PUSH
56782: LD_VAR 0 1
56786: IN
56787: NOT
56788: OR
56789: IFFALSE 56793
// exit ;
56791: GO 56847
// for i = 1 to array do
56793: LD_ADDR_VAR 0 4
56797: PUSH
56798: DOUBLE
56799: LD_INT 1
56801: DEC
56802: ST_TO_ADDR
56803: LD_VAR 0 1
56807: PUSH
56808: FOR_TO
56809: IFFALSE 56845
// if value = array [ i ] then
56811: LD_VAR 0 2
56815: PUSH
56816: LD_VAR 0 1
56820: PUSH
56821: LD_VAR 0 4
56825: ARRAY
56826: EQUAL
56827: IFFALSE 56843
// begin result := i ;
56829: LD_ADDR_VAR 0 3
56833: PUSH
56834: LD_VAR 0 4
56838: ST_TO_ADDR
// exit ;
56839: POP
56840: POP
56841: GO 56847
// end ;
56843: GO 56808
56845: POP
56846: POP
// end ;
56847: LD_VAR 0 3
56851: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56852: LD_INT 0
56854: PPUSH
// vc_chassis := chassis ;
56855: LD_ADDR_OWVAR 37
56859: PUSH
56860: LD_VAR 0 1
56864: ST_TO_ADDR
// vc_engine := engine ;
56865: LD_ADDR_OWVAR 39
56869: PUSH
56870: LD_VAR 0 2
56874: ST_TO_ADDR
// vc_control := control ;
56875: LD_ADDR_OWVAR 38
56879: PUSH
56880: LD_VAR 0 3
56884: ST_TO_ADDR
// vc_weapon := weapon ;
56885: LD_ADDR_OWVAR 40
56889: PUSH
56890: LD_VAR 0 4
56894: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56895: LD_ADDR_OWVAR 41
56899: PUSH
56900: LD_VAR 0 5
56904: ST_TO_ADDR
// end ;
56905: LD_VAR 0 6
56909: RET
// export function WantPlant ( unit ) ; var task ; begin
56910: LD_INT 0
56912: PPUSH
56913: PPUSH
// result := false ;
56914: LD_ADDR_VAR 0 2
56918: PUSH
56919: LD_INT 0
56921: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56922: LD_ADDR_VAR 0 3
56926: PUSH
56927: LD_VAR 0 1
56931: PPUSH
56932: CALL_OW 437
56936: ST_TO_ADDR
// if task then
56937: LD_VAR 0 3
56941: IFFALSE 56969
// if task [ 1 ] [ 1 ] = p then
56943: LD_VAR 0 3
56947: PUSH
56948: LD_INT 1
56950: ARRAY
56951: PUSH
56952: LD_INT 1
56954: ARRAY
56955: PUSH
56956: LD_STRING p
56958: EQUAL
56959: IFFALSE 56969
// result := true ;
56961: LD_ADDR_VAR 0 2
56965: PUSH
56966: LD_INT 1
56968: ST_TO_ADDR
// end ;
56969: LD_VAR 0 2
56973: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56974: LD_INT 0
56976: PPUSH
56977: PPUSH
56978: PPUSH
56979: PPUSH
// if pos < 1 then
56980: LD_VAR 0 2
56984: PUSH
56985: LD_INT 1
56987: LESS
56988: IFFALSE 56992
// exit ;
56990: GO 57295
// if pos = 1 then
56992: LD_VAR 0 2
56996: PUSH
56997: LD_INT 1
56999: EQUAL
57000: IFFALSE 57033
// result := Replace ( arr , pos [ 1 ] , value ) else
57002: LD_ADDR_VAR 0 4
57006: PUSH
57007: LD_VAR 0 1
57011: PPUSH
57012: LD_VAR 0 2
57016: PUSH
57017: LD_INT 1
57019: ARRAY
57020: PPUSH
57021: LD_VAR 0 3
57025: PPUSH
57026: CALL_OW 1
57030: ST_TO_ADDR
57031: GO 57295
// begin tmp := arr ;
57033: LD_ADDR_VAR 0 6
57037: PUSH
57038: LD_VAR 0 1
57042: ST_TO_ADDR
// s_arr := [ tmp ] ;
57043: LD_ADDR_VAR 0 7
57047: PUSH
57048: LD_VAR 0 6
57052: PUSH
57053: EMPTY
57054: LIST
57055: ST_TO_ADDR
// for i = 1 to pos - 1 do
57056: LD_ADDR_VAR 0 5
57060: PUSH
57061: DOUBLE
57062: LD_INT 1
57064: DEC
57065: ST_TO_ADDR
57066: LD_VAR 0 2
57070: PUSH
57071: LD_INT 1
57073: MINUS
57074: PUSH
57075: FOR_TO
57076: IFFALSE 57121
// begin tmp := tmp [ pos [ i ] ] ;
57078: LD_ADDR_VAR 0 6
57082: PUSH
57083: LD_VAR 0 6
57087: PUSH
57088: LD_VAR 0 2
57092: PUSH
57093: LD_VAR 0 5
57097: ARRAY
57098: ARRAY
57099: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57100: LD_ADDR_VAR 0 7
57104: PUSH
57105: LD_VAR 0 7
57109: PUSH
57110: LD_VAR 0 6
57114: PUSH
57115: EMPTY
57116: LIST
57117: ADD
57118: ST_TO_ADDR
// end ;
57119: GO 57075
57121: POP
57122: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57123: LD_ADDR_VAR 0 6
57127: PUSH
57128: LD_VAR 0 6
57132: PPUSH
57133: LD_VAR 0 2
57137: PUSH
57138: LD_VAR 0 2
57142: ARRAY
57143: PPUSH
57144: LD_VAR 0 3
57148: PPUSH
57149: CALL_OW 1
57153: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57154: LD_ADDR_VAR 0 7
57158: PUSH
57159: LD_VAR 0 7
57163: PPUSH
57164: LD_VAR 0 7
57168: PPUSH
57169: LD_VAR 0 6
57173: PPUSH
57174: CALL_OW 1
57178: ST_TO_ADDR
// for i = s_arr downto 2 do
57179: LD_ADDR_VAR 0 5
57183: PUSH
57184: DOUBLE
57185: LD_VAR 0 7
57189: INC
57190: ST_TO_ADDR
57191: LD_INT 2
57193: PUSH
57194: FOR_DOWNTO
57195: IFFALSE 57279
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57197: LD_ADDR_VAR 0 6
57201: PUSH
57202: LD_VAR 0 7
57206: PUSH
57207: LD_VAR 0 5
57211: PUSH
57212: LD_INT 1
57214: MINUS
57215: ARRAY
57216: PPUSH
57217: LD_VAR 0 2
57221: PUSH
57222: LD_VAR 0 5
57226: PUSH
57227: LD_INT 1
57229: MINUS
57230: ARRAY
57231: PPUSH
57232: LD_VAR 0 7
57236: PUSH
57237: LD_VAR 0 5
57241: ARRAY
57242: PPUSH
57243: CALL_OW 1
57247: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57248: LD_ADDR_VAR 0 7
57252: PUSH
57253: LD_VAR 0 7
57257: PPUSH
57258: LD_VAR 0 5
57262: PUSH
57263: LD_INT 1
57265: MINUS
57266: PPUSH
57267: LD_VAR 0 6
57271: PPUSH
57272: CALL_OW 1
57276: ST_TO_ADDR
// end ;
57277: GO 57194
57279: POP
57280: POP
// result := s_arr [ 1 ] ;
57281: LD_ADDR_VAR 0 4
57285: PUSH
57286: LD_VAR 0 7
57290: PUSH
57291: LD_INT 1
57293: ARRAY
57294: ST_TO_ADDR
// end ; end ;
57295: LD_VAR 0 4
57299: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57300: LD_INT 0
57302: PPUSH
57303: PPUSH
// if not list then
57304: LD_VAR 0 1
57308: NOT
57309: IFFALSE 57313
// exit ;
57311: GO 57404
// i := list [ pos1 ] ;
57313: LD_ADDR_VAR 0 5
57317: PUSH
57318: LD_VAR 0 1
57322: PUSH
57323: LD_VAR 0 2
57327: ARRAY
57328: ST_TO_ADDR
// if not i then
57329: LD_VAR 0 5
57333: NOT
57334: IFFALSE 57338
// exit ;
57336: GO 57404
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57338: LD_ADDR_VAR 0 1
57342: PUSH
57343: LD_VAR 0 1
57347: PPUSH
57348: LD_VAR 0 2
57352: PPUSH
57353: LD_VAR 0 1
57357: PUSH
57358: LD_VAR 0 3
57362: ARRAY
57363: PPUSH
57364: CALL_OW 1
57368: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57369: LD_ADDR_VAR 0 1
57373: PUSH
57374: LD_VAR 0 1
57378: PPUSH
57379: LD_VAR 0 3
57383: PPUSH
57384: LD_VAR 0 5
57388: PPUSH
57389: CALL_OW 1
57393: ST_TO_ADDR
// result := list ;
57394: LD_ADDR_VAR 0 4
57398: PUSH
57399: LD_VAR 0 1
57403: ST_TO_ADDR
// end ;
57404: LD_VAR 0 4
57408: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57409: LD_INT 0
57411: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57412: LD_ADDR_VAR 0 5
57416: PUSH
57417: LD_VAR 0 1
57421: PPUSH
57422: CALL_OW 250
57426: PPUSH
57427: LD_VAR 0 1
57431: PPUSH
57432: CALL_OW 251
57436: PPUSH
57437: LD_VAR 0 2
57441: PPUSH
57442: LD_VAR 0 3
57446: PPUSH
57447: LD_VAR 0 4
57451: PPUSH
57452: CALL 57462 0 5
57456: ST_TO_ADDR
// end ;
57457: LD_VAR 0 5
57461: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57462: LD_INT 0
57464: PPUSH
57465: PPUSH
57466: PPUSH
57467: PPUSH
// if not list then
57468: LD_VAR 0 3
57472: NOT
57473: IFFALSE 57477
// exit ;
57475: GO 57865
// result := [ ] ;
57477: LD_ADDR_VAR 0 6
57481: PUSH
57482: EMPTY
57483: ST_TO_ADDR
// for i in list do
57484: LD_ADDR_VAR 0 7
57488: PUSH
57489: LD_VAR 0 3
57493: PUSH
57494: FOR_IN
57495: IFFALSE 57697
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57497: LD_ADDR_VAR 0 9
57501: PUSH
57502: LD_VAR 0 7
57506: PPUSH
57507: LD_VAR 0 1
57511: PPUSH
57512: LD_VAR 0 2
57516: PPUSH
57517: CALL_OW 297
57521: ST_TO_ADDR
// if not result then
57522: LD_VAR 0 6
57526: NOT
57527: IFFALSE 57553
// result := [ [ i , tmp ] ] else
57529: LD_ADDR_VAR 0 6
57533: PUSH
57534: LD_VAR 0 7
57538: PUSH
57539: LD_VAR 0 9
57543: PUSH
57544: EMPTY
57545: LIST
57546: LIST
57547: PUSH
57548: EMPTY
57549: LIST
57550: ST_TO_ADDR
57551: GO 57695
// begin if result [ result ] [ 2 ] < tmp then
57553: LD_VAR 0 6
57557: PUSH
57558: LD_VAR 0 6
57562: ARRAY
57563: PUSH
57564: LD_INT 2
57566: ARRAY
57567: PUSH
57568: LD_VAR 0 9
57572: LESS
57573: IFFALSE 57615
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57575: LD_ADDR_VAR 0 6
57579: PUSH
57580: LD_VAR 0 6
57584: PPUSH
57585: LD_VAR 0 6
57589: PUSH
57590: LD_INT 1
57592: PLUS
57593: PPUSH
57594: LD_VAR 0 7
57598: PUSH
57599: LD_VAR 0 9
57603: PUSH
57604: EMPTY
57605: LIST
57606: LIST
57607: PPUSH
57608: CALL_OW 2
57612: ST_TO_ADDR
57613: GO 57695
// for j = 1 to result do
57615: LD_ADDR_VAR 0 8
57619: PUSH
57620: DOUBLE
57621: LD_INT 1
57623: DEC
57624: ST_TO_ADDR
57625: LD_VAR 0 6
57629: PUSH
57630: FOR_TO
57631: IFFALSE 57693
// begin if tmp < result [ j ] [ 2 ] then
57633: LD_VAR 0 9
57637: PUSH
57638: LD_VAR 0 6
57642: PUSH
57643: LD_VAR 0 8
57647: ARRAY
57648: PUSH
57649: LD_INT 2
57651: ARRAY
57652: LESS
57653: IFFALSE 57691
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57655: LD_ADDR_VAR 0 6
57659: PUSH
57660: LD_VAR 0 6
57664: PPUSH
57665: LD_VAR 0 8
57669: PPUSH
57670: LD_VAR 0 7
57674: PUSH
57675: LD_VAR 0 9
57679: PUSH
57680: EMPTY
57681: LIST
57682: LIST
57683: PPUSH
57684: CALL_OW 2
57688: ST_TO_ADDR
// break ;
57689: GO 57693
// end ; end ;
57691: GO 57630
57693: POP
57694: POP
// end ; end ;
57695: GO 57494
57697: POP
57698: POP
// if result and not asc then
57699: LD_VAR 0 6
57703: PUSH
57704: LD_VAR 0 4
57708: NOT
57709: AND
57710: IFFALSE 57785
// begin tmp := result ;
57712: LD_ADDR_VAR 0 9
57716: PUSH
57717: LD_VAR 0 6
57721: ST_TO_ADDR
// for i = tmp downto 1 do
57722: LD_ADDR_VAR 0 7
57726: PUSH
57727: DOUBLE
57728: LD_VAR 0 9
57732: INC
57733: ST_TO_ADDR
57734: LD_INT 1
57736: PUSH
57737: FOR_DOWNTO
57738: IFFALSE 57783
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57740: LD_ADDR_VAR 0 6
57744: PUSH
57745: LD_VAR 0 6
57749: PPUSH
57750: LD_VAR 0 9
57754: PUSH
57755: LD_VAR 0 7
57759: MINUS
57760: PUSH
57761: LD_INT 1
57763: PLUS
57764: PPUSH
57765: LD_VAR 0 9
57769: PUSH
57770: LD_VAR 0 7
57774: ARRAY
57775: PPUSH
57776: CALL_OW 1
57780: ST_TO_ADDR
57781: GO 57737
57783: POP
57784: POP
// end ; tmp := [ ] ;
57785: LD_ADDR_VAR 0 9
57789: PUSH
57790: EMPTY
57791: ST_TO_ADDR
// if mode then
57792: LD_VAR 0 5
57796: IFFALSE 57865
// begin for i = 1 to result do
57798: LD_ADDR_VAR 0 7
57802: PUSH
57803: DOUBLE
57804: LD_INT 1
57806: DEC
57807: ST_TO_ADDR
57808: LD_VAR 0 6
57812: PUSH
57813: FOR_TO
57814: IFFALSE 57853
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57816: LD_ADDR_VAR 0 9
57820: PUSH
57821: LD_VAR 0 9
57825: PPUSH
57826: LD_VAR 0 7
57830: PPUSH
57831: LD_VAR 0 6
57835: PUSH
57836: LD_VAR 0 7
57840: ARRAY
57841: PUSH
57842: LD_INT 1
57844: ARRAY
57845: PPUSH
57846: CALL_OW 1
57850: ST_TO_ADDR
57851: GO 57813
57853: POP
57854: POP
// result := tmp ;
57855: LD_ADDR_VAR 0 6
57859: PUSH
57860: LD_VAR 0 9
57864: ST_TO_ADDR
// end ; end ;
57865: LD_VAR 0 6
57869: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57870: LD_INT 0
57872: PPUSH
57873: PPUSH
57874: PPUSH
57875: PPUSH
57876: PPUSH
57877: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57878: LD_ADDR_VAR 0 5
57882: PUSH
57883: LD_INT 0
57885: PUSH
57886: LD_INT 0
57888: PUSH
57889: LD_INT 0
57891: PUSH
57892: EMPTY
57893: PUSH
57894: EMPTY
57895: LIST
57896: LIST
57897: LIST
57898: LIST
57899: ST_TO_ADDR
// if not x or not y then
57900: LD_VAR 0 2
57904: NOT
57905: PUSH
57906: LD_VAR 0 3
57910: NOT
57911: OR
57912: IFFALSE 57916
// exit ;
57914: GO 59568
// if not range then
57916: LD_VAR 0 4
57920: NOT
57921: IFFALSE 57931
// range := 10 ;
57923: LD_ADDR_VAR 0 4
57927: PUSH
57928: LD_INT 10
57930: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57931: LD_ADDR_VAR 0 8
57935: PUSH
57936: LD_INT 81
57938: PUSH
57939: LD_VAR 0 1
57943: PUSH
57944: EMPTY
57945: LIST
57946: LIST
57947: PUSH
57948: LD_INT 92
57950: PUSH
57951: LD_VAR 0 2
57955: PUSH
57956: LD_VAR 0 3
57960: PUSH
57961: LD_VAR 0 4
57965: PUSH
57966: EMPTY
57967: LIST
57968: LIST
57969: LIST
57970: LIST
57971: PUSH
57972: LD_INT 3
57974: PUSH
57975: LD_INT 21
57977: PUSH
57978: LD_INT 3
57980: PUSH
57981: EMPTY
57982: LIST
57983: LIST
57984: PUSH
57985: EMPTY
57986: LIST
57987: LIST
57988: PUSH
57989: EMPTY
57990: LIST
57991: LIST
57992: LIST
57993: PPUSH
57994: CALL_OW 69
57998: ST_TO_ADDR
// if not tmp then
57999: LD_VAR 0 8
58003: NOT
58004: IFFALSE 58008
// exit ;
58006: GO 59568
// for i in tmp do
58008: LD_ADDR_VAR 0 6
58012: PUSH
58013: LD_VAR 0 8
58017: PUSH
58018: FOR_IN
58019: IFFALSE 59543
// begin points := [ 0 , 0 , 0 ] ;
58021: LD_ADDR_VAR 0 9
58025: PUSH
58026: LD_INT 0
58028: PUSH
58029: LD_INT 0
58031: PUSH
58032: LD_INT 0
58034: PUSH
58035: EMPTY
58036: LIST
58037: LIST
58038: LIST
58039: ST_TO_ADDR
// bpoints := 1 ;
58040: LD_ADDR_VAR 0 10
58044: PUSH
58045: LD_INT 1
58047: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58048: LD_VAR 0 6
58052: PPUSH
58053: CALL_OW 247
58057: PUSH
58058: LD_INT 1
58060: DOUBLE
58061: EQUAL
58062: IFTRUE 58066
58064: GO 58644
58066: POP
// begin if GetClass ( i ) = 1 then
58067: LD_VAR 0 6
58071: PPUSH
58072: CALL_OW 257
58076: PUSH
58077: LD_INT 1
58079: EQUAL
58080: IFFALSE 58101
// points := [ 10 , 5 , 3 ] ;
58082: LD_ADDR_VAR 0 9
58086: PUSH
58087: LD_INT 10
58089: PUSH
58090: LD_INT 5
58092: PUSH
58093: LD_INT 3
58095: PUSH
58096: EMPTY
58097: LIST
58098: LIST
58099: LIST
58100: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58101: LD_VAR 0 6
58105: PPUSH
58106: CALL_OW 257
58110: PUSH
58111: LD_INT 2
58113: PUSH
58114: LD_INT 3
58116: PUSH
58117: LD_INT 4
58119: PUSH
58120: EMPTY
58121: LIST
58122: LIST
58123: LIST
58124: IN
58125: IFFALSE 58146
// points := [ 3 , 2 , 1 ] ;
58127: LD_ADDR_VAR 0 9
58131: PUSH
58132: LD_INT 3
58134: PUSH
58135: LD_INT 2
58137: PUSH
58138: LD_INT 1
58140: PUSH
58141: EMPTY
58142: LIST
58143: LIST
58144: LIST
58145: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58146: LD_VAR 0 6
58150: PPUSH
58151: CALL_OW 257
58155: PUSH
58156: LD_INT 5
58158: EQUAL
58159: IFFALSE 58180
// points := [ 130 , 5 , 2 ] ;
58161: LD_ADDR_VAR 0 9
58165: PUSH
58166: LD_INT 130
58168: PUSH
58169: LD_INT 5
58171: PUSH
58172: LD_INT 2
58174: PUSH
58175: EMPTY
58176: LIST
58177: LIST
58178: LIST
58179: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58180: LD_VAR 0 6
58184: PPUSH
58185: CALL_OW 257
58189: PUSH
58190: LD_INT 8
58192: EQUAL
58193: IFFALSE 58214
// points := [ 35 , 35 , 30 ] ;
58195: LD_ADDR_VAR 0 9
58199: PUSH
58200: LD_INT 35
58202: PUSH
58203: LD_INT 35
58205: PUSH
58206: LD_INT 30
58208: PUSH
58209: EMPTY
58210: LIST
58211: LIST
58212: LIST
58213: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58214: LD_VAR 0 6
58218: PPUSH
58219: CALL_OW 257
58223: PUSH
58224: LD_INT 9
58226: EQUAL
58227: IFFALSE 58248
// points := [ 20 , 55 , 40 ] ;
58229: LD_ADDR_VAR 0 9
58233: PUSH
58234: LD_INT 20
58236: PUSH
58237: LD_INT 55
58239: PUSH
58240: LD_INT 40
58242: PUSH
58243: EMPTY
58244: LIST
58245: LIST
58246: LIST
58247: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58248: LD_VAR 0 6
58252: PPUSH
58253: CALL_OW 257
58257: PUSH
58258: LD_INT 12
58260: PUSH
58261: LD_INT 16
58263: PUSH
58264: EMPTY
58265: LIST
58266: LIST
58267: IN
58268: IFFALSE 58289
// points := [ 5 , 3 , 2 ] ;
58270: LD_ADDR_VAR 0 9
58274: PUSH
58275: LD_INT 5
58277: PUSH
58278: LD_INT 3
58280: PUSH
58281: LD_INT 2
58283: PUSH
58284: EMPTY
58285: LIST
58286: LIST
58287: LIST
58288: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58289: LD_VAR 0 6
58293: PPUSH
58294: CALL_OW 257
58298: PUSH
58299: LD_INT 17
58301: EQUAL
58302: IFFALSE 58323
// points := [ 100 , 50 , 75 ] ;
58304: LD_ADDR_VAR 0 9
58308: PUSH
58309: LD_INT 100
58311: PUSH
58312: LD_INT 50
58314: PUSH
58315: LD_INT 75
58317: PUSH
58318: EMPTY
58319: LIST
58320: LIST
58321: LIST
58322: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58323: LD_VAR 0 6
58327: PPUSH
58328: CALL_OW 257
58332: PUSH
58333: LD_INT 15
58335: EQUAL
58336: IFFALSE 58357
// points := [ 10 , 5 , 3 ] ;
58338: LD_ADDR_VAR 0 9
58342: PUSH
58343: LD_INT 10
58345: PUSH
58346: LD_INT 5
58348: PUSH
58349: LD_INT 3
58351: PUSH
58352: EMPTY
58353: LIST
58354: LIST
58355: LIST
58356: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58357: LD_VAR 0 6
58361: PPUSH
58362: CALL_OW 257
58366: PUSH
58367: LD_INT 14
58369: EQUAL
58370: IFFALSE 58391
// points := [ 10 , 0 , 0 ] ;
58372: LD_ADDR_VAR 0 9
58376: PUSH
58377: LD_INT 10
58379: PUSH
58380: LD_INT 0
58382: PUSH
58383: LD_INT 0
58385: PUSH
58386: EMPTY
58387: LIST
58388: LIST
58389: LIST
58390: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58391: LD_VAR 0 6
58395: PPUSH
58396: CALL_OW 257
58400: PUSH
58401: LD_INT 11
58403: EQUAL
58404: IFFALSE 58425
// points := [ 30 , 10 , 5 ] ;
58406: LD_ADDR_VAR 0 9
58410: PUSH
58411: LD_INT 30
58413: PUSH
58414: LD_INT 10
58416: PUSH
58417: LD_INT 5
58419: PUSH
58420: EMPTY
58421: LIST
58422: LIST
58423: LIST
58424: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58425: LD_VAR 0 1
58429: PPUSH
58430: LD_INT 5
58432: PPUSH
58433: CALL_OW 321
58437: PUSH
58438: LD_INT 2
58440: EQUAL
58441: IFFALSE 58458
// bpoints := bpoints * 1.8 ;
58443: LD_ADDR_VAR 0 10
58447: PUSH
58448: LD_VAR 0 10
58452: PUSH
58453: LD_REAL  1.80000000000000E+0000
58456: MUL
58457: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58458: LD_VAR 0 6
58462: PPUSH
58463: CALL_OW 257
58467: PUSH
58468: LD_INT 1
58470: PUSH
58471: LD_INT 2
58473: PUSH
58474: LD_INT 3
58476: PUSH
58477: LD_INT 4
58479: PUSH
58480: EMPTY
58481: LIST
58482: LIST
58483: LIST
58484: LIST
58485: IN
58486: PUSH
58487: LD_VAR 0 1
58491: PPUSH
58492: LD_INT 51
58494: PPUSH
58495: CALL_OW 321
58499: PUSH
58500: LD_INT 2
58502: EQUAL
58503: AND
58504: IFFALSE 58521
// bpoints := bpoints * 1.2 ;
58506: LD_ADDR_VAR 0 10
58510: PUSH
58511: LD_VAR 0 10
58515: PUSH
58516: LD_REAL  1.20000000000000E+0000
58519: MUL
58520: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58521: LD_VAR 0 6
58525: PPUSH
58526: CALL_OW 257
58530: PUSH
58531: LD_INT 5
58533: PUSH
58534: LD_INT 7
58536: PUSH
58537: LD_INT 9
58539: PUSH
58540: EMPTY
58541: LIST
58542: LIST
58543: LIST
58544: IN
58545: PUSH
58546: LD_VAR 0 1
58550: PPUSH
58551: LD_INT 52
58553: PPUSH
58554: CALL_OW 321
58558: PUSH
58559: LD_INT 2
58561: EQUAL
58562: AND
58563: IFFALSE 58580
// bpoints := bpoints * 1.5 ;
58565: LD_ADDR_VAR 0 10
58569: PUSH
58570: LD_VAR 0 10
58574: PUSH
58575: LD_REAL  1.50000000000000E+0000
58578: MUL
58579: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58580: LD_VAR 0 1
58584: PPUSH
58585: LD_INT 66
58587: PPUSH
58588: CALL_OW 321
58592: PUSH
58593: LD_INT 2
58595: EQUAL
58596: IFFALSE 58613
// bpoints := bpoints * 1.1 ;
58598: LD_ADDR_VAR 0 10
58602: PUSH
58603: LD_VAR 0 10
58607: PUSH
58608: LD_REAL  1.10000000000000E+0000
58611: MUL
58612: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58613: LD_ADDR_VAR 0 10
58617: PUSH
58618: LD_VAR 0 10
58622: PUSH
58623: LD_VAR 0 6
58627: PPUSH
58628: LD_INT 1
58630: PPUSH
58631: CALL_OW 259
58635: PUSH
58636: LD_REAL  1.15000000000000E+0000
58639: MUL
58640: MUL
58641: ST_TO_ADDR
// end ; unit_vehicle :
58642: GO 59472
58644: LD_INT 2
58646: DOUBLE
58647: EQUAL
58648: IFTRUE 58652
58650: GO 59460
58652: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58653: LD_VAR 0 6
58657: PPUSH
58658: CALL_OW 264
58662: PUSH
58663: LD_INT 2
58665: PUSH
58666: LD_INT 42
58668: PUSH
58669: LD_INT 24
58671: PUSH
58672: EMPTY
58673: LIST
58674: LIST
58675: LIST
58676: IN
58677: IFFALSE 58698
// points := [ 25 , 5 , 3 ] ;
58679: LD_ADDR_VAR 0 9
58683: PUSH
58684: LD_INT 25
58686: PUSH
58687: LD_INT 5
58689: PUSH
58690: LD_INT 3
58692: PUSH
58693: EMPTY
58694: LIST
58695: LIST
58696: LIST
58697: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58698: LD_VAR 0 6
58702: PPUSH
58703: CALL_OW 264
58707: PUSH
58708: LD_INT 4
58710: PUSH
58711: LD_INT 43
58713: PUSH
58714: LD_INT 25
58716: PUSH
58717: EMPTY
58718: LIST
58719: LIST
58720: LIST
58721: IN
58722: IFFALSE 58743
// points := [ 40 , 15 , 5 ] ;
58724: LD_ADDR_VAR 0 9
58728: PUSH
58729: LD_INT 40
58731: PUSH
58732: LD_INT 15
58734: PUSH
58735: LD_INT 5
58737: PUSH
58738: EMPTY
58739: LIST
58740: LIST
58741: LIST
58742: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58743: LD_VAR 0 6
58747: PPUSH
58748: CALL_OW 264
58752: PUSH
58753: LD_INT 3
58755: PUSH
58756: LD_INT 23
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: IN
58763: IFFALSE 58784
// points := [ 7 , 25 , 8 ] ;
58765: LD_ADDR_VAR 0 9
58769: PUSH
58770: LD_INT 7
58772: PUSH
58773: LD_INT 25
58775: PUSH
58776: LD_INT 8
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: LIST
58783: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58784: LD_VAR 0 6
58788: PPUSH
58789: CALL_OW 264
58793: PUSH
58794: LD_INT 5
58796: PUSH
58797: LD_INT 27
58799: PUSH
58800: LD_INT 44
58802: PUSH
58803: EMPTY
58804: LIST
58805: LIST
58806: LIST
58807: IN
58808: IFFALSE 58829
// points := [ 14 , 50 , 16 ] ;
58810: LD_ADDR_VAR 0 9
58814: PUSH
58815: LD_INT 14
58817: PUSH
58818: LD_INT 50
58820: PUSH
58821: LD_INT 16
58823: PUSH
58824: EMPTY
58825: LIST
58826: LIST
58827: LIST
58828: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58829: LD_VAR 0 6
58833: PPUSH
58834: CALL_OW 264
58838: PUSH
58839: LD_INT 6
58841: PUSH
58842: LD_INT 46
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: IN
58849: IFFALSE 58870
// points := [ 32 , 120 , 70 ] ;
58851: LD_ADDR_VAR 0 9
58855: PUSH
58856: LD_INT 32
58858: PUSH
58859: LD_INT 120
58861: PUSH
58862: LD_INT 70
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: LIST
58869: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58870: LD_VAR 0 6
58874: PPUSH
58875: CALL_OW 264
58879: PUSH
58880: LD_INT 7
58882: PUSH
58883: LD_INT 28
58885: PUSH
58886: LD_INT 45
58888: PUSH
58889: LD_EXP 79
58893: PUSH
58894: EMPTY
58895: LIST
58896: LIST
58897: LIST
58898: LIST
58899: IN
58900: IFFALSE 58921
// points := [ 35 , 20 , 45 ] ;
58902: LD_ADDR_VAR 0 9
58906: PUSH
58907: LD_INT 35
58909: PUSH
58910: LD_INT 20
58912: PUSH
58913: LD_INT 45
58915: PUSH
58916: EMPTY
58917: LIST
58918: LIST
58919: LIST
58920: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58921: LD_VAR 0 6
58925: PPUSH
58926: CALL_OW 264
58930: PUSH
58931: LD_INT 47
58933: PUSH
58934: EMPTY
58935: LIST
58936: IN
58937: IFFALSE 58958
// points := [ 67 , 45 , 75 ] ;
58939: LD_ADDR_VAR 0 9
58943: PUSH
58944: LD_INT 67
58946: PUSH
58947: LD_INT 45
58949: PUSH
58950: LD_INT 75
58952: PUSH
58953: EMPTY
58954: LIST
58955: LIST
58956: LIST
58957: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58958: LD_VAR 0 6
58962: PPUSH
58963: CALL_OW 264
58967: PUSH
58968: LD_INT 26
58970: PUSH
58971: EMPTY
58972: LIST
58973: IN
58974: IFFALSE 58995
// points := [ 120 , 30 , 80 ] ;
58976: LD_ADDR_VAR 0 9
58980: PUSH
58981: LD_INT 120
58983: PUSH
58984: LD_INT 30
58986: PUSH
58987: LD_INT 80
58989: PUSH
58990: EMPTY
58991: LIST
58992: LIST
58993: LIST
58994: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58995: LD_VAR 0 6
58999: PPUSH
59000: CALL_OW 264
59004: PUSH
59005: LD_INT 22
59007: PUSH
59008: EMPTY
59009: LIST
59010: IN
59011: IFFALSE 59032
// points := [ 40 , 1 , 1 ] ;
59013: LD_ADDR_VAR 0 9
59017: PUSH
59018: LD_INT 40
59020: PUSH
59021: LD_INT 1
59023: PUSH
59024: LD_INT 1
59026: PUSH
59027: EMPTY
59028: LIST
59029: LIST
59030: LIST
59031: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59032: LD_VAR 0 6
59036: PPUSH
59037: CALL_OW 264
59041: PUSH
59042: LD_INT 29
59044: PUSH
59045: EMPTY
59046: LIST
59047: IN
59048: IFFALSE 59069
// points := [ 70 , 200 , 400 ] ;
59050: LD_ADDR_VAR 0 9
59054: PUSH
59055: LD_INT 70
59057: PUSH
59058: LD_INT 200
59060: PUSH
59061: LD_INT 400
59063: PUSH
59064: EMPTY
59065: LIST
59066: LIST
59067: LIST
59068: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59069: LD_VAR 0 6
59073: PPUSH
59074: CALL_OW 264
59078: PUSH
59079: LD_INT 14
59081: PUSH
59082: LD_INT 53
59084: PUSH
59085: EMPTY
59086: LIST
59087: LIST
59088: IN
59089: IFFALSE 59110
// points := [ 40 , 10 , 20 ] ;
59091: LD_ADDR_VAR 0 9
59095: PUSH
59096: LD_INT 40
59098: PUSH
59099: LD_INT 10
59101: PUSH
59102: LD_INT 20
59104: PUSH
59105: EMPTY
59106: LIST
59107: LIST
59108: LIST
59109: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59110: LD_VAR 0 6
59114: PPUSH
59115: CALL_OW 264
59119: PUSH
59120: LD_INT 9
59122: PUSH
59123: EMPTY
59124: LIST
59125: IN
59126: IFFALSE 59147
// points := [ 5 , 70 , 20 ] ;
59128: LD_ADDR_VAR 0 9
59132: PUSH
59133: LD_INT 5
59135: PUSH
59136: LD_INT 70
59138: PUSH
59139: LD_INT 20
59141: PUSH
59142: EMPTY
59143: LIST
59144: LIST
59145: LIST
59146: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59147: LD_VAR 0 6
59151: PPUSH
59152: CALL_OW 264
59156: PUSH
59157: LD_INT 10
59159: PUSH
59160: EMPTY
59161: LIST
59162: IN
59163: IFFALSE 59184
// points := [ 35 , 110 , 70 ] ;
59165: LD_ADDR_VAR 0 9
59169: PUSH
59170: LD_INT 35
59172: PUSH
59173: LD_INT 110
59175: PUSH
59176: LD_INT 70
59178: PUSH
59179: EMPTY
59180: LIST
59181: LIST
59182: LIST
59183: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59184: LD_VAR 0 6
59188: PPUSH
59189: CALL_OW 265
59193: PUSH
59194: LD_INT 25
59196: EQUAL
59197: IFFALSE 59218
// points := [ 80 , 65 , 100 ] ;
59199: LD_ADDR_VAR 0 9
59203: PUSH
59204: LD_INT 80
59206: PUSH
59207: LD_INT 65
59209: PUSH
59210: LD_INT 100
59212: PUSH
59213: EMPTY
59214: LIST
59215: LIST
59216: LIST
59217: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59218: LD_VAR 0 6
59222: PPUSH
59223: CALL_OW 263
59227: PUSH
59228: LD_INT 1
59230: EQUAL
59231: IFFALSE 59266
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59233: LD_ADDR_VAR 0 10
59237: PUSH
59238: LD_VAR 0 10
59242: PUSH
59243: LD_VAR 0 6
59247: PPUSH
59248: CALL_OW 311
59252: PPUSH
59253: LD_INT 3
59255: PPUSH
59256: CALL_OW 259
59260: PUSH
59261: LD_INT 4
59263: MUL
59264: MUL
59265: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59266: LD_VAR 0 6
59270: PPUSH
59271: CALL_OW 263
59275: PUSH
59276: LD_INT 2
59278: EQUAL
59279: IFFALSE 59330
// begin j := IsControledBy ( i ) ;
59281: LD_ADDR_VAR 0 7
59285: PUSH
59286: LD_VAR 0 6
59290: PPUSH
59291: CALL_OW 312
59295: ST_TO_ADDR
// if j then
59296: LD_VAR 0 7
59300: IFFALSE 59330
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59302: LD_ADDR_VAR 0 10
59306: PUSH
59307: LD_VAR 0 10
59311: PUSH
59312: LD_VAR 0 7
59316: PPUSH
59317: LD_INT 3
59319: PPUSH
59320: CALL_OW 259
59324: PUSH
59325: LD_INT 3
59327: MUL
59328: MUL
59329: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59330: LD_VAR 0 6
59334: PPUSH
59335: CALL_OW 264
59339: PUSH
59340: LD_INT 5
59342: PUSH
59343: LD_INT 6
59345: PUSH
59346: LD_INT 46
59348: PUSH
59349: LD_INT 44
59351: PUSH
59352: LD_INT 47
59354: PUSH
59355: LD_INT 45
59357: PUSH
59358: LD_INT 28
59360: PUSH
59361: LD_INT 7
59363: PUSH
59364: LD_INT 27
59366: PUSH
59367: LD_INT 29
59369: PUSH
59370: EMPTY
59371: LIST
59372: LIST
59373: LIST
59374: LIST
59375: LIST
59376: LIST
59377: LIST
59378: LIST
59379: LIST
59380: LIST
59381: IN
59382: PUSH
59383: LD_VAR 0 1
59387: PPUSH
59388: LD_INT 52
59390: PPUSH
59391: CALL_OW 321
59395: PUSH
59396: LD_INT 2
59398: EQUAL
59399: AND
59400: IFFALSE 59417
// bpoints := bpoints * 1.2 ;
59402: LD_ADDR_VAR 0 10
59406: PUSH
59407: LD_VAR 0 10
59411: PUSH
59412: LD_REAL  1.20000000000000E+0000
59415: MUL
59416: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59417: LD_VAR 0 6
59421: PPUSH
59422: CALL_OW 264
59426: PUSH
59427: LD_INT 6
59429: PUSH
59430: LD_INT 46
59432: PUSH
59433: LD_INT 47
59435: PUSH
59436: EMPTY
59437: LIST
59438: LIST
59439: LIST
59440: IN
59441: IFFALSE 59458
// bpoints := bpoints * 1.2 ;
59443: LD_ADDR_VAR 0 10
59447: PUSH
59448: LD_VAR 0 10
59452: PUSH
59453: LD_REAL  1.20000000000000E+0000
59456: MUL
59457: ST_TO_ADDR
// end ; unit_building :
59458: GO 59472
59460: LD_INT 3
59462: DOUBLE
59463: EQUAL
59464: IFTRUE 59468
59466: GO 59471
59468: POP
// ; end ;
59469: GO 59472
59471: POP
// for j = 1 to 3 do
59472: LD_ADDR_VAR 0 7
59476: PUSH
59477: DOUBLE
59478: LD_INT 1
59480: DEC
59481: ST_TO_ADDR
59482: LD_INT 3
59484: PUSH
59485: FOR_TO
59486: IFFALSE 59539
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59488: LD_ADDR_VAR 0 5
59492: PUSH
59493: LD_VAR 0 5
59497: PPUSH
59498: LD_VAR 0 7
59502: PPUSH
59503: LD_VAR 0 5
59507: PUSH
59508: LD_VAR 0 7
59512: ARRAY
59513: PUSH
59514: LD_VAR 0 9
59518: PUSH
59519: LD_VAR 0 7
59523: ARRAY
59524: PUSH
59525: LD_VAR 0 10
59529: MUL
59530: PLUS
59531: PPUSH
59532: CALL_OW 1
59536: ST_TO_ADDR
59537: GO 59485
59539: POP
59540: POP
// end ;
59541: GO 58018
59543: POP
59544: POP
// result := Replace ( result , 4 , tmp ) ;
59545: LD_ADDR_VAR 0 5
59549: PUSH
59550: LD_VAR 0 5
59554: PPUSH
59555: LD_INT 4
59557: PPUSH
59558: LD_VAR 0 8
59562: PPUSH
59563: CALL_OW 1
59567: ST_TO_ADDR
// end ;
59568: LD_VAR 0 5
59572: RET
// export function DangerAtRange ( unit , range ) ; begin
59573: LD_INT 0
59575: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59576: LD_ADDR_VAR 0 3
59580: PUSH
59581: LD_VAR 0 1
59585: PPUSH
59586: CALL_OW 255
59590: PPUSH
59591: LD_VAR 0 1
59595: PPUSH
59596: CALL_OW 250
59600: PPUSH
59601: LD_VAR 0 1
59605: PPUSH
59606: CALL_OW 251
59610: PPUSH
59611: LD_VAR 0 2
59615: PPUSH
59616: CALL 57870 0 4
59620: ST_TO_ADDR
// end ;
59621: LD_VAR 0 3
59625: RET
// export function DangerInArea ( side , area ) ; begin
59626: LD_INT 0
59628: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59629: LD_ADDR_VAR 0 3
59633: PUSH
59634: LD_VAR 0 2
59638: PPUSH
59639: LD_INT 81
59641: PUSH
59642: LD_VAR 0 1
59646: PUSH
59647: EMPTY
59648: LIST
59649: LIST
59650: PPUSH
59651: CALL_OW 70
59655: ST_TO_ADDR
// end ;
59656: LD_VAR 0 3
59660: RET
// export function IsExtension ( b ) ; begin
59661: LD_INT 0
59663: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59664: LD_ADDR_VAR 0 2
59668: PUSH
59669: LD_VAR 0 1
59673: PUSH
59674: LD_INT 23
59676: PUSH
59677: LD_INT 20
59679: PUSH
59680: LD_INT 22
59682: PUSH
59683: LD_INT 17
59685: PUSH
59686: LD_INT 24
59688: PUSH
59689: LD_INT 21
59691: PUSH
59692: LD_INT 19
59694: PUSH
59695: LD_INT 16
59697: PUSH
59698: LD_INT 25
59700: PUSH
59701: LD_INT 18
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: LIST
59708: LIST
59709: LIST
59710: LIST
59711: LIST
59712: LIST
59713: LIST
59714: LIST
59715: IN
59716: ST_TO_ADDR
// end ;
59717: LD_VAR 0 2
59721: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59722: LD_INT 0
59724: PPUSH
59725: PPUSH
59726: PPUSH
// result := [ ] ;
59727: LD_ADDR_VAR 0 4
59731: PUSH
59732: EMPTY
59733: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59734: LD_ADDR_VAR 0 5
59738: PUSH
59739: LD_VAR 0 2
59743: PPUSH
59744: LD_INT 21
59746: PUSH
59747: LD_INT 3
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PPUSH
59754: CALL_OW 70
59758: ST_TO_ADDR
// if not tmp then
59759: LD_VAR 0 5
59763: NOT
59764: IFFALSE 59768
// exit ;
59766: GO 59832
// if checkLink then
59768: LD_VAR 0 3
59772: IFFALSE 59822
// begin for i in tmp do
59774: LD_ADDR_VAR 0 6
59778: PUSH
59779: LD_VAR 0 5
59783: PUSH
59784: FOR_IN
59785: IFFALSE 59820
// if GetBase ( i ) <> base then
59787: LD_VAR 0 6
59791: PPUSH
59792: CALL_OW 274
59796: PUSH
59797: LD_VAR 0 1
59801: NONEQUAL
59802: IFFALSE 59818
// ComLinkToBase ( base , i ) ;
59804: LD_VAR 0 1
59808: PPUSH
59809: LD_VAR 0 6
59813: PPUSH
59814: CALL_OW 169
59818: GO 59784
59820: POP
59821: POP
// end ; result := tmp ;
59822: LD_ADDR_VAR 0 4
59826: PUSH
59827: LD_VAR 0 5
59831: ST_TO_ADDR
// end ;
59832: LD_VAR 0 4
59836: RET
// export function ComComplete ( units , b ) ; var i ; begin
59837: LD_INT 0
59839: PPUSH
59840: PPUSH
// if not units then
59841: LD_VAR 0 1
59845: NOT
59846: IFFALSE 59850
// exit ;
59848: GO 59940
// for i in units do
59850: LD_ADDR_VAR 0 4
59854: PUSH
59855: LD_VAR 0 1
59859: PUSH
59860: FOR_IN
59861: IFFALSE 59938
// if BuildingStatus ( b ) = bs_build then
59863: LD_VAR 0 2
59867: PPUSH
59868: CALL_OW 461
59872: PUSH
59873: LD_INT 1
59875: EQUAL
59876: IFFALSE 59936
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59878: LD_VAR 0 4
59882: PPUSH
59883: LD_STRING h
59885: PUSH
59886: LD_VAR 0 2
59890: PPUSH
59891: CALL_OW 250
59895: PUSH
59896: LD_VAR 0 2
59900: PPUSH
59901: CALL_OW 251
59905: PUSH
59906: LD_VAR 0 2
59910: PUSH
59911: LD_INT 0
59913: PUSH
59914: LD_INT 0
59916: PUSH
59917: LD_INT 0
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: LIST
59924: LIST
59925: LIST
59926: LIST
59927: LIST
59928: PUSH
59929: EMPTY
59930: LIST
59931: PPUSH
59932: CALL_OW 446
59936: GO 59860
59938: POP
59939: POP
// end ;
59940: LD_VAR 0 3
59944: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59945: LD_INT 0
59947: PPUSH
59948: PPUSH
59949: PPUSH
59950: PPUSH
59951: PPUSH
59952: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59953: LD_VAR 0 1
59957: NOT
59958: PUSH
59959: LD_VAR 0 1
59963: PPUSH
59964: CALL_OW 263
59968: PUSH
59969: LD_INT 2
59971: NONEQUAL
59972: OR
59973: IFFALSE 59977
// exit ;
59975: GO 60293
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59977: LD_ADDR_VAR 0 6
59981: PUSH
59982: LD_INT 22
59984: PUSH
59985: LD_VAR 0 1
59989: PPUSH
59990: CALL_OW 255
59994: PUSH
59995: EMPTY
59996: LIST
59997: LIST
59998: PUSH
59999: LD_INT 2
60001: PUSH
60002: LD_INT 30
60004: PUSH
60005: LD_INT 36
60007: PUSH
60008: EMPTY
60009: LIST
60010: LIST
60011: PUSH
60012: LD_INT 34
60014: PUSH
60015: LD_INT 31
60017: PUSH
60018: EMPTY
60019: LIST
60020: LIST
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: LIST
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PPUSH
60031: CALL_OW 69
60035: ST_TO_ADDR
// if not tmp then
60036: LD_VAR 0 6
60040: NOT
60041: IFFALSE 60045
// exit ;
60043: GO 60293
// result := [ ] ;
60045: LD_ADDR_VAR 0 2
60049: PUSH
60050: EMPTY
60051: ST_TO_ADDR
// for i in tmp do
60052: LD_ADDR_VAR 0 3
60056: PUSH
60057: LD_VAR 0 6
60061: PUSH
60062: FOR_IN
60063: IFFALSE 60134
// begin t := UnitsInside ( i ) ;
60065: LD_ADDR_VAR 0 4
60069: PUSH
60070: LD_VAR 0 3
60074: PPUSH
60075: CALL_OW 313
60079: ST_TO_ADDR
// if t then
60080: LD_VAR 0 4
60084: IFFALSE 60132
// for j in t do
60086: LD_ADDR_VAR 0 7
60090: PUSH
60091: LD_VAR 0 4
60095: PUSH
60096: FOR_IN
60097: IFFALSE 60130
// result := Replace ( result , result + 1 , j ) ;
60099: LD_ADDR_VAR 0 2
60103: PUSH
60104: LD_VAR 0 2
60108: PPUSH
60109: LD_VAR 0 2
60113: PUSH
60114: LD_INT 1
60116: PLUS
60117: PPUSH
60118: LD_VAR 0 7
60122: PPUSH
60123: CALL_OW 1
60127: ST_TO_ADDR
60128: GO 60096
60130: POP
60131: POP
// end ;
60132: GO 60062
60134: POP
60135: POP
// if not result then
60136: LD_VAR 0 2
60140: NOT
60141: IFFALSE 60145
// exit ;
60143: GO 60293
// mech := result [ 1 ] ;
60145: LD_ADDR_VAR 0 5
60149: PUSH
60150: LD_VAR 0 2
60154: PUSH
60155: LD_INT 1
60157: ARRAY
60158: ST_TO_ADDR
// if result > 1 then
60159: LD_VAR 0 2
60163: PUSH
60164: LD_INT 1
60166: GREATER
60167: IFFALSE 60279
// begin for i = 2 to result do
60169: LD_ADDR_VAR 0 3
60173: PUSH
60174: DOUBLE
60175: LD_INT 2
60177: DEC
60178: ST_TO_ADDR
60179: LD_VAR 0 2
60183: PUSH
60184: FOR_TO
60185: IFFALSE 60277
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60187: LD_ADDR_VAR 0 4
60191: PUSH
60192: LD_VAR 0 2
60196: PUSH
60197: LD_VAR 0 3
60201: ARRAY
60202: PPUSH
60203: LD_INT 3
60205: PPUSH
60206: CALL_OW 259
60210: PUSH
60211: LD_VAR 0 2
60215: PUSH
60216: LD_VAR 0 3
60220: ARRAY
60221: PPUSH
60222: CALL_OW 432
60226: MINUS
60227: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60228: LD_VAR 0 4
60232: PUSH
60233: LD_VAR 0 5
60237: PPUSH
60238: LD_INT 3
60240: PPUSH
60241: CALL_OW 259
60245: PUSH
60246: LD_VAR 0 5
60250: PPUSH
60251: CALL_OW 432
60255: MINUS
60256: GREATEREQUAL
60257: IFFALSE 60275
// mech := result [ i ] ;
60259: LD_ADDR_VAR 0 5
60263: PUSH
60264: LD_VAR 0 2
60268: PUSH
60269: LD_VAR 0 3
60273: ARRAY
60274: ST_TO_ADDR
// end ;
60275: GO 60184
60277: POP
60278: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60279: LD_VAR 0 1
60283: PPUSH
60284: LD_VAR 0 5
60288: PPUSH
60289: CALL_OW 135
// end ;
60293: LD_VAR 0 2
60297: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60298: LD_INT 0
60300: PPUSH
60301: PPUSH
60302: PPUSH
60303: PPUSH
60304: PPUSH
60305: PPUSH
60306: PPUSH
60307: PPUSH
60308: PPUSH
60309: PPUSH
60310: PPUSH
60311: PPUSH
60312: PPUSH
// result := [ ] ;
60313: LD_ADDR_VAR 0 7
60317: PUSH
60318: EMPTY
60319: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60320: LD_VAR 0 1
60324: PPUSH
60325: CALL_OW 266
60329: PUSH
60330: LD_INT 0
60332: PUSH
60333: LD_INT 1
60335: PUSH
60336: EMPTY
60337: LIST
60338: LIST
60339: IN
60340: NOT
60341: IFFALSE 60345
// exit ;
60343: GO 61979
// if name then
60345: LD_VAR 0 3
60349: IFFALSE 60365
// SetBName ( base_dep , name ) ;
60351: LD_VAR 0 1
60355: PPUSH
60356: LD_VAR 0 3
60360: PPUSH
60361: CALL_OW 500
// base := GetBase ( base_dep ) ;
60365: LD_ADDR_VAR 0 15
60369: PUSH
60370: LD_VAR 0 1
60374: PPUSH
60375: CALL_OW 274
60379: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60380: LD_ADDR_VAR 0 16
60384: PUSH
60385: LD_VAR 0 1
60389: PPUSH
60390: CALL_OW 255
60394: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60395: LD_ADDR_VAR 0 17
60399: PUSH
60400: LD_VAR 0 1
60404: PPUSH
60405: CALL_OW 248
60409: ST_TO_ADDR
// if sources then
60410: LD_VAR 0 5
60414: IFFALSE 60461
// for i = 1 to 3 do
60416: LD_ADDR_VAR 0 8
60420: PUSH
60421: DOUBLE
60422: LD_INT 1
60424: DEC
60425: ST_TO_ADDR
60426: LD_INT 3
60428: PUSH
60429: FOR_TO
60430: IFFALSE 60459
// AddResourceType ( base , i , sources [ i ] ) ;
60432: LD_VAR 0 15
60436: PPUSH
60437: LD_VAR 0 8
60441: PPUSH
60442: LD_VAR 0 5
60446: PUSH
60447: LD_VAR 0 8
60451: ARRAY
60452: PPUSH
60453: CALL_OW 276
60457: GO 60429
60459: POP
60460: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60461: LD_ADDR_VAR 0 18
60465: PUSH
60466: LD_VAR 0 15
60470: PPUSH
60471: LD_VAR 0 2
60475: PPUSH
60476: LD_INT 1
60478: PPUSH
60479: CALL 59722 0 3
60483: ST_TO_ADDR
// InitHc ;
60484: CALL_OW 19
// InitUc ;
60488: CALL_OW 18
// uc_side := side ;
60492: LD_ADDR_OWVAR 20
60496: PUSH
60497: LD_VAR 0 16
60501: ST_TO_ADDR
// uc_nation := nation ;
60502: LD_ADDR_OWVAR 21
60506: PUSH
60507: LD_VAR 0 17
60511: ST_TO_ADDR
// if buildings then
60512: LD_VAR 0 18
60516: IFFALSE 61838
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60518: LD_ADDR_VAR 0 19
60522: PUSH
60523: LD_VAR 0 18
60527: PPUSH
60528: LD_INT 2
60530: PUSH
60531: LD_INT 30
60533: PUSH
60534: LD_INT 29
60536: PUSH
60537: EMPTY
60538: LIST
60539: LIST
60540: PUSH
60541: LD_INT 30
60543: PUSH
60544: LD_INT 30
60546: PUSH
60547: EMPTY
60548: LIST
60549: LIST
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: LIST
60555: PPUSH
60556: CALL_OW 72
60560: ST_TO_ADDR
// if tmp then
60561: LD_VAR 0 19
60565: IFFALSE 60613
// for i in tmp do
60567: LD_ADDR_VAR 0 8
60571: PUSH
60572: LD_VAR 0 19
60576: PUSH
60577: FOR_IN
60578: IFFALSE 60611
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60580: LD_VAR 0 8
60584: PPUSH
60585: CALL_OW 250
60589: PPUSH
60590: LD_VAR 0 8
60594: PPUSH
60595: CALL_OW 251
60599: PPUSH
60600: LD_VAR 0 16
60604: PPUSH
60605: CALL_OW 441
60609: GO 60577
60611: POP
60612: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60613: LD_VAR 0 18
60617: PPUSH
60618: LD_INT 2
60620: PUSH
60621: LD_INT 30
60623: PUSH
60624: LD_INT 32
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: PUSH
60631: LD_INT 30
60633: PUSH
60634: LD_INT 33
60636: PUSH
60637: EMPTY
60638: LIST
60639: LIST
60640: PUSH
60641: EMPTY
60642: LIST
60643: LIST
60644: LIST
60645: PPUSH
60646: CALL_OW 72
60650: IFFALSE 60738
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60652: LD_ADDR_VAR 0 8
60656: PUSH
60657: LD_VAR 0 18
60661: PPUSH
60662: LD_INT 2
60664: PUSH
60665: LD_INT 30
60667: PUSH
60668: LD_INT 32
60670: PUSH
60671: EMPTY
60672: LIST
60673: LIST
60674: PUSH
60675: LD_INT 30
60677: PUSH
60678: LD_INT 33
60680: PUSH
60681: EMPTY
60682: LIST
60683: LIST
60684: PUSH
60685: EMPTY
60686: LIST
60687: LIST
60688: LIST
60689: PPUSH
60690: CALL_OW 72
60694: PUSH
60695: FOR_IN
60696: IFFALSE 60736
// begin if not GetBWeapon ( i ) then
60698: LD_VAR 0 8
60702: PPUSH
60703: CALL_OW 269
60707: NOT
60708: IFFALSE 60734
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60710: LD_VAR 0 8
60714: PPUSH
60715: LD_VAR 0 8
60719: PPUSH
60720: LD_VAR 0 2
60724: PPUSH
60725: CALL 61984 0 2
60729: PPUSH
60730: CALL_OW 431
// end ;
60734: GO 60695
60736: POP
60737: POP
// end ; for i = 1 to personel do
60738: LD_ADDR_VAR 0 8
60742: PUSH
60743: DOUBLE
60744: LD_INT 1
60746: DEC
60747: ST_TO_ADDR
60748: LD_VAR 0 6
60752: PUSH
60753: FOR_TO
60754: IFFALSE 61818
// begin if i > 4 then
60756: LD_VAR 0 8
60760: PUSH
60761: LD_INT 4
60763: GREATER
60764: IFFALSE 60768
// break ;
60766: GO 61818
// case i of 1 :
60768: LD_VAR 0 8
60772: PUSH
60773: LD_INT 1
60775: DOUBLE
60776: EQUAL
60777: IFTRUE 60781
60779: GO 60861
60781: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60782: LD_ADDR_VAR 0 12
60786: PUSH
60787: LD_VAR 0 18
60791: PPUSH
60792: LD_INT 22
60794: PUSH
60795: LD_VAR 0 16
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: PUSH
60804: LD_INT 58
60806: PUSH
60807: EMPTY
60808: LIST
60809: PUSH
60810: LD_INT 2
60812: PUSH
60813: LD_INT 30
60815: PUSH
60816: LD_INT 32
60818: PUSH
60819: EMPTY
60820: LIST
60821: LIST
60822: PUSH
60823: LD_INT 30
60825: PUSH
60826: LD_INT 4
60828: PUSH
60829: EMPTY
60830: LIST
60831: LIST
60832: PUSH
60833: LD_INT 30
60835: PUSH
60836: LD_INT 5
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: PUSH
60843: EMPTY
60844: LIST
60845: LIST
60846: LIST
60847: LIST
60848: PUSH
60849: EMPTY
60850: LIST
60851: LIST
60852: LIST
60853: PPUSH
60854: CALL_OW 72
60858: ST_TO_ADDR
60859: GO 61083
60861: LD_INT 2
60863: DOUBLE
60864: EQUAL
60865: IFTRUE 60869
60867: GO 60931
60869: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60870: LD_ADDR_VAR 0 12
60874: PUSH
60875: LD_VAR 0 18
60879: PPUSH
60880: LD_INT 22
60882: PUSH
60883: LD_VAR 0 16
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: PUSH
60892: LD_INT 2
60894: PUSH
60895: LD_INT 30
60897: PUSH
60898: LD_INT 0
60900: PUSH
60901: EMPTY
60902: LIST
60903: LIST
60904: PUSH
60905: LD_INT 30
60907: PUSH
60908: LD_INT 1
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PUSH
60915: EMPTY
60916: LIST
60917: LIST
60918: LIST
60919: PUSH
60920: EMPTY
60921: LIST
60922: LIST
60923: PPUSH
60924: CALL_OW 72
60928: ST_TO_ADDR
60929: GO 61083
60931: LD_INT 3
60933: DOUBLE
60934: EQUAL
60935: IFTRUE 60939
60937: GO 61001
60939: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60940: LD_ADDR_VAR 0 12
60944: PUSH
60945: LD_VAR 0 18
60949: PPUSH
60950: LD_INT 22
60952: PUSH
60953: LD_VAR 0 16
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PUSH
60962: LD_INT 2
60964: PUSH
60965: LD_INT 30
60967: PUSH
60968: LD_INT 2
60970: PUSH
60971: EMPTY
60972: LIST
60973: LIST
60974: PUSH
60975: LD_INT 30
60977: PUSH
60978: LD_INT 3
60980: PUSH
60981: EMPTY
60982: LIST
60983: LIST
60984: PUSH
60985: EMPTY
60986: LIST
60987: LIST
60988: LIST
60989: PUSH
60990: EMPTY
60991: LIST
60992: LIST
60993: PPUSH
60994: CALL_OW 72
60998: ST_TO_ADDR
60999: GO 61083
61001: LD_INT 4
61003: DOUBLE
61004: EQUAL
61005: IFTRUE 61009
61007: GO 61082
61009: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61010: LD_ADDR_VAR 0 12
61014: PUSH
61015: LD_VAR 0 18
61019: PPUSH
61020: LD_INT 22
61022: PUSH
61023: LD_VAR 0 16
61027: PUSH
61028: EMPTY
61029: LIST
61030: LIST
61031: PUSH
61032: LD_INT 2
61034: PUSH
61035: LD_INT 30
61037: PUSH
61038: LD_INT 6
61040: PUSH
61041: EMPTY
61042: LIST
61043: LIST
61044: PUSH
61045: LD_INT 30
61047: PUSH
61048: LD_INT 7
61050: PUSH
61051: EMPTY
61052: LIST
61053: LIST
61054: PUSH
61055: LD_INT 30
61057: PUSH
61058: LD_INT 8
61060: PUSH
61061: EMPTY
61062: LIST
61063: LIST
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: LIST
61069: LIST
61070: PUSH
61071: EMPTY
61072: LIST
61073: LIST
61074: PPUSH
61075: CALL_OW 72
61079: ST_TO_ADDR
61080: GO 61083
61082: POP
// if i = 1 then
61083: LD_VAR 0 8
61087: PUSH
61088: LD_INT 1
61090: EQUAL
61091: IFFALSE 61202
// begin tmp := [ ] ;
61093: LD_ADDR_VAR 0 19
61097: PUSH
61098: EMPTY
61099: ST_TO_ADDR
// for j in f do
61100: LD_ADDR_VAR 0 9
61104: PUSH
61105: LD_VAR 0 12
61109: PUSH
61110: FOR_IN
61111: IFFALSE 61184
// if GetBType ( j ) = b_bunker then
61113: LD_VAR 0 9
61117: PPUSH
61118: CALL_OW 266
61122: PUSH
61123: LD_INT 32
61125: EQUAL
61126: IFFALSE 61153
// tmp := Insert ( tmp , 1 , j ) else
61128: LD_ADDR_VAR 0 19
61132: PUSH
61133: LD_VAR 0 19
61137: PPUSH
61138: LD_INT 1
61140: PPUSH
61141: LD_VAR 0 9
61145: PPUSH
61146: CALL_OW 2
61150: ST_TO_ADDR
61151: GO 61182
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61153: LD_ADDR_VAR 0 19
61157: PUSH
61158: LD_VAR 0 19
61162: PPUSH
61163: LD_VAR 0 19
61167: PUSH
61168: LD_INT 1
61170: PLUS
61171: PPUSH
61172: LD_VAR 0 9
61176: PPUSH
61177: CALL_OW 2
61181: ST_TO_ADDR
61182: GO 61110
61184: POP
61185: POP
// if tmp then
61186: LD_VAR 0 19
61190: IFFALSE 61202
// f := tmp ;
61192: LD_ADDR_VAR 0 12
61196: PUSH
61197: LD_VAR 0 19
61201: ST_TO_ADDR
// end ; x := personel [ i ] ;
61202: LD_ADDR_VAR 0 13
61206: PUSH
61207: LD_VAR 0 6
61211: PUSH
61212: LD_VAR 0 8
61216: ARRAY
61217: ST_TO_ADDR
// if x = - 1 then
61218: LD_VAR 0 13
61222: PUSH
61223: LD_INT 1
61225: NEG
61226: EQUAL
61227: IFFALSE 61436
// begin for j in f do
61229: LD_ADDR_VAR 0 9
61233: PUSH
61234: LD_VAR 0 12
61238: PUSH
61239: FOR_IN
61240: IFFALSE 61432
// repeat InitHc ;
61242: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61246: LD_VAR 0 9
61250: PPUSH
61251: CALL_OW 266
61255: PUSH
61256: LD_INT 5
61258: EQUAL
61259: IFFALSE 61329
// begin if UnitsInside ( j ) < 3 then
61261: LD_VAR 0 9
61265: PPUSH
61266: CALL_OW 313
61270: PUSH
61271: LD_INT 3
61273: LESS
61274: IFFALSE 61310
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61276: LD_INT 0
61278: PPUSH
61279: LD_INT 5
61281: PUSH
61282: LD_INT 8
61284: PUSH
61285: LD_INT 9
61287: PUSH
61288: EMPTY
61289: LIST
61290: LIST
61291: LIST
61292: PUSH
61293: LD_VAR 0 17
61297: ARRAY
61298: PPUSH
61299: LD_VAR 0 4
61303: PPUSH
61304: CALL_OW 380
61308: GO 61327
// PrepareHuman ( false , i , skill ) ;
61310: LD_INT 0
61312: PPUSH
61313: LD_VAR 0 8
61317: PPUSH
61318: LD_VAR 0 4
61322: PPUSH
61323: CALL_OW 380
// end else
61327: GO 61346
// PrepareHuman ( false , i , skill ) ;
61329: LD_INT 0
61331: PPUSH
61332: LD_VAR 0 8
61336: PPUSH
61337: LD_VAR 0 4
61341: PPUSH
61342: CALL_OW 380
// un := CreateHuman ;
61346: LD_ADDR_VAR 0 14
61350: PUSH
61351: CALL_OW 44
61355: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61356: LD_ADDR_VAR 0 7
61360: PUSH
61361: LD_VAR 0 7
61365: PPUSH
61366: LD_INT 1
61368: PPUSH
61369: LD_VAR 0 14
61373: PPUSH
61374: CALL_OW 2
61378: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61379: LD_VAR 0 14
61383: PPUSH
61384: LD_VAR 0 9
61388: PPUSH
61389: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61393: LD_VAR 0 9
61397: PPUSH
61398: CALL_OW 313
61402: PUSH
61403: LD_INT 6
61405: EQUAL
61406: PUSH
61407: LD_VAR 0 9
61411: PPUSH
61412: CALL_OW 266
61416: PUSH
61417: LD_INT 32
61419: PUSH
61420: LD_INT 31
61422: PUSH
61423: EMPTY
61424: LIST
61425: LIST
61426: IN
61427: OR
61428: IFFALSE 61242
61430: GO 61239
61432: POP
61433: POP
// end else
61434: GO 61816
// for j = 1 to x do
61436: LD_ADDR_VAR 0 9
61440: PUSH
61441: DOUBLE
61442: LD_INT 1
61444: DEC
61445: ST_TO_ADDR
61446: LD_VAR 0 13
61450: PUSH
61451: FOR_TO
61452: IFFALSE 61814
// begin InitHc ;
61454: CALL_OW 19
// if not f then
61458: LD_VAR 0 12
61462: NOT
61463: IFFALSE 61552
// begin PrepareHuman ( false , i , skill ) ;
61465: LD_INT 0
61467: PPUSH
61468: LD_VAR 0 8
61472: PPUSH
61473: LD_VAR 0 4
61477: PPUSH
61478: CALL_OW 380
// un := CreateHuman ;
61482: LD_ADDR_VAR 0 14
61486: PUSH
61487: CALL_OW 44
61491: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61492: LD_ADDR_VAR 0 7
61496: PUSH
61497: LD_VAR 0 7
61501: PPUSH
61502: LD_INT 1
61504: PPUSH
61505: LD_VAR 0 14
61509: PPUSH
61510: CALL_OW 2
61514: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61515: LD_VAR 0 14
61519: PPUSH
61520: LD_VAR 0 1
61524: PPUSH
61525: CALL_OW 250
61529: PPUSH
61530: LD_VAR 0 1
61534: PPUSH
61535: CALL_OW 251
61539: PPUSH
61540: LD_INT 10
61542: PPUSH
61543: LD_INT 0
61545: PPUSH
61546: CALL_OW 50
// continue ;
61550: GO 61451
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61552: LD_VAR 0 12
61556: PUSH
61557: LD_INT 1
61559: ARRAY
61560: PPUSH
61561: CALL_OW 313
61565: PUSH
61566: LD_VAR 0 12
61570: PUSH
61571: LD_INT 1
61573: ARRAY
61574: PPUSH
61575: CALL_OW 266
61579: PUSH
61580: LD_INT 32
61582: PUSH
61583: LD_INT 31
61585: PUSH
61586: EMPTY
61587: LIST
61588: LIST
61589: IN
61590: AND
61591: PUSH
61592: LD_VAR 0 12
61596: PUSH
61597: LD_INT 1
61599: ARRAY
61600: PPUSH
61601: CALL_OW 313
61605: PUSH
61606: LD_INT 6
61608: EQUAL
61609: OR
61610: IFFALSE 61630
// f := Delete ( f , 1 ) ;
61612: LD_ADDR_VAR 0 12
61616: PUSH
61617: LD_VAR 0 12
61621: PPUSH
61622: LD_INT 1
61624: PPUSH
61625: CALL_OW 3
61629: ST_TO_ADDR
// if not f then
61630: LD_VAR 0 12
61634: NOT
61635: IFFALSE 61653
// begin x := x + 2 ;
61637: LD_ADDR_VAR 0 13
61641: PUSH
61642: LD_VAR 0 13
61646: PUSH
61647: LD_INT 2
61649: PLUS
61650: ST_TO_ADDR
// continue ;
61651: GO 61451
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61653: LD_VAR 0 12
61657: PUSH
61658: LD_INT 1
61660: ARRAY
61661: PPUSH
61662: CALL_OW 266
61666: PUSH
61667: LD_INT 5
61669: EQUAL
61670: IFFALSE 61744
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61672: LD_VAR 0 12
61676: PUSH
61677: LD_INT 1
61679: ARRAY
61680: PPUSH
61681: CALL_OW 313
61685: PUSH
61686: LD_INT 3
61688: LESS
61689: IFFALSE 61725
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61691: LD_INT 0
61693: PPUSH
61694: LD_INT 5
61696: PUSH
61697: LD_INT 8
61699: PUSH
61700: LD_INT 9
61702: PUSH
61703: EMPTY
61704: LIST
61705: LIST
61706: LIST
61707: PUSH
61708: LD_VAR 0 17
61712: ARRAY
61713: PPUSH
61714: LD_VAR 0 4
61718: PPUSH
61719: CALL_OW 380
61723: GO 61742
// PrepareHuman ( false , i , skill ) ;
61725: LD_INT 0
61727: PPUSH
61728: LD_VAR 0 8
61732: PPUSH
61733: LD_VAR 0 4
61737: PPUSH
61738: CALL_OW 380
// end else
61742: GO 61761
// PrepareHuman ( false , i , skill ) ;
61744: LD_INT 0
61746: PPUSH
61747: LD_VAR 0 8
61751: PPUSH
61752: LD_VAR 0 4
61756: PPUSH
61757: CALL_OW 380
// un := CreateHuman ;
61761: LD_ADDR_VAR 0 14
61765: PUSH
61766: CALL_OW 44
61770: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61771: LD_ADDR_VAR 0 7
61775: PUSH
61776: LD_VAR 0 7
61780: PPUSH
61781: LD_INT 1
61783: PPUSH
61784: LD_VAR 0 14
61788: PPUSH
61789: CALL_OW 2
61793: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61794: LD_VAR 0 14
61798: PPUSH
61799: LD_VAR 0 12
61803: PUSH
61804: LD_INT 1
61806: ARRAY
61807: PPUSH
61808: CALL_OW 52
// end ;
61812: GO 61451
61814: POP
61815: POP
// end ;
61816: GO 60753
61818: POP
61819: POP
// result := result ^ buildings ;
61820: LD_ADDR_VAR 0 7
61824: PUSH
61825: LD_VAR 0 7
61829: PUSH
61830: LD_VAR 0 18
61834: ADD
61835: ST_TO_ADDR
// end else
61836: GO 61979
// begin for i = 1 to personel do
61838: LD_ADDR_VAR 0 8
61842: PUSH
61843: DOUBLE
61844: LD_INT 1
61846: DEC
61847: ST_TO_ADDR
61848: LD_VAR 0 6
61852: PUSH
61853: FOR_TO
61854: IFFALSE 61977
// begin if i > 4 then
61856: LD_VAR 0 8
61860: PUSH
61861: LD_INT 4
61863: GREATER
61864: IFFALSE 61868
// break ;
61866: GO 61977
// x := personel [ i ] ;
61868: LD_ADDR_VAR 0 13
61872: PUSH
61873: LD_VAR 0 6
61877: PUSH
61878: LD_VAR 0 8
61882: ARRAY
61883: ST_TO_ADDR
// if x = - 1 then
61884: LD_VAR 0 13
61888: PUSH
61889: LD_INT 1
61891: NEG
61892: EQUAL
61893: IFFALSE 61897
// continue ;
61895: GO 61853
// PrepareHuman ( false , i , skill ) ;
61897: LD_INT 0
61899: PPUSH
61900: LD_VAR 0 8
61904: PPUSH
61905: LD_VAR 0 4
61909: PPUSH
61910: CALL_OW 380
// un := CreateHuman ;
61914: LD_ADDR_VAR 0 14
61918: PUSH
61919: CALL_OW 44
61923: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61924: LD_VAR 0 14
61928: PPUSH
61929: LD_VAR 0 1
61933: PPUSH
61934: CALL_OW 250
61938: PPUSH
61939: LD_VAR 0 1
61943: PPUSH
61944: CALL_OW 251
61948: PPUSH
61949: LD_INT 10
61951: PPUSH
61952: LD_INT 0
61954: PPUSH
61955: CALL_OW 50
// result := result ^ un ;
61959: LD_ADDR_VAR 0 7
61963: PUSH
61964: LD_VAR 0 7
61968: PUSH
61969: LD_VAR 0 14
61973: ADD
61974: ST_TO_ADDR
// end ;
61975: GO 61853
61977: POP
61978: POP
// end ; end ;
61979: LD_VAR 0 7
61983: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61984: LD_INT 0
61986: PPUSH
61987: PPUSH
61988: PPUSH
61989: PPUSH
61990: PPUSH
61991: PPUSH
61992: PPUSH
61993: PPUSH
61994: PPUSH
61995: PPUSH
61996: PPUSH
61997: PPUSH
61998: PPUSH
61999: PPUSH
62000: PPUSH
62001: PPUSH
// result := false ;
62002: LD_ADDR_VAR 0 3
62006: PUSH
62007: LD_INT 0
62009: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62010: LD_VAR 0 1
62014: NOT
62015: PUSH
62016: LD_VAR 0 1
62020: PPUSH
62021: CALL_OW 266
62025: PUSH
62026: LD_INT 32
62028: PUSH
62029: LD_INT 33
62031: PUSH
62032: EMPTY
62033: LIST
62034: LIST
62035: IN
62036: NOT
62037: OR
62038: IFFALSE 62042
// exit ;
62040: GO 63151
// nat := GetNation ( tower ) ;
62042: LD_ADDR_VAR 0 12
62046: PUSH
62047: LD_VAR 0 1
62051: PPUSH
62052: CALL_OW 248
62056: ST_TO_ADDR
// side := GetSide ( tower ) ;
62057: LD_ADDR_VAR 0 16
62061: PUSH
62062: LD_VAR 0 1
62066: PPUSH
62067: CALL_OW 255
62071: ST_TO_ADDR
// x := GetX ( tower ) ;
62072: LD_ADDR_VAR 0 10
62076: PUSH
62077: LD_VAR 0 1
62081: PPUSH
62082: CALL_OW 250
62086: ST_TO_ADDR
// y := GetY ( tower ) ;
62087: LD_ADDR_VAR 0 11
62091: PUSH
62092: LD_VAR 0 1
62096: PPUSH
62097: CALL_OW 251
62101: ST_TO_ADDR
// if not x or not y then
62102: LD_VAR 0 10
62106: NOT
62107: PUSH
62108: LD_VAR 0 11
62112: NOT
62113: OR
62114: IFFALSE 62118
// exit ;
62116: GO 63151
// weapon := 0 ;
62118: LD_ADDR_VAR 0 18
62122: PUSH
62123: LD_INT 0
62125: ST_TO_ADDR
// fac_list := [ ] ;
62126: LD_ADDR_VAR 0 17
62130: PUSH
62131: EMPTY
62132: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62133: LD_ADDR_VAR 0 6
62137: PUSH
62138: LD_VAR 0 1
62142: PPUSH
62143: CALL_OW 274
62147: PPUSH
62148: LD_VAR 0 2
62152: PPUSH
62153: LD_INT 0
62155: PPUSH
62156: CALL 59722 0 3
62160: PPUSH
62161: LD_INT 30
62163: PUSH
62164: LD_INT 3
62166: PUSH
62167: EMPTY
62168: LIST
62169: LIST
62170: PPUSH
62171: CALL_OW 72
62175: ST_TO_ADDR
// if not factories then
62176: LD_VAR 0 6
62180: NOT
62181: IFFALSE 62185
// exit ;
62183: GO 63151
// for i in factories do
62185: LD_ADDR_VAR 0 8
62189: PUSH
62190: LD_VAR 0 6
62194: PUSH
62195: FOR_IN
62196: IFFALSE 62221
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62198: LD_ADDR_VAR 0 17
62202: PUSH
62203: LD_VAR 0 17
62207: PUSH
62208: LD_VAR 0 8
62212: PPUSH
62213: CALL_OW 478
62217: UNION
62218: ST_TO_ADDR
62219: GO 62195
62221: POP
62222: POP
// if not fac_list then
62223: LD_VAR 0 17
62227: NOT
62228: IFFALSE 62232
// exit ;
62230: GO 63151
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62232: LD_ADDR_VAR 0 5
62236: PUSH
62237: LD_INT 4
62239: PUSH
62240: LD_INT 5
62242: PUSH
62243: LD_INT 9
62245: PUSH
62246: LD_INT 10
62248: PUSH
62249: LD_INT 6
62251: PUSH
62252: LD_INT 7
62254: PUSH
62255: LD_INT 11
62257: PUSH
62258: EMPTY
62259: LIST
62260: LIST
62261: LIST
62262: LIST
62263: LIST
62264: LIST
62265: LIST
62266: PUSH
62267: LD_INT 27
62269: PUSH
62270: LD_INT 28
62272: PUSH
62273: LD_INT 26
62275: PUSH
62276: LD_INT 30
62278: PUSH
62279: EMPTY
62280: LIST
62281: LIST
62282: LIST
62283: LIST
62284: PUSH
62285: LD_INT 43
62287: PUSH
62288: LD_INT 44
62290: PUSH
62291: LD_INT 46
62293: PUSH
62294: LD_INT 45
62296: PUSH
62297: LD_INT 47
62299: PUSH
62300: LD_INT 49
62302: PUSH
62303: EMPTY
62304: LIST
62305: LIST
62306: LIST
62307: LIST
62308: LIST
62309: LIST
62310: PUSH
62311: EMPTY
62312: LIST
62313: LIST
62314: LIST
62315: PUSH
62316: LD_VAR 0 12
62320: ARRAY
62321: ST_TO_ADDR
// list := list isect fac_list ;
62322: LD_ADDR_VAR 0 5
62326: PUSH
62327: LD_VAR 0 5
62331: PUSH
62332: LD_VAR 0 17
62336: ISECT
62337: ST_TO_ADDR
// if not list then
62338: LD_VAR 0 5
62342: NOT
62343: IFFALSE 62347
// exit ;
62345: GO 63151
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62347: LD_VAR 0 12
62351: PUSH
62352: LD_INT 3
62354: EQUAL
62355: PUSH
62356: LD_INT 49
62358: PUSH
62359: LD_VAR 0 5
62363: IN
62364: AND
62365: PUSH
62366: LD_INT 31
62368: PPUSH
62369: LD_VAR 0 16
62373: PPUSH
62374: CALL_OW 321
62378: PUSH
62379: LD_INT 2
62381: EQUAL
62382: AND
62383: IFFALSE 62443
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62385: LD_INT 22
62387: PUSH
62388: LD_VAR 0 16
62392: PUSH
62393: EMPTY
62394: LIST
62395: LIST
62396: PUSH
62397: LD_INT 35
62399: PUSH
62400: LD_INT 49
62402: PUSH
62403: EMPTY
62404: LIST
62405: LIST
62406: PUSH
62407: LD_INT 91
62409: PUSH
62410: LD_VAR 0 1
62414: PUSH
62415: LD_INT 10
62417: PUSH
62418: EMPTY
62419: LIST
62420: LIST
62421: LIST
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: LIST
62427: PPUSH
62428: CALL_OW 69
62432: NOT
62433: IFFALSE 62443
// weapon := ru_time_lapser ;
62435: LD_ADDR_VAR 0 18
62439: PUSH
62440: LD_INT 49
62442: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62443: LD_VAR 0 12
62447: PUSH
62448: LD_INT 1
62450: PUSH
62451: LD_INT 2
62453: PUSH
62454: EMPTY
62455: LIST
62456: LIST
62457: IN
62458: PUSH
62459: LD_INT 11
62461: PUSH
62462: LD_VAR 0 5
62466: IN
62467: PUSH
62468: LD_INT 30
62470: PUSH
62471: LD_VAR 0 5
62475: IN
62476: OR
62477: AND
62478: PUSH
62479: LD_INT 6
62481: PPUSH
62482: LD_VAR 0 16
62486: PPUSH
62487: CALL_OW 321
62491: PUSH
62492: LD_INT 2
62494: EQUAL
62495: AND
62496: IFFALSE 62661
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62498: LD_INT 22
62500: PUSH
62501: LD_VAR 0 16
62505: PUSH
62506: EMPTY
62507: LIST
62508: LIST
62509: PUSH
62510: LD_INT 2
62512: PUSH
62513: LD_INT 35
62515: PUSH
62516: LD_INT 11
62518: PUSH
62519: EMPTY
62520: LIST
62521: LIST
62522: PUSH
62523: LD_INT 35
62525: PUSH
62526: LD_INT 30
62528: PUSH
62529: EMPTY
62530: LIST
62531: LIST
62532: PUSH
62533: EMPTY
62534: LIST
62535: LIST
62536: LIST
62537: PUSH
62538: LD_INT 91
62540: PUSH
62541: LD_VAR 0 1
62545: PUSH
62546: LD_INT 18
62548: PUSH
62549: EMPTY
62550: LIST
62551: LIST
62552: LIST
62553: PUSH
62554: EMPTY
62555: LIST
62556: LIST
62557: LIST
62558: PPUSH
62559: CALL_OW 69
62563: NOT
62564: PUSH
62565: LD_INT 22
62567: PUSH
62568: LD_VAR 0 16
62572: PUSH
62573: EMPTY
62574: LIST
62575: LIST
62576: PUSH
62577: LD_INT 2
62579: PUSH
62580: LD_INT 30
62582: PUSH
62583: LD_INT 32
62585: PUSH
62586: EMPTY
62587: LIST
62588: LIST
62589: PUSH
62590: LD_INT 30
62592: PUSH
62593: LD_INT 33
62595: PUSH
62596: EMPTY
62597: LIST
62598: LIST
62599: PUSH
62600: EMPTY
62601: LIST
62602: LIST
62603: LIST
62604: PUSH
62605: LD_INT 91
62607: PUSH
62608: LD_VAR 0 1
62612: PUSH
62613: LD_INT 12
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: LIST
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: LIST
62625: PUSH
62626: EMPTY
62627: LIST
62628: PPUSH
62629: CALL_OW 69
62633: PUSH
62634: LD_INT 2
62636: GREATER
62637: AND
62638: IFFALSE 62661
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62640: LD_ADDR_VAR 0 18
62644: PUSH
62645: LD_INT 11
62647: PUSH
62648: LD_INT 30
62650: PUSH
62651: EMPTY
62652: LIST
62653: LIST
62654: PUSH
62655: LD_VAR 0 12
62659: ARRAY
62660: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62661: LD_VAR 0 18
62665: NOT
62666: PUSH
62667: LD_INT 40
62669: PPUSH
62670: LD_VAR 0 16
62674: PPUSH
62675: CALL_OW 321
62679: PUSH
62680: LD_INT 2
62682: EQUAL
62683: AND
62684: PUSH
62685: LD_INT 7
62687: PUSH
62688: LD_VAR 0 5
62692: IN
62693: PUSH
62694: LD_INT 28
62696: PUSH
62697: LD_VAR 0 5
62701: IN
62702: OR
62703: PUSH
62704: LD_INT 45
62706: PUSH
62707: LD_VAR 0 5
62711: IN
62712: OR
62713: AND
62714: IFFALSE 62968
// begin hex := GetHexInfo ( x , y ) ;
62716: LD_ADDR_VAR 0 4
62720: PUSH
62721: LD_VAR 0 10
62725: PPUSH
62726: LD_VAR 0 11
62730: PPUSH
62731: CALL_OW 546
62735: ST_TO_ADDR
// if hex [ 1 ] then
62736: LD_VAR 0 4
62740: PUSH
62741: LD_INT 1
62743: ARRAY
62744: IFFALSE 62748
// exit ;
62746: GO 63151
// height := hex [ 2 ] ;
62748: LD_ADDR_VAR 0 15
62752: PUSH
62753: LD_VAR 0 4
62757: PUSH
62758: LD_INT 2
62760: ARRAY
62761: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62762: LD_ADDR_VAR 0 14
62766: PUSH
62767: LD_INT 0
62769: PUSH
62770: LD_INT 2
62772: PUSH
62773: LD_INT 3
62775: PUSH
62776: LD_INT 5
62778: PUSH
62779: EMPTY
62780: LIST
62781: LIST
62782: LIST
62783: LIST
62784: ST_TO_ADDR
// for i in tmp do
62785: LD_ADDR_VAR 0 8
62789: PUSH
62790: LD_VAR 0 14
62794: PUSH
62795: FOR_IN
62796: IFFALSE 62966
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62798: LD_ADDR_VAR 0 9
62802: PUSH
62803: LD_VAR 0 10
62807: PPUSH
62808: LD_VAR 0 8
62812: PPUSH
62813: LD_INT 5
62815: PPUSH
62816: CALL_OW 272
62820: PUSH
62821: LD_VAR 0 11
62825: PPUSH
62826: LD_VAR 0 8
62830: PPUSH
62831: LD_INT 5
62833: PPUSH
62834: CALL_OW 273
62838: PUSH
62839: EMPTY
62840: LIST
62841: LIST
62842: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62843: LD_VAR 0 9
62847: PUSH
62848: LD_INT 1
62850: ARRAY
62851: PPUSH
62852: LD_VAR 0 9
62856: PUSH
62857: LD_INT 2
62859: ARRAY
62860: PPUSH
62861: CALL_OW 488
62865: IFFALSE 62964
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62867: LD_ADDR_VAR 0 4
62871: PUSH
62872: LD_VAR 0 9
62876: PUSH
62877: LD_INT 1
62879: ARRAY
62880: PPUSH
62881: LD_VAR 0 9
62885: PUSH
62886: LD_INT 2
62888: ARRAY
62889: PPUSH
62890: CALL_OW 546
62894: ST_TO_ADDR
// if hex [ 1 ] then
62895: LD_VAR 0 4
62899: PUSH
62900: LD_INT 1
62902: ARRAY
62903: IFFALSE 62907
// continue ;
62905: GO 62795
// h := hex [ 2 ] ;
62907: LD_ADDR_VAR 0 13
62911: PUSH
62912: LD_VAR 0 4
62916: PUSH
62917: LD_INT 2
62919: ARRAY
62920: ST_TO_ADDR
// if h + 7 < height then
62921: LD_VAR 0 13
62925: PUSH
62926: LD_INT 7
62928: PLUS
62929: PUSH
62930: LD_VAR 0 15
62934: LESS
62935: IFFALSE 62964
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62937: LD_ADDR_VAR 0 18
62941: PUSH
62942: LD_INT 7
62944: PUSH
62945: LD_INT 28
62947: PUSH
62948: LD_INT 45
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: LIST
62955: PUSH
62956: LD_VAR 0 12
62960: ARRAY
62961: ST_TO_ADDR
// break ;
62962: GO 62966
// end ; end ; end ;
62964: GO 62795
62966: POP
62967: POP
// end ; if not weapon then
62968: LD_VAR 0 18
62972: NOT
62973: IFFALSE 63033
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62975: LD_ADDR_VAR 0 5
62979: PUSH
62980: LD_VAR 0 5
62984: PUSH
62985: LD_INT 11
62987: PUSH
62988: LD_INT 30
62990: PUSH
62991: LD_INT 49
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: LIST
62998: DIFF
62999: ST_TO_ADDR
// if not list then
63000: LD_VAR 0 5
63004: NOT
63005: IFFALSE 63009
// exit ;
63007: GO 63151
// weapon := list [ rand ( 1 , list ) ] ;
63009: LD_ADDR_VAR 0 18
63013: PUSH
63014: LD_VAR 0 5
63018: PUSH
63019: LD_INT 1
63021: PPUSH
63022: LD_VAR 0 5
63026: PPUSH
63027: CALL_OW 12
63031: ARRAY
63032: ST_TO_ADDR
// end ; if weapon then
63033: LD_VAR 0 18
63037: IFFALSE 63151
// begin tmp := CostOfWeapon ( weapon ) ;
63039: LD_ADDR_VAR 0 14
63043: PUSH
63044: LD_VAR 0 18
63048: PPUSH
63049: CALL_OW 451
63053: ST_TO_ADDR
// j := GetBase ( tower ) ;
63054: LD_ADDR_VAR 0 9
63058: PUSH
63059: LD_VAR 0 1
63063: PPUSH
63064: CALL_OW 274
63068: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63069: LD_VAR 0 9
63073: PPUSH
63074: LD_INT 1
63076: PPUSH
63077: CALL_OW 275
63081: PUSH
63082: LD_VAR 0 14
63086: PUSH
63087: LD_INT 1
63089: ARRAY
63090: GREATEREQUAL
63091: PUSH
63092: LD_VAR 0 9
63096: PPUSH
63097: LD_INT 2
63099: PPUSH
63100: CALL_OW 275
63104: PUSH
63105: LD_VAR 0 14
63109: PUSH
63110: LD_INT 2
63112: ARRAY
63113: GREATEREQUAL
63114: AND
63115: PUSH
63116: LD_VAR 0 9
63120: PPUSH
63121: LD_INT 3
63123: PPUSH
63124: CALL_OW 275
63128: PUSH
63129: LD_VAR 0 14
63133: PUSH
63134: LD_INT 3
63136: ARRAY
63137: GREATEREQUAL
63138: AND
63139: IFFALSE 63151
// result := weapon ;
63141: LD_ADDR_VAR 0 3
63145: PUSH
63146: LD_VAR 0 18
63150: ST_TO_ADDR
// end ; end ;
63151: LD_VAR 0 3
63155: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63156: LD_INT 0
63158: PPUSH
63159: PPUSH
// result := true ;
63160: LD_ADDR_VAR 0 3
63164: PUSH
63165: LD_INT 1
63167: ST_TO_ADDR
// if array1 = array2 then
63168: LD_VAR 0 1
63172: PUSH
63173: LD_VAR 0 2
63177: EQUAL
63178: IFFALSE 63238
// begin for i = 1 to array1 do
63180: LD_ADDR_VAR 0 4
63184: PUSH
63185: DOUBLE
63186: LD_INT 1
63188: DEC
63189: ST_TO_ADDR
63190: LD_VAR 0 1
63194: PUSH
63195: FOR_TO
63196: IFFALSE 63234
// if array1 [ i ] <> array2 [ i ] then
63198: LD_VAR 0 1
63202: PUSH
63203: LD_VAR 0 4
63207: ARRAY
63208: PUSH
63209: LD_VAR 0 2
63213: PUSH
63214: LD_VAR 0 4
63218: ARRAY
63219: NONEQUAL
63220: IFFALSE 63232
// begin result := false ;
63222: LD_ADDR_VAR 0 3
63226: PUSH
63227: LD_INT 0
63229: ST_TO_ADDR
// break ;
63230: GO 63234
// end ;
63232: GO 63195
63234: POP
63235: POP
// end else
63236: GO 63246
// result := false ;
63238: LD_ADDR_VAR 0 3
63242: PUSH
63243: LD_INT 0
63245: ST_TO_ADDR
// end ;
63246: LD_VAR 0 3
63250: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63251: LD_INT 0
63253: PPUSH
63254: PPUSH
// if not array1 or not array2 then
63255: LD_VAR 0 1
63259: NOT
63260: PUSH
63261: LD_VAR 0 2
63265: NOT
63266: OR
63267: IFFALSE 63271
// exit ;
63269: GO 63335
// result := true ;
63271: LD_ADDR_VAR 0 3
63275: PUSH
63276: LD_INT 1
63278: ST_TO_ADDR
// for i = 1 to array1 do
63279: LD_ADDR_VAR 0 4
63283: PUSH
63284: DOUBLE
63285: LD_INT 1
63287: DEC
63288: ST_TO_ADDR
63289: LD_VAR 0 1
63293: PUSH
63294: FOR_TO
63295: IFFALSE 63333
// if array1 [ i ] <> array2 [ i ] then
63297: LD_VAR 0 1
63301: PUSH
63302: LD_VAR 0 4
63306: ARRAY
63307: PUSH
63308: LD_VAR 0 2
63312: PUSH
63313: LD_VAR 0 4
63317: ARRAY
63318: NONEQUAL
63319: IFFALSE 63331
// begin result := false ;
63321: LD_ADDR_VAR 0 3
63325: PUSH
63326: LD_INT 0
63328: ST_TO_ADDR
// break ;
63329: GO 63333
// end ;
63331: GO 63294
63333: POP
63334: POP
// end ;
63335: LD_VAR 0 3
63339: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63340: LD_INT 0
63342: PPUSH
63343: PPUSH
63344: PPUSH
// pom := GetBase ( fac ) ;
63345: LD_ADDR_VAR 0 5
63349: PUSH
63350: LD_VAR 0 1
63354: PPUSH
63355: CALL_OW 274
63359: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63360: LD_ADDR_VAR 0 4
63364: PUSH
63365: LD_VAR 0 2
63369: PUSH
63370: LD_INT 1
63372: ARRAY
63373: PPUSH
63374: LD_VAR 0 2
63378: PUSH
63379: LD_INT 2
63381: ARRAY
63382: PPUSH
63383: LD_VAR 0 2
63387: PUSH
63388: LD_INT 3
63390: ARRAY
63391: PPUSH
63392: LD_VAR 0 2
63396: PUSH
63397: LD_INT 4
63399: ARRAY
63400: PPUSH
63401: CALL_OW 449
63405: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63406: LD_ADDR_VAR 0 3
63410: PUSH
63411: LD_VAR 0 5
63415: PPUSH
63416: LD_INT 1
63418: PPUSH
63419: CALL_OW 275
63423: PUSH
63424: LD_VAR 0 4
63428: PUSH
63429: LD_INT 1
63431: ARRAY
63432: GREATEREQUAL
63433: PUSH
63434: LD_VAR 0 5
63438: PPUSH
63439: LD_INT 2
63441: PPUSH
63442: CALL_OW 275
63446: PUSH
63447: LD_VAR 0 4
63451: PUSH
63452: LD_INT 2
63454: ARRAY
63455: GREATEREQUAL
63456: AND
63457: PUSH
63458: LD_VAR 0 5
63462: PPUSH
63463: LD_INT 3
63465: PPUSH
63466: CALL_OW 275
63470: PUSH
63471: LD_VAR 0 4
63475: PUSH
63476: LD_INT 3
63478: ARRAY
63479: GREATEREQUAL
63480: AND
63481: ST_TO_ADDR
// end ;
63482: LD_VAR 0 3
63486: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63487: LD_INT 0
63489: PPUSH
63490: PPUSH
63491: PPUSH
63492: PPUSH
// pom := GetBase ( building ) ;
63493: LD_ADDR_VAR 0 3
63497: PUSH
63498: LD_VAR 0 1
63502: PPUSH
63503: CALL_OW 274
63507: ST_TO_ADDR
// if not pom then
63508: LD_VAR 0 3
63512: NOT
63513: IFFALSE 63517
// exit ;
63515: GO 63687
// btype := GetBType ( building ) ;
63517: LD_ADDR_VAR 0 5
63521: PUSH
63522: LD_VAR 0 1
63526: PPUSH
63527: CALL_OW 266
63531: ST_TO_ADDR
// if btype = b_armoury then
63532: LD_VAR 0 5
63536: PUSH
63537: LD_INT 4
63539: EQUAL
63540: IFFALSE 63550
// btype := b_barracks ;
63542: LD_ADDR_VAR 0 5
63546: PUSH
63547: LD_INT 5
63549: ST_TO_ADDR
// if btype = b_depot then
63550: LD_VAR 0 5
63554: PUSH
63555: LD_INT 0
63557: EQUAL
63558: IFFALSE 63568
// btype := b_warehouse ;
63560: LD_ADDR_VAR 0 5
63564: PUSH
63565: LD_INT 1
63567: ST_TO_ADDR
// if btype = b_workshop then
63568: LD_VAR 0 5
63572: PUSH
63573: LD_INT 2
63575: EQUAL
63576: IFFALSE 63586
// btype := b_factory ;
63578: LD_ADDR_VAR 0 5
63582: PUSH
63583: LD_INT 3
63585: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63586: LD_ADDR_VAR 0 4
63590: PUSH
63591: LD_VAR 0 5
63595: PPUSH
63596: LD_VAR 0 1
63600: PPUSH
63601: CALL_OW 248
63605: PPUSH
63606: CALL_OW 450
63610: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63611: LD_ADDR_VAR 0 2
63615: PUSH
63616: LD_VAR 0 3
63620: PPUSH
63621: LD_INT 1
63623: PPUSH
63624: CALL_OW 275
63628: PUSH
63629: LD_VAR 0 4
63633: PUSH
63634: LD_INT 1
63636: ARRAY
63637: GREATEREQUAL
63638: PUSH
63639: LD_VAR 0 3
63643: PPUSH
63644: LD_INT 2
63646: PPUSH
63647: CALL_OW 275
63651: PUSH
63652: LD_VAR 0 4
63656: PUSH
63657: LD_INT 2
63659: ARRAY
63660: GREATEREQUAL
63661: AND
63662: PUSH
63663: LD_VAR 0 3
63667: PPUSH
63668: LD_INT 3
63670: PPUSH
63671: CALL_OW 275
63675: PUSH
63676: LD_VAR 0 4
63680: PUSH
63681: LD_INT 3
63683: ARRAY
63684: GREATEREQUAL
63685: AND
63686: ST_TO_ADDR
// end ;
63687: LD_VAR 0 2
63691: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63692: LD_INT 0
63694: PPUSH
63695: PPUSH
63696: PPUSH
// pom := GetBase ( building ) ;
63697: LD_ADDR_VAR 0 4
63701: PUSH
63702: LD_VAR 0 1
63706: PPUSH
63707: CALL_OW 274
63711: ST_TO_ADDR
// if not pom then
63712: LD_VAR 0 4
63716: NOT
63717: IFFALSE 63721
// exit ;
63719: GO 63822
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63721: LD_ADDR_VAR 0 5
63725: PUSH
63726: LD_VAR 0 2
63730: PPUSH
63731: LD_VAR 0 1
63735: PPUSH
63736: CALL_OW 248
63740: PPUSH
63741: CALL_OW 450
63745: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63746: LD_ADDR_VAR 0 3
63750: PUSH
63751: LD_VAR 0 4
63755: PPUSH
63756: LD_INT 1
63758: PPUSH
63759: CALL_OW 275
63763: PUSH
63764: LD_VAR 0 5
63768: PUSH
63769: LD_INT 1
63771: ARRAY
63772: GREATEREQUAL
63773: PUSH
63774: LD_VAR 0 4
63778: PPUSH
63779: LD_INT 2
63781: PPUSH
63782: CALL_OW 275
63786: PUSH
63787: LD_VAR 0 5
63791: PUSH
63792: LD_INT 2
63794: ARRAY
63795: GREATEREQUAL
63796: AND
63797: PUSH
63798: LD_VAR 0 4
63802: PPUSH
63803: LD_INT 3
63805: PPUSH
63806: CALL_OW 275
63810: PUSH
63811: LD_VAR 0 5
63815: PUSH
63816: LD_INT 3
63818: ARRAY
63819: GREATEREQUAL
63820: AND
63821: ST_TO_ADDR
// end ;
63822: LD_VAR 0 3
63826: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63827: LD_INT 0
63829: PPUSH
63830: PPUSH
63831: PPUSH
63832: PPUSH
63833: PPUSH
63834: PPUSH
63835: PPUSH
63836: PPUSH
63837: PPUSH
63838: PPUSH
63839: PPUSH
// result := false ;
63840: LD_ADDR_VAR 0 8
63844: PUSH
63845: LD_INT 0
63847: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63848: LD_VAR 0 5
63852: NOT
63853: PUSH
63854: LD_VAR 0 1
63858: NOT
63859: OR
63860: PUSH
63861: LD_VAR 0 2
63865: NOT
63866: OR
63867: PUSH
63868: LD_VAR 0 3
63872: NOT
63873: OR
63874: IFFALSE 63878
// exit ;
63876: GO 64692
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63878: LD_ADDR_VAR 0 14
63882: PUSH
63883: LD_VAR 0 1
63887: PPUSH
63888: LD_VAR 0 2
63892: PPUSH
63893: LD_VAR 0 3
63897: PPUSH
63898: LD_VAR 0 4
63902: PPUSH
63903: LD_VAR 0 5
63907: PUSH
63908: LD_INT 1
63910: ARRAY
63911: PPUSH
63912: CALL_OW 248
63916: PPUSH
63917: LD_INT 0
63919: PPUSH
63920: CALL 65929 0 6
63924: ST_TO_ADDR
// if not hexes then
63925: LD_VAR 0 14
63929: NOT
63930: IFFALSE 63934
// exit ;
63932: GO 64692
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63934: LD_ADDR_VAR 0 17
63938: PUSH
63939: LD_VAR 0 5
63943: PPUSH
63944: LD_INT 22
63946: PUSH
63947: LD_VAR 0 13
63951: PPUSH
63952: CALL_OW 255
63956: PUSH
63957: EMPTY
63958: LIST
63959: LIST
63960: PUSH
63961: LD_INT 2
63963: PUSH
63964: LD_INT 30
63966: PUSH
63967: LD_INT 0
63969: PUSH
63970: EMPTY
63971: LIST
63972: LIST
63973: PUSH
63974: LD_INT 30
63976: PUSH
63977: LD_INT 1
63979: PUSH
63980: EMPTY
63981: LIST
63982: LIST
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: LIST
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PPUSH
63993: CALL_OW 72
63997: ST_TO_ADDR
// for i = 1 to hexes do
63998: LD_ADDR_VAR 0 9
64002: PUSH
64003: DOUBLE
64004: LD_INT 1
64006: DEC
64007: ST_TO_ADDR
64008: LD_VAR 0 14
64012: PUSH
64013: FOR_TO
64014: IFFALSE 64690
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64016: LD_ADDR_VAR 0 13
64020: PUSH
64021: LD_VAR 0 14
64025: PUSH
64026: LD_VAR 0 9
64030: ARRAY
64031: PUSH
64032: LD_INT 1
64034: ARRAY
64035: PPUSH
64036: LD_VAR 0 14
64040: PUSH
64041: LD_VAR 0 9
64045: ARRAY
64046: PUSH
64047: LD_INT 2
64049: ARRAY
64050: PPUSH
64051: CALL_OW 428
64055: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64056: LD_VAR 0 14
64060: PUSH
64061: LD_VAR 0 9
64065: ARRAY
64066: PUSH
64067: LD_INT 1
64069: ARRAY
64070: PPUSH
64071: LD_VAR 0 14
64075: PUSH
64076: LD_VAR 0 9
64080: ARRAY
64081: PUSH
64082: LD_INT 2
64084: ARRAY
64085: PPUSH
64086: CALL_OW 351
64090: PUSH
64091: LD_VAR 0 14
64095: PUSH
64096: LD_VAR 0 9
64100: ARRAY
64101: PUSH
64102: LD_INT 1
64104: ARRAY
64105: PPUSH
64106: LD_VAR 0 14
64110: PUSH
64111: LD_VAR 0 9
64115: ARRAY
64116: PUSH
64117: LD_INT 2
64119: ARRAY
64120: PPUSH
64121: CALL_OW 488
64125: NOT
64126: OR
64127: PUSH
64128: LD_VAR 0 13
64132: PPUSH
64133: CALL_OW 247
64137: PUSH
64138: LD_INT 3
64140: EQUAL
64141: OR
64142: IFFALSE 64148
// exit ;
64144: POP
64145: POP
64146: GO 64692
// if not tmp then
64148: LD_VAR 0 13
64152: NOT
64153: IFFALSE 64157
// continue ;
64155: GO 64013
// result := true ;
64157: LD_ADDR_VAR 0 8
64161: PUSH
64162: LD_INT 1
64164: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64165: LD_VAR 0 6
64169: PUSH
64170: LD_VAR 0 13
64174: PPUSH
64175: CALL_OW 247
64179: PUSH
64180: LD_INT 2
64182: EQUAL
64183: AND
64184: PUSH
64185: LD_VAR 0 13
64189: PPUSH
64190: CALL_OW 263
64194: PUSH
64195: LD_INT 1
64197: EQUAL
64198: AND
64199: IFFALSE 64363
// begin if IsDrivenBy ( tmp ) then
64201: LD_VAR 0 13
64205: PPUSH
64206: CALL_OW 311
64210: IFFALSE 64214
// continue ;
64212: GO 64013
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64214: LD_VAR 0 6
64218: PPUSH
64219: LD_INT 3
64221: PUSH
64222: LD_INT 60
64224: PUSH
64225: EMPTY
64226: LIST
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: PUSH
64232: LD_INT 3
64234: PUSH
64235: LD_INT 55
64237: PUSH
64238: EMPTY
64239: LIST
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PUSH
64245: EMPTY
64246: LIST
64247: LIST
64248: PPUSH
64249: CALL_OW 72
64253: IFFALSE 64361
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64255: LD_ADDR_VAR 0 18
64259: PUSH
64260: LD_VAR 0 6
64264: PPUSH
64265: LD_INT 3
64267: PUSH
64268: LD_INT 60
64270: PUSH
64271: EMPTY
64272: LIST
64273: PUSH
64274: EMPTY
64275: LIST
64276: LIST
64277: PUSH
64278: LD_INT 3
64280: PUSH
64281: LD_INT 55
64283: PUSH
64284: EMPTY
64285: LIST
64286: PUSH
64287: EMPTY
64288: LIST
64289: LIST
64290: PUSH
64291: EMPTY
64292: LIST
64293: LIST
64294: PPUSH
64295: CALL_OW 72
64299: PUSH
64300: LD_INT 1
64302: ARRAY
64303: ST_TO_ADDR
// if IsInUnit ( driver ) then
64304: LD_VAR 0 18
64308: PPUSH
64309: CALL_OW 310
64313: IFFALSE 64324
// ComExit ( driver ) ;
64315: LD_VAR 0 18
64319: PPUSH
64320: CALL 89113 0 1
// AddComEnterUnit ( driver , tmp ) ;
64324: LD_VAR 0 18
64328: PPUSH
64329: LD_VAR 0 13
64333: PPUSH
64334: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64338: LD_VAR 0 18
64342: PPUSH
64343: LD_VAR 0 7
64347: PPUSH
64348: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64352: LD_VAR 0 18
64356: PPUSH
64357: CALL_OW 181
// end ; continue ;
64361: GO 64013
// end ; if not cleaners or not tmp in cleaners then
64363: LD_VAR 0 6
64367: NOT
64368: PUSH
64369: LD_VAR 0 13
64373: PUSH
64374: LD_VAR 0 6
64378: IN
64379: NOT
64380: OR
64381: IFFALSE 64688
// begin if dep then
64383: LD_VAR 0 17
64387: IFFALSE 64523
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64389: LD_ADDR_VAR 0 16
64393: PUSH
64394: LD_VAR 0 17
64398: PUSH
64399: LD_INT 1
64401: ARRAY
64402: PPUSH
64403: CALL_OW 250
64407: PPUSH
64408: LD_VAR 0 17
64412: PUSH
64413: LD_INT 1
64415: ARRAY
64416: PPUSH
64417: CALL_OW 254
64421: PPUSH
64422: LD_INT 5
64424: PPUSH
64425: CALL_OW 272
64429: PUSH
64430: LD_VAR 0 17
64434: PUSH
64435: LD_INT 1
64437: ARRAY
64438: PPUSH
64439: CALL_OW 251
64443: PPUSH
64444: LD_VAR 0 17
64448: PUSH
64449: LD_INT 1
64451: ARRAY
64452: PPUSH
64453: CALL_OW 254
64457: PPUSH
64458: LD_INT 5
64460: PPUSH
64461: CALL_OW 273
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64470: LD_VAR 0 16
64474: PUSH
64475: LD_INT 1
64477: ARRAY
64478: PPUSH
64479: LD_VAR 0 16
64483: PUSH
64484: LD_INT 2
64486: ARRAY
64487: PPUSH
64488: CALL_OW 488
64492: IFFALSE 64523
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64494: LD_VAR 0 13
64498: PPUSH
64499: LD_VAR 0 16
64503: PUSH
64504: LD_INT 1
64506: ARRAY
64507: PPUSH
64508: LD_VAR 0 16
64512: PUSH
64513: LD_INT 2
64515: ARRAY
64516: PPUSH
64517: CALL_OW 111
// continue ;
64521: GO 64013
// end ; end ; r := GetDir ( tmp ) ;
64523: LD_ADDR_VAR 0 15
64527: PUSH
64528: LD_VAR 0 13
64532: PPUSH
64533: CALL_OW 254
64537: ST_TO_ADDR
// if r = 5 then
64538: LD_VAR 0 15
64542: PUSH
64543: LD_INT 5
64545: EQUAL
64546: IFFALSE 64556
// r := 0 ;
64548: LD_ADDR_VAR 0 15
64552: PUSH
64553: LD_INT 0
64555: ST_TO_ADDR
// for j = r to 5 do
64556: LD_ADDR_VAR 0 10
64560: PUSH
64561: DOUBLE
64562: LD_VAR 0 15
64566: DEC
64567: ST_TO_ADDR
64568: LD_INT 5
64570: PUSH
64571: FOR_TO
64572: IFFALSE 64686
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64574: LD_ADDR_VAR 0 11
64578: PUSH
64579: LD_VAR 0 13
64583: PPUSH
64584: CALL_OW 250
64588: PPUSH
64589: LD_VAR 0 10
64593: PPUSH
64594: LD_INT 2
64596: PPUSH
64597: CALL_OW 272
64601: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64602: LD_ADDR_VAR 0 12
64606: PUSH
64607: LD_VAR 0 13
64611: PPUSH
64612: CALL_OW 251
64616: PPUSH
64617: LD_VAR 0 10
64621: PPUSH
64622: LD_INT 2
64624: PPUSH
64625: CALL_OW 273
64629: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64630: LD_VAR 0 11
64634: PPUSH
64635: LD_VAR 0 12
64639: PPUSH
64640: CALL_OW 488
64644: PUSH
64645: LD_VAR 0 11
64649: PPUSH
64650: LD_VAR 0 12
64654: PPUSH
64655: CALL_OW 428
64659: NOT
64660: AND
64661: IFFALSE 64684
// begin ComMoveXY ( tmp , _x , _y ) ;
64663: LD_VAR 0 13
64667: PPUSH
64668: LD_VAR 0 11
64672: PPUSH
64673: LD_VAR 0 12
64677: PPUSH
64678: CALL_OW 111
// break ;
64682: GO 64686
// end ; end ;
64684: GO 64571
64686: POP
64687: POP
// end ; end ;
64688: GO 64013
64690: POP
64691: POP
// end ;
64692: LD_VAR 0 8
64696: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64697: LD_INT 0
64699: PPUSH
// result := true ;
64700: LD_ADDR_VAR 0 3
64704: PUSH
64705: LD_INT 1
64707: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64708: LD_VAR 0 2
64712: PUSH
64713: LD_INT 24
64715: DOUBLE
64716: EQUAL
64717: IFTRUE 64727
64719: LD_INT 33
64721: DOUBLE
64722: EQUAL
64723: IFTRUE 64727
64725: GO 64752
64727: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64728: LD_ADDR_VAR 0 3
64732: PUSH
64733: LD_INT 32
64735: PPUSH
64736: LD_VAR 0 1
64740: PPUSH
64741: CALL_OW 321
64745: PUSH
64746: LD_INT 2
64748: EQUAL
64749: ST_TO_ADDR
64750: GO 65072
64752: LD_INT 20
64754: DOUBLE
64755: EQUAL
64756: IFTRUE 64760
64758: GO 64785
64760: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64761: LD_ADDR_VAR 0 3
64765: PUSH
64766: LD_INT 6
64768: PPUSH
64769: LD_VAR 0 1
64773: PPUSH
64774: CALL_OW 321
64778: PUSH
64779: LD_INT 2
64781: EQUAL
64782: ST_TO_ADDR
64783: GO 65072
64785: LD_INT 22
64787: DOUBLE
64788: EQUAL
64789: IFTRUE 64799
64791: LD_INT 36
64793: DOUBLE
64794: EQUAL
64795: IFTRUE 64799
64797: GO 64824
64799: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64800: LD_ADDR_VAR 0 3
64804: PUSH
64805: LD_INT 15
64807: PPUSH
64808: LD_VAR 0 1
64812: PPUSH
64813: CALL_OW 321
64817: PUSH
64818: LD_INT 2
64820: EQUAL
64821: ST_TO_ADDR
64822: GO 65072
64824: LD_INT 30
64826: DOUBLE
64827: EQUAL
64828: IFTRUE 64832
64830: GO 64857
64832: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64833: LD_ADDR_VAR 0 3
64837: PUSH
64838: LD_INT 20
64840: PPUSH
64841: LD_VAR 0 1
64845: PPUSH
64846: CALL_OW 321
64850: PUSH
64851: LD_INT 2
64853: EQUAL
64854: ST_TO_ADDR
64855: GO 65072
64857: LD_INT 28
64859: DOUBLE
64860: EQUAL
64861: IFTRUE 64871
64863: LD_INT 21
64865: DOUBLE
64866: EQUAL
64867: IFTRUE 64871
64869: GO 64896
64871: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64872: LD_ADDR_VAR 0 3
64876: PUSH
64877: LD_INT 21
64879: PPUSH
64880: LD_VAR 0 1
64884: PPUSH
64885: CALL_OW 321
64889: PUSH
64890: LD_INT 2
64892: EQUAL
64893: ST_TO_ADDR
64894: GO 65072
64896: LD_INT 16
64898: DOUBLE
64899: EQUAL
64900: IFTRUE 64904
64902: GO 64931
64904: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64905: LD_ADDR_VAR 0 3
64909: PUSH
64910: LD_EXP 86
64914: PPUSH
64915: LD_VAR 0 1
64919: PPUSH
64920: CALL_OW 321
64924: PUSH
64925: LD_INT 2
64927: EQUAL
64928: ST_TO_ADDR
64929: GO 65072
64931: LD_INT 19
64933: DOUBLE
64934: EQUAL
64935: IFTRUE 64945
64937: LD_INT 23
64939: DOUBLE
64940: EQUAL
64941: IFTRUE 64945
64943: GO 64972
64945: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64946: LD_ADDR_VAR 0 3
64950: PUSH
64951: LD_EXP 85
64955: PPUSH
64956: LD_VAR 0 1
64960: PPUSH
64961: CALL_OW 321
64965: PUSH
64966: LD_INT 2
64968: EQUAL
64969: ST_TO_ADDR
64970: GO 65072
64972: LD_INT 17
64974: DOUBLE
64975: EQUAL
64976: IFTRUE 64980
64978: GO 65005
64980: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
64981: LD_ADDR_VAR 0 3
64985: PUSH
64986: LD_INT 39
64988: PPUSH
64989: LD_VAR 0 1
64993: PPUSH
64994: CALL_OW 321
64998: PUSH
64999: LD_INT 2
65001: EQUAL
65002: ST_TO_ADDR
65003: GO 65072
65005: LD_INT 18
65007: DOUBLE
65008: EQUAL
65009: IFTRUE 65013
65011: GO 65038
65013: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65014: LD_ADDR_VAR 0 3
65018: PUSH
65019: LD_INT 40
65021: PPUSH
65022: LD_VAR 0 1
65026: PPUSH
65027: CALL_OW 321
65031: PUSH
65032: LD_INT 2
65034: EQUAL
65035: ST_TO_ADDR
65036: GO 65072
65038: LD_INT 27
65040: DOUBLE
65041: EQUAL
65042: IFTRUE 65046
65044: GO 65071
65046: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65047: LD_ADDR_VAR 0 3
65051: PUSH
65052: LD_INT 35
65054: PPUSH
65055: LD_VAR 0 1
65059: PPUSH
65060: CALL_OW 321
65064: PUSH
65065: LD_INT 2
65067: EQUAL
65068: ST_TO_ADDR
65069: GO 65072
65071: POP
// end ;
65072: LD_VAR 0 3
65076: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65077: LD_INT 0
65079: PPUSH
65080: PPUSH
65081: PPUSH
65082: PPUSH
65083: PPUSH
65084: PPUSH
65085: PPUSH
65086: PPUSH
65087: PPUSH
65088: PPUSH
65089: PPUSH
// result := false ;
65090: LD_ADDR_VAR 0 6
65094: PUSH
65095: LD_INT 0
65097: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65098: LD_VAR 0 1
65102: NOT
65103: PUSH
65104: LD_VAR 0 1
65108: PPUSH
65109: CALL_OW 266
65113: PUSH
65114: LD_INT 0
65116: PUSH
65117: LD_INT 1
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: IN
65124: NOT
65125: OR
65126: PUSH
65127: LD_VAR 0 2
65131: NOT
65132: OR
65133: PUSH
65134: LD_VAR 0 5
65138: PUSH
65139: LD_INT 0
65141: PUSH
65142: LD_INT 1
65144: PUSH
65145: LD_INT 2
65147: PUSH
65148: LD_INT 3
65150: PUSH
65151: LD_INT 4
65153: PUSH
65154: LD_INT 5
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: IN
65165: NOT
65166: OR
65167: PUSH
65168: LD_VAR 0 3
65172: PPUSH
65173: LD_VAR 0 4
65177: PPUSH
65178: CALL_OW 488
65182: NOT
65183: OR
65184: IFFALSE 65188
// exit ;
65186: GO 65924
// side := GetSide ( depot ) ;
65188: LD_ADDR_VAR 0 9
65192: PUSH
65193: LD_VAR 0 1
65197: PPUSH
65198: CALL_OW 255
65202: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65203: LD_VAR 0 9
65207: PPUSH
65208: LD_VAR 0 2
65212: PPUSH
65213: CALL 64697 0 2
65217: NOT
65218: IFFALSE 65222
// exit ;
65220: GO 65924
// pom := GetBase ( depot ) ;
65222: LD_ADDR_VAR 0 10
65226: PUSH
65227: LD_VAR 0 1
65231: PPUSH
65232: CALL_OW 274
65236: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65237: LD_ADDR_VAR 0 11
65241: PUSH
65242: LD_VAR 0 2
65246: PPUSH
65247: LD_VAR 0 1
65251: PPUSH
65252: CALL_OW 248
65256: PPUSH
65257: CALL_OW 450
65261: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65262: LD_VAR 0 10
65266: PPUSH
65267: LD_INT 1
65269: PPUSH
65270: CALL_OW 275
65274: PUSH
65275: LD_VAR 0 11
65279: PUSH
65280: LD_INT 1
65282: ARRAY
65283: GREATEREQUAL
65284: PUSH
65285: LD_VAR 0 10
65289: PPUSH
65290: LD_INT 2
65292: PPUSH
65293: CALL_OW 275
65297: PUSH
65298: LD_VAR 0 11
65302: PUSH
65303: LD_INT 2
65305: ARRAY
65306: GREATEREQUAL
65307: AND
65308: PUSH
65309: LD_VAR 0 10
65313: PPUSH
65314: LD_INT 3
65316: PPUSH
65317: CALL_OW 275
65321: PUSH
65322: LD_VAR 0 11
65326: PUSH
65327: LD_INT 3
65329: ARRAY
65330: GREATEREQUAL
65331: AND
65332: NOT
65333: IFFALSE 65337
// exit ;
65335: GO 65924
// if GetBType ( depot ) = b_depot then
65337: LD_VAR 0 1
65341: PPUSH
65342: CALL_OW 266
65346: PUSH
65347: LD_INT 0
65349: EQUAL
65350: IFFALSE 65362
// dist := 28 else
65352: LD_ADDR_VAR 0 14
65356: PUSH
65357: LD_INT 28
65359: ST_TO_ADDR
65360: GO 65370
// dist := 36 ;
65362: LD_ADDR_VAR 0 14
65366: PUSH
65367: LD_INT 36
65369: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65370: LD_VAR 0 1
65374: PPUSH
65375: LD_VAR 0 3
65379: PPUSH
65380: LD_VAR 0 4
65384: PPUSH
65385: CALL_OW 297
65389: PUSH
65390: LD_VAR 0 14
65394: GREATER
65395: IFFALSE 65399
// exit ;
65397: GO 65924
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65399: LD_ADDR_VAR 0 12
65403: PUSH
65404: LD_VAR 0 2
65408: PPUSH
65409: LD_VAR 0 3
65413: PPUSH
65414: LD_VAR 0 4
65418: PPUSH
65419: LD_VAR 0 5
65423: PPUSH
65424: LD_VAR 0 1
65428: PPUSH
65429: CALL_OW 248
65433: PPUSH
65434: LD_INT 0
65436: PPUSH
65437: CALL 65929 0 6
65441: ST_TO_ADDR
// if not hexes then
65442: LD_VAR 0 12
65446: NOT
65447: IFFALSE 65451
// exit ;
65449: GO 65924
// hex := GetHexInfo ( x , y ) ;
65451: LD_ADDR_VAR 0 15
65455: PUSH
65456: LD_VAR 0 3
65460: PPUSH
65461: LD_VAR 0 4
65465: PPUSH
65466: CALL_OW 546
65470: ST_TO_ADDR
// if hex [ 1 ] then
65471: LD_VAR 0 15
65475: PUSH
65476: LD_INT 1
65478: ARRAY
65479: IFFALSE 65483
// exit ;
65481: GO 65924
// height := hex [ 2 ] ;
65483: LD_ADDR_VAR 0 13
65487: PUSH
65488: LD_VAR 0 15
65492: PUSH
65493: LD_INT 2
65495: ARRAY
65496: ST_TO_ADDR
// for i = 1 to hexes do
65497: LD_ADDR_VAR 0 7
65501: PUSH
65502: DOUBLE
65503: LD_INT 1
65505: DEC
65506: ST_TO_ADDR
65507: LD_VAR 0 12
65511: PUSH
65512: FOR_TO
65513: IFFALSE 65843
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65515: LD_VAR 0 12
65519: PUSH
65520: LD_VAR 0 7
65524: ARRAY
65525: PUSH
65526: LD_INT 1
65528: ARRAY
65529: PPUSH
65530: LD_VAR 0 12
65534: PUSH
65535: LD_VAR 0 7
65539: ARRAY
65540: PUSH
65541: LD_INT 2
65543: ARRAY
65544: PPUSH
65545: CALL_OW 488
65549: NOT
65550: PUSH
65551: LD_VAR 0 12
65555: PUSH
65556: LD_VAR 0 7
65560: ARRAY
65561: PUSH
65562: LD_INT 1
65564: ARRAY
65565: PPUSH
65566: LD_VAR 0 12
65570: PUSH
65571: LD_VAR 0 7
65575: ARRAY
65576: PUSH
65577: LD_INT 2
65579: ARRAY
65580: PPUSH
65581: CALL_OW 428
65585: PUSH
65586: LD_INT 0
65588: GREATER
65589: OR
65590: PUSH
65591: LD_VAR 0 12
65595: PUSH
65596: LD_VAR 0 7
65600: ARRAY
65601: PUSH
65602: LD_INT 1
65604: ARRAY
65605: PPUSH
65606: LD_VAR 0 12
65610: PUSH
65611: LD_VAR 0 7
65615: ARRAY
65616: PUSH
65617: LD_INT 2
65619: ARRAY
65620: PPUSH
65621: CALL_OW 351
65625: OR
65626: IFFALSE 65632
// exit ;
65628: POP
65629: POP
65630: GO 65924
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65632: LD_ADDR_VAR 0 8
65636: PUSH
65637: LD_VAR 0 12
65641: PUSH
65642: LD_VAR 0 7
65646: ARRAY
65647: PUSH
65648: LD_INT 1
65650: ARRAY
65651: PPUSH
65652: LD_VAR 0 12
65656: PUSH
65657: LD_VAR 0 7
65661: ARRAY
65662: PUSH
65663: LD_INT 2
65665: ARRAY
65666: PPUSH
65667: CALL_OW 546
65671: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65672: LD_VAR 0 8
65676: PUSH
65677: LD_INT 1
65679: ARRAY
65680: PUSH
65681: LD_VAR 0 8
65685: PUSH
65686: LD_INT 2
65688: ARRAY
65689: PUSH
65690: LD_VAR 0 13
65694: PUSH
65695: LD_INT 2
65697: PLUS
65698: GREATER
65699: OR
65700: PUSH
65701: LD_VAR 0 8
65705: PUSH
65706: LD_INT 2
65708: ARRAY
65709: PUSH
65710: LD_VAR 0 13
65714: PUSH
65715: LD_INT 2
65717: MINUS
65718: LESS
65719: OR
65720: PUSH
65721: LD_VAR 0 8
65725: PUSH
65726: LD_INT 3
65728: ARRAY
65729: PUSH
65730: LD_INT 0
65732: PUSH
65733: LD_INT 8
65735: PUSH
65736: LD_INT 9
65738: PUSH
65739: LD_INT 10
65741: PUSH
65742: LD_INT 11
65744: PUSH
65745: LD_INT 12
65747: PUSH
65748: LD_INT 13
65750: PUSH
65751: LD_INT 16
65753: PUSH
65754: LD_INT 17
65756: PUSH
65757: LD_INT 18
65759: PUSH
65760: LD_INT 19
65762: PUSH
65763: LD_INT 20
65765: PUSH
65766: LD_INT 21
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: LIST
65773: LIST
65774: LIST
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: LIST
65780: LIST
65781: LIST
65782: LIST
65783: IN
65784: NOT
65785: OR
65786: PUSH
65787: LD_VAR 0 8
65791: PUSH
65792: LD_INT 5
65794: ARRAY
65795: NOT
65796: OR
65797: PUSH
65798: LD_VAR 0 8
65802: PUSH
65803: LD_INT 6
65805: ARRAY
65806: PUSH
65807: LD_INT 1
65809: PUSH
65810: LD_INT 2
65812: PUSH
65813: LD_INT 7
65815: PUSH
65816: LD_INT 9
65818: PUSH
65819: LD_INT 10
65821: PUSH
65822: LD_INT 11
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: IN
65833: NOT
65834: OR
65835: IFFALSE 65841
// exit ;
65837: POP
65838: POP
65839: GO 65924
// end ;
65841: GO 65512
65843: POP
65844: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65845: LD_VAR 0 9
65849: PPUSH
65850: LD_VAR 0 3
65854: PPUSH
65855: LD_VAR 0 4
65859: PPUSH
65860: LD_INT 20
65862: PPUSH
65863: CALL 57870 0 4
65867: PUSH
65868: LD_INT 4
65870: ARRAY
65871: IFFALSE 65875
// exit ;
65873: GO 65924
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65875: LD_VAR 0 2
65879: PUSH
65880: LD_INT 29
65882: PUSH
65883: LD_INT 30
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: IN
65890: PUSH
65891: LD_VAR 0 3
65895: PPUSH
65896: LD_VAR 0 4
65900: PPUSH
65901: LD_VAR 0 9
65905: PPUSH
65906: CALL_OW 440
65910: NOT
65911: AND
65912: IFFALSE 65916
// exit ;
65914: GO 65924
// result := true ;
65916: LD_ADDR_VAR 0 6
65920: PUSH
65921: LD_INT 1
65923: ST_TO_ADDR
// end ;
65924: LD_VAR 0 6
65928: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65929: LD_INT 0
65931: PPUSH
65932: PPUSH
65933: PPUSH
65934: PPUSH
65935: PPUSH
65936: PPUSH
65937: PPUSH
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
65942: PPUSH
65943: PPUSH
65944: PPUSH
65945: PPUSH
65946: PPUSH
65947: PPUSH
65948: PPUSH
65949: PPUSH
65950: PPUSH
65951: PPUSH
65952: PPUSH
65953: PPUSH
65954: PPUSH
65955: PPUSH
65956: PPUSH
65957: PPUSH
65958: PPUSH
65959: PPUSH
65960: PPUSH
65961: PPUSH
65962: PPUSH
65963: PPUSH
65964: PPUSH
65965: PPUSH
65966: PPUSH
65967: PPUSH
65968: PPUSH
65969: PPUSH
65970: PPUSH
65971: PPUSH
65972: PPUSH
65973: PPUSH
65974: PPUSH
65975: PPUSH
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
65980: PPUSH
65981: PPUSH
65982: PPUSH
65983: PPUSH
65984: PPUSH
65985: PPUSH
65986: PPUSH
65987: PPUSH
65988: PPUSH
// result = [ ] ;
65989: LD_ADDR_VAR 0 7
65993: PUSH
65994: EMPTY
65995: ST_TO_ADDR
// temp_list = [ ] ;
65996: LD_ADDR_VAR 0 9
66000: PUSH
66001: EMPTY
66002: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66003: LD_VAR 0 4
66007: PUSH
66008: LD_INT 0
66010: PUSH
66011: LD_INT 1
66013: PUSH
66014: LD_INT 2
66016: PUSH
66017: LD_INT 3
66019: PUSH
66020: LD_INT 4
66022: PUSH
66023: LD_INT 5
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: LIST
66030: LIST
66031: LIST
66032: LIST
66033: IN
66034: NOT
66035: PUSH
66036: LD_VAR 0 1
66040: PUSH
66041: LD_INT 0
66043: PUSH
66044: LD_INT 1
66046: PUSH
66047: EMPTY
66048: LIST
66049: LIST
66050: IN
66051: PUSH
66052: LD_VAR 0 5
66056: PUSH
66057: LD_INT 1
66059: PUSH
66060: LD_INT 2
66062: PUSH
66063: LD_INT 3
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: LIST
66070: IN
66071: NOT
66072: AND
66073: OR
66074: IFFALSE 66078
// exit ;
66076: GO 84469
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66078: LD_VAR 0 1
66082: PUSH
66083: LD_INT 6
66085: PUSH
66086: LD_INT 7
66088: PUSH
66089: LD_INT 8
66091: PUSH
66092: LD_INT 13
66094: PUSH
66095: LD_INT 12
66097: PUSH
66098: LD_INT 15
66100: PUSH
66101: LD_INT 11
66103: PUSH
66104: LD_INT 14
66106: PUSH
66107: LD_INT 10
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: LIST
66114: LIST
66115: LIST
66116: LIST
66117: LIST
66118: LIST
66119: LIST
66120: IN
66121: IFFALSE 66131
// btype = b_lab ;
66123: LD_ADDR_VAR 0 1
66127: PUSH
66128: LD_INT 6
66130: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66131: LD_VAR 0 6
66135: PUSH
66136: LD_INT 0
66138: PUSH
66139: LD_INT 1
66141: PUSH
66142: LD_INT 2
66144: PUSH
66145: EMPTY
66146: LIST
66147: LIST
66148: LIST
66149: IN
66150: NOT
66151: PUSH
66152: LD_VAR 0 1
66156: PUSH
66157: LD_INT 0
66159: PUSH
66160: LD_INT 1
66162: PUSH
66163: LD_INT 2
66165: PUSH
66166: LD_INT 3
66168: PUSH
66169: LD_INT 6
66171: PUSH
66172: LD_INT 36
66174: PUSH
66175: LD_INT 4
66177: PUSH
66178: LD_INT 5
66180: PUSH
66181: LD_INT 31
66183: PUSH
66184: LD_INT 32
66186: PUSH
66187: LD_INT 33
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: IN
66203: NOT
66204: PUSH
66205: LD_VAR 0 6
66209: PUSH
66210: LD_INT 1
66212: EQUAL
66213: AND
66214: OR
66215: PUSH
66216: LD_VAR 0 1
66220: PUSH
66221: LD_INT 2
66223: PUSH
66224: LD_INT 3
66226: PUSH
66227: EMPTY
66228: LIST
66229: LIST
66230: IN
66231: NOT
66232: PUSH
66233: LD_VAR 0 6
66237: PUSH
66238: LD_INT 2
66240: EQUAL
66241: AND
66242: OR
66243: IFFALSE 66253
// mode = 0 ;
66245: LD_ADDR_VAR 0 6
66249: PUSH
66250: LD_INT 0
66252: ST_TO_ADDR
// case mode of 0 :
66253: LD_VAR 0 6
66257: PUSH
66258: LD_INT 0
66260: DOUBLE
66261: EQUAL
66262: IFTRUE 66266
66264: GO 77719
66266: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66267: LD_ADDR_VAR 0 11
66271: PUSH
66272: LD_INT 0
66274: PUSH
66275: LD_INT 0
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 0
66284: PUSH
66285: LD_INT 1
66287: NEG
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 1
66295: PUSH
66296: LD_INT 0
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PUSH
66303: LD_INT 1
66305: PUSH
66306: LD_INT 1
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 0
66315: PUSH
66316: LD_INT 1
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 1
66325: NEG
66326: PUSH
66327: LD_INT 0
66329: PUSH
66330: EMPTY
66331: LIST
66332: LIST
66333: PUSH
66334: LD_INT 1
66336: NEG
66337: PUSH
66338: LD_INT 1
66340: NEG
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 1
66348: NEG
66349: PUSH
66350: LD_INT 2
66352: NEG
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: LD_INT 0
66360: PUSH
66361: LD_INT 2
66363: NEG
66364: PUSH
66365: EMPTY
66366: LIST
66367: LIST
66368: PUSH
66369: LD_INT 1
66371: PUSH
66372: LD_INT 1
66374: NEG
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: LD_INT 1
66382: PUSH
66383: LD_INT 2
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: LD_INT 0
66392: PUSH
66393: LD_INT 2
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 1
66402: NEG
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 1
66413: PUSH
66414: LD_INT 3
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 0
66423: PUSH
66424: LD_INT 3
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 1
66433: NEG
66434: PUSH
66435: LD_INT 2
66437: PUSH
66438: EMPTY
66439: LIST
66440: LIST
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66460: LD_ADDR_VAR 0 12
66464: PUSH
66465: LD_INT 0
66467: PUSH
66468: LD_INT 0
66470: PUSH
66471: EMPTY
66472: LIST
66473: LIST
66474: PUSH
66475: LD_INT 0
66477: PUSH
66478: LD_INT 1
66480: NEG
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: LD_INT 1
66488: PUSH
66489: LD_INT 0
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 1
66498: PUSH
66499: LD_INT 1
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 0
66508: PUSH
66509: LD_INT 1
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: PUSH
66516: LD_INT 1
66518: NEG
66519: PUSH
66520: LD_INT 0
66522: PUSH
66523: EMPTY
66524: LIST
66525: LIST
66526: PUSH
66527: LD_INT 1
66529: NEG
66530: PUSH
66531: LD_INT 1
66533: NEG
66534: PUSH
66535: EMPTY
66536: LIST
66537: LIST
66538: PUSH
66539: LD_INT 1
66541: PUSH
66542: LD_INT 1
66544: NEG
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 2
66552: PUSH
66553: LD_INT 0
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 2
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 1
66572: NEG
66573: PUSH
66574: LD_INT 1
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 2
66583: NEG
66584: PUSH
66585: LD_INT 0
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 2
66594: NEG
66595: PUSH
66596: LD_INT 1
66598: NEG
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 2
66606: NEG
66607: PUSH
66608: LD_INT 1
66610: PUSH
66611: EMPTY
66612: LIST
66613: LIST
66614: PUSH
66615: LD_INT 3
66617: NEG
66618: PUSH
66619: LD_INT 0
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 3
66628: NEG
66629: PUSH
66630: LD_INT 1
66632: NEG
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66656: LD_ADDR_VAR 0 13
66660: PUSH
66661: LD_INT 0
66663: PUSH
66664: LD_INT 0
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PUSH
66671: LD_INT 0
66673: PUSH
66674: LD_INT 1
66676: NEG
66677: PUSH
66678: EMPTY
66679: LIST
66680: LIST
66681: PUSH
66682: LD_INT 1
66684: PUSH
66685: LD_INT 0
66687: PUSH
66688: EMPTY
66689: LIST
66690: LIST
66691: PUSH
66692: LD_INT 1
66694: PUSH
66695: LD_INT 1
66697: PUSH
66698: EMPTY
66699: LIST
66700: LIST
66701: PUSH
66702: LD_INT 0
66704: PUSH
66705: LD_INT 1
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: LD_INT 1
66714: NEG
66715: PUSH
66716: LD_INT 0
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 1
66725: NEG
66726: PUSH
66727: LD_INT 1
66729: NEG
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: PUSH
66735: LD_INT 1
66737: NEG
66738: PUSH
66739: LD_INT 2
66741: NEG
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: LD_INT 2
66749: PUSH
66750: LD_INT 1
66752: PUSH
66753: EMPTY
66754: LIST
66755: LIST
66756: PUSH
66757: LD_INT 2
66759: PUSH
66760: LD_INT 2
66762: PUSH
66763: EMPTY
66764: LIST
66765: LIST
66766: PUSH
66767: LD_INT 1
66769: PUSH
66770: LD_INT 2
66772: PUSH
66773: EMPTY
66774: LIST
66775: LIST
66776: PUSH
66777: LD_INT 2
66779: NEG
66780: PUSH
66781: LD_INT 1
66783: NEG
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: LD_INT 2
66791: NEG
66792: PUSH
66793: LD_INT 2
66795: NEG
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PUSH
66801: LD_INT 2
66803: NEG
66804: PUSH
66805: LD_INT 3
66807: NEG
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 3
66815: NEG
66816: PUSH
66817: LD_INT 2
66819: NEG
66820: PUSH
66821: EMPTY
66822: LIST
66823: LIST
66824: PUSH
66825: LD_INT 3
66827: NEG
66828: PUSH
66829: LD_INT 3
66831: NEG
66832: PUSH
66833: EMPTY
66834: LIST
66835: LIST
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: LIST
66849: LIST
66850: LIST
66851: LIST
66852: LIST
66853: LIST
66854: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66855: LD_ADDR_VAR 0 14
66859: PUSH
66860: LD_INT 0
66862: PUSH
66863: LD_INT 0
66865: PUSH
66866: EMPTY
66867: LIST
66868: LIST
66869: PUSH
66870: LD_INT 0
66872: PUSH
66873: LD_INT 1
66875: NEG
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: PUSH
66881: LD_INT 1
66883: PUSH
66884: LD_INT 0
66886: PUSH
66887: EMPTY
66888: LIST
66889: LIST
66890: PUSH
66891: LD_INT 1
66893: PUSH
66894: LD_INT 1
66896: PUSH
66897: EMPTY
66898: LIST
66899: LIST
66900: PUSH
66901: LD_INT 0
66903: PUSH
66904: LD_INT 1
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: LD_INT 1
66913: NEG
66914: PUSH
66915: LD_INT 0
66917: PUSH
66918: EMPTY
66919: LIST
66920: LIST
66921: PUSH
66922: LD_INT 1
66924: NEG
66925: PUSH
66926: LD_INT 1
66928: NEG
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PUSH
66934: LD_INT 1
66936: NEG
66937: PUSH
66938: LD_INT 2
66940: NEG
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PUSH
66946: LD_INT 0
66948: PUSH
66949: LD_INT 2
66951: NEG
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: LD_INT 1
66959: PUSH
66960: LD_INT 1
66962: NEG
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 1
66970: PUSH
66971: LD_INT 2
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 0
66980: PUSH
66981: LD_INT 2
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: PUSH
66988: LD_INT 1
66990: NEG
66991: PUSH
66992: LD_INT 1
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: LD_INT 1
67001: NEG
67002: PUSH
67003: LD_INT 3
67005: NEG
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: PUSH
67011: LD_INT 0
67013: PUSH
67014: LD_INT 3
67016: NEG
67017: PUSH
67018: EMPTY
67019: LIST
67020: LIST
67021: PUSH
67022: LD_INT 1
67024: PUSH
67025: LD_INT 2
67027: NEG
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: LIST
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: LIST
67048: LIST
67049: LIST
67050: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67051: LD_ADDR_VAR 0 15
67055: PUSH
67056: LD_INT 0
67058: PUSH
67059: LD_INT 0
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 0
67068: PUSH
67069: LD_INT 1
67071: NEG
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: PUSH
67077: LD_INT 1
67079: PUSH
67080: LD_INT 0
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 1
67089: PUSH
67090: LD_INT 1
67092: PUSH
67093: EMPTY
67094: LIST
67095: LIST
67096: PUSH
67097: LD_INT 0
67099: PUSH
67100: LD_INT 1
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: PUSH
67107: LD_INT 1
67109: NEG
67110: PUSH
67111: LD_INT 0
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PUSH
67118: LD_INT 1
67120: NEG
67121: PUSH
67122: LD_INT 1
67124: NEG
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 1
67132: PUSH
67133: LD_INT 1
67135: NEG
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 2
67143: PUSH
67144: LD_INT 0
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 2
67153: PUSH
67154: LD_INT 1
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 1
67163: NEG
67164: PUSH
67165: LD_INT 1
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 2
67174: NEG
67175: PUSH
67176: LD_INT 0
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 2
67185: NEG
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 2
67197: PUSH
67198: LD_INT 1
67200: NEG
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 3
67208: PUSH
67209: LD_INT 0
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 3
67218: PUSH
67219: LD_INT 1
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: LIST
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67244: LD_ADDR_VAR 0 16
67248: PUSH
67249: LD_INT 0
67251: PUSH
67252: LD_INT 0
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 0
67261: PUSH
67262: LD_INT 1
67264: NEG
67265: PUSH
67266: EMPTY
67267: LIST
67268: LIST
67269: PUSH
67270: LD_INT 1
67272: PUSH
67273: LD_INT 0
67275: PUSH
67276: EMPTY
67277: LIST
67278: LIST
67279: PUSH
67280: LD_INT 1
67282: PUSH
67283: LD_INT 1
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 0
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: LD_INT 1
67302: NEG
67303: PUSH
67304: LD_INT 0
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 1
67313: NEG
67314: PUSH
67315: LD_INT 1
67317: NEG
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 1
67325: NEG
67326: PUSH
67327: LD_INT 2
67329: NEG
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: PUSH
67335: LD_INT 2
67337: PUSH
67338: LD_INT 1
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 2
67347: PUSH
67348: LD_INT 2
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 1
67357: PUSH
67358: LD_INT 2
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 2
67367: NEG
67368: PUSH
67369: LD_INT 1
67371: NEG
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: PUSH
67377: LD_INT 2
67379: NEG
67380: PUSH
67381: LD_INT 2
67383: NEG
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: PUSH
67389: LD_INT 3
67391: PUSH
67392: LD_INT 2
67394: PUSH
67395: EMPTY
67396: LIST
67397: LIST
67398: PUSH
67399: LD_INT 3
67401: PUSH
67402: LD_INT 3
67404: PUSH
67405: EMPTY
67406: LIST
67407: LIST
67408: PUSH
67409: LD_INT 2
67411: PUSH
67412: LD_INT 3
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: EMPTY
67420: LIST
67421: LIST
67422: LIST
67423: LIST
67424: LIST
67425: LIST
67426: LIST
67427: LIST
67428: LIST
67429: LIST
67430: LIST
67431: LIST
67432: LIST
67433: LIST
67434: LIST
67435: LIST
67436: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67437: LD_ADDR_VAR 0 17
67441: PUSH
67442: LD_INT 0
67444: PUSH
67445: LD_INT 0
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: LD_INT 0
67454: PUSH
67455: LD_INT 1
67457: NEG
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: PUSH
67463: LD_INT 1
67465: PUSH
67466: LD_INT 0
67468: PUSH
67469: EMPTY
67470: LIST
67471: LIST
67472: PUSH
67473: LD_INT 1
67475: PUSH
67476: LD_INT 1
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: LD_INT 0
67485: PUSH
67486: LD_INT 1
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 1
67495: NEG
67496: PUSH
67497: LD_INT 0
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 1
67506: NEG
67507: PUSH
67508: LD_INT 1
67510: NEG
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PUSH
67516: LD_INT 1
67518: NEG
67519: PUSH
67520: LD_INT 2
67522: NEG
67523: PUSH
67524: EMPTY
67525: LIST
67526: LIST
67527: PUSH
67528: LD_INT 0
67530: PUSH
67531: LD_INT 2
67533: NEG
67534: PUSH
67535: EMPTY
67536: LIST
67537: LIST
67538: PUSH
67539: LD_INT 1
67541: PUSH
67542: LD_INT 1
67544: NEG
67545: PUSH
67546: EMPTY
67547: LIST
67548: LIST
67549: PUSH
67550: LD_INT 2
67552: PUSH
67553: LD_INT 0
67555: PUSH
67556: EMPTY
67557: LIST
67558: LIST
67559: PUSH
67560: LD_INT 2
67562: PUSH
67563: LD_INT 1
67565: PUSH
67566: EMPTY
67567: LIST
67568: LIST
67569: PUSH
67570: LD_INT 2
67572: PUSH
67573: LD_INT 2
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: PUSH
67580: LD_INT 1
67582: PUSH
67583: LD_INT 2
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PUSH
67590: LD_INT 0
67592: PUSH
67593: LD_INT 2
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 1
67602: NEG
67603: PUSH
67604: LD_INT 1
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 2
67613: NEG
67614: PUSH
67615: LD_INT 0
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: LD_INT 2
67624: NEG
67625: PUSH
67626: LD_INT 1
67628: NEG
67629: PUSH
67630: EMPTY
67631: LIST
67632: LIST
67633: PUSH
67634: LD_INT 2
67636: NEG
67637: PUSH
67638: LD_INT 2
67640: NEG
67641: PUSH
67642: EMPTY
67643: LIST
67644: LIST
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: LIST
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: LIST
67664: LIST
67665: LIST
67666: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67667: LD_ADDR_VAR 0 18
67671: PUSH
67672: LD_INT 0
67674: PUSH
67675: LD_INT 0
67677: PUSH
67678: EMPTY
67679: LIST
67680: LIST
67681: PUSH
67682: LD_INT 0
67684: PUSH
67685: LD_INT 1
67687: NEG
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 1
67695: PUSH
67696: LD_INT 0
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 1
67705: PUSH
67706: LD_INT 1
67708: PUSH
67709: EMPTY
67710: LIST
67711: LIST
67712: PUSH
67713: LD_INT 0
67715: PUSH
67716: LD_INT 1
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: LD_INT 0
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 1
67736: NEG
67737: PUSH
67738: LD_INT 1
67740: NEG
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 1
67748: NEG
67749: PUSH
67750: LD_INT 2
67752: NEG
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: LD_INT 0
67760: PUSH
67761: LD_INT 2
67763: NEG
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: PUSH
67769: LD_INT 1
67771: PUSH
67772: LD_INT 1
67774: NEG
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: PUSH
67780: LD_INT 2
67782: PUSH
67783: LD_INT 0
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 2
67792: PUSH
67793: LD_INT 1
67795: PUSH
67796: EMPTY
67797: LIST
67798: LIST
67799: PUSH
67800: LD_INT 2
67802: PUSH
67803: LD_INT 2
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: PUSH
67810: LD_INT 1
67812: PUSH
67813: LD_INT 2
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: PUSH
67820: LD_INT 0
67822: PUSH
67823: LD_INT 2
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: LD_INT 1
67832: NEG
67833: PUSH
67834: LD_INT 1
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 2
67843: NEG
67844: PUSH
67845: LD_INT 0
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 2
67854: NEG
67855: PUSH
67856: LD_INT 1
67858: NEG
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 2
67866: NEG
67867: PUSH
67868: LD_INT 2
67870: NEG
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: LIST
67891: LIST
67892: LIST
67893: LIST
67894: LIST
67895: LIST
67896: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67897: LD_ADDR_VAR 0 19
67901: PUSH
67902: LD_INT 0
67904: PUSH
67905: LD_INT 0
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PUSH
67912: LD_INT 0
67914: PUSH
67915: LD_INT 1
67917: NEG
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: PUSH
67923: LD_INT 1
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 1
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: LD_INT 1
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: LD_INT 0
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 1
67966: NEG
67967: PUSH
67968: LD_INT 1
67970: NEG
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 1
67978: NEG
67979: PUSH
67980: LD_INT 2
67982: NEG
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 0
67990: PUSH
67991: LD_INT 2
67993: NEG
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: PUSH
67999: LD_INT 1
68001: PUSH
68002: LD_INT 1
68004: NEG
68005: PUSH
68006: EMPTY
68007: LIST
68008: LIST
68009: PUSH
68010: LD_INT 2
68012: PUSH
68013: LD_INT 0
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: PUSH
68020: LD_INT 2
68022: PUSH
68023: LD_INT 1
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: LD_INT 2
68032: PUSH
68033: LD_INT 2
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: LD_INT 1
68042: PUSH
68043: LD_INT 2
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 0
68052: PUSH
68053: LD_INT 2
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 1
68062: NEG
68063: PUSH
68064: LD_INT 1
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 2
68073: NEG
68074: PUSH
68075: LD_INT 0
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 2
68084: NEG
68085: PUSH
68086: LD_INT 1
68088: NEG
68089: PUSH
68090: EMPTY
68091: LIST
68092: LIST
68093: PUSH
68094: LD_INT 2
68096: NEG
68097: PUSH
68098: LD_INT 2
68100: NEG
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68127: LD_ADDR_VAR 0 20
68131: PUSH
68132: LD_INT 0
68134: PUSH
68135: LD_INT 0
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: LD_INT 0
68144: PUSH
68145: LD_INT 1
68147: NEG
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: PUSH
68153: LD_INT 1
68155: PUSH
68156: LD_INT 0
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 1
68165: PUSH
68166: LD_INT 1
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 0
68175: PUSH
68176: LD_INT 1
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 1
68185: NEG
68186: PUSH
68187: LD_INT 0
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 1
68196: NEG
68197: PUSH
68198: LD_INT 1
68200: NEG
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: PUSH
68206: LD_INT 1
68208: NEG
68209: PUSH
68210: LD_INT 2
68212: NEG
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 0
68220: PUSH
68221: LD_INT 2
68223: NEG
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 1
68231: PUSH
68232: LD_INT 1
68234: NEG
68235: PUSH
68236: EMPTY
68237: LIST
68238: LIST
68239: PUSH
68240: LD_INT 2
68242: PUSH
68243: LD_INT 0
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PUSH
68250: LD_INT 2
68252: PUSH
68253: LD_INT 1
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 2
68262: PUSH
68263: LD_INT 2
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 1
68272: PUSH
68273: LD_INT 2
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 0
68282: PUSH
68283: LD_INT 2
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 1
68292: NEG
68293: PUSH
68294: LD_INT 1
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 2
68303: NEG
68304: PUSH
68305: LD_INT 0
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: PUSH
68312: LD_INT 2
68314: NEG
68315: PUSH
68316: LD_INT 1
68318: NEG
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: PUSH
68324: LD_INT 2
68326: NEG
68327: PUSH
68328: LD_INT 2
68330: NEG
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: LIST
68354: LIST
68355: LIST
68356: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68357: LD_ADDR_VAR 0 21
68361: PUSH
68362: LD_INT 0
68364: PUSH
68365: LD_INT 0
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: LD_INT 0
68374: PUSH
68375: LD_INT 1
68377: NEG
68378: PUSH
68379: EMPTY
68380: LIST
68381: LIST
68382: PUSH
68383: LD_INT 1
68385: PUSH
68386: LD_INT 0
68388: PUSH
68389: EMPTY
68390: LIST
68391: LIST
68392: PUSH
68393: LD_INT 1
68395: PUSH
68396: LD_INT 1
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: PUSH
68403: LD_INT 0
68405: PUSH
68406: LD_INT 1
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 1
68415: NEG
68416: PUSH
68417: LD_INT 0
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 1
68426: NEG
68427: PUSH
68428: LD_INT 1
68430: NEG
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: LD_INT 1
68438: NEG
68439: PUSH
68440: LD_INT 2
68442: NEG
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 0
68450: PUSH
68451: LD_INT 2
68453: NEG
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 1
68461: PUSH
68462: LD_INT 1
68464: NEG
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 2
68472: PUSH
68473: LD_INT 0
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: LD_INT 2
68482: PUSH
68483: LD_INT 1
68485: PUSH
68486: EMPTY
68487: LIST
68488: LIST
68489: PUSH
68490: LD_INT 2
68492: PUSH
68493: LD_INT 2
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 1
68502: PUSH
68503: LD_INT 2
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PUSH
68510: LD_INT 0
68512: PUSH
68513: LD_INT 2
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 1
68522: NEG
68523: PUSH
68524: LD_INT 1
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 2
68533: NEG
68534: PUSH
68535: LD_INT 0
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 2
68544: NEG
68545: PUSH
68546: LD_INT 1
68548: NEG
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: PUSH
68554: LD_INT 2
68556: NEG
68557: PUSH
68558: LD_INT 2
68560: NEG
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: EMPTY
68567: LIST
68568: LIST
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: LIST
68577: LIST
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68587: LD_ADDR_VAR 0 22
68591: PUSH
68592: LD_INT 0
68594: PUSH
68595: LD_INT 0
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: LD_INT 0
68604: PUSH
68605: LD_INT 1
68607: NEG
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 1
68615: PUSH
68616: LD_INT 0
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 1
68625: PUSH
68626: LD_INT 1
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 0
68635: PUSH
68636: LD_INT 1
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 1
68645: NEG
68646: PUSH
68647: LD_INT 0
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: PUSH
68654: LD_INT 1
68656: NEG
68657: PUSH
68658: LD_INT 1
68660: NEG
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 1
68668: NEG
68669: PUSH
68670: LD_INT 2
68672: NEG
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 0
68680: PUSH
68681: LD_INT 2
68683: NEG
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 1
68691: PUSH
68692: LD_INT 1
68694: NEG
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 2
68702: PUSH
68703: LD_INT 0
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 2
68712: PUSH
68713: LD_INT 1
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: PUSH
68720: LD_INT 2
68722: PUSH
68723: LD_INT 2
68725: PUSH
68726: EMPTY
68727: LIST
68728: LIST
68729: PUSH
68730: LD_INT 1
68732: PUSH
68733: LD_INT 2
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 0
68742: PUSH
68743: LD_INT 2
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: NEG
68753: PUSH
68754: LD_INT 1
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 2
68763: NEG
68764: PUSH
68765: LD_INT 0
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: LD_INT 2
68774: NEG
68775: PUSH
68776: LD_INT 1
68778: NEG
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: PUSH
68784: LD_INT 2
68786: NEG
68787: PUSH
68788: LD_INT 2
68790: NEG
68791: PUSH
68792: EMPTY
68793: LIST
68794: LIST
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: LIST
68807: LIST
68808: LIST
68809: LIST
68810: LIST
68811: LIST
68812: LIST
68813: LIST
68814: LIST
68815: LIST
68816: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68817: LD_ADDR_VAR 0 23
68821: PUSH
68822: LD_INT 0
68824: PUSH
68825: LD_INT 0
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 0
68834: PUSH
68835: LD_INT 1
68837: NEG
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 1
68845: PUSH
68846: LD_INT 0
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: LD_INT 1
68855: PUSH
68856: LD_INT 1
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 0
68865: PUSH
68866: LD_INT 1
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 1
68875: NEG
68876: PUSH
68877: LD_INT 0
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: PUSH
68884: LD_INT 1
68886: NEG
68887: PUSH
68888: LD_INT 1
68890: NEG
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: LD_INT 1
68898: NEG
68899: PUSH
68900: LD_INT 2
68902: NEG
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 0
68910: PUSH
68911: LD_INT 2
68913: NEG
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 1
68921: PUSH
68922: LD_INT 1
68924: NEG
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: PUSH
68930: LD_INT 2
68932: PUSH
68933: LD_INT 0
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 2
68942: PUSH
68943: LD_INT 1
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PUSH
68950: LD_INT 2
68952: PUSH
68953: LD_INT 2
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PUSH
68960: LD_INT 1
68962: PUSH
68963: LD_INT 2
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: PUSH
68970: LD_INT 0
68972: PUSH
68973: LD_INT 2
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 1
68982: NEG
68983: PUSH
68984: LD_INT 1
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 2
68993: NEG
68994: PUSH
68995: LD_INT 0
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: LD_INT 2
69004: NEG
69005: PUSH
69006: LD_INT 1
69008: NEG
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 2
69016: NEG
69017: PUSH
69018: LD_INT 2
69020: NEG
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: PUSH
69026: LD_INT 2
69028: NEG
69029: PUSH
69030: LD_INT 3
69032: NEG
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 1
69040: NEG
69041: PUSH
69042: LD_INT 3
69044: NEG
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: PUSH
69050: LD_INT 1
69052: PUSH
69053: LD_INT 2
69055: NEG
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 2
69063: PUSH
69064: LD_INT 1
69066: NEG
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69097: LD_ADDR_VAR 0 24
69101: PUSH
69102: LD_INT 0
69104: PUSH
69105: LD_INT 0
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 0
69114: PUSH
69115: LD_INT 1
69117: NEG
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PUSH
69123: LD_INT 1
69125: PUSH
69126: LD_INT 0
69128: PUSH
69129: EMPTY
69130: LIST
69131: LIST
69132: PUSH
69133: LD_INT 1
69135: PUSH
69136: LD_INT 1
69138: PUSH
69139: EMPTY
69140: LIST
69141: LIST
69142: PUSH
69143: LD_INT 0
69145: PUSH
69146: LD_INT 1
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: LD_INT 0
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: LD_INT 1
69166: NEG
69167: PUSH
69168: LD_INT 1
69170: NEG
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: LD_INT 1
69178: NEG
69179: PUSH
69180: LD_INT 2
69182: NEG
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 0
69190: PUSH
69191: LD_INT 2
69193: NEG
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PUSH
69199: LD_INT 1
69201: PUSH
69202: LD_INT 1
69204: NEG
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: PUSH
69210: LD_INT 2
69212: PUSH
69213: LD_INT 0
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 2
69222: PUSH
69223: LD_INT 1
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: LD_INT 2
69232: PUSH
69233: LD_INT 2
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: PUSH
69240: LD_INT 1
69242: PUSH
69243: LD_INT 2
69245: PUSH
69246: EMPTY
69247: LIST
69248: LIST
69249: PUSH
69250: LD_INT 0
69252: PUSH
69253: LD_INT 2
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: NEG
69263: PUSH
69264: LD_INT 1
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: NEG
69274: PUSH
69275: LD_INT 0
69277: PUSH
69278: EMPTY
69279: LIST
69280: LIST
69281: PUSH
69282: LD_INT 2
69284: NEG
69285: PUSH
69286: LD_INT 1
69288: NEG
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: LD_INT 2
69296: NEG
69297: PUSH
69298: LD_INT 2
69300: NEG
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: PUSH
69306: LD_INT 1
69308: PUSH
69309: LD_INT 2
69311: NEG
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 2
69319: PUSH
69320: LD_INT 1
69322: NEG
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 3
69330: PUSH
69331: LD_INT 1
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 3
69340: PUSH
69341: LD_INT 2
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: LIST
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69373: LD_ADDR_VAR 0 25
69377: PUSH
69378: LD_INT 0
69380: PUSH
69381: LD_INT 0
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: PUSH
69388: LD_INT 0
69390: PUSH
69391: LD_INT 1
69393: NEG
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: LD_INT 1
69401: PUSH
69402: LD_INT 0
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: PUSH
69409: LD_INT 1
69411: PUSH
69412: LD_INT 1
69414: PUSH
69415: EMPTY
69416: LIST
69417: LIST
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: LD_INT 1
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 1
69431: NEG
69432: PUSH
69433: LD_INT 0
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: NEG
69443: PUSH
69444: LD_INT 1
69446: NEG
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: LD_INT 2
69458: NEG
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 0
69466: PUSH
69467: LD_INT 2
69469: NEG
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: PUSH
69475: LD_INT 1
69477: PUSH
69478: LD_INT 1
69480: NEG
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: LD_INT 2
69488: PUSH
69489: LD_INT 0
69491: PUSH
69492: EMPTY
69493: LIST
69494: LIST
69495: PUSH
69496: LD_INT 2
69498: PUSH
69499: LD_INT 1
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 2
69508: PUSH
69509: LD_INT 2
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 1
69518: PUSH
69519: LD_INT 2
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: LD_INT 0
69528: PUSH
69529: LD_INT 2
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 1
69538: NEG
69539: PUSH
69540: LD_INT 1
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 2
69549: NEG
69550: PUSH
69551: LD_INT 0
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PUSH
69558: LD_INT 2
69560: NEG
69561: PUSH
69562: LD_INT 1
69564: NEG
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 2
69572: NEG
69573: PUSH
69574: LD_INT 2
69576: NEG
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 3
69584: PUSH
69585: LD_INT 1
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PUSH
69592: LD_INT 3
69594: PUSH
69595: LD_INT 2
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 2
69604: PUSH
69605: LD_INT 3
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 1
69614: PUSH
69615: LD_INT 3
69617: PUSH
69618: EMPTY
69619: LIST
69620: LIST
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69647: LD_ADDR_VAR 0 26
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: LD_INT 0
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PUSH
69662: LD_INT 0
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: LD_INT 0
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: LD_INT 1
69685: PUSH
69686: LD_INT 1
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: LD_INT 0
69695: PUSH
69696: LD_INT 1
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 1
69705: NEG
69706: PUSH
69707: LD_INT 0
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 1
69716: NEG
69717: PUSH
69718: LD_INT 1
69720: NEG
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 1
69728: NEG
69729: PUSH
69730: LD_INT 2
69732: NEG
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 0
69740: PUSH
69741: LD_INT 2
69743: NEG
69744: PUSH
69745: EMPTY
69746: LIST
69747: LIST
69748: PUSH
69749: LD_INT 1
69751: PUSH
69752: LD_INT 1
69754: NEG
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: PUSH
69760: LD_INT 2
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 2
69772: PUSH
69773: LD_INT 1
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: PUSH
69780: LD_INT 2
69782: PUSH
69783: LD_INT 2
69785: PUSH
69786: EMPTY
69787: LIST
69788: LIST
69789: PUSH
69790: LD_INT 1
69792: PUSH
69793: LD_INT 2
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PUSH
69800: LD_INT 0
69802: PUSH
69803: LD_INT 2
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 1
69812: NEG
69813: PUSH
69814: LD_INT 1
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 2
69823: NEG
69824: PUSH
69825: LD_INT 0
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: PUSH
69832: LD_INT 2
69834: NEG
69835: PUSH
69836: LD_INT 1
69838: NEG
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: PUSH
69844: LD_INT 2
69846: NEG
69847: PUSH
69848: LD_INT 2
69850: NEG
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 2
69858: PUSH
69859: LD_INT 3
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PUSH
69866: LD_INT 1
69868: PUSH
69869: LD_INT 3
69871: PUSH
69872: EMPTY
69873: LIST
69874: LIST
69875: PUSH
69876: LD_INT 1
69878: NEG
69879: PUSH
69880: LD_INT 2
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 2
69889: NEG
69890: PUSH
69891: LD_INT 1
69893: PUSH
69894: EMPTY
69895: LIST
69896: LIST
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: LIST
69902: LIST
69903: LIST
69904: LIST
69905: LIST
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: LIST
69920: LIST
69921: LIST
69922: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69923: LD_ADDR_VAR 0 27
69927: PUSH
69928: LD_INT 0
69930: PUSH
69931: LD_INT 0
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: PUSH
69938: LD_INT 0
69940: PUSH
69941: LD_INT 1
69943: NEG
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 1
69951: PUSH
69952: LD_INT 0
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PUSH
69959: LD_INT 1
69961: PUSH
69962: LD_INT 1
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 0
69971: PUSH
69972: LD_INT 1
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 1
69981: NEG
69982: PUSH
69983: LD_INT 0
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 1
69992: NEG
69993: PUSH
69994: LD_INT 1
69996: NEG
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 1
70004: NEG
70005: PUSH
70006: LD_INT 2
70008: NEG
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 0
70016: PUSH
70017: LD_INT 2
70019: NEG
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 1
70027: PUSH
70028: LD_INT 1
70030: NEG
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 2
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 2
70048: PUSH
70049: LD_INT 1
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 2
70058: PUSH
70059: LD_INT 2
70061: PUSH
70062: EMPTY
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 1
70068: PUSH
70069: LD_INT 2
70071: PUSH
70072: EMPTY
70073: LIST
70074: LIST
70075: PUSH
70076: LD_INT 0
70078: PUSH
70079: LD_INT 2
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: PUSH
70086: LD_INT 1
70088: NEG
70089: PUSH
70090: LD_INT 1
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 2
70099: NEG
70100: PUSH
70101: LD_INT 0
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 2
70110: NEG
70111: PUSH
70112: LD_INT 1
70114: NEG
70115: PUSH
70116: EMPTY
70117: LIST
70118: LIST
70119: PUSH
70120: LD_INT 2
70122: NEG
70123: PUSH
70124: LD_INT 2
70126: NEG
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: PUSH
70132: LD_INT 1
70134: NEG
70135: PUSH
70136: LD_INT 2
70138: PUSH
70139: EMPTY
70140: LIST
70141: LIST
70142: PUSH
70143: LD_INT 2
70145: NEG
70146: PUSH
70147: LD_INT 1
70149: PUSH
70150: EMPTY
70151: LIST
70152: LIST
70153: PUSH
70154: LD_INT 3
70156: NEG
70157: PUSH
70158: LD_INT 1
70160: NEG
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 3
70168: NEG
70169: PUSH
70170: LD_INT 2
70172: NEG
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70203: LD_ADDR_VAR 0 28
70207: PUSH
70208: LD_INT 0
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PUSH
70218: LD_INT 0
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PUSH
70229: LD_INT 1
70231: PUSH
70232: LD_INT 0
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 1
70241: PUSH
70242: LD_INT 1
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 0
70251: PUSH
70252: LD_INT 1
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: LD_INT 1
70261: NEG
70262: PUSH
70263: LD_INT 0
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 1
70272: NEG
70273: PUSH
70274: LD_INT 1
70276: NEG
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 1
70284: NEG
70285: PUSH
70286: LD_INT 2
70288: NEG
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 0
70296: PUSH
70297: LD_INT 2
70299: NEG
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 1
70307: PUSH
70308: LD_INT 1
70310: NEG
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 2
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: LD_INT 2
70328: PUSH
70329: LD_INT 1
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PUSH
70336: LD_INT 2
70338: PUSH
70339: LD_INT 2
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: PUSH
70346: LD_INT 1
70348: PUSH
70349: LD_INT 2
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: PUSH
70356: LD_INT 0
70358: PUSH
70359: LD_INT 2
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 1
70368: NEG
70369: PUSH
70370: LD_INT 1
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 2
70379: NEG
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: LD_INT 2
70390: NEG
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: EMPTY
70397: LIST
70398: LIST
70399: PUSH
70400: LD_INT 2
70402: NEG
70403: PUSH
70404: LD_INT 2
70406: NEG
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: PUSH
70412: LD_INT 2
70414: NEG
70415: PUSH
70416: LD_INT 3
70418: NEG
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: PUSH
70424: LD_INT 1
70426: NEG
70427: PUSH
70428: LD_INT 3
70430: NEG
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 3
70438: NEG
70439: PUSH
70440: LD_INT 1
70442: NEG
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 3
70450: NEG
70451: PUSH
70452: LD_INT 2
70454: NEG
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: LIST
70484: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70485: LD_ADDR_VAR 0 29
70489: PUSH
70490: LD_INT 0
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 0
70502: PUSH
70503: LD_INT 1
70505: NEG
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 1
70513: PUSH
70514: LD_INT 0
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 1
70523: PUSH
70524: LD_INT 1
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PUSH
70531: LD_INT 0
70533: PUSH
70534: LD_INT 1
70536: PUSH
70537: EMPTY
70538: LIST
70539: LIST
70540: PUSH
70541: LD_INT 1
70543: NEG
70544: PUSH
70545: LD_INT 0
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: LD_INT 1
70554: NEG
70555: PUSH
70556: LD_INT 1
70558: NEG
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 1
70566: NEG
70567: PUSH
70568: LD_INT 2
70570: NEG
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 0
70578: PUSH
70579: LD_INT 2
70581: NEG
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 1
70589: PUSH
70590: LD_INT 1
70592: NEG
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 2
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 2
70610: PUSH
70611: LD_INT 1
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 1
70620: PUSH
70621: LD_INT 2
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: LD_INT 0
70630: PUSH
70631: LD_INT 2
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: PUSH
70638: LD_INT 1
70640: NEG
70641: PUSH
70642: LD_INT 1
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 2
70651: NEG
70652: PUSH
70653: LD_INT 1
70655: NEG
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: LD_INT 2
70663: NEG
70664: PUSH
70665: LD_INT 2
70667: NEG
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 2
70675: NEG
70676: PUSH
70677: LD_INT 3
70679: NEG
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 2
70687: PUSH
70688: LD_INT 1
70690: NEG
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: PUSH
70696: LD_INT 3
70698: PUSH
70699: LD_INT 1
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: PUSH
70706: LD_INT 1
70708: PUSH
70709: LD_INT 3
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 1
70718: NEG
70719: PUSH
70720: LD_INT 2
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: LD_INT 3
70729: NEG
70730: PUSH
70731: LD_INT 2
70733: NEG
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70764: LD_ADDR_VAR 0 30
70768: PUSH
70769: LD_INT 0
70771: PUSH
70772: LD_INT 0
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 0
70781: PUSH
70782: LD_INT 1
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: PUSH
70793: LD_INT 0
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 1
70802: PUSH
70803: LD_INT 1
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: LD_INT 1
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: NEG
70823: PUSH
70824: LD_INT 0
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 1
70833: NEG
70834: PUSH
70835: LD_INT 1
70837: NEG
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: NEG
70846: PUSH
70847: LD_INT 2
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 0
70857: PUSH
70858: LD_INT 2
70860: NEG
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 1
70868: PUSH
70869: LD_INT 1
70871: NEG
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 2
70879: PUSH
70880: LD_INT 0
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 2
70889: PUSH
70890: LD_INT 1
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 2
70899: PUSH
70900: LD_INT 2
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 1
70909: PUSH
70910: LD_INT 2
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: NEG
70920: PUSH
70921: LD_INT 1
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 2
70930: NEG
70931: PUSH
70932: LD_INT 0
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 2
70941: NEG
70942: PUSH
70943: LD_INT 1
70945: NEG
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: PUSH
70951: LD_INT 1
70953: NEG
70954: PUSH
70955: LD_INT 3
70957: NEG
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 1
70965: PUSH
70966: LD_INT 2
70968: NEG
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: PUSH
70974: LD_INT 3
70976: PUSH
70977: LD_INT 2
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 2
70986: PUSH
70987: LD_INT 3
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 2
70996: NEG
70997: PUSH
70998: LD_INT 1
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 3
71007: NEG
71008: PUSH
71009: LD_INT 1
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: LIST
71041: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71042: LD_ADDR_VAR 0 31
71046: PUSH
71047: LD_INT 0
71049: PUSH
71050: LD_INT 0
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 0
71059: PUSH
71060: LD_INT 1
71062: NEG
71063: PUSH
71064: EMPTY
71065: LIST
71066: LIST
71067: PUSH
71068: LD_INT 1
71070: PUSH
71071: LD_INT 0
71073: PUSH
71074: EMPTY
71075: LIST
71076: LIST
71077: PUSH
71078: LD_INT 1
71080: PUSH
71081: LD_INT 1
71083: PUSH
71084: EMPTY
71085: LIST
71086: LIST
71087: PUSH
71088: LD_INT 0
71090: PUSH
71091: LD_INT 1
71093: PUSH
71094: EMPTY
71095: LIST
71096: LIST
71097: PUSH
71098: LD_INT 1
71100: NEG
71101: PUSH
71102: LD_INT 0
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: PUSH
71109: LD_INT 1
71111: NEG
71112: PUSH
71113: LD_INT 1
71115: NEG
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 1
71123: NEG
71124: PUSH
71125: LD_INT 2
71127: NEG
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: LD_INT 1
71135: PUSH
71136: LD_INT 1
71138: NEG
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: PUSH
71144: LD_INT 2
71146: PUSH
71147: LD_INT 0
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: PUSH
71154: LD_INT 2
71156: PUSH
71157: LD_INT 1
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PUSH
71164: LD_INT 2
71166: PUSH
71167: LD_INT 2
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 1
71176: PUSH
71177: LD_INT 2
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 0
71186: PUSH
71187: LD_INT 2
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 1
71196: NEG
71197: PUSH
71198: LD_INT 1
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 2
71207: NEG
71208: PUSH
71209: LD_INT 1
71211: NEG
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PUSH
71217: LD_INT 2
71219: NEG
71220: PUSH
71221: LD_INT 2
71223: NEG
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 2
71231: NEG
71232: PUSH
71233: LD_INT 3
71235: NEG
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: PUSH
71241: LD_INT 2
71243: PUSH
71244: LD_INT 1
71246: NEG
71247: PUSH
71248: EMPTY
71249: LIST
71250: LIST
71251: PUSH
71252: LD_INT 3
71254: PUSH
71255: LD_INT 1
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 1
71264: PUSH
71265: LD_INT 3
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: LD_INT 1
71274: NEG
71275: PUSH
71276: LD_INT 2
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 3
71285: NEG
71286: PUSH
71287: LD_INT 2
71289: NEG
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71320: LD_ADDR_VAR 0 32
71324: PUSH
71325: LD_INT 0
71327: PUSH
71328: LD_INT 0
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 0
71337: PUSH
71338: LD_INT 1
71340: NEG
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: PUSH
71346: LD_INT 1
71348: PUSH
71349: LD_INT 0
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: LD_INT 1
71358: PUSH
71359: LD_INT 1
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: LD_INT 1
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 1
71378: NEG
71379: PUSH
71380: LD_INT 0
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 1
71389: NEG
71390: PUSH
71391: LD_INT 1
71393: NEG
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 1
71401: NEG
71402: PUSH
71403: LD_INT 2
71405: NEG
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: LD_INT 0
71413: PUSH
71414: LD_INT 2
71416: NEG
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 1
71424: PUSH
71425: LD_INT 1
71427: NEG
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PUSH
71433: LD_INT 2
71435: PUSH
71436: LD_INT 1
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: LD_INT 2
71445: PUSH
71446: LD_INT 2
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 1
71455: PUSH
71456: LD_INT 2
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: PUSH
71463: LD_INT 0
71465: PUSH
71466: LD_INT 2
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 1
71475: NEG
71476: PUSH
71477: LD_INT 1
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: LD_INT 2
71486: NEG
71487: PUSH
71488: LD_INT 0
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 2
71497: NEG
71498: PUSH
71499: LD_INT 1
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 1
71509: NEG
71510: PUSH
71511: LD_INT 3
71513: NEG
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 1
71521: PUSH
71522: LD_INT 2
71524: NEG
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: LD_INT 3
71532: PUSH
71533: LD_INT 2
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 2
71542: PUSH
71543: LD_INT 3
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 2
71552: NEG
71553: PUSH
71554: LD_INT 1
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 3
71563: NEG
71564: PUSH
71565: LD_INT 1
71567: NEG
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: LIST
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: LIST
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71598: LD_ADDR_VAR 0 33
71602: PUSH
71603: LD_INT 0
71605: PUSH
71606: LD_INT 0
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: LD_INT 0
71615: PUSH
71616: LD_INT 1
71618: NEG
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 1
71626: PUSH
71627: LD_INT 0
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 1
71636: PUSH
71637: LD_INT 1
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 0
71646: PUSH
71647: LD_INT 1
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 1
71656: NEG
71657: PUSH
71658: LD_INT 0
71660: PUSH
71661: EMPTY
71662: LIST
71663: LIST
71664: PUSH
71665: LD_INT 1
71667: NEG
71668: PUSH
71669: LD_INT 1
71671: NEG
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 1
71679: NEG
71680: PUSH
71681: LD_INT 2
71683: NEG
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 1
71691: PUSH
71692: LD_INT 1
71694: NEG
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 2
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 2
71712: PUSH
71713: LD_INT 1
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: PUSH
71720: LD_INT 1
71722: PUSH
71723: LD_INT 2
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 0
71732: PUSH
71733: LD_INT 2
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: PUSH
71740: LD_INT 1
71742: NEG
71743: PUSH
71744: LD_INT 1
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 2
71753: NEG
71754: PUSH
71755: LD_INT 0
71757: PUSH
71758: EMPTY
71759: LIST
71760: LIST
71761: PUSH
71762: LD_INT 2
71764: NEG
71765: PUSH
71766: LD_INT 1
71768: NEG
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: PUSH
71774: LD_INT 2
71776: NEG
71777: PUSH
71778: LD_INT 2
71780: NEG
71781: PUSH
71782: EMPTY
71783: LIST
71784: LIST
71785: PUSH
71786: LD_INT 2
71788: NEG
71789: PUSH
71790: LD_INT 3
71792: NEG
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: LD_INT 2
71800: PUSH
71801: LD_INT 1
71803: NEG
71804: PUSH
71805: EMPTY
71806: LIST
71807: LIST
71808: PUSH
71809: LD_INT 3
71811: PUSH
71812: LD_INT 1
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: PUSH
71819: LD_INT 1
71821: PUSH
71822: LD_INT 3
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: LD_INT 1
71831: NEG
71832: PUSH
71833: LD_INT 2
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: LD_INT 3
71842: NEG
71843: PUSH
71844: LD_INT 2
71846: NEG
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: PUSH
71852: EMPTY
71853: LIST
71854: LIST
71855: LIST
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71877: LD_ADDR_VAR 0 34
71881: PUSH
71882: LD_INT 0
71884: PUSH
71885: LD_INT 0
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 0
71894: PUSH
71895: LD_INT 1
71897: NEG
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 1
71905: PUSH
71906: LD_INT 0
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 1
71915: PUSH
71916: LD_INT 1
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: LD_INT 1
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 1
71935: NEG
71936: PUSH
71937: LD_INT 0
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 1
71946: NEG
71947: PUSH
71948: LD_INT 1
71950: NEG
71951: PUSH
71952: EMPTY
71953: LIST
71954: LIST
71955: PUSH
71956: LD_INT 1
71958: NEG
71959: PUSH
71960: LD_INT 2
71962: NEG
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 0
71970: PUSH
71971: LD_INT 2
71973: NEG
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 1
71981: PUSH
71982: LD_INT 1
71984: NEG
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: PUSH
71990: LD_INT 2
71992: PUSH
71993: LD_INT 1
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 2
72002: PUSH
72003: LD_INT 2
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 1
72012: PUSH
72013: LD_INT 2
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 1
72022: NEG
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: PUSH
72031: LD_INT 2
72033: NEG
72034: PUSH
72035: LD_INT 0
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: LD_INT 2
72044: NEG
72045: PUSH
72046: LD_INT 1
72048: NEG
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 2
72056: NEG
72057: PUSH
72058: LD_INT 2
72060: NEG
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: PUSH
72066: LD_INT 1
72068: NEG
72069: PUSH
72070: LD_INT 3
72072: NEG
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 1
72080: PUSH
72081: LD_INT 2
72083: NEG
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: LD_INT 3
72091: PUSH
72092: LD_INT 2
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: LD_INT 2
72101: PUSH
72102: LD_INT 3
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: PUSH
72109: LD_INT 2
72111: NEG
72112: PUSH
72113: LD_INT 1
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 3
72122: NEG
72123: PUSH
72124: LD_INT 1
72126: NEG
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: LIST
72149: LIST
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: LIST
72155: LIST
72156: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72157: LD_ADDR_VAR 0 35
72161: PUSH
72162: LD_INT 0
72164: PUSH
72165: LD_INT 0
72167: PUSH
72168: EMPTY
72169: LIST
72170: LIST
72171: PUSH
72172: LD_INT 0
72174: PUSH
72175: LD_INT 1
72177: NEG
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: LD_INT 1
72185: PUSH
72186: LD_INT 0
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: LD_INT 1
72195: PUSH
72196: LD_INT 1
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 0
72205: PUSH
72206: LD_INT 1
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 1
72215: NEG
72216: PUSH
72217: LD_INT 0
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 1
72226: NEG
72227: PUSH
72228: LD_INT 1
72230: NEG
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 2
72238: PUSH
72239: LD_INT 1
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 2
72248: NEG
72249: PUSH
72250: LD_INT 1
72252: NEG
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: LIST
72262: LIST
72263: LIST
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72269: LD_ADDR_VAR 0 36
72273: PUSH
72274: LD_INT 0
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 0
72286: PUSH
72287: LD_INT 1
72289: NEG
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: PUSH
72298: LD_INT 0
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 1
72307: PUSH
72308: LD_INT 1
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 0
72317: PUSH
72318: LD_INT 1
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 1
72327: NEG
72328: PUSH
72329: LD_INT 0
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PUSH
72336: LD_INT 1
72338: NEG
72339: PUSH
72340: LD_INT 1
72342: NEG
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PUSH
72348: LD_INT 1
72350: NEG
72351: PUSH
72352: LD_INT 2
72354: NEG
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 1
72362: PUSH
72363: LD_INT 2
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72381: LD_ADDR_VAR 0 37
72385: PUSH
72386: LD_INT 0
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PUSH
72396: LD_INT 0
72398: PUSH
72399: LD_INT 1
72401: NEG
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: LD_INT 1
72409: PUSH
72410: LD_INT 0
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 1
72419: PUSH
72420: LD_INT 1
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: LD_INT 0
72429: PUSH
72430: LD_INT 1
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PUSH
72437: LD_INT 1
72439: NEG
72440: PUSH
72441: LD_INT 0
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: PUSH
72448: LD_INT 1
72450: NEG
72451: PUSH
72452: LD_INT 1
72454: NEG
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: PUSH
72460: LD_INT 1
72462: PUSH
72463: LD_INT 1
72465: NEG
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: LD_INT 1
72473: NEG
72474: PUSH
72475: LD_INT 1
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72493: LD_ADDR_VAR 0 38
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: LD_INT 0
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: PUSH
72508: LD_INT 0
72510: PUSH
72511: LD_INT 1
72513: NEG
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 1
72521: PUSH
72522: LD_INT 0
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 1
72531: PUSH
72532: LD_INT 1
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 0
72541: PUSH
72542: LD_INT 1
72544: PUSH
72545: EMPTY
72546: LIST
72547: LIST
72548: PUSH
72549: LD_INT 1
72551: NEG
72552: PUSH
72553: LD_INT 0
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 1
72562: NEG
72563: PUSH
72564: LD_INT 1
72566: NEG
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 2
72574: PUSH
72575: LD_INT 1
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 2
72584: NEG
72585: PUSH
72586: LD_INT 1
72588: NEG
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: LIST
72600: LIST
72601: LIST
72602: LIST
72603: LIST
72604: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72605: LD_ADDR_VAR 0 39
72609: PUSH
72610: LD_INT 0
72612: PUSH
72613: LD_INT 0
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 0
72622: PUSH
72623: LD_INT 1
72625: NEG
72626: PUSH
72627: EMPTY
72628: LIST
72629: LIST
72630: PUSH
72631: LD_INT 1
72633: PUSH
72634: LD_INT 0
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: PUSH
72641: LD_INT 1
72643: PUSH
72644: LD_INT 1
72646: PUSH
72647: EMPTY
72648: LIST
72649: LIST
72650: PUSH
72651: LD_INT 0
72653: PUSH
72654: LD_INT 1
72656: PUSH
72657: EMPTY
72658: LIST
72659: LIST
72660: PUSH
72661: LD_INT 1
72663: NEG
72664: PUSH
72665: LD_INT 0
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: PUSH
72672: LD_INT 1
72674: NEG
72675: PUSH
72676: LD_INT 1
72678: NEG
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 1
72686: NEG
72687: PUSH
72688: LD_INT 2
72690: NEG
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 1
72698: PUSH
72699: LD_INT 2
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: LIST
72710: LIST
72711: LIST
72712: LIST
72713: LIST
72714: LIST
72715: LIST
72716: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72717: LD_ADDR_VAR 0 40
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 0
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: EMPTY
72740: LIST
72741: LIST
72742: PUSH
72743: LD_INT 1
72745: PUSH
72746: LD_INT 0
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 1
72755: PUSH
72756: LD_INT 1
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 0
72765: PUSH
72766: LD_INT 1
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 1
72775: NEG
72776: PUSH
72777: LD_INT 0
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: LD_INT 1
72786: NEG
72787: PUSH
72788: LD_INT 1
72790: NEG
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 1
72798: PUSH
72799: LD_INT 1
72801: NEG
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: PUSH
72807: LD_INT 1
72809: NEG
72810: PUSH
72811: LD_INT 1
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72829: LD_ADDR_VAR 0 41
72833: PUSH
72834: LD_INT 0
72836: PUSH
72837: LD_INT 0
72839: PUSH
72840: EMPTY
72841: LIST
72842: LIST
72843: PUSH
72844: LD_INT 0
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: EMPTY
72852: LIST
72853: LIST
72854: PUSH
72855: LD_INT 1
72857: PUSH
72858: LD_INT 0
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 1
72867: PUSH
72868: LD_INT 1
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 0
72877: PUSH
72878: LD_INT 1
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 1
72887: NEG
72888: PUSH
72889: LD_INT 0
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 1
72898: NEG
72899: PUSH
72900: LD_INT 1
72902: NEG
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 1
72910: NEG
72911: PUSH
72912: LD_INT 2
72914: NEG
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: LD_INT 1
72922: PUSH
72923: LD_INT 1
72925: NEG
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 2
72933: PUSH
72934: LD_INT 0
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 2
72943: PUSH
72944: LD_INT 1
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 2
72953: PUSH
72954: LD_INT 2
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: LD_INT 2
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 1
72973: NEG
72974: PUSH
72975: LD_INT 1
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 2
72984: NEG
72985: PUSH
72986: LD_INT 0
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 2
72995: NEG
72996: PUSH
72997: LD_INT 1
72999: NEG
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PUSH
73005: LD_INT 2
73007: NEG
73008: PUSH
73009: LD_INT 2
73011: NEG
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: PUSH
73017: LD_INT 2
73019: NEG
73020: PUSH
73021: LD_INT 3
73023: NEG
73024: PUSH
73025: EMPTY
73026: LIST
73027: LIST
73028: PUSH
73029: LD_INT 2
73031: PUSH
73032: LD_INT 1
73034: NEG
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: LD_INT 3
73042: PUSH
73043: LD_INT 0
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 3
73052: PUSH
73053: LD_INT 1
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: LD_INT 3
73062: PUSH
73063: LD_INT 2
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_INT 3
73072: PUSH
73073: LD_INT 3
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: PUSH
73080: LD_INT 2
73082: PUSH
73083: LD_INT 3
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 2
73092: NEG
73093: PUSH
73094: LD_INT 1
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 3
73103: NEG
73104: PUSH
73105: LD_INT 0
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: PUSH
73112: LD_INT 3
73114: NEG
73115: PUSH
73116: LD_INT 1
73118: NEG
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 3
73126: NEG
73127: PUSH
73128: LD_INT 2
73130: NEG
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 3
73138: NEG
73139: PUSH
73140: LD_INT 3
73142: NEG
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: LIST
73155: LIST
73156: LIST
73157: LIST
73158: LIST
73159: LIST
73160: LIST
73161: LIST
73162: LIST
73163: LIST
73164: LIST
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: LIST
73170: LIST
73171: LIST
73172: LIST
73173: LIST
73174: LIST
73175: LIST
73176: LIST
73177: LIST
73178: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73179: LD_ADDR_VAR 0 42
73183: PUSH
73184: LD_INT 0
73186: PUSH
73187: LD_INT 0
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 0
73196: PUSH
73197: LD_INT 1
73199: NEG
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: PUSH
73205: LD_INT 1
73207: PUSH
73208: LD_INT 0
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 1
73217: PUSH
73218: LD_INT 1
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: PUSH
73225: LD_INT 0
73227: PUSH
73228: LD_INT 1
73230: PUSH
73231: EMPTY
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 1
73237: NEG
73238: PUSH
73239: LD_INT 0
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 1
73248: NEG
73249: PUSH
73250: LD_INT 1
73252: NEG
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 1
73260: NEG
73261: PUSH
73262: LD_INT 2
73264: NEG
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 0
73272: PUSH
73273: LD_INT 2
73275: NEG
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: LD_INT 1
73286: NEG
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PUSH
73292: LD_INT 2
73294: PUSH
73295: LD_INT 1
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 2
73304: PUSH
73305: LD_INT 2
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 1
73314: PUSH
73315: LD_INT 2
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 0
73324: PUSH
73325: LD_INT 2
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 1
73334: NEG
73335: PUSH
73336: LD_INT 1
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 2
73345: NEG
73346: PUSH
73347: LD_INT 1
73349: NEG
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 2
73357: NEG
73358: PUSH
73359: LD_INT 2
73361: NEG
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 2
73369: NEG
73370: PUSH
73371: LD_INT 3
73373: NEG
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: LD_INT 1
73381: NEG
73382: PUSH
73383: LD_INT 3
73385: NEG
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: LD_INT 0
73393: PUSH
73394: LD_INT 3
73396: NEG
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: PUSH
73402: LD_INT 1
73404: PUSH
73405: LD_INT 2
73407: NEG
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 3
73415: PUSH
73416: LD_INT 2
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 3
73425: PUSH
73426: LD_INT 3
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 2
73435: PUSH
73436: LD_INT 3
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 1
73445: PUSH
73446: LD_INT 3
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 0
73455: PUSH
73456: LD_INT 3
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: NEG
73466: PUSH
73467: LD_INT 2
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 3
73476: NEG
73477: PUSH
73478: LD_INT 2
73480: NEG
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 3
73488: NEG
73489: PUSH
73490: LD_INT 3
73492: NEG
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73529: LD_ADDR_VAR 0 43
73533: PUSH
73534: LD_INT 0
73536: PUSH
73537: LD_INT 0
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 0
73546: PUSH
73547: LD_INT 1
73549: NEG
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: LD_INT 1
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 1
73567: PUSH
73568: LD_INT 1
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: PUSH
73575: LD_INT 0
73577: PUSH
73578: LD_INT 1
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 1
73587: NEG
73588: PUSH
73589: LD_INT 0
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 1
73598: NEG
73599: PUSH
73600: LD_INT 1
73602: NEG
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 1
73610: NEG
73611: PUSH
73612: LD_INT 2
73614: NEG
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: PUSH
73620: LD_INT 0
73622: PUSH
73623: LD_INT 2
73625: NEG
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 1
73633: PUSH
73634: LD_INT 1
73636: NEG
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PUSH
73642: LD_INT 2
73644: PUSH
73645: LD_INT 0
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: LD_INT 2
73654: PUSH
73655: LD_INT 1
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: LD_INT 1
73664: PUSH
73665: LD_INT 2
73667: PUSH
73668: EMPTY
73669: LIST
73670: LIST
73671: PUSH
73672: LD_INT 0
73674: PUSH
73675: LD_INT 2
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: LD_INT 1
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 2
73695: NEG
73696: PUSH
73697: LD_INT 0
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: PUSH
73704: LD_INT 2
73706: NEG
73707: PUSH
73708: LD_INT 1
73710: NEG
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 1
73718: NEG
73719: PUSH
73720: LD_INT 3
73722: NEG
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 0
73730: PUSH
73731: LD_INT 3
73733: NEG
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 1
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 2
73752: PUSH
73753: LD_INT 1
73755: NEG
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 3
73763: PUSH
73764: LD_INT 0
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: LD_INT 3
73773: PUSH
73774: LD_INT 1
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: PUSH
73781: LD_INT 1
73783: PUSH
73784: LD_INT 3
73786: PUSH
73787: EMPTY
73788: LIST
73789: LIST
73790: PUSH
73791: LD_INT 0
73793: PUSH
73794: LD_INT 3
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 1
73803: NEG
73804: PUSH
73805: LD_INT 2
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 2
73814: NEG
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: PUSH
73823: LD_INT 3
73825: NEG
73826: PUSH
73827: LD_INT 0
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 3
73836: NEG
73837: PUSH
73838: LD_INT 1
73840: NEG
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: LIST
73854: LIST
73855: LIST
73856: LIST
73857: LIST
73858: LIST
73859: LIST
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73877: LD_ADDR_VAR 0 44
73881: PUSH
73882: LD_INT 0
73884: PUSH
73885: LD_INT 0
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PUSH
73903: LD_INT 1
73905: PUSH
73906: LD_INT 0
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 1
73915: PUSH
73916: LD_INT 1
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: LD_INT 1
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: LD_INT 0
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PUSH
73944: LD_INT 1
73946: NEG
73947: PUSH
73948: LD_INT 1
73950: NEG
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 1
73958: NEG
73959: PUSH
73960: LD_INT 2
73962: NEG
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 1
73970: PUSH
73971: LD_INT 1
73973: NEG
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: LD_INT 2
73981: PUSH
73982: LD_INT 0
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 2
73991: PUSH
73992: LD_INT 1
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 2
74001: PUSH
74002: LD_INT 2
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 1
74011: PUSH
74012: LD_INT 2
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 1
74021: NEG
74022: PUSH
74023: LD_INT 1
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: LD_INT 2
74032: NEG
74033: PUSH
74034: LD_INT 0
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 2
74043: NEG
74044: PUSH
74045: LD_INT 1
74047: NEG
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 2
74055: NEG
74056: PUSH
74057: LD_INT 2
74059: NEG
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: LD_INT 2
74067: NEG
74068: PUSH
74069: LD_INT 3
74071: NEG
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: LD_INT 2
74079: PUSH
74080: LD_INT 1
74082: NEG
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 3
74090: PUSH
74091: LD_INT 0
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 3
74100: PUSH
74101: LD_INT 1
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 3
74110: PUSH
74111: LD_INT 2
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 3
74120: PUSH
74121: LD_INT 3
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: LD_INT 2
74130: PUSH
74131: LD_INT 3
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 2
74140: NEG
74141: PUSH
74142: LD_INT 1
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 3
74151: NEG
74152: PUSH
74153: LD_INT 0
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 3
74162: NEG
74163: PUSH
74164: LD_INT 1
74166: NEG
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 3
74174: NEG
74175: PUSH
74176: LD_INT 2
74178: NEG
74179: PUSH
74180: EMPTY
74181: LIST
74182: LIST
74183: PUSH
74184: LD_INT 3
74186: NEG
74187: PUSH
74188: LD_INT 3
74190: NEG
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: LIST
74218: LIST
74219: LIST
74220: LIST
74221: LIST
74222: LIST
74223: LIST
74224: LIST
74225: LIST
74226: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74227: LD_ADDR_VAR 0 45
74231: PUSH
74232: LD_INT 0
74234: PUSH
74235: LD_INT 0
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: LD_INT 1
74247: NEG
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 1
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: PUSH
74266: LD_INT 1
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: LD_INT 1
74278: PUSH
74279: EMPTY
74280: LIST
74281: LIST
74282: PUSH
74283: LD_INT 1
74285: NEG
74286: PUSH
74287: LD_INT 0
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 1
74296: NEG
74297: PUSH
74298: LD_INT 1
74300: NEG
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 1
74308: NEG
74309: PUSH
74310: LD_INT 2
74312: NEG
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 0
74320: PUSH
74321: LD_INT 2
74323: NEG
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: LD_INT 1
74334: NEG
74335: PUSH
74336: EMPTY
74337: LIST
74338: LIST
74339: PUSH
74340: LD_INT 2
74342: PUSH
74343: LD_INT 1
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PUSH
74350: LD_INT 2
74352: PUSH
74353: LD_INT 2
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 1
74362: PUSH
74363: LD_INT 2
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: PUSH
74370: LD_INT 0
74372: PUSH
74373: LD_INT 2
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PUSH
74380: LD_INT 1
74382: NEG
74383: PUSH
74384: LD_INT 1
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: LD_INT 2
74393: NEG
74394: PUSH
74395: LD_INT 1
74397: NEG
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 2
74405: NEG
74406: PUSH
74407: LD_INT 2
74409: NEG
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 2
74417: NEG
74418: PUSH
74419: LD_INT 3
74421: NEG
74422: PUSH
74423: EMPTY
74424: LIST
74425: LIST
74426: PUSH
74427: LD_INT 1
74429: NEG
74430: PUSH
74431: LD_INT 3
74433: NEG
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: LD_INT 0
74441: PUSH
74442: LD_INT 3
74444: NEG
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: LD_INT 1
74452: PUSH
74453: LD_INT 2
74455: NEG
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 3
74463: PUSH
74464: LD_INT 2
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: LD_INT 3
74473: PUSH
74474: LD_INT 3
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 2
74483: PUSH
74484: LD_INT 3
74486: PUSH
74487: EMPTY
74488: LIST
74489: LIST
74490: PUSH
74491: LD_INT 1
74493: PUSH
74494: LD_INT 3
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PUSH
74501: LD_INT 0
74503: PUSH
74504: LD_INT 3
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 1
74513: NEG
74514: PUSH
74515: LD_INT 2
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 3
74524: NEG
74525: PUSH
74526: LD_INT 2
74528: NEG
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 3
74536: NEG
74537: PUSH
74538: LD_INT 3
74540: NEG
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: LIST
74550: LIST
74551: LIST
74552: LIST
74553: LIST
74554: LIST
74555: LIST
74556: LIST
74557: LIST
74558: LIST
74559: LIST
74560: LIST
74561: LIST
74562: LIST
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: LIST
74575: LIST
74576: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74577: LD_ADDR_VAR 0 46
74581: PUSH
74582: LD_INT 0
74584: PUSH
74585: LD_INT 0
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 0
74594: PUSH
74595: LD_INT 1
74597: NEG
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 1
74605: PUSH
74606: LD_INT 0
74608: PUSH
74609: EMPTY
74610: LIST
74611: LIST
74612: PUSH
74613: LD_INT 1
74615: PUSH
74616: LD_INT 1
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: LD_INT 0
74625: PUSH
74626: LD_INT 1
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: LD_INT 1
74635: NEG
74636: PUSH
74637: LD_INT 0
74639: PUSH
74640: EMPTY
74641: LIST
74642: LIST
74643: PUSH
74644: LD_INT 1
74646: NEG
74647: PUSH
74648: LD_INT 1
74650: NEG
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: PUSH
74656: LD_INT 1
74658: NEG
74659: PUSH
74660: LD_INT 2
74662: NEG
74663: PUSH
74664: EMPTY
74665: LIST
74666: LIST
74667: PUSH
74668: LD_INT 0
74670: PUSH
74671: LD_INT 2
74673: NEG
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: LD_INT 1
74681: PUSH
74682: LD_INT 1
74684: NEG
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 2
74692: PUSH
74693: LD_INT 0
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: LD_INT 2
74702: PUSH
74703: LD_INT 1
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 1
74712: PUSH
74713: LD_INT 2
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 0
74722: PUSH
74723: LD_INT 2
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 1
74732: NEG
74733: PUSH
74734: LD_INT 1
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: LD_INT 2
74743: NEG
74744: PUSH
74745: LD_INT 0
74747: PUSH
74748: EMPTY
74749: LIST
74750: LIST
74751: PUSH
74752: LD_INT 2
74754: NEG
74755: PUSH
74756: LD_INT 1
74758: NEG
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: PUSH
74764: LD_INT 1
74766: NEG
74767: PUSH
74768: LD_INT 3
74770: NEG
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 0
74778: PUSH
74779: LD_INT 3
74781: NEG
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: PUSH
74787: LD_INT 1
74789: PUSH
74790: LD_INT 2
74792: NEG
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: PUSH
74798: LD_INT 2
74800: PUSH
74801: LD_INT 1
74803: NEG
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PUSH
74809: LD_INT 3
74811: PUSH
74812: LD_INT 0
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 3
74821: PUSH
74822: LD_INT 1
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 1
74831: PUSH
74832: LD_INT 3
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 0
74841: PUSH
74842: LD_INT 3
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PUSH
74849: LD_INT 1
74851: NEG
74852: PUSH
74853: LD_INT 2
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: PUSH
74860: LD_INT 2
74862: NEG
74863: PUSH
74864: LD_INT 1
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 3
74873: NEG
74874: PUSH
74875: LD_INT 0
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 3
74884: NEG
74885: PUSH
74886: LD_INT 1
74888: NEG
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: LIST
74898: LIST
74899: LIST
74900: LIST
74901: LIST
74902: LIST
74903: LIST
74904: LIST
74905: LIST
74906: LIST
74907: LIST
74908: LIST
74909: LIST
74910: LIST
74911: LIST
74912: LIST
74913: LIST
74914: LIST
74915: LIST
74916: LIST
74917: LIST
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74925: LD_ADDR_VAR 0 47
74929: PUSH
74930: LD_INT 0
74932: PUSH
74933: LD_INT 0
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 0
74942: PUSH
74943: LD_INT 1
74945: NEG
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: PUSH
74951: LD_INT 1
74953: PUSH
74954: LD_INT 0
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 1
74963: PUSH
74964: LD_INT 1
74966: PUSH
74967: EMPTY
74968: LIST
74969: LIST
74970: PUSH
74971: LD_INT 0
74973: PUSH
74974: LD_INT 1
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: PUSH
74981: LD_INT 1
74983: NEG
74984: PUSH
74985: LD_INT 0
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: LD_INT 1
74994: NEG
74995: PUSH
74996: LD_INT 1
74998: NEG
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 1
75006: NEG
75007: PUSH
75008: LD_INT 2
75010: NEG
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 0
75018: PUSH
75019: LD_INT 2
75021: NEG
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: LD_INT 1
75029: PUSH
75030: LD_INT 1
75032: NEG
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: PUSH
75038: LD_INT 2
75040: NEG
75041: PUSH
75042: LD_INT 1
75044: NEG
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PUSH
75050: LD_INT 2
75052: NEG
75053: PUSH
75054: LD_INT 2
75056: NEG
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75076: LD_ADDR_VAR 0 48
75080: PUSH
75081: LD_INT 0
75083: PUSH
75084: LD_INT 0
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 0
75093: PUSH
75094: LD_INT 1
75096: NEG
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PUSH
75102: LD_INT 1
75104: PUSH
75105: LD_INT 0
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: PUSH
75112: LD_INT 1
75114: PUSH
75115: LD_INT 1
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: PUSH
75122: LD_INT 0
75124: PUSH
75125: LD_INT 1
75127: PUSH
75128: EMPTY
75129: LIST
75130: LIST
75131: PUSH
75132: LD_INT 1
75134: NEG
75135: PUSH
75136: LD_INT 0
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: PUSH
75143: LD_INT 1
75145: NEG
75146: PUSH
75147: LD_INT 1
75149: NEG
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_INT 1
75157: NEG
75158: PUSH
75159: LD_INT 2
75161: NEG
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 0
75169: PUSH
75170: LD_INT 2
75172: NEG
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 1
75180: PUSH
75181: LD_INT 1
75183: NEG
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 2
75191: PUSH
75192: LD_INT 0
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 2
75201: PUSH
75202: LD_INT 1
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: LIST
75217: LIST
75218: LIST
75219: LIST
75220: LIST
75221: LIST
75222: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75223: LD_ADDR_VAR 0 49
75227: PUSH
75228: LD_INT 0
75230: PUSH
75231: LD_INT 0
75233: PUSH
75234: EMPTY
75235: LIST
75236: LIST
75237: PUSH
75238: LD_INT 0
75240: PUSH
75241: LD_INT 1
75243: NEG
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 1
75251: PUSH
75252: LD_INT 0
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: PUSH
75259: LD_INT 1
75261: PUSH
75262: LD_INT 1
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: PUSH
75269: LD_INT 0
75271: PUSH
75272: LD_INT 1
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 1
75281: NEG
75282: PUSH
75283: LD_INT 0
75285: PUSH
75286: EMPTY
75287: LIST
75288: LIST
75289: PUSH
75290: LD_INT 1
75292: NEG
75293: PUSH
75294: LD_INT 1
75296: NEG
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 1
75304: PUSH
75305: LD_INT 1
75307: NEG
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 2
75315: PUSH
75316: LD_INT 0
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 2
75325: PUSH
75326: LD_INT 1
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 2
75335: PUSH
75336: LD_INT 2
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: PUSH
75343: LD_INT 1
75345: PUSH
75346: LD_INT 2
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: LIST
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75367: LD_ADDR_VAR 0 50
75371: PUSH
75372: LD_INT 0
75374: PUSH
75375: LD_INT 0
75377: PUSH
75378: EMPTY
75379: LIST
75380: LIST
75381: PUSH
75382: LD_INT 0
75384: PUSH
75385: LD_INT 1
75387: NEG
75388: PUSH
75389: EMPTY
75390: LIST
75391: LIST
75392: PUSH
75393: LD_INT 1
75395: PUSH
75396: LD_INT 0
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: LD_INT 1
75405: PUSH
75406: LD_INT 1
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PUSH
75413: LD_INT 0
75415: PUSH
75416: LD_INT 1
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 1
75425: NEG
75426: PUSH
75427: LD_INT 0
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PUSH
75434: LD_INT 1
75436: NEG
75437: PUSH
75438: LD_INT 1
75440: NEG
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 2
75448: PUSH
75449: LD_INT 1
75451: PUSH
75452: EMPTY
75453: LIST
75454: LIST
75455: PUSH
75456: LD_INT 2
75458: PUSH
75459: LD_INT 2
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 1
75468: PUSH
75469: LD_INT 2
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 0
75478: PUSH
75479: LD_INT 2
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 1
75488: NEG
75489: PUSH
75490: LD_INT 1
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: LIST
75506: LIST
75507: LIST
75508: LIST
75509: LIST
75510: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75511: LD_ADDR_VAR 0 51
75515: PUSH
75516: LD_INT 0
75518: PUSH
75519: LD_INT 0
75521: PUSH
75522: EMPTY
75523: LIST
75524: LIST
75525: PUSH
75526: LD_INT 0
75528: PUSH
75529: LD_INT 1
75531: NEG
75532: PUSH
75533: EMPTY
75534: LIST
75535: LIST
75536: PUSH
75537: LD_INT 1
75539: PUSH
75540: LD_INT 0
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: LD_INT 1
75549: PUSH
75550: LD_INT 1
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: LD_INT 0
75559: PUSH
75560: LD_INT 1
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 1
75569: NEG
75570: PUSH
75571: LD_INT 0
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: LD_INT 1
75580: NEG
75581: PUSH
75582: LD_INT 1
75584: NEG
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: PUSH
75590: LD_INT 1
75592: PUSH
75593: LD_INT 2
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 0
75602: PUSH
75603: LD_INT 2
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: LD_INT 1
75612: NEG
75613: PUSH
75614: LD_INT 1
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 2
75623: NEG
75624: PUSH
75625: LD_INT 0
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 2
75634: NEG
75635: PUSH
75636: LD_INT 1
75638: NEG
75639: PUSH
75640: EMPTY
75641: LIST
75642: LIST
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: LIST
75648: LIST
75649: LIST
75650: LIST
75651: LIST
75652: LIST
75653: LIST
75654: LIST
75655: LIST
75656: LIST
75657: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75658: LD_ADDR_VAR 0 52
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: LD_INT 0
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 0
75675: PUSH
75676: LD_INT 1
75678: NEG
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 1
75686: PUSH
75687: LD_INT 0
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 1
75696: PUSH
75697: LD_INT 1
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 0
75706: PUSH
75707: LD_INT 1
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 1
75716: NEG
75717: PUSH
75718: LD_INT 0
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 1
75727: NEG
75728: PUSH
75729: LD_INT 1
75731: NEG
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 1
75739: NEG
75740: PUSH
75741: LD_INT 2
75743: NEG
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 1
75751: NEG
75752: PUSH
75753: LD_INT 1
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 2
75762: NEG
75763: PUSH
75764: LD_INT 0
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: PUSH
75771: LD_INT 2
75773: NEG
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 2
75785: NEG
75786: PUSH
75787: LD_INT 2
75789: NEG
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: LIST
75801: LIST
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75809: LD_ADDR_VAR 0 53
75813: PUSH
75814: LD_INT 0
75816: PUSH
75817: LD_INT 0
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 0
75826: PUSH
75827: LD_INT 1
75829: NEG
75830: PUSH
75831: EMPTY
75832: LIST
75833: LIST
75834: PUSH
75835: LD_INT 1
75837: PUSH
75838: LD_INT 0
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 1
75847: PUSH
75848: LD_INT 1
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: LD_INT 0
75857: PUSH
75858: LD_INT 1
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 1
75867: NEG
75868: PUSH
75869: LD_INT 0
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 1
75878: NEG
75879: PUSH
75880: LD_INT 1
75882: NEG
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 1
75890: NEG
75891: PUSH
75892: LD_INT 2
75894: NEG
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 0
75902: PUSH
75903: LD_INT 2
75905: NEG
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 1
75913: PUSH
75914: LD_INT 1
75916: NEG
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 2
75924: PUSH
75925: LD_INT 0
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: PUSH
75932: LD_INT 2
75934: PUSH
75935: LD_INT 1
75937: PUSH
75938: EMPTY
75939: LIST
75940: LIST
75941: PUSH
75942: LD_INT 2
75944: PUSH
75945: LD_INT 2
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 1
75954: PUSH
75955: LD_INT 2
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: LD_INT 0
75964: PUSH
75965: LD_INT 2
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 1
75974: NEG
75975: PUSH
75976: LD_INT 1
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PUSH
75983: LD_INT 2
75985: NEG
75986: PUSH
75987: LD_INT 0
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: PUSH
75994: LD_INT 2
75996: NEG
75997: PUSH
75998: LD_INT 1
76000: NEG
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: LD_INT 2
76008: NEG
76009: PUSH
76010: LD_INT 2
76012: NEG
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: LIST
76026: LIST
76027: LIST
76028: LIST
76029: LIST
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: LIST
76037: LIST
76038: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76039: LD_ADDR_VAR 0 54
76043: PUSH
76044: LD_INT 0
76046: PUSH
76047: LD_INT 0
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 0
76056: PUSH
76057: LD_INT 1
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 1
76067: PUSH
76068: LD_INT 0
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PUSH
76075: LD_INT 1
76077: PUSH
76078: LD_INT 1
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 0
76087: PUSH
76088: LD_INT 1
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 1
76097: NEG
76098: PUSH
76099: LD_INT 0
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: LD_INT 1
76108: NEG
76109: PUSH
76110: LD_INT 1
76112: NEG
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 1
76120: NEG
76121: PUSH
76122: LD_INT 2
76124: NEG
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 0
76132: PUSH
76133: LD_INT 2
76135: NEG
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 1
76143: PUSH
76144: LD_INT 1
76146: NEG
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 2
76154: PUSH
76155: LD_INT 0
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: LD_INT 2
76164: PUSH
76165: LD_INT 1
76167: PUSH
76168: EMPTY
76169: LIST
76170: LIST
76171: PUSH
76172: LD_INT 2
76174: PUSH
76175: LD_INT 2
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 1
76184: PUSH
76185: LD_INT 2
76187: PUSH
76188: EMPTY
76189: LIST
76190: LIST
76191: PUSH
76192: LD_INT 0
76194: PUSH
76195: LD_INT 2
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 1
76204: NEG
76205: PUSH
76206: LD_INT 1
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 2
76215: NEG
76216: PUSH
76217: LD_INT 0
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 2
76226: NEG
76227: PUSH
76228: LD_INT 1
76230: NEG
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: LD_INT 2
76238: NEG
76239: PUSH
76240: LD_INT 2
76242: NEG
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: LIST
76266: LIST
76267: LIST
76268: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76269: LD_ADDR_VAR 0 55
76273: PUSH
76274: LD_INT 0
76276: PUSH
76277: LD_INT 0
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 0
76286: PUSH
76287: LD_INT 1
76289: NEG
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: LD_INT 1
76297: PUSH
76298: LD_INT 0
76300: PUSH
76301: EMPTY
76302: LIST
76303: LIST
76304: PUSH
76305: LD_INT 1
76307: PUSH
76308: LD_INT 1
76310: PUSH
76311: EMPTY
76312: LIST
76313: LIST
76314: PUSH
76315: LD_INT 0
76317: PUSH
76318: LD_INT 1
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: LD_INT 0
76331: PUSH
76332: EMPTY
76333: LIST
76334: LIST
76335: PUSH
76336: LD_INT 1
76338: NEG
76339: PUSH
76340: LD_INT 1
76342: NEG
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 1
76350: NEG
76351: PUSH
76352: LD_INT 2
76354: NEG
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: LD_INT 0
76362: PUSH
76363: LD_INT 2
76365: NEG
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: PUSH
76371: LD_INT 1
76373: PUSH
76374: LD_INT 1
76376: NEG
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: LD_INT 2
76384: PUSH
76385: LD_INT 0
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 2
76394: PUSH
76395: LD_INT 1
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PUSH
76402: LD_INT 2
76404: PUSH
76405: LD_INT 2
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 1
76414: PUSH
76415: LD_INT 2
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: PUSH
76422: LD_INT 0
76424: PUSH
76425: LD_INT 2
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: LD_INT 1
76434: NEG
76435: PUSH
76436: LD_INT 1
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 2
76445: NEG
76446: PUSH
76447: LD_INT 0
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: LD_INT 2
76456: NEG
76457: PUSH
76458: LD_INT 1
76460: NEG
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 2
76468: NEG
76469: PUSH
76470: LD_INT 2
76472: NEG
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: LIST
76482: LIST
76483: LIST
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76499: LD_ADDR_VAR 0 56
76503: PUSH
76504: LD_INT 0
76506: PUSH
76507: LD_INT 0
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: PUSH
76514: LD_INT 0
76516: PUSH
76517: LD_INT 1
76519: NEG
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: PUSH
76525: LD_INT 1
76527: PUSH
76528: LD_INT 0
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PUSH
76535: LD_INT 1
76537: PUSH
76538: LD_INT 1
76540: PUSH
76541: EMPTY
76542: LIST
76543: LIST
76544: PUSH
76545: LD_INT 0
76547: PUSH
76548: LD_INT 1
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: LD_INT 0
76561: PUSH
76562: EMPTY
76563: LIST
76564: LIST
76565: PUSH
76566: LD_INT 1
76568: NEG
76569: PUSH
76570: LD_INT 1
76572: NEG
76573: PUSH
76574: EMPTY
76575: LIST
76576: LIST
76577: PUSH
76578: LD_INT 1
76580: NEG
76581: PUSH
76582: LD_INT 2
76584: NEG
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 0
76592: PUSH
76593: LD_INT 2
76595: NEG
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 1
76603: PUSH
76604: LD_INT 1
76606: NEG
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: PUSH
76612: LD_INT 2
76614: PUSH
76615: LD_INT 0
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: PUSH
76622: LD_INT 2
76624: PUSH
76625: LD_INT 1
76627: PUSH
76628: EMPTY
76629: LIST
76630: LIST
76631: PUSH
76632: LD_INT 2
76634: PUSH
76635: LD_INT 2
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: PUSH
76642: LD_INT 1
76644: PUSH
76645: LD_INT 2
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PUSH
76652: LD_INT 0
76654: PUSH
76655: LD_INT 2
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 1
76664: NEG
76665: PUSH
76666: LD_INT 1
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 2
76675: NEG
76676: PUSH
76677: LD_INT 0
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 2
76686: NEG
76687: PUSH
76688: LD_INT 1
76690: NEG
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: PUSH
76696: LD_INT 2
76698: NEG
76699: PUSH
76700: LD_INT 2
76702: NEG
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: LIST
76721: LIST
76722: LIST
76723: LIST
76724: LIST
76725: LIST
76726: LIST
76727: LIST
76728: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76729: LD_ADDR_VAR 0 57
76733: PUSH
76734: LD_INT 0
76736: PUSH
76737: LD_INT 0
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 0
76746: PUSH
76747: LD_INT 1
76749: NEG
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PUSH
76755: LD_INT 1
76757: PUSH
76758: LD_INT 0
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: LD_INT 1
76767: PUSH
76768: LD_INT 1
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 0
76777: PUSH
76778: LD_INT 1
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 1
76787: NEG
76788: PUSH
76789: LD_INT 0
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 1
76798: NEG
76799: PUSH
76800: LD_INT 1
76802: NEG
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 1
76810: NEG
76811: PUSH
76812: LD_INT 2
76814: NEG
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 0
76822: PUSH
76823: LD_INT 2
76825: NEG
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PUSH
76831: LD_INT 1
76833: PUSH
76834: LD_INT 1
76836: NEG
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 2
76844: PUSH
76845: LD_INT 0
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 2
76854: PUSH
76855: LD_INT 1
76857: PUSH
76858: EMPTY
76859: LIST
76860: LIST
76861: PUSH
76862: LD_INT 2
76864: PUSH
76865: LD_INT 2
76867: PUSH
76868: EMPTY
76869: LIST
76870: LIST
76871: PUSH
76872: LD_INT 1
76874: PUSH
76875: LD_INT 2
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: PUSH
76882: LD_INT 0
76884: PUSH
76885: LD_INT 2
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 1
76894: NEG
76895: PUSH
76896: LD_INT 1
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 2
76905: NEG
76906: PUSH
76907: LD_INT 0
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: LD_INT 2
76916: NEG
76917: PUSH
76918: LD_INT 1
76920: NEG
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: LD_INT 2
76928: NEG
76929: PUSH
76930: LD_INT 2
76932: NEG
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: LIST
76942: LIST
76943: LIST
76944: LIST
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: LIST
76952: LIST
76953: LIST
76954: LIST
76955: LIST
76956: LIST
76957: LIST
76958: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76959: LD_ADDR_VAR 0 58
76963: PUSH
76964: LD_INT 0
76966: PUSH
76967: LD_INT 0
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: PUSH
76974: LD_INT 0
76976: PUSH
76977: LD_INT 1
76979: NEG
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: PUSH
76985: LD_INT 1
76987: PUSH
76988: LD_INT 0
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: PUSH
76995: LD_INT 1
76997: PUSH
76998: LD_INT 1
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: PUSH
77005: LD_INT 0
77007: PUSH
77008: LD_INT 1
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 1
77017: NEG
77018: PUSH
77019: LD_INT 0
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 1
77028: NEG
77029: PUSH
77030: LD_INT 1
77032: NEG
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 1
77040: NEG
77041: PUSH
77042: LD_INT 2
77044: NEG
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 0
77052: PUSH
77053: LD_INT 2
77055: NEG
77056: PUSH
77057: EMPTY
77058: LIST
77059: LIST
77060: PUSH
77061: LD_INT 1
77063: PUSH
77064: LD_INT 1
77066: NEG
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: LD_INT 2
77074: PUSH
77075: LD_INT 0
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: PUSH
77082: LD_INT 2
77084: PUSH
77085: LD_INT 1
77087: PUSH
77088: EMPTY
77089: LIST
77090: LIST
77091: PUSH
77092: LD_INT 2
77094: PUSH
77095: LD_INT 2
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: PUSH
77102: LD_INT 1
77104: PUSH
77105: LD_INT 2
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: PUSH
77112: LD_INT 0
77114: PUSH
77115: LD_INT 2
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 1
77124: NEG
77125: PUSH
77126: LD_INT 1
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 2
77135: NEG
77136: PUSH
77137: LD_INT 0
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 2
77146: NEG
77147: PUSH
77148: LD_INT 1
77150: NEG
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: PUSH
77156: LD_INT 2
77158: NEG
77159: PUSH
77160: LD_INT 2
77162: NEG
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: EMPTY
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: LIST
77174: LIST
77175: LIST
77176: LIST
77177: LIST
77178: LIST
77179: LIST
77180: LIST
77181: LIST
77182: LIST
77183: LIST
77184: LIST
77185: LIST
77186: LIST
77187: LIST
77188: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77189: LD_ADDR_VAR 0 59
77193: PUSH
77194: LD_INT 0
77196: PUSH
77197: LD_INT 0
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 0
77206: PUSH
77207: LD_INT 1
77209: NEG
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 1
77217: PUSH
77218: LD_INT 0
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 1
77227: PUSH
77228: LD_INT 1
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 0
77237: PUSH
77238: LD_INT 1
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: LD_INT 0
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 1
77258: NEG
77259: PUSH
77260: LD_INT 1
77262: NEG
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77277: LD_ADDR_VAR 0 60
77281: PUSH
77282: LD_INT 0
77284: PUSH
77285: LD_INT 0
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 0
77294: PUSH
77295: LD_INT 1
77297: NEG
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 1
77305: PUSH
77306: LD_INT 0
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: PUSH
77313: LD_INT 1
77315: PUSH
77316: LD_INT 1
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PUSH
77323: LD_INT 0
77325: PUSH
77326: LD_INT 1
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: PUSH
77333: LD_INT 1
77335: NEG
77336: PUSH
77337: LD_INT 0
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 1
77346: NEG
77347: PUSH
77348: LD_INT 1
77350: NEG
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: LIST
77360: LIST
77361: LIST
77362: LIST
77363: LIST
77364: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77365: LD_ADDR_VAR 0 61
77369: PUSH
77370: LD_INT 0
77372: PUSH
77373: LD_INT 0
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 0
77382: PUSH
77383: LD_INT 1
77385: NEG
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: LD_INT 1
77393: PUSH
77394: LD_INT 0
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 1
77403: PUSH
77404: LD_INT 1
77406: PUSH
77407: EMPTY
77408: LIST
77409: LIST
77410: PUSH
77411: LD_INT 0
77413: PUSH
77414: LD_INT 1
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: LD_INT 1
77423: NEG
77424: PUSH
77425: LD_INT 0
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 1
77434: NEG
77435: PUSH
77436: LD_INT 1
77438: NEG
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: LIST
77448: LIST
77449: LIST
77450: LIST
77451: LIST
77452: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77453: LD_ADDR_VAR 0 62
77457: PUSH
77458: LD_INT 0
77460: PUSH
77461: LD_INT 0
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: LD_INT 0
77470: PUSH
77471: LD_INT 1
77473: NEG
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 1
77481: PUSH
77482: LD_INT 0
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 1
77491: PUSH
77492: LD_INT 1
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 0
77501: PUSH
77502: LD_INT 1
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 1
77511: NEG
77512: PUSH
77513: LD_INT 0
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: PUSH
77520: LD_INT 1
77522: NEG
77523: PUSH
77524: LD_INT 1
77526: NEG
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: LIST
77536: LIST
77537: LIST
77538: LIST
77539: LIST
77540: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77541: LD_ADDR_VAR 0 63
77545: PUSH
77546: LD_INT 0
77548: PUSH
77549: LD_INT 0
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: LD_INT 1
77561: NEG
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 1
77569: PUSH
77570: LD_INT 0
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 1
77579: PUSH
77580: LD_INT 1
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 0
77589: PUSH
77590: LD_INT 1
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PUSH
77597: LD_INT 1
77599: NEG
77600: PUSH
77601: LD_INT 0
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: LD_INT 1
77610: NEG
77611: PUSH
77612: LD_INT 1
77614: NEG
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77629: LD_ADDR_VAR 0 64
77633: PUSH
77634: LD_INT 0
77636: PUSH
77637: LD_INT 0
77639: PUSH
77640: EMPTY
77641: LIST
77642: LIST
77643: PUSH
77644: LD_INT 0
77646: PUSH
77647: LD_INT 1
77649: NEG
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: LD_INT 1
77657: PUSH
77658: LD_INT 0
77660: PUSH
77661: EMPTY
77662: LIST
77663: LIST
77664: PUSH
77665: LD_INT 1
77667: PUSH
77668: LD_INT 1
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 0
77677: PUSH
77678: LD_INT 1
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 1
77687: NEG
77688: PUSH
77689: LD_INT 0
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: PUSH
77696: LD_INT 1
77698: NEG
77699: PUSH
77700: LD_INT 1
77702: NEG
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: ST_TO_ADDR
// end ; 1 :
77717: GO 83614
77719: LD_INT 1
77721: DOUBLE
77722: EQUAL
77723: IFTRUE 77727
77725: GO 80350
77727: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77728: LD_ADDR_VAR 0 11
77732: PUSH
77733: LD_INT 1
77735: NEG
77736: PUSH
77737: LD_INT 3
77739: NEG
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: LD_INT 3
77750: NEG
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 1
77758: PUSH
77759: LD_INT 2
77761: NEG
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: LIST
77771: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77772: LD_ADDR_VAR 0 12
77776: PUSH
77777: LD_INT 2
77779: PUSH
77780: LD_INT 1
77782: NEG
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: PUSH
77788: LD_INT 3
77790: PUSH
77791: LD_INT 0
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: LD_INT 3
77800: PUSH
77801: LD_INT 1
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: LIST
77812: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77813: LD_ADDR_VAR 0 13
77817: PUSH
77818: LD_INT 3
77820: PUSH
77821: LD_INT 2
77823: PUSH
77824: EMPTY
77825: LIST
77826: LIST
77827: PUSH
77828: LD_INT 3
77830: PUSH
77831: LD_INT 3
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 2
77840: PUSH
77841: LD_INT 3
77843: PUSH
77844: EMPTY
77845: LIST
77846: LIST
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: LIST
77852: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77853: LD_ADDR_VAR 0 14
77857: PUSH
77858: LD_INT 1
77860: PUSH
77861: LD_INT 3
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: LD_INT 0
77870: PUSH
77871: LD_INT 3
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 1
77880: NEG
77881: PUSH
77882: LD_INT 2
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: LIST
77893: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77894: LD_ADDR_VAR 0 15
77898: PUSH
77899: LD_INT 2
77901: NEG
77902: PUSH
77903: LD_INT 1
77905: PUSH
77906: EMPTY
77907: LIST
77908: LIST
77909: PUSH
77910: LD_INT 3
77912: NEG
77913: PUSH
77914: LD_INT 0
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 3
77923: NEG
77924: PUSH
77925: LD_INT 1
77927: NEG
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: EMPTY
77934: LIST
77935: LIST
77936: LIST
77937: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77938: LD_ADDR_VAR 0 16
77942: PUSH
77943: LD_INT 2
77945: NEG
77946: PUSH
77947: LD_INT 3
77949: NEG
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 3
77957: NEG
77958: PUSH
77959: LD_INT 2
77961: NEG
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: PUSH
77967: LD_INT 3
77969: NEG
77970: PUSH
77971: LD_INT 3
77973: NEG
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: LIST
77983: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77984: LD_ADDR_VAR 0 17
77988: PUSH
77989: LD_INT 1
77991: NEG
77992: PUSH
77993: LD_INT 3
77995: NEG
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 0
78003: PUSH
78004: LD_INT 3
78006: NEG
78007: PUSH
78008: EMPTY
78009: LIST
78010: LIST
78011: PUSH
78012: LD_INT 1
78014: PUSH
78015: LD_INT 2
78017: NEG
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: LIST
78027: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78028: LD_ADDR_VAR 0 18
78032: PUSH
78033: LD_INT 2
78035: PUSH
78036: LD_INT 1
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 3
78046: PUSH
78047: LD_INT 0
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: PUSH
78054: LD_INT 3
78056: PUSH
78057: LD_INT 1
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: LIST
78068: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78069: LD_ADDR_VAR 0 19
78073: PUSH
78074: LD_INT 3
78076: PUSH
78077: LD_INT 2
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: LD_INT 3
78086: PUSH
78087: LD_INT 3
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 2
78096: PUSH
78097: LD_INT 3
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: LIST
78108: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78109: LD_ADDR_VAR 0 20
78113: PUSH
78114: LD_INT 1
78116: PUSH
78117: LD_INT 3
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 0
78126: PUSH
78127: LD_INT 3
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 1
78136: NEG
78137: PUSH
78138: LD_INT 2
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: LIST
78149: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78150: LD_ADDR_VAR 0 21
78154: PUSH
78155: LD_INT 2
78157: NEG
78158: PUSH
78159: LD_INT 1
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 3
78168: NEG
78169: PUSH
78170: LD_INT 0
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 3
78179: NEG
78180: PUSH
78181: LD_INT 1
78183: NEG
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: LIST
78193: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78194: LD_ADDR_VAR 0 22
78198: PUSH
78199: LD_INT 2
78201: NEG
78202: PUSH
78203: LD_INT 3
78205: NEG
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 3
78213: NEG
78214: PUSH
78215: LD_INT 2
78217: NEG
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PUSH
78223: LD_INT 3
78225: NEG
78226: PUSH
78227: LD_INT 3
78229: NEG
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: LIST
78239: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78240: LD_ADDR_VAR 0 23
78244: PUSH
78245: LD_INT 0
78247: PUSH
78248: LD_INT 3
78250: NEG
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 1
78258: NEG
78259: PUSH
78260: LD_INT 4
78262: NEG
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 1
78270: PUSH
78271: LD_INT 3
78273: NEG
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: LIST
78283: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78284: LD_ADDR_VAR 0 24
78288: PUSH
78289: LD_INT 3
78291: PUSH
78292: LD_INT 0
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: PUSH
78299: LD_INT 3
78301: PUSH
78302: LD_INT 1
78304: NEG
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: LD_INT 4
78312: PUSH
78313: LD_INT 1
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: LIST
78324: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78325: LD_ADDR_VAR 0 25
78329: PUSH
78330: LD_INT 3
78332: PUSH
78333: LD_INT 3
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 4
78342: PUSH
78343: LD_INT 3
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 3
78352: PUSH
78353: LD_INT 4
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: LIST
78364: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78365: LD_ADDR_VAR 0 26
78369: PUSH
78370: LD_INT 0
78372: PUSH
78373: LD_INT 3
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: PUSH
78380: LD_INT 1
78382: PUSH
78383: LD_INT 4
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 1
78392: NEG
78393: PUSH
78394: LD_INT 3
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: LIST
78405: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78406: LD_ADDR_VAR 0 27
78410: PUSH
78411: LD_INT 3
78413: NEG
78414: PUSH
78415: LD_INT 0
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 3
78424: NEG
78425: PUSH
78426: LD_INT 1
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 4
78435: NEG
78436: PUSH
78437: LD_INT 1
78439: NEG
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: LIST
78449: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78450: LD_ADDR_VAR 0 28
78454: PUSH
78455: LD_INT 3
78457: NEG
78458: PUSH
78459: LD_INT 3
78461: NEG
78462: PUSH
78463: EMPTY
78464: LIST
78465: LIST
78466: PUSH
78467: LD_INT 3
78469: NEG
78470: PUSH
78471: LD_INT 4
78473: NEG
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PUSH
78479: LD_INT 4
78481: NEG
78482: PUSH
78483: LD_INT 3
78485: NEG
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: LIST
78495: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78496: LD_ADDR_VAR 0 29
78500: PUSH
78501: LD_INT 1
78503: NEG
78504: PUSH
78505: LD_INT 3
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 0
78515: PUSH
78516: LD_INT 3
78518: NEG
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: PUSH
78524: LD_INT 1
78526: PUSH
78527: LD_INT 2
78529: NEG
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: PUSH
78535: LD_INT 1
78537: NEG
78538: PUSH
78539: LD_INT 4
78541: NEG
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 0
78549: PUSH
78550: LD_INT 4
78552: NEG
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 1
78560: PUSH
78561: LD_INT 3
78563: NEG
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: LD_INT 1
78571: NEG
78572: PUSH
78573: LD_INT 5
78575: NEG
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: LD_INT 0
78583: PUSH
78584: LD_INT 5
78586: NEG
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 1
78594: PUSH
78595: LD_INT 4
78597: NEG
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 1
78605: NEG
78606: PUSH
78607: LD_INT 6
78609: NEG
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 0
78617: PUSH
78618: LD_INT 6
78620: NEG
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 1
78628: PUSH
78629: LD_INT 5
78631: NEG
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: LIST
78641: LIST
78642: LIST
78643: LIST
78644: LIST
78645: LIST
78646: LIST
78647: LIST
78648: LIST
78649: LIST
78650: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78651: LD_ADDR_VAR 0 30
78655: PUSH
78656: LD_INT 2
78658: PUSH
78659: LD_INT 1
78661: NEG
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 3
78669: PUSH
78670: LD_INT 0
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PUSH
78677: LD_INT 3
78679: PUSH
78680: LD_INT 1
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 3
78689: PUSH
78690: LD_INT 1
78692: NEG
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 4
78700: PUSH
78701: LD_INT 0
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 4
78710: PUSH
78711: LD_INT 1
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 4
78720: PUSH
78721: LD_INT 1
78723: NEG
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 5
78731: PUSH
78732: LD_INT 0
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 5
78741: PUSH
78742: LD_INT 1
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 5
78751: PUSH
78752: LD_INT 1
78754: NEG
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 6
78762: PUSH
78763: LD_INT 0
78765: PUSH
78766: EMPTY
78767: LIST
78768: LIST
78769: PUSH
78770: LD_INT 6
78772: PUSH
78773: LD_INT 1
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78794: LD_ADDR_VAR 0 31
78798: PUSH
78799: LD_INT 3
78801: PUSH
78802: LD_INT 2
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 3
78811: PUSH
78812: LD_INT 3
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: LD_INT 2
78821: PUSH
78822: LD_INT 3
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 4
78831: PUSH
78832: LD_INT 3
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 4
78841: PUSH
78842: LD_INT 4
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 3
78851: PUSH
78852: LD_INT 4
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 5
78861: PUSH
78862: LD_INT 4
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 5
78871: PUSH
78872: LD_INT 5
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 4
78881: PUSH
78882: LD_INT 5
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 6
78891: PUSH
78892: LD_INT 5
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 6
78901: PUSH
78902: LD_INT 6
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 5
78911: PUSH
78912: LD_INT 6
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78933: LD_ADDR_VAR 0 32
78937: PUSH
78938: LD_INT 1
78940: PUSH
78941: LD_INT 3
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: LD_INT 0
78950: PUSH
78951: LD_INT 3
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 1
78960: NEG
78961: PUSH
78962: LD_INT 2
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 1
78971: PUSH
78972: LD_INT 4
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PUSH
78979: LD_INT 0
78981: PUSH
78982: LD_INT 4
78984: PUSH
78985: EMPTY
78986: LIST
78987: LIST
78988: PUSH
78989: LD_INT 1
78991: NEG
78992: PUSH
78993: LD_INT 3
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 1
79002: PUSH
79003: LD_INT 5
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 0
79012: PUSH
79013: LD_INT 5
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 1
79022: NEG
79023: PUSH
79024: LD_INT 4
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: LD_INT 6
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 0
79043: PUSH
79044: LD_INT 6
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 1
79053: NEG
79054: PUSH
79055: LD_INT 5
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79076: LD_ADDR_VAR 0 33
79080: PUSH
79081: LD_INT 2
79083: NEG
79084: PUSH
79085: LD_INT 1
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 3
79094: NEG
79095: PUSH
79096: LD_INT 0
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 3
79105: NEG
79106: PUSH
79107: LD_INT 1
79109: NEG
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 3
79117: NEG
79118: PUSH
79119: LD_INT 1
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 4
79128: NEG
79129: PUSH
79130: LD_INT 0
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 4
79139: NEG
79140: PUSH
79141: LD_INT 1
79143: NEG
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 4
79151: NEG
79152: PUSH
79153: LD_INT 1
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 5
79162: NEG
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 5
79173: NEG
79174: PUSH
79175: LD_INT 1
79177: NEG
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 5
79185: NEG
79186: PUSH
79187: LD_INT 1
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 6
79196: NEG
79197: PUSH
79198: LD_INT 0
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: LD_INT 6
79207: NEG
79208: PUSH
79209: LD_INT 1
79211: NEG
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79231: LD_ADDR_VAR 0 34
79235: PUSH
79236: LD_INT 2
79238: NEG
79239: PUSH
79240: LD_INT 3
79242: NEG
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 3
79250: NEG
79251: PUSH
79252: LD_INT 2
79254: NEG
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 3
79262: NEG
79263: PUSH
79264: LD_INT 3
79266: NEG
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 3
79274: NEG
79275: PUSH
79276: LD_INT 4
79278: NEG
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 4
79286: NEG
79287: PUSH
79288: LD_INT 3
79290: NEG
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: LD_INT 4
79298: NEG
79299: PUSH
79300: LD_INT 4
79302: NEG
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PUSH
79308: LD_INT 4
79310: NEG
79311: PUSH
79312: LD_INT 5
79314: NEG
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 5
79322: NEG
79323: PUSH
79324: LD_INT 4
79326: NEG
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: PUSH
79332: LD_INT 5
79334: NEG
79335: PUSH
79336: LD_INT 5
79338: NEG
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 5
79346: NEG
79347: PUSH
79348: LD_INT 6
79350: NEG
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 6
79358: NEG
79359: PUSH
79360: LD_INT 5
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 6
79370: NEG
79371: PUSH
79372: LD_INT 6
79374: NEG
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79394: LD_ADDR_VAR 0 41
79398: PUSH
79399: LD_INT 0
79401: PUSH
79402: LD_INT 2
79404: NEG
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: PUSH
79410: LD_INT 1
79412: NEG
79413: PUSH
79414: LD_INT 3
79416: NEG
79417: PUSH
79418: EMPTY
79419: LIST
79420: LIST
79421: PUSH
79422: LD_INT 1
79424: PUSH
79425: LD_INT 2
79427: NEG
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: LIST
79437: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79438: LD_ADDR_VAR 0 42
79442: PUSH
79443: LD_INT 2
79445: PUSH
79446: LD_INT 0
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 2
79455: PUSH
79456: LD_INT 1
79458: NEG
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: PUSH
79464: LD_INT 3
79466: PUSH
79467: LD_INT 1
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: LIST
79478: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79479: LD_ADDR_VAR 0 43
79483: PUSH
79484: LD_INT 2
79486: PUSH
79487: LD_INT 2
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 3
79496: PUSH
79497: LD_INT 2
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 2
79506: PUSH
79507: LD_INT 3
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: LIST
79518: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79519: LD_ADDR_VAR 0 44
79523: PUSH
79524: LD_INT 0
79526: PUSH
79527: LD_INT 2
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 1
79536: PUSH
79537: LD_INT 3
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 1
79546: NEG
79547: PUSH
79548: LD_INT 2
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: LIST
79559: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79560: LD_ADDR_VAR 0 45
79564: PUSH
79565: LD_INT 2
79567: NEG
79568: PUSH
79569: LD_INT 0
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 2
79578: NEG
79579: PUSH
79580: LD_INT 1
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 3
79589: NEG
79590: PUSH
79591: LD_INT 1
79593: NEG
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79604: LD_ADDR_VAR 0 46
79608: PUSH
79609: LD_INT 2
79611: NEG
79612: PUSH
79613: LD_INT 2
79615: NEG
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 2
79623: NEG
79624: PUSH
79625: LD_INT 3
79627: NEG
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: PUSH
79633: LD_INT 3
79635: NEG
79636: PUSH
79637: LD_INT 2
79639: NEG
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: LIST
79649: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79650: LD_ADDR_VAR 0 47
79654: PUSH
79655: LD_INT 2
79657: NEG
79658: PUSH
79659: LD_INT 3
79661: NEG
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 1
79669: NEG
79670: PUSH
79671: LD_INT 3
79673: NEG
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79683: LD_ADDR_VAR 0 48
79687: PUSH
79688: LD_INT 1
79690: PUSH
79691: LD_INT 2
79693: NEG
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 2
79701: PUSH
79702: LD_INT 1
79704: NEG
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79714: LD_ADDR_VAR 0 49
79718: PUSH
79719: LD_INT 3
79721: PUSH
79722: LD_INT 1
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 3
79731: PUSH
79732: LD_INT 2
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79743: LD_ADDR_VAR 0 50
79747: PUSH
79748: LD_INT 2
79750: PUSH
79751: LD_INT 3
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 1
79760: PUSH
79761: LD_INT 3
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79772: LD_ADDR_VAR 0 51
79776: PUSH
79777: LD_INT 1
79779: NEG
79780: PUSH
79781: LD_INT 2
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 2
79790: NEG
79791: PUSH
79792: LD_INT 1
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79803: LD_ADDR_VAR 0 52
79807: PUSH
79808: LD_INT 3
79810: NEG
79811: PUSH
79812: LD_INT 1
79814: NEG
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 3
79822: NEG
79823: PUSH
79824: LD_INT 2
79826: NEG
79827: PUSH
79828: EMPTY
79829: LIST
79830: LIST
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79836: LD_ADDR_VAR 0 53
79840: PUSH
79841: LD_INT 1
79843: NEG
79844: PUSH
79845: LD_INT 3
79847: NEG
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 0
79855: PUSH
79856: LD_INT 3
79858: NEG
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 1
79866: PUSH
79867: LD_INT 2
79869: NEG
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: LIST
79879: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79880: LD_ADDR_VAR 0 54
79884: PUSH
79885: LD_INT 2
79887: PUSH
79888: LD_INT 1
79890: NEG
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 3
79898: PUSH
79899: LD_INT 0
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 3
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: LIST
79920: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79921: LD_ADDR_VAR 0 55
79925: PUSH
79926: LD_INT 3
79928: PUSH
79929: LD_INT 2
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 3
79938: PUSH
79939: LD_INT 3
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 2
79948: PUSH
79949: LD_INT 3
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: LIST
79960: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79961: LD_ADDR_VAR 0 56
79965: PUSH
79966: LD_INT 1
79968: PUSH
79969: LD_INT 3
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: LD_INT 0
79978: PUSH
79979: LD_INT 3
79981: PUSH
79982: EMPTY
79983: LIST
79984: LIST
79985: PUSH
79986: LD_INT 1
79988: NEG
79989: PUSH
79990: LD_INT 2
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: LIST
80001: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80002: LD_ADDR_VAR 0 57
80006: PUSH
80007: LD_INT 2
80009: NEG
80010: PUSH
80011: LD_INT 1
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 3
80020: NEG
80021: PUSH
80022: LD_INT 0
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 3
80031: NEG
80032: PUSH
80033: LD_INT 1
80035: NEG
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: LIST
80045: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80046: LD_ADDR_VAR 0 58
80050: PUSH
80051: LD_INT 2
80053: NEG
80054: PUSH
80055: LD_INT 3
80057: NEG
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 3
80065: NEG
80066: PUSH
80067: LD_INT 2
80069: NEG
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 3
80077: NEG
80078: PUSH
80079: LD_INT 3
80081: NEG
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: LIST
80091: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80092: LD_ADDR_VAR 0 59
80096: PUSH
80097: LD_INT 1
80099: NEG
80100: PUSH
80101: LD_INT 2
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 0
80111: PUSH
80112: LD_INT 2
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 1
80122: PUSH
80123: LD_INT 1
80125: NEG
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: LIST
80135: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80136: LD_ADDR_VAR 0 60
80140: PUSH
80141: LD_INT 1
80143: PUSH
80144: LD_INT 1
80146: NEG
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 2
80154: PUSH
80155: LD_INT 0
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 2
80164: PUSH
80165: LD_INT 1
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: LIST
80176: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80177: LD_ADDR_VAR 0 61
80181: PUSH
80182: LD_INT 2
80184: PUSH
80185: LD_INT 1
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 2
80194: PUSH
80195: LD_INT 2
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 1
80204: PUSH
80205: LD_INT 2
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: LIST
80216: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80217: LD_ADDR_VAR 0 62
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: LD_INT 2
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 0
80234: PUSH
80235: LD_INT 2
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 1
80244: NEG
80245: PUSH
80246: LD_INT 1
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: LIST
80257: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80258: LD_ADDR_VAR 0 63
80262: PUSH
80263: LD_INT 1
80265: NEG
80266: PUSH
80267: LD_INT 1
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 2
80276: NEG
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 2
80287: NEG
80288: PUSH
80289: LD_INT 1
80291: NEG
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: LIST
80301: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80302: LD_ADDR_VAR 0 64
80306: PUSH
80307: LD_INT 1
80309: NEG
80310: PUSH
80311: LD_INT 2
80313: NEG
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 2
80321: NEG
80322: PUSH
80323: LD_INT 1
80325: NEG
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: LD_INT 2
80333: NEG
80334: PUSH
80335: LD_INT 2
80337: NEG
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: LIST
80347: ST_TO_ADDR
// end ; 2 :
80348: GO 83614
80350: LD_INT 2
80352: DOUBLE
80353: EQUAL
80354: IFTRUE 80358
80356: GO 83613
80358: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80359: LD_ADDR_VAR 0 29
80363: PUSH
80364: LD_INT 4
80366: PUSH
80367: LD_INT 0
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 4
80376: PUSH
80377: LD_INT 1
80379: NEG
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 5
80387: PUSH
80388: LD_INT 0
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 5
80397: PUSH
80398: LD_INT 1
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 4
80407: PUSH
80408: LD_INT 1
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 3
80417: PUSH
80418: LD_INT 0
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 3
80427: PUSH
80428: LD_INT 1
80430: NEG
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 3
80438: PUSH
80439: LD_INT 2
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 5
80449: PUSH
80450: LD_INT 2
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 3
80459: PUSH
80460: LD_INT 3
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 3
80469: PUSH
80470: LD_INT 2
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 4
80479: PUSH
80480: LD_INT 3
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 4
80489: PUSH
80490: LD_INT 4
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 3
80499: PUSH
80500: LD_INT 4
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PUSH
80507: LD_INT 2
80509: PUSH
80510: LD_INT 3
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 2
80519: PUSH
80520: LD_INT 2
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: LD_INT 4
80529: PUSH
80530: LD_INT 2
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 2
80539: PUSH
80540: LD_INT 4
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 0
80549: PUSH
80550: LD_INT 4
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: LD_INT 3
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: PUSH
80567: LD_INT 1
80569: PUSH
80570: LD_INT 4
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 1
80579: PUSH
80580: LD_INT 5
80582: PUSH
80583: EMPTY
80584: LIST
80585: LIST
80586: PUSH
80587: LD_INT 0
80589: PUSH
80590: LD_INT 5
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: PUSH
80597: LD_INT 1
80599: NEG
80600: PUSH
80601: LD_INT 4
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 1
80610: NEG
80611: PUSH
80612: LD_INT 3
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 2
80621: PUSH
80622: LD_INT 5
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: LD_INT 2
80631: NEG
80632: PUSH
80633: LD_INT 3
80635: PUSH
80636: EMPTY
80637: LIST
80638: LIST
80639: PUSH
80640: LD_INT 3
80642: NEG
80643: PUSH
80644: LD_INT 0
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: PUSH
80651: LD_INT 3
80653: NEG
80654: PUSH
80655: LD_INT 1
80657: NEG
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PUSH
80663: LD_INT 2
80665: NEG
80666: PUSH
80667: LD_INT 0
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 2
80676: NEG
80677: PUSH
80678: LD_INT 1
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 3
80687: NEG
80688: PUSH
80689: LD_INT 1
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 4
80698: NEG
80699: PUSH
80700: LD_INT 0
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 4
80709: NEG
80710: PUSH
80711: LD_INT 1
80713: NEG
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PUSH
80719: LD_INT 4
80721: NEG
80722: PUSH
80723: LD_INT 2
80725: NEG
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 2
80733: NEG
80734: PUSH
80735: LD_INT 2
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 4
80744: NEG
80745: PUSH
80746: LD_INT 4
80748: NEG
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 4
80756: NEG
80757: PUSH
80758: LD_INT 5
80760: NEG
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 3
80768: NEG
80769: PUSH
80770: LD_INT 4
80772: NEG
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 3
80780: NEG
80781: PUSH
80782: LD_INT 3
80784: NEG
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 4
80792: NEG
80793: PUSH
80794: LD_INT 3
80796: NEG
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 5
80804: NEG
80805: PUSH
80806: LD_INT 4
80808: NEG
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: PUSH
80814: LD_INT 5
80816: NEG
80817: PUSH
80818: LD_INT 5
80820: NEG
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 3
80828: NEG
80829: PUSH
80830: LD_INT 5
80832: NEG
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 5
80840: NEG
80841: PUSH
80842: LD_INT 3
80844: NEG
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: LIST
80858: LIST
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: LIST
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: LIST
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: LIST
80890: LIST
80891: LIST
80892: LIST
80893: LIST
80894: LIST
80895: LIST
80896: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80897: LD_ADDR_VAR 0 30
80901: PUSH
80902: LD_INT 4
80904: PUSH
80905: LD_INT 4
80907: PUSH
80908: EMPTY
80909: LIST
80910: LIST
80911: PUSH
80912: LD_INT 4
80914: PUSH
80915: LD_INT 3
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 5
80924: PUSH
80925: LD_INT 4
80927: PUSH
80928: EMPTY
80929: LIST
80930: LIST
80931: PUSH
80932: LD_INT 5
80934: PUSH
80935: LD_INT 5
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 4
80944: PUSH
80945: LD_INT 5
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PUSH
80952: LD_INT 3
80954: PUSH
80955: LD_INT 4
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: LD_INT 3
80964: PUSH
80965: LD_INT 3
80967: PUSH
80968: EMPTY
80969: LIST
80970: LIST
80971: PUSH
80972: LD_INT 5
80974: PUSH
80975: LD_INT 3
80977: PUSH
80978: EMPTY
80979: LIST
80980: LIST
80981: PUSH
80982: LD_INT 3
80984: PUSH
80985: LD_INT 5
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 0
80994: PUSH
80995: LD_INT 3
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 0
81004: PUSH
81005: LD_INT 2
81007: PUSH
81008: EMPTY
81009: LIST
81010: LIST
81011: PUSH
81012: LD_INT 1
81014: PUSH
81015: LD_INT 3
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 1
81024: PUSH
81025: LD_INT 4
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 0
81034: PUSH
81035: LD_INT 4
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 1
81044: NEG
81045: PUSH
81046: LD_INT 3
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 1
81055: NEG
81056: PUSH
81057: LD_INT 2
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: LD_INT 2
81066: PUSH
81067: LD_INT 4
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: PUSH
81074: LD_INT 2
81076: NEG
81077: PUSH
81078: LD_INT 2
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 4
81087: NEG
81088: PUSH
81089: LD_INT 0
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 4
81098: NEG
81099: PUSH
81100: LD_INT 1
81102: NEG
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PUSH
81108: LD_INT 3
81110: NEG
81111: PUSH
81112: LD_INT 0
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PUSH
81119: LD_INT 3
81121: NEG
81122: PUSH
81123: LD_INT 1
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 4
81132: NEG
81133: PUSH
81134: LD_INT 1
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 5
81143: NEG
81144: PUSH
81145: LD_INT 0
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PUSH
81152: LD_INT 5
81154: NEG
81155: PUSH
81156: LD_INT 1
81158: NEG
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: LD_INT 5
81166: NEG
81167: PUSH
81168: LD_INT 2
81170: NEG
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PUSH
81176: LD_INT 3
81178: NEG
81179: PUSH
81180: LD_INT 2
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 3
81189: NEG
81190: PUSH
81191: LD_INT 3
81193: NEG
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PUSH
81199: LD_INT 3
81201: NEG
81202: PUSH
81203: LD_INT 4
81205: NEG
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: LD_INT 2
81213: NEG
81214: PUSH
81215: LD_INT 3
81217: NEG
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: PUSH
81223: LD_INT 2
81225: NEG
81226: PUSH
81227: LD_INT 2
81229: NEG
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 3
81237: NEG
81238: PUSH
81239: LD_INT 2
81241: NEG
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 4
81249: NEG
81250: PUSH
81251: LD_INT 3
81253: NEG
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 4
81261: NEG
81262: PUSH
81263: LD_INT 4
81265: NEG
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: PUSH
81271: LD_INT 2
81273: NEG
81274: PUSH
81275: LD_INT 4
81277: NEG
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 4
81285: NEG
81286: PUSH
81287: LD_INT 2
81289: NEG
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 0
81297: PUSH
81298: LD_INT 4
81300: NEG
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 0
81308: PUSH
81309: LD_INT 5
81311: NEG
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 1
81319: PUSH
81320: LD_INT 4
81322: NEG
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 1
81330: PUSH
81331: LD_INT 3
81333: NEG
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: LD_INT 0
81341: PUSH
81342: LD_INT 3
81344: NEG
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: LD_INT 1
81352: NEG
81353: PUSH
81354: LD_INT 4
81356: NEG
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 1
81364: NEG
81365: PUSH
81366: LD_INT 5
81368: NEG
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PUSH
81374: LD_INT 2
81376: PUSH
81377: LD_INT 3
81379: NEG
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 2
81387: NEG
81388: PUSH
81389: LD_INT 5
81391: NEG
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: LIST
81401: LIST
81402: LIST
81403: LIST
81404: LIST
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: LIST
81426: LIST
81427: LIST
81428: LIST
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81444: LD_ADDR_VAR 0 31
81448: PUSH
81449: LD_INT 0
81451: PUSH
81452: LD_INT 4
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 0
81461: PUSH
81462: LD_INT 3
81464: PUSH
81465: EMPTY
81466: LIST
81467: LIST
81468: PUSH
81469: LD_INT 1
81471: PUSH
81472: LD_INT 4
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 1
81481: PUSH
81482: LD_INT 5
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 0
81491: PUSH
81492: LD_INT 5
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 1
81501: NEG
81502: PUSH
81503: LD_INT 4
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 1
81512: NEG
81513: PUSH
81514: LD_INT 3
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 2
81523: PUSH
81524: LD_INT 5
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 2
81533: NEG
81534: PUSH
81535: LD_INT 3
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 3
81544: NEG
81545: PUSH
81546: LD_INT 0
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 3
81555: NEG
81556: PUSH
81557: LD_INT 1
81559: NEG
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 2
81567: NEG
81568: PUSH
81569: LD_INT 0
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: PUSH
81576: LD_INT 2
81578: NEG
81579: PUSH
81580: LD_INT 1
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 3
81589: NEG
81590: PUSH
81591: LD_INT 1
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 4
81600: NEG
81601: PUSH
81602: LD_INT 0
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: PUSH
81609: LD_INT 4
81611: NEG
81612: PUSH
81613: LD_INT 1
81615: NEG
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 4
81623: NEG
81624: PUSH
81625: LD_INT 2
81627: NEG
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 2
81635: NEG
81636: PUSH
81637: LD_INT 2
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 4
81646: NEG
81647: PUSH
81648: LD_INT 4
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: LD_INT 4
81658: NEG
81659: PUSH
81660: LD_INT 5
81662: NEG
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 3
81670: NEG
81671: PUSH
81672: LD_INT 4
81674: NEG
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: LD_INT 3
81682: NEG
81683: PUSH
81684: LD_INT 3
81686: NEG
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 4
81694: NEG
81695: PUSH
81696: LD_INT 3
81698: NEG
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 5
81706: NEG
81707: PUSH
81708: LD_INT 4
81710: NEG
81711: PUSH
81712: EMPTY
81713: LIST
81714: LIST
81715: PUSH
81716: LD_INT 5
81718: NEG
81719: PUSH
81720: LD_INT 5
81722: NEG
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 3
81730: NEG
81731: PUSH
81732: LD_INT 5
81734: NEG
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 5
81742: NEG
81743: PUSH
81744: LD_INT 3
81746: NEG
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 0
81754: PUSH
81755: LD_INT 3
81757: NEG
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: LD_INT 0
81765: PUSH
81766: LD_INT 4
81768: NEG
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 1
81776: PUSH
81777: LD_INT 3
81779: NEG
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: LD_INT 2
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 0
81798: PUSH
81799: LD_INT 2
81801: NEG
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 1
81809: NEG
81810: PUSH
81811: LD_INT 3
81813: NEG
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: LD_INT 1
81821: NEG
81822: PUSH
81823: LD_INT 4
81825: NEG
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 2
81833: PUSH
81834: LD_INT 2
81836: NEG
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 2
81844: NEG
81845: PUSH
81846: LD_INT 4
81848: NEG
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 4
81856: PUSH
81857: LD_INT 0
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: LD_INT 4
81866: PUSH
81867: LD_INT 1
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 5
81877: PUSH
81878: LD_INT 0
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 5
81887: PUSH
81888: LD_INT 1
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 4
81897: PUSH
81898: LD_INT 1
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 3
81907: PUSH
81908: LD_INT 0
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 3
81917: PUSH
81918: LD_INT 1
81920: NEG
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 3
81928: PUSH
81929: LD_INT 2
81931: NEG
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 5
81939: PUSH
81940: LD_INT 2
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81994: LD_ADDR_VAR 0 32
81998: PUSH
81999: LD_INT 4
82001: NEG
82002: PUSH
82003: LD_INT 0
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 4
82012: NEG
82013: PUSH
82014: LD_INT 1
82016: NEG
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 3
82024: NEG
82025: PUSH
82026: LD_INT 0
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 3
82035: NEG
82036: PUSH
82037: LD_INT 1
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 4
82046: NEG
82047: PUSH
82048: LD_INT 1
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 5
82057: NEG
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: EMPTY
82063: LIST
82064: LIST
82065: PUSH
82066: LD_INT 5
82068: NEG
82069: PUSH
82070: LD_INT 1
82072: NEG
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 5
82080: NEG
82081: PUSH
82082: LD_INT 2
82084: NEG
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: LD_INT 3
82092: NEG
82093: PUSH
82094: LD_INT 2
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 3
82103: NEG
82104: PUSH
82105: LD_INT 3
82107: NEG
82108: PUSH
82109: EMPTY
82110: LIST
82111: LIST
82112: PUSH
82113: LD_INT 3
82115: NEG
82116: PUSH
82117: LD_INT 4
82119: NEG
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 2
82127: NEG
82128: PUSH
82129: LD_INT 3
82131: NEG
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 2
82139: NEG
82140: PUSH
82141: LD_INT 2
82143: NEG
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 3
82151: NEG
82152: PUSH
82153: LD_INT 2
82155: NEG
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 4
82163: NEG
82164: PUSH
82165: LD_INT 3
82167: NEG
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: LD_INT 4
82175: NEG
82176: PUSH
82177: LD_INT 4
82179: NEG
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 2
82187: NEG
82188: PUSH
82189: LD_INT 4
82191: NEG
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PUSH
82197: LD_INT 4
82199: NEG
82200: PUSH
82201: LD_INT 2
82203: NEG
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 0
82211: PUSH
82212: LD_INT 4
82214: NEG
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 0
82222: PUSH
82223: LD_INT 5
82225: NEG
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: LD_INT 1
82233: PUSH
82234: LD_INT 4
82236: NEG
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 1
82244: PUSH
82245: LD_INT 3
82247: NEG
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 0
82255: PUSH
82256: LD_INT 3
82258: NEG
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PUSH
82264: LD_INT 1
82266: NEG
82267: PUSH
82268: LD_INT 4
82270: NEG
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: LD_INT 1
82278: NEG
82279: PUSH
82280: LD_INT 5
82282: NEG
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 2
82290: PUSH
82291: LD_INT 3
82293: NEG
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 2
82301: NEG
82302: PUSH
82303: LD_INT 5
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 3
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 3
82323: PUSH
82324: LD_INT 1
82326: NEG
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 4
82334: PUSH
82335: LD_INT 0
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 4
82344: PUSH
82345: LD_INT 1
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 3
82354: PUSH
82355: LD_INT 1
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 2
82364: PUSH
82365: LD_INT 0
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 2
82374: PUSH
82375: LD_INT 1
82377: NEG
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 2
82385: PUSH
82386: LD_INT 2
82388: NEG
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 4
82396: PUSH
82397: LD_INT 2
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 4
82406: PUSH
82407: LD_INT 4
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 4
82416: PUSH
82417: LD_INT 3
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 5
82426: PUSH
82427: LD_INT 4
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 5
82436: PUSH
82437: LD_INT 5
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 4
82446: PUSH
82447: LD_INT 5
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 3
82456: PUSH
82457: LD_INT 4
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 3
82466: PUSH
82467: LD_INT 3
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 5
82476: PUSH
82477: LD_INT 3
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 3
82486: PUSH
82487: LD_INT 5
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: LIST
82506: LIST
82507: LIST
82508: LIST
82509: LIST
82510: LIST
82511: LIST
82512: LIST
82513: LIST
82514: LIST
82515: LIST
82516: LIST
82517: LIST
82518: LIST
82519: LIST
82520: LIST
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82541: LD_ADDR_VAR 0 33
82545: PUSH
82546: LD_INT 4
82548: NEG
82549: PUSH
82550: LD_INT 4
82552: NEG
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 4
82560: NEG
82561: PUSH
82562: LD_INT 5
82564: NEG
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 3
82572: NEG
82573: PUSH
82574: LD_INT 4
82576: NEG
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 3
82584: NEG
82585: PUSH
82586: LD_INT 3
82588: NEG
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_INT 4
82596: NEG
82597: PUSH
82598: LD_INT 3
82600: NEG
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 5
82608: NEG
82609: PUSH
82610: LD_INT 4
82612: NEG
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 5
82620: NEG
82621: PUSH
82622: LD_INT 5
82624: NEG
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 3
82632: NEG
82633: PUSH
82634: LD_INT 5
82636: NEG
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 5
82644: NEG
82645: PUSH
82646: LD_INT 3
82648: NEG
82649: PUSH
82650: EMPTY
82651: LIST
82652: LIST
82653: PUSH
82654: LD_INT 0
82656: PUSH
82657: LD_INT 3
82659: NEG
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 0
82667: PUSH
82668: LD_INT 4
82670: NEG
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PUSH
82676: LD_INT 1
82678: PUSH
82679: LD_INT 3
82681: NEG
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 1
82689: PUSH
82690: LD_INT 2
82692: NEG
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 0
82700: PUSH
82701: LD_INT 2
82703: NEG
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 1
82711: NEG
82712: PUSH
82713: LD_INT 3
82715: NEG
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 1
82723: NEG
82724: PUSH
82725: LD_INT 4
82727: NEG
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 2
82735: PUSH
82736: LD_INT 2
82738: NEG
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 2
82746: NEG
82747: PUSH
82748: LD_INT 4
82750: NEG
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 4
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 4
82768: PUSH
82769: LD_INT 1
82771: NEG
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 5
82779: PUSH
82780: LD_INT 0
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 5
82789: PUSH
82790: LD_INT 1
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 4
82799: PUSH
82800: LD_INT 1
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PUSH
82807: LD_INT 3
82809: PUSH
82810: LD_INT 0
82812: PUSH
82813: EMPTY
82814: LIST
82815: LIST
82816: PUSH
82817: LD_INT 3
82819: PUSH
82820: LD_INT 1
82822: NEG
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: LD_INT 3
82830: PUSH
82831: LD_INT 2
82833: NEG
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 5
82841: PUSH
82842: LD_INT 2
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 3
82851: PUSH
82852: LD_INT 3
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 3
82861: PUSH
82862: LD_INT 2
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 4
82871: PUSH
82872: LD_INT 3
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 4
82881: PUSH
82882: LD_INT 4
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 3
82891: PUSH
82892: LD_INT 4
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 2
82901: PUSH
82902: LD_INT 3
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 2
82911: PUSH
82912: LD_INT 2
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 4
82921: PUSH
82922: LD_INT 2
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 2
82931: PUSH
82932: LD_INT 4
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 0
82941: PUSH
82942: LD_INT 4
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 0
82951: PUSH
82952: LD_INT 3
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: LD_INT 1
82961: PUSH
82962: LD_INT 4
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 1
82971: PUSH
82972: LD_INT 5
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 0
82981: PUSH
82982: LD_INT 5
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 1
82991: NEG
82992: PUSH
82993: LD_INT 4
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 1
83002: NEG
83003: PUSH
83004: LD_INT 3
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_INT 2
83013: PUSH
83014: LD_INT 5
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 2
83023: NEG
83024: PUSH
83025: LD_INT 3
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: LIST
83036: LIST
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83079: LD_ADDR_VAR 0 34
83083: PUSH
83084: LD_INT 0
83086: PUSH
83087: LD_INT 4
83089: NEG
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 0
83097: PUSH
83098: LD_INT 5
83100: NEG
83101: PUSH
83102: EMPTY
83103: LIST
83104: LIST
83105: PUSH
83106: LD_INT 1
83108: PUSH
83109: LD_INT 4
83111: NEG
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 1
83119: PUSH
83120: LD_INT 3
83122: NEG
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 0
83130: PUSH
83131: LD_INT 3
83133: NEG
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 1
83141: NEG
83142: PUSH
83143: LD_INT 4
83145: NEG
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 1
83153: NEG
83154: PUSH
83155: LD_INT 5
83157: NEG
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 2
83165: PUSH
83166: LD_INT 3
83168: NEG
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 2
83176: NEG
83177: PUSH
83178: LD_INT 5
83180: NEG
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PUSH
83186: LD_INT 3
83188: PUSH
83189: LD_INT 0
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 3
83198: PUSH
83199: LD_INT 1
83201: NEG
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 4
83209: PUSH
83210: LD_INT 0
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 4
83219: PUSH
83220: LD_INT 1
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 3
83229: PUSH
83230: LD_INT 1
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 2
83239: PUSH
83240: LD_INT 0
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 2
83249: PUSH
83250: LD_INT 1
83252: NEG
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PUSH
83258: LD_INT 2
83260: PUSH
83261: LD_INT 2
83263: NEG
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: PUSH
83269: LD_INT 4
83271: PUSH
83272: LD_INT 2
83274: PUSH
83275: EMPTY
83276: LIST
83277: LIST
83278: PUSH
83279: LD_INT 4
83281: PUSH
83282: LD_INT 4
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 4
83291: PUSH
83292: LD_INT 3
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 5
83301: PUSH
83302: LD_INT 4
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 5
83311: PUSH
83312: LD_INT 5
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 4
83321: PUSH
83322: LD_INT 5
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 3
83331: PUSH
83332: LD_INT 4
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: LD_INT 3
83341: PUSH
83342: LD_INT 3
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 5
83351: PUSH
83352: LD_INT 3
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PUSH
83359: LD_INT 3
83361: PUSH
83362: LD_INT 5
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PUSH
83369: LD_INT 0
83371: PUSH
83372: LD_INT 3
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 0
83381: PUSH
83382: LD_INT 2
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: LD_INT 1
83391: PUSH
83392: LD_INT 3
83394: PUSH
83395: EMPTY
83396: LIST
83397: LIST
83398: PUSH
83399: LD_INT 1
83401: PUSH
83402: LD_INT 4
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: LD_INT 0
83411: PUSH
83412: LD_INT 4
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 1
83421: NEG
83422: PUSH
83423: LD_INT 3
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 1
83432: NEG
83433: PUSH
83434: LD_INT 2
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: PUSH
83441: LD_INT 2
83443: PUSH
83444: LD_INT 4
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 2
83453: NEG
83454: PUSH
83455: LD_INT 2
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 4
83464: NEG
83465: PUSH
83466: LD_INT 0
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 4
83475: NEG
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 3
83487: NEG
83488: PUSH
83489: LD_INT 0
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 3
83498: NEG
83499: PUSH
83500: LD_INT 1
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 4
83509: NEG
83510: PUSH
83511: LD_INT 1
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: LD_INT 5
83520: NEG
83521: PUSH
83522: LD_INT 0
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 5
83531: NEG
83532: PUSH
83533: LD_INT 1
83535: NEG
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 5
83543: NEG
83544: PUSH
83545: LD_INT 2
83547: NEG
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 3
83555: NEG
83556: PUSH
83557: LD_INT 2
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: LIST
83590: LIST
83591: LIST
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: ST_TO_ADDR
// end ; end ;
83611: GO 83614
83613: POP
// case btype of b_depot , b_warehouse :
83614: LD_VAR 0 1
83618: PUSH
83619: LD_INT 0
83621: DOUBLE
83622: EQUAL
83623: IFTRUE 83633
83625: LD_INT 1
83627: DOUBLE
83628: EQUAL
83629: IFTRUE 83633
83631: GO 83834
83633: POP
// case nation of nation_american :
83634: LD_VAR 0 5
83638: PUSH
83639: LD_INT 1
83641: DOUBLE
83642: EQUAL
83643: IFTRUE 83647
83645: GO 83703
83647: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83648: LD_ADDR_VAR 0 9
83652: PUSH
83653: LD_VAR 0 11
83657: PUSH
83658: LD_VAR 0 12
83662: PUSH
83663: LD_VAR 0 13
83667: PUSH
83668: LD_VAR 0 14
83672: PUSH
83673: LD_VAR 0 15
83677: PUSH
83678: LD_VAR 0 16
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: LIST
83687: LIST
83688: LIST
83689: LIST
83690: PUSH
83691: LD_VAR 0 4
83695: PUSH
83696: LD_INT 1
83698: PLUS
83699: ARRAY
83700: ST_TO_ADDR
83701: GO 83832
83703: LD_INT 2
83705: DOUBLE
83706: EQUAL
83707: IFTRUE 83711
83709: GO 83767
83711: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83712: LD_ADDR_VAR 0 9
83716: PUSH
83717: LD_VAR 0 17
83721: PUSH
83722: LD_VAR 0 18
83726: PUSH
83727: LD_VAR 0 19
83731: PUSH
83732: LD_VAR 0 20
83736: PUSH
83737: LD_VAR 0 21
83741: PUSH
83742: LD_VAR 0 22
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: PUSH
83755: LD_VAR 0 4
83759: PUSH
83760: LD_INT 1
83762: PLUS
83763: ARRAY
83764: ST_TO_ADDR
83765: GO 83832
83767: LD_INT 3
83769: DOUBLE
83770: EQUAL
83771: IFTRUE 83775
83773: GO 83831
83775: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83776: LD_ADDR_VAR 0 9
83780: PUSH
83781: LD_VAR 0 23
83785: PUSH
83786: LD_VAR 0 24
83790: PUSH
83791: LD_VAR 0 25
83795: PUSH
83796: LD_VAR 0 26
83800: PUSH
83801: LD_VAR 0 27
83805: PUSH
83806: LD_VAR 0 28
83810: PUSH
83811: EMPTY
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: PUSH
83819: LD_VAR 0 4
83823: PUSH
83824: LD_INT 1
83826: PLUS
83827: ARRAY
83828: ST_TO_ADDR
83829: GO 83832
83831: POP
83832: GO 84387
83834: LD_INT 2
83836: DOUBLE
83837: EQUAL
83838: IFTRUE 83848
83840: LD_INT 3
83842: DOUBLE
83843: EQUAL
83844: IFTRUE 83848
83846: GO 83904
83848: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83849: LD_ADDR_VAR 0 9
83853: PUSH
83854: LD_VAR 0 29
83858: PUSH
83859: LD_VAR 0 30
83863: PUSH
83864: LD_VAR 0 31
83868: PUSH
83869: LD_VAR 0 32
83873: PUSH
83874: LD_VAR 0 33
83878: PUSH
83879: LD_VAR 0 34
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: PUSH
83892: LD_VAR 0 4
83896: PUSH
83897: LD_INT 1
83899: PLUS
83900: ARRAY
83901: ST_TO_ADDR
83902: GO 84387
83904: LD_INT 16
83906: DOUBLE
83907: EQUAL
83908: IFTRUE 83966
83910: LD_INT 17
83912: DOUBLE
83913: EQUAL
83914: IFTRUE 83966
83916: LD_INT 18
83918: DOUBLE
83919: EQUAL
83920: IFTRUE 83966
83922: LD_INT 19
83924: DOUBLE
83925: EQUAL
83926: IFTRUE 83966
83928: LD_INT 22
83930: DOUBLE
83931: EQUAL
83932: IFTRUE 83966
83934: LD_INT 20
83936: DOUBLE
83937: EQUAL
83938: IFTRUE 83966
83940: LD_INT 21
83942: DOUBLE
83943: EQUAL
83944: IFTRUE 83966
83946: LD_INT 23
83948: DOUBLE
83949: EQUAL
83950: IFTRUE 83966
83952: LD_INT 24
83954: DOUBLE
83955: EQUAL
83956: IFTRUE 83966
83958: LD_INT 25
83960: DOUBLE
83961: EQUAL
83962: IFTRUE 83966
83964: GO 84022
83966: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83967: LD_ADDR_VAR 0 9
83971: PUSH
83972: LD_VAR 0 35
83976: PUSH
83977: LD_VAR 0 36
83981: PUSH
83982: LD_VAR 0 37
83986: PUSH
83987: LD_VAR 0 38
83991: PUSH
83992: LD_VAR 0 39
83996: PUSH
83997: LD_VAR 0 40
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: PUSH
84010: LD_VAR 0 4
84014: PUSH
84015: LD_INT 1
84017: PLUS
84018: ARRAY
84019: ST_TO_ADDR
84020: GO 84387
84022: LD_INT 6
84024: DOUBLE
84025: EQUAL
84026: IFTRUE 84078
84028: LD_INT 7
84030: DOUBLE
84031: EQUAL
84032: IFTRUE 84078
84034: LD_INT 8
84036: DOUBLE
84037: EQUAL
84038: IFTRUE 84078
84040: LD_INT 13
84042: DOUBLE
84043: EQUAL
84044: IFTRUE 84078
84046: LD_INT 12
84048: DOUBLE
84049: EQUAL
84050: IFTRUE 84078
84052: LD_INT 15
84054: DOUBLE
84055: EQUAL
84056: IFTRUE 84078
84058: LD_INT 11
84060: DOUBLE
84061: EQUAL
84062: IFTRUE 84078
84064: LD_INT 14
84066: DOUBLE
84067: EQUAL
84068: IFTRUE 84078
84070: LD_INT 10
84072: DOUBLE
84073: EQUAL
84074: IFTRUE 84078
84076: GO 84134
84078: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84079: LD_ADDR_VAR 0 9
84083: PUSH
84084: LD_VAR 0 41
84088: PUSH
84089: LD_VAR 0 42
84093: PUSH
84094: LD_VAR 0 43
84098: PUSH
84099: LD_VAR 0 44
84103: PUSH
84104: LD_VAR 0 45
84108: PUSH
84109: LD_VAR 0 46
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: LIST
84121: PUSH
84122: LD_VAR 0 4
84126: PUSH
84127: LD_INT 1
84129: PLUS
84130: ARRAY
84131: ST_TO_ADDR
84132: GO 84387
84134: LD_INT 36
84136: DOUBLE
84137: EQUAL
84138: IFTRUE 84142
84140: GO 84198
84142: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84143: LD_ADDR_VAR 0 9
84147: PUSH
84148: LD_VAR 0 47
84152: PUSH
84153: LD_VAR 0 48
84157: PUSH
84158: LD_VAR 0 49
84162: PUSH
84163: LD_VAR 0 50
84167: PUSH
84168: LD_VAR 0 51
84172: PUSH
84173: LD_VAR 0 52
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: LIST
84182: LIST
84183: LIST
84184: LIST
84185: PUSH
84186: LD_VAR 0 4
84190: PUSH
84191: LD_INT 1
84193: PLUS
84194: ARRAY
84195: ST_TO_ADDR
84196: GO 84387
84198: LD_INT 4
84200: DOUBLE
84201: EQUAL
84202: IFTRUE 84224
84204: LD_INT 5
84206: DOUBLE
84207: EQUAL
84208: IFTRUE 84224
84210: LD_INT 34
84212: DOUBLE
84213: EQUAL
84214: IFTRUE 84224
84216: LD_INT 37
84218: DOUBLE
84219: EQUAL
84220: IFTRUE 84224
84222: GO 84280
84224: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84225: LD_ADDR_VAR 0 9
84229: PUSH
84230: LD_VAR 0 53
84234: PUSH
84235: LD_VAR 0 54
84239: PUSH
84240: LD_VAR 0 55
84244: PUSH
84245: LD_VAR 0 56
84249: PUSH
84250: LD_VAR 0 57
84254: PUSH
84255: LD_VAR 0 58
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: LIST
84264: LIST
84265: LIST
84266: LIST
84267: PUSH
84268: LD_VAR 0 4
84272: PUSH
84273: LD_INT 1
84275: PLUS
84276: ARRAY
84277: ST_TO_ADDR
84278: GO 84387
84280: LD_INT 31
84282: DOUBLE
84283: EQUAL
84284: IFTRUE 84330
84286: LD_INT 32
84288: DOUBLE
84289: EQUAL
84290: IFTRUE 84330
84292: LD_INT 33
84294: DOUBLE
84295: EQUAL
84296: IFTRUE 84330
84298: LD_INT 27
84300: DOUBLE
84301: EQUAL
84302: IFTRUE 84330
84304: LD_INT 26
84306: DOUBLE
84307: EQUAL
84308: IFTRUE 84330
84310: LD_INT 28
84312: DOUBLE
84313: EQUAL
84314: IFTRUE 84330
84316: LD_INT 29
84318: DOUBLE
84319: EQUAL
84320: IFTRUE 84330
84322: LD_INT 30
84324: DOUBLE
84325: EQUAL
84326: IFTRUE 84330
84328: GO 84386
84330: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84331: LD_ADDR_VAR 0 9
84335: PUSH
84336: LD_VAR 0 59
84340: PUSH
84341: LD_VAR 0 60
84345: PUSH
84346: LD_VAR 0 61
84350: PUSH
84351: LD_VAR 0 62
84355: PUSH
84356: LD_VAR 0 63
84360: PUSH
84361: LD_VAR 0 64
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: PUSH
84374: LD_VAR 0 4
84378: PUSH
84379: LD_INT 1
84381: PLUS
84382: ARRAY
84383: ST_TO_ADDR
84384: GO 84387
84386: POP
// temp_list2 = [ ] ;
84387: LD_ADDR_VAR 0 10
84391: PUSH
84392: EMPTY
84393: ST_TO_ADDR
// for i in temp_list do
84394: LD_ADDR_VAR 0 8
84398: PUSH
84399: LD_VAR 0 9
84403: PUSH
84404: FOR_IN
84405: IFFALSE 84457
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84407: LD_ADDR_VAR 0 10
84411: PUSH
84412: LD_VAR 0 10
84416: PUSH
84417: LD_VAR 0 8
84421: PUSH
84422: LD_INT 1
84424: ARRAY
84425: PUSH
84426: LD_VAR 0 2
84430: PLUS
84431: PUSH
84432: LD_VAR 0 8
84436: PUSH
84437: LD_INT 2
84439: ARRAY
84440: PUSH
84441: LD_VAR 0 3
84445: PLUS
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: EMPTY
84452: LIST
84453: ADD
84454: ST_TO_ADDR
84455: GO 84404
84457: POP
84458: POP
// result = temp_list2 ;
84459: LD_ADDR_VAR 0 7
84463: PUSH
84464: LD_VAR 0 10
84468: ST_TO_ADDR
// end ;
84469: LD_VAR 0 7
84473: RET
// export function EnemyInRange ( unit , dist ) ; begin
84474: LD_INT 0
84476: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84477: LD_ADDR_VAR 0 3
84481: PUSH
84482: LD_VAR 0 1
84486: PPUSH
84487: CALL_OW 255
84491: PPUSH
84492: LD_VAR 0 1
84496: PPUSH
84497: CALL_OW 250
84501: PPUSH
84502: LD_VAR 0 1
84506: PPUSH
84507: CALL_OW 251
84511: PPUSH
84512: LD_VAR 0 2
84516: PPUSH
84517: CALL 57870 0 4
84521: PUSH
84522: LD_INT 4
84524: ARRAY
84525: ST_TO_ADDR
// end ;
84526: LD_VAR 0 3
84530: RET
// export function PlayerSeeMe ( unit ) ; begin
84531: LD_INT 0
84533: PPUSH
// result := See ( your_side , unit ) ;
84534: LD_ADDR_VAR 0 2
84538: PUSH
84539: LD_OWVAR 2
84543: PPUSH
84544: LD_VAR 0 1
84548: PPUSH
84549: CALL_OW 292
84553: ST_TO_ADDR
// end ;
84554: LD_VAR 0 2
84558: RET
// export function ReverseDir ( unit ) ; begin
84559: LD_INT 0
84561: PPUSH
// if not unit then
84562: LD_VAR 0 1
84566: NOT
84567: IFFALSE 84571
// exit ;
84569: GO 84594
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84571: LD_ADDR_VAR 0 2
84575: PUSH
84576: LD_VAR 0 1
84580: PPUSH
84581: CALL_OW 254
84585: PUSH
84586: LD_INT 3
84588: PLUS
84589: PUSH
84590: LD_INT 6
84592: MOD
84593: ST_TO_ADDR
// end ;
84594: LD_VAR 0 2
84598: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84599: LD_INT 0
84601: PPUSH
84602: PPUSH
84603: PPUSH
84604: PPUSH
84605: PPUSH
// if not hexes then
84606: LD_VAR 0 2
84610: NOT
84611: IFFALSE 84615
// exit ;
84613: GO 84763
// dist := 9999 ;
84615: LD_ADDR_VAR 0 5
84619: PUSH
84620: LD_INT 9999
84622: ST_TO_ADDR
// for i = 1 to hexes do
84623: LD_ADDR_VAR 0 4
84627: PUSH
84628: DOUBLE
84629: LD_INT 1
84631: DEC
84632: ST_TO_ADDR
84633: LD_VAR 0 2
84637: PUSH
84638: FOR_TO
84639: IFFALSE 84751
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84641: LD_VAR 0 1
84645: PPUSH
84646: LD_VAR 0 2
84650: PUSH
84651: LD_VAR 0 4
84655: ARRAY
84656: PUSH
84657: LD_INT 1
84659: ARRAY
84660: PPUSH
84661: LD_VAR 0 2
84665: PUSH
84666: LD_VAR 0 4
84670: ARRAY
84671: PUSH
84672: LD_INT 2
84674: ARRAY
84675: PPUSH
84676: CALL_OW 297
84680: PUSH
84681: LD_VAR 0 5
84685: LESS
84686: IFFALSE 84749
// begin hex := hexes [ i ] ;
84688: LD_ADDR_VAR 0 7
84692: PUSH
84693: LD_VAR 0 2
84697: PUSH
84698: LD_VAR 0 4
84702: ARRAY
84703: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84704: LD_ADDR_VAR 0 5
84708: PUSH
84709: LD_VAR 0 1
84713: PPUSH
84714: LD_VAR 0 2
84718: PUSH
84719: LD_VAR 0 4
84723: ARRAY
84724: PUSH
84725: LD_INT 1
84727: ARRAY
84728: PPUSH
84729: LD_VAR 0 2
84733: PUSH
84734: LD_VAR 0 4
84738: ARRAY
84739: PUSH
84740: LD_INT 2
84742: ARRAY
84743: PPUSH
84744: CALL_OW 297
84748: ST_TO_ADDR
// end ; end ;
84749: GO 84638
84751: POP
84752: POP
// result := hex ;
84753: LD_ADDR_VAR 0 3
84757: PUSH
84758: LD_VAR 0 7
84762: ST_TO_ADDR
// end ;
84763: LD_VAR 0 3
84767: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84768: LD_INT 0
84770: PPUSH
84771: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84772: LD_VAR 0 1
84776: NOT
84777: PUSH
84778: LD_VAR 0 1
84782: PUSH
84783: LD_INT 21
84785: PUSH
84786: LD_INT 2
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 23
84795: PUSH
84796: LD_INT 2
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: PPUSH
84807: CALL_OW 69
84811: IN
84812: NOT
84813: OR
84814: IFFALSE 84818
// exit ;
84816: GO 84865
// for i = 1 to 3 do
84818: LD_ADDR_VAR 0 3
84822: PUSH
84823: DOUBLE
84824: LD_INT 1
84826: DEC
84827: ST_TO_ADDR
84828: LD_INT 3
84830: PUSH
84831: FOR_TO
84832: IFFALSE 84863
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84834: LD_VAR 0 1
84838: PPUSH
84839: CALL_OW 250
84843: PPUSH
84844: LD_VAR 0 1
84848: PPUSH
84849: CALL_OW 251
84853: PPUSH
84854: LD_INT 1
84856: PPUSH
84857: CALL_OW 453
84861: GO 84831
84863: POP
84864: POP
// end ;
84865: LD_VAR 0 2
84869: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84870: LD_INT 0
84872: PPUSH
84873: PPUSH
84874: PPUSH
84875: PPUSH
84876: PPUSH
84877: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84878: LD_VAR 0 1
84882: NOT
84883: PUSH
84884: LD_VAR 0 2
84888: NOT
84889: OR
84890: PUSH
84891: LD_VAR 0 1
84895: PPUSH
84896: CALL_OW 314
84900: OR
84901: IFFALSE 84905
// exit ;
84903: GO 85346
// x := GetX ( enemy_unit ) ;
84905: LD_ADDR_VAR 0 7
84909: PUSH
84910: LD_VAR 0 2
84914: PPUSH
84915: CALL_OW 250
84919: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84920: LD_ADDR_VAR 0 8
84924: PUSH
84925: LD_VAR 0 2
84929: PPUSH
84930: CALL_OW 251
84934: ST_TO_ADDR
// if not x or not y then
84935: LD_VAR 0 7
84939: NOT
84940: PUSH
84941: LD_VAR 0 8
84945: NOT
84946: OR
84947: IFFALSE 84951
// exit ;
84949: GO 85346
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84951: LD_ADDR_VAR 0 6
84955: PUSH
84956: LD_VAR 0 7
84960: PPUSH
84961: LD_INT 0
84963: PPUSH
84964: LD_INT 4
84966: PPUSH
84967: CALL_OW 272
84971: PUSH
84972: LD_VAR 0 8
84976: PPUSH
84977: LD_INT 0
84979: PPUSH
84980: LD_INT 4
84982: PPUSH
84983: CALL_OW 273
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_VAR 0 7
84996: PPUSH
84997: LD_INT 1
84999: PPUSH
85000: LD_INT 4
85002: PPUSH
85003: CALL_OW 272
85007: PUSH
85008: LD_VAR 0 8
85012: PPUSH
85013: LD_INT 1
85015: PPUSH
85016: LD_INT 4
85018: PPUSH
85019: CALL_OW 273
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_VAR 0 7
85032: PPUSH
85033: LD_INT 2
85035: PPUSH
85036: LD_INT 4
85038: PPUSH
85039: CALL_OW 272
85043: PUSH
85044: LD_VAR 0 8
85048: PPUSH
85049: LD_INT 2
85051: PPUSH
85052: LD_INT 4
85054: PPUSH
85055: CALL_OW 273
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: PUSH
85064: LD_VAR 0 7
85068: PPUSH
85069: LD_INT 3
85071: PPUSH
85072: LD_INT 4
85074: PPUSH
85075: CALL_OW 272
85079: PUSH
85080: LD_VAR 0 8
85084: PPUSH
85085: LD_INT 3
85087: PPUSH
85088: LD_INT 4
85090: PPUSH
85091: CALL_OW 273
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_VAR 0 7
85104: PPUSH
85105: LD_INT 4
85107: PPUSH
85108: LD_INT 4
85110: PPUSH
85111: CALL_OW 272
85115: PUSH
85116: LD_VAR 0 8
85120: PPUSH
85121: LD_INT 4
85123: PPUSH
85124: LD_INT 4
85126: PPUSH
85127: CALL_OW 273
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_VAR 0 7
85140: PPUSH
85141: LD_INT 5
85143: PPUSH
85144: LD_INT 4
85146: PPUSH
85147: CALL_OW 272
85151: PUSH
85152: LD_VAR 0 8
85156: PPUSH
85157: LD_INT 5
85159: PPUSH
85160: LD_INT 4
85162: PPUSH
85163: CALL_OW 273
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: ST_TO_ADDR
// for i = tmp downto 1 do
85180: LD_ADDR_VAR 0 4
85184: PUSH
85185: DOUBLE
85186: LD_VAR 0 6
85190: INC
85191: ST_TO_ADDR
85192: LD_INT 1
85194: PUSH
85195: FOR_DOWNTO
85196: IFFALSE 85297
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85198: LD_VAR 0 6
85202: PUSH
85203: LD_VAR 0 4
85207: ARRAY
85208: PUSH
85209: LD_INT 1
85211: ARRAY
85212: PPUSH
85213: LD_VAR 0 6
85217: PUSH
85218: LD_VAR 0 4
85222: ARRAY
85223: PUSH
85224: LD_INT 2
85226: ARRAY
85227: PPUSH
85228: CALL_OW 488
85232: NOT
85233: PUSH
85234: LD_VAR 0 6
85238: PUSH
85239: LD_VAR 0 4
85243: ARRAY
85244: PUSH
85245: LD_INT 1
85247: ARRAY
85248: PPUSH
85249: LD_VAR 0 6
85253: PUSH
85254: LD_VAR 0 4
85258: ARRAY
85259: PUSH
85260: LD_INT 2
85262: ARRAY
85263: PPUSH
85264: CALL_OW 428
85268: PUSH
85269: LD_INT 0
85271: NONEQUAL
85272: OR
85273: IFFALSE 85295
// tmp := Delete ( tmp , i ) ;
85275: LD_ADDR_VAR 0 6
85279: PUSH
85280: LD_VAR 0 6
85284: PPUSH
85285: LD_VAR 0 4
85289: PPUSH
85290: CALL_OW 3
85294: ST_TO_ADDR
85295: GO 85195
85297: POP
85298: POP
// j := GetClosestHex ( unit , tmp ) ;
85299: LD_ADDR_VAR 0 5
85303: PUSH
85304: LD_VAR 0 1
85308: PPUSH
85309: LD_VAR 0 6
85313: PPUSH
85314: CALL 84599 0 2
85318: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85319: LD_VAR 0 1
85323: PPUSH
85324: LD_VAR 0 5
85328: PUSH
85329: LD_INT 1
85331: ARRAY
85332: PPUSH
85333: LD_VAR 0 5
85337: PUSH
85338: LD_INT 2
85340: ARRAY
85341: PPUSH
85342: CALL_OW 111
// end ;
85346: LD_VAR 0 3
85350: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85351: LD_INT 0
85353: PPUSH
85354: PPUSH
85355: PPUSH
// uc_side = 0 ;
85356: LD_ADDR_OWVAR 20
85360: PUSH
85361: LD_INT 0
85363: ST_TO_ADDR
// uc_nation = 0 ;
85364: LD_ADDR_OWVAR 21
85368: PUSH
85369: LD_INT 0
85371: ST_TO_ADDR
// InitHc_All ( ) ;
85372: CALL_OW 584
// InitVc ;
85376: CALL_OW 20
// if mastodonts then
85380: LD_VAR 0 6
85384: IFFALSE 85451
// for i = 1 to mastodonts do
85386: LD_ADDR_VAR 0 11
85390: PUSH
85391: DOUBLE
85392: LD_INT 1
85394: DEC
85395: ST_TO_ADDR
85396: LD_VAR 0 6
85400: PUSH
85401: FOR_TO
85402: IFFALSE 85449
// begin vc_chassis := 31 ;
85404: LD_ADDR_OWVAR 37
85408: PUSH
85409: LD_INT 31
85411: ST_TO_ADDR
// vc_control := control_rider ;
85412: LD_ADDR_OWVAR 38
85416: PUSH
85417: LD_INT 4
85419: ST_TO_ADDR
// animal := CreateVehicle ;
85420: LD_ADDR_VAR 0 12
85424: PUSH
85425: CALL_OW 45
85429: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85430: LD_VAR 0 12
85434: PPUSH
85435: LD_VAR 0 8
85439: PPUSH
85440: LD_INT 0
85442: PPUSH
85443: CALL 87639 0 3
// end ;
85447: GO 85401
85449: POP
85450: POP
// if horses then
85451: LD_VAR 0 5
85455: IFFALSE 85522
// for i = 1 to horses do
85457: LD_ADDR_VAR 0 11
85461: PUSH
85462: DOUBLE
85463: LD_INT 1
85465: DEC
85466: ST_TO_ADDR
85467: LD_VAR 0 5
85471: PUSH
85472: FOR_TO
85473: IFFALSE 85520
// begin hc_class := 21 ;
85475: LD_ADDR_OWVAR 28
85479: PUSH
85480: LD_INT 21
85482: ST_TO_ADDR
// hc_gallery :=  ;
85483: LD_ADDR_OWVAR 33
85487: PUSH
85488: LD_STRING 
85490: ST_TO_ADDR
// animal := CreateHuman ;
85491: LD_ADDR_VAR 0 12
85495: PUSH
85496: CALL_OW 44
85500: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85501: LD_VAR 0 12
85505: PPUSH
85506: LD_VAR 0 8
85510: PPUSH
85511: LD_INT 0
85513: PPUSH
85514: CALL 87639 0 3
// end ;
85518: GO 85472
85520: POP
85521: POP
// if birds then
85522: LD_VAR 0 1
85526: IFFALSE 85593
// for i = 1 to birds do
85528: LD_ADDR_VAR 0 11
85532: PUSH
85533: DOUBLE
85534: LD_INT 1
85536: DEC
85537: ST_TO_ADDR
85538: LD_VAR 0 1
85542: PUSH
85543: FOR_TO
85544: IFFALSE 85591
// begin hc_class = 18 ;
85546: LD_ADDR_OWVAR 28
85550: PUSH
85551: LD_INT 18
85553: ST_TO_ADDR
// hc_gallery =  ;
85554: LD_ADDR_OWVAR 33
85558: PUSH
85559: LD_STRING 
85561: ST_TO_ADDR
// animal := CreateHuman ;
85562: LD_ADDR_VAR 0 12
85566: PUSH
85567: CALL_OW 44
85571: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85572: LD_VAR 0 12
85576: PPUSH
85577: LD_VAR 0 8
85581: PPUSH
85582: LD_INT 0
85584: PPUSH
85585: CALL 87639 0 3
// end ;
85589: GO 85543
85591: POP
85592: POP
// if tigers then
85593: LD_VAR 0 2
85597: IFFALSE 85681
// for i = 1 to tigers do
85599: LD_ADDR_VAR 0 11
85603: PUSH
85604: DOUBLE
85605: LD_INT 1
85607: DEC
85608: ST_TO_ADDR
85609: LD_VAR 0 2
85613: PUSH
85614: FOR_TO
85615: IFFALSE 85679
// begin hc_class = class_tiger ;
85617: LD_ADDR_OWVAR 28
85621: PUSH
85622: LD_INT 14
85624: ST_TO_ADDR
// hc_gallery =  ;
85625: LD_ADDR_OWVAR 33
85629: PUSH
85630: LD_STRING 
85632: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85633: LD_ADDR_OWVAR 35
85637: PUSH
85638: LD_INT 7
85640: NEG
85641: PPUSH
85642: LD_INT 7
85644: PPUSH
85645: CALL_OW 12
85649: ST_TO_ADDR
// animal := CreateHuman ;
85650: LD_ADDR_VAR 0 12
85654: PUSH
85655: CALL_OW 44
85659: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85660: LD_VAR 0 12
85664: PPUSH
85665: LD_VAR 0 8
85669: PPUSH
85670: LD_INT 0
85672: PPUSH
85673: CALL 87639 0 3
// end ;
85677: GO 85614
85679: POP
85680: POP
// if apemans then
85681: LD_VAR 0 3
85685: IFFALSE 85808
// for i = 1 to apemans do
85687: LD_ADDR_VAR 0 11
85691: PUSH
85692: DOUBLE
85693: LD_INT 1
85695: DEC
85696: ST_TO_ADDR
85697: LD_VAR 0 3
85701: PUSH
85702: FOR_TO
85703: IFFALSE 85806
// begin hc_class = class_apeman ;
85705: LD_ADDR_OWVAR 28
85709: PUSH
85710: LD_INT 12
85712: ST_TO_ADDR
// hc_gallery =  ;
85713: LD_ADDR_OWVAR 33
85717: PUSH
85718: LD_STRING 
85720: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85721: LD_ADDR_OWVAR 35
85725: PUSH
85726: LD_INT 2
85728: NEG
85729: PPUSH
85730: LD_INT 2
85732: PPUSH
85733: CALL_OW 12
85737: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85738: LD_ADDR_OWVAR 31
85742: PUSH
85743: LD_INT 1
85745: PPUSH
85746: LD_INT 3
85748: PPUSH
85749: CALL_OW 12
85753: PUSH
85754: LD_INT 1
85756: PPUSH
85757: LD_INT 3
85759: PPUSH
85760: CALL_OW 12
85764: PUSH
85765: LD_INT 0
85767: PUSH
85768: LD_INT 0
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: ST_TO_ADDR
// animal := CreateHuman ;
85777: LD_ADDR_VAR 0 12
85781: PUSH
85782: CALL_OW 44
85786: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85787: LD_VAR 0 12
85791: PPUSH
85792: LD_VAR 0 8
85796: PPUSH
85797: LD_INT 0
85799: PPUSH
85800: CALL 87639 0 3
// end ;
85804: GO 85702
85806: POP
85807: POP
// if enchidnas then
85808: LD_VAR 0 4
85812: IFFALSE 85879
// for i = 1 to enchidnas do
85814: LD_ADDR_VAR 0 11
85818: PUSH
85819: DOUBLE
85820: LD_INT 1
85822: DEC
85823: ST_TO_ADDR
85824: LD_VAR 0 4
85828: PUSH
85829: FOR_TO
85830: IFFALSE 85877
// begin hc_class = 13 ;
85832: LD_ADDR_OWVAR 28
85836: PUSH
85837: LD_INT 13
85839: ST_TO_ADDR
// hc_gallery =  ;
85840: LD_ADDR_OWVAR 33
85844: PUSH
85845: LD_STRING 
85847: ST_TO_ADDR
// animal := CreateHuman ;
85848: LD_ADDR_VAR 0 12
85852: PUSH
85853: CALL_OW 44
85857: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85858: LD_VAR 0 12
85862: PPUSH
85863: LD_VAR 0 8
85867: PPUSH
85868: LD_INT 0
85870: PPUSH
85871: CALL 87639 0 3
// end ;
85875: GO 85829
85877: POP
85878: POP
// if fishes then
85879: LD_VAR 0 7
85883: IFFALSE 85950
// for i = 1 to fishes do
85885: LD_ADDR_VAR 0 11
85889: PUSH
85890: DOUBLE
85891: LD_INT 1
85893: DEC
85894: ST_TO_ADDR
85895: LD_VAR 0 7
85899: PUSH
85900: FOR_TO
85901: IFFALSE 85948
// begin hc_class = 20 ;
85903: LD_ADDR_OWVAR 28
85907: PUSH
85908: LD_INT 20
85910: ST_TO_ADDR
// hc_gallery =  ;
85911: LD_ADDR_OWVAR 33
85915: PUSH
85916: LD_STRING 
85918: ST_TO_ADDR
// animal := CreateHuman ;
85919: LD_ADDR_VAR 0 12
85923: PUSH
85924: CALL_OW 44
85928: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85929: LD_VAR 0 12
85933: PPUSH
85934: LD_VAR 0 9
85938: PPUSH
85939: LD_INT 0
85941: PPUSH
85942: CALL 87639 0 3
// end ;
85946: GO 85900
85948: POP
85949: POP
// end ;
85950: LD_VAR 0 10
85954: RET
// export function WantHeal ( sci , unit ) ; begin
85955: LD_INT 0
85957: PPUSH
// if GetTaskList ( sci ) > 0 then
85958: LD_VAR 0 1
85962: PPUSH
85963: CALL_OW 437
85967: PUSH
85968: LD_INT 0
85970: GREATER
85971: IFFALSE 86041
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85973: LD_VAR 0 1
85977: PPUSH
85978: CALL_OW 437
85982: PUSH
85983: LD_INT 1
85985: ARRAY
85986: PUSH
85987: LD_INT 1
85989: ARRAY
85990: PUSH
85991: LD_STRING l
85993: EQUAL
85994: PUSH
85995: LD_VAR 0 1
85999: PPUSH
86000: CALL_OW 437
86004: PUSH
86005: LD_INT 1
86007: ARRAY
86008: PUSH
86009: LD_INT 4
86011: ARRAY
86012: PUSH
86013: LD_VAR 0 2
86017: EQUAL
86018: AND
86019: IFFALSE 86031
// result := true else
86021: LD_ADDR_VAR 0 3
86025: PUSH
86026: LD_INT 1
86028: ST_TO_ADDR
86029: GO 86039
// result := false ;
86031: LD_ADDR_VAR 0 3
86035: PUSH
86036: LD_INT 0
86038: ST_TO_ADDR
// end else
86039: GO 86049
// result := false ;
86041: LD_ADDR_VAR 0 3
86045: PUSH
86046: LD_INT 0
86048: ST_TO_ADDR
// end ;
86049: LD_VAR 0 3
86053: RET
// export function HealTarget ( sci ) ; begin
86054: LD_INT 0
86056: PPUSH
// if not sci then
86057: LD_VAR 0 1
86061: NOT
86062: IFFALSE 86066
// exit ;
86064: GO 86131
// result := 0 ;
86066: LD_ADDR_VAR 0 2
86070: PUSH
86071: LD_INT 0
86073: ST_TO_ADDR
// if GetTaskList ( sci ) then
86074: LD_VAR 0 1
86078: PPUSH
86079: CALL_OW 437
86083: IFFALSE 86131
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86085: LD_VAR 0 1
86089: PPUSH
86090: CALL_OW 437
86094: PUSH
86095: LD_INT 1
86097: ARRAY
86098: PUSH
86099: LD_INT 1
86101: ARRAY
86102: PUSH
86103: LD_STRING l
86105: EQUAL
86106: IFFALSE 86131
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86108: LD_ADDR_VAR 0 2
86112: PUSH
86113: LD_VAR 0 1
86117: PPUSH
86118: CALL_OW 437
86122: PUSH
86123: LD_INT 1
86125: ARRAY
86126: PUSH
86127: LD_INT 4
86129: ARRAY
86130: ST_TO_ADDR
// end ;
86131: LD_VAR 0 2
86135: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86136: LD_INT 0
86138: PPUSH
86139: PPUSH
86140: PPUSH
86141: PPUSH
// if not base_units then
86142: LD_VAR 0 1
86146: NOT
86147: IFFALSE 86151
// exit ;
86149: GO 86238
// result := false ;
86151: LD_ADDR_VAR 0 2
86155: PUSH
86156: LD_INT 0
86158: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86159: LD_ADDR_VAR 0 5
86163: PUSH
86164: LD_VAR 0 1
86168: PPUSH
86169: LD_INT 21
86171: PUSH
86172: LD_INT 3
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PPUSH
86179: CALL_OW 72
86183: ST_TO_ADDR
// if not tmp then
86184: LD_VAR 0 5
86188: NOT
86189: IFFALSE 86193
// exit ;
86191: GO 86238
// for i in tmp do
86193: LD_ADDR_VAR 0 3
86197: PUSH
86198: LD_VAR 0 5
86202: PUSH
86203: FOR_IN
86204: IFFALSE 86236
// begin result := EnemyInRange ( i , 22 ) ;
86206: LD_ADDR_VAR 0 2
86210: PUSH
86211: LD_VAR 0 3
86215: PPUSH
86216: LD_INT 22
86218: PPUSH
86219: CALL 84474 0 2
86223: ST_TO_ADDR
// if result then
86224: LD_VAR 0 2
86228: IFFALSE 86234
// exit ;
86230: POP
86231: POP
86232: GO 86238
// end ;
86234: GO 86203
86236: POP
86237: POP
// end ;
86238: LD_VAR 0 2
86242: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
86243: LD_INT 0
86245: PPUSH
86246: PPUSH
// if not units then
86247: LD_VAR 0 1
86251: NOT
86252: IFFALSE 86256
// exit ;
86254: GO 86326
// result := [ ] ;
86256: LD_ADDR_VAR 0 3
86260: PUSH
86261: EMPTY
86262: ST_TO_ADDR
// for i in units do
86263: LD_ADDR_VAR 0 4
86267: PUSH
86268: LD_VAR 0 1
86272: PUSH
86273: FOR_IN
86274: IFFALSE 86324
// if GetTag ( i ) = tag then
86276: LD_VAR 0 4
86280: PPUSH
86281: CALL_OW 110
86285: PUSH
86286: LD_VAR 0 2
86290: EQUAL
86291: IFFALSE 86322
// result := Replace ( result , result + 1 , i ) ;
86293: LD_ADDR_VAR 0 3
86297: PUSH
86298: LD_VAR 0 3
86302: PPUSH
86303: LD_VAR 0 3
86307: PUSH
86308: LD_INT 1
86310: PLUS
86311: PPUSH
86312: LD_VAR 0 4
86316: PPUSH
86317: CALL_OW 1
86321: ST_TO_ADDR
86322: GO 86273
86324: POP
86325: POP
// end ;
86326: LD_VAR 0 3
86330: RET
// export function IsDriver ( un ) ; begin
86331: LD_INT 0
86333: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
86334: LD_ADDR_VAR 0 2
86338: PUSH
86339: LD_VAR 0 1
86343: PUSH
86344: LD_INT 55
86346: PUSH
86347: EMPTY
86348: LIST
86349: PPUSH
86350: CALL_OW 69
86354: IN
86355: ST_TO_ADDR
// end ;
86356: LD_VAR 0 2
86360: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
86361: LD_INT 0
86363: PPUSH
86364: PPUSH
// list := [ ] ;
86365: LD_ADDR_VAR 0 5
86369: PUSH
86370: EMPTY
86371: ST_TO_ADDR
// case d of 0 :
86372: LD_VAR 0 3
86376: PUSH
86377: LD_INT 0
86379: DOUBLE
86380: EQUAL
86381: IFTRUE 86385
86383: GO 86518
86385: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
86386: LD_ADDR_VAR 0 5
86390: PUSH
86391: LD_VAR 0 1
86395: PUSH
86396: LD_INT 4
86398: MINUS
86399: PUSH
86400: LD_VAR 0 2
86404: PUSH
86405: LD_INT 4
86407: MINUS
86408: PUSH
86409: LD_INT 2
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: LIST
86416: PUSH
86417: LD_VAR 0 1
86421: PUSH
86422: LD_INT 3
86424: MINUS
86425: PUSH
86426: LD_VAR 0 2
86430: PUSH
86431: LD_INT 1
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: LIST
86438: PUSH
86439: LD_VAR 0 1
86443: PUSH
86444: LD_INT 4
86446: PLUS
86447: PUSH
86448: LD_VAR 0 2
86452: PUSH
86453: LD_INT 4
86455: PUSH
86456: EMPTY
86457: LIST
86458: LIST
86459: LIST
86460: PUSH
86461: LD_VAR 0 1
86465: PUSH
86466: LD_INT 3
86468: PLUS
86469: PUSH
86470: LD_VAR 0 2
86474: PUSH
86475: LD_INT 3
86477: PLUS
86478: PUSH
86479: LD_INT 5
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: LIST
86486: PUSH
86487: LD_VAR 0 1
86491: PUSH
86492: LD_VAR 0 2
86496: PUSH
86497: LD_INT 4
86499: PLUS
86500: PUSH
86501: LD_INT 0
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: LIST
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: ST_TO_ADDR
// end ; 1 :
86516: GO 87216
86518: LD_INT 1
86520: DOUBLE
86521: EQUAL
86522: IFTRUE 86526
86524: GO 86659
86526: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
86527: LD_ADDR_VAR 0 5
86531: PUSH
86532: LD_VAR 0 1
86536: PUSH
86537: LD_VAR 0 2
86541: PUSH
86542: LD_INT 4
86544: MINUS
86545: PUSH
86546: LD_INT 3
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: LIST
86553: PUSH
86554: LD_VAR 0 1
86558: PUSH
86559: LD_INT 3
86561: MINUS
86562: PUSH
86563: LD_VAR 0 2
86567: PUSH
86568: LD_INT 3
86570: MINUS
86571: PUSH
86572: LD_INT 2
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: LIST
86579: PUSH
86580: LD_VAR 0 1
86584: PUSH
86585: LD_INT 4
86587: MINUS
86588: PUSH
86589: LD_VAR 0 2
86593: PUSH
86594: LD_INT 1
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: LIST
86601: PUSH
86602: LD_VAR 0 1
86606: PUSH
86607: LD_VAR 0 2
86611: PUSH
86612: LD_INT 3
86614: PLUS
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: LIST
86623: PUSH
86624: LD_VAR 0 1
86628: PUSH
86629: LD_INT 4
86631: PLUS
86632: PUSH
86633: LD_VAR 0 2
86637: PUSH
86638: LD_INT 4
86640: PLUS
86641: PUSH
86642: LD_INT 5
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: LIST
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: ST_TO_ADDR
// end ; 2 :
86657: GO 87216
86659: LD_INT 2
86661: DOUBLE
86662: EQUAL
86663: IFTRUE 86667
86665: GO 86796
86667: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
86668: LD_ADDR_VAR 0 5
86672: PUSH
86673: LD_VAR 0 1
86677: PUSH
86678: LD_VAR 0 2
86682: PUSH
86683: LD_INT 3
86685: MINUS
86686: PUSH
86687: LD_INT 3
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: LIST
86694: PUSH
86695: LD_VAR 0 1
86699: PUSH
86700: LD_INT 4
86702: PLUS
86703: PUSH
86704: LD_VAR 0 2
86708: PUSH
86709: LD_INT 4
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: LIST
86716: PUSH
86717: LD_VAR 0 1
86721: PUSH
86722: LD_VAR 0 2
86726: PUSH
86727: LD_INT 4
86729: PLUS
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: LIST
86738: PUSH
86739: LD_VAR 0 1
86743: PUSH
86744: LD_INT 3
86746: MINUS
86747: PUSH
86748: LD_VAR 0 2
86752: PUSH
86753: LD_INT 1
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: LIST
86760: PUSH
86761: LD_VAR 0 1
86765: PUSH
86766: LD_INT 4
86768: MINUS
86769: PUSH
86770: LD_VAR 0 2
86774: PUSH
86775: LD_INT 4
86777: MINUS
86778: PUSH
86779: LD_INT 2
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: LIST
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: ST_TO_ADDR
// end ; 3 :
86794: GO 87216
86796: LD_INT 3
86798: DOUBLE
86799: EQUAL
86800: IFTRUE 86804
86802: GO 86937
86804: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86805: LD_ADDR_VAR 0 5
86809: PUSH
86810: LD_VAR 0 1
86814: PUSH
86815: LD_INT 3
86817: PLUS
86818: PUSH
86819: LD_VAR 0 2
86823: PUSH
86824: LD_INT 4
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: LIST
86831: PUSH
86832: LD_VAR 0 1
86836: PUSH
86837: LD_INT 4
86839: PLUS
86840: PUSH
86841: LD_VAR 0 2
86845: PUSH
86846: LD_INT 4
86848: PLUS
86849: PUSH
86850: LD_INT 5
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: LIST
86857: PUSH
86858: LD_VAR 0 1
86862: PUSH
86863: LD_INT 4
86865: MINUS
86866: PUSH
86867: LD_VAR 0 2
86871: PUSH
86872: LD_INT 1
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: LIST
86879: PUSH
86880: LD_VAR 0 1
86884: PUSH
86885: LD_VAR 0 2
86889: PUSH
86890: LD_INT 4
86892: MINUS
86893: PUSH
86894: LD_INT 3
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: LIST
86901: PUSH
86902: LD_VAR 0 1
86906: PUSH
86907: LD_INT 3
86909: MINUS
86910: PUSH
86911: LD_VAR 0 2
86915: PUSH
86916: LD_INT 3
86918: MINUS
86919: PUSH
86920: LD_INT 2
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: LIST
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: ST_TO_ADDR
// end ; 4 :
86935: GO 87216
86937: LD_INT 4
86939: DOUBLE
86940: EQUAL
86941: IFTRUE 86945
86943: GO 87078
86945: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86946: LD_ADDR_VAR 0 5
86950: PUSH
86951: LD_VAR 0 1
86955: PUSH
86956: LD_VAR 0 2
86960: PUSH
86961: LD_INT 4
86963: PLUS
86964: PUSH
86965: LD_INT 0
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: LIST
86972: PUSH
86973: LD_VAR 0 1
86977: PUSH
86978: LD_INT 3
86980: PLUS
86981: PUSH
86982: LD_VAR 0 2
86986: PUSH
86987: LD_INT 3
86989: PLUS
86990: PUSH
86991: LD_INT 5
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: LIST
86998: PUSH
86999: LD_VAR 0 1
87003: PUSH
87004: LD_INT 4
87006: PLUS
87007: PUSH
87008: LD_VAR 0 2
87012: PUSH
87013: LD_INT 4
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: LIST
87020: PUSH
87021: LD_VAR 0 1
87025: PUSH
87026: LD_VAR 0 2
87030: PUSH
87031: LD_INT 3
87033: MINUS
87034: PUSH
87035: LD_INT 3
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: LIST
87042: PUSH
87043: LD_VAR 0 1
87047: PUSH
87048: LD_INT 4
87050: MINUS
87051: PUSH
87052: LD_VAR 0 2
87056: PUSH
87057: LD_INT 4
87059: MINUS
87060: PUSH
87061: LD_INT 2
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: LIST
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: ST_TO_ADDR
// end ; 5 :
87076: GO 87216
87078: LD_INT 5
87080: DOUBLE
87081: EQUAL
87082: IFTRUE 87086
87084: GO 87215
87086: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87087: LD_ADDR_VAR 0 5
87091: PUSH
87092: LD_VAR 0 1
87096: PUSH
87097: LD_INT 4
87099: MINUS
87100: PUSH
87101: LD_VAR 0 2
87105: PUSH
87106: LD_INT 1
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: LIST
87113: PUSH
87114: LD_VAR 0 1
87118: PUSH
87119: LD_VAR 0 2
87123: PUSH
87124: LD_INT 4
87126: MINUS
87127: PUSH
87128: LD_INT 3
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: LIST
87135: PUSH
87136: LD_VAR 0 1
87140: PUSH
87141: LD_INT 4
87143: PLUS
87144: PUSH
87145: LD_VAR 0 2
87149: PUSH
87150: LD_INT 4
87152: PLUS
87153: PUSH
87154: LD_INT 5
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: LIST
87161: PUSH
87162: LD_VAR 0 1
87166: PUSH
87167: LD_INT 3
87169: PLUS
87170: PUSH
87171: LD_VAR 0 2
87175: PUSH
87176: LD_INT 4
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: LIST
87183: PUSH
87184: LD_VAR 0 1
87188: PUSH
87189: LD_VAR 0 2
87193: PUSH
87194: LD_INT 3
87196: PLUS
87197: PUSH
87198: LD_INT 0
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: LIST
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: ST_TO_ADDR
// end ; end ;
87213: GO 87216
87215: POP
// result := list ;
87216: LD_ADDR_VAR 0 4
87220: PUSH
87221: LD_VAR 0 5
87225: ST_TO_ADDR
// end ;
87226: LD_VAR 0 4
87230: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87231: LD_INT 0
87233: PPUSH
87234: PPUSH
87235: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87236: LD_VAR 0 1
87240: NOT
87241: PUSH
87242: LD_VAR 0 2
87246: PUSH
87247: LD_INT 1
87249: PUSH
87250: LD_INT 2
87252: PUSH
87253: LD_INT 3
87255: PUSH
87256: LD_INT 4
87258: PUSH
87259: EMPTY
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: IN
87265: NOT
87266: OR
87267: IFFALSE 87271
// exit ;
87269: GO 87363
// tmp := [ ] ;
87271: LD_ADDR_VAR 0 5
87275: PUSH
87276: EMPTY
87277: ST_TO_ADDR
// for i in units do
87278: LD_ADDR_VAR 0 4
87282: PUSH
87283: LD_VAR 0 1
87287: PUSH
87288: FOR_IN
87289: IFFALSE 87332
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
87291: LD_ADDR_VAR 0 5
87295: PUSH
87296: LD_VAR 0 5
87300: PPUSH
87301: LD_VAR 0 5
87305: PUSH
87306: LD_INT 1
87308: PLUS
87309: PPUSH
87310: LD_VAR 0 4
87314: PPUSH
87315: LD_VAR 0 2
87319: PPUSH
87320: CALL_OW 259
87324: PPUSH
87325: CALL_OW 2
87329: ST_TO_ADDR
87330: GO 87288
87332: POP
87333: POP
// if not tmp then
87334: LD_VAR 0 5
87338: NOT
87339: IFFALSE 87343
// exit ;
87341: GO 87363
// result := SortListByListDesc ( units , tmp ) ;
87343: LD_ADDR_VAR 0 3
87347: PUSH
87348: LD_VAR 0 1
87352: PPUSH
87353: LD_VAR 0 5
87357: PPUSH
87358: CALL_OW 77
87362: ST_TO_ADDR
// end ;
87363: LD_VAR 0 3
87367: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
87368: LD_INT 0
87370: PPUSH
87371: PPUSH
87372: PPUSH
// result := false ;
87373: LD_ADDR_VAR 0 3
87377: PUSH
87378: LD_INT 0
87380: ST_TO_ADDR
// x := GetX ( building ) ;
87381: LD_ADDR_VAR 0 4
87385: PUSH
87386: LD_VAR 0 2
87390: PPUSH
87391: CALL_OW 250
87395: ST_TO_ADDR
// y := GetY ( building ) ;
87396: LD_ADDR_VAR 0 5
87400: PUSH
87401: LD_VAR 0 2
87405: PPUSH
87406: CALL_OW 251
87410: ST_TO_ADDR
// if not building or not x or not y then
87411: LD_VAR 0 2
87415: NOT
87416: PUSH
87417: LD_VAR 0 4
87421: NOT
87422: OR
87423: PUSH
87424: LD_VAR 0 5
87428: NOT
87429: OR
87430: IFFALSE 87434
// exit ;
87432: GO 87526
// if GetTaskList ( unit ) then
87434: LD_VAR 0 1
87438: PPUSH
87439: CALL_OW 437
87443: IFFALSE 87526
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87445: LD_STRING e
87447: PUSH
87448: LD_VAR 0 1
87452: PPUSH
87453: CALL_OW 437
87457: PUSH
87458: LD_INT 1
87460: ARRAY
87461: PUSH
87462: LD_INT 1
87464: ARRAY
87465: EQUAL
87466: PUSH
87467: LD_VAR 0 4
87471: PUSH
87472: LD_VAR 0 1
87476: PPUSH
87477: CALL_OW 437
87481: PUSH
87482: LD_INT 1
87484: ARRAY
87485: PUSH
87486: LD_INT 2
87488: ARRAY
87489: EQUAL
87490: AND
87491: PUSH
87492: LD_VAR 0 5
87496: PUSH
87497: LD_VAR 0 1
87501: PPUSH
87502: CALL_OW 437
87506: PUSH
87507: LD_INT 1
87509: ARRAY
87510: PUSH
87511: LD_INT 3
87513: ARRAY
87514: EQUAL
87515: AND
87516: IFFALSE 87526
// result := true end ;
87518: LD_ADDR_VAR 0 3
87522: PUSH
87523: LD_INT 1
87525: ST_TO_ADDR
// end ;
87526: LD_VAR 0 3
87530: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
87531: LD_INT 0
87533: PPUSH
// result := false ;
87534: LD_ADDR_VAR 0 4
87538: PUSH
87539: LD_INT 0
87541: ST_TO_ADDR
// if GetTaskList ( unit ) then
87542: LD_VAR 0 1
87546: PPUSH
87547: CALL_OW 437
87551: IFFALSE 87634
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87553: LD_STRING M
87555: PUSH
87556: LD_VAR 0 1
87560: PPUSH
87561: CALL_OW 437
87565: PUSH
87566: LD_INT 1
87568: ARRAY
87569: PUSH
87570: LD_INT 1
87572: ARRAY
87573: EQUAL
87574: PUSH
87575: LD_VAR 0 2
87579: PUSH
87580: LD_VAR 0 1
87584: PPUSH
87585: CALL_OW 437
87589: PUSH
87590: LD_INT 1
87592: ARRAY
87593: PUSH
87594: LD_INT 2
87596: ARRAY
87597: EQUAL
87598: AND
87599: PUSH
87600: LD_VAR 0 3
87604: PUSH
87605: LD_VAR 0 1
87609: PPUSH
87610: CALL_OW 437
87614: PUSH
87615: LD_INT 1
87617: ARRAY
87618: PUSH
87619: LD_INT 3
87621: ARRAY
87622: EQUAL
87623: AND
87624: IFFALSE 87634
// result := true ;
87626: LD_ADDR_VAR 0 4
87630: PUSH
87631: LD_INT 1
87633: ST_TO_ADDR
// end ; end ;
87634: LD_VAR 0 4
87638: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
87639: LD_INT 0
87641: PPUSH
87642: PPUSH
87643: PPUSH
87644: PPUSH
// if not unit or not area then
87645: LD_VAR 0 1
87649: NOT
87650: PUSH
87651: LD_VAR 0 2
87655: NOT
87656: OR
87657: IFFALSE 87661
// exit ;
87659: GO 87825
// tmp := AreaToList ( area , i ) ;
87661: LD_ADDR_VAR 0 6
87665: PUSH
87666: LD_VAR 0 2
87670: PPUSH
87671: LD_VAR 0 5
87675: PPUSH
87676: CALL_OW 517
87680: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
87681: LD_ADDR_VAR 0 5
87685: PUSH
87686: DOUBLE
87687: LD_INT 1
87689: DEC
87690: ST_TO_ADDR
87691: LD_VAR 0 6
87695: PUSH
87696: LD_INT 1
87698: ARRAY
87699: PUSH
87700: FOR_TO
87701: IFFALSE 87823
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
87703: LD_ADDR_VAR 0 7
87707: PUSH
87708: LD_VAR 0 6
87712: PUSH
87713: LD_INT 1
87715: ARRAY
87716: PUSH
87717: LD_VAR 0 5
87721: ARRAY
87722: PUSH
87723: LD_VAR 0 6
87727: PUSH
87728: LD_INT 2
87730: ARRAY
87731: PUSH
87732: LD_VAR 0 5
87736: ARRAY
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87742: LD_VAR 0 7
87746: PUSH
87747: LD_INT 1
87749: ARRAY
87750: PPUSH
87751: LD_VAR 0 7
87755: PUSH
87756: LD_INT 2
87758: ARRAY
87759: PPUSH
87760: CALL_OW 428
87764: PUSH
87765: LD_INT 0
87767: EQUAL
87768: IFFALSE 87821
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87770: LD_VAR 0 1
87774: PPUSH
87775: LD_VAR 0 7
87779: PUSH
87780: LD_INT 1
87782: ARRAY
87783: PPUSH
87784: LD_VAR 0 7
87788: PUSH
87789: LD_INT 2
87791: ARRAY
87792: PPUSH
87793: LD_VAR 0 3
87797: PPUSH
87798: CALL_OW 48
// result := IsPlaced ( unit ) ;
87802: LD_ADDR_VAR 0 4
87806: PUSH
87807: LD_VAR 0 1
87811: PPUSH
87812: CALL_OW 305
87816: ST_TO_ADDR
// exit ;
87817: POP
87818: POP
87819: GO 87825
// end ; end ;
87821: GO 87700
87823: POP
87824: POP
// end ;
87825: LD_VAR 0 4
87829: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87830: LD_INT 0
87832: PPUSH
87833: PPUSH
87834: PPUSH
// if not side or side > 8 then
87835: LD_VAR 0 1
87839: NOT
87840: PUSH
87841: LD_VAR 0 1
87845: PUSH
87846: LD_INT 8
87848: GREATER
87849: OR
87850: IFFALSE 87854
// exit ;
87852: GO 88041
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87854: LD_ADDR_VAR 0 4
87858: PUSH
87859: LD_INT 22
87861: PUSH
87862: LD_VAR 0 1
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 21
87873: PUSH
87874: LD_INT 3
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: PPUSH
87885: CALL_OW 69
87889: ST_TO_ADDR
// if not tmp then
87890: LD_VAR 0 4
87894: NOT
87895: IFFALSE 87899
// exit ;
87897: GO 88041
// enable_addtolog := true ;
87899: LD_ADDR_OWVAR 81
87903: PUSH
87904: LD_INT 1
87906: ST_TO_ADDR
// AddToLog ( [ ) ;
87907: LD_STRING [
87909: PPUSH
87910: CALL_OW 561
// for i in tmp do
87914: LD_ADDR_VAR 0 3
87918: PUSH
87919: LD_VAR 0 4
87923: PUSH
87924: FOR_IN
87925: IFFALSE 88032
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87927: LD_STRING [
87929: PUSH
87930: LD_VAR 0 3
87934: PPUSH
87935: CALL_OW 266
87939: STR
87940: PUSH
87941: LD_STRING , 
87943: STR
87944: PUSH
87945: LD_VAR 0 3
87949: PPUSH
87950: CALL_OW 250
87954: STR
87955: PUSH
87956: LD_STRING , 
87958: STR
87959: PUSH
87960: LD_VAR 0 3
87964: PPUSH
87965: CALL_OW 251
87969: STR
87970: PUSH
87971: LD_STRING , 
87973: STR
87974: PUSH
87975: LD_VAR 0 3
87979: PPUSH
87980: CALL_OW 254
87984: STR
87985: PUSH
87986: LD_STRING , 
87988: STR
87989: PUSH
87990: LD_VAR 0 3
87994: PPUSH
87995: LD_INT 1
87997: PPUSH
87998: CALL_OW 268
88002: STR
88003: PUSH
88004: LD_STRING , 
88006: STR
88007: PUSH
88008: LD_VAR 0 3
88012: PPUSH
88013: LD_INT 2
88015: PPUSH
88016: CALL_OW 268
88020: STR
88021: PUSH
88022: LD_STRING ],
88024: STR
88025: PPUSH
88026: CALL_OW 561
// end ;
88030: GO 87924
88032: POP
88033: POP
// AddToLog ( ]; ) ;
88034: LD_STRING ];
88036: PPUSH
88037: CALL_OW 561
// end ;
88041: LD_VAR 0 2
88045: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88046: LD_INT 0
88048: PPUSH
88049: PPUSH
88050: PPUSH
88051: PPUSH
88052: PPUSH
// if not area or not rate or not max then
88053: LD_VAR 0 1
88057: NOT
88058: PUSH
88059: LD_VAR 0 2
88063: NOT
88064: OR
88065: PUSH
88066: LD_VAR 0 4
88070: NOT
88071: OR
88072: IFFALSE 88076
// exit ;
88074: GO 88268
// while 1 do
88076: LD_INT 1
88078: IFFALSE 88268
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88080: LD_ADDR_VAR 0 9
88084: PUSH
88085: LD_VAR 0 1
88089: PPUSH
88090: LD_INT 1
88092: PPUSH
88093: CALL_OW 287
88097: PUSH
88098: LD_INT 10
88100: MUL
88101: ST_TO_ADDR
// r := rate / 10 ;
88102: LD_ADDR_VAR 0 7
88106: PUSH
88107: LD_VAR 0 2
88111: PUSH
88112: LD_INT 10
88114: DIVREAL
88115: ST_TO_ADDR
// time := 1 1$00 ;
88116: LD_ADDR_VAR 0 8
88120: PUSH
88121: LD_INT 2100
88123: ST_TO_ADDR
// if amount < min then
88124: LD_VAR 0 9
88128: PUSH
88129: LD_VAR 0 3
88133: LESS
88134: IFFALSE 88152
// r := r * 2 else
88136: LD_ADDR_VAR 0 7
88140: PUSH
88141: LD_VAR 0 7
88145: PUSH
88146: LD_INT 2
88148: MUL
88149: ST_TO_ADDR
88150: GO 88178
// if amount > max then
88152: LD_VAR 0 9
88156: PUSH
88157: LD_VAR 0 4
88161: GREATER
88162: IFFALSE 88178
// r := r / 2 ;
88164: LD_ADDR_VAR 0 7
88168: PUSH
88169: LD_VAR 0 7
88173: PUSH
88174: LD_INT 2
88176: DIVREAL
88177: ST_TO_ADDR
// time := time / r ;
88178: LD_ADDR_VAR 0 8
88182: PUSH
88183: LD_VAR 0 8
88187: PUSH
88188: LD_VAR 0 7
88192: DIVREAL
88193: ST_TO_ADDR
// if time < 0 then
88194: LD_VAR 0 8
88198: PUSH
88199: LD_INT 0
88201: LESS
88202: IFFALSE 88219
// time := time * - 1 ;
88204: LD_ADDR_VAR 0 8
88208: PUSH
88209: LD_VAR 0 8
88213: PUSH
88214: LD_INT 1
88216: NEG
88217: MUL
88218: ST_TO_ADDR
// wait ( time ) ;
88219: LD_VAR 0 8
88223: PPUSH
88224: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
88228: LD_INT 35
88230: PPUSH
88231: LD_INT 875
88233: PPUSH
88234: CALL_OW 12
88238: PPUSH
88239: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88243: LD_INT 1
88245: PPUSH
88246: LD_INT 5
88248: PPUSH
88249: CALL_OW 12
88253: PPUSH
88254: LD_VAR 0 1
88258: PPUSH
88259: LD_INT 1
88261: PPUSH
88262: CALL_OW 55
// end ;
88266: GO 88076
// end ;
88268: LD_VAR 0 5
88272: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88273: LD_INT 0
88275: PPUSH
88276: PPUSH
88277: PPUSH
88278: PPUSH
88279: PPUSH
88280: PPUSH
88281: PPUSH
88282: PPUSH
// if not turrets or not factories then
88283: LD_VAR 0 1
88287: NOT
88288: PUSH
88289: LD_VAR 0 2
88293: NOT
88294: OR
88295: IFFALSE 88299
// exit ;
88297: GO 88606
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88299: LD_ADDR_VAR 0 10
88303: PUSH
88304: LD_INT 5
88306: PUSH
88307: LD_INT 6
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: PUSH
88314: LD_INT 2
88316: PUSH
88317: LD_INT 4
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 3
88326: PUSH
88327: LD_INT 5
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 24
88341: PUSH
88342: LD_INT 25
88344: PUSH
88345: EMPTY
88346: LIST
88347: LIST
88348: PUSH
88349: LD_INT 23
88351: PUSH
88352: LD_INT 27
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 42
88365: PUSH
88366: LD_INT 43
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 44
88375: PUSH
88376: LD_INT 46
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: LD_INT 45
88385: PUSH
88386: LD_INT 47
88388: PUSH
88389: EMPTY
88390: LIST
88391: LIST
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: LIST
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: LIST
88402: ST_TO_ADDR
// result := [ ] ;
88403: LD_ADDR_VAR 0 3
88407: PUSH
88408: EMPTY
88409: ST_TO_ADDR
// for i in turrets do
88410: LD_ADDR_VAR 0 4
88414: PUSH
88415: LD_VAR 0 1
88419: PUSH
88420: FOR_IN
88421: IFFALSE 88604
// begin nat := GetNation ( i ) ;
88423: LD_ADDR_VAR 0 7
88427: PUSH
88428: LD_VAR 0 4
88432: PPUSH
88433: CALL_OW 248
88437: ST_TO_ADDR
// weapon := 0 ;
88438: LD_ADDR_VAR 0 8
88442: PUSH
88443: LD_INT 0
88445: ST_TO_ADDR
// if not nat then
88446: LD_VAR 0 7
88450: NOT
88451: IFFALSE 88455
// continue ;
88453: GO 88420
// for j in list [ nat ] do
88455: LD_ADDR_VAR 0 5
88459: PUSH
88460: LD_VAR 0 10
88464: PUSH
88465: LD_VAR 0 7
88469: ARRAY
88470: PUSH
88471: FOR_IN
88472: IFFALSE 88513
// if GetBWeapon ( i ) = j [ 1 ] then
88474: LD_VAR 0 4
88478: PPUSH
88479: CALL_OW 269
88483: PUSH
88484: LD_VAR 0 5
88488: PUSH
88489: LD_INT 1
88491: ARRAY
88492: EQUAL
88493: IFFALSE 88511
// begin weapon := j [ 2 ] ;
88495: LD_ADDR_VAR 0 8
88499: PUSH
88500: LD_VAR 0 5
88504: PUSH
88505: LD_INT 2
88507: ARRAY
88508: ST_TO_ADDR
// break ;
88509: GO 88513
// end ;
88511: GO 88471
88513: POP
88514: POP
// if not weapon then
88515: LD_VAR 0 8
88519: NOT
88520: IFFALSE 88524
// continue ;
88522: GO 88420
// for k in factories do
88524: LD_ADDR_VAR 0 6
88528: PUSH
88529: LD_VAR 0 2
88533: PUSH
88534: FOR_IN
88535: IFFALSE 88600
// begin weapons := AvailableWeaponList ( k ) ;
88537: LD_ADDR_VAR 0 9
88541: PUSH
88542: LD_VAR 0 6
88546: PPUSH
88547: CALL_OW 478
88551: ST_TO_ADDR
// if not weapons then
88552: LD_VAR 0 9
88556: NOT
88557: IFFALSE 88561
// continue ;
88559: GO 88534
// if weapon in weapons then
88561: LD_VAR 0 8
88565: PUSH
88566: LD_VAR 0 9
88570: IN
88571: IFFALSE 88598
// begin result := [ i , weapon ] ;
88573: LD_ADDR_VAR 0 3
88577: PUSH
88578: LD_VAR 0 4
88582: PUSH
88583: LD_VAR 0 8
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: ST_TO_ADDR
// exit ;
88592: POP
88593: POP
88594: POP
88595: POP
88596: GO 88606
// end ; end ;
88598: GO 88534
88600: POP
88601: POP
// end ;
88602: GO 88420
88604: POP
88605: POP
// end ;
88606: LD_VAR 0 3
88610: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
88611: LD_INT 0
88613: PPUSH
// if not side or side > 8 then
88614: LD_VAR 0 3
88618: NOT
88619: PUSH
88620: LD_VAR 0 3
88624: PUSH
88625: LD_INT 8
88627: GREATER
88628: OR
88629: IFFALSE 88633
// exit ;
88631: GO 88692
// if not range then
88633: LD_VAR 0 4
88637: NOT
88638: IFFALSE 88649
// range := - 12 ;
88640: LD_ADDR_VAR 0 4
88644: PUSH
88645: LD_INT 12
88647: NEG
88648: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
88649: LD_VAR 0 1
88653: PPUSH
88654: LD_VAR 0 2
88658: PPUSH
88659: LD_VAR 0 3
88663: PPUSH
88664: LD_VAR 0 4
88668: PPUSH
88669: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
88673: LD_VAR 0 1
88677: PPUSH
88678: LD_VAR 0 2
88682: PPUSH
88683: LD_VAR 0 3
88687: PPUSH
88688: CALL_OW 331
// end ;
88692: LD_VAR 0 5
88696: RET
// export function Video ( mode ) ; begin
88697: LD_INT 0
88699: PPUSH
// ingame_video = mode ;
88700: LD_ADDR_OWVAR 52
88704: PUSH
88705: LD_VAR 0 1
88709: ST_TO_ADDR
// interface_hidden = mode ;
88710: LD_ADDR_OWVAR 54
88714: PUSH
88715: LD_VAR 0 1
88719: ST_TO_ADDR
// end ;
88720: LD_VAR 0 2
88724: RET
// export function Join ( array , element ) ; begin
88725: LD_INT 0
88727: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88728: LD_ADDR_VAR 0 3
88732: PUSH
88733: LD_VAR 0 1
88737: PPUSH
88738: LD_VAR 0 1
88742: PUSH
88743: LD_INT 1
88745: PLUS
88746: PPUSH
88747: LD_VAR 0 2
88751: PPUSH
88752: CALL_OW 1
88756: ST_TO_ADDR
// end ;
88757: LD_VAR 0 3
88761: RET
// export function JoinUnion ( array , element ) ; begin
88762: LD_INT 0
88764: PPUSH
// result := array union element ;
88765: LD_ADDR_VAR 0 3
88769: PUSH
88770: LD_VAR 0 1
88774: PUSH
88775: LD_VAR 0 2
88779: UNION
88780: ST_TO_ADDR
// end ;
88781: LD_VAR 0 3
88785: RET
// export function GetBehemoths ( side ) ; begin
88786: LD_INT 0
88788: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88789: LD_ADDR_VAR 0 2
88793: PUSH
88794: LD_INT 22
88796: PUSH
88797: LD_VAR 0 1
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: LD_INT 31
88808: PUSH
88809: LD_INT 25
88811: PUSH
88812: EMPTY
88813: LIST
88814: LIST
88815: PUSH
88816: EMPTY
88817: LIST
88818: LIST
88819: PPUSH
88820: CALL_OW 69
88824: ST_TO_ADDR
// end ;
88825: LD_VAR 0 2
88829: RET
// export function Shuffle ( array ) ; var i , index ; begin
88830: LD_INT 0
88832: PPUSH
88833: PPUSH
88834: PPUSH
// result := [ ] ;
88835: LD_ADDR_VAR 0 2
88839: PUSH
88840: EMPTY
88841: ST_TO_ADDR
// if not array then
88842: LD_VAR 0 1
88846: NOT
88847: IFFALSE 88851
// exit ;
88849: GO 88950
// Randomize ;
88851: CALL_OW 10
// for i = array downto 1 do
88855: LD_ADDR_VAR 0 3
88859: PUSH
88860: DOUBLE
88861: LD_VAR 0 1
88865: INC
88866: ST_TO_ADDR
88867: LD_INT 1
88869: PUSH
88870: FOR_DOWNTO
88871: IFFALSE 88948
// begin index := rand ( 1 , array ) ;
88873: LD_ADDR_VAR 0 4
88877: PUSH
88878: LD_INT 1
88880: PPUSH
88881: LD_VAR 0 1
88885: PPUSH
88886: CALL_OW 12
88890: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88891: LD_ADDR_VAR 0 2
88895: PUSH
88896: LD_VAR 0 2
88900: PPUSH
88901: LD_VAR 0 2
88905: PUSH
88906: LD_INT 1
88908: PLUS
88909: PPUSH
88910: LD_VAR 0 1
88914: PUSH
88915: LD_VAR 0 4
88919: ARRAY
88920: PPUSH
88921: CALL_OW 2
88925: ST_TO_ADDR
// array := Delete ( array , index ) ;
88926: LD_ADDR_VAR 0 1
88930: PUSH
88931: LD_VAR 0 1
88935: PPUSH
88936: LD_VAR 0 4
88940: PPUSH
88941: CALL_OW 3
88945: ST_TO_ADDR
// end ;
88946: GO 88870
88948: POP
88949: POP
// end ;
88950: LD_VAR 0 2
88954: RET
// export function GetBaseMaterials ( base ) ; begin
88955: LD_INT 0
88957: PPUSH
// result := [ 0 , 0 , 0 ] ;
88958: LD_ADDR_VAR 0 2
88962: PUSH
88963: LD_INT 0
88965: PUSH
88966: LD_INT 0
88968: PUSH
88969: LD_INT 0
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: LIST
88976: ST_TO_ADDR
// if not base then
88977: LD_VAR 0 1
88981: NOT
88982: IFFALSE 88986
// exit ;
88984: GO 89035
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88986: LD_ADDR_VAR 0 2
88990: PUSH
88991: LD_VAR 0 1
88995: PPUSH
88996: LD_INT 1
88998: PPUSH
88999: CALL_OW 275
89003: PUSH
89004: LD_VAR 0 1
89008: PPUSH
89009: LD_INT 2
89011: PPUSH
89012: CALL_OW 275
89016: PUSH
89017: LD_VAR 0 1
89021: PPUSH
89022: LD_INT 3
89024: PPUSH
89025: CALL_OW 275
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: LIST
89034: ST_TO_ADDR
// end ;
89035: LD_VAR 0 2
89039: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89040: LD_INT 0
89042: PPUSH
89043: PPUSH
// result := array ;
89044: LD_ADDR_VAR 0 3
89048: PUSH
89049: LD_VAR 0 1
89053: ST_TO_ADDR
// if size > 0 then
89054: LD_VAR 0 2
89058: PUSH
89059: LD_INT 0
89061: GREATER
89062: IFFALSE 89108
// for i := array downto size do
89064: LD_ADDR_VAR 0 4
89068: PUSH
89069: DOUBLE
89070: LD_VAR 0 1
89074: INC
89075: ST_TO_ADDR
89076: LD_VAR 0 2
89080: PUSH
89081: FOR_DOWNTO
89082: IFFALSE 89106
// result := Delete ( result , result ) ;
89084: LD_ADDR_VAR 0 3
89088: PUSH
89089: LD_VAR 0 3
89093: PPUSH
89094: LD_VAR 0 3
89098: PPUSH
89099: CALL_OW 3
89103: ST_TO_ADDR
89104: GO 89081
89106: POP
89107: POP
// end ;
89108: LD_VAR 0 3
89112: RET
// export function ComExit ( unit ) ; var tmp ; begin
89113: LD_INT 0
89115: PPUSH
89116: PPUSH
// if not IsInUnit ( unit ) then
89117: LD_VAR 0 1
89121: PPUSH
89122: CALL_OW 310
89126: NOT
89127: IFFALSE 89131
// exit ;
89129: GO 89191
// tmp := IsInUnit ( unit ) ;
89131: LD_ADDR_VAR 0 3
89135: PUSH
89136: LD_VAR 0 1
89140: PPUSH
89141: CALL_OW 310
89145: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89146: LD_VAR 0 3
89150: PPUSH
89151: CALL_OW 247
89155: PUSH
89156: LD_INT 2
89158: EQUAL
89159: IFFALSE 89172
// ComExitVehicle ( unit ) else
89161: LD_VAR 0 1
89165: PPUSH
89166: CALL_OW 121
89170: GO 89181
// ComExitBuilding ( unit ) ;
89172: LD_VAR 0 1
89176: PPUSH
89177: CALL_OW 122
// result := tmp ;
89181: LD_ADDR_VAR 0 2
89185: PUSH
89186: LD_VAR 0 3
89190: ST_TO_ADDR
// end ;
89191: LD_VAR 0 2
89195: RET
// export function ComExitAll ( units ) ; var i ; begin
89196: LD_INT 0
89198: PPUSH
89199: PPUSH
// if not units then
89200: LD_VAR 0 1
89204: NOT
89205: IFFALSE 89209
// exit ;
89207: GO 89235
// for i in units do
89209: LD_ADDR_VAR 0 3
89213: PUSH
89214: LD_VAR 0 1
89218: PUSH
89219: FOR_IN
89220: IFFALSE 89233
// ComExit ( i ) ;
89222: LD_VAR 0 3
89226: PPUSH
89227: CALL 89113 0 1
89231: GO 89219
89233: POP
89234: POP
// end ;
89235: LD_VAR 0 2
89239: RET
// export function ResetHc ; begin
89240: LD_INT 0
89242: PPUSH
// InitHc ;
89243: CALL_OW 19
// hc_importance := 0 ;
89247: LD_ADDR_OWVAR 32
89251: PUSH
89252: LD_INT 0
89254: ST_TO_ADDR
// end ;
89255: LD_VAR 0 1
89259: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89260: LD_INT 0
89262: PPUSH
89263: PPUSH
89264: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89265: LD_ADDR_VAR 0 6
89269: PUSH
89270: LD_VAR 0 1
89274: PUSH
89275: LD_VAR 0 3
89279: PLUS
89280: PUSH
89281: LD_INT 2
89283: DIV
89284: ST_TO_ADDR
// if _x < 0 then
89285: LD_VAR 0 6
89289: PUSH
89290: LD_INT 0
89292: LESS
89293: IFFALSE 89310
// _x := _x * - 1 ;
89295: LD_ADDR_VAR 0 6
89299: PUSH
89300: LD_VAR 0 6
89304: PUSH
89305: LD_INT 1
89307: NEG
89308: MUL
89309: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
89310: LD_ADDR_VAR 0 7
89314: PUSH
89315: LD_VAR 0 2
89319: PUSH
89320: LD_VAR 0 4
89324: PLUS
89325: PUSH
89326: LD_INT 2
89328: DIV
89329: ST_TO_ADDR
// if _y < 0 then
89330: LD_VAR 0 7
89334: PUSH
89335: LD_INT 0
89337: LESS
89338: IFFALSE 89355
// _y := _y * - 1 ;
89340: LD_ADDR_VAR 0 7
89344: PUSH
89345: LD_VAR 0 7
89349: PUSH
89350: LD_INT 1
89352: NEG
89353: MUL
89354: ST_TO_ADDR
// result := [ _x , _y ] ;
89355: LD_ADDR_VAR 0 5
89359: PUSH
89360: LD_VAR 0 6
89364: PUSH
89365: LD_VAR 0 7
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: ST_TO_ADDR
// end ;
89374: LD_VAR 0 5
89378: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
89379: LD_INT 0
89381: PPUSH
89382: PPUSH
89383: PPUSH
89384: PPUSH
// task := GetTaskList ( unit ) ;
89385: LD_ADDR_VAR 0 7
89389: PUSH
89390: LD_VAR 0 1
89394: PPUSH
89395: CALL_OW 437
89399: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
89400: LD_VAR 0 7
89404: NOT
89405: PUSH
89406: LD_VAR 0 1
89410: PPUSH
89411: LD_VAR 0 2
89415: PPUSH
89416: CALL_OW 308
89420: NOT
89421: AND
89422: IFFALSE 89426
// exit ;
89424: GO 89544
// if IsInArea ( unit , area ) then
89426: LD_VAR 0 1
89430: PPUSH
89431: LD_VAR 0 2
89435: PPUSH
89436: CALL_OW 308
89440: IFFALSE 89458
// begin ComMoveToArea ( unit , goAway ) ;
89442: LD_VAR 0 1
89446: PPUSH
89447: LD_VAR 0 3
89451: PPUSH
89452: CALL_OW 113
// exit ;
89456: GO 89544
// end ; if task [ 1 ] [ 1 ] <> M then
89458: LD_VAR 0 7
89462: PUSH
89463: LD_INT 1
89465: ARRAY
89466: PUSH
89467: LD_INT 1
89469: ARRAY
89470: PUSH
89471: LD_STRING M
89473: NONEQUAL
89474: IFFALSE 89478
// exit ;
89476: GO 89544
// x := task [ 1 ] [ 2 ] ;
89478: LD_ADDR_VAR 0 5
89482: PUSH
89483: LD_VAR 0 7
89487: PUSH
89488: LD_INT 1
89490: ARRAY
89491: PUSH
89492: LD_INT 2
89494: ARRAY
89495: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
89496: LD_ADDR_VAR 0 6
89500: PUSH
89501: LD_VAR 0 7
89505: PUSH
89506: LD_INT 1
89508: ARRAY
89509: PUSH
89510: LD_INT 3
89512: ARRAY
89513: ST_TO_ADDR
// if InArea ( x , y , area ) then
89514: LD_VAR 0 5
89518: PPUSH
89519: LD_VAR 0 6
89523: PPUSH
89524: LD_VAR 0 2
89528: PPUSH
89529: CALL_OW 309
89533: IFFALSE 89544
// ComStop ( unit ) ;
89535: LD_VAR 0 1
89539: PPUSH
89540: CALL_OW 141
// end ;
89544: LD_VAR 0 4
89548: RET
// export function Abs ( value ) ; begin
89549: LD_INT 0
89551: PPUSH
// result := value ;
89552: LD_ADDR_VAR 0 2
89556: PUSH
89557: LD_VAR 0 1
89561: ST_TO_ADDR
// if value < 0 then
89562: LD_VAR 0 1
89566: PUSH
89567: LD_INT 0
89569: LESS
89570: IFFALSE 89587
// result := value * - 1 ;
89572: LD_ADDR_VAR 0 2
89576: PUSH
89577: LD_VAR 0 1
89581: PUSH
89582: LD_INT 1
89584: NEG
89585: MUL
89586: ST_TO_ADDR
// end ;
89587: LD_VAR 0 2
89591: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
89592: LD_INT 0
89594: PPUSH
89595: PPUSH
89596: PPUSH
89597: PPUSH
89598: PPUSH
89599: PPUSH
89600: PPUSH
89601: PPUSH
// if not unit or not building then
89602: LD_VAR 0 1
89606: NOT
89607: PUSH
89608: LD_VAR 0 2
89612: NOT
89613: OR
89614: IFFALSE 89618
// exit ;
89616: GO 89844
// x := GetX ( building ) ;
89618: LD_ADDR_VAR 0 4
89622: PUSH
89623: LD_VAR 0 2
89627: PPUSH
89628: CALL_OW 250
89632: ST_TO_ADDR
// y := GetY ( building ) ;
89633: LD_ADDR_VAR 0 6
89637: PUSH
89638: LD_VAR 0 2
89642: PPUSH
89643: CALL_OW 251
89647: ST_TO_ADDR
// d := GetDir ( building ) ;
89648: LD_ADDR_VAR 0 8
89652: PUSH
89653: LD_VAR 0 2
89657: PPUSH
89658: CALL_OW 254
89662: ST_TO_ADDR
// r := 4 ;
89663: LD_ADDR_VAR 0 9
89667: PUSH
89668: LD_INT 4
89670: ST_TO_ADDR
// for i := 1 to 5 do
89671: LD_ADDR_VAR 0 10
89675: PUSH
89676: DOUBLE
89677: LD_INT 1
89679: DEC
89680: ST_TO_ADDR
89681: LD_INT 5
89683: PUSH
89684: FOR_TO
89685: IFFALSE 89842
// begin _x := ShiftX ( x , d , r + i ) ;
89687: LD_ADDR_VAR 0 5
89691: PUSH
89692: LD_VAR 0 4
89696: PPUSH
89697: LD_VAR 0 8
89701: PPUSH
89702: LD_VAR 0 9
89706: PUSH
89707: LD_VAR 0 10
89711: PLUS
89712: PPUSH
89713: CALL_OW 272
89717: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89718: LD_ADDR_VAR 0 7
89722: PUSH
89723: LD_VAR 0 6
89727: PPUSH
89728: LD_VAR 0 8
89732: PPUSH
89733: LD_VAR 0 9
89737: PUSH
89738: LD_VAR 0 10
89742: PLUS
89743: PPUSH
89744: CALL_OW 273
89748: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89749: LD_VAR 0 5
89753: PPUSH
89754: LD_VAR 0 7
89758: PPUSH
89759: CALL_OW 488
89763: PUSH
89764: LD_VAR 0 5
89768: PPUSH
89769: LD_VAR 0 7
89773: PPUSH
89774: CALL_OW 428
89778: PPUSH
89779: CALL_OW 247
89783: PUSH
89784: LD_INT 3
89786: PUSH
89787: LD_INT 2
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: IN
89794: NOT
89795: AND
89796: IFFALSE 89840
// begin ComMoveXY ( unit , _x , _y ) ;
89798: LD_VAR 0 1
89802: PPUSH
89803: LD_VAR 0 5
89807: PPUSH
89808: LD_VAR 0 7
89812: PPUSH
89813: CALL_OW 111
// result := [ _x , _y ] ;
89817: LD_ADDR_VAR 0 3
89821: PUSH
89822: LD_VAR 0 5
89826: PUSH
89827: LD_VAR 0 7
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: ST_TO_ADDR
// exit ;
89836: POP
89837: POP
89838: GO 89844
// end ; end ;
89840: GO 89684
89842: POP
89843: POP
// end ;
89844: LD_VAR 0 3
89848: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89849: LD_INT 0
89851: PPUSH
89852: PPUSH
89853: PPUSH
// result := 0 ;
89854: LD_ADDR_VAR 0 3
89858: PUSH
89859: LD_INT 0
89861: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89862: LD_VAR 0 1
89866: PUSH
89867: LD_INT 0
89869: LESS
89870: PUSH
89871: LD_VAR 0 1
89875: PUSH
89876: LD_INT 8
89878: GREATER
89879: OR
89880: PUSH
89881: LD_VAR 0 2
89885: PUSH
89886: LD_INT 0
89888: LESS
89889: OR
89890: PUSH
89891: LD_VAR 0 2
89895: PUSH
89896: LD_INT 8
89898: GREATER
89899: OR
89900: IFFALSE 89904
// exit ;
89902: GO 89979
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89904: LD_ADDR_VAR 0 4
89908: PUSH
89909: LD_INT 22
89911: PUSH
89912: LD_VAR 0 2
89916: PUSH
89917: EMPTY
89918: LIST
89919: LIST
89920: PPUSH
89921: CALL_OW 69
89925: PUSH
89926: FOR_IN
89927: IFFALSE 89977
// begin un := UnitShoot ( i ) ;
89929: LD_ADDR_VAR 0 5
89933: PUSH
89934: LD_VAR 0 4
89938: PPUSH
89939: CALL_OW 504
89943: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89944: LD_VAR 0 5
89948: PPUSH
89949: CALL_OW 255
89953: PUSH
89954: LD_VAR 0 1
89958: EQUAL
89959: IFFALSE 89975
// begin result := un ;
89961: LD_ADDR_VAR 0 3
89965: PUSH
89966: LD_VAR 0 5
89970: ST_TO_ADDR
// exit ;
89971: POP
89972: POP
89973: GO 89979
// end ; end ;
89975: GO 89926
89977: POP
89978: POP
// end ;
89979: LD_VAR 0 3
89983: RET
// export function GetCargoBay ( units ) ; begin
89984: LD_INT 0
89986: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89987: LD_ADDR_VAR 0 2
89991: PUSH
89992: LD_VAR 0 1
89996: PPUSH
89997: LD_INT 2
89999: PUSH
90000: LD_INT 34
90002: PUSH
90003: LD_INT 12
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 34
90012: PUSH
90013: LD_INT 51
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 34
90022: PUSH
90023: LD_INT 32
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 34
90032: PUSH
90033: LD_EXP 75
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: PPUSH
90049: CALL_OW 72
90053: ST_TO_ADDR
// end ;
90054: LD_VAR 0 2
90058: RET
// export function Negate ( value ) ; begin
90059: LD_INT 0
90061: PPUSH
// result := not value ;
90062: LD_ADDR_VAR 0 2
90066: PUSH
90067: LD_VAR 0 1
90071: NOT
90072: ST_TO_ADDR
// end ;
90073: LD_VAR 0 2
90077: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
90078: LD_INT 0
90080: PPUSH
// if x1 = x2 then
90081: LD_VAR 0 1
90085: PUSH
90086: LD_VAR 0 3
90090: EQUAL
90091: IFFALSE 90125
// begin if y1 > y2 then
90093: LD_VAR 0 2
90097: PUSH
90098: LD_VAR 0 4
90102: GREATER
90103: IFFALSE 90115
// result := 0 else
90105: LD_ADDR_VAR 0 5
90109: PUSH
90110: LD_INT 0
90112: ST_TO_ADDR
90113: GO 90123
// result := 3 ;
90115: LD_ADDR_VAR 0 5
90119: PUSH
90120: LD_INT 3
90122: ST_TO_ADDR
// exit ;
90123: GO 90211
// end ; if y1 = y2 then
90125: LD_VAR 0 2
90129: PUSH
90130: LD_VAR 0 4
90134: EQUAL
90135: IFFALSE 90169
// begin if x1 > x2 then
90137: LD_VAR 0 1
90141: PUSH
90142: LD_VAR 0 3
90146: GREATER
90147: IFFALSE 90159
// result := 1 else
90149: LD_ADDR_VAR 0 5
90153: PUSH
90154: LD_INT 1
90156: ST_TO_ADDR
90157: GO 90167
// result := 4 ;
90159: LD_ADDR_VAR 0 5
90163: PUSH
90164: LD_INT 4
90166: ST_TO_ADDR
// exit ;
90167: GO 90211
// end ; if x1 > x2 and y1 > y2 then
90169: LD_VAR 0 1
90173: PUSH
90174: LD_VAR 0 3
90178: GREATER
90179: PUSH
90180: LD_VAR 0 2
90184: PUSH
90185: LD_VAR 0 4
90189: GREATER
90190: AND
90191: IFFALSE 90203
// result := 2 else
90193: LD_ADDR_VAR 0 5
90197: PUSH
90198: LD_INT 2
90200: ST_TO_ADDR
90201: GO 90211
// result := 5 ;
90203: LD_ADDR_VAR 0 5
90207: PUSH
90208: LD_INT 5
90210: ST_TO_ADDR
// end ;
90211: LD_VAR 0 5
90215: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90216: LD_INT 0
90218: PPUSH
90219: PPUSH
// if not driver or not IsInUnit ( driver ) then
90220: LD_VAR 0 1
90224: NOT
90225: PUSH
90226: LD_VAR 0 1
90230: PPUSH
90231: CALL_OW 310
90235: NOT
90236: OR
90237: IFFALSE 90241
// exit ;
90239: GO 90331
// vehicle := IsInUnit ( driver ) ;
90241: LD_ADDR_VAR 0 3
90245: PUSH
90246: LD_VAR 0 1
90250: PPUSH
90251: CALL_OW 310
90255: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90256: LD_VAR 0 1
90260: PPUSH
90261: LD_STRING \
90263: PUSH
90264: LD_INT 0
90266: PUSH
90267: LD_INT 0
90269: PUSH
90270: LD_INT 0
90272: PUSH
90273: LD_INT 0
90275: PUSH
90276: LD_INT 0
90278: PUSH
90279: LD_INT 0
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: PUSH
90291: LD_STRING E
90293: PUSH
90294: LD_INT 0
90296: PUSH
90297: LD_INT 0
90299: PUSH
90300: LD_VAR 0 3
90304: PUSH
90305: LD_INT 0
90307: PUSH
90308: LD_INT 0
90310: PUSH
90311: LD_INT 0
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PPUSH
90327: CALL_OW 446
// end ;
90331: LD_VAR 0 2
90335: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90336: LD_INT 0
90338: PPUSH
90339: PPUSH
// if not driver or not IsInUnit ( driver ) then
90340: LD_VAR 0 1
90344: NOT
90345: PUSH
90346: LD_VAR 0 1
90350: PPUSH
90351: CALL_OW 310
90355: NOT
90356: OR
90357: IFFALSE 90361
// exit ;
90359: GO 90451
// vehicle := IsInUnit ( driver ) ;
90361: LD_ADDR_VAR 0 3
90365: PUSH
90366: LD_VAR 0 1
90370: PPUSH
90371: CALL_OW 310
90375: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90376: LD_VAR 0 1
90380: PPUSH
90381: LD_STRING \
90383: PUSH
90384: LD_INT 0
90386: PUSH
90387: LD_INT 0
90389: PUSH
90390: LD_INT 0
90392: PUSH
90393: LD_INT 0
90395: PUSH
90396: LD_INT 0
90398: PUSH
90399: LD_INT 0
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: PUSH
90411: LD_STRING E
90413: PUSH
90414: LD_INT 0
90416: PUSH
90417: LD_INT 0
90419: PUSH
90420: LD_VAR 0 3
90424: PUSH
90425: LD_INT 0
90427: PUSH
90428: LD_INT 0
90430: PUSH
90431: LD_INT 0
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PPUSH
90447: CALL_OW 447
// end ;
90451: LD_VAR 0 2
90455: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
90456: LD_INT 0
90458: PPUSH
90459: PPUSH
90460: PPUSH
// tmp := [ ] ;
90461: LD_ADDR_VAR 0 5
90465: PUSH
90466: EMPTY
90467: ST_TO_ADDR
// for i in units do
90468: LD_ADDR_VAR 0 4
90472: PUSH
90473: LD_VAR 0 1
90477: PUSH
90478: FOR_IN
90479: IFFALSE 90517
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
90481: LD_ADDR_VAR 0 5
90485: PUSH
90486: LD_VAR 0 5
90490: PPUSH
90491: LD_VAR 0 5
90495: PUSH
90496: LD_INT 1
90498: PLUS
90499: PPUSH
90500: LD_VAR 0 4
90504: PPUSH
90505: CALL_OW 256
90509: PPUSH
90510: CALL_OW 2
90514: ST_TO_ADDR
90515: GO 90478
90517: POP
90518: POP
// if not tmp then
90519: LD_VAR 0 5
90523: NOT
90524: IFFALSE 90528
// exit ;
90526: GO 90576
// if asc then
90528: LD_VAR 0 2
90532: IFFALSE 90556
// result := SortListByListAsc ( units , tmp ) else
90534: LD_ADDR_VAR 0 3
90538: PUSH
90539: LD_VAR 0 1
90543: PPUSH
90544: LD_VAR 0 5
90548: PPUSH
90549: CALL_OW 76
90553: ST_TO_ADDR
90554: GO 90576
// result := SortListByListDesc ( units , tmp ) ;
90556: LD_ADDR_VAR 0 3
90560: PUSH
90561: LD_VAR 0 1
90565: PPUSH
90566: LD_VAR 0 5
90570: PPUSH
90571: CALL_OW 77
90575: ST_TO_ADDR
// end ;
90576: LD_VAR 0 3
90580: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
90581: LD_INT 0
90583: PPUSH
90584: PPUSH
// task := GetTaskList ( mech ) ;
90585: LD_ADDR_VAR 0 4
90589: PUSH
90590: LD_VAR 0 1
90594: PPUSH
90595: CALL_OW 437
90599: ST_TO_ADDR
// if not task then
90600: LD_VAR 0 4
90604: NOT
90605: IFFALSE 90609
// exit ;
90607: GO 90651
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
90609: LD_ADDR_VAR 0 3
90613: PUSH
90614: LD_VAR 0 4
90618: PUSH
90619: LD_INT 1
90621: ARRAY
90622: PUSH
90623: LD_INT 1
90625: ARRAY
90626: PUSH
90627: LD_STRING r
90629: EQUAL
90630: PUSH
90631: LD_VAR 0 4
90635: PUSH
90636: LD_INT 1
90638: ARRAY
90639: PUSH
90640: LD_INT 4
90642: ARRAY
90643: PUSH
90644: LD_VAR 0 2
90648: EQUAL
90649: AND
90650: ST_TO_ADDR
// end ;
90651: LD_VAR 0 3
90655: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
90656: LD_INT 0
90658: PPUSH
// SetDir ( unit , d ) ;
90659: LD_VAR 0 1
90663: PPUSH
90664: LD_VAR 0 4
90668: PPUSH
90669: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
90673: LD_VAR 0 1
90677: PPUSH
90678: LD_VAR 0 2
90682: PPUSH
90683: LD_VAR 0 3
90687: PPUSH
90688: LD_VAR 0 5
90692: PPUSH
90693: CALL_OW 48
// end ;
90697: LD_VAR 0 6
90701: RET
// export function ToNaturalNumber ( number ) ; begin
90702: LD_INT 0
90704: PPUSH
// result := number div 1 ;
90705: LD_ADDR_VAR 0 2
90709: PUSH
90710: LD_VAR 0 1
90714: PUSH
90715: LD_INT 1
90717: DIV
90718: ST_TO_ADDR
// if number < 0 then
90719: LD_VAR 0 1
90723: PUSH
90724: LD_INT 0
90726: LESS
90727: IFFALSE 90737
// result := 0 ;
90729: LD_ADDR_VAR 0 2
90733: PUSH
90734: LD_INT 0
90736: ST_TO_ADDR
// end ;
90737: LD_VAR 0 2
90741: RET
// export function SortByClass ( units , class ) ; var un ; begin
90742: LD_INT 0
90744: PPUSH
90745: PPUSH
// if not units or not class then
90746: LD_VAR 0 1
90750: NOT
90751: PUSH
90752: LD_VAR 0 2
90756: NOT
90757: OR
90758: IFFALSE 90762
// exit ;
90760: GO 90857
// result := [ ] ;
90762: LD_ADDR_VAR 0 3
90766: PUSH
90767: EMPTY
90768: ST_TO_ADDR
// for un in units do
90769: LD_ADDR_VAR 0 4
90773: PUSH
90774: LD_VAR 0 1
90778: PUSH
90779: FOR_IN
90780: IFFALSE 90855
// if GetClass ( un ) = class then
90782: LD_VAR 0 4
90786: PPUSH
90787: CALL_OW 257
90791: PUSH
90792: LD_VAR 0 2
90796: EQUAL
90797: IFFALSE 90824
// result := Insert ( result , 1 , un ) else
90799: LD_ADDR_VAR 0 3
90803: PUSH
90804: LD_VAR 0 3
90808: PPUSH
90809: LD_INT 1
90811: PPUSH
90812: LD_VAR 0 4
90816: PPUSH
90817: CALL_OW 2
90821: ST_TO_ADDR
90822: GO 90853
// result := Replace ( result , result + 1 , un ) ;
90824: LD_ADDR_VAR 0 3
90828: PUSH
90829: LD_VAR 0 3
90833: PPUSH
90834: LD_VAR 0 3
90838: PUSH
90839: LD_INT 1
90841: PLUS
90842: PPUSH
90843: LD_VAR 0 4
90847: PPUSH
90848: CALL_OW 1
90852: ST_TO_ADDR
90853: GO 90779
90855: POP
90856: POP
// end ;
90857: LD_VAR 0 3
90861: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
90862: LD_INT 0
90864: PPUSH
90865: PPUSH
90866: PPUSH
90867: PPUSH
90868: PPUSH
90869: PPUSH
90870: PPUSH
// result := [ ] ;
90871: LD_ADDR_VAR 0 4
90875: PUSH
90876: EMPTY
90877: ST_TO_ADDR
// if x - r < 0 then
90878: LD_VAR 0 1
90882: PUSH
90883: LD_VAR 0 3
90887: MINUS
90888: PUSH
90889: LD_INT 0
90891: LESS
90892: IFFALSE 90904
// min_x := 0 else
90894: LD_ADDR_VAR 0 8
90898: PUSH
90899: LD_INT 0
90901: ST_TO_ADDR
90902: GO 90920
// min_x := x - r ;
90904: LD_ADDR_VAR 0 8
90908: PUSH
90909: LD_VAR 0 1
90913: PUSH
90914: LD_VAR 0 3
90918: MINUS
90919: ST_TO_ADDR
// if y - r < 0 then
90920: LD_VAR 0 2
90924: PUSH
90925: LD_VAR 0 3
90929: MINUS
90930: PUSH
90931: LD_INT 0
90933: LESS
90934: IFFALSE 90946
// min_y := 0 else
90936: LD_ADDR_VAR 0 7
90940: PUSH
90941: LD_INT 0
90943: ST_TO_ADDR
90944: GO 90962
// min_y := y - r ;
90946: LD_ADDR_VAR 0 7
90950: PUSH
90951: LD_VAR 0 2
90955: PUSH
90956: LD_VAR 0 3
90960: MINUS
90961: ST_TO_ADDR
// max_x := x + r ;
90962: LD_ADDR_VAR 0 9
90966: PUSH
90967: LD_VAR 0 1
90971: PUSH
90972: LD_VAR 0 3
90976: PLUS
90977: ST_TO_ADDR
// max_y := y + r ;
90978: LD_ADDR_VAR 0 10
90982: PUSH
90983: LD_VAR 0 2
90987: PUSH
90988: LD_VAR 0 3
90992: PLUS
90993: ST_TO_ADDR
// for _x = min_x to max_x do
90994: LD_ADDR_VAR 0 5
90998: PUSH
90999: DOUBLE
91000: LD_VAR 0 8
91004: DEC
91005: ST_TO_ADDR
91006: LD_VAR 0 9
91010: PUSH
91011: FOR_TO
91012: IFFALSE 91113
// for _y = min_y to max_y do
91014: LD_ADDR_VAR 0 6
91018: PUSH
91019: DOUBLE
91020: LD_VAR 0 7
91024: DEC
91025: ST_TO_ADDR
91026: LD_VAR 0 10
91030: PUSH
91031: FOR_TO
91032: IFFALSE 91109
// begin if not ValidHex ( _x , _y ) then
91034: LD_VAR 0 5
91038: PPUSH
91039: LD_VAR 0 6
91043: PPUSH
91044: CALL_OW 488
91048: NOT
91049: IFFALSE 91053
// continue ;
91051: GO 91031
// if GetResourceTypeXY ( _x , _y ) then
91053: LD_VAR 0 5
91057: PPUSH
91058: LD_VAR 0 6
91062: PPUSH
91063: CALL_OW 283
91067: IFFALSE 91107
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91069: LD_ADDR_VAR 0 4
91073: PUSH
91074: LD_VAR 0 4
91078: PPUSH
91079: LD_VAR 0 4
91083: PUSH
91084: LD_INT 1
91086: PLUS
91087: PPUSH
91088: LD_VAR 0 5
91092: PUSH
91093: LD_VAR 0 6
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PPUSH
91102: CALL_OW 1
91106: ST_TO_ADDR
// end ;
91107: GO 91031
91109: POP
91110: POP
91111: GO 91011
91113: POP
91114: POP
// end ;
91115: LD_VAR 0 4
91119: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
91120: LD_INT 0
91122: PPUSH
91123: PPUSH
91124: PPUSH
91125: PPUSH
91126: PPUSH
91127: PPUSH
// if not units then
91128: LD_VAR 0 1
91132: NOT
91133: IFFALSE 91137
// exit ;
91135: GO 91538
// result := UnitFilter ( units , [ f_ok ] ) ;
91137: LD_ADDR_VAR 0 3
91141: PUSH
91142: LD_VAR 0 1
91146: PPUSH
91147: LD_INT 50
91149: PUSH
91150: EMPTY
91151: LIST
91152: PPUSH
91153: CALL_OW 72
91157: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
91158: LD_ADDR_VAR 0 7
91162: PUSH
91163: LD_VAR 0 1
91167: PUSH
91168: LD_INT 1
91170: ARRAY
91171: PPUSH
91172: CALL_OW 255
91176: ST_TO_ADDR
// if not result then
91177: LD_VAR 0 3
91181: NOT
91182: IFFALSE 91186
// exit ;
91184: GO 91538
// for i in result do
91186: LD_ADDR_VAR 0 4
91190: PUSH
91191: LD_VAR 0 3
91195: PUSH
91196: FOR_IN
91197: IFFALSE 91536
// begin tag := GetTag ( i ) + 1 ;
91199: LD_ADDR_VAR 0 8
91203: PUSH
91204: LD_VAR 0 4
91208: PPUSH
91209: CALL_OW 110
91213: PUSH
91214: LD_INT 1
91216: PLUS
91217: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
91218: LD_ADDR_VAR 0 6
91222: PUSH
91223: LD_VAR 0 4
91227: PPUSH
91228: CALL_OW 250
91232: PPUSH
91233: LD_VAR 0 4
91237: PPUSH
91238: CALL_OW 251
91242: PPUSH
91243: LD_INT 6
91245: PPUSH
91246: CALL 90862 0 3
91250: ST_TO_ADDR
// if cr then
91251: LD_VAR 0 6
91255: IFFALSE 91294
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
91257: LD_VAR 0 4
91261: PPUSH
91262: LD_VAR 0 6
91266: PUSH
91267: LD_INT 1
91269: ARRAY
91270: PUSH
91271: LD_INT 1
91273: ARRAY
91274: PPUSH
91275: LD_VAR 0 6
91279: PUSH
91280: LD_INT 1
91282: ARRAY
91283: PUSH
91284: LD_INT 2
91286: ARRAY
91287: PPUSH
91288: CALL_OW 116
91292: GO 91534
// if path > tag then
91294: LD_VAR 0 2
91298: PUSH
91299: LD_VAR 0 8
91303: GREATER
91304: IFFALSE 91482
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
91306: LD_ADDR_VAR 0 5
91310: PUSH
91311: LD_INT 81
91313: PUSH
91314: LD_VAR 0 7
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 91
91325: PUSH
91326: LD_VAR 0 4
91330: PUSH
91331: LD_INT 12
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: LIST
91338: PUSH
91339: EMPTY
91340: LIST
91341: LIST
91342: PPUSH
91343: CALL_OW 69
91347: ST_TO_ADDR
// if enemy then
91348: LD_VAR 0 5
91352: IFFALSE 91380
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
91354: LD_VAR 0 4
91358: PPUSH
91359: LD_VAR 0 5
91363: PPUSH
91364: LD_VAR 0 4
91368: PPUSH
91369: CALL_OW 74
91373: PPUSH
91374: CALL_OW 115
91378: GO 91480
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
91380: LD_VAR 0 4
91384: PPUSH
91385: LD_VAR 0 2
91389: PUSH
91390: LD_VAR 0 8
91394: ARRAY
91395: PUSH
91396: LD_INT 1
91398: ARRAY
91399: PPUSH
91400: LD_VAR 0 2
91404: PUSH
91405: LD_VAR 0 8
91409: ARRAY
91410: PUSH
91411: LD_INT 2
91413: ARRAY
91414: PPUSH
91415: CALL_OW 297
91419: PUSH
91420: LD_INT 6
91422: GREATER
91423: IFFALSE 91466
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
91425: LD_VAR 0 4
91429: PPUSH
91430: LD_VAR 0 2
91434: PUSH
91435: LD_VAR 0 8
91439: ARRAY
91440: PUSH
91441: LD_INT 1
91443: ARRAY
91444: PPUSH
91445: LD_VAR 0 2
91449: PUSH
91450: LD_VAR 0 8
91454: ARRAY
91455: PUSH
91456: LD_INT 2
91458: ARRAY
91459: PPUSH
91460: CALL_OW 114
91464: GO 91480
// SetTag ( i , tag ) ;
91466: LD_VAR 0 4
91470: PPUSH
91471: LD_VAR 0 8
91475: PPUSH
91476: CALL_OW 109
// end else
91480: GO 91534
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
91482: LD_ADDR_VAR 0 5
91486: PUSH
91487: LD_INT 81
91489: PUSH
91490: LD_VAR 0 7
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PPUSH
91499: CALL_OW 69
91503: ST_TO_ADDR
// if enemy then
91504: LD_VAR 0 5
91508: IFFALSE 91534
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
91510: LD_VAR 0 4
91514: PPUSH
91515: LD_VAR 0 5
91519: PPUSH
91520: LD_VAR 0 4
91524: PPUSH
91525: CALL_OW 74
91529: PPUSH
91530: CALL_OW 115
// end ; end ;
91534: GO 91196
91536: POP
91537: POP
// end ; end_of_file end_of_file
91538: LD_VAR 0 3
91542: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91543: LD_INT 0
91545: PPUSH
// if p2 = 100 then
91546: LD_VAR 0 2
91550: PUSH
91551: LD_INT 100
91553: EQUAL
91554: IFFALSE 92557
// begin if not StreamModeActive then
91556: LD_EXP 139
91560: NOT
91561: IFFALSE 91571
// StreamModeActive := true ;
91563: LD_ADDR_EXP 139
91567: PUSH
91568: LD_INT 1
91570: ST_TO_ADDR
// if p3 = 0 then
91571: LD_VAR 0 3
91575: PUSH
91576: LD_INT 0
91578: EQUAL
91579: IFFALSE 91585
// InitStreamMode ;
91581: CALL 92717 0 0
// if p3 = 1 then
91585: LD_VAR 0 3
91589: PUSH
91590: LD_INT 1
91592: EQUAL
91593: IFFALSE 91603
// sRocket := true ;
91595: LD_ADDR_EXP 144
91599: PUSH
91600: LD_INT 1
91602: ST_TO_ADDR
// if p3 = 2 then
91603: LD_VAR 0 3
91607: PUSH
91608: LD_INT 2
91610: EQUAL
91611: IFFALSE 91621
// sSpeed := true ;
91613: LD_ADDR_EXP 143
91617: PUSH
91618: LD_INT 1
91620: ST_TO_ADDR
// if p3 = 3 then
91621: LD_VAR 0 3
91625: PUSH
91626: LD_INT 3
91628: EQUAL
91629: IFFALSE 91639
// sEngine := true ;
91631: LD_ADDR_EXP 145
91635: PUSH
91636: LD_INT 1
91638: ST_TO_ADDR
// if p3 = 4 then
91639: LD_VAR 0 3
91643: PUSH
91644: LD_INT 4
91646: EQUAL
91647: IFFALSE 91657
// sSpec := true ;
91649: LD_ADDR_EXP 142
91653: PUSH
91654: LD_INT 1
91656: ST_TO_ADDR
// if p3 = 5 then
91657: LD_VAR 0 3
91661: PUSH
91662: LD_INT 5
91664: EQUAL
91665: IFFALSE 91675
// sLevel := true ;
91667: LD_ADDR_EXP 146
91671: PUSH
91672: LD_INT 1
91674: ST_TO_ADDR
// if p3 = 6 then
91675: LD_VAR 0 3
91679: PUSH
91680: LD_INT 6
91682: EQUAL
91683: IFFALSE 91693
// sArmoury := true ;
91685: LD_ADDR_EXP 147
91689: PUSH
91690: LD_INT 1
91692: ST_TO_ADDR
// if p3 = 7 then
91693: LD_VAR 0 3
91697: PUSH
91698: LD_INT 7
91700: EQUAL
91701: IFFALSE 91711
// sRadar := true ;
91703: LD_ADDR_EXP 148
91707: PUSH
91708: LD_INT 1
91710: ST_TO_ADDR
// if p3 = 8 then
91711: LD_VAR 0 3
91715: PUSH
91716: LD_INT 8
91718: EQUAL
91719: IFFALSE 91729
// sBunker := true ;
91721: LD_ADDR_EXP 149
91725: PUSH
91726: LD_INT 1
91728: ST_TO_ADDR
// if p3 = 9 then
91729: LD_VAR 0 3
91733: PUSH
91734: LD_INT 9
91736: EQUAL
91737: IFFALSE 91747
// sHack := true ;
91739: LD_ADDR_EXP 150
91743: PUSH
91744: LD_INT 1
91746: ST_TO_ADDR
// if p3 = 10 then
91747: LD_VAR 0 3
91751: PUSH
91752: LD_INT 10
91754: EQUAL
91755: IFFALSE 91765
// sFire := true ;
91757: LD_ADDR_EXP 151
91761: PUSH
91762: LD_INT 1
91764: ST_TO_ADDR
// if p3 = 11 then
91765: LD_VAR 0 3
91769: PUSH
91770: LD_INT 11
91772: EQUAL
91773: IFFALSE 91783
// sRefresh := true ;
91775: LD_ADDR_EXP 152
91779: PUSH
91780: LD_INT 1
91782: ST_TO_ADDR
// if p3 = 12 then
91783: LD_VAR 0 3
91787: PUSH
91788: LD_INT 12
91790: EQUAL
91791: IFFALSE 91801
// sExp := true ;
91793: LD_ADDR_EXP 153
91797: PUSH
91798: LD_INT 1
91800: ST_TO_ADDR
// if p3 = 13 then
91801: LD_VAR 0 3
91805: PUSH
91806: LD_INT 13
91808: EQUAL
91809: IFFALSE 91819
// sDepot := true ;
91811: LD_ADDR_EXP 154
91815: PUSH
91816: LD_INT 1
91818: ST_TO_ADDR
// if p3 = 14 then
91819: LD_VAR 0 3
91823: PUSH
91824: LD_INT 14
91826: EQUAL
91827: IFFALSE 91837
// sFlag := true ;
91829: LD_ADDR_EXP 155
91833: PUSH
91834: LD_INT 1
91836: ST_TO_ADDR
// if p3 = 15 then
91837: LD_VAR 0 3
91841: PUSH
91842: LD_INT 15
91844: EQUAL
91845: IFFALSE 91855
// sKamikadze := true ;
91847: LD_ADDR_EXP 163
91851: PUSH
91852: LD_INT 1
91854: ST_TO_ADDR
// if p3 = 16 then
91855: LD_VAR 0 3
91859: PUSH
91860: LD_INT 16
91862: EQUAL
91863: IFFALSE 91873
// sTroll := true ;
91865: LD_ADDR_EXP 164
91869: PUSH
91870: LD_INT 1
91872: ST_TO_ADDR
// if p3 = 17 then
91873: LD_VAR 0 3
91877: PUSH
91878: LD_INT 17
91880: EQUAL
91881: IFFALSE 91891
// sSlow := true ;
91883: LD_ADDR_EXP 165
91887: PUSH
91888: LD_INT 1
91890: ST_TO_ADDR
// if p3 = 18 then
91891: LD_VAR 0 3
91895: PUSH
91896: LD_INT 18
91898: EQUAL
91899: IFFALSE 91909
// sLack := true ;
91901: LD_ADDR_EXP 166
91905: PUSH
91906: LD_INT 1
91908: ST_TO_ADDR
// if p3 = 19 then
91909: LD_VAR 0 3
91913: PUSH
91914: LD_INT 19
91916: EQUAL
91917: IFFALSE 91927
// sTank := true ;
91919: LD_ADDR_EXP 168
91923: PUSH
91924: LD_INT 1
91926: ST_TO_ADDR
// if p3 = 20 then
91927: LD_VAR 0 3
91931: PUSH
91932: LD_INT 20
91934: EQUAL
91935: IFFALSE 91945
// sRemote := true ;
91937: LD_ADDR_EXP 169
91941: PUSH
91942: LD_INT 1
91944: ST_TO_ADDR
// if p3 = 21 then
91945: LD_VAR 0 3
91949: PUSH
91950: LD_INT 21
91952: EQUAL
91953: IFFALSE 91963
// sPowell := true ;
91955: LD_ADDR_EXP 170
91959: PUSH
91960: LD_INT 1
91962: ST_TO_ADDR
// if p3 = 22 then
91963: LD_VAR 0 3
91967: PUSH
91968: LD_INT 22
91970: EQUAL
91971: IFFALSE 91981
// sTeleport := true ;
91973: LD_ADDR_EXP 173
91977: PUSH
91978: LD_INT 1
91980: ST_TO_ADDR
// if p3 = 23 then
91981: LD_VAR 0 3
91985: PUSH
91986: LD_INT 23
91988: EQUAL
91989: IFFALSE 91999
// sOilTower := true ;
91991: LD_ADDR_EXP 175
91995: PUSH
91996: LD_INT 1
91998: ST_TO_ADDR
// if p3 = 24 then
91999: LD_VAR 0 3
92003: PUSH
92004: LD_INT 24
92006: EQUAL
92007: IFFALSE 92017
// sShovel := true ;
92009: LD_ADDR_EXP 176
92013: PUSH
92014: LD_INT 1
92016: ST_TO_ADDR
// if p3 = 25 then
92017: LD_VAR 0 3
92021: PUSH
92022: LD_INT 25
92024: EQUAL
92025: IFFALSE 92035
// sSheik := true ;
92027: LD_ADDR_EXP 177
92031: PUSH
92032: LD_INT 1
92034: ST_TO_ADDR
// if p3 = 26 then
92035: LD_VAR 0 3
92039: PUSH
92040: LD_INT 26
92042: EQUAL
92043: IFFALSE 92053
// sEarthquake := true ;
92045: LD_ADDR_EXP 179
92049: PUSH
92050: LD_INT 1
92052: ST_TO_ADDR
// if p3 = 27 then
92053: LD_VAR 0 3
92057: PUSH
92058: LD_INT 27
92060: EQUAL
92061: IFFALSE 92071
// sAI := true ;
92063: LD_ADDR_EXP 180
92067: PUSH
92068: LD_INT 1
92070: ST_TO_ADDR
// if p3 = 28 then
92071: LD_VAR 0 3
92075: PUSH
92076: LD_INT 28
92078: EQUAL
92079: IFFALSE 92089
// sCargo := true ;
92081: LD_ADDR_EXP 183
92085: PUSH
92086: LD_INT 1
92088: ST_TO_ADDR
// if p3 = 29 then
92089: LD_VAR 0 3
92093: PUSH
92094: LD_INT 29
92096: EQUAL
92097: IFFALSE 92107
// sDLaser := true ;
92099: LD_ADDR_EXP 184
92103: PUSH
92104: LD_INT 1
92106: ST_TO_ADDR
// if p3 = 30 then
92107: LD_VAR 0 3
92111: PUSH
92112: LD_INT 30
92114: EQUAL
92115: IFFALSE 92125
// sExchange := true ;
92117: LD_ADDR_EXP 185
92121: PUSH
92122: LD_INT 1
92124: ST_TO_ADDR
// if p3 = 31 then
92125: LD_VAR 0 3
92129: PUSH
92130: LD_INT 31
92132: EQUAL
92133: IFFALSE 92143
// sFac := true ;
92135: LD_ADDR_EXP 186
92139: PUSH
92140: LD_INT 1
92142: ST_TO_ADDR
// if p3 = 32 then
92143: LD_VAR 0 3
92147: PUSH
92148: LD_INT 32
92150: EQUAL
92151: IFFALSE 92161
// sPower := true ;
92153: LD_ADDR_EXP 187
92157: PUSH
92158: LD_INT 1
92160: ST_TO_ADDR
// if p3 = 33 then
92161: LD_VAR 0 3
92165: PUSH
92166: LD_INT 33
92168: EQUAL
92169: IFFALSE 92179
// sRandom := true ;
92171: LD_ADDR_EXP 188
92175: PUSH
92176: LD_INT 1
92178: ST_TO_ADDR
// if p3 = 34 then
92179: LD_VAR 0 3
92183: PUSH
92184: LD_INT 34
92186: EQUAL
92187: IFFALSE 92197
// sShield := true ;
92189: LD_ADDR_EXP 189
92193: PUSH
92194: LD_INT 1
92196: ST_TO_ADDR
// if p3 = 35 then
92197: LD_VAR 0 3
92201: PUSH
92202: LD_INT 35
92204: EQUAL
92205: IFFALSE 92215
// sTime := true ;
92207: LD_ADDR_EXP 190
92211: PUSH
92212: LD_INT 1
92214: ST_TO_ADDR
// if p3 = 36 then
92215: LD_VAR 0 3
92219: PUSH
92220: LD_INT 36
92222: EQUAL
92223: IFFALSE 92233
// sTools := true ;
92225: LD_ADDR_EXP 191
92229: PUSH
92230: LD_INT 1
92232: ST_TO_ADDR
// if p3 = 101 then
92233: LD_VAR 0 3
92237: PUSH
92238: LD_INT 101
92240: EQUAL
92241: IFFALSE 92251
// sSold := true ;
92243: LD_ADDR_EXP 156
92247: PUSH
92248: LD_INT 1
92250: ST_TO_ADDR
// if p3 = 102 then
92251: LD_VAR 0 3
92255: PUSH
92256: LD_INT 102
92258: EQUAL
92259: IFFALSE 92269
// sDiff := true ;
92261: LD_ADDR_EXP 157
92265: PUSH
92266: LD_INT 1
92268: ST_TO_ADDR
// if p3 = 103 then
92269: LD_VAR 0 3
92273: PUSH
92274: LD_INT 103
92276: EQUAL
92277: IFFALSE 92287
// sFog := true ;
92279: LD_ADDR_EXP 160
92283: PUSH
92284: LD_INT 1
92286: ST_TO_ADDR
// if p3 = 104 then
92287: LD_VAR 0 3
92291: PUSH
92292: LD_INT 104
92294: EQUAL
92295: IFFALSE 92305
// sReset := true ;
92297: LD_ADDR_EXP 161
92301: PUSH
92302: LD_INT 1
92304: ST_TO_ADDR
// if p3 = 105 then
92305: LD_VAR 0 3
92309: PUSH
92310: LD_INT 105
92312: EQUAL
92313: IFFALSE 92323
// sSun := true ;
92315: LD_ADDR_EXP 162
92319: PUSH
92320: LD_INT 1
92322: ST_TO_ADDR
// if p3 = 106 then
92323: LD_VAR 0 3
92327: PUSH
92328: LD_INT 106
92330: EQUAL
92331: IFFALSE 92341
// sTiger := true ;
92333: LD_ADDR_EXP 158
92337: PUSH
92338: LD_INT 1
92340: ST_TO_ADDR
// if p3 = 107 then
92341: LD_VAR 0 3
92345: PUSH
92346: LD_INT 107
92348: EQUAL
92349: IFFALSE 92359
// sBomb := true ;
92351: LD_ADDR_EXP 159
92355: PUSH
92356: LD_INT 1
92358: ST_TO_ADDR
// if p3 = 108 then
92359: LD_VAR 0 3
92363: PUSH
92364: LD_INT 108
92366: EQUAL
92367: IFFALSE 92377
// sWound := true ;
92369: LD_ADDR_EXP 167
92373: PUSH
92374: LD_INT 1
92376: ST_TO_ADDR
// if p3 = 109 then
92377: LD_VAR 0 3
92381: PUSH
92382: LD_INT 109
92384: EQUAL
92385: IFFALSE 92395
// sBetray := true ;
92387: LD_ADDR_EXP 171
92391: PUSH
92392: LD_INT 1
92394: ST_TO_ADDR
// if p3 = 110 then
92395: LD_VAR 0 3
92399: PUSH
92400: LD_INT 110
92402: EQUAL
92403: IFFALSE 92413
// sContamin := true ;
92405: LD_ADDR_EXP 172
92409: PUSH
92410: LD_INT 1
92412: ST_TO_ADDR
// if p3 = 111 then
92413: LD_VAR 0 3
92417: PUSH
92418: LD_INT 111
92420: EQUAL
92421: IFFALSE 92431
// sOil := true ;
92423: LD_ADDR_EXP 174
92427: PUSH
92428: LD_INT 1
92430: ST_TO_ADDR
// if p3 = 112 then
92431: LD_VAR 0 3
92435: PUSH
92436: LD_INT 112
92438: EQUAL
92439: IFFALSE 92449
// sStu := true ;
92441: LD_ADDR_EXP 178
92445: PUSH
92446: LD_INT 1
92448: ST_TO_ADDR
// if p3 = 113 then
92449: LD_VAR 0 3
92453: PUSH
92454: LD_INT 113
92456: EQUAL
92457: IFFALSE 92467
// sBazooka := true ;
92459: LD_ADDR_EXP 181
92463: PUSH
92464: LD_INT 1
92466: ST_TO_ADDR
// if p3 = 114 then
92467: LD_VAR 0 3
92471: PUSH
92472: LD_INT 114
92474: EQUAL
92475: IFFALSE 92485
// sMortar := true ;
92477: LD_ADDR_EXP 182
92481: PUSH
92482: LD_INT 1
92484: ST_TO_ADDR
// if p3 = 115 then
92485: LD_VAR 0 3
92489: PUSH
92490: LD_INT 115
92492: EQUAL
92493: IFFALSE 92503
// sRanger := true ;
92495: LD_ADDR_EXP 192
92499: PUSH
92500: LD_INT 1
92502: ST_TO_ADDR
// if p3 = 116 then
92503: LD_VAR 0 3
92507: PUSH
92508: LD_INT 116
92510: EQUAL
92511: IFFALSE 92521
// sComputer := true ;
92513: LD_ADDR_EXP 193
92517: PUSH
92518: LD_INT 1
92520: ST_TO_ADDR
// if p3 = 117 then
92521: LD_VAR 0 3
92525: PUSH
92526: LD_INT 117
92528: EQUAL
92529: IFFALSE 92539
// s30 := true ;
92531: LD_ADDR_EXP 194
92535: PUSH
92536: LD_INT 1
92538: ST_TO_ADDR
// if p3 = 118 then
92539: LD_VAR 0 3
92543: PUSH
92544: LD_INT 118
92546: EQUAL
92547: IFFALSE 92557
// s60 := true ;
92549: LD_ADDR_EXP 195
92553: PUSH
92554: LD_INT 1
92556: ST_TO_ADDR
// end ; if p2 = 101 then
92557: LD_VAR 0 2
92561: PUSH
92562: LD_INT 101
92564: EQUAL
92565: IFFALSE 92693
// begin case p3 of 1 :
92567: LD_VAR 0 3
92571: PUSH
92572: LD_INT 1
92574: DOUBLE
92575: EQUAL
92576: IFTRUE 92580
92578: GO 92587
92580: POP
// hHackUnlimitedResources ; 2 :
92581: CALL 104289 0 0
92585: GO 92693
92587: LD_INT 2
92589: DOUBLE
92590: EQUAL
92591: IFTRUE 92595
92593: GO 92602
92595: POP
// hHackSetLevel10 ; 3 :
92596: CALL 104422 0 0
92600: GO 92693
92602: LD_INT 3
92604: DOUBLE
92605: EQUAL
92606: IFTRUE 92610
92608: GO 92617
92610: POP
// hHackSetLevel10YourUnits ; 4 :
92611: CALL 104507 0 0
92615: GO 92693
92617: LD_INT 4
92619: DOUBLE
92620: EQUAL
92621: IFTRUE 92625
92623: GO 92632
92625: POP
// hHackInvincible ; 5 :
92626: CALL 104955 0 0
92630: GO 92693
92632: LD_INT 5
92634: DOUBLE
92635: EQUAL
92636: IFTRUE 92640
92638: GO 92647
92640: POP
// hHackInvisible ; 6 :
92641: CALL 105066 0 0
92645: GO 92693
92647: LD_INT 6
92649: DOUBLE
92650: EQUAL
92651: IFTRUE 92655
92653: GO 92662
92655: POP
// hHackChangeYourSide ; 7 :
92656: CALL 105123 0 0
92660: GO 92693
92662: LD_INT 7
92664: DOUBLE
92665: EQUAL
92666: IFTRUE 92670
92668: GO 92677
92670: POP
// hHackChangeUnitSide ; 8 :
92671: CALL 105165 0 0
92675: GO 92693
92677: LD_INT 8
92679: DOUBLE
92680: EQUAL
92681: IFTRUE 92685
92683: GO 92692
92685: POP
// hHackFog ; end ;
92686: CALL 105266 0 0
92690: GO 92693
92692: POP
// end ; end ;
92693: LD_VAR 0 7
92697: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
92698: GO 92700
92700: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
92701: LD_STRING initStreamRollete();
92703: PPUSH
92704: CALL_OW 559
// InitStreamMode ;
92708: CALL 92717 0 0
// DefineStreamItems ( ) ;
92712: CALL 93181 0 0
// end ;
92716: END
// function InitStreamMode ; begin
92717: LD_INT 0
92719: PPUSH
// streamModeActive := false ;
92720: LD_ADDR_EXP 139
92724: PUSH
92725: LD_INT 0
92727: ST_TO_ADDR
// normalCounter := 36 ;
92728: LD_ADDR_EXP 140
92732: PUSH
92733: LD_INT 36
92735: ST_TO_ADDR
// hardcoreCounter := 16 ;
92736: LD_ADDR_EXP 141
92740: PUSH
92741: LD_INT 16
92743: ST_TO_ADDR
// sRocket := false ;
92744: LD_ADDR_EXP 144
92748: PUSH
92749: LD_INT 0
92751: ST_TO_ADDR
// sSpeed := false ;
92752: LD_ADDR_EXP 143
92756: PUSH
92757: LD_INT 0
92759: ST_TO_ADDR
// sEngine := false ;
92760: LD_ADDR_EXP 145
92764: PUSH
92765: LD_INT 0
92767: ST_TO_ADDR
// sSpec := false ;
92768: LD_ADDR_EXP 142
92772: PUSH
92773: LD_INT 0
92775: ST_TO_ADDR
// sLevel := false ;
92776: LD_ADDR_EXP 146
92780: PUSH
92781: LD_INT 0
92783: ST_TO_ADDR
// sArmoury := false ;
92784: LD_ADDR_EXP 147
92788: PUSH
92789: LD_INT 0
92791: ST_TO_ADDR
// sRadar := false ;
92792: LD_ADDR_EXP 148
92796: PUSH
92797: LD_INT 0
92799: ST_TO_ADDR
// sBunker := false ;
92800: LD_ADDR_EXP 149
92804: PUSH
92805: LD_INT 0
92807: ST_TO_ADDR
// sHack := false ;
92808: LD_ADDR_EXP 150
92812: PUSH
92813: LD_INT 0
92815: ST_TO_ADDR
// sFire := false ;
92816: LD_ADDR_EXP 151
92820: PUSH
92821: LD_INT 0
92823: ST_TO_ADDR
// sRefresh := false ;
92824: LD_ADDR_EXP 152
92828: PUSH
92829: LD_INT 0
92831: ST_TO_ADDR
// sExp := false ;
92832: LD_ADDR_EXP 153
92836: PUSH
92837: LD_INT 0
92839: ST_TO_ADDR
// sDepot := false ;
92840: LD_ADDR_EXP 154
92844: PUSH
92845: LD_INT 0
92847: ST_TO_ADDR
// sFlag := false ;
92848: LD_ADDR_EXP 155
92852: PUSH
92853: LD_INT 0
92855: ST_TO_ADDR
// sKamikadze := false ;
92856: LD_ADDR_EXP 163
92860: PUSH
92861: LD_INT 0
92863: ST_TO_ADDR
// sTroll := false ;
92864: LD_ADDR_EXP 164
92868: PUSH
92869: LD_INT 0
92871: ST_TO_ADDR
// sSlow := false ;
92872: LD_ADDR_EXP 165
92876: PUSH
92877: LD_INT 0
92879: ST_TO_ADDR
// sLack := false ;
92880: LD_ADDR_EXP 166
92884: PUSH
92885: LD_INT 0
92887: ST_TO_ADDR
// sTank := false ;
92888: LD_ADDR_EXP 168
92892: PUSH
92893: LD_INT 0
92895: ST_TO_ADDR
// sRemote := false ;
92896: LD_ADDR_EXP 169
92900: PUSH
92901: LD_INT 0
92903: ST_TO_ADDR
// sPowell := false ;
92904: LD_ADDR_EXP 170
92908: PUSH
92909: LD_INT 0
92911: ST_TO_ADDR
// sTeleport := false ;
92912: LD_ADDR_EXP 173
92916: PUSH
92917: LD_INT 0
92919: ST_TO_ADDR
// sOilTower := false ;
92920: LD_ADDR_EXP 175
92924: PUSH
92925: LD_INT 0
92927: ST_TO_ADDR
// sShovel := false ;
92928: LD_ADDR_EXP 176
92932: PUSH
92933: LD_INT 0
92935: ST_TO_ADDR
// sSheik := false ;
92936: LD_ADDR_EXP 177
92940: PUSH
92941: LD_INT 0
92943: ST_TO_ADDR
// sEarthquake := false ;
92944: LD_ADDR_EXP 179
92948: PUSH
92949: LD_INT 0
92951: ST_TO_ADDR
// sAI := false ;
92952: LD_ADDR_EXP 180
92956: PUSH
92957: LD_INT 0
92959: ST_TO_ADDR
// sCargo := false ;
92960: LD_ADDR_EXP 183
92964: PUSH
92965: LD_INT 0
92967: ST_TO_ADDR
// sDLaser := false ;
92968: LD_ADDR_EXP 184
92972: PUSH
92973: LD_INT 0
92975: ST_TO_ADDR
// sExchange := false ;
92976: LD_ADDR_EXP 185
92980: PUSH
92981: LD_INT 0
92983: ST_TO_ADDR
// sFac := false ;
92984: LD_ADDR_EXP 186
92988: PUSH
92989: LD_INT 0
92991: ST_TO_ADDR
// sPower := false ;
92992: LD_ADDR_EXP 187
92996: PUSH
92997: LD_INT 0
92999: ST_TO_ADDR
// sRandom := false ;
93000: LD_ADDR_EXP 188
93004: PUSH
93005: LD_INT 0
93007: ST_TO_ADDR
// sShield := false ;
93008: LD_ADDR_EXP 189
93012: PUSH
93013: LD_INT 0
93015: ST_TO_ADDR
// sTime := false ;
93016: LD_ADDR_EXP 190
93020: PUSH
93021: LD_INT 0
93023: ST_TO_ADDR
// sTools := false ;
93024: LD_ADDR_EXP 191
93028: PUSH
93029: LD_INT 0
93031: ST_TO_ADDR
// sSold := false ;
93032: LD_ADDR_EXP 156
93036: PUSH
93037: LD_INT 0
93039: ST_TO_ADDR
// sDiff := false ;
93040: LD_ADDR_EXP 157
93044: PUSH
93045: LD_INT 0
93047: ST_TO_ADDR
// sFog := false ;
93048: LD_ADDR_EXP 160
93052: PUSH
93053: LD_INT 0
93055: ST_TO_ADDR
// sReset := false ;
93056: LD_ADDR_EXP 161
93060: PUSH
93061: LD_INT 0
93063: ST_TO_ADDR
// sSun := false ;
93064: LD_ADDR_EXP 162
93068: PUSH
93069: LD_INT 0
93071: ST_TO_ADDR
// sTiger := false ;
93072: LD_ADDR_EXP 158
93076: PUSH
93077: LD_INT 0
93079: ST_TO_ADDR
// sBomb := false ;
93080: LD_ADDR_EXP 159
93084: PUSH
93085: LD_INT 0
93087: ST_TO_ADDR
// sWound := false ;
93088: LD_ADDR_EXP 167
93092: PUSH
93093: LD_INT 0
93095: ST_TO_ADDR
// sBetray := false ;
93096: LD_ADDR_EXP 171
93100: PUSH
93101: LD_INT 0
93103: ST_TO_ADDR
// sContamin := false ;
93104: LD_ADDR_EXP 172
93108: PUSH
93109: LD_INT 0
93111: ST_TO_ADDR
// sOil := false ;
93112: LD_ADDR_EXP 174
93116: PUSH
93117: LD_INT 0
93119: ST_TO_ADDR
// sStu := false ;
93120: LD_ADDR_EXP 178
93124: PUSH
93125: LD_INT 0
93127: ST_TO_ADDR
// sBazooka := false ;
93128: LD_ADDR_EXP 181
93132: PUSH
93133: LD_INT 0
93135: ST_TO_ADDR
// sMortar := false ;
93136: LD_ADDR_EXP 182
93140: PUSH
93141: LD_INT 0
93143: ST_TO_ADDR
// sRanger := false ;
93144: LD_ADDR_EXP 192
93148: PUSH
93149: LD_INT 0
93151: ST_TO_ADDR
// sComputer := false ;
93152: LD_ADDR_EXP 193
93156: PUSH
93157: LD_INT 0
93159: ST_TO_ADDR
// s30 := false ;
93160: LD_ADDR_EXP 194
93164: PUSH
93165: LD_INT 0
93167: ST_TO_ADDR
// s60 := false ;
93168: LD_ADDR_EXP 195
93172: PUSH
93173: LD_INT 0
93175: ST_TO_ADDR
// end ;
93176: LD_VAR 0 1
93180: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
93181: LD_INT 0
93183: PPUSH
93184: PPUSH
93185: PPUSH
93186: PPUSH
93187: PPUSH
// result := [ ] ;
93188: LD_ADDR_VAR 0 1
93192: PUSH
93193: EMPTY
93194: ST_TO_ADDR
// if campaign_id = 1 then
93195: LD_OWVAR 69
93199: PUSH
93200: LD_INT 1
93202: EQUAL
93203: IFFALSE 96369
// begin case mission_number of 1 :
93205: LD_OWVAR 70
93209: PUSH
93210: LD_INT 1
93212: DOUBLE
93213: EQUAL
93214: IFTRUE 93218
93216: GO 93294
93218: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93219: LD_ADDR_VAR 0 1
93223: PUSH
93224: LD_INT 2
93226: PUSH
93227: LD_INT 4
93229: PUSH
93230: LD_INT 11
93232: PUSH
93233: LD_INT 12
93235: PUSH
93236: LD_INT 15
93238: PUSH
93239: LD_INT 16
93241: PUSH
93242: LD_INT 22
93244: PUSH
93245: LD_INT 23
93247: PUSH
93248: LD_INT 26
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: PUSH
93262: LD_INT 101
93264: PUSH
93265: LD_INT 102
93267: PUSH
93268: LD_INT 106
93270: PUSH
93271: LD_INT 116
93273: PUSH
93274: LD_INT 117
93276: PUSH
93277: LD_INT 118
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: ST_TO_ADDR
93292: GO 96367
93294: LD_INT 2
93296: DOUBLE
93297: EQUAL
93298: IFTRUE 93302
93300: GO 93386
93302: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93303: LD_ADDR_VAR 0 1
93307: PUSH
93308: LD_INT 2
93310: PUSH
93311: LD_INT 4
93313: PUSH
93314: LD_INT 11
93316: PUSH
93317: LD_INT 12
93319: PUSH
93320: LD_INT 15
93322: PUSH
93323: LD_INT 16
93325: PUSH
93326: LD_INT 22
93328: PUSH
93329: LD_INT 23
93331: PUSH
93332: LD_INT 26
93334: PUSH
93335: EMPTY
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: PUSH
93346: LD_INT 101
93348: PUSH
93349: LD_INT 102
93351: PUSH
93352: LD_INT 105
93354: PUSH
93355: LD_INT 106
93357: PUSH
93358: LD_INT 108
93360: PUSH
93361: LD_INT 116
93363: PUSH
93364: LD_INT 117
93366: PUSH
93367: LD_INT 118
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: ST_TO_ADDR
93384: GO 96367
93386: LD_INT 3
93388: DOUBLE
93389: EQUAL
93390: IFTRUE 93394
93392: GO 93482
93394: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93395: LD_ADDR_VAR 0 1
93399: PUSH
93400: LD_INT 2
93402: PUSH
93403: LD_INT 4
93405: PUSH
93406: LD_INT 5
93408: PUSH
93409: LD_INT 11
93411: PUSH
93412: LD_INT 12
93414: PUSH
93415: LD_INT 15
93417: PUSH
93418: LD_INT 16
93420: PUSH
93421: LD_INT 22
93423: PUSH
93424: LD_INT 26
93426: PUSH
93427: LD_INT 36
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: PUSH
93442: LD_INT 101
93444: PUSH
93445: LD_INT 102
93447: PUSH
93448: LD_INT 105
93450: PUSH
93451: LD_INT 106
93453: PUSH
93454: LD_INT 108
93456: PUSH
93457: LD_INT 116
93459: PUSH
93460: LD_INT 117
93462: PUSH
93463: LD_INT 118
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: PUSH
93476: EMPTY
93477: LIST
93478: LIST
93479: ST_TO_ADDR
93480: GO 96367
93482: LD_INT 4
93484: DOUBLE
93485: EQUAL
93486: IFTRUE 93490
93488: GO 93586
93490: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93491: LD_ADDR_VAR 0 1
93495: PUSH
93496: LD_INT 2
93498: PUSH
93499: LD_INT 4
93501: PUSH
93502: LD_INT 5
93504: PUSH
93505: LD_INT 8
93507: PUSH
93508: LD_INT 11
93510: PUSH
93511: LD_INT 12
93513: PUSH
93514: LD_INT 15
93516: PUSH
93517: LD_INT 16
93519: PUSH
93520: LD_INT 22
93522: PUSH
93523: LD_INT 23
93525: PUSH
93526: LD_INT 26
93528: PUSH
93529: LD_INT 36
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: PUSH
93546: LD_INT 101
93548: PUSH
93549: LD_INT 102
93551: PUSH
93552: LD_INT 105
93554: PUSH
93555: LD_INT 106
93557: PUSH
93558: LD_INT 108
93560: PUSH
93561: LD_INT 116
93563: PUSH
93564: LD_INT 117
93566: PUSH
93567: LD_INT 118
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: ST_TO_ADDR
93584: GO 96367
93586: LD_INT 5
93588: DOUBLE
93589: EQUAL
93590: IFTRUE 93594
93592: GO 93706
93594: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93595: LD_ADDR_VAR 0 1
93599: PUSH
93600: LD_INT 2
93602: PUSH
93603: LD_INT 4
93605: PUSH
93606: LD_INT 5
93608: PUSH
93609: LD_INT 6
93611: PUSH
93612: LD_INT 8
93614: PUSH
93615: LD_INT 11
93617: PUSH
93618: LD_INT 12
93620: PUSH
93621: LD_INT 15
93623: PUSH
93624: LD_INT 16
93626: PUSH
93627: LD_INT 22
93629: PUSH
93630: LD_INT 23
93632: PUSH
93633: LD_INT 25
93635: PUSH
93636: LD_INT 26
93638: PUSH
93639: LD_INT 36
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: PUSH
93658: LD_INT 101
93660: PUSH
93661: LD_INT 102
93663: PUSH
93664: LD_INT 105
93666: PUSH
93667: LD_INT 106
93669: PUSH
93670: LD_INT 108
93672: PUSH
93673: LD_INT 109
93675: PUSH
93676: LD_INT 112
93678: PUSH
93679: LD_INT 116
93681: PUSH
93682: LD_INT 117
93684: PUSH
93685: LD_INT 118
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: ST_TO_ADDR
93704: GO 96367
93706: LD_INT 6
93708: DOUBLE
93709: EQUAL
93710: IFTRUE 93714
93712: GO 93846
93714: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93715: LD_ADDR_VAR 0 1
93719: PUSH
93720: LD_INT 2
93722: PUSH
93723: LD_INT 4
93725: PUSH
93726: LD_INT 5
93728: PUSH
93729: LD_INT 6
93731: PUSH
93732: LD_INT 8
93734: PUSH
93735: LD_INT 11
93737: PUSH
93738: LD_INT 12
93740: PUSH
93741: LD_INT 15
93743: PUSH
93744: LD_INT 16
93746: PUSH
93747: LD_INT 20
93749: PUSH
93750: LD_INT 21
93752: PUSH
93753: LD_INT 22
93755: PUSH
93756: LD_INT 23
93758: PUSH
93759: LD_INT 25
93761: PUSH
93762: LD_INT 26
93764: PUSH
93765: LD_INT 30
93767: PUSH
93768: LD_INT 31
93770: PUSH
93771: LD_INT 32
93773: PUSH
93774: LD_INT 36
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: PUSH
93798: LD_INT 101
93800: PUSH
93801: LD_INT 102
93803: PUSH
93804: LD_INT 105
93806: PUSH
93807: LD_INT 106
93809: PUSH
93810: LD_INT 108
93812: PUSH
93813: LD_INT 109
93815: PUSH
93816: LD_INT 112
93818: PUSH
93819: LD_INT 116
93821: PUSH
93822: LD_INT 117
93824: PUSH
93825: LD_INT 118
93827: PUSH
93828: EMPTY
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: PUSH
93840: EMPTY
93841: LIST
93842: LIST
93843: ST_TO_ADDR
93844: GO 96367
93846: LD_INT 7
93848: DOUBLE
93849: EQUAL
93850: IFTRUE 93854
93852: GO 93966
93854: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93855: LD_ADDR_VAR 0 1
93859: PUSH
93860: LD_INT 2
93862: PUSH
93863: LD_INT 4
93865: PUSH
93866: LD_INT 5
93868: PUSH
93869: LD_INT 7
93871: PUSH
93872: LD_INT 11
93874: PUSH
93875: LD_INT 12
93877: PUSH
93878: LD_INT 15
93880: PUSH
93881: LD_INT 16
93883: PUSH
93884: LD_INT 20
93886: PUSH
93887: LD_INT 21
93889: PUSH
93890: LD_INT 22
93892: PUSH
93893: LD_INT 23
93895: PUSH
93896: LD_INT 25
93898: PUSH
93899: LD_INT 26
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 101
93920: PUSH
93921: LD_INT 102
93923: PUSH
93924: LD_INT 103
93926: PUSH
93927: LD_INT 105
93929: PUSH
93930: LD_INT 106
93932: PUSH
93933: LD_INT 108
93935: PUSH
93936: LD_INT 112
93938: PUSH
93939: LD_INT 116
93941: PUSH
93942: LD_INT 117
93944: PUSH
93945: LD_INT 118
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: ST_TO_ADDR
93964: GO 96367
93966: LD_INT 8
93968: DOUBLE
93969: EQUAL
93970: IFTRUE 93974
93972: GO 94114
93974: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93975: LD_ADDR_VAR 0 1
93979: PUSH
93980: LD_INT 2
93982: PUSH
93983: LD_INT 4
93985: PUSH
93986: LD_INT 5
93988: PUSH
93989: LD_INT 6
93991: PUSH
93992: LD_INT 7
93994: PUSH
93995: LD_INT 8
93997: PUSH
93998: LD_INT 11
94000: PUSH
94001: LD_INT 12
94003: PUSH
94004: LD_INT 15
94006: PUSH
94007: LD_INT 16
94009: PUSH
94010: LD_INT 20
94012: PUSH
94013: LD_INT 21
94015: PUSH
94016: LD_INT 22
94018: PUSH
94019: LD_INT 23
94021: PUSH
94022: LD_INT 25
94024: PUSH
94025: LD_INT 26
94027: PUSH
94028: LD_INT 30
94030: PUSH
94031: LD_INT 31
94033: PUSH
94034: LD_INT 32
94036: PUSH
94037: LD_INT 36
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: PUSH
94062: LD_INT 101
94064: PUSH
94065: LD_INT 102
94067: PUSH
94068: LD_INT 103
94070: PUSH
94071: LD_INT 105
94073: PUSH
94074: LD_INT 106
94076: PUSH
94077: LD_INT 108
94079: PUSH
94080: LD_INT 109
94082: PUSH
94083: LD_INT 112
94085: PUSH
94086: LD_INT 116
94088: PUSH
94089: LD_INT 117
94091: PUSH
94092: LD_INT 118
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: ST_TO_ADDR
94112: GO 96367
94114: LD_INT 9
94116: DOUBLE
94117: EQUAL
94118: IFTRUE 94122
94120: GO 94270
94122: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94123: LD_ADDR_VAR 0 1
94127: PUSH
94128: LD_INT 2
94130: PUSH
94131: LD_INT 4
94133: PUSH
94134: LD_INT 5
94136: PUSH
94137: LD_INT 6
94139: PUSH
94140: LD_INT 7
94142: PUSH
94143: LD_INT 8
94145: PUSH
94146: LD_INT 11
94148: PUSH
94149: LD_INT 12
94151: PUSH
94152: LD_INT 15
94154: PUSH
94155: LD_INT 16
94157: PUSH
94158: LD_INT 20
94160: PUSH
94161: LD_INT 21
94163: PUSH
94164: LD_INT 22
94166: PUSH
94167: LD_INT 23
94169: PUSH
94170: LD_INT 25
94172: PUSH
94173: LD_INT 26
94175: PUSH
94176: LD_INT 28
94178: PUSH
94179: LD_INT 30
94181: PUSH
94182: LD_INT 31
94184: PUSH
94185: LD_INT 32
94187: PUSH
94188: LD_INT 36
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: PUSH
94214: LD_INT 101
94216: PUSH
94217: LD_INT 102
94219: PUSH
94220: LD_INT 103
94222: PUSH
94223: LD_INT 105
94225: PUSH
94226: LD_INT 106
94228: PUSH
94229: LD_INT 108
94231: PUSH
94232: LD_INT 109
94234: PUSH
94235: LD_INT 112
94237: PUSH
94238: LD_INT 114
94240: PUSH
94241: LD_INT 116
94243: PUSH
94244: LD_INT 117
94246: PUSH
94247: LD_INT 118
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: ST_TO_ADDR
94268: GO 96367
94270: LD_INT 10
94272: DOUBLE
94273: EQUAL
94274: IFTRUE 94278
94276: GO 94474
94278: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94279: LD_ADDR_VAR 0 1
94283: PUSH
94284: LD_INT 2
94286: PUSH
94287: LD_INT 4
94289: PUSH
94290: LD_INT 5
94292: PUSH
94293: LD_INT 6
94295: PUSH
94296: LD_INT 7
94298: PUSH
94299: LD_INT 8
94301: PUSH
94302: LD_INT 9
94304: PUSH
94305: LD_INT 10
94307: PUSH
94308: LD_INT 11
94310: PUSH
94311: LD_INT 12
94313: PUSH
94314: LD_INT 13
94316: PUSH
94317: LD_INT 14
94319: PUSH
94320: LD_INT 15
94322: PUSH
94323: LD_INT 16
94325: PUSH
94326: LD_INT 17
94328: PUSH
94329: LD_INT 18
94331: PUSH
94332: LD_INT 19
94334: PUSH
94335: LD_INT 20
94337: PUSH
94338: LD_INT 21
94340: PUSH
94341: LD_INT 22
94343: PUSH
94344: LD_INT 23
94346: PUSH
94347: LD_INT 24
94349: PUSH
94350: LD_INT 25
94352: PUSH
94353: LD_INT 26
94355: PUSH
94356: LD_INT 28
94358: PUSH
94359: LD_INT 30
94361: PUSH
94362: LD_INT 31
94364: PUSH
94365: LD_INT 32
94367: PUSH
94368: LD_INT 36
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: PUSH
94402: LD_INT 101
94404: PUSH
94405: LD_INT 102
94407: PUSH
94408: LD_INT 103
94410: PUSH
94411: LD_INT 104
94413: PUSH
94414: LD_INT 105
94416: PUSH
94417: LD_INT 106
94419: PUSH
94420: LD_INT 107
94422: PUSH
94423: LD_INT 108
94425: PUSH
94426: LD_INT 109
94428: PUSH
94429: LD_INT 110
94431: PUSH
94432: LD_INT 111
94434: PUSH
94435: LD_INT 112
94437: PUSH
94438: LD_INT 114
94440: PUSH
94441: LD_INT 116
94443: PUSH
94444: LD_INT 117
94446: PUSH
94447: LD_INT 118
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: ST_TO_ADDR
94472: GO 96367
94474: LD_INT 11
94476: DOUBLE
94477: EQUAL
94478: IFTRUE 94482
94480: GO 94686
94482: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94483: LD_ADDR_VAR 0 1
94487: PUSH
94488: LD_INT 2
94490: PUSH
94491: LD_INT 3
94493: PUSH
94494: LD_INT 4
94496: PUSH
94497: LD_INT 5
94499: PUSH
94500: LD_INT 6
94502: PUSH
94503: LD_INT 7
94505: PUSH
94506: LD_INT 8
94508: PUSH
94509: LD_INT 9
94511: PUSH
94512: LD_INT 10
94514: PUSH
94515: LD_INT 11
94517: PUSH
94518: LD_INT 12
94520: PUSH
94521: LD_INT 13
94523: PUSH
94524: LD_INT 14
94526: PUSH
94527: LD_INT 15
94529: PUSH
94530: LD_INT 16
94532: PUSH
94533: LD_INT 17
94535: PUSH
94536: LD_INT 18
94538: PUSH
94539: LD_INT 19
94541: PUSH
94542: LD_INT 20
94544: PUSH
94545: LD_INT 21
94547: PUSH
94548: LD_INT 22
94550: PUSH
94551: LD_INT 23
94553: PUSH
94554: LD_INT 24
94556: PUSH
94557: LD_INT 25
94559: PUSH
94560: LD_INT 26
94562: PUSH
94563: LD_INT 28
94565: PUSH
94566: LD_INT 30
94568: PUSH
94569: LD_INT 31
94571: PUSH
94572: LD_INT 32
94574: PUSH
94575: LD_INT 34
94577: PUSH
94578: LD_INT 36
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: PUSH
94614: LD_INT 101
94616: PUSH
94617: LD_INT 102
94619: PUSH
94620: LD_INT 103
94622: PUSH
94623: LD_INT 104
94625: PUSH
94626: LD_INT 105
94628: PUSH
94629: LD_INT 106
94631: PUSH
94632: LD_INT 107
94634: PUSH
94635: LD_INT 108
94637: PUSH
94638: LD_INT 109
94640: PUSH
94641: LD_INT 110
94643: PUSH
94644: LD_INT 111
94646: PUSH
94647: LD_INT 112
94649: PUSH
94650: LD_INT 114
94652: PUSH
94653: LD_INT 116
94655: PUSH
94656: LD_INT 117
94658: PUSH
94659: LD_INT 118
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: ST_TO_ADDR
94684: GO 96367
94686: LD_INT 12
94688: DOUBLE
94689: EQUAL
94690: IFTRUE 94694
94692: GO 94914
94694: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94695: LD_ADDR_VAR 0 1
94699: PUSH
94700: LD_INT 1
94702: PUSH
94703: LD_INT 2
94705: PUSH
94706: LD_INT 3
94708: PUSH
94709: LD_INT 4
94711: PUSH
94712: LD_INT 5
94714: PUSH
94715: LD_INT 6
94717: PUSH
94718: LD_INT 7
94720: PUSH
94721: LD_INT 8
94723: PUSH
94724: LD_INT 9
94726: PUSH
94727: LD_INT 10
94729: PUSH
94730: LD_INT 11
94732: PUSH
94733: LD_INT 12
94735: PUSH
94736: LD_INT 13
94738: PUSH
94739: LD_INT 14
94741: PUSH
94742: LD_INT 15
94744: PUSH
94745: LD_INT 16
94747: PUSH
94748: LD_INT 17
94750: PUSH
94751: LD_INT 18
94753: PUSH
94754: LD_INT 19
94756: PUSH
94757: LD_INT 20
94759: PUSH
94760: LD_INT 21
94762: PUSH
94763: LD_INT 22
94765: PUSH
94766: LD_INT 23
94768: PUSH
94769: LD_INT 24
94771: PUSH
94772: LD_INT 25
94774: PUSH
94775: LD_INT 26
94777: PUSH
94778: LD_INT 27
94780: PUSH
94781: LD_INT 28
94783: PUSH
94784: LD_INT 30
94786: PUSH
94787: LD_INT 31
94789: PUSH
94790: LD_INT 32
94792: PUSH
94793: LD_INT 33
94795: PUSH
94796: LD_INT 34
94798: PUSH
94799: LD_INT 36
94801: PUSH
94802: EMPTY
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 101
94840: PUSH
94841: LD_INT 102
94843: PUSH
94844: LD_INT 103
94846: PUSH
94847: LD_INT 104
94849: PUSH
94850: LD_INT 105
94852: PUSH
94853: LD_INT 106
94855: PUSH
94856: LD_INT 107
94858: PUSH
94859: LD_INT 108
94861: PUSH
94862: LD_INT 109
94864: PUSH
94865: LD_INT 110
94867: PUSH
94868: LD_INT 111
94870: PUSH
94871: LD_INT 112
94873: PUSH
94874: LD_INT 113
94876: PUSH
94877: LD_INT 114
94879: PUSH
94880: LD_INT 116
94882: PUSH
94883: LD_INT 117
94885: PUSH
94886: LD_INT 118
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: ST_TO_ADDR
94912: GO 96367
94914: LD_INT 13
94916: DOUBLE
94917: EQUAL
94918: IFTRUE 94922
94920: GO 95130
94922: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94923: LD_ADDR_VAR 0 1
94927: PUSH
94928: LD_INT 1
94930: PUSH
94931: LD_INT 2
94933: PUSH
94934: LD_INT 3
94936: PUSH
94937: LD_INT 4
94939: PUSH
94940: LD_INT 5
94942: PUSH
94943: LD_INT 8
94945: PUSH
94946: LD_INT 9
94948: PUSH
94949: LD_INT 10
94951: PUSH
94952: LD_INT 11
94954: PUSH
94955: LD_INT 12
94957: PUSH
94958: LD_INT 14
94960: PUSH
94961: LD_INT 15
94963: PUSH
94964: LD_INT 16
94966: PUSH
94967: LD_INT 17
94969: PUSH
94970: LD_INT 18
94972: PUSH
94973: LD_INT 19
94975: PUSH
94976: LD_INT 20
94978: PUSH
94979: LD_INT 21
94981: PUSH
94982: LD_INT 22
94984: PUSH
94985: LD_INT 23
94987: PUSH
94988: LD_INT 24
94990: PUSH
94991: LD_INT 25
94993: PUSH
94994: LD_INT 26
94996: PUSH
94997: LD_INT 27
94999: PUSH
95000: LD_INT 28
95002: PUSH
95003: LD_INT 30
95005: PUSH
95006: LD_INT 31
95008: PUSH
95009: LD_INT 32
95011: PUSH
95012: LD_INT 33
95014: PUSH
95015: LD_INT 34
95017: PUSH
95018: LD_INT 36
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: PUSH
95054: LD_INT 101
95056: PUSH
95057: LD_INT 102
95059: PUSH
95060: LD_INT 103
95062: PUSH
95063: LD_INT 104
95065: PUSH
95066: LD_INT 105
95068: PUSH
95069: LD_INT 106
95071: PUSH
95072: LD_INT 107
95074: PUSH
95075: LD_INT 108
95077: PUSH
95078: LD_INT 109
95080: PUSH
95081: LD_INT 110
95083: PUSH
95084: LD_INT 111
95086: PUSH
95087: LD_INT 112
95089: PUSH
95090: LD_INT 113
95092: PUSH
95093: LD_INT 114
95095: PUSH
95096: LD_INT 116
95098: PUSH
95099: LD_INT 117
95101: PUSH
95102: LD_INT 118
95104: PUSH
95105: EMPTY
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: PUSH
95124: EMPTY
95125: LIST
95126: LIST
95127: ST_TO_ADDR
95128: GO 96367
95130: LD_INT 14
95132: DOUBLE
95133: EQUAL
95134: IFTRUE 95138
95136: GO 95362
95138: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95139: LD_ADDR_VAR 0 1
95143: PUSH
95144: LD_INT 1
95146: PUSH
95147: LD_INT 2
95149: PUSH
95150: LD_INT 3
95152: PUSH
95153: LD_INT 4
95155: PUSH
95156: LD_INT 5
95158: PUSH
95159: LD_INT 6
95161: PUSH
95162: LD_INT 7
95164: PUSH
95165: LD_INT 8
95167: PUSH
95168: LD_INT 9
95170: PUSH
95171: LD_INT 10
95173: PUSH
95174: LD_INT 11
95176: PUSH
95177: LD_INT 12
95179: PUSH
95180: LD_INT 13
95182: PUSH
95183: LD_INT 14
95185: PUSH
95186: LD_INT 15
95188: PUSH
95189: LD_INT 16
95191: PUSH
95192: LD_INT 17
95194: PUSH
95195: LD_INT 18
95197: PUSH
95198: LD_INT 19
95200: PUSH
95201: LD_INT 20
95203: PUSH
95204: LD_INT 21
95206: PUSH
95207: LD_INT 22
95209: PUSH
95210: LD_INT 23
95212: PUSH
95213: LD_INT 24
95215: PUSH
95216: LD_INT 25
95218: PUSH
95219: LD_INT 26
95221: PUSH
95222: LD_INT 27
95224: PUSH
95225: LD_INT 28
95227: PUSH
95228: LD_INT 29
95230: PUSH
95231: LD_INT 30
95233: PUSH
95234: LD_INT 31
95236: PUSH
95237: LD_INT 32
95239: PUSH
95240: LD_INT 33
95242: PUSH
95243: LD_INT 34
95245: PUSH
95246: LD_INT 36
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: PUSH
95286: LD_INT 101
95288: PUSH
95289: LD_INT 102
95291: PUSH
95292: LD_INT 103
95294: PUSH
95295: LD_INT 104
95297: PUSH
95298: LD_INT 105
95300: PUSH
95301: LD_INT 106
95303: PUSH
95304: LD_INT 107
95306: PUSH
95307: LD_INT 108
95309: PUSH
95310: LD_INT 109
95312: PUSH
95313: LD_INT 110
95315: PUSH
95316: LD_INT 111
95318: PUSH
95319: LD_INT 112
95321: PUSH
95322: LD_INT 113
95324: PUSH
95325: LD_INT 114
95327: PUSH
95328: LD_INT 116
95330: PUSH
95331: LD_INT 117
95333: PUSH
95334: LD_INT 118
95336: PUSH
95337: EMPTY
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: ST_TO_ADDR
95360: GO 96367
95362: LD_INT 15
95364: DOUBLE
95365: EQUAL
95366: IFTRUE 95370
95368: GO 95594
95370: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95371: LD_ADDR_VAR 0 1
95375: PUSH
95376: LD_INT 1
95378: PUSH
95379: LD_INT 2
95381: PUSH
95382: LD_INT 3
95384: PUSH
95385: LD_INT 4
95387: PUSH
95388: LD_INT 5
95390: PUSH
95391: LD_INT 6
95393: PUSH
95394: LD_INT 7
95396: PUSH
95397: LD_INT 8
95399: PUSH
95400: LD_INT 9
95402: PUSH
95403: LD_INT 10
95405: PUSH
95406: LD_INT 11
95408: PUSH
95409: LD_INT 12
95411: PUSH
95412: LD_INT 13
95414: PUSH
95415: LD_INT 14
95417: PUSH
95418: LD_INT 15
95420: PUSH
95421: LD_INT 16
95423: PUSH
95424: LD_INT 17
95426: PUSH
95427: LD_INT 18
95429: PUSH
95430: LD_INT 19
95432: PUSH
95433: LD_INT 20
95435: PUSH
95436: LD_INT 21
95438: PUSH
95439: LD_INT 22
95441: PUSH
95442: LD_INT 23
95444: PUSH
95445: LD_INT 24
95447: PUSH
95448: LD_INT 25
95450: PUSH
95451: LD_INT 26
95453: PUSH
95454: LD_INT 27
95456: PUSH
95457: LD_INT 28
95459: PUSH
95460: LD_INT 29
95462: PUSH
95463: LD_INT 30
95465: PUSH
95466: LD_INT 31
95468: PUSH
95469: LD_INT 32
95471: PUSH
95472: LD_INT 33
95474: PUSH
95475: LD_INT 34
95477: PUSH
95478: LD_INT 36
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 101
95520: PUSH
95521: LD_INT 102
95523: PUSH
95524: LD_INT 103
95526: PUSH
95527: LD_INT 104
95529: PUSH
95530: LD_INT 105
95532: PUSH
95533: LD_INT 106
95535: PUSH
95536: LD_INT 107
95538: PUSH
95539: LD_INT 108
95541: PUSH
95542: LD_INT 109
95544: PUSH
95545: LD_INT 110
95547: PUSH
95548: LD_INT 111
95550: PUSH
95551: LD_INT 112
95553: PUSH
95554: LD_INT 113
95556: PUSH
95557: LD_INT 114
95559: PUSH
95560: LD_INT 116
95562: PUSH
95563: LD_INT 117
95565: PUSH
95566: LD_INT 118
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: ST_TO_ADDR
95592: GO 96367
95594: LD_INT 16
95596: DOUBLE
95597: EQUAL
95598: IFTRUE 95602
95600: GO 95738
95602: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95603: LD_ADDR_VAR 0 1
95607: PUSH
95608: LD_INT 2
95610: PUSH
95611: LD_INT 4
95613: PUSH
95614: LD_INT 5
95616: PUSH
95617: LD_INT 7
95619: PUSH
95620: LD_INT 11
95622: PUSH
95623: LD_INT 12
95625: PUSH
95626: LD_INT 15
95628: PUSH
95629: LD_INT 16
95631: PUSH
95632: LD_INT 20
95634: PUSH
95635: LD_INT 21
95637: PUSH
95638: LD_INT 22
95640: PUSH
95641: LD_INT 23
95643: PUSH
95644: LD_INT 25
95646: PUSH
95647: LD_INT 26
95649: PUSH
95650: LD_INT 30
95652: PUSH
95653: LD_INT 31
95655: PUSH
95656: LD_INT 32
95658: PUSH
95659: LD_INT 33
95661: PUSH
95662: LD_INT 34
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: PUSH
95686: LD_INT 101
95688: PUSH
95689: LD_INT 102
95691: PUSH
95692: LD_INT 103
95694: PUSH
95695: LD_INT 106
95697: PUSH
95698: LD_INT 108
95700: PUSH
95701: LD_INT 112
95703: PUSH
95704: LD_INT 113
95706: PUSH
95707: LD_INT 114
95709: PUSH
95710: LD_INT 116
95712: PUSH
95713: LD_INT 117
95715: PUSH
95716: LD_INT 118
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: ST_TO_ADDR
95736: GO 96367
95738: LD_INT 17
95740: DOUBLE
95741: EQUAL
95742: IFTRUE 95746
95744: GO 95970
95746: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95747: LD_ADDR_VAR 0 1
95751: PUSH
95752: LD_INT 1
95754: PUSH
95755: LD_INT 2
95757: PUSH
95758: LD_INT 3
95760: PUSH
95761: LD_INT 4
95763: PUSH
95764: LD_INT 5
95766: PUSH
95767: LD_INT 6
95769: PUSH
95770: LD_INT 7
95772: PUSH
95773: LD_INT 8
95775: PUSH
95776: LD_INT 9
95778: PUSH
95779: LD_INT 10
95781: PUSH
95782: LD_INT 11
95784: PUSH
95785: LD_INT 12
95787: PUSH
95788: LD_INT 13
95790: PUSH
95791: LD_INT 14
95793: PUSH
95794: LD_INT 15
95796: PUSH
95797: LD_INT 16
95799: PUSH
95800: LD_INT 17
95802: PUSH
95803: LD_INT 18
95805: PUSH
95806: LD_INT 19
95808: PUSH
95809: LD_INT 20
95811: PUSH
95812: LD_INT 21
95814: PUSH
95815: LD_INT 22
95817: PUSH
95818: LD_INT 23
95820: PUSH
95821: LD_INT 24
95823: PUSH
95824: LD_INT 25
95826: PUSH
95827: LD_INT 26
95829: PUSH
95830: LD_INT 27
95832: PUSH
95833: LD_INT 28
95835: PUSH
95836: LD_INT 29
95838: PUSH
95839: LD_INT 30
95841: PUSH
95842: LD_INT 31
95844: PUSH
95845: LD_INT 32
95847: PUSH
95848: LD_INT 33
95850: PUSH
95851: LD_INT 34
95853: PUSH
95854: LD_INT 36
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 101
95896: PUSH
95897: LD_INT 102
95899: PUSH
95900: LD_INT 103
95902: PUSH
95903: LD_INT 104
95905: PUSH
95906: LD_INT 105
95908: PUSH
95909: LD_INT 106
95911: PUSH
95912: LD_INT 107
95914: PUSH
95915: LD_INT 108
95917: PUSH
95918: LD_INT 109
95920: PUSH
95921: LD_INT 110
95923: PUSH
95924: LD_INT 111
95926: PUSH
95927: LD_INT 112
95929: PUSH
95930: LD_INT 113
95932: PUSH
95933: LD_INT 114
95935: PUSH
95936: LD_INT 116
95938: PUSH
95939: LD_INT 117
95941: PUSH
95942: LD_INT 118
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: ST_TO_ADDR
95968: GO 96367
95970: LD_INT 18
95972: DOUBLE
95973: EQUAL
95974: IFTRUE 95978
95976: GO 96126
95978: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95979: LD_ADDR_VAR 0 1
95983: PUSH
95984: LD_INT 2
95986: PUSH
95987: LD_INT 4
95989: PUSH
95990: LD_INT 5
95992: PUSH
95993: LD_INT 7
95995: PUSH
95996: LD_INT 11
95998: PUSH
95999: LD_INT 12
96001: PUSH
96002: LD_INT 15
96004: PUSH
96005: LD_INT 16
96007: PUSH
96008: LD_INT 20
96010: PUSH
96011: LD_INT 21
96013: PUSH
96014: LD_INT 22
96016: PUSH
96017: LD_INT 23
96019: PUSH
96020: LD_INT 25
96022: PUSH
96023: LD_INT 26
96025: PUSH
96026: LD_INT 30
96028: PUSH
96029: LD_INT 31
96031: PUSH
96032: LD_INT 32
96034: PUSH
96035: LD_INT 33
96037: PUSH
96038: LD_INT 34
96040: PUSH
96041: LD_INT 35
96043: PUSH
96044: LD_INT 36
96046: PUSH
96047: EMPTY
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 101
96072: PUSH
96073: LD_INT 102
96075: PUSH
96076: LD_INT 103
96078: PUSH
96079: LD_INT 106
96081: PUSH
96082: LD_INT 108
96084: PUSH
96085: LD_INT 112
96087: PUSH
96088: LD_INT 113
96090: PUSH
96091: LD_INT 114
96093: PUSH
96094: LD_INT 115
96096: PUSH
96097: LD_INT 116
96099: PUSH
96100: LD_INT 117
96102: PUSH
96103: LD_INT 118
96105: PUSH
96106: EMPTY
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: ST_TO_ADDR
96124: GO 96367
96126: LD_INT 19
96128: DOUBLE
96129: EQUAL
96130: IFTRUE 96134
96132: GO 96366
96134: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96135: LD_ADDR_VAR 0 1
96139: PUSH
96140: LD_INT 1
96142: PUSH
96143: LD_INT 2
96145: PUSH
96146: LD_INT 3
96148: PUSH
96149: LD_INT 4
96151: PUSH
96152: LD_INT 5
96154: PUSH
96155: LD_INT 6
96157: PUSH
96158: LD_INT 7
96160: PUSH
96161: LD_INT 8
96163: PUSH
96164: LD_INT 9
96166: PUSH
96167: LD_INT 10
96169: PUSH
96170: LD_INT 11
96172: PUSH
96173: LD_INT 12
96175: PUSH
96176: LD_INT 13
96178: PUSH
96179: LD_INT 14
96181: PUSH
96182: LD_INT 15
96184: PUSH
96185: LD_INT 16
96187: PUSH
96188: LD_INT 17
96190: PUSH
96191: LD_INT 18
96193: PUSH
96194: LD_INT 19
96196: PUSH
96197: LD_INT 20
96199: PUSH
96200: LD_INT 21
96202: PUSH
96203: LD_INT 22
96205: PUSH
96206: LD_INT 23
96208: PUSH
96209: LD_INT 24
96211: PUSH
96212: LD_INT 25
96214: PUSH
96215: LD_INT 26
96217: PUSH
96218: LD_INT 27
96220: PUSH
96221: LD_INT 28
96223: PUSH
96224: LD_INT 29
96226: PUSH
96227: LD_INT 30
96229: PUSH
96230: LD_INT 31
96232: PUSH
96233: LD_INT 32
96235: PUSH
96236: LD_INT 33
96238: PUSH
96239: LD_INT 34
96241: PUSH
96242: LD_INT 35
96244: PUSH
96245: LD_INT 36
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: PUSH
96286: LD_INT 101
96288: PUSH
96289: LD_INT 102
96291: PUSH
96292: LD_INT 103
96294: PUSH
96295: LD_INT 104
96297: PUSH
96298: LD_INT 105
96300: PUSH
96301: LD_INT 106
96303: PUSH
96304: LD_INT 107
96306: PUSH
96307: LD_INT 108
96309: PUSH
96310: LD_INT 109
96312: PUSH
96313: LD_INT 110
96315: PUSH
96316: LD_INT 111
96318: PUSH
96319: LD_INT 112
96321: PUSH
96322: LD_INT 113
96324: PUSH
96325: LD_INT 114
96327: PUSH
96328: LD_INT 115
96330: PUSH
96331: LD_INT 116
96333: PUSH
96334: LD_INT 117
96336: PUSH
96337: LD_INT 118
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: ST_TO_ADDR
96364: GO 96367
96366: POP
// end else
96367: GO 96598
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96369: LD_ADDR_VAR 0 1
96373: PUSH
96374: LD_INT 1
96376: PUSH
96377: LD_INT 2
96379: PUSH
96380: LD_INT 3
96382: PUSH
96383: LD_INT 4
96385: PUSH
96386: LD_INT 5
96388: PUSH
96389: LD_INT 6
96391: PUSH
96392: LD_INT 7
96394: PUSH
96395: LD_INT 8
96397: PUSH
96398: LD_INT 9
96400: PUSH
96401: LD_INT 10
96403: PUSH
96404: LD_INT 11
96406: PUSH
96407: LD_INT 12
96409: PUSH
96410: LD_INT 13
96412: PUSH
96413: LD_INT 14
96415: PUSH
96416: LD_INT 15
96418: PUSH
96419: LD_INT 16
96421: PUSH
96422: LD_INT 17
96424: PUSH
96425: LD_INT 18
96427: PUSH
96428: LD_INT 19
96430: PUSH
96431: LD_INT 20
96433: PUSH
96434: LD_INT 21
96436: PUSH
96437: LD_INT 22
96439: PUSH
96440: LD_INT 23
96442: PUSH
96443: LD_INT 24
96445: PUSH
96446: LD_INT 25
96448: PUSH
96449: LD_INT 26
96451: PUSH
96452: LD_INT 27
96454: PUSH
96455: LD_INT 28
96457: PUSH
96458: LD_INT 29
96460: PUSH
96461: LD_INT 30
96463: PUSH
96464: LD_INT 31
96466: PUSH
96467: LD_INT 32
96469: PUSH
96470: LD_INT 33
96472: PUSH
96473: LD_INT 34
96475: PUSH
96476: LD_INT 35
96478: PUSH
96479: LD_INT 36
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: PUSH
96520: LD_INT 101
96522: PUSH
96523: LD_INT 102
96525: PUSH
96526: LD_INT 103
96528: PUSH
96529: LD_INT 104
96531: PUSH
96532: LD_INT 105
96534: PUSH
96535: LD_INT 106
96537: PUSH
96538: LD_INT 107
96540: PUSH
96541: LD_INT 108
96543: PUSH
96544: LD_INT 109
96546: PUSH
96547: LD_INT 110
96549: PUSH
96550: LD_INT 111
96552: PUSH
96553: LD_INT 112
96555: PUSH
96556: LD_INT 113
96558: PUSH
96559: LD_INT 114
96561: PUSH
96562: LD_INT 115
96564: PUSH
96565: LD_INT 116
96567: PUSH
96568: LD_INT 117
96570: PUSH
96571: LD_INT 118
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: PUSH
96594: EMPTY
96595: LIST
96596: LIST
96597: ST_TO_ADDR
// if result then
96598: LD_VAR 0 1
96602: IFFALSE 96891
// begin normal :=  ;
96604: LD_ADDR_VAR 0 3
96608: PUSH
96609: LD_STRING 
96611: ST_TO_ADDR
// hardcore :=  ;
96612: LD_ADDR_VAR 0 4
96616: PUSH
96617: LD_STRING 
96619: ST_TO_ADDR
// for i = 1 to normalCounter do
96620: LD_ADDR_VAR 0 5
96624: PUSH
96625: DOUBLE
96626: LD_INT 1
96628: DEC
96629: ST_TO_ADDR
96630: LD_EXP 140
96634: PUSH
96635: FOR_TO
96636: IFFALSE 96737
// begin tmp := 0 ;
96638: LD_ADDR_VAR 0 2
96642: PUSH
96643: LD_STRING 0
96645: ST_TO_ADDR
// if result [ 1 ] then
96646: LD_VAR 0 1
96650: PUSH
96651: LD_INT 1
96653: ARRAY
96654: IFFALSE 96719
// if result [ 1 ] [ 1 ] = i then
96656: LD_VAR 0 1
96660: PUSH
96661: LD_INT 1
96663: ARRAY
96664: PUSH
96665: LD_INT 1
96667: ARRAY
96668: PUSH
96669: LD_VAR 0 5
96673: EQUAL
96674: IFFALSE 96719
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96676: LD_ADDR_VAR 0 1
96680: PUSH
96681: LD_VAR 0 1
96685: PPUSH
96686: LD_INT 1
96688: PPUSH
96689: LD_VAR 0 1
96693: PUSH
96694: LD_INT 1
96696: ARRAY
96697: PPUSH
96698: LD_INT 1
96700: PPUSH
96701: CALL_OW 3
96705: PPUSH
96706: CALL_OW 1
96710: ST_TO_ADDR
// tmp := 1 ;
96711: LD_ADDR_VAR 0 2
96715: PUSH
96716: LD_STRING 1
96718: ST_TO_ADDR
// end ; normal := normal & tmp ;
96719: LD_ADDR_VAR 0 3
96723: PUSH
96724: LD_VAR 0 3
96728: PUSH
96729: LD_VAR 0 2
96733: STR
96734: ST_TO_ADDR
// end ;
96735: GO 96635
96737: POP
96738: POP
// for i = 1 to hardcoreCounter do
96739: LD_ADDR_VAR 0 5
96743: PUSH
96744: DOUBLE
96745: LD_INT 1
96747: DEC
96748: ST_TO_ADDR
96749: LD_EXP 141
96753: PUSH
96754: FOR_TO
96755: IFFALSE 96860
// begin tmp := 0 ;
96757: LD_ADDR_VAR 0 2
96761: PUSH
96762: LD_STRING 0
96764: ST_TO_ADDR
// if result [ 2 ] then
96765: LD_VAR 0 1
96769: PUSH
96770: LD_INT 2
96772: ARRAY
96773: IFFALSE 96842
// if result [ 2 ] [ 1 ] = 100 + i then
96775: LD_VAR 0 1
96779: PUSH
96780: LD_INT 2
96782: ARRAY
96783: PUSH
96784: LD_INT 1
96786: ARRAY
96787: PUSH
96788: LD_INT 100
96790: PUSH
96791: LD_VAR 0 5
96795: PLUS
96796: EQUAL
96797: IFFALSE 96842
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96799: LD_ADDR_VAR 0 1
96803: PUSH
96804: LD_VAR 0 1
96808: PPUSH
96809: LD_INT 2
96811: PPUSH
96812: LD_VAR 0 1
96816: PUSH
96817: LD_INT 2
96819: ARRAY
96820: PPUSH
96821: LD_INT 1
96823: PPUSH
96824: CALL_OW 3
96828: PPUSH
96829: CALL_OW 1
96833: ST_TO_ADDR
// tmp := 1 ;
96834: LD_ADDR_VAR 0 2
96838: PUSH
96839: LD_STRING 1
96841: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96842: LD_ADDR_VAR 0 4
96846: PUSH
96847: LD_VAR 0 4
96851: PUSH
96852: LD_VAR 0 2
96856: STR
96857: ST_TO_ADDR
// end ;
96858: GO 96754
96860: POP
96861: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
96862: LD_STRING getStreamItemsFromMission("
96864: PUSH
96865: LD_VAR 0 3
96869: STR
96870: PUSH
96871: LD_STRING ","
96873: STR
96874: PUSH
96875: LD_VAR 0 4
96879: STR
96880: PUSH
96881: LD_STRING ")
96883: STR
96884: PPUSH
96885: CALL_OW 559
// end else
96889: GO 96898
// ToLua ( getStreamItemsFromMission("","") ) ;
96891: LD_STRING getStreamItemsFromMission("","")
96893: PPUSH
96894: CALL_OW 559
// end ;
96898: LD_VAR 0 1
96902: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96903: LD_EXP 139
96907: PUSH
96908: LD_EXP 144
96912: AND
96913: IFFALSE 97037
96915: GO 96917
96917: DISABLE
96918: LD_INT 0
96920: PPUSH
96921: PPUSH
// begin enable ;
96922: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96923: LD_ADDR_VAR 0 2
96927: PUSH
96928: LD_INT 22
96930: PUSH
96931: LD_OWVAR 2
96935: PUSH
96936: EMPTY
96937: LIST
96938: LIST
96939: PUSH
96940: LD_INT 2
96942: PUSH
96943: LD_INT 34
96945: PUSH
96946: LD_INT 7
96948: PUSH
96949: EMPTY
96950: LIST
96951: LIST
96952: PUSH
96953: LD_INT 34
96955: PUSH
96956: LD_INT 45
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 34
96965: PUSH
96966: LD_INT 28
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 34
96975: PUSH
96976: LD_INT 47
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: EMPTY
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PPUSH
96994: CALL_OW 69
96998: ST_TO_ADDR
// if not tmp then
96999: LD_VAR 0 2
97003: NOT
97004: IFFALSE 97008
// exit ;
97006: GO 97037
// for i in tmp do
97008: LD_ADDR_VAR 0 1
97012: PUSH
97013: LD_VAR 0 2
97017: PUSH
97018: FOR_IN
97019: IFFALSE 97035
// begin SetLives ( i , 0 ) ;
97021: LD_VAR 0 1
97025: PPUSH
97026: LD_INT 0
97028: PPUSH
97029: CALL_OW 234
// end ;
97033: GO 97018
97035: POP
97036: POP
// end ;
97037: PPOPN 2
97039: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97040: LD_EXP 139
97044: PUSH
97045: LD_EXP 145
97049: AND
97050: IFFALSE 97134
97052: GO 97054
97054: DISABLE
97055: LD_INT 0
97057: PPUSH
97058: PPUSH
// begin enable ;
97059: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97060: LD_ADDR_VAR 0 2
97064: PUSH
97065: LD_INT 22
97067: PUSH
97068: LD_OWVAR 2
97072: PUSH
97073: EMPTY
97074: LIST
97075: LIST
97076: PUSH
97077: LD_INT 32
97079: PUSH
97080: LD_INT 3
97082: PUSH
97083: EMPTY
97084: LIST
97085: LIST
97086: PUSH
97087: EMPTY
97088: LIST
97089: LIST
97090: PPUSH
97091: CALL_OW 69
97095: ST_TO_ADDR
// if not tmp then
97096: LD_VAR 0 2
97100: NOT
97101: IFFALSE 97105
// exit ;
97103: GO 97134
// for i in tmp do
97105: LD_ADDR_VAR 0 1
97109: PUSH
97110: LD_VAR 0 2
97114: PUSH
97115: FOR_IN
97116: IFFALSE 97132
// begin SetLives ( i , 0 ) ;
97118: LD_VAR 0 1
97122: PPUSH
97123: LD_INT 0
97125: PPUSH
97126: CALL_OW 234
// end ;
97130: GO 97115
97132: POP
97133: POP
// end ;
97134: PPOPN 2
97136: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97137: LD_EXP 139
97141: PUSH
97142: LD_EXP 142
97146: AND
97147: IFFALSE 97240
97149: GO 97151
97151: DISABLE
97152: LD_INT 0
97154: PPUSH
// begin enable ;
97155: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97156: LD_ADDR_VAR 0 1
97160: PUSH
97161: LD_INT 22
97163: PUSH
97164: LD_OWVAR 2
97168: PUSH
97169: EMPTY
97170: LIST
97171: LIST
97172: PUSH
97173: LD_INT 2
97175: PUSH
97176: LD_INT 25
97178: PUSH
97179: LD_INT 5
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: LD_INT 25
97188: PUSH
97189: LD_INT 9
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 25
97198: PUSH
97199: LD_INT 8
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: EMPTY
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PPUSH
97216: CALL_OW 69
97220: PUSH
97221: FOR_IN
97222: IFFALSE 97238
// begin SetClass ( i , 1 ) ;
97224: LD_VAR 0 1
97228: PPUSH
97229: LD_INT 1
97231: PPUSH
97232: CALL_OW 336
// end ;
97236: GO 97221
97238: POP
97239: POP
// end ;
97240: PPOPN 1
97242: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97243: LD_EXP 139
97247: PUSH
97248: LD_EXP 143
97252: AND
97253: PUSH
97254: LD_OWVAR 65
97258: PUSH
97259: LD_INT 7
97261: LESS
97262: AND
97263: IFFALSE 97277
97265: GO 97267
97267: DISABLE
// begin enable ;
97268: ENABLE
// game_speed := 7 ;
97269: LD_ADDR_OWVAR 65
97273: PUSH
97274: LD_INT 7
97276: ST_TO_ADDR
// end ;
97277: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97278: LD_EXP 139
97282: PUSH
97283: LD_EXP 146
97287: AND
97288: IFFALSE 97490
97290: GO 97292
97292: DISABLE
97293: LD_INT 0
97295: PPUSH
97296: PPUSH
97297: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97298: LD_ADDR_VAR 0 3
97302: PUSH
97303: LD_INT 81
97305: PUSH
97306: LD_OWVAR 2
97310: PUSH
97311: EMPTY
97312: LIST
97313: LIST
97314: PUSH
97315: LD_INT 21
97317: PUSH
97318: LD_INT 1
97320: PUSH
97321: EMPTY
97322: LIST
97323: LIST
97324: PUSH
97325: EMPTY
97326: LIST
97327: LIST
97328: PPUSH
97329: CALL_OW 69
97333: ST_TO_ADDR
// if not tmp then
97334: LD_VAR 0 3
97338: NOT
97339: IFFALSE 97343
// exit ;
97341: GO 97490
// if tmp > 5 then
97343: LD_VAR 0 3
97347: PUSH
97348: LD_INT 5
97350: GREATER
97351: IFFALSE 97363
// k := 5 else
97353: LD_ADDR_VAR 0 2
97357: PUSH
97358: LD_INT 5
97360: ST_TO_ADDR
97361: GO 97373
// k := tmp ;
97363: LD_ADDR_VAR 0 2
97367: PUSH
97368: LD_VAR 0 3
97372: ST_TO_ADDR
// for i := 1 to k do
97373: LD_ADDR_VAR 0 1
97377: PUSH
97378: DOUBLE
97379: LD_INT 1
97381: DEC
97382: ST_TO_ADDR
97383: LD_VAR 0 2
97387: PUSH
97388: FOR_TO
97389: IFFALSE 97488
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97391: LD_VAR 0 3
97395: PUSH
97396: LD_VAR 0 1
97400: ARRAY
97401: PPUSH
97402: LD_VAR 0 1
97406: PUSH
97407: LD_INT 4
97409: MOD
97410: PUSH
97411: LD_INT 1
97413: PLUS
97414: PPUSH
97415: CALL_OW 259
97419: PUSH
97420: LD_INT 10
97422: LESS
97423: IFFALSE 97486
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97425: LD_VAR 0 3
97429: PUSH
97430: LD_VAR 0 1
97434: ARRAY
97435: PPUSH
97436: LD_VAR 0 1
97440: PUSH
97441: LD_INT 4
97443: MOD
97444: PUSH
97445: LD_INT 1
97447: PLUS
97448: PPUSH
97449: LD_VAR 0 3
97453: PUSH
97454: LD_VAR 0 1
97458: ARRAY
97459: PPUSH
97460: LD_VAR 0 1
97464: PUSH
97465: LD_INT 4
97467: MOD
97468: PUSH
97469: LD_INT 1
97471: PLUS
97472: PPUSH
97473: CALL_OW 259
97477: PUSH
97478: LD_INT 1
97480: PLUS
97481: PPUSH
97482: CALL_OW 237
97486: GO 97388
97488: POP
97489: POP
// end ;
97490: PPOPN 3
97492: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97493: LD_EXP 139
97497: PUSH
97498: LD_EXP 147
97502: AND
97503: IFFALSE 97523
97505: GO 97507
97507: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97508: LD_INT 4
97510: PPUSH
97511: LD_OWVAR 2
97515: PPUSH
97516: LD_INT 0
97518: PPUSH
97519: CALL_OW 324
97523: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97524: LD_EXP 139
97528: PUSH
97529: LD_EXP 176
97533: AND
97534: IFFALSE 97554
97536: GO 97538
97538: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97539: LD_INT 19
97541: PPUSH
97542: LD_OWVAR 2
97546: PPUSH
97547: LD_INT 0
97549: PPUSH
97550: CALL_OW 324
97554: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97555: LD_EXP 139
97559: PUSH
97560: LD_EXP 148
97564: AND
97565: IFFALSE 97667
97567: GO 97569
97569: DISABLE
97570: LD_INT 0
97572: PPUSH
97573: PPUSH
// begin enable ;
97574: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97575: LD_ADDR_VAR 0 2
97579: PUSH
97580: LD_INT 22
97582: PUSH
97583: LD_OWVAR 2
97587: PUSH
97588: EMPTY
97589: LIST
97590: LIST
97591: PUSH
97592: LD_INT 2
97594: PUSH
97595: LD_INT 34
97597: PUSH
97598: LD_INT 11
97600: PUSH
97601: EMPTY
97602: LIST
97603: LIST
97604: PUSH
97605: LD_INT 34
97607: PUSH
97608: LD_INT 30
97610: PUSH
97611: EMPTY
97612: LIST
97613: LIST
97614: PUSH
97615: EMPTY
97616: LIST
97617: LIST
97618: LIST
97619: PUSH
97620: EMPTY
97621: LIST
97622: LIST
97623: PPUSH
97624: CALL_OW 69
97628: ST_TO_ADDR
// if not tmp then
97629: LD_VAR 0 2
97633: NOT
97634: IFFALSE 97638
// exit ;
97636: GO 97667
// for i in tmp do
97638: LD_ADDR_VAR 0 1
97642: PUSH
97643: LD_VAR 0 2
97647: PUSH
97648: FOR_IN
97649: IFFALSE 97665
// begin SetLives ( i , 0 ) ;
97651: LD_VAR 0 1
97655: PPUSH
97656: LD_INT 0
97658: PPUSH
97659: CALL_OW 234
// end ;
97663: GO 97648
97665: POP
97666: POP
// end ;
97667: PPOPN 2
97669: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97670: LD_EXP 139
97674: PUSH
97675: LD_EXP 149
97679: AND
97680: IFFALSE 97700
97682: GO 97684
97684: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97685: LD_INT 32
97687: PPUSH
97688: LD_OWVAR 2
97692: PPUSH
97693: LD_INT 0
97695: PPUSH
97696: CALL_OW 324
97700: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97701: LD_EXP 139
97705: PUSH
97706: LD_EXP 150
97710: AND
97711: IFFALSE 97892
97713: GO 97715
97715: DISABLE
97716: LD_INT 0
97718: PPUSH
97719: PPUSH
97720: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97721: LD_ADDR_VAR 0 2
97725: PUSH
97726: LD_INT 22
97728: PUSH
97729: LD_OWVAR 2
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: PUSH
97738: LD_INT 33
97740: PUSH
97741: LD_INT 3
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PUSH
97748: EMPTY
97749: LIST
97750: LIST
97751: PPUSH
97752: CALL_OW 69
97756: ST_TO_ADDR
// if not tmp then
97757: LD_VAR 0 2
97761: NOT
97762: IFFALSE 97766
// exit ;
97764: GO 97892
// side := 0 ;
97766: LD_ADDR_VAR 0 3
97770: PUSH
97771: LD_INT 0
97773: ST_TO_ADDR
// for i := 1 to 8 do
97774: LD_ADDR_VAR 0 1
97778: PUSH
97779: DOUBLE
97780: LD_INT 1
97782: DEC
97783: ST_TO_ADDR
97784: LD_INT 8
97786: PUSH
97787: FOR_TO
97788: IFFALSE 97836
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97790: LD_OWVAR 2
97794: PUSH
97795: LD_VAR 0 1
97799: NONEQUAL
97800: PUSH
97801: LD_OWVAR 2
97805: PPUSH
97806: LD_VAR 0 1
97810: PPUSH
97811: CALL_OW 81
97815: PUSH
97816: LD_INT 2
97818: EQUAL
97819: AND
97820: IFFALSE 97834
// begin side := i ;
97822: LD_ADDR_VAR 0 3
97826: PUSH
97827: LD_VAR 0 1
97831: ST_TO_ADDR
// break ;
97832: GO 97836
// end ;
97834: GO 97787
97836: POP
97837: POP
// if not side then
97838: LD_VAR 0 3
97842: NOT
97843: IFFALSE 97847
// exit ;
97845: GO 97892
// for i := 1 to tmp do
97847: LD_ADDR_VAR 0 1
97851: PUSH
97852: DOUBLE
97853: LD_INT 1
97855: DEC
97856: ST_TO_ADDR
97857: LD_VAR 0 2
97861: PUSH
97862: FOR_TO
97863: IFFALSE 97890
// if Prob ( 60 ) then
97865: LD_INT 60
97867: PPUSH
97868: CALL_OW 13
97872: IFFALSE 97888
// SetSide ( i , side ) ;
97874: LD_VAR 0 1
97878: PPUSH
97879: LD_VAR 0 3
97883: PPUSH
97884: CALL_OW 235
97888: GO 97862
97890: POP
97891: POP
// end ;
97892: PPOPN 3
97894: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97895: LD_EXP 139
97899: PUSH
97900: LD_EXP 152
97904: AND
97905: IFFALSE 98024
97907: GO 97909
97909: DISABLE
97910: LD_INT 0
97912: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97913: LD_ADDR_VAR 0 1
97917: PUSH
97918: LD_INT 22
97920: PUSH
97921: LD_OWVAR 2
97925: PUSH
97926: EMPTY
97927: LIST
97928: LIST
97929: PUSH
97930: LD_INT 21
97932: PUSH
97933: LD_INT 1
97935: PUSH
97936: EMPTY
97937: LIST
97938: LIST
97939: PUSH
97940: LD_INT 3
97942: PUSH
97943: LD_INT 23
97945: PUSH
97946: LD_INT 0
97948: PUSH
97949: EMPTY
97950: LIST
97951: LIST
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: EMPTY
97958: LIST
97959: LIST
97960: LIST
97961: PPUSH
97962: CALL_OW 69
97966: PUSH
97967: FOR_IN
97968: IFFALSE 98022
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97970: LD_VAR 0 1
97974: PPUSH
97975: CALL_OW 257
97979: PUSH
97980: LD_INT 1
97982: PUSH
97983: LD_INT 2
97985: PUSH
97986: LD_INT 3
97988: PUSH
97989: LD_INT 4
97991: PUSH
97992: EMPTY
97993: LIST
97994: LIST
97995: LIST
97996: LIST
97997: IN
97998: IFFALSE 98020
// SetClass ( un , rand ( 1 , 4 ) ) ;
98000: LD_VAR 0 1
98004: PPUSH
98005: LD_INT 1
98007: PPUSH
98008: LD_INT 4
98010: PPUSH
98011: CALL_OW 12
98015: PPUSH
98016: CALL_OW 336
98020: GO 97967
98022: POP
98023: POP
// end ;
98024: PPOPN 1
98026: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98027: LD_EXP 139
98031: PUSH
98032: LD_EXP 151
98036: AND
98037: IFFALSE 98116
98039: GO 98041
98041: DISABLE
98042: LD_INT 0
98044: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98045: LD_ADDR_VAR 0 1
98049: PUSH
98050: LD_INT 22
98052: PUSH
98053: LD_OWVAR 2
98057: PUSH
98058: EMPTY
98059: LIST
98060: LIST
98061: PUSH
98062: LD_INT 21
98064: PUSH
98065: LD_INT 3
98067: PUSH
98068: EMPTY
98069: LIST
98070: LIST
98071: PUSH
98072: EMPTY
98073: LIST
98074: LIST
98075: PPUSH
98076: CALL_OW 69
98080: ST_TO_ADDR
// if not tmp then
98081: LD_VAR 0 1
98085: NOT
98086: IFFALSE 98090
// exit ;
98088: GO 98116
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98090: LD_VAR 0 1
98094: PUSH
98095: LD_INT 1
98097: PPUSH
98098: LD_VAR 0 1
98102: PPUSH
98103: CALL_OW 12
98107: ARRAY
98108: PPUSH
98109: LD_INT 100
98111: PPUSH
98112: CALL_OW 234
// end ;
98116: PPOPN 1
98118: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98119: LD_EXP 139
98123: PUSH
98124: LD_EXP 153
98128: AND
98129: IFFALSE 98227
98131: GO 98133
98133: DISABLE
98134: LD_INT 0
98136: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98137: LD_ADDR_VAR 0 1
98141: PUSH
98142: LD_INT 22
98144: PUSH
98145: LD_OWVAR 2
98149: PUSH
98150: EMPTY
98151: LIST
98152: LIST
98153: PUSH
98154: LD_INT 21
98156: PUSH
98157: LD_INT 1
98159: PUSH
98160: EMPTY
98161: LIST
98162: LIST
98163: PUSH
98164: EMPTY
98165: LIST
98166: LIST
98167: PPUSH
98168: CALL_OW 69
98172: ST_TO_ADDR
// if not tmp then
98173: LD_VAR 0 1
98177: NOT
98178: IFFALSE 98182
// exit ;
98180: GO 98227
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98182: LD_VAR 0 1
98186: PUSH
98187: LD_INT 1
98189: PPUSH
98190: LD_VAR 0 1
98194: PPUSH
98195: CALL_OW 12
98199: ARRAY
98200: PPUSH
98201: LD_INT 1
98203: PPUSH
98204: LD_INT 4
98206: PPUSH
98207: CALL_OW 12
98211: PPUSH
98212: LD_INT 3000
98214: PPUSH
98215: LD_INT 9000
98217: PPUSH
98218: CALL_OW 12
98222: PPUSH
98223: CALL_OW 492
// end ;
98227: PPOPN 1
98229: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98230: LD_EXP 139
98234: PUSH
98235: LD_EXP 154
98239: AND
98240: IFFALSE 98260
98242: GO 98244
98244: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98245: LD_INT 1
98247: PPUSH
98248: LD_OWVAR 2
98252: PPUSH
98253: LD_INT 0
98255: PPUSH
98256: CALL_OW 324
98260: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98261: LD_EXP 139
98265: PUSH
98266: LD_EXP 155
98270: AND
98271: IFFALSE 98354
98273: GO 98275
98275: DISABLE
98276: LD_INT 0
98278: PPUSH
98279: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98280: LD_ADDR_VAR 0 2
98284: PUSH
98285: LD_INT 22
98287: PUSH
98288: LD_OWVAR 2
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: PUSH
98297: LD_INT 21
98299: PUSH
98300: LD_INT 3
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: PPUSH
98311: CALL_OW 69
98315: ST_TO_ADDR
// if not tmp then
98316: LD_VAR 0 2
98320: NOT
98321: IFFALSE 98325
// exit ;
98323: GO 98354
// for i in tmp do
98325: LD_ADDR_VAR 0 1
98329: PUSH
98330: LD_VAR 0 2
98334: PUSH
98335: FOR_IN
98336: IFFALSE 98352
// SetBLevel ( i , 10 ) ;
98338: LD_VAR 0 1
98342: PPUSH
98343: LD_INT 10
98345: PPUSH
98346: CALL_OW 241
98350: GO 98335
98352: POP
98353: POP
// end ;
98354: PPOPN 2
98356: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98357: LD_EXP 139
98361: PUSH
98362: LD_EXP 156
98366: AND
98367: IFFALSE 98478
98369: GO 98371
98371: DISABLE
98372: LD_INT 0
98374: PPUSH
98375: PPUSH
98376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98377: LD_ADDR_VAR 0 3
98381: PUSH
98382: LD_INT 22
98384: PUSH
98385: LD_OWVAR 2
98389: PUSH
98390: EMPTY
98391: LIST
98392: LIST
98393: PUSH
98394: LD_INT 25
98396: PUSH
98397: LD_INT 1
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: PUSH
98404: EMPTY
98405: LIST
98406: LIST
98407: PPUSH
98408: CALL_OW 69
98412: ST_TO_ADDR
// if not tmp then
98413: LD_VAR 0 3
98417: NOT
98418: IFFALSE 98422
// exit ;
98420: GO 98478
// un := tmp [ rand ( 1 , tmp ) ] ;
98422: LD_ADDR_VAR 0 2
98426: PUSH
98427: LD_VAR 0 3
98431: PUSH
98432: LD_INT 1
98434: PPUSH
98435: LD_VAR 0 3
98439: PPUSH
98440: CALL_OW 12
98444: ARRAY
98445: ST_TO_ADDR
// if Crawls ( un ) then
98446: LD_VAR 0 2
98450: PPUSH
98451: CALL_OW 318
98455: IFFALSE 98466
// ComWalk ( un ) ;
98457: LD_VAR 0 2
98461: PPUSH
98462: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98466: LD_VAR 0 2
98470: PPUSH
98471: LD_INT 5
98473: PPUSH
98474: CALL_OW 336
// end ;
98478: PPOPN 3
98480: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98481: LD_EXP 139
98485: PUSH
98486: LD_EXP 157
98490: AND
98491: PUSH
98492: LD_OWVAR 67
98496: PUSH
98497: LD_INT 4
98499: LESS
98500: AND
98501: IFFALSE 98520
98503: GO 98505
98505: DISABLE
// begin Difficulty := Difficulty + 1 ;
98506: LD_ADDR_OWVAR 67
98510: PUSH
98511: LD_OWVAR 67
98515: PUSH
98516: LD_INT 1
98518: PLUS
98519: ST_TO_ADDR
// end ;
98520: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98521: LD_EXP 139
98525: PUSH
98526: LD_EXP 158
98530: AND
98531: IFFALSE 98634
98533: GO 98535
98535: DISABLE
98536: LD_INT 0
98538: PPUSH
// begin for i := 1 to 5 do
98539: LD_ADDR_VAR 0 1
98543: PUSH
98544: DOUBLE
98545: LD_INT 1
98547: DEC
98548: ST_TO_ADDR
98549: LD_INT 5
98551: PUSH
98552: FOR_TO
98553: IFFALSE 98632
// begin uc_nation := nation_nature ;
98555: LD_ADDR_OWVAR 21
98559: PUSH
98560: LD_INT 0
98562: ST_TO_ADDR
// uc_side := 0 ;
98563: LD_ADDR_OWVAR 20
98567: PUSH
98568: LD_INT 0
98570: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98571: LD_ADDR_OWVAR 29
98575: PUSH
98576: LD_INT 12
98578: PUSH
98579: LD_INT 12
98581: PUSH
98582: EMPTY
98583: LIST
98584: LIST
98585: ST_TO_ADDR
// hc_agressivity := 20 ;
98586: LD_ADDR_OWVAR 35
98590: PUSH
98591: LD_INT 20
98593: ST_TO_ADDR
// hc_class := class_tiger ;
98594: LD_ADDR_OWVAR 28
98598: PUSH
98599: LD_INT 14
98601: ST_TO_ADDR
// hc_gallery :=  ;
98602: LD_ADDR_OWVAR 33
98606: PUSH
98607: LD_STRING 
98609: ST_TO_ADDR
// hc_name :=  ;
98610: LD_ADDR_OWVAR 26
98614: PUSH
98615: LD_STRING 
98617: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98618: CALL_OW 44
98622: PPUSH
98623: LD_INT 0
98625: PPUSH
98626: CALL_OW 51
// end ;
98630: GO 98552
98632: POP
98633: POP
// end ;
98634: PPOPN 1
98636: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98637: LD_EXP 139
98641: PUSH
98642: LD_EXP 159
98646: AND
98647: IFFALSE 98656
98649: GO 98651
98651: DISABLE
// StreamSibBomb ;
98652: CALL 98657 0 0
98656: END
// export function StreamSibBomb ; var i , x , y ; begin
98657: LD_INT 0
98659: PPUSH
98660: PPUSH
98661: PPUSH
98662: PPUSH
// result := false ;
98663: LD_ADDR_VAR 0 1
98667: PUSH
98668: LD_INT 0
98670: ST_TO_ADDR
// for i := 1 to 16 do
98671: LD_ADDR_VAR 0 2
98675: PUSH
98676: DOUBLE
98677: LD_INT 1
98679: DEC
98680: ST_TO_ADDR
98681: LD_INT 16
98683: PUSH
98684: FOR_TO
98685: IFFALSE 98884
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98687: LD_ADDR_VAR 0 3
98691: PUSH
98692: LD_INT 10
98694: PUSH
98695: LD_INT 20
98697: PUSH
98698: LD_INT 30
98700: PUSH
98701: LD_INT 40
98703: PUSH
98704: LD_INT 50
98706: PUSH
98707: LD_INT 60
98709: PUSH
98710: LD_INT 70
98712: PUSH
98713: LD_INT 80
98715: PUSH
98716: LD_INT 90
98718: PUSH
98719: LD_INT 100
98721: PUSH
98722: LD_INT 110
98724: PUSH
98725: LD_INT 120
98727: PUSH
98728: LD_INT 130
98730: PUSH
98731: LD_INT 140
98733: PUSH
98734: LD_INT 150
98736: PUSH
98737: EMPTY
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: PUSH
98754: LD_INT 1
98756: PPUSH
98757: LD_INT 15
98759: PPUSH
98760: CALL_OW 12
98764: ARRAY
98765: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98766: LD_ADDR_VAR 0 4
98770: PUSH
98771: LD_INT 10
98773: PUSH
98774: LD_INT 20
98776: PUSH
98777: LD_INT 30
98779: PUSH
98780: LD_INT 40
98782: PUSH
98783: LD_INT 50
98785: PUSH
98786: LD_INT 60
98788: PUSH
98789: LD_INT 70
98791: PUSH
98792: LD_INT 80
98794: PUSH
98795: LD_INT 90
98797: PUSH
98798: LD_INT 100
98800: PUSH
98801: LD_INT 110
98803: PUSH
98804: LD_INT 120
98806: PUSH
98807: LD_INT 130
98809: PUSH
98810: LD_INT 140
98812: PUSH
98813: LD_INT 150
98815: PUSH
98816: EMPTY
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: PUSH
98833: LD_INT 1
98835: PPUSH
98836: LD_INT 15
98838: PPUSH
98839: CALL_OW 12
98843: ARRAY
98844: ST_TO_ADDR
// if ValidHex ( x , y ) then
98845: LD_VAR 0 3
98849: PPUSH
98850: LD_VAR 0 4
98854: PPUSH
98855: CALL_OW 488
98859: IFFALSE 98882
// begin result := [ x , y ] ;
98861: LD_ADDR_VAR 0 1
98865: PUSH
98866: LD_VAR 0 3
98870: PUSH
98871: LD_VAR 0 4
98875: PUSH
98876: EMPTY
98877: LIST
98878: LIST
98879: ST_TO_ADDR
// break ;
98880: GO 98884
// end ; end ;
98882: GO 98684
98884: POP
98885: POP
// if result then
98886: LD_VAR 0 1
98890: IFFALSE 98950
// begin ToLua ( playSibBomb() ) ;
98892: LD_STRING playSibBomb()
98894: PPUSH
98895: CALL_OW 559
// wait ( 0 0$14 ) ;
98899: LD_INT 490
98901: PPUSH
98902: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98906: LD_VAR 0 1
98910: PUSH
98911: LD_INT 1
98913: ARRAY
98914: PPUSH
98915: LD_VAR 0 1
98919: PUSH
98920: LD_INT 2
98922: ARRAY
98923: PPUSH
98924: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98928: LD_VAR 0 1
98932: PUSH
98933: LD_INT 1
98935: ARRAY
98936: PPUSH
98937: LD_VAR 0 1
98941: PUSH
98942: LD_INT 2
98944: ARRAY
98945: PPUSH
98946: CALL_OW 429
// end ; end ;
98950: LD_VAR 0 1
98954: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98955: LD_EXP 139
98959: PUSH
98960: LD_EXP 161
98964: AND
98965: IFFALSE 98977
98967: GO 98969
98969: DISABLE
// YouLost (  ) ;
98970: LD_STRING 
98972: PPUSH
98973: CALL_OW 104
98977: END
// every 0 0$1 trigger StreamModeActive and sFog do
98978: LD_EXP 139
98982: PUSH
98983: LD_EXP 160
98987: AND
98988: IFFALSE 99002
98990: GO 98992
98992: DISABLE
// FogOff ( your_side ) ;
98993: LD_OWVAR 2
98997: PPUSH
98998: CALL_OW 344
99002: END
// every 0 0$1 trigger StreamModeActive and sSun do
99003: LD_EXP 139
99007: PUSH
99008: LD_EXP 162
99012: AND
99013: IFFALSE 99041
99015: GO 99017
99017: DISABLE
// begin solar_recharge_percent := 0 ;
99018: LD_ADDR_OWVAR 79
99022: PUSH
99023: LD_INT 0
99025: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99026: LD_INT 10500
99028: PPUSH
99029: CALL_OW 67
// solar_recharge_percent := 100 ;
99033: LD_ADDR_OWVAR 79
99037: PUSH
99038: LD_INT 100
99040: ST_TO_ADDR
// end ;
99041: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99042: LD_EXP 139
99046: PUSH
99047: LD_EXP 163
99051: AND
99052: IFFALSE 99291
99054: GO 99056
99056: DISABLE
99057: LD_INT 0
99059: PPUSH
99060: PPUSH
99061: PPUSH
// begin tmp := [ ] ;
99062: LD_ADDR_VAR 0 3
99066: PUSH
99067: EMPTY
99068: ST_TO_ADDR
// for i := 1 to 6 do
99069: LD_ADDR_VAR 0 1
99073: PUSH
99074: DOUBLE
99075: LD_INT 1
99077: DEC
99078: ST_TO_ADDR
99079: LD_INT 6
99081: PUSH
99082: FOR_TO
99083: IFFALSE 99188
// begin uc_nation := nation_nature ;
99085: LD_ADDR_OWVAR 21
99089: PUSH
99090: LD_INT 0
99092: ST_TO_ADDR
// uc_side := 0 ;
99093: LD_ADDR_OWVAR 20
99097: PUSH
99098: LD_INT 0
99100: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99101: LD_ADDR_OWVAR 29
99105: PUSH
99106: LD_INT 12
99108: PUSH
99109: LD_INT 12
99111: PUSH
99112: EMPTY
99113: LIST
99114: LIST
99115: ST_TO_ADDR
// hc_agressivity := 20 ;
99116: LD_ADDR_OWVAR 35
99120: PUSH
99121: LD_INT 20
99123: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99124: LD_ADDR_OWVAR 28
99128: PUSH
99129: LD_INT 17
99131: ST_TO_ADDR
// hc_gallery :=  ;
99132: LD_ADDR_OWVAR 33
99136: PUSH
99137: LD_STRING 
99139: ST_TO_ADDR
// hc_name :=  ;
99140: LD_ADDR_OWVAR 26
99144: PUSH
99145: LD_STRING 
99147: ST_TO_ADDR
// un := CreateHuman ;
99148: LD_ADDR_VAR 0 2
99152: PUSH
99153: CALL_OW 44
99157: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99158: LD_VAR 0 2
99162: PPUSH
99163: LD_INT 1
99165: PPUSH
99166: CALL_OW 51
// tmp := tmp ^ un ;
99170: LD_ADDR_VAR 0 3
99174: PUSH
99175: LD_VAR 0 3
99179: PUSH
99180: LD_VAR 0 2
99184: ADD
99185: ST_TO_ADDR
// end ;
99186: GO 99082
99188: POP
99189: POP
// repeat wait ( 0 0$1 ) ;
99190: LD_INT 35
99192: PPUSH
99193: CALL_OW 67
// for un in tmp do
99197: LD_ADDR_VAR 0 2
99201: PUSH
99202: LD_VAR 0 3
99206: PUSH
99207: FOR_IN
99208: IFFALSE 99282
// begin if IsDead ( un ) then
99210: LD_VAR 0 2
99214: PPUSH
99215: CALL_OW 301
99219: IFFALSE 99239
// begin tmp := tmp diff un ;
99221: LD_ADDR_VAR 0 3
99225: PUSH
99226: LD_VAR 0 3
99230: PUSH
99231: LD_VAR 0 2
99235: DIFF
99236: ST_TO_ADDR
// continue ;
99237: GO 99207
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99239: LD_VAR 0 2
99243: PPUSH
99244: LD_INT 3
99246: PUSH
99247: LD_INT 22
99249: PUSH
99250: LD_INT 0
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: PPUSH
99261: CALL_OW 69
99265: PPUSH
99266: LD_VAR 0 2
99270: PPUSH
99271: CALL_OW 74
99275: PPUSH
99276: CALL_OW 115
// end ;
99280: GO 99207
99282: POP
99283: POP
// until not tmp ;
99284: LD_VAR 0 3
99288: NOT
99289: IFFALSE 99190
// end ;
99291: PPOPN 3
99293: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99294: LD_EXP 139
99298: PUSH
99299: LD_EXP 164
99303: AND
99304: IFFALSE 99358
99306: GO 99308
99308: DISABLE
// begin ToLua ( displayTroll(); ) ;
99309: LD_STRING displayTroll();
99311: PPUSH
99312: CALL_OW 559
// wait ( 3 3$00 ) ;
99316: LD_INT 6300
99318: PPUSH
99319: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99323: LD_STRING hideTroll();
99325: PPUSH
99326: CALL_OW 559
// wait ( 1 1$00 ) ;
99330: LD_INT 2100
99332: PPUSH
99333: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99337: LD_STRING displayTroll();
99339: PPUSH
99340: CALL_OW 559
// wait ( 1 1$00 ) ;
99344: LD_INT 2100
99346: PPUSH
99347: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99351: LD_STRING hideTroll();
99353: PPUSH
99354: CALL_OW 559
// end ;
99358: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99359: LD_EXP 139
99363: PUSH
99364: LD_EXP 165
99368: AND
99369: IFFALSE 99432
99371: GO 99373
99373: DISABLE
99374: LD_INT 0
99376: PPUSH
// begin p := 0 ;
99377: LD_ADDR_VAR 0 1
99381: PUSH
99382: LD_INT 0
99384: ST_TO_ADDR
// repeat game_speed := 1 ;
99385: LD_ADDR_OWVAR 65
99389: PUSH
99390: LD_INT 1
99392: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99393: LD_INT 35
99395: PPUSH
99396: CALL_OW 67
// p := p + 1 ;
99400: LD_ADDR_VAR 0 1
99404: PUSH
99405: LD_VAR 0 1
99409: PUSH
99410: LD_INT 1
99412: PLUS
99413: ST_TO_ADDR
// until p >= 60 ;
99414: LD_VAR 0 1
99418: PUSH
99419: LD_INT 60
99421: GREATEREQUAL
99422: IFFALSE 99385
// game_speed := 4 ;
99424: LD_ADDR_OWVAR 65
99428: PUSH
99429: LD_INT 4
99431: ST_TO_ADDR
// end ;
99432: PPOPN 1
99434: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99435: LD_EXP 139
99439: PUSH
99440: LD_EXP 166
99444: AND
99445: IFFALSE 99591
99447: GO 99449
99449: DISABLE
99450: LD_INT 0
99452: PPUSH
99453: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99454: LD_ADDR_VAR 0 1
99458: PUSH
99459: LD_INT 22
99461: PUSH
99462: LD_OWVAR 2
99466: PUSH
99467: EMPTY
99468: LIST
99469: LIST
99470: PUSH
99471: LD_INT 2
99473: PUSH
99474: LD_INT 30
99476: PUSH
99477: LD_INT 0
99479: PUSH
99480: EMPTY
99481: LIST
99482: LIST
99483: PUSH
99484: LD_INT 30
99486: PUSH
99487: LD_INT 1
99489: PUSH
99490: EMPTY
99491: LIST
99492: LIST
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: LIST
99498: PUSH
99499: EMPTY
99500: LIST
99501: LIST
99502: PPUSH
99503: CALL_OW 69
99507: ST_TO_ADDR
// if not depot then
99508: LD_VAR 0 1
99512: NOT
99513: IFFALSE 99517
// exit ;
99515: GO 99591
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99517: LD_ADDR_VAR 0 2
99521: PUSH
99522: LD_VAR 0 1
99526: PUSH
99527: LD_INT 1
99529: PPUSH
99530: LD_VAR 0 1
99534: PPUSH
99535: CALL_OW 12
99539: ARRAY
99540: PPUSH
99541: CALL_OW 274
99545: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99546: LD_VAR 0 2
99550: PPUSH
99551: LD_INT 1
99553: PPUSH
99554: LD_INT 0
99556: PPUSH
99557: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99561: LD_VAR 0 2
99565: PPUSH
99566: LD_INT 2
99568: PPUSH
99569: LD_INT 0
99571: PPUSH
99572: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99576: LD_VAR 0 2
99580: PPUSH
99581: LD_INT 3
99583: PPUSH
99584: LD_INT 0
99586: PPUSH
99587: CALL_OW 277
// end ;
99591: PPOPN 2
99593: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99594: LD_EXP 139
99598: PUSH
99599: LD_EXP 167
99603: AND
99604: IFFALSE 99701
99606: GO 99608
99608: DISABLE
99609: LD_INT 0
99611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99612: LD_ADDR_VAR 0 1
99616: PUSH
99617: LD_INT 22
99619: PUSH
99620: LD_OWVAR 2
99624: PUSH
99625: EMPTY
99626: LIST
99627: LIST
99628: PUSH
99629: LD_INT 21
99631: PUSH
99632: LD_INT 1
99634: PUSH
99635: EMPTY
99636: LIST
99637: LIST
99638: PUSH
99639: LD_INT 3
99641: PUSH
99642: LD_INT 23
99644: PUSH
99645: LD_INT 0
99647: PUSH
99648: EMPTY
99649: LIST
99650: LIST
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: PUSH
99656: EMPTY
99657: LIST
99658: LIST
99659: LIST
99660: PPUSH
99661: CALL_OW 69
99665: ST_TO_ADDR
// if not tmp then
99666: LD_VAR 0 1
99670: NOT
99671: IFFALSE 99675
// exit ;
99673: GO 99701
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99675: LD_VAR 0 1
99679: PUSH
99680: LD_INT 1
99682: PPUSH
99683: LD_VAR 0 1
99687: PPUSH
99688: CALL_OW 12
99692: ARRAY
99693: PPUSH
99694: LD_INT 200
99696: PPUSH
99697: CALL_OW 234
// end ;
99701: PPOPN 1
99703: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99704: LD_EXP 139
99708: PUSH
99709: LD_EXP 168
99713: AND
99714: IFFALSE 99793
99716: GO 99718
99718: DISABLE
99719: LD_INT 0
99721: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99722: LD_ADDR_VAR 0 1
99726: PUSH
99727: LD_INT 22
99729: PUSH
99730: LD_OWVAR 2
99734: PUSH
99735: EMPTY
99736: LIST
99737: LIST
99738: PUSH
99739: LD_INT 21
99741: PUSH
99742: LD_INT 2
99744: PUSH
99745: EMPTY
99746: LIST
99747: LIST
99748: PUSH
99749: EMPTY
99750: LIST
99751: LIST
99752: PPUSH
99753: CALL_OW 69
99757: ST_TO_ADDR
// if not tmp then
99758: LD_VAR 0 1
99762: NOT
99763: IFFALSE 99767
// exit ;
99765: GO 99793
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99767: LD_VAR 0 1
99771: PUSH
99772: LD_INT 1
99774: PPUSH
99775: LD_VAR 0 1
99779: PPUSH
99780: CALL_OW 12
99784: ARRAY
99785: PPUSH
99786: LD_INT 60
99788: PPUSH
99789: CALL_OW 234
// end ;
99793: PPOPN 1
99795: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99796: LD_EXP 139
99800: PUSH
99801: LD_EXP 169
99805: AND
99806: IFFALSE 99905
99808: GO 99810
99810: DISABLE
99811: LD_INT 0
99813: PPUSH
99814: PPUSH
// begin enable ;
99815: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99816: LD_ADDR_VAR 0 1
99820: PUSH
99821: LD_INT 22
99823: PUSH
99824: LD_OWVAR 2
99828: PUSH
99829: EMPTY
99830: LIST
99831: LIST
99832: PUSH
99833: LD_INT 61
99835: PUSH
99836: EMPTY
99837: LIST
99838: PUSH
99839: LD_INT 33
99841: PUSH
99842: LD_INT 2
99844: PUSH
99845: EMPTY
99846: LIST
99847: LIST
99848: PUSH
99849: EMPTY
99850: LIST
99851: LIST
99852: LIST
99853: PPUSH
99854: CALL_OW 69
99858: ST_TO_ADDR
// if not tmp then
99859: LD_VAR 0 1
99863: NOT
99864: IFFALSE 99868
// exit ;
99866: GO 99905
// for i in tmp do
99868: LD_ADDR_VAR 0 2
99872: PUSH
99873: LD_VAR 0 1
99877: PUSH
99878: FOR_IN
99879: IFFALSE 99903
// if IsControledBy ( i ) then
99881: LD_VAR 0 2
99885: PPUSH
99886: CALL_OW 312
99890: IFFALSE 99901
// ComUnlink ( i ) ;
99892: LD_VAR 0 2
99896: PPUSH
99897: CALL_OW 136
99901: GO 99878
99903: POP
99904: POP
// end ;
99905: PPOPN 2
99907: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99908: LD_EXP 139
99912: PUSH
99913: LD_EXP 170
99917: AND
99918: IFFALSE 100058
99920: GO 99922
99922: DISABLE
99923: LD_INT 0
99925: PPUSH
99926: PPUSH
// begin ToLua ( displayPowell(); ) ;
99927: LD_STRING displayPowell();
99929: PPUSH
99930: CALL_OW 559
// uc_side := 0 ;
99934: LD_ADDR_OWVAR 20
99938: PUSH
99939: LD_INT 0
99941: ST_TO_ADDR
// uc_nation := 2 ;
99942: LD_ADDR_OWVAR 21
99946: PUSH
99947: LD_INT 2
99949: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99950: LD_ADDR_OWVAR 37
99954: PUSH
99955: LD_INT 14
99957: ST_TO_ADDR
// vc_engine := engine_siberite ;
99958: LD_ADDR_OWVAR 39
99962: PUSH
99963: LD_INT 3
99965: ST_TO_ADDR
// vc_control := control_apeman ;
99966: LD_ADDR_OWVAR 38
99970: PUSH
99971: LD_INT 5
99973: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99974: LD_ADDR_OWVAR 40
99978: PUSH
99979: LD_INT 29
99981: ST_TO_ADDR
// un := CreateVehicle ;
99982: LD_ADDR_VAR 0 2
99986: PUSH
99987: CALL_OW 45
99991: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99992: LD_VAR 0 2
99996: PPUSH
99997: LD_INT 1
99999: PPUSH
100000: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100004: LD_INT 35
100006: PPUSH
100007: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100011: LD_VAR 0 2
100015: PPUSH
100016: LD_INT 22
100018: PUSH
100019: LD_OWVAR 2
100023: PUSH
100024: EMPTY
100025: LIST
100026: LIST
100027: PPUSH
100028: CALL_OW 69
100032: PPUSH
100033: LD_VAR 0 2
100037: PPUSH
100038: CALL_OW 74
100042: PPUSH
100043: CALL_OW 115
// until IsDead ( un ) ;
100047: LD_VAR 0 2
100051: PPUSH
100052: CALL_OW 301
100056: IFFALSE 100004
// end ;
100058: PPOPN 2
100060: END
// every 0 0$1 trigger StreamModeActive and sStu do
100061: LD_EXP 139
100065: PUSH
100066: LD_EXP 178
100070: AND
100071: IFFALSE 100087
100073: GO 100075
100075: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100076: LD_STRING displayStucuk();
100078: PPUSH
100079: CALL_OW 559
// ResetFog ;
100083: CALL_OW 335
// end ;
100087: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100088: LD_EXP 139
100092: PUSH
100093: LD_EXP 171
100097: AND
100098: IFFALSE 100239
100100: GO 100102
100102: DISABLE
100103: LD_INT 0
100105: PPUSH
100106: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100107: LD_ADDR_VAR 0 2
100111: PUSH
100112: LD_INT 22
100114: PUSH
100115: LD_OWVAR 2
100119: PUSH
100120: EMPTY
100121: LIST
100122: LIST
100123: PUSH
100124: LD_INT 21
100126: PUSH
100127: LD_INT 1
100129: PUSH
100130: EMPTY
100131: LIST
100132: LIST
100133: PUSH
100134: EMPTY
100135: LIST
100136: LIST
100137: PPUSH
100138: CALL_OW 69
100142: ST_TO_ADDR
// if not tmp then
100143: LD_VAR 0 2
100147: NOT
100148: IFFALSE 100152
// exit ;
100150: GO 100239
// un := tmp [ rand ( 1 , tmp ) ] ;
100152: LD_ADDR_VAR 0 1
100156: PUSH
100157: LD_VAR 0 2
100161: PUSH
100162: LD_INT 1
100164: PPUSH
100165: LD_VAR 0 2
100169: PPUSH
100170: CALL_OW 12
100174: ARRAY
100175: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100176: LD_VAR 0 1
100180: PPUSH
100181: LD_INT 0
100183: PPUSH
100184: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100188: LD_VAR 0 1
100192: PPUSH
100193: LD_OWVAR 3
100197: PUSH
100198: LD_VAR 0 1
100202: DIFF
100203: PPUSH
100204: LD_VAR 0 1
100208: PPUSH
100209: CALL_OW 74
100213: PPUSH
100214: CALL_OW 115
// wait ( 0 0$20 ) ;
100218: LD_INT 700
100220: PPUSH
100221: CALL_OW 67
// SetSide ( un , your_side ) ;
100225: LD_VAR 0 1
100229: PPUSH
100230: LD_OWVAR 2
100234: PPUSH
100235: CALL_OW 235
// end ;
100239: PPOPN 2
100241: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100242: LD_EXP 139
100246: PUSH
100247: LD_EXP 172
100251: AND
100252: IFFALSE 100358
100254: GO 100256
100256: DISABLE
100257: LD_INT 0
100259: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100260: LD_ADDR_VAR 0 1
100264: PUSH
100265: LD_INT 22
100267: PUSH
100268: LD_OWVAR 2
100272: PUSH
100273: EMPTY
100274: LIST
100275: LIST
100276: PUSH
100277: LD_INT 2
100279: PUSH
100280: LD_INT 30
100282: PUSH
100283: LD_INT 0
100285: PUSH
100286: EMPTY
100287: LIST
100288: LIST
100289: PUSH
100290: LD_INT 30
100292: PUSH
100293: LD_INT 1
100295: PUSH
100296: EMPTY
100297: LIST
100298: LIST
100299: PUSH
100300: EMPTY
100301: LIST
100302: LIST
100303: LIST
100304: PUSH
100305: EMPTY
100306: LIST
100307: LIST
100308: PPUSH
100309: CALL_OW 69
100313: ST_TO_ADDR
// if not depot then
100314: LD_VAR 0 1
100318: NOT
100319: IFFALSE 100323
// exit ;
100321: GO 100358
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100323: LD_VAR 0 1
100327: PUSH
100328: LD_INT 1
100330: ARRAY
100331: PPUSH
100332: CALL_OW 250
100336: PPUSH
100337: LD_VAR 0 1
100341: PUSH
100342: LD_INT 1
100344: ARRAY
100345: PPUSH
100346: CALL_OW 251
100350: PPUSH
100351: LD_INT 70
100353: PPUSH
100354: CALL_OW 495
// end ;
100358: PPOPN 1
100360: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100361: LD_EXP 139
100365: PUSH
100366: LD_EXP 173
100370: AND
100371: IFFALSE 100582
100373: GO 100375
100375: DISABLE
100376: LD_INT 0
100378: PPUSH
100379: PPUSH
100380: PPUSH
100381: PPUSH
100382: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100383: LD_ADDR_VAR 0 5
100387: PUSH
100388: LD_INT 22
100390: PUSH
100391: LD_OWVAR 2
100395: PUSH
100396: EMPTY
100397: LIST
100398: LIST
100399: PUSH
100400: LD_INT 21
100402: PUSH
100403: LD_INT 1
100405: PUSH
100406: EMPTY
100407: LIST
100408: LIST
100409: PUSH
100410: EMPTY
100411: LIST
100412: LIST
100413: PPUSH
100414: CALL_OW 69
100418: ST_TO_ADDR
// if not tmp then
100419: LD_VAR 0 5
100423: NOT
100424: IFFALSE 100428
// exit ;
100426: GO 100582
// for i in tmp do
100428: LD_ADDR_VAR 0 1
100432: PUSH
100433: LD_VAR 0 5
100437: PUSH
100438: FOR_IN
100439: IFFALSE 100580
// begin d := rand ( 0 , 5 ) ;
100441: LD_ADDR_VAR 0 4
100445: PUSH
100446: LD_INT 0
100448: PPUSH
100449: LD_INT 5
100451: PPUSH
100452: CALL_OW 12
100456: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100457: LD_ADDR_VAR 0 2
100461: PUSH
100462: LD_VAR 0 1
100466: PPUSH
100467: CALL_OW 250
100471: PPUSH
100472: LD_VAR 0 4
100476: PPUSH
100477: LD_INT 3
100479: PPUSH
100480: LD_INT 12
100482: PPUSH
100483: CALL_OW 12
100487: PPUSH
100488: CALL_OW 272
100492: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100493: LD_ADDR_VAR 0 3
100497: PUSH
100498: LD_VAR 0 1
100502: PPUSH
100503: CALL_OW 251
100507: PPUSH
100508: LD_VAR 0 4
100512: PPUSH
100513: LD_INT 3
100515: PPUSH
100516: LD_INT 12
100518: PPUSH
100519: CALL_OW 12
100523: PPUSH
100524: CALL_OW 273
100528: ST_TO_ADDR
// if ValidHex ( x , y ) then
100529: LD_VAR 0 2
100533: PPUSH
100534: LD_VAR 0 3
100538: PPUSH
100539: CALL_OW 488
100543: IFFALSE 100578
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100545: LD_VAR 0 1
100549: PPUSH
100550: LD_VAR 0 2
100554: PPUSH
100555: LD_VAR 0 3
100559: PPUSH
100560: LD_INT 3
100562: PPUSH
100563: LD_INT 6
100565: PPUSH
100566: CALL_OW 12
100570: PPUSH
100571: LD_INT 1
100573: PPUSH
100574: CALL_OW 483
// end ;
100578: GO 100438
100580: POP
100581: POP
// end ;
100582: PPOPN 5
100584: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100585: LD_EXP 139
100589: PUSH
100590: LD_EXP 174
100594: AND
100595: IFFALSE 100689
100597: GO 100599
100599: DISABLE
100600: LD_INT 0
100602: PPUSH
100603: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100604: LD_ADDR_VAR 0 2
100608: PUSH
100609: LD_INT 22
100611: PUSH
100612: LD_OWVAR 2
100616: PUSH
100617: EMPTY
100618: LIST
100619: LIST
100620: PUSH
100621: LD_INT 32
100623: PUSH
100624: LD_INT 1
100626: PUSH
100627: EMPTY
100628: LIST
100629: LIST
100630: PUSH
100631: LD_INT 21
100633: PUSH
100634: LD_INT 2
100636: PUSH
100637: EMPTY
100638: LIST
100639: LIST
100640: PUSH
100641: EMPTY
100642: LIST
100643: LIST
100644: LIST
100645: PPUSH
100646: CALL_OW 69
100650: ST_TO_ADDR
// if not tmp then
100651: LD_VAR 0 2
100655: NOT
100656: IFFALSE 100660
// exit ;
100658: GO 100689
// for i in tmp do
100660: LD_ADDR_VAR 0 1
100664: PUSH
100665: LD_VAR 0 2
100669: PUSH
100670: FOR_IN
100671: IFFALSE 100687
// SetFuel ( i , 0 ) ;
100673: LD_VAR 0 1
100677: PPUSH
100678: LD_INT 0
100680: PPUSH
100681: CALL_OW 240
100685: GO 100670
100687: POP
100688: POP
// end ;
100689: PPOPN 2
100691: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100692: LD_EXP 139
100696: PUSH
100697: LD_EXP 175
100701: AND
100702: IFFALSE 100768
100704: GO 100706
100706: DISABLE
100707: LD_INT 0
100709: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100710: LD_ADDR_VAR 0 1
100714: PUSH
100715: LD_INT 22
100717: PUSH
100718: LD_OWVAR 2
100722: PUSH
100723: EMPTY
100724: LIST
100725: LIST
100726: PUSH
100727: LD_INT 30
100729: PUSH
100730: LD_INT 29
100732: PUSH
100733: EMPTY
100734: LIST
100735: LIST
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PPUSH
100741: CALL_OW 69
100745: ST_TO_ADDR
// if not tmp then
100746: LD_VAR 0 1
100750: NOT
100751: IFFALSE 100755
// exit ;
100753: GO 100768
// DestroyUnit ( tmp [ 1 ] ) ;
100755: LD_VAR 0 1
100759: PUSH
100760: LD_INT 1
100762: ARRAY
100763: PPUSH
100764: CALL_OW 65
// end ;
100768: PPOPN 1
100770: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100771: LD_EXP 139
100775: PUSH
100776: LD_EXP 177
100780: AND
100781: IFFALSE 100910
100783: GO 100785
100785: DISABLE
100786: LD_INT 0
100788: PPUSH
// begin uc_side := 0 ;
100789: LD_ADDR_OWVAR 20
100793: PUSH
100794: LD_INT 0
100796: ST_TO_ADDR
// uc_nation := nation_arabian ;
100797: LD_ADDR_OWVAR 21
100801: PUSH
100802: LD_INT 2
100804: ST_TO_ADDR
// hc_gallery :=  ;
100805: LD_ADDR_OWVAR 33
100809: PUSH
100810: LD_STRING 
100812: ST_TO_ADDR
// hc_name :=  ;
100813: LD_ADDR_OWVAR 26
100817: PUSH
100818: LD_STRING 
100820: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100821: LD_INT 1
100823: PPUSH
100824: LD_INT 11
100826: PPUSH
100827: LD_INT 10
100829: PPUSH
100830: CALL_OW 380
// un := CreateHuman ;
100834: LD_ADDR_VAR 0 1
100838: PUSH
100839: CALL_OW 44
100843: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100844: LD_VAR 0 1
100848: PPUSH
100849: LD_INT 1
100851: PPUSH
100852: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100856: LD_INT 35
100858: PPUSH
100859: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100863: LD_VAR 0 1
100867: PPUSH
100868: LD_INT 22
100870: PUSH
100871: LD_OWVAR 2
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: PPUSH
100880: CALL_OW 69
100884: PPUSH
100885: LD_VAR 0 1
100889: PPUSH
100890: CALL_OW 74
100894: PPUSH
100895: CALL_OW 115
// until IsDead ( un ) ;
100899: LD_VAR 0 1
100903: PPUSH
100904: CALL_OW 301
100908: IFFALSE 100856
// end ;
100910: PPOPN 1
100912: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100913: LD_EXP 139
100917: PUSH
100918: LD_EXP 179
100922: AND
100923: IFFALSE 100935
100925: GO 100927
100927: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100928: LD_STRING earthquake(getX(game), 0, 32)
100930: PPUSH
100931: CALL_OW 559
100935: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100936: LD_EXP 139
100940: PUSH
100941: LD_EXP 180
100945: AND
100946: IFFALSE 101037
100948: GO 100950
100950: DISABLE
100951: LD_INT 0
100953: PPUSH
// begin enable ;
100954: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100955: LD_ADDR_VAR 0 1
100959: PUSH
100960: LD_INT 22
100962: PUSH
100963: LD_OWVAR 2
100967: PUSH
100968: EMPTY
100969: LIST
100970: LIST
100971: PUSH
100972: LD_INT 21
100974: PUSH
100975: LD_INT 2
100977: PUSH
100978: EMPTY
100979: LIST
100980: LIST
100981: PUSH
100982: LD_INT 33
100984: PUSH
100985: LD_INT 3
100987: PUSH
100988: EMPTY
100989: LIST
100990: LIST
100991: PUSH
100992: EMPTY
100993: LIST
100994: LIST
100995: LIST
100996: PPUSH
100997: CALL_OW 69
101001: ST_TO_ADDR
// if not tmp then
101002: LD_VAR 0 1
101006: NOT
101007: IFFALSE 101011
// exit ;
101009: GO 101037
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101011: LD_VAR 0 1
101015: PUSH
101016: LD_INT 1
101018: PPUSH
101019: LD_VAR 0 1
101023: PPUSH
101024: CALL_OW 12
101028: ARRAY
101029: PPUSH
101030: LD_INT 1
101032: PPUSH
101033: CALL_OW 234
// end ;
101037: PPOPN 1
101039: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101040: LD_EXP 139
101044: PUSH
101045: LD_EXP 181
101049: AND
101050: IFFALSE 101191
101052: GO 101054
101054: DISABLE
101055: LD_INT 0
101057: PPUSH
101058: PPUSH
101059: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101060: LD_ADDR_VAR 0 3
101064: PUSH
101065: LD_INT 22
101067: PUSH
101068: LD_OWVAR 2
101072: PUSH
101073: EMPTY
101074: LIST
101075: LIST
101076: PUSH
101077: LD_INT 25
101079: PUSH
101080: LD_INT 1
101082: PUSH
101083: EMPTY
101084: LIST
101085: LIST
101086: PUSH
101087: EMPTY
101088: LIST
101089: LIST
101090: PPUSH
101091: CALL_OW 69
101095: ST_TO_ADDR
// if not tmp then
101096: LD_VAR 0 3
101100: NOT
101101: IFFALSE 101105
// exit ;
101103: GO 101191
// un := tmp [ rand ( 1 , tmp ) ] ;
101105: LD_ADDR_VAR 0 2
101109: PUSH
101110: LD_VAR 0 3
101114: PUSH
101115: LD_INT 1
101117: PPUSH
101118: LD_VAR 0 3
101122: PPUSH
101123: CALL_OW 12
101127: ARRAY
101128: ST_TO_ADDR
// if Crawls ( un ) then
101129: LD_VAR 0 2
101133: PPUSH
101134: CALL_OW 318
101138: IFFALSE 101149
// ComWalk ( un ) ;
101140: LD_VAR 0 2
101144: PPUSH
101145: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101149: LD_VAR 0 2
101153: PPUSH
101154: LD_INT 9
101156: PPUSH
101157: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101161: LD_INT 28
101163: PPUSH
101164: LD_OWVAR 2
101168: PPUSH
101169: LD_INT 2
101171: PPUSH
101172: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101176: LD_INT 29
101178: PPUSH
101179: LD_OWVAR 2
101183: PPUSH
101184: LD_INT 2
101186: PPUSH
101187: CALL_OW 322
// end ;
101191: PPOPN 3
101193: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101194: LD_EXP 139
101198: PUSH
101199: LD_EXP 182
101203: AND
101204: IFFALSE 101315
101206: GO 101208
101208: DISABLE
101209: LD_INT 0
101211: PPUSH
101212: PPUSH
101213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101214: LD_ADDR_VAR 0 3
101218: PUSH
101219: LD_INT 22
101221: PUSH
101222: LD_OWVAR 2
101226: PUSH
101227: EMPTY
101228: LIST
101229: LIST
101230: PUSH
101231: LD_INT 25
101233: PUSH
101234: LD_INT 1
101236: PUSH
101237: EMPTY
101238: LIST
101239: LIST
101240: PUSH
101241: EMPTY
101242: LIST
101243: LIST
101244: PPUSH
101245: CALL_OW 69
101249: ST_TO_ADDR
// if not tmp then
101250: LD_VAR 0 3
101254: NOT
101255: IFFALSE 101259
// exit ;
101257: GO 101315
// un := tmp [ rand ( 1 , tmp ) ] ;
101259: LD_ADDR_VAR 0 2
101263: PUSH
101264: LD_VAR 0 3
101268: PUSH
101269: LD_INT 1
101271: PPUSH
101272: LD_VAR 0 3
101276: PPUSH
101277: CALL_OW 12
101281: ARRAY
101282: ST_TO_ADDR
// if Crawls ( un ) then
101283: LD_VAR 0 2
101287: PPUSH
101288: CALL_OW 318
101292: IFFALSE 101303
// ComWalk ( un ) ;
101294: LD_VAR 0 2
101298: PPUSH
101299: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101303: LD_VAR 0 2
101307: PPUSH
101308: LD_INT 8
101310: PPUSH
101311: CALL_OW 336
// end ;
101315: PPOPN 3
101317: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101318: LD_EXP 139
101322: PUSH
101323: LD_EXP 183
101327: AND
101328: IFFALSE 101472
101330: GO 101332
101332: DISABLE
101333: LD_INT 0
101335: PPUSH
101336: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101337: LD_ADDR_VAR 0 2
101341: PUSH
101342: LD_INT 22
101344: PUSH
101345: LD_OWVAR 2
101349: PUSH
101350: EMPTY
101351: LIST
101352: LIST
101353: PUSH
101354: LD_INT 21
101356: PUSH
101357: LD_INT 2
101359: PUSH
101360: EMPTY
101361: LIST
101362: LIST
101363: PUSH
101364: LD_INT 2
101366: PUSH
101367: LD_INT 34
101369: PUSH
101370: LD_INT 12
101372: PUSH
101373: EMPTY
101374: LIST
101375: LIST
101376: PUSH
101377: LD_INT 34
101379: PUSH
101380: LD_INT 51
101382: PUSH
101383: EMPTY
101384: LIST
101385: LIST
101386: PUSH
101387: LD_INT 34
101389: PUSH
101390: LD_INT 32
101392: PUSH
101393: EMPTY
101394: LIST
101395: LIST
101396: PUSH
101397: EMPTY
101398: LIST
101399: LIST
101400: LIST
101401: LIST
101402: PUSH
101403: EMPTY
101404: LIST
101405: LIST
101406: LIST
101407: PPUSH
101408: CALL_OW 69
101412: ST_TO_ADDR
// if not tmp then
101413: LD_VAR 0 2
101417: NOT
101418: IFFALSE 101422
// exit ;
101420: GO 101472
// for i in tmp do
101422: LD_ADDR_VAR 0 1
101426: PUSH
101427: LD_VAR 0 2
101431: PUSH
101432: FOR_IN
101433: IFFALSE 101470
// if GetCargo ( i , mat_artifact ) = 0 then
101435: LD_VAR 0 1
101439: PPUSH
101440: LD_INT 4
101442: PPUSH
101443: CALL_OW 289
101447: PUSH
101448: LD_INT 0
101450: EQUAL
101451: IFFALSE 101468
// SetCargo ( i , mat_siberit , 100 ) ;
101453: LD_VAR 0 1
101457: PPUSH
101458: LD_INT 3
101460: PPUSH
101461: LD_INT 100
101463: PPUSH
101464: CALL_OW 290
101468: GO 101432
101470: POP
101471: POP
// end ;
101472: PPOPN 2
101474: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101475: LD_EXP 139
101479: PUSH
101480: LD_EXP 184
101484: AND
101485: IFFALSE 101668
101487: GO 101489
101489: DISABLE
101490: LD_INT 0
101492: PPUSH
101493: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101494: LD_ADDR_VAR 0 2
101498: PUSH
101499: LD_INT 22
101501: PUSH
101502: LD_OWVAR 2
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: PPUSH
101511: CALL_OW 69
101515: ST_TO_ADDR
// if not tmp then
101516: LD_VAR 0 2
101520: NOT
101521: IFFALSE 101525
// exit ;
101523: GO 101668
// for i := 1 to 2 do
101525: LD_ADDR_VAR 0 1
101529: PUSH
101530: DOUBLE
101531: LD_INT 1
101533: DEC
101534: ST_TO_ADDR
101535: LD_INT 2
101537: PUSH
101538: FOR_TO
101539: IFFALSE 101666
// begin uc_side := your_side ;
101541: LD_ADDR_OWVAR 20
101545: PUSH
101546: LD_OWVAR 2
101550: ST_TO_ADDR
// uc_nation := nation_american ;
101551: LD_ADDR_OWVAR 21
101555: PUSH
101556: LD_INT 1
101558: ST_TO_ADDR
// vc_chassis := us_morphling ;
101559: LD_ADDR_OWVAR 37
101563: PUSH
101564: LD_INT 5
101566: ST_TO_ADDR
// vc_engine := engine_siberite ;
101567: LD_ADDR_OWVAR 39
101571: PUSH
101572: LD_INT 3
101574: ST_TO_ADDR
// vc_control := control_computer ;
101575: LD_ADDR_OWVAR 38
101579: PUSH
101580: LD_INT 3
101582: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101583: LD_ADDR_OWVAR 40
101587: PUSH
101588: LD_INT 10
101590: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101591: LD_VAR 0 2
101595: PUSH
101596: LD_INT 1
101598: ARRAY
101599: PPUSH
101600: CALL_OW 310
101604: NOT
101605: IFFALSE 101652
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101607: CALL_OW 45
101611: PPUSH
101612: LD_VAR 0 2
101616: PUSH
101617: LD_INT 1
101619: ARRAY
101620: PPUSH
101621: CALL_OW 250
101625: PPUSH
101626: LD_VAR 0 2
101630: PUSH
101631: LD_INT 1
101633: ARRAY
101634: PPUSH
101635: CALL_OW 251
101639: PPUSH
101640: LD_INT 12
101642: PPUSH
101643: LD_INT 1
101645: PPUSH
101646: CALL_OW 50
101650: GO 101664
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101652: CALL_OW 45
101656: PPUSH
101657: LD_INT 1
101659: PPUSH
101660: CALL_OW 51
// end ;
101664: GO 101538
101666: POP
101667: POP
// end ;
101668: PPOPN 2
101670: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101671: LD_EXP 139
101675: PUSH
101676: LD_EXP 185
101680: AND
101681: IFFALSE 101903
101683: GO 101685
101685: DISABLE
101686: LD_INT 0
101688: PPUSH
101689: PPUSH
101690: PPUSH
101691: PPUSH
101692: PPUSH
101693: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101694: LD_ADDR_VAR 0 6
101698: PUSH
101699: LD_INT 22
101701: PUSH
101702: LD_OWVAR 2
101706: PUSH
101707: EMPTY
101708: LIST
101709: LIST
101710: PUSH
101711: LD_INT 21
101713: PUSH
101714: LD_INT 1
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: PUSH
101721: LD_INT 3
101723: PUSH
101724: LD_INT 23
101726: PUSH
101727: LD_INT 0
101729: PUSH
101730: EMPTY
101731: LIST
101732: LIST
101733: PUSH
101734: EMPTY
101735: LIST
101736: LIST
101737: PUSH
101738: EMPTY
101739: LIST
101740: LIST
101741: LIST
101742: PPUSH
101743: CALL_OW 69
101747: ST_TO_ADDR
// if not tmp then
101748: LD_VAR 0 6
101752: NOT
101753: IFFALSE 101757
// exit ;
101755: GO 101903
// s1 := rand ( 1 , 4 ) ;
101757: LD_ADDR_VAR 0 2
101761: PUSH
101762: LD_INT 1
101764: PPUSH
101765: LD_INT 4
101767: PPUSH
101768: CALL_OW 12
101772: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101773: LD_ADDR_VAR 0 4
101777: PUSH
101778: LD_VAR 0 6
101782: PUSH
101783: LD_INT 1
101785: ARRAY
101786: PPUSH
101787: LD_VAR 0 2
101791: PPUSH
101792: CALL_OW 259
101796: ST_TO_ADDR
// if s1 = 1 then
101797: LD_VAR 0 2
101801: PUSH
101802: LD_INT 1
101804: EQUAL
101805: IFFALSE 101825
// s2 := rand ( 2 , 4 ) else
101807: LD_ADDR_VAR 0 3
101811: PUSH
101812: LD_INT 2
101814: PPUSH
101815: LD_INT 4
101817: PPUSH
101818: CALL_OW 12
101822: ST_TO_ADDR
101823: GO 101833
// s2 := 1 ;
101825: LD_ADDR_VAR 0 3
101829: PUSH
101830: LD_INT 1
101832: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101833: LD_ADDR_VAR 0 5
101837: PUSH
101838: LD_VAR 0 6
101842: PUSH
101843: LD_INT 1
101845: ARRAY
101846: PPUSH
101847: LD_VAR 0 3
101851: PPUSH
101852: CALL_OW 259
101856: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101857: LD_VAR 0 6
101861: PUSH
101862: LD_INT 1
101864: ARRAY
101865: PPUSH
101866: LD_VAR 0 2
101870: PPUSH
101871: LD_VAR 0 5
101875: PPUSH
101876: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101880: LD_VAR 0 6
101884: PUSH
101885: LD_INT 1
101887: ARRAY
101888: PPUSH
101889: LD_VAR 0 3
101893: PPUSH
101894: LD_VAR 0 4
101898: PPUSH
101899: CALL_OW 237
// end ;
101903: PPOPN 6
101905: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101906: LD_EXP 139
101910: PUSH
101911: LD_EXP 186
101915: AND
101916: IFFALSE 101995
101918: GO 101920
101920: DISABLE
101921: LD_INT 0
101923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101924: LD_ADDR_VAR 0 1
101928: PUSH
101929: LD_INT 22
101931: PUSH
101932: LD_OWVAR 2
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: PUSH
101941: LD_INT 30
101943: PUSH
101944: LD_INT 3
101946: PUSH
101947: EMPTY
101948: LIST
101949: LIST
101950: PUSH
101951: EMPTY
101952: LIST
101953: LIST
101954: PPUSH
101955: CALL_OW 69
101959: ST_TO_ADDR
// if not tmp then
101960: LD_VAR 0 1
101964: NOT
101965: IFFALSE 101969
// exit ;
101967: GO 101995
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101969: LD_VAR 0 1
101973: PUSH
101974: LD_INT 1
101976: PPUSH
101977: LD_VAR 0 1
101981: PPUSH
101982: CALL_OW 12
101986: ARRAY
101987: PPUSH
101988: LD_INT 1
101990: PPUSH
101991: CALL_OW 234
// end ;
101995: PPOPN 1
101997: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101998: LD_EXP 139
102002: PUSH
102003: LD_EXP 187
102007: AND
102008: IFFALSE 102120
102010: GO 102012
102012: DISABLE
102013: LD_INT 0
102015: PPUSH
102016: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102017: LD_ADDR_VAR 0 2
102021: PUSH
102022: LD_INT 22
102024: PUSH
102025: LD_OWVAR 2
102029: PUSH
102030: EMPTY
102031: LIST
102032: LIST
102033: PUSH
102034: LD_INT 2
102036: PUSH
102037: LD_INT 30
102039: PUSH
102040: LD_INT 27
102042: PUSH
102043: EMPTY
102044: LIST
102045: LIST
102046: PUSH
102047: LD_INT 30
102049: PUSH
102050: LD_INT 26
102052: PUSH
102053: EMPTY
102054: LIST
102055: LIST
102056: PUSH
102057: LD_INT 30
102059: PUSH
102060: LD_INT 28
102062: PUSH
102063: EMPTY
102064: LIST
102065: LIST
102066: PUSH
102067: EMPTY
102068: LIST
102069: LIST
102070: LIST
102071: LIST
102072: PUSH
102073: EMPTY
102074: LIST
102075: LIST
102076: PPUSH
102077: CALL_OW 69
102081: ST_TO_ADDR
// if not tmp then
102082: LD_VAR 0 2
102086: NOT
102087: IFFALSE 102091
// exit ;
102089: GO 102120
// for i in tmp do
102091: LD_ADDR_VAR 0 1
102095: PUSH
102096: LD_VAR 0 2
102100: PUSH
102101: FOR_IN
102102: IFFALSE 102118
// SetLives ( i , 1 ) ;
102104: LD_VAR 0 1
102108: PPUSH
102109: LD_INT 1
102111: PPUSH
102112: CALL_OW 234
102116: GO 102101
102118: POP
102119: POP
// end ;
102120: PPOPN 2
102122: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102123: LD_EXP 139
102127: PUSH
102128: LD_EXP 188
102132: AND
102133: IFFALSE 102420
102135: GO 102137
102137: DISABLE
102138: LD_INT 0
102140: PPUSH
102141: PPUSH
102142: PPUSH
// begin i := rand ( 1 , 7 ) ;
102143: LD_ADDR_VAR 0 1
102147: PUSH
102148: LD_INT 1
102150: PPUSH
102151: LD_INT 7
102153: PPUSH
102154: CALL_OW 12
102158: ST_TO_ADDR
// case i of 1 :
102159: LD_VAR 0 1
102163: PUSH
102164: LD_INT 1
102166: DOUBLE
102167: EQUAL
102168: IFTRUE 102172
102170: GO 102182
102172: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102173: LD_STRING earthquake(getX(game), 0, 32)
102175: PPUSH
102176: CALL_OW 559
102180: GO 102420
102182: LD_INT 2
102184: DOUBLE
102185: EQUAL
102186: IFTRUE 102190
102188: GO 102204
102190: POP
// begin ToLua ( displayStucuk(); ) ;
102191: LD_STRING displayStucuk();
102193: PPUSH
102194: CALL_OW 559
// ResetFog ;
102198: CALL_OW 335
// end ; 3 :
102202: GO 102420
102204: LD_INT 3
102206: DOUBLE
102207: EQUAL
102208: IFTRUE 102212
102210: GO 102316
102212: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102213: LD_ADDR_VAR 0 2
102217: PUSH
102218: LD_INT 22
102220: PUSH
102221: LD_OWVAR 2
102225: PUSH
102226: EMPTY
102227: LIST
102228: LIST
102229: PUSH
102230: LD_INT 25
102232: PUSH
102233: LD_INT 1
102235: PUSH
102236: EMPTY
102237: LIST
102238: LIST
102239: PUSH
102240: EMPTY
102241: LIST
102242: LIST
102243: PPUSH
102244: CALL_OW 69
102248: ST_TO_ADDR
// if not tmp then
102249: LD_VAR 0 2
102253: NOT
102254: IFFALSE 102258
// exit ;
102256: GO 102420
// un := tmp [ rand ( 1 , tmp ) ] ;
102258: LD_ADDR_VAR 0 3
102262: PUSH
102263: LD_VAR 0 2
102267: PUSH
102268: LD_INT 1
102270: PPUSH
102271: LD_VAR 0 2
102275: PPUSH
102276: CALL_OW 12
102280: ARRAY
102281: ST_TO_ADDR
// if Crawls ( un ) then
102282: LD_VAR 0 3
102286: PPUSH
102287: CALL_OW 318
102291: IFFALSE 102302
// ComWalk ( un ) ;
102293: LD_VAR 0 3
102297: PPUSH
102298: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102302: LD_VAR 0 3
102306: PPUSH
102307: LD_INT 8
102309: PPUSH
102310: CALL_OW 336
// end ; 4 :
102314: GO 102420
102316: LD_INT 4
102318: DOUBLE
102319: EQUAL
102320: IFTRUE 102324
102322: GO 102398
102324: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102325: LD_ADDR_VAR 0 2
102329: PUSH
102330: LD_INT 22
102332: PUSH
102333: LD_OWVAR 2
102337: PUSH
102338: EMPTY
102339: LIST
102340: LIST
102341: PUSH
102342: LD_INT 30
102344: PUSH
102345: LD_INT 29
102347: PUSH
102348: EMPTY
102349: LIST
102350: LIST
102351: PUSH
102352: EMPTY
102353: LIST
102354: LIST
102355: PPUSH
102356: CALL_OW 69
102360: ST_TO_ADDR
// if not tmp then
102361: LD_VAR 0 2
102365: NOT
102366: IFFALSE 102370
// exit ;
102368: GO 102420
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102370: LD_VAR 0 2
102374: PUSH
102375: LD_INT 1
102377: ARRAY
102378: PPUSH
102379: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102383: LD_VAR 0 2
102387: PUSH
102388: LD_INT 1
102390: ARRAY
102391: PPUSH
102392: CALL_OW 65
// end ; 5 .. 7 :
102396: GO 102420
102398: LD_INT 5
102400: DOUBLE
102401: GREATEREQUAL
102402: IFFALSE 102410
102404: LD_INT 7
102406: DOUBLE
102407: LESSEQUAL
102408: IFTRUE 102412
102410: GO 102419
102412: POP
// StreamSibBomb ; end ;
102413: CALL 98657 0 0
102417: GO 102420
102419: POP
// end ;
102420: PPOPN 3
102422: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102423: LD_EXP 139
102427: PUSH
102428: LD_EXP 189
102432: AND
102433: IFFALSE 102589
102435: GO 102437
102437: DISABLE
102438: LD_INT 0
102440: PPUSH
102441: PPUSH
102442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102443: LD_ADDR_VAR 0 2
102447: PUSH
102448: LD_INT 81
102450: PUSH
102451: LD_OWVAR 2
102455: PUSH
102456: EMPTY
102457: LIST
102458: LIST
102459: PUSH
102460: LD_INT 2
102462: PUSH
102463: LD_INT 21
102465: PUSH
102466: LD_INT 1
102468: PUSH
102469: EMPTY
102470: LIST
102471: LIST
102472: PUSH
102473: LD_INT 21
102475: PUSH
102476: LD_INT 2
102478: PUSH
102479: EMPTY
102480: LIST
102481: LIST
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: LIST
102487: PUSH
102488: EMPTY
102489: LIST
102490: LIST
102491: PPUSH
102492: CALL_OW 69
102496: ST_TO_ADDR
// if not tmp then
102497: LD_VAR 0 2
102501: NOT
102502: IFFALSE 102506
// exit ;
102504: GO 102589
// p := 0 ;
102506: LD_ADDR_VAR 0 3
102510: PUSH
102511: LD_INT 0
102513: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102514: LD_INT 35
102516: PPUSH
102517: CALL_OW 67
// p := p + 1 ;
102521: LD_ADDR_VAR 0 3
102525: PUSH
102526: LD_VAR 0 3
102530: PUSH
102531: LD_INT 1
102533: PLUS
102534: ST_TO_ADDR
// for i in tmp do
102535: LD_ADDR_VAR 0 1
102539: PUSH
102540: LD_VAR 0 2
102544: PUSH
102545: FOR_IN
102546: IFFALSE 102577
// if GetLives ( i ) < 1000 then
102548: LD_VAR 0 1
102552: PPUSH
102553: CALL_OW 256
102557: PUSH
102558: LD_INT 1000
102560: LESS
102561: IFFALSE 102575
// SetLives ( i , 1000 ) ;
102563: LD_VAR 0 1
102567: PPUSH
102568: LD_INT 1000
102570: PPUSH
102571: CALL_OW 234
102575: GO 102545
102577: POP
102578: POP
// until p > 20 ;
102579: LD_VAR 0 3
102583: PUSH
102584: LD_INT 20
102586: GREATER
102587: IFFALSE 102514
// end ;
102589: PPOPN 3
102591: END
// every 0 0$1 trigger StreamModeActive and sTime do
102592: LD_EXP 139
102596: PUSH
102597: LD_EXP 190
102601: AND
102602: IFFALSE 102637
102604: GO 102606
102606: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102607: LD_INT 28
102609: PPUSH
102610: LD_OWVAR 2
102614: PPUSH
102615: LD_INT 2
102617: PPUSH
102618: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102622: LD_INT 30
102624: PPUSH
102625: LD_OWVAR 2
102629: PPUSH
102630: LD_INT 2
102632: PPUSH
102633: CALL_OW 322
// end ;
102637: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102638: LD_EXP 139
102642: PUSH
102643: LD_EXP 191
102647: AND
102648: IFFALSE 102769
102650: GO 102652
102652: DISABLE
102653: LD_INT 0
102655: PPUSH
102656: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102657: LD_ADDR_VAR 0 2
102661: PUSH
102662: LD_INT 22
102664: PUSH
102665: LD_OWVAR 2
102669: PUSH
102670: EMPTY
102671: LIST
102672: LIST
102673: PUSH
102674: LD_INT 21
102676: PUSH
102677: LD_INT 1
102679: PUSH
102680: EMPTY
102681: LIST
102682: LIST
102683: PUSH
102684: LD_INT 3
102686: PUSH
102687: LD_INT 23
102689: PUSH
102690: LD_INT 0
102692: PUSH
102693: EMPTY
102694: LIST
102695: LIST
102696: PUSH
102697: EMPTY
102698: LIST
102699: LIST
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: LIST
102705: PPUSH
102706: CALL_OW 69
102710: ST_TO_ADDR
// if not tmp then
102711: LD_VAR 0 2
102715: NOT
102716: IFFALSE 102720
// exit ;
102718: GO 102769
// for i in tmp do
102720: LD_ADDR_VAR 0 1
102724: PUSH
102725: LD_VAR 0 2
102729: PUSH
102730: FOR_IN
102731: IFFALSE 102767
// begin if Crawls ( i ) then
102733: LD_VAR 0 1
102737: PPUSH
102738: CALL_OW 318
102742: IFFALSE 102753
// ComWalk ( i ) ;
102744: LD_VAR 0 1
102748: PPUSH
102749: CALL_OW 138
// SetClass ( i , 2 ) ;
102753: LD_VAR 0 1
102757: PPUSH
102758: LD_INT 2
102760: PPUSH
102761: CALL_OW 336
// end ;
102765: GO 102730
102767: POP
102768: POP
// end ;
102769: PPOPN 2
102771: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102772: LD_EXP 139
102776: PUSH
102777: LD_EXP 192
102781: AND
102782: IFFALSE 103070
102784: GO 102786
102786: DISABLE
102787: LD_INT 0
102789: PPUSH
102790: PPUSH
102791: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102792: LD_OWVAR 2
102796: PPUSH
102797: LD_INT 9
102799: PPUSH
102800: LD_INT 1
102802: PPUSH
102803: LD_INT 1
102805: PPUSH
102806: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102810: LD_INT 9
102812: PPUSH
102813: LD_OWVAR 2
102817: PPUSH
102818: CALL_OW 343
// uc_side := 9 ;
102822: LD_ADDR_OWVAR 20
102826: PUSH
102827: LD_INT 9
102829: ST_TO_ADDR
// uc_nation := 2 ;
102830: LD_ADDR_OWVAR 21
102834: PUSH
102835: LD_INT 2
102837: ST_TO_ADDR
// hc_name := Dark Warrior ;
102838: LD_ADDR_OWVAR 26
102842: PUSH
102843: LD_STRING Dark Warrior
102845: ST_TO_ADDR
// hc_gallery :=  ;
102846: LD_ADDR_OWVAR 33
102850: PUSH
102851: LD_STRING 
102853: ST_TO_ADDR
// hc_noskilllimit := true ;
102854: LD_ADDR_OWVAR 76
102858: PUSH
102859: LD_INT 1
102861: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102862: LD_ADDR_OWVAR 31
102866: PUSH
102867: LD_INT 30
102869: PUSH
102870: LD_INT 30
102872: PUSH
102873: LD_INT 30
102875: PUSH
102876: LD_INT 30
102878: PUSH
102879: EMPTY
102880: LIST
102881: LIST
102882: LIST
102883: LIST
102884: ST_TO_ADDR
// un := CreateHuman ;
102885: LD_ADDR_VAR 0 3
102889: PUSH
102890: CALL_OW 44
102894: ST_TO_ADDR
// hc_noskilllimit := false ;
102895: LD_ADDR_OWVAR 76
102899: PUSH
102900: LD_INT 0
102902: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102903: LD_VAR 0 3
102907: PPUSH
102908: LD_INT 1
102910: PPUSH
102911: CALL_OW 51
// ToLua ( playRanger() ) ;
102915: LD_STRING playRanger()
102917: PPUSH
102918: CALL_OW 559
// p := 0 ;
102922: LD_ADDR_VAR 0 2
102926: PUSH
102927: LD_INT 0
102929: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102930: LD_INT 35
102932: PPUSH
102933: CALL_OW 67
// p := p + 1 ;
102937: LD_ADDR_VAR 0 2
102941: PUSH
102942: LD_VAR 0 2
102946: PUSH
102947: LD_INT 1
102949: PLUS
102950: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102951: LD_VAR 0 3
102955: PPUSH
102956: CALL_OW 256
102960: PUSH
102961: LD_INT 1000
102963: LESS
102964: IFFALSE 102978
// SetLives ( un , 1000 ) ;
102966: LD_VAR 0 3
102970: PPUSH
102971: LD_INT 1000
102973: PPUSH
102974: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102978: LD_VAR 0 3
102982: PPUSH
102983: LD_INT 81
102985: PUSH
102986: LD_OWVAR 2
102990: PUSH
102991: EMPTY
102992: LIST
102993: LIST
102994: PUSH
102995: LD_INT 91
102997: PUSH
102998: LD_VAR 0 3
103002: PUSH
103003: LD_INT 30
103005: PUSH
103006: EMPTY
103007: LIST
103008: LIST
103009: LIST
103010: PUSH
103011: EMPTY
103012: LIST
103013: LIST
103014: PPUSH
103015: CALL_OW 69
103019: PPUSH
103020: LD_VAR 0 3
103024: PPUSH
103025: CALL_OW 74
103029: PPUSH
103030: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103034: LD_VAR 0 2
103038: PUSH
103039: LD_INT 80
103041: GREATER
103042: PUSH
103043: LD_VAR 0 3
103047: PPUSH
103048: CALL_OW 301
103052: OR
103053: IFFALSE 102930
// if un then
103055: LD_VAR 0 3
103059: IFFALSE 103070
// RemoveUnit ( un ) ;
103061: LD_VAR 0 3
103065: PPUSH
103066: CALL_OW 64
// end ;
103070: PPOPN 3
103072: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103073: LD_EXP 193
103077: IFFALSE 103193
103079: GO 103081
103081: DISABLE
103082: LD_INT 0
103084: PPUSH
103085: PPUSH
103086: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103087: LD_ADDR_VAR 0 2
103091: PUSH
103092: LD_INT 81
103094: PUSH
103095: LD_OWVAR 2
103099: PUSH
103100: EMPTY
103101: LIST
103102: LIST
103103: PUSH
103104: LD_INT 21
103106: PUSH
103107: LD_INT 1
103109: PUSH
103110: EMPTY
103111: LIST
103112: LIST
103113: PUSH
103114: EMPTY
103115: LIST
103116: LIST
103117: PPUSH
103118: CALL_OW 69
103122: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103123: LD_STRING playComputer()
103125: PPUSH
103126: CALL_OW 559
// if not tmp then
103130: LD_VAR 0 2
103134: NOT
103135: IFFALSE 103139
// exit ;
103137: GO 103193
// for i in tmp do
103139: LD_ADDR_VAR 0 1
103143: PUSH
103144: LD_VAR 0 2
103148: PUSH
103149: FOR_IN
103150: IFFALSE 103191
// for j := 1 to 4 do
103152: LD_ADDR_VAR 0 3
103156: PUSH
103157: DOUBLE
103158: LD_INT 1
103160: DEC
103161: ST_TO_ADDR
103162: LD_INT 4
103164: PUSH
103165: FOR_TO
103166: IFFALSE 103187
// SetSkill ( i , j , 10 ) ;
103168: LD_VAR 0 1
103172: PPUSH
103173: LD_VAR 0 3
103177: PPUSH
103178: LD_INT 10
103180: PPUSH
103181: CALL_OW 237
103185: GO 103165
103187: POP
103188: POP
103189: GO 103149
103191: POP
103192: POP
// end ;
103193: PPOPN 3
103195: END
// every 0 0$1 trigger s30 do var i , tmp ;
103196: LD_EXP 194
103200: IFFALSE 103269
103202: GO 103204
103204: DISABLE
103205: LD_INT 0
103207: PPUSH
103208: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103209: LD_ADDR_VAR 0 2
103213: PUSH
103214: LD_INT 22
103216: PUSH
103217: LD_OWVAR 2
103221: PUSH
103222: EMPTY
103223: LIST
103224: LIST
103225: PPUSH
103226: CALL_OW 69
103230: ST_TO_ADDR
// if not tmp then
103231: LD_VAR 0 2
103235: NOT
103236: IFFALSE 103240
// exit ;
103238: GO 103269
// for i in tmp do
103240: LD_ADDR_VAR 0 1
103244: PUSH
103245: LD_VAR 0 2
103249: PUSH
103250: FOR_IN
103251: IFFALSE 103267
// SetLives ( i , 300 ) ;
103253: LD_VAR 0 1
103257: PPUSH
103258: LD_INT 300
103260: PPUSH
103261: CALL_OW 234
103265: GO 103250
103267: POP
103268: POP
// end ;
103269: PPOPN 2
103271: END
// every 0 0$1 trigger s60 do var i , tmp ;
103272: LD_EXP 195
103276: IFFALSE 103345
103278: GO 103280
103280: DISABLE
103281: LD_INT 0
103283: PPUSH
103284: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103285: LD_ADDR_VAR 0 2
103289: PUSH
103290: LD_INT 22
103292: PUSH
103293: LD_OWVAR 2
103297: PUSH
103298: EMPTY
103299: LIST
103300: LIST
103301: PPUSH
103302: CALL_OW 69
103306: ST_TO_ADDR
// if not tmp then
103307: LD_VAR 0 2
103311: NOT
103312: IFFALSE 103316
// exit ;
103314: GO 103345
// for i in tmp do
103316: LD_ADDR_VAR 0 1
103320: PUSH
103321: LD_VAR 0 2
103325: PUSH
103326: FOR_IN
103327: IFFALSE 103343
// SetLives ( i , 600 ) ;
103329: LD_VAR 0 1
103333: PPUSH
103334: LD_INT 600
103336: PPUSH
103337: CALL_OW 234
103341: GO 103326
103343: POP
103344: POP
// end ;
103345: PPOPN 2
103347: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103348: LD_INT 0
103350: PPUSH
// case cmd of 301 :
103351: LD_VAR 0 1
103355: PUSH
103356: LD_INT 301
103358: DOUBLE
103359: EQUAL
103360: IFTRUE 103364
103362: GO 103396
103364: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103365: LD_VAR 0 6
103369: PPUSH
103370: LD_VAR 0 7
103374: PPUSH
103375: LD_VAR 0 8
103379: PPUSH
103380: LD_VAR 0 4
103384: PPUSH
103385: LD_VAR 0 5
103389: PPUSH
103390: CALL 104597 0 5
103394: GO 103517
103396: LD_INT 302
103398: DOUBLE
103399: EQUAL
103400: IFTRUE 103404
103402: GO 103441
103404: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103405: LD_VAR 0 6
103409: PPUSH
103410: LD_VAR 0 7
103414: PPUSH
103415: LD_VAR 0 8
103419: PPUSH
103420: LD_VAR 0 9
103424: PPUSH
103425: LD_VAR 0 4
103429: PPUSH
103430: LD_VAR 0 5
103434: PPUSH
103435: CALL 104688 0 6
103439: GO 103517
103441: LD_INT 303
103443: DOUBLE
103444: EQUAL
103445: IFTRUE 103449
103447: GO 103486
103449: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103450: LD_VAR 0 6
103454: PPUSH
103455: LD_VAR 0 7
103459: PPUSH
103460: LD_VAR 0 8
103464: PPUSH
103465: LD_VAR 0 9
103469: PPUSH
103470: LD_VAR 0 4
103474: PPUSH
103475: LD_VAR 0 5
103479: PPUSH
103480: CALL 103522 0 6
103484: GO 103517
103486: LD_INT 304
103488: DOUBLE
103489: EQUAL
103490: IFTRUE 103494
103492: GO 103516
103494: POP
// hHackTeleport ( unit , x , y ) ; end ;
103495: LD_VAR 0 2
103499: PPUSH
103500: LD_VAR 0 4
103504: PPUSH
103505: LD_VAR 0 5
103509: PPUSH
103510: CALL 105281 0 3
103514: GO 103517
103516: POP
// end ;
103517: LD_VAR 0 12
103521: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103522: LD_INT 0
103524: PPUSH
103525: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103526: LD_VAR 0 1
103530: PUSH
103531: LD_INT 1
103533: LESS
103534: PUSH
103535: LD_VAR 0 1
103539: PUSH
103540: LD_INT 3
103542: GREATER
103543: OR
103544: PUSH
103545: LD_VAR 0 5
103549: PPUSH
103550: LD_VAR 0 6
103554: PPUSH
103555: CALL_OW 428
103559: OR
103560: IFFALSE 103564
// exit ;
103562: GO 104284
// uc_side := your_side ;
103564: LD_ADDR_OWVAR 20
103568: PUSH
103569: LD_OWVAR 2
103573: ST_TO_ADDR
// uc_nation := nation ;
103574: LD_ADDR_OWVAR 21
103578: PUSH
103579: LD_VAR 0 1
103583: ST_TO_ADDR
// bc_level = 1 ;
103584: LD_ADDR_OWVAR 43
103588: PUSH
103589: LD_INT 1
103591: ST_TO_ADDR
// case btype of 1 :
103592: LD_VAR 0 2
103596: PUSH
103597: LD_INT 1
103599: DOUBLE
103600: EQUAL
103601: IFTRUE 103605
103603: GO 103616
103605: POP
// bc_type := b_depot ; 2 :
103606: LD_ADDR_OWVAR 42
103610: PUSH
103611: LD_INT 0
103613: ST_TO_ADDR
103614: GO 104228
103616: LD_INT 2
103618: DOUBLE
103619: EQUAL
103620: IFTRUE 103624
103622: GO 103635
103624: POP
// bc_type := b_warehouse ; 3 :
103625: LD_ADDR_OWVAR 42
103629: PUSH
103630: LD_INT 1
103632: ST_TO_ADDR
103633: GO 104228
103635: LD_INT 3
103637: DOUBLE
103638: EQUAL
103639: IFTRUE 103643
103641: GO 103654
103643: POP
// bc_type := b_lab ; 4 .. 9 :
103644: LD_ADDR_OWVAR 42
103648: PUSH
103649: LD_INT 6
103651: ST_TO_ADDR
103652: GO 104228
103654: LD_INT 4
103656: DOUBLE
103657: GREATEREQUAL
103658: IFFALSE 103666
103660: LD_INT 9
103662: DOUBLE
103663: LESSEQUAL
103664: IFTRUE 103668
103666: GO 103720
103668: POP
// begin bc_type := b_lab_half ;
103669: LD_ADDR_OWVAR 42
103673: PUSH
103674: LD_INT 7
103676: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103677: LD_ADDR_OWVAR 44
103681: PUSH
103682: LD_INT 10
103684: PUSH
103685: LD_INT 11
103687: PUSH
103688: LD_INT 12
103690: PUSH
103691: LD_INT 15
103693: PUSH
103694: LD_INT 14
103696: PUSH
103697: LD_INT 13
103699: PUSH
103700: EMPTY
103701: LIST
103702: LIST
103703: LIST
103704: LIST
103705: LIST
103706: LIST
103707: PUSH
103708: LD_VAR 0 2
103712: PUSH
103713: LD_INT 3
103715: MINUS
103716: ARRAY
103717: ST_TO_ADDR
// end ; 10 .. 13 :
103718: GO 104228
103720: LD_INT 10
103722: DOUBLE
103723: GREATEREQUAL
103724: IFFALSE 103732
103726: LD_INT 13
103728: DOUBLE
103729: LESSEQUAL
103730: IFTRUE 103734
103732: GO 103811
103734: POP
// begin bc_type := b_lab_full ;
103735: LD_ADDR_OWVAR 42
103739: PUSH
103740: LD_INT 8
103742: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103743: LD_ADDR_OWVAR 44
103747: PUSH
103748: LD_INT 10
103750: PUSH
103751: LD_INT 12
103753: PUSH
103754: LD_INT 14
103756: PUSH
103757: LD_INT 13
103759: PUSH
103760: EMPTY
103761: LIST
103762: LIST
103763: LIST
103764: LIST
103765: PUSH
103766: LD_VAR 0 2
103770: PUSH
103771: LD_INT 9
103773: MINUS
103774: ARRAY
103775: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103776: LD_ADDR_OWVAR 45
103780: PUSH
103781: LD_INT 11
103783: PUSH
103784: LD_INT 15
103786: PUSH
103787: LD_INT 12
103789: PUSH
103790: LD_INT 15
103792: PUSH
103793: EMPTY
103794: LIST
103795: LIST
103796: LIST
103797: LIST
103798: PUSH
103799: LD_VAR 0 2
103803: PUSH
103804: LD_INT 9
103806: MINUS
103807: ARRAY
103808: ST_TO_ADDR
// end ; 14 :
103809: GO 104228
103811: LD_INT 14
103813: DOUBLE
103814: EQUAL
103815: IFTRUE 103819
103817: GO 103830
103819: POP
// bc_type := b_workshop ; 15 :
103820: LD_ADDR_OWVAR 42
103824: PUSH
103825: LD_INT 2
103827: ST_TO_ADDR
103828: GO 104228
103830: LD_INT 15
103832: DOUBLE
103833: EQUAL
103834: IFTRUE 103838
103836: GO 103849
103838: POP
// bc_type := b_factory ; 16 :
103839: LD_ADDR_OWVAR 42
103843: PUSH
103844: LD_INT 3
103846: ST_TO_ADDR
103847: GO 104228
103849: LD_INT 16
103851: DOUBLE
103852: EQUAL
103853: IFTRUE 103857
103855: GO 103868
103857: POP
// bc_type := b_ext_gun ; 17 :
103858: LD_ADDR_OWVAR 42
103862: PUSH
103863: LD_INT 17
103865: ST_TO_ADDR
103866: GO 104228
103868: LD_INT 17
103870: DOUBLE
103871: EQUAL
103872: IFTRUE 103876
103874: GO 103904
103876: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103877: LD_ADDR_OWVAR 42
103881: PUSH
103882: LD_INT 19
103884: PUSH
103885: LD_INT 23
103887: PUSH
103888: LD_INT 19
103890: PUSH
103891: EMPTY
103892: LIST
103893: LIST
103894: LIST
103895: PUSH
103896: LD_VAR 0 1
103900: ARRAY
103901: ST_TO_ADDR
103902: GO 104228
103904: LD_INT 18
103906: DOUBLE
103907: EQUAL
103908: IFTRUE 103912
103910: GO 103923
103912: POP
// bc_type := b_ext_radar ; 19 :
103913: LD_ADDR_OWVAR 42
103917: PUSH
103918: LD_INT 20
103920: ST_TO_ADDR
103921: GO 104228
103923: LD_INT 19
103925: DOUBLE
103926: EQUAL
103927: IFTRUE 103931
103929: GO 103942
103931: POP
// bc_type := b_ext_radio ; 20 :
103932: LD_ADDR_OWVAR 42
103936: PUSH
103937: LD_INT 22
103939: ST_TO_ADDR
103940: GO 104228
103942: LD_INT 20
103944: DOUBLE
103945: EQUAL
103946: IFTRUE 103950
103948: GO 103961
103950: POP
// bc_type := b_ext_siberium ; 21 :
103951: LD_ADDR_OWVAR 42
103955: PUSH
103956: LD_INT 21
103958: ST_TO_ADDR
103959: GO 104228
103961: LD_INT 21
103963: DOUBLE
103964: EQUAL
103965: IFTRUE 103969
103967: GO 103980
103969: POP
// bc_type := b_ext_computer ; 22 :
103970: LD_ADDR_OWVAR 42
103974: PUSH
103975: LD_INT 24
103977: ST_TO_ADDR
103978: GO 104228
103980: LD_INT 22
103982: DOUBLE
103983: EQUAL
103984: IFTRUE 103988
103986: GO 103999
103988: POP
// bc_type := b_ext_track ; 23 :
103989: LD_ADDR_OWVAR 42
103993: PUSH
103994: LD_INT 16
103996: ST_TO_ADDR
103997: GO 104228
103999: LD_INT 23
104001: DOUBLE
104002: EQUAL
104003: IFTRUE 104007
104005: GO 104018
104007: POP
// bc_type := b_ext_laser ; 24 :
104008: LD_ADDR_OWVAR 42
104012: PUSH
104013: LD_INT 25
104015: ST_TO_ADDR
104016: GO 104228
104018: LD_INT 24
104020: DOUBLE
104021: EQUAL
104022: IFTRUE 104026
104024: GO 104037
104026: POP
// bc_type := b_control_tower ; 25 :
104027: LD_ADDR_OWVAR 42
104031: PUSH
104032: LD_INT 36
104034: ST_TO_ADDR
104035: GO 104228
104037: LD_INT 25
104039: DOUBLE
104040: EQUAL
104041: IFTRUE 104045
104043: GO 104056
104045: POP
// bc_type := b_breastwork ; 26 :
104046: LD_ADDR_OWVAR 42
104050: PUSH
104051: LD_INT 31
104053: ST_TO_ADDR
104054: GO 104228
104056: LD_INT 26
104058: DOUBLE
104059: EQUAL
104060: IFTRUE 104064
104062: GO 104075
104064: POP
// bc_type := b_bunker ; 27 :
104065: LD_ADDR_OWVAR 42
104069: PUSH
104070: LD_INT 32
104072: ST_TO_ADDR
104073: GO 104228
104075: LD_INT 27
104077: DOUBLE
104078: EQUAL
104079: IFTRUE 104083
104081: GO 104094
104083: POP
// bc_type := b_turret ; 28 :
104084: LD_ADDR_OWVAR 42
104088: PUSH
104089: LD_INT 33
104091: ST_TO_ADDR
104092: GO 104228
104094: LD_INT 28
104096: DOUBLE
104097: EQUAL
104098: IFTRUE 104102
104100: GO 104113
104102: POP
// bc_type := b_armoury ; 29 :
104103: LD_ADDR_OWVAR 42
104107: PUSH
104108: LD_INT 4
104110: ST_TO_ADDR
104111: GO 104228
104113: LD_INT 29
104115: DOUBLE
104116: EQUAL
104117: IFTRUE 104121
104119: GO 104132
104121: POP
// bc_type := b_barracks ; 30 :
104122: LD_ADDR_OWVAR 42
104126: PUSH
104127: LD_INT 5
104129: ST_TO_ADDR
104130: GO 104228
104132: LD_INT 30
104134: DOUBLE
104135: EQUAL
104136: IFTRUE 104140
104138: GO 104151
104140: POP
// bc_type := b_solar_power ; 31 :
104141: LD_ADDR_OWVAR 42
104145: PUSH
104146: LD_INT 27
104148: ST_TO_ADDR
104149: GO 104228
104151: LD_INT 31
104153: DOUBLE
104154: EQUAL
104155: IFTRUE 104159
104157: GO 104170
104159: POP
// bc_type := b_oil_power ; 32 :
104160: LD_ADDR_OWVAR 42
104164: PUSH
104165: LD_INT 26
104167: ST_TO_ADDR
104168: GO 104228
104170: LD_INT 32
104172: DOUBLE
104173: EQUAL
104174: IFTRUE 104178
104176: GO 104189
104178: POP
// bc_type := b_siberite_power ; 33 :
104179: LD_ADDR_OWVAR 42
104183: PUSH
104184: LD_INT 28
104186: ST_TO_ADDR
104187: GO 104228
104189: LD_INT 33
104191: DOUBLE
104192: EQUAL
104193: IFTRUE 104197
104195: GO 104208
104197: POP
// bc_type := b_oil_mine ; 34 :
104198: LD_ADDR_OWVAR 42
104202: PUSH
104203: LD_INT 29
104205: ST_TO_ADDR
104206: GO 104228
104208: LD_INT 34
104210: DOUBLE
104211: EQUAL
104212: IFTRUE 104216
104214: GO 104227
104216: POP
// bc_type := b_siberite_mine ; end ;
104217: LD_ADDR_OWVAR 42
104221: PUSH
104222: LD_INT 30
104224: ST_TO_ADDR
104225: GO 104228
104227: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104228: LD_ADDR_VAR 0 8
104232: PUSH
104233: LD_VAR 0 5
104237: PPUSH
104238: LD_VAR 0 6
104242: PPUSH
104243: LD_VAR 0 3
104247: PPUSH
104248: CALL_OW 47
104252: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104253: LD_OWVAR 42
104257: PUSH
104258: LD_INT 32
104260: PUSH
104261: LD_INT 33
104263: PUSH
104264: EMPTY
104265: LIST
104266: LIST
104267: IN
104268: IFFALSE 104284
// PlaceWeaponTurret ( b , weapon ) ;
104270: LD_VAR 0 8
104274: PPUSH
104275: LD_VAR 0 4
104279: PPUSH
104280: CALL_OW 431
// end ;
104284: LD_VAR 0 7
104288: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104289: LD_INT 0
104291: PPUSH
104292: PPUSH
104293: PPUSH
104294: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104295: LD_ADDR_VAR 0 4
104299: PUSH
104300: LD_INT 22
104302: PUSH
104303: LD_OWVAR 2
104307: PUSH
104308: EMPTY
104309: LIST
104310: LIST
104311: PUSH
104312: LD_INT 2
104314: PUSH
104315: LD_INT 30
104317: PUSH
104318: LD_INT 0
104320: PUSH
104321: EMPTY
104322: LIST
104323: LIST
104324: PUSH
104325: LD_INT 30
104327: PUSH
104328: LD_INT 1
104330: PUSH
104331: EMPTY
104332: LIST
104333: LIST
104334: PUSH
104335: EMPTY
104336: LIST
104337: LIST
104338: LIST
104339: PUSH
104340: EMPTY
104341: LIST
104342: LIST
104343: PPUSH
104344: CALL_OW 69
104348: ST_TO_ADDR
// if not tmp then
104349: LD_VAR 0 4
104353: NOT
104354: IFFALSE 104358
// exit ;
104356: GO 104417
// for i in tmp do
104358: LD_ADDR_VAR 0 2
104362: PUSH
104363: LD_VAR 0 4
104367: PUSH
104368: FOR_IN
104369: IFFALSE 104415
// for j = 1 to 3 do
104371: LD_ADDR_VAR 0 3
104375: PUSH
104376: DOUBLE
104377: LD_INT 1
104379: DEC
104380: ST_TO_ADDR
104381: LD_INT 3
104383: PUSH
104384: FOR_TO
104385: IFFALSE 104411
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104387: LD_VAR 0 2
104391: PPUSH
104392: CALL_OW 274
104396: PPUSH
104397: LD_VAR 0 3
104401: PPUSH
104402: LD_INT 99999
104404: PPUSH
104405: CALL_OW 277
104409: GO 104384
104411: POP
104412: POP
104413: GO 104368
104415: POP
104416: POP
// end ;
104417: LD_VAR 0 1
104421: RET
// export function hHackSetLevel10 ; var i , j ; begin
104422: LD_INT 0
104424: PPUSH
104425: PPUSH
104426: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104427: LD_ADDR_VAR 0 2
104431: PUSH
104432: LD_INT 21
104434: PUSH
104435: LD_INT 1
104437: PUSH
104438: EMPTY
104439: LIST
104440: LIST
104441: PPUSH
104442: CALL_OW 69
104446: PUSH
104447: FOR_IN
104448: IFFALSE 104500
// if IsSelected ( i ) then
104450: LD_VAR 0 2
104454: PPUSH
104455: CALL_OW 306
104459: IFFALSE 104498
// begin for j := 1 to 4 do
104461: LD_ADDR_VAR 0 3
104465: PUSH
104466: DOUBLE
104467: LD_INT 1
104469: DEC
104470: ST_TO_ADDR
104471: LD_INT 4
104473: PUSH
104474: FOR_TO
104475: IFFALSE 104496
// SetSkill ( i , j , 10 ) ;
104477: LD_VAR 0 2
104481: PPUSH
104482: LD_VAR 0 3
104486: PPUSH
104487: LD_INT 10
104489: PPUSH
104490: CALL_OW 237
104494: GO 104474
104496: POP
104497: POP
// end ;
104498: GO 104447
104500: POP
104501: POP
// end ;
104502: LD_VAR 0 1
104506: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104507: LD_INT 0
104509: PPUSH
104510: PPUSH
104511: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104512: LD_ADDR_VAR 0 2
104516: PUSH
104517: LD_INT 22
104519: PUSH
104520: LD_OWVAR 2
104524: PUSH
104525: EMPTY
104526: LIST
104527: LIST
104528: PUSH
104529: LD_INT 21
104531: PUSH
104532: LD_INT 1
104534: PUSH
104535: EMPTY
104536: LIST
104537: LIST
104538: PUSH
104539: EMPTY
104540: LIST
104541: LIST
104542: PPUSH
104543: CALL_OW 69
104547: PUSH
104548: FOR_IN
104549: IFFALSE 104590
// begin for j := 1 to 4 do
104551: LD_ADDR_VAR 0 3
104555: PUSH
104556: DOUBLE
104557: LD_INT 1
104559: DEC
104560: ST_TO_ADDR
104561: LD_INT 4
104563: PUSH
104564: FOR_TO
104565: IFFALSE 104586
// SetSkill ( i , j , 10 ) ;
104567: LD_VAR 0 2
104571: PPUSH
104572: LD_VAR 0 3
104576: PPUSH
104577: LD_INT 10
104579: PPUSH
104580: CALL_OW 237
104584: GO 104564
104586: POP
104587: POP
// end ;
104588: GO 104548
104590: POP
104591: POP
// end ;
104592: LD_VAR 0 1
104596: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104597: LD_INT 0
104599: PPUSH
// uc_side := your_side ;
104600: LD_ADDR_OWVAR 20
104604: PUSH
104605: LD_OWVAR 2
104609: ST_TO_ADDR
// uc_nation := nation ;
104610: LD_ADDR_OWVAR 21
104614: PUSH
104615: LD_VAR 0 1
104619: ST_TO_ADDR
// InitHc ;
104620: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104624: LD_INT 0
104626: PPUSH
104627: LD_VAR 0 2
104631: PPUSH
104632: LD_VAR 0 3
104636: PPUSH
104637: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104641: LD_VAR 0 4
104645: PPUSH
104646: LD_VAR 0 5
104650: PPUSH
104651: CALL_OW 428
104655: PUSH
104656: LD_INT 0
104658: EQUAL
104659: IFFALSE 104683
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104661: CALL_OW 44
104665: PPUSH
104666: LD_VAR 0 4
104670: PPUSH
104671: LD_VAR 0 5
104675: PPUSH
104676: LD_INT 1
104678: PPUSH
104679: CALL_OW 48
// end ;
104683: LD_VAR 0 6
104687: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104688: LD_INT 0
104690: PPUSH
104691: PPUSH
// uc_side := your_side ;
104692: LD_ADDR_OWVAR 20
104696: PUSH
104697: LD_OWVAR 2
104701: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104702: LD_VAR 0 1
104706: PUSH
104707: LD_INT 1
104709: PUSH
104710: LD_INT 2
104712: PUSH
104713: LD_INT 3
104715: PUSH
104716: LD_INT 4
104718: PUSH
104719: LD_INT 5
104721: PUSH
104722: EMPTY
104723: LIST
104724: LIST
104725: LIST
104726: LIST
104727: LIST
104728: IN
104729: IFFALSE 104741
// uc_nation := nation_american else
104731: LD_ADDR_OWVAR 21
104735: PUSH
104736: LD_INT 1
104738: ST_TO_ADDR
104739: GO 104784
// if chassis in [ 11 , 12 , 13 , 14 ] then
104741: LD_VAR 0 1
104745: PUSH
104746: LD_INT 11
104748: PUSH
104749: LD_INT 12
104751: PUSH
104752: LD_INT 13
104754: PUSH
104755: LD_INT 14
104757: PUSH
104758: EMPTY
104759: LIST
104760: LIST
104761: LIST
104762: LIST
104763: IN
104764: IFFALSE 104776
// uc_nation := nation_arabian else
104766: LD_ADDR_OWVAR 21
104770: PUSH
104771: LD_INT 2
104773: ST_TO_ADDR
104774: GO 104784
// uc_nation := nation_russian ;
104776: LD_ADDR_OWVAR 21
104780: PUSH
104781: LD_INT 3
104783: ST_TO_ADDR
// vc_chassis := chassis ;
104784: LD_ADDR_OWVAR 37
104788: PUSH
104789: LD_VAR 0 1
104793: ST_TO_ADDR
// vc_engine := engine ;
104794: LD_ADDR_OWVAR 39
104798: PUSH
104799: LD_VAR 0 2
104803: ST_TO_ADDR
// vc_control := control ;
104804: LD_ADDR_OWVAR 38
104808: PUSH
104809: LD_VAR 0 3
104813: ST_TO_ADDR
// vc_weapon := weapon ;
104814: LD_ADDR_OWVAR 40
104818: PUSH
104819: LD_VAR 0 4
104823: ST_TO_ADDR
// un := CreateVehicle ;
104824: LD_ADDR_VAR 0 8
104828: PUSH
104829: CALL_OW 45
104833: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104834: LD_VAR 0 8
104838: PPUSH
104839: LD_INT 0
104841: PPUSH
104842: LD_INT 5
104844: PPUSH
104845: CALL_OW 12
104849: PPUSH
104850: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104854: LD_VAR 0 8
104858: PPUSH
104859: LD_VAR 0 5
104863: PPUSH
104864: LD_VAR 0 6
104868: PPUSH
104869: LD_INT 1
104871: PPUSH
104872: CALL_OW 48
// end ;
104876: LD_VAR 0 7
104880: RET
// export hInvincible ; every 1 do
104881: GO 104883
104883: DISABLE
// hInvincible := [ ] ;
104884: LD_ADDR_EXP 196
104888: PUSH
104889: EMPTY
104890: ST_TO_ADDR
104891: END
// every 10 do var i ;
104892: GO 104894
104894: DISABLE
104895: LD_INT 0
104897: PPUSH
// begin enable ;
104898: ENABLE
// if not hInvincible then
104899: LD_EXP 196
104903: NOT
104904: IFFALSE 104908
// exit ;
104906: GO 104952
// for i in hInvincible do
104908: LD_ADDR_VAR 0 1
104912: PUSH
104913: LD_EXP 196
104917: PUSH
104918: FOR_IN
104919: IFFALSE 104950
// if GetLives ( i ) < 1000 then
104921: LD_VAR 0 1
104925: PPUSH
104926: CALL_OW 256
104930: PUSH
104931: LD_INT 1000
104933: LESS
104934: IFFALSE 104948
// SetLives ( i , 1000 ) ;
104936: LD_VAR 0 1
104940: PPUSH
104941: LD_INT 1000
104943: PPUSH
104944: CALL_OW 234
104948: GO 104918
104950: POP
104951: POP
// end ;
104952: PPOPN 1
104954: END
// export function hHackInvincible ; var i ; begin
104955: LD_INT 0
104957: PPUSH
104958: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104959: LD_ADDR_VAR 0 2
104963: PUSH
104964: LD_INT 2
104966: PUSH
104967: LD_INT 21
104969: PUSH
104970: LD_INT 1
104972: PUSH
104973: EMPTY
104974: LIST
104975: LIST
104976: PUSH
104977: LD_INT 21
104979: PUSH
104980: LD_INT 2
104982: PUSH
104983: EMPTY
104984: LIST
104985: LIST
104986: PUSH
104987: EMPTY
104988: LIST
104989: LIST
104990: LIST
104991: PPUSH
104992: CALL_OW 69
104996: PUSH
104997: FOR_IN
104998: IFFALSE 105059
// if IsSelected ( i ) then
105000: LD_VAR 0 2
105004: PPUSH
105005: CALL_OW 306
105009: IFFALSE 105057
// begin if i in hInvincible then
105011: LD_VAR 0 2
105015: PUSH
105016: LD_EXP 196
105020: IN
105021: IFFALSE 105041
// hInvincible := hInvincible diff i else
105023: LD_ADDR_EXP 196
105027: PUSH
105028: LD_EXP 196
105032: PUSH
105033: LD_VAR 0 2
105037: DIFF
105038: ST_TO_ADDR
105039: GO 105057
// hInvincible := hInvincible union i ;
105041: LD_ADDR_EXP 196
105045: PUSH
105046: LD_EXP 196
105050: PUSH
105051: LD_VAR 0 2
105055: UNION
105056: ST_TO_ADDR
// end ;
105057: GO 104997
105059: POP
105060: POP
// end ;
105061: LD_VAR 0 1
105065: RET
// export function hHackInvisible ; var i , j ; begin
105066: LD_INT 0
105068: PPUSH
105069: PPUSH
105070: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105071: LD_ADDR_VAR 0 2
105075: PUSH
105076: LD_INT 21
105078: PUSH
105079: LD_INT 1
105081: PUSH
105082: EMPTY
105083: LIST
105084: LIST
105085: PPUSH
105086: CALL_OW 69
105090: PUSH
105091: FOR_IN
105092: IFFALSE 105116
// if IsSelected ( i ) then
105094: LD_VAR 0 2
105098: PPUSH
105099: CALL_OW 306
105103: IFFALSE 105114
// ComForceInvisible ( i ) ;
105105: LD_VAR 0 2
105109: PPUSH
105110: CALL_OW 496
105114: GO 105091
105116: POP
105117: POP
// end ;
105118: LD_VAR 0 1
105122: RET
// export function hHackChangeYourSide ; begin
105123: LD_INT 0
105125: PPUSH
// if your_side = 8 then
105126: LD_OWVAR 2
105130: PUSH
105131: LD_INT 8
105133: EQUAL
105134: IFFALSE 105146
// your_side := 0 else
105136: LD_ADDR_OWVAR 2
105140: PUSH
105141: LD_INT 0
105143: ST_TO_ADDR
105144: GO 105160
// your_side := your_side + 1 ;
105146: LD_ADDR_OWVAR 2
105150: PUSH
105151: LD_OWVAR 2
105155: PUSH
105156: LD_INT 1
105158: PLUS
105159: ST_TO_ADDR
// end ;
105160: LD_VAR 0 1
105164: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105165: LD_INT 0
105167: PPUSH
105168: PPUSH
105169: PPUSH
// for i in all_units do
105170: LD_ADDR_VAR 0 2
105174: PUSH
105175: LD_OWVAR 3
105179: PUSH
105180: FOR_IN
105181: IFFALSE 105259
// if IsSelected ( i ) then
105183: LD_VAR 0 2
105187: PPUSH
105188: CALL_OW 306
105192: IFFALSE 105257
// begin j := GetSide ( i ) ;
105194: LD_ADDR_VAR 0 3
105198: PUSH
105199: LD_VAR 0 2
105203: PPUSH
105204: CALL_OW 255
105208: ST_TO_ADDR
// if j = 8 then
105209: LD_VAR 0 3
105213: PUSH
105214: LD_INT 8
105216: EQUAL
105217: IFFALSE 105229
// j := 0 else
105219: LD_ADDR_VAR 0 3
105223: PUSH
105224: LD_INT 0
105226: ST_TO_ADDR
105227: GO 105243
// j := j + 1 ;
105229: LD_ADDR_VAR 0 3
105233: PUSH
105234: LD_VAR 0 3
105238: PUSH
105239: LD_INT 1
105241: PLUS
105242: ST_TO_ADDR
// SetSide ( i , j ) ;
105243: LD_VAR 0 2
105247: PPUSH
105248: LD_VAR 0 3
105252: PPUSH
105253: CALL_OW 235
// end ;
105257: GO 105180
105259: POP
105260: POP
// end ;
105261: LD_VAR 0 1
105265: RET
// export function hHackFog ; begin
105266: LD_INT 0
105268: PPUSH
// FogOff ( true ) ;
105269: LD_INT 1
105271: PPUSH
105272: CALL_OW 344
// end ;
105276: LD_VAR 0 1
105280: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105281: LD_INT 0
105283: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105284: LD_VAR 0 1
105288: PPUSH
105289: LD_VAR 0 2
105293: PPUSH
105294: LD_VAR 0 3
105298: PPUSH
105299: LD_INT 1
105301: PPUSH
105302: LD_INT 1
105304: PPUSH
105305: CALL_OW 483
// CenterOnXY ( x , y ) ;
105309: LD_VAR 0 2
105313: PPUSH
105314: LD_VAR 0 3
105318: PPUSH
105319: CALL_OW 84
// end ; end_of_file
105323: LD_VAR 0 4
105327: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105328: LD_INT 0
105330: PPUSH
105331: PPUSH
105332: PPUSH
105333: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105334: LD_VAR 0 1
105338: PPUSH
105339: CALL_OW 264
105343: PUSH
105344: LD_EXP 78
105348: EQUAL
105349: IFFALSE 105421
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105351: LD_INT 68
105353: PPUSH
105354: LD_VAR 0 1
105358: PPUSH
105359: CALL_OW 255
105363: PPUSH
105364: CALL_OW 321
105368: PUSH
105369: LD_INT 2
105371: EQUAL
105372: IFFALSE 105384
// eff := 70 else
105374: LD_ADDR_VAR 0 4
105378: PUSH
105379: LD_INT 70
105381: ST_TO_ADDR
105382: GO 105392
// eff := 30 ;
105384: LD_ADDR_VAR 0 4
105388: PUSH
105389: LD_INT 30
105391: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105392: LD_VAR 0 1
105396: PPUSH
105397: CALL_OW 250
105401: PPUSH
105402: LD_VAR 0 1
105406: PPUSH
105407: CALL_OW 251
105411: PPUSH
105412: LD_VAR 0 4
105416: PPUSH
105417: CALL_OW 495
// end ; end ;
105421: LD_VAR 0 2
105425: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105426: LD_INT 0
105428: PPUSH
// end ;
105429: LD_VAR 0 4
105433: RET
// export function SOS_Command ( cmd ) ; begin
105434: LD_INT 0
105436: PPUSH
// end ;
105437: LD_VAR 0 2
105441: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105442: LD_INT 0
105444: PPUSH
// end ;
105445: LD_VAR 0 6
105449: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
105450: LD_INT 0
105452: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
105453: LD_VAR 0 1
105457: PUSH
105458: LD_INT 250
105460: EQUAL
105461: PUSH
105462: LD_VAR 0 2
105466: PPUSH
105467: CALL_OW 264
105471: PUSH
105472: LD_EXP 81
105476: EQUAL
105477: AND
105478: IFFALSE 105499
// MinerPlaceMine ( unit , x , y ) ;
105480: LD_VAR 0 2
105484: PPUSH
105485: LD_VAR 0 4
105489: PPUSH
105490: LD_VAR 0 5
105494: PPUSH
105495: CALL 107848 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
105499: LD_VAR 0 1
105503: PUSH
105504: LD_INT 251
105506: EQUAL
105507: PUSH
105508: LD_VAR 0 2
105512: PPUSH
105513: CALL_OW 264
105517: PUSH
105518: LD_EXP 81
105522: EQUAL
105523: AND
105524: IFFALSE 105545
// MinerDetonateMine ( unit , x , y ) ;
105526: LD_VAR 0 2
105530: PPUSH
105531: LD_VAR 0 4
105535: PPUSH
105536: LD_VAR 0 5
105540: PPUSH
105541: CALL 108125 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
105545: LD_VAR 0 1
105549: PUSH
105550: LD_INT 252
105552: EQUAL
105553: PUSH
105554: LD_VAR 0 2
105558: PPUSH
105559: CALL_OW 264
105563: PUSH
105564: LD_EXP 81
105568: EQUAL
105569: AND
105570: IFFALSE 105591
// MinerCreateMinefield ( unit , x , y ) ;
105572: LD_VAR 0 2
105576: PPUSH
105577: LD_VAR 0 4
105581: PPUSH
105582: LD_VAR 0 5
105586: PPUSH
105587: CALL 108542 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
105591: LD_VAR 0 1
105595: PUSH
105596: LD_INT 253
105598: EQUAL
105599: PUSH
105600: LD_VAR 0 2
105604: PPUSH
105605: CALL_OW 257
105609: PUSH
105610: LD_INT 5
105612: EQUAL
105613: AND
105614: IFFALSE 105635
// ComBinocular ( unit , x , y ) ;
105616: LD_VAR 0 2
105620: PPUSH
105621: LD_VAR 0 4
105625: PPUSH
105626: LD_VAR 0 5
105630: PPUSH
105631: CALL 108913 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
105635: LD_VAR 0 1
105639: PUSH
105640: LD_INT 254
105642: EQUAL
105643: PUSH
105644: LD_VAR 0 2
105648: PPUSH
105649: CALL_OW 264
105653: PUSH
105654: LD_EXP 76
105658: EQUAL
105659: AND
105660: PUSH
105661: LD_VAR 0 3
105665: PPUSH
105666: CALL_OW 263
105670: PUSH
105671: LD_INT 3
105673: EQUAL
105674: AND
105675: IFFALSE 105691
// HackDestroyVehicle ( unit , selectedUnit ) ;
105677: LD_VAR 0 2
105681: PPUSH
105682: LD_VAR 0 3
105686: PPUSH
105687: CALL 107208 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
105691: LD_VAR 0 1
105695: PUSH
105696: LD_INT 255
105698: EQUAL
105699: PUSH
105700: LD_VAR 0 2
105704: PPUSH
105705: CALL_OW 264
105709: PUSH
105710: LD_INT 14
105712: PUSH
105713: LD_INT 53
105715: PUSH
105716: EMPTY
105717: LIST
105718: LIST
105719: IN
105720: AND
105721: PUSH
105722: LD_VAR 0 4
105726: PPUSH
105727: LD_VAR 0 5
105731: PPUSH
105732: CALL_OW 488
105736: AND
105737: IFFALSE 105761
// CutTreeXYR ( unit , x , y , 12 ) ;
105739: LD_VAR 0 2
105743: PPUSH
105744: LD_VAR 0 4
105748: PPUSH
105749: LD_VAR 0 5
105753: PPUSH
105754: LD_INT 12
105756: PPUSH
105757: CALL 105774 0 4
// end ;
105761: LD_VAR 0 6
105765: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
105766: LD_INT 0
105768: PPUSH
// end ;
105769: LD_VAR 0 4
105773: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105774: LD_INT 0
105776: PPUSH
105777: PPUSH
105778: PPUSH
105779: PPUSH
105780: PPUSH
105781: PPUSH
105782: PPUSH
105783: PPUSH
105784: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
105785: LD_VAR 0 1
105789: NOT
105790: PUSH
105791: LD_VAR 0 2
105795: PPUSH
105796: LD_VAR 0 3
105800: PPUSH
105801: CALL_OW 488
105805: NOT
105806: OR
105807: PUSH
105808: LD_VAR 0 4
105812: NOT
105813: OR
105814: IFFALSE 105818
// exit ;
105816: GO 106158
// list := [ ] ;
105818: LD_ADDR_VAR 0 13
105822: PUSH
105823: EMPTY
105824: ST_TO_ADDR
// if x - r < 0 then
105825: LD_VAR 0 2
105829: PUSH
105830: LD_VAR 0 4
105834: MINUS
105835: PUSH
105836: LD_INT 0
105838: LESS
105839: IFFALSE 105851
// min_x := 0 else
105841: LD_ADDR_VAR 0 7
105845: PUSH
105846: LD_INT 0
105848: ST_TO_ADDR
105849: GO 105867
// min_x := x - r ;
105851: LD_ADDR_VAR 0 7
105855: PUSH
105856: LD_VAR 0 2
105860: PUSH
105861: LD_VAR 0 4
105865: MINUS
105866: ST_TO_ADDR
// if y - r < 0 then
105867: LD_VAR 0 3
105871: PUSH
105872: LD_VAR 0 4
105876: MINUS
105877: PUSH
105878: LD_INT 0
105880: LESS
105881: IFFALSE 105893
// min_y := 0 else
105883: LD_ADDR_VAR 0 8
105887: PUSH
105888: LD_INT 0
105890: ST_TO_ADDR
105891: GO 105909
// min_y := y - r ;
105893: LD_ADDR_VAR 0 8
105897: PUSH
105898: LD_VAR 0 3
105902: PUSH
105903: LD_VAR 0 4
105907: MINUS
105908: ST_TO_ADDR
// max_x := x + r ;
105909: LD_ADDR_VAR 0 9
105913: PUSH
105914: LD_VAR 0 2
105918: PUSH
105919: LD_VAR 0 4
105923: PLUS
105924: ST_TO_ADDR
// max_y := y + r ;
105925: LD_ADDR_VAR 0 10
105929: PUSH
105930: LD_VAR 0 3
105934: PUSH
105935: LD_VAR 0 4
105939: PLUS
105940: ST_TO_ADDR
// for _x = min_x to max_x do
105941: LD_ADDR_VAR 0 11
105945: PUSH
105946: DOUBLE
105947: LD_VAR 0 7
105951: DEC
105952: ST_TO_ADDR
105953: LD_VAR 0 9
105957: PUSH
105958: FOR_TO
105959: IFFALSE 106076
// for _y = min_y to max_y do
105961: LD_ADDR_VAR 0 12
105965: PUSH
105966: DOUBLE
105967: LD_VAR 0 8
105971: DEC
105972: ST_TO_ADDR
105973: LD_VAR 0 10
105977: PUSH
105978: FOR_TO
105979: IFFALSE 106072
// begin if not ValidHex ( _x , _y ) then
105981: LD_VAR 0 11
105985: PPUSH
105986: LD_VAR 0 12
105990: PPUSH
105991: CALL_OW 488
105995: NOT
105996: IFFALSE 106000
// continue ;
105998: GO 105978
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106000: LD_VAR 0 11
106004: PPUSH
106005: LD_VAR 0 12
106009: PPUSH
106010: CALL_OW 351
106014: PUSH
106015: LD_VAR 0 11
106019: PPUSH
106020: LD_VAR 0 12
106024: PPUSH
106025: CALL_OW 554
106029: AND
106030: IFFALSE 106070
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106032: LD_ADDR_VAR 0 13
106036: PUSH
106037: LD_VAR 0 13
106041: PPUSH
106042: LD_VAR 0 13
106046: PUSH
106047: LD_INT 1
106049: PLUS
106050: PPUSH
106051: LD_VAR 0 11
106055: PUSH
106056: LD_VAR 0 12
106060: PUSH
106061: EMPTY
106062: LIST
106063: LIST
106064: PPUSH
106065: CALL_OW 2
106069: ST_TO_ADDR
// end ;
106070: GO 105978
106072: POP
106073: POP
106074: GO 105958
106076: POP
106077: POP
// if not list then
106078: LD_VAR 0 13
106082: NOT
106083: IFFALSE 106087
// exit ;
106085: GO 106158
// for i in list do
106087: LD_ADDR_VAR 0 6
106091: PUSH
106092: LD_VAR 0 13
106096: PUSH
106097: FOR_IN
106098: IFFALSE 106156
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106100: LD_VAR 0 1
106104: PPUSH
106105: LD_STRING M
106107: PUSH
106108: LD_VAR 0 6
106112: PUSH
106113: LD_INT 1
106115: ARRAY
106116: PUSH
106117: LD_VAR 0 6
106121: PUSH
106122: LD_INT 2
106124: ARRAY
106125: PUSH
106126: LD_INT 0
106128: PUSH
106129: LD_INT 0
106131: PUSH
106132: LD_INT 0
106134: PUSH
106135: LD_INT 0
106137: PUSH
106138: EMPTY
106139: LIST
106140: LIST
106141: LIST
106142: LIST
106143: LIST
106144: LIST
106145: LIST
106146: PUSH
106147: EMPTY
106148: LIST
106149: PPUSH
106150: CALL_OW 447
106154: GO 106097
106156: POP
106157: POP
// end ;
106158: LD_VAR 0 5
106162: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106163: LD_EXP 199
106167: NOT
106168: IFFALSE 106218
106170: GO 106172
106172: DISABLE
// begin initHack := true ;
106173: LD_ADDR_EXP 199
106177: PUSH
106178: LD_INT 1
106180: ST_TO_ADDR
// hackTanks := [ ] ;
106181: LD_ADDR_EXP 200
106185: PUSH
106186: EMPTY
106187: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106188: LD_ADDR_EXP 201
106192: PUSH
106193: EMPTY
106194: ST_TO_ADDR
// hackLimit := 3 ;
106195: LD_ADDR_EXP 202
106199: PUSH
106200: LD_INT 3
106202: ST_TO_ADDR
// hackDist := 12 ;
106203: LD_ADDR_EXP 203
106207: PUSH
106208: LD_INT 12
106210: ST_TO_ADDR
// hackCounter := [ ] ;
106211: LD_ADDR_EXP 204
106215: PUSH
106216: EMPTY
106217: ST_TO_ADDR
// end ;
106218: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106219: LD_EXP 199
106223: PUSH
106224: LD_INT 34
106226: PUSH
106227: LD_EXP 76
106231: PUSH
106232: EMPTY
106233: LIST
106234: LIST
106235: PPUSH
106236: CALL_OW 69
106240: AND
106241: IFFALSE 106496
106243: GO 106245
106245: DISABLE
106246: LD_INT 0
106248: PPUSH
106249: PPUSH
// begin enable ;
106250: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106251: LD_ADDR_VAR 0 1
106255: PUSH
106256: LD_INT 34
106258: PUSH
106259: LD_EXP 76
106263: PUSH
106264: EMPTY
106265: LIST
106266: LIST
106267: PPUSH
106268: CALL_OW 69
106272: PUSH
106273: FOR_IN
106274: IFFALSE 106494
// begin if not i in hackTanks then
106276: LD_VAR 0 1
106280: PUSH
106281: LD_EXP 200
106285: IN
106286: NOT
106287: IFFALSE 106370
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106289: LD_ADDR_EXP 200
106293: PUSH
106294: LD_EXP 200
106298: PPUSH
106299: LD_EXP 200
106303: PUSH
106304: LD_INT 1
106306: PLUS
106307: PPUSH
106308: LD_VAR 0 1
106312: PPUSH
106313: CALL_OW 1
106317: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106318: LD_ADDR_EXP 201
106322: PUSH
106323: LD_EXP 201
106327: PPUSH
106328: LD_EXP 201
106332: PUSH
106333: LD_INT 1
106335: PLUS
106336: PPUSH
106337: EMPTY
106338: PPUSH
106339: CALL_OW 1
106343: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
106344: LD_ADDR_EXP 204
106348: PUSH
106349: LD_EXP 204
106353: PPUSH
106354: LD_EXP 204
106358: PUSH
106359: LD_INT 1
106361: PLUS
106362: PPUSH
106363: EMPTY
106364: PPUSH
106365: CALL_OW 1
106369: ST_TO_ADDR
// end ; if not IsOk ( i ) then
106370: LD_VAR 0 1
106374: PPUSH
106375: CALL_OW 302
106379: NOT
106380: IFFALSE 106393
// begin HackUnlinkAll ( i ) ;
106382: LD_VAR 0 1
106386: PPUSH
106387: CALL 106499 0 1
// continue ;
106391: GO 106273
// end ; HackCheckCapturedStatus ( i ) ;
106393: LD_VAR 0 1
106397: PPUSH
106398: CALL 106942 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
106402: LD_ADDR_VAR 0 2
106406: PUSH
106407: LD_INT 81
106409: PUSH
106410: LD_VAR 0 1
106414: PPUSH
106415: CALL_OW 255
106419: PUSH
106420: EMPTY
106421: LIST
106422: LIST
106423: PUSH
106424: LD_INT 33
106426: PUSH
106427: LD_INT 3
106429: PUSH
106430: EMPTY
106431: LIST
106432: LIST
106433: PUSH
106434: LD_INT 91
106436: PUSH
106437: LD_VAR 0 1
106441: PUSH
106442: LD_EXP 203
106446: PUSH
106447: EMPTY
106448: LIST
106449: LIST
106450: LIST
106451: PUSH
106452: LD_INT 50
106454: PUSH
106455: EMPTY
106456: LIST
106457: PUSH
106458: EMPTY
106459: LIST
106460: LIST
106461: LIST
106462: LIST
106463: PPUSH
106464: CALL_OW 69
106468: ST_TO_ADDR
// if not tmp then
106469: LD_VAR 0 2
106473: NOT
106474: IFFALSE 106478
// continue ;
106476: GO 106273
// HackLink ( i , tmp ) ;
106478: LD_VAR 0 1
106482: PPUSH
106483: LD_VAR 0 2
106487: PPUSH
106488: CALL 106635 0 2
// end ;
106492: GO 106273
106494: POP
106495: POP
// end ;
106496: PPOPN 2
106498: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
106499: LD_INT 0
106501: PPUSH
106502: PPUSH
106503: PPUSH
// if not hack in hackTanks then
106504: LD_VAR 0 1
106508: PUSH
106509: LD_EXP 200
106513: IN
106514: NOT
106515: IFFALSE 106519
// exit ;
106517: GO 106630
// index := GetElementIndex ( hackTanks , hack ) ;
106519: LD_ADDR_VAR 0 4
106523: PUSH
106524: LD_EXP 200
106528: PPUSH
106529: LD_VAR 0 1
106533: PPUSH
106534: CALL 56759 0 2
106538: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
106539: LD_EXP 201
106543: PUSH
106544: LD_VAR 0 4
106548: ARRAY
106549: IFFALSE 106630
// begin for i in hackTanksCaptured [ index ] do
106551: LD_ADDR_VAR 0 3
106555: PUSH
106556: LD_EXP 201
106560: PUSH
106561: LD_VAR 0 4
106565: ARRAY
106566: PUSH
106567: FOR_IN
106568: IFFALSE 106594
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
106570: LD_VAR 0 3
106574: PUSH
106575: LD_INT 1
106577: ARRAY
106578: PPUSH
106579: LD_VAR 0 3
106583: PUSH
106584: LD_INT 2
106586: ARRAY
106587: PPUSH
106588: CALL_OW 235
106592: GO 106567
106594: POP
106595: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
106596: LD_ADDR_EXP 201
106600: PUSH
106601: LD_EXP 201
106605: PPUSH
106606: LD_VAR 0 4
106610: PPUSH
106611: EMPTY
106612: PPUSH
106613: CALL_OW 1
106617: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
106618: LD_VAR 0 1
106622: PPUSH
106623: LD_INT 0
106625: PPUSH
106626: CALL_OW 505
// end ; end ;
106630: LD_VAR 0 2
106634: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
106635: LD_INT 0
106637: PPUSH
106638: PPUSH
106639: PPUSH
// if not hack in hackTanks or not vehicles then
106640: LD_VAR 0 1
106644: PUSH
106645: LD_EXP 200
106649: IN
106650: NOT
106651: PUSH
106652: LD_VAR 0 2
106656: NOT
106657: OR
106658: IFFALSE 106662
// exit ;
106660: GO 106937
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
106662: LD_ADDR_VAR 0 2
106666: PUSH
106667: LD_VAR 0 1
106671: PPUSH
106672: LD_VAR 0 2
106676: PPUSH
106677: LD_INT 1
106679: PPUSH
106680: LD_INT 1
106682: PPUSH
106683: CALL 57409 0 4
106687: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
106688: LD_ADDR_VAR 0 5
106692: PUSH
106693: LD_EXP 200
106697: PPUSH
106698: LD_VAR 0 1
106702: PPUSH
106703: CALL 56759 0 2
106707: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
106708: LD_EXP 201
106712: PUSH
106713: LD_VAR 0 5
106717: ARRAY
106718: PUSH
106719: LD_EXP 202
106723: LESS
106724: IFFALSE 106913
// begin for i := 1 to vehicles do
106726: LD_ADDR_VAR 0 4
106730: PUSH
106731: DOUBLE
106732: LD_INT 1
106734: DEC
106735: ST_TO_ADDR
106736: LD_VAR 0 2
106740: PUSH
106741: FOR_TO
106742: IFFALSE 106911
// begin if hackTanksCaptured [ index ] = hackLimit then
106744: LD_EXP 201
106748: PUSH
106749: LD_VAR 0 5
106753: ARRAY
106754: PUSH
106755: LD_EXP 202
106759: EQUAL
106760: IFFALSE 106764
// break ;
106762: GO 106911
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
106764: LD_ADDR_EXP 204
106768: PUSH
106769: LD_EXP 204
106773: PPUSH
106774: LD_VAR 0 5
106778: PPUSH
106779: LD_EXP 204
106783: PUSH
106784: LD_VAR 0 5
106788: ARRAY
106789: PUSH
106790: LD_INT 1
106792: PLUS
106793: PPUSH
106794: CALL_OW 1
106798: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
106799: LD_ADDR_EXP 201
106803: PUSH
106804: LD_EXP 201
106808: PPUSH
106809: LD_VAR 0 5
106813: PUSH
106814: LD_EXP 201
106818: PUSH
106819: LD_VAR 0 5
106823: ARRAY
106824: PUSH
106825: LD_INT 1
106827: PLUS
106828: PUSH
106829: EMPTY
106830: LIST
106831: LIST
106832: PPUSH
106833: LD_VAR 0 2
106837: PUSH
106838: LD_VAR 0 4
106842: ARRAY
106843: PUSH
106844: LD_VAR 0 2
106848: PUSH
106849: LD_VAR 0 4
106853: ARRAY
106854: PPUSH
106855: CALL_OW 255
106859: PUSH
106860: EMPTY
106861: LIST
106862: LIST
106863: PPUSH
106864: CALL 56974 0 3
106868: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
106869: LD_VAR 0 2
106873: PUSH
106874: LD_VAR 0 4
106878: ARRAY
106879: PPUSH
106880: LD_VAR 0 1
106884: PPUSH
106885: CALL_OW 255
106889: PPUSH
106890: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
106894: LD_VAR 0 2
106898: PUSH
106899: LD_VAR 0 4
106903: ARRAY
106904: PPUSH
106905: CALL_OW 141
// end ;
106909: GO 106741
106911: POP
106912: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
106913: LD_VAR 0 1
106917: PPUSH
106918: LD_EXP 201
106922: PUSH
106923: LD_VAR 0 5
106927: ARRAY
106928: PUSH
106929: LD_INT 0
106931: PLUS
106932: PPUSH
106933: CALL_OW 505
// end ;
106937: LD_VAR 0 3
106941: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
106942: LD_INT 0
106944: PPUSH
106945: PPUSH
106946: PPUSH
106947: PPUSH
// if not hack in hackTanks then
106948: LD_VAR 0 1
106952: PUSH
106953: LD_EXP 200
106957: IN
106958: NOT
106959: IFFALSE 106963
// exit ;
106961: GO 107203
// index := GetElementIndex ( hackTanks , hack ) ;
106963: LD_ADDR_VAR 0 4
106967: PUSH
106968: LD_EXP 200
106972: PPUSH
106973: LD_VAR 0 1
106977: PPUSH
106978: CALL 56759 0 2
106982: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
106983: LD_ADDR_VAR 0 3
106987: PUSH
106988: DOUBLE
106989: LD_EXP 201
106993: PUSH
106994: LD_VAR 0 4
106998: ARRAY
106999: INC
107000: ST_TO_ADDR
107001: LD_INT 1
107003: PUSH
107004: FOR_DOWNTO
107005: IFFALSE 107177
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107007: LD_ADDR_VAR 0 5
107011: PUSH
107012: LD_EXP 201
107016: PUSH
107017: LD_VAR 0 4
107021: ARRAY
107022: PUSH
107023: LD_VAR 0 3
107027: ARRAY
107028: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107029: LD_VAR 0 5
107033: PUSH
107034: LD_INT 1
107036: ARRAY
107037: PPUSH
107038: CALL_OW 302
107042: NOT
107043: PUSH
107044: LD_VAR 0 5
107048: PUSH
107049: LD_INT 1
107051: ARRAY
107052: PPUSH
107053: CALL_OW 255
107057: PUSH
107058: LD_VAR 0 1
107062: PPUSH
107063: CALL_OW 255
107067: NONEQUAL
107068: OR
107069: IFFALSE 107175
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107071: LD_VAR 0 5
107075: PUSH
107076: LD_INT 1
107078: ARRAY
107079: PPUSH
107080: CALL_OW 305
107084: PUSH
107085: LD_VAR 0 5
107089: PUSH
107090: LD_INT 1
107092: ARRAY
107093: PPUSH
107094: CALL_OW 255
107098: PUSH
107099: LD_VAR 0 1
107103: PPUSH
107104: CALL_OW 255
107108: EQUAL
107109: AND
107110: IFFALSE 107134
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107112: LD_VAR 0 5
107116: PUSH
107117: LD_INT 1
107119: ARRAY
107120: PPUSH
107121: LD_VAR 0 5
107125: PUSH
107126: LD_INT 2
107128: ARRAY
107129: PPUSH
107130: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107134: LD_ADDR_EXP 201
107138: PUSH
107139: LD_EXP 201
107143: PPUSH
107144: LD_VAR 0 4
107148: PPUSH
107149: LD_EXP 201
107153: PUSH
107154: LD_VAR 0 4
107158: ARRAY
107159: PPUSH
107160: LD_VAR 0 3
107164: PPUSH
107165: CALL_OW 3
107169: PPUSH
107170: CALL_OW 1
107174: ST_TO_ADDR
// end ; end ;
107175: GO 107004
107177: POP
107178: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107179: LD_VAR 0 1
107183: PPUSH
107184: LD_EXP 201
107188: PUSH
107189: LD_VAR 0 4
107193: ARRAY
107194: PUSH
107195: LD_INT 0
107197: PLUS
107198: PPUSH
107199: CALL_OW 505
// end ;
107203: LD_VAR 0 2
107207: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107208: LD_INT 0
107210: PPUSH
107211: PPUSH
107212: PPUSH
107213: PPUSH
// if not hack in hackTanks then
107214: LD_VAR 0 1
107218: PUSH
107219: LD_EXP 200
107223: IN
107224: NOT
107225: IFFALSE 107229
// exit ;
107227: GO 107314
// index := GetElementIndex ( hackTanks , hack ) ;
107229: LD_ADDR_VAR 0 5
107233: PUSH
107234: LD_EXP 200
107238: PPUSH
107239: LD_VAR 0 1
107243: PPUSH
107244: CALL 56759 0 2
107248: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107249: LD_ADDR_VAR 0 4
107253: PUSH
107254: DOUBLE
107255: LD_INT 1
107257: DEC
107258: ST_TO_ADDR
107259: LD_EXP 201
107263: PUSH
107264: LD_VAR 0 5
107268: ARRAY
107269: PUSH
107270: FOR_TO
107271: IFFALSE 107312
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107273: LD_EXP 201
107277: PUSH
107278: LD_VAR 0 5
107282: ARRAY
107283: PUSH
107284: LD_VAR 0 4
107288: ARRAY
107289: PUSH
107290: LD_INT 1
107292: ARRAY
107293: PUSH
107294: LD_VAR 0 2
107298: EQUAL
107299: IFFALSE 107310
// KillUnit ( vehicle ) ;
107301: LD_VAR 0 2
107305: PPUSH
107306: CALL_OW 66
107310: GO 107270
107312: POP
107313: POP
// end ;
107314: LD_VAR 0 3
107318: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107319: LD_EXP 205
107323: NOT
107324: IFFALSE 107359
107326: GO 107328
107328: DISABLE
// begin initMiner := true ;
107329: LD_ADDR_EXP 205
107333: PUSH
107334: LD_INT 1
107336: ST_TO_ADDR
// minersList := [ ] ;
107337: LD_ADDR_EXP 206
107341: PUSH
107342: EMPTY
107343: ST_TO_ADDR
// minerMinesList := [ ] ;
107344: LD_ADDR_EXP 207
107348: PUSH
107349: EMPTY
107350: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
107351: LD_ADDR_EXP 208
107355: PUSH
107356: LD_INT 5
107358: ST_TO_ADDR
// end ;
107359: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
107360: LD_EXP 205
107364: PUSH
107365: LD_INT 34
107367: PUSH
107368: LD_EXP 81
107372: PUSH
107373: EMPTY
107374: LIST
107375: LIST
107376: PPUSH
107377: CALL_OW 69
107381: AND
107382: IFFALSE 107845
107384: GO 107386
107386: DISABLE
107387: LD_INT 0
107389: PPUSH
107390: PPUSH
107391: PPUSH
107392: PPUSH
// begin enable ;
107393: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
107394: LD_ADDR_VAR 0 1
107398: PUSH
107399: LD_INT 34
107401: PUSH
107402: LD_EXP 81
107406: PUSH
107407: EMPTY
107408: LIST
107409: LIST
107410: PPUSH
107411: CALL_OW 69
107415: PUSH
107416: FOR_IN
107417: IFFALSE 107489
// begin if not i in minersList then
107419: LD_VAR 0 1
107423: PUSH
107424: LD_EXP 206
107428: IN
107429: NOT
107430: IFFALSE 107487
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
107432: LD_ADDR_EXP 206
107436: PUSH
107437: LD_EXP 206
107441: PPUSH
107442: LD_EXP 206
107446: PUSH
107447: LD_INT 1
107449: PLUS
107450: PPUSH
107451: LD_VAR 0 1
107455: PPUSH
107456: CALL_OW 1
107460: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
107461: LD_ADDR_EXP 207
107465: PUSH
107466: LD_EXP 207
107470: PPUSH
107471: LD_EXP 207
107475: PUSH
107476: LD_INT 1
107478: PLUS
107479: PPUSH
107480: EMPTY
107481: PPUSH
107482: CALL_OW 1
107486: ST_TO_ADDR
// end end ;
107487: GO 107416
107489: POP
107490: POP
// for i := minerMinesList downto 1 do
107491: LD_ADDR_VAR 0 1
107495: PUSH
107496: DOUBLE
107497: LD_EXP 207
107501: INC
107502: ST_TO_ADDR
107503: LD_INT 1
107505: PUSH
107506: FOR_DOWNTO
107507: IFFALSE 107843
// begin if IsLive ( minersList [ i ] ) then
107509: LD_EXP 206
107513: PUSH
107514: LD_VAR 0 1
107518: ARRAY
107519: PPUSH
107520: CALL_OW 300
107524: IFFALSE 107552
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
107526: LD_EXP 206
107530: PUSH
107531: LD_VAR 0 1
107535: ARRAY
107536: PPUSH
107537: LD_EXP 207
107541: PUSH
107542: LD_VAR 0 1
107546: ARRAY
107547: PPUSH
107548: CALL_OW 505
// if not minerMinesList [ i ] then
107552: LD_EXP 207
107556: PUSH
107557: LD_VAR 0 1
107561: ARRAY
107562: NOT
107563: IFFALSE 107567
// continue ;
107565: GO 107506
// for j := minerMinesList [ i ] downto 1 do
107567: LD_ADDR_VAR 0 2
107571: PUSH
107572: DOUBLE
107573: LD_EXP 207
107577: PUSH
107578: LD_VAR 0 1
107582: ARRAY
107583: INC
107584: ST_TO_ADDR
107585: LD_INT 1
107587: PUSH
107588: FOR_DOWNTO
107589: IFFALSE 107839
// begin side := GetSide ( minersList [ i ] ) ;
107591: LD_ADDR_VAR 0 3
107595: PUSH
107596: LD_EXP 206
107600: PUSH
107601: LD_VAR 0 1
107605: ARRAY
107606: PPUSH
107607: CALL_OW 255
107611: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
107612: LD_ADDR_VAR 0 4
107616: PUSH
107617: LD_EXP 207
107621: PUSH
107622: LD_VAR 0 1
107626: ARRAY
107627: PUSH
107628: LD_VAR 0 2
107632: ARRAY
107633: PUSH
107634: LD_INT 1
107636: ARRAY
107637: PPUSH
107638: LD_EXP 207
107642: PUSH
107643: LD_VAR 0 1
107647: ARRAY
107648: PUSH
107649: LD_VAR 0 2
107653: ARRAY
107654: PUSH
107655: LD_INT 2
107657: ARRAY
107658: PPUSH
107659: CALL_OW 428
107663: ST_TO_ADDR
// if not tmp then
107664: LD_VAR 0 4
107668: NOT
107669: IFFALSE 107673
// continue ;
107671: GO 107588
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
107673: LD_VAR 0 4
107677: PUSH
107678: LD_INT 81
107680: PUSH
107681: LD_VAR 0 3
107685: PUSH
107686: EMPTY
107687: LIST
107688: LIST
107689: PPUSH
107690: CALL_OW 69
107694: IN
107695: PUSH
107696: LD_EXP 207
107700: PUSH
107701: LD_VAR 0 1
107705: ARRAY
107706: PUSH
107707: LD_VAR 0 2
107711: ARRAY
107712: PUSH
107713: LD_INT 1
107715: ARRAY
107716: PPUSH
107717: LD_EXP 207
107721: PUSH
107722: LD_VAR 0 1
107726: ARRAY
107727: PUSH
107728: LD_VAR 0 2
107732: ARRAY
107733: PUSH
107734: LD_INT 2
107736: ARRAY
107737: PPUSH
107738: CALL_OW 458
107742: AND
107743: IFFALSE 107837
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
107745: LD_EXP 207
107749: PUSH
107750: LD_VAR 0 1
107754: ARRAY
107755: PUSH
107756: LD_VAR 0 2
107760: ARRAY
107761: PUSH
107762: LD_INT 1
107764: ARRAY
107765: PPUSH
107766: LD_EXP 207
107770: PUSH
107771: LD_VAR 0 1
107775: ARRAY
107776: PUSH
107777: LD_VAR 0 2
107781: ARRAY
107782: PUSH
107783: LD_INT 2
107785: ARRAY
107786: PPUSH
107787: LD_VAR 0 3
107791: PPUSH
107792: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
107796: LD_ADDR_EXP 207
107800: PUSH
107801: LD_EXP 207
107805: PPUSH
107806: LD_VAR 0 1
107810: PPUSH
107811: LD_EXP 207
107815: PUSH
107816: LD_VAR 0 1
107820: ARRAY
107821: PPUSH
107822: LD_VAR 0 2
107826: PPUSH
107827: CALL_OW 3
107831: PPUSH
107832: CALL_OW 1
107836: ST_TO_ADDR
// end ; end ;
107837: GO 107588
107839: POP
107840: POP
// end ;
107841: GO 107506
107843: POP
107844: POP
// end ;
107845: PPOPN 4
107847: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
107848: LD_INT 0
107850: PPUSH
107851: PPUSH
// result := false ;
107852: LD_ADDR_VAR 0 4
107856: PUSH
107857: LD_INT 0
107859: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
107860: LD_VAR 0 1
107864: PPUSH
107865: CALL_OW 264
107869: PUSH
107870: LD_EXP 81
107874: EQUAL
107875: NOT
107876: IFFALSE 107880
// exit ;
107878: GO 108120
// index := GetElementIndex ( minersList , unit ) ;
107880: LD_ADDR_VAR 0 5
107884: PUSH
107885: LD_EXP 206
107889: PPUSH
107890: LD_VAR 0 1
107894: PPUSH
107895: CALL 56759 0 2
107899: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
107900: LD_EXP 207
107904: PUSH
107905: LD_VAR 0 5
107909: ARRAY
107910: PUSH
107911: LD_EXP 208
107915: GREATEREQUAL
107916: IFFALSE 107920
// exit ;
107918: GO 108120
// ComMoveXY ( unit , x , y ) ;
107920: LD_VAR 0 1
107924: PPUSH
107925: LD_VAR 0 2
107929: PPUSH
107930: LD_VAR 0 3
107934: PPUSH
107935: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107939: LD_INT 35
107941: PPUSH
107942: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
107946: LD_VAR 0 1
107950: PPUSH
107951: LD_VAR 0 2
107955: PPUSH
107956: LD_VAR 0 3
107960: PPUSH
107961: CALL 87531 0 3
107965: NOT
107966: PUSH
107967: LD_VAR 0 1
107971: PPUSH
107972: CALL_OW 314
107976: AND
107977: IFFALSE 107981
// exit ;
107979: GO 108120
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
107981: LD_VAR 0 2
107985: PPUSH
107986: LD_VAR 0 3
107990: PPUSH
107991: CALL_OW 428
107995: PUSH
107996: LD_VAR 0 1
108000: EQUAL
108001: PUSH
108002: LD_VAR 0 1
108006: PPUSH
108007: CALL_OW 314
108011: NOT
108012: AND
108013: IFFALSE 107939
// PlaySoundXY ( x , y , PlantMine ) ;
108015: LD_VAR 0 2
108019: PPUSH
108020: LD_VAR 0 3
108024: PPUSH
108025: LD_STRING PlantMine
108027: PPUSH
108028: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108032: LD_VAR 0 2
108036: PPUSH
108037: LD_VAR 0 3
108041: PPUSH
108042: LD_VAR 0 1
108046: PPUSH
108047: CALL_OW 255
108051: PPUSH
108052: LD_INT 0
108054: PPUSH
108055: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108059: LD_ADDR_EXP 207
108063: PUSH
108064: LD_EXP 207
108068: PPUSH
108069: LD_VAR 0 5
108073: PUSH
108074: LD_EXP 207
108078: PUSH
108079: LD_VAR 0 5
108083: ARRAY
108084: PUSH
108085: LD_INT 1
108087: PLUS
108088: PUSH
108089: EMPTY
108090: LIST
108091: LIST
108092: PPUSH
108093: LD_VAR 0 2
108097: PUSH
108098: LD_VAR 0 3
108102: PUSH
108103: EMPTY
108104: LIST
108105: LIST
108106: PPUSH
108107: CALL 56974 0 3
108111: ST_TO_ADDR
// result := true ;
108112: LD_ADDR_VAR 0 4
108116: PUSH
108117: LD_INT 1
108119: ST_TO_ADDR
// end ;
108120: LD_VAR 0 4
108124: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108125: LD_INT 0
108127: PPUSH
108128: PPUSH
108129: PPUSH
// if not unit in minersList then
108130: LD_VAR 0 1
108134: PUSH
108135: LD_EXP 206
108139: IN
108140: NOT
108141: IFFALSE 108145
// exit ;
108143: GO 108537
// index := GetElementIndex ( minersList , unit ) ;
108145: LD_ADDR_VAR 0 6
108149: PUSH
108150: LD_EXP 206
108154: PPUSH
108155: LD_VAR 0 1
108159: PPUSH
108160: CALL 56759 0 2
108164: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108165: LD_ADDR_VAR 0 5
108169: PUSH
108170: DOUBLE
108171: LD_EXP 207
108175: PUSH
108176: LD_VAR 0 6
108180: ARRAY
108181: INC
108182: ST_TO_ADDR
108183: LD_INT 1
108185: PUSH
108186: FOR_DOWNTO
108187: IFFALSE 108348
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108189: LD_EXP 207
108193: PUSH
108194: LD_VAR 0 6
108198: ARRAY
108199: PUSH
108200: LD_VAR 0 5
108204: ARRAY
108205: PUSH
108206: LD_INT 1
108208: ARRAY
108209: PUSH
108210: LD_VAR 0 2
108214: EQUAL
108215: PUSH
108216: LD_EXP 207
108220: PUSH
108221: LD_VAR 0 6
108225: ARRAY
108226: PUSH
108227: LD_VAR 0 5
108231: ARRAY
108232: PUSH
108233: LD_INT 2
108235: ARRAY
108236: PUSH
108237: LD_VAR 0 3
108241: EQUAL
108242: AND
108243: IFFALSE 108346
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108245: LD_EXP 207
108249: PUSH
108250: LD_VAR 0 6
108254: ARRAY
108255: PUSH
108256: LD_VAR 0 5
108260: ARRAY
108261: PUSH
108262: LD_INT 1
108264: ARRAY
108265: PPUSH
108266: LD_EXP 207
108270: PUSH
108271: LD_VAR 0 6
108275: ARRAY
108276: PUSH
108277: LD_VAR 0 5
108281: ARRAY
108282: PUSH
108283: LD_INT 2
108285: ARRAY
108286: PPUSH
108287: LD_VAR 0 1
108291: PPUSH
108292: CALL_OW 255
108296: PPUSH
108297: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108301: LD_ADDR_EXP 207
108305: PUSH
108306: LD_EXP 207
108310: PPUSH
108311: LD_VAR 0 6
108315: PPUSH
108316: LD_EXP 207
108320: PUSH
108321: LD_VAR 0 6
108325: ARRAY
108326: PPUSH
108327: LD_VAR 0 5
108331: PPUSH
108332: CALL_OW 3
108336: PPUSH
108337: CALL_OW 1
108341: ST_TO_ADDR
// exit ;
108342: POP
108343: POP
108344: GO 108537
// end ; end ;
108346: GO 108186
108348: POP
108349: POP
// for i := minerMinesList [ index ] downto 1 do
108350: LD_ADDR_VAR 0 5
108354: PUSH
108355: DOUBLE
108356: LD_EXP 207
108360: PUSH
108361: LD_VAR 0 6
108365: ARRAY
108366: INC
108367: ST_TO_ADDR
108368: LD_INT 1
108370: PUSH
108371: FOR_DOWNTO
108372: IFFALSE 108535
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
108374: LD_EXP 207
108378: PUSH
108379: LD_VAR 0 6
108383: ARRAY
108384: PUSH
108385: LD_VAR 0 5
108389: ARRAY
108390: PUSH
108391: LD_INT 1
108393: ARRAY
108394: PPUSH
108395: LD_EXP 207
108399: PUSH
108400: LD_VAR 0 6
108404: ARRAY
108405: PUSH
108406: LD_VAR 0 5
108410: ARRAY
108411: PUSH
108412: LD_INT 2
108414: ARRAY
108415: PPUSH
108416: LD_VAR 0 2
108420: PPUSH
108421: LD_VAR 0 3
108425: PPUSH
108426: CALL_OW 298
108430: PUSH
108431: LD_INT 6
108433: LESS
108434: IFFALSE 108533
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108436: LD_EXP 207
108440: PUSH
108441: LD_VAR 0 6
108445: ARRAY
108446: PUSH
108447: LD_VAR 0 5
108451: ARRAY
108452: PUSH
108453: LD_INT 1
108455: ARRAY
108456: PPUSH
108457: LD_EXP 207
108461: PUSH
108462: LD_VAR 0 6
108466: ARRAY
108467: PUSH
108468: LD_VAR 0 5
108472: ARRAY
108473: PUSH
108474: LD_INT 2
108476: ARRAY
108477: PPUSH
108478: LD_VAR 0 1
108482: PPUSH
108483: CALL_OW 255
108487: PPUSH
108488: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108492: LD_ADDR_EXP 207
108496: PUSH
108497: LD_EXP 207
108501: PPUSH
108502: LD_VAR 0 6
108506: PPUSH
108507: LD_EXP 207
108511: PUSH
108512: LD_VAR 0 6
108516: ARRAY
108517: PPUSH
108518: LD_VAR 0 5
108522: PPUSH
108523: CALL_OW 3
108527: PPUSH
108528: CALL_OW 1
108532: ST_TO_ADDR
// end ; end ;
108533: GO 108371
108535: POP
108536: POP
// end ;
108537: LD_VAR 0 4
108541: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
108542: LD_INT 0
108544: PPUSH
108545: PPUSH
108546: PPUSH
108547: PPUSH
108548: PPUSH
108549: PPUSH
108550: PPUSH
108551: PPUSH
108552: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
108553: LD_VAR 0 1
108557: PPUSH
108558: CALL_OW 264
108562: PUSH
108563: LD_EXP 81
108567: EQUAL
108568: NOT
108569: PUSH
108570: LD_VAR 0 1
108574: PUSH
108575: LD_EXP 206
108579: IN
108580: NOT
108581: OR
108582: IFFALSE 108586
// exit ;
108584: GO 108908
// index := GetElementIndex ( minersList , unit ) ;
108586: LD_ADDR_VAR 0 6
108590: PUSH
108591: LD_EXP 206
108595: PPUSH
108596: LD_VAR 0 1
108600: PPUSH
108601: CALL 56759 0 2
108605: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
108606: LD_ADDR_VAR 0 8
108610: PUSH
108611: LD_EXP 208
108615: PUSH
108616: LD_EXP 207
108620: PUSH
108621: LD_VAR 0 6
108625: ARRAY
108626: MINUS
108627: ST_TO_ADDR
// if not minesFreeAmount then
108628: LD_VAR 0 8
108632: NOT
108633: IFFALSE 108637
// exit ;
108635: GO 108908
// tmp := [ ] ;
108637: LD_ADDR_VAR 0 7
108641: PUSH
108642: EMPTY
108643: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
108644: LD_ADDR_VAR 0 5
108648: PUSH
108649: DOUBLE
108650: LD_INT 1
108652: DEC
108653: ST_TO_ADDR
108654: LD_VAR 0 8
108658: PUSH
108659: FOR_TO
108660: IFFALSE 108855
// begin _d := rand ( 0 , 5 ) ;
108662: LD_ADDR_VAR 0 11
108666: PUSH
108667: LD_INT 0
108669: PPUSH
108670: LD_INT 5
108672: PPUSH
108673: CALL_OW 12
108677: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
108678: LD_ADDR_VAR 0 12
108682: PUSH
108683: LD_INT 2
108685: PPUSH
108686: LD_INT 6
108688: PPUSH
108689: CALL_OW 12
108693: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
108694: LD_ADDR_VAR 0 9
108698: PUSH
108699: LD_VAR 0 2
108703: PPUSH
108704: LD_VAR 0 11
108708: PPUSH
108709: LD_VAR 0 12
108713: PPUSH
108714: CALL_OW 272
108718: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
108719: LD_ADDR_VAR 0 10
108723: PUSH
108724: LD_VAR 0 3
108728: PPUSH
108729: LD_VAR 0 11
108733: PPUSH
108734: LD_VAR 0 12
108738: PPUSH
108739: CALL_OW 273
108743: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
108744: LD_VAR 0 9
108748: PPUSH
108749: LD_VAR 0 10
108753: PPUSH
108754: CALL_OW 488
108758: PUSH
108759: LD_VAR 0 9
108763: PUSH
108764: LD_VAR 0 10
108768: PUSH
108769: EMPTY
108770: LIST
108771: LIST
108772: PUSH
108773: LD_VAR 0 7
108777: IN
108778: NOT
108779: AND
108780: PUSH
108781: LD_VAR 0 9
108785: PPUSH
108786: LD_VAR 0 10
108790: PPUSH
108791: CALL_OW 458
108795: NOT
108796: AND
108797: IFFALSE 108839
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
108799: LD_ADDR_VAR 0 7
108803: PUSH
108804: LD_VAR 0 7
108808: PPUSH
108809: LD_VAR 0 7
108813: PUSH
108814: LD_INT 1
108816: PLUS
108817: PPUSH
108818: LD_VAR 0 9
108822: PUSH
108823: LD_VAR 0 10
108827: PUSH
108828: EMPTY
108829: LIST
108830: LIST
108831: PPUSH
108832: CALL_OW 1
108836: ST_TO_ADDR
108837: GO 108853
// i := i - 1 ;
108839: LD_ADDR_VAR 0 5
108843: PUSH
108844: LD_VAR 0 5
108848: PUSH
108849: LD_INT 1
108851: MINUS
108852: ST_TO_ADDR
// end ;
108853: GO 108659
108855: POP
108856: POP
// for i in tmp do
108857: LD_ADDR_VAR 0 5
108861: PUSH
108862: LD_VAR 0 7
108866: PUSH
108867: FOR_IN
108868: IFFALSE 108906
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
108870: LD_VAR 0 1
108874: PPUSH
108875: LD_VAR 0 5
108879: PUSH
108880: LD_INT 1
108882: ARRAY
108883: PPUSH
108884: LD_VAR 0 5
108888: PUSH
108889: LD_INT 2
108891: ARRAY
108892: PPUSH
108893: CALL 107848 0 3
108897: NOT
108898: IFFALSE 108904
// exit ;
108900: POP
108901: POP
108902: GO 108908
108904: GO 108867
108906: POP
108907: POP
// end ;
108908: LD_VAR 0 4
108912: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
108913: LD_INT 0
108915: PPUSH
108916: PPUSH
108917: PPUSH
108918: PPUSH
108919: PPUSH
108920: PPUSH
108921: PPUSH
// if not GetClass ( unit ) = class_sniper then
108922: LD_VAR 0 1
108926: PPUSH
108927: CALL_OW 257
108931: PUSH
108932: LD_INT 5
108934: EQUAL
108935: NOT
108936: IFFALSE 108940
// exit ;
108938: GO 109328
// dist := 8 ;
108940: LD_ADDR_VAR 0 5
108944: PUSH
108945: LD_INT 8
108947: ST_TO_ADDR
// viewRange := 12 ;
108948: LD_ADDR_VAR 0 7
108952: PUSH
108953: LD_INT 12
108955: ST_TO_ADDR
// side := GetSide ( unit ) ;
108956: LD_ADDR_VAR 0 6
108960: PUSH
108961: LD_VAR 0 1
108965: PPUSH
108966: CALL_OW 255
108970: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
108971: LD_INT 61
108973: PPUSH
108974: LD_VAR 0 6
108978: PPUSH
108979: CALL_OW 321
108983: PUSH
108984: LD_INT 2
108986: EQUAL
108987: IFFALSE 108997
// viewRange := 16 ;
108989: LD_ADDR_VAR 0 7
108993: PUSH
108994: LD_INT 16
108996: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
108997: LD_VAR 0 1
109001: PPUSH
109002: LD_VAR 0 2
109006: PPUSH
109007: LD_VAR 0 3
109011: PPUSH
109012: CALL_OW 297
109016: PUSH
109017: LD_VAR 0 5
109021: GREATER
109022: IFFALSE 109101
// begin ComMoveXY ( unit , x , y ) ;
109024: LD_VAR 0 1
109028: PPUSH
109029: LD_VAR 0 2
109033: PPUSH
109034: LD_VAR 0 3
109038: PPUSH
109039: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109043: LD_INT 35
109045: PPUSH
109046: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109050: LD_VAR 0 1
109054: PPUSH
109055: LD_VAR 0 2
109059: PPUSH
109060: LD_VAR 0 3
109064: PPUSH
109065: CALL 87531 0 3
109069: NOT
109070: IFFALSE 109074
// exit ;
109072: GO 109328
// until GetDistUnitXY ( unit , x , y ) < dist ;
109074: LD_VAR 0 1
109078: PPUSH
109079: LD_VAR 0 2
109083: PPUSH
109084: LD_VAR 0 3
109088: PPUSH
109089: CALL_OW 297
109093: PUSH
109094: LD_VAR 0 5
109098: LESS
109099: IFFALSE 109043
// end ; ComTurnXY ( unit , x , y ) ;
109101: LD_VAR 0 1
109105: PPUSH
109106: LD_VAR 0 2
109110: PPUSH
109111: LD_VAR 0 3
109115: PPUSH
109116: CALL_OW 118
// wait ( 5 ) ;
109120: LD_INT 5
109122: PPUSH
109123: CALL_OW 67
// _d := GetDir ( unit ) ;
109127: LD_ADDR_VAR 0 10
109131: PUSH
109132: LD_VAR 0 1
109136: PPUSH
109137: CALL_OW 254
109141: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109142: LD_ADDR_VAR 0 8
109146: PUSH
109147: LD_VAR 0 1
109151: PPUSH
109152: CALL_OW 250
109156: PPUSH
109157: LD_VAR 0 10
109161: PPUSH
109162: LD_VAR 0 5
109166: PPUSH
109167: CALL_OW 272
109171: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109172: LD_ADDR_VAR 0 9
109176: PUSH
109177: LD_VAR 0 1
109181: PPUSH
109182: CALL_OW 251
109186: PPUSH
109187: LD_VAR 0 10
109191: PPUSH
109192: LD_VAR 0 5
109196: PPUSH
109197: CALL_OW 273
109201: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109202: LD_VAR 0 8
109206: PPUSH
109207: LD_VAR 0 9
109211: PPUSH
109212: CALL_OW 488
109216: NOT
109217: IFFALSE 109221
// exit ;
109219: GO 109328
// ComAnimCustom ( unit , 1 ) ;
109221: LD_VAR 0 1
109225: PPUSH
109226: LD_INT 1
109228: PPUSH
109229: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109233: LD_VAR 0 8
109237: PPUSH
109238: LD_VAR 0 9
109242: PPUSH
109243: LD_VAR 0 6
109247: PPUSH
109248: LD_VAR 0 7
109252: PPUSH
109253: CALL_OW 330
// repeat wait ( 1 ) ;
109257: LD_INT 1
109259: PPUSH
109260: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109264: LD_VAR 0 1
109268: PPUSH
109269: CALL_OW 316
109273: PUSH
109274: LD_VAR 0 1
109278: PPUSH
109279: CALL_OW 314
109283: OR
109284: PUSH
109285: LD_VAR 0 1
109289: PPUSH
109290: CALL_OW 302
109294: NOT
109295: OR
109296: PUSH
109297: LD_VAR 0 1
109301: PPUSH
109302: CALL_OW 301
109306: OR
109307: IFFALSE 109257
// RemoveSeeing ( _x , _y , side ) ;
109309: LD_VAR 0 8
109313: PPUSH
109314: LD_VAR 0 9
109318: PPUSH
109319: LD_VAR 0 6
109323: PPUSH
109324: CALL_OW 331
// end ; end_of_file
109328: LD_VAR 0 4
109332: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109333: LD_INT 0
109335: PPUSH
109336: PPUSH
109337: PPUSH
109338: PPUSH
109339: PPUSH
109340: PPUSH
109341: PPUSH
109342: PPUSH
109343: PPUSH
109344: PPUSH
109345: PPUSH
109346: PPUSH
109347: PPUSH
109348: PPUSH
109349: PPUSH
109350: PPUSH
109351: PPUSH
109352: PPUSH
109353: PPUSH
109354: PPUSH
109355: PPUSH
109356: PPUSH
109357: PPUSH
109358: PPUSH
109359: PPUSH
109360: PPUSH
109361: PPUSH
109362: PPUSH
109363: PPUSH
109364: PPUSH
109365: PPUSH
109366: PPUSH
109367: PPUSH
109368: PPUSH
// if not list then
109369: LD_VAR 0 1
109373: NOT
109374: IFFALSE 109378
// exit ;
109376: GO 114037
// base := list [ 1 ] ;
109378: LD_ADDR_VAR 0 3
109382: PUSH
109383: LD_VAR 0 1
109387: PUSH
109388: LD_INT 1
109390: ARRAY
109391: ST_TO_ADDR
// group := list [ 2 ] ;
109392: LD_ADDR_VAR 0 4
109396: PUSH
109397: LD_VAR 0 1
109401: PUSH
109402: LD_INT 2
109404: ARRAY
109405: ST_TO_ADDR
// path := list [ 3 ] ;
109406: LD_ADDR_VAR 0 5
109410: PUSH
109411: LD_VAR 0 1
109415: PUSH
109416: LD_INT 3
109418: ARRAY
109419: ST_TO_ADDR
// flags := list [ 4 ] ;
109420: LD_ADDR_VAR 0 6
109424: PUSH
109425: LD_VAR 0 1
109429: PUSH
109430: LD_INT 4
109432: ARRAY
109433: ST_TO_ADDR
// mined := [ ] ;
109434: LD_ADDR_VAR 0 27
109438: PUSH
109439: EMPTY
109440: ST_TO_ADDR
// bombed := [ ] ;
109441: LD_ADDR_VAR 0 28
109445: PUSH
109446: EMPTY
109447: ST_TO_ADDR
// healers := [ ] ;
109448: LD_ADDR_VAR 0 31
109452: PUSH
109453: EMPTY
109454: ST_TO_ADDR
// to_heal := [ ] ;
109455: LD_ADDR_VAR 0 30
109459: PUSH
109460: EMPTY
109461: ST_TO_ADDR
// repairs := [ ] ;
109462: LD_ADDR_VAR 0 33
109466: PUSH
109467: EMPTY
109468: ST_TO_ADDR
// to_repair := [ ] ;
109469: LD_ADDR_VAR 0 32
109473: PUSH
109474: EMPTY
109475: ST_TO_ADDR
// if not group or not path then
109476: LD_VAR 0 4
109480: NOT
109481: PUSH
109482: LD_VAR 0 5
109486: NOT
109487: OR
109488: IFFALSE 109492
// exit ;
109490: GO 114037
// side := GetSide ( group [ 1 ] ) ;
109492: LD_ADDR_VAR 0 35
109496: PUSH
109497: LD_VAR 0 4
109501: PUSH
109502: LD_INT 1
109504: ARRAY
109505: PPUSH
109506: CALL_OW 255
109510: ST_TO_ADDR
// if flags then
109511: LD_VAR 0 6
109515: IFFALSE 109659
// begin f_ignore_area := flags [ 1 ] ;
109517: LD_ADDR_VAR 0 17
109521: PUSH
109522: LD_VAR 0 6
109526: PUSH
109527: LD_INT 1
109529: ARRAY
109530: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
109531: LD_ADDR_VAR 0 18
109535: PUSH
109536: LD_VAR 0 6
109540: PUSH
109541: LD_INT 2
109543: ARRAY
109544: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
109545: LD_ADDR_VAR 0 19
109549: PUSH
109550: LD_VAR 0 6
109554: PUSH
109555: LD_INT 3
109557: ARRAY
109558: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
109559: LD_ADDR_VAR 0 20
109563: PUSH
109564: LD_VAR 0 6
109568: PUSH
109569: LD_INT 4
109571: ARRAY
109572: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
109573: LD_ADDR_VAR 0 21
109577: PUSH
109578: LD_VAR 0 6
109582: PUSH
109583: LD_INT 5
109585: ARRAY
109586: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
109587: LD_ADDR_VAR 0 22
109591: PUSH
109592: LD_VAR 0 6
109596: PUSH
109597: LD_INT 6
109599: ARRAY
109600: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
109601: LD_ADDR_VAR 0 23
109605: PUSH
109606: LD_VAR 0 6
109610: PUSH
109611: LD_INT 7
109613: ARRAY
109614: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
109615: LD_ADDR_VAR 0 24
109619: PUSH
109620: LD_VAR 0 6
109624: PUSH
109625: LD_INT 8
109627: ARRAY
109628: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
109629: LD_ADDR_VAR 0 25
109633: PUSH
109634: LD_VAR 0 6
109638: PUSH
109639: LD_INT 9
109641: ARRAY
109642: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
109643: LD_ADDR_VAR 0 26
109647: PUSH
109648: LD_VAR 0 6
109652: PUSH
109653: LD_INT 10
109655: ARRAY
109656: ST_TO_ADDR
// end else
109657: GO 109739
// begin f_ignore_area := false ;
109659: LD_ADDR_VAR 0 17
109663: PUSH
109664: LD_INT 0
109666: ST_TO_ADDR
// f_capture := false ;
109667: LD_ADDR_VAR 0 18
109671: PUSH
109672: LD_INT 0
109674: ST_TO_ADDR
// f_ignore_civ := false ;
109675: LD_ADDR_VAR 0 19
109679: PUSH
109680: LD_INT 0
109682: ST_TO_ADDR
// f_murder := false ;
109683: LD_ADDR_VAR 0 20
109687: PUSH
109688: LD_INT 0
109690: ST_TO_ADDR
// f_mines := false ;
109691: LD_ADDR_VAR 0 21
109695: PUSH
109696: LD_INT 0
109698: ST_TO_ADDR
// f_repair := false ;
109699: LD_ADDR_VAR 0 22
109703: PUSH
109704: LD_INT 0
109706: ST_TO_ADDR
// f_heal := false ;
109707: LD_ADDR_VAR 0 23
109711: PUSH
109712: LD_INT 0
109714: ST_TO_ADDR
// f_spacetime := false ;
109715: LD_ADDR_VAR 0 24
109719: PUSH
109720: LD_INT 0
109722: ST_TO_ADDR
// f_attack_depot := false ;
109723: LD_ADDR_VAR 0 25
109727: PUSH
109728: LD_INT 0
109730: ST_TO_ADDR
// f_crawl := false ;
109731: LD_ADDR_VAR 0 26
109735: PUSH
109736: LD_INT 0
109738: ST_TO_ADDR
// end ; if f_heal then
109739: LD_VAR 0 23
109743: IFFALSE 109770
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
109745: LD_ADDR_VAR 0 31
109749: PUSH
109750: LD_VAR 0 4
109754: PPUSH
109755: LD_INT 25
109757: PUSH
109758: LD_INT 4
109760: PUSH
109761: EMPTY
109762: LIST
109763: LIST
109764: PPUSH
109765: CALL_OW 72
109769: ST_TO_ADDR
// if f_repair then
109770: LD_VAR 0 22
109774: IFFALSE 109801
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
109776: LD_ADDR_VAR 0 33
109780: PUSH
109781: LD_VAR 0 4
109785: PPUSH
109786: LD_INT 25
109788: PUSH
109789: LD_INT 3
109791: PUSH
109792: EMPTY
109793: LIST
109794: LIST
109795: PPUSH
109796: CALL_OW 72
109800: ST_TO_ADDR
// units_path := [ ] ;
109801: LD_ADDR_VAR 0 16
109805: PUSH
109806: EMPTY
109807: ST_TO_ADDR
// for i = 1 to group do
109808: LD_ADDR_VAR 0 7
109812: PUSH
109813: DOUBLE
109814: LD_INT 1
109816: DEC
109817: ST_TO_ADDR
109818: LD_VAR 0 4
109822: PUSH
109823: FOR_TO
109824: IFFALSE 109853
// units_path := Replace ( units_path , i , path ) ;
109826: LD_ADDR_VAR 0 16
109830: PUSH
109831: LD_VAR 0 16
109835: PPUSH
109836: LD_VAR 0 7
109840: PPUSH
109841: LD_VAR 0 5
109845: PPUSH
109846: CALL_OW 1
109850: ST_TO_ADDR
109851: GO 109823
109853: POP
109854: POP
// repeat for i = group downto 1 do
109855: LD_ADDR_VAR 0 7
109859: PUSH
109860: DOUBLE
109861: LD_VAR 0 4
109865: INC
109866: ST_TO_ADDR
109867: LD_INT 1
109869: PUSH
109870: FOR_DOWNTO
109871: IFFALSE 113993
// begin wait ( 5 ) ;
109873: LD_INT 5
109875: PPUSH
109876: CALL_OW 67
// tmp := [ ] ;
109880: LD_ADDR_VAR 0 14
109884: PUSH
109885: EMPTY
109886: ST_TO_ADDR
// attacking := false ;
109887: LD_ADDR_VAR 0 29
109891: PUSH
109892: LD_INT 0
109894: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
109895: LD_VAR 0 4
109899: PUSH
109900: LD_VAR 0 7
109904: ARRAY
109905: PPUSH
109906: CALL_OW 301
109910: PUSH
109911: LD_VAR 0 4
109915: PUSH
109916: LD_VAR 0 7
109920: ARRAY
109921: NOT
109922: OR
109923: IFFALSE 110032
// begin if GetType ( group [ i ] ) = unit_human then
109925: LD_VAR 0 4
109929: PUSH
109930: LD_VAR 0 7
109934: ARRAY
109935: PPUSH
109936: CALL_OW 247
109940: PUSH
109941: LD_INT 1
109943: EQUAL
109944: IFFALSE 109990
// begin to_heal := to_heal diff group [ i ] ;
109946: LD_ADDR_VAR 0 30
109950: PUSH
109951: LD_VAR 0 30
109955: PUSH
109956: LD_VAR 0 4
109960: PUSH
109961: LD_VAR 0 7
109965: ARRAY
109966: DIFF
109967: ST_TO_ADDR
// healers := healers diff group [ i ] ;
109968: LD_ADDR_VAR 0 31
109972: PUSH
109973: LD_VAR 0 31
109977: PUSH
109978: LD_VAR 0 4
109982: PUSH
109983: LD_VAR 0 7
109987: ARRAY
109988: DIFF
109989: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
109990: LD_ADDR_VAR 0 4
109994: PUSH
109995: LD_VAR 0 4
109999: PPUSH
110000: LD_VAR 0 7
110004: PPUSH
110005: CALL_OW 3
110009: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110010: LD_ADDR_VAR 0 16
110014: PUSH
110015: LD_VAR 0 16
110019: PPUSH
110020: LD_VAR 0 7
110024: PPUSH
110025: CALL_OW 3
110029: ST_TO_ADDR
// continue ;
110030: GO 109870
// end ; if f_repair then
110032: LD_VAR 0 22
110036: IFFALSE 110525
// begin if GetType ( group [ i ] ) = unit_vehicle then
110038: LD_VAR 0 4
110042: PUSH
110043: LD_VAR 0 7
110047: ARRAY
110048: PPUSH
110049: CALL_OW 247
110053: PUSH
110054: LD_INT 2
110056: EQUAL
110057: IFFALSE 110247
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110059: LD_VAR 0 4
110063: PUSH
110064: LD_VAR 0 7
110068: ARRAY
110069: PPUSH
110070: CALL_OW 256
110074: PUSH
110075: LD_INT 700
110077: LESS
110078: PUSH
110079: LD_VAR 0 4
110083: PUSH
110084: LD_VAR 0 7
110088: ARRAY
110089: PUSH
110090: LD_VAR 0 32
110094: IN
110095: NOT
110096: AND
110097: IFFALSE 110121
// to_repair := to_repair union group [ i ] ;
110099: LD_ADDR_VAR 0 32
110103: PUSH
110104: LD_VAR 0 32
110108: PUSH
110109: LD_VAR 0 4
110113: PUSH
110114: LD_VAR 0 7
110118: ARRAY
110119: UNION
110120: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110121: LD_VAR 0 4
110125: PUSH
110126: LD_VAR 0 7
110130: ARRAY
110131: PPUSH
110132: CALL_OW 256
110136: PUSH
110137: LD_INT 1000
110139: EQUAL
110140: PUSH
110141: LD_VAR 0 4
110145: PUSH
110146: LD_VAR 0 7
110150: ARRAY
110151: PUSH
110152: LD_VAR 0 32
110156: IN
110157: AND
110158: IFFALSE 110182
// to_repair := to_repair diff group [ i ] ;
110160: LD_ADDR_VAR 0 32
110164: PUSH
110165: LD_VAR 0 32
110169: PUSH
110170: LD_VAR 0 4
110174: PUSH
110175: LD_VAR 0 7
110179: ARRAY
110180: DIFF
110181: ST_TO_ADDR
// if group [ i ] in to_repair then
110182: LD_VAR 0 4
110186: PUSH
110187: LD_VAR 0 7
110191: ARRAY
110192: PUSH
110193: LD_VAR 0 32
110197: IN
110198: IFFALSE 110245
// begin if not IsInArea ( group [ i ] , f_repair ) then
110200: LD_VAR 0 4
110204: PUSH
110205: LD_VAR 0 7
110209: ARRAY
110210: PPUSH
110211: LD_VAR 0 22
110215: PPUSH
110216: CALL_OW 308
110220: NOT
110221: IFFALSE 110243
// ComMoveToArea ( group [ i ] , f_repair ) ;
110223: LD_VAR 0 4
110227: PUSH
110228: LD_VAR 0 7
110232: ARRAY
110233: PPUSH
110234: LD_VAR 0 22
110238: PPUSH
110239: CALL_OW 113
// continue ;
110243: GO 109870
// end ; end else
110245: GO 110525
// if group [ i ] in repairs then
110247: LD_VAR 0 4
110251: PUSH
110252: LD_VAR 0 7
110256: ARRAY
110257: PUSH
110258: LD_VAR 0 33
110262: IN
110263: IFFALSE 110525
// begin if IsInUnit ( group [ i ] ) then
110265: LD_VAR 0 4
110269: PUSH
110270: LD_VAR 0 7
110274: ARRAY
110275: PPUSH
110276: CALL_OW 310
110280: IFFALSE 110348
// begin z := IsInUnit ( group [ i ] ) ;
110282: LD_ADDR_VAR 0 13
110286: PUSH
110287: LD_VAR 0 4
110291: PUSH
110292: LD_VAR 0 7
110296: ARRAY
110297: PPUSH
110298: CALL_OW 310
110302: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110303: LD_VAR 0 13
110307: PUSH
110308: LD_VAR 0 32
110312: IN
110313: PUSH
110314: LD_VAR 0 13
110318: PPUSH
110319: LD_VAR 0 22
110323: PPUSH
110324: CALL_OW 308
110328: AND
110329: IFFALSE 110346
// ComExitVehicle ( group [ i ] ) ;
110331: LD_VAR 0 4
110335: PUSH
110336: LD_VAR 0 7
110340: ARRAY
110341: PPUSH
110342: CALL_OW 121
// end else
110346: GO 110525
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
110348: LD_ADDR_VAR 0 13
110352: PUSH
110353: LD_VAR 0 4
110357: PPUSH
110358: LD_INT 95
110360: PUSH
110361: LD_VAR 0 22
110365: PUSH
110366: EMPTY
110367: LIST
110368: LIST
110369: PUSH
110370: LD_INT 58
110372: PUSH
110373: EMPTY
110374: LIST
110375: PUSH
110376: EMPTY
110377: LIST
110378: LIST
110379: PPUSH
110380: CALL_OW 72
110384: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
110385: LD_VAR 0 4
110389: PUSH
110390: LD_VAR 0 7
110394: ARRAY
110395: PPUSH
110396: CALL_OW 314
110400: NOT
110401: IFFALSE 110523
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
110403: LD_ADDR_VAR 0 10
110407: PUSH
110408: LD_VAR 0 13
110412: PPUSH
110413: LD_VAR 0 4
110417: PUSH
110418: LD_VAR 0 7
110422: ARRAY
110423: PPUSH
110424: CALL_OW 74
110428: ST_TO_ADDR
// if not x then
110429: LD_VAR 0 10
110433: NOT
110434: IFFALSE 110438
// continue ;
110436: GO 109870
// if GetLives ( x ) < 1000 then
110438: LD_VAR 0 10
110442: PPUSH
110443: CALL_OW 256
110447: PUSH
110448: LD_INT 1000
110450: LESS
110451: IFFALSE 110475
// ComRepairVehicle ( group [ i ] , x ) else
110453: LD_VAR 0 4
110457: PUSH
110458: LD_VAR 0 7
110462: ARRAY
110463: PPUSH
110464: LD_VAR 0 10
110468: PPUSH
110469: CALL_OW 129
110473: GO 110523
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
110475: LD_VAR 0 23
110479: PUSH
110480: LD_VAR 0 4
110484: PUSH
110485: LD_VAR 0 7
110489: ARRAY
110490: PPUSH
110491: CALL_OW 256
110495: PUSH
110496: LD_INT 1000
110498: LESS
110499: AND
110500: NOT
110501: IFFALSE 110523
// ComEnterUnit ( group [ i ] , x ) ;
110503: LD_VAR 0 4
110507: PUSH
110508: LD_VAR 0 7
110512: ARRAY
110513: PPUSH
110514: LD_VAR 0 10
110518: PPUSH
110519: CALL_OW 120
// end ; continue ;
110523: GO 109870
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
110525: LD_VAR 0 23
110529: PUSH
110530: LD_VAR 0 4
110534: PUSH
110535: LD_VAR 0 7
110539: ARRAY
110540: PPUSH
110541: CALL_OW 247
110545: PUSH
110546: LD_INT 1
110548: EQUAL
110549: AND
110550: IFFALSE 111028
// begin if group [ i ] in healers then
110552: LD_VAR 0 4
110556: PUSH
110557: LD_VAR 0 7
110561: ARRAY
110562: PUSH
110563: LD_VAR 0 31
110567: IN
110568: IFFALSE 110841
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
110570: LD_VAR 0 4
110574: PUSH
110575: LD_VAR 0 7
110579: ARRAY
110580: PPUSH
110581: LD_VAR 0 23
110585: PPUSH
110586: CALL_OW 308
110590: NOT
110591: PUSH
110592: LD_VAR 0 4
110596: PUSH
110597: LD_VAR 0 7
110601: ARRAY
110602: PPUSH
110603: CALL_OW 314
110607: NOT
110608: AND
110609: IFFALSE 110633
// ComMoveToArea ( group [ i ] , f_heal ) else
110611: LD_VAR 0 4
110615: PUSH
110616: LD_VAR 0 7
110620: ARRAY
110621: PPUSH
110622: LD_VAR 0 23
110626: PPUSH
110627: CALL_OW 113
110631: GO 110839
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
110633: LD_VAR 0 4
110637: PUSH
110638: LD_VAR 0 7
110642: ARRAY
110643: PPUSH
110644: CALL 86054 0 1
110648: PPUSH
110649: CALL_OW 256
110653: PUSH
110654: LD_INT 1000
110656: EQUAL
110657: IFFALSE 110676
// ComStop ( group [ i ] ) else
110659: LD_VAR 0 4
110663: PUSH
110664: LD_VAR 0 7
110668: ARRAY
110669: PPUSH
110670: CALL_OW 141
110674: GO 110839
// if not HasTask ( group [ i ] ) and to_heal then
110676: LD_VAR 0 4
110680: PUSH
110681: LD_VAR 0 7
110685: ARRAY
110686: PPUSH
110687: CALL_OW 314
110691: NOT
110692: PUSH
110693: LD_VAR 0 30
110697: AND
110698: IFFALSE 110839
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
110700: LD_ADDR_VAR 0 13
110704: PUSH
110705: LD_VAR 0 30
110709: PPUSH
110710: LD_INT 3
110712: PUSH
110713: LD_INT 54
110715: PUSH
110716: EMPTY
110717: LIST
110718: PUSH
110719: EMPTY
110720: LIST
110721: LIST
110722: PPUSH
110723: CALL_OW 72
110727: PPUSH
110728: LD_VAR 0 4
110732: PUSH
110733: LD_VAR 0 7
110737: ARRAY
110738: PPUSH
110739: CALL_OW 74
110743: ST_TO_ADDR
// if z then
110744: LD_VAR 0 13
110748: IFFALSE 110839
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
110750: LD_INT 91
110752: PUSH
110753: LD_VAR 0 13
110757: PUSH
110758: LD_INT 10
110760: PUSH
110761: EMPTY
110762: LIST
110763: LIST
110764: LIST
110765: PUSH
110766: LD_INT 81
110768: PUSH
110769: LD_VAR 0 13
110773: PPUSH
110774: CALL_OW 255
110778: PUSH
110779: EMPTY
110780: LIST
110781: LIST
110782: PUSH
110783: EMPTY
110784: LIST
110785: LIST
110786: PPUSH
110787: CALL_OW 69
110791: PUSH
110792: LD_INT 0
110794: EQUAL
110795: IFFALSE 110819
// ComHeal ( group [ i ] , z ) else
110797: LD_VAR 0 4
110801: PUSH
110802: LD_VAR 0 7
110806: ARRAY
110807: PPUSH
110808: LD_VAR 0 13
110812: PPUSH
110813: CALL_OW 128
110817: GO 110839
// ComMoveToArea ( group [ i ] , f_heal ) ;
110819: LD_VAR 0 4
110823: PUSH
110824: LD_VAR 0 7
110828: ARRAY
110829: PPUSH
110830: LD_VAR 0 23
110834: PPUSH
110835: CALL_OW 113
// end ; continue ;
110839: GO 109870
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
110841: LD_VAR 0 4
110845: PUSH
110846: LD_VAR 0 7
110850: ARRAY
110851: PPUSH
110852: CALL_OW 256
110856: PUSH
110857: LD_INT 700
110859: LESS
110860: PUSH
110861: LD_VAR 0 4
110865: PUSH
110866: LD_VAR 0 7
110870: ARRAY
110871: PUSH
110872: LD_VAR 0 30
110876: IN
110877: NOT
110878: AND
110879: IFFALSE 110903
// to_heal := to_heal union group [ i ] ;
110881: LD_ADDR_VAR 0 30
110885: PUSH
110886: LD_VAR 0 30
110890: PUSH
110891: LD_VAR 0 4
110895: PUSH
110896: LD_VAR 0 7
110900: ARRAY
110901: UNION
110902: ST_TO_ADDR
// if group [ i ] in to_heal then
110903: LD_VAR 0 4
110907: PUSH
110908: LD_VAR 0 7
110912: ARRAY
110913: PUSH
110914: LD_VAR 0 30
110918: IN
110919: IFFALSE 111028
// begin if GetLives ( group [ i ] ) = 1000 then
110921: LD_VAR 0 4
110925: PUSH
110926: LD_VAR 0 7
110930: ARRAY
110931: PPUSH
110932: CALL_OW 256
110936: PUSH
110937: LD_INT 1000
110939: EQUAL
110940: IFFALSE 110966
// to_heal := to_heal diff group [ i ] else
110942: LD_ADDR_VAR 0 30
110946: PUSH
110947: LD_VAR 0 30
110951: PUSH
110952: LD_VAR 0 4
110956: PUSH
110957: LD_VAR 0 7
110961: ARRAY
110962: DIFF
110963: ST_TO_ADDR
110964: GO 111028
// begin if not IsInArea ( group [ i ] , to_heal ) then
110966: LD_VAR 0 4
110970: PUSH
110971: LD_VAR 0 7
110975: ARRAY
110976: PPUSH
110977: LD_VAR 0 30
110981: PPUSH
110982: CALL_OW 308
110986: NOT
110987: IFFALSE 111011
// ComMoveToArea ( group [ i ] , f_heal ) else
110989: LD_VAR 0 4
110993: PUSH
110994: LD_VAR 0 7
110998: ARRAY
110999: PPUSH
111000: LD_VAR 0 23
111004: PPUSH
111005: CALL_OW 113
111009: GO 111026
// ComHold ( group [ i ] ) ;
111011: LD_VAR 0 4
111015: PUSH
111016: LD_VAR 0 7
111020: ARRAY
111021: PPUSH
111022: CALL_OW 140
// continue ;
111026: GO 109870
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111028: LD_VAR 0 4
111032: PUSH
111033: LD_VAR 0 7
111037: ARRAY
111038: PPUSH
111039: LD_INT 10
111041: PPUSH
111042: CALL 84474 0 2
111046: NOT
111047: PUSH
111048: LD_VAR 0 16
111052: PUSH
111053: LD_VAR 0 7
111057: ARRAY
111058: PUSH
111059: EMPTY
111060: EQUAL
111061: NOT
111062: AND
111063: IFFALSE 111329
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111065: LD_VAR 0 4
111069: PUSH
111070: LD_VAR 0 7
111074: ARRAY
111075: PPUSH
111076: CALL_OW 262
111080: PUSH
111081: LD_INT 1
111083: PUSH
111084: LD_INT 2
111086: PUSH
111087: EMPTY
111088: LIST
111089: LIST
111090: IN
111091: IFFALSE 111132
// if GetFuel ( group [ i ] ) < 10 then
111093: LD_VAR 0 4
111097: PUSH
111098: LD_VAR 0 7
111102: ARRAY
111103: PPUSH
111104: CALL_OW 261
111108: PUSH
111109: LD_INT 10
111111: LESS
111112: IFFALSE 111132
// SetFuel ( group [ i ] , 12 ) ;
111114: LD_VAR 0 4
111118: PUSH
111119: LD_VAR 0 7
111123: ARRAY
111124: PPUSH
111125: LD_INT 12
111127: PPUSH
111128: CALL_OW 240
// if units_path [ i ] then
111132: LD_VAR 0 16
111136: PUSH
111137: LD_VAR 0 7
111141: ARRAY
111142: IFFALSE 111327
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111144: LD_VAR 0 4
111148: PUSH
111149: LD_VAR 0 7
111153: ARRAY
111154: PPUSH
111155: LD_VAR 0 16
111159: PUSH
111160: LD_VAR 0 7
111164: ARRAY
111165: PUSH
111166: LD_INT 1
111168: ARRAY
111169: PUSH
111170: LD_INT 1
111172: ARRAY
111173: PPUSH
111174: LD_VAR 0 16
111178: PUSH
111179: LD_VAR 0 7
111183: ARRAY
111184: PUSH
111185: LD_INT 1
111187: ARRAY
111188: PUSH
111189: LD_INT 2
111191: ARRAY
111192: PPUSH
111193: CALL_OW 297
111197: PUSH
111198: LD_INT 6
111200: GREATER
111201: IFFALSE 111276
// begin if not HasTask ( group [ i ] ) then
111203: LD_VAR 0 4
111207: PUSH
111208: LD_VAR 0 7
111212: ARRAY
111213: PPUSH
111214: CALL_OW 314
111218: NOT
111219: IFFALSE 111274
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111221: LD_VAR 0 4
111225: PUSH
111226: LD_VAR 0 7
111230: ARRAY
111231: PPUSH
111232: LD_VAR 0 16
111236: PUSH
111237: LD_VAR 0 7
111241: ARRAY
111242: PUSH
111243: LD_INT 1
111245: ARRAY
111246: PUSH
111247: LD_INT 1
111249: ARRAY
111250: PPUSH
111251: LD_VAR 0 16
111255: PUSH
111256: LD_VAR 0 7
111260: ARRAY
111261: PUSH
111262: LD_INT 1
111264: ARRAY
111265: PUSH
111266: LD_INT 2
111268: ARRAY
111269: PPUSH
111270: CALL_OW 114
// end else
111274: GO 111327
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111276: LD_ADDR_VAR 0 15
111280: PUSH
111281: LD_VAR 0 16
111285: PUSH
111286: LD_VAR 0 7
111290: ARRAY
111291: PPUSH
111292: LD_INT 1
111294: PPUSH
111295: CALL_OW 3
111299: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111300: LD_ADDR_VAR 0 16
111304: PUSH
111305: LD_VAR 0 16
111309: PPUSH
111310: LD_VAR 0 7
111314: PPUSH
111315: LD_VAR 0 15
111319: PPUSH
111320: CALL_OW 1
111324: ST_TO_ADDR
// continue ;
111325: GO 109870
// end ; end ; end else
111327: GO 113991
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111329: LD_ADDR_VAR 0 14
111333: PUSH
111334: LD_INT 81
111336: PUSH
111337: LD_VAR 0 4
111341: PUSH
111342: LD_VAR 0 7
111346: ARRAY
111347: PPUSH
111348: CALL_OW 255
111352: PUSH
111353: EMPTY
111354: LIST
111355: LIST
111356: PPUSH
111357: CALL_OW 69
111361: ST_TO_ADDR
// if not tmp then
111362: LD_VAR 0 14
111366: NOT
111367: IFFALSE 111371
// continue ;
111369: GO 109870
// if f_ignore_area then
111371: LD_VAR 0 17
111375: IFFALSE 111463
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
111377: LD_ADDR_VAR 0 15
111381: PUSH
111382: LD_VAR 0 14
111386: PPUSH
111387: LD_INT 3
111389: PUSH
111390: LD_INT 92
111392: PUSH
111393: LD_VAR 0 17
111397: PUSH
111398: LD_INT 1
111400: ARRAY
111401: PUSH
111402: LD_VAR 0 17
111406: PUSH
111407: LD_INT 2
111409: ARRAY
111410: PUSH
111411: LD_VAR 0 17
111415: PUSH
111416: LD_INT 3
111418: ARRAY
111419: PUSH
111420: EMPTY
111421: LIST
111422: LIST
111423: LIST
111424: LIST
111425: PUSH
111426: EMPTY
111427: LIST
111428: LIST
111429: PPUSH
111430: CALL_OW 72
111434: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111435: LD_VAR 0 14
111439: PUSH
111440: LD_VAR 0 15
111444: DIFF
111445: IFFALSE 111463
// tmp := tmp diff tmp2 ;
111447: LD_ADDR_VAR 0 14
111451: PUSH
111452: LD_VAR 0 14
111456: PUSH
111457: LD_VAR 0 15
111461: DIFF
111462: ST_TO_ADDR
// end ; if not f_murder then
111463: LD_VAR 0 20
111467: NOT
111468: IFFALSE 111526
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
111470: LD_ADDR_VAR 0 15
111474: PUSH
111475: LD_VAR 0 14
111479: PPUSH
111480: LD_INT 3
111482: PUSH
111483: LD_INT 50
111485: PUSH
111486: EMPTY
111487: LIST
111488: PUSH
111489: EMPTY
111490: LIST
111491: LIST
111492: PPUSH
111493: CALL_OW 72
111497: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
111498: LD_VAR 0 14
111502: PUSH
111503: LD_VAR 0 15
111507: DIFF
111508: IFFALSE 111526
// tmp := tmp diff tmp2 ;
111510: LD_ADDR_VAR 0 14
111514: PUSH
111515: LD_VAR 0 14
111519: PUSH
111520: LD_VAR 0 15
111524: DIFF
111525: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
111526: LD_ADDR_VAR 0 14
111530: PUSH
111531: LD_VAR 0 4
111535: PUSH
111536: LD_VAR 0 7
111540: ARRAY
111541: PPUSH
111542: LD_VAR 0 14
111546: PPUSH
111547: LD_INT 1
111549: PPUSH
111550: LD_INT 1
111552: PPUSH
111553: CALL 57409 0 4
111557: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
111558: LD_VAR 0 4
111562: PUSH
111563: LD_VAR 0 7
111567: ARRAY
111568: PPUSH
111569: CALL_OW 257
111573: PUSH
111574: LD_INT 1
111576: EQUAL
111577: IFFALSE 112025
// begin if WantPlant ( group [ i ] ) then
111579: LD_VAR 0 4
111583: PUSH
111584: LD_VAR 0 7
111588: ARRAY
111589: PPUSH
111590: CALL 56910 0 1
111594: IFFALSE 111598
// continue ;
111596: GO 109870
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
111598: LD_VAR 0 18
111602: PUSH
111603: LD_VAR 0 4
111607: PUSH
111608: LD_VAR 0 7
111612: ARRAY
111613: PPUSH
111614: CALL_OW 310
111618: NOT
111619: AND
111620: PUSH
111621: LD_VAR 0 14
111625: PUSH
111626: LD_INT 1
111628: ARRAY
111629: PUSH
111630: LD_VAR 0 14
111634: PPUSH
111635: LD_INT 21
111637: PUSH
111638: LD_INT 2
111640: PUSH
111641: EMPTY
111642: LIST
111643: LIST
111644: PUSH
111645: LD_INT 58
111647: PUSH
111648: EMPTY
111649: LIST
111650: PUSH
111651: EMPTY
111652: LIST
111653: LIST
111654: PPUSH
111655: CALL_OW 72
111659: IN
111660: AND
111661: IFFALSE 111697
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
111663: LD_VAR 0 4
111667: PUSH
111668: LD_VAR 0 7
111672: ARRAY
111673: PPUSH
111674: LD_VAR 0 14
111678: PUSH
111679: LD_INT 1
111681: ARRAY
111682: PPUSH
111683: CALL_OW 120
// attacking := true ;
111687: LD_ADDR_VAR 0 29
111691: PUSH
111692: LD_INT 1
111694: ST_TO_ADDR
// continue ;
111695: GO 109870
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
111697: LD_VAR 0 26
111701: PUSH
111702: LD_VAR 0 4
111706: PUSH
111707: LD_VAR 0 7
111711: ARRAY
111712: PPUSH
111713: CALL_OW 257
111717: PUSH
111718: LD_INT 1
111720: EQUAL
111721: AND
111722: PUSH
111723: LD_VAR 0 4
111727: PUSH
111728: LD_VAR 0 7
111732: ARRAY
111733: PPUSH
111734: CALL_OW 256
111738: PUSH
111739: LD_INT 800
111741: LESS
111742: AND
111743: PUSH
111744: LD_VAR 0 4
111748: PUSH
111749: LD_VAR 0 7
111753: ARRAY
111754: PPUSH
111755: CALL_OW 318
111759: NOT
111760: AND
111761: IFFALSE 111778
// ComCrawl ( group [ i ] ) ;
111763: LD_VAR 0 4
111767: PUSH
111768: LD_VAR 0 7
111772: ARRAY
111773: PPUSH
111774: CALL_OW 137
// if f_mines then
111778: LD_VAR 0 21
111782: IFFALSE 112025
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
111784: LD_VAR 0 14
111788: PUSH
111789: LD_INT 1
111791: ARRAY
111792: PPUSH
111793: CALL_OW 247
111797: PUSH
111798: LD_INT 3
111800: EQUAL
111801: PUSH
111802: LD_VAR 0 14
111806: PUSH
111807: LD_INT 1
111809: ARRAY
111810: PUSH
111811: LD_VAR 0 27
111815: IN
111816: NOT
111817: AND
111818: IFFALSE 112025
// begin x := GetX ( tmp [ 1 ] ) ;
111820: LD_ADDR_VAR 0 10
111824: PUSH
111825: LD_VAR 0 14
111829: PUSH
111830: LD_INT 1
111832: ARRAY
111833: PPUSH
111834: CALL_OW 250
111838: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
111839: LD_ADDR_VAR 0 11
111843: PUSH
111844: LD_VAR 0 14
111848: PUSH
111849: LD_INT 1
111851: ARRAY
111852: PPUSH
111853: CALL_OW 251
111857: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
111858: LD_ADDR_VAR 0 12
111862: PUSH
111863: LD_VAR 0 4
111867: PUSH
111868: LD_VAR 0 7
111872: ARRAY
111873: PPUSH
111874: CALL 84559 0 1
111878: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
111879: LD_VAR 0 4
111883: PUSH
111884: LD_VAR 0 7
111888: ARRAY
111889: PPUSH
111890: LD_VAR 0 10
111894: PPUSH
111895: LD_VAR 0 11
111899: PPUSH
111900: LD_VAR 0 14
111904: PUSH
111905: LD_INT 1
111907: ARRAY
111908: PPUSH
111909: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
111913: LD_VAR 0 4
111917: PUSH
111918: LD_VAR 0 7
111922: ARRAY
111923: PPUSH
111924: LD_VAR 0 10
111928: PPUSH
111929: LD_VAR 0 12
111933: PPUSH
111934: LD_INT 7
111936: PPUSH
111937: CALL_OW 272
111941: PPUSH
111942: LD_VAR 0 11
111946: PPUSH
111947: LD_VAR 0 12
111951: PPUSH
111952: LD_INT 7
111954: PPUSH
111955: CALL_OW 273
111959: PPUSH
111960: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
111964: LD_VAR 0 4
111968: PUSH
111969: LD_VAR 0 7
111973: ARRAY
111974: PPUSH
111975: LD_INT 71
111977: PPUSH
111978: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
111982: LD_ADDR_VAR 0 27
111986: PUSH
111987: LD_VAR 0 27
111991: PPUSH
111992: LD_VAR 0 27
111996: PUSH
111997: LD_INT 1
111999: PLUS
112000: PPUSH
112001: LD_VAR 0 14
112005: PUSH
112006: LD_INT 1
112008: ARRAY
112009: PPUSH
112010: CALL_OW 1
112014: ST_TO_ADDR
// attacking := true ;
112015: LD_ADDR_VAR 0 29
112019: PUSH
112020: LD_INT 1
112022: ST_TO_ADDR
// continue ;
112023: GO 109870
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112025: LD_VAR 0 4
112029: PUSH
112030: LD_VAR 0 7
112034: ARRAY
112035: PPUSH
112036: CALL_OW 257
112040: PUSH
112041: LD_INT 17
112043: EQUAL
112044: PUSH
112045: LD_VAR 0 4
112049: PUSH
112050: LD_VAR 0 7
112054: ARRAY
112055: PPUSH
112056: CALL_OW 110
112060: PUSH
112061: LD_INT 71
112063: EQUAL
112064: NOT
112065: AND
112066: IFFALSE 112212
// begin attacking := false ;
112068: LD_ADDR_VAR 0 29
112072: PUSH
112073: LD_INT 0
112075: ST_TO_ADDR
// k := 5 ;
112076: LD_ADDR_VAR 0 9
112080: PUSH
112081: LD_INT 5
112083: ST_TO_ADDR
// if tmp < k then
112084: LD_VAR 0 14
112088: PUSH
112089: LD_VAR 0 9
112093: LESS
112094: IFFALSE 112106
// k := tmp ;
112096: LD_ADDR_VAR 0 9
112100: PUSH
112101: LD_VAR 0 14
112105: ST_TO_ADDR
// for j = 1 to k do
112106: LD_ADDR_VAR 0 8
112110: PUSH
112111: DOUBLE
112112: LD_INT 1
112114: DEC
112115: ST_TO_ADDR
112116: LD_VAR 0 9
112120: PUSH
112121: FOR_TO
112122: IFFALSE 112210
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112124: LD_VAR 0 14
112128: PUSH
112129: LD_VAR 0 8
112133: ARRAY
112134: PUSH
112135: LD_VAR 0 14
112139: PPUSH
112140: LD_INT 58
112142: PUSH
112143: EMPTY
112144: LIST
112145: PPUSH
112146: CALL_OW 72
112150: IN
112151: NOT
112152: IFFALSE 112208
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112154: LD_VAR 0 4
112158: PUSH
112159: LD_VAR 0 7
112163: ARRAY
112164: PPUSH
112165: LD_VAR 0 14
112169: PUSH
112170: LD_VAR 0 8
112174: ARRAY
112175: PPUSH
112176: CALL_OW 115
// attacking := true ;
112180: LD_ADDR_VAR 0 29
112184: PUSH
112185: LD_INT 1
112187: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112188: LD_VAR 0 4
112192: PUSH
112193: LD_VAR 0 7
112197: ARRAY
112198: PPUSH
112199: LD_INT 71
112201: PPUSH
112202: CALL_OW 109
// continue ;
112206: GO 112121
// end ; end ;
112208: GO 112121
112210: POP
112211: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112212: LD_VAR 0 4
112216: PUSH
112217: LD_VAR 0 7
112221: ARRAY
112222: PPUSH
112223: CALL_OW 257
112227: PUSH
112228: LD_INT 8
112230: EQUAL
112231: PUSH
112232: LD_VAR 0 4
112236: PUSH
112237: LD_VAR 0 7
112241: ARRAY
112242: PPUSH
112243: CALL_OW 264
112247: PUSH
112248: LD_INT 28
112250: PUSH
112251: LD_INT 45
112253: PUSH
112254: LD_INT 7
112256: PUSH
112257: LD_INT 47
112259: PUSH
112260: EMPTY
112261: LIST
112262: LIST
112263: LIST
112264: LIST
112265: IN
112266: OR
112267: IFFALSE 112523
// begin attacking := false ;
112269: LD_ADDR_VAR 0 29
112273: PUSH
112274: LD_INT 0
112276: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112277: LD_VAR 0 14
112281: PUSH
112282: LD_INT 1
112284: ARRAY
112285: PPUSH
112286: CALL_OW 266
112290: PUSH
112291: LD_INT 32
112293: PUSH
112294: LD_INT 31
112296: PUSH
112297: LD_INT 33
112299: PUSH
112300: LD_INT 4
112302: PUSH
112303: LD_INT 5
112305: PUSH
112306: EMPTY
112307: LIST
112308: LIST
112309: LIST
112310: LIST
112311: LIST
112312: IN
112313: IFFALSE 112499
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112315: LD_ADDR_VAR 0 9
112319: PUSH
112320: LD_VAR 0 14
112324: PUSH
112325: LD_INT 1
112327: ARRAY
112328: PPUSH
112329: CALL_OW 266
112333: PPUSH
112334: LD_VAR 0 14
112338: PUSH
112339: LD_INT 1
112341: ARRAY
112342: PPUSH
112343: CALL_OW 250
112347: PPUSH
112348: LD_VAR 0 14
112352: PUSH
112353: LD_INT 1
112355: ARRAY
112356: PPUSH
112357: CALL_OW 251
112361: PPUSH
112362: LD_VAR 0 14
112366: PUSH
112367: LD_INT 1
112369: ARRAY
112370: PPUSH
112371: CALL_OW 254
112375: PPUSH
112376: LD_VAR 0 14
112380: PUSH
112381: LD_INT 1
112383: ARRAY
112384: PPUSH
112385: CALL_OW 248
112389: PPUSH
112390: LD_INT 0
112392: PPUSH
112393: CALL 65929 0 6
112397: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
112398: LD_ADDR_VAR 0 8
112402: PUSH
112403: LD_VAR 0 4
112407: PUSH
112408: LD_VAR 0 7
112412: ARRAY
112413: PPUSH
112414: LD_VAR 0 9
112418: PPUSH
112419: CALL 84599 0 2
112423: ST_TO_ADDR
// if j then
112424: LD_VAR 0 8
112428: IFFALSE 112497
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
112430: LD_VAR 0 8
112434: PUSH
112435: LD_INT 1
112437: ARRAY
112438: PPUSH
112439: LD_VAR 0 8
112443: PUSH
112444: LD_INT 2
112446: ARRAY
112447: PPUSH
112448: CALL_OW 488
112452: IFFALSE 112497
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
112454: LD_VAR 0 4
112458: PUSH
112459: LD_VAR 0 7
112463: ARRAY
112464: PPUSH
112465: LD_VAR 0 8
112469: PUSH
112470: LD_INT 1
112472: ARRAY
112473: PPUSH
112474: LD_VAR 0 8
112478: PUSH
112479: LD_INT 2
112481: ARRAY
112482: PPUSH
112483: CALL_OW 116
// attacking := true ;
112487: LD_ADDR_VAR 0 29
112491: PUSH
112492: LD_INT 1
112494: ST_TO_ADDR
// continue ;
112495: GO 109870
// end ; end else
112497: GO 112523
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112499: LD_VAR 0 4
112503: PUSH
112504: LD_VAR 0 7
112508: ARRAY
112509: PPUSH
112510: LD_VAR 0 14
112514: PUSH
112515: LD_INT 1
112517: ARRAY
112518: PPUSH
112519: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
112523: LD_VAR 0 4
112527: PUSH
112528: LD_VAR 0 7
112532: ARRAY
112533: PPUSH
112534: CALL_OW 265
112538: PUSH
112539: LD_INT 11
112541: EQUAL
112542: IFFALSE 112820
// begin k := 10 ;
112544: LD_ADDR_VAR 0 9
112548: PUSH
112549: LD_INT 10
112551: ST_TO_ADDR
// x := 0 ;
112552: LD_ADDR_VAR 0 10
112556: PUSH
112557: LD_INT 0
112559: ST_TO_ADDR
// if tmp < k then
112560: LD_VAR 0 14
112564: PUSH
112565: LD_VAR 0 9
112569: LESS
112570: IFFALSE 112582
// k := tmp ;
112572: LD_ADDR_VAR 0 9
112576: PUSH
112577: LD_VAR 0 14
112581: ST_TO_ADDR
// for j = k downto 1 do
112582: LD_ADDR_VAR 0 8
112586: PUSH
112587: DOUBLE
112588: LD_VAR 0 9
112592: INC
112593: ST_TO_ADDR
112594: LD_INT 1
112596: PUSH
112597: FOR_DOWNTO
112598: IFFALSE 112673
// begin if GetType ( tmp [ j ] ) = unit_human then
112600: LD_VAR 0 14
112604: PUSH
112605: LD_VAR 0 8
112609: ARRAY
112610: PPUSH
112611: CALL_OW 247
112615: PUSH
112616: LD_INT 1
112618: EQUAL
112619: IFFALSE 112671
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
112621: LD_VAR 0 4
112625: PUSH
112626: LD_VAR 0 7
112630: ARRAY
112631: PPUSH
112632: LD_VAR 0 14
112636: PUSH
112637: LD_VAR 0 8
112641: ARRAY
112642: PPUSH
112643: CALL 84870 0 2
// x := tmp [ j ] ;
112647: LD_ADDR_VAR 0 10
112651: PUSH
112652: LD_VAR 0 14
112656: PUSH
112657: LD_VAR 0 8
112661: ARRAY
112662: ST_TO_ADDR
// attacking := true ;
112663: LD_ADDR_VAR 0 29
112667: PUSH
112668: LD_INT 1
112670: ST_TO_ADDR
// end ; end ;
112671: GO 112597
112673: POP
112674: POP
// if not x then
112675: LD_VAR 0 10
112679: NOT
112680: IFFALSE 112820
// begin attacking := true ;
112682: LD_ADDR_VAR 0 29
112686: PUSH
112687: LD_INT 1
112689: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
112690: LD_VAR 0 4
112694: PUSH
112695: LD_VAR 0 7
112699: ARRAY
112700: PPUSH
112701: CALL_OW 250
112705: PPUSH
112706: LD_VAR 0 4
112710: PUSH
112711: LD_VAR 0 7
112715: ARRAY
112716: PPUSH
112717: CALL_OW 251
112721: PPUSH
112722: CALL_OW 546
112726: PUSH
112727: LD_INT 2
112729: ARRAY
112730: PUSH
112731: LD_VAR 0 14
112735: PUSH
112736: LD_INT 1
112738: ARRAY
112739: PPUSH
112740: CALL_OW 250
112744: PPUSH
112745: LD_VAR 0 14
112749: PUSH
112750: LD_INT 1
112752: ARRAY
112753: PPUSH
112754: CALL_OW 251
112758: PPUSH
112759: CALL_OW 546
112763: PUSH
112764: LD_INT 2
112766: ARRAY
112767: EQUAL
112768: IFFALSE 112796
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
112770: LD_VAR 0 4
112774: PUSH
112775: LD_VAR 0 7
112779: ARRAY
112780: PPUSH
112781: LD_VAR 0 14
112785: PUSH
112786: LD_INT 1
112788: ARRAY
112789: PPUSH
112790: CALL 84870 0 2
112794: GO 112820
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112796: LD_VAR 0 4
112800: PUSH
112801: LD_VAR 0 7
112805: ARRAY
112806: PPUSH
112807: LD_VAR 0 14
112811: PUSH
112812: LD_INT 1
112814: ARRAY
112815: PPUSH
112816: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
112820: LD_VAR 0 4
112824: PUSH
112825: LD_VAR 0 7
112829: ARRAY
112830: PPUSH
112831: CALL_OW 264
112835: PUSH
112836: LD_INT 29
112838: EQUAL
112839: IFFALSE 113205
// begin if WantsToAttack ( group [ i ] ) in bombed then
112841: LD_VAR 0 4
112845: PUSH
112846: LD_VAR 0 7
112850: ARRAY
112851: PPUSH
112852: CALL_OW 319
112856: PUSH
112857: LD_VAR 0 28
112861: IN
112862: IFFALSE 112866
// continue ;
112864: GO 109870
// k := 8 ;
112866: LD_ADDR_VAR 0 9
112870: PUSH
112871: LD_INT 8
112873: ST_TO_ADDR
// x := 0 ;
112874: LD_ADDR_VAR 0 10
112878: PUSH
112879: LD_INT 0
112881: ST_TO_ADDR
// if tmp < k then
112882: LD_VAR 0 14
112886: PUSH
112887: LD_VAR 0 9
112891: LESS
112892: IFFALSE 112904
// k := tmp ;
112894: LD_ADDR_VAR 0 9
112898: PUSH
112899: LD_VAR 0 14
112903: ST_TO_ADDR
// for j = 1 to k do
112904: LD_ADDR_VAR 0 8
112908: PUSH
112909: DOUBLE
112910: LD_INT 1
112912: DEC
112913: ST_TO_ADDR
112914: LD_VAR 0 9
112918: PUSH
112919: FOR_TO
112920: IFFALSE 113052
// begin if GetType ( tmp [ j ] ) = unit_building then
112922: LD_VAR 0 14
112926: PUSH
112927: LD_VAR 0 8
112931: ARRAY
112932: PPUSH
112933: CALL_OW 247
112937: PUSH
112938: LD_INT 3
112940: EQUAL
112941: IFFALSE 113050
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
112943: LD_VAR 0 14
112947: PUSH
112948: LD_VAR 0 8
112952: ARRAY
112953: PUSH
112954: LD_VAR 0 28
112958: IN
112959: NOT
112960: PUSH
112961: LD_VAR 0 14
112965: PUSH
112966: LD_VAR 0 8
112970: ARRAY
112971: PPUSH
112972: CALL_OW 313
112976: AND
112977: IFFALSE 113050
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112979: LD_VAR 0 4
112983: PUSH
112984: LD_VAR 0 7
112988: ARRAY
112989: PPUSH
112990: LD_VAR 0 14
112994: PUSH
112995: LD_VAR 0 8
112999: ARRAY
113000: PPUSH
113001: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113005: LD_ADDR_VAR 0 28
113009: PUSH
113010: LD_VAR 0 28
113014: PPUSH
113015: LD_VAR 0 28
113019: PUSH
113020: LD_INT 1
113022: PLUS
113023: PPUSH
113024: LD_VAR 0 14
113028: PUSH
113029: LD_VAR 0 8
113033: ARRAY
113034: PPUSH
113035: CALL_OW 1
113039: ST_TO_ADDR
// attacking := true ;
113040: LD_ADDR_VAR 0 29
113044: PUSH
113045: LD_INT 1
113047: ST_TO_ADDR
// break ;
113048: GO 113052
// end ; end ;
113050: GO 112919
113052: POP
113053: POP
// if not attacking and f_attack_depot then
113054: LD_VAR 0 29
113058: NOT
113059: PUSH
113060: LD_VAR 0 25
113064: AND
113065: IFFALSE 113160
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113067: LD_ADDR_VAR 0 13
113071: PUSH
113072: LD_VAR 0 14
113076: PPUSH
113077: LD_INT 2
113079: PUSH
113080: LD_INT 30
113082: PUSH
113083: LD_INT 0
113085: PUSH
113086: EMPTY
113087: LIST
113088: LIST
113089: PUSH
113090: LD_INT 30
113092: PUSH
113093: LD_INT 1
113095: PUSH
113096: EMPTY
113097: LIST
113098: LIST
113099: PUSH
113100: EMPTY
113101: LIST
113102: LIST
113103: LIST
113104: PPUSH
113105: CALL_OW 72
113109: ST_TO_ADDR
// if z then
113110: LD_VAR 0 13
113114: IFFALSE 113160
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113116: LD_VAR 0 4
113120: PUSH
113121: LD_VAR 0 7
113125: ARRAY
113126: PPUSH
113127: LD_VAR 0 13
113131: PPUSH
113132: LD_VAR 0 4
113136: PUSH
113137: LD_VAR 0 7
113141: ARRAY
113142: PPUSH
113143: CALL_OW 74
113147: PPUSH
113148: CALL_OW 115
// attacking := true ;
113152: LD_ADDR_VAR 0 29
113156: PUSH
113157: LD_INT 1
113159: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113160: LD_VAR 0 4
113164: PUSH
113165: LD_VAR 0 7
113169: ARRAY
113170: PPUSH
113171: CALL_OW 256
113175: PUSH
113176: LD_INT 500
113178: LESS
113179: IFFALSE 113205
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113181: LD_VAR 0 4
113185: PUSH
113186: LD_VAR 0 7
113190: ARRAY
113191: PPUSH
113192: LD_VAR 0 14
113196: PUSH
113197: LD_INT 1
113199: ARRAY
113200: PPUSH
113201: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113205: LD_VAR 0 4
113209: PUSH
113210: LD_VAR 0 7
113214: ARRAY
113215: PPUSH
113216: CALL_OW 264
113220: PUSH
113221: LD_INT 49
113223: EQUAL
113224: IFFALSE 113345
// begin if not HasTask ( group [ i ] ) then
113226: LD_VAR 0 4
113230: PUSH
113231: LD_VAR 0 7
113235: ARRAY
113236: PPUSH
113237: CALL_OW 314
113241: NOT
113242: IFFALSE 113345
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113244: LD_ADDR_VAR 0 9
113248: PUSH
113249: LD_INT 81
113251: PUSH
113252: LD_VAR 0 4
113256: PUSH
113257: LD_VAR 0 7
113261: ARRAY
113262: PPUSH
113263: CALL_OW 255
113267: PUSH
113268: EMPTY
113269: LIST
113270: LIST
113271: PPUSH
113272: CALL_OW 69
113276: PPUSH
113277: LD_VAR 0 4
113281: PUSH
113282: LD_VAR 0 7
113286: ARRAY
113287: PPUSH
113288: CALL_OW 74
113292: ST_TO_ADDR
// if k then
113293: LD_VAR 0 9
113297: IFFALSE 113345
// if GetDistUnits ( group [ i ] , k ) > 10 then
113299: LD_VAR 0 4
113303: PUSH
113304: LD_VAR 0 7
113308: ARRAY
113309: PPUSH
113310: LD_VAR 0 9
113314: PPUSH
113315: CALL_OW 296
113319: PUSH
113320: LD_INT 10
113322: GREATER
113323: IFFALSE 113345
// ComMoveUnit ( group [ i ] , k ) ;
113325: LD_VAR 0 4
113329: PUSH
113330: LD_VAR 0 7
113334: ARRAY
113335: PPUSH
113336: LD_VAR 0 9
113340: PPUSH
113341: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
113345: LD_VAR 0 4
113349: PUSH
113350: LD_VAR 0 7
113354: ARRAY
113355: PPUSH
113356: CALL_OW 256
113360: PUSH
113361: LD_INT 250
113363: LESS
113364: PUSH
113365: LD_VAR 0 4
113369: PUSH
113370: LD_VAR 0 7
113374: ARRAY
113375: PUSH
113376: LD_INT 21
113378: PUSH
113379: LD_INT 2
113381: PUSH
113382: EMPTY
113383: LIST
113384: LIST
113385: PUSH
113386: LD_INT 23
113388: PUSH
113389: LD_INT 2
113391: PUSH
113392: EMPTY
113393: LIST
113394: LIST
113395: PUSH
113396: EMPTY
113397: LIST
113398: LIST
113399: PPUSH
113400: CALL_OW 69
113404: IN
113405: AND
113406: IFFALSE 113531
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
113408: LD_ADDR_VAR 0 9
113412: PUSH
113413: LD_OWVAR 3
113417: PUSH
113418: LD_VAR 0 4
113422: PUSH
113423: LD_VAR 0 7
113427: ARRAY
113428: DIFF
113429: PPUSH
113430: LD_VAR 0 4
113434: PUSH
113435: LD_VAR 0 7
113439: ARRAY
113440: PPUSH
113441: CALL_OW 74
113445: ST_TO_ADDR
// if not k then
113446: LD_VAR 0 9
113450: NOT
113451: IFFALSE 113455
// continue ;
113453: GO 109870
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
113455: LD_VAR 0 9
113459: PUSH
113460: LD_INT 81
113462: PUSH
113463: LD_VAR 0 4
113467: PUSH
113468: LD_VAR 0 7
113472: ARRAY
113473: PPUSH
113474: CALL_OW 255
113478: PUSH
113479: EMPTY
113480: LIST
113481: LIST
113482: PPUSH
113483: CALL_OW 69
113487: IN
113488: PUSH
113489: LD_VAR 0 9
113493: PPUSH
113494: LD_VAR 0 4
113498: PUSH
113499: LD_VAR 0 7
113503: ARRAY
113504: PPUSH
113505: CALL_OW 296
113509: PUSH
113510: LD_INT 5
113512: LESS
113513: AND
113514: IFFALSE 113531
// ComAutodestruct ( group [ i ] ) ;
113516: LD_VAR 0 4
113520: PUSH
113521: LD_VAR 0 7
113525: ARRAY
113526: PPUSH
113527: CALL 84768 0 1
// end ; if f_attack_depot then
113531: LD_VAR 0 25
113535: IFFALSE 113647
// begin k := 6 ;
113537: LD_ADDR_VAR 0 9
113541: PUSH
113542: LD_INT 6
113544: ST_TO_ADDR
// if tmp < k then
113545: LD_VAR 0 14
113549: PUSH
113550: LD_VAR 0 9
113554: LESS
113555: IFFALSE 113567
// k := tmp ;
113557: LD_ADDR_VAR 0 9
113561: PUSH
113562: LD_VAR 0 14
113566: ST_TO_ADDR
// for j = 1 to k do
113567: LD_ADDR_VAR 0 8
113571: PUSH
113572: DOUBLE
113573: LD_INT 1
113575: DEC
113576: ST_TO_ADDR
113577: LD_VAR 0 9
113581: PUSH
113582: FOR_TO
113583: IFFALSE 113645
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
113585: LD_VAR 0 8
113589: PPUSH
113590: CALL_OW 266
113594: PUSH
113595: LD_INT 0
113597: PUSH
113598: LD_INT 1
113600: PUSH
113601: EMPTY
113602: LIST
113603: LIST
113604: IN
113605: IFFALSE 113643
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113607: LD_VAR 0 4
113611: PUSH
113612: LD_VAR 0 7
113616: ARRAY
113617: PPUSH
113618: LD_VAR 0 14
113622: PUSH
113623: LD_VAR 0 8
113627: ARRAY
113628: PPUSH
113629: CALL_OW 115
// attacking := true ;
113633: LD_ADDR_VAR 0 29
113637: PUSH
113638: LD_INT 1
113640: ST_TO_ADDR
// break ;
113641: GO 113645
// end ;
113643: GO 113582
113645: POP
113646: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
113647: LD_VAR 0 4
113651: PUSH
113652: LD_VAR 0 7
113656: ARRAY
113657: PPUSH
113658: CALL_OW 302
113662: PUSH
113663: LD_VAR 0 29
113667: NOT
113668: AND
113669: IFFALSE 113991
// begin if GetTag ( group [ i ] ) = 71 then
113671: LD_VAR 0 4
113675: PUSH
113676: LD_VAR 0 7
113680: ARRAY
113681: PPUSH
113682: CALL_OW 110
113686: PUSH
113687: LD_INT 71
113689: EQUAL
113690: IFFALSE 113731
// begin if HasTask ( group [ i ] ) then
113692: LD_VAR 0 4
113696: PUSH
113697: LD_VAR 0 7
113701: ARRAY
113702: PPUSH
113703: CALL_OW 314
113707: IFFALSE 113713
// continue else
113709: GO 109870
113711: GO 113731
// SetTag ( group [ i ] , 0 ) ;
113713: LD_VAR 0 4
113717: PUSH
113718: LD_VAR 0 7
113722: ARRAY
113723: PPUSH
113724: LD_INT 0
113726: PPUSH
113727: CALL_OW 109
// end ; k := 8 ;
113731: LD_ADDR_VAR 0 9
113735: PUSH
113736: LD_INT 8
113738: ST_TO_ADDR
// x := 0 ;
113739: LD_ADDR_VAR 0 10
113743: PUSH
113744: LD_INT 0
113746: ST_TO_ADDR
// if tmp < k then
113747: LD_VAR 0 14
113751: PUSH
113752: LD_VAR 0 9
113756: LESS
113757: IFFALSE 113769
// k := tmp ;
113759: LD_ADDR_VAR 0 9
113763: PUSH
113764: LD_VAR 0 14
113768: ST_TO_ADDR
// for j = 1 to k do
113769: LD_ADDR_VAR 0 8
113773: PUSH
113774: DOUBLE
113775: LD_INT 1
113777: DEC
113778: ST_TO_ADDR
113779: LD_VAR 0 9
113783: PUSH
113784: FOR_TO
113785: IFFALSE 113883
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
113787: LD_VAR 0 14
113791: PUSH
113792: LD_VAR 0 8
113796: ARRAY
113797: PPUSH
113798: CALL_OW 247
113802: PUSH
113803: LD_INT 1
113805: EQUAL
113806: PUSH
113807: LD_VAR 0 14
113811: PUSH
113812: LD_VAR 0 8
113816: ARRAY
113817: PPUSH
113818: CALL_OW 256
113822: PUSH
113823: LD_INT 250
113825: LESS
113826: PUSH
113827: LD_VAR 0 20
113831: AND
113832: PUSH
113833: LD_VAR 0 20
113837: NOT
113838: PUSH
113839: LD_VAR 0 14
113843: PUSH
113844: LD_VAR 0 8
113848: ARRAY
113849: PPUSH
113850: CALL_OW 256
113854: PUSH
113855: LD_INT 250
113857: GREATEREQUAL
113858: AND
113859: OR
113860: AND
113861: IFFALSE 113881
// begin x := tmp [ j ] ;
113863: LD_ADDR_VAR 0 10
113867: PUSH
113868: LD_VAR 0 14
113872: PUSH
113873: LD_VAR 0 8
113877: ARRAY
113878: ST_TO_ADDR
// break ;
113879: GO 113883
// end ;
113881: GO 113784
113883: POP
113884: POP
// if x then
113885: LD_VAR 0 10
113889: IFFALSE 113913
// ComAttackUnit ( group [ i ] , x ) else
113891: LD_VAR 0 4
113895: PUSH
113896: LD_VAR 0 7
113900: ARRAY
113901: PPUSH
113902: LD_VAR 0 10
113906: PPUSH
113907: CALL_OW 115
113911: GO 113937
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113913: LD_VAR 0 4
113917: PUSH
113918: LD_VAR 0 7
113922: ARRAY
113923: PPUSH
113924: LD_VAR 0 14
113928: PUSH
113929: LD_INT 1
113931: ARRAY
113932: PPUSH
113933: CALL_OW 115
// if not HasTask ( group [ i ] ) then
113937: LD_VAR 0 4
113941: PUSH
113942: LD_VAR 0 7
113946: ARRAY
113947: PPUSH
113948: CALL_OW 314
113952: NOT
113953: IFFALSE 113991
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
113955: LD_VAR 0 4
113959: PUSH
113960: LD_VAR 0 7
113964: ARRAY
113965: PPUSH
113966: LD_VAR 0 14
113970: PPUSH
113971: LD_VAR 0 4
113975: PUSH
113976: LD_VAR 0 7
113980: ARRAY
113981: PPUSH
113982: CALL_OW 74
113986: PPUSH
113987: CALL_OW 115
// end ; end ; end ;
113991: GO 109870
113993: POP
113994: POP
// wait ( 0 0$2 ) ;
113995: LD_INT 70
113997: PPUSH
113998: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114002: LD_VAR 0 4
114006: NOT
114007: PUSH
114008: LD_VAR 0 4
114012: PUSH
114013: EMPTY
114014: EQUAL
114015: OR
114016: PUSH
114017: LD_INT 81
114019: PUSH
114020: LD_VAR 0 35
114024: PUSH
114025: EMPTY
114026: LIST
114027: LIST
114028: PPUSH
114029: CALL_OW 69
114033: NOT
114034: OR
114035: IFFALSE 109855
// end ;
114037: LD_VAR 0 2
114041: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114042: LD_INT 0
114044: PPUSH
114045: PPUSH
114046: PPUSH
114047: PPUSH
114048: PPUSH
114049: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114050: LD_VAR 0 1
114054: NOT
114055: PUSH
114056: LD_EXP 95
114060: PUSH
114061: LD_VAR 0 1
114065: ARRAY
114066: NOT
114067: OR
114068: PUSH
114069: LD_VAR 0 2
114073: NOT
114074: OR
114075: IFFALSE 114079
// exit ;
114077: GO 114633
// side := mc_sides [ base ] ;
114079: LD_ADDR_VAR 0 6
114083: PUSH
114084: LD_EXP 121
114088: PUSH
114089: LD_VAR 0 1
114093: ARRAY
114094: ST_TO_ADDR
// if not side then
114095: LD_VAR 0 6
114099: NOT
114100: IFFALSE 114104
// exit ;
114102: GO 114633
// for i in solds do
114104: LD_ADDR_VAR 0 7
114108: PUSH
114109: LD_VAR 0 2
114113: PUSH
114114: FOR_IN
114115: IFFALSE 114176
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114117: LD_VAR 0 7
114121: PPUSH
114122: CALL_OW 310
114126: PPUSH
114127: CALL_OW 266
114131: PUSH
114132: LD_INT 32
114134: PUSH
114135: LD_INT 31
114137: PUSH
114138: EMPTY
114139: LIST
114140: LIST
114141: IN
114142: IFFALSE 114162
// solds := solds diff i else
114144: LD_ADDR_VAR 0 2
114148: PUSH
114149: LD_VAR 0 2
114153: PUSH
114154: LD_VAR 0 7
114158: DIFF
114159: ST_TO_ADDR
114160: GO 114174
// SetTag ( i , 18 ) ;
114162: LD_VAR 0 7
114166: PPUSH
114167: LD_INT 18
114169: PPUSH
114170: CALL_OW 109
114174: GO 114114
114176: POP
114177: POP
// if not solds then
114178: LD_VAR 0 2
114182: NOT
114183: IFFALSE 114187
// exit ;
114185: GO 114633
// repeat wait ( 0 0$2 ) ;
114187: LD_INT 70
114189: PPUSH
114190: CALL_OW 67
// enemy := mc_scan [ base ] ;
114194: LD_ADDR_VAR 0 4
114198: PUSH
114199: LD_EXP 118
114203: PUSH
114204: LD_VAR 0 1
114208: ARRAY
114209: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114210: LD_EXP 95
114214: PUSH
114215: LD_VAR 0 1
114219: ARRAY
114220: NOT
114221: PUSH
114222: LD_EXP 95
114226: PUSH
114227: LD_VAR 0 1
114231: ARRAY
114232: PUSH
114233: EMPTY
114234: EQUAL
114235: OR
114236: IFFALSE 114273
// begin for i in solds do
114238: LD_ADDR_VAR 0 7
114242: PUSH
114243: LD_VAR 0 2
114247: PUSH
114248: FOR_IN
114249: IFFALSE 114262
// ComStop ( i ) ;
114251: LD_VAR 0 7
114255: PPUSH
114256: CALL_OW 141
114260: GO 114248
114262: POP
114263: POP
// solds := [ ] ;
114264: LD_ADDR_VAR 0 2
114268: PUSH
114269: EMPTY
114270: ST_TO_ADDR
// exit ;
114271: GO 114633
// end ; for i in solds do
114273: LD_ADDR_VAR 0 7
114277: PUSH
114278: LD_VAR 0 2
114282: PUSH
114283: FOR_IN
114284: IFFALSE 114605
// begin if IsInUnit ( i ) then
114286: LD_VAR 0 7
114290: PPUSH
114291: CALL_OW 310
114295: IFFALSE 114306
// ComExitBuilding ( i ) ;
114297: LD_VAR 0 7
114301: PPUSH
114302: CALL_OW 122
// if GetLives ( i ) > 500 then
114306: LD_VAR 0 7
114310: PPUSH
114311: CALL_OW 256
114315: PUSH
114316: LD_INT 500
114318: GREATER
114319: IFFALSE 114372
// begin e := NearestUnitToUnit ( enemy , i ) ;
114321: LD_ADDR_VAR 0 5
114325: PUSH
114326: LD_VAR 0 4
114330: PPUSH
114331: LD_VAR 0 7
114335: PPUSH
114336: CALL_OW 74
114340: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
114341: LD_VAR 0 7
114345: PPUSH
114346: LD_VAR 0 5
114350: PPUSH
114351: CALL_OW 250
114355: PPUSH
114356: LD_VAR 0 5
114360: PPUSH
114361: CALL_OW 251
114365: PPUSH
114366: CALL_OW 114
// end else
114370: GO 114603
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
114372: LD_VAR 0 7
114376: PPUSH
114377: LD_EXP 95
114381: PUSH
114382: LD_VAR 0 1
114386: ARRAY
114387: PPUSH
114388: LD_INT 2
114390: PUSH
114391: LD_INT 30
114393: PUSH
114394: LD_INT 0
114396: PUSH
114397: EMPTY
114398: LIST
114399: LIST
114400: PUSH
114401: LD_INT 30
114403: PUSH
114404: LD_INT 1
114406: PUSH
114407: EMPTY
114408: LIST
114409: LIST
114410: PUSH
114411: LD_INT 30
114413: PUSH
114414: LD_INT 6
114416: PUSH
114417: EMPTY
114418: LIST
114419: LIST
114420: PUSH
114421: EMPTY
114422: LIST
114423: LIST
114424: LIST
114425: LIST
114426: PPUSH
114427: CALL_OW 72
114431: PPUSH
114432: LD_VAR 0 7
114436: PPUSH
114437: CALL_OW 74
114441: PPUSH
114442: CALL_OW 296
114446: PUSH
114447: LD_INT 10
114449: GREATER
114450: IFFALSE 114603
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
114452: LD_ADDR_VAR 0 8
114456: PUSH
114457: LD_EXP 95
114461: PUSH
114462: LD_VAR 0 1
114466: ARRAY
114467: PPUSH
114468: LD_INT 2
114470: PUSH
114471: LD_INT 30
114473: PUSH
114474: LD_INT 0
114476: PUSH
114477: EMPTY
114478: LIST
114479: LIST
114480: PUSH
114481: LD_INT 30
114483: PUSH
114484: LD_INT 1
114486: PUSH
114487: EMPTY
114488: LIST
114489: LIST
114490: PUSH
114491: LD_INT 30
114493: PUSH
114494: LD_INT 6
114496: PUSH
114497: EMPTY
114498: LIST
114499: LIST
114500: PUSH
114501: EMPTY
114502: LIST
114503: LIST
114504: LIST
114505: LIST
114506: PPUSH
114507: CALL_OW 72
114511: PPUSH
114512: LD_VAR 0 7
114516: PPUSH
114517: CALL_OW 74
114521: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
114522: LD_VAR 0 7
114526: PPUSH
114527: LD_VAR 0 8
114531: PPUSH
114532: CALL_OW 250
114536: PPUSH
114537: LD_INT 3
114539: PPUSH
114540: LD_INT 5
114542: PPUSH
114543: CALL_OW 272
114547: PPUSH
114548: LD_VAR 0 8
114552: PPUSH
114553: CALL_OW 251
114557: PPUSH
114558: LD_INT 3
114560: PPUSH
114561: LD_INT 5
114563: PPUSH
114564: CALL_OW 273
114568: PPUSH
114569: CALL_OW 111
// SetTag ( i , 0 ) ;
114573: LD_VAR 0 7
114577: PPUSH
114578: LD_INT 0
114580: PPUSH
114581: CALL_OW 109
// solds := solds diff i ;
114585: LD_ADDR_VAR 0 2
114589: PUSH
114590: LD_VAR 0 2
114594: PUSH
114595: LD_VAR 0 7
114599: DIFF
114600: ST_TO_ADDR
// continue ;
114601: GO 114283
// end ; end ;
114603: GO 114283
114605: POP
114606: POP
// until not solds or not enemy ;
114607: LD_VAR 0 2
114611: NOT
114612: PUSH
114613: LD_VAR 0 4
114617: NOT
114618: OR
114619: IFFALSE 114187
// MC_Reset ( base , 18 ) ;
114621: LD_VAR 0 1
114625: PPUSH
114626: LD_INT 18
114628: PPUSH
114629: CALL 25516 0 2
// end ;
114633: LD_VAR 0 3
114637: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
114638: LD_INT 0
114640: PPUSH
114641: PPUSH
114642: PPUSH
114643: PPUSH
114644: PPUSH
114645: PPUSH
114646: PPUSH
114647: PPUSH
114648: PPUSH
114649: PPUSH
114650: PPUSH
114651: PPUSH
114652: PPUSH
114653: PPUSH
114654: PPUSH
114655: PPUSH
114656: PPUSH
114657: PPUSH
114658: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
114659: LD_ADDR_VAR 0 12
114663: PUSH
114664: LD_EXP 95
114668: PUSH
114669: LD_VAR 0 1
114673: ARRAY
114674: PPUSH
114675: LD_INT 25
114677: PUSH
114678: LD_INT 3
114680: PUSH
114681: EMPTY
114682: LIST
114683: LIST
114684: PPUSH
114685: CALL_OW 72
114689: ST_TO_ADDR
// if mc_remote_driver [ base ] then
114690: LD_EXP 135
114694: PUSH
114695: LD_VAR 0 1
114699: ARRAY
114700: IFFALSE 114724
// mechs := mechs diff mc_remote_driver [ base ] ;
114702: LD_ADDR_VAR 0 12
114706: PUSH
114707: LD_VAR 0 12
114711: PUSH
114712: LD_EXP 135
114716: PUSH
114717: LD_VAR 0 1
114721: ARRAY
114722: DIFF
114723: ST_TO_ADDR
// for i in mechs do
114724: LD_ADDR_VAR 0 4
114728: PUSH
114729: LD_VAR 0 12
114733: PUSH
114734: FOR_IN
114735: IFFALSE 114770
// if GetTag ( i ) > 0 then
114737: LD_VAR 0 4
114741: PPUSH
114742: CALL_OW 110
114746: PUSH
114747: LD_INT 0
114749: GREATER
114750: IFFALSE 114768
// mechs := mechs diff i ;
114752: LD_ADDR_VAR 0 12
114756: PUSH
114757: LD_VAR 0 12
114761: PUSH
114762: LD_VAR 0 4
114766: DIFF
114767: ST_TO_ADDR
114768: GO 114734
114770: POP
114771: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114772: LD_ADDR_VAR 0 8
114776: PUSH
114777: LD_EXP 95
114781: PUSH
114782: LD_VAR 0 1
114786: ARRAY
114787: PPUSH
114788: LD_INT 2
114790: PUSH
114791: LD_INT 25
114793: PUSH
114794: LD_INT 1
114796: PUSH
114797: EMPTY
114798: LIST
114799: LIST
114800: PUSH
114801: LD_INT 25
114803: PUSH
114804: LD_INT 5
114806: PUSH
114807: EMPTY
114808: LIST
114809: LIST
114810: PUSH
114811: LD_INT 25
114813: PUSH
114814: LD_INT 8
114816: PUSH
114817: EMPTY
114818: LIST
114819: LIST
114820: PUSH
114821: LD_INT 25
114823: PUSH
114824: LD_INT 9
114826: PUSH
114827: EMPTY
114828: LIST
114829: LIST
114830: PUSH
114831: EMPTY
114832: LIST
114833: LIST
114834: LIST
114835: LIST
114836: LIST
114837: PPUSH
114838: CALL_OW 72
114842: ST_TO_ADDR
// if not defenders and not solds then
114843: LD_VAR 0 2
114847: NOT
114848: PUSH
114849: LD_VAR 0 8
114853: NOT
114854: AND
114855: IFFALSE 114859
// exit ;
114857: GO 116629
// depot_under_attack := false ;
114859: LD_ADDR_VAR 0 16
114863: PUSH
114864: LD_INT 0
114866: ST_TO_ADDR
// sold_defenders := [ ] ;
114867: LD_ADDR_VAR 0 17
114871: PUSH
114872: EMPTY
114873: ST_TO_ADDR
// if mechs then
114874: LD_VAR 0 12
114878: IFFALSE 115031
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
114880: LD_ADDR_VAR 0 4
114884: PUSH
114885: LD_VAR 0 2
114889: PPUSH
114890: LD_INT 21
114892: PUSH
114893: LD_INT 2
114895: PUSH
114896: EMPTY
114897: LIST
114898: LIST
114899: PPUSH
114900: CALL_OW 72
114904: PUSH
114905: FOR_IN
114906: IFFALSE 115029
// begin if GetTag ( i ) <> 20 then
114908: LD_VAR 0 4
114912: PPUSH
114913: CALL_OW 110
114917: PUSH
114918: LD_INT 20
114920: NONEQUAL
114921: IFFALSE 114935
// SetTag ( i , 20 ) ;
114923: LD_VAR 0 4
114927: PPUSH
114928: LD_INT 20
114930: PPUSH
114931: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
114935: LD_VAR 0 4
114939: PPUSH
114940: CALL_OW 263
114944: PUSH
114945: LD_INT 1
114947: EQUAL
114948: PUSH
114949: LD_VAR 0 4
114953: PPUSH
114954: CALL_OW 311
114958: NOT
114959: AND
114960: IFFALSE 115027
// begin un := mechs [ 1 ] ;
114962: LD_ADDR_VAR 0 10
114966: PUSH
114967: LD_VAR 0 12
114971: PUSH
114972: LD_INT 1
114974: ARRAY
114975: ST_TO_ADDR
// ComExit ( un ) ;
114976: LD_VAR 0 10
114980: PPUSH
114981: CALL 89113 0 1
// AddComEnterUnit ( un , i ) ;
114985: LD_VAR 0 10
114989: PPUSH
114990: LD_VAR 0 4
114994: PPUSH
114995: CALL_OW 180
// SetTag ( un , 19 ) ;
114999: LD_VAR 0 10
115003: PPUSH
115004: LD_INT 19
115006: PPUSH
115007: CALL_OW 109
// mechs := mechs diff un ;
115011: LD_ADDR_VAR 0 12
115015: PUSH
115016: LD_VAR 0 12
115020: PUSH
115021: LD_VAR 0 10
115025: DIFF
115026: ST_TO_ADDR
// end ; end ;
115027: GO 114905
115029: POP
115030: POP
// if solds then
115031: LD_VAR 0 8
115035: IFFALSE 115094
// for i in solds do
115037: LD_ADDR_VAR 0 4
115041: PUSH
115042: LD_VAR 0 8
115046: PUSH
115047: FOR_IN
115048: IFFALSE 115092
// if not GetTag ( i ) then
115050: LD_VAR 0 4
115054: PPUSH
115055: CALL_OW 110
115059: NOT
115060: IFFALSE 115090
// begin defenders := defenders union i ;
115062: LD_ADDR_VAR 0 2
115066: PUSH
115067: LD_VAR 0 2
115071: PUSH
115072: LD_VAR 0 4
115076: UNION
115077: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115078: LD_VAR 0 4
115082: PPUSH
115083: LD_INT 18
115085: PPUSH
115086: CALL_OW 109
// end ;
115090: GO 115047
115092: POP
115093: POP
// repeat wait ( 0 0$2 ) ;
115094: LD_INT 70
115096: PPUSH
115097: CALL_OW 67
// enemy := mc_scan [ base ] ;
115101: LD_ADDR_VAR 0 21
115105: PUSH
115106: LD_EXP 118
115110: PUSH
115111: LD_VAR 0 1
115115: ARRAY
115116: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115117: LD_EXP 95
115121: PUSH
115122: LD_VAR 0 1
115126: ARRAY
115127: NOT
115128: PUSH
115129: LD_EXP 95
115133: PUSH
115134: LD_VAR 0 1
115138: ARRAY
115139: PUSH
115140: EMPTY
115141: EQUAL
115142: OR
115143: IFFALSE 115180
// begin for i in defenders do
115145: LD_ADDR_VAR 0 4
115149: PUSH
115150: LD_VAR 0 2
115154: PUSH
115155: FOR_IN
115156: IFFALSE 115169
// ComStop ( i ) ;
115158: LD_VAR 0 4
115162: PPUSH
115163: CALL_OW 141
115167: GO 115155
115169: POP
115170: POP
// defenders := [ ] ;
115171: LD_ADDR_VAR 0 2
115175: PUSH
115176: EMPTY
115177: ST_TO_ADDR
// exit ;
115178: GO 116629
// end ; for i in defenders do
115180: LD_ADDR_VAR 0 4
115184: PUSH
115185: LD_VAR 0 2
115189: PUSH
115190: FOR_IN
115191: IFFALSE 116089
// begin e := NearestUnitToUnit ( enemy , i ) ;
115193: LD_ADDR_VAR 0 13
115197: PUSH
115198: LD_VAR 0 21
115202: PPUSH
115203: LD_VAR 0 4
115207: PPUSH
115208: CALL_OW 74
115212: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115213: LD_ADDR_VAR 0 7
115217: PUSH
115218: LD_EXP 95
115222: PUSH
115223: LD_VAR 0 1
115227: ARRAY
115228: PPUSH
115229: LD_INT 2
115231: PUSH
115232: LD_INT 30
115234: PUSH
115235: LD_INT 0
115237: PUSH
115238: EMPTY
115239: LIST
115240: LIST
115241: PUSH
115242: LD_INT 30
115244: PUSH
115245: LD_INT 1
115247: PUSH
115248: EMPTY
115249: LIST
115250: LIST
115251: PUSH
115252: EMPTY
115253: LIST
115254: LIST
115255: LIST
115256: PPUSH
115257: CALL_OW 72
115261: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115262: LD_ADDR_VAR 0 16
115266: PUSH
115267: LD_VAR 0 7
115271: NOT
115272: PUSH
115273: LD_VAR 0 7
115277: PPUSH
115278: LD_INT 3
115280: PUSH
115281: LD_INT 24
115283: PUSH
115284: LD_INT 600
115286: PUSH
115287: EMPTY
115288: LIST
115289: LIST
115290: PUSH
115291: EMPTY
115292: LIST
115293: LIST
115294: PPUSH
115295: CALL_OW 72
115299: OR
115300: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115301: LD_VAR 0 4
115305: PPUSH
115306: CALL_OW 247
115310: PUSH
115311: LD_INT 2
115313: DOUBLE
115314: EQUAL
115315: IFTRUE 115319
115317: GO 115715
115319: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115320: LD_VAR 0 4
115324: PPUSH
115325: CALL_OW 256
115329: PUSH
115330: LD_INT 1000
115332: EQUAL
115333: PUSH
115334: LD_VAR 0 4
115338: PPUSH
115339: LD_VAR 0 13
115343: PPUSH
115344: CALL_OW 296
115348: PUSH
115349: LD_INT 40
115351: LESS
115352: PUSH
115353: LD_VAR 0 13
115357: PPUSH
115358: LD_EXP 120
115362: PUSH
115363: LD_VAR 0 1
115367: ARRAY
115368: PPUSH
115369: CALL_OW 308
115373: OR
115374: AND
115375: IFFALSE 115497
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
115377: LD_VAR 0 4
115381: PPUSH
115382: CALL_OW 262
115386: PUSH
115387: LD_INT 1
115389: EQUAL
115390: PUSH
115391: LD_VAR 0 4
115395: PPUSH
115396: CALL_OW 261
115400: PUSH
115401: LD_INT 30
115403: LESS
115404: AND
115405: PUSH
115406: LD_VAR 0 7
115410: AND
115411: IFFALSE 115481
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
115413: LD_VAR 0 4
115417: PPUSH
115418: LD_VAR 0 7
115422: PPUSH
115423: LD_VAR 0 4
115427: PPUSH
115428: CALL_OW 74
115432: PPUSH
115433: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
115437: LD_VAR 0 4
115441: PPUSH
115442: LD_VAR 0 7
115446: PPUSH
115447: LD_VAR 0 4
115451: PPUSH
115452: CALL_OW 74
115456: PPUSH
115457: CALL_OW 296
115461: PUSH
115462: LD_INT 6
115464: LESS
115465: IFFALSE 115479
// SetFuel ( i , 100 ) ;
115467: LD_VAR 0 4
115471: PPUSH
115472: LD_INT 100
115474: PPUSH
115475: CALL_OW 240
// end else
115479: GO 115495
// ComAttackUnit ( i , e ) ;
115481: LD_VAR 0 4
115485: PPUSH
115486: LD_VAR 0 13
115490: PPUSH
115491: CALL_OW 115
// end else
115495: GO 115598
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
115497: LD_VAR 0 13
115501: PPUSH
115502: LD_EXP 120
115506: PUSH
115507: LD_VAR 0 1
115511: ARRAY
115512: PPUSH
115513: CALL_OW 308
115517: NOT
115518: PUSH
115519: LD_VAR 0 4
115523: PPUSH
115524: LD_VAR 0 13
115528: PPUSH
115529: CALL_OW 296
115533: PUSH
115534: LD_INT 40
115536: GREATEREQUAL
115537: AND
115538: PUSH
115539: LD_VAR 0 4
115543: PPUSH
115544: CALL_OW 256
115548: PUSH
115549: LD_INT 650
115551: LESSEQUAL
115552: OR
115553: PUSH
115554: LD_VAR 0 4
115558: PPUSH
115559: LD_EXP 119
115563: PUSH
115564: LD_VAR 0 1
115568: ARRAY
115569: PPUSH
115570: CALL_OW 308
115574: NOT
115575: AND
115576: IFFALSE 115598
// ComMoveToArea ( i , mc_parking [ base ] ) ;
115578: LD_VAR 0 4
115582: PPUSH
115583: LD_EXP 119
115587: PUSH
115588: LD_VAR 0 1
115592: ARRAY
115593: PPUSH
115594: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
115598: LD_VAR 0 4
115602: PPUSH
115603: CALL_OW 256
115607: PUSH
115608: LD_INT 1000
115610: LESS
115611: PUSH
115612: LD_VAR 0 4
115616: PPUSH
115617: CALL_OW 263
115621: PUSH
115622: LD_INT 1
115624: EQUAL
115625: AND
115626: PUSH
115627: LD_VAR 0 4
115631: PPUSH
115632: CALL_OW 311
115636: AND
115637: PUSH
115638: LD_VAR 0 4
115642: PPUSH
115643: LD_EXP 119
115647: PUSH
115648: LD_VAR 0 1
115652: ARRAY
115653: PPUSH
115654: CALL_OW 308
115658: AND
115659: IFFALSE 115713
// begin mech := IsDrivenBy ( i ) ;
115661: LD_ADDR_VAR 0 9
115665: PUSH
115666: LD_VAR 0 4
115670: PPUSH
115671: CALL_OW 311
115675: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
115676: LD_VAR 0 9
115680: PPUSH
115681: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
115685: LD_VAR 0 9
115689: PPUSH
115690: LD_VAR 0 4
115694: PPUSH
115695: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
115699: LD_VAR 0 9
115703: PPUSH
115704: LD_VAR 0 4
115708: PPUSH
115709: CALL_OW 180
// end ; end ; unit_human :
115713: GO 116060
115715: LD_INT 1
115717: DOUBLE
115718: EQUAL
115719: IFTRUE 115723
115721: GO 116059
115723: POP
// begin b := IsInUnit ( i ) ;
115724: LD_ADDR_VAR 0 18
115728: PUSH
115729: LD_VAR 0 4
115733: PPUSH
115734: CALL_OW 310
115738: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
115739: LD_ADDR_VAR 0 19
115743: PUSH
115744: LD_VAR 0 18
115748: NOT
115749: PUSH
115750: LD_VAR 0 18
115754: PPUSH
115755: CALL_OW 266
115759: PUSH
115760: LD_INT 32
115762: PUSH
115763: LD_INT 31
115765: PUSH
115766: EMPTY
115767: LIST
115768: LIST
115769: IN
115770: OR
115771: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
115772: LD_VAR 0 18
115776: PPUSH
115777: CALL_OW 266
115781: PUSH
115782: LD_INT 5
115784: EQUAL
115785: PUSH
115786: LD_VAR 0 4
115790: PPUSH
115791: CALL_OW 257
115795: PUSH
115796: LD_INT 1
115798: PUSH
115799: LD_INT 2
115801: PUSH
115802: LD_INT 3
115804: PUSH
115805: LD_INT 4
115807: PUSH
115808: EMPTY
115809: LIST
115810: LIST
115811: LIST
115812: LIST
115813: IN
115814: AND
115815: IFFALSE 115852
// begin class := AllowSpecClass ( i ) ;
115817: LD_ADDR_VAR 0 20
115821: PUSH
115822: LD_VAR 0 4
115826: PPUSH
115827: CALL 53774 0 1
115831: ST_TO_ADDR
// if class then
115832: LD_VAR 0 20
115836: IFFALSE 115852
// ComChangeProfession ( i , class ) ;
115838: LD_VAR 0 4
115842: PPUSH
115843: LD_VAR 0 20
115847: PPUSH
115848: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
115852: LD_VAR 0 16
115856: PUSH
115857: LD_VAR 0 2
115861: PPUSH
115862: LD_INT 21
115864: PUSH
115865: LD_INT 2
115867: PUSH
115868: EMPTY
115869: LIST
115870: LIST
115871: PPUSH
115872: CALL_OW 72
115876: PUSH
115877: LD_INT 1
115879: LESSEQUAL
115880: OR
115881: PUSH
115882: LD_VAR 0 19
115886: AND
115887: PUSH
115888: LD_VAR 0 4
115892: PUSH
115893: LD_VAR 0 17
115897: IN
115898: NOT
115899: AND
115900: IFFALSE 115993
// begin if b then
115902: LD_VAR 0 18
115906: IFFALSE 115955
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
115908: LD_VAR 0 18
115912: PPUSH
115913: LD_VAR 0 21
115917: PPUSH
115918: LD_VAR 0 18
115922: PPUSH
115923: CALL_OW 74
115927: PPUSH
115928: CALL_OW 296
115932: PUSH
115933: LD_INT 10
115935: LESS
115936: PUSH
115937: LD_VAR 0 18
115941: PPUSH
115942: CALL_OW 461
115946: PUSH
115947: LD_INT 7
115949: NONEQUAL
115950: AND
115951: IFFALSE 115955
// continue ;
115953: GO 115190
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
115955: LD_ADDR_VAR 0 17
115959: PUSH
115960: LD_VAR 0 17
115964: PPUSH
115965: LD_VAR 0 17
115969: PUSH
115970: LD_INT 1
115972: PLUS
115973: PPUSH
115974: LD_VAR 0 4
115978: PPUSH
115979: CALL_OW 1
115983: ST_TO_ADDR
// ComExitBuilding ( i ) ;
115984: LD_VAR 0 4
115988: PPUSH
115989: CALL_OW 122
// end ; if sold_defenders then
115993: LD_VAR 0 17
115997: IFFALSE 116057
// if i in sold_defenders then
115999: LD_VAR 0 4
116003: PUSH
116004: LD_VAR 0 17
116008: IN
116009: IFFALSE 116057
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116011: LD_VAR 0 4
116015: PPUSH
116016: CALL_OW 314
116020: NOT
116021: PUSH
116022: LD_VAR 0 4
116026: PPUSH
116027: LD_VAR 0 13
116031: PPUSH
116032: CALL_OW 296
116036: PUSH
116037: LD_INT 30
116039: LESS
116040: AND
116041: IFFALSE 116057
// ComAttackUnit ( i , e ) ;
116043: LD_VAR 0 4
116047: PPUSH
116048: LD_VAR 0 13
116052: PPUSH
116053: CALL_OW 115
// end ; end ; end ;
116057: GO 116060
116059: POP
// if IsDead ( i ) then
116060: LD_VAR 0 4
116064: PPUSH
116065: CALL_OW 301
116069: IFFALSE 116087
// defenders := defenders diff i ;
116071: LD_ADDR_VAR 0 2
116075: PUSH
116076: LD_VAR 0 2
116080: PUSH
116081: LD_VAR 0 4
116085: DIFF
116086: ST_TO_ADDR
// end ;
116087: GO 115190
116089: POP
116090: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116091: LD_VAR 0 21
116095: NOT
116096: PUSH
116097: LD_VAR 0 2
116101: NOT
116102: OR
116103: PUSH
116104: LD_EXP 95
116108: PUSH
116109: LD_VAR 0 1
116113: ARRAY
116114: NOT
116115: OR
116116: IFFALSE 115094
// MC_Reset ( base , 18 ) ;
116118: LD_VAR 0 1
116122: PPUSH
116123: LD_INT 18
116125: PPUSH
116126: CALL 25516 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116130: LD_ADDR_VAR 0 2
116134: PUSH
116135: LD_VAR 0 2
116139: PUSH
116140: LD_VAR 0 2
116144: PPUSH
116145: LD_INT 2
116147: PUSH
116148: LD_INT 25
116150: PUSH
116151: LD_INT 1
116153: PUSH
116154: EMPTY
116155: LIST
116156: LIST
116157: PUSH
116158: LD_INT 25
116160: PUSH
116161: LD_INT 5
116163: PUSH
116164: EMPTY
116165: LIST
116166: LIST
116167: PUSH
116168: LD_INT 25
116170: PUSH
116171: LD_INT 8
116173: PUSH
116174: EMPTY
116175: LIST
116176: LIST
116177: PUSH
116178: LD_INT 25
116180: PUSH
116181: LD_INT 9
116183: PUSH
116184: EMPTY
116185: LIST
116186: LIST
116187: PUSH
116188: EMPTY
116189: LIST
116190: LIST
116191: LIST
116192: LIST
116193: LIST
116194: PPUSH
116195: CALL_OW 72
116199: DIFF
116200: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116201: LD_VAR 0 21
116205: NOT
116206: PUSH
116207: LD_VAR 0 2
116211: PPUSH
116212: LD_INT 21
116214: PUSH
116215: LD_INT 2
116217: PUSH
116218: EMPTY
116219: LIST
116220: LIST
116221: PPUSH
116222: CALL_OW 72
116226: AND
116227: IFFALSE 116565
// begin tmp := FilterByTag ( defenders , 19 ) ;
116229: LD_ADDR_VAR 0 11
116233: PUSH
116234: LD_VAR 0 2
116238: PPUSH
116239: LD_INT 19
116241: PPUSH
116242: CALL 86243 0 2
116246: ST_TO_ADDR
// if tmp then
116247: LD_VAR 0 11
116251: IFFALSE 116321
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116253: LD_ADDR_VAR 0 11
116257: PUSH
116258: LD_VAR 0 11
116262: PPUSH
116263: LD_INT 25
116265: PUSH
116266: LD_INT 3
116268: PUSH
116269: EMPTY
116270: LIST
116271: LIST
116272: PPUSH
116273: CALL_OW 72
116277: ST_TO_ADDR
// if tmp then
116278: LD_VAR 0 11
116282: IFFALSE 116321
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116284: LD_ADDR_EXP 107
116288: PUSH
116289: LD_EXP 107
116293: PPUSH
116294: LD_VAR 0 1
116298: PPUSH
116299: LD_EXP 107
116303: PUSH
116304: LD_VAR 0 1
116308: ARRAY
116309: PUSH
116310: LD_VAR 0 11
116314: UNION
116315: PPUSH
116316: CALL_OW 1
116320: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116321: LD_VAR 0 1
116325: PPUSH
116326: LD_INT 19
116328: PPUSH
116329: CALL 25516 0 2
// repeat wait ( 0 0$1 ) ;
116333: LD_INT 35
116335: PPUSH
116336: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116340: LD_EXP 95
116344: PUSH
116345: LD_VAR 0 1
116349: ARRAY
116350: NOT
116351: PUSH
116352: LD_EXP 95
116356: PUSH
116357: LD_VAR 0 1
116361: ARRAY
116362: PUSH
116363: EMPTY
116364: EQUAL
116365: OR
116366: IFFALSE 116403
// begin for i in defenders do
116368: LD_ADDR_VAR 0 4
116372: PUSH
116373: LD_VAR 0 2
116377: PUSH
116378: FOR_IN
116379: IFFALSE 116392
// ComStop ( i ) ;
116381: LD_VAR 0 4
116385: PPUSH
116386: CALL_OW 141
116390: GO 116378
116392: POP
116393: POP
// defenders := [ ] ;
116394: LD_ADDR_VAR 0 2
116398: PUSH
116399: EMPTY
116400: ST_TO_ADDR
// exit ;
116401: GO 116629
// end ; for i in defenders do
116403: LD_ADDR_VAR 0 4
116407: PUSH
116408: LD_VAR 0 2
116412: PUSH
116413: FOR_IN
116414: IFFALSE 116503
// begin if not IsInArea ( i , mc_parking [ base ] ) then
116416: LD_VAR 0 4
116420: PPUSH
116421: LD_EXP 119
116425: PUSH
116426: LD_VAR 0 1
116430: ARRAY
116431: PPUSH
116432: CALL_OW 308
116436: NOT
116437: IFFALSE 116461
// ComMoveToArea ( i , mc_parking [ base ] ) else
116439: LD_VAR 0 4
116443: PPUSH
116444: LD_EXP 119
116448: PUSH
116449: LD_VAR 0 1
116453: ARRAY
116454: PPUSH
116455: CALL_OW 113
116459: GO 116501
// if GetControl ( i ) = control_manual then
116461: LD_VAR 0 4
116465: PPUSH
116466: CALL_OW 263
116470: PUSH
116471: LD_INT 1
116473: EQUAL
116474: IFFALSE 116501
// if IsDrivenBy ( i ) then
116476: LD_VAR 0 4
116480: PPUSH
116481: CALL_OW 311
116485: IFFALSE 116501
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
116487: LD_VAR 0 4
116491: PPUSH
116492: CALL_OW 311
116496: PPUSH
116497: CALL_OW 121
// end ;
116501: GO 116413
116503: POP
116504: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
116505: LD_VAR 0 2
116509: PPUSH
116510: LD_INT 95
116512: PUSH
116513: LD_EXP 119
116517: PUSH
116518: LD_VAR 0 1
116522: ARRAY
116523: PUSH
116524: EMPTY
116525: LIST
116526: LIST
116527: PPUSH
116528: CALL_OW 72
116532: PUSH
116533: LD_VAR 0 2
116537: EQUAL
116538: PUSH
116539: LD_EXP 118
116543: PUSH
116544: LD_VAR 0 1
116548: ARRAY
116549: OR
116550: PUSH
116551: LD_EXP 95
116555: PUSH
116556: LD_VAR 0 1
116560: ARRAY
116561: NOT
116562: OR
116563: IFFALSE 116333
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
116565: LD_ADDR_EXP 117
116569: PUSH
116570: LD_EXP 117
116574: PPUSH
116575: LD_VAR 0 1
116579: PPUSH
116580: LD_VAR 0 2
116584: PPUSH
116585: LD_INT 21
116587: PUSH
116588: LD_INT 2
116590: PUSH
116591: EMPTY
116592: LIST
116593: LIST
116594: PPUSH
116595: CALL_OW 72
116599: PPUSH
116600: CALL_OW 1
116604: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
116605: LD_VAR 0 1
116609: PPUSH
116610: LD_INT 19
116612: PPUSH
116613: CALL 25516 0 2
// MC_Reset ( base , 20 ) ;
116617: LD_VAR 0 1
116621: PPUSH
116622: LD_INT 20
116624: PPUSH
116625: CALL 25516 0 2
// end ; end_of_file
116629: LD_VAR 0 3
116633: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
116634: LD_VAR 0 1
116638: PUSH
116639: LD_INT 200
116641: DOUBLE
116642: GREATEREQUAL
116643: IFFALSE 116651
116645: LD_INT 299
116647: DOUBLE
116648: LESSEQUAL
116649: IFTRUE 116653
116651: GO 116685
116653: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
116654: LD_VAR 0 1
116658: PPUSH
116659: LD_VAR 0 2
116663: PPUSH
116664: LD_VAR 0 3
116668: PPUSH
116669: LD_VAR 0 4
116673: PPUSH
116674: LD_VAR 0 5
116678: PPUSH
116679: CALL 105450 0 5
116683: GO 116762
116685: LD_INT 300
116687: DOUBLE
116688: GREATEREQUAL
116689: IFFALSE 116697
116691: LD_INT 399
116693: DOUBLE
116694: LESSEQUAL
116695: IFTRUE 116699
116697: GO 116761
116699: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
116700: LD_VAR 0 1
116704: PPUSH
116705: LD_VAR 0 2
116709: PPUSH
116710: LD_VAR 0 3
116714: PPUSH
116715: LD_VAR 0 4
116719: PPUSH
116720: LD_VAR 0 5
116724: PPUSH
116725: LD_VAR 0 6
116729: PPUSH
116730: LD_VAR 0 7
116734: PPUSH
116735: LD_VAR 0 8
116739: PPUSH
116740: LD_VAR 0 9
116744: PPUSH
116745: LD_VAR 0 10
116749: PPUSH
116750: LD_VAR 0 11
116754: PPUSH
116755: CALL 103348 0 11
116759: GO 116762
116761: POP
// end ;
116762: PPOPN 11
116764: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
116765: LD_VAR 0 1
116769: PPUSH
116770: LD_VAR 0 2
116774: PPUSH
116775: LD_VAR 0 3
116779: PPUSH
116780: LD_VAR 0 4
116784: PPUSH
116785: LD_VAR 0 5
116789: PPUSH
116790: CALL 105442 0 5
// end ; end_of_file
116794: PPOPN 5
116796: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
116797: LD_VAR 0 1
116801: PPUSH
116802: LD_VAR 0 2
116806: PPUSH
116807: LD_VAR 0 3
116811: PPUSH
116812: LD_VAR 0 4
116816: PPUSH
116817: LD_VAR 0 5
116821: PPUSH
116822: LD_VAR 0 6
116826: PPUSH
116827: CALL 91543 0 6
// end ;
116831: PPOPN 6
116833: END
