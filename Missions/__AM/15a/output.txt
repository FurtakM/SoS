// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 20634 0 0
// InitMacro ;
  19: CALL 20802 0 0
// InitNature ;
  23: CALL 17304 0 0
// InitArtifact ;
  27: CALL 17917 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 4625 0 0
// PrepareAlliance ;
  48: CALL 1421 0 0
// PrepareArabian ;
  52: CALL 6393 0 0
// PrepareRussian ;
  56: CALL 8378 0 0
// PrepareLegion ;
  60: CALL 6821 0 0
// Action ;
  64: CALL 10931 0 0
// MC_Start ( ) ;
  68: CALL 22967 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// end ;
 212: LD_VAR 0 1
 216: RET
// export function CustomInitMacro ( ) ; begin
 217: LD_INT 0
 219: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 220: LD_ADDR_EXP 117
 224: PUSH
 225: LD_INT 26
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 4
 233: PUSH
 234: LD_INT 8
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: LIST
 241: LIST
 242: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 243: LD_ADDR_EXP 118
 247: PUSH
 248: LD_INT 27
 250: PUSH
 251: LD_INT 2
 253: PUSH
 254: LD_INT 3
 256: PUSH
 257: LD_INT 7
 259: PUSH
 260: EMPTY
 261: LIST
 262: LIST
 263: LIST
 264: LIST
 265: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 266: LD_INT 1
 268: PPUSH
 269: LD_INT 6
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: LD_INT 9
 277: PUSH
 278: EMPTY
 279: LIST
 280: LIST
 281: LIST
 282: PUSH
 283: LD_OWVAR 67
 287: ARRAY
 288: PPUSH
 289: LD_INT 28
 291: PPUSH
 292: CALL 44509 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 10
 301: PUSH
 302: LD_INT 11
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 15
 310: PUSH
 311: EMPTY
 312: LIST
 313: LIST
 314: LIST
 315: LIST
 316: PPUSH
 317: CALL 45569 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 29
 326: PUSH
 327: EMPTY
 328: LIST
 329: PPUSH
 330: CALL 45662 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 334: LD_ADDR_EXP 122
 338: PUSH
 339: LD_EXP 122
 343: PPUSH
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 22
 349: PUSH
 350: LD_INT 2
 352: PUSH
 353: EMPTY
 354: LIST
 355: LIST
 356: PUSH
 357: LD_INT 25
 359: PUSH
 360: LD_INT 15
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: PPUSH
 371: CALL_OW 69
 375: PPUSH
 376: CALL_OW 1
 380: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 381: LD_INT 1
 383: PPUSH
 384: LD_INT 13
 386: PUSH
 387: LD_INT 2
 389: PUSH
 390: LD_INT 1
 392: PUSH
 393: LD_INT 31
 395: PUSH
 396: EMPTY
 397: LIST
 398: LIST
 399: LIST
 400: LIST
 401: PUSH
 402: LD_INT 13
 404: PUSH
 405: LD_INT 2
 407: PUSH
 408: LD_INT 1
 410: PUSH
 411: LD_INT 31
 413: PUSH
 414: EMPTY
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: PUSH
 420: LD_INT 13
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 1
 428: PUSH
 429: LD_INT 28
 431: PUSH
 432: EMPTY
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: PUSH
 438: LD_INT 13
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 1
 446: PUSH
 447: LD_INT 28
 449: PUSH
 450: EMPTY
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PUSH
 456: LD_INT 13
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 28
 467: PUSH
 468: EMPTY
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: PUSH
 474: LD_INT 13
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 28
 485: PUSH
 486: EMPTY
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: PUSH
 492: LD_INT 13
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 2
 500: PUSH
 501: LD_EXP 78
 505: PUSH
 506: EMPTY
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: PUSH
 512: EMPTY
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PPUSH
 521: CALL 44827 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 525: LD_INT 1
 527: PPUSH
 528: LD_INT 4
 530: PPUSH
 531: CALL 45012 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 10
 540: PUSH
 541: LD_INT 11
 543: PUSH
 544: LD_INT 12
 546: PUSH
 547: LD_INT 14
 549: PUSH
 550: EMPTY
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 45569 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 14
 565: PUSH
 566: EMPTY
 567: LIST
 568: PPUSH
 569: CALL 45662 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 21
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 51
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 22
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 3
 602: PUSH
 603: LD_INT 52
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 22
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 3
 620: PUSH
 621: LD_INT 52
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: LD_INT 24
 632: PUSH
 633: LD_INT 3
 635: PUSH
 636: LD_INT 3
 638: PUSH
 639: LD_INT 47
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: LIST
 646: LIST
 647: PUSH
 648: LD_INT 24
 650: PUSH
 651: LD_INT 3
 653: PUSH
 654: LD_INT 3
 656: PUSH
 657: LD_INT 47
 659: PUSH
 660: EMPTY
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: PUSH
 666: LD_INT 24
 668: PUSH
 669: LD_INT 3
 671: PUSH
 672: LD_INT 3
 674: PUSH
 675: LD_INT 47
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: PUSH
 684: LD_INT 24
 686: PUSH
 687: LD_INT 3
 689: PUSH
 690: LD_INT 3
 692: PUSH
 693: LD_INT 47
 695: PUSH
 696: EMPTY
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_INT 24
 704: PUSH
 705: LD_INT 3
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 47
 713: PUSH
 714: EMPTY
 715: LIST
 716: LIST
 717: LIST
 718: LIST
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PPUSH
 730: CALL 44827 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 734: LD_INT 2
 736: PPUSH
 737: LD_INT 5
 739: PPUSH
 740: CALL 45012 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 744: LD_INT 2
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL 45442 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 754: LD_INT 3
 756: PPUSH
 757: LD_INT 10
 759: PUSH
 760: LD_INT 12
 762: PUSH
 763: LD_INT 15
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_OWVAR 67
 775: ARRAY
 776: PPUSH
 777: LD_INT 24
 779: PPUSH
 780: CALL 44509 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 10
 789: PUSH
 790: LD_INT 11
 792: PUSH
 793: LD_INT 13
 795: PUSH
 796: LD_INT 15
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL 45569 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 809: LD_INT 3
 811: PPUSH
 812: LD_INT 13
 814: PUSH
 815: EMPTY
 816: LIST
 817: PPUSH
 818: CALL 45662 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 822: LD_ADDR_EXP 122
 826: PUSH
 827: LD_EXP 122
 831: PPUSH
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 22
 837: PUSH
 838: LD_INT 8
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: PUSH
 845: LD_INT 25
 847: PUSH
 848: LD_INT 15
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL_OW 69
 863: PPUSH
 864: CALL_OW 1
 868: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 869: LD_INT 3
 871: PPUSH
 872: LD_INT 13
 874: PUSH
 875: LD_INT 2
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 31
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 13
 892: PUSH
 893: LD_INT 2
 895: PUSH
 896: LD_INT 1
 898: PUSH
 899: LD_INT 31
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 13
 910: PUSH
 911: LD_INT 3
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 32
 919: PUSH
 920: EMPTY
 921: LIST
 922: LIST
 923: LIST
 924: LIST
 925: PUSH
 926: LD_INT 14
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 1
 934: PUSH
 935: LD_INT 28
 937: PUSH
 938: EMPTY
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_INT 14
 946: PUSH
 947: LD_INT 1
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 28
 955: PUSH
 956: EMPTY
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: PUSH
 962: LD_INT 14
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 1
 970: PUSH
 971: LD_INT 28
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: PUSH
 980: LD_INT 14
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 1
 988: PUSH
 989: LD_INT 28
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: PUSH
 998: LD_INT 14
1000: PUSH
1001: LD_INT 1
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_EXP 78
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: EMPTY
1019: LIST
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: LIST
1027: PPUSH
1028: CALL 44827 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1032: LD_INT 3
1034: PPUSH
1035: LD_INT 4
1037: PPUSH
1038: CALL 45012 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1042: LD_INT 4
1044: PPUSH
1045: LD_INT 10
1047: PUSH
1048: LD_INT 12
1050: PUSH
1051: LD_INT 11
1053: PUSH
1054: LD_INT 15
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PPUSH
1063: CALL 45569 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1067: LD_INT 4
1069: PPUSH
1070: LD_INT 33
1072: PUSH
1073: EMPTY
1074: LIST
1075: PPUSH
1076: CALL 45662 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1080: LD_INT 4
1082: PPUSH
1083: LD_INT 5
1085: PUSH
1086: LD_INT 6
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: LD_INT 9
1094: PUSH
1095: LD_INT 10
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: PPUSH
1105: CALL 45980 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1109: LD_INT 4
1111: PPUSH
1112: LD_INT 54
1114: PPUSH
1115: LD_INT 85
1117: PPUSH
1118: LD_INT 2
1120: PPUSH
1121: LD_INT 25
1123: PUSH
1124: LD_INT 16
1126: PUSH
1127: LD_INT 17
1129: PUSH
1130: LD_INT 18
1132: PUSH
1133: LD_INT 22
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: PPUSH
1143: CALL 45774 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1147: LD_INT 4
1149: PPUSH
1150: LD_INT 5
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: LD_INT 1
1158: PUSH
1159: LD_INT 7
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 5
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 1
1176: PUSH
1177: LD_INT 6
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 5
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 7
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 5
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 6
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 5
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 3
1230: PUSH
1231: LD_INT 12
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 3
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: LD_INT 3
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 44827 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 4
1275: PPUSH
1276: CALL 45012 0 2
// MC_SetTame ( 4 , powellApe ) ;
1280: LD_INT 4
1282: PPUSH
1283: LD_INT 11
1285: PPUSH
1286: CALL 45393 0 2
// end ;
1290: LD_VAR 0 1
1294: RET
// every 0 0$1 trigger debug do var i ;
1295: LD_EXP 1
1299: IFFALSE 1397
1301: GO 1303
1303: DISABLE
1304: LD_INT 0
1306: PPUSH
// begin enable ;
1307: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1308: LD_ADDR_VAR 0 1
1312: PUSH
1313: LD_INT 22
1315: PUSH
1316: LD_INT 7
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 2
1325: PUSH
1326: LD_INT 21
1328: PUSH
1329: LD_INT 1
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: PUSH
1336: LD_INT 21
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 3
1353: PUSH
1354: LD_INT 24
1356: PUSH
1357: LD_INT 1000
1359: PUSH
1360: EMPTY
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PPUSH
1373: CALL_OW 69
1377: PUSH
1378: FOR_IN
1379: IFFALSE 1395
// SetLives ( i , 1000 ) ;
1381: LD_VAR 0 1
1385: PPUSH
1386: LD_INT 1000
1388: PPUSH
1389: CALL_OW 234
1393: GO 1378
1395: POP
1396: POP
// end ;
1397: PPOPN 1
1399: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1400: LD_EXP 16
1404: PUSH
1405: LD_INT 5
1407: GREATEREQUAL
1408: IFFALSE 1420
1410: GO 1412
1412: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1413: LD_STRING ACH_ARTIFACT
1415: PPUSH
1416: CALL_OW 543
1420: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1421: LD_INT 0
1423: PPUSH
1424: PPUSH
1425: PPUSH
1426: PPUSH
1427: PPUSH
// uc_side := 7 ;
1428: LD_ADDR_OWVAR 20
1432: PUSH
1433: LD_INT 7
1435: ST_TO_ADDR
// tmp := [ ] ;
1436: LD_ADDR_VAR 0 5
1440: PUSH
1441: EMPTY
1442: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1443: LD_ADDR_EXP 17
1447: PUSH
1448: LD_STRING JMM
1450: PPUSH
1451: LD_EXP 1
1455: NOT
1456: PPUSH
1457: LD_STRING 14a_
1459: PPUSH
1460: CALL 51281 0 3
1464: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1465: LD_ADDR_EXP 49
1469: PUSH
1470: LD_STRING Burlak
1472: PPUSH
1473: LD_EXP 1
1477: NOT
1478: PPUSH
1479: LD_STRING 14a_
1481: PPUSH
1482: CALL 51281 0 3
1486: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1487: LD_ADDR_EXP 32
1491: PUSH
1492: LD_STRING Joan
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 13a_
1503: PPUSH
1504: CALL 51281 0 3
1508: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1509: LD_ADDR_EXP 18
1513: PUSH
1514: LD_STRING Roth
1516: PPUSH
1517: LD_EXP 1
1521: NOT
1522: PPUSH
1523: LD_STRING 13a_
1525: PPUSH
1526: CALL 51281 0 3
1530: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1531: LD_ADDR_EXP 35
1535: PUSH
1536: LD_STRING Gossudarov
1538: PPUSH
1539: LD_EXP 1
1543: NOT
1544: PPUSH
1545: LD_STRING 13a_
1547: PPUSH
1548: CALL 51281 0 3
1552: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1553: LD_ADDR_EXP 23
1557: PUSH
1558: LD_STRING Denis
1560: PPUSH
1561: LD_EXP 1
1565: NOT
1566: PPUSH
1567: LD_STRING 13a_
1569: PPUSH
1570: CALL 51281 0 3
1574: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1575: LD_ADDR_EXP 33
1579: PUSH
1580: LD_STRING DeltaDoctor
1582: PPUSH
1583: LD_EXP 1
1587: NOT
1588: PPUSH
1589: LD_STRING 13a_
1591: PPUSH
1592: CALL 51281 0 3
1596: ST_TO_ADDR
// if DeltaDoctor then
1597: LD_EXP 33
1601: IFFALSE 1619
// tmp := tmp ^ DeltaDoctor ;
1603: LD_ADDR_VAR 0 5
1607: PUSH
1608: LD_VAR 0 5
1612: PUSH
1613: LD_EXP 33
1617: ADD
1618: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1619: LD_ADDR_EXP 31
1623: PUSH
1624: LD_STRING Simms
1626: PPUSH
1627: LD_EXP 1
1631: NOT
1632: PPUSH
1633: LD_STRING 13a_
1635: PPUSH
1636: CALL 51281 0 3
1640: ST_TO_ADDR
// if Simms then
1641: LD_EXP 31
1645: IFFALSE 1663
// tmp := tmp ^ Simms ;
1647: LD_ADDR_VAR 0 5
1651: PUSH
1652: LD_VAR 0 5
1656: PUSH
1657: LD_EXP 31
1661: ADD
1662: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1663: LD_ADDR_EXP 29
1667: PUSH
1668: LD_STRING Frank
1670: PPUSH
1671: LD_EXP 1
1675: NOT
1676: PPUSH
1677: LD_STRING 13a_
1679: PPUSH
1680: CALL 51281 0 3
1684: ST_TO_ADDR
// if Frank then
1685: LD_EXP 29
1689: IFFALSE 1707
// tmp := tmp ^ Frank ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_VAR 0 5
1700: PUSH
1701: LD_EXP 29
1705: ADD
1706: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1707: LD_ADDR_EXP 36
1711: PUSH
1712: LD_STRING Kirilenkova
1714: PPUSH
1715: LD_EXP 1
1719: NOT
1720: PPUSH
1721: LD_STRING 13a_
1723: PPUSH
1724: CALL 51281 0 3
1728: ST_TO_ADDR
// if Kirilenkova then
1729: LD_EXP 36
1733: IFFALSE 1751
// tmp := tmp ^ Kirilenkova ;
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 5
1744: PUSH
1745: LD_EXP 36
1749: ADD
1750: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1751: LD_ADDR_EXP 37
1755: PUSH
1756: LD_STRING Titov
1758: PPUSH
1759: LD_EXP 1
1763: NOT
1764: PPUSH
1765: LD_STRING 13a_
1767: PPUSH
1768: CALL 51281 0 3
1772: ST_TO_ADDR
// if Titov then
1773: LD_EXP 37
1777: IFFALSE 1795
// tmp := tmp ^ Titov ;
1779: LD_ADDR_VAR 0 5
1783: PUSH
1784: LD_VAR 0 5
1788: PUSH
1789: LD_EXP 37
1793: ADD
1794: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1795: LD_ADDR_EXP 38
1799: PUSH
1800: LD_STRING Fadeev
1802: PPUSH
1803: LD_EXP 1
1807: NOT
1808: PPUSH
1809: LD_STRING 13a_
1811: PPUSH
1812: CALL 51281 0 3
1816: ST_TO_ADDR
// if Fadeev then
1817: LD_EXP 38
1821: IFFALSE 1839
// tmp := tmp ^ Fadeev ;
1823: LD_ADDR_VAR 0 5
1827: PUSH
1828: LD_VAR 0 5
1832: PUSH
1833: LD_EXP 38
1837: ADD
1838: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1839: LD_ADDR_EXP 39
1843: PUSH
1844: LD_STRING Dolgov
1846: PPUSH
1847: LD_EXP 1
1851: NOT
1852: PPUSH
1853: LD_STRING 13a_
1855: PPUSH
1856: CALL 51281 0 3
1860: ST_TO_ADDR
// if Dolgov then
1861: LD_EXP 39
1865: IFFALSE 1883
// tmp := tmp ^ Dolgov ;
1867: LD_ADDR_VAR 0 5
1871: PUSH
1872: LD_VAR 0 5
1876: PUSH
1877: LD_EXP 39
1881: ADD
1882: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1883: LD_ADDR_EXP 40
1887: PUSH
1888: LD_STRING Petrosyan
1890: PPUSH
1891: LD_EXP 1
1895: NOT
1896: PPUSH
1897: LD_STRING 13a_
1899: PPUSH
1900: CALL 51281 0 3
1904: ST_TO_ADDR
// if Petrosyan then
1905: LD_EXP 40
1909: IFFALSE 1927
// tmp := tmp ^ Petrosyan ;
1911: LD_ADDR_VAR 0 5
1915: PUSH
1916: LD_VAR 0 5
1920: PUSH
1921: LD_EXP 40
1925: ADD
1926: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1927: LD_ADDR_EXP 41
1931: PUSH
1932: LD_STRING Scholtze
1934: PPUSH
1935: LD_EXP 1
1939: NOT
1940: PPUSH
1941: LD_STRING 13a_
1943: PPUSH
1944: CALL 51281 0 3
1948: ST_TO_ADDR
// if Scholtze then
1949: LD_EXP 41
1953: IFFALSE 1971
// tmp := tmp ^ Scholtze ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_VAR 0 5
1964: PUSH
1965: LD_EXP 41
1969: ADD
1970: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1971: LD_ADDR_EXP 42
1975: PUSH
1976: LD_STRING Oblukov
1978: PPUSH
1979: LD_EXP 1
1983: NOT
1984: PPUSH
1985: LD_STRING 13a_
1987: PPUSH
1988: CALL 51281 0 3
1992: ST_TO_ADDR
// if Oblukov then
1993: LD_EXP 42
1997: IFFALSE 2015
// tmp := tmp ^ Oblukov ;
1999: LD_ADDR_VAR 0 5
2003: PUSH
2004: LD_VAR 0 5
2008: PUSH
2009: LD_EXP 42
2013: ADD
2014: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2015: LD_ADDR_EXP 43
2019: PUSH
2020: LD_STRING Kapitsova
2022: PPUSH
2023: LD_EXP 1
2027: NOT
2028: PPUSH
2029: LD_STRING 13a_
2031: PPUSH
2032: CALL 51281 0 3
2036: ST_TO_ADDR
// if Kapitsova then
2037: LD_EXP 43
2041: IFFALSE 2059
// tmp := tmp ^ Kapitsova ;
2043: LD_ADDR_VAR 0 5
2047: PUSH
2048: LD_VAR 0 5
2052: PUSH
2053: LD_EXP 43
2057: ADD
2058: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2059: LD_ADDR_EXP 44
2063: PUSH
2064: LD_STRING Lipshchin
2066: PPUSH
2067: LD_EXP 1
2071: NOT
2072: PPUSH
2073: LD_STRING 13a_
2075: PPUSH
2076: CALL 51281 0 3
2080: ST_TO_ADDR
// if Lipshchin then
2081: LD_EXP 44
2085: IFFALSE 2103
// tmp := tmp ^ Lipshchin ;
2087: LD_ADDR_VAR 0 5
2091: PUSH
2092: LD_VAR 0 5
2096: PUSH
2097: LD_EXP 44
2101: ADD
2102: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2103: LD_ADDR_EXP 45
2107: PUSH
2108: LD_STRING Petrovova
2110: PPUSH
2111: LD_EXP 1
2115: NOT
2116: PPUSH
2117: LD_STRING 13a_
2119: PPUSH
2120: CALL 51281 0 3
2124: ST_TO_ADDR
// if Petrovova then
2125: LD_EXP 45
2129: IFFALSE 2147
// tmp := tmp ^ Petrovova ;
2131: LD_ADDR_VAR 0 5
2135: PUSH
2136: LD_VAR 0 5
2140: PUSH
2141: LD_EXP 45
2145: ADD
2146: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2147: LD_ADDR_EXP 46
2151: PUSH
2152: LD_STRING Kovalyuk
2154: PPUSH
2155: LD_EXP 1
2159: NOT
2160: PPUSH
2161: LD_STRING 13a_
2163: PPUSH
2164: CALL 51281 0 3
2168: ST_TO_ADDR
// if Kovalyuk then
2169: LD_EXP 46
2173: IFFALSE 2191
// tmp := tmp ^ Kovalyuk ;
2175: LD_ADDR_VAR 0 5
2179: PUSH
2180: LD_VAR 0 5
2184: PUSH
2185: LD_EXP 46
2189: ADD
2190: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2191: LD_ADDR_EXP 47
2195: PUSH
2196: LD_STRING Kuzmov
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13a_
2207: PPUSH
2208: CALL 51281 0 3
2212: ST_TO_ADDR
// if Kuzmov then
2213: LD_EXP 47
2217: IFFALSE 2235
// tmp := tmp ^ Kuzmov ;
2219: LD_ADDR_VAR 0 5
2223: PUSH
2224: LD_VAR 0 5
2228: PUSH
2229: LD_EXP 47
2233: ADD
2234: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: LD_STRING Karamazov
2242: PPUSH
2243: LD_EXP 1
2247: NOT
2248: PPUSH
2249: LD_STRING 13a_
2251: PPUSH
2252: CALL 51281 0 3
2256: ST_TO_ADDR
// if Karamazov then
2257: LD_EXP 48
2261: IFFALSE 2279
// tmp := tmp ^ Karamazov ;
2263: LD_ADDR_VAR 0 5
2267: PUSH
2268: LD_VAR 0 5
2272: PUSH
2273: LD_EXP 48
2277: ADD
2278: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: LD_EXP 1
2291: NOT
2292: PPUSH
2293: LD_STRING 13a_
2295: PPUSH
2296: CALL 51281 0 3
2300: ST_TO_ADDR
// if Belkov then
2301: LD_EXP 50
2305: IFFALSE 2323
// tmp := tmp ^ Belkov ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 5
2316: PUSH
2317: LD_EXP 50
2321: ADD
2322: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2323: LD_ADDR_EXP 51
2327: PUSH
2328: LD_STRING Gnyevko
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13a_
2339: PPUSH
2340: CALL 51281 0 3
2344: ST_TO_ADDR
// if Gnyevko then
2345: LD_EXP 51
2349: IFFALSE 2367
// tmp := tmp ^ Gnyevko ;
2351: LD_ADDR_VAR 0 5
2355: PUSH
2356: LD_VAR 0 5
2360: PUSH
2361: LD_EXP 51
2365: ADD
2366: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2367: LD_ADDR_EXP 34
2371: PUSH
2372: LD_STRING Coonie
2374: PPUSH
2375: CALL_OW 25
2379: ST_TO_ADDR
// if not Lisa then
2380: LD_EXP 19
2384: NOT
2385: IFFALSE 2431
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2387: LD_ADDR_EXP 19
2391: PUSH
2392: LD_STRING Lisa
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_STRING 13a_
2403: PPUSH
2404: CALL 51281 0 3
2408: ST_TO_ADDR
// if Lisa then
2409: LD_EXP 19
2413: IFFALSE 2431
// tmp := tmp ^ Lisa ;
2415: LD_ADDR_VAR 0 5
2419: PUSH
2420: LD_VAR 0 5
2424: PUSH
2425: LD_EXP 19
2429: ADD
2430: ST_TO_ADDR
// end ; if not Donaldson then
2431: LD_EXP 20
2435: NOT
2436: IFFALSE 2482
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2438: LD_ADDR_EXP 20
2442: PUSH
2443: LD_STRING Donaldson
2445: PPUSH
2446: LD_EXP 1
2450: NOT
2451: PPUSH
2452: LD_STRING 13a_
2454: PPUSH
2455: CALL 51281 0 3
2459: ST_TO_ADDR
// if Donaldson then
2460: LD_EXP 20
2464: IFFALSE 2482
// tmp := tmp ^ Donaldson ;
2466: LD_ADDR_VAR 0 5
2470: PUSH
2471: LD_VAR 0 5
2475: PUSH
2476: LD_EXP 20
2480: ADD
2481: ST_TO_ADDR
// end ; if not Bobby then
2482: LD_EXP 21
2486: NOT
2487: IFFALSE 2533
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2489: LD_ADDR_EXP 21
2493: PUSH
2494: LD_STRING Bobby
2496: PPUSH
2497: LD_EXP 1
2501: NOT
2502: PPUSH
2503: LD_STRING 13a_
2505: PPUSH
2506: CALL 51281 0 3
2510: ST_TO_ADDR
// if Bobby then
2511: LD_EXP 21
2515: IFFALSE 2533
// tmp := tmp ^ Bobby ;
2517: LD_ADDR_VAR 0 5
2521: PUSH
2522: LD_VAR 0 5
2526: PUSH
2527: LD_EXP 21
2531: ADD
2532: ST_TO_ADDR
// end ; if not Cyrus then
2533: LD_EXP 22
2537: NOT
2538: IFFALSE 2584
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2540: LD_ADDR_EXP 22
2544: PUSH
2545: LD_STRING Cyrus
2547: PPUSH
2548: LD_EXP 1
2552: NOT
2553: PPUSH
2554: LD_STRING 13a_
2556: PPUSH
2557: CALL 51281 0 3
2561: ST_TO_ADDR
// if Cyrus then
2562: LD_EXP 22
2566: IFFALSE 2584
// tmp := tmp ^ Cyrus ;
2568: LD_ADDR_VAR 0 5
2572: PUSH
2573: LD_VAR 0 5
2577: PUSH
2578: LD_EXP 22
2582: ADD
2583: ST_TO_ADDR
// end ; if not Brown then
2584: LD_EXP 24
2588: NOT
2589: IFFALSE 2635
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2591: LD_ADDR_EXP 24
2595: PUSH
2596: LD_STRING Brown
2598: PPUSH
2599: LD_EXP 1
2603: NOT
2604: PPUSH
2605: LD_STRING 13a_
2607: PPUSH
2608: CALL 51281 0 3
2612: ST_TO_ADDR
// if Brown then
2613: LD_EXP 24
2617: IFFALSE 2635
// tmp := tmp ^ Brown ;
2619: LD_ADDR_VAR 0 5
2623: PUSH
2624: LD_VAR 0 5
2628: PUSH
2629: LD_EXP 24
2633: ADD
2634: ST_TO_ADDR
// end ; if not Gladstone then
2635: LD_EXP 25
2639: NOT
2640: IFFALSE 2686
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2642: LD_ADDR_EXP 25
2646: PUSH
2647: LD_STRING Gladstone
2649: PPUSH
2650: LD_EXP 1
2654: NOT
2655: PPUSH
2656: LD_STRING 13a_
2658: PPUSH
2659: CALL 51281 0 3
2663: ST_TO_ADDR
// if Gladstone then
2664: LD_EXP 25
2668: IFFALSE 2686
// tmp := tmp ^ Gladstone ;
2670: LD_ADDR_VAR 0 5
2674: PUSH
2675: LD_VAR 0 5
2679: PUSH
2680: LD_EXP 25
2684: ADD
2685: ST_TO_ADDR
// end ; if not Cornel then
2686: LD_EXP 27
2690: NOT
2691: IFFALSE 2737
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2693: LD_ADDR_EXP 27
2697: PUSH
2698: LD_STRING Cornel
2700: PPUSH
2701: LD_EXP 1
2705: NOT
2706: PPUSH
2707: LD_STRING 13a_
2709: PPUSH
2710: CALL 51281 0 3
2714: ST_TO_ADDR
// if Cornel then
2715: LD_EXP 27
2719: IFFALSE 2737
// tmp := tmp ^ Cornel ;
2721: LD_ADDR_VAR 0 5
2725: PUSH
2726: LD_VAR 0 5
2730: PUSH
2731: LD_EXP 27
2735: ADD
2736: ST_TO_ADDR
// end ; if not Houten then
2737: LD_EXP 26
2741: NOT
2742: IFFALSE 2788
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2744: LD_ADDR_EXP 26
2748: PUSH
2749: LD_STRING Houten
2751: PPUSH
2752: LD_EXP 1
2756: NOT
2757: PPUSH
2758: LD_STRING 13a_
2760: PPUSH
2761: CALL 51281 0 3
2765: ST_TO_ADDR
// if Houten then
2766: LD_EXP 26
2770: IFFALSE 2788
// tmp := tmp ^ Houten ;
2772: LD_ADDR_VAR 0 5
2776: PUSH
2777: LD_VAR 0 5
2781: PUSH
2782: LD_EXP 26
2786: ADD
2787: ST_TO_ADDR
// end ; if not Gary then
2788: LD_EXP 28
2792: NOT
2793: IFFALSE 2839
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2795: LD_ADDR_EXP 28
2799: PUSH
2800: LD_STRING Gary
2802: PPUSH
2803: LD_EXP 1
2807: NOT
2808: PPUSH
2809: LD_STRING 13a_
2811: PPUSH
2812: CALL 51281 0 3
2816: ST_TO_ADDR
// if Gary then
2817: LD_EXP 28
2821: IFFALSE 2839
// tmp := tmp ^ Gary ;
2823: LD_ADDR_VAR 0 5
2827: PUSH
2828: LD_VAR 0 5
2832: PUSH
2833: LD_EXP 28
2837: ADD
2838: ST_TO_ADDR
// end ; if not Kikuchi then
2839: LD_EXP 30
2843: NOT
2844: IFFALSE 2890
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2846: LD_ADDR_EXP 30
2850: PUSH
2851: LD_STRING Kikuchi
2853: PPUSH
2854: LD_EXP 1
2858: NOT
2859: PPUSH
2860: LD_STRING 13a_
2862: PPUSH
2863: CALL 51281 0 3
2867: ST_TO_ADDR
// if Kikuchi then
2868: LD_EXP 30
2872: IFFALSE 2890
// tmp := tmp ^ Kikuchi ;
2874: LD_ADDR_VAR 0 5
2878: PUSH
2879: LD_VAR 0 5
2883: PUSH
2884: LD_EXP 30
2888: ADD
2889: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2890: LD_ADDR_VAR 0 5
2894: PUSH
2895: LD_VAR 0 5
2899: PUSH
2900: LD_STRING 13a_others
2902: PPUSH
2903: CALL_OW 31
2907: UNION
2908: ST_TO_ADDR
// tmp := tmp diff 0 ;
2909: LD_ADDR_VAR 0 5
2913: PUSH
2914: LD_VAR 0 5
2918: PUSH
2919: LD_INT 0
2921: DIFF
2922: ST_TO_ADDR
// if tmp < 15 then
2923: LD_VAR 0 5
2927: PUSH
2928: LD_INT 15
2930: LESS
2931: IFFALSE 3019
// for i = 15 downto tmp do
2933: LD_ADDR_VAR 0 2
2937: PUSH
2938: DOUBLE
2939: LD_INT 15
2941: INC
2942: ST_TO_ADDR
2943: LD_VAR 0 5
2947: PUSH
2948: FOR_DOWNTO
2949: IFFALSE 3017
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2951: LD_ADDR_OWVAR 21
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 3
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: PUSH
2966: LD_INT 1
2968: PPUSH
2969: LD_INT 2
2971: PPUSH
2972: CALL_OW 12
2976: ARRAY
2977: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2978: LD_INT 0
2980: PPUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 4
2986: PPUSH
2987: CALL_OW 12
2991: PPUSH
2992: LD_INT 8
2994: PPUSH
2995: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2999: LD_ADDR_VAR 0 5
3003: PUSH
3004: LD_VAR 0 5
3008: PUSH
3009: CALL_OW 44
3013: ADD
3014: ST_TO_ADDR
// end ;
3015: GO 2948
3017: POP
3018: POP
// if not debug then
3019: LD_EXP 1
3023: NOT
3024: IFFALSE 3196
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 15
3036: PUSH
3037: LD_INT 14
3039: PUSH
3040: LD_INT 13
3042: PUSH
3043: EMPTY
3044: LIST
3045: LIST
3046: LIST
3047: PUSH
3048: LD_OWVAR 67
3052: ARRAY
3053: PPUSH
3054: LD_INT 15
3056: PUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 13
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: LD_OWVAR 67
3072: ARRAY
3073: PPUSH
3074: LD_INT -5
3076: PUSH
3077: LD_EXP 17
3081: PUSH
3082: LD_EXP 49
3086: PUSH
3087: LD_EXP 18
3091: PUSH
3092: LD_EXP 32
3096: PUSH
3097: LD_EXP 23
3101: PUSH
3102: LD_EXP 35
3106: PUSH
3107: LD_INT -2
3109: PUSH
3110: LD_INT -3
3112: PUSH
3113: LD_INT -5
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: LIST
3126: LIST
3127: PUSH
3128: LD_VAR 0 5
3132: ADD
3133: PPUSH
3134: LD_INT 1
3136: PUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 2
3142: PUSH
3143: LD_INT 1
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 3
3152: PUSH
3153: LD_INT 5
3155: PUSH
3156: LD_INT 0
3158: PUSH
3159: LD_INT 3
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: PUSH
3167: LD_INT 9
3169: PUSH
3170: LD_INT 0
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: EMPTY
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: PPUSH
3189: CALL_OW 42
3193: ST_TO_ADDR
3194: GO 3275
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3196: LD_ADDR_VAR 0 4
3200: PUSH
3201: LD_EXP 37
3205: PUSH
3206: LD_EXP 38
3210: PUSH
3211: LD_EXP 39
3215: PUSH
3216: LD_EXP 40
3220: PUSH
3221: LD_EXP 41
3225: PUSH
3226: LD_EXP 42
3230: PUSH
3231: LD_EXP 43
3235: PUSH
3236: LD_EXP 44
3240: PUSH
3241: LD_EXP 45
3245: PUSH
3246: LD_EXP 46
3250: PUSH
3251: LD_EXP 47
3255: PUSH
3256: LD_EXP 48
3260: PUSH
3261: EMPTY
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: ST_TO_ADDR
// uc_nation := 1 ;
3275: LD_ADDR_OWVAR 21
3279: PUSH
3280: LD_INT 1
3282: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3283: LD_INT 5
3285: PPUSH
3286: LD_INT 3
3288: PPUSH
3289: LD_INT 1
3291: PPUSH
3292: LD_INT 6
3294: PPUSH
3295: LD_INT 100
3297: PPUSH
3298: CALL 56145 0 5
// veh := CreateVehicle ;
3302: LD_ADDR_VAR 0 3
3306: PUSH
3307: CALL_OW 45
3311: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_INT 7
3319: NEG
3320: PPUSH
3321: CALL_OW 242
// SetDir ( veh , 3 ) ;
3325: LD_VAR 0 3
3329: PPUSH
3330: LD_INT 3
3332: PPUSH
3333: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3337: LD_VAR 0 3
3341: PPUSH
3342: LD_INT 31
3344: PPUSH
3345: LD_INT 0
3347: PPUSH
3348: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3352: LD_EXP 17
3356: PPUSH
3357: LD_VAR 0 3
3361: PPUSH
3362: CALL_OW 52
// if Joan then
3366: LD_EXP 32
3370: IFFALSE 3442
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3372: LD_INT 3
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 1
3380: PPUSH
3381: LD_INT 11
3383: PPUSH
3384: LD_INT 100
3386: PPUSH
3387: CALL 56145 0 5
// veh := CreateVehicle ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: CALL_OW 45
3400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3401: LD_VAR 0 3
3405: PPUSH
3406: LD_INT 3
3408: PPUSH
3409: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_INT 30
3420: PPUSH
3421: LD_INT 0
3423: PPUSH
3424: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3428: LD_EXP 32
3432: PPUSH
3433: LD_VAR 0 3
3437: PPUSH
3438: CALL_OW 52
// end ; if Roth then
3442: LD_EXP 18
3446: IFFALSE 3518
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3448: LD_INT 3
3450: PPUSH
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 11
3459: PPUSH
3460: LD_INT 100
3462: PPUSH
3463: CALL 56145 0 5
// veh := CreateVehicle ;
3467: LD_ADDR_VAR 0 3
3471: PUSH
3472: CALL_OW 45
3476: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3477: LD_VAR 0 3
3481: PPUSH
3482: LD_INT 3
3484: PPUSH
3485: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3489: LD_VAR 0 3
3493: PPUSH
3494: LD_INT 30
3496: PPUSH
3497: LD_INT 0
3499: PPUSH
3500: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3504: LD_EXP 18
3508: PPUSH
3509: LD_VAR 0 3
3513: PPUSH
3514: CALL_OW 52
// end ; if Denis then
3518: LD_EXP 23
3522: IFFALSE 3594
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3524: LD_INT 5
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 1
3532: PPUSH
3533: LD_INT 9
3535: PPUSH
3536: LD_INT 100
3538: PPUSH
3539: CALL 56145 0 5
// veh := CreateVehicle ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: CALL_OW 45
3552: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3553: LD_VAR 0 3
3557: PPUSH
3558: LD_INT 3
3560: PPUSH
3561: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3565: LD_VAR 0 3
3569: PPUSH
3570: LD_INT 30
3572: PPUSH
3573: LD_INT 0
3575: PPUSH
3576: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3580: LD_EXP 23
3584: PPUSH
3585: LD_VAR 0 3
3589: PPUSH
3590: CALL_OW 52
// end ; uc_nation := 3 ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3602: LD_INT 22
3604: PPUSH
3605: LD_INT 3
3607: PPUSH
3608: LD_INT 1
3610: PPUSH
3611: LD_INT 45
3613: PPUSH
3614: LD_INT 100
3616: PPUSH
3617: CALL 56145 0 5
// veh := CreateVehicle ;
3621: LD_ADDR_VAR 0 3
3625: PUSH
3626: CALL_OW 45
3630: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3631: LD_VAR 0 3
3635: PPUSH
3636: LD_INT 7
3638: NEG
3639: PPUSH
3640: CALL_OW 242
// SetDir ( veh , 3 ) ;
3644: LD_VAR 0 3
3648: PPUSH
3649: LD_INT 3
3651: PPUSH
3652: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3656: LD_VAR 0 3
3660: PPUSH
3661: LD_INT 31
3663: PPUSH
3664: LD_INT 0
3666: PPUSH
3667: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3671: LD_EXP 49
3675: PPUSH
3676: LD_VAR 0 3
3680: PPUSH
3681: CALL_OW 52
// if Gossudarov then
3685: LD_EXP 35
3689: IFFALSE 3776
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3691: LD_INT 22
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 1
3699: PPUSH
3700: LD_INT 51
3702: PPUSH
3703: LD_INT 100
3705: PPUSH
3706: CALL 56145 0 5
// veh := CreateVehicle ;
3710: LD_ADDR_VAR 0 3
3714: PUSH
3715: CALL_OW 45
3719: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3732: LD_VAR 0 3
3736: PPUSH
3737: LD_INT 30
3739: PPUSH
3740: LD_INT 0
3742: PPUSH
3743: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3747: LD_EXP 35
3751: PPUSH
3752: LD_VAR 0 3
3756: PPUSH
3757: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3761: LD_VAR 0 3
3765: PPUSH
3766: LD_INT 1
3768: PPUSH
3769: LD_INT 100
3771: PPUSH
3772: CALL_OW 290
// end ; for i in selected do
3776: LD_ADDR_VAR 0 2
3780: PUSH
3781: LD_VAR 0 4
3785: PUSH
3786: FOR_IN
3787: IFFALSE 4345
// begin uc_nation := GetNation ( i ) ;
3789: LD_ADDR_OWVAR 21
3793: PUSH
3794: LD_VAR 0 2
3798: PPUSH
3799: CALL_OW 248
3803: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3804: LD_VAR 0 2
3808: PUSH
3809: LD_EXP 19
3813: PUSH
3814: LD_EXP 20
3818: PUSH
3819: LD_EXP 22
3823: PUSH
3824: LD_EXP 21
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: LIST
3833: LIST
3834: IN
3835: IFFALSE 3858
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3837: LD_INT 5
3839: PPUSH
3840: LD_INT 3
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_INT 6
3848: PPUSH
3849: LD_INT 100
3851: PPUSH
3852: CALL 56145 0 5
3856: GO 4292
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3858: LD_VAR 0 2
3862: PUSH
3863: LD_EXP 42
3867: PUSH
3868: LD_EXP 47
3872: PUSH
3873: LD_EXP 45
3877: PUSH
3878: LD_EXP 37
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: IN
3889: IFFALSE 3920
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3891: LD_INT 24
3893: PPUSH
3894: LD_INT 1
3896: PPUSH
3897: LD_INT 1
3899: PPUSH
3900: LD_INT 46
3902: PPUSH
3903: LD_INT 65
3905: PPUSH
3906: LD_INT 75
3908: PPUSH
3909: CALL_OW 12
3913: PPUSH
3914: CALL 56145 0 5
3918: GO 4292
// if i = Karamazov then
3920: LD_VAR 0 2
3924: PUSH
3925: LD_EXP 48
3929: EQUAL
3930: IFFALSE 3953
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3932: LD_INT 22
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: LD_INT 52
3943: PPUSH
3944: LD_INT 100
3946: PPUSH
3947: CALL 56145 0 5
3951: GO 4292
// if i = Brown then
3953: LD_VAR 0 2
3957: PUSH
3958: LD_EXP 24
3962: EQUAL
3963: IFFALSE 3986
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3965: LD_INT 3
3967: PPUSH
3968: LD_INT 3
3970: PPUSH
3971: LD_INT 1
3973: PPUSH
3974: LD_INT 13
3976: PPUSH
3977: LD_INT 100
3979: PPUSH
3980: CALL 56145 0 5
3984: GO 4292
// if uc_nation = nation_american then
3986: LD_OWVAR 21
3990: PUSH
3991: LD_INT 1
3993: EQUAL
3994: IFFALSE 4145
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3996: LD_INT 3
3998: PUSH
3999: LD_INT 5
4001: PUSH
4002: LD_INT 5
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PPUSH
4024: LD_INT 1
4026: PUSH
4027: LD_INT 3
4029: PUSH
4030: LD_INT 1
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: LIST
4037: PUSH
4038: LD_OWVAR 21
4042: PUSH
4043: LD_INT 3
4045: MOD
4046: PUSH
4047: LD_INT 1
4049: PLUS
4050: ARRAY
4051: PPUSH
4052: LD_INT 1
4054: PPUSH
4055: LD_INT 11
4057: PUSH
4058: LD_INT 4
4060: PUSH
4061: LD_INT 5
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: PUSH
4069: LD_INT 6
4071: PUSH
4072: LD_INT 7
4074: PUSH
4075: LD_INT 9
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: LIST
4082: PUSH
4083: LD_INT 6
4085: PUSH
4086: LD_INT 9
4088: PUSH
4089: LD_INT 12
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: LIST
4101: PUSH
4102: LD_OWVAR 21
4106: PUSH
4107: LD_INT 3
4109: MOD
4110: PUSH
4111: LD_INT 1
4113: PLUS
4114: ARRAY
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: CALL_OW 12
4126: ARRAY
4127: PPUSH
4128: LD_INT 65
4130: PPUSH
4131: LD_INT 75
4133: PPUSH
4134: CALL_OW 12
4138: PPUSH
4139: CALL 56145 0 5
// end else
4143: GO 4292
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4145: LD_INT 22
4147: PUSH
4148: LD_INT 23
4150: PUSH
4151: LD_INT 23
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PPUSH
4173: LD_INT 1
4175: PUSH
4176: LD_INT 3
4178: PUSH
4179: LD_INT 1
4181: PUSH
4182: EMPTY
4183: LIST
4184: LIST
4185: LIST
4186: PUSH
4187: LD_OWVAR 21
4191: PUSH
4192: LD_INT 3
4194: MOD
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: ARRAY
4200: PPUSH
4201: LD_INT 1
4203: PPUSH
4204: LD_INT 45
4206: PUSH
4207: LD_INT 43
4209: PUSH
4210: LD_INT 44
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: LIST
4217: PUSH
4218: LD_INT 46
4220: PUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 44
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 46
4234: PUSH
4235: LD_INT 43
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: LIST
4250: PUSH
4251: LD_OWVAR 21
4255: PUSH
4256: LD_INT 3
4258: MOD
4259: PUSH
4260: LD_INT 1
4262: PLUS
4263: ARRAY
4264: PUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_INT 3
4270: PPUSH
4271: CALL_OW 12
4275: ARRAY
4276: PPUSH
4277: LD_INT 65
4279: PPUSH
4280: LD_INT 75
4282: PPUSH
4283: CALL_OW 12
4287: PPUSH
4288: CALL 56145 0 5
// end ; veh := CreateVehicle ;
4292: LD_ADDR_VAR 0 3
4296: PUSH
4297: CALL_OW 45
4301: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4302: LD_VAR 0 3
4306: PPUSH
4307: LD_INT 3
4309: PPUSH
4310: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4314: LD_VAR 0 3
4318: PPUSH
4319: LD_INT 30
4321: PPUSH
4322: LD_INT 0
4324: PPUSH
4325: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4329: LD_VAR 0 2
4333: PPUSH
4334: LD_VAR 0 3
4338: PPUSH
4339: CALL_OW 52
// end ;
4343: GO 3786
4345: POP
4346: POP
// if artifactArCaptured then
4347: LD_EXP 9
4351: IFFALSE 4437
// begin uc_nation := nation_american ;
4353: LD_ADDR_OWVAR 21
4357: PUSH
4358: LD_INT 1
4360: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4361: LD_INT 3
4363: PPUSH
4364: LD_INT 3
4366: PPUSH
4367: LD_INT 3
4369: PPUSH
4370: LD_INT 12
4372: PPUSH
4373: LD_INT 100
4375: PPUSH
4376: CALL 56145 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 3
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4390: LD_VAR 0 3
4394: PPUSH
4395: LD_INT 3
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4402: LD_VAR 0 3
4406: PPUSH
4407: LD_INT 198
4409: PPUSH
4410: LD_INT 22
4412: PPUSH
4413: LD_INT 0
4415: PPUSH
4416: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4420: LD_VAR 0 3
4424: PPUSH
4425: LD_INT 4
4427: PPUSH
4428: LD_INT 50
4430: PPUSH
4431: CALL_OW 290
// end else
4435: GO 4456
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4437: LD_INT 4
4439: PPUSH
4440: LD_INT 5
4442: PPUSH
4443: LD_INT 267
4445: PPUSH
4446: LD_INT 226
4448: PPUSH
4449: LD_INT 0
4451: PPUSH
4452: CALL_OW 58
// end ; uc_nation := nation_american ;
4456: LD_ADDR_OWVAR 21
4460: PUSH
4461: LD_INT 1
4463: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4464: LD_INT 3
4466: PPUSH
4467: LD_INT 3
4469: PPUSH
4470: LD_INT 3
4472: PPUSH
4473: LD_INT 12
4475: PPUSH
4476: LD_INT 100
4478: PPUSH
4479: CALL 56145 0 5
// veh := CreateVehicle ;
4483: LD_ADDR_VAR 0 3
4487: PUSH
4488: CALL_OW 45
4492: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4493: LD_VAR 0 3
4497: PPUSH
4498: LD_INT 3
4500: PPUSH
4501: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4505: LD_VAR 0 3
4509: PPUSH
4510: LD_INT 218
4512: PPUSH
4513: LD_INT 23
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4523: LD_VAR 0 3
4527: PPUSH
4528: LD_INT 4
4530: PPUSH
4531: LD_INT 30
4533: PPUSH
4534: CALL_OW 290
// uc_nation := nation_russian ;
4538: LD_ADDR_OWVAR 21
4542: PUSH
4543: LD_INT 3
4545: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4546: LD_INT 22
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: LD_INT 51
4557: PPUSH
4558: LD_INT 100
4560: PPUSH
4561: CALL 56145 0 5
// veh := CreateVehicle ;
4565: LD_ADDR_VAR 0 3
4569: PUSH
4570: CALL_OW 45
4574: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4575: LD_VAR 0 3
4579: PPUSH
4580: LD_INT 3
4582: PPUSH
4583: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4587: LD_VAR 0 3
4591: PPUSH
4592: LD_INT 214
4594: PPUSH
4595: LD_INT 20
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4605: LD_VAR 0 3
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: LD_INT 40
4615: PPUSH
4616: CALL_OW 290
// end ; end_of_file
4620: LD_VAR 0 1
4624: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4625: LD_INT 0
4627: PPUSH
4628: PPUSH
4629: PPUSH
4630: PPUSH
4631: PPUSH
4632: PPUSH
4633: PPUSH
4634: PPUSH
4635: PPUSH
4636: PPUSH
// InitHc ;
4637: CALL_OW 19
// uc_side := 1 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 1
4648: ST_TO_ADDR
// uc_nation := 1 ;
4649: LD_ADDR_OWVAR 21
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: LD_INT 22
4664: PUSH
4665: LD_INT 1
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 21
4674: PUSH
4675: LD_INT 3
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PPUSH
4686: CALL_OW 69
4690: PUSH
4691: FOR_IN
4692: IFFALSE 4708
// SetBLevel ( i , 10 ) ;
4694: LD_VAR 0 2
4698: PPUSH
4699: LD_INT 10
4701: PPUSH
4702: CALL_OW 241
4706: GO 4691
4708: POP
4709: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4710: LD_INT 387
4712: PPUSH
4713: CALL_OW 274
4717: PPUSH
4718: LD_INT 1
4720: PPUSH
4721: LD_INT 7500
4723: PPUSH
4724: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4728: LD_INT 387
4730: PPUSH
4731: CALL_OW 274
4735: PPUSH
4736: LD_INT 2
4738: PPUSH
4739: LD_INT 4000
4741: PPUSH
4742: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4746: LD_INT 387
4748: PPUSH
4749: CALL_OW 274
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 50
4759: PPUSH
4760: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4764: LD_INT 476
4766: PPUSH
4767: CALL_OW 274
4771: PPUSH
4772: LD_INT 1
4774: PPUSH
4775: LD_INT 5500
4777: PPUSH
4778: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4782: LD_INT 476
4784: PPUSH
4785: CALL_OW 274
4789: PPUSH
4790: LD_INT 2
4792: PPUSH
4793: LD_INT 4000
4795: PPUSH
4796: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4800: LD_INT 476
4802: PPUSH
4803: CALL_OW 274
4807: PPUSH
4808: LD_INT 3
4810: PPUSH
4811: LD_INT 10
4813: PPUSH
4814: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4818: LD_ADDR_EXP 52
4822: PUSH
4823: LD_STRING Powell
4825: PPUSH
4826: CALL_OW 25
4830: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4831: LD_EXP 52
4835: PPUSH
4836: LD_INT 387
4838: PPUSH
4839: CALL_OW 52
// tmp := [ ] ;
4843: LD_ADDR_VAR 0 6
4847: PUSH
4848: EMPTY
4849: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4850: LD_ADDR_EXP 19
4854: PUSH
4855: LD_STRING Lisa
4857: PPUSH
4858: LD_EXP 1
4862: NOT
4863: PPUSH
4864: LD_STRING 12p_
4866: PPUSH
4867: CALL 51281 0 3
4871: ST_TO_ADDR
// if Lisa then
4872: LD_EXP 19
4876: IFFALSE 4894
// tmp := tmp ^ Lisa ;
4878: LD_ADDR_VAR 0 6
4882: PUSH
4883: LD_VAR 0 6
4887: PUSH
4888: LD_EXP 19
4892: ADD
4893: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4894: LD_ADDR_EXP 20
4898: PUSH
4899: LD_STRING Donaldson
4901: PPUSH
4902: LD_EXP 1
4906: NOT
4907: PPUSH
4908: LD_STRING 12p_
4910: PPUSH
4911: CALL 51281 0 3
4915: ST_TO_ADDR
// if Donaldson then
4916: LD_EXP 20
4920: IFFALSE 4938
// tmp := tmp ^ Donaldson ;
4922: LD_ADDR_VAR 0 6
4926: PUSH
4927: LD_VAR 0 6
4931: PUSH
4932: LD_EXP 20
4936: ADD
4937: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4938: LD_ADDR_EXP 21
4942: PUSH
4943: LD_STRING Bobby
4945: PPUSH
4946: LD_EXP 1
4950: NOT
4951: PPUSH
4952: LD_STRING 12p_
4954: PPUSH
4955: CALL 51281 0 3
4959: ST_TO_ADDR
// if Bobby then
4960: LD_EXP 21
4964: IFFALSE 4982
// tmp := tmp ^ Bobby ;
4966: LD_ADDR_VAR 0 6
4970: PUSH
4971: LD_VAR 0 6
4975: PUSH
4976: LD_EXP 21
4980: ADD
4981: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4982: LD_ADDR_EXP 22
4986: PUSH
4987: LD_STRING Cyrus
4989: PPUSH
4990: LD_EXP 1
4994: NOT
4995: PPUSH
4996: LD_STRING 12p_
4998: PPUSH
4999: CALL 51281 0 3
5003: ST_TO_ADDR
// if Cyrus then
5004: LD_EXP 22
5008: IFFALSE 5026
// tmp := tmp ^ Cyrus ;
5010: LD_ADDR_VAR 0 6
5014: PUSH
5015: LD_VAR 0 6
5019: PUSH
5020: LD_EXP 22
5024: ADD
5025: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5026: LD_ADDR_EXP 24
5030: PUSH
5031: LD_STRING Brown
5033: PPUSH
5034: LD_EXP 1
5038: NOT
5039: PPUSH
5040: LD_STRING 12p_
5042: PPUSH
5043: CALL 51281 0 3
5047: ST_TO_ADDR
// if Brown then
5048: LD_EXP 24
5052: IFFALSE 5070
// tmp := tmp ^ Brown ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: LD_VAR 0 6
5063: PUSH
5064: LD_EXP 24
5068: ADD
5069: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5070: LD_ADDR_EXP 25
5074: PUSH
5075: LD_STRING Gladstone
5077: PPUSH
5078: LD_EXP 1
5082: NOT
5083: PPUSH
5084: LD_STRING 12p_
5086: PPUSH
5087: CALL 51281 0 3
5091: ST_TO_ADDR
// if Gladstone then
5092: LD_EXP 25
5096: IFFALSE 5114
// tmp := tmp ^ Gladstone ;
5098: LD_ADDR_VAR 0 6
5102: PUSH
5103: LD_VAR 0 6
5107: PUSH
5108: LD_EXP 25
5112: ADD
5113: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5114: LD_ADDR_EXP 26
5118: PUSH
5119: LD_STRING Houten
5121: PPUSH
5122: LD_EXP 1
5126: NOT
5127: PPUSH
5128: LD_STRING 12p_
5130: PPUSH
5131: CALL 51281 0 3
5135: ST_TO_ADDR
// if Houten then
5136: LD_EXP 26
5140: IFFALSE 5158
// tmp := tmp ^ Houten ;
5142: LD_ADDR_VAR 0 6
5146: PUSH
5147: LD_VAR 0 6
5151: PUSH
5152: LD_EXP 26
5156: ADD
5157: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5158: LD_ADDR_EXP 27
5162: PUSH
5163: LD_STRING Cornel
5165: PPUSH
5166: LD_EXP 1
5170: NOT
5171: PPUSH
5172: LD_STRING 12p_
5174: PPUSH
5175: CALL 51281 0 3
5179: ST_TO_ADDR
// if Cornel then
5180: LD_EXP 27
5184: IFFALSE 5202
// tmp := tmp ^ Cornel ;
5186: LD_ADDR_VAR 0 6
5190: PUSH
5191: LD_VAR 0 6
5195: PUSH
5196: LD_EXP 27
5200: ADD
5201: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5202: LD_ADDR_EXP 28
5206: PUSH
5207: LD_STRING Gary
5209: PPUSH
5210: LD_EXP 1
5214: NOT
5215: PPUSH
5216: LD_STRING 12p_
5218: PPUSH
5219: CALL 51281 0 3
5223: ST_TO_ADDR
// if Gary then
5224: LD_EXP 28
5228: IFFALSE 5246
// tmp := tmp ^ Gary ;
5230: LD_ADDR_VAR 0 6
5234: PUSH
5235: LD_VAR 0 6
5239: PUSH
5240: LD_EXP 28
5244: ADD
5245: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5246: LD_ADDR_EXP 30
5250: PUSH
5251: LD_STRING Kikuchi
5253: PPUSH
5254: LD_EXP 1
5258: NOT
5259: PPUSH
5260: LD_STRING 12p_
5262: PPUSH
5263: CALL 51281 0 3
5267: ST_TO_ADDR
// if Kikuchi then
5268: LD_EXP 30
5272: IFFALSE 5290
// tmp := tmp ^ Kikuchi ;
5274: LD_ADDR_VAR 0 6
5278: PUSH
5279: LD_VAR 0 6
5283: PUSH
5284: LD_EXP 30
5288: ADD
5289: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5290: LD_ADDR_VAR 0 6
5294: PUSH
5295: LD_VAR 0 6
5299: PUSH
5300: LD_STRING 12p_others
5302: PPUSH
5303: CALL_OW 31
5307: UNION
5308: ST_TO_ADDR
// if tmp < 36 then
5309: LD_VAR 0 6
5313: PUSH
5314: LD_INT 36
5316: LESS
5317: IFFALSE 5384
// for i = 1 to 36 - tmp do
5319: LD_ADDR_VAR 0 2
5323: PUSH
5324: DOUBLE
5325: LD_INT 1
5327: DEC
5328: ST_TO_ADDR
5329: LD_INT 36
5331: PUSH
5332: LD_VAR 0 6
5336: MINUS
5337: PUSH
5338: FOR_TO
5339: IFFALSE 5382
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5341: LD_INT 1
5343: PPUSH
5344: LD_VAR 0 2
5348: PUSH
5349: LD_INT 4
5351: MOD
5352: PUSH
5353: LD_INT 1
5355: PLUS
5356: PPUSH
5357: LD_INT 10
5359: PPUSH
5360: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: CALL_OW 44
5378: ADD
5379: ST_TO_ADDR
// end ;
5380: GO 5338
5382: POP
5383: POP
// for i in tmp do
5384: LD_ADDR_VAR 0 2
5388: PUSH
5389: LD_VAR 0 6
5393: PUSH
5394: FOR_IN
5395: IFFALSE 5420
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5397: LD_VAR 0 2
5401: PPUSH
5402: LD_INT 62
5404: PPUSH
5405: LD_INT 93
5407: PPUSH
5408: LD_INT 9
5410: PPUSH
5411: LD_INT 0
5413: PPUSH
5414: CALL_OW 50
5418: GO 5394
5420: POP
5421: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5422: LD_ADDR_EXP 93
5426: PUSH
5427: LD_EXP 93
5431: PPUSH
5432: LD_INT 4
5434: PPUSH
5435: LD_INT 22
5437: PUSH
5438: LD_INT 1
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL_OW 69
5449: PUSH
5450: LD_EXP 52
5454: DIFF
5455: PPUSH
5456: CALL_OW 1
5460: ST_TO_ADDR
// uc_side := 0 ;
5461: LD_ADDR_OWVAR 20
5465: PUSH
5466: LD_INT 0
5468: ST_TO_ADDR
// uc_nation := 0 ;
5469: LD_ADDR_OWVAR 21
5473: PUSH
5474: LD_INT 0
5476: ST_TO_ADDR
// for i = 1 to 4 do
5477: LD_ADDR_VAR 0 2
5481: PUSH
5482: DOUBLE
5483: LD_INT 1
5485: DEC
5486: ST_TO_ADDR
5487: LD_INT 4
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5522
// begin InitHc ;
5493: CALL_OW 19
// hc_class := class_apeman ;
5497: LD_ADDR_OWVAR 28
5501: PUSH
5502: LD_INT 12
5504: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5505: CALL_OW 44
5509: PPUSH
5510: LD_INT 11
5512: PPUSH
5513: LD_INT 0
5515: PPUSH
5516: CALL_OW 49
// end ;
5520: GO 5490
5522: POP
5523: POP
// end ;
5524: LD_VAR 0 1
5528: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5529: LD_EXP 4
5533: NOT
5534: PUSH
5535: LD_INT 4
5537: PPUSH
5538: LD_INT 1
5540: PPUSH
5541: CALL 46293 0 2
5545: NOT
5546: AND
5547: IFFALSE 6319
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
// begin enable ;
5557: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5558: LD_INT 22
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: PUSH
5568: LD_INT 23
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PUSH
5578: LD_INT 30
5580: PUSH
5581: LD_INT 3
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: PPUSH
5593: CALL_OW 69
5597: NOT
5598: IFFALSE 5602
// exit ;
5600: GO 6319
// if Prob ( 40 ) then
5602: LD_INT 40
5604: PPUSH
5605: CALL_OW 13
5609: IFFALSE 5736
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5611: LD_INT 4
5613: PPUSH
5614: LD_INT 5
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 7
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 7
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 5
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 7
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 5
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 6
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 5
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 6
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: LD_INT 5
5706: PUSH
5707: LD_INT 1
5709: PUSH
5710: LD_INT 2
5712: PUSH
5713: LD_INT 6
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL 44875 0 2
// end else
5734: GO 5859
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5736: LD_INT 4
5738: PPUSH
5739: LD_INT 5
5741: PUSH
5742: LD_INT 1
5744: PUSH
5745: LD_INT 2
5747: PUSH
5748: LD_INT 7
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: LIST
5755: LIST
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 1
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 9
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: PUSH
5775: LD_INT 5
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 9
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 5
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 2
5801: PUSH
5802: LD_INT 6
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 5
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 2
5819: PUSH
5820: LD_INT 6
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 5
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 2
5837: PUSH
5838: LD_INT 6
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PPUSH
5855: CALL 44875 0 2
// end ; repeat wait ( 0 0$1 ) ;
5859: LD_INT 35
5861: PPUSH
5862: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 1
5871: PPUSH
5872: CALL 46293 0 2
5876: PUSH
5877: LD_INT 6
5879: GREATEREQUAL
5880: IFFALSE 5859
// wait ( 0 0$30 ) ;
5882: LD_INT 1050
5884: PPUSH
5885: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5889: LD_ADDR_VAR 0 2
5893: PUSH
5894: LD_INT 4
5896: PPUSH
5897: LD_INT 1
5899: PPUSH
5900: CALL 46293 0 2
5904: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5905: LD_ADDR_EXP 112
5909: PUSH
5910: LD_EXP 112
5914: PPUSH
5915: LD_INT 4
5917: PPUSH
5918: LD_EXP 112
5922: PUSH
5923: LD_INT 4
5925: ARRAY
5926: PUSH
5927: LD_VAR 0 2
5931: DIFF
5932: PPUSH
5933: CALL_OW 1
5937: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 0
5945: PPUSH
5946: LD_INT 2
5948: PPUSH
5949: CALL_OW 12
5953: ST_TO_ADDR
// if target then
5954: LD_VAR 0 3
5958: IFFALSE 6086
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5960: LD_ADDR_VAR 0 2
5964: PUSH
5965: LD_VAR 0 2
5969: PPUSH
5970: LD_INT 24
5972: PUSH
5973: LD_INT 250
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: ST_TO_ADDR
// for i in tmp do
5985: LD_ADDR_VAR 0 1
5989: PUSH
5990: LD_VAR 0 2
5994: PUSH
5995: FOR_IN
5996: IFFALSE 6036
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5998: LD_VAR 0 1
6002: PPUSH
6003: LD_INT 114
6005: PPUSH
6006: LD_INT 108
6008: PPUSH
6009: CALL_OW 297
6013: PUSH
6014: LD_INT 9
6016: GREATER
6017: IFFALSE 6034
// ComMoveXY ( i , 114 , 108 ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_INT 114
6026: PPUSH
6027: LD_INT 108
6029: PPUSH
6030: CALL_OW 111
6034: GO 5995
6036: POP
6037: POP
// wait ( 0 0$1 ) ;
6038: LD_INT 35
6040: PPUSH
6041: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 92
6052: PUSH
6053: LD_INT 114
6055: PUSH
6056: LD_INT 108
6058: PUSH
6059: LD_INT 9
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL_OW 72
6072: PUSH
6073: LD_VAR 0 2
6077: PUSH
6078: LD_INT 1
6080: MINUS
6081: GREATEREQUAL
6082: IFFALSE 5960
// end else
6084: GO 6210
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6086: LD_ADDR_VAR 0 2
6090: PUSH
6091: LD_VAR 0 2
6095: PPUSH
6096: LD_INT 24
6098: PUSH
6099: LD_INT 250
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PPUSH
6106: CALL_OW 72
6110: ST_TO_ADDR
// for i in tmp do
6111: LD_ADDR_VAR 0 1
6115: PUSH
6116: LD_VAR 0 2
6120: PUSH
6121: FOR_IN
6122: IFFALSE 6162
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6124: LD_VAR 0 1
6128: PPUSH
6129: LD_INT 129
6131: PPUSH
6132: LD_INT 139
6134: PPUSH
6135: CALL_OW 297
6139: PUSH
6140: LD_INT 9
6142: GREATER
6143: IFFALSE 6160
// ComMoveXY ( i , 129 , 139 ) ;
6145: LD_VAR 0 1
6149: PPUSH
6150: LD_INT 129
6152: PPUSH
6153: LD_INT 139
6155: PPUSH
6156: CALL_OW 111
6160: GO 6121
6162: POP
6163: POP
// wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6171: LD_VAR 0 2
6175: PPUSH
6176: LD_INT 92
6178: PUSH
6179: LD_INT 129
6181: PUSH
6182: LD_INT 139
6184: PUSH
6185: LD_INT 9
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PPUSH
6194: CALL_OW 72
6198: PUSH
6199: LD_VAR 0 2
6203: PUSH
6204: LD_INT 1
6206: MINUS
6207: GREATEREQUAL
6208: IFFALSE 6086
// end ; repeat wait ( 0 0$1 ) ;
6210: LD_INT 35
6212: PPUSH
6213: CALL_OW 67
// for i in tmp do
6217: LD_ADDR_VAR 0 1
6221: PUSH
6222: LD_VAR 0 2
6226: PUSH
6227: FOR_IN
6228: IFFALSE 6310
// begin if GetLives ( i ) > 251 then
6230: LD_VAR 0 1
6234: PPUSH
6235: CALL_OW 256
6239: PUSH
6240: LD_INT 251
6242: GREATER
6243: IFFALSE 6281
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6245: LD_VAR 0 1
6249: PPUSH
6250: LD_INT 81
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: PPUSH
6260: CALL_OW 69
6264: PPUSH
6265: LD_VAR 0 1
6269: PPUSH
6270: CALL_OW 74
6274: PPUSH
6275: CALL_OW 115
6279: GO 6308
// if IsDead ( i ) then
6281: LD_VAR 0 1
6285: PPUSH
6286: CALL_OW 301
6290: IFFALSE 6308
// tmp := tmp diff i ;
6292: LD_ADDR_VAR 0 2
6296: PUSH
6297: LD_VAR 0 2
6301: PUSH
6302: LD_VAR 0 1
6306: DIFF
6307: ST_TO_ADDR
// end ;
6308: GO 6227
6310: POP
6311: POP
// until not tmp ;
6312: LD_VAR 0 2
6316: NOT
6317: IFFALSE 6210
// end ;
6319: PPOPN 3
6321: END
// every 30 30$00 trigger not americanDestroyed do
6322: LD_EXP 4
6326: NOT
6327: IFFALSE 6392
6329: GO 6331
6331: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6332: LD_INT 63000
6334: PUSH
6335: LD_INT 42000
6337: PUSH
6338: LD_INT 21000
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PPUSH
6352: CALL_OW 67
// if americanDestroyed then
6356: LD_EXP 4
6360: IFFALSE 6364
// exit ;
6362: GO 6392
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6364: LD_INT 4
6366: PPUSH
6367: LD_INT 5
6369: PUSH
6370: LD_INT 3
6372: PUSH
6373: LD_INT 1
6375: PUSH
6376: LD_INT 8
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: PPUSH
6388: CALL 44875 0 2
// end ; end_of_file
6392: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6393: LD_INT 0
6395: PPUSH
6396: PPUSH
6397: PPUSH
6398: PPUSH
6399: PPUSH
// side := 2 ;
6400: LD_ADDR_VAR 0 5
6404: PUSH
6405: LD_INT 2
6407: ST_TO_ADDR
// InitHc ;
6408: CALL_OW 19
// uc_side := side ;
6412: LD_ADDR_OWVAR 20
6416: PUSH
6417: LD_VAR 0 5
6421: ST_TO_ADDR
// uc_nation := 2 ;
6422: LD_ADDR_OWVAR 21
6426: PUSH
6427: LD_INT 2
6429: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6430: LD_ADDR_VAR 0 2
6434: PUSH
6435: LD_INT 22
6437: PUSH
6438: LD_INT 2
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 21
6447: PUSH
6448: LD_INT 3
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: PPUSH
6459: CALL_OW 69
6463: PUSH
6464: FOR_IN
6465: IFFALSE 6481
// SetBLevel ( i , 10 ) ;
6467: LD_VAR 0 2
6471: PPUSH
6472: LD_INT 10
6474: PPUSH
6475: CALL_OW 241
6479: GO 6464
6481: POP
6482: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6483: LD_ADDR_VAR 0 4
6487: PUSH
6488: LD_INT 22
6490: PUSH
6491: LD_VAR 0 5
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 30
6502: PUSH
6503: LD_INT 32
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 58
6512: PUSH
6513: EMPTY
6514: LIST
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: PPUSH
6521: CALL_OW 69
6525: ST_TO_ADDR
// for i = 1 to 10 do
6526: LD_ADDR_VAR 0 2
6530: PUSH
6531: DOUBLE
6532: LD_INT 1
6534: DEC
6535: ST_TO_ADDR
6536: LD_INT 10
6538: PUSH
6539: FOR_TO
6540: IFFALSE 6612
// begin uc_nation := nation_nature ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 0
6549: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6550: LD_ADDR_OWVAR 28
6554: PUSH
6555: LD_INT 15
6557: ST_TO_ADDR
// hc_gallery :=  ;
6558: LD_ADDR_OWVAR 33
6562: PUSH
6563: LD_STRING 
6565: ST_TO_ADDR
// hc_name :=  ;
6566: LD_ADDR_OWVAR 26
6570: PUSH
6571: LD_STRING 
6573: ST_TO_ADDR
// un := CreateHuman ;
6574: LD_ADDR_VAR 0 3
6578: PUSH
6579: CALL_OW 44
6583: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6584: LD_VAR 0 3
6588: PPUSH
6589: LD_VAR 0 4
6593: PUSH
6594: LD_VAR 0 4
6598: PUSH
6599: LD_VAR 0 2
6603: MINUS
6604: ARRAY
6605: PPUSH
6606: CALL_OW 52
// end ;
6610: GO 6539
6612: POP
6613: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6614: LD_INT 503
6616: PPUSH
6617: LD_INT 27
6619: PPUSH
6620: LD_STRING 
6622: PPUSH
6623: LD_INT 8
6625: PUSH
6626: LD_INT 9
6628: PUSH
6629: LD_INT 10
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: LIST
6636: PUSH
6637: LD_OWVAR 67
6641: ARRAY
6642: PPUSH
6643: LD_INT 3000
6645: PUSH
6646: LD_INT 500
6648: PUSH
6649: LD_INT 150
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PPUSH
6657: LD_INT 16
6659: PUSH
6660: LD_INT 6
6662: PUSH
6663: LD_INT 6
6665: PUSH
6666: LD_INT 6
6668: PUSH
6669: EMPTY
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL 59591 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6679: LD_ADDR_EXP 93
6683: PUSH
6684: LD_EXP 93
6688: PPUSH
6689: LD_INT 1
6691: PPUSH
6692: LD_INT 22
6694: PUSH
6695: LD_VAR 0 5
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PUSH
6704: LD_INT 23
6706: PUSH
6707: LD_INT 2
6709: PUSH
6710: EMPTY
6711: LIST
6712: LIST
6713: PUSH
6714: LD_INT 3
6716: PUSH
6717: LD_INT 21
6719: PUSH
6720: LD_INT 2
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: LIST
6735: PPUSH
6736: CALL_OW 69
6740: PPUSH
6741: CALL_OW 1
6745: ST_TO_ADDR
// end ;
6746: LD_VAR 0 1
6750: RET
// export Omar ; export function PrepareOmarAli ; begin
6751: LD_INT 0
6753: PPUSH
// uc_side := 5 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 5
6761: ST_TO_ADDR
// uc_nation := 2 ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_INT 2
6769: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6770: LD_ADDR_EXP 53
6774: PUSH
6775: LD_STRING Omar
6777: PPUSH
6778: CALL_OW 25
6782: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6783: LD_EXP 53
6787: PPUSH
6788: LD_INT 330
6790: PPUSH
6791: LD_INT 244
6793: PPUSH
6794: LD_INT 0
6796: PPUSH
6797: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6801: LD_EXP 53
6805: PPUSH
6806: LD_INT 252
6808: PPUSH
6809: LD_INT 220
6811: PPUSH
6812: CALL_OW 111
// end ; end_of_file
6816: LD_VAR 0 1
6820: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6821: LD_INT 0
6823: PPUSH
6824: PPUSH
6825: PPUSH
6826: PPUSH
6827: PPUSH
// side := 8 ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_INT 8
6835: ST_TO_ADDR
// InitHc ;
6836: CALL_OW 19
// uc_side := side ;
6840: LD_ADDR_OWVAR 20
6844: PUSH
6845: LD_VAR 0 3
6849: ST_TO_ADDR
// uc_nation := 2 ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 2
6857: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6858: LD_ADDR_VAR 0 2
6862: PUSH
6863: LD_INT 22
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: LD_INT 21
6877: PUSH
6878: LD_INT 3
6880: PUSH
6881: EMPTY
6882: LIST
6883: LIST
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: PPUSH
6889: CALL_OW 69
6893: PUSH
6894: FOR_IN
6895: IFFALSE 6911
// SetBLevel ( i , 10 ) ;
6897: LD_VAR 0 2
6901: PPUSH
6902: LD_INT 10
6904: PPUSH
6905: CALL_OW 241
6909: GO 6894
6911: POP
6912: POP
// Schulz := NewCharacter ( Schulz ) ;
6913: LD_ADDR_EXP 54
6917: PUSH
6918: LD_STRING Schulz
6920: PPUSH
6921: CALL_OW 25
6925: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6926: LD_ADDR_EXP 55
6930: PUSH
6931: LD_STRING Kozlov
6933: PPUSH
6934: LD_INT 0
6936: PPUSH
6937: LD_STRING 
6939: PPUSH
6940: CALL 51281 0 3
6944: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6945: LD_EXP 55
6949: PPUSH
6950: LD_INT 22
6952: PUSH
6953: LD_INT 8
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: LD_INT 23
6962: PUSH
6963: LD_INT 3
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 30
6972: PUSH
6973: LD_INT 8
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: LD_INT 1
6992: ARRAY
6993: PPUSH
6994: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6998: LD_EXP 55
7002: PPUSH
7003: LD_INT 3
7005: PPUSH
7006: LD_INT 10
7008: PPUSH
7009: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7013: LD_ADDR_VAR 0 5
7017: PUSH
7018: LD_INT 22
7020: PUSH
7021: LD_VAR 0 3
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: PUSH
7030: LD_INT 30
7032: PUSH
7033: LD_INT 32
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 58
7042: PUSH
7043: EMPTY
7044: LIST
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: PPUSH
7051: CALL_OW 69
7055: ST_TO_ADDR
// for i = 1 to 10 do
7056: LD_ADDR_VAR 0 2
7060: PUSH
7061: DOUBLE
7062: LD_INT 1
7064: DEC
7065: ST_TO_ADDR
7066: LD_INT 10
7068: PUSH
7069: FOR_TO
7070: IFFALSE 7142
// begin uc_nation := nation_nature ;
7072: LD_ADDR_OWVAR 21
7076: PUSH
7077: LD_INT 0
7079: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7080: LD_ADDR_OWVAR 28
7084: PUSH
7085: LD_INT 15
7087: ST_TO_ADDR
// hc_gallery :=  ;
7088: LD_ADDR_OWVAR 33
7092: PUSH
7093: LD_STRING 
7095: ST_TO_ADDR
// hc_name :=  ;
7096: LD_ADDR_OWVAR 26
7100: PUSH
7101: LD_STRING 
7103: ST_TO_ADDR
// un := CreateHuman ;
7104: LD_ADDR_VAR 0 4
7108: PUSH
7109: CALL_OW 44
7113: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7114: LD_VAR 0 4
7118: PPUSH
7119: LD_VAR 0 5
7123: PUSH
7124: LD_VAR 0 5
7128: PUSH
7129: LD_VAR 0 2
7133: MINUS
7134: ARRAY
7135: PPUSH
7136: CALL_OW 52
// end ;
7140: GO 7069
7142: POP
7143: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7144: LD_INT 324
7146: PPUSH
7147: LD_INT 3
7149: PPUSH
7150: LD_STRING 
7152: PPUSH
7153: LD_INT 8
7155: PUSH
7156: LD_INT 9
7158: PUSH
7159: LD_INT 10
7161: PUSH
7162: EMPTY
7163: LIST
7164: LIST
7165: LIST
7166: PUSH
7167: LD_OWVAR 67
7171: ARRAY
7172: PPUSH
7173: LD_INT 3000
7175: PUSH
7176: LD_INT 500
7178: PUSH
7179: LD_INT 150
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: LIST
7186: PPUSH
7187: LD_INT 16
7189: PUSH
7190: LD_INT 6
7192: PUSH
7193: LD_INT 6
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: EMPTY
7200: LIST
7201: LIST
7202: LIST
7203: LIST
7204: PPUSH
7205: CALL 59591 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7209: LD_ADDR_EXP 93
7213: PUSH
7214: LD_EXP 93
7218: PPUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 22
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: PUSH
7234: LD_INT 23
7236: PUSH
7237: LD_INT 2
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 21
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: LD_EXP 54
7275: DIFF
7276: PPUSH
7277: CALL_OW 1
7281: ST_TO_ADDR
// end ;
7282: LD_VAR 0 1
7286: RET
// export function BuildKozlovBomb ; begin
7287: LD_INT 0
7289: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7290: LD_INT 332
7292: PPUSH
7293: CALL_OW 302
7297: NOT
7298: PUSH
7299: LD_INT 336
7301: PPUSH
7302: CALL_OW 302
7306: NOT
7307: OR
7308: IFFALSE 7312
// exit ;
7310: GO 7409
// ComChangeProfession ( Kozlov , 4 ) ;
7312: LD_EXP 55
7316: PPUSH
7317: LD_INT 4
7319: PPUSH
7320: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7324: LD_INT 336
7326: PPUSH
7327: LD_INT 25
7329: PPUSH
7330: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7334: LD_INT 35
7336: PPUSH
7337: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7341: LD_INT 25
7343: PPUSH
7344: LD_INT 8
7346: PPUSH
7347: CALL_OW 321
7351: PUSH
7352: LD_INT 2
7354: EQUAL
7355: IFFALSE 7334
// ComExitBuilding ( Kozlov ) ;
7357: LD_EXP 55
7361: PPUSH
7362: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7366: LD_EXP 55
7370: PPUSH
7371: LD_INT 332
7373: PPUSH
7374: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7378: LD_EXP 55
7382: PPUSH
7383: LD_INT 3
7385: PPUSH
7386: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7390: LD_INT 332
7392: PPUSH
7393: LD_INT 23
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 48
7404: PPUSH
7405: CALL_OW 125
// end ;
7409: LD_VAR 0 1
7413: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7414: LD_EXP 3
7418: NOT
7419: PUSH
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 1
7425: PPUSH
7426: CALL 46293 0 2
7430: NOT
7431: AND
7432: IFFALSE 8272
7434: GO 7436
7436: DISABLE
7437: LD_INT 0
7439: PPUSH
7440: PPUSH
7441: PPUSH
// begin enable ;
7442: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7443: LD_INT 22
7445: PUSH
7446: LD_INT 8
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 23
7455: PUSH
7456: LD_INT 2
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 30
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: PPUSH
7478: CALL_OW 69
7482: NOT
7483: IFFALSE 7487
// exit ;
7485: GO 8272
// if Prob ( 40 ) then
7487: LD_INT 40
7489: PPUSH
7490: CALL_OW 13
7494: IFFALSE 7621
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7496: LD_INT 3
7498: PPUSH
7499: LD_INT 14
7501: PUSH
7502: LD_INT 1
7504: PUSH
7505: LD_INT 2
7507: PUSH
7508: LD_INT 28
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 14
7519: PUSH
7520: LD_INT 1
7522: PUSH
7523: LD_INT 2
7525: PUSH
7526: LD_INT 28
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: LIST
7533: LIST
7534: PUSH
7535: LD_INT 14
7537: PUSH
7538: LD_INT 1
7540: PUSH
7541: LD_INT 2
7543: PUSH
7544: LD_INT 28
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: PUSH
7553: LD_INT 14
7555: PUSH
7556: LD_INT 1
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 28
7564: PUSH
7565: EMPTY
7566: LIST
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 14
7573: PUSH
7574: LD_INT 1
7576: PUSH
7577: LD_INT 2
7579: PUSH
7580: LD_INT 28
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 14
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: LD_INT 26
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL 44875 0 2
// end else
7619: GO 7812
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 27
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 26
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: PUSH
7647: LD_OWVAR 67
7651: ARRAY
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 14
7661: PUSH
7662: LD_INT 1
7664: PUSH
7665: LD_INT 2
7667: PUSH
7668: LD_INT 27
7670: PUSH
7671: LD_INT 26
7673: PUSH
7674: LD_INT 26
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: PUSH
7682: LD_OWVAR 67
7686: ARRAY
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 14
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 26
7705: PUSH
7706: LD_INT 26
7708: PUSH
7709: LD_INT 29
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: PUSH
7717: LD_OWVAR 67
7721: ARRAY
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: LIST
7727: LIST
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 1
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 26
7740: PUSH
7741: LD_INT 29
7743: PUSH
7744: LD_INT 29
7746: PUSH
7747: EMPTY
7748: LIST
7749: LIST
7750: LIST
7751: PUSH
7752: LD_OWVAR 67
7756: ARRAY
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: LIST
7762: LIST
7763: PUSH
7764: LD_INT 13
7766: PUSH
7767: LD_INT 1
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: LD_INT 29
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 14
7784: PUSH
7785: LD_INT 1
7787: PUSH
7788: LD_INT 2
7790: PUSH
7791: LD_INT 26
7793: PUSH
7794: EMPTY
7795: LIST
7796: LIST
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PPUSH
7808: CALL 44875 0 2
// end ; repeat wait ( 0 0$1 ) ;
7812: LD_INT 35
7814: PPUSH
7815: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7819: LD_INT 3
7821: PPUSH
7822: LD_INT 1
7824: PPUSH
7825: CALL 46293 0 2
7829: PUSH
7830: LD_INT 6
7832: GREATEREQUAL
7833: IFFALSE 7812
// wait ( 0 0$30 ) ;
7835: LD_INT 1050
7837: PPUSH
7838: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7842: LD_ADDR_VAR 0 2
7846: PUSH
7847: LD_INT 3
7849: PPUSH
7850: LD_INT 1
7852: PPUSH
7853: CALL 46293 0 2
7857: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7858: LD_ADDR_EXP 112
7862: PUSH
7863: LD_EXP 112
7867: PPUSH
7868: LD_INT 3
7870: PPUSH
7871: LD_EXP 112
7875: PUSH
7876: LD_INT 3
7878: ARRAY
7879: PUSH
7880: LD_VAR 0 2
7884: DIFF
7885: PPUSH
7886: CALL_OW 1
7890: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7891: LD_ADDR_VAR 0 3
7895: PUSH
7896: LD_INT 0
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ST_TO_ADDR
// if target then
7907: LD_VAR 0 3
7911: IFFALSE 8039
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7913: LD_ADDR_VAR 0 2
7917: PUSH
7918: LD_VAR 0 2
7922: PPUSH
7923: LD_INT 24
7925: PUSH
7926: LD_INT 250
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: ST_TO_ADDR
// for i in tmp do
7938: LD_ADDR_VAR 0 1
7942: PUSH
7943: LD_VAR 0 2
7947: PUSH
7948: FOR_IN
7949: IFFALSE 7989
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7951: LD_VAR 0 1
7955: PPUSH
7956: LD_INT 89
7958: PPUSH
7959: LD_INT 71
7961: PPUSH
7962: CALL_OW 297
7966: PUSH
7967: LD_INT 9
7969: GREATER
7970: IFFALSE 7987
// ComMoveXY ( i , 89 , 71 ) ;
7972: LD_VAR 0 1
7976: PPUSH
7977: LD_INT 89
7979: PPUSH
7980: LD_INT 71
7982: PPUSH
7983: CALL_OW 111
7987: GO 7948
7989: POP
7990: POP
// wait ( 0 0$1 ) ;
7991: LD_INT 35
7993: PPUSH
7994: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 92
8005: PUSH
8006: LD_INT 89
8008: PUSH
8009: LD_INT 71
8011: PUSH
8012: LD_INT 9
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 72
8025: PUSH
8026: LD_VAR 0 2
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: GREATEREQUAL
8035: IFFALSE 7913
// end else
8037: GO 8163
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_VAR 0 2
8048: PPUSH
8049: LD_INT 24
8051: PUSH
8052: LD_INT 250
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: ST_TO_ADDR
// for i in tmp do
8064: LD_ADDR_VAR 0 1
8068: PUSH
8069: LD_VAR 0 2
8073: PUSH
8074: FOR_IN
8075: IFFALSE 8115
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8077: LD_VAR 0 1
8081: PPUSH
8082: LD_INT 147
8084: PPUSH
8085: LD_INT 4
8087: PPUSH
8088: CALL_OW 297
8092: PUSH
8093: LD_INT 9
8095: GREATER
8096: IFFALSE 8113
// ComMoveXY ( i , 147 , 4 ) ;
8098: LD_VAR 0 1
8102: PPUSH
8103: LD_INT 147
8105: PPUSH
8106: LD_INT 4
8108: PPUSH
8109: CALL_OW 111
8113: GO 8074
8115: POP
8116: POP
// wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8124: LD_VAR 0 2
8128: PPUSH
8129: LD_INT 92
8131: PUSH
8132: LD_INT 147
8134: PUSH
8135: LD_INT 4
8137: PUSH
8138: LD_INT 9
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: PPUSH
8147: CALL_OW 72
8151: PUSH
8152: LD_VAR 0 2
8156: PUSH
8157: LD_INT 1
8159: MINUS
8160: GREATEREQUAL
8161: IFFALSE 8039
// end ; repeat wait ( 0 0$1 ) ;
8163: LD_INT 35
8165: PPUSH
8166: CALL_OW 67
// for i in tmp do
8170: LD_ADDR_VAR 0 1
8174: PUSH
8175: LD_VAR 0 2
8179: PUSH
8180: FOR_IN
8181: IFFALSE 8263
// begin if GetLives ( i ) > 251 then
8183: LD_VAR 0 1
8187: PPUSH
8188: CALL_OW 256
8192: PUSH
8193: LD_INT 251
8195: GREATER
8196: IFFALSE 8234
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8198: LD_VAR 0 1
8202: PPUSH
8203: LD_INT 81
8205: PUSH
8206: LD_INT 8
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 69
8217: PPUSH
8218: LD_VAR 0 1
8222: PPUSH
8223: CALL_OW 74
8227: PPUSH
8228: CALL_OW 115
8232: GO 8261
// if IsDead ( i ) then
8234: LD_VAR 0 1
8238: PPUSH
8239: CALL_OW 301
8243: IFFALSE 8261
// tmp := tmp diff i ;
8245: LD_ADDR_VAR 0 2
8249: PUSH
8250: LD_VAR 0 2
8254: PUSH
8255: LD_VAR 0 1
8259: DIFF
8260: ST_TO_ADDR
// end ;
8261: GO 8180
8263: POP
8264: POP
// until not tmp ;
8265: LD_VAR 0 2
8269: NOT
8270: IFFALSE 8163
// end ;
8272: PPOPN 3
8274: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8275: LD_EXP 55
8279: PPUSH
8280: CALL_OW 302
8284: PUSH
8285: LD_EXP 3
8289: NOT
8290: AND
8291: IFFALSE 8300
8293: GO 8295
8295: DISABLE
// BuildKozlovBomb ;
8296: CALL 7287 0 0
8300: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8301: LD_INT 22
8303: PUSH
8304: LD_INT 8
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 34
8313: PUSH
8314: LD_INT 48
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: PUSH
8321: EMPTY
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 69
8329: IFFALSE 8377
8331: GO 8333
8333: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8334: LD_INT 22
8336: PUSH
8337: LD_INT 8
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PUSH
8344: LD_INT 34
8346: PUSH
8347: LD_INT 48
8349: PUSH
8350: EMPTY
8351: LIST
8352: LIST
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PPUSH
8358: CALL_OW 69
8362: PUSH
8363: LD_INT 1
8365: ARRAY
8366: PPUSH
8367: LD_INT 173
8369: PPUSH
8370: LD_INT 96
8372: PPUSH
8373: CALL_OW 116
// end ; end_of_file
8377: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
8384: PPUSH
8385: PPUSH
8386: PPUSH
8387: PPUSH
8388: PPUSH
// side := 3 ;
8389: LD_ADDR_VAR 0 6
8393: PUSH
8394: LD_INT 3
8396: ST_TO_ADDR
// InitHc ;
8397: CALL_OW 19
// uc_side := side ;
8401: LD_ADDR_OWVAR 20
8405: PUSH
8406: LD_VAR 0 6
8410: ST_TO_ADDR
// uc_nation := 3 ;
8411: LD_ADDR_OWVAR 21
8415: PUSH
8416: LD_INT 3
8418: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8419: LD_ADDR_VAR 0 2
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_VAR 0 6
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PUSH
8436: LD_INT 21
8438: PUSH
8439: LD_INT 3
8441: PUSH
8442: EMPTY
8443: LIST
8444: LIST
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 69
8454: PUSH
8455: FOR_IN
8456: IFFALSE 8472
// SetBLevel ( i , 10 ) ;
8458: LD_VAR 0 2
8462: PPUSH
8463: LD_INT 10
8465: PPUSH
8466: CALL_OW 241
8470: GO 8455
8472: POP
8473: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8474: LD_ADDR_VAR 0 9
8478: PUSH
8479: LD_INT 22
8481: PUSH
8482: LD_VAR 0 6
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PUSH
8491: LD_INT 30
8493: PUSH
8494: LD_INT 34
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PPUSH
8505: CALL_OW 69
8509: ST_TO_ADDR
// if teleport then
8510: LD_VAR 0 9
8514: IFFALSE 8535
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8516: LD_VAR 0 9
8520: PUSH
8521: LD_INT 1
8523: ARRAY
8524: PPUSH
8525: LD_INT 123
8527: PPUSH
8528: LD_INT 122
8530: PPUSH
8531: CALL_OW 243
// hc_importance := 0 ;
8535: LD_ADDR_OWVAR 32
8539: PUSH
8540: LD_INT 0
8542: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8543: LD_ADDR_EXP 56
8547: PUSH
8548: LD_STRING Platonov
8550: PPUSH
8551: CALL_OW 25
8555: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8556: LD_ADDR_EXP 57
8560: PUSH
8561: LD_STRING Yakotich
8563: PPUSH
8564: CALL_OW 25
8568: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8569: LD_ADDR_EXP 58
8573: PUSH
8574: LD_STRING Gleb
8576: PPUSH
8577: CALL_OW 25
8581: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8582: LD_STRING 03_Cornel
8584: PPUSH
8585: CALL_OW 28
8589: IFFALSE 8637
// begin Bierezov := NewCharacter ( Mikhail ) ;
8591: LD_ADDR_EXP 59
8595: PUSH
8596: LD_STRING Mikhail
8598: PPUSH
8599: CALL_OW 25
8603: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8604: LD_EXP 59
8608: PPUSH
8609: LD_INT 197
8611: PPUSH
8612: LD_INT 111
8614: PPUSH
8615: LD_INT 9
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8625: LD_EXP 59
8629: PPUSH
8630: LD_INT 3
8632: PPUSH
8633: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8637: LD_EXP 56
8641: PPUSH
8642: LD_INT 126
8644: PPUSH
8645: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8649: LD_EXP 57
8653: PPUSH
8654: LD_INT 197
8656: PPUSH
8657: LD_INT 111
8659: PPUSH
8660: LD_INT 9
8662: PPUSH
8663: LD_INT 0
8665: PPUSH
8666: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8670: LD_EXP 58
8674: PPUSH
8675: LD_INT 197
8677: PPUSH
8678: LD_INT 111
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: LD_INT 0
8686: PPUSH
8687: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8691: LD_ADDR_VAR 0 5
8695: PUSH
8696: LD_INT 126
8698: PPUSH
8699: LD_INT 2
8701: PPUSH
8702: LD_STRING zhukov
8704: PPUSH
8705: LD_INT 9
8707: PUSH
8708: LD_INT 10
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: LD_OWVAR 67
8723: ARRAY
8724: PPUSH
8725: LD_INT 9000
8727: PUSH
8728: LD_INT 1000
8730: PUSH
8731: LD_INT 300
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PPUSH
8739: LD_INT 21
8741: PUSH
8742: LD_INT 8
8744: PUSH
8745: LD_INT 13
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: LIST
8756: PPUSH
8757: CALL 59591 0 6
8761: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 267
8769: PPUSH
8770: CALL_OW 274
8774: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8775: LD_VAR 0 4
8779: PPUSH
8780: LD_INT 1
8782: PPUSH
8783: LD_INT 5000
8785: PPUSH
8786: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8790: LD_VAR 0 4
8794: PPUSH
8795: LD_INT 2
8797: PPUSH
8798: LD_INT 200
8800: PPUSH
8801: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8805: LD_VAR 0 4
8809: PPUSH
8810: LD_INT 3
8812: PPUSH
8813: LD_INT 200
8815: PPUSH
8816: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8820: LD_ADDR_EXP 93
8824: PUSH
8825: LD_EXP 93
8829: PPUSH
8830: LD_INT 2
8832: PPUSH
8833: LD_VAR 0 5
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_VAR 0 6
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: LD_INT 21
8855: PUSH
8856: LD_INT 2
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PPUSH
8871: CALL_OW 69
8875: UNION
8876: PUSH
8877: LD_EXP 56
8881: DIFF
8882: PPUSH
8883: CALL_OW 1
8887: ST_TO_ADDR
// behemoths := [ ] ;
8888: LD_ADDR_EXP 60
8892: PUSH
8893: EMPTY
8894: ST_TO_ADDR
// behemothBuilders := [ ] ;
8895: LD_ADDR_EXP 61
8899: PUSH
8900: EMPTY
8901: ST_TO_ADDR
// j := 3 ;
8902: LD_ADDR_VAR 0 3
8906: PUSH
8907: LD_INT 3
8909: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_INT 22
8917: PUSH
8918: LD_INT 3
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 25
8927: PUSH
8928: LD_INT 3
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: PPUSH
8939: CALL_OW 69
8943: PUSH
8944: FOR_IN
8945: IFFALSE 8995
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8947: LD_ADDR_EXP 61
8951: PUSH
8952: LD_EXP 61
8956: PPUSH
8957: LD_VAR 0 2
8961: PPUSH
8962: CALL 88018 0 2
8966: ST_TO_ADDR
// j := j - 1 ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PUSH
8977: LD_INT 1
8979: MINUS
8980: ST_TO_ADDR
// if j = 0 then
8981: LD_VAR 0 3
8985: PUSH
8986: LD_INT 0
8988: EQUAL
8989: IFFALSE 8993
// break ;
8991: GO 8995
// end ;
8993: GO 8944
8995: POP
8996: POP
// end ;
8997: LD_VAR 0 1
9001: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9002: LD_INT 0
9004: PPUSH
9005: PPUSH
9006: PPUSH
9007: PPUSH
9008: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9009: LD_ADDR_VAR 0 4
9013: PUSH
9014: LD_INT 209
9016: PUSH
9017: LD_INT 149
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 219
9026: PUSH
9027: LD_INT 154
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: PUSH
9034: LD_INT 223
9036: PUSH
9037: LD_INT 149
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PUSH
9044: LD_INT 232
9046: PUSH
9047: LD_INT 155
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: LIST
9058: LIST
9059: ST_TO_ADDR
// if not behemothBuilders then
9060: LD_EXP 61
9064: NOT
9065: IFFALSE 9069
// exit ;
9067: GO 9173
// j := 1 ;
9069: LD_ADDR_VAR 0 3
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// for i in behemothBuilders do
9077: LD_ADDR_VAR 0 2
9081: PUSH
9082: LD_EXP 61
9086: PUSH
9087: FOR_IN
9088: IFFALSE 9171
// begin if IsInUnit ( i ) then
9090: LD_VAR 0 2
9094: PPUSH
9095: CALL_OW 310
9099: IFFALSE 9110
// ComExitBuilding ( i ) ;
9101: LD_VAR 0 2
9105: PPUSH
9106: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9110: LD_VAR 0 2
9114: PPUSH
9115: LD_INT 37
9117: PPUSH
9118: LD_VAR 0 4
9122: PUSH
9123: LD_VAR 0 3
9127: ARRAY
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_VAR 0 4
9137: PUSH
9138: LD_VAR 0 3
9142: ARRAY
9143: PUSH
9144: LD_INT 2
9146: ARRAY
9147: PPUSH
9148: LD_INT 0
9150: PPUSH
9151: CALL_OW 230
// j := j + 1 ;
9155: LD_ADDR_VAR 0 3
9159: PUSH
9160: LD_VAR 0 3
9164: PUSH
9165: LD_INT 1
9167: PLUS
9168: ST_TO_ADDR
// end ;
9169: GO 9087
9171: POP
9172: POP
// end ;
9173: LD_VAR 0 1
9177: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9178: LD_INT 3
9180: PPUSH
9181: CALL 88079 0 1
9185: PUSH
9186: LD_INT 22
9188: PUSH
9189: LD_INT 3
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PUSH
9196: LD_INT 30
9198: PUSH
9199: LD_INT 37
9201: PUSH
9202: EMPTY
9203: LIST
9204: LIST
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: PPUSH
9210: CALL_OW 69
9214: NOT
9215: AND
9216: IFFALSE 9402
9218: GO 9220
9220: DISABLE
9221: LD_INT 0
9223: PPUSH
9224: PPUSH
// begin enable ;
9225: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9226: LD_ADDR_VAR 0 2
9230: PUSH
9231: LD_INT 3
9233: PPUSH
9234: CALL 88079 0 1
9238: ST_TO_ADDR
// for i in tmp do
9239: LD_ADDR_VAR 0 1
9243: PUSH
9244: LD_VAR 0 2
9248: PUSH
9249: FOR_IN
9250: IFFALSE 9400
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9252: LD_VAR 0 1
9256: PPUSH
9257: LD_INT 7
9259: PPUSH
9260: CALL_OW 308
9264: PUSH
9265: LD_VAR 0 1
9269: PPUSH
9270: CALL_OW 110
9274: PUSH
9275: LD_INT 2
9277: EQUAL
9278: NOT
9279: AND
9280: IFFALSE 9294
// SetTag ( i , 2 ) ;
9282: LD_VAR 0 1
9286: PPUSH
9287: LD_INT 2
9289: PPUSH
9290: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9294: LD_INT 81
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: LD_INT 91
9306: PUSH
9307: LD_VAR 0 1
9311: PUSH
9312: LD_INT 12
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: NOT
9329: PUSH
9330: LD_VAR 0 1
9334: PPUSH
9335: CALL_OW 110
9339: PUSH
9340: LD_INT 2
9342: EQUAL
9343: NOT
9344: AND
9345: IFFALSE 9364
// ComAgressiveMove ( i , 64 , 93 ) else
9347: LD_VAR 0 1
9351: PPUSH
9352: LD_INT 64
9354: PPUSH
9355: LD_INT 93
9357: PPUSH
9358: CALL_OW 114
9362: GO 9398
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9364: LD_VAR 0 1
9368: PPUSH
9369: LD_INT 81
9371: PUSH
9372: LD_INT 3
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PPUSH
9384: LD_VAR 0 1
9388: PPUSH
9389: CALL_OW 74
9393: PPUSH
9394: CALL_OW 115
// end ;
9398: GO 9249
9400: POP
9401: POP
// end ;
9402: PPOPN 2
9404: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9405: LD_EXP 2
9409: NOT
9410: PUSH
9411: LD_INT 2
9413: PPUSH
9414: LD_INT 1
9416: PPUSH
9417: CALL 46293 0 2
9421: NOT
9422: AND
9423: IFFALSE 10343
9425: GO 9427
9427: DISABLE
9428: LD_INT 0
9430: PPUSH
9431: PPUSH
9432: PPUSH
9433: PPUSH
// begin enable ;
9434: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9435: LD_INT 22
9437: PUSH
9438: LD_INT 3
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: LD_INT 30
9447: PUSH
9448: LD_INT 3
9450: PUSH
9451: EMPTY
9452: LIST
9453: LIST
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: PPUSH
9459: CALL_OW 69
9463: NOT
9464: IFFALSE 9468
// exit ;
9466: GO 10343
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9468: LD_ADDR_VAR 0 4
9472: PUSH
9473: LD_INT 22
9475: PUSH
9476: LD_INT 3
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 30
9485: PUSH
9486: LD_INT 34
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: PPUSH
9497: CALL_OW 69
9501: ST_TO_ADDR
// if Prob ( 40 ) then
9502: LD_INT 40
9504: PPUSH
9505: CALL_OW 13
9509: IFFALSE 9636
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9511: LD_INT 2
9513: PPUSH
9514: LD_INT 22
9516: PUSH
9517: LD_INT 3
9519: PUSH
9520: LD_INT 3
9522: PUSH
9523: LD_INT 49
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: LD_INT 3
9540: PUSH
9541: LD_INT 49
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_INT 22
9552: PUSH
9553: LD_INT 3
9555: PUSH
9556: LD_INT 3
9558: PUSH
9559: LD_INT 49
9561: PUSH
9562: EMPTY
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: PUSH
9568: LD_INT 24
9570: PUSH
9571: LD_INT 3
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 46
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 3
9591: PUSH
9592: LD_INT 3
9594: PUSH
9595: LD_INT 46
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 24
9606: PUSH
9607: LD_INT 3
9609: PUSH
9610: LD_INT 3
9612: PUSH
9613: LD_INT 46
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: LIST
9629: PPUSH
9630: CALL 44875 0 2
// end else
9634: GO 9759
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9636: LD_INT 2
9638: PPUSH
9639: LD_INT 24
9641: PUSH
9642: LD_INT 3
9644: PUSH
9645: LD_INT 3
9647: PUSH
9648: LD_INT 47
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: PUSH
9657: LD_INT 24
9659: PUSH
9660: LD_INT 3
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: LD_INT 47
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: PUSH
9675: LD_INT 24
9677: PUSH
9678: LD_INT 3
9680: PUSH
9681: LD_INT 3
9683: PUSH
9684: LD_INT 47
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: PUSH
9693: LD_INT 24
9695: PUSH
9696: LD_INT 3
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 46
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 24
9713: PUSH
9714: LD_INT 3
9716: PUSH
9717: LD_INT 3
9719: PUSH
9720: LD_INT 46
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: LIST
9728: PUSH
9729: LD_INT 24
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 3
9737: PUSH
9738: LD_INT 46
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PPUSH
9755: CALL 44875 0 2
// end ; if Difficulty > 1 then
9759: LD_OWVAR 67
9763: PUSH
9764: LD_INT 1
9766: GREATER
9767: IFFALSE 9797
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9769: LD_INT 2
9771: PPUSH
9772: LD_INT 24
9774: PUSH
9775: LD_INT 3
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: LD_INT 47
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: LIST
9789: PUSH
9790: EMPTY
9791: LIST
9792: PPUSH
9793: CALL 44875 0 2
// repeat wait ( 0 0$1 ) ;
9797: LD_INT 35
9799: PPUSH
9800: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9804: LD_INT 2
9806: PPUSH
9807: LD_INT 1
9809: PPUSH
9810: CALL 46293 0 2
9814: PUSH
9815: LD_INT 6
9817: PUSH
9818: LD_INT 7
9820: PUSH
9821: LD_INT 7
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: LD_OWVAR 67
9833: ARRAY
9834: GREATEREQUAL
9835: IFFALSE 9797
// wait ( 0 0$30 ) ;
9837: LD_INT 1050
9839: PPUSH
9840: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9844: LD_ADDR_VAR 0 2
9848: PUSH
9849: LD_INT 2
9851: PPUSH
9852: LD_INT 1
9854: PPUSH
9855: CALL 46293 0 2
9859: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9860: LD_ADDR_EXP 112
9864: PUSH
9865: LD_EXP 112
9869: PPUSH
9870: LD_INT 2
9872: PPUSH
9873: LD_EXP 112
9877: PUSH
9878: LD_INT 2
9880: ARRAY
9881: PUSH
9882: LD_VAR 0 2
9886: DIFF
9887: PPUSH
9888: CALL_OW 1
9892: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9893: LD_ADDR_VAR 0 3
9897: PUSH
9898: LD_INT 0
9900: PPUSH
9901: LD_INT 1
9903: PPUSH
9904: CALL_OW 12
9908: ST_TO_ADDR
// if target then
9909: LD_VAR 0 3
9913: IFFALSE 10041
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9915: LD_ADDR_VAR 0 2
9919: PUSH
9920: LD_VAR 0 2
9924: PPUSH
9925: LD_INT 24
9927: PUSH
9928: LD_INT 250
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: PPUSH
9935: CALL_OW 72
9939: ST_TO_ADDR
// for i in tmp do
9940: LD_ADDR_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: FOR_IN
9951: IFFALSE 9991
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9953: LD_VAR 0 1
9957: PPUSH
9958: LD_INT 139
9960: PPUSH
9961: LD_INT 89
9963: PPUSH
9964: CALL_OW 297
9968: PUSH
9969: LD_INT 9
9971: GREATER
9972: IFFALSE 9989
// ComMoveXY ( i , 139 , 89 ) ;
9974: LD_VAR 0 1
9978: PPUSH
9979: LD_INT 139
9981: PPUSH
9982: LD_INT 89
9984: PPUSH
9985: CALL_OW 111
9989: GO 9950
9991: POP
9992: POP
// wait ( 0 0$1 ) ;
9993: LD_INT 35
9995: PPUSH
9996: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10000: LD_VAR 0 2
10004: PPUSH
10005: LD_INT 92
10007: PUSH
10008: LD_INT 139
10010: PUSH
10011: LD_INT 89
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: LIST
10021: LIST
10022: PPUSH
10023: CALL_OW 72
10027: PUSH
10028: LD_VAR 0 2
10032: PUSH
10033: LD_INT 1
10035: MINUS
10036: GREATEREQUAL
10037: IFFALSE 9915
// end else
10039: GO 10183
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10041: LD_VAR 0 2
10045: PPUSH
10046: LD_VAR 0 4
10050: PUSH
10051: LD_INT 1
10053: ARRAY
10054: PPUSH
10055: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10059: LD_ADDR_VAR 0 2
10063: PUSH
10064: LD_VAR 0 2
10068: PPUSH
10069: LD_INT 24
10071: PUSH
10072: LD_INT 250
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PPUSH
10079: CALL_OW 72
10083: ST_TO_ADDR
// for i in tmp do
10084: LD_ADDR_VAR 0 1
10088: PUSH
10089: LD_VAR 0 2
10093: PUSH
10094: FOR_IN
10095: IFFALSE 10135
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10097: LD_VAR 0 1
10101: PPUSH
10102: LD_INT 124
10104: PPUSH
10105: LD_INT 139
10107: PPUSH
10108: CALL_OW 297
10112: PUSH
10113: LD_INT 9
10115: GREATER
10116: IFFALSE 10133
// ComMoveXY ( i , 124 , 139 ) ;
10118: LD_VAR 0 1
10122: PPUSH
10123: LD_INT 124
10125: PPUSH
10126: LD_INT 139
10128: PPUSH
10129: CALL_OW 111
10133: GO 10094
10135: POP
10136: POP
// wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10144: LD_VAR 0 2
10148: PPUSH
10149: LD_INT 92
10151: PUSH
10152: LD_INT 124
10154: PUSH
10155: LD_INT 139
10157: PUSH
10158: LD_INT 9
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PPUSH
10167: CALL_OW 72
10171: PUSH
10172: LD_VAR 0 2
10176: PUSH
10177: LD_INT 1
10179: MINUS
10180: GREATEREQUAL
10181: IFFALSE 10059
// end ; repeat wait ( 0 0$1 ) ;
10183: LD_INT 35
10185: PPUSH
10186: CALL_OW 67
// for i in tmp do
10190: LD_ADDR_VAR 0 1
10194: PUSH
10195: LD_VAR 0 2
10199: PUSH
10200: FOR_IN
10201: IFFALSE 10334
// begin if GetLives ( i ) > 251 then
10203: LD_VAR 0 1
10207: PPUSH
10208: CALL_OW 256
10212: PUSH
10213: LD_INT 251
10215: GREATER
10216: IFFALSE 10305
// begin if GetWeapon ( i ) = ru_time_lapser then
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 264
10227: PUSH
10228: LD_INT 49
10230: EQUAL
10231: IFFALSE 10269
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10233: LD_VAR 0 1
10237: PPUSH
10238: LD_INT 81
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PPUSH
10248: CALL_OW 69
10252: PPUSH
10253: LD_VAR 0 1
10257: PPUSH
10258: CALL_OW 74
10262: PPUSH
10263: CALL_OW 112
10267: GO 10303
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 81
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PPUSH
10284: CALL_OW 69
10288: PPUSH
10289: LD_VAR 0 1
10293: PPUSH
10294: CALL_OW 74
10298: PPUSH
10299: CALL_OW 115
// end else
10303: GO 10332
// if IsDead ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 301
10314: IFFALSE 10332
// tmp := tmp diff i ;
10316: LD_ADDR_VAR 0 2
10320: PUSH
10321: LD_VAR 0 2
10325: PUSH
10326: LD_VAR 0 1
10330: DIFF
10331: ST_TO_ADDR
// end ;
10332: GO 10200
10334: POP
10335: POP
// until not tmp ;
10336: LD_VAR 0 2
10340: NOT
10341: IFFALSE 10183
// end ;
10343: PPOPN 4
10345: END
// every 30 30$00 trigger not russianDestroyed do
10346: LD_EXP 2
10350: NOT
10351: IFFALSE 10416
10353: GO 10355
10355: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10356: LD_INT 105000
10358: PUSH
10359: LD_INT 84000
10361: PUSH
10362: LD_INT 63000
10364: PUSH
10365: EMPTY
10366: LIST
10367: LIST
10368: LIST
10369: PUSH
10370: LD_OWVAR 67
10374: ARRAY
10375: PPUSH
10376: CALL_OW 67
// if russianDestroyed then
10380: LD_EXP 2
10384: IFFALSE 10388
// exit ;
10386: GO 10416
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10388: LD_INT 2
10390: PPUSH
10391: LD_INT 23
10393: PUSH
10394: LD_INT 3
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: LD_INT 48
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: LIST
10407: LIST
10408: PUSH
10409: EMPTY
10410: LIST
10411: PPUSH
10412: CALL 44875 0 2
// end ; end_of_file
10416: END
// export function CustomEvent ( event ) ; begin
10417: LD_INT 0
10419: PPUSH
// end ;
10420: LD_VAR 0 2
10424: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10425: LD_VAR 0 2
10429: PPUSH
10430: LD_VAR 0 3
10434: PPUSH
10435: LD_INT 15
10437: PPUSH
10438: CALL_OW 309
10442: IFFALSE 10451
// YouLost ( MothContaminate ) ;
10444: LD_STRING MothContaminate
10446: PPUSH
10447: CALL_OW 104
// end ;
10451: PPOPN 3
10453: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10454: LD_VAR 0 2
10458: PPUSH
10459: LD_VAR 0 3
10463: PPUSH
10464: LD_INT 15
10466: PPUSH
10467: CALL_OW 309
10471: IFFALSE 10487
// begin wait ( 0 0$6 ) ;
10473: LD_INT 210
10475: PPUSH
10476: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10480: LD_STRING MothContaminateBomb
10482: PPUSH
10483: CALL_OW 104
// end ; end ;
10487: PPOPN 3
10489: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10490: LD_VAR 0 1
10494: PUSH
10495: LD_EXP 17
10499: EQUAL
10500: IFFALSE 10511
// begin YouLost ( JMM ) ;
10502: LD_STRING JMM
10504: PPUSH
10505: CALL_OW 104
// exit ;
10509: GO 10610
// end ; if un = Powell then
10511: LD_VAR 0 1
10515: PUSH
10516: LD_EXP 52
10520: EQUAL
10521: IFFALSE 10531
// americanDestroyed := true ;
10523: LD_ADDR_EXP 4
10527: PUSH
10528: LD_INT 1
10530: ST_TO_ADDR
// if un = Platonov then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 56
10540: EQUAL
10541: IFFALSE 10551
// russianDestroyed := true ;
10543: LD_ADDR_EXP 2
10547: PUSH
10548: LD_INT 1
10550: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10551: LD_VAR 0 1
10555: PUSH
10556: LD_INT 22
10558: PUSH
10559: LD_INT 7
10561: PUSH
10562: EMPTY
10563: LIST
10564: LIST
10565: PUSH
10566: LD_INT 21
10568: PUSH
10569: LD_INT 2
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: PPUSH
10580: CALL_OW 69
10584: IN
10585: IFFALSE 10601
// vehicleLostCounter := vehicleLostCounter + 1 ;
10587: LD_ADDR_EXP 15
10591: PUSH
10592: LD_EXP 15
10596: PUSH
10597: LD_INT 1
10599: PLUS
10600: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10601: LD_VAR 0 1
10605: PPUSH
10606: CALL 48295 0 1
// end ;
10610: PPOPN 1
10612: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_VAR 0 2
10622: PPUSH
10623: CALL 50629 0 2
// end ;
10627: PPOPN 2
10629: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10630: LD_VAR 0 1
10634: PPUSH
10635: CALL 49697 0 1
// end ;
10639: PPOPN 1
10641: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_INT 22
10649: PUSH
10650: LD_INT 8
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: PUSH
10657: LD_INT 30
10659: PUSH
10660: LD_INT 2
10662: PUSH
10663: EMPTY
10664: LIST
10665: LIST
10666: PUSH
10667: LD_INT 23
10669: PUSH
10670: LD_INT 3
10672: PUSH
10673: EMPTY
10674: LIST
10675: LIST
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: LIST
10681: PPUSH
10682: CALL_OW 69
10686: IN
10687: IFFALSE 10714
// begin ComUpgrade ( building ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10698: LD_EXP 55
10702: PPUSH
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL 59130 0 2
// exit ;
10712: GO 10723
// end ; MCE_BuildingComplete ( building ) ;
10714: LD_VAR 0 1
10718: PPUSH
10719: CALL 49938 0 1
// end ;
10723: PPOPN 1
10725: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10726: LD_VAR 0 1
10730: PPUSH
10731: LD_VAR 0 2
10735: PPUSH
10736: CALL 47991 0 2
// end ;
10740: PPOPN 2
10742: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10743: LD_VAR 0 1
10747: PPUSH
10748: LD_VAR 0 2
10752: PPUSH
10753: LD_VAR 0 3
10757: PPUSH
10758: LD_VAR 0 4
10762: PPUSH
10763: LD_VAR 0 5
10767: PPUSH
10768: CALL 47611 0 5
// end ;
10772: PPOPN 5
10774: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10775: LD_VAR 0 1
10779: PPUSH
10780: LD_VAR 0 2
10784: PPUSH
10785: CALL 47192 0 2
// end ;
10789: PPOPN 2
10791: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_VAR 0 2
10801: PPUSH
10802: LD_VAR 0 3
10806: PPUSH
10807: LD_VAR 0 4
10811: PPUSH
10812: CALL 47030 0 4
// end ;
10816: PPOPN 4
10818: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10819: LD_VAR 0 1
10823: PPUSH
10824: LD_VAR 0 2
10828: PPUSH
10829: LD_VAR 0 3
10833: PPUSH
10834: CALL 46805 0 3
// end ;
10838: PPOPN 3
10840: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 46690 0 2
// end ;
10855: PPOPN 2
10857: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: CALL 50924 0 2
// end ;
10872: PPOPN 2
10874: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10875: LD_VAR 0 1
10879: PPUSH
10880: LD_VAR 0 2
10884: PPUSH
10885: LD_VAR 0 3
10889: PPUSH
10890: LD_VAR 0 4
10894: PPUSH
10895: CALL 51140 0 4
// end ;
10899: PPOPN 4
10901: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10902: LD_VAR 0 1
10906: PPUSH
10907: LD_VAR 0 2
10911: PPUSH
10912: CALL 46499 0 2
// end ;
10916: PPOPN 2
10918: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: CALL 103433 0 1
// end ; end_of_file
10928: PPOPN 1
10930: END
// export function Action ; begin
10931: LD_INT 0
10933: PPUSH
// InGameOn ;
10934: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10938: LD_INT 206
10940: PPUSH
10941: LD_INT 11
10943: PPUSH
10944: CALL_OW 86
// wait ( 0 0$1 ) ;
10948: LD_INT 35
10950: PPUSH
10951: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10955: LD_EXP 17
10959: PPUSH
10960: LD_STRING DStart-JMM-JMM-1
10962: PPUSH
10963: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10967: LD_EXP 49
10971: PPUSH
10972: LD_STRING DStart-JMM-Bur-1
10974: PPUSH
10975: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10979: LD_EXP 17
10983: PPUSH
10984: LD_STRING DStart-JMM-JMM-2
10986: PPUSH
10987: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10991: LD_EXP 49
10995: PPUSH
10996: LD_STRING DStart-JMM-Bur-2
10998: PPUSH
10999: CALL_OW 88
// InGameOff ;
11003: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11007: LD_STRING MStart
11009: PPUSH
11010: CALL_OW 337
// SaveForQuickRestart ;
11014: CALL_OW 22
// end ;
11018: LD_VAR 0 1
11022: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11023: LD_INT 7
11025: PPUSH
11026: LD_INT 255
11028: PPUSH
11029: LD_INT 219
11031: PPUSH
11032: CALL_OW 293
11036: IFFALSE 11645
11038: GO 11040
11040: DISABLE
11041: LD_INT 0
11043: PPUSH
// begin wait ( 0 0$3 ) ;
11044: LD_INT 105
11046: PPUSH
11047: CALL_OW 67
// alienSpotted := true ;
11051: LD_ADDR_EXP 10
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11059: LD_ADDR_VAR 0 1
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 7
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 23
11076: PUSH
11077: LD_INT 3
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 21
11086: PUSH
11087: LD_INT 1
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 26
11096: PUSH
11097: LD_INT 1
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: PPUSH
11110: CALL_OW 69
11114: PUSH
11115: LD_EXP 49
11119: PUSH
11120: LD_EXP 37
11124: PUSH
11125: LD_EXP 39
11129: PUSH
11130: LD_EXP 40
11134: PUSH
11135: LD_EXP 47
11139: PUSH
11140: LD_EXP 46
11144: PUSH
11145: LD_EXP 41
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: DIFF
11159: ST_TO_ADDR
// DialogueOn ;
11160: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11164: LD_INT 255
11166: PPUSH
11167: LD_INT 219
11169: PPUSH
11170: LD_INT 7
11172: PPUSH
11173: LD_INT 20
11175: NEG
11176: PPUSH
11177: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11181: LD_INT 255
11183: PPUSH
11184: LD_INT 219
11186: PPUSH
11187: CALL_OW 86
// if speaker then
11191: LD_VAR 0 1
11195: IFFALSE 11213
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11197: LD_VAR 0 1
11201: PUSH
11202: LD_INT 1
11204: ARRAY
11205: PPUSH
11206: LD_STRING DAlienBase-RSol1-1
11208: PPUSH
11209: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11213: LD_EXP 17
11217: PPUSH
11218: LD_STRING DAlienBase-JMM-1
11220: PPUSH
11221: CALL_OW 88
// if IsOk ( Burlak ) then
11225: LD_EXP 49
11229: PPUSH
11230: CALL_OW 302
11234: IFFALSE 11255
// begin dwait ( 0 0$1 ) ;
11236: LD_INT 35
11238: PPUSH
11239: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11243: LD_EXP 49
11247: PPUSH
11248: LD_STRING DAlienBase-Bur-1
11250: PPUSH
11251: CALL_OW 88
// end ; if IsOk ( Roth ) then
11255: LD_EXP 18
11259: PPUSH
11260: CALL_OW 302
11264: IFFALSE 11278
// Say ( Roth , DAlienBase-Roth-1 ) ;
11266: LD_EXP 18
11270: PPUSH
11271: LD_STRING DAlienBase-Roth-1
11273: PPUSH
11274: CALL_OW 88
// if IsOk ( Gossudarov ) then
11278: LD_EXP 35
11282: PPUSH
11283: CALL_OW 302
11287: IFFALSE 11303
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11289: LD_EXP 35
11293: PPUSH
11294: LD_STRING DAlienBase-Gos-1
11296: PPUSH
11297: CALL_OW 88
11301: GO 11420
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11303: LD_ADDR_VAR 0 1
11307: PUSH
11308: LD_INT 22
11310: PUSH
11311: LD_INT 7
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: PUSH
11318: LD_INT 25
11320: PUSH
11321: LD_INT 4
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PUSH
11328: LD_INT 21
11330: PUSH
11331: LD_INT 1
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 26
11340: PUSH
11341: LD_INT 1
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: LIST
11352: LIST
11353: PPUSH
11354: CALL_OW 69
11358: PUSH
11359: LD_EXP 18
11363: PUSH
11364: LD_EXP 17
11368: PUSH
11369: LD_EXP 49
11373: PUSH
11374: LD_EXP 37
11378: PUSH
11379: LD_EXP 47
11383: PUSH
11384: LD_EXP 46
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: DIFF
11397: ST_TO_ADDR
// if speaker then
11398: LD_VAR 0 1
11402: IFFALSE 11420
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11404: LD_VAR 0 1
11408: PUSH
11409: LD_INT 1
11411: ARRAY
11412: PPUSH
11413: LD_STRING DAlienBase-Sci1-1
11415: PPUSH
11416: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11420: LD_INT 255
11422: PPUSH
11423: LD_INT 219
11425: PPUSH
11426: LD_INT 7
11428: PPUSH
11429: CALL_OW 331
// DialogueOff ;
11433: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11437: LD_INT 35
11439: PPUSH
11440: CALL_OW 67
// until IsSelected ( alien ) ;
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 306
11451: IFFALSE 11437
// if not artifactIResearched or not artifactIIResearched then
11453: LD_EXP 12
11457: NOT
11458: PUSH
11459: LD_EXP 13
11463: NOT
11464: OR
11465: IFFALSE 11645
// begin if IsOk ( Roth ) then
11467: LD_EXP 18
11471: PPUSH
11472: CALL_OW 302
11476: IFFALSE 11492
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11478: LD_EXP 18
11482: PPUSH
11483: LD_STRING DAlieBaseNotReady-Roth-1
11485: PPUSH
11486: CALL_OW 88
11490: GO 11645
// if IsOk ( Gossudarov ) then
11492: LD_EXP 35
11496: PPUSH
11497: CALL_OW 302
11501: IFFALSE 11517
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11503: LD_EXP 35
11507: PPUSH
11508: LD_STRING DAlieBaseNotReady-Gos-1
11510: PPUSH
11511: CALL_OW 88
11515: GO 11645
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11517: LD_ADDR_VAR 0 1
11521: PUSH
11522: LD_INT 22
11524: PUSH
11525: LD_INT 7
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: LD_INT 23
11534: PUSH
11535: LD_INT 3
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 4
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 21
11554: PUSH
11555: LD_INT 1
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 26
11564: PUSH
11565: LD_INT 1
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: LIST
11578: PPUSH
11579: CALL_OW 69
11583: PUSH
11584: LD_EXP 18
11588: PUSH
11589: LD_EXP 17
11593: PUSH
11594: LD_EXP 49
11598: PUSH
11599: LD_EXP 37
11603: PUSH
11604: LD_EXP 47
11608: PUSH
11609: LD_EXP 46
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: DIFF
11622: ST_TO_ADDR
// if speaker then
11623: LD_VAR 0 1
11627: IFFALSE 11645
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11629: LD_VAR 0 1
11633: PUSH
11634: LD_INT 1
11636: ARRAY
11637: PPUSH
11638: LD_STRING DAlieBaseNotReady-RSci1-1
11640: PPUSH
11641: CALL_OW 88
// end ; end ; end ;
11645: PPOPN 1
11647: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11648: LD_INT 24
11650: PPUSH
11651: LD_INT 7
11653: PPUSH
11654: CALL_OW 321
11658: PUSH
11659: LD_INT 2
11661: EQUAL
11662: IFFALSE 12353
11664: GO 11666
11666: DISABLE
11667: LD_INT 0
11669: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11670: LD_ADDR_VAR 0 1
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_INT 7
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PUSH
11685: LD_INT 23
11687: PUSH
11688: LD_INT 3
11690: PUSH
11691: EMPTY
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 25
11697: PUSH
11698: LD_INT 4
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: LD_INT 21
11707: PUSH
11708: LD_INT 1
11710: PUSH
11711: EMPTY
11712: LIST
11713: LIST
11714: PUSH
11715: LD_INT 26
11717: PUSH
11718: LD_INT 1
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: PPUSH
11732: CALL_OW 69
11736: PUSH
11737: LD_EXP 18
11741: PUSH
11742: LD_EXP 17
11746: PUSH
11747: LD_EXP 49
11751: PUSH
11752: LD_EXP 37
11756: PUSH
11757: LD_EXP 47
11761: PUSH
11762: LD_EXP 46
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: DIFF
11775: ST_TO_ADDR
// if not speaker then
11776: LD_VAR 0 1
11780: NOT
11781: IFFALSE 11785
// exit ;
11783: GO 12353
// DialogueOn ;
11785: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11789: LD_VAR 0 1
11793: PUSH
11794: LD_INT 1
11796: ARRAY
11797: PPUSH
11798: LD_STRING DArtefTechnology-RSci1-1
11800: PPUSH
11801: CALL_OW 88
// if IsOk ( Burlak ) then
11805: LD_EXP 49
11809: PPUSH
11810: CALL_OW 302
11814: IFFALSE 11828
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11816: LD_EXP 49
11820: PPUSH
11821: LD_STRING DArtefTechnology-Bur-1
11823: PPUSH
11824: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11828: LD_VAR 0 1
11832: PUSH
11833: LD_INT 1
11835: ARRAY
11836: PPUSH
11837: LD_STRING DArtefTechnology-RSci1-2
11839: PPUSH
11840: CALL_OW 88
// if Denis then
11844: LD_EXP 23
11848: IFFALSE 11865
// speaker := [ Denis ] else
11850: LD_ADDR_VAR 0 1
11854: PUSH
11855: LD_EXP 23
11859: PUSH
11860: EMPTY
11861: LIST
11862: ST_TO_ADDR
11863: GO 11971
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11865: LD_ADDR_VAR 0 1
11869: PUSH
11870: LD_INT 22
11872: PUSH
11873: LD_INT 7
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 23
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: LD_INT 25
11892: PUSH
11893: LD_INT 4
11895: PUSH
11896: EMPTY
11897: LIST
11898: LIST
11899: PUSH
11900: LD_INT 21
11902: PUSH
11903: LD_INT 1
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PUSH
11910: LD_INT 26
11912: PUSH
11913: LD_INT 1
11915: PUSH
11916: EMPTY
11917: LIST
11918: LIST
11919: PUSH
11920: EMPTY
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: PPUSH
11927: CALL_OW 69
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: LD_EXP 17
11941: PUSH
11942: LD_EXP 49
11946: PUSH
11947: LD_EXP 37
11951: PUSH
11952: LD_EXP 47
11956: PUSH
11957: LD_EXP 46
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: DIFF
11970: ST_TO_ADDR
// if speaker then
11971: LD_VAR 0 1
11975: IFFALSE 11993
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11977: LD_VAR 0 1
11981: PUSH
11982: LD_INT 1
11984: ARRAY
11985: PPUSH
11986: LD_STRING DArtefTechnology-Sci1-2
11988: PPUSH
11989: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11993: LD_ADDR_VAR 0 1
11997: PUSH
11998: LD_INT 22
12000: PUSH
12001: LD_INT 7
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: PUSH
12008: LD_INT 23
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: EMPTY
12015: LIST
12016: LIST
12017: PUSH
12018: LD_INT 25
12020: PUSH
12021: LD_INT 4
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 21
12030: PUSH
12031: LD_INT 1
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 26
12040: PUSH
12041: LD_INT 1
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: LIST
12054: PPUSH
12055: CALL_OW 69
12059: PUSH
12060: LD_EXP 18
12064: PUSH
12065: LD_EXP 17
12069: PUSH
12070: LD_EXP 49
12074: PUSH
12075: LD_EXP 37
12079: PUSH
12080: LD_EXP 47
12084: PUSH
12085: LD_EXP 46
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: DIFF
12098: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12099: LD_VAR 0 1
12103: PUSH
12104: LD_EXP 9
12108: PUSH
12109: LD_EXP 5
12113: OR
12114: AND
12115: IFFALSE 12349
// begin if arabianDestroyed and IsOk ( Burlak ) then
12117: LD_EXP 5
12121: PUSH
12122: LD_EXP 49
12126: PPUSH
12127: CALL_OW 302
12131: AND
12132: IFFALSE 12148
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12134: LD_EXP 49
12138: PPUSH
12139: LD_STRING DArtefTechnology-Bur-2
12141: PPUSH
12142: CALL_OW 88
12146: GO 12160
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12148: LD_EXP 17
12152: PPUSH
12153: LD_STRING DArtefTechnology-JMM-2
12155: PPUSH
12156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12160: LD_VAR 0 1
12164: PUSH
12165: LD_INT 1
12167: ARRAY
12168: PPUSH
12169: LD_STRING DArtefTechnology-RSci1-3
12171: PPUSH
12172: CALL_OW 88
// if Denis then
12176: LD_EXP 23
12180: IFFALSE 12197
// speaker := [ Denis ] else
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_EXP 23
12191: PUSH
12192: EMPTY
12193: LIST
12194: ST_TO_ADDR
12195: GO 12303
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12197: LD_ADDR_VAR 0 1
12201: PUSH
12202: LD_INT 22
12204: PUSH
12205: LD_INT 7
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 25
12224: PUSH
12225: LD_INT 4
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 21
12234: PUSH
12235: LD_INT 1
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 26
12244: PUSH
12245: LD_INT 1
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: LIST
12258: PPUSH
12259: CALL_OW 69
12263: PUSH
12264: LD_EXP 18
12268: PUSH
12269: LD_EXP 17
12273: PUSH
12274: LD_EXP 49
12278: PUSH
12279: LD_EXP 37
12283: PUSH
12284: LD_EXP 47
12288: PUSH
12289: LD_EXP 46
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: DIFF
12302: ST_TO_ADDR
// if speaker then
12303: LD_VAR 0 1
12307: IFFALSE 12349
// if alienSpotted then
12309: LD_EXP 10
12313: IFFALSE 12333
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12315: LD_VAR 0 1
12319: PUSH
12320: LD_INT 1
12322: ARRAY
12323: PPUSH
12324: LD_STRING DArtefTechnology-Sci1-3
12326: PPUSH
12327: CALL_OW 88
12331: GO 12349
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12333: LD_VAR 0 1
12337: PUSH
12338: LD_INT 1
12340: ARRAY
12341: PPUSH
12342: LD_STRING DArtefTechnology-Sci1-3a
12344: PPUSH
12345: CALL_OW 88
// end ; DialogueOff ;
12349: CALL_OW 7
// end ;
12353: PPOPN 1
12355: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12356: LD_EXP 12
12360: IFFALSE 12555
12362: GO 12364
12364: DISABLE
12365: LD_INT 0
12367: PPUSH
// begin if Denis then
12368: LD_EXP 23
12372: IFFALSE 12389
// speaker := [ Denis ] else
12374: LD_ADDR_VAR 0 1
12378: PUSH
12379: LD_EXP 23
12383: PUSH
12384: EMPTY
12385: LIST
12386: ST_TO_ADDR
12387: GO 12495
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12389: LD_ADDR_VAR 0 1
12393: PUSH
12394: LD_INT 22
12396: PUSH
12397: LD_INT 7
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PUSH
12404: LD_INT 23
12406: PUSH
12407: LD_INT 1
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: PUSH
12414: LD_INT 25
12416: PUSH
12417: LD_INT 4
12419: PUSH
12420: EMPTY
12421: LIST
12422: LIST
12423: PUSH
12424: LD_INT 21
12426: PUSH
12427: LD_INT 1
12429: PUSH
12430: EMPTY
12431: LIST
12432: LIST
12433: PUSH
12434: LD_INT 26
12436: PUSH
12437: LD_INT 1
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: PPUSH
12451: CALL_OW 69
12455: PUSH
12456: LD_EXP 18
12460: PUSH
12461: LD_EXP 17
12465: PUSH
12466: LD_EXP 49
12470: PUSH
12471: LD_EXP 37
12475: PUSH
12476: LD_EXP 47
12480: PUSH
12481: LD_EXP 46
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: DIFF
12494: ST_TO_ADDR
// if not speaker then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 12555
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12504: LD_VAR 0 1
12508: PUSH
12509: LD_INT 1
12511: ARRAY
12512: PPUSH
12513: LD_STRING DArtefTechnologyAm-Sci1-1
12515: PPUSH
12516: CALL_OW 88
// if IsOk ( Burlak ) then
12520: LD_EXP 49
12524: PPUSH
12525: CALL_OW 302
12529: IFFALSE 12543
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12531: LD_EXP 49
12535: PPUSH
12536: LD_STRING DArtefTechnologyAm-Bur-1
12538: PPUSH
12539: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12543: LD_EXP 17
12547: PPUSH
12548: LD_STRING DArtefTechnologyAm-JMM-1
12550: PPUSH
12551: CALL_OW 88
// end ;
12555: PPOPN 1
12557: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12558: LD_EXP 13
12562: IFFALSE 12752
12564: GO 12566
12566: DISABLE
12567: LD_INT 0
12569: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_INT 22
12577: PUSH
12578: LD_INT 7
12580: PUSH
12581: EMPTY
12582: LIST
12583: LIST
12584: PUSH
12585: LD_INT 23
12587: PUSH
12588: LD_INT 3
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: PUSH
12595: LD_INT 25
12597: PUSH
12598: LD_INT 4
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 21
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 26
12617: PUSH
12618: LD_INT 1
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: PPUSH
12632: CALL_OW 69
12636: PUSH
12637: LD_EXP 18
12641: PUSH
12642: LD_EXP 17
12646: PUSH
12647: LD_EXP 49
12651: PUSH
12652: LD_EXP 37
12656: PUSH
12657: LD_EXP 47
12661: PUSH
12662: LD_EXP 46
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: DIFF
12675: ST_TO_ADDR
// if not speaker then
12676: LD_VAR 0 1
12680: NOT
12681: IFFALSE 12685
// exit ;
12683: GO 12752
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12685: LD_VAR 0 1
12689: PUSH
12690: LD_INT 1
12692: ARRAY
12693: PPUSH
12694: LD_STRING DArtefTechnologyRu-RSci1-1
12696: PPUSH
12697: CALL_OW 88
// if IsOk ( Burlak ) then
12701: LD_EXP 49
12705: PPUSH
12706: CALL_OW 302
12710: IFFALSE 12724
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12712: LD_EXP 49
12716: PPUSH
12717: LD_STRING DArtefTechnologyRu-Bur-1
12719: PPUSH
12720: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DArtefTechnologyRu-RSci1-2
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12740: LD_EXP 17
12744: PPUSH
12745: LD_STRING DArtefTechnologyRu-JMM-1
12747: PPUSH
12748: CALL_OW 88
// end ;
12752: PPOPN 1
12754: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12755: LD_INT 24
12757: PPUSH
12758: LD_INT 7
12760: PPUSH
12761: CALL_OW 321
12765: PUSH
12766: LD_INT 2
12768: EQUAL
12769: PUSH
12770: LD_INT 1
12772: PPUSH
12773: CALL_OW 255
12777: PUSH
12778: LD_INT 7
12780: EQUAL
12781: AND
12782: IFFALSE 12942
12784: GO 12786
12786: DISABLE
12787: LD_INT 0
12789: PPUSH
// begin if Denis then
12790: LD_EXP 23
12794: IFFALSE 12811
// speaker := [ Denis ] else
12796: LD_ADDR_VAR 0 1
12800: PUSH
12801: LD_EXP 23
12805: PUSH
12806: EMPTY
12807: LIST
12808: ST_TO_ADDR
12809: GO 12917
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12811: LD_ADDR_VAR 0 1
12815: PUSH
12816: LD_INT 22
12818: PUSH
12819: LD_INT 7
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: LD_INT 23
12828: PUSH
12829: LD_INT 1
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 25
12838: PUSH
12839: LD_INT 4
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 21
12848: PUSH
12849: LD_INT 1
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: LD_INT 26
12858: PUSH
12859: LD_INT 1
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: PPUSH
12873: CALL_OW 69
12877: PUSH
12878: LD_EXP 18
12882: PUSH
12883: LD_EXP 17
12887: PUSH
12888: LD_EXP 49
12892: PUSH
12893: LD_EXP 37
12897: PUSH
12898: LD_EXP 47
12902: PUSH
12903: LD_EXP 46
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: DIFF
12916: ST_TO_ADDR
// if not speaker then
12917: LD_VAR 0 1
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 12942
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyArStart-Sci1-1
12937: PPUSH
12938: CALL_OW 88
// end ;
12942: PPOPN 1
12944: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12945: LD_EXP 14
12949: IFFALSE 13230
12951: GO 12953
12953: DISABLE
12954: LD_INT 0
12956: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12957: LD_ADDR_VAR 0 1
12961: PUSH
12962: LD_INT 22
12964: PUSH
12965: LD_INT 7
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: PUSH
12972: LD_INT 23
12974: PUSH
12975: LD_INT 3
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 25
12984: PUSH
12985: LD_INT 4
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 21
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 26
13004: PUSH
13005: LD_INT 1
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PPUSH
13019: CALL_OW 69
13023: PUSH
13024: LD_EXP 18
13028: PUSH
13029: LD_EXP 17
13033: PUSH
13034: LD_EXP 49
13038: PUSH
13039: LD_EXP 37
13043: PUSH
13044: LD_EXP 47
13048: PUSH
13049: LD_EXP 46
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: DIFF
13062: ST_TO_ADDR
// if not speaker then
13063: LD_VAR 0 1
13067: NOT
13068: IFFALSE 13072
// exit ;
13070: GO 13230
// DialogueOn ;
13072: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13076: LD_VAR 0 1
13080: PUSH
13081: LD_INT 1
13083: ARRAY
13084: PPUSH
13085: LD_STRING DArtefTechnologyAr-RSci1-1
13087: PPUSH
13088: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13092: LD_EXP 17
13096: PPUSH
13097: LD_STRING DArtefTechnologyAr-JMM-1
13099: PPUSH
13100: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 1
13111: ARRAY
13112: PPUSH
13113: LD_STRING DArtefTechnologyAr-RSci1-2
13115: PPUSH
13116: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13120: LD_EXP 17
13124: PPUSH
13125: LD_STRING DArtefTechnologyAr-JMM-2
13127: PPUSH
13128: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13132: LD_VAR 0 1
13136: PUSH
13137: LD_INT 1
13139: ARRAY
13140: PPUSH
13141: LD_STRING DArtefTechnologyAr-RSci1-3
13143: PPUSH
13144: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13148: LD_EXP 17
13152: PPUSH
13153: LD_STRING DArtefTechnologyAr-JMM-3
13155: PPUSH
13156: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13160: LD_VAR 0 1
13164: PUSH
13165: LD_INT 1
13167: ARRAY
13168: PPUSH
13169: LD_STRING DArtefTechnologyAr-RSci1-4
13171: PPUSH
13172: CALL_OW 88
// if IsOk ( Burlak ) then
13176: LD_EXP 49
13180: PPUSH
13181: CALL_OW 302
13185: IFFALSE 13199
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13187: LD_EXP 49
13191: PPUSH
13192: LD_STRING DArtefTechnologyAr-Bur-4
13194: PPUSH
13195: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13199: LD_EXP 17
13203: PPUSH
13204: LD_STRING DArtefTechnologyAr-JMM-4
13206: PPUSH
13207: CALL_OW 88
// DialogueOff ;
13211: CALL_OW 7
// wait ( 0 0$45 ) ;
13215: LD_INT 1575
13217: PPUSH
13218: CALL_OW 67
// spawnOmar := true ;
13222: LD_ADDR_EXP 11
13226: PUSH
13227: LD_INT 1
13229: ST_TO_ADDR
// end ;
13230: PPOPN 1
13232: END
// every 0 0$1 trigger spawnOmar do
13233: LD_EXP 11
13237: IFFALSE 13617
13239: GO 13241
13241: DISABLE
// begin PrepareOmarAli ;
13242: CALL 6751 0 0
// if not HasTask ( Omar ) then
13246: LD_EXP 53
13250: PPUSH
13251: CALL_OW 314
13255: NOT
13256: IFFALSE 13273
// ComMoveXY ( Omar , 252 , 220 ) ;
13258: LD_EXP 53
13262: PPUSH
13263: LD_INT 252
13265: PPUSH
13266: LD_INT 220
13268: PPUSH
13269: CALL_OW 111
// if not Omar then
13273: LD_EXP 53
13277: NOT
13278: IFFALSE 13282
// exit ;
13280: GO 13617
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13289: LD_EXP 53
13293: PPUSH
13294: CALL_OW 314
13298: NOT
13299: PUSH
13300: LD_EXP 53
13304: PPUSH
13305: LD_INT 252
13307: PPUSH
13308: LD_INT 220
13310: PPUSH
13311: CALL_OW 297
13315: PUSH
13316: LD_INT 6
13318: GREATER
13319: AND
13320: IFFALSE 13337
// ComMoveXY ( Omar , 252 , 220 ) ;
13322: LD_EXP 53
13326: PPUSH
13327: LD_INT 252
13329: PPUSH
13330: LD_INT 220
13332: PPUSH
13333: CALL_OW 111
// until See ( 7 , Omar ) ;
13337: LD_INT 7
13339: PPUSH
13340: LD_EXP 53
13344: PPUSH
13345: CALL_OW 292
13349: IFFALSE 13282
// CenterNowOnUnits ( Omar ) ;
13351: LD_EXP 53
13355: PPUSH
13356: CALL_OW 87
// DialogueOn ;
13360: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13364: LD_EXP 53
13368: PPUSH
13369: LD_STRING DOmar-Omar-1
13371: PPUSH
13372: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13376: LD_EXP 17
13380: PPUSH
13381: LD_STRING DOmar-JMM-1
13383: PPUSH
13384: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13388: LD_EXP 53
13392: PPUSH
13393: LD_STRING DOmar-Omar-2
13395: PPUSH
13396: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13400: LD_EXP 17
13404: PPUSH
13405: LD_STRING DOmar-JMM-2
13407: PPUSH
13408: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13412: LD_EXP 53
13416: PPUSH
13417: LD_STRING DOmar-Omar-3
13419: PPUSH
13420: CALL_OW 88
// if IsOk ( Burlak ) then
13424: LD_EXP 49
13428: PPUSH
13429: CALL_OW 302
13433: IFFALSE 13449
// Say ( Burlak , DOmar-Bur-3 ) else
13435: LD_EXP 49
13439: PPUSH
13440: LD_STRING DOmar-Bur-3
13442: PPUSH
13443: CALL_OW 88
13447: GO 13461
// Say ( JMM , DOmar-JMM-3 ) ;
13449: LD_EXP 17
13453: PPUSH
13454: LD_STRING DOmar-JMM-3
13456: PPUSH
13457: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13461: LD_EXP 53
13465: PPUSH
13466: LD_STRING DOmar-Omar-4
13468: PPUSH
13469: CALL_OW 88
// case Query ( QAccept ) of 1 :
13473: LD_STRING QAccept
13475: PPUSH
13476: CALL_OW 97
13480: PUSH
13481: LD_INT 1
13483: DOUBLE
13484: EQUAL
13485: IFTRUE 13489
13487: GO 13525
13489: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13490: LD_EXP 17
13494: PPUSH
13495: LD_STRING DQrAccept#1-JMM-1
13497: PPUSH
13498: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13502: LD_EXP 53
13506: PPUSH
13507: LD_INT 7
13509: PPUSH
13510: CALL_OW 235
// ComStop ( Omar ) ;
13514: LD_EXP 53
13518: PPUSH
13519: CALL_OW 141
// end ; 2 :
13523: GO 13574
13525: LD_INT 2
13527: DOUBLE
13528: EQUAL
13529: IFTRUE 13533
13531: GO 13573
13533: POP
// begin if IsOk ( Burlak ) then
13534: LD_EXP 49
13538: PPUSH
13539: CALL_OW 302
13543: IFFALSE 13559
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13545: LD_EXP 49
13549: PPUSH
13550: LD_STRING DQrAccept#2-Bur-1
13552: PPUSH
13553: CALL_OW 88
13557: GO 13571
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13559: LD_EXP 17
13563: PPUSH
13564: LD_STRING DQrAccept#2-JMM-1
13566: PPUSH
13567: CALL_OW 88
// end ; end ;
13571: GO 13574
13573: POP
// DialogueOff ;
13574: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13578: LD_EXP 53
13582: PPUSH
13583: CALL_OW 255
13587: PUSH
13588: LD_INT 7
13590: EQUAL
13591: IFFALSE 13602
// begin SetAchievement ( ACH_OMAR ) ;
13593: LD_STRING ACH_OMAR
13595: PPUSH
13596: CALL_OW 543
// exit ;
13600: GO 13617
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13602: LD_EXP 53
13606: PPUSH
13607: LD_INT 202
13609: PPUSH
13610: LD_INT 115
13612: PPUSH
13613: CALL_OW 111
// end ;
13617: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13618: LD_EXP 53
13622: PPUSH
13623: LD_INT 200
13625: PPUSH
13626: LD_INT 98
13628: PPUSH
13629: CALL_OW 297
13633: PUSH
13634: LD_INT 40
13636: LESS
13637: PUSH
13638: LD_EXP 2
13642: AND
13643: IFFALSE 13861
13645: GO 13647
13647: DISABLE
// begin SetSide ( Omar , 5 ) ;
13648: LD_EXP 53
13652: PPUSH
13653: LD_INT 5
13655: PPUSH
13656: CALL_OW 235
// if IsInUnit ( Omar ) then
13660: LD_EXP 53
13664: PPUSH
13665: CALL_OW 310
13669: IFFALSE 13680
// ComExitVehicle ( Omar ) ;
13671: LD_EXP 53
13675: PPUSH
13676: CALL_OW 121
// if IsInUnit ( Omar ) then
13680: LD_EXP 53
13684: PPUSH
13685: CALL_OW 310
13689: IFFALSE 13700
// ComExitBuilding ( Omar ) ;
13691: LD_EXP 53
13695: PPUSH
13696: CALL_OW 122
// wait ( 0 0$1 ) ;
13700: LD_INT 35
13702: PPUSH
13703: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13707: LD_EXP 53
13711: PPUSH
13712: LD_INT 203
13714: PPUSH
13715: LD_INT 120
13717: PPUSH
13718: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13722: LD_INT 35
13724: PPUSH
13725: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13729: LD_EXP 53
13733: PPUSH
13734: CALL_OW 306
13738: PUSH
13739: LD_EXP 53
13743: PPUSH
13744: LD_INT 203
13746: PPUSH
13747: LD_INT 120
13749: PPUSH
13750: CALL_OW 297
13754: PUSH
13755: LD_INT 6
13757: LESS
13758: OR
13759: IFFALSE 13722
// CenterNowOnUnits ( Omar ) ;
13761: LD_EXP 53
13765: PPUSH
13766: CALL_OW 87
// DialogueOn ;
13770: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13774: LD_EXP 17
13778: PPUSH
13779: LD_STRING DOmarContam-JMM-1
13781: PPUSH
13782: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13786: LD_EXP 53
13790: PPUSH
13791: LD_STRING DOmarContam-Omar-1
13793: PPUSH
13794: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13798: LD_EXP 17
13802: PPUSH
13803: LD_STRING DOmarContam-JMM-2
13805: PPUSH
13806: CALL_OW 88
// DialogueOff ;
13810: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13814: LD_INT 5
13816: PPUSH
13817: LD_INT 7
13819: PPUSH
13820: LD_INT 2
13822: PPUSH
13823: LD_INT 1
13825: PPUSH
13826: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13830: LD_INT 105
13832: PPUSH
13833: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13837: LD_EXP 53
13841: PPUSH
13842: LD_INT 203
13844: PPUSH
13845: LD_INT 120
13847: PPUSH
13848: CALL_OW 307
13852: IFFALSE 13830
// YouLost ( MothContaminate ) ;
13854: LD_STRING MothContaminate
13856: PPUSH
13857: CALL_OW 104
// end ;
13861: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13862: LD_EXP 4
13866: NOT
13867: PUSH
13868: LD_INT 22
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PUSH
13878: LD_INT 34
13880: PUSH
13881: LD_INT 8
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PPUSH
13892: CALL_OW 69
13896: AND
13897: IFFALSE 14016
13899: GO 13901
13901: DISABLE
// begin wait ( 0 0$5 ) ;
13902: LD_INT 175
13904: PPUSH
13905: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
13909: LD_EXP 52
13913: PPUSH
13914: CALL_OW 302
13918: NOT
13919: PUSH
13920: LD_INT 22
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PUSH
13930: LD_INT 34
13932: PUSH
13933: LD_INT 8
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: PPUSH
13944: CALL_OW 69
13948: NOT
13949: OR
13950: IFFALSE 13954
// exit ;
13952: GO 14016
// DialogueOn ;
13954: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13958: LD_EXP 52
13962: PPUSH
13963: LD_STRING DWinAmericans-Pow-1
13965: PPUSH
13966: CALL_OW 94
// if IsOk ( Burlak ) then
13970: LD_EXP 49
13974: PPUSH
13975: CALL_OW 302
13979: IFFALSE 13993
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13981: LD_EXP 49
13985: PPUSH
13986: LD_STRING DWinAmericans-Bur-1
13988: PPUSH
13989: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13993: LD_EXP 17
13997: PPUSH
13998: LD_STRING DWinAmericans-JMM-1
14000: PPUSH
14001: CALL_OW 88
// DialogueOff ;
14005: CALL_OW 7
// YouLost ( AmBomb ) ;
14009: LD_STRING AmBomb
14011: PPUSH
14012: CALL_OW 104
// end ;
14016: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14017: LD_EXP 2
14021: NOT
14022: PUSH
14023: LD_INT 22
14025: PUSH
14026: LD_INT 3
14028: PUSH
14029: EMPTY
14030: LIST
14031: LIST
14032: PUSH
14033: LD_INT 34
14035: PUSH
14036: LD_INT 48
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: PUSH
14043: EMPTY
14044: LIST
14045: LIST
14046: PPUSH
14047: CALL_OW 69
14051: AND
14052: IFFALSE 14171
14054: GO 14056
14056: DISABLE
// begin wait ( 0 0$5 ) ;
14057: LD_INT 175
14059: PPUSH
14060: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14064: LD_EXP 56
14068: PPUSH
14069: CALL_OW 302
14073: NOT
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: EMPTY
14082: LIST
14083: LIST
14084: PUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 48
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PPUSH
14099: CALL_OW 69
14103: NOT
14104: OR
14105: IFFALSE 14109
// exit ;
14107: GO 14171
// DialogueOn ;
14109: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14113: LD_EXP 56
14117: PPUSH
14118: LD_STRING DWinRussians-Pla-1
14120: PPUSH
14121: CALL_OW 94
// if IsOk ( Burlak ) then
14125: LD_EXP 49
14129: PPUSH
14130: CALL_OW 302
14134: IFFALSE 14148
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14136: LD_EXP 49
14140: PPUSH
14141: LD_STRING DWinRussians-Bur-1
14143: PPUSH
14144: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14148: LD_EXP 17
14152: PPUSH
14153: LD_STRING DWinRussians-JMM-1
14155: PPUSH
14156: CALL_OW 88
// DialogueOff ;
14160: CALL_OW 7
// YouLost ( RuBomb ) ;
14164: LD_STRING RuBomb
14166: PPUSH
14167: CALL_OW 104
// end ;
14171: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14172: LD_INT 7
14174: PPUSH
14175: LD_INT 22
14177: PUSH
14178: LD_INT 7
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: PPUSH
14185: CALL_OW 70
14189: PUSH
14190: LD_EXP 4
14194: NOT
14195: AND
14196: IFFALSE 14225
14198: GO 14200
14200: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14201: LD_EXP 52
14205: PPUSH
14206: LD_STRING DSurrenderAmericans-Pow-1
14208: PPUSH
14209: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14213: LD_EXP 17
14217: PPUSH
14218: LD_STRING DSurrenderAmericans-JMM-1
14220: PPUSH
14221: CALL_OW 88
// end ;
14225: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14226: LD_INT 2
14228: PPUSH
14229: LD_INT 22
14231: PUSH
14232: LD_INT 7
14234: PUSH
14235: EMPTY
14236: LIST
14237: LIST
14238: PPUSH
14239: CALL_OW 70
14243: PUSH
14244: LD_EXP 2
14248: NOT
14249: AND
14250: PUSH
14251: LD_EXP 49
14255: AND
14256: IFFALSE 14285
14258: GO 14260
14260: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14261: LD_EXP 56
14265: PPUSH
14266: LD_STRING DSurrenderRussians-Pla-1
14268: PPUSH
14269: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14273: LD_EXP 49
14277: PPUSH
14278: LD_STRING DSurrenderRussians-Bur-1
14280: PPUSH
14281: CALL_OW 88
// end ;
14285: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14286: LD_EXP 4
14290: IFFALSE 14673
14292: GO 14294
14294: DISABLE
14295: LD_INT 0
14297: PPUSH
14298: PPUSH
14299: PPUSH
// begin MC_Kill ( 4 ) ;
14300: LD_INT 4
14302: PPUSH
14303: CALL 21044 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14307: LD_INT 1
14309: PPUSH
14310: LD_INT 7
14312: PPUSH
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 1
14318: PPUSH
14319: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14323: LD_ADDR_VAR 0 3
14327: PUSH
14328: LD_INT 22
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: EMPTY
14335: LIST
14336: LIST
14337: PUSH
14338: LD_INT 26
14340: PUSH
14341: LD_INT 1
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 1
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: PPUSH
14363: CALL_OW 69
14367: PUSH
14368: LD_EXP 52
14372: PUSH
14373: LD_EXP 25
14377: PUSH
14378: LD_EXP 22
14382: PUSH
14383: LD_EXP 21
14387: PUSH
14388: LD_EXP 28
14392: PUSH
14393: LD_EXP 26
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: DIFF
14406: ST_TO_ADDR
// if speaker then
14407: LD_VAR 0 3
14411: IFFALSE 14437
// begin DialogueOn ;
14413: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14417: LD_VAR 0 3
14421: PUSH
14422: LD_INT 1
14424: ARRAY
14425: PPUSH
14426: LD_STRING DSurrenderAmericans-Sol1-1a
14428: PPUSH
14429: CALL_OW 94
// DialogueOff ;
14433: CALL_OW 7
// end ; americanCapitulated := true ;
14437: LD_ADDR_EXP 6
14441: PUSH
14442: LD_INT 1
14444: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 122
14589: PPUSH
14590: LD_INT 242
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 35
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14676: LD_EXP 2
14680: IFFALSE 15081
14682: GO 14684
14684: DISABLE
14685: LD_INT 0
14687: PPUSH
14688: PPUSH
14689: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14690: LD_INT 35
14692: PPUSH
14693: CALL_OW 67
// until IsDead ( Yakotich ) ;
14697: LD_EXP 57
14701: PPUSH
14702: CALL_OW 301
14706: IFFALSE 14690
// MC_Kill ( 2 ) ;
14708: LD_INT 2
14710: PPUSH
14711: CALL 21044 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14715: LD_INT 3
14717: PPUSH
14718: LD_INT 7
14720: PPUSH
14721: LD_INT 1
14723: PPUSH
14724: LD_INT 1
14726: PPUSH
14727: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 22
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 26
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 23
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: EMPTY
14763: LIST
14764: LIST
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: PUSH
14776: LD_EXP 56
14780: PUSH
14781: LD_EXP 57
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: DIFF
14790: ST_TO_ADDR
// if speaker then
14791: LD_VAR 0 3
14795: IFFALSE 14845
// begin DialogueOn ;
14797: CALL_OW 6
// if Burlak then
14801: LD_EXP 49
14805: IFFALSE 14825
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14807: LD_VAR 0 3
14811: PUSH
14812: LD_INT 1
14814: ARRAY
14815: PPUSH
14816: LD_STRING DSurrenderRussians-RSol1-1
14818: PPUSH
14819: CALL_OW 94
14823: GO 14841
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 1
14832: ARRAY
14833: PPUSH
14834: LD_STRING DSurrenderRussians-RSol1-1a
14836: PPUSH
14837: CALL_OW 94
// DialogueOff ;
14841: CALL_OW 7
// end ; russianCapitulated := true ;
14845: LD_ADDR_EXP 7
14849: PUSH
14850: LD_INT 1
14852: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14853: LD_ADDR_VAR 0 2
14857: PUSH
14858: LD_INT 22
14860: PUSH
14861: LD_INT 3
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: LD_INT 21
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: PPUSH
14882: CALL_OW 69
14886: PUSH
14887: LD_INT 22
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 21
14899: PUSH
14900: LD_INT 2
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: PUSH
14907: LD_INT 1
14909: PUSH
14910: EMPTY
14911: LIST
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: PPUSH
14918: CALL_OW 69
14922: ADD
14923: ST_TO_ADDR
// if tmp then
14924: LD_VAR 0 2
14928: IFFALSE 15081
// repeat wait ( 0 0$1 ) ;
14930: LD_INT 35
14932: PPUSH
14933: CALL_OW 67
// for i in tmp do
14937: LD_ADDR_VAR 0 1
14941: PUSH
14942: LD_VAR 0 2
14946: PUSH
14947: FOR_IN
14948: IFFALSE 15030
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14950: LD_VAR 0 1
14954: PPUSH
14955: CALL_OW 310
14959: PUSH
14960: LD_VAR 0 1
14964: PPUSH
14965: CALL_OW 310
14969: PPUSH
14970: CALL_OW 247
14974: PUSH
14975: LD_INT 3
14977: EQUAL
14978: AND
14979: IFFALSE 14990
// ComExitBuilding ( i ) ;
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14990: LD_VAR 0 1
14994: PPUSH
14995: LD_INT 154
14997: PPUSH
14998: LD_INT 1
15000: PPUSH
15001: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15005: LD_VAR 0 1
15009: PPUSH
15010: LD_INT 36
15012: PPUSH
15013: CALL_OW 308
15017: IFFALSE 15028
// RemoveUnit ( i ) ;
15019: LD_VAR 0 1
15023: PPUSH
15024: CALL_OW 64
// end ;
15028: GO 14947
15030: POP
15031: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15032: LD_INT 22
15034: PUSH
15035: LD_INT 3
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: LD_INT 21
15047: PUSH
15048: LD_INT 1
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 33
15057: PUSH
15058: LD_INT 1
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: NOT
15079: IFFALSE 14930
// end ;
15081: PPOPN 3
15083: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15084: LD_INT 22
15086: PUSH
15087: LD_INT 8
15089: PUSH
15090: EMPTY
15091: LIST
15092: LIST
15093: PUSH
15094: LD_INT 21
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 23
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: LIST
15118: PPUSH
15119: CALL_OW 69
15123: PUSH
15124: LD_INT 18
15126: LESS
15127: PUSH
15128: LD_EXP 55
15132: PPUSH
15133: CALL_OW 301
15137: OR
15138: PUSH
15139: LD_INT 324
15141: PPUSH
15142: CALL_OW 255
15146: PUSH
15147: LD_INT 7
15149: EQUAL
15150: OR
15151: IFFALSE 15164
15153: GO 15155
15155: DISABLE
// legionDestroyed := true ;
15156: LD_ADDR_EXP 3
15160: PUSH
15161: LD_INT 1
15163: ST_TO_ADDR
15164: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15165: LD_INT 22
15167: PUSH
15168: LD_INT 2
15170: PUSH
15171: EMPTY
15172: LIST
15173: LIST
15174: PUSH
15175: LD_INT 21
15177: PUSH
15178: LD_INT 1
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 23
15187: PUSH
15188: LD_INT 2
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PUSH
15195: EMPTY
15196: LIST
15197: LIST
15198: LIST
15199: PPUSH
15200: CALL_OW 69
15204: PUSH
15205: LD_INT 9
15207: LESS
15208: IFFALSE 15221
15210: GO 15212
15212: DISABLE
// arabianDestroyed := true ;
15213: LD_ADDR_EXP 5
15217: PUSH
15218: LD_INT 1
15220: ST_TO_ADDR
15221: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15222: LD_EXP 5
15226: IFFALSE 15470
15228: GO 15230
15230: DISABLE
15231: LD_INT 0
15233: PPUSH
15234: PPUSH
// begin MC_Kill ( 1 ) ;
15235: LD_INT 1
15237: PPUSH
15238: CALL 21044 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15242: LD_ADDR_VAR 0 2
15246: PUSH
15247: LD_INT 22
15249: PUSH
15250: LD_INT 2
15252: PUSH
15253: EMPTY
15254: LIST
15255: LIST
15256: PUSH
15257: LD_INT 21
15259: PUSH
15260: LD_INT 1
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 69
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 8
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 21
15288: PUSH
15289: LD_INT 2
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 1
15298: PUSH
15299: EMPTY
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: LIST
15306: PPUSH
15307: CALL_OW 69
15311: ADD
15312: ST_TO_ADDR
// if tmp then
15313: LD_VAR 0 2
15317: IFFALSE 15470
// repeat wait ( 0 0$1 ) ;
15319: LD_INT 35
15321: PPUSH
15322: CALL_OW 67
// for i in tmp do
15326: LD_ADDR_VAR 0 1
15330: PUSH
15331: LD_VAR 0 2
15335: PUSH
15336: FOR_IN
15337: IFFALSE 15419
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15339: LD_VAR 0 1
15343: PPUSH
15344: CALL_OW 310
15348: PUSH
15349: LD_VAR 0 1
15353: PPUSH
15354: CALL_OW 310
15358: PPUSH
15359: CALL_OW 247
15363: PUSH
15364: LD_INT 3
15366: EQUAL
15367: AND
15368: IFFALSE 15379
// ComExitBuilding ( i ) ;
15370: LD_VAR 0 1
15374: PPUSH
15375: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_INT 254
15386: PPUSH
15387: LD_INT 268
15389: PPUSH
15390: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15394: LD_VAR 0 1
15398: PPUSH
15399: LD_INT 34
15401: PPUSH
15402: CALL_OW 308
15406: IFFALSE 15417
// RemoveUnit ( i ) ;
15408: LD_VAR 0 1
15412: PPUSH
15413: CALL_OW 64
// end ;
15417: GO 15336
15419: POP
15420: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15421: LD_INT 22
15423: PUSH
15424: LD_INT 2
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 21
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 33
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: LIST
15458: PUSH
15459: EMPTY
15460: LIST
15461: LIST
15462: PPUSH
15463: CALL_OW 69
15467: NOT
15468: IFFALSE 15319
// end ;
15470: PPOPN 2
15472: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15473: LD_EXP 3
15477: IFFALSE 15829
15479: GO 15481
15481: DISABLE
15482: LD_INT 0
15484: PPUSH
15485: PPUSH
// begin MC_Kill ( 3 ) ;
15486: LD_INT 3
15488: PPUSH
15489: CALL 21044 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15493: LD_INT 8
15495: PPUSH
15496: LD_INT 7
15498: PPUSH
15499: LD_INT 1
15501: PPUSH
15502: LD_INT 1
15504: PPUSH
15505: CALL_OW 80
// DialogueOn ;
15509: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15513: LD_EXP 54
15517: PPUSH
15518: LD_STRING D15-Szulc-1
15520: PPUSH
15521: CALL_OW 94
// DialogueOff ;
15525: CALL_OW 7
// legionCapitulated := true ;
15529: LD_ADDR_EXP 8
15533: PUSH
15534: LD_INT 1
15536: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15537: LD_ADDR_VAR 0 1
15541: PUSH
15542: LD_INT 22
15544: PUSH
15545: LD_INT 8
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PUSH
15552: LD_INT 21
15554: PUSH
15555: LD_INT 3
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 23
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: LIST
15576: PPUSH
15577: CALL_OW 69
15581: PUSH
15582: FOR_IN
15583: IFFALSE 15599
// SetLives ( i , 3 ) ;
15585: LD_VAR 0 1
15589: PPUSH
15590: LD_INT 3
15592: PPUSH
15593: CALL_OW 234
15597: GO 15582
15599: POP
15600: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15601: LD_ADDR_VAR 0 2
15605: PUSH
15606: LD_INT 22
15608: PUSH
15609: LD_INT 8
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: LD_INT 21
15618: PUSH
15619: LD_INT 1
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: PPUSH
15630: CALL_OW 69
15634: PUSH
15635: LD_INT 22
15637: PUSH
15638: LD_INT 8
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PUSH
15645: LD_INT 21
15647: PUSH
15648: LD_INT 2
15650: PUSH
15651: EMPTY
15652: LIST
15653: LIST
15654: PUSH
15655: LD_INT 1
15657: PUSH
15658: EMPTY
15659: LIST
15660: PUSH
15661: EMPTY
15662: LIST
15663: LIST
15664: LIST
15665: PPUSH
15666: CALL_OW 69
15670: ADD
15671: ST_TO_ADDR
// if tmp then
15672: LD_VAR 0 2
15676: IFFALSE 15829
// repeat wait ( 0 0$1 ) ;
15678: LD_INT 35
15680: PPUSH
15681: CALL_OW 67
// for i in tmp do
15685: LD_ADDR_VAR 0 1
15689: PUSH
15690: LD_VAR 0 2
15694: PUSH
15695: FOR_IN
15696: IFFALSE 15778
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15698: LD_VAR 0 1
15702: PPUSH
15703: CALL_OW 310
15707: PUSH
15708: LD_VAR 0 1
15712: PPUSH
15713: CALL_OW 310
15717: PPUSH
15718: CALL_OW 247
15722: PUSH
15723: LD_INT 3
15725: EQUAL
15726: AND
15727: IFFALSE 15738
// ComExitBuilding ( i ) ;
15729: LD_VAR 0 1
15733: PPUSH
15734: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15738: LD_VAR 0 1
15742: PPUSH
15743: LD_INT 10
15745: PPUSH
15746: LD_INT 1
15748: PPUSH
15749: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15753: LD_VAR 0 1
15757: PPUSH
15758: LD_INT 32
15760: PPUSH
15761: CALL_OW 308
15765: IFFALSE 15776
// RemoveUnit ( i ) ;
15767: LD_VAR 0 1
15771: PPUSH
15772: CALL_OW 64
// end ;
15776: GO 15695
15778: POP
15779: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15780: LD_INT 22
15782: PUSH
15783: LD_INT 8
15785: PUSH
15786: EMPTY
15787: LIST
15788: LIST
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: LD_INT 21
15795: PUSH
15796: LD_INT 1
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PUSH
15803: LD_INT 33
15805: PUSH
15806: LD_INT 1
15808: PUSH
15809: EMPTY
15810: LIST
15811: LIST
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: LIST
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PPUSH
15822: CALL_OW 69
15826: NOT
15827: IFFALSE 15678
// end ;
15829: PPOPN 2
15831: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
15832: LD_EXP 4
15836: PUSH
15837: LD_EXP 2
15841: AND
15842: PUSH
15843: LD_EXP 3
15847: AND
15848: PUSH
15849: LD_EXP 5
15853: AND
15854: PUSH
15855: LD_EXP 6
15859: AND
15860: PUSH
15861: LD_EXP 7
15865: AND
15866: PUSH
15867: LD_EXP 8
15871: AND
15872: PUSH
15873: LD_EXP 53
15877: PPUSH
15878: CALL_OW 255
15882: PUSH
15883: LD_INT 5
15885: NONEQUAL
15886: PUSH
15887: LD_EXP 53
15891: PPUSH
15892: CALL_OW 301
15896: OR
15897: PUSH
15898: LD_EXP 53
15902: PPUSH
15903: CALL_OW 305
15907: NOT
15908: OR
15909: AND
15910: IFFALSE 17301
15912: GO 15914
15914: DISABLE
15915: LD_INT 0
15917: PPUSH
15918: PPUSH
// begin wait ( 0 0$5 ) ;
15919: LD_INT 175
15921: PPUSH
15922: CALL_OW 67
// music_class := 5 ;
15926: LD_ADDR_OWVAR 72
15930: PUSH
15931: LD_INT 5
15933: ST_TO_ADDR
// music_nat := 5 ;
15934: LD_ADDR_OWVAR 71
15938: PUSH
15939: LD_INT 5
15941: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15942: LD_EXP 15
15946: PUSH
15947: LD_INT 3
15949: LESS
15950: IFFALSE 15959
// SetAchievement ( ACH_ECONOMY ) ;
15952: LD_STRING ACH_ECONOMY
15954: PPUSH
15955: CALL_OW 543
// if tick < 60 60$00 then
15959: LD_OWVAR 1
15963: PUSH
15964: LD_INT 126000
15966: LESS
15967: IFFALSE 15983
// begin wait ( 3 ) ;
15969: LD_INT 3
15971: PPUSH
15972: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15976: LD_STRING ACH_ASPEED_19
15978: PPUSH
15979: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15983: LD_EXP 17
15987: PPUSH
15988: CALL_OW 87
// InGameOn ;
15992: CALL_OW 8
// DialogueOn ;
15996: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16000: LD_EXP 17
16004: PPUSH
16005: LD_STRING DEnd-JMM-JMM-1
16007: PPUSH
16008: CALL_OW 88
// if Joan then
16012: LD_EXP 32
16016: IFFALSE 16032
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16018: LD_EXP 32
16022: PPUSH
16023: LD_STRING DEnd-JMM-Joan-1
16025: PPUSH
16026: CALL_OW 88
16030: GO 16076
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16032: LD_EXP 19
16036: PUSH
16037: LD_EXP 19
16041: PPUSH
16042: CALL_OW 255
16046: PUSH
16047: LD_INT 7
16049: EQUAL
16050: AND
16051: PUSH
16052: LD_EXP 19
16056: PPUSH
16057: CALL_OW 305
16061: AND
16062: IFFALSE 16076
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16064: LD_EXP 19
16068: PPUSH
16069: LD_STRING DEnd-JMM-Lisa-1
16071: PPUSH
16072: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16076: LD_EXP 29
16080: PUSH
16081: LD_EXP 29
16085: PPUSH
16086: CALL_OW 305
16090: AND
16091: IFFALSE 16105
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16093: LD_EXP 29
16097: PPUSH
16098: LD_STRING DEnd-JMM-Frank-1
16100: PPUSH
16101: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16105: LD_EXP 22
16109: PUSH
16110: LD_EXP 22
16114: PPUSH
16115: CALL_OW 255
16119: PUSH
16120: LD_INT 7
16122: EQUAL
16123: AND
16124: PUSH
16125: LD_EXP 22
16129: PPUSH
16130: CALL_OW 305
16134: AND
16135: IFFALSE 16149
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16137: LD_EXP 22
16141: PPUSH
16142: LD_STRING DEnd-JMM-Cyrus-1
16144: PPUSH
16145: CALL_OW 88
// if Burlak then
16149: LD_EXP 49
16153: IFFALSE 16167
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16155: LD_EXP 49
16159: PPUSH
16160: LD_STRING DEnd-JMM-Bur-1
16162: PPUSH
16163: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16167: LD_EXP 32
16171: PUSH
16172: LD_EXP 19
16176: AND
16177: PUSH
16178: LD_EXP 19
16182: PPUSH
16183: CALL_OW 255
16187: PUSH
16188: LD_INT 7
16190: EQUAL
16191: AND
16192: PUSH
16193: LD_EXP 19
16197: PPUSH
16198: CALL_OW 305
16202: AND
16203: IFFALSE 16217
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16205: LD_EXP 19
16209: PPUSH
16210: LD_STRING DEnd-Burlak-Lisa-1
16212: PPUSH
16213: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16217: LD_EXP 50
16221: PUSH
16222: LD_EXP 50
16226: PPUSH
16227: CALL_OW 305
16231: AND
16232: IFFALSE 16246
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16234: LD_EXP 50
16238: PPUSH
16239: LD_STRING DEnd-JMM-Bel-1
16241: PPUSH
16242: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16246: LD_EXP 51
16250: PUSH
16251: LD_EXP 51
16255: PPUSH
16256: CALL_OW 305
16260: AND
16261: IFFALSE 16275
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16263: LD_EXP 51
16267: PPUSH
16268: LD_STRING DEnd-JMM-Gny-1
16270: PPUSH
16271: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16275: LD_EXP 27
16279: PUSH
16280: LD_EXP 27
16284: PPUSH
16285: CALL_OW 255
16289: PUSH
16290: LD_INT 7
16292: EQUAL
16293: AND
16294: PUSH
16295: LD_EXP 27
16299: PPUSH
16300: CALL_OW 305
16304: AND
16305: IFFALSE 16319
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16307: LD_EXP 27
16311: PPUSH
16312: LD_STRING DEnd-JMM-Corn-1
16314: PPUSH
16315: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16319: LD_EXP 20
16323: PUSH
16324: LD_EXP 20
16328: PPUSH
16329: CALL_OW 255
16333: PUSH
16334: LD_INT 7
16336: EQUAL
16337: AND
16338: PUSH
16339: LD_EXP 20
16343: PPUSH
16344: CALL_OW 305
16348: AND
16349: IFFALSE 16363
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16351: LD_EXP 20
16355: PPUSH
16356: LD_STRING DEnd-JMM-Don-1
16358: PPUSH
16359: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16363: LD_EXP 21
16367: PUSH
16368: LD_EXP 21
16372: PPUSH
16373: CALL_OW 255
16377: PUSH
16378: LD_INT 7
16380: EQUAL
16381: AND
16382: PUSH
16383: LD_EXP 21
16387: PPUSH
16388: CALL_OW 305
16392: AND
16393: IFFALSE 16407
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16395: LD_EXP 21
16399: PPUSH
16400: LD_STRING DEnd-JMM-Bobby-1
16402: PPUSH
16403: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16407: LD_EXP 23
16411: PUSH
16412: LD_EXP 23
16416: PPUSH
16417: CALL_OW 255
16421: PUSH
16422: LD_INT 7
16424: EQUAL
16425: AND
16426: PUSH
16427: LD_EXP 23
16431: PPUSH
16432: CALL_OW 305
16436: AND
16437: IFFALSE 16451
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16439: LD_EXP 23
16443: PPUSH
16444: LD_STRING DEnd-JMM-Den-1
16446: PPUSH
16447: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16451: LD_EXP 25
16455: PUSH
16456: LD_EXP 25
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 7
16468: EQUAL
16469: AND
16470: PUSH
16471: LD_EXP 25
16475: PPUSH
16476: CALL_OW 305
16480: AND
16481: IFFALSE 16495
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16483: LD_EXP 25
16487: PPUSH
16488: LD_STRING DEnd-JMM-Glad-1
16490: PPUSH
16491: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16495: LD_EXP 30
16499: PUSH
16500: LD_EXP 30
16504: PPUSH
16505: CALL_OW 255
16509: PUSH
16510: LD_INT 7
16512: EQUAL
16513: AND
16514: PUSH
16515: LD_EXP 30
16519: PPUSH
16520: CALL_OW 305
16524: AND
16525: IFFALSE 16539
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16527: LD_EXP 30
16531: PPUSH
16532: LD_STRING DEnd-JMM-Yam-1
16534: PPUSH
16535: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 24
16548: PPUSH
16549: CALL_OW 255
16553: PUSH
16554: LD_INT 7
16556: EQUAL
16557: AND
16558: PUSH
16559: LD_EXP 24
16563: PPUSH
16564: CALL_OW 305
16568: AND
16569: IFFALSE 16583
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16571: LD_EXP 24
16575: PPUSH
16576: LD_STRING DEnd-JMM-Brown-1
16578: PPUSH
16579: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16583: LD_EXP 34
16587: PUSH
16588: LD_EXP 34
16592: PPUSH
16593: CALL_OW 255
16597: PUSH
16598: LD_INT 7
16600: EQUAL
16601: AND
16602: PUSH
16603: LD_EXP 34
16607: PPUSH
16608: CALL_OW 305
16612: AND
16613: IFFALSE 16627
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16615: LD_EXP 34
16619: PPUSH
16620: LD_STRING DEnd-JMM-Con-1
16622: PPUSH
16623: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16627: LD_EXP 28
16631: PUSH
16632: LD_EXP 28
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 28
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16659: LD_EXP 28
16663: PPUSH
16664: LD_STRING DEnd-JMM-Gary-1
16666: PPUSH
16667: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 18
16680: AND
16681: PUSH
16682: LD_EXP 31
16686: PPUSH
16687: CALL_OW 305
16691: AND
16692: IFFALSE 16706
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16694: LD_EXP 31
16698: PPUSH
16699: LD_STRING DEnd-JMM-Sim-1
16701: PPUSH
16702: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16706: LD_EXP 26
16710: PUSH
16711: LD_EXP 26
16715: PPUSH
16716: CALL_OW 255
16720: PUSH
16721: LD_INT 7
16723: EQUAL
16724: AND
16725: PUSH
16726: LD_EXP 26
16730: PPUSH
16731: CALL_OW 305
16735: AND
16736: IFFALSE 16750
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16738: LD_EXP 26
16742: PPUSH
16743: LD_STRING DEnd-JMM-VanH-1
16745: PPUSH
16746: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16750: LD_EXP 39
16754: PUSH
16755: LD_EXP 39
16759: PPUSH
16760: CALL_OW 305
16764: AND
16765: IFFALSE 16779
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16767: LD_EXP 39
16771: PPUSH
16772: LD_STRING DEnd-JMM-Dol-1
16774: PPUSH
16775: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16779: LD_EXP 43
16783: PUSH
16784: LD_EXP 43
16788: PPUSH
16789: CALL_OW 305
16793: AND
16794: IFFALSE 16808
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16796: LD_EXP 43
16800: PPUSH
16801: LD_STRING DEnd-JMM-Kap-1
16803: PPUSH
16804: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16808: LD_EXP 46
16812: PUSH
16813: LD_EXP 46
16817: PPUSH
16818: CALL_OW 305
16822: AND
16823: IFFALSE 16837
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16825: LD_EXP 46
16829: PPUSH
16830: LD_STRING DEnd-JMM-Kov-1
16832: PPUSH
16833: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16837: LD_EXP 41
16841: PUSH
16842: LD_EXP 41
16846: PPUSH
16847: CALL_OW 305
16851: AND
16852: IFFALSE 16866
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16854: LD_EXP 41
16858: PPUSH
16859: LD_STRING DEnd-JMM-Sch-1
16861: PPUSH
16862: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16866: LD_EXP 37
16870: PUSH
16871: LD_EXP 37
16875: PPUSH
16876: CALL_OW 305
16880: AND
16881: IFFALSE 16895
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16883: LD_EXP 37
16887: PPUSH
16888: LD_STRING DEnd-JMM-Tit-1
16890: PPUSH
16891: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16895: LD_EXP 42
16899: PUSH
16900: LD_EXP 42
16904: PPUSH
16905: CALL_OW 305
16909: AND
16910: IFFALSE 16924
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16912: LD_EXP 42
16916: PPUSH
16917: LD_STRING DEnd-JMM-Obl-1
16919: PPUSH
16920: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16924: LD_EXP 44
16928: PUSH
16929: LD_EXP 44
16933: PPUSH
16934: CALL_OW 305
16938: AND
16939: IFFALSE 16953
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16941: LD_EXP 44
16945: PPUSH
16946: LD_STRING DEnd-JMM-Lip-1
16948: PPUSH
16949: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16953: LD_EXP 38
16957: PUSH
16958: LD_EXP 38
16962: PPUSH
16963: CALL_OW 305
16967: AND
16968: PUSH
16969: LD_EXP 49
16973: AND
16974: IFFALSE 16988
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16976: LD_EXP 38
16980: PPUSH
16981: LD_STRING DEnd-Burlak-Fad-1
16983: PPUSH
16984: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16988: LD_EXP 45
16992: PUSH
16993: LD_EXP 45
16997: PPUSH
16998: CALL_OW 305
17002: AND
17003: IFFALSE 17017
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17005: LD_EXP 45
17009: PPUSH
17010: LD_STRING DEnd-Burlak-Ptr-1
17012: PPUSH
17013: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17017: LD_EXP 47
17021: PUSH
17022: LD_EXP 47
17026: PPUSH
17027: CALL_OW 305
17031: AND
17032: IFFALSE 17046
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17034: LD_EXP 47
17038: PPUSH
17039: LD_STRING DEnd-Burlak-Kuz-1
17041: PPUSH
17042: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17046: LD_EXP 36
17050: PUSH
17051: LD_EXP 36
17055: PPUSH
17056: CALL_OW 305
17060: AND
17061: PUSH
17062: LD_EXP 49
17066: AND
17067: IFFALSE 17081
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17069: LD_EXP 36
17073: PPUSH
17074: LD_STRING DEnd-Burlak-Kir-1
17076: PPUSH
17077: CALL_OW 88
// if Burlak then
17081: LD_EXP 49
17085: IFFALSE 17099
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17087: LD_EXP 17
17091: PPUSH
17092: LD_STRING DEnd-Burlak-JMM-1
17094: PPUSH
17095: CALL_OW 88
// dwait ( 0 0$2 ) ;
17099: LD_INT 70
17101: PPUSH
17102: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17106: LD_EXP 54
17110: PPUSH
17111: LD_STRING DEnd-Szulc
17113: PPUSH
17114: CALL_OW 94
// dwait ( 0 0$1 ) ;
17118: LD_INT 35
17120: PPUSH
17121: CALL_OW 68
// if IsLive ( Burlak ) then
17125: LD_EXP 49
17129: PPUSH
17130: CALL_OW 300
17134: IFFALSE 17146
// med1 := 1 else
17136: LD_ADDR_VAR 0 1
17140: PUSH
17141: LD_INT 1
17143: ST_TO_ADDR
17144: GO 17155
// med1 := - 1 ;
17146: LD_ADDR_VAR 0 1
17150: PUSH
17151: LD_INT 1
17153: NEG
17154: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17155: LD_EXP 12
17159: PUSH
17160: LD_EXP 13
17164: AND
17165: PUSH
17166: LD_EXP 14
17170: AND
17171: IFFALSE 17183
// med2 := 1 else
17173: LD_ADDR_VAR 0 2
17177: PUSH
17178: LD_INT 1
17180: ST_TO_ADDR
17181: GO 17192
// med2 := - 1 ;
17183: LD_ADDR_VAR 0 2
17187: PUSH
17188: LD_INT 1
17190: NEG
17191: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17192: LD_STRING Hero
17194: PPUSH
17195: LD_INT 1
17197: PPUSH
17198: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17202: LD_STRING Artefact
17204: PPUSH
17205: LD_VAR 0 2
17209: PPUSH
17210: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17214: LD_STRING ReconcileBurlak
17216: PPUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17226: LD_OWVAR 67
17230: PUSH
17231: LD_INT 3
17233: EQUAL
17234: PUSH
17235: LD_VAR 0 1
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: AND
17244: PUSH
17245: LD_VAR 0 2
17249: PUSH
17250: LD_INT 1
17252: EQUAL
17253: AND
17254: IFFALSE 17266
// SetAchievementEX ( ACH_AMER , 19 ) ;
17256: LD_STRING ACH_AMER
17258: PPUSH
17259: LD_INT 19
17261: PPUSH
17262: CALL_OW 564
// GiveMedals ( MAIN ) ;
17266: LD_STRING MAIN
17268: PPUSH
17269: CALL_OW 102
// InGameOff ;
17273: CALL_OW 9
// DialogueOff ;
17277: CALL_OW 7
// music_nat := 1 ;
17281: LD_ADDR_OWVAR 71
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// music_class := 4 ;
17289: LD_ADDR_OWVAR 72
17293: PUSH
17294: LD_INT 4
17296: ST_TO_ADDR
// YouWin ;
17297: CALL_OW 103
// end ; end_of_file
17301: PPOPN 2
17303: END
// export function InitNature ; begin
17304: LD_INT 0
17306: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17307: LD_INT 3
17309: PPUSH
17310: LD_INT 3
17312: PPUSH
17313: LD_INT 2
17315: PPUSH
17316: LD_INT 1
17318: PPUSH
17319: LD_INT 1
17321: PPUSH
17322: LD_INT 0
17324: PPUSH
17325: LD_INT 0
17327: PPUSH
17328: LD_INT 17
17330: PPUSH
17331: LD_INT 0
17333: PPUSH
17334: CALL 84644 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17338: LD_INT 2
17340: PPUSH
17341: LD_INT 1
17343: PPUSH
17344: LD_INT 1
17346: PPUSH
17347: LD_INT 1
17349: PPUSH
17350: LD_INT 1
17352: PPUSH
17353: LD_INT 0
17355: PPUSH
17356: LD_INT 0
17358: PPUSH
17359: LD_INT 18
17361: PPUSH
17362: LD_INT 0
17364: PPUSH
17365: CALL 84644 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17369: LD_INT 4
17371: PPUSH
17372: LD_INT 1
17374: PPUSH
17375: LD_INT 2
17377: PPUSH
17378: LD_INT 4
17380: PPUSH
17381: LD_INT 2
17383: PPUSH
17384: LD_INT 1
17386: PPUSH
17387: LD_INT 0
17389: PPUSH
17390: LD_INT 19
17392: PPUSH
17393: LD_INT 0
17395: PPUSH
17396: CALL 84644 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17400: LD_INT 0
17402: PPUSH
17403: LD_INT 0
17405: PPUSH
17406: LD_INT 0
17408: PPUSH
17409: LD_INT 0
17411: PPUSH
17412: LD_INT 0
17414: PPUSH
17415: LD_INT 0
17417: PPUSH
17418: LD_INT 9
17420: PPUSH
17421: LD_INT 0
17423: PPUSH
17424: LD_INT 20
17426: PPUSH
17427: CALL 84644 0 9
// end ; end_of_file
17431: LD_VAR 0 1
17435: RET
// every 0 0$30 do var time ;
17436: GO 17438
17438: DISABLE
17439: LD_INT 0
17441: PPUSH
// begin time := 0 0$30 ;
17442: LD_ADDR_VAR 0 1
17446: PUSH
17447: LD_INT 1050
17449: ST_TO_ADDR
// repeat wait ( time ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: CALL_OW 67
// if Prob ( 50 ) then
17459: LD_INT 50
17461: PPUSH
17462: CALL_OW 13
17466: IFFALSE 17495
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17468: LD_INT 1
17470: PPUSH
17471: LD_INT 5
17473: PPUSH
17474: CALL_OW 12
17478: PPUSH
17479: LD_INT 106
17481: PPUSH
17482: LD_INT 89
17484: PPUSH
17485: LD_INT 45
17487: PPUSH
17488: LD_INT 1
17490: PPUSH
17491: CALL_OW 56
// time := time + 0 0$3 ;
17495: LD_ADDR_VAR 0 1
17499: PUSH
17500: LD_VAR 0 1
17504: PUSH
17505: LD_INT 105
17507: PLUS
17508: ST_TO_ADDR
// if Prob ( 30 ) then
17509: LD_INT 30
17511: PPUSH
17512: CALL_OW 13
17516: IFFALSE 17562
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17518: LD_INT 525
17520: PPUSH
17521: LD_INT 735
17523: PPUSH
17524: CALL_OW 12
17528: PPUSH
17529: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17533: LD_INT 1
17535: PPUSH
17536: LD_INT 5
17538: PPUSH
17539: CALL_OW 12
17543: PPUSH
17544: LD_INT 21
17546: PPUSH
17547: LD_INT 26
17549: PPUSH
17550: LD_INT 12
17552: PPUSH
17553: LD_INT 1
17555: PPUSH
17556: CALL_OW 56
// end else
17560: GO 17598
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17562: LD_INT 700
17564: PPUSH
17565: LD_INT 1225
17567: PPUSH
17568: CALL_OW 12
17572: PPUSH
17573: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17577: LD_INT 1
17579: PPUSH
17580: LD_INT 5
17582: PPUSH
17583: CALL_OW 12
17587: PPUSH
17588: LD_INT 14
17590: PPUSH
17591: LD_INT 1
17593: PPUSH
17594: CALL_OW 55
// end ; if Prob ( 50 ) then
17598: LD_INT 50
17600: PPUSH
17601: CALL_OW 13
17605: IFFALSE 17651
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17607: LD_INT 700
17609: PPUSH
17610: LD_INT 1050
17612: PPUSH
17613: CALL_OW 12
17617: PPUSH
17618: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17622: LD_INT 1
17624: PPUSH
17625: LD_INT 5
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: LD_INT 181
17635: PPUSH
17636: LD_INT 218
17638: PPUSH
17639: LD_INT 16
17641: PPUSH
17642: LD_INT 1
17644: PPUSH
17645: CALL_OW 56
// end else
17649: GO 17723
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17651: LD_INT 350
17653: PPUSH
17654: LD_INT 525
17656: PPUSH
17657: CALL_OW 12
17661: PPUSH
17662: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17666: LD_INT 1
17668: PPUSH
17669: LD_INT 5
17671: PPUSH
17672: CALL_OW 12
17676: PPUSH
17677: LD_INT 13
17679: PPUSH
17680: LD_INT 1
17682: PPUSH
17683: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17687: LD_INT 350
17689: PPUSH
17690: LD_INT 700
17692: PPUSH
17693: CALL_OW 12
17697: PPUSH
17698: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17702: LD_INT 1
17704: PPUSH
17705: LD_INT 5
17707: PPUSH
17708: CALL_OW 12
17712: PPUSH
17713: LD_INT 33
17715: PPUSH
17716: LD_INT 1
17718: PPUSH
17719: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17723: LD_INT 65
17725: PUSH
17726: LD_INT 62
17728: PUSH
17729: LD_INT 55
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: PUSH
17737: LD_OWVAR 67
17741: ARRAY
17742: PPUSH
17743: CALL_OW 13
17747: IFFALSE 17793
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17749: LD_INT 525
17751: PPUSH
17752: LD_INT 875
17754: PPUSH
17755: CALL_OW 12
17759: PPUSH
17760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17764: LD_INT 1
17766: PPUSH
17767: LD_INT 5
17769: PPUSH
17770: CALL_OW 12
17774: PPUSH
17775: LD_INT 294
17777: PPUSH
17778: LD_INT 211
17780: PPUSH
17781: LD_INT 30
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: CALL_OW 56
// end else
17791: GO 17835
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17793: LD_INT 420
17795: PPUSH
17796: LD_INT 770
17798: PPUSH
17799: CALL_OW 12
17803: PPUSH
17804: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17808: LD_INT 1
17810: PPUSH
17811: LD_INT 5
17813: PPUSH
17814: CALL_OW 12
17818: PPUSH
17819: LD_INT 294
17821: PPUSH
17822: LD_INT 211
17824: PPUSH
17825: LD_INT 30
17827: PPUSH
17828: LD_INT 1
17830: PPUSH
17831: CALL_OW 56
// end ; if time > 2 2$20 then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_INT 4900
17842: GREATER
17843: IFFALSE 17853
// time := 0 0$50 ;
17845: LD_ADDR_VAR 0 1
17849: PUSH
17850: LD_INT 1750
17852: ST_TO_ADDR
// until false ;
17853: LD_INT 0
17855: IFFALSE 17450
// end ;
17857: PPOPN 1
17859: END
// every 0 0$45 trigger tick < 10 10$00 do
17860: LD_OWVAR 1
17864: PUSH
17865: LD_INT 21000
17867: LESS
17868: IFFALSE 17916
17870: GO 17872
17872: DISABLE
// begin enable ;
17873: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17874: LD_INT 350
17876: PPUSH
17877: LD_INT 700
17879: PPUSH
17880: CALL_OW 12
17884: PPUSH
17885: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17889: LD_INT 3
17891: PPUSH
17892: LD_INT 5
17894: PPUSH
17895: CALL_OW 12
17899: PPUSH
17900: LD_INT 181
17902: PPUSH
17903: LD_INT 13
17905: PPUSH
17906: LD_INT 20
17908: PPUSH
17909: LD_INT 1
17911: PPUSH
17912: CALL_OW 56
// end ; end_of_file
17916: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17917: LD_INT 0
17919: PPUSH
// SetArtifactRes ( 7 , true ) ;
17920: LD_INT 7
17922: PPUSH
17923: LD_INT 1
17925: PPUSH
17926: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17930: LD_ADDR_EXP 62
17934: PUSH
17935: EMPTY
17936: PUSH
17937: EMPTY
17938: PUSH
17939: EMPTY
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17946: LD_ADDR_EXP 63
17950: PUSH
17951: LD_INT 1050
17953: PUSH
17954: LD_OWVAR 67
17958: MUL
17959: PUSH
17960: LD_INT 2800
17962: PUSH
17963: LD_OWVAR 67
17967: MUL
17968: PUSH
17969: LD_INT 1
17971: NEG
17972: PUSH
17973: EMPTY
17974: LIST
17975: LIST
17976: LIST
17977: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17978: LD_ADDR_EXP 64
17982: PUSH
17983: LD_INT 10
17985: PUSH
17986: LD_INT 35
17988: PUSH
17989: LD_INT 100
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17997: LD_ADDR_EXP 65
18001: PUSH
18002: LD_INT 0
18004: PUSH
18005: LD_INT 0
18007: PUSH
18008: LD_INT 0
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18016: LD_ADDR_EXP 67
18020: PUSH
18021: LD_INT 300
18023: PUSH
18024: LD_INT 500
18026: PUSH
18027: LD_INT 800
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: LIST
18034: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18035: LD_ADDR_EXP 68
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: LD_INT 0
18045: PUSH
18046: LD_INT 0
18048: PUSH
18049: EMPTY
18050: LIST
18051: LIST
18052: LIST
18053: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18054: LD_ADDR_EXP 69
18058: PUSH
18059: LD_INT 0
18061: PUSH
18062: LD_INT 0
18064: PUSH
18065: LD_INT 0
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: LIST
18072: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18073: LD_ADDR_EXP 66
18077: PUSH
18078: LD_INT 0
18080: PUSH
18081: LD_INT 0
18083: PUSH
18084: LD_INT 0
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18092: LD_ADDR_EXP 70
18096: PUSH
18097: LD_INT 4
18099: PUSH
18100: LD_INT 3
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: LIST
18110: PUSH
18111: LD_INT 5
18113: PUSH
18114: LD_INT 4
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 6
18127: PUSH
18128: LD_INT 3
18130: PUSH
18131: LD_INT 3
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18144: LD_ADDR_EXP 71
18148: PUSH
18149: LD_INT 0
18151: PUSH
18152: LD_INT 0
18154: PUSH
18155: LD_INT 0
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 1
18167: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18168: LD_INT 24
18170: PPUSH
18171: LD_INT 7
18173: PPUSH
18174: CALL_OW 321
18178: PUSH
18179: LD_INT 2
18181: EQUAL
18182: IFFALSE 19108
18184: GO 18186
18186: DISABLE
18187: LD_INT 0
18189: PPUSH
18190: PPUSH
18191: PPUSH
18192: PPUSH
18193: PPUSH
// begin enable ;
18194: ENABLE
// for i = 1 to 3 do
18195: LD_ADDR_VAR 0 1
18199: PUSH
18200: DOUBLE
18201: LD_INT 1
18203: DEC
18204: ST_TO_ADDR
18205: LD_INT 3
18207: PUSH
18208: FOR_TO
18209: IFFALSE 19106
// begin pos := FindArtifact ( i + 2 ) ;
18211: LD_ADDR_VAR 0 2
18215: PUSH
18216: LD_VAR 0 1
18220: PUSH
18221: LD_INT 2
18223: PLUS
18224: PPUSH
18225: CALL_OW 469
18229: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18230: LD_ADDR_EXP 62
18234: PUSH
18235: LD_EXP 62
18239: PPUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: LD_VAR 0 2
18249: PPUSH
18250: CALL_OW 1
18254: ST_TO_ADDR
// if pos then
18255: LD_VAR 0 2
18259: IFFALSE 18967
// begin case i of 1 :
18261: LD_VAR 0 1
18265: PUSH
18266: LD_INT 1
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18351
18274: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 7
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PUSH
18290: LD_INT 23
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 2
18302: PUSH
18303: LD_INT 30
18305: PUSH
18306: LD_INT 8
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 7
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 11
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 69
18348: ST_TO_ADDR
18349: GO 18459
18351: LD_INT 2
18353: DOUBLE
18354: EQUAL
18355: IFTRUE 18359
18357: GO 18436
18359: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18360: LD_ADDR_VAR 0 4
18364: PUSH
18365: LD_INT 22
18367: PUSH
18368: LD_INT 7
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: PUSH
18375: LD_INT 23
18377: PUSH
18378: LD_INT 3
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 2
18387: PUSH
18388: LD_INT 30
18390: PUSH
18391: LD_INT 8
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: LD_INT 30
18400: PUSH
18401: LD_INT 7
18403: PUSH
18404: EMPTY
18405: LIST
18406: LIST
18407: PUSH
18408: LD_INT 30
18410: PUSH
18411: LD_INT 11
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: LIST
18423: PUSH
18424: EMPTY
18425: LIST
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 69
18433: ST_TO_ADDR
18434: GO 18459
18436: LD_INT 3
18438: DOUBLE
18439: EQUAL
18440: IFTRUE 18444
18442: GO 18458
18444: POP
// labs := [ alien ] ; end ;
18445: LD_ADDR_VAR 0 4
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: ST_TO_ADDR
18456: GO 18459
18458: POP
// if not labs then
18459: LD_VAR 0 4
18463: NOT
18464: IFFALSE 18468
// continue ;
18466: GO 18208
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18468: LD_ADDR_VAR 0 5
18472: PUSH
18473: LD_VAR 0 4
18477: PPUSH
18478: LD_EXP 62
18482: PUSH
18483: LD_VAR 0 1
18487: ARRAY
18488: PUSH
18489: LD_INT 1
18491: ARRAY
18492: PPUSH
18493: LD_EXP 62
18497: PUSH
18498: LD_VAR 0 1
18502: ARRAY
18503: PUSH
18504: LD_INT 2
18506: ARRAY
18507: PPUSH
18508: CALL_OW 73
18512: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18513: LD_VAR 0 5
18517: NOT
18518: PUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_EXP 69
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NONEQUAL
18535: OR
18536: IFFALSE 18641
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18538: LD_INT 7
18540: PPUSH
18541: LD_EXP 70
18545: PUSH
18546: LD_VAR 0 1
18550: ARRAY
18551: PUSH
18552: LD_INT 3
18554: ARRAY
18555: PPUSH
18556: LD_INT 0
18558: PPUSH
18559: LD_EXP 69
18563: PUSH
18564: LD_VAR 0 1
18568: ARRAY
18569: PPUSH
18570: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18574: LD_INT 7
18576: PPUSH
18577: LD_EXP 70
18581: PUSH
18582: LD_VAR 0 1
18586: ARRAY
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: PPUSH
18592: LD_INT 0
18594: PPUSH
18595: LD_EXP 69
18599: PUSH
18600: LD_VAR 0 1
18604: ARRAY
18605: PPUSH
18606: CALL_OW 468
// if nearestLab then
18610: LD_VAR 0 5
18614: IFFALSE 18641
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18616: LD_ADDR_EXP 69
18620: PUSH
18621: LD_EXP 69
18625: PPUSH
18626: LD_VAR 0 1
18630: PPUSH
18631: LD_VAR 0 5
18635: PPUSH
18636: CALL_OW 1
18640: ST_TO_ADDR
// end ; if not nearestLab then
18641: LD_VAR 0 5
18645: NOT
18646: IFFALSE 18650
// continue ;
18648: GO 18208
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18650: LD_VAR 0 5
18654: PPUSH
18655: LD_EXP 62
18659: PUSH
18660: LD_VAR 0 1
18664: ARRAY
18665: PUSH
18666: LD_INT 1
18668: ARRAY
18669: PPUSH
18670: LD_EXP 62
18674: PUSH
18675: LD_VAR 0 1
18679: ARRAY
18680: PUSH
18681: LD_INT 2
18683: ARRAY
18684: PPUSH
18685: CALL_OW 297
18689: PUSH
18690: LD_INT 8
18692: LESS
18693: IFFALSE 18890
// begin if not artifactsResearched [ i ] then
18695: LD_EXP 65
18699: PUSH
18700: LD_VAR 0 1
18704: ARRAY
18705: NOT
18706: IFFALSE 18787
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 461
18717: PUSH
18718: LD_INT 2
18720: EQUAL
18721: IFFALSE 18755
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18723: LD_INT 7
18725: PPUSH
18726: LD_EXP 70
18730: PUSH
18731: LD_VAR 0 1
18735: ARRAY
18736: PUSH
18737: LD_INT 3
18739: ARRAY
18740: PPUSH
18741: LD_INT 2
18743: PPUSH
18744: LD_VAR 0 5
18748: PPUSH
18749: CALL_OW 468
18753: GO 18785
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18755: LD_INT 7
18757: PPUSH
18758: LD_EXP 70
18762: PUSH
18763: LD_VAR 0 1
18767: ARRAY
18768: PUSH
18769: LD_INT 3
18771: ARRAY
18772: PPUSH
18773: LD_INT 1
18775: PPUSH
18776: LD_VAR 0 5
18780: PPUSH
18781: CALL_OW 468
// end else
18785: GO 18888
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18787: LD_VAR 0 5
18791: PPUSH
18792: CALL_OW 461
18796: PUSH
18797: LD_INT 2
18799: EQUAL
18800: PUSH
18801: LD_EXP 71
18805: PUSH
18806: LD_VAR 0 1
18810: ARRAY
18811: AND
18812: IFFALSE 18858
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18814: LD_INT 7
18816: PPUSH
18817: LD_EXP 70
18821: PUSH
18822: LD_VAR 0 1
18826: ARRAY
18827: PUSH
18828: LD_INT 1
18830: ARRAY
18831: PPUSH
18832: LD_EXP 70
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PUSH
18843: LD_INT 2
18845: ARRAY
18846: PPUSH
18847: LD_VAR 0 5
18851: PPUSH
18852: CALL_OW 468
18856: GO 18888
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18858: LD_INT 7
18860: PPUSH
18861: LD_EXP 70
18865: PUSH
18866: LD_VAR 0 1
18870: ARRAY
18871: PUSH
18872: LD_INT 1
18874: ARRAY
18875: PPUSH
18876: LD_INT 1
18878: PPUSH
18879: LD_VAR 0 5
18883: PPUSH
18884: CALL_OW 468
// end else
18888: GO 18965
// begin if not artifactsResearched [ i ] then
18890: LD_EXP 65
18894: PUSH
18895: LD_VAR 0 1
18899: ARRAY
18900: NOT
18901: IFFALSE 18935
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18903: LD_INT 7
18905: PPUSH
18906: LD_EXP 70
18910: PUSH
18911: LD_VAR 0 1
18915: ARRAY
18916: PUSH
18917: LD_INT 3
18919: ARRAY
18920: PPUSH
18921: LD_INT 0
18923: PPUSH
18924: LD_VAR 0 5
18928: PPUSH
18929: CALL_OW 468
18933: GO 18965
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18935: LD_INT 7
18937: PPUSH
18938: LD_EXP 70
18942: PUSH
18943: LD_VAR 0 1
18947: ARRAY
18948: PUSH
18949: LD_INT 1
18951: ARRAY
18952: PPUSH
18953: LD_INT 0
18955: PPUSH
18956: LD_VAR 0 5
18960: PPUSH
18961: CALL_OW 468
// end ; end else
18965: GO 19104
// begin if not artifactsLabs [ i ] then
18967: LD_EXP 69
18971: PUSH
18972: LD_VAR 0 1
18976: ARRAY
18977: NOT
18978: IFFALSE 18982
// continue ;
18980: GO 18208
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18982: LD_INT 7
18984: PPUSH
18985: LD_EXP 70
18989: PUSH
18990: LD_VAR 0 1
18994: ARRAY
18995: PUSH
18996: LD_INT 3
18998: ARRAY
18999: PPUSH
19000: LD_INT 0
19002: PPUSH
19003: LD_EXP 69
19007: PUSH
19008: LD_VAR 0 1
19012: ARRAY
19013: PPUSH
19014: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19018: LD_INT 7
19020: PPUSH
19021: LD_EXP 70
19025: PUSH
19026: LD_VAR 0 1
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: ARRAY
19035: PPUSH
19036: LD_INT 0
19038: PPUSH
19039: LD_EXP 69
19043: PUSH
19044: LD_VAR 0 1
19048: ARRAY
19049: PPUSH
19050: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19054: LD_EXP 66
19058: PUSH
19059: LD_VAR 0 1
19063: ARRAY
19064: IFFALSE 19104
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19066: LD_ADDR_EXP 66
19070: PUSH
19071: LD_EXP 66
19075: PPUSH
19076: LD_VAR 0 1
19080: PPUSH
19081: LD_INT 0
19083: PPUSH
19084: CALL_OW 1
19088: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19089: LD_EXP 69
19093: PUSH
19094: LD_VAR 0 1
19098: ARRAY
19099: PPUSH
19100: CALL_OW 127
// end ; end ; end ;
19104: GO 18208
19106: POP
19107: POP
// end ;
19108: PPOPN 5
19110: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19111: LD_INT 0
19113: PPUSH
19114: PPUSH
19115: PPUSH
19116: PPUSH
19117: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19118: LD_VAR 0 2
19122: PUSH
19123: LD_EXP 70
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PUSH
19132: LD_INT 3
19134: ARRAY
19135: EQUAL
19136: IFFALSE 19259
// begin lab := artifactsLabs [ 1 ] ;
19138: LD_ADDR_VAR 0 6
19142: PUSH
19143: LD_EXP 69
19147: PUSH
19148: LD_INT 1
19150: ARRAY
19151: ST_TO_ADDR
// if not lab then
19152: LD_VAR 0 6
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19161: LD_VAR 0 6
19165: PPUSH
19166: LD_EXP 67
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: PPUSH
19175: LD_INT 1
19177: PPUSH
19178: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19182: LD_EXP 68
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: IFFALSE 19210
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19192: LD_VAR 0 6
19196: PPUSH
19197: LD_EXP 68
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19210: LD_ADDR_EXP 66
19214: PUSH
19215: LD_EXP 66
19219: PPUSH
19220: LD_INT 1
19222: PPUSH
19223: LD_INT 1
19225: PPUSH
19226: CALL_OW 1
19230: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19231: LD_INT 7
19233: PPUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: PPUSH
19247: LD_INT 0
19249: PPUSH
19250: LD_VAR 0 6
19254: PPUSH
19255: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19259: LD_VAR 0 2
19263: PUSH
19264: LD_EXP 70
19268: PUSH
19269: LD_INT 2
19271: ARRAY
19272: PUSH
19273: LD_INT 3
19275: ARRAY
19276: EQUAL
19277: IFFALSE 19400
// begin lab := artifactsLabs [ 2 ] ;
19279: LD_ADDR_VAR 0 6
19283: PUSH
19284: LD_EXP 69
19288: PUSH
19289: LD_INT 2
19291: ARRAY
19292: ST_TO_ADDR
// if not lab then
19293: LD_VAR 0 6
19297: NOT
19298: IFFALSE 19302
// exit ;
19300: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19302: LD_VAR 0 6
19306: PPUSH
19307: LD_EXP 67
19311: PUSH
19312: LD_INT 2
19314: ARRAY
19315: PPUSH
19316: LD_INT 1
19318: PPUSH
19319: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19323: LD_EXP 68
19327: PUSH
19328: LD_INT 2
19330: ARRAY
19331: IFFALSE 19351
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19333: LD_VAR 0 6
19337: PPUSH
19338: LD_EXP 68
19342: PUSH
19343: LD_INT 2
19345: ARRAY
19346: PPUSH
19347: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19351: LD_ADDR_EXP 66
19355: PUSH
19356: LD_EXP 66
19360: PPUSH
19361: LD_INT 2
19363: PPUSH
19364: LD_INT 1
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19372: LD_INT 7
19374: PPUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 2
19382: ARRAY
19383: PUSH
19384: LD_INT 3
19386: ARRAY
19387: PPUSH
19388: LD_INT 0
19390: PPUSH
19391: LD_VAR 0 6
19395: PPUSH
19396: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19400: LD_VAR 0 2
19404: PUSH
19405: LD_EXP 70
19409: PUSH
19410: LD_INT 3
19412: ARRAY
19413: PUSH
19414: LD_INT 3
19416: ARRAY
19417: EQUAL
19418: IFFALSE 19541
// begin lab := artifactsLabs [ 3 ] ;
19420: LD_ADDR_VAR 0 6
19424: PUSH
19425: LD_EXP 69
19429: PUSH
19430: LD_INT 3
19432: ARRAY
19433: ST_TO_ADDR
// if not lab then
19434: LD_VAR 0 6
19438: NOT
19439: IFFALSE 19443
// exit ;
19441: GO 20239
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19443: LD_VAR 0 6
19447: PPUSH
19448: LD_EXP 67
19452: PUSH
19453: LD_INT 3
19455: ARRAY
19456: PPUSH
19457: LD_INT 1
19459: PPUSH
19460: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19464: LD_EXP 68
19468: PUSH
19469: LD_INT 3
19471: ARRAY
19472: IFFALSE 19492
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19474: LD_VAR 0 6
19478: PPUSH
19479: LD_EXP 68
19483: PUSH
19484: LD_INT 3
19486: ARRAY
19487: PPUSH
19488: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19492: LD_ADDR_EXP 66
19496: PUSH
19497: LD_EXP 66
19501: PPUSH
19502: LD_INT 3
19504: PPUSH
19505: LD_INT 1
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 70
19520: PUSH
19521: LD_INT 3
19523: ARRAY
19524: PUSH
19525: LD_INT 3
19527: ARRAY
19528: PPUSH
19529: LD_INT 0
19531: PPUSH
19532: LD_VAR 0 6
19536: PPUSH
19537: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19541: LD_VAR 0 2
19545: PUSH
19546: LD_EXP 70
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: EQUAL
19559: IFFALSE 19717
// begin lab := artifactsLabs [ 1 ] ;
19561: LD_ADDR_VAR 0 6
19565: PUSH
19566: LD_EXP 69
19570: PUSH
19571: LD_INT 1
19573: ARRAY
19574: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19575: LD_VAR 0 6
19579: PPUSH
19580: CALL_OW 274
19584: PPUSH
19585: CALL 88248 0 1
19589: PUSH
19590: LD_INT 3
19592: ARRAY
19593: PUSH
19594: LD_EXP 64
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: LESS
19603: IFFALSE 19617
// begin HintSpec ( ArtifactCost , 2 ) ;
19605: LD_STRING ArtifactCost
19607: PPUSH
19608: LD_INT 2
19610: PPUSH
19611: CALL_OW 338
// exit ;
19615: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19617: LD_ADDR_EXP 71
19621: PUSH
19622: LD_EXP 71
19626: PPUSH
19627: LD_INT 1
19629: PPUSH
19630: LD_INT 0
19632: PPUSH
19633: CALL_OW 1
19637: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19638: LD_VAR 0 3
19642: PPUSH
19643: LD_VAR 0 4
19647: PPUSH
19648: LD_INT 7
19650: PPUSH
19651: LD_INT 12
19653: NEG
19654: PPUSH
19655: CALL_OW 330
// wait ( 0 0$30 ) ;
19659: LD_INT 1050
19661: PPUSH
19662: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19666: LD_VAR 0 3
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: LD_INT 7
19678: PPUSH
19679: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19683: LD_EXP 63
19687: PUSH
19688: LD_INT 1
19690: ARRAY
19691: PPUSH
19692: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19696: LD_ADDR_EXP 71
19700: PUSH
19701: LD_EXP 71
19705: PPUSH
19706: LD_INT 1
19708: PPUSH
19709: LD_INT 1
19711: PPUSH
19712: CALL_OW 1
19716: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19717: LD_VAR 0 2
19721: PUSH
19722: LD_EXP 70
19726: PUSH
19727: LD_INT 2
19729: ARRAY
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: EQUAL
19735: IFFALSE 19972
// begin lab := artifactsLabs [ 2 ] ;
19737: LD_ADDR_VAR 0 6
19741: PUSH
19742: LD_EXP 69
19746: PUSH
19747: LD_INT 2
19749: ARRAY
19750: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19751: LD_VAR 0 3
19755: PUSH
19756: LD_INT 81
19758: PUSH
19759: LD_INT 7
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: PUSH
19766: LD_INT 2
19768: PUSH
19769: LD_INT 32
19771: PUSH
19772: LD_INT 3
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 30
19781: PUSH
19782: LD_INT 28
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 30
19791: PUSH
19792: LD_INT 30
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: PUSH
19799: LD_INT 35
19801: PUSH
19802: LD_INT 49
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 34
19811: PUSH
19812: LD_INT 49
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: LD_INT 30
19821: PUSH
19822: LD_INT 21
19824: PUSH
19825: EMPTY
19826: LIST
19827: LIST
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: LIST
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: IN
19847: NOT
19848: IFFALSE 19852
// exit ;
19850: GO 20239
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19852: LD_VAR 0 6
19856: PPUSH
19857: CALL_OW 274
19861: PPUSH
19862: CALL 88248 0 1
19866: PUSH
19867: LD_INT 3
19869: ARRAY
19870: PUSH
19871: LD_EXP 64
19875: PUSH
19876: LD_INT 2
19878: ARRAY
19879: LESS
19880: IFFALSE 19894
// begin HintSpec ( ArtifactCost , 2 ) ;
19882: LD_STRING ArtifactCost
19884: PPUSH
19885: LD_INT 2
19887: PPUSH
19888: CALL_OW 338
// exit ;
19892: GO 20239
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19894: LD_ADDR_EXP 71
19898: PUSH
19899: LD_EXP 71
19903: PPUSH
19904: LD_INT 2
19906: PPUSH
19907: LD_INT 0
19909: PPUSH
19910: CALL_OW 1
19914: ST_TO_ADDR
// KillUnit ( x ) ;
19915: LD_VAR 0 3
19919: PPUSH
19920: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19924: LD_ADDR_EXP 16
19928: PUSH
19929: LD_EXP 16
19933: PUSH
19934: LD_INT 1
19936: PLUS
19937: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19938: LD_EXP 63
19942: PUSH
19943: LD_INT 2
19945: ARRAY
19946: PPUSH
19947: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19951: LD_ADDR_EXP 71
19955: PUSH
19956: LD_EXP 71
19960: PPUSH
19961: LD_INT 2
19963: PPUSH
19964: LD_INT 1
19966: PPUSH
19967: CALL_OW 1
19971: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19972: LD_VAR 0 2
19976: PUSH
19977: LD_EXP 70
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: EQUAL
19990: IFFALSE 20239
// begin lab := artifactsLabs [ 3 ] ;
19992: LD_ADDR_VAR 0 6
19996: PUSH
19997: LD_EXP 69
20001: PUSH
20002: LD_INT 3
20004: ARRAY
20005: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20006: LD_VAR 0 6
20010: PPUSH
20011: CALL_OW 274
20015: PPUSH
20016: CALL 88248 0 1
20020: PUSH
20021: LD_INT 3
20023: ARRAY
20024: PUSH
20025: LD_EXP 64
20029: PUSH
20030: LD_INT 3
20032: ARRAY
20033: LESS
20034: IFFALSE 20048
// begin HintSpec ( ArtifactCost , 2 ) ;
20036: LD_STRING ArtifactCost
20038: PPUSH
20039: LD_INT 2
20041: PPUSH
20042: CALL_OW 338
// exit ;
20046: GO 20239
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20048: LD_INT 37
20050: PPUSH
20051: LD_INT 1
20053: PPUSH
20054: CALL_OW 424
// time := 0 0$30 ;
20058: LD_ADDR_VAR 0 7
20062: PUSH
20063: LD_INT 1050
20065: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20066: LD_ADDR_EXP 71
20070: PUSH
20071: LD_EXP 71
20075: PPUSH
20076: LD_INT 3
20078: PPUSH
20079: LD_INT 0
20081: PPUSH
20082: CALL_OW 1
20086: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20087: LD_ADDR_OWVAR 47
20091: PUSH
20092: LD_STRING #Am15a-1
20094: PUSH
20095: LD_VAR 0 7
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20104: LD_INT 35
20106: PPUSH
20107: CALL_OW 67
// time := time - 0 0$1 ;
20111: LD_ADDR_VAR 0 7
20115: PUSH
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 35
20123: MINUS
20124: ST_TO_ADDR
// until time = 0 0$00 ;
20125: LD_VAR 0 7
20129: PUSH
20130: LD_INT 0
20132: EQUAL
20133: IFFALSE 20087
// display_strings :=  ;
20135: LD_ADDR_OWVAR 47
20139: PUSH
20140: LD_STRING 
20142: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20143: LD_INT 37
20145: PPUSH
20146: LD_INT 0
20148: PPUSH
20149: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20153: LD_ADDR_VAR 0 8
20157: PUSH
20158: LD_INT 37
20160: PPUSH
20161: LD_INT 3
20163: PUSH
20164: LD_INT 21
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: EMPTY
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PPUSH
20178: CALL_OW 70
20182: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20183: LD_VAR 0 3
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: CALL_OW 84
// for un in list do
20197: LD_ADDR_VAR 0 9
20201: PUSH
20202: LD_VAR 0 8
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20237
// TeleportUnit ( un , x , y , 12 , true ) ;
20210: LD_VAR 0 9
20214: PPUSH
20215: LD_VAR 0 3
20219: PPUSH
20220: LD_VAR 0 4
20224: PPUSH
20225: LD_INT 12
20227: PPUSH
20228: LD_INT 1
20230: PPUSH
20231: CALL_OW 483
20235: GO 20207
20237: POP
20238: POP
// end ; end ;
20239: PPOPN 9
20241: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20242: LD_INT 0
20244: PPUSH
20245: PPUSH
// begin labNum := 0 ;
20246: LD_ADDR_VAR 0 4
20250: PUSH
20251: LD_INT 0
20253: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20254: LD_ADDR_VAR 0 3
20258: PUSH
20259: DOUBLE
20260: LD_INT 1
20262: DEC
20263: ST_TO_ADDR
20264: LD_EXP 69
20268: PUSH
20269: FOR_TO
20270: IFFALSE 20304
// if artifactsLabs [ i ] = lab then
20272: LD_EXP 69
20276: PUSH
20277: LD_VAR 0 3
20281: ARRAY
20282: PUSH
20283: LD_VAR 0 1
20287: EQUAL
20288: IFFALSE 20302
// begin labNum := i ;
20290: LD_ADDR_VAR 0 4
20294: PUSH
20295: LD_VAR 0 3
20299: ST_TO_ADDR
// break ;
20300: GO 20304
// end ;
20302: GO 20269
20304: POP
20305: POP
// if not labNum then
20306: LD_VAR 0 4
20310: NOT
20311: IFFALSE 20315
// exit ;
20313: GO 20393
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20315: LD_INT 7
20317: PPUSH
20318: LD_EXP 70
20322: PUSH
20323: LD_VAR 0 4
20327: ARRAY
20328: PUSH
20329: LD_INT 3
20331: ARRAY
20332: PPUSH
20333: LD_INT 2
20335: PPUSH
20336: LD_VAR 0 1
20340: PPUSH
20341: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20345: LD_ADDR_EXP 68
20349: PUSH
20350: LD_EXP 68
20354: PPUSH
20355: LD_VAR 0 4
20359: PPUSH
20360: LD_VAR 0 2
20364: PPUSH
20365: CALL_OW 1
20369: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20370: LD_ADDR_EXP 66
20374: PUSH
20375: LD_EXP 66
20379: PPUSH
20380: LD_VAR 0 4
20384: PPUSH
20385: LD_INT 0
20387: PPUSH
20388: CALL_OW 1
20392: ST_TO_ADDR
// end ;
20393: PPOPN 4
20395: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// begin labNum := 0 ;
20400: LD_ADDR_VAR 0 3
20404: PUSH
20405: LD_INT 0
20407: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20408: LD_ADDR_VAR 0 2
20412: PUSH
20413: DOUBLE
20414: LD_INT 1
20416: DEC
20417: ST_TO_ADDR
20418: LD_EXP 69
20422: PUSH
20423: FOR_TO
20424: IFFALSE 20458
// if artifactsLabs [ i ] = lab then
20426: LD_EXP 69
20430: PUSH
20431: LD_VAR 0 2
20435: ARRAY
20436: PUSH
20437: LD_VAR 0 1
20441: EQUAL
20442: IFFALSE 20456
// begin labNum := i ;
20444: LD_ADDR_VAR 0 3
20448: PUSH
20449: LD_VAR 0 2
20453: ST_TO_ADDR
// break ;
20454: GO 20458
// end ;
20456: GO 20423
20458: POP
20459: POP
// if not labNum then
20460: LD_VAR 0 3
20464: NOT
20465: IFFALSE 20469
// exit ;
20467: GO 20631
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20469: LD_INT 7
20471: PPUSH
20472: LD_EXP 70
20476: PUSH
20477: LD_VAR 0 3
20481: ARRAY
20482: PUSH
20483: LD_INT 3
20485: ARRAY
20486: PPUSH
20487: LD_INT 0
20489: PPUSH
20490: LD_VAR 0 1
20494: PPUSH
20495: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20499: LD_ADDR_EXP 65
20503: PUSH
20504: LD_EXP 65
20508: PPUSH
20509: LD_VAR 0 3
20513: PPUSH
20514: LD_INT 1
20516: PPUSH
20517: CALL_OW 1
20521: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20522: LD_ADDR_EXP 71
20526: PUSH
20527: LD_EXP 71
20531: PPUSH
20532: LD_VAR 0 3
20536: PPUSH
20537: LD_INT 1
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20545: LD_ADDR_EXP 66
20549: PUSH
20550: LD_EXP 66
20554: PPUSH
20555: LD_VAR 0 3
20559: PPUSH
20560: LD_INT 0
20562: PPUSH
20563: CALL_OW 1
20567: ST_TO_ADDR
// case labNum of 1 :
20568: LD_VAR 0 3
20572: PUSH
20573: LD_INT 1
20575: DOUBLE
20576: EQUAL
20577: IFTRUE 20581
20579: GO 20592
20581: POP
// artifactIResearched := true ; 2 :
20582: LD_ADDR_EXP 12
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
20590: GO 20631
20592: LD_INT 2
20594: DOUBLE
20595: EQUAL
20596: IFTRUE 20600
20598: GO 20611
20600: POP
// artifactIIResearched := true ; 3 :
20601: LD_ADDR_EXP 13
20605: PUSH
20606: LD_INT 1
20608: ST_TO_ADDR
20609: GO 20631
20611: LD_INT 3
20613: DOUBLE
20614: EQUAL
20615: IFTRUE 20619
20617: GO 20630
20619: POP
// artifactIIIResearched := true ; end ;
20620: LD_ADDR_EXP 14
20624: PUSH
20625: LD_INT 1
20627: ST_TO_ADDR
20628: GO 20631
20630: POP
// end ; end_of_file
20631: PPOPN 3
20633: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
20634: LD_INT 0
20636: PPUSH
// ar_miner := 81 ;
20637: LD_ADDR_EXP 79
20641: PUSH
20642: LD_INT 81
20644: ST_TO_ADDR
// ar_crane := 88 ;
20645: LD_ADDR_EXP 78
20649: PUSH
20650: LD_INT 88
20652: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20653: LD_ADDR_EXP 73
20657: PUSH
20658: LD_INT 89
20660: ST_TO_ADDR
// us_hack := 99 ;
20661: LD_ADDR_EXP 74
20665: PUSH
20666: LD_INT 99
20668: ST_TO_ADDR
// us_artillery := 97 ;
20669: LD_ADDR_EXP 75
20673: PUSH
20674: LD_INT 97
20676: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20677: LD_ADDR_EXP 76
20681: PUSH
20682: LD_INT 91
20684: ST_TO_ADDR
// ar_mortar := 92 ;
20685: LD_ADDR_EXP 77
20689: PUSH
20690: LD_INT 92
20692: ST_TO_ADDR
// ru_radar := 98 ;
20693: LD_ADDR_EXP 72
20697: PUSH
20698: LD_INT 98
20700: ST_TO_ADDR
// tech_Artillery := 80 ;
20701: LD_ADDR_EXP 80
20705: PUSH
20706: LD_INT 80
20708: ST_TO_ADDR
// tech_RadMat := 81 ;
20709: LD_ADDR_EXP 81
20713: PUSH
20714: LD_INT 81
20716: ST_TO_ADDR
// tech_BasicTools := 82 ;
20717: LD_ADDR_EXP 82
20721: PUSH
20722: LD_INT 82
20724: ST_TO_ADDR
// tech_Cargo := 83 ;
20725: LD_ADDR_EXP 83
20729: PUSH
20730: LD_INT 83
20732: ST_TO_ADDR
// tech_Track := 84 ;
20733: LD_ADDR_EXP 84
20737: PUSH
20738: LD_INT 84
20740: ST_TO_ADDR
// tech_Crane := 85 ;
20741: LD_ADDR_EXP 85
20745: PUSH
20746: LD_INT 85
20748: ST_TO_ADDR
// tech_Bulldozer := 86 ;
20749: LD_ADDR_EXP 86
20753: PUSH
20754: LD_INT 86
20756: ST_TO_ADDR
// tech_Hovercraft := 87 ;
20757: LD_ADDR_EXP 87
20761: PUSH
20762: LD_INT 87
20764: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
20765: LD_ADDR_EXP 88
20769: PUSH
20770: LD_INT 88
20772: ST_TO_ADDR
// class_mastodont := 31 ;
20773: LD_ADDR_EXP 89
20777: PUSH
20778: LD_INT 31
20780: ST_TO_ADDR
// class_horse := 21 ;
20781: LD_ADDR_EXP 90
20785: PUSH
20786: LD_INT 21
20788: ST_TO_ADDR
// end ;
20789: LD_VAR 0 1
20793: RET
// every 1 do
20794: GO 20796
20796: DISABLE
// InitGlobalVariables ; end_of_file
20797: CALL 20634 0 0
20801: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
20802: LD_INT 0
20804: PPUSH
20805: PPUSH
// skirmish := false ;
20806: LD_ADDR_EXP 91
20810: PUSH
20811: LD_INT 0
20813: ST_TO_ADDR
// debug_mc := false ;
20814: LD_ADDR_EXP 92
20818: PUSH
20819: LD_INT 0
20821: ST_TO_ADDR
// mc_bases := [ ] ;
20822: LD_ADDR_EXP 93
20826: PUSH
20827: EMPTY
20828: ST_TO_ADDR
// mc_sides := [ ] ;
20829: LD_ADDR_EXP 119
20833: PUSH
20834: EMPTY
20835: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20836: LD_ADDR_EXP 94
20840: PUSH
20841: EMPTY
20842: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20843: LD_ADDR_EXP 95
20847: PUSH
20848: EMPTY
20849: ST_TO_ADDR
// mc_need_heal := [ ] ;
20850: LD_ADDR_EXP 96
20854: PUSH
20855: EMPTY
20856: ST_TO_ADDR
// mc_healers := [ ] ;
20857: LD_ADDR_EXP 97
20861: PUSH
20862: EMPTY
20863: ST_TO_ADDR
// mc_build_list := [ ] ;
20864: LD_ADDR_EXP 98
20868: PUSH
20869: EMPTY
20870: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20871: LD_ADDR_EXP 125
20875: PUSH
20876: EMPTY
20877: ST_TO_ADDR
// mc_builders := [ ] ;
20878: LD_ADDR_EXP 99
20882: PUSH
20883: EMPTY
20884: ST_TO_ADDR
// mc_construct_list := [ ] ;
20885: LD_ADDR_EXP 100
20889: PUSH
20890: EMPTY
20891: ST_TO_ADDR
// mc_turret_list := [ ] ;
20892: LD_ADDR_EXP 101
20896: PUSH
20897: EMPTY
20898: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20899: LD_ADDR_EXP 102
20903: PUSH
20904: EMPTY
20905: ST_TO_ADDR
// mc_miners := [ ] ;
20906: LD_ADDR_EXP 107
20910: PUSH
20911: EMPTY
20912: ST_TO_ADDR
// mc_mines := [ ] ;
20913: LD_ADDR_EXP 106
20917: PUSH
20918: EMPTY
20919: ST_TO_ADDR
// mc_minefields := [ ] ;
20920: LD_ADDR_EXP 108
20924: PUSH
20925: EMPTY
20926: ST_TO_ADDR
// mc_crates := [ ] ;
20927: LD_ADDR_EXP 109
20931: PUSH
20932: EMPTY
20933: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20934: LD_ADDR_EXP 110
20938: PUSH
20939: EMPTY
20940: ST_TO_ADDR
// mc_crates_area := [ ] ;
20941: LD_ADDR_EXP 111
20945: PUSH
20946: EMPTY
20947: ST_TO_ADDR
// mc_vehicles := [ ] ;
20948: LD_ADDR_EXP 112
20952: PUSH
20953: EMPTY
20954: ST_TO_ADDR
// mc_attack := [ ] ;
20955: LD_ADDR_EXP 113
20959: PUSH
20960: EMPTY
20961: ST_TO_ADDR
// mc_produce := [ ] ;
20962: LD_ADDR_EXP 114
20966: PUSH
20967: EMPTY
20968: ST_TO_ADDR
// mc_defender := [ ] ;
20969: LD_ADDR_EXP 115
20973: PUSH
20974: EMPTY
20975: ST_TO_ADDR
// mc_parking := [ ] ;
20976: LD_ADDR_EXP 117
20980: PUSH
20981: EMPTY
20982: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20983: LD_ADDR_EXP 103
20987: PUSH
20988: EMPTY
20989: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20990: LD_ADDR_EXP 105
20994: PUSH
20995: EMPTY
20996: ST_TO_ADDR
// mc_scan := [ ] ;
20997: LD_ADDR_EXP 116
21001: PUSH
21002: EMPTY
21003: ST_TO_ADDR
// mc_scan_area := [ ] ;
21004: LD_ADDR_EXP 118
21008: PUSH
21009: EMPTY
21010: ST_TO_ADDR
// mc_tech := [ ] ;
21011: LD_ADDR_EXP 120
21015: PUSH
21016: EMPTY
21017: ST_TO_ADDR
// mc_class := [ ] ;
21018: LD_ADDR_EXP 134
21022: PUSH
21023: EMPTY
21024: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21025: LD_ADDR_EXP 135
21029: PUSH
21030: EMPTY
21031: ST_TO_ADDR
// mc_is_defending := [ ] ;
21032: LD_ADDR_EXP 136
21036: PUSH
21037: EMPTY
21038: ST_TO_ADDR
// end ;
21039: LD_VAR 0 1
21043: RET
// export function MC_Kill ( base ) ; begin
21044: LD_INT 0
21046: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21047: LD_ADDR_EXP 93
21051: PUSH
21052: LD_EXP 93
21056: PPUSH
21057: LD_VAR 0 1
21061: PPUSH
21062: EMPTY
21063: PPUSH
21064: CALL_OW 1
21068: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21069: LD_ADDR_EXP 94
21073: PUSH
21074: LD_EXP 94
21078: PPUSH
21079: LD_VAR 0 1
21083: PPUSH
21084: EMPTY
21085: PPUSH
21086: CALL_OW 1
21090: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21091: LD_ADDR_EXP 95
21095: PUSH
21096: LD_EXP 95
21100: PPUSH
21101: LD_VAR 0 1
21105: PPUSH
21106: EMPTY
21107: PPUSH
21108: CALL_OW 1
21112: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21113: LD_ADDR_EXP 96
21117: PUSH
21118: LD_EXP 96
21122: PPUSH
21123: LD_VAR 0 1
21127: PPUSH
21128: EMPTY
21129: PPUSH
21130: CALL_OW 1
21134: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21135: LD_ADDR_EXP 97
21139: PUSH
21140: LD_EXP 97
21144: PPUSH
21145: LD_VAR 0 1
21149: PPUSH
21150: EMPTY
21151: PPUSH
21152: CALL_OW 1
21156: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21157: LD_ADDR_EXP 98
21161: PUSH
21162: LD_EXP 98
21166: PPUSH
21167: LD_VAR 0 1
21171: PPUSH
21172: EMPTY
21173: PPUSH
21174: CALL_OW 1
21178: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21179: LD_ADDR_EXP 99
21183: PUSH
21184: LD_EXP 99
21188: PPUSH
21189: LD_VAR 0 1
21193: PPUSH
21194: EMPTY
21195: PPUSH
21196: CALL_OW 1
21200: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21201: LD_ADDR_EXP 100
21205: PUSH
21206: LD_EXP 100
21210: PPUSH
21211: LD_VAR 0 1
21215: PPUSH
21216: EMPTY
21217: PPUSH
21218: CALL_OW 1
21222: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21223: LD_ADDR_EXP 101
21227: PUSH
21228: LD_EXP 101
21232: PPUSH
21233: LD_VAR 0 1
21237: PPUSH
21238: EMPTY
21239: PPUSH
21240: CALL_OW 1
21244: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21245: LD_ADDR_EXP 102
21249: PUSH
21250: LD_EXP 102
21254: PPUSH
21255: LD_VAR 0 1
21259: PPUSH
21260: EMPTY
21261: PPUSH
21262: CALL_OW 1
21266: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21267: LD_ADDR_EXP 103
21271: PUSH
21272: LD_EXP 103
21276: PPUSH
21277: LD_VAR 0 1
21281: PPUSH
21282: EMPTY
21283: PPUSH
21284: CALL_OW 1
21288: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21289: LD_ADDR_EXP 104
21293: PUSH
21294: LD_EXP 104
21298: PPUSH
21299: LD_VAR 0 1
21303: PPUSH
21304: LD_INT 0
21306: PPUSH
21307: CALL_OW 1
21311: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21312: LD_ADDR_EXP 105
21316: PUSH
21317: LD_EXP 105
21321: PPUSH
21322: LD_VAR 0 1
21326: PPUSH
21327: EMPTY
21328: PPUSH
21329: CALL_OW 1
21333: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21334: LD_ADDR_EXP 106
21338: PUSH
21339: LD_EXP 106
21343: PPUSH
21344: LD_VAR 0 1
21348: PPUSH
21349: EMPTY
21350: PPUSH
21351: CALL_OW 1
21355: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21356: LD_ADDR_EXP 107
21360: PUSH
21361: LD_EXP 107
21365: PPUSH
21366: LD_VAR 0 1
21370: PPUSH
21371: EMPTY
21372: PPUSH
21373: CALL_OW 1
21377: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21378: LD_ADDR_EXP 108
21382: PUSH
21383: LD_EXP 108
21387: PPUSH
21388: LD_VAR 0 1
21392: PPUSH
21393: EMPTY
21394: PPUSH
21395: CALL_OW 1
21399: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21400: LD_ADDR_EXP 109
21404: PUSH
21405: LD_EXP 109
21409: PPUSH
21410: LD_VAR 0 1
21414: PPUSH
21415: EMPTY
21416: PPUSH
21417: CALL_OW 1
21421: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21422: LD_ADDR_EXP 110
21426: PUSH
21427: LD_EXP 110
21431: PPUSH
21432: LD_VAR 0 1
21436: PPUSH
21437: EMPTY
21438: PPUSH
21439: CALL_OW 1
21443: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21444: LD_ADDR_EXP 111
21448: PUSH
21449: LD_EXP 111
21453: PPUSH
21454: LD_VAR 0 1
21458: PPUSH
21459: EMPTY
21460: PPUSH
21461: CALL_OW 1
21465: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21466: LD_ADDR_EXP 112
21470: PUSH
21471: LD_EXP 112
21475: PPUSH
21476: LD_VAR 0 1
21480: PPUSH
21481: EMPTY
21482: PPUSH
21483: CALL_OW 1
21487: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21488: LD_ADDR_EXP 113
21492: PUSH
21493: LD_EXP 113
21497: PPUSH
21498: LD_VAR 0 1
21502: PPUSH
21503: EMPTY
21504: PPUSH
21505: CALL_OW 1
21509: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21510: LD_ADDR_EXP 114
21514: PUSH
21515: LD_EXP 114
21519: PPUSH
21520: LD_VAR 0 1
21524: PPUSH
21525: EMPTY
21526: PPUSH
21527: CALL_OW 1
21531: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21532: LD_ADDR_EXP 115
21536: PUSH
21537: LD_EXP 115
21541: PPUSH
21542: LD_VAR 0 1
21546: PPUSH
21547: EMPTY
21548: PPUSH
21549: CALL_OW 1
21553: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21554: LD_ADDR_EXP 116
21558: PUSH
21559: LD_EXP 116
21563: PPUSH
21564: LD_VAR 0 1
21568: PPUSH
21569: EMPTY
21570: PPUSH
21571: CALL_OW 1
21575: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21576: LD_ADDR_EXP 117
21580: PUSH
21581: LD_EXP 117
21585: PPUSH
21586: LD_VAR 0 1
21590: PPUSH
21591: EMPTY
21592: PPUSH
21593: CALL_OW 1
21597: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21598: LD_ADDR_EXP 118
21602: PUSH
21603: LD_EXP 118
21607: PPUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: EMPTY
21614: PPUSH
21615: CALL_OW 1
21619: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21620: LD_ADDR_EXP 120
21624: PUSH
21625: LD_EXP 120
21629: PPUSH
21630: LD_VAR 0 1
21634: PPUSH
21635: EMPTY
21636: PPUSH
21637: CALL_OW 1
21641: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21642: LD_ADDR_EXP 122
21646: PUSH
21647: LD_EXP 122
21651: PPUSH
21652: LD_VAR 0 1
21656: PPUSH
21657: EMPTY
21658: PPUSH
21659: CALL_OW 1
21663: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21664: LD_ADDR_EXP 123
21668: PUSH
21669: LD_EXP 123
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: EMPTY
21680: PPUSH
21681: CALL_OW 1
21685: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21686: LD_ADDR_EXP 124
21690: PUSH
21691: LD_EXP 124
21695: PPUSH
21696: LD_VAR 0 1
21700: PPUSH
21701: EMPTY
21702: PPUSH
21703: CALL_OW 1
21707: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21708: LD_ADDR_EXP 125
21712: PUSH
21713: LD_EXP 125
21717: PPUSH
21718: LD_VAR 0 1
21722: PPUSH
21723: EMPTY
21724: PPUSH
21725: CALL_OW 1
21729: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21730: LD_ADDR_EXP 126
21734: PUSH
21735: LD_EXP 126
21739: PPUSH
21740: LD_VAR 0 1
21744: PPUSH
21745: EMPTY
21746: PPUSH
21747: CALL_OW 1
21751: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21752: LD_ADDR_EXP 127
21756: PUSH
21757: LD_EXP 127
21761: PPUSH
21762: LD_VAR 0 1
21766: PPUSH
21767: EMPTY
21768: PPUSH
21769: CALL_OW 1
21773: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21774: LD_ADDR_EXP 128
21778: PUSH
21779: LD_EXP 128
21783: PPUSH
21784: LD_VAR 0 1
21788: PPUSH
21789: EMPTY
21790: PPUSH
21791: CALL_OW 1
21795: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21796: LD_ADDR_EXP 129
21800: PUSH
21801: LD_EXP 129
21805: PPUSH
21806: LD_VAR 0 1
21810: PPUSH
21811: EMPTY
21812: PPUSH
21813: CALL_OW 1
21817: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21818: LD_ADDR_EXP 130
21822: PUSH
21823: LD_EXP 130
21827: PPUSH
21828: LD_VAR 0 1
21832: PPUSH
21833: EMPTY
21834: PPUSH
21835: CALL_OW 1
21839: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21840: LD_ADDR_EXP 131
21844: PUSH
21845: LD_EXP 131
21849: PPUSH
21850: LD_VAR 0 1
21854: PPUSH
21855: EMPTY
21856: PPUSH
21857: CALL_OW 1
21861: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21862: LD_ADDR_EXP 132
21866: PUSH
21867: LD_EXP 132
21871: PPUSH
21872: LD_VAR 0 1
21876: PPUSH
21877: EMPTY
21878: PPUSH
21879: CALL_OW 1
21883: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21884: LD_ADDR_EXP 133
21888: PUSH
21889: LD_EXP 133
21893: PPUSH
21894: LD_VAR 0 1
21898: PPUSH
21899: EMPTY
21900: PPUSH
21901: CALL_OW 1
21905: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21906: LD_ADDR_EXP 134
21910: PUSH
21911: LD_EXP 134
21915: PPUSH
21916: LD_VAR 0 1
21920: PPUSH
21921: EMPTY
21922: PPUSH
21923: CALL_OW 1
21927: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21928: LD_ADDR_EXP 135
21932: PUSH
21933: LD_EXP 135
21937: PPUSH
21938: LD_VAR 0 1
21942: PPUSH
21943: LD_INT 0
21945: PPUSH
21946: CALL_OW 1
21950: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
21951: LD_ADDR_EXP 136
21955: PUSH
21956: LD_EXP 136
21960: PPUSH
21961: LD_VAR 0 1
21965: PPUSH
21966: LD_INT 0
21968: PPUSH
21969: CALL_OW 1
21973: ST_TO_ADDR
// end ;
21974: LD_VAR 0 2
21978: RET
// export function MC_Add ( side , units ) ; var base ; begin
21979: LD_INT 0
21981: PPUSH
21982: PPUSH
// base := mc_bases + 1 ;
21983: LD_ADDR_VAR 0 4
21987: PUSH
21988: LD_EXP 93
21992: PUSH
21993: LD_INT 1
21995: PLUS
21996: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21997: LD_ADDR_EXP 119
22001: PUSH
22002: LD_EXP 119
22006: PPUSH
22007: LD_VAR 0 4
22011: PPUSH
22012: LD_VAR 0 1
22016: PPUSH
22017: CALL_OW 1
22021: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22022: LD_ADDR_EXP 93
22026: PUSH
22027: LD_EXP 93
22031: PPUSH
22032: LD_VAR 0 4
22036: PPUSH
22037: LD_VAR 0 2
22041: PPUSH
22042: CALL_OW 1
22046: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22047: LD_ADDR_EXP 94
22051: PUSH
22052: LD_EXP 94
22056: PPUSH
22057: LD_VAR 0 4
22061: PPUSH
22062: EMPTY
22063: PPUSH
22064: CALL_OW 1
22068: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22069: LD_ADDR_EXP 95
22073: PUSH
22074: LD_EXP 95
22078: PPUSH
22079: LD_VAR 0 4
22083: PPUSH
22084: EMPTY
22085: PPUSH
22086: CALL_OW 1
22090: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22091: LD_ADDR_EXP 96
22095: PUSH
22096: LD_EXP 96
22100: PPUSH
22101: LD_VAR 0 4
22105: PPUSH
22106: EMPTY
22107: PPUSH
22108: CALL_OW 1
22112: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22113: LD_ADDR_EXP 97
22117: PUSH
22118: LD_EXP 97
22122: PPUSH
22123: LD_VAR 0 4
22127: PPUSH
22128: EMPTY
22129: PPUSH
22130: CALL_OW 1
22134: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22135: LD_ADDR_EXP 98
22139: PUSH
22140: LD_EXP 98
22144: PPUSH
22145: LD_VAR 0 4
22149: PPUSH
22150: EMPTY
22151: PPUSH
22152: CALL_OW 1
22156: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22157: LD_ADDR_EXP 99
22161: PUSH
22162: LD_EXP 99
22166: PPUSH
22167: LD_VAR 0 4
22171: PPUSH
22172: EMPTY
22173: PPUSH
22174: CALL_OW 1
22178: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22179: LD_ADDR_EXP 100
22183: PUSH
22184: LD_EXP 100
22188: PPUSH
22189: LD_VAR 0 4
22193: PPUSH
22194: EMPTY
22195: PPUSH
22196: CALL_OW 1
22200: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22201: LD_ADDR_EXP 101
22205: PUSH
22206: LD_EXP 101
22210: PPUSH
22211: LD_VAR 0 4
22215: PPUSH
22216: EMPTY
22217: PPUSH
22218: CALL_OW 1
22222: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22223: LD_ADDR_EXP 102
22227: PUSH
22228: LD_EXP 102
22232: PPUSH
22233: LD_VAR 0 4
22237: PPUSH
22238: EMPTY
22239: PPUSH
22240: CALL_OW 1
22244: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22245: LD_ADDR_EXP 103
22249: PUSH
22250: LD_EXP 103
22254: PPUSH
22255: LD_VAR 0 4
22259: PPUSH
22260: EMPTY
22261: PPUSH
22262: CALL_OW 1
22266: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22267: LD_ADDR_EXP 104
22271: PUSH
22272: LD_EXP 104
22276: PPUSH
22277: LD_VAR 0 4
22281: PPUSH
22282: LD_INT 0
22284: PPUSH
22285: CALL_OW 1
22289: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22290: LD_ADDR_EXP 105
22294: PUSH
22295: LD_EXP 105
22299: PPUSH
22300: LD_VAR 0 4
22304: PPUSH
22305: EMPTY
22306: PPUSH
22307: CALL_OW 1
22311: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22312: LD_ADDR_EXP 106
22316: PUSH
22317: LD_EXP 106
22321: PPUSH
22322: LD_VAR 0 4
22326: PPUSH
22327: EMPTY
22328: PPUSH
22329: CALL_OW 1
22333: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22334: LD_ADDR_EXP 107
22338: PUSH
22339: LD_EXP 107
22343: PPUSH
22344: LD_VAR 0 4
22348: PPUSH
22349: EMPTY
22350: PPUSH
22351: CALL_OW 1
22355: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22356: LD_ADDR_EXP 108
22360: PUSH
22361: LD_EXP 108
22365: PPUSH
22366: LD_VAR 0 4
22370: PPUSH
22371: EMPTY
22372: PPUSH
22373: CALL_OW 1
22377: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22378: LD_ADDR_EXP 109
22382: PUSH
22383: LD_EXP 109
22387: PPUSH
22388: LD_VAR 0 4
22392: PPUSH
22393: EMPTY
22394: PPUSH
22395: CALL_OW 1
22399: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22400: LD_ADDR_EXP 110
22404: PUSH
22405: LD_EXP 110
22409: PPUSH
22410: LD_VAR 0 4
22414: PPUSH
22415: EMPTY
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22422: LD_ADDR_EXP 111
22426: PUSH
22427: LD_EXP 111
22431: PPUSH
22432: LD_VAR 0 4
22436: PPUSH
22437: EMPTY
22438: PPUSH
22439: CALL_OW 1
22443: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22444: LD_ADDR_EXP 112
22448: PUSH
22449: LD_EXP 112
22453: PPUSH
22454: LD_VAR 0 4
22458: PPUSH
22459: EMPTY
22460: PPUSH
22461: CALL_OW 1
22465: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22466: LD_ADDR_EXP 113
22470: PUSH
22471: LD_EXP 113
22475: PPUSH
22476: LD_VAR 0 4
22480: PPUSH
22481: EMPTY
22482: PPUSH
22483: CALL_OW 1
22487: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22488: LD_ADDR_EXP 114
22492: PUSH
22493: LD_EXP 114
22497: PPUSH
22498: LD_VAR 0 4
22502: PPUSH
22503: EMPTY
22504: PPUSH
22505: CALL_OW 1
22509: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22510: LD_ADDR_EXP 115
22514: PUSH
22515: LD_EXP 115
22519: PPUSH
22520: LD_VAR 0 4
22524: PPUSH
22525: EMPTY
22526: PPUSH
22527: CALL_OW 1
22531: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22532: LD_ADDR_EXP 116
22536: PUSH
22537: LD_EXP 116
22541: PPUSH
22542: LD_VAR 0 4
22546: PPUSH
22547: EMPTY
22548: PPUSH
22549: CALL_OW 1
22553: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22554: LD_ADDR_EXP 117
22558: PUSH
22559: LD_EXP 117
22563: PPUSH
22564: LD_VAR 0 4
22568: PPUSH
22569: EMPTY
22570: PPUSH
22571: CALL_OW 1
22575: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22576: LD_ADDR_EXP 118
22580: PUSH
22581: LD_EXP 118
22585: PPUSH
22586: LD_VAR 0 4
22590: PPUSH
22591: EMPTY
22592: PPUSH
22593: CALL_OW 1
22597: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22598: LD_ADDR_EXP 120
22602: PUSH
22603: LD_EXP 120
22607: PPUSH
22608: LD_VAR 0 4
22612: PPUSH
22613: EMPTY
22614: PPUSH
22615: CALL_OW 1
22619: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22620: LD_ADDR_EXP 122
22624: PUSH
22625: LD_EXP 122
22629: PPUSH
22630: LD_VAR 0 4
22634: PPUSH
22635: EMPTY
22636: PPUSH
22637: CALL_OW 1
22641: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22642: LD_ADDR_EXP 123
22646: PUSH
22647: LD_EXP 123
22651: PPUSH
22652: LD_VAR 0 4
22656: PPUSH
22657: EMPTY
22658: PPUSH
22659: CALL_OW 1
22663: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22664: LD_ADDR_EXP 124
22668: PUSH
22669: LD_EXP 124
22673: PPUSH
22674: LD_VAR 0 4
22678: PPUSH
22679: EMPTY
22680: PPUSH
22681: CALL_OW 1
22685: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22686: LD_ADDR_EXP 125
22690: PUSH
22691: LD_EXP 125
22695: PPUSH
22696: LD_VAR 0 4
22700: PPUSH
22701: EMPTY
22702: PPUSH
22703: CALL_OW 1
22707: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22708: LD_ADDR_EXP 126
22712: PUSH
22713: LD_EXP 126
22717: PPUSH
22718: LD_VAR 0 4
22722: PPUSH
22723: EMPTY
22724: PPUSH
22725: CALL_OW 1
22729: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22730: LD_ADDR_EXP 127
22734: PUSH
22735: LD_EXP 127
22739: PPUSH
22740: LD_VAR 0 4
22744: PPUSH
22745: EMPTY
22746: PPUSH
22747: CALL_OW 1
22751: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22752: LD_ADDR_EXP 128
22756: PUSH
22757: LD_EXP 128
22761: PPUSH
22762: LD_VAR 0 4
22766: PPUSH
22767: EMPTY
22768: PPUSH
22769: CALL_OW 1
22773: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22774: LD_ADDR_EXP 129
22778: PUSH
22779: LD_EXP 129
22783: PPUSH
22784: LD_VAR 0 4
22788: PPUSH
22789: EMPTY
22790: PPUSH
22791: CALL_OW 1
22795: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22796: LD_ADDR_EXP 130
22800: PUSH
22801: LD_EXP 130
22805: PPUSH
22806: LD_VAR 0 4
22810: PPUSH
22811: EMPTY
22812: PPUSH
22813: CALL_OW 1
22817: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22818: LD_ADDR_EXP 131
22822: PUSH
22823: LD_EXP 131
22827: PPUSH
22828: LD_VAR 0 4
22832: PPUSH
22833: EMPTY
22834: PPUSH
22835: CALL_OW 1
22839: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22840: LD_ADDR_EXP 132
22844: PUSH
22845: LD_EXP 132
22849: PPUSH
22850: LD_VAR 0 4
22854: PPUSH
22855: EMPTY
22856: PPUSH
22857: CALL_OW 1
22861: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22862: LD_ADDR_EXP 133
22866: PUSH
22867: LD_EXP 133
22871: PPUSH
22872: LD_VAR 0 4
22876: PPUSH
22877: EMPTY
22878: PPUSH
22879: CALL_OW 1
22883: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22884: LD_ADDR_EXP 134
22888: PUSH
22889: LD_EXP 134
22893: PPUSH
22894: LD_VAR 0 4
22898: PPUSH
22899: EMPTY
22900: PPUSH
22901: CALL_OW 1
22905: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22906: LD_ADDR_EXP 135
22910: PUSH
22911: LD_EXP 135
22915: PPUSH
22916: LD_VAR 0 4
22920: PPUSH
22921: LD_INT 0
22923: PPUSH
22924: CALL_OW 1
22928: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22929: LD_ADDR_EXP 136
22933: PUSH
22934: LD_EXP 136
22938: PPUSH
22939: LD_VAR 0 4
22943: PPUSH
22944: LD_INT 0
22946: PPUSH
22947: CALL_OW 1
22951: ST_TO_ADDR
// result := base ;
22952: LD_ADDR_VAR 0 3
22956: PUSH
22957: LD_VAR 0 4
22961: ST_TO_ADDR
// end ;
22962: LD_VAR 0 3
22966: RET
// export function MC_Start ( ) ; var i ; begin
22967: LD_INT 0
22969: PPUSH
22970: PPUSH
// for i = 1 to mc_bases do
22971: LD_ADDR_VAR 0 2
22975: PUSH
22976: DOUBLE
22977: LD_INT 1
22979: DEC
22980: ST_TO_ADDR
22981: LD_EXP 93
22985: PUSH
22986: FOR_TO
22987: IFFALSE 24087
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22989: LD_ADDR_EXP 93
22993: PUSH
22994: LD_EXP 93
22998: PPUSH
22999: LD_VAR 0 2
23003: PPUSH
23004: LD_EXP 93
23008: PUSH
23009: LD_VAR 0 2
23013: ARRAY
23014: PUSH
23015: LD_INT 0
23017: DIFF
23018: PPUSH
23019: CALL_OW 1
23023: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23024: LD_ADDR_EXP 94
23028: PUSH
23029: LD_EXP 94
23033: PPUSH
23034: LD_VAR 0 2
23038: PPUSH
23039: EMPTY
23040: PPUSH
23041: CALL_OW 1
23045: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23046: LD_ADDR_EXP 95
23050: PUSH
23051: LD_EXP 95
23055: PPUSH
23056: LD_VAR 0 2
23060: PPUSH
23061: EMPTY
23062: PPUSH
23063: CALL_OW 1
23067: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23068: LD_ADDR_EXP 96
23072: PUSH
23073: LD_EXP 96
23077: PPUSH
23078: LD_VAR 0 2
23082: PPUSH
23083: EMPTY
23084: PPUSH
23085: CALL_OW 1
23089: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23090: LD_ADDR_EXP 97
23094: PUSH
23095: LD_EXP 97
23099: PPUSH
23100: LD_VAR 0 2
23104: PPUSH
23105: EMPTY
23106: PUSH
23107: EMPTY
23108: PUSH
23109: EMPTY
23110: LIST
23111: LIST
23112: PPUSH
23113: CALL_OW 1
23117: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23118: LD_ADDR_EXP 98
23122: PUSH
23123: LD_EXP 98
23127: PPUSH
23128: LD_VAR 0 2
23132: PPUSH
23133: EMPTY
23134: PPUSH
23135: CALL_OW 1
23139: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23140: LD_ADDR_EXP 125
23144: PUSH
23145: LD_EXP 125
23149: PPUSH
23150: LD_VAR 0 2
23154: PPUSH
23155: EMPTY
23156: PPUSH
23157: CALL_OW 1
23161: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23162: LD_ADDR_EXP 99
23166: PUSH
23167: LD_EXP 99
23171: PPUSH
23172: LD_VAR 0 2
23176: PPUSH
23177: EMPTY
23178: PPUSH
23179: CALL_OW 1
23183: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23184: LD_ADDR_EXP 100
23188: PUSH
23189: LD_EXP 100
23193: PPUSH
23194: LD_VAR 0 2
23198: PPUSH
23199: EMPTY
23200: PPUSH
23201: CALL_OW 1
23205: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23206: LD_ADDR_EXP 101
23210: PUSH
23211: LD_EXP 101
23215: PPUSH
23216: LD_VAR 0 2
23220: PPUSH
23221: LD_EXP 93
23225: PUSH
23226: LD_VAR 0 2
23230: ARRAY
23231: PPUSH
23232: LD_INT 2
23234: PUSH
23235: LD_INT 30
23237: PUSH
23238: LD_INT 32
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: PUSH
23245: LD_INT 30
23247: PUSH
23248: LD_INT 33
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: PUSH
23255: EMPTY
23256: LIST
23257: LIST
23258: LIST
23259: PPUSH
23260: CALL_OW 72
23264: PPUSH
23265: CALL_OW 1
23269: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23270: LD_ADDR_EXP 102
23274: PUSH
23275: LD_EXP 102
23279: PPUSH
23280: LD_VAR 0 2
23284: PPUSH
23285: LD_EXP 93
23289: PUSH
23290: LD_VAR 0 2
23294: ARRAY
23295: PPUSH
23296: LD_INT 2
23298: PUSH
23299: LD_INT 30
23301: PUSH
23302: LD_INT 32
23304: PUSH
23305: EMPTY
23306: LIST
23307: LIST
23308: PUSH
23309: LD_INT 30
23311: PUSH
23312: LD_INT 31
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: LIST
23323: PUSH
23324: LD_INT 58
23326: PUSH
23327: EMPTY
23328: LIST
23329: PUSH
23330: EMPTY
23331: LIST
23332: LIST
23333: PPUSH
23334: CALL_OW 72
23338: PPUSH
23339: CALL_OW 1
23343: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23344: LD_ADDR_EXP 103
23348: PUSH
23349: LD_EXP 103
23353: PPUSH
23354: LD_VAR 0 2
23358: PPUSH
23359: EMPTY
23360: PPUSH
23361: CALL_OW 1
23365: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23366: LD_ADDR_EXP 107
23370: PUSH
23371: LD_EXP 107
23375: PPUSH
23376: LD_VAR 0 2
23380: PPUSH
23381: EMPTY
23382: PPUSH
23383: CALL_OW 1
23387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23388: LD_ADDR_EXP 106
23392: PUSH
23393: LD_EXP 106
23397: PPUSH
23398: LD_VAR 0 2
23402: PPUSH
23403: EMPTY
23404: PPUSH
23405: CALL_OW 1
23409: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23410: LD_ADDR_EXP 108
23414: PUSH
23415: LD_EXP 108
23419: PPUSH
23420: LD_VAR 0 2
23424: PPUSH
23425: EMPTY
23426: PPUSH
23427: CALL_OW 1
23431: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23432: LD_ADDR_EXP 109
23436: PUSH
23437: LD_EXP 109
23441: PPUSH
23442: LD_VAR 0 2
23446: PPUSH
23447: EMPTY
23448: PPUSH
23449: CALL_OW 1
23453: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23454: LD_ADDR_EXP 110
23458: PUSH
23459: LD_EXP 110
23463: PPUSH
23464: LD_VAR 0 2
23468: PPUSH
23469: EMPTY
23470: PPUSH
23471: CALL_OW 1
23475: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23476: LD_ADDR_EXP 111
23480: PUSH
23481: LD_EXP 111
23485: PPUSH
23486: LD_VAR 0 2
23490: PPUSH
23491: EMPTY
23492: PPUSH
23493: CALL_OW 1
23497: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23498: LD_ADDR_EXP 112
23502: PUSH
23503: LD_EXP 112
23507: PPUSH
23508: LD_VAR 0 2
23512: PPUSH
23513: EMPTY
23514: PPUSH
23515: CALL_OW 1
23519: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23520: LD_ADDR_EXP 113
23524: PUSH
23525: LD_EXP 113
23529: PPUSH
23530: LD_VAR 0 2
23534: PPUSH
23535: EMPTY
23536: PPUSH
23537: CALL_OW 1
23541: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23542: LD_ADDR_EXP 114
23546: PUSH
23547: LD_EXP 114
23551: PPUSH
23552: LD_VAR 0 2
23556: PPUSH
23557: EMPTY
23558: PPUSH
23559: CALL_OW 1
23563: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23564: LD_ADDR_EXP 115
23568: PUSH
23569: LD_EXP 115
23573: PPUSH
23574: LD_VAR 0 2
23578: PPUSH
23579: EMPTY
23580: PPUSH
23581: CALL_OW 1
23585: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23586: LD_ADDR_EXP 104
23590: PUSH
23591: LD_EXP 104
23595: PPUSH
23596: LD_VAR 0 2
23600: PPUSH
23601: LD_INT 0
23603: PPUSH
23604: CALL_OW 1
23608: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23609: LD_ADDR_EXP 117
23613: PUSH
23614: LD_EXP 117
23618: PPUSH
23619: LD_VAR 0 2
23623: PPUSH
23624: LD_INT 0
23626: PPUSH
23627: CALL_OW 1
23631: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23632: LD_ADDR_EXP 105
23636: PUSH
23637: LD_EXP 105
23641: PPUSH
23642: LD_VAR 0 2
23646: PPUSH
23647: EMPTY
23648: PPUSH
23649: CALL_OW 1
23653: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23654: LD_ADDR_EXP 116
23658: PUSH
23659: LD_EXP 116
23663: PPUSH
23664: LD_VAR 0 2
23668: PPUSH
23669: LD_INT 0
23671: PPUSH
23672: CALL_OW 1
23676: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23677: LD_ADDR_EXP 118
23681: PUSH
23682: LD_EXP 118
23686: PPUSH
23687: LD_VAR 0 2
23691: PPUSH
23692: EMPTY
23693: PPUSH
23694: CALL_OW 1
23698: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23699: LD_ADDR_EXP 121
23703: PUSH
23704: LD_EXP 121
23708: PPUSH
23709: LD_VAR 0 2
23713: PPUSH
23714: LD_INT 0
23716: PPUSH
23717: CALL_OW 1
23721: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23722: LD_ADDR_EXP 122
23726: PUSH
23727: LD_EXP 122
23731: PPUSH
23732: LD_VAR 0 2
23736: PPUSH
23737: EMPTY
23738: PPUSH
23739: CALL_OW 1
23743: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23744: LD_ADDR_EXP 123
23748: PUSH
23749: LD_EXP 123
23753: PPUSH
23754: LD_VAR 0 2
23758: PPUSH
23759: EMPTY
23760: PPUSH
23761: CALL_OW 1
23765: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23766: LD_ADDR_EXP 124
23770: PUSH
23771: LD_EXP 124
23775: PPUSH
23776: LD_VAR 0 2
23780: PPUSH
23781: EMPTY
23782: PPUSH
23783: CALL_OW 1
23787: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23788: LD_ADDR_EXP 126
23792: PUSH
23793: LD_EXP 126
23797: PPUSH
23798: LD_VAR 0 2
23802: PPUSH
23803: LD_EXP 93
23807: PUSH
23808: LD_VAR 0 2
23812: ARRAY
23813: PPUSH
23814: LD_INT 2
23816: PUSH
23817: LD_INT 30
23819: PUSH
23820: LD_INT 6
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: LD_INT 30
23829: PUSH
23830: LD_INT 7
23832: PUSH
23833: EMPTY
23834: LIST
23835: LIST
23836: PUSH
23837: LD_INT 30
23839: PUSH
23840: LD_INT 8
23842: PUSH
23843: EMPTY
23844: LIST
23845: LIST
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 72
23857: PPUSH
23858: CALL_OW 1
23862: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23863: LD_ADDR_EXP 127
23867: PUSH
23868: LD_EXP 127
23872: PPUSH
23873: LD_VAR 0 2
23877: PPUSH
23878: EMPTY
23879: PPUSH
23880: CALL_OW 1
23884: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23885: LD_ADDR_EXP 128
23889: PUSH
23890: LD_EXP 128
23894: PPUSH
23895: LD_VAR 0 2
23899: PPUSH
23900: EMPTY
23901: PPUSH
23902: CALL_OW 1
23906: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23907: LD_ADDR_EXP 129
23911: PUSH
23912: LD_EXP 129
23916: PPUSH
23917: LD_VAR 0 2
23921: PPUSH
23922: EMPTY
23923: PPUSH
23924: CALL_OW 1
23928: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23929: LD_ADDR_EXP 130
23933: PUSH
23934: LD_EXP 130
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: EMPTY
23945: PPUSH
23946: CALL_OW 1
23950: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23951: LD_ADDR_EXP 131
23955: PUSH
23956: LD_EXP 131
23960: PPUSH
23961: LD_VAR 0 2
23965: PPUSH
23966: EMPTY
23967: PPUSH
23968: CALL_OW 1
23972: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23973: LD_ADDR_EXP 132
23977: PUSH
23978: LD_EXP 132
23982: PPUSH
23983: LD_VAR 0 2
23987: PPUSH
23988: EMPTY
23989: PPUSH
23990: CALL_OW 1
23994: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23995: LD_ADDR_EXP 133
23999: PUSH
24000: LD_EXP 133
24004: PPUSH
24005: LD_VAR 0 2
24009: PPUSH
24010: EMPTY
24011: PPUSH
24012: CALL_OW 1
24016: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24017: LD_ADDR_EXP 134
24021: PUSH
24022: LD_EXP 134
24026: PPUSH
24027: LD_VAR 0 2
24031: PPUSH
24032: EMPTY
24033: PPUSH
24034: CALL_OW 1
24038: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24039: LD_ADDR_EXP 135
24043: PUSH
24044: LD_EXP 135
24048: PPUSH
24049: LD_VAR 0 2
24053: PPUSH
24054: LD_INT 0
24056: PPUSH
24057: CALL_OW 1
24061: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24062: LD_ADDR_EXP 136
24066: PUSH
24067: LD_EXP 136
24071: PPUSH
24072: LD_VAR 0 2
24076: PPUSH
24077: LD_INT 0
24079: PPUSH
24080: CALL_OW 1
24084: ST_TO_ADDR
// end ;
24085: GO 22986
24087: POP
24088: POP
// MC_InitSides ( ) ;
24089: CALL 24375 0 0
// MC_InitResearch ( ) ;
24093: CALL 24114 0 0
// CustomInitMacro ( ) ;
24097: CALL 217 0 0
// skirmish := true ;
24101: LD_ADDR_EXP 91
24105: PUSH
24106: LD_INT 1
24108: ST_TO_ADDR
// end ;
24109: LD_VAR 0 1
24113: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24114: LD_INT 0
24116: PPUSH
24117: PPUSH
24118: PPUSH
24119: PPUSH
24120: PPUSH
24121: PPUSH
// if not mc_bases then
24122: LD_EXP 93
24126: NOT
24127: IFFALSE 24131
// exit ;
24129: GO 24370
// for i = 1 to 8 do
24131: LD_ADDR_VAR 0 2
24135: PUSH
24136: DOUBLE
24137: LD_INT 1
24139: DEC
24140: ST_TO_ADDR
24141: LD_INT 8
24143: PUSH
24144: FOR_TO
24145: IFFALSE 24171
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24147: LD_ADDR_EXP 120
24151: PUSH
24152: LD_EXP 120
24156: PPUSH
24157: LD_VAR 0 2
24161: PPUSH
24162: EMPTY
24163: PPUSH
24164: CALL_OW 1
24168: ST_TO_ADDR
24169: GO 24144
24171: POP
24172: POP
// tmp := [ ] ;
24173: LD_ADDR_VAR 0 5
24177: PUSH
24178: EMPTY
24179: ST_TO_ADDR
// for i = 1 to mc_sides do
24180: LD_ADDR_VAR 0 2
24184: PUSH
24185: DOUBLE
24186: LD_INT 1
24188: DEC
24189: ST_TO_ADDR
24190: LD_EXP 119
24194: PUSH
24195: FOR_TO
24196: IFFALSE 24254
// if not mc_sides [ i ] in tmp then
24198: LD_EXP 119
24202: PUSH
24203: LD_VAR 0 2
24207: ARRAY
24208: PUSH
24209: LD_VAR 0 5
24213: IN
24214: NOT
24215: IFFALSE 24252
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24217: LD_ADDR_VAR 0 5
24221: PUSH
24222: LD_VAR 0 5
24226: PPUSH
24227: LD_VAR 0 5
24231: PUSH
24232: LD_INT 1
24234: PLUS
24235: PPUSH
24236: LD_EXP 119
24240: PUSH
24241: LD_VAR 0 2
24245: ARRAY
24246: PPUSH
24247: CALL_OW 2
24251: ST_TO_ADDR
24252: GO 24195
24254: POP
24255: POP
// if not tmp then
24256: LD_VAR 0 5
24260: NOT
24261: IFFALSE 24265
// exit ;
24263: GO 24370
// for j in tmp do
24265: LD_ADDR_VAR 0 3
24269: PUSH
24270: LD_VAR 0 5
24274: PUSH
24275: FOR_IN
24276: IFFALSE 24368
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24278: LD_ADDR_VAR 0 6
24282: PUSH
24283: LD_INT 22
24285: PUSH
24286: LD_VAR 0 3
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: PPUSH
24295: CALL_OW 69
24299: ST_TO_ADDR
// if not un then
24300: LD_VAR 0 6
24304: NOT
24305: IFFALSE 24309
// continue ;
24307: GO 24275
// nation := GetNation ( un [ 1 ] ) ;
24309: LD_ADDR_VAR 0 4
24313: PUSH
24314: LD_VAR 0 6
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 248
24327: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24328: LD_ADDR_EXP 120
24332: PUSH
24333: LD_EXP 120
24337: PPUSH
24338: LD_VAR 0 3
24342: PPUSH
24343: LD_VAR 0 3
24347: PPUSH
24348: LD_VAR 0 4
24352: PPUSH
24353: LD_INT 1
24355: PPUSH
24356: CALL 51344 0 3
24360: PPUSH
24361: CALL_OW 1
24365: ST_TO_ADDR
// end ;
24366: GO 24275
24368: POP
24369: POP
// end ;
24370: LD_VAR 0 1
24374: RET
// export function MC_InitSides ( ) ; var i ; begin
24375: LD_INT 0
24377: PPUSH
24378: PPUSH
// if not mc_bases then
24379: LD_EXP 93
24383: NOT
24384: IFFALSE 24388
// exit ;
24386: GO 24462
// for i = 1 to mc_bases do
24388: LD_ADDR_VAR 0 2
24392: PUSH
24393: DOUBLE
24394: LD_INT 1
24396: DEC
24397: ST_TO_ADDR
24398: LD_EXP 93
24402: PUSH
24403: FOR_TO
24404: IFFALSE 24460
// if mc_bases [ i ] then
24406: LD_EXP 93
24410: PUSH
24411: LD_VAR 0 2
24415: ARRAY
24416: IFFALSE 24458
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24418: LD_ADDR_EXP 119
24422: PUSH
24423: LD_EXP 119
24427: PPUSH
24428: LD_VAR 0 2
24432: PPUSH
24433: LD_EXP 93
24437: PUSH
24438: LD_VAR 0 2
24442: ARRAY
24443: PUSH
24444: LD_INT 1
24446: ARRAY
24447: PPUSH
24448: CALL_OW 255
24452: PPUSH
24453: CALL_OW 1
24457: ST_TO_ADDR
24458: GO 24403
24460: POP
24461: POP
// end ;
24462: LD_VAR 0 1
24466: RET
// every 0 0$03 trigger skirmish do
24467: LD_EXP 91
24471: IFFALSE 24625
24473: GO 24475
24475: DISABLE
// begin enable ;
24476: ENABLE
// MC_CheckBuildings ( ) ;
24477: CALL 29123 0 0
// MC_CheckPeopleLife ( ) ;
24481: CALL 29284 0 0
// RaiseSailEvent ( 100 ) ;
24485: LD_INT 100
24487: PPUSH
24488: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24492: LD_INT 103
24494: PPUSH
24495: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24499: LD_INT 104
24501: PPUSH
24502: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24506: LD_INT 105
24508: PPUSH
24509: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24513: LD_INT 106
24515: PPUSH
24516: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24520: LD_INT 107
24522: PPUSH
24523: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24527: LD_INT 108
24529: PPUSH
24530: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24534: LD_INT 109
24536: PPUSH
24537: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24541: LD_INT 110
24543: PPUSH
24544: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24548: LD_INT 111
24550: PPUSH
24551: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24555: LD_INT 112
24557: PPUSH
24558: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24562: LD_INT 113
24564: PPUSH
24565: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24569: LD_INT 120
24571: PPUSH
24572: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24576: LD_INT 121
24578: PPUSH
24579: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24583: LD_INT 122
24585: PPUSH
24586: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24590: LD_INT 123
24592: PPUSH
24593: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24597: LD_INT 124
24599: PPUSH
24600: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24604: LD_INT 125
24606: PPUSH
24607: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24611: LD_INT 126
24613: PPUSH
24614: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24618: LD_INT 200
24620: PPUSH
24621: CALL_OW 427
// end ;
24625: END
// on SailEvent ( event ) do begin if event < 100 then
24626: LD_VAR 0 1
24630: PUSH
24631: LD_INT 100
24633: LESS
24634: IFFALSE 24645
// CustomEvent ( event ) ;
24636: LD_VAR 0 1
24640: PPUSH
24641: CALL 10417 0 1
// if event = 100 then
24645: LD_VAR 0 1
24649: PUSH
24650: LD_INT 100
24652: EQUAL
24653: IFFALSE 24659
// MC_ClassManager ( ) ;
24655: CALL 25051 0 0
// if event = 101 then
24659: LD_VAR 0 1
24663: PUSH
24664: LD_INT 101
24666: EQUAL
24667: IFFALSE 24673
// MC_RepairBuildings ( ) ;
24669: CALL 29869 0 0
// if event = 102 then
24673: LD_VAR 0 1
24677: PUSH
24678: LD_INT 102
24680: EQUAL
24681: IFFALSE 24687
// MC_Heal ( ) ;
24683: CALL 30776 0 0
// if event = 103 then
24687: LD_VAR 0 1
24691: PUSH
24692: LD_INT 103
24694: EQUAL
24695: IFFALSE 24701
// MC_Build ( ) ;
24697: CALL 31198 0 0
// if event = 104 then
24701: LD_VAR 0 1
24705: PUSH
24706: LD_INT 104
24708: EQUAL
24709: IFFALSE 24715
// MC_TurretWeapon ( ) ;
24711: CALL 32839 0 0
// if event = 105 then
24715: LD_VAR 0 1
24719: PUSH
24720: LD_INT 105
24722: EQUAL
24723: IFFALSE 24729
// MC_BuildUpgrade ( ) ;
24725: CALL 32390 0 0
// if event = 106 then
24729: LD_VAR 0 1
24733: PUSH
24734: LD_INT 106
24736: EQUAL
24737: IFFALSE 24743
// MC_PlantMines ( ) ;
24739: CALL 33269 0 0
// if event = 107 then
24743: LD_VAR 0 1
24747: PUSH
24748: LD_INT 107
24750: EQUAL
24751: IFFALSE 24757
// MC_CollectCrates ( ) ;
24753: CALL 34060 0 0
// if event = 108 then
24757: LD_VAR 0 1
24761: PUSH
24762: LD_INT 108
24764: EQUAL
24765: IFFALSE 24771
// MC_LinkRemoteControl ( ) ;
24767: CALL 35910 0 0
// if event = 109 then
24771: LD_VAR 0 1
24775: PUSH
24776: LD_INT 109
24778: EQUAL
24779: IFFALSE 24785
// MC_ProduceVehicle ( ) ;
24781: CALL 36091 0 0
// if event = 110 then
24785: LD_VAR 0 1
24789: PUSH
24790: LD_INT 110
24792: EQUAL
24793: IFFALSE 24799
// MC_SendAttack ( ) ;
24795: CALL 36557 0 0
// if event = 111 then
24799: LD_VAR 0 1
24803: PUSH
24804: LD_INT 111
24806: EQUAL
24807: IFFALSE 24813
// MC_Defend ( ) ;
24809: CALL 36665 0 0
// if event = 112 then
24813: LD_VAR 0 1
24817: PUSH
24818: LD_INT 112
24820: EQUAL
24821: IFFALSE 24827
// MC_Research ( ) ;
24823: CALL 37398 0 0
// if event = 113 then
24827: LD_VAR 0 1
24831: PUSH
24832: LD_INT 113
24834: EQUAL
24835: IFFALSE 24841
// MC_MinesTrigger ( ) ;
24837: CALL 38512 0 0
// if event = 120 then
24841: LD_VAR 0 1
24845: PUSH
24846: LD_INT 120
24848: EQUAL
24849: IFFALSE 24855
// MC_RepairVehicle ( ) ;
24851: CALL 38611 0 0
// if event = 121 then
24855: LD_VAR 0 1
24859: PUSH
24860: LD_INT 121
24862: EQUAL
24863: IFFALSE 24869
// MC_TameApe ( ) ;
24865: CALL 39352 0 0
// if event = 122 then
24869: LD_VAR 0 1
24873: PUSH
24874: LD_INT 122
24876: EQUAL
24877: IFFALSE 24883
// MC_ChangeApeClass ( ) ;
24879: CALL 40181 0 0
// if event = 123 then
24883: LD_VAR 0 1
24887: PUSH
24888: LD_INT 123
24890: EQUAL
24891: IFFALSE 24897
// MC_Bazooka ( ) ;
24893: CALL 40831 0 0
// if event = 124 then
24897: LD_VAR 0 1
24901: PUSH
24902: LD_INT 124
24904: EQUAL
24905: IFFALSE 24911
// MC_TeleportExit ( ) ;
24907: CALL 41029 0 0
// if event = 125 then
24911: LD_VAR 0 1
24915: PUSH
24916: LD_INT 125
24918: EQUAL
24919: IFFALSE 24925
// MC_Deposits ( ) ;
24921: CALL 41676 0 0
// if event = 126 then
24925: LD_VAR 0 1
24929: PUSH
24930: LD_INT 126
24932: EQUAL
24933: IFFALSE 24939
// MC_RemoteDriver ( ) ;
24935: CALL 42301 0 0
// if event = 200 then
24939: LD_VAR 0 1
24943: PUSH
24944: LD_INT 200
24946: EQUAL
24947: IFFALSE 24953
// MC_Idle ( ) ;
24949: CALL 44250 0 0
// end ;
24953: PPOPN 1
24955: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24956: LD_INT 0
24958: PPUSH
24959: PPUSH
// if not mc_bases [ base ] or not tag then
24960: LD_EXP 93
24964: PUSH
24965: LD_VAR 0 1
24969: ARRAY
24970: NOT
24971: PUSH
24972: LD_VAR 0 2
24976: NOT
24977: OR
24978: IFFALSE 24982
// exit ;
24980: GO 25046
// for i in mc_bases [ base ] union mc_ape [ base ] do
24982: LD_ADDR_VAR 0 4
24986: PUSH
24987: LD_EXP 93
24991: PUSH
24992: LD_VAR 0 1
24996: ARRAY
24997: PUSH
24998: LD_EXP 122
25002: PUSH
25003: LD_VAR 0 1
25007: ARRAY
25008: UNION
25009: PUSH
25010: FOR_IN
25011: IFFALSE 25044
// if GetTag ( i ) = tag then
25013: LD_VAR 0 4
25017: PPUSH
25018: CALL_OW 110
25022: PUSH
25023: LD_VAR 0 2
25027: EQUAL
25028: IFFALSE 25042
// SetTag ( i , 0 ) ;
25030: LD_VAR 0 4
25034: PPUSH
25035: LD_INT 0
25037: PPUSH
25038: CALL_OW 109
25042: GO 25010
25044: POP
25045: POP
// end ;
25046: LD_VAR 0 3
25050: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25051: LD_INT 0
25053: PPUSH
25054: PPUSH
25055: PPUSH
25056: PPUSH
25057: PPUSH
25058: PPUSH
25059: PPUSH
25060: PPUSH
// if not mc_bases then
25061: LD_EXP 93
25065: NOT
25066: IFFALSE 25070
// exit ;
25068: GO 25528
// for i = 1 to mc_bases do
25070: LD_ADDR_VAR 0 2
25074: PUSH
25075: DOUBLE
25076: LD_INT 1
25078: DEC
25079: ST_TO_ADDR
25080: LD_EXP 93
25084: PUSH
25085: FOR_TO
25086: IFFALSE 25526
// begin tmp := MC_ClassCheckReq ( i ) ;
25088: LD_ADDR_VAR 0 4
25092: PUSH
25093: LD_VAR 0 2
25097: PPUSH
25098: CALL 25533 0 1
25102: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25103: LD_ADDR_EXP 134
25107: PUSH
25108: LD_EXP 134
25112: PPUSH
25113: LD_VAR 0 2
25117: PPUSH
25118: LD_VAR 0 4
25122: PPUSH
25123: CALL_OW 1
25127: ST_TO_ADDR
// if not tmp then
25128: LD_VAR 0 4
25132: NOT
25133: IFFALSE 25137
// continue ;
25135: GO 25085
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25137: LD_ADDR_VAR 0 6
25141: PUSH
25142: LD_EXP 93
25146: PUSH
25147: LD_VAR 0 2
25151: ARRAY
25152: PPUSH
25153: LD_INT 2
25155: PUSH
25156: LD_INT 30
25158: PUSH
25159: LD_INT 4
25161: PUSH
25162: EMPTY
25163: LIST
25164: LIST
25165: PUSH
25166: LD_INT 30
25168: PUSH
25169: LD_INT 5
25171: PUSH
25172: EMPTY
25173: LIST
25174: LIST
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: LIST
25180: PPUSH
25181: CALL_OW 72
25185: PUSH
25186: LD_EXP 93
25190: PUSH
25191: LD_VAR 0 2
25195: ARRAY
25196: PPUSH
25197: LD_INT 2
25199: PUSH
25200: LD_INT 30
25202: PUSH
25203: LD_INT 0
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 30
25212: PUSH
25213: LD_INT 1
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: PUSH
25220: EMPTY
25221: LIST
25222: LIST
25223: LIST
25224: PPUSH
25225: CALL_OW 72
25229: PUSH
25230: LD_EXP 93
25234: PUSH
25235: LD_VAR 0 2
25239: ARRAY
25240: PPUSH
25241: LD_INT 30
25243: PUSH
25244: LD_INT 3
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: PPUSH
25251: CALL_OW 72
25255: PUSH
25256: LD_EXP 93
25260: PUSH
25261: LD_VAR 0 2
25265: ARRAY
25266: PPUSH
25267: LD_INT 2
25269: PUSH
25270: LD_INT 30
25272: PUSH
25273: LD_INT 6
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 30
25282: PUSH
25283: LD_INT 7
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 30
25292: PUSH
25293: LD_INT 8
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: EMPTY
25301: LIST
25302: LIST
25303: LIST
25304: LIST
25305: PPUSH
25306: CALL_OW 72
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: LIST
25315: LIST
25316: ST_TO_ADDR
// for j = 1 to 4 do
25317: LD_ADDR_VAR 0 3
25321: PUSH
25322: DOUBLE
25323: LD_INT 1
25325: DEC
25326: ST_TO_ADDR
25327: LD_INT 4
25329: PUSH
25330: FOR_TO
25331: IFFALSE 25522
// begin if not tmp [ j ] then
25333: LD_VAR 0 4
25337: PUSH
25338: LD_VAR 0 3
25342: ARRAY
25343: NOT
25344: IFFALSE 25348
// continue ;
25346: GO 25330
// for p in tmp [ j ] do
25348: LD_ADDR_VAR 0 5
25352: PUSH
25353: LD_VAR 0 4
25357: PUSH
25358: LD_VAR 0 3
25362: ARRAY
25363: PUSH
25364: FOR_IN
25365: IFFALSE 25518
// begin if not b [ j ] then
25367: LD_VAR 0 6
25371: PUSH
25372: LD_VAR 0 3
25376: ARRAY
25377: NOT
25378: IFFALSE 25382
// break ;
25380: GO 25518
// e := 0 ;
25382: LD_ADDR_VAR 0 7
25386: PUSH
25387: LD_INT 0
25389: ST_TO_ADDR
// for k in b [ j ] do
25390: LD_ADDR_VAR 0 8
25394: PUSH
25395: LD_VAR 0 6
25399: PUSH
25400: LD_VAR 0 3
25404: ARRAY
25405: PUSH
25406: FOR_IN
25407: IFFALSE 25434
// if IsNotFull ( k ) then
25409: LD_VAR 0 8
25413: PPUSH
25414: CALL 53497 0 1
25418: IFFALSE 25432
// begin e := k ;
25420: LD_ADDR_VAR 0 7
25424: PUSH
25425: LD_VAR 0 8
25429: ST_TO_ADDR
// break ;
25430: GO 25434
// end ;
25432: GO 25406
25434: POP
25435: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25436: LD_VAR 0 7
25440: PUSH
25441: LD_VAR 0 5
25445: PPUSH
25446: LD_VAR 0 7
25450: PPUSH
25451: CALL 86661 0 2
25455: NOT
25456: AND
25457: IFFALSE 25516
// begin if IsInUnit ( p ) then
25459: LD_VAR 0 5
25463: PPUSH
25464: CALL_OW 310
25468: IFFALSE 25479
// ComExitBuilding ( p ) ;
25470: LD_VAR 0 5
25474: PPUSH
25475: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25479: LD_VAR 0 5
25483: PPUSH
25484: LD_VAR 0 7
25488: PPUSH
25489: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25493: LD_VAR 0 5
25497: PPUSH
25498: LD_VAR 0 3
25502: PPUSH
25503: CALL_OW 183
// AddComExitBuilding ( p ) ;
25507: LD_VAR 0 5
25511: PPUSH
25512: CALL_OW 182
// end ; end ;
25516: GO 25364
25518: POP
25519: POP
// end ;
25520: GO 25330
25522: POP
25523: POP
// end ;
25524: GO 25085
25526: POP
25527: POP
// end ;
25528: LD_VAR 0 1
25532: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25533: LD_INT 0
25535: PPUSH
25536: PPUSH
25537: PPUSH
25538: PPUSH
25539: PPUSH
25540: PPUSH
25541: PPUSH
25542: PPUSH
25543: PPUSH
25544: PPUSH
25545: PPUSH
25546: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25547: LD_VAR 0 1
25551: NOT
25552: PUSH
25553: LD_EXP 93
25557: PUSH
25558: LD_VAR 0 1
25562: ARRAY
25563: NOT
25564: OR
25565: PUSH
25566: LD_EXP 93
25570: PUSH
25571: LD_VAR 0 1
25575: ARRAY
25576: PPUSH
25577: LD_INT 2
25579: PUSH
25580: LD_INT 30
25582: PUSH
25583: LD_INT 0
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 30
25592: PUSH
25593: LD_INT 1
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: LIST
25604: PPUSH
25605: CALL_OW 72
25609: NOT
25610: OR
25611: IFFALSE 25615
// exit ;
25613: GO 29118
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25615: LD_ADDR_VAR 0 4
25619: PUSH
25620: LD_EXP 93
25624: PUSH
25625: LD_VAR 0 1
25629: ARRAY
25630: PPUSH
25631: LD_INT 2
25633: PUSH
25634: LD_INT 25
25636: PUSH
25637: LD_INT 1
25639: PUSH
25640: EMPTY
25641: LIST
25642: LIST
25643: PUSH
25644: LD_INT 25
25646: PUSH
25647: LD_INT 2
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 25
25656: PUSH
25657: LD_INT 3
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 25
25666: PUSH
25667: LD_INT 4
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: PUSH
25674: LD_INT 25
25676: PUSH
25677: LD_INT 5
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 25
25686: PUSH
25687: LD_INT 8
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: PUSH
25694: LD_INT 25
25696: PUSH
25697: LD_INT 9
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: LIST
25708: LIST
25709: LIST
25710: LIST
25711: LIST
25712: LIST
25713: PPUSH
25714: CALL_OW 72
25718: ST_TO_ADDR
// if not tmp then
25719: LD_VAR 0 4
25723: NOT
25724: IFFALSE 25728
// exit ;
25726: GO 29118
// for i in tmp do
25728: LD_ADDR_VAR 0 3
25732: PUSH
25733: LD_VAR 0 4
25737: PUSH
25738: FOR_IN
25739: IFFALSE 25770
// if GetTag ( i ) then
25741: LD_VAR 0 3
25745: PPUSH
25746: CALL_OW 110
25750: IFFALSE 25768
// tmp := tmp diff i ;
25752: LD_ADDR_VAR 0 4
25756: PUSH
25757: LD_VAR 0 4
25761: PUSH
25762: LD_VAR 0 3
25766: DIFF
25767: ST_TO_ADDR
25768: GO 25738
25770: POP
25771: POP
// if not tmp then
25772: LD_VAR 0 4
25776: NOT
25777: IFFALSE 25781
// exit ;
25779: GO 29118
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25781: LD_ADDR_VAR 0 5
25785: PUSH
25786: LD_EXP 93
25790: PUSH
25791: LD_VAR 0 1
25795: ARRAY
25796: PPUSH
25797: LD_INT 2
25799: PUSH
25800: LD_INT 25
25802: PUSH
25803: LD_INT 1
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 25
25812: PUSH
25813: LD_INT 5
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 25
25822: PUSH
25823: LD_INT 8
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 25
25832: PUSH
25833: LD_INT 9
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: LIST
25844: LIST
25845: LIST
25846: PPUSH
25847: CALL_OW 72
25851: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25852: LD_ADDR_VAR 0 6
25856: PUSH
25857: LD_EXP 93
25861: PUSH
25862: LD_VAR 0 1
25866: ARRAY
25867: PPUSH
25868: LD_INT 25
25870: PUSH
25871: LD_INT 2
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PPUSH
25878: CALL_OW 72
25882: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25883: LD_ADDR_VAR 0 7
25887: PUSH
25888: LD_EXP 93
25892: PUSH
25893: LD_VAR 0 1
25897: ARRAY
25898: PPUSH
25899: LD_INT 25
25901: PUSH
25902: LD_INT 3
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PPUSH
25909: CALL_OW 72
25913: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25914: LD_ADDR_VAR 0 8
25918: PUSH
25919: LD_EXP 93
25923: PUSH
25924: LD_VAR 0 1
25928: ARRAY
25929: PPUSH
25930: LD_INT 25
25932: PUSH
25933: LD_INT 4
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: PUSH
25940: LD_INT 24
25942: PUSH
25943: LD_INT 251
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: PPUSH
25954: CALL_OW 72
25958: ST_TO_ADDR
// if mc_is_defending [ base ] then
25959: LD_EXP 136
25963: PUSH
25964: LD_VAR 0 1
25968: ARRAY
25969: IFFALSE 26430
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25971: LD_ADDR_EXP 135
25975: PUSH
25976: LD_EXP 135
25980: PPUSH
25981: LD_VAR 0 1
25985: PPUSH
25986: LD_INT 4
25988: PPUSH
25989: CALL_OW 1
25993: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25994: LD_ADDR_VAR 0 12
25998: PUSH
25999: LD_EXP 93
26003: PUSH
26004: LD_VAR 0 1
26008: ARRAY
26009: PPUSH
26010: LD_INT 2
26012: PUSH
26013: LD_INT 30
26015: PUSH
26016: LD_INT 4
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PUSH
26023: LD_INT 30
26025: PUSH
26026: LD_INT 5
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PUSH
26033: EMPTY
26034: LIST
26035: LIST
26036: LIST
26037: PPUSH
26038: CALL_OW 72
26042: ST_TO_ADDR
// if not b then
26043: LD_VAR 0 12
26047: NOT
26048: IFFALSE 26052
// exit ;
26050: GO 29118
// p := [ ] ;
26052: LD_ADDR_VAR 0 11
26056: PUSH
26057: EMPTY
26058: ST_TO_ADDR
// if sci >= 2 then
26059: LD_VAR 0 8
26063: PUSH
26064: LD_INT 2
26066: GREATEREQUAL
26067: IFFALSE 26098
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26069: LD_ADDR_VAR 0 8
26073: PUSH
26074: LD_VAR 0 8
26078: PUSH
26079: LD_INT 1
26081: ARRAY
26082: PUSH
26083: LD_VAR 0 8
26087: PUSH
26088: LD_INT 2
26090: ARRAY
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: ST_TO_ADDR
26096: GO 26159
// if sci = 1 then
26098: LD_VAR 0 8
26102: PUSH
26103: LD_INT 1
26105: EQUAL
26106: IFFALSE 26127
// sci := [ sci [ 1 ] ] else
26108: LD_ADDR_VAR 0 8
26112: PUSH
26113: LD_VAR 0 8
26117: PUSH
26118: LD_INT 1
26120: ARRAY
26121: PUSH
26122: EMPTY
26123: LIST
26124: ST_TO_ADDR
26125: GO 26159
// if sci = 0 then
26127: LD_VAR 0 8
26131: PUSH
26132: LD_INT 0
26134: EQUAL
26135: IFFALSE 26159
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26137: LD_ADDR_VAR 0 11
26141: PUSH
26142: LD_VAR 0 4
26146: PPUSH
26147: LD_INT 4
26149: PPUSH
26150: CALL 86524 0 2
26154: PUSH
26155: LD_INT 1
26157: ARRAY
26158: ST_TO_ADDR
// if eng > 4 then
26159: LD_VAR 0 6
26163: PUSH
26164: LD_INT 4
26166: GREATER
26167: IFFALSE 26213
// for i = eng downto 4 do
26169: LD_ADDR_VAR 0 3
26173: PUSH
26174: DOUBLE
26175: LD_VAR 0 6
26179: INC
26180: ST_TO_ADDR
26181: LD_INT 4
26183: PUSH
26184: FOR_DOWNTO
26185: IFFALSE 26211
// eng := eng diff eng [ i ] ;
26187: LD_ADDR_VAR 0 6
26191: PUSH
26192: LD_VAR 0 6
26196: PUSH
26197: LD_VAR 0 6
26201: PUSH
26202: LD_VAR 0 3
26206: ARRAY
26207: DIFF
26208: ST_TO_ADDR
26209: GO 26184
26211: POP
26212: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26213: LD_ADDR_VAR 0 4
26217: PUSH
26218: LD_VAR 0 4
26222: PUSH
26223: LD_VAR 0 5
26227: PUSH
26228: LD_VAR 0 6
26232: UNION
26233: PUSH
26234: LD_VAR 0 7
26238: UNION
26239: PUSH
26240: LD_VAR 0 8
26244: UNION
26245: DIFF
26246: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26247: LD_ADDR_VAR 0 13
26251: PUSH
26252: LD_EXP 93
26256: PUSH
26257: LD_VAR 0 1
26261: ARRAY
26262: PPUSH
26263: LD_INT 2
26265: PUSH
26266: LD_INT 30
26268: PUSH
26269: LD_INT 32
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 30
26278: PUSH
26279: LD_INT 31
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: LIST
26290: PPUSH
26291: CALL_OW 72
26295: PUSH
26296: LD_EXP 93
26300: PUSH
26301: LD_VAR 0 1
26305: ARRAY
26306: PPUSH
26307: LD_INT 2
26309: PUSH
26310: LD_INT 30
26312: PUSH
26313: LD_INT 4
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 30
26322: PUSH
26323: LD_INT 5
26325: PUSH
26326: EMPTY
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: LIST
26334: PPUSH
26335: CALL_OW 72
26339: PUSH
26340: LD_INT 6
26342: MUL
26343: PLUS
26344: ST_TO_ADDR
// if bcount < tmp then
26345: LD_VAR 0 13
26349: PUSH
26350: LD_VAR 0 4
26354: LESS
26355: IFFALSE 26401
// for i = tmp downto bcount do
26357: LD_ADDR_VAR 0 3
26361: PUSH
26362: DOUBLE
26363: LD_VAR 0 4
26367: INC
26368: ST_TO_ADDR
26369: LD_VAR 0 13
26373: PUSH
26374: FOR_DOWNTO
26375: IFFALSE 26399
// tmp := Delete ( tmp , tmp ) ;
26377: LD_ADDR_VAR 0 4
26381: PUSH
26382: LD_VAR 0 4
26386: PPUSH
26387: LD_VAR 0 4
26391: PPUSH
26392: CALL_OW 3
26396: ST_TO_ADDR
26397: GO 26374
26399: POP
26400: POP
// result := [ tmp , 0 , 0 , p ] ;
26401: LD_ADDR_VAR 0 2
26405: PUSH
26406: LD_VAR 0 4
26410: PUSH
26411: LD_INT 0
26413: PUSH
26414: LD_INT 0
26416: PUSH
26417: LD_VAR 0 11
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: LIST
26426: LIST
26427: ST_TO_ADDR
// exit ;
26428: GO 29118
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26430: LD_EXP 93
26434: PUSH
26435: LD_VAR 0 1
26439: ARRAY
26440: PPUSH
26441: LD_INT 2
26443: PUSH
26444: LD_INT 30
26446: PUSH
26447: LD_INT 6
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: LD_INT 30
26456: PUSH
26457: LD_INT 7
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 30
26466: PUSH
26467: LD_INT 8
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: LIST
26478: LIST
26479: PPUSH
26480: CALL_OW 72
26484: NOT
26485: PUSH
26486: LD_EXP 93
26490: PUSH
26491: LD_VAR 0 1
26495: ARRAY
26496: PPUSH
26497: LD_INT 30
26499: PUSH
26500: LD_INT 3
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL_OW 72
26511: NOT
26512: AND
26513: IFFALSE 26585
// begin if eng = tmp then
26515: LD_VAR 0 6
26519: PUSH
26520: LD_VAR 0 4
26524: EQUAL
26525: IFFALSE 26529
// exit ;
26527: GO 29118
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26529: LD_ADDR_EXP 135
26533: PUSH
26534: LD_EXP 135
26538: PPUSH
26539: LD_VAR 0 1
26543: PPUSH
26544: LD_INT 1
26546: PPUSH
26547: CALL_OW 1
26551: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26552: LD_ADDR_VAR 0 2
26556: PUSH
26557: LD_INT 0
26559: PUSH
26560: LD_VAR 0 4
26564: PUSH
26565: LD_VAR 0 6
26569: DIFF
26570: PUSH
26571: LD_INT 0
26573: PUSH
26574: LD_INT 0
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: LIST
26581: LIST
26582: ST_TO_ADDR
// exit ;
26583: GO 29118
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26585: LD_EXP 120
26589: PUSH
26590: LD_EXP 119
26594: PUSH
26595: LD_VAR 0 1
26599: ARRAY
26600: ARRAY
26601: PUSH
26602: LD_EXP 93
26606: PUSH
26607: LD_VAR 0 1
26611: ARRAY
26612: PPUSH
26613: LD_INT 2
26615: PUSH
26616: LD_INT 30
26618: PUSH
26619: LD_INT 6
26621: PUSH
26622: EMPTY
26623: LIST
26624: LIST
26625: PUSH
26626: LD_INT 30
26628: PUSH
26629: LD_INT 7
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: LD_INT 30
26638: PUSH
26639: LD_INT 8
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: PPUSH
26652: CALL_OW 72
26656: AND
26657: PUSH
26658: LD_EXP 93
26662: PUSH
26663: LD_VAR 0 1
26667: ARRAY
26668: PPUSH
26669: LD_INT 30
26671: PUSH
26672: LD_INT 3
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PPUSH
26679: CALL_OW 72
26683: NOT
26684: AND
26685: IFFALSE 26899
// begin if sci >= 6 then
26687: LD_VAR 0 8
26691: PUSH
26692: LD_INT 6
26694: GREATEREQUAL
26695: IFFALSE 26699
// exit ;
26697: GO 29118
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26699: LD_ADDR_EXP 135
26703: PUSH
26704: LD_EXP 135
26708: PPUSH
26709: LD_VAR 0 1
26713: PPUSH
26714: LD_INT 2
26716: PPUSH
26717: CALL_OW 1
26721: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26722: LD_ADDR_VAR 0 9
26726: PUSH
26727: LD_VAR 0 4
26731: PUSH
26732: LD_VAR 0 8
26736: DIFF
26737: PPUSH
26738: LD_INT 4
26740: PPUSH
26741: CALL 86524 0 2
26745: ST_TO_ADDR
// p := [ ] ;
26746: LD_ADDR_VAR 0 11
26750: PUSH
26751: EMPTY
26752: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26753: LD_VAR 0 8
26757: PUSH
26758: LD_INT 6
26760: LESS
26761: PUSH
26762: LD_VAR 0 9
26766: PUSH
26767: LD_INT 6
26769: GREATER
26770: AND
26771: IFFALSE 26852
// begin for i = 1 to 6 - sci do
26773: LD_ADDR_VAR 0 3
26777: PUSH
26778: DOUBLE
26779: LD_INT 1
26781: DEC
26782: ST_TO_ADDR
26783: LD_INT 6
26785: PUSH
26786: LD_VAR 0 8
26790: MINUS
26791: PUSH
26792: FOR_TO
26793: IFFALSE 26848
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26795: LD_ADDR_VAR 0 11
26799: PUSH
26800: LD_VAR 0 11
26804: PPUSH
26805: LD_VAR 0 11
26809: PUSH
26810: LD_INT 1
26812: PLUS
26813: PPUSH
26814: LD_VAR 0 9
26818: PUSH
26819: LD_INT 1
26821: ARRAY
26822: PPUSH
26823: CALL_OW 2
26827: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26828: LD_ADDR_VAR 0 9
26832: PUSH
26833: LD_VAR 0 9
26837: PPUSH
26838: LD_INT 1
26840: PPUSH
26841: CALL_OW 3
26845: ST_TO_ADDR
// end ;
26846: GO 26792
26848: POP
26849: POP
// end else
26850: GO 26872
// if sort then
26852: LD_VAR 0 9
26856: IFFALSE 26872
// p := sort [ 1 ] ;
26858: LD_ADDR_VAR 0 11
26862: PUSH
26863: LD_VAR 0 9
26867: PUSH
26868: LD_INT 1
26870: ARRAY
26871: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26872: LD_ADDR_VAR 0 2
26876: PUSH
26877: LD_INT 0
26879: PUSH
26880: LD_INT 0
26882: PUSH
26883: LD_INT 0
26885: PUSH
26886: LD_VAR 0 11
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: LIST
26895: LIST
26896: ST_TO_ADDR
// exit ;
26897: GO 29118
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26899: LD_EXP 120
26903: PUSH
26904: LD_EXP 119
26908: PUSH
26909: LD_VAR 0 1
26913: ARRAY
26914: ARRAY
26915: PUSH
26916: LD_EXP 93
26920: PUSH
26921: LD_VAR 0 1
26925: ARRAY
26926: PPUSH
26927: LD_INT 2
26929: PUSH
26930: LD_INT 30
26932: PUSH
26933: LD_INT 6
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 30
26942: PUSH
26943: LD_INT 7
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 30
26952: PUSH
26953: LD_INT 8
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: LIST
26964: LIST
26965: PPUSH
26966: CALL_OW 72
26970: AND
26971: PUSH
26972: LD_EXP 93
26976: PUSH
26977: LD_VAR 0 1
26981: ARRAY
26982: PPUSH
26983: LD_INT 30
26985: PUSH
26986: LD_INT 3
26988: PUSH
26989: EMPTY
26990: LIST
26991: LIST
26992: PPUSH
26993: CALL_OW 72
26997: AND
26998: IFFALSE 27732
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27000: LD_ADDR_EXP 135
27004: PUSH
27005: LD_EXP 135
27009: PPUSH
27010: LD_VAR 0 1
27014: PPUSH
27015: LD_INT 3
27017: PPUSH
27018: CALL_OW 1
27022: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27023: LD_ADDR_VAR 0 2
27027: PUSH
27028: LD_INT 0
27030: PUSH
27031: LD_INT 0
27033: PUSH
27034: LD_INT 0
27036: PUSH
27037: LD_INT 0
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: LIST
27044: LIST
27045: ST_TO_ADDR
// if not eng then
27046: LD_VAR 0 6
27050: NOT
27051: IFFALSE 27114
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27053: LD_ADDR_VAR 0 11
27057: PUSH
27058: LD_VAR 0 4
27062: PPUSH
27063: LD_INT 2
27065: PPUSH
27066: CALL 86524 0 2
27070: PUSH
27071: LD_INT 1
27073: ARRAY
27074: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27075: LD_ADDR_VAR 0 2
27079: PUSH
27080: LD_VAR 0 2
27084: PPUSH
27085: LD_INT 2
27087: PPUSH
27088: LD_VAR 0 11
27092: PPUSH
27093: CALL_OW 1
27097: ST_TO_ADDR
// tmp := tmp diff p ;
27098: LD_ADDR_VAR 0 4
27102: PUSH
27103: LD_VAR 0 4
27107: PUSH
27108: LD_VAR 0 11
27112: DIFF
27113: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27114: LD_VAR 0 4
27118: PUSH
27119: LD_VAR 0 8
27123: PUSH
27124: LD_INT 6
27126: LESS
27127: AND
27128: IFFALSE 27316
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27130: LD_ADDR_VAR 0 9
27134: PUSH
27135: LD_VAR 0 4
27139: PUSH
27140: LD_VAR 0 8
27144: PUSH
27145: LD_VAR 0 7
27149: UNION
27150: DIFF
27151: PPUSH
27152: LD_INT 4
27154: PPUSH
27155: CALL 86524 0 2
27159: ST_TO_ADDR
// p := [ ] ;
27160: LD_ADDR_VAR 0 11
27164: PUSH
27165: EMPTY
27166: ST_TO_ADDR
// if sort then
27167: LD_VAR 0 9
27171: IFFALSE 27287
// for i = 1 to 6 - sci do
27173: LD_ADDR_VAR 0 3
27177: PUSH
27178: DOUBLE
27179: LD_INT 1
27181: DEC
27182: ST_TO_ADDR
27183: LD_INT 6
27185: PUSH
27186: LD_VAR 0 8
27190: MINUS
27191: PUSH
27192: FOR_TO
27193: IFFALSE 27285
// begin if i = sort then
27195: LD_VAR 0 3
27199: PUSH
27200: LD_VAR 0 9
27204: EQUAL
27205: IFFALSE 27209
// break ;
27207: GO 27285
// if GetClass ( i ) = 4 then
27209: LD_VAR 0 3
27213: PPUSH
27214: CALL_OW 257
27218: PUSH
27219: LD_INT 4
27221: EQUAL
27222: IFFALSE 27226
// continue ;
27224: GO 27192
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27226: LD_ADDR_VAR 0 11
27230: PUSH
27231: LD_VAR 0 11
27235: PPUSH
27236: LD_VAR 0 11
27240: PUSH
27241: LD_INT 1
27243: PLUS
27244: PPUSH
27245: LD_VAR 0 9
27249: PUSH
27250: LD_VAR 0 3
27254: ARRAY
27255: PPUSH
27256: CALL_OW 2
27260: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27261: LD_ADDR_VAR 0 4
27265: PUSH
27266: LD_VAR 0 4
27270: PUSH
27271: LD_VAR 0 9
27275: PUSH
27276: LD_VAR 0 3
27280: ARRAY
27281: DIFF
27282: ST_TO_ADDR
// end ;
27283: GO 27192
27285: POP
27286: POP
// if p then
27287: LD_VAR 0 11
27291: IFFALSE 27316
// result := Replace ( result , 4 , p ) ;
27293: LD_ADDR_VAR 0 2
27297: PUSH
27298: LD_VAR 0 2
27302: PPUSH
27303: LD_INT 4
27305: PPUSH
27306: LD_VAR 0 11
27310: PPUSH
27311: CALL_OW 1
27315: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27316: LD_VAR 0 4
27320: PUSH
27321: LD_VAR 0 7
27325: PUSH
27326: LD_INT 6
27328: LESS
27329: AND
27330: IFFALSE 27518
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27332: LD_ADDR_VAR 0 9
27336: PUSH
27337: LD_VAR 0 4
27341: PUSH
27342: LD_VAR 0 8
27346: PUSH
27347: LD_VAR 0 7
27351: UNION
27352: DIFF
27353: PPUSH
27354: LD_INT 3
27356: PPUSH
27357: CALL 86524 0 2
27361: ST_TO_ADDR
// p := [ ] ;
27362: LD_ADDR_VAR 0 11
27366: PUSH
27367: EMPTY
27368: ST_TO_ADDR
// if sort then
27369: LD_VAR 0 9
27373: IFFALSE 27489
// for i = 1 to 6 - mech do
27375: LD_ADDR_VAR 0 3
27379: PUSH
27380: DOUBLE
27381: LD_INT 1
27383: DEC
27384: ST_TO_ADDR
27385: LD_INT 6
27387: PUSH
27388: LD_VAR 0 7
27392: MINUS
27393: PUSH
27394: FOR_TO
27395: IFFALSE 27487
// begin if i = sort then
27397: LD_VAR 0 3
27401: PUSH
27402: LD_VAR 0 9
27406: EQUAL
27407: IFFALSE 27411
// break ;
27409: GO 27487
// if GetClass ( i ) = 3 then
27411: LD_VAR 0 3
27415: PPUSH
27416: CALL_OW 257
27420: PUSH
27421: LD_INT 3
27423: EQUAL
27424: IFFALSE 27428
// continue ;
27426: GO 27394
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27428: LD_ADDR_VAR 0 11
27432: PUSH
27433: LD_VAR 0 11
27437: PPUSH
27438: LD_VAR 0 11
27442: PUSH
27443: LD_INT 1
27445: PLUS
27446: PPUSH
27447: LD_VAR 0 9
27451: PUSH
27452: LD_VAR 0 3
27456: ARRAY
27457: PPUSH
27458: CALL_OW 2
27462: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27463: LD_ADDR_VAR 0 4
27467: PUSH
27468: LD_VAR 0 4
27472: PUSH
27473: LD_VAR 0 9
27477: PUSH
27478: LD_VAR 0 3
27482: ARRAY
27483: DIFF
27484: ST_TO_ADDR
// end ;
27485: GO 27394
27487: POP
27488: POP
// if p then
27489: LD_VAR 0 11
27493: IFFALSE 27518
// result := Replace ( result , 3 , p ) ;
27495: LD_ADDR_VAR 0 2
27499: PUSH
27500: LD_VAR 0 2
27504: PPUSH
27505: LD_INT 3
27507: PPUSH
27508: LD_VAR 0 11
27512: PPUSH
27513: CALL_OW 1
27517: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27518: LD_VAR 0 4
27522: PUSH
27523: LD_INT 6
27525: GREATER
27526: PUSH
27527: LD_VAR 0 6
27531: PUSH
27532: LD_INT 6
27534: LESS
27535: AND
27536: IFFALSE 27730
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27538: LD_ADDR_VAR 0 9
27542: PUSH
27543: LD_VAR 0 4
27547: PUSH
27548: LD_VAR 0 8
27552: PUSH
27553: LD_VAR 0 7
27557: UNION
27558: PUSH
27559: LD_VAR 0 6
27563: UNION
27564: DIFF
27565: PPUSH
27566: LD_INT 2
27568: PPUSH
27569: CALL 86524 0 2
27573: ST_TO_ADDR
// p := [ ] ;
27574: LD_ADDR_VAR 0 11
27578: PUSH
27579: EMPTY
27580: ST_TO_ADDR
// if sort then
27581: LD_VAR 0 9
27585: IFFALSE 27701
// for i = 1 to 6 - eng do
27587: LD_ADDR_VAR 0 3
27591: PUSH
27592: DOUBLE
27593: LD_INT 1
27595: DEC
27596: ST_TO_ADDR
27597: LD_INT 6
27599: PUSH
27600: LD_VAR 0 6
27604: MINUS
27605: PUSH
27606: FOR_TO
27607: IFFALSE 27699
// begin if i = sort then
27609: LD_VAR 0 3
27613: PUSH
27614: LD_VAR 0 9
27618: EQUAL
27619: IFFALSE 27623
// break ;
27621: GO 27699
// if GetClass ( i ) = 2 then
27623: LD_VAR 0 3
27627: PPUSH
27628: CALL_OW 257
27632: PUSH
27633: LD_INT 2
27635: EQUAL
27636: IFFALSE 27640
// continue ;
27638: GO 27606
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27640: LD_ADDR_VAR 0 11
27644: PUSH
27645: LD_VAR 0 11
27649: PPUSH
27650: LD_VAR 0 11
27654: PUSH
27655: LD_INT 1
27657: PLUS
27658: PPUSH
27659: LD_VAR 0 9
27663: PUSH
27664: LD_VAR 0 3
27668: ARRAY
27669: PPUSH
27670: CALL_OW 2
27674: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27675: LD_ADDR_VAR 0 4
27679: PUSH
27680: LD_VAR 0 4
27684: PUSH
27685: LD_VAR 0 9
27689: PUSH
27690: LD_VAR 0 3
27694: ARRAY
27695: DIFF
27696: ST_TO_ADDR
// end ;
27697: GO 27606
27699: POP
27700: POP
// if p then
27701: LD_VAR 0 11
27705: IFFALSE 27730
// result := Replace ( result , 2 , p ) ;
27707: LD_ADDR_VAR 0 2
27711: PUSH
27712: LD_VAR 0 2
27716: PPUSH
27717: LD_INT 2
27719: PPUSH
27720: LD_VAR 0 11
27724: PPUSH
27725: CALL_OW 1
27729: ST_TO_ADDR
// end ; exit ;
27730: GO 29118
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27732: LD_EXP 120
27736: PUSH
27737: LD_EXP 119
27741: PUSH
27742: LD_VAR 0 1
27746: ARRAY
27747: ARRAY
27748: NOT
27749: PUSH
27750: LD_EXP 93
27754: PUSH
27755: LD_VAR 0 1
27759: ARRAY
27760: PPUSH
27761: LD_INT 30
27763: PUSH
27764: LD_INT 3
27766: PUSH
27767: EMPTY
27768: LIST
27769: LIST
27770: PPUSH
27771: CALL_OW 72
27775: AND
27776: PUSH
27777: LD_EXP 98
27781: PUSH
27782: LD_VAR 0 1
27786: ARRAY
27787: AND
27788: IFFALSE 28396
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27790: LD_ADDR_EXP 135
27794: PUSH
27795: LD_EXP 135
27799: PPUSH
27800: LD_VAR 0 1
27804: PPUSH
27805: LD_INT 5
27807: PPUSH
27808: CALL_OW 1
27812: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27813: LD_ADDR_VAR 0 2
27817: PUSH
27818: LD_INT 0
27820: PUSH
27821: LD_INT 0
27823: PUSH
27824: LD_INT 0
27826: PUSH
27827: LD_INT 0
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: LIST
27834: LIST
27835: ST_TO_ADDR
// if sci > 1 then
27836: LD_VAR 0 8
27840: PUSH
27841: LD_INT 1
27843: GREATER
27844: IFFALSE 27872
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27846: LD_ADDR_VAR 0 4
27850: PUSH
27851: LD_VAR 0 4
27855: PUSH
27856: LD_VAR 0 8
27860: PUSH
27861: LD_VAR 0 8
27865: PUSH
27866: LD_INT 1
27868: ARRAY
27869: DIFF
27870: DIFF
27871: ST_TO_ADDR
// if tmp and not sci then
27872: LD_VAR 0 4
27876: PUSH
27877: LD_VAR 0 8
27881: NOT
27882: AND
27883: IFFALSE 27952
// begin sort := SortBySkill ( tmp , 4 ) ;
27885: LD_ADDR_VAR 0 9
27889: PUSH
27890: LD_VAR 0 4
27894: PPUSH
27895: LD_INT 4
27897: PPUSH
27898: CALL 86524 0 2
27902: ST_TO_ADDR
// if sort then
27903: LD_VAR 0 9
27907: IFFALSE 27923
// p := sort [ 1 ] ;
27909: LD_ADDR_VAR 0 11
27913: PUSH
27914: LD_VAR 0 9
27918: PUSH
27919: LD_INT 1
27921: ARRAY
27922: ST_TO_ADDR
// if p then
27923: LD_VAR 0 11
27927: IFFALSE 27952
// result := Replace ( result , 4 , p ) ;
27929: LD_ADDR_VAR 0 2
27933: PUSH
27934: LD_VAR 0 2
27938: PPUSH
27939: LD_INT 4
27941: PPUSH
27942: LD_VAR 0 11
27946: PPUSH
27947: CALL_OW 1
27951: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27952: LD_ADDR_VAR 0 4
27956: PUSH
27957: LD_VAR 0 4
27961: PUSH
27962: LD_VAR 0 7
27966: DIFF
27967: ST_TO_ADDR
// if tmp and mech < 6 then
27968: LD_VAR 0 4
27972: PUSH
27973: LD_VAR 0 7
27977: PUSH
27978: LD_INT 6
27980: LESS
27981: AND
27982: IFFALSE 28170
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27984: LD_ADDR_VAR 0 9
27988: PUSH
27989: LD_VAR 0 4
27993: PUSH
27994: LD_VAR 0 8
27998: PUSH
27999: LD_VAR 0 7
28003: UNION
28004: DIFF
28005: PPUSH
28006: LD_INT 3
28008: PPUSH
28009: CALL 86524 0 2
28013: ST_TO_ADDR
// p := [ ] ;
28014: LD_ADDR_VAR 0 11
28018: PUSH
28019: EMPTY
28020: ST_TO_ADDR
// if sort then
28021: LD_VAR 0 9
28025: IFFALSE 28141
// for i = 1 to 6 - mech do
28027: LD_ADDR_VAR 0 3
28031: PUSH
28032: DOUBLE
28033: LD_INT 1
28035: DEC
28036: ST_TO_ADDR
28037: LD_INT 6
28039: PUSH
28040: LD_VAR 0 7
28044: MINUS
28045: PUSH
28046: FOR_TO
28047: IFFALSE 28139
// begin if i = sort then
28049: LD_VAR 0 3
28053: PUSH
28054: LD_VAR 0 9
28058: EQUAL
28059: IFFALSE 28063
// break ;
28061: GO 28139
// if GetClass ( i ) = 3 then
28063: LD_VAR 0 3
28067: PPUSH
28068: CALL_OW 257
28072: PUSH
28073: LD_INT 3
28075: EQUAL
28076: IFFALSE 28080
// continue ;
28078: GO 28046
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28080: LD_ADDR_VAR 0 11
28084: PUSH
28085: LD_VAR 0 11
28089: PPUSH
28090: LD_VAR 0 11
28094: PUSH
28095: LD_INT 1
28097: PLUS
28098: PPUSH
28099: LD_VAR 0 9
28103: PUSH
28104: LD_VAR 0 3
28108: ARRAY
28109: PPUSH
28110: CALL_OW 2
28114: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28115: LD_ADDR_VAR 0 4
28119: PUSH
28120: LD_VAR 0 4
28124: PUSH
28125: LD_VAR 0 9
28129: PUSH
28130: LD_VAR 0 3
28134: ARRAY
28135: DIFF
28136: ST_TO_ADDR
// end ;
28137: GO 28046
28139: POP
28140: POP
// if p then
28141: LD_VAR 0 11
28145: IFFALSE 28170
// result := Replace ( result , 3 , p ) ;
28147: LD_ADDR_VAR 0 2
28151: PUSH
28152: LD_VAR 0 2
28156: PPUSH
28157: LD_INT 3
28159: PPUSH
28160: LD_VAR 0 11
28164: PPUSH
28165: CALL_OW 1
28169: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28170: LD_ADDR_VAR 0 4
28174: PUSH
28175: LD_VAR 0 4
28179: PUSH
28180: LD_VAR 0 6
28184: DIFF
28185: ST_TO_ADDR
// if tmp and eng < 6 then
28186: LD_VAR 0 4
28190: PUSH
28191: LD_VAR 0 6
28195: PUSH
28196: LD_INT 6
28198: LESS
28199: AND
28200: IFFALSE 28394
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28202: LD_ADDR_VAR 0 9
28206: PUSH
28207: LD_VAR 0 4
28211: PUSH
28212: LD_VAR 0 8
28216: PUSH
28217: LD_VAR 0 7
28221: UNION
28222: PUSH
28223: LD_VAR 0 6
28227: UNION
28228: DIFF
28229: PPUSH
28230: LD_INT 2
28232: PPUSH
28233: CALL 86524 0 2
28237: ST_TO_ADDR
// p := [ ] ;
28238: LD_ADDR_VAR 0 11
28242: PUSH
28243: EMPTY
28244: ST_TO_ADDR
// if sort then
28245: LD_VAR 0 9
28249: IFFALSE 28365
// for i = 1 to 6 - eng do
28251: LD_ADDR_VAR 0 3
28255: PUSH
28256: DOUBLE
28257: LD_INT 1
28259: DEC
28260: ST_TO_ADDR
28261: LD_INT 6
28263: PUSH
28264: LD_VAR 0 6
28268: MINUS
28269: PUSH
28270: FOR_TO
28271: IFFALSE 28363
// begin if i = sort then
28273: LD_VAR 0 3
28277: PUSH
28278: LD_VAR 0 9
28282: EQUAL
28283: IFFALSE 28287
// break ;
28285: GO 28363
// if GetClass ( i ) = 2 then
28287: LD_VAR 0 3
28291: PPUSH
28292: CALL_OW 257
28296: PUSH
28297: LD_INT 2
28299: EQUAL
28300: IFFALSE 28304
// continue ;
28302: GO 28270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28304: LD_ADDR_VAR 0 11
28308: PUSH
28309: LD_VAR 0 11
28313: PPUSH
28314: LD_VAR 0 11
28318: PUSH
28319: LD_INT 1
28321: PLUS
28322: PPUSH
28323: LD_VAR 0 9
28327: PUSH
28328: LD_VAR 0 3
28332: ARRAY
28333: PPUSH
28334: CALL_OW 2
28338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28339: LD_ADDR_VAR 0 4
28343: PUSH
28344: LD_VAR 0 4
28348: PUSH
28349: LD_VAR 0 9
28353: PUSH
28354: LD_VAR 0 3
28358: ARRAY
28359: DIFF
28360: ST_TO_ADDR
// end ;
28361: GO 28270
28363: POP
28364: POP
// if p then
28365: LD_VAR 0 11
28369: IFFALSE 28394
// result := Replace ( result , 2 , p ) ;
28371: LD_ADDR_VAR 0 2
28375: PUSH
28376: LD_VAR 0 2
28380: PPUSH
28381: LD_INT 2
28383: PPUSH
28384: LD_VAR 0 11
28388: PPUSH
28389: CALL_OW 1
28393: ST_TO_ADDR
// end ; exit ;
28394: GO 29118
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28396: LD_EXP 120
28400: PUSH
28401: LD_EXP 119
28405: PUSH
28406: LD_VAR 0 1
28410: ARRAY
28411: ARRAY
28412: NOT
28413: PUSH
28414: LD_EXP 93
28418: PUSH
28419: LD_VAR 0 1
28423: ARRAY
28424: PPUSH
28425: LD_INT 30
28427: PUSH
28428: LD_INT 3
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PPUSH
28435: CALL_OW 72
28439: AND
28440: PUSH
28441: LD_EXP 98
28445: PUSH
28446: LD_VAR 0 1
28450: ARRAY
28451: NOT
28452: AND
28453: IFFALSE 29118
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28455: LD_ADDR_EXP 135
28459: PUSH
28460: LD_EXP 135
28464: PPUSH
28465: LD_VAR 0 1
28469: PPUSH
28470: LD_INT 6
28472: PPUSH
28473: CALL_OW 1
28477: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28478: LD_ADDR_VAR 0 2
28482: PUSH
28483: LD_INT 0
28485: PUSH
28486: LD_INT 0
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: LD_INT 0
28494: PUSH
28495: EMPTY
28496: LIST
28497: LIST
28498: LIST
28499: LIST
28500: ST_TO_ADDR
// if sci >= 1 then
28501: LD_VAR 0 8
28505: PUSH
28506: LD_INT 1
28508: GREATEREQUAL
28509: IFFALSE 28531
// tmp := tmp diff sci [ 1 ] ;
28511: LD_ADDR_VAR 0 4
28515: PUSH
28516: LD_VAR 0 4
28520: PUSH
28521: LD_VAR 0 8
28525: PUSH
28526: LD_INT 1
28528: ARRAY
28529: DIFF
28530: ST_TO_ADDR
// if tmp and not sci then
28531: LD_VAR 0 4
28535: PUSH
28536: LD_VAR 0 8
28540: NOT
28541: AND
28542: IFFALSE 28611
// begin sort := SortBySkill ( tmp , 4 ) ;
28544: LD_ADDR_VAR 0 9
28548: PUSH
28549: LD_VAR 0 4
28553: PPUSH
28554: LD_INT 4
28556: PPUSH
28557: CALL 86524 0 2
28561: ST_TO_ADDR
// if sort then
28562: LD_VAR 0 9
28566: IFFALSE 28582
// p := sort [ 1 ] ;
28568: LD_ADDR_VAR 0 11
28572: PUSH
28573: LD_VAR 0 9
28577: PUSH
28578: LD_INT 1
28580: ARRAY
28581: ST_TO_ADDR
// if p then
28582: LD_VAR 0 11
28586: IFFALSE 28611
// result := Replace ( result , 4 , p ) ;
28588: LD_ADDR_VAR 0 2
28592: PUSH
28593: LD_VAR 0 2
28597: PPUSH
28598: LD_INT 4
28600: PPUSH
28601: LD_VAR 0 11
28605: PPUSH
28606: CALL_OW 1
28610: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28611: LD_ADDR_VAR 0 4
28615: PUSH
28616: LD_VAR 0 4
28620: PUSH
28621: LD_VAR 0 7
28625: DIFF
28626: ST_TO_ADDR
// if tmp and mech < 6 then
28627: LD_VAR 0 4
28631: PUSH
28632: LD_VAR 0 7
28636: PUSH
28637: LD_INT 6
28639: LESS
28640: AND
28641: IFFALSE 28823
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28643: LD_ADDR_VAR 0 9
28647: PUSH
28648: LD_VAR 0 4
28652: PUSH
28653: LD_VAR 0 7
28657: DIFF
28658: PPUSH
28659: LD_INT 3
28661: PPUSH
28662: CALL 86524 0 2
28666: ST_TO_ADDR
// p := [ ] ;
28667: LD_ADDR_VAR 0 11
28671: PUSH
28672: EMPTY
28673: ST_TO_ADDR
// if sort then
28674: LD_VAR 0 9
28678: IFFALSE 28794
// for i = 1 to 6 - mech do
28680: LD_ADDR_VAR 0 3
28684: PUSH
28685: DOUBLE
28686: LD_INT 1
28688: DEC
28689: ST_TO_ADDR
28690: LD_INT 6
28692: PUSH
28693: LD_VAR 0 7
28697: MINUS
28698: PUSH
28699: FOR_TO
28700: IFFALSE 28792
// begin if i = sort then
28702: LD_VAR 0 3
28706: PUSH
28707: LD_VAR 0 9
28711: EQUAL
28712: IFFALSE 28716
// break ;
28714: GO 28792
// if GetClass ( i ) = 3 then
28716: LD_VAR 0 3
28720: PPUSH
28721: CALL_OW 257
28725: PUSH
28726: LD_INT 3
28728: EQUAL
28729: IFFALSE 28733
// continue ;
28731: GO 28699
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28733: LD_ADDR_VAR 0 11
28737: PUSH
28738: LD_VAR 0 11
28742: PPUSH
28743: LD_VAR 0 11
28747: PUSH
28748: LD_INT 1
28750: PLUS
28751: PPUSH
28752: LD_VAR 0 9
28756: PUSH
28757: LD_VAR 0 3
28761: ARRAY
28762: PPUSH
28763: CALL_OW 2
28767: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28768: LD_ADDR_VAR 0 4
28772: PUSH
28773: LD_VAR 0 4
28777: PUSH
28778: LD_VAR 0 9
28782: PUSH
28783: LD_VAR 0 3
28787: ARRAY
28788: DIFF
28789: ST_TO_ADDR
// end ;
28790: GO 28699
28792: POP
28793: POP
// if p then
28794: LD_VAR 0 11
28798: IFFALSE 28823
// result := Replace ( result , 3 , p ) ;
28800: LD_ADDR_VAR 0 2
28804: PUSH
28805: LD_VAR 0 2
28809: PPUSH
28810: LD_INT 3
28812: PPUSH
28813: LD_VAR 0 11
28817: PPUSH
28818: CALL_OW 1
28822: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28823: LD_ADDR_VAR 0 4
28827: PUSH
28828: LD_VAR 0 4
28832: PUSH
28833: LD_VAR 0 6
28837: DIFF
28838: ST_TO_ADDR
// if tmp and eng < 4 then
28839: LD_VAR 0 4
28843: PUSH
28844: LD_VAR 0 6
28848: PUSH
28849: LD_INT 4
28851: LESS
28852: AND
28853: IFFALSE 29043
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28855: LD_ADDR_VAR 0 9
28859: PUSH
28860: LD_VAR 0 4
28864: PUSH
28865: LD_VAR 0 7
28869: PUSH
28870: LD_VAR 0 6
28874: UNION
28875: DIFF
28876: PPUSH
28877: LD_INT 2
28879: PPUSH
28880: CALL 86524 0 2
28884: ST_TO_ADDR
// p := [ ] ;
28885: LD_ADDR_VAR 0 11
28889: PUSH
28890: EMPTY
28891: ST_TO_ADDR
// if sort then
28892: LD_VAR 0 9
28896: IFFALSE 29012
// for i = 1 to 4 - eng do
28898: LD_ADDR_VAR 0 3
28902: PUSH
28903: DOUBLE
28904: LD_INT 1
28906: DEC
28907: ST_TO_ADDR
28908: LD_INT 4
28910: PUSH
28911: LD_VAR 0 6
28915: MINUS
28916: PUSH
28917: FOR_TO
28918: IFFALSE 29010
// begin if i = sort then
28920: LD_VAR 0 3
28924: PUSH
28925: LD_VAR 0 9
28929: EQUAL
28930: IFFALSE 28934
// break ;
28932: GO 29010
// if GetClass ( i ) = 2 then
28934: LD_VAR 0 3
28938: PPUSH
28939: CALL_OW 257
28943: PUSH
28944: LD_INT 2
28946: EQUAL
28947: IFFALSE 28951
// continue ;
28949: GO 28917
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28951: LD_ADDR_VAR 0 11
28955: PUSH
28956: LD_VAR 0 11
28960: PPUSH
28961: LD_VAR 0 11
28965: PUSH
28966: LD_INT 1
28968: PLUS
28969: PPUSH
28970: LD_VAR 0 9
28974: PUSH
28975: LD_VAR 0 3
28979: ARRAY
28980: PPUSH
28981: CALL_OW 2
28985: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28986: LD_ADDR_VAR 0 4
28990: PUSH
28991: LD_VAR 0 4
28995: PUSH
28996: LD_VAR 0 9
29000: PUSH
29001: LD_VAR 0 3
29005: ARRAY
29006: DIFF
29007: ST_TO_ADDR
// end ;
29008: GO 28917
29010: POP
29011: POP
// if p then
29012: LD_VAR 0 11
29016: IFFALSE 29041
// result := Replace ( result , 2 , p ) ;
29018: LD_ADDR_VAR 0 2
29022: PUSH
29023: LD_VAR 0 2
29027: PPUSH
29028: LD_INT 2
29030: PPUSH
29031: LD_VAR 0 11
29035: PPUSH
29036: CALL_OW 1
29040: ST_TO_ADDR
// end else
29041: GO 29087
// for i = eng downto 5 do
29043: LD_ADDR_VAR 0 3
29047: PUSH
29048: DOUBLE
29049: LD_VAR 0 6
29053: INC
29054: ST_TO_ADDR
29055: LD_INT 5
29057: PUSH
29058: FOR_DOWNTO
29059: IFFALSE 29085
// tmp := tmp union eng [ i ] ;
29061: LD_ADDR_VAR 0 4
29065: PUSH
29066: LD_VAR 0 4
29070: PUSH
29071: LD_VAR 0 6
29075: PUSH
29076: LD_VAR 0 3
29080: ARRAY
29081: UNION
29082: ST_TO_ADDR
29083: GO 29058
29085: POP
29086: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29087: LD_ADDR_VAR 0 2
29091: PUSH
29092: LD_VAR 0 2
29096: PPUSH
29097: LD_INT 1
29099: PPUSH
29100: LD_VAR 0 4
29104: PUSH
29105: LD_VAR 0 5
29109: DIFF
29110: PPUSH
29111: CALL_OW 1
29115: ST_TO_ADDR
// exit ;
29116: GO 29118
// end ; end ;
29118: LD_VAR 0 2
29122: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29123: LD_INT 0
29125: PPUSH
29126: PPUSH
29127: PPUSH
// if not mc_bases then
29128: LD_EXP 93
29132: NOT
29133: IFFALSE 29137
// exit ;
29135: GO 29279
// for i = 1 to mc_bases do
29137: LD_ADDR_VAR 0 2
29141: PUSH
29142: DOUBLE
29143: LD_INT 1
29145: DEC
29146: ST_TO_ADDR
29147: LD_EXP 93
29151: PUSH
29152: FOR_TO
29153: IFFALSE 29270
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29155: LD_ADDR_VAR 0 3
29159: PUSH
29160: LD_EXP 93
29164: PUSH
29165: LD_VAR 0 2
29169: ARRAY
29170: PPUSH
29171: LD_INT 21
29173: PUSH
29174: LD_INT 3
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 3
29183: PUSH
29184: LD_INT 2
29186: PUSH
29187: LD_INT 30
29189: PUSH
29190: LD_INT 29
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: LD_INT 30
29199: PUSH
29200: LD_INT 30
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: LIST
29211: PUSH
29212: EMPTY
29213: LIST
29214: LIST
29215: PUSH
29216: LD_INT 3
29218: PUSH
29219: LD_INT 24
29221: PUSH
29222: LD_INT 1000
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: LIST
29237: PPUSH
29238: CALL_OW 72
29242: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29243: LD_ADDR_EXP 94
29247: PUSH
29248: LD_EXP 94
29252: PPUSH
29253: LD_VAR 0 2
29257: PPUSH
29258: LD_VAR 0 3
29262: PPUSH
29263: CALL_OW 1
29267: ST_TO_ADDR
// end ;
29268: GO 29152
29270: POP
29271: POP
// RaiseSailEvent ( 101 ) ;
29272: LD_INT 101
29274: PPUSH
29275: CALL_OW 427
// end ;
29279: LD_VAR 0 1
29283: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29284: LD_INT 0
29286: PPUSH
29287: PPUSH
29288: PPUSH
29289: PPUSH
29290: PPUSH
29291: PPUSH
29292: PPUSH
// if not mc_bases then
29293: LD_EXP 93
29297: NOT
29298: IFFALSE 29302
// exit ;
29300: GO 29864
// for i = 1 to mc_bases do
29302: LD_ADDR_VAR 0 2
29306: PUSH
29307: DOUBLE
29308: LD_INT 1
29310: DEC
29311: ST_TO_ADDR
29312: LD_EXP 93
29316: PUSH
29317: FOR_TO
29318: IFFALSE 29855
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29320: LD_ADDR_VAR 0 5
29324: PUSH
29325: LD_EXP 93
29329: PUSH
29330: LD_VAR 0 2
29334: ARRAY
29335: PUSH
29336: LD_EXP 122
29340: PUSH
29341: LD_VAR 0 2
29345: ARRAY
29346: UNION
29347: PPUSH
29348: LD_INT 21
29350: PUSH
29351: LD_INT 1
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 1
29360: PUSH
29361: LD_INT 3
29363: PUSH
29364: LD_INT 54
29366: PUSH
29367: EMPTY
29368: LIST
29369: PUSH
29370: EMPTY
29371: LIST
29372: LIST
29373: PUSH
29374: LD_INT 3
29376: PUSH
29377: LD_INT 24
29379: PUSH
29380: LD_INT 1000
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: LIST
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PPUSH
29400: CALL_OW 72
29404: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29405: LD_ADDR_VAR 0 6
29409: PUSH
29410: LD_EXP 93
29414: PUSH
29415: LD_VAR 0 2
29419: ARRAY
29420: PPUSH
29421: LD_INT 21
29423: PUSH
29424: LD_INT 1
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 1
29433: PUSH
29434: LD_INT 3
29436: PUSH
29437: LD_INT 54
29439: PUSH
29440: EMPTY
29441: LIST
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: LD_INT 3
29449: PUSH
29450: LD_INT 24
29452: PUSH
29453: LD_INT 250
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: LIST
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: PPUSH
29473: CALL_OW 72
29477: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29478: LD_ADDR_VAR 0 7
29482: PUSH
29483: LD_VAR 0 5
29487: PUSH
29488: LD_VAR 0 6
29492: DIFF
29493: ST_TO_ADDR
// if not need_heal_1 then
29494: LD_VAR 0 6
29498: NOT
29499: IFFALSE 29532
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29501: LD_ADDR_EXP 96
29505: PUSH
29506: LD_EXP 96
29510: PPUSH
29511: LD_VAR 0 2
29515: PUSH
29516: LD_INT 1
29518: PUSH
29519: EMPTY
29520: LIST
29521: LIST
29522: PPUSH
29523: EMPTY
29524: PPUSH
29525: CALL 56267 0 3
29529: ST_TO_ADDR
29530: GO 29602
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29532: LD_ADDR_EXP 96
29536: PUSH
29537: LD_EXP 96
29541: PPUSH
29542: LD_VAR 0 2
29546: PUSH
29547: LD_INT 1
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PPUSH
29554: LD_EXP 96
29558: PUSH
29559: LD_VAR 0 2
29563: ARRAY
29564: PUSH
29565: LD_INT 1
29567: ARRAY
29568: PPUSH
29569: LD_INT 3
29571: PUSH
29572: LD_INT 24
29574: PUSH
29575: LD_INT 1000
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PPUSH
29586: CALL_OW 72
29590: PUSH
29591: LD_VAR 0 6
29595: UNION
29596: PPUSH
29597: CALL 56267 0 3
29601: ST_TO_ADDR
// if not need_heal_2 then
29602: LD_VAR 0 7
29606: NOT
29607: IFFALSE 29640
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29609: LD_ADDR_EXP 96
29613: PUSH
29614: LD_EXP 96
29618: PPUSH
29619: LD_VAR 0 2
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PPUSH
29631: EMPTY
29632: PPUSH
29633: CALL 56267 0 3
29637: ST_TO_ADDR
29638: GO 29672
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29640: LD_ADDR_EXP 96
29644: PUSH
29645: LD_EXP 96
29649: PPUSH
29650: LD_VAR 0 2
29654: PUSH
29655: LD_INT 2
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PPUSH
29662: LD_VAR 0 7
29666: PPUSH
29667: CALL 56267 0 3
29671: ST_TO_ADDR
// if need_heal_2 then
29672: LD_VAR 0 7
29676: IFFALSE 29837
// for j in need_heal_2 do
29678: LD_ADDR_VAR 0 3
29682: PUSH
29683: LD_VAR 0 7
29687: PUSH
29688: FOR_IN
29689: IFFALSE 29835
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29691: LD_ADDR_VAR 0 5
29695: PUSH
29696: LD_EXP 93
29700: PUSH
29701: LD_VAR 0 2
29705: ARRAY
29706: PPUSH
29707: LD_INT 2
29709: PUSH
29710: LD_INT 30
29712: PUSH
29713: LD_INT 6
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: LD_INT 30
29722: PUSH
29723: LD_INT 7
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 30
29732: PUSH
29733: LD_INT 8
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 30
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 30
29752: PUSH
29753: LD_INT 1
29755: PUSH
29756: EMPTY
29757: LIST
29758: LIST
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: LIST
29764: LIST
29765: LIST
29766: LIST
29767: PPUSH
29768: CALL_OW 72
29772: ST_TO_ADDR
// if tmp then
29773: LD_VAR 0 5
29777: IFFALSE 29833
// begin k := NearestUnitToUnit ( tmp , j ) ;
29779: LD_ADDR_VAR 0 4
29783: PUSH
29784: LD_VAR 0 5
29788: PPUSH
29789: LD_VAR 0 3
29793: PPUSH
29794: CALL_OW 74
29798: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
29799: LD_VAR 0 3
29803: PPUSH
29804: LD_VAR 0 4
29808: PPUSH
29809: CALL_OW 296
29813: PUSH
29814: LD_INT 5
29816: GREATER
29817: IFFALSE 29833
// ComMoveToNearbyEntrance ( j , k ) ;
29819: LD_VAR 0 3
29823: PPUSH
29824: LD_VAR 0 4
29828: PPUSH
29829: CALL 88885 0 2
// end ; end ;
29833: GO 29688
29835: POP
29836: POP
// if not need_heal_1 and not need_heal_2 then
29837: LD_VAR 0 6
29841: NOT
29842: PUSH
29843: LD_VAR 0 7
29847: NOT
29848: AND
29849: IFFALSE 29853
// continue ;
29851: GO 29317
// end ;
29853: GO 29317
29855: POP
29856: POP
// RaiseSailEvent ( 102 ) ;
29857: LD_INT 102
29859: PPUSH
29860: CALL_OW 427
// end ;
29864: LD_VAR 0 1
29868: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29869: LD_INT 0
29871: PPUSH
29872: PPUSH
29873: PPUSH
29874: PPUSH
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
// if not mc_bases then
29879: LD_EXP 93
29883: NOT
29884: IFFALSE 29888
// exit ;
29886: GO 30771
// for i = 1 to mc_bases do
29888: LD_ADDR_VAR 0 2
29892: PUSH
29893: DOUBLE
29894: LD_INT 1
29896: DEC
29897: ST_TO_ADDR
29898: LD_EXP 93
29902: PUSH
29903: FOR_TO
29904: IFFALSE 30769
// begin if not mc_building_need_repair [ i ] then
29906: LD_EXP 94
29910: PUSH
29911: LD_VAR 0 2
29915: ARRAY
29916: NOT
29917: IFFALSE 30104
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
29919: LD_ADDR_VAR 0 6
29923: PUSH
29924: LD_EXP 112
29928: PUSH
29929: LD_VAR 0 2
29933: ARRAY
29934: PPUSH
29935: LD_INT 3
29937: PUSH
29938: LD_INT 24
29940: PUSH
29941: LD_INT 1000
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 2
29954: PUSH
29955: LD_INT 34
29957: PUSH
29958: LD_INT 13
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 34
29967: PUSH
29968: LD_INT 52
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 34
29977: PUSH
29978: LD_EXP 78
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: EMPTY
29988: LIST
29989: LIST
29990: LIST
29991: LIST
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PPUSH
29997: CALL_OW 72
30001: ST_TO_ADDR
// if cranes then
30002: LD_VAR 0 6
30006: IFFALSE 30068
// for j in cranes do
30008: LD_ADDR_VAR 0 3
30012: PUSH
30013: LD_VAR 0 6
30017: PUSH
30018: FOR_IN
30019: IFFALSE 30066
// if not IsInArea ( j , mc_parking [ i ] ) then
30021: LD_VAR 0 3
30025: PPUSH
30026: LD_EXP 117
30030: PUSH
30031: LD_VAR 0 2
30035: ARRAY
30036: PPUSH
30037: CALL_OW 308
30041: NOT
30042: IFFALSE 30064
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30044: LD_VAR 0 3
30048: PPUSH
30049: LD_EXP 117
30053: PUSH
30054: LD_VAR 0 2
30058: ARRAY
30059: PPUSH
30060: CALL_OW 113
30064: GO 30018
30066: POP
30067: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30068: LD_ADDR_EXP 95
30072: PUSH
30073: LD_EXP 95
30077: PPUSH
30078: LD_VAR 0 2
30082: PPUSH
30083: EMPTY
30084: PPUSH
30085: CALL_OW 1
30089: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30090: LD_VAR 0 2
30094: PPUSH
30095: LD_INT 101
30097: PPUSH
30098: CALL 24956 0 2
// continue ;
30102: GO 29903
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30104: LD_ADDR_EXP 99
30108: PUSH
30109: LD_EXP 99
30113: PPUSH
30114: LD_VAR 0 2
30118: PPUSH
30119: EMPTY
30120: PPUSH
30121: CALL_OW 1
30125: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30126: LD_VAR 0 2
30130: PPUSH
30131: LD_INT 103
30133: PPUSH
30134: CALL 24956 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30138: LD_ADDR_VAR 0 5
30142: PUSH
30143: LD_EXP 93
30147: PUSH
30148: LD_VAR 0 2
30152: ARRAY
30153: PUSH
30154: LD_EXP 122
30158: PUSH
30159: LD_VAR 0 2
30163: ARRAY
30164: UNION
30165: PPUSH
30166: LD_INT 2
30168: PUSH
30169: LD_INT 25
30171: PUSH
30172: LD_INT 2
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 25
30181: PUSH
30182: LD_INT 16
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: LIST
30193: PUSH
30194: EMPTY
30195: LIST
30196: PPUSH
30197: CALL_OW 72
30201: ST_TO_ADDR
// if mc_need_heal [ i ] then
30202: LD_EXP 96
30206: PUSH
30207: LD_VAR 0 2
30211: ARRAY
30212: IFFALSE 30256
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30214: LD_ADDR_VAR 0 5
30218: PUSH
30219: LD_VAR 0 5
30223: PUSH
30224: LD_EXP 96
30228: PUSH
30229: LD_VAR 0 2
30233: ARRAY
30234: PUSH
30235: LD_INT 1
30237: ARRAY
30238: PUSH
30239: LD_EXP 96
30243: PUSH
30244: LD_VAR 0 2
30248: ARRAY
30249: PUSH
30250: LD_INT 2
30252: ARRAY
30253: UNION
30254: DIFF
30255: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30256: LD_ADDR_VAR 0 6
30260: PUSH
30261: LD_EXP 112
30265: PUSH
30266: LD_VAR 0 2
30270: ARRAY
30271: PPUSH
30272: LD_INT 2
30274: PUSH
30275: LD_INT 34
30277: PUSH
30278: LD_INT 13
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 34
30287: PUSH
30288: LD_INT 52
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 34
30297: PUSH
30298: LD_EXP 78
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: PPUSH
30313: CALL_OW 72
30317: ST_TO_ADDR
// if cranes then
30318: LD_VAR 0 6
30322: IFFALSE 30458
// begin for j in cranes do
30324: LD_ADDR_VAR 0 3
30328: PUSH
30329: LD_VAR 0 6
30333: PUSH
30334: FOR_IN
30335: IFFALSE 30456
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30337: LD_VAR 0 3
30341: PPUSH
30342: CALL_OW 256
30346: PUSH
30347: LD_INT 1000
30349: EQUAL
30350: PUSH
30351: LD_VAR 0 3
30355: PPUSH
30356: CALL_OW 314
30360: NOT
30361: AND
30362: IFFALSE 30396
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30364: LD_VAR 0 3
30368: PPUSH
30369: LD_EXP 94
30373: PUSH
30374: LD_VAR 0 2
30378: ARRAY
30379: PPUSH
30380: LD_VAR 0 3
30384: PPUSH
30385: CALL_OW 74
30389: PPUSH
30390: CALL_OW 130
30394: GO 30454
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30396: LD_VAR 0 3
30400: PPUSH
30401: CALL_OW 256
30405: PUSH
30406: LD_INT 500
30408: LESS
30409: PUSH
30410: LD_VAR 0 3
30414: PPUSH
30415: LD_EXP 117
30419: PUSH
30420: LD_VAR 0 2
30424: ARRAY
30425: PPUSH
30426: CALL_OW 308
30430: NOT
30431: AND
30432: IFFALSE 30454
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30434: LD_VAR 0 3
30438: PPUSH
30439: LD_EXP 117
30443: PUSH
30444: LD_VAR 0 2
30448: ARRAY
30449: PPUSH
30450: CALL_OW 113
// end ;
30454: GO 30334
30456: POP
30457: POP
// end ; if tmp > 3 then
30458: LD_VAR 0 5
30462: PUSH
30463: LD_INT 3
30465: GREATER
30466: IFFALSE 30486
// tmp := ShrinkArray ( tmp , 4 ) ;
30468: LD_ADDR_VAR 0 5
30472: PUSH
30473: LD_VAR 0 5
30477: PPUSH
30478: LD_INT 4
30480: PPUSH
30481: CALL 88333 0 2
30485: ST_TO_ADDR
// if not tmp then
30486: LD_VAR 0 5
30490: NOT
30491: IFFALSE 30495
// continue ;
30493: GO 29903
// for j in tmp do
30495: LD_ADDR_VAR 0 3
30499: PUSH
30500: LD_VAR 0 5
30504: PUSH
30505: FOR_IN
30506: IFFALSE 30765
// begin if IsInUnit ( j ) then
30508: LD_VAR 0 3
30512: PPUSH
30513: CALL_OW 310
30517: IFFALSE 30528
// ComExitBuilding ( j ) ;
30519: LD_VAR 0 3
30523: PPUSH
30524: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30528: LD_VAR 0 3
30532: PUSH
30533: LD_EXP 95
30537: PUSH
30538: LD_VAR 0 2
30542: ARRAY
30543: IN
30544: NOT
30545: IFFALSE 30603
// begin SetTag ( j , 101 ) ;
30547: LD_VAR 0 3
30551: PPUSH
30552: LD_INT 101
30554: PPUSH
30555: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30559: LD_ADDR_EXP 95
30563: PUSH
30564: LD_EXP 95
30568: PPUSH
30569: LD_VAR 0 2
30573: PUSH
30574: LD_EXP 95
30578: PUSH
30579: LD_VAR 0 2
30583: ARRAY
30584: PUSH
30585: LD_INT 1
30587: PLUS
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PPUSH
30593: LD_VAR 0 3
30597: PPUSH
30598: CALL 56267 0 3
30602: ST_TO_ADDR
// end ; wait ( 1 ) ;
30603: LD_INT 1
30605: PPUSH
30606: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30610: LD_ADDR_VAR 0 7
30614: PUSH
30615: LD_EXP 94
30619: PUSH
30620: LD_VAR 0 2
30624: ARRAY
30625: ST_TO_ADDR
// if mc_scan [ i ] then
30626: LD_EXP 116
30630: PUSH
30631: LD_VAR 0 2
30635: ARRAY
30636: IFFALSE 30698
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
30638: LD_ADDR_VAR 0 7
30642: PUSH
30643: LD_EXP 94
30647: PUSH
30648: LD_VAR 0 2
30652: ARRAY
30653: PPUSH
30654: LD_INT 3
30656: PUSH
30657: LD_INT 30
30659: PUSH
30660: LD_INT 32
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 30
30669: PUSH
30670: LD_INT 33
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: LD_INT 30
30679: PUSH
30680: LD_INT 31
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: PPUSH
30693: CALL_OW 72
30697: ST_TO_ADDR
// if not to_repair_tmp then
30698: LD_VAR 0 7
30702: NOT
30703: IFFALSE 30707
// continue ;
30705: GO 30505
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30707: LD_ADDR_VAR 0 8
30711: PUSH
30712: LD_VAR 0 7
30716: PPUSH
30717: LD_VAR 0 3
30721: PPUSH
30722: CALL_OW 74
30726: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30727: LD_VAR 0 8
30731: PPUSH
30732: LD_INT 16
30734: PPUSH
30735: CALL 58866 0 2
30739: PUSH
30740: LD_INT 4
30742: ARRAY
30743: PUSH
30744: LD_INT 10
30746: LESS
30747: IFFALSE 30763
// ComRepairBuilding ( j , to_repair ) ;
30749: LD_VAR 0 3
30753: PPUSH
30754: LD_VAR 0 8
30758: PPUSH
30759: CALL_OW 130
// end ;
30763: GO 30505
30765: POP
30766: POP
// end ;
30767: GO 29903
30769: POP
30770: POP
// end ;
30771: LD_VAR 0 1
30775: RET
// export function MC_Heal ; var i , j , tmp ; begin
30776: LD_INT 0
30778: PPUSH
30779: PPUSH
30780: PPUSH
30781: PPUSH
// if not mc_bases then
30782: LD_EXP 93
30786: NOT
30787: IFFALSE 30791
// exit ;
30789: GO 31193
// for i = 1 to mc_bases do
30791: LD_ADDR_VAR 0 2
30795: PUSH
30796: DOUBLE
30797: LD_INT 1
30799: DEC
30800: ST_TO_ADDR
30801: LD_EXP 93
30805: PUSH
30806: FOR_TO
30807: IFFALSE 31191
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30809: LD_EXP 96
30813: PUSH
30814: LD_VAR 0 2
30818: ARRAY
30819: PUSH
30820: LD_INT 1
30822: ARRAY
30823: NOT
30824: PUSH
30825: LD_EXP 96
30829: PUSH
30830: LD_VAR 0 2
30834: ARRAY
30835: PUSH
30836: LD_INT 2
30838: ARRAY
30839: NOT
30840: AND
30841: IFFALSE 30879
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30843: LD_ADDR_EXP 97
30847: PUSH
30848: LD_EXP 97
30852: PPUSH
30853: LD_VAR 0 2
30857: PPUSH
30858: EMPTY
30859: PPUSH
30860: CALL_OW 1
30864: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30865: LD_VAR 0 2
30869: PPUSH
30870: LD_INT 102
30872: PPUSH
30873: CALL 24956 0 2
// continue ;
30877: GO 30806
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30879: LD_ADDR_VAR 0 4
30883: PUSH
30884: LD_EXP 93
30888: PUSH
30889: LD_VAR 0 2
30893: ARRAY
30894: PPUSH
30895: LD_INT 25
30897: PUSH
30898: LD_INT 4
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PPUSH
30905: CALL_OW 72
30909: ST_TO_ADDR
// if not tmp then
30910: LD_VAR 0 4
30914: NOT
30915: IFFALSE 30919
// continue ;
30917: GO 30806
// if mc_taming [ i ] then
30919: LD_EXP 124
30923: PUSH
30924: LD_VAR 0 2
30928: ARRAY
30929: IFFALSE 30953
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30931: LD_ADDR_EXP 124
30935: PUSH
30936: LD_EXP 124
30940: PPUSH
30941: LD_VAR 0 2
30945: PPUSH
30946: EMPTY
30947: PPUSH
30948: CALL_OW 1
30952: ST_TO_ADDR
// for j in tmp do
30953: LD_ADDR_VAR 0 3
30957: PUSH
30958: LD_VAR 0 4
30962: PUSH
30963: FOR_IN
30964: IFFALSE 31187
// begin if IsInUnit ( j ) then
30966: LD_VAR 0 3
30970: PPUSH
30971: CALL_OW 310
30975: IFFALSE 30986
// ComExitBuilding ( j ) ;
30977: LD_VAR 0 3
30981: PPUSH
30982: CALL_OW 122
// if not j in mc_healers [ i ] then
30986: LD_VAR 0 3
30990: PUSH
30991: LD_EXP 97
30995: PUSH
30996: LD_VAR 0 2
31000: ARRAY
31001: IN
31002: NOT
31003: IFFALSE 31049
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31005: LD_ADDR_EXP 97
31009: PUSH
31010: LD_EXP 97
31014: PPUSH
31015: LD_VAR 0 2
31019: PUSH
31020: LD_EXP 97
31024: PUSH
31025: LD_VAR 0 2
31029: ARRAY
31030: PUSH
31031: LD_INT 1
31033: PLUS
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PPUSH
31039: LD_VAR 0 3
31043: PPUSH
31044: CALL 56267 0 3
31048: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31049: LD_VAR 0 3
31053: PPUSH
31054: CALL_OW 110
31058: PUSH
31059: LD_INT 102
31061: NONEQUAL
31062: IFFALSE 31076
// SetTag ( j , 102 ) ;
31064: LD_VAR 0 3
31068: PPUSH
31069: LD_INT 102
31071: PPUSH
31072: CALL_OW 109
// Wait ( 3 ) ;
31076: LD_INT 3
31078: PPUSH
31079: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31083: LD_EXP 96
31087: PUSH
31088: LD_VAR 0 2
31092: ARRAY
31093: PUSH
31094: LD_INT 1
31096: ARRAY
31097: IFFALSE 31129
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31099: LD_VAR 0 3
31103: PPUSH
31104: LD_EXP 96
31108: PUSH
31109: LD_VAR 0 2
31113: ARRAY
31114: PUSH
31115: LD_INT 1
31117: ARRAY
31118: PUSH
31119: LD_INT 1
31121: ARRAY
31122: PPUSH
31123: CALL_OW 128
31127: GO 31185
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31129: LD_VAR 0 3
31133: PPUSH
31134: CALL_OW 314
31138: NOT
31139: PUSH
31140: LD_EXP 96
31144: PUSH
31145: LD_VAR 0 2
31149: ARRAY
31150: PUSH
31151: LD_INT 2
31153: ARRAY
31154: AND
31155: IFFALSE 31185
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31157: LD_VAR 0 3
31161: PPUSH
31162: LD_EXP 96
31166: PUSH
31167: LD_VAR 0 2
31171: ARRAY
31172: PUSH
31173: LD_INT 2
31175: ARRAY
31176: PUSH
31177: LD_INT 1
31179: ARRAY
31180: PPUSH
31181: CALL_OW 128
// end ;
31185: GO 30963
31187: POP
31188: POP
// end ;
31189: GO 30806
31191: POP
31192: POP
// end ;
31193: LD_VAR 0 1
31197: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31198: LD_INT 0
31200: PPUSH
31201: PPUSH
31202: PPUSH
31203: PPUSH
31204: PPUSH
// if not mc_bases then
31205: LD_EXP 93
31209: NOT
31210: IFFALSE 31214
// exit ;
31212: GO 32385
// for i = 1 to mc_bases do
31214: LD_ADDR_VAR 0 2
31218: PUSH
31219: DOUBLE
31220: LD_INT 1
31222: DEC
31223: ST_TO_ADDR
31224: LD_EXP 93
31228: PUSH
31229: FOR_TO
31230: IFFALSE 32383
// begin if mc_scan [ i ] then
31232: LD_EXP 116
31236: PUSH
31237: LD_VAR 0 2
31241: ARRAY
31242: IFFALSE 31246
// continue ;
31244: GO 31229
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31246: LD_EXP 98
31250: PUSH
31251: LD_VAR 0 2
31255: ARRAY
31256: NOT
31257: PUSH
31258: LD_EXP 100
31262: PUSH
31263: LD_VAR 0 2
31267: ARRAY
31268: NOT
31269: AND
31270: PUSH
31271: LD_EXP 99
31275: PUSH
31276: LD_VAR 0 2
31280: ARRAY
31281: AND
31282: IFFALSE 31320
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31284: LD_ADDR_EXP 99
31288: PUSH
31289: LD_EXP 99
31293: PPUSH
31294: LD_VAR 0 2
31298: PPUSH
31299: EMPTY
31300: PPUSH
31301: CALL_OW 1
31305: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31306: LD_VAR 0 2
31310: PPUSH
31311: LD_INT 103
31313: PPUSH
31314: CALL 24956 0 2
// continue ;
31318: GO 31229
// end ; if mc_construct_list [ i ] then
31320: LD_EXP 100
31324: PUSH
31325: LD_VAR 0 2
31329: ARRAY
31330: IFFALSE 31550
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31332: LD_ADDR_VAR 0 4
31336: PUSH
31337: LD_EXP 93
31341: PUSH
31342: LD_VAR 0 2
31346: ARRAY
31347: PPUSH
31348: LD_INT 25
31350: PUSH
31351: LD_INT 2
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PPUSH
31358: CALL_OW 72
31362: PUSH
31363: LD_EXP 95
31367: PUSH
31368: LD_VAR 0 2
31372: ARRAY
31373: DIFF
31374: ST_TO_ADDR
// if not tmp then
31375: LD_VAR 0 4
31379: NOT
31380: IFFALSE 31384
// continue ;
31382: GO 31229
// for j in tmp do
31384: LD_ADDR_VAR 0 3
31388: PUSH
31389: LD_VAR 0 4
31393: PUSH
31394: FOR_IN
31395: IFFALSE 31546
// begin if not mc_builders [ i ] then
31397: LD_EXP 99
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: NOT
31408: IFFALSE 31466
// begin SetTag ( j , 103 ) ;
31410: LD_VAR 0 3
31414: PPUSH
31415: LD_INT 103
31417: PPUSH
31418: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31422: LD_ADDR_EXP 99
31426: PUSH
31427: LD_EXP 99
31431: PPUSH
31432: LD_VAR 0 2
31436: PUSH
31437: LD_EXP 99
31441: PUSH
31442: LD_VAR 0 2
31446: ARRAY
31447: PUSH
31448: LD_INT 1
31450: PLUS
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: PPUSH
31456: LD_VAR 0 3
31460: PPUSH
31461: CALL 56267 0 3
31465: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31466: LD_VAR 0 3
31470: PPUSH
31471: CALL_OW 310
31475: IFFALSE 31486
// ComExitBuilding ( j ) ;
31477: LD_VAR 0 3
31481: PPUSH
31482: CALL_OW 122
// wait ( 3 ) ;
31486: LD_INT 3
31488: PPUSH
31489: CALL_OW 67
// if not mc_construct_list [ i ] then
31493: LD_EXP 100
31497: PUSH
31498: LD_VAR 0 2
31502: ARRAY
31503: NOT
31504: IFFALSE 31508
// break ;
31506: GO 31546
// if not HasTask ( j ) then
31508: LD_VAR 0 3
31512: PPUSH
31513: CALL_OW 314
31517: NOT
31518: IFFALSE 31544
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31520: LD_VAR 0 3
31524: PPUSH
31525: LD_EXP 100
31529: PUSH
31530: LD_VAR 0 2
31534: ARRAY
31535: PUSH
31536: LD_INT 1
31538: ARRAY
31539: PPUSH
31540: CALL 59130 0 2
// end ;
31544: GO 31394
31546: POP
31547: POP
// end else
31548: GO 32381
// if mc_build_list [ i ] then
31550: LD_EXP 98
31554: PUSH
31555: LD_VAR 0 2
31559: ARRAY
31560: IFFALSE 32381
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31562: LD_ADDR_VAR 0 5
31566: PUSH
31567: LD_EXP 93
31571: PUSH
31572: LD_VAR 0 2
31576: ARRAY
31577: PPUSH
31578: LD_INT 2
31580: PUSH
31581: LD_INT 30
31583: PUSH
31584: LD_INT 0
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 30
31593: PUSH
31594: LD_INT 1
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: LIST
31605: PPUSH
31606: CALL_OW 72
31610: ST_TO_ADDR
// if depot then
31611: LD_VAR 0 5
31615: IFFALSE 31633
// depot := depot [ 1 ] else
31617: LD_ADDR_VAR 0 5
31621: PUSH
31622: LD_VAR 0 5
31626: PUSH
31627: LD_INT 1
31629: ARRAY
31630: ST_TO_ADDR
31631: GO 31641
// depot := 0 ;
31633: LD_ADDR_VAR 0 5
31637: PUSH
31638: LD_INT 0
31640: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31641: LD_EXP 98
31645: PUSH
31646: LD_VAR 0 2
31650: ARRAY
31651: PUSH
31652: LD_INT 1
31654: ARRAY
31655: PUSH
31656: LD_INT 1
31658: ARRAY
31659: PPUSH
31660: CALL 58954 0 1
31664: PUSH
31665: LD_EXP 93
31669: PUSH
31670: LD_VAR 0 2
31674: ARRAY
31675: PPUSH
31676: LD_INT 2
31678: PUSH
31679: LD_INT 30
31681: PUSH
31682: LD_INT 2
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 30
31691: PUSH
31692: LD_INT 3
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: LIST
31703: PPUSH
31704: CALL_OW 72
31708: NOT
31709: AND
31710: IFFALSE 31815
// begin for j = 1 to mc_build_list [ i ] do
31712: LD_ADDR_VAR 0 3
31716: PUSH
31717: DOUBLE
31718: LD_INT 1
31720: DEC
31721: ST_TO_ADDR
31722: LD_EXP 98
31726: PUSH
31727: LD_VAR 0 2
31731: ARRAY
31732: PUSH
31733: FOR_TO
31734: IFFALSE 31813
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31736: LD_EXP 98
31740: PUSH
31741: LD_VAR 0 2
31745: ARRAY
31746: PUSH
31747: LD_VAR 0 3
31751: ARRAY
31752: PUSH
31753: LD_INT 1
31755: ARRAY
31756: PUSH
31757: LD_INT 2
31759: EQUAL
31760: IFFALSE 31811
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31762: LD_ADDR_EXP 98
31766: PUSH
31767: LD_EXP 98
31771: PPUSH
31772: LD_VAR 0 2
31776: PPUSH
31777: LD_EXP 98
31781: PUSH
31782: LD_VAR 0 2
31786: ARRAY
31787: PPUSH
31788: LD_VAR 0 3
31792: PPUSH
31793: LD_INT 1
31795: PPUSH
31796: LD_INT 0
31798: PPUSH
31799: CALL 55685 0 4
31803: PPUSH
31804: CALL_OW 1
31808: ST_TO_ADDR
// break ;
31809: GO 31813
// end ;
31811: GO 31733
31813: POP
31814: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31815: LD_EXP 98
31819: PUSH
31820: LD_VAR 0 2
31824: ARRAY
31825: PUSH
31826: LD_INT 1
31828: ARRAY
31829: PUSH
31830: LD_INT 1
31832: ARRAY
31833: PUSH
31834: LD_INT 0
31836: EQUAL
31837: PUSH
31838: LD_VAR 0 5
31842: PUSH
31843: LD_VAR 0 5
31847: PPUSH
31848: LD_EXP 98
31852: PUSH
31853: LD_VAR 0 2
31857: ARRAY
31858: PUSH
31859: LD_INT 1
31861: ARRAY
31862: PUSH
31863: LD_INT 1
31865: ARRAY
31866: PPUSH
31867: LD_EXP 98
31871: PUSH
31872: LD_VAR 0 2
31876: ARRAY
31877: PUSH
31878: LD_INT 1
31880: ARRAY
31881: PUSH
31882: LD_INT 2
31884: ARRAY
31885: PPUSH
31886: LD_EXP 98
31890: PUSH
31891: LD_VAR 0 2
31895: ARRAY
31896: PUSH
31897: LD_INT 1
31899: ARRAY
31900: PUSH
31901: LD_INT 3
31903: ARRAY
31904: PPUSH
31905: LD_EXP 98
31909: PUSH
31910: LD_VAR 0 2
31914: ARRAY
31915: PUSH
31916: LD_INT 1
31918: ARRAY
31919: PUSH
31920: LD_INT 4
31922: ARRAY
31923: PPUSH
31924: CALL 64370 0 5
31928: AND
31929: OR
31930: IFFALSE 32211
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31932: LD_ADDR_VAR 0 4
31936: PUSH
31937: LD_EXP 93
31941: PUSH
31942: LD_VAR 0 2
31946: ARRAY
31947: PPUSH
31948: LD_INT 25
31950: PUSH
31951: LD_INT 2
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PPUSH
31958: CALL_OW 72
31962: PUSH
31963: LD_EXP 95
31967: PUSH
31968: LD_VAR 0 2
31972: ARRAY
31973: DIFF
31974: ST_TO_ADDR
// if not tmp then
31975: LD_VAR 0 4
31979: NOT
31980: IFFALSE 31984
// continue ;
31982: GO 31229
// for j in tmp do
31984: LD_ADDR_VAR 0 3
31988: PUSH
31989: LD_VAR 0 4
31993: PUSH
31994: FOR_IN
31995: IFFALSE 32207
// begin if not mc_builders [ i ] then
31997: LD_EXP 99
32001: PUSH
32002: LD_VAR 0 2
32006: ARRAY
32007: NOT
32008: IFFALSE 32066
// begin SetTag ( j , 103 ) ;
32010: LD_VAR 0 3
32014: PPUSH
32015: LD_INT 103
32017: PPUSH
32018: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32022: LD_ADDR_EXP 99
32026: PUSH
32027: LD_EXP 99
32031: PPUSH
32032: LD_VAR 0 2
32036: PUSH
32037: LD_EXP 99
32041: PUSH
32042: LD_VAR 0 2
32046: ARRAY
32047: PUSH
32048: LD_INT 1
32050: PLUS
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PPUSH
32056: LD_VAR 0 3
32060: PPUSH
32061: CALL 56267 0 3
32065: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32066: LD_VAR 0 3
32070: PPUSH
32071: CALL_OW 310
32075: IFFALSE 32086
// ComExitBuilding ( j ) ;
32077: LD_VAR 0 3
32081: PPUSH
32082: CALL_OW 122
// wait ( 3 ) ;
32086: LD_INT 3
32088: PPUSH
32089: CALL_OW 67
// if not mc_build_list [ i ] then
32093: LD_EXP 98
32097: PUSH
32098: LD_VAR 0 2
32102: ARRAY
32103: NOT
32104: IFFALSE 32108
// break ;
32106: GO 32207
// if not HasTask ( j ) then
32108: LD_VAR 0 3
32112: PPUSH
32113: CALL_OW 314
32117: NOT
32118: IFFALSE 32205
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32120: LD_VAR 0 3
32124: PPUSH
32125: LD_EXP 98
32129: PUSH
32130: LD_VAR 0 2
32134: ARRAY
32135: PUSH
32136: LD_INT 1
32138: ARRAY
32139: PUSH
32140: LD_INT 1
32142: ARRAY
32143: PPUSH
32144: LD_EXP 98
32148: PUSH
32149: LD_VAR 0 2
32153: ARRAY
32154: PUSH
32155: LD_INT 1
32157: ARRAY
32158: PUSH
32159: LD_INT 2
32161: ARRAY
32162: PPUSH
32163: LD_EXP 98
32167: PUSH
32168: LD_VAR 0 2
32172: ARRAY
32173: PUSH
32174: LD_INT 1
32176: ARRAY
32177: PUSH
32178: LD_INT 3
32180: ARRAY
32181: PPUSH
32182: LD_EXP 98
32186: PUSH
32187: LD_VAR 0 2
32191: ARRAY
32192: PUSH
32193: LD_INT 1
32195: ARRAY
32196: PUSH
32197: LD_INT 4
32199: ARRAY
32200: PPUSH
32201: CALL_OW 145
// end ;
32205: GO 31994
32207: POP
32208: POP
// end else
32209: GO 32381
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32211: LD_EXP 93
32215: PUSH
32216: LD_VAR 0 2
32220: ARRAY
32221: PPUSH
32222: LD_EXP 98
32226: PUSH
32227: LD_VAR 0 2
32231: ARRAY
32232: PUSH
32233: LD_INT 1
32235: ARRAY
32236: PUSH
32237: LD_INT 1
32239: ARRAY
32240: PPUSH
32241: LD_EXP 98
32245: PUSH
32246: LD_VAR 0 2
32250: ARRAY
32251: PUSH
32252: LD_INT 1
32254: ARRAY
32255: PUSH
32256: LD_INT 2
32258: ARRAY
32259: PPUSH
32260: LD_EXP 98
32264: PUSH
32265: LD_VAR 0 2
32269: ARRAY
32270: PUSH
32271: LD_INT 1
32273: ARRAY
32274: PUSH
32275: LD_INT 3
32277: ARRAY
32278: PPUSH
32279: LD_EXP 98
32283: PUSH
32284: LD_VAR 0 2
32288: ARRAY
32289: PUSH
32290: LD_INT 1
32292: ARRAY
32293: PUSH
32294: LD_INT 4
32296: ARRAY
32297: PPUSH
32298: LD_EXP 93
32302: PUSH
32303: LD_VAR 0 2
32307: ARRAY
32308: PPUSH
32309: LD_INT 21
32311: PUSH
32312: LD_INT 3
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PPUSH
32319: CALL_OW 72
32323: PPUSH
32324: EMPTY
32325: PPUSH
32326: CALL 63120 0 7
32330: NOT
32331: IFFALSE 32381
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32333: LD_ADDR_EXP 98
32337: PUSH
32338: LD_EXP 98
32342: PPUSH
32343: LD_VAR 0 2
32347: PPUSH
32348: LD_EXP 98
32352: PUSH
32353: LD_VAR 0 2
32357: ARRAY
32358: PPUSH
32359: LD_INT 1
32361: PPUSH
32362: LD_INT 1
32364: NEG
32365: PPUSH
32366: LD_INT 0
32368: PPUSH
32369: CALL 55685 0 4
32373: PPUSH
32374: CALL_OW 1
32378: ST_TO_ADDR
// continue ;
32379: GO 31229
// end ; end ; end ;
32381: GO 31229
32383: POP
32384: POP
// end ;
32385: LD_VAR 0 1
32389: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32390: LD_INT 0
32392: PPUSH
32393: PPUSH
32394: PPUSH
32395: PPUSH
32396: PPUSH
32397: PPUSH
// if not mc_bases then
32398: LD_EXP 93
32402: NOT
32403: IFFALSE 32407
// exit ;
32405: GO 32834
// for i = 1 to mc_bases do
32407: LD_ADDR_VAR 0 2
32411: PUSH
32412: DOUBLE
32413: LD_INT 1
32415: DEC
32416: ST_TO_ADDR
32417: LD_EXP 93
32421: PUSH
32422: FOR_TO
32423: IFFALSE 32832
// begin tmp := mc_build_upgrade [ i ] ;
32425: LD_ADDR_VAR 0 4
32429: PUSH
32430: LD_EXP 125
32434: PUSH
32435: LD_VAR 0 2
32439: ARRAY
32440: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32441: LD_ADDR_VAR 0 6
32445: PUSH
32446: LD_EXP 126
32450: PUSH
32451: LD_VAR 0 2
32455: ARRAY
32456: PPUSH
32457: LD_INT 2
32459: PUSH
32460: LD_INT 30
32462: PUSH
32463: LD_INT 6
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 30
32472: PUSH
32473: LD_INT 7
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: LIST
32484: PPUSH
32485: CALL_OW 72
32489: ST_TO_ADDR
// if not tmp and not lab then
32490: LD_VAR 0 4
32494: NOT
32495: PUSH
32496: LD_VAR 0 6
32500: NOT
32501: AND
32502: IFFALSE 32506
// continue ;
32504: GO 32422
// if tmp then
32506: LD_VAR 0 4
32510: IFFALSE 32630
// for j in tmp do
32512: LD_ADDR_VAR 0 3
32516: PUSH
32517: LD_VAR 0 4
32521: PUSH
32522: FOR_IN
32523: IFFALSE 32628
// begin if UpgradeCost ( j ) then
32525: LD_VAR 0 3
32529: PPUSH
32530: CALL 62780 0 1
32534: IFFALSE 32626
// begin ComUpgrade ( j ) ;
32536: LD_VAR 0 3
32540: PPUSH
32541: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32545: LD_ADDR_EXP 125
32549: PUSH
32550: LD_EXP 125
32554: PPUSH
32555: LD_VAR 0 2
32559: PPUSH
32560: LD_EXP 125
32564: PUSH
32565: LD_VAR 0 2
32569: ARRAY
32570: PUSH
32571: LD_VAR 0 3
32575: DIFF
32576: PPUSH
32577: CALL_OW 1
32581: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32582: LD_ADDR_EXP 100
32586: PUSH
32587: LD_EXP 100
32591: PPUSH
32592: LD_VAR 0 2
32596: PUSH
32597: LD_EXP 100
32601: PUSH
32602: LD_VAR 0 2
32606: ARRAY
32607: PUSH
32608: LD_INT 1
32610: PLUS
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PPUSH
32616: LD_VAR 0 3
32620: PPUSH
32621: CALL 56267 0 3
32625: ST_TO_ADDR
// end ; end ;
32626: GO 32522
32628: POP
32629: POP
// if not lab or not mc_lab_upgrade [ i ] then
32630: LD_VAR 0 6
32634: NOT
32635: PUSH
32636: LD_EXP 127
32640: PUSH
32641: LD_VAR 0 2
32645: ARRAY
32646: NOT
32647: OR
32648: IFFALSE 32652
// continue ;
32650: GO 32422
// for j in lab do
32652: LD_ADDR_VAR 0 3
32656: PUSH
32657: LD_VAR 0 6
32661: PUSH
32662: FOR_IN
32663: IFFALSE 32828
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32665: LD_VAR 0 3
32669: PPUSH
32670: CALL_OW 266
32674: PUSH
32675: LD_INT 6
32677: PUSH
32678: LD_INT 7
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: IN
32685: PUSH
32686: LD_VAR 0 3
32690: PPUSH
32691: CALL_OW 461
32695: PUSH
32696: LD_INT 1
32698: NONEQUAL
32699: AND
32700: IFFALSE 32826
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32702: LD_VAR 0 3
32706: PPUSH
32707: LD_EXP 127
32711: PUSH
32712: LD_VAR 0 2
32716: ARRAY
32717: PUSH
32718: LD_INT 1
32720: ARRAY
32721: PPUSH
32722: CALL 62985 0 2
32726: IFFALSE 32826
// begin ComCancel ( j ) ;
32728: LD_VAR 0 3
32732: PPUSH
32733: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32737: LD_VAR 0 3
32741: PPUSH
32742: LD_EXP 127
32746: PUSH
32747: LD_VAR 0 2
32751: ARRAY
32752: PUSH
32753: LD_INT 1
32755: ARRAY
32756: PPUSH
32757: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32761: LD_VAR 0 3
32765: PUSH
32766: LD_EXP 100
32770: PUSH
32771: LD_VAR 0 2
32775: ARRAY
32776: IN
32777: NOT
32778: IFFALSE 32824
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32780: LD_ADDR_EXP 100
32784: PUSH
32785: LD_EXP 100
32789: PPUSH
32790: LD_VAR 0 2
32794: PUSH
32795: LD_EXP 100
32799: PUSH
32800: LD_VAR 0 2
32804: ARRAY
32805: PUSH
32806: LD_INT 1
32808: PLUS
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PPUSH
32814: LD_VAR 0 3
32818: PPUSH
32819: CALL 56267 0 3
32823: ST_TO_ADDR
// break ;
32824: GO 32828
// end ; end ; end ;
32826: GO 32662
32828: POP
32829: POP
// end ;
32830: GO 32422
32832: POP
32833: POP
// end ;
32834: LD_VAR 0 1
32838: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32839: LD_INT 0
32841: PPUSH
32842: PPUSH
32843: PPUSH
32844: PPUSH
32845: PPUSH
32846: PPUSH
32847: PPUSH
32848: PPUSH
32849: PPUSH
// if not mc_bases then
32850: LD_EXP 93
32854: NOT
32855: IFFALSE 32859
// exit ;
32857: GO 33264
// for i = 1 to mc_bases do
32859: LD_ADDR_VAR 0 2
32863: PUSH
32864: DOUBLE
32865: LD_INT 1
32867: DEC
32868: ST_TO_ADDR
32869: LD_EXP 93
32873: PUSH
32874: FOR_TO
32875: IFFALSE 33262
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32877: LD_EXP 101
32881: PUSH
32882: LD_VAR 0 2
32886: ARRAY
32887: NOT
32888: PUSH
32889: LD_EXP 93
32893: PUSH
32894: LD_VAR 0 2
32898: ARRAY
32899: PPUSH
32900: LD_INT 30
32902: PUSH
32903: LD_INT 3
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PPUSH
32910: CALL_OW 72
32914: NOT
32915: OR
32916: IFFALSE 32920
// continue ;
32918: GO 32874
// busy := false ;
32920: LD_ADDR_VAR 0 8
32924: PUSH
32925: LD_INT 0
32927: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32928: LD_ADDR_VAR 0 4
32932: PUSH
32933: LD_EXP 93
32937: PUSH
32938: LD_VAR 0 2
32942: ARRAY
32943: PPUSH
32944: LD_INT 30
32946: PUSH
32947: LD_INT 3
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PPUSH
32954: CALL_OW 72
32958: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32959: LD_ADDR_VAR 0 6
32963: PUSH
32964: LD_EXP 101
32968: PUSH
32969: LD_VAR 0 2
32973: ARRAY
32974: PPUSH
32975: LD_INT 2
32977: PUSH
32978: LD_INT 30
32980: PUSH
32981: LD_INT 32
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 30
32990: PUSH
32991: LD_INT 33
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: LIST
33002: PPUSH
33003: CALL_OW 72
33007: ST_TO_ADDR
// if not t then
33008: LD_VAR 0 6
33012: NOT
33013: IFFALSE 33017
// continue ;
33015: GO 32874
// for j in tmp do
33017: LD_ADDR_VAR 0 3
33021: PUSH
33022: LD_VAR 0 4
33026: PUSH
33027: FOR_IN
33028: IFFALSE 33058
// if not BuildingStatus ( j ) = bs_idle then
33030: LD_VAR 0 3
33034: PPUSH
33035: CALL_OW 461
33039: PUSH
33040: LD_INT 2
33042: EQUAL
33043: NOT
33044: IFFALSE 33056
// begin busy := true ;
33046: LD_ADDR_VAR 0 8
33050: PUSH
33051: LD_INT 1
33053: ST_TO_ADDR
// break ;
33054: GO 33058
// end ;
33056: GO 33027
33058: POP
33059: POP
// if busy then
33060: LD_VAR 0 8
33064: IFFALSE 33068
// continue ;
33066: GO 32874
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33068: LD_ADDR_VAR 0 7
33072: PUSH
33073: LD_VAR 0 6
33077: PPUSH
33078: LD_INT 35
33080: PUSH
33081: LD_INT 0
33083: PUSH
33084: EMPTY
33085: LIST
33086: LIST
33087: PPUSH
33088: CALL_OW 72
33092: ST_TO_ADDR
// if tw then
33093: LD_VAR 0 7
33097: IFFALSE 33174
// begin tw := tw [ 1 ] ;
33099: LD_ADDR_VAR 0 7
33103: PUSH
33104: LD_VAR 0 7
33108: PUSH
33109: LD_INT 1
33111: ARRAY
33112: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33113: LD_ADDR_VAR 0 9
33117: PUSH
33118: LD_VAR 0 7
33122: PPUSH
33123: LD_EXP 118
33127: PUSH
33128: LD_VAR 0 2
33132: ARRAY
33133: PPUSH
33134: CALL 61277 0 2
33138: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33139: LD_EXP 132
33143: PUSH
33144: LD_VAR 0 2
33148: ARRAY
33149: IFFALSE 33172
// if not weapon in mc_allowed_tower_weapons [ i ] then
33151: LD_VAR 0 9
33155: PUSH
33156: LD_EXP 132
33160: PUSH
33161: LD_VAR 0 2
33165: ARRAY
33166: IN
33167: NOT
33168: IFFALSE 33172
// continue ;
33170: GO 32874
// end else
33172: GO 33237
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33174: LD_ADDR_VAR 0 5
33178: PUSH
33179: LD_EXP 101
33183: PUSH
33184: LD_VAR 0 2
33188: ARRAY
33189: PPUSH
33190: LD_VAR 0 4
33194: PPUSH
33195: CALL 87566 0 2
33199: ST_TO_ADDR
// if not tmp2 then
33200: LD_VAR 0 5
33204: NOT
33205: IFFALSE 33209
// continue ;
33207: GO 32874
// tw := tmp2 [ 1 ] ;
33209: LD_ADDR_VAR 0 7
33213: PUSH
33214: LD_VAR 0 5
33218: PUSH
33219: LD_INT 1
33221: ARRAY
33222: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33223: LD_ADDR_VAR 0 9
33227: PUSH
33228: LD_VAR 0 5
33232: PUSH
33233: LD_INT 2
33235: ARRAY
33236: ST_TO_ADDR
// end ; if not weapon then
33237: LD_VAR 0 9
33241: NOT
33242: IFFALSE 33246
// continue ;
33244: GO 32874
// ComPlaceWeapon ( tw , weapon ) ;
33246: LD_VAR 0 7
33250: PPUSH
33251: LD_VAR 0 9
33255: PPUSH
33256: CALL_OW 148
// end ;
33260: GO 32874
33262: POP
33263: POP
// end ;
33264: LD_VAR 0 1
33268: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33269: LD_INT 0
33271: PPUSH
33272: PPUSH
33273: PPUSH
33274: PPUSH
33275: PPUSH
33276: PPUSH
33277: PPUSH
// if not mc_bases then
33278: LD_EXP 93
33282: NOT
33283: IFFALSE 33287
// exit ;
33285: GO 34055
// for i = 1 to mc_bases do
33287: LD_ADDR_VAR 0 2
33291: PUSH
33292: DOUBLE
33293: LD_INT 1
33295: DEC
33296: ST_TO_ADDR
33297: LD_EXP 93
33301: PUSH
33302: FOR_TO
33303: IFFALSE 34053
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33305: LD_EXP 106
33309: PUSH
33310: LD_VAR 0 2
33314: ARRAY
33315: NOT
33316: PUSH
33317: LD_EXP 106
33321: PUSH
33322: LD_VAR 0 2
33326: ARRAY
33327: PUSH
33328: LD_EXP 107
33332: PUSH
33333: LD_VAR 0 2
33337: ARRAY
33338: EQUAL
33339: OR
33340: PUSH
33341: LD_EXP 116
33345: PUSH
33346: LD_VAR 0 2
33350: ARRAY
33351: OR
33352: IFFALSE 33356
// continue ;
33354: GO 33302
// if mc_miners [ i ] then
33356: LD_EXP 107
33360: PUSH
33361: LD_VAR 0 2
33365: ARRAY
33366: IFFALSE 33740
// begin for j = mc_miners [ i ] downto 1 do
33368: LD_ADDR_VAR 0 3
33372: PUSH
33373: DOUBLE
33374: LD_EXP 107
33378: PUSH
33379: LD_VAR 0 2
33383: ARRAY
33384: INC
33385: ST_TO_ADDR
33386: LD_INT 1
33388: PUSH
33389: FOR_DOWNTO
33390: IFFALSE 33738
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33392: LD_EXP 107
33396: PUSH
33397: LD_VAR 0 2
33401: ARRAY
33402: PUSH
33403: LD_VAR 0 3
33407: ARRAY
33408: PPUSH
33409: CALL_OW 301
33413: PUSH
33414: LD_EXP 107
33418: PUSH
33419: LD_VAR 0 2
33423: ARRAY
33424: PUSH
33425: LD_VAR 0 3
33429: ARRAY
33430: PPUSH
33431: CALL_OW 257
33435: PUSH
33436: LD_INT 1
33438: NONEQUAL
33439: OR
33440: IFFALSE 33503
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33442: LD_ADDR_VAR 0 5
33446: PUSH
33447: LD_EXP 107
33451: PUSH
33452: LD_VAR 0 2
33456: ARRAY
33457: PUSH
33458: LD_EXP 107
33462: PUSH
33463: LD_VAR 0 2
33467: ARRAY
33468: PUSH
33469: LD_VAR 0 3
33473: ARRAY
33474: DIFF
33475: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33476: LD_ADDR_EXP 107
33480: PUSH
33481: LD_EXP 107
33485: PPUSH
33486: LD_VAR 0 2
33490: PPUSH
33491: LD_VAR 0 5
33495: PPUSH
33496: CALL_OW 1
33500: ST_TO_ADDR
// continue ;
33501: GO 33389
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33503: LD_EXP 107
33507: PUSH
33508: LD_VAR 0 2
33512: ARRAY
33513: PUSH
33514: LD_VAR 0 3
33518: ARRAY
33519: PPUSH
33520: CALL_OW 257
33524: PUSH
33525: LD_INT 1
33527: EQUAL
33528: PUSH
33529: LD_EXP 107
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: PUSH
33540: LD_VAR 0 3
33544: ARRAY
33545: PPUSH
33546: CALL_OW 459
33550: NOT
33551: AND
33552: PUSH
33553: LD_EXP 107
33557: PUSH
33558: LD_VAR 0 2
33562: ARRAY
33563: PUSH
33564: LD_VAR 0 3
33568: ARRAY
33569: PPUSH
33570: CALL_OW 314
33574: NOT
33575: AND
33576: IFFALSE 33736
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33578: LD_EXP 107
33582: PUSH
33583: LD_VAR 0 2
33587: ARRAY
33588: PUSH
33589: LD_VAR 0 3
33593: ARRAY
33594: PPUSH
33595: CALL_OW 310
33599: IFFALSE 33622
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33601: LD_EXP 107
33605: PUSH
33606: LD_VAR 0 2
33610: ARRAY
33611: PUSH
33612: LD_VAR 0 3
33616: ARRAY
33617: PPUSH
33618: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33622: LD_EXP 107
33626: PUSH
33627: LD_VAR 0 2
33631: ARRAY
33632: PUSH
33633: LD_VAR 0 3
33637: ARRAY
33638: PPUSH
33639: CALL_OW 314
33643: NOT
33644: IFFALSE 33736
// begin r := rand ( 1 , mc_mines [ i ] ) ;
33646: LD_ADDR_VAR 0 7
33650: PUSH
33651: LD_INT 1
33653: PPUSH
33654: LD_EXP 106
33658: PUSH
33659: LD_VAR 0 2
33663: ARRAY
33664: PPUSH
33665: CALL_OW 12
33669: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
33670: LD_EXP 107
33674: PUSH
33675: LD_VAR 0 2
33679: ARRAY
33680: PUSH
33681: LD_VAR 0 3
33685: ARRAY
33686: PPUSH
33687: LD_EXP 106
33691: PUSH
33692: LD_VAR 0 2
33696: ARRAY
33697: PUSH
33698: LD_VAR 0 7
33702: ARRAY
33703: PUSH
33704: LD_INT 1
33706: ARRAY
33707: PPUSH
33708: LD_EXP 106
33712: PUSH
33713: LD_VAR 0 2
33717: ARRAY
33718: PUSH
33719: LD_VAR 0 7
33723: ARRAY
33724: PUSH
33725: LD_INT 2
33727: ARRAY
33728: PPUSH
33729: LD_INT 0
33731: PPUSH
33732: CALL_OW 193
// end ; end ; end ;
33736: GO 33389
33738: POP
33739: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33740: LD_ADDR_VAR 0 5
33744: PUSH
33745: LD_EXP 93
33749: PUSH
33750: LD_VAR 0 2
33754: ARRAY
33755: PPUSH
33756: LD_INT 2
33758: PUSH
33759: LD_INT 30
33761: PUSH
33762: LD_INT 4
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 30
33771: PUSH
33772: LD_INT 5
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 30
33781: PUSH
33782: LD_INT 32
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: PPUSH
33795: CALL_OW 72
33799: ST_TO_ADDR
// if not tmp then
33800: LD_VAR 0 5
33804: NOT
33805: IFFALSE 33809
// continue ;
33807: GO 33302
// list := [ ] ;
33809: LD_ADDR_VAR 0 6
33813: PUSH
33814: EMPTY
33815: ST_TO_ADDR
// for j in tmp do
33816: LD_ADDR_VAR 0 3
33820: PUSH
33821: LD_VAR 0 5
33825: PUSH
33826: FOR_IN
33827: IFFALSE 33896
// begin for k in UnitsInside ( j ) do
33829: LD_ADDR_VAR 0 4
33833: PUSH
33834: LD_VAR 0 3
33838: PPUSH
33839: CALL_OW 313
33843: PUSH
33844: FOR_IN
33845: IFFALSE 33892
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33847: LD_VAR 0 4
33851: PPUSH
33852: CALL_OW 257
33856: PUSH
33857: LD_INT 1
33859: EQUAL
33860: PUSH
33861: LD_VAR 0 4
33865: PPUSH
33866: CALL_OW 459
33870: NOT
33871: AND
33872: IFFALSE 33890
// list := list ^ k ;
33874: LD_ADDR_VAR 0 6
33878: PUSH
33879: LD_VAR 0 6
33883: PUSH
33884: LD_VAR 0 4
33888: ADD
33889: ST_TO_ADDR
33890: GO 33844
33892: POP
33893: POP
// end ;
33894: GO 33826
33896: POP
33897: POP
// list := list diff mc_miners [ i ] ;
33898: LD_ADDR_VAR 0 6
33902: PUSH
33903: LD_VAR 0 6
33907: PUSH
33908: LD_EXP 107
33912: PUSH
33913: LD_VAR 0 2
33917: ARRAY
33918: DIFF
33919: ST_TO_ADDR
// if not list then
33920: LD_VAR 0 6
33924: NOT
33925: IFFALSE 33929
// continue ;
33927: GO 33302
// k := mc_mines [ i ] - mc_miners [ i ] ;
33929: LD_ADDR_VAR 0 4
33933: PUSH
33934: LD_EXP 106
33938: PUSH
33939: LD_VAR 0 2
33943: ARRAY
33944: PUSH
33945: LD_EXP 107
33949: PUSH
33950: LD_VAR 0 2
33954: ARRAY
33955: MINUS
33956: ST_TO_ADDR
// if k > list then
33957: LD_VAR 0 4
33961: PUSH
33962: LD_VAR 0 6
33966: GREATER
33967: IFFALSE 33979
// k := list ;
33969: LD_ADDR_VAR 0 4
33973: PUSH
33974: LD_VAR 0 6
33978: ST_TO_ADDR
// for j = 1 to k do
33979: LD_ADDR_VAR 0 3
33983: PUSH
33984: DOUBLE
33985: LD_INT 1
33987: DEC
33988: ST_TO_ADDR
33989: LD_VAR 0 4
33993: PUSH
33994: FOR_TO
33995: IFFALSE 34049
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33997: LD_ADDR_EXP 107
34001: PUSH
34002: LD_EXP 107
34006: PPUSH
34007: LD_VAR 0 2
34011: PUSH
34012: LD_EXP 107
34016: PUSH
34017: LD_VAR 0 2
34021: ARRAY
34022: PUSH
34023: LD_INT 1
34025: PLUS
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PPUSH
34031: LD_VAR 0 6
34035: PUSH
34036: LD_VAR 0 3
34040: ARRAY
34041: PPUSH
34042: CALL 56267 0 3
34046: ST_TO_ADDR
34047: GO 33994
34049: POP
34050: POP
// end ;
34051: GO 33302
34053: POP
34054: POP
// end ;
34055: LD_VAR 0 1
34059: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34060: LD_INT 0
34062: PPUSH
34063: PPUSH
34064: PPUSH
34065: PPUSH
34066: PPUSH
34067: PPUSH
34068: PPUSH
34069: PPUSH
34070: PPUSH
34071: PPUSH
34072: PPUSH
// if not mc_bases then
34073: LD_EXP 93
34077: NOT
34078: IFFALSE 34082
// exit ;
34080: GO 35905
// for i = 1 to mc_bases do
34082: LD_ADDR_VAR 0 2
34086: PUSH
34087: DOUBLE
34088: LD_INT 1
34090: DEC
34091: ST_TO_ADDR
34092: LD_EXP 93
34096: PUSH
34097: FOR_TO
34098: IFFALSE 35903
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34100: LD_EXP 93
34104: PUSH
34105: LD_VAR 0 2
34109: ARRAY
34110: NOT
34111: PUSH
34112: LD_EXP 100
34116: PUSH
34117: LD_VAR 0 2
34121: ARRAY
34122: OR
34123: IFFALSE 34127
// continue ;
34125: GO 34097
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34127: LD_EXP 109
34131: PUSH
34132: LD_VAR 0 2
34136: ARRAY
34137: NOT
34138: PUSH
34139: LD_EXP 110
34143: PUSH
34144: LD_VAR 0 2
34148: ARRAY
34149: AND
34150: IFFALSE 34188
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34152: LD_ADDR_EXP 110
34156: PUSH
34157: LD_EXP 110
34161: PPUSH
34162: LD_VAR 0 2
34166: PPUSH
34167: EMPTY
34168: PPUSH
34169: CALL_OW 1
34173: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34174: LD_VAR 0 2
34178: PPUSH
34179: LD_INT 107
34181: PPUSH
34182: CALL 24956 0 2
// continue ;
34186: GO 34097
// end ; target := [ ] ;
34188: LD_ADDR_VAR 0 7
34192: PUSH
34193: EMPTY
34194: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34195: LD_ADDR_VAR 0 6
34199: PUSH
34200: LD_EXP 93
34204: PUSH
34205: LD_VAR 0 2
34209: ARRAY
34210: PUSH
34211: LD_INT 1
34213: ARRAY
34214: PPUSH
34215: CALL_OW 255
34219: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34220: LD_ADDR_VAR 0 9
34224: PUSH
34225: LD_EXP 93
34229: PUSH
34230: LD_VAR 0 2
34234: ARRAY
34235: PPUSH
34236: LD_INT 2
34238: PUSH
34239: LD_INT 30
34241: PUSH
34242: LD_INT 0
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 30
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: LIST
34263: PPUSH
34264: CALL_OW 72
34268: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34269: LD_ADDR_VAR 0 3
34273: PUSH
34274: DOUBLE
34275: LD_EXP 109
34279: PUSH
34280: LD_VAR 0 2
34284: ARRAY
34285: INC
34286: ST_TO_ADDR
34287: LD_INT 1
34289: PUSH
34290: FOR_DOWNTO
34291: IFFALSE 34536
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34293: LD_EXP 109
34297: PUSH
34298: LD_VAR 0 2
34302: ARRAY
34303: PUSH
34304: LD_VAR 0 3
34308: ARRAY
34309: PUSH
34310: LD_INT 2
34312: ARRAY
34313: PPUSH
34314: LD_EXP 109
34318: PUSH
34319: LD_VAR 0 2
34323: ARRAY
34324: PUSH
34325: LD_VAR 0 3
34329: ARRAY
34330: PUSH
34331: LD_INT 3
34333: ARRAY
34334: PPUSH
34335: CALL_OW 488
34339: PUSH
34340: LD_EXP 109
34344: PUSH
34345: LD_VAR 0 2
34349: ARRAY
34350: PUSH
34351: LD_VAR 0 3
34355: ARRAY
34356: PUSH
34357: LD_INT 2
34359: ARRAY
34360: PPUSH
34361: LD_EXP 109
34365: PUSH
34366: LD_VAR 0 2
34370: ARRAY
34371: PUSH
34372: LD_VAR 0 3
34376: ARRAY
34377: PUSH
34378: LD_INT 3
34380: ARRAY
34381: PPUSH
34382: CALL_OW 284
34386: PUSH
34387: LD_INT 0
34389: EQUAL
34390: AND
34391: IFFALSE 34446
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34393: LD_ADDR_VAR 0 5
34397: PUSH
34398: LD_EXP 109
34402: PUSH
34403: LD_VAR 0 2
34407: ARRAY
34408: PPUSH
34409: LD_VAR 0 3
34413: PPUSH
34414: CALL_OW 3
34418: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34419: LD_ADDR_EXP 109
34423: PUSH
34424: LD_EXP 109
34428: PPUSH
34429: LD_VAR 0 2
34433: PPUSH
34434: LD_VAR 0 5
34438: PPUSH
34439: CALL_OW 1
34443: ST_TO_ADDR
// continue ;
34444: GO 34290
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34446: LD_VAR 0 6
34450: PPUSH
34451: LD_EXP 109
34455: PUSH
34456: LD_VAR 0 2
34460: ARRAY
34461: PUSH
34462: LD_VAR 0 3
34466: ARRAY
34467: PUSH
34468: LD_INT 2
34470: ARRAY
34471: PPUSH
34472: LD_EXP 109
34476: PUSH
34477: LD_VAR 0 2
34481: ARRAY
34482: PUSH
34483: LD_VAR 0 3
34487: ARRAY
34488: PUSH
34489: LD_INT 3
34491: ARRAY
34492: PPUSH
34493: LD_INT 30
34495: PPUSH
34496: CALL 57163 0 4
34500: PUSH
34501: LD_INT 4
34503: ARRAY
34504: PUSH
34505: LD_INT 0
34507: EQUAL
34508: IFFALSE 34534
// begin target := mc_crates [ i ] [ j ] ;
34510: LD_ADDR_VAR 0 7
34514: PUSH
34515: LD_EXP 109
34519: PUSH
34520: LD_VAR 0 2
34524: ARRAY
34525: PUSH
34526: LD_VAR 0 3
34530: ARRAY
34531: ST_TO_ADDR
// break ;
34532: GO 34536
// end ; end ;
34534: GO 34290
34536: POP
34537: POP
// if not target then
34538: LD_VAR 0 7
34542: NOT
34543: IFFALSE 34547
// continue ;
34545: GO 34097
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34547: LD_ADDR_VAR 0 8
34551: PUSH
34552: LD_EXP 112
34556: PUSH
34557: LD_VAR 0 2
34561: ARRAY
34562: PPUSH
34563: LD_INT 2
34565: PUSH
34566: LD_INT 3
34568: PUSH
34569: LD_INT 58
34571: PUSH
34572: EMPTY
34573: LIST
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: LD_INT 61
34581: PUSH
34582: EMPTY
34583: LIST
34584: PUSH
34585: LD_INT 33
34587: PUSH
34588: LD_INT 5
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 33
34597: PUSH
34598: LD_INT 3
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 2
34614: PUSH
34615: LD_INT 34
34617: PUSH
34618: LD_INT 32
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 34
34627: PUSH
34628: LD_INT 51
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 34
34637: PUSH
34638: LD_INT 12
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: LIST
34649: LIST
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PPUSH
34655: CALL_OW 72
34659: ST_TO_ADDR
// if not cargo then
34660: LD_VAR 0 8
34664: NOT
34665: IFFALSE 35371
// begin if mc_crates_collector [ i ] < 5 then
34667: LD_EXP 110
34671: PUSH
34672: LD_VAR 0 2
34676: ARRAY
34677: PUSH
34678: LD_INT 5
34680: LESS
34681: IFFALSE 35047
// begin if mc_ape [ i ] then
34683: LD_EXP 122
34687: PUSH
34688: LD_VAR 0 2
34692: ARRAY
34693: IFFALSE 34740
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34695: LD_ADDR_VAR 0 5
34699: PUSH
34700: LD_EXP 122
34704: PUSH
34705: LD_VAR 0 2
34709: ARRAY
34710: PPUSH
34711: LD_INT 25
34713: PUSH
34714: LD_INT 16
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PUSH
34721: LD_INT 24
34723: PUSH
34724: LD_INT 750
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PPUSH
34735: CALL_OW 72
34739: ST_TO_ADDR
// if not tmp then
34740: LD_VAR 0 5
34744: NOT
34745: IFFALSE 34792
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34747: LD_ADDR_VAR 0 5
34751: PUSH
34752: LD_EXP 93
34756: PUSH
34757: LD_VAR 0 2
34761: ARRAY
34762: PPUSH
34763: LD_INT 25
34765: PUSH
34766: LD_INT 2
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 24
34775: PUSH
34776: LD_INT 750
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PPUSH
34787: CALL_OW 72
34791: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34792: LD_EXP 122
34796: PUSH
34797: LD_VAR 0 2
34801: ARRAY
34802: PUSH
34803: LD_EXP 93
34807: PUSH
34808: LD_VAR 0 2
34812: ARRAY
34813: PPUSH
34814: LD_INT 25
34816: PUSH
34817: LD_INT 2
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 24
34826: PUSH
34827: LD_INT 750
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PPUSH
34838: CALL_OW 72
34842: AND
34843: PUSH
34844: LD_VAR 0 5
34848: PUSH
34849: LD_INT 5
34851: LESS
34852: AND
34853: IFFALSE 34935
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34855: LD_ADDR_VAR 0 3
34859: PUSH
34860: LD_EXP 93
34864: PUSH
34865: LD_VAR 0 2
34869: ARRAY
34870: PPUSH
34871: LD_INT 25
34873: PUSH
34874: LD_INT 2
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 24
34883: PUSH
34884: LD_INT 750
34886: PUSH
34887: EMPTY
34888: LIST
34889: LIST
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PPUSH
34895: CALL_OW 72
34899: PUSH
34900: FOR_IN
34901: IFFALSE 34933
// begin tmp := tmp union j ;
34903: LD_ADDR_VAR 0 5
34907: PUSH
34908: LD_VAR 0 5
34912: PUSH
34913: LD_VAR 0 3
34917: UNION
34918: ST_TO_ADDR
// if tmp >= 5 then
34919: LD_VAR 0 5
34923: PUSH
34924: LD_INT 5
34926: GREATEREQUAL
34927: IFFALSE 34931
// break ;
34929: GO 34933
// end ;
34931: GO 34900
34933: POP
34934: POP
// end ; if not tmp then
34935: LD_VAR 0 5
34939: NOT
34940: IFFALSE 34944
// continue ;
34942: GO 34097
// for j in tmp do
34944: LD_ADDR_VAR 0 3
34948: PUSH
34949: LD_VAR 0 5
34953: PUSH
34954: FOR_IN
34955: IFFALSE 35045
// if not GetTag ( j ) then
34957: LD_VAR 0 3
34961: PPUSH
34962: CALL_OW 110
34966: NOT
34967: IFFALSE 35043
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34969: LD_ADDR_EXP 110
34973: PUSH
34974: LD_EXP 110
34978: PPUSH
34979: LD_VAR 0 2
34983: PUSH
34984: LD_EXP 110
34988: PUSH
34989: LD_VAR 0 2
34993: ARRAY
34994: PUSH
34995: LD_INT 1
34997: PLUS
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PPUSH
35003: LD_VAR 0 3
35007: PPUSH
35008: CALL 56267 0 3
35012: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35013: LD_VAR 0 3
35017: PPUSH
35018: LD_INT 107
35020: PPUSH
35021: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35025: LD_EXP 110
35029: PUSH
35030: LD_VAR 0 2
35034: ARRAY
35035: PUSH
35036: LD_INT 5
35038: GREATEREQUAL
35039: IFFALSE 35043
// break ;
35041: GO 35045
// end ;
35043: GO 34954
35045: POP
35046: POP
// end ; if mc_crates_collector [ i ] and target then
35047: LD_EXP 110
35051: PUSH
35052: LD_VAR 0 2
35056: ARRAY
35057: PUSH
35058: LD_VAR 0 7
35062: AND
35063: IFFALSE 35369
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35065: LD_EXP 110
35069: PUSH
35070: LD_VAR 0 2
35074: ARRAY
35075: PUSH
35076: LD_VAR 0 7
35080: PUSH
35081: LD_INT 1
35083: ARRAY
35084: LESS
35085: IFFALSE 35105
// tmp := mc_crates_collector [ i ] else
35087: LD_ADDR_VAR 0 5
35091: PUSH
35092: LD_EXP 110
35096: PUSH
35097: LD_VAR 0 2
35101: ARRAY
35102: ST_TO_ADDR
35103: GO 35119
// tmp := target [ 1 ] ;
35105: LD_ADDR_VAR 0 5
35109: PUSH
35110: LD_VAR 0 7
35114: PUSH
35115: LD_INT 1
35117: ARRAY
35118: ST_TO_ADDR
// k := 0 ;
35119: LD_ADDR_VAR 0 4
35123: PUSH
35124: LD_INT 0
35126: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35127: LD_ADDR_VAR 0 3
35131: PUSH
35132: LD_EXP 110
35136: PUSH
35137: LD_VAR 0 2
35141: ARRAY
35142: PUSH
35143: FOR_IN
35144: IFFALSE 35367
// begin k := k + 1 ;
35146: LD_ADDR_VAR 0 4
35150: PUSH
35151: LD_VAR 0 4
35155: PUSH
35156: LD_INT 1
35158: PLUS
35159: ST_TO_ADDR
// if k > tmp then
35160: LD_VAR 0 4
35164: PUSH
35165: LD_VAR 0 5
35169: GREATER
35170: IFFALSE 35174
// break ;
35172: GO 35367
// if not GetClass ( j ) in [ 2 , 16 ] then
35174: LD_VAR 0 3
35178: PPUSH
35179: CALL_OW 257
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: LD_INT 16
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: IN
35194: NOT
35195: IFFALSE 35248
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35197: LD_ADDR_EXP 110
35201: PUSH
35202: LD_EXP 110
35206: PPUSH
35207: LD_VAR 0 2
35211: PPUSH
35212: LD_EXP 110
35216: PUSH
35217: LD_VAR 0 2
35221: ARRAY
35222: PUSH
35223: LD_VAR 0 3
35227: DIFF
35228: PPUSH
35229: CALL_OW 1
35233: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35234: LD_VAR 0 3
35238: PPUSH
35239: LD_INT 0
35241: PPUSH
35242: CALL_OW 109
// continue ;
35246: GO 35143
// end ; if IsInUnit ( j ) then
35248: LD_VAR 0 3
35252: PPUSH
35253: CALL_OW 310
35257: IFFALSE 35268
// ComExitBuilding ( j ) ;
35259: LD_VAR 0 3
35263: PPUSH
35264: CALL_OW 122
// wait ( 3 ) ;
35268: LD_INT 3
35270: PPUSH
35271: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35275: LD_VAR 0 3
35279: PPUSH
35280: CALL_OW 314
35284: PUSH
35285: LD_VAR 0 6
35289: PPUSH
35290: LD_VAR 0 7
35294: PUSH
35295: LD_INT 2
35297: ARRAY
35298: PPUSH
35299: LD_VAR 0 7
35303: PUSH
35304: LD_INT 3
35306: ARRAY
35307: PPUSH
35308: LD_INT 30
35310: PPUSH
35311: CALL 57163 0 4
35315: PUSH
35316: LD_INT 4
35318: ARRAY
35319: AND
35320: IFFALSE 35338
// ComStandNearbyBuilding ( j , depot ) else
35322: LD_VAR 0 3
35326: PPUSH
35327: LD_VAR 0 9
35331: PPUSH
35332: CALL 52845 0 2
35336: GO 35365
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35338: LD_VAR 0 3
35342: PPUSH
35343: LD_VAR 0 7
35347: PUSH
35348: LD_INT 2
35350: ARRAY
35351: PPUSH
35352: LD_VAR 0 7
35356: PUSH
35357: LD_INT 3
35359: ARRAY
35360: PPUSH
35361: CALL_OW 117
// end ;
35365: GO 35143
35367: POP
35368: POP
// end ; end else
35369: GO 35901
// begin for j in cargo do
35371: LD_ADDR_VAR 0 3
35375: PUSH
35376: LD_VAR 0 8
35380: PUSH
35381: FOR_IN
35382: IFFALSE 35899
// begin if GetTag ( j ) <> 0 then
35384: LD_VAR 0 3
35388: PPUSH
35389: CALL_OW 110
35393: PUSH
35394: LD_INT 0
35396: NONEQUAL
35397: IFFALSE 35401
// continue ;
35399: GO 35381
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35401: LD_VAR 0 3
35405: PPUSH
35406: CALL_OW 256
35410: PUSH
35411: LD_INT 1000
35413: LESS
35414: PUSH
35415: LD_VAR 0 3
35419: PPUSH
35420: LD_EXP 117
35424: PUSH
35425: LD_VAR 0 2
35429: ARRAY
35430: PPUSH
35431: CALL_OW 308
35435: NOT
35436: AND
35437: IFFALSE 35459
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35439: LD_VAR 0 3
35443: PPUSH
35444: LD_EXP 117
35448: PUSH
35449: LD_VAR 0 2
35453: ARRAY
35454: PPUSH
35455: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35459: LD_VAR 0 3
35463: PPUSH
35464: CALL_OW 256
35468: PUSH
35469: LD_INT 1000
35471: LESS
35472: PUSH
35473: LD_VAR 0 3
35477: PPUSH
35478: LD_EXP 117
35482: PUSH
35483: LD_VAR 0 2
35487: ARRAY
35488: PPUSH
35489: CALL_OW 308
35493: AND
35494: IFFALSE 35498
// continue ;
35496: GO 35381
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35498: LD_VAR 0 3
35502: PPUSH
35503: CALL_OW 262
35507: PUSH
35508: LD_INT 2
35510: EQUAL
35511: PUSH
35512: LD_VAR 0 3
35516: PPUSH
35517: CALL_OW 261
35521: PUSH
35522: LD_INT 15
35524: LESS
35525: AND
35526: IFFALSE 35530
// continue ;
35528: GO 35381
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
35530: LD_VAR 0 3
35534: PPUSH
35535: CALL_OW 262
35539: PUSH
35540: LD_INT 1
35542: EQUAL
35543: PUSH
35544: LD_VAR 0 3
35548: PPUSH
35549: CALL_OW 261
35553: PUSH
35554: LD_INT 10
35556: LESS
35557: AND
35558: IFFALSE 35838
// begin if not depot then
35560: LD_VAR 0 9
35564: NOT
35565: IFFALSE 35569
// continue ;
35567: GO 35381
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35569: LD_VAR 0 3
35573: PPUSH
35574: LD_VAR 0 9
35578: PPUSH
35579: LD_VAR 0 3
35583: PPUSH
35584: CALL_OW 74
35588: PPUSH
35589: CALL_OW 296
35593: PUSH
35594: LD_INT 6
35596: LESS
35597: IFFALSE 35613
// SetFuel ( j , 100 ) else
35599: LD_VAR 0 3
35603: PPUSH
35604: LD_INT 100
35606: PPUSH
35607: CALL_OW 240
35611: GO 35838
// if GetFuel ( j ) = 0 then
35613: LD_VAR 0 3
35617: PPUSH
35618: CALL_OW 261
35622: PUSH
35623: LD_INT 0
35625: EQUAL
35626: IFFALSE 35838
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35628: LD_ADDR_EXP 112
35632: PUSH
35633: LD_EXP 112
35637: PPUSH
35638: LD_VAR 0 2
35642: PPUSH
35643: LD_EXP 112
35647: PUSH
35648: LD_VAR 0 2
35652: ARRAY
35653: PUSH
35654: LD_VAR 0 3
35658: DIFF
35659: PPUSH
35660: CALL_OW 1
35664: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35665: LD_VAR 0 3
35669: PPUSH
35670: CALL_OW 263
35674: PUSH
35675: LD_INT 1
35677: EQUAL
35678: IFFALSE 35694
// ComExitVehicle ( IsInUnit ( j ) ) ;
35680: LD_VAR 0 3
35684: PPUSH
35685: CALL_OW 310
35689: PPUSH
35690: CALL_OW 121
// if GetControl ( j ) = control_remote then
35694: LD_VAR 0 3
35698: PPUSH
35699: CALL_OW 263
35703: PUSH
35704: LD_INT 2
35706: EQUAL
35707: IFFALSE 35718
// ComUnlink ( j ) ;
35709: LD_VAR 0 3
35713: PPUSH
35714: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35718: LD_ADDR_VAR 0 10
35722: PUSH
35723: LD_VAR 0 2
35727: PPUSH
35728: LD_INT 3
35730: PPUSH
35731: CALL 45330 0 2
35735: ST_TO_ADDR
// if fac then
35736: LD_VAR 0 10
35740: IFFALSE 35836
// begin for k in fac do
35742: LD_ADDR_VAR 0 4
35746: PUSH
35747: LD_VAR 0 10
35751: PUSH
35752: FOR_IN
35753: IFFALSE 35834
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35755: LD_ADDR_VAR 0 11
35759: PUSH
35760: LD_VAR 0 10
35764: PPUSH
35765: LD_VAR 0 3
35769: PPUSH
35770: CALL_OW 265
35774: PPUSH
35775: LD_VAR 0 3
35779: PPUSH
35780: CALL_OW 262
35784: PPUSH
35785: LD_VAR 0 3
35789: PPUSH
35790: CALL_OW 263
35794: PPUSH
35795: LD_VAR 0 3
35799: PPUSH
35800: CALL_OW 264
35804: PPUSH
35805: CALL 53763 0 5
35809: ST_TO_ADDR
// if components then
35810: LD_VAR 0 11
35814: IFFALSE 35832
// begin MC_InsertProduceList ( i , components ) ;
35816: LD_VAR 0 2
35820: PPUSH
35821: LD_VAR 0 11
35825: PPUSH
35826: CALL 44875 0 2
// break ;
35830: GO 35834
// end ; end ;
35832: GO 35752
35834: POP
35835: POP
// end ; continue ;
35836: GO 35381
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35838: LD_VAR 0 3
35842: PPUSH
35843: LD_INT 1
35845: PPUSH
35846: CALL_OW 289
35850: PUSH
35851: LD_INT 100
35853: LESS
35854: PUSH
35855: LD_VAR 0 3
35859: PPUSH
35860: CALL_OW 314
35864: NOT
35865: AND
35866: IFFALSE 35895
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35868: LD_VAR 0 3
35872: PPUSH
35873: LD_VAR 0 7
35877: PUSH
35878: LD_INT 2
35880: ARRAY
35881: PPUSH
35882: LD_VAR 0 7
35886: PUSH
35887: LD_INT 3
35889: ARRAY
35890: PPUSH
35891: CALL_OW 117
// break ;
35895: GO 35899
// end ;
35897: GO 35381
35899: POP
35900: POP
// end ; end ;
35901: GO 34097
35903: POP
35904: POP
// end ;
35905: LD_VAR 0 1
35909: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35910: LD_INT 0
35912: PPUSH
35913: PPUSH
35914: PPUSH
35915: PPUSH
// if not mc_bases then
35916: LD_EXP 93
35920: NOT
35921: IFFALSE 35925
// exit ;
35923: GO 36086
// for i = 1 to mc_bases do
35925: LD_ADDR_VAR 0 2
35929: PUSH
35930: DOUBLE
35931: LD_INT 1
35933: DEC
35934: ST_TO_ADDR
35935: LD_EXP 93
35939: PUSH
35940: FOR_TO
35941: IFFALSE 36084
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35943: LD_ADDR_VAR 0 4
35947: PUSH
35948: LD_EXP 112
35952: PUSH
35953: LD_VAR 0 2
35957: ARRAY
35958: PUSH
35959: LD_EXP 115
35963: PUSH
35964: LD_VAR 0 2
35968: ARRAY
35969: UNION
35970: PPUSH
35971: LD_INT 33
35973: PUSH
35974: LD_INT 2
35976: PUSH
35977: EMPTY
35978: LIST
35979: LIST
35980: PPUSH
35981: CALL_OW 72
35985: ST_TO_ADDR
// if tmp then
35986: LD_VAR 0 4
35990: IFFALSE 36082
// for j in tmp do
35992: LD_ADDR_VAR 0 3
35996: PUSH
35997: LD_VAR 0 4
36001: PUSH
36002: FOR_IN
36003: IFFALSE 36080
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36005: LD_VAR 0 3
36009: PPUSH
36010: CALL_OW 312
36014: NOT
36015: PUSH
36016: LD_VAR 0 3
36020: PPUSH
36021: CALL_OW 256
36025: PUSH
36026: LD_INT 250
36028: GREATEREQUAL
36029: AND
36030: IFFALSE 36043
// Connect ( j ) else
36032: LD_VAR 0 3
36036: PPUSH
36037: CALL 59238 0 1
36041: GO 36078
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36043: LD_VAR 0 3
36047: PPUSH
36048: CALL_OW 256
36052: PUSH
36053: LD_INT 250
36055: LESS
36056: PUSH
36057: LD_VAR 0 3
36061: PPUSH
36062: CALL_OW 312
36066: AND
36067: IFFALSE 36078
// ComUnlink ( j ) ;
36069: LD_VAR 0 3
36073: PPUSH
36074: CALL_OW 136
36078: GO 36002
36080: POP
36081: POP
// end ;
36082: GO 35940
36084: POP
36085: POP
// end ;
36086: LD_VAR 0 1
36090: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36091: LD_INT 0
36093: PPUSH
36094: PPUSH
36095: PPUSH
36096: PPUSH
36097: PPUSH
// if not mc_bases then
36098: LD_EXP 93
36102: NOT
36103: IFFALSE 36107
// exit ;
36105: GO 36552
// for i = 1 to mc_bases do
36107: LD_ADDR_VAR 0 2
36111: PUSH
36112: DOUBLE
36113: LD_INT 1
36115: DEC
36116: ST_TO_ADDR
36117: LD_EXP 93
36121: PUSH
36122: FOR_TO
36123: IFFALSE 36550
// begin if not mc_produce [ i ] then
36125: LD_EXP 114
36129: PUSH
36130: LD_VAR 0 2
36134: ARRAY
36135: NOT
36136: IFFALSE 36140
// continue ;
36138: GO 36122
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36140: LD_ADDR_VAR 0 5
36144: PUSH
36145: LD_EXP 93
36149: PUSH
36150: LD_VAR 0 2
36154: ARRAY
36155: PPUSH
36156: LD_INT 30
36158: PUSH
36159: LD_INT 3
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PPUSH
36166: CALL_OW 72
36170: ST_TO_ADDR
// if not fac then
36171: LD_VAR 0 5
36175: NOT
36176: IFFALSE 36180
// continue ;
36178: GO 36122
// for j in fac do
36180: LD_ADDR_VAR 0 3
36184: PUSH
36185: LD_VAR 0 5
36189: PUSH
36190: FOR_IN
36191: IFFALSE 36546
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36193: LD_VAR 0 3
36197: PPUSH
36198: CALL_OW 461
36202: PUSH
36203: LD_INT 2
36205: NONEQUAL
36206: PUSH
36207: LD_VAR 0 3
36211: PPUSH
36212: LD_INT 15
36214: PPUSH
36215: CALL 58866 0 2
36219: PUSH
36220: LD_INT 4
36222: ARRAY
36223: OR
36224: IFFALSE 36228
// continue ;
36226: GO 36190
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36228: LD_VAR 0 3
36232: PPUSH
36233: LD_EXP 114
36237: PUSH
36238: LD_VAR 0 2
36242: ARRAY
36243: PUSH
36244: LD_INT 1
36246: ARRAY
36247: PUSH
36248: LD_INT 1
36250: ARRAY
36251: PPUSH
36252: LD_EXP 114
36256: PUSH
36257: LD_VAR 0 2
36261: ARRAY
36262: PUSH
36263: LD_INT 1
36265: ARRAY
36266: PUSH
36267: LD_INT 2
36269: ARRAY
36270: PPUSH
36271: LD_EXP 114
36275: PUSH
36276: LD_VAR 0 2
36280: ARRAY
36281: PUSH
36282: LD_INT 1
36284: ARRAY
36285: PUSH
36286: LD_INT 3
36288: ARRAY
36289: PPUSH
36290: LD_EXP 114
36294: PUSH
36295: LD_VAR 0 2
36299: ARRAY
36300: PUSH
36301: LD_INT 1
36303: ARRAY
36304: PUSH
36305: LD_INT 4
36307: ARRAY
36308: PPUSH
36309: CALL_OW 448
36313: PUSH
36314: LD_VAR 0 3
36318: PPUSH
36319: LD_EXP 114
36323: PUSH
36324: LD_VAR 0 2
36328: ARRAY
36329: PUSH
36330: LD_INT 1
36332: ARRAY
36333: PUSH
36334: LD_INT 1
36336: ARRAY
36337: PUSH
36338: LD_EXP 114
36342: PUSH
36343: LD_VAR 0 2
36347: ARRAY
36348: PUSH
36349: LD_INT 1
36351: ARRAY
36352: PUSH
36353: LD_INT 2
36355: ARRAY
36356: PUSH
36357: LD_EXP 114
36361: PUSH
36362: LD_VAR 0 2
36366: ARRAY
36367: PUSH
36368: LD_INT 1
36370: ARRAY
36371: PUSH
36372: LD_INT 3
36374: ARRAY
36375: PUSH
36376: LD_EXP 114
36380: PUSH
36381: LD_VAR 0 2
36385: ARRAY
36386: PUSH
36387: LD_INT 1
36389: ARRAY
36390: PUSH
36391: LD_INT 4
36393: ARRAY
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: PPUSH
36401: CALL 62633 0 2
36405: AND
36406: IFFALSE 36544
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36408: LD_VAR 0 3
36412: PPUSH
36413: LD_EXP 114
36417: PUSH
36418: LD_VAR 0 2
36422: ARRAY
36423: PUSH
36424: LD_INT 1
36426: ARRAY
36427: PUSH
36428: LD_INT 1
36430: ARRAY
36431: PPUSH
36432: LD_EXP 114
36436: PUSH
36437: LD_VAR 0 2
36441: ARRAY
36442: PUSH
36443: LD_INT 1
36445: ARRAY
36446: PUSH
36447: LD_INT 2
36449: ARRAY
36450: PPUSH
36451: LD_EXP 114
36455: PUSH
36456: LD_VAR 0 2
36460: ARRAY
36461: PUSH
36462: LD_INT 1
36464: ARRAY
36465: PUSH
36466: LD_INT 3
36468: ARRAY
36469: PPUSH
36470: LD_EXP 114
36474: PUSH
36475: LD_VAR 0 2
36479: ARRAY
36480: PUSH
36481: LD_INT 1
36483: ARRAY
36484: PUSH
36485: LD_INT 4
36487: ARRAY
36488: PPUSH
36489: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36493: LD_ADDR_VAR 0 4
36497: PUSH
36498: LD_EXP 114
36502: PUSH
36503: LD_VAR 0 2
36507: ARRAY
36508: PPUSH
36509: LD_INT 1
36511: PPUSH
36512: CALL_OW 3
36516: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36517: LD_ADDR_EXP 114
36521: PUSH
36522: LD_EXP 114
36526: PPUSH
36527: LD_VAR 0 2
36531: PPUSH
36532: LD_VAR 0 4
36536: PPUSH
36537: CALL_OW 1
36541: ST_TO_ADDR
// break ;
36542: GO 36546
// end ; end ;
36544: GO 36190
36546: POP
36547: POP
// end ;
36548: GO 36122
36550: POP
36551: POP
// end ;
36552: LD_VAR 0 1
36556: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36557: LD_INT 0
36559: PPUSH
36560: PPUSH
36561: PPUSH
// if not mc_bases then
36562: LD_EXP 93
36566: NOT
36567: IFFALSE 36571
// exit ;
36569: GO 36660
// for i = 1 to mc_bases do
36571: LD_ADDR_VAR 0 2
36575: PUSH
36576: DOUBLE
36577: LD_INT 1
36579: DEC
36580: ST_TO_ADDR
36581: LD_EXP 93
36585: PUSH
36586: FOR_TO
36587: IFFALSE 36658
// begin if mc_attack [ i ] then
36589: LD_EXP 113
36593: PUSH
36594: LD_VAR 0 2
36598: ARRAY
36599: IFFALSE 36656
// begin tmp := mc_attack [ i ] [ 1 ] ;
36601: LD_ADDR_VAR 0 3
36605: PUSH
36606: LD_EXP 113
36610: PUSH
36611: LD_VAR 0 2
36615: ARRAY
36616: PUSH
36617: LD_INT 1
36619: ARRAY
36620: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36621: LD_ADDR_EXP 113
36625: PUSH
36626: LD_EXP 113
36630: PPUSH
36631: LD_VAR 0 2
36635: PPUSH
36636: EMPTY
36637: PPUSH
36638: CALL_OW 1
36642: ST_TO_ADDR
// Attack ( tmp ) ;
36643: LD_VAR 0 3
36647: PPUSH
36648: CALL 107342 0 1
// exit ;
36652: POP
36653: POP
36654: GO 36660
// end ; end ;
36656: GO 36586
36658: POP
36659: POP
// end ;
36660: LD_VAR 0 1
36664: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36665: LD_INT 0
36667: PPUSH
36668: PPUSH
36669: PPUSH
36670: PPUSH
36671: PPUSH
36672: PPUSH
36673: PPUSH
// if not mc_bases then
36674: LD_EXP 93
36678: NOT
36679: IFFALSE 36683
// exit ;
36681: GO 37393
// for i = 1 to mc_bases do
36683: LD_ADDR_VAR 0 2
36687: PUSH
36688: DOUBLE
36689: LD_INT 1
36691: DEC
36692: ST_TO_ADDR
36693: LD_EXP 93
36697: PUSH
36698: FOR_TO
36699: IFFALSE 37391
// begin if not mc_bases [ i ] then
36701: LD_EXP 93
36705: PUSH
36706: LD_VAR 0 2
36710: ARRAY
36711: NOT
36712: IFFALSE 36716
// continue ;
36714: GO 36698
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36716: LD_ADDR_VAR 0 7
36720: PUSH
36721: LD_EXP 93
36725: PUSH
36726: LD_VAR 0 2
36730: ARRAY
36731: PUSH
36732: LD_INT 1
36734: ARRAY
36735: PPUSH
36736: CALL 53067 0 1
36740: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36741: LD_ADDR_EXP 116
36745: PUSH
36746: LD_EXP 116
36750: PPUSH
36751: LD_VAR 0 2
36755: PPUSH
36756: LD_EXP 93
36760: PUSH
36761: LD_VAR 0 2
36765: ARRAY
36766: PUSH
36767: LD_INT 1
36769: ARRAY
36770: PPUSH
36771: CALL_OW 255
36775: PPUSH
36776: LD_EXP 118
36780: PUSH
36781: LD_VAR 0 2
36785: ARRAY
36786: PPUSH
36787: CALL 53032 0 2
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// if not mc_scan [ i ] then
36797: LD_EXP 116
36801: PUSH
36802: LD_VAR 0 2
36806: ARRAY
36807: NOT
36808: IFFALSE 36986
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
36810: LD_ADDR_EXP 136
36814: PUSH
36815: LD_EXP 136
36819: PPUSH
36820: LD_VAR 0 2
36824: PPUSH
36825: LD_INT 0
36827: PPUSH
36828: CALL_OW 1
36832: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36833: LD_ADDR_VAR 0 4
36837: PUSH
36838: LD_EXP 93
36842: PUSH
36843: LD_VAR 0 2
36847: ARRAY
36848: PPUSH
36849: LD_INT 2
36851: PUSH
36852: LD_INT 25
36854: PUSH
36855: LD_INT 5
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: PUSH
36862: LD_INT 25
36864: PUSH
36865: LD_INT 8
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 25
36874: PUSH
36875: LD_INT 9
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: PPUSH
36888: CALL_OW 72
36892: ST_TO_ADDR
// if not tmp then
36893: LD_VAR 0 4
36897: NOT
36898: IFFALSE 36902
// continue ;
36900: GO 36698
// for j in tmp do
36902: LD_ADDR_VAR 0 3
36906: PUSH
36907: LD_VAR 0 4
36911: PUSH
36912: FOR_IN
36913: IFFALSE 36984
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36915: LD_VAR 0 3
36919: PPUSH
36920: CALL_OW 310
36924: PPUSH
36925: CALL_OW 266
36929: PUSH
36930: LD_INT 5
36932: EQUAL
36933: PUSH
36934: LD_VAR 0 3
36938: PPUSH
36939: CALL_OW 257
36943: PUSH
36944: LD_INT 1
36946: EQUAL
36947: AND
36948: PUSH
36949: LD_VAR 0 3
36953: PPUSH
36954: CALL_OW 459
36958: NOT
36959: AND
36960: PUSH
36961: LD_VAR 0 7
36965: AND
36966: IFFALSE 36982
// ComChangeProfession ( j , class ) ;
36968: LD_VAR 0 3
36972: PPUSH
36973: LD_VAR 0 7
36977: PPUSH
36978: CALL_OW 123
36982: GO 36912
36984: POP
36985: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
36986: LD_EXP 116
36990: PUSH
36991: LD_VAR 0 2
36995: ARRAY
36996: PUSH
36997: LD_EXP 136
37001: PUSH
37002: LD_VAR 0 2
37006: ARRAY
37007: NOT
37008: AND
37009: PUSH
37010: LD_EXP 115
37014: PUSH
37015: LD_VAR 0 2
37019: ARRAY
37020: NOT
37021: AND
37022: IFFALSE 37273
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37024: LD_ADDR_EXP 136
37028: PUSH
37029: LD_EXP 136
37033: PPUSH
37034: LD_VAR 0 2
37038: PPUSH
37039: LD_INT 1
37041: PPUSH
37042: CALL_OW 1
37046: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37047: LD_ADDR_VAR 0 4
37051: PUSH
37052: LD_EXP 93
37056: PUSH
37057: LD_VAR 0 2
37061: ARRAY
37062: PPUSH
37063: LD_INT 2
37065: PUSH
37066: LD_INT 25
37068: PUSH
37069: LD_INT 1
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: PUSH
37076: LD_INT 25
37078: PUSH
37079: LD_INT 5
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 25
37088: PUSH
37089: LD_INT 8
37091: PUSH
37092: EMPTY
37093: LIST
37094: LIST
37095: PUSH
37096: LD_INT 25
37098: PUSH
37099: LD_INT 9
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: LIST
37110: LIST
37111: LIST
37112: PPUSH
37113: CALL_OW 72
37117: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37118: LD_ADDR_VAR 0 4
37122: PUSH
37123: LD_VAR 0 4
37127: PUSH
37128: LD_VAR 0 4
37132: PPUSH
37133: LD_INT 18
37135: PPUSH
37136: CALL 85536 0 2
37140: DIFF
37141: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37142: LD_VAR 0 4
37146: NOT
37147: PUSH
37148: LD_EXP 93
37152: PUSH
37153: LD_VAR 0 2
37157: ARRAY
37158: PPUSH
37159: LD_INT 2
37161: PUSH
37162: LD_INT 30
37164: PUSH
37165: LD_INT 4
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 30
37174: PUSH
37175: LD_INT 5
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: LIST
37186: PPUSH
37187: CALL_OW 72
37191: NOT
37192: AND
37193: IFFALSE 37255
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37195: LD_ADDR_VAR 0 4
37199: PUSH
37200: LD_EXP 93
37204: PUSH
37205: LD_VAR 0 2
37209: ARRAY
37210: PPUSH
37211: LD_INT 2
37213: PUSH
37214: LD_INT 25
37216: PUSH
37217: LD_INT 2
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 25
37226: PUSH
37227: LD_INT 3
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: LD_INT 25
37236: PUSH
37237: LD_INT 4
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: PPUSH
37250: CALL_OW 72
37254: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37255: LD_VAR 0 2
37259: PPUSH
37260: LD_VAR 0 4
37264: PPUSH
37265: CALL 112051 0 2
// exit ;
37269: POP
37270: POP
37271: GO 37393
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37273: LD_EXP 116
37277: PUSH
37278: LD_VAR 0 2
37282: ARRAY
37283: PUSH
37284: LD_EXP 136
37288: PUSH
37289: LD_VAR 0 2
37293: ARRAY
37294: NOT
37295: AND
37296: PUSH
37297: LD_EXP 115
37301: PUSH
37302: LD_VAR 0 2
37306: ARRAY
37307: AND
37308: IFFALSE 37389
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37310: LD_ADDR_EXP 136
37314: PUSH
37315: LD_EXP 136
37319: PPUSH
37320: LD_VAR 0 2
37324: PPUSH
37325: LD_INT 1
37327: PPUSH
37328: CALL_OW 1
37332: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
37333: LD_ADDR_VAR 0 4
37337: PUSH
37338: LD_EXP 115
37342: PUSH
37343: LD_VAR 0 2
37347: ARRAY
37348: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37349: LD_ADDR_EXP 115
37353: PUSH
37354: LD_EXP 115
37358: PPUSH
37359: LD_VAR 0 2
37363: PPUSH
37364: EMPTY
37365: PPUSH
37366: CALL_OW 1
37370: ST_TO_ADDR
// Defend ( i , tmp ) ;
37371: LD_VAR 0 2
37375: PPUSH
37376: LD_VAR 0 4
37380: PPUSH
37381: CALL 112621 0 2
// exit ;
37385: POP
37386: POP
37387: GO 37393
// end ; end ;
37389: GO 36698
37391: POP
37392: POP
// end ;
37393: LD_VAR 0 1
37397: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
37398: LD_INT 0
37400: PPUSH
37401: PPUSH
37402: PPUSH
37403: PPUSH
37404: PPUSH
37405: PPUSH
37406: PPUSH
37407: PPUSH
37408: PPUSH
37409: PPUSH
37410: PPUSH
// if not mc_bases then
37411: LD_EXP 93
37415: NOT
37416: IFFALSE 37420
// exit ;
37418: GO 38507
// for i = 1 to mc_bases do
37420: LD_ADDR_VAR 0 2
37424: PUSH
37425: DOUBLE
37426: LD_INT 1
37428: DEC
37429: ST_TO_ADDR
37430: LD_EXP 93
37434: PUSH
37435: FOR_TO
37436: IFFALSE 38505
// begin tmp := mc_lab [ i ] ;
37438: LD_ADDR_VAR 0 6
37442: PUSH
37443: LD_EXP 126
37447: PUSH
37448: LD_VAR 0 2
37452: ARRAY
37453: ST_TO_ADDR
// if not tmp then
37454: LD_VAR 0 6
37458: NOT
37459: IFFALSE 37463
// continue ;
37461: GO 37435
// idle_lab := 0 ;
37463: LD_ADDR_VAR 0 11
37467: PUSH
37468: LD_INT 0
37470: ST_TO_ADDR
// for j in tmp do
37471: LD_ADDR_VAR 0 3
37475: PUSH
37476: LD_VAR 0 6
37480: PUSH
37481: FOR_IN
37482: IFFALSE 38501
// begin researching := false ;
37484: LD_ADDR_VAR 0 10
37488: PUSH
37489: LD_INT 0
37491: ST_TO_ADDR
// side := GetSide ( j ) ;
37492: LD_ADDR_VAR 0 4
37496: PUSH
37497: LD_VAR 0 3
37501: PPUSH
37502: CALL_OW 255
37506: ST_TO_ADDR
// if not mc_tech [ side ] then
37507: LD_EXP 120
37511: PUSH
37512: LD_VAR 0 4
37516: ARRAY
37517: NOT
37518: IFFALSE 37522
// continue ;
37520: GO 37481
// if BuildingStatus ( j ) = bs_idle then
37522: LD_VAR 0 3
37526: PPUSH
37527: CALL_OW 461
37531: PUSH
37532: LD_INT 2
37534: EQUAL
37535: IFFALSE 37723
// begin if idle_lab and UnitsInside ( j ) < 6 then
37537: LD_VAR 0 11
37541: PUSH
37542: LD_VAR 0 3
37546: PPUSH
37547: CALL_OW 313
37551: PUSH
37552: LD_INT 6
37554: LESS
37555: AND
37556: IFFALSE 37627
// begin tmp2 := UnitsInside ( idle_lab ) ;
37558: LD_ADDR_VAR 0 9
37562: PUSH
37563: LD_VAR 0 11
37567: PPUSH
37568: CALL_OW 313
37572: ST_TO_ADDR
// if tmp2 then
37573: LD_VAR 0 9
37577: IFFALSE 37619
// for x in tmp2 do
37579: LD_ADDR_VAR 0 7
37583: PUSH
37584: LD_VAR 0 9
37588: PUSH
37589: FOR_IN
37590: IFFALSE 37617
// begin ComExitBuilding ( x ) ;
37592: LD_VAR 0 7
37596: PPUSH
37597: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37601: LD_VAR 0 7
37605: PPUSH
37606: LD_VAR 0 3
37610: PPUSH
37611: CALL_OW 180
// end ;
37615: GO 37589
37617: POP
37618: POP
// idle_lab := 0 ;
37619: LD_ADDR_VAR 0 11
37623: PUSH
37624: LD_INT 0
37626: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
37627: LD_ADDR_VAR 0 5
37631: PUSH
37632: LD_EXP 120
37636: PUSH
37637: LD_VAR 0 4
37641: ARRAY
37642: PUSH
37643: FOR_IN
37644: IFFALSE 37704
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
37646: LD_VAR 0 3
37650: PPUSH
37651: LD_VAR 0 5
37655: PPUSH
37656: CALL_OW 430
37660: PUSH
37661: LD_VAR 0 4
37665: PPUSH
37666: LD_VAR 0 5
37670: PPUSH
37671: CALL 52137 0 2
37675: AND
37676: IFFALSE 37702
// begin researching := true ;
37678: LD_ADDR_VAR 0 10
37682: PUSH
37683: LD_INT 1
37685: ST_TO_ADDR
// ComResearch ( j , t ) ;
37686: LD_VAR 0 3
37690: PPUSH
37691: LD_VAR 0 5
37695: PPUSH
37696: CALL_OW 124
// break ;
37700: GO 37704
// end ;
37702: GO 37643
37704: POP
37705: POP
// if not researching then
37706: LD_VAR 0 10
37710: NOT
37711: IFFALSE 37723
// idle_lab := j ;
37713: LD_ADDR_VAR 0 11
37717: PUSH
37718: LD_VAR 0 3
37722: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37723: LD_VAR 0 3
37727: PPUSH
37728: CALL_OW 461
37732: PUSH
37733: LD_INT 10
37735: EQUAL
37736: IFFALSE 38324
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37738: LD_EXP 122
37742: PUSH
37743: LD_VAR 0 2
37747: ARRAY
37748: NOT
37749: PUSH
37750: LD_EXP 123
37754: PUSH
37755: LD_VAR 0 2
37759: ARRAY
37760: NOT
37761: AND
37762: PUSH
37763: LD_EXP 120
37767: PUSH
37768: LD_VAR 0 4
37772: ARRAY
37773: PUSH
37774: LD_INT 1
37776: GREATER
37777: AND
37778: IFFALSE 37909
// begin ComCancel ( j ) ;
37780: LD_VAR 0 3
37784: PPUSH
37785: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37789: LD_ADDR_EXP 120
37793: PUSH
37794: LD_EXP 120
37798: PPUSH
37799: LD_VAR 0 4
37803: PPUSH
37804: LD_EXP 120
37808: PUSH
37809: LD_VAR 0 4
37813: ARRAY
37814: PPUSH
37815: LD_EXP 120
37819: PUSH
37820: LD_VAR 0 4
37824: ARRAY
37825: PUSH
37826: LD_INT 1
37828: MINUS
37829: PPUSH
37830: LD_EXP 120
37834: PUSH
37835: LD_VAR 0 4
37839: ARRAY
37840: PPUSH
37841: LD_INT 0
37843: PPUSH
37844: CALL 55685 0 4
37848: PPUSH
37849: CALL_OW 1
37853: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37854: LD_ADDR_EXP 120
37858: PUSH
37859: LD_EXP 120
37863: PPUSH
37864: LD_VAR 0 4
37868: PPUSH
37869: LD_EXP 120
37873: PUSH
37874: LD_VAR 0 4
37878: ARRAY
37879: PPUSH
37880: LD_EXP 120
37884: PUSH
37885: LD_VAR 0 4
37889: ARRAY
37890: PPUSH
37891: LD_INT 1
37893: PPUSH
37894: LD_INT 0
37896: PPUSH
37897: CALL 55685 0 4
37901: PPUSH
37902: CALL_OW 1
37906: ST_TO_ADDR
// continue ;
37907: GO 37481
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37909: LD_EXP 122
37913: PUSH
37914: LD_VAR 0 2
37918: ARRAY
37919: PUSH
37920: LD_EXP 123
37924: PUSH
37925: LD_VAR 0 2
37929: ARRAY
37930: NOT
37931: AND
37932: IFFALSE 38059
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37934: LD_ADDR_EXP 123
37938: PUSH
37939: LD_EXP 123
37943: PPUSH
37944: LD_VAR 0 2
37948: PUSH
37949: LD_EXP 123
37953: PUSH
37954: LD_VAR 0 2
37958: ARRAY
37959: PUSH
37960: LD_INT 1
37962: PLUS
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PPUSH
37968: LD_EXP 122
37972: PUSH
37973: LD_VAR 0 2
37977: ARRAY
37978: PUSH
37979: LD_INT 1
37981: ARRAY
37982: PPUSH
37983: CALL 56267 0 3
37987: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37988: LD_EXP 122
37992: PUSH
37993: LD_VAR 0 2
37997: ARRAY
37998: PUSH
37999: LD_INT 1
38001: ARRAY
38002: PPUSH
38003: LD_INT 112
38005: PPUSH
38006: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38010: LD_ADDR_VAR 0 9
38014: PUSH
38015: LD_EXP 122
38019: PUSH
38020: LD_VAR 0 2
38024: ARRAY
38025: PPUSH
38026: LD_INT 1
38028: PPUSH
38029: CALL_OW 3
38033: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38034: LD_ADDR_EXP 122
38038: PUSH
38039: LD_EXP 122
38043: PPUSH
38044: LD_VAR 0 2
38048: PPUSH
38049: LD_VAR 0 9
38053: PPUSH
38054: CALL_OW 1
38058: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38059: LD_EXP 122
38063: PUSH
38064: LD_VAR 0 2
38068: ARRAY
38069: PUSH
38070: LD_EXP 123
38074: PUSH
38075: LD_VAR 0 2
38079: ARRAY
38080: AND
38081: PUSH
38082: LD_EXP 123
38086: PUSH
38087: LD_VAR 0 2
38091: ARRAY
38092: PUSH
38093: LD_INT 1
38095: ARRAY
38096: PPUSH
38097: CALL_OW 310
38101: NOT
38102: AND
38103: PUSH
38104: LD_VAR 0 3
38108: PPUSH
38109: CALL_OW 313
38113: PUSH
38114: LD_INT 6
38116: EQUAL
38117: AND
38118: IFFALSE 38174
// begin tmp2 := UnitsInside ( j ) ;
38120: LD_ADDR_VAR 0 9
38124: PUSH
38125: LD_VAR 0 3
38129: PPUSH
38130: CALL_OW 313
38134: ST_TO_ADDR
// if tmp2 = 6 then
38135: LD_VAR 0 9
38139: PUSH
38140: LD_INT 6
38142: EQUAL
38143: IFFALSE 38174
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38145: LD_VAR 0 9
38149: PUSH
38150: LD_INT 1
38152: ARRAY
38153: PPUSH
38154: LD_INT 112
38156: PPUSH
38157: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38161: LD_VAR 0 9
38165: PUSH
38166: LD_INT 1
38168: ARRAY
38169: PPUSH
38170: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38174: LD_EXP 123
38178: PUSH
38179: LD_VAR 0 2
38183: ARRAY
38184: PUSH
38185: LD_EXP 123
38189: PUSH
38190: LD_VAR 0 2
38194: ARRAY
38195: PUSH
38196: LD_INT 1
38198: ARRAY
38199: PPUSH
38200: CALL_OW 314
38204: NOT
38205: AND
38206: PUSH
38207: LD_EXP 123
38211: PUSH
38212: LD_VAR 0 2
38216: ARRAY
38217: PUSH
38218: LD_INT 1
38220: ARRAY
38221: PPUSH
38222: CALL_OW 310
38226: NOT
38227: AND
38228: IFFALSE 38254
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38230: LD_EXP 123
38234: PUSH
38235: LD_VAR 0 2
38239: ARRAY
38240: PUSH
38241: LD_INT 1
38243: ARRAY
38244: PPUSH
38245: LD_VAR 0 3
38249: PPUSH
38250: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38254: LD_EXP 123
38258: PUSH
38259: LD_VAR 0 2
38263: ARRAY
38264: PUSH
38265: LD_INT 1
38267: ARRAY
38268: PPUSH
38269: CALL_OW 310
38273: PUSH
38274: LD_EXP 123
38278: PUSH
38279: LD_VAR 0 2
38283: ARRAY
38284: PUSH
38285: LD_INT 1
38287: ARRAY
38288: PPUSH
38289: CALL_OW 310
38293: PPUSH
38294: CALL_OW 461
38298: PUSH
38299: LD_INT 3
38301: NONEQUAL
38302: AND
38303: IFFALSE 38324
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38305: LD_EXP 123
38309: PUSH
38310: LD_VAR 0 2
38314: ARRAY
38315: PUSH
38316: LD_INT 1
38318: ARRAY
38319: PPUSH
38320: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38324: LD_VAR 0 3
38328: PPUSH
38329: CALL_OW 461
38333: PUSH
38334: LD_INT 6
38336: EQUAL
38337: PUSH
38338: LD_VAR 0 6
38342: PUSH
38343: LD_INT 1
38345: GREATER
38346: AND
38347: IFFALSE 38499
// begin sci := [ ] ;
38349: LD_ADDR_VAR 0 8
38353: PUSH
38354: EMPTY
38355: ST_TO_ADDR
// for x in ( tmp diff j ) do
38356: LD_ADDR_VAR 0 7
38360: PUSH
38361: LD_VAR 0 6
38365: PUSH
38366: LD_VAR 0 3
38370: DIFF
38371: PUSH
38372: FOR_IN
38373: IFFALSE 38425
// begin if sci = 6 then
38375: LD_VAR 0 8
38379: PUSH
38380: LD_INT 6
38382: EQUAL
38383: IFFALSE 38387
// break ;
38385: GO 38425
// if BuildingStatus ( x ) = bs_idle then
38387: LD_VAR 0 7
38391: PPUSH
38392: CALL_OW 461
38396: PUSH
38397: LD_INT 2
38399: EQUAL
38400: IFFALSE 38423
// sci := sci ^ UnitsInside ( x ) ;
38402: LD_ADDR_VAR 0 8
38406: PUSH
38407: LD_VAR 0 8
38411: PUSH
38412: LD_VAR 0 7
38416: PPUSH
38417: CALL_OW 313
38421: ADD
38422: ST_TO_ADDR
// end ;
38423: GO 38372
38425: POP
38426: POP
// if not sci then
38427: LD_VAR 0 8
38431: NOT
38432: IFFALSE 38436
// continue ;
38434: GO 37481
// for x in sci do
38436: LD_ADDR_VAR 0 7
38440: PUSH
38441: LD_VAR 0 8
38445: PUSH
38446: FOR_IN
38447: IFFALSE 38497
// if IsInUnit ( x ) and not HasTask ( x ) then
38449: LD_VAR 0 7
38453: PPUSH
38454: CALL_OW 310
38458: PUSH
38459: LD_VAR 0 7
38463: PPUSH
38464: CALL_OW 314
38468: NOT
38469: AND
38470: IFFALSE 38495
// begin ComExitBuilding ( x ) ;
38472: LD_VAR 0 7
38476: PPUSH
38477: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38481: LD_VAR 0 7
38485: PPUSH
38486: LD_VAR 0 3
38490: PPUSH
38491: CALL_OW 180
// end ;
38495: GO 38446
38497: POP
38498: POP
// end ; end ;
38499: GO 37481
38501: POP
38502: POP
// end ;
38503: GO 37435
38505: POP
38506: POP
// end ;
38507: LD_VAR 0 1
38511: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
38512: LD_INT 0
38514: PPUSH
38515: PPUSH
// if not mc_bases then
38516: LD_EXP 93
38520: NOT
38521: IFFALSE 38525
// exit ;
38523: GO 38606
// for i = 1 to mc_bases do
38525: LD_ADDR_VAR 0 2
38529: PUSH
38530: DOUBLE
38531: LD_INT 1
38533: DEC
38534: ST_TO_ADDR
38535: LD_EXP 93
38539: PUSH
38540: FOR_TO
38541: IFFALSE 38604
// if mc_mines [ i ] and mc_miners [ i ] then
38543: LD_EXP 106
38547: PUSH
38548: LD_VAR 0 2
38552: ARRAY
38553: PUSH
38554: LD_EXP 107
38558: PUSH
38559: LD_VAR 0 2
38563: ARRAY
38564: AND
38565: IFFALSE 38602
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
38567: LD_EXP 107
38571: PUSH
38572: LD_VAR 0 2
38576: ARRAY
38577: PUSH
38578: LD_INT 1
38580: ARRAY
38581: PPUSH
38582: CALL_OW 255
38586: PPUSH
38587: LD_EXP 106
38591: PUSH
38592: LD_VAR 0 2
38596: ARRAY
38597: PPUSH
38598: CALL 53220 0 2
38602: GO 38540
38604: POP
38605: POP
// end ;
38606: LD_VAR 0 1
38610: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
38611: LD_INT 0
38613: PPUSH
38614: PPUSH
38615: PPUSH
38616: PPUSH
38617: PPUSH
38618: PPUSH
38619: PPUSH
38620: PPUSH
// if not mc_bases or not mc_parking then
38621: LD_EXP 93
38625: NOT
38626: PUSH
38627: LD_EXP 117
38631: NOT
38632: OR
38633: IFFALSE 38637
// exit ;
38635: GO 39347
// for i = 1 to mc_bases do
38637: LD_ADDR_VAR 0 2
38641: PUSH
38642: DOUBLE
38643: LD_INT 1
38645: DEC
38646: ST_TO_ADDR
38647: LD_EXP 93
38651: PUSH
38652: FOR_TO
38653: IFFALSE 39345
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
38655: LD_EXP 93
38659: PUSH
38660: LD_VAR 0 2
38664: ARRAY
38665: NOT
38666: PUSH
38667: LD_EXP 117
38671: PUSH
38672: LD_VAR 0 2
38676: ARRAY
38677: NOT
38678: OR
38679: IFFALSE 38683
// continue ;
38681: GO 38652
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38683: LD_ADDR_VAR 0 5
38687: PUSH
38688: LD_EXP 93
38692: PUSH
38693: LD_VAR 0 2
38697: ARRAY
38698: PUSH
38699: LD_INT 1
38701: ARRAY
38702: PPUSH
38703: CALL_OW 255
38707: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38708: LD_ADDR_VAR 0 6
38712: PUSH
38713: LD_EXP 93
38717: PUSH
38718: LD_VAR 0 2
38722: ARRAY
38723: PPUSH
38724: LD_INT 30
38726: PUSH
38727: LD_INT 3
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PPUSH
38734: CALL_OW 72
38738: ST_TO_ADDR
// if not fac then
38739: LD_VAR 0 6
38743: NOT
38744: IFFALSE 38795
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38746: LD_ADDR_VAR 0 6
38750: PUSH
38751: LD_EXP 93
38755: PUSH
38756: LD_VAR 0 2
38760: ARRAY
38761: PPUSH
38762: LD_INT 2
38764: PUSH
38765: LD_INT 30
38767: PUSH
38768: LD_INT 0
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 30
38777: PUSH
38778: LD_INT 1
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: LIST
38789: PPUSH
38790: CALL_OW 72
38794: ST_TO_ADDR
// if not fac then
38795: LD_VAR 0 6
38799: NOT
38800: IFFALSE 38804
// continue ;
38802: GO 38652
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38804: LD_ADDR_VAR 0 7
38808: PUSH
38809: LD_EXP 117
38813: PUSH
38814: LD_VAR 0 2
38818: ARRAY
38819: PPUSH
38820: LD_INT 22
38822: PUSH
38823: LD_VAR 0 5
38827: PUSH
38828: EMPTY
38829: LIST
38830: LIST
38831: PUSH
38832: LD_INT 21
38834: PUSH
38835: LD_INT 2
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 3
38844: PUSH
38845: LD_INT 24
38847: PUSH
38848: LD_INT 1000
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: LIST
38863: PPUSH
38864: CALL_OW 70
38868: ST_TO_ADDR
// for j in fac do
38869: LD_ADDR_VAR 0 3
38873: PUSH
38874: LD_VAR 0 6
38878: PUSH
38879: FOR_IN
38880: IFFALSE 38961
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38882: LD_ADDR_VAR 0 7
38886: PUSH
38887: LD_VAR 0 7
38891: PUSH
38892: LD_INT 22
38894: PUSH
38895: LD_VAR 0 5
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 91
38906: PUSH
38907: LD_VAR 0 3
38911: PUSH
38912: LD_INT 15
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 21
38922: PUSH
38923: LD_INT 2
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 3
38932: PUSH
38933: LD_INT 24
38935: PUSH
38936: LD_INT 1000
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: LIST
38951: LIST
38952: PPUSH
38953: CALL_OW 69
38957: UNION
38958: ST_TO_ADDR
38959: GO 38879
38961: POP
38962: POP
// if not vehs then
38963: LD_VAR 0 7
38967: NOT
38968: IFFALSE 38994
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38970: LD_ADDR_EXP 105
38974: PUSH
38975: LD_EXP 105
38979: PPUSH
38980: LD_VAR 0 2
38984: PPUSH
38985: EMPTY
38986: PPUSH
38987: CALL_OW 1
38991: ST_TO_ADDR
// continue ;
38992: GO 38652
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38994: LD_ADDR_VAR 0 8
38998: PUSH
38999: LD_EXP 93
39003: PUSH
39004: LD_VAR 0 2
39008: ARRAY
39009: PPUSH
39010: LD_INT 30
39012: PUSH
39013: LD_INT 3
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PPUSH
39020: CALL_OW 72
39024: ST_TO_ADDR
// if tmp then
39025: LD_VAR 0 8
39029: IFFALSE 39132
// begin for j in tmp do
39031: LD_ADDR_VAR 0 3
39035: PUSH
39036: LD_VAR 0 8
39040: PUSH
39041: FOR_IN
39042: IFFALSE 39130
// for k in UnitsInside ( j ) do
39044: LD_ADDR_VAR 0 4
39048: PUSH
39049: LD_VAR 0 3
39053: PPUSH
39054: CALL_OW 313
39058: PUSH
39059: FOR_IN
39060: IFFALSE 39126
// if k then
39062: LD_VAR 0 4
39066: IFFALSE 39124
// if not k in mc_repair_vehicle [ i ] then
39068: LD_VAR 0 4
39072: PUSH
39073: LD_EXP 105
39077: PUSH
39078: LD_VAR 0 2
39082: ARRAY
39083: IN
39084: NOT
39085: IFFALSE 39124
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39087: LD_ADDR_EXP 105
39091: PUSH
39092: LD_EXP 105
39096: PPUSH
39097: LD_VAR 0 2
39101: PPUSH
39102: LD_EXP 105
39106: PUSH
39107: LD_VAR 0 2
39111: ARRAY
39112: PUSH
39113: LD_VAR 0 4
39117: UNION
39118: PPUSH
39119: CALL_OW 1
39123: ST_TO_ADDR
39124: GO 39059
39126: POP
39127: POP
39128: GO 39041
39130: POP
39131: POP
// end ; if not mc_repair_vehicle [ i ] then
39132: LD_EXP 105
39136: PUSH
39137: LD_VAR 0 2
39141: ARRAY
39142: NOT
39143: IFFALSE 39147
// continue ;
39145: GO 38652
// for j in mc_repair_vehicle [ i ] do
39147: LD_ADDR_VAR 0 3
39151: PUSH
39152: LD_EXP 105
39156: PUSH
39157: LD_VAR 0 2
39161: ARRAY
39162: PUSH
39163: FOR_IN
39164: IFFALSE 39341
// begin if GetClass ( j ) <> 3 then
39166: LD_VAR 0 3
39170: PPUSH
39171: CALL_OW 257
39175: PUSH
39176: LD_INT 3
39178: NONEQUAL
39179: IFFALSE 39220
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39181: LD_ADDR_EXP 105
39185: PUSH
39186: LD_EXP 105
39190: PPUSH
39191: LD_VAR 0 2
39195: PPUSH
39196: LD_EXP 105
39200: PUSH
39201: LD_VAR 0 2
39205: ARRAY
39206: PUSH
39207: LD_VAR 0 3
39211: DIFF
39212: PPUSH
39213: CALL_OW 1
39217: ST_TO_ADDR
// continue ;
39218: GO 39163
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39220: LD_VAR 0 3
39224: PPUSH
39225: CALL_OW 311
39229: NOT
39230: PUSH
39231: LD_VAR 0 3
39235: PUSH
39236: LD_EXP 96
39240: PUSH
39241: LD_VAR 0 2
39245: ARRAY
39246: PUSH
39247: LD_INT 1
39249: ARRAY
39250: IN
39251: NOT
39252: AND
39253: PUSH
39254: LD_VAR 0 3
39258: PUSH
39259: LD_EXP 96
39263: PUSH
39264: LD_VAR 0 2
39268: ARRAY
39269: PUSH
39270: LD_INT 2
39272: ARRAY
39273: IN
39274: NOT
39275: AND
39276: IFFALSE 39339
// begin if IsInUnit ( j ) then
39278: LD_VAR 0 3
39282: PPUSH
39283: CALL_OW 310
39287: IFFALSE 39300
// ComExitBuilding ( j ) else
39289: LD_VAR 0 3
39293: PPUSH
39294: CALL_OW 122
39298: GO 39339
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
39300: LD_VAR 0 3
39304: PPUSH
39305: LD_VAR 0 7
39309: PUSH
39310: LD_INT 1
39312: ARRAY
39313: PPUSH
39314: CALL 89874 0 2
39318: NOT
39319: IFFALSE 39339
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
39321: LD_VAR 0 3
39325: PPUSH
39326: LD_VAR 0 7
39330: PUSH
39331: LD_INT 1
39333: ARRAY
39334: PPUSH
39335: CALL_OW 129
// end ; end ;
39339: GO 39163
39341: POP
39342: POP
// end ;
39343: GO 38652
39345: POP
39346: POP
// end ;
39347: LD_VAR 0 1
39351: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39352: LD_INT 0
39354: PPUSH
39355: PPUSH
39356: PPUSH
39357: PPUSH
39358: PPUSH
39359: PPUSH
39360: PPUSH
39361: PPUSH
39362: PPUSH
39363: PPUSH
39364: PPUSH
// if not mc_bases then
39365: LD_EXP 93
39369: NOT
39370: IFFALSE 39374
// exit ;
39372: GO 40176
// for i = 1 to mc_bases do
39374: LD_ADDR_VAR 0 2
39378: PUSH
39379: DOUBLE
39380: LD_INT 1
39382: DEC
39383: ST_TO_ADDR
39384: LD_EXP 93
39388: PUSH
39389: FOR_TO
39390: IFFALSE 40174
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
39392: LD_EXP 121
39396: PUSH
39397: LD_VAR 0 2
39401: ARRAY
39402: NOT
39403: PUSH
39404: LD_EXP 96
39408: PUSH
39409: LD_VAR 0 2
39413: ARRAY
39414: PUSH
39415: LD_INT 1
39417: ARRAY
39418: OR
39419: PUSH
39420: LD_EXP 96
39424: PUSH
39425: LD_VAR 0 2
39429: ARRAY
39430: PUSH
39431: LD_INT 2
39433: ARRAY
39434: OR
39435: PUSH
39436: LD_EXP 119
39440: PUSH
39441: LD_VAR 0 2
39445: ARRAY
39446: PPUSH
39447: LD_INT 1
39449: PPUSH
39450: CALL_OW 325
39454: NOT
39455: OR
39456: PUSH
39457: LD_EXP 116
39461: PUSH
39462: LD_VAR 0 2
39466: ARRAY
39467: OR
39468: IFFALSE 39472
// continue ;
39470: GO 39389
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
39472: LD_ADDR_VAR 0 8
39476: PUSH
39477: LD_EXP 93
39481: PUSH
39482: LD_VAR 0 2
39486: ARRAY
39487: PPUSH
39488: LD_INT 25
39490: PUSH
39491: LD_INT 4
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 50
39500: PUSH
39501: EMPTY
39502: LIST
39503: PUSH
39504: LD_INT 3
39506: PUSH
39507: LD_INT 60
39509: PUSH
39510: EMPTY
39511: LIST
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: LIST
39521: PPUSH
39522: CALL_OW 72
39526: PUSH
39527: LD_EXP 97
39531: PUSH
39532: LD_VAR 0 2
39536: ARRAY
39537: DIFF
39538: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39539: LD_ADDR_VAR 0 9
39543: PUSH
39544: LD_EXP 93
39548: PUSH
39549: LD_VAR 0 2
39553: ARRAY
39554: PPUSH
39555: LD_INT 2
39557: PUSH
39558: LD_INT 30
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 30
39570: PUSH
39571: LD_INT 1
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: LIST
39582: PPUSH
39583: CALL_OW 72
39587: ST_TO_ADDR
// if not tmp or not dep then
39588: LD_VAR 0 8
39592: NOT
39593: PUSH
39594: LD_VAR 0 9
39598: NOT
39599: OR
39600: IFFALSE 39604
// continue ;
39602: GO 39389
// side := GetSide ( tmp [ 1 ] ) ;
39604: LD_ADDR_VAR 0 11
39608: PUSH
39609: LD_VAR 0 8
39613: PUSH
39614: LD_INT 1
39616: ARRAY
39617: PPUSH
39618: CALL_OW 255
39622: ST_TO_ADDR
// dep := dep [ 1 ] ;
39623: LD_ADDR_VAR 0 9
39627: PUSH
39628: LD_VAR 0 9
39632: PUSH
39633: LD_INT 1
39635: ARRAY
39636: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
39637: LD_ADDR_VAR 0 7
39641: PUSH
39642: LD_EXP 121
39646: PUSH
39647: LD_VAR 0 2
39651: ARRAY
39652: PPUSH
39653: LD_INT 22
39655: PUSH
39656: LD_INT 0
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 25
39665: PUSH
39666: LD_INT 12
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PPUSH
39677: CALL_OW 70
39681: PUSH
39682: LD_INT 22
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 25
39694: PUSH
39695: LD_INT 12
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 91
39704: PUSH
39705: LD_VAR 0 9
39709: PUSH
39710: LD_INT 20
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: LIST
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: LIST
39722: PPUSH
39723: CALL_OW 69
39727: UNION
39728: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39729: LD_ADDR_VAR 0 10
39733: PUSH
39734: LD_EXP 121
39738: PUSH
39739: LD_VAR 0 2
39743: ARRAY
39744: PPUSH
39745: LD_INT 81
39747: PUSH
39748: LD_VAR 0 11
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PPUSH
39757: CALL_OW 70
39761: ST_TO_ADDR
// if not apes or danger_at_area then
39762: LD_VAR 0 7
39766: NOT
39767: PUSH
39768: LD_VAR 0 10
39772: OR
39773: IFFALSE 39823
// begin if mc_taming [ i ] then
39775: LD_EXP 124
39779: PUSH
39780: LD_VAR 0 2
39784: ARRAY
39785: IFFALSE 39821
// begin MC_Reset ( i , 121 ) ;
39787: LD_VAR 0 2
39791: PPUSH
39792: LD_INT 121
39794: PPUSH
39795: CALL 24956 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39799: LD_ADDR_EXP 124
39803: PUSH
39804: LD_EXP 124
39808: PPUSH
39809: LD_VAR 0 2
39813: PPUSH
39814: EMPTY
39815: PPUSH
39816: CALL_OW 1
39820: ST_TO_ADDR
// end ; continue ;
39821: GO 39389
// end ; for j in tmp do
39823: LD_ADDR_VAR 0 3
39827: PUSH
39828: LD_VAR 0 8
39832: PUSH
39833: FOR_IN
39834: IFFALSE 40170
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39836: LD_VAR 0 3
39840: PUSH
39841: LD_EXP 124
39845: PUSH
39846: LD_VAR 0 2
39850: ARRAY
39851: IN
39852: NOT
39853: PUSH
39854: LD_EXP 124
39858: PUSH
39859: LD_VAR 0 2
39863: ARRAY
39864: PUSH
39865: LD_INT 3
39867: LESS
39868: AND
39869: IFFALSE 39927
// begin SetTag ( j , 121 ) ;
39871: LD_VAR 0 3
39875: PPUSH
39876: LD_INT 121
39878: PPUSH
39879: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39883: LD_ADDR_EXP 124
39887: PUSH
39888: LD_EXP 124
39892: PPUSH
39893: LD_VAR 0 2
39897: PUSH
39898: LD_EXP 124
39902: PUSH
39903: LD_VAR 0 2
39907: ARRAY
39908: PUSH
39909: LD_INT 1
39911: PLUS
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PPUSH
39917: LD_VAR 0 3
39921: PPUSH
39922: CALL 56267 0 3
39926: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39927: LD_VAR 0 3
39931: PUSH
39932: LD_EXP 124
39936: PUSH
39937: LD_VAR 0 2
39941: ARRAY
39942: IN
39943: IFFALSE 40168
// begin if GetClass ( j ) <> 4 then
39945: LD_VAR 0 3
39949: PPUSH
39950: CALL_OW 257
39954: PUSH
39955: LD_INT 4
39957: NONEQUAL
39958: IFFALSE 40011
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39960: LD_ADDR_EXP 124
39964: PUSH
39965: LD_EXP 124
39969: PPUSH
39970: LD_VAR 0 2
39974: PPUSH
39975: LD_EXP 124
39979: PUSH
39980: LD_VAR 0 2
39984: ARRAY
39985: PUSH
39986: LD_VAR 0 3
39990: DIFF
39991: PPUSH
39992: CALL_OW 1
39996: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39997: LD_VAR 0 3
40001: PPUSH
40002: LD_INT 0
40004: PPUSH
40005: CALL_OW 109
// continue ;
40009: GO 39833
// end ; if IsInUnit ( j ) then
40011: LD_VAR 0 3
40015: PPUSH
40016: CALL_OW 310
40020: IFFALSE 40031
// ComExitBuilding ( j ) ;
40022: LD_VAR 0 3
40026: PPUSH
40027: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40031: LD_ADDR_VAR 0 6
40035: PUSH
40036: LD_VAR 0 7
40040: PPUSH
40041: LD_VAR 0 3
40045: PPUSH
40046: CALL_OW 74
40050: ST_TO_ADDR
// if not ape then
40051: LD_VAR 0 6
40055: NOT
40056: IFFALSE 40060
// break ;
40058: GO 40170
// x := GetX ( ape ) ;
40060: LD_ADDR_VAR 0 4
40064: PUSH
40065: LD_VAR 0 6
40069: PPUSH
40070: CALL_OW 250
40074: ST_TO_ADDR
// y := GetY ( ape ) ;
40075: LD_ADDR_VAR 0 5
40079: PUSH
40080: LD_VAR 0 6
40084: PPUSH
40085: CALL_OW 251
40089: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40090: LD_VAR 0 4
40094: PPUSH
40095: LD_VAR 0 5
40099: PPUSH
40100: CALL_OW 488
40104: NOT
40105: PUSH
40106: LD_VAR 0 11
40110: PPUSH
40111: LD_VAR 0 4
40115: PPUSH
40116: LD_VAR 0 5
40120: PPUSH
40121: LD_INT 20
40123: PPUSH
40124: CALL 57163 0 4
40128: PUSH
40129: LD_INT 4
40131: ARRAY
40132: OR
40133: IFFALSE 40137
// break ;
40135: GO 40170
// if not HasTask ( j ) then
40137: LD_VAR 0 3
40141: PPUSH
40142: CALL_OW 314
40146: NOT
40147: IFFALSE 40168
// ComTameXY ( j , x , y ) ;
40149: LD_VAR 0 3
40153: PPUSH
40154: LD_VAR 0 4
40158: PPUSH
40159: LD_VAR 0 5
40163: PPUSH
40164: CALL_OW 131
// end ; end ;
40168: GO 39833
40170: POP
40171: POP
// end ;
40172: GO 39389
40174: POP
40175: POP
// end ;
40176: LD_VAR 0 1
40180: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40181: LD_INT 0
40183: PPUSH
40184: PPUSH
40185: PPUSH
40186: PPUSH
40187: PPUSH
40188: PPUSH
40189: PPUSH
40190: PPUSH
// if not mc_bases then
40191: LD_EXP 93
40195: NOT
40196: IFFALSE 40200
// exit ;
40198: GO 40826
// for i = 1 to mc_bases do
40200: LD_ADDR_VAR 0 2
40204: PUSH
40205: DOUBLE
40206: LD_INT 1
40208: DEC
40209: ST_TO_ADDR
40210: LD_EXP 93
40214: PUSH
40215: FOR_TO
40216: IFFALSE 40824
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40218: LD_EXP 122
40222: PUSH
40223: LD_VAR 0 2
40227: ARRAY
40228: NOT
40229: PUSH
40230: LD_EXP 122
40234: PUSH
40235: LD_VAR 0 2
40239: ARRAY
40240: PPUSH
40241: LD_INT 25
40243: PUSH
40244: LD_INT 12
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PPUSH
40251: CALL_OW 72
40255: NOT
40256: OR
40257: IFFALSE 40261
// continue ;
40259: GO 40215
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40261: LD_ADDR_VAR 0 5
40265: PUSH
40266: LD_EXP 122
40270: PUSH
40271: LD_VAR 0 2
40275: ARRAY
40276: PUSH
40277: LD_INT 1
40279: ARRAY
40280: PPUSH
40281: CALL_OW 255
40285: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40286: LD_VAR 0 5
40290: PPUSH
40291: LD_INT 2
40293: PPUSH
40294: CALL_OW 325
40298: IFFALSE 40551
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40300: LD_ADDR_VAR 0 4
40304: PUSH
40305: LD_EXP 122
40309: PUSH
40310: LD_VAR 0 2
40314: ARRAY
40315: PPUSH
40316: LD_INT 25
40318: PUSH
40319: LD_INT 16
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PPUSH
40326: CALL_OW 72
40330: ST_TO_ADDR
// if tmp < 6 then
40331: LD_VAR 0 4
40335: PUSH
40336: LD_INT 6
40338: LESS
40339: IFFALSE 40551
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40341: LD_ADDR_VAR 0 6
40345: PUSH
40346: LD_EXP 93
40350: PUSH
40351: LD_VAR 0 2
40355: ARRAY
40356: PPUSH
40357: LD_INT 2
40359: PUSH
40360: LD_INT 30
40362: PUSH
40363: LD_INT 0
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 30
40372: PUSH
40373: LD_INT 1
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: LIST
40384: PPUSH
40385: CALL_OW 72
40389: ST_TO_ADDR
// if depot then
40390: LD_VAR 0 6
40394: IFFALSE 40551
// begin selected := 0 ;
40396: LD_ADDR_VAR 0 7
40400: PUSH
40401: LD_INT 0
40403: ST_TO_ADDR
// for j in depot do
40404: LD_ADDR_VAR 0 3
40408: PUSH
40409: LD_VAR 0 6
40413: PUSH
40414: FOR_IN
40415: IFFALSE 40446
// begin if UnitsInside ( j ) < 6 then
40417: LD_VAR 0 3
40421: PPUSH
40422: CALL_OW 313
40426: PUSH
40427: LD_INT 6
40429: LESS
40430: IFFALSE 40444
// begin selected := j ;
40432: LD_ADDR_VAR 0 7
40436: PUSH
40437: LD_VAR 0 3
40441: ST_TO_ADDR
// break ;
40442: GO 40446
// end ; end ;
40444: GO 40414
40446: POP
40447: POP
// if selected then
40448: LD_VAR 0 7
40452: IFFALSE 40551
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40454: LD_ADDR_VAR 0 3
40458: PUSH
40459: LD_EXP 122
40463: PUSH
40464: LD_VAR 0 2
40468: ARRAY
40469: PPUSH
40470: LD_INT 25
40472: PUSH
40473: LD_INT 12
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PPUSH
40480: CALL_OW 72
40484: PUSH
40485: FOR_IN
40486: IFFALSE 40549
// if not HasTask ( j ) then
40488: LD_VAR 0 3
40492: PPUSH
40493: CALL_OW 314
40497: NOT
40498: IFFALSE 40547
// begin if not IsInUnit ( j ) then
40500: LD_VAR 0 3
40504: PPUSH
40505: CALL_OW 310
40509: NOT
40510: IFFALSE 40526
// ComEnterUnit ( j , selected ) ;
40512: LD_VAR 0 3
40516: PPUSH
40517: LD_VAR 0 7
40521: PPUSH
40522: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
40526: LD_VAR 0 3
40530: PPUSH
40531: LD_INT 16
40533: PPUSH
40534: CALL_OW 183
// AddComExitBuilding ( j ) ;
40538: LD_VAR 0 3
40542: PPUSH
40543: CALL_OW 182
// end ;
40547: GO 40485
40549: POP
40550: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
40551: LD_VAR 0 5
40555: PPUSH
40556: LD_INT 11
40558: PPUSH
40559: CALL_OW 325
40563: IFFALSE 40822
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40565: LD_ADDR_VAR 0 4
40569: PUSH
40570: LD_EXP 122
40574: PUSH
40575: LD_VAR 0 2
40579: ARRAY
40580: PPUSH
40581: LD_INT 25
40583: PUSH
40584: LD_INT 16
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PPUSH
40591: CALL_OW 72
40595: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
40596: LD_VAR 0 4
40600: PUSH
40601: LD_INT 6
40603: GREATEREQUAL
40604: PUSH
40605: LD_VAR 0 5
40609: PPUSH
40610: LD_INT 2
40612: PPUSH
40613: CALL_OW 325
40617: NOT
40618: OR
40619: IFFALSE 40822
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40621: LD_ADDR_VAR 0 8
40625: PUSH
40626: LD_EXP 93
40630: PUSH
40631: LD_VAR 0 2
40635: ARRAY
40636: PPUSH
40637: LD_INT 2
40639: PUSH
40640: LD_INT 30
40642: PUSH
40643: LD_INT 4
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 30
40652: PUSH
40653: LD_INT 5
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: LIST
40664: PPUSH
40665: CALL_OW 72
40669: ST_TO_ADDR
// if barracks then
40670: LD_VAR 0 8
40674: IFFALSE 40822
// begin selected := 0 ;
40676: LD_ADDR_VAR 0 7
40680: PUSH
40681: LD_INT 0
40683: ST_TO_ADDR
// for j in barracks do
40684: LD_ADDR_VAR 0 3
40688: PUSH
40689: LD_VAR 0 8
40693: PUSH
40694: FOR_IN
40695: IFFALSE 40726
// begin if UnitsInside ( j ) < 6 then
40697: LD_VAR 0 3
40701: PPUSH
40702: CALL_OW 313
40706: PUSH
40707: LD_INT 6
40709: LESS
40710: IFFALSE 40724
// begin selected := j ;
40712: LD_ADDR_VAR 0 7
40716: PUSH
40717: LD_VAR 0 3
40721: ST_TO_ADDR
// break ;
40722: GO 40726
// end ; end ;
40724: GO 40694
40726: POP
40727: POP
// if selected then
40728: LD_VAR 0 7
40732: IFFALSE 40822
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40734: LD_ADDR_VAR 0 3
40738: PUSH
40739: LD_EXP 122
40743: PUSH
40744: LD_VAR 0 2
40748: ARRAY
40749: PPUSH
40750: LD_INT 25
40752: PUSH
40753: LD_INT 12
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PPUSH
40760: CALL_OW 72
40764: PUSH
40765: FOR_IN
40766: IFFALSE 40820
// if not IsInUnit ( j ) and not HasTask ( j ) then
40768: LD_VAR 0 3
40772: PPUSH
40773: CALL_OW 310
40777: NOT
40778: PUSH
40779: LD_VAR 0 3
40783: PPUSH
40784: CALL_OW 314
40788: NOT
40789: AND
40790: IFFALSE 40818
// begin ComEnterUnit ( j , selected ) ;
40792: LD_VAR 0 3
40796: PPUSH
40797: LD_VAR 0 7
40801: PPUSH
40802: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40806: LD_VAR 0 3
40810: PPUSH
40811: LD_INT 15
40813: PPUSH
40814: CALL_OW 183
// end ;
40818: GO 40765
40820: POP
40821: POP
// end ; end ; end ; end ; end ;
40822: GO 40215
40824: POP
40825: POP
// end ;
40826: LD_VAR 0 1
40830: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40831: LD_INT 0
40833: PPUSH
40834: PPUSH
40835: PPUSH
40836: PPUSH
// if not mc_bases then
40837: LD_EXP 93
40841: NOT
40842: IFFALSE 40846
// exit ;
40844: GO 41024
// for i = 1 to mc_bases do
40846: LD_ADDR_VAR 0 2
40850: PUSH
40851: DOUBLE
40852: LD_INT 1
40854: DEC
40855: ST_TO_ADDR
40856: LD_EXP 93
40860: PUSH
40861: FOR_TO
40862: IFFALSE 41022
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40864: LD_ADDR_VAR 0 4
40868: PUSH
40869: LD_EXP 93
40873: PUSH
40874: LD_VAR 0 2
40878: ARRAY
40879: PPUSH
40880: LD_INT 25
40882: PUSH
40883: LD_INT 9
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PPUSH
40890: CALL_OW 72
40894: ST_TO_ADDR
// if not tmp then
40895: LD_VAR 0 4
40899: NOT
40900: IFFALSE 40904
// continue ;
40902: GO 40861
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40904: LD_EXP 119
40908: PUSH
40909: LD_VAR 0 2
40913: ARRAY
40914: PPUSH
40915: LD_INT 29
40917: PPUSH
40918: CALL_OW 325
40922: NOT
40923: PUSH
40924: LD_EXP 119
40928: PUSH
40929: LD_VAR 0 2
40933: ARRAY
40934: PPUSH
40935: LD_INT 28
40937: PPUSH
40938: CALL_OW 325
40942: NOT
40943: AND
40944: IFFALSE 40948
// continue ;
40946: GO 40861
// for j in tmp do
40948: LD_ADDR_VAR 0 3
40952: PUSH
40953: LD_VAR 0 4
40957: PUSH
40958: FOR_IN
40959: IFFALSE 41018
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40961: LD_VAR 0 3
40965: PUSH
40966: LD_EXP 96
40970: PUSH
40971: LD_VAR 0 2
40975: ARRAY
40976: PUSH
40977: LD_INT 1
40979: ARRAY
40980: IN
40981: NOT
40982: PUSH
40983: LD_VAR 0 3
40987: PUSH
40988: LD_EXP 96
40992: PUSH
40993: LD_VAR 0 2
40997: ARRAY
40998: PUSH
40999: LD_INT 2
41001: ARRAY
41002: IN
41003: NOT
41004: AND
41005: IFFALSE 41016
// ComSpaceTimeShoot ( j ) ;
41007: LD_VAR 0 3
41011: PPUSH
41012: CALL 52228 0 1
41016: GO 40958
41018: POP
41019: POP
// end ;
41020: GO 40861
41022: POP
41023: POP
// end ;
41024: LD_VAR 0 1
41028: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41029: LD_INT 0
41031: PPUSH
41032: PPUSH
41033: PPUSH
41034: PPUSH
41035: PPUSH
41036: PPUSH
41037: PPUSH
41038: PPUSH
41039: PPUSH
// if not mc_bases then
41040: LD_EXP 93
41044: NOT
41045: IFFALSE 41049
// exit ;
41047: GO 41671
// for i = 1 to mc_bases do
41049: LD_ADDR_VAR 0 2
41053: PUSH
41054: DOUBLE
41055: LD_INT 1
41057: DEC
41058: ST_TO_ADDR
41059: LD_EXP 93
41063: PUSH
41064: FOR_TO
41065: IFFALSE 41669
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41067: LD_EXP 128
41071: PUSH
41072: LD_VAR 0 2
41076: ARRAY
41077: NOT
41078: PUSH
41079: LD_INT 38
41081: PPUSH
41082: LD_EXP 119
41086: PUSH
41087: LD_VAR 0 2
41091: ARRAY
41092: PPUSH
41093: CALL_OW 321
41097: PUSH
41098: LD_INT 2
41100: NONEQUAL
41101: OR
41102: IFFALSE 41106
// continue ;
41104: GO 41064
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41106: LD_ADDR_VAR 0 8
41110: PUSH
41111: LD_EXP 93
41115: PUSH
41116: LD_VAR 0 2
41120: ARRAY
41121: PPUSH
41122: LD_INT 30
41124: PUSH
41125: LD_INT 34
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PPUSH
41132: CALL_OW 72
41136: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41137: LD_ADDR_VAR 0 9
41141: PUSH
41142: LD_EXP 93
41146: PUSH
41147: LD_VAR 0 2
41151: ARRAY
41152: PPUSH
41153: LD_INT 25
41155: PUSH
41156: LD_INT 4
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PPUSH
41163: CALL_OW 72
41167: PPUSH
41168: LD_INT 0
41170: PPUSH
41171: CALL 85536 0 2
41175: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41176: LD_VAR 0 9
41180: NOT
41181: PUSH
41182: LD_VAR 0 8
41186: NOT
41187: OR
41188: PUSH
41189: LD_EXP 93
41193: PUSH
41194: LD_VAR 0 2
41198: ARRAY
41199: PPUSH
41200: LD_INT 124
41202: PPUSH
41203: CALL 85536 0 2
41207: OR
41208: IFFALSE 41212
// continue ;
41210: GO 41064
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41212: LD_EXP 129
41216: PUSH
41217: LD_VAR 0 2
41221: ARRAY
41222: PUSH
41223: LD_EXP 128
41227: PUSH
41228: LD_VAR 0 2
41232: ARRAY
41233: LESS
41234: PUSH
41235: LD_EXP 129
41239: PUSH
41240: LD_VAR 0 2
41244: ARRAY
41245: PUSH
41246: LD_VAR 0 8
41250: LESS
41251: AND
41252: IFFALSE 41667
// begin tmp := sci [ 1 ] ;
41254: LD_ADDR_VAR 0 7
41258: PUSH
41259: LD_VAR 0 9
41263: PUSH
41264: LD_INT 1
41266: ARRAY
41267: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41268: LD_VAR 0 7
41272: PPUSH
41273: LD_INT 124
41275: PPUSH
41276: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41280: LD_ADDR_VAR 0 3
41284: PUSH
41285: DOUBLE
41286: LD_EXP 128
41290: PUSH
41291: LD_VAR 0 2
41295: ARRAY
41296: INC
41297: ST_TO_ADDR
41298: LD_EXP 128
41302: PUSH
41303: LD_VAR 0 2
41307: ARRAY
41308: PUSH
41309: FOR_DOWNTO
41310: IFFALSE 41653
// begin if IsInUnit ( tmp ) then
41312: LD_VAR 0 7
41316: PPUSH
41317: CALL_OW 310
41321: IFFALSE 41332
// ComExitBuilding ( tmp ) ;
41323: LD_VAR 0 7
41327: PPUSH
41328: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41332: LD_INT 35
41334: PPUSH
41335: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41339: LD_VAR 0 7
41343: PPUSH
41344: CALL_OW 310
41348: NOT
41349: PUSH
41350: LD_VAR 0 7
41354: PPUSH
41355: CALL_OW 314
41359: NOT
41360: AND
41361: IFFALSE 41332
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
41363: LD_ADDR_VAR 0 6
41367: PUSH
41368: LD_VAR 0 7
41372: PPUSH
41373: CALL_OW 250
41377: PUSH
41378: LD_VAR 0 7
41382: PPUSH
41383: CALL_OW 251
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
41392: LD_INT 35
41394: PPUSH
41395: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
41399: LD_ADDR_VAR 0 4
41403: PUSH
41404: LD_EXP 128
41408: PUSH
41409: LD_VAR 0 2
41413: ARRAY
41414: PUSH
41415: LD_VAR 0 3
41419: ARRAY
41420: PUSH
41421: LD_INT 1
41423: ARRAY
41424: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
41425: LD_ADDR_VAR 0 5
41429: PUSH
41430: LD_EXP 128
41434: PUSH
41435: LD_VAR 0 2
41439: ARRAY
41440: PUSH
41441: LD_VAR 0 3
41445: ARRAY
41446: PUSH
41447: LD_INT 2
41449: ARRAY
41450: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
41451: LD_VAR 0 7
41455: PPUSH
41456: LD_INT 10
41458: PPUSH
41459: CALL 58866 0 2
41463: PUSH
41464: LD_INT 4
41466: ARRAY
41467: IFFALSE 41505
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
41469: LD_VAR 0 7
41473: PPUSH
41474: LD_VAR 0 6
41478: PUSH
41479: LD_INT 1
41481: ARRAY
41482: PPUSH
41483: LD_VAR 0 6
41487: PUSH
41488: LD_INT 2
41490: ARRAY
41491: PPUSH
41492: CALL_OW 111
// wait ( 0 0$10 ) ;
41496: LD_INT 350
41498: PPUSH
41499: CALL_OW 67
// end else
41503: GO 41531
// begin ComMoveXY ( tmp , x , y ) ;
41505: LD_VAR 0 7
41509: PPUSH
41510: LD_VAR 0 4
41514: PPUSH
41515: LD_VAR 0 5
41519: PPUSH
41520: CALL_OW 111
// wait ( 0 0$3 ) ;
41524: LD_INT 105
41526: PPUSH
41527: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
41531: LD_VAR 0 7
41535: PPUSH
41536: LD_VAR 0 4
41540: PPUSH
41541: LD_VAR 0 5
41545: PPUSH
41546: CALL_OW 307
41550: IFFALSE 41392
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
41552: LD_VAR 0 7
41556: PPUSH
41557: LD_VAR 0 4
41561: PPUSH
41562: LD_VAR 0 5
41566: PPUSH
41567: LD_VAR 0 8
41571: PUSH
41572: LD_VAR 0 3
41576: ARRAY
41577: PPUSH
41578: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
41582: LD_INT 35
41584: PPUSH
41585: CALL_OW 67
// until not HasTask ( tmp ) ;
41589: LD_VAR 0 7
41593: PPUSH
41594: CALL_OW 314
41598: NOT
41599: IFFALSE 41582
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
41601: LD_ADDR_EXP 129
41605: PUSH
41606: LD_EXP 129
41610: PPUSH
41611: LD_VAR 0 2
41615: PUSH
41616: LD_EXP 129
41620: PUSH
41621: LD_VAR 0 2
41625: ARRAY
41626: PUSH
41627: LD_INT 1
41629: PLUS
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PPUSH
41635: LD_VAR 0 8
41639: PUSH
41640: LD_VAR 0 3
41644: ARRAY
41645: PPUSH
41646: CALL 56267 0 3
41650: ST_TO_ADDR
// end ;
41651: GO 41309
41653: POP
41654: POP
// MC_Reset ( i , 124 ) ;
41655: LD_VAR 0 2
41659: PPUSH
41660: LD_INT 124
41662: PPUSH
41663: CALL 24956 0 2
// end ; end ;
41667: GO 41064
41669: POP
41670: POP
// end ;
41671: LD_VAR 0 1
41675: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41676: LD_INT 0
41678: PPUSH
41679: PPUSH
41680: PPUSH
// if not mc_bases then
41681: LD_EXP 93
41685: NOT
41686: IFFALSE 41690
// exit ;
41688: GO 42296
// for i = 1 to mc_bases do
41690: LD_ADDR_VAR 0 2
41694: PUSH
41695: DOUBLE
41696: LD_INT 1
41698: DEC
41699: ST_TO_ADDR
41700: LD_EXP 93
41704: PUSH
41705: FOR_TO
41706: IFFALSE 42294
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41708: LD_ADDR_VAR 0 3
41712: PUSH
41713: LD_EXP 93
41717: PUSH
41718: LD_VAR 0 2
41722: ARRAY
41723: PPUSH
41724: LD_INT 25
41726: PUSH
41727: LD_INT 4
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PPUSH
41734: CALL_OW 72
41738: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41739: LD_VAR 0 3
41743: NOT
41744: PUSH
41745: LD_EXP 130
41749: PUSH
41750: LD_VAR 0 2
41754: ARRAY
41755: NOT
41756: OR
41757: PUSH
41758: LD_EXP 93
41762: PUSH
41763: LD_VAR 0 2
41767: ARRAY
41768: PPUSH
41769: LD_INT 2
41771: PUSH
41772: LD_INT 30
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 30
41784: PUSH
41785: LD_INT 1
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: LIST
41796: PPUSH
41797: CALL_OW 72
41801: NOT
41802: OR
41803: IFFALSE 41853
// begin if mc_deposits_finder [ i ] then
41805: LD_EXP 131
41809: PUSH
41810: LD_VAR 0 2
41814: ARRAY
41815: IFFALSE 41851
// begin MC_Reset ( i , 125 ) ;
41817: LD_VAR 0 2
41821: PPUSH
41822: LD_INT 125
41824: PPUSH
41825: CALL 24956 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41829: LD_ADDR_EXP 131
41833: PUSH
41834: LD_EXP 131
41838: PPUSH
41839: LD_VAR 0 2
41843: PPUSH
41844: EMPTY
41845: PPUSH
41846: CALL_OW 1
41850: ST_TO_ADDR
// end ; continue ;
41851: GO 41705
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41853: LD_EXP 130
41857: PUSH
41858: LD_VAR 0 2
41862: ARRAY
41863: PUSH
41864: LD_INT 1
41866: ARRAY
41867: PUSH
41868: LD_INT 3
41870: ARRAY
41871: PUSH
41872: LD_INT 1
41874: EQUAL
41875: PUSH
41876: LD_INT 20
41878: PPUSH
41879: LD_EXP 119
41883: PUSH
41884: LD_VAR 0 2
41888: ARRAY
41889: PPUSH
41890: CALL_OW 321
41894: PUSH
41895: LD_INT 2
41897: NONEQUAL
41898: AND
41899: IFFALSE 41949
// begin if mc_deposits_finder [ i ] then
41901: LD_EXP 131
41905: PUSH
41906: LD_VAR 0 2
41910: ARRAY
41911: IFFALSE 41947
// begin MC_Reset ( i , 125 ) ;
41913: LD_VAR 0 2
41917: PPUSH
41918: LD_INT 125
41920: PPUSH
41921: CALL 24956 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41925: LD_ADDR_EXP 131
41929: PUSH
41930: LD_EXP 131
41934: PPUSH
41935: LD_VAR 0 2
41939: PPUSH
41940: EMPTY
41941: PPUSH
41942: CALL_OW 1
41946: ST_TO_ADDR
// end ; continue ;
41947: GO 41705
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41949: LD_EXP 130
41953: PUSH
41954: LD_VAR 0 2
41958: ARRAY
41959: PUSH
41960: LD_INT 1
41962: ARRAY
41963: PUSH
41964: LD_INT 1
41966: ARRAY
41967: PPUSH
41968: LD_EXP 130
41972: PUSH
41973: LD_VAR 0 2
41977: ARRAY
41978: PUSH
41979: LD_INT 1
41981: ARRAY
41982: PUSH
41983: LD_INT 2
41985: ARRAY
41986: PPUSH
41987: LD_EXP 119
41991: PUSH
41992: LD_VAR 0 2
41996: ARRAY
41997: PPUSH
41998: CALL_OW 440
42002: IFFALSE 42045
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42004: LD_ADDR_EXP 130
42008: PUSH
42009: LD_EXP 130
42013: PPUSH
42014: LD_VAR 0 2
42018: PPUSH
42019: LD_EXP 130
42023: PUSH
42024: LD_VAR 0 2
42028: ARRAY
42029: PPUSH
42030: LD_INT 1
42032: PPUSH
42033: CALL_OW 3
42037: PPUSH
42038: CALL_OW 1
42042: ST_TO_ADDR
42043: GO 42292
// begin if not mc_deposits_finder [ i ] then
42045: LD_EXP 131
42049: PUSH
42050: LD_VAR 0 2
42054: ARRAY
42055: NOT
42056: IFFALSE 42108
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42058: LD_ADDR_EXP 131
42062: PUSH
42063: LD_EXP 131
42067: PPUSH
42068: LD_VAR 0 2
42072: PPUSH
42073: LD_VAR 0 3
42077: PUSH
42078: LD_INT 1
42080: ARRAY
42081: PUSH
42082: EMPTY
42083: LIST
42084: PPUSH
42085: CALL_OW 1
42089: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42090: LD_VAR 0 3
42094: PUSH
42095: LD_INT 1
42097: ARRAY
42098: PPUSH
42099: LD_INT 125
42101: PPUSH
42102: CALL_OW 109
// end else
42106: GO 42292
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42108: LD_EXP 131
42112: PUSH
42113: LD_VAR 0 2
42117: ARRAY
42118: PUSH
42119: LD_INT 1
42121: ARRAY
42122: PPUSH
42123: CALL_OW 310
42127: IFFALSE 42150
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42129: LD_EXP 131
42133: PUSH
42134: LD_VAR 0 2
42138: ARRAY
42139: PUSH
42140: LD_INT 1
42142: ARRAY
42143: PPUSH
42144: CALL_OW 122
42148: GO 42292
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42150: LD_EXP 131
42154: PUSH
42155: LD_VAR 0 2
42159: ARRAY
42160: PUSH
42161: LD_INT 1
42163: ARRAY
42164: PPUSH
42165: CALL_OW 314
42169: NOT
42170: PUSH
42171: LD_EXP 131
42175: PUSH
42176: LD_VAR 0 2
42180: ARRAY
42181: PUSH
42182: LD_INT 1
42184: ARRAY
42185: PPUSH
42186: LD_EXP 130
42190: PUSH
42191: LD_VAR 0 2
42195: ARRAY
42196: PUSH
42197: LD_INT 1
42199: ARRAY
42200: PUSH
42201: LD_INT 1
42203: ARRAY
42204: PPUSH
42205: LD_EXP 130
42209: PUSH
42210: LD_VAR 0 2
42214: ARRAY
42215: PUSH
42216: LD_INT 1
42218: ARRAY
42219: PUSH
42220: LD_INT 2
42222: ARRAY
42223: PPUSH
42224: CALL_OW 297
42228: PUSH
42229: LD_INT 6
42231: GREATER
42232: AND
42233: IFFALSE 42292
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42235: LD_EXP 131
42239: PUSH
42240: LD_VAR 0 2
42244: ARRAY
42245: PUSH
42246: LD_INT 1
42248: ARRAY
42249: PPUSH
42250: LD_EXP 130
42254: PUSH
42255: LD_VAR 0 2
42259: ARRAY
42260: PUSH
42261: LD_INT 1
42263: ARRAY
42264: PUSH
42265: LD_INT 1
42267: ARRAY
42268: PPUSH
42269: LD_EXP 130
42273: PUSH
42274: LD_VAR 0 2
42278: ARRAY
42279: PUSH
42280: LD_INT 1
42282: ARRAY
42283: PUSH
42284: LD_INT 2
42286: ARRAY
42287: PPUSH
42288: CALL_OW 111
// end ; end ; end ;
42292: GO 41705
42294: POP
42295: POP
// end ;
42296: LD_VAR 0 1
42300: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42301: LD_INT 0
42303: PPUSH
42304: PPUSH
42305: PPUSH
42306: PPUSH
42307: PPUSH
42308: PPUSH
42309: PPUSH
42310: PPUSH
42311: PPUSH
42312: PPUSH
42313: PPUSH
// if not mc_bases then
42314: LD_EXP 93
42318: NOT
42319: IFFALSE 42323
// exit ;
42321: GO 43263
// for i = 1 to mc_bases do
42323: LD_ADDR_VAR 0 2
42327: PUSH
42328: DOUBLE
42329: LD_INT 1
42331: DEC
42332: ST_TO_ADDR
42333: LD_EXP 93
42337: PUSH
42338: FOR_TO
42339: IFFALSE 43261
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42341: LD_EXP 93
42345: PUSH
42346: LD_VAR 0 2
42350: ARRAY
42351: NOT
42352: PUSH
42353: LD_EXP 116
42357: PUSH
42358: LD_VAR 0 2
42362: ARRAY
42363: OR
42364: IFFALSE 42368
// continue ;
42366: GO 42338
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
42368: LD_ADDR_VAR 0 7
42372: PUSH
42373: LD_EXP 93
42377: PUSH
42378: LD_VAR 0 2
42382: ARRAY
42383: PUSH
42384: LD_INT 1
42386: ARRAY
42387: PPUSH
42388: CALL_OW 248
42392: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
42393: LD_VAR 0 7
42397: PUSH
42398: LD_INT 3
42400: EQUAL
42401: PUSH
42402: LD_EXP 112
42406: PUSH
42407: LD_VAR 0 2
42411: ARRAY
42412: PUSH
42413: LD_EXP 115
42417: PUSH
42418: LD_VAR 0 2
42422: ARRAY
42423: UNION
42424: PPUSH
42425: LD_INT 33
42427: PUSH
42428: LD_INT 2
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PPUSH
42435: CALL_OW 72
42439: NOT
42440: OR
42441: IFFALSE 42445
// continue ;
42443: GO 42338
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
42445: LD_ADDR_VAR 0 9
42449: PUSH
42450: LD_EXP 93
42454: PUSH
42455: LD_VAR 0 2
42459: ARRAY
42460: PPUSH
42461: LD_INT 30
42463: PUSH
42464: LD_INT 36
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PPUSH
42471: CALL_OW 72
42475: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
42476: LD_ADDR_VAR 0 10
42480: PUSH
42481: LD_EXP 112
42485: PUSH
42486: LD_VAR 0 2
42490: ARRAY
42491: PPUSH
42492: LD_INT 34
42494: PUSH
42495: LD_INT 31
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PPUSH
42502: CALL_OW 72
42506: ST_TO_ADDR
// if not cts and not mcts then
42507: LD_VAR 0 9
42511: NOT
42512: PUSH
42513: LD_VAR 0 10
42517: NOT
42518: AND
42519: IFFALSE 42523
// continue ;
42521: GO 42338
// x := cts ;
42523: LD_ADDR_VAR 0 11
42527: PUSH
42528: LD_VAR 0 9
42532: ST_TO_ADDR
// if not x then
42533: LD_VAR 0 11
42537: NOT
42538: IFFALSE 42550
// x := mcts ;
42540: LD_ADDR_VAR 0 11
42544: PUSH
42545: LD_VAR 0 10
42549: ST_TO_ADDR
// if not x then
42550: LD_VAR 0 11
42554: NOT
42555: IFFALSE 42559
// continue ;
42557: GO 42338
// if mc_remote_driver [ i ] then
42559: LD_EXP 133
42563: PUSH
42564: LD_VAR 0 2
42568: ARRAY
42569: IFFALSE 42956
// for j in mc_remote_driver [ i ] do
42571: LD_ADDR_VAR 0 3
42575: PUSH
42576: LD_EXP 133
42580: PUSH
42581: LD_VAR 0 2
42585: ARRAY
42586: PUSH
42587: FOR_IN
42588: IFFALSE 42954
// begin if GetClass ( j ) <> 3 then
42590: LD_VAR 0 3
42594: PPUSH
42595: CALL_OW 257
42599: PUSH
42600: LD_INT 3
42602: NONEQUAL
42603: IFFALSE 42656
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
42605: LD_ADDR_EXP 133
42609: PUSH
42610: LD_EXP 133
42614: PPUSH
42615: LD_VAR 0 2
42619: PPUSH
42620: LD_EXP 133
42624: PUSH
42625: LD_VAR 0 2
42629: ARRAY
42630: PUSH
42631: LD_VAR 0 3
42635: DIFF
42636: PPUSH
42637: CALL_OW 1
42641: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42642: LD_VAR 0 3
42646: PPUSH
42647: LD_INT 0
42649: PPUSH
42650: CALL_OW 109
// continue ;
42654: GO 42587
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
42656: LD_EXP 112
42660: PUSH
42661: LD_VAR 0 2
42665: ARRAY
42666: PPUSH
42667: LD_INT 34
42669: PUSH
42670: LD_INT 31
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 58
42679: PUSH
42680: EMPTY
42681: LIST
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PPUSH
42687: CALL_OW 72
42691: PUSH
42692: LD_VAR 0 3
42696: PPUSH
42697: CALL 85624 0 1
42701: NOT
42702: AND
42703: IFFALSE 42774
// begin if IsInUnit ( j ) then
42705: LD_VAR 0 3
42709: PPUSH
42710: CALL_OW 310
42714: IFFALSE 42725
// ComExitBuilding ( j ) ;
42716: LD_VAR 0 3
42720: PPUSH
42721: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42725: LD_VAR 0 3
42729: PPUSH
42730: LD_EXP 112
42734: PUSH
42735: LD_VAR 0 2
42739: ARRAY
42740: PPUSH
42741: LD_INT 34
42743: PUSH
42744: LD_INT 31
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 58
42753: PUSH
42754: EMPTY
42755: LIST
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PPUSH
42761: CALL_OW 72
42765: PUSH
42766: LD_INT 1
42768: ARRAY
42769: PPUSH
42770: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42774: LD_VAR 0 3
42778: PPUSH
42779: CALL_OW 310
42783: NOT
42784: PUSH
42785: LD_VAR 0 3
42789: PPUSH
42790: CALL_OW 310
42794: PPUSH
42795: CALL_OW 266
42799: PUSH
42800: LD_INT 36
42802: NONEQUAL
42803: PUSH
42804: LD_VAR 0 3
42808: PPUSH
42809: CALL 85624 0 1
42813: NOT
42814: AND
42815: OR
42816: IFFALSE 42952
// begin if IsInUnit ( j ) then
42818: LD_VAR 0 3
42822: PPUSH
42823: CALL_OW 310
42827: IFFALSE 42838
// ComExitBuilding ( j ) ;
42829: LD_VAR 0 3
42833: PPUSH
42834: CALL_OW 122
// ct := 0 ;
42838: LD_ADDR_VAR 0 8
42842: PUSH
42843: LD_INT 0
42845: ST_TO_ADDR
// for k in x do
42846: LD_ADDR_VAR 0 4
42850: PUSH
42851: LD_VAR 0 11
42855: PUSH
42856: FOR_IN
42857: IFFALSE 42930
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42859: LD_VAR 0 4
42863: PPUSH
42864: CALL_OW 264
42868: PUSH
42869: LD_INT 31
42871: EQUAL
42872: PUSH
42873: LD_VAR 0 4
42877: PPUSH
42878: CALL_OW 311
42882: NOT
42883: AND
42884: PUSH
42885: LD_VAR 0 4
42889: PPUSH
42890: CALL_OW 266
42894: PUSH
42895: LD_INT 36
42897: EQUAL
42898: PUSH
42899: LD_VAR 0 4
42903: PPUSH
42904: CALL_OW 313
42908: PUSH
42909: LD_INT 3
42911: LESS
42912: AND
42913: OR
42914: IFFALSE 42928
// begin ct := k ;
42916: LD_ADDR_VAR 0 8
42920: PUSH
42921: LD_VAR 0 4
42925: ST_TO_ADDR
// break ;
42926: GO 42930
// end ;
42928: GO 42856
42930: POP
42931: POP
// if ct then
42932: LD_VAR 0 8
42936: IFFALSE 42952
// ComEnterUnit ( j , ct ) ;
42938: LD_VAR 0 3
42942: PPUSH
42943: LD_VAR 0 8
42947: PPUSH
42948: CALL_OW 120
// end ; end ;
42952: GO 42587
42954: POP
42955: POP
// places := 0 ;
42956: LD_ADDR_VAR 0 5
42960: PUSH
42961: LD_INT 0
42963: ST_TO_ADDR
// for j = 1 to x do
42964: LD_ADDR_VAR 0 3
42968: PUSH
42969: DOUBLE
42970: LD_INT 1
42972: DEC
42973: ST_TO_ADDR
42974: LD_VAR 0 11
42978: PUSH
42979: FOR_TO
42980: IFFALSE 43056
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42982: LD_VAR 0 11
42986: PUSH
42987: LD_VAR 0 3
42991: ARRAY
42992: PPUSH
42993: CALL_OW 264
42997: PUSH
42998: LD_INT 31
43000: EQUAL
43001: IFFALSE 43019
// places := places + 1 else
43003: LD_ADDR_VAR 0 5
43007: PUSH
43008: LD_VAR 0 5
43012: PUSH
43013: LD_INT 1
43015: PLUS
43016: ST_TO_ADDR
43017: GO 43054
// if GetBType ( x [ j ] ) = b_control_tower then
43019: LD_VAR 0 11
43023: PUSH
43024: LD_VAR 0 3
43028: ARRAY
43029: PPUSH
43030: CALL_OW 266
43034: PUSH
43035: LD_INT 36
43037: EQUAL
43038: IFFALSE 43054
// places := places + 3 ;
43040: LD_ADDR_VAR 0 5
43044: PUSH
43045: LD_VAR 0 5
43049: PUSH
43050: LD_INT 3
43052: PLUS
43053: ST_TO_ADDR
43054: GO 42979
43056: POP
43057: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43058: LD_VAR 0 5
43062: PUSH
43063: LD_INT 0
43065: EQUAL
43066: PUSH
43067: LD_VAR 0 5
43071: PUSH
43072: LD_EXP 133
43076: PUSH
43077: LD_VAR 0 2
43081: ARRAY
43082: LESSEQUAL
43083: OR
43084: IFFALSE 43088
// continue ;
43086: GO 42338
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43088: LD_ADDR_VAR 0 6
43092: PUSH
43093: LD_EXP 93
43097: PUSH
43098: LD_VAR 0 2
43102: ARRAY
43103: PPUSH
43104: LD_INT 25
43106: PUSH
43107: LD_INT 3
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PPUSH
43114: CALL_OW 72
43118: PUSH
43119: LD_EXP 133
43123: PUSH
43124: LD_VAR 0 2
43128: ARRAY
43129: DIFF
43130: PPUSH
43131: LD_INT 3
43133: PPUSH
43134: CALL 86524 0 2
43138: ST_TO_ADDR
// for j in tmp do
43139: LD_ADDR_VAR 0 3
43143: PUSH
43144: LD_VAR 0 6
43148: PUSH
43149: FOR_IN
43150: IFFALSE 43185
// if GetTag ( j ) > 0 then
43152: LD_VAR 0 3
43156: PPUSH
43157: CALL_OW 110
43161: PUSH
43162: LD_INT 0
43164: GREATER
43165: IFFALSE 43183
// tmp := tmp diff j ;
43167: LD_ADDR_VAR 0 6
43171: PUSH
43172: LD_VAR 0 6
43176: PUSH
43177: LD_VAR 0 3
43181: DIFF
43182: ST_TO_ADDR
43183: GO 43149
43185: POP
43186: POP
// if not tmp then
43187: LD_VAR 0 6
43191: NOT
43192: IFFALSE 43196
// continue ;
43194: GO 42338
// if places then
43196: LD_VAR 0 5
43200: IFFALSE 43259
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43202: LD_ADDR_EXP 133
43206: PUSH
43207: LD_EXP 133
43211: PPUSH
43212: LD_VAR 0 2
43216: PPUSH
43217: LD_EXP 133
43221: PUSH
43222: LD_VAR 0 2
43226: ARRAY
43227: PUSH
43228: LD_VAR 0 6
43232: PUSH
43233: LD_INT 1
43235: ARRAY
43236: UNION
43237: PPUSH
43238: CALL_OW 1
43242: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43243: LD_VAR 0 6
43247: PUSH
43248: LD_INT 1
43250: ARRAY
43251: PPUSH
43252: LD_INT 126
43254: PPUSH
43255: CALL_OW 109
// end ; end ;
43259: GO 42338
43261: POP
43262: POP
// end ;
43263: LD_VAR 0 1
43267: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43268: LD_INT 0
43270: PPUSH
43271: PPUSH
43272: PPUSH
43273: PPUSH
43274: PPUSH
43275: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43276: LD_VAR 0 1
43280: NOT
43281: PUSH
43282: LD_VAR 0 2
43286: NOT
43287: OR
43288: PUSH
43289: LD_VAR 0 3
43293: NOT
43294: OR
43295: PUSH
43296: LD_VAR 0 4
43300: PUSH
43301: LD_INT 1
43303: PUSH
43304: LD_INT 2
43306: PUSH
43307: LD_INT 3
43309: PUSH
43310: LD_INT 4
43312: PUSH
43313: LD_INT 5
43315: PUSH
43316: LD_INT 8
43318: PUSH
43319: LD_INT 9
43321: PUSH
43322: LD_INT 15
43324: PUSH
43325: LD_INT 16
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: LIST
43332: LIST
43333: LIST
43334: LIST
43335: LIST
43336: LIST
43337: LIST
43338: IN
43339: NOT
43340: OR
43341: IFFALSE 43345
// exit ;
43343: GO 44245
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43345: LD_ADDR_VAR 0 2
43349: PUSH
43350: LD_VAR 0 2
43354: PPUSH
43355: LD_INT 21
43357: PUSH
43358: LD_INT 3
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: LD_INT 24
43367: PUSH
43368: LD_INT 250
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: EMPTY
43376: LIST
43377: LIST
43378: PPUSH
43379: CALL_OW 72
43383: ST_TO_ADDR
// case class of 1 , 15 :
43384: LD_VAR 0 4
43388: PUSH
43389: LD_INT 1
43391: DOUBLE
43392: EQUAL
43393: IFTRUE 43403
43395: LD_INT 15
43397: DOUBLE
43398: EQUAL
43399: IFTRUE 43403
43401: GO 43488
43403: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
43404: LD_ADDR_VAR 0 8
43408: PUSH
43409: LD_VAR 0 2
43413: PPUSH
43414: LD_INT 2
43416: PUSH
43417: LD_INT 30
43419: PUSH
43420: LD_INT 32
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: LD_INT 30
43429: PUSH
43430: LD_INT 31
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: LIST
43441: PPUSH
43442: CALL_OW 72
43446: PUSH
43447: LD_VAR 0 2
43451: PPUSH
43452: LD_INT 2
43454: PUSH
43455: LD_INT 30
43457: PUSH
43458: LD_INT 4
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PUSH
43465: LD_INT 30
43467: PUSH
43468: LD_INT 5
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: LIST
43479: PPUSH
43480: CALL_OW 72
43484: ADD
43485: ST_TO_ADDR
43486: GO 43734
43488: LD_INT 2
43490: DOUBLE
43491: EQUAL
43492: IFTRUE 43502
43494: LD_INT 16
43496: DOUBLE
43497: EQUAL
43498: IFTRUE 43502
43500: GO 43548
43502: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
43503: LD_ADDR_VAR 0 8
43507: PUSH
43508: LD_VAR 0 2
43512: PPUSH
43513: LD_INT 2
43515: PUSH
43516: LD_INT 30
43518: PUSH
43519: LD_INT 0
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: LD_INT 30
43528: PUSH
43529: LD_INT 1
43531: PUSH
43532: EMPTY
43533: LIST
43534: LIST
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: LIST
43540: PPUSH
43541: CALL_OW 72
43545: ST_TO_ADDR
43546: GO 43734
43548: LD_INT 3
43550: DOUBLE
43551: EQUAL
43552: IFTRUE 43556
43554: GO 43602
43556: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
43557: LD_ADDR_VAR 0 8
43561: PUSH
43562: LD_VAR 0 2
43566: PPUSH
43567: LD_INT 2
43569: PUSH
43570: LD_INT 30
43572: PUSH
43573: LD_INT 2
43575: PUSH
43576: EMPTY
43577: LIST
43578: LIST
43579: PUSH
43580: LD_INT 30
43582: PUSH
43583: LD_INT 3
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: LIST
43594: PPUSH
43595: CALL_OW 72
43599: ST_TO_ADDR
43600: GO 43734
43602: LD_INT 4
43604: DOUBLE
43605: EQUAL
43606: IFTRUE 43610
43608: GO 43667
43610: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
43611: LD_ADDR_VAR 0 8
43615: PUSH
43616: LD_VAR 0 2
43620: PPUSH
43621: LD_INT 2
43623: PUSH
43624: LD_INT 30
43626: PUSH
43627: LD_INT 6
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 30
43636: PUSH
43637: LD_INT 7
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 30
43646: PUSH
43647: LD_INT 8
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: LIST
43658: LIST
43659: PPUSH
43660: CALL_OW 72
43664: ST_TO_ADDR
43665: GO 43734
43667: LD_INT 5
43669: DOUBLE
43670: EQUAL
43671: IFTRUE 43687
43673: LD_INT 8
43675: DOUBLE
43676: EQUAL
43677: IFTRUE 43687
43679: LD_INT 9
43681: DOUBLE
43682: EQUAL
43683: IFTRUE 43687
43685: GO 43733
43687: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43688: LD_ADDR_VAR 0 8
43692: PUSH
43693: LD_VAR 0 2
43697: PPUSH
43698: LD_INT 2
43700: PUSH
43701: LD_INT 30
43703: PUSH
43704: LD_INT 4
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 30
43713: PUSH
43714: LD_INT 5
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: LIST
43725: PPUSH
43726: CALL_OW 72
43730: ST_TO_ADDR
43731: GO 43734
43733: POP
// if not tmp then
43734: LD_VAR 0 8
43738: NOT
43739: IFFALSE 43743
// exit ;
43741: GO 44245
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43743: LD_VAR 0 4
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: LD_INT 15
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: IN
43758: PUSH
43759: LD_EXP 102
43763: PUSH
43764: LD_VAR 0 1
43768: ARRAY
43769: AND
43770: IFFALSE 43926
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43772: LD_ADDR_VAR 0 9
43776: PUSH
43777: LD_EXP 102
43781: PUSH
43782: LD_VAR 0 1
43786: ARRAY
43787: PUSH
43788: LD_INT 1
43790: ARRAY
43791: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43792: LD_VAR 0 9
43796: PUSH
43797: LD_EXP 103
43801: PUSH
43802: LD_VAR 0 1
43806: ARRAY
43807: IN
43808: NOT
43809: IFFALSE 43924
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43811: LD_ADDR_EXP 103
43815: PUSH
43816: LD_EXP 103
43820: PPUSH
43821: LD_VAR 0 1
43825: PUSH
43826: LD_EXP 103
43830: PUSH
43831: LD_VAR 0 1
43835: ARRAY
43836: PUSH
43837: LD_INT 1
43839: PLUS
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PPUSH
43845: LD_VAR 0 9
43849: PPUSH
43850: CALL 56267 0 3
43854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43855: LD_ADDR_EXP 102
43859: PUSH
43860: LD_EXP 102
43864: PPUSH
43865: LD_VAR 0 1
43869: PPUSH
43870: LD_EXP 102
43874: PUSH
43875: LD_VAR 0 1
43879: ARRAY
43880: PUSH
43881: LD_VAR 0 9
43885: DIFF
43886: PPUSH
43887: CALL_OW 1
43891: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43892: LD_VAR 0 3
43896: PPUSH
43897: LD_EXP 103
43901: PUSH
43902: LD_VAR 0 1
43906: ARRAY
43907: PUSH
43908: LD_EXP 103
43912: PUSH
43913: LD_VAR 0 1
43917: ARRAY
43918: ARRAY
43919: PPUSH
43920: CALL_OW 120
// end ; exit ;
43924: GO 44245
// end ; if tmp > 1 then
43926: LD_VAR 0 8
43930: PUSH
43931: LD_INT 1
43933: GREATER
43934: IFFALSE 44038
// for i = 2 to tmp do
43936: LD_ADDR_VAR 0 6
43940: PUSH
43941: DOUBLE
43942: LD_INT 2
43944: DEC
43945: ST_TO_ADDR
43946: LD_VAR 0 8
43950: PUSH
43951: FOR_TO
43952: IFFALSE 44036
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43954: LD_VAR 0 8
43958: PUSH
43959: LD_VAR 0 6
43963: ARRAY
43964: PPUSH
43965: CALL_OW 461
43969: PUSH
43970: LD_INT 6
43972: EQUAL
43973: IFFALSE 44034
// begin x := tmp [ i ] ;
43975: LD_ADDR_VAR 0 9
43979: PUSH
43980: LD_VAR 0 8
43984: PUSH
43985: LD_VAR 0 6
43989: ARRAY
43990: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43991: LD_ADDR_VAR 0 8
43995: PUSH
43996: LD_VAR 0 8
44000: PPUSH
44001: LD_VAR 0 6
44005: PPUSH
44006: CALL_OW 3
44010: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44011: LD_ADDR_VAR 0 8
44015: PUSH
44016: LD_VAR 0 8
44020: PPUSH
44021: LD_INT 1
44023: PPUSH
44024: LD_VAR 0 9
44028: PPUSH
44029: CALL_OW 2
44033: ST_TO_ADDR
// end ;
44034: GO 43951
44036: POP
44037: POP
// for i in tmp do
44038: LD_ADDR_VAR 0 6
44042: PUSH
44043: LD_VAR 0 8
44047: PUSH
44048: FOR_IN
44049: IFFALSE 44118
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44051: LD_VAR 0 6
44055: PPUSH
44056: CALL_OW 313
44060: PUSH
44061: LD_INT 6
44063: LESS
44064: PUSH
44065: LD_VAR 0 6
44069: PPUSH
44070: CALL_OW 266
44074: PUSH
44075: LD_INT 31
44077: PUSH
44078: LD_INT 32
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: IN
44085: NOT
44086: AND
44087: PUSH
44088: LD_VAR 0 6
44092: PPUSH
44093: CALL_OW 313
44097: PUSH
44098: LD_INT 0
44100: EQUAL
44101: OR
44102: IFFALSE 44116
// begin j := i ;
44104: LD_ADDR_VAR 0 7
44108: PUSH
44109: LD_VAR 0 6
44113: ST_TO_ADDR
// break ;
44114: GO 44118
// end ; end ;
44116: GO 44048
44118: POP
44119: POP
// if j then
44120: LD_VAR 0 7
44124: IFFALSE 44142
// ComEnterUnit ( unit , j ) else
44126: LD_VAR 0 3
44130: PPUSH
44131: LD_VAR 0 7
44135: PPUSH
44136: CALL_OW 120
44140: GO 44245
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44142: LD_ADDR_VAR 0 10
44146: PUSH
44147: LD_VAR 0 2
44151: PPUSH
44152: LD_INT 2
44154: PUSH
44155: LD_INT 30
44157: PUSH
44158: LD_INT 0
44160: PUSH
44161: EMPTY
44162: LIST
44163: LIST
44164: PUSH
44165: LD_INT 30
44167: PUSH
44168: LD_INT 1
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: LIST
44179: PPUSH
44180: CALL_OW 72
44184: ST_TO_ADDR
// if depot then
44185: LD_VAR 0 10
44189: IFFALSE 44245
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44191: LD_ADDR_VAR 0 10
44195: PUSH
44196: LD_VAR 0 10
44200: PPUSH
44201: LD_VAR 0 3
44205: PPUSH
44206: CALL_OW 74
44210: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44211: LD_VAR 0 3
44215: PPUSH
44216: LD_VAR 0 10
44220: PPUSH
44221: CALL_OW 296
44225: PUSH
44226: LD_INT 10
44228: GREATER
44229: IFFALSE 44245
// ComStandNearbyBuilding ( unit , depot ) ;
44231: LD_VAR 0 3
44235: PPUSH
44236: LD_VAR 0 10
44240: PPUSH
44241: CALL 52845 0 2
// end ; end ; end ;
44245: LD_VAR 0 5
44249: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44250: LD_INT 0
44252: PPUSH
44253: PPUSH
44254: PPUSH
44255: PPUSH
// if not mc_bases then
44256: LD_EXP 93
44260: NOT
44261: IFFALSE 44265
// exit ;
44263: GO 44504
// for i = 1 to mc_bases do
44265: LD_ADDR_VAR 0 2
44269: PUSH
44270: DOUBLE
44271: LD_INT 1
44273: DEC
44274: ST_TO_ADDR
44275: LD_EXP 93
44279: PUSH
44280: FOR_TO
44281: IFFALSE 44502
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44283: LD_ADDR_VAR 0 4
44287: PUSH
44288: LD_EXP 93
44292: PUSH
44293: LD_VAR 0 2
44297: ARRAY
44298: PPUSH
44299: LD_INT 21
44301: PUSH
44302: LD_INT 1
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PPUSH
44309: CALL_OW 72
44313: PUSH
44314: LD_EXP 122
44318: PUSH
44319: LD_VAR 0 2
44323: ARRAY
44324: UNION
44325: ST_TO_ADDR
// if not tmp then
44326: LD_VAR 0 4
44330: NOT
44331: IFFALSE 44335
// continue ;
44333: GO 44280
// for j in tmp do
44335: LD_ADDR_VAR 0 3
44339: PUSH
44340: LD_VAR 0 4
44344: PUSH
44345: FOR_IN
44346: IFFALSE 44498
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44348: LD_VAR 0 3
44352: PPUSH
44353: CALL_OW 110
44357: NOT
44358: PUSH
44359: LD_VAR 0 3
44363: PPUSH
44364: CALL_OW 314
44368: NOT
44369: AND
44370: PUSH
44371: LD_VAR 0 3
44375: PPUSH
44376: CALL_OW 311
44380: NOT
44381: AND
44382: PUSH
44383: LD_VAR 0 3
44387: PPUSH
44388: CALL_OW 310
44392: NOT
44393: AND
44394: PUSH
44395: LD_VAR 0 3
44399: PUSH
44400: LD_EXP 96
44404: PUSH
44405: LD_VAR 0 2
44409: ARRAY
44410: PUSH
44411: LD_INT 1
44413: ARRAY
44414: IN
44415: NOT
44416: AND
44417: PUSH
44418: LD_VAR 0 3
44422: PUSH
44423: LD_EXP 96
44427: PUSH
44428: LD_VAR 0 2
44432: ARRAY
44433: PUSH
44434: LD_INT 2
44436: ARRAY
44437: IN
44438: NOT
44439: AND
44440: PUSH
44441: LD_VAR 0 3
44445: PUSH
44446: LD_EXP 105
44450: PUSH
44451: LD_VAR 0 2
44455: ARRAY
44456: IN
44457: NOT
44458: AND
44459: IFFALSE 44496
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
44461: LD_VAR 0 2
44465: PPUSH
44466: LD_EXP 93
44470: PUSH
44471: LD_VAR 0 2
44475: ARRAY
44476: PPUSH
44477: LD_VAR 0 3
44481: PPUSH
44482: LD_VAR 0 3
44486: PPUSH
44487: CALL_OW 257
44491: PPUSH
44492: CALL 43268 0 4
// end ;
44496: GO 44345
44498: POP
44499: POP
// end ;
44500: GO 44280
44502: POP
44503: POP
// end ;
44504: LD_VAR 0 1
44508: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
44509: LD_INT 0
44511: PPUSH
44512: PPUSH
44513: PPUSH
44514: PPUSH
44515: PPUSH
44516: PPUSH
// if not mc_bases [ base ] then
44517: LD_EXP 93
44521: PUSH
44522: LD_VAR 0 1
44526: ARRAY
44527: NOT
44528: IFFALSE 44532
// exit ;
44530: GO 44714
// tmp := [ ] ;
44532: LD_ADDR_VAR 0 6
44536: PUSH
44537: EMPTY
44538: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
44539: LD_ADDR_VAR 0 7
44543: PUSH
44544: LD_VAR 0 3
44548: PPUSH
44549: LD_INT 0
44551: PPUSH
44552: CALL_OW 517
44556: ST_TO_ADDR
// if not list then
44557: LD_VAR 0 7
44561: NOT
44562: IFFALSE 44566
// exit ;
44564: GO 44714
// for i = 1 to amount do
44566: LD_ADDR_VAR 0 5
44570: PUSH
44571: DOUBLE
44572: LD_INT 1
44574: DEC
44575: ST_TO_ADDR
44576: LD_VAR 0 2
44580: PUSH
44581: FOR_TO
44582: IFFALSE 44662
// begin x := rand ( 1 , list [ 1 ] ) ;
44584: LD_ADDR_VAR 0 8
44588: PUSH
44589: LD_INT 1
44591: PPUSH
44592: LD_VAR 0 7
44596: PUSH
44597: LD_INT 1
44599: ARRAY
44600: PPUSH
44601: CALL_OW 12
44605: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
44606: LD_ADDR_VAR 0 6
44610: PUSH
44611: LD_VAR 0 6
44615: PPUSH
44616: LD_VAR 0 5
44620: PPUSH
44621: LD_VAR 0 7
44625: PUSH
44626: LD_INT 1
44628: ARRAY
44629: PUSH
44630: LD_VAR 0 8
44634: ARRAY
44635: PUSH
44636: LD_VAR 0 7
44640: PUSH
44641: LD_INT 2
44643: ARRAY
44644: PUSH
44645: LD_VAR 0 8
44649: ARRAY
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PPUSH
44655: CALL_OW 1
44659: ST_TO_ADDR
// end ;
44660: GO 44581
44662: POP
44663: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
44664: LD_ADDR_EXP 106
44668: PUSH
44669: LD_EXP 106
44673: PPUSH
44674: LD_VAR 0 1
44678: PPUSH
44679: LD_VAR 0 6
44683: PPUSH
44684: CALL_OW 1
44688: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44689: LD_ADDR_EXP 108
44693: PUSH
44694: LD_EXP 108
44698: PPUSH
44699: LD_VAR 0 1
44703: PPUSH
44704: LD_VAR 0 3
44708: PPUSH
44709: CALL_OW 1
44713: ST_TO_ADDR
// end ;
44714: LD_VAR 0 4
44718: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44719: LD_INT 0
44721: PPUSH
// if not mc_bases [ base ] then
44722: LD_EXP 93
44726: PUSH
44727: LD_VAR 0 1
44731: ARRAY
44732: NOT
44733: IFFALSE 44737
// exit ;
44735: GO 44762
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44737: LD_ADDR_EXP 98
44741: PUSH
44742: LD_EXP 98
44746: PPUSH
44747: LD_VAR 0 1
44751: PPUSH
44752: LD_VAR 0 2
44756: PPUSH
44757: CALL_OW 1
44761: ST_TO_ADDR
// end ;
44762: LD_VAR 0 3
44766: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44767: LD_INT 0
44769: PPUSH
// if not mc_bases [ base ] then
44770: LD_EXP 93
44774: PUSH
44775: LD_VAR 0 1
44779: ARRAY
44780: NOT
44781: IFFALSE 44785
// exit ;
44783: GO 44822
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44785: LD_ADDR_EXP 98
44789: PUSH
44790: LD_EXP 98
44794: PPUSH
44795: LD_VAR 0 1
44799: PPUSH
44800: LD_EXP 98
44804: PUSH
44805: LD_VAR 0 1
44809: ARRAY
44810: PUSH
44811: LD_VAR 0 2
44815: UNION
44816: PPUSH
44817: CALL_OW 1
44821: ST_TO_ADDR
// end ;
44822: LD_VAR 0 3
44826: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44827: LD_INT 0
44829: PPUSH
// if not mc_bases [ base ] then
44830: LD_EXP 93
44834: PUSH
44835: LD_VAR 0 1
44839: ARRAY
44840: NOT
44841: IFFALSE 44845
// exit ;
44843: GO 44870
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44845: LD_ADDR_EXP 114
44849: PUSH
44850: LD_EXP 114
44854: PPUSH
44855: LD_VAR 0 1
44859: PPUSH
44860: LD_VAR 0 2
44864: PPUSH
44865: CALL_OW 1
44869: ST_TO_ADDR
// end ;
44870: LD_VAR 0 3
44874: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44875: LD_INT 0
44877: PPUSH
// if not mc_bases [ base ] then
44878: LD_EXP 93
44882: PUSH
44883: LD_VAR 0 1
44887: ARRAY
44888: NOT
44889: IFFALSE 44893
// exit ;
44891: GO 44930
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44893: LD_ADDR_EXP 114
44897: PUSH
44898: LD_EXP 114
44902: PPUSH
44903: LD_VAR 0 1
44907: PPUSH
44908: LD_EXP 114
44912: PUSH
44913: LD_VAR 0 1
44917: ARRAY
44918: PUSH
44919: LD_VAR 0 2
44923: ADD
44924: PPUSH
44925: CALL_OW 1
44929: ST_TO_ADDR
// end ;
44930: LD_VAR 0 3
44934: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44935: LD_INT 0
44937: PPUSH
// if not mc_bases [ base ] then
44938: LD_EXP 93
44942: PUSH
44943: LD_VAR 0 1
44947: ARRAY
44948: NOT
44949: IFFALSE 44953
// exit ;
44951: GO 45007
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44953: LD_ADDR_EXP 115
44957: PUSH
44958: LD_EXP 115
44962: PPUSH
44963: LD_VAR 0 1
44967: PPUSH
44968: LD_VAR 0 2
44972: PPUSH
44973: CALL_OW 1
44977: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44978: LD_ADDR_EXP 104
44982: PUSH
44983: LD_EXP 104
44987: PPUSH
44988: LD_VAR 0 1
44992: PPUSH
44993: LD_VAR 0 2
44997: PUSH
44998: LD_INT 0
45000: PLUS
45001: PPUSH
45002: CALL_OW 1
45006: ST_TO_ADDR
// end ;
45007: LD_VAR 0 3
45011: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45012: LD_INT 0
45014: PPUSH
// if not mc_bases [ base ] then
45015: LD_EXP 93
45019: PUSH
45020: LD_VAR 0 1
45024: ARRAY
45025: NOT
45026: IFFALSE 45030
// exit ;
45028: GO 45055
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45030: LD_ADDR_EXP 104
45034: PUSH
45035: LD_EXP 104
45039: PPUSH
45040: LD_VAR 0 1
45044: PPUSH
45045: LD_VAR 0 2
45049: PPUSH
45050: CALL_OW 1
45054: ST_TO_ADDR
// end ;
45055: LD_VAR 0 3
45059: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45060: LD_INT 0
45062: PPUSH
45063: PPUSH
45064: PPUSH
45065: PPUSH
// if not mc_bases [ base ] then
45066: LD_EXP 93
45070: PUSH
45071: LD_VAR 0 1
45075: ARRAY
45076: NOT
45077: IFFALSE 45081
// exit ;
45079: GO 45146
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45081: LD_ADDR_EXP 113
45085: PUSH
45086: LD_EXP 113
45090: PPUSH
45091: LD_VAR 0 1
45095: PUSH
45096: LD_EXP 113
45100: PUSH
45101: LD_VAR 0 1
45105: ARRAY
45106: PUSH
45107: LD_INT 1
45109: PLUS
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PPUSH
45115: LD_VAR 0 1
45119: PUSH
45120: LD_VAR 0 2
45124: PUSH
45125: LD_VAR 0 3
45129: PUSH
45130: LD_VAR 0 4
45134: PUSH
45135: EMPTY
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: PPUSH
45141: CALL 56267 0 3
45145: ST_TO_ADDR
// end ;
45146: LD_VAR 0 5
45150: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45151: LD_INT 0
45153: PPUSH
// if not mc_bases [ base ] then
45154: LD_EXP 93
45158: PUSH
45159: LD_VAR 0 1
45163: ARRAY
45164: NOT
45165: IFFALSE 45169
// exit ;
45167: GO 45194
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45169: LD_ADDR_EXP 130
45173: PUSH
45174: LD_EXP 130
45178: PPUSH
45179: LD_VAR 0 1
45183: PPUSH
45184: LD_VAR 0 2
45188: PPUSH
45189: CALL_OW 1
45193: ST_TO_ADDR
// end ;
45194: LD_VAR 0 3
45198: RET
// export function MC_GetMinesField ( base ) ; begin
45199: LD_INT 0
45201: PPUSH
// result := mc_mines [ base ] ;
45202: LD_ADDR_VAR 0 2
45206: PUSH
45207: LD_EXP 106
45211: PUSH
45212: LD_VAR 0 1
45216: ARRAY
45217: ST_TO_ADDR
// end ;
45218: LD_VAR 0 2
45222: RET
// export function MC_GetProduceList ( base ) ; begin
45223: LD_INT 0
45225: PPUSH
// result := mc_produce [ base ] ;
45226: LD_ADDR_VAR 0 2
45230: PUSH
45231: LD_EXP 114
45235: PUSH
45236: LD_VAR 0 1
45240: ARRAY
45241: ST_TO_ADDR
// end ;
45242: LD_VAR 0 2
45246: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45247: LD_INT 0
45249: PPUSH
45250: PPUSH
// if not mc_bases then
45251: LD_EXP 93
45255: NOT
45256: IFFALSE 45260
// exit ;
45258: GO 45325
// if mc_bases [ base ] then
45260: LD_EXP 93
45264: PUSH
45265: LD_VAR 0 1
45269: ARRAY
45270: IFFALSE 45325
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45272: LD_ADDR_VAR 0 3
45276: PUSH
45277: LD_EXP 93
45281: PUSH
45282: LD_VAR 0 1
45286: ARRAY
45287: PPUSH
45288: LD_INT 30
45290: PUSH
45291: LD_VAR 0 2
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PPUSH
45300: CALL_OW 72
45304: ST_TO_ADDR
// if result then
45305: LD_VAR 0 3
45309: IFFALSE 45325
// result := result [ 1 ] ;
45311: LD_ADDR_VAR 0 3
45315: PUSH
45316: LD_VAR 0 3
45320: PUSH
45321: LD_INT 1
45323: ARRAY
45324: ST_TO_ADDR
// end ; end ;
45325: LD_VAR 0 3
45329: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45330: LD_INT 0
45332: PPUSH
45333: PPUSH
// if not mc_bases then
45334: LD_EXP 93
45338: NOT
45339: IFFALSE 45343
// exit ;
45341: GO 45388
// if mc_bases [ base ] then
45343: LD_EXP 93
45347: PUSH
45348: LD_VAR 0 1
45352: ARRAY
45353: IFFALSE 45388
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45355: LD_ADDR_VAR 0 3
45359: PUSH
45360: LD_EXP 93
45364: PUSH
45365: LD_VAR 0 1
45369: ARRAY
45370: PPUSH
45371: LD_INT 30
45373: PUSH
45374: LD_VAR 0 2
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: PPUSH
45383: CALL_OW 72
45387: ST_TO_ADDR
// end ;
45388: LD_VAR 0 3
45392: RET
// export function MC_SetTame ( base , area ) ; begin
45393: LD_INT 0
45395: PPUSH
// if not mc_bases or not base then
45396: LD_EXP 93
45400: NOT
45401: PUSH
45402: LD_VAR 0 1
45406: NOT
45407: OR
45408: IFFALSE 45412
// exit ;
45410: GO 45437
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
45412: LD_ADDR_EXP 121
45416: PUSH
45417: LD_EXP 121
45421: PPUSH
45422: LD_VAR 0 1
45426: PPUSH
45427: LD_VAR 0 2
45431: PPUSH
45432: CALL_OW 1
45436: ST_TO_ADDR
// end ;
45437: LD_VAR 0 3
45441: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
45442: LD_INT 0
45444: PPUSH
45445: PPUSH
// if not mc_bases or not base then
45446: LD_EXP 93
45450: NOT
45451: PUSH
45452: LD_VAR 0 1
45456: NOT
45457: OR
45458: IFFALSE 45462
// exit ;
45460: GO 45564
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45462: LD_ADDR_VAR 0 4
45466: PUSH
45467: LD_EXP 93
45471: PUSH
45472: LD_VAR 0 1
45476: ARRAY
45477: PPUSH
45478: LD_INT 30
45480: PUSH
45481: LD_VAR 0 2
45485: PUSH
45486: EMPTY
45487: LIST
45488: LIST
45489: PPUSH
45490: CALL_OW 72
45494: ST_TO_ADDR
// if not tmp then
45495: LD_VAR 0 4
45499: NOT
45500: IFFALSE 45504
// exit ;
45502: GO 45564
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
45504: LD_ADDR_EXP 125
45508: PUSH
45509: LD_EXP 125
45513: PPUSH
45514: LD_VAR 0 1
45518: PPUSH
45519: LD_EXP 125
45523: PUSH
45524: LD_VAR 0 1
45528: ARRAY
45529: PPUSH
45530: LD_EXP 125
45534: PUSH
45535: LD_VAR 0 1
45539: ARRAY
45540: PUSH
45541: LD_INT 1
45543: PLUS
45544: PPUSH
45545: LD_VAR 0 4
45549: PUSH
45550: LD_INT 1
45552: ARRAY
45553: PPUSH
45554: CALL_OW 2
45558: PPUSH
45559: CALL_OW 1
45563: ST_TO_ADDR
// end ;
45564: LD_VAR 0 3
45568: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
45569: LD_INT 0
45571: PPUSH
45572: PPUSH
// if not mc_bases or not base or not kinds then
45573: LD_EXP 93
45577: NOT
45578: PUSH
45579: LD_VAR 0 1
45583: NOT
45584: OR
45585: PUSH
45586: LD_VAR 0 2
45590: NOT
45591: OR
45592: IFFALSE 45596
// exit ;
45594: GO 45657
// for i in kinds do
45596: LD_ADDR_VAR 0 4
45600: PUSH
45601: LD_VAR 0 2
45605: PUSH
45606: FOR_IN
45607: IFFALSE 45655
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
45609: LD_ADDR_EXP 127
45613: PUSH
45614: LD_EXP 127
45618: PPUSH
45619: LD_VAR 0 1
45623: PUSH
45624: LD_EXP 127
45628: PUSH
45629: LD_VAR 0 1
45633: ARRAY
45634: PUSH
45635: LD_INT 1
45637: PLUS
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: PPUSH
45643: LD_VAR 0 4
45647: PPUSH
45648: CALL 56267 0 3
45652: ST_TO_ADDR
45653: GO 45606
45655: POP
45656: POP
// end ;
45657: LD_VAR 0 3
45661: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
45662: LD_INT 0
45664: PPUSH
// if not mc_bases or not base or not areas then
45665: LD_EXP 93
45669: NOT
45670: PUSH
45671: LD_VAR 0 1
45675: NOT
45676: OR
45677: PUSH
45678: LD_VAR 0 2
45682: NOT
45683: OR
45684: IFFALSE 45688
// exit ;
45686: GO 45713
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45688: LD_ADDR_EXP 111
45692: PUSH
45693: LD_EXP 111
45697: PPUSH
45698: LD_VAR 0 1
45702: PPUSH
45703: LD_VAR 0 2
45707: PPUSH
45708: CALL_OW 1
45712: ST_TO_ADDR
// end ;
45713: LD_VAR 0 3
45717: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45718: LD_INT 0
45720: PPUSH
// if not mc_bases or not base or not teleports_exit then
45721: LD_EXP 93
45725: NOT
45726: PUSH
45727: LD_VAR 0 1
45731: NOT
45732: OR
45733: PUSH
45734: LD_VAR 0 2
45738: NOT
45739: OR
45740: IFFALSE 45744
// exit ;
45742: GO 45769
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45744: LD_ADDR_EXP 128
45748: PUSH
45749: LD_EXP 128
45753: PPUSH
45754: LD_VAR 0 1
45758: PPUSH
45759: LD_VAR 0 2
45763: PPUSH
45764: CALL_OW 1
45768: ST_TO_ADDR
// end ;
45769: LD_VAR 0 3
45773: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45774: LD_INT 0
45776: PPUSH
45777: PPUSH
45778: PPUSH
// if not mc_bases or not base or not ext_list then
45779: LD_EXP 93
45783: NOT
45784: PUSH
45785: LD_VAR 0 1
45789: NOT
45790: OR
45791: PUSH
45792: LD_VAR 0 5
45796: NOT
45797: OR
45798: IFFALSE 45802
// exit ;
45800: GO 45975
// tmp := GetFacExtXYD ( x , y , d ) ;
45802: LD_ADDR_VAR 0 8
45806: PUSH
45807: LD_VAR 0 2
45811: PPUSH
45812: LD_VAR 0 3
45816: PPUSH
45817: LD_VAR 0 4
45821: PPUSH
45822: CALL 85654 0 3
45826: ST_TO_ADDR
// if not tmp then
45827: LD_VAR 0 8
45831: NOT
45832: IFFALSE 45836
// exit ;
45834: GO 45975
// for i in tmp do
45836: LD_ADDR_VAR 0 7
45840: PUSH
45841: LD_VAR 0 8
45845: PUSH
45846: FOR_IN
45847: IFFALSE 45973
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45849: LD_ADDR_EXP 98
45853: PUSH
45854: LD_EXP 98
45858: PPUSH
45859: LD_VAR 0 1
45863: PPUSH
45864: LD_EXP 98
45868: PUSH
45869: LD_VAR 0 1
45873: ARRAY
45874: PPUSH
45875: LD_EXP 98
45879: PUSH
45880: LD_VAR 0 1
45884: ARRAY
45885: PUSH
45886: LD_INT 1
45888: PLUS
45889: PPUSH
45890: LD_VAR 0 5
45894: PUSH
45895: LD_INT 1
45897: ARRAY
45898: PUSH
45899: LD_VAR 0 7
45903: PUSH
45904: LD_INT 1
45906: ARRAY
45907: PUSH
45908: LD_VAR 0 7
45912: PUSH
45913: LD_INT 2
45915: ARRAY
45916: PUSH
45917: LD_VAR 0 7
45921: PUSH
45922: LD_INT 3
45924: ARRAY
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: LIST
45930: LIST
45931: PPUSH
45932: CALL_OW 2
45936: PPUSH
45937: CALL_OW 1
45941: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45942: LD_ADDR_VAR 0 5
45946: PUSH
45947: LD_VAR 0 5
45951: PPUSH
45952: LD_INT 1
45954: PPUSH
45955: CALL_OW 3
45959: ST_TO_ADDR
// if not ext_list then
45960: LD_VAR 0 5
45964: NOT
45965: IFFALSE 45971
// exit ;
45967: POP
45968: POP
45969: GO 45975
// end ;
45971: GO 45846
45973: POP
45974: POP
// end ;
45975: LD_VAR 0 6
45979: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45980: LD_INT 0
45982: PPUSH
// if not mc_bases or not base or not weapon_list then
45983: LD_EXP 93
45987: NOT
45988: PUSH
45989: LD_VAR 0 1
45993: NOT
45994: OR
45995: PUSH
45996: LD_VAR 0 2
46000: NOT
46001: OR
46002: IFFALSE 46006
// exit ;
46004: GO 46031
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46006: LD_ADDR_EXP 132
46010: PUSH
46011: LD_EXP 132
46015: PPUSH
46016: LD_VAR 0 1
46020: PPUSH
46021: LD_VAR 0 2
46025: PPUSH
46026: CALL_OW 1
46030: ST_TO_ADDR
// end ;
46031: LD_VAR 0 3
46035: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46036: LD_INT 0
46038: PPUSH
// if not mc_bases or not base or not tech_list then
46039: LD_EXP 93
46043: NOT
46044: PUSH
46045: LD_VAR 0 1
46049: NOT
46050: OR
46051: PUSH
46052: LD_VAR 0 2
46056: NOT
46057: OR
46058: IFFALSE 46062
// exit ;
46060: GO 46087
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46062: LD_ADDR_EXP 120
46066: PUSH
46067: LD_EXP 120
46071: PPUSH
46072: LD_VAR 0 1
46076: PPUSH
46077: LD_VAR 0 2
46081: PPUSH
46082: CALL_OW 1
46086: ST_TO_ADDR
// end ;
46087: LD_VAR 0 3
46091: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46092: LD_INT 0
46094: PPUSH
// if not mc_bases or not parking_area or not base then
46095: LD_EXP 93
46099: NOT
46100: PUSH
46101: LD_VAR 0 2
46105: NOT
46106: OR
46107: PUSH
46108: LD_VAR 0 1
46112: NOT
46113: OR
46114: IFFALSE 46118
// exit ;
46116: GO 46143
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46118: LD_ADDR_EXP 117
46122: PUSH
46123: LD_EXP 117
46127: PPUSH
46128: LD_VAR 0 1
46132: PPUSH
46133: LD_VAR 0 2
46137: PPUSH
46138: CALL_OW 1
46142: ST_TO_ADDR
// end ;
46143: LD_VAR 0 3
46147: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46148: LD_INT 0
46150: PPUSH
// if not mc_bases or not base or not scan_area then
46151: LD_EXP 93
46155: NOT
46156: PUSH
46157: LD_VAR 0 1
46161: NOT
46162: OR
46163: PUSH
46164: LD_VAR 0 2
46168: NOT
46169: OR
46170: IFFALSE 46174
// exit ;
46172: GO 46199
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46174: LD_ADDR_EXP 118
46178: PUSH
46179: LD_EXP 118
46183: PPUSH
46184: LD_VAR 0 1
46188: PPUSH
46189: LD_VAR 0 2
46193: PPUSH
46194: CALL_OW 1
46198: ST_TO_ADDR
// end ;
46199: LD_VAR 0 3
46203: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46204: LD_INT 0
46206: PPUSH
46207: PPUSH
// if not mc_bases or not base then
46208: LD_EXP 93
46212: NOT
46213: PUSH
46214: LD_VAR 0 1
46218: NOT
46219: OR
46220: IFFALSE 46224
// exit ;
46222: GO 46288
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46224: LD_ADDR_VAR 0 3
46228: PUSH
46229: LD_INT 1
46231: PUSH
46232: LD_INT 2
46234: PUSH
46235: LD_INT 3
46237: PUSH
46238: LD_INT 4
46240: PUSH
46241: LD_INT 11
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46251: LD_ADDR_EXP 120
46255: PUSH
46256: LD_EXP 120
46260: PPUSH
46261: LD_VAR 0 1
46265: PPUSH
46266: LD_EXP 120
46270: PUSH
46271: LD_VAR 0 1
46275: ARRAY
46276: PUSH
46277: LD_VAR 0 3
46281: DIFF
46282: PPUSH
46283: CALL_OW 1
46287: ST_TO_ADDR
// end ;
46288: LD_VAR 0 2
46292: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46293: LD_INT 0
46295: PPUSH
// result := mc_vehicles [ base ] ;
46296: LD_ADDR_VAR 0 3
46300: PUSH
46301: LD_EXP 112
46305: PUSH
46306: LD_VAR 0 1
46310: ARRAY
46311: ST_TO_ADDR
// if onlyCombat then
46312: LD_VAR 0 2
46316: IFFALSE 46494
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46318: LD_ADDR_VAR 0 3
46322: PUSH
46323: LD_VAR 0 3
46327: PUSH
46328: LD_VAR 0 3
46332: PPUSH
46333: LD_INT 2
46335: PUSH
46336: LD_INT 34
46338: PUSH
46339: LD_INT 12
46341: PUSH
46342: EMPTY
46343: LIST
46344: LIST
46345: PUSH
46346: LD_INT 34
46348: PUSH
46349: LD_INT 51
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: PUSH
46356: LD_INT 34
46358: PUSH
46359: LD_EXP 73
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 34
46370: PUSH
46371: LD_INT 32
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 34
46380: PUSH
46381: LD_INT 13
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PUSH
46388: LD_INT 34
46390: PUSH
46391: LD_INT 52
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: PUSH
46398: LD_INT 34
46400: PUSH
46401: LD_EXP 78
46405: PUSH
46406: EMPTY
46407: LIST
46408: LIST
46409: PUSH
46410: LD_INT 34
46412: PUSH
46413: LD_INT 14
46415: PUSH
46416: EMPTY
46417: LIST
46418: LIST
46419: PUSH
46420: LD_INT 34
46422: PUSH
46423: LD_INT 53
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 34
46432: PUSH
46433: LD_EXP 72
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: PUSH
46442: LD_INT 34
46444: PUSH
46445: LD_INT 31
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: PUSH
46452: LD_INT 34
46454: PUSH
46455: LD_INT 48
46457: PUSH
46458: EMPTY
46459: LIST
46460: LIST
46461: PUSH
46462: LD_INT 34
46464: PUSH
46465: LD_INT 8
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: LIST
46476: LIST
46477: LIST
46478: LIST
46479: LIST
46480: LIST
46481: LIST
46482: LIST
46483: LIST
46484: LIST
46485: LIST
46486: LIST
46487: PPUSH
46488: CALL_OW 72
46492: DIFF
46493: ST_TO_ADDR
// end ; end_of_file
46494: LD_VAR 0 3
46498: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
46499: LD_INT 0
46501: PPUSH
46502: PPUSH
46503: PPUSH
// if not mc_bases or not skirmish then
46504: LD_EXP 93
46508: NOT
46509: PUSH
46510: LD_EXP 91
46514: NOT
46515: OR
46516: IFFALSE 46520
// exit ;
46518: GO 46685
// for i = 1 to mc_bases do
46520: LD_ADDR_VAR 0 4
46524: PUSH
46525: DOUBLE
46526: LD_INT 1
46528: DEC
46529: ST_TO_ADDR
46530: LD_EXP 93
46534: PUSH
46535: FOR_TO
46536: IFFALSE 46683
// begin if sci in mc_bases [ i ] then
46538: LD_VAR 0 2
46542: PUSH
46543: LD_EXP 93
46547: PUSH
46548: LD_VAR 0 4
46552: ARRAY
46553: IN
46554: IFFALSE 46681
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
46556: LD_ADDR_EXP 122
46560: PUSH
46561: LD_EXP 122
46565: PPUSH
46566: LD_VAR 0 4
46570: PUSH
46571: LD_EXP 122
46575: PUSH
46576: LD_VAR 0 4
46580: ARRAY
46581: PUSH
46582: LD_INT 1
46584: PLUS
46585: PUSH
46586: EMPTY
46587: LIST
46588: LIST
46589: PPUSH
46590: LD_VAR 0 1
46594: PPUSH
46595: CALL 56267 0 3
46599: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
46600: LD_ADDR_VAR 0 5
46604: PUSH
46605: LD_EXP 93
46609: PUSH
46610: LD_VAR 0 4
46614: ARRAY
46615: PPUSH
46616: LD_INT 2
46618: PUSH
46619: LD_INT 30
46621: PUSH
46622: LD_INT 0
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: PUSH
46629: LD_INT 30
46631: PUSH
46632: LD_INT 1
46634: PUSH
46635: EMPTY
46636: LIST
46637: LIST
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: LIST
46643: PPUSH
46644: CALL_OW 72
46648: PPUSH
46649: LD_VAR 0 1
46653: PPUSH
46654: CALL_OW 74
46658: ST_TO_ADDR
// if tmp then
46659: LD_VAR 0 5
46663: IFFALSE 46679
// ComStandNearbyBuilding ( ape , tmp ) ;
46665: LD_VAR 0 1
46669: PPUSH
46670: LD_VAR 0 5
46674: PPUSH
46675: CALL 52845 0 2
// break ;
46679: GO 46683
// end ; end ;
46681: GO 46535
46683: POP
46684: POP
// end ;
46685: LD_VAR 0 3
46689: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46690: LD_INT 0
46692: PPUSH
46693: PPUSH
46694: PPUSH
// if not mc_bases or not skirmish then
46695: LD_EXP 93
46699: NOT
46700: PUSH
46701: LD_EXP 91
46705: NOT
46706: OR
46707: IFFALSE 46711
// exit ;
46709: GO 46800
// for i = 1 to mc_bases do
46711: LD_ADDR_VAR 0 4
46715: PUSH
46716: DOUBLE
46717: LD_INT 1
46719: DEC
46720: ST_TO_ADDR
46721: LD_EXP 93
46725: PUSH
46726: FOR_TO
46727: IFFALSE 46798
// begin if building in mc_busy_turret_list [ i ] then
46729: LD_VAR 0 1
46733: PUSH
46734: LD_EXP 103
46738: PUSH
46739: LD_VAR 0 4
46743: ARRAY
46744: IN
46745: IFFALSE 46796
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46747: LD_ADDR_VAR 0 5
46751: PUSH
46752: LD_EXP 103
46756: PUSH
46757: LD_VAR 0 4
46761: ARRAY
46762: PUSH
46763: LD_VAR 0 1
46767: DIFF
46768: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46769: LD_ADDR_EXP 103
46773: PUSH
46774: LD_EXP 103
46778: PPUSH
46779: LD_VAR 0 4
46783: PPUSH
46784: LD_VAR 0 5
46788: PPUSH
46789: CALL_OW 1
46793: ST_TO_ADDR
// break ;
46794: GO 46798
// end ; end ;
46796: GO 46726
46798: POP
46799: POP
// end ;
46800: LD_VAR 0 3
46804: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46805: LD_INT 0
46807: PPUSH
46808: PPUSH
46809: PPUSH
// if not mc_bases or not skirmish then
46810: LD_EXP 93
46814: NOT
46815: PUSH
46816: LD_EXP 91
46820: NOT
46821: OR
46822: IFFALSE 46826
// exit ;
46824: GO 47025
// for i = 1 to mc_bases do
46826: LD_ADDR_VAR 0 5
46830: PUSH
46831: DOUBLE
46832: LD_INT 1
46834: DEC
46835: ST_TO_ADDR
46836: LD_EXP 93
46840: PUSH
46841: FOR_TO
46842: IFFALSE 47023
// if building in mc_bases [ i ] then
46844: LD_VAR 0 1
46848: PUSH
46849: LD_EXP 93
46853: PUSH
46854: LD_VAR 0 5
46858: ARRAY
46859: IN
46860: IFFALSE 47021
// begin tmp := mc_bases [ i ] diff building ;
46862: LD_ADDR_VAR 0 6
46866: PUSH
46867: LD_EXP 93
46871: PUSH
46872: LD_VAR 0 5
46876: ARRAY
46877: PUSH
46878: LD_VAR 0 1
46882: DIFF
46883: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46884: LD_ADDR_EXP 93
46888: PUSH
46889: LD_EXP 93
46893: PPUSH
46894: LD_VAR 0 5
46898: PPUSH
46899: LD_VAR 0 6
46903: PPUSH
46904: CALL_OW 1
46908: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46909: LD_VAR 0 1
46913: PUSH
46914: LD_EXP 101
46918: PUSH
46919: LD_VAR 0 5
46923: ARRAY
46924: IN
46925: IFFALSE 46964
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46927: LD_ADDR_EXP 101
46931: PUSH
46932: LD_EXP 101
46936: PPUSH
46937: LD_VAR 0 5
46941: PPUSH
46942: LD_EXP 101
46946: PUSH
46947: LD_VAR 0 5
46951: ARRAY
46952: PUSH
46953: LD_VAR 0 1
46957: DIFF
46958: PPUSH
46959: CALL_OW 1
46963: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46964: LD_VAR 0 1
46968: PUSH
46969: LD_EXP 102
46973: PUSH
46974: LD_VAR 0 5
46978: ARRAY
46979: IN
46980: IFFALSE 47019
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46982: LD_ADDR_EXP 102
46986: PUSH
46987: LD_EXP 102
46991: PPUSH
46992: LD_VAR 0 5
46996: PPUSH
46997: LD_EXP 102
47001: PUSH
47002: LD_VAR 0 5
47006: ARRAY
47007: PUSH
47008: LD_VAR 0 1
47012: DIFF
47013: PPUSH
47014: CALL_OW 1
47018: ST_TO_ADDR
// break ;
47019: GO 47023
// end ;
47021: GO 46841
47023: POP
47024: POP
// end ;
47025: LD_VAR 0 4
47029: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47030: LD_INT 0
47032: PPUSH
47033: PPUSH
47034: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47035: LD_EXP 93
47039: NOT
47040: PUSH
47041: LD_EXP 91
47045: NOT
47046: OR
47047: PUSH
47048: LD_VAR 0 3
47052: PUSH
47053: LD_EXP 119
47057: IN
47058: NOT
47059: OR
47060: IFFALSE 47064
// exit ;
47062: GO 47187
// for i = 1 to mc_vehicles do
47064: LD_ADDR_VAR 0 6
47068: PUSH
47069: DOUBLE
47070: LD_INT 1
47072: DEC
47073: ST_TO_ADDR
47074: LD_EXP 112
47078: PUSH
47079: FOR_TO
47080: IFFALSE 47185
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47082: LD_VAR 0 2
47086: PUSH
47087: LD_EXP 112
47091: PUSH
47092: LD_VAR 0 6
47096: ARRAY
47097: IN
47098: PUSH
47099: LD_VAR 0 1
47103: PUSH
47104: LD_EXP 112
47108: PUSH
47109: LD_VAR 0 6
47113: ARRAY
47114: IN
47115: OR
47116: IFFALSE 47183
// begin tmp := mc_vehicles [ i ] diff old ;
47118: LD_ADDR_VAR 0 7
47122: PUSH
47123: LD_EXP 112
47127: PUSH
47128: LD_VAR 0 6
47132: ARRAY
47133: PUSH
47134: LD_VAR 0 2
47138: DIFF
47139: ST_TO_ADDR
// tmp := tmp diff new ;
47140: LD_ADDR_VAR 0 7
47144: PUSH
47145: LD_VAR 0 7
47149: PUSH
47150: LD_VAR 0 1
47154: DIFF
47155: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47156: LD_ADDR_EXP 112
47160: PUSH
47161: LD_EXP 112
47165: PPUSH
47166: LD_VAR 0 6
47170: PPUSH
47171: LD_VAR 0 7
47175: PPUSH
47176: CALL_OW 1
47180: ST_TO_ADDR
// break ;
47181: GO 47185
// end ;
47183: GO 47079
47185: POP
47186: POP
// end ;
47187: LD_VAR 0 5
47191: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47192: LD_INT 0
47194: PPUSH
47195: PPUSH
47196: PPUSH
47197: PPUSH
// if not mc_bases or not skirmish then
47198: LD_EXP 93
47202: NOT
47203: PUSH
47204: LD_EXP 91
47208: NOT
47209: OR
47210: IFFALSE 47214
// exit ;
47212: GO 47606
// side := GetSide ( vehicle ) ;
47214: LD_ADDR_VAR 0 5
47218: PUSH
47219: LD_VAR 0 1
47223: PPUSH
47224: CALL_OW 255
47228: ST_TO_ADDR
// for i = 1 to mc_bases do
47229: LD_ADDR_VAR 0 4
47233: PUSH
47234: DOUBLE
47235: LD_INT 1
47237: DEC
47238: ST_TO_ADDR
47239: LD_EXP 93
47243: PUSH
47244: FOR_TO
47245: IFFALSE 47604
// begin if factory in mc_bases [ i ] then
47247: LD_VAR 0 2
47251: PUSH
47252: LD_EXP 93
47256: PUSH
47257: LD_VAR 0 4
47261: ARRAY
47262: IN
47263: IFFALSE 47602
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47265: LD_EXP 115
47269: PUSH
47270: LD_VAR 0 4
47274: ARRAY
47275: PUSH
47276: LD_EXP 104
47280: PUSH
47281: LD_VAR 0 4
47285: ARRAY
47286: LESS
47287: PUSH
47288: LD_VAR 0 1
47292: PPUSH
47293: CALL_OW 264
47297: PUSH
47298: LD_INT 31
47300: PUSH
47301: LD_INT 32
47303: PUSH
47304: LD_INT 51
47306: PUSH
47307: LD_EXP 73
47311: PUSH
47312: LD_INT 12
47314: PUSH
47315: LD_INT 30
47317: PUSH
47318: LD_EXP 72
47322: PUSH
47323: LD_INT 11
47325: PUSH
47326: LD_INT 53
47328: PUSH
47329: LD_INT 14
47331: PUSH
47332: LD_EXP 76
47336: PUSH
47337: LD_INT 29
47339: PUSH
47340: LD_EXP 74
47344: PUSH
47345: LD_INT 13
47347: PUSH
47348: LD_INT 52
47350: PUSH
47351: LD_EXP 78
47355: PUSH
47356: LD_INT 48
47358: PUSH
47359: LD_INT 8
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: LIST
47366: LIST
47367: LIST
47368: LIST
47369: LIST
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: IN
47382: NOT
47383: AND
47384: IFFALSE 47432
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
47386: LD_ADDR_EXP 115
47390: PUSH
47391: LD_EXP 115
47395: PPUSH
47396: LD_VAR 0 4
47400: PUSH
47401: LD_EXP 115
47405: PUSH
47406: LD_VAR 0 4
47410: ARRAY
47411: PUSH
47412: LD_INT 1
47414: PLUS
47415: PUSH
47416: EMPTY
47417: LIST
47418: LIST
47419: PPUSH
47420: LD_VAR 0 1
47424: PPUSH
47425: CALL 56267 0 3
47429: ST_TO_ADDR
47430: GO 47476
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
47432: LD_ADDR_EXP 112
47436: PUSH
47437: LD_EXP 112
47441: PPUSH
47442: LD_VAR 0 4
47446: PUSH
47447: LD_EXP 112
47451: PUSH
47452: LD_VAR 0 4
47456: ARRAY
47457: PUSH
47458: LD_INT 1
47460: PLUS
47461: PUSH
47462: EMPTY
47463: LIST
47464: LIST
47465: PPUSH
47466: LD_VAR 0 1
47470: PPUSH
47471: CALL 56267 0 3
47475: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
47476: LD_VAR 0 1
47480: PPUSH
47481: CALL_OW 263
47485: PUSH
47486: LD_INT 2
47488: EQUAL
47489: IFFALSE 47518
// begin repeat wait ( 0 0$3 ) ;
47491: LD_INT 105
47493: PPUSH
47494: CALL_OW 67
// Connect ( vehicle ) ;
47498: LD_VAR 0 1
47502: PPUSH
47503: CALL 59238 0 1
// until IsControledBy ( vehicle ) ;
47507: LD_VAR 0 1
47511: PPUSH
47512: CALL_OW 312
47516: IFFALSE 47491
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
47518: LD_VAR 0 1
47522: PPUSH
47523: LD_EXP 117
47527: PUSH
47528: LD_VAR 0 4
47532: ARRAY
47533: PPUSH
47534: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
47538: LD_VAR 0 1
47542: PPUSH
47543: CALL_OW 263
47547: PUSH
47548: LD_INT 1
47550: NONEQUAL
47551: IFFALSE 47555
// break ;
47553: GO 47604
// repeat wait ( 0 0$1 ) ;
47555: LD_INT 35
47557: PPUSH
47558: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
47562: LD_VAR 0 1
47566: PPUSH
47567: LD_EXP 117
47571: PUSH
47572: LD_VAR 0 4
47576: ARRAY
47577: PPUSH
47578: CALL_OW 308
47582: IFFALSE 47555
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
47584: LD_VAR 0 1
47588: PPUSH
47589: CALL_OW 311
47593: PPUSH
47594: CALL_OW 121
// exit ;
47598: POP
47599: POP
47600: GO 47606
// end ; end ;
47602: GO 47244
47604: POP
47605: POP
// end ;
47606: LD_VAR 0 3
47610: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
47611: LD_INT 0
47613: PPUSH
47614: PPUSH
47615: PPUSH
47616: PPUSH
// if not mc_bases or not skirmish then
47617: LD_EXP 93
47621: NOT
47622: PUSH
47623: LD_EXP 91
47627: NOT
47628: OR
47629: IFFALSE 47633
// exit ;
47631: GO 47986
// repeat wait ( 0 0$1 ) ;
47633: LD_INT 35
47635: PPUSH
47636: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
47640: LD_VAR 0 2
47644: PPUSH
47645: LD_VAR 0 3
47649: PPUSH
47650: CALL_OW 284
47654: IFFALSE 47633
// if GetResourceTypeXY ( x , y ) = mat_artefact then
47656: LD_VAR 0 2
47660: PPUSH
47661: LD_VAR 0 3
47665: PPUSH
47666: CALL_OW 283
47670: PUSH
47671: LD_INT 4
47673: EQUAL
47674: IFFALSE 47678
// exit ;
47676: GO 47986
// for i = 1 to mc_bases do
47678: LD_ADDR_VAR 0 7
47682: PUSH
47683: DOUBLE
47684: LD_INT 1
47686: DEC
47687: ST_TO_ADDR
47688: LD_EXP 93
47692: PUSH
47693: FOR_TO
47694: IFFALSE 47984
// begin if mc_crates_area [ i ] then
47696: LD_EXP 111
47700: PUSH
47701: LD_VAR 0 7
47705: ARRAY
47706: IFFALSE 47817
// for j in mc_crates_area [ i ] do
47708: LD_ADDR_VAR 0 8
47712: PUSH
47713: LD_EXP 111
47717: PUSH
47718: LD_VAR 0 7
47722: ARRAY
47723: PUSH
47724: FOR_IN
47725: IFFALSE 47815
// if InArea ( x , y , j ) then
47727: LD_VAR 0 2
47731: PPUSH
47732: LD_VAR 0 3
47736: PPUSH
47737: LD_VAR 0 8
47741: PPUSH
47742: CALL_OW 309
47746: IFFALSE 47813
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47748: LD_ADDR_EXP 109
47752: PUSH
47753: LD_EXP 109
47757: PPUSH
47758: LD_VAR 0 7
47762: PUSH
47763: LD_EXP 109
47767: PUSH
47768: LD_VAR 0 7
47772: ARRAY
47773: PUSH
47774: LD_INT 1
47776: PLUS
47777: PUSH
47778: EMPTY
47779: LIST
47780: LIST
47781: PPUSH
47782: LD_VAR 0 4
47786: PUSH
47787: LD_VAR 0 2
47791: PUSH
47792: LD_VAR 0 3
47796: PUSH
47797: EMPTY
47798: LIST
47799: LIST
47800: LIST
47801: PPUSH
47802: CALL 56267 0 3
47806: ST_TO_ADDR
// exit ;
47807: POP
47808: POP
47809: POP
47810: POP
47811: GO 47986
// end ;
47813: GO 47724
47815: POP
47816: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47817: LD_ADDR_VAR 0 9
47821: PUSH
47822: LD_EXP 93
47826: PUSH
47827: LD_VAR 0 7
47831: ARRAY
47832: PPUSH
47833: LD_INT 2
47835: PUSH
47836: LD_INT 30
47838: PUSH
47839: LD_INT 0
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: PUSH
47846: LD_INT 30
47848: PUSH
47849: LD_INT 1
47851: PUSH
47852: EMPTY
47853: LIST
47854: LIST
47855: PUSH
47856: EMPTY
47857: LIST
47858: LIST
47859: LIST
47860: PPUSH
47861: CALL_OW 72
47865: ST_TO_ADDR
// if not depot then
47866: LD_VAR 0 9
47870: NOT
47871: IFFALSE 47875
// continue ;
47873: GO 47693
// for j in depot do
47875: LD_ADDR_VAR 0 8
47879: PUSH
47880: LD_VAR 0 9
47884: PUSH
47885: FOR_IN
47886: IFFALSE 47980
// if GetDistUnitXY ( j , x , y ) < 30 then
47888: LD_VAR 0 8
47892: PPUSH
47893: LD_VAR 0 2
47897: PPUSH
47898: LD_VAR 0 3
47902: PPUSH
47903: CALL_OW 297
47907: PUSH
47908: LD_INT 30
47910: LESS
47911: IFFALSE 47978
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47913: LD_ADDR_EXP 109
47917: PUSH
47918: LD_EXP 109
47922: PPUSH
47923: LD_VAR 0 7
47927: PUSH
47928: LD_EXP 109
47932: PUSH
47933: LD_VAR 0 7
47937: ARRAY
47938: PUSH
47939: LD_INT 1
47941: PLUS
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PPUSH
47947: LD_VAR 0 4
47951: PUSH
47952: LD_VAR 0 2
47956: PUSH
47957: LD_VAR 0 3
47961: PUSH
47962: EMPTY
47963: LIST
47964: LIST
47965: LIST
47966: PPUSH
47967: CALL 56267 0 3
47971: ST_TO_ADDR
// exit ;
47972: POP
47973: POP
47974: POP
47975: POP
47976: GO 47986
// end ;
47978: GO 47885
47980: POP
47981: POP
// end ;
47982: GO 47693
47984: POP
47985: POP
// end ;
47986: LD_VAR 0 6
47990: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47991: LD_INT 0
47993: PPUSH
47994: PPUSH
47995: PPUSH
47996: PPUSH
// if not mc_bases or not skirmish then
47997: LD_EXP 93
48001: NOT
48002: PUSH
48003: LD_EXP 91
48007: NOT
48008: OR
48009: IFFALSE 48013
// exit ;
48011: GO 48290
// side := GetSide ( lab ) ;
48013: LD_ADDR_VAR 0 4
48017: PUSH
48018: LD_VAR 0 2
48022: PPUSH
48023: CALL_OW 255
48027: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48028: LD_VAR 0 4
48032: PUSH
48033: LD_EXP 119
48037: IN
48038: NOT
48039: PUSH
48040: LD_EXP 120
48044: NOT
48045: OR
48046: PUSH
48047: LD_EXP 93
48051: NOT
48052: OR
48053: IFFALSE 48057
// exit ;
48055: GO 48290
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48057: LD_ADDR_EXP 120
48061: PUSH
48062: LD_EXP 120
48066: PPUSH
48067: LD_VAR 0 4
48071: PPUSH
48072: LD_EXP 120
48076: PUSH
48077: LD_VAR 0 4
48081: ARRAY
48082: PUSH
48083: LD_VAR 0 1
48087: DIFF
48088: PPUSH
48089: CALL_OW 1
48093: ST_TO_ADDR
// for i = 1 to mc_bases do
48094: LD_ADDR_VAR 0 5
48098: PUSH
48099: DOUBLE
48100: LD_INT 1
48102: DEC
48103: ST_TO_ADDR
48104: LD_EXP 93
48108: PUSH
48109: FOR_TO
48110: IFFALSE 48288
// begin if lab in mc_bases [ i ] then
48112: LD_VAR 0 2
48116: PUSH
48117: LD_EXP 93
48121: PUSH
48122: LD_VAR 0 5
48126: ARRAY
48127: IN
48128: IFFALSE 48286
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48130: LD_VAR 0 1
48134: PUSH
48135: LD_INT 11
48137: PUSH
48138: LD_INT 4
48140: PUSH
48141: LD_INT 3
48143: PUSH
48144: LD_INT 2
48146: PUSH
48147: EMPTY
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: IN
48153: PUSH
48154: LD_EXP 123
48158: PUSH
48159: LD_VAR 0 5
48163: ARRAY
48164: AND
48165: IFFALSE 48286
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48167: LD_ADDR_VAR 0 6
48171: PUSH
48172: LD_EXP 123
48176: PUSH
48177: LD_VAR 0 5
48181: ARRAY
48182: PUSH
48183: LD_INT 1
48185: ARRAY
48186: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48187: LD_ADDR_EXP 123
48191: PUSH
48192: LD_EXP 123
48196: PPUSH
48197: LD_VAR 0 5
48201: PPUSH
48202: EMPTY
48203: PPUSH
48204: CALL_OW 1
48208: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48209: LD_VAR 0 6
48213: PPUSH
48214: LD_INT 0
48216: PPUSH
48217: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48221: LD_VAR 0 6
48225: PPUSH
48226: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48230: LD_ADDR_EXP 122
48234: PUSH
48235: LD_EXP 122
48239: PPUSH
48240: LD_VAR 0 5
48244: PPUSH
48245: LD_EXP 122
48249: PUSH
48250: LD_VAR 0 5
48254: ARRAY
48255: PPUSH
48256: LD_INT 1
48258: PPUSH
48259: LD_VAR 0 6
48263: PPUSH
48264: CALL_OW 2
48268: PPUSH
48269: CALL_OW 1
48273: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48274: LD_VAR 0 5
48278: PPUSH
48279: LD_INT 112
48281: PPUSH
48282: CALL 24956 0 2
// end ; end ; end ;
48286: GO 48109
48288: POP
48289: POP
// end ;
48290: LD_VAR 0 3
48294: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48295: LD_INT 0
48297: PPUSH
48298: PPUSH
48299: PPUSH
48300: PPUSH
48301: PPUSH
48302: PPUSH
48303: PPUSH
48304: PPUSH
// if not mc_bases or not skirmish then
48305: LD_EXP 93
48309: NOT
48310: PUSH
48311: LD_EXP 91
48315: NOT
48316: OR
48317: IFFALSE 48321
// exit ;
48319: GO 49692
// for i = 1 to mc_bases do
48321: LD_ADDR_VAR 0 3
48325: PUSH
48326: DOUBLE
48327: LD_INT 1
48329: DEC
48330: ST_TO_ADDR
48331: LD_EXP 93
48335: PUSH
48336: FOR_TO
48337: IFFALSE 49690
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48339: LD_VAR 0 1
48343: PUSH
48344: LD_EXP 93
48348: PUSH
48349: LD_VAR 0 3
48353: ARRAY
48354: IN
48355: PUSH
48356: LD_VAR 0 1
48360: PUSH
48361: LD_EXP 100
48365: PUSH
48366: LD_VAR 0 3
48370: ARRAY
48371: IN
48372: OR
48373: PUSH
48374: LD_VAR 0 1
48378: PUSH
48379: LD_EXP 115
48383: PUSH
48384: LD_VAR 0 3
48388: ARRAY
48389: IN
48390: OR
48391: PUSH
48392: LD_VAR 0 1
48396: PUSH
48397: LD_EXP 112
48401: PUSH
48402: LD_VAR 0 3
48406: ARRAY
48407: IN
48408: OR
48409: PUSH
48410: LD_VAR 0 1
48414: PUSH
48415: LD_EXP 122
48419: PUSH
48420: LD_VAR 0 3
48424: ARRAY
48425: IN
48426: OR
48427: PUSH
48428: LD_VAR 0 1
48432: PUSH
48433: LD_EXP 123
48437: PUSH
48438: LD_VAR 0 3
48442: ARRAY
48443: IN
48444: OR
48445: IFFALSE 49688
// begin if un in mc_ape [ i ] then
48447: LD_VAR 0 1
48451: PUSH
48452: LD_EXP 122
48456: PUSH
48457: LD_VAR 0 3
48461: ARRAY
48462: IN
48463: IFFALSE 48502
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
48465: LD_ADDR_EXP 122
48469: PUSH
48470: LD_EXP 122
48474: PPUSH
48475: LD_VAR 0 3
48479: PPUSH
48480: LD_EXP 122
48484: PUSH
48485: LD_VAR 0 3
48489: ARRAY
48490: PUSH
48491: LD_VAR 0 1
48495: DIFF
48496: PPUSH
48497: CALL_OW 1
48501: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
48502: LD_VAR 0 1
48506: PUSH
48507: LD_EXP 123
48511: PUSH
48512: LD_VAR 0 3
48516: ARRAY
48517: IN
48518: IFFALSE 48542
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48520: LD_ADDR_EXP 123
48524: PUSH
48525: LD_EXP 123
48529: PPUSH
48530: LD_VAR 0 3
48534: PPUSH
48535: EMPTY
48536: PPUSH
48537: CALL_OW 1
48541: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
48542: LD_VAR 0 1
48546: PPUSH
48547: CALL_OW 247
48551: PUSH
48552: LD_INT 2
48554: EQUAL
48555: PUSH
48556: LD_VAR 0 1
48560: PPUSH
48561: CALL_OW 110
48565: PUSH
48566: LD_INT 20
48568: EQUAL
48569: PUSH
48570: LD_VAR 0 1
48574: PUSH
48575: LD_EXP 115
48579: PUSH
48580: LD_VAR 0 3
48584: ARRAY
48585: IN
48586: OR
48587: PUSH
48588: LD_VAR 0 1
48592: PPUSH
48593: CALL_OW 264
48597: PUSH
48598: LD_INT 12
48600: PUSH
48601: LD_INT 51
48603: PUSH
48604: LD_EXP 73
48608: PUSH
48609: LD_INT 32
48611: PUSH
48612: LD_INT 13
48614: PUSH
48615: LD_INT 52
48617: PUSH
48618: LD_INT 31
48620: PUSH
48621: EMPTY
48622: LIST
48623: LIST
48624: LIST
48625: LIST
48626: LIST
48627: LIST
48628: LIST
48629: IN
48630: OR
48631: AND
48632: IFFALSE 48940
// begin if un in mc_defender [ i ] then
48634: LD_VAR 0 1
48638: PUSH
48639: LD_EXP 115
48643: PUSH
48644: LD_VAR 0 3
48648: ARRAY
48649: IN
48650: IFFALSE 48689
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48652: LD_ADDR_EXP 115
48656: PUSH
48657: LD_EXP 115
48661: PPUSH
48662: LD_VAR 0 3
48666: PPUSH
48667: LD_EXP 115
48671: PUSH
48672: LD_VAR 0 3
48676: ARRAY
48677: PUSH
48678: LD_VAR 0 1
48682: DIFF
48683: PPUSH
48684: CALL_OW 1
48688: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
48689: LD_ADDR_VAR 0 8
48693: PUSH
48694: LD_VAR 0 3
48698: PPUSH
48699: LD_INT 3
48701: PPUSH
48702: CALL 45330 0 2
48706: ST_TO_ADDR
// if fac then
48707: LD_VAR 0 8
48711: IFFALSE 48940
// begin for j in fac do
48713: LD_ADDR_VAR 0 4
48717: PUSH
48718: LD_VAR 0 8
48722: PUSH
48723: FOR_IN
48724: IFFALSE 48938
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48726: LD_ADDR_VAR 0 9
48730: PUSH
48731: LD_VAR 0 8
48735: PPUSH
48736: LD_VAR 0 1
48740: PPUSH
48741: CALL_OW 265
48745: PPUSH
48746: LD_VAR 0 1
48750: PPUSH
48751: CALL_OW 262
48755: PPUSH
48756: LD_VAR 0 1
48760: PPUSH
48761: CALL_OW 263
48765: PPUSH
48766: LD_VAR 0 1
48770: PPUSH
48771: CALL_OW 264
48775: PPUSH
48776: CALL 53763 0 5
48780: ST_TO_ADDR
// if components then
48781: LD_VAR 0 9
48785: IFFALSE 48936
// begin if GetWeapon ( un ) = ar_control_tower then
48787: LD_VAR 0 1
48791: PPUSH
48792: CALL_OW 264
48796: PUSH
48797: LD_INT 31
48799: EQUAL
48800: IFFALSE 48917
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48802: LD_VAR 0 1
48806: PPUSH
48807: CALL_OW 311
48811: PPUSH
48812: LD_INT 0
48814: PPUSH
48815: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48819: LD_ADDR_EXP 133
48823: PUSH
48824: LD_EXP 133
48828: PPUSH
48829: LD_VAR 0 3
48833: PPUSH
48834: LD_EXP 133
48838: PUSH
48839: LD_VAR 0 3
48843: ARRAY
48844: PUSH
48845: LD_VAR 0 1
48849: PPUSH
48850: CALL_OW 311
48854: DIFF
48855: PPUSH
48856: CALL_OW 1
48860: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48861: LD_ADDR_VAR 0 7
48865: PUSH
48866: LD_EXP 114
48870: PUSH
48871: LD_VAR 0 3
48875: ARRAY
48876: PPUSH
48877: LD_INT 1
48879: PPUSH
48880: LD_VAR 0 9
48884: PPUSH
48885: CALL_OW 2
48889: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48890: LD_ADDR_EXP 114
48894: PUSH
48895: LD_EXP 114
48899: PPUSH
48900: LD_VAR 0 3
48904: PPUSH
48905: LD_VAR 0 7
48909: PPUSH
48910: CALL_OW 1
48914: ST_TO_ADDR
// end else
48915: GO 48934
// MC_InsertProduceList ( i , [ components ] ) ;
48917: LD_VAR 0 3
48921: PPUSH
48922: LD_VAR 0 9
48926: PUSH
48927: EMPTY
48928: LIST
48929: PPUSH
48930: CALL 44875 0 2
// break ;
48934: GO 48938
// end ; end ;
48936: GO 48723
48938: POP
48939: POP
// end ; end ; if GetType ( un ) = unit_building then
48940: LD_VAR 0 1
48944: PPUSH
48945: CALL_OW 247
48949: PUSH
48950: LD_INT 3
48952: EQUAL
48953: IFFALSE 49356
// begin btype := GetBType ( un ) ;
48955: LD_ADDR_VAR 0 5
48959: PUSH
48960: LD_VAR 0 1
48964: PPUSH
48965: CALL_OW 266
48969: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48970: LD_VAR 0 5
48974: PUSH
48975: LD_INT 29
48977: PUSH
48978: LD_INT 30
48980: PUSH
48981: EMPTY
48982: LIST
48983: LIST
48984: IN
48985: IFFALSE 49058
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48987: LD_VAR 0 1
48991: PPUSH
48992: CALL_OW 250
48996: PPUSH
48997: LD_VAR 0 1
49001: PPUSH
49002: CALL_OW 251
49006: PPUSH
49007: LD_VAR 0 1
49011: PPUSH
49012: CALL_OW 255
49016: PPUSH
49017: CALL_OW 440
49021: NOT
49022: IFFALSE 49058
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49024: LD_VAR 0 1
49028: PPUSH
49029: CALL_OW 250
49033: PPUSH
49034: LD_VAR 0 1
49038: PPUSH
49039: CALL_OW 251
49043: PPUSH
49044: LD_VAR 0 1
49048: PPUSH
49049: CALL_OW 255
49053: PPUSH
49054: CALL_OW 441
// end ; if btype = b_warehouse then
49058: LD_VAR 0 5
49062: PUSH
49063: LD_INT 1
49065: EQUAL
49066: IFFALSE 49084
// begin btype := b_depot ;
49068: LD_ADDR_VAR 0 5
49072: PUSH
49073: LD_INT 0
49075: ST_TO_ADDR
// pos := 1 ;
49076: LD_ADDR_VAR 0 6
49080: PUSH
49081: LD_INT 1
49083: ST_TO_ADDR
// end ; if btype = b_factory then
49084: LD_VAR 0 5
49088: PUSH
49089: LD_INT 3
49091: EQUAL
49092: IFFALSE 49110
// begin btype := b_workshop ;
49094: LD_ADDR_VAR 0 5
49098: PUSH
49099: LD_INT 2
49101: ST_TO_ADDR
// pos := 1 ;
49102: LD_ADDR_VAR 0 6
49106: PUSH
49107: LD_INT 1
49109: ST_TO_ADDR
// end ; if btype = b_barracks then
49110: LD_VAR 0 5
49114: PUSH
49115: LD_INT 5
49117: EQUAL
49118: IFFALSE 49128
// btype := b_armoury ;
49120: LD_ADDR_VAR 0 5
49124: PUSH
49125: LD_INT 4
49127: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49128: LD_VAR 0 5
49132: PUSH
49133: LD_INT 7
49135: PUSH
49136: LD_INT 8
49138: PUSH
49139: EMPTY
49140: LIST
49141: LIST
49142: IN
49143: IFFALSE 49153
// btype := b_lab ;
49145: LD_ADDR_VAR 0 5
49149: PUSH
49150: LD_INT 6
49152: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49153: LD_ADDR_EXP 98
49157: PUSH
49158: LD_EXP 98
49162: PPUSH
49163: LD_VAR 0 3
49167: PUSH
49168: LD_EXP 98
49172: PUSH
49173: LD_VAR 0 3
49177: ARRAY
49178: PUSH
49179: LD_INT 1
49181: PLUS
49182: PUSH
49183: EMPTY
49184: LIST
49185: LIST
49186: PPUSH
49187: LD_VAR 0 5
49191: PUSH
49192: LD_VAR 0 1
49196: PPUSH
49197: CALL_OW 250
49201: PUSH
49202: LD_VAR 0 1
49206: PPUSH
49207: CALL_OW 251
49211: PUSH
49212: LD_VAR 0 1
49216: PPUSH
49217: CALL_OW 254
49221: PUSH
49222: EMPTY
49223: LIST
49224: LIST
49225: LIST
49226: LIST
49227: PPUSH
49228: CALL 56267 0 3
49232: ST_TO_ADDR
// if pos = 1 then
49233: LD_VAR 0 6
49237: PUSH
49238: LD_INT 1
49240: EQUAL
49241: IFFALSE 49356
// begin tmp := mc_build_list [ i ] ;
49243: LD_ADDR_VAR 0 7
49247: PUSH
49248: LD_EXP 98
49252: PUSH
49253: LD_VAR 0 3
49257: ARRAY
49258: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49259: LD_VAR 0 7
49263: PPUSH
49264: LD_INT 2
49266: PUSH
49267: LD_INT 30
49269: PUSH
49270: LD_INT 0
49272: PUSH
49273: EMPTY
49274: LIST
49275: LIST
49276: PUSH
49277: LD_INT 30
49279: PUSH
49280: LD_INT 1
49282: PUSH
49283: EMPTY
49284: LIST
49285: LIST
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: LIST
49291: PPUSH
49292: CALL_OW 72
49296: IFFALSE 49306
// pos := 2 ;
49298: LD_ADDR_VAR 0 6
49302: PUSH
49303: LD_INT 2
49305: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49306: LD_ADDR_VAR 0 7
49310: PUSH
49311: LD_VAR 0 7
49315: PPUSH
49316: LD_VAR 0 6
49320: PPUSH
49321: LD_VAR 0 7
49325: PPUSH
49326: CALL 56593 0 3
49330: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49331: LD_ADDR_EXP 98
49335: PUSH
49336: LD_EXP 98
49340: PPUSH
49341: LD_VAR 0 3
49345: PPUSH
49346: LD_VAR 0 7
49350: PPUSH
49351: CALL_OW 1
49355: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49356: LD_VAR 0 1
49360: PUSH
49361: LD_EXP 93
49365: PUSH
49366: LD_VAR 0 3
49370: ARRAY
49371: IN
49372: IFFALSE 49411
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
49374: LD_ADDR_EXP 93
49378: PUSH
49379: LD_EXP 93
49383: PPUSH
49384: LD_VAR 0 3
49388: PPUSH
49389: LD_EXP 93
49393: PUSH
49394: LD_VAR 0 3
49398: ARRAY
49399: PUSH
49400: LD_VAR 0 1
49404: DIFF
49405: PPUSH
49406: CALL_OW 1
49410: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
49411: LD_VAR 0 1
49415: PUSH
49416: LD_EXP 100
49420: PUSH
49421: LD_VAR 0 3
49425: ARRAY
49426: IN
49427: IFFALSE 49466
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
49429: LD_ADDR_EXP 100
49433: PUSH
49434: LD_EXP 100
49438: PPUSH
49439: LD_VAR 0 3
49443: PPUSH
49444: LD_EXP 100
49448: PUSH
49449: LD_VAR 0 3
49453: ARRAY
49454: PUSH
49455: LD_VAR 0 1
49459: DIFF
49460: PPUSH
49461: CALL_OW 1
49465: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
49466: LD_VAR 0 1
49470: PUSH
49471: LD_EXP 112
49475: PUSH
49476: LD_VAR 0 3
49480: ARRAY
49481: IN
49482: IFFALSE 49521
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
49484: LD_ADDR_EXP 112
49488: PUSH
49489: LD_EXP 112
49493: PPUSH
49494: LD_VAR 0 3
49498: PPUSH
49499: LD_EXP 112
49503: PUSH
49504: LD_VAR 0 3
49508: ARRAY
49509: PUSH
49510: LD_VAR 0 1
49514: DIFF
49515: PPUSH
49516: CALL_OW 1
49520: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
49521: LD_VAR 0 1
49525: PUSH
49526: LD_EXP 115
49530: PUSH
49531: LD_VAR 0 3
49535: ARRAY
49536: IN
49537: IFFALSE 49576
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49539: LD_ADDR_EXP 115
49543: PUSH
49544: LD_EXP 115
49548: PPUSH
49549: LD_VAR 0 3
49553: PPUSH
49554: LD_EXP 115
49558: PUSH
49559: LD_VAR 0 3
49563: ARRAY
49564: PUSH
49565: LD_VAR 0 1
49569: DIFF
49570: PPUSH
49571: CALL_OW 1
49575: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
49576: LD_VAR 0 1
49580: PUSH
49581: LD_EXP 102
49585: PUSH
49586: LD_VAR 0 3
49590: ARRAY
49591: IN
49592: IFFALSE 49631
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
49594: LD_ADDR_EXP 102
49598: PUSH
49599: LD_EXP 102
49603: PPUSH
49604: LD_VAR 0 3
49608: PPUSH
49609: LD_EXP 102
49613: PUSH
49614: LD_VAR 0 3
49618: ARRAY
49619: PUSH
49620: LD_VAR 0 1
49624: DIFF
49625: PPUSH
49626: CALL_OW 1
49630: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
49631: LD_VAR 0 1
49635: PUSH
49636: LD_EXP 101
49640: PUSH
49641: LD_VAR 0 3
49645: ARRAY
49646: IN
49647: IFFALSE 49686
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
49649: LD_ADDR_EXP 101
49653: PUSH
49654: LD_EXP 101
49658: PPUSH
49659: LD_VAR 0 3
49663: PPUSH
49664: LD_EXP 101
49668: PUSH
49669: LD_VAR 0 3
49673: ARRAY
49674: PUSH
49675: LD_VAR 0 1
49679: DIFF
49680: PPUSH
49681: CALL_OW 1
49685: ST_TO_ADDR
// end ; break ;
49686: GO 49690
// end ;
49688: GO 48336
49690: POP
49691: POP
// end ;
49692: LD_VAR 0 2
49696: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
49697: LD_INT 0
49699: PPUSH
49700: PPUSH
49701: PPUSH
// if not mc_bases or not skirmish then
49702: LD_EXP 93
49706: NOT
49707: PUSH
49708: LD_EXP 91
49712: NOT
49713: OR
49714: IFFALSE 49718
// exit ;
49716: GO 49933
// for i = 1 to mc_bases do
49718: LD_ADDR_VAR 0 3
49722: PUSH
49723: DOUBLE
49724: LD_INT 1
49726: DEC
49727: ST_TO_ADDR
49728: LD_EXP 93
49732: PUSH
49733: FOR_TO
49734: IFFALSE 49931
// begin if building in mc_construct_list [ i ] then
49736: LD_VAR 0 1
49740: PUSH
49741: LD_EXP 100
49745: PUSH
49746: LD_VAR 0 3
49750: ARRAY
49751: IN
49752: IFFALSE 49929
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49754: LD_ADDR_EXP 100
49758: PUSH
49759: LD_EXP 100
49763: PPUSH
49764: LD_VAR 0 3
49768: PPUSH
49769: LD_EXP 100
49773: PUSH
49774: LD_VAR 0 3
49778: ARRAY
49779: PUSH
49780: LD_VAR 0 1
49784: DIFF
49785: PPUSH
49786: CALL_OW 1
49790: ST_TO_ADDR
// if building in mc_lab [ i ] then
49791: LD_VAR 0 1
49795: PUSH
49796: LD_EXP 126
49800: PUSH
49801: LD_VAR 0 3
49805: ARRAY
49806: IN
49807: IFFALSE 49862
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49809: LD_ADDR_EXP 127
49813: PUSH
49814: LD_EXP 127
49818: PPUSH
49819: LD_VAR 0 3
49823: PPUSH
49824: LD_EXP 127
49828: PUSH
49829: LD_VAR 0 3
49833: ARRAY
49834: PPUSH
49835: LD_INT 1
49837: PPUSH
49838: LD_EXP 127
49842: PUSH
49843: LD_VAR 0 3
49847: ARRAY
49848: PPUSH
49849: LD_INT 0
49851: PPUSH
49852: CALL 55685 0 4
49856: PPUSH
49857: CALL_OW 1
49861: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49862: LD_VAR 0 1
49866: PUSH
49867: LD_EXP 93
49871: PUSH
49872: LD_VAR 0 3
49876: ARRAY
49877: IN
49878: NOT
49879: IFFALSE 49925
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49881: LD_ADDR_EXP 93
49885: PUSH
49886: LD_EXP 93
49890: PPUSH
49891: LD_VAR 0 3
49895: PUSH
49896: LD_EXP 93
49900: PUSH
49901: LD_VAR 0 3
49905: ARRAY
49906: PUSH
49907: LD_INT 1
49909: PLUS
49910: PUSH
49911: EMPTY
49912: LIST
49913: LIST
49914: PPUSH
49915: LD_VAR 0 1
49919: PPUSH
49920: CALL 56267 0 3
49924: ST_TO_ADDR
// exit ;
49925: POP
49926: POP
49927: GO 49933
// end ; end ;
49929: GO 49733
49931: POP
49932: POP
// end ;
49933: LD_VAR 0 2
49937: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49938: LD_INT 0
49940: PPUSH
49941: PPUSH
49942: PPUSH
49943: PPUSH
49944: PPUSH
49945: PPUSH
49946: PPUSH
// if not mc_bases or not skirmish then
49947: LD_EXP 93
49951: NOT
49952: PUSH
49953: LD_EXP 91
49957: NOT
49958: OR
49959: IFFALSE 49963
// exit ;
49961: GO 50624
// for i = 1 to mc_bases do
49963: LD_ADDR_VAR 0 3
49967: PUSH
49968: DOUBLE
49969: LD_INT 1
49971: DEC
49972: ST_TO_ADDR
49973: LD_EXP 93
49977: PUSH
49978: FOR_TO
49979: IFFALSE 50622
// begin if building in mc_construct_list [ i ] then
49981: LD_VAR 0 1
49985: PUSH
49986: LD_EXP 100
49990: PUSH
49991: LD_VAR 0 3
49995: ARRAY
49996: IN
49997: IFFALSE 50620
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49999: LD_ADDR_EXP 100
50003: PUSH
50004: LD_EXP 100
50008: PPUSH
50009: LD_VAR 0 3
50013: PPUSH
50014: LD_EXP 100
50018: PUSH
50019: LD_VAR 0 3
50023: ARRAY
50024: PUSH
50025: LD_VAR 0 1
50029: DIFF
50030: PPUSH
50031: CALL_OW 1
50035: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50036: LD_ADDR_EXP 93
50040: PUSH
50041: LD_EXP 93
50045: PPUSH
50046: LD_VAR 0 3
50050: PUSH
50051: LD_EXP 93
50055: PUSH
50056: LD_VAR 0 3
50060: ARRAY
50061: PUSH
50062: LD_INT 1
50064: PLUS
50065: PUSH
50066: EMPTY
50067: LIST
50068: LIST
50069: PPUSH
50070: LD_VAR 0 1
50074: PPUSH
50075: CALL 56267 0 3
50079: ST_TO_ADDR
// btype := GetBType ( building ) ;
50080: LD_ADDR_VAR 0 5
50084: PUSH
50085: LD_VAR 0 1
50089: PPUSH
50090: CALL_OW 266
50094: ST_TO_ADDR
// side := GetSide ( building ) ;
50095: LD_ADDR_VAR 0 8
50099: PUSH
50100: LD_VAR 0 1
50104: PPUSH
50105: CALL_OW 255
50109: ST_TO_ADDR
// if btype = b_lab then
50110: LD_VAR 0 5
50114: PUSH
50115: LD_INT 6
50117: EQUAL
50118: IFFALSE 50168
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50120: LD_ADDR_EXP 126
50124: PUSH
50125: LD_EXP 126
50129: PPUSH
50130: LD_VAR 0 3
50134: PUSH
50135: LD_EXP 126
50139: PUSH
50140: LD_VAR 0 3
50144: ARRAY
50145: PUSH
50146: LD_INT 1
50148: PLUS
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PPUSH
50154: LD_VAR 0 1
50158: PPUSH
50159: CALL 56267 0 3
50163: ST_TO_ADDR
// exit ;
50164: POP
50165: POP
50166: GO 50624
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50168: LD_VAR 0 5
50172: PUSH
50173: LD_INT 0
50175: PUSH
50176: LD_INT 2
50178: PUSH
50179: LD_INT 4
50181: PUSH
50182: EMPTY
50183: LIST
50184: LIST
50185: LIST
50186: IN
50187: IFFALSE 50311
// begin if btype = b_armoury then
50189: LD_VAR 0 5
50193: PUSH
50194: LD_INT 4
50196: EQUAL
50197: IFFALSE 50207
// btype := b_barracks ;
50199: LD_ADDR_VAR 0 5
50203: PUSH
50204: LD_INT 5
50206: ST_TO_ADDR
// if btype = b_depot then
50207: LD_VAR 0 5
50211: PUSH
50212: LD_INT 0
50214: EQUAL
50215: IFFALSE 50225
// btype := b_warehouse ;
50217: LD_ADDR_VAR 0 5
50221: PUSH
50222: LD_INT 1
50224: ST_TO_ADDR
// if btype = b_workshop then
50225: LD_VAR 0 5
50229: PUSH
50230: LD_INT 2
50232: EQUAL
50233: IFFALSE 50243
// btype := b_factory ;
50235: LD_ADDR_VAR 0 5
50239: PUSH
50240: LD_INT 3
50242: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50243: LD_VAR 0 5
50247: PPUSH
50248: LD_VAR 0 8
50252: PPUSH
50253: CALL_OW 323
50257: PUSH
50258: LD_INT 1
50260: EQUAL
50261: IFFALSE 50307
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50263: LD_ADDR_EXP 125
50267: PUSH
50268: LD_EXP 125
50272: PPUSH
50273: LD_VAR 0 3
50277: PUSH
50278: LD_EXP 125
50282: PUSH
50283: LD_VAR 0 3
50287: ARRAY
50288: PUSH
50289: LD_INT 1
50291: PLUS
50292: PUSH
50293: EMPTY
50294: LIST
50295: LIST
50296: PPUSH
50297: LD_VAR 0 1
50301: PPUSH
50302: CALL 56267 0 3
50306: ST_TO_ADDR
// exit ;
50307: POP
50308: POP
50309: GO 50624
// end ; if btype in [ b_bunker , b_turret ] then
50311: LD_VAR 0 5
50315: PUSH
50316: LD_INT 32
50318: PUSH
50319: LD_INT 33
50321: PUSH
50322: EMPTY
50323: LIST
50324: LIST
50325: IN
50326: IFFALSE 50616
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50328: LD_ADDR_EXP 101
50332: PUSH
50333: LD_EXP 101
50337: PPUSH
50338: LD_VAR 0 3
50342: PUSH
50343: LD_EXP 101
50347: PUSH
50348: LD_VAR 0 3
50352: ARRAY
50353: PUSH
50354: LD_INT 1
50356: PLUS
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PPUSH
50362: LD_VAR 0 1
50366: PPUSH
50367: CALL 56267 0 3
50371: ST_TO_ADDR
// if btype = b_bunker then
50372: LD_VAR 0 5
50376: PUSH
50377: LD_INT 32
50379: EQUAL
50380: IFFALSE 50616
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50382: LD_ADDR_EXP 102
50386: PUSH
50387: LD_EXP 102
50391: PPUSH
50392: LD_VAR 0 3
50396: PUSH
50397: LD_EXP 102
50401: PUSH
50402: LD_VAR 0 3
50406: ARRAY
50407: PUSH
50408: LD_INT 1
50410: PLUS
50411: PUSH
50412: EMPTY
50413: LIST
50414: LIST
50415: PPUSH
50416: LD_VAR 0 1
50420: PPUSH
50421: CALL 56267 0 3
50425: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
50426: LD_ADDR_VAR 0 6
50430: PUSH
50431: LD_EXP 93
50435: PUSH
50436: LD_VAR 0 3
50440: ARRAY
50441: PPUSH
50442: LD_INT 25
50444: PUSH
50445: LD_INT 1
50447: PUSH
50448: EMPTY
50449: LIST
50450: LIST
50451: PUSH
50452: LD_INT 3
50454: PUSH
50455: LD_INT 54
50457: PUSH
50458: EMPTY
50459: LIST
50460: PUSH
50461: EMPTY
50462: LIST
50463: LIST
50464: PUSH
50465: EMPTY
50466: LIST
50467: LIST
50468: PPUSH
50469: CALL_OW 72
50473: ST_TO_ADDR
// if tmp then
50474: LD_VAR 0 6
50478: IFFALSE 50484
// exit ;
50480: POP
50481: POP
50482: GO 50624
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
50484: LD_ADDR_VAR 0 6
50488: PUSH
50489: LD_EXP 93
50493: PUSH
50494: LD_VAR 0 3
50498: ARRAY
50499: PPUSH
50500: LD_INT 2
50502: PUSH
50503: LD_INT 30
50505: PUSH
50506: LD_INT 4
50508: PUSH
50509: EMPTY
50510: LIST
50511: LIST
50512: PUSH
50513: LD_INT 30
50515: PUSH
50516: LD_INT 5
50518: PUSH
50519: EMPTY
50520: LIST
50521: LIST
50522: PUSH
50523: EMPTY
50524: LIST
50525: LIST
50526: LIST
50527: PPUSH
50528: CALL_OW 72
50532: ST_TO_ADDR
// if not tmp then
50533: LD_VAR 0 6
50537: NOT
50538: IFFALSE 50544
// exit ;
50540: POP
50541: POP
50542: GO 50624
// for j in tmp do
50544: LD_ADDR_VAR 0 4
50548: PUSH
50549: LD_VAR 0 6
50553: PUSH
50554: FOR_IN
50555: IFFALSE 50614
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
50557: LD_ADDR_VAR 0 7
50561: PUSH
50562: LD_VAR 0 4
50566: PPUSH
50567: CALL_OW 313
50571: PPUSH
50572: LD_INT 25
50574: PUSH
50575: LD_INT 1
50577: PUSH
50578: EMPTY
50579: LIST
50580: LIST
50581: PPUSH
50582: CALL_OW 72
50586: ST_TO_ADDR
// if units then
50587: LD_VAR 0 7
50591: IFFALSE 50612
// begin ComExitBuilding ( units [ 1 ] ) ;
50593: LD_VAR 0 7
50597: PUSH
50598: LD_INT 1
50600: ARRAY
50601: PPUSH
50602: CALL_OW 122
// exit ;
50606: POP
50607: POP
50608: POP
50609: POP
50610: GO 50624
// end ; end ;
50612: GO 50554
50614: POP
50615: POP
// end ; end ; exit ;
50616: POP
50617: POP
50618: GO 50624
// end ; end ;
50620: GO 49978
50622: POP
50623: POP
// end ;
50624: LD_VAR 0 2
50628: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
50629: LD_INT 0
50631: PPUSH
50632: PPUSH
50633: PPUSH
50634: PPUSH
50635: PPUSH
50636: PPUSH
50637: PPUSH
// if not mc_bases or not skirmish then
50638: LD_EXP 93
50642: NOT
50643: PUSH
50644: LD_EXP 91
50648: NOT
50649: OR
50650: IFFALSE 50654
// exit ;
50652: GO 50919
// btype := GetBType ( building ) ;
50654: LD_ADDR_VAR 0 6
50658: PUSH
50659: LD_VAR 0 1
50663: PPUSH
50664: CALL_OW 266
50668: ST_TO_ADDR
// x := GetX ( building ) ;
50669: LD_ADDR_VAR 0 7
50673: PUSH
50674: LD_VAR 0 1
50678: PPUSH
50679: CALL_OW 250
50683: ST_TO_ADDR
// y := GetY ( building ) ;
50684: LD_ADDR_VAR 0 8
50688: PUSH
50689: LD_VAR 0 1
50693: PPUSH
50694: CALL_OW 251
50698: ST_TO_ADDR
// d := GetDir ( building ) ;
50699: LD_ADDR_VAR 0 9
50703: PUSH
50704: LD_VAR 0 1
50708: PPUSH
50709: CALL_OW 254
50713: ST_TO_ADDR
// for i = 1 to mc_bases do
50714: LD_ADDR_VAR 0 4
50718: PUSH
50719: DOUBLE
50720: LD_INT 1
50722: DEC
50723: ST_TO_ADDR
50724: LD_EXP 93
50728: PUSH
50729: FOR_TO
50730: IFFALSE 50917
// begin if not mc_build_list [ i ] then
50732: LD_EXP 98
50736: PUSH
50737: LD_VAR 0 4
50741: ARRAY
50742: NOT
50743: IFFALSE 50747
// continue ;
50745: GO 50729
// for j := 1 to mc_build_list [ i ] do
50747: LD_ADDR_VAR 0 5
50751: PUSH
50752: DOUBLE
50753: LD_INT 1
50755: DEC
50756: ST_TO_ADDR
50757: LD_EXP 98
50761: PUSH
50762: LD_VAR 0 4
50766: ARRAY
50767: PUSH
50768: FOR_TO
50769: IFFALSE 50913
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
50771: LD_VAR 0 6
50775: PUSH
50776: LD_VAR 0 7
50780: PUSH
50781: LD_VAR 0 8
50785: PUSH
50786: LD_VAR 0 9
50790: PUSH
50791: EMPTY
50792: LIST
50793: LIST
50794: LIST
50795: LIST
50796: PPUSH
50797: LD_EXP 98
50801: PUSH
50802: LD_VAR 0 4
50806: ARRAY
50807: PUSH
50808: LD_VAR 0 5
50812: ARRAY
50813: PPUSH
50814: CALL 62449 0 2
50818: IFFALSE 50911
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
50820: LD_ADDR_EXP 98
50824: PUSH
50825: LD_EXP 98
50829: PPUSH
50830: LD_VAR 0 4
50834: PPUSH
50835: LD_EXP 98
50839: PUSH
50840: LD_VAR 0 4
50844: ARRAY
50845: PPUSH
50846: LD_VAR 0 5
50850: PPUSH
50851: CALL_OW 3
50855: PPUSH
50856: CALL_OW 1
50860: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50861: LD_ADDR_EXP 100
50865: PUSH
50866: LD_EXP 100
50870: PPUSH
50871: LD_VAR 0 4
50875: PUSH
50876: LD_EXP 100
50880: PUSH
50881: LD_VAR 0 4
50885: ARRAY
50886: PUSH
50887: LD_INT 1
50889: PLUS
50890: PUSH
50891: EMPTY
50892: LIST
50893: LIST
50894: PPUSH
50895: LD_VAR 0 1
50899: PPUSH
50900: CALL 56267 0 3
50904: ST_TO_ADDR
// exit ;
50905: POP
50906: POP
50907: POP
50908: POP
50909: GO 50919
// end ;
50911: GO 50768
50913: POP
50914: POP
// end ;
50915: GO 50729
50917: POP
50918: POP
// end ;
50919: LD_VAR 0 3
50923: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50924: LD_INT 0
50926: PPUSH
50927: PPUSH
50928: PPUSH
// if not mc_bases or not skirmish then
50929: LD_EXP 93
50933: NOT
50934: PUSH
50935: LD_EXP 91
50939: NOT
50940: OR
50941: IFFALSE 50945
// exit ;
50943: GO 51135
// for i = 1 to mc_bases do
50945: LD_ADDR_VAR 0 4
50949: PUSH
50950: DOUBLE
50951: LD_INT 1
50953: DEC
50954: ST_TO_ADDR
50955: LD_EXP 93
50959: PUSH
50960: FOR_TO
50961: IFFALSE 51048
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50963: LD_VAR 0 1
50967: PUSH
50968: LD_EXP 101
50972: PUSH
50973: LD_VAR 0 4
50977: ARRAY
50978: IN
50979: PUSH
50980: LD_VAR 0 1
50984: PUSH
50985: LD_EXP 102
50989: PUSH
50990: LD_VAR 0 4
50994: ARRAY
50995: IN
50996: NOT
50997: AND
50998: IFFALSE 51046
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51000: LD_ADDR_EXP 102
51004: PUSH
51005: LD_EXP 102
51009: PPUSH
51010: LD_VAR 0 4
51014: PUSH
51015: LD_EXP 102
51019: PUSH
51020: LD_VAR 0 4
51024: ARRAY
51025: PUSH
51026: LD_INT 1
51028: PLUS
51029: PUSH
51030: EMPTY
51031: LIST
51032: LIST
51033: PPUSH
51034: LD_VAR 0 1
51038: PPUSH
51039: CALL 56267 0 3
51043: ST_TO_ADDR
// break ;
51044: GO 51048
// end ; end ;
51046: GO 50960
51048: POP
51049: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51050: LD_VAR 0 1
51054: PPUSH
51055: CALL_OW 257
51059: PUSH
51060: LD_EXP 119
51064: IN
51065: PUSH
51066: LD_VAR 0 1
51070: PPUSH
51071: CALL_OW 266
51075: PUSH
51076: LD_INT 5
51078: EQUAL
51079: AND
51080: PUSH
51081: LD_VAR 0 2
51085: PPUSH
51086: CALL_OW 110
51090: PUSH
51091: LD_INT 18
51093: NONEQUAL
51094: AND
51095: IFFALSE 51135
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51097: LD_VAR 0 2
51101: PPUSH
51102: CALL_OW 257
51106: PUSH
51107: LD_INT 5
51109: PUSH
51110: LD_INT 8
51112: PUSH
51113: LD_INT 9
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: LIST
51120: IN
51121: IFFALSE 51135
// SetClass ( unit , 1 ) ;
51123: LD_VAR 0 2
51127: PPUSH
51128: LD_INT 1
51130: PPUSH
51131: CALL_OW 336
// end ;
51135: LD_VAR 0 3
51139: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51140: LD_INT 0
51142: PPUSH
51143: PPUSH
// if not mc_bases or not skirmish then
51144: LD_EXP 93
51148: NOT
51149: PUSH
51150: LD_EXP 91
51154: NOT
51155: OR
51156: IFFALSE 51160
// exit ;
51158: GO 51276
// if GetLives ( abandoned_vehicle ) > 250 then
51160: LD_VAR 0 2
51164: PPUSH
51165: CALL_OW 256
51169: PUSH
51170: LD_INT 250
51172: GREATER
51173: IFFALSE 51177
// exit ;
51175: GO 51276
// for i = 1 to mc_bases do
51177: LD_ADDR_VAR 0 6
51181: PUSH
51182: DOUBLE
51183: LD_INT 1
51185: DEC
51186: ST_TO_ADDR
51187: LD_EXP 93
51191: PUSH
51192: FOR_TO
51193: IFFALSE 51274
// begin if driver in mc_bases [ i ] then
51195: LD_VAR 0 1
51199: PUSH
51200: LD_EXP 93
51204: PUSH
51205: LD_VAR 0 6
51209: ARRAY
51210: IN
51211: IFFALSE 51272
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51213: LD_VAR 0 1
51217: PPUSH
51218: LD_EXP 93
51222: PUSH
51223: LD_VAR 0 6
51227: ARRAY
51228: PPUSH
51229: LD_INT 2
51231: PUSH
51232: LD_INT 30
51234: PUSH
51235: LD_INT 0
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: PUSH
51242: LD_INT 30
51244: PUSH
51245: LD_INT 1
51247: PUSH
51248: EMPTY
51249: LIST
51250: LIST
51251: PUSH
51252: EMPTY
51253: LIST
51254: LIST
51255: LIST
51256: PPUSH
51257: CALL_OW 72
51261: PUSH
51262: LD_INT 1
51264: ARRAY
51265: PPUSH
51266: CALL 88885 0 2
// break ;
51270: GO 51274
// end ; end ;
51272: GO 51192
51274: POP
51275: POP
// end ; end_of_file
51276: LD_VAR 0 5
51280: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51281: LD_INT 0
51283: PPUSH
51284: PPUSH
// if exist_mode then
51285: LD_VAR 0 2
51289: IFFALSE 51314
// unit := CreateCharacter ( prefix & ident ) else
51291: LD_ADDR_VAR 0 5
51295: PUSH
51296: LD_VAR 0 3
51300: PUSH
51301: LD_VAR 0 1
51305: STR
51306: PPUSH
51307: CALL_OW 34
51311: ST_TO_ADDR
51312: GO 51329
// unit := NewCharacter ( ident ) ;
51314: LD_ADDR_VAR 0 5
51318: PUSH
51319: LD_VAR 0 1
51323: PPUSH
51324: CALL_OW 25
51328: ST_TO_ADDR
// result := unit ;
51329: LD_ADDR_VAR 0 4
51333: PUSH
51334: LD_VAR 0 5
51338: ST_TO_ADDR
// end ;
51339: LD_VAR 0 4
51343: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51344: LD_INT 0
51346: PPUSH
51347: PPUSH
// if not side or not nation then
51348: LD_VAR 0 1
51352: NOT
51353: PUSH
51354: LD_VAR 0 2
51358: NOT
51359: OR
51360: IFFALSE 51364
// exit ;
51362: GO 52132
// case nation of nation_american :
51364: LD_VAR 0 2
51368: PUSH
51369: LD_INT 1
51371: DOUBLE
51372: EQUAL
51373: IFTRUE 51377
51375: GO 51591
51377: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
51378: LD_ADDR_VAR 0 4
51382: PUSH
51383: LD_INT 35
51385: PUSH
51386: LD_INT 45
51388: PUSH
51389: LD_INT 46
51391: PUSH
51392: LD_INT 47
51394: PUSH
51395: LD_INT 82
51397: PUSH
51398: LD_INT 83
51400: PUSH
51401: LD_INT 84
51403: PUSH
51404: LD_INT 85
51406: PUSH
51407: LD_INT 86
51409: PUSH
51410: LD_INT 1
51412: PUSH
51413: LD_INT 2
51415: PUSH
51416: LD_INT 6
51418: PUSH
51419: LD_INT 15
51421: PUSH
51422: LD_INT 16
51424: PUSH
51425: LD_INT 7
51427: PUSH
51428: LD_INT 12
51430: PUSH
51431: LD_INT 13
51433: PUSH
51434: LD_INT 10
51436: PUSH
51437: LD_INT 14
51439: PUSH
51440: LD_INT 20
51442: PUSH
51443: LD_INT 21
51445: PUSH
51446: LD_INT 22
51448: PUSH
51449: LD_INT 25
51451: PUSH
51452: LD_INT 32
51454: PUSH
51455: LD_INT 27
51457: PUSH
51458: LD_INT 36
51460: PUSH
51461: LD_INT 69
51463: PUSH
51464: LD_INT 39
51466: PUSH
51467: LD_INT 34
51469: PUSH
51470: LD_INT 40
51472: PUSH
51473: LD_INT 48
51475: PUSH
51476: LD_INT 49
51478: PUSH
51479: LD_INT 50
51481: PUSH
51482: LD_INT 51
51484: PUSH
51485: LD_INT 52
51487: PUSH
51488: LD_INT 53
51490: PUSH
51491: LD_INT 54
51493: PUSH
51494: LD_INT 55
51496: PUSH
51497: LD_INT 56
51499: PUSH
51500: LD_INT 57
51502: PUSH
51503: LD_INT 58
51505: PUSH
51506: LD_INT 59
51508: PUSH
51509: LD_INT 60
51511: PUSH
51512: LD_INT 61
51514: PUSH
51515: LD_INT 62
51517: PUSH
51518: LD_INT 80
51520: PUSH
51521: LD_INT 82
51523: PUSH
51524: LD_INT 83
51526: PUSH
51527: LD_INT 84
51529: PUSH
51530: LD_INT 85
51532: PUSH
51533: LD_INT 86
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: LIST
51542: LIST
51543: LIST
51544: LIST
51545: LIST
51546: LIST
51547: LIST
51548: LIST
51549: LIST
51550: LIST
51551: LIST
51552: LIST
51553: LIST
51554: LIST
51555: LIST
51556: LIST
51557: LIST
51558: LIST
51559: LIST
51560: LIST
51561: LIST
51562: LIST
51563: LIST
51564: LIST
51565: LIST
51566: LIST
51567: LIST
51568: LIST
51569: LIST
51570: LIST
51571: LIST
51572: LIST
51573: LIST
51574: LIST
51575: LIST
51576: LIST
51577: LIST
51578: LIST
51579: LIST
51580: LIST
51581: LIST
51582: LIST
51583: LIST
51584: LIST
51585: LIST
51586: LIST
51587: LIST
51588: ST_TO_ADDR
51589: GO 52056
51591: LD_INT 2
51593: DOUBLE
51594: EQUAL
51595: IFTRUE 51599
51597: GO 51825
51599: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
51600: LD_ADDR_VAR 0 4
51604: PUSH
51605: LD_INT 35
51607: PUSH
51608: LD_INT 45
51610: PUSH
51611: LD_INT 46
51613: PUSH
51614: LD_INT 47
51616: PUSH
51617: LD_INT 82
51619: PUSH
51620: LD_INT 83
51622: PUSH
51623: LD_INT 84
51625: PUSH
51626: LD_INT 85
51628: PUSH
51629: LD_INT 87
51631: PUSH
51632: LD_INT 70
51634: PUSH
51635: LD_INT 1
51637: PUSH
51638: LD_INT 11
51640: PUSH
51641: LD_INT 3
51643: PUSH
51644: LD_INT 4
51646: PUSH
51647: LD_INT 5
51649: PUSH
51650: LD_INT 6
51652: PUSH
51653: LD_INT 15
51655: PUSH
51656: LD_INT 18
51658: PUSH
51659: LD_INT 7
51661: PUSH
51662: LD_INT 17
51664: PUSH
51665: LD_INT 8
51667: PUSH
51668: LD_INT 20
51670: PUSH
51671: LD_INT 21
51673: PUSH
51674: LD_INT 22
51676: PUSH
51677: LD_INT 72
51679: PUSH
51680: LD_INT 26
51682: PUSH
51683: LD_INT 69
51685: PUSH
51686: LD_INT 39
51688: PUSH
51689: LD_INT 40
51691: PUSH
51692: LD_INT 41
51694: PUSH
51695: LD_INT 42
51697: PUSH
51698: LD_INT 43
51700: PUSH
51701: LD_INT 48
51703: PUSH
51704: LD_INT 49
51706: PUSH
51707: LD_INT 50
51709: PUSH
51710: LD_INT 51
51712: PUSH
51713: LD_INT 52
51715: PUSH
51716: LD_INT 53
51718: PUSH
51719: LD_INT 54
51721: PUSH
51722: LD_INT 55
51724: PUSH
51725: LD_INT 56
51727: PUSH
51728: LD_INT 60
51730: PUSH
51731: LD_INT 61
51733: PUSH
51734: LD_INT 62
51736: PUSH
51737: LD_INT 66
51739: PUSH
51740: LD_INT 67
51742: PUSH
51743: LD_INT 68
51745: PUSH
51746: LD_INT 81
51748: PUSH
51749: LD_INT 82
51751: PUSH
51752: LD_INT 83
51754: PUSH
51755: LD_INT 84
51757: PUSH
51758: LD_INT 85
51760: PUSH
51761: LD_INT 87
51763: PUSH
51764: LD_INT 88
51766: PUSH
51767: EMPTY
51768: LIST
51769: LIST
51770: LIST
51771: LIST
51772: LIST
51773: LIST
51774: LIST
51775: LIST
51776: LIST
51777: LIST
51778: LIST
51779: LIST
51780: LIST
51781: LIST
51782: LIST
51783: LIST
51784: LIST
51785: LIST
51786: LIST
51787: LIST
51788: LIST
51789: LIST
51790: LIST
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: LIST
51796: LIST
51797: LIST
51798: LIST
51799: LIST
51800: LIST
51801: LIST
51802: LIST
51803: LIST
51804: LIST
51805: LIST
51806: LIST
51807: LIST
51808: LIST
51809: LIST
51810: LIST
51811: LIST
51812: LIST
51813: LIST
51814: LIST
51815: LIST
51816: LIST
51817: LIST
51818: LIST
51819: LIST
51820: LIST
51821: LIST
51822: ST_TO_ADDR
51823: GO 52056
51825: LD_INT 3
51827: DOUBLE
51828: EQUAL
51829: IFTRUE 51833
51831: GO 52055
51833: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
51834: LD_ADDR_VAR 0 4
51838: PUSH
51839: LD_INT 46
51841: PUSH
51842: LD_INT 47
51844: PUSH
51845: LD_INT 1
51847: PUSH
51848: LD_INT 2
51850: PUSH
51851: LD_INT 82
51853: PUSH
51854: LD_INT 83
51856: PUSH
51857: LD_INT 84
51859: PUSH
51860: LD_INT 85
51862: PUSH
51863: LD_INT 86
51865: PUSH
51866: LD_INT 11
51868: PUSH
51869: LD_INT 9
51871: PUSH
51872: LD_INT 20
51874: PUSH
51875: LD_INT 19
51877: PUSH
51878: LD_INT 21
51880: PUSH
51881: LD_INT 24
51883: PUSH
51884: LD_INT 22
51886: PUSH
51887: LD_INT 25
51889: PUSH
51890: LD_INT 28
51892: PUSH
51893: LD_INT 29
51895: PUSH
51896: LD_INT 30
51898: PUSH
51899: LD_INT 31
51901: PUSH
51902: LD_INT 37
51904: PUSH
51905: LD_INT 38
51907: PUSH
51908: LD_INT 32
51910: PUSH
51911: LD_INT 27
51913: PUSH
51914: LD_INT 33
51916: PUSH
51917: LD_INT 69
51919: PUSH
51920: LD_INT 39
51922: PUSH
51923: LD_INT 34
51925: PUSH
51926: LD_INT 40
51928: PUSH
51929: LD_INT 71
51931: PUSH
51932: LD_INT 23
51934: PUSH
51935: LD_INT 44
51937: PUSH
51938: LD_INT 48
51940: PUSH
51941: LD_INT 49
51943: PUSH
51944: LD_INT 50
51946: PUSH
51947: LD_INT 51
51949: PUSH
51950: LD_INT 52
51952: PUSH
51953: LD_INT 53
51955: PUSH
51956: LD_INT 54
51958: PUSH
51959: LD_INT 55
51961: PUSH
51962: LD_INT 56
51964: PUSH
51965: LD_INT 57
51967: PUSH
51968: LD_INT 58
51970: PUSH
51971: LD_INT 59
51973: PUSH
51974: LD_INT 63
51976: PUSH
51977: LD_INT 64
51979: PUSH
51980: LD_INT 65
51982: PUSH
51983: LD_INT 82
51985: PUSH
51986: LD_INT 83
51988: PUSH
51989: LD_INT 84
51991: PUSH
51992: LD_INT 85
51994: PUSH
51995: LD_INT 86
51997: PUSH
51998: EMPTY
51999: LIST
52000: LIST
52001: LIST
52002: LIST
52003: LIST
52004: LIST
52005: LIST
52006: LIST
52007: LIST
52008: LIST
52009: LIST
52010: LIST
52011: LIST
52012: LIST
52013: LIST
52014: LIST
52015: LIST
52016: LIST
52017: LIST
52018: LIST
52019: LIST
52020: LIST
52021: LIST
52022: LIST
52023: LIST
52024: LIST
52025: LIST
52026: LIST
52027: LIST
52028: LIST
52029: LIST
52030: LIST
52031: LIST
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: LIST
52037: LIST
52038: LIST
52039: LIST
52040: LIST
52041: LIST
52042: LIST
52043: LIST
52044: LIST
52045: LIST
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: LIST
52051: LIST
52052: ST_TO_ADDR
52053: GO 52056
52055: POP
// if state > - 1 and state < 3 then
52056: LD_VAR 0 3
52060: PUSH
52061: LD_INT 1
52063: NEG
52064: GREATER
52065: PUSH
52066: LD_VAR 0 3
52070: PUSH
52071: LD_INT 3
52073: LESS
52074: AND
52075: IFFALSE 52132
// for i in result do
52077: LD_ADDR_VAR 0 5
52081: PUSH
52082: LD_VAR 0 4
52086: PUSH
52087: FOR_IN
52088: IFFALSE 52130
// if GetTech ( i , side ) <> state then
52090: LD_VAR 0 5
52094: PPUSH
52095: LD_VAR 0 1
52099: PPUSH
52100: CALL_OW 321
52104: PUSH
52105: LD_VAR 0 3
52109: NONEQUAL
52110: IFFALSE 52128
// result := result diff i ;
52112: LD_ADDR_VAR 0 4
52116: PUSH
52117: LD_VAR 0 4
52121: PUSH
52122: LD_VAR 0 5
52126: DIFF
52127: ST_TO_ADDR
52128: GO 52087
52130: POP
52131: POP
// end ;
52132: LD_VAR 0 4
52136: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52137: LD_INT 0
52139: PPUSH
52140: PPUSH
52141: PPUSH
// result := true ;
52142: LD_ADDR_VAR 0 3
52146: PUSH
52147: LD_INT 1
52149: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52150: LD_ADDR_VAR 0 5
52154: PUSH
52155: LD_VAR 0 2
52159: PPUSH
52160: CALL_OW 480
52164: ST_TO_ADDR
// if not tmp then
52165: LD_VAR 0 5
52169: NOT
52170: IFFALSE 52174
// exit ;
52172: GO 52223
// for i in tmp do
52174: LD_ADDR_VAR 0 4
52178: PUSH
52179: LD_VAR 0 5
52183: PUSH
52184: FOR_IN
52185: IFFALSE 52221
// if GetTech ( i , side ) <> state_researched then
52187: LD_VAR 0 4
52191: PPUSH
52192: LD_VAR 0 1
52196: PPUSH
52197: CALL_OW 321
52201: PUSH
52202: LD_INT 2
52204: NONEQUAL
52205: IFFALSE 52219
// begin result := false ;
52207: LD_ADDR_VAR 0 3
52211: PUSH
52212: LD_INT 0
52214: ST_TO_ADDR
// exit ;
52215: POP
52216: POP
52217: GO 52223
// end ;
52219: GO 52184
52221: POP
52222: POP
// end ;
52223: LD_VAR 0 3
52227: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52228: LD_INT 0
52230: PPUSH
52231: PPUSH
52232: PPUSH
52233: PPUSH
52234: PPUSH
52235: PPUSH
52236: PPUSH
52237: PPUSH
52238: PPUSH
52239: PPUSH
52240: PPUSH
52241: PPUSH
52242: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52243: LD_VAR 0 1
52247: NOT
52248: PUSH
52249: LD_VAR 0 1
52253: PPUSH
52254: CALL_OW 257
52258: PUSH
52259: LD_INT 9
52261: NONEQUAL
52262: OR
52263: IFFALSE 52267
// exit ;
52265: GO 52840
// side := GetSide ( unit ) ;
52267: LD_ADDR_VAR 0 9
52271: PUSH
52272: LD_VAR 0 1
52276: PPUSH
52277: CALL_OW 255
52281: ST_TO_ADDR
// tech_space := tech_spacanom ;
52282: LD_ADDR_VAR 0 12
52286: PUSH
52287: LD_INT 29
52289: ST_TO_ADDR
// tech_time := tech_taurad ;
52290: LD_ADDR_VAR 0 13
52294: PUSH
52295: LD_INT 28
52297: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52298: LD_ADDR_VAR 0 11
52302: PUSH
52303: LD_VAR 0 1
52307: PPUSH
52308: CALL_OW 310
52312: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52313: LD_VAR 0 11
52317: PPUSH
52318: CALL_OW 247
52322: PUSH
52323: LD_INT 2
52325: EQUAL
52326: IFFALSE 52330
// exit ;
52328: GO 52840
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52330: LD_ADDR_VAR 0 8
52334: PUSH
52335: LD_INT 81
52337: PUSH
52338: LD_VAR 0 9
52342: PUSH
52343: EMPTY
52344: LIST
52345: LIST
52346: PUSH
52347: LD_INT 3
52349: PUSH
52350: LD_INT 21
52352: PUSH
52353: LD_INT 3
52355: PUSH
52356: EMPTY
52357: LIST
52358: LIST
52359: PUSH
52360: EMPTY
52361: LIST
52362: LIST
52363: PUSH
52364: EMPTY
52365: LIST
52366: LIST
52367: PPUSH
52368: CALL_OW 69
52372: ST_TO_ADDR
// if not tmp then
52373: LD_VAR 0 8
52377: NOT
52378: IFFALSE 52382
// exit ;
52380: GO 52840
// if in_unit then
52382: LD_VAR 0 11
52386: IFFALSE 52410
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
52388: LD_ADDR_VAR 0 10
52392: PUSH
52393: LD_VAR 0 8
52397: PPUSH
52398: LD_VAR 0 11
52402: PPUSH
52403: CALL_OW 74
52407: ST_TO_ADDR
52408: GO 52430
// enemy := NearestUnitToUnit ( tmp , unit ) ;
52410: LD_ADDR_VAR 0 10
52414: PUSH
52415: LD_VAR 0 8
52419: PPUSH
52420: LD_VAR 0 1
52424: PPUSH
52425: CALL_OW 74
52429: ST_TO_ADDR
// if not enemy then
52430: LD_VAR 0 10
52434: NOT
52435: IFFALSE 52439
// exit ;
52437: GO 52840
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
52439: LD_VAR 0 11
52443: PUSH
52444: LD_VAR 0 11
52448: PPUSH
52449: LD_VAR 0 10
52453: PPUSH
52454: CALL_OW 296
52458: PUSH
52459: LD_INT 13
52461: GREATER
52462: AND
52463: PUSH
52464: LD_VAR 0 1
52468: PPUSH
52469: LD_VAR 0 10
52473: PPUSH
52474: CALL_OW 296
52478: PUSH
52479: LD_INT 12
52481: GREATER
52482: OR
52483: IFFALSE 52487
// exit ;
52485: GO 52840
// missile := [ 1 ] ;
52487: LD_ADDR_VAR 0 14
52491: PUSH
52492: LD_INT 1
52494: PUSH
52495: EMPTY
52496: LIST
52497: ST_TO_ADDR
// if Researched ( side , tech_space ) then
52498: LD_VAR 0 9
52502: PPUSH
52503: LD_VAR 0 12
52507: PPUSH
52508: CALL_OW 325
52512: IFFALSE 52541
// missile := Insert ( missile , missile + 1 , 2 ) ;
52514: LD_ADDR_VAR 0 14
52518: PUSH
52519: LD_VAR 0 14
52523: PPUSH
52524: LD_VAR 0 14
52528: PUSH
52529: LD_INT 1
52531: PLUS
52532: PPUSH
52533: LD_INT 2
52535: PPUSH
52536: CALL_OW 2
52540: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
52541: LD_VAR 0 9
52545: PPUSH
52546: LD_VAR 0 13
52550: PPUSH
52551: CALL_OW 325
52555: PUSH
52556: LD_VAR 0 10
52560: PPUSH
52561: CALL_OW 255
52565: PPUSH
52566: LD_VAR 0 13
52570: PPUSH
52571: CALL_OW 325
52575: NOT
52576: AND
52577: IFFALSE 52606
// missile := Insert ( missile , missile + 1 , 3 ) ;
52579: LD_ADDR_VAR 0 14
52583: PUSH
52584: LD_VAR 0 14
52588: PPUSH
52589: LD_VAR 0 14
52593: PUSH
52594: LD_INT 1
52596: PLUS
52597: PPUSH
52598: LD_INT 3
52600: PPUSH
52601: CALL_OW 2
52605: ST_TO_ADDR
// if missile < 2 then
52606: LD_VAR 0 14
52610: PUSH
52611: LD_INT 2
52613: LESS
52614: IFFALSE 52618
// exit ;
52616: GO 52840
// x := GetX ( enemy ) ;
52618: LD_ADDR_VAR 0 4
52622: PUSH
52623: LD_VAR 0 10
52627: PPUSH
52628: CALL_OW 250
52632: ST_TO_ADDR
// y := GetY ( enemy ) ;
52633: LD_ADDR_VAR 0 5
52637: PUSH
52638: LD_VAR 0 10
52642: PPUSH
52643: CALL_OW 251
52647: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
52648: LD_ADDR_VAR 0 6
52652: PUSH
52653: LD_VAR 0 4
52657: PUSH
52658: LD_INT 1
52660: NEG
52661: PPUSH
52662: LD_INT 1
52664: PPUSH
52665: CALL_OW 12
52669: PLUS
52670: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
52671: LD_ADDR_VAR 0 7
52675: PUSH
52676: LD_VAR 0 5
52680: PUSH
52681: LD_INT 1
52683: NEG
52684: PPUSH
52685: LD_INT 1
52687: PPUSH
52688: CALL_OW 12
52692: PLUS
52693: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52694: LD_VAR 0 6
52698: PPUSH
52699: LD_VAR 0 7
52703: PPUSH
52704: CALL_OW 488
52708: NOT
52709: IFFALSE 52731
// begin _x := x ;
52711: LD_ADDR_VAR 0 6
52715: PUSH
52716: LD_VAR 0 4
52720: ST_TO_ADDR
// _y := y ;
52721: LD_ADDR_VAR 0 7
52725: PUSH
52726: LD_VAR 0 5
52730: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
52731: LD_ADDR_VAR 0 3
52735: PUSH
52736: LD_INT 1
52738: PPUSH
52739: LD_VAR 0 14
52743: PPUSH
52744: CALL_OW 12
52748: ST_TO_ADDR
// case i of 1 :
52749: LD_VAR 0 3
52753: PUSH
52754: LD_INT 1
52756: DOUBLE
52757: EQUAL
52758: IFTRUE 52762
52760: GO 52779
52762: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
52763: LD_VAR 0 1
52767: PPUSH
52768: LD_VAR 0 10
52772: PPUSH
52773: CALL_OW 115
52777: GO 52840
52779: LD_INT 2
52781: DOUBLE
52782: EQUAL
52783: IFTRUE 52787
52785: GO 52809
52787: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
52788: LD_VAR 0 1
52792: PPUSH
52793: LD_VAR 0 6
52797: PPUSH
52798: LD_VAR 0 7
52802: PPUSH
52803: CALL_OW 153
52807: GO 52840
52809: LD_INT 3
52811: DOUBLE
52812: EQUAL
52813: IFTRUE 52817
52815: GO 52839
52817: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
52818: LD_VAR 0 1
52822: PPUSH
52823: LD_VAR 0 6
52827: PPUSH
52828: LD_VAR 0 7
52832: PPUSH
52833: CALL_OW 154
52837: GO 52840
52839: POP
// end ;
52840: LD_VAR 0 2
52844: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
52845: LD_INT 0
52847: PPUSH
52848: PPUSH
52849: PPUSH
52850: PPUSH
52851: PPUSH
52852: PPUSH
// if not unit or not building then
52853: LD_VAR 0 1
52857: NOT
52858: PUSH
52859: LD_VAR 0 2
52863: NOT
52864: OR
52865: IFFALSE 52869
// exit ;
52867: GO 53027
// x := GetX ( building ) ;
52869: LD_ADDR_VAR 0 5
52873: PUSH
52874: LD_VAR 0 2
52878: PPUSH
52879: CALL_OW 250
52883: ST_TO_ADDR
// y := GetY ( building ) ;
52884: LD_ADDR_VAR 0 6
52888: PUSH
52889: LD_VAR 0 2
52893: PPUSH
52894: CALL_OW 251
52898: ST_TO_ADDR
// for i = 0 to 5 do
52899: LD_ADDR_VAR 0 4
52903: PUSH
52904: DOUBLE
52905: LD_INT 0
52907: DEC
52908: ST_TO_ADDR
52909: LD_INT 5
52911: PUSH
52912: FOR_TO
52913: IFFALSE 53025
// begin _x := ShiftX ( x , i , 3 ) ;
52915: LD_ADDR_VAR 0 7
52919: PUSH
52920: LD_VAR 0 5
52924: PPUSH
52925: LD_VAR 0 4
52929: PPUSH
52930: LD_INT 3
52932: PPUSH
52933: CALL_OW 272
52937: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52938: LD_ADDR_VAR 0 8
52942: PUSH
52943: LD_VAR 0 6
52947: PPUSH
52948: LD_VAR 0 4
52952: PPUSH
52953: LD_INT 3
52955: PPUSH
52956: CALL_OW 273
52960: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52961: LD_VAR 0 7
52965: PPUSH
52966: LD_VAR 0 8
52970: PPUSH
52971: CALL_OW 488
52975: NOT
52976: IFFALSE 52980
// continue ;
52978: GO 52912
// if HexInfo ( _x , _y ) = 0 then
52980: LD_VAR 0 7
52984: PPUSH
52985: LD_VAR 0 8
52989: PPUSH
52990: CALL_OW 428
52994: PUSH
52995: LD_INT 0
52997: EQUAL
52998: IFFALSE 53023
// begin ComMoveXY ( unit , _x , _y ) ;
53000: LD_VAR 0 1
53004: PPUSH
53005: LD_VAR 0 7
53009: PPUSH
53010: LD_VAR 0 8
53014: PPUSH
53015: CALL_OW 111
// exit ;
53019: POP
53020: POP
53021: GO 53027
// end ; end ;
53023: GO 52912
53025: POP
53026: POP
// end ;
53027: LD_VAR 0 3
53031: RET
// export function ScanBase ( side , base_area ) ; begin
53032: LD_INT 0
53034: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53035: LD_ADDR_VAR 0 3
53039: PUSH
53040: LD_VAR 0 2
53044: PPUSH
53045: LD_INT 81
53047: PUSH
53048: LD_VAR 0 1
53052: PUSH
53053: EMPTY
53054: LIST
53055: LIST
53056: PPUSH
53057: CALL_OW 70
53061: ST_TO_ADDR
// end ;
53062: LD_VAR 0 3
53066: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53067: LD_INT 0
53069: PPUSH
53070: PPUSH
53071: PPUSH
53072: PPUSH
// result := false ;
53073: LD_ADDR_VAR 0 2
53077: PUSH
53078: LD_INT 0
53080: ST_TO_ADDR
// side := GetSide ( unit ) ;
53081: LD_ADDR_VAR 0 3
53085: PUSH
53086: LD_VAR 0 1
53090: PPUSH
53091: CALL_OW 255
53095: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53096: LD_ADDR_VAR 0 4
53100: PUSH
53101: LD_VAR 0 1
53105: PPUSH
53106: CALL_OW 248
53110: ST_TO_ADDR
// case nat of 1 :
53111: LD_VAR 0 4
53115: PUSH
53116: LD_INT 1
53118: DOUBLE
53119: EQUAL
53120: IFTRUE 53124
53122: GO 53135
53124: POP
// tech := tech_lassight ; 2 :
53125: LD_ADDR_VAR 0 5
53129: PUSH
53130: LD_INT 12
53132: ST_TO_ADDR
53133: GO 53174
53135: LD_INT 2
53137: DOUBLE
53138: EQUAL
53139: IFTRUE 53143
53141: GO 53154
53143: POP
// tech := tech_mortar ; 3 :
53144: LD_ADDR_VAR 0 5
53148: PUSH
53149: LD_INT 41
53151: ST_TO_ADDR
53152: GO 53174
53154: LD_INT 3
53156: DOUBLE
53157: EQUAL
53158: IFTRUE 53162
53160: GO 53173
53162: POP
// tech := tech_bazooka ; end ;
53163: LD_ADDR_VAR 0 5
53167: PUSH
53168: LD_INT 44
53170: ST_TO_ADDR
53171: GO 53174
53173: POP
// if Researched ( side , tech ) then
53174: LD_VAR 0 3
53178: PPUSH
53179: LD_VAR 0 5
53183: PPUSH
53184: CALL_OW 325
53188: IFFALSE 53215
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53190: LD_ADDR_VAR 0 2
53194: PUSH
53195: LD_INT 5
53197: PUSH
53198: LD_INT 8
53200: PUSH
53201: LD_INT 9
53203: PUSH
53204: EMPTY
53205: LIST
53206: LIST
53207: LIST
53208: PUSH
53209: LD_VAR 0 4
53213: ARRAY
53214: ST_TO_ADDR
// end ;
53215: LD_VAR 0 2
53219: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53220: LD_INT 0
53222: PPUSH
53223: PPUSH
53224: PPUSH
// if not mines then
53225: LD_VAR 0 2
53229: NOT
53230: IFFALSE 53234
// exit ;
53232: GO 53378
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53234: LD_ADDR_VAR 0 5
53238: PUSH
53239: LD_INT 81
53241: PUSH
53242: LD_VAR 0 1
53246: PUSH
53247: EMPTY
53248: LIST
53249: LIST
53250: PUSH
53251: LD_INT 3
53253: PUSH
53254: LD_INT 21
53256: PUSH
53257: LD_INT 3
53259: PUSH
53260: EMPTY
53261: LIST
53262: LIST
53263: PUSH
53264: EMPTY
53265: LIST
53266: LIST
53267: PUSH
53268: EMPTY
53269: LIST
53270: LIST
53271: PPUSH
53272: CALL_OW 69
53276: ST_TO_ADDR
// for i in mines do
53277: LD_ADDR_VAR 0 4
53281: PUSH
53282: LD_VAR 0 2
53286: PUSH
53287: FOR_IN
53288: IFFALSE 53376
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53290: LD_VAR 0 4
53294: PUSH
53295: LD_INT 1
53297: ARRAY
53298: PPUSH
53299: LD_VAR 0 4
53303: PUSH
53304: LD_INT 2
53306: ARRAY
53307: PPUSH
53308: CALL_OW 458
53312: NOT
53313: IFFALSE 53317
// continue ;
53315: GO 53287
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53317: LD_VAR 0 4
53321: PUSH
53322: LD_INT 1
53324: ARRAY
53325: PPUSH
53326: LD_VAR 0 4
53330: PUSH
53331: LD_INT 2
53333: ARRAY
53334: PPUSH
53335: CALL_OW 428
53339: PUSH
53340: LD_VAR 0 5
53344: IN
53345: IFFALSE 53374
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53347: LD_VAR 0 4
53351: PUSH
53352: LD_INT 1
53354: ARRAY
53355: PPUSH
53356: LD_VAR 0 4
53360: PUSH
53361: LD_INT 2
53363: ARRAY
53364: PPUSH
53365: LD_VAR 0 1
53369: PPUSH
53370: CALL_OW 456
// end ;
53374: GO 53287
53376: POP
53377: POP
// end ;
53378: LD_VAR 0 3
53382: RET
// export function Count ( array ) ; var i ; begin
53383: LD_INT 0
53385: PPUSH
53386: PPUSH
// result := 0 ;
53387: LD_ADDR_VAR 0 2
53391: PUSH
53392: LD_INT 0
53394: ST_TO_ADDR
// for i in array do
53395: LD_ADDR_VAR 0 3
53399: PUSH
53400: LD_VAR 0 1
53404: PUSH
53405: FOR_IN
53406: IFFALSE 53430
// if i then
53408: LD_VAR 0 3
53412: IFFALSE 53428
// result := result + 1 ;
53414: LD_ADDR_VAR 0 2
53418: PUSH
53419: LD_VAR 0 2
53423: PUSH
53424: LD_INT 1
53426: PLUS
53427: ST_TO_ADDR
53428: GO 53405
53430: POP
53431: POP
// end ;
53432: LD_VAR 0 2
53436: RET
// export function IsEmpty ( building ) ; begin
53437: LD_INT 0
53439: PPUSH
// if not building then
53440: LD_VAR 0 1
53444: NOT
53445: IFFALSE 53449
// exit ;
53447: GO 53492
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
53449: LD_ADDR_VAR 0 2
53453: PUSH
53454: LD_VAR 0 1
53458: PUSH
53459: LD_INT 22
53461: PUSH
53462: LD_VAR 0 1
53466: PPUSH
53467: CALL_OW 255
53471: PUSH
53472: EMPTY
53473: LIST
53474: LIST
53475: PUSH
53476: LD_INT 58
53478: PUSH
53479: EMPTY
53480: LIST
53481: PUSH
53482: EMPTY
53483: LIST
53484: LIST
53485: PPUSH
53486: CALL_OW 69
53490: IN
53491: ST_TO_ADDR
// end ;
53492: LD_VAR 0 2
53496: RET
// export function IsNotFull ( building ) ; begin
53497: LD_INT 0
53499: PPUSH
// if not building then
53500: LD_VAR 0 1
53504: NOT
53505: IFFALSE 53509
// exit ;
53507: GO 53528
// result := UnitsInside ( building ) < 6 ;
53509: LD_ADDR_VAR 0 2
53513: PUSH
53514: LD_VAR 0 1
53518: PPUSH
53519: CALL_OW 313
53523: PUSH
53524: LD_INT 6
53526: LESS
53527: ST_TO_ADDR
// end ;
53528: LD_VAR 0 2
53532: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
53533: LD_INT 0
53535: PPUSH
53536: PPUSH
53537: PPUSH
53538: PPUSH
// tmp := [ ] ;
53539: LD_ADDR_VAR 0 3
53543: PUSH
53544: EMPTY
53545: ST_TO_ADDR
// list := [ ] ;
53546: LD_ADDR_VAR 0 5
53550: PUSH
53551: EMPTY
53552: ST_TO_ADDR
// for i = 16 to 25 do
53553: LD_ADDR_VAR 0 4
53557: PUSH
53558: DOUBLE
53559: LD_INT 16
53561: DEC
53562: ST_TO_ADDR
53563: LD_INT 25
53565: PUSH
53566: FOR_TO
53567: IFFALSE 53640
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
53569: LD_ADDR_VAR 0 3
53573: PUSH
53574: LD_VAR 0 3
53578: PUSH
53579: LD_INT 22
53581: PUSH
53582: LD_VAR 0 1
53586: PPUSH
53587: CALL_OW 255
53591: PUSH
53592: EMPTY
53593: LIST
53594: LIST
53595: PUSH
53596: LD_INT 91
53598: PUSH
53599: LD_VAR 0 1
53603: PUSH
53604: LD_INT 6
53606: PUSH
53607: EMPTY
53608: LIST
53609: LIST
53610: LIST
53611: PUSH
53612: LD_INT 30
53614: PUSH
53615: LD_VAR 0 4
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: PUSH
53624: EMPTY
53625: LIST
53626: LIST
53627: LIST
53628: PUSH
53629: EMPTY
53630: LIST
53631: PPUSH
53632: CALL_OW 69
53636: ADD
53637: ST_TO_ADDR
53638: GO 53566
53640: POP
53641: POP
// for i = 1 to tmp do
53642: LD_ADDR_VAR 0 4
53646: PUSH
53647: DOUBLE
53648: LD_INT 1
53650: DEC
53651: ST_TO_ADDR
53652: LD_VAR 0 3
53656: PUSH
53657: FOR_TO
53658: IFFALSE 53746
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
53660: LD_ADDR_VAR 0 5
53664: PUSH
53665: LD_VAR 0 5
53669: PUSH
53670: LD_VAR 0 3
53674: PUSH
53675: LD_VAR 0 4
53679: ARRAY
53680: PPUSH
53681: CALL_OW 266
53685: PUSH
53686: LD_VAR 0 3
53690: PUSH
53691: LD_VAR 0 4
53695: ARRAY
53696: PPUSH
53697: CALL_OW 250
53701: PUSH
53702: LD_VAR 0 3
53706: PUSH
53707: LD_VAR 0 4
53711: ARRAY
53712: PPUSH
53713: CALL_OW 251
53717: PUSH
53718: LD_VAR 0 3
53722: PUSH
53723: LD_VAR 0 4
53727: ARRAY
53728: PPUSH
53729: CALL_OW 254
53733: PUSH
53734: EMPTY
53735: LIST
53736: LIST
53737: LIST
53738: LIST
53739: PUSH
53740: EMPTY
53741: LIST
53742: ADD
53743: ST_TO_ADDR
53744: GO 53657
53746: POP
53747: POP
// result := list ;
53748: LD_ADDR_VAR 0 2
53752: PUSH
53753: LD_VAR 0 5
53757: ST_TO_ADDR
// end ;
53758: LD_VAR 0 2
53762: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
53763: LD_INT 0
53765: PPUSH
53766: PPUSH
53767: PPUSH
53768: PPUSH
53769: PPUSH
53770: PPUSH
53771: PPUSH
// if not factory then
53772: LD_VAR 0 1
53776: NOT
53777: IFFALSE 53781
// exit ;
53779: GO 54374
// if control = control_apeman then
53781: LD_VAR 0 4
53785: PUSH
53786: LD_INT 5
53788: EQUAL
53789: IFFALSE 53898
// begin tmp := UnitsInside ( factory ) ;
53791: LD_ADDR_VAR 0 8
53795: PUSH
53796: LD_VAR 0 1
53800: PPUSH
53801: CALL_OW 313
53805: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
53806: LD_VAR 0 8
53810: PPUSH
53811: LD_INT 25
53813: PUSH
53814: LD_INT 12
53816: PUSH
53817: EMPTY
53818: LIST
53819: LIST
53820: PPUSH
53821: CALL_OW 72
53825: NOT
53826: IFFALSE 53836
// control := control_manual ;
53828: LD_ADDR_VAR 0 4
53832: PUSH
53833: LD_INT 1
53835: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
53836: LD_ADDR_VAR 0 8
53840: PUSH
53841: LD_VAR 0 1
53845: PPUSH
53846: CALL 53533 0 1
53850: ST_TO_ADDR
// if tmp then
53851: LD_VAR 0 8
53855: IFFALSE 53898
// begin for i in tmp do
53857: LD_ADDR_VAR 0 7
53861: PUSH
53862: LD_VAR 0 8
53866: PUSH
53867: FOR_IN
53868: IFFALSE 53896
// if i [ 1 ] = b_ext_radio then
53870: LD_VAR 0 7
53874: PUSH
53875: LD_INT 1
53877: ARRAY
53878: PUSH
53879: LD_INT 22
53881: EQUAL
53882: IFFALSE 53894
// begin control := control_remote ;
53884: LD_ADDR_VAR 0 4
53888: PUSH
53889: LD_INT 2
53891: ST_TO_ADDR
// break ;
53892: GO 53896
// end ;
53894: GO 53867
53896: POP
53897: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
53898: LD_VAR 0 1
53902: PPUSH
53903: LD_VAR 0 2
53907: PPUSH
53908: LD_VAR 0 3
53912: PPUSH
53913: LD_VAR 0 4
53917: PPUSH
53918: LD_VAR 0 5
53922: PPUSH
53923: CALL_OW 448
53927: IFFALSE 53962
// begin result := [ chassis , engine , control , weapon ] ;
53929: LD_ADDR_VAR 0 6
53933: PUSH
53934: LD_VAR 0 2
53938: PUSH
53939: LD_VAR 0 3
53943: PUSH
53944: LD_VAR 0 4
53948: PUSH
53949: LD_VAR 0 5
53953: PUSH
53954: EMPTY
53955: LIST
53956: LIST
53957: LIST
53958: LIST
53959: ST_TO_ADDR
// exit ;
53960: GO 54374
// end ; _chassis := AvailableChassisList ( factory ) ;
53962: LD_ADDR_VAR 0 9
53966: PUSH
53967: LD_VAR 0 1
53971: PPUSH
53972: CALL_OW 475
53976: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
53977: LD_ADDR_VAR 0 11
53981: PUSH
53982: LD_VAR 0 1
53986: PPUSH
53987: CALL_OW 476
53991: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
53992: LD_ADDR_VAR 0 12
53996: PUSH
53997: LD_VAR 0 1
54001: PPUSH
54002: CALL_OW 477
54006: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54007: LD_ADDR_VAR 0 10
54011: PUSH
54012: LD_VAR 0 1
54016: PPUSH
54017: CALL_OW 478
54021: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54022: LD_VAR 0 9
54026: NOT
54027: PUSH
54028: LD_VAR 0 11
54032: NOT
54033: OR
54034: PUSH
54035: LD_VAR 0 12
54039: NOT
54040: OR
54041: PUSH
54042: LD_VAR 0 10
54046: NOT
54047: OR
54048: IFFALSE 54083
// begin result := [ chassis , engine , control , weapon ] ;
54050: LD_ADDR_VAR 0 6
54054: PUSH
54055: LD_VAR 0 2
54059: PUSH
54060: LD_VAR 0 3
54064: PUSH
54065: LD_VAR 0 4
54069: PUSH
54070: LD_VAR 0 5
54074: PUSH
54075: EMPTY
54076: LIST
54077: LIST
54078: LIST
54079: LIST
54080: ST_TO_ADDR
// exit ;
54081: GO 54374
// end ; if not chassis in _chassis then
54083: LD_VAR 0 2
54087: PUSH
54088: LD_VAR 0 9
54092: IN
54093: NOT
54094: IFFALSE 54120
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54096: LD_ADDR_VAR 0 2
54100: PUSH
54101: LD_VAR 0 9
54105: PUSH
54106: LD_INT 1
54108: PPUSH
54109: LD_VAR 0 9
54113: PPUSH
54114: CALL_OW 12
54118: ARRAY
54119: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54120: LD_VAR 0 2
54124: PPUSH
54125: LD_VAR 0 3
54129: PPUSH
54130: CALL 54379 0 2
54134: NOT
54135: IFFALSE 54194
// repeat engine := _engine [ 1 ] ;
54137: LD_ADDR_VAR 0 3
54141: PUSH
54142: LD_VAR 0 11
54146: PUSH
54147: LD_INT 1
54149: ARRAY
54150: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54151: LD_ADDR_VAR 0 11
54155: PUSH
54156: LD_VAR 0 11
54160: PPUSH
54161: LD_INT 1
54163: PPUSH
54164: CALL_OW 3
54168: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54169: LD_VAR 0 2
54173: PPUSH
54174: LD_VAR 0 3
54178: PPUSH
54179: CALL 54379 0 2
54183: PUSH
54184: LD_VAR 0 11
54188: PUSH
54189: EMPTY
54190: EQUAL
54191: OR
54192: IFFALSE 54137
// if not control in _control then
54194: LD_VAR 0 4
54198: PUSH
54199: LD_VAR 0 12
54203: IN
54204: NOT
54205: IFFALSE 54231
// control := _control [ rand ( 1 , _control ) ] ;
54207: LD_ADDR_VAR 0 4
54211: PUSH
54212: LD_VAR 0 12
54216: PUSH
54217: LD_INT 1
54219: PPUSH
54220: LD_VAR 0 12
54224: PPUSH
54225: CALL_OW 12
54229: ARRAY
54230: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54231: LD_VAR 0 2
54235: PPUSH
54236: LD_VAR 0 5
54240: PPUSH
54241: CALL 54599 0 2
54245: NOT
54246: IFFALSE 54305
// repeat weapon := _weapon [ 1 ] ;
54248: LD_ADDR_VAR 0 5
54252: PUSH
54253: LD_VAR 0 10
54257: PUSH
54258: LD_INT 1
54260: ARRAY
54261: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54262: LD_ADDR_VAR 0 10
54266: PUSH
54267: LD_VAR 0 10
54271: PPUSH
54272: LD_INT 1
54274: PPUSH
54275: CALL_OW 3
54279: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
54280: LD_VAR 0 2
54284: PPUSH
54285: LD_VAR 0 5
54289: PPUSH
54290: CALL 54599 0 2
54294: PUSH
54295: LD_VAR 0 10
54299: PUSH
54300: EMPTY
54301: EQUAL
54302: OR
54303: IFFALSE 54248
// result := [ ] ;
54305: LD_ADDR_VAR 0 6
54309: PUSH
54310: EMPTY
54311: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54312: LD_VAR 0 1
54316: PPUSH
54317: LD_VAR 0 2
54321: PPUSH
54322: LD_VAR 0 3
54326: PPUSH
54327: LD_VAR 0 4
54331: PPUSH
54332: LD_VAR 0 5
54336: PPUSH
54337: CALL_OW 448
54341: IFFALSE 54374
// result := [ chassis , engine , control , weapon ] ;
54343: LD_ADDR_VAR 0 6
54347: PUSH
54348: LD_VAR 0 2
54352: PUSH
54353: LD_VAR 0 3
54357: PUSH
54358: LD_VAR 0 4
54362: PUSH
54363: LD_VAR 0 5
54367: PUSH
54368: EMPTY
54369: LIST
54370: LIST
54371: LIST
54372: LIST
54373: ST_TO_ADDR
// end ;
54374: LD_VAR 0 6
54378: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
54379: LD_INT 0
54381: PPUSH
// if not chassis or not engine then
54382: LD_VAR 0 1
54386: NOT
54387: PUSH
54388: LD_VAR 0 2
54392: NOT
54393: OR
54394: IFFALSE 54398
// exit ;
54396: GO 54594
// case engine of engine_solar :
54398: LD_VAR 0 2
54402: PUSH
54403: LD_INT 2
54405: DOUBLE
54406: EQUAL
54407: IFTRUE 54411
54409: GO 54449
54411: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
54412: LD_ADDR_VAR 0 3
54416: PUSH
54417: LD_INT 11
54419: PUSH
54420: LD_INT 12
54422: PUSH
54423: LD_INT 13
54425: PUSH
54426: LD_INT 14
54428: PUSH
54429: LD_INT 1
54431: PUSH
54432: LD_INT 2
54434: PUSH
54435: LD_INT 3
54437: PUSH
54438: EMPTY
54439: LIST
54440: LIST
54441: LIST
54442: LIST
54443: LIST
54444: LIST
54445: LIST
54446: ST_TO_ADDR
54447: GO 54578
54449: LD_INT 1
54451: DOUBLE
54452: EQUAL
54453: IFTRUE 54457
54455: GO 54519
54457: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
54458: LD_ADDR_VAR 0 3
54462: PUSH
54463: LD_INT 11
54465: PUSH
54466: LD_INT 12
54468: PUSH
54469: LD_INT 13
54471: PUSH
54472: LD_INT 14
54474: PUSH
54475: LD_INT 1
54477: PUSH
54478: LD_INT 2
54480: PUSH
54481: LD_INT 3
54483: PUSH
54484: LD_INT 4
54486: PUSH
54487: LD_INT 5
54489: PUSH
54490: LD_INT 21
54492: PUSH
54493: LD_INT 23
54495: PUSH
54496: LD_INT 22
54498: PUSH
54499: LD_INT 24
54501: PUSH
54502: EMPTY
54503: LIST
54504: LIST
54505: LIST
54506: LIST
54507: LIST
54508: LIST
54509: LIST
54510: LIST
54511: LIST
54512: LIST
54513: LIST
54514: LIST
54515: LIST
54516: ST_TO_ADDR
54517: GO 54578
54519: LD_INT 3
54521: DOUBLE
54522: EQUAL
54523: IFTRUE 54527
54525: GO 54577
54527: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
54528: LD_ADDR_VAR 0 3
54532: PUSH
54533: LD_INT 13
54535: PUSH
54536: LD_INT 14
54538: PUSH
54539: LD_INT 2
54541: PUSH
54542: LD_INT 3
54544: PUSH
54545: LD_INT 4
54547: PUSH
54548: LD_INT 5
54550: PUSH
54551: LD_INT 21
54553: PUSH
54554: LD_INT 22
54556: PUSH
54557: LD_INT 23
54559: PUSH
54560: LD_INT 24
54562: PUSH
54563: EMPTY
54564: LIST
54565: LIST
54566: LIST
54567: LIST
54568: LIST
54569: LIST
54570: LIST
54571: LIST
54572: LIST
54573: LIST
54574: ST_TO_ADDR
54575: GO 54578
54577: POP
// result := ( chassis in result ) ;
54578: LD_ADDR_VAR 0 3
54582: PUSH
54583: LD_VAR 0 1
54587: PUSH
54588: LD_VAR 0 3
54592: IN
54593: ST_TO_ADDR
// end ;
54594: LD_VAR 0 3
54598: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
54599: LD_INT 0
54601: PPUSH
// if not chassis or not weapon then
54602: LD_VAR 0 1
54606: NOT
54607: PUSH
54608: LD_VAR 0 2
54612: NOT
54613: OR
54614: IFFALSE 54618
// exit ;
54616: GO 55680
// case weapon of us_machine_gun :
54618: LD_VAR 0 2
54622: PUSH
54623: LD_INT 2
54625: DOUBLE
54626: EQUAL
54627: IFTRUE 54631
54629: GO 54661
54631: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
54632: LD_ADDR_VAR 0 3
54636: PUSH
54637: LD_INT 1
54639: PUSH
54640: LD_INT 2
54642: PUSH
54643: LD_INT 3
54645: PUSH
54646: LD_INT 4
54648: PUSH
54649: LD_INT 5
54651: PUSH
54652: EMPTY
54653: LIST
54654: LIST
54655: LIST
54656: LIST
54657: LIST
54658: ST_TO_ADDR
54659: GO 55664
54661: LD_INT 3
54663: DOUBLE
54664: EQUAL
54665: IFTRUE 54669
54667: GO 54699
54669: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
54670: LD_ADDR_VAR 0 3
54674: PUSH
54675: LD_INT 1
54677: PUSH
54678: LD_INT 2
54680: PUSH
54681: LD_INT 3
54683: PUSH
54684: LD_INT 4
54686: PUSH
54687: LD_INT 5
54689: PUSH
54690: EMPTY
54691: LIST
54692: LIST
54693: LIST
54694: LIST
54695: LIST
54696: ST_TO_ADDR
54697: GO 55664
54699: LD_INT 11
54701: DOUBLE
54702: EQUAL
54703: IFTRUE 54707
54705: GO 54737
54707: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
54708: LD_ADDR_VAR 0 3
54712: PUSH
54713: LD_INT 1
54715: PUSH
54716: LD_INT 2
54718: PUSH
54719: LD_INT 3
54721: PUSH
54722: LD_INT 4
54724: PUSH
54725: LD_INT 5
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: LIST
54733: LIST
54734: ST_TO_ADDR
54735: GO 55664
54737: LD_INT 4
54739: DOUBLE
54740: EQUAL
54741: IFTRUE 54745
54743: GO 54771
54745: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
54746: LD_ADDR_VAR 0 3
54750: PUSH
54751: LD_INT 2
54753: PUSH
54754: LD_INT 3
54756: PUSH
54757: LD_INT 4
54759: PUSH
54760: LD_INT 5
54762: PUSH
54763: EMPTY
54764: LIST
54765: LIST
54766: LIST
54767: LIST
54768: ST_TO_ADDR
54769: GO 55664
54771: LD_INT 5
54773: DOUBLE
54774: EQUAL
54775: IFTRUE 54779
54777: GO 54805
54779: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
54780: LD_ADDR_VAR 0 3
54784: PUSH
54785: LD_INT 2
54787: PUSH
54788: LD_INT 3
54790: PUSH
54791: LD_INT 4
54793: PUSH
54794: LD_INT 5
54796: PUSH
54797: EMPTY
54798: LIST
54799: LIST
54800: LIST
54801: LIST
54802: ST_TO_ADDR
54803: GO 55664
54805: LD_INT 9
54807: DOUBLE
54808: EQUAL
54809: IFTRUE 54813
54811: GO 54839
54813: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
54814: LD_ADDR_VAR 0 3
54818: PUSH
54819: LD_INT 2
54821: PUSH
54822: LD_INT 3
54824: PUSH
54825: LD_INT 4
54827: PUSH
54828: LD_INT 5
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: LIST
54835: LIST
54836: ST_TO_ADDR
54837: GO 55664
54839: LD_INT 7
54841: DOUBLE
54842: EQUAL
54843: IFTRUE 54847
54845: GO 54873
54847: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
54848: LD_ADDR_VAR 0 3
54852: PUSH
54853: LD_INT 2
54855: PUSH
54856: LD_INT 3
54858: PUSH
54859: LD_INT 4
54861: PUSH
54862: LD_INT 5
54864: PUSH
54865: EMPTY
54866: LIST
54867: LIST
54868: LIST
54869: LIST
54870: ST_TO_ADDR
54871: GO 55664
54873: LD_INT 12
54875: DOUBLE
54876: EQUAL
54877: IFTRUE 54881
54879: GO 54907
54881: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
54882: LD_ADDR_VAR 0 3
54886: PUSH
54887: LD_INT 2
54889: PUSH
54890: LD_INT 3
54892: PUSH
54893: LD_INT 4
54895: PUSH
54896: LD_INT 5
54898: PUSH
54899: EMPTY
54900: LIST
54901: LIST
54902: LIST
54903: LIST
54904: ST_TO_ADDR
54905: GO 55664
54907: LD_INT 13
54909: DOUBLE
54910: EQUAL
54911: IFTRUE 54915
54913: GO 54941
54915: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
54916: LD_ADDR_VAR 0 3
54920: PUSH
54921: LD_INT 2
54923: PUSH
54924: LD_INT 3
54926: PUSH
54927: LD_INT 4
54929: PUSH
54930: LD_INT 5
54932: PUSH
54933: EMPTY
54934: LIST
54935: LIST
54936: LIST
54937: LIST
54938: ST_TO_ADDR
54939: GO 55664
54941: LD_INT 14
54943: DOUBLE
54944: EQUAL
54945: IFTRUE 54949
54947: GO 54967
54949: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
54950: LD_ADDR_VAR 0 3
54954: PUSH
54955: LD_INT 4
54957: PUSH
54958: LD_INT 5
54960: PUSH
54961: EMPTY
54962: LIST
54963: LIST
54964: ST_TO_ADDR
54965: GO 55664
54967: LD_INT 6
54969: DOUBLE
54970: EQUAL
54971: IFTRUE 54975
54973: GO 54993
54975: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
54976: LD_ADDR_VAR 0 3
54980: PUSH
54981: LD_INT 4
54983: PUSH
54984: LD_INT 5
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: ST_TO_ADDR
54991: GO 55664
54993: LD_INT 10
54995: DOUBLE
54996: EQUAL
54997: IFTRUE 55001
54999: GO 55019
55001: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55002: LD_ADDR_VAR 0 3
55006: PUSH
55007: LD_INT 4
55009: PUSH
55010: LD_INT 5
55012: PUSH
55013: EMPTY
55014: LIST
55015: LIST
55016: ST_TO_ADDR
55017: GO 55664
55019: LD_INT 22
55021: DOUBLE
55022: EQUAL
55023: IFTRUE 55027
55025: GO 55053
55027: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55028: LD_ADDR_VAR 0 3
55032: PUSH
55033: LD_INT 11
55035: PUSH
55036: LD_INT 12
55038: PUSH
55039: LD_INT 13
55041: PUSH
55042: LD_INT 14
55044: PUSH
55045: EMPTY
55046: LIST
55047: LIST
55048: LIST
55049: LIST
55050: ST_TO_ADDR
55051: GO 55664
55053: LD_INT 23
55055: DOUBLE
55056: EQUAL
55057: IFTRUE 55061
55059: GO 55087
55061: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55062: LD_ADDR_VAR 0 3
55066: PUSH
55067: LD_INT 11
55069: PUSH
55070: LD_INT 12
55072: PUSH
55073: LD_INT 13
55075: PUSH
55076: LD_INT 14
55078: PUSH
55079: EMPTY
55080: LIST
55081: LIST
55082: LIST
55083: LIST
55084: ST_TO_ADDR
55085: GO 55664
55087: LD_INT 24
55089: DOUBLE
55090: EQUAL
55091: IFTRUE 55095
55093: GO 55121
55095: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55096: LD_ADDR_VAR 0 3
55100: PUSH
55101: LD_INT 11
55103: PUSH
55104: LD_INT 12
55106: PUSH
55107: LD_INT 13
55109: PUSH
55110: LD_INT 14
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: LIST
55117: LIST
55118: ST_TO_ADDR
55119: GO 55664
55121: LD_INT 30
55123: DOUBLE
55124: EQUAL
55125: IFTRUE 55129
55127: GO 55155
55129: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55130: LD_ADDR_VAR 0 3
55134: PUSH
55135: LD_INT 11
55137: PUSH
55138: LD_INT 12
55140: PUSH
55141: LD_INT 13
55143: PUSH
55144: LD_INT 14
55146: PUSH
55147: EMPTY
55148: LIST
55149: LIST
55150: LIST
55151: LIST
55152: ST_TO_ADDR
55153: GO 55664
55155: LD_INT 25
55157: DOUBLE
55158: EQUAL
55159: IFTRUE 55163
55161: GO 55181
55163: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55164: LD_ADDR_VAR 0 3
55168: PUSH
55169: LD_INT 13
55171: PUSH
55172: LD_INT 14
55174: PUSH
55175: EMPTY
55176: LIST
55177: LIST
55178: ST_TO_ADDR
55179: GO 55664
55181: LD_INT 27
55183: DOUBLE
55184: EQUAL
55185: IFTRUE 55189
55187: GO 55207
55189: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55190: LD_ADDR_VAR 0 3
55194: PUSH
55195: LD_INT 13
55197: PUSH
55198: LD_INT 14
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: ST_TO_ADDR
55205: GO 55664
55207: LD_EXP 77
55211: DOUBLE
55212: EQUAL
55213: IFTRUE 55217
55215: GO 55243
55217: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55218: LD_ADDR_VAR 0 3
55222: PUSH
55223: LD_INT 11
55225: PUSH
55226: LD_INT 12
55228: PUSH
55229: LD_INT 13
55231: PUSH
55232: LD_INT 14
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: LIST
55239: LIST
55240: ST_TO_ADDR
55241: GO 55664
55243: LD_INT 28
55245: DOUBLE
55246: EQUAL
55247: IFTRUE 55251
55249: GO 55269
55251: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55252: LD_ADDR_VAR 0 3
55256: PUSH
55257: LD_INT 13
55259: PUSH
55260: LD_INT 14
55262: PUSH
55263: EMPTY
55264: LIST
55265: LIST
55266: ST_TO_ADDR
55267: GO 55664
55269: LD_INT 29
55271: DOUBLE
55272: EQUAL
55273: IFTRUE 55277
55275: GO 55295
55277: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55278: LD_ADDR_VAR 0 3
55282: PUSH
55283: LD_INT 13
55285: PUSH
55286: LD_INT 14
55288: PUSH
55289: EMPTY
55290: LIST
55291: LIST
55292: ST_TO_ADDR
55293: GO 55664
55295: LD_INT 31
55297: DOUBLE
55298: EQUAL
55299: IFTRUE 55303
55301: GO 55321
55303: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55304: LD_ADDR_VAR 0 3
55308: PUSH
55309: LD_INT 13
55311: PUSH
55312: LD_INT 14
55314: PUSH
55315: EMPTY
55316: LIST
55317: LIST
55318: ST_TO_ADDR
55319: GO 55664
55321: LD_INT 26
55323: DOUBLE
55324: EQUAL
55325: IFTRUE 55329
55327: GO 55347
55329: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
55330: LD_ADDR_VAR 0 3
55334: PUSH
55335: LD_INT 13
55337: PUSH
55338: LD_INT 14
55340: PUSH
55341: EMPTY
55342: LIST
55343: LIST
55344: ST_TO_ADDR
55345: GO 55664
55347: LD_INT 42
55349: DOUBLE
55350: EQUAL
55351: IFTRUE 55355
55353: GO 55381
55355: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
55356: LD_ADDR_VAR 0 3
55360: PUSH
55361: LD_INT 21
55363: PUSH
55364: LD_INT 22
55366: PUSH
55367: LD_INT 23
55369: PUSH
55370: LD_INT 24
55372: PUSH
55373: EMPTY
55374: LIST
55375: LIST
55376: LIST
55377: LIST
55378: ST_TO_ADDR
55379: GO 55664
55381: LD_INT 43
55383: DOUBLE
55384: EQUAL
55385: IFTRUE 55389
55387: GO 55415
55389: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
55390: LD_ADDR_VAR 0 3
55394: PUSH
55395: LD_INT 21
55397: PUSH
55398: LD_INT 22
55400: PUSH
55401: LD_INT 23
55403: PUSH
55404: LD_INT 24
55406: PUSH
55407: EMPTY
55408: LIST
55409: LIST
55410: LIST
55411: LIST
55412: ST_TO_ADDR
55413: GO 55664
55415: LD_INT 44
55417: DOUBLE
55418: EQUAL
55419: IFTRUE 55423
55421: GO 55449
55423: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
55424: LD_ADDR_VAR 0 3
55428: PUSH
55429: LD_INT 21
55431: PUSH
55432: LD_INT 22
55434: PUSH
55435: LD_INT 23
55437: PUSH
55438: LD_INT 24
55440: PUSH
55441: EMPTY
55442: LIST
55443: LIST
55444: LIST
55445: LIST
55446: ST_TO_ADDR
55447: GO 55664
55449: LD_INT 45
55451: DOUBLE
55452: EQUAL
55453: IFTRUE 55457
55455: GO 55483
55457: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
55458: LD_ADDR_VAR 0 3
55462: PUSH
55463: LD_INT 21
55465: PUSH
55466: LD_INT 22
55468: PUSH
55469: LD_INT 23
55471: PUSH
55472: LD_INT 24
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: LIST
55479: LIST
55480: ST_TO_ADDR
55481: GO 55664
55483: LD_INT 49
55485: DOUBLE
55486: EQUAL
55487: IFTRUE 55491
55489: GO 55517
55491: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
55492: LD_ADDR_VAR 0 3
55496: PUSH
55497: LD_INT 21
55499: PUSH
55500: LD_INT 22
55502: PUSH
55503: LD_INT 23
55505: PUSH
55506: LD_INT 24
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: LIST
55513: LIST
55514: ST_TO_ADDR
55515: GO 55664
55517: LD_INT 51
55519: DOUBLE
55520: EQUAL
55521: IFTRUE 55525
55523: GO 55551
55525: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
55526: LD_ADDR_VAR 0 3
55530: PUSH
55531: LD_INT 21
55533: PUSH
55534: LD_INT 22
55536: PUSH
55537: LD_INT 23
55539: PUSH
55540: LD_INT 24
55542: PUSH
55543: EMPTY
55544: LIST
55545: LIST
55546: LIST
55547: LIST
55548: ST_TO_ADDR
55549: GO 55664
55551: LD_INT 52
55553: DOUBLE
55554: EQUAL
55555: IFTRUE 55559
55557: GO 55585
55559: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
55560: LD_ADDR_VAR 0 3
55564: PUSH
55565: LD_INT 21
55567: PUSH
55568: LD_INT 22
55570: PUSH
55571: LD_INT 23
55573: PUSH
55574: LD_INT 24
55576: PUSH
55577: EMPTY
55578: LIST
55579: LIST
55580: LIST
55581: LIST
55582: ST_TO_ADDR
55583: GO 55664
55585: LD_INT 53
55587: DOUBLE
55588: EQUAL
55589: IFTRUE 55593
55591: GO 55611
55593: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
55594: LD_ADDR_VAR 0 3
55598: PUSH
55599: LD_INT 23
55601: PUSH
55602: LD_INT 24
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: ST_TO_ADDR
55609: GO 55664
55611: LD_INT 46
55613: DOUBLE
55614: EQUAL
55615: IFTRUE 55619
55617: GO 55637
55619: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
55620: LD_ADDR_VAR 0 3
55624: PUSH
55625: LD_INT 23
55627: PUSH
55628: LD_INT 24
55630: PUSH
55631: EMPTY
55632: LIST
55633: LIST
55634: ST_TO_ADDR
55635: GO 55664
55637: LD_INT 47
55639: DOUBLE
55640: EQUAL
55641: IFTRUE 55645
55643: GO 55663
55645: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55646: LD_ADDR_VAR 0 3
55650: PUSH
55651: LD_INT 23
55653: PUSH
55654: LD_INT 24
55656: PUSH
55657: EMPTY
55658: LIST
55659: LIST
55660: ST_TO_ADDR
55661: GO 55664
55663: POP
// result := ( chassis in result ) ;
55664: LD_ADDR_VAR 0 3
55668: PUSH
55669: LD_VAR 0 1
55673: PUSH
55674: LD_VAR 0 3
55678: IN
55679: ST_TO_ADDR
// end ;
55680: LD_VAR 0 3
55684: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
55685: LD_INT 0
55687: PPUSH
55688: PPUSH
55689: PPUSH
55690: PPUSH
55691: PPUSH
55692: PPUSH
55693: PPUSH
// result := array ;
55694: LD_ADDR_VAR 0 5
55698: PUSH
55699: LD_VAR 0 1
55703: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
55704: LD_VAR 0 1
55708: NOT
55709: PUSH
55710: LD_VAR 0 2
55714: NOT
55715: OR
55716: PUSH
55717: LD_VAR 0 3
55721: NOT
55722: OR
55723: PUSH
55724: LD_VAR 0 2
55728: PUSH
55729: LD_VAR 0 1
55733: GREATER
55734: OR
55735: PUSH
55736: LD_VAR 0 3
55740: PUSH
55741: LD_VAR 0 1
55745: GREATER
55746: OR
55747: IFFALSE 55751
// exit ;
55749: GO 56047
// if direction then
55751: LD_VAR 0 4
55755: IFFALSE 55819
// begin d := 1 ;
55757: LD_ADDR_VAR 0 9
55761: PUSH
55762: LD_INT 1
55764: ST_TO_ADDR
// if i_from > i_to then
55765: LD_VAR 0 2
55769: PUSH
55770: LD_VAR 0 3
55774: GREATER
55775: IFFALSE 55801
// length := ( array - i_from ) + i_to else
55777: LD_ADDR_VAR 0 11
55781: PUSH
55782: LD_VAR 0 1
55786: PUSH
55787: LD_VAR 0 2
55791: MINUS
55792: PUSH
55793: LD_VAR 0 3
55797: PLUS
55798: ST_TO_ADDR
55799: GO 55817
// length := i_to - i_from ;
55801: LD_ADDR_VAR 0 11
55805: PUSH
55806: LD_VAR 0 3
55810: PUSH
55811: LD_VAR 0 2
55815: MINUS
55816: ST_TO_ADDR
// end else
55817: GO 55880
// begin d := - 1 ;
55819: LD_ADDR_VAR 0 9
55823: PUSH
55824: LD_INT 1
55826: NEG
55827: ST_TO_ADDR
// if i_from > i_to then
55828: LD_VAR 0 2
55832: PUSH
55833: LD_VAR 0 3
55837: GREATER
55838: IFFALSE 55858
// length := i_from - i_to else
55840: LD_ADDR_VAR 0 11
55844: PUSH
55845: LD_VAR 0 2
55849: PUSH
55850: LD_VAR 0 3
55854: MINUS
55855: ST_TO_ADDR
55856: GO 55880
// length := ( array - i_to ) + i_from ;
55858: LD_ADDR_VAR 0 11
55862: PUSH
55863: LD_VAR 0 1
55867: PUSH
55868: LD_VAR 0 3
55872: MINUS
55873: PUSH
55874: LD_VAR 0 2
55878: PLUS
55879: ST_TO_ADDR
// end ; if not length then
55880: LD_VAR 0 11
55884: NOT
55885: IFFALSE 55889
// exit ;
55887: GO 56047
// tmp := array ;
55889: LD_ADDR_VAR 0 10
55893: PUSH
55894: LD_VAR 0 1
55898: ST_TO_ADDR
// for i = 1 to length do
55899: LD_ADDR_VAR 0 6
55903: PUSH
55904: DOUBLE
55905: LD_INT 1
55907: DEC
55908: ST_TO_ADDR
55909: LD_VAR 0 11
55913: PUSH
55914: FOR_TO
55915: IFFALSE 56035
// begin for j = 1 to array do
55917: LD_ADDR_VAR 0 7
55921: PUSH
55922: DOUBLE
55923: LD_INT 1
55925: DEC
55926: ST_TO_ADDR
55927: LD_VAR 0 1
55931: PUSH
55932: FOR_TO
55933: IFFALSE 56021
// begin k := j + d ;
55935: LD_ADDR_VAR 0 8
55939: PUSH
55940: LD_VAR 0 7
55944: PUSH
55945: LD_VAR 0 9
55949: PLUS
55950: ST_TO_ADDR
// if k > array then
55951: LD_VAR 0 8
55955: PUSH
55956: LD_VAR 0 1
55960: GREATER
55961: IFFALSE 55971
// k := 1 ;
55963: LD_ADDR_VAR 0 8
55967: PUSH
55968: LD_INT 1
55970: ST_TO_ADDR
// if not k then
55971: LD_VAR 0 8
55975: NOT
55976: IFFALSE 55988
// k := array ;
55978: LD_ADDR_VAR 0 8
55982: PUSH
55983: LD_VAR 0 1
55987: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
55988: LD_ADDR_VAR 0 10
55992: PUSH
55993: LD_VAR 0 10
55997: PPUSH
55998: LD_VAR 0 8
56002: PPUSH
56003: LD_VAR 0 1
56007: PUSH
56008: LD_VAR 0 7
56012: ARRAY
56013: PPUSH
56014: CALL_OW 1
56018: ST_TO_ADDR
// end ;
56019: GO 55932
56021: POP
56022: POP
// array := tmp ;
56023: LD_ADDR_VAR 0 1
56027: PUSH
56028: LD_VAR 0 10
56032: ST_TO_ADDR
// end ;
56033: GO 55914
56035: POP
56036: POP
// result := array ;
56037: LD_ADDR_VAR 0 5
56041: PUSH
56042: LD_VAR 0 1
56046: ST_TO_ADDR
// end ;
56047: LD_VAR 0 5
56051: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56052: LD_INT 0
56054: PPUSH
56055: PPUSH
// result := 0 ;
56056: LD_ADDR_VAR 0 3
56060: PUSH
56061: LD_INT 0
56063: ST_TO_ADDR
// if not array or not value in array then
56064: LD_VAR 0 1
56068: NOT
56069: PUSH
56070: LD_VAR 0 2
56074: PUSH
56075: LD_VAR 0 1
56079: IN
56080: NOT
56081: OR
56082: IFFALSE 56086
// exit ;
56084: GO 56140
// for i = 1 to array do
56086: LD_ADDR_VAR 0 4
56090: PUSH
56091: DOUBLE
56092: LD_INT 1
56094: DEC
56095: ST_TO_ADDR
56096: LD_VAR 0 1
56100: PUSH
56101: FOR_TO
56102: IFFALSE 56138
// if value = array [ i ] then
56104: LD_VAR 0 2
56108: PUSH
56109: LD_VAR 0 1
56113: PUSH
56114: LD_VAR 0 4
56118: ARRAY
56119: EQUAL
56120: IFFALSE 56136
// begin result := i ;
56122: LD_ADDR_VAR 0 3
56126: PUSH
56127: LD_VAR 0 4
56131: ST_TO_ADDR
// exit ;
56132: POP
56133: POP
56134: GO 56140
// end ;
56136: GO 56101
56138: POP
56139: POP
// end ;
56140: LD_VAR 0 3
56144: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56145: LD_INT 0
56147: PPUSH
// vc_chassis := chassis ;
56148: LD_ADDR_OWVAR 37
56152: PUSH
56153: LD_VAR 0 1
56157: ST_TO_ADDR
// vc_engine := engine ;
56158: LD_ADDR_OWVAR 39
56162: PUSH
56163: LD_VAR 0 2
56167: ST_TO_ADDR
// vc_control := control ;
56168: LD_ADDR_OWVAR 38
56172: PUSH
56173: LD_VAR 0 3
56177: ST_TO_ADDR
// vc_weapon := weapon ;
56178: LD_ADDR_OWVAR 40
56182: PUSH
56183: LD_VAR 0 4
56187: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56188: LD_ADDR_OWVAR 41
56192: PUSH
56193: LD_VAR 0 5
56197: ST_TO_ADDR
// end ;
56198: LD_VAR 0 6
56202: RET
// export function WantPlant ( unit ) ; var task ; begin
56203: LD_INT 0
56205: PPUSH
56206: PPUSH
// result := false ;
56207: LD_ADDR_VAR 0 2
56211: PUSH
56212: LD_INT 0
56214: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56215: LD_ADDR_VAR 0 3
56219: PUSH
56220: LD_VAR 0 1
56224: PPUSH
56225: CALL_OW 437
56229: ST_TO_ADDR
// if task then
56230: LD_VAR 0 3
56234: IFFALSE 56262
// if task [ 1 ] [ 1 ] = p then
56236: LD_VAR 0 3
56240: PUSH
56241: LD_INT 1
56243: ARRAY
56244: PUSH
56245: LD_INT 1
56247: ARRAY
56248: PUSH
56249: LD_STRING p
56251: EQUAL
56252: IFFALSE 56262
// result := true ;
56254: LD_ADDR_VAR 0 2
56258: PUSH
56259: LD_INT 1
56261: ST_TO_ADDR
// end ;
56262: LD_VAR 0 2
56266: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56267: LD_INT 0
56269: PPUSH
56270: PPUSH
56271: PPUSH
56272: PPUSH
// if pos < 1 then
56273: LD_VAR 0 2
56277: PUSH
56278: LD_INT 1
56280: LESS
56281: IFFALSE 56285
// exit ;
56283: GO 56588
// if pos = 1 then
56285: LD_VAR 0 2
56289: PUSH
56290: LD_INT 1
56292: EQUAL
56293: IFFALSE 56326
// result := Replace ( arr , pos [ 1 ] , value ) else
56295: LD_ADDR_VAR 0 4
56299: PUSH
56300: LD_VAR 0 1
56304: PPUSH
56305: LD_VAR 0 2
56309: PUSH
56310: LD_INT 1
56312: ARRAY
56313: PPUSH
56314: LD_VAR 0 3
56318: PPUSH
56319: CALL_OW 1
56323: ST_TO_ADDR
56324: GO 56588
// begin tmp := arr ;
56326: LD_ADDR_VAR 0 6
56330: PUSH
56331: LD_VAR 0 1
56335: ST_TO_ADDR
// s_arr := [ tmp ] ;
56336: LD_ADDR_VAR 0 7
56340: PUSH
56341: LD_VAR 0 6
56345: PUSH
56346: EMPTY
56347: LIST
56348: ST_TO_ADDR
// for i = 1 to pos - 1 do
56349: LD_ADDR_VAR 0 5
56353: PUSH
56354: DOUBLE
56355: LD_INT 1
56357: DEC
56358: ST_TO_ADDR
56359: LD_VAR 0 2
56363: PUSH
56364: LD_INT 1
56366: MINUS
56367: PUSH
56368: FOR_TO
56369: IFFALSE 56414
// begin tmp := tmp [ pos [ i ] ] ;
56371: LD_ADDR_VAR 0 6
56375: PUSH
56376: LD_VAR 0 6
56380: PUSH
56381: LD_VAR 0 2
56385: PUSH
56386: LD_VAR 0 5
56390: ARRAY
56391: ARRAY
56392: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
56393: LD_ADDR_VAR 0 7
56397: PUSH
56398: LD_VAR 0 7
56402: PUSH
56403: LD_VAR 0 6
56407: PUSH
56408: EMPTY
56409: LIST
56410: ADD
56411: ST_TO_ADDR
// end ;
56412: GO 56368
56414: POP
56415: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
56416: LD_ADDR_VAR 0 6
56420: PUSH
56421: LD_VAR 0 6
56425: PPUSH
56426: LD_VAR 0 2
56430: PUSH
56431: LD_VAR 0 2
56435: ARRAY
56436: PPUSH
56437: LD_VAR 0 3
56441: PPUSH
56442: CALL_OW 1
56446: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
56447: LD_ADDR_VAR 0 7
56451: PUSH
56452: LD_VAR 0 7
56456: PPUSH
56457: LD_VAR 0 7
56461: PPUSH
56462: LD_VAR 0 6
56466: PPUSH
56467: CALL_OW 1
56471: ST_TO_ADDR
// for i = s_arr downto 2 do
56472: LD_ADDR_VAR 0 5
56476: PUSH
56477: DOUBLE
56478: LD_VAR 0 7
56482: INC
56483: ST_TO_ADDR
56484: LD_INT 2
56486: PUSH
56487: FOR_DOWNTO
56488: IFFALSE 56572
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
56490: LD_ADDR_VAR 0 6
56494: PUSH
56495: LD_VAR 0 7
56499: PUSH
56500: LD_VAR 0 5
56504: PUSH
56505: LD_INT 1
56507: MINUS
56508: ARRAY
56509: PPUSH
56510: LD_VAR 0 2
56514: PUSH
56515: LD_VAR 0 5
56519: PUSH
56520: LD_INT 1
56522: MINUS
56523: ARRAY
56524: PPUSH
56525: LD_VAR 0 7
56529: PUSH
56530: LD_VAR 0 5
56534: ARRAY
56535: PPUSH
56536: CALL_OW 1
56540: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
56541: LD_ADDR_VAR 0 7
56545: PUSH
56546: LD_VAR 0 7
56550: PPUSH
56551: LD_VAR 0 5
56555: PUSH
56556: LD_INT 1
56558: MINUS
56559: PPUSH
56560: LD_VAR 0 6
56564: PPUSH
56565: CALL_OW 1
56569: ST_TO_ADDR
// end ;
56570: GO 56487
56572: POP
56573: POP
// result := s_arr [ 1 ] ;
56574: LD_ADDR_VAR 0 4
56578: PUSH
56579: LD_VAR 0 7
56583: PUSH
56584: LD_INT 1
56586: ARRAY
56587: ST_TO_ADDR
// end ; end ;
56588: LD_VAR 0 4
56592: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
56593: LD_INT 0
56595: PPUSH
56596: PPUSH
// if not list then
56597: LD_VAR 0 1
56601: NOT
56602: IFFALSE 56606
// exit ;
56604: GO 56697
// i := list [ pos1 ] ;
56606: LD_ADDR_VAR 0 5
56610: PUSH
56611: LD_VAR 0 1
56615: PUSH
56616: LD_VAR 0 2
56620: ARRAY
56621: ST_TO_ADDR
// if not i then
56622: LD_VAR 0 5
56626: NOT
56627: IFFALSE 56631
// exit ;
56629: GO 56697
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
56631: LD_ADDR_VAR 0 1
56635: PUSH
56636: LD_VAR 0 1
56640: PPUSH
56641: LD_VAR 0 2
56645: PPUSH
56646: LD_VAR 0 1
56650: PUSH
56651: LD_VAR 0 3
56655: ARRAY
56656: PPUSH
56657: CALL_OW 1
56661: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
56662: LD_ADDR_VAR 0 1
56666: PUSH
56667: LD_VAR 0 1
56671: PPUSH
56672: LD_VAR 0 3
56676: PPUSH
56677: LD_VAR 0 5
56681: PPUSH
56682: CALL_OW 1
56686: ST_TO_ADDR
// result := list ;
56687: LD_ADDR_VAR 0 4
56691: PUSH
56692: LD_VAR 0 1
56696: ST_TO_ADDR
// end ;
56697: LD_VAR 0 4
56701: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
56702: LD_INT 0
56704: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
56705: LD_ADDR_VAR 0 5
56709: PUSH
56710: LD_VAR 0 1
56714: PPUSH
56715: CALL_OW 250
56719: PPUSH
56720: LD_VAR 0 1
56724: PPUSH
56725: CALL_OW 251
56729: PPUSH
56730: LD_VAR 0 2
56734: PPUSH
56735: LD_VAR 0 3
56739: PPUSH
56740: LD_VAR 0 4
56744: PPUSH
56745: CALL 56755 0 5
56749: ST_TO_ADDR
// end ;
56750: LD_VAR 0 5
56754: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
56755: LD_INT 0
56757: PPUSH
56758: PPUSH
56759: PPUSH
56760: PPUSH
// if not list then
56761: LD_VAR 0 3
56765: NOT
56766: IFFALSE 56770
// exit ;
56768: GO 57158
// result := [ ] ;
56770: LD_ADDR_VAR 0 6
56774: PUSH
56775: EMPTY
56776: ST_TO_ADDR
// for i in list do
56777: LD_ADDR_VAR 0 7
56781: PUSH
56782: LD_VAR 0 3
56786: PUSH
56787: FOR_IN
56788: IFFALSE 56990
// begin tmp := GetDistUnitXY ( i , x , y ) ;
56790: LD_ADDR_VAR 0 9
56794: PUSH
56795: LD_VAR 0 7
56799: PPUSH
56800: LD_VAR 0 1
56804: PPUSH
56805: LD_VAR 0 2
56809: PPUSH
56810: CALL_OW 297
56814: ST_TO_ADDR
// if not result then
56815: LD_VAR 0 6
56819: NOT
56820: IFFALSE 56846
// result := [ [ i , tmp ] ] else
56822: LD_ADDR_VAR 0 6
56826: PUSH
56827: LD_VAR 0 7
56831: PUSH
56832: LD_VAR 0 9
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: PUSH
56841: EMPTY
56842: LIST
56843: ST_TO_ADDR
56844: GO 56988
// begin if result [ result ] [ 2 ] < tmp then
56846: LD_VAR 0 6
56850: PUSH
56851: LD_VAR 0 6
56855: ARRAY
56856: PUSH
56857: LD_INT 2
56859: ARRAY
56860: PUSH
56861: LD_VAR 0 9
56865: LESS
56866: IFFALSE 56908
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
56868: LD_ADDR_VAR 0 6
56872: PUSH
56873: LD_VAR 0 6
56877: PPUSH
56878: LD_VAR 0 6
56882: PUSH
56883: LD_INT 1
56885: PLUS
56886: PPUSH
56887: LD_VAR 0 7
56891: PUSH
56892: LD_VAR 0 9
56896: PUSH
56897: EMPTY
56898: LIST
56899: LIST
56900: PPUSH
56901: CALL_OW 2
56905: ST_TO_ADDR
56906: GO 56988
// for j = 1 to result do
56908: LD_ADDR_VAR 0 8
56912: PUSH
56913: DOUBLE
56914: LD_INT 1
56916: DEC
56917: ST_TO_ADDR
56918: LD_VAR 0 6
56922: PUSH
56923: FOR_TO
56924: IFFALSE 56986
// begin if tmp < result [ j ] [ 2 ] then
56926: LD_VAR 0 9
56930: PUSH
56931: LD_VAR 0 6
56935: PUSH
56936: LD_VAR 0 8
56940: ARRAY
56941: PUSH
56942: LD_INT 2
56944: ARRAY
56945: LESS
56946: IFFALSE 56984
// begin result := Insert ( result , j , [ i , tmp ] ) ;
56948: LD_ADDR_VAR 0 6
56952: PUSH
56953: LD_VAR 0 6
56957: PPUSH
56958: LD_VAR 0 8
56962: PPUSH
56963: LD_VAR 0 7
56967: PUSH
56968: LD_VAR 0 9
56972: PUSH
56973: EMPTY
56974: LIST
56975: LIST
56976: PPUSH
56977: CALL_OW 2
56981: ST_TO_ADDR
// break ;
56982: GO 56986
// end ; end ;
56984: GO 56923
56986: POP
56987: POP
// end ; end ;
56988: GO 56787
56990: POP
56991: POP
// if result and not asc then
56992: LD_VAR 0 6
56996: PUSH
56997: LD_VAR 0 4
57001: NOT
57002: AND
57003: IFFALSE 57078
// begin tmp := result ;
57005: LD_ADDR_VAR 0 9
57009: PUSH
57010: LD_VAR 0 6
57014: ST_TO_ADDR
// for i = tmp downto 1 do
57015: LD_ADDR_VAR 0 7
57019: PUSH
57020: DOUBLE
57021: LD_VAR 0 9
57025: INC
57026: ST_TO_ADDR
57027: LD_INT 1
57029: PUSH
57030: FOR_DOWNTO
57031: IFFALSE 57076
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57033: LD_ADDR_VAR 0 6
57037: PUSH
57038: LD_VAR 0 6
57042: PPUSH
57043: LD_VAR 0 9
57047: PUSH
57048: LD_VAR 0 7
57052: MINUS
57053: PUSH
57054: LD_INT 1
57056: PLUS
57057: PPUSH
57058: LD_VAR 0 9
57062: PUSH
57063: LD_VAR 0 7
57067: ARRAY
57068: PPUSH
57069: CALL_OW 1
57073: ST_TO_ADDR
57074: GO 57030
57076: POP
57077: POP
// end ; tmp := [ ] ;
57078: LD_ADDR_VAR 0 9
57082: PUSH
57083: EMPTY
57084: ST_TO_ADDR
// if mode then
57085: LD_VAR 0 5
57089: IFFALSE 57158
// begin for i = 1 to result do
57091: LD_ADDR_VAR 0 7
57095: PUSH
57096: DOUBLE
57097: LD_INT 1
57099: DEC
57100: ST_TO_ADDR
57101: LD_VAR 0 6
57105: PUSH
57106: FOR_TO
57107: IFFALSE 57146
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57109: LD_ADDR_VAR 0 9
57113: PUSH
57114: LD_VAR 0 9
57118: PPUSH
57119: LD_VAR 0 7
57123: PPUSH
57124: LD_VAR 0 6
57128: PUSH
57129: LD_VAR 0 7
57133: ARRAY
57134: PUSH
57135: LD_INT 1
57137: ARRAY
57138: PPUSH
57139: CALL_OW 1
57143: ST_TO_ADDR
57144: GO 57106
57146: POP
57147: POP
// result := tmp ;
57148: LD_ADDR_VAR 0 6
57152: PUSH
57153: LD_VAR 0 9
57157: ST_TO_ADDR
// end ; end ;
57158: LD_VAR 0 6
57162: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57163: LD_INT 0
57165: PPUSH
57166: PPUSH
57167: PPUSH
57168: PPUSH
57169: PPUSH
57170: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57171: LD_ADDR_VAR 0 5
57175: PUSH
57176: LD_INT 0
57178: PUSH
57179: LD_INT 0
57181: PUSH
57182: LD_INT 0
57184: PUSH
57185: EMPTY
57186: PUSH
57187: EMPTY
57188: LIST
57189: LIST
57190: LIST
57191: LIST
57192: ST_TO_ADDR
// if not x or not y then
57193: LD_VAR 0 2
57197: NOT
57198: PUSH
57199: LD_VAR 0 3
57203: NOT
57204: OR
57205: IFFALSE 57209
// exit ;
57207: GO 58861
// if not range then
57209: LD_VAR 0 4
57213: NOT
57214: IFFALSE 57224
// range := 10 ;
57216: LD_ADDR_VAR 0 4
57220: PUSH
57221: LD_INT 10
57223: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57224: LD_ADDR_VAR 0 8
57228: PUSH
57229: LD_INT 81
57231: PUSH
57232: LD_VAR 0 1
57236: PUSH
57237: EMPTY
57238: LIST
57239: LIST
57240: PUSH
57241: LD_INT 92
57243: PUSH
57244: LD_VAR 0 2
57248: PUSH
57249: LD_VAR 0 3
57253: PUSH
57254: LD_VAR 0 4
57258: PUSH
57259: EMPTY
57260: LIST
57261: LIST
57262: LIST
57263: LIST
57264: PUSH
57265: LD_INT 3
57267: PUSH
57268: LD_INT 21
57270: PUSH
57271: LD_INT 3
57273: PUSH
57274: EMPTY
57275: LIST
57276: LIST
57277: PUSH
57278: EMPTY
57279: LIST
57280: LIST
57281: PUSH
57282: EMPTY
57283: LIST
57284: LIST
57285: LIST
57286: PPUSH
57287: CALL_OW 69
57291: ST_TO_ADDR
// if not tmp then
57292: LD_VAR 0 8
57296: NOT
57297: IFFALSE 57301
// exit ;
57299: GO 58861
// for i in tmp do
57301: LD_ADDR_VAR 0 6
57305: PUSH
57306: LD_VAR 0 8
57310: PUSH
57311: FOR_IN
57312: IFFALSE 58836
// begin points := [ 0 , 0 , 0 ] ;
57314: LD_ADDR_VAR 0 9
57318: PUSH
57319: LD_INT 0
57321: PUSH
57322: LD_INT 0
57324: PUSH
57325: LD_INT 0
57327: PUSH
57328: EMPTY
57329: LIST
57330: LIST
57331: LIST
57332: ST_TO_ADDR
// bpoints := 1 ;
57333: LD_ADDR_VAR 0 10
57337: PUSH
57338: LD_INT 1
57340: ST_TO_ADDR
// case GetType ( i ) of unit_human :
57341: LD_VAR 0 6
57345: PPUSH
57346: CALL_OW 247
57350: PUSH
57351: LD_INT 1
57353: DOUBLE
57354: EQUAL
57355: IFTRUE 57359
57357: GO 57937
57359: POP
// begin if GetClass ( i ) = 1 then
57360: LD_VAR 0 6
57364: PPUSH
57365: CALL_OW 257
57369: PUSH
57370: LD_INT 1
57372: EQUAL
57373: IFFALSE 57394
// points := [ 10 , 5 , 3 ] ;
57375: LD_ADDR_VAR 0 9
57379: PUSH
57380: LD_INT 10
57382: PUSH
57383: LD_INT 5
57385: PUSH
57386: LD_INT 3
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: LIST
57393: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
57394: LD_VAR 0 6
57398: PPUSH
57399: CALL_OW 257
57403: PUSH
57404: LD_INT 2
57406: PUSH
57407: LD_INT 3
57409: PUSH
57410: LD_INT 4
57412: PUSH
57413: EMPTY
57414: LIST
57415: LIST
57416: LIST
57417: IN
57418: IFFALSE 57439
// points := [ 3 , 2 , 1 ] ;
57420: LD_ADDR_VAR 0 9
57424: PUSH
57425: LD_INT 3
57427: PUSH
57428: LD_INT 2
57430: PUSH
57431: LD_INT 1
57433: PUSH
57434: EMPTY
57435: LIST
57436: LIST
57437: LIST
57438: ST_TO_ADDR
// if GetClass ( i ) = 5 then
57439: LD_VAR 0 6
57443: PPUSH
57444: CALL_OW 257
57448: PUSH
57449: LD_INT 5
57451: EQUAL
57452: IFFALSE 57473
// points := [ 130 , 5 , 2 ] ;
57454: LD_ADDR_VAR 0 9
57458: PUSH
57459: LD_INT 130
57461: PUSH
57462: LD_INT 5
57464: PUSH
57465: LD_INT 2
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: LIST
57472: ST_TO_ADDR
// if GetClass ( i ) = 8 then
57473: LD_VAR 0 6
57477: PPUSH
57478: CALL_OW 257
57482: PUSH
57483: LD_INT 8
57485: EQUAL
57486: IFFALSE 57507
// points := [ 35 , 35 , 30 ] ;
57488: LD_ADDR_VAR 0 9
57492: PUSH
57493: LD_INT 35
57495: PUSH
57496: LD_INT 35
57498: PUSH
57499: LD_INT 30
57501: PUSH
57502: EMPTY
57503: LIST
57504: LIST
57505: LIST
57506: ST_TO_ADDR
// if GetClass ( i ) = 9 then
57507: LD_VAR 0 6
57511: PPUSH
57512: CALL_OW 257
57516: PUSH
57517: LD_INT 9
57519: EQUAL
57520: IFFALSE 57541
// points := [ 20 , 55 , 40 ] ;
57522: LD_ADDR_VAR 0 9
57526: PUSH
57527: LD_INT 20
57529: PUSH
57530: LD_INT 55
57532: PUSH
57533: LD_INT 40
57535: PUSH
57536: EMPTY
57537: LIST
57538: LIST
57539: LIST
57540: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
57541: LD_VAR 0 6
57545: PPUSH
57546: CALL_OW 257
57550: PUSH
57551: LD_INT 12
57553: PUSH
57554: LD_INT 16
57556: PUSH
57557: EMPTY
57558: LIST
57559: LIST
57560: IN
57561: IFFALSE 57582
// points := [ 5 , 3 , 2 ] ;
57563: LD_ADDR_VAR 0 9
57567: PUSH
57568: LD_INT 5
57570: PUSH
57571: LD_INT 3
57573: PUSH
57574: LD_INT 2
57576: PUSH
57577: EMPTY
57578: LIST
57579: LIST
57580: LIST
57581: ST_TO_ADDR
// if GetClass ( i ) = 17 then
57582: LD_VAR 0 6
57586: PPUSH
57587: CALL_OW 257
57591: PUSH
57592: LD_INT 17
57594: EQUAL
57595: IFFALSE 57616
// points := [ 100 , 50 , 75 ] ;
57597: LD_ADDR_VAR 0 9
57601: PUSH
57602: LD_INT 100
57604: PUSH
57605: LD_INT 50
57607: PUSH
57608: LD_INT 75
57610: PUSH
57611: EMPTY
57612: LIST
57613: LIST
57614: LIST
57615: ST_TO_ADDR
// if GetClass ( i ) = 15 then
57616: LD_VAR 0 6
57620: PPUSH
57621: CALL_OW 257
57625: PUSH
57626: LD_INT 15
57628: EQUAL
57629: IFFALSE 57650
// points := [ 10 , 5 , 3 ] ;
57631: LD_ADDR_VAR 0 9
57635: PUSH
57636: LD_INT 10
57638: PUSH
57639: LD_INT 5
57641: PUSH
57642: LD_INT 3
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: LIST
57649: ST_TO_ADDR
// if GetClass ( i ) = 14 then
57650: LD_VAR 0 6
57654: PPUSH
57655: CALL_OW 257
57659: PUSH
57660: LD_INT 14
57662: EQUAL
57663: IFFALSE 57684
// points := [ 10 , 0 , 0 ] ;
57665: LD_ADDR_VAR 0 9
57669: PUSH
57670: LD_INT 10
57672: PUSH
57673: LD_INT 0
57675: PUSH
57676: LD_INT 0
57678: PUSH
57679: EMPTY
57680: LIST
57681: LIST
57682: LIST
57683: ST_TO_ADDR
// if GetClass ( i ) = 11 then
57684: LD_VAR 0 6
57688: PPUSH
57689: CALL_OW 257
57693: PUSH
57694: LD_INT 11
57696: EQUAL
57697: IFFALSE 57718
// points := [ 30 , 10 , 5 ] ;
57699: LD_ADDR_VAR 0 9
57703: PUSH
57704: LD_INT 30
57706: PUSH
57707: LD_INT 10
57709: PUSH
57710: LD_INT 5
57712: PUSH
57713: EMPTY
57714: LIST
57715: LIST
57716: LIST
57717: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
57718: LD_VAR 0 1
57722: PPUSH
57723: LD_INT 5
57725: PPUSH
57726: CALL_OW 321
57730: PUSH
57731: LD_INT 2
57733: EQUAL
57734: IFFALSE 57751
// bpoints := bpoints * 1.8 ;
57736: LD_ADDR_VAR 0 10
57740: PUSH
57741: LD_VAR 0 10
57745: PUSH
57746: LD_REAL  1.80000000000000E+0000
57749: MUL
57750: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
57751: LD_VAR 0 6
57755: PPUSH
57756: CALL_OW 257
57760: PUSH
57761: LD_INT 1
57763: PUSH
57764: LD_INT 2
57766: PUSH
57767: LD_INT 3
57769: PUSH
57770: LD_INT 4
57772: PUSH
57773: EMPTY
57774: LIST
57775: LIST
57776: LIST
57777: LIST
57778: IN
57779: PUSH
57780: LD_VAR 0 1
57784: PPUSH
57785: LD_INT 51
57787: PPUSH
57788: CALL_OW 321
57792: PUSH
57793: LD_INT 2
57795: EQUAL
57796: AND
57797: IFFALSE 57814
// bpoints := bpoints * 1.2 ;
57799: LD_ADDR_VAR 0 10
57803: PUSH
57804: LD_VAR 0 10
57808: PUSH
57809: LD_REAL  1.20000000000000E+0000
57812: MUL
57813: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
57814: LD_VAR 0 6
57818: PPUSH
57819: CALL_OW 257
57823: PUSH
57824: LD_INT 5
57826: PUSH
57827: LD_INT 7
57829: PUSH
57830: LD_INT 9
57832: PUSH
57833: EMPTY
57834: LIST
57835: LIST
57836: LIST
57837: IN
57838: PUSH
57839: LD_VAR 0 1
57843: PPUSH
57844: LD_INT 52
57846: PPUSH
57847: CALL_OW 321
57851: PUSH
57852: LD_INT 2
57854: EQUAL
57855: AND
57856: IFFALSE 57873
// bpoints := bpoints * 1.5 ;
57858: LD_ADDR_VAR 0 10
57862: PUSH
57863: LD_VAR 0 10
57867: PUSH
57868: LD_REAL  1.50000000000000E+0000
57871: MUL
57872: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
57873: LD_VAR 0 1
57877: PPUSH
57878: LD_INT 66
57880: PPUSH
57881: CALL_OW 321
57885: PUSH
57886: LD_INT 2
57888: EQUAL
57889: IFFALSE 57906
// bpoints := bpoints * 1.1 ;
57891: LD_ADDR_VAR 0 10
57895: PUSH
57896: LD_VAR 0 10
57900: PUSH
57901: LD_REAL  1.10000000000000E+0000
57904: MUL
57905: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
57906: LD_ADDR_VAR 0 10
57910: PUSH
57911: LD_VAR 0 10
57915: PUSH
57916: LD_VAR 0 6
57920: PPUSH
57921: LD_INT 1
57923: PPUSH
57924: CALL_OW 259
57928: PUSH
57929: LD_REAL  1.15000000000000E+0000
57932: MUL
57933: MUL
57934: ST_TO_ADDR
// end ; unit_vehicle :
57935: GO 58765
57937: LD_INT 2
57939: DOUBLE
57940: EQUAL
57941: IFTRUE 57945
57943: GO 58753
57945: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
57946: LD_VAR 0 6
57950: PPUSH
57951: CALL_OW 264
57955: PUSH
57956: LD_INT 2
57958: PUSH
57959: LD_INT 42
57961: PUSH
57962: LD_INT 24
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: LIST
57969: IN
57970: IFFALSE 57991
// points := [ 25 , 5 , 3 ] ;
57972: LD_ADDR_VAR 0 9
57976: PUSH
57977: LD_INT 25
57979: PUSH
57980: LD_INT 5
57982: PUSH
57983: LD_INT 3
57985: PUSH
57986: EMPTY
57987: LIST
57988: LIST
57989: LIST
57990: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
57991: LD_VAR 0 6
57995: PPUSH
57996: CALL_OW 264
58000: PUSH
58001: LD_INT 4
58003: PUSH
58004: LD_INT 43
58006: PUSH
58007: LD_INT 25
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: LIST
58014: IN
58015: IFFALSE 58036
// points := [ 40 , 15 , 5 ] ;
58017: LD_ADDR_VAR 0 9
58021: PUSH
58022: LD_INT 40
58024: PUSH
58025: LD_INT 15
58027: PUSH
58028: LD_INT 5
58030: PUSH
58031: EMPTY
58032: LIST
58033: LIST
58034: LIST
58035: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58036: LD_VAR 0 6
58040: PPUSH
58041: CALL_OW 264
58045: PUSH
58046: LD_INT 3
58048: PUSH
58049: LD_INT 23
58051: PUSH
58052: EMPTY
58053: LIST
58054: LIST
58055: IN
58056: IFFALSE 58077
// points := [ 7 , 25 , 8 ] ;
58058: LD_ADDR_VAR 0 9
58062: PUSH
58063: LD_INT 7
58065: PUSH
58066: LD_INT 25
58068: PUSH
58069: LD_INT 8
58071: PUSH
58072: EMPTY
58073: LIST
58074: LIST
58075: LIST
58076: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58077: LD_VAR 0 6
58081: PPUSH
58082: CALL_OW 264
58086: PUSH
58087: LD_INT 5
58089: PUSH
58090: LD_INT 27
58092: PUSH
58093: LD_INT 44
58095: PUSH
58096: EMPTY
58097: LIST
58098: LIST
58099: LIST
58100: IN
58101: IFFALSE 58122
// points := [ 14 , 50 , 16 ] ;
58103: LD_ADDR_VAR 0 9
58107: PUSH
58108: LD_INT 14
58110: PUSH
58111: LD_INT 50
58113: PUSH
58114: LD_INT 16
58116: PUSH
58117: EMPTY
58118: LIST
58119: LIST
58120: LIST
58121: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58122: LD_VAR 0 6
58126: PPUSH
58127: CALL_OW 264
58131: PUSH
58132: LD_INT 6
58134: PUSH
58135: LD_INT 46
58137: PUSH
58138: EMPTY
58139: LIST
58140: LIST
58141: IN
58142: IFFALSE 58163
// points := [ 32 , 120 , 70 ] ;
58144: LD_ADDR_VAR 0 9
58148: PUSH
58149: LD_INT 32
58151: PUSH
58152: LD_INT 120
58154: PUSH
58155: LD_INT 70
58157: PUSH
58158: EMPTY
58159: LIST
58160: LIST
58161: LIST
58162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58163: LD_VAR 0 6
58167: PPUSH
58168: CALL_OW 264
58172: PUSH
58173: LD_INT 7
58175: PUSH
58176: LD_INT 28
58178: PUSH
58179: LD_INT 45
58181: PUSH
58182: LD_EXP 77
58186: PUSH
58187: EMPTY
58188: LIST
58189: LIST
58190: LIST
58191: LIST
58192: IN
58193: IFFALSE 58214
// points := [ 35 , 20 , 45 ] ;
58195: LD_ADDR_VAR 0 9
58199: PUSH
58200: LD_INT 35
58202: PUSH
58203: LD_INT 20
58205: PUSH
58206: LD_INT 45
58208: PUSH
58209: EMPTY
58210: LIST
58211: LIST
58212: LIST
58213: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58214: LD_VAR 0 6
58218: PPUSH
58219: CALL_OW 264
58223: PUSH
58224: LD_INT 47
58226: PUSH
58227: EMPTY
58228: LIST
58229: IN
58230: IFFALSE 58251
// points := [ 67 , 45 , 75 ] ;
58232: LD_ADDR_VAR 0 9
58236: PUSH
58237: LD_INT 67
58239: PUSH
58240: LD_INT 45
58242: PUSH
58243: LD_INT 75
58245: PUSH
58246: EMPTY
58247: LIST
58248: LIST
58249: LIST
58250: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58251: LD_VAR 0 6
58255: PPUSH
58256: CALL_OW 264
58260: PUSH
58261: LD_INT 26
58263: PUSH
58264: EMPTY
58265: LIST
58266: IN
58267: IFFALSE 58288
// points := [ 120 , 30 , 80 ] ;
58269: LD_ADDR_VAR 0 9
58273: PUSH
58274: LD_INT 120
58276: PUSH
58277: LD_INT 30
58279: PUSH
58280: LD_INT 80
58282: PUSH
58283: EMPTY
58284: LIST
58285: LIST
58286: LIST
58287: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58288: LD_VAR 0 6
58292: PPUSH
58293: CALL_OW 264
58297: PUSH
58298: LD_INT 22
58300: PUSH
58301: EMPTY
58302: LIST
58303: IN
58304: IFFALSE 58325
// points := [ 40 , 1 , 1 ] ;
58306: LD_ADDR_VAR 0 9
58310: PUSH
58311: LD_INT 40
58313: PUSH
58314: LD_INT 1
58316: PUSH
58317: LD_INT 1
58319: PUSH
58320: EMPTY
58321: LIST
58322: LIST
58323: LIST
58324: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
58325: LD_VAR 0 6
58329: PPUSH
58330: CALL_OW 264
58334: PUSH
58335: LD_INT 29
58337: PUSH
58338: EMPTY
58339: LIST
58340: IN
58341: IFFALSE 58362
// points := [ 70 , 200 , 400 ] ;
58343: LD_ADDR_VAR 0 9
58347: PUSH
58348: LD_INT 70
58350: PUSH
58351: LD_INT 200
58353: PUSH
58354: LD_INT 400
58356: PUSH
58357: EMPTY
58358: LIST
58359: LIST
58360: LIST
58361: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
58362: LD_VAR 0 6
58366: PPUSH
58367: CALL_OW 264
58371: PUSH
58372: LD_INT 14
58374: PUSH
58375: LD_INT 53
58377: PUSH
58378: EMPTY
58379: LIST
58380: LIST
58381: IN
58382: IFFALSE 58403
// points := [ 40 , 10 , 20 ] ;
58384: LD_ADDR_VAR 0 9
58388: PUSH
58389: LD_INT 40
58391: PUSH
58392: LD_INT 10
58394: PUSH
58395: LD_INT 20
58397: PUSH
58398: EMPTY
58399: LIST
58400: LIST
58401: LIST
58402: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
58403: LD_VAR 0 6
58407: PPUSH
58408: CALL_OW 264
58412: PUSH
58413: LD_INT 9
58415: PUSH
58416: EMPTY
58417: LIST
58418: IN
58419: IFFALSE 58440
// points := [ 5 , 70 , 20 ] ;
58421: LD_ADDR_VAR 0 9
58425: PUSH
58426: LD_INT 5
58428: PUSH
58429: LD_INT 70
58431: PUSH
58432: LD_INT 20
58434: PUSH
58435: EMPTY
58436: LIST
58437: LIST
58438: LIST
58439: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
58440: LD_VAR 0 6
58444: PPUSH
58445: CALL_OW 264
58449: PUSH
58450: LD_INT 10
58452: PUSH
58453: EMPTY
58454: LIST
58455: IN
58456: IFFALSE 58477
// points := [ 35 , 110 , 70 ] ;
58458: LD_ADDR_VAR 0 9
58462: PUSH
58463: LD_INT 35
58465: PUSH
58466: LD_INT 110
58468: PUSH
58469: LD_INT 70
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: LIST
58476: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
58477: LD_VAR 0 6
58481: PPUSH
58482: CALL_OW 265
58486: PUSH
58487: LD_INT 25
58489: EQUAL
58490: IFFALSE 58511
// points := [ 80 , 65 , 100 ] ;
58492: LD_ADDR_VAR 0 9
58496: PUSH
58497: LD_INT 80
58499: PUSH
58500: LD_INT 65
58502: PUSH
58503: LD_INT 100
58505: PUSH
58506: EMPTY
58507: LIST
58508: LIST
58509: LIST
58510: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
58511: LD_VAR 0 6
58515: PPUSH
58516: CALL_OW 263
58520: PUSH
58521: LD_INT 1
58523: EQUAL
58524: IFFALSE 58559
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
58526: LD_ADDR_VAR 0 10
58530: PUSH
58531: LD_VAR 0 10
58535: PUSH
58536: LD_VAR 0 6
58540: PPUSH
58541: CALL_OW 311
58545: PPUSH
58546: LD_INT 3
58548: PPUSH
58549: CALL_OW 259
58553: PUSH
58554: LD_INT 4
58556: MUL
58557: MUL
58558: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
58559: LD_VAR 0 6
58563: PPUSH
58564: CALL_OW 263
58568: PUSH
58569: LD_INT 2
58571: EQUAL
58572: IFFALSE 58623
// begin j := IsControledBy ( i ) ;
58574: LD_ADDR_VAR 0 7
58578: PUSH
58579: LD_VAR 0 6
58583: PPUSH
58584: CALL_OW 312
58588: ST_TO_ADDR
// if j then
58589: LD_VAR 0 7
58593: IFFALSE 58623
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
58595: LD_ADDR_VAR 0 10
58599: PUSH
58600: LD_VAR 0 10
58604: PUSH
58605: LD_VAR 0 7
58609: PPUSH
58610: LD_INT 3
58612: PPUSH
58613: CALL_OW 259
58617: PUSH
58618: LD_INT 3
58620: MUL
58621: MUL
58622: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
58623: LD_VAR 0 6
58627: PPUSH
58628: CALL_OW 264
58632: PUSH
58633: LD_INT 5
58635: PUSH
58636: LD_INT 6
58638: PUSH
58639: LD_INT 46
58641: PUSH
58642: LD_INT 44
58644: PUSH
58645: LD_INT 47
58647: PUSH
58648: LD_INT 45
58650: PUSH
58651: LD_INT 28
58653: PUSH
58654: LD_INT 7
58656: PUSH
58657: LD_INT 27
58659: PUSH
58660: LD_INT 29
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: LIST
58667: LIST
58668: LIST
58669: LIST
58670: LIST
58671: LIST
58672: LIST
58673: LIST
58674: IN
58675: PUSH
58676: LD_VAR 0 1
58680: PPUSH
58681: LD_INT 52
58683: PPUSH
58684: CALL_OW 321
58688: PUSH
58689: LD_INT 2
58691: EQUAL
58692: AND
58693: IFFALSE 58710
// bpoints := bpoints * 1.2 ;
58695: LD_ADDR_VAR 0 10
58699: PUSH
58700: LD_VAR 0 10
58704: PUSH
58705: LD_REAL  1.20000000000000E+0000
58708: MUL
58709: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
58710: LD_VAR 0 6
58714: PPUSH
58715: CALL_OW 264
58719: PUSH
58720: LD_INT 6
58722: PUSH
58723: LD_INT 46
58725: PUSH
58726: LD_INT 47
58728: PUSH
58729: EMPTY
58730: LIST
58731: LIST
58732: LIST
58733: IN
58734: IFFALSE 58751
// bpoints := bpoints * 1.2 ;
58736: LD_ADDR_VAR 0 10
58740: PUSH
58741: LD_VAR 0 10
58745: PUSH
58746: LD_REAL  1.20000000000000E+0000
58749: MUL
58750: ST_TO_ADDR
// end ; unit_building :
58751: GO 58765
58753: LD_INT 3
58755: DOUBLE
58756: EQUAL
58757: IFTRUE 58761
58759: GO 58764
58761: POP
// ; end ;
58762: GO 58765
58764: POP
// for j = 1 to 3 do
58765: LD_ADDR_VAR 0 7
58769: PUSH
58770: DOUBLE
58771: LD_INT 1
58773: DEC
58774: ST_TO_ADDR
58775: LD_INT 3
58777: PUSH
58778: FOR_TO
58779: IFFALSE 58832
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
58781: LD_ADDR_VAR 0 5
58785: PUSH
58786: LD_VAR 0 5
58790: PPUSH
58791: LD_VAR 0 7
58795: PPUSH
58796: LD_VAR 0 5
58800: PUSH
58801: LD_VAR 0 7
58805: ARRAY
58806: PUSH
58807: LD_VAR 0 9
58811: PUSH
58812: LD_VAR 0 7
58816: ARRAY
58817: PUSH
58818: LD_VAR 0 10
58822: MUL
58823: PLUS
58824: PPUSH
58825: CALL_OW 1
58829: ST_TO_ADDR
58830: GO 58778
58832: POP
58833: POP
// end ;
58834: GO 57311
58836: POP
58837: POP
// result := Replace ( result , 4 , tmp ) ;
58838: LD_ADDR_VAR 0 5
58842: PUSH
58843: LD_VAR 0 5
58847: PPUSH
58848: LD_INT 4
58850: PPUSH
58851: LD_VAR 0 8
58855: PPUSH
58856: CALL_OW 1
58860: ST_TO_ADDR
// end ;
58861: LD_VAR 0 5
58865: RET
// export function DangerAtRange ( unit , range ) ; begin
58866: LD_INT 0
58868: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
58869: LD_ADDR_VAR 0 3
58873: PUSH
58874: LD_VAR 0 1
58878: PPUSH
58879: CALL_OW 255
58883: PPUSH
58884: LD_VAR 0 1
58888: PPUSH
58889: CALL_OW 250
58893: PPUSH
58894: LD_VAR 0 1
58898: PPUSH
58899: CALL_OW 251
58903: PPUSH
58904: LD_VAR 0 2
58908: PPUSH
58909: CALL 57163 0 4
58913: ST_TO_ADDR
// end ;
58914: LD_VAR 0 3
58918: RET
// export function DangerInArea ( side , area ) ; begin
58919: LD_INT 0
58921: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
58922: LD_ADDR_VAR 0 3
58926: PUSH
58927: LD_VAR 0 2
58931: PPUSH
58932: LD_INT 81
58934: PUSH
58935: LD_VAR 0 1
58939: PUSH
58940: EMPTY
58941: LIST
58942: LIST
58943: PPUSH
58944: CALL_OW 70
58948: ST_TO_ADDR
// end ;
58949: LD_VAR 0 3
58953: RET
// export function IsExtension ( b ) ; begin
58954: LD_INT 0
58956: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
58957: LD_ADDR_VAR 0 2
58961: PUSH
58962: LD_VAR 0 1
58966: PUSH
58967: LD_INT 23
58969: PUSH
58970: LD_INT 20
58972: PUSH
58973: LD_INT 22
58975: PUSH
58976: LD_INT 17
58978: PUSH
58979: LD_INT 24
58981: PUSH
58982: LD_INT 21
58984: PUSH
58985: LD_INT 19
58987: PUSH
58988: LD_INT 16
58990: PUSH
58991: LD_INT 25
58993: PUSH
58994: LD_INT 18
58996: PUSH
58997: EMPTY
58998: LIST
58999: LIST
59000: LIST
59001: LIST
59002: LIST
59003: LIST
59004: LIST
59005: LIST
59006: LIST
59007: LIST
59008: IN
59009: ST_TO_ADDR
// end ;
59010: LD_VAR 0 2
59014: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59015: LD_INT 0
59017: PPUSH
59018: PPUSH
59019: PPUSH
// result := [ ] ;
59020: LD_ADDR_VAR 0 4
59024: PUSH
59025: EMPTY
59026: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59027: LD_ADDR_VAR 0 5
59031: PUSH
59032: LD_VAR 0 2
59036: PPUSH
59037: LD_INT 21
59039: PUSH
59040: LD_INT 3
59042: PUSH
59043: EMPTY
59044: LIST
59045: LIST
59046: PPUSH
59047: CALL_OW 70
59051: ST_TO_ADDR
// if not tmp then
59052: LD_VAR 0 5
59056: NOT
59057: IFFALSE 59061
// exit ;
59059: GO 59125
// if checkLink then
59061: LD_VAR 0 3
59065: IFFALSE 59115
// begin for i in tmp do
59067: LD_ADDR_VAR 0 6
59071: PUSH
59072: LD_VAR 0 5
59076: PUSH
59077: FOR_IN
59078: IFFALSE 59113
// if GetBase ( i ) <> base then
59080: LD_VAR 0 6
59084: PPUSH
59085: CALL_OW 274
59089: PUSH
59090: LD_VAR 0 1
59094: NONEQUAL
59095: IFFALSE 59111
// ComLinkToBase ( base , i ) ;
59097: LD_VAR 0 1
59101: PPUSH
59102: LD_VAR 0 6
59106: PPUSH
59107: CALL_OW 169
59111: GO 59077
59113: POP
59114: POP
// end ; result := tmp ;
59115: LD_ADDR_VAR 0 4
59119: PUSH
59120: LD_VAR 0 5
59124: ST_TO_ADDR
// end ;
59125: LD_VAR 0 4
59129: RET
// export function ComComplete ( units , b ) ; var i ; begin
59130: LD_INT 0
59132: PPUSH
59133: PPUSH
// if not units then
59134: LD_VAR 0 1
59138: NOT
59139: IFFALSE 59143
// exit ;
59141: GO 59233
// for i in units do
59143: LD_ADDR_VAR 0 4
59147: PUSH
59148: LD_VAR 0 1
59152: PUSH
59153: FOR_IN
59154: IFFALSE 59231
// if BuildingStatus ( b ) = bs_build then
59156: LD_VAR 0 2
59160: PPUSH
59161: CALL_OW 461
59165: PUSH
59166: LD_INT 1
59168: EQUAL
59169: IFFALSE 59229
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59171: LD_VAR 0 4
59175: PPUSH
59176: LD_STRING h
59178: PUSH
59179: LD_VAR 0 2
59183: PPUSH
59184: CALL_OW 250
59188: PUSH
59189: LD_VAR 0 2
59193: PPUSH
59194: CALL_OW 251
59198: PUSH
59199: LD_VAR 0 2
59203: PUSH
59204: LD_INT 0
59206: PUSH
59207: LD_INT 0
59209: PUSH
59210: LD_INT 0
59212: PUSH
59213: EMPTY
59214: LIST
59215: LIST
59216: LIST
59217: LIST
59218: LIST
59219: LIST
59220: LIST
59221: PUSH
59222: EMPTY
59223: LIST
59224: PPUSH
59225: CALL_OW 446
59229: GO 59153
59231: POP
59232: POP
// end ;
59233: LD_VAR 0 3
59237: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59238: LD_INT 0
59240: PPUSH
59241: PPUSH
59242: PPUSH
59243: PPUSH
59244: PPUSH
59245: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59246: LD_VAR 0 1
59250: NOT
59251: PUSH
59252: LD_VAR 0 1
59256: PPUSH
59257: CALL_OW 263
59261: PUSH
59262: LD_INT 2
59264: NONEQUAL
59265: OR
59266: IFFALSE 59270
// exit ;
59268: GO 59586
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59270: LD_ADDR_VAR 0 6
59274: PUSH
59275: LD_INT 22
59277: PUSH
59278: LD_VAR 0 1
59282: PPUSH
59283: CALL_OW 255
59287: PUSH
59288: EMPTY
59289: LIST
59290: LIST
59291: PUSH
59292: LD_INT 2
59294: PUSH
59295: LD_INT 30
59297: PUSH
59298: LD_INT 36
59300: PUSH
59301: EMPTY
59302: LIST
59303: LIST
59304: PUSH
59305: LD_INT 34
59307: PUSH
59308: LD_INT 31
59310: PUSH
59311: EMPTY
59312: LIST
59313: LIST
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: LIST
59319: PUSH
59320: EMPTY
59321: LIST
59322: LIST
59323: PPUSH
59324: CALL_OW 69
59328: ST_TO_ADDR
// if not tmp then
59329: LD_VAR 0 6
59333: NOT
59334: IFFALSE 59338
// exit ;
59336: GO 59586
// result := [ ] ;
59338: LD_ADDR_VAR 0 2
59342: PUSH
59343: EMPTY
59344: ST_TO_ADDR
// for i in tmp do
59345: LD_ADDR_VAR 0 3
59349: PUSH
59350: LD_VAR 0 6
59354: PUSH
59355: FOR_IN
59356: IFFALSE 59427
// begin t := UnitsInside ( i ) ;
59358: LD_ADDR_VAR 0 4
59362: PUSH
59363: LD_VAR 0 3
59367: PPUSH
59368: CALL_OW 313
59372: ST_TO_ADDR
// if t then
59373: LD_VAR 0 4
59377: IFFALSE 59425
// for j in t do
59379: LD_ADDR_VAR 0 7
59383: PUSH
59384: LD_VAR 0 4
59388: PUSH
59389: FOR_IN
59390: IFFALSE 59423
// result := Replace ( result , result + 1 , j ) ;
59392: LD_ADDR_VAR 0 2
59396: PUSH
59397: LD_VAR 0 2
59401: PPUSH
59402: LD_VAR 0 2
59406: PUSH
59407: LD_INT 1
59409: PLUS
59410: PPUSH
59411: LD_VAR 0 7
59415: PPUSH
59416: CALL_OW 1
59420: ST_TO_ADDR
59421: GO 59389
59423: POP
59424: POP
// end ;
59425: GO 59355
59427: POP
59428: POP
// if not result then
59429: LD_VAR 0 2
59433: NOT
59434: IFFALSE 59438
// exit ;
59436: GO 59586
// mech := result [ 1 ] ;
59438: LD_ADDR_VAR 0 5
59442: PUSH
59443: LD_VAR 0 2
59447: PUSH
59448: LD_INT 1
59450: ARRAY
59451: ST_TO_ADDR
// if result > 1 then
59452: LD_VAR 0 2
59456: PUSH
59457: LD_INT 1
59459: GREATER
59460: IFFALSE 59572
// begin for i = 2 to result do
59462: LD_ADDR_VAR 0 3
59466: PUSH
59467: DOUBLE
59468: LD_INT 2
59470: DEC
59471: ST_TO_ADDR
59472: LD_VAR 0 2
59476: PUSH
59477: FOR_TO
59478: IFFALSE 59570
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
59480: LD_ADDR_VAR 0 4
59484: PUSH
59485: LD_VAR 0 2
59489: PUSH
59490: LD_VAR 0 3
59494: ARRAY
59495: PPUSH
59496: LD_INT 3
59498: PPUSH
59499: CALL_OW 259
59503: PUSH
59504: LD_VAR 0 2
59508: PUSH
59509: LD_VAR 0 3
59513: ARRAY
59514: PPUSH
59515: CALL_OW 432
59519: MINUS
59520: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
59521: LD_VAR 0 4
59525: PUSH
59526: LD_VAR 0 5
59530: PPUSH
59531: LD_INT 3
59533: PPUSH
59534: CALL_OW 259
59538: PUSH
59539: LD_VAR 0 5
59543: PPUSH
59544: CALL_OW 432
59548: MINUS
59549: GREATEREQUAL
59550: IFFALSE 59568
// mech := result [ i ] ;
59552: LD_ADDR_VAR 0 5
59556: PUSH
59557: LD_VAR 0 2
59561: PUSH
59562: LD_VAR 0 3
59566: ARRAY
59567: ST_TO_ADDR
// end ;
59568: GO 59477
59570: POP
59571: POP
// end ; ComLinkTo ( vehicle , mech ) ;
59572: LD_VAR 0 1
59576: PPUSH
59577: LD_VAR 0 5
59581: PPUSH
59582: CALL_OW 135
// end ;
59586: LD_VAR 0 2
59590: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
59591: LD_INT 0
59593: PPUSH
59594: PPUSH
59595: PPUSH
59596: PPUSH
59597: PPUSH
59598: PPUSH
59599: PPUSH
59600: PPUSH
59601: PPUSH
59602: PPUSH
59603: PPUSH
59604: PPUSH
59605: PPUSH
// result := [ ] ;
59606: LD_ADDR_VAR 0 7
59610: PUSH
59611: EMPTY
59612: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
59613: LD_VAR 0 1
59617: PPUSH
59618: CALL_OW 266
59622: PUSH
59623: LD_INT 0
59625: PUSH
59626: LD_INT 1
59628: PUSH
59629: EMPTY
59630: LIST
59631: LIST
59632: IN
59633: NOT
59634: IFFALSE 59638
// exit ;
59636: GO 61272
// if name then
59638: LD_VAR 0 3
59642: IFFALSE 59658
// SetBName ( base_dep , name ) ;
59644: LD_VAR 0 1
59648: PPUSH
59649: LD_VAR 0 3
59653: PPUSH
59654: CALL_OW 500
// base := GetBase ( base_dep ) ;
59658: LD_ADDR_VAR 0 15
59662: PUSH
59663: LD_VAR 0 1
59667: PPUSH
59668: CALL_OW 274
59672: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
59673: LD_ADDR_VAR 0 16
59677: PUSH
59678: LD_VAR 0 1
59682: PPUSH
59683: CALL_OW 255
59687: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
59688: LD_ADDR_VAR 0 17
59692: PUSH
59693: LD_VAR 0 1
59697: PPUSH
59698: CALL_OW 248
59702: ST_TO_ADDR
// if sources then
59703: LD_VAR 0 5
59707: IFFALSE 59754
// for i = 1 to 3 do
59709: LD_ADDR_VAR 0 8
59713: PUSH
59714: DOUBLE
59715: LD_INT 1
59717: DEC
59718: ST_TO_ADDR
59719: LD_INT 3
59721: PUSH
59722: FOR_TO
59723: IFFALSE 59752
// AddResourceType ( base , i , sources [ i ] ) ;
59725: LD_VAR 0 15
59729: PPUSH
59730: LD_VAR 0 8
59734: PPUSH
59735: LD_VAR 0 5
59739: PUSH
59740: LD_VAR 0 8
59744: ARRAY
59745: PPUSH
59746: CALL_OW 276
59750: GO 59722
59752: POP
59753: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
59754: LD_ADDR_VAR 0 18
59758: PUSH
59759: LD_VAR 0 15
59763: PPUSH
59764: LD_VAR 0 2
59768: PPUSH
59769: LD_INT 1
59771: PPUSH
59772: CALL 59015 0 3
59776: ST_TO_ADDR
// InitHc ;
59777: CALL_OW 19
// InitUc ;
59781: CALL_OW 18
// uc_side := side ;
59785: LD_ADDR_OWVAR 20
59789: PUSH
59790: LD_VAR 0 16
59794: ST_TO_ADDR
// uc_nation := nation ;
59795: LD_ADDR_OWVAR 21
59799: PUSH
59800: LD_VAR 0 17
59804: ST_TO_ADDR
// if buildings then
59805: LD_VAR 0 18
59809: IFFALSE 61131
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
59811: LD_ADDR_VAR 0 19
59815: PUSH
59816: LD_VAR 0 18
59820: PPUSH
59821: LD_INT 2
59823: PUSH
59824: LD_INT 30
59826: PUSH
59827: LD_INT 29
59829: PUSH
59830: EMPTY
59831: LIST
59832: LIST
59833: PUSH
59834: LD_INT 30
59836: PUSH
59837: LD_INT 30
59839: PUSH
59840: EMPTY
59841: LIST
59842: LIST
59843: PUSH
59844: EMPTY
59845: LIST
59846: LIST
59847: LIST
59848: PPUSH
59849: CALL_OW 72
59853: ST_TO_ADDR
// if tmp then
59854: LD_VAR 0 19
59858: IFFALSE 59906
// for i in tmp do
59860: LD_ADDR_VAR 0 8
59864: PUSH
59865: LD_VAR 0 19
59869: PUSH
59870: FOR_IN
59871: IFFALSE 59904
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
59873: LD_VAR 0 8
59877: PPUSH
59878: CALL_OW 250
59882: PPUSH
59883: LD_VAR 0 8
59887: PPUSH
59888: CALL_OW 251
59892: PPUSH
59893: LD_VAR 0 16
59897: PPUSH
59898: CALL_OW 441
59902: GO 59870
59904: POP
59905: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
59906: LD_VAR 0 18
59910: PPUSH
59911: LD_INT 2
59913: PUSH
59914: LD_INT 30
59916: PUSH
59917: LD_INT 32
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: PUSH
59924: LD_INT 30
59926: PUSH
59927: LD_INT 33
59929: PUSH
59930: EMPTY
59931: LIST
59932: LIST
59933: PUSH
59934: EMPTY
59935: LIST
59936: LIST
59937: LIST
59938: PPUSH
59939: CALL_OW 72
59943: IFFALSE 60031
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
59945: LD_ADDR_VAR 0 8
59949: PUSH
59950: LD_VAR 0 18
59954: PPUSH
59955: LD_INT 2
59957: PUSH
59958: LD_INT 30
59960: PUSH
59961: LD_INT 32
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: PUSH
59968: LD_INT 30
59970: PUSH
59971: LD_INT 33
59973: PUSH
59974: EMPTY
59975: LIST
59976: LIST
59977: PUSH
59978: EMPTY
59979: LIST
59980: LIST
59981: LIST
59982: PPUSH
59983: CALL_OW 72
59987: PUSH
59988: FOR_IN
59989: IFFALSE 60029
// begin if not GetBWeapon ( i ) then
59991: LD_VAR 0 8
59995: PPUSH
59996: CALL_OW 269
60000: NOT
60001: IFFALSE 60027
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60003: LD_VAR 0 8
60007: PPUSH
60008: LD_VAR 0 8
60012: PPUSH
60013: LD_VAR 0 2
60017: PPUSH
60018: CALL 61277 0 2
60022: PPUSH
60023: CALL_OW 431
// end ;
60027: GO 59988
60029: POP
60030: POP
// end ; for i = 1 to personel do
60031: LD_ADDR_VAR 0 8
60035: PUSH
60036: DOUBLE
60037: LD_INT 1
60039: DEC
60040: ST_TO_ADDR
60041: LD_VAR 0 6
60045: PUSH
60046: FOR_TO
60047: IFFALSE 61111
// begin if i > 4 then
60049: LD_VAR 0 8
60053: PUSH
60054: LD_INT 4
60056: GREATER
60057: IFFALSE 60061
// break ;
60059: GO 61111
// case i of 1 :
60061: LD_VAR 0 8
60065: PUSH
60066: LD_INT 1
60068: DOUBLE
60069: EQUAL
60070: IFTRUE 60074
60072: GO 60154
60074: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60075: LD_ADDR_VAR 0 12
60079: PUSH
60080: LD_VAR 0 18
60084: PPUSH
60085: LD_INT 22
60087: PUSH
60088: LD_VAR 0 16
60092: PUSH
60093: EMPTY
60094: LIST
60095: LIST
60096: PUSH
60097: LD_INT 58
60099: PUSH
60100: EMPTY
60101: LIST
60102: PUSH
60103: LD_INT 2
60105: PUSH
60106: LD_INT 30
60108: PUSH
60109: LD_INT 32
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: LD_INT 30
60118: PUSH
60119: LD_INT 4
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: PUSH
60126: LD_INT 30
60128: PUSH
60129: LD_INT 5
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PUSH
60136: EMPTY
60137: LIST
60138: LIST
60139: LIST
60140: LIST
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: LIST
60146: PPUSH
60147: CALL_OW 72
60151: ST_TO_ADDR
60152: GO 60376
60154: LD_INT 2
60156: DOUBLE
60157: EQUAL
60158: IFTRUE 60162
60160: GO 60224
60162: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60163: LD_ADDR_VAR 0 12
60167: PUSH
60168: LD_VAR 0 18
60172: PPUSH
60173: LD_INT 22
60175: PUSH
60176: LD_VAR 0 16
60180: PUSH
60181: EMPTY
60182: LIST
60183: LIST
60184: PUSH
60185: LD_INT 2
60187: PUSH
60188: LD_INT 30
60190: PUSH
60191: LD_INT 0
60193: PUSH
60194: EMPTY
60195: LIST
60196: LIST
60197: PUSH
60198: LD_INT 30
60200: PUSH
60201: LD_INT 1
60203: PUSH
60204: EMPTY
60205: LIST
60206: LIST
60207: PUSH
60208: EMPTY
60209: LIST
60210: LIST
60211: LIST
60212: PUSH
60213: EMPTY
60214: LIST
60215: LIST
60216: PPUSH
60217: CALL_OW 72
60221: ST_TO_ADDR
60222: GO 60376
60224: LD_INT 3
60226: DOUBLE
60227: EQUAL
60228: IFTRUE 60232
60230: GO 60294
60232: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60233: LD_ADDR_VAR 0 12
60237: PUSH
60238: LD_VAR 0 18
60242: PPUSH
60243: LD_INT 22
60245: PUSH
60246: LD_VAR 0 16
60250: PUSH
60251: EMPTY
60252: LIST
60253: LIST
60254: PUSH
60255: LD_INT 2
60257: PUSH
60258: LD_INT 30
60260: PUSH
60261: LD_INT 2
60263: PUSH
60264: EMPTY
60265: LIST
60266: LIST
60267: PUSH
60268: LD_INT 30
60270: PUSH
60271: LD_INT 3
60273: PUSH
60274: EMPTY
60275: LIST
60276: LIST
60277: PUSH
60278: EMPTY
60279: LIST
60280: LIST
60281: LIST
60282: PUSH
60283: EMPTY
60284: LIST
60285: LIST
60286: PPUSH
60287: CALL_OW 72
60291: ST_TO_ADDR
60292: GO 60376
60294: LD_INT 4
60296: DOUBLE
60297: EQUAL
60298: IFTRUE 60302
60300: GO 60375
60302: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60303: LD_ADDR_VAR 0 12
60307: PUSH
60308: LD_VAR 0 18
60312: PPUSH
60313: LD_INT 22
60315: PUSH
60316: LD_VAR 0 16
60320: PUSH
60321: EMPTY
60322: LIST
60323: LIST
60324: PUSH
60325: LD_INT 2
60327: PUSH
60328: LD_INT 30
60330: PUSH
60331: LD_INT 6
60333: PUSH
60334: EMPTY
60335: LIST
60336: LIST
60337: PUSH
60338: LD_INT 30
60340: PUSH
60341: LD_INT 7
60343: PUSH
60344: EMPTY
60345: LIST
60346: LIST
60347: PUSH
60348: LD_INT 30
60350: PUSH
60351: LD_INT 8
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: PUSH
60358: EMPTY
60359: LIST
60360: LIST
60361: LIST
60362: LIST
60363: PUSH
60364: EMPTY
60365: LIST
60366: LIST
60367: PPUSH
60368: CALL_OW 72
60372: ST_TO_ADDR
60373: GO 60376
60375: POP
// if i = 1 then
60376: LD_VAR 0 8
60380: PUSH
60381: LD_INT 1
60383: EQUAL
60384: IFFALSE 60495
// begin tmp := [ ] ;
60386: LD_ADDR_VAR 0 19
60390: PUSH
60391: EMPTY
60392: ST_TO_ADDR
// for j in f do
60393: LD_ADDR_VAR 0 9
60397: PUSH
60398: LD_VAR 0 12
60402: PUSH
60403: FOR_IN
60404: IFFALSE 60477
// if GetBType ( j ) = b_bunker then
60406: LD_VAR 0 9
60410: PPUSH
60411: CALL_OW 266
60415: PUSH
60416: LD_INT 32
60418: EQUAL
60419: IFFALSE 60446
// tmp := Insert ( tmp , 1 , j ) else
60421: LD_ADDR_VAR 0 19
60425: PUSH
60426: LD_VAR 0 19
60430: PPUSH
60431: LD_INT 1
60433: PPUSH
60434: LD_VAR 0 9
60438: PPUSH
60439: CALL_OW 2
60443: ST_TO_ADDR
60444: GO 60475
// tmp := Insert ( tmp , tmp + 1 , j ) ;
60446: LD_ADDR_VAR 0 19
60450: PUSH
60451: LD_VAR 0 19
60455: PPUSH
60456: LD_VAR 0 19
60460: PUSH
60461: LD_INT 1
60463: PLUS
60464: PPUSH
60465: LD_VAR 0 9
60469: PPUSH
60470: CALL_OW 2
60474: ST_TO_ADDR
60475: GO 60403
60477: POP
60478: POP
// if tmp then
60479: LD_VAR 0 19
60483: IFFALSE 60495
// f := tmp ;
60485: LD_ADDR_VAR 0 12
60489: PUSH
60490: LD_VAR 0 19
60494: ST_TO_ADDR
// end ; x := personel [ i ] ;
60495: LD_ADDR_VAR 0 13
60499: PUSH
60500: LD_VAR 0 6
60504: PUSH
60505: LD_VAR 0 8
60509: ARRAY
60510: ST_TO_ADDR
// if x = - 1 then
60511: LD_VAR 0 13
60515: PUSH
60516: LD_INT 1
60518: NEG
60519: EQUAL
60520: IFFALSE 60729
// begin for j in f do
60522: LD_ADDR_VAR 0 9
60526: PUSH
60527: LD_VAR 0 12
60531: PUSH
60532: FOR_IN
60533: IFFALSE 60725
// repeat InitHc ;
60535: CALL_OW 19
// if GetBType ( j ) = b_barracks then
60539: LD_VAR 0 9
60543: PPUSH
60544: CALL_OW 266
60548: PUSH
60549: LD_INT 5
60551: EQUAL
60552: IFFALSE 60622
// begin if UnitsInside ( j ) < 3 then
60554: LD_VAR 0 9
60558: PPUSH
60559: CALL_OW 313
60563: PUSH
60564: LD_INT 3
60566: LESS
60567: IFFALSE 60603
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60569: LD_INT 0
60571: PPUSH
60572: LD_INT 5
60574: PUSH
60575: LD_INT 8
60577: PUSH
60578: LD_INT 9
60580: PUSH
60581: EMPTY
60582: LIST
60583: LIST
60584: LIST
60585: PUSH
60586: LD_VAR 0 17
60590: ARRAY
60591: PPUSH
60592: LD_VAR 0 4
60596: PPUSH
60597: CALL_OW 380
60601: GO 60620
// PrepareHuman ( false , i , skill ) ;
60603: LD_INT 0
60605: PPUSH
60606: LD_VAR 0 8
60610: PPUSH
60611: LD_VAR 0 4
60615: PPUSH
60616: CALL_OW 380
// end else
60620: GO 60639
// PrepareHuman ( false , i , skill ) ;
60622: LD_INT 0
60624: PPUSH
60625: LD_VAR 0 8
60629: PPUSH
60630: LD_VAR 0 4
60634: PPUSH
60635: CALL_OW 380
// un := CreateHuman ;
60639: LD_ADDR_VAR 0 14
60643: PUSH
60644: CALL_OW 44
60648: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60649: LD_ADDR_VAR 0 7
60653: PUSH
60654: LD_VAR 0 7
60658: PPUSH
60659: LD_INT 1
60661: PPUSH
60662: LD_VAR 0 14
60666: PPUSH
60667: CALL_OW 2
60671: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
60672: LD_VAR 0 14
60676: PPUSH
60677: LD_VAR 0 9
60681: PPUSH
60682: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
60686: LD_VAR 0 9
60690: PPUSH
60691: CALL_OW 313
60695: PUSH
60696: LD_INT 6
60698: EQUAL
60699: PUSH
60700: LD_VAR 0 9
60704: PPUSH
60705: CALL_OW 266
60709: PUSH
60710: LD_INT 32
60712: PUSH
60713: LD_INT 31
60715: PUSH
60716: EMPTY
60717: LIST
60718: LIST
60719: IN
60720: OR
60721: IFFALSE 60535
60723: GO 60532
60725: POP
60726: POP
// end else
60727: GO 61109
// for j = 1 to x do
60729: LD_ADDR_VAR 0 9
60733: PUSH
60734: DOUBLE
60735: LD_INT 1
60737: DEC
60738: ST_TO_ADDR
60739: LD_VAR 0 13
60743: PUSH
60744: FOR_TO
60745: IFFALSE 61107
// begin InitHc ;
60747: CALL_OW 19
// if not f then
60751: LD_VAR 0 12
60755: NOT
60756: IFFALSE 60845
// begin PrepareHuman ( false , i , skill ) ;
60758: LD_INT 0
60760: PPUSH
60761: LD_VAR 0 8
60765: PPUSH
60766: LD_VAR 0 4
60770: PPUSH
60771: CALL_OW 380
// un := CreateHuman ;
60775: LD_ADDR_VAR 0 14
60779: PUSH
60780: CALL_OW 44
60784: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
60785: LD_ADDR_VAR 0 7
60789: PUSH
60790: LD_VAR 0 7
60794: PPUSH
60795: LD_INT 1
60797: PPUSH
60798: LD_VAR 0 14
60802: PPUSH
60803: CALL_OW 2
60807: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
60808: LD_VAR 0 14
60812: PPUSH
60813: LD_VAR 0 1
60817: PPUSH
60818: CALL_OW 250
60822: PPUSH
60823: LD_VAR 0 1
60827: PPUSH
60828: CALL_OW 251
60832: PPUSH
60833: LD_INT 10
60835: PPUSH
60836: LD_INT 0
60838: PPUSH
60839: CALL_OW 50
// continue ;
60843: GO 60744
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
60845: LD_VAR 0 12
60849: PUSH
60850: LD_INT 1
60852: ARRAY
60853: PPUSH
60854: CALL_OW 313
60858: PUSH
60859: LD_VAR 0 12
60863: PUSH
60864: LD_INT 1
60866: ARRAY
60867: PPUSH
60868: CALL_OW 266
60872: PUSH
60873: LD_INT 32
60875: PUSH
60876: LD_INT 31
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: IN
60883: AND
60884: PUSH
60885: LD_VAR 0 12
60889: PUSH
60890: LD_INT 1
60892: ARRAY
60893: PPUSH
60894: CALL_OW 313
60898: PUSH
60899: LD_INT 6
60901: EQUAL
60902: OR
60903: IFFALSE 60923
// f := Delete ( f , 1 ) ;
60905: LD_ADDR_VAR 0 12
60909: PUSH
60910: LD_VAR 0 12
60914: PPUSH
60915: LD_INT 1
60917: PPUSH
60918: CALL_OW 3
60922: ST_TO_ADDR
// if not f then
60923: LD_VAR 0 12
60927: NOT
60928: IFFALSE 60946
// begin x := x + 2 ;
60930: LD_ADDR_VAR 0 13
60934: PUSH
60935: LD_VAR 0 13
60939: PUSH
60940: LD_INT 2
60942: PLUS
60943: ST_TO_ADDR
// continue ;
60944: GO 60744
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
60946: LD_VAR 0 12
60950: PUSH
60951: LD_INT 1
60953: ARRAY
60954: PPUSH
60955: CALL_OW 266
60959: PUSH
60960: LD_INT 5
60962: EQUAL
60963: IFFALSE 61037
// begin if UnitsInside ( f [ 1 ] ) < 3 then
60965: LD_VAR 0 12
60969: PUSH
60970: LD_INT 1
60972: ARRAY
60973: PPUSH
60974: CALL_OW 313
60978: PUSH
60979: LD_INT 3
60981: LESS
60982: IFFALSE 61018
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
60984: LD_INT 0
60986: PPUSH
60987: LD_INT 5
60989: PUSH
60990: LD_INT 8
60992: PUSH
60993: LD_INT 9
60995: PUSH
60996: EMPTY
60997: LIST
60998: LIST
60999: LIST
61000: PUSH
61001: LD_VAR 0 17
61005: ARRAY
61006: PPUSH
61007: LD_VAR 0 4
61011: PPUSH
61012: CALL_OW 380
61016: GO 61035
// PrepareHuman ( false , i , skill ) ;
61018: LD_INT 0
61020: PPUSH
61021: LD_VAR 0 8
61025: PPUSH
61026: LD_VAR 0 4
61030: PPUSH
61031: CALL_OW 380
// end else
61035: GO 61054
// PrepareHuman ( false , i , skill ) ;
61037: LD_INT 0
61039: PPUSH
61040: LD_VAR 0 8
61044: PPUSH
61045: LD_VAR 0 4
61049: PPUSH
61050: CALL_OW 380
// un := CreateHuman ;
61054: LD_ADDR_VAR 0 14
61058: PUSH
61059: CALL_OW 44
61063: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61064: LD_ADDR_VAR 0 7
61068: PUSH
61069: LD_VAR 0 7
61073: PPUSH
61074: LD_INT 1
61076: PPUSH
61077: LD_VAR 0 14
61081: PPUSH
61082: CALL_OW 2
61086: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61087: LD_VAR 0 14
61091: PPUSH
61092: LD_VAR 0 12
61096: PUSH
61097: LD_INT 1
61099: ARRAY
61100: PPUSH
61101: CALL_OW 52
// end ;
61105: GO 60744
61107: POP
61108: POP
// end ;
61109: GO 60046
61111: POP
61112: POP
// result := result ^ buildings ;
61113: LD_ADDR_VAR 0 7
61117: PUSH
61118: LD_VAR 0 7
61122: PUSH
61123: LD_VAR 0 18
61127: ADD
61128: ST_TO_ADDR
// end else
61129: GO 61272
// begin for i = 1 to personel do
61131: LD_ADDR_VAR 0 8
61135: PUSH
61136: DOUBLE
61137: LD_INT 1
61139: DEC
61140: ST_TO_ADDR
61141: LD_VAR 0 6
61145: PUSH
61146: FOR_TO
61147: IFFALSE 61270
// begin if i > 4 then
61149: LD_VAR 0 8
61153: PUSH
61154: LD_INT 4
61156: GREATER
61157: IFFALSE 61161
// break ;
61159: GO 61270
// x := personel [ i ] ;
61161: LD_ADDR_VAR 0 13
61165: PUSH
61166: LD_VAR 0 6
61170: PUSH
61171: LD_VAR 0 8
61175: ARRAY
61176: ST_TO_ADDR
// if x = - 1 then
61177: LD_VAR 0 13
61181: PUSH
61182: LD_INT 1
61184: NEG
61185: EQUAL
61186: IFFALSE 61190
// continue ;
61188: GO 61146
// PrepareHuman ( false , i , skill ) ;
61190: LD_INT 0
61192: PPUSH
61193: LD_VAR 0 8
61197: PPUSH
61198: LD_VAR 0 4
61202: PPUSH
61203: CALL_OW 380
// un := CreateHuman ;
61207: LD_ADDR_VAR 0 14
61211: PUSH
61212: CALL_OW 44
61216: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61217: LD_VAR 0 14
61221: PPUSH
61222: LD_VAR 0 1
61226: PPUSH
61227: CALL_OW 250
61231: PPUSH
61232: LD_VAR 0 1
61236: PPUSH
61237: CALL_OW 251
61241: PPUSH
61242: LD_INT 10
61244: PPUSH
61245: LD_INT 0
61247: PPUSH
61248: CALL_OW 50
// result := result ^ un ;
61252: LD_ADDR_VAR 0 7
61256: PUSH
61257: LD_VAR 0 7
61261: PUSH
61262: LD_VAR 0 14
61266: ADD
61267: ST_TO_ADDR
// end ;
61268: GO 61146
61270: POP
61271: POP
// end ; end ;
61272: LD_VAR 0 7
61276: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61277: LD_INT 0
61279: PPUSH
61280: PPUSH
61281: PPUSH
61282: PPUSH
61283: PPUSH
61284: PPUSH
61285: PPUSH
61286: PPUSH
61287: PPUSH
61288: PPUSH
61289: PPUSH
61290: PPUSH
61291: PPUSH
61292: PPUSH
61293: PPUSH
61294: PPUSH
// result := false ;
61295: LD_ADDR_VAR 0 3
61299: PUSH
61300: LD_INT 0
61302: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61303: LD_VAR 0 1
61307: NOT
61308: PUSH
61309: LD_VAR 0 1
61313: PPUSH
61314: CALL_OW 266
61318: PUSH
61319: LD_INT 32
61321: PUSH
61322: LD_INT 33
61324: PUSH
61325: EMPTY
61326: LIST
61327: LIST
61328: IN
61329: NOT
61330: OR
61331: IFFALSE 61335
// exit ;
61333: GO 62444
// nat := GetNation ( tower ) ;
61335: LD_ADDR_VAR 0 12
61339: PUSH
61340: LD_VAR 0 1
61344: PPUSH
61345: CALL_OW 248
61349: ST_TO_ADDR
// side := GetSide ( tower ) ;
61350: LD_ADDR_VAR 0 16
61354: PUSH
61355: LD_VAR 0 1
61359: PPUSH
61360: CALL_OW 255
61364: ST_TO_ADDR
// x := GetX ( tower ) ;
61365: LD_ADDR_VAR 0 10
61369: PUSH
61370: LD_VAR 0 1
61374: PPUSH
61375: CALL_OW 250
61379: ST_TO_ADDR
// y := GetY ( tower ) ;
61380: LD_ADDR_VAR 0 11
61384: PUSH
61385: LD_VAR 0 1
61389: PPUSH
61390: CALL_OW 251
61394: ST_TO_ADDR
// if not x or not y then
61395: LD_VAR 0 10
61399: NOT
61400: PUSH
61401: LD_VAR 0 11
61405: NOT
61406: OR
61407: IFFALSE 61411
// exit ;
61409: GO 62444
// weapon := 0 ;
61411: LD_ADDR_VAR 0 18
61415: PUSH
61416: LD_INT 0
61418: ST_TO_ADDR
// fac_list := [ ] ;
61419: LD_ADDR_VAR 0 17
61423: PUSH
61424: EMPTY
61425: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
61426: LD_ADDR_VAR 0 6
61430: PUSH
61431: LD_VAR 0 1
61435: PPUSH
61436: CALL_OW 274
61440: PPUSH
61441: LD_VAR 0 2
61445: PPUSH
61446: LD_INT 0
61448: PPUSH
61449: CALL 59015 0 3
61453: PPUSH
61454: LD_INT 30
61456: PUSH
61457: LD_INT 3
61459: PUSH
61460: EMPTY
61461: LIST
61462: LIST
61463: PPUSH
61464: CALL_OW 72
61468: ST_TO_ADDR
// if not factories then
61469: LD_VAR 0 6
61473: NOT
61474: IFFALSE 61478
// exit ;
61476: GO 62444
// for i in factories do
61478: LD_ADDR_VAR 0 8
61482: PUSH
61483: LD_VAR 0 6
61487: PUSH
61488: FOR_IN
61489: IFFALSE 61514
// fac_list := fac_list union AvailableWeaponList ( i ) ;
61491: LD_ADDR_VAR 0 17
61495: PUSH
61496: LD_VAR 0 17
61500: PUSH
61501: LD_VAR 0 8
61505: PPUSH
61506: CALL_OW 478
61510: UNION
61511: ST_TO_ADDR
61512: GO 61488
61514: POP
61515: POP
// if not fac_list then
61516: LD_VAR 0 17
61520: NOT
61521: IFFALSE 61525
// exit ;
61523: GO 62444
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
61525: LD_ADDR_VAR 0 5
61529: PUSH
61530: LD_INT 4
61532: PUSH
61533: LD_INT 5
61535: PUSH
61536: LD_INT 9
61538: PUSH
61539: LD_INT 10
61541: PUSH
61542: LD_INT 6
61544: PUSH
61545: LD_INT 7
61547: PUSH
61548: LD_INT 11
61550: PUSH
61551: EMPTY
61552: LIST
61553: LIST
61554: LIST
61555: LIST
61556: LIST
61557: LIST
61558: LIST
61559: PUSH
61560: LD_INT 27
61562: PUSH
61563: LD_INT 28
61565: PUSH
61566: LD_INT 26
61568: PUSH
61569: LD_INT 30
61571: PUSH
61572: EMPTY
61573: LIST
61574: LIST
61575: LIST
61576: LIST
61577: PUSH
61578: LD_INT 43
61580: PUSH
61581: LD_INT 44
61583: PUSH
61584: LD_INT 46
61586: PUSH
61587: LD_INT 45
61589: PUSH
61590: LD_INT 47
61592: PUSH
61593: LD_INT 49
61595: PUSH
61596: EMPTY
61597: LIST
61598: LIST
61599: LIST
61600: LIST
61601: LIST
61602: LIST
61603: PUSH
61604: EMPTY
61605: LIST
61606: LIST
61607: LIST
61608: PUSH
61609: LD_VAR 0 12
61613: ARRAY
61614: ST_TO_ADDR
// list := list isect fac_list ;
61615: LD_ADDR_VAR 0 5
61619: PUSH
61620: LD_VAR 0 5
61624: PUSH
61625: LD_VAR 0 17
61629: ISECT
61630: ST_TO_ADDR
// if not list then
61631: LD_VAR 0 5
61635: NOT
61636: IFFALSE 61640
// exit ;
61638: GO 62444
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
61640: LD_VAR 0 12
61644: PUSH
61645: LD_INT 3
61647: EQUAL
61648: PUSH
61649: LD_INT 49
61651: PUSH
61652: LD_VAR 0 5
61656: IN
61657: AND
61658: PUSH
61659: LD_INT 31
61661: PPUSH
61662: LD_VAR 0 16
61666: PPUSH
61667: CALL_OW 321
61671: PUSH
61672: LD_INT 2
61674: EQUAL
61675: AND
61676: IFFALSE 61736
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
61678: LD_INT 22
61680: PUSH
61681: LD_VAR 0 16
61685: PUSH
61686: EMPTY
61687: LIST
61688: LIST
61689: PUSH
61690: LD_INT 35
61692: PUSH
61693: LD_INT 49
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PUSH
61700: LD_INT 91
61702: PUSH
61703: LD_VAR 0 1
61707: PUSH
61708: LD_INT 10
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: LIST
61715: PUSH
61716: EMPTY
61717: LIST
61718: LIST
61719: LIST
61720: PPUSH
61721: CALL_OW 69
61725: NOT
61726: IFFALSE 61736
// weapon := ru_time_lapser ;
61728: LD_ADDR_VAR 0 18
61732: PUSH
61733: LD_INT 49
61735: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
61736: LD_VAR 0 12
61740: PUSH
61741: LD_INT 1
61743: PUSH
61744: LD_INT 2
61746: PUSH
61747: EMPTY
61748: LIST
61749: LIST
61750: IN
61751: PUSH
61752: LD_INT 11
61754: PUSH
61755: LD_VAR 0 5
61759: IN
61760: PUSH
61761: LD_INT 30
61763: PUSH
61764: LD_VAR 0 5
61768: IN
61769: OR
61770: AND
61771: PUSH
61772: LD_INT 6
61774: PPUSH
61775: LD_VAR 0 16
61779: PPUSH
61780: CALL_OW 321
61784: PUSH
61785: LD_INT 2
61787: EQUAL
61788: AND
61789: IFFALSE 61954
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
61791: LD_INT 22
61793: PUSH
61794: LD_VAR 0 16
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: LD_INT 2
61805: PUSH
61806: LD_INT 35
61808: PUSH
61809: LD_INT 11
61811: PUSH
61812: EMPTY
61813: LIST
61814: LIST
61815: PUSH
61816: LD_INT 35
61818: PUSH
61819: LD_INT 30
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: PUSH
61826: EMPTY
61827: LIST
61828: LIST
61829: LIST
61830: PUSH
61831: LD_INT 91
61833: PUSH
61834: LD_VAR 0 1
61838: PUSH
61839: LD_INT 18
61841: PUSH
61842: EMPTY
61843: LIST
61844: LIST
61845: LIST
61846: PUSH
61847: EMPTY
61848: LIST
61849: LIST
61850: LIST
61851: PPUSH
61852: CALL_OW 69
61856: NOT
61857: PUSH
61858: LD_INT 22
61860: PUSH
61861: LD_VAR 0 16
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: PUSH
61870: LD_INT 2
61872: PUSH
61873: LD_INT 30
61875: PUSH
61876: LD_INT 32
61878: PUSH
61879: EMPTY
61880: LIST
61881: LIST
61882: PUSH
61883: LD_INT 30
61885: PUSH
61886: LD_INT 33
61888: PUSH
61889: EMPTY
61890: LIST
61891: LIST
61892: PUSH
61893: EMPTY
61894: LIST
61895: LIST
61896: LIST
61897: PUSH
61898: LD_INT 91
61900: PUSH
61901: LD_VAR 0 1
61905: PUSH
61906: LD_INT 12
61908: PUSH
61909: EMPTY
61910: LIST
61911: LIST
61912: LIST
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: LIST
61918: PUSH
61919: EMPTY
61920: LIST
61921: PPUSH
61922: CALL_OW 69
61926: PUSH
61927: LD_INT 2
61929: GREATER
61930: AND
61931: IFFALSE 61954
// weapon := [ us_radar , ar_radar ] [ nat ] ;
61933: LD_ADDR_VAR 0 18
61937: PUSH
61938: LD_INT 11
61940: PUSH
61941: LD_INT 30
61943: PUSH
61944: EMPTY
61945: LIST
61946: LIST
61947: PUSH
61948: LD_VAR 0 12
61952: ARRAY
61953: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
61954: LD_VAR 0 18
61958: NOT
61959: PUSH
61960: LD_INT 40
61962: PPUSH
61963: LD_VAR 0 16
61967: PPUSH
61968: CALL_OW 321
61972: PUSH
61973: LD_INT 2
61975: EQUAL
61976: AND
61977: PUSH
61978: LD_INT 7
61980: PUSH
61981: LD_VAR 0 5
61985: IN
61986: PUSH
61987: LD_INT 28
61989: PUSH
61990: LD_VAR 0 5
61994: IN
61995: OR
61996: PUSH
61997: LD_INT 45
61999: PUSH
62000: LD_VAR 0 5
62004: IN
62005: OR
62006: AND
62007: IFFALSE 62261
// begin hex := GetHexInfo ( x , y ) ;
62009: LD_ADDR_VAR 0 4
62013: PUSH
62014: LD_VAR 0 10
62018: PPUSH
62019: LD_VAR 0 11
62023: PPUSH
62024: CALL_OW 546
62028: ST_TO_ADDR
// if hex [ 1 ] then
62029: LD_VAR 0 4
62033: PUSH
62034: LD_INT 1
62036: ARRAY
62037: IFFALSE 62041
// exit ;
62039: GO 62444
// height := hex [ 2 ] ;
62041: LD_ADDR_VAR 0 15
62045: PUSH
62046: LD_VAR 0 4
62050: PUSH
62051: LD_INT 2
62053: ARRAY
62054: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62055: LD_ADDR_VAR 0 14
62059: PUSH
62060: LD_INT 0
62062: PUSH
62063: LD_INT 2
62065: PUSH
62066: LD_INT 3
62068: PUSH
62069: LD_INT 5
62071: PUSH
62072: EMPTY
62073: LIST
62074: LIST
62075: LIST
62076: LIST
62077: ST_TO_ADDR
// for i in tmp do
62078: LD_ADDR_VAR 0 8
62082: PUSH
62083: LD_VAR 0 14
62087: PUSH
62088: FOR_IN
62089: IFFALSE 62259
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62091: LD_ADDR_VAR 0 9
62095: PUSH
62096: LD_VAR 0 10
62100: PPUSH
62101: LD_VAR 0 8
62105: PPUSH
62106: LD_INT 5
62108: PPUSH
62109: CALL_OW 272
62113: PUSH
62114: LD_VAR 0 11
62118: PPUSH
62119: LD_VAR 0 8
62123: PPUSH
62124: LD_INT 5
62126: PPUSH
62127: CALL_OW 273
62131: PUSH
62132: EMPTY
62133: LIST
62134: LIST
62135: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62136: LD_VAR 0 9
62140: PUSH
62141: LD_INT 1
62143: ARRAY
62144: PPUSH
62145: LD_VAR 0 9
62149: PUSH
62150: LD_INT 2
62152: ARRAY
62153: PPUSH
62154: CALL_OW 488
62158: IFFALSE 62257
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62160: LD_ADDR_VAR 0 4
62164: PUSH
62165: LD_VAR 0 9
62169: PUSH
62170: LD_INT 1
62172: ARRAY
62173: PPUSH
62174: LD_VAR 0 9
62178: PUSH
62179: LD_INT 2
62181: ARRAY
62182: PPUSH
62183: CALL_OW 546
62187: ST_TO_ADDR
// if hex [ 1 ] then
62188: LD_VAR 0 4
62192: PUSH
62193: LD_INT 1
62195: ARRAY
62196: IFFALSE 62200
// continue ;
62198: GO 62088
// h := hex [ 2 ] ;
62200: LD_ADDR_VAR 0 13
62204: PUSH
62205: LD_VAR 0 4
62209: PUSH
62210: LD_INT 2
62212: ARRAY
62213: ST_TO_ADDR
// if h + 7 < height then
62214: LD_VAR 0 13
62218: PUSH
62219: LD_INT 7
62221: PLUS
62222: PUSH
62223: LD_VAR 0 15
62227: LESS
62228: IFFALSE 62257
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62230: LD_ADDR_VAR 0 18
62234: PUSH
62235: LD_INT 7
62237: PUSH
62238: LD_INT 28
62240: PUSH
62241: LD_INT 45
62243: PUSH
62244: EMPTY
62245: LIST
62246: LIST
62247: LIST
62248: PUSH
62249: LD_VAR 0 12
62253: ARRAY
62254: ST_TO_ADDR
// break ;
62255: GO 62259
// end ; end ; end ;
62257: GO 62088
62259: POP
62260: POP
// end ; if not weapon then
62261: LD_VAR 0 18
62265: NOT
62266: IFFALSE 62326
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62268: LD_ADDR_VAR 0 5
62272: PUSH
62273: LD_VAR 0 5
62277: PUSH
62278: LD_INT 11
62280: PUSH
62281: LD_INT 30
62283: PUSH
62284: LD_INT 49
62286: PUSH
62287: EMPTY
62288: LIST
62289: LIST
62290: LIST
62291: DIFF
62292: ST_TO_ADDR
// if not list then
62293: LD_VAR 0 5
62297: NOT
62298: IFFALSE 62302
// exit ;
62300: GO 62444
// weapon := list [ rand ( 1 , list ) ] ;
62302: LD_ADDR_VAR 0 18
62306: PUSH
62307: LD_VAR 0 5
62311: PUSH
62312: LD_INT 1
62314: PPUSH
62315: LD_VAR 0 5
62319: PPUSH
62320: CALL_OW 12
62324: ARRAY
62325: ST_TO_ADDR
// end ; if weapon then
62326: LD_VAR 0 18
62330: IFFALSE 62444
// begin tmp := CostOfWeapon ( weapon ) ;
62332: LD_ADDR_VAR 0 14
62336: PUSH
62337: LD_VAR 0 18
62341: PPUSH
62342: CALL_OW 451
62346: ST_TO_ADDR
// j := GetBase ( tower ) ;
62347: LD_ADDR_VAR 0 9
62351: PUSH
62352: LD_VAR 0 1
62356: PPUSH
62357: CALL_OW 274
62361: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
62362: LD_VAR 0 9
62366: PPUSH
62367: LD_INT 1
62369: PPUSH
62370: CALL_OW 275
62374: PUSH
62375: LD_VAR 0 14
62379: PUSH
62380: LD_INT 1
62382: ARRAY
62383: GREATEREQUAL
62384: PUSH
62385: LD_VAR 0 9
62389: PPUSH
62390: LD_INT 2
62392: PPUSH
62393: CALL_OW 275
62397: PUSH
62398: LD_VAR 0 14
62402: PUSH
62403: LD_INT 2
62405: ARRAY
62406: GREATEREQUAL
62407: AND
62408: PUSH
62409: LD_VAR 0 9
62413: PPUSH
62414: LD_INT 3
62416: PPUSH
62417: CALL_OW 275
62421: PUSH
62422: LD_VAR 0 14
62426: PUSH
62427: LD_INT 3
62429: ARRAY
62430: GREATEREQUAL
62431: AND
62432: IFFALSE 62444
// result := weapon ;
62434: LD_ADDR_VAR 0 3
62438: PUSH
62439: LD_VAR 0 18
62443: ST_TO_ADDR
// end ; end ;
62444: LD_VAR 0 3
62448: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
62449: LD_INT 0
62451: PPUSH
62452: PPUSH
// result := true ;
62453: LD_ADDR_VAR 0 3
62457: PUSH
62458: LD_INT 1
62460: ST_TO_ADDR
// if array1 = array2 then
62461: LD_VAR 0 1
62465: PUSH
62466: LD_VAR 0 2
62470: EQUAL
62471: IFFALSE 62531
// begin for i = 1 to array1 do
62473: LD_ADDR_VAR 0 4
62477: PUSH
62478: DOUBLE
62479: LD_INT 1
62481: DEC
62482: ST_TO_ADDR
62483: LD_VAR 0 1
62487: PUSH
62488: FOR_TO
62489: IFFALSE 62527
// if array1 [ i ] <> array2 [ i ] then
62491: LD_VAR 0 1
62495: PUSH
62496: LD_VAR 0 4
62500: ARRAY
62501: PUSH
62502: LD_VAR 0 2
62506: PUSH
62507: LD_VAR 0 4
62511: ARRAY
62512: NONEQUAL
62513: IFFALSE 62525
// begin result := false ;
62515: LD_ADDR_VAR 0 3
62519: PUSH
62520: LD_INT 0
62522: ST_TO_ADDR
// break ;
62523: GO 62527
// end ;
62525: GO 62488
62527: POP
62528: POP
// end else
62529: GO 62539
// result := false ;
62531: LD_ADDR_VAR 0 3
62535: PUSH
62536: LD_INT 0
62538: ST_TO_ADDR
// end ;
62539: LD_VAR 0 3
62543: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
62544: LD_INT 0
62546: PPUSH
62547: PPUSH
// if not array1 or not array2 then
62548: LD_VAR 0 1
62552: NOT
62553: PUSH
62554: LD_VAR 0 2
62558: NOT
62559: OR
62560: IFFALSE 62564
// exit ;
62562: GO 62628
// result := true ;
62564: LD_ADDR_VAR 0 3
62568: PUSH
62569: LD_INT 1
62571: ST_TO_ADDR
// for i = 1 to array1 do
62572: LD_ADDR_VAR 0 4
62576: PUSH
62577: DOUBLE
62578: LD_INT 1
62580: DEC
62581: ST_TO_ADDR
62582: LD_VAR 0 1
62586: PUSH
62587: FOR_TO
62588: IFFALSE 62626
// if array1 [ i ] <> array2 [ i ] then
62590: LD_VAR 0 1
62594: PUSH
62595: LD_VAR 0 4
62599: ARRAY
62600: PUSH
62601: LD_VAR 0 2
62605: PUSH
62606: LD_VAR 0 4
62610: ARRAY
62611: NONEQUAL
62612: IFFALSE 62624
// begin result := false ;
62614: LD_ADDR_VAR 0 3
62618: PUSH
62619: LD_INT 0
62621: ST_TO_ADDR
// break ;
62622: GO 62626
// end ;
62624: GO 62587
62626: POP
62627: POP
// end ;
62628: LD_VAR 0 3
62632: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
62633: LD_INT 0
62635: PPUSH
62636: PPUSH
62637: PPUSH
// pom := GetBase ( fac ) ;
62638: LD_ADDR_VAR 0 5
62642: PUSH
62643: LD_VAR 0 1
62647: PPUSH
62648: CALL_OW 274
62652: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
62653: LD_ADDR_VAR 0 4
62657: PUSH
62658: LD_VAR 0 2
62662: PUSH
62663: LD_INT 1
62665: ARRAY
62666: PPUSH
62667: LD_VAR 0 2
62671: PUSH
62672: LD_INT 2
62674: ARRAY
62675: PPUSH
62676: LD_VAR 0 2
62680: PUSH
62681: LD_INT 3
62683: ARRAY
62684: PPUSH
62685: LD_VAR 0 2
62689: PUSH
62690: LD_INT 4
62692: ARRAY
62693: PPUSH
62694: CALL_OW 449
62698: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62699: LD_ADDR_VAR 0 3
62703: PUSH
62704: LD_VAR 0 5
62708: PPUSH
62709: LD_INT 1
62711: PPUSH
62712: CALL_OW 275
62716: PUSH
62717: LD_VAR 0 4
62721: PUSH
62722: LD_INT 1
62724: ARRAY
62725: GREATEREQUAL
62726: PUSH
62727: LD_VAR 0 5
62731: PPUSH
62732: LD_INT 2
62734: PPUSH
62735: CALL_OW 275
62739: PUSH
62740: LD_VAR 0 4
62744: PUSH
62745: LD_INT 2
62747: ARRAY
62748: GREATEREQUAL
62749: AND
62750: PUSH
62751: LD_VAR 0 5
62755: PPUSH
62756: LD_INT 3
62758: PPUSH
62759: CALL_OW 275
62763: PUSH
62764: LD_VAR 0 4
62768: PUSH
62769: LD_INT 3
62771: ARRAY
62772: GREATEREQUAL
62773: AND
62774: ST_TO_ADDR
// end ;
62775: LD_VAR 0 3
62779: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
62780: LD_INT 0
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
// pom := GetBase ( building ) ;
62786: LD_ADDR_VAR 0 3
62790: PUSH
62791: LD_VAR 0 1
62795: PPUSH
62796: CALL_OW 274
62800: ST_TO_ADDR
// if not pom then
62801: LD_VAR 0 3
62805: NOT
62806: IFFALSE 62810
// exit ;
62808: GO 62980
// btype := GetBType ( building ) ;
62810: LD_ADDR_VAR 0 5
62814: PUSH
62815: LD_VAR 0 1
62819: PPUSH
62820: CALL_OW 266
62824: ST_TO_ADDR
// if btype = b_armoury then
62825: LD_VAR 0 5
62829: PUSH
62830: LD_INT 4
62832: EQUAL
62833: IFFALSE 62843
// btype := b_barracks ;
62835: LD_ADDR_VAR 0 5
62839: PUSH
62840: LD_INT 5
62842: ST_TO_ADDR
// if btype = b_depot then
62843: LD_VAR 0 5
62847: PUSH
62848: LD_INT 0
62850: EQUAL
62851: IFFALSE 62861
// btype := b_warehouse ;
62853: LD_ADDR_VAR 0 5
62857: PUSH
62858: LD_INT 1
62860: ST_TO_ADDR
// if btype = b_workshop then
62861: LD_VAR 0 5
62865: PUSH
62866: LD_INT 2
62868: EQUAL
62869: IFFALSE 62879
// btype := b_factory ;
62871: LD_ADDR_VAR 0 5
62875: PUSH
62876: LD_INT 3
62878: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
62879: LD_ADDR_VAR 0 4
62883: PUSH
62884: LD_VAR 0 5
62888: PPUSH
62889: LD_VAR 0 1
62893: PPUSH
62894: CALL_OW 248
62898: PPUSH
62899: CALL_OW 450
62903: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
62904: LD_ADDR_VAR 0 2
62908: PUSH
62909: LD_VAR 0 3
62913: PPUSH
62914: LD_INT 1
62916: PPUSH
62917: CALL_OW 275
62921: PUSH
62922: LD_VAR 0 4
62926: PUSH
62927: LD_INT 1
62929: ARRAY
62930: GREATEREQUAL
62931: PUSH
62932: LD_VAR 0 3
62936: PPUSH
62937: LD_INT 2
62939: PPUSH
62940: CALL_OW 275
62944: PUSH
62945: LD_VAR 0 4
62949: PUSH
62950: LD_INT 2
62952: ARRAY
62953: GREATEREQUAL
62954: AND
62955: PUSH
62956: LD_VAR 0 3
62960: PPUSH
62961: LD_INT 3
62963: PPUSH
62964: CALL_OW 275
62968: PUSH
62969: LD_VAR 0 4
62973: PUSH
62974: LD_INT 3
62976: ARRAY
62977: GREATEREQUAL
62978: AND
62979: ST_TO_ADDR
// end ;
62980: LD_VAR 0 2
62984: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
62985: LD_INT 0
62987: PPUSH
62988: PPUSH
62989: PPUSH
// pom := GetBase ( building ) ;
62990: LD_ADDR_VAR 0 4
62994: PUSH
62995: LD_VAR 0 1
62999: PPUSH
63000: CALL_OW 274
63004: ST_TO_ADDR
// if not pom then
63005: LD_VAR 0 4
63009: NOT
63010: IFFALSE 63014
// exit ;
63012: GO 63115
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63014: LD_ADDR_VAR 0 5
63018: PUSH
63019: LD_VAR 0 2
63023: PPUSH
63024: LD_VAR 0 1
63028: PPUSH
63029: CALL_OW 248
63033: PPUSH
63034: CALL_OW 450
63038: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63039: LD_ADDR_VAR 0 3
63043: PUSH
63044: LD_VAR 0 4
63048: PPUSH
63049: LD_INT 1
63051: PPUSH
63052: CALL_OW 275
63056: PUSH
63057: LD_VAR 0 5
63061: PUSH
63062: LD_INT 1
63064: ARRAY
63065: GREATEREQUAL
63066: PUSH
63067: LD_VAR 0 4
63071: PPUSH
63072: LD_INT 2
63074: PPUSH
63075: CALL_OW 275
63079: PUSH
63080: LD_VAR 0 5
63084: PUSH
63085: LD_INT 2
63087: ARRAY
63088: GREATEREQUAL
63089: AND
63090: PUSH
63091: LD_VAR 0 4
63095: PPUSH
63096: LD_INT 3
63098: PPUSH
63099: CALL_OW 275
63103: PUSH
63104: LD_VAR 0 5
63108: PUSH
63109: LD_INT 3
63111: ARRAY
63112: GREATEREQUAL
63113: AND
63114: ST_TO_ADDR
// end ;
63115: LD_VAR 0 3
63119: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63120: LD_INT 0
63122: PPUSH
63123: PPUSH
63124: PPUSH
63125: PPUSH
63126: PPUSH
63127: PPUSH
63128: PPUSH
63129: PPUSH
63130: PPUSH
63131: PPUSH
63132: PPUSH
// result := false ;
63133: LD_ADDR_VAR 0 8
63137: PUSH
63138: LD_INT 0
63140: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63141: LD_VAR 0 5
63145: NOT
63146: PUSH
63147: LD_VAR 0 1
63151: NOT
63152: OR
63153: PUSH
63154: LD_VAR 0 2
63158: NOT
63159: OR
63160: PUSH
63161: LD_VAR 0 3
63165: NOT
63166: OR
63167: IFFALSE 63171
// exit ;
63169: GO 63985
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63171: LD_ADDR_VAR 0 14
63175: PUSH
63176: LD_VAR 0 1
63180: PPUSH
63181: LD_VAR 0 2
63185: PPUSH
63186: LD_VAR 0 3
63190: PPUSH
63191: LD_VAR 0 4
63195: PPUSH
63196: LD_VAR 0 5
63200: PUSH
63201: LD_INT 1
63203: ARRAY
63204: PPUSH
63205: CALL_OW 248
63209: PPUSH
63210: LD_INT 0
63212: PPUSH
63213: CALL 65222 0 6
63217: ST_TO_ADDR
// if not hexes then
63218: LD_VAR 0 14
63222: NOT
63223: IFFALSE 63227
// exit ;
63225: GO 63985
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63227: LD_ADDR_VAR 0 17
63231: PUSH
63232: LD_VAR 0 5
63236: PPUSH
63237: LD_INT 22
63239: PUSH
63240: LD_VAR 0 13
63244: PPUSH
63245: CALL_OW 255
63249: PUSH
63250: EMPTY
63251: LIST
63252: LIST
63253: PUSH
63254: LD_INT 2
63256: PUSH
63257: LD_INT 30
63259: PUSH
63260: LD_INT 0
63262: PUSH
63263: EMPTY
63264: LIST
63265: LIST
63266: PUSH
63267: LD_INT 30
63269: PUSH
63270: LD_INT 1
63272: PUSH
63273: EMPTY
63274: LIST
63275: LIST
63276: PUSH
63277: EMPTY
63278: LIST
63279: LIST
63280: LIST
63281: PUSH
63282: EMPTY
63283: LIST
63284: LIST
63285: PPUSH
63286: CALL_OW 72
63290: ST_TO_ADDR
// for i = 1 to hexes do
63291: LD_ADDR_VAR 0 9
63295: PUSH
63296: DOUBLE
63297: LD_INT 1
63299: DEC
63300: ST_TO_ADDR
63301: LD_VAR 0 14
63305: PUSH
63306: FOR_TO
63307: IFFALSE 63983
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63309: LD_ADDR_VAR 0 13
63313: PUSH
63314: LD_VAR 0 14
63318: PUSH
63319: LD_VAR 0 9
63323: ARRAY
63324: PUSH
63325: LD_INT 1
63327: ARRAY
63328: PPUSH
63329: LD_VAR 0 14
63333: PUSH
63334: LD_VAR 0 9
63338: ARRAY
63339: PUSH
63340: LD_INT 2
63342: ARRAY
63343: PPUSH
63344: CALL_OW 428
63348: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63349: LD_VAR 0 14
63353: PUSH
63354: LD_VAR 0 9
63358: ARRAY
63359: PUSH
63360: LD_INT 1
63362: ARRAY
63363: PPUSH
63364: LD_VAR 0 14
63368: PUSH
63369: LD_VAR 0 9
63373: ARRAY
63374: PUSH
63375: LD_INT 2
63377: ARRAY
63378: PPUSH
63379: CALL_OW 351
63383: PUSH
63384: LD_VAR 0 14
63388: PUSH
63389: LD_VAR 0 9
63393: ARRAY
63394: PUSH
63395: LD_INT 1
63397: ARRAY
63398: PPUSH
63399: LD_VAR 0 14
63403: PUSH
63404: LD_VAR 0 9
63408: ARRAY
63409: PUSH
63410: LD_INT 2
63412: ARRAY
63413: PPUSH
63414: CALL_OW 488
63418: NOT
63419: OR
63420: PUSH
63421: LD_VAR 0 13
63425: PPUSH
63426: CALL_OW 247
63430: PUSH
63431: LD_INT 3
63433: EQUAL
63434: OR
63435: IFFALSE 63441
// exit ;
63437: POP
63438: POP
63439: GO 63985
// if not tmp then
63441: LD_VAR 0 13
63445: NOT
63446: IFFALSE 63450
// continue ;
63448: GO 63306
// result := true ;
63450: LD_ADDR_VAR 0 8
63454: PUSH
63455: LD_INT 1
63457: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
63458: LD_VAR 0 6
63462: PUSH
63463: LD_VAR 0 13
63467: PPUSH
63468: CALL_OW 247
63472: PUSH
63473: LD_INT 2
63475: EQUAL
63476: AND
63477: PUSH
63478: LD_VAR 0 13
63482: PPUSH
63483: CALL_OW 263
63487: PUSH
63488: LD_INT 1
63490: EQUAL
63491: AND
63492: IFFALSE 63656
// begin if IsDrivenBy ( tmp ) then
63494: LD_VAR 0 13
63498: PPUSH
63499: CALL_OW 311
63503: IFFALSE 63507
// continue ;
63505: GO 63306
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
63507: LD_VAR 0 6
63511: PPUSH
63512: LD_INT 3
63514: PUSH
63515: LD_INT 60
63517: PUSH
63518: EMPTY
63519: LIST
63520: PUSH
63521: EMPTY
63522: LIST
63523: LIST
63524: PUSH
63525: LD_INT 3
63527: PUSH
63528: LD_INT 55
63530: PUSH
63531: EMPTY
63532: LIST
63533: PUSH
63534: EMPTY
63535: LIST
63536: LIST
63537: PUSH
63538: EMPTY
63539: LIST
63540: LIST
63541: PPUSH
63542: CALL_OW 72
63546: IFFALSE 63654
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
63548: LD_ADDR_VAR 0 18
63552: PUSH
63553: LD_VAR 0 6
63557: PPUSH
63558: LD_INT 3
63560: PUSH
63561: LD_INT 60
63563: PUSH
63564: EMPTY
63565: LIST
63566: PUSH
63567: EMPTY
63568: LIST
63569: LIST
63570: PUSH
63571: LD_INT 3
63573: PUSH
63574: LD_INT 55
63576: PUSH
63577: EMPTY
63578: LIST
63579: PUSH
63580: EMPTY
63581: LIST
63582: LIST
63583: PUSH
63584: EMPTY
63585: LIST
63586: LIST
63587: PPUSH
63588: CALL_OW 72
63592: PUSH
63593: LD_INT 1
63595: ARRAY
63596: ST_TO_ADDR
// if IsInUnit ( driver ) then
63597: LD_VAR 0 18
63601: PPUSH
63602: CALL_OW 310
63606: IFFALSE 63617
// ComExit ( driver ) ;
63608: LD_VAR 0 18
63612: PPUSH
63613: CALL 88406 0 1
// AddComEnterUnit ( driver , tmp ) ;
63617: LD_VAR 0 18
63621: PPUSH
63622: LD_VAR 0 13
63626: PPUSH
63627: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
63631: LD_VAR 0 18
63635: PPUSH
63636: LD_VAR 0 7
63640: PPUSH
63641: CALL_OW 173
// AddComExitVehicle ( driver ) ;
63645: LD_VAR 0 18
63649: PPUSH
63650: CALL_OW 181
// end ; continue ;
63654: GO 63306
// end ; if not cleaners or not tmp in cleaners then
63656: LD_VAR 0 6
63660: NOT
63661: PUSH
63662: LD_VAR 0 13
63666: PUSH
63667: LD_VAR 0 6
63671: IN
63672: NOT
63673: OR
63674: IFFALSE 63981
// begin if dep then
63676: LD_VAR 0 17
63680: IFFALSE 63816
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
63682: LD_ADDR_VAR 0 16
63686: PUSH
63687: LD_VAR 0 17
63691: PUSH
63692: LD_INT 1
63694: ARRAY
63695: PPUSH
63696: CALL_OW 250
63700: PPUSH
63701: LD_VAR 0 17
63705: PUSH
63706: LD_INT 1
63708: ARRAY
63709: PPUSH
63710: CALL_OW 254
63714: PPUSH
63715: LD_INT 5
63717: PPUSH
63718: CALL_OW 272
63722: PUSH
63723: LD_VAR 0 17
63727: PUSH
63728: LD_INT 1
63730: ARRAY
63731: PPUSH
63732: CALL_OW 251
63736: PPUSH
63737: LD_VAR 0 17
63741: PUSH
63742: LD_INT 1
63744: ARRAY
63745: PPUSH
63746: CALL_OW 254
63750: PPUSH
63751: LD_INT 5
63753: PPUSH
63754: CALL_OW 273
63758: PUSH
63759: EMPTY
63760: LIST
63761: LIST
63762: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
63763: LD_VAR 0 16
63767: PUSH
63768: LD_INT 1
63770: ARRAY
63771: PPUSH
63772: LD_VAR 0 16
63776: PUSH
63777: LD_INT 2
63779: ARRAY
63780: PPUSH
63781: CALL_OW 488
63785: IFFALSE 63816
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
63787: LD_VAR 0 13
63791: PPUSH
63792: LD_VAR 0 16
63796: PUSH
63797: LD_INT 1
63799: ARRAY
63800: PPUSH
63801: LD_VAR 0 16
63805: PUSH
63806: LD_INT 2
63808: ARRAY
63809: PPUSH
63810: CALL_OW 111
// continue ;
63814: GO 63306
// end ; end ; r := GetDir ( tmp ) ;
63816: LD_ADDR_VAR 0 15
63820: PUSH
63821: LD_VAR 0 13
63825: PPUSH
63826: CALL_OW 254
63830: ST_TO_ADDR
// if r = 5 then
63831: LD_VAR 0 15
63835: PUSH
63836: LD_INT 5
63838: EQUAL
63839: IFFALSE 63849
// r := 0 ;
63841: LD_ADDR_VAR 0 15
63845: PUSH
63846: LD_INT 0
63848: ST_TO_ADDR
// for j = r to 5 do
63849: LD_ADDR_VAR 0 10
63853: PUSH
63854: DOUBLE
63855: LD_VAR 0 15
63859: DEC
63860: ST_TO_ADDR
63861: LD_INT 5
63863: PUSH
63864: FOR_TO
63865: IFFALSE 63979
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
63867: LD_ADDR_VAR 0 11
63871: PUSH
63872: LD_VAR 0 13
63876: PPUSH
63877: CALL_OW 250
63881: PPUSH
63882: LD_VAR 0 10
63886: PPUSH
63887: LD_INT 2
63889: PPUSH
63890: CALL_OW 272
63894: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
63895: LD_ADDR_VAR 0 12
63899: PUSH
63900: LD_VAR 0 13
63904: PPUSH
63905: CALL_OW 251
63909: PPUSH
63910: LD_VAR 0 10
63914: PPUSH
63915: LD_INT 2
63917: PPUSH
63918: CALL_OW 273
63922: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
63923: LD_VAR 0 11
63927: PPUSH
63928: LD_VAR 0 12
63932: PPUSH
63933: CALL_OW 488
63937: PUSH
63938: LD_VAR 0 11
63942: PPUSH
63943: LD_VAR 0 12
63947: PPUSH
63948: CALL_OW 428
63952: NOT
63953: AND
63954: IFFALSE 63977
// begin ComMoveXY ( tmp , _x , _y ) ;
63956: LD_VAR 0 13
63960: PPUSH
63961: LD_VAR 0 11
63965: PPUSH
63966: LD_VAR 0 12
63970: PPUSH
63971: CALL_OW 111
// break ;
63975: GO 63979
// end ; end ;
63977: GO 63864
63979: POP
63980: POP
// end ; end ;
63981: GO 63306
63983: POP
63984: POP
// end ;
63985: LD_VAR 0 8
63989: RET
// export function BuildingTechInvented ( side , btype ) ; begin
63990: LD_INT 0
63992: PPUSH
// result := true ;
63993: LD_ADDR_VAR 0 3
63997: PUSH
63998: LD_INT 1
64000: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64001: LD_VAR 0 2
64005: PUSH
64006: LD_INT 24
64008: DOUBLE
64009: EQUAL
64010: IFTRUE 64020
64012: LD_INT 33
64014: DOUBLE
64015: EQUAL
64016: IFTRUE 64020
64018: GO 64045
64020: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64021: LD_ADDR_VAR 0 3
64025: PUSH
64026: LD_INT 32
64028: PPUSH
64029: LD_VAR 0 1
64033: PPUSH
64034: CALL_OW 321
64038: PUSH
64039: LD_INT 2
64041: EQUAL
64042: ST_TO_ADDR
64043: GO 64365
64045: LD_INT 20
64047: DOUBLE
64048: EQUAL
64049: IFTRUE 64053
64051: GO 64078
64053: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64054: LD_ADDR_VAR 0 3
64058: PUSH
64059: LD_INT 6
64061: PPUSH
64062: LD_VAR 0 1
64066: PPUSH
64067: CALL_OW 321
64071: PUSH
64072: LD_INT 2
64074: EQUAL
64075: ST_TO_ADDR
64076: GO 64365
64078: LD_INT 22
64080: DOUBLE
64081: EQUAL
64082: IFTRUE 64092
64084: LD_INT 36
64086: DOUBLE
64087: EQUAL
64088: IFTRUE 64092
64090: GO 64117
64092: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64093: LD_ADDR_VAR 0 3
64097: PUSH
64098: LD_INT 15
64100: PPUSH
64101: LD_VAR 0 1
64105: PPUSH
64106: CALL_OW 321
64110: PUSH
64111: LD_INT 2
64113: EQUAL
64114: ST_TO_ADDR
64115: GO 64365
64117: LD_INT 30
64119: DOUBLE
64120: EQUAL
64121: IFTRUE 64125
64123: GO 64150
64125: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64126: LD_ADDR_VAR 0 3
64130: PUSH
64131: LD_INT 20
64133: PPUSH
64134: LD_VAR 0 1
64138: PPUSH
64139: CALL_OW 321
64143: PUSH
64144: LD_INT 2
64146: EQUAL
64147: ST_TO_ADDR
64148: GO 64365
64150: LD_INT 28
64152: DOUBLE
64153: EQUAL
64154: IFTRUE 64164
64156: LD_INT 21
64158: DOUBLE
64159: EQUAL
64160: IFTRUE 64164
64162: GO 64189
64164: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64165: LD_ADDR_VAR 0 3
64169: PUSH
64170: LD_INT 21
64172: PPUSH
64173: LD_VAR 0 1
64177: PPUSH
64178: CALL_OW 321
64182: PUSH
64183: LD_INT 2
64185: EQUAL
64186: ST_TO_ADDR
64187: GO 64365
64189: LD_INT 16
64191: DOUBLE
64192: EQUAL
64193: IFTRUE 64197
64195: GO 64224
64197: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64198: LD_ADDR_VAR 0 3
64202: PUSH
64203: LD_EXP 84
64207: PPUSH
64208: LD_VAR 0 1
64212: PPUSH
64213: CALL_OW 321
64217: PUSH
64218: LD_INT 2
64220: EQUAL
64221: ST_TO_ADDR
64222: GO 64365
64224: LD_INT 19
64226: DOUBLE
64227: EQUAL
64228: IFTRUE 64238
64230: LD_INT 23
64232: DOUBLE
64233: EQUAL
64234: IFTRUE 64238
64236: GO 64265
64238: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64239: LD_ADDR_VAR 0 3
64243: PUSH
64244: LD_EXP 83
64248: PPUSH
64249: LD_VAR 0 1
64253: PPUSH
64254: CALL_OW 321
64258: PUSH
64259: LD_INT 2
64261: EQUAL
64262: ST_TO_ADDR
64263: GO 64365
64265: LD_INT 17
64267: DOUBLE
64268: EQUAL
64269: IFTRUE 64273
64271: GO 64298
64273: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
64274: LD_ADDR_VAR 0 3
64278: PUSH
64279: LD_INT 39
64281: PPUSH
64282: LD_VAR 0 1
64286: PPUSH
64287: CALL_OW 321
64291: PUSH
64292: LD_INT 2
64294: EQUAL
64295: ST_TO_ADDR
64296: GO 64365
64298: LD_INT 18
64300: DOUBLE
64301: EQUAL
64302: IFTRUE 64306
64304: GO 64331
64306: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
64307: LD_ADDR_VAR 0 3
64311: PUSH
64312: LD_INT 40
64314: PPUSH
64315: LD_VAR 0 1
64319: PPUSH
64320: CALL_OW 321
64324: PUSH
64325: LD_INT 2
64327: EQUAL
64328: ST_TO_ADDR
64329: GO 64365
64331: LD_INT 27
64333: DOUBLE
64334: EQUAL
64335: IFTRUE 64339
64337: GO 64364
64339: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
64340: LD_ADDR_VAR 0 3
64344: PUSH
64345: LD_INT 35
64347: PPUSH
64348: LD_VAR 0 1
64352: PPUSH
64353: CALL_OW 321
64357: PUSH
64358: LD_INT 2
64360: EQUAL
64361: ST_TO_ADDR
64362: GO 64365
64364: POP
// end ;
64365: LD_VAR 0 3
64369: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
64370: LD_INT 0
64372: PPUSH
64373: PPUSH
64374: PPUSH
64375: PPUSH
64376: PPUSH
64377: PPUSH
64378: PPUSH
64379: PPUSH
64380: PPUSH
64381: PPUSH
64382: PPUSH
// result := false ;
64383: LD_ADDR_VAR 0 6
64387: PUSH
64388: LD_INT 0
64390: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64391: LD_VAR 0 1
64395: NOT
64396: PUSH
64397: LD_VAR 0 1
64401: PPUSH
64402: CALL_OW 266
64406: PUSH
64407: LD_INT 0
64409: PUSH
64410: LD_INT 1
64412: PUSH
64413: EMPTY
64414: LIST
64415: LIST
64416: IN
64417: NOT
64418: OR
64419: PUSH
64420: LD_VAR 0 2
64424: NOT
64425: OR
64426: PUSH
64427: LD_VAR 0 5
64431: PUSH
64432: LD_INT 0
64434: PUSH
64435: LD_INT 1
64437: PUSH
64438: LD_INT 2
64440: PUSH
64441: LD_INT 3
64443: PUSH
64444: LD_INT 4
64446: PUSH
64447: LD_INT 5
64449: PUSH
64450: EMPTY
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: IN
64458: NOT
64459: OR
64460: PUSH
64461: LD_VAR 0 3
64465: PPUSH
64466: LD_VAR 0 4
64470: PPUSH
64471: CALL_OW 488
64475: NOT
64476: OR
64477: IFFALSE 64481
// exit ;
64479: GO 65217
// side := GetSide ( depot ) ;
64481: LD_ADDR_VAR 0 9
64485: PUSH
64486: LD_VAR 0 1
64490: PPUSH
64491: CALL_OW 255
64495: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
64496: LD_VAR 0 9
64500: PPUSH
64501: LD_VAR 0 2
64505: PPUSH
64506: CALL 63990 0 2
64510: NOT
64511: IFFALSE 64515
// exit ;
64513: GO 65217
// pom := GetBase ( depot ) ;
64515: LD_ADDR_VAR 0 10
64519: PUSH
64520: LD_VAR 0 1
64524: PPUSH
64525: CALL_OW 274
64529: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64530: LD_ADDR_VAR 0 11
64534: PUSH
64535: LD_VAR 0 2
64539: PPUSH
64540: LD_VAR 0 1
64544: PPUSH
64545: CALL_OW 248
64549: PPUSH
64550: CALL_OW 450
64554: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64555: LD_VAR 0 10
64559: PPUSH
64560: LD_INT 1
64562: PPUSH
64563: CALL_OW 275
64567: PUSH
64568: LD_VAR 0 11
64572: PUSH
64573: LD_INT 1
64575: ARRAY
64576: GREATEREQUAL
64577: PUSH
64578: LD_VAR 0 10
64582: PPUSH
64583: LD_INT 2
64585: PPUSH
64586: CALL_OW 275
64590: PUSH
64591: LD_VAR 0 11
64595: PUSH
64596: LD_INT 2
64598: ARRAY
64599: GREATEREQUAL
64600: AND
64601: PUSH
64602: LD_VAR 0 10
64606: PPUSH
64607: LD_INT 3
64609: PPUSH
64610: CALL_OW 275
64614: PUSH
64615: LD_VAR 0 11
64619: PUSH
64620: LD_INT 3
64622: ARRAY
64623: GREATEREQUAL
64624: AND
64625: NOT
64626: IFFALSE 64630
// exit ;
64628: GO 65217
// if GetBType ( depot ) = b_depot then
64630: LD_VAR 0 1
64634: PPUSH
64635: CALL_OW 266
64639: PUSH
64640: LD_INT 0
64642: EQUAL
64643: IFFALSE 64655
// dist := 28 else
64645: LD_ADDR_VAR 0 14
64649: PUSH
64650: LD_INT 28
64652: ST_TO_ADDR
64653: GO 64663
// dist := 36 ;
64655: LD_ADDR_VAR 0 14
64659: PUSH
64660: LD_INT 36
64662: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64663: LD_VAR 0 1
64667: PPUSH
64668: LD_VAR 0 3
64672: PPUSH
64673: LD_VAR 0 4
64677: PPUSH
64678: CALL_OW 297
64682: PUSH
64683: LD_VAR 0 14
64687: GREATER
64688: IFFALSE 64692
// exit ;
64690: GO 65217
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64692: LD_ADDR_VAR 0 12
64696: PUSH
64697: LD_VAR 0 2
64701: PPUSH
64702: LD_VAR 0 3
64706: PPUSH
64707: LD_VAR 0 4
64711: PPUSH
64712: LD_VAR 0 5
64716: PPUSH
64717: LD_VAR 0 1
64721: PPUSH
64722: CALL_OW 248
64726: PPUSH
64727: LD_INT 0
64729: PPUSH
64730: CALL 65222 0 6
64734: ST_TO_ADDR
// if not hexes then
64735: LD_VAR 0 12
64739: NOT
64740: IFFALSE 64744
// exit ;
64742: GO 65217
// hex := GetHexInfo ( x , y ) ;
64744: LD_ADDR_VAR 0 15
64748: PUSH
64749: LD_VAR 0 3
64753: PPUSH
64754: LD_VAR 0 4
64758: PPUSH
64759: CALL_OW 546
64763: ST_TO_ADDR
// if hex [ 1 ] then
64764: LD_VAR 0 15
64768: PUSH
64769: LD_INT 1
64771: ARRAY
64772: IFFALSE 64776
// exit ;
64774: GO 65217
// height := hex [ 2 ] ;
64776: LD_ADDR_VAR 0 13
64780: PUSH
64781: LD_VAR 0 15
64785: PUSH
64786: LD_INT 2
64788: ARRAY
64789: ST_TO_ADDR
// for i = 1 to hexes do
64790: LD_ADDR_VAR 0 7
64794: PUSH
64795: DOUBLE
64796: LD_INT 1
64798: DEC
64799: ST_TO_ADDR
64800: LD_VAR 0 12
64804: PUSH
64805: FOR_TO
64806: IFFALSE 65136
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64808: LD_VAR 0 12
64812: PUSH
64813: LD_VAR 0 7
64817: ARRAY
64818: PUSH
64819: LD_INT 1
64821: ARRAY
64822: PPUSH
64823: LD_VAR 0 12
64827: PUSH
64828: LD_VAR 0 7
64832: ARRAY
64833: PUSH
64834: LD_INT 2
64836: ARRAY
64837: PPUSH
64838: CALL_OW 488
64842: NOT
64843: PUSH
64844: LD_VAR 0 12
64848: PUSH
64849: LD_VAR 0 7
64853: ARRAY
64854: PUSH
64855: LD_INT 1
64857: ARRAY
64858: PPUSH
64859: LD_VAR 0 12
64863: PUSH
64864: LD_VAR 0 7
64868: ARRAY
64869: PUSH
64870: LD_INT 2
64872: ARRAY
64873: PPUSH
64874: CALL_OW 428
64878: PUSH
64879: LD_INT 0
64881: GREATER
64882: OR
64883: PUSH
64884: LD_VAR 0 12
64888: PUSH
64889: LD_VAR 0 7
64893: ARRAY
64894: PUSH
64895: LD_INT 1
64897: ARRAY
64898: PPUSH
64899: LD_VAR 0 12
64903: PUSH
64904: LD_VAR 0 7
64908: ARRAY
64909: PUSH
64910: LD_INT 2
64912: ARRAY
64913: PPUSH
64914: CALL_OW 351
64918: OR
64919: IFFALSE 64925
// exit ;
64921: POP
64922: POP
64923: GO 65217
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64925: LD_ADDR_VAR 0 8
64929: PUSH
64930: LD_VAR 0 12
64934: PUSH
64935: LD_VAR 0 7
64939: ARRAY
64940: PUSH
64941: LD_INT 1
64943: ARRAY
64944: PPUSH
64945: LD_VAR 0 12
64949: PUSH
64950: LD_VAR 0 7
64954: ARRAY
64955: PUSH
64956: LD_INT 2
64958: ARRAY
64959: PPUSH
64960: CALL_OW 546
64964: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64965: LD_VAR 0 8
64969: PUSH
64970: LD_INT 1
64972: ARRAY
64973: PUSH
64974: LD_VAR 0 8
64978: PUSH
64979: LD_INT 2
64981: ARRAY
64982: PUSH
64983: LD_VAR 0 13
64987: PUSH
64988: LD_INT 2
64990: PLUS
64991: GREATER
64992: OR
64993: PUSH
64994: LD_VAR 0 8
64998: PUSH
64999: LD_INT 2
65001: ARRAY
65002: PUSH
65003: LD_VAR 0 13
65007: PUSH
65008: LD_INT 2
65010: MINUS
65011: LESS
65012: OR
65013: PUSH
65014: LD_VAR 0 8
65018: PUSH
65019: LD_INT 3
65021: ARRAY
65022: PUSH
65023: LD_INT 0
65025: PUSH
65026: LD_INT 8
65028: PUSH
65029: LD_INT 9
65031: PUSH
65032: LD_INT 10
65034: PUSH
65035: LD_INT 11
65037: PUSH
65038: LD_INT 12
65040: PUSH
65041: LD_INT 13
65043: PUSH
65044: LD_INT 16
65046: PUSH
65047: LD_INT 17
65049: PUSH
65050: LD_INT 18
65052: PUSH
65053: LD_INT 19
65055: PUSH
65056: LD_INT 20
65058: PUSH
65059: LD_INT 21
65061: PUSH
65062: EMPTY
65063: LIST
65064: LIST
65065: LIST
65066: LIST
65067: LIST
65068: LIST
65069: LIST
65070: LIST
65071: LIST
65072: LIST
65073: LIST
65074: LIST
65075: LIST
65076: IN
65077: NOT
65078: OR
65079: PUSH
65080: LD_VAR 0 8
65084: PUSH
65085: LD_INT 5
65087: ARRAY
65088: NOT
65089: OR
65090: PUSH
65091: LD_VAR 0 8
65095: PUSH
65096: LD_INT 6
65098: ARRAY
65099: PUSH
65100: LD_INT 1
65102: PUSH
65103: LD_INT 2
65105: PUSH
65106: LD_INT 7
65108: PUSH
65109: LD_INT 9
65111: PUSH
65112: LD_INT 10
65114: PUSH
65115: LD_INT 11
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: LIST
65122: LIST
65123: LIST
65124: LIST
65125: IN
65126: NOT
65127: OR
65128: IFFALSE 65134
// exit ;
65130: POP
65131: POP
65132: GO 65217
// end ;
65134: GO 64805
65136: POP
65137: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65138: LD_VAR 0 9
65142: PPUSH
65143: LD_VAR 0 3
65147: PPUSH
65148: LD_VAR 0 4
65152: PPUSH
65153: LD_INT 20
65155: PPUSH
65156: CALL 57163 0 4
65160: PUSH
65161: LD_INT 4
65163: ARRAY
65164: IFFALSE 65168
// exit ;
65166: GO 65217
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65168: LD_VAR 0 2
65172: PUSH
65173: LD_INT 29
65175: PUSH
65176: LD_INT 30
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: IN
65183: PUSH
65184: LD_VAR 0 3
65188: PPUSH
65189: LD_VAR 0 4
65193: PPUSH
65194: LD_VAR 0 9
65198: PPUSH
65199: CALL_OW 440
65203: NOT
65204: AND
65205: IFFALSE 65209
// exit ;
65207: GO 65217
// result := true ;
65209: LD_ADDR_VAR 0 6
65213: PUSH
65214: LD_INT 1
65216: ST_TO_ADDR
// end ;
65217: LD_VAR 0 6
65221: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65222: LD_INT 0
65224: PPUSH
65225: PPUSH
65226: PPUSH
65227: PPUSH
65228: PPUSH
65229: PPUSH
65230: PPUSH
65231: PPUSH
65232: PPUSH
65233: PPUSH
65234: PPUSH
65235: PPUSH
65236: PPUSH
65237: PPUSH
65238: PPUSH
65239: PPUSH
65240: PPUSH
65241: PPUSH
65242: PPUSH
65243: PPUSH
65244: PPUSH
65245: PPUSH
65246: PPUSH
65247: PPUSH
65248: PPUSH
65249: PPUSH
65250: PPUSH
65251: PPUSH
65252: PPUSH
65253: PPUSH
65254: PPUSH
65255: PPUSH
65256: PPUSH
65257: PPUSH
65258: PPUSH
65259: PPUSH
65260: PPUSH
65261: PPUSH
65262: PPUSH
65263: PPUSH
65264: PPUSH
65265: PPUSH
65266: PPUSH
65267: PPUSH
65268: PPUSH
65269: PPUSH
65270: PPUSH
65271: PPUSH
65272: PPUSH
65273: PPUSH
65274: PPUSH
65275: PPUSH
65276: PPUSH
65277: PPUSH
65278: PPUSH
65279: PPUSH
65280: PPUSH
65281: PPUSH
// result = [ ] ;
65282: LD_ADDR_VAR 0 7
65286: PUSH
65287: EMPTY
65288: ST_TO_ADDR
// temp_list = [ ] ;
65289: LD_ADDR_VAR 0 9
65293: PUSH
65294: EMPTY
65295: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65296: LD_VAR 0 4
65300: PUSH
65301: LD_INT 0
65303: PUSH
65304: LD_INT 1
65306: PUSH
65307: LD_INT 2
65309: PUSH
65310: LD_INT 3
65312: PUSH
65313: LD_INT 4
65315: PUSH
65316: LD_INT 5
65318: PUSH
65319: EMPTY
65320: LIST
65321: LIST
65322: LIST
65323: LIST
65324: LIST
65325: LIST
65326: IN
65327: NOT
65328: PUSH
65329: LD_VAR 0 1
65333: PUSH
65334: LD_INT 0
65336: PUSH
65337: LD_INT 1
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: IN
65344: PUSH
65345: LD_VAR 0 5
65349: PUSH
65350: LD_INT 1
65352: PUSH
65353: LD_INT 2
65355: PUSH
65356: LD_INT 3
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: LIST
65363: IN
65364: NOT
65365: AND
65366: OR
65367: IFFALSE 65371
// exit ;
65369: GO 83762
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65371: LD_VAR 0 1
65375: PUSH
65376: LD_INT 6
65378: PUSH
65379: LD_INT 7
65381: PUSH
65382: LD_INT 8
65384: PUSH
65385: LD_INT 13
65387: PUSH
65388: LD_INT 12
65390: PUSH
65391: LD_INT 15
65393: PUSH
65394: LD_INT 11
65396: PUSH
65397: LD_INT 14
65399: PUSH
65400: LD_INT 10
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: LIST
65412: LIST
65413: IN
65414: IFFALSE 65424
// btype = b_lab ;
65416: LD_ADDR_VAR 0 1
65420: PUSH
65421: LD_INT 6
65423: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65424: LD_VAR 0 6
65428: PUSH
65429: LD_INT 0
65431: PUSH
65432: LD_INT 1
65434: PUSH
65435: LD_INT 2
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: LIST
65442: IN
65443: NOT
65444: PUSH
65445: LD_VAR 0 1
65449: PUSH
65450: LD_INT 0
65452: PUSH
65453: LD_INT 1
65455: PUSH
65456: LD_INT 2
65458: PUSH
65459: LD_INT 3
65461: PUSH
65462: LD_INT 6
65464: PUSH
65465: LD_INT 36
65467: PUSH
65468: LD_INT 4
65470: PUSH
65471: LD_INT 5
65473: PUSH
65474: LD_INT 31
65476: PUSH
65477: LD_INT 32
65479: PUSH
65480: LD_INT 33
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: IN
65496: NOT
65497: PUSH
65498: LD_VAR 0 6
65502: PUSH
65503: LD_INT 1
65505: EQUAL
65506: AND
65507: OR
65508: PUSH
65509: LD_VAR 0 1
65513: PUSH
65514: LD_INT 2
65516: PUSH
65517: LD_INT 3
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: IN
65524: NOT
65525: PUSH
65526: LD_VAR 0 6
65530: PUSH
65531: LD_INT 2
65533: EQUAL
65534: AND
65535: OR
65536: IFFALSE 65546
// mode = 0 ;
65538: LD_ADDR_VAR 0 6
65542: PUSH
65543: LD_INT 0
65545: ST_TO_ADDR
// case mode of 0 :
65546: LD_VAR 0 6
65550: PUSH
65551: LD_INT 0
65553: DOUBLE
65554: EQUAL
65555: IFTRUE 65559
65557: GO 77012
65559: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65560: LD_ADDR_VAR 0 11
65564: PUSH
65565: LD_INT 0
65567: PUSH
65568: LD_INT 0
65570: PUSH
65571: EMPTY
65572: LIST
65573: LIST
65574: PUSH
65575: LD_INT 0
65577: PUSH
65578: LD_INT 1
65580: NEG
65581: PUSH
65582: EMPTY
65583: LIST
65584: LIST
65585: PUSH
65586: LD_INT 1
65588: PUSH
65589: LD_INT 0
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 1
65598: PUSH
65599: LD_INT 1
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: PUSH
65606: LD_INT 0
65608: PUSH
65609: LD_INT 1
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: PUSH
65616: LD_INT 1
65618: NEG
65619: PUSH
65620: LD_INT 0
65622: PUSH
65623: EMPTY
65624: LIST
65625: LIST
65626: PUSH
65627: LD_INT 1
65629: NEG
65630: PUSH
65631: LD_INT 1
65633: NEG
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: PUSH
65639: LD_INT 1
65641: NEG
65642: PUSH
65643: LD_INT 2
65645: NEG
65646: PUSH
65647: EMPTY
65648: LIST
65649: LIST
65650: PUSH
65651: LD_INT 0
65653: PUSH
65654: LD_INT 2
65656: NEG
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 1
65664: PUSH
65665: LD_INT 1
65667: NEG
65668: PUSH
65669: EMPTY
65670: LIST
65671: LIST
65672: PUSH
65673: LD_INT 1
65675: PUSH
65676: LD_INT 2
65678: PUSH
65679: EMPTY
65680: LIST
65681: LIST
65682: PUSH
65683: LD_INT 0
65685: PUSH
65686: LD_INT 2
65688: PUSH
65689: EMPTY
65690: LIST
65691: LIST
65692: PUSH
65693: LD_INT 1
65695: NEG
65696: PUSH
65697: LD_INT 1
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 1
65706: PUSH
65707: LD_INT 3
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: LD_INT 0
65716: PUSH
65717: LD_INT 3
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 1
65726: NEG
65727: PUSH
65728: LD_INT 2
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: LIST
65748: LIST
65749: LIST
65750: LIST
65751: LIST
65752: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65753: LD_ADDR_VAR 0 12
65757: PUSH
65758: LD_INT 0
65760: PUSH
65761: LD_INT 0
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PUSH
65768: LD_INT 0
65770: PUSH
65771: LD_INT 1
65773: NEG
65774: PUSH
65775: EMPTY
65776: LIST
65777: LIST
65778: PUSH
65779: LD_INT 1
65781: PUSH
65782: LD_INT 0
65784: PUSH
65785: EMPTY
65786: LIST
65787: LIST
65788: PUSH
65789: LD_INT 1
65791: PUSH
65792: LD_INT 1
65794: PUSH
65795: EMPTY
65796: LIST
65797: LIST
65798: PUSH
65799: LD_INT 0
65801: PUSH
65802: LD_INT 1
65804: PUSH
65805: EMPTY
65806: LIST
65807: LIST
65808: PUSH
65809: LD_INT 1
65811: NEG
65812: PUSH
65813: LD_INT 0
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: PUSH
65820: LD_INT 1
65822: NEG
65823: PUSH
65824: LD_INT 1
65826: NEG
65827: PUSH
65828: EMPTY
65829: LIST
65830: LIST
65831: PUSH
65832: LD_INT 1
65834: PUSH
65835: LD_INT 1
65837: NEG
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 2
65845: PUSH
65846: LD_INT 0
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 2
65855: PUSH
65856: LD_INT 1
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: LD_INT 1
65865: NEG
65866: PUSH
65867: LD_INT 1
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PUSH
65874: LD_INT 2
65876: NEG
65877: PUSH
65878: LD_INT 0
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: PUSH
65885: LD_INT 2
65887: NEG
65888: PUSH
65889: LD_INT 1
65891: NEG
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 2
65899: NEG
65900: PUSH
65901: LD_INT 1
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: LD_INT 3
65910: NEG
65911: PUSH
65912: LD_INT 0
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: PUSH
65919: LD_INT 3
65921: NEG
65922: PUSH
65923: LD_INT 1
65925: NEG
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: EMPTY
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: LIST
65937: LIST
65938: LIST
65939: LIST
65940: LIST
65941: LIST
65942: LIST
65943: LIST
65944: LIST
65945: LIST
65946: LIST
65947: LIST
65948: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65949: LD_ADDR_VAR 0 13
65953: PUSH
65954: LD_INT 0
65956: PUSH
65957: LD_INT 0
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 0
65966: PUSH
65967: LD_INT 1
65969: NEG
65970: PUSH
65971: EMPTY
65972: LIST
65973: LIST
65974: PUSH
65975: LD_INT 1
65977: PUSH
65978: LD_INT 0
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 1
65987: PUSH
65988: LD_INT 1
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: PUSH
65995: LD_INT 0
65997: PUSH
65998: LD_INT 1
66000: PUSH
66001: EMPTY
66002: LIST
66003: LIST
66004: PUSH
66005: LD_INT 1
66007: NEG
66008: PUSH
66009: LD_INT 0
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 1
66018: NEG
66019: PUSH
66020: LD_INT 1
66022: NEG
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: LD_INT 1
66030: NEG
66031: PUSH
66032: LD_INT 2
66034: NEG
66035: PUSH
66036: EMPTY
66037: LIST
66038: LIST
66039: PUSH
66040: LD_INT 2
66042: PUSH
66043: LD_INT 1
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 2
66052: PUSH
66053: LD_INT 2
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 1
66062: PUSH
66063: LD_INT 2
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PUSH
66070: LD_INT 2
66072: NEG
66073: PUSH
66074: LD_INT 1
66076: NEG
66077: PUSH
66078: EMPTY
66079: LIST
66080: LIST
66081: PUSH
66082: LD_INT 2
66084: NEG
66085: PUSH
66086: LD_INT 2
66088: NEG
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: PUSH
66094: LD_INT 2
66096: NEG
66097: PUSH
66098: LD_INT 3
66100: NEG
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 3
66108: NEG
66109: PUSH
66110: LD_INT 2
66112: NEG
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 3
66120: NEG
66121: PUSH
66122: LD_INT 3
66124: NEG
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66148: LD_ADDR_VAR 0 14
66152: PUSH
66153: LD_INT 0
66155: PUSH
66156: LD_INT 0
66158: PUSH
66159: EMPTY
66160: LIST
66161: LIST
66162: PUSH
66163: LD_INT 0
66165: PUSH
66166: LD_INT 1
66168: NEG
66169: PUSH
66170: EMPTY
66171: LIST
66172: LIST
66173: PUSH
66174: LD_INT 1
66176: PUSH
66177: LD_INT 0
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 1
66186: PUSH
66187: LD_INT 1
66189: PUSH
66190: EMPTY
66191: LIST
66192: LIST
66193: PUSH
66194: LD_INT 0
66196: PUSH
66197: LD_INT 1
66199: PUSH
66200: EMPTY
66201: LIST
66202: LIST
66203: PUSH
66204: LD_INT 1
66206: NEG
66207: PUSH
66208: LD_INT 0
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: PUSH
66215: LD_INT 1
66217: NEG
66218: PUSH
66219: LD_INT 1
66221: NEG
66222: PUSH
66223: EMPTY
66224: LIST
66225: LIST
66226: PUSH
66227: LD_INT 1
66229: NEG
66230: PUSH
66231: LD_INT 2
66233: NEG
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: LD_INT 0
66241: PUSH
66242: LD_INT 2
66244: NEG
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 1
66252: PUSH
66253: LD_INT 1
66255: NEG
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 1
66263: PUSH
66264: LD_INT 2
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: LD_INT 0
66273: PUSH
66274: LD_INT 2
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 1
66283: NEG
66284: PUSH
66285: LD_INT 1
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 1
66294: NEG
66295: PUSH
66296: LD_INT 3
66298: NEG
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: LD_INT 0
66306: PUSH
66307: LD_INT 3
66309: NEG
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 1
66317: PUSH
66318: LD_INT 2
66320: NEG
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: LIST
66330: LIST
66331: LIST
66332: LIST
66333: LIST
66334: LIST
66335: LIST
66336: LIST
66337: LIST
66338: LIST
66339: LIST
66340: LIST
66341: LIST
66342: LIST
66343: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66344: LD_ADDR_VAR 0 15
66348: PUSH
66349: LD_INT 0
66351: PUSH
66352: LD_INT 0
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: LD_INT 0
66361: PUSH
66362: LD_INT 1
66364: NEG
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PUSH
66370: LD_INT 1
66372: PUSH
66373: LD_INT 0
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: LD_INT 1
66382: PUSH
66383: LD_INT 1
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: LD_INT 0
66392: PUSH
66393: LD_INT 1
66395: PUSH
66396: EMPTY
66397: LIST
66398: LIST
66399: PUSH
66400: LD_INT 1
66402: NEG
66403: PUSH
66404: LD_INT 0
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 1
66413: NEG
66414: PUSH
66415: LD_INT 1
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 1
66425: PUSH
66426: LD_INT 1
66428: NEG
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 2
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 2
66446: PUSH
66447: LD_INT 1
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 1
66456: NEG
66457: PUSH
66458: LD_INT 1
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: LD_INT 2
66467: NEG
66468: PUSH
66469: LD_INT 0
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 2
66478: NEG
66479: PUSH
66480: LD_INT 1
66482: NEG
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 2
66490: PUSH
66491: LD_INT 1
66493: NEG
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: PUSH
66499: LD_INT 3
66501: PUSH
66502: LD_INT 0
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: PUSH
66509: LD_INT 3
66511: PUSH
66512: LD_INT 1
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: LIST
66526: LIST
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66537: LD_ADDR_VAR 0 16
66541: PUSH
66542: LD_INT 0
66544: PUSH
66545: LD_INT 0
66547: PUSH
66548: EMPTY
66549: LIST
66550: LIST
66551: PUSH
66552: LD_INT 0
66554: PUSH
66555: LD_INT 1
66557: NEG
66558: PUSH
66559: EMPTY
66560: LIST
66561: LIST
66562: PUSH
66563: LD_INT 1
66565: PUSH
66566: LD_INT 0
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: PUSH
66573: LD_INT 1
66575: PUSH
66576: LD_INT 1
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: PUSH
66583: LD_INT 0
66585: PUSH
66586: LD_INT 1
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 1
66595: NEG
66596: PUSH
66597: LD_INT 0
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 1
66606: NEG
66607: PUSH
66608: LD_INT 1
66610: NEG
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 1
66618: NEG
66619: PUSH
66620: LD_INT 2
66622: NEG
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PUSH
66628: LD_INT 2
66630: PUSH
66631: LD_INT 1
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 2
66640: PUSH
66641: LD_INT 2
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PUSH
66648: LD_INT 1
66650: PUSH
66651: LD_INT 2
66653: PUSH
66654: EMPTY
66655: LIST
66656: LIST
66657: PUSH
66658: LD_INT 2
66660: NEG
66661: PUSH
66662: LD_INT 1
66664: NEG
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: LD_INT 2
66672: NEG
66673: PUSH
66674: LD_INT 2
66676: NEG
66677: PUSH
66678: EMPTY
66679: LIST
66680: LIST
66681: PUSH
66682: LD_INT 3
66684: PUSH
66685: LD_INT 2
66687: PUSH
66688: EMPTY
66689: LIST
66690: LIST
66691: PUSH
66692: LD_INT 3
66694: PUSH
66695: LD_INT 3
66697: PUSH
66698: EMPTY
66699: LIST
66700: LIST
66701: PUSH
66702: LD_INT 2
66704: PUSH
66705: LD_INT 3
66707: PUSH
66708: EMPTY
66709: LIST
66710: LIST
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66730: LD_ADDR_VAR 0 17
66734: PUSH
66735: LD_INT 0
66737: PUSH
66738: LD_INT 0
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: LD_INT 0
66747: PUSH
66748: LD_INT 1
66750: NEG
66751: PUSH
66752: EMPTY
66753: LIST
66754: LIST
66755: PUSH
66756: LD_INT 1
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 1
66768: PUSH
66769: LD_INT 1
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 0
66778: PUSH
66779: LD_INT 1
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 1
66788: NEG
66789: PUSH
66790: LD_INT 0
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: PUSH
66797: LD_INT 1
66799: NEG
66800: PUSH
66801: LD_INT 1
66803: NEG
66804: PUSH
66805: EMPTY
66806: LIST
66807: LIST
66808: PUSH
66809: LD_INT 1
66811: NEG
66812: PUSH
66813: LD_INT 2
66815: NEG
66816: PUSH
66817: EMPTY
66818: LIST
66819: LIST
66820: PUSH
66821: LD_INT 0
66823: PUSH
66824: LD_INT 2
66826: NEG
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 1
66834: PUSH
66835: LD_INT 1
66837: NEG
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: PUSH
66843: LD_INT 2
66845: PUSH
66846: LD_INT 0
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: PUSH
66853: LD_INT 2
66855: PUSH
66856: LD_INT 1
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 2
66865: PUSH
66866: LD_INT 2
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 1
66875: PUSH
66876: LD_INT 2
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: LD_INT 0
66885: PUSH
66886: LD_INT 2
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 1
66895: NEG
66896: PUSH
66897: LD_INT 1
66899: PUSH
66900: EMPTY
66901: LIST
66902: LIST
66903: PUSH
66904: LD_INT 2
66906: NEG
66907: PUSH
66908: LD_INT 0
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: PUSH
66915: LD_INT 2
66917: NEG
66918: PUSH
66919: LD_INT 1
66921: NEG
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 2
66929: NEG
66930: PUSH
66931: LD_INT 2
66933: NEG
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66960: LD_ADDR_VAR 0 18
66964: PUSH
66965: LD_INT 0
66967: PUSH
66968: LD_INT 0
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 0
66977: PUSH
66978: LD_INT 1
66980: NEG
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: LD_INT 0
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: PUSH
66996: LD_INT 1
66998: PUSH
66999: LD_INT 1
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: PUSH
67006: LD_INT 0
67008: PUSH
67009: LD_INT 1
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 1
67018: NEG
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 1
67029: NEG
67030: PUSH
67031: LD_INT 1
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 1
67041: NEG
67042: PUSH
67043: LD_INT 2
67045: NEG
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 0
67053: PUSH
67054: LD_INT 2
67056: NEG
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: PUSH
67062: LD_INT 1
67064: PUSH
67065: LD_INT 1
67067: NEG
67068: PUSH
67069: EMPTY
67070: LIST
67071: LIST
67072: PUSH
67073: LD_INT 2
67075: PUSH
67076: LD_INT 0
67078: PUSH
67079: EMPTY
67080: LIST
67081: LIST
67082: PUSH
67083: LD_INT 2
67085: PUSH
67086: LD_INT 1
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 2
67095: PUSH
67096: LD_INT 2
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 1
67105: PUSH
67106: LD_INT 2
67108: PUSH
67109: EMPTY
67110: LIST
67111: LIST
67112: PUSH
67113: LD_INT 0
67115: PUSH
67116: LD_INT 2
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 1
67125: NEG
67126: PUSH
67127: LD_INT 1
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 2
67136: NEG
67137: PUSH
67138: LD_INT 0
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 2
67147: NEG
67148: PUSH
67149: LD_INT 1
67151: NEG
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PUSH
67157: LD_INT 2
67159: NEG
67160: PUSH
67161: LD_INT 2
67163: NEG
67164: PUSH
67165: EMPTY
67166: LIST
67167: LIST
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: LIST
67177: LIST
67178: LIST
67179: LIST
67180: LIST
67181: LIST
67182: LIST
67183: LIST
67184: LIST
67185: LIST
67186: LIST
67187: LIST
67188: LIST
67189: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67190: LD_ADDR_VAR 0 19
67194: PUSH
67195: LD_INT 0
67197: PUSH
67198: LD_INT 0
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: LD_INT 1
67210: NEG
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 1
67218: PUSH
67219: LD_INT 0
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 1
67228: PUSH
67229: LD_INT 1
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 0
67238: PUSH
67239: LD_INT 1
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 1
67248: NEG
67249: PUSH
67250: LD_INT 0
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 1
67259: NEG
67260: PUSH
67261: LD_INT 1
67263: NEG
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 1
67271: NEG
67272: PUSH
67273: LD_INT 2
67275: NEG
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: LD_INT 0
67283: PUSH
67284: LD_INT 2
67286: NEG
67287: PUSH
67288: EMPTY
67289: LIST
67290: LIST
67291: PUSH
67292: LD_INT 1
67294: PUSH
67295: LD_INT 1
67297: NEG
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: PUSH
67303: LD_INT 2
67305: PUSH
67306: LD_INT 0
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 2
67315: PUSH
67316: LD_INT 1
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 2
67325: PUSH
67326: LD_INT 2
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: LD_INT 2
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 0
67345: PUSH
67346: LD_INT 2
67348: PUSH
67349: EMPTY
67350: LIST
67351: LIST
67352: PUSH
67353: LD_INT 1
67355: NEG
67356: PUSH
67357: LD_INT 1
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 2
67366: NEG
67367: PUSH
67368: LD_INT 0
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 2
67377: NEG
67378: PUSH
67379: LD_INT 1
67381: NEG
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: PUSH
67387: LD_INT 2
67389: NEG
67390: PUSH
67391: LD_INT 2
67393: NEG
67394: PUSH
67395: EMPTY
67396: LIST
67397: LIST
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: LIST
67403: LIST
67404: LIST
67405: LIST
67406: LIST
67407: LIST
67408: LIST
67409: LIST
67410: LIST
67411: LIST
67412: LIST
67413: LIST
67414: LIST
67415: LIST
67416: LIST
67417: LIST
67418: LIST
67419: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67420: LD_ADDR_VAR 0 20
67424: PUSH
67425: LD_INT 0
67427: PUSH
67428: LD_INT 0
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: PUSH
67435: LD_INT 0
67437: PUSH
67438: LD_INT 1
67440: NEG
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 1
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 1
67458: PUSH
67459: LD_INT 1
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 0
67468: PUSH
67469: LD_INT 1
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: LD_INT 1
67478: NEG
67479: PUSH
67480: LD_INT 0
67482: PUSH
67483: EMPTY
67484: LIST
67485: LIST
67486: PUSH
67487: LD_INT 1
67489: NEG
67490: PUSH
67491: LD_INT 1
67493: NEG
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: PUSH
67499: LD_INT 1
67501: NEG
67502: PUSH
67503: LD_INT 2
67505: NEG
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 0
67513: PUSH
67514: LD_INT 2
67516: NEG
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 1
67524: PUSH
67525: LD_INT 1
67527: NEG
67528: PUSH
67529: EMPTY
67530: LIST
67531: LIST
67532: PUSH
67533: LD_INT 2
67535: PUSH
67536: LD_INT 0
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PUSH
67543: LD_INT 2
67545: PUSH
67546: LD_INT 1
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: LD_INT 2
67555: PUSH
67556: LD_INT 2
67558: PUSH
67559: EMPTY
67560: LIST
67561: LIST
67562: PUSH
67563: LD_INT 1
67565: PUSH
67566: LD_INT 2
67568: PUSH
67569: EMPTY
67570: LIST
67571: LIST
67572: PUSH
67573: LD_INT 0
67575: PUSH
67576: LD_INT 2
67578: PUSH
67579: EMPTY
67580: LIST
67581: LIST
67582: PUSH
67583: LD_INT 1
67585: NEG
67586: PUSH
67587: LD_INT 1
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 2
67596: NEG
67597: PUSH
67598: LD_INT 0
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 2
67607: NEG
67608: PUSH
67609: LD_INT 1
67611: NEG
67612: PUSH
67613: EMPTY
67614: LIST
67615: LIST
67616: PUSH
67617: LD_INT 2
67619: NEG
67620: PUSH
67621: LD_INT 2
67623: NEG
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67650: LD_ADDR_VAR 0 21
67654: PUSH
67655: LD_INT 0
67657: PUSH
67658: LD_INT 0
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 0
67667: PUSH
67668: LD_INT 1
67670: NEG
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 1
67678: PUSH
67679: LD_INT 0
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 1
67688: PUSH
67689: LD_INT 1
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 0
67698: PUSH
67699: LD_INT 1
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 1
67708: NEG
67709: PUSH
67710: LD_INT 0
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: PUSH
67717: LD_INT 1
67719: NEG
67720: PUSH
67721: LD_INT 1
67723: NEG
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 1
67731: NEG
67732: PUSH
67733: LD_INT 2
67735: NEG
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 0
67743: PUSH
67744: LD_INT 2
67746: NEG
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PUSH
67752: LD_INT 1
67754: PUSH
67755: LD_INT 1
67757: NEG
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: PUSH
67763: LD_INT 2
67765: PUSH
67766: LD_INT 0
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PUSH
67773: LD_INT 2
67775: PUSH
67776: LD_INT 1
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 2
67785: PUSH
67786: LD_INT 2
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 1
67795: PUSH
67796: LD_INT 2
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 0
67805: PUSH
67806: LD_INT 2
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: LD_INT 1
67815: NEG
67816: PUSH
67817: LD_INT 1
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 2
67826: NEG
67827: PUSH
67828: LD_INT 0
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 2
67837: NEG
67838: PUSH
67839: LD_INT 1
67841: NEG
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PUSH
67847: LD_INT 2
67849: NEG
67850: PUSH
67851: LD_INT 2
67853: NEG
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67880: LD_ADDR_VAR 0 22
67884: PUSH
67885: LD_INT 0
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 0
67897: PUSH
67898: LD_INT 1
67900: NEG
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 1
67908: PUSH
67909: LD_INT 0
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PUSH
67916: LD_INT 1
67918: PUSH
67919: LD_INT 1
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: LD_INT 1
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PUSH
67936: LD_INT 1
67938: NEG
67939: PUSH
67940: LD_INT 0
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: PUSH
67947: LD_INT 1
67949: NEG
67950: PUSH
67951: LD_INT 1
67953: NEG
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 1
67961: NEG
67962: PUSH
67963: LD_INT 2
67965: NEG
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 0
67973: PUSH
67974: LD_INT 2
67976: NEG
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 1
67984: PUSH
67985: LD_INT 1
67987: NEG
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 2
67995: PUSH
67996: LD_INT 0
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 2
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 2
68015: PUSH
68016: LD_INT 2
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 1
68025: PUSH
68026: LD_INT 2
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 0
68035: PUSH
68036: LD_INT 2
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: PUSH
68043: LD_INT 1
68045: NEG
68046: PUSH
68047: LD_INT 1
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 2
68056: NEG
68057: PUSH
68058: LD_INT 0
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 2
68067: NEG
68068: PUSH
68069: LD_INT 1
68071: NEG
68072: PUSH
68073: EMPTY
68074: LIST
68075: LIST
68076: PUSH
68077: LD_INT 2
68079: NEG
68080: PUSH
68081: LD_INT 2
68083: NEG
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: LIST
68097: LIST
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: LIST
68103: LIST
68104: LIST
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68110: LD_ADDR_VAR 0 23
68114: PUSH
68115: LD_INT 0
68117: PUSH
68118: LD_INT 0
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 0
68127: PUSH
68128: LD_INT 1
68130: NEG
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 1
68138: PUSH
68139: LD_INT 0
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 1
68148: PUSH
68149: LD_INT 1
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 0
68158: PUSH
68159: LD_INT 1
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: LD_INT 1
68168: NEG
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 1
68179: NEG
68180: PUSH
68181: LD_INT 1
68183: NEG
68184: PUSH
68185: EMPTY
68186: LIST
68187: LIST
68188: PUSH
68189: LD_INT 1
68191: NEG
68192: PUSH
68193: LD_INT 2
68195: NEG
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 0
68203: PUSH
68204: LD_INT 2
68206: NEG
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PUSH
68212: LD_INT 1
68214: PUSH
68215: LD_INT 1
68217: NEG
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 2
68225: PUSH
68226: LD_INT 0
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: PUSH
68233: LD_INT 2
68235: PUSH
68236: LD_INT 1
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 2
68245: PUSH
68246: LD_INT 2
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 1
68255: PUSH
68256: LD_INT 2
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 0
68265: PUSH
68266: LD_INT 2
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: LD_INT 1
68275: NEG
68276: PUSH
68277: LD_INT 1
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 2
68286: NEG
68287: PUSH
68288: LD_INT 0
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 2
68297: NEG
68298: PUSH
68299: LD_INT 1
68301: NEG
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 2
68309: NEG
68310: PUSH
68311: LD_INT 2
68313: NEG
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: PUSH
68319: LD_INT 2
68321: NEG
68322: PUSH
68323: LD_INT 3
68325: NEG
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: PUSH
68331: LD_INT 1
68333: NEG
68334: PUSH
68335: LD_INT 3
68337: NEG
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 1
68345: PUSH
68346: LD_INT 2
68348: NEG
68349: PUSH
68350: EMPTY
68351: LIST
68352: LIST
68353: PUSH
68354: LD_INT 2
68356: PUSH
68357: LD_INT 1
68359: NEG
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: EMPTY
68366: LIST
68367: LIST
68368: LIST
68369: LIST
68370: LIST
68371: LIST
68372: LIST
68373: LIST
68374: LIST
68375: LIST
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68390: LD_ADDR_VAR 0 24
68394: PUSH
68395: LD_INT 0
68397: PUSH
68398: LD_INT 0
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: PUSH
68405: LD_INT 0
68407: PUSH
68408: LD_INT 1
68410: NEG
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: LD_INT 1
68418: PUSH
68419: LD_INT 0
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 1
68428: PUSH
68429: LD_INT 1
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: LD_INT 0
68438: PUSH
68439: LD_INT 1
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 1
68448: NEG
68449: PUSH
68450: LD_INT 0
68452: PUSH
68453: EMPTY
68454: LIST
68455: LIST
68456: PUSH
68457: LD_INT 1
68459: NEG
68460: PUSH
68461: LD_INT 1
68463: NEG
68464: PUSH
68465: EMPTY
68466: LIST
68467: LIST
68468: PUSH
68469: LD_INT 1
68471: NEG
68472: PUSH
68473: LD_INT 2
68475: NEG
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: PUSH
68481: LD_INT 0
68483: PUSH
68484: LD_INT 2
68486: NEG
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 1
68494: PUSH
68495: LD_INT 1
68497: NEG
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 2
68505: PUSH
68506: LD_INT 0
68508: PUSH
68509: EMPTY
68510: LIST
68511: LIST
68512: PUSH
68513: LD_INT 2
68515: PUSH
68516: LD_INT 1
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 2
68525: PUSH
68526: LD_INT 2
68528: PUSH
68529: EMPTY
68530: LIST
68531: LIST
68532: PUSH
68533: LD_INT 1
68535: PUSH
68536: LD_INT 2
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 0
68545: PUSH
68546: LD_INT 2
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 1
68555: NEG
68556: PUSH
68557: LD_INT 1
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 2
68566: NEG
68567: PUSH
68568: LD_INT 0
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PUSH
68575: LD_INT 2
68577: NEG
68578: PUSH
68579: LD_INT 1
68581: NEG
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: PUSH
68587: LD_INT 2
68589: NEG
68590: PUSH
68591: LD_INT 2
68593: NEG
68594: PUSH
68595: EMPTY
68596: LIST
68597: LIST
68598: PUSH
68599: LD_INT 1
68601: PUSH
68602: LD_INT 2
68604: NEG
68605: PUSH
68606: EMPTY
68607: LIST
68608: LIST
68609: PUSH
68610: LD_INT 2
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 3
68623: PUSH
68624: LD_INT 1
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 3
68633: PUSH
68634: LD_INT 2
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: LIST
68650: LIST
68651: LIST
68652: LIST
68653: LIST
68654: LIST
68655: LIST
68656: LIST
68657: LIST
68658: LIST
68659: LIST
68660: LIST
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68666: LD_ADDR_VAR 0 25
68670: PUSH
68671: LD_INT 0
68673: PUSH
68674: LD_INT 0
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 0
68683: PUSH
68684: LD_INT 1
68686: NEG
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 1
68694: PUSH
68695: LD_INT 0
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: PUSH
68702: LD_INT 1
68704: PUSH
68705: LD_INT 1
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 0
68714: PUSH
68715: LD_INT 1
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 1
68724: NEG
68725: PUSH
68726: LD_INT 0
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PUSH
68733: LD_INT 1
68735: NEG
68736: PUSH
68737: LD_INT 1
68739: NEG
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: LD_INT 1
68747: NEG
68748: PUSH
68749: LD_INT 2
68751: NEG
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 0
68759: PUSH
68760: LD_INT 2
68762: NEG
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: PUSH
68771: LD_INT 1
68773: NEG
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 2
68781: PUSH
68782: LD_INT 0
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PUSH
68789: LD_INT 2
68791: PUSH
68792: LD_INT 1
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PUSH
68799: LD_INT 2
68801: PUSH
68802: LD_INT 2
68804: PUSH
68805: EMPTY
68806: LIST
68807: LIST
68808: PUSH
68809: LD_INT 1
68811: PUSH
68812: LD_INT 2
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: LD_INT 2
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: LD_INT 1
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: PUSH
68840: LD_INT 2
68842: NEG
68843: PUSH
68844: LD_INT 0
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 2
68853: NEG
68854: PUSH
68855: LD_INT 1
68857: NEG
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: LD_INT 2
68869: NEG
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 3
68877: PUSH
68878: LD_INT 1
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: PUSH
68885: LD_INT 3
68887: PUSH
68888: LD_INT 2
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PUSH
68895: LD_INT 2
68897: PUSH
68898: LD_INT 3
68900: PUSH
68901: EMPTY
68902: LIST
68903: LIST
68904: PUSH
68905: LD_INT 1
68907: PUSH
68908: LD_INT 3
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: LIST
68919: LIST
68920: LIST
68921: LIST
68922: LIST
68923: LIST
68924: LIST
68925: LIST
68926: LIST
68927: LIST
68928: LIST
68929: LIST
68930: LIST
68931: LIST
68932: LIST
68933: LIST
68934: LIST
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68940: LD_ADDR_VAR 0 26
68944: PUSH
68945: LD_INT 0
68947: PUSH
68948: LD_INT 0
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 0
68957: PUSH
68958: LD_INT 1
68960: NEG
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PUSH
68966: LD_INT 1
68968: PUSH
68969: LD_INT 0
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 1
68978: PUSH
68979: LD_INT 1
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 0
68988: PUSH
68989: LD_INT 1
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: LD_INT 1
68998: NEG
68999: PUSH
69000: LD_INT 0
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 1
69009: NEG
69010: PUSH
69011: LD_INT 1
69013: NEG
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 1
69021: NEG
69022: PUSH
69023: LD_INT 2
69025: NEG
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 0
69033: PUSH
69034: LD_INT 2
69036: NEG
69037: PUSH
69038: EMPTY
69039: LIST
69040: LIST
69041: PUSH
69042: LD_INT 1
69044: PUSH
69045: LD_INT 1
69047: NEG
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PUSH
69053: LD_INT 2
69055: PUSH
69056: LD_INT 0
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: LD_INT 2
69065: PUSH
69066: LD_INT 1
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: PUSH
69073: LD_INT 2
69075: PUSH
69076: LD_INT 2
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: PUSH
69083: LD_INT 1
69085: PUSH
69086: LD_INT 2
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PUSH
69093: LD_INT 0
69095: PUSH
69096: LD_INT 2
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: PUSH
69103: LD_INT 1
69105: NEG
69106: PUSH
69107: LD_INT 1
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: LD_INT 2
69116: NEG
69117: PUSH
69118: LD_INT 0
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 2
69127: NEG
69128: PUSH
69129: LD_INT 1
69131: NEG
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 2
69139: NEG
69140: PUSH
69141: LD_INT 2
69143: NEG
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 2
69151: PUSH
69152: LD_INT 3
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: PUSH
69159: LD_INT 1
69161: PUSH
69162: LD_INT 3
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: NEG
69172: PUSH
69173: LD_INT 2
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: PUSH
69180: LD_INT 2
69182: NEG
69183: PUSH
69184: LD_INT 1
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: EMPTY
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69216: LD_ADDR_VAR 0 27
69220: PUSH
69221: LD_INT 0
69223: PUSH
69224: LD_INT 0
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 0
69233: PUSH
69234: LD_INT 1
69236: NEG
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: PUSH
69242: LD_INT 1
69244: PUSH
69245: LD_INT 0
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PUSH
69252: LD_INT 1
69254: PUSH
69255: LD_INT 1
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: PUSH
69262: LD_INT 0
69264: PUSH
69265: LD_INT 1
69267: PUSH
69268: EMPTY
69269: LIST
69270: LIST
69271: PUSH
69272: LD_INT 1
69274: NEG
69275: PUSH
69276: LD_INT 0
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 1
69285: NEG
69286: PUSH
69287: LD_INT 1
69289: NEG
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: PUSH
69295: LD_INT 1
69297: NEG
69298: PUSH
69299: LD_INT 2
69301: NEG
69302: PUSH
69303: EMPTY
69304: LIST
69305: LIST
69306: PUSH
69307: LD_INT 0
69309: PUSH
69310: LD_INT 2
69312: NEG
69313: PUSH
69314: EMPTY
69315: LIST
69316: LIST
69317: PUSH
69318: LD_INT 1
69320: PUSH
69321: LD_INT 1
69323: NEG
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 2
69331: PUSH
69332: LD_INT 0
69334: PUSH
69335: EMPTY
69336: LIST
69337: LIST
69338: PUSH
69339: LD_INT 2
69341: PUSH
69342: LD_INT 1
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 2
69351: PUSH
69352: LD_INT 2
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 1
69361: PUSH
69362: LD_INT 2
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 0
69371: PUSH
69372: LD_INT 2
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 1
69381: NEG
69382: PUSH
69383: LD_INT 1
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 2
69392: NEG
69393: PUSH
69394: LD_INT 0
69396: PUSH
69397: EMPTY
69398: LIST
69399: LIST
69400: PUSH
69401: LD_INT 2
69403: NEG
69404: PUSH
69405: LD_INT 1
69407: NEG
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: LD_INT 2
69415: NEG
69416: PUSH
69417: LD_INT 2
69419: NEG
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 1
69427: NEG
69428: PUSH
69429: LD_INT 2
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 2
69438: NEG
69439: PUSH
69440: LD_INT 1
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 3
69449: NEG
69450: PUSH
69451: LD_INT 1
69453: NEG
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 3
69461: NEG
69462: PUSH
69463: LD_INT 2
69465: NEG
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: EMPTY
69472: LIST
69473: LIST
69474: LIST
69475: LIST
69476: LIST
69477: LIST
69478: LIST
69479: LIST
69480: LIST
69481: LIST
69482: LIST
69483: LIST
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: LIST
69495: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69496: LD_ADDR_VAR 0 28
69500: PUSH
69501: LD_INT 0
69503: PUSH
69504: LD_INT 0
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 0
69513: PUSH
69514: LD_INT 1
69516: NEG
69517: PUSH
69518: EMPTY
69519: LIST
69520: LIST
69521: PUSH
69522: LD_INT 1
69524: PUSH
69525: LD_INT 0
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 1
69534: PUSH
69535: LD_INT 1
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 0
69544: PUSH
69545: LD_INT 1
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 1
69554: NEG
69555: PUSH
69556: LD_INT 0
69558: PUSH
69559: EMPTY
69560: LIST
69561: LIST
69562: PUSH
69563: LD_INT 1
69565: NEG
69566: PUSH
69567: LD_INT 1
69569: NEG
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 1
69577: NEG
69578: PUSH
69579: LD_INT 2
69581: NEG
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 0
69589: PUSH
69590: LD_INT 2
69592: NEG
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: PUSH
69598: LD_INT 1
69600: PUSH
69601: LD_INT 1
69603: NEG
69604: PUSH
69605: EMPTY
69606: LIST
69607: LIST
69608: PUSH
69609: LD_INT 2
69611: PUSH
69612: LD_INT 0
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: LD_INT 2
69621: PUSH
69622: LD_INT 1
69624: PUSH
69625: EMPTY
69626: LIST
69627: LIST
69628: PUSH
69629: LD_INT 2
69631: PUSH
69632: LD_INT 2
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: PUSH
69639: LD_INT 1
69641: PUSH
69642: LD_INT 2
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: LD_INT 2
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 1
69661: NEG
69662: PUSH
69663: LD_INT 1
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 2
69672: NEG
69673: PUSH
69674: LD_INT 0
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 2
69683: NEG
69684: PUSH
69685: LD_INT 1
69687: NEG
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: LD_INT 2
69695: NEG
69696: PUSH
69697: LD_INT 2
69699: NEG
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 2
69707: NEG
69708: PUSH
69709: LD_INT 3
69711: NEG
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: LD_INT 1
69719: NEG
69720: PUSH
69721: LD_INT 3
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 3
69731: NEG
69732: PUSH
69733: LD_INT 1
69735: NEG
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 3
69743: NEG
69744: PUSH
69745: LD_INT 2
69747: NEG
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: LIST
69760: LIST
69761: LIST
69762: LIST
69763: LIST
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: LIST
69769: LIST
69770: LIST
69771: LIST
69772: LIST
69773: LIST
69774: LIST
69775: LIST
69776: LIST
69777: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69778: LD_ADDR_VAR 0 29
69782: PUSH
69783: LD_INT 0
69785: PUSH
69786: LD_INT 0
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: LD_INT 0
69795: PUSH
69796: LD_INT 1
69798: NEG
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 1
69806: PUSH
69807: LD_INT 0
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 1
69816: PUSH
69817: LD_INT 1
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 0
69826: PUSH
69827: LD_INT 1
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: LD_INT 1
69836: NEG
69837: PUSH
69838: LD_INT 0
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 1
69847: NEG
69848: PUSH
69849: LD_INT 1
69851: NEG
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: PUSH
69857: LD_INT 1
69859: NEG
69860: PUSH
69861: LD_INT 2
69863: NEG
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 0
69871: PUSH
69872: LD_INT 2
69874: NEG
69875: PUSH
69876: EMPTY
69877: LIST
69878: LIST
69879: PUSH
69880: LD_INT 1
69882: PUSH
69883: LD_INT 1
69885: NEG
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 2
69893: PUSH
69894: LD_INT 0
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 2
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 1
69913: PUSH
69914: LD_INT 2
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 0
69923: PUSH
69924: LD_INT 2
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 1
69933: NEG
69934: PUSH
69935: LD_INT 1
69937: PUSH
69938: EMPTY
69939: LIST
69940: LIST
69941: PUSH
69942: LD_INT 2
69944: NEG
69945: PUSH
69946: LD_INT 1
69948: NEG
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: PUSH
69954: LD_INT 2
69956: NEG
69957: PUSH
69958: LD_INT 2
69960: NEG
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PUSH
69966: LD_INT 2
69968: NEG
69969: PUSH
69970: LD_INT 3
69972: NEG
69973: PUSH
69974: EMPTY
69975: LIST
69976: LIST
69977: PUSH
69978: LD_INT 2
69980: PUSH
69981: LD_INT 1
69983: NEG
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: PUSH
69989: LD_INT 3
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 1
70001: PUSH
70002: LD_INT 3
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: LD_INT 1
70011: NEG
70012: PUSH
70013: LD_INT 2
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 3
70022: NEG
70023: PUSH
70024: LD_INT 2
70026: NEG
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: LIST
70053: LIST
70054: LIST
70055: LIST
70056: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70057: LD_ADDR_VAR 0 30
70061: PUSH
70062: LD_INT 0
70064: PUSH
70065: LD_INT 0
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 0
70074: PUSH
70075: LD_INT 1
70077: NEG
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: LD_INT 1
70085: PUSH
70086: LD_INT 0
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 1
70095: PUSH
70096: LD_INT 1
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 0
70105: PUSH
70106: LD_INT 1
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: LD_INT 0
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 1
70126: NEG
70127: PUSH
70128: LD_INT 1
70130: NEG
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: PUSH
70136: LD_INT 1
70138: NEG
70139: PUSH
70140: LD_INT 2
70142: NEG
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 0
70150: PUSH
70151: LD_INT 2
70153: NEG
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 1
70161: PUSH
70162: LD_INT 1
70164: NEG
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: PUSH
70170: LD_INT 2
70172: PUSH
70173: LD_INT 0
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 2
70182: PUSH
70183: LD_INT 1
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: LD_INT 2
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 1
70202: PUSH
70203: LD_INT 2
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 1
70212: NEG
70213: PUSH
70214: LD_INT 1
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 2
70223: NEG
70224: PUSH
70225: LD_INT 0
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 2
70234: NEG
70235: PUSH
70236: LD_INT 1
70238: NEG
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 1
70246: NEG
70247: PUSH
70248: LD_INT 3
70250: NEG
70251: PUSH
70252: EMPTY
70253: LIST
70254: LIST
70255: PUSH
70256: LD_INT 1
70258: PUSH
70259: LD_INT 2
70261: NEG
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 3
70269: PUSH
70270: LD_INT 2
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: PUSH
70277: LD_INT 2
70279: PUSH
70280: LD_INT 3
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 2
70289: NEG
70290: PUSH
70291: LD_INT 1
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 3
70300: NEG
70301: PUSH
70302: LD_INT 1
70304: NEG
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70335: LD_ADDR_VAR 0 31
70339: PUSH
70340: LD_INT 0
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 0
70352: PUSH
70353: LD_INT 1
70355: NEG
70356: PUSH
70357: EMPTY
70358: LIST
70359: LIST
70360: PUSH
70361: LD_INT 1
70363: PUSH
70364: LD_INT 0
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: PUSH
70374: LD_INT 1
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 0
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: EMPTY
70388: LIST
70389: LIST
70390: PUSH
70391: LD_INT 1
70393: NEG
70394: PUSH
70395: LD_INT 0
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: PUSH
70402: LD_INT 1
70404: NEG
70405: PUSH
70406: LD_INT 1
70408: NEG
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: PUSH
70414: LD_INT 1
70416: NEG
70417: PUSH
70418: LD_INT 2
70420: NEG
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 1
70428: PUSH
70429: LD_INT 1
70431: NEG
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 2
70439: PUSH
70440: LD_INT 0
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 2
70449: PUSH
70450: LD_INT 1
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 2
70459: PUSH
70460: LD_INT 2
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 1
70469: PUSH
70470: LD_INT 2
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 0
70479: PUSH
70480: LD_INT 2
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 1
70489: NEG
70490: PUSH
70491: LD_INT 1
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: LD_INT 2
70500: NEG
70501: PUSH
70502: LD_INT 1
70504: NEG
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: PUSH
70510: LD_INT 2
70512: NEG
70513: PUSH
70514: LD_INT 2
70516: NEG
70517: PUSH
70518: EMPTY
70519: LIST
70520: LIST
70521: PUSH
70522: LD_INT 2
70524: NEG
70525: PUSH
70526: LD_INT 3
70528: NEG
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 2
70536: PUSH
70537: LD_INT 1
70539: NEG
70540: PUSH
70541: EMPTY
70542: LIST
70543: LIST
70544: PUSH
70545: LD_INT 3
70547: PUSH
70548: LD_INT 1
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 1
70557: PUSH
70558: LD_INT 3
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PUSH
70565: LD_INT 1
70567: NEG
70568: PUSH
70569: LD_INT 2
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 3
70578: NEG
70579: PUSH
70580: LD_INT 2
70582: NEG
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: LIST
70592: LIST
70593: LIST
70594: LIST
70595: LIST
70596: LIST
70597: LIST
70598: LIST
70599: LIST
70600: LIST
70601: LIST
70602: LIST
70603: LIST
70604: LIST
70605: LIST
70606: LIST
70607: LIST
70608: LIST
70609: LIST
70610: LIST
70611: LIST
70612: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70613: LD_ADDR_VAR 0 32
70617: PUSH
70618: LD_INT 0
70620: PUSH
70621: LD_INT 0
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: LD_INT 0
70630: PUSH
70631: LD_INT 1
70633: NEG
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 1
70641: PUSH
70642: LD_INT 0
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 1
70651: PUSH
70652: LD_INT 1
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: PUSH
70659: LD_INT 0
70661: PUSH
70662: LD_INT 1
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PUSH
70669: LD_INT 1
70671: NEG
70672: PUSH
70673: LD_INT 0
70675: PUSH
70676: EMPTY
70677: LIST
70678: LIST
70679: PUSH
70680: LD_INT 1
70682: NEG
70683: PUSH
70684: LD_INT 1
70686: NEG
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 1
70694: NEG
70695: PUSH
70696: LD_INT 2
70698: NEG
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 0
70706: PUSH
70707: LD_INT 2
70709: NEG
70710: PUSH
70711: EMPTY
70712: LIST
70713: LIST
70714: PUSH
70715: LD_INT 1
70717: PUSH
70718: LD_INT 1
70720: NEG
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 2
70728: PUSH
70729: LD_INT 1
70731: PUSH
70732: EMPTY
70733: LIST
70734: LIST
70735: PUSH
70736: LD_INT 2
70738: PUSH
70739: LD_INT 2
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 1
70748: PUSH
70749: LD_INT 2
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: PUSH
70756: LD_INT 0
70758: PUSH
70759: LD_INT 2
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PUSH
70766: LD_INT 1
70768: NEG
70769: PUSH
70770: LD_INT 1
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 2
70779: NEG
70780: PUSH
70781: LD_INT 0
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 2
70790: NEG
70791: PUSH
70792: LD_INT 1
70794: NEG
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 1
70802: NEG
70803: PUSH
70804: LD_INT 3
70806: NEG
70807: PUSH
70808: EMPTY
70809: LIST
70810: LIST
70811: PUSH
70812: LD_INT 1
70814: PUSH
70815: LD_INT 2
70817: NEG
70818: PUSH
70819: EMPTY
70820: LIST
70821: LIST
70822: PUSH
70823: LD_INT 3
70825: PUSH
70826: LD_INT 2
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: PUSH
70833: LD_INT 2
70835: PUSH
70836: LD_INT 3
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 2
70845: NEG
70846: PUSH
70847: LD_INT 1
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: PUSH
70854: LD_INT 3
70856: NEG
70857: PUSH
70858: LD_INT 1
70860: NEG
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: LIST
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: LIST
70875: LIST
70876: LIST
70877: LIST
70878: LIST
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: LIST
70884: LIST
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70891: LD_ADDR_VAR 0 33
70895: PUSH
70896: LD_INT 0
70898: PUSH
70899: LD_INT 0
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: PUSH
70906: LD_INT 0
70908: PUSH
70909: LD_INT 1
70911: NEG
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: PUSH
70920: LD_INT 0
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 1
70929: PUSH
70930: LD_INT 1
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 0
70939: PUSH
70940: LD_INT 1
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 1
70949: NEG
70950: PUSH
70951: LD_INT 0
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 1
70960: NEG
70961: PUSH
70962: LD_INT 1
70964: NEG
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PUSH
70970: LD_INT 1
70972: NEG
70973: PUSH
70974: LD_INT 2
70976: NEG
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 1
70984: PUSH
70985: LD_INT 1
70987: NEG
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 2
70995: PUSH
70996: LD_INT 0
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: LD_INT 2
71005: PUSH
71006: LD_INT 1
71008: PUSH
71009: EMPTY
71010: LIST
71011: LIST
71012: PUSH
71013: LD_INT 1
71015: PUSH
71016: LD_INT 2
71018: PUSH
71019: EMPTY
71020: LIST
71021: LIST
71022: PUSH
71023: LD_INT 0
71025: PUSH
71026: LD_INT 2
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 1
71035: NEG
71036: PUSH
71037: LD_INT 1
71039: PUSH
71040: EMPTY
71041: LIST
71042: LIST
71043: PUSH
71044: LD_INT 2
71046: NEG
71047: PUSH
71048: LD_INT 0
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: LD_INT 2
71057: NEG
71058: PUSH
71059: LD_INT 1
71061: NEG
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 2
71069: NEG
71070: PUSH
71071: LD_INT 2
71073: NEG
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: PUSH
71079: LD_INT 2
71081: NEG
71082: PUSH
71083: LD_INT 3
71085: NEG
71086: PUSH
71087: EMPTY
71088: LIST
71089: LIST
71090: PUSH
71091: LD_INT 2
71093: PUSH
71094: LD_INT 1
71096: NEG
71097: PUSH
71098: EMPTY
71099: LIST
71100: LIST
71101: PUSH
71102: LD_INT 3
71104: PUSH
71105: LD_INT 1
71107: PUSH
71108: EMPTY
71109: LIST
71110: LIST
71111: PUSH
71112: LD_INT 1
71114: PUSH
71115: LD_INT 3
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 1
71124: NEG
71125: PUSH
71126: LD_INT 2
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: LD_INT 3
71135: NEG
71136: PUSH
71137: LD_INT 2
71139: NEG
71140: PUSH
71141: EMPTY
71142: LIST
71143: LIST
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: LIST
71165: LIST
71166: LIST
71167: LIST
71168: LIST
71169: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71170: LD_ADDR_VAR 0 34
71174: PUSH
71175: LD_INT 0
71177: PUSH
71178: LD_INT 0
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_INT 0
71187: PUSH
71188: LD_INT 1
71190: NEG
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 1
71198: PUSH
71199: LD_INT 0
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 1
71208: PUSH
71209: LD_INT 1
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 0
71218: PUSH
71219: LD_INT 1
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: PUSH
71226: LD_INT 1
71228: NEG
71229: PUSH
71230: LD_INT 0
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 1
71239: NEG
71240: PUSH
71241: LD_INT 1
71243: NEG
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 1
71251: NEG
71252: PUSH
71253: LD_INT 2
71255: NEG
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 0
71263: PUSH
71264: LD_INT 2
71266: NEG
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: LD_INT 1
71274: PUSH
71275: LD_INT 1
71277: NEG
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 2
71285: PUSH
71286: LD_INT 1
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PUSH
71293: LD_INT 2
71295: PUSH
71296: LD_INT 2
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: LD_INT 2
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 1
71315: NEG
71316: PUSH
71317: LD_INT 1
71319: PUSH
71320: EMPTY
71321: LIST
71322: LIST
71323: PUSH
71324: LD_INT 2
71326: NEG
71327: PUSH
71328: LD_INT 0
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 2
71337: NEG
71338: PUSH
71339: LD_INT 1
71341: NEG
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PUSH
71347: LD_INT 2
71349: NEG
71350: PUSH
71351: LD_INT 2
71353: NEG
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 1
71361: NEG
71362: PUSH
71363: LD_INT 3
71365: NEG
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: PUSH
71371: LD_INT 1
71373: PUSH
71374: LD_INT 2
71376: NEG
71377: PUSH
71378: EMPTY
71379: LIST
71380: LIST
71381: PUSH
71382: LD_INT 3
71384: PUSH
71385: LD_INT 2
71387: PUSH
71388: EMPTY
71389: LIST
71390: LIST
71391: PUSH
71392: LD_INT 2
71394: PUSH
71395: LD_INT 3
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 2
71404: NEG
71405: PUSH
71406: LD_INT 1
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: PUSH
71413: LD_INT 3
71415: NEG
71416: PUSH
71417: LD_INT 1
71419: NEG
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: LIST
71449: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71450: LD_ADDR_VAR 0 35
71454: PUSH
71455: LD_INT 0
71457: PUSH
71458: LD_INT 0
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 0
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: LD_INT 0
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 1
71488: PUSH
71489: LD_INT 1
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 0
71498: PUSH
71499: LD_INT 1
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: PUSH
71506: LD_INT 1
71508: NEG
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 1
71519: NEG
71520: PUSH
71521: LD_INT 1
71523: NEG
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 2
71531: PUSH
71532: LD_INT 1
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: LD_INT 2
71541: NEG
71542: PUSH
71543: LD_INT 1
71545: NEG
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: LIST
71561: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71562: LD_ADDR_VAR 0 36
71566: PUSH
71567: LD_INT 0
71569: PUSH
71570: LD_INT 0
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 0
71579: PUSH
71580: LD_INT 1
71582: NEG
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 1
71590: PUSH
71591: LD_INT 0
71593: PUSH
71594: EMPTY
71595: LIST
71596: LIST
71597: PUSH
71598: LD_INT 1
71600: PUSH
71601: LD_INT 1
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: LD_INT 0
71610: PUSH
71611: LD_INT 1
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 1
71620: NEG
71621: PUSH
71622: LD_INT 0
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 1
71631: NEG
71632: PUSH
71633: LD_INT 1
71635: NEG
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 1
71643: NEG
71644: PUSH
71645: LD_INT 2
71647: NEG
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: PUSH
71653: LD_INT 1
71655: PUSH
71656: LD_INT 2
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: LIST
71669: LIST
71670: LIST
71671: LIST
71672: LIST
71673: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71674: LD_ADDR_VAR 0 37
71678: PUSH
71679: LD_INT 0
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 0
71691: PUSH
71692: LD_INT 1
71694: NEG
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 1
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 1
71712: PUSH
71713: LD_INT 1
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: PUSH
71720: LD_INT 0
71722: PUSH
71723: LD_INT 1
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 1
71732: NEG
71733: PUSH
71734: LD_INT 0
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 1
71743: NEG
71744: PUSH
71745: LD_INT 1
71747: NEG
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 1
71755: PUSH
71756: LD_INT 1
71758: NEG
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: PUSH
71764: LD_INT 1
71766: NEG
71767: PUSH
71768: LD_INT 1
71770: PUSH
71771: EMPTY
71772: LIST
71773: LIST
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71786: LD_ADDR_VAR 0 38
71790: PUSH
71791: LD_INT 0
71793: PUSH
71794: LD_INT 0
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 0
71803: PUSH
71804: LD_INT 1
71806: NEG
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 1
71814: PUSH
71815: LD_INT 0
71817: PUSH
71818: EMPTY
71819: LIST
71820: LIST
71821: PUSH
71822: LD_INT 1
71824: PUSH
71825: LD_INT 1
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 0
71834: PUSH
71835: LD_INT 1
71837: PUSH
71838: EMPTY
71839: LIST
71840: LIST
71841: PUSH
71842: LD_INT 1
71844: NEG
71845: PUSH
71846: LD_INT 0
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 1
71855: NEG
71856: PUSH
71857: LD_INT 1
71859: NEG
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: LD_INT 2
71867: PUSH
71868: LD_INT 1
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: PUSH
71875: LD_INT 2
71877: NEG
71878: PUSH
71879: LD_INT 1
71881: NEG
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: LIST
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: LIST
71896: LIST
71897: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71898: LD_ADDR_VAR 0 39
71902: PUSH
71903: LD_INT 0
71905: PUSH
71906: LD_INT 0
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 0
71915: PUSH
71916: LD_INT 1
71918: NEG
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 1
71926: PUSH
71927: LD_INT 0
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 1
71936: PUSH
71937: LD_INT 1
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 0
71946: PUSH
71947: LD_INT 1
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: LD_INT 1
71956: NEG
71957: PUSH
71958: LD_INT 0
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 1
71967: NEG
71968: PUSH
71969: LD_INT 1
71971: NEG
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 1
71979: NEG
71980: PUSH
71981: LD_INT 2
71983: NEG
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 1
71991: PUSH
71992: LD_INT 2
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: LIST
72005: LIST
72006: LIST
72007: LIST
72008: LIST
72009: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72010: LD_ADDR_VAR 0 40
72014: PUSH
72015: LD_INT 0
72017: PUSH
72018: LD_INT 0
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 0
72027: PUSH
72028: LD_INT 1
72030: NEG
72031: PUSH
72032: EMPTY
72033: LIST
72034: LIST
72035: PUSH
72036: LD_INT 1
72038: PUSH
72039: LD_INT 0
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 1
72048: PUSH
72049: LD_INT 1
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: LD_INT 0
72058: PUSH
72059: LD_INT 1
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: PUSH
72066: LD_INT 1
72068: NEG
72069: PUSH
72070: LD_INT 0
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: PUSH
72077: LD_INT 1
72079: NEG
72080: PUSH
72081: LD_INT 1
72083: NEG
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: LD_INT 1
72091: PUSH
72092: LD_INT 1
72094: NEG
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 1
72102: NEG
72103: PUSH
72104: LD_INT 1
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: EMPTY
72112: LIST
72113: LIST
72114: LIST
72115: LIST
72116: LIST
72117: LIST
72118: LIST
72119: LIST
72120: LIST
72121: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72122: LD_ADDR_VAR 0 41
72126: PUSH
72127: LD_INT 0
72129: PUSH
72130: LD_INT 0
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 0
72139: PUSH
72140: LD_INT 1
72142: NEG
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 1
72150: PUSH
72151: LD_INT 0
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: PUSH
72161: LD_INT 1
72163: PUSH
72164: EMPTY
72165: LIST
72166: LIST
72167: PUSH
72168: LD_INT 0
72170: PUSH
72171: LD_INT 1
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: LD_INT 1
72180: NEG
72181: PUSH
72182: LD_INT 0
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 1
72191: NEG
72192: PUSH
72193: LD_INT 1
72195: NEG
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PUSH
72201: LD_INT 1
72203: NEG
72204: PUSH
72205: LD_INT 2
72207: NEG
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 1
72215: PUSH
72216: LD_INT 1
72218: NEG
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: LD_INT 2
72226: PUSH
72227: LD_INT 0
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: PUSH
72234: LD_INT 2
72236: PUSH
72237: LD_INT 1
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 2
72246: PUSH
72247: LD_INT 2
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: LD_INT 1
72256: PUSH
72257: LD_INT 2
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 1
72266: NEG
72267: PUSH
72268: LD_INT 1
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 2
72277: NEG
72278: PUSH
72279: LD_INT 0
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PUSH
72286: LD_INT 2
72288: NEG
72289: PUSH
72290: LD_INT 1
72292: NEG
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 2
72300: NEG
72301: PUSH
72302: LD_INT 2
72304: NEG
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 2
72312: NEG
72313: PUSH
72314: LD_INT 3
72316: NEG
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 2
72324: PUSH
72325: LD_INT 1
72327: NEG
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 3
72335: PUSH
72336: LD_INT 0
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 3
72345: PUSH
72346: LD_INT 1
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: PUSH
72353: LD_INT 3
72355: PUSH
72356: LD_INT 2
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 3
72365: PUSH
72366: LD_INT 3
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PUSH
72373: LD_INT 2
72375: PUSH
72376: LD_INT 3
72378: PUSH
72379: EMPTY
72380: LIST
72381: LIST
72382: PUSH
72383: LD_INT 2
72385: NEG
72386: PUSH
72387: LD_INT 1
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: PUSH
72394: LD_INT 3
72396: NEG
72397: PUSH
72398: LD_INT 0
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 3
72407: NEG
72408: PUSH
72409: LD_INT 1
72411: NEG
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 3
72419: NEG
72420: PUSH
72421: LD_INT 2
72423: NEG
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PUSH
72429: LD_INT 3
72431: NEG
72432: PUSH
72433: LD_INT 3
72435: NEG
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72472: LD_ADDR_VAR 0 42
72476: PUSH
72477: LD_INT 0
72479: PUSH
72480: LD_INT 0
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: LD_INT 0
72489: PUSH
72490: LD_INT 1
72492: NEG
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: PUSH
72501: LD_INT 0
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: PUSH
72508: LD_INT 1
72510: PUSH
72511: LD_INT 1
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: PUSH
72518: LD_INT 0
72520: PUSH
72521: LD_INT 1
72523: PUSH
72524: EMPTY
72525: LIST
72526: LIST
72527: PUSH
72528: LD_INT 1
72530: NEG
72531: PUSH
72532: LD_INT 0
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 1
72541: NEG
72542: PUSH
72543: LD_INT 1
72545: NEG
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: PUSH
72551: LD_INT 1
72553: NEG
72554: PUSH
72555: LD_INT 2
72557: NEG
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 0
72565: PUSH
72566: LD_INT 2
72568: NEG
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: LD_INT 1
72576: PUSH
72577: LD_INT 1
72579: NEG
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 2
72587: PUSH
72588: LD_INT 1
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 2
72597: PUSH
72598: LD_INT 2
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 1
72607: PUSH
72608: LD_INT 2
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: LD_INT 0
72617: PUSH
72618: LD_INT 2
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: PUSH
72625: LD_INT 1
72627: NEG
72628: PUSH
72629: LD_INT 1
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 2
72638: NEG
72639: PUSH
72640: LD_INT 1
72642: NEG
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: LD_INT 2
72650: NEG
72651: PUSH
72652: LD_INT 2
72654: NEG
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: LD_INT 2
72662: NEG
72663: PUSH
72664: LD_INT 3
72666: NEG
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: PUSH
72672: LD_INT 1
72674: NEG
72675: PUSH
72676: LD_INT 3
72678: NEG
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: LD_INT 3
72689: NEG
72690: PUSH
72691: EMPTY
72692: LIST
72693: LIST
72694: PUSH
72695: LD_INT 1
72697: PUSH
72698: LD_INT 2
72700: NEG
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 3
72708: PUSH
72709: LD_INT 2
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 3
72718: PUSH
72719: LD_INT 3
72721: PUSH
72722: EMPTY
72723: LIST
72724: LIST
72725: PUSH
72726: LD_INT 2
72728: PUSH
72729: LD_INT 3
72731: PUSH
72732: EMPTY
72733: LIST
72734: LIST
72735: PUSH
72736: LD_INT 1
72738: PUSH
72739: LD_INT 3
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 0
72748: PUSH
72749: LD_INT 3
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 1
72758: NEG
72759: PUSH
72760: LD_INT 2
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: LD_INT 3
72769: NEG
72770: PUSH
72771: LD_INT 2
72773: NEG
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 3
72781: NEG
72782: PUSH
72783: LD_INT 3
72785: NEG
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: LIST
72795: LIST
72796: LIST
72797: LIST
72798: LIST
72799: LIST
72800: LIST
72801: LIST
72802: LIST
72803: LIST
72804: LIST
72805: LIST
72806: LIST
72807: LIST
72808: LIST
72809: LIST
72810: LIST
72811: LIST
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72822: LD_ADDR_VAR 0 43
72826: PUSH
72827: LD_INT 0
72829: PUSH
72830: LD_INT 0
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: LD_INT 0
72839: PUSH
72840: LD_INT 1
72842: NEG
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: PUSH
72848: LD_INT 1
72850: PUSH
72851: LD_INT 0
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: PUSH
72858: LD_INT 1
72860: PUSH
72861: LD_INT 1
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: LD_INT 1
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 1
72880: NEG
72881: PUSH
72882: LD_INT 0
72884: PUSH
72885: EMPTY
72886: LIST
72887: LIST
72888: PUSH
72889: LD_INT 1
72891: NEG
72892: PUSH
72893: LD_INT 1
72895: NEG
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: LD_INT 1
72903: NEG
72904: PUSH
72905: LD_INT 2
72907: NEG
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 0
72915: PUSH
72916: LD_INT 2
72918: NEG
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: PUSH
72924: LD_INT 1
72926: PUSH
72927: LD_INT 1
72929: NEG
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: PUSH
72935: LD_INT 2
72937: PUSH
72938: LD_INT 0
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: PUSH
72945: LD_INT 2
72947: PUSH
72948: LD_INT 1
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 1
72957: PUSH
72958: LD_INT 2
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: LD_INT 0
72967: PUSH
72968: LD_INT 2
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 1
72977: NEG
72978: PUSH
72979: LD_INT 1
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 2
72988: NEG
72989: PUSH
72990: LD_INT 0
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 2
72999: NEG
73000: PUSH
73001: LD_INT 1
73003: NEG
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 1
73011: NEG
73012: PUSH
73013: LD_INT 3
73015: NEG
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 0
73023: PUSH
73024: LD_INT 3
73026: NEG
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 1
73034: PUSH
73035: LD_INT 2
73037: NEG
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 2
73045: PUSH
73046: LD_INT 1
73048: NEG
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PUSH
73054: LD_INT 3
73056: PUSH
73057: LD_INT 0
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PUSH
73064: LD_INT 3
73066: PUSH
73067: LD_INT 1
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: LD_INT 1
73076: PUSH
73077: LD_INT 3
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: PUSH
73084: LD_INT 0
73086: PUSH
73087: LD_INT 3
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 1
73096: NEG
73097: PUSH
73098: LD_INT 2
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 2
73107: NEG
73108: PUSH
73109: LD_INT 1
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 3
73118: NEG
73119: PUSH
73120: LD_INT 0
73122: PUSH
73123: EMPTY
73124: LIST
73125: LIST
73126: PUSH
73127: LD_INT 3
73129: NEG
73130: PUSH
73131: LD_INT 1
73133: NEG
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: EMPTY
73140: LIST
73141: LIST
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: LIST
73155: LIST
73156: LIST
73157: LIST
73158: LIST
73159: LIST
73160: LIST
73161: LIST
73162: LIST
73163: LIST
73164: LIST
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73170: LD_ADDR_VAR 0 44
73174: PUSH
73175: LD_INT 0
73177: PUSH
73178: LD_INT 0
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 0
73187: PUSH
73188: LD_INT 1
73190: NEG
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 1
73198: PUSH
73199: LD_INT 0
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PUSH
73206: LD_INT 1
73208: PUSH
73209: LD_INT 1
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 0
73218: PUSH
73219: LD_INT 1
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: PUSH
73226: LD_INT 1
73228: NEG
73229: PUSH
73230: LD_INT 0
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 1
73239: NEG
73240: PUSH
73241: LD_INT 1
73243: NEG
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: LD_INT 1
73251: NEG
73252: PUSH
73253: LD_INT 2
73255: NEG
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: PUSH
73261: LD_INT 1
73263: PUSH
73264: LD_INT 1
73266: NEG
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: LD_INT 2
73274: PUSH
73275: LD_INT 0
73277: PUSH
73278: EMPTY
73279: LIST
73280: LIST
73281: PUSH
73282: LD_INT 2
73284: PUSH
73285: LD_INT 1
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PUSH
73292: LD_INT 2
73294: PUSH
73295: LD_INT 2
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 1
73304: PUSH
73305: LD_INT 2
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 1
73314: NEG
73315: PUSH
73316: LD_INT 1
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 2
73325: NEG
73326: PUSH
73327: LD_INT 0
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 2
73336: NEG
73337: PUSH
73338: LD_INT 1
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 2
73348: NEG
73349: PUSH
73350: LD_INT 2
73352: NEG
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: PUSH
73358: LD_INT 2
73360: NEG
73361: PUSH
73362: LD_INT 3
73364: NEG
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 2
73372: PUSH
73373: LD_INT 1
73375: NEG
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 3
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: LD_INT 3
73393: PUSH
73394: LD_INT 1
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: PUSH
73401: LD_INT 3
73403: PUSH
73404: LD_INT 2
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 3
73413: PUSH
73414: LD_INT 3
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 2
73423: PUSH
73424: LD_INT 3
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 2
73433: NEG
73434: PUSH
73435: LD_INT 1
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: PUSH
73442: LD_INT 3
73444: NEG
73445: PUSH
73446: LD_INT 0
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 3
73455: NEG
73456: PUSH
73457: LD_INT 1
73459: NEG
73460: PUSH
73461: EMPTY
73462: LIST
73463: LIST
73464: PUSH
73465: LD_INT 3
73467: NEG
73468: PUSH
73469: LD_INT 2
73471: NEG
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: LD_INT 3
73479: NEG
73480: PUSH
73481: LD_INT 3
73483: NEG
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: LIST
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: LIST
73498: LIST
73499: LIST
73500: LIST
73501: LIST
73502: LIST
73503: LIST
73504: LIST
73505: LIST
73506: LIST
73507: LIST
73508: LIST
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73520: LD_ADDR_VAR 0 45
73524: PUSH
73525: LD_INT 0
73527: PUSH
73528: LD_INT 0
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PUSH
73535: LD_INT 0
73537: PUSH
73538: LD_INT 1
73540: NEG
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 1
73548: PUSH
73549: LD_INT 0
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 1
73558: PUSH
73559: LD_INT 1
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 0
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 1
73578: NEG
73579: PUSH
73580: LD_INT 0
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 1
73589: NEG
73590: PUSH
73591: LD_INT 1
73593: NEG
73594: PUSH
73595: EMPTY
73596: LIST
73597: LIST
73598: PUSH
73599: LD_INT 1
73601: NEG
73602: PUSH
73603: LD_INT 2
73605: NEG
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: LD_INT 0
73613: PUSH
73614: LD_INT 2
73616: NEG
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: PUSH
73622: LD_INT 1
73624: PUSH
73625: LD_INT 1
73627: NEG
73628: PUSH
73629: EMPTY
73630: LIST
73631: LIST
73632: PUSH
73633: LD_INT 2
73635: PUSH
73636: LD_INT 1
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: LD_INT 2
73645: PUSH
73646: LD_INT 2
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: PUSH
73653: LD_INT 1
73655: PUSH
73656: LD_INT 2
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: LD_INT 0
73665: PUSH
73666: LD_INT 2
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 1
73675: NEG
73676: PUSH
73677: LD_INT 1
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 2
73686: NEG
73687: PUSH
73688: LD_INT 1
73690: NEG
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 2
73698: NEG
73699: PUSH
73700: LD_INT 2
73702: NEG
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: LD_INT 2
73710: NEG
73711: PUSH
73712: LD_INT 3
73714: NEG
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: LD_INT 3
73726: NEG
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: LD_INT 3
73737: NEG
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 1
73745: PUSH
73746: LD_INT 2
73748: NEG
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: LD_INT 3
73756: PUSH
73757: LD_INT 2
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 3
73766: PUSH
73767: LD_INT 3
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PUSH
73774: LD_INT 2
73776: PUSH
73777: LD_INT 3
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: LD_INT 1
73786: PUSH
73787: LD_INT 3
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: LD_INT 3
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 1
73806: NEG
73807: PUSH
73808: LD_INT 2
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 3
73817: NEG
73818: PUSH
73819: LD_INT 2
73821: NEG
73822: PUSH
73823: EMPTY
73824: LIST
73825: LIST
73826: PUSH
73827: LD_INT 3
73829: NEG
73830: PUSH
73831: LD_INT 3
73833: NEG
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: LIST
73846: LIST
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: LIST
73854: LIST
73855: LIST
73856: LIST
73857: LIST
73858: LIST
73859: LIST
73860: LIST
73861: LIST
73862: LIST
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73870: LD_ADDR_VAR 0 46
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: LD_INT 0
73880: PUSH
73881: EMPTY
73882: LIST
73883: LIST
73884: PUSH
73885: LD_INT 0
73887: PUSH
73888: LD_INT 1
73890: NEG
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 1
73898: PUSH
73899: LD_INT 0
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PUSH
73906: LD_INT 1
73908: PUSH
73909: LD_INT 1
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: PUSH
73916: LD_INT 0
73918: PUSH
73919: LD_INT 1
73921: PUSH
73922: EMPTY
73923: LIST
73924: LIST
73925: PUSH
73926: LD_INT 1
73928: NEG
73929: PUSH
73930: LD_INT 0
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 1
73939: NEG
73940: PUSH
73941: LD_INT 1
73943: NEG
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 1
73951: NEG
73952: PUSH
73953: LD_INT 2
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: LD_INT 2
73966: NEG
73967: PUSH
73968: EMPTY
73969: LIST
73970: LIST
73971: PUSH
73972: LD_INT 1
73974: PUSH
73975: LD_INT 1
73977: NEG
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PUSH
73983: LD_INT 2
73985: PUSH
73986: LD_INT 0
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: LD_INT 2
73995: PUSH
73996: LD_INT 1
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: PUSH
74003: LD_INT 1
74005: PUSH
74006: LD_INT 2
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 0
74015: PUSH
74016: LD_INT 2
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 1
74025: NEG
74026: PUSH
74027: LD_INT 1
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 2
74036: NEG
74037: PUSH
74038: LD_INT 0
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: PUSH
74045: LD_INT 2
74047: NEG
74048: PUSH
74049: LD_INT 1
74051: NEG
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 1
74059: NEG
74060: PUSH
74061: LD_INT 3
74063: NEG
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: PUSH
74069: LD_INT 0
74071: PUSH
74072: LD_INT 3
74074: NEG
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: LD_INT 1
74082: PUSH
74083: LD_INT 2
74085: NEG
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 2
74093: PUSH
74094: LD_INT 1
74096: NEG
74097: PUSH
74098: EMPTY
74099: LIST
74100: LIST
74101: PUSH
74102: LD_INT 3
74104: PUSH
74105: LD_INT 0
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: LD_INT 3
74114: PUSH
74115: LD_INT 1
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 1
74124: PUSH
74125: LD_INT 3
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: PUSH
74132: LD_INT 0
74134: PUSH
74135: LD_INT 3
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: LD_INT 2
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 2
74155: NEG
74156: PUSH
74157: LD_INT 1
74159: PUSH
74160: EMPTY
74161: LIST
74162: LIST
74163: PUSH
74164: LD_INT 3
74166: NEG
74167: PUSH
74168: LD_INT 0
74170: PUSH
74171: EMPTY
74172: LIST
74173: LIST
74174: PUSH
74175: LD_INT 3
74177: NEG
74178: PUSH
74179: LD_INT 1
74181: NEG
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: LIST
74196: LIST
74197: LIST
74198: LIST
74199: LIST
74200: LIST
74201: LIST
74202: LIST
74203: LIST
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: LIST
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: LIST
74217: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74218: LD_ADDR_VAR 0 47
74222: PUSH
74223: LD_INT 0
74225: PUSH
74226: LD_INT 0
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 0
74235: PUSH
74236: LD_INT 1
74238: NEG
74239: PUSH
74240: EMPTY
74241: LIST
74242: LIST
74243: PUSH
74244: LD_INT 1
74246: PUSH
74247: LD_INT 0
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PUSH
74254: LD_INT 1
74256: PUSH
74257: LD_INT 1
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 0
74266: PUSH
74267: LD_INT 1
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 1
74276: NEG
74277: PUSH
74278: LD_INT 0
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PUSH
74285: LD_INT 1
74287: NEG
74288: PUSH
74289: LD_INT 1
74291: NEG
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: LD_INT 1
74299: NEG
74300: PUSH
74301: LD_INT 2
74303: NEG
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 0
74311: PUSH
74312: LD_INT 2
74314: NEG
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 1
74322: PUSH
74323: LD_INT 1
74325: NEG
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 2
74333: NEG
74334: PUSH
74335: LD_INT 1
74337: NEG
74338: PUSH
74339: EMPTY
74340: LIST
74341: LIST
74342: PUSH
74343: LD_INT 2
74345: NEG
74346: PUSH
74347: LD_INT 2
74349: NEG
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: LIST
74359: LIST
74360: LIST
74361: LIST
74362: LIST
74363: LIST
74364: LIST
74365: LIST
74366: LIST
74367: LIST
74368: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74369: LD_ADDR_VAR 0 48
74373: PUSH
74374: LD_INT 0
74376: PUSH
74377: LD_INT 0
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 0
74386: PUSH
74387: LD_INT 1
74389: NEG
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 1
74397: PUSH
74398: LD_INT 0
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 1
74407: PUSH
74408: LD_INT 1
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 0
74417: PUSH
74418: LD_INT 1
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 1
74427: NEG
74428: PUSH
74429: LD_INT 0
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: PUSH
74436: LD_INT 1
74438: NEG
74439: PUSH
74440: LD_INT 1
74442: NEG
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: LD_INT 1
74450: NEG
74451: PUSH
74452: LD_INT 2
74454: NEG
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 0
74462: PUSH
74463: LD_INT 2
74465: NEG
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: LD_INT 1
74473: PUSH
74474: LD_INT 1
74476: NEG
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PUSH
74482: LD_INT 2
74484: PUSH
74485: LD_INT 0
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 2
74494: PUSH
74495: LD_INT 1
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74516: LD_ADDR_VAR 0 49
74520: PUSH
74521: LD_INT 0
74523: PUSH
74524: LD_INT 0
74526: PUSH
74527: EMPTY
74528: LIST
74529: LIST
74530: PUSH
74531: LD_INT 0
74533: PUSH
74534: LD_INT 1
74536: NEG
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 1
74544: PUSH
74545: LD_INT 0
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: LD_INT 1
74554: PUSH
74555: LD_INT 1
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 0
74564: PUSH
74565: LD_INT 1
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 1
74574: NEG
74575: PUSH
74576: LD_INT 0
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: PUSH
74583: LD_INT 1
74585: NEG
74586: PUSH
74587: LD_INT 1
74589: NEG
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 1
74597: PUSH
74598: LD_INT 1
74600: NEG
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 2
74608: PUSH
74609: LD_INT 0
74611: PUSH
74612: EMPTY
74613: LIST
74614: LIST
74615: PUSH
74616: LD_INT 2
74618: PUSH
74619: LD_INT 1
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: PUSH
74626: LD_INT 2
74628: PUSH
74629: LD_INT 2
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 1
74638: PUSH
74639: LD_INT 2
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: LIST
74650: LIST
74651: LIST
74652: LIST
74653: LIST
74654: LIST
74655: LIST
74656: LIST
74657: LIST
74658: LIST
74659: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74660: LD_ADDR_VAR 0 50
74664: PUSH
74665: LD_INT 0
74667: PUSH
74668: LD_INT 0
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: PUSH
74675: LD_INT 0
74677: PUSH
74678: LD_INT 1
74680: NEG
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: PUSH
74686: LD_INT 1
74688: PUSH
74689: LD_INT 0
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 1
74698: PUSH
74699: LD_INT 1
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: LD_INT 0
74708: PUSH
74709: LD_INT 1
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PUSH
74716: LD_INT 1
74718: NEG
74719: PUSH
74720: LD_INT 0
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 1
74729: NEG
74730: PUSH
74731: LD_INT 1
74733: NEG
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: PUSH
74739: LD_INT 2
74741: PUSH
74742: LD_INT 1
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 2
74751: PUSH
74752: LD_INT 2
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: LD_INT 1
74761: PUSH
74762: LD_INT 2
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: LD_INT 2
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 1
74781: NEG
74782: PUSH
74783: LD_INT 1
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: EMPTY
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: LIST
74796: LIST
74797: LIST
74798: LIST
74799: LIST
74800: LIST
74801: LIST
74802: LIST
74803: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74804: LD_ADDR_VAR 0 51
74808: PUSH
74809: LD_INT 0
74811: PUSH
74812: LD_INT 0
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 0
74821: PUSH
74822: LD_INT 1
74824: NEG
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PUSH
74830: LD_INT 1
74832: PUSH
74833: LD_INT 0
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: LD_INT 1
74842: PUSH
74843: LD_INT 1
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: LD_INT 0
74852: PUSH
74853: LD_INT 1
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: PUSH
74860: LD_INT 1
74862: NEG
74863: PUSH
74864: LD_INT 0
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 1
74873: NEG
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: LD_INT 1
74885: PUSH
74886: LD_INT 2
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 0
74895: PUSH
74896: LD_INT 2
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 1
74905: NEG
74906: PUSH
74907: LD_INT 1
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 2
74916: NEG
74917: PUSH
74918: LD_INT 0
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: LD_INT 2
74927: NEG
74928: PUSH
74929: LD_INT 1
74931: NEG
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: LIST
74950: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74951: LD_ADDR_VAR 0 52
74955: PUSH
74956: LD_INT 0
74958: PUSH
74959: LD_INT 0
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 0
74968: PUSH
74969: LD_INT 1
74971: NEG
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: LD_INT 1
74979: PUSH
74980: LD_INT 0
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: LD_INT 1
74989: PUSH
74990: LD_INT 1
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: LD_INT 1
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 1
75009: NEG
75010: PUSH
75011: LD_INT 0
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: LD_INT 1
75020: NEG
75021: PUSH
75022: LD_INT 1
75024: NEG
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: LD_INT 1
75032: NEG
75033: PUSH
75034: LD_INT 2
75036: NEG
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 1
75044: NEG
75045: PUSH
75046: LD_INT 1
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 2
75055: NEG
75056: PUSH
75057: LD_INT 0
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 2
75066: NEG
75067: PUSH
75068: LD_INT 1
75070: NEG
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 2
75078: NEG
75079: PUSH
75080: LD_INT 2
75082: NEG
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: LIST
75092: LIST
75093: LIST
75094: LIST
75095: LIST
75096: LIST
75097: LIST
75098: LIST
75099: LIST
75100: LIST
75101: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75102: LD_ADDR_VAR 0 53
75106: PUSH
75107: LD_INT 0
75109: PUSH
75110: LD_INT 0
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: LD_INT 1
75122: NEG
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 1
75130: PUSH
75131: LD_INT 0
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 1
75140: PUSH
75141: LD_INT 1
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: LD_INT 1
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 1
75160: NEG
75161: PUSH
75162: LD_INT 0
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 1
75171: NEG
75172: PUSH
75173: LD_INT 1
75175: NEG
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: LD_INT 1
75183: NEG
75184: PUSH
75185: LD_INT 2
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 0
75195: PUSH
75196: LD_INT 2
75198: NEG
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 1
75206: PUSH
75207: LD_INT 1
75209: NEG
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PUSH
75215: LD_INT 2
75217: PUSH
75218: LD_INT 0
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: PUSH
75225: LD_INT 2
75227: PUSH
75228: LD_INT 1
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: LD_INT 2
75237: PUSH
75238: LD_INT 2
75240: PUSH
75241: EMPTY
75242: LIST
75243: LIST
75244: PUSH
75245: LD_INT 1
75247: PUSH
75248: LD_INT 2
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: PUSH
75255: LD_INT 0
75257: PUSH
75258: LD_INT 2
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 1
75267: NEG
75268: PUSH
75269: LD_INT 1
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 2
75278: NEG
75279: PUSH
75280: LD_INT 0
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PUSH
75287: LD_INT 2
75289: NEG
75290: PUSH
75291: LD_INT 1
75293: NEG
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 2
75301: NEG
75302: PUSH
75303: LD_INT 2
75305: NEG
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: LIST
75315: LIST
75316: LIST
75317: LIST
75318: LIST
75319: LIST
75320: LIST
75321: LIST
75322: LIST
75323: LIST
75324: LIST
75325: LIST
75326: LIST
75327: LIST
75328: LIST
75329: LIST
75330: LIST
75331: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75332: LD_ADDR_VAR 0 54
75336: PUSH
75337: LD_INT 0
75339: PUSH
75340: LD_INT 0
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: LD_INT 0
75349: PUSH
75350: LD_INT 1
75352: NEG
75353: PUSH
75354: EMPTY
75355: LIST
75356: LIST
75357: PUSH
75358: LD_INT 1
75360: PUSH
75361: LD_INT 0
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 1
75370: PUSH
75371: LD_INT 1
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 0
75380: PUSH
75381: LD_INT 1
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 1
75390: NEG
75391: PUSH
75392: LD_INT 0
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 1
75401: NEG
75402: PUSH
75403: LD_INT 1
75405: NEG
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 1
75413: NEG
75414: PUSH
75415: LD_INT 2
75417: NEG
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 0
75425: PUSH
75426: LD_INT 2
75428: NEG
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PUSH
75434: LD_INT 1
75436: PUSH
75437: LD_INT 1
75439: NEG
75440: PUSH
75441: EMPTY
75442: LIST
75443: LIST
75444: PUSH
75445: LD_INT 2
75447: PUSH
75448: LD_INT 0
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: LD_INT 2
75457: PUSH
75458: LD_INT 1
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 2
75467: PUSH
75468: LD_INT 2
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: PUSH
75475: LD_INT 1
75477: PUSH
75478: LD_INT 2
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: LD_INT 0
75487: PUSH
75488: LD_INT 2
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 1
75497: NEG
75498: PUSH
75499: LD_INT 1
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 2
75508: NEG
75509: PUSH
75510: LD_INT 0
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 2
75519: NEG
75520: PUSH
75521: LD_INT 1
75523: NEG
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 2
75531: NEG
75532: PUSH
75533: LD_INT 2
75535: NEG
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: LIST
75545: LIST
75546: LIST
75547: LIST
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75562: LD_ADDR_VAR 0 55
75566: PUSH
75567: LD_INT 0
75569: PUSH
75570: LD_INT 0
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 0
75579: PUSH
75580: LD_INT 1
75582: NEG
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 1
75590: PUSH
75591: LD_INT 0
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: LD_INT 1
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 0
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 1
75620: NEG
75621: PUSH
75622: LD_INT 0
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 1
75631: NEG
75632: PUSH
75633: LD_INT 1
75635: NEG
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 1
75643: NEG
75644: PUSH
75645: LD_INT 2
75647: NEG
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 0
75655: PUSH
75656: LD_INT 2
75658: NEG
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: LD_INT 1
75666: PUSH
75667: LD_INT 1
75669: NEG
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: LD_INT 0
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 2
75687: PUSH
75688: LD_INT 1
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PUSH
75695: LD_INT 2
75697: PUSH
75698: LD_INT 2
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 1
75707: PUSH
75708: LD_INT 2
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: LD_INT 0
75717: PUSH
75718: LD_INT 2
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 1
75727: NEG
75728: PUSH
75729: LD_INT 1
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: PUSH
75736: LD_INT 2
75738: NEG
75739: PUSH
75740: LD_INT 0
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: PUSH
75747: LD_INT 2
75749: NEG
75750: PUSH
75751: LD_INT 1
75753: NEG
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: LD_INT 2
75761: NEG
75762: PUSH
75763: LD_INT 2
75765: NEG
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: LIST
75775: LIST
75776: LIST
75777: LIST
75778: LIST
75779: LIST
75780: LIST
75781: LIST
75782: LIST
75783: LIST
75784: LIST
75785: LIST
75786: LIST
75787: LIST
75788: LIST
75789: LIST
75790: LIST
75791: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75792: LD_ADDR_VAR 0 56
75796: PUSH
75797: LD_INT 0
75799: PUSH
75800: LD_INT 0
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: PUSH
75807: LD_INT 0
75809: PUSH
75810: LD_INT 1
75812: NEG
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_INT 1
75820: PUSH
75821: LD_INT 0
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 1
75830: PUSH
75831: LD_INT 1
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: LD_INT 0
75840: PUSH
75841: LD_INT 1
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 1
75850: NEG
75851: PUSH
75852: LD_INT 0
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PUSH
75859: LD_INT 1
75861: NEG
75862: PUSH
75863: LD_INT 1
75865: NEG
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: PUSH
75871: LD_INT 1
75873: NEG
75874: PUSH
75875: LD_INT 2
75877: NEG
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 0
75885: PUSH
75886: LD_INT 2
75888: NEG
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: PUSH
75894: LD_INT 1
75896: PUSH
75897: LD_INT 1
75899: NEG
75900: PUSH
75901: EMPTY
75902: LIST
75903: LIST
75904: PUSH
75905: LD_INT 2
75907: PUSH
75908: LD_INT 0
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: PUSH
75915: LD_INT 2
75917: PUSH
75918: LD_INT 1
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PUSH
75925: LD_INT 2
75927: PUSH
75928: LD_INT 2
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 1
75937: PUSH
75938: LD_INT 2
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 0
75947: PUSH
75948: LD_INT 2
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 1
75957: NEG
75958: PUSH
75959: LD_INT 1
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 2
75968: NEG
75969: PUSH
75970: LD_INT 0
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 2
75979: NEG
75980: PUSH
75981: LD_INT 1
75983: NEG
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 2
75991: NEG
75992: PUSH
75993: LD_INT 2
75995: NEG
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: LIST
76005: LIST
76006: LIST
76007: LIST
76008: LIST
76009: LIST
76010: LIST
76011: LIST
76012: LIST
76013: LIST
76014: LIST
76015: LIST
76016: LIST
76017: LIST
76018: LIST
76019: LIST
76020: LIST
76021: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76022: LD_ADDR_VAR 0 57
76026: PUSH
76027: LD_INT 0
76029: PUSH
76030: LD_INT 0
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 0
76039: PUSH
76040: LD_INT 1
76042: NEG
76043: PUSH
76044: EMPTY
76045: LIST
76046: LIST
76047: PUSH
76048: LD_INT 1
76050: PUSH
76051: LD_INT 0
76053: PUSH
76054: EMPTY
76055: LIST
76056: LIST
76057: PUSH
76058: LD_INT 1
76060: PUSH
76061: LD_INT 1
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PUSH
76068: LD_INT 0
76070: PUSH
76071: LD_INT 1
76073: PUSH
76074: EMPTY
76075: LIST
76076: LIST
76077: PUSH
76078: LD_INT 1
76080: NEG
76081: PUSH
76082: LD_INT 0
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: PUSH
76089: LD_INT 1
76091: NEG
76092: PUSH
76093: LD_INT 1
76095: NEG
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PUSH
76101: LD_INT 1
76103: NEG
76104: PUSH
76105: LD_INT 2
76107: NEG
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 0
76115: PUSH
76116: LD_INT 2
76118: NEG
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 1
76126: PUSH
76127: LD_INT 1
76129: NEG
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: LD_INT 2
76137: PUSH
76138: LD_INT 0
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: LD_INT 2
76147: PUSH
76148: LD_INT 1
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: PUSH
76155: LD_INT 2
76157: PUSH
76158: LD_INT 2
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 1
76167: PUSH
76168: LD_INT 2
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 0
76177: PUSH
76178: LD_INT 2
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: LD_INT 1
76187: NEG
76188: PUSH
76189: LD_INT 1
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 2
76198: NEG
76199: PUSH
76200: LD_INT 0
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 2
76209: NEG
76210: PUSH
76211: LD_INT 1
76213: NEG
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 2
76221: NEG
76222: PUSH
76223: LD_INT 2
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: LIST
76235: LIST
76236: LIST
76237: LIST
76238: LIST
76239: LIST
76240: LIST
76241: LIST
76242: LIST
76243: LIST
76244: LIST
76245: LIST
76246: LIST
76247: LIST
76248: LIST
76249: LIST
76250: LIST
76251: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76252: LD_ADDR_VAR 0 58
76256: PUSH
76257: LD_INT 0
76259: PUSH
76260: LD_INT 0
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 0
76269: PUSH
76270: LD_INT 1
76272: NEG
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: LD_INT 1
76280: PUSH
76281: LD_INT 0
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: PUSH
76288: LD_INT 1
76290: PUSH
76291: LD_INT 1
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 0
76300: PUSH
76301: LD_INT 1
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: LD_INT 1
76310: NEG
76311: PUSH
76312: LD_INT 0
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: PUSH
76319: LD_INT 1
76321: NEG
76322: PUSH
76323: LD_INT 1
76325: NEG
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 1
76333: NEG
76334: PUSH
76335: LD_INT 2
76337: NEG
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 0
76345: PUSH
76346: LD_INT 2
76348: NEG
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 1
76356: PUSH
76357: LD_INT 1
76359: NEG
76360: PUSH
76361: EMPTY
76362: LIST
76363: LIST
76364: PUSH
76365: LD_INT 2
76367: PUSH
76368: LD_INT 0
76370: PUSH
76371: EMPTY
76372: LIST
76373: LIST
76374: PUSH
76375: LD_INT 2
76377: PUSH
76378: LD_INT 1
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 2
76387: PUSH
76388: LD_INT 2
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 1
76397: PUSH
76398: LD_INT 2
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PUSH
76405: LD_INT 0
76407: PUSH
76408: LD_INT 2
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: LD_INT 1
76417: NEG
76418: PUSH
76419: LD_INT 1
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 2
76428: NEG
76429: PUSH
76430: LD_INT 0
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 2
76439: NEG
76440: PUSH
76441: LD_INT 1
76443: NEG
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 2
76451: NEG
76452: PUSH
76453: LD_INT 2
76455: NEG
76456: PUSH
76457: EMPTY
76458: LIST
76459: LIST
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: LIST
76465: LIST
76466: LIST
76467: LIST
76468: LIST
76469: LIST
76470: LIST
76471: LIST
76472: LIST
76473: LIST
76474: LIST
76475: LIST
76476: LIST
76477: LIST
76478: LIST
76479: LIST
76480: LIST
76481: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76482: LD_ADDR_VAR 0 59
76486: PUSH
76487: LD_INT 0
76489: PUSH
76490: LD_INT 0
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 0
76499: PUSH
76500: LD_INT 1
76502: NEG
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 1
76510: PUSH
76511: LD_INT 0
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 1
76520: PUSH
76521: LD_INT 1
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 0
76530: PUSH
76531: LD_INT 1
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 1
76540: NEG
76541: PUSH
76542: LD_INT 0
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: LD_INT 1
76551: NEG
76552: PUSH
76553: LD_INT 1
76555: NEG
76556: PUSH
76557: EMPTY
76558: LIST
76559: LIST
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: LIST
76565: LIST
76566: LIST
76567: LIST
76568: LIST
76569: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76570: LD_ADDR_VAR 0 60
76574: PUSH
76575: LD_INT 0
76577: PUSH
76578: LD_INT 0
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: LD_INT 0
76587: PUSH
76588: LD_INT 1
76590: NEG
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 1
76598: PUSH
76599: LD_INT 0
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 1
76608: PUSH
76609: LD_INT 1
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 0
76618: PUSH
76619: LD_INT 1
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 1
76628: NEG
76629: PUSH
76630: LD_INT 0
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: LD_INT 1
76639: NEG
76640: PUSH
76641: LD_INT 1
76643: NEG
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76658: LD_ADDR_VAR 0 61
76662: PUSH
76663: LD_INT 0
76665: PUSH
76666: LD_INT 0
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 0
76675: PUSH
76676: LD_INT 1
76678: NEG
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: LD_INT 1
76686: PUSH
76687: LD_INT 0
76689: PUSH
76690: EMPTY
76691: LIST
76692: LIST
76693: PUSH
76694: LD_INT 1
76696: PUSH
76697: LD_INT 1
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: PUSH
76704: LD_INT 0
76706: PUSH
76707: LD_INT 1
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 1
76716: NEG
76717: PUSH
76718: LD_INT 0
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: LD_INT 1
76727: NEG
76728: PUSH
76729: LD_INT 1
76731: NEG
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: LIST
76741: LIST
76742: LIST
76743: LIST
76744: LIST
76745: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76746: LD_ADDR_VAR 0 62
76750: PUSH
76751: LD_INT 0
76753: PUSH
76754: LD_INT 0
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: LD_INT 0
76763: PUSH
76764: LD_INT 1
76766: NEG
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PUSH
76772: LD_INT 1
76774: PUSH
76775: LD_INT 0
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 1
76784: PUSH
76785: LD_INT 1
76787: PUSH
76788: EMPTY
76789: LIST
76790: LIST
76791: PUSH
76792: LD_INT 0
76794: PUSH
76795: LD_INT 1
76797: PUSH
76798: EMPTY
76799: LIST
76800: LIST
76801: PUSH
76802: LD_INT 1
76804: NEG
76805: PUSH
76806: LD_INT 0
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 1
76815: NEG
76816: PUSH
76817: LD_INT 1
76819: NEG
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: LIST
76829: LIST
76830: LIST
76831: LIST
76832: LIST
76833: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76834: LD_ADDR_VAR 0 63
76838: PUSH
76839: LD_INT 0
76841: PUSH
76842: LD_INT 0
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 0
76851: PUSH
76852: LD_INT 1
76854: NEG
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 1
76862: PUSH
76863: LD_INT 0
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 1
76872: PUSH
76873: LD_INT 1
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 0
76882: PUSH
76883: LD_INT 1
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 1
76892: NEG
76893: PUSH
76894: LD_INT 0
76896: PUSH
76897: EMPTY
76898: LIST
76899: LIST
76900: PUSH
76901: LD_INT 1
76903: NEG
76904: PUSH
76905: LD_INT 1
76907: NEG
76908: PUSH
76909: EMPTY
76910: LIST
76911: LIST
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76922: LD_ADDR_VAR 0 64
76926: PUSH
76927: LD_INT 0
76929: PUSH
76930: LD_INT 0
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 0
76939: PUSH
76940: LD_INT 1
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 1
76950: PUSH
76951: LD_INT 0
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: LD_INT 1
76960: PUSH
76961: LD_INT 1
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 0
76970: PUSH
76971: LD_INT 1
76973: PUSH
76974: EMPTY
76975: LIST
76976: LIST
76977: PUSH
76978: LD_INT 1
76980: NEG
76981: PUSH
76982: LD_INT 0
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: LD_INT 1
76991: NEG
76992: PUSH
76993: LD_INT 1
76995: NEG
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: LIST
77005: LIST
77006: LIST
77007: LIST
77008: LIST
77009: ST_TO_ADDR
// end ; 1 :
77010: GO 82907
77012: LD_INT 1
77014: DOUBLE
77015: EQUAL
77016: IFTRUE 77020
77018: GO 79643
77020: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77021: LD_ADDR_VAR 0 11
77025: PUSH
77026: LD_INT 1
77028: NEG
77029: PUSH
77030: LD_INT 3
77032: NEG
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 0
77040: PUSH
77041: LD_INT 3
77043: NEG
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 1
77051: PUSH
77052: LD_INT 2
77054: NEG
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: LIST
77064: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77065: LD_ADDR_VAR 0 12
77069: PUSH
77070: LD_INT 2
77072: PUSH
77073: LD_INT 1
77075: NEG
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: PUSH
77081: LD_INT 3
77083: PUSH
77084: LD_INT 0
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: PUSH
77091: LD_INT 3
77093: PUSH
77094: LD_INT 1
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: LIST
77105: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77106: LD_ADDR_VAR 0 13
77110: PUSH
77111: LD_INT 3
77113: PUSH
77114: LD_INT 2
77116: PUSH
77117: EMPTY
77118: LIST
77119: LIST
77120: PUSH
77121: LD_INT 3
77123: PUSH
77124: LD_INT 3
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: PUSH
77131: LD_INT 2
77133: PUSH
77134: LD_INT 3
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: LIST
77145: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77146: LD_ADDR_VAR 0 14
77150: PUSH
77151: LD_INT 1
77153: PUSH
77154: LD_INT 3
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: LD_INT 0
77163: PUSH
77164: LD_INT 3
77166: PUSH
77167: EMPTY
77168: LIST
77169: LIST
77170: PUSH
77171: LD_INT 1
77173: NEG
77174: PUSH
77175: LD_INT 2
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: LIST
77186: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77187: LD_ADDR_VAR 0 15
77191: PUSH
77192: LD_INT 2
77194: NEG
77195: PUSH
77196: LD_INT 1
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PUSH
77203: LD_INT 3
77205: NEG
77206: PUSH
77207: LD_INT 0
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 3
77216: NEG
77217: PUSH
77218: LD_INT 1
77220: NEG
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: LIST
77230: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77231: LD_ADDR_VAR 0 16
77235: PUSH
77236: LD_INT 2
77238: NEG
77239: PUSH
77240: LD_INT 3
77242: NEG
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: LD_INT 3
77250: NEG
77251: PUSH
77252: LD_INT 2
77254: NEG
77255: PUSH
77256: EMPTY
77257: LIST
77258: LIST
77259: PUSH
77260: LD_INT 3
77262: NEG
77263: PUSH
77264: LD_INT 3
77266: NEG
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: LIST
77276: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77277: LD_ADDR_VAR 0 17
77281: PUSH
77282: LD_INT 1
77284: NEG
77285: PUSH
77286: LD_INT 3
77288: NEG
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 0
77296: PUSH
77297: LD_INT 3
77299: NEG
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: LD_INT 1
77307: PUSH
77308: LD_INT 2
77310: NEG
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: LIST
77320: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77321: LD_ADDR_VAR 0 18
77325: PUSH
77326: LD_INT 2
77328: PUSH
77329: LD_INT 1
77331: NEG
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PUSH
77337: LD_INT 3
77339: PUSH
77340: LD_INT 0
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PUSH
77347: LD_INT 3
77349: PUSH
77350: LD_INT 1
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: LIST
77361: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77362: LD_ADDR_VAR 0 19
77366: PUSH
77367: LD_INT 3
77369: PUSH
77370: LD_INT 2
77372: PUSH
77373: EMPTY
77374: LIST
77375: LIST
77376: PUSH
77377: LD_INT 3
77379: PUSH
77380: LD_INT 3
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: LD_INT 2
77389: PUSH
77390: LD_INT 3
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: LIST
77401: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77402: LD_ADDR_VAR 0 20
77406: PUSH
77407: LD_INT 1
77409: PUSH
77410: LD_INT 3
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 0
77419: PUSH
77420: LD_INT 3
77422: PUSH
77423: EMPTY
77424: LIST
77425: LIST
77426: PUSH
77427: LD_INT 1
77429: NEG
77430: PUSH
77431: LD_INT 2
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: LIST
77442: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77443: LD_ADDR_VAR 0 21
77447: PUSH
77448: LD_INT 2
77450: NEG
77451: PUSH
77452: LD_INT 1
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 3
77461: NEG
77462: PUSH
77463: LD_INT 0
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 3
77472: NEG
77473: PUSH
77474: LD_INT 1
77476: NEG
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: LIST
77486: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77487: LD_ADDR_VAR 0 22
77491: PUSH
77492: LD_INT 2
77494: NEG
77495: PUSH
77496: LD_INT 3
77498: NEG
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 3
77506: NEG
77507: PUSH
77508: LD_INT 2
77510: NEG
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 3
77518: NEG
77519: PUSH
77520: LD_INT 3
77522: NEG
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: LIST
77532: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77533: LD_ADDR_VAR 0 23
77537: PUSH
77538: LD_INT 0
77540: PUSH
77541: LD_INT 3
77543: NEG
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 1
77551: NEG
77552: PUSH
77553: LD_INT 4
77555: NEG
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 1
77563: PUSH
77564: LD_INT 3
77566: NEG
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: LIST
77576: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77577: LD_ADDR_VAR 0 24
77581: PUSH
77582: LD_INT 3
77584: PUSH
77585: LD_INT 0
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 3
77594: PUSH
77595: LD_INT 1
77597: NEG
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 4
77605: PUSH
77606: LD_INT 1
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: LIST
77617: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77618: LD_ADDR_VAR 0 25
77622: PUSH
77623: LD_INT 3
77625: PUSH
77626: LD_INT 3
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 4
77635: PUSH
77636: LD_INT 3
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 3
77645: PUSH
77646: LD_INT 4
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: LIST
77657: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77658: LD_ADDR_VAR 0 26
77662: PUSH
77663: LD_INT 0
77665: PUSH
77666: LD_INT 3
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 1
77675: PUSH
77676: LD_INT 4
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 1
77685: NEG
77686: PUSH
77687: LD_INT 3
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: LIST
77698: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77699: LD_ADDR_VAR 0 27
77703: PUSH
77704: LD_INT 3
77706: NEG
77707: PUSH
77708: LD_INT 0
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 3
77717: NEG
77718: PUSH
77719: LD_INT 1
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 4
77728: NEG
77729: PUSH
77730: LD_INT 1
77732: NEG
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: LIST
77742: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77743: LD_ADDR_VAR 0 28
77747: PUSH
77748: LD_INT 3
77750: NEG
77751: PUSH
77752: LD_INT 3
77754: NEG
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 3
77762: NEG
77763: PUSH
77764: LD_INT 4
77766: NEG
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 4
77774: NEG
77775: PUSH
77776: LD_INT 3
77778: NEG
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: LIST
77788: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77789: LD_ADDR_VAR 0 29
77793: PUSH
77794: LD_INT 1
77796: NEG
77797: PUSH
77798: LD_INT 3
77800: NEG
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 0
77808: PUSH
77809: LD_INT 3
77811: NEG
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 1
77819: PUSH
77820: LD_INT 2
77822: NEG
77823: PUSH
77824: EMPTY
77825: LIST
77826: LIST
77827: PUSH
77828: LD_INT 1
77830: NEG
77831: PUSH
77832: LD_INT 4
77834: NEG
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 0
77842: PUSH
77843: LD_INT 4
77845: NEG
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 1
77853: PUSH
77854: LD_INT 3
77856: NEG
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 1
77864: NEG
77865: PUSH
77866: LD_INT 5
77868: NEG
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 0
77876: PUSH
77877: LD_INT 5
77879: NEG
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 1
77887: PUSH
77888: LD_INT 4
77890: NEG
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 1
77898: NEG
77899: PUSH
77900: LD_INT 6
77902: NEG
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 0
77910: PUSH
77911: LD_INT 6
77913: NEG
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 1
77921: PUSH
77922: LD_INT 5
77924: NEG
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: LIST
77934: LIST
77935: LIST
77936: LIST
77937: LIST
77938: LIST
77939: LIST
77940: LIST
77941: LIST
77942: LIST
77943: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77944: LD_ADDR_VAR 0 30
77948: PUSH
77949: LD_INT 2
77951: PUSH
77952: LD_INT 1
77954: NEG
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: LD_INT 3
77962: PUSH
77963: LD_INT 0
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 3
77972: PUSH
77973: LD_INT 1
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: PUSH
77980: LD_INT 3
77982: PUSH
77983: LD_INT 1
77985: NEG
77986: PUSH
77987: EMPTY
77988: LIST
77989: LIST
77990: PUSH
77991: LD_INT 4
77993: PUSH
77994: LD_INT 0
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 4
78003: PUSH
78004: LD_INT 1
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 4
78013: PUSH
78014: LD_INT 1
78016: NEG
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: PUSH
78022: LD_INT 5
78024: PUSH
78025: LD_INT 0
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 5
78034: PUSH
78035: LD_INT 1
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PUSH
78042: LD_INT 5
78044: PUSH
78045: LD_INT 1
78047: NEG
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 6
78055: PUSH
78056: LD_INT 0
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: LD_INT 6
78065: PUSH
78066: LD_INT 1
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: LIST
78077: LIST
78078: LIST
78079: LIST
78080: LIST
78081: LIST
78082: LIST
78083: LIST
78084: LIST
78085: LIST
78086: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78087: LD_ADDR_VAR 0 31
78091: PUSH
78092: LD_INT 3
78094: PUSH
78095: LD_INT 2
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 3
78104: PUSH
78105: LD_INT 3
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 2
78114: PUSH
78115: LD_INT 3
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 4
78124: PUSH
78125: LD_INT 3
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 4
78134: PUSH
78135: LD_INT 4
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: LD_INT 3
78144: PUSH
78145: LD_INT 4
78147: PUSH
78148: EMPTY
78149: LIST
78150: LIST
78151: PUSH
78152: LD_INT 5
78154: PUSH
78155: LD_INT 4
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 5
78164: PUSH
78165: LD_INT 5
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 4
78174: PUSH
78175: LD_INT 5
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 6
78184: PUSH
78185: LD_INT 5
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PUSH
78192: LD_INT 6
78194: PUSH
78195: LD_INT 6
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: PUSH
78202: LD_INT 5
78204: PUSH
78205: LD_INT 6
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78226: LD_ADDR_VAR 0 32
78230: PUSH
78231: LD_INT 1
78233: PUSH
78234: LD_INT 3
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 0
78243: PUSH
78244: LD_INT 3
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 1
78253: NEG
78254: PUSH
78255: LD_INT 2
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 1
78264: PUSH
78265: LD_INT 4
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 0
78274: PUSH
78275: LD_INT 4
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: PUSH
78282: LD_INT 1
78284: NEG
78285: PUSH
78286: LD_INT 3
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 1
78295: PUSH
78296: LD_INT 5
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 0
78305: PUSH
78306: LD_INT 5
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 1
78315: NEG
78316: PUSH
78317: LD_INT 4
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: LD_INT 1
78326: PUSH
78327: LD_INT 6
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 0
78336: PUSH
78337: LD_INT 6
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: LD_INT 1
78346: NEG
78347: PUSH
78348: LD_INT 5
78350: PUSH
78351: EMPTY
78352: LIST
78353: LIST
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78369: LD_ADDR_VAR 0 33
78373: PUSH
78374: LD_INT 2
78376: NEG
78377: PUSH
78378: LD_INT 1
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 3
78387: NEG
78388: PUSH
78389: LD_INT 0
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 3
78398: NEG
78399: PUSH
78400: LD_INT 1
78402: NEG
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 3
78410: NEG
78411: PUSH
78412: LD_INT 1
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 4
78421: NEG
78422: PUSH
78423: LD_INT 0
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 4
78432: NEG
78433: PUSH
78434: LD_INT 1
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 4
78444: NEG
78445: PUSH
78446: LD_INT 1
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 5
78455: NEG
78456: PUSH
78457: LD_INT 0
78459: PUSH
78460: EMPTY
78461: LIST
78462: LIST
78463: PUSH
78464: LD_INT 5
78466: NEG
78467: PUSH
78468: LD_INT 1
78470: NEG
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 5
78478: NEG
78479: PUSH
78480: LD_INT 1
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 6
78489: NEG
78490: PUSH
78491: LD_INT 0
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 6
78500: NEG
78501: PUSH
78502: LD_INT 1
78504: NEG
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: LIST
78514: LIST
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: LIST
78521: LIST
78522: LIST
78523: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78524: LD_ADDR_VAR 0 34
78528: PUSH
78529: LD_INT 2
78531: NEG
78532: PUSH
78533: LD_INT 3
78535: NEG
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 3
78543: NEG
78544: PUSH
78545: LD_INT 2
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 3
78555: NEG
78556: PUSH
78557: LD_INT 3
78559: NEG
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 3
78567: NEG
78568: PUSH
78569: LD_INT 4
78571: NEG
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 4
78579: NEG
78580: PUSH
78581: LD_INT 3
78583: NEG
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 4
78591: NEG
78592: PUSH
78593: LD_INT 4
78595: NEG
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 4
78603: NEG
78604: PUSH
78605: LD_INT 5
78607: NEG
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: LD_INT 5
78615: NEG
78616: PUSH
78617: LD_INT 4
78619: NEG
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 5
78627: NEG
78628: PUSH
78629: LD_INT 5
78631: NEG
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 5
78639: NEG
78640: PUSH
78641: LD_INT 6
78643: NEG
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 6
78651: NEG
78652: PUSH
78653: LD_INT 5
78655: NEG
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 6
78663: NEG
78664: PUSH
78665: LD_INT 6
78667: NEG
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78687: LD_ADDR_VAR 0 41
78691: PUSH
78692: LD_INT 0
78694: PUSH
78695: LD_INT 2
78697: NEG
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 1
78705: NEG
78706: PUSH
78707: LD_INT 3
78709: NEG
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 1
78717: PUSH
78718: LD_INT 2
78720: NEG
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: LIST
78730: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78731: LD_ADDR_VAR 0 42
78735: PUSH
78736: LD_INT 2
78738: PUSH
78739: LD_INT 0
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 2
78748: PUSH
78749: LD_INT 1
78751: NEG
78752: PUSH
78753: EMPTY
78754: LIST
78755: LIST
78756: PUSH
78757: LD_INT 3
78759: PUSH
78760: LD_INT 1
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: LIST
78771: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78772: LD_ADDR_VAR 0 43
78776: PUSH
78777: LD_INT 2
78779: PUSH
78780: LD_INT 2
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 3
78789: PUSH
78790: LD_INT 2
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 2
78799: PUSH
78800: LD_INT 3
78802: PUSH
78803: EMPTY
78804: LIST
78805: LIST
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: LIST
78811: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78812: LD_ADDR_VAR 0 44
78816: PUSH
78817: LD_INT 0
78819: PUSH
78820: LD_INT 2
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 1
78829: PUSH
78830: LD_INT 3
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 1
78839: NEG
78840: PUSH
78841: LD_INT 2
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: LIST
78852: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78853: LD_ADDR_VAR 0 45
78857: PUSH
78858: LD_INT 2
78860: NEG
78861: PUSH
78862: LD_INT 0
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 2
78871: NEG
78872: PUSH
78873: LD_INT 1
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: LD_INT 3
78882: NEG
78883: PUSH
78884: LD_INT 1
78886: NEG
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: EMPTY
78893: LIST
78894: LIST
78895: LIST
78896: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78897: LD_ADDR_VAR 0 46
78901: PUSH
78902: LD_INT 2
78904: NEG
78905: PUSH
78906: LD_INT 2
78908: NEG
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 2
78916: NEG
78917: PUSH
78918: LD_INT 3
78920: NEG
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 3
78928: NEG
78929: PUSH
78930: LD_INT 2
78932: NEG
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: LIST
78942: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78943: LD_ADDR_VAR 0 47
78947: PUSH
78948: LD_INT 2
78950: NEG
78951: PUSH
78952: LD_INT 3
78954: NEG
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 1
78962: NEG
78963: PUSH
78964: LD_INT 3
78966: NEG
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78976: LD_ADDR_VAR 0 48
78980: PUSH
78981: LD_INT 1
78983: PUSH
78984: LD_INT 2
78986: NEG
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: PUSH
78992: LD_INT 2
78994: PUSH
78995: LD_INT 1
78997: NEG
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79007: LD_ADDR_VAR 0 49
79011: PUSH
79012: LD_INT 3
79014: PUSH
79015: LD_INT 1
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 3
79024: PUSH
79025: LD_INT 2
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79036: LD_ADDR_VAR 0 50
79040: PUSH
79041: LD_INT 2
79043: PUSH
79044: LD_INT 3
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 1
79053: PUSH
79054: LD_INT 3
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79065: LD_ADDR_VAR 0 51
79069: PUSH
79070: LD_INT 1
79072: NEG
79073: PUSH
79074: LD_INT 2
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 2
79083: NEG
79084: PUSH
79085: LD_INT 1
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79096: LD_ADDR_VAR 0 52
79100: PUSH
79101: LD_INT 3
79103: NEG
79104: PUSH
79105: LD_INT 1
79107: NEG
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 3
79115: NEG
79116: PUSH
79117: LD_INT 2
79119: NEG
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79129: LD_ADDR_VAR 0 53
79133: PUSH
79134: LD_INT 1
79136: NEG
79137: PUSH
79138: LD_INT 3
79140: NEG
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 0
79148: PUSH
79149: LD_INT 3
79151: NEG
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 1
79159: PUSH
79160: LD_INT 2
79162: NEG
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: LIST
79172: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79173: LD_ADDR_VAR 0 54
79177: PUSH
79178: LD_INT 2
79180: PUSH
79181: LD_INT 1
79183: NEG
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 3
79191: PUSH
79192: LD_INT 0
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 3
79201: PUSH
79202: LD_INT 1
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: LIST
79213: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79214: LD_ADDR_VAR 0 55
79218: PUSH
79219: LD_INT 3
79221: PUSH
79222: LD_INT 2
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 3
79231: PUSH
79232: LD_INT 3
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 2
79241: PUSH
79242: LD_INT 3
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: LIST
79253: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79254: LD_ADDR_VAR 0 56
79258: PUSH
79259: LD_INT 1
79261: PUSH
79262: LD_INT 3
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 0
79271: PUSH
79272: LD_INT 3
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: LD_INT 1
79281: NEG
79282: PUSH
79283: LD_INT 2
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: LIST
79294: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79295: LD_ADDR_VAR 0 57
79299: PUSH
79300: LD_INT 2
79302: NEG
79303: PUSH
79304: LD_INT 1
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 3
79313: NEG
79314: PUSH
79315: LD_INT 0
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 3
79324: NEG
79325: PUSH
79326: LD_INT 1
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: LIST
79338: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79339: LD_ADDR_VAR 0 58
79343: PUSH
79344: LD_INT 2
79346: NEG
79347: PUSH
79348: LD_INT 3
79350: NEG
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 3
79358: NEG
79359: PUSH
79360: LD_INT 2
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 3
79370: NEG
79371: PUSH
79372: LD_INT 3
79374: NEG
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: LIST
79384: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79385: LD_ADDR_VAR 0 59
79389: PUSH
79390: LD_INT 1
79392: NEG
79393: PUSH
79394: LD_INT 2
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 0
79404: PUSH
79405: LD_INT 2
79407: NEG
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PUSH
79413: LD_INT 1
79415: PUSH
79416: LD_INT 1
79418: NEG
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: LIST
79428: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79429: LD_ADDR_VAR 0 60
79433: PUSH
79434: LD_INT 1
79436: PUSH
79437: LD_INT 1
79439: NEG
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 2
79447: PUSH
79448: LD_INT 0
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 2
79457: PUSH
79458: LD_INT 1
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: LIST
79469: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79470: LD_ADDR_VAR 0 61
79474: PUSH
79475: LD_INT 2
79477: PUSH
79478: LD_INT 1
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: LD_INT 2
79487: PUSH
79488: LD_INT 2
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: LD_INT 1
79497: PUSH
79498: LD_INT 2
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: LIST
79509: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79510: LD_ADDR_VAR 0 62
79514: PUSH
79515: LD_INT 1
79517: PUSH
79518: LD_INT 2
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 0
79527: PUSH
79528: LD_INT 2
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 1
79537: NEG
79538: PUSH
79539: LD_INT 1
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: LIST
79550: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79551: LD_ADDR_VAR 0 63
79555: PUSH
79556: LD_INT 1
79558: NEG
79559: PUSH
79560: LD_INT 1
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 2
79569: NEG
79570: PUSH
79571: LD_INT 0
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: PUSH
79578: LD_INT 2
79580: NEG
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: LIST
79594: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79595: LD_ADDR_VAR 0 64
79599: PUSH
79600: LD_INT 1
79602: NEG
79603: PUSH
79604: LD_INT 2
79606: NEG
79607: PUSH
79608: EMPTY
79609: LIST
79610: LIST
79611: PUSH
79612: LD_INT 2
79614: NEG
79615: PUSH
79616: LD_INT 1
79618: NEG
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 2
79626: NEG
79627: PUSH
79628: LD_INT 2
79630: NEG
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: LIST
79640: ST_TO_ADDR
// end ; 2 :
79641: GO 82907
79643: LD_INT 2
79645: DOUBLE
79646: EQUAL
79647: IFTRUE 79651
79649: GO 82906
79651: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79652: LD_ADDR_VAR 0 29
79656: PUSH
79657: LD_INT 4
79659: PUSH
79660: LD_INT 0
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 4
79669: PUSH
79670: LD_INT 1
79672: NEG
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 5
79680: PUSH
79681: LD_INT 0
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 5
79690: PUSH
79691: LD_INT 1
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 4
79700: PUSH
79701: LD_INT 1
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 3
79710: PUSH
79711: LD_INT 0
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 3
79720: PUSH
79721: LD_INT 1
79723: NEG
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 3
79731: PUSH
79732: LD_INT 2
79734: NEG
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 5
79742: PUSH
79743: LD_INT 2
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 3
79752: PUSH
79753: LD_INT 3
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 3
79762: PUSH
79763: LD_INT 2
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 4
79772: PUSH
79773: LD_INT 3
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: LD_INT 4
79782: PUSH
79783: LD_INT 4
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 3
79792: PUSH
79793: LD_INT 4
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 2
79802: PUSH
79803: LD_INT 3
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 2
79812: PUSH
79813: LD_INT 2
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 4
79822: PUSH
79823: LD_INT 2
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 2
79832: PUSH
79833: LD_INT 4
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 0
79842: PUSH
79843: LD_INT 4
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 0
79852: PUSH
79853: LD_INT 3
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 1
79862: PUSH
79863: LD_INT 4
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: LD_INT 1
79872: PUSH
79873: LD_INT 5
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: LD_INT 0
79882: PUSH
79883: LD_INT 5
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 1
79892: NEG
79893: PUSH
79894: LD_INT 4
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 1
79903: NEG
79904: PUSH
79905: LD_INT 3
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 2
79914: PUSH
79915: LD_INT 5
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 2
79924: NEG
79925: PUSH
79926: LD_INT 3
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 3
79935: NEG
79936: PUSH
79937: LD_INT 0
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 3
79946: NEG
79947: PUSH
79948: LD_INT 1
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 2
79958: NEG
79959: PUSH
79960: LD_INT 0
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 2
79969: NEG
79970: PUSH
79971: LD_INT 1
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 3
79980: NEG
79981: PUSH
79982: LD_INT 1
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 4
79991: NEG
79992: PUSH
79993: LD_INT 0
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: LD_INT 4
80002: NEG
80003: PUSH
80004: LD_INT 1
80006: NEG
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 4
80014: NEG
80015: PUSH
80016: LD_INT 2
80018: NEG
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 2
80026: NEG
80027: PUSH
80028: LD_INT 2
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 4
80037: NEG
80038: PUSH
80039: LD_INT 4
80041: NEG
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 4
80049: NEG
80050: PUSH
80051: LD_INT 5
80053: NEG
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 3
80061: NEG
80062: PUSH
80063: LD_INT 4
80065: NEG
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 3
80073: NEG
80074: PUSH
80075: LD_INT 3
80077: NEG
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 4
80085: NEG
80086: PUSH
80087: LD_INT 3
80089: NEG
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 5
80097: NEG
80098: PUSH
80099: LD_INT 4
80101: NEG
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PUSH
80107: LD_INT 5
80109: NEG
80110: PUSH
80111: LD_INT 5
80113: NEG
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 3
80121: NEG
80122: PUSH
80123: LD_INT 5
80125: NEG
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 5
80133: NEG
80134: PUSH
80135: LD_INT 3
80137: NEG
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80190: LD_ADDR_VAR 0 30
80194: PUSH
80195: LD_INT 4
80197: PUSH
80198: LD_INT 4
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 4
80207: PUSH
80208: LD_INT 3
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 5
80217: PUSH
80218: LD_INT 4
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 5
80227: PUSH
80228: LD_INT 5
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 4
80237: PUSH
80238: LD_INT 5
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 3
80247: PUSH
80248: LD_INT 4
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 3
80257: PUSH
80258: LD_INT 3
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: PUSH
80265: LD_INT 5
80267: PUSH
80268: LD_INT 3
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 3
80277: PUSH
80278: LD_INT 5
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 0
80287: PUSH
80288: LD_INT 3
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: PUSH
80295: LD_INT 0
80297: PUSH
80298: LD_INT 2
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 1
80307: PUSH
80308: LD_INT 3
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 1
80317: PUSH
80318: LD_INT 4
80320: PUSH
80321: EMPTY
80322: LIST
80323: LIST
80324: PUSH
80325: LD_INT 0
80327: PUSH
80328: LD_INT 4
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 1
80337: NEG
80338: PUSH
80339: LD_INT 3
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 1
80348: NEG
80349: PUSH
80350: LD_INT 2
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 2
80359: PUSH
80360: LD_INT 4
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 2
80369: NEG
80370: PUSH
80371: LD_INT 2
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 4
80380: NEG
80381: PUSH
80382: LD_INT 0
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 4
80391: NEG
80392: PUSH
80393: LD_INT 1
80395: NEG
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 3
80403: NEG
80404: PUSH
80405: LD_INT 0
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 3
80414: NEG
80415: PUSH
80416: LD_INT 1
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 4
80425: NEG
80426: PUSH
80427: LD_INT 1
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 5
80436: NEG
80437: PUSH
80438: LD_INT 0
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 5
80447: NEG
80448: PUSH
80449: LD_INT 1
80451: NEG
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 5
80459: NEG
80460: PUSH
80461: LD_INT 2
80463: NEG
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 3
80471: NEG
80472: PUSH
80473: LD_INT 2
80475: PUSH
80476: EMPTY
80477: LIST
80478: LIST
80479: PUSH
80480: LD_INT 3
80482: NEG
80483: PUSH
80484: LD_INT 3
80486: NEG
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 3
80494: NEG
80495: PUSH
80496: LD_INT 4
80498: NEG
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 2
80506: NEG
80507: PUSH
80508: LD_INT 3
80510: NEG
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 2
80518: NEG
80519: PUSH
80520: LD_INT 2
80522: NEG
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 3
80530: NEG
80531: PUSH
80532: LD_INT 2
80534: NEG
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: PUSH
80540: LD_INT 4
80542: NEG
80543: PUSH
80544: LD_INT 3
80546: NEG
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 4
80554: NEG
80555: PUSH
80556: LD_INT 4
80558: NEG
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 2
80566: NEG
80567: PUSH
80568: LD_INT 4
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 4
80578: NEG
80579: PUSH
80580: LD_INT 2
80582: NEG
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 0
80590: PUSH
80591: LD_INT 4
80593: NEG
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 0
80601: PUSH
80602: LD_INT 5
80604: NEG
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 1
80612: PUSH
80613: LD_INT 4
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: PUSH
80624: LD_INT 3
80626: NEG
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 0
80634: PUSH
80635: LD_INT 3
80637: NEG
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 1
80645: NEG
80646: PUSH
80647: LD_INT 4
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 1
80657: NEG
80658: PUSH
80659: LD_INT 5
80661: NEG
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 2
80669: PUSH
80670: LD_INT 3
80672: NEG
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 2
80680: NEG
80681: PUSH
80682: LD_INT 5
80684: NEG
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80737: LD_ADDR_VAR 0 31
80741: PUSH
80742: LD_INT 0
80744: PUSH
80745: LD_INT 4
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 0
80754: PUSH
80755: LD_INT 3
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 1
80764: PUSH
80765: LD_INT 4
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 1
80774: PUSH
80775: LD_INT 5
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: LD_INT 0
80784: PUSH
80785: LD_INT 5
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 1
80794: NEG
80795: PUSH
80796: LD_INT 4
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 1
80805: NEG
80806: PUSH
80807: LD_INT 3
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: PUSH
80814: LD_INT 2
80816: PUSH
80817: LD_INT 5
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 2
80826: NEG
80827: PUSH
80828: LD_INT 3
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 3
80837: NEG
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 3
80848: NEG
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 2
80860: NEG
80861: PUSH
80862: LD_INT 0
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 2
80871: NEG
80872: PUSH
80873: LD_INT 1
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 3
80882: NEG
80883: PUSH
80884: LD_INT 1
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PUSH
80891: LD_INT 4
80893: NEG
80894: PUSH
80895: LD_INT 0
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: PUSH
80902: LD_INT 4
80904: NEG
80905: PUSH
80906: LD_INT 1
80908: NEG
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 4
80916: NEG
80917: PUSH
80918: LD_INT 2
80920: NEG
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 2
80928: NEG
80929: PUSH
80930: LD_INT 2
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 4
80939: NEG
80940: PUSH
80941: LD_INT 4
80943: NEG
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 4
80951: NEG
80952: PUSH
80953: LD_INT 5
80955: NEG
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 3
80963: NEG
80964: PUSH
80965: LD_INT 4
80967: NEG
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 3
80975: NEG
80976: PUSH
80977: LD_INT 3
80979: NEG
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 4
80987: NEG
80988: PUSH
80989: LD_INT 3
80991: NEG
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 5
80999: NEG
81000: PUSH
81001: LD_INT 4
81003: NEG
81004: PUSH
81005: EMPTY
81006: LIST
81007: LIST
81008: PUSH
81009: LD_INT 5
81011: NEG
81012: PUSH
81013: LD_INT 5
81015: NEG
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 3
81023: NEG
81024: PUSH
81025: LD_INT 5
81027: NEG
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 5
81035: NEG
81036: PUSH
81037: LD_INT 3
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 0
81047: PUSH
81048: LD_INT 3
81050: NEG
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 0
81058: PUSH
81059: LD_INT 4
81061: NEG
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 1
81069: PUSH
81070: LD_INT 3
81072: NEG
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: PUSH
81081: LD_INT 2
81083: NEG
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: LD_INT 0
81091: PUSH
81092: LD_INT 2
81094: NEG
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 1
81102: NEG
81103: PUSH
81104: LD_INT 3
81106: NEG
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 1
81114: NEG
81115: PUSH
81116: LD_INT 4
81118: NEG
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 2
81126: PUSH
81127: LD_INT 2
81129: NEG
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 2
81137: NEG
81138: PUSH
81139: LD_INT 4
81141: NEG
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 4
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 4
81159: PUSH
81160: LD_INT 1
81162: NEG
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 5
81170: PUSH
81171: LD_INT 0
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 5
81180: PUSH
81181: LD_INT 1
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: PUSH
81188: LD_INT 4
81190: PUSH
81191: LD_INT 1
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 3
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 3
81210: PUSH
81211: LD_INT 1
81213: NEG
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 3
81221: PUSH
81222: LD_INT 2
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 5
81232: PUSH
81233: LD_INT 2
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81287: LD_ADDR_VAR 0 32
81291: PUSH
81292: LD_INT 4
81294: NEG
81295: PUSH
81296: LD_INT 0
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: LD_INT 4
81305: NEG
81306: PUSH
81307: LD_INT 1
81309: NEG
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 3
81317: NEG
81318: PUSH
81319: LD_INT 0
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 3
81328: NEG
81329: PUSH
81330: LD_INT 1
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 4
81339: NEG
81340: PUSH
81341: LD_INT 1
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 5
81350: NEG
81351: PUSH
81352: LD_INT 0
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: LD_INT 5
81361: NEG
81362: PUSH
81363: LD_INT 1
81365: NEG
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 5
81373: NEG
81374: PUSH
81375: LD_INT 2
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 3
81385: NEG
81386: PUSH
81387: LD_INT 2
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: PUSH
81394: LD_INT 3
81396: NEG
81397: PUSH
81398: LD_INT 3
81400: NEG
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 3
81408: NEG
81409: PUSH
81410: LD_INT 4
81412: NEG
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 2
81420: NEG
81421: PUSH
81422: LD_INT 3
81424: NEG
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 2
81432: NEG
81433: PUSH
81434: LD_INT 2
81436: NEG
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 3
81444: NEG
81445: PUSH
81446: LD_INT 2
81448: NEG
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 4
81456: NEG
81457: PUSH
81458: LD_INT 3
81460: NEG
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 4
81468: NEG
81469: PUSH
81470: LD_INT 4
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 2
81480: NEG
81481: PUSH
81482: LD_INT 4
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 4
81492: NEG
81493: PUSH
81494: LD_INT 2
81496: NEG
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 0
81504: PUSH
81505: LD_INT 4
81507: NEG
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 0
81515: PUSH
81516: LD_INT 5
81518: NEG
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 1
81526: PUSH
81527: LD_INT 4
81529: NEG
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 1
81537: PUSH
81538: LD_INT 3
81540: NEG
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 0
81548: PUSH
81549: LD_INT 3
81551: NEG
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 1
81559: NEG
81560: PUSH
81561: LD_INT 4
81563: NEG
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 1
81571: NEG
81572: PUSH
81573: LD_INT 5
81575: NEG
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: PUSH
81581: LD_INT 2
81583: PUSH
81584: LD_INT 3
81586: NEG
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 2
81594: NEG
81595: PUSH
81596: LD_INT 5
81598: NEG
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: PUSH
81604: LD_INT 3
81606: PUSH
81607: LD_INT 0
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: PUSH
81614: LD_INT 3
81616: PUSH
81617: LD_INT 1
81619: NEG
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 4
81627: PUSH
81628: LD_INT 0
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: LD_INT 4
81637: PUSH
81638: LD_INT 1
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PUSH
81645: LD_INT 3
81647: PUSH
81648: LD_INT 1
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 2
81657: PUSH
81658: LD_INT 0
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: PUSH
81665: LD_INT 2
81667: PUSH
81668: LD_INT 1
81670: NEG
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 2
81678: PUSH
81679: LD_INT 2
81681: NEG
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 4
81689: PUSH
81690: LD_INT 2
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 4
81699: PUSH
81700: LD_INT 4
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 4
81709: PUSH
81710: LD_INT 3
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 5
81719: PUSH
81720: LD_INT 4
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PUSH
81727: LD_INT 5
81729: PUSH
81730: LD_INT 5
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 4
81739: PUSH
81740: LD_INT 5
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 3
81749: PUSH
81750: LD_INT 4
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 3
81759: PUSH
81760: LD_INT 3
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 5
81769: PUSH
81770: LD_INT 3
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 3
81779: PUSH
81780: LD_INT 5
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: LIST
81793: LIST
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81834: LD_ADDR_VAR 0 33
81838: PUSH
81839: LD_INT 4
81841: NEG
81842: PUSH
81843: LD_INT 4
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 4
81853: NEG
81854: PUSH
81855: LD_INT 5
81857: NEG
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 3
81865: NEG
81866: PUSH
81867: LD_INT 4
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 3
81877: NEG
81878: PUSH
81879: LD_INT 3
81881: NEG
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 4
81889: NEG
81890: PUSH
81891: LD_INT 3
81893: NEG
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 5
81901: NEG
81902: PUSH
81903: LD_INT 4
81905: NEG
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 5
81913: NEG
81914: PUSH
81915: LD_INT 5
81917: NEG
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 3
81925: NEG
81926: PUSH
81927: LD_INT 5
81929: NEG
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 5
81937: NEG
81938: PUSH
81939: LD_INT 3
81941: NEG
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 0
81949: PUSH
81950: LD_INT 3
81952: NEG
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 0
81960: PUSH
81961: LD_INT 4
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 1
81971: PUSH
81972: LD_INT 3
81974: NEG
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: PUSH
81983: LD_INT 2
81985: NEG
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 0
81993: PUSH
81994: LD_INT 2
81996: NEG
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 1
82004: NEG
82005: PUSH
82006: LD_INT 3
82008: NEG
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 1
82016: NEG
82017: PUSH
82018: LD_INT 4
82020: NEG
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 2
82028: PUSH
82029: LD_INT 2
82031: NEG
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 2
82039: NEG
82040: PUSH
82041: LD_INT 4
82043: NEG
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 4
82051: PUSH
82052: LD_INT 0
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 4
82061: PUSH
82062: LD_INT 1
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 5
82072: PUSH
82073: LD_INT 0
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 5
82082: PUSH
82083: LD_INT 1
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: LD_INT 4
82092: PUSH
82093: LD_INT 1
82095: PUSH
82096: EMPTY
82097: LIST
82098: LIST
82099: PUSH
82100: LD_INT 3
82102: PUSH
82103: LD_INT 0
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 3
82112: PUSH
82113: LD_INT 1
82115: NEG
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 3
82123: PUSH
82124: LD_INT 2
82126: NEG
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: LD_INT 5
82134: PUSH
82135: LD_INT 2
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 3
82144: PUSH
82145: LD_INT 3
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 3
82154: PUSH
82155: LD_INT 2
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 4
82164: PUSH
82165: LD_INT 3
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: LD_INT 4
82174: PUSH
82175: LD_INT 4
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 3
82184: PUSH
82185: LD_INT 4
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 2
82194: PUSH
82195: LD_INT 3
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 2
82204: PUSH
82205: LD_INT 2
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 4
82214: PUSH
82215: LD_INT 2
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PUSH
82222: LD_INT 2
82224: PUSH
82225: LD_INT 4
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 0
82234: PUSH
82235: LD_INT 4
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 0
82244: PUSH
82245: LD_INT 3
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 1
82254: PUSH
82255: LD_INT 4
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 1
82264: PUSH
82265: LD_INT 5
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 0
82274: PUSH
82275: LD_INT 5
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 1
82284: NEG
82285: PUSH
82286: LD_INT 4
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 1
82295: NEG
82296: PUSH
82297: LD_INT 3
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 2
82306: PUSH
82307: LD_INT 5
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 2
82316: NEG
82317: PUSH
82318: LD_INT 3
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: LIST
82350: LIST
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: LIST
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82372: LD_ADDR_VAR 0 34
82376: PUSH
82377: LD_INT 0
82379: PUSH
82380: LD_INT 4
82382: NEG
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 0
82390: PUSH
82391: LD_INT 5
82393: NEG
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 1
82401: PUSH
82402: LD_INT 4
82404: NEG
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 1
82412: PUSH
82413: LD_INT 3
82415: NEG
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: LD_INT 0
82423: PUSH
82424: LD_INT 3
82426: NEG
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 1
82434: NEG
82435: PUSH
82436: LD_INT 4
82438: NEG
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 1
82446: NEG
82447: PUSH
82448: LD_INT 5
82450: NEG
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: LD_INT 2
82458: PUSH
82459: LD_INT 3
82461: NEG
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 2
82469: NEG
82470: PUSH
82471: LD_INT 5
82473: NEG
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 3
82481: PUSH
82482: LD_INT 0
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 3
82491: PUSH
82492: LD_INT 1
82494: NEG
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 4
82502: PUSH
82503: LD_INT 0
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 4
82512: PUSH
82513: LD_INT 1
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 3
82522: PUSH
82523: LD_INT 1
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 2
82532: PUSH
82533: LD_INT 0
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 2
82542: PUSH
82543: LD_INT 1
82545: NEG
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 2
82553: PUSH
82554: LD_INT 2
82556: NEG
82557: PUSH
82558: EMPTY
82559: LIST
82560: LIST
82561: PUSH
82562: LD_INT 4
82564: PUSH
82565: LD_INT 2
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 4
82574: PUSH
82575: LD_INT 4
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 4
82584: PUSH
82585: LD_INT 3
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 5
82594: PUSH
82595: LD_INT 4
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 5
82604: PUSH
82605: LD_INT 5
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: PUSH
82612: LD_INT 4
82614: PUSH
82615: LD_INT 5
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 3
82624: PUSH
82625: LD_INT 4
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 3
82634: PUSH
82635: LD_INT 3
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 5
82644: PUSH
82645: LD_INT 3
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 3
82654: PUSH
82655: LD_INT 5
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 0
82664: PUSH
82665: LD_INT 3
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 0
82674: PUSH
82675: LD_INT 2
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 1
82684: PUSH
82685: LD_INT 3
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 1
82694: PUSH
82695: LD_INT 4
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 0
82704: PUSH
82705: LD_INT 4
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 1
82714: NEG
82715: PUSH
82716: LD_INT 3
82718: PUSH
82719: EMPTY
82720: LIST
82721: LIST
82722: PUSH
82723: LD_INT 1
82725: NEG
82726: PUSH
82727: LD_INT 2
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 2
82736: PUSH
82737: LD_INT 4
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 2
82746: NEG
82747: PUSH
82748: LD_INT 2
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 4
82757: NEG
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 4
82768: NEG
82769: PUSH
82770: LD_INT 1
82772: NEG
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: PUSH
82778: LD_INT 3
82780: NEG
82781: PUSH
82782: LD_INT 0
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 3
82791: NEG
82792: PUSH
82793: LD_INT 1
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 4
82802: NEG
82803: PUSH
82804: LD_INT 1
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 5
82813: NEG
82814: PUSH
82815: LD_INT 0
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 5
82824: NEG
82825: PUSH
82826: LD_INT 1
82828: NEG
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 5
82836: NEG
82837: PUSH
82838: LD_INT 2
82840: NEG
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 3
82848: NEG
82849: PUSH
82850: LD_INT 2
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: LIST
82888: LIST
82889: LIST
82890: LIST
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: ST_TO_ADDR
// end ; end ;
82904: GO 82907
82906: POP
// case btype of b_depot , b_warehouse :
82907: LD_VAR 0 1
82911: PUSH
82912: LD_INT 0
82914: DOUBLE
82915: EQUAL
82916: IFTRUE 82926
82918: LD_INT 1
82920: DOUBLE
82921: EQUAL
82922: IFTRUE 82926
82924: GO 83127
82926: POP
// case nation of nation_american :
82927: LD_VAR 0 5
82931: PUSH
82932: LD_INT 1
82934: DOUBLE
82935: EQUAL
82936: IFTRUE 82940
82938: GO 82996
82940: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
82941: LD_ADDR_VAR 0 9
82945: PUSH
82946: LD_VAR 0 11
82950: PUSH
82951: LD_VAR 0 12
82955: PUSH
82956: LD_VAR 0 13
82960: PUSH
82961: LD_VAR 0 14
82965: PUSH
82966: LD_VAR 0 15
82970: PUSH
82971: LD_VAR 0 16
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: PUSH
82984: LD_VAR 0 4
82988: PUSH
82989: LD_INT 1
82991: PLUS
82992: ARRAY
82993: ST_TO_ADDR
82994: GO 83125
82996: LD_INT 2
82998: DOUBLE
82999: EQUAL
83000: IFTRUE 83004
83002: GO 83060
83004: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83005: LD_ADDR_VAR 0 9
83009: PUSH
83010: LD_VAR 0 17
83014: PUSH
83015: LD_VAR 0 18
83019: PUSH
83020: LD_VAR 0 19
83024: PUSH
83025: LD_VAR 0 20
83029: PUSH
83030: LD_VAR 0 21
83034: PUSH
83035: LD_VAR 0 22
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: PUSH
83048: LD_VAR 0 4
83052: PUSH
83053: LD_INT 1
83055: PLUS
83056: ARRAY
83057: ST_TO_ADDR
83058: GO 83125
83060: LD_INT 3
83062: DOUBLE
83063: EQUAL
83064: IFTRUE 83068
83066: GO 83124
83068: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83069: LD_ADDR_VAR 0 9
83073: PUSH
83074: LD_VAR 0 23
83078: PUSH
83079: LD_VAR 0 24
83083: PUSH
83084: LD_VAR 0 25
83088: PUSH
83089: LD_VAR 0 26
83093: PUSH
83094: LD_VAR 0 27
83098: PUSH
83099: LD_VAR 0 28
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: PUSH
83112: LD_VAR 0 4
83116: PUSH
83117: LD_INT 1
83119: PLUS
83120: ARRAY
83121: ST_TO_ADDR
83122: GO 83125
83124: POP
83125: GO 83680
83127: LD_INT 2
83129: DOUBLE
83130: EQUAL
83131: IFTRUE 83141
83133: LD_INT 3
83135: DOUBLE
83136: EQUAL
83137: IFTRUE 83141
83139: GO 83197
83141: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83142: LD_ADDR_VAR 0 9
83146: PUSH
83147: LD_VAR 0 29
83151: PUSH
83152: LD_VAR 0 30
83156: PUSH
83157: LD_VAR 0 31
83161: PUSH
83162: LD_VAR 0 32
83166: PUSH
83167: LD_VAR 0 33
83171: PUSH
83172: LD_VAR 0 34
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: PUSH
83185: LD_VAR 0 4
83189: PUSH
83190: LD_INT 1
83192: PLUS
83193: ARRAY
83194: ST_TO_ADDR
83195: GO 83680
83197: LD_INT 16
83199: DOUBLE
83200: EQUAL
83201: IFTRUE 83259
83203: LD_INT 17
83205: DOUBLE
83206: EQUAL
83207: IFTRUE 83259
83209: LD_INT 18
83211: DOUBLE
83212: EQUAL
83213: IFTRUE 83259
83215: LD_INT 19
83217: DOUBLE
83218: EQUAL
83219: IFTRUE 83259
83221: LD_INT 22
83223: DOUBLE
83224: EQUAL
83225: IFTRUE 83259
83227: LD_INT 20
83229: DOUBLE
83230: EQUAL
83231: IFTRUE 83259
83233: LD_INT 21
83235: DOUBLE
83236: EQUAL
83237: IFTRUE 83259
83239: LD_INT 23
83241: DOUBLE
83242: EQUAL
83243: IFTRUE 83259
83245: LD_INT 24
83247: DOUBLE
83248: EQUAL
83249: IFTRUE 83259
83251: LD_INT 25
83253: DOUBLE
83254: EQUAL
83255: IFTRUE 83259
83257: GO 83315
83259: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83260: LD_ADDR_VAR 0 9
83264: PUSH
83265: LD_VAR 0 35
83269: PUSH
83270: LD_VAR 0 36
83274: PUSH
83275: LD_VAR 0 37
83279: PUSH
83280: LD_VAR 0 38
83284: PUSH
83285: LD_VAR 0 39
83289: PUSH
83290: LD_VAR 0 40
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: PUSH
83303: LD_VAR 0 4
83307: PUSH
83308: LD_INT 1
83310: PLUS
83311: ARRAY
83312: ST_TO_ADDR
83313: GO 83680
83315: LD_INT 6
83317: DOUBLE
83318: EQUAL
83319: IFTRUE 83371
83321: LD_INT 7
83323: DOUBLE
83324: EQUAL
83325: IFTRUE 83371
83327: LD_INT 8
83329: DOUBLE
83330: EQUAL
83331: IFTRUE 83371
83333: LD_INT 13
83335: DOUBLE
83336: EQUAL
83337: IFTRUE 83371
83339: LD_INT 12
83341: DOUBLE
83342: EQUAL
83343: IFTRUE 83371
83345: LD_INT 15
83347: DOUBLE
83348: EQUAL
83349: IFTRUE 83371
83351: LD_INT 11
83353: DOUBLE
83354: EQUAL
83355: IFTRUE 83371
83357: LD_INT 14
83359: DOUBLE
83360: EQUAL
83361: IFTRUE 83371
83363: LD_INT 10
83365: DOUBLE
83366: EQUAL
83367: IFTRUE 83371
83369: GO 83427
83371: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
83372: LD_ADDR_VAR 0 9
83376: PUSH
83377: LD_VAR 0 41
83381: PUSH
83382: LD_VAR 0 42
83386: PUSH
83387: LD_VAR 0 43
83391: PUSH
83392: LD_VAR 0 44
83396: PUSH
83397: LD_VAR 0 45
83401: PUSH
83402: LD_VAR 0 46
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: PUSH
83415: LD_VAR 0 4
83419: PUSH
83420: LD_INT 1
83422: PLUS
83423: ARRAY
83424: ST_TO_ADDR
83425: GO 83680
83427: LD_INT 36
83429: DOUBLE
83430: EQUAL
83431: IFTRUE 83435
83433: GO 83491
83435: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83436: LD_ADDR_VAR 0 9
83440: PUSH
83441: LD_VAR 0 47
83445: PUSH
83446: LD_VAR 0 48
83450: PUSH
83451: LD_VAR 0 49
83455: PUSH
83456: LD_VAR 0 50
83460: PUSH
83461: LD_VAR 0 51
83465: PUSH
83466: LD_VAR 0 52
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: PUSH
83479: LD_VAR 0 4
83483: PUSH
83484: LD_INT 1
83486: PLUS
83487: ARRAY
83488: ST_TO_ADDR
83489: GO 83680
83491: LD_INT 4
83493: DOUBLE
83494: EQUAL
83495: IFTRUE 83517
83497: LD_INT 5
83499: DOUBLE
83500: EQUAL
83501: IFTRUE 83517
83503: LD_INT 34
83505: DOUBLE
83506: EQUAL
83507: IFTRUE 83517
83509: LD_INT 37
83511: DOUBLE
83512: EQUAL
83513: IFTRUE 83517
83515: GO 83573
83517: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83518: LD_ADDR_VAR 0 9
83522: PUSH
83523: LD_VAR 0 53
83527: PUSH
83528: LD_VAR 0 54
83532: PUSH
83533: LD_VAR 0 55
83537: PUSH
83538: LD_VAR 0 56
83542: PUSH
83543: LD_VAR 0 57
83547: PUSH
83548: LD_VAR 0 58
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: PUSH
83561: LD_VAR 0 4
83565: PUSH
83566: LD_INT 1
83568: PLUS
83569: ARRAY
83570: ST_TO_ADDR
83571: GO 83680
83573: LD_INT 31
83575: DOUBLE
83576: EQUAL
83577: IFTRUE 83623
83579: LD_INT 32
83581: DOUBLE
83582: EQUAL
83583: IFTRUE 83623
83585: LD_INT 33
83587: DOUBLE
83588: EQUAL
83589: IFTRUE 83623
83591: LD_INT 27
83593: DOUBLE
83594: EQUAL
83595: IFTRUE 83623
83597: LD_INT 26
83599: DOUBLE
83600: EQUAL
83601: IFTRUE 83623
83603: LD_INT 28
83605: DOUBLE
83606: EQUAL
83607: IFTRUE 83623
83609: LD_INT 29
83611: DOUBLE
83612: EQUAL
83613: IFTRUE 83623
83615: LD_INT 30
83617: DOUBLE
83618: EQUAL
83619: IFTRUE 83623
83621: GO 83679
83623: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
83624: LD_ADDR_VAR 0 9
83628: PUSH
83629: LD_VAR 0 59
83633: PUSH
83634: LD_VAR 0 60
83638: PUSH
83639: LD_VAR 0 61
83643: PUSH
83644: LD_VAR 0 62
83648: PUSH
83649: LD_VAR 0 63
83653: PUSH
83654: LD_VAR 0 64
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: PUSH
83667: LD_VAR 0 4
83671: PUSH
83672: LD_INT 1
83674: PLUS
83675: ARRAY
83676: ST_TO_ADDR
83677: GO 83680
83679: POP
// temp_list2 = [ ] ;
83680: LD_ADDR_VAR 0 10
83684: PUSH
83685: EMPTY
83686: ST_TO_ADDR
// for i in temp_list do
83687: LD_ADDR_VAR 0 8
83691: PUSH
83692: LD_VAR 0 9
83696: PUSH
83697: FOR_IN
83698: IFFALSE 83750
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83700: LD_ADDR_VAR 0 10
83704: PUSH
83705: LD_VAR 0 10
83709: PUSH
83710: LD_VAR 0 8
83714: PUSH
83715: LD_INT 1
83717: ARRAY
83718: PUSH
83719: LD_VAR 0 2
83723: PLUS
83724: PUSH
83725: LD_VAR 0 8
83729: PUSH
83730: LD_INT 2
83732: ARRAY
83733: PUSH
83734: LD_VAR 0 3
83738: PLUS
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: PUSH
83744: EMPTY
83745: LIST
83746: ADD
83747: ST_TO_ADDR
83748: GO 83697
83750: POP
83751: POP
// result = temp_list2 ;
83752: LD_ADDR_VAR 0 7
83756: PUSH
83757: LD_VAR 0 10
83761: ST_TO_ADDR
// end ;
83762: LD_VAR 0 7
83766: RET
// export function EnemyInRange ( unit , dist ) ; begin
83767: LD_INT 0
83769: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83770: LD_ADDR_VAR 0 3
83774: PUSH
83775: LD_VAR 0 1
83779: PPUSH
83780: CALL_OW 255
83784: PPUSH
83785: LD_VAR 0 1
83789: PPUSH
83790: CALL_OW 250
83794: PPUSH
83795: LD_VAR 0 1
83799: PPUSH
83800: CALL_OW 251
83804: PPUSH
83805: LD_VAR 0 2
83809: PPUSH
83810: CALL 57163 0 4
83814: PUSH
83815: LD_INT 4
83817: ARRAY
83818: ST_TO_ADDR
// end ;
83819: LD_VAR 0 3
83823: RET
// export function PlayerSeeMe ( unit ) ; begin
83824: LD_INT 0
83826: PPUSH
// result := See ( your_side , unit ) ;
83827: LD_ADDR_VAR 0 2
83831: PUSH
83832: LD_OWVAR 2
83836: PPUSH
83837: LD_VAR 0 1
83841: PPUSH
83842: CALL_OW 292
83846: ST_TO_ADDR
// end ;
83847: LD_VAR 0 2
83851: RET
// export function ReverseDir ( unit ) ; begin
83852: LD_INT 0
83854: PPUSH
// if not unit then
83855: LD_VAR 0 1
83859: NOT
83860: IFFALSE 83864
// exit ;
83862: GO 83887
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
83864: LD_ADDR_VAR 0 2
83868: PUSH
83869: LD_VAR 0 1
83873: PPUSH
83874: CALL_OW 254
83878: PUSH
83879: LD_INT 3
83881: PLUS
83882: PUSH
83883: LD_INT 6
83885: MOD
83886: ST_TO_ADDR
// end ;
83887: LD_VAR 0 2
83891: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83892: LD_INT 0
83894: PPUSH
83895: PPUSH
83896: PPUSH
83897: PPUSH
83898: PPUSH
// if not hexes then
83899: LD_VAR 0 2
83903: NOT
83904: IFFALSE 83908
// exit ;
83906: GO 84056
// dist := 9999 ;
83908: LD_ADDR_VAR 0 5
83912: PUSH
83913: LD_INT 9999
83915: ST_TO_ADDR
// for i = 1 to hexes do
83916: LD_ADDR_VAR 0 4
83920: PUSH
83921: DOUBLE
83922: LD_INT 1
83924: DEC
83925: ST_TO_ADDR
83926: LD_VAR 0 2
83930: PUSH
83931: FOR_TO
83932: IFFALSE 84044
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83934: LD_VAR 0 1
83938: PPUSH
83939: LD_VAR 0 2
83943: PUSH
83944: LD_VAR 0 4
83948: ARRAY
83949: PUSH
83950: LD_INT 1
83952: ARRAY
83953: PPUSH
83954: LD_VAR 0 2
83958: PUSH
83959: LD_VAR 0 4
83963: ARRAY
83964: PUSH
83965: LD_INT 2
83967: ARRAY
83968: PPUSH
83969: CALL_OW 297
83973: PUSH
83974: LD_VAR 0 5
83978: LESS
83979: IFFALSE 84042
// begin hex := hexes [ i ] ;
83981: LD_ADDR_VAR 0 7
83985: PUSH
83986: LD_VAR 0 2
83990: PUSH
83991: LD_VAR 0 4
83995: ARRAY
83996: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83997: LD_ADDR_VAR 0 5
84001: PUSH
84002: LD_VAR 0 1
84006: PPUSH
84007: LD_VAR 0 2
84011: PUSH
84012: LD_VAR 0 4
84016: ARRAY
84017: PUSH
84018: LD_INT 1
84020: ARRAY
84021: PPUSH
84022: LD_VAR 0 2
84026: PUSH
84027: LD_VAR 0 4
84031: ARRAY
84032: PUSH
84033: LD_INT 2
84035: ARRAY
84036: PPUSH
84037: CALL_OW 297
84041: ST_TO_ADDR
// end ; end ;
84042: GO 83931
84044: POP
84045: POP
// result := hex ;
84046: LD_ADDR_VAR 0 3
84050: PUSH
84051: LD_VAR 0 7
84055: ST_TO_ADDR
// end ;
84056: LD_VAR 0 3
84060: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84061: LD_INT 0
84063: PPUSH
84064: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84065: LD_VAR 0 1
84069: NOT
84070: PUSH
84071: LD_VAR 0 1
84075: PUSH
84076: LD_INT 21
84078: PUSH
84079: LD_INT 2
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 23
84088: PUSH
84089: LD_INT 2
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: EMPTY
84097: LIST
84098: LIST
84099: PPUSH
84100: CALL_OW 69
84104: IN
84105: NOT
84106: OR
84107: IFFALSE 84111
// exit ;
84109: GO 84158
// for i = 1 to 3 do
84111: LD_ADDR_VAR 0 3
84115: PUSH
84116: DOUBLE
84117: LD_INT 1
84119: DEC
84120: ST_TO_ADDR
84121: LD_INT 3
84123: PUSH
84124: FOR_TO
84125: IFFALSE 84156
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84127: LD_VAR 0 1
84131: PPUSH
84132: CALL_OW 250
84136: PPUSH
84137: LD_VAR 0 1
84141: PPUSH
84142: CALL_OW 251
84146: PPUSH
84147: LD_INT 1
84149: PPUSH
84150: CALL_OW 453
84154: GO 84124
84156: POP
84157: POP
// end ;
84158: LD_VAR 0 2
84162: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84163: LD_INT 0
84165: PPUSH
84166: PPUSH
84167: PPUSH
84168: PPUSH
84169: PPUSH
84170: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84171: LD_VAR 0 1
84175: NOT
84176: PUSH
84177: LD_VAR 0 2
84181: NOT
84182: OR
84183: PUSH
84184: LD_VAR 0 1
84188: PPUSH
84189: CALL_OW 314
84193: OR
84194: IFFALSE 84198
// exit ;
84196: GO 84639
// x := GetX ( enemy_unit ) ;
84198: LD_ADDR_VAR 0 7
84202: PUSH
84203: LD_VAR 0 2
84207: PPUSH
84208: CALL_OW 250
84212: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84213: LD_ADDR_VAR 0 8
84217: PUSH
84218: LD_VAR 0 2
84222: PPUSH
84223: CALL_OW 251
84227: ST_TO_ADDR
// if not x or not y then
84228: LD_VAR 0 7
84232: NOT
84233: PUSH
84234: LD_VAR 0 8
84238: NOT
84239: OR
84240: IFFALSE 84244
// exit ;
84242: GO 84639
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84244: LD_ADDR_VAR 0 6
84248: PUSH
84249: LD_VAR 0 7
84253: PPUSH
84254: LD_INT 0
84256: PPUSH
84257: LD_INT 4
84259: PPUSH
84260: CALL_OW 272
84264: PUSH
84265: LD_VAR 0 8
84269: PPUSH
84270: LD_INT 0
84272: PPUSH
84273: LD_INT 4
84275: PPUSH
84276: CALL_OW 273
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_VAR 0 7
84289: PPUSH
84290: LD_INT 1
84292: PPUSH
84293: LD_INT 4
84295: PPUSH
84296: CALL_OW 272
84300: PUSH
84301: LD_VAR 0 8
84305: PPUSH
84306: LD_INT 1
84308: PPUSH
84309: LD_INT 4
84311: PPUSH
84312: CALL_OW 273
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_VAR 0 7
84325: PPUSH
84326: LD_INT 2
84328: PPUSH
84329: LD_INT 4
84331: PPUSH
84332: CALL_OW 272
84336: PUSH
84337: LD_VAR 0 8
84341: PPUSH
84342: LD_INT 2
84344: PPUSH
84345: LD_INT 4
84347: PPUSH
84348: CALL_OW 273
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_VAR 0 7
84361: PPUSH
84362: LD_INT 3
84364: PPUSH
84365: LD_INT 4
84367: PPUSH
84368: CALL_OW 272
84372: PUSH
84373: LD_VAR 0 8
84377: PPUSH
84378: LD_INT 3
84380: PPUSH
84381: LD_INT 4
84383: PPUSH
84384: CALL_OW 273
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_VAR 0 7
84397: PPUSH
84398: LD_INT 4
84400: PPUSH
84401: LD_INT 4
84403: PPUSH
84404: CALL_OW 272
84408: PUSH
84409: LD_VAR 0 8
84413: PPUSH
84414: LD_INT 4
84416: PPUSH
84417: LD_INT 4
84419: PPUSH
84420: CALL_OW 273
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_VAR 0 7
84433: PPUSH
84434: LD_INT 5
84436: PPUSH
84437: LD_INT 4
84439: PPUSH
84440: CALL_OW 272
84444: PUSH
84445: LD_VAR 0 8
84449: PPUSH
84450: LD_INT 5
84452: PPUSH
84453: LD_INT 4
84455: PPUSH
84456: CALL_OW 273
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: ST_TO_ADDR
// for i = tmp downto 1 do
84473: LD_ADDR_VAR 0 4
84477: PUSH
84478: DOUBLE
84479: LD_VAR 0 6
84483: INC
84484: ST_TO_ADDR
84485: LD_INT 1
84487: PUSH
84488: FOR_DOWNTO
84489: IFFALSE 84590
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84491: LD_VAR 0 6
84495: PUSH
84496: LD_VAR 0 4
84500: ARRAY
84501: PUSH
84502: LD_INT 1
84504: ARRAY
84505: PPUSH
84506: LD_VAR 0 6
84510: PUSH
84511: LD_VAR 0 4
84515: ARRAY
84516: PUSH
84517: LD_INT 2
84519: ARRAY
84520: PPUSH
84521: CALL_OW 488
84525: NOT
84526: PUSH
84527: LD_VAR 0 6
84531: PUSH
84532: LD_VAR 0 4
84536: ARRAY
84537: PUSH
84538: LD_INT 1
84540: ARRAY
84541: PPUSH
84542: LD_VAR 0 6
84546: PUSH
84547: LD_VAR 0 4
84551: ARRAY
84552: PUSH
84553: LD_INT 2
84555: ARRAY
84556: PPUSH
84557: CALL_OW 428
84561: PUSH
84562: LD_INT 0
84564: NONEQUAL
84565: OR
84566: IFFALSE 84588
// tmp := Delete ( tmp , i ) ;
84568: LD_ADDR_VAR 0 6
84572: PUSH
84573: LD_VAR 0 6
84577: PPUSH
84578: LD_VAR 0 4
84582: PPUSH
84583: CALL_OW 3
84587: ST_TO_ADDR
84588: GO 84488
84590: POP
84591: POP
// j := GetClosestHex ( unit , tmp ) ;
84592: LD_ADDR_VAR 0 5
84596: PUSH
84597: LD_VAR 0 1
84601: PPUSH
84602: LD_VAR 0 6
84606: PPUSH
84607: CALL 83892 0 2
84611: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84612: LD_VAR 0 1
84616: PPUSH
84617: LD_VAR 0 5
84621: PUSH
84622: LD_INT 1
84624: ARRAY
84625: PPUSH
84626: LD_VAR 0 5
84630: PUSH
84631: LD_INT 2
84633: ARRAY
84634: PPUSH
84635: CALL_OW 111
// end ;
84639: LD_VAR 0 3
84643: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84644: LD_INT 0
84646: PPUSH
84647: PPUSH
84648: PPUSH
// uc_side = 0 ;
84649: LD_ADDR_OWVAR 20
84653: PUSH
84654: LD_INT 0
84656: ST_TO_ADDR
// uc_nation = 0 ;
84657: LD_ADDR_OWVAR 21
84661: PUSH
84662: LD_INT 0
84664: ST_TO_ADDR
// InitHc_All ( ) ;
84665: CALL_OW 584
// InitVc ;
84669: CALL_OW 20
// if mastodonts then
84673: LD_VAR 0 6
84677: IFFALSE 84744
// for i = 1 to mastodonts do
84679: LD_ADDR_VAR 0 11
84683: PUSH
84684: DOUBLE
84685: LD_INT 1
84687: DEC
84688: ST_TO_ADDR
84689: LD_VAR 0 6
84693: PUSH
84694: FOR_TO
84695: IFFALSE 84742
// begin vc_chassis := 31 ;
84697: LD_ADDR_OWVAR 37
84701: PUSH
84702: LD_INT 31
84704: ST_TO_ADDR
// vc_control := control_rider ;
84705: LD_ADDR_OWVAR 38
84709: PUSH
84710: LD_INT 4
84712: ST_TO_ADDR
// animal := CreateVehicle ;
84713: LD_ADDR_VAR 0 12
84717: PUSH
84718: CALL_OW 45
84722: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84723: LD_VAR 0 12
84727: PPUSH
84728: LD_VAR 0 8
84732: PPUSH
84733: LD_INT 0
84735: PPUSH
84736: CALL 86932 0 3
// end ;
84740: GO 84694
84742: POP
84743: POP
// if horses then
84744: LD_VAR 0 5
84748: IFFALSE 84815
// for i = 1 to horses do
84750: LD_ADDR_VAR 0 11
84754: PUSH
84755: DOUBLE
84756: LD_INT 1
84758: DEC
84759: ST_TO_ADDR
84760: LD_VAR 0 5
84764: PUSH
84765: FOR_TO
84766: IFFALSE 84813
// begin hc_class := 21 ;
84768: LD_ADDR_OWVAR 28
84772: PUSH
84773: LD_INT 21
84775: ST_TO_ADDR
// hc_gallery :=  ;
84776: LD_ADDR_OWVAR 33
84780: PUSH
84781: LD_STRING 
84783: ST_TO_ADDR
// animal := CreateHuman ;
84784: LD_ADDR_VAR 0 12
84788: PUSH
84789: CALL_OW 44
84793: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84794: LD_VAR 0 12
84798: PPUSH
84799: LD_VAR 0 8
84803: PPUSH
84804: LD_INT 0
84806: PPUSH
84807: CALL 86932 0 3
// end ;
84811: GO 84765
84813: POP
84814: POP
// if birds then
84815: LD_VAR 0 1
84819: IFFALSE 84886
// for i = 1 to birds do
84821: LD_ADDR_VAR 0 11
84825: PUSH
84826: DOUBLE
84827: LD_INT 1
84829: DEC
84830: ST_TO_ADDR
84831: LD_VAR 0 1
84835: PUSH
84836: FOR_TO
84837: IFFALSE 84884
// begin hc_class = 18 ;
84839: LD_ADDR_OWVAR 28
84843: PUSH
84844: LD_INT 18
84846: ST_TO_ADDR
// hc_gallery =  ;
84847: LD_ADDR_OWVAR 33
84851: PUSH
84852: LD_STRING 
84854: ST_TO_ADDR
// animal := CreateHuman ;
84855: LD_ADDR_VAR 0 12
84859: PUSH
84860: CALL_OW 44
84864: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84865: LD_VAR 0 12
84869: PPUSH
84870: LD_VAR 0 8
84874: PPUSH
84875: LD_INT 0
84877: PPUSH
84878: CALL 86932 0 3
// end ;
84882: GO 84836
84884: POP
84885: POP
// if tigers then
84886: LD_VAR 0 2
84890: IFFALSE 84974
// for i = 1 to tigers do
84892: LD_ADDR_VAR 0 11
84896: PUSH
84897: DOUBLE
84898: LD_INT 1
84900: DEC
84901: ST_TO_ADDR
84902: LD_VAR 0 2
84906: PUSH
84907: FOR_TO
84908: IFFALSE 84972
// begin hc_class = class_tiger ;
84910: LD_ADDR_OWVAR 28
84914: PUSH
84915: LD_INT 14
84917: ST_TO_ADDR
// hc_gallery =  ;
84918: LD_ADDR_OWVAR 33
84922: PUSH
84923: LD_STRING 
84925: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84926: LD_ADDR_OWVAR 35
84930: PUSH
84931: LD_INT 7
84933: NEG
84934: PPUSH
84935: LD_INT 7
84937: PPUSH
84938: CALL_OW 12
84942: ST_TO_ADDR
// animal := CreateHuman ;
84943: LD_ADDR_VAR 0 12
84947: PUSH
84948: CALL_OW 44
84952: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84953: LD_VAR 0 12
84957: PPUSH
84958: LD_VAR 0 8
84962: PPUSH
84963: LD_INT 0
84965: PPUSH
84966: CALL 86932 0 3
// end ;
84970: GO 84907
84972: POP
84973: POP
// if apemans then
84974: LD_VAR 0 3
84978: IFFALSE 85101
// for i = 1 to apemans do
84980: LD_ADDR_VAR 0 11
84984: PUSH
84985: DOUBLE
84986: LD_INT 1
84988: DEC
84989: ST_TO_ADDR
84990: LD_VAR 0 3
84994: PUSH
84995: FOR_TO
84996: IFFALSE 85099
// begin hc_class = class_apeman ;
84998: LD_ADDR_OWVAR 28
85002: PUSH
85003: LD_INT 12
85005: ST_TO_ADDR
// hc_gallery =  ;
85006: LD_ADDR_OWVAR 33
85010: PUSH
85011: LD_STRING 
85013: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85014: LD_ADDR_OWVAR 35
85018: PUSH
85019: LD_INT 2
85021: NEG
85022: PPUSH
85023: LD_INT 2
85025: PPUSH
85026: CALL_OW 12
85030: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85031: LD_ADDR_OWVAR 31
85035: PUSH
85036: LD_INT 1
85038: PPUSH
85039: LD_INT 3
85041: PPUSH
85042: CALL_OW 12
85046: PUSH
85047: LD_INT 1
85049: PPUSH
85050: LD_INT 3
85052: PPUSH
85053: CALL_OW 12
85057: PUSH
85058: LD_INT 0
85060: PUSH
85061: LD_INT 0
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: ST_TO_ADDR
// animal := CreateHuman ;
85070: LD_ADDR_VAR 0 12
85074: PUSH
85075: CALL_OW 44
85079: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85080: LD_VAR 0 12
85084: PPUSH
85085: LD_VAR 0 8
85089: PPUSH
85090: LD_INT 0
85092: PPUSH
85093: CALL 86932 0 3
// end ;
85097: GO 84995
85099: POP
85100: POP
// if enchidnas then
85101: LD_VAR 0 4
85105: IFFALSE 85172
// for i = 1 to enchidnas do
85107: LD_ADDR_VAR 0 11
85111: PUSH
85112: DOUBLE
85113: LD_INT 1
85115: DEC
85116: ST_TO_ADDR
85117: LD_VAR 0 4
85121: PUSH
85122: FOR_TO
85123: IFFALSE 85170
// begin hc_class = 13 ;
85125: LD_ADDR_OWVAR 28
85129: PUSH
85130: LD_INT 13
85132: ST_TO_ADDR
// hc_gallery =  ;
85133: LD_ADDR_OWVAR 33
85137: PUSH
85138: LD_STRING 
85140: ST_TO_ADDR
// animal := CreateHuman ;
85141: LD_ADDR_VAR 0 12
85145: PUSH
85146: CALL_OW 44
85150: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85151: LD_VAR 0 12
85155: PPUSH
85156: LD_VAR 0 8
85160: PPUSH
85161: LD_INT 0
85163: PPUSH
85164: CALL 86932 0 3
// end ;
85168: GO 85122
85170: POP
85171: POP
// if fishes then
85172: LD_VAR 0 7
85176: IFFALSE 85243
// for i = 1 to fishes do
85178: LD_ADDR_VAR 0 11
85182: PUSH
85183: DOUBLE
85184: LD_INT 1
85186: DEC
85187: ST_TO_ADDR
85188: LD_VAR 0 7
85192: PUSH
85193: FOR_TO
85194: IFFALSE 85241
// begin hc_class = 20 ;
85196: LD_ADDR_OWVAR 28
85200: PUSH
85201: LD_INT 20
85203: ST_TO_ADDR
// hc_gallery =  ;
85204: LD_ADDR_OWVAR 33
85208: PUSH
85209: LD_STRING 
85211: ST_TO_ADDR
// animal := CreateHuman ;
85212: LD_ADDR_VAR 0 12
85216: PUSH
85217: CALL_OW 44
85221: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85222: LD_VAR 0 12
85226: PPUSH
85227: LD_VAR 0 9
85231: PPUSH
85232: LD_INT 0
85234: PPUSH
85235: CALL 86932 0 3
// end ;
85239: GO 85193
85241: POP
85242: POP
// end ;
85243: LD_VAR 0 10
85247: RET
// export function WantHeal ( sci , unit ) ; begin
85248: LD_INT 0
85250: PPUSH
// if GetTaskList ( sci ) > 0 then
85251: LD_VAR 0 1
85255: PPUSH
85256: CALL_OW 437
85260: PUSH
85261: LD_INT 0
85263: GREATER
85264: IFFALSE 85334
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85266: LD_VAR 0 1
85270: PPUSH
85271: CALL_OW 437
85275: PUSH
85276: LD_INT 1
85278: ARRAY
85279: PUSH
85280: LD_INT 1
85282: ARRAY
85283: PUSH
85284: LD_STRING l
85286: EQUAL
85287: PUSH
85288: LD_VAR 0 1
85292: PPUSH
85293: CALL_OW 437
85297: PUSH
85298: LD_INT 1
85300: ARRAY
85301: PUSH
85302: LD_INT 4
85304: ARRAY
85305: PUSH
85306: LD_VAR 0 2
85310: EQUAL
85311: AND
85312: IFFALSE 85324
// result := true else
85314: LD_ADDR_VAR 0 3
85318: PUSH
85319: LD_INT 1
85321: ST_TO_ADDR
85322: GO 85332
// result := false ;
85324: LD_ADDR_VAR 0 3
85328: PUSH
85329: LD_INT 0
85331: ST_TO_ADDR
// end else
85332: GO 85342
// result := false ;
85334: LD_ADDR_VAR 0 3
85338: PUSH
85339: LD_INT 0
85341: ST_TO_ADDR
// end ;
85342: LD_VAR 0 3
85346: RET
// export function HealTarget ( sci ) ; begin
85347: LD_INT 0
85349: PPUSH
// if not sci then
85350: LD_VAR 0 1
85354: NOT
85355: IFFALSE 85359
// exit ;
85357: GO 85424
// result := 0 ;
85359: LD_ADDR_VAR 0 2
85363: PUSH
85364: LD_INT 0
85366: ST_TO_ADDR
// if GetTaskList ( sci ) then
85367: LD_VAR 0 1
85371: PPUSH
85372: CALL_OW 437
85376: IFFALSE 85424
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85378: LD_VAR 0 1
85382: PPUSH
85383: CALL_OW 437
85387: PUSH
85388: LD_INT 1
85390: ARRAY
85391: PUSH
85392: LD_INT 1
85394: ARRAY
85395: PUSH
85396: LD_STRING l
85398: EQUAL
85399: IFFALSE 85424
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85401: LD_ADDR_VAR 0 2
85405: PUSH
85406: LD_VAR 0 1
85410: PPUSH
85411: CALL_OW 437
85415: PUSH
85416: LD_INT 1
85418: ARRAY
85419: PUSH
85420: LD_INT 4
85422: ARRAY
85423: ST_TO_ADDR
// end ;
85424: LD_VAR 0 2
85428: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
85429: LD_INT 0
85431: PPUSH
85432: PPUSH
85433: PPUSH
85434: PPUSH
// if not base_units then
85435: LD_VAR 0 1
85439: NOT
85440: IFFALSE 85444
// exit ;
85442: GO 85531
// result := false ;
85444: LD_ADDR_VAR 0 2
85448: PUSH
85449: LD_INT 0
85451: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
85452: LD_ADDR_VAR 0 5
85456: PUSH
85457: LD_VAR 0 1
85461: PPUSH
85462: LD_INT 21
85464: PUSH
85465: LD_INT 3
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PPUSH
85472: CALL_OW 72
85476: ST_TO_ADDR
// if not tmp then
85477: LD_VAR 0 5
85481: NOT
85482: IFFALSE 85486
// exit ;
85484: GO 85531
// for i in tmp do
85486: LD_ADDR_VAR 0 3
85490: PUSH
85491: LD_VAR 0 5
85495: PUSH
85496: FOR_IN
85497: IFFALSE 85529
// begin result := EnemyInRange ( i , 22 ) ;
85499: LD_ADDR_VAR 0 2
85503: PUSH
85504: LD_VAR 0 3
85508: PPUSH
85509: LD_INT 22
85511: PPUSH
85512: CALL 83767 0 2
85516: ST_TO_ADDR
// if result then
85517: LD_VAR 0 2
85521: IFFALSE 85527
// exit ;
85523: POP
85524: POP
85525: GO 85531
// end ;
85527: GO 85496
85529: POP
85530: POP
// end ;
85531: LD_VAR 0 2
85535: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
85536: LD_INT 0
85538: PPUSH
85539: PPUSH
// if not units then
85540: LD_VAR 0 1
85544: NOT
85545: IFFALSE 85549
// exit ;
85547: GO 85619
// result := [ ] ;
85549: LD_ADDR_VAR 0 3
85553: PUSH
85554: EMPTY
85555: ST_TO_ADDR
// for i in units do
85556: LD_ADDR_VAR 0 4
85560: PUSH
85561: LD_VAR 0 1
85565: PUSH
85566: FOR_IN
85567: IFFALSE 85617
// if GetTag ( i ) = tag then
85569: LD_VAR 0 4
85573: PPUSH
85574: CALL_OW 110
85578: PUSH
85579: LD_VAR 0 2
85583: EQUAL
85584: IFFALSE 85615
// result := Replace ( result , result + 1 , i ) ;
85586: LD_ADDR_VAR 0 3
85590: PUSH
85591: LD_VAR 0 3
85595: PPUSH
85596: LD_VAR 0 3
85600: PUSH
85601: LD_INT 1
85603: PLUS
85604: PPUSH
85605: LD_VAR 0 4
85609: PPUSH
85610: CALL_OW 1
85614: ST_TO_ADDR
85615: GO 85566
85617: POP
85618: POP
// end ;
85619: LD_VAR 0 3
85623: RET
// export function IsDriver ( un ) ; begin
85624: LD_INT 0
85626: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
85627: LD_ADDR_VAR 0 2
85631: PUSH
85632: LD_VAR 0 1
85636: PUSH
85637: LD_INT 55
85639: PUSH
85640: EMPTY
85641: LIST
85642: PPUSH
85643: CALL_OW 69
85647: IN
85648: ST_TO_ADDR
// end ;
85649: LD_VAR 0 2
85653: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
85654: LD_INT 0
85656: PPUSH
85657: PPUSH
// list := [ ] ;
85658: LD_ADDR_VAR 0 5
85662: PUSH
85663: EMPTY
85664: ST_TO_ADDR
// case d of 0 :
85665: LD_VAR 0 3
85669: PUSH
85670: LD_INT 0
85672: DOUBLE
85673: EQUAL
85674: IFTRUE 85678
85676: GO 85811
85678: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
85679: LD_ADDR_VAR 0 5
85683: PUSH
85684: LD_VAR 0 1
85688: PUSH
85689: LD_INT 4
85691: MINUS
85692: PUSH
85693: LD_VAR 0 2
85697: PUSH
85698: LD_INT 4
85700: MINUS
85701: PUSH
85702: LD_INT 2
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: LIST
85709: PUSH
85710: LD_VAR 0 1
85714: PUSH
85715: LD_INT 3
85717: MINUS
85718: PUSH
85719: LD_VAR 0 2
85723: PUSH
85724: LD_INT 1
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: LIST
85731: PUSH
85732: LD_VAR 0 1
85736: PUSH
85737: LD_INT 4
85739: PLUS
85740: PUSH
85741: LD_VAR 0 2
85745: PUSH
85746: LD_INT 4
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: LIST
85753: PUSH
85754: LD_VAR 0 1
85758: PUSH
85759: LD_INT 3
85761: PLUS
85762: PUSH
85763: LD_VAR 0 2
85767: PUSH
85768: LD_INT 3
85770: PLUS
85771: PUSH
85772: LD_INT 5
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: LIST
85779: PUSH
85780: LD_VAR 0 1
85784: PUSH
85785: LD_VAR 0 2
85789: PUSH
85790: LD_INT 4
85792: PLUS
85793: PUSH
85794: LD_INT 0
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: LIST
85801: PUSH
85802: EMPTY
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: ST_TO_ADDR
// end ; 1 :
85809: GO 86509
85811: LD_INT 1
85813: DOUBLE
85814: EQUAL
85815: IFTRUE 85819
85817: GO 85952
85819: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
85820: LD_ADDR_VAR 0 5
85824: PUSH
85825: LD_VAR 0 1
85829: PUSH
85830: LD_VAR 0 2
85834: PUSH
85835: LD_INT 4
85837: MINUS
85838: PUSH
85839: LD_INT 3
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: LIST
85846: PUSH
85847: LD_VAR 0 1
85851: PUSH
85852: LD_INT 3
85854: MINUS
85855: PUSH
85856: LD_VAR 0 2
85860: PUSH
85861: LD_INT 3
85863: MINUS
85864: PUSH
85865: LD_INT 2
85867: PUSH
85868: EMPTY
85869: LIST
85870: LIST
85871: LIST
85872: PUSH
85873: LD_VAR 0 1
85877: PUSH
85878: LD_INT 4
85880: MINUS
85881: PUSH
85882: LD_VAR 0 2
85886: PUSH
85887: LD_INT 1
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: LIST
85894: PUSH
85895: LD_VAR 0 1
85899: PUSH
85900: LD_VAR 0 2
85904: PUSH
85905: LD_INT 3
85907: PLUS
85908: PUSH
85909: LD_INT 0
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: LIST
85916: PUSH
85917: LD_VAR 0 1
85921: PUSH
85922: LD_INT 4
85924: PLUS
85925: PUSH
85926: LD_VAR 0 2
85930: PUSH
85931: LD_INT 4
85933: PLUS
85934: PUSH
85935: LD_INT 5
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: LIST
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: ST_TO_ADDR
// end ; 2 :
85950: GO 86509
85952: LD_INT 2
85954: DOUBLE
85955: EQUAL
85956: IFTRUE 85960
85958: GO 86089
85960: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
85961: LD_ADDR_VAR 0 5
85965: PUSH
85966: LD_VAR 0 1
85970: PUSH
85971: LD_VAR 0 2
85975: PUSH
85976: LD_INT 3
85978: MINUS
85979: PUSH
85980: LD_INT 3
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: LIST
85987: PUSH
85988: LD_VAR 0 1
85992: PUSH
85993: LD_INT 4
85995: PLUS
85996: PUSH
85997: LD_VAR 0 2
86001: PUSH
86002: LD_INT 4
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: LIST
86009: PUSH
86010: LD_VAR 0 1
86014: PUSH
86015: LD_VAR 0 2
86019: PUSH
86020: LD_INT 4
86022: PLUS
86023: PUSH
86024: LD_INT 0
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: LIST
86031: PUSH
86032: LD_VAR 0 1
86036: PUSH
86037: LD_INT 3
86039: MINUS
86040: PUSH
86041: LD_VAR 0 2
86045: PUSH
86046: LD_INT 1
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: LIST
86053: PUSH
86054: LD_VAR 0 1
86058: PUSH
86059: LD_INT 4
86061: MINUS
86062: PUSH
86063: LD_VAR 0 2
86067: PUSH
86068: LD_INT 4
86070: MINUS
86071: PUSH
86072: LD_INT 2
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: LIST
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: ST_TO_ADDR
// end ; 3 :
86087: GO 86509
86089: LD_INT 3
86091: DOUBLE
86092: EQUAL
86093: IFTRUE 86097
86095: GO 86230
86097: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86098: LD_ADDR_VAR 0 5
86102: PUSH
86103: LD_VAR 0 1
86107: PUSH
86108: LD_INT 3
86110: PLUS
86111: PUSH
86112: LD_VAR 0 2
86116: PUSH
86117: LD_INT 4
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: LIST
86124: PUSH
86125: LD_VAR 0 1
86129: PUSH
86130: LD_INT 4
86132: PLUS
86133: PUSH
86134: LD_VAR 0 2
86138: PUSH
86139: LD_INT 4
86141: PLUS
86142: PUSH
86143: LD_INT 5
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: LIST
86150: PUSH
86151: LD_VAR 0 1
86155: PUSH
86156: LD_INT 4
86158: MINUS
86159: PUSH
86160: LD_VAR 0 2
86164: PUSH
86165: LD_INT 1
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: LIST
86172: PUSH
86173: LD_VAR 0 1
86177: PUSH
86178: LD_VAR 0 2
86182: PUSH
86183: LD_INT 4
86185: MINUS
86186: PUSH
86187: LD_INT 3
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: LIST
86194: PUSH
86195: LD_VAR 0 1
86199: PUSH
86200: LD_INT 3
86202: MINUS
86203: PUSH
86204: LD_VAR 0 2
86208: PUSH
86209: LD_INT 3
86211: MINUS
86212: PUSH
86213: LD_INT 2
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: LIST
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: ST_TO_ADDR
// end ; 4 :
86228: GO 86509
86230: LD_INT 4
86232: DOUBLE
86233: EQUAL
86234: IFTRUE 86238
86236: GO 86371
86238: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86239: LD_ADDR_VAR 0 5
86243: PUSH
86244: LD_VAR 0 1
86248: PUSH
86249: LD_VAR 0 2
86253: PUSH
86254: LD_INT 4
86256: PLUS
86257: PUSH
86258: LD_INT 0
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: LIST
86265: PUSH
86266: LD_VAR 0 1
86270: PUSH
86271: LD_INT 3
86273: PLUS
86274: PUSH
86275: LD_VAR 0 2
86279: PUSH
86280: LD_INT 3
86282: PLUS
86283: PUSH
86284: LD_INT 5
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: LIST
86291: PUSH
86292: LD_VAR 0 1
86296: PUSH
86297: LD_INT 4
86299: PLUS
86300: PUSH
86301: LD_VAR 0 2
86305: PUSH
86306: LD_INT 4
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: LIST
86313: PUSH
86314: LD_VAR 0 1
86318: PUSH
86319: LD_VAR 0 2
86323: PUSH
86324: LD_INT 3
86326: MINUS
86327: PUSH
86328: LD_INT 3
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: LIST
86335: PUSH
86336: LD_VAR 0 1
86340: PUSH
86341: LD_INT 4
86343: MINUS
86344: PUSH
86345: LD_VAR 0 2
86349: PUSH
86350: LD_INT 4
86352: MINUS
86353: PUSH
86354: LD_INT 2
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: LIST
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: LIST
86368: ST_TO_ADDR
// end ; 5 :
86369: GO 86509
86371: LD_INT 5
86373: DOUBLE
86374: EQUAL
86375: IFTRUE 86379
86377: GO 86508
86379: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
86380: LD_ADDR_VAR 0 5
86384: PUSH
86385: LD_VAR 0 1
86389: PUSH
86390: LD_INT 4
86392: MINUS
86393: PUSH
86394: LD_VAR 0 2
86398: PUSH
86399: LD_INT 1
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: LIST
86406: PUSH
86407: LD_VAR 0 1
86411: PUSH
86412: LD_VAR 0 2
86416: PUSH
86417: LD_INT 4
86419: MINUS
86420: PUSH
86421: LD_INT 3
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: LIST
86428: PUSH
86429: LD_VAR 0 1
86433: PUSH
86434: LD_INT 4
86436: PLUS
86437: PUSH
86438: LD_VAR 0 2
86442: PUSH
86443: LD_INT 4
86445: PLUS
86446: PUSH
86447: LD_INT 5
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: LIST
86454: PUSH
86455: LD_VAR 0 1
86459: PUSH
86460: LD_INT 3
86462: PLUS
86463: PUSH
86464: LD_VAR 0 2
86468: PUSH
86469: LD_INT 4
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: LIST
86476: PUSH
86477: LD_VAR 0 1
86481: PUSH
86482: LD_VAR 0 2
86486: PUSH
86487: LD_INT 3
86489: PLUS
86490: PUSH
86491: LD_INT 0
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: LIST
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: LIST
86503: LIST
86504: LIST
86505: ST_TO_ADDR
// end ; end ;
86506: GO 86509
86508: POP
// result := list ;
86509: LD_ADDR_VAR 0 4
86513: PUSH
86514: LD_VAR 0 5
86518: ST_TO_ADDR
// end ;
86519: LD_VAR 0 4
86523: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
86524: LD_INT 0
86526: PPUSH
86527: PPUSH
86528: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
86529: LD_VAR 0 1
86533: NOT
86534: PUSH
86535: LD_VAR 0 2
86539: PUSH
86540: LD_INT 1
86542: PUSH
86543: LD_INT 2
86545: PUSH
86546: LD_INT 3
86548: PUSH
86549: LD_INT 4
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: IN
86558: NOT
86559: OR
86560: IFFALSE 86564
// exit ;
86562: GO 86656
// tmp := [ ] ;
86564: LD_ADDR_VAR 0 5
86568: PUSH
86569: EMPTY
86570: ST_TO_ADDR
// for i in units do
86571: LD_ADDR_VAR 0 4
86575: PUSH
86576: LD_VAR 0 1
86580: PUSH
86581: FOR_IN
86582: IFFALSE 86625
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
86584: LD_ADDR_VAR 0 5
86588: PUSH
86589: LD_VAR 0 5
86593: PPUSH
86594: LD_VAR 0 5
86598: PUSH
86599: LD_INT 1
86601: PLUS
86602: PPUSH
86603: LD_VAR 0 4
86607: PPUSH
86608: LD_VAR 0 2
86612: PPUSH
86613: CALL_OW 259
86617: PPUSH
86618: CALL_OW 2
86622: ST_TO_ADDR
86623: GO 86581
86625: POP
86626: POP
// if not tmp then
86627: LD_VAR 0 5
86631: NOT
86632: IFFALSE 86636
// exit ;
86634: GO 86656
// result := SortListByListDesc ( units , tmp ) ;
86636: LD_ADDR_VAR 0 3
86640: PUSH
86641: LD_VAR 0 1
86645: PPUSH
86646: LD_VAR 0 5
86650: PPUSH
86651: CALL_OW 77
86655: ST_TO_ADDR
// end ;
86656: LD_VAR 0 3
86660: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
86661: LD_INT 0
86663: PPUSH
86664: PPUSH
86665: PPUSH
// result := false ;
86666: LD_ADDR_VAR 0 3
86670: PUSH
86671: LD_INT 0
86673: ST_TO_ADDR
// x := GetX ( building ) ;
86674: LD_ADDR_VAR 0 4
86678: PUSH
86679: LD_VAR 0 2
86683: PPUSH
86684: CALL_OW 250
86688: ST_TO_ADDR
// y := GetY ( building ) ;
86689: LD_ADDR_VAR 0 5
86693: PUSH
86694: LD_VAR 0 2
86698: PPUSH
86699: CALL_OW 251
86703: ST_TO_ADDR
// if not building or not x or not y then
86704: LD_VAR 0 2
86708: NOT
86709: PUSH
86710: LD_VAR 0 4
86714: NOT
86715: OR
86716: PUSH
86717: LD_VAR 0 5
86721: NOT
86722: OR
86723: IFFALSE 86727
// exit ;
86725: GO 86819
// if GetTaskList ( unit ) then
86727: LD_VAR 0 1
86731: PPUSH
86732: CALL_OW 437
86736: IFFALSE 86819
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86738: LD_STRING e
86740: PUSH
86741: LD_VAR 0 1
86745: PPUSH
86746: CALL_OW 437
86750: PUSH
86751: LD_INT 1
86753: ARRAY
86754: PUSH
86755: LD_INT 1
86757: ARRAY
86758: EQUAL
86759: PUSH
86760: LD_VAR 0 4
86764: PUSH
86765: LD_VAR 0 1
86769: PPUSH
86770: CALL_OW 437
86774: PUSH
86775: LD_INT 1
86777: ARRAY
86778: PUSH
86779: LD_INT 2
86781: ARRAY
86782: EQUAL
86783: AND
86784: PUSH
86785: LD_VAR 0 5
86789: PUSH
86790: LD_VAR 0 1
86794: PPUSH
86795: CALL_OW 437
86799: PUSH
86800: LD_INT 1
86802: ARRAY
86803: PUSH
86804: LD_INT 3
86806: ARRAY
86807: EQUAL
86808: AND
86809: IFFALSE 86819
// result := true end ;
86811: LD_ADDR_VAR 0 3
86815: PUSH
86816: LD_INT 1
86818: ST_TO_ADDR
// end ;
86819: LD_VAR 0 3
86823: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
86824: LD_INT 0
86826: PPUSH
// result := false ;
86827: LD_ADDR_VAR 0 4
86831: PUSH
86832: LD_INT 0
86834: ST_TO_ADDR
// if GetTaskList ( unit ) then
86835: LD_VAR 0 1
86839: PPUSH
86840: CALL_OW 437
86844: IFFALSE 86927
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
86846: LD_STRING M
86848: PUSH
86849: LD_VAR 0 1
86853: PPUSH
86854: CALL_OW 437
86858: PUSH
86859: LD_INT 1
86861: ARRAY
86862: PUSH
86863: LD_INT 1
86865: ARRAY
86866: EQUAL
86867: PUSH
86868: LD_VAR 0 2
86872: PUSH
86873: LD_VAR 0 1
86877: PPUSH
86878: CALL_OW 437
86882: PUSH
86883: LD_INT 1
86885: ARRAY
86886: PUSH
86887: LD_INT 2
86889: ARRAY
86890: EQUAL
86891: AND
86892: PUSH
86893: LD_VAR 0 3
86897: PUSH
86898: LD_VAR 0 1
86902: PPUSH
86903: CALL_OW 437
86907: PUSH
86908: LD_INT 1
86910: ARRAY
86911: PUSH
86912: LD_INT 3
86914: ARRAY
86915: EQUAL
86916: AND
86917: IFFALSE 86927
// result := true ;
86919: LD_ADDR_VAR 0 4
86923: PUSH
86924: LD_INT 1
86926: ST_TO_ADDR
// end ; end ;
86927: LD_VAR 0 4
86931: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
86932: LD_INT 0
86934: PPUSH
86935: PPUSH
86936: PPUSH
86937: PPUSH
// if not unit or not area then
86938: LD_VAR 0 1
86942: NOT
86943: PUSH
86944: LD_VAR 0 2
86948: NOT
86949: OR
86950: IFFALSE 86954
// exit ;
86952: GO 87118
// tmp := AreaToList ( area , i ) ;
86954: LD_ADDR_VAR 0 6
86958: PUSH
86959: LD_VAR 0 2
86963: PPUSH
86964: LD_VAR 0 5
86968: PPUSH
86969: CALL_OW 517
86973: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
86974: LD_ADDR_VAR 0 5
86978: PUSH
86979: DOUBLE
86980: LD_INT 1
86982: DEC
86983: ST_TO_ADDR
86984: LD_VAR 0 6
86988: PUSH
86989: LD_INT 1
86991: ARRAY
86992: PUSH
86993: FOR_TO
86994: IFFALSE 87116
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
86996: LD_ADDR_VAR 0 7
87000: PUSH
87001: LD_VAR 0 6
87005: PUSH
87006: LD_INT 1
87008: ARRAY
87009: PUSH
87010: LD_VAR 0 5
87014: ARRAY
87015: PUSH
87016: LD_VAR 0 6
87020: PUSH
87021: LD_INT 2
87023: ARRAY
87024: PUSH
87025: LD_VAR 0 5
87029: ARRAY
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87035: LD_VAR 0 7
87039: PUSH
87040: LD_INT 1
87042: ARRAY
87043: PPUSH
87044: LD_VAR 0 7
87048: PUSH
87049: LD_INT 2
87051: ARRAY
87052: PPUSH
87053: CALL_OW 428
87057: PUSH
87058: LD_INT 0
87060: EQUAL
87061: IFFALSE 87114
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87063: LD_VAR 0 1
87067: PPUSH
87068: LD_VAR 0 7
87072: PUSH
87073: LD_INT 1
87075: ARRAY
87076: PPUSH
87077: LD_VAR 0 7
87081: PUSH
87082: LD_INT 2
87084: ARRAY
87085: PPUSH
87086: LD_VAR 0 3
87090: PPUSH
87091: CALL_OW 48
// result := IsPlaced ( unit ) ;
87095: LD_ADDR_VAR 0 4
87099: PUSH
87100: LD_VAR 0 1
87104: PPUSH
87105: CALL_OW 305
87109: ST_TO_ADDR
// exit ;
87110: POP
87111: POP
87112: GO 87118
// end ; end ;
87114: GO 86993
87116: POP
87117: POP
// end ;
87118: LD_VAR 0 4
87122: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87123: LD_INT 0
87125: PPUSH
87126: PPUSH
87127: PPUSH
// if not side or side > 8 then
87128: LD_VAR 0 1
87132: NOT
87133: PUSH
87134: LD_VAR 0 1
87138: PUSH
87139: LD_INT 8
87141: GREATER
87142: OR
87143: IFFALSE 87147
// exit ;
87145: GO 87334
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87147: LD_ADDR_VAR 0 4
87151: PUSH
87152: LD_INT 22
87154: PUSH
87155: LD_VAR 0 1
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: PUSH
87164: LD_INT 21
87166: PUSH
87167: LD_INT 3
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PPUSH
87178: CALL_OW 69
87182: ST_TO_ADDR
// if not tmp then
87183: LD_VAR 0 4
87187: NOT
87188: IFFALSE 87192
// exit ;
87190: GO 87334
// enable_addtolog := true ;
87192: LD_ADDR_OWVAR 81
87196: PUSH
87197: LD_INT 1
87199: ST_TO_ADDR
// AddToLog ( [ ) ;
87200: LD_STRING [
87202: PPUSH
87203: CALL_OW 561
// for i in tmp do
87207: LD_ADDR_VAR 0 3
87211: PUSH
87212: LD_VAR 0 4
87216: PUSH
87217: FOR_IN
87218: IFFALSE 87325
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87220: LD_STRING [
87222: PUSH
87223: LD_VAR 0 3
87227: PPUSH
87228: CALL_OW 266
87232: STR
87233: PUSH
87234: LD_STRING , 
87236: STR
87237: PUSH
87238: LD_VAR 0 3
87242: PPUSH
87243: CALL_OW 250
87247: STR
87248: PUSH
87249: LD_STRING , 
87251: STR
87252: PUSH
87253: LD_VAR 0 3
87257: PPUSH
87258: CALL_OW 251
87262: STR
87263: PUSH
87264: LD_STRING , 
87266: STR
87267: PUSH
87268: LD_VAR 0 3
87272: PPUSH
87273: CALL_OW 254
87277: STR
87278: PUSH
87279: LD_STRING , 
87281: STR
87282: PUSH
87283: LD_VAR 0 3
87287: PPUSH
87288: LD_INT 1
87290: PPUSH
87291: CALL_OW 268
87295: STR
87296: PUSH
87297: LD_STRING , 
87299: STR
87300: PUSH
87301: LD_VAR 0 3
87305: PPUSH
87306: LD_INT 2
87308: PPUSH
87309: CALL_OW 268
87313: STR
87314: PUSH
87315: LD_STRING ],
87317: STR
87318: PPUSH
87319: CALL_OW 561
// end ;
87323: GO 87217
87325: POP
87326: POP
// AddToLog ( ]; ) ;
87327: LD_STRING ];
87329: PPUSH
87330: CALL_OW 561
// end ;
87334: LD_VAR 0 2
87338: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
87339: LD_INT 0
87341: PPUSH
87342: PPUSH
87343: PPUSH
87344: PPUSH
87345: PPUSH
// if not area or not rate or not max then
87346: LD_VAR 0 1
87350: NOT
87351: PUSH
87352: LD_VAR 0 2
87356: NOT
87357: OR
87358: PUSH
87359: LD_VAR 0 4
87363: NOT
87364: OR
87365: IFFALSE 87369
// exit ;
87367: GO 87561
// while 1 do
87369: LD_INT 1
87371: IFFALSE 87561
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
87373: LD_ADDR_VAR 0 9
87377: PUSH
87378: LD_VAR 0 1
87382: PPUSH
87383: LD_INT 1
87385: PPUSH
87386: CALL_OW 287
87390: PUSH
87391: LD_INT 10
87393: MUL
87394: ST_TO_ADDR
// r := rate / 10 ;
87395: LD_ADDR_VAR 0 7
87399: PUSH
87400: LD_VAR 0 2
87404: PUSH
87405: LD_INT 10
87407: DIVREAL
87408: ST_TO_ADDR
// time := 1 1$00 ;
87409: LD_ADDR_VAR 0 8
87413: PUSH
87414: LD_INT 2100
87416: ST_TO_ADDR
// if amount < min then
87417: LD_VAR 0 9
87421: PUSH
87422: LD_VAR 0 3
87426: LESS
87427: IFFALSE 87445
// r := r * 2 else
87429: LD_ADDR_VAR 0 7
87433: PUSH
87434: LD_VAR 0 7
87438: PUSH
87439: LD_INT 2
87441: MUL
87442: ST_TO_ADDR
87443: GO 87471
// if amount > max then
87445: LD_VAR 0 9
87449: PUSH
87450: LD_VAR 0 4
87454: GREATER
87455: IFFALSE 87471
// r := r / 2 ;
87457: LD_ADDR_VAR 0 7
87461: PUSH
87462: LD_VAR 0 7
87466: PUSH
87467: LD_INT 2
87469: DIVREAL
87470: ST_TO_ADDR
// time := time / r ;
87471: LD_ADDR_VAR 0 8
87475: PUSH
87476: LD_VAR 0 8
87480: PUSH
87481: LD_VAR 0 7
87485: DIVREAL
87486: ST_TO_ADDR
// if time < 0 then
87487: LD_VAR 0 8
87491: PUSH
87492: LD_INT 0
87494: LESS
87495: IFFALSE 87512
// time := time * - 1 ;
87497: LD_ADDR_VAR 0 8
87501: PUSH
87502: LD_VAR 0 8
87506: PUSH
87507: LD_INT 1
87509: NEG
87510: MUL
87511: ST_TO_ADDR
// wait ( time ) ;
87512: LD_VAR 0 8
87516: PPUSH
87517: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
87521: LD_INT 35
87523: PPUSH
87524: LD_INT 875
87526: PPUSH
87527: CALL_OW 12
87531: PPUSH
87532: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
87536: LD_INT 1
87538: PPUSH
87539: LD_INT 5
87541: PPUSH
87542: CALL_OW 12
87546: PPUSH
87547: LD_VAR 0 1
87551: PPUSH
87552: LD_INT 1
87554: PPUSH
87555: CALL_OW 55
// end ;
87559: GO 87369
// end ;
87561: LD_VAR 0 5
87565: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
87566: LD_INT 0
87568: PPUSH
87569: PPUSH
87570: PPUSH
87571: PPUSH
87572: PPUSH
87573: PPUSH
87574: PPUSH
87575: PPUSH
// if not turrets or not factories then
87576: LD_VAR 0 1
87580: NOT
87581: PUSH
87582: LD_VAR 0 2
87586: NOT
87587: OR
87588: IFFALSE 87592
// exit ;
87590: GO 87899
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
87592: LD_ADDR_VAR 0 10
87596: PUSH
87597: LD_INT 5
87599: PUSH
87600: LD_INT 6
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 2
87609: PUSH
87610: LD_INT 4
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 3
87619: PUSH
87620: LD_INT 5
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 24
87634: PUSH
87635: LD_INT 25
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 23
87644: PUSH
87645: LD_INT 27
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 42
87658: PUSH
87659: LD_INT 43
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 44
87668: PUSH
87669: LD_INT 46
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: PUSH
87676: LD_INT 45
87678: PUSH
87679: LD_INT 47
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PUSH
87686: EMPTY
87687: LIST
87688: LIST
87689: LIST
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: LIST
87695: ST_TO_ADDR
// result := [ ] ;
87696: LD_ADDR_VAR 0 3
87700: PUSH
87701: EMPTY
87702: ST_TO_ADDR
// for i in turrets do
87703: LD_ADDR_VAR 0 4
87707: PUSH
87708: LD_VAR 0 1
87712: PUSH
87713: FOR_IN
87714: IFFALSE 87897
// begin nat := GetNation ( i ) ;
87716: LD_ADDR_VAR 0 7
87720: PUSH
87721: LD_VAR 0 4
87725: PPUSH
87726: CALL_OW 248
87730: ST_TO_ADDR
// weapon := 0 ;
87731: LD_ADDR_VAR 0 8
87735: PUSH
87736: LD_INT 0
87738: ST_TO_ADDR
// if not nat then
87739: LD_VAR 0 7
87743: NOT
87744: IFFALSE 87748
// continue ;
87746: GO 87713
// for j in list [ nat ] do
87748: LD_ADDR_VAR 0 5
87752: PUSH
87753: LD_VAR 0 10
87757: PUSH
87758: LD_VAR 0 7
87762: ARRAY
87763: PUSH
87764: FOR_IN
87765: IFFALSE 87806
// if GetBWeapon ( i ) = j [ 1 ] then
87767: LD_VAR 0 4
87771: PPUSH
87772: CALL_OW 269
87776: PUSH
87777: LD_VAR 0 5
87781: PUSH
87782: LD_INT 1
87784: ARRAY
87785: EQUAL
87786: IFFALSE 87804
// begin weapon := j [ 2 ] ;
87788: LD_ADDR_VAR 0 8
87792: PUSH
87793: LD_VAR 0 5
87797: PUSH
87798: LD_INT 2
87800: ARRAY
87801: ST_TO_ADDR
// break ;
87802: GO 87806
// end ;
87804: GO 87764
87806: POP
87807: POP
// if not weapon then
87808: LD_VAR 0 8
87812: NOT
87813: IFFALSE 87817
// continue ;
87815: GO 87713
// for k in factories do
87817: LD_ADDR_VAR 0 6
87821: PUSH
87822: LD_VAR 0 2
87826: PUSH
87827: FOR_IN
87828: IFFALSE 87893
// begin weapons := AvailableWeaponList ( k ) ;
87830: LD_ADDR_VAR 0 9
87834: PUSH
87835: LD_VAR 0 6
87839: PPUSH
87840: CALL_OW 478
87844: ST_TO_ADDR
// if not weapons then
87845: LD_VAR 0 9
87849: NOT
87850: IFFALSE 87854
// continue ;
87852: GO 87827
// if weapon in weapons then
87854: LD_VAR 0 8
87858: PUSH
87859: LD_VAR 0 9
87863: IN
87864: IFFALSE 87891
// begin result := [ i , weapon ] ;
87866: LD_ADDR_VAR 0 3
87870: PUSH
87871: LD_VAR 0 4
87875: PUSH
87876: LD_VAR 0 8
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: ST_TO_ADDR
// exit ;
87885: POP
87886: POP
87887: POP
87888: POP
87889: GO 87899
// end ; end ;
87891: GO 87827
87893: POP
87894: POP
// end ;
87895: GO 87713
87897: POP
87898: POP
// end ;
87899: LD_VAR 0 3
87903: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
87904: LD_INT 0
87906: PPUSH
// if not side or side > 8 then
87907: LD_VAR 0 3
87911: NOT
87912: PUSH
87913: LD_VAR 0 3
87917: PUSH
87918: LD_INT 8
87920: GREATER
87921: OR
87922: IFFALSE 87926
// exit ;
87924: GO 87985
// if not range then
87926: LD_VAR 0 4
87930: NOT
87931: IFFALSE 87942
// range := - 12 ;
87933: LD_ADDR_VAR 0 4
87937: PUSH
87938: LD_INT 12
87940: NEG
87941: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
87942: LD_VAR 0 1
87946: PPUSH
87947: LD_VAR 0 2
87951: PPUSH
87952: LD_VAR 0 3
87956: PPUSH
87957: LD_VAR 0 4
87961: PPUSH
87962: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
87966: LD_VAR 0 1
87970: PPUSH
87971: LD_VAR 0 2
87975: PPUSH
87976: LD_VAR 0 3
87980: PPUSH
87981: CALL_OW 331
// end ;
87985: LD_VAR 0 5
87989: RET
// export function Video ( mode ) ; begin
87990: LD_INT 0
87992: PPUSH
// ingame_video = mode ;
87993: LD_ADDR_OWVAR 52
87997: PUSH
87998: LD_VAR 0 1
88002: ST_TO_ADDR
// interface_hidden = mode ;
88003: LD_ADDR_OWVAR 54
88007: PUSH
88008: LD_VAR 0 1
88012: ST_TO_ADDR
// end ;
88013: LD_VAR 0 2
88017: RET
// export function Join ( array , element ) ; begin
88018: LD_INT 0
88020: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88021: LD_ADDR_VAR 0 3
88025: PUSH
88026: LD_VAR 0 1
88030: PPUSH
88031: LD_VAR 0 1
88035: PUSH
88036: LD_INT 1
88038: PLUS
88039: PPUSH
88040: LD_VAR 0 2
88044: PPUSH
88045: CALL_OW 1
88049: ST_TO_ADDR
// end ;
88050: LD_VAR 0 3
88054: RET
// export function JoinUnion ( array , element ) ; begin
88055: LD_INT 0
88057: PPUSH
// result := array union element ;
88058: LD_ADDR_VAR 0 3
88062: PUSH
88063: LD_VAR 0 1
88067: PUSH
88068: LD_VAR 0 2
88072: UNION
88073: ST_TO_ADDR
// end ;
88074: LD_VAR 0 3
88078: RET
// export function GetBehemoths ( side ) ; begin
88079: LD_INT 0
88081: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88082: LD_ADDR_VAR 0 2
88086: PUSH
88087: LD_INT 22
88089: PUSH
88090: LD_VAR 0 1
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 31
88101: PUSH
88102: LD_INT 25
88104: PUSH
88105: EMPTY
88106: LIST
88107: LIST
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PPUSH
88113: CALL_OW 69
88117: ST_TO_ADDR
// end ;
88118: LD_VAR 0 2
88122: RET
// export function Shuffle ( array ) ; var i , index ; begin
88123: LD_INT 0
88125: PPUSH
88126: PPUSH
88127: PPUSH
// result := [ ] ;
88128: LD_ADDR_VAR 0 2
88132: PUSH
88133: EMPTY
88134: ST_TO_ADDR
// if not array then
88135: LD_VAR 0 1
88139: NOT
88140: IFFALSE 88144
// exit ;
88142: GO 88243
// Randomize ;
88144: CALL_OW 10
// for i = array downto 1 do
88148: LD_ADDR_VAR 0 3
88152: PUSH
88153: DOUBLE
88154: LD_VAR 0 1
88158: INC
88159: ST_TO_ADDR
88160: LD_INT 1
88162: PUSH
88163: FOR_DOWNTO
88164: IFFALSE 88241
// begin index := rand ( 1 , array ) ;
88166: LD_ADDR_VAR 0 4
88170: PUSH
88171: LD_INT 1
88173: PPUSH
88174: LD_VAR 0 1
88178: PPUSH
88179: CALL_OW 12
88183: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88184: LD_ADDR_VAR 0 2
88188: PUSH
88189: LD_VAR 0 2
88193: PPUSH
88194: LD_VAR 0 2
88198: PUSH
88199: LD_INT 1
88201: PLUS
88202: PPUSH
88203: LD_VAR 0 1
88207: PUSH
88208: LD_VAR 0 4
88212: ARRAY
88213: PPUSH
88214: CALL_OW 2
88218: ST_TO_ADDR
// array := Delete ( array , index ) ;
88219: LD_ADDR_VAR 0 1
88223: PUSH
88224: LD_VAR 0 1
88228: PPUSH
88229: LD_VAR 0 4
88233: PPUSH
88234: CALL_OW 3
88238: ST_TO_ADDR
// end ;
88239: GO 88163
88241: POP
88242: POP
// end ;
88243: LD_VAR 0 2
88247: RET
// export function GetBaseMaterials ( base ) ; begin
88248: LD_INT 0
88250: PPUSH
// result := [ 0 , 0 , 0 ] ;
88251: LD_ADDR_VAR 0 2
88255: PUSH
88256: LD_INT 0
88258: PUSH
88259: LD_INT 0
88261: PUSH
88262: LD_INT 0
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: LIST
88269: ST_TO_ADDR
// if not base then
88270: LD_VAR 0 1
88274: NOT
88275: IFFALSE 88279
// exit ;
88277: GO 88328
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88279: LD_ADDR_VAR 0 2
88283: PUSH
88284: LD_VAR 0 1
88288: PPUSH
88289: LD_INT 1
88291: PPUSH
88292: CALL_OW 275
88296: PUSH
88297: LD_VAR 0 1
88301: PPUSH
88302: LD_INT 2
88304: PPUSH
88305: CALL_OW 275
88309: PUSH
88310: LD_VAR 0 1
88314: PPUSH
88315: LD_INT 3
88317: PPUSH
88318: CALL_OW 275
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: LIST
88327: ST_TO_ADDR
// end ;
88328: LD_VAR 0 2
88332: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
88333: LD_INT 0
88335: PPUSH
88336: PPUSH
// result := array ;
88337: LD_ADDR_VAR 0 3
88341: PUSH
88342: LD_VAR 0 1
88346: ST_TO_ADDR
// if size > 0 then
88347: LD_VAR 0 2
88351: PUSH
88352: LD_INT 0
88354: GREATER
88355: IFFALSE 88401
// for i := array downto size do
88357: LD_ADDR_VAR 0 4
88361: PUSH
88362: DOUBLE
88363: LD_VAR 0 1
88367: INC
88368: ST_TO_ADDR
88369: LD_VAR 0 2
88373: PUSH
88374: FOR_DOWNTO
88375: IFFALSE 88399
// result := Delete ( result , result ) ;
88377: LD_ADDR_VAR 0 3
88381: PUSH
88382: LD_VAR 0 3
88386: PPUSH
88387: LD_VAR 0 3
88391: PPUSH
88392: CALL_OW 3
88396: ST_TO_ADDR
88397: GO 88374
88399: POP
88400: POP
// end ;
88401: LD_VAR 0 3
88405: RET
// export function ComExit ( unit ) ; var tmp ; begin
88406: LD_INT 0
88408: PPUSH
88409: PPUSH
// if not IsInUnit ( unit ) then
88410: LD_VAR 0 1
88414: PPUSH
88415: CALL_OW 310
88419: NOT
88420: IFFALSE 88424
// exit ;
88422: GO 88484
// tmp := IsInUnit ( unit ) ;
88424: LD_ADDR_VAR 0 3
88428: PUSH
88429: LD_VAR 0 1
88433: PPUSH
88434: CALL_OW 310
88438: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
88439: LD_VAR 0 3
88443: PPUSH
88444: CALL_OW 247
88448: PUSH
88449: LD_INT 2
88451: EQUAL
88452: IFFALSE 88465
// ComExitVehicle ( unit ) else
88454: LD_VAR 0 1
88458: PPUSH
88459: CALL_OW 121
88463: GO 88474
// ComExitBuilding ( unit ) ;
88465: LD_VAR 0 1
88469: PPUSH
88470: CALL_OW 122
// result := tmp ;
88474: LD_ADDR_VAR 0 2
88478: PUSH
88479: LD_VAR 0 3
88483: ST_TO_ADDR
// end ;
88484: LD_VAR 0 2
88488: RET
// export function ComExitAll ( units ) ; var i ; begin
88489: LD_INT 0
88491: PPUSH
88492: PPUSH
// if not units then
88493: LD_VAR 0 1
88497: NOT
88498: IFFALSE 88502
// exit ;
88500: GO 88528
// for i in units do
88502: LD_ADDR_VAR 0 3
88506: PUSH
88507: LD_VAR 0 1
88511: PUSH
88512: FOR_IN
88513: IFFALSE 88526
// ComExit ( i ) ;
88515: LD_VAR 0 3
88519: PPUSH
88520: CALL 88406 0 1
88524: GO 88512
88526: POP
88527: POP
// end ;
88528: LD_VAR 0 2
88532: RET
// export function ResetHc ; begin
88533: LD_INT 0
88535: PPUSH
// InitHc ;
88536: CALL_OW 19
// hc_importance := 0 ;
88540: LD_ADDR_OWVAR 32
88544: PUSH
88545: LD_INT 0
88547: ST_TO_ADDR
// end ;
88548: LD_VAR 0 1
88552: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
88553: LD_INT 0
88555: PPUSH
88556: PPUSH
88557: PPUSH
// _x := ( x1 + x2 ) div 2 ;
88558: LD_ADDR_VAR 0 6
88562: PUSH
88563: LD_VAR 0 1
88567: PUSH
88568: LD_VAR 0 3
88572: PLUS
88573: PUSH
88574: LD_INT 2
88576: DIV
88577: ST_TO_ADDR
// if _x < 0 then
88578: LD_VAR 0 6
88582: PUSH
88583: LD_INT 0
88585: LESS
88586: IFFALSE 88603
// _x := _x * - 1 ;
88588: LD_ADDR_VAR 0 6
88592: PUSH
88593: LD_VAR 0 6
88597: PUSH
88598: LD_INT 1
88600: NEG
88601: MUL
88602: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
88603: LD_ADDR_VAR 0 7
88607: PUSH
88608: LD_VAR 0 2
88612: PUSH
88613: LD_VAR 0 4
88617: PLUS
88618: PUSH
88619: LD_INT 2
88621: DIV
88622: ST_TO_ADDR
// if _y < 0 then
88623: LD_VAR 0 7
88627: PUSH
88628: LD_INT 0
88630: LESS
88631: IFFALSE 88648
// _y := _y * - 1 ;
88633: LD_ADDR_VAR 0 7
88637: PUSH
88638: LD_VAR 0 7
88642: PUSH
88643: LD_INT 1
88645: NEG
88646: MUL
88647: ST_TO_ADDR
// result := [ _x , _y ] ;
88648: LD_ADDR_VAR 0 5
88652: PUSH
88653: LD_VAR 0 6
88657: PUSH
88658: LD_VAR 0 7
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: ST_TO_ADDR
// end ;
88667: LD_VAR 0 5
88671: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
88672: LD_INT 0
88674: PPUSH
88675: PPUSH
88676: PPUSH
88677: PPUSH
// task := GetTaskList ( unit ) ;
88678: LD_ADDR_VAR 0 7
88682: PUSH
88683: LD_VAR 0 1
88687: PPUSH
88688: CALL_OW 437
88692: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
88693: LD_VAR 0 7
88697: NOT
88698: PUSH
88699: LD_VAR 0 1
88703: PPUSH
88704: LD_VAR 0 2
88708: PPUSH
88709: CALL_OW 308
88713: NOT
88714: AND
88715: IFFALSE 88719
// exit ;
88717: GO 88837
// if IsInArea ( unit , area ) then
88719: LD_VAR 0 1
88723: PPUSH
88724: LD_VAR 0 2
88728: PPUSH
88729: CALL_OW 308
88733: IFFALSE 88751
// begin ComMoveToArea ( unit , goAway ) ;
88735: LD_VAR 0 1
88739: PPUSH
88740: LD_VAR 0 3
88744: PPUSH
88745: CALL_OW 113
// exit ;
88749: GO 88837
// end ; if task [ 1 ] [ 1 ] <> M then
88751: LD_VAR 0 7
88755: PUSH
88756: LD_INT 1
88758: ARRAY
88759: PUSH
88760: LD_INT 1
88762: ARRAY
88763: PUSH
88764: LD_STRING M
88766: NONEQUAL
88767: IFFALSE 88771
// exit ;
88769: GO 88837
// x := task [ 1 ] [ 2 ] ;
88771: LD_ADDR_VAR 0 5
88775: PUSH
88776: LD_VAR 0 7
88780: PUSH
88781: LD_INT 1
88783: ARRAY
88784: PUSH
88785: LD_INT 2
88787: ARRAY
88788: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
88789: LD_ADDR_VAR 0 6
88793: PUSH
88794: LD_VAR 0 7
88798: PUSH
88799: LD_INT 1
88801: ARRAY
88802: PUSH
88803: LD_INT 3
88805: ARRAY
88806: ST_TO_ADDR
// if InArea ( x , y , area ) then
88807: LD_VAR 0 5
88811: PPUSH
88812: LD_VAR 0 6
88816: PPUSH
88817: LD_VAR 0 2
88821: PPUSH
88822: CALL_OW 309
88826: IFFALSE 88837
// ComStop ( unit ) ;
88828: LD_VAR 0 1
88832: PPUSH
88833: CALL_OW 141
// end ;
88837: LD_VAR 0 4
88841: RET
// export function Abs ( value ) ; begin
88842: LD_INT 0
88844: PPUSH
// result := value ;
88845: LD_ADDR_VAR 0 2
88849: PUSH
88850: LD_VAR 0 1
88854: ST_TO_ADDR
// if value < 0 then
88855: LD_VAR 0 1
88859: PUSH
88860: LD_INT 0
88862: LESS
88863: IFFALSE 88880
// result := value * - 1 ;
88865: LD_ADDR_VAR 0 2
88869: PUSH
88870: LD_VAR 0 1
88874: PUSH
88875: LD_INT 1
88877: NEG
88878: MUL
88879: ST_TO_ADDR
// end ;
88880: LD_VAR 0 2
88884: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
88885: LD_INT 0
88887: PPUSH
88888: PPUSH
88889: PPUSH
88890: PPUSH
88891: PPUSH
88892: PPUSH
88893: PPUSH
88894: PPUSH
// if not unit or not building then
88895: LD_VAR 0 1
88899: NOT
88900: PUSH
88901: LD_VAR 0 2
88905: NOT
88906: OR
88907: IFFALSE 88911
// exit ;
88909: GO 89137
// x := GetX ( building ) ;
88911: LD_ADDR_VAR 0 4
88915: PUSH
88916: LD_VAR 0 2
88920: PPUSH
88921: CALL_OW 250
88925: ST_TO_ADDR
// y := GetY ( building ) ;
88926: LD_ADDR_VAR 0 6
88930: PUSH
88931: LD_VAR 0 2
88935: PPUSH
88936: CALL_OW 251
88940: ST_TO_ADDR
// d := GetDir ( building ) ;
88941: LD_ADDR_VAR 0 8
88945: PUSH
88946: LD_VAR 0 2
88950: PPUSH
88951: CALL_OW 254
88955: ST_TO_ADDR
// r := 4 ;
88956: LD_ADDR_VAR 0 9
88960: PUSH
88961: LD_INT 4
88963: ST_TO_ADDR
// for i := 1 to 5 do
88964: LD_ADDR_VAR 0 10
88968: PUSH
88969: DOUBLE
88970: LD_INT 1
88972: DEC
88973: ST_TO_ADDR
88974: LD_INT 5
88976: PUSH
88977: FOR_TO
88978: IFFALSE 89135
// begin _x := ShiftX ( x , d , r + i ) ;
88980: LD_ADDR_VAR 0 5
88984: PUSH
88985: LD_VAR 0 4
88989: PPUSH
88990: LD_VAR 0 8
88994: PPUSH
88995: LD_VAR 0 9
88999: PUSH
89000: LD_VAR 0 10
89004: PLUS
89005: PPUSH
89006: CALL_OW 272
89010: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89011: LD_ADDR_VAR 0 7
89015: PUSH
89016: LD_VAR 0 6
89020: PPUSH
89021: LD_VAR 0 8
89025: PPUSH
89026: LD_VAR 0 9
89030: PUSH
89031: LD_VAR 0 10
89035: PLUS
89036: PPUSH
89037: CALL_OW 273
89041: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89042: LD_VAR 0 5
89046: PPUSH
89047: LD_VAR 0 7
89051: PPUSH
89052: CALL_OW 488
89056: PUSH
89057: LD_VAR 0 5
89061: PPUSH
89062: LD_VAR 0 7
89066: PPUSH
89067: CALL_OW 428
89071: PPUSH
89072: CALL_OW 247
89076: PUSH
89077: LD_INT 3
89079: PUSH
89080: LD_INT 2
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: IN
89087: NOT
89088: AND
89089: IFFALSE 89133
// begin ComMoveXY ( unit , _x , _y ) ;
89091: LD_VAR 0 1
89095: PPUSH
89096: LD_VAR 0 5
89100: PPUSH
89101: LD_VAR 0 7
89105: PPUSH
89106: CALL_OW 111
// result := [ _x , _y ] ;
89110: LD_ADDR_VAR 0 3
89114: PUSH
89115: LD_VAR 0 5
89119: PUSH
89120: LD_VAR 0 7
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: ST_TO_ADDR
// exit ;
89129: POP
89130: POP
89131: GO 89137
// end ; end ;
89133: GO 88977
89135: POP
89136: POP
// end ;
89137: LD_VAR 0 3
89141: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89142: LD_INT 0
89144: PPUSH
89145: PPUSH
89146: PPUSH
// result := 0 ;
89147: LD_ADDR_VAR 0 3
89151: PUSH
89152: LD_INT 0
89154: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89155: LD_VAR 0 1
89159: PUSH
89160: LD_INT 0
89162: LESS
89163: PUSH
89164: LD_VAR 0 1
89168: PUSH
89169: LD_INT 8
89171: GREATER
89172: OR
89173: PUSH
89174: LD_VAR 0 2
89178: PUSH
89179: LD_INT 0
89181: LESS
89182: OR
89183: PUSH
89184: LD_VAR 0 2
89188: PUSH
89189: LD_INT 8
89191: GREATER
89192: OR
89193: IFFALSE 89197
// exit ;
89195: GO 89272
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89197: LD_ADDR_VAR 0 4
89201: PUSH
89202: LD_INT 22
89204: PUSH
89205: LD_VAR 0 2
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PPUSH
89214: CALL_OW 69
89218: PUSH
89219: FOR_IN
89220: IFFALSE 89270
// begin un := UnitShoot ( i ) ;
89222: LD_ADDR_VAR 0 5
89226: PUSH
89227: LD_VAR 0 4
89231: PPUSH
89232: CALL_OW 504
89236: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89237: LD_VAR 0 5
89241: PPUSH
89242: CALL_OW 255
89246: PUSH
89247: LD_VAR 0 1
89251: EQUAL
89252: IFFALSE 89268
// begin result := un ;
89254: LD_ADDR_VAR 0 3
89258: PUSH
89259: LD_VAR 0 5
89263: ST_TO_ADDR
// exit ;
89264: POP
89265: POP
89266: GO 89272
// end ; end ;
89268: GO 89219
89270: POP
89271: POP
// end ;
89272: LD_VAR 0 3
89276: RET
// export function GetCargoBay ( units ) ; begin
89277: LD_INT 0
89279: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89280: LD_ADDR_VAR 0 2
89284: PUSH
89285: LD_VAR 0 1
89289: PPUSH
89290: LD_INT 2
89292: PUSH
89293: LD_INT 34
89295: PUSH
89296: LD_INT 12
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 34
89305: PUSH
89306: LD_INT 51
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: LD_INT 34
89315: PUSH
89316: LD_INT 32
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 34
89325: PUSH
89326: LD_EXP 73
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: EMPTY
89336: LIST
89337: LIST
89338: LIST
89339: LIST
89340: LIST
89341: PPUSH
89342: CALL_OW 72
89346: ST_TO_ADDR
// end ;
89347: LD_VAR 0 2
89351: RET
// export function Negate ( value ) ; begin
89352: LD_INT 0
89354: PPUSH
// result := not value ;
89355: LD_ADDR_VAR 0 2
89359: PUSH
89360: LD_VAR 0 1
89364: NOT
89365: ST_TO_ADDR
// end ;
89366: LD_VAR 0 2
89370: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
89371: LD_INT 0
89373: PPUSH
// if x1 = x2 then
89374: LD_VAR 0 1
89378: PUSH
89379: LD_VAR 0 3
89383: EQUAL
89384: IFFALSE 89418
// begin if y1 > y2 then
89386: LD_VAR 0 2
89390: PUSH
89391: LD_VAR 0 4
89395: GREATER
89396: IFFALSE 89408
// result := 0 else
89398: LD_ADDR_VAR 0 5
89402: PUSH
89403: LD_INT 0
89405: ST_TO_ADDR
89406: GO 89416
// result := 3 ;
89408: LD_ADDR_VAR 0 5
89412: PUSH
89413: LD_INT 3
89415: ST_TO_ADDR
// exit ;
89416: GO 89504
// end ; if y1 = y2 then
89418: LD_VAR 0 2
89422: PUSH
89423: LD_VAR 0 4
89427: EQUAL
89428: IFFALSE 89462
// begin if x1 > x2 then
89430: LD_VAR 0 1
89434: PUSH
89435: LD_VAR 0 3
89439: GREATER
89440: IFFALSE 89452
// result := 1 else
89442: LD_ADDR_VAR 0 5
89446: PUSH
89447: LD_INT 1
89449: ST_TO_ADDR
89450: GO 89460
// result := 4 ;
89452: LD_ADDR_VAR 0 5
89456: PUSH
89457: LD_INT 4
89459: ST_TO_ADDR
// exit ;
89460: GO 89504
// end ; if x1 > x2 and y1 > y2 then
89462: LD_VAR 0 1
89466: PUSH
89467: LD_VAR 0 3
89471: GREATER
89472: PUSH
89473: LD_VAR 0 2
89477: PUSH
89478: LD_VAR 0 4
89482: GREATER
89483: AND
89484: IFFALSE 89496
// result := 2 else
89486: LD_ADDR_VAR 0 5
89490: PUSH
89491: LD_INT 2
89493: ST_TO_ADDR
89494: GO 89504
// result := 5 ;
89496: LD_ADDR_VAR 0 5
89500: PUSH
89501: LD_INT 5
89503: ST_TO_ADDR
// end ;
89504: LD_VAR 0 5
89508: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89509: LD_INT 0
89511: PPUSH
89512: PPUSH
// if not driver or not IsInUnit ( driver ) then
89513: LD_VAR 0 1
89517: NOT
89518: PUSH
89519: LD_VAR 0 1
89523: PPUSH
89524: CALL_OW 310
89528: NOT
89529: OR
89530: IFFALSE 89534
// exit ;
89532: GO 89624
// vehicle := IsInUnit ( driver ) ;
89534: LD_ADDR_VAR 0 3
89538: PUSH
89539: LD_VAR 0 1
89543: PPUSH
89544: CALL_OW 310
89548: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89549: LD_VAR 0 1
89553: PPUSH
89554: LD_STRING \
89556: PUSH
89557: LD_INT 0
89559: PUSH
89560: LD_INT 0
89562: PUSH
89563: LD_INT 0
89565: PUSH
89566: LD_INT 0
89568: PUSH
89569: LD_INT 0
89571: PUSH
89572: LD_INT 0
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: PUSH
89584: LD_STRING E
89586: PUSH
89587: LD_INT 0
89589: PUSH
89590: LD_INT 0
89592: PUSH
89593: LD_VAR 0 3
89597: PUSH
89598: LD_INT 0
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: LD_INT 0
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: PPUSH
89620: CALL_OW 446
// end ;
89624: LD_VAR 0 2
89628: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
89629: LD_INT 0
89631: PPUSH
89632: PPUSH
// if not driver or not IsInUnit ( driver ) then
89633: LD_VAR 0 1
89637: NOT
89638: PUSH
89639: LD_VAR 0 1
89643: PPUSH
89644: CALL_OW 310
89648: NOT
89649: OR
89650: IFFALSE 89654
// exit ;
89652: GO 89744
// vehicle := IsInUnit ( driver ) ;
89654: LD_ADDR_VAR 0 3
89658: PUSH
89659: LD_VAR 0 1
89663: PPUSH
89664: CALL_OW 310
89668: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
89669: LD_VAR 0 1
89673: PPUSH
89674: LD_STRING \
89676: PUSH
89677: LD_INT 0
89679: PUSH
89680: LD_INT 0
89682: PUSH
89683: LD_INT 0
89685: PUSH
89686: LD_INT 0
89688: PUSH
89689: LD_INT 0
89691: PUSH
89692: LD_INT 0
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: PUSH
89704: LD_STRING E
89706: PUSH
89707: LD_INT 0
89709: PUSH
89710: LD_INT 0
89712: PUSH
89713: LD_VAR 0 3
89717: PUSH
89718: LD_INT 0
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: LD_INT 0
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PPUSH
89740: CALL_OW 447
// end ;
89744: LD_VAR 0 2
89748: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
89749: LD_INT 0
89751: PPUSH
89752: PPUSH
89753: PPUSH
// tmp := [ ] ;
89754: LD_ADDR_VAR 0 5
89758: PUSH
89759: EMPTY
89760: ST_TO_ADDR
// for i in units do
89761: LD_ADDR_VAR 0 4
89765: PUSH
89766: LD_VAR 0 1
89770: PUSH
89771: FOR_IN
89772: IFFALSE 89810
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
89774: LD_ADDR_VAR 0 5
89778: PUSH
89779: LD_VAR 0 5
89783: PPUSH
89784: LD_VAR 0 5
89788: PUSH
89789: LD_INT 1
89791: PLUS
89792: PPUSH
89793: LD_VAR 0 4
89797: PPUSH
89798: CALL_OW 256
89802: PPUSH
89803: CALL_OW 2
89807: ST_TO_ADDR
89808: GO 89771
89810: POP
89811: POP
// if not tmp then
89812: LD_VAR 0 5
89816: NOT
89817: IFFALSE 89821
// exit ;
89819: GO 89869
// if asc then
89821: LD_VAR 0 2
89825: IFFALSE 89849
// result := SortListByListAsc ( units , tmp ) else
89827: LD_ADDR_VAR 0 3
89831: PUSH
89832: LD_VAR 0 1
89836: PPUSH
89837: LD_VAR 0 5
89841: PPUSH
89842: CALL_OW 76
89846: ST_TO_ADDR
89847: GO 89869
// result := SortListByListDesc ( units , tmp ) ;
89849: LD_ADDR_VAR 0 3
89853: PUSH
89854: LD_VAR 0 1
89858: PPUSH
89859: LD_VAR 0 5
89863: PPUSH
89864: CALL_OW 77
89868: ST_TO_ADDR
// end ;
89869: LD_VAR 0 3
89873: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
89874: LD_INT 0
89876: PPUSH
89877: PPUSH
// task := GetTaskList ( mech ) ;
89878: LD_ADDR_VAR 0 4
89882: PUSH
89883: LD_VAR 0 1
89887: PPUSH
89888: CALL_OW 437
89892: ST_TO_ADDR
// if not task then
89893: LD_VAR 0 4
89897: NOT
89898: IFFALSE 89902
// exit ;
89900: GO 89944
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
89902: LD_ADDR_VAR 0 3
89906: PUSH
89907: LD_VAR 0 4
89911: PUSH
89912: LD_INT 1
89914: ARRAY
89915: PUSH
89916: LD_INT 1
89918: ARRAY
89919: PUSH
89920: LD_STRING r
89922: EQUAL
89923: PUSH
89924: LD_VAR 0 4
89928: PUSH
89929: LD_INT 1
89931: ARRAY
89932: PUSH
89933: LD_INT 4
89935: ARRAY
89936: PUSH
89937: LD_VAR 0 2
89941: EQUAL
89942: AND
89943: ST_TO_ADDR
// end ;
89944: LD_VAR 0 3
89948: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
89949: LD_INT 0
89951: PPUSH
// SetDir ( unit , d ) ;
89952: LD_VAR 0 1
89956: PPUSH
89957: LD_VAR 0 4
89961: PPUSH
89962: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
89966: LD_VAR 0 1
89970: PPUSH
89971: LD_VAR 0 2
89975: PPUSH
89976: LD_VAR 0 3
89980: PPUSH
89981: LD_VAR 0 5
89985: PPUSH
89986: CALL_OW 48
// end ;
89990: LD_VAR 0 6
89994: RET
// export function ToNaturalNumber ( number ) ; begin
89995: LD_INT 0
89997: PPUSH
// result := number div 1 ;
89998: LD_ADDR_VAR 0 2
90002: PUSH
90003: LD_VAR 0 1
90007: PUSH
90008: LD_INT 1
90010: DIV
90011: ST_TO_ADDR
// if number < 0 then
90012: LD_VAR 0 1
90016: PUSH
90017: LD_INT 0
90019: LESS
90020: IFFALSE 90030
// result := 0 ;
90022: LD_ADDR_VAR 0 2
90026: PUSH
90027: LD_INT 0
90029: ST_TO_ADDR
// end ;
90030: LD_VAR 0 2
90034: RET
// export function SortByClass ( units , class ) ; var un ; begin
90035: LD_INT 0
90037: PPUSH
90038: PPUSH
// if not units or not class then
90039: LD_VAR 0 1
90043: NOT
90044: PUSH
90045: LD_VAR 0 2
90049: NOT
90050: OR
90051: IFFALSE 90055
// exit ;
90053: GO 90150
// result := [ ] ;
90055: LD_ADDR_VAR 0 3
90059: PUSH
90060: EMPTY
90061: ST_TO_ADDR
// for un in units do
90062: LD_ADDR_VAR 0 4
90066: PUSH
90067: LD_VAR 0 1
90071: PUSH
90072: FOR_IN
90073: IFFALSE 90148
// if GetClass ( un ) = class then
90075: LD_VAR 0 4
90079: PPUSH
90080: CALL_OW 257
90084: PUSH
90085: LD_VAR 0 2
90089: EQUAL
90090: IFFALSE 90117
// result := Insert ( result , 1 , un ) else
90092: LD_ADDR_VAR 0 3
90096: PUSH
90097: LD_VAR 0 3
90101: PPUSH
90102: LD_INT 1
90104: PPUSH
90105: LD_VAR 0 4
90109: PPUSH
90110: CALL_OW 2
90114: ST_TO_ADDR
90115: GO 90146
// result := Replace ( result , result + 1 , un ) ;
90117: LD_ADDR_VAR 0 3
90121: PUSH
90122: LD_VAR 0 3
90126: PPUSH
90127: LD_VAR 0 3
90131: PUSH
90132: LD_INT 1
90134: PLUS
90135: PPUSH
90136: LD_VAR 0 4
90140: PPUSH
90141: CALL_OW 1
90145: ST_TO_ADDR
90146: GO 90072
90148: POP
90149: POP
// end ; end_of_file end_of_file
90150: LD_VAR 0 3
90154: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90155: LD_INT 0
90157: PPUSH
// if p2 = 100 then
90158: LD_VAR 0 2
90162: PUSH
90163: LD_INT 100
90165: EQUAL
90166: IFFALSE 91115
// begin if not StreamModeActive then
90168: LD_EXP 137
90172: NOT
90173: IFFALSE 90183
// StreamModeActive := true ;
90175: LD_ADDR_EXP 137
90179: PUSH
90180: LD_INT 1
90182: ST_TO_ADDR
// if p3 = 0 then
90183: LD_VAR 0 3
90187: PUSH
90188: LD_INT 0
90190: EQUAL
90191: IFFALSE 90197
// InitStreamMode ;
90193: CALL 91275 0 0
// if p3 = 1 then
90197: LD_VAR 0 3
90201: PUSH
90202: LD_INT 1
90204: EQUAL
90205: IFFALSE 90215
// sRocket := true ;
90207: LD_ADDR_EXP 142
90211: PUSH
90212: LD_INT 1
90214: ST_TO_ADDR
// if p3 = 2 then
90215: LD_VAR 0 3
90219: PUSH
90220: LD_INT 2
90222: EQUAL
90223: IFFALSE 90233
// sSpeed := true ;
90225: LD_ADDR_EXP 141
90229: PUSH
90230: LD_INT 1
90232: ST_TO_ADDR
// if p3 = 3 then
90233: LD_VAR 0 3
90237: PUSH
90238: LD_INT 3
90240: EQUAL
90241: IFFALSE 90251
// sEngine := true ;
90243: LD_ADDR_EXP 143
90247: PUSH
90248: LD_INT 1
90250: ST_TO_ADDR
// if p3 = 4 then
90251: LD_VAR 0 3
90255: PUSH
90256: LD_INT 4
90258: EQUAL
90259: IFFALSE 90269
// sSpec := true ;
90261: LD_ADDR_EXP 140
90265: PUSH
90266: LD_INT 1
90268: ST_TO_ADDR
// if p3 = 5 then
90269: LD_VAR 0 3
90273: PUSH
90274: LD_INT 5
90276: EQUAL
90277: IFFALSE 90287
// sLevel := true ;
90279: LD_ADDR_EXP 144
90283: PUSH
90284: LD_INT 1
90286: ST_TO_ADDR
// if p3 = 6 then
90287: LD_VAR 0 3
90291: PUSH
90292: LD_INT 6
90294: EQUAL
90295: IFFALSE 90305
// sArmoury := true ;
90297: LD_ADDR_EXP 145
90301: PUSH
90302: LD_INT 1
90304: ST_TO_ADDR
// if p3 = 7 then
90305: LD_VAR 0 3
90309: PUSH
90310: LD_INT 7
90312: EQUAL
90313: IFFALSE 90323
// sRadar := true ;
90315: LD_ADDR_EXP 146
90319: PUSH
90320: LD_INT 1
90322: ST_TO_ADDR
// if p3 = 8 then
90323: LD_VAR 0 3
90327: PUSH
90328: LD_INT 8
90330: EQUAL
90331: IFFALSE 90341
// sBunker := true ;
90333: LD_ADDR_EXP 147
90337: PUSH
90338: LD_INT 1
90340: ST_TO_ADDR
// if p3 = 9 then
90341: LD_VAR 0 3
90345: PUSH
90346: LD_INT 9
90348: EQUAL
90349: IFFALSE 90359
// sHack := true ;
90351: LD_ADDR_EXP 148
90355: PUSH
90356: LD_INT 1
90358: ST_TO_ADDR
// if p3 = 10 then
90359: LD_VAR 0 3
90363: PUSH
90364: LD_INT 10
90366: EQUAL
90367: IFFALSE 90377
// sFire := true ;
90369: LD_ADDR_EXP 149
90373: PUSH
90374: LD_INT 1
90376: ST_TO_ADDR
// if p3 = 11 then
90377: LD_VAR 0 3
90381: PUSH
90382: LD_INT 11
90384: EQUAL
90385: IFFALSE 90395
// sRefresh := true ;
90387: LD_ADDR_EXP 150
90391: PUSH
90392: LD_INT 1
90394: ST_TO_ADDR
// if p3 = 12 then
90395: LD_VAR 0 3
90399: PUSH
90400: LD_INT 12
90402: EQUAL
90403: IFFALSE 90413
// sExp := true ;
90405: LD_ADDR_EXP 151
90409: PUSH
90410: LD_INT 1
90412: ST_TO_ADDR
// if p3 = 13 then
90413: LD_VAR 0 3
90417: PUSH
90418: LD_INT 13
90420: EQUAL
90421: IFFALSE 90431
// sDepot := true ;
90423: LD_ADDR_EXP 152
90427: PUSH
90428: LD_INT 1
90430: ST_TO_ADDR
// if p3 = 14 then
90431: LD_VAR 0 3
90435: PUSH
90436: LD_INT 14
90438: EQUAL
90439: IFFALSE 90449
// sFlag := true ;
90441: LD_ADDR_EXP 153
90445: PUSH
90446: LD_INT 1
90448: ST_TO_ADDR
// if p3 = 15 then
90449: LD_VAR 0 3
90453: PUSH
90454: LD_INT 15
90456: EQUAL
90457: IFFALSE 90467
// sKamikadze := true ;
90459: LD_ADDR_EXP 161
90463: PUSH
90464: LD_INT 1
90466: ST_TO_ADDR
// if p3 = 16 then
90467: LD_VAR 0 3
90471: PUSH
90472: LD_INT 16
90474: EQUAL
90475: IFFALSE 90485
// sTroll := true ;
90477: LD_ADDR_EXP 162
90481: PUSH
90482: LD_INT 1
90484: ST_TO_ADDR
// if p3 = 17 then
90485: LD_VAR 0 3
90489: PUSH
90490: LD_INT 17
90492: EQUAL
90493: IFFALSE 90503
// sSlow := true ;
90495: LD_ADDR_EXP 163
90499: PUSH
90500: LD_INT 1
90502: ST_TO_ADDR
// if p3 = 18 then
90503: LD_VAR 0 3
90507: PUSH
90508: LD_INT 18
90510: EQUAL
90511: IFFALSE 90521
// sLack := true ;
90513: LD_ADDR_EXP 164
90517: PUSH
90518: LD_INT 1
90520: ST_TO_ADDR
// if p3 = 19 then
90521: LD_VAR 0 3
90525: PUSH
90526: LD_INT 19
90528: EQUAL
90529: IFFALSE 90539
// sTank := true ;
90531: LD_ADDR_EXP 166
90535: PUSH
90536: LD_INT 1
90538: ST_TO_ADDR
// if p3 = 20 then
90539: LD_VAR 0 3
90543: PUSH
90544: LD_INT 20
90546: EQUAL
90547: IFFALSE 90557
// sRemote := true ;
90549: LD_ADDR_EXP 167
90553: PUSH
90554: LD_INT 1
90556: ST_TO_ADDR
// if p3 = 21 then
90557: LD_VAR 0 3
90561: PUSH
90562: LD_INT 21
90564: EQUAL
90565: IFFALSE 90575
// sPowell := true ;
90567: LD_ADDR_EXP 168
90571: PUSH
90572: LD_INT 1
90574: ST_TO_ADDR
// if p3 = 22 then
90575: LD_VAR 0 3
90579: PUSH
90580: LD_INT 22
90582: EQUAL
90583: IFFALSE 90593
// sTeleport := true ;
90585: LD_ADDR_EXP 171
90589: PUSH
90590: LD_INT 1
90592: ST_TO_ADDR
// if p3 = 23 then
90593: LD_VAR 0 3
90597: PUSH
90598: LD_INT 23
90600: EQUAL
90601: IFFALSE 90611
// sOilTower := true ;
90603: LD_ADDR_EXP 173
90607: PUSH
90608: LD_INT 1
90610: ST_TO_ADDR
// if p3 = 24 then
90611: LD_VAR 0 3
90615: PUSH
90616: LD_INT 24
90618: EQUAL
90619: IFFALSE 90629
// sShovel := true ;
90621: LD_ADDR_EXP 174
90625: PUSH
90626: LD_INT 1
90628: ST_TO_ADDR
// if p3 = 25 then
90629: LD_VAR 0 3
90633: PUSH
90634: LD_INT 25
90636: EQUAL
90637: IFFALSE 90647
// sSheik := true ;
90639: LD_ADDR_EXP 175
90643: PUSH
90644: LD_INT 1
90646: ST_TO_ADDR
// if p3 = 26 then
90647: LD_VAR 0 3
90651: PUSH
90652: LD_INT 26
90654: EQUAL
90655: IFFALSE 90665
// sEarthquake := true ;
90657: LD_ADDR_EXP 177
90661: PUSH
90662: LD_INT 1
90664: ST_TO_ADDR
// if p3 = 27 then
90665: LD_VAR 0 3
90669: PUSH
90670: LD_INT 27
90672: EQUAL
90673: IFFALSE 90683
// sAI := true ;
90675: LD_ADDR_EXP 178
90679: PUSH
90680: LD_INT 1
90682: ST_TO_ADDR
// if p3 = 28 then
90683: LD_VAR 0 3
90687: PUSH
90688: LD_INT 28
90690: EQUAL
90691: IFFALSE 90701
// sCargo := true ;
90693: LD_ADDR_EXP 181
90697: PUSH
90698: LD_INT 1
90700: ST_TO_ADDR
// if p3 = 29 then
90701: LD_VAR 0 3
90705: PUSH
90706: LD_INT 29
90708: EQUAL
90709: IFFALSE 90719
// sDLaser := true ;
90711: LD_ADDR_EXP 182
90715: PUSH
90716: LD_INT 1
90718: ST_TO_ADDR
// if p3 = 30 then
90719: LD_VAR 0 3
90723: PUSH
90724: LD_INT 30
90726: EQUAL
90727: IFFALSE 90737
// sExchange := true ;
90729: LD_ADDR_EXP 183
90733: PUSH
90734: LD_INT 1
90736: ST_TO_ADDR
// if p3 = 31 then
90737: LD_VAR 0 3
90741: PUSH
90742: LD_INT 31
90744: EQUAL
90745: IFFALSE 90755
// sFac := true ;
90747: LD_ADDR_EXP 184
90751: PUSH
90752: LD_INT 1
90754: ST_TO_ADDR
// if p3 = 32 then
90755: LD_VAR 0 3
90759: PUSH
90760: LD_INT 32
90762: EQUAL
90763: IFFALSE 90773
// sPower := true ;
90765: LD_ADDR_EXP 185
90769: PUSH
90770: LD_INT 1
90772: ST_TO_ADDR
// if p3 = 33 then
90773: LD_VAR 0 3
90777: PUSH
90778: LD_INT 33
90780: EQUAL
90781: IFFALSE 90791
// sRandom := true ;
90783: LD_ADDR_EXP 186
90787: PUSH
90788: LD_INT 1
90790: ST_TO_ADDR
// if p3 = 34 then
90791: LD_VAR 0 3
90795: PUSH
90796: LD_INT 34
90798: EQUAL
90799: IFFALSE 90809
// sShield := true ;
90801: LD_ADDR_EXP 187
90805: PUSH
90806: LD_INT 1
90808: ST_TO_ADDR
// if p3 = 35 then
90809: LD_VAR 0 3
90813: PUSH
90814: LD_INT 35
90816: EQUAL
90817: IFFALSE 90827
// sTime := true ;
90819: LD_ADDR_EXP 188
90823: PUSH
90824: LD_INT 1
90826: ST_TO_ADDR
// if p3 = 36 then
90827: LD_VAR 0 3
90831: PUSH
90832: LD_INT 36
90834: EQUAL
90835: IFFALSE 90845
// sTools := true ;
90837: LD_ADDR_EXP 189
90841: PUSH
90842: LD_INT 1
90844: ST_TO_ADDR
// if p3 = 101 then
90845: LD_VAR 0 3
90849: PUSH
90850: LD_INT 101
90852: EQUAL
90853: IFFALSE 90863
// sSold := true ;
90855: LD_ADDR_EXP 154
90859: PUSH
90860: LD_INT 1
90862: ST_TO_ADDR
// if p3 = 102 then
90863: LD_VAR 0 3
90867: PUSH
90868: LD_INT 102
90870: EQUAL
90871: IFFALSE 90881
// sDiff := true ;
90873: LD_ADDR_EXP 155
90877: PUSH
90878: LD_INT 1
90880: ST_TO_ADDR
// if p3 = 103 then
90881: LD_VAR 0 3
90885: PUSH
90886: LD_INT 103
90888: EQUAL
90889: IFFALSE 90899
// sFog := true ;
90891: LD_ADDR_EXP 158
90895: PUSH
90896: LD_INT 1
90898: ST_TO_ADDR
// if p3 = 104 then
90899: LD_VAR 0 3
90903: PUSH
90904: LD_INT 104
90906: EQUAL
90907: IFFALSE 90917
// sReset := true ;
90909: LD_ADDR_EXP 159
90913: PUSH
90914: LD_INT 1
90916: ST_TO_ADDR
// if p3 = 105 then
90917: LD_VAR 0 3
90921: PUSH
90922: LD_INT 105
90924: EQUAL
90925: IFFALSE 90935
// sSun := true ;
90927: LD_ADDR_EXP 160
90931: PUSH
90932: LD_INT 1
90934: ST_TO_ADDR
// if p3 = 106 then
90935: LD_VAR 0 3
90939: PUSH
90940: LD_INT 106
90942: EQUAL
90943: IFFALSE 90953
// sTiger := true ;
90945: LD_ADDR_EXP 156
90949: PUSH
90950: LD_INT 1
90952: ST_TO_ADDR
// if p3 = 107 then
90953: LD_VAR 0 3
90957: PUSH
90958: LD_INT 107
90960: EQUAL
90961: IFFALSE 90971
// sBomb := true ;
90963: LD_ADDR_EXP 157
90967: PUSH
90968: LD_INT 1
90970: ST_TO_ADDR
// if p3 = 108 then
90971: LD_VAR 0 3
90975: PUSH
90976: LD_INT 108
90978: EQUAL
90979: IFFALSE 90989
// sWound := true ;
90981: LD_ADDR_EXP 165
90985: PUSH
90986: LD_INT 1
90988: ST_TO_ADDR
// if p3 = 109 then
90989: LD_VAR 0 3
90993: PUSH
90994: LD_INT 109
90996: EQUAL
90997: IFFALSE 91007
// sBetray := true ;
90999: LD_ADDR_EXP 169
91003: PUSH
91004: LD_INT 1
91006: ST_TO_ADDR
// if p3 = 110 then
91007: LD_VAR 0 3
91011: PUSH
91012: LD_INT 110
91014: EQUAL
91015: IFFALSE 91025
// sContamin := true ;
91017: LD_ADDR_EXP 170
91021: PUSH
91022: LD_INT 1
91024: ST_TO_ADDR
// if p3 = 111 then
91025: LD_VAR 0 3
91029: PUSH
91030: LD_INT 111
91032: EQUAL
91033: IFFALSE 91043
// sOil := true ;
91035: LD_ADDR_EXP 172
91039: PUSH
91040: LD_INT 1
91042: ST_TO_ADDR
// if p3 = 112 then
91043: LD_VAR 0 3
91047: PUSH
91048: LD_INT 112
91050: EQUAL
91051: IFFALSE 91061
// sStu := true ;
91053: LD_ADDR_EXP 176
91057: PUSH
91058: LD_INT 1
91060: ST_TO_ADDR
// if p3 = 113 then
91061: LD_VAR 0 3
91065: PUSH
91066: LD_INT 113
91068: EQUAL
91069: IFFALSE 91079
// sBazooka := true ;
91071: LD_ADDR_EXP 179
91075: PUSH
91076: LD_INT 1
91078: ST_TO_ADDR
// if p3 = 114 then
91079: LD_VAR 0 3
91083: PUSH
91084: LD_INT 114
91086: EQUAL
91087: IFFALSE 91097
// sMortar := true ;
91089: LD_ADDR_EXP 180
91093: PUSH
91094: LD_INT 1
91096: ST_TO_ADDR
// if p3 = 115 then
91097: LD_VAR 0 3
91101: PUSH
91102: LD_INT 115
91104: EQUAL
91105: IFFALSE 91115
// sRanger := true ;
91107: LD_ADDR_EXP 190
91111: PUSH
91112: LD_INT 1
91114: ST_TO_ADDR
// end ; if p2 = 101 then
91115: LD_VAR 0 2
91119: PUSH
91120: LD_INT 101
91122: EQUAL
91123: IFFALSE 91251
// begin case p3 of 1 :
91125: LD_VAR 0 3
91129: PUSH
91130: LD_INT 1
91132: DOUBLE
91133: EQUAL
91134: IFTRUE 91138
91136: GO 91145
91138: POP
// hHackUnlimitedResources ; 2 :
91139: CALL 102288 0 0
91143: GO 91251
91145: LD_INT 2
91147: DOUBLE
91148: EQUAL
91149: IFTRUE 91153
91151: GO 91160
91153: POP
// hHackSetLevel10 ; 3 :
91154: CALL 102421 0 0
91158: GO 91251
91160: LD_INT 3
91162: DOUBLE
91163: EQUAL
91164: IFTRUE 91168
91166: GO 91175
91168: POP
// hHackSetLevel10YourUnits ; 4 :
91169: CALL 102506 0 0
91173: GO 91251
91175: LD_INT 4
91177: DOUBLE
91178: EQUAL
91179: IFTRUE 91183
91181: GO 91190
91183: POP
// hHackInvincible ; 5 :
91184: CALL 102954 0 0
91188: GO 91251
91190: LD_INT 5
91192: DOUBLE
91193: EQUAL
91194: IFTRUE 91198
91196: GO 91205
91198: POP
// hHackInvisible ; 6 :
91199: CALL 103065 0 0
91203: GO 91251
91205: LD_INT 6
91207: DOUBLE
91208: EQUAL
91209: IFTRUE 91213
91211: GO 91220
91213: POP
// hHackChangeYourSide ; 7 :
91214: CALL 103122 0 0
91218: GO 91251
91220: LD_INT 7
91222: DOUBLE
91223: EQUAL
91224: IFTRUE 91228
91226: GO 91235
91228: POP
// hHackChangeUnitSide ; 8 :
91229: CALL 103164 0 0
91233: GO 91251
91235: LD_INT 8
91237: DOUBLE
91238: EQUAL
91239: IFTRUE 91243
91241: GO 91250
91243: POP
// hHackFog ; end ;
91244: CALL 103265 0 0
91248: GO 91251
91250: POP
// end ; end ;
91251: LD_VAR 0 7
91255: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
91256: GO 91258
91258: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91259: LD_STRING initStreamRollete();
91261: PPUSH
91262: CALL_OW 559
// InitStreamMode ;
91266: CALL 91275 0 0
// DefineStreamItems ( ) ;
91270: CALL 91715 0 0
// end ;
91274: END
// function InitStreamMode ; begin
91275: LD_INT 0
91277: PPUSH
// streamModeActive := false ;
91278: LD_ADDR_EXP 137
91282: PUSH
91283: LD_INT 0
91285: ST_TO_ADDR
// normalCounter := 36 ;
91286: LD_ADDR_EXP 138
91290: PUSH
91291: LD_INT 36
91293: ST_TO_ADDR
// hardcoreCounter := 16 ;
91294: LD_ADDR_EXP 139
91298: PUSH
91299: LD_INT 16
91301: ST_TO_ADDR
// sRocket := false ;
91302: LD_ADDR_EXP 142
91306: PUSH
91307: LD_INT 0
91309: ST_TO_ADDR
// sSpeed := false ;
91310: LD_ADDR_EXP 141
91314: PUSH
91315: LD_INT 0
91317: ST_TO_ADDR
// sEngine := false ;
91318: LD_ADDR_EXP 143
91322: PUSH
91323: LD_INT 0
91325: ST_TO_ADDR
// sSpec := false ;
91326: LD_ADDR_EXP 140
91330: PUSH
91331: LD_INT 0
91333: ST_TO_ADDR
// sLevel := false ;
91334: LD_ADDR_EXP 144
91338: PUSH
91339: LD_INT 0
91341: ST_TO_ADDR
// sArmoury := false ;
91342: LD_ADDR_EXP 145
91346: PUSH
91347: LD_INT 0
91349: ST_TO_ADDR
// sRadar := false ;
91350: LD_ADDR_EXP 146
91354: PUSH
91355: LD_INT 0
91357: ST_TO_ADDR
// sBunker := false ;
91358: LD_ADDR_EXP 147
91362: PUSH
91363: LD_INT 0
91365: ST_TO_ADDR
// sHack := false ;
91366: LD_ADDR_EXP 148
91370: PUSH
91371: LD_INT 0
91373: ST_TO_ADDR
// sFire := false ;
91374: LD_ADDR_EXP 149
91378: PUSH
91379: LD_INT 0
91381: ST_TO_ADDR
// sRefresh := false ;
91382: LD_ADDR_EXP 150
91386: PUSH
91387: LD_INT 0
91389: ST_TO_ADDR
// sExp := false ;
91390: LD_ADDR_EXP 151
91394: PUSH
91395: LD_INT 0
91397: ST_TO_ADDR
// sDepot := false ;
91398: LD_ADDR_EXP 152
91402: PUSH
91403: LD_INT 0
91405: ST_TO_ADDR
// sFlag := false ;
91406: LD_ADDR_EXP 153
91410: PUSH
91411: LD_INT 0
91413: ST_TO_ADDR
// sKamikadze := false ;
91414: LD_ADDR_EXP 161
91418: PUSH
91419: LD_INT 0
91421: ST_TO_ADDR
// sTroll := false ;
91422: LD_ADDR_EXP 162
91426: PUSH
91427: LD_INT 0
91429: ST_TO_ADDR
// sSlow := false ;
91430: LD_ADDR_EXP 163
91434: PUSH
91435: LD_INT 0
91437: ST_TO_ADDR
// sLack := false ;
91438: LD_ADDR_EXP 164
91442: PUSH
91443: LD_INT 0
91445: ST_TO_ADDR
// sTank := false ;
91446: LD_ADDR_EXP 166
91450: PUSH
91451: LD_INT 0
91453: ST_TO_ADDR
// sRemote := false ;
91454: LD_ADDR_EXP 167
91458: PUSH
91459: LD_INT 0
91461: ST_TO_ADDR
// sPowell := false ;
91462: LD_ADDR_EXP 168
91466: PUSH
91467: LD_INT 0
91469: ST_TO_ADDR
// sTeleport := false ;
91470: LD_ADDR_EXP 171
91474: PUSH
91475: LD_INT 0
91477: ST_TO_ADDR
// sOilTower := false ;
91478: LD_ADDR_EXP 173
91482: PUSH
91483: LD_INT 0
91485: ST_TO_ADDR
// sShovel := false ;
91486: LD_ADDR_EXP 174
91490: PUSH
91491: LD_INT 0
91493: ST_TO_ADDR
// sSheik := false ;
91494: LD_ADDR_EXP 175
91498: PUSH
91499: LD_INT 0
91501: ST_TO_ADDR
// sEarthquake := false ;
91502: LD_ADDR_EXP 177
91506: PUSH
91507: LD_INT 0
91509: ST_TO_ADDR
// sAI := false ;
91510: LD_ADDR_EXP 178
91514: PUSH
91515: LD_INT 0
91517: ST_TO_ADDR
// sCargo := false ;
91518: LD_ADDR_EXP 181
91522: PUSH
91523: LD_INT 0
91525: ST_TO_ADDR
// sDLaser := false ;
91526: LD_ADDR_EXP 182
91530: PUSH
91531: LD_INT 0
91533: ST_TO_ADDR
// sExchange := false ;
91534: LD_ADDR_EXP 183
91538: PUSH
91539: LD_INT 0
91541: ST_TO_ADDR
// sFac := false ;
91542: LD_ADDR_EXP 184
91546: PUSH
91547: LD_INT 0
91549: ST_TO_ADDR
// sPower := false ;
91550: LD_ADDR_EXP 185
91554: PUSH
91555: LD_INT 0
91557: ST_TO_ADDR
// sRandom := false ;
91558: LD_ADDR_EXP 186
91562: PUSH
91563: LD_INT 0
91565: ST_TO_ADDR
// sShield := false ;
91566: LD_ADDR_EXP 187
91570: PUSH
91571: LD_INT 0
91573: ST_TO_ADDR
// sTime := false ;
91574: LD_ADDR_EXP 188
91578: PUSH
91579: LD_INT 0
91581: ST_TO_ADDR
// sTools := false ;
91582: LD_ADDR_EXP 189
91586: PUSH
91587: LD_INT 0
91589: ST_TO_ADDR
// sSold := false ;
91590: LD_ADDR_EXP 154
91594: PUSH
91595: LD_INT 0
91597: ST_TO_ADDR
// sDiff := false ;
91598: LD_ADDR_EXP 155
91602: PUSH
91603: LD_INT 0
91605: ST_TO_ADDR
// sFog := false ;
91606: LD_ADDR_EXP 158
91610: PUSH
91611: LD_INT 0
91613: ST_TO_ADDR
// sReset := false ;
91614: LD_ADDR_EXP 159
91618: PUSH
91619: LD_INT 0
91621: ST_TO_ADDR
// sSun := false ;
91622: LD_ADDR_EXP 160
91626: PUSH
91627: LD_INT 0
91629: ST_TO_ADDR
// sTiger := false ;
91630: LD_ADDR_EXP 156
91634: PUSH
91635: LD_INT 0
91637: ST_TO_ADDR
// sBomb := false ;
91638: LD_ADDR_EXP 157
91642: PUSH
91643: LD_INT 0
91645: ST_TO_ADDR
// sWound := false ;
91646: LD_ADDR_EXP 165
91650: PUSH
91651: LD_INT 0
91653: ST_TO_ADDR
// sBetray := false ;
91654: LD_ADDR_EXP 169
91658: PUSH
91659: LD_INT 0
91661: ST_TO_ADDR
// sContamin := false ;
91662: LD_ADDR_EXP 170
91666: PUSH
91667: LD_INT 0
91669: ST_TO_ADDR
// sOil := false ;
91670: LD_ADDR_EXP 172
91674: PUSH
91675: LD_INT 0
91677: ST_TO_ADDR
// sStu := false ;
91678: LD_ADDR_EXP 176
91682: PUSH
91683: LD_INT 0
91685: ST_TO_ADDR
// sBazooka := false ;
91686: LD_ADDR_EXP 179
91690: PUSH
91691: LD_INT 0
91693: ST_TO_ADDR
// sMortar := false ;
91694: LD_ADDR_EXP 180
91698: PUSH
91699: LD_INT 0
91701: ST_TO_ADDR
// sRanger := false ;
91702: LD_ADDR_EXP 190
91706: PUSH
91707: LD_INT 0
91709: ST_TO_ADDR
// end ;
91710: LD_VAR 0 1
91714: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
91715: LD_INT 0
91717: PPUSH
91718: PPUSH
91719: PPUSH
91720: PPUSH
91721: PPUSH
// result := [ ] ;
91722: LD_ADDR_VAR 0 1
91726: PUSH
91727: EMPTY
91728: ST_TO_ADDR
// if campaign_id = 1 then
91729: LD_OWVAR 69
91733: PUSH
91734: LD_INT 1
91736: EQUAL
91737: IFFALSE 94675
// begin case mission_number of 1 :
91739: LD_OWVAR 70
91743: PUSH
91744: LD_INT 1
91746: DOUBLE
91747: EQUAL
91748: IFTRUE 91752
91750: GO 91816
91752: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
91753: LD_ADDR_VAR 0 1
91757: PUSH
91758: LD_INT 2
91760: PUSH
91761: LD_INT 4
91763: PUSH
91764: LD_INT 11
91766: PUSH
91767: LD_INT 12
91769: PUSH
91770: LD_INT 15
91772: PUSH
91773: LD_INT 16
91775: PUSH
91776: LD_INT 22
91778: PUSH
91779: LD_INT 23
91781: PUSH
91782: LD_INT 26
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 101
91798: PUSH
91799: LD_INT 102
91801: PUSH
91802: LD_INT 106
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: LIST
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: ST_TO_ADDR
91814: GO 94673
91816: LD_INT 2
91818: DOUBLE
91819: EQUAL
91820: IFTRUE 91824
91822: GO 91896
91824: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
91825: LD_ADDR_VAR 0 1
91829: PUSH
91830: LD_INT 2
91832: PUSH
91833: LD_INT 4
91835: PUSH
91836: LD_INT 11
91838: PUSH
91839: LD_INT 12
91841: PUSH
91842: LD_INT 15
91844: PUSH
91845: LD_INT 16
91847: PUSH
91848: LD_INT 22
91850: PUSH
91851: LD_INT 23
91853: PUSH
91854: LD_INT 26
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: PUSH
91868: LD_INT 101
91870: PUSH
91871: LD_INT 102
91873: PUSH
91874: LD_INT 105
91876: PUSH
91877: LD_INT 106
91879: PUSH
91880: LD_INT 108
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: LIST
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: ST_TO_ADDR
91894: GO 94673
91896: LD_INT 3
91898: DOUBLE
91899: EQUAL
91900: IFTRUE 91904
91902: GO 91980
91904: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
91905: LD_ADDR_VAR 0 1
91909: PUSH
91910: LD_INT 2
91912: PUSH
91913: LD_INT 4
91915: PUSH
91916: LD_INT 5
91918: PUSH
91919: LD_INT 11
91921: PUSH
91922: LD_INT 12
91924: PUSH
91925: LD_INT 15
91927: PUSH
91928: LD_INT 16
91930: PUSH
91931: LD_INT 22
91933: PUSH
91934: LD_INT 26
91936: PUSH
91937: LD_INT 36
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 101
91954: PUSH
91955: LD_INT 102
91957: PUSH
91958: LD_INT 105
91960: PUSH
91961: LD_INT 106
91963: PUSH
91964: LD_INT 108
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: PUSH
91974: EMPTY
91975: LIST
91976: LIST
91977: ST_TO_ADDR
91978: GO 94673
91980: LD_INT 4
91982: DOUBLE
91983: EQUAL
91984: IFTRUE 91988
91986: GO 92072
91988: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
91989: LD_ADDR_VAR 0 1
91993: PUSH
91994: LD_INT 2
91996: PUSH
91997: LD_INT 4
91999: PUSH
92000: LD_INT 5
92002: PUSH
92003: LD_INT 8
92005: PUSH
92006: LD_INT 11
92008: PUSH
92009: LD_INT 12
92011: PUSH
92012: LD_INT 15
92014: PUSH
92015: LD_INT 16
92017: PUSH
92018: LD_INT 22
92020: PUSH
92021: LD_INT 23
92023: PUSH
92024: LD_INT 26
92026: PUSH
92027: LD_INT 36
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 101
92046: PUSH
92047: LD_INT 102
92049: PUSH
92050: LD_INT 105
92052: PUSH
92053: LD_INT 106
92055: PUSH
92056: LD_INT 108
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: ST_TO_ADDR
92070: GO 94673
92072: LD_INT 5
92074: DOUBLE
92075: EQUAL
92076: IFTRUE 92080
92078: GO 92180
92080: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
92081: LD_ADDR_VAR 0 1
92085: PUSH
92086: LD_INT 2
92088: PUSH
92089: LD_INT 4
92091: PUSH
92092: LD_INT 5
92094: PUSH
92095: LD_INT 6
92097: PUSH
92098: LD_INT 8
92100: PUSH
92101: LD_INT 11
92103: PUSH
92104: LD_INT 12
92106: PUSH
92107: LD_INT 15
92109: PUSH
92110: LD_INT 16
92112: PUSH
92113: LD_INT 22
92115: PUSH
92116: LD_INT 23
92118: PUSH
92119: LD_INT 25
92121: PUSH
92122: LD_INT 26
92124: PUSH
92125: LD_INT 36
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 101
92146: PUSH
92147: LD_INT 102
92149: PUSH
92150: LD_INT 105
92152: PUSH
92153: LD_INT 106
92155: PUSH
92156: LD_INT 108
92158: PUSH
92159: LD_INT 109
92161: PUSH
92162: LD_INT 112
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: PUSH
92174: EMPTY
92175: LIST
92176: LIST
92177: ST_TO_ADDR
92178: GO 94673
92180: LD_INT 6
92182: DOUBLE
92183: EQUAL
92184: IFTRUE 92188
92186: GO 92308
92188: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
92189: LD_ADDR_VAR 0 1
92193: PUSH
92194: LD_INT 2
92196: PUSH
92197: LD_INT 4
92199: PUSH
92200: LD_INT 5
92202: PUSH
92203: LD_INT 6
92205: PUSH
92206: LD_INT 8
92208: PUSH
92209: LD_INT 11
92211: PUSH
92212: LD_INT 12
92214: PUSH
92215: LD_INT 15
92217: PUSH
92218: LD_INT 16
92220: PUSH
92221: LD_INT 20
92223: PUSH
92224: LD_INT 21
92226: PUSH
92227: LD_INT 22
92229: PUSH
92230: LD_INT 23
92232: PUSH
92233: LD_INT 25
92235: PUSH
92236: LD_INT 26
92238: PUSH
92239: LD_INT 30
92241: PUSH
92242: LD_INT 31
92244: PUSH
92245: LD_INT 32
92247: PUSH
92248: LD_INT 36
92250: PUSH
92251: EMPTY
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: PUSH
92272: LD_INT 101
92274: PUSH
92275: LD_INT 102
92277: PUSH
92278: LD_INT 105
92280: PUSH
92281: LD_INT 106
92283: PUSH
92284: LD_INT 108
92286: PUSH
92287: LD_INT 109
92289: PUSH
92290: LD_INT 112
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: PUSH
92302: EMPTY
92303: LIST
92304: LIST
92305: ST_TO_ADDR
92306: GO 94673
92308: LD_INT 7
92310: DOUBLE
92311: EQUAL
92312: IFTRUE 92316
92314: GO 92416
92316: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
92317: LD_ADDR_VAR 0 1
92321: PUSH
92322: LD_INT 2
92324: PUSH
92325: LD_INT 4
92327: PUSH
92328: LD_INT 5
92330: PUSH
92331: LD_INT 7
92333: PUSH
92334: LD_INT 11
92336: PUSH
92337: LD_INT 12
92339: PUSH
92340: LD_INT 15
92342: PUSH
92343: LD_INT 16
92345: PUSH
92346: LD_INT 20
92348: PUSH
92349: LD_INT 21
92351: PUSH
92352: LD_INT 22
92354: PUSH
92355: LD_INT 23
92357: PUSH
92358: LD_INT 25
92360: PUSH
92361: LD_INT 26
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: PUSH
92380: LD_INT 101
92382: PUSH
92383: LD_INT 102
92385: PUSH
92386: LD_INT 103
92388: PUSH
92389: LD_INT 105
92391: PUSH
92392: LD_INT 106
92394: PUSH
92395: LD_INT 108
92397: PUSH
92398: LD_INT 112
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: ST_TO_ADDR
92414: GO 94673
92416: LD_INT 8
92418: DOUBLE
92419: EQUAL
92420: IFTRUE 92424
92422: GO 92552
92424: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
92425: LD_ADDR_VAR 0 1
92429: PUSH
92430: LD_INT 2
92432: PUSH
92433: LD_INT 4
92435: PUSH
92436: LD_INT 5
92438: PUSH
92439: LD_INT 6
92441: PUSH
92442: LD_INT 7
92444: PUSH
92445: LD_INT 8
92447: PUSH
92448: LD_INT 11
92450: PUSH
92451: LD_INT 12
92453: PUSH
92454: LD_INT 15
92456: PUSH
92457: LD_INT 16
92459: PUSH
92460: LD_INT 20
92462: PUSH
92463: LD_INT 21
92465: PUSH
92466: LD_INT 22
92468: PUSH
92469: LD_INT 23
92471: PUSH
92472: LD_INT 25
92474: PUSH
92475: LD_INT 26
92477: PUSH
92478: LD_INT 30
92480: PUSH
92481: LD_INT 31
92483: PUSH
92484: LD_INT 32
92486: PUSH
92487: LD_INT 36
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: LIST
92501: LIST
92502: LIST
92503: LIST
92504: LIST
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 101
92514: PUSH
92515: LD_INT 102
92517: PUSH
92518: LD_INT 103
92520: PUSH
92521: LD_INT 105
92523: PUSH
92524: LD_INT 106
92526: PUSH
92527: LD_INT 108
92529: PUSH
92530: LD_INT 109
92532: PUSH
92533: LD_INT 112
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: PUSH
92546: EMPTY
92547: LIST
92548: LIST
92549: ST_TO_ADDR
92550: GO 94673
92552: LD_INT 9
92554: DOUBLE
92555: EQUAL
92556: IFTRUE 92560
92558: GO 92696
92560: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
92561: LD_ADDR_VAR 0 1
92565: PUSH
92566: LD_INT 2
92568: PUSH
92569: LD_INT 4
92571: PUSH
92572: LD_INT 5
92574: PUSH
92575: LD_INT 6
92577: PUSH
92578: LD_INT 7
92580: PUSH
92581: LD_INT 8
92583: PUSH
92584: LD_INT 11
92586: PUSH
92587: LD_INT 12
92589: PUSH
92590: LD_INT 15
92592: PUSH
92593: LD_INT 16
92595: PUSH
92596: LD_INT 20
92598: PUSH
92599: LD_INT 21
92601: PUSH
92602: LD_INT 22
92604: PUSH
92605: LD_INT 23
92607: PUSH
92608: LD_INT 25
92610: PUSH
92611: LD_INT 26
92613: PUSH
92614: LD_INT 28
92616: PUSH
92617: LD_INT 30
92619: PUSH
92620: LD_INT 31
92622: PUSH
92623: LD_INT 32
92625: PUSH
92626: LD_INT 36
92628: PUSH
92629: EMPTY
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 101
92654: PUSH
92655: LD_INT 102
92657: PUSH
92658: LD_INT 103
92660: PUSH
92661: LD_INT 105
92663: PUSH
92664: LD_INT 106
92666: PUSH
92667: LD_INT 108
92669: PUSH
92670: LD_INT 109
92672: PUSH
92673: LD_INT 112
92675: PUSH
92676: LD_INT 114
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: ST_TO_ADDR
92694: GO 94673
92696: LD_INT 10
92698: DOUBLE
92699: EQUAL
92700: IFTRUE 92704
92702: GO 92888
92704: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
92705: LD_ADDR_VAR 0 1
92709: PUSH
92710: LD_INT 2
92712: PUSH
92713: LD_INT 4
92715: PUSH
92716: LD_INT 5
92718: PUSH
92719: LD_INT 6
92721: PUSH
92722: LD_INT 7
92724: PUSH
92725: LD_INT 8
92727: PUSH
92728: LD_INT 9
92730: PUSH
92731: LD_INT 10
92733: PUSH
92734: LD_INT 11
92736: PUSH
92737: LD_INT 12
92739: PUSH
92740: LD_INT 13
92742: PUSH
92743: LD_INT 14
92745: PUSH
92746: LD_INT 15
92748: PUSH
92749: LD_INT 16
92751: PUSH
92752: LD_INT 17
92754: PUSH
92755: LD_INT 18
92757: PUSH
92758: LD_INT 19
92760: PUSH
92761: LD_INT 20
92763: PUSH
92764: LD_INT 21
92766: PUSH
92767: LD_INT 22
92769: PUSH
92770: LD_INT 23
92772: PUSH
92773: LD_INT 24
92775: PUSH
92776: LD_INT 25
92778: PUSH
92779: LD_INT 26
92781: PUSH
92782: LD_INT 28
92784: PUSH
92785: LD_INT 30
92787: PUSH
92788: LD_INT 31
92790: PUSH
92791: LD_INT 32
92793: PUSH
92794: LD_INT 36
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 101
92830: PUSH
92831: LD_INT 102
92833: PUSH
92834: LD_INT 103
92836: PUSH
92837: LD_INT 104
92839: PUSH
92840: LD_INT 105
92842: PUSH
92843: LD_INT 106
92845: PUSH
92846: LD_INT 107
92848: PUSH
92849: LD_INT 108
92851: PUSH
92852: LD_INT 109
92854: PUSH
92855: LD_INT 110
92857: PUSH
92858: LD_INT 111
92860: PUSH
92861: LD_INT 112
92863: PUSH
92864: LD_INT 114
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: ST_TO_ADDR
92886: GO 94673
92888: LD_INT 11
92890: DOUBLE
92891: EQUAL
92892: IFTRUE 92896
92894: GO 93088
92896: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
92897: LD_ADDR_VAR 0 1
92901: PUSH
92902: LD_INT 2
92904: PUSH
92905: LD_INT 3
92907: PUSH
92908: LD_INT 4
92910: PUSH
92911: LD_INT 5
92913: PUSH
92914: LD_INT 6
92916: PUSH
92917: LD_INT 7
92919: PUSH
92920: LD_INT 8
92922: PUSH
92923: LD_INT 9
92925: PUSH
92926: LD_INT 10
92928: PUSH
92929: LD_INT 11
92931: PUSH
92932: LD_INT 12
92934: PUSH
92935: LD_INT 13
92937: PUSH
92938: LD_INT 14
92940: PUSH
92941: LD_INT 15
92943: PUSH
92944: LD_INT 16
92946: PUSH
92947: LD_INT 17
92949: PUSH
92950: LD_INT 18
92952: PUSH
92953: LD_INT 19
92955: PUSH
92956: LD_INT 20
92958: PUSH
92959: LD_INT 21
92961: PUSH
92962: LD_INT 22
92964: PUSH
92965: LD_INT 23
92967: PUSH
92968: LD_INT 24
92970: PUSH
92971: LD_INT 25
92973: PUSH
92974: LD_INT 26
92976: PUSH
92977: LD_INT 28
92979: PUSH
92980: LD_INT 30
92982: PUSH
92983: LD_INT 31
92985: PUSH
92986: LD_INT 32
92988: PUSH
92989: LD_INT 34
92991: PUSH
92992: LD_INT 36
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: PUSH
93028: LD_INT 101
93030: PUSH
93031: LD_INT 102
93033: PUSH
93034: LD_INT 103
93036: PUSH
93037: LD_INT 104
93039: PUSH
93040: LD_INT 105
93042: PUSH
93043: LD_INT 106
93045: PUSH
93046: LD_INT 107
93048: PUSH
93049: LD_INT 108
93051: PUSH
93052: LD_INT 109
93054: PUSH
93055: LD_INT 110
93057: PUSH
93058: LD_INT 111
93060: PUSH
93061: LD_INT 112
93063: PUSH
93064: LD_INT 114
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: ST_TO_ADDR
93086: GO 94673
93088: LD_INT 12
93090: DOUBLE
93091: EQUAL
93092: IFTRUE 93096
93094: GO 93304
93096: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
93097: LD_ADDR_VAR 0 1
93101: PUSH
93102: LD_INT 1
93104: PUSH
93105: LD_INT 2
93107: PUSH
93108: LD_INT 3
93110: PUSH
93111: LD_INT 4
93113: PUSH
93114: LD_INT 5
93116: PUSH
93117: LD_INT 6
93119: PUSH
93120: LD_INT 7
93122: PUSH
93123: LD_INT 8
93125: PUSH
93126: LD_INT 9
93128: PUSH
93129: LD_INT 10
93131: PUSH
93132: LD_INT 11
93134: PUSH
93135: LD_INT 12
93137: PUSH
93138: LD_INT 13
93140: PUSH
93141: LD_INT 14
93143: PUSH
93144: LD_INT 15
93146: PUSH
93147: LD_INT 16
93149: PUSH
93150: LD_INT 17
93152: PUSH
93153: LD_INT 18
93155: PUSH
93156: LD_INT 19
93158: PUSH
93159: LD_INT 20
93161: PUSH
93162: LD_INT 21
93164: PUSH
93165: LD_INT 22
93167: PUSH
93168: LD_INT 23
93170: PUSH
93171: LD_INT 24
93173: PUSH
93174: LD_INT 25
93176: PUSH
93177: LD_INT 26
93179: PUSH
93180: LD_INT 27
93182: PUSH
93183: LD_INT 28
93185: PUSH
93186: LD_INT 30
93188: PUSH
93189: LD_INT 31
93191: PUSH
93192: LD_INT 32
93194: PUSH
93195: LD_INT 33
93197: PUSH
93198: LD_INT 34
93200: PUSH
93201: LD_INT 36
93203: PUSH
93204: EMPTY
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: PUSH
93240: LD_INT 101
93242: PUSH
93243: LD_INT 102
93245: PUSH
93246: LD_INT 103
93248: PUSH
93249: LD_INT 104
93251: PUSH
93252: LD_INT 105
93254: PUSH
93255: LD_INT 106
93257: PUSH
93258: LD_INT 107
93260: PUSH
93261: LD_INT 108
93263: PUSH
93264: LD_INT 109
93266: PUSH
93267: LD_INT 110
93269: PUSH
93270: LD_INT 111
93272: PUSH
93273: LD_INT 112
93275: PUSH
93276: LD_INT 113
93278: PUSH
93279: LD_INT 114
93281: PUSH
93282: EMPTY
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: ST_TO_ADDR
93302: GO 94673
93304: LD_INT 13
93306: DOUBLE
93307: EQUAL
93308: IFTRUE 93312
93310: GO 93508
93312: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
93313: LD_ADDR_VAR 0 1
93317: PUSH
93318: LD_INT 1
93320: PUSH
93321: LD_INT 2
93323: PUSH
93324: LD_INT 3
93326: PUSH
93327: LD_INT 4
93329: PUSH
93330: LD_INT 5
93332: PUSH
93333: LD_INT 8
93335: PUSH
93336: LD_INT 9
93338: PUSH
93339: LD_INT 10
93341: PUSH
93342: LD_INT 11
93344: PUSH
93345: LD_INT 12
93347: PUSH
93348: LD_INT 14
93350: PUSH
93351: LD_INT 15
93353: PUSH
93354: LD_INT 16
93356: PUSH
93357: LD_INT 17
93359: PUSH
93360: LD_INT 18
93362: PUSH
93363: LD_INT 19
93365: PUSH
93366: LD_INT 20
93368: PUSH
93369: LD_INT 21
93371: PUSH
93372: LD_INT 22
93374: PUSH
93375: LD_INT 23
93377: PUSH
93378: LD_INT 24
93380: PUSH
93381: LD_INT 25
93383: PUSH
93384: LD_INT 26
93386: PUSH
93387: LD_INT 27
93389: PUSH
93390: LD_INT 28
93392: PUSH
93393: LD_INT 30
93395: PUSH
93396: LD_INT 31
93398: PUSH
93399: LD_INT 32
93401: PUSH
93402: LD_INT 33
93404: PUSH
93405: LD_INT 34
93407: PUSH
93408: LD_INT 36
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 101
93446: PUSH
93447: LD_INT 102
93449: PUSH
93450: LD_INT 103
93452: PUSH
93453: LD_INT 104
93455: PUSH
93456: LD_INT 105
93458: PUSH
93459: LD_INT 106
93461: PUSH
93462: LD_INT 107
93464: PUSH
93465: LD_INT 108
93467: PUSH
93468: LD_INT 109
93470: PUSH
93471: LD_INT 110
93473: PUSH
93474: LD_INT 111
93476: PUSH
93477: LD_INT 112
93479: PUSH
93480: LD_INT 113
93482: PUSH
93483: LD_INT 114
93485: PUSH
93486: EMPTY
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: ST_TO_ADDR
93506: GO 94673
93508: LD_INT 14
93510: DOUBLE
93511: EQUAL
93512: IFTRUE 93516
93514: GO 93728
93516: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
93517: LD_ADDR_VAR 0 1
93521: PUSH
93522: LD_INT 1
93524: PUSH
93525: LD_INT 2
93527: PUSH
93528: LD_INT 3
93530: PUSH
93531: LD_INT 4
93533: PUSH
93534: LD_INT 5
93536: PUSH
93537: LD_INT 6
93539: PUSH
93540: LD_INT 7
93542: PUSH
93543: LD_INT 8
93545: PUSH
93546: LD_INT 9
93548: PUSH
93549: LD_INT 10
93551: PUSH
93552: LD_INT 11
93554: PUSH
93555: LD_INT 12
93557: PUSH
93558: LD_INT 13
93560: PUSH
93561: LD_INT 14
93563: PUSH
93564: LD_INT 15
93566: PUSH
93567: LD_INT 16
93569: PUSH
93570: LD_INT 17
93572: PUSH
93573: LD_INT 18
93575: PUSH
93576: LD_INT 19
93578: PUSH
93579: LD_INT 20
93581: PUSH
93582: LD_INT 21
93584: PUSH
93585: LD_INT 22
93587: PUSH
93588: LD_INT 23
93590: PUSH
93591: LD_INT 24
93593: PUSH
93594: LD_INT 25
93596: PUSH
93597: LD_INT 26
93599: PUSH
93600: LD_INT 27
93602: PUSH
93603: LD_INT 28
93605: PUSH
93606: LD_INT 29
93608: PUSH
93609: LD_INT 30
93611: PUSH
93612: LD_INT 31
93614: PUSH
93615: LD_INT 32
93617: PUSH
93618: LD_INT 33
93620: PUSH
93621: LD_INT 34
93623: PUSH
93624: LD_INT 36
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: LIST
93631: LIST
93632: LIST
93633: LIST
93634: LIST
93635: LIST
93636: LIST
93637: LIST
93638: LIST
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: LIST
93657: LIST
93658: LIST
93659: LIST
93660: LIST
93661: LIST
93662: LIST
93663: PUSH
93664: LD_INT 101
93666: PUSH
93667: LD_INT 102
93669: PUSH
93670: LD_INT 103
93672: PUSH
93673: LD_INT 104
93675: PUSH
93676: LD_INT 105
93678: PUSH
93679: LD_INT 106
93681: PUSH
93682: LD_INT 107
93684: PUSH
93685: LD_INT 108
93687: PUSH
93688: LD_INT 109
93690: PUSH
93691: LD_INT 110
93693: PUSH
93694: LD_INT 111
93696: PUSH
93697: LD_INT 112
93699: PUSH
93700: LD_INT 113
93702: PUSH
93703: LD_INT 114
93705: PUSH
93706: EMPTY
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: ST_TO_ADDR
93726: GO 94673
93728: LD_INT 15
93730: DOUBLE
93731: EQUAL
93732: IFTRUE 93736
93734: GO 93948
93736: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
93737: LD_ADDR_VAR 0 1
93741: PUSH
93742: LD_INT 1
93744: PUSH
93745: LD_INT 2
93747: PUSH
93748: LD_INT 3
93750: PUSH
93751: LD_INT 4
93753: PUSH
93754: LD_INT 5
93756: PUSH
93757: LD_INT 6
93759: PUSH
93760: LD_INT 7
93762: PUSH
93763: LD_INT 8
93765: PUSH
93766: LD_INT 9
93768: PUSH
93769: LD_INT 10
93771: PUSH
93772: LD_INT 11
93774: PUSH
93775: LD_INT 12
93777: PUSH
93778: LD_INT 13
93780: PUSH
93781: LD_INT 14
93783: PUSH
93784: LD_INT 15
93786: PUSH
93787: LD_INT 16
93789: PUSH
93790: LD_INT 17
93792: PUSH
93793: LD_INT 18
93795: PUSH
93796: LD_INT 19
93798: PUSH
93799: LD_INT 20
93801: PUSH
93802: LD_INT 21
93804: PUSH
93805: LD_INT 22
93807: PUSH
93808: LD_INT 23
93810: PUSH
93811: LD_INT 24
93813: PUSH
93814: LD_INT 25
93816: PUSH
93817: LD_INT 26
93819: PUSH
93820: LD_INT 27
93822: PUSH
93823: LD_INT 28
93825: PUSH
93826: LD_INT 29
93828: PUSH
93829: LD_INT 30
93831: PUSH
93832: LD_INT 31
93834: PUSH
93835: LD_INT 32
93837: PUSH
93838: LD_INT 33
93840: PUSH
93841: LD_INT 34
93843: PUSH
93844: LD_INT 36
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: LIST
93851: LIST
93852: LIST
93853: LIST
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: PUSH
93884: LD_INT 101
93886: PUSH
93887: LD_INT 102
93889: PUSH
93890: LD_INT 103
93892: PUSH
93893: LD_INT 104
93895: PUSH
93896: LD_INT 105
93898: PUSH
93899: LD_INT 106
93901: PUSH
93902: LD_INT 107
93904: PUSH
93905: LD_INT 108
93907: PUSH
93908: LD_INT 109
93910: PUSH
93911: LD_INT 110
93913: PUSH
93914: LD_INT 111
93916: PUSH
93917: LD_INT 112
93919: PUSH
93920: LD_INT 113
93922: PUSH
93923: LD_INT 114
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: ST_TO_ADDR
93946: GO 94673
93948: LD_INT 16
93950: DOUBLE
93951: EQUAL
93952: IFTRUE 93956
93954: GO 94080
93956: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
93957: LD_ADDR_VAR 0 1
93961: PUSH
93962: LD_INT 2
93964: PUSH
93965: LD_INT 4
93967: PUSH
93968: LD_INT 5
93970: PUSH
93971: LD_INT 7
93973: PUSH
93974: LD_INT 11
93976: PUSH
93977: LD_INT 12
93979: PUSH
93980: LD_INT 15
93982: PUSH
93983: LD_INT 16
93985: PUSH
93986: LD_INT 20
93988: PUSH
93989: LD_INT 21
93991: PUSH
93992: LD_INT 22
93994: PUSH
93995: LD_INT 23
93997: PUSH
93998: LD_INT 25
94000: PUSH
94001: LD_INT 26
94003: PUSH
94004: LD_INT 30
94006: PUSH
94007: LD_INT 31
94009: PUSH
94010: LD_INT 32
94012: PUSH
94013: LD_INT 33
94015: PUSH
94016: LD_INT 34
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: PUSH
94040: LD_INT 101
94042: PUSH
94043: LD_INT 102
94045: PUSH
94046: LD_INT 103
94048: PUSH
94049: LD_INT 106
94051: PUSH
94052: LD_INT 108
94054: PUSH
94055: LD_INT 112
94057: PUSH
94058: LD_INT 113
94060: PUSH
94061: LD_INT 114
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: PUSH
94074: EMPTY
94075: LIST
94076: LIST
94077: ST_TO_ADDR
94078: GO 94673
94080: LD_INT 17
94082: DOUBLE
94083: EQUAL
94084: IFTRUE 94088
94086: GO 94300
94088: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
94089: LD_ADDR_VAR 0 1
94093: PUSH
94094: LD_INT 1
94096: PUSH
94097: LD_INT 2
94099: PUSH
94100: LD_INT 3
94102: PUSH
94103: LD_INT 4
94105: PUSH
94106: LD_INT 5
94108: PUSH
94109: LD_INT 6
94111: PUSH
94112: LD_INT 7
94114: PUSH
94115: LD_INT 8
94117: PUSH
94118: LD_INT 9
94120: PUSH
94121: LD_INT 10
94123: PUSH
94124: LD_INT 11
94126: PUSH
94127: LD_INT 12
94129: PUSH
94130: LD_INT 13
94132: PUSH
94133: LD_INT 14
94135: PUSH
94136: LD_INT 15
94138: PUSH
94139: LD_INT 16
94141: PUSH
94142: LD_INT 17
94144: PUSH
94145: LD_INT 18
94147: PUSH
94148: LD_INT 19
94150: PUSH
94151: LD_INT 20
94153: PUSH
94154: LD_INT 21
94156: PUSH
94157: LD_INT 22
94159: PUSH
94160: LD_INT 23
94162: PUSH
94163: LD_INT 24
94165: PUSH
94166: LD_INT 25
94168: PUSH
94169: LD_INT 26
94171: PUSH
94172: LD_INT 27
94174: PUSH
94175: LD_INT 28
94177: PUSH
94178: LD_INT 29
94180: PUSH
94181: LD_INT 30
94183: PUSH
94184: LD_INT 31
94186: PUSH
94187: LD_INT 32
94189: PUSH
94190: LD_INT 33
94192: PUSH
94193: LD_INT 34
94195: PUSH
94196: LD_INT 36
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: LIST
94233: LIST
94234: LIST
94235: PUSH
94236: LD_INT 101
94238: PUSH
94239: LD_INT 102
94241: PUSH
94242: LD_INT 103
94244: PUSH
94245: LD_INT 104
94247: PUSH
94248: LD_INT 105
94250: PUSH
94251: LD_INT 106
94253: PUSH
94254: LD_INT 107
94256: PUSH
94257: LD_INT 108
94259: PUSH
94260: LD_INT 109
94262: PUSH
94263: LD_INT 110
94265: PUSH
94266: LD_INT 111
94268: PUSH
94269: LD_INT 112
94271: PUSH
94272: LD_INT 113
94274: PUSH
94275: LD_INT 114
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: ST_TO_ADDR
94298: GO 94673
94300: LD_INT 18
94302: DOUBLE
94303: EQUAL
94304: IFTRUE 94308
94306: GO 94444
94308: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
94309: LD_ADDR_VAR 0 1
94313: PUSH
94314: LD_INT 2
94316: PUSH
94317: LD_INT 4
94319: PUSH
94320: LD_INT 5
94322: PUSH
94323: LD_INT 7
94325: PUSH
94326: LD_INT 11
94328: PUSH
94329: LD_INT 12
94331: PUSH
94332: LD_INT 15
94334: PUSH
94335: LD_INT 16
94337: PUSH
94338: LD_INT 20
94340: PUSH
94341: LD_INT 21
94343: PUSH
94344: LD_INT 22
94346: PUSH
94347: LD_INT 23
94349: PUSH
94350: LD_INT 25
94352: PUSH
94353: LD_INT 26
94355: PUSH
94356: LD_INT 30
94358: PUSH
94359: LD_INT 31
94361: PUSH
94362: LD_INT 32
94364: PUSH
94365: LD_INT 33
94367: PUSH
94368: LD_INT 34
94370: PUSH
94371: LD_INT 35
94373: PUSH
94374: LD_INT 36
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 101
94402: PUSH
94403: LD_INT 102
94405: PUSH
94406: LD_INT 103
94408: PUSH
94409: LD_INT 106
94411: PUSH
94412: LD_INT 108
94414: PUSH
94415: LD_INT 112
94417: PUSH
94418: LD_INT 113
94420: PUSH
94421: LD_INT 114
94423: PUSH
94424: LD_INT 115
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: ST_TO_ADDR
94442: GO 94673
94444: LD_INT 19
94446: DOUBLE
94447: EQUAL
94448: IFTRUE 94452
94450: GO 94672
94452: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
94453: LD_ADDR_VAR 0 1
94457: PUSH
94458: LD_INT 1
94460: PUSH
94461: LD_INT 2
94463: PUSH
94464: LD_INT 3
94466: PUSH
94467: LD_INT 4
94469: PUSH
94470: LD_INT 5
94472: PUSH
94473: LD_INT 6
94475: PUSH
94476: LD_INT 7
94478: PUSH
94479: LD_INT 8
94481: PUSH
94482: LD_INT 9
94484: PUSH
94485: LD_INT 10
94487: PUSH
94488: LD_INT 11
94490: PUSH
94491: LD_INT 12
94493: PUSH
94494: LD_INT 13
94496: PUSH
94497: LD_INT 14
94499: PUSH
94500: LD_INT 15
94502: PUSH
94503: LD_INT 16
94505: PUSH
94506: LD_INT 17
94508: PUSH
94509: LD_INT 18
94511: PUSH
94512: LD_INT 19
94514: PUSH
94515: LD_INT 20
94517: PUSH
94518: LD_INT 21
94520: PUSH
94521: LD_INT 22
94523: PUSH
94524: LD_INT 23
94526: PUSH
94527: LD_INT 24
94529: PUSH
94530: LD_INT 25
94532: PUSH
94533: LD_INT 26
94535: PUSH
94536: LD_INT 27
94538: PUSH
94539: LD_INT 28
94541: PUSH
94542: LD_INT 29
94544: PUSH
94545: LD_INT 30
94547: PUSH
94548: LD_INT 31
94550: PUSH
94551: LD_INT 32
94553: PUSH
94554: LD_INT 33
94556: PUSH
94557: LD_INT 34
94559: PUSH
94560: LD_INT 35
94562: PUSH
94563: LD_INT 36
94565: PUSH
94566: EMPTY
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 101
94606: PUSH
94607: LD_INT 102
94609: PUSH
94610: LD_INT 103
94612: PUSH
94613: LD_INT 104
94615: PUSH
94616: LD_INT 105
94618: PUSH
94619: LD_INT 106
94621: PUSH
94622: LD_INT 107
94624: PUSH
94625: LD_INT 108
94627: PUSH
94628: LD_INT 109
94630: PUSH
94631: LD_INT 110
94633: PUSH
94634: LD_INT 111
94636: PUSH
94637: LD_INT 112
94639: PUSH
94640: LD_INT 113
94642: PUSH
94643: LD_INT 114
94645: PUSH
94646: LD_INT 115
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: LIST
94662: LIST
94663: LIST
94664: LIST
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: ST_TO_ADDR
94670: GO 94673
94672: POP
// end else
94673: GO 94892
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
94675: LD_ADDR_VAR 0 1
94679: PUSH
94680: LD_INT 1
94682: PUSH
94683: LD_INT 2
94685: PUSH
94686: LD_INT 3
94688: PUSH
94689: LD_INT 4
94691: PUSH
94692: LD_INT 5
94694: PUSH
94695: LD_INT 6
94697: PUSH
94698: LD_INT 7
94700: PUSH
94701: LD_INT 8
94703: PUSH
94704: LD_INT 9
94706: PUSH
94707: LD_INT 10
94709: PUSH
94710: LD_INT 11
94712: PUSH
94713: LD_INT 12
94715: PUSH
94716: LD_INT 13
94718: PUSH
94719: LD_INT 14
94721: PUSH
94722: LD_INT 15
94724: PUSH
94725: LD_INT 16
94727: PUSH
94728: LD_INT 17
94730: PUSH
94731: LD_INT 18
94733: PUSH
94734: LD_INT 19
94736: PUSH
94737: LD_INT 20
94739: PUSH
94740: LD_INT 21
94742: PUSH
94743: LD_INT 22
94745: PUSH
94746: LD_INT 23
94748: PUSH
94749: LD_INT 24
94751: PUSH
94752: LD_INT 25
94754: PUSH
94755: LD_INT 26
94757: PUSH
94758: LD_INT 27
94760: PUSH
94761: LD_INT 28
94763: PUSH
94764: LD_INT 29
94766: PUSH
94767: LD_INT 30
94769: PUSH
94770: LD_INT 31
94772: PUSH
94773: LD_INT 32
94775: PUSH
94776: LD_INT 33
94778: PUSH
94779: LD_INT 34
94781: PUSH
94782: LD_INT 35
94784: PUSH
94785: LD_INT 36
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: PUSH
94826: LD_INT 101
94828: PUSH
94829: LD_INT 102
94831: PUSH
94832: LD_INT 103
94834: PUSH
94835: LD_INT 104
94837: PUSH
94838: LD_INT 105
94840: PUSH
94841: LD_INT 106
94843: PUSH
94844: LD_INT 107
94846: PUSH
94847: LD_INT 108
94849: PUSH
94850: LD_INT 109
94852: PUSH
94853: LD_INT 110
94855: PUSH
94856: LD_INT 111
94858: PUSH
94859: LD_INT 112
94861: PUSH
94862: LD_INT 113
94864: PUSH
94865: LD_INT 114
94867: PUSH
94868: LD_INT 115
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: ST_TO_ADDR
// if result then
94892: LD_VAR 0 1
94896: IFFALSE 95185
// begin normal :=  ;
94898: LD_ADDR_VAR 0 3
94902: PUSH
94903: LD_STRING 
94905: ST_TO_ADDR
// hardcore :=  ;
94906: LD_ADDR_VAR 0 4
94910: PUSH
94911: LD_STRING 
94913: ST_TO_ADDR
// for i = 1 to normalCounter do
94914: LD_ADDR_VAR 0 5
94918: PUSH
94919: DOUBLE
94920: LD_INT 1
94922: DEC
94923: ST_TO_ADDR
94924: LD_EXP 138
94928: PUSH
94929: FOR_TO
94930: IFFALSE 95031
// begin tmp := 0 ;
94932: LD_ADDR_VAR 0 2
94936: PUSH
94937: LD_STRING 0
94939: ST_TO_ADDR
// if result [ 1 ] then
94940: LD_VAR 0 1
94944: PUSH
94945: LD_INT 1
94947: ARRAY
94948: IFFALSE 95013
// if result [ 1 ] [ 1 ] = i then
94950: LD_VAR 0 1
94954: PUSH
94955: LD_INT 1
94957: ARRAY
94958: PUSH
94959: LD_INT 1
94961: ARRAY
94962: PUSH
94963: LD_VAR 0 5
94967: EQUAL
94968: IFFALSE 95013
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94970: LD_ADDR_VAR 0 1
94974: PUSH
94975: LD_VAR 0 1
94979: PPUSH
94980: LD_INT 1
94982: PPUSH
94983: LD_VAR 0 1
94987: PUSH
94988: LD_INT 1
94990: ARRAY
94991: PPUSH
94992: LD_INT 1
94994: PPUSH
94995: CALL_OW 3
94999: PPUSH
95000: CALL_OW 1
95004: ST_TO_ADDR
// tmp := 1 ;
95005: LD_ADDR_VAR 0 2
95009: PUSH
95010: LD_STRING 1
95012: ST_TO_ADDR
// end ; normal := normal & tmp ;
95013: LD_ADDR_VAR 0 3
95017: PUSH
95018: LD_VAR 0 3
95022: PUSH
95023: LD_VAR 0 2
95027: STR
95028: ST_TO_ADDR
// end ;
95029: GO 94929
95031: POP
95032: POP
// for i = 1 to hardcoreCounter do
95033: LD_ADDR_VAR 0 5
95037: PUSH
95038: DOUBLE
95039: LD_INT 1
95041: DEC
95042: ST_TO_ADDR
95043: LD_EXP 139
95047: PUSH
95048: FOR_TO
95049: IFFALSE 95154
// begin tmp := 0 ;
95051: LD_ADDR_VAR 0 2
95055: PUSH
95056: LD_STRING 0
95058: ST_TO_ADDR
// if result [ 2 ] then
95059: LD_VAR 0 1
95063: PUSH
95064: LD_INT 2
95066: ARRAY
95067: IFFALSE 95136
// if result [ 2 ] [ 1 ] = 100 + i then
95069: LD_VAR 0 1
95073: PUSH
95074: LD_INT 2
95076: ARRAY
95077: PUSH
95078: LD_INT 1
95080: ARRAY
95081: PUSH
95082: LD_INT 100
95084: PUSH
95085: LD_VAR 0 5
95089: PLUS
95090: EQUAL
95091: IFFALSE 95136
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95093: LD_ADDR_VAR 0 1
95097: PUSH
95098: LD_VAR 0 1
95102: PPUSH
95103: LD_INT 2
95105: PPUSH
95106: LD_VAR 0 1
95110: PUSH
95111: LD_INT 2
95113: ARRAY
95114: PPUSH
95115: LD_INT 1
95117: PPUSH
95118: CALL_OW 3
95122: PPUSH
95123: CALL_OW 1
95127: ST_TO_ADDR
// tmp := 1 ;
95128: LD_ADDR_VAR 0 2
95132: PUSH
95133: LD_STRING 1
95135: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95136: LD_ADDR_VAR 0 4
95140: PUSH
95141: LD_VAR 0 4
95145: PUSH
95146: LD_VAR 0 2
95150: STR
95151: ST_TO_ADDR
// end ;
95152: GO 95048
95154: POP
95155: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
95156: LD_STRING getStreamItemsFromMission("
95158: PUSH
95159: LD_VAR 0 3
95163: STR
95164: PUSH
95165: LD_STRING ","
95167: STR
95168: PUSH
95169: LD_VAR 0 4
95173: STR
95174: PUSH
95175: LD_STRING ")
95177: STR
95178: PPUSH
95179: CALL_OW 559
// end else
95183: GO 95192
// ToLua ( getStreamItemsFromMission("","") ) ;
95185: LD_STRING getStreamItemsFromMission("","")
95187: PPUSH
95188: CALL_OW 559
// end ;
95192: LD_VAR 0 1
95196: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95197: LD_EXP 137
95201: PUSH
95202: LD_EXP 142
95206: AND
95207: IFFALSE 95331
95209: GO 95211
95211: DISABLE
95212: LD_INT 0
95214: PPUSH
95215: PPUSH
// begin enable ;
95216: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95217: LD_ADDR_VAR 0 2
95221: PUSH
95222: LD_INT 22
95224: PUSH
95225: LD_OWVAR 2
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: PUSH
95234: LD_INT 2
95236: PUSH
95237: LD_INT 34
95239: PUSH
95240: LD_INT 7
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 34
95249: PUSH
95250: LD_INT 45
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 34
95259: PUSH
95260: LD_INT 28
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 34
95269: PUSH
95270: LD_INT 47
95272: PUSH
95273: EMPTY
95274: LIST
95275: LIST
95276: PUSH
95277: EMPTY
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PPUSH
95288: CALL_OW 69
95292: ST_TO_ADDR
// if not tmp then
95293: LD_VAR 0 2
95297: NOT
95298: IFFALSE 95302
// exit ;
95300: GO 95331
// for i in tmp do
95302: LD_ADDR_VAR 0 1
95306: PUSH
95307: LD_VAR 0 2
95311: PUSH
95312: FOR_IN
95313: IFFALSE 95329
// begin SetLives ( i , 0 ) ;
95315: LD_VAR 0 1
95319: PPUSH
95320: LD_INT 0
95322: PPUSH
95323: CALL_OW 234
// end ;
95327: GO 95312
95329: POP
95330: POP
// end ;
95331: PPOPN 2
95333: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
95334: LD_EXP 137
95338: PUSH
95339: LD_EXP 143
95343: AND
95344: IFFALSE 95428
95346: GO 95348
95348: DISABLE
95349: LD_INT 0
95351: PPUSH
95352: PPUSH
// begin enable ;
95353: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
95354: LD_ADDR_VAR 0 2
95358: PUSH
95359: LD_INT 22
95361: PUSH
95362: LD_OWVAR 2
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: PUSH
95371: LD_INT 32
95373: PUSH
95374: LD_INT 3
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: PPUSH
95385: CALL_OW 69
95389: ST_TO_ADDR
// if not tmp then
95390: LD_VAR 0 2
95394: NOT
95395: IFFALSE 95399
// exit ;
95397: GO 95428
// for i in tmp do
95399: LD_ADDR_VAR 0 1
95403: PUSH
95404: LD_VAR 0 2
95408: PUSH
95409: FOR_IN
95410: IFFALSE 95426
// begin SetLives ( i , 0 ) ;
95412: LD_VAR 0 1
95416: PPUSH
95417: LD_INT 0
95419: PPUSH
95420: CALL_OW 234
// end ;
95424: GO 95409
95426: POP
95427: POP
// end ;
95428: PPOPN 2
95430: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
95431: LD_EXP 137
95435: PUSH
95436: LD_EXP 140
95440: AND
95441: IFFALSE 95534
95443: GO 95445
95445: DISABLE
95446: LD_INT 0
95448: PPUSH
// begin enable ;
95449: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
95450: LD_ADDR_VAR 0 1
95454: PUSH
95455: LD_INT 22
95457: PUSH
95458: LD_OWVAR 2
95462: PUSH
95463: EMPTY
95464: LIST
95465: LIST
95466: PUSH
95467: LD_INT 2
95469: PUSH
95470: LD_INT 25
95472: PUSH
95473: LD_INT 5
95475: PUSH
95476: EMPTY
95477: LIST
95478: LIST
95479: PUSH
95480: LD_INT 25
95482: PUSH
95483: LD_INT 9
95485: PUSH
95486: EMPTY
95487: LIST
95488: LIST
95489: PUSH
95490: LD_INT 25
95492: PUSH
95493: LD_INT 8
95495: PUSH
95496: EMPTY
95497: LIST
95498: LIST
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: PUSH
95506: EMPTY
95507: LIST
95508: LIST
95509: PPUSH
95510: CALL_OW 69
95514: PUSH
95515: FOR_IN
95516: IFFALSE 95532
// begin SetClass ( i , 1 ) ;
95518: LD_VAR 0 1
95522: PPUSH
95523: LD_INT 1
95525: PPUSH
95526: CALL_OW 336
// end ;
95530: GO 95515
95532: POP
95533: POP
// end ;
95534: PPOPN 1
95536: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95537: LD_EXP 137
95541: PUSH
95542: LD_EXP 141
95546: AND
95547: PUSH
95548: LD_OWVAR 65
95552: PUSH
95553: LD_INT 7
95555: LESS
95556: AND
95557: IFFALSE 95571
95559: GO 95561
95561: DISABLE
// begin enable ;
95562: ENABLE
// game_speed := 7 ;
95563: LD_ADDR_OWVAR 65
95567: PUSH
95568: LD_INT 7
95570: ST_TO_ADDR
// end ;
95571: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95572: LD_EXP 137
95576: PUSH
95577: LD_EXP 144
95581: AND
95582: IFFALSE 95784
95584: GO 95586
95586: DISABLE
95587: LD_INT 0
95589: PPUSH
95590: PPUSH
95591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95592: LD_ADDR_VAR 0 3
95596: PUSH
95597: LD_INT 81
95599: PUSH
95600: LD_OWVAR 2
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: LD_INT 21
95611: PUSH
95612: LD_INT 1
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: PPUSH
95623: CALL_OW 69
95627: ST_TO_ADDR
// if not tmp then
95628: LD_VAR 0 3
95632: NOT
95633: IFFALSE 95637
// exit ;
95635: GO 95784
// if tmp > 5 then
95637: LD_VAR 0 3
95641: PUSH
95642: LD_INT 5
95644: GREATER
95645: IFFALSE 95657
// k := 5 else
95647: LD_ADDR_VAR 0 2
95651: PUSH
95652: LD_INT 5
95654: ST_TO_ADDR
95655: GO 95667
// k := tmp ;
95657: LD_ADDR_VAR 0 2
95661: PUSH
95662: LD_VAR 0 3
95666: ST_TO_ADDR
// for i := 1 to k do
95667: LD_ADDR_VAR 0 1
95671: PUSH
95672: DOUBLE
95673: LD_INT 1
95675: DEC
95676: ST_TO_ADDR
95677: LD_VAR 0 2
95681: PUSH
95682: FOR_TO
95683: IFFALSE 95782
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95685: LD_VAR 0 3
95689: PUSH
95690: LD_VAR 0 1
95694: ARRAY
95695: PPUSH
95696: LD_VAR 0 1
95700: PUSH
95701: LD_INT 4
95703: MOD
95704: PUSH
95705: LD_INT 1
95707: PLUS
95708: PPUSH
95709: CALL_OW 259
95713: PUSH
95714: LD_INT 10
95716: LESS
95717: IFFALSE 95780
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95719: LD_VAR 0 3
95723: PUSH
95724: LD_VAR 0 1
95728: ARRAY
95729: PPUSH
95730: LD_VAR 0 1
95734: PUSH
95735: LD_INT 4
95737: MOD
95738: PUSH
95739: LD_INT 1
95741: PLUS
95742: PPUSH
95743: LD_VAR 0 3
95747: PUSH
95748: LD_VAR 0 1
95752: ARRAY
95753: PPUSH
95754: LD_VAR 0 1
95758: PUSH
95759: LD_INT 4
95761: MOD
95762: PUSH
95763: LD_INT 1
95765: PLUS
95766: PPUSH
95767: CALL_OW 259
95771: PUSH
95772: LD_INT 1
95774: PLUS
95775: PPUSH
95776: CALL_OW 237
95780: GO 95682
95782: POP
95783: POP
// end ;
95784: PPOPN 3
95786: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
95787: LD_EXP 137
95791: PUSH
95792: LD_EXP 145
95796: AND
95797: IFFALSE 95817
95799: GO 95801
95801: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
95802: LD_INT 4
95804: PPUSH
95805: LD_OWVAR 2
95809: PPUSH
95810: LD_INT 0
95812: PPUSH
95813: CALL_OW 324
95817: END
// every 0 0$1 trigger StreamModeActive and sShovel do
95818: LD_EXP 137
95822: PUSH
95823: LD_EXP 174
95827: AND
95828: IFFALSE 95848
95830: GO 95832
95832: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
95833: LD_INT 19
95835: PPUSH
95836: LD_OWVAR 2
95840: PPUSH
95841: LD_INT 0
95843: PPUSH
95844: CALL_OW 324
95848: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
95849: LD_EXP 137
95853: PUSH
95854: LD_EXP 146
95858: AND
95859: IFFALSE 95961
95861: GO 95863
95863: DISABLE
95864: LD_INT 0
95866: PPUSH
95867: PPUSH
// begin enable ;
95868: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
95869: LD_ADDR_VAR 0 2
95873: PUSH
95874: LD_INT 22
95876: PUSH
95877: LD_OWVAR 2
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 2
95888: PUSH
95889: LD_INT 34
95891: PUSH
95892: LD_INT 11
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 34
95901: PUSH
95902: LD_INT 30
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: EMPTY
95910: LIST
95911: LIST
95912: LIST
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PPUSH
95918: CALL_OW 69
95922: ST_TO_ADDR
// if not tmp then
95923: LD_VAR 0 2
95927: NOT
95928: IFFALSE 95932
// exit ;
95930: GO 95961
// for i in tmp do
95932: LD_ADDR_VAR 0 1
95936: PUSH
95937: LD_VAR 0 2
95941: PUSH
95942: FOR_IN
95943: IFFALSE 95959
// begin SetLives ( i , 0 ) ;
95945: LD_VAR 0 1
95949: PPUSH
95950: LD_INT 0
95952: PPUSH
95953: CALL_OW 234
// end ;
95957: GO 95942
95959: POP
95960: POP
// end ;
95961: PPOPN 2
95963: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95964: LD_EXP 137
95968: PUSH
95969: LD_EXP 147
95973: AND
95974: IFFALSE 95994
95976: GO 95978
95978: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95979: LD_INT 32
95981: PPUSH
95982: LD_OWVAR 2
95986: PPUSH
95987: LD_INT 0
95989: PPUSH
95990: CALL_OW 324
95994: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
95995: LD_EXP 137
95999: PUSH
96000: LD_EXP 148
96004: AND
96005: IFFALSE 96186
96007: GO 96009
96009: DISABLE
96010: LD_INT 0
96012: PPUSH
96013: PPUSH
96014: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96015: LD_ADDR_VAR 0 2
96019: PUSH
96020: LD_INT 22
96022: PUSH
96023: LD_OWVAR 2
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: PUSH
96032: LD_INT 33
96034: PUSH
96035: LD_INT 3
96037: PUSH
96038: EMPTY
96039: LIST
96040: LIST
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: PPUSH
96046: CALL_OW 69
96050: ST_TO_ADDR
// if not tmp then
96051: LD_VAR 0 2
96055: NOT
96056: IFFALSE 96060
// exit ;
96058: GO 96186
// side := 0 ;
96060: LD_ADDR_VAR 0 3
96064: PUSH
96065: LD_INT 0
96067: ST_TO_ADDR
// for i := 1 to 8 do
96068: LD_ADDR_VAR 0 1
96072: PUSH
96073: DOUBLE
96074: LD_INT 1
96076: DEC
96077: ST_TO_ADDR
96078: LD_INT 8
96080: PUSH
96081: FOR_TO
96082: IFFALSE 96130
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96084: LD_OWVAR 2
96088: PUSH
96089: LD_VAR 0 1
96093: NONEQUAL
96094: PUSH
96095: LD_OWVAR 2
96099: PPUSH
96100: LD_VAR 0 1
96104: PPUSH
96105: CALL_OW 81
96109: PUSH
96110: LD_INT 2
96112: EQUAL
96113: AND
96114: IFFALSE 96128
// begin side := i ;
96116: LD_ADDR_VAR 0 3
96120: PUSH
96121: LD_VAR 0 1
96125: ST_TO_ADDR
// break ;
96126: GO 96130
// end ;
96128: GO 96081
96130: POP
96131: POP
// if not side then
96132: LD_VAR 0 3
96136: NOT
96137: IFFALSE 96141
// exit ;
96139: GO 96186
// for i := 1 to tmp do
96141: LD_ADDR_VAR 0 1
96145: PUSH
96146: DOUBLE
96147: LD_INT 1
96149: DEC
96150: ST_TO_ADDR
96151: LD_VAR 0 2
96155: PUSH
96156: FOR_TO
96157: IFFALSE 96184
// if Prob ( 60 ) then
96159: LD_INT 60
96161: PPUSH
96162: CALL_OW 13
96166: IFFALSE 96182
// SetSide ( i , side ) ;
96168: LD_VAR 0 1
96172: PPUSH
96173: LD_VAR 0 3
96177: PPUSH
96178: CALL_OW 235
96182: GO 96156
96184: POP
96185: POP
// end ;
96186: PPOPN 3
96188: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96189: LD_EXP 137
96193: PUSH
96194: LD_EXP 150
96198: AND
96199: IFFALSE 96318
96201: GO 96203
96203: DISABLE
96204: LD_INT 0
96206: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96207: LD_ADDR_VAR 0 1
96211: PUSH
96212: LD_INT 22
96214: PUSH
96215: LD_OWVAR 2
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: LD_INT 21
96226: PUSH
96227: LD_INT 1
96229: PUSH
96230: EMPTY
96231: LIST
96232: LIST
96233: PUSH
96234: LD_INT 3
96236: PUSH
96237: LD_INT 23
96239: PUSH
96240: LD_INT 0
96242: PUSH
96243: EMPTY
96244: LIST
96245: LIST
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: PUSH
96251: EMPTY
96252: LIST
96253: LIST
96254: LIST
96255: PPUSH
96256: CALL_OW 69
96260: PUSH
96261: FOR_IN
96262: IFFALSE 96316
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
96264: LD_VAR 0 1
96268: PPUSH
96269: CALL_OW 257
96273: PUSH
96274: LD_INT 1
96276: PUSH
96277: LD_INT 2
96279: PUSH
96280: LD_INT 3
96282: PUSH
96283: LD_INT 4
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: IN
96292: IFFALSE 96314
// SetClass ( un , rand ( 1 , 4 ) ) ;
96294: LD_VAR 0 1
96298: PPUSH
96299: LD_INT 1
96301: PPUSH
96302: LD_INT 4
96304: PPUSH
96305: CALL_OW 12
96309: PPUSH
96310: CALL_OW 336
96314: GO 96261
96316: POP
96317: POP
// end ;
96318: PPOPN 1
96320: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
96321: LD_EXP 137
96325: PUSH
96326: LD_EXP 149
96330: AND
96331: IFFALSE 96410
96333: GO 96335
96335: DISABLE
96336: LD_INT 0
96338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96339: LD_ADDR_VAR 0 1
96343: PUSH
96344: LD_INT 22
96346: PUSH
96347: LD_OWVAR 2
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: LD_INT 21
96358: PUSH
96359: LD_INT 3
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: PUSH
96366: EMPTY
96367: LIST
96368: LIST
96369: PPUSH
96370: CALL_OW 69
96374: ST_TO_ADDR
// if not tmp then
96375: LD_VAR 0 1
96379: NOT
96380: IFFALSE 96384
// exit ;
96382: GO 96410
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
96384: LD_VAR 0 1
96388: PUSH
96389: LD_INT 1
96391: PPUSH
96392: LD_VAR 0 1
96396: PPUSH
96397: CALL_OW 12
96401: ARRAY
96402: PPUSH
96403: LD_INT 100
96405: PPUSH
96406: CALL_OW 234
// end ;
96410: PPOPN 1
96412: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
96413: LD_EXP 137
96417: PUSH
96418: LD_EXP 151
96422: AND
96423: IFFALSE 96521
96425: GO 96427
96427: DISABLE
96428: LD_INT 0
96430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96431: LD_ADDR_VAR 0 1
96435: PUSH
96436: LD_INT 22
96438: PUSH
96439: LD_OWVAR 2
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 21
96450: PUSH
96451: LD_INT 1
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: PPUSH
96462: CALL_OW 69
96466: ST_TO_ADDR
// if not tmp then
96467: LD_VAR 0 1
96471: NOT
96472: IFFALSE 96476
// exit ;
96474: GO 96521
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
96476: LD_VAR 0 1
96480: PUSH
96481: LD_INT 1
96483: PPUSH
96484: LD_VAR 0 1
96488: PPUSH
96489: CALL_OW 12
96493: ARRAY
96494: PPUSH
96495: LD_INT 1
96497: PPUSH
96498: LD_INT 4
96500: PPUSH
96501: CALL_OW 12
96505: PPUSH
96506: LD_INT 3000
96508: PPUSH
96509: LD_INT 9000
96511: PPUSH
96512: CALL_OW 12
96516: PPUSH
96517: CALL_OW 492
// end ;
96521: PPOPN 1
96523: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96524: LD_EXP 137
96528: PUSH
96529: LD_EXP 152
96533: AND
96534: IFFALSE 96554
96536: GO 96538
96538: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96539: LD_INT 1
96541: PPUSH
96542: LD_OWVAR 2
96546: PPUSH
96547: LD_INT 0
96549: PPUSH
96550: CALL_OW 324
96554: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96555: LD_EXP 137
96559: PUSH
96560: LD_EXP 153
96564: AND
96565: IFFALSE 96648
96567: GO 96569
96569: DISABLE
96570: LD_INT 0
96572: PPUSH
96573: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96574: LD_ADDR_VAR 0 2
96578: PUSH
96579: LD_INT 22
96581: PUSH
96582: LD_OWVAR 2
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: PUSH
96591: LD_INT 21
96593: PUSH
96594: LD_INT 3
96596: PUSH
96597: EMPTY
96598: LIST
96599: LIST
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PPUSH
96605: CALL_OW 69
96609: ST_TO_ADDR
// if not tmp then
96610: LD_VAR 0 2
96614: NOT
96615: IFFALSE 96619
// exit ;
96617: GO 96648
// for i in tmp do
96619: LD_ADDR_VAR 0 1
96623: PUSH
96624: LD_VAR 0 2
96628: PUSH
96629: FOR_IN
96630: IFFALSE 96646
// SetBLevel ( i , 10 ) ;
96632: LD_VAR 0 1
96636: PPUSH
96637: LD_INT 10
96639: PPUSH
96640: CALL_OW 241
96644: GO 96629
96646: POP
96647: POP
// end ;
96648: PPOPN 2
96650: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96651: LD_EXP 137
96655: PUSH
96656: LD_EXP 154
96660: AND
96661: IFFALSE 96772
96663: GO 96665
96665: DISABLE
96666: LD_INT 0
96668: PPUSH
96669: PPUSH
96670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96671: LD_ADDR_VAR 0 3
96675: PUSH
96676: LD_INT 22
96678: PUSH
96679: LD_OWVAR 2
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PUSH
96688: LD_INT 25
96690: PUSH
96691: LD_INT 1
96693: PUSH
96694: EMPTY
96695: LIST
96696: LIST
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PPUSH
96702: CALL_OW 69
96706: ST_TO_ADDR
// if not tmp then
96707: LD_VAR 0 3
96711: NOT
96712: IFFALSE 96716
// exit ;
96714: GO 96772
// un := tmp [ rand ( 1 , tmp ) ] ;
96716: LD_ADDR_VAR 0 2
96720: PUSH
96721: LD_VAR 0 3
96725: PUSH
96726: LD_INT 1
96728: PPUSH
96729: LD_VAR 0 3
96733: PPUSH
96734: CALL_OW 12
96738: ARRAY
96739: ST_TO_ADDR
// if Crawls ( un ) then
96740: LD_VAR 0 2
96744: PPUSH
96745: CALL_OW 318
96749: IFFALSE 96760
// ComWalk ( un ) ;
96751: LD_VAR 0 2
96755: PPUSH
96756: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96760: LD_VAR 0 2
96764: PPUSH
96765: LD_INT 5
96767: PPUSH
96768: CALL_OW 336
// end ;
96772: PPOPN 3
96774: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
96775: LD_EXP 137
96779: PUSH
96780: LD_EXP 155
96784: AND
96785: PUSH
96786: LD_OWVAR 67
96790: PUSH
96791: LD_INT 3
96793: LESS
96794: AND
96795: IFFALSE 96814
96797: GO 96799
96799: DISABLE
// Difficulty := Difficulty + 1 ;
96800: LD_ADDR_OWVAR 67
96804: PUSH
96805: LD_OWVAR 67
96809: PUSH
96810: LD_INT 1
96812: PLUS
96813: ST_TO_ADDR
96814: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
96815: LD_EXP 137
96819: PUSH
96820: LD_EXP 156
96824: AND
96825: IFFALSE 96928
96827: GO 96829
96829: DISABLE
96830: LD_INT 0
96832: PPUSH
// begin for i := 1 to 5 do
96833: LD_ADDR_VAR 0 1
96837: PUSH
96838: DOUBLE
96839: LD_INT 1
96841: DEC
96842: ST_TO_ADDR
96843: LD_INT 5
96845: PUSH
96846: FOR_TO
96847: IFFALSE 96926
// begin uc_nation := nation_nature ;
96849: LD_ADDR_OWVAR 21
96853: PUSH
96854: LD_INT 0
96856: ST_TO_ADDR
// uc_side := 0 ;
96857: LD_ADDR_OWVAR 20
96861: PUSH
96862: LD_INT 0
96864: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96865: LD_ADDR_OWVAR 29
96869: PUSH
96870: LD_INT 12
96872: PUSH
96873: LD_INT 12
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: ST_TO_ADDR
// hc_agressivity := 20 ;
96880: LD_ADDR_OWVAR 35
96884: PUSH
96885: LD_INT 20
96887: ST_TO_ADDR
// hc_class := class_tiger ;
96888: LD_ADDR_OWVAR 28
96892: PUSH
96893: LD_INT 14
96895: ST_TO_ADDR
// hc_gallery :=  ;
96896: LD_ADDR_OWVAR 33
96900: PUSH
96901: LD_STRING 
96903: ST_TO_ADDR
// hc_name :=  ;
96904: LD_ADDR_OWVAR 26
96908: PUSH
96909: LD_STRING 
96911: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
96912: CALL_OW 44
96916: PPUSH
96917: LD_INT 0
96919: PPUSH
96920: CALL_OW 51
// end ;
96924: GO 96846
96926: POP
96927: POP
// end ;
96928: PPOPN 1
96930: END
// every 0 0$1 trigger StreamModeActive and sBomb do
96931: LD_EXP 137
96935: PUSH
96936: LD_EXP 157
96940: AND
96941: IFFALSE 96950
96943: GO 96945
96945: DISABLE
// StreamSibBomb ;
96946: CALL 96951 0 0
96950: END
// export function StreamSibBomb ; var i , x , y ; begin
96951: LD_INT 0
96953: PPUSH
96954: PPUSH
96955: PPUSH
96956: PPUSH
// result := false ;
96957: LD_ADDR_VAR 0 1
96961: PUSH
96962: LD_INT 0
96964: ST_TO_ADDR
// for i := 1 to 16 do
96965: LD_ADDR_VAR 0 2
96969: PUSH
96970: DOUBLE
96971: LD_INT 1
96973: DEC
96974: ST_TO_ADDR
96975: LD_INT 16
96977: PUSH
96978: FOR_TO
96979: IFFALSE 97178
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96981: LD_ADDR_VAR 0 3
96985: PUSH
96986: LD_INT 10
96988: PUSH
96989: LD_INT 20
96991: PUSH
96992: LD_INT 30
96994: PUSH
96995: LD_INT 40
96997: PUSH
96998: LD_INT 50
97000: PUSH
97001: LD_INT 60
97003: PUSH
97004: LD_INT 70
97006: PUSH
97007: LD_INT 80
97009: PUSH
97010: LD_INT 90
97012: PUSH
97013: LD_INT 100
97015: PUSH
97016: LD_INT 110
97018: PUSH
97019: LD_INT 120
97021: PUSH
97022: LD_INT 130
97024: PUSH
97025: LD_INT 140
97027: PUSH
97028: LD_INT 150
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: PUSH
97048: LD_INT 1
97050: PPUSH
97051: LD_INT 15
97053: PPUSH
97054: CALL_OW 12
97058: ARRAY
97059: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97060: LD_ADDR_VAR 0 4
97064: PUSH
97065: LD_INT 10
97067: PUSH
97068: LD_INT 20
97070: PUSH
97071: LD_INT 30
97073: PUSH
97074: LD_INT 40
97076: PUSH
97077: LD_INT 50
97079: PUSH
97080: LD_INT 60
97082: PUSH
97083: LD_INT 70
97085: PUSH
97086: LD_INT 80
97088: PUSH
97089: LD_INT 90
97091: PUSH
97092: LD_INT 100
97094: PUSH
97095: LD_INT 110
97097: PUSH
97098: LD_INT 120
97100: PUSH
97101: LD_INT 130
97103: PUSH
97104: LD_INT 140
97106: PUSH
97107: LD_INT 150
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: PUSH
97127: LD_INT 1
97129: PPUSH
97130: LD_INT 15
97132: PPUSH
97133: CALL_OW 12
97137: ARRAY
97138: ST_TO_ADDR
// if ValidHex ( x , y ) then
97139: LD_VAR 0 3
97143: PPUSH
97144: LD_VAR 0 4
97148: PPUSH
97149: CALL_OW 488
97153: IFFALSE 97176
// begin result := [ x , y ] ;
97155: LD_ADDR_VAR 0 1
97159: PUSH
97160: LD_VAR 0 3
97164: PUSH
97165: LD_VAR 0 4
97169: PUSH
97170: EMPTY
97171: LIST
97172: LIST
97173: ST_TO_ADDR
// break ;
97174: GO 97178
// end ; end ;
97176: GO 96978
97178: POP
97179: POP
// if result then
97180: LD_VAR 0 1
97184: IFFALSE 97244
// begin ToLua ( playSibBomb() ) ;
97186: LD_STRING playSibBomb()
97188: PPUSH
97189: CALL_OW 559
// wait ( 0 0$14 ) ;
97193: LD_INT 490
97195: PPUSH
97196: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97200: LD_VAR 0 1
97204: PUSH
97205: LD_INT 1
97207: ARRAY
97208: PPUSH
97209: LD_VAR 0 1
97213: PUSH
97214: LD_INT 2
97216: ARRAY
97217: PPUSH
97218: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97222: LD_VAR 0 1
97226: PUSH
97227: LD_INT 1
97229: ARRAY
97230: PPUSH
97231: LD_VAR 0 1
97235: PUSH
97236: LD_INT 2
97238: ARRAY
97239: PPUSH
97240: CALL_OW 429
// end ; end ;
97244: LD_VAR 0 1
97248: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97249: LD_EXP 137
97253: PUSH
97254: LD_EXP 159
97258: AND
97259: IFFALSE 97271
97261: GO 97263
97263: DISABLE
// YouLost (  ) ;
97264: LD_STRING 
97266: PPUSH
97267: CALL_OW 104
97271: END
// every 0 0$1 trigger StreamModeActive and sFog do
97272: LD_EXP 137
97276: PUSH
97277: LD_EXP 158
97281: AND
97282: IFFALSE 97296
97284: GO 97286
97286: DISABLE
// FogOff ( your_side ) ;
97287: LD_OWVAR 2
97291: PPUSH
97292: CALL_OW 344
97296: END
// every 0 0$1 trigger StreamModeActive and sSun do
97297: LD_EXP 137
97301: PUSH
97302: LD_EXP 160
97306: AND
97307: IFFALSE 97335
97309: GO 97311
97311: DISABLE
// begin solar_recharge_percent := 0 ;
97312: LD_ADDR_OWVAR 79
97316: PUSH
97317: LD_INT 0
97319: ST_TO_ADDR
// wait ( 5 5$00 ) ;
97320: LD_INT 10500
97322: PPUSH
97323: CALL_OW 67
// solar_recharge_percent := 100 ;
97327: LD_ADDR_OWVAR 79
97331: PUSH
97332: LD_INT 100
97334: ST_TO_ADDR
// end ;
97335: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
97336: LD_EXP 137
97340: PUSH
97341: LD_EXP 161
97345: AND
97346: IFFALSE 97585
97348: GO 97350
97350: DISABLE
97351: LD_INT 0
97353: PPUSH
97354: PPUSH
97355: PPUSH
// begin tmp := [ ] ;
97356: LD_ADDR_VAR 0 3
97360: PUSH
97361: EMPTY
97362: ST_TO_ADDR
// for i := 1 to 6 do
97363: LD_ADDR_VAR 0 1
97367: PUSH
97368: DOUBLE
97369: LD_INT 1
97371: DEC
97372: ST_TO_ADDR
97373: LD_INT 6
97375: PUSH
97376: FOR_TO
97377: IFFALSE 97482
// begin uc_nation := nation_nature ;
97379: LD_ADDR_OWVAR 21
97383: PUSH
97384: LD_INT 0
97386: ST_TO_ADDR
// uc_side := 0 ;
97387: LD_ADDR_OWVAR 20
97391: PUSH
97392: LD_INT 0
97394: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97395: LD_ADDR_OWVAR 29
97399: PUSH
97400: LD_INT 12
97402: PUSH
97403: LD_INT 12
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: ST_TO_ADDR
// hc_agressivity := 20 ;
97410: LD_ADDR_OWVAR 35
97414: PUSH
97415: LD_INT 20
97417: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
97418: LD_ADDR_OWVAR 28
97422: PUSH
97423: LD_INT 17
97425: ST_TO_ADDR
// hc_gallery :=  ;
97426: LD_ADDR_OWVAR 33
97430: PUSH
97431: LD_STRING 
97433: ST_TO_ADDR
// hc_name :=  ;
97434: LD_ADDR_OWVAR 26
97438: PUSH
97439: LD_STRING 
97441: ST_TO_ADDR
// un := CreateHuman ;
97442: LD_ADDR_VAR 0 2
97446: PUSH
97447: CALL_OW 44
97451: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
97452: LD_VAR 0 2
97456: PPUSH
97457: LD_INT 1
97459: PPUSH
97460: CALL_OW 51
// tmp := tmp ^ un ;
97464: LD_ADDR_VAR 0 3
97468: PUSH
97469: LD_VAR 0 3
97473: PUSH
97474: LD_VAR 0 2
97478: ADD
97479: ST_TO_ADDR
// end ;
97480: GO 97376
97482: POP
97483: POP
// repeat wait ( 0 0$1 ) ;
97484: LD_INT 35
97486: PPUSH
97487: CALL_OW 67
// for un in tmp do
97491: LD_ADDR_VAR 0 2
97495: PUSH
97496: LD_VAR 0 3
97500: PUSH
97501: FOR_IN
97502: IFFALSE 97576
// begin if IsDead ( un ) then
97504: LD_VAR 0 2
97508: PPUSH
97509: CALL_OW 301
97513: IFFALSE 97533
// begin tmp := tmp diff un ;
97515: LD_ADDR_VAR 0 3
97519: PUSH
97520: LD_VAR 0 3
97524: PUSH
97525: LD_VAR 0 2
97529: DIFF
97530: ST_TO_ADDR
// continue ;
97531: GO 97501
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97533: LD_VAR 0 2
97537: PPUSH
97538: LD_INT 3
97540: PUSH
97541: LD_INT 22
97543: PUSH
97544: LD_INT 0
97546: PUSH
97547: EMPTY
97548: LIST
97549: LIST
97550: PUSH
97551: EMPTY
97552: LIST
97553: LIST
97554: PPUSH
97555: CALL_OW 69
97559: PPUSH
97560: LD_VAR 0 2
97564: PPUSH
97565: CALL_OW 74
97569: PPUSH
97570: CALL_OW 115
// end ;
97574: GO 97501
97576: POP
97577: POP
// until not tmp ;
97578: LD_VAR 0 3
97582: NOT
97583: IFFALSE 97484
// end ;
97585: PPOPN 3
97587: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97588: LD_EXP 137
97592: PUSH
97593: LD_EXP 162
97597: AND
97598: IFFALSE 97652
97600: GO 97602
97602: DISABLE
// begin ToLua ( displayTroll(); ) ;
97603: LD_STRING displayTroll();
97605: PPUSH
97606: CALL_OW 559
// wait ( 3 3$00 ) ;
97610: LD_INT 6300
97612: PPUSH
97613: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97617: LD_STRING hideTroll();
97619: PPUSH
97620: CALL_OW 559
// wait ( 1 1$00 ) ;
97624: LD_INT 2100
97626: PPUSH
97627: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97631: LD_STRING displayTroll();
97633: PPUSH
97634: CALL_OW 559
// wait ( 1 1$00 ) ;
97638: LD_INT 2100
97640: PPUSH
97641: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97645: LD_STRING hideTroll();
97647: PPUSH
97648: CALL_OW 559
// end ;
97652: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97653: LD_EXP 137
97657: PUSH
97658: LD_EXP 163
97662: AND
97663: IFFALSE 97726
97665: GO 97667
97667: DISABLE
97668: LD_INT 0
97670: PPUSH
// begin p := 0 ;
97671: LD_ADDR_VAR 0 1
97675: PUSH
97676: LD_INT 0
97678: ST_TO_ADDR
// repeat game_speed := 1 ;
97679: LD_ADDR_OWVAR 65
97683: PUSH
97684: LD_INT 1
97686: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97687: LD_INT 35
97689: PPUSH
97690: CALL_OW 67
// p := p + 1 ;
97694: LD_ADDR_VAR 0 1
97698: PUSH
97699: LD_VAR 0 1
97703: PUSH
97704: LD_INT 1
97706: PLUS
97707: ST_TO_ADDR
// until p >= 60 ;
97708: LD_VAR 0 1
97712: PUSH
97713: LD_INT 60
97715: GREATEREQUAL
97716: IFFALSE 97679
// game_speed := 4 ;
97718: LD_ADDR_OWVAR 65
97722: PUSH
97723: LD_INT 4
97725: ST_TO_ADDR
// end ;
97726: PPOPN 1
97728: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97729: LD_EXP 137
97733: PUSH
97734: LD_EXP 164
97738: AND
97739: IFFALSE 97885
97741: GO 97743
97743: DISABLE
97744: LD_INT 0
97746: PPUSH
97747: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97748: LD_ADDR_VAR 0 1
97752: PUSH
97753: LD_INT 22
97755: PUSH
97756: LD_OWVAR 2
97760: PUSH
97761: EMPTY
97762: LIST
97763: LIST
97764: PUSH
97765: LD_INT 2
97767: PUSH
97768: LD_INT 30
97770: PUSH
97771: LD_INT 0
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: PUSH
97778: LD_INT 30
97780: PUSH
97781: LD_INT 1
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: LIST
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PPUSH
97797: CALL_OW 69
97801: ST_TO_ADDR
// if not depot then
97802: LD_VAR 0 1
97806: NOT
97807: IFFALSE 97811
// exit ;
97809: GO 97885
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
97811: LD_ADDR_VAR 0 2
97815: PUSH
97816: LD_VAR 0 1
97820: PUSH
97821: LD_INT 1
97823: PPUSH
97824: LD_VAR 0 1
97828: PPUSH
97829: CALL_OW 12
97833: ARRAY
97834: PPUSH
97835: CALL_OW 274
97839: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
97840: LD_VAR 0 2
97844: PPUSH
97845: LD_INT 1
97847: PPUSH
97848: LD_INT 0
97850: PPUSH
97851: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
97855: LD_VAR 0 2
97859: PPUSH
97860: LD_INT 2
97862: PPUSH
97863: LD_INT 0
97865: PPUSH
97866: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
97870: LD_VAR 0 2
97874: PPUSH
97875: LD_INT 3
97877: PPUSH
97878: LD_INT 0
97880: PPUSH
97881: CALL_OW 277
// end ;
97885: PPOPN 2
97887: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
97888: LD_EXP 137
97892: PUSH
97893: LD_EXP 165
97897: AND
97898: IFFALSE 97995
97900: GO 97902
97902: DISABLE
97903: LD_INT 0
97905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97906: LD_ADDR_VAR 0 1
97910: PUSH
97911: LD_INT 22
97913: PUSH
97914: LD_OWVAR 2
97918: PUSH
97919: EMPTY
97920: LIST
97921: LIST
97922: PUSH
97923: LD_INT 21
97925: PUSH
97926: LD_INT 1
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: PUSH
97933: LD_INT 3
97935: PUSH
97936: LD_INT 23
97938: PUSH
97939: LD_INT 0
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: PUSH
97946: EMPTY
97947: LIST
97948: LIST
97949: PUSH
97950: EMPTY
97951: LIST
97952: LIST
97953: LIST
97954: PPUSH
97955: CALL_OW 69
97959: ST_TO_ADDR
// if not tmp then
97960: LD_VAR 0 1
97964: NOT
97965: IFFALSE 97969
// exit ;
97967: GO 97995
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
97969: LD_VAR 0 1
97973: PUSH
97974: LD_INT 1
97976: PPUSH
97977: LD_VAR 0 1
97981: PPUSH
97982: CALL_OW 12
97986: ARRAY
97987: PPUSH
97988: LD_INT 200
97990: PPUSH
97991: CALL_OW 234
// end ;
97995: PPOPN 1
97997: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
97998: LD_EXP 137
98002: PUSH
98003: LD_EXP 166
98007: AND
98008: IFFALSE 98087
98010: GO 98012
98012: DISABLE
98013: LD_INT 0
98015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98016: LD_ADDR_VAR 0 1
98020: PUSH
98021: LD_INT 22
98023: PUSH
98024: LD_OWVAR 2
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PUSH
98033: LD_INT 21
98035: PUSH
98036: LD_INT 2
98038: PUSH
98039: EMPTY
98040: LIST
98041: LIST
98042: PUSH
98043: EMPTY
98044: LIST
98045: LIST
98046: PPUSH
98047: CALL_OW 69
98051: ST_TO_ADDR
// if not tmp then
98052: LD_VAR 0 1
98056: NOT
98057: IFFALSE 98061
// exit ;
98059: GO 98087
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98061: LD_VAR 0 1
98065: PUSH
98066: LD_INT 1
98068: PPUSH
98069: LD_VAR 0 1
98073: PPUSH
98074: CALL_OW 12
98078: ARRAY
98079: PPUSH
98080: LD_INT 60
98082: PPUSH
98083: CALL_OW 234
// end ;
98087: PPOPN 1
98089: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98090: LD_EXP 137
98094: PUSH
98095: LD_EXP 167
98099: AND
98100: IFFALSE 98199
98102: GO 98104
98104: DISABLE
98105: LD_INT 0
98107: PPUSH
98108: PPUSH
// begin enable ;
98109: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98110: LD_ADDR_VAR 0 1
98114: PUSH
98115: LD_INT 22
98117: PUSH
98118: LD_OWVAR 2
98122: PUSH
98123: EMPTY
98124: LIST
98125: LIST
98126: PUSH
98127: LD_INT 61
98129: PUSH
98130: EMPTY
98131: LIST
98132: PUSH
98133: LD_INT 33
98135: PUSH
98136: LD_INT 2
98138: PUSH
98139: EMPTY
98140: LIST
98141: LIST
98142: PUSH
98143: EMPTY
98144: LIST
98145: LIST
98146: LIST
98147: PPUSH
98148: CALL_OW 69
98152: ST_TO_ADDR
// if not tmp then
98153: LD_VAR 0 1
98157: NOT
98158: IFFALSE 98162
// exit ;
98160: GO 98199
// for i in tmp do
98162: LD_ADDR_VAR 0 2
98166: PUSH
98167: LD_VAR 0 1
98171: PUSH
98172: FOR_IN
98173: IFFALSE 98197
// if IsControledBy ( i ) then
98175: LD_VAR 0 2
98179: PPUSH
98180: CALL_OW 312
98184: IFFALSE 98195
// ComUnlink ( i ) ;
98186: LD_VAR 0 2
98190: PPUSH
98191: CALL_OW 136
98195: GO 98172
98197: POP
98198: POP
// end ;
98199: PPOPN 2
98201: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98202: LD_EXP 137
98206: PUSH
98207: LD_EXP 168
98211: AND
98212: IFFALSE 98352
98214: GO 98216
98216: DISABLE
98217: LD_INT 0
98219: PPUSH
98220: PPUSH
// begin ToLua ( displayPowell(); ) ;
98221: LD_STRING displayPowell();
98223: PPUSH
98224: CALL_OW 559
// uc_side := 0 ;
98228: LD_ADDR_OWVAR 20
98232: PUSH
98233: LD_INT 0
98235: ST_TO_ADDR
// uc_nation := 2 ;
98236: LD_ADDR_OWVAR 21
98240: PUSH
98241: LD_INT 2
98243: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98244: LD_ADDR_OWVAR 37
98248: PUSH
98249: LD_INT 14
98251: ST_TO_ADDR
// vc_engine := engine_siberite ;
98252: LD_ADDR_OWVAR 39
98256: PUSH
98257: LD_INT 3
98259: ST_TO_ADDR
// vc_control := control_apeman ;
98260: LD_ADDR_OWVAR 38
98264: PUSH
98265: LD_INT 5
98267: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
98268: LD_ADDR_OWVAR 40
98272: PUSH
98273: LD_INT 29
98275: ST_TO_ADDR
// un := CreateVehicle ;
98276: LD_ADDR_VAR 0 2
98280: PUSH
98281: CALL_OW 45
98285: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98286: LD_VAR 0 2
98290: PPUSH
98291: LD_INT 1
98293: PPUSH
98294: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98298: LD_INT 35
98300: PPUSH
98301: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98305: LD_VAR 0 2
98309: PPUSH
98310: LD_INT 22
98312: PUSH
98313: LD_OWVAR 2
98317: PUSH
98318: EMPTY
98319: LIST
98320: LIST
98321: PPUSH
98322: CALL_OW 69
98326: PPUSH
98327: LD_VAR 0 2
98331: PPUSH
98332: CALL_OW 74
98336: PPUSH
98337: CALL_OW 115
// until IsDead ( un ) ;
98341: LD_VAR 0 2
98345: PPUSH
98346: CALL_OW 301
98350: IFFALSE 98298
// end ;
98352: PPOPN 2
98354: END
// every 0 0$1 trigger StreamModeActive and sStu do
98355: LD_EXP 137
98359: PUSH
98360: LD_EXP 176
98364: AND
98365: IFFALSE 98381
98367: GO 98369
98369: DISABLE
// begin ToLua ( displayStucuk(); ) ;
98370: LD_STRING displayStucuk();
98372: PPUSH
98373: CALL_OW 559
// ResetFog ;
98377: CALL_OW 335
// end ;
98381: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
98382: LD_EXP 137
98386: PUSH
98387: LD_EXP 169
98391: AND
98392: IFFALSE 98533
98394: GO 98396
98396: DISABLE
98397: LD_INT 0
98399: PPUSH
98400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98401: LD_ADDR_VAR 0 2
98405: PUSH
98406: LD_INT 22
98408: PUSH
98409: LD_OWVAR 2
98413: PUSH
98414: EMPTY
98415: LIST
98416: LIST
98417: PUSH
98418: LD_INT 21
98420: PUSH
98421: LD_INT 1
98423: PUSH
98424: EMPTY
98425: LIST
98426: LIST
98427: PUSH
98428: EMPTY
98429: LIST
98430: LIST
98431: PPUSH
98432: CALL_OW 69
98436: ST_TO_ADDR
// if not tmp then
98437: LD_VAR 0 2
98441: NOT
98442: IFFALSE 98446
// exit ;
98444: GO 98533
// un := tmp [ rand ( 1 , tmp ) ] ;
98446: LD_ADDR_VAR 0 1
98450: PUSH
98451: LD_VAR 0 2
98455: PUSH
98456: LD_INT 1
98458: PPUSH
98459: LD_VAR 0 2
98463: PPUSH
98464: CALL_OW 12
98468: ARRAY
98469: ST_TO_ADDR
// SetSide ( un , 0 ) ;
98470: LD_VAR 0 1
98474: PPUSH
98475: LD_INT 0
98477: PPUSH
98478: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
98482: LD_VAR 0 1
98486: PPUSH
98487: LD_OWVAR 3
98491: PUSH
98492: LD_VAR 0 1
98496: DIFF
98497: PPUSH
98498: LD_VAR 0 1
98502: PPUSH
98503: CALL_OW 74
98507: PPUSH
98508: CALL_OW 115
// wait ( 0 0$20 ) ;
98512: LD_INT 700
98514: PPUSH
98515: CALL_OW 67
// SetSide ( un , your_side ) ;
98519: LD_VAR 0 1
98523: PPUSH
98524: LD_OWVAR 2
98528: PPUSH
98529: CALL_OW 235
// end ;
98533: PPOPN 2
98535: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98536: LD_EXP 137
98540: PUSH
98541: LD_EXP 170
98545: AND
98546: IFFALSE 98652
98548: GO 98550
98550: DISABLE
98551: LD_INT 0
98553: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98554: LD_ADDR_VAR 0 1
98558: PUSH
98559: LD_INT 22
98561: PUSH
98562: LD_OWVAR 2
98566: PUSH
98567: EMPTY
98568: LIST
98569: LIST
98570: PUSH
98571: LD_INT 2
98573: PUSH
98574: LD_INT 30
98576: PUSH
98577: LD_INT 0
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: PUSH
98584: LD_INT 30
98586: PUSH
98587: LD_INT 1
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: LIST
98598: PUSH
98599: EMPTY
98600: LIST
98601: LIST
98602: PPUSH
98603: CALL_OW 69
98607: ST_TO_ADDR
// if not depot then
98608: LD_VAR 0 1
98612: NOT
98613: IFFALSE 98617
// exit ;
98615: GO 98652
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98617: LD_VAR 0 1
98621: PUSH
98622: LD_INT 1
98624: ARRAY
98625: PPUSH
98626: CALL_OW 250
98630: PPUSH
98631: LD_VAR 0 1
98635: PUSH
98636: LD_INT 1
98638: ARRAY
98639: PPUSH
98640: CALL_OW 251
98644: PPUSH
98645: LD_INT 70
98647: PPUSH
98648: CALL_OW 495
// end ;
98652: PPOPN 1
98654: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98655: LD_EXP 137
98659: PUSH
98660: LD_EXP 171
98664: AND
98665: IFFALSE 98876
98667: GO 98669
98669: DISABLE
98670: LD_INT 0
98672: PPUSH
98673: PPUSH
98674: PPUSH
98675: PPUSH
98676: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98677: LD_ADDR_VAR 0 5
98681: PUSH
98682: LD_INT 22
98684: PUSH
98685: LD_OWVAR 2
98689: PUSH
98690: EMPTY
98691: LIST
98692: LIST
98693: PUSH
98694: LD_INT 21
98696: PUSH
98697: LD_INT 1
98699: PUSH
98700: EMPTY
98701: LIST
98702: LIST
98703: PUSH
98704: EMPTY
98705: LIST
98706: LIST
98707: PPUSH
98708: CALL_OW 69
98712: ST_TO_ADDR
// if not tmp then
98713: LD_VAR 0 5
98717: NOT
98718: IFFALSE 98722
// exit ;
98720: GO 98876
// for i in tmp do
98722: LD_ADDR_VAR 0 1
98726: PUSH
98727: LD_VAR 0 5
98731: PUSH
98732: FOR_IN
98733: IFFALSE 98874
// begin d := rand ( 0 , 5 ) ;
98735: LD_ADDR_VAR 0 4
98739: PUSH
98740: LD_INT 0
98742: PPUSH
98743: LD_INT 5
98745: PPUSH
98746: CALL_OW 12
98750: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98751: LD_ADDR_VAR 0 2
98755: PUSH
98756: LD_VAR 0 1
98760: PPUSH
98761: CALL_OW 250
98765: PPUSH
98766: LD_VAR 0 4
98770: PPUSH
98771: LD_INT 3
98773: PPUSH
98774: LD_INT 12
98776: PPUSH
98777: CALL_OW 12
98781: PPUSH
98782: CALL_OW 272
98786: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
98787: LD_ADDR_VAR 0 3
98791: PUSH
98792: LD_VAR 0 1
98796: PPUSH
98797: CALL_OW 251
98801: PPUSH
98802: LD_VAR 0 4
98806: PPUSH
98807: LD_INT 3
98809: PPUSH
98810: LD_INT 12
98812: PPUSH
98813: CALL_OW 12
98817: PPUSH
98818: CALL_OW 273
98822: ST_TO_ADDR
// if ValidHex ( x , y ) then
98823: LD_VAR 0 2
98827: PPUSH
98828: LD_VAR 0 3
98832: PPUSH
98833: CALL_OW 488
98837: IFFALSE 98872
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
98839: LD_VAR 0 1
98843: PPUSH
98844: LD_VAR 0 2
98848: PPUSH
98849: LD_VAR 0 3
98853: PPUSH
98854: LD_INT 3
98856: PPUSH
98857: LD_INT 6
98859: PPUSH
98860: CALL_OW 12
98864: PPUSH
98865: LD_INT 1
98867: PPUSH
98868: CALL_OW 483
// end ;
98872: GO 98732
98874: POP
98875: POP
// end ;
98876: PPOPN 5
98878: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
98879: LD_EXP 137
98883: PUSH
98884: LD_EXP 172
98888: AND
98889: IFFALSE 98983
98891: GO 98893
98893: DISABLE
98894: LD_INT 0
98896: PPUSH
98897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
98898: LD_ADDR_VAR 0 2
98902: PUSH
98903: LD_INT 22
98905: PUSH
98906: LD_OWVAR 2
98910: PUSH
98911: EMPTY
98912: LIST
98913: LIST
98914: PUSH
98915: LD_INT 32
98917: PUSH
98918: LD_INT 1
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: LD_INT 21
98927: PUSH
98928: LD_INT 2
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: EMPTY
98936: LIST
98937: LIST
98938: LIST
98939: PPUSH
98940: CALL_OW 69
98944: ST_TO_ADDR
// if not tmp then
98945: LD_VAR 0 2
98949: NOT
98950: IFFALSE 98954
// exit ;
98952: GO 98983
// for i in tmp do
98954: LD_ADDR_VAR 0 1
98958: PUSH
98959: LD_VAR 0 2
98963: PUSH
98964: FOR_IN
98965: IFFALSE 98981
// SetFuel ( i , 0 ) ;
98967: LD_VAR 0 1
98971: PPUSH
98972: LD_INT 0
98974: PPUSH
98975: CALL_OW 240
98979: GO 98964
98981: POP
98982: POP
// end ;
98983: PPOPN 2
98985: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
98986: LD_EXP 137
98990: PUSH
98991: LD_EXP 173
98995: AND
98996: IFFALSE 99062
98998: GO 99000
99000: DISABLE
99001: LD_INT 0
99003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99004: LD_ADDR_VAR 0 1
99008: PUSH
99009: LD_INT 22
99011: PUSH
99012: LD_OWVAR 2
99016: PUSH
99017: EMPTY
99018: LIST
99019: LIST
99020: PUSH
99021: LD_INT 30
99023: PUSH
99024: LD_INT 29
99026: PUSH
99027: EMPTY
99028: LIST
99029: LIST
99030: PUSH
99031: EMPTY
99032: LIST
99033: LIST
99034: PPUSH
99035: CALL_OW 69
99039: ST_TO_ADDR
// if not tmp then
99040: LD_VAR 0 1
99044: NOT
99045: IFFALSE 99049
// exit ;
99047: GO 99062
// DestroyUnit ( tmp [ 1 ] ) ;
99049: LD_VAR 0 1
99053: PUSH
99054: LD_INT 1
99056: ARRAY
99057: PPUSH
99058: CALL_OW 65
// end ;
99062: PPOPN 1
99064: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99065: LD_EXP 137
99069: PUSH
99070: LD_EXP 175
99074: AND
99075: IFFALSE 99204
99077: GO 99079
99079: DISABLE
99080: LD_INT 0
99082: PPUSH
// begin uc_side := 0 ;
99083: LD_ADDR_OWVAR 20
99087: PUSH
99088: LD_INT 0
99090: ST_TO_ADDR
// uc_nation := nation_arabian ;
99091: LD_ADDR_OWVAR 21
99095: PUSH
99096: LD_INT 2
99098: ST_TO_ADDR
// hc_gallery :=  ;
99099: LD_ADDR_OWVAR 33
99103: PUSH
99104: LD_STRING 
99106: ST_TO_ADDR
// hc_name :=  ;
99107: LD_ADDR_OWVAR 26
99111: PUSH
99112: LD_STRING 
99114: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99115: LD_INT 1
99117: PPUSH
99118: LD_INT 11
99120: PPUSH
99121: LD_INT 10
99123: PPUSH
99124: CALL_OW 380
// un := CreateHuman ;
99128: LD_ADDR_VAR 0 1
99132: PUSH
99133: CALL_OW 44
99137: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99138: LD_VAR 0 1
99142: PPUSH
99143: LD_INT 1
99145: PPUSH
99146: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99150: LD_INT 35
99152: PPUSH
99153: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99157: LD_VAR 0 1
99161: PPUSH
99162: LD_INT 22
99164: PUSH
99165: LD_OWVAR 2
99169: PUSH
99170: EMPTY
99171: LIST
99172: LIST
99173: PPUSH
99174: CALL_OW 69
99178: PPUSH
99179: LD_VAR 0 1
99183: PPUSH
99184: CALL_OW 74
99188: PPUSH
99189: CALL_OW 115
// until IsDead ( un ) ;
99193: LD_VAR 0 1
99197: PPUSH
99198: CALL_OW 301
99202: IFFALSE 99150
// end ;
99204: PPOPN 1
99206: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99207: LD_EXP 137
99211: PUSH
99212: LD_EXP 177
99216: AND
99217: IFFALSE 99229
99219: GO 99221
99221: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99222: LD_STRING earthquake(getX(game), 0, 32)
99224: PPUSH
99225: CALL_OW 559
99229: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99230: LD_EXP 137
99234: PUSH
99235: LD_EXP 178
99239: AND
99240: IFFALSE 99331
99242: GO 99244
99244: DISABLE
99245: LD_INT 0
99247: PPUSH
// begin enable ;
99248: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99249: LD_ADDR_VAR 0 1
99253: PUSH
99254: LD_INT 22
99256: PUSH
99257: LD_OWVAR 2
99261: PUSH
99262: EMPTY
99263: LIST
99264: LIST
99265: PUSH
99266: LD_INT 21
99268: PUSH
99269: LD_INT 2
99271: PUSH
99272: EMPTY
99273: LIST
99274: LIST
99275: PUSH
99276: LD_INT 33
99278: PUSH
99279: LD_INT 3
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: PUSH
99286: EMPTY
99287: LIST
99288: LIST
99289: LIST
99290: PPUSH
99291: CALL_OW 69
99295: ST_TO_ADDR
// if not tmp then
99296: LD_VAR 0 1
99300: NOT
99301: IFFALSE 99305
// exit ;
99303: GO 99331
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99305: LD_VAR 0 1
99309: PUSH
99310: LD_INT 1
99312: PPUSH
99313: LD_VAR 0 1
99317: PPUSH
99318: CALL_OW 12
99322: ARRAY
99323: PPUSH
99324: LD_INT 1
99326: PPUSH
99327: CALL_OW 234
// end ;
99331: PPOPN 1
99333: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
99334: LD_EXP 137
99338: PUSH
99339: LD_EXP 179
99343: AND
99344: IFFALSE 99485
99346: GO 99348
99348: DISABLE
99349: LD_INT 0
99351: PPUSH
99352: PPUSH
99353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99354: LD_ADDR_VAR 0 3
99358: PUSH
99359: LD_INT 22
99361: PUSH
99362: LD_OWVAR 2
99366: PUSH
99367: EMPTY
99368: LIST
99369: LIST
99370: PUSH
99371: LD_INT 25
99373: PUSH
99374: LD_INT 1
99376: PUSH
99377: EMPTY
99378: LIST
99379: LIST
99380: PUSH
99381: EMPTY
99382: LIST
99383: LIST
99384: PPUSH
99385: CALL_OW 69
99389: ST_TO_ADDR
// if not tmp then
99390: LD_VAR 0 3
99394: NOT
99395: IFFALSE 99399
// exit ;
99397: GO 99485
// un := tmp [ rand ( 1 , tmp ) ] ;
99399: LD_ADDR_VAR 0 2
99403: PUSH
99404: LD_VAR 0 3
99408: PUSH
99409: LD_INT 1
99411: PPUSH
99412: LD_VAR 0 3
99416: PPUSH
99417: CALL_OW 12
99421: ARRAY
99422: ST_TO_ADDR
// if Crawls ( un ) then
99423: LD_VAR 0 2
99427: PPUSH
99428: CALL_OW 318
99432: IFFALSE 99443
// ComWalk ( un ) ;
99434: LD_VAR 0 2
99438: PPUSH
99439: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
99443: LD_VAR 0 2
99447: PPUSH
99448: LD_INT 9
99450: PPUSH
99451: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
99455: LD_INT 28
99457: PPUSH
99458: LD_OWVAR 2
99462: PPUSH
99463: LD_INT 2
99465: PPUSH
99466: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
99470: LD_INT 29
99472: PPUSH
99473: LD_OWVAR 2
99477: PPUSH
99478: LD_INT 2
99480: PPUSH
99481: CALL_OW 322
// end ;
99485: PPOPN 3
99487: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
99488: LD_EXP 137
99492: PUSH
99493: LD_EXP 180
99497: AND
99498: IFFALSE 99609
99500: GO 99502
99502: DISABLE
99503: LD_INT 0
99505: PPUSH
99506: PPUSH
99507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99508: LD_ADDR_VAR 0 3
99512: PUSH
99513: LD_INT 22
99515: PUSH
99516: LD_OWVAR 2
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: PUSH
99525: LD_INT 25
99527: PUSH
99528: LD_INT 1
99530: PUSH
99531: EMPTY
99532: LIST
99533: LIST
99534: PUSH
99535: EMPTY
99536: LIST
99537: LIST
99538: PPUSH
99539: CALL_OW 69
99543: ST_TO_ADDR
// if not tmp then
99544: LD_VAR 0 3
99548: NOT
99549: IFFALSE 99553
// exit ;
99551: GO 99609
// un := tmp [ rand ( 1 , tmp ) ] ;
99553: LD_ADDR_VAR 0 2
99557: PUSH
99558: LD_VAR 0 3
99562: PUSH
99563: LD_INT 1
99565: PPUSH
99566: LD_VAR 0 3
99570: PPUSH
99571: CALL_OW 12
99575: ARRAY
99576: ST_TO_ADDR
// if Crawls ( un ) then
99577: LD_VAR 0 2
99581: PPUSH
99582: CALL_OW 318
99586: IFFALSE 99597
// ComWalk ( un ) ;
99588: LD_VAR 0 2
99592: PPUSH
99593: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99597: LD_VAR 0 2
99601: PPUSH
99602: LD_INT 8
99604: PPUSH
99605: CALL_OW 336
// end ;
99609: PPOPN 3
99611: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99612: LD_EXP 137
99616: PUSH
99617: LD_EXP 181
99621: AND
99622: IFFALSE 99766
99624: GO 99626
99626: DISABLE
99627: LD_INT 0
99629: PPUSH
99630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99631: LD_ADDR_VAR 0 2
99635: PUSH
99636: LD_INT 22
99638: PUSH
99639: LD_OWVAR 2
99643: PUSH
99644: EMPTY
99645: LIST
99646: LIST
99647: PUSH
99648: LD_INT 21
99650: PUSH
99651: LD_INT 2
99653: PUSH
99654: EMPTY
99655: LIST
99656: LIST
99657: PUSH
99658: LD_INT 2
99660: PUSH
99661: LD_INT 34
99663: PUSH
99664: LD_INT 12
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: PUSH
99671: LD_INT 34
99673: PUSH
99674: LD_INT 51
99676: PUSH
99677: EMPTY
99678: LIST
99679: LIST
99680: PUSH
99681: LD_INT 34
99683: PUSH
99684: LD_INT 32
99686: PUSH
99687: EMPTY
99688: LIST
99689: LIST
99690: PUSH
99691: EMPTY
99692: LIST
99693: LIST
99694: LIST
99695: LIST
99696: PUSH
99697: EMPTY
99698: LIST
99699: LIST
99700: LIST
99701: PPUSH
99702: CALL_OW 69
99706: ST_TO_ADDR
// if not tmp then
99707: LD_VAR 0 2
99711: NOT
99712: IFFALSE 99716
// exit ;
99714: GO 99766
// for i in tmp do
99716: LD_ADDR_VAR 0 1
99720: PUSH
99721: LD_VAR 0 2
99725: PUSH
99726: FOR_IN
99727: IFFALSE 99764
// if GetCargo ( i , mat_artifact ) = 0 then
99729: LD_VAR 0 1
99733: PPUSH
99734: LD_INT 4
99736: PPUSH
99737: CALL_OW 289
99741: PUSH
99742: LD_INT 0
99744: EQUAL
99745: IFFALSE 99762
// SetCargo ( i , mat_siberit , 100 ) ;
99747: LD_VAR 0 1
99751: PPUSH
99752: LD_INT 3
99754: PPUSH
99755: LD_INT 100
99757: PPUSH
99758: CALL_OW 290
99762: GO 99726
99764: POP
99765: POP
// end ;
99766: PPOPN 2
99768: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
99769: LD_EXP 137
99773: PUSH
99774: LD_EXP 182
99778: AND
99779: IFFALSE 99962
99781: GO 99783
99783: DISABLE
99784: LD_INT 0
99786: PPUSH
99787: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99788: LD_ADDR_VAR 0 2
99792: PUSH
99793: LD_INT 22
99795: PUSH
99796: LD_OWVAR 2
99800: PUSH
99801: EMPTY
99802: LIST
99803: LIST
99804: PPUSH
99805: CALL_OW 69
99809: ST_TO_ADDR
// if not tmp then
99810: LD_VAR 0 2
99814: NOT
99815: IFFALSE 99819
// exit ;
99817: GO 99962
// for i := 1 to 2 do
99819: LD_ADDR_VAR 0 1
99823: PUSH
99824: DOUBLE
99825: LD_INT 1
99827: DEC
99828: ST_TO_ADDR
99829: LD_INT 2
99831: PUSH
99832: FOR_TO
99833: IFFALSE 99960
// begin uc_side := your_side ;
99835: LD_ADDR_OWVAR 20
99839: PUSH
99840: LD_OWVAR 2
99844: ST_TO_ADDR
// uc_nation := nation_american ;
99845: LD_ADDR_OWVAR 21
99849: PUSH
99850: LD_INT 1
99852: ST_TO_ADDR
// vc_chassis := us_morphling ;
99853: LD_ADDR_OWVAR 37
99857: PUSH
99858: LD_INT 5
99860: ST_TO_ADDR
// vc_engine := engine_siberite ;
99861: LD_ADDR_OWVAR 39
99865: PUSH
99866: LD_INT 3
99868: ST_TO_ADDR
// vc_control := control_computer ;
99869: LD_ADDR_OWVAR 38
99873: PUSH
99874: LD_INT 3
99876: ST_TO_ADDR
// vc_weapon := us_double_laser ;
99877: LD_ADDR_OWVAR 40
99881: PUSH
99882: LD_INT 10
99884: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
99885: LD_VAR 0 2
99889: PUSH
99890: LD_INT 1
99892: ARRAY
99893: PPUSH
99894: CALL_OW 310
99898: NOT
99899: IFFALSE 99946
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
99901: CALL_OW 45
99905: PPUSH
99906: LD_VAR 0 2
99910: PUSH
99911: LD_INT 1
99913: ARRAY
99914: PPUSH
99915: CALL_OW 250
99919: PPUSH
99920: LD_VAR 0 2
99924: PUSH
99925: LD_INT 1
99927: ARRAY
99928: PPUSH
99929: CALL_OW 251
99933: PPUSH
99934: LD_INT 12
99936: PPUSH
99937: LD_INT 1
99939: PPUSH
99940: CALL_OW 50
99944: GO 99958
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99946: CALL_OW 45
99950: PPUSH
99951: LD_INT 1
99953: PPUSH
99954: CALL_OW 51
// end ;
99958: GO 99832
99960: POP
99961: POP
// end ;
99962: PPOPN 2
99964: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
99965: LD_EXP 137
99969: PUSH
99970: LD_EXP 183
99974: AND
99975: IFFALSE 100197
99977: GO 99979
99979: DISABLE
99980: LD_INT 0
99982: PPUSH
99983: PPUSH
99984: PPUSH
99985: PPUSH
99986: PPUSH
99987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99988: LD_ADDR_VAR 0 6
99992: PUSH
99993: LD_INT 22
99995: PUSH
99996: LD_OWVAR 2
100000: PUSH
100001: EMPTY
100002: LIST
100003: LIST
100004: PUSH
100005: LD_INT 21
100007: PUSH
100008: LD_INT 1
100010: PUSH
100011: EMPTY
100012: LIST
100013: LIST
100014: PUSH
100015: LD_INT 3
100017: PUSH
100018: LD_INT 23
100020: PUSH
100021: LD_INT 0
100023: PUSH
100024: EMPTY
100025: LIST
100026: LIST
100027: PUSH
100028: EMPTY
100029: LIST
100030: LIST
100031: PUSH
100032: EMPTY
100033: LIST
100034: LIST
100035: LIST
100036: PPUSH
100037: CALL_OW 69
100041: ST_TO_ADDR
// if not tmp then
100042: LD_VAR 0 6
100046: NOT
100047: IFFALSE 100051
// exit ;
100049: GO 100197
// s1 := rand ( 1 , 4 ) ;
100051: LD_ADDR_VAR 0 2
100055: PUSH
100056: LD_INT 1
100058: PPUSH
100059: LD_INT 4
100061: PPUSH
100062: CALL_OW 12
100066: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100067: LD_ADDR_VAR 0 4
100071: PUSH
100072: LD_VAR 0 6
100076: PUSH
100077: LD_INT 1
100079: ARRAY
100080: PPUSH
100081: LD_VAR 0 2
100085: PPUSH
100086: CALL_OW 259
100090: ST_TO_ADDR
// if s1 = 1 then
100091: LD_VAR 0 2
100095: PUSH
100096: LD_INT 1
100098: EQUAL
100099: IFFALSE 100119
// s2 := rand ( 2 , 4 ) else
100101: LD_ADDR_VAR 0 3
100105: PUSH
100106: LD_INT 2
100108: PPUSH
100109: LD_INT 4
100111: PPUSH
100112: CALL_OW 12
100116: ST_TO_ADDR
100117: GO 100127
// s2 := 1 ;
100119: LD_ADDR_VAR 0 3
100123: PUSH
100124: LD_INT 1
100126: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100127: LD_ADDR_VAR 0 5
100131: PUSH
100132: LD_VAR 0 6
100136: PUSH
100137: LD_INT 1
100139: ARRAY
100140: PPUSH
100141: LD_VAR 0 3
100145: PPUSH
100146: CALL_OW 259
100150: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100151: LD_VAR 0 6
100155: PUSH
100156: LD_INT 1
100158: ARRAY
100159: PPUSH
100160: LD_VAR 0 2
100164: PPUSH
100165: LD_VAR 0 5
100169: PPUSH
100170: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100174: LD_VAR 0 6
100178: PUSH
100179: LD_INT 1
100181: ARRAY
100182: PPUSH
100183: LD_VAR 0 3
100187: PPUSH
100188: LD_VAR 0 4
100192: PPUSH
100193: CALL_OW 237
// end ;
100197: PPOPN 6
100199: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100200: LD_EXP 137
100204: PUSH
100205: LD_EXP 184
100209: AND
100210: IFFALSE 100289
100212: GO 100214
100214: DISABLE
100215: LD_INT 0
100217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100218: LD_ADDR_VAR 0 1
100222: PUSH
100223: LD_INT 22
100225: PUSH
100226: LD_OWVAR 2
100230: PUSH
100231: EMPTY
100232: LIST
100233: LIST
100234: PUSH
100235: LD_INT 30
100237: PUSH
100238: LD_INT 3
100240: PUSH
100241: EMPTY
100242: LIST
100243: LIST
100244: PUSH
100245: EMPTY
100246: LIST
100247: LIST
100248: PPUSH
100249: CALL_OW 69
100253: ST_TO_ADDR
// if not tmp then
100254: LD_VAR 0 1
100258: NOT
100259: IFFALSE 100263
// exit ;
100261: GO 100289
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100263: LD_VAR 0 1
100267: PUSH
100268: LD_INT 1
100270: PPUSH
100271: LD_VAR 0 1
100275: PPUSH
100276: CALL_OW 12
100280: ARRAY
100281: PPUSH
100282: LD_INT 1
100284: PPUSH
100285: CALL_OW 234
// end ;
100289: PPOPN 1
100291: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
100292: LD_EXP 137
100296: PUSH
100297: LD_EXP 185
100301: AND
100302: IFFALSE 100414
100304: GO 100306
100306: DISABLE
100307: LD_INT 0
100309: PPUSH
100310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
100311: LD_ADDR_VAR 0 2
100315: PUSH
100316: LD_INT 22
100318: PUSH
100319: LD_OWVAR 2
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PUSH
100328: LD_INT 2
100330: PUSH
100331: LD_INT 30
100333: PUSH
100334: LD_INT 27
100336: PUSH
100337: EMPTY
100338: LIST
100339: LIST
100340: PUSH
100341: LD_INT 30
100343: PUSH
100344: LD_INT 26
100346: PUSH
100347: EMPTY
100348: LIST
100349: LIST
100350: PUSH
100351: LD_INT 30
100353: PUSH
100354: LD_INT 28
100356: PUSH
100357: EMPTY
100358: LIST
100359: LIST
100360: PUSH
100361: EMPTY
100362: LIST
100363: LIST
100364: LIST
100365: LIST
100366: PUSH
100367: EMPTY
100368: LIST
100369: LIST
100370: PPUSH
100371: CALL_OW 69
100375: ST_TO_ADDR
// if not tmp then
100376: LD_VAR 0 2
100380: NOT
100381: IFFALSE 100385
// exit ;
100383: GO 100414
// for i in tmp do
100385: LD_ADDR_VAR 0 1
100389: PUSH
100390: LD_VAR 0 2
100394: PUSH
100395: FOR_IN
100396: IFFALSE 100412
// SetLives ( i , 1 ) ;
100398: LD_VAR 0 1
100402: PPUSH
100403: LD_INT 1
100405: PPUSH
100406: CALL_OW 234
100410: GO 100395
100412: POP
100413: POP
// end ;
100414: PPOPN 2
100416: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
100417: LD_EXP 137
100421: PUSH
100422: LD_EXP 186
100426: AND
100427: IFFALSE 100701
100429: GO 100431
100431: DISABLE
100432: LD_INT 0
100434: PPUSH
100435: PPUSH
100436: PPUSH
// begin i := rand ( 1 , 7 ) ;
100437: LD_ADDR_VAR 0 1
100441: PUSH
100442: LD_INT 1
100444: PPUSH
100445: LD_INT 7
100447: PPUSH
100448: CALL_OW 12
100452: ST_TO_ADDR
// case i of 1 :
100453: LD_VAR 0 1
100457: PUSH
100458: LD_INT 1
100460: DOUBLE
100461: EQUAL
100462: IFTRUE 100466
100464: GO 100476
100466: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
100467: LD_STRING earthquake(getX(game), 0, 32)
100469: PPUSH
100470: CALL_OW 559
100474: GO 100701
100476: LD_INT 2
100478: DOUBLE
100479: EQUAL
100480: IFTRUE 100484
100482: GO 100498
100484: POP
// begin ToLua ( displayStucuk(); ) ;
100485: LD_STRING displayStucuk();
100487: PPUSH
100488: CALL_OW 559
// ResetFog ;
100492: CALL_OW 335
// end ; 3 :
100496: GO 100701
100498: LD_INT 3
100500: DOUBLE
100501: EQUAL
100502: IFTRUE 100506
100504: GO 100610
100506: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100507: LD_ADDR_VAR 0 2
100511: PUSH
100512: LD_INT 22
100514: PUSH
100515: LD_OWVAR 2
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: PUSH
100524: LD_INT 25
100526: PUSH
100527: LD_INT 1
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: PUSH
100534: EMPTY
100535: LIST
100536: LIST
100537: PPUSH
100538: CALL_OW 69
100542: ST_TO_ADDR
// if not tmp then
100543: LD_VAR 0 2
100547: NOT
100548: IFFALSE 100552
// exit ;
100550: GO 100701
// un := tmp [ rand ( 1 , tmp ) ] ;
100552: LD_ADDR_VAR 0 3
100556: PUSH
100557: LD_VAR 0 2
100561: PUSH
100562: LD_INT 1
100564: PPUSH
100565: LD_VAR 0 2
100569: PPUSH
100570: CALL_OW 12
100574: ARRAY
100575: ST_TO_ADDR
// if Crawls ( un ) then
100576: LD_VAR 0 3
100580: PPUSH
100581: CALL_OW 318
100585: IFFALSE 100596
// ComWalk ( un ) ;
100587: LD_VAR 0 3
100591: PPUSH
100592: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100596: LD_VAR 0 3
100600: PPUSH
100601: LD_INT 8
100603: PPUSH
100604: CALL_OW 336
// end ; 4 :
100608: GO 100701
100610: LD_INT 4
100612: DOUBLE
100613: EQUAL
100614: IFTRUE 100618
100616: GO 100679
100618: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100619: LD_ADDR_VAR 0 2
100623: PUSH
100624: LD_INT 22
100626: PUSH
100627: LD_OWVAR 2
100631: PUSH
100632: EMPTY
100633: LIST
100634: LIST
100635: PUSH
100636: LD_INT 30
100638: PUSH
100639: LD_INT 29
100641: PUSH
100642: EMPTY
100643: LIST
100644: LIST
100645: PUSH
100646: EMPTY
100647: LIST
100648: LIST
100649: PPUSH
100650: CALL_OW 69
100654: ST_TO_ADDR
// if not tmp then
100655: LD_VAR 0 2
100659: NOT
100660: IFFALSE 100664
// exit ;
100662: GO 100701
// DestroyUnit ( tmp [ 1 ] ) ;
100664: LD_VAR 0 2
100668: PUSH
100669: LD_INT 1
100671: ARRAY
100672: PPUSH
100673: CALL_OW 65
// end ; 5 .. 7 :
100677: GO 100701
100679: LD_INT 5
100681: DOUBLE
100682: GREATEREQUAL
100683: IFFALSE 100691
100685: LD_INT 7
100687: DOUBLE
100688: LESSEQUAL
100689: IFTRUE 100693
100691: GO 100700
100693: POP
// StreamSibBomb ; end ;
100694: CALL 96951 0 0
100698: GO 100701
100700: POP
// end ;
100701: PPOPN 3
100703: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100704: LD_EXP 137
100708: PUSH
100709: LD_EXP 187
100713: AND
100714: IFFALSE 100870
100716: GO 100718
100718: DISABLE
100719: LD_INT 0
100721: PPUSH
100722: PPUSH
100723: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100724: LD_ADDR_VAR 0 2
100728: PUSH
100729: LD_INT 81
100731: PUSH
100732: LD_OWVAR 2
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PUSH
100741: LD_INT 2
100743: PUSH
100744: LD_INT 21
100746: PUSH
100747: LD_INT 1
100749: PUSH
100750: EMPTY
100751: LIST
100752: LIST
100753: PUSH
100754: LD_INT 21
100756: PUSH
100757: LD_INT 2
100759: PUSH
100760: EMPTY
100761: LIST
100762: LIST
100763: PUSH
100764: EMPTY
100765: LIST
100766: LIST
100767: LIST
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PPUSH
100773: CALL_OW 69
100777: ST_TO_ADDR
// if not tmp then
100778: LD_VAR 0 2
100782: NOT
100783: IFFALSE 100787
// exit ;
100785: GO 100870
// p := 0 ;
100787: LD_ADDR_VAR 0 3
100791: PUSH
100792: LD_INT 0
100794: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100795: LD_INT 35
100797: PPUSH
100798: CALL_OW 67
// p := p + 1 ;
100802: LD_ADDR_VAR 0 3
100806: PUSH
100807: LD_VAR 0 3
100811: PUSH
100812: LD_INT 1
100814: PLUS
100815: ST_TO_ADDR
// for i in tmp do
100816: LD_ADDR_VAR 0 1
100820: PUSH
100821: LD_VAR 0 2
100825: PUSH
100826: FOR_IN
100827: IFFALSE 100858
// if GetLives ( i ) < 1000 then
100829: LD_VAR 0 1
100833: PPUSH
100834: CALL_OW 256
100838: PUSH
100839: LD_INT 1000
100841: LESS
100842: IFFALSE 100856
// SetLives ( i , 1000 ) ;
100844: LD_VAR 0 1
100848: PPUSH
100849: LD_INT 1000
100851: PPUSH
100852: CALL_OW 234
100856: GO 100826
100858: POP
100859: POP
// until p > 20 ;
100860: LD_VAR 0 3
100864: PUSH
100865: LD_INT 20
100867: GREATER
100868: IFFALSE 100795
// end ;
100870: PPOPN 3
100872: END
// every 0 0$1 trigger StreamModeActive and sTime do
100873: LD_EXP 137
100877: PUSH
100878: LD_EXP 188
100882: AND
100883: IFFALSE 100918
100885: GO 100887
100887: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
100888: LD_INT 28
100890: PPUSH
100891: LD_OWVAR 2
100895: PPUSH
100896: LD_INT 2
100898: PPUSH
100899: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
100903: LD_INT 30
100905: PPUSH
100906: LD_OWVAR 2
100910: PPUSH
100911: LD_INT 2
100913: PPUSH
100914: CALL_OW 322
// end ;
100918: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
100919: LD_EXP 137
100923: PUSH
100924: LD_EXP 189
100928: AND
100929: IFFALSE 101050
100931: GO 100933
100933: DISABLE
100934: LD_INT 0
100936: PPUSH
100937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100938: LD_ADDR_VAR 0 2
100942: PUSH
100943: LD_INT 22
100945: PUSH
100946: LD_OWVAR 2
100950: PUSH
100951: EMPTY
100952: LIST
100953: LIST
100954: PUSH
100955: LD_INT 21
100957: PUSH
100958: LD_INT 1
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: PUSH
100965: LD_INT 3
100967: PUSH
100968: LD_INT 23
100970: PUSH
100971: LD_INT 0
100973: PUSH
100974: EMPTY
100975: LIST
100976: LIST
100977: PUSH
100978: EMPTY
100979: LIST
100980: LIST
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: LIST
100986: PPUSH
100987: CALL_OW 69
100991: ST_TO_ADDR
// if not tmp then
100992: LD_VAR 0 2
100996: NOT
100997: IFFALSE 101001
// exit ;
100999: GO 101050
// for i in tmp do
101001: LD_ADDR_VAR 0 1
101005: PUSH
101006: LD_VAR 0 2
101010: PUSH
101011: FOR_IN
101012: IFFALSE 101048
// begin if Crawls ( i ) then
101014: LD_VAR 0 1
101018: PPUSH
101019: CALL_OW 318
101023: IFFALSE 101034
// ComWalk ( i ) ;
101025: LD_VAR 0 1
101029: PPUSH
101030: CALL_OW 138
// SetClass ( i , 2 ) ;
101034: LD_VAR 0 1
101038: PPUSH
101039: LD_INT 2
101041: PPUSH
101042: CALL_OW 336
// end ;
101046: GO 101011
101048: POP
101049: POP
// end ;
101050: PPOPN 2
101052: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101053: LD_EXP 137
101057: PUSH
101058: LD_EXP 190
101062: AND
101063: IFFALSE 101344
101065: GO 101067
101067: DISABLE
101068: LD_INT 0
101070: PPUSH
101071: PPUSH
101072: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101073: LD_OWVAR 2
101077: PPUSH
101078: LD_INT 9
101080: PPUSH
101081: LD_INT 1
101083: PPUSH
101084: LD_INT 1
101086: PPUSH
101087: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101091: LD_INT 9
101093: PPUSH
101094: LD_OWVAR 2
101098: PPUSH
101099: CALL_OW 343
// uc_side := 9 ;
101103: LD_ADDR_OWVAR 20
101107: PUSH
101108: LD_INT 9
101110: ST_TO_ADDR
// uc_nation := 2 ;
101111: LD_ADDR_OWVAR 21
101115: PUSH
101116: LD_INT 2
101118: ST_TO_ADDR
// hc_name := Dark Warrior ;
101119: LD_ADDR_OWVAR 26
101123: PUSH
101124: LD_STRING Dark Warrior
101126: ST_TO_ADDR
// hc_gallery :=  ;
101127: LD_ADDR_OWVAR 33
101131: PUSH
101132: LD_STRING 
101134: ST_TO_ADDR
// hc_noskilllimit := true ;
101135: LD_ADDR_OWVAR 76
101139: PUSH
101140: LD_INT 1
101142: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101143: LD_ADDR_OWVAR 31
101147: PUSH
101148: LD_INT 30
101150: PUSH
101151: LD_INT 30
101153: PUSH
101154: LD_INT 30
101156: PUSH
101157: LD_INT 30
101159: PUSH
101160: EMPTY
101161: LIST
101162: LIST
101163: LIST
101164: LIST
101165: ST_TO_ADDR
// un := CreateHuman ;
101166: LD_ADDR_VAR 0 3
101170: PUSH
101171: CALL_OW 44
101175: ST_TO_ADDR
// hc_noskilllimit := false ;
101176: LD_ADDR_OWVAR 76
101180: PUSH
101181: LD_INT 0
101183: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101184: LD_VAR 0 3
101188: PPUSH
101189: LD_INT 1
101191: PPUSH
101192: CALL_OW 51
// p := 0 ;
101196: LD_ADDR_VAR 0 2
101200: PUSH
101201: LD_INT 0
101203: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101204: LD_INT 35
101206: PPUSH
101207: CALL_OW 67
// p := p + 1 ;
101211: LD_ADDR_VAR 0 2
101215: PUSH
101216: LD_VAR 0 2
101220: PUSH
101221: LD_INT 1
101223: PLUS
101224: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101225: LD_VAR 0 3
101229: PPUSH
101230: CALL_OW 256
101234: PUSH
101235: LD_INT 1000
101237: LESS
101238: IFFALSE 101252
// SetLives ( un , 1000 ) ;
101240: LD_VAR 0 3
101244: PPUSH
101245: LD_INT 1000
101247: PPUSH
101248: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
101252: LD_VAR 0 3
101256: PPUSH
101257: LD_INT 81
101259: PUSH
101260: LD_OWVAR 2
101264: PUSH
101265: EMPTY
101266: LIST
101267: LIST
101268: PUSH
101269: LD_INT 91
101271: PUSH
101272: LD_VAR 0 3
101276: PUSH
101277: LD_INT 30
101279: PUSH
101280: EMPTY
101281: LIST
101282: LIST
101283: LIST
101284: PUSH
101285: EMPTY
101286: LIST
101287: LIST
101288: PPUSH
101289: CALL_OW 69
101293: PPUSH
101294: LD_VAR 0 3
101298: PPUSH
101299: CALL_OW 74
101303: PPUSH
101304: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
101308: LD_VAR 0 2
101312: PUSH
101313: LD_INT 60
101315: GREATER
101316: PUSH
101317: LD_VAR 0 3
101321: PPUSH
101322: CALL_OW 301
101326: OR
101327: IFFALSE 101204
// if un then
101329: LD_VAR 0 3
101333: IFFALSE 101344
// RemoveUnit ( un ) ;
101335: LD_VAR 0 3
101339: PPUSH
101340: CALL_OW 64
// end ;
101344: PPOPN 3
101346: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
101347: LD_INT 0
101349: PPUSH
// case cmd of 301 :
101350: LD_VAR 0 1
101354: PUSH
101355: LD_INT 301
101357: DOUBLE
101358: EQUAL
101359: IFTRUE 101363
101361: GO 101395
101363: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
101364: LD_VAR 0 6
101368: PPUSH
101369: LD_VAR 0 7
101373: PPUSH
101374: LD_VAR 0 8
101378: PPUSH
101379: LD_VAR 0 4
101383: PPUSH
101384: LD_VAR 0 5
101388: PPUSH
101389: CALL 102596 0 5
101393: GO 101516
101395: LD_INT 302
101397: DOUBLE
101398: EQUAL
101399: IFTRUE 101403
101401: GO 101440
101403: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
101404: LD_VAR 0 6
101408: PPUSH
101409: LD_VAR 0 7
101413: PPUSH
101414: LD_VAR 0 8
101418: PPUSH
101419: LD_VAR 0 9
101423: PPUSH
101424: LD_VAR 0 4
101428: PPUSH
101429: LD_VAR 0 5
101433: PPUSH
101434: CALL 102687 0 6
101438: GO 101516
101440: LD_INT 303
101442: DOUBLE
101443: EQUAL
101444: IFTRUE 101448
101446: GO 101485
101448: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
101449: LD_VAR 0 6
101453: PPUSH
101454: LD_VAR 0 7
101458: PPUSH
101459: LD_VAR 0 8
101463: PPUSH
101464: LD_VAR 0 9
101468: PPUSH
101469: LD_VAR 0 4
101473: PPUSH
101474: LD_VAR 0 5
101478: PPUSH
101479: CALL 101521 0 6
101483: GO 101516
101485: LD_INT 304
101487: DOUBLE
101488: EQUAL
101489: IFTRUE 101493
101491: GO 101515
101493: POP
// hHackTeleport ( unit , x , y ) ; end ;
101494: LD_VAR 0 2
101498: PPUSH
101499: LD_VAR 0 4
101503: PPUSH
101504: LD_VAR 0 5
101508: PPUSH
101509: CALL 103280 0 3
101513: GO 101516
101515: POP
// end ;
101516: LD_VAR 0 12
101520: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
101521: LD_INT 0
101523: PPUSH
101524: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
101525: LD_VAR 0 1
101529: PUSH
101530: LD_INT 1
101532: LESS
101533: PUSH
101534: LD_VAR 0 1
101538: PUSH
101539: LD_INT 3
101541: GREATER
101542: OR
101543: PUSH
101544: LD_VAR 0 5
101548: PPUSH
101549: LD_VAR 0 6
101553: PPUSH
101554: CALL_OW 428
101558: OR
101559: IFFALSE 101563
// exit ;
101561: GO 102283
// uc_side := your_side ;
101563: LD_ADDR_OWVAR 20
101567: PUSH
101568: LD_OWVAR 2
101572: ST_TO_ADDR
// uc_nation := nation ;
101573: LD_ADDR_OWVAR 21
101577: PUSH
101578: LD_VAR 0 1
101582: ST_TO_ADDR
// bc_level = 1 ;
101583: LD_ADDR_OWVAR 43
101587: PUSH
101588: LD_INT 1
101590: ST_TO_ADDR
// case btype of 1 :
101591: LD_VAR 0 2
101595: PUSH
101596: LD_INT 1
101598: DOUBLE
101599: EQUAL
101600: IFTRUE 101604
101602: GO 101615
101604: POP
// bc_type := b_depot ; 2 :
101605: LD_ADDR_OWVAR 42
101609: PUSH
101610: LD_INT 0
101612: ST_TO_ADDR
101613: GO 102227
101615: LD_INT 2
101617: DOUBLE
101618: EQUAL
101619: IFTRUE 101623
101621: GO 101634
101623: POP
// bc_type := b_warehouse ; 3 :
101624: LD_ADDR_OWVAR 42
101628: PUSH
101629: LD_INT 1
101631: ST_TO_ADDR
101632: GO 102227
101634: LD_INT 3
101636: DOUBLE
101637: EQUAL
101638: IFTRUE 101642
101640: GO 101653
101642: POP
// bc_type := b_lab ; 4 .. 9 :
101643: LD_ADDR_OWVAR 42
101647: PUSH
101648: LD_INT 6
101650: ST_TO_ADDR
101651: GO 102227
101653: LD_INT 4
101655: DOUBLE
101656: GREATEREQUAL
101657: IFFALSE 101665
101659: LD_INT 9
101661: DOUBLE
101662: LESSEQUAL
101663: IFTRUE 101667
101665: GO 101719
101667: POP
// begin bc_type := b_lab_half ;
101668: LD_ADDR_OWVAR 42
101672: PUSH
101673: LD_INT 7
101675: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
101676: LD_ADDR_OWVAR 44
101680: PUSH
101681: LD_INT 10
101683: PUSH
101684: LD_INT 11
101686: PUSH
101687: LD_INT 12
101689: PUSH
101690: LD_INT 15
101692: PUSH
101693: LD_INT 14
101695: PUSH
101696: LD_INT 13
101698: PUSH
101699: EMPTY
101700: LIST
101701: LIST
101702: LIST
101703: LIST
101704: LIST
101705: LIST
101706: PUSH
101707: LD_VAR 0 2
101711: PUSH
101712: LD_INT 3
101714: MINUS
101715: ARRAY
101716: ST_TO_ADDR
// end ; 10 .. 13 :
101717: GO 102227
101719: LD_INT 10
101721: DOUBLE
101722: GREATEREQUAL
101723: IFFALSE 101731
101725: LD_INT 13
101727: DOUBLE
101728: LESSEQUAL
101729: IFTRUE 101733
101731: GO 101810
101733: POP
// begin bc_type := b_lab_full ;
101734: LD_ADDR_OWVAR 42
101738: PUSH
101739: LD_INT 8
101741: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101742: LD_ADDR_OWVAR 44
101746: PUSH
101747: LD_INT 10
101749: PUSH
101750: LD_INT 12
101752: PUSH
101753: LD_INT 14
101755: PUSH
101756: LD_INT 13
101758: PUSH
101759: EMPTY
101760: LIST
101761: LIST
101762: LIST
101763: LIST
101764: PUSH
101765: LD_VAR 0 2
101769: PUSH
101770: LD_INT 9
101772: MINUS
101773: ARRAY
101774: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101775: LD_ADDR_OWVAR 45
101779: PUSH
101780: LD_INT 11
101782: PUSH
101783: LD_INT 15
101785: PUSH
101786: LD_INT 12
101788: PUSH
101789: LD_INT 15
101791: PUSH
101792: EMPTY
101793: LIST
101794: LIST
101795: LIST
101796: LIST
101797: PUSH
101798: LD_VAR 0 2
101802: PUSH
101803: LD_INT 9
101805: MINUS
101806: ARRAY
101807: ST_TO_ADDR
// end ; 14 :
101808: GO 102227
101810: LD_INT 14
101812: DOUBLE
101813: EQUAL
101814: IFTRUE 101818
101816: GO 101829
101818: POP
// bc_type := b_workshop ; 15 :
101819: LD_ADDR_OWVAR 42
101823: PUSH
101824: LD_INT 2
101826: ST_TO_ADDR
101827: GO 102227
101829: LD_INT 15
101831: DOUBLE
101832: EQUAL
101833: IFTRUE 101837
101835: GO 101848
101837: POP
// bc_type := b_factory ; 16 :
101838: LD_ADDR_OWVAR 42
101842: PUSH
101843: LD_INT 3
101845: ST_TO_ADDR
101846: GO 102227
101848: LD_INT 16
101850: DOUBLE
101851: EQUAL
101852: IFTRUE 101856
101854: GO 101867
101856: POP
// bc_type := b_ext_gun ; 17 :
101857: LD_ADDR_OWVAR 42
101861: PUSH
101862: LD_INT 17
101864: ST_TO_ADDR
101865: GO 102227
101867: LD_INT 17
101869: DOUBLE
101870: EQUAL
101871: IFTRUE 101875
101873: GO 101903
101875: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
101876: LD_ADDR_OWVAR 42
101880: PUSH
101881: LD_INT 19
101883: PUSH
101884: LD_INT 23
101886: PUSH
101887: LD_INT 19
101889: PUSH
101890: EMPTY
101891: LIST
101892: LIST
101893: LIST
101894: PUSH
101895: LD_VAR 0 1
101899: ARRAY
101900: ST_TO_ADDR
101901: GO 102227
101903: LD_INT 18
101905: DOUBLE
101906: EQUAL
101907: IFTRUE 101911
101909: GO 101922
101911: POP
// bc_type := b_ext_radar ; 19 :
101912: LD_ADDR_OWVAR 42
101916: PUSH
101917: LD_INT 20
101919: ST_TO_ADDR
101920: GO 102227
101922: LD_INT 19
101924: DOUBLE
101925: EQUAL
101926: IFTRUE 101930
101928: GO 101941
101930: POP
// bc_type := b_ext_radio ; 20 :
101931: LD_ADDR_OWVAR 42
101935: PUSH
101936: LD_INT 22
101938: ST_TO_ADDR
101939: GO 102227
101941: LD_INT 20
101943: DOUBLE
101944: EQUAL
101945: IFTRUE 101949
101947: GO 101960
101949: POP
// bc_type := b_ext_siberium ; 21 :
101950: LD_ADDR_OWVAR 42
101954: PUSH
101955: LD_INT 21
101957: ST_TO_ADDR
101958: GO 102227
101960: LD_INT 21
101962: DOUBLE
101963: EQUAL
101964: IFTRUE 101968
101966: GO 101979
101968: POP
// bc_type := b_ext_computer ; 22 :
101969: LD_ADDR_OWVAR 42
101973: PUSH
101974: LD_INT 24
101976: ST_TO_ADDR
101977: GO 102227
101979: LD_INT 22
101981: DOUBLE
101982: EQUAL
101983: IFTRUE 101987
101985: GO 101998
101987: POP
// bc_type := b_ext_track ; 23 :
101988: LD_ADDR_OWVAR 42
101992: PUSH
101993: LD_INT 16
101995: ST_TO_ADDR
101996: GO 102227
101998: LD_INT 23
102000: DOUBLE
102001: EQUAL
102002: IFTRUE 102006
102004: GO 102017
102006: POP
// bc_type := b_ext_laser ; 24 :
102007: LD_ADDR_OWVAR 42
102011: PUSH
102012: LD_INT 25
102014: ST_TO_ADDR
102015: GO 102227
102017: LD_INT 24
102019: DOUBLE
102020: EQUAL
102021: IFTRUE 102025
102023: GO 102036
102025: POP
// bc_type := b_control_tower ; 25 :
102026: LD_ADDR_OWVAR 42
102030: PUSH
102031: LD_INT 36
102033: ST_TO_ADDR
102034: GO 102227
102036: LD_INT 25
102038: DOUBLE
102039: EQUAL
102040: IFTRUE 102044
102042: GO 102055
102044: POP
// bc_type := b_breastwork ; 26 :
102045: LD_ADDR_OWVAR 42
102049: PUSH
102050: LD_INT 31
102052: ST_TO_ADDR
102053: GO 102227
102055: LD_INT 26
102057: DOUBLE
102058: EQUAL
102059: IFTRUE 102063
102061: GO 102074
102063: POP
// bc_type := b_bunker ; 27 :
102064: LD_ADDR_OWVAR 42
102068: PUSH
102069: LD_INT 32
102071: ST_TO_ADDR
102072: GO 102227
102074: LD_INT 27
102076: DOUBLE
102077: EQUAL
102078: IFTRUE 102082
102080: GO 102093
102082: POP
// bc_type := b_turret ; 28 :
102083: LD_ADDR_OWVAR 42
102087: PUSH
102088: LD_INT 33
102090: ST_TO_ADDR
102091: GO 102227
102093: LD_INT 28
102095: DOUBLE
102096: EQUAL
102097: IFTRUE 102101
102099: GO 102112
102101: POP
// bc_type := b_armoury ; 29 :
102102: LD_ADDR_OWVAR 42
102106: PUSH
102107: LD_INT 4
102109: ST_TO_ADDR
102110: GO 102227
102112: LD_INT 29
102114: DOUBLE
102115: EQUAL
102116: IFTRUE 102120
102118: GO 102131
102120: POP
// bc_type := b_barracks ; 30 :
102121: LD_ADDR_OWVAR 42
102125: PUSH
102126: LD_INT 5
102128: ST_TO_ADDR
102129: GO 102227
102131: LD_INT 30
102133: DOUBLE
102134: EQUAL
102135: IFTRUE 102139
102137: GO 102150
102139: POP
// bc_type := b_solar_power ; 31 :
102140: LD_ADDR_OWVAR 42
102144: PUSH
102145: LD_INT 27
102147: ST_TO_ADDR
102148: GO 102227
102150: LD_INT 31
102152: DOUBLE
102153: EQUAL
102154: IFTRUE 102158
102156: GO 102169
102158: POP
// bc_type := b_oil_power ; 32 :
102159: LD_ADDR_OWVAR 42
102163: PUSH
102164: LD_INT 26
102166: ST_TO_ADDR
102167: GO 102227
102169: LD_INT 32
102171: DOUBLE
102172: EQUAL
102173: IFTRUE 102177
102175: GO 102188
102177: POP
// bc_type := b_siberite_power ; 33 :
102178: LD_ADDR_OWVAR 42
102182: PUSH
102183: LD_INT 28
102185: ST_TO_ADDR
102186: GO 102227
102188: LD_INT 33
102190: DOUBLE
102191: EQUAL
102192: IFTRUE 102196
102194: GO 102207
102196: POP
// bc_type := b_oil_mine ; 34 :
102197: LD_ADDR_OWVAR 42
102201: PUSH
102202: LD_INT 29
102204: ST_TO_ADDR
102205: GO 102227
102207: LD_INT 34
102209: DOUBLE
102210: EQUAL
102211: IFTRUE 102215
102213: GO 102226
102215: POP
// bc_type := b_siberite_mine ; end ;
102216: LD_ADDR_OWVAR 42
102220: PUSH
102221: LD_INT 30
102223: ST_TO_ADDR
102224: GO 102227
102226: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
102227: LD_ADDR_VAR 0 8
102231: PUSH
102232: LD_VAR 0 5
102236: PPUSH
102237: LD_VAR 0 6
102241: PPUSH
102242: LD_VAR 0 3
102246: PPUSH
102247: CALL_OW 47
102251: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
102252: LD_OWVAR 42
102256: PUSH
102257: LD_INT 32
102259: PUSH
102260: LD_INT 33
102262: PUSH
102263: EMPTY
102264: LIST
102265: LIST
102266: IN
102267: IFFALSE 102283
// PlaceWeaponTurret ( b , weapon ) ;
102269: LD_VAR 0 8
102273: PPUSH
102274: LD_VAR 0 4
102278: PPUSH
102279: CALL_OW 431
// end ;
102283: LD_VAR 0 7
102287: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
102288: LD_INT 0
102290: PPUSH
102291: PPUSH
102292: PPUSH
102293: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102294: LD_ADDR_VAR 0 4
102298: PUSH
102299: LD_INT 22
102301: PUSH
102302: LD_OWVAR 2
102306: PUSH
102307: EMPTY
102308: LIST
102309: LIST
102310: PUSH
102311: LD_INT 2
102313: PUSH
102314: LD_INT 30
102316: PUSH
102317: LD_INT 0
102319: PUSH
102320: EMPTY
102321: LIST
102322: LIST
102323: PUSH
102324: LD_INT 30
102326: PUSH
102327: LD_INT 1
102329: PUSH
102330: EMPTY
102331: LIST
102332: LIST
102333: PUSH
102334: EMPTY
102335: LIST
102336: LIST
102337: LIST
102338: PUSH
102339: EMPTY
102340: LIST
102341: LIST
102342: PPUSH
102343: CALL_OW 69
102347: ST_TO_ADDR
// if not tmp then
102348: LD_VAR 0 4
102352: NOT
102353: IFFALSE 102357
// exit ;
102355: GO 102416
// for i in tmp do
102357: LD_ADDR_VAR 0 2
102361: PUSH
102362: LD_VAR 0 4
102366: PUSH
102367: FOR_IN
102368: IFFALSE 102414
// for j = 1 to 3 do
102370: LD_ADDR_VAR 0 3
102374: PUSH
102375: DOUBLE
102376: LD_INT 1
102378: DEC
102379: ST_TO_ADDR
102380: LD_INT 3
102382: PUSH
102383: FOR_TO
102384: IFFALSE 102410
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
102386: LD_VAR 0 2
102390: PPUSH
102391: CALL_OW 274
102395: PPUSH
102396: LD_VAR 0 3
102400: PPUSH
102401: LD_INT 99999
102403: PPUSH
102404: CALL_OW 277
102408: GO 102383
102410: POP
102411: POP
102412: GO 102367
102414: POP
102415: POP
// end ;
102416: LD_VAR 0 1
102420: RET
// export function hHackSetLevel10 ; var i , j ; begin
102421: LD_INT 0
102423: PPUSH
102424: PPUSH
102425: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102426: LD_ADDR_VAR 0 2
102430: PUSH
102431: LD_INT 21
102433: PUSH
102434: LD_INT 1
102436: PUSH
102437: EMPTY
102438: LIST
102439: LIST
102440: PPUSH
102441: CALL_OW 69
102445: PUSH
102446: FOR_IN
102447: IFFALSE 102499
// if IsSelected ( i ) then
102449: LD_VAR 0 2
102453: PPUSH
102454: CALL_OW 306
102458: IFFALSE 102497
// begin for j := 1 to 4 do
102460: LD_ADDR_VAR 0 3
102464: PUSH
102465: DOUBLE
102466: LD_INT 1
102468: DEC
102469: ST_TO_ADDR
102470: LD_INT 4
102472: PUSH
102473: FOR_TO
102474: IFFALSE 102495
// SetSkill ( i , j , 10 ) ;
102476: LD_VAR 0 2
102480: PPUSH
102481: LD_VAR 0 3
102485: PPUSH
102486: LD_INT 10
102488: PPUSH
102489: CALL_OW 237
102493: GO 102473
102495: POP
102496: POP
// end ;
102497: GO 102446
102499: POP
102500: POP
// end ;
102501: LD_VAR 0 1
102505: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
102506: LD_INT 0
102508: PPUSH
102509: PPUSH
102510: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
102511: LD_ADDR_VAR 0 2
102515: PUSH
102516: LD_INT 22
102518: PUSH
102519: LD_OWVAR 2
102523: PUSH
102524: EMPTY
102525: LIST
102526: LIST
102527: PUSH
102528: LD_INT 21
102530: PUSH
102531: LD_INT 1
102533: PUSH
102534: EMPTY
102535: LIST
102536: LIST
102537: PUSH
102538: EMPTY
102539: LIST
102540: LIST
102541: PPUSH
102542: CALL_OW 69
102546: PUSH
102547: FOR_IN
102548: IFFALSE 102589
// begin for j := 1 to 4 do
102550: LD_ADDR_VAR 0 3
102554: PUSH
102555: DOUBLE
102556: LD_INT 1
102558: DEC
102559: ST_TO_ADDR
102560: LD_INT 4
102562: PUSH
102563: FOR_TO
102564: IFFALSE 102585
// SetSkill ( i , j , 10 ) ;
102566: LD_VAR 0 2
102570: PPUSH
102571: LD_VAR 0 3
102575: PPUSH
102576: LD_INT 10
102578: PPUSH
102579: CALL_OW 237
102583: GO 102563
102585: POP
102586: POP
// end ;
102587: GO 102547
102589: POP
102590: POP
// end ;
102591: LD_VAR 0 1
102595: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102596: LD_INT 0
102598: PPUSH
// uc_side := your_side ;
102599: LD_ADDR_OWVAR 20
102603: PUSH
102604: LD_OWVAR 2
102608: ST_TO_ADDR
// uc_nation := nation ;
102609: LD_ADDR_OWVAR 21
102613: PUSH
102614: LD_VAR 0 1
102618: ST_TO_ADDR
// InitHc ;
102619: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
102623: LD_INT 0
102625: PPUSH
102626: LD_VAR 0 2
102630: PPUSH
102631: LD_VAR 0 3
102635: PPUSH
102636: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
102640: LD_VAR 0 4
102644: PPUSH
102645: LD_VAR 0 5
102649: PPUSH
102650: CALL_OW 428
102654: PUSH
102655: LD_INT 0
102657: EQUAL
102658: IFFALSE 102682
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
102660: CALL_OW 44
102664: PPUSH
102665: LD_VAR 0 4
102669: PPUSH
102670: LD_VAR 0 5
102674: PPUSH
102675: LD_INT 1
102677: PPUSH
102678: CALL_OW 48
// end ;
102682: LD_VAR 0 6
102686: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
102687: LD_INT 0
102689: PPUSH
102690: PPUSH
// uc_side := your_side ;
102691: LD_ADDR_OWVAR 20
102695: PUSH
102696: LD_OWVAR 2
102700: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
102701: LD_VAR 0 1
102705: PUSH
102706: LD_INT 1
102708: PUSH
102709: LD_INT 2
102711: PUSH
102712: LD_INT 3
102714: PUSH
102715: LD_INT 4
102717: PUSH
102718: LD_INT 5
102720: PUSH
102721: EMPTY
102722: LIST
102723: LIST
102724: LIST
102725: LIST
102726: LIST
102727: IN
102728: IFFALSE 102740
// uc_nation := nation_american else
102730: LD_ADDR_OWVAR 21
102734: PUSH
102735: LD_INT 1
102737: ST_TO_ADDR
102738: GO 102783
// if chassis in [ 11 , 12 , 13 , 14 ] then
102740: LD_VAR 0 1
102744: PUSH
102745: LD_INT 11
102747: PUSH
102748: LD_INT 12
102750: PUSH
102751: LD_INT 13
102753: PUSH
102754: LD_INT 14
102756: PUSH
102757: EMPTY
102758: LIST
102759: LIST
102760: LIST
102761: LIST
102762: IN
102763: IFFALSE 102775
// uc_nation := nation_arabian else
102765: LD_ADDR_OWVAR 21
102769: PUSH
102770: LD_INT 2
102772: ST_TO_ADDR
102773: GO 102783
// uc_nation := nation_russian ;
102775: LD_ADDR_OWVAR 21
102779: PUSH
102780: LD_INT 3
102782: ST_TO_ADDR
// vc_chassis := chassis ;
102783: LD_ADDR_OWVAR 37
102787: PUSH
102788: LD_VAR 0 1
102792: ST_TO_ADDR
// vc_engine := engine ;
102793: LD_ADDR_OWVAR 39
102797: PUSH
102798: LD_VAR 0 2
102802: ST_TO_ADDR
// vc_control := control ;
102803: LD_ADDR_OWVAR 38
102807: PUSH
102808: LD_VAR 0 3
102812: ST_TO_ADDR
// vc_weapon := weapon ;
102813: LD_ADDR_OWVAR 40
102817: PUSH
102818: LD_VAR 0 4
102822: ST_TO_ADDR
// un := CreateVehicle ;
102823: LD_ADDR_VAR 0 8
102827: PUSH
102828: CALL_OW 45
102832: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102833: LD_VAR 0 8
102837: PPUSH
102838: LD_INT 0
102840: PPUSH
102841: LD_INT 5
102843: PPUSH
102844: CALL_OW 12
102848: PPUSH
102849: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
102853: LD_VAR 0 8
102857: PPUSH
102858: LD_VAR 0 5
102862: PPUSH
102863: LD_VAR 0 6
102867: PPUSH
102868: LD_INT 1
102870: PPUSH
102871: CALL_OW 48
// end ;
102875: LD_VAR 0 7
102879: RET
// export hInvincible ; every 1 do
102880: GO 102882
102882: DISABLE
// hInvincible := [ ] ;
102883: LD_ADDR_EXP 191
102887: PUSH
102888: EMPTY
102889: ST_TO_ADDR
102890: END
// every 10 do var i ;
102891: GO 102893
102893: DISABLE
102894: LD_INT 0
102896: PPUSH
// begin enable ;
102897: ENABLE
// if not hInvincible then
102898: LD_EXP 191
102902: NOT
102903: IFFALSE 102907
// exit ;
102905: GO 102951
// for i in hInvincible do
102907: LD_ADDR_VAR 0 1
102911: PUSH
102912: LD_EXP 191
102916: PUSH
102917: FOR_IN
102918: IFFALSE 102949
// if GetLives ( i ) < 1000 then
102920: LD_VAR 0 1
102924: PPUSH
102925: CALL_OW 256
102929: PUSH
102930: LD_INT 1000
102932: LESS
102933: IFFALSE 102947
// SetLives ( i , 1000 ) ;
102935: LD_VAR 0 1
102939: PPUSH
102940: LD_INT 1000
102942: PPUSH
102943: CALL_OW 234
102947: GO 102917
102949: POP
102950: POP
// end ;
102951: PPOPN 1
102953: END
// export function hHackInvincible ; var i ; begin
102954: LD_INT 0
102956: PPUSH
102957: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
102958: LD_ADDR_VAR 0 2
102962: PUSH
102963: LD_INT 2
102965: PUSH
102966: LD_INT 21
102968: PUSH
102969: LD_INT 1
102971: PUSH
102972: EMPTY
102973: LIST
102974: LIST
102975: PUSH
102976: LD_INT 21
102978: PUSH
102979: LD_INT 2
102981: PUSH
102982: EMPTY
102983: LIST
102984: LIST
102985: PUSH
102986: EMPTY
102987: LIST
102988: LIST
102989: LIST
102990: PPUSH
102991: CALL_OW 69
102995: PUSH
102996: FOR_IN
102997: IFFALSE 103058
// if IsSelected ( i ) then
102999: LD_VAR 0 2
103003: PPUSH
103004: CALL_OW 306
103008: IFFALSE 103056
// begin if i in hInvincible then
103010: LD_VAR 0 2
103014: PUSH
103015: LD_EXP 191
103019: IN
103020: IFFALSE 103040
// hInvincible := hInvincible diff i else
103022: LD_ADDR_EXP 191
103026: PUSH
103027: LD_EXP 191
103031: PUSH
103032: LD_VAR 0 2
103036: DIFF
103037: ST_TO_ADDR
103038: GO 103056
// hInvincible := hInvincible union i ;
103040: LD_ADDR_EXP 191
103044: PUSH
103045: LD_EXP 191
103049: PUSH
103050: LD_VAR 0 2
103054: UNION
103055: ST_TO_ADDR
// end ;
103056: GO 102996
103058: POP
103059: POP
// end ;
103060: LD_VAR 0 1
103064: RET
// export function hHackInvisible ; var i , j ; begin
103065: LD_INT 0
103067: PPUSH
103068: PPUSH
103069: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103070: LD_ADDR_VAR 0 2
103074: PUSH
103075: LD_INT 21
103077: PUSH
103078: LD_INT 1
103080: PUSH
103081: EMPTY
103082: LIST
103083: LIST
103084: PPUSH
103085: CALL_OW 69
103089: PUSH
103090: FOR_IN
103091: IFFALSE 103115
// if IsSelected ( i ) then
103093: LD_VAR 0 2
103097: PPUSH
103098: CALL_OW 306
103102: IFFALSE 103113
// ComForceInvisible ( i ) ;
103104: LD_VAR 0 2
103108: PPUSH
103109: CALL_OW 496
103113: GO 103090
103115: POP
103116: POP
// end ;
103117: LD_VAR 0 1
103121: RET
// export function hHackChangeYourSide ; begin
103122: LD_INT 0
103124: PPUSH
// if your_side = 8 then
103125: LD_OWVAR 2
103129: PUSH
103130: LD_INT 8
103132: EQUAL
103133: IFFALSE 103145
// your_side := 0 else
103135: LD_ADDR_OWVAR 2
103139: PUSH
103140: LD_INT 0
103142: ST_TO_ADDR
103143: GO 103159
// your_side := your_side + 1 ;
103145: LD_ADDR_OWVAR 2
103149: PUSH
103150: LD_OWVAR 2
103154: PUSH
103155: LD_INT 1
103157: PLUS
103158: ST_TO_ADDR
// end ;
103159: LD_VAR 0 1
103163: RET
// export function hHackChangeUnitSide ; var i , j ; begin
103164: LD_INT 0
103166: PPUSH
103167: PPUSH
103168: PPUSH
// for i in all_units do
103169: LD_ADDR_VAR 0 2
103173: PUSH
103174: LD_OWVAR 3
103178: PUSH
103179: FOR_IN
103180: IFFALSE 103258
// if IsSelected ( i ) then
103182: LD_VAR 0 2
103186: PPUSH
103187: CALL_OW 306
103191: IFFALSE 103256
// begin j := GetSide ( i ) ;
103193: LD_ADDR_VAR 0 3
103197: PUSH
103198: LD_VAR 0 2
103202: PPUSH
103203: CALL_OW 255
103207: ST_TO_ADDR
// if j = 8 then
103208: LD_VAR 0 3
103212: PUSH
103213: LD_INT 8
103215: EQUAL
103216: IFFALSE 103228
// j := 0 else
103218: LD_ADDR_VAR 0 3
103222: PUSH
103223: LD_INT 0
103225: ST_TO_ADDR
103226: GO 103242
// j := j + 1 ;
103228: LD_ADDR_VAR 0 3
103232: PUSH
103233: LD_VAR 0 3
103237: PUSH
103238: LD_INT 1
103240: PLUS
103241: ST_TO_ADDR
// SetSide ( i , j ) ;
103242: LD_VAR 0 2
103246: PPUSH
103247: LD_VAR 0 3
103251: PPUSH
103252: CALL_OW 235
// end ;
103256: GO 103179
103258: POP
103259: POP
// end ;
103260: LD_VAR 0 1
103264: RET
// export function hHackFog ; begin
103265: LD_INT 0
103267: PPUSH
// FogOff ( true ) ;
103268: LD_INT 1
103270: PPUSH
103271: CALL_OW 344
// end ;
103275: LD_VAR 0 1
103279: RET
// export function hHackTeleport ( unit , x , y ) ; begin
103280: LD_INT 0
103282: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
103283: LD_VAR 0 1
103287: PPUSH
103288: LD_VAR 0 2
103292: PPUSH
103293: LD_VAR 0 3
103297: PPUSH
103298: LD_INT 1
103300: PPUSH
103301: LD_INT 1
103303: PPUSH
103304: CALL_OW 483
// CenterOnXY ( x , y ) ;
103308: LD_VAR 0 2
103312: PPUSH
103313: LD_VAR 0 3
103317: PPUSH
103318: CALL_OW 84
// end ; end_of_file
103322: LD_VAR 0 4
103326: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
103327: LD_INT 0
103329: PPUSH
103330: PPUSH
103331: PPUSH
103332: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
103333: LD_VAR 0 1
103337: PPUSH
103338: CALL_OW 264
103342: PUSH
103343: LD_EXP 76
103347: EQUAL
103348: IFFALSE 103420
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103350: LD_INT 68
103352: PPUSH
103353: LD_VAR 0 1
103357: PPUSH
103358: CALL_OW 255
103362: PPUSH
103363: CALL_OW 321
103367: PUSH
103368: LD_INT 2
103370: EQUAL
103371: IFFALSE 103383
// eff := 70 else
103373: LD_ADDR_VAR 0 4
103377: PUSH
103378: LD_INT 70
103380: ST_TO_ADDR
103381: GO 103391
// eff := 30 ;
103383: LD_ADDR_VAR 0 4
103387: PUSH
103388: LD_INT 30
103390: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103391: LD_VAR 0 1
103395: PPUSH
103396: CALL_OW 250
103400: PPUSH
103401: LD_VAR 0 1
103405: PPUSH
103406: CALL_OW 251
103410: PPUSH
103411: LD_VAR 0 4
103415: PPUSH
103416: CALL_OW 495
// end ; end ;
103420: LD_VAR 0 2
103424: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
103425: LD_INT 0
103427: PPUSH
// end ;
103428: LD_VAR 0 4
103432: RET
// export function SOS_Command ( cmd ) ; begin
103433: LD_INT 0
103435: PPUSH
// end ;
103436: LD_VAR 0 2
103440: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
103441: LD_INT 0
103443: PPUSH
// if cmd = 121 then
103444: LD_VAR 0 1
103448: PUSH
103449: LD_INT 121
103451: EQUAL
103452: IFFALSE 103454
// end ;
103454: LD_VAR 0 6
103458: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103459: LD_INT 0
103461: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103462: LD_VAR 0 1
103466: PUSH
103467: LD_INT 250
103469: EQUAL
103470: PUSH
103471: LD_VAR 0 2
103475: PPUSH
103476: CALL_OW 264
103480: PUSH
103481: LD_EXP 79
103485: EQUAL
103486: AND
103487: IFFALSE 103508
// MinerPlaceMine ( unit , x , y ) ;
103489: LD_VAR 0 2
103493: PPUSH
103494: LD_VAR 0 4
103498: PPUSH
103499: LD_VAR 0 5
103503: PPUSH
103504: CALL 105857 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103508: LD_VAR 0 1
103512: PUSH
103513: LD_INT 251
103515: EQUAL
103516: PUSH
103517: LD_VAR 0 2
103521: PPUSH
103522: CALL_OW 264
103526: PUSH
103527: LD_EXP 79
103531: EQUAL
103532: AND
103533: IFFALSE 103554
// MinerDetonateMine ( unit , x , y ) ;
103535: LD_VAR 0 2
103539: PPUSH
103540: LD_VAR 0 4
103544: PPUSH
103545: LD_VAR 0 5
103549: PPUSH
103550: CALL 106134 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103554: LD_VAR 0 1
103558: PUSH
103559: LD_INT 252
103561: EQUAL
103562: PUSH
103563: LD_VAR 0 2
103567: PPUSH
103568: CALL_OW 264
103572: PUSH
103573: LD_EXP 79
103577: EQUAL
103578: AND
103579: IFFALSE 103600
// MinerCreateMinefield ( unit , x , y ) ;
103581: LD_VAR 0 2
103585: PPUSH
103586: LD_VAR 0 4
103590: PPUSH
103591: LD_VAR 0 5
103595: PPUSH
103596: CALL 106551 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103600: LD_VAR 0 1
103604: PUSH
103605: LD_INT 253
103607: EQUAL
103608: PUSH
103609: LD_VAR 0 2
103613: PPUSH
103614: CALL_OW 257
103618: PUSH
103619: LD_INT 5
103621: EQUAL
103622: AND
103623: IFFALSE 103644
// ComBinocular ( unit , x , y ) ;
103625: LD_VAR 0 2
103629: PPUSH
103630: LD_VAR 0 4
103634: PPUSH
103635: LD_VAR 0 5
103639: PPUSH
103640: CALL 106922 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103644: LD_VAR 0 1
103648: PUSH
103649: LD_INT 254
103651: EQUAL
103652: PUSH
103653: LD_VAR 0 2
103657: PPUSH
103658: CALL_OW 264
103662: PUSH
103663: LD_EXP 74
103667: EQUAL
103668: AND
103669: PUSH
103670: LD_VAR 0 3
103674: PPUSH
103675: CALL_OW 263
103679: PUSH
103680: LD_INT 3
103682: EQUAL
103683: AND
103684: IFFALSE 103700
// HackDestroyVehicle ( unit , selectedUnit ) ;
103686: LD_VAR 0 2
103690: PPUSH
103691: LD_VAR 0 3
103695: PPUSH
103696: CALL 105217 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103700: LD_VAR 0 1
103704: PUSH
103705: LD_INT 255
103707: EQUAL
103708: PUSH
103709: LD_VAR 0 2
103713: PPUSH
103714: CALL_OW 264
103718: PUSH
103719: LD_INT 14
103721: PUSH
103722: LD_INT 53
103724: PUSH
103725: EMPTY
103726: LIST
103727: LIST
103728: IN
103729: AND
103730: PUSH
103731: LD_VAR 0 4
103735: PPUSH
103736: LD_VAR 0 5
103740: PPUSH
103741: CALL_OW 488
103745: AND
103746: IFFALSE 103770
// CutTreeXYR ( unit , x , y , 12 ) ;
103748: LD_VAR 0 2
103752: PPUSH
103753: LD_VAR 0 4
103757: PPUSH
103758: LD_VAR 0 5
103762: PPUSH
103763: LD_INT 12
103765: PPUSH
103766: CALL 103783 0 4
// end ;
103770: LD_VAR 0 6
103774: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
103775: LD_INT 0
103777: PPUSH
// end ;
103778: LD_VAR 0 4
103782: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103783: LD_INT 0
103785: PPUSH
103786: PPUSH
103787: PPUSH
103788: PPUSH
103789: PPUSH
103790: PPUSH
103791: PPUSH
103792: PPUSH
103793: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103794: LD_VAR 0 1
103798: NOT
103799: PUSH
103800: LD_VAR 0 2
103804: PPUSH
103805: LD_VAR 0 3
103809: PPUSH
103810: CALL_OW 488
103814: NOT
103815: OR
103816: PUSH
103817: LD_VAR 0 4
103821: NOT
103822: OR
103823: IFFALSE 103827
// exit ;
103825: GO 104167
// list := [ ] ;
103827: LD_ADDR_VAR 0 13
103831: PUSH
103832: EMPTY
103833: ST_TO_ADDR
// if x - r < 0 then
103834: LD_VAR 0 2
103838: PUSH
103839: LD_VAR 0 4
103843: MINUS
103844: PUSH
103845: LD_INT 0
103847: LESS
103848: IFFALSE 103860
// min_x := 0 else
103850: LD_ADDR_VAR 0 7
103854: PUSH
103855: LD_INT 0
103857: ST_TO_ADDR
103858: GO 103876
// min_x := x - r ;
103860: LD_ADDR_VAR 0 7
103864: PUSH
103865: LD_VAR 0 2
103869: PUSH
103870: LD_VAR 0 4
103874: MINUS
103875: ST_TO_ADDR
// if y - r < 0 then
103876: LD_VAR 0 3
103880: PUSH
103881: LD_VAR 0 4
103885: MINUS
103886: PUSH
103887: LD_INT 0
103889: LESS
103890: IFFALSE 103902
// min_y := 0 else
103892: LD_ADDR_VAR 0 8
103896: PUSH
103897: LD_INT 0
103899: ST_TO_ADDR
103900: GO 103918
// min_y := y - r ;
103902: LD_ADDR_VAR 0 8
103906: PUSH
103907: LD_VAR 0 3
103911: PUSH
103912: LD_VAR 0 4
103916: MINUS
103917: ST_TO_ADDR
// max_x := x + r ;
103918: LD_ADDR_VAR 0 9
103922: PUSH
103923: LD_VAR 0 2
103927: PUSH
103928: LD_VAR 0 4
103932: PLUS
103933: ST_TO_ADDR
// max_y := y + r ;
103934: LD_ADDR_VAR 0 10
103938: PUSH
103939: LD_VAR 0 3
103943: PUSH
103944: LD_VAR 0 4
103948: PLUS
103949: ST_TO_ADDR
// for _x = min_x to max_x do
103950: LD_ADDR_VAR 0 11
103954: PUSH
103955: DOUBLE
103956: LD_VAR 0 7
103960: DEC
103961: ST_TO_ADDR
103962: LD_VAR 0 9
103966: PUSH
103967: FOR_TO
103968: IFFALSE 104085
// for _y = min_y to max_y do
103970: LD_ADDR_VAR 0 12
103974: PUSH
103975: DOUBLE
103976: LD_VAR 0 8
103980: DEC
103981: ST_TO_ADDR
103982: LD_VAR 0 10
103986: PUSH
103987: FOR_TO
103988: IFFALSE 104081
// begin if not ValidHex ( _x , _y ) then
103990: LD_VAR 0 11
103994: PPUSH
103995: LD_VAR 0 12
103999: PPUSH
104000: CALL_OW 488
104004: NOT
104005: IFFALSE 104009
// continue ;
104007: GO 103987
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104009: LD_VAR 0 11
104013: PPUSH
104014: LD_VAR 0 12
104018: PPUSH
104019: CALL_OW 351
104023: PUSH
104024: LD_VAR 0 11
104028: PPUSH
104029: LD_VAR 0 12
104033: PPUSH
104034: CALL_OW 554
104038: AND
104039: IFFALSE 104079
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104041: LD_ADDR_VAR 0 13
104045: PUSH
104046: LD_VAR 0 13
104050: PPUSH
104051: LD_VAR 0 13
104055: PUSH
104056: LD_INT 1
104058: PLUS
104059: PPUSH
104060: LD_VAR 0 11
104064: PUSH
104065: LD_VAR 0 12
104069: PUSH
104070: EMPTY
104071: LIST
104072: LIST
104073: PPUSH
104074: CALL_OW 2
104078: ST_TO_ADDR
// end ;
104079: GO 103987
104081: POP
104082: POP
104083: GO 103967
104085: POP
104086: POP
// if not list then
104087: LD_VAR 0 13
104091: NOT
104092: IFFALSE 104096
// exit ;
104094: GO 104167
// for i in list do
104096: LD_ADDR_VAR 0 6
104100: PUSH
104101: LD_VAR 0 13
104105: PUSH
104106: FOR_IN
104107: IFFALSE 104165
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104109: LD_VAR 0 1
104113: PPUSH
104114: LD_STRING M
104116: PUSH
104117: LD_VAR 0 6
104121: PUSH
104122: LD_INT 1
104124: ARRAY
104125: PUSH
104126: LD_VAR 0 6
104130: PUSH
104131: LD_INT 2
104133: ARRAY
104134: PUSH
104135: LD_INT 0
104137: PUSH
104138: LD_INT 0
104140: PUSH
104141: LD_INT 0
104143: PUSH
104144: LD_INT 0
104146: PUSH
104147: EMPTY
104148: LIST
104149: LIST
104150: LIST
104151: LIST
104152: LIST
104153: LIST
104154: LIST
104155: PUSH
104156: EMPTY
104157: LIST
104158: PPUSH
104159: CALL_OW 447
104163: GO 104106
104165: POP
104166: POP
// end ;
104167: LD_VAR 0 5
104171: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104172: LD_EXP 194
104176: NOT
104177: IFFALSE 104227
104179: GO 104181
104181: DISABLE
// begin initHack := true ;
104182: LD_ADDR_EXP 194
104186: PUSH
104187: LD_INT 1
104189: ST_TO_ADDR
// hackTanks := [ ] ;
104190: LD_ADDR_EXP 195
104194: PUSH
104195: EMPTY
104196: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104197: LD_ADDR_EXP 196
104201: PUSH
104202: EMPTY
104203: ST_TO_ADDR
// hackLimit := 3 ;
104204: LD_ADDR_EXP 197
104208: PUSH
104209: LD_INT 3
104211: ST_TO_ADDR
// hackDist := 12 ;
104212: LD_ADDR_EXP 198
104216: PUSH
104217: LD_INT 12
104219: ST_TO_ADDR
// hackCounter := [ ] ;
104220: LD_ADDR_EXP 199
104224: PUSH
104225: EMPTY
104226: ST_TO_ADDR
// end ;
104227: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104228: LD_EXP 194
104232: PUSH
104233: LD_INT 34
104235: PUSH
104236: LD_EXP 74
104240: PUSH
104241: EMPTY
104242: LIST
104243: LIST
104244: PPUSH
104245: CALL_OW 69
104249: AND
104250: IFFALSE 104505
104252: GO 104254
104254: DISABLE
104255: LD_INT 0
104257: PPUSH
104258: PPUSH
// begin enable ;
104259: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104260: LD_ADDR_VAR 0 1
104264: PUSH
104265: LD_INT 34
104267: PUSH
104268: LD_EXP 74
104272: PUSH
104273: EMPTY
104274: LIST
104275: LIST
104276: PPUSH
104277: CALL_OW 69
104281: PUSH
104282: FOR_IN
104283: IFFALSE 104503
// begin if not i in hackTanks then
104285: LD_VAR 0 1
104289: PUSH
104290: LD_EXP 195
104294: IN
104295: NOT
104296: IFFALSE 104379
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104298: LD_ADDR_EXP 195
104302: PUSH
104303: LD_EXP 195
104307: PPUSH
104308: LD_EXP 195
104312: PUSH
104313: LD_INT 1
104315: PLUS
104316: PPUSH
104317: LD_VAR 0 1
104321: PPUSH
104322: CALL_OW 1
104326: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104327: LD_ADDR_EXP 196
104331: PUSH
104332: LD_EXP 196
104336: PPUSH
104337: LD_EXP 196
104341: PUSH
104342: LD_INT 1
104344: PLUS
104345: PPUSH
104346: EMPTY
104347: PPUSH
104348: CALL_OW 1
104352: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104353: LD_ADDR_EXP 199
104357: PUSH
104358: LD_EXP 199
104362: PPUSH
104363: LD_EXP 199
104367: PUSH
104368: LD_INT 1
104370: PLUS
104371: PPUSH
104372: EMPTY
104373: PPUSH
104374: CALL_OW 1
104378: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104379: LD_VAR 0 1
104383: PPUSH
104384: CALL_OW 302
104388: NOT
104389: IFFALSE 104402
// begin HackUnlinkAll ( i ) ;
104391: LD_VAR 0 1
104395: PPUSH
104396: CALL 104508 0 1
// continue ;
104400: GO 104282
// end ; HackCheckCapturedStatus ( i ) ;
104402: LD_VAR 0 1
104406: PPUSH
104407: CALL 104951 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104411: LD_ADDR_VAR 0 2
104415: PUSH
104416: LD_INT 81
104418: PUSH
104419: LD_VAR 0 1
104423: PPUSH
104424: CALL_OW 255
104428: PUSH
104429: EMPTY
104430: LIST
104431: LIST
104432: PUSH
104433: LD_INT 33
104435: PUSH
104436: LD_INT 3
104438: PUSH
104439: EMPTY
104440: LIST
104441: LIST
104442: PUSH
104443: LD_INT 91
104445: PUSH
104446: LD_VAR 0 1
104450: PUSH
104451: LD_EXP 198
104455: PUSH
104456: EMPTY
104457: LIST
104458: LIST
104459: LIST
104460: PUSH
104461: LD_INT 50
104463: PUSH
104464: EMPTY
104465: LIST
104466: PUSH
104467: EMPTY
104468: LIST
104469: LIST
104470: LIST
104471: LIST
104472: PPUSH
104473: CALL_OW 69
104477: ST_TO_ADDR
// if not tmp then
104478: LD_VAR 0 2
104482: NOT
104483: IFFALSE 104487
// continue ;
104485: GO 104282
// HackLink ( i , tmp ) ;
104487: LD_VAR 0 1
104491: PPUSH
104492: LD_VAR 0 2
104496: PPUSH
104497: CALL 104644 0 2
// end ;
104501: GO 104282
104503: POP
104504: POP
// end ;
104505: PPOPN 2
104507: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104508: LD_INT 0
104510: PPUSH
104511: PPUSH
104512: PPUSH
// if not hack in hackTanks then
104513: LD_VAR 0 1
104517: PUSH
104518: LD_EXP 195
104522: IN
104523: NOT
104524: IFFALSE 104528
// exit ;
104526: GO 104639
// index := GetElementIndex ( hackTanks , hack ) ;
104528: LD_ADDR_VAR 0 4
104532: PUSH
104533: LD_EXP 195
104537: PPUSH
104538: LD_VAR 0 1
104542: PPUSH
104543: CALL 56052 0 2
104547: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104548: LD_EXP 196
104552: PUSH
104553: LD_VAR 0 4
104557: ARRAY
104558: IFFALSE 104639
// begin for i in hackTanksCaptured [ index ] do
104560: LD_ADDR_VAR 0 3
104564: PUSH
104565: LD_EXP 196
104569: PUSH
104570: LD_VAR 0 4
104574: ARRAY
104575: PUSH
104576: FOR_IN
104577: IFFALSE 104603
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104579: LD_VAR 0 3
104583: PUSH
104584: LD_INT 1
104586: ARRAY
104587: PPUSH
104588: LD_VAR 0 3
104592: PUSH
104593: LD_INT 2
104595: ARRAY
104596: PPUSH
104597: CALL_OW 235
104601: GO 104576
104603: POP
104604: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104605: LD_ADDR_EXP 196
104609: PUSH
104610: LD_EXP 196
104614: PPUSH
104615: LD_VAR 0 4
104619: PPUSH
104620: EMPTY
104621: PPUSH
104622: CALL_OW 1
104626: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104627: LD_VAR 0 1
104631: PPUSH
104632: LD_INT 0
104634: PPUSH
104635: CALL_OW 505
// end ; end ;
104639: LD_VAR 0 2
104643: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104644: LD_INT 0
104646: PPUSH
104647: PPUSH
104648: PPUSH
// if not hack in hackTanks or not vehicles then
104649: LD_VAR 0 1
104653: PUSH
104654: LD_EXP 195
104658: IN
104659: NOT
104660: PUSH
104661: LD_VAR 0 2
104665: NOT
104666: OR
104667: IFFALSE 104671
// exit ;
104669: GO 104946
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104671: LD_ADDR_VAR 0 2
104675: PUSH
104676: LD_VAR 0 1
104680: PPUSH
104681: LD_VAR 0 2
104685: PPUSH
104686: LD_INT 1
104688: PPUSH
104689: LD_INT 1
104691: PPUSH
104692: CALL 56702 0 4
104696: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104697: LD_ADDR_VAR 0 5
104701: PUSH
104702: LD_EXP 195
104706: PPUSH
104707: LD_VAR 0 1
104711: PPUSH
104712: CALL 56052 0 2
104716: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
104717: LD_EXP 196
104721: PUSH
104722: LD_VAR 0 5
104726: ARRAY
104727: PUSH
104728: LD_EXP 197
104732: LESS
104733: IFFALSE 104922
// begin for i := 1 to vehicles do
104735: LD_ADDR_VAR 0 4
104739: PUSH
104740: DOUBLE
104741: LD_INT 1
104743: DEC
104744: ST_TO_ADDR
104745: LD_VAR 0 2
104749: PUSH
104750: FOR_TO
104751: IFFALSE 104920
// begin if hackTanksCaptured [ index ] = hackLimit then
104753: LD_EXP 196
104757: PUSH
104758: LD_VAR 0 5
104762: ARRAY
104763: PUSH
104764: LD_EXP 197
104768: EQUAL
104769: IFFALSE 104773
// break ;
104771: GO 104920
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104773: LD_ADDR_EXP 199
104777: PUSH
104778: LD_EXP 199
104782: PPUSH
104783: LD_VAR 0 5
104787: PPUSH
104788: LD_EXP 199
104792: PUSH
104793: LD_VAR 0 5
104797: ARRAY
104798: PUSH
104799: LD_INT 1
104801: PLUS
104802: PPUSH
104803: CALL_OW 1
104807: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104808: LD_ADDR_EXP 196
104812: PUSH
104813: LD_EXP 196
104817: PPUSH
104818: LD_VAR 0 5
104822: PUSH
104823: LD_EXP 196
104827: PUSH
104828: LD_VAR 0 5
104832: ARRAY
104833: PUSH
104834: LD_INT 1
104836: PLUS
104837: PUSH
104838: EMPTY
104839: LIST
104840: LIST
104841: PPUSH
104842: LD_VAR 0 2
104846: PUSH
104847: LD_VAR 0 4
104851: ARRAY
104852: PUSH
104853: LD_VAR 0 2
104857: PUSH
104858: LD_VAR 0 4
104862: ARRAY
104863: PPUSH
104864: CALL_OW 255
104868: PUSH
104869: EMPTY
104870: LIST
104871: LIST
104872: PPUSH
104873: CALL 56267 0 3
104877: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104878: LD_VAR 0 2
104882: PUSH
104883: LD_VAR 0 4
104887: ARRAY
104888: PPUSH
104889: LD_VAR 0 1
104893: PPUSH
104894: CALL_OW 255
104898: PPUSH
104899: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104903: LD_VAR 0 2
104907: PUSH
104908: LD_VAR 0 4
104912: ARRAY
104913: PPUSH
104914: CALL_OW 141
// end ;
104918: GO 104750
104920: POP
104921: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104922: LD_VAR 0 1
104926: PPUSH
104927: LD_EXP 196
104931: PUSH
104932: LD_VAR 0 5
104936: ARRAY
104937: PUSH
104938: LD_INT 0
104940: PLUS
104941: PPUSH
104942: CALL_OW 505
// end ;
104946: LD_VAR 0 3
104950: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104951: LD_INT 0
104953: PPUSH
104954: PPUSH
104955: PPUSH
104956: PPUSH
// if not hack in hackTanks then
104957: LD_VAR 0 1
104961: PUSH
104962: LD_EXP 195
104966: IN
104967: NOT
104968: IFFALSE 104972
// exit ;
104970: GO 105212
// index := GetElementIndex ( hackTanks , hack ) ;
104972: LD_ADDR_VAR 0 4
104976: PUSH
104977: LD_EXP 195
104981: PPUSH
104982: LD_VAR 0 1
104986: PPUSH
104987: CALL 56052 0 2
104991: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104992: LD_ADDR_VAR 0 3
104996: PUSH
104997: DOUBLE
104998: LD_EXP 196
105002: PUSH
105003: LD_VAR 0 4
105007: ARRAY
105008: INC
105009: ST_TO_ADDR
105010: LD_INT 1
105012: PUSH
105013: FOR_DOWNTO
105014: IFFALSE 105186
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105016: LD_ADDR_VAR 0 5
105020: PUSH
105021: LD_EXP 196
105025: PUSH
105026: LD_VAR 0 4
105030: ARRAY
105031: PUSH
105032: LD_VAR 0 3
105036: ARRAY
105037: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105038: LD_VAR 0 5
105042: PUSH
105043: LD_INT 1
105045: ARRAY
105046: PPUSH
105047: CALL_OW 302
105051: NOT
105052: PUSH
105053: LD_VAR 0 5
105057: PUSH
105058: LD_INT 1
105060: ARRAY
105061: PPUSH
105062: CALL_OW 255
105066: PUSH
105067: LD_VAR 0 1
105071: PPUSH
105072: CALL_OW 255
105076: NONEQUAL
105077: OR
105078: IFFALSE 105184
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105080: LD_VAR 0 5
105084: PUSH
105085: LD_INT 1
105087: ARRAY
105088: PPUSH
105089: CALL_OW 305
105093: PUSH
105094: LD_VAR 0 5
105098: PUSH
105099: LD_INT 1
105101: ARRAY
105102: PPUSH
105103: CALL_OW 255
105107: PUSH
105108: LD_VAR 0 1
105112: PPUSH
105113: CALL_OW 255
105117: EQUAL
105118: AND
105119: IFFALSE 105143
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
105121: LD_VAR 0 5
105125: PUSH
105126: LD_INT 1
105128: ARRAY
105129: PPUSH
105130: LD_VAR 0 5
105134: PUSH
105135: LD_INT 2
105137: ARRAY
105138: PPUSH
105139: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
105143: LD_ADDR_EXP 196
105147: PUSH
105148: LD_EXP 196
105152: PPUSH
105153: LD_VAR 0 4
105157: PPUSH
105158: LD_EXP 196
105162: PUSH
105163: LD_VAR 0 4
105167: ARRAY
105168: PPUSH
105169: LD_VAR 0 3
105173: PPUSH
105174: CALL_OW 3
105178: PPUSH
105179: CALL_OW 1
105183: ST_TO_ADDR
// end ; end ;
105184: GO 105013
105186: POP
105187: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105188: LD_VAR 0 1
105192: PPUSH
105193: LD_EXP 196
105197: PUSH
105198: LD_VAR 0 4
105202: ARRAY
105203: PUSH
105204: LD_INT 0
105206: PLUS
105207: PPUSH
105208: CALL_OW 505
// end ;
105212: LD_VAR 0 2
105216: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
105217: LD_INT 0
105219: PPUSH
105220: PPUSH
105221: PPUSH
105222: PPUSH
// if not hack in hackTanks then
105223: LD_VAR 0 1
105227: PUSH
105228: LD_EXP 195
105232: IN
105233: NOT
105234: IFFALSE 105238
// exit ;
105236: GO 105323
// index := GetElementIndex ( hackTanks , hack ) ;
105238: LD_ADDR_VAR 0 5
105242: PUSH
105243: LD_EXP 195
105247: PPUSH
105248: LD_VAR 0 1
105252: PPUSH
105253: CALL 56052 0 2
105257: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105258: LD_ADDR_VAR 0 4
105262: PUSH
105263: DOUBLE
105264: LD_INT 1
105266: DEC
105267: ST_TO_ADDR
105268: LD_EXP 196
105272: PUSH
105273: LD_VAR 0 5
105277: ARRAY
105278: PUSH
105279: FOR_TO
105280: IFFALSE 105321
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105282: LD_EXP 196
105286: PUSH
105287: LD_VAR 0 5
105291: ARRAY
105292: PUSH
105293: LD_VAR 0 4
105297: ARRAY
105298: PUSH
105299: LD_INT 1
105301: ARRAY
105302: PUSH
105303: LD_VAR 0 2
105307: EQUAL
105308: IFFALSE 105319
// KillUnit ( vehicle ) ;
105310: LD_VAR 0 2
105314: PPUSH
105315: CALL_OW 66
105319: GO 105279
105321: POP
105322: POP
// end ;
105323: LD_VAR 0 3
105327: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105328: LD_EXP 200
105332: NOT
105333: IFFALSE 105368
105335: GO 105337
105337: DISABLE
// begin initMiner := true ;
105338: LD_ADDR_EXP 200
105342: PUSH
105343: LD_INT 1
105345: ST_TO_ADDR
// minersList := [ ] ;
105346: LD_ADDR_EXP 201
105350: PUSH
105351: EMPTY
105352: ST_TO_ADDR
// minerMinesList := [ ] ;
105353: LD_ADDR_EXP 202
105357: PUSH
105358: EMPTY
105359: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105360: LD_ADDR_EXP 203
105364: PUSH
105365: LD_INT 5
105367: ST_TO_ADDR
// end ;
105368: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105369: LD_EXP 200
105373: PUSH
105374: LD_INT 34
105376: PUSH
105377: LD_EXP 79
105381: PUSH
105382: EMPTY
105383: LIST
105384: LIST
105385: PPUSH
105386: CALL_OW 69
105390: AND
105391: IFFALSE 105854
105393: GO 105395
105395: DISABLE
105396: LD_INT 0
105398: PPUSH
105399: PPUSH
105400: PPUSH
105401: PPUSH
// begin enable ;
105402: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105403: LD_ADDR_VAR 0 1
105407: PUSH
105408: LD_INT 34
105410: PUSH
105411: LD_EXP 79
105415: PUSH
105416: EMPTY
105417: LIST
105418: LIST
105419: PPUSH
105420: CALL_OW 69
105424: PUSH
105425: FOR_IN
105426: IFFALSE 105498
// begin if not i in minersList then
105428: LD_VAR 0 1
105432: PUSH
105433: LD_EXP 201
105437: IN
105438: NOT
105439: IFFALSE 105496
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105441: LD_ADDR_EXP 201
105445: PUSH
105446: LD_EXP 201
105450: PPUSH
105451: LD_EXP 201
105455: PUSH
105456: LD_INT 1
105458: PLUS
105459: PPUSH
105460: LD_VAR 0 1
105464: PPUSH
105465: CALL_OW 1
105469: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105470: LD_ADDR_EXP 202
105474: PUSH
105475: LD_EXP 202
105479: PPUSH
105480: LD_EXP 202
105484: PUSH
105485: LD_INT 1
105487: PLUS
105488: PPUSH
105489: EMPTY
105490: PPUSH
105491: CALL_OW 1
105495: ST_TO_ADDR
// end end ;
105496: GO 105425
105498: POP
105499: POP
// for i := minerMinesList downto 1 do
105500: LD_ADDR_VAR 0 1
105504: PUSH
105505: DOUBLE
105506: LD_EXP 202
105510: INC
105511: ST_TO_ADDR
105512: LD_INT 1
105514: PUSH
105515: FOR_DOWNTO
105516: IFFALSE 105852
// begin if IsLive ( minersList [ i ] ) then
105518: LD_EXP 201
105522: PUSH
105523: LD_VAR 0 1
105527: ARRAY
105528: PPUSH
105529: CALL_OW 300
105533: IFFALSE 105561
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105535: LD_EXP 201
105539: PUSH
105540: LD_VAR 0 1
105544: ARRAY
105545: PPUSH
105546: LD_EXP 202
105550: PUSH
105551: LD_VAR 0 1
105555: ARRAY
105556: PPUSH
105557: CALL_OW 505
// if not minerMinesList [ i ] then
105561: LD_EXP 202
105565: PUSH
105566: LD_VAR 0 1
105570: ARRAY
105571: NOT
105572: IFFALSE 105576
// continue ;
105574: GO 105515
// for j := minerMinesList [ i ] downto 1 do
105576: LD_ADDR_VAR 0 2
105580: PUSH
105581: DOUBLE
105582: LD_EXP 202
105586: PUSH
105587: LD_VAR 0 1
105591: ARRAY
105592: INC
105593: ST_TO_ADDR
105594: LD_INT 1
105596: PUSH
105597: FOR_DOWNTO
105598: IFFALSE 105848
// begin side := GetSide ( minersList [ i ] ) ;
105600: LD_ADDR_VAR 0 3
105604: PUSH
105605: LD_EXP 201
105609: PUSH
105610: LD_VAR 0 1
105614: ARRAY
105615: PPUSH
105616: CALL_OW 255
105620: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105621: LD_ADDR_VAR 0 4
105625: PUSH
105626: LD_EXP 202
105630: PUSH
105631: LD_VAR 0 1
105635: ARRAY
105636: PUSH
105637: LD_VAR 0 2
105641: ARRAY
105642: PUSH
105643: LD_INT 1
105645: ARRAY
105646: PPUSH
105647: LD_EXP 202
105651: PUSH
105652: LD_VAR 0 1
105656: ARRAY
105657: PUSH
105658: LD_VAR 0 2
105662: ARRAY
105663: PUSH
105664: LD_INT 2
105666: ARRAY
105667: PPUSH
105668: CALL_OW 428
105672: ST_TO_ADDR
// if not tmp then
105673: LD_VAR 0 4
105677: NOT
105678: IFFALSE 105682
// continue ;
105680: GO 105597
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105682: LD_VAR 0 4
105686: PUSH
105687: LD_INT 81
105689: PUSH
105690: LD_VAR 0 3
105694: PUSH
105695: EMPTY
105696: LIST
105697: LIST
105698: PPUSH
105699: CALL_OW 69
105703: IN
105704: PUSH
105705: LD_EXP 202
105709: PUSH
105710: LD_VAR 0 1
105714: ARRAY
105715: PUSH
105716: LD_VAR 0 2
105720: ARRAY
105721: PUSH
105722: LD_INT 1
105724: ARRAY
105725: PPUSH
105726: LD_EXP 202
105730: PUSH
105731: LD_VAR 0 1
105735: ARRAY
105736: PUSH
105737: LD_VAR 0 2
105741: ARRAY
105742: PUSH
105743: LD_INT 2
105745: ARRAY
105746: PPUSH
105747: CALL_OW 458
105751: AND
105752: IFFALSE 105846
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
105754: LD_EXP 202
105758: PUSH
105759: LD_VAR 0 1
105763: ARRAY
105764: PUSH
105765: LD_VAR 0 2
105769: ARRAY
105770: PUSH
105771: LD_INT 1
105773: ARRAY
105774: PPUSH
105775: LD_EXP 202
105779: PUSH
105780: LD_VAR 0 1
105784: ARRAY
105785: PUSH
105786: LD_VAR 0 2
105790: ARRAY
105791: PUSH
105792: LD_INT 2
105794: ARRAY
105795: PPUSH
105796: LD_VAR 0 3
105800: PPUSH
105801: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105805: LD_ADDR_EXP 202
105809: PUSH
105810: LD_EXP 202
105814: PPUSH
105815: LD_VAR 0 1
105819: PPUSH
105820: LD_EXP 202
105824: PUSH
105825: LD_VAR 0 1
105829: ARRAY
105830: PPUSH
105831: LD_VAR 0 2
105835: PPUSH
105836: CALL_OW 3
105840: PPUSH
105841: CALL_OW 1
105845: ST_TO_ADDR
// end ; end ;
105846: GO 105597
105848: POP
105849: POP
// end ;
105850: GO 105515
105852: POP
105853: POP
// end ;
105854: PPOPN 4
105856: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105857: LD_INT 0
105859: PPUSH
105860: PPUSH
// result := false ;
105861: LD_ADDR_VAR 0 4
105865: PUSH
105866: LD_INT 0
105868: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105869: LD_VAR 0 1
105873: PPUSH
105874: CALL_OW 264
105878: PUSH
105879: LD_EXP 79
105883: EQUAL
105884: NOT
105885: IFFALSE 105889
// exit ;
105887: GO 106129
// index := GetElementIndex ( minersList , unit ) ;
105889: LD_ADDR_VAR 0 5
105893: PUSH
105894: LD_EXP 201
105898: PPUSH
105899: LD_VAR 0 1
105903: PPUSH
105904: CALL 56052 0 2
105908: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105909: LD_EXP 202
105913: PUSH
105914: LD_VAR 0 5
105918: ARRAY
105919: PUSH
105920: LD_EXP 203
105924: GREATEREQUAL
105925: IFFALSE 105929
// exit ;
105927: GO 106129
// ComMoveXY ( unit , x , y ) ;
105929: LD_VAR 0 1
105933: PPUSH
105934: LD_VAR 0 2
105938: PPUSH
105939: LD_VAR 0 3
105943: PPUSH
105944: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105948: LD_INT 35
105950: PPUSH
105951: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105955: LD_VAR 0 1
105959: PPUSH
105960: LD_VAR 0 2
105964: PPUSH
105965: LD_VAR 0 3
105969: PPUSH
105970: CALL 86824 0 3
105974: NOT
105975: PUSH
105976: LD_VAR 0 1
105980: PPUSH
105981: CALL_OW 314
105985: AND
105986: IFFALSE 105990
// exit ;
105988: GO 106129
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105990: LD_VAR 0 2
105994: PPUSH
105995: LD_VAR 0 3
105999: PPUSH
106000: CALL_OW 428
106004: PUSH
106005: LD_VAR 0 1
106009: EQUAL
106010: PUSH
106011: LD_VAR 0 1
106015: PPUSH
106016: CALL_OW 314
106020: NOT
106021: AND
106022: IFFALSE 105948
// PlaySoundXY ( x , y , PlantMine ) ;
106024: LD_VAR 0 2
106028: PPUSH
106029: LD_VAR 0 3
106033: PPUSH
106034: LD_STRING PlantMine
106036: PPUSH
106037: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106041: LD_VAR 0 2
106045: PPUSH
106046: LD_VAR 0 3
106050: PPUSH
106051: LD_VAR 0 1
106055: PPUSH
106056: CALL_OW 255
106060: PPUSH
106061: LD_INT 0
106063: PPUSH
106064: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106068: LD_ADDR_EXP 202
106072: PUSH
106073: LD_EXP 202
106077: PPUSH
106078: LD_VAR 0 5
106082: PUSH
106083: LD_EXP 202
106087: PUSH
106088: LD_VAR 0 5
106092: ARRAY
106093: PUSH
106094: LD_INT 1
106096: PLUS
106097: PUSH
106098: EMPTY
106099: LIST
106100: LIST
106101: PPUSH
106102: LD_VAR 0 2
106106: PUSH
106107: LD_VAR 0 3
106111: PUSH
106112: EMPTY
106113: LIST
106114: LIST
106115: PPUSH
106116: CALL 56267 0 3
106120: ST_TO_ADDR
// result := true ;
106121: LD_ADDR_VAR 0 4
106125: PUSH
106126: LD_INT 1
106128: ST_TO_ADDR
// end ;
106129: LD_VAR 0 4
106133: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
106134: LD_INT 0
106136: PPUSH
106137: PPUSH
106138: PPUSH
// if not unit in minersList then
106139: LD_VAR 0 1
106143: PUSH
106144: LD_EXP 201
106148: IN
106149: NOT
106150: IFFALSE 106154
// exit ;
106152: GO 106546
// index := GetElementIndex ( minersList , unit ) ;
106154: LD_ADDR_VAR 0 6
106158: PUSH
106159: LD_EXP 201
106163: PPUSH
106164: LD_VAR 0 1
106168: PPUSH
106169: CALL 56052 0 2
106173: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
106174: LD_ADDR_VAR 0 5
106178: PUSH
106179: DOUBLE
106180: LD_EXP 202
106184: PUSH
106185: LD_VAR 0 6
106189: ARRAY
106190: INC
106191: ST_TO_ADDR
106192: LD_INT 1
106194: PUSH
106195: FOR_DOWNTO
106196: IFFALSE 106357
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106198: LD_EXP 202
106202: PUSH
106203: LD_VAR 0 6
106207: ARRAY
106208: PUSH
106209: LD_VAR 0 5
106213: ARRAY
106214: PUSH
106215: LD_INT 1
106217: ARRAY
106218: PUSH
106219: LD_VAR 0 2
106223: EQUAL
106224: PUSH
106225: LD_EXP 202
106229: PUSH
106230: LD_VAR 0 6
106234: ARRAY
106235: PUSH
106236: LD_VAR 0 5
106240: ARRAY
106241: PUSH
106242: LD_INT 2
106244: ARRAY
106245: PUSH
106246: LD_VAR 0 3
106250: EQUAL
106251: AND
106252: IFFALSE 106355
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106254: LD_EXP 202
106258: PUSH
106259: LD_VAR 0 6
106263: ARRAY
106264: PUSH
106265: LD_VAR 0 5
106269: ARRAY
106270: PUSH
106271: LD_INT 1
106273: ARRAY
106274: PPUSH
106275: LD_EXP 202
106279: PUSH
106280: LD_VAR 0 6
106284: ARRAY
106285: PUSH
106286: LD_VAR 0 5
106290: ARRAY
106291: PUSH
106292: LD_INT 2
106294: ARRAY
106295: PPUSH
106296: LD_VAR 0 1
106300: PPUSH
106301: CALL_OW 255
106305: PPUSH
106306: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106310: LD_ADDR_EXP 202
106314: PUSH
106315: LD_EXP 202
106319: PPUSH
106320: LD_VAR 0 6
106324: PPUSH
106325: LD_EXP 202
106329: PUSH
106330: LD_VAR 0 6
106334: ARRAY
106335: PPUSH
106336: LD_VAR 0 5
106340: PPUSH
106341: CALL_OW 3
106345: PPUSH
106346: CALL_OW 1
106350: ST_TO_ADDR
// exit ;
106351: POP
106352: POP
106353: GO 106546
// end ; end ;
106355: GO 106195
106357: POP
106358: POP
// for i := minerMinesList [ index ] downto 1 do
106359: LD_ADDR_VAR 0 5
106363: PUSH
106364: DOUBLE
106365: LD_EXP 202
106369: PUSH
106370: LD_VAR 0 6
106374: ARRAY
106375: INC
106376: ST_TO_ADDR
106377: LD_INT 1
106379: PUSH
106380: FOR_DOWNTO
106381: IFFALSE 106544
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106383: LD_EXP 202
106387: PUSH
106388: LD_VAR 0 6
106392: ARRAY
106393: PUSH
106394: LD_VAR 0 5
106398: ARRAY
106399: PUSH
106400: LD_INT 1
106402: ARRAY
106403: PPUSH
106404: LD_EXP 202
106408: PUSH
106409: LD_VAR 0 6
106413: ARRAY
106414: PUSH
106415: LD_VAR 0 5
106419: ARRAY
106420: PUSH
106421: LD_INT 2
106423: ARRAY
106424: PPUSH
106425: LD_VAR 0 2
106429: PPUSH
106430: LD_VAR 0 3
106434: PPUSH
106435: CALL_OW 298
106439: PUSH
106440: LD_INT 6
106442: LESS
106443: IFFALSE 106542
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106445: LD_EXP 202
106449: PUSH
106450: LD_VAR 0 6
106454: ARRAY
106455: PUSH
106456: LD_VAR 0 5
106460: ARRAY
106461: PUSH
106462: LD_INT 1
106464: ARRAY
106465: PPUSH
106466: LD_EXP 202
106470: PUSH
106471: LD_VAR 0 6
106475: ARRAY
106476: PUSH
106477: LD_VAR 0 5
106481: ARRAY
106482: PUSH
106483: LD_INT 2
106485: ARRAY
106486: PPUSH
106487: LD_VAR 0 1
106491: PPUSH
106492: CALL_OW 255
106496: PPUSH
106497: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106501: LD_ADDR_EXP 202
106505: PUSH
106506: LD_EXP 202
106510: PPUSH
106511: LD_VAR 0 6
106515: PPUSH
106516: LD_EXP 202
106520: PUSH
106521: LD_VAR 0 6
106525: ARRAY
106526: PPUSH
106527: LD_VAR 0 5
106531: PPUSH
106532: CALL_OW 3
106536: PPUSH
106537: CALL_OW 1
106541: ST_TO_ADDR
// end ; end ;
106542: GO 106380
106544: POP
106545: POP
// end ;
106546: LD_VAR 0 4
106550: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106551: LD_INT 0
106553: PPUSH
106554: PPUSH
106555: PPUSH
106556: PPUSH
106557: PPUSH
106558: PPUSH
106559: PPUSH
106560: PPUSH
106561: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106562: LD_VAR 0 1
106566: PPUSH
106567: CALL_OW 264
106571: PUSH
106572: LD_EXP 79
106576: EQUAL
106577: NOT
106578: PUSH
106579: LD_VAR 0 1
106583: PUSH
106584: LD_EXP 201
106588: IN
106589: NOT
106590: OR
106591: IFFALSE 106595
// exit ;
106593: GO 106917
// index := GetElementIndex ( minersList , unit ) ;
106595: LD_ADDR_VAR 0 6
106599: PUSH
106600: LD_EXP 201
106604: PPUSH
106605: LD_VAR 0 1
106609: PPUSH
106610: CALL 56052 0 2
106614: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106615: LD_ADDR_VAR 0 8
106619: PUSH
106620: LD_EXP 203
106624: PUSH
106625: LD_EXP 202
106629: PUSH
106630: LD_VAR 0 6
106634: ARRAY
106635: MINUS
106636: ST_TO_ADDR
// if not minesFreeAmount then
106637: LD_VAR 0 8
106641: NOT
106642: IFFALSE 106646
// exit ;
106644: GO 106917
// tmp := [ ] ;
106646: LD_ADDR_VAR 0 7
106650: PUSH
106651: EMPTY
106652: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106653: LD_ADDR_VAR 0 5
106657: PUSH
106658: DOUBLE
106659: LD_INT 1
106661: DEC
106662: ST_TO_ADDR
106663: LD_VAR 0 8
106667: PUSH
106668: FOR_TO
106669: IFFALSE 106864
// begin _d := rand ( 0 , 5 ) ;
106671: LD_ADDR_VAR 0 11
106675: PUSH
106676: LD_INT 0
106678: PPUSH
106679: LD_INT 5
106681: PPUSH
106682: CALL_OW 12
106686: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106687: LD_ADDR_VAR 0 12
106691: PUSH
106692: LD_INT 2
106694: PPUSH
106695: LD_INT 6
106697: PPUSH
106698: CALL_OW 12
106702: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106703: LD_ADDR_VAR 0 9
106707: PUSH
106708: LD_VAR 0 2
106712: PPUSH
106713: LD_VAR 0 11
106717: PPUSH
106718: LD_VAR 0 12
106722: PPUSH
106723: CALL_OW 272
106727: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
106728: LD_ADDR_VAR 0 10
106732: PUSH
106733: LD_VAR 0 3
106737: PPUSH
106738: LD_VAR 0 11
106742: PPUSH
106743: LD_VAR 0 12
106747: PPUSH
106748: CALL_OW 273
106752: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
106753: LD_VAR 0 9
106757: PPUSH
106758: LD_VAR 0 10
106762: PPUSH
106763: CALL_OW 488
106767: PUSH
106768: LD_VAR 0 9
106772: PUSH
106773: LD_VAR 0 10
106777: PUSH
106778: EMPTY
106779: LIST
106780: LIST
106781: PUSH
106782: LD_VAR 0 7
106786: IN
106787: NOT
106788: AND
106789: PUSH
106790: LD_VAR 0 9
106794: PPUSH
106795: LD_VAR 0 10
106799: PPUSH
106800: CALL_OW 458
106804: NOT
106805: AND
106806: IFFALSE 106848
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106808: LD_ADDR_VAR 0 7
106812: PUSH
106813: LD_VAR 0 7
106817: PPUSH
106818: LD_VAR 0 7
106822: PUSH
106823: LD_INT 1
106825: PLUS
106826: PPUSH
106827: LD_VAR 0 9
106831: PUSH
106832: LD_VAR 0 10
106836: PUSH
106837: EMPTY
106838: LIST
106839: LIST
106840: PPUSH
106841: CALL_OW 1
106845: ST_TO_ADDR
106846: GO 106862
// i := i - 1 ;
106848: LD_ADDR_VAR 0 5
106852: PUSH
106853: LD_VAR 0 5
106857: PUSH
106858: LD_INT 1
106860: MINUS
106861: ST_TO_ADDR
// end ;
106862: GO 106668
106864: POP
106865: POP
// for i in tmp do
106866: LD_ADDR_VAR 0 5
106870: PUSH
106871: LD_VAR 0 7
106875: PUSH
106876: FOR_IN
106877: IFFALSE 106915
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106879: LD_VAR 0 1
106883: PPUSH
106884: LD_VAR 0 5
106888: PUSH
106889: LD_INT 1
106891: ARRAY
106892: PPUSH
106893: LD_VAR 0 5
106897: PUSH
106898: LD_INT 2
106900: ARRAY
106901: PPUSH
106902: CALL 105857 0 3
106906: NOT
106907: IFFALSE 106913
// exit ;
106909: POP
106910: POP
106911: GO 106917
106913: GO 106876
106915: POP
106916: POP
// end ;
106917: LD_VAR 0 4
106921: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106922: LD_INT 0
106924: PPUSH
106925: PPUSH
106926: PPUSH
106927: PPUSH
106928: PPUSH
106929: PPUSH
106930: PPUSH
// if not GetClass ( unit ) = class_sniper then
106931: LD_VAR 0 1
106935: PPUSH
106936: CALL_OW 257
106940: PUSH
106941: LD_INT 5
106943: EQUAL
106944: NOT
106945: IFFALSE 106949
// exit ;
106947: GO 107337
// dist := 8 ;
106949: LD_ADDR_VAR 0 5
106953: PUSH
106954: LD_INT 8
106956: ST_TO_ADDR
// viewRange := 12 ;
106957: LD_ADDR_VAR 0 7
106961: PUSH
106962: LD_INT 12
106964: ST_TO_ADDR
// side := GetSide ( unit ) ;
106965: LD_ADDR_VAR 0 6
106969: PUSH
106970: LD_VAR 0 1
106974: PPUSH
106975: CALL_OW 255
106979: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106980: LD_INT 61
106982: PPUSH
106983: LD_VAR 0 6
106987: PPUSH
106988: CALL_OW 321
106992: PUSH
106993: LD_INT 2
106995: EQUAL
106996: IFFALSE 107006
// viewRange := 16 ;
106998: LD_ADDR_VAR 0 7
107002: PUSH
107003: LD_INT 16
107005: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107006: LD_VAR 0 1
107010: PPUSH
107011: LD_VAR 0 2
107015: PPUSH
107016: LD_VAR 0 3
107020: PPUSH
107021: CALL_OW 297
107025: PUSH
107026: LD_VAR 0 5
107030: GREATER
107031: IFFALSE 107110
// begin ComMoveXY ( unit , x , y ) ;
107033: LD_VAR 0 1
107037: PPUSH
107038: LD_VAR 0 2
107042: PPUSH
107043: LD_VAR 0 3
107047: PPUSH
107048: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107052: LD_INT 35
107054: PPUSH
107055: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107059: LD_VAR 0 1
107063: PPUSH
107064: LD_VAR 0 2
107068: PPUSH
107069: LD_VAR 0 3
107073: PPUSH
107074: CALL 86824 0 3
107078: NOT
107079: IFFALSE 107083
// exit ;
107081: GO 107337
// until GetDistUnitXY ( unit , x , y ) < dist ;
107083: LD_VAR 0 1
107087: PPUSH
107088: LD_VAR 0 2
107092: PPUSH
107093: LD_VAR 0 3
107097: PPUSH
107098: CALL_OW 297
107102: PUSH
107103: LD_VAR 0 5
107107: LESS
107108: IFFALSE 107052
// end ; ComTurnXY ( unit , x , y ) ;
107110: LD_VAR 0 1
107114: PPUSH
107115: LD_VAR 0 2
107119: PPUSH
107120: LD_VAR 0 3
107124: PPUSH
107125: CALL_OW 118
// wait ( 5 ) ;
107129: LD_INT 5
107131: PPUSH
107132: CALL_OW 67
// _d := GetDir ( unit ) ;
107136: LD_ADDR_VAR 0 10
107140: PUSH
107141: LD_VAR 0 1
107145: PPUSH
107146: CALL_OW 254
107150: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
107151: LD_ADDR_VAR 0 8
107155: PUSH
107156: LD_VAR 0 1
107160: PPUSH
107161: CALL_OW 250
107165: PPUSH
107166: LD_VAR 0 10
107170: PPUSH
107171: LD_VAR 0 5
107175: PPUSH
107176: CALL_OW 272
107180: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107181: LD_ADDR_VAR 0 9
107185: PUSH
107186: LD_VAR 0 1
107190: PPUSH
107191: CALL_OW 251
107195: PPUSH
107196: LD_VAR 0 10
107200: PPUSH
107201: LD_VAR 0 5
107205: PPUSH
107206: CALL_OW 273
107210: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107211: LD_VAR 0 8
107215: PPUSH
107216: LD_VAR 0 9
107220: PPUSH
107221: CALL_OW 488
107225: NOT
107226: IFFALSE 107230
// exit ;
107228: GO 107337
// ComAnimCustom ( unit , 1 ) ;
107230: LD_VAR 0 1
107234: PPUSH
107235: LD_INT 1
107237: PPUSH
107238: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107242: LD_VAR 0 8
107246: PPUSH
107247: LD_VAR 0 9
107251: PPUSH
107252: LD_VAR 0 6
107256: PPUSH
107257: LD_VAR 0 7
107261: PPUSH
107262: CALL_OW 330
// repeat wait ( 1 ) ;
107266: LD_INT 1
107268: PPUSH
107269: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107273: LD_VAR 0 1
107277: PPUSH
107278: CALL_OW 316
107282: PUSH
107283: LD_VAR 0 1
107287: PPUSH
107288: CALL_OW 314
107292: OR
107293: PUSH
107294: LD_VAR 0 1
107298: PPUSH
107299: CALL_OW 302
107303: NOT
107304: OR
107305: PUSH
107306: LD_VAR 0 1
107310: PPUSH
107311: CALL_OW 301
107315: OR
107316: IFFALSE 107266
// RemoveSeeing ( _x , _y , side ) ;
107318: LD_VAR 0 8
107322: PPUSH
107323: LD_VAR 0 9
107327: PPUSH
107328: LD_VAR 0 6
107332: PPUSH
107333: CALL_OW 331
// end ; end_of_file
107337: LD_VAR 0 4
107341: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107342: LD_INT 0
107344: PPUSH
107345: PPUSH
107346: PPUSH
107347: PPUSH
107348: PPUSH
107349: PPUSH
107350: PPUSH
107351: PPUSH
107352: PPUSH
107353: PPUSH
107354: PPUSH
107355: PPUSH
107356: PPUSH
107357: PPUSH
107358: PPUSH
107359: PPUSH
107360: PPUSH
107361: PPUSH
107362: PPUSH
107363: PPUSH
107364: PPUSH
107365: PPUSH
107366: PPUSH
107367: PPUSH
107368: PPUSH
107369: PPUSH
107370: PPUSH
107371: PPUSH
107372: PPUSH
107373: PPUSH
107374: PPUSH
107375: PPUSH
107376: PPUSH
107377: PPUSH
// if not list then
107378: LD_VAR 0 1
107382: NOT
107383: IFFALSE 107387
// exit ;
107385: GO 112046
// base := list [ 1 ] ;
107387: LD_ADDR_VAR 0 3
107391: PUSH
107392: LD_VAR 0 1
107396: PUSH
107397: LD_INT 1
107399: ARRAY
107400: ST_TO_ADDR
// group := list [ 2 ] ;
107401: LD_ADDR_VAR 0 4
107405: PUSH
107406: LD_VAR 0 1
107410: PUSH
107411: LD_INT 2
107413: ARRAY
107414: ST_TO_ADDR
// path := list [ 3 ] ;
107415: LD_ADDR_VAR 0 5
107419: PUSH
107420: LD_VAR 0 1
107424: PUSH
107425: LD_INT 3
107427: ARRAY
107428: ST_TO_ADDR
// flags := list [ 4 ] ;
107429: LD_ADDR_VAR 0 6
107433: PUSH
107434: LD_VAR 0 1
107438: PUSH
107439: LD_INT 4
107441: ARRAY
107442: ST_TO_ADDR
// mined := [ ] ;
107443: LD_ADDR_VAR 0 27
107447: PUSH
107448: EMPTY
107449: ST_TO_ADDR
// bombed := [ ] ;
107450: LD_ADDR_VAR 0 28
107454: PUSH
107455: EMPTY
107456: ST_TO_ADDR
// healers := [ ] ;
107457: LD_ADDR_VAR 0 31
107461: PUSH
107462: EMPTY
107463: ST_TO_ADDR
// to_heal := [ ] ;
107464: LD_ADDR_VAR 0 30
107468: PUSH
107469: EMPTY
107470: ST_TO_ADDR
// repairs := [ ] ;
107471: LD_ADDR_VAR 0 33
107475: PUSH
107476: EMPTY
107477: ST_TO_ADDR
// to_repair := [ ] ;
107478: LD_ADDR_VAR 0 32
107482: PUSH
107483: EMPTY
107484: ST_TO_ADDR
// if not group or not path then
107485: LD_VAR 0 4
107489: NOT
107490: PUSH
107491: LD_VAR 0 5
107495: NOT
107496: OR
107497: IFFALSE 107501
// exit ;
107499: GO 112046
// side := GetSide ( group [ 1 ] ) ;
107501: LD_ADDR_VAR 0 35
107505: PUSH
107506: LD_VAR 0 4
107510: PUSH
107511: LD_INT 1
107513: ARRAY
107514: PPUSH
107515: CALL_OW 255
107519: ST_TO_ADDR
// if flags then
107520: LD_VAR 0 6
107524: IFFALSE 107668
// begin f_ignore_area := flags [ 1 ] ;
107526: LD_ADDR_VAR 0 17
107530: PUSH
107531: LD_VAR 0 6
107535: PUSH
107536: LD_INT 1
107538: ARRAY
107539: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107540: LD_ADDR_VAR 0 18
107544: PUSH
107545: LD_VAR 0 6
107549: PUSH
107550: LD_INT 2
107552: ARRAY
107553: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107554: LD_ADDR_VAR 0 19
107558: PUSH
107559: LD_VAR 0 6
107563: PUSH
107564: LD_INT 3
107566: ARRAY
107567: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107568: LD_ADDR_VAR 0 20
107572: PUSH
107573: LD_VAR 0 6
107577: PUSH
107578: LD_INT 4
107580: ARRAY
107581: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107582: LD_ADDR_VAR 0 21
107586: PUSH
107587: LD_VAR 0 6
107591: PUSH
107592: LD_INT 5
107594: ARRAY
107595: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107596: LD_ADDR_VAR 0 22
107600: PUSH
107601: LD_VAR 0 6
107605: PUSH
107606: LD_INT 6
107608: ARRAY
107609: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107610: LD_ADDR_VAR 0 23
107614: PUSH
107615: LD_VAR 0 6
107619: PUSH
107620: LD_INT 7
107622: ARRAY
107623: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107624: LD_ADDR_VAR 0 24
107628: PUSH
107629: LD_VAR 0 6
107633: PUSH
107634: LD_INT 8
107636: ARRAY
107637: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107638: LD_ADDR_VAR 0 25
107642: PUSH
107643: LD_VAR 0 6
107647: PUSH
107648: LD_INT 9
107650: ARRAY
107651: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107652: LD_ADDR_VAR 0 26
107656: PUSH
107657: LD_VAR 0 6
107661: PUSH
107662: LD_INT 10
107664: ARRAY
107665: ST_TO_ADDR
// end else
107666: GO 107748
// begin f_ignore_area := false ;
107668: LD_ADDR_VAR 0 17
107672: PUSH
107673: LD_INT 0
107675: ST_TO_ADDR
// f_capture := false ;
107676: LD_ADDR_VAR 0 18
107680: PUSH
107681: LD_INT 0
107683: ST_TO_ADDR
// f_ignore_civ := false ;
107684: LD_ADDR_VAR 0 19
107688: PUSH
107689: LD_INT 0
107691: ST_TO_ADDR
// f_murder := false ;
107692: LD_ADDR_VAR 0 20
107696: PUSH
107697: LD_INT 0
107699: ST_TO_ADDR
// f_mines := false ;
107700: LD_ADDR_VAR 0 21
107704: PUSH
107705: LD_INT 0
107707: ST_TO_ADDR
// f_repair := false ;
107708: LD_ADDR_VAR 0 22
107712: PUSH
107713: LD_INT 0
107715: ST_TO_ADDR
// f_heal := false ;
107716: LD_ADDR_VAR 0 23
107720: PUSH
107721: LD_INT 0
107723: ST_TO_ADDR
// f_spacetime := false ;
107724: LD_ADDR_VAR 0 24
107728: PUSH
107729: LD_INT 0
107731: ST_TO_ADDR
// f_attack_depot := false ;
107732: LD_ADDR_VAR 0 25
107736: PUSH
107737: LD_INT 0
107739: ST_TO_ADDR
// f_crawl := false ;
107740: LD_ADDR_VAR 0 26
107744: PUSH
107745: LD_INT 0
107747: ST_TO_ADDR
// end ; if f_heal then
107748: LD_VAR 0 23
107752: IFFALSE 107779
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
107754: LD_ADDR_VAR 0 31
107758: PUSH
107759: LD_VAR 0 4
107763: PPUSH
107764: LD_INT 25
107766: PUSH
107767: LD_INT 4
107769: PUSH
107770: EMPTY
107771: LIST
107772: LIST
107773: PPUSH
107774: CALL_OW 72
107778: ST_TO_ADDR
// if f_repair then
107779: LD_VAR 0 22
107783: IFFALSE 107810
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107785: LD_ADDR_VAR 0 33
107789: PUSH
107790: LD_VAR 0 4
107794: PPUSH
107795: LD_INT 25
107797: PUSH
107798: LD_INT 3
107800: PUSH
107801: EMPTY
107802: LIST
107803: LIST
107804: PPUSH
107805: CALL_OW 72
107809: ST_TO_ADDR
// units_path := [ ] ;
107810: LD_ADDR_VAR 0 16
107814: PUSH
107815: EMPTY
107816: ST_TO_ADDR
// for i = 1 to group do
107817: LD_ADDR_VAR 0 7
107821: PUSH
107822: DOUBLE
107823: LD_INT 1
107825: DEC
107826: ST_TO_ADDR
107827: LD_VAR 0 4
107831: PUSH
107832: FOR_TO
107833: IFFALSE 107862
// units_path := Replace ( units_path , i , path ) ;
107835: LD_ADDR_VAR 0 16
107839: PUSH
107840: LD_VAR 0 16
107844: PPUSH
107845: LD_VAR 0 7
107849: PPUSH
107850: LD_VAR 0 5
107854: PPUSH
107855: CALL_OW 1
107859: ST_TO_ADDR
107860: GO 107832
107862: POP
107863: POP
// repeat for i = group downto 1 do
107864: LD_ADDR_VAR 0 7
107868: PUSH
107869: DOUBLE
107870: LD_VAR 0 4
107874: INC
107875: ST_TO_ADDR
107876: LD_INT 1
107878: PUSH
107879: FOR_DOWNTO
107880: IFFALSE 112002
// begin wait ( 5 ) ;
107882: LD_INT 5
107884: PPUSH
107885: CALL_OW 67
// tmp := [ ] ;
107889: LD_ADDR_VAR 0 14
107893: PUSH
107894: EMPTY
107895: ST_TO_ADDR
// attacking := false ;
107896: LD_ADDR_VAR 0 29
107900: PUSH
107901: LD_INT 0
107903: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107904: LD_VAR 0 4
107908: PUSH
107909: LD_VAR 0 7
107913: ARRAY
107914: PPUSH
107915: CALL_OW 301
107919: PUSH
107920: LD_VAR 0 4
107924: PUSH
107925: LD_VAR 0 7
107929: ARRAY
107930: NOT
107931: OR
107932: IFFALSE 108041
// begin if GetType ( group [ i ] ) = unit_human then
107934: LD_VAR 0 4
107938: PUSH
107939: LD_VAR 0 7
107943: ARRAY
107944: PPUSH
107945: CALL_OW 247
107949: PUSH
107950: LD_INT 1
107952: EQUAL
107953: IFFALSE 107999
// begin to_heal := to_heal diff group [ i ] ;
107955: LD_ADDR_VAR 0 30
107959: PUSH
107960: LD_VAR 0 30
107964: PUSH
107965: LD_VAR 0 4
107969: PUSH
107970: LD_VAR 0 7
107974: ARRAY
107975: DIFF
107976: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107977: LD_ADDR_VAR 0 31
107981: PUSH
107982: LD_VAR 0 31
107986: PUSH
107987: LD_VAR 0 4
107991: PUSH
107992: LD_VAR 0 7
107996: ARRAY
107997: DIFF
107998: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107999: LD_ADDR_VAR 0 4
108003: PUSH
108004: LD_VAR 0 4
108008: PPUSH
108009: LD_VAR 0 7
108013: PPUSH
108014: CALL_OW 3
108018: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108019: LD_ADDR_VAR 0 16
108023: PUSH
108024: LD_VAR 0 16
108028: PPUSH
108029: LD_VAR 0 7
108033: PPUSH
108034: CALL_OW 3
108038: ST_TO_ADDR
// continue ;
108039: GO 107879
// end ; if f_repair then
108041: LD_VAR 0 22
108045: IFFALSE 108534
// begin if GetType ( group [ i ] ) = unit_vehicle then
108047: LD_VAR 0 4
108051: PUSH
108052: LD_VAR 0 7
108056: ARRAY
108057: PPUSH
108058: CALL_OW 247
108062: PUSH
108063: LD_INT 2
108065: EQUAL
108066: IFFALSE 108256
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108068: LD_VAR 0 4
108072: PUSH
108073: LD_VAR 0 7
108077: ARRAY
108078: PPUSH
108079: CALL_OW 256
108083: PUSH
108084: LD_INT 700
108086: LESS
108087: PUSH
108088: LD_VAR 0 4
108092: PUSH
108093: LD_VAR 0 7
108097: ARRAY
108098: PUSH
108099: LD_VAR 0 32
108103: IN
108104: NOT
108105: AND
108106: IFFALSE 108130
// to_repair := to_repair union group [ i ] ;
108108: LD_ADDR_VAR 0 32
108112: PUSH
108113: LD_VAR 0 32
108117: PUSH
108118: LD_VAR 0 4
108122: PUSH
108123: LD_VAR 0 7
108127: ARRAY
108128: UNION
108129: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
108130: LD_VAR 0 4
108134: PUSH
108135: LD_VAR 0 7
108139: ARRAY
108140: PPUSH
108141: CALL_OW 256
108145: PUSH
108146: LD_INT 1000
108148: EQUAL
108149: PUSH
108150: LD_VAR 0 4
108154: PUSH
108155: LD_VAR 0 7
108159: ARRAY
108160: PUSH
108161: LD_VAR 0 32
108165: IN
108166: AND
108167: IFFALSE 108191
// to_repair := to_repair diff group [ i ] ;
108169: LD_ADDR_VAR 0 32
108173: PUSH
108174: LD_VAR 0 32
108178: PUSH
108179: LD_VAR 0 4
108183: PUSH
108184: LD_VAR 0 7
108188: ARRAY
108189: DIFF
108190: ST_TO_ADDR
// if group [ i ] in to_repair then
108191: LD_VAR 0 4
108195: PUSH
108196: LD_VAR 0 7
108200: ARRAY
108201: PUSH
108202: LD_VAR 0 32
108206: IN
108207: IFFALSE 108254
// begin if not IsInArea ( group [ i ] , f_repair ) then
108209: LD_VAR 0 4
108213: PUSH
108214: LD_VAR 0 7
108218: ARRAY
108219: PPUSH
108220: LD_VAR 0 22
108224: PPUSH
108225: CALL_OW 308
108229: NOT
108230: IFFALSE 108252
// ComMoveToArea ( group [ i ] , f_repair ) ;
108232: LD_VAR 0 4
108236: PUSH
108237: LD_VAR 0 7
108241: ARRAY
108242: PPUSH
108243: LD_VAR 0 22
108247: PPUSH
108248: CALL_OW 113
// continue ;
108252: GO 107879
// end ; end else
108254: GO 108534
// if group [ i ] in repairs then
108256: LD_VAR 0 4
108260: PUSH
108261: LD_VAR 0 7
108265: ARRAY
108266: PUSH
108267: LD_VAR 0 33
108271: IN
108272: IFFALSE 108534
// begin if IsInUnit ( group [ i ] ) then
108274: LD_VAR 0 4
108278: PUSH
108279: LD_VAR 0 7
108283: ARRAY
108284: PPUSH
108285: CALL_OW 310
108289: IFFALSE 108357
// begin z := IsInUnit ( group [ i ] ) ;
108291: LD_ADDR_VAR 0 13
108295: PUSH
108296: LD_VAR 0 4
108300: PUSH
108301: LD_VAR 0 7
108305: ARRAY
108306: PPUSH
108307: CALL_OW 310
108311: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108312: LD_VAR 0 13
108316: PUSH
108317: LD_VAR 0 32
108321: IN
108322: PUSH
108323: LD_VAR 0 13
108327: PPUSH
108328: LD_VAR 0 22
108332: PPUSH
108333: CALL_OW 308
108337: AND
108338: IFFALSE 108355
// ComExitVehicle ( group [ i ] ) ;
108340: LD_VAR 0 4
108344: PUSH
108345: LD_VAR 0 7
108349: ARRAY
108350: PPUSH
108351: CALL_OW 121
// end else
108355: GO 108534
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108357: LD_ADDR_VAR 0 13
108361: PUSH
108362: LD_VAR 0 4
108366: PPUSH
108367: LD_INT 95
108369: PUSH
108370: LD_VAR 0 22
108374: PUSH
108375: EMPTY
108376: LIST
108377: LIST
108378: PUSH
108379: LD_INT 58
108381: PUSH
108382: EMPTY
108383: LIST
108384: PUSH
108385: EMPTY
108386: LIST
108387: LIST
108388: PPUSH
108389: CALL_OW 72
108393: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108394: LD_VAR 0 4
108398: PUSH
108399: LD_VAR 0 7
108403: ARRAY
108404: PPUSH
108405: CALL_OW 314
108409: NOT
108410: IFFALSE 108532
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108412: LD_ADDR_VAR 0 10
108416: PUSH
108417: LD_VAR 0 13
108421: PPUSH
108422: LD_VAR 0 4
108426: PUSH
108427: LD_VAR 0 7
108431: ARRAY
108432: PPUSH
108433: CALL_OW 74
108437: ST_TO_ADDR
// if not x then
108438: LD_VAR 0 10
108442: NOT
108443: IFFALSE 108447
// continue ;
108445: GO 107879
// if GetLives ( x ) < 1000 then
108447: LD_VAR 0 10
108451: PPUSH
108452: CALL_OW 256
108456: PUSH
108457: LD_INT 1000
108459: LESS
108460: IFFALSE 108484
// ComRepairVehicle ( group [ i ] , x ) else
108462: LD_VAR 0 4
108466: PUSH
108467: LD_VAR 0 7
108471: ARRAY
108472: PPUSH
108473: LD_VAR 0 10
108477: PPUSH
108478: CALL_OW 129
108482: GO 108532
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108484: LD_VAR 0 23
108488: PUSH
108489: LD_VAR 0 4
108493: PUSH
108494: LD_VAR 0 7
108498: ARRAY
108499: PPUSH
108500: CALL_OW 256
108504: PUSH
108505: LD_INT 1000
108507: LESS
108508: AND
108509: NOT
108510: IFFALSE 108532
// ComEnterUnit ( group [ i ] , x ) ;
108512: LD_VAR 0 4
108516: PUSH
108517: LD_VAR 0 7
108521: ARRAY
108522: PPUSH
108523: LD_VAR 0 10
108527: PPUSH
108528: CALL_OW 120
// end ; continue ;
108532: GO 107879
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108534: LD_VAR 0 23
108538: PUSH
108539: LD_VAR 0 4
108543: PUSH
108544: LD_VAR 0 7
108548: ARRAY
108549: PPUSH
108550: CALL_OW 247
108554: PUSH
108555: LD_INT 1
108557: EQUAL
108558: AND
108559: IFFALSE 109037
// begin if group [ i ] in healers then
108561: LD_VAR 0 4
108565: PUSH
108566: LD_VAR 0 7
108570: ARRAY
108571: PUSH
108572: LD_VAR 0 31
108576: IN
108577: IFFALSE 108850
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108579: LD_VAR 0 4
108583: PUSH
108584: LD_VAR 0 7
108588: ARRAY
108589: PPUSH
108590: LD_VAR 0 23
108594: PPUSH
108595: CALL_OW 308
108599: NOT
108600: PUSH
108601: LD_VAR 0 4
108605: PUSH
108606: LD_VAR 0 7
108610: ARRAY
108611: PPUSH
108612: CALL_OW 314
108616: NOT
108617: AND
108618: IFFALSE 108642
// ComMoveToArea ( group [ i ] , f_heal ) else
108620: LD_VAR 0 4
108624: PUSH
108625: LD_VAR 0 7
108629: ARRAY
108630: PPUSH
108631: LD_VAR 0 23
108635: PPUSH
108636: CALL_OW 113
108640: GO 108848
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108642: LD_VAR 0 4
108646: PUSH
108647: LD_VAR 0 7
108651: ARRAY
108652: PPUSH
108653: CALL 85347 0 1
108657: PPUSH
108658: CALL_OW 256
108662: PUSH
108663: LD_INT 1000
108665: EQUAL
108666: IFFALSE 108685
// ComStop ( group [ i ] ) else
108668: LD_VAR 0 4
108672: PUSH
108673: LD_VAR 0 7
108677: ARRAY
108678: PPUSH
108679: CALL_OW 141
108683: GO 108848
// if not HasTask ( group [ i ] ) and to_heal then
108685: LD_VAR 0 4
108689: PUSH
108690: LD_VAR 0 7
108694: ARRAY
108695: PPUSH
108696: CALL_OW 314
108700: NOT
108701: PUSH
108702: LD_VAR 0 30
108706: AND
108707: IFFALSE 108848
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108709: LD_ADDR_VAR 0 13
108713: PUSH
108714: LD_VAR 0 30
108718: PPUSH
108719: LD_INT 3
108721: PUSH
108722: LD_INT 54
108724: PUSH
108725: EMPTY
108726: LIST
108727: PUSH
108728: EMPTY
108729: LIST
108730: LIST
108731: PPUSH
108732: CALL_OW 72
108736: PPUSH
108737: LD_VAR 0 4
108741: PUSH
108742: LD_VAR 0 7
108746: ARRAY
108747: PPUSH
108748: CALL_OW 74
108752: ST_TO_ADDR
// if z then
108753: LD_VAR 0 13
108757: IFFALSE 108848
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
108759: LD_INT 91
108761: PUSH
108762: LD_VAR 0 13
108766: PUSH
108767: LD_INT 10
108769: PUSH
108770: EMPTY
108771: LIST
108772: LIST
108773: LIST
108774: PUSH
108775: LD_INT 81
108777: PUSH
108778: LD_VAR 0 13
108782: PPUSH
108783: CALL_OW 255
108787: PUSH
108788: EMPTY
108789: LIST
108790: LIST
108791: PUSH
108792: EMPTY
108793: LIST
108794: LIST
108795: PPUSH
108796: CALL_OW 69
108800: PUSH
108801: LD_INT 0
108803: EQUAL
108804: IFFALSE 108828
// ComHeal ( group [ i ] , z ) else
108806: LD_VAR 0 4
108810: PUSH
108811: LD_VAR 0 7
108815: ARRAY
108816: PPUSH
108817: LD_VAR 0 13
108821: PPUSH
108822: CALL_OW 128
108826: GO 108848
// ComMoveToArea ( group [ i ] , f_heal ) ;
108828: LD_VAR 0 4
108832: PUSH
108833: LD_VAR 0 7
108837: ARRAY
108838: PPUSH
108839: LD_VAR 0 23
108843: PPUSH
108844: CALL_OW 113
// end ; continue ;
108848: GO 107879
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108850: LD_VAR 0 4
108854: PUSH
108855: LD_VAR 0 7
108859: ARRAY
108860: PPUSH
108861: CALL_OW 256
108865: PUSH
108866: LD_INT 700
108868: LESS
108869: PUSH
108870: LD_VAR 0 4
108874: PUSH
108875: LD_VAR 0 7
108879: ARRAY
108880: PUSH
108881: LD_VAR 0 30
108885: IN
108886: NOT
108887: AND
108888: IFFALSE 108912
// to_heal := to_heal union group [ i ] ;
108890: LD_ADDR_VAR 0 30
108894: PUSH
108895: LD_VAR 0 30
108899: PUSH
108900: LD_VAR 0 4
108904: PUSH
108905: LD_VAR 0 7
108909: ARRAY
108910: UNION
108911: ST_TO_ADDR
// if group [ i ] in to_heal then
108912: LD_VAR 0 4
108916: PUSH
108917: LD_VAR 0 7
108921: ARRAY
108922: PUSH
108923: LD_VAR 0 30
108927: IN
108928: IFFALSE 109037
// begin if GetLives ( group [ i ] ) = 1000 then
108930: LD_VAR 0 4
108934: PUSH
108935: LD_VAR 0 7
108939: ARRAY
108940: PPUSH
108941: CALL_OW 256
108945: PUSH
108946: LD_INT 1000
108948: EQUAL
108949: IFFALSE 108975
// to_heal := to_heal diff group [ i ] else
108951: LD_ADDR_VAR 0 30
108955: PUSH
108956: LD_VAR 0 30
108960: PUSH
108961: LD_VAR 0 4
108965: PUSH
108966: LD_VAR 0 7
108970: ARRAY
108971: DIFF
108972: ST_TO_ADDR
108973: GO 109037
// begin if not IsInArea ( group [ i ] , to_heal ) then
108975: LD_VAR 0 4
108979: PUSH
108980: LD_VAR 0 7
108984: ARRAY
108985: PPUSH
108986: LD_VAR 0 30
108990: PPUSH
108991: CALL_OW 308
108995: NOT
108996: IFFALSE 109020
// ComMoveToArea ( group [ i ] , f_heal ) else
108998: LD_VAR 0 4
109002: PUSH
109003: LD_VAR 0 7
109007: ARRAY
109008: PPUSH
109009: LD_VAR 0 23
109013: PPUSH
109014: CALL_OW 113
109018: GO 109035
// ComHold ( group [ i ] ) ;
109020: LD_VAR 0 4
109024: PUSH
109025: LD_VAR 0 7
109029: ARRAY
109030: PPUSH
109031: CALL_OW 140
// continue ;
109035: GO 107879
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109037: LD_VAR 0 4
109041: PUSH
109042: LD_VAR 0 7
109046: ARRAY
109047: PPUSH
109048: LD_INT 10
109050: PPUSH
109051: CALL 83767 0 2
109055: NOT
109056: PUSH
109057: LD_VAR 0 16
109061: PUSH
109062: LD_VAR 0 7
109066: ARRAY
109067: PUSH
109068: EMPTY
109069: EQUAL
109070: NOT
109071: AND
109072: IFFALSE 109338
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109074: LD_VAR 0 4
109078: PUSH
109079: LD_VAR 0 7
109083: ARRAY
109084: PPUSH
109085: CALL_OW 262
109089: PUSH
109090: LD_INT 1
109092: PUSH
109093: LD_INT 2
109095: PUSH
109096: EMPTY
109097: LIST
109098: LIST
109099: IN
109100: IFFALSE 109141
// if GetFuel ( group [ i ] ) < 10 then
109102: LD_VAR 0 4
109106: PUSH
109107: LD_VAR 0 7
109111: ARRAY
109112: PPUSH
109113: CALL_OW 261
109117: PUSH
109118: LD_INT 10
109120: LESS
109121: IFFALSE 109141
// SetFuel ( group [ i ] , 12 ) ;
109123: LD_VAR 0 4
109127: PUSH
109128: LD_VAR 0 7
109132: ARRAY
109133: PPUSH
109134: LD_INT 12
109136: PPUSH
109137: CALL_OW 240
// if units_path [ i ] then
109141: LD_VAR 0 16
109145: PUSH
109146: LD_VAR 0 7
109150: ARRAY
109151: IFFALSE 109336
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
109153: LD_VAR 0 4
109157: PUSH
109158: LD_VAR 0 7
109162: ARRAY
109163: PPUSH
109164: LD_VAR 0 16
109168: PUSH
109169: LD_VAR 0 7
109173: ARRAY
109174: PUSH
109175: LD_INT 1
109177: ARRAY
109178: PUSH
109179: LD_INT 1
109181: ARRAY
109182: PPUSH
109183: LD_VAR 0 16
109187: PUSH
109188: LD_VAR 0 7
109192: ARRAY
109193: PUSH
109194: LD_INT 1
109196: ARRAY
109197: PUSH
109198: LD_INT 2
109200: ARRAY
109201: PPUSH
109202: CALL_OW 297
109206: PUSH
109207: LD_INT 6
109209: GREATER
109210: IFFALSE 109285
// begin if not HasTask ( group [ i ] ) then
109212: LD_VAR 0 4
109216: PUSH
109217: LD_VAR 0 7
109221: ARRAY
109222: PPUSH
109223: CALL_OW 314
109227: NOT
109228: IFFALSE 109283
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
109230: LD_VAR 0 4
109234: PUSH
109235: LD_VAR 0 7
109239: ARRAY
109240: PPUSH
109241: LD_VAR 0 16
109245: PUSH
109246: LD_VAR 0 7
109250: ARRAY
109251: PUSH
109252: LD_INT 1
109254: ARRAY
109255: PUSH
109256: LD_INT 1
109258: ARRAY
109259: PPUSH
109260: LD_VAR 0 16
109264: PUSH
109265: LD_VAR 0 7
109269: ARRAY
109270: PUSH
109271: LD_INT 1
109273: ARRAY
109274: PUSH
109275: LD_INT 2
109277: ARRAY
109278: PPUSH
109279: CALL_OW 114
// end else
109283: GO 109336
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109285: LD_ADDR_VAR 0 15
109289: PUSH
109290: LD_VAR 0 16
109294: PUSH
109295: LD_VAR 0 7
109299: ARRAY
109300: PPUSH
109301: LD_INT 1
109303: PPUSH
109304: CALL_OW 3
109308: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109309: LD_ADDR_VAR 0 16
109313: PUSH
109314: LD_VAR 0 16
109318: PPUSH
109319: LD_VAR 0 7
109323: PPUSH
109324: LD_VAR 0 15
109328: PPUSH
109329: CALL_OW 1
109333: ST_TO_ADDR
// continue ;
109334: GO 107879
// end ; end ; end else
109336: GO 112000
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109338: LD_ADDR_VAR 0 14
109342: PUSH
109343: LD_INT 81
109345: PUSH
109346: LD_VAR 0 4
109350: PUSH
109351: LD_VAR 0 7
109355: ARRAY
109356: PPUSH
109357: CALL_OW 255
109361: PUSH
109362: EMPTY
109363: LIST
109364: LIST
109365: PPUSH
109366: CALL_OW 69
109370: ST_TO_ADDR
// if not tmp then
109371: LD_VAR 0 14
109375: NOT
109376: IFFALSE 109380
// continue ;
109378: GO 107879
// if f_ignore_area then
109380: LD_VAR 0 17
109384: IFFALSE 109472
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109386: LD_ADDR_VAR 0 15
109390: PUSH
109391: LD_VAR 0 14
109395: PPUSH
109396: LD_INT 3
109398: PUSH
109399: LD_INT 92
109401: PUSH
109402: LD_VAR 0 17
109406: PUSH
109407: LD_INT 1
109409: ARRAY
109410: PUSH
109411: LD_VAR 0 17
109415: PUSH
109416: LD_INT 2
109418: ARRAY
109419: PUSH
109420: LD_VAR 0 17
109424: PUSH
109425: LD_INT 3
109427: ARRAY
109428: PUSH
109429: EMPTY
109430: LIST
109431: LIST
109432: LIST
109433: LIST
109434: PUSH
109435: EMPTY
109436: LIST
109437: LIST
109438: PPUSH
109439: CALL_OW 72
109443: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109444: LD_VAR 0 14
109448: PUSH
109449: LD_VAR 0 15
109453: DIFF
109454: IFFALSE 109472
// tmp := tmp diff tmp2 ;
109456: LD_ADDR_VAR 0 14
109460: PUSH
109461: LD_VAR 0 14
109465: PUSH
109466: LD_VAR 0 15
109470: DIFF
109471: ST_TO_ADDR
// end ; if not f_murder then
109472: LD_VAR 0 20
109476: NOT
109477: IFFALSE 109535
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109479: LD_ADDR_VAR 0 15
109483: PUSH
109484: LD_VAR 0 14
109488: PPUSH
109489: LD_INT 3
109491: PUSH
109492: LD_INT 50
109494: PUSH
109495: EMPTY
109496: LIST
109497: PUSH
109498: EMPTY
109499: LIST
109500: LIST
109501: PPUSH
109502: CALL_OW 72
109506: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109507: LD_VAR 0 14
109511: PUSH
109512: LD_VAR 0 15
109516: DIFF
109517: IFFALSE 109535
// tmp := tmp diff tmp2 ;
109519: LD_ADDR_VAR 0 14
109523: PUSH
109524: LD_VAR 0 14
109528: PUSH
109529: LD_VAR 0 15
109533: DIFF
109534: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109535: LD_ADDR_VAR 0 14
109539: PUSH
109540: LD_VAR 0 4
109544: PUSH
109545: LD_VAR 0 7
109549: ARRAY
109550: PPUSH
109551: LD_VAR 0 14
109555: PPUSH
109556: LD_INT 1
109558: PPUSH
109559: LD_INT 1
109561: PPUSH
109562: CALL 56702 0 4
109566: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109567: LD_VAR 0 4
109571: PUSH
109572: LD_VAR 0 7
109576: ARRAY
109577: PPUSH
109578: CALL_OW 257
109582: PUSH
109583: LD_INT 1
109585: EQUAL
109586: IFFALSE 110034
// begin if WantPlant ( group [ i ] ) then
109588: LD_VAR 0 4
109592: PUSH
109593: LD_VAR 0 7
109597: ARRAY
109598: PPUSH
109599: CALL 56203 0 1
109603: IFFALSE 109607
// continue ;
109605: GO 107879
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109607: LD_VAR 0 18
109611: PUSH
109612: LD_VAR 0 4
109616: PUSH
109617: LD_VAR 0 7
109621: ARRAY
109622: PPUSH
109623: CALL_OW 310
109627: NOT
109628: AND
109629: PUSH
109630: LD_VAR 0 14
109634: PUSH
109635: LD_INT 1
109637: ARRAY
109638: PUSH
109639: LD_VAR 0 14
109643: PPUSH
109644: LD_INT 21
109646: PUSH
109647: LD_INT 2
109649: PUSH
109650: EMPTY
109651: LIST
109652: LIST
109653: PUSH
109654: LD_INT 58
109656: PUSH
109657: EMPTY
109658: LIST
109659: PUSH
109660: EMPTY
109661: LIST
109662: LIST
109663: PPUSH
109664: CALL_OW 72
109668: IN
109669: AND
109670: IFFALSE 109706
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109672: LD_VAR 0 4
109676: PUSH
109677: LD_VAR 0 7
109681: ARRAY
109682: PPUSH
109683: LD_VAR 0 14
109687: PUSH
109688: LD_INT 1
109690: ARRAY
109691: PPUSH
109692: CALL_OW 120
// attacking := true ;
109696: LD_ADDR_VAR 0 29
109700: PUSH
109701: LD_INT 1
109703: ST_TO_ADDR
// continue ;
109704: GO 107879
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109706: LD_VAR 0 26
109710: PUSH
109711: LD_VAR 0 4
109715: PUSH
109716: LD_VAR 0 7
109720: ARRAY
109721: PPUSH
109722: CALL_OW 257
109726: PUSH
109727: LD_INT 1
109729: EQUAL
109730: AND
109731: PUSH
109732: LD_VAR 0 4
109736: PUSH
109737: LD_VAR 0 7
109741: ARRAY
109742: PPUSH
109743: CALL_OW 256
109747: PUSH
109748: LD_INT 800
109750: LESS
109751: AND
109752: PUSH
109753: LD_VAR 0 4
109757: PUSH
109758: LD_VAR 0 7
109762: ARRAY
109763: PPUSH
109764: CALL_OW 318
109768: NOT
109769: AND
109770: IFFALSE 109787
// ComCrawl ( group [ i ] ) ;
109772: LD_VAR 0 4
109776: PUSH
109777: LD_VAR 0 7
109781: ARRAY
109782: PPUSH
109783: CALL_OW 137
// if f_mines then
109787: LD_VAR 0 21
109791: IFFALSE 110034
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109793: LD_VAR 0 14
109797: PUSH
109798: LD_INT 1
109800: ARRAY
109801: PPUSH
109802: CALL_OW 247
109806: PUSH
109807: LD_INT 3
109809: EQUAL
109810: PUSH
109811: LD_VAR 0 14
109815: PUSH
109816: LD_INT 1
109818: ARRAY
109819: PUSH
109820: LD_VAR 0 27
109824: IN
109825: NOT
109826: AND
109827: IFFALSE 110034
// begin x := GetX ( tmp [ 1 ] ) ;
109829: LD_ADDR_VAR 0 10
109833: PUSH
109834: LD_VAR 0 14
109838: PUSH
109839: LD_INT 1
109841: ARRAY
109842: PPUSH
109843: CALL_OW 250
109847: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109848: LD_ADDR_VAR 0 11
109852: PUSH
109853: LD_VAR 0 14
109857: PUSH
109858: LD_INT 1
109860: ARRAY
109861: PPUSH
109862: CALL_OW 251
109866: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109867: LD_ADDR_VAR 0 12
109871: PUSH
109872: LD_VAR 0 4
109876: PUSH
109877: LD_VAR 0 7
109881: ARRAY
109882: PPUSH
109883: CALL 83852 0 1
109887: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109888: LD_VAR 0 4
109892: PUSH
109893: LD_VAR 0 7
109897: ARRAY
109898: PPUSH
109899: LD_VAR 0 10
109903: PPUSH
109904: LD_VAR 0 11
109908: PPUSH
109909: LD_VAR 0 14
109913: PUSH
109914: LD_INT 1
109916: ARRAY
109917: PPUSH
109918: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109922: LD_VAR 0 4
109926: PUSH
109927: LD_VAR 0 7
109931: ARRAY
109932: PPUSH
109933: LD_VAR 0 10
109937: PPUSH
109938: LD_VAR 0 12
109942: PPUSH
109943: LD_INT 7
109945: PPUSH
109946: CALL_OW 272
109950: PPUSH
109951: LD_VAR 0 11
109955: PPUSH
109956: LD_VAR 0 12
109960: PPUSH
109961: LD_INT 7
109963: PPUSH
109964: CALL_OW 273
109968: PPUSH
109969: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109973: LD_VAR 0 4
109977: PUSH
109978: LD_VAR 0 7
109982: ARRAY
109983: PPUSH
109984: LD_INT 71
109986: PPUSH
109987: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109991: LD_ADDR_VAR 0 27
109995: PUSH
109996: LD_VAR 0 27
110000: PPUSH
110001: LD_VAR 0 27
110005: PUSH
110006: LD_INT 1
110008: PLUS
110009: PPUSH
110010: LD_VAR 0 14
110014: PUSH
110015: LD_INT 1
110017: ARRAY
110018: PPUSH
110019: CALL_OW 1
110023: ST_TO_ADDR
// attacking := true ;
110024: LD_ADDR_VAR 0 29
110028: PUSH
110029: LD_INT 1
110031: ST_TO_ADDR
// continue ;
110032: GO 107879
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110034: LD_VAR 0 4
110038: PUSH
110039: LD_VAR 0 7
110043: ARRAY
110044: PPUSH
110045: CALL_OW 257
110049: PUSH
110050: LD_INT 17
110052: EQUAL
110053: PUSH
110054: LD_VAR 0 4
110058: PUSH
110059: LD_VAR 0 7
110063: ARRAY
110064: PPUSH
110065: CALL_OW 110
110069: PUSH
110070: LD_INT 71
110072: EQUAL
110073: NOT
110074: AND
110075: IFFALSE 110221
// begin attacking := false ;
110077: LD_ADDR_VAR 0 29
110081: PUSH
110082: LD_INT 0
110084: ST_TO_ADDR
// k := 5 ;
110085: LD_ADDR_VAR 0 9
110089: PUSH
110090: LD_INT 5
110092: ST_TO_ADDR
// if tmp < k then
110093: LD_VAR 0 14
110097: PUSH
110098: LD_VAR 0 9
110102: LESS
110103: IFFALSE 110115
// k := tmp ;
110105: LD_ADDR_VAR 0 9
110109: PUSH
110110: LD_VAR 0 14
110114: ST_TO_ADDR
// for j = 1 to k do
110115: LD_ADDR_VAR 0 8
110119: PUSH
110120: DOUBLE
110121: LD_INT 1
110123: DEC
110124: ST_TO_ADDR
110125: LD_VAR 0 9
110129: PUSH
110130: FOR_TO
110131: IFFALSE 110219
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
110133: LD_VAR 0 14
110137: PUSH
110138: LD_VAR 0 8
110142: ARRAY
110143: PUSH
110144: LD_VAR 0 14
110148: PPUSH
110149: LD_INT 58
110151: PUSH
110152: EMPTY
110153: LIST
110154: PPUSH
110155: CALL_OW 72
110159: IN
110160: NOT
110161: IFFALSE 110217
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110163: LD_VAR 0 4
110167: PUSH
110168: LD_VAR 0 7
110172: ARRAY
110173: PPUSH
110174: LD_VAR 0 14
110178: PUSH
110179: LD_VAR 0 8
110183: ARRAY
110184: PPUSH
110185: CALL_OW 115
// attacking := true ;
110189: LD_ADDR_VAR 0 29
110193: PUSH
110194: LD_INT 1
110196: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110197: LD_VAR 0 4
110201: PUSH
110202: LD_VAR 0 7
110206: ARRAY
110207: PPUSH
110208: LD_INT 71
110210: PPUSH
110211: CALL_OW 109
// continue ;
110215: GO 110130
// end ; end ;
110217: GO 110130
110219: POP
110220: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
110221: LD_VAR 0 4
110225: PUSH
110226: LD_VAR 0 7
110230: ARRAY
110231: PPUSH
110232: CALL_OW 257
110236: PUSH
110237: LD_INT 8
110239: EQUAL
110240: PUSH
110241: LD_VAR 0 4
110245: PUSH
110246: LD_VAR 0 7
110250: ARRAY
110251: PPUSH
110252: CALL_OW 264
110256: PUSH
110257: LD_INT 28
110259: PUSH
110260: LD_INT 45
110262: PUSH
110263: LD_INT 7
110265: PUSH
110266: LD_INT 47
110268: PUSH
110269: EMPTY
110270: LIST
110271: LIST
110272: LIST
110273: LIST
110274: IN
110275: OR
110276: IFFALSE 110532
// begin attacking := false ;
110278: LD_ADDR_VAR 0 29
110282: PUSH
110283: LD_INT 0
110285: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110286: LD_VAR 0 14
110290: PUSH
110291: LD_INT 1
110293: ARRAY
110294: PPUSH
110295: CALL_OW 266
110299: PUSH
110300: LD_INT 32
110302: PUSH
110303: LD_INT 31
110305: PUSH
110306: LD_INT 33
110308: PUSH
110309: LD_INT 4
110311: PUSH
110312: LD_INT 5
110314: PUSH
110315: EMPTY
110316: LIST
110317: LIST
110318: LIST
110319: LIST
110320: LIST
110321: IN
110322: IFFALSE 110508
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110324: LD_ADDR_VAR 0 9
110328: PUSH
110329: LD_VAR 0 14
110333: PUSH
110334: LD_INT 1
110336: ARRAY
110337: PPUSH
110338: CALL_OW 266
110342: PPUSH
110343: LD_VAR 0 14
110347: PUSH
110348: LD_INT 1
110350: ARRAY
110351: PPUSH
110352: CALL_OW 250
110356: PPUSH
110357: LD_VAR 0 14
110361: PUSH
110362: LD_INT 1
110364: ARRAY
110365: PPUSH
110366: CALL_OW 251
110370: PPUSH
110371: LD_VAR 0 14
110375: PUSH
110376: LD_INT 1
110378: ARRAY
110379: PPUSH
110380: CALL_OW 254
110384: PPUSH
110385: LD_VAR 0 14
110389: PUSH
110390: LD_INT 1
110392: ARRAY
110393: PPUSH
110394: CALL_OW 248
110398: PPUSH
110399: LD_INT 0
110401: PPUSH
110402: CALL 65222 0 6
110406: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110407: LD_ADDR_VAR 0 8
110411: PUSH
110412: LD_VAR 0 4
110416: PUSH
110417: LD_VAR 0 7
110421: ARRAY
110422: PPUSH
110423: LD_VAR 0 9
110427: PPUSH
110428: CALL 83892 0 2
110432: ST_TO_ADDR
// if j then
110433: LD_VAR 0 8
110437: IFFALSE 110506
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110439: LD_VAR 0 8
110443: PUSH
110444: LD_INT 1
110446: ARRAY
110447: PPUSH
110448: LD_VAR 0 8
110452: PUSH
110453: LD_INT 2
110455: ARRAY
110456: PPUSH
110457: CALL_OW 488
110461: IFFALSE 110506
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110463: LD_VAR 0 4
110467: PUSH
110468: LD_VAR 0 7
110472: ARRAY
110473: PPUSH
110474: LD_VAR 0 8
110478: PUSH
110479: LD_INT 1
110481: ARRAY
110482: PPUSH
110483: LD_VAR 0 8
110487: PUSH
110488: LD_INT 2
110490: ARRAY
110491: PPUSH
110492: CALL_OW 116
// attacking := true ;
110496: LD_ADDR_VAR 0 29
110500: PUSH
110501: LD_INT 1
110503: ST_TO_ADDR
// continue ;
110504: GO 107879
// end ; end else
110506: GO 110532
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110508: LD_VAR 0 4
110512: PUSH
110513: LD_VAR 0 7
110517: ARRAY
110518: PPUSH
110519: LD_VAR 0 14
110523: PUSH
110524: LD_INT 1
110526: ARRAY
110527: PPUSH
110528: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110532: LD_VAR 0 4
110536: PUSH
110537: LD_VAR 0 7
110541: ARRAY
110542: PPUSH
110543: CALL_OW 265
110547: PUSH
110548: LD_INT 11
110550: EQUAL
110551: IFFALSE 110829
// begin k := 10 ;
110553: LD_ADDR_VAR 0 9
110557: PUSH
110558: LD_INT 10
110560: ST_TO_ADDR
// x := 0 ;
110561: LD_ADDR_VAR 0 10
110565: PUSH
110566: LD_INT 0
110568: ST_TO_ADDR
// if tmp < k then
110569: LD_VAR 0 14
110573: PUSH
110574: LD_VAR 0 9
110578: LESS
110579: IFFALSE 110591
// k := tmp ;
110581: LD_ADDR_VAR 0 9
110585: PUSH
110586: LD_VAR 0 14
110590: ST_TO_ADDR
// for j = k downto 1 do
110591: LD_ADDR_VAR 0 8
110595: PUSH
110596: DOUBLE
110597: LD_VAR 0 9
110601: INC
110602: ST_TO_ADDR
110603: LD_INT 1
110605: PUSH
110606: FOR_DOWNTO
110607: IFFALSE 110682
// begin if GetType ( tmp [ j ] ) = unit_human then
110609: LD_VAR 0 14
110613: PUSH
110614: LD_VAR 0 8
110618: ARRAY
110619: PPUSH
110620: CALL_OW 247
110624: PUSH
110625: LD_INT 1
110627: EQUAL
110628: IFFALSE 110680
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110630: LD_VAR 0 4
110634: PUSH
110635: LD_VAR 0 7
110639: ARRAY
110640: PPUSH
110641: LD_VAR 0 14
110645: PUSH
110646: LD_VAR 0 8
110650: ARRAY
110651: PPUSH
110652: CALL 84163 0 2
// x := tmp [ j ] ;
110656: LD_ADDR_VAR 0 10
110660: PUSH
110661: LD_VAR 0 14
110665: PUSH
110666: LD_VAR 0 8
110670: ARRAY
110671: ST_TO_ADDR
// attacking := true ;
110672: LD_ADDR_VAR 0 29
110676: PUSH
110677: LD_INT 1
110679: ST_TO_ADDR
// end ; end ;
110680: GO 110606
110682: POP
110683: POP
// if not x then
110684: LD_VAR 0 10
110688: NOT
110689: IFFALSE 110829
// begin attacking := true ;
110691: LD_ADDR_VAR 0 29
110695: PUSH
110696: LD_INT 1
110698: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110699: LD_VAR 0 4
110703: PUSH
110704: LD_VAR 0 7
110708: ARRAY
110709: PPUSH
110710: CALL_OW 250
110714: PPUSH
110715: LD_VAR 0 4
110719: PUSH
110720: LD_VAR 0 7
110724: ARRAY
110725: PPUSH
110726: CALL_OW 251
110730: PPUSH
110731: CALL_OW 546
110735: PUSH
110736: LD_INT 2
110738: ARRAY
110739: PUSH
110740: LD_VAR 0 14
110744: PUSH
110745: LD_INT 1
110747: ARRAY
110748: PPUSH
110749: CALL_OW 250
110753: PPUSH
110754: LD_VAR 0 14
110758: PUSH
110759: LD_INT 1
110761: ARRAY
110762: PPUSH
110763: CALL_OW 251
110767: PPUSH
110768: CALL_OW 546
110772: PUSH
110773: LD_INT 2
110775: ARRAY
110776: EQUAL
110777: IFFALSE 110805
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110779: LD_VAR 0 4
110783: PUSH
110784: LD_VAR 0 7
110788: ARRAY
110789: PPUSH
110790: LD_VAR 0 14
110794: PUSH
110795: LD_INT 1
110797: ARRAY
110798: PPUSH
110799: CALL 84163 0 2
110803: GO 110829
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110805: LD_VAR 0 4
110809: PUSH
110810: LD_VAR 0 7
110814: ARRAY
110815: PPUSH
110816: LD_VAR 0 14
110820: PUSH
110821: LD_INT 1
110823: ARRAY
110824: PPUSH
110825: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110829: LD_VAR 0 4
110833: PUSH
110834: LD_VAR 0 7
110838: ARRAY
110839: PPUSH
110840: CALL_OW 264
110844: PUSH
110845: LD_INT 29
110847: EQUAL
110848: IFFALSE 111214
// begin if WantsToAttack ( group [ i ] ) in bombed then
110850: LD_VAR 0 4
110854: PUSH
110855: LD_VAR 0 7
110859: ARRAY
110860: PPUSH
110861: CALL_OW 319
110865: PUSH
110866: LD_VAR 0 28
110870: IN
110871: IFFALSE 110875
// continue ;
110873: GO 107879
// k := 8 ;
110875: LD_ADDR_VAR 0 9
110879: PUSH
110880: LD_INT 8
110882: ST_TO_ADDR
// x := 0 ;
110883: LD_ADDR_VAR 0 10
110887: PUSH
110888: LD_INT 0
110890: ST_TO_ADDR
// if tmp < k then
110891: LD_VAR 0 14
110895: PUSH
110896: LD_VAR 0 9
110900: LESS
110901: IFFALSE 110913
// k := tmp ;
110903: LD_ADDR_VAR 0 9
110907: PUSH
110908: LD_VAR 0 14
110912: ST_TO_ADDR
// for j = 1 to k do
110913: LD_ADDR_VAR 0 8
110917: PUSH
110918: DOUBLE
110919: LD_INT 1
110921: DEC
110922: ST_TO_ADDR
110923: LD_VAR 0 9
110927: PUSH
110928: FOR_TO
110929: IFFALSE 111061
// begin if GetType ( tmp [ j ] ) = unit_building then
110931: LD_VAR 0 14
110935: PUSH
110936: LD_VAR 0 8
110940: ARRAY
110941: PPUSH
110942: CALL_OW 247
110946: PUSH
110947: LD_INT 3
110949: EQUAL
110950: IFFALSE 111059
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110952: LD_VAR 0 14
110956: PUSH
110957: LD_VAR 0 8
110961: ARRAY
110962: PUSH
110963: LD_VAR 0 28
110967: IN
110968: NOT
110969: PUSH
110970: LD_VAR 0 14
110974: PUSH
110975: LD_VAR 0 8
110979: ARRAY
110980: PPUSH
110981: CALL_OW 313
110985: AND
110986: IFFALSE 111059
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110988: LD_VAR 0 4
110992: PUSH
110993: LD_VAR 0 7
110997: ARRAY
110998: PPUSH
110999: LD_VAR 0 14
111003: PUSH
111004: LD_VAR 0 8
111008: ARRAY
111009: PPUSH
111010: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111014: LD_ADDR_VAR 0 28
111018: PUSH
111019: LD_VAR 0 28
111023: PPUSH
111024: LD_VAR 0 28
111028: PUSH
111029: LD_INT 1
111031: PLUS
111032: PPUSH
111033: LD_VAR 0 14
111037: PUSH
111038: LD_VAR 0 8
111042: ARRAY
111043: PPUSH
111044: CALL_OW 1
111048: ST_TO_ADDR
// attacking := true ;
111049: LD_ADDR_VAR 0 29
111053: PUSH
111054: LD_INT 1
111056: ST_TO_ADDR
// break ;
111057: GO 111061
// end ; end ;
111059: GO 110928
111061: POP
111062: POP
// if not attacking and f_attack_depot then
111063: LD_VAR 0 29
111067: NOT
111068: PUSH
111069: LD_VAR 0 25
111073: AND
111074: IFFALSE 111169
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111076: LD_ADDR_VAR 0 13
111080: PUSH
111081: LD_VAR 0 14
111085: PPUSH
111086: LD_INT 2
111088: PUSH
111089: LD_INT 30
111091: PUSH
111092: LD_INT 0
111094: PUSH
111095: EMPTY
111096: LIST
111097: LIST
111098: PUSH
111099: LD_INT 30
111101: PUSH
111102: LD_INT 1
111104: PUSH
111105: EMPTY
111106: LIST
111107: LIST
111108: PUSH
111109: EMPTY
111110: LIST
111111: LIST
111112: LIST
111113: PPUSH
111114: CALL_OW 72
111118: ST_TO_ADDR
// if z then
111119: LD_VAR 0 13
111123: IFFALSE 111169
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
111125: LD_VAR 0 4
111129: PUSH
111130: LD_VAR 0 7
111134: ARRAY
111135: PPUSH
111136: LD_VAR 0 13
111140: PPUSH
111141: LD_VAR 0 4
111145: PUSH
111146: LD_VAR 0 7
111150: ARRAY
111151: PPUSH
111152: CALL_OW 74
111156: PPUSH
111157: CALL_OW 115
// attacking := true ;
111161: LD_ADDR_VAR 0 29
111165: PUSH
111166: LD_INT 1
111168: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
111169: LD_VAR 0 4
111173: PUSH
111174: LD_VAR 0 7
111178: ARRAY
111179: PPUSH
111180: CALL_OW 256
111184: PUSH
111185: LD_INT 500
111187: LESS
111188: IFFALSE 111214
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111190: LD_VAR 0 4
111194: PUSH
111195: LD_VAR 0 7
111199: ARRAY
111200: PPUSH
111201: LD_VAR 0 14
111205: PUSH
111206: LD_INT 1
111208: ARRAY
111209: PPUSH
111210: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111214: LD_VAR 0 4
111218: PUSH
111219: LD_VAR 0 7
111223: ARRAY
111224: PPUSH
111225: CALL_OW 264
111229: PUSH
111230: LD_INT 49
111232: EQUAL
111233: IFFALSE 111354
// begin if not HasTask ( group [ i ] ) then
111235: LD_VAR 0 4
111239: PUSH
111240: LD_VAR 0 7
111244: ARRAY
111245: PPUSH
111246: CALL_OW 314
111250: NOT
111251: IFFALSE 111354
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111253: LD_ADDR_VAR 0 9
111257: PUSH
111258: LD_INT 81
111260: PUSH
111261: LD_VAR 0 4
111265: PUSH
111266: LD_VAR 0 7
111270: ARRAY
111271: PPUSH
111272: CALL_OW 255
111276: PUSH
111277: EMPTY
111278: LIST
111279: LIST
111280: PPUSH
111281: CALL_OW 69
111285: PPUSH
111286: LD_VAR 0 4
111290: PUSH
111291: LD_VAR 0 7
111295: ARRAY
111296: PPUSH
111297: CALL_OW 74
111301: ST_TO_ADDR
// if k then
111302: LD_VAR 0 9
111306: IFFALSE 111354
// if GetDistUnits ( group [ i ] , k ) > 10 then
111308: LD_VAR 0 4
111312: PUSH
111313: LD_VAR 0 7
111317: ARRAY
111318: PPUSH
111319: LD_VAR 0 9
111323: PPUSH
111324: CALL_OW 296
111328: PUSH
111329: LD_INT 10
111331: GREATER
111332: IFFALSE 111354
// ComMoveUnit ( group [ i ] , k ) ;
111334: LD_VAR 0 4
111338: PUSH
111339: LD_VAR 0 7
111343: ARRAY
111344: PPUSH
111345: LD_VAR 0 9
111349: PPUSH
111350: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111354: LD_VAR 0 4
111358: PUSH
111359: LD_VAR 0 7
111363: ARRAY
111364: PPUSH
111365: CALL_OW 256
111369: PUSH
111370: LD_INT 250
111372: LESS
111373: PUSH
111374: LD_VAR 0 4
111378: PUSH
111379: LD_VAR 0 7
111383: ARRAY
111384: PUSH
111385: LD_INT 21
111387: PUSH
111388: LD_INT 2
111390: PUSH
111391: EMPTY
111392: LIST
111393: LIST
111394: PUSH
111395: LD_INT 23
111397: PUSH
111398: LD_INT 2
111400: PUSH
111401: EMPTY
111402: LIST
111403: LIST
111404: PUSH
111405: EMPTY
111406: LIST
111407: LIST
111408: PPUSH
111409: CALL_OW 69
111413: IN
111414: AND
111415: IFFALSE 111540
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111417: LD_ADDR_VAR 0 9
111421: PUSH
111422: LD_OWVAR 3
111426: PUSH
111427: LD_VAR 0 4
111431: PUSH
111432: LD_VAR 0 7
111436: ARRAY
111437: DIFF
111438: PPUSH
111439: LD_VAR 0 4
111443: PUSH
111444: LD_VAR 0 7
111448: ARRAY
111449: PPUSH
111450: CALL_OW 74
111454: ST_TO_ADDR
// if not k then
111455: LD_VAR 0 9
111459: NOT
111460: IFFALSE 111464
// continue ;
111462: GO 107879
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111464: LD_VAR 0 9
111468: PUSH
111469: LD_INT 81
111471: PUSH
111472: LD_VAR 0 4
111476: PUSH
111477: LD_VAR 0 7
111481: ARRAY
111482: PPUSH
111483: CALL_OW 255
111487: PUSH
111488: EMPTY
111489: LIST
111490: LIST
111491: PPUSH
111492: CALL_OW 69
111496: IN
111497: PUSH
111498: LD_VAR 0 9
111502: PPUSH
111503: LD_VAR 0 4
111507: PUSH
111508: LD_VAR 0 7
111512: ARRAY
111513: PPUSH
111514: CALL_OW 296
111518: PUSH
111519: LD_INT 5
111521: LESS
111522: AND
111523: IFFALSE 111540
// ComAutodestruct ( group [ i ] ) ;
111525: LD_VAR 0 4
111529: PUSH
111530: LD_VAR 0 7
111534: ARRAY
111535: PPUSH
111536: CALL 84061 0 1
// end ; if f_attack_depot then
111540: LD_VAR 0 25
111544: IFFALSE 111656
// begin k := 6 ;
111546: LD_ADDR_VAR 0 9
111550: PUSH
111551: LD_INT 6
111553: ST_TO_ADDR
// if tmp < k then
111554: LD_VAR 0 14
111558: PUSH
111559: LD_VAR 0 9
111563: LESS
111564: IFFALSE 111576
// k := tmp ;
111566: LD_ADDR_VAR 0 9
111570: PUSH
111571: LD_VAR 0 14
111575: ST_TO_ADDR
// for j = 1 to k do
111576: LD_ADDR_VAR 0 8
111580: PUSH
111581: DOUBLE
111582: LD_INT 1
111584: DEC
111585: ST_TO_ADDR
111586: LD_VAR 0 9
111590: PUSH
111591: FOR_TO
111592: IFFALSE 111654
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111594: LD_VAR 0 8
111598: PPUSH
111599: CALL_OW 266
111603: PUSH
111604: LD_INT 0
111606: PUSH
111607: LD_INT 1
111609: PUSH
111610: EMPTY
111611: LIST
111612: LIST
111613: IN
111614: IFFALSE 111652
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111616: LD_VAR 0 4
111620: PUSH
111621: LD_VAR 0 7
111625: ARRAY
111626: PPUSH
111627: LD_VAR 0 14
111631: PUSH
111632: LD_VAR 0 8
111636: ARRAY
111637: PPUSH
111638: CALL_OW 115
// attacking := true ;
111642: LD_ADDR_VAR 0 29
111646: PUSH
111647: LD_INT 1
111649: ST_TO_ADDR
// break ;
111650: GO 111654
// end ;
111652: GO 111591
111654: POP
111655: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111656: LD_VAR 0 4
111660: PUSH
111661: LD_VAR 0 7
111665: ARRAY
111666: PPUSH
111667: CALL_OW 302
111671: PUSH
111672: LD_VAR 0 29
111676: NOT
111677: AND
111678: IFFALSE 112000
// begin if GetTag ( group [ i ] ) = 71 then
111680: LD_VAR 0 4
111684: PUSH
111685: LD_VAR 0 7
111689: ARRAY
111690: PPUSH
111691: CALL_OW 110
111695: PUSH
111696: LD_INT 71
111698: EQUAL
111699: IFFALSE 111740
// begin if HasTask ( group [ i ] ) then
111701: LD_VAR 0 4
111705: PUSH
111706: LD_VAR 0 7
111710: ARRAY
111711: PPUSH
111712: CALL_OW 314
111716: IFFALSE 111722
// continue else
111718: GO 107879
111720: GO 111740
// SetTag ( group [ i ] , 0 ) ;
111722: LD_VAR 0 4
111726: PUSH
111727: LD_VAR 0 7
111731: ARRAY
111732: PPUSH
111733: LD_INT 0
111735: PPUSH
111736: CALL_OW 109
// end ; k := 8 ;
111740: LD_ADDR_VAR 0 9
111744: PUSH
111745: LD_INT 8
111747: ST_TO_ADDR
// x := 0 ;
111748: LD_ADDR_VAR 0 10
111752: PUSH
111753: LD_INT 0
111755: ST_TO_ADDR
// if tmp < k then
111756: LD_VAR 0 14
111760: PUSH
111761: LD_VAR 0 9
111765: LESS
111766: IFFALSE 111778
// k := tmp ;
111768: LD_ADDR_VAR 0 9
111772: PUSH
111773: LD_VAR 0 14
111777: ST_TO_ADDR
// for j = 1 to k do
111778: LD_ADDR_VAR 0 8
111782: PUSH
111783: DOUBLE
111784: LD_INT 1
111786: DEC
111787: ST_TO_ADDR
111788: LD_VAR 0 9
111792: PUSH
111793: FOR_TO
111794: IFFALSE 111892
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111796: LD_VAR 0 14
111800: PUSH
111801: LD_VAR 0 8
111805: ARRAY
111806: PPUSH
111807: CALL_OW 247
111811: PUSH
111812: LD_INT 1
111814: EQUAL
111815: PUSH
111816: LD_VAR 0 14
111820: PUSH
111821: LD_VAR 0 8
111825: ARRAY
111826: PPUSH
111827: CALL_OW 256
111831: PUSH
111832: LD_INT 250
111834: LESS
111835: PUSH
111836: LD_VAR 0 20
111840: AND
111841: PUSH
111842: LD_VAR 0 20
111846: NOT
111847: PUSH
111848: LD_VAR 0 14
111852: PUSH
111853: LD_VAR 0 8
111857: ARRAY
111858: PPUSH
111859: CALL_OW 256
111863: PUSH
111864: LD_INT 250
111866: GREATEREQUAL
111867: AND
111868: OR
111869: AND
111870: IFFALSE 111890
// begin x := tmp [ j ] ;
111872: LD_ADDR_VAR 0 10
111876: PUSH
111877: LD_VAR 0 14
111881: PUSH
111882: LD_VAR 0 8
111886: ARRAY
111887: ST_TO_ADDR
// break ;
111888: GO 111892
// end ;
111890: GO 111793
111892: POP
111893: POP
// if x then
111894: LD_VAR 0 10
111898: IFFALSE 111922
// ComAttackUnit ( group [ i ] , x ) else
111900: LD_VAR 0 4
111904: PUSH
111905: LD_VAR 0 7
111909: ARRAY
111910: PPUSH
111911: LD_VAR 0 10
111915: PPUSH
111916: CALL_OW 115
111920: GO 111946
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111922: LD_VAR 0 4
111926: PUSH
111927: LD_VAR 0 7
111931: ARRAY
111932: PPUSH
111933: LD_VAR 0 14
111937: PUSH
111938: LD_INT 1
111940: ARRAY
111941: PPUSH
111942: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111946: LD_VAR 0 4
111950: PUSH
111951: LD_VAR 0 7
111955: ARRAY
111956: PPUSH
111957: CALL_OW 314
111961: NOT
111962: IFFALSE 112000
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111964: LD_VAR 0 4
111968: PUSH
111969: LD_VAR 0 7
111973: ARRAY
111974: PPUSH
111975: LD_VAR 0 14
111979: PPUSH
111980: LD_VAR 0 4
111984: PUSH
111985: LD_VAR 0 7
111989: ARRAY
111990: PPUSH
111991: CALL_OW 74
111995: PPUSH
111996: CALL_OW 115
// end ; end ; end ;
112000: GO 107879
112002: POP
112003: POP
// wait ( 0 0$2 ) ;
112004: LD_INT 70
112006: PPUSH
112007: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112011: LD_VAR 0 4
112015: NOT
112016: PUSH
112017: LD_VAR 0 4
112021: PUSH
112022: EMPTY
112023: EQUAL
112024: OR
112025: PUSH
112026: LD_INT 81
112028: PUSH
112029: LD_VAR 0 35
112033: PUSH
112034: EMPTY
112035: LIST
112036: LIST
112037: PPUSH
112038: CALL_OW 69
112042: NOT
112043: OR
112044: IFFALSE 107864
// end ;
112046: LD_VAR 0 2
112050: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
112051: LD_INT 0
112053: PPUSH
112054: PPUSH
112055: PPUSH
112056: PPUSH
112057: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112058: LD_VAR 0 1
112062: NOT
112063: PUSH
112064: LD_EXP 93
112068: PUSH
112069: LD_VAR 0 1
112073: ARRAY
112074: NOT
112075: OR
112076: PUSH
112077: LD_VAR 0 2
112081: NOT
112082: OR
112083: IFFALSE 112087
// exit ;
112085: GO 112616
// side := mc_sides [ base ] ;
112087: LD_ADDR_VAR 0 5
112091: PUSH
112092: LD_EXP 119
112096: PUSH
112097: LD_VAR 0 1
112101: ARRAY
112102: ST_TO_ADDR
// if not side then
112103: LD_VAR 0 5
112107: NOT
112108: IFFALSE 112112
// exit ;
112110: GO 112616
// for i in solds do
112112: LD_ADDR_VAR 0 6
112116: PUSH
112117: LD_VAR 0 2
112121: PUSH
112122: FOR_IN
112123: IFFALSE 112184
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
112125: LD_VAR 0 6
112129: PPUSH
112130: CALL_OW 310
112134: PPUSH
112135: CALL_OW 266
112139: PUSH
112140: LD_INT 32
112142: PUSH
112143: LD_INT 31
112145: PUSH
112146: EMPTY
112147: LIST
112148: LIST
112149: IN
112150: IFFALSE 112170
// solds := solds diff i else
112152: LD_ADDR_VAR 0 2
112156: PUSH
112157: LD_VAR 0 2
112161: PUSH
112162: LD_VAR 0 6
112166: DIFF
112167: ST_TO_ADDR
112168: GO 112182
// SetTag ( i , 18 ) ;
112170: LD_VAR 0 6
112174: PPUSH
112175: LD_INT 18
112177: PPUSH
112178: CALL_OW 109
112182: GO 112122
112184: POP
112185: POP
// if not solds then
112186: LD_VAR 0 2
112190: NOT
112191: IFFALSE 112195
// exit ;
112193: GO 112616
// repeat wait ( 0 0$2 ) ;
112195: LD_INT 70
112197: PPUSH
112198: CALL_OW 67
// enemy := mc_scan [ base ] ;
112202: LD_ADDR_VAR 0 4
112206: PUSH
112207: LD_EXP 116
112211: PUSH
112212: LD_VAR 0 1
112216: ARRAY
112217: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112218: LD_EXP 93
112222: PUSH
112223: LD_VAR 0 1
112227: ARRAY
112228: NOT
112229: PUSH
112230: LD_EXP 93
112234: PUSH
112235: LD_VAR 0 1
112239: ARRAY
112240: PUSH
112241: EMPTY
112242: EQUAL
112243: OR
112244: IFFALSE 112281
// begin for i in solds do
112246: LD_ADDR_VAR 0 6
112250: PUSH
112251: LD_VAR 0 2
112255: PUSH
112256: FOR_IN
112257: IFFALSE 112270
// ComStop ( i ) ;
112259: LD_VAR 0 6
112263: PPUSH
112264: CALL_OW 141
112268: GO 112256
112270: POP
112271: POP
// solds := [ ] ;
112272: LD_ADDR_VAR 0 2
112276: PUSH
112277: EMPTY
112278: ST_TO_ADDR
// exit ;
112279: GO 112616
// end ; for i in solds do
112281: LD_ADDR_VAR 0 6
112285: PUSH
112286: LD_VAR 0 2
112290: PUSH
112291: FOR_IN
112292: IFFALSE 112588
// begin if IsInUnit ( i ) then
112294: LD_VAR 0 6
112298: PPUSH
112299: CALL_OW 310
112303: IFFALSE 112314
// ComExitBuilding ( i ) ;
112305: LD_VAR 0 6
112309: PPUSH
112310: CALL_OW 122
// if GetLives ( i ) > 333 then
112314: LD_VAR 0 6
112318: PPUSH
112319: CALL_OW 256
112323: PUSH
112324: LD_INT 333
112326: GREATER
112327: IFFALSE 112355
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
112329: LD_VAR 0 6
112333: PPUSH
112334: LD_VAR 0 4
112338: PPUSH
112339: LD_VAR 0 6
112343: PPUSH
112344: CALL_OW 74
112348: PPUSH
112349: CALL_OW 115
112353: GO 112586
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112355: LD_VAR 0 6
112359: PPUSH
112360: LD_EXP 93
112364: PUSH
112365: LD_VAR 0 1
112369: ARRAY
112370: PPUSH
112371: LD_INT 2
112373: PUSH
112374: LD_INT 30
112376: PUSH
112377: LD_INT 0
112379: PUSH
112380: EMPTY
112381: LIST
112382: LIST
112383: PUSH
112384: LD_INT 30
112386: PUSH
112387: LD_INT 1
112389: PUSH
112390: EMPTY
112391: LIST
112392: LIST
112393: PUSH
112394: LD_INT 30
112396: PUSH
112397: LD_INT 6
112399: PUSH
112400: EMPTY
112401: LIST
112402: LIST
112403: PUSH
112404: EMPTY
112405: LIST
112406: LIST
112407: LIST
112408: LIST
112409: PPUSH
112410: CALL_OW 72
112414: PPUSH
112415: LD_VAR 0 6
112419: PPUSH
112420: CALL_OW 74
112424: PPUSH
112425: CALL_OW 296
112429: PUSH
112430: LD_INT 10
112432: GREATER
112433: IFFALSE 112586
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112435: LD_ADDR_VAR 0 7
112439: PUSH
112440: LD_EXP 93
112444: PUSH
112445: LD_VAR 0 1
112449: ARRAY
112450: PPUSH
112451: LD_INT 2
112453: PUSH
112454: LD_INT 30
112456: PUSH
112457: LD_INT 0
112459: PUSH
112460: EMPTY
112461: LIST
112462: LIST
112463: PUSH
112464: LD_INT 30
112466: PUSH
112467: LD_INT 1
112469: PUSH
112470: EMPTY
112471: LIST
112472: LIST
112473: PUSH
112474: LD_INT 30
112476: PUSH
112477: LD_INT 6
112479: PUSH
112480: EMPTY
112481: LIST
112482: LIST
112483: PUSH
112484: EMPTY
112485: LIST
112486: LIST
112487: LIST
112488: LIST
112489: PPUSH
112490: CALL_OW 72
112494: PPUSH
112495: LD_VAR 0 6
112499: PPUSH
112500: CALL_OW 74
112504: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112505: LD_VAR 0 6
112509: PPUSH
112510: LD_VAR 0 7
112514: PPUSH
112515: CALL_OW 250
112519: PPUSH
112520: LD_INT 3
112522: PPUSH
112523: LD_INT 5
112525: PPUSH
112526: CALL_OW 272
112530: PPUSH
112531: LD_VAR 0 7
112535: PPUSH
112536: CALL_OW 251
112540: PPUSH
112541: LD_INT 3
112543: PPUSH
112544: LD_INT 5
112546: PPUSH
112547: CALL_OW 273
112551: PPUSH
112552: CALL_OW 111
// SetTag ( i , 0 ) ;
112556: LD_VAR 0 6
112560: PPUSH
112561: LD_INT 0
112563: PPUSH
112564: CALL_OW 109
// solds := solds diff i ;
112568: LD_ADDR_VAR 0 2
112572: PUSH
112573: LD_VAR 0 2
112577: PUSH
112578: LD_VAR 0 6
112582: DIFF
112583: ST_TO_ADDR
// continue ;
112584: GO 112291
// end ; end ;
112586: GO 112291
112588: POP
112589: POP
// until not solds or not enemy ;
112590: LD_VAR 0 2
112594: NOT
112595: PUSH
112596: LD_VAR 0 4
112600: NOT
112601: OR
112602: IFFALSE 112195
// MC_Reset ( base , 18 ) ;
112604: LD_VAR 0 1
112608: PPUSH
112609: LD_INT 18
112611: PPUSH
112612: CALL 24956 0 2
// end ;
112616: LD_VAR 0 3
112620: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
112621: LD_INT 0
112623: PPUSH
112624: PPUSH
112625: PPUSH
112626: PPUSH
112627: PPUSH
112628: PPUSH
112629: PPUSH
112630: PPUSH
112631: PPUSH
112632: PPUSH
112633: PPUSH
112634: PPUSH
112635: PPUSH
112636: PPUSH
112637: PPUSH
112638: PPUSH
112639: PPUSH
112640: PPUSH
112641: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112642: LD_ADDR_VAR 0 12
112646: PUSH
112647: LD_EXP 93
112651: PUSH
112652: LD_VAR 0 1
112656: ARRAY
112657: PPUSH
112658: LD_INT 25
112660: PUSH
112661: LD_INT 3
112663: PUSH
112664: EMPTY
112665: LIST
112666: LIST
112667: PPUSH
112668: CALL_OW 72
112672: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112673: LD_EXP 133
112677: PUSH
112678: LD_VAR 0 1
112682: ARRAY
112683: IFFALSE 112707
// mechs := mechs diff mc_remote_driver [ base ] ;
112685: LD_ADDR_VAR 0 12
112689: PUSH
112690: LD_VAR 0 12
112694: PUSH
112695: LD_EXP 133
112699: PUSH
112700: LD_VAR 0 1
112704: ARRAY
112705: DIFF
112706: ST_TO_ADDR
// for i in mechs do
112707: LD_ADDR_VAR 0 4
112711: PUSH
112712: LD_VAR 0 12
112716: PUSH
112717: FOR_IN
112718: IFFALSE 112753
// if GetTag ( i ) > 0 then
112720: LD_VAR 0 4
112724: PPUSH
112725: CALL_OW 110
112729: PUSH
112730: LD_INT 0
112732: GREATER
112733: IFFALSE 112751
// mechs := mechs diff i ;
112735: LD_ADDR_VAR 0 12
112739: PUSH
112740: LD_VAR 0 12
112744: PUSH
112745: LD_VAR 0 4
112749: DIFF
112750: ST_TO_ADDR
112751: GO 112717
112753: POP
112754: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112755: LD_ADDR_VAR 0 8
112759: PUSH
112760: LD_EXP 93
112764: PUSH
112765: LD_VAR 0 1
112769: ARRAY
112770: PPUSH
112771: LD_INT 2
112773: PUSH
112774: LD_INT 25
112776: PUSH
112777: LD_INT 1
112779: PUSH
112780: EMPTY
112781: LIST
112782: LIST
112783: PUSH
112784: LD_INT 25
112786: PUSH
112787: LD_INT 5
112789: PUSH
112790: EMPTY
112791: LIST
112792: LIST
112793: PUSH
112794: LD_INT 25
112796: PUSH
112797: LD_INT 8
112799: PUSH
112800: EMPTY
112801: LIST
112802: LIST
112803: PUSH
112804: LD_INT 25
112806: PUSH
112807: LD_INT 9
112809: PUSH
112810: EMPTY
112811: LIST
112812: LIST
112813: PUSH
112814: EMPTY
112815: LIST
112816: LIST
112817: LIST
112818: LIST
112819: LIST
112820: PPUSH
112821: CALL_OW 72
112825: ST_TO_ADDR
// if not defenders and not solds then
112826: LD_VAR 0 2
112830: NOT
112831: PUSH
112832: LD_VAR 0 8
112836: NOT
112837: AND
112838: IFFALSE 112842
// exit ;
112840: GO 114612
// depot_under_attack := false ;
112842: LD_ADDR_VAR 0 16
112846: PUSH
112847: LD_INT 0
112849: ST_TO_ADDR
// sold_defenders := [ ] ;
112850: LD_ADDR_VAR 0 17
112854: PUSH
112855: EMPTY
112856: ST_TO_ADDR
// if mechs then
112857: LD_VAR 0 12
112861: IFFALSE 113014
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112863: LD_ADDR_VAR 0 4
112867: PUSH
112868: LD_VAR 0 2
112872: PPUSH
112873: LD_INT 21
112875: PUSH
112876: LD_INT 2
112878: PUSH
112879: EMPTY
112880: LIST
112881: LIST
112882: PPUSH
112883: CALL_OW 72
112887: PUSH
112888: FOR_IN
112889: IFFALSE 113012
// begin if GetTag ( i ) <> 20 then
112891: LD_VAR 0 4
112895: PPUSH
112896: CALL_OW 110
112900: PUSH
112901: LD_INT 20
112903: NONEQUAL
112904: IFFALSE 112918
// SetTag ( i , 20 ) ;
112906: LD_VAR 0 4
112910: PPUSH
112911: LD_INT 20
112913: PPUSH
112914: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112918: LD_VAR 0 4
112922: PPUSH
112923: CALL_OW 263
112927: PUSH
112928: LD_INT 1
112930: EQUAL
112931: PUSH
112932: LD_VAR 0 4
112936: PPUSH
112937: CALL_OW 311
112941: NOT
112942: AND
112943: IFFALSE 113010
// begin un := mechs [ 1 ] ;
112945: LD_ADDR_VAR 0 10
112949: PUSH
112950: LD_VAR 0 12
112954: PUSH
112955: LD_INT 1
112957: ARRAY
112958: ST_TO_ADDR
// ComExit ( un ) ;
112959: LD_VAR 0 10
112963: PPUSH
112964: CALL 88406 0 1
// AddComEnterUnit ( un , i ) ;
112968: LD_VAR 0 10
112972: PPUSH
112973: LD_VAR 0 4
112977: PPUSH
112978: CALL_OW 180
// SetTag ( un , 19 ) ;
112982: LD_VAR 0 10
112986: PPUSH
112987: LD_INT 19
112989: PPUSH
112990: CALL_OW 109
// mechs := mechs diff un ;
112994: LD_ADDR_VAR 0 12
112998: PUSH
112999: LD_VAR 0 12
113003: PUSH
113004: LD_VAR 0 10
113008: DIFF
113009: ST_TO_ADDR
// end ; end ;
113010: GO 112888
113012: POP
113013: POP
// if solds then
113014: LD_VAR 0 8
113018: IFFALSE 113077
// for i in solds do
113020: LD_ADDR_VAR 0 4
113024: PUSH
113025: LD_VAR 0 8
113029: PUSH
113030: FOR_IN
113031: IFFALSE 113075
// if not GetTag ( i ) then
113033: LD_VAR 0 4
113037: PPUSH
113038: CALL_OW 110
113042: NOT
113043: IFFALSE 113073
// begin defenders := defenders union i ;
113045: LD_ADDR_VAR 0 2
113049: PUSH
113050: LD_VAR 0 2
113054: PUSH
113055: LD_VAR 0 4
113059: UNION
113060: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113061: LD_VAR 0 4
113065: PPUSH
113066: LD_INT 18
113068: PPUSH
113069: CALL_OW 109
// end ;
113073: GO 113030
113075: POP
113076: POP
// repeat wait ( 0 0$2 ) ;
113077: LD_INT 70
113079: PPUSH
113080: CALL_OW 67
// enemy := mc_scan [ base ] ;
113084: LD_ADDR_VAR 0 21
113088: PUSH
113089: LD_EXP 116
113093: PUSH
113094: LD_VAR 0 1
113098: ARRAY
113099: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113100: LD_EXP 93
113104: PUSH
113105: LD_VAR 0 1
113109: ARRAY
113110: NOT
113111: PUSH
113112: LD_EXP 93
113116: PUSH
113117: LD_VAR 0 1
113121: ARRAY
113122: PUSH
113123: EMPTY
113124: EQUAL
113125: OR
113126: IFFALSE 113163
// begin for i in defenders do
113128: LD_ADDR_VAR 0 4
113132: PUSH
113133: LD_VAR 0 2
113137: PUSH
113138: FOR_IN
113139: IFFALSE 113152
// ComStop ( i ) ;
113141: LD_VAR 0 4
113145: PPUSH
113146: CALL_OW 141
113150: GO 113138
113152: POP
113153: POP
// defenders := [ ] ;
113154: LD_ADDR_VAR 0 2
113158: PUSH
113159: EMPTY
113160: ST_TO_ADDR
// exit ;
113161: GO 114612
// end ; for i in defenders do
113163: LD_ADDR_VAR 0 4
113167: PUSH
113168: LD_VAR 0 2
113172: PUSH
113173: FOR_IN
113174: IFFALSE 114072
// begin e := NearestUnitToUnit ( enemy , i ) ;
113176: LD_ADDR_VAR 0 13
113180: PUSH
113181: LD_VAR 0 21
113185: PPUSH
113186: LD_VAR 0 4
113190: PPUSH
113191: CALL_OW 74
113195: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113196: LD_ADDR_VAR 0 7
113200: PUSH
113201: LD_EXP 93
113205: PUSH
113206: LD_VAR 0 1
113210: ARRAY
113211: PPUSH
113212: LD_INT 2
113214: PUSH
113215: LD_INT 30
113217: PUSH
113218: LD_INT 0
113220: PUSH
113221: EMPTY
113222: LIST
113223: LIST
113224: PUSH
113225: LD_INT 30
113227: PUSH
113228: LD_INT 1
113230: PUSH
113231: EMPTY
113232: LIST
113233: LIST
113234: PUSH
113235: EMPTY
113236: LIST
113237: LIST
113238: LIST
113239: PPUSH
113240: CALL_OW 72
113244: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113245: LD_ADDR_VAR 0 16
113249: PUSH
113250: LD_VAR 0 7
113254: NOT
113255: PUSH
113256: LD_VAR 0 7
113260: PPUSH
113261: LD_INT 3
113263: PUSH
113264: LD_INT 24
113266: PUSH
113267: LD_INT 600
113269: PUSH
113270: EMPTY
113271: LIST
113272: LIST
113273: PUSH
113274: EMPTY
113275: LIST
113276: LIST
113277: PPUSH
113278: CALL_OW 72
113282: OR
113283: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113284: LD_VAR 0 4
113288: PPUSH
113289: CALL_OW 247
113293: PUSH
113294: LD_INT 2
113296: DOUBLE
113297: EQUAL
113298: IFTRUE 113302
113300: GO 113698
113302: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113303: LD_VAR 0 4
113307: PPUSH
113308: CALL_OW 256
113312: PUSH
113313: LD_INT 1000
113315: EQUAL
113316: PUSH
113317: LD_VAR 0 4
113321: PPUSH
113322: LD_VAR 0 13
113326: PPUSH
113327: CALL_OW 296
113331: PUSH
113332: LD_INT 40
113334: LESS
113335: PUSH
113336: LD_VAR 0 13
113340: PPUSH
113341: LD_EXP 118
113345: PUSH
113346: LD_VAR 0 1
113350: ARRAY
113351: PPUSH
113352: CALL_OW 308
113356: OR
113357: AND
113358: IFFALSE 113480
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113360: LD_VAR 0 4
113364: PPUSH
113365: CALL_OW 262
113369: PUSH
113370: LD_INT 1
113372: EQUAL
113373: PUSH
113374: LD_VAR 0 4
113378: PPUSH
113379: CALL_OW 261
113383: PUSH
113384: LD_INT 30
113386: LESS
113387: AND
113388: PUSH
113389: LD_VAR 0 7
113393: AND
113394: IFFALSE 113464
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113396: LD_VAR 0 4
113400: PPUSH
113401: LD_VAR 0 7
113405: PPUSH
113406: LD_VAR 0 4
113410: PPUSH
113411: CALL_OW 74
113415: PPUSH
113416: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113420: LD_VAR 0 4
113424: PPUSH
113425: LD_VAR 0 7
113429: PPUSH
113430: LD_VAR 0 4
113434: PPUSH
113435: CALL_OW 74
113439: PPUSH
113440: CALL_OW 296
113444: PUSH
113445: LD_INT 6
113447: LESS
113448: IFFALSE 113462
// SetFuel ( i , 100 ) ;
113450: LD_VAR 0 4
113454: PPUSH
113455: LD_INT 100
113457: PPUSH
113458: CALL_OW 240
// end else
113462: GO 113478
// ComAttackUnit ( i , e ) ;
113464: LD_VAR 0 4
113468: PPUSH
113469: LD_VAR 0 13
113473: PPUSH
113474: CALL_OW 115
// end else
113478: GO 113581
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113480: LD_VAR 0 13
113484: PPUSH
113485: LD_EXP 118
113489: PUSH
113490: LD_VAR 0 1
113494: ARRAY
113495: PPUSH
113496: CALL_OW 308
113500: NOT
113501: PUSH
113502: LD_VAR 0 4
113506: PPUSH
113507: LD_VAR 0 13
113511: PPUSH
113512: CALL_OW 296
113516: PUSH
113517: LD_INT 40
113519: GREATEREQUAL
113520: AND
113521: PUSH
113522: LD_VAR 0 4
113526: PPUSH
113527: CALL_OW 256
113531: PUSH
113532: LD_INT 650
113534: LESSEQUAL
113535: OR
113536: PUSH
113537: LD_VAR 0 4
113541: PPUSH
113542: LD_EXP 117
113546: PUSH
113547: LD_VAR 0 1
113551: ARRAY
113552: PPUSH
113553: CALL_OW 308
113557: NOT
113558: AND
113559: IFFALSE 113581
// ComMoveToArea ( i , mc_parking [ base ] ) ;
113561: LD_VAR 0 4
113565: PPUSH
113566: LD_EXP 117
113570: PUSH
113571: LD_VAR 0 1
113575: ARRAY
113576: PPUSH
113577: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113581: LD_VAR 0 4
113585: PPUSH
113586: CALL_OW 256
113590: PUSH
113591: LD_INT 1000
113593: LESS
113594: PUSH
113595: LD_VAR 0 4
113599: PPUSH
113600: CALL_OW 263
113604: PUSH
113605: LD_INT 1
113607: EQUAL
113608: AND
113609: PUSH
113610: LD_VAR 0 4
113614: PPUSH
113615: CALL_OW 311
113619: AND
113620: PUSH
113621: LD_VAR 0 4
113625: PPUSH
113626: LD_EXP 117
113630: PUSH
113631: LD_VAR 0 1
113635: ARRAY
113636: PPUSH
113637: CALL_OW 308
113641: AND
113642: IFFALSE 113696
// begin mech := IsDrivenBy ( i ) ;
113644: LD_ADDR_VAR 0 9
113648: PUSH
113649: LD_VAR 0 4
113653: PPUSH
113654: CALL_OW 311
113658: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113659: LD_VAR 0 9
113663: PPUSH
113664: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113668: LD_VAR 0 9
113672: PPUSH
113673: LD_VAR 0 4
113677: PPUSH
113678: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113682: LD_VAR 0 9
113686: PPUSH
113687: LD_VAR 0 4
113691: PPUSH
113692: CALL_OW 180
// end ; end ; unit_human :
113696: GO 114043
113698: LD_INT 1
113700: DOUBLE
113701: EQUAL
113702: IFTRUE 113706
113704: GO 114042
113706: POP
// begin b := IsInUnit ( i ) ;
113707: LD_ADDR_VAR 0 18
113711: PUSH
113712: LD_VAR 0 4
113716: PPUSH
113717: CALL_OW 310
113721: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
113722: LD_ADDR_VAR 0 19
113726: PUSH
113727: LD_VAR 0 18
113731: NOT
113732: PUSH
113733: LD_VAR 0 18
113737: PPUSH
113738: CALL_OW 266
113742: PUSH
113743: LD_INT 32
113745: PUSH
113746: LD_INT 31
113748: PUSH
113749: EMPTY
113750: LIST
113751: LIST
113752: IN
113753: OR
113754: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
113755: LD_VAR 0 18
113759: PPUSH
113760: CALL_OW 266
113764: PUSH
113765: LD_INT 5
113767: EQUAL
113768: PUSH
113769: LD_VAR 0 4
113773: PPUSH
113774: CALL_OW 257
113778: PUSH
113779: LD_INT 1
113781: PUSH
113782: LD_INT 2
113784: PUSH
113785: LD_INT 3
113787: PUSH
113788: LD_INT 4
113790: PUSH
113791: EMPTY
113792: LIST
113793: LIST
113794: LIST
113795: LIST
113796: IN
113797: AND
113798: IFFALSE 113835
// begin class := AllowSpecClass ( i ) ;
113800: LD_ADDR_VAR 0 20
113804: PUSH
113805: LD_VAR 0 4
113809: PPUSH
113810: CALL 53067 0 1
113814: ST_TO_ADDR
// if class then
113815: LD_VAR 0 20
113819: IFFALSE 113835
// ComChangeProfession ( i , class ) ;
113821: LD_VAR 0 4
113825: PPUSH
113826: LD_VAR 0 20
113830: PPUSH
113831: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113835: LD_VAR 0 16
113839: PUSH
113840: LD_VAR 0 2
113844: PPUSH
113845: LD_INT 21
113847: PUSH
113848: LD_INT 2
113850: PUSH
113851: EMPTY
113852: LIST
113853: LIST
113854: PPUSH
113855: CALL_OW 72
113859: PUSH
113860: LD_INT 1
113862: LESSEQUAL
113863: OR
113864: PUSH
113865: LD_VAR 0 19
113869: AND
113870: PUSH
113871: LD_VAR 0 4
113875: PUSH
113876: LD_VAR 0 17
113880: IN
113881: NOT
113882: AND
113883: IFFALSE 113976
// begin if b then
113885: LD_VAR 0 18
113889: IFFALSE 113938
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113891: LD_VAR 0 18
113895: PPUSH
113896: LD_VAR 0 21
113900: PPUSH
113901: LD_VAR 0 18
113905: PPUSH
113906: CALL_OW 74
113910: PPUSH
113911: CALL_OW 296
113915: PUSH
113916: LD_INT 10
113918: LESS
113919: PUSH
113920: LD_VAR 0 18
113924: PPUSH
113925: CALL_OW 461
113929: PUSH
113930: LD_INT 7
113932: NONEQUAL
113933: AND
113934: IFFALSE 113938
// continue ;
113936: GO 113173
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113938: LD_ADDR_VAR 0 17
113942: PUSH
113943: LD_VAR 0 17
113947: PPUSH
113948: LD_VAR 0 17
113952: PUSH
113953: LD_INT 1
113955: PLUS
113956: PPUSH
113957: LD_VAR 0 4
113961: PPUSH
113962: CALL_OW 1
113966: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113967: LD_VAR 0 4
113971: PPUSH
113972: CALL_OW 122
// end ; if sold_defenders then
113976: LD_VAR 0 17
113980: IFFALSE 114040
// if i in sold_defenders then
113982: LD_VAR 0 4
113986: PUSH
113987: LD_VAR 0 17
113991: IN
113992: IFFALSE 114040
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113994: LD_VAR 0 4
113998: PPUSH
113999: CALL_OW 314
114003: NOT
114004: PUSH
114005: LD_VAR 0 4
114009: PPUSH
114010: LD_VAR 0 13
114014: PPUSH
114015: CALL_OW 296
114019: PUSH
114020: LD_INT 30
114022: LESS
114023: AND
114024: IFFALSE 114040
// ComAttackUnit ( i , e ) ;
114026: LD_VAR 0 4
114030: PPUSH
114031: LD_VAR 0 13
114035: PPUSH
114036: CALL_OW 115
// end ; end ; end ;
114040: GO 114043
114042: POP
// if IsDead ( i ) then
114043: LD_VAR 0 4
114047: PPUSH
114048: CALL_OW 301
114052: IFFALSE 114070
// defenders := defenders diff i ;
114054: LD_ADDR_VAR 0 2
114058: PUSH
114059: LD_VAR 0 2
114063: PUSH
114064: LD_VAR 0 4
114068: DIFF
114069: ST_TO_ADDR
// end ;
114070: GO 113173
114072: POP
114073: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114074: LD_VAR 0 21
114078: NOT
114079: PUSH
114080: LD_VAR 0 2
114084: NOT
114085: OR
114086: PUSH
114087: LD_EXP 93
114091: PUSH
114092: LD_VAR 0 1
114096: ARRAY
114097: NOT
114098: OR
114099: IFFALSE 113077
// MC_Reset ( base , 18 ) ;
114101: LD_VAR 0 1
114105: PPUSH
114106: LD_INT 18
114108: PPUSH
114109: CALL 24956 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114113: LD_ADDR_VAR 0 2
114117: PUSH
114118: LD_VAR 0 2
114122: PUSH
114123: LD_VAR 0 2
114127: PPUSH
114128: LD_INT 2
114130: PUSH
114131: LD_INT 25
114133: PUSH
114134: LD_INT 1
114136: PUSH
114137: EMPTY
114138: LIST
114139: LIST
114140: PUSH
114141: LD_INT 25
114143: PUSH
114144: LD_INT 5
114146: PUSH
114147: EMPTY
114148: LIST
114149: LIST
114150: PUSH
114151: LD_INT 25
114153: PUSH
114154: LD_INT 8
114156: PUSH
114157: EMPTY
114158: LIST
114159: LIST
114160: PUSH
114161: LD_INT 25
114163: PUSH
114164: LD_INT 9
114166: PUSH
114167: EMPTY
114168: LIST
114169: LIST
114170: PUSH
114171: EMPTY
114172: LIST
114173: LIST
114174: LIST
114175: LIST
114176: LIST
114177: PPUSH
114178: CALL_OW 72
114182: DIFF
114183: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114184: LD_VAR 0 21
114188: NOT
114189: PUSH
114190: LD_VAR 0 2
114194: PPUSH
114195: LD_INT 21
114197: PUSH
114198: LD_INT 2
114200: PUSH
114201: EMPTY
114202: LIST
114203: LIST
114204: PPUSH
114205: CALL_OW 72
114209: AND
114210: IFFALSE 114548
// begin tmp := FilterByTag ( defenders , 19 ) ;
114212: LD_ADDR_VAR 0 11
114216: PUSH
114217: LD_VAR 0 2
114221: PPUSH
114222: LD_INT 19
114224: PPUSH
114225: CALL 85536 0 2
114229: ST_TO_ADDR
// if tmp then
114230: LD_VAR 0 11
114234: IFFALSE 114304
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114236: LD_ADDR_VAR 0 11
114240: PUSH
114241: LD_VAR 0 11
114245: PPUSH
114246: LD_INT 25
114248: PUSH
114249: LD_INT 3
114251: PUSH
114252: EMPTY
114253: LIST
114254: LIST
114255: PPUSH
114256: CALL_OW 72
114260: ST_TO_ADDR
// if tmp then
114261: LD_VAR 0 11
114265: IFFALSE 114304
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114267: LD_ADDR_EXP 105
114271: PUSH
114272: LD_EXP 105
114276: PPUSH
114277: LD_VAR 0 1
114281: PPUSH
114282: LD_EXP 105
114286: PUSH
114287: LD_VAR 0 1
114291: ARRAY
114292: PUSH
114293: LD_VAR 0 11
114297: UNION
114298: PPUSH
114299: CALL_OW 1
114303: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114304: LD_VAR 0 1
114308: PPUSH
114309: LD_INT 19
114311: PPUSH
114312: CALL 24956 0 2
// repeat wait ( 0 0$1 ) ;
114316: LD_INT 35
114318: PPUSH
114319: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114323: LD_EXP 93
114327: PUSH
114328: LD_VAR 0 1
114332: ARRAY
114333: NOT
114334: PUSH
114335: LD_EXP 93
114339: PUSH
114340: LD_VAR 0 1
114344: ARRAY
114345: PUSH
114346: EMPTY
114347: EQUAL
114348: OR
114349: IFFALSE 114386
// begin for i in defenders do
114351: LD_ADDR_VAR 0 4
114355: PUSH
114356: LD_VAR 0 2
114360: PUSH
114361: FOR_IN
114362: IFFALSE 114375
// ComStop ( i ) ;
114364: LD_VAR 0 4
114368: PPUSH
114369: CALL_OW 141
114373: GO 114361
114375: POP
114376: POP
// defenders := [ ] ;
114377: LD_ADDR_VAR 0 2
114381: PUSH
114382: EMPTY
114383: ST_TO_ADDR
// exit ;
114384: GO 114612
// end ; for i in defenders do
114386: LD_ADDR_VAR 0 4
114390: PUSH
114391: LD_VAR 0 2
114395: PUSH
114396: FOR_IN
114397: IFFALSE 114486
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114399: LD_VAR 0 4
114403: PPUSH
114404: LD_EXP 117
114408: PUSH
114409: LD_VAR 0 1
114413: ARRAY
114414: PPUSH
114415: CALL_OW 308
114419: NOT
114420: IFFALSE 114444
// ComMoveToArea ( i , mc_parking [ base ] ) else
114422: LD_VAR 0 4
114426: PPUSH
114427: LD_EXP 117
114431: PUSH
114432: LD_VAR 0 1
114436: ARRAY
114437: PPUSH
114438: CALL_OW 113
114442: GO 114484
// if GetControl ( i ) = control_manual then
114444: LD_VAR 0 4
114448: PPUSH
114449: CALL_OW 263
114453: PUSH
114454: LD_INT 1
114456: EQUAL
114457: IFFALSE 114484
// if IsDrivenBy ( i ) then
114459: LD_VAR 0 4
114463: PPUSH
114464: CALL_OW 311
114468: IFFALSE 114484
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114470: LD_VAR 0 4
114474: PPUSH
114475: CALL_OW 311
114479: PPUSH
114480: CALL_OW 121
// end ;
114484: GO 114396
114486: POP
114487: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114488: LD_VAR 0 2
114492: PPUSH
114493: LD_INT 95
114495: PUSH
114496: LD_EXP 117
114500: PUSH
114501: LD_VAR 0 1
114505: ARRAY
114506: PUSH
114507: EMPTY
114508: LIST
114509: LIST
114510: PPUSH
114511: CALL_OW 72
114515: PUSH
114516: LD_VAR 0 2
114520: EQUAL
114521: PUSH
114522: LD_EXP 116
114526: PUSH
114527: LD_VAR 0 1
114531: ARRAY
114532: OR
114533: PUSH
114534: LD_EXP 93
114538: PUSH
114539: LD_VAR 0 1
114543: ARRAY
114544: NOT
114545: OR
114546: IFFALSE 114316
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114548: LD_ADDR_EXP 115
114552: PUSH
114553: LD_EXP 115
114557: PPUSH
114558: LD_VAR 0 1
114562: PPUSH
114563: LD_VAR 0 2
114567: PPUSH
114568: LD_INT 21
114570: PUSH
114571: LD_INT 2
114573: PUSH
114574: EMPTY
114575: LIST
114576: LIST
114577: PPUSH
114578: CALL_OW 72
114582: PPUSH
114583: CALL_OW 1
114587: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
114588: LD_VAR 0 1
114592: PPUSH
114593: LD_INT 19
114595: PPUSH
114596: CALL 24956 0 2
// MC_Reset ( base , 20 ) ;
114600: LD_VAR 0 1
114604: PPUSH
114605: LD_INT 20
114607: PPUSH
114608: CALL 24956 0 2
// end ; end_of_file
114612: LD_VAR 0 3
114616: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
114617: LD_VAR 0 1
114621: PUSH
114622: LD_INT 200
114624: DOUBLE
114625: GREATEREQUAL
114626: IFFALSE 114634
114628: LD_INT 299
114630: DOUBLE
114631: LESSEQUAL
114632: IFTRUE 114636
114634: GO 114668
114636: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
114637: LD_VAR 0 1
114641: PPUSH
114642: LD_VAR 0 2
114646: PPUSH
114647: LD_VAR 0 3
114651: PPUSH
114652: LD_VAR 0 4
114656: PPUSH
114657: LD_VAR 0 5
114661: PPUSH
114662: CALL 103459 0 5
114666: GO 114745
114668: LD_INT 300
114670: DOUBLE
114671: GREATEREQUAL
114672: IFFALSE 114680
114674: LD_INT 399
114676: DOUBLE
114677: LESSEQUAL
114678: IFTRUE 114682
114680: GO 114744
114682: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114683: LD_VAR 0 1
114687: PPUSH
114688: LD_VAR 0 2
114692: PPUSH
114693: LD_VAR 0 3
114697: PPUSH
114698: LD_VAR 0 4
114702: PPUSH
114703: LD_VAR 0 5
114707: PPUSH
114708: LD_VAR 0 6
114712: PPUSH
114713: LD_VAR 0 7
114717: PPUSH
114718: LD_VAR 0 8
114722: PPUSH
114723: LD_VAR 0 9
114727: PPUSH
114728: LD_VAR 0 10
114732: PPUSH
114733: LD_VAR 0 11
114737: PPUSH
114738: CALL 101347 0 11
114742: GO 114745
114744: POP
// end ;
114745: PPOPN 11
114747: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114748: LD_VAR 0 1
114752: PPUSH
114753: LD_VAR 0 2
114757: PPUSH
114758: LD_VAR 0 3
114762: PPUSH
114763: LD_VAR 0 4
114767: PPUSH
114768: LD_VAR 0 5
114772: PPUSH
114773: CALL 103441 0 5
// end ; end_of_file
114777: PPOPN 5
114779: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114780: LD_VAR 0 1
114784: PPUSH
114785: LD_VAR 0 2
114789: PPUSH
114790: LD_VAR 0 3
114794: PPUSH
114795: LD_VAR 0 4
114799: PPUSH
114800: LD_VAR 0 5
114804: PPUSH
114805: LD_VAR 0 6
114809: PPUSH
114810: CALL 90155 0 6
// end ;
114814: PPOPN 6
114816: END
