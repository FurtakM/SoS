// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 21244 0 0
// InitNature ;
  19: CALL 17910 0 0
// InitArtifact ;
  23: CALL 18527 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5059 0 0
// PrepareAlliance ;
  44: CALL 1436 0 0
// PrepareArabian ;
  48: CALL 6831 0 0
// PrepareRussian ;
  52: CALL 8840 0 0
// PrepareLegion ;
  56: CALL 7263 0 0
// Action ;
  60: CALL 11473 0 0
// MC_Start ( ) ;
  64: CALL 23416 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// allianceTeam := [ ] ;
 208: LD_ADDR_EXP 17
 212: PUSH
 213: EMPTY
 214: ST_TO_ADDR
// arabianAttacked := false ;
 215: LD_ADDR_EXP 18
 219: PUSH
 220: LD_INT 0
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 1
 227: RET
// export function CustomInitMacro ( ) ; begin
 228: LD_INT 0
 230: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 231: LD_ADDR_EXP 100
 235: PUSH
 236: LD_INT 26
 238: PUSH
 239: LD_INT 1
 241: PUSH
 242: LD_INT 4
 244: PUSH
 245: LD_INT 8
 247: PUSH
 248: EMPTY
 249: LIST
 250: LIST
 251: LIST
 252: LIST
 253: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 254: LD_ADDR_EXP 101
 258: PUSH
 259: LD_INT 27
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 3
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 6
 282: PUSH
 283: LD_INT 7
 285: PUSH
 286: LD_INT 9
 288: PUSH
 289: LD_INT 10
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_OWVAR 67
 302: ARRAY
 303: PPUSH
 304: LD_INT 28
 306: PPUSH
 307: CALL 45154 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 311: LD_INT 1
 313: PPUSH
 314: LD_INT 10
 316: PUSH
 317: LD_INT 11
 319: PUSH
 320: LD_INT 13
 322: PUSH
 323: LD_INT 15
 325: PUSH
 326: EMPTY
 327: LIST
 328: LIST
 329: LIST
 330: LIST
 331: PPUSH
 332: CALL 46214 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 336: LD_INT 1
 338: PPUSH
 339: LD_INT 29
 341: PUSH
 342: EMPTY
 343: LIST
 344: PPUSH
 345: CALL 46307 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 349: LD_ADDR_EXP 105
 353: PUSH
 354: LD_EXP 105
 358: PPUSH
 359: LD_INT 1
 361: PPUSH
 362: LD_INT 22
 364: PUSH
 365: LD_INT 2
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: PUSH
 372: LD_INT 25
 374: PUSH
 375: LD_INT 15
 377: PUSH
 378: EMPTY
 379: LIST
 380: LIST
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PPUSH
 386: CALL_OW 69
 390: PPUSH
 391: CALL_OW 1
 395: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 396: LD_INT 1
 398: PPUSH
 399: LD_INT 13
 401: PUSH
 402: LD_INT 2
 404: PUSH
 405: LD_INT 1
 407: PUSH
 408: LD_INT 31
 410: PUSH
 411: EMPTY
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: PUSH
 417: LD_INT 13
 419: PUSH
 420: LD_INT 2
 422: PUSH
 423: LD_INT 1
 425: PUSH
 426: LD_INT 31
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_INT 13
 437: PUSH
 438: LD_INT 1
 440: PUSH
 441: LD_INT 1
 443: PUSH
 444: LD_INT 28
 446: PUSH
 447: EMPTY
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: PUSH
 453: LD_INT 13
 455: PUSH
 456: LD_INT 1
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 28
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: PUSH
 471: LD_INT 13
 473: PUSH
 474: LD_INT 1
 476: PUSH
 477: LD_INT 1
 479: PUSH
 480: LD_INT 28
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: LIST
 487: LIST
 488: PUSH
 489: LD_INT 13
 491: PUSH
 492: LD_INT 1
 494: PUSH
 495: LD_INT 1
 497: PUSH
 498: LD_INT 28
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PUSH
 507: LD_INT 13
 509: PUSH
 510: LD_INT 1
 512: PUSH
 513: LD_INT 2
 515: PUSH
 516: LD_INT 88
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: LIST
 523: LIST
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: LIST
 533: PPUSH
 534: CALL 45472 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 538: LD_INT 1
 540: PPUSH
 541: LD_INT 4
 543: PPUSH
 544: CALL 45657 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 10
 553: PUSH
 554: LD_INT 11
 556: PUSH
 557: LD_INT 12
 559: PUSH
 560: LD_INT 14
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PPUSH
 569: CALL 46214 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 573: LD_INT 2
 575: PPUSH
 576: LD_INT 14
 578: PUSH
 579: EMPTY
 580: LIST
 581: PPUSH
 582: CALL 46307 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 586: LD_INT 2
 588: PPUSH
 589: LD_INT 21
 591: PUSH
 592: LD_INT 3
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 51
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PUSH
 607: LD_INT 22
 609: PUSH
 610: LD_INT 3
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 52
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: LIST
 624: PUSH
 625: LD_INT 22
 627: PUSH
 628: LD_INT 3
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 52
 636: PUSH
 637: EMPTY
 638: LIST
 639: LIST
 640: LIST
 641: LIST
 642: PUSH
 643: LD_INT 24
 645: PUSH
 646: LD_INT 3
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: LD_INT 47
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: PUSH
 661: LD_INT 24
 663: PUSH
 664: LD_INT 3
 666: PUSH
 667: LD_INT 3
 669: PUSH
 670: LD_INT 47
 672: PUSH
 673: EMPTY
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: PUSH
 679: LD_INT 24
 681: PUSH
 682: LD_INT 3
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 47
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 24
 699: PUSH
 700: LD_INT 3
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 47
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_INT 24
 717: PUSH
 718: LD_INT 3
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 47
 726: PUSH
 727: EMPTY
 728: LIST
 729: LIST
 730: LIST
 731: LIST
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: PPUSH
 743: CALL 45472 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 747: LD_INT 2
 749: PPUSH
 750: LD_INT 5
 752: PPUSH
 753: CALL 45657 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 757: LD_INT 2
 759: PPUSH
 760: LD_INT 0
 762: PPUSH
 763: CALL 46087 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 10
 772: PUSH
 773: LD_INT 12
 775: PUSH
 776: LD_INT 14
 778: PUSH
 779: LD_INT 15
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_OWVAR 67
 792: ARRAY
 793: PPUSH
 794: LD_INT 24
 796: PPUSH
 797: CALL 45154 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 801: LD_INT 3
 803: PPUSH
 804: LD_INT 10
 806: PUSH
 807: LD_INT 11
 809: PUSH
 810: LD_INT 13
 812: PUSH
 813: LD_INT 15
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: LIST
 821: PPUSH
 822: CALL 46214 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 826: LD_INT 3
 828: PPUSH
 829: LD_INT 13
 831: PUSH
 832: EMPTY
 833: LIST
 834: PPUSH
 835: CALL 46307 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 839: LD_ADDR_EXP 105
 843: PUSH
 844: LD_EXP 105
 848: PPUSH
 849: LD_INT 3
 851: PPUSH
 852: LD_INT 22
 854: PUSH
 855: LD_INT 8
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: PUSH
 862: LD_INT 25
 864: PUSH
 865: LD_INT 15
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: PPUSH
 876: CALL_OW 69
 880: PPUSH
 881: CALL_OW 1
 885: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 13
 891: PUSH
 892: LD_INT 2
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 31
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: PUSH
 907: LD_INT 13
 909: PUSH
 910: LD_INT 2
 912: PUSH
 913: LD_INT 1
 915: PUSH
 916: LD_INT 31
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 13
 927: PUSH
 928: LD_INT 3
 930: PUSH
 931: LD_INT 2
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: EMPTY
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: PUSH
 943: LD_INT 14
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 1
 951: PUSH
 952: LD_INT 28
 954: PUSH
 955: EMPTY
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: PUSH
 961: LD_INT 14
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 1
 969: PUSH
 970: LD_INT 28
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 14
 981: PUSH
 982: LD_INT 1
 984: PUSH
 985: LD_INT 1
 987: PUSH
 988: LD_INT 28
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PUSH
 997: LD_INT 14
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 1
1005: PUSH
1006: LD_INT 28
1008: PUSH
1009: EMPTY
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: PUSH
1015: LD_INT 14
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 2
1023: PUSH
1024: LD_INT 88
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PPUSH
1043: CALL 45472 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1047: LD_INT 3
1049: PPUSH
1050: LD_INT 4
1052: PPUSH
1053: CALL 45657 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: LD_INT 11
1068: PUSH
1069: LD_INT 15
1071: PUSH
1072: EMPTY
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: PPUSH
1078: CALL 46214 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1082: LD_INT 4
1084: PPUSH
1085: LD_INT 33
1087: PUSH
1088: EMPTY
1089: LIST
1090: PPUSH
1091: CALL 46307 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1095: LD_INT 4
1097: PPUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 6
1103: PUSH
1104: LD_INT 7
1106: PUSH
1107: LD_INT 9
1109: PUSH
1110: LD_INT 10
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 46625 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 54
1129: PPUSH
1130: LD_INT 85
1132: PPUSH
1133: LD_INT 2
1135: PPUSH
1136: LD_INT 25
1138: PUSH
1139: LD_INT 16
1141: PUSH
1142: LD_INT 17
1144: PUSH
1145: LD_INT 18
1147: PUSH
1148: LD_INT 22
1150: PUSH
1151: EMPTY
1152: LIST
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PPUSH
1158: CALL 46419 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1162: LD_INT 4
1164: PPUSH
1165: LD_INT 5
1167: PUSH
1168: LD_INT 1
1170: PUSH
1171: LD_INT 1
1173: PUSH
1174: LD_INT 7
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 5
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 1
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: LD_INT 1
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: LD_INT 7
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 5
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: LD_INT 1
1227: PUSH
1228: LD_INT 6
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 5
1239: PUSH
1240: LD_INT 1
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 3
1257: PUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 3
1263: PUSH
1264: LD_INT 13
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PPUSH
1281: CALL 45472 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1285: LD_INT 4
1287: PPUSH
1288: LD_INT 4
1290: PPUSH
1291: CALL 45657 0 2
// MC_SetTame ( 4 , powellApe ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 11
1300: PPUSH
1301: CALL 46038 0 2
// end ;
1305: LD_VAR 0 1
1309: RET
// every 0 0$1 trigger debug do var i ;
1310: LD_EXP 1
1314: IFFALSE 1412
1316: GO 1318
1318: DISABLE
1319: LD_INT 0
1321: PPUSH
// begin enable ;
1322: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1323: LD_ADDR_VAR 0 1
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 7
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: PUSH
1338: LD_INT 2
1340: PUSH
1341: LD_INT 21
1343: PUSH
1344: LD_INT 1
1346: PUSH
1347: EMPTY
1348: LIST
1349: LIST
1350: PUSH
1351: LD_INT 21
1353: PUSH
1354: LD_INT 2
1356: PUSH
1357: EMPTY
1358: LIST
1359: LIST
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 3
1368: PUSH
1369: LD_INT 24
1371: PUSH
1372: LD_INT 1000
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: PPUSH
1388: CALL_OW 69
1392: PUSH
1393: FOR_IN
1394: IFFALSE 1410
// SetLives ( i , 1000 ) ;
1396: LD_VAR 0 1
1400: PPUSH
1401: LD_INT 1000
1403: PPUSH
1404: CALL_OW 234
1408: GO 1393
1410: POP
1411: POP
// end ;
1412: PPOPN 1
1414: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1415: LD_EXP 16
1419: PUSH
1420: LD_INT 5
1422: GREATEREQUAL
1423: IFFALSE 1435
1425: GO 1427
1427: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1428: LD_STRING ACH_ARTIFACT
1430: PPUSH
1431: CALL_OW 543
1435: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1436: LD_INT 0
1438: PPUSH
1439: PPUSH
1440: PPUSH
1441: PPUSH
1442: PPUSH
// uc_side := 7 ;
1443: LD_ADDR_OWVAR 20
1447: PUSH
1448: LD_INT 7
1450: ST_TO_ADDR
// tmp := [ ] ;
1451: LD_ADDR_VAR 0 5
1455: PUSH
1456: EMPTY
1457: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1458: LD_ADDR_EXP 19
1462: PUSH
1463: LD_STRING JMM
1465: PPUSH
1466: LD_EXP 1
1470: NOT
1471: PPUSH
1472: LD_STRING 14a_
1474: PPUSH
1475: CALL 51908 0 3
1479: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1480: LD_ADDR_EXP 51
1484: PUSH
1485: LD_STRING Burlak
1487: PPUSH
1488: LD_EXP 1
1492: NOT
1493: PPUSH
1494: LD_STRING 14a_
1496: PPUSH
1497: CALL 51908 0 3
1501: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1502: LD_ADDR_EXP 34
1506: PUSH
1507: LD_STRING Joan
1509: PPUSH
1510: LD_EXP 1
1514: NOT
1515: PPUSH
1516: LD_STRING 13a_
1518: PPUSH
1519: CALL 51908 0 3
1523: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1524: LD_ADDR_EXP 20
1528: PUSH
1529: LD_STRING Roth
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_STRING 13a_
1540: PPUSH
1541: CALL 51908 0 3
1545: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1546: LD_ADDR_EXP 37
1550: PUSH
1551: LD_STRING Gossudarov
1553: PPUSH
1554: LD_EXP 1
1558: NOT
1559: PPUSH
1560: LD_STRING 13a_
1562: PPUSH
1563: CALL 51908 0 3
1567: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1568: LD_ADDR_EXP 25
1572: PUSH
1573: LD_STRING Denis
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 13a_
1584: PPUSH
1585: CALL 51908 0 3
1589: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1590: LD_ADDR_EXP 35
1594: PUSH
1595: LD_STRING DeltaDoctor
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 13a_
1606: PPUSH
1607: CALL 51908 0 3
1611: ST_TO_ADDR
// if DeltaDoctor then
1612: LD_EXP 35
1616: IFFALSE 1634
// tmp := tmp ^ DeltaDoctor ;
1618: LD_ADDR_VAR 0 5
1622: PUSH
1623: LD_VAR 0 5
1627: PUSH
1628: LD_EXP 35
1632: ADD
1633: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1634: LD_ADDR_EXP 33
1638: PUSH
1639: LD_STRING Simms
1641: PPUSH
1642: LD_EXP 1
1646: NOT
1647: PPUSH
1648: LD_STRING 13a_
1650: PPUSH
1651: CALL 51908 0 3
1655: ST_TO_ADDR
// if Simms then
1656: LD_EXP 33
1660: IFFALSE 1678
// tmp := tmp ^ Simms ;
1662: LD_ADDR_VAR 0 5
1666: PUSH
1667: LD_VAR 0 5
1671: PUSH
1672: LD_EXP 33
1676: ADD
1677: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1678: LD_ADDR_EXP 31
1682: PUSH
1683: LD_STRING Frank
1685: PPUSH
1686: LD_EXP 1
1690: NOT
1691: PPUSH
1692: LD_STRING 13a_
1694: PPUSH
1695: CALL 51908 0 3
1699: ST_TO_ADDR
// if Frank then
1700: LD_EXP 31
1704: IFFALSE 1722
// tmp := tmp ^ Frank ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: LD_EXP 31
1720: ADD
1721: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1722: LD_ADDR_EXP 38
1726: PUSH
1727: LD_STRING Kirilenkova
1729: PPUSH
1730: LD_EXP 1
1734: NOT
1735: PPUSH
1736: LD_STRING 13a_
1738: PPUSH
1739: CALL 51908 0 3
1743: ST_TO_ADDR
// if Kirilenkova then
1744: LD_EXP 38
1748: IFFALSE 1766
// tmp := tmp ^ Kirilenkova ;
1750: LD_ADDR_VAR 0 5
1754: PUSH
1755: LD_VAR 0 5
1759: PUSH
1760: LD_EXP 38
1764: ADD
1765: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1766: LD_ADDR_EXP 39
1770: PUSH
1771: LD_STRING Titov
1773: PPUSH
1774: LD_EXP 1
1778: NOT
1779: PPUSH
1780: LD_STRING 13a_
1782: PPUSH
1783: CALL 51908 0 3
1787: ST_TO_ADDR
// if Titov then
1788: LD_EXP 39
1792: IFFALSE 1810
// tmp := tmp ^ Titov ;
1794: LD_ADDR_VAR 0 5
1798: PUSH
1799: LD_VAR 0 5
1803: PUSH
1804: LD_EXP 39
1808: ADD
1809: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1810: LD_ADDR_EXP 40
1814: PUSH
1815: LD_STRING Fadeev
1817: PPUSH
1818: LD_EXP 1
1822: NOT
1823: PPUSH
1824: LD_STRING 13a_
1826: PPUSH
1827: CALL 51908 0 3
1831: ST_TO_ADDR
// if Fadeev then
1832: LD_EXP 40
1836: IFFALSE 1854
// tmp := tmp ^ Fadeev ;
1838: LD_ADDR_VAR 0 5
1842: PUSH
1843: LD_VAR 0 5
1847: PUSH
1848: LD_EXP 40
1852: ADD
1853: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1854: LD_ADDR_EXP 41
1858: PUSH
1859: LD_STRING Dolgov
1861: PPUSH
1862: LD_EXP 1
1866: NOT
1867: PPUSH
1868: LD_STRING 13a_
1870: PPUSH
1871: CALL 51908 0 3
1875: ST_TO_ADDR
// if Dolgov then
1876: LD_EXP 41
1880: IFFALSE 1898
// tmp := tmp ^ Dolgov ;
1882: LD_ADDR_VAR 0 5
1886: PUSH
1887: LD_VAR 0 5
1891: PUSH
1892: LD_EXP 41
1896: ADD
1897: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1898: LD_ADDR_EXP 42
1902: PUSH
1903: LD_STRING Petrosyan
1905: PPUSH
1906: LD_EXP 1
1910: NOT
1911: PPUSH
1912: LD_STRING 13a_
1914: PPUSH
1915: CALL 51908 0 3
1919: ST_TO_ADDR
// if Petrosyan then
1920: LD_EXP 42
1924: IFFALSE 1942
// tmp := tmp ^ Petrosyan ;
1926: LD_ADDR_VAR 0 5
1930: PUSH
1931: LD_VAR 0 5
1935: PUSH
1936: LD_EXP 42
1940: ADD
1941: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1942: LD_ADDR_EXP 43
1946: PUSH
1947: LD_STRING Scholtze
1949: PPUSH
1950: LD_EXP 1
1954: NOT
1955: PPUSH
1956: LD_STRING 13a_
1958: PPUSH
1959: CALL 51908 0 3
1963: ST_TO_ADDR
// if Scholtze then
1964: LD_EXP 43
1968: IFFALSE 1986
// tmp := tmp ^ Scholtze ;
1970: LD_ADDR_VAR 0 5
1974: PUSH
1975: LD_VAR 0 5
1979: PUSH
1980: LD_EXP 43
1984: ADD
1985: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1986: LD_ADDR_EXP 44
1990: PUSH
1991: LD_STRING Oblukov
1993: PPUSH
1994: LD_EXP 1
1998: NOT
1999: PPUSH
2000: LD_STRING 13a_
2002: PPUSH
2003: CALL 51908 0 3
2007: ST_TO_ADDR
// if Oblukov then
2008: LD_EXP 44
2012: IFFALSE 2030
// tmp := tmp ^ Oblukov ;
2014: LD_ADDR_VAR 0 5
2018: PUSH
2019: LD_VAR 0 5
2023: PUSH
2024: LD_EXP 44
2028: ADD
2029: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2030: LD_ADDR_EXP 45
2034: PUSH
2035: LD_STRING Kapitsova
2037: PPUSH
2038: LD_EXP 1
2042: NOT
2043: PPUSH
2044: LD_STRING 13a_
2046: PPUSH
2047: CALL 51908 0 3
2051: ST_TO_ADDR
// if Kapitsova then
2052: LD_EXP 45
2056: IFFALSE 2074
// tmp := tmp ^ Kapitsova ;
2058: LD_ADDR_VAR 0 5
2062: PUSH
2063: LD_VAR 0 5
2067: PUSH
2068: LD_EXP 45
2072: ADD
2073: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2074: LD_ADDR_EXP 46
2078: PUSH
2079: LD_STRING Lipshchin
2081: PPUSH
2082: LD_EXP 1
2086: NOT
2087: PPUSH
2088: LD_STRING 13a_
2090: PPUSH
2091: CALL 51908 0 3
2095: ST_TO_ADDR
// if Lipshchin then
2096: LD_EXP 46
2100: IFFALSE 2118
// tmp := tmp ^ Lipshchin ;
2102: LD_ADDR_VAR 0 5
2106: PUSH
2107: LD_VAR 0 5
2111: PUSH
2112: LD_EXP 46
2116: ADD
2117: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2118: LD_ADDR_EXP 47
2122: PUSH
2123: LD_STRING Petrovova
2125: PPUSH
2126: LD_EXP 1
2130: NOT
2131: PPUSH
2132: LD_STRING 13a_
2134: PPUSH
2135: CALL 51908 0 3
2139: ST_TO_ADDR
// if Petrovova then
2140: LD_EXP 47
2144: IFFALSE 2162
// tmp := tmp ^ Petrovova ;
2146: LD_ADDR_VAR 0 5
2150: PUSH
2151: LD_VAR 0 5
2155: PUSH
2156: LD_EXP 47
2160: ADD
2161: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2162: LD_ADDR_EXP 48
2166: PUSH
2167: LD_STRING Kovalyuk
2169: PPUSH
2170: LD_EXP 1
2174: NOT
2175: PPUSH
2176: LD_STRING 13a_
2178: PPUSH
2179: CALL 51908 0 3
2183: ST_TO_ADDR
// if Kovalyuk then
2184: LD_EXP 48
2188: IFFALSE 2206
// tmp := tmp ^ Kovalyuk ;
2190: LD_ADDR_VAR 0 5
2194: PUSH
2195: LD_VAR 0 5
2199: PUSH
2200: LD_EXP 48
2204: ADD
2205: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2206: LD_ADDR_EXP 49
2210: PUSH
2211: LD_STRING Kuzmov
2213: PPUSH
2214: LD_EXP 1
2218: NOT
2219: PPUSH
2220: LD_STRING 13a_
2222: PPUSH
2223: CALL 51908 0 3
2227: ST_TO_ADDR
// if Kuzmov then
2228: LD_EXP 49
2232: IFFALSE 2250
// tmp := tmp ^ Kuzmov ;
2234: LD_ADDR_VAR 0 5
2238: PUSH
2239: LD_VAR 0 5
2243: PUSH
2244: LD_EXP 49
2248: ADD
2249: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2250: LD_ADDR_EXP 50
2254: PUSH
2255: LD_STRING Karamazov
2257: PPUSH
2258: LD_EXP 1
2262: NOT
2263: PPUSH
2264: LD_STRING 13a_
2266: PPUSH
2267: CALL 51908 0 3
2271: ST_TO_ADDR
// if Karamazov then
2272: LD_EXP 50
2276: IFFALSE 2294
// tmp := tmp ^ Karamazov ;
2278: LD_ADDR_VAR 0 5
2282: PUSH
2283: LD_VAR 0 5
2287: PUSH
2288: LD_EXP 50
2292: ADD
2293: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2294: LD_ADDR_EXP 52
2298: PUSH
2299: LD_STRING Belkov
2301: PPUSH
2302: LD_EXP 1
2306: NOT
2307: PPUSH
2308: LD_STRING 13a_
2310: PPUSH
2311: CALL 51908 0 3
2315: ST_TO_ADDR
// if Belkov then
2316: LD_EXP 52
2320: IFFALSE 2338
// tmp := tmp ^ Belkov ;
2322: LD_ADDR_VAR 0 5
2326: PUSH
2327: LD_VAR 0 5
2331: PUSH
2332: LD_EXP 52
2336: ADD
2337: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2338: LD_ADDR_EXP 53
2342: PUSH
2343: LD_STRING Gnyevko
2345: PPUSH
2346: LD_EXP 1
2350: NOT
2351: PPUSH
2352: LD_STRING 13a_
2354: PPUSH
2355: CALL 51908 0 3
2359: ST_TO_ADDR
// if Gnyevko then
2360: LD_EXP 53
2364: IFFALSE 2382
// tmp := tmp ^ Gnyevko ;
2366: LD_ADDR_VAR 0 5
2370: PUSH
2371: LD_VAR 0 5
2375: PUSH
2376: LD_EXP 53
2380: ADD
2381: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2382: LD_ADDR_EXP 36
2386: PUSH
2387: LD_STRING Coonie
2389: PPUSH
2390: CALL_OW 25
2394: ST_TO_ADDR
// if not Lisa then
2395: LD_EXP 21
2399: NOT
2400: IFFALSE 2446
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2402: LD_ADDR_EXP 21
2406: PUSH
2407: LD_STRING Lisa
2409: PPUSH
2410: LD_EXP 1
2414: NOT
2415: PPUSH
2416: LD_STRING 13a_
2418: PPUSH
2419: CALL 51908 0 3
2423: ST_TO_ADDR
// if Lisa then
2424: LD_EXP 21
2428: IFFALSE 2446
// tmp := tmp ^ Lisa ;
2430: LD_ADDR_VAR 0 5
2434: PUSH
2435: LD_VAR 0 5
2439: PUSH
2440: LD_EXP 21
2444: ADD
2445: ST_TO_ADDR
// end ; if not Donaldson then
2446: LD_EXP 22
2450: NOT
2451: IFFALSE 2497
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2453: LD_ADDR_EXP 22
2457: PUSH
2458: LD_STRING Donaldson
2460: PPUSH
2461: LD_EXP 1
2465: NOT
2466: PPUSH
2467: LD_STRING 13a_
2469: PPUSH
2470: CALL 51908 0 3
2474: ST_TO_ADDR
// if Donaldson then
2475: LD_EXP 22
2479: IFFALSE 2497
// tmp := tmp ^ Donaldson ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 5
2490: PUSH
2491: LD_EXP 22
2495: ADD
2496: ST_TO_ADDR
// end ; if not Bobby then
2497: LD_EXP 23
2501: NOT
2502: IFFALSE 2548
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2504: LD_ADDR_EXP 23
2508: PUSH
2509: LD_STRING Bobby
2511: PPUSH
2512: LD_EXP 1
2516: NOT
2517: PPUSH
2518: LD_STRING 13a_
2520: PPUSH
2521: CALL 51908 0 3
2525: ST_TO_ADDR
// if Bobby then
2526: LD_EXP 23
2530: IFFALSE 2548
// tmp := tmp ^ Bobby ;
2532: LD_ADDR_VAR 0 5
2536: PUSH
2537: LD_VAR 0 5
2541: PUSH
2542: LD_EXP 23
2546: ADD
2547: ST_TO_ADDR
// end ; if not Cyrus then
2548: LD_EXP 24
2552: NOT
2553: IFFALSE 2599
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2555: LD_ADDR_EXP 24
2559: PUSH
2560: LD_STRING Cyrus
2562: PPUSH
2563: LD_EXP 1
2567: NOT
2568: PPUSH
2569: LD_STRING 13a_
2571: PPUSH
2572: CALL 51908 0 3
2576: ST_TO_ADDR
// if Cyrus then
2577: LD_EXP 24
2581: IFFALSE 2599
// tmp := tmp ^ Cyrus ;
2583: LD_ADDR_VAR 0 5
2587: PUSH
2588: LD_VAR 0 5
2592: PUSH
2593: LD_EXP 24
2597: ADD
2598: ST_TO_ADDR
// end ; if not Brown then
2599: LD_EXP 26
2603: NOT
2604: IFFALSE 2650
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2606: LD_ADDR_EXP 26
2610: PUSH
2611: LD_STRING Brown
2613: PPUSH
2614: LD_EXP 1
2618: NOT
2619: PPUSH
2620: LD_STRING 13a_
2622: PPUSH
2623: CALL 51908 0 3
2627: ST_TO_ADDR
// if Brown then
2628: LD_EXP 26
2632: IFFALSE 2650
// tmp := tmp ^ Brown ;
2634: LD_ADDR_VAR 0 5
2638: PUSH
2639: LD_VAR 0 5
2643: PUSH
2644: LD_EXP 26
2648: ADD
2649: ST_TO_ADDR
// end ; if not Gladstone then
2650: LD_EXP 27
2654: NOT
2655: IFFALSE 2701
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2657: LD_ADDR_EXP 27
2661: PUSH
2662: LD_STRING Gladstone
2664: PPUSH
2665: LD_EXP 1
2669: NOT
2670: PPUSH
2671: LD_STRING 13a_
2673: PPUSH
2674: CALL 51908 0 3
2678: ST_TO_ADDR
// if Gladstone then
2679: LD_EXP 27
2683: IFFALSE 2701
// tmp := tmp ^ Gladstone ;
2685: LD_ADDR_VAR 0 5
2689: PUSH
2690: LD_VAR 0 5
2694: PUSH
2695: LD_EXP 27
2699: ADD
2700: ST_TO_ADDR
// end ; if not Cornel then
2701: LD_EXP 29
2705: NOT
2706: IFFALSE 2752
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2708: LD_ADDR_EXP 29
2712: PUSH
2713: LD_STRING Cornel
2715: PPUSH
2716: LD_EXP 1
2720: NOT
2721: PPUSH
2722: LD_STRING 13a_
2724: PPUSH
2725: CALL 51908 0 3
2729: ST_TO_ADDR
// if Cornel then
2730: LD_EXP 29
2734: IFFALSE 2752
// tmp := tmp ^ Cornel ;
2736: LD_ADDR_VAR 0 5
2740: PUSH
2741: LD_VAR 0 5
2745: PUSH
2746: LD_EXP 29
2750: ADD
2751: ST_TO_ADDR
// end ; if not Houten then
2752: LD_EXP 28
2756: NOT
2757: IFFALSE 2803
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2759: LD_ADDR_EXP 28
2763: PUSH
2764: LD_STRING Houten
2766: PPUSH
2767: LD_EXP 1
2771: NOT
2772: PPUSH
2773: LD_STRING 13a_
2775: PPUSH
2776: CALL 51908 0 3
2780: ST_TO_ADDR
// if Houten then
2781: LD_EXP 28
2785: IFFALSE 2803
// tmp := tmp ^ Houten ;
2787: LD_ADDR_VAR 0 5
2791: PUSH
2792: LD_VAR 0 5
2796: PUSH
2797: LD_EXP 28
2801: ADD
2802: ST_TO_ADDR
// end ; if not Gary then
2803: LD_EXP 30
2807: NOT
2808: IFFALSE 2854
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2810: LD_ADDR_EXP 30
2814: PUSH
2815: LD_STRING Gary
2817: PPUSH
2818: LD_EXP 1
2822: NOT
2823: PPUSH
2824: LD_STRING 13a_
2826: PPUSH
2827: CALL 51908 0 3
2831: ST_TO_ADDR
// if Gary then
2832: LD_EXP 30
2836: IFFALSE 2854
// tmp := tmp ^ Gary ;
2838: LD_ADDR_VAR 0 5
2842: PUSH
2843: LD_VAR 0 5
2847: PUSH
2848: LD_EXP 30
2852: ADD
2853: ST_TO_ADDR
// end ; if not Kikuchi then
2854: LD_EXP 32
2858: NOT
2859: IFFALSE 2905
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2861: LD_ADDR_EXP 32
2865: PUSH
2866: LD_STRING Kikuchi
2868: PPUSH
2869: LD_EXP 1
2873: NOT
2874: PPUSH
2875: LD_STRING 13a_
2877: PPUSH
2878: CALL 51908 0 3
2882: ST_TO_ADDR
// if Kikuchi then
2883: LD_EXP 32
2887: IFFALSE 2905
// tmp := tmp ^ Kikuchi ;
2889: LD_ADDR_VAR 0 5
2893: PUSH
2894: LD_VAR 0 5
2898: PUSH
2899: LD_EXP 32
2903: ADD
2904: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2905: LD_ADDR_VAR 0 5
2909: PUSH
2910: LD_VAR 0 5
2914: PUSH
2915: LD_STRING 13a_others
2917: PPUSH
2918: CALL_OW 31
2922: UNION
2923: ST_TO_ADDR
// tmp := tmp diff 0 ;
2924: LD_ADDR_VAR 0 5
2928: PUSH
2929: LD_VAR 0 5
2933: PUSH
2934: LD_INT 0
2936: DIFF
2937: ST_TO_ADDR
// if tmp < 15 then
2938: LD_VAR 0 5
2942: PUSH
2943: LD_INT 15
2945: LESS
2946: IFFALSE 3034
// for i = 15 downto tmp do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 15
2956: INC
2957: ST_TO_ADDR
2958: LD_VAR 0 5
2962: PUSH
2963: FOR_DOWNTO
2964: IFFALSE 3032
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2966: LD_ADDR_OWVAR 21
2970: PUSH
2971: LD_INT 1
2973: PUSH
2974: LD_INT 3
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: PUSH
2981: LD_INT 1
2983: PPUSH
2984: LD_INT 2
2986: PPUSH
2987: CALL_OW 12
2991: ARRAY
2992: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2993: LD_INT 0
2995: PPUSH
2996: LD_INT 1
2998: PPUSH
2999: LD_INT 4
3001: PPUSH
3002: CALL_OW 12
3006: PPUSH
3007: LD_INT 8
3009: PPUSH
3010: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3014: LD_ADDR_VAR 0 5
3018: PUSH
3019: LD_VAR 0 5
3023: PUSH
3024: CALL_OW 44
3028: ADD
3029: ST_TO_ADDR
// end ;
3030: GO 2963
3032: POP
3033: POP
// if not debug then
3034: LD_EXP 1
3038: NOT
3039: IFFALSE 3219
// selected = CharacterSelection (  , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3041: LD_ADDR_VAR 0 4
3045: PUSH
3046: LD_STRING 
3048: PPUSH
3049: LD_INT 14
3051: PUSH
3052: LD_INT 14
3054: PUSH
3055: LD_INT 13
3057: PUSH
3058: LD_INT 12
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: PUSH
3067: LD_OWVAR 67
3071: ARRAY
3072: PPUSH
3073: LD_INT 14
3075: PUSH
3076: LD_INT 14
3078: PUSH
3079: LD_INT 13
3081: PUSH
3082: LD_INT 12
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_OWVAR 67
3095: ARRAY
3096: PPUSH
3097: LD_INT -5
3099: PUSH
3100: LD_EXP 19
3104: PUSH
3105: LD_EXP 51
3109: PUSH
3110: LD_EXP 20
3114: PUSH
3115: LD_EXP 34
3119: PUSH
3120: LD_EXP 25
3124: PUSH
3125: LD_EXP 37
3129: PUSH
3130: LD_INT -2
3132: PUSH
3133: LD_INT -3
3135: PUSH
3136: LD_INT -5
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_VAR 0 5
3155: ADD
3156: PPUSH
3157: LD_INT 1
3159: PUSH
3160: LD_INT 4
3162: PUSH
3163: LD_INT 2
3165: PUSH
3166: LD_INT 1
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: PUSH
3173: LD_INT 3
3175: PUSH
3176: LD_INT 5
3178: PUSH
3179: LD_INT 0
3181: PUSH
3182: LD_INT 3
3184: PUSH
3185: EMPTY
3186: LIST
3187: LIST
3188: LIST
3189: PUSH
3190: LD_INT 9
3192: PUSH
3193: LD_INT 0
3195: PUSH
3196: LD_INT 3
3198: PUSH
3199: EMPTY
3200: LIST
3201: LIST
3202: LIST
3203: PUSH
3204: EMPTY
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: PPUSH
3212: CALL_OW 42
3216: ST_TO_ADDR
3217: GO 3268
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3219: LD_ADDR_VAR 0 4
3223: PUSH
3224: LD_EXP 39
3228: PUSH
3229: LD_EXP 40
3233: PUSH
3234: LD_EXP 41
3238: PUSH
3239: LD_EXP 42
3243: PUSH
3244: LD_EXP 43
3248: PUSH
3249: LD_EXP 44
3253: PUSH
3254: LD_EXP 45
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3268: LD_ADDR_EXP 17
3272: PUSH
3273: LD_VAR 0 5
3277: PUSH
3278: LD_VAR 0 4
3282: DIFF
3283: ST_TO_ADDR
// uc_nation := 1 ;
3284: LD_ADDR_OWVAR 21
3288: PUSH
3289: LD_INT 1
3291: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3292: LD_INT 5
3294: PPUSH
3295: LD_INT 3
3297: PPUSH
3298: LD_INT 1
3300: PPUSH
3301: LD_INT 6
3303: PPUSH
3304: LD_INT 100
3306: PPUSH
3307: CALL 56923 0 5
// veh := CreateVehicle ;
3311: LD_ADDR_VAR 0 3
3315: PUSH
3316: CALL_OW 45
3320: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3321: LD_VAR 0 3
3325: PPUSH
3326: LD_INT 7
3328: NEG
3329: PPUSH
3330: CALL_OW 242
// SetDir ( veh , 3 ) ;
3334: LD_VAR 0 3
3338: PPUSH
3339: LD_INT 3
3341: PPUSH
3342: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3346: LD_VAR 0 3
3350: PPUSH
3351: LD_INT 31
3353: PPUSH
3354: LD_INT 0
3356: PPUSH
3357: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3361: LD_EXP 19
3365: PPUSH
3366: LD_VAR 0 3
3370: PPUSH
3371: CALL_OW 52
// if Joan then
3375: LD_EXP 34
3379: IFFALSE 3451
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3381: LD_INT 3
3383: PPUSH
3384: LD_INT 3
3386: PPUSH
3387: LD_INT 1
3389: PPUSH
3390: LD_INT 11
3392: PPUSH
3393: LD_INT 100
3395: PPUSH
3396: CALL 56923 0 5
// veh := CreateVehicle ;
3400: LD_ADDR_VAR 0 3
3404: PUSH
3405: CALL_OW 45
3409: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3410: LD_VAR 0 3
3414: PPUSH
3415: LD_INT 3
3417: PPUSH
3418: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3422: LD_VAR 0 3
3426: PPUSH
3427: LD_INT 30
3429: PPUSH
3430: LD_INT 0
3432: PPUSH
3433: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3437: LD_EXP 34
3441: PPUSH
3442: LD_VAR 0 3
3446: PPUSH
3447: CALL_OW 52
// end ; if Roth then
3451: LD_EXP 20
3455: IFFALSE 3527
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3457: LD_INT 3
3459: PPUSH
3460: LD_INT 3
3462: PPUSH
3463: LD_INT 1
3465: PPUSH
3466: LD_INT 11
3468: PPUSH
3469: LD_INT 100
3471: PPUSH
3472: CALL 56923 0 5
// veh := CreateVehicle ;
3476: LD_ADDR_VAR 0 3
3480: PUSH
3481: CALL_OW 45
3485: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3486: LD_VAR 0 3
3490: PPUSH
3491: LD_INT 3
3493: PPUSH
3494: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3498: LD_VAR 0 3
3502: PPUSH
3503: LD_INT 30
3505: PPUSH
3506: LD_INT 0
3508: PPUSH
3509: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3513: LD_EXP 20
3517: PPUSH
3518: LD_VAR 0 3
3522: PPUSH
3523: CALL_OW 52
// end ; if Denis then
3527: LD_EXP 25
3531: IFFALSE 3603
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3533: LD_INT 5
3535: PPUSH
3536: LD_INT 3
3538: PPUSH
3539: LD_INT 1
3541: PPUSH
3542: LD_INT 9
3544: PPUSH
3545: LD_INT 100
3547: PPUSH
3548: CALL 56923 0 5
// veh := CreateVehicle ;
3552: LD_ADDR_VAR 0 3
3556: PUSH
3557: CALL_OW 45
3561: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3562: LD_VAR 0 3
3566: PPUSH
3567: LD_INT 3
3569: PPUSH
3570: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3574: LD_VAR 0 3
3578: PPUSH
3579: LD_INT 30
3581: PPUSH
3582: LD_INT 0
3584: PPUSH
3585: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3589: LD_EXP 25
3593: PPUSH
3594: LD_VAR 0 3
3598: PPUSH
3599: CALL_OW 52
// end ; uc_nation := 3 ;
3603: LD_ADDR_OWVAR 21
3607: PUSH
3608: LD_INT 3
3610: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3611: LD_INT 22
3613: PPUSH
3614: LD_INT 3
3616: PPUSH
3617: LD_INT 1
3619: PPUSH
3620: LD_INT 45
3622: PPUSH
3623: LD_INT 100
3625: PPUSH
3626: CALL 56923 0 5
// veh := CreateVehicle ;
3630: LD_ADDR_VAR 0 3
3634: PUSH
3635: CALL_OW 45
3639: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3640: LD_VAR 0 3
3644: PPUSH
3645: LD_INT 7
3647: NEG
3648: PPUSH
3649: CALL_OW 242
// SetDir ( veh , 3 ) ;
3653: LD_VAR 0 3
3657: PPUSH
3658: LD_INT 3
3660: PPUSH
3661: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3665: LD_VAR 0 3
3669: PPUSH
3670: LD_INT 31
3672: PPUSH
3673: LD_INT 0
3675: PPUSH
3676: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3680: LD_EXP 51
3684: PPUSH
3685: LD_VAR 0 3
3689: PPUSH
3690: CALL_OW 52
// if Gossudarov then
3694: LD_EXP 37
3698: IFFALSE 3785
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3700: LD_INT 22
3702: PPUSH
3703: LD_INT 3
3705: PPUSH
3706: LD_INT 1
3708: PPUSH
3709: LD_INT 51
3711: PPUSH
3712: LD_INT 100
3714: PPUSH
3715: CALL 56923 0 5
// veh := CreateVehicle ;
3719: LD_ADDR_VAR 0 3
3723: PUSH
3724: CALL_OW 45
3728: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3729: LD_VAR 0 3
3733: PPUSH
3734: LD_INT 3
3736: PPUSH
3737: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3741: LD_VAR 0 3
3745: PPUSH
3746: LD_INT 30
3748: PPUSH
3749: LD_INT 0
3751: PPUSH
3752: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3756: LD_EXP 37
3760: PPUSH
3761: LD_VAR 0 3
3765: PPUSH
3766: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3770: LD_VAR 0 3
3774: PPUSH
3775: LD_INT 1
3777: PPUSH
3778: LD_INT 100
3780: PPUSH
3781: CALL_OW 290
// end ; for i in selected do
3785: LD_ADDR_VAR 0 2
3789: PUSH
3790: LD_VAR 0 4
3794: PUSH
3795: FOR_IN
3796: IFFALSE 4354
// begin uc_nation := GetNation ( i ) ;
3798: LD_ADDR_OWVAR 21
3802: PUSH
3803: LD_VAR 0 2
3807: PPUSH
3808: CALL_OW 248
3812: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3813: LD_VAR 0 2
3817: PUSH
3818: LD_EXP 21
3822: PUSH
3823: LD_EXP 22
3827: PUSH
3828: LD_EXP 24
3832: PUSH
3833: LD_EXP 23
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: LIST
3842: LIST
3843: IN
3844: IFFALSE 3867
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3846: LD_INT 5
3848: PPUSH
3849: LD_INT 3
3851: PPUSH
3852: LD_INT 1
3854: PPUSH
3855: LD_INT 6
3857: PPUSH
3858: LD_INT 100
3860: PPUSH
3861: CALL 56923 0 5
3865: GO 4301
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3867: LD_VAR 0 2
3871: PUSH
3872: LD_EXP 44
3876: PUSH
3877: LD_EXP 49
3881: PUSH
3882: LD_EXP 47
3886: PUSH
3887: LD_EXP 39
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: LIST
3896: LIST
3897: IN
3898: IFFALSE 3929
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3900: LD_INT 24
3902: PPUSH
3903: LD_INT 1
3905: PPUSH
3906: LD_INT 1
3908: PPUSH
3909: LD_INT 46
3911: PPUSH
3912: LD_INT 65
3914: PPUSH
3915: LD_INT 75
3917: PPUSH
3918: CALL_OW 12
3922: PPUSH
3923: CALL 56923 0 5
3927: GO 4301
// if i = Karamazov then
3929: LD_VAR 0 2
3933: PUSH
3934: LD_EXP 50
3938: EQUAL
3939: IFFALSE 3962
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3941: LD_INT 22
3943: PPUSH
3944: LD_INT 3
3946: PPUSH
3947: LD_INT 1
3949: PPUSH
3950: LD_INT 52
3952: PPUSH
3953: LD_INT 100
3955: PPUSH
3956: CALL 56923 0 5
3960: GO 4301
// if i = Brown then
3962: LD_VAR 0 2
3966: PUSH
3967: LD_EXP 26
3971: EQUAL
3972: IFFALSE 3995
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3974: LD_INT 3
3976: PPUSH
3977: LD_INT 3
3979: PPUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_INT 13
3985: PPUSH
3986: LD_INT 100
3988: PPUSH
3989: CALL 56923 0 5
3993: GO 4301
// if uc_nation = nation_american then
3995: LD_OWVAR 21
3999: PUSH
4000: LD_INT 1
4002: EQUAL
4003: IFFALSE 4154
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4005: LD_INT 3
4007: PUSH
4008: LD_INT 5
4010: PUSH
4011: LD_INT 5
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: LIST
4018: PUSH
4019: LD_OWVAR 21
4023: PUSH
4024: LD_INT 3
4026: MOD
4027: PUSH
4028: LD_INT 1
4030: PLUS
4031: ARRAY
4032: PPUSH
4033: LD_INT 1
4035: PUSH
4036: LD_INT 3
4038: PUSH
4039: LD_INT 1
4041: PUSH
4042: EMPTY
4043: LIST
4044: LIST
4045: LIST
4046: PUSH
4047: LD_OWVAR 21
4051: PUSH
4052: LD_INT 3
4054: MOD
4055: PUSH
4056: LD_INT 1
4058: PLUS
4059: ARRAY
4060: PPUSH
4061: LD_INT 1
4063: PPUSH
4064: LD_INT 11
4066: PUSH
4067: LD_INT 4
4069: PUSH
4070: LD_INT 5
4072: PUSH
4073: EMPTY
4074: LIST
4075: LIST
4076: LIST
4077: PUSH
4078: LD_INT 6
4080: PUSH
4081: LD_INT 7
4083: PUSH
4084: LD_INT 9
4086: PUSH
4087: EMPTY
4088: LIST
4089: LIST
4090: LIST
4091: PUSH
4092: LD_INT 6
4094: PUSH
4095: LD_INT 9
4097: PUSH
4098: LD_INT 12
4100: PUSH
4101: EMPTY
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: LIST
4110: PUSH
4111: LD_OWVAR 21
4115: PUSH
4116: LD_INT 3
4118: MOD
4119: PUSH
4120: LD_INT 1
4122: PLUS
4123: ARRAY
4124: PUSH
4125: LD_INT 1
4127: PPUSH
4128: LD_INT 3
4130: PPUSH
4131: CALL_OW 12
4135: ARRAY
4136: PPUSH
4137: LD_INT 65
4139: PPUSH
4140: LD_INT 75
4142: PPUSH
4143: CALL_OW 12
4147: PPUSH
4148: CALL 56923 0 5
// end else
4152: GO 4301
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4154: LD_INT 22
4156: PUSH
4157: LD_INT 23
4159: PUSH
4160: LD_INT 23
4162: PUSH
4163: EMPTY
4164: LIST
4165: LIST
4166: LIST
4167: PUSH
4168: LD_OWVAR 21
4172: PUSH
4173: LD_INT 3
4175: MOD
4176: PUSH
4177: LD_INT 1
4179: PLUS
4180: ARRAY
4181: PPUSH
4182: LD_INT 1
4184: PUSH
4185: LD_INT 3
4187: PUSH
4188: LD_INT 1
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: LIST
4195: PUSH
4196: LD_OWVAR 21
4200: PUSH
4201: LD_INT 3
4203: MOD
4204: PUSH
4205: LD_INT 1
4207: PLUS
4208: ARRAY
4209: PPUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 45
4215: PUSH
4216: LD_INT 43
4218: PUSH
4219: LD_INT 44
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: LIST
4226: PUSH
4227: LD_INT 46
4229: PUSH
4230: LD_INT 45
4232: PUSH
4233: LD_INT 44
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: LIST
4240: PUSH
4241: LD_INT 46
4243: PUSH
4244: LD_INT 43
4246: PUSH
4247: LD_INT 45
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: LIST
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: LIST
4259: PUSH
4260: LD_OWVAR 21
4264: PUSH
4265: LD_INT 3
4267: MOD
4268: PUSH
4269: LD_INT 1
4271: PLUS
4272: ARRAY
4273: PUSH
4274: LD_INT 1
4276: PPUSH
4277: LD_INT 3
4279: PPUSH
4280: CALL_OW 12
4284: ARRAY
4285: PPUSH
4286: LD_INT 65
4288: PPUSH
4289: LD_INT 75
4291: PPUSH
4292: CALL_OW 12
4296: PPUSH
4297: CALL 56923 0 5
// end ; veh := CreateVehicle ;
4301: LD_ADDR_VAR 0 3
4305: PUSH
4306: CALL_OW 45
4310: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4311: LD_VAR 0 3
4315: PPUSH
4316: LD_INT 3
4318: PPUSH
4319: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4323: LD_VAR 0 3
4327: PPUSH
4328: LD_INT 30
4330: PPUSH
4331: LD_INT 0
4333: PPUSH
4334: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4338: LD_VAR 0 2
4342: PPUSH
4343: LD_VAR 0 3
4347: PPUSH
4348: CALL_OW 52
// end ;
4352: GO 3795
4354: POP
4355: POP
// if artifactArCaptured then
4356: LD_EXP 9
4360: IFFALSE 4446
// begin uc_nation := nation_american ;
4362: LD_ADDR_OWVAR 21
4366: PUSH
4367: LD_INT 1
4369: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4370: LD_INT 3
4372: PPUSH
4373: LD_INT 3
4375: PPUSH
4376: LD_INT 3
4378: PPUSH
4379: LD_INT 12
4381: PPUSH
4382: LD_INT 100
4384: PPUSH
4385: CALL 56923 0 5
// veh := CreateVehicle ;
4389: LD_ADDR_VAR 0 3
4393: PUSH
4394: CALL_OW 45
4398: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4399: LD_VAR 0 3
4403: PPUSH
4404: LD_INT 3
4406: PPUSH
4407: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4411: LD_VAR 0 3
4415: PPUSH
4416: LD_INT 198
4418: PPUSH
4419: LD_INT 22
4421: PPUSH
4422: LD_INT 0
4424: PPUSH
4425: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4429: LD_VAR 0 3
4433: PPUSH
4434: LD_INT 4
4436: PPUSH
4437: LD_INT 50
4439: PPUSH
4440: CALL_OW 290
// end else
4444: GO 4465
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4446: LD_INT 4
4448: PPUSH
4449: LD_INT 5
4451: PPUSH
4452: LD_INT 267
4454: PPUSH
4455: LD_INT 226
4457: PPUSH
4458: LD_INT 0
4460: PPUSH
4461: CALL_OW 58
// end ; uc_nation := nation_american ;
4465: LD_ADDR_OWVAR 21
4469: PUSH
4470: LD_INT 1
4472: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4473: LD_INT 3
4475: PPUSH
4476: LD_INT 3
4478: PPUSH
4479: LD_INT 3
4481: PPUSH
4482: LD_INT 12
4484: PPUSH
4485: LD_INT 100
4487: PPUSH
4488: CALL 56923 0 5
// veh := CreateVehicle ;
4492: LD_ADDR_VAR 0 3
4496: PUSH
4497: CALL_OW 45
4501: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4502: LD_VAR 0 3
4506: PPUSH
4507: LD_INT 3
4509: PPUSH
4510: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4514: LD_VAR 0 3
4518: PPUSH
4519: LD_INT 218
4521: PPUSH
4522: LD_INT 23
4524: PPUSH
4525: LD_INT 0
4527: PPUSH
4528: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4532: LD_VAR 0 3
4536: PPUSH
4537: LD_INT 4
4539: PPUSH
4540: LD_INT 30
4542: PPUSH
4543: CALL_OW 290
// uc_nation := nation_russian ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 3
4554: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4555: LD_INT 22
4557: PPUSH
4558: LD_INT 3
4560: PPUSH
4561: LD_INT 3
4563: PPUSH
4564: LD_INT 51
4566: PPUSH
4567: LD_INT 100
4569: PPUSH
4570: CALL 56923 0 5
// veh := CreateVehicle ;
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: CALL_OW 45
4583: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4584: LD_VAR 0 3
4588: PPUSH
4589: LD_INT 3
4591: PPUSH
4592: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4596: LD_VAR 0 3
4600: PPUSH
4601: LD_INT 214
4603: PPUSH
4604: LD_INT 20
4606: PPUSH
4607: LD_INT 0
4609: PPUSH
4610: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4614: LD_VAR 0 3
4618: PPUSH
4619: LD_INT 4
4621: PPUSH
4622: LD_INT 40
4624: PPUSH
4625: CALL_OW 290
// end ;
4629: LD_VAR 0 1
4633: RET
// export function AllianceSupport ; var i , veh ; begin
4634: LD_INT 0
4636: PPUSH
4637: PPUSH
4638: PPUSH
// if not allianceTeam then
4639: LD_EXP 17
4643: NOT
4644: IFFALSE 4648
// exit ;
4646: GO 5054
// for i := 1 to 6 do
4648: LD_ADDR_VAR 0 2
4652: PUSH
4653: DOUBLE
4654: LD_INT 1
4656: DEC
4657: ST_TO_ADDR
4658: LD_INT 6
4660: PUSH
4661: FOR_TO
4662: IFFALSE 4958
// begin uc_side := 7 ;
4664: LD_ADDR_OWVAR 20
4668: PUSH
4669: LD_INT 7
4671: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4672: LD_ADDR_OWVAR 21
4676: PUSH
4677: LD_INT 1
4679: PUSH
4680: LD_INT 3
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: PUSH
4687: LD_VAR 0 2
4691: PUSH
4692: LD_INT 2
4694: MOD
4695: PUSH
4696: LD_INT 1
4698: PLUS
4699: ARRAY
4700: ST_TO_ADDR
// if uc_nation = 1 then
4701: LD_OWVAR 21
4705: PUSH
4706: LD_INT 1
4708: EQUAL
4709: IFFALSE 4751
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4711: LD_INT 5
4713: PPUSH
4714: LD_INT 3
4716: PPUSH
4717: LD_INT 1
4719: PPUSH
4720: LD_INT 6
4722: PUSH
4723: LD_INT 7
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 1
4732: PPUSH
4733: LD_INT 2
4735: PPUSH
4736: CALL_OW 12
4740: ARRAY
4741: PPUSH
4742: LD_INT 100
4744: PPUSH
4745: CALL 56923 0 5
4749: GO 4789
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4751: LD_INT 23
4753: PPUSH
4754: LD_INT 3
4756: PPUSH
4757: LD_INT 1
4759: PPUSH
4760: LD_INT 46
4762: PUSH
4763: LD_INT 47
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 2
4775: PPUSH
4776: CALL_OW 12
4780: ARRAY
4781: PPUSH
4782: LD_INT 100
4784: PPUSH
4785: CALL 56923 0 5
// if not allianceTeam then
4789: LD_EXP 17
4793: NOT
4794: IFFALSE 4798
// break ;
4796: GO 4958
// veh := CreateVehicle ;
4798: LD_ADDR_VAR 0 3
4802: PUSH
4803: CALL_OW 45
4807: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4808: LD_VAR 0 3
4812: PPUSH
4813: LD_INT 4
4815: PPUSH
4816: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4820: LD_VAR 0 3
4824: PPUSH
4825: LD_INT 38
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4835: LD_EXP 17
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 3
4846: PPUSH
4847: CALL_OW 259
4851: PUSH
4852: LD_INT 4
4854: GREATER
4855: IFFALSE 4873
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4857: LD_EXP 17
4861: PUSH
4862: LD_INT 1
4864: ARRAY
4865: PPUSH
4866: LD_INT 3
4868: PPUSH
4869: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4873: LD_EXP 17
4877: PUSH
4878: LD_INT 1
4880: ARRAY
4881: PPUSH
4882: LD_INT 4
4884: PPUSH
4885: CALL_OW 259
4889: PUSH
4890: LD_INT 8
4892: GREATER
4893: IFFALSE 4911
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4895: LD_EXP 17
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: PPUSH
4904: LD_INT 4
4906: PPUSH
4907: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4911: LD_EXP 17
4915: PUSH
4916: LD_INT 1
4918: ARRAY
4919: PPUSH
4920: LD_VAR 0 3
4924: PPUSH
4925: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4929: LD_ADDR_EXP 17
4933: PUSH
4934: LD_EXP 17
4938: PPUSH
4939: LD_INT 1
4941: PPUSH
4942: CALL_OW 3
4946: ST_TO_ADDR
// ComHold ( veh ) ;
4947: LD_VAR 0 3
4951: PPUSH
4952: CALL_OW 140
// end ;
4956: GO 4661
4958: POP
4959: POP
// uc_side := 7 ;
4960: LD_ADDR_OWVAR 20
4964: PUSH
4965: LD_INT 7
4967: ST_TO_ADDR
// uc_nation := 1 ;
4968: LD_ADDR_OWVAR 21
4972: PUSH
4973: LD_INT 1
4975: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
4976: LD_INT 5
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: LD_INT 3
4984: PPUSH
4985: LD_INT 11
4987: PPUSH
4988: LD_INT 100
4990: PPUSH
4991: CALL 56923 0 5
// veh := CreateVehicle ;
4995: LD_ADDR_VAR 0 3
4999: PUSH
5000: CALL_OW 45
5004: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5005: LD_VAR 0 3
5009: PPUSH
5010: LD_INT 4
5012: PPUSH
5013: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5017: LD_VAR 0 3
5021: PPUSH
5022: LD_INT 305
5024: PPUSH
5025: LD_INT 218
5027: PPUSH
5028: LD_INT 0
5030: PPUSH
5031: CALL_OW 48
// ComHold ( veh ) ;
5035: LD_VAR 0 3
5039: PPUSH
5040: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5044: LD_INT 313
5046: PPUSH
5047: LD_INT 220
5049: PPUSH
5050: CALL_OW 86
// end ; end_of_file
5054: LD_VAR 0 1
5058: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5059: LD_INT 0
5061: PPUSH
5062: PPUSH
5063: PPUSH
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
// InitHc ;
5071: CALL_OW 19
// uc_side := 1 ;
5075: LD_ADDR_OWVAR 20
5079: PUSH
5080: LD_INT 1
5082: ST_TO_ADDR
// uc_nation := 1 ;
5083: LD_ADDR_OWVAR 21
5087: PUSH
5088: LD_INT 1
5090: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5091: LD_ADDR_VAR 0 2
5095: PUSH
5096: LD_INT 22
5098: PUSH
5099: LD_INT 1
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 21
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: PUSH
5125: FOR_IN
5126: IFFALSE 5142
// SetBLevel ( i , 10 ) ;
5128: LD_VAR 0 2
5132: PPUSH
5133: LD_INT 10
5135: PPUSH
5136: CALL_OW 241
5140: GO 5125
5142: POP
5143: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5144: LD_INT 387
5146: PPUSH
5147: CALL_OW 274
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: LD_INT 7500
5157: PPUSH
5158: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5162: LD_INT 387
5164: PPUSH
5165: CALL_OW 274
5169: PPUSH
5170: LD_INT 2
5172: PPUSH
5173: LD_INT 4000
5175: PPUSH
5176: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5180: LD_INT 387
5182: PPUSH
5183: CALL_OW 274
5187: PPUSH
5188: LD_INT 3
5190: PPUSH
5191: LD_INT 50
5193: PPUSH
5194: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5198: LD_INT 476
5200: PPUSH
5201: CALL_OW 274
5205: PPUSH
5206: LD_INT 1
5208: PPUSH
5209: LD_INT 5500
5211: PPUSH
5212: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5216: LD_INT 476
5218: PPUSH
5219: CALL_OW 274
5223: PPUSH
5224: LD_INT 2
5226: PPUSH
5227: LD_INT 4000
5229: PPUSH
5230: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5234: LD_INT 476
5236: PPUSH
5237: CALL_OW 274
5241: PPUSH
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 10
5247: PPUSH
5248: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5252: LD_ADDR_EXP 54
5256: PUSH
5257: LD_STRING Powell
5259: PPUSH
5260: CALL_OW 25
5264: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5265: LD_EXP 54
5269: PPUSH
5270: LD_INT 387
5272: PPUSH
5273: CALL_OW 52
// tmp := [ ] ;
5277: LD_ADDR_VAR 0 6
5281: PUSH
5282: EMPTY
5283: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5284: LD_ADDR_EXP 21
5288: PUSH
5289: LD_STRING Lisa
5291: PPUSH
5292: LD_EXP 1
5296: NOT
5297: PPUSH
5298: LD_STRING 12p_
5300: PPUSH
5301: CALL 51908 0 3
5305: ST_TO_ADDR
// if Lisa then
5306: LD_EXP 21
5310: IFFALSE 5328
// tmp := tmp ^ Lisa ;
5312: LD_ADDR_VAR 0 6
5316: PUSH
5317: LD_VAR 0 6
5321: PUSH
5322: LD_EXP 21
5326: ADD
5327: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5328: LD_ADDR_EXP 22
5332: PUSH
5333: LD_STRING Donaldson
5335: PPUSH
5336: LD_EXP 1
5340: NOT
5341: PPUSH
5342: LD_STRING 12p_
5344: PPUSH
5345: CALL 51908 0 3
5349: ST_TO_ADDR
// if Donaldson then
5350: LD_EXP 22
5354: IFFALSE 5372
// tmp := tmp ^ Donaldson ;
5356: LD_ADDR_VAR 0 6
5360: PUSH
5361: LD_VAR 0 6
5365: PUSH
5366: LD_EXP 22
5370: ADD
5371: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5372: LD_ADDR_EXP 23
5376: PUSH
5377: LD_STRING Bobby
5379: PPUSH
5380: LD_EXP 1
5384: NOT
5385: PPUSH
5386: LD_STRING 12p_
5388: PPUSH
5389: CALL 51908 0 3
5393: ST_TO_ADDR
// if Bobby then
5394: LD_EXP 23
5398: IFFALSE 5416
// tmp := tmp ^ Bobby ;
5400: LD_ADDR_VAR 0 6
5404: PUSH
5405: LD_VAR 0 6
5409: PUSH
5410: LD_EXP 23
5414: ADD
5415: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5416: LD_ADDR_EXP 24
5420: PUSH
5421: LD_STRING Cyrus
5423: PPUSH
5424: LD_EXP 1
5428: NOT
5429: PPUSH
5430: LD_STRING 12p_
5432: PPUSH
5433: CALL 51908 0 3
5437: ST_TO_ADDR
// if Cyrus then
5438: LD_EXP 24
5442: IFFALSE 5460
// tmp := tmp ^ Cyrus ;
5444: LD_ADDR_VAR 0 6
5448: PUSH
5449: LD_VAR 0 6
5453: PUSH
5454: LD_EXP 24
5458: ADD
5459: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5460: LD_ADDR_EXP 26
5464: PUSH
5465: LD_STRING Brown
5467: PPUSH
5468: LD_EXP 1
5472: NOT
5473: PPUSH
5474: LD_STRING 12p_
5476: PPUSH
5477: CALL 51908 0 3
5481: ST_TO_ADDR
// if Brown then
5482: LD_EXP 26
5486: IFFALSE 5504
// tmp := tmp ^ Brown ;
5488: LD_ADDR_VAR 0 6
5492: PUSH
5493: LD_VAR 0 6
5497: PUSH
5498: LD_EXP 26
5502: ADD
5503: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5504: LD_ADDR_EXP 27
5508: PUSH
5509: LD_STRING Gladstone
5511: PPUSH
5512: LD_EXP 1
5516: NOT
5517: PPUSH
5518: LD_STRING 12p_
5520: PPUSH
5521: CALL 51908 0 3
5525: ST_TO_ADDR
// if Gladstone then
5526: LD_EXP 27
5530: IFFALSE 5548
// tmp := tmp ^ Gladstone ;
5532: LD_ADDR_VAR 0 6
5536: PUSH
5537: LD_VAR 0 6
5541: PUSH
5542: LD_EXP 27
5546: ADD
5547: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5548: LD_ADDR_EXP 28
5552: PUSH
5553: LD_STRING Houten
5555: PPUSH
5556: LD_EXP 1
5560: NOT
5561: PPUSH
5562: LD_STRING 12p_
5564: PPUSH
5565: CALL 51908 0 3
5569: ST_TO_ADDR
// if Houten then
5570: LD_EXP 28
5574: IFFALSE 5592
// tmp := tmp ^ Houten ;
5576: LD_ADDR_VAR 0 6
5580: PUSH
5581: LD_VAR 0 6
5585: PUSH
5586: LD_EXP 28
5590: ADD
5591: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5592: LD_ADDR_EXP 29
5596: PUSH
5597: LD_STRING Cornel
5599: PPUSH
5600: LD_EXP 1
5604: NOT
5605: PPUSH
5606: LD_STRING 12p_
5608: PPUSH
5609: CALL 51908 0 3
5613: ST_TO_ADDR
// if Cornel then
5614: LD_EXP 29
5618: IFFALSE 5636
// tmp := tmp ^ Cornel ;
5620: LD_ADDR_VAR 0 6
5624: PUSH
5625: LD_VAR 0 6
5629: PUSH
5630: LD_EXP 29
5634: ADD
5635: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5636: LD_ADDR_EXP 30
5640: PUSH
5641: LD_STRING Gary
5643: PPUSH
5644: LD_EXP 1
5648: NOT
5649: PPUSH
5650: LD_STRING 12p_
5652: PPUSH
5653: CALL 51908 0 3
5657: ST_TO_ADDR
// if Gary then
5658: LD_EXP 30
5662: IFFALSE 5680
// tmp := tmp ^ Gary ;
5664: LD_ADDR_VAR 0 6
5668: PUSH
5669: LD_VAR 0 6
5673: PUSH
5674: LD_EXP 30
5678: ADD
5679: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5680: LD_ADDR_EXP 32
5684: PUSH
5685: LD_STRING Kikuchi
5687: PPUSH
5688: LD_EXP 1
5692: NOT
5693: PPUSH
5694: LD_STRING 12p_
5696: PPUSH
5697: CALL 51908 0 3
5701: ST_TO_ADDR
// if Kikuchi then
5702: LD_EXP 32
5706: IFFALSE 5724
// tmp := tmp ^ Kikuchi ;
5708: LD_ADDR_VAR 0 6
5712: PUSH
5713: LD_VAR 0 6
5717: PUSH
5718: LD_EXP 32
5722: ADD
5723: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5724: LD_ADDR_VAR 0 6
5728: PUSH
5729: LD_VAR 0 6
5733: PUSH
5734: LD_STRING 12p_others
5736: PPUSH
5737: CALL_OW 31
5741: UNION
5742: ST_TO_ADDR
// if tmp < 36 then
5743: LD_VAR 0 6
5747: PUSH
5748: LD_INT 36
5750: LESS
5751: IFFALSE 5818
// for i = 1 to 36 - tmp do
5753: LD_ADDR_VAR 0 2
5757: PUSH
5758: DOUBLE
5759: LD_INT 1
5761: DEC
5762: ST_TO_ADDR
5763: LD_INT 36
5765: PUSH
5766: LD_VAR 0 6
5770: MINUS
5771: PUSH
5772: FOR_TO
5773: IFFALSE 5816
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5775: LD_INT 1
5777: PPUSH
5778: LD_VAR 0 2
5782: PUSH
5783: LD_INT 4
5785: MOD
5786: PUSH
5787: LD_INT 1
5789: PLUS
5790: PPUSH
5791: LD_INT 10
5793: PPUSH
5794: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5798: LD_ADDR_VAR 0 6
5802: PUSH
5803: LD_VAR 0 6
5807: PUSH
5808: CALL_OW 44
5812: ADD
5813: ST_TO_ADDR
// end ;
5814: GO 5772
5816: POP
5817: POP
// for i in tmp do
5818: LD_ADDR_VAR 0 2
5822: PUSH
5823: LD_VAR 0 6
5827: PUSH
5828: FOR_IN
5829: IFFALSE 5854
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5831: LD_VAR 0 2
5835: PPUSH
5836: LD_INT 62
5838: PPUSH
5839: LD_INT 93
5841: PPUSH
5842: LD_INT 9
5844: PPUSH
5845: LD_INT 0
5847: PPUSH
5848: CALL_OW 50
5852: GO 5828
5854: POP
5855: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5856: LD_ADDR_EXP 76
5860: PUSH
5861: LD_EXP 76
5865: PPUSH
5866: LD_INT 4
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PPUSH
5879: CALL_OW 69
5883: PUSH
5884: LD_EXP 54
5888: DIFF
5889: PPUSH
5890: CALL_OW 1
5894: ST_TO_ADDR
// uc_side := 0 ;
5895: LD_ADDR_OWVAR 20
5899: PUSH
5900: LD_INT 0
5902: ST_TO_ADDR
// uc_nation := 0 ;
5903: LD_ADDR_OWVAR 21
5907: PUSH
5908: LD_INT 0
5910: ST_TO_ADDR
// for i = 1 to 4 do
5911: LD_ADDR_VAR 0 2
5915: PUSH
5916: DOUBLE
5917: LD_INT 1
5919: DEC
5920: ST_TO_ADDR
5921: LD_INT 4
5923: PUSH
5924: FOR_TO
5925: IFFALSE 5956
// begin InitHc ;
5927: CALL_OW 19
// hc_class := class_apeman ;
5931: LD_ADDR_OWVAR 28
5935: PUSH
5936: LD_INT 12
5938: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5939: CALL_OW 44
5943: PPUSH
5944: LD_INT 11
5946: PPUSH
5947: LD_INT 0
5949: PPUSH
5950: CALL_OW 49
// end ;
5954: GO 5924
5956: POP
5957: POP
// end ;
5958: LD_VAR 0 1
5962: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5963: LD_EXP 4
5967: NOT
5968: PUSH
5969: LD_INT 4
5971: PPUSH
5972: LD_INT 1
5974: PPUSH
5975: CALL 46938 0 2
5979: NOT
5980: AND
5981: IFFALSE 6753
5983: GO 5985
5985: DISABLE
5986: LD_INT 0
5988: PPUSH
5989: PPUSH
5990: PPUSH
// begin enable ;
5991: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5992: LD_INT 22
5994: PUSH
5995: LD_INT 1
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 23
6004: PUSH
6005: LD_INT 1
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: LD_INT 30
6014: PUSH
6015: LD_INT 3
6017: PUSH
6018: EMPTY
6019: LIST
6020: LIST
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: LIST
6026: PPUSH
6027: CALL_OW 69
6031: NOT
6032: IFFALSE 6036
// exit ;
6034: GO 6753
// if Prob ( 40 ) then
6036: LD_INT 40
6038: PPUSH
6039: CALL_OW 13
6043: IFFALSE 6170
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6045: LD_INT 4
6047: PPUSH
6048: LD_INT 5
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 2
6056: PUSH
6057: LD_INT 7
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 5
6068: PUSH
6069: LD_INT 1
6071: PUSH
6072: LD_INT 2
6074: PUSH
6075: LD_INT 7
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 5
6086: PUSH
6087: LD_INT 1
6089: PUSH
6090: LD_INT 2
6092: PUSH
6093: LD_INT 7
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 5
6104: PUSH
6105: LD_INT 1
6107: PUSH
6108: LD_INT 2
6110: PUSH
6111: LD_INT 6
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 5
6122: PUSH
6123: LD_INT 1
6125: PUSH
6126: LD_INT 2
6128: PUSH
6129: LD_INT 6
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 5
6140: PUSH
6141: LD_INT 1
6143: PUSH
6144: LD_INT 2
6146: PUSH
6147: LD_INT 6
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: EMPTY
6157: LIST
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PPUSH
6164: CALL 45520 0 2
// end else
6168: GO 6293
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6170: LD_INT 4
6172: PPUSH
6173: LD_INT 5
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 7
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 5
6193: PUSH
6194: LD_INT 1
6196: PUSH
6197: LD_INT 2
6199: PUSH
6200: LD_INT 9
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 5
6211: PUSH
6212: LD_INT 1
6214: PUSH
6215: LD_INT 2
6217: PUSH
6218: LD_INT 9
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 5
6229: PUSH
6230: LD_INT 1
6232: PUSH
6233: LD_INT 2
6235: PUSH
6236: LD_INT 6
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 5
6247: PUSH
6248: LD_INT 1
6250: PUSH
6251: LD_INT 2
6253: PUSH
6254: LD_INT 6
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: PUSH
6263: LD_INT 5
6265: PUSH
6266: LD_INT 1
6268: PUSH
6269: LD_INT 2
6271: PUSH
6272: LD_INT 6
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PPUSH
6289: CALL 45520 0 2
// end ; repeat wait ( 0 0$1 ) ;
6293: LD_INT 35
6295: PPUSH
6296: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6300: LD_INT 4
6302: PPUSH
6303: LD_INT 1
6305: PPUSH
6306: CALL 46938 0 2
6310: PUSH
6311: LD_INT 6
6313: GREATEREQUAL
6314: IFFALSE 6293
// wait ( 0 0$30 ) ;
6316: LD_INT 1050
6318: PPUSH
6319: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6323: LD_ADDR_VAR 0 2
6327: PUSH
6328: LD_INT 4
6330: PPUSH
6331: LD_INT 1
6333: PPUSH
6334: CALL 46938 0 2
6338: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6339: LD_ADDR_EXP 95
6343: PUSH
6344: LD_EXP 95
6348: PPUSH
6349: LD_INT 4
6351: PPUSH
6352: LD_EXP 95
6356: PUSH
6357: LD_INT 4
6359: ARRAY
6360: PUSH
6361: LD_VAR 0 2
6365: DIFF
6366: PPUSH
6367: CALL_OW 1
6371: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6372: LD_ADDR_VAR 0 3
6376: PUSH
6377: LD_INT 0
6379: PPUSH
6380: LD_INT 2
6382: PPUSH
6383: CALL_OW 12
6387: ST_TO_ADDR
// if target then
6388: LD_VAR 0 3
6392: IFFALSE 6520
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6394: LD_ADDR_VAR 0 2
6398: PUSH
6399: LD_VAR 0 2
6403: PPUSH
6404: LD_INT 24
6406: PUSH
6407: LD_INT 250
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PPUSH
6414: CALL_OW 72
6418: ST_TO_ADDR
// for i in tmp do
6419: LD_ADDR_VAR 0 1
6423: PUSH
6424: LD_VAR 0 2
6428: PUSH
6429: FOR_IN
6430: IFFALSE 6470
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6432: LD_VAR 0 1
6436: PPUSH
6437: LD_INT 114
6439: PPUSH
6440: LD_INT 108
6442: PPUSH
6443: CALL_OW 297
6447: PUSH
6448: LD_INT 9
6450: GREATER
6451: IFFALSE 6468
// ComMoveXY ( i , 114 , 108 ) ;
6453: LD_VAR 0 1
6457: PPUSH
6458: LD_INT 114
6460: PPUSH
6461: LD_INT 108
6463: PPUSH
6464: CALL_OW 111
6468: GO 6429
6470: POP
6471: POP
// wait ( 0 0$1 ) ;
6472: LD_INT 35
6474: PPUSH
6475: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6479: LD_VAR 0 2
6483: PPUSH
6484: LD_INT 92
6486: PUSH
6487: LD_INT 114
6489: PUSH
6490: LD_INT 108
6492: PUSH
6493: LD_INT 9
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: PPUSH
6502: CALL_OW 72
6506: PUSH
6507: LD_VAR 0 2
6511: PUSH
6512: LD_INT 1
6514: MINUS
6515: GREATEREQUAL
6516: IFFALSE 6394
// end else
6518: GO 6644
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6520: LD_ADDR_VAR 0 2
6524: PUSH
6525: LD_VAR 0 2
6529: PPUSH
6530: LD_INT 24
6532: PUSH
6533: LD_INT 250
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: PPUSH
6540: CALL_OW 72
6544: ST_TO_ADDR
// for i in tmp do
6545: LD_ADDR_VAR 0 1
6549: PUSH
6550: LD_VAR 0 2
6554: PUSH
6555: FOR_IN
6556: IFFALSE 6596
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6558: LD_VAR 0 1
6562: PPUSH
6563: LD_INT 129
6565: PPUSH
6566: LD_INT 139
6568: PPUSH
6569: CALL_OW 297
6573: PUSH
6574: LD_INT 9
6576: GREATER
6577: IFFALSE 6594
// ComMoveXY ( i , 129 , 139 ) ;
6579: LD_VAR 0 1
6583: PPUSH
6584: LD_INT 129
6586: PPUSH
6587: LD_INT 139
6589: PPUSH
6590: CALL_OW 111
6594: GO 6555
6596: POP
6597: POP
// wait ( 0 0$1 ) ;
6598: LD_INT 35
6600: PPUSH
6601: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6605: LD_VAR 0 2
6609: PPUSH
6610: LD_INT 92
6612: PUSH
6613: LD_INT 129
6615: PUSH
6616: LD_INT 139
6618: PUSH
6619: LD_INT 9
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PPUSH
6628: CALL_OW 72
6632: PUSH
6633: LD_VAR 0 2
6637: PUSH
6638: LD_INT 1
6640: MINUS
6641: GREATEREQUAL
6642: IFFALSE 6520
// end ; repeat wait ( 0 0$1 ) ;
6644: LD_INT 35
6646: PPUSH
6647: CALL_OW 67
// for i in tmp do
6651: LD_ADDR_VAR 0 1
6655: PUSH
6656: LD_VAR 0 2
6660: PUSH
6661: FOR_IN
6662: IFFALSE 6744
// begin if GetLives ( i ) > 251 then
6664: LD_VAR 0 1
6668: PPUSH
6669: CALL_OW 256
6673: PUSH
6674: LD_INT 251
6676: GREATER
6677: IFFALSE 6715
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6679: LD_VAR 0 1
6683: PPUSH
6684: LD_INT 81
6686: PUSH
6687: LD_INT 1
6689: PUSH
6690: EMPTY
6691: LIST
6692: LIST
6693: PPUSH
6694: CALL_OW 69
6698: PPUSH
6699: LD_VAR 0 1
6703: PPUSH
6704: CALL_OW 74
6708: PPUSH
6709: CALL_OW 115
6713: GO 6742
// if IsDead ( i ) then
6715: LD_VAR 0 1
6719: PPUSH
6720: CALL_OW 301
6724: IFFALSE 6742
// tmp := tmp diff i ;
6726: LD_ADDR_VAR 0 2
6730: PUSH
6731: LD_VAR 0 2
6735: PUSH
6736: LD_VAR 0 1
6740: DIFF
6741: ST_TO_ADDR
// end ;
6742: GO 6661
6744: POP
6745: POP
// until not tmp ;
6746: LD_VAR 0 2
6750: NOT
6751: IFFALSE 6644
// end ;
6753: PPOPN 3
6755: END
// every 30 30$00 trigger not americanDestroyed do
6756: LD_EXP 4
6760: NOT
6761: IFFALSE 6830
6763: GO 6765
6765: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6766: LD_INT 63000
6768: PUSH
6769: LD_INT 42000
6771: PUSH
6772: LD_INT 31500
6774: PUSH
6775: LD_INT 21000
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: LIST
6782: LIST
6783: PUSH
6784: LD_OWVAR 67
6788: ARRAY
6789: PPUSH
6790: CALL_OW 67
// if americanDestroyed then
6794: LD_EXP 4
6798: IFFALSE 6802
// exit ;
6800: GO 6830
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6802: LD_INT 4
6804: PPUSH
6805: LD_INT 5
6807: PUSH
6808: LD_INT 3
6810: PUSH
6811: LD_INT 1
6813: PUSH
6814: LD_INT 8
6816: PUSH
6817: EMPTY
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: PUSH
6823: EMPTY
6824: LIST
6825: PPUSH
6826: CALL 45520 0 2
// end ; end_of_file
6830: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6831: LD_INT 0
6833: PPUSH
6834: PPUSH
6835: PPUSH
6836: PPUSH
6837: PPUSH
// side := 2 ;
6838: LD_ADDR_VAR 0 5
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// InitHc ;
6846: CALL_OW 19
// uc_side := side ;
6850: LD_ADDR_OWVAR 20
6854: PUSH
6855: LD_VAR 0 5
6859: ST_TO_ADDR
// uc_nation := 2 ;
6860: LD_ADDR_OWVAR 21
6864: PUSH
6865: LD_INT 2
6867: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6868: LD_ADDR_VAR 0 2
6872: PUSH
6873: LD_INT 22
6875: PUSH
6876: LD_INT 2
6878: PUSH
6879: EMPTY
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 21
6885: PUSH
6886: LD_INT 3
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PPUSH
6897: CALL_OW 69
6901: PUSH
6902: FOR_IN
6903: IFFALSE 6919
// SetBLevel ( i , 10 ) ;
6905: LD_VAR 0 2
6909: PPUSH
6910: LD_INT 10
6912: PPUSH
6913: CALL_OW 241
6917: GO 6902
6919: POP
6920: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6921: LD_ADDR_VAR 0 4
6925: PUSH
6926: LD_INT 22
6928: PUSH
6929: LD_VAR 0 5
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: LD_INT 30
6940: PUSH
6941: LD_INT 32
6943: PUSH
6944: EMPTY
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 58
6950: PUSH
6951: EMPTY
6952: LIST
6953: PUSH
6954: EMPTY
6955: LIST
6956: LIST
6957: LIST
6958: PPUSH
6959: CALL_OW 69
6963: ST_TO_ADDR
// for i = 1 to 10 do
6964: LD_ADDR_VAR 0 2
6968: PUSH
6969: DOUBLE
6970: LD_INT 1
6972: DEC
6973: ST_TO_ADDR
6974: LD_INT 10
6976: PUSH
6977: FOR_TO
6978: IFFALSE 7050
// begin uc_nation := nation_nature ;
6980: LD_ADDR_OWVAR 21
6984: PUSH
6985: LD_INT 0
6987: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6988: LD_ADDR_OWVAR 28
6992: PUSH
6993: LD_INT 15
6995: ST_TO_ADDR
// hc_gallery :=  ;
6996: LD_ADDR_OWVAR 33
7000: PUSH
7001: LD_STRING 
7003: ST_TO_ADDR
// hc_name :=  ;
7004: LD_ADDR_OWVAR 26
7008: PUSH
7009: LD_STRING 
7011: ST_TO_ADDR
// un := CreateHuman ;
7012: LD_ADDR_VAR 0 3
7016: PUSH
7017: CALL_OW 44
7021: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7022: LD_VAR 0 3
7026: PPUSH
7027: LD_VAR 0 4
7031: PUSH
7032: LD_VAR 0 4
7036: PUSH
7037: LD_VAR 0 2
7041: MINUS
7042: ARRAY
7043: PPUSH
7044: CALL_OW 52
// end ;
7048: GO 6977
7050: POP
7051: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7052: LD_INT 503
7054: PPUSH
7055: LD_INT 27
7057: PPUSH
7058: LD_STRING 
7060: PPUSH
7061: LD_INT 8
7063: PUSH
7064: LD_INT 9
7066: PUSH
7067: LD_INT 10
7069: PUSH
7070: LD_INT 10
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: LIST
7077: LIST
7078: PUSH
7079: LD_OWVAR 67
7083: ARRAY
7084: PPUSH
7085: LD_INT 3000
7087: PUSH
7088: LD_INT 500
7090: PUSH
7091: LD_INT 150
7093: PUSH
7094: EMPTY
7095: LIST
7096: LIST
7097: LIST
7098: PPUSH
7099: LD_INT 16
7101: PUSH
7102: LD_INT 6
7104: PUSH
7105: LD_INT 6
7107: PUSH
7108: LD_INT 6
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: PPUSH
7117: CALL 60367 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7121: LD_ADDR_EXP 76
7125: PUSH
7126: LD_EXP 76
7130: PPUSH
7131: LD_INT 1
7133: PPUSH
7134: LD_INT 22
7136: PUSH
7137: LD_VAR 0 5
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: PUSH
7146: LD_INT 23
7148: PUSH
7149: LD_INT 2
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PUSH
7156: LD_INT 3
7158: PUSH
7159: LD_INT 21
7161: PUSH
7162: LD_INT 2
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: PUSH
7169: EMPTY
7170: LIST
7171: LIST
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: LIST
7177: PPUSH
7178: CALL_OW 69
7182: PPUSH
7183: CALL_OW 1
7187: ST_TO_ADDR
// end ;
7188: LD_VAR 0 1
7192: RET
// export Omar ; export function PrepareOmarAli ; begin
7193: LD_INT 0
7195: PPUSH
// uc_side := 5 ;
7196: LD_ADDR_OWVAR 20
7200: PUSH
7201: LD_INT 5
7203: ST_TO_ADDR
// uc_nation := 2 ;
7204: LD_ADDR_OWVAR 21
7208: PUSH
7209: LD_INT 2
7211: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7212: LD_ADDR_EXP 55
7216: PUSH
7217: LD_STRING Omar
7219: PPUSH
7220: CALL_OW 25
7224: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7225: LD_EXP 55
7229: PPUSH
7230: LD_INT 330
7232: PPUSH
7233: LD_INT 244
7235: PPUSH
7236: LD_INT 0
7238: PPUSH
7239: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7243: LD_EXP 55
7247: PPUSH
7248: LD_INT 252
7250: PPUSH
7251: LD_INT 220
7253: PPUSH
7254: CALL_OW 111
// end ; end_of_file
7258: LD_VAR 0 1
7262: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7263: LD_INT 0
7265: PPUSH
7266: PPUSH
7267: PPUSH
7268: PPUSH
7269: PPUSH
// side := 8 ;
7270: LD_ADDR_VAR 0 3
7274: PUSH
7275: LD_INT 8
7277: ST_TO_ADDR
// InitHc ;
7278: CALL_OW 19
// uc_side := side ;
7282: LD_ADDR_OWVAR 20
7286: PUSH
7287: LD_VAR 0 3
7291: ST_TO_ADDR
// uc_nation := 2 ;
7292: LD_ADDR_OWVAR 21
7296: PUSH
7297: LD_INT 2
7299: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7300: LD_ADDR_VAR 0 2
7304: PUSH
7305: LD_INT 22
7307: PUSH
7308: LD_VAR 0 3
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: LD_INT 21
7319: PUSH
7320: LD_INT 3
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: PUSH
7327: EMPTY
7328: LIST
7329: LIST
7330: PPUSH
7331: CALL_OW 69
7335: PUSH
7336: FOR_IN
7337: IFFALSE 7353
// SetBLevel ( i , 10 ) ;
7339: LD_VAR 0 2
7343: PPUSH
7344: LD_INT 10
7346: PPUSH
7347: CALL_OW 241
7351: GO 7336
7353: POP
7354: POP
// Schulz := NewCharacter ( Schulz ) ;
7355: LD_ADDR_EXP 56
7359: PUSH
7360: LD_STRING Schulz
7362: PPUSH
7363: CALL_OW 25
7367: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7368: LD_ADDR_EXP 57
7372: PUSH
7373: LD_STRING Kozlov
7375: PPUSH
7376: LD_INT 0
7378: PPUSH
7379: LD_STRING 
7381: PPUSH
7382: CALL 51908 0 3
7386: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7387: LD_EXP 57
7391: PPUSH
7392: LD_INT 22
7394: PUSH
7395: LD_INT 8
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: PUSH
7402: LD_INT 23
7404: PUSH
7405: LD_INT 3
7407: PUSH
7408: EMPTY
7409: LIST
7410: LIST
7411: PUSH
7412: LD_INT 30
7414: PUSH
7415: LD_INT 8
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: LIST
7426: PPUSH
7427: CALL_OW 69
7431: PUSH
7432: LD_INT 1
7434: ARRAY
7435: PPUSH
7436: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7440: LD_EXP 57
7444: PPUSH
7445: LD_INT 3
7447: PPUSH
7448: LD_INT 10
7450: PPUSH
7451: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7455: LD_ADDR_VAR 0 5
7459: PUSH
7460: LD_INT 22
7462: PUSH
7463: LD_VAR 0 3
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: PUSH
7472: LD_INT 30
7474: PUSH
7475: LD_INT 32
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: LD_INT 58
7484: PUSH
7485: EMPTY
7486: LIST
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: LIST
7492: PPUSH
7493: CALL_OW 69
7497: ST_TO_ADDR
// for i = 1 to 10 do
7498: LD_ADDR_VAR 0 2
7502: PUSH
7503: DOUBLE
7504: LD_INT 1
7506: DEC
7507: ST_TO_ADDR
7508: LD_INT 10
7510: PUSH
7511: FOR_TO
7512: IFFALSE 7584
// begin uc_nation := nation_nature ;
7514: LD_ADDR_OWVAR 21
7518: PUSH
7519: LD_INT 0
7521: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7522: LD_ADDR_OWVAR 28
7526: PUSH
7527: LD_INT 15
7529: ST_TO_ADDR
// hc_gallery :=  ;
7530: LD_ADDR_OWVAR 33
7534: PUSH
7535: LD_STRING 
7537: ST_TO_ADDR
// hc_name :=  ;
7538: LD_ADDR_OWVAR 26
7542: PUSH
7543: LD_STRING 
7545: ST_TO_ADDR
// un := CreateHuman ;
7546: LD_ADDR_VAR 0 4
7550: PUSH
7551: CALL_OW 44
7555: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7556: LD_VAR 0 4
7560: PPUSH
7561: LD_VAR 0 5
7565: PUSH
7566: LD_VAR 0 5
7570: PUSH
7571: LD_VAR 0 2
7575: MINUS
7576: ARRAY
7577: PPUSH
7578: CALL_OW 52
// end ;
7582: GO 7511
7584: POP
7585: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7586: LD_INT 324
7588: PPUSH
7589: LD_INT 3
7591: PPUSH
7592: LD_STRING 
7594: PPUSH
7595: LD_INT 8
7597: PUSH
7598: LD_INT 9
7600: PUSH
7601: LD_INT 10
7603: PUSH
7604: LD_INT 10
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_OWVAR 67
7617: ARRAY
7618: PPUSH
7619: LD_INT 3000
7621: PUSH
7622: LD_INT 500
7624: PUSH
7625: LD_INT 150
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: LIST
7632: PPUSH
7633: LD_INT 16
7635: PUSH
7636: LD_INT 6
7638: PUSH
7639: LD_INT 6
7641: PUSH
7642: LD_INT 8
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: LIST
7649: LIST
7650: PPUSH
7651: CALL 60367 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7655: LD_ADDR_EXP 76
7659: PUSH
7660: LD_EXP 76
7664: PPUSH
7665: LD_INT 3
7667: PPUSH
7668: LD_INT 22
7670: PUSH
7671: LD_VAR 0 3
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 23
7682: PUSH
7683: LD_INT 2
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 3
7692: PUSH
7693: LD_INT 21
7695: PUSH
7696: LD_INT 2
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: LIST
7711: PPUSH
7712: CALL_OW 69
7716: PUSH
7717: LD_EXP 56
7721: DIFF
7722: PPUSH
7723: CALL_OW 1
7727: ST_TO_ADDR
// end ;
7728: LD_VAR 0 1
7732: RET
// export function BuildKozlovBomb ; begin
7733: LD_INT 0
7735: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7736: LD_INT 332
7738: PPUSH
7739: CALL_OW 302
7743: NOT
7744: PUSH
7745: LD_INT 336
7747: PPUSH
7748: CALL_OW 302
7752: NOT
7753: OR
7754: IFFALSE 7758
// exit ;
7756: GO 7855
// ComChangeProfession ( Kozlov , 4 ) ;
7758: LD_EXP 57
7762: PPUSH
7763: LD_INT 4
7765: PPUSH
7766: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7770: LD_INT 336
7772: PPUSH
7773: LD_INT 25
7775: PPUSH
7776: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7780: LD_INT 35
7782: PPUSH
7783: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7787: LD_INT 25
7789: PPUSH
7790: LD_INT 8
7792: PPUSH
7793: CALL_OW 321
7797: PUSH
7798: LD_INT 2
7800: EQUAL
7801: IFFALSE 7780
// ComExitBuilding ( Kozlov ) ;
7803: LD_EXP 57
7807: PPUSH
7808: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7812: LD_EXP 57
7816: PPUSH
7817: LD_INT 332
7819: PPUSH
7820: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7824: LD_EXP 57
7828: PPUSH
7829: LD_INT 3
7831: PPUSH
7832: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7836: LD_INT 332
7838: PPUSH
7839: LD_INT 23
7841: PPUSH
7842: LD_INT 3
7844: PPUSH
7845: LD_INT 1
7847: PPUSH
7848: LD_INT 48
7850: PPUSH
7851: CALL_OW 125
// end ;
7855: LD_VAR 0 1
7859: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7860: LD_EXP 3
7864: NOT
7865: PUSH
7866: LD_INT 3
7868: PPUSH
7869: LD_INT 1
7871: PPUSH
7872: CALL 46938 0 2
7876: NOT
7877: AND
7878: IFFALSE 8734
7880: GO 7882
7882: DISABLE
7883: LD_INT 0
7885: PPUSH
7886: PPUSH
7887: PPUSH
// begin enable ;
7888: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7889: LD_INT 22
7891: PUSH
7892: LD_INT 8
7894: PUSH
7895: EMPTY
7896: LIST
7897: LIST
7898: PUSH
7899: LD_INT 23
7901: PUSH
7902: LD_INT 2
7904: PUSH
7905: EMPTY
7906: LIST
7907: LIST
7908: PUSH
7909: LD_INT 30
7911: PUSH
7912: LD_INT 3
7914: PUSH
7915: EMPTY
7916: LIST
7917: LIST
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: LIST
7923: PPUSH
7924: CALL_OW 69
7928: NOT
7929: IFFALSE 7933
// exit ;
7931: GO 8734
// if Prob ( 40 ) then
7933: LD_INT 40
7935: PPUSH
7936: CALL_OW 13
7940: IFFALSE 8067
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7942: LD_INT 3
7944: PPUSH
7945: LD_INT 14
7947: PUSH
7948: LD_INT 1
7950: PUSH
7951: LD_INT 2
7953: PUSH
7954: LD_INT 28
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: LIST
7961: LIST
7962: PUSH
7963: LD_INT 14
7965: PUSH
7966: LD_INT 1
7968: PUSH
7969: LD_INT 2
7971: PUSH
7972: LD_INT 28
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: LD_INT 14
7983: PUSH
7984: LD_INT 1
7986: PUSH
7987: LD_INT 2
7989: PUSH
7990: LD_INT 28
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: PUSH
7999: LD_INT 14
8001: PUSH
8002: LD_INT 1
8004: PUSH
8005: LD_INT 2
8007: PUSH
8008: LD_INT 28
8010: PUSH
8011: EMPTY
8012: LIST
8013: LIST
8014: LIST
8015: LIST
8016: PUSH
8017: LD_INT 14
8019: PUSH
8020: LD_INT 1
8022: PUSH
8023: LD_INT 2
8025: PUSH
8026: LD_INT 28
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: LIST
8033: LIST
8034: PUSH
8035: LD_INT 14
8037: PUSH
8038: LD_INT 1
8040: PUSH
8041: LD_INT 2
8043: PUSH
8044: LD_INT 26
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: LIST
8052: PUSH
8053: EMPTY
8054: LIST
8055: LIST
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PPUSH
8061: CALL 45520 0 2
// end else
8065: GO 8274
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8067: LD_INT 3
8069: PPUSH
8070: LD_INT 14
8072: PUSH
8073: LD_INT 1
8075: PUSH
8076: LD_INT 2
8078: PUSH
8079: LD_INT 27
8081: PUSH
8082: LD_INT 26
8084: PUSH
8085: LD_INT 26
8087: PUSH
8088: LD_INT 28
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: LIST
8095: LIST
8096: PUSH
8097: LD_OWVAR 67
8101: ARRAY
8102: PUSH
8103: EMPTY
8104: LIST
8105: LIST
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 14
8111: PUSH
8112: LD_INT 1
8114: PUSH
8115: LD_INT 2
8117: PUSH
8118: LD_INT 27
8120: PUSH
8121: LD_INT 26
8123: PUSH
8124: LD_INT 26
8126: PUSH
8127: LD_INT 26
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: LIST
8134: LIST
8135: PUSH
8136: LD_OWVAR 67
8140: ARRAY
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 14
8150: PUSH
8151: LD_INT 1
8153: PUSH
8154: LD_INT 2
8156: PUSH
8157: LD_INT 26
8159: PUSH
8160: LD_INT 26
8162: PUSH
8163: LD_INT 29
8165: PUSH
8166: LD_INT 29
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: LIST
8173: LIST
8174: PUSH
8175: LD_OWVAR 67
8179: ARRAY
8180: PUSH
8181: EMPTY
8182: LIST
8183: LIST
8184: LIST
8185: LIST
8186: PUSH
8187: LD_INT 13
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: LD_INT 2
8195: PUSH
8196: LD_INT 26
8198: PUSH
8199: LD_INT 29
8201: PUSH
8202: LD_INT 29
8204: PUSH
8205: LD_INT 29
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_OWVAR 67
8218: ARRAY
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: LIST
8224: LIST
8225: PUSH
8226: LD_INT 13
8228: PUSH
8229: LD_INT 1
8231: PUSH
8232: LD_INT 2
8234: PUSH
8235: LD_INT 29
8237: PUSH
8238: EMPTY
8239: LIST
8240: LIST
8241: LIST
8242: LIST
8243: PUSH
8244: LD_INT 14
8246: PUSH
8247: LD_INT 1
8249: PUSH
8250: LD_INT 2
8252: PUSH
8253: LD_INT 26
8255: PUSH
8256: EMPTY
8257: LIST
8258: LIST
8259: LIST
8260: LIST
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PPUSH
8270: CALL 45520 0 2
// end ; repeat wait ( 0 0$1 ) ;
8274: LD_INT 35
8276: PPUSH
8277: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8281: LD_INT 3
8283: PPUSH
8284: LD_INT 1
8286: PPUSH
8287: CALL 46938 0 2
8291: PUSH
8292: LD_INT 6
8294: GREATEREQUAL
8295: IFFALSE 8274
// wait ( 0 0$30 ) ;
8297: LD_INT 1050
8299: PPUSH
8300: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8304: LD_ADDR_VAR 0 2
8308: PUSH
8309: LD_INT 3
8311: PPUSH
8312: LD_INT 1
8314: PPUSH
8315: CALL 46938 0 2
8319: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8320: LD_ADDR_EXP 95
8324: PUSH
8325: LD_EXP 95
8329: PPUSH
8330: LD_INT 3
8332: PPUSH
8333: LD_EXP 95
8337: PUSH
8338: LD_INT 3
8340: ARRAY
8341: PUSH
8342: LD_VAR 0 2
8346: DIFF
8347: PPUSH
8348: CALL_OW 1
8352: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8353: LD_ADDR_VAR 0 3
8357: PUSH
8358: LD_INT 0
8360: PPUSH
8361: LD_INT 2
8363: PPUSH
8364: CALL_OW 12
8368: ST_TO_ADDR
// if target then
8369: LD_VAR 0 3
8373: IFFALSE 8501
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8375: LD_ADDR_VAR 0 2
8379: PUSH
8380: LD_VAR 0 2
8384: PPUSH
8385: LD_INT 24
8387: PUSH
8388: LD_INT 250
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PPUSH
8395: CALL_OW 72
8399: ST_TO_ADDR
// for i in tmp do
8400: LD_ADDR_VAR 0 1
8404: PUSH
8405: LD_VAR 0 2
8409: PUSH
8410: FOR_IN
8411: IFFALSE 8451
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8413: LD_VAR 0 1
8417: PPUSH
8418: LD_INT 89
8420: PPUSH
8421: LD_INT 71
8423: PPUSH
8424: CALL_OW 297
8428: PUSH
8429: LD_INT 9
8431: GREATER
8432: IFFALSE 8449
// ComMoveXY ( i , 89 , 71 ) ;
8434: LD_VAR 0 1
8438: PPUSH
8439: LD_INT 89
8441: PPUSH
8442: LD_INT 71
8444: PPUSH
8445: CALL_OW 111
8449: GO 8410
8451: POP
8452: POP
// wait ( 0 0$1 ) ;
8453: LD_INT 35
8455: PPUSH
8456: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8460: LD_VAR 0 2
8464: PPUSH
8465: LD_INT 92
8467: PUSH
8468: LD_INT 89
8470: PUSH
8471: LD_INT 71
8473: PUSH
8474: LD_INT 9
8476: PUSH
8477: EMPTY
8478: LIST
8479: LIST
8480: LIST
8481: LIST
8482: PPUSH
8483: CALL_OW 72
8487: PUSH
8488: LD_VAR 0 2
8492: PUSH
8493: LD_INT 1
8495: MINUS
8496: GREATEREQUAL
8497: IFFALSE 8375
// end else
8499: GO 8625
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8501: LD_ADDR_VAR 0 2
8505: PUSH
8506: LD_VAR 0 2
8510: PPUSH
8511: LD_INT 24
8513: PUSH
8514: LD_INT 250
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PPUSH
8521: CALL_OW 72
8525: ST_TO_ADDR
// for i in tmp do
8526: LD_ADDR_VAR 0 1
8530: PUSH
8531: LD_VAR 0 2
8535: PUSH
8536: FOR_IN
8537: IFFALSE 8577
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8539: LD_VAR 0 1
8543: PPUSH
8544: LD_INT 147
8546: PPUSH
8547: LD_INT 4
8549: PPUSH
8550: CALL_OW 297
8554: PUSH
8555: LD_INT 9
8557: GREATER
8558: IFFALSE 8575
// ComMoveXY ( i , 147 , 4 ) ;
8560: LD_VAR 0 1
8564: PPUSH
8565: LD_INT 147
8567: PPUSH
8568: LD_INT 4
8570: PPUSH
8571: CALL_OW 111
8575: GO 8536
8577: POP
8578: POP
// wait ( 0 0$1 ) ;
8579: LD_INT 35
8581: PPUSH
8582: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8586: LD_VAR 0 2
8590: PPUSH
8591: LD_INT 92
8593: PUSH
8594: LD_INT 147
8596: PUSH
8597: LD_INT 4
8599: PUSH
8600: LD_INT 9
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: LIST
8607: LIST
8608: PPUSH
8609: CALL_OW 72
8613: PUSH
8614: LD_VAR 0 2
8618: PUSH
8619: LD_INT 1
8621: MINUS
8622: GREATEREQUAL
8623: IFFALSE 8501
// end ; repeat wait ( 0 0$1 ) ;
8625: LD_INT 35
8627: PPUSH
8628: CALL_OW 67
// for i in tmp do
8632: LD_ADDR_VAR 0 1
8636: PUSH
8637: LD_VAR 0 2
8641: PUSH
8642: FOR_IN
8643: IFFALSE 8725
// begin if GetLives ( i ) > 251 then
8645: LD_VAR 0 1
8649: PPUSH
8650: CALL_OW 256
8654: PUSH
8655: LD_INT 251
8657: GREATER
8658: IFFALSE 8696
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8660: LD_VAR 0 1
8664: PPUSH
8665: LD_INT 81
8667: PUSH
8668: LD_INT 8
8670: PUSH
8671: EMPTY
8672: LIST
8673: LIST
8674: PPUSH
8675: CALL_OW 69
8679: PPUSH
8680: LD_VAR 0 1
8684: PPUSH
8685: CALL_OW 74
8689: PPUSH
8690: CALL_OW 115
8694: GO 8723
// if IsDead ( i ) then
8696: LD_VAR 0 1
8700: PPUSH
8701: CALL_OW 301
8705: IFFALSE 8723
// tmp := tmp diff i ;
8707: LD_ADDR_VAR 0 2
8711: PUSH
8712: LD_VAR 0 2
8716: PUSH
8717: LD_VAR 0 1
8721: DIFF
8722: ST_TO_ADDR
// end ;
8723: GO 8642
8725: POP
8726: POP
// until not tmp ;
8727: LD_VAR 0 2
8731: NOT
8732: IFFALSE 8625
// end ;
8734: PPOPN 3
8736: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8737: LD_EXP 57
8741: PPUSH
8742: CALL_OW 302
8746: PUSH
8747: LD_EXP 3
8751: NOT
8752: AND
8753: IFFALSE 8762
8755: GO 8757
8757: DISABLE
// BuildKozlovBomb ;
8758: CALL 7733 0 0
8762: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8763: LD_INT 22
8765: PUSH
8766: LD_INT 8
8768: PUSH
8769: EMPTY
8770: LIST
8771: LIST
8772: PUSH
8773: LD_INT 34
8775: PUSH
8776: LD_INT 48
8778: PUSH
8779: EMPTY
8780: LIST
8781: LIST
8782: PUSH
8783: EMPTY
8784: LIST
8785: LIST
8786: PPUSH
8787: CALL_OW 69
8791: IFFALSE 8839
8793: GO 8795
8795: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8796: LD_INT 22
8798: PUSH
8799: LD_INT 8
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: PUSH
8806: LD_INT 34
8808: PUSH
8809: LD_INT 48
8811: PUSH
8812: EMPTY
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PPUSH
8820: CALL_OW 69
8824: PUSH
8825: LD_INT 1
8827: ARRAY
8828: PPUSH
8829: LD_INT 173
8831: PPUSH
8832: LD_INT 96
8834: PPUSH
8835: CALL_OW 116
// end ; end_of_file
8839: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8840: LD_INT 0
8842: PPUSH
8843: PPUSH
8844: PPUSH
8845: PPUSH
8846: PPUSH
8847: PPUSH
8848: PPUSH
8849: PPUSH
8850: PPUSH
// side := 3 ;
8851: LD_ADDR_VAR 0 6
8855: PUSH
8856: LD_INT 3
8858: ST_TO_ADDR
// InitHc ;
8859: CALL_OW 19
// uc_side := side ;
8863: LD_ADDR_OWVAR 20
8867: PUSH
8868: LD_VAR 0 6
8872: ST_TO_ADDR
// uc_nation := 3 ;
8873: LD_ADDR_OWVAR 21
8877: PUSH
8878: LD_INT 3
8880: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8881: LD_ADDR_VAR 0 2
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_VAR 0 6
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: PUSH
8898: LD_INT 21
8900: PUSH
8901: LD_INT 3
8903: PUSH
8904: EMPTY
8905: LIST
8906: LIST
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: PPUSH
8912: CALL_OW 69
8916: PUSH
8917: FOR_IN
8918: IFFALSE 8934
// SetBLevel ( i , 10 ) ;
8920: LD_VAR 0 2
8924: PPUSH
8925: LD_INT 10
8927: PPUSH
8928: CALL_OW 241
8932: GO 8917
8934: POP
8935: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8936: LD_ADDR_VAR 0 9
8940: PUSH
8941: LD_INT 22
8943: PUSH
8944: LD_VAR 0 6
8948: PUSH
8949: EMPTY
8950: LIST
8951: LIST
8952: PUSH
8953: LD_INT 30
8955: PUSH
8956: LD_INT 34
8958: PUSH
8959: EMPTY
8960: LIST
8961: LIST
8962: PUSH
8963: EMPTY
8964: LIST
8965: LIST
8966: PPUSH
8967: CALL_OW 69
8971: ST_TO_ADDR
// if teleport then
8972: LD_VAR 0 9
8976: IFFALSE 8997
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8978: LD_VAR 0 9
8982: PUSH
8983: LD_INT 1
8985: ARRAY
8986: PPUSH
8987: LD_INT 123
8989: PPUSH
8990: LD_INT 122
8992: PPUSH
8993: CALL_OW 243
// hc_importance := 0 ;
8997: LD_ADDR_OWVAR 32
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9005: LD_ADDR_EXP 58
9009: PUSH
9010: LD_STRING Platonov
9012: PPUSH
9013: CALL_OW 25
9017: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9018: LD_ADDR_EXP 59
9022: PUSH
9023: LD_STRING Yakotich
9025: PPUSH
9026: LD_EXP 1
9030: NOT
9031: PPUSH
9032: LD_STRING 09_
9034: PPUSH
9035: CALL 51908 0 3
9039: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9040: LD_ADDR_EXP 60
9044: PUSH
9045: LD_STRING Gleb
9047: PPUSH
9048: CALL_OW 25
9052: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9053: LD_STRING 03_Cornel
9055: PPUSH
9056: CALL_OW 28
9060: IFFALSE 9108
// begin Bierezov := NewCharacter ( Mikhail ) ;
9062: LD_ADDR_EXP 61
9066: PUSH
9067: LD_STRING Mikhail
9069: PPUSH
9070: CALL_OW 25
9074: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9075: LD_EXP 61
9079: PPUSH
9080: LD_INT 197
9082: PPUSH
9083: LD_INT 111
9085: PPUSH
9086: LD_INT 9
9088: PPUSH
9089: LD_INT 0
9091: PPUSH
9092: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9096: LD_EXP 61
9100: PPUSH
9101: LD_INT 3
9103: PPUSH
9104: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9108: LD_EXP 58
9112: PPUSH
9113: LD_INT 126
9115: PPUSH
9116: CALL_OW 52
// if Yakotich then
9120: LD_EXP 59
9124: IFFALSE 9147
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9126: LD_EXP 59
9130: PPUSH
9131: LD_INT 197
9133: PPUSH
9134: LD_INT 111
9136: PPUSH
9137: LD_INT 9
9139: PPUSH
9140: LD_INT 0
9142: PPUSH
9143: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9147: LD_EXP 60
9151: PPUSH
9152: LD_INT 197
9154: PPUSH
9155: LD_INT 111
9157: PPUSH
9158: LD_INT 9
9160: PPUSH
9161: LD_INT 0
9163: PPUSH
9164: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9168: LD_ADDR_VAR 0 5
9172: PUSH
9173: LD_INT 126
9175: PPUSH
9176: LD_INT 2
9178: PPUSH
9179: LD_STRING zhukov
9181: PPUSH
9182: LD_INT 9
9184: PUSH
9185: LD_INT 10
9187: PUSH
9188: LD_INT 10
9190: PUSH
9191: LD_INT 10
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: LIST
9198: LIST
9199: PUSH
9200: LD_OWVAR 67
9204: ARRAY
9205: PPUSH
9206: LD_INT 9000
9208: PUSH
9209: LD_INT 1000
9211: PUSH
9212: LD_INT 300
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: LIST
9219: PPUSH
9220: LD_INT 21
9222: PUSH
9223: LD_INT 8
9225: PUSH
9226: LD_INT 13
9228: PUSH
9229: LD_INT 8
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: LIST
9236: LIST
9237: PPUSH
9238: CALL 60367 0 6
9242: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9243: LD_ADDR_VAR 0 4
9247: PUSH
9248: LD_INT 267
9250: PPUSH
9251: CALL_OW 274
9255: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9256: LD_VAR 0 4
9260: PPUSH
9261: LD_INT 1
9263: PPUSH
9264: LD_INT 5000
9266: PPUSH
9267: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9271: LD_VAR 0 4
9275: PPUSH
9276: LD_INT 2
9278: PPUSH
9279: LD_INT 200
9281: PPUSH
9282: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9286: LD_VAR 0 4
9290: PPUSH
9291: LD_INT 3
9293: PPUSH
9294: LD_INT 200
9296: PPUSH
9297: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9301: LD_ADDR_EXP 76
9305: PUSH
9306: LD_EXP 76
9310: PPUSH
9311: LD_INT 2
9313: PPUSH
9314: LD_VAR 0 5
9318: PUSH
9319: LD_INT 22
9321: PUSH
9322: LD_VAR 0 6
9326: PUSH
9327: EMPTY
9328: LIST
9329: LIST
9330: PUSH
9331: LD_INT 3
9333: PUSH
9334: LD_INT 21
9336: PUSH
9337: LD_INT 2
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL_OW 69
9356: UNION
9357: PUSH
9358: LD_EXP 58
9362: DIFF
9363: PPUSH
9364: CALL_OW 1
9368: ST_TO_ADDR
// behemoths := [ ] ;
9369: LD_ADDR_EXP 62
9373: PUSH
9374: EMPTY
9375: ST_TO_ADDR
// behemothBuilders := [ ] ;
9376: LD_ADDR_EXP 63
9380: PUSH
9381: EMPTY
9382: ST_TO_ADDR
// j := 3 ;
9383: LD_ADDR_VAR 0 3
9387: PUSH
9388: LD_INT 3
9390: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9391: LD_ADDR_VAR 0 2
9395: PUSH
9396: LD_INT 22
9398: PUSH
9399: LD_INT 3
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: PUSH
9406: LD_INT 25
9408: PUSH
9409: LD_INT 3
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: PPUSH
9420: CALL_OW 69
9424: PUSH
9425: FOR_IN
9426: IFFALSE 9476
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9428: LD_ADDR_EXP 63
9432: PUSH
9433: LD_EXP 63
9437: PPUSH
9438: LD_VAR 0 2
9442: PPUSH
9443: CALL 89357 0 2
9447: ST_TO_ADDR
// j := j - 1 ;
9448: LD_ADDR_VAR 0 3
9452: PUSH
9453: LD_VAR 0 3
9457: PUSH
9458: LD_INT 1
9460: MINUS
9461: ST_TO_ADDR
// if j = 0 then
9462: LD_VAR 0 3
9466: PUSH
9467: LD_INT 0
9469: EQUAL
9470: IFFALSE 9474
// break ;
9472: GO 9476
// end ;
9474: GO 9425
9476: POP
9477: POP
// end ;
9478: LD_VAR 0 1
9482: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9483: LD_INT 0
9485: PPUSH
9486: PPUSH
9487: PPUSH
9488: PPUSH
9489: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9490: LD_ADDR_VAR 0 4
9494: PUSH
9495: LD_INT 209
9497: PUSH
9498: LD_INT 149
9500: PUSH
9501: EMPTY
9502: LIST
9503: LIST
9504: PUSH
9505: LD_INT 219
9507: PUSH
9508: LD_INT 154
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PUSH
9515: LD_INT 223
9517: PUSH
9518: LD_INT 149
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PUSH
9525: LD_INT 232
9527: PUSH
9528: LD_INT 155
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: LIST
9540: ST_TO_ADDR
// if not behemothBuilders then
9541: LD_EXP 63
9545: NOT
9546: IFFALSE 9550
// exit ;
9548: GO 9654
// j := 1 ;
9550: LD_ADDR_VAR 0 3
9554: PUSH
9555: LD_INT 1
9557: ST_TO_ADDR
// for i in behemothBuilders do
9558: LD_ADDR_VAR 0 2
9562: PUSH
9563: LD_EXP 63
9567: PUSH
9568: FOR_IN
9569: IFFALSE 9652
// begin if IsInUnit ( i ) then
9571: LD_VAR 0 2
9575: PPUSH
9576: CALL_OW 310
9580: IFFALSE 9591
// ComExitBuilding ( i ) ;
9582: LD_VAR 0 2
9586: PPUSH
9587: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9591: LD_VAR 0 2
9595: PPUSH
9596: LD_INT 37
9598: PPUSH
9599: LD_VAR 0 4
9603: PUSH
9604: LD_VAR 0 3
9608: ARRAY
9609: PUSH
9610: LD_INT 1
9612: ARRAY
9613: PPUSH
9614: LD_VAR 0 4
9618: PUSH
9619: LD_VAR 0 3
9623: ARRAY
9624: PUSH
9625: LD_INT 2
9627: ARRAY
9628: PPUSH
9629: LD_INT 0
9631: PPUSH
9632: CALL_OW 230
// j := j + 1 ;
9636: LD_ADDR_VAR 0 3
9640: PUSH
9641: LD_VAR 0 3
9645: PUSH
9646: LD_INT 1
9648: PLUS
9649: ST_TO_ADDR
// end ;
9650: GO 9568
9652: POP
9653: POP
// end ;
9654: LD_VAR 0 1
9658: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9659: LD_INT 3
9661: PPUSH
9662: CALL 89418 0 1
9666: PUSH
9667: LD_INT 22
9669: PUSH
9670: LD_INT 3
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PUSH
9677: LD_INT 30
9679: PUSH
9680: LD_INT 37
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: CALL_OW 69
9695: NOT
9696: AND
9697: IFFALSE 9883
9699: GO 9701
9701: DISABLE
9702: LD_INT 0
9704: PPUSH
9705: PPUSH
// begin enable ;
9706: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9707: LD_ADDR_VAR 0 2
9711: PUSH
9712: LD_INT 3
9714: PPUSH
9715: CALL 89418 0 1
9719: ST_TO_ADDR
// for i in tmp do
9720: LD_ADDR_VAR 0 1
9724: PUSH
9725: LD_VAR 0 2
9729: PUSH
9730: FOR_IN
9731: IFFALSE 9881
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9733: LD_VAR 0 1
9737: PPUSH
9738: LD_INT 7
9740: PPUSH
9741: CALL_OW 308
9745: PUSH
9746: LD_VAR 0 1
9750: PPUSH
9751: CALL_OW 110
9755: PUSH
9756: LD_INT 2
9758: EQUAL
9759: NOT
9760: AND
9761: IFFALSE 9775
// SetTag ( i , 2 ) ;
9763: LD_VAR 0 1
9767: PPUSH
9768: LD_INT 2
9770: PPUSH
9771: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9775: LD_INT 81
9777: PUSH
9778: LD_INT 3
9780: PUSH
9781: EMPTY
9782: LIST
9783: LIST
9784: PUSH
9785: LD_INT 91
9787: PUSH
9788: LD_VAR 0 1
9792: PUSH
9793: LD_INT 12
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: LIST
9800: PUSH
9801: EMPTY
9802: LIST
9803: LIST
9804: PPUSH
9805: CALL_OW 69
9809: NOT
9810: PUSH
9811: LD_VAR 0 1
9815: PPUSH
9816: CALL_OW 110
9820: PUSH
9821: LD_INT 2
9823: EQUAL
9824: NOT
9825: AND
9826: IFFALSE 9845
// ComAgressiveMove ( i , 64 , 93 ) else
9828: LD_VAR 0 1
9832: PPUSH
9833: LD_INT 64
9835: PPUSH
9836: LD_INT 93
9838: PPUSH
9839: CALL_OW 114
9843: GO 9879
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9845: LD_VAR 0 1
9849: PPUSH
9850: LD_INT 81
9852: PUSH
9853: LD_INT 3
9855: PUSH
9856: EMPTY
9857: LIST
9858: LIST
9859: PPUSH
9860: CALL_OW 69
9864: PPUSH
9865: LD_VAR 0 1
9869: PPUSH
9870: CALL_OW 74
9874: PPUSH
9875: CALL_OW 115
// end ;
9879: GO 9730
9881: POP
9882: POP
// end ;
9883: PPOPN 2
9885: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9886: LD_EXP 2
9890: NOT
9891: PUSH
9892: LD_INT 2
9894: PPUSH
9895: LD_INT 1
9897: PPUSH
9898: CALL 46938 0 2
9902: NOT
9903: AND
9904: IFFALSE 10828
9906: GO 9908
9908: DISABLE
9909: LD_INT 0
9911: PPUSH
9912: PPUSH
9913: PPUSH
9914: PPUSH
// begin enable ;
9915: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9916: LD_INT 22
9918: PUSH
9919: LD_INT 3
9921: PUSH
9922: EMPTY
9923: LIST
9924: LIST
9925: PUSH
9926: LD_INT 30
9928: PUSH
9929: LD_INT 3
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: PPUSH
9940: CALL_OW 69
9944: NOT
9945: IFFALSE 9949
// exit ;
9947: GO 10828
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9949: LD_ADDR_VAR 0 4
9953: PUSH
9954: LD_INT 22
9956: PUSH
9957: LD_INT 3
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PUSH
9964: LD_INT 30
9966: PUSH
9967: LD_INT 34
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: PPUSH
9978: CALL_OW 69
9982: ST_TO_ADDR
// if Prob ( 40 ) then
9983: LD_INT 40
9985: PPUSH
9986: CALL_OW 13
9990: IFFALSE 10117
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9992: LD_INT 2
9994: PPUSH
9995: LD_INT 22
9997: PUSH
9998: LD_INT 3
10000: PUSH
10001: LD_INT 3
10003: PUSH
10004: LD_INT 49
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: LIST
10011: LIST
10012: PUSH
10013: LD_INT 22
10015: PUSH
10016: LD_INT 3
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: LD_INT 49
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: LD_INT 3
10039: PUSH
10040: LD_INT 49
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: LIST
10048: PUSH
10049: LD_INT 24
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 46
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 46
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 46
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: PPUSH
10111: CALL 45520 0 2
// end else
10115: GO 10240
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10117: LD_INT 2
10119: PPUSH
10120: LD_INT 24
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: LD_INT 3
10128: PUSH
10129: LD_INT 47
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 47
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 47
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 24
10176: PUSH
10177: LD_INT 3
10179: PUSH
10180: LD_INT 3
10182: PUSH
10183: LD_INT 46
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: PUSH
10192: LD_INT 24
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: LD_INT 46
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_INT 24
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 3
10218: PUSH
10219: LD_INT 46
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: LIST
10232: LIST
10233: LIST
10234: LIST
10235: PPUSH
10236: CALL 45520 0 2
// end ; if Difficulty > 1 then
10240: LD_OWVAR 67
10244: PUSH
10245: LD_INT 1
10247: GREATER
10248: IFFALSE 10278
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10250: LD_INT 2
10252: PPUSH
10253: LD_INT 24
10255: PUSH
10256: LD_INT 3
10258: PUSH
10259: LD_INT 3
10261: PUSH
10262: LD_INT 47
10264: PUSH
10265: EMPTY
10266: LIST
10267: LIST
10268: LIST
10269: LIST
10270: PUSH
10271: EMPTY
10272: LIST
10273: PPUSH
10274: CALL 45520 0 2
// repeat wait ( 0 0$1 ) ;
10278: LD_INT 35
10280: PPUSH
10281: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10285: LD_INT 2
10287: PPUSH
10288: LD_INT 1
10290: PPUSH
10291: CALL 46938 0 2
10295: PUSH
10296: LD_INT 6
10298: PUSH
10299: LD_INT 7
10301: PUSH
10302: LD_INT 7
10304: PUSH
10305: LD_INT 7
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: PUSH
10314: LD_OWVAR 67
10318: ARRAY
10319: GREATEREQUAL
10320: IFFALSE 10278
// wait ( 0 0$30 ) ;
10322: LD_INT 1050
10324: PPUSH
10325: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10329: LD_ADDR_VAR 0 2
10333: PUSH
10334: LD_INT 2
10336: PPUSH
10337: LD_INT 1
10339: PPUSH
10340: CALL 46938 0 2
10344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10345: LD_ADDR_EXP 95
10349: PUSH
10350: LD_EXP 95
10354: PPUSH
10355: LD_INT 2
10357: PPUSH
10358: LD_EXP 95
10362: PUSH
10363: LD_INT 2
10365: ARRAY
10366: PUSH
10367: LD_VAR 0 2
10371: DIFF
10372: PPUSH
10373: CALL_OW 1
10377: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10378: LD_ADDR_VAR 0 3
10382: PUSH
10383: LD_INT 0
10385: PPUSH
10386: LD_INT 1
10388: PPUSH
10389: CALL_OW 12
10393: ST_TO_ADDR
// if target then
10394: LD_VAR 0 3
10398: IFFALSE 10526
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10400: LD_ADDR_VAR 0 2
10404: PUSH
10405: LD_VAR 0 2
10409: PPUSH
10410: LD_INT 24
10412: PUSH
10413: LD_INT 250
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: PPUSH
10420: CALL_OW 72
10424: ST_TO_ADDR
// for i in tmp do
10425: LD_ADDR_VAR 0 1
10429: PUSH
10430: LD_VAR 0 2
10434: PUSH
10435: FOR_IN
10436: IFFALSE 10476
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10438: LD_VAR 0 1
10442: PPUSH
10443: LD_INT 139
10445: PPUSH
10446: LD_INT 89
10448: PPUSH
10449: CALL_OW 297
10453: PUSH
10454: LD_INT 9
10456: GREATER
10457: IFFALSE 10474
// ComMoveXY ( i , 139 , 89 ) ;
10459: LD_VAR 0 1
10463: PPUSH
10464: LD_INT 139
10466: PPUSH
10467: LD_INT 89
10469: PPUSH
10470: CALL_OW 111
10474: GO 10435
10476: POP
10477: POP
// wait ( 0 0$1 ) ;
10478: LD_INT 35
10480: PPUSH
10481: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10485: LD_VAR 0 2
10489: PPUSH
10490: LD_INT 92
10492: PUSH
10493: LD_INT 139
10495: PUSH
10496: LD_INT 89
10498: PUSH
10499: LD_INT 9
10501: PUSH
10502: EMPTY
10503: LIST
10504: LIST
10505: LIST
10506: LIST
10507: PPUSH
10508: CALL_OW 72
10512: PUSH
10513: LD_VAR 0 2
10517: PUSH
10518: LD_INT 1
10520: MINUS
10521: GREATEREQUAL
10522: IFFALSE 10400
// end else
10524: GO 10668
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10526: LD_VAR 0 2
10530: PPUSH
10531: LD_VAR 0 4
10535: PUSH
10536: LD_INT 1
10538: ARRAY
10539: PPUSH
10540: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10544: LD_ADDR_VAR 0 2
10548: PUSH
10549: LD_VAR 0 2
10553: PPUSH
10554: LD_INT 24
10556: PUSH
10557: LD_INT 250
10559: PUSH
10560: EMPTY
10561: LIST
10562: LIST
10563: PPUSH
10564: CALL_OW 72
10568: ST_TO_ADDR
// for i in tmp do
10569: LD_ADDR_VAR 0 1
10573: PUSH
10574: LD_VAR 0 2
10578: PUSH
10579: FOR_IN
10580: IFFALSE 10620
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10582: LD_VAR 0 1
10586: PPUSH
10587: LD_INT 124
10589: PPUSH
10590: LD_INT 139
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 9
10600: GREATER
10601: IFFALSE 10618
// ComMoveXY ( i , 124 , 139 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 124
10610: PPUSH
10611: LD_INT 139
10613: PPUSH
10614: CALL_OW 111
10618: GO 10579
10620: POP
10621: POP
// wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10629: LD_VAR 0 2
10633: PPUSH
10634: LD_INT 92
10636: PUSH
10637: LD_INT 124
10639: PUSH
10640: LD_INT 139
10642: PUSH
10643: LD_INT 9
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: LIST
10650: LIST
10651: PPUSH
10652: CALL_OW 72
10656: PUSH
10657: LD_VAR 0 2
10661: PUSH
10662: LD_INT 1
10664: MINUS
10665: GREATEREQUAL
10666: IFFALSE 10544
// end ; repeat wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// for i in tmp do
10675: LD_ADDR_VAR 0 1
10679: PUSH
10680: LD_VAR 0 2
10684: PUSH
10685: FOR_IN
10686: IFFALSE 10819
// begin if GetLives ( i ) > 251 then
10688: LD_VAR 0 1
10692: PPUSH
10693: CALL_OW 256
10697: PUSH
10698: LD_INT 251
10700: GREATER
10701: IFFALSE 10790
// begin if GetWeapon ( i ) = ru_time_lapser then
10703: LD_VAR 0 1
10707: PPUSH
10708: CALL_OW 264
10712: PUSH
10713: LD_INT 49
10715: EQUAL
10716: IFFALSE 10754
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10718: LD_VAR 0 1
10722: PPUSH
10723: LD_INT 81
10725: PUSH
10726: LD_INT 3
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PPUSH
10733: CALL_OW 69
10737: PPUSH
10738: LD_VAR 0 1
10742: PPUSH
10743: CALL_OW 74
10747: PPUSH
10748: CALL_OW 112
10752: GO 10788
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10754: LD_VAR 0 1
10758: PPUSH
10759: LD_INT 81
10761: PUSH
10762: LD_INT 3
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: PPUSH
10769: CALL_OW 69
10773: PPUSH
10774: LD_VAR 0 1
10778: PPUSH
10779: CALL_OW 74
10783: PPUSH
10784: CALL_OW 115
// end else
10788: GO 10817
// if IsDead ( i ) then
10790: LD_VAR 0 1
10794: PPUSH
10795: CALL_OW 301
10799: IFFALSE 10817
// tmp := tmp diff i ;
10801: LD_ADDR_VAR 0 2
10805: PUSH
10806: LD_VAR 0 2
10810: PUSH
10811: LD_VAR 0 1
10815: DIFF
10816: ST_TO_ADDR
// end ;
10817: GO 10685
10819: POP
10820: POP
// until not tmp ;
10821: LD_VAR 0 2
10825: NOT
10826: IFFALSE 10668
// end ;
10828: PPOPN 4
10830: END
// every 30 30$00 trigger not russianDestroyed do
10831: LD_EXP 2
10835: NOT
10836: IFFALSE 10905
10838: GO 10840
10840: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10841: LD_INT 105000
10843: PUSH
10844: LD_INT 84000
10846: PUSH
10847: LD_INT 63000
10849: PUSH
10850: LD_INT 52500
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: LIST
10857: LIST
10858: PUSH
10859: LD_OWVAR 67
10863: ARRAY
10864: PPUSH
10865: CALL_OW 67
// if russianDestroyed then
10869: LD_EXP 2
10873: IFFALSE 10877
// exit ;
10875: GO 10905
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10877: LD_INT 2
10879: PPUSH
10880: LD_INT 23
10882: PUSH
10883: LD_INT 3
10885: PUSH
10886: LD_INT 1
10888: PUSH
10889: LD_INT 48
10891: PUSH
10892: EMPTY
10893: LIST
10894: LIST
10895: LIST
10896: LIST
10897: PUSH
10898: EMPTY
10899: LIST
10900: PPUSH
10901: CALL 45520 0 2
// end ; end_of_file
10905: END
// export function CustomEvent ( event ) ; begin
10906: LD_INT 0
10908: PPUSH
// end ;
10909: LD_VAR 0 2
10913: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10914: LD_VAR 0 2
10918: PPUSH
10919: LD_VAR 0 3
10923: PPUSH
10924: LD_INT 15
10926: PPUSH
10927: CALL_OW 309
10931: IFFALSE 10940
// YouLost ( MothContaminate ) ;
10933: LD_STRING MothContaminate
10935: PPUSH
10936: CALL_OW 104
// end ;
10940: PPOPN 3
10942: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10943: LD_VAR 0 2
10947: PPUSH
10948: LD_VAR 0 3
10952: PPUSH
10953: LD_INT 15
10955: PPUSH
10956: CALL_OW 309
10960: IFFALSE 10976
// begin wait ( 0 0$6 ) ;
10962: LD_INT 210
10964: PPUSH
10965: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10969: LD_STRING MothContaminateBomb
10971: PPUSH
10972: CALL_OW 104
// end ; end ;
10976: PPOPN 3
10978: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10979: LD_VAR 0 1
10983: PPUSH
10984: CALL 108815 0 1
// if un = JMM then
10988: LD_VAR 0 1
10992: PUSH
10993: LD_EXP 19
10997: EQUAL
10998: IFFALSE 11009
// begin YouLost ( JMM ) ;
11000: LD_STRING JMM
11002: PPUSH
11003: CALL_OW 104
// exit ;
11007: GO 11138
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11009: LD_VAR 0 1
11013: PPUSH
11014: CALL_OW 255
11018: PUSH
11019: LD_INT 2
11021: EQUAL
11022: PUSH
11023: LD_EXP 18
11027: NOT
11028: AND
11029: IFFALSE 11039
// arabianAttacked := true ;
11031: LD_ADDR_EXP 18
11035: PUSH
11036: LD_INT 1
11038: ST_TO_ADDR
// if un = Powell then
11039: LD_VAR 0 1
11043: PUSH
11044: LD_EXP 54
11048: EQUAL
11049: IFFALSE 11059
// americanDestroyed := true ;
11051: LD_ADDR_EXP 4
11055: PUSH
11056: LD_INT 1
11058: ST_TO_ADDR
// if un = Platonov then
11059: LD_VAR 0 1
11063: PUSH
11064: LD_EXP 58
11068: EQUAL
11069: IFFALSE 11079
// russianDestroyed := true ;
11071: LD_ADDR_EXP 2
11075: PUSH
11076: LD_INT 1
11078: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11079: LD_VAR 0 1
11083: PUSH
11084: LD_INT 22
11086: PUSH
11087: LD_INT 7
11089: PUSH
11090: EMPTY
11091: LIST
11092: LIST
11093: PUSH
11094: LD_INT 21
11096: PUSH
11097: LD_INT 2
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PPUSH
11108: CALL_OW 69
11112: IN
11113: IFFALSE 11129
// vehicleLostCounter := vehicleLostCounter + 1 ;
11115: LD_ADDR_EXP 15
11119: PUSH
11120: LD_EXP 15
11124: PUSH
11125: LD_INT 1
11127: PLUS
11128: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11129: LD_VAR 0 1
11133: PPUSH
11134: CALL 48924 0 1
// end ;
11138: PPOPN 1
11140: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11141: LD_VAR 0 1
11145: PPUSH
11146: LD_VAR 0 2
11150: PPUSH
11151: CALL 51256 0 2
// end ;
11155: PPOPN 2
11157: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11158: LD_VAR 0 1
11162: PPUSH
11163: CALL 50324 0 1
// end ;
11167: PPOPN 1
11169: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11170: LD_VAR 0 1
11174: PUSH
11175: LD_INT 22
11177: PUSH
11178: LD_INT 8
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: LD_INT 30
11187: PUSH
11188: LD_INT 2
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PUSH
11195: LD_INT 23
11197: PUSH
11198: LD_INT 3
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: LIST
11209: PPUSH
11210: CALL_OW 69
11214: IN
11215: IFFALSE 11242
// begin ComUpgrade ( building ) ;
11217: LD_VAR 0 1
11221: PPUSH
11222: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11226: LD_EXP 57
11230: PPUSH
11231: LD_VAR 0 1
11235: PPUSH
11236: CALL 59906 0 2
// exit ;
11240: GO 11251
// end ; MCE_BuildingComplete ( building ) ;
11242: LD_VAR 0 1
11246: PPUSH
11247: CALL 50565 0 1
// end ;
11251: PPOPN 1
11253: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11254: LD_VAR 0 1
11258: PPUSH
11259: LD_VAR 0 2
11263: PPUSH
11264: CALL 48620 0 2
// end ;
11268: PPOPN 2
11270: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_VAR 0 2
11280: PPUSH
11281: LD_VAR 0 3
11285: PPUSH
11286: LD_VAR 0 4
11290: PPUSH
11291: LD_VAR 0 5
11295: PPUSH
11296: CALL 48240 0 5
// end ;
11300: PPOPN 5
11302: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11303: LD_VAR 0 1
11307: PPUSH
11308: LD_VAR 0 2
11312: PPUSH
11313: CALL 108935 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11317: LD_VAR 0 1
11321: PPUSH
11322: LD_VAR 0 2
11326: PPUSH
11327: CALL 47831 0 2
// end ;
11331: PPOPN 2
11333: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11334: LD_VAR 0 1
11338: PPUSH
11339: LD_VAR 0 2
11343: PPUSH
11344: LD_VAR 0 3
11348: PPUSH
11349: LD_VAR 0 4
11353: PPUSH
11354: CALL 47669 0 4
// end ;
11358: PPOPN 4
11360: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11361: LD_VAR 0 1
11365: PPUSH
11366: LD_VAR 0 2
11370: PPUSH
11371: LD_VAR 0 3
11375: PPUSH
11376: CALL 47444 0 3
// end ;
11380: PPOPN 3
11382: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11383: LD_VAR 0 1
11387: PPUSH
11388: LD_VAR 0 2
11392: PPUSH
11393: CALL 47329 0 2
// end ;
11397: PPOPN 2
11399: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11400: LD_VAR 0 1
11404: PPUSH
11405: LD_VAR 0 2
11409: PPUSH
11410: CALL 51551 0 2
// end ;
11414: PPOPN 2
11416: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11417: LD_VAR 0 1
11421: PPUSH
11422: LD_VAR 0 2
11426: PPUSH
11427: LD_VAR 0 3
11431: PPUSH
11432: LD_VAR 0 4
11436: PPUSH
11437: CALL 51767 0 4
// end ;
11441: PPOPN 4
11443: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11444: LD_VAR 0 1
11448: PPUSH
11449: LD_VAR 0 2
11453: PPUSH
11454: CALL 47138 0 2
// end ;
11458: PPOPN 2
11460: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11461: LD_VAR 0 1
11465: PPUSH
11466: CALL 108919 0 1
// end ; end_of_file
11470: PPOPN 1
11472: END
// export function Action ; begin
11473: LD_INT 0
11475: PPUSH
// InGameOn ;
11476: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11480: LD_INT 206
11482: PPUSH
11483: LD_INT 11
11485: PPUSH
11486: CALL_OW 86
// wait ( 0 0$1 ) ;
11490: LD_INT 35
11492: PPUSH
11493: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11497: LD_EXP 19
11501: PPUSH
11502: LD_STRING DStart-JMM-JMM-1
11504: PPUSH
11505: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11509: LD_EXP 51
11513: PPUSH
11514: LD_STRING DStart-JMM-Bur-1
11516: PPUSH
11517: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11521: LD_EXP 19
11525: PPUSH
11526: LD_STRING DStart-JMM-JMM-2
11528: PPUSH
11529: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11533: LD_EXP 51
11537: PPUSH
11538: LD_STRING DStart-JMM-Bur-2
11540: PPUSH
11541: CALL_OW 88
// InGameOff ;
11545: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11549: LD_STRING MStart
11551: PPUSH
11552: CALL_OW 337
// SaveForQuickRestart ;
11556: CALL_OW 22
// end ;
11560: LD_VAR 0 1
11564: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11565: LD_INT 7
11567: PPUSH
11568: LD_INT 255
11570: PPUSH
11571: LD_INT 219
11573: PPUSH
11574: CALL_OW 293
11578: IFFALSE 12187
11580: GO 11582
11582: DISABLE
11583: LD_INT 0
11585: PPUSH
// begin wait ( 0 0$3 ) ;
11586: LD_INT 105
11588: PPUSH
11589: CALL_OW 67
// alienSpotted := true ;
11593: LD_ADDR_EXP 10
11597: PUSH
11598: LD_INT 1
11600: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11601: LD_ADDR_VAR 0 1
11605: PUSH
11606: LD_INT 22
11608: PUSH
11609: LD_INT 7
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PUSH
11616: LD_INT 23
11618: PUSH
11619: LD_INT 3
11621: PUSH
11622: EMPTY
11623: LIST
11624: LIST
11625: PUSH
11626: LD_INT 21
11628: PUSH
11629: LD_INT 1
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PUSH
11636: LD_INT 26
11638: PUSH
11639: LD_INT 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: EMPTY
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: PPUSH
11652: CALL_OW 69
11656: PUSH
11657: LD_EXP 51
11661: PUSH
11662: LD_EXP 39
11666: PUSH
11667: LD_EXP 41
11671: PUSH
11672: LD_EXP 42
11676: PUSH
11677: LD_EXP 49
11681: PUSH
11682: LD_EXP 48
11686: PUSH
11687: LD_EXP 43
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: DIFF
11701: ST_TO_ADDR
// DialogueOn ;
11702: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11706: LD_INT 255
11708: PPUSH
11709: LD_INT 219
11711: PPUSH
11712: LD_INT 7
11714: PPUSH
11715: LD_INT 20
11717: NEG
11718: PPUSH
11719: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11723: LD_INT 255
11725: PPUSH
11726: LD_INT 219
11728: PPUSH
11729: CALL_OW 86
// if speaker then
11733: LD_VAR 0 1
11737: IFFALSE 11755
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11739: LD_VAR 0 1
11743: PUSH
11744: LD_INT 1
11746: ARRAY
11747: PPUSH
11748: LD_STRING DAlienBase-RSol1-1
11750: PPUSH
11751: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11755: LD_EXP 19
11759: PPUSH
11760: LD_STRING DAlienBase-JMM-1
11762: PPUSH
11763: CALL_OW 88
// if IsOk ( Burlak ) then
11767: LD_EXP 51
11771: PPUSH
11772: CALL_OW 302
11776: IFFALSE 11797
// begin dwait ( 0 0$1 ) ;
11778: LD_INT 35
11780: PPUSH
11781: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11785: LD_EXP 51
11789: PPUSH
11790: LD_STRING DAlienBase-Bur-1
11792: PPUSH
11793: CALL_OW 88
// end ; if IsOk ( Roth ) then
11797: LD_EXP 20
11801: PPUSH
11802: CALL_OW 302
11806: IFFALSE 11820
// Say ( Roth , DAlienBase-Roth-1 ) ;
11808: LD_EXP 20
11812: PPUSH
11813: LD_STRING DAlienBase-Roth-1
11815: PPUSH
11816: CALL_OW 88
// if IsOk ( Gossudarov ) then
11820: LD_EXP 37
11824: PPUSH
11825: CALL_OW 302
11829: IFFALSE 11845
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11831: LD_EXP 37
11835: PPUSH
11836: LD_STRING DAlienBase-Gos-1
11838: PPUSH
11839: CALL_OW 88
11843: GO 11962
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11845: LD_ADDR_VAR 0 1
11849: PUSH
11850: LD_INT 22
11852: PUSH
11853: LD_INT 7
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 25
11862: PUSH
11863: LD_INT 4
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: LD_INT 21
11872: PUSH
11873: LD_INT 1
11875: PUSH
11876: EMPTY
11877: LIST
11878: LIST
11879: PUSH
11880: LD_INT 26
11882: PUSH
11883: LD_INT 1
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: PUSH
11890: EMPTY
11891: LIST
11892: LIST
11893: LIST
11894: LIST
11895: PPUSH
11896: CALL_OW 69
11900: PUSH
11901: LD_EXP 20
11905: PUSH
11906: LD_EXP 19
11910: PUSH
11911: LD_EXP 51
11915: PUSH
11916: LD_EXP 39
11920: PUSH
11921: LD_EXP 49
11925: PUSH
11926: LD_EXP 48
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: LIST
11935: LIST
11936: LIST
11937: LIST
11938: DIFF
11939: ST_TO_ADDR
// if speaker then
11940: LD_VAR 0 1
11944: IFFALSE 11962
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11946: LD_VAR 0 1
11950: PUSH
11951: LD_INT 1
11953: ARRAY
11954: PPUSH
11955: LD_STRING DAlienBase-Sci1-1
11957: PPUSH
11958: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11962: LD_INT 255
11964: PPUSH
11965: LD_INT 219
11967: PPUSH
11968: LD_INT 7
11970: PPUSH
11971: CALL_OW 331
// DialogueOff ;
11975: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11979: LD_INT 35
11981: PPUSH
11982: CALL_OW 67
// until IsSelected ( alien ) ;
11986: LD_INT 1
11988: PPUSH
11989: CALL_OW 306
11993: IFFALSE 11979
// if not artifactIResearched or not artifactIIResearched then
11995: LD_EXP 12
11999: NOT
12000: PUSH
12001: LD_EXP 13
12005: NOT
12006: OR
12007: IFFALSE 12187
// begin if IsOk ( Roth ) then
12009: LD_EXP 20
12013: PPUSH
12014: CALL_OW 302
12018: IFFALSE 12034
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12020: LD_EXP 20
12024: PPUSH
12025: LD_STRING DAlieBaseNotReady-Roth-1
12027: PPUSH
12028: CALL_OW 88
12032: GO 12187
// if IsOk ( Gossudarov ) then
12034: LD_EXP 37
12038: PPUSH
12039: CALL_OW 302
12043: IFFALSE 12059
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12045: LD_EXP 37
12049: PPUSH
12050: LD_STRING DAlieBaseNotReady-Gos-1
12052: PPUSH
12053: CALL_OW 88
12057: GO 12187
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12059: LD_ADDR_VAR 0 1
12063: PUSH
12064: LD_INT 22
12066: PUSH
12067: LD_INT 7
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 23
12076: PUSH
12077: LD_INT 3
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 25
12086: PUSH
12087: LD_INT 4
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: LD_INT 21
12096: PUSH
12097: LD_INT 1
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PUSH
12104: LD_INT 26
12106: PUSH
12107: LD_INT 1
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PUSH
12114: EMPTY
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: PPUSH
12121: CALL_OW 69
12125: PUSH
12126: LD_EXP 20
12130: PUSH
12131: LD_EXP 19
12135: PUSH
12136: LD_EXP 51
12140: PUSH
12141: LD_EXP 39
12145: PUSH
12146: LD_EXP 49
12150: PUSH
12151: LD_EXP 48
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: DIFF
12164: ST_TO_ADDR
// if speaker then
12165: LD_VAR 0 1
12169: IFFALSE 12187
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12171: LD_VAR 0 1
12175: PUSH
12176: LD_INT 1
12178: ARRAY
12179: PPUSH
12180: LD_STRING DAlieBaseNotReady-RSci1-1
12182: PPUSH
12183: CALL_OW 88
// end ; end ; end ;
12187: PPOPN 1
12189: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12190: LD_INT 24
12192: PPUSH
12193: LD_INT 7
12195: PPUSH
12196: CALL_OW 321
12200: PUSH
12201: LD_INT 2
12203: EQUAL
12204: IFFALSE 12895
12206: GO 12208
12208: DISABLE
12209: LD_INT 0
12211: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12212: LD_ADDR_VAR 0 1
12216: PUSH
12217: LD_INT 22
12219: PUSH
12220: LD_INT 7
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PUSH
12227: LD_INT 23
12229: PUSH
12230: LD_INT 3
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: LD_INT 25
12239: PUSH
12240: LD_INT 4
12242: PUSH
12243: EMPTY
12244: LIST
12245: LIST
12246: PUSH
12247: LD_INT 21
12249: PUSH
12250: LD_INT 1
12252: PUSH
12253: EMPTY
12254: LIST
12255: LIST
12256: PUSH
12257: LD_INT 26
12259: PUSH
12260: LD_INT 1
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: PUSH
12267: EMPTY
12268: LIST
12269: LIST
12270: LIST
12271: LIST
12272: LIST
12273: PPUSH
12274: CALL_OW 69
12278: PUSH
12279: LD_EXP 20
12283: PUSH
12284: LD_EXP 19
12288: PUSH
12289: LD_EXP 51
12293: PUSH
12294: LD_EXP 39
12298: PUSH
12299: LD_EXP 49
12303: PUSH
12304: LD_EXP 48
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: DIFF
12317: ST_TO_ADDR
// if not speaker then
12318: LD_VAR 0 1
12322: NOT
12323: IFFALSE 12327
// exit ;
12325: GO 12895
// DialogueOn ;
12327: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12331: LD_VAR 0 1
12335: PUSH
12336: LD_INT 1
12338: ARRAY
12339: PPUSH
12340: LD_STRING DArtefTechnology-RSci1-1
12342: PPUSH
12343: CALL_OW 88
// if IsOk ( Burlak ) then
12347: LD_EXP 51
12351: PPUSH
12352: CALL_OW 302
12356: IFFALSE 12370
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12358: LD_EXP 51
12362: PPUSH
12363: LD_STRING DArtefTechnology-Bur-1
12365: PPUSH
12366: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12370: LD_VAR 0 1
12374: PUSH
12375: LD_INT 1
12377: ARRAY
12378: PPUSH
12379: LD_STRING DArtefTechnology-RSci1-2
12381: PPUSH
12382: CALL_OW 88
// if Denis then
12386: LD_EXP 25
12390: IFFALSE 12407
// speaker := [ Denis ] else
12392: LD_ADDR_VAR 0 1
12396: PUSH
12397: LD_EXP 25
12401: PUSH
12402: EMPTY
12403: LIST
12404: ST_TO_ADDR
12405: GO 12513
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12407: LD_ADDR_VAR 0 1
12411: PUSH
12412: LD_INT 22
12414: PUSH
12415: LD_INT 7
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PUSH
12422: LD_INT 23
12424: PUSH
12425: LD_INT 1
12427: PUSH
12428: EMPTY
12429: LIST
12430: LIST
12431: PUSH
12432: LD_INT 25
12434: PUSH
12435: LD_INT 4
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: PUSH
12442: LD_INT 21
12444: PUSH
12445: LD_INT 1
12447: PUSH
12448: EMPTY
12449: LIST
12450: LIST
12451: PUSH
12452: LD_INT 26
12454: PUSH
12455: LD_INT 1
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: PUSH
12462: EMPTY
12463: LIST
12464: LIST
12465: LIST
12466: LIST
12467: LIST
12468: PPUSH
12469: CALL_OW 69
12473: PUSH
12474: LD_EXP 20
12478: PUSH
12479: LD_EXP 19
12483: PUSH
12484: LD_EXP 51
12488: PUSH
12489: LD_EXP 39
12493: PUSH
12494: LD_EXP 49
12498: PUSH
12499: LD_EXP 48
12503: PUSH
12504: EMPTY
12505: LIST
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: DIFF
12512: ST_TO_ADDR
// if speaker then
12513: LD_VAR 0 1
12517: IFFALSE 12535
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12519: LD_VAR 0 1
12523: PUSH
12524: LD_INT 1
12526: ARRAY
12527: PPUSH
12528: LD_STRING DArtefTechnology-Sci1-2
12530: PPUSH
12531: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12535: LD_ADDR_VAR 0 1
12539: PUSH
12540: LD_INT 22
12542: PUSH
12543: LD_INT 7
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: PUSH
12550: LD_INT 23
12552: PUSH
12553: LD_INT 3
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: LD_INT 25
12562: PUSH
12563: LD_INT 4
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: PUSH
12570: LD_INT 21
12572: PUSH
12573: LD_INT 1
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: PUSH
12580: LD_INT 26
12582: PUSH
12583: LD_INT 1
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: PPUSH
12597: CALL_OW 69
12601: PUSH
12602: LD_EXP 20
12606: PUSH
12607: LD_EXP 19
12611: PUSH
12612: LD_EXP 51
12616: PUSH
12617: LD_EXP 39
12621: PUSH
12622: LD_EXP 49
12626: PUSH
12627: LD_EXP 48
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: LIST
12639: DIFF
12640: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12641: LD_VAR 0 1
12645: PUSH
12646: LD_EXP 9
12650: PUSH
12651: LD_EXP 5
12655: OR
12656: AND
12657: IFFALSE 12891
// begin if arabianDestroyed and IsOk ( Burlak ) then
12659: LD_EXP 5
12663: PUSH
12664: LD_EXP 51
12668: PPUSH
12669: CALL_OW 302
12673: AND
12674: IFFALSE 12690
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12676: LD_EXP 51
12680: PPUSH
12681: LD_STRING DArtefTechnology-Bur-2
12683: PPUSH
12684: CALL_OW 88
12688: GO 12702
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12690: LD_EXP 19
12694: PPUSH
12695: LD_STRING DArtefTechnology-JMM-2
12697: PPUSH
12698: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12702: LD_VAR 0 1
12706: PUSH
12707: LD_INT 1
12709: ARRAY
12710: PPUSH
12711: LD_STRING DArtefTechnology-RSci1-3
12713: PPUSH
12714: CALL_OW 88
// if Denis then
12718: LD_EXP 25
12722: IFFALSE 12739
// speaker := [ Denis ] else
12724: LD_ADDR_VAR 0 1
12728: PUSH
12729: LD_EXP 25
12733: PUSH
12734: EMPTY
12735: LIST
12736: ST_TO_ADDR
12737: GO 12845
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12739: LD_ADDR_VAR 0 1
12743: PUSH
12744: LD_INT 22
12746: PUSH
12747: LD_INT 7
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 23
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 25
12766: PUSH
12767: LD_INT 4
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 21
12776: PUSH
12777: LD_INT 1
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: PUSH
12784: LD_INT 26
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: PPUSH
12801: CALL_OW 69
12805: PUSH
12806: LD_EXP 20
12810: PUSH
12811: LD_EXP 19
12815: PUSH
12816: LD_EXP 51
12820: PUSH
12821: LD_EXP 39
12825: PUSH
12826: LD_EXP 49
12830: PUSH
12831: LD_EXP 48
12835: PUSH
12836: EMPTY
12837: LIST
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: DIFF
12844: ST_TO_ADDR
// if speaker then
12845: LD_VAR 0 1
12849: IFFALSE 12891
// if alienSpotted then
12851: LD_EXP 10
12855: IFFALSE 12875
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12857: LD_VAR 0 1
12861: PUSH
12862: LD_INT 1
12864: ARRAY
12865: PPUSH
12866: LD_STRING DArtefTechnology-Sci1-3
12868: PPUSH
12869: CALL_OW 88
12873: GO 12891
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12875: LD_VAR 0 1
12879: PUSH
12880: LD_INT 1
12882: ARRAY
12883: PPUSH
12884: LD_STRING DArtefTechnology-Sci1-3a
12886: PPUSH
12887: CALL_OW 88
// end ; DialogueOff ;
12891: CALL_OW 7
// end ;
12895: PPOPN 1
12897: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12898: LD_EXP 12
12902: IFFALSE 13105
12904: GO 12906
12906: DISABLE
12907: LD_INT 0
12909: PPUSH
// begin if Denis then
12910: LD_EXP 25
12914: IFFALSE 12931
// speaker := [ Denis ] else
12916: LD_ADDR_VAR 0 1
12920: PUSH
12921: LD_EXP 25
12925: PUSH
12926: EMPTY
12927: LIST
12928: ST_TO_ADDR
12929: GO 13037
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12931: LD_ADDR_VAR 0 1
12935: PUSH
12936: LD_INT 22
12938: PUSH
12939: LD_INT 7
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 23
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: LD_INT 25
12958: PUSH
12959: LD_INT 4
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: LD_INT 21
12968: PUSH
12969: LD_INT 1
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: LD_INT 26
12978: PUSH
12979: LD_INT 1
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: LIST
12992: PPUSH
12993: CALL_OW 69
12997: PUSH
12998: LD_EXP 20
13002: PUSH
13003: LD_EXP 19
13007: PUSH
13008: LD_EXP 51
13012: PUSH
13013: LD_EXP 39
13017: PUSH
13018: LD_EXP 49
13022: PUSH
13023: LD_EXP 48
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: DIFF
13036: ST_TO_ADDR
// if not speaker then
13037: LD_VAR 0 1
13041: NOT
13042: IFFALSE 13046
// exit ;
13044: GO 13105
// DialogueOn ;
13046: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13050: LD_VAR 0 1
13054: PUSH
13055: LD_INT 1
13057: ARRAY
13058: PPUSH
13059: LD_STRING DArtefTechnologyAm-Sci1-1
13061: PPUSH
13062: CALL_OW 88
// if IsOk ( Burlak ) then
13066: LD_EXP 51
13070: PPUSH
13071: CALL_OW 302
13075: IFFALSE 13089
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13077: LD_EXP 51
13081: PPUSH
13082: LD_STRING DArtefTechnologyAm-Bur-1
13084: PPUSH
13085: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13089: LD_EXP 19
13093: PPUSH
13094: LD_STRING DArtefTechnologyAm-JMM-1
13096: PPUSH
13097: CALL_OW 88
// DialogueOff ;
13101: CALL_OW 7
// end ;
13105: PPOPN 1
13107: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13108: LD_EXP 13
13112: IFFALSE 13314
13114: GO 13116
13116: DISABLE
13117: LD_INT 0
13119: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13120: LD_ADDR_VAR 0 1
13124: PUSH
13125: LD_INT 22
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 23
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 25
13147: PUSH
13148: LD_INT 4
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PUSH
13155: LD_INT 21
13157: PUSH
13158: LD_INT 1
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: PUSH
13165: LD_INT 26
13167: PUSH
13168: LD_INT 1
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: PPUSH
13182: CALL_OW 69
13186: PUSH
13187: LD_EXP 20
13191: PUSH
13192: LD_EXP 19
13196: PUSH
13197: LD_EXP 51
13201: PUSH
13202: LD_EXP 39
13206: PUSH
13207: LD_EXP 49
13211: PUSH
13212: LD_EXP 48
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: DIFF
13225: ST_TO_ADDR
// if not speaker then
13226: LD_VAR 0 1
13230: NOT
13231: IFFALSE 13235
// exit ;
13233: GO 13314
// DialogueOn ;
13235: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13239: LD_VAR 0 1
13243: PUSH
13244: LD_VAR 0 1
13248: ARRAY
13249: PPUSH
13250: LD_STRING DArtefTechnologyRu-RSci1-1
13252: PPUSH
13253: CALL_OW 88
// if IsOk ( Burlak ) then
13257: LD_EXP 51
13261: PPUSH
13262: CALL_OW 302
13266: IFFALSE 13280
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13268: LD_EXP 51
13272: PPUSH
13273: LD_STRING DArtefTechnologyRu-Bur-1
13275: PPUSH
13276: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13280: LD_VAR 0 1
13284: PUSH
13285: LD_VAR 0 1
13289: ARRAY
13290: PPUSH
13291: LD_STRING DArtefTechnologyRu-RSci1-2
13293: PPUSH
13294: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13298: LD_EXP 19
13302: PPUSH
13303: LD_STRING DArtefTechnologyRu-JMM-1
13305: PPUSH
13306: CALL_OW 88
// DialogueOff ;
13310: CALL_OW 7
// end ;
13314: PPOPN 1
13316: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13317: LD_INT 24
13319: PPUSH
13320: LD_INT 7
13322: PPUSH
13323: CALL_OW 321
13327: PUSH
13328: LD_INT 2
13330: EQUAL
13331: PUSH
13332: LD_INT 1
13334: PPUSH
13335: CALL_OW 255
13339: PUSH
13340: LD_INT 7
13342: EQUAL
13343: AND
13344: IFFALSE 13512
13346: GO 13348
13348: DISABLE
13349: LD_INT 0
13351: PPUSH
// begin if Denis then
13352: LD_EXP 25
13356: IFFALSE 13373
// speaker := [ Denis ] else
13358: LD_ADDR_VAR 0 1
13362: PUSH
13363: LD_EXP 25
13367: PUSH
13368: EMPTY
13369: LIST
13370: ST_TO_ADDR
13371: GO 13479
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13373: LD_ADDR_VAR 0 1
13377: PUSH
13378: LD_INT 22
13380: PUSH
13381: LD_INT 7
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 23
13390: PUSH
13391: LD_INT 1
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: LD_INT 25
13400: PUSH
13401: LD_INT 4
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: PUSH
13408: LD_INT 21
13410: PUSH
13411: LD_INT 1
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: PUSH
13418: LD_INT 26
13420: PUSH
13421: LD_INT 1
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: LIST
13432: LIST
13433: LIST
13434: PPUSH
13435: CALL_OW 69
13439: PUSH
13440: LD_EXP 20
13444: PUSH
13445: LD_EXP 19
13449: PUSH
13450: LD_EXP 51
13454: PUSH
13455: LD_EXP 39
13459: PUSH
13460: LD_EXP 49
13464: PUSH
13465: LD_EXP 48
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: LIST
13474: LIST
13475: LIST
13476: LIST
13477: DIFF
13478: ST_TO_ADDR
// if not speaker then
13479: LD_VAR 0 1
13483: NOT
13484: IFFALSE 13488
// exit ;
13486: GO 13512
// DialogueOn ;
13488: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13492: LD_VAR 0 1
13496: PUSH
13497: LD_INT 1
13499: ARRAY
13500: PPUSH
13501: LD_STRING DArtefTechnologyArStart-Sci1-1
13503: PPUSH
13504: CALL_OW 88
// DialogueOff ;
13508: CALL_OW 7
// end ;
13512: PPOPN 1
13514: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13515: LD_EXP 14
13519: IFFALSE 13800
13521: GO 13523
13523: DISABLE
13524: LD_INT 0
13526: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13527: LD_ADDR_VAR 0 1
13531: PUSH
13532: LD_INT 22
13534: PUSH
13535: LD_INT 7
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PUSH
13542: LD_INT 23
13544: PUSH
13545: LD_INT 3
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: LD_INT 25
13554: PUSH
13555: LD_INT 4
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: LD_INT 21
13564: PUSH
13565: LD_INT 1
13567: PUSH
13568: EMPTY
13569: LIST
13570: LIST
13571: PUSH
13572: LD_INT 26
13574: PUSH
13575: LD_INT 1
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: PPUSH
13589: CALL_OW 69
13593: PUSH
13594: LD_EXP 20
13598: PUSH
13599: LD_EXP 19
13603: PUSH
13604: LD_EXP 51
13608: PUSH
13609: LD_EXP 39
13613: PUSH
13614: LD_EXP 49
13618: PUSH
13619: LD_EXP 48
13623: PUSH
13624: EMPTY
13625: LIST
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: LIST
13631: DIFF
13632: ST_TO_ADDR
// if not speaker then
13633: LD_VAR 0 1
13637: NOT
13638: IFFALSE 13642
// exit ;
13640: GO 13800
// DialogueOn ;
13642: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13646: LD_VAR 0 1
13650: PUSH
13651: LD_INT 1
13653: ARRAY
13654: PPUSH
13655: LD_STRING DArtefTechnologyAr-RSci1-1
13657: PPUSH
13658: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13662: LD_EXP 19
13666: PPUSH
13667: LD_STRING DArtefTechnologyAr-JMM-1
13669: PPUSH
13670: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13674: LD_VAR 0 1
13678: PUSH
13679: LD_INT 1
13681: ARRAY
13682: PPUSH
13683: LD_STRING DArtefTechnologyAr-RSci1-2
13685: PPUSH
13686: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13690: LD_EXP 19
13694: PPUSH
13695: LD_STRING DArtefTechnologyAr-JMM-2
13697: PPUSH
13698: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13702: LD_VAR 0 1
13706: PUSH
13707: LD_INT 1
13709: ARRAY
13710: PPUSH
13711: LD_STRING DArtefTechnologyAr-RSci1-3
13713: PPUSH
13714: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13718: LD_EXP 19
13722: PPUSH
13723: LD_STRING DArtefTechnologyAr-JMM-3
13725: PPUSH
13726: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13730: LD_VAR 0 1
13734: PUSH
13735: LD_INT 1
13737: ARRAY
13738: PPUSH
13739: LD_STRING DArtefTechnologyAr-RSci1-4
13741: PPUSH
13742: CALL_OW 88
// if IsOk ( Burlak ) then
13746: LD_EXP 51
13750: PPUSH
13751: CALL_OW 302
13755: IFFALSE 13769
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13757: LD_EXP 51
13761: PPUSH
13762: LD_STRING DArtefTechnologyAr-Bur-4
13764: PPUSH
13765: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13769: LD_EXP 19
13773: PPUSH
13774: LD_STRING DArtefTechnologyAr-JMM-4
13776: PPUSH
13777: CALL_OW 88
// DialogueOff ;
13781: CALL_OW 7
// wait ( 0 0$45 ) ;
13785: LD_INT 1575
13787: PPUSH
13788: CALL_OW 67
// spawnOmar := true ;
13792: LD_ADDR_EXP 11
13796: PUSH
13797: LD_INT 1
13799: ST_TO_ADDR
// end ;
13800: PPOPN 1
13802: END
// every 0 0$1 trigger spawnOmar do
13803: LD_EXP 11
13807: IFFALSE 14187
13809: GO 13811
13811: DISABLE
// begin PrepareOmarAli ;
13812: CALL 7193 0 0
// if not HasTask ( Omar ) then
13816: LD_EXP 55
13820: PPUSH
13821: CALL_OW 314
13825: NOT
13826: IFFALSE 13843
// ComMoveXY ( Omar , 252 , 220 ) ;
13828: LD_EXP 55
13832: PPUSH
13833: LD_INT 252
13835: PPUSH
13836: LD_INT 220
13838: PPUSH
13839: CALL_OW 111
// if not Omar then
13843: LD_EXP 55
13847: NOT
13848: IFFALSE 13852
// exit ;
13850: GO 14187
// repeat wait ( 0 0$1 ) ;
13852: LD_INT 35
13854: PPUSH
13855: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13859: LD_EXP 55
13863: PPUSH
13864: CALL_OW 314
13868: NOT
13869: PUSH
13870: LD_EXP 55
13874: PPUSH
13875: LD_INT 252
13877: PPUSH
13878: LD_INT 220
13880: PPUSH
13881: CALL_OW 297
13885: PUSH
13886: LD_INT 6
13888: GREATER
13889: AND
13890: IFFALSE 13907
// ComMoveXY ( Omar , 252 , 220 ) ;
13892: LD_EXP 55
13896: PPUSH
13897: LD_INT 252
13899: PPUSH
13900: LD_INT 220
13902: PPUSH
13903: CALL_OW 111
// until See ( 7 , Omar ) ;
13907: LD_INT 7
13909: PPUSH
13910: LD_EXP 55
13914: PPUSH
13915: CALL_OW 292
13919: IFFALSE 13852
// CenterNowOnUnits ( Omar ) ;
13921: LD_EXP 55
13925: PPUSH
13926: CALL_OW 87
// DialogueOn ;
13930: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13934: LD_EXP 55
13938: PPUSH
13939: LD_STRING DOmar-Omar-1
13941: PPUSH
13942: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13946: LD_EXP 19
13950: PPUSH
13951: LD_STRING DOmar-JMM-1
13953: PPUSH
13954: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13958: LD_EXP 55
13962: PPUSH
13963: LD_STRING DOmar-Omar-2
13965: PPUSH
13966: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13970: LD_EXP 19
13974: PPUSH
13975: LD_STRING DOmar-JMM-2
13977: PPUSH
13978: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13982: LD_EXP 55
13986: PPUSH
13987: LD_STRING DOmar-Omar-3
13989: PPUSH
13990: CALL_OW 88
// if IsOk ( Burlak ) then
13994: LD_EXP 51
13998: PPUSH
13999: CALL_OW 302
14003: IFFALSE 14019
// Say ( Burlak , DOmar-Bur-3 ) else
14005: LD_EXP 51
14009: PPUSH
14010: LD_STRING DOmar-Bur-3
14012: PPUSH
14013: CALL_OW 88
14017: GO 14031
// Say ( JMM , DOmar-JMM-3 ) ;
14019: LD_EXP 19
14023: PPUSH
14024: LD_STRING DOmar-JMM-3
14026: PPUSH
14027: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14031: LD_EXP 55
14035: PPUSH
14036: LD_STRING DOmar-Omar-4
14038: PPUSH
14039: CALL_OW 88
// case Query ( QAccept ) of 1 :
14043: LD_STRING QAccept
14045: PPUSH
14046: CALL_OW 97
14050: PUSH
14051: LD_INT 1
14053: DOUBLE
14054: EQUAL
14055: IFTRUE 14059
14057: GO 14095
14059: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14060: LD_EXP 19
14064: PPUSH
14065: LD_STRING DQrAccept#1-JMM-1
14067: PPUSH
14068: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14072: LD_EXP 55
14076: PPUSH
14077: LD_INT 7
14079: PPUSH
14080: CALL_OW 235
// ComStop ( Omar ) ;
14084: LD_EXP 55
14088: PPUSH
14089: CALL_OW 141
// end ; 2 :
14093: GO 14144
14095: LD_INT 2
14097: DOUBLE
14098: EQUAL
14099: IFTRUE 14103
14101: GO 14143
14103: POP
// begin if IsOk ( Burlak ) then
14104: LD_EXP 51
14108: PPUSH
14109: CALL_OW 302
14113: IFFALSE 14129
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14115: LD_EXP 51
14119: PPUSH
14120: LD_STRING DQrAccept#2-Bur-1
14122: PPUSH
14123: CALL_OW 88
14127: GO 14141
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14129: LD_EXP 19
14133: PPUSH
14134: LD_STRING DQrAccept#2-JMM-1
14136: PPUSH
14137: CALL_OW 88
// end ; end ;
14141: GO 14144
14143: POP
// DialogueOff ;
14144: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14148: LD_EXP 55
14152: PPUSH
14153: CALL_OW 255
14157: PUSH
14158: LD_INT 7
14160: EQUAL
14161: IFFALSE 14172
// begin SetAchievement ( ACH_OMAR ) ;
14163: LD_STRING ACH_OMAR
14165: PPUSH
14166: CALL_OW 543
// exit ;
14170: GO 14187
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14172: LD_EXP 55
14176: PPUSH
14177: LD_INT 202
14179: PPUSH
14180: LD_INT 115
14182: PPUSH
14183: CALL_OW 111
// end ;
14187: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14188: LD_EXP 55
14192: PPUSH
14193: LD_INT 200
14195: PPUSH
14196: LD_INT 98
14198: PPUSH
14199: CALL_OW 297
14203: PUSH
14204: LD_INT 40
14206: LESS
14207: PUSH
14208: LD_EXP 2
14212: AND
14213: IFFALSE 14431
14215: GO 14217
14217: DISABLE
// begin SetSide ( Omar , 5 ) ;
14218: LD_EXP 55
14222: PPUSH
14223: LD_INT 5
14225: PPUSH
14226: CALL_OW 235
// if IsInUnit ( Omar ) then
14230: LD_EXP 55
14234: PPUSH
14235: CALL_OW 310
14239: IFFALSE 14250
// ComExitVehicle ( Omar ) ;
14241: LD_EXP 55
14245: PPUSH
14246: CALL_OW 121
// if IsInUnit ( Omar ) then
14250: LD_EXP 55
14254: PPUSH
14255: CALL_OW 310
14259: IFFALSE 14270
// ComExitBuilding ( Omar ) ;
14261: LD_EXP 55
14265: PPUSH
14266: CALL_OW 122
// wait ( 0 0$1 ) ;
14270: LD_INT 35
14272: PPUSH
14273: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14277: LD_EXP 55
14281: PPUSH
14282: LD_INT 203
14284: PPUSH
14285: LD_INT 120
14287: PPUSH
14288: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14292: LD_INT 35
14294: PPUSH
14295: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14299: LD_EXP 55
14303: PPUSH
14304: CALL_OW 306
14308: PUSH
14309: LD_EXP 55
14313: PPUSH
14314: LD_INT 203
14316: PPUSH
14317: LD_INT 120
14319: PPUSH
14320: CALL_OW 297
14324: PUSH
14325: LD_INT 6
14327: LESS
14328: OR
14329: IFFALSE 14292
// CenterNowOnUnits ( Omar ) ;
14331: LD_EXP 55
14335: PPUSH
14336: CALL_OW 87
// DialogueOn ;
14340: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14344: LD_EXP 19
14348: PPUSH
14349: LD_STRING DOmarContam-JMM-1
14351: PPUSH
14352: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14356: LD_EXP 55
14360: PPUSH
14361: LD_STRING DOmarContam-Omar-1
14363: PPUSH
14364: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14368: LD_EXP 19
14372: PPUSH
14373: LD_STRING DOmarContam-JMM-2
14375: PPUSH
14376: CALL_OW 88
// DialogueOff ;
14380: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14384: LD_INT 5
14386: PPUSH
14387: LD_INT 7
14389: PPUSH
14390: LD_INT 2
14392: PPUSH
14393: LD_INT 1
14395: PPUSH
14396: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14400: LD_INT 105
14402: PPUSH
14403: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14407: LD_EXP 55
14411: PPUSH
14412: LD_INT 203
14414: PPUSH
14415: LD_INT 120
14417: PPUSH
14418: CALL_OW 307
14422: IFFALSE 14400
// YouLost ( MothContaminate ) ;
14424: LD_STRING MothContaminate
14426: PPUSH
14427: CALL_OW 104
// end ;
14431: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14432: LD_EXP 4
14436: NOT
14437: PUSH
14438: LD_INT 22
14440: PUSH
14441: LD_INT 1
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: PUSH
14448: LD_INT 34
14450: PUSH
14451: LD_INT 8
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PPUSH
14462: CALL_OW 69
14466: AND
14467: IFFALSE 14586
14469: GO 14471
14471: DISABLE
// begin wait ( 0 0$5 ) ;
14472: LD_INT 175
14474: PPUSH
14475: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14479: LD_EXP 54
14483: PPUSH
14484: CALL_OW 302
14488: NOT
14489: PUSH
14490: LD_INT 22
14492: PUSH
14493: LD_INT 1
14495: PUSH
14496: EMPTY
14497: LIST
14498: LIST
14499: PUSH
14500: LD_INT 34
14502: PUSH
14503: LD_INT 8
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PUSH
14510: EMPTY
14511: LIST
14512: LIST
14513: PPUSH
14514: CALL_OW 69
14518: NOT
14519: OR
14520: IFFALSE 14524
// exit ;
14522: GO 14586
// DialogueOn ;
14524: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14528: LD_EXP 54
14532: PPUSH
14533: LD_STRING DWinAmericans-Pow-1
14535: PPUSH
14536: CALL_OW 94
// if IsOk ( Burlak ) then
14540: LD_EXP 51
14544: PPUSH
14545: CALL_OW 302
14549: IFFALSE 14563
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14551: LD_EXP 51
14555: PPUSH
14556: LD_STRING DWinAmericans-Bur-1
14558: PPUSH
14559: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14563: LD_EXP 19
14567: PPUSH
14568: LD_STRING DWinAmericans-JMM-1
14570: PPUSH
14571: CALL_OW 88
// DialogueOff ;
14575: CALL_OW 7
// YouLost ( AmBomb ) ;
14579: LD_STRING AmBomb
14581: PPUSH
14582: CALL_OW 104
// end ;
14586: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14587: LD_EXP 2
14591: NOT
14592: PUSH
14593: LD_INT 22
14595: PUSH
14596: LD_INT 3
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PUSH
14603: LD_INT 34
14605: PUSH
14606: LD_INT 48
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: PUSH
14613: EMPTY
14614: LIST
14615: LIST
14616: PPUSH
14617: CALL_OW 69
14621: AND
14622: IFFALSE 14741
14624: GO 14626
14626: DISABLE
// begin wait ( 0 0$5 ) ;
14627: LD_INT 175
14629: PPUSH
14630: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14634: LD_EXP 58
14638: PPUSH
14639: CALL_OW 302
14643: NOT
14644: PUSH
14645: LD_INT 22
14647: PUSH
14648: LD_INT 3
14650: PUSH
14651: EMPTY
14652: LIST
14653: LIST
14654: PUSH
14655: LD_INT 34
14657: PUSH
14658: LD_INT 48
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: PUSH
14665: EMPTY
14666: LIST
14667: LIST
14668: PPUSH
14669: CALL_OW 69
14673: NOT
14674: OR
14675: IFFALSE 14679
// exit ;
14677: GO 14741
// DialogueOn ;
14679: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14683: LD_EXP 58
14687: PPUSH
14688: LD_STRING DWinRussians-Pla-1
14690: PPUSH
14691: CALL_OW 94
// if IsOk ( Burlak ) then
14695: LD_EXP 51
14699: PPUSH
14700: CALL_OW 302
14704: IFFALSE 14718
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14706: LD_EXP 51
14710: PPUSH
14711: LD_STRING DWinRussians-Bur-1
14713: PPUSH
14714: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14718: LD_EXP 19
14722: PPUSH
14723: LD_STRING DWinRussians-JMM-1
14725: PPUSH
14726: CALL_OW 88
// DialogueOff ;
14730: CALL_OW 7
// YouLost ( RuBomb ) ;
14734: LD_STRING RuBomb
14736: PPUSH
14737: CALL_OW 104
// end ;
14741: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14742: LD_INT 7
14744: PPUSH
14745: LD_INT 22
14747: PUSH
14748: LD_INT 7
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: PPUSH
14755: CALL_OW 70
14759: PUSH
14760: LD_EXP 4
14764: NOT
14765: AND
14766: IFFALSE 14795
14768: GO 14770
14770: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14771: LD_EXP 54
14775: PPUSH
14776: LD_STRING DSurrenderAmericans-Pow-1
14778: PPUSH
14779: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14783: LD_EXP 19
14787: PPUSH
14788: LD_STRING DSurrenderAmericans-JMM-1
14790: PPUSH
14791: CALL_OW 88
// end ;
14795: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14796: LD_INT 2
14798: PPUSH
14799: LD_INT 22
14801: PUSH
14802: LD_INT 7
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PPUSH
14809: CALL_OW 70
14813: PUSH
14814: LD_EXP 2
14818: NOT
14819: AND
14820: PUSH
14821: LD_EXP 51
14825: AND
14826: IFFALSE 14855
14828: GO 14830
14830: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14831: LD_EXP 58
14835: PPUSH
14836: LD_STRING DSurrenderRussians-Pla-1
14838: PPUSH
14839: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14843: LD_EXP 51
14847: PPUSH
14848: LD_STRING DSurrenderRussians-Bur-1
14850: PPUSH
14851: CALL_OW 88
// end ;
14855: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14856: LD_EXP 4
14860: IFFALSE 15243
14862: GO 14864
14864: DISABLE
14865: LD_INT 0
14867: PPUSH
14868: PPUSH
14869: PPUSH
// begin MC_Kill ( 4 ) ;
14870: LD_INT 4
14872: PPUSH
14873: CALL 21493 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14877: LD_INT 1
14879: PPUSH
14880: LD_INT 7
14882: PPUSH
14883: LD_INT 1
14885: PPUSH
14886: LD_INT 1
14888: PPUSH
14889: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14893: LD_ADDR_VAR 0 3
14897: PUSH
14898: LD_INT 22
14900: PUSH
14901: LD_INT 1
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 26
14910: PUSH
14911: LD_INT 1
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: PUSH
14918: LD_INT 23
14920: PUSH
14921: LD_INT 1
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: PUSH
14928: EMPTY
14929: LIST
14930: LIST
14931: LIST
14932: PPUSH
14933: CALL_OW 69
14937: PUSH
14938: LD_EXP 54
14942: PUSH
14943: LD_EXP 27
14947: PUSH
14948: LD_EXP 24
14952: PUSH
14953: LD_EXP 23
14957: PUSH
14958: LD_EXP 30
14962: PUSH
14963: LD_EXP 28
14967: PUSH
14968: EMPTY
14969: LIST
14970: LIST
14971: LIST
14972: LIST
14973: LIST
14974: LIST
14975: DIFF
14976: ST_TO_ADDR
// if speaker then
14977: LD_VAR 0 3
14981: IFFALSE 15007
// begin DialogueOn ;
14983: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14987: LD_VAR 0 3
14991: PUSH
14992: LD_INT 1
14994: ARRAY
14995: PPUSH
14996: LD_STRING DSurrenderAmericans-Sol1-1a
14998: PPUSH
14999: CALL_OW 94
// DialogueOff ;
15003: CALL_OW 7
// end ; americanCapitulated := true ;
15007: LD_ADDR_EXP 6
15011: PUSH
15012: LD_INT 1
15014: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15015: LD_ADDR_VAR 0 2
15019: PUSH
15020: LD_INT 22
15022: PUSH
15023: LD_INT 1
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: PUSH
15030: LD_INT 21
15032: PUSH
15033: LD_INT 1
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: PPUSH
15044: CALL_OW 69
15048: PUSH
15049: LD_INT 22
15051: PUSH
15052: LD_INT 1
15054: PUSH
15055: EMPTY
15056: LIST
15057: LIST
15058: PUSH
15059: LD_INT 21
15061: PUSH
15062: LD_INT 2
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: PUSH
15069: LD_INT 1
15071: PUSH
15072: EMPTY
15073: LIST
15074: PUSH
15075: EMPTY
15076: LIST
15077: LIST
15078: LIST
15079: PPUSH
15080: CALL_OW 69
15084: ADD
15085: ST_TO_ADDR
// if tmp then
15086: LD_VAR 0 2
15090: IFFALSE 15243
// repeat wait ( 0 0$1 ) ;
15092: LD_INT 35
15094: PPUSH
15095: CALL_OW 67
// for i in tmp do
15099: LD_ADDR_VAR 0 1
15103: PUSH
15104: LD_VAR 0 2
15108: PUSH
15109: FOR_IN
15110: IFFALSE 15192
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15112: LD_VAR 0 1
15116: PPUSH
15117: CALL_OW 310
15121: PUSH
15122: LD_VAR 0 1
15126: PPUSH
15127: CALL_OW 310
15131: PPUSH
15132: CALL_OW 247
15136: PUSH
15137: LD_INT 3
15139: EQUAL
15140: AND
15141: IFFALSE 15152
// ComExitBuilding ( i ) ;
15143: LD_VAR 0 1
15147: PPUSH
15148: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15152: LD_VAR 0 1
15156: PPUSH
15157: LD_INT 122
15159: PPUSH
15160: LD_INT 242
15162: PPUSH
15163: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15167: LD_VAR 0 1
15171: PPUSH
15172: LD_INT 35
15174: PPUSH
15175: CALL_OW 308
15179: IFFALSE 15190
// RemoveUnit ( i ) ;
15181: LD_VAR 0 1
15185: PPUSH
15186: CALL_OW 64
// end ;
15190: GO 15109
15192: POP
15193: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15194: LD_INT 22
15196: PUSH
15197: LD_INT 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PUSH
15204: LD_INT 2
15206: PUSH
15207: LD_INT 21
15209: PUSH
15210: LD_INT 1
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: PUSH
15217: LD_INT 33
15219: PUSH
15220: LD_INT 1
15222: PUSH
15223: EMPTY
15224: LIST
15225: LIST
15226: PUSH
15227: EMPTY
15228: LIST
15229: LIST
15230: LIST
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PPUSH
15236: CALL_OW 69
15240: NOT
15241: IFFALSE 15092
// end ;
15243: PPOPN 3
15245: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15246: LD_EXP 2
15250: IFFALSE 15651
15252: GO 15254
15254: DISABLE
15255: LD_INT 0
15257: PPUSH
15258: PPUSH
15259: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15260: LD_INT 35
15262: PPUSH
15263: CALL_OW 67
// until IsDead ( Yakotich ) ;
15267: LD_EXP 59
15271: PPUSH
15272: CALL_OW 301
15276: IFFALSE 15260
// MC_Kill ( 2 ) ;
15278: LD_INT 2
15280: PPUSH
15281: CALL 21493 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15285: LD_INT 3
15287: PPUSH
15288: LD_INT 7
15290: PPUSH
15291: LD_INT 1
15293: PPUSH
15294: LD_INT 1
15296: PPUSH
15297: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15301: LD_ADDR_VAR 0 3
15305: PUSH
15306: LD_INT 22
15308: PUSH
15309: LD_INT 3
15311: PUSH
15312: EMPTY
15313: LIST
15314: LIST
15315: PUSH
15316: LD_INT 26
15318: PUSH
15319: LD_INT 1
15321: PUSH
15322: EMPTY
15323: LIST
15324: LIST
15325: PUSH
15326: LD_INT 23
15328: PUSH
15329: LD_INT 3
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: PUSH
15336: EMPTY
15337: LIST
15338: LIST
15339: LIST
15340: PPUSH
15341: CALL_OW 69
15345: PUSH
15346: LD_EXP 58
15350: PUSH
15351: LD_EXP 59
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: DIFF
15360: ST_TO_ADDR
// if speaker then
15361: LD_VAR 0 3
15365: IFFALSE 15415
// begin DialogueOn ;
15367: CALL_OW 6
// if Burlak then
15371: LD_EXP 51
15375: IFFALSE 15395
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15377: LD_VAR 0 3
15381: PUSH
15382: LD_INT 1
15384: ARRAY
15385: PPUSH
15386: LD_STRING DSurrenderRussians-RSol1-1
15388: PPUSH
15389: CALL_OW 94
15393: GO 15411
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15395: LD_VAR 0 3
15399: PUSH
15400: LD_INT 1
15402: ARRAY
15403: PPUSH
15404: LD_STRING DSurrenderRussians-RSol1-1a
15406: PPUSH
15407: CALL_OW 94
// DialogueOff ;
15411: CALL_OW 7
// end ; russianCapitulated := true ;
15415: LD_ADDR_EXP 7
15419: PUSH
15420: LD_INT 1
15422: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15423: LD_ADDR_VAR 0 2
15427: PUSH
15428: LD_INT 22
15430: PUSH
15431: LD_INT 3
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PUSH
15438: LD_INT 21
15440: PUSH
15441: LD_INT 1
15443: PUSH
15444: EMPTY
15445: LIST
15446: LIST
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: PPUSH
15452: CALL_OW 69
15456: PUSH
15457: LD_INT 22
15459: PUSH
15460: LD_INT 3
15462: PUSH
15463: EMPTY
15464: LIST
15465: LIST
15466: PUSH
15467: LD_INT 21
15469: PUSH
15470: LD_INT 2
15472: PUSH
15473: EMPTY
15474: LIST
15475: LIST
15476: PUSH
15477: LD_INT 1
15479: PUSH
15480: EMPTY
15481: LIST
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: LIST
15487: PPUSH
15488: CALL_OW 69
15492: ADD
15493: ST_TO_ADDR
// if tmp then
15494: LD_VAR 0 2
15498: IFFALSE 15651
// repeat wait ( 0 0$1 ) ;
15500: LD_INT 35
15502: PPUSH
15503: CALL_OW 67
// for i in tmp do
15507: LD_ADDR_VAR 0 1
15511: PUSH
15512: LD_VAR 0 2
15516: PUSH
15517: FOR_IN
15518: IFFALSE 15600
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15520: LD_VAR 0 1
15524: PPUSH
15525: CALL_OW 310
15529: PUSH
15530: LD_VAR 0 1
15534: PPUSH
15535: CALL_OW 310
15539: PPUSH
15540: CALL_OW 247
15544: PUSH
15545: LD_INT 3
15547: EQUAL
15548: AND
15549: IFFALSE 15560
// ComExitBuilding ( i ) ;
15551: LD_VAR 0 1
15555: PPUSH
15556: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15560: LD_VAR 0 1
15564: PPUSH
15565: LD_INT 154
15567: PPUSH
15568: LD_INT 1
15570: PPUSH
15571: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15575: LD_VAR 0 1
15579: PPUSH
15580: LD_INT 36
15582: PPUSH
15583: CALL_OW 308
15587: IFFALSE 15598
// RemoveUnit ( i ) ;
15589: LD_VAR 0 1
15593: PPUSH
15594: CALL_OW 64
// end ;
15598: GO 15517
15600: POP
15601: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15602: LD_INT 22
15604: PUSH
15605: LD_INT 3
15607: PUSH
15608: EMPTY
15609: LIST
15610: LIST
15611: PUSH
15612: LD_INT 2
15614: PUSH
15615: LD_INT 21
15617: PUSH
15618: LD_INT 1
15620: PUSH
15621: EMPTY
15622: LIST
15623: LIST
15624: PUSH
15625: LD_INT 33
15627: PUSH
15628: LD_INT 1
15630: PUSH
15631: EMPTY
15632: LIST
15633: LIST
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: PPUSH
15644: CALL_OW 69
15648: NOT
15649: IFFALSE 15500
// end ;
15651: PPOPN 3
15653: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15654: LD_INT 22
15656: PUSH
15657: LD_INT 8
15659: PUSH
15660: EMPTY
15661: LIST
15662: LIST
15663: PUSH
15664: LD_INT 21
15666: PUSH
15667: LD_INT 1
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PUSH
15674: LD_INT 23
15676: PUSH
15677: LD_INT 2
15679: PUSH
15680: EMPTY
15681: LIST
15682: LIST
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: LIST
15688: PPUSH
15689: CALL_OW 69
15693: PUSH
15694: LD_INT 18
15696: LESS
15697: PUSH
15698: LD_EXP 57
15702: PPUSH
15703: CALL_OW 301
15707: OR
15708: PUSH
15709: LD_INT 324
15711: PPUSH
15712: CALL_OW 255
15716: PUSH
15717: LD_INT 7
15719: EQUAL
15720: OR
15721: IFFALSE 15734
15723: GO 15725
15725: DISABLE
// legionDestroyed := true ;
15726: LD_ADDR_EXP 3
15730: PUSH
15731: LD_INT 1
15733: ST_TO_ADDR
15734: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15735: LD_INT 22
15737: PUSH
15738: LD_INT 2
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: LD_INT 21
15747: PUSH
15748: LD_INT 1
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: PUSH
15755: LD_INT 23
15757: PUSH
15758: LD_INT 2
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: LIST
15769: PPUSH
15770: CALL_OW 69
15774: PUSH
15775: LD_INT 9
15777: LESS
15778: IFFALSE 15791
15780: GO 15782
15782: DISABLE
// arabianDestroyed := true ;
15783: LD_ADDR_EXP 5
15787: PUSH
15788: LD_INT 1
15790: ST_TO_ADDR
15791: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15792: LD_EXP 5
15796: IFFALSE 16040
15798: GO 15800
15800: DISABLE
15801: LD_INT 0
15803: PPUSH
15804: PPUSH
// begin MC_Kill ( 1 ) ;
15805: LD_INT 1
15807: PPUSH
15808: CALL 21493 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15812: LD_ADDR_VAR 0 2
15816: PUSH
15817: LD_INT 22
15819: PUSH
15820: LD_INT 2
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 21
15829: PUSH
15830: LD_INT 1
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: PPUSH
15841: CALL_OW 69
15845: PUSH
15846: LD_INT 22
15848: PUSH
15849: LD_INT 8
15851: PUSH
15852: EMPTY
15853: LIST
15854: LIST
15855: PUSH
15856: LD_INT 21
15858: PUSH
15859: LD_INT 2
15861: PUSH
15862: EMPTY
15863: LIST
15864: LIST
15865: PUSH
15866: LD_INT 1
15868: PUSH
15869: EMPTY
15870: LIST
15871: PUSH
15872: EMPTY
15873: LIST
15874: LIST
15875: LIST
15876: PPUSH
15877: CALL_OW 69
15881: ADD
15882: ST_TO_ADDR
// if tmp then
15883: LD_VAR 0 2
15887: IFFALSE 16040
// repeat wait ( 0 0$1 ) ;
15889: LD_INT 35
15891: PPUSH
15892: CALL_OW 67
// for i in tmp do
15896: LD_ADDR_VAR 0 1
15900: PUSH
15901: LD_VAR 0 2
15905: PUSH
15906: FOR_IN
15907: IFFALSE 15989
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15909: LD_VAR 0 1
15913: PPUSH
15914: CALL_OW 310
15918: PUSH
15919: LD_VAR 0 1
15923: PPUSH
15924: CALL_OW 310
15928: PPUSH
15929: CALL_OW 247
15933: PUSH
15934: LD_INT 3
15936: EQUAL
15937: AND
15938: IFFALSE 15949
// ComExitBuilding ( i ) ;
15940: LD_VAR 0 1
15944: PPUSH
15945: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15949: LD_VAR 0 1
15953: PPUSH
15954: LD_INT 254
15956: PPUSH
15957: LD_INT 268
15959: PPUSH
15960: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15964: LD_VAR 0 1
15968: PPUSH
15969: LD_INT 34
15971: PPUSH
15972: CALL_OW 308
15976: IFFALSE 15987
// RemoveUnit ( i ) ;
15978: LD_VAR 0 1
15982: PPUSH
15983: CALL_OW 64
// end ;
15987: GO 15906
15989: POP
15990: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15991: LD_INT 22
15993: PUSH
15994: LD_INT 2
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: PUSH
16001: LD_INT 2
16003: PUSH
16004: LD_INT 21
16006: PUSH
16007: LD_INT 1
16009: PUSH
16010: EMPTY
16011: LIST
16012: LIST
16013: PUSH
16014: LD_INT 33
16016: PUSH
16017: LD_INT 1
16019: PUSH
16020: EMPTY
16021: LIST
16022: LIST
16023: PUSH
16024: EMPTY
16025: LIST
16026: LIST
16027: LIST
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PPUSH
16033: CALL_OW 69
16037: NOT
16038: IFFALSE 15889
// end ;
16040: PPOPN 2
16042: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16043: LD_EXP 3
16047: IFFALSE 16399
16049: GO 16051
16051: DISABLE
16052: LD_INT 0
16054: PPUSH
16055: PPUSH
// begin MC_Kill ( 3 ) ;
16056: LD_INT 3
16058: PPUSH
16059: CALL 21493 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16063: LD_INT 8
16065: PPUSH
16066: LD_INT 7
16068: PPUSH
16069: LD_INT 1
16071: PPUSH
16072: LD_INT 1
16074: PPUSH
16075: CALL_OW 80
// DialogueOn ;
16079: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16083: LD_EXP 56
16087: PPUSH
16088: LD_STRING D15-Szulc-1
16090: PPUSH
16091: CALL_OW 94
// DialogueOff ;
16095: CALL_OW 7
// legionCapitulated := true ;
16099: LD_ADDR_EXP 8
16103: PUSH
16104: LD_INT 1
16106: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16107: LD_ADDR_VAR 0 1
16111: PUSH
16112: LD_INT 22
16114: PUSH
16115: LD_INT 8
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: PUSH
16122: LD_INT 21
16124: PUSH
16125: LD_INT 3
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: PUSH
16132: LD_INT 23
16134: PUSH
16135: LD_INT 3
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: PPUSH
16147: CALL_OW 69
16151: PUSH
16152: FOR_IN
16153: IFFALSE 16169
// SetLives ( i , 3 ) ;
16155: LD_VAR 0 1
16159: PPUSH
16160: LD_INT 3
16162: PPUSH
16163: CALL_OW 234
16167: GO 16152
16169: POP
16170: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16171: LD_ADDR_VAR 0 2
16175: PUSH
16176: LD_INT 22
16178: PUSH
16179: LD_INT 8
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: PUSH
16186: LD_INT 21
16188: PUSH
16189: LD_INT 1
16191: PUSH
16192: EMPTY
16193: LIST
16194: LIST
16195: PUSH
16196: EMPTY
16197: LIST
16198: LIST
16199: PPUSH
16200: CALL_OW 69
16204: PUSH
16205: LD_INT 22
16207: PUSH
16208: LD_INT 8
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: PUSH
16215: LD_INT 21
16217: PUSH
16218: LD_INT 2
16220: PUSH
16221: EMPTY
16222: LIST
16223: LIST
16224: PUSH
16225: LD_INT 1
16227: PUSH
16228: EMPTY
16229: LIST
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: LIST
16235: PPUSH
16236: CALL_OW 69
16240: ADD
16241: ST_TO_ADDR
// if tmp then
16242: LD_VAR 0 2
16246: IFFALSE 16399
// repeat wait ( 0 0$1 ) ;
16248: LD_INT 35
16250: PPUSH
16251: CALL_OW 67
// for i in tmp do
16255: LD_ADDR_VAR 0 1
16259: PUSH
16260: LD_VAR 0 2
16264: PUSH
16265: FOR_IN
16266: IFFALSE 16348
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16268: LD_VAR 0 1
16272: PPUSH
16273: CALL_OW 310
16277: PUSH
16278: LD_VAR 0 1
16282: PPUSH
16283: CALL_OW 310
16287: PPUSH
16288: CALL_OW 247
16292: PUSH
16293: LD_INT 3
16295: EQUAL
16296: AND
16297: IFFALSE 16308
// ComExitBuilding ( i ) ;
16299: LD_VAR 0 1
16303: PPUSH
16304: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_INT 10
16315: PPUSH
16316: LD_INT 1
16318: PPUSH
16319: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16323: LD_VAR 0 1
16327: PPUSH
16328: LD_INT 32
16330: PPUSH
16331: CALL_OW 308
16335: IFFALSE 16346
// RemoveUnit ( i ) ;
16337: LD_VAR 0 1
16341: PPUSH
16342: CALL_OW 64
// end ;
16346: GO 16265
16348: POP
16349: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16350: LD_INT 22
16352: PUSH
16353: LD_INT 8
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: PUSH
16360: LD_INT 2
16362: PUSH
16363: LD_INT 21
16365: PUSH
16366: LD_INT 1
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 33
16375: PUSH
16376: LD_INT 1
16378: PUSH
16379: EMPTY
16380: LIST
16381: LIST
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: LIST
16387: PUSH
16388: EMPTY
16389: LIST
16390: LIST
16391: PPUSH
16392: CALL_OW 69
16396: NOT
16397: IFFALSE 16248
// end ;
16399: PPOPN 2
16401: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 do
16402: LD_EXP 5
16406: NOT
16407: PUSH
16408: LD_OWVAR 1
16412: PUSH
16413: LD_INT 63000
16415: GREATEREQUAL
16416: AND
16417: IFFALSE 16426
16419: GO 16421
16421: DISABLE
// AllianceSupport ;
16422: CALL 4634 0 0
16426: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16427: LD_EXP 4
16431: PUSH
16432: LD_EXP 2
16436: AND
16437: PUSH
16438: LD_EXP 3
16442: AND
16443: PUSH
16444: LD_EXP 5
16448: AND
16449: PUSH
16450: LD_EXP 6
16454: AND
16455: PUSH
16456: LD_EXP 7
16460: AND
16461: PUSH
16462: LD_EXP 8
16466: AND
16467: PUSH
16468: LD_EXP 55
16472: PPUSH
16473: CALL_OW 255
16477: PUSH
16478: LD_INT 5
16480: NONEQUAL
16481: PUSH
16482: LD_EXP 55
16486: PPUSH
16487: CALL_OW 301
16491: OR
16492: PUSH
16493: LD_EXP 55
16497: PPUSH
16498: CALL_OW 305
16502: NOT
16503: OR
16504: AND
16505: IFFALSE 17907
16507: GO 16509
16509: DISABLE
16510: LD_INT 0
16512: PPUSH
16513: PPUSH
// begin wait ( 0 0$5 ) ;
16514: LD_INT 175
16516: PPUSH
16517: CALL_OW 67
// music_class := 5 ;
16521: LD_ADDR_OWVAR 72
16525: PUSH
16526: LD_INT 5
16528: ST_TO_ADDR
// music_nat := 5 ;
16529: LD_ADDR_OWVAR 71
16533: PUSH
16534: LD_INT 5
16536: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16537: LD_EXP 15
16541: PUSH
16542: LD_INT 3
16544: LESS
16545: IFFALSE 16554
// SetAchievement ( ACH_ECONOMY ) ;
16547: LD_STRING ACH_ECONOMY
16549: PPUSH
16550: CALL_OW 543
// if tick < 60 60$00 then
16554: LD_OWVAR 1
16558: PUSH
16559: LD_INT 126000
16561: LESS
16562: IFFALSE 16578
// begin wait ( 3 ) ;
16564: LD_INT 3
16566: PPUSH
16567: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16571: LD_STRING ACH_ASPEED_19
16573: PPUSH
16574: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16578: LD_EXP 19
16582: PPUSH
16583: CALL_OW 87
// InGameOn ;
16587: CALL_OW 8
// DialogueOn ;
16591: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16595: LD_EXP 19
16599: PPUSH
16600: LD_STRING DEnd-JMM-JMM-1
16602: PPUSH
16603: CALL_OW 88
// if Joan then
16607: LD_EXP 34
16611: IFFALSE 16627
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16613: LD_EXP 34
16617: PPUSH
16618: LD_STRING DEnd-JMM-Joan-1
16620: PPUSH
16621: CALL_OW 88
16625: GO 16671
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16627: LD_EXP 21
16631: PUSH
16632: LD_EXP 21
16636: PPUSH
16637: CALL_OW 255
16641: PUSH
16642: LD_INT 7
16644: EQUAL
16645: AND
16646: PUSH
16647: LD_EXP 21
16651: PPUSH
16652: CALL_OW 305
16656: AND
16657: IFFALSE 16671
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16659: LD_EXP 21
16663: PPUSH
16664: LD_STRING DEnd-JMM-Lisa-1
16666: PPUSH
16667: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16671: LD_EXP 31
16675: PUSH
16676: LD_EXP 31
16680: PPUSH
16681: CALL_OW 305
16685: AND
16686: IFFALSE 16700
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16688: LD_EXP 31
16692: PPUSH
16693: LD_STRING DEnd-JMM-Frank-1
16695: PPUSH
16696: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16700: LD_EXP 24
16704: PUSH
16705: LD_EXP 24
16709: PPUSH
16710: CALL_OW 255
16714: PUSH
16715: LD_INT 7
16717: EQUAL
16718: AND
16719: PUSH
16720: LD_EXP 24
16724: PPUSH
16725: CALL_OW 305
16729: AND
16730: IFFALSE 16744
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16732: LD_EXP 24
16736: PPUSH
16737: LD_STRING DEnd-JMM-Cyrus-1
16739: PPUSH
16740: CALL_OW 88
// if Burlak then
16744: LD_EXP 51
16748: IFFALSE 16762
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16750: LD_EXP 51
16754: PPUSH
16755: LD_STRING DEnd-JMM-Bur-1
16757: PPUSH
16758: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16762: LD_EXP 34
16766: PUSH
16767: LD_EXP 21
16771: AND
16772: PUSH
16773: LD_EXP 21
16777: PPUSH
16778: CALL_OW 255
16782: PUSH
16783: LD_INT 7
16785: EQUAL
16786: AND
16787: PUSH
16788: LD_EXP 21
16792: PPUSH
16793: CALL_OW 305
16797: AND
16798: PUSH
16799: LD_EXP 51
16803: PPUSH
16804: CALL_OW 302
16808: AND
16809: IFFALSE 16823
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16811: LD_EXP 21
16815: PPUSH
16816: LD_STRING DEnd-Burlak-Lisa-1
16818: PPUSH
16819: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16823: LD_EXP 52
16827: PUSH
16828: LD_EXP 52
16832: PPUSH
16833: CALL_OW 305
16837: AND
16838: IFFALSE 16852
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16840: LD_EXP 52
16844: PPUSH
16845: LD_STRING DEnd-JMM-Bel-1
16847: PPUSH
16848: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16852: LD_EXP 53
16856: PUSH
16857: LD_EXP 53
16861: PPUSH
16862: CALL_OW 305
16866: AND
16867: IFFALSE 16881
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16869: LD_EXP 53
16873: PPUSH
16874: LD_STRING DEnd-JMM-Gny-1
16876: PPUSH
16877: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16881: LD_EXP 29
16885: PUSH
16886: LD_EXP 29
16890: PPUSH
16891: CALL_OW 255
16895: PUSH
16896: LD_INT 7
16898: EQUAL
16899: AND
16900: PUSH
16901: LD_EXP 29
16905: PPUSH
16906: CALL_OW 305
16910: AND
16911: IFFALSE 16925
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16913: LD_EXP 29
16917: PPUSH
16918: LD_STRING DEnd-JMM-Corn-1
16920: PPUSH
16921: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16925: LD_EXP 22
16929: PUSH
16930: LD_EXP 22
16934: PPUSH
16935: CALL_OW 255
16939: PUSH
16940: LD_INT 7
16942: EQUAL
16943: AND
16944: PUSH
16945: LD_EXP 22
16949: PPUSH
16950: CALL_OW 305
16954: AND
16955: IFFALSE 16969
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16957: LD_EXP 22
16961: PPUSH
16962: LD_STRING DEnd-JMM-Don-1
16964: PPUSH
16965: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16969: LD_EXP 23
16973: PUSH
16974: LD_EXP 23
16978: PPUSH
16979: CALL_OW 255
16983: PUSH
16984: LD_INT 7
16986: EQUAL
16987: AND
16988: PUSH
16989: LD_EXP 23
16993: PPUSH
16994: CALL_OW 305
16998: AND
16999: IFFALSE 17013
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
17001: LD_EXP 23
17005: PPUSH
17006: LD_STRING DEnd-JMM-Bobby-1
17008: PPUSH
17009: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17013: LD_EXP 25
17017: PUSH
17018: LD_EXP 25
17022: PPUSH
17023: CALL_OW 255
17027: PUSH
17028: LD_INT 7
17030: EQUAL
17031: AND
17032: PUSH
17033: LD_EXP 25
17037: PPUSH
17038: CALL_OW 305
17042: AND
17043: IFFALSE 17057
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17045: LD_EXP 25
17049: PPUSH
17050: LD_STRING DEnd-JMM-Den-1
17052: PPUSH
17053: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17057: LD_EXP 27
17061: PUSH
17062: LD_EXP 27
17066: PPUSH
17067: CALL_OW 255
17071: PUSH
17072: LD_INT 7
17074: EQUAL
17075: AND
17076: PUSH
17077: LD_EXP 27
17081: PPUSH
17082: CALL_OW 305
17086: AND
17087: IFFALSE 17101
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17089: LD_EXP 27
17093: PPUSH
17094: LD_STRING DEnd-JMM-Glad-1
17096: PPUSH
17097: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17101: LD_EXP 32
17105: PUSH
17106: LD_EXP 32
17110: PPUSH
17111: CALL_OW 255
17115: PUSH
17116: LD_INT 7
17118: EQUAL
17119: AND
17120: PUSH
17121: LD_EXP 32
17125: PPUSH
17126: CALL_OW 305
17130: AND
17131: IFFALSE 17145
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17133: LD_EXP 32
17137: PPUSH
17138: LD_STRING DEnd-JMM-Yam-1
17140: PPUSH
17141: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17145: LD_EXP 26
17149: PUSH
17150: LD_EXP 26
17154: PPUSH
17155: CALL_OW 255
17159: PUSH
17160: LD_INT 7
17162: EQUAL
17163: AND
17164: PUSH
17165: LD_EXP 26
17169: PPUSH
17170: CALL_OW 305
17174: AND
17175: IFFALSE 17189
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17177: LD_EXP 26
17181: PPUSH
17182: LD_STRING DEnd-JMM-Brown-1
17184: PPUSH
17185: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17189: LD_EXP 36
17193: PUSH
17194: LD_EXP 36
17198: PPUSH
17199: CALL_OW 255
17203: PUSH
17204: LD_INT 7
17206: EQUAL
17207: AND
17208: PUSH
17209: LD_EXP 36
17213: PPUSH
17214: CALL_OW 305
17218: AND
17219: IFFALSE 17233
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17221: LD_EXP 36
17225: PPUSH
17226: LD_STRING DEnd-JMM-Con-1
17228: PPUSH
17229: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17233: LD_EXP 30
17237: PUSH
17238: LD_EXP 30
17242: PPUSH
17243: CALL_OW 255
17247: PUSH
17248: LD_INT 7
17250: EQUAL
17251: AND
17252: PUSH
17253: LD_EXP 30
17257: PPUSH
17258: CALL_OW 305
17262: AND
17263: IFFALSE 17277
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17265: LD_EXP 30
17269: PPUSH
17270: LD_STRING DEnd-JMM-Gary-1
17272: PPUSH
17273: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17277: LD_EXP 33
17281: PUSH
17282: LD_EXP 20
17286: AND
17287: PUSH
17288: LD_EXP 33
17292: PPUSH
17293: CALL_OW 305
17297: AND
17298: IFFALSE 17312
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17300: LD_EXP 33
17304: PPUSH
17305: LD_STRING DEnd-JMM-Sim-1
17307: PPUSH
17308: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17312: LD_EXP 28
17316: PUSH
17317: LD_EXP 28
17321: PPUSH
17322: CALL_OW 255
17326: PUSH
17327: LD_INT 7
17329: EQUAL
17330: AND
17331: PUSH
17332: LD_EXP 28
17336: PPUSH
17337: CALL_OW 305
17341: AND
17342: IFFALSE 17356
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17344: LD_EXP 28
17348: PPUSH
17349: LD_STRING DEnd-JMM-VanH-1
17351: PPUSH
17352: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17356: LD_EXP 41
17360: PUSH
17361: LD_EXP 41
17365: PPUSH
17366: CALL_OW 305
17370: AND
17371: IFFALSE 17385
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17373: LD_EXP 41
17377: PPUSH
17378: LD_STRING DEnd-JMM-Dol-1
17380: PPUSH
17381: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17385: LD_EXP 45
17389: PUSH
17390: LD_EXP 45
17394: PPUSH
17395: CALL_OW 305
17399: AND
17400: IFFALSE 17414
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17402: LD_EXP 45
17406: PPUSH
17407: LD_STRING DEnd-JMM-Kap-1
17409: PPUSH
17410: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17414: LD_EXP 48
17418: PUSH
17419: LD_EXP 48
17423: PPUSH
17424: CALL_OW 305
17428: AND
17429: IFFALSE 17443
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17431: LD_EXP 48
17435: PPUSH
17436: LD_STRING DEnd-JMM-Kov-1
17438: PPUSH
17439: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17443: LD_EXP 43
17447: PUSH
17448: LD_EXP 43
17452: PPUSH
17453: CALL_OW 305
17457: AND
17458: IFFALSE 17472
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17460: LD_EXP 43
17464: PPUSH
17465: LD_STRING DEnd-JMM-Sch-1
17467: PPUSH
17468: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17472: LD_EXP 39
17476: PUSH
17477: LD_EXP 39
17481: PPUSH
17482: CALL_OW 305
17486: AND
17487: IFFALSE 17501
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17489: LD_EXP 39
17493: PPUSH
17494: LD_STRING DEnd-JMM-Tit-1
17496: PPUSH
17497: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17501: LD_EXP 44
17505: PUSH
17506: LD_EXP 44
17510: PPUSH
17511: CALL_OW 305
17515: AND
17516: IFFALSE 17530
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17518: LD_EXP 44
17522: PPUSH
17523: LD_STRING DEnd-JMM-Obl-1
17525: PPUSH
17526: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17530: LD_EXP 46
17534: PUSH
17535: LD_EXP 46
17539: PPUSH
17540: CALL_OW 305
17544: AND
17545: IFFALSE 17559
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17547: LD_EXP 46
17551: PPUSH
17552: LD_STRING DEnd-JMM-Lip-1
17554: PPUSH
17555: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17559: LD_EXP 40
17563: PUSH
17564: LD_EXP 40
17568: PPUSH
17569: CALL_OW 305
17573: AND
17574: PUSH
17575: LD_EXP 51
17579: AND
17580: IFFALSE 17594
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17582: LD_EXP 40
17586: PPUSH
17587: LD_STRING DEnd-Burlak-Fad-1
17589: PPUSH
17590: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17594: LD_EXP 47
17598: PUSH
17599: LD_EXP 47
17603: PPUSH
17604: CALL_OW 305
17608: AND
17609: IFFALSE 17623
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17611: LD_EXP 47
17615: PPUSH
17616: LD_STRING DEnd-Burlak-Ptr-1
17618: PPUSH
17619: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17623: LD_EXP 49
17627: PUSH
17628: LD_EXP 49
17632: PPUSH
17633: CALL_OW 305
17637: AND
17638: IFFALSE 17652
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17640: LD_EXP 49
17644: PPUSH
17645: LD_STRING DEnd-Burlak-Kuz-1
17647: PPUSH
17648: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17652: LD_EXP 38
17656: PUSH
17657: LD_EXP 38
17661: PPUSH
17662: CALL_OW 305
17666: AND
17667: PUSH
17668: LD_EXP 51
17672: AND
17673: IFFALSE 17687
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17675: LD_EXP 38
17679: PPUSH
17680: LD_STRING DEnd-Burlak-Kir-1
17682: PPUSH
17683: CALL_OW 88
// if Burlak then
17687: LD_EXP 51
17691: IFFALSE 17705
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17693: LD_EXP 19
17697: PPUSH
17698: LD_STRING DEnd-Burlak-JMM-1
17700: PPUSH
17701: CALL_OW 88
// dwait ( 0 0$2 ) ;
17705: LD_INT 70
17707: PPUSH
17708: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17712: LD_EXP 56
17716: PPUSH
17717: LD_STRING DEnd-Szulc
17719: PPUSH
17720: CALL_OW 94
// dwait ( 0 0$1 ) ;
17724: LD_INT 35
17726: PPUSH
17727: CALL_OW 68
// if IsLive ( Burlak ) then
17731: LD_EXP 51
17735: PPUSH
17736: CALL_OW 300
17740: IFFALSE 17752
// med1 := 1 else
17742: LD_ADDR_VAR 0 1
17746: PUSH
17747: LD_INT 1
17749: ST_TO_ADDR
17750: GO 17761
// med1 := - 1 ;
17752: LD_ADDR_VAR 0 1
17756: PUSH
17757: LD_INT 1
17759: NEG
17760: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17761: LD_EXP 12
17765: PUSH
17766: LD_EXP 13
17770: AND
17771: PUSH
17772: LD_EXP 14
17776: AND
17777: IFFALSE 17789
// med2 := 1 else
17779: LD_ADDR_VAR 0 2
17783: PUSH
17784: LD_INT 1
17786: ST_TO_ADDR
17787: GO 17798
// med2 := - 1 ;
17789: LD_ADDR_VAR 0 2
17793: PUSH
17794: LD_INT 1
17796: NEG
17797: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17798: LD_STRING Hero
17800: PPUSH
17801: LD_INT 1
17803: PPUSH
17804: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17808: LD_STRING Artefact
17810: PPUSH
17811: LD_VAR 0 2
17815: PPUSH
17816: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17820: LD_STRING ReconcileBurlak
17822: PPUSH
17823: LD_VAR 0 1
17827: PPUSH
17828: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17832: LD_OWVAR 67
17836: PUSH
17837: LD_INT 3
17839: GREATEREQUAL
17840: PUSH
17841: LD_VAR 0 1
17845: PUSH
17846: LD_INT 1
17848: EQUAL
17849: AND
17850: PUSH
17851: LD_VAR 0 2
17855: PUSH
17856: LD_INT 1
17858: EQUAL
17859: AND
17860: IFFALSE 17872
// SetAchievementEX ( ACH_AMER , 19 ) ;
17862: LD_STRING ACH_AMER
17864: PPUSH
17865: LD_INT 19
17867: PPUSH
17868: CALL_OW 564
// GiveMedals ( MAIN ) ;
17872: LD_STRING MAIN
17874: PPUSH
17875: CALL_OW 102
// InGameOff ;
17879: CALL_OW 9
// DialogueOff ;
17883: CALL_OW 7
// music_nat := 1 ;
17887: LD_ADDR_OWVAR 71
17891: PUSH
17892: LD_INT 1
17894: ST_TO_ADDR
// music_class := 4 ;
17895: LD_ADDR_OWVAR 72
17899: PUSH
17900: LD_INT 4
17902: ST_TO_ADDR
// YouWin ;
17903: CALL_OW 103
// end ; end_of_file
17907: PPOPN 2
17909: END
// export function InitNature ; begin
17910: LD_INT 0
17912: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17913: LD_INT 3
17915: PPUSH
17916: LD_INT 3
17918: PPUSH
17919: LD_INT 2
17921: PPUSH
17922: LD_INT 1
17924: PPUSH
17925: LD_INT 1
17927: PPUSH
17928: LD_INT 0
17930: PPUSH
17931: LD_INT 0
17933: PPUSH
17934: LD_INT 17
17936: PPUSH
17937: LD_INT 0
17939: PPUSH
17940: CALL 86039 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17944: LD_INT 2
17946: PPUSH
17947: LD_INT 1
17949: PPUSH
17950: LD_INT 1
17952: PPUSH
17953: LD_INT 1
17955: PPUSH
17956: LD_INT 1
17958: PPUSH
17959: LD_INT 0
17961: PPUSH
17962: LD_INT 0
17964: PPUSH
17965: LD_INT 18
17967: PPUSH
17968: LD_INT 0
17970: PPUSH
17971: CALL 86039 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17975: LD_INT 4
17977: PPUSH
17978: LD_INT 1
17980: PPUSH
17981: LD_INT 2
17983: PPUSH
17984: LD_INT 4
17986: PPUSH
17987: LD_INT 2
17989: PPUSH
17990: LD_INT 1
17992: PPUSH
17993: LD_INT 0
17995: PPUSH
17996: LD_INT 19
17998: PPUSH
17999: LD_INT 0
18001: PPUSH
18002: CALL 86039 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
18006: LD_INT 0
18008: PPUSH
18009: LD_INT 0
18011: PPUSH
18012: LD_INT 0
18014: PPUSH
18015: LD_INT 0
18017: PPUSH
18018: LD_INT 0
18020: PPUSH
18021: LD_INT 0
18023: PPUSH
18024: LD_INT 9
18026: PPUSH
18027: LD_INT 0
18029: PPUSH
18030: LD_INT 20
18032: PPUSH
18033: CALL 86039 0 9
// end ; end_of_file
18037: LD_VAR 0 1
18041: RET
// every 0 0$30 do var time ;
18042: GO 18044
18044: DISABLE
18045: LD_INT 0
18047: PPUSH
// begin time := 0 0$30 ;
18048: LD_ADDR_VAR 0 1
18052: PUSH
18053: LD_INT 1050
18055: ST_TO_ADDR
// repeat wait ( time ) ;
18056: LD_VAR 0 1
18060: PPUSH
18061: CALL_OW 67
// if Prob ( 50 ) then
18065: LD_INT 50
18067: PPUSH
18068: CALL_OW 13
18072: IFFALSE 18101
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18074: LD_INT 1
18076: PPUSH
18077: LD_INT 5
18079: PPUSH
18080: CALL_OW 12
18084: PPUSH
18085: LD_INT 106
18087: PPUSH
18088: LD_INT 89
18090: PPUSH
18091: LD_INT 45
18093: PPUSH
18094: LD_INT 1
18096: PPUSH
18097: CALL_OW 56
// time := time + 0 0$3 ;
18101: LD_ADDR_VAR 0 1
18105: PUSH
18106: LD_VAR 0 1
18110: PUSH
18111: LD_INT 105
18113: PLUS
18114: ST_TO_ADDR
// if Prob ( 30 ) then
18115: LD_INT 30
18117: PPUSH
18118: CALL_OW 13
18122: IFFALSE 18168
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18124: LD_INT 525
18126: PPUSH
18127: LD_INT 735
18129: PPUSH
18130: CALL_OW 12
18134: PPUSH
18135: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18139: LD_INT 1
18141: PPUSH
18142: LD_INT 5
18144: PPUSH
18145: CALL_OW 12
18149: PPUSH
18150: LD_INT 21
18152: PPUSH
18153: LD_INT 26
18155: PPUSH
18156: LD_INT 12
18158: PPUSH
18159: LD_INT 1
18161: PPUSH
18162: CALL_OW 56
// end else
18166: GO 18204
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18168: LD_INT 700
18170: PPUSH
18171: LD_INT 1225
18173: PPUSH
18174: CALL_OW 12
18178: PPUSH
18179: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18183: LD_INT 1
18185: PPUSH
18186: LD_INT 5
18188: PPUSH
18189: CALL_OW 12
18193: PPUSH
18194: LD_INT 14
18196: PPUSH
18197: LD_INT 1
18199: PPUSH
18200: CALL_OW 55
// end ; if Prob ( 50 ) then
18204: LD_INT 50
18206: PPUSH
18207: CALL_OW 13
18211: IFFALSE 18257
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18213: LD_INT 700
18215: PPUSH
18216: LD_INT 1050
18218: PPUSH
18219: CALL_OW 12
18223: PPUSH
18224: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18228: LD_INT 1
18230: PPUSH
18231: LD_INT 5
18233: PPUSH
18234: CALL_OW 12
18238: PPUSH
18239: LD_INT 181
18241: PPUSH
18242: LD_INT 218
18244: PPUSH
18245: LD_INT 16
18247: PPUSH
18248: LD_INT 1
18250: PPUSH
18251: CALL_OW 56
// end else
18255: GO 18329
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18257: LD_INT 350
18259: PPUSH
18260: LD_INT 525
18262: PPUSH
18263: CALL_OW 12
18267: PPUSH
18268: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18272: LD_INT 1
18274: PPUSH
18275: LD_INT 5
18277: PPUSH
18278: CALL_OW 12
18282: PPUSH
18283: LD_INT 13
18285: PPUSH
18286: LD_INT 1
18288: PPUSH
18289: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18293: LD_INT 350
18295: PPUSH
18296: LD_INT 700
18298: PPUSH
18299: CALL_OW 12
18303: PPUSH
18304: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18308: LD_INT 1
18310: PPUSH
18311: LD_INT 5
18313: PPUSH
18314: CALL_OW 12
18318: PPUSH
18319: LD_INT 33
18321: PPUSH
18322: LD_INT 1
18324: PPUSH
18325: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18329: LD_INT 65
18331: PUSH
18332: LD_INT 62
18334: PUSH
18335: LD_INT 55
18337: PUSH
18338: LD_INT 50
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: LIST
18345: LIST
18346: PUSH
18347: LD_OWVAR 67
18351: ARRAY
18352: PPUSH
18353: CALL_OW 13
18357: IFFALSE 18403
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18359: LD_INT 525
18361: PPUSH
18362: LD_INT 875
18364: PPUSH
18365: CALL_OW 12
18369: PPUSH
18370: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18374: LD_INT 1
18376: PPUSH
18377: LD_INT 5
18379: PPUSH
18380: CALL_OW 12
18384: PPUSH
18385: LD_INT 294
18387: PPUSH
18388: LD_INT 211
18390: PPUSH
18391: LD_INT 30
18393: PPUSH
18394: LD_INT 1
18396: PPUSH
18397: CALL_OW 56
// end else
18401: GO 18445
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18403: LD_INT 420
18405: PPUSH
18406: LD_INT 770
18408: PPUSH
18409: CALL_OW 12
18413: PPUSH
18414: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18418: LD_INT 1
18420: PPUSH
18421: LD_INT 5
18423: PPUSH
18424: CALL_OW 12
18428: PPUSH
18429: LD_INT 294
18431: PPUSH
18432: LD_INT 211
18434: PPUSH
18435: LD_INT 30
18437: PPUSH
18438: LD_INT 1
18440: PPUSH
18441: CALL_OW 56
// end ; if time > 2 2$20 then
18445: LD_VAR 0 1
18449: PUSH
18450: LD_INT 4900
18452: GREATER
18453: IFFALSE 18463
// time := 0 0$50 ;
18455: LD_ADDR_VAR 0 1
18459: PUSH
18460: LD_INT 1750
18462: ST_TO_ADDR
// until false ;
18463: LD_INT 0
18465: IFFALSE 18056
// end ;
18467: PPOPN 1
18469: END
// every 0 0$45 trigger tick < 10 10$00 do
18470: LD_OWVAR 1
18474: PUSH
18475: LD_INT 21000
18477: LESS
18478: IFFALSE 18526
18480: GO 18482
18482: DISABLE
// begin enable ;
18483: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18484: LD_INT 350
18486: PPUSH
18487: LD_INT 700
18489: PPUSH
18490: CALL_OW 12
18494: PPUSH
18495: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18499: LD_INT 3
18501: PPUSH
18502: LD_INT 5
18504: PPUSH
18505: CALL_OW 12
18509: PPUSH
18510: LD_INT 181
18512: PPUSH
18513: LD_INT 13
18515: PPUSH
18516: LD_INT 20
18518: PPUSH
18519: LD_INT 1
18521: PPUSH
18522: CALL_OW 56
// end ; end_of_file
18526: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18527: LD_INT 0
18529: PPUSH
// SetArtifactRes ( 7 , true ) ;
18530: LD_INT 7
18532: PPUSH
18533: LD_INT 1
18535: PPUSH
18536: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18540: LD_ADDR_EXP 64
18544: PUSH
18545: EMPTY
18546: PUSH
18547: EMPTY
18548: PUSH
18549: EMPTY
18550: PUSH
18551: EMPTY
18552: LIST
18553: LIST
18554: LIST
18555: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18556: LD_ADDR_EXP 65
18560: PUSH
18561: LD_INT 1050
18563: PUSH
18564: LD_OWVAR 67
18568: MUL
18569: PUSH
18570: LD_INT 2800
18572: PUSH
18573: LD_OWVAR 67
18577: MUL
18578: PUSH
18579: LD_INT 1
18581: NEG
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: LIST
18587: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18588: LD_ADDR_EXP 66
18592: PUSH
18593: LD_INT 10
18595: PUSH
18596: LD_INT 35
18598: PUSH
18599: LD_INT 100
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18607: LD_ADDR_EXP 67
18611: PUSH
18612: LD_INT 0
18614: PUSH
18615: LD_INT 0
18617: PUSH
18618: LD_INT 0
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: LIST
18625: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18626: LD_ADDR_EXP 69
18630: PUSH
18631: LD_INT 300
18633: PUSH
18634: LD_INT 500
18636: PUSH
18637: LD_INT 800
18639: PUSH
18640: EMPTY
18641: LIST
18642: LIST
18643: LIST
18644: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18645: LD_ADDR_EXP 70
18649: PUSH
18650: LD_INT 0
18652: PUSH
18653: LD_INT 0
18655: PUSH
18656: LD_INT 0
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: LIST
18663: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18664: LD_ADDR_EXP 71
18668: PUSH
18669: LD_INT 0
18671: PUSH
18672: LD_INT 0
18674: PUSH
18675: LD_INT 0
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18683: LD_ADDR_EXP 68
18687: PUSH
18688: LD_INT 0
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 0
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: LIST
18701: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18702: LD_ADDR_EXP 72
18706: PUSH
18707: LD_INT 4
18709: PUSH
18710: LD_INT 3
18712: PUSH
18713: LD_INT 1
18715: PUSH
18716: EMPTY
18717: LIST
18718: LIST
18719: LIST
18720: PUSH
18721: LD_INT 5
18723: PUSH
18724: LD_INT 4
18726: PUSH
18727: LD_INT 2
18729: PUSH
18730: EMPTY
18731: LIST
18732: LIST
18733: LIST
18734: PUSH
18735: LD_INT 6
18737: PUSH
18738: LD_INT 3
18740: PUSH
18741: LD_INT 3
18743: PUSH
18744: EMPTY
18745: LIST
18746: LIST
18747: LIST
18748: PUSH
18749: EMPTY
18750: LIST
18751: LIST
18752: LIST
18753: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18754: LD_ADDR_EXP 73
18758: PUSH
18759: LD_INT 0
18761: PUSH
18762: LD_INT 0
18764: PUSH
18765: LD_INT 0
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: LIST
18772: ST_TO_ADDR
// end ;
18773: LD_VAR 0 1
18777: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18778: LD_INT 24
18780: PPUSH
18781: LD_INT 7
18783: PPUSH
18784: CALL_OW 321
18788: PUSH
18789: LD_INT 2
18791: EQUAL
18792: IFFALSE 19718
18794: GO 18796
18796: DISABLE
18797: LD_INT 0
18799: PPUSH
18800: PPUSH
18801: PPUSH
18802: PPUSH
18803: PPUSH
// begin enable ;
18804: ENABLE
// for i = 1 to 3 do
18805: LD_ADDR_VAR 0 1
18809: PUSH
18810: DOUBLE
18811: LD_INT 1
18813: DEC
18814: ST_TO_ADDR
18815: LD_INT 3
18817: PUSH
18818: FOR_TO
18819: IFFALSE 19716
// begin pos := FindArtifact ( i + 2 ) ;
18821: LD_ADDR_VAR 0 2
18825: PUSH
18826: LD_VAR 0 1
18830: PUSH
18831: LD_INT 2
18833: PLUS
18834: PPUSH
18835: CALL_OW 469
18839: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18840: LD_ADDR_EXP 64
18844: PUSH
18845: LD_EXP 64
18849: PPUSH
18850: LD_VAR 0 1
18854: PPUSH
18855: LD_VAR 0 2
18859: PPUSH
18860: CALL_OW 1
18864: ST_TO_ADDR
// if pos then
18865: LD_VAR 0 2
18869: IFFALSE 19577
// begin case i of 1 :
18871: LD_VAR 0 1
18875: PUSH
18876: LD_INT 1
18878: DOUBLE
18879: EQUAL
18880: IFTRUE 18884
18882: GO 18961
18884: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18885: LD_ADDR_VAR 0 4
18889: PUSH
18890: LD_INT 22
18892: PUSH
18893: LD_INT 7
18895: PUSH
18896: EMPTY
18897: LIST
18898: LIST
18899: PUSH
18900: LD_INT 23
18902: PUSH
18903: LD_INT 1
18905: PUSH
18906: EMPTY
18907: LIST
18908: LIST
18909: PUSH
18910: LD_INT 2
18912: PUSH
18913: LD_INT 30
18915: PUSH
18916: LD_INT 8
18918: PUSH
18919: EMPTY
18920: LIST
18921: LIST
18922: PUSH
18923: LD_INT 30
18925: PUSH
18926: LD_INT 7
18928: PUSH
18929: EMPTY
18930: LIST
18931: LIST
18932: PUSH
18933: LD_INT 30
18935: PUSH
18936: LD_INT 11
18938: PUSH
18939: EMPTY
18940: LIST
18941: LIST
18942: PUSH
18943: EMPTY
18944: LIST
18945: LIST
18946: LIST
18947: LIST
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: LIST
18953: PPUSH
18954: CALL_OW 69
18958: ST_TO_ADDR
18959: GO 19069
18961: LD_INT 2
18963: DOUBLE
18964: EQUAL
18965: IFTRUE 18969
18967: GO 19046
18969: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18970: LD_ADDR_VAR 0 4
18974: PUSH
18975: LD_INT 22
18977: PUSH
18978: LD_INT 7
18980: PUSH
18981: EMPTY
18982: LIST
18983: LIST
18984: PUSH
18985: LD_INT 23
18987: PUSH
18988: LD_INT 3
18990: PUSH
18991: EMPTY
18992: LIST
18993: LIST
18994: PUSH
18995: LD_INT 2
18997: PUSH
18998: LD_INT 30
19000: PUSH
19001: LD_INT 8
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: PUSH
19008: LD_INT 30
19010: PUSH
19011: LD_INT 7
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: PUSH
19018: LD_INT 30
19020: PUSH
19021: LD_INT 11
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: EMPTY
19029: LIST
19030: LIST
19031: LIST
19032: LIST
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: LIST
19038: PPUSH
19039: CALL_OW 69
19043: ST_TO_ADDR
19044: GO 19069
19046: LD_INT 3
19048: DOUBLE
19049: EQUAL
19050: IFTRUE 19054
19052: GO 19068
19054: POP
// labs := [ alien ] ; end ;
19055: LD_ADDR_VAR 0 4
19059: PUSH
19060: LD_INT 1
19062: PUSH
19063: EMPTY
19064: LIST
19065: ST_TO_ADDR
19066: GO 19069
19068: POP
// if not labs then
19069: LD_VAR 0 4
19073: NOT
19074: IFFALSE 19078
// continue ;
19076: GO 18818
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19078: LD_ADDR_VAR 0 5
19082: PUSH
19083: LD_VAR 0 4
19087: PPUSH
19088: LD_EXP 64
19092: PUSH
19093: LD_VAR 0 1
19097: ARRAY
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: LD_EXP 64
19107: PUSH
19108: LD_VAR 0 1
19112: ARRAY
19113: PUSH
19114: LD_INT 2
19116: ARRAY
19117: PPUSH
19118: CALL_OW 73
19122: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19123: LD_VAR 0 5
19127: NOT
19128: PUSH
19129: LD_VAR 0 5
19133: PUSH
19134: LD_EXP 71
19138: PUSH
19139: LD_VAR 0 1
19143: ARRAY
19144: NONEQUAL
19145: OR
19146: IFFALSE 19251
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19148: LD_INT 7
19150: PPUSH
19151: LD_EXP 72
19155: PUSH
19156: LD_VAR 0 1
19160: ARRAY
19161: PUSH
19162: LD_INT 3
19164: ARRAY
19165: PPUSH
19166: LD_INT 0
19168: PPUSH
19169: LD_EXP 71
19173: PUSH
19174: LD_VAR 0 1
19178: ARRAY
19179: PPUSH
19180: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19184: LD_INT 7
19186: PPUSH
19187: LD_EXP 72
19191: PUSH
19192: LD_VAR 0 1
19196: ARRAY
19197: PUSH
19198: LD_INT 1
19200: ARRAY
19201: PPUSH
19202: LD_INT 0
19204: PPUSH
19205: LD_EXP 71
19209: PUSH
19210: LD_VAR 0 1
19214: ARRAY
19215: PPUSH
19216: CALL_OW 468
// if nearestLab then
19220: LD_VAR 0 5
19224: IFFALSE 19251
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19226: LD_ADDR_EXP 71
19230: PUSH
19231: LD_EXP 71
19235: PPUSH
19236: LD_VAR 0 1
19240: PPUSH
19241: LD_VAR 0 5
19245: PPUSH
19246: CALL_OW 1
19250: ST_TO_ADDR
// end ; if not nearestLab then
19251: LD_VAR 0 5
19255: NOT
19256: IFFALSE 19260
// continue ;
19258: GO 18818
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19260: LD_VAR 0 5
19264: PPUSH
19265: LD_EXP 64
19269: PUSH
19270: LD_VAR 0 1
19274: ARRAY
19275: PUSH
19276: LD_INT 1
19278: ARRAY
19279: PPUSH
19280: LD_EXP 64
19284: PUSH
19285: LD_VAR 0 1
19289: ARRAY
19290: PUSH
19291: LD_INT 2
19293: ARRAY
19294: PPUSH
19295: CALL_OW 297
19299: PUSH
19300: LD_INT 8
19302: LESS
19303: IFFALSE 19500
// begin if not artifactsResearched [ i ] then
19305: LD_EXP 67
19309: PUSH
19310: LD_VAR 0 1
19314: ARRAY
19315: NOT
19316: IFFALSE 19397
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19318: LD_VAR 0 5
19322: PPUSH
19323: CALL_OW 461
19327: PUSH
19328: LD_INT 2
19330: EQUAL
19331: IFFALSE 19365
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19333: LD_INT 7
19335: PPUSH
19336: LD_EXP 72
19340: PUSH
19341: LD_VAR 0 1
19345: ARRAY
19346: PUSH
19347: LD_INT 3
19349: ARRAY
19350: PPUSH
19351: LD_INT 2
19353: PPUSH
19354: LD_VAR 0 5
19358: PPUSH
19359: CALL_OW 468
19363: GO 19395
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19365: LD_INT 7
19367: PPUSH
19368: LD_EXP 72
19372: PUSH
19373: LD_VAR 0 1
19377: ARRAY
19378: PUSH
19379: LD_INT 3
19381: ARRAY
19382: PPUSH
19383: LD_INT 1
19385: PPUSH
19386: LD_VAR 0 5
19390: PPUSH
19391: CALL_OW 468
// end else
19395: GO 19498
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19397: LD_VAR 0 5
19401: PPUSH
19402: CALL_OW 461
19406: PUSH
19407: LD_INT 2
19409: EQUAL
19410: PUSH
19411: LD_EXP 73
19415: PUSH
19416: LD_VAR 0 1
19420: ARRAY
19421: AND
19422: IFFALSE 19468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19424: LD_INT 7
19426: PPUSH
19427: LD_EXP 72
19431: PUSH
19432: LD_VAR 0 1
19436: ARRAY
19437: PUSH
19438: LD_INT 1
19440: ARRAY
19441: PPUSH
19442: LD_EXP 72
19446: PUSH
19447: LD_VAR 0 1
19451: ARRAY
19452: PUSH
19453: LD_INT 2
19455: ARRAY
19456: PPUSH
19457: LD_VAR 0 5
19461: PPUSH
19462: CALL_OW 468
19466: GO 19498
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19468: LD_INT 7
19470: PPUSH
19471: LD_EXP 72
19475: PUSH
19476: LD_VAR 0 1
19480: ARRAY
19481: PUSH
19482: LD_INT 1
19484: ARRAY
19485: PPUSH
19486: LD_INT 1
19488: PPUSH
19489: LD_VAR 0 5
19493: PPUSH
19494: CALL_OW 468
// end else
19498: GO 19575
// begin if not artifactsResearched [ i ] then
19500: LD_EXP 67
19504: PUSH
19505: LD_VAR 0 1
19509: ARRAY
19510: NOT
19511: IFFALSE 19545
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19513: LD_INT 7
19515: PPUSH
19516: LD_EXP 72
19520: PUSH
19521: LD_VAR 0 1
19525: ARRAY
19526: PUSH
19527: LD_INT 3
19529: ARRAY
19530: PPUSH
19531: LD_INT 0
19533: PPUSH
19534: LD_VAR 0 5
19538: PPUSH
19539: CALL_OW 468
19543: GO 19575
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19545: LD_INT 7
19547: PPUSH
19548: LD_EXP 72
19552: PUSH
19553: LD_VAR 0 1
19557: ARRAY
19558: PUSH
19559: LD_INT 1
19561: ARRAY
19562: PPUSH
19563: LD_INT 0
19565: PPUSH
19566: LD_VAR 0 5
19570: PPUSH
19571: CALL_OW 468
// end ; end else
19575: GO 19714
// begin if not artifactsLabs [ i ] then
19577: LD_EXP 71
19581: PUSH
19582: LD_VAR 0 1
19586: ARRAY
19587: NOT
19588: IFFALSE 19592
// continue ;
19590: GO 18818
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19592: LD_INT 7
19594: PPUSH
19595: LD_EXP 72
19599: PUSH
19600: LD_VAR 0 1
19604: ARRAY
19605: PUSH
19606: LD_INT 3
19608: ARRAY
19609: PPUSH
19610: LD_INT 0
19612: PPUSH
19613: LD_EXP 71
19617: PUSH
19618: LD_VAR 0 1
19622: ARRAY
19623: PPUSH
19624: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19628: LD_INT 7
19630: PPUSH
19631: LD_EXP 72
19635: PUSH
19636: LD_VAR 0 1
19640: ARRAY
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: LD_INT 0
19648: PPUSH
19649: LD_EXP 71
19653: PUSH
19654: LD_VAR 0 1
19658: ARRAY
19659: PPUSH
19660: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19664: LD_EXP 68
19668: PUSH
19669: LD_VAR 0 1
19673: ARRAY
19674: IFFALSE 19714
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19676: LD_ADDR_EXP 68
19680: PUSH
19681: LD_EXP 68
19685: PPUSH
19686: LD_VAR 0 1
19690: PPUSH
19691: LD_INT 0
19693: PPUSH
19694: CALL_OW 1
19698: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19699: LD_EXP 71
19703: PUSH
19704: LD_VAR 0 1
19708: ARRAY
19709: PPUSH
19710: CALL_OW 127
// end ; end ; end ;
19714: GO 18818
19716: POP
19717: POP
// end ;
19718: PPOPN 5
19720: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19721: LD_INT 0
19723: PPUSH
19724: PPUSH
19725: PPUSH
19726: PPUSH
19727: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19728: LD_VAR 0 2
19732: PUSH
19733: LD_EXP 72
19737: PUSH
19738: LD_INT 1
19740: ARRAY
19741: PUSH
19742: LD_INT 3
19744: ARRAY
19745: EQUAL
19746: IFFALSE 19869
// begin lab := artifactsLabs [ 1 ] ;
19748: LD_ADDR_VAR 0 6
19752: PUSH
19753: LD_EXP 71
19757: PUSH
19758: LD_INT 1
19760: ARRAY
19761: ST_TO_ADDR
// if not lab then
19762: LD_VAR 0 6
19766: NOT
19767: IFFALSE 19771
// exit ;
19769: GO 20849
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19771: LD_VAR 0 6
19775: PPUSH
19776: LD_EXP 69
19780: PUSH
19781: LD_INT 1
19783: ARRAY
19784: PPUSH
19785: LD_INT 1
19787: PPUSH
19788: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19792: LD_EXP 70
19796: PUSH
19797: LD_INT 1
19799: ARRAY
19800: IFFALSE 19820
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19802: LD_VAR 0 6
19806: PPUSH
19807: LD_EXP 70
19811: PUSH
19812: LD_INT 1
19814: ARRAY
19815: PPUSH
19816: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19820: LD_ADDR_EXP 68
19824: PUSH
19825: LD_EXP 68
19829: PPUSH
19830: LD_INT 1
19832: PPUSH
19833: LD_INT 1
19835: PPUSH
19836: CALL_OW 1
19840: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19841: LD_INT 7
19843: PPUSH
19844: LD_EXP 72
19848: PUSH
19849: LD_INT 1
19851: ARRAY
19852: PUSH
19853: LD_INT 3
19855: ARRAY
19856: PPUSH
19857: LD_INT 0
19859: PPUSH
19860: LD_VAR 0 6
19864: PPUSH
19865: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19869: LD_VAR 0 2
19873: PUSH
19874: LD_EXP 72
19878: PUSH
19879: LD_INT 2
19881: ARRAY
19882: PUSH
19883: LD_INT 3
19885: ARRAY
19886: EQUAL
19887: IFFALSE 20010
// begin lab := artifactsLabs [ 2 ] ;
19889: LD_ADDR_VAR 0 6
19893: PUSH
19894: LD_EXP 71
19898: PUSH
19899: LD_INT 2
19901: ARRAY
19902: ST_TO_ADDR
// if not lab then
19903: LD_VAR 0 6
19907: NOT
19908: IFFALSE 19912
// exit ;
19910: GO 20849
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19912: LD_VAR 0 6
19916: PPUSH
19917: LD_EXP 69
19921: PUSH
19922: LD_INT 2
19924: ARRAY
19925: PPUSH
19926: LD_INT 1
19928: PPUSH
19929: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19933: LD_EXP 70
19937: PUSH
19938: LD_INT 2
19940: ARRAY
19941: IFFALSE 19961
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19943: LD_VAR 0 6
19947: PPUSH
19948: LD_EXP 70
19952: PUSH
19953: LD_INT 2
19955: ARRAY
19956: PPUSH
19957: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19961: LD_ADDR_EXP 68
19965: PUSH
19966: LD_EXP 68
19970: PPUSH
19971: LD_INT 2
19973: PPUSH
19974: LD_INT 1
19976: PPUSH
19977: CALL_OW 1
19981: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19982: LD_INT 7
19984: PPUSH
19985: LD_EXP 72
19989: PUSH
19990: LD_INT 2
19992: ARRAY
19993: PUSH
19994: LD_INT 3
19996: ARRAY
19997: PPUSH
19998: LD_INT 0
20000: PPUSH
20001: LD_VAR 0 6
20005: PPUSH
20006: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20010: LD_VAR 0 2
20014: PUSH
20015: LD_EXP 72
20019: PUSH
20020: LD_INT 3
20022: ARRAY
20023: PUSH
20024: LD_INT 3
20026: ARRAY
20027: EQUAL
20028: IFFALSE 20151
// begin lab := artifactsLabs [ 3 ] ;
20030: LD_ADDR_VAR 0 6
20034: PUSH
20035: LD_EXP 71
20039: PUSH
20040: LD_INT 3
20042: ARRAY
20043: ST_TO_ADDR
// if not lab then
20044: LD_VAR 0 6
20048: NOT
20049: IFFALSE 20053
// exit ;
20051: GO 20849
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20053: LD_VAR 0 6
20057: PPUSH
20058: LD_EXP 69
20062: PUSH
20063: LD_INT 3
20065: ARRAY
20066: PPUSH
20067: LD_INT 1
20069: PPUSH
20070: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20074: LD_EXP 70
20078: PUSH
20079: LD_INT 3
20081: ARRAY
20082: IFFALSE 20102
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20084: LD_VAR 0 6
20088: PPUSH
20089: LD_EXP 70
20093: PUSH
20094: LD_INT 3
20096: ARRAY
20097: PPUSH
20098: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20102: LD_ADDR_EXP 68
20106: PUSH
20107: LD_EXP 68
20111: PPUSH
20112: LD_INT 3
20114: PPUSH
20115: LD_INT 1
20117: PPUSH
20118: CALL_OW 1
20122: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20123: LD_INT 7
20125: PPUSH
20126: LD_EXP 72
20130: PUSH
20131: LD_INT 3
20133: ARRAY
20134: PUSH
20135: LD_INT 3
20137: ARRAY
20138: PPUSH
20139: LD_INT 0
20141: PPUSH
20142: LD_VAR 0 6
20146: PPUSH
20147: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20151: LD_VAR 0 2
20155: PUSH
20156: LD_EXP 72
20160: PUSH
20161: LD_INT 1
20163: ARRAY
20164: PUSH
20165: LD_INT 1
20167: ARRAY
20168: EQUAL
20169: IFFALSE 20327
// begin lab := artifactsLabs [ 1 ] ;
20171: LD_ADDR_VAR 0 6
20175: PUSH
20176: LD_EXP 71
20180: PUSH
20181: LD_INT 1
20183: ARRAY
20184: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20185: LD_VAR 0 6
20189: PPUSH
20190: CALL_OW 274
20194: PPUSH
20195: CALL 89587 0 1
20199: PUSH
20200: LD_INT 3
20202: ARRAY
20203: PUSH
20204: LD_EXP 66
20208: PUSH
20209: LD_INT 1
20211: ARRAY
20212: LESS
20213: IFFALSE 20227
// begin HintSpec ( ArtifactCost , 2 ) ;
20215: LD_STRING ArtifactCost
20217: PPUSH
20218: LD_INT 2
20220: PPUSH
20221: CALL_OW 338
// exit ;
20225: GO 20849
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20227: LD_ADDR_EXP 73
20231: PUSH
20232: LD_EXP 73
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: LD_INT 0
20242: PPUSH
20243: CALL_OW 1
20247: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20248: LD_VAR 0 3
20252: PPUSH
20253: LD_VAR 0 4
20257: PPUSH
20258: LD_INT 7
20260: PPUSH
20261: LD_INT 12
20263: NEG
20264: PPUSH
20265: CALL_OW 330
// wait ( 0 0$30 ) ;
20269: LD_INT 1050
20271: PPUSH
20272: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20276: LD_VAR 0 3
20280: PPUSH
20281: LD_VAR 0 4
20285: PPUSH
20286: LD_INT 7
20288: PPUSH
20289: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20293: LD_EXP 65
20297: PUSH
20298: LD_INT 1
20300: ARRAY
20301: PPUSH
20302: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20306: LD_ADDR_EXP 73
20310: PUSH
20311: LD_EXP 73
20315: PPUSH
20316: LD_INT 1
20318: PPUSH
20319: LD_INT 1
20321: PPUSH
20322: CALL_OW 1
20326: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20327: LD_VAR 0 2
20331: PUSH
20332: LD_EXP 72
20336: PUSH
20337: LD_INT 2
20339: ARRAY
20340: PUSH
20341: LD_INT 1
20343: ARRAY
20344: EQUAL
20345: IFFALSE 20582
// begin lab := artifactsLabs [ 2 ] ;
20347: LD_ADDR_VAR 0 6
20351: PUSH
20352: LD_EXP 71
20356: PUSH
20357: LD_INT 2
20359: ARRAY
20360: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20361: LD_VAR 0 3
20365: PUSH
20366: LD_INT 81
20368: PUSH
20369: LD_INT 7
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PUSH
20376: LD_INT 2
20378: PUSH
20379: LD_INT 32
20381: PUSH
20382: LD_INT 3
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: PUSH
20389: LD_INT 30
20391: PUSH
20392: LD_INT 28
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: PUSH
20399: LD_INT 30
20401: PUSH
20402: LD_INT 30
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: LD_INT 35
20411: PUSH
20412: LD_INT 49
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: PUSH
20419: LD_INT 34
20421: PUSH
20422: LD_INT 49
20424: PUSH
20425: EMPTY
20426: LIST
20427: LIST
20428: PUSH
20429: LD_INT 30
20431: PUSH
20432: LD_INT 21
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: PPUSH
20452: CALL_OW 69
20456: IN
20457: NOT
20458: IFFALSE 20462
// exit ;
20460: GO 20849
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20462: LD_VAR 0 6
20466: PPUSH
20467: CALL_OW 274
20471: PPUSH
20472: CALL 89587 0 1
20476: PUSH
20477: LD_INT 3
20479: ARRAY
20480: PUSH
20481: LD_EXP 66
20485: PUSH
20486: LD_INT 2
20488: ARRAY
20489: LESS
20490: IFFALSE 20504
// begin HintSpec ( ArtifactCost , 2 ) ;
20492: LD_STRING ArtifactCost
20494: PPUSH
20495: LD_INT 2
20497: PPUSH
20498: CALL_OW 338
// exit ;
20502: GO 20849
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20504: LD_ADDR_EXP 73
20508: PUSH
20509: LD_EXP 73
20513: PPUSH
20514: LD_INT 2
20516: PPUSH
20517: LD_INT 0
20519: PPUSH
20520: CALL_OW 1
20524: ST_TO_ADDR
// KillUnit ( x ) ;
20525: LD_VAR 0 3
20529: PPUSH
20530: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20534: LD_ADDR_EXP 16
20538: PUSH
20539: LD_EXP 16
20543: PUSH
20544: LD_INT 1
20546: PLUS
20547: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20548: LD_EXP 65
20552: PUSH
20553: LD_INT 2
20555: ARRAY
20556: PPUSH
20557: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20561: LD_ADDR_EXP 73
20565: PUSH
20566: LD_EXP 73
20570: PPUSH
20571: LD_INT 2
20573: PPUSH
20574: LD_INT 1
20576: PPUSH
20577: CALL_OW 1
20581: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20582: LD_VAR 0 2
20586: PUSH
20587: LD_EXP 72
20591: PUSH
20592: LD_INT 3
20594: ARRAY
20595: PUSH
20596: LD_INT 1
20598: ARRAY
20599: EQUAL
20600: IFFALSE 20849
// begin lab := artifactsLabs [ 3 ] ;
20602: LD_ADDR_VAR 0 6
20606: PUSH
20607: LD_EXP 71
20611: PUSH
20612: LD_INT 3
20614: ARRAY
20615: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20616: LD_VAR 0 6
20620: PPUSH
20621: CALL_OW 274
20625: PPUSH
20626: CALL 89587 0 1
20630: PUSH
20631: LD_INT 3
20633: ARRAY
20634: PUSH
20635: LD_EXP 66
20639: PUSH
20640: LD_INT 3
20642: ARRAY
20643: LESS
20644: IFFALSE 20658
// begin HintSpec ( ArtifactCost , 2 ) ;
20646: LD_STRING ArtifactCost
20648: PPUSH
20649: LD_INT 2
20651: PPUSH
20652: CALL_OW 338
// exit ;
20656: GO 20849
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20658: LD_INT 37
20660: PPUSH
20661: LD_INT 1
20663: PPUSH
20664: CALL_OW 424
// time := 0 0$30 ;
20668: LD_ADDR_VAR 0 7
20672: PUSH
20673: LD_INT 1050
20675: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20676: LD_ADDR_EXP 73
20680: PUSH
20681: LD_EXP 73
20685: PPUSH
20686: LD_INT 3
20688: PPUSH
20689: LD_INT 0
20691: PPUSH
20692: CALL_OW 1
20696: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20697: LD_ADDR_OWVAR 47
20701: PUSH
20702: LD_STRING #Am15a-1
20704: PUSH
20705: LD_VAR 0 7
20709: PUSH
20710: EMPTY
20711: LIST
20712: LIST
20713: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20714: LD_INT 35
20716: PPUSH
20717: CALL_OW 67
// time := time - 0 0$1 ;
20721: LD_ADDR_VAR 0 7
20725: PUSH
20726: LD_VAR 0 7
20730: PUSH
20731: LD_INT 35
20733: MINUS
20734: ST_TO_ADDR
// until time = 0 0$00 ;
20735: LD_VAR 0 7
20739: PUSH
20740: LD_INT 0
20742: EQUAL
20743: IFFALSE 20697
// display_strings :=  ;
20745: LD_ADDR_OWVAR 47
20749: PUSH
20750: LD_STRING 
20752: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20753: LD_INT 37
20755: PPUSH
20756: LD_INT 0
20758: PPUSH
20759: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20763: LD_ADDR_VAR 0 8
20767: PUSH
20768: LD_INT 37
20770: PPUSH
20771: LD_INT 3
20773: PUSH
20774: LD_INT 21
20776: PUSH
20777: LD_INT 3
20779: PUSH
20780: EMPTY
20781: LIST
20782: LIST
20783: PUSH
20784: EMPTY
20785: LIST
20786: LIST
20787: PPUSH
20788: CALL_OW 70
20792: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20793: LD_VAR 0 3
20797: PPUSH
20798: LD_VAR 0 4
20802: PPUSH
20803: CALL_OW 84
// for un in list do
20807: LD_ADDR_VAR 0 9
20811: PUSH
20812: LD_VAR 0 8
20816: PUSH
20817: FOR_IN
20818: IFFALSE 20847
// TeleportUnit ( un , x , y , 12 , true ) ;
20820: LD_VAR 0 9
20824: PPUSH
20825: LD_VAR 0 3
20829: PPUSH
20830: LD_VAR 0 4
20834: PPUSH
20835: LD_INT 12
20837: PPUSH
20838: LD_INT 1
20840: PPUSH
20841: CALL_OW 483
20845: GO 20817
20847: POP
20848: POP
// end ; end ;
20849: PPOPN 9
20851: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20852: LD_INT 0
20854: PPUSH
20855: PPUSH
// begin labNum := 0 ;
20856: LD_ADDR_VAR 0 4
20860: PUSH
20861: LD_INT 0
20863: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20864: LD_ADDR_VAR 0 3
20868: PUSH
20869: DOUBLE
20870: LD_INT 1
20872: DEC
20873: ST_TO_ADDR
20874: LD_EXP 71
20878: PUSH
20879: FOR_TO
20880: IFFALSE 20914
// if artifactsLabs [ i ] = lab then
20882: LD_EXP 71
20886: PUSH
20887: LD_VAR 0 3
20891: ARRAY
20892: PUSH
20893: LD_VAR 0 1
20897: EQUAL
20898: IFFALSE 20912
// begin labNum := i ;
20900: LD_ADDR_VAR 0 4
20904: PUSH
20905: LD_VAR 0 3
20909: ST_TO_ADDR
// break ;
20910: GO 20914
// end ;
20912: GO 20879
20914: POP
20915: POP
// if not labNum then
20916: LD_VAR 0 4
20920: NOT
20921: IFFALSE 20925
// exit ;
20923: GO 21003
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20925: LD_INT 7
20927: PPUSH
20928: LD_EXP 72
20932: PUSH
20933: LD_VAR 0 4
20937: ARRAY
20938: PUSH
20939: LD_INT 3
20941: ARRAY
20942: PPUSH
20943: LD_INT 2
20945: PPUSH
20946: LD_VAR 0 1
20950: PPUSH
20951: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20955: LD_ADDR_EXP 70
20959: PUSH
20960: LD_EXP 70
20964: PPUSH
20965: LD_VAR 0 4
20969: PPUSH
20970: LD_VAR 0 2
20974: PPUSH
20975: CALL_OW 1
20979: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20980: LD_ADDR_EXP 68
20984: PUSH
20985: LD_EXP 68
20989: PPUSH
20990: LD_VAR 0 4
20994: PPUSH
20995: LD_INT 0
20997: PPUSH
20998: CALL_OW 1
21002: ST_TO_ADDR
// end ;
21003: PPOPN 4
21005: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
21006: LD_INT 0
21008: PPUSH
21009: PPUSH
// begin labNum := 0 ;
21010: LD_ADDR_VAR 0 3
21014: PUSH
21015: LD_INT 0
21017: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21018: LD_ADDR_VAR 0 2
21022: PUSH
21023: DOUBLE
21024: LD_INT 1
21026: DEC
21027: ST_TO_ADDR
21028: LD_EXP 71
21032: PUSH
21033: FOR_TO
21034: IFFALSE 21068
// if artifactsLabs [ i ] = lab then
21036: LD_EXP 71
21040: PUSH
21041: LD_VAR 0 2
21045: ARRAY
21046: PUSH
21047: LD_VAR 0 1
21051: EQUAL
21052: IFFALSE 21066
// begin labNum := i ;
21054: LD_ADDR_VAR 0 3
21058: PUSH
21059: LD_VAR 0 2
21063: ST_TO_ADDR
// break ;
21064: GO 21068
// end ;
21066: GO 21033
21068: POP
21069: POP
// if not labNum then
21070: LD_VAR 0 3
21074: NOT
21075: IFFALSE 21079
// exit ;
21077: GO 21241
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21079: LD_INT 7
21081: PPUSH
21082: LD_EXP 72
21086: PUSH
21087: LD_VAR 0 3
21091: ARRAY
21092: PUSH
21093: LD_INT 3
21095: ARRAY
21096: PPUSH
21097: LD_INT 0
21099: PPUSH
21100: LD_VAR 0 1
21104: PPUSH
21105: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21109: LD_ADDR_EXP 67
21113: PUSH
21114: LD_EXP 67
21118: PPUSH
21119: LD_VAR 0 3
21123: PPUSH
21124: LD_INT 1
21126: PPUSH
21127: CALL_OW 1
21131: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21132: LD_ADDR_EXP 73
21136: PUSH
21137: LD_EXP 73
21141: PPUSH
21142: LD_VAR 0 3
21146: PPUSH
21147: LD_INT 1
21149: PPUSH
21150: CALL_OW 1
21154: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21155: LD_ADDR_EXP 68
21159: PUSH
21160: LD_EXP 68
21164: PPUSH
21165: LD_VAR 0 3
21169: PPUSH
21170: LD_INT 0
21172: PPUSH
21173: CALL_OW 1
21177: ST_TO_ADDR
// case labNum of 1 :
21178: LD_VAR 0 3
21182: PUSH
21183: LD_INT 1
21185: DOUBLE
21186: EQUAL
21187: IFTRUE 21191
21189: GO 21202
21191: POP
// artifactIResearched := true ; 2 :
21192: LD_ADDR_EXP 12
21196: PUSH
21197: LD_INT 1
21199: ST_TO_ADDR
21200: GO 21241
21202: LD_INT 2
21204: DOUBLE
21205: EQUAL
21206: IFTRUE 21210
21208: GO 21221
21210: POP
// artifactIIResearched := true ; 3 :
21211: LD_ADDR_EXP 13
21215: PUSH
21216: LD_INT 1
21218: ST_TO_ADDR
21219: GO 21241
21221: LD_INT 3
21223: DOUBLE
21224: EQUAL
21225: IFTRUE 21229
21227: GO 21240
21229: POP
// artifactIIIResearched := true ; end ;
21230: LD_ADDR_EXP 14
21234: PUSH
21235: LD_INT 1
21237: ST_TO_ADDR
21238: GO 21241
21240: POP
// end ; end_of_file
21241: PPOPN 3
21243: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21244: LD_INT 0
21246: PPUSH
21247: PPUSH
// skirmish := false ;
21248: LD_ADDR_EXP 74
21252: PUSH
21253: LD_INT 0
21255: ST_TO_ADDR
// debug_mc := false ;
21256: LD_ADDR_EXP 75
21260: PUSH
21261: LD_INT 0
21263: ST_TO_ADDR
// mc_bases := [ ] ;
21264: LD_ADDR_EXP 76
21268: PUSH
21269: EMPTY
21270: ST_TO_ADDR
// mc_sides := [ ] ;
21271: LD_ADDR_EXP 102
21275: PUSH
21276: EMPTY
21277: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21278: LD_ADDR_EXP 77
21282: PUSH
21283: EMPTY
21284: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21285: LD_ADDR_EXP 78
21289: PUSH
21290: EMPTY
21291: ST_TO_ADDR
// mc_need_heal := [ ] ;
21292: LD_ADDR_EXP 79
21296: PUSH
21297: EMPTY
21298: ST_TO_ADDR
// mc_healers := [ ] ;
21299: LD_ADDR_EXP 80
21303: PUSH
21304: EMPTY
21305: ST_TO_ADDR
// mc_build_list := [ ] ;
21306: LD_ADDR_EXP 81
21310: PUSH
21311: EMPTY
21312: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21313: LD_ADDR_EXP 108
21317: PUSH
21318: EMPTY
21319: ST_TO_ADDR
// mc_builders := [ ] ;
21320: LD_ADDR_EXP 82
21324: PUSH
21325: EMPTY
21326: ST_TO_ADDR
// mc_construct_list := [ ] ;
21327: LD_ADDR_EXP 83
21331: PUSH
21332: EMPTY
21333: ST_TO_ADDR
// mc_turret_list := [ ] ;
21334: LD_ADDR_EXP 84
21338: PUSH
21339: EMPTY
21340: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21341: LD_ADDR_EXP 85
21345: PUSH
21346: EMPTY
21347: ST_TO_ADDR
// mc_miners := [ ] ;
21348: LD_ADDR_EXP 90
21352: PUSH
21353: EMPTY
21354: ST_TO_ADDR
// mc_mines := [ ] ;
21355: LD_ADDR_EXP 89
21359: PUSH
21360: EMPTY
21361: ST_TO_ADDR
// mc_minefields := [ ] ;
21362: LD_ADDR_EXP 91
21366: PUSH
21367: EMPTY
21368: ST_TO_ADDR
// mc_crates := [ ] ;
21369: LD_ADDR_EXP 92
21373: PUSH
21374: EMPTY
21375: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21376: LD_ADDR_EXP 93
21380: PUSH
21381: EMPTY
21382: ST_TO_ADDR
// mc_crates_area := [ ] ;
21383: LD_ADDR_EXP 94
21387: PUSH
21388: EMPTY
21389: ST_TO_ADDR
// mc_vehicles := [ ] ;
21390: LD_ADDR_EXP 95
21394: PUSH
21395: EMPTY
21396: ST_TO_ADDR
// mc_attack := [ ] ;
21397: LD_ADDR_EXP 96
21401: PUSH
21402: EMPTY
21403: ST_TO_ADDR
// mc_produce := [ ] ;
21404: LD_ADDR_EXP 97
21408: PUSH
21409: EMPTY
21410: ST_TO_ADDR
// mc_defender := [ ] ;
21411: LD_ADDR_EXP 98
21415: PUSH
21416: EMPTY
21417: ST_TO_ADDR
// mc_parking := [ ] ;
21418: LD_ADDR_EXP 100
21422: PUSH
21423: EMPTY
21424: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21425: LD_ADDR_EXP 86
21429: PUSH
21430: EMPTY
21431: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21432: LD_ADDR_EXP 88
21436: PUSH
21437: EMPTY
21438: ST_TO_ADDR
// mc_scan := [ ] ;
21439: LD_ADDR_EXP 99
21443: PUSH
21444: EMPTY
21445: ST_TO_ADDR
// mc_scan_area := [ ] ;
21446: LD_ADDR_EXP 101
21450: PUSH
21451: EMPTY
21452: ST_TO_ADDR
// mc_tech := [ ] ;
21453: LD_ADDR_EXP 103
21457: PUSH
21458: EMPTY
21459: ST_TO_ADDR
// mc_class := [ ] ;
21460: LD_ADDR_EXP 117
21464: PUSH
21465: EMPTY
21466: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21467: LD_ADDR_EXP 118
21471: PUSH
21472: EMPTY
21473: ST_TO_ADDR
// mc_is_defending := [ ] ;
21474: LD_ADDR_EXP 119
21478: PUSH
21479: EMPTY
21480: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
21481: LD_ADDR_EXP 110
21485: PUSH
21486: EMPTY
21487: ST_TO_ADDR
// end ;
21488: LD_VAR 0 1
21492: RET
// export function MC_Kill ( base ) ; begin
21493: LD_INT 0
21495: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21496: LD_ADDR_EXP 76
21500: PUSH
21501: LD_EXP 76
21505: PPUSH
21506: LD_VAR 0 1
21510: PPUSH
21511: EMPTY
21512: PPUSH
21513: CALL_OW 1
21517: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21518: LD_ADDR_EXP 77
21522: PUSH
21523: LD_EXP 77
21527: PPUSH
21528: LD_VAR 0 1
21532: PPUSH
21533: EMPTY
21534: PPUSH
21535: CALL_OW 1
21539: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21540: LD_ADDR_EXP 78
21544: PUSH
21545: LD_EXP 78
21549: PPUSH
21550: LD_VAR 0 1
21554: PPUSH
21555: EMPTY
21556: PPUSH
21557: CALL_OW 1
21561: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21562: LD_ADDR_EXP 79
21566: PUSH
21567: LD_EXP 79
21571: PPUSH
21572: LD_VAR 0 1
21576: PPUSH
21577: EMPTY
21578: PPUSH
21579: CALL_OW 1
21583: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21584: LD_ADDR_EXP 80
21588: PUSH
21589: LD_EXP 80
21593: PPUSH
21594: LD_VAR 0 1
21598: PPUSH
21599: EMPTY
21600: PPUSH
21601: CALL_OW 1
21605: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21606: LD_ADDR_EXP 81
21610: PUSH
21611: LD_EXP 81
21615: PPUSH
21616: LD_VAR 0 1
21620: PPUSH
21621: EMPTY
21622: PPUSH
21623: CALL_OW 1
21627: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21628: LD_ADDR_EXP 82
21632: PUSH
21633: LD_EXP 82
21637: PPUSH
21638: LD_VAR 0 1
21642: PPUSH
21643: EMPTY
21644: PPUSH
21645: CALL_OW 1
21649: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21650: LD_ADDR_EXP 83
21654: PUSH
21655: LD_EXP 83
21659: PPUSH
21660: LD_VAR 0 1
21664: PPUSH
21665: EMPTY
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21672: LD_ADDR_EXP 84
21676: PUSH
21677: LD_EXP 84
21681: PPUSH
21682: LD_VAR 0 1
21686: PPUSH
21687: EMPTY
21688: PPUSH
21689: CALL_OW 1
21693: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21694: LD_ADDR_EXP 85
21698: PUSH
21699: LD_EXP 85
21703: PPUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: EMPTY
21710: PPUSH
21711: CALL_OW 1
21715: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21716: LD_ADDR_EXP 86
21720: PUSH
21721: LD_EXP 86
21725: PPUSH
21726: LD_VAR 0 1
21730: PPUSH
21731: EMPTY
21732: PPUSH
21733: CALL_OW 1
21737: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21738: LD_ADDR_EXP 87
21742: PUSH
21743: LD_EXP 87
21747: PPUSH
21748: LD_VAR 0 1
21752: PPUSH
21753: LD_INT 0
21755: PPUSH
21756: CALL_OW 1
21760: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21761: LD_ADDR_EXP 88
21765: PUSH
21766: LD_EXP 88
21770: PPUSH
21771: LD_VAR 0 1
21775: PPUSH
21776: EMPTY
21777: PPUSH
21778: CALL_OW 1
21782: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21783: LD_ADDR_EXP 89
21787: PUSH
21788: LD_EXP 89
21792: PPUSH
21793: LD_VAR 0 1
21797: PPUSH
21798: EMPTY
21799: PPUSH
21800: CALL_OW 1
21804: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21805: LD_ADDR_EXP 90
21809: PUSH
21810: LD_EXP 90
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: EMPTY
21821: PPUSH
21822: CALL_OW 1
21826: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21827: LD_ADDR_EXP 91
21831: PUSH
21832: LD_EXP 91
21836: PPUSH
21837: LD_VAR 0 1
21841: PPUSH
21842: EMPTY
21843: PPUSH
21844: CALL_OW 1
21848: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21849: LD_ADDR_EXP 92
21853: PUSH
21854: LD_EXP 92
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: EMPTY
21865: PPUSH
21866: CALL_OW 1
21870: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21871: LD_ADDR_EXP 93
21875: PUSH
21876: LD_EXP 93
21880: PPUSH
21881: LD_VAR 0 1
21885: PPUSH
21886: EMPTY
21887: PPUSH
21888: CALL_OW 1
21892: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21893: LD_ADDR_EXP 94
21897: PUSH
21898: LD_EXP 94
21902: PPUSH
21903: LD_VAR 0 1
21907: PPUSH
21908: EMPTY
21909: PPUSH
21910: CALL_OW 1
21914: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21915: LD_ADDR_EXP 95
21919: PUSH
21920: LD_EXP 95
21924: PPUSH
21925: LD_VAR 0 1
21929: PPUSH
21930: EMPTY
21931: PPUSH
21932: CALL_OW 1
21936: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21937: LD_ADDR_EXP 96
21941: PUSH
21942: LD_EXP 96
21946: PPUSH
21947: LD_VAR 0 1
21951: PPUSH
21952: EMPTY
21953: PPUSH
21954: CALL_OW 1
21958: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21959: LD_ADDR_EXP 97
21963: PUSH
21964: LD_EXP 97
21968: PPUSH
21969: LD_VAR 0 1
21973: PPUSH
21974: EMPTY
21975: PPUSH
21976: CALL_OW 1
21980: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21981: LD_ADDR_EXP 98
21985: PUSH
21986: LD_EXP 98
21990: PPUSH
21991: LD_VAR 0 1
21995: PPUSH
21996: EMPTY
21997: PPUSH
21998: CALL_OW 1
22002: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22003: LD_ADDR_EXP 99
22007: PUSH
22008: LD_EXP 99
22012: PPUSH
22013: LD_VAR 0 1
22017: PPUSH
22018: EMPTY
22019: PPUSH
22020: CALL_OW 1
22024: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22025: LD_ADDR_EXP 100
22029: PUSH
22030: LD_EXP 100
22034: PPUSH
22035: LD_VAR 0 1
22039: PPUSH
22040: EMPTY
22041: PPUSH
22042: CALL_OW 1
22046: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22047: LD_ADDR_EXP 101
22051: PUSH
22052: LD_EXP 101
22056: PPUSH
22057: LD_VAR 0 1
22061: PPUSH
22062: EMPTY
22063: PPUSH
22064: CALL_OW 1
22068: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22069: LD_ADDR_EXP 103
22073: PUSH
22074: LD_EXP 103
22078: PPUSH
22079: LD_VAR 0 1
22083: PPUSH
22084: EMPTY
22085: PPUSH
22086: CALL_OW 1
22090: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22091: LD_ADDR_EXP 105
22095: PUSH
22096: LD_EXP 105
22100: PPUSH
22101: LD_VAR 0 1
22105: PPUSH
22106: EMPTY
22107: PPUSH
22108: CALL_OW 1
22112: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22113: LD_ADDR_EXP 106
22117: PUSH
22118: LD_EXP 106
22122: PPUSH
22123: LD_VAR 0 1
22127: PPUSH
22128: EMPTY
22129: PPUSH
22130: CALL_OW 1
22134: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22135: LD_ADDR_EXP 107
22139: PUSH
22140: LD_EXP 107
22144: PPUSH
22145: LD_VAR 0 1
22149: PPUSH
22150: EMPTY
22151: PPUSH
22152: CALL_OW 1
22156: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22157: LD_ADDR_EXP 108
22161: PUSH
22162: LD_EXP 108
22166: PPUSH
22167: LD_VAR 0 1
22171: PPUSH
22172: EMPTY
22173: PPUSH
22174: CALL_OW 1
22178: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22179: LD_ADDR_EXP 109
22183: PUSH
22184: LD_EXP 109
22188: PPUSH
22189: LD_VAR 0 1
22193: PPUSH
22194: EMPTY
22195: PPUSH
22196: CALL_OW 1
22200: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22201: LD_ADDR_EXP 110
22205: PUSH
22206: LD_EXP 110
22210: PPUSH
22211: LD_VAR 0 1
22215: PPUSH
22216: EMPTY
22217: PPUSH
22218: CALL_OW 1
22222: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22223: LD_ADDR_EXP 111
22227: PUSH
22228: LD_EXP 111
22232: PPUSH
22233: LD_VAR 0 1
22237: PPUSH
22238: EMPTY
22239: PPUSH
22240: CALL_OW 1
22244: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22245: LD_ADDR_EXP 112
22249: PUSH
22250: LD_EXP 112
22254: PPUSH
22255: LD_VAR 0 1
22259: PPUSH
22260: EMPTY
22261: PPUSH
22262: CALL_OW 1
22266: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22267: LD_ADDR_EXP 113
22271: PUSH
22272: LD_EXP 113
22276: PPUSH
22277: LD_VAR 0 1
22281: PPUSH
22282: EMPTY
22283: PPUSH
22284: CALL_OW 1
22288: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22289: LD_ADDR_EXP 114
22293: PUSH
22294: LD_EXP 114
22298: PPUSH
22299: LD_VAR 0 1
22303: PPUSH
22304: EMPTY
22305: PPUSH
22306: CALL_OW 1
22310: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22311: LD_ADDR_EXP 115
22315: PUSH
22316: LD_EXP 115
22320: PPUSH
22321: LD_VAR 0 1
22325: PPUSH
22326: EMPTY
22327: PPUSH
22328: CALL_OW 1
22332: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22333: LD_ADDR_EXP 116
22337: PUSH
22338: LD_EXP 116
22342: PPUSH
22343: LD_VAR 0 1
22347: PPUSH
22348: EMPTY
22349: PPUSH
22350: CALL_OW 1
22354: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22355: LD_ADDR_EXP 117
22359: PUSH
22360: LD_EXP 117
22364: PPUSH
22365: LD_VAR 0 1
22369: PPUSH
22370: EMPTY
22371: PPUSH
22372: CALL_OW 1
22376: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22377: LD_ADDR_EXP 118
22381: PUSH
22382: LD_EXP 118
22386: PPUSH
22387: LD_VAR 0 1
22391: PPUSH
22392: LD_INT 0
22394: PPUSH
22395: CALL_OW 1
22399: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22400: LD_ADDR_EXP 119
22404: PUSH
22405: LD_EXP 119
22409: PPUSH
22410: LD_VAR 0 1
22414: PPUSH
22415: LD_INT 0
22417: PPUSH
22418: CALL_OW 1
22422: ST_TO_ADDR
// end ;
22423: LD_VAR 0 2
22427: RET
// export function MC_Add ( side , units ) ; var base ; begin
22428: LD_INT 0
22430: PPUSH
22431: PPUSH
// base := mc_bases + 1 ;
22432: LD_ADDR_VAR 0 4
22436: PUSH
22437: LD_EXP 76
22441: PUSH
22442: LD_INT 1
22444: PLUS
22445: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22446: LD_ADDR_EXP 102
22450: PUSH
22451: LD_EXP 102
22455: PPUSH
22456: LD_VAR 0 4
22460: PPUSH
22461: LD_VAR 0 1
22465: PPUSH
22466: CALL_OW 1
22470: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22471: LD_ADDR_EXP 76
22475: PUSH
22476: LD_EXP 76
22480: PPUSH
22481: LD_VAR 0 4
22485: PPUSH
22486: LD_VAR 0 2
22490: PPUSH
22491: CALL_OW 1
22495: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22496: LD_ADDR_EXP 77
22500: PUSH
22501: LD_EXP 77
22505: PPUSH
22506: LD_VAR 0 4
22510: PPUSH
22511: EMPTY
22512: PPUSH
22513: CALL_OW 1
22517: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22518: LD_ADDR_EXP 78
22522: PUSH
22523: LD_EXP 78
22527: PPUSH
22528: LD_VAR 0 4
22532: PPUSH
22533: EMPTY
22534: PPUSH
22535: CALL_OW 1
22539: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22540: LD_ADDR_EXP 79
22544: PUSH
22545: LD_EXP 79
22549: PPUSH
22550: LD_VAR 0 4
22554: PPUSH
22555: EMPTY
22556: PPUSH
22557: CALL_OW 1
22561: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22562: LD_ADDR_EXP 80
22566: PUSH
22567: LD_EXP 80
22571: PPUSH
22572: LD_VAR 0 4
22576: PPUSH
22577: EMPTY
22578: PPUSH
22579: CALL_OW 1
22583: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22584: LD_ADDR_EXP 81
22588: PUSH
22589: LD_EXP 81
22593: PPUSH
22594: LD_VAR 0 4
22598: PPUSH
22599: EMPTY
22600: PPUSH
22601: CALL_OW 1
22605: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22606: LD_ADDR_EXP 82
22610: PUSH
22611: LD_EXP 82
22615: PPUSH
22616: LD_VAR 0 4
22620: PPUSH
22621: EMPTY
22622: PPUSH
22623: CALL_OW 1
22627: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22628: LD_ADDR_EXP 83
22632: PUSH
22633: LD_EXP 83
22637: PPUSH
22638: LD_VAR 0 4
22642: PPUSH
22643: EMPTY
22644: PPUSH
22645: CALL_OW 1
22649: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22650: LD_ADDR_EXP 84
22654: PUSH
22655: LD_EXP 84
22659: PPUSH
22660: LD_VAR 0 4
22664: PPUSH
22665: EMPTY
22666: PPUSH
22667: CALL_OW 1
22671: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22672: LD_ADDR_EXP 85
22676: PUSH
22677: LD_EXP 85
22681: PPUSH
22682: LD_VAR 0 4
22686: PPUSH
22687: EMPTY
22688: PPUSH
22689: CALL_OW 1
22693: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22694: LD_ADDR_EXP 86
22698: PUSH
22699: LD_EXP 86
22703: PPUSH
22704: LD_VAR 0 4
22708: PPUSH
22709: EMPTY
22710: PPUSH
22711: CALL_OW 1
22715: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22716: LD_ADDR_EXP 87
22720: PUSH
22721: LD_EXP 87
22725: PPUSH
22726: LD_VAR 0 4
22730: PPUSH
22731: LD_INT 0
22733: PPUSH
22734: CALL_OW 1
22738: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22739: LD_ADDR_EXP 88
22743: PUSH
22744: LD_EXP 88
22748: PPUSH
22749: LD_VAR 0 4
22753: PPUSH
22754: EMPTY
22755: PPUSH
22756: CALL_OW 1
22760: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22761: LD_ADDR_EXP 89
22765: PUSH
22766: LD_EXP 89
22770: PPUSH
22771: LD_VAR 0 4
22775: PPUSH
22776: EMPTY
22777: PPUSH
22778: CALL_OW 1
22782: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22783: LD_ADDR_EXP 90
22787: PUSH
22788: LD_EXP 90
22792: PPUSH
22793: LD_VAR 0 4
22797: PPUSH
22798: EMPTY
22799: PPUSH
22800: CALL_OW 1
22804: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22805: LD_ADDR_EXP 91
22809: PUSH
22810: LD_EXP 91
22814: PPUSH
22815: LD_VAR 0 4
22819: PPUSH
22820: EMPTY
22821: PPUSH
22822: CALL_OW 1
22826: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22827: LD_ADDR_EXP 92
22831: PUSH
22832: LD_EXP 92
22836: PPUSH
22837: LD_VAR 0 4
22841: PPUSH
22842: EMPTY
22843: PPUSH
22844: CALL_OW 1
22848: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22849: LD_ADDR_EXP 93
22853: PUSH
22854: LD_EXP 93
22858: PPUSH
22859: LD_VAR 0 4
22863: PPUSH
22864: EMPTY
22865: PPUSH
22866: CALL_OW 1
22870: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22871: LD_ADDR_EXP 94
22875: PUSH
22876: LD_EXP 94
22880: PPUSH
22881: LD_VAR 0 4
22885: PPUSH
22886: EMPTY
22887: PPUSH
22888: CALL_OW 1
22892: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22893: LD_ADDR_EXP 95
22897: PUSH
22898: LD_EXP 95
22902: PPUSH
22903: LD_VAR 0 4
22907: PPUSH
22908: EMPTY
22909: PPUSH
22910: CALL_OW 1
22914: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22915: LD_ADDR_EXP 96
22919: PUSH
22920: LD_EXP 96
22924: PPUSH
22925: LD_VAR 0 4
22929: PPUSH
22930: EMPTY
22931: PPUSH
22932: CALL_OW 1
22936: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22937: LD_ADDR_EXP 97
22941: PUSH
22942: LD_EXP 97
22946: PPUSH
22947: LD_VAR 0 4
22951: PPUSH
22952: EMPTY
22953: PPUSH
22954: CALL_OW 1
22958: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22959: LD_ADDR_EXP 98
22963: PUSH
22964: LD_EXP 98
22968: PPUSH
22969: LD_VAR 0 4
22973: PPUSH
22974: EMPTY
22975: PPUSH
22976: CALL_OW 1
22980: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22981: LD_ADDR_EXP 99
22985: PUSH
22986: LD_EXP 99
22990: PPUSH
22991: LD_VAR 0 4
22995: PPUSH
22996: EMPTY
22997: PPUSH
22998: CALL_OW 1
23002: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23003: LD_ADDR_EXP 100
23007: PUSH
23008: LD_EXP 100
23012: PPUSH
23013: LD_VAR 0 4
23017: PPUSH
23018: EMPTY
23019: PPUSH
23020: CALL_OW 1
23024: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23025: LD_ADDR_EXP 101
23029: PUSH
23030: LD_EXP 101
23034: PPUSH
23035: LD_VAR 0 4
23039: PPUSH
23040: EMPTY
23041: PPUSH
23042: CALL_OW 1
23046: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23047: LD_ADDR_EXP 103
23051: PUSH
23052: LD_EXP 103
23056: PPUSH
23057: LD_VAR 0 4
23061: PPUSH
23062: EMPTY
23063: PPUSH
23064: CALL_OW 1
23068: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23069: LD_ADDR_EXP 105
23073: PUSH
23074: LD_EXP 105
23078: PPUSH
23079: LD_VAR 0 4
23083: PPUSH
23084: EMPTY
23085: PPUSH
23086: CALL_OW 1
23090: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23091: LD_ADDR_EXP 106
23095: PUSH
23096: LD_EXP 106
23100: PPUSH
23101: LD_VAR 0 4
23105: PPUSH
23106: EMPTY
23107: PPUSH
23108: CALL_OW 1
23112: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23113: LD_ADDR_EXP 107
23117: PUSH
23118: LD_EXP 107
23122: PPUSH
23123: LD_VAR 0 4
23127: PPUSH
23128: EMPTY
23129: PPUSH
23130: CALL_OW 1
23134: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23135: LD_ADDR_EXP 108
23139: PUSH
23140: LD_EXP 108
23144: PPUSH
23145: LD_VAR 0 4
23149: PPUSH
23150: EMPTY
23151: PPUSH
23152: CALL_OW 1
23156: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23157: LD_ADDR_EXP 109
23161: PUSH
23162: LD_EXP 109
23166: PPUSH
23167: LD_VAR 0 4
23171: PPUSH
23172: EMPTY
23173: PPUSH
23174: CALL_OW 1
23178: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23179: LD_ADDR_EXP 110
23183: PUSH
23184: LD_EXP 110
23188: PPUSH
23189: LD_VAR 0 4
23193: PPUSH
23194: EMPTY
23195: PPUSH
23196: CALL_OW 1
23200: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23201: LD_ADDR_EXP 111
23205: PUSH
23206: LD_EXP 111
23210: PPUSH
23211: LD_VAR 0 4
23215: PPUSH
23216: EMPTY
23217: PPUSH
23218: CALL_OW 1
23222: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23223: LD_ADDR_EXP 112
23227: PUSH
23228: LD_EXP 112
23232: PPUSH
23233: LD_VAR 0 4
23237: PPUSH
23238: EMPTY
23239: PPUSH
23240: CALL_OW 1
23244: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23245: LD_ADDR_EXP 113
23249: PUSH
23250: LD_EXP 113
23254: PPUSH
23255: LD_VAR 0 4
23259: PPUSH
23260: EMPTY
23261: PPUSH
23262: CALL_OW 1
23266: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23267: LD_ADDR_EXP 114
23271: PUSH
23272: LD_EXP 114
23276: PPUSH
23277: LD_VAR 0 4
23281: PPUSH
23282: EMPTY
23283: PPUSH
23284: CALL_OW 1
23288: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23289: LD_ADDR_EXP 115
23293: PUSH
23294: LD_EXP 115
23298: PPUSH
23299: LD_VAR 0 4
23303: PPUSH
23304: EMPTY
23305: PPUSH
23306: CALL_OW 1
23310: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23311: LD_ADDR_EXP 116
23315: PUSH
23316: LD_EXP 116
23320: PPUSH
23321: LD_VAR 0 4
23325: PPUSH
23326: EMPTY
23327: PPUSH
23328: CALL_OW 1
23332: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23333: LD_ADDR_EXP 117
23337: PUSH
23338: LD_EXP 117
23342: PPUSH
23343: LD_VAR 0 4
23347: PPUSH
23348: EMPTY
23349: PPUSH
23350: CALL_OW 1
23354: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23355: LD_ADDR_EXP 118
23359: PUSH
23360: LD_EXP 118
23364: PPUSH
23365: LD_VAR 0 4
23369: PPUSH
23370: LD_INT 0
23372: PPUSH
23373: CALL_OW 1
23377: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23378: LD_ADDR_EXP 119
23382: PUSH
23383: LD_EXP 119
23387: PPUSH
23388: LD_VAR 0 4
23392: PPUSH
23393: LD_INT 0
23395: PPUSH
23396: CALL_OW 1
23400: ST_TO_ADDR
// result := base ;
23401: LD_ADDR_VAR 0 3
23405: PUSH
23406: LD_VAR 0 4
23410: ST_TO_ADDR
// end ;
23411: LD_VAR 0 3
23415: RET
// export function MC_Start ( ) ; var i ; begin
23416: LD_INT 0
23418: PPUSH
23419: PPUSH
// for i = 1 to mc_bases do
23420: LD_ADDR_VAR 0 2
23424: PUSH
23425: DOUBLE
23426: LD_INT 1
23428: DEC
23429: ST_TO_ADDR
23430: LD_EXP 76
23434: PUSH
23435: FOR_TO
23436: IFFALSE 24536
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23438: LD_ADDR_EXP 76
23442: PUSH
23443: LD_EXP 76
23447: PPUSH
23448: LD_VAR 0 2
23452: PPUSH
23453: LD_EXP 76
23457: PUSH
23458: LD_VAR 0 2
23462: ARRAY
23463: PUSH
23464: LD_INT 0
23466: DIFF
23467: PPUSH
23468: CALL_OW 1
23472: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23473: LD_ADDR_EXP 77
23477: PUSH
23478: LD_EXP 77
23482: PPUSH
23483: LD_VAR 0 2
23487: PPUSH
23488: EMPTY
23489: PPUSH
23490: CALL_OW 1
23494: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23495: LD_ADDR_EXP 78
23499: PUSH
23500: LD_EXP 78
23504: PPUSH
23505: LD_VAR 0 2
23509: PPUSH
23510: EMPTY
23511: PPUSH
23512: CALL_OW 1
23516: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23517: LD_ADDR_EXP 79
23521: PUSH
23522: LD_EXP 79
23526: PPUSH
23527: LD_VAR 0 2
23531: PPUSH
23532: EMPTY
23533: PPUSH
23534: CALL_OW 1
23538: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23539: LD_ADDR_EXP 80
23543: PUSH
23544: LD_EXP 80
23548: PPUSH
23549: LD_VAR 0 2
23553: PPUSH
23554: EMPTY
23555: PUSH
23556: EMPTY
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: PPUSH
23562: CALL_OW 1
23566: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23567: LD_ADDR_EXP 81
23571: PUSH
23572: LD_EXP 81
23576: PPUSH
23577: LD_VAR 0 2
23581: PPUSH
23582: EMPTY
23583: PPUSH
23584: CALL_OW 1
23588: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23589: LD_ADDR_EXP 108
23593: PUSH
23594: LD_EXP 108
23598: PPUSH
23599: LD_VAR 0 2
23603: PPUSH
23604: EMPTY
23605: PPUSH
23606: CALL_OW 1
23610: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23611: LD_ADDR_EXP 82
23615: PUSH
23616: LD_EXP 82
23620: PPUSH
23621: LD_VAR 0 2
23625: PPUSH
23626: EMPTY
23627: PPUSH
23628: CALL_OW 1
23632: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23633: LD_ADDR_EXP 83
23637: PUSH
23638: LD_EXP 83
23642: PPUSH
23643: LD_VAR 0 2
23647: PPUSH
23648: EMPTY
23649: PPUSH
23650: CALL_OW 1
23654: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23655: LD_ADDR_EXP 84
23659: PUSH
23660: LD_EXP 84
23664: PPUSH
23665: LD_VAR 0 2
23669: PPUSH
23670: LD_EXP 76
23674: PUSH
23675: LD_VAR 0 2
23679: ARRAY
23680: PPUSH
23681: LD_INT 2
23683: PUSH
23684: LD_INT 30
23686: PUSH
23687: LD_INT 32
23689: PUSH
23690: EMPTY
23691: LIST
23692: LIST
23693: PUSH
23694: LD_INT 30
23696: PUSH
23697: LD_INT 33
23699: PUSH
23700: EMPTY
23701: LIST
23702: LIST
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: LIST
23708: PPUSH
23709: CALL_OW 72
23713: PPUSH
23714: CALL_OW 1
23718: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23719: LD_ADDR_EXP 85
23723: PUSH
23724: LD_EXP 85
23728: PPUSH
23729: LD_VAR 0 2
23733: PPUSH
23734: LD_EXP 76
23738: PUSH
23739: LD_VAR 0 2
23743: ARRAY
23744: PPUSH
23745: LD_INT 2
23747: PUSH
23748: LD_INT 30
23750: PUSH
23751: LD_INT 32
23753: PUSH
23754: EMPTY
23755: LIST
23756: LIST
23757: PUSH
23758: LD_INT 30
23760: PUSH
23761: LD_INT 31
23763: PUSH
23764: EMPTY
23765: LIST
23766: LIST
23767: PUSH
23768: EMPTY
23769: LIST
23770: LIST
23771: LIST
23772: PUSH
23773: LD_INT 58
23775: PUSH
23776: EMPTY
23777: LIST
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: PPUSH
23783: CALL_OW 72
23787: PPUSH
23788: CALL_OW 1
23792: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23793: LD_ADDR_EXP 86
23797: PUSH
23798: LD_EXP 86
23802: PPUSH
23803: LD_VAR 0 2
23807: PPUSH
23808: EMPTY
23809: PPUSH
23810: CALL_OW 1
23814: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23815: LD_ADDR_EXP 90
23819: PUSH
23820: LD_EXP 90
23824: PPUSH
23825: LD_VAR 0 2
23829: PPUSH
23830: EMPTY
23831: PPUSH
23832: CALL_OW 1
23836: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23837: LD_ADDR_EXP 89
23841: PUSH
23842: LD_EXP 89
23846: PPUSH
23847: LD_VAR 0 2
23851: PPUSH
23852: EMPTY
23853: PPUSH
23854: CALL_OW 1
23858: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23859: LD_ADDR_EXP 91
23863: PUSH
23864: LD_EXP 91
23868: PPUSH
23869: LD_VAR 0 2
23873: PPUSH
23874: EMPTY
23875: PPUSH
23876: CALL_OW 1
23880: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23881: LD_ADDR_EXP 92
23885: PUSH
23886: LD_EXP 92
23890: PPUSH
23891: LD_VAR 0 2
23895: PPUSH
23896: EMPTY
23897: PPUSH
23898: CALL_OW 1
23902: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23903: LD_ADDR_EXP 93
23907: PUSH
23908: LD_EXP 93
23912: PPUSH
23913: LD_VAR 0 2
23917: PPUSH
23918: EMPTY
23919: PPUSH
23920: CALL_OW 1
23924: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23925: LD_ADDR_EXP 94
23929: PUSH
23930: LD_EXP 94
23934: PPUSH
23935: LD_VAR 0 2
23939: PPUSH
23940: EMPTY
23941: PPUSH
23942: CALL_OW 1
23946: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23947: LD_ADDR_EXP 95
23951: PUSH
23952: LD_EXP 95
23956: PPUSH
23957: LD_VAR 0 2
23961: PPUSH
23962: EMPTY
23963: PPUSH
23964: CALL_OW 1
23968: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23969: LD_ADDR_EXP 96
23973: PUSH
23974: LD_EXP 96
23978: PPUSH
23979: LD_VAR 0 2
23983: PPUSH
23984: EMPTY
23985: PPUSH
23986: CALL_OW 1
23990: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23991: LD_ADDR_EXP 97
23995: PUSH
23996: LD_EXP 97
24000: PPUSH
24001: LD_VAR 0 2
24005: PPUSH
24006: EMPTY
24007: PPUSH
24008: CALL_OW 1
24012: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24013: LD_ADDR_EXP 98
24017: PUSH
24018: LD_EXP 98
24022: PPUSH
24023: LD_VAR 0 2
24027: PPUSH
24028: EMPTY
24029: PPUSH
24030: CALL_OW 1
24034: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24035: LD_ADDR_EXP 87
24039: PUSH
24040: LD_EXP 87
24044: PPUSH
24045: LD_VAR 0 2
24049: PPUSH
24050: LD_INT 0
24052: PPUSH
24053: CALL_OW 1
24057: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24058: LD_ADDR_EXP 100
24062: PUSH
24063: LD_EXP 100
24067: PPUSH
24068: LD_VAR 0 2
24072: PPUSH
24073: LD_INT 0
24075: PPUSH
24076: CALL_OW 1
24080: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24081: LD_ADDR_EXP 88
24085: PUSH
24086: LD_EXP 88
24090: PPUSH
24091: LD_VAR 0 2
24095: PPUSH
24096: EMPTY
24097: PPUSH
24098: CALL_OW 1
24102: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24103: LD_ADDR_EXP 99
24107: PUSH
24108: LD_EXP 99
24112: PPUSH
24113: LD_VAR 0 2
24117: PPUSH
24118: LD_INT 0
24120: PPUSH
24121: CALL_OW 1
24125: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24126: LD_ADDR_EXP 101
24130: PUSH
24131: LD_EXP 101
24135: PPUSH
24136: LD_VAR 0 2
24140: PPUSH
24141: EMPTY
24142: PPUSH
24143: CALL_OW 1
24147: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24148: LD_ADDR_EXP 104
24152: PUSH
24153: LD_EXP 104
24157: PPUSH
24158: LD_VAR 0 2
24162: PPUSH
24163: LD_INT 0
24165: PPUSH
24166: CALL_OW 1
24170: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24171: LD_ADDR_EXP 105
24175: PUSH
24176: LD_EXP 105
24180: PPUSH
24181: LD_VAR 0 2
24185: PPUSH
24186: EMPTY
24187: PPUSH
24188: CALL_OW 1
24192: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24193: LD_ADDR_EXP 106
24197: PUSH
24198: LD_EXP 106
24202: PPUSH
24203: LD_VAR 0 2
24207: PPUSH
24208: EMPTY
24209: PPUSH
24210: CALL_OW 1
24214: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24215: LD_ADDR_EXP 107
24219: PUSH
24220: LD_EXP 107
24224: PPUSH
24225: LD_VAR 0 2
24229: PPUSH
24230: EMPTY
24231: PPUSH
24232: CALL_OW 1
24236: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24237: LD_ADDR_EXP 109
24241: PUSH
24242: LD_EXP 109
24246: PPUSH
24247: LD_VAR 0 2
24251: PPUSH
24252: LD_EXP 76
24256: PUSH
24257: LD_VAR 0 2
24261: ARRAY
24262: PPUSH
24263: LD_INT 2
24265: PUSH
24266: LD_INT 30
24268: PUSH
24269: LD_INT 6
24271: PUSH
24272: EMPTY
24273: LIST
24274: LIST
24275: PUSH
24276: LD_INT 30
24278: PUSH
24279: LD_INT 7
24281: PUSH
24282: EMPTY
24283: LIST
24284: LIST
24285: PUSH
24286: LD_INT 30
24288: PUSH
24289: LD_INT 8
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: PPUSH
24302: CALL_OW 72
24306: PPUSH
24307: CALL_OW 1
24311: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24312: LD_ADDR_EXP 110
24316: PUSH
24317: LD_EXP 110
24321: PPUSH
24322: LD_VAR 0 2
24326: PPUSH
24327: EMPTY
24328: PPUSH
24329: CALL_OW 1
24333: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24334: LD_ADDR_EXP 111
24338: PUSH
24339: LD_EXP 111
24343: PPUSH
24344: LD_VAR 0 2
24348: PPUSH
24349: EMPTY
24350: PPUSH
24351: CALL_OW 1
24355: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24356: LD_ADDR_EXP 112
24360: PUSH
24361: LD_EXP 112
24365: PPUSH
24366: LD_VAR 0 2
24370: PPUSH
24371: EMPTY
24372: PPUSH
24373: CALL_OW 1
24377: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24378: LD_ADDR_EXP 113
24382: PUSH
24383: LD_EXP 113
24387: PPUSH
24388: LD_VAR 0 2
24392: PPUSH
24393: EMPTY
24394: PPUSH
24395: CALL_OW 1
24399: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24400: LD_ADDR_EXP 114
24404: PUSH
24405: LD_EXP 114
24409: PPUSH
24410: LD_VAR 0 2
24414: PPUSH
24415: EMPTY
24416: PPUSH
24417: CALL_OW 1
24421: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24422: LD_ADDR_EXP 115
24426: PUSH
24427: LD_EXP 115
24431: PPUSH
24432: LD_VAR 0 2
24436: PPUSH
24437: EMPTY
24438: PPUSH
24439: CALL_OW 1
24443: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24444: LD_ADDR_EXP 116
24448: PUSH
24449: LD_EXP 116
24453: PPUSH
24454: LD_VAR 0 2
24458: PPUSH
24459: EMPTY
24460: PPUSH
24461: CALL_OW 1
24465: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24466: LD_ADDR_EXP 117
24470: PUSH
24471: LD_EXP 117
24475: PPUSH
24476: LD_VAR 0 2
24480: PPUSH
24481: EMPTY
24482: PPUSH
24483: CALL_OW 1
24487: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24488: LD_ADDR_EXP 118
24492: PUSH
24493: LD_EXP 118
24497: PPUSH
24498: LD_VAR 0 2
24502: PPUSH
24503: LD_INT 0
24505: PPUSH
24506: CALL_OW 1
24510: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24511: LD_ADDR_EXP 119
24515: PUSH
24516: LD_EXP 119
24520: PPUSH
24521: LD_VAR 0 2
24525: PPUSH
24526: LD_INT 0
24528: PPUSH
24529: CALL_OW 1
24533: ST_TO_ADDR
// end ;
24534: GO 23435
24536: POP
24537: POP
// MC_InitSides ( ) ;
24538: CALL 24824 0 0
// MC_InitResearch ( ) ;
24542: CALL 24563 0 0
// CustomInitMacro ( ) ;
24546: CALL 228 0 0
// skirmish := true ;
24550: LD_ADDR_EXP 74
24554: PUSH
24555: LD_INT 1
24557: ST_TO_ADDR
// end ;
24558: LD_VAR 0 1
24562: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24563: LD_INT 0
24565: PPUSH
24566: PPUSH
24567: PPUSH
24568: PPUSH
24569: PPUSH
24570: PPUSH
// if not mc_bases then
24571: LD_EXP 76
24575: NOT
24576: IFFALSE 24580
// exit ;
24578: GO 24819
// for i = 1 to 8 do
24580: LD_ADDR_VAR 0 2
24584: PUSH
24585: DOUBLE
24586: LD_INT 1
24588: DEC
24589: ST_TO_ADDR
24590: LD_INT 8
24592: PUSH
24593: FOR_TO
24594: IFFALSE 24620
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24596: LD_ADDR_EXP 103
24600: PUSH
24601: LD_EXP 103
24605: PPUSH
24606: LD_VAR 0 2
24610: PPUSH
24611: EMPTY
24612: PPUSH
24613: CALL_OW 1
24617: ST_TO_ADDR
24618: GO 24593
24620: POP
24621: POP
// tmp := [ ] ;
24622: LD_ADDR_VAR 0 5
24626: PUSH
24627: EMPTY
24628: ST_TO_ADDR
// for i = 1 to mc_sides do
24629: LD_ADDR_VAR 0 2
24633: PUSH
24634: DOUBLE
24635: LD_INT 1
24637: DEC
24638: ST_TO_ADDR
24639: LD_EXP 102
24643: PUSH
24644: FOR_TO
24645: IFFALSE 24703
// if not mc_sides [ i ] in tmp then
24647: LD_EXP 102
24651: PUSH
24652: LD_VAR 0 2
24656: ARRAY
24657: PUSH
24658: LD_VAR 0 5
24662: IN
24663: NOT
24664: IFFALSE 24701
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24666: LD_ADDR_VAR 0 5
24670: PUSH
24671: LD_VAR 0 5
24675: PPUSH
24676: LD_VAR 0 5
24680: PUSH
24681: LD_INT 1
24683: PLUS
24684: PPUSH
24685: LD_EXP 102
24689: PUSH
24690: LD_VAR 0 2
24694: ARRAY
24695: PPUSH
24696: CALL_OW 2
24700: ST_TO_ADDR
24701: GO 24644
24703: POP
24704: POP
// if not tmp then
24705: LD_VAR 0 5
24709: NOT
24710: IFFALSE 24714
// exit ;
24712: GO 24819
// for j in tmp do
24714: LD_ADDR_VAR 0 3
24718: PUSH
24719: LD_VAR 0 5
24723: PUSH
24724: FOR_IN
24725: IFFALSE 24817
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24727: LD_ADDR_VAR 0 6
24731: PUSH
24732: LD_INT 22
24734: PUSH
24735: LD_VAR 0 3
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: PPUSH
24744: CALL_OW 69
24748: ST_TO_ADDR
// if not un then
24749: LD_VAR 0 6
24753: NOT
24754: IFFALSE 24758
// continue ;
24756: GO 24724
// nation := GetNation ( un [ 1 ] ) ;
24758: LD_ADDR_VAR 0 4
24762: PUSH
24763: LD_VAR 0 6
24767: PUSH
24768: LD_INT 1
24770: ARRAY
24771: PPUSH
24772: CALL_OW 248
24776: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24777: LD_ADDR_EXP 103
24781: PUSH
24782: LD_EXP 103
24786: PPUSH
24787: LD_VAR 0 3
24791: PPUSH
24792: LD_VAR 0 3
24796: PPUSH
24797: LD_VAR 0 4
24801: PPUSH
24802: LD_INT 1
24804: PPUSH
24805: CALL 51971 0 3
24809: PPUSH
24810: CALL_OW 1
24814: ST_TO_ADDR
// end ;
24815: GO 24724
24817: POP
24818: POP
// end ;
24819: LD_VAR 0 1
24823: RET
// export function MC_InitSides ( ) ; var i ; begin
24824: LD_INT 0
24826: PPUSH
24827: PPUSH
// if not mc_bases then
24828: LD_EXP 76
24832: NOT
24833: IFFALSE 24837
// exit ;
24835: GO 24911
// for i = 1 to mc_bases do
24837: LD_ADDR_VAR 0 2
24841: PUSH
24842: DOUBLE
24843: LD_INT 1
24845: DEC
24846: ST_TO_ADDR
24847: LD_EXP 76
24851: PUSH
24852: FOR_TO
24853: IFFALSE 24909
// if mc_bases [ i ] then
24855: LD_EXP 76
24859: PUSH
24860: LD_VAR 0 2
24864: ARRAY
24865: IFFALSE 24907
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24867: LD_ADDR_EXP 102
24871: PUSH
24872: LD_EXP 102
24876: PPUSH
24877: LD_VAR 0 2
24881: PPUSH
24882: LD_EXP 76
24886: PUSH
24887: LD_VAR 0 2
24891: ARRAY
24892: PUSH
24893: LD_INT 1
24895: ARRAY
24896: PPUSH
24897: CALL_OW 255
24901: PPUSH
24902: CALL_OW 1
24906: ST_TO_ADDR
24907: GO 24852
24909: POP
24910: POP
// end ;
24911: LD_VAR 0 1
24915: RET
// every 0 0$03 trigger skirmish do
24916: LD_EXP 74
24920: IFFALSE 25074
24922: GO 24924
24924: DISABLE
// begin enable ;
24925: ENABLE
// MC_CheckBuildings ( ) ;
24926: CALL 29572 0 0
// MC_CheckPeopleLife ( ) ;
24930: CALL 29733 0 0
// RaiseSailEvent ( 100 ) ;
24934: LD_INT 100
24936: PPUSH
24937: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24941: LD_INT 103
24943: PPUSH
24944: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24948: LD_INT 104
24950: PPUSH
24951: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24955: LD_INT 105
24957: PPUSH
24958: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24962: LD_INT 106
24964: PPUSH
24965: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24969: LD_INT 107
24971: PPUSH
24972: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24976: LD_INT 108
24978: PPUSH
24979: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24983: LD_INT 109
24985: PPUSH
24986: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24990: LD_INT 110
24992: PPUSH
24993: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24997: LD_INT 111
24999: PPUSH
25000: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25004: LD_INT 112
25006: PPUSH
25007: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25011: LD_INT 113
25013: PPUSH
25014: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25018: LD_INT 120
25020: PPUSH
25021: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25025: LD_INT 121
25027: PPUSH
25028: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25032: LD_INT 122
25034: PPUSH
25035: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25039: LD_INT 123
25041: PPUSH
25042: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25046: LD_INT 124
25048: PPUSH
25049: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25053: LD_INT 125
25055: PPUSH
25056: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25060: LD_INT 126
25062: PPUSH
25063: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25067: LD_INT 200
25069: PPUSH
25070: CALL_OW 427
// end ;
25074: END
// on SailEvent ( event ) do begin if event < 100 then
25075: LD_VAR 0 1
25079: PUSH
25080: LD_INT 100
25082: LESS
25083: IFFALSE 25094
// CustomEvent ( event ) ;
25085: LD_VAR 0 1
25089: PPUSH
25090: CALL 10906 0 1
// if event = 100 then
25094: LD_VAR 0 1
25098: PUSH
25099: LD_INT 100
25101: EQUAL
25102: IFFALSE 25108
// MC_ClassManager ( ) ;
25104: CALL 25500 0 0
// if event = 101 then
25108: LD_VAR 0 1
25112: PUSH
25113: LD_INT 101
25115: EQUAL
25116: IFFALSE 25122
// MC_RepairBuildings ( ) ;
25118: CALL 30318 0 0
// if event = 102 then
25122: LD_VAR 0 1
25126: PUSH
25127: LD_INT 102
25129: EQUAL
25130: IFFALSE 25136
// MC_Heal ( ) ;
25132: CALL 31253 0 0
// if event = 103 then
25136: LD_VAR 0 1
25140: PUSH
25141: LD_INT 103
25143: EQUAL
25144: IFFALSE 25150
// MC_Build ( ) ;
25146: CALL 31675 0 0
// if event = 104 then
25150: LD_VAR 0 1
25154: PUSH
25155: LD_INT 104
25157: EQUAL
25158: IFFALSE 25164
// MC_TurretWeapon ( ) ;
25160: CALL 33309 0 0
// if event = 105 then
25164: LD_VAR 0 1
25168: PUSH
25169: LD_INT 105
25171: EQUAL
25172: IFFALSE 25178
// MC_BuildUpgrade ( ) ;
25174: CALL 32860 0 0
// if event = 106 then
25178: LD_VAR 0 1
25182: PUSH
25183: LD_INT 106
25185: EQUAL
25186: IFFALSE 25192
// MC_PlantMines ( ) ;
25188: CALL 33739 0 0
// if event = 107 then
25192: LD_VAR 0 1
25196: PUSH
25197: LD_INT 107
25199: EQUAL
25200: IFFALSE 25206
// MC_CollectCrates ( ) ;
25202: CALL 34530 0 0
// if event = 108 then
25206: LD_VAR 0 1
25210: PUSH
25211: LD_INT 108
25213: EQUAL
25214: IFFALSE 25220
// MC_LinkRemoteControl ( ) ;
25216: CALL 36380 0 0
// if event = 109 then
25220: LD_VAR 0 1
25224: PUSH
25225: LD_INT 109
25227: EQUAL
25228: IFFALSE 25234
// MC_ProduceVehicle ( ) ;
25230: CALL 36561 0 0
// if event = 110 then
25234: LD_VAR 0 1
25238: PUSH
25239: LD_INT 110
25241: EQUAL
25242: IFFALSE 25248
// MC_SendAttack ( ) ;
25244: CALL 37027 0 0
// if event = 111 then
25248: LD_VAR 0 1
25252: PUSH
25253: LD_INT 111
25255: EQUAL
25256: IFFALSE 25262
// MC_Defend ( ) ;
25258: CALL 37135 0 0
// if event = 112 then
25262: LD_VAR 0 1
25266: PUSH
25267: LD_INT 112
25269: EQUAL
25270: IFFALSE 25276
// MC_Research ( ) ;
25272: CALL 38015 0 0
// if event = 113 then
25276: LD_VAR 0 1
25280: PUSH
25281: LD_INT 113
25283: EQUAL
25284: IFFALSE 25290
// MC_MinesTrigger ( ) ;
25286: CALL 39129 0 0
// if event = 120 then
25290: LD_VAR 0 1
25294: PUSH
25295: LD_INT 120
25297: EQUAL
25298: IFFALSE 25304
// MC_RepairVehicle ( ) ;
25300: CALL 39228 0 0
// if event = 121 then
25304: LD_VAR 0 1
25308: PUSH
25309: LD_INT 121
25311: EQUAL
25312: IFFALSE 25318
// MC_TameApe ( ) ;
25314: CALL 39997 0 0
// if event = 122 then
25318: LD_VAR 0 1
25322: PUSH
25323: LD_INT 122
25325: EQUAL
25326: IFFALSE 25332
// MC_ChangeApeClass ( ) ;
25328: CALL 40826 0 0
// if event = 123 then
25332: LD_VAR 0 1
25336: PUSH
25337: LD_INT 123
25339: EQUAL
25340: IFFALSE 25346
// MC_Bazooka ( ) ;
25342: CALL 41476 0 0
// if event = 124 then
25346: LD_VAR 0 1
25350: PUSH
25351: LD_INT 124
25353: EQUAL
25354: IFFALSE 25360
// MC_TeleportExit ( ) ;
25356: CALL 41674 0 0
// if event = 125 then
25360: LD_VAR 0 1
25364: PUSH
25365: LD_INT 125
25367: EQUAL
25368: IFFALSE 25374
// MC_Deposits ( ) ;
25370: CALL 42321 0 0
// if event = 126 then
25374: LD_VAR 0 1
25378: PUSH
25379: LD_INT 126
25381: EQUAL
25382: IFFALSE 25388
// MC_RemoteDriver ( ) ;
25384: CALL 42946 0 0
// if event = 200 then
25388: LD_VAR 0 1
25392: PUSH
25393: LD_INT 200
25395: EQUAL
25396: IFFALSE 25402
// MC_Idle ( ) ;
25398: CALL 44895 0 0
// end ;
25402: PPOPN 1
25404: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25405: LD_INT 0
25407: PPUSH
25408: PPUSH
// if not mc_bases [ base ] or not tag then
25409: LD_EXP 76
25413: PUSH
25414: LD_VAR 0 1
25418: ARRAY
25419: NOT
25420: PUSH
25421: LD_VAR 0 2
25425: NOT
25426: OR
25427: IFFALSE 25431
// exit ;
25429: GO 25495
// for i in mc_bases [ base ] union mc_ape [ base ] do
25431: LD_ADDR_VAR 0 4
25435: PUSH
25436: LD_EXP 76
25440: PUSH
25441: LD_VAR 0 1
25445: ARRAY
25446: PUSH
25447: LD_EXP 105
25451: PUSH
25452: LD_VAR 0 1
25456: ARRAY
25457: UNION
25458: PUSH
25459: FOR_IN
25460: IFFALSE 25493
// if GetTag ( i ) = tag then
25462: LD_VAR 0 4
25466: PPUSH
25467: CALL_OW 110
25471: PUSH
25472: LD_VAR 0 2
25476: EQUAL
25477: IFFALSE 25491
// SetTag ( i , 0 ) ;
25479: LD_VAR 0 4
25483: PPUSH
25484: LD_INT 0
25486: PPUSH
25487: CALL_OW 109
25491: GO 25459
25493: POP
25494: POP
// end ;
25495: LD_VAR 0 3
25499: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25500: LD_INT 0
25502: PPUSH
25503: PPUSH
25504: PPUSH
25505: PPUSH
25506: PPUSH
25507: PPUSH
25508: PPUSH
25509: PPUSH
// if not mc_bases then
25510: LD_EXP 76
25514: NOT
25515: IFFALSE 25519
// exit ;
25517: GO 25977
// for i = 1 to mc_bases do
25519: LD_ADDR_VAR 0 2
25523: PUSH
25524: DOUBLE
25525: LD_INT 1
25527: DEC
25528: ST_TO_ADDR
25529: LD_EXP 76
25533: PUSH
25534: FOR_TO
25535: IFFALSE 25975
// begin tmp := MC_ClassCheckReq ( i ) ;
25537: LD_ADDR_VAR 0 4
25541: PUSH
25542: LD_VAR 0 2
25546: PPUSH
25547: CALL 25982 0 1
25551: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25552: LD_ADDR_EXP 117
25556: PUSH
25557: LD_EXP 117
25561: PPUSH
25562: LD_VAR 0 2
25566: PPUSH
25567: LD_VAR 0 4
25571: PPUSH
25572: CALL_OW 1
25576: ST_TO_ADDR
// if not tmp then
25577: LD_VAR 0 4
25581: NOT
25582: IFFALSE 25586
// continue ;
25584: GO 25534
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25586: LD_ADDR_VAR 0 6
25590: PUSH
25591: LD_EXP 76
25595: PUSH
25596: LD_VAR 0 2
25600: ARRAY
25601: PPUSH
25602: LD_INT 2
25604: PUSH
25605: LD_INT 30
25607: PUSH
25608: LD_INT 4
25610: PUSH
25611: EMPTY
25612: LIST
25613: LIST
25614: PUSH
25615: LD_INT 30
25617: PUSH
25618: LD_INT 5
25620: PUSH
25621: EMPTY
25622: LIST
25623: LIST
25624: PUSH
25625: EMPTY
25626: LIST
25627: LIST
25628: LIST
25629: PPUSH
25630: CALL_OW 72
25634: PUSH
25635: LD_EXP 76
25639: PUSH
25640: LD_VAR 0 2
25644: ARRAY
25645: PPUSH
25646: LD_INT 2
25648: PUSH
25649: LD_INT 30
25651: PUSH
25652: LD_INT 0
25654: PUSH
25655: EMPTY
25656: LIST
25657: LIST
25658: PUSH
25659: LD_INT 30
25661: PUSH
25662: LD_INT 1
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: LIST
25673: PPUSH
25674: CALL_OW 72
25678: PUSH
25679: LD_EXP 76
25683: PUSH
25684: LD_VAR 0 2
25688: ARRAY
25689: PPUSH
25690: LD_INT 30
25692: PUSH
25693: LD_INT 3
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PPUSH
25700: CALL_OW 72
25704: PUSH
25705: LD_EXP 76
25709: PUSH
25710: LD_VAR 0 2
25714: ARRAY
25715: PPUSH
25716: LD_INT 2
25718: PUSH
25719: LD_INT 30
25721: PUSH
25722: LD_INT 6
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: LD_INT 30
25731: PUSH
25732: LD_INT 7
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: LD_INT 30
25741: PUSH
25742: LD_INT 8
25744: PUSH
25745: EMPTY
25746: LIST
25747: LIST
25748: PUSH
25749: EMPTY
25750: LIST
25751: LIST
25752: LIST
25753: LIST
25754: PPUSH
25755: CALL_OW 72
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: LIST
25764: LIST
25765: ST_TO_ADDR
// for j = 1 to 4 do
25766: LD_ADDR_VAR 0 3
25770: PUSH
25771: DOUBLE
25772: LD_INT 1
25774: DEC
25775: ST_TO_ADDR
25776: LD_INT 4
25778: PUSH
25779: FOR_TO
25780: IFFALSE 25971
// begin if not tmp [ j ] then
25782: LD_VAR 0 4
25786: PUSH
25787: LD_VAR 0 3
25791: ARRAY
25792: NOT
25793: IFFALSE 25797
// continue ;
25795: GO 25779
// for p in tmp [ j ] do
25797: LD_ADDR_VAR 0 5
25801: PUSH
25802: LD_VAR 0 4
25806: PUSH
25807: LD_VAR 0 3
25811: ARRAY
25812: PUSH
25813: FOR_IN
25814: IFFALSE 25967
// begin if not b [ j ] then
25816: LD_VAR 0 6
25820: PUSH
25821: LD_VAR 0 3
25825: ARRAY
25826: NOT
25827: IFFALSE 25831
// break ;
25829: GO 25967
// e := 0 ;
25831: LD_ADDR_VAR 0 7
25835: PUSH
25836: LD_INT 0
25838: ST_TO_ADDR
// for k in b [ j ] do
25839: LD_ADDR_VAR 0 8
25843: PUSH
25844: LD_VAR 0 6
25848: PUSH
25849: LD_VAR 0 3
25853: ARRAY
25854: PUSH
25855: FOR_IN
25856: IFFALSE 25883
// if IsNotFull ( k ) then
25858: LD_VAR 0 8
25862: PPUSH
25863: CALL 54124 0 1
25867: IFFALSE 25881
// begin e := k ;
25869: LD_ADDR_VAR 0 7
25873: PUSH
25874: LD_VAR 0 8
25878: ST_TO_ADDR
// break ;
25879: GO 25883
// end ;
25881: GO 25855
25883: POP
25884: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25885: LD_VAR 0 7
25889: PUSH
25890: LD_VAR 0 5
25894: PPUSH
25895: LD_VAR 0 7
25899: PPUSH
25900: CALL 88003 0 2
25904: NOT
25905: AND
25906: IFFALSE 25965
// begin if IsInUnit ( p ) then
25908: LD_VAR 0 5
25912: PPUSH
25913: CALL_OW 310
25917: IFFALSE 25928
// ComExitBuilding ( p ) ;
25919: LD_VAR 0 5
25923: PPUSH
25924: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25928: LD_VAR 0 5
25932: PPUSH
25933: LD_VAR 0 7
25937: PPUSH
25938: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25942: LD_VAR 0 5
25946: PPUSH
25947: LD_VAR 0 3
25951: PPUSH
25952: CALL_OW 183
// AddComExitBuilding ( p ) ;
25956: LD_VAR 0 5
25960: PPUSH
25961: CALL_OW 182
// end ; end ;
25965: GO 25813
25967: POP
25968: POP
// end ;
25969: GO 25779
25971: POP
25972: POP
// end ;
25973: GO 25534
25975: POP
25976: POP
// end ;
25977: LD_VAR 0 1
25981: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25982: LD_INT 0
25984: PPUSH
25985: PPUSH
25986: PPUSH
25987: PPUSH
25988: PPUSH
25989: PPUSH
25990: PPUSH
25991: PPUSH
25992: PPUSH
25993: PPUSH
25994: PPUSH
25995: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25996: LD_VAR 0 1
26000: NOT
26001: PUSH
26002: LD_EXP 76
26006: PUSH
26007: LD_VAR 0 1
26011: ARRAY
26012: NOT
26013: OR
26014: PUSH
26015: LD_EXP 76
26019: PUSH
26020: LD_VAR 0 1
26024: ARRAY
26025: PPUSH
26026: LD_INT 2
26028: PUSH
26029: LD_INT 30
26031: PUSH
26032: LD_INT 0
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PUSH
26039: LD_INT 30
26041: PUSH
26042: LD_INT 1
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: LIST
26053: PPUSH
26054: CALL_OW 72
26058: NOT
26059: OR
26060: IFFALSE 26064
// exit ;
26062: GO 29567
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26064: LD_ADDR_VAR 0 4
26068: PUSH
26069: LD_EXP 76
26073: PUSH
26074: LD_VAR 0 1
26078: ARRAY
26079: PPUSH
26080: LD_INT 2
26082: PUSH
26083: LD_INT 25
26085: PUSH
26086: LD_INT 1
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 25
26095: PUSH
26096: LD_INT 2
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 25
26105: PUSH
26106: LD_INT 3
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 25
26115: PUSH
26116: LD_INT 4
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 25
26125: PUSH
26126: LD_INT 5
26128: PUSH
26129: EMPTY
26130: LIST
26131: LIST
26132: PUSH
26133: LD_INT 25
26135: PUSH
26136: LD_INT 8
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 25
26145: PUSH
26146: LD_INT 9
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PUSH
26153: EMPTY
26154: LIST
26155: LIST
26156: LIST
26157: LIST
26158: LIST
26159: LIST
26160: LIST
26161: LIST
26162: PPUSH
26163: CALL_OW 72
26167: ST_TO_ADDR
// if not tmp then
26168: LD_VAR 0 4
26172: NOT
26173: IFFALSE 26177
// exit ;
26175: GO 29567
// for i in tmp do
26177: LD_ADDR_VAR 0 3
26181: PUSH
26182: LD_VAR 0 4
26186: PUSH
26187: FOR_IN
26188: IFFALSE 26219
// if GetTag ( i ) then
26190: LD_VAR 0 3
26194: PPUSH
26195: CALL_OW 110
26199: IFFALSE 26217
// tmp := tmp diff i ;
26201: LD_ADDR_VAR 0 4
26205: PUSH
26206: LD_VAR 0 4
26210: PUSH
26211: LD_VAR 0 3
26215: DIFF
26216: ST_TO_ADDR
26217: GO 26187
26219: POP
26220: POP
// if not tmp then
26221: LD_VAR 0 4
26225: NOT
26226: IFFALSE 26230
// exit ;
26228: GO 29567
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26230: LD_ADDR_VAR 0 5
26234: PUSH
26235: LD_EXP 76
26239: PUSH
26240: LD_VAR 0 1
26244: ARRAY
26245: PPUSH
26246: LD_INT 2
26248: PUSH
26249: LD_INT 25
26251: PUSH
26252: LD_INT 1
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 25
26261: PUSH
26262: LD_INT 5
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PUSH
26269: LD_INT 25
26271: PUSH
26272: LD_INT 8
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 25
26281: PUSH
26282: LD_INT 9
26284: PUSH
26285: EMPTY
26286: LIST
26287: LIST
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: LIST
26293: LIST
26294: LIST
26295: PPUSH
26296: CALL_OW 72
26300: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26301: LD_ADDR_VAR 0 6
26305: PUSH
26306: LD_EXP 76
26310: PUSH
26311: LD_VAR 0 1
26315: ARRAY
26316: PPUSH
26317: LD_INT 25
26319: PUSH
26320: LD_INT 2
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PPUSH
26327: CALL_OW 72
26331: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26332: LD_ADDR_VAR 0 7
26336: PUSH
26337: LD_EXP 76
26341: PUSH
26342: LD_VAR 0 1
26346: ARRAY
26347: PPUSH
26348: LD_INT 25
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PPUSH
26358: CALL_OW 72
26362: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26363: LD_ADDR_VAR 0 8
26367: PUSH
26368: LD_EXP 76
26372: PUSH
26373: LD_VAR 0 1
26377: ARRAY
26378: PPUSH
26379: LD_INT 25
26381: PUSH
26382: LD_INT 4
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PUSH
26389: LD_INT 24
26391: PUSH
26392: LD_INT 251
26394: PUSH
26395: EMPTY
26396: LIST
26397: LIST
26398: PUSH
26399: EMPTY
26400: LIST
26401: LIST
26402: PPUSH
26403: CALL_OW 72
26407: ST_TO_ADDR
// if mc_is_defending [ base ] then
26408: LD_EXP 119
26412: PUSH
26413: LD_VAR 0 1
26417: ARRAY
26418: IFFALSE 26879
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26420: LD_ADDR_EXP 118
26424: PUSH
26425: LD_EXP 118
26429: PPUSH
26430: LD_VAR 0 1
26434: PPUSH
26435: LD_INT 4
26437: PPUSH
26438: CALL_OW 1
26442: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26443: LD_ADDR_VAR 0 12
26447: PUSH
26448: LD_EXP 76
26452: PUSH
26453: LD_VAR 0 1
26457: ARRAY
26458: PPUSH
26459: LD_INT 2
26461: PUSH
26462: LD_INT 30
26464: PUSH
26465: LD_INT 4
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 30
26474: PUSH
26475: LD_INT 5
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: LIST
26486: PPUSH
26487: CALL_OW 72
26491: ST_TO_ADDR
// if not b then
26492: LD_VAR 0 12
26496: NOT
26497: IFFALSE 26501
// exit ;
26499: GO 29567
// p := [ ] ;
26501: LD_ADDR_VAR 0 11
26505: PUSH
26506: EMPTY
26507: ST_TO_ADDR
// if sci >= 2 then
26508: LD_VAR 0 8
26512: PUSH
26513: LD_INT 2
26515: GREATEREQUAL
26516: IFFALSE 26547
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26518: LD_ADDR_VAR 0 8
26522: PUSH
26523: LD_VAR 0 8
26527: PUSH
26528: LD_INT 1
26530: ARRAY
26531: PUSH
26532: LD_VAR 0 8
26536: PUSH
26537: LD_INT 2
26539: ARRAY
26540: PUSH
26541: EMPTY
26542: LIST
26543: LIST
26544: ST_TO_ADDR
26545: GO 26608
// if sci = 1 then
26547: LD_VAR 0 8
26551: PUSH
26552: LD_INT 1
26554: EQUAL
26555: IFFALSE 26576
// sci := [ sci [ 1 ] ] else
26557: LD_ADDR_VAR 0 8
26561: PUSH
26562: LD_VAR 0 8
26566: PUSH
26567: LD_INT 1
26569: ARRAY
26570: PUSH
26571: EMPTY
26572: LIST
26573: ST_TO_ADDR
26574: GO 26608
// if sci = 0 then
26576: LD_VAR 0 8
26580: PUSH
26581: LD_INT 0
26583: EQUAL
26584: IFFALSE 26608
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26586: LD_ADDR_VAR 0 11
26590: PUSH
26591: LD_VAR 0 4
26595: PPUSH
26596: LD_INT 4
26598: PPUSH
26599: CALL 87866 0 2
26603: PUSH
26604: LD_INT 1
26606: ARRAY
26607: ST_TO_ADDR
// if eng > 4 then
26608: LD_VAR 0 6
26612: PUSH
26613: LD_INT 4
26615: GREATER
26616: IFFALSE 26662
// for i = eng downto 4 do
26618: LD_ADDR_VAR 0 3
26622: PUSH
26623: DOUBLE
26624: LD_VAR 0 6
26628: INC
26629: ST_TO_ADDR
26630: LD_INT 4
26632: PUSH
26633: FOR_DOWNTO
26634: IFFALSE 26660
// eng := eng diff eng [ i ] ;
26636: LD_ADDR_VAR 0 6
26640: PUSH
26641: LD_VAR 0 6
26645: PUSH
26646: LD_VAR 0 6
26650: PUSH
26651: LD_VAR 0 3
26655: ARRAY
26656: DIFF
26657: ST_TO_ADDR
26658: GO 26633
26660: POP
26661: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26662: LD_ADDR_VAR 0 4
26666: PUSH
26667: LD_VAR 0 4
26671: PUSH
26672: LD_VAR 0 5
26676: PUSH
26677: LD_VAR 0 6
26681: UNION
26682: PUSH
26683: LD_VAR 0 7
26687: UNION
26688: PUSH
26689: LD_VAR 0 8
26693: UNION
26694: DIFF
26695: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26696: LD_ADDR_VAR 0 13
26700: PUSH
26701: LD_EXP 76
26705: PUSH
26706: LD_VAR 0 1
26710: ARRAY
26711: PPUSH
26712: LD_INT 2
26714: PUSH
26715: LD_INT 30
26717: PUSH
26718: LD_INT 32
26720: PUSH
26721: EMPTY
26722: LIST
26723: LIST
26724: PUSH
26725: LD_INT 30
26727: PUSH
26728: LD_INT 31
26730: PUSH
26731: EMPTY
26732: LIST
26733: LIST
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: LIST
26739: PPUSH
26740: CALL_OW 72
26744: PUSH
26745: LD_EXP 76
26749: PUSH
26750: LD_VAR 0 1
26754: ARRAY
26755: PPUSH
26756: LD_INT 2
26758: PUSH
26759: LD_INT 30
26761: PUSH
26762: LD_INT 4
26764: PUSH
26765: EMPTY
26766: LIST
26767: LIST
26768: PUSH
26769: LD_INT 30
26771: PUSH
26772: LD_INT 5
26774: PUSH
26775: EMPTY
26776: LIST
26777: LIST
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: LIST
26783: PPUSH
26784: CALL_OW 72
26788: PUSH
26789: LD_INT 6
26791: MUL
26792: PLUS
26793: ST_TO_ADDR
// if bcount < tmp then
26794: LD_VAR 0 13
26798: PUSH
26799: LD_VAR 0 4
26803: LESS
26804: IFFALSE 26850
// for i = tmp downto bcount do
26806: LD_ADDR_VAR 0 3
26810: PUSH
26811: DOUBLE
26812: LD_VAR 0 4
26816: INC
26817: ST_TO_ADDR
26818: LD_VAR 0 13
26822: PUSH
26823: FOR_DOWNTO
26824: IFFALSE 26848
// tmp := Delete ( tmp , tmp ) ;
26826: LD_ADDR_VAR 0 4
26830: PUSH
26831: LD_VAR 0 4
26835: PPUSH
26836: LD_VAR 0 4
26840: PPUSH
26841: CALL_OW 3
26845: ST_TO_ADDR
26846: GO 26823
26848: POP
26849: POP
// result := [ tmp , 0 , 0 , p ] ;
26850: LD_ADDR_VAR 0 2
26854: PUSH
26855: LD_VAR 0 4
26859: PUSH
26860: LD_INT 0
26862: PUSH
26863: LD_INT 0
26865: PUSH
26866: LD_VAR 0 11
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: LIST
26875: LIST
26876: ST_TO_ADDR
// exit ;
26877: GO 29567
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26879: LD_EXP 76
26883: PUSH
26884: LD_VAR 0 1
26888: ARRAY
26889: PPUSH
26890: LD_INT 2
26892: PUSH
26893: LD_INT 30
26895: PUSH
26896: LD_INT 6
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PUSH
26903: LD_INT 30
26905: PUSH
26906: LD_INT 7
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: LD_INT 30
26915: PUSH
26916: LD_INT 8
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: LIST
26927: LIST
26928: PPUSH
26929: CALL_OW 72
26933: NOT
26934: PUSH
26935: LD_EXP 76
26939: PUSH
26940: LD_VAR 0 1
26944: ARRAY
26945: PPUSH
26946: LD_INT 30
26948: PUSH
26949: LD_INT 3
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PPUSH
26956: CALL_OW 72
26960: NOT
26961: AND
26962: IFFALSE 27034
// begin if eng = tmp then
26964: LD_VAR 0 6
26968: PUSH
26969: LD_VAR 0 4
26973: EQUAL
26974: IFFALSE 26978
// exit ;
26976: GO 29567
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26978: LD_ADDR_EXP 118
26982: PUSH
26983: LD_EXP 118
26987: PPUSH
26988: LD_VAR 0 1
26992: PPUSH
26993: LD_INT 1
26995: PPUSH
26996: CALL_OW 1
27000: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27001: LD_ADDR_VAR 0 2
27005: PUSH
27006: LD_INT 0
27008: PUSH
27009: LD_VAR 0 4
27013: PUSH
27014: LD_VAR 0 6
27018: DIFF
27019: PUSH
27020: LD_INT 0
27022: PUSH
27023: LD_INT 0
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: LIST
27030: LIST
27031: ST_TO_ADDR
// exit ;
27032: GO 29567
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27034: LD_EXP 103
27038: PUSH
27039: LD_EXP 102
27043: PUSH
27044: LD_VAR 0 1
27048: ARRAY
27049: ARRAY
27050: PUSH
27051: LD_EXP 76
27055: PUSH
27056: LD_VAR 0 1
27060: ARRAY
27061: PPUSH
27062: LD_INT 2
27064: PUSH
27065: LD_INT 30
27067: PUSH
27068: LD_INT 6
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: LD_INT 30
27077: PUSH
27078: LD_INT 7
27080: PUSH
27081: EMPTY
27082: LIST
27083: LIST
27084: PUSH
27085: LD_INT 30
27087: PUSH
27088: LD_INT 8
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: PPUSH
27101: CALL_OW 72
27105: AND
27106: PUSH
27107: LD_EXP 76
27111: PUSH
27112: LD_VAR 0 1
27116: ARRAY
27117: PPUSH
27118: LD_INT 30
27120: PUSH
27121: LD_INT 3
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PPUSH
27128: CALL_OW 72
27132: NOT
27133: AND
27134: IFFALSE 27348
// begin if sci >= 6 then
27136: LD_VAR 0 8
27140: PUSH
27141: LD_INT 6
27143: GREATEREQUAL
27144: IFFALSE 27148
// exit ;
27146: GO 29567
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27148: LD_ADDR_EXP 118
27152: PUSH
27153: LD_EXP 118
27157: PPUSH
27158: LD_VAR 0 1
27162: PPUSH
27163: LD_INT 2
27165: PPUSH
27166: CALL_OW 1
27170: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27171: LD_ADDR_VAR 0 9
27175: PUSH
27176: LD_VAR 0 4
27180: PUSH
27181: LD_VAR 0 8
27185: DIFF
27186: PPUSH
27187: LD_INT 4
27189: PPUSH
27190: CALL 87866 0 2
27194: ST_TO_ADDR
// p := [ ] ;
27195: LD_ADDR_VAR 0 11
27199: PUSH
27200: EMPTY
27201: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27202: LD_VAR 0 8
27206: PUSH
27207: LD_INT 6
27209: LESS
27210: PUSH
27211: LD_VAR 0 9
27215: PUSH
27216: LD_INT 6
27218: GREATER
27219: AND
27220: IFFALSE 27301
// begin for i = 1 to 6 - sci do
27222: LD_ADDR_VAR 0 3
27226: PUSH
27227: DOUBLE
27228: LD_INT 1
27230: DEC
27231: ST_TO_ADDR
27232: LD_INT 6
27234: PUSH
27235: LD_VAR 0 8
27239: MINUS
27240: PUSH
27241: FOR_TO
27242: IFFALSE 27297
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27244: LD_ADDR_VAR 0 11
27248: PUSH
27249: LD_VAR 0 11
27253: PPUSH
27254: LD_VAR 0 11
27258: PUSH
27259: LD_INT 1
27261: PLUS
27262: PPUSH
27263: LD_VAR 0 9
27267: PUSH
27268: LD_INT 1
27270: ARRAY
27271: PPUSH
27272: CALL_OW 2
27276: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27277: LD_ADDR_VAR 0 9
27281: PUSH
27282: LD_VAR 0 9
27286: PPUSH
27287: LD_INT 1
27289: PPUSH
27290: CALL_OW 3
27294: ST_TO_ADDR
// end ;
27295: GO 27241
27297: POP
27298: POP
// end else
27299: GO 27321
// if sort then
27301: LD_VAR 0 9
27305: IFFALSE 27321
// p := sort [ 1 ] ;
27307: LD_ADDR_VAR 0 11
27311: PUSH
27312: LD_VAR 0 9
27316: PUSH
27317: LD_INT 1
27319: ARRAY
27320: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27321: LD_ADDR_VAR 0 2
27325: PUSH
27326: LD_INT 0
27328: PUSH
27329: LD_INT 0
27331: PUSH
27332: LD_INT 0
27334: PUSH
27335: LD_VAR 0 11
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: LIST
27344: LIST
27345: ST_TO_ADDR
// exit ;
27346: GO 29567
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27348: LD_EXP 103
27352: PUSH
27353: LD_EXP 102
27357: PUSH
27358: LD_VAR 0 1
27362: ARRAY
27363: ARRAY
27364: PUSH
27365: LD_EXP 76
27369: PUSH
27370: LD_VAR 0 1
27374: ARRAY
27375: PPUSH
27376: LD_INT 2
27378: PUSH
27379: LD_INT 30
27381: PUSH
27382: LD_INT 6
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: LD_INT 30
27391: PUSH
27392: LD_INT 7
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 30
27401: PUSH
27402: LD_INT 8
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: EMPTY
27410: LIST
27411: LIST
27412: LIST
27413: LIST
27414: PPUSH
27415: CALL_OW 72
27419: AND
27420: PUSH
27421: LD_EXP 76
27425: PUSH
27426: LD_VAR 0 1
27430: ARRAY
27431: PPUSH
27432: LD_INT 30
27434: PUSH
27435: LD_INT 3
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PPUSH
27442: CALL_OW 72
27446: AND
27447: IFFALSE 28181
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27449: LD_ADDR_EXP 118
27453: PUSH
27454: LD_EXP 118
27458: PPUSH
27459: LD_VAR 0 1
27463: PPUSH
27464: LD_INT 3
27466: PPUSH
27467: CALL_OW 1
27471: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27472: LD_ADDR_VAR 0 2
27476: PUSH
27477: LD_INT 0
27479: PUSH
27480: LD_INT 0
27482: PUSH
27483: LD_INT 0
27485: PUSH
27486: LD_INT 0
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: LIST
27493: LIST
27494: ST_TO_ADDR
// if not eng then
27495: LD_VAR 0 6
27499: NOT
27500: IFFALSE 27563
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27502: LD_ADDR_VAR 0 11
27506: PUSH
27507: LD_VAR 0 4
27511: PPUSH
27512: LD_INT 2
27514: PPUSH
27515: CALL 87866 0 2
27519: PUSH
27520: LD_INT 1
27522: ARRAY
27523: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27524: LD_ADDR_VAR 0 2
27528: PUSH
27529: LD_VAR 0 2
27533: PPUSH
27534: LD_INT 2
27536: PPUSH
27537: LD_VAR 0 11
27541: PPUSH
27542: CALL_OW 1
27546: ST_TO_ADDR
// tmp := tmp diff p ;
27547: LD_ADDR_VAR 0 4
27551: PUSH
27552: LD_VAR 0 4
27556: PUSH
27557: LD_VAR 0 11
27561: DIFF
27562: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27563: LD_VAR 0 4
27567: PUSH
27568: LD_VAR 0 8
27572: PUSH
27573: LD_INT 6
27575: LESS
27576: AND
27577: IFFALSE 27765
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27579: LD_ADDR_VAR 0 9
27583: PUSH
27584: LD_VAR 0 4
27588: PUSH
27589: LD_VAR 0 8
27593: PUSH
27594: LD_VAR 0 7
27598: UNION
27599: DIFF
27600: PPUSH
27601: LD_INT 4
27603: PPUSH
27604: CALL 87866 0 2
27608: ST_TO_ADDR
// p := [ ] ;
27609: LD_ADDR_VAR 0 11
27613: PUSH
27614: EMPTY
27615: ST_TO_ADDR
// if sort then
27616: LD_VAR 0 9
27620: IFFALSE 27736
// for i = 1 to 6 - sci do
27622: LD_ADDR_VAR 0 3
27626: PUSH
27627: DOUBLE
27628: LD_INT 1
27630: DEC
27631: ST_TO_ADDR
27632: LD_INT 6
27634: PUSH
27635: LD_VAR 0 8
27639: MINUS
27640: PUSH
27641: FOR_TO
27642: IFFALSE 27734
// begin if i = sort then
27644: LD_VAR 0 3
27648: PUSH
27649: LD_VAR 0 9
27653: EQUAL
27654: IFFALSE 27658
// break ;
27656: GO 27734
// if GetClass ( i ) = 4 then
27658: LD_VAR 0 3
27662: PPUSH
27663: CALL_OW 257
27667: PUSH
27668: LD_INT 4
27670: EQUAL
27671: IFFALSE 27675
// continue ;
27673: GO 27641
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27675: LD_ADDR_VAR 0 11
27679: PUSH
27680: LD_VAR 0 11
27684: PPUSH
27685: LD_VAR 0 11
27689: PUSH
27690: LD_INT 1
27692: PLUS
27693: PPUSH
27694: LD_VAR 0 9
27698: PUSH
27699: LD_VAR 0 3
27703: ARRAY
27704: PPUSH
27705: CALL_OW 2
27709: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27710: LD_ADDR_VAR 0 4
27714: PUSH
27715: LD_VAR 0 4
27719: PUSH
27720: LD_VAR 0 9
27724: PUSH
27725: LD_VAR 0 3
27729: ARRAY
27730: DIFF
27731: ST_TO_ADDR
// end ;
27732: GO 27641
27734: POP
27735: POP
// if p then
27736: LD_VAR 0 11
27740: IFFALSE 27765
// result := Replace ( result , 4 , p ) ;
27742: LD_ADDR_VAR 0 2
27746: PUSH
27747: LD_VAR 0 2
27751: PPUSH
27752: LD_INT 4
27754: PPUSH
27755: LD_VAR 0 11
27759: PPUSH
27760: CALL_OW 1
27764: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27765: LD_VAR 0 4
27769: PUSH
27770: LD_VAR 0 7
27774: PUSH
27775: LD_INT 6
27777: LESS
27778: AND
27779: IFFALSE 27967
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27781: LD_ADDR_VAR 0 9
27785: PUSH
27786: LD_VAR 0 4
27790: PUSH
27791: LD_VAR 0 8
27795: PUSH
27796: LD_VAR 0 7
27800: UNION
27801: DIFF
27802: PPUSH
27803: LD_INT 3
27805: PPUSH
27806: CALL 87866 0 2
27810: ST_TO_ADDR
// p := [ ] ;
27811: LD_ADDR_VAR 0 11
27815: PUSH
27816: EMPTY
27817: ST_TO_ADDR
// if sort then
27818: LD_VAR 0 9
27822: IFFALSE 27938
// for i = 1 to 6 - mech do
27824: LD_ADDR_VAR 0 3
27828: PUSH
27829: DOUBLE
27830: LD_INT 1
27832: DEC
27833: ST_TO_ADDR
27834: LD_INT 6
27836: PUSH
27837: LD_VAR 0 7
27841: MINUS
27842: PUSH
27843: FOR_TO
27844: IFFALSE 27936
// begin if i = sort then
27846: LD_VAR 0 3
27850: PUSH
27851: LD_VAR 0 9
27855: EQUAL
27856: IFFALSE 27860
// break ;
27858: GO 27936
// if GetClass ( i ) = 3 then
27860: LD_VAR 0 3
27864: PPUSH
27865: CALL_OW 257
27869: PUSH
27870: LD_INT 3
27872: EQUAL
27873: IFFALSE 27877
// continue ;
27875: GO 27843
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27877: LD_ADDR_VAR 0 11
27881: PUSH
27882: LD_VAR 0 11
27886: PPUSH
27887: LD_VAR 0 11
27891: PUSH
27892: LD_INT 1
27894: PLUS
27895: PPUSH
27896: LD_VAR 0 9
27900: PUSH
27901: LD_VAR 0 3
27905: ARRAY
27906: PPUSH
27907: CALL_OW 2
27911: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27912: LD_ADDR_VAR 0 4
27916: PUSH
27917: LD_VAR 0 4
27921: PUSH
27922: LD_VAR 0 9
27926: PUSH
27927: LD_VAR 0 3
27931: ARRAY
27932: DIFF
27933: ST_TO_ADDR
// end ;
27934: GO 27843
27936: POP
27937: POP
// if p then
27938: LD_VAR 0 11
27942: IFFALSE 27967
// result := Replace ( result , 3 , p ) ;
27944: LD_ADDR_VAR 0 2
27948: PUSH
27949: LD_VAR 0 2
27953: PPUSH
27954: LD_INT 3
27956: PPUSH
27957: LD_VAR 0 11
27961: PPUSH
27962: CALL_OW 1
27966: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27967: LD_VAR 0 4
27971: PUSH
27972: LD_INT 6
27974: GREATER
27975: PUSH
27976: LD_VAR 0 6
27980: PUSH
27981: LD_INT 6
27983: LESS
27984: AND
27985: IFFALSE 28179
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27987: LD_ADDR_VAR 0 9
27991: PUSH
27992: LD_VAR 0 4
27996: PUSH
27997: LD_VAR 0 8
28001: PUSH
28002: LD_VAR 0 7
28006: UNION
28007: PUSH
28008: LD_VAR 0 6
28012: UNION
28013: DIFF
28014: PPUSH
28015: LD_INT 2
28017: PPUSH
28018: CALL 87866 0 2
28022: ST_TO_ADDR
// p := [ ] ;
28023: LD_ADDR_VAR 0 11
28027: PUSH
28028: EMPTY
28029: ST_TO_ADDR
// if sort then
28030: LD_VAR 0 9
28034: IFFALSE 28150
// for i = 1 to 6 - eng do
28036: LD_ADDR_VAR 0 3
28040: PUSH
28041: DOUBLE
28042: LD_INT 1
28044: DEC
28045: ST_TO_ADDR
28046: LD_INT 6
28048: PUSH
28049: LD_VAR 0 6
28053: MINUS
28054: PUSH
28055: FOR_TO
28056: IFFALSE 28148
// begin if i = sort then
28058: LD_VAR 0 3
28062: PUSH
28063: LD_VAR 0 9
28067: EQUAL
28068: IFFALSE 28072
// break ;
28070: GO 28148
// if GetClass ( i ) = 2 then
28072: LD_VAR 0 3
28076: PPUSH
28077: CALL_OW 257
28081: PUSH
28082: LD_INT 2
28084: EQUAL
28085: IFFALSE 28089
// continue ;
28087: GO 28055
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28089: LD_ADDR_VAR 0 11
28093: PUSH
28094: LD_VAR 0 11
28098: PPUSH
28099: LD_VAR 0 11
28103: PUSH
28104: LD_INT 1
28106: PLUS
28107: PPUSH
28108: LD_VAR 0 9
28112: PUSH
28113: LD_VAR 0 3
28117: ARRAY
28118: PPUSH
28119: CALL_OW 2
28123: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28124: LD_ADDR_VAR 0 4
28128: PUSH
28129: LD_VAR 0 4
28133: PUSH
28134: LD_VAR 0 9
28138: PUSH
28139: LD_VAR 0 3
28143: ARRAY
28144: DIFF
28145: ST_TO_ADDR
// end ;
28146: GO 28055
28148: POP
28149: POP
// if p then
28150: LD_VAR 0 11
28154: IFFALSE 28179
// result := Replace ( result , 2 , p ) ;
28156: LD_ADDR_VAR 0 2
28160: PUSH
28161: LD_VAR 0 2
28165: PPUSH
28166: LD_INT 2
28168: PPUSH
28169: LD_VAR 0 11
28173: PPUSH
28174: CALL_OW 1
28178: ST_TO_ADDR
// end ; exit ;
28179: GO 29567
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28181: LD_EXP 103
28185: PUSH
28186: LD_EXP 102
28190: PUSH
28191: LD_VAR 0 1
28195: ARRAY
28196: ARRAY
28197: NOT
28198: PUSH
28199: LD_EXP 76
28203: PUSH
28204: LD_VAR 0 1
28208: ARRAY
28209: PPUSH
28210: LD_INT 30
28212: PUSH
28213: LD_INT 3
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: PPUSH
28220: CALL_OW 72
28224: AND
28225: PUSH
28226: LD_EXP 81
28230: PUSH
28231: LD_VAR 0 1
28235: ARRAY
28236: AND
28237: IFFALSE 28845
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28239: LD_ADDR_EXP 118
28243: PUSH
28244: LD_EXP 118
28248: PPUSH
28249: LD_VAR 0 1
28253: PPUSH
28254: LD_INT 5
28256: PPUSH
28257: CALL_OW 1
28261: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28262: LD_ADDR_VAR 0 2
28266: PUSH
28267: LD_INT 0
28269: PUSH
28270: LD_INT 0
28272: PUSH
28273: LD_INT 0
28275: PUSH
28276: LD_INT 0
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: LIST
28283: LIST
28284: ST_TO_ADDR
// if sci > 1 then
28285: LD_VAR 0 8
28289: PUSH
28290: LD_INT 1
28292: GREATER
28293: IFFALSE 28321
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28295: LD_ADDR_VAR 0 4
28299: PUSH
28300: LD_VAR 0 4
28304: PUSH
28305: LD_VAR 0 8
28309: PUSH
28310: LD_VAR 0 8
28314: PUSH
28315: LD_INT 1
28317: ARRAY
28318: DIFF
28319: DIFF
28320: ST_TO_ADDR
// if tmp and not sci then
28321: LD_VAR 0 4
28325: PUSH
28326: LD_VAR 0 8
28330: NOT
28331: AND
28332: IFFALSE 28401
// begin sort := SortBySkill ( tmp , 4 ) ;
28334: LD_ADDR_VAR 0 9
28338: PUSH
28339: LD_VAR 0 4
28343: PPUSH
28344: LD_INT 4
28346: PPUSH
28347: CALL 87866 0 2
28351: ST_TO_ADDR
// if sort then
28352: LD_VAR 0 9
28356: IFFALSE 28372
// p := sort [ 1 ] ;
28358: LD_ADDR_VAR 0 11
28362: PUSH
28363: LD_VAR 0 9
28367: PUSH
28368: LD_INT 1
28370: ARRAY
28371: ST_TO_ADDR
// if p then
28372: LD_VAR 0 11
28376: IFFALSE 28401
// result := Replace ( result , 4 , p ) ;
28378: LD_ADDR_VAR 0 2
28382: PUSH
28383: LD_VAR 0 2
28387: PPUSH
28388: LD_INT 4
28390: PPUSH
28391: LD_VAR 0 11
28395: PPUSH
28396: CALL_OW 1
28400: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28401: LD_ADDR_VAR 0 4
28405: PUSH
28406: LD_VAR 0 4
28410: PUSH
28411: LD_VAR 0 7
28415: DIFF
28416: ST_TO_ADDR
// if tmp and mech < 6 then
28417: LD_VAR 0 4
28421: PUSH
28422: LD_VAR 0 7
28426: PUSH
28427: LD_INT 6
28429: LESS
28430: AND
28431: IFFALSE 28619
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28433: LD_ADDR_VAR 0 9
28437: PUSH
28438: LD_VAR 0 4
28442: PUSH
28443: LD_VAR 0 8
28447: PUSH
28448: LD_VAR 0 7
28452: UNION
28453: DIFF
28454: PPUSH
28455: LD_INT 3
28457: PPUSH
28458: CALL 87866 0 2
28462: ST_TO_ADDR
// p := [ ] ;
28463: LD_ADDR_VAR 0 11
28467: PUSH
28468: EMPTY
28469: ST_TO_ADDR
// if sort then
28470: LD_VAR 0 9
28474: IFFALSE 28590
// for i = 1 to 6 - mech do
28476: LD_ADDR_VAR 0 3
28480: PUSH
28481: DOUBLE
28482: LD_INT 1
28484: DEC
28485: ST_TO_ADDR
28486: LD_INT 6
28488: PUSH
28489: LD_VAR 0 7
28493: MINUS
28494: PUSH
28495: FOR_TO
28496: IFFALSE 28588
// begin if i = sort then
28498: LD_VAR 0 3
28502: PUSH
28503: LD_VAR 0 9
28507: EQUAL
28508: IFFALSE 28512
// break ;
28510: GO 28588
// if GetClass ( i ) = 3 then
28512: LD_VAR 0 3
28516: PPUSH
28517: CALL_OW 257
28521: PUSH
28522: LD_INT 3
28524: EQUAL
28525: IFFALSE 28529
// continue ;
28527: GO 28495
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28529: LD_ADDR_VAR 0 11
28533: PUSH
28534: LD_VAR 0 11
28538: PPUSH
28539: LD_VAR 0 11
28543: PUSH
28544: LD_INT 1
28546: PLUS
28547: PPUSH
28548: LD_VAR 0 9
28552: PUSH
28553: LD_VAR 0 3
28557: ARRAY
28558: PPUSH
28559: CALL_OW 2
28563: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28564: LD_ADDR_VAR 0 4
28568: PUSH
28569: LD_VAR 0 4
28573: PUSH
28574: LD_VAR 0 9
28578: PUSH
28579: LD_VAR 0 3
28583: ARRAY
28584: DIFF
28585: ST_TO_ADDR
// end ;
28586: GO 28495
28588: POP
28589: POP
// if p then
28590: LD_VAR 0 11
28594: IFFALSE 28619
// result := Replace ( result , 3 , p ) ;
28596: LD_ADDR_VAR 0 2
28600: PUSH
28601: LD_VAR 0 2
28605: PPUSH
28606: LD_INT 3
28608: PPUSH
28609: LD_VAR 0 11
28613: PPUSH
28614: CALL_OW 1
28618: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28619: LD_ADDR_VAR 0 4
28623: PUSH
28624: LD_VAR 0 4
28628: PUSH
28629: LD_VAR 0 6
28633: DIFF
28634: ST_TO_ADDR
// if tmp and eng < 6 then
28635: LD_VAR 0 4
28639: PUSH
28640: LD_VAR 0 6
28644: PUSH
28645: LD_INT 6
28647: LESS
28648: AND
28649: IFFALSE 28843
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28651: LD_ADDR_VAR 0 9
28655: PUSH
28656: LD_VAR 0 4
28660: PUSH
28661: LD_VAR 0 8
28665: PUSH
28666: LD_VAR 0 7
28670: UNION
28671: PUSH
28672: LD_VAR 0 6
28676: UNION
28677: DIFF
28678: PPUSH
28679: LD_INT 2
28681: PPUSH
28682: CALL 87866 0 2
28686: ST_TO_ADDR
// p := [ ] ;
28687: LD_ADDR_VAR 0 11
28691: PUSH
28692: EMPTY
28693: ST_TO_ADDR
// if sort then
28694: LD_VAR 0 9
28698: IFFALSE 28814
// for i = 1 to 6 - eng do
28700: LD_ADDR_VAR 0 3
28704: PUSH
28705: DOUBLE
28706: LD_INT 1
28708: DEC
28709: ST_TO_ADDR
28710: LD_INT 6
28712: PUSH
28713: LD_VAR 0 6
28717: MINUS
28718: PUSH
28719: FOR_TO
28720: IFFALSE 28812
// begin if i = sort then
28722: LD_VAR 0 3
28726: PUSH
28727: LD_VAR 0 9
28731: EQUAL
28732: IFFALSE 28736
// break ;
28734: GO 28812
// if GetClass ( i ) = 2 then
28736: LD_VAR 0 3
28740: PPUSH
28741: CALL_OW 257
28745: PUSH
28746: LD_INT 2
28748: EQUAL
28749: IFFALSE 28753
// continue ;
28751: GO 28719
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28753: LD_ADDR_VAR 0 11
28757: PUSH
28758: LD_VAR 0 11
28762: PPUSH
28763: LD_VAR 0 11
28767: PUSH
28768: LD_INT 1
28770: PLUS
28771: PPUSH
28772: LD_VAR 0 9
28776: PUSH
28777: LD_VAR 0 3
28781: ARRAY
28782: PPUSH
28783: CALL_OW 2
28787: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28788: LD_ADDR_VAR 0 4
28792: PUSH
28793: LD_VAR 0 4
28797: PUSH
28798: LD_VAR 0 9
28802: PUSH
28803: LD_VAR 0 3
28807: ARRAY
28808: DIFF
28809: ST_TO_ADDR
// end ;
28810: GO 28719
28812: POP
28813: POP
// if p then
28814: LD_VAR 0 11
28818: IFFALSE 28843
// result := Replace ( result , 2 , p ) ;
28820: LD_ADDR_VAR 0 2
28824: PUSH
28825: LD_VAR 0 2
28829: PPUSH
28830: LD_INT 2
28832: PPUSH
28833: LD_VAR 0 11
28837: PPUSH
28838: CALL_OW 1
28842: ST_TO_ADDR
// end ; exit ;
28843: GO 29567
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28845: LD_EXP 103
28849: PUSH
28850: LD_EXP 102
28854: PUSH
28855: LD_VAR 0 1
28859: ARRAY
28860: ARRAY
28861: NOT
28862: PUSH
28863: LD_EXP 76
28867: PUSH
28868: LD_VAR 0 1
28872: ARRAY
28873: PPUSH
28874: LD_INT 30
28876: PUSH
28877: LD_INT 3
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PPUSH
28884: CALL_OW 72
28888: AND
28889: PUSH
28890: LD_EXP 81
28894: PUSH
28895: LD_VAR 0 1
28899: ARRAY
28900: NOT
28901: AND
28902: IFFALSE 29567
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28904: LD_ADDR_EXP 118
28908: PUSH
28909: LD_EXP 118
28913: PPUSH
28914: LD_VAR 0 1
28918: PPUSH
28919: LD_INT 6
28921: PPUSH
28922: CALL_OW 1
28926: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28927: LD_ADDR_VAR 0 2
28931: PUSH
28932: LD_INT 0
28934: PUSH
28935: LD_INT 0
28937: PUSH
28938: LD_INT 0
28940: PUSH
28941: LD_INT 0
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: ST_TO_ADDR
// if sci >= 1 then
28950: LD_VAR 0 8
28954: PUSH
28955: LD_INT 1
28957: GREATEREQUAL
28958: IFFALSE 28980
// tmp := tmp diff sci [ 1 ] ;
28960: LD_ADDR_VAR 0 4
28964: PUSH
28965: LD_VAR 0 4
28969: PUSH
28970: LD_VAR 0 8
28974: PUSH
28975: LD_INT 1
28977: ARRAY
28978: DIFF
28979: ST_TO_ADDR
// if tmp and not sci then
28980: LD_VAR 0 4
28984: PUSH
28985: LD_VAR 0 8
28989: NOT
28990: AND
28991: IFFALSE 29060
// begin sort := SortBySkill ( tmp , 4 ) ;
28993: LD_ADDR_VAR 0 9
28997: PUSH
28998: LD_VAR 0 4
29002: PPUSH
29003: LD_INT 4
29005: PPUSH
29006: CALL 87866 0 2
29010: ST_TO_ADDR
// if sort then
29011: LD_VAR 0 9
29015: IFFALSE 29031
// p := sort [ 1 ] ;
29017: LD_ADDR_VAR 0 11
29021: PUSH
29022: LD_VAR 0 9
29026: PUSH
29027: LD_INT 1
29029: ARRAY
29030: ST_TO_ADDR
// if p then
29031: LD_VAR 0 11
29035: IFFALSE 29060
// result := Replace ( result , 4 , p ) ;
29037: LD_ADDR_VAR 0 2
29041: PUSH
29042: LD_VAR 0 2
29046: PPUSH
29047: LD_INT 4
29049: PPUSH
29050: LD_VAR 0 11
29054: PPUSH
29055: CALL_OW 1
29059: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29060: LD_ADDR_VAR 0 4
29064: PUSH
29065: LD_VAR 0 4
29069: PUSH
29070: LD_VAR 0 7
29074: DIFF
29075: ST_TO_ADDR
// if tmp and mech < 6 then
29076: LD_VAR 0 4
29080: PUSH
29081: LD_VAR 0 7
29085: PUSH
29086: LD_INT 6
29088: LESS
29089: AND
29090: IFFALSE 29272
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29092: LD_ADDR_VAR 0 9
29096: PUSH
29097: LD_VAR 0 4
29101: PUSH
29102: LD_VAR 0 7
29106: DIFF
29107: PPUSH
29108: LD_INT 3
29110: PPUSH
29111: CALL 87866 0 2
29115: ST_TO_ADDR
// p := [ ] ;
29116: LD_ADDR_VAR 0 11
29120: PUSH
29121: EMPTY
29122: ST_TO_ADDR
// if sort then
29123: LD_VAR 0 9
29127: IFFALSE 29243
// for i = 1 to 6 - mech do
29129: LD_ADDR_VAR 0 3
29133: PUSH
29134: DOUBLE
29135: LD_INT 1
29137: DEC
29138: ST_TO_ADDR
29139: LD_INT 6
29141: PUSH
29142: LD_VAR 0 7
29146: MINUS
29147: PUSH
29148: FOR_TO
29149: IFFALSE 29241
// begin if i = sort then
29151: LD_VAR 0 3
29155: PUSH
29156: LD_VAR 0 9
29160: EQUAL
29161: IFFALSE 29165
// break ;
29163: GO 29241
// if GetClass ( i ) = 3 then
29165: LD_VAR 0 3
29169: PPUSH
29170: CALL_OW 257
29174: PUSH
29175: LD_INT 3
29177: EQUAL
29178: IFFALSE 29182
// continue ;
29180: GO 29148
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29182: LD_ADDR_VAR 0 11
29186: PUSH
29187: LD_VAR 0 11
29191: PPUSH
29192: LD_VAR 0 11
29196: PUSH
29197: LD_INT 1
29199: PLUS
29200: PPUSH
29201: LD_VAR 0 9
29205: PUSH
29206: LD_VAR 0 3
29210: ARRAY
29211: PPUSH
29212: CALL_OW 2
29216: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29217: LD_ADDR_VAR 0 4
29221: PUSH
29222: LD_VAR 0 4
29226: PUSH
29227: LD_VAR 0 9
29231: PUSH
29232: LD_VAR 0 3
29236: ARRAY
29237: DIFF
29238: ST_TO_ADDR
// end ;
29239: GO 29148
29241: POP
29242: POP
// if p then
29243: LD_VAR 0 11
29247: IFFALSE 29272
// result := Replace ( result , 3 , p ) ;
29249: LD_ADDR_VAR 0 2
29253: PUSH
29254: LD_VAR 0 2
29258: PPUSH
29259: LD_INT 3
29261: PPUSH
29262: LD_VAR 0 11
29266: PPUSH
29267: CALL_OW 1
29271: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29272: LD_ADDR_VAR 0 4
29276: PUSH
29277: LD_VAR 0 4
29281: PUSH
29282: LD_VAR 0 6
29286: DIFF
29287: ST_TO_ADDR
// if tmp and eng < 4 then
29288: LD_VAR 0 4
29292: PUSH
29293: LD_VAR 0 6
29297: PUSH
29298: LD_INT 4
29300: LESS
29301: AND
29302: IFFALSE 29492
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29304: LD_ADDR_VAR 0 9
29308: PUSH
29309: LD_VAR 0 4
29313: PUSH
29314: LD_VAR 0 7
29318: PUSH
29319: LD_VAR 0 6
29323: UNION
29324: DIFF
29325: PPUSH
29326: LD_INT 2
29328: PPUSH
29329: CALL 87866 0 2
29333: ST_TO_ADDR
// p := [ ] ;
29334: LD_ADDR_VAR 0 11
29338: PUSH
29339: EMPTY
29340: ST_TO_ADDR
// if sort then
29341: LD_VAR 0 9
29345: IFFALSE 29461
// for i = 1 to 4 - eng do
29347: LD_ADDR_VAR 0 3
29351: PUSH
29352: DOUBLE
29353: LD_INT 1
29355: DEC
29356: ST_TO_ADDR
29357: LD_INT 4
29359: PUSH
29360: LD_VAR 0 6
29364: MINUS
29365: PUSH
29366: FOR_TO
29367: IFFALSE 29459
// begin if i = sort then
29369: LD_VAR 0 3
29373: PUSH
29374: LD_VAR 0 9
29378: EQUAL
29379: IFFALSE 29383
// break ;
29381: GO 29459
// if GetClass ( i ) = 2 then
29383: LD_VAR 0 3
29387: PPUSH
29388: CALL_OW 257
29392: PUSH
29393: LD_INT 2
29395: EQUAL
29396: IFFALSE 29400
// continue ;
29398: GO 29366
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29400: LD_ADDR_VAR 0 11
29404: PUSH
29405: LD_VAR 0 11
29409: PPUSH
29410: LD_VAR 0 11
29414: PUSH
29415: LD_INT 1
29417: PLUS
29418: PPUSH
29419: LD_VAR 0 9
29423: PUSH
29424: LD_VAR 0 3
29428: ARRAY
29429: PPUSH
29430: CALL_OW 2
29434: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29435: LD_ADDR_VAR 0 4
29439: PUSH
29440: LD_VAR 0 4
29444: PUSH
29445: LD_VAR 0 9
29449: PUSH
29450: LD_VAR 0 3
29454: ARRAY
29455: DIFF
29456: ST_TO_ADDR
// end ;
29457: GO 29366
29459: POP
29460: POP
// if p then
29461: LD_VAR 0 11
29465: IFFALSE 29490
// result := Replace ( result , 2 , p ) ;
29467: LD_ADDR_VAR 0 2
29471: PUSH
29472: LD_VAR 0 2
29476: PPUSH
29477: LD_INT 2
29479: PPUSH
29480: LD_VAR 0 11
29484: PPUSH
29485: CALL_OW 1
29489: ST_TO_ADDR
// end else
29490: GO 29536
// for i = eng downto 5 do
29492: LD_ADDR_VAR 0 3
29496: PUSH
29497: DOUBLE
29498: LD_VAR 0 6
29502: INC
29503: ST_TO_ADDR
29504: LD_INT 5
29506: PUSH
29507: FOR_DOWNTO
29508: IFFALSE 29534
// tmp := tmp union eng [ i ] ;
29510: LD_ADDR_VAR 0 4
29514: PUSH
29515: LD_VAR 0 4
29519: PUSH
29520: LD_VAR 0 6
29524: PUSH
29525: LD_VAR 0 3
29529: ARRAY
29530: UNION
29531: ST_TO_ADDR
29532: GO 29507
29534: POP
29535: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29536: LD_ADDR_VAR 0 2
29540: PUSH
29541: LD_VAR 0 2
29545: PPUSH
29546: LD_INT 1
29548: PPUSH
29549: LD_VAR 0 4
29553: PUSH
29554: LD_VAR 0 5
29558: DIFF
29559: PPUSH
29560: CALL_OW 1
29564: ST_TO_ADDR
// exit ;
29565: GO 29567
// end ; end ;
29567: LD_VAR 0 2
29571: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29572: LD_INT 0
29574: PPUSH
29575: PPUSH
29576: PPUSH
// if not mc_bases then
29577: LD_EXP 76
29581: NOT
29582: IFFALSE 29586
// exit ;
29584: GO 29728
// for i = 1 to mc_bases do
29586: LD_ADDR_VAR 0 2
29590: PUSH
29591: DOUBLE
29592: LD_INT 1
29594: DEC
29595: ST_TO_ADDR
29596: LD_EXP 76
29600: PUSH
29601: FOR_TO
29602: IFFALSE 29719
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29604: LD_ADDR_VAR 0 3
29608: PUSH
29609: LD_EXP 76
29613: PUSH
29614: LD_VAR 0 2
29618: ARRAY
29619: PPUSH
29620: LD_INT 21
29622: PUSH
29623: LD_INT 3
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 3
29632: PUSH
29633: LD_INT 2
29635: PUSH
29636: LD_INT 30
29638: PUSH
29639: LD_INT 29
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: PUSH
29646: LD_INT 30
29648: PUSH
29649: LD_INT 30
29651: PUSH
29652: EMPTY
29653: LIST
29654: LIST
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: LIST
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 3
29667: PUSH
29668: LD_INT 24
29670: PUSH
29671: LD_INT 1000
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: LIST
29686: PPUSH
29687: CALL_OW 72
29691: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29692: LD_ADDR_EXP 77
29696: PUSH
29697: LD_EXP 77
29701: PPUSH
29702: LD_VAR 0 2
29706: PPUSH
29707: LD_VAR 0 3
29711: PPUSH
29712: CALL_OW 1
29716: ST_TO_ADDR
// end ;
29717: GO 29601
29719: POP
29720: POP
// RaiseSailEvent ( 101 ) ;
29721: LD_INT 101
29723: PPUSH
29724: CALL_OW 427
// end ;
29728: LD_VAR 0 1
29732: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29733: LD_INT 0
29735: PPUSH
29736: PPUSH
29737: PPUSH
29738: PPUSH
29739: PPUSH
29740: PPUSH
29741: PPUSH
// if not mc_bases then
29742: LD_EXP 76
29746: NOT
29747: IFFALSE 29751
// exit ;
29749: GO 30313
// for i = 1 to mc_bases do
29751: LD_ADDR_VAR 0 2
29755: PUSH
29756: DOUBLE
29757: LD_INT 1
29759: DEC
29760: ST_TO_ADDR
29761: LD_EXP 76
29765: PUSH
29766: FOR_TO
29767: IFFALSE 30304
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29769: LD_ADDR_VAR 0 5
29773: PUSH
29774: LD_EXP 76
29778: PUSH
29779: LD_VAR 0 2
29783: ARRAY
29784: PUSH
29785: LD_EXP 105
29789: PUSH
29790: LD_VAR 0 2
29794: ARRAY
29795: UNION
29796: PPUSH
29797: LD_INT 21
29799: PUSH
29800: LD_INT 1
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 1
29809: PUSH
29810: LD_INT 3
29812: PUSH
29813: LD_INT 54
29815: PUSH
29816: EMPTY
29817: LIST
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: LD_INT 3
29825: PUSH
29826: LD_INT 24
29828: PUSH
29829: LD_INT 1000
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: LIST
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PPUSH
29849: CALL_OW 72
29853: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
29854: LD_ADDR_VAR 0 6
29858: PUSH
29859: LD_EXP 76
29863: PUSH
29864: LD_VAR 0 2
29868: ARRAY
29869: PPUSH
29870: LD_INT 21
29872: PUSH
29873: LD_INT 1
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 1
29882: PUSH
29883: LD_INT 3
29885: PUSH
29886: LD_INT 54
29888: PUSH
29889: EMPTY
29890: LIST
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: LD_INT 3
29898: PUSH
29899: LD_INT 24
29901: PUSH
29902: LD_INT 250
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: LIST
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PPUSH
29922: CALL_OW 72
29926: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29927: LD_ADDR_VAR 0 7
29931: PUSH
29932: LD_VAR 0 5
29936: PUSH
29937: LD_VAR 0 6
29941: DIFF
29942: ST_TO_ADDR
// if not need_heal_1 then
29943: LD_VAR 0 6
29947: NOT
29948: IFFALSE 29981
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29950: LD_ADDR_EXP 79
29954: PUSH
29955: LD_EXP 79
29959: PPUSH
29960: LD_VAR 0 2
29964: PUSH
29965: LD_INT 1
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PPUSH
29972: EMPTY
29973: PPUSH
29974: CALL 57045 0 3
29978: ST_TO_ADDR
29979: GO 30051
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29981: LD_ADDR_EXP 79
29985: PUSH
29986: LD_EXP 79
29990: PPUSH
29991: LD_VAR 0 2
29995: PUSH
29996: LD_INT 1
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PPUSH
30003: LD_EXP 79
30007: PUSH
30008: LD_VAR 0 2
30012: ARRAY
30013: PUSH
30014: LD_INT 1
30016: ARRAY
30017: PPUSH
30018: LD_INT 3
30020: PUSH
30021: LD_INT 24
30023: PUSH
30024: LD_INT 1000
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PPUSH
30035: CALL_OW 72
30039: PUSH
30040: LD_VAR 0 6
30044: UNION
30045: PPUSH
30046: CALL 57045 0 3
30050: ST_TO_ADDR
// if not need_heal_2 then
30051: LD_VAR 0 7
30055: NOT
30056: IFFALSE 30089
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30058: LD_ADDR_EXP 79
30062: PUSH
30063: LD_EXP 79
30067: PPUSH
30068: LD_VAR 0 2
30072: PUSH
30073: LD_INT 2
30075: PUSH
30076: EMPTY
30077: LIST
30078: LIST
30079: PPUSH
30080: EMPTY
30081: PPUSH
30082: CALL 57045 0 3
30086: ST_TO_ADDR
30087: GO 30121
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30089: LD_ADDR_EXP 79
30093: PUSH
30094: LD_EXP 79
30098: PPUSH
30099: LD_VAR 0 2
30103: PUSH
30104: LD_INT 2
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: PPUSH
30111: LD_VAR 0 7
30115: PPUSH
30116: CALL 57045 0 3
30120: ST_TO_ADDR
// if need_heal_2 then
30121: LD_VAR 0 7
30125: IFFALSE 30286
// for j in need_heal_2 do
30127: LD_ADDR_VAR 0 3
30131: PUSH
30132: LD_VAR 0 7
30136: PUSH
30137: FOR_IN
30138: IFFALSE 30284
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30140: LD_ADDR_VAR 0 5
30144: PUSH
30145: LD_EXP 76
30149: PUSH
30150: LD_VAR 0 2
30154: ARRAY
30155: PPUSH
30156: LD_INT 2
30158: PUSH
30159: LD_INT 30
30161: PUSH
30162: LD_INT 6
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 30
30171: PUSH
30172: LD_INT 7
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 30
30181: PUSH
30182: LD_INT 8
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 30
30191: PUSH
30192: LD_INT 0
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 30
30201: PUSH
30202: LD_INT 1
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: LIST
30216: PPUSH
30217: CALL_OW 72
30221: ST_TO_ADDR
// if tmp then
30222: LD_VAR 0 5
30226: IFFALSE 30282
// begin k := NearestUnitToUnit ( tmp , j ) ;
30228: LD_ADDR_VAR 0 4
30232: PUSH
30233: LD_VAR 0 5
30237: PPUSH
30238: LD_VAR 0 3
30242: PPUSH
30243: CALL_OW 74
30247: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30248: LD_VAR 0 3
30252: PPUSH
30253: LD_VAR 0 4
30257: PPUSH
30258: CALL_OW 296
30262: PUSH
30263: LD_INT 5
30265: GREATER
30266: IFFALSE 30282
// ComMoveToNearbyEntrance ( j , k ) ;
30268: LD_VAR 0 3
30272: PPUSH
30273: LD_VAR 0 4
30277: PPUSH
30278: CALL 90234 0 2
// end ; end ;
30282: GO 30137
30284: POP
30285: POP
// if not need_heal_1 and not need_heal_2 then
30286: LD_VAR 0 6
30290: NOT
30291: PUSH
30292: LD_VAR 0 7
30296: NOT
30297: AND
30298: IFFALSE 30302
// continue ;
30300: GO 29766
// end ;
30302: GO 29766
30304: POP
30305: POP
// RaiseSailEvent ( 102 ) ;
30306: LD_INT 102
30308: PPUSH
30309: CALL_OW 427
// end ;
30313: LD_VAR 0 1
30317: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30318: LD_INT 0
30320: PPUSH
30321: PPUSH
30322: PPUSH
30323: PPUSH
30324: PPUSH
30325: PPUSH
30326: PPUSH
30327: PPUSH
// if not mc_bases then
30328: LD_EXP 76
30332: NOT
30333: IFFALSE 30337
// exit ;
30335: GO 31248
// for i = 1 to mc_bases do
30337: LD_ADDR_VAR 0 2
30341: PUSH
30342: DOUBLE
30343: LD_INT 1
30345: DEC
30346: ST_TO_ADDR
30347: LD_EXP 76
30351: PUSH
30352: FOR_TO
30353: IFFALSE 31246
// begin if not mc_building_need_repair [ i ] then
30355: LD_EXP 77
30359: PUSH
30360: LD_VAR 0 2
30364: ARRAY
30365: NOT
30366: IFFALSE 30551
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30368: LD_ADDR_VAR 0 6
30372: PUSH
30373: LD_EXP 95
30377: PUSH
30378: LD_VAR 0 2
30382: ARRAY
30383: PPUSH
30384: LD_INT 3
30386: PUSH
30387: LD_INT 24
30389: PUSH
30390: LD_INT 1000
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 2
30403: PUSH
30404: LD_INT 34
30406: PUSH
30407: LD_INT 13
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: PUSH
30414: LD_INT 34
30416: PUSH
30417: LD_INT 52
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 34
30426: PUSH
30427: LD_INT 88
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: LIST
30438: LIST
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PPUSH
30444: CALL_OW 72
30448: ST_TO_ADDR
// if cranes then
30449: LD_VAR 0 6
30453: IFFALSE 30515
// for j in cranes do
30455: LD_ADDR_VAR 0 3
30459: PUSH
30460: LD_VAR 0 6
30464: PUSH
30465: FOR_IN
30466: IFFALSE 30513
// if not IsInArea ( j , mc_parking [ i ] ) then
30468: LD_VAR 0 3
30472: PPUSH
30473: LD_EXP 100
30477: PUSH
30478: LD_VAR 0 2
30482: ARRAY
30483: PPUSH
30484: CALL_OW 308
30488: NOT
30489: IFFALSE 30511
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30491: LD_VAR 0 3
30495: PPUSH
30496: LD_EXP 100
30500: PUSH
30501: LD_VAR 0 2
30505: ARRAY
30506: PPUSH
30507: CALL_OW 113
30511: GO 30465
30513: POP
30514: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30515: LD_ADDR_EXP 78
30519: PUSH
30520: LD_EXP 78
30524: PPUSH
30525: LD_VAR 0 2
30529: PPUSH
30530: EMPTY
30531: PPUSH
30532: CALL_OW 1
30536: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30537: LD_VAR 0 2
30541: PPUSH
30542: LD_INT 101
30544: PPUSH
30545: CALL 25405 0 2
// continue ;
30549: GO 30352
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30551: LD_ADDR_EXP 82
30555: PUSH
30556: LD_EXP 82
30560: PPUSH
30561: LD_VAR 0 2
30565: PPUSH
30566: EMPTY
30567: PPUSH
30568: CALL_OW 1
30572: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30573: LD_VAR 0 2
30577: PPUSH
30578: LD_INT 103
30580: PPUSH
30581: CALL 25405 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30585: LD_ADDR_VAR 0 5
30589: PUSH
30590: LD_EXP 76
30594: PUSH
30595: LD_VAR 0 2
30599: ARRAY
30600: PUSH
30601: LD_EXP 105
30605: PUSH
30606: LD_VAR 0 2
30610: ARRAY
30611: UNION
30612: PPUSH
30613: LD_INT 2
30615: PUSH
30616: LD_INT 25
30618: PUSH
30619: LD_INT 2
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 25
30628: PUSH
30629: LD_INT 16
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: LIST
30640: PUSH
30641: EMPTY
30642: LIST
30643: PPUSH
30644: CALL_OW 72
30648: ST_TO_ADDR
// if mc_need_heal [ i ] then
30649: LD_EXP 79
30653: PUSH
30654: LD_VAR 0 2
30658: ARRAY
30659: IFFALSE 30703
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30661: LD_ADDR_VAR 0 5
30665: PUSH
30666: LD_VAR 0 5
30670: PUSH
30671: LD_EXP 79
30675: PUSH
30676: LD_VAR 0 2
30680: ARRAY
30681: PUSH
30682: LD_INT 1
30684: ARRAY
30685: PUSH
30686: LD_EXP 79
30690: PUSH
30691: LD_VAR 0 2
30695: ARRAY
30696: PUSH
30697: LD_INT 2
30699: ARRAY
30700: UNION
30701: DIFF
30702: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30703: LD_ADDR_VAR 0 6
30707: PUSH
30708: LD_EXP 95
30712: PUSH
30713: LD_VAR 0 2
30717: ARRAY
30718: PPUSH
30719: LD_INT 2
30721: PUSH
30722: LD_INT 34
30724: PUSH
30725: LD_INT 13
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 34
30734: PUSH
30735: LD_INT 52
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 34
30744: PUSH
30745: LD_INT 88
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: LIST
30756: LIST
30757: PPUSH
30758: CALL_OW 72
30762: ST_TO_ADDR
// if cranes then
30763: LD_VAR 0 6
30767: IFFALSE 30935
// begin for j in cranes do
30769: LD_ADDR_VAR 0 3
30773: PUSH
30774: LD_VAR 0 6
30778: PUSH
30779: FOR_IN
30780: IFFALSE 30933
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30782: LD_VAR 0 3
30786: PPUSH
30787: CALL_OW 256
30791: PUSH
30792: LD_INT 1000
30794: EQUAL
30795: PUSH
30796: LD_VAR 0 3
30800: PPUSH
30801: CALL_OW 314
30805: NOT
30806: AND
30807: IFFALSE 30873
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
30809: LD_ADDR_VAR 0 8
30813: PUSH
30814: LD_EXP 77
30818: PUSH
30819: LD_VAR 0 2
30823: ARRAY
30824: PPUSH
30825: LD_VAR 0 3
30829: PPUSH
30830: CALL_OW 74
30834: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
30835: LD_VAR 0 8
30839: PPUSH
30840: LD_INT 16
30842: PPUSH
30843: CALL 59642 0 2
30847: PUSH
30848: LD_INT 4
30850: ARRAY
30851: PUSH
30852: LD_INT 10
30854: LESS
30855: IFFALSE 30871
// ComRepairBuilding ( j , to_repair ) ;
30857: LD_VAR 0 3
30861: PPUSH
30862: LD_VAR 0 8
30866: PPUSH
30867: CALL_OW 130
// end else
30871: GO 30931
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30873: LD_VAR 0 3
30877: PPUSH
30878: CALL_OW 256
30882: PUSH
30883: LD_INT 500
30885: LESS
30886: PUSH
30887: LD_VAR 0 3
30891: PPUSH
30892: LD_EXP 100
30896: PUSH
30897: LD_VAR 0 2
30901: ARRAY
30902: PPUSH
30903: CALL_OW 308
30907: NOT
30908: AND
30909: IFFALSE 30931
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30911: LD_VAR 0 3
30915: PPUSH
30916: LD_EXP 100
30920: PUSH
30921: LD_VAR 0 2
30925: ARRAY
30926: PPUSH
30927: CALL_OW 113
// end ;
30931: GO 30779
30933: POP
30934: POP
// end ; if tmp > 3 then
30935: LD_VAR 0 5
30939: PUSH
30940: LD_INT 3
30942: GREATER
30943: IFFALSE 30963
// tmp := ShrinkArray ( tmp , 4 ) ;
30945: LD_ADDR_VAR 0 5
30949: PUSH
30950: LD_VAR 0 5
30954: PPUSH
30955: LD_INT 4
30957: PPUSH
30958: CALL 89672 0 2
30962: ST_TO_ADDR
// if not tmp then
30963: LD_VAR 0 5
30967: NOT
30968: IFFALSE 30972
// continue ;
30970: GO 30352
// for j in tmp do
30972: LD_ADDR_VAR 0 3
30976: PUSH
30977: LD_VAR 0 5
30981: PUSH
30982: FOR_IN
30983: IFFALSE 31242
// begin if IsInUnit ( j ) then
30985: LD_VAR 0 3
30989: PPUSH
30990: CALL_OW 310
30994: IFFALSE 31005
// ComExitBuilding ( j ) ;
30996: LD_VAR 0 3
31000: PPUSH
31001: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31005: LD_VAR 0 3
31009: PUSH
31010: LD_EXP 78
31014: PUSH
31015: LD_VAR 0 2
31019: ARRAY
31020: IN
31021: NOT
31022: IFFALSE 31080
// begin SetTag ( j , 101 ) ;
31024: LD_VAR 0 3
31028: PPUSH
31029: LD_INT 101
31031: PPUSH
31032: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31036: LD_ADDR_EXP 78
31040: PUSH
31041: LD_EXP 78
31045: PPUSH
31046: LD_VAR 0 2
31050: PUSH
31051: LD_EXP 78
31055: PUSH
31056: LD_VAR 0 2
31060: ARRAY
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PPUSH
31070: LD_VAR 0 3
31074: PPUSH
31075: CALL 57045 0 3
31079: ST_TO_ADDR
// end ; wait ( 1 ) ;
31080: LD_INT 1
31082: PPUSH
31083: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31087: LD_ADDR_VAR 0 7
31091: PUSH
31092: LD_EXP 77
31096: PUSH
31097: LD_VAR 0 2
31101: ARRAY
31102: ST_TO_ADDR
// if mc_scan [ i ] then
31103: LD_EXP 99
31107: PUSH
31108: LD_VAR 0 2
31112: ARRAY
31113: IFFALSE 31175
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31115: LD_ADDR_VAR 0 7
31119: PUSH
31120: LD_EXP 77
31124: PUSH
31125: LD_VAR 0 2
31129: ARRAY
31130: PPUSH
31131: LD_INT 3
31133: PUSH
31134: LD_INT 30
31136: PUSH
31137: LD_INT 32
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 30
31146: PUSH
31147: LD_INT 33
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PUSH
31154: LD_INT 30
31156: PUSH
31157: LD_INT 31
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: PPUSH
31170: CALL_OW 72
31174: ST_TO_ADDR
// if not to_repair_tmp then
31175: LD_VAR 0 7
31179: NOT
31180: IFFALSE 31184
// continue ;
31182: GO 30982
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31184: LD_ADDR_VAR 0 8
31188: PUSH
31189: LD_VAR 0 7
31193: PPUSH
31194: LD_VAR 0 3
31198: PPUSH
31199: CALL_OW 74
31203: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
31204: LD_VAR 0 8
31208: PPUSH
31209: LD_INT 16
31211: PPUSH
31212: CALL 59642 0 2
31216: PUSH
31217: LD_INT 4
31219: ARRAY
31220: PUSH
31221: LD_INT 14
31223: LESS
31224: IFFALSE 31240
// ComRepairBuilding ( j , to_repair ) ;
31226: LD_VAR 0 3
31230: PPUSH
31231: LD_VAR 0 8
31235: PPUSH
31236: CALL_OW 130
// end ;
31240: GO 30982
31242: POP
31243: POP
// end ;
31244: GO 30352
31246: POP
31247: POP
// end ;
31248: LD_VAR 0 1
31252: RET
// export function MC_Heal ; var i , j , tmp ; begin
31253: LD_INT 0
31255: PPUSH
31256: PPUSH
31257: PPUSH
31258: PPUSH
// if not mc_bases then
31259: LD_EXP 76
31263: NOT
31264: IFFALSE 31268
// exit ;
31266: GO 31670
// for i = 1 to mc_bases do
31268: LD_ADDR_VAR 0 2
31272: PUSH
31273: DOUBLE
31274: LD_INT 1
31276: DEC
31277: ST_TO_ADDR
31278: LD_EXP 76
31282: PUSH
31283: FOR_TO
31284: IFFALSE 31668
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31286: LD_EXP 79
31290: PUSH
31291: LD_VAR 0 2
31295: ARRAY
31296: PUSH
31297: LD_INT 1
31299: ARRAY
31300: NOT
31301: PUSH
31302: LD_EXP 79
31306: PUSH
31307: LD_VAR 0 2
31311: ARRAY
31312: PUSH
31313: LD_INT 2
31315: ARRAY
31316: NOT
31317: AND
31318: IFFALSE 31356
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31320: LD_ADDR_EXP 80
31324: PUSH
31325: LD_EXP 80
31329: PPUSH
31330: LD_VAR 0 2
31334: PPUSH
31335: EMPTY
31336: PPUSH
31337: CALL_OW 1
31341: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31342: LD_VAR 0 2
31346: PPUSH
31347: LD_INT 102
31349: PPUSH
31350: CALL 25405 0 2
// continue ;
31354: GO 31283
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31356: LD_ADDR_VAR 0 4
31360: PUSH
31361: LD_EXP 76
31365: PUSH
31366: LD_VAR 0 2
31370: ARRAY
31371: PPUSH
31372: LD_INT 25
31374: PUSH
31375: LD_INT 4
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PPUSH
31382: CALL_OW 72
31386: ST_TO_ADDR
// if not tmp then
31387: LD_VAR 0 4
31391: NOT
31392: IFFALSE 31396
// continue ;
31394: GO 31283
// if mc_taming [ i ] then
31396: LD_EXP 107
31400: PUSH
31401: LD_VAR 0 2
31405: ARRAY
31406: IFFALSE 31430
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31408: LD_ADDR_EXP 107
31412: PUSH
31413: LD_EXP 107
31417: PPUSH
31418: LD_VAR 0 2
31422: PPUSH
31423: EMPTY
31424: PPUSH
31425: CALL_OW 1
31429: ST_TO_ADDR
// for j in tmp do
31430: LD_ADDR_VAR 0 3
31434: PUSH
31435: LD_VAR 0 4
31439: PUSH
31440: FOR_IN
31441: IFFALSE 31664
// begin if IsInUnit ( j ) then
31443: LD_VAR 0 3
31447: PPUSH
31448: CALL_OW 310
31452: IFFALSE 31463
// ComExitBuilding ( j ) ;
31454: LD_VAR 0 3
31458: PPUSH
31459: CALL_OW 122
// if not j in mc_healers [ i ] then
31463: LD_VAR 0 3
31467: PUSH
31468: LD_EXP 80
31472: PUSH
31473: LD_VAR 0 2
31477: ARRAY
31478: IN
31479: NOT
31480: IFFALSE 31526
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31482: LD_ADDR_EXP 80
31486: PUSH
31487: LD_EXP 80
31491: PPUSH
31492: LD_VAR 0 2
31496: PUSH
31497: LD_EXP 80
31501: PUSH
31502: LD_VAR 0 2
31506: ARRAY
31507: PUSH
31508: LD_INT 1
31510: PLUS
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PPUSH
31516: LD_VAR 0 3
31520: PPUSH
31521: CALL 57045 0 3
31525: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31526: LD_VAR 0 3
31530: PPUSH
31531: CALL_OW 110
31535: PUSH
31536: LD_INT 102
31538: NONEQUAL
31539: IFFALSE 31553
// SetTag ( j , 102 ) ;
31541: LD_VAR 0 3
31545: PPUSH
31546: LD_INT 102
31548: PPUSH
31549: CALL_OW 109
// Wait ( 3 ) ;
31553: LD_INT 3
31555: PPUSH
31556: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31560: LD_EXP 79
31564: PUSH
31565: LD_VAR 0 2
31569: ARRAY
31570: PUSH
31571: LD_INT 1
31573: ARRAY
31574: IFFALSE 31606
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31576: LD_VAR 0 3
31580: PPUSH
31581: LD_EXP 79
31585: PUSH
31586: LD_VAR 0 2
31590: ARRAY
31591: PUSH
31592: LD_INT 1
31594: ARRAY
31595: PUSH
31596: LD_INT 1
31598: ARRAY
31599: PPUSH
31600: CALL_OW 128
31604: GO 31662
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31606: LD_VAR 0 3
31610: PPUSH
31611: CALL_OW 314
31615: NOT
31616: PUSH
31617: LD_EXP 79
31621: PUSH
31622: LD_VAR 0 2
31626: ARRAY
31627: PUSH
31628: LD_INT 2
31630: ARRAY
31631: AND
31632: IFFALSE 31662
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31634: LD_VAR 0 3
31638: PPUSH
31639: LD_EXP 79
31643: PUSH
31644: LD_VAR 0 2
31648: ARRAY
31649: PUSH
31650: LD_INT 2
31652: ARRAY
31653: PUSH
31654: LD_INT 1
31656: ARRAY
31657: PPUSH
31658: CALL_OW 128
// end ;
31662: GO 31440
31664: POP
31665: POP
// end ;
31666: GO 31283
31668: POP
31669: POP
// end ;
31670: LD_VAR 0 1
31674: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
31675: LD_INT 0
31677: PPUSH
31678: PPUSH
31679: PPUSH
31680: PPUSH
31681: PPUSH
31682: PPUSH
// if not mc_bases then
31683: LD_EXP 76
31687: NOT
31688: IFFALSE 31692
// exit ;
31690: GO 32855
// for i = 1 to mc_bases do
31692: LD_ADDR_VAR 0 2
31696: PUSH
31697: DOUBLE
31698: LD_INT 1
31700: DEC
31701: ST_TO_ADDR
31702: LD_EXP 76
31706: PUSH
31707: FOR_TO
31708: IFFALSE 32853
// begin if mc_scan [ i ] then
31710: LD_EXP 99
31714: PUSH
31715: LD_VAR 0 2
31719: ARRAY
31720: IFFALSE 31724
// continue ;
31722: GO 31707
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31724: LD_EXP 81
31728: PUSH
31729: LD_VAR 0 2
31733: ARRAY
31734: NOT
31735: PUSH
31736: LD_EXP 83
31740: PUSH
31741: LD_VAR 0 2
31745: ARRAY
31746: NOT
31747: AND
31748: PUSH
31749: LD_EXP 82
31753: PUSH
31754: LD_VAR 0 2
31758: ARRAY
31759: AND
31760: IFFALSE 31798
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31762: LD_ADDR_EXP 82
31766: PUSH
31767: LD_EXP 82
31771: PPUSH
31772: LD_VAR 0 2
31776: PPUSH
31777: EMPTY
31778: PPUSH
31779: CALL_OW 1
31783: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31784: LD_VAR 0 2
31788: PPUSH
31789: LD_INT 103
31791: PPUSH
31792: CALL 25405 0 2
// continue ;
31796: GO 31707
// end ; if mc_construct_list [ i ] then
31798: LD_EXP 83
31802: PUSH
31803: LD_VAR 0 2
31807: ARRAY
31808: IFFALSE 32028
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31810: LD_ADDR_VAR 0 5
31814: PUSH
31815: LD_EXP 76
31819: PUSH
31820: LD_VAR 0 2
31824: ARRAY
31825: PPUSH
31826: LD_INT 25
31828: PUSH
31829: LD_INT 2
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PPUSH
31836: CALL_OW 72
31840: PUSH
31841: LD_EXP 78
31845: PUSH
31846: LD_VAR 0 2
31850: ARRAY
31851: DIFF
31852: ST_TO_ADDR
// if not tmp then
31853: LD_VAR 0 5
31857: NOT
31858: IFFALSE 31862
// continue ;
31860: GO 31707
// for j in tmp do
31862: LD_ADDR_VAR 0 3
31866: PUSH
31867: LD_VAR 0 5
31871: PUSH
31872: FOR_IN
31873: IFFALSE 32024
// begin if not mc_builders [ i ] then
31875: LD_EXP 82
31879: PUSH
31880: LD_VAR 0 2
31884: ARRAY
31885: NOT
31886: IFFALSE 31944
// begin SetTag ( j , 103 ) ;
31888: LD_VAR 0 3
31892: PPUSH
31893: LD_INT 103
31895: PPUSH
31896: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31900: LD_ADDR_EXP 82
31904: PUSH
31905: LD_EXP 82
31909: PPUSH
31910: LD_VAR 0 2
31914: PUSH
31915: LD_EXP 82
31919: PUSH
31920: LD_VAR 0 2
31924: ARRAY
31925: PUSH
31926: LD_INT 1
31928: PLUS
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PPUSH
31934: LD_VAR 0 3
31938: PPUSH
31939: CALL 57045 0 3
31943: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31944: LD_VAR 0 3
31948: PPUSH
31949: CALL_OW 310
31953: IFFALSE 31964
// ComExitBuilding ( j ) ;
31955: LD_VAR 0 3
31959: PPUSH
31960: CALL_OW 122
// wait ( 3 ) ;
31964: LD_INT 3
31966: PPUSH
31967: CALL_OW 67
// if not mc_construct_list [ i ] then
31971: LD_EXP 83
31975: PUSH
31976: LD_VAR 0 2
31980: ARRAY
31981: NOT
31982: IFFALSE 31986
// break ;
31984: GO 32024
// if not HasTask ( j ) then
31986: LD_VAR 0 3
31990: PPUSH
31991: CALL_OW 314
31995: NOT
31996: IFFALSE 32022
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31998: LD_VAR 0 3
32002: PPUSH
32003: LD_EXP 83
32007: PUSH
32008: LD_VAR 0 2
32012: ARRAY
32013: PUSH
32014: LD_INT 1
32016: ARRAY
32017: PPUSH
32018: CALL 59906 0 2
// end ;
32022: GO 31872
32024: POP
32025: POP
// end else
32026: GO 32851
// if mc_build_list [ i ] then
32028: LD_EXP 81
32032: PUSH
32033: LD_VAR 0 2
32037: ARRAY
32038: IFFALSE 32851
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32040: LD_EXP 81
32044: PUSH
32045: LD_VAR 0 2
32049: ARRAY
32050: PUSH
32051: LD_INT 1
32053: ARRAY
32054: PUSH
32055: LD_INT 1
32057: ARRAY
32058: PPUSH
32059: CALL 59730 0 1
32063: PUSH
32064: LD_EXP 76
32068: PUSH
32069: LD_VAR 0 2
32073: ARRAY
32074: PPUSH
32075: LD_INT 2
32077: PUSH
32078: LD_INT 30
32080: PUSH
32081: LD_INT 2
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: LD_INT 30
32090: PUSH
32091: LD_INT 3
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: LIST
32102: PPUSH
32103: CALL_OW 72
32107: NOT
32108: AND
32109: IFFALSE 32214
// begin for j = 1 to mc_build_list [ i ] do
32111: LD_ADDR_VAR 0 3
32115: PUSH
32116: DOUBLE
32117: LD_INT 1
32119: DEC
32120: ST_TO_ADDR
32121: LD_EXP 81
32125: PUSH
32126: LD_VAR 0 2
32130: ARRAY
32131: PUSH
32132: FOR_TO
32133: IFFALSE 32212
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32135: LD_EXP 81
32139: PUSH
32140: LD_VAR 0 2
32144: ARRAY
32145: PUSH
32146: LD_VAR 0 3
32150: ARRAY
32151: PUSH
32152: LD_INT 1
32154: ARRAY
32155: PUSH
32156: LD_INT 2
32158: EQUAL
32159: IFFALSE 32210
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32161: LD_ADDR_EXP 81
32165: PUSH
32166: LD_EXP 81
32170: PPUSH
32171: LD_VAR 0 2
32175: PPUSH
32176: LD_EXP 81
32180: PUSH
32181: LD_VAR 0 2
32185: ARRAY
32186: PPUSH
32187: LD_VAR 0 3
32191: PPUSH
32192: LD_INT 1
32194: PPUSH
32195: LD_INT 0
32197: PPUSH
32198: CALL 56463 0 4
32202: PPUSH
32203: CALL_OW 1
32207: ST_TO_ADDR
// break ;
32208: GO 32212
// end ;
32210: GO 32132
32212: POP
32213: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32214: LD_ADDR_VAR 0 6
32218: PUSH
32219: LD_EXP 76
32223: PUSH
32224: LD_VAR 0 2
32228: ARRAY
32229: PPUSH
32230: LD_INT 2
32232: PUSH
32233: LD_INT 30
32235: PUSH
32236: LD_INT 0
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 30
32245: PUSH
32246: LD_INT 1
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: LIST
32257: PPUSH
32258: CALL_OW 72
32262: ST_TO_ADDR
// for k := 1 to depot do
32263: LD_ADDR_VAR 0 4
32267: PUSH
32268: DOUBLE
32269: LD_INT 1
32271: DEC
32272: ST_TO_ADDR
32273: LD_VAR 0 6
32277: PUSH
32278: FOR_TO
32279: IFFALSE 32849
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
32281: LD_EXP 81
32285: PUSH
32286: LD_VAR 0 2
32290: ARRAY
32291: PUSH
32292: LD_INT 1
32294: ARRAY
32295: PUSH
32296: LD_INT 1
32298: ARRAY
32299: PUSH
32300: LD_INT 0
32302: EQUAL
32303: PUSH
32304: LD_VAR 0 6
32308: PUSH
32309: LD_VAR 0 4
32313: ARRAY
32314: PPUSH
32315: LD_EXP 81
32319: PUSH
32320: LD_VAR 0 2
32324: ARRAY
32325: PUSH
32326: LD_INT 1
32328: ARRAY
32329: PUSH
32330: LD_INT 1
32332: ARRAY
32333: PPUSH
32334: LD_EXP 81
32338: PUSH
32339: LD_VAR 0 2
32343: ARRAY
32344: PUSH
32345: LD_INT 1
32347: ARRAY
32348: PUSH
32349: LD_INT 2
32351: ARRAY
32352: PPUSH
32353: LD_EXP 81
32357: PUSH
32358: LD_VAR 0 2
32362: ARRAY
32363: PUSH
32364: LD_INT 1
32366: ARRAY
32367: PUSH
32368: LD_INT 3
32370: ARRAY
32371: PPUSH
32372: LD_EXP 81
32376: PUSH
32377: LD_VAR 0 2
32381: ARRAY
32382: PUSH
32383: LD_INT 1
32385: ARRAY
32386: PUSH
32387: LD_INT 4
32389: ARRAY
32390: PPUSH
32391: CALL 65142 0 5
32395: OR
32396: IFFALSE 32677
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32398: LD_ADDR_VAR 0 5
32402: PUSH
32403: LD_EXP 76
32407: PUSH
32408: LD_VAR 0 2
32412: ARRAY
32413: PPUSH
32414: LD_INT 25
32416: PUSH
32417: LD_INT 2
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PPUSH
32424: CALL_OW 72
32428: PUSH
32429: LD_EXP 78
32433: PUSH
32434: LD_VAR 0 2
32438: ARRAY
32439: DIFF
32440: ST_TO_ADDR
// if not tmp then
32441: LD_VAR 0 5
32445: NOT
32446: IFFALSE 32450
// continue ;
32448: GO 32278
// for j in tmp do
32450: LD_ADDR_VAR 0 3
32454: PUSH
32455: LD_VAR 0 5
32459: PUSH
32460: FOR_IN
32461: IFFALSE 32673
// begin if not mc_builders [ i ] then
32463: LD_EXP 82
32467: PUSH
32468: LD_VAR 0 2
32472: ARRAY
32473: NOT
32474: IFFALSE 32532
// begin SetTag ( j , 103 ) ;
32476: LD_VAR 0 3
32480: PPUSH
32481: LD_INT 103
32483: PPUSH
32484: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32488: LD_ADDR_EXP 82
32492: PUSH
32493: LD_EXP 82
32497: PPUSH
32498: LD_VAR 0 2
32502: PUSH
32503: LD_EXP 82
32507: PUSH
32508: LD_VAR 0 2
32512: ARRAY
32513: PUSH
32514: LD_INT 1
32516: PLUS
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: PPUSH
32522: LD_VAR 0 3
32526: PPUSH
32527: CALL 57045 0 3
32531: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32532: LD_VAR 0 3
32536: PPUSH
32537: CALL_OW 310
32541: IFFALSE 32552
// ComExitBuilding ( j ) ;
32543: LD_VAR 0 3
32547: PPUSH
32548: CALL_OW 122
// wait ( 3 ) ;
32552: LD_INT 3
32554: PPUSH
32555: CALL_OW 67
// if not mc_build_list [ i ] then
32559: LD_EXP 81
32563: PUSH
32564: LD_VAR 0 2
32568: ARRAY
32569: NOT
32570: IFFALSE 32574
// break ;
32572: GO 32673
// if not HasTask ( j ) then
32574: LD_VAR 0 3
32578: PPUSH
32579: CALL_OW 314
32583: NOT
32584: IFFALSE 32671
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32586: LD_VAR 0 3
32590: PPUSH
32591: LD_EXP 81
32595: PUSH
32596: LD_VAR 0 2
32600: ARRAY
32601: PUSH
32602: LD_INT 1
32604: ARRAY
32605: PUSH
32606: LD_INT 1
32608: ARRAY
32609: PPUSH
32610: LD_EXP 81
32614: PUSH
32615: LD_VAR 0 2
32619: ARRAY
32620: PUSH
32621: LD_INT 1
32623: ARRAY
32624: PUSH
32625: LD_INT 2
32627: ARRAY
32628: PPUSH
32629: LD_EXP 81
32633: PUSH
32634: LD_VAR 0 2
32638: ARRAY
32639: PUSH
32640: LD_INT 1
32642: ARRAY
32643: PUSH
32644: LD_INT 3
32646: ARRAY
32647: PPUSH
32648: LD_EXP 81
32652: PUSH
32653: LD_VAR 0 2
32657: ARRAY
32658: PUSH
32659: LD_INT 1
32661: ARRAY
32662: PUSH
32663: LD_INT 4
32665: ARRAY
32666: PPUSH
32667: CALL_OW 145
// end ;
32671: GO 32460
32673: POP
32674: POP
// end else
32675: GO 32847
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32677: LD_EXP 76
32681: PUSH
32682: LD_VAR 0 2
32686: ARRAY
32687: PPUSH
32688: LD_EXP 81
32692: PUSH
32693: LD_VAR 0 2
32697: ARRAY
32698: PUSH
32699: LD_INT 1
32701: ARRAY
32702: PUSH
32703: LD_INT 1
32705: ARRAY
32706: PPUSH
32707: LD_EXP 81
32711: PUSH
32712: LD_VAR 0 2
32716: ARRAY
32717: PUSH
32718: LD_INT 1
32720: ARRAY
32721: PUSH
32722: LD_INT 2
32724: ARRAY
32725: PPUSH
32726: LD_EXP 81
32730: PUSH
32731: LD_VAR 0 2
32735: ARRAY
32736: PUSH
32737: LD_INT 1
32739: ARRAY
32740: PUSH
32741: LD_INT 3
32743: ARRAY
32744: PPUSH
32745: LD_EXP 81
32749: PUSH
32750: LD_VAR 0 2
32754: ARRAY
32755: PUSH
32756: LD_INT 1
32758: ARRAY
32759: PUSH
32760: LD_INT 4
32762: ARRAY
32763: PPUSH
32764: LD_EXP 76
32768: PUSH
32769: LD_VAR 0 2
32773: ARRAY
32774: PPUSH
32775: LD_INT 21
32777: PUSH
32778: LD_INT 3
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PPUSH
32785: CALL_OW 72
32789: PPUSH
32790: EMPTY
32791: PPUSH
32792: CALL 63896 0 7
32796: NOT
32797: IFFALSE 32847
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32799: LD_ADDR_EXP 81
32803: PUSH
32804: LD_EXP 81
32808: PPUSH
32809: LD_VAR 0 2
32813: PPUSH
32814: LD_EXP 81
32818: PUSH
32819: LD_VAR 0 2
32823: ARRAY
32824: PPUSH
32825: LD_INT 1
32827: PPUSH
32828: LD_INT 1
32830: NEG
32831: PPUSH
32832: LD_INT 0
32834: PPUSH
32835: CALL 56463 0 4
32839: PPUSH
32840: CALL_OW 1
32844: ST_TO_ADDR
// continue ;
32845: GO 32278
// end ; end ;
32847: GO 32278
32849: POP
32850: POP
// end ; end ;
32851: GO 31707
32853: POP
32854: POP
// end ;
32855: LD_VAR 0 1
32859: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32860: LD_INT 0
32862: PPUSH
32863: PPUSH
32864: PPUSH
32865: PPUSH
32866: PPUSH
32867: PPUSH
// if not mc_bases then
32868: LD_EXP 76
32872: NOT
32873: IFFALSE 32877
// exit ;
32875: GO 33304
// for i = 1 to mc_bases do
32877: LD_ADDR_VAR 0 2
32881: PUSH
32882: DOUBLE
32883: LD_INT 1
32885: DEC
32886: ST_TO_ADDR
32887: LD_EXP 76
32891: PUSH
32892: FOR_TO
32893: IFFALSE 33302
// begin tmp := mc_build_upgrade [ i ] ;
32895: LD_ADDR_VAR 0 4
32899: PUSH
32900: LD_EXP 108
32904: PUSH
32905: LD_VAR 0 2
32909: ARRAY
32910: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
32911: LD_ADDR_VAR 0 6
32915: PUSH
32916: LD_EXP 109
32920: PUSH
32921: LD_VAR 0 2
32925: ARRAY
32926: PPUSH
32927: LD_INT 2
32929: PUSH
32930: LD_INT 30
32932: PUSH
32933: LD_INT 6
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: LD_INT 30
32942: PUSH
32943: LD_INT 7
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: LIST
32954: PPUSH
32955: CALL_OW 72
32959: ST_TO_ADDR
// if not tmp and not lab then
32960: LD_VAR 0 4
32964: NOT
32965: PUSH
32966: LD_VAR 0 6
32970: NOT
32971: AND
32972: IFFALSE 32976
// continue ;
32974: GO 32892
// if tmp then
32976: LD_VAR 0 4
32980: IFFALSE 33100
// for j in tmp do
32982: LD_ADDR_VAR 0 3
32986: PUSH
32987: LD_VAR 0 4
32991: PUSH
32992: FOR_IN
32993: IFFALSE 33098
// begin if UpgradeCost ( j ) then
32995: LD_VAR 0 3
32999: PPUSH
33000: CALL 63556 0 1
33004: IFFALSE 33096
// begin ComUpgrade ( j ) ;
33006: LD_VAR 0 3
33010: PPUSH
33011: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33015: LD_ADDR_EXP 108
33019: PUSH
33020: LD_EXP 108
33024: PPUSH
33025: LD_VAR 0 2
33029: PPUSH
33030: LD_EXP 108
33034: PUSH
33035: LD_VAR 0 2
33039: ARRAY
33040: PUSH
33041: LD_VAR 0 3
33045: DIFF
33046: PPUSH
33047: CALL_OW 1
33051: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33052: LD_ADDR_EXP 83
33056: PUSH
33057: LD_EXP 83
33061: PPUSH
33062: LD_VAR 0 2
33066: PUSH
33067: LD_EXP 83
33071: PUSH
33072: LD_VAR 0 2
33076: ARRAY
33077: PUSH
33078: LD_INT 1
33080: PLUS
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PPUSH
33086: LD_VAR 0 3
33090: PPUSH
33091: CALL 57045 0 3
33095: ST_TO_ADDR
// end ; end ;
33096: GO 32992
33098: POP
33099: POP
// if not lab or not mc_lab_upgrade [ i ] then
33100: LD_VAR 0 6
33104: NOT
33105: PUSH
33106: LD_EXP 110
33110: PUSH
33111: LD_VAR 0 2
33115: ARRAY
33116: NOT
33117: OR
33118: IFFALSE 33122
// continue ;
33120: GO 32892
// for j in lab do
33122: LD_ADDR_VAR 0 3
33126: PUSH
33127: LD_VAR 0 6
33131: PUSH
33132: FOR_IN
33133: IFFALSE 33298
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33135: LD_VAR 0 3
33139: PPUSH
33140: CALL_OW 266
33144: PUSH
33145: LD_INT 6
33147: PUSH
33148: LD_INT 7
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: IN
33155: PUSH
33156: LD_VAR 0 3
33160: PPUSH
33161: CALL_OW 461
33165: PUSH
33166: LD_INT 1
33168: NONEQUAL
33169: AND
33170: IFFALSE 33296
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33172: LD_VAR 0 3
33176: PPUSH
33177: LD_EXP 110
33181: PUSH
33182: LD_VAR 0 2
33186: ARRAY
33187: PUSH
33188: LD_INT 1
33190: ARRAY
33191: PPUSH
33192: CALL 63761 0 2
33196: IFFALSE 33296
// begin ComCancel ( j ) ;
33198: LD_VAR 0 3
33202: PPUSH
33203: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33207: LD_VAR 0 3
33211: PPUSH
33212: LD_EXP 110
33216: PUSH
33217: LD_VAR 0 2
33221: ARRAY
33222: PUSH
33223: LD_INT 1
33225: ARRAY
33226: PPUSH
33227: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33231: LD_VAR 0 3
33235: PUSH
33236: LD_EXP 83
33240: PUSH
33241: LD_VAR 0 2
33245: ARRAY
33246: IN
33247: NOT
33248: IFFALSE 33294
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33250: LD_ADDR_EXP 83
33254: PUSH
33255: LD_EXP 83
33259: PPUSH
33260: LD_VAR 0 2
33264: PUSH
33265: LD_EXP 83
33269: PUSH
33270: LD_VAR 0 2
33274: ARRAY
33275: PUSH
33276: LD_INT 1
33278: PLUS
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PPUSH
33284: LD_VAR 0 3
33288: PPUSH
33289: CALL 57045 0 3
33293: ST_TO_ADDR
// break ;
33294: GO 33298
// end ; end ; end ;
33296: GO 33132
33298: POP
33299: POP
// end ;
33300: GO 32892
33302: POP
33303: POP
// end ;
33304: LD_VAR 0 1
33308: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33309: LD_INT 0
33311: PPUSH
33312: PPUSH
33313: PPUSH
33314: PPUSH
33315: PPUSH
33316: PPUSH
33317: PPUSH
33318: PPUSH
33319: PPUSH
// if not mc_bases then
33320: LD_EXP 76
33324: NOT
33325: IFFALSE 33329
// exit ;
33327: GO 33734
// for i = 1 to mc_bases do
33329: LD_ADDR_VAR 0 2
33333: PUSH
33334: DOUBLE
33335: LD_INT 1
33337: DEC
33338: ST_TO_ADDR
33339: LD_EXP 76
33343: PUSH
33344: FOR_TO
33345: IFFALSE 33732
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33347: LD_EXP 84
33351: PUSH
33352: LD_VAR 0 2
33356: ARRAY
33357: NOT
33358: PUSH
33359: LD_EXP 76
33363: PUSH
33364: LD_VAR 0 2
33368: ARRAY
33369: PPUSH
33370: LD_INT 30
33372: PUSH
33373: LD_INT 3
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PPUSH
33380: CALL_OW 72
33384: NOT
33385: OR
33386: IFFALSE 33390
// continue ;
33388: GO 33344
// busy := false ;
33390: LD_ADDR_VAR 0 8
33394: PUSH
33395: LD_INT 0
33397: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33398: LD_ADDR_VAR 0 4
33402: PUSH
33403: LD_EXP 76
33407: PUSH
33408: LD_VAR 0 2
33412: ARRAY
33413: PPUSH
33414: LD_INT 30
33416: PUSH
33417: LD_INT 3
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PPUSH
33424: CALL_OW 72
33428: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33429: LD_ADDR_VAR 0 6
33433: PUSH
33434: LD_EXP 84
33438: PUSH
33439: LD_VAR 0 2
33443: ARRAY
33444: PPUSH
33445: LD_INT 2
33447: PUSH
33448: LD_INT 30
33450: PUSH
33451: LD_INT 32
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 30
33460: PUSH
33461: LD_INT 33
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: EMPTY
33469: LIST
33470: LIST
33471: LIST
33472: PPUSH
33473: CALL_OW 72
33477: ST_TO_ADDR
// if not t then
33478: LD_VAR 0 6
33482: NOT
33483: IFFALSE 33487
// continue ;
33485: GO 33344
// for j in tmp do
33487: LD_ADDR_VAR 0 3
33491: PUSH
33492: LD_VAR 0 4
33496: PUSH
33497: FOR_IN
33498: IFFALSE 33528
// if not BuildingStatus ( j ) = bs_idle then
33500: LD_VAR 0 3
33504: PPUSH
33505: CALL_OW 461
33509: PUSH
33510: LD_INT 2
33512: EQUAL
33513: NOT
33514: IFFALSE 33526
// begin busy := true ;
33516: LD_ADDR_VAR 0 8
33520: PUSH
33521: LD_INT 1
33523: ST_TO_ADDR
// break ;
33524: GO 33528
// end ;
33526: GO 33497
33528: POP
33529: POP
// if busy then
33530: LD_VAR 0 8
33534: IFFALSE 33538
// continue ;
33536: GO 33344
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33538: LD_ADDR_VAR 0 7
33542: PUSH
33543: LD_VAR 0 6
33547: PPUSH
33548: LD_INT 35
33550: PUSH
33551: LD_INT 0
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PPUSH
33558: CALL_OW 72
33562: ST_TO_ADDR
// if tw then
33563: LD_VAR 0 7
33567: IFFALSE 33644
// begin tw := tw [ 1 ] ;
33569: LD_ADDR_VAR 0 7
33573: PUSH
33574: LD_VAR 0 7
33578: PUSH
33579: LD_INT 1
33581: ARRAY
33582: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33583: LD_ADDR_VAR 0 9
33587: PUSH
33588: LD_VAR 0 7
33592: PPUSH
33593: LD_EXP 101
33597: PUSH
33598: LD_VAR 0 2
33602: ARRAY
33603: PPUSH
33604: CALL 62053 0 2
33608: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33609: LD_EXP 115
33613: PUSH
33614: LD_VAR 0 2
33618: ARRAY
33619: IFFALSE 33642
// if not weapon in mc_allowed_tower_weapons [ i ] then
33621: LD_VAR 0 9
33625: PUSH
33626: LD_EXP 115
33630: PUSH
33631: LD_VAR 0 2
33635: ARRAY
33636: IN
33637: NOT
33638: IFFALSE 33642
// continue ;
33640: GO 33344
// end else
33642: GO 33707
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33644: LD_ADDR_VAR 0 5
33648: PUSH
33649: LD_EXP 84
33653: PUSH
33654: LD_VAR 0 2
33658: ARRAY
33659: PPUSH
33660: LD_VAR 0 4
33664: PPUSH
33665: CALL 88905 0 2
33669: ST_TO_ADDR
// if not tmp2 then
33670: LD_VAR 0 5
33674: NOT
33675: IFFALSE 33679
// continue ;
33677: GO 33344
// tw := tmp2 [ 1 ] ;
33679: LD_ADDR_VAR 0 7
33683: PUSH
33684: LD_VAR 0 5
33688: PUSH
33689: LD_INT 1
33691: ARRAY
33692: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33693: LD_ADDR_VAR 0 9
33697: PUSH
33698: LD_VAR 0 5
33702: PUSH
33703: LD_INT 2
33705: ARRAY
33706: ST_TO_ADDR
// end ; if not weapon then
33707: LD_VAR 0 9
33711: NOT
33712: IFFALSE 33716
// continue ;
33714: GO 33344
// ComPlaceWeapon ( tw , weapon ) ;
33716: LD_VAR 0 7
33720: PPUSH
33721: LD_VAR 0 9
33725: PPUSH
33726: CALL_OW 148
// end ;
33730: GO 33344
33732: POP
33733: POP
// end ;
33734: LD_VAR 0 1
33738: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33739: LD_INT 0
33741: PPUSH
33742: PPUSH
33743: PPUSH
33744: PPUSH
33745: PPUSH
33746: PPUSH
33747: PPUSH
// if not mc_bases then
33748: LD_EXP 76
33752: NOT
33753: IFFALSE 33757
// exit ;
33755: GO 34525
// for i = 1 to mc_bases do
33757: LD_ADDR_VAR 0 2
33761: PUSH
33762: DOUBLE
33763: LD_INT 1
33765: DEC
33766: ST_TO_ADDR
33767: LD_EXP 76
33771: PUSH
33772: FOR_TO
33773: IFFALSE 34523
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33775: LD_EXP 89
33779: PUSH
33780: LD_VAR 0 2
33784: ARRAY
33785: NOT
33786: PUSH
33787: LD_EXP 89
33791: PUSH
33792: LD_VAR 0 2
33796: ARRAY
33797: PUSH
33798: LD_EXP 90
33802: PUSH
33803: LD_VAR 0 2
33807: ARRAY
33808: EQUAL
33809: OR
33810: PUSH
33811: LD_EXP 99
33815: PUSH
33816: LD_VAR 0 2
33820: ARRAY
33821: OR
33822: IFFALSE 33826
// continue ;
33824: GO 33772
// if mc_miners [ i ] then
33826: LD_EXP 90
33830: PUSH
33831: LD_VAR 0 2
33835: ARRAY
33836: IFFALSE 34210
// begin for j = mc_miners [ i ] downto 1 do
33838: LD_ADDR_VAR 0 3
33842: PUSH
33843: DOUBLE
33844: LD_EXP 90
33848: PUSH
33849: LD_VAR 0 2
33853: ARRAY
33854: INC
33855: ST_TO_ADDR
33856: LD_INT 1
33858: PUSH
33859: FOR_DOWNTO
33860: IFFALSE 34208
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33862: LD_EXP 90
33866: PUSH
33867: LD_VAR 0 2
33871: ARRAY
33872: PUSH
33873: LD_VAR 0 3
33877: ARRAY
33878: PPUSH
33879: CALL_OW 301
33883: PUSH
33884: LD_EXP 90
33888: PUSH
33889: LD_VAR 0 2
33893: ARRAY
33894: PUSH
33895: LD_VAR 0 3
33899: ARRAY
33900: PPUSH
33901: CALL_OW 257
33905: PUSH
33906: LD_INT 1
33908: NONEQUAL
33909: OR
33910: IFFALSE 33973
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
33912: LD_ADDR_VAR 0 5
33916: PUSH
33917: LD_EXP 90
33921: PUSH
33922: LD_VAR 0 2
33926: ARRAY
33927: PUSH
33928: LD_EXP 90
33932: PUSH
33933: LD_VAR 0 2
33937: ARRAY
33938: PUSH
33939: LD_VAR 0 3
33943: ARRAY
33944: DIFF
33945: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33946: LD_ADDR_EXP 90
33950: PUSH
33951: LD_EXP 90
33955: PPUSH
33956: LD_VAR 0 2
33960: PPUSH
33961: LD_VAR 0 5
33965: PPUSH
33966: CALL_OW 1
33970: ST_TO_ADDR
// continue ;
33971: GO 33859
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33973: LD_EXP 90
33977: PUSH
33978: LD_VAR 0 2
33982: ARRAY
33983: PUSH
33984: LD_VAR 0 3
33988: ARRAY
33989: PPUSH
33990: CALL_OW 257
33994: PUSH
33995: LD_INT 1
33997: EQUAL
33998: PUSH
33999: LD_EXP 90
34003: PUSH
34004: LD_VAR 0 2
34008: ARRAY
34009: PUSH
34010: LD_VAR 0 3
34014: ARRAY
34015: PPUSH
34016: CALL_OW 459
34020: NOT
34021: AND
34022: PUSH
34023: LD_EXP 90
34027: PUSH
34028: LD_VAR 0 2
34032: ARRAY
34033: PUSH
34034: LD_VAR 0 3
34038: ARRAY
34039: PPUSH
34040: CALL_OW 314
34044: NOT
34045: AND
34046: IFFALSE 34206
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34048: LD_EXP 90
34052: PUSH
34053: LD_VAR 0 2
34057: ARRAY
34058: PUSH
34059: LD_VAR 0 3
34063: ARRAY
34064: PPUSH
34065: CALL_OW 310
34069: IFFALSE 34092
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34071: LD_EXP 90
34075: PUSH
34076: LD_VAR 0 2
34080: ARRAY
34081: PUSH
34082: LD_VAR 0 3
34086: ARRAY
34087: PPUSH
34088: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34092: LD_EXP 90
34096: PUSH
34097: LD_VAR 0 2
34101: ARRAY
34102: PUSH
34103: LD_VAR 0 3
34107: ARRAY
34108: PPUSH
34109: CALL_OW 314
34113: NOT
34114: IFFALSE 34206
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34116: LD_ADDR_VAR 0 7
34120: PUSH
34121: LD_INT 1
34123: PPUSH
34124: LD_EXP 89
34128: PUSH
34129: LD_VAR 0 2
34133: ARRAY
34134: PPUSH
34135: CALL_OW 12
34139: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34140: LD_EXP 90
34144: PUSH
34145: LD_VAR 0 2
34149: ARRAY
34150: PUSH
34151: LD_VAR 0 3
34155: ARRAY
34156: PPUSH
34157: LD_EXP 89
34161: PUSH
34162: LD_VAR 0 2
34166: ARRAY
34167: PUSH
34168: LD_VAR 0 7
34172: ARRAY
34173: PUSH
34174: LD_INT 1
34176: ARRAY
34177: PPUSH
34178: LD_EXP 89
34182: PUSH
34183: LD_VAR 0 2
34187: ARRAY
34188: PUSH
34189: LD_VAR 0 7
34193: ARRAY
34194: PUSH
34195: LD_INT 2
34197: ARRAY
34198: PPUSH
34199: LD_INT 0
34201: PPUSH
34202: CALL_OW 193
// end ; end ; end ;
34206: GO 33859
34208: POP
34209: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34210: LD_ADDR_VAR 0 5
34214: PUSH
34215: LD_EXP 76
34219: PUSH
34220: LD_VAR 0 2
34224: ARRAY
34225: PPUSH
34226: LD_INT 2
34228: PUSH
34229: LD_INT 30
34231: PUSH
34232: LD_INT 4
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 30
34241: PUSH
34242: LD_INT 5
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 30
34251: PUSH
34252: LD_INT 32
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: PPUSH
34265: CALL_OW 72
34269: ST_TO_ADDR
// if not tmp then
34270: LD_VAR 0 5
34274: NOT
34275: IFFALSE 34279
// continue ;
34277: GO 33772
// list := [ ] ;
34279: LD_ADDR_VAR 0 6
34283: PUSH
34284: EMPTY
34285: ST_TO_ADDR
// for j in tmp do
34286: LD_ADDR_VAR 0 3
34290: PUSH
34291: LD_VAR 0 5
34295: PUSH
34296: FOR_IN
34297: IFFALSE 34366
// begin for k in UnitsInside ( j ) do
34299: LD_ADDR_VAR 0 4
34303: PUSH
34304: LD_VAR 0 3
34308: PPUSH
34309: CALL_OW 313
34313: PUSH
34314: FOR_IN
34315: IFFALSE 34362
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34317: LD_VAR 0 4
34321: PPUSH
34322: CALL_OW 257
34326: PUSH
34327: LD_INT 1
34329: EQUAL
34330: PUSH
34331: LD_VAR 0 4
34335: PPUSH
34336: CALL_OW 459
34340: NOT
34341: AND
34342: IFFALSE 34360
// list := list ^ k ;
34344: LD_ADDR_VAR 0 6
34348: PUSH
34349: LD_VAR 0 6
34353: PUSH
34354: LD_VAR 0 4
34358: ADD
34359: ST_TO_ADDR
34360: GO 34314
34362: POP
34363: POP
// end ;
34364: GO 34296
34366: POP
34367: POP
// list := list diff mc_miners [ i ] ;
34368: LD_ADDR_VAR 0 6
34372: PUSH
34373: LD_VAR 0 6
34377: PUSH
34378: LD_EXP 90
34382: PUSH
34383: LD_VAR 0 2
34387: ARRAY
34388: DIFF
34389: ST_TO_ADDR
// if not list then
34390: LD_VAR 0 6
34394: NOT
34395: IFFALSE 34399
// continue ;
34397: GO 33772
// k := mc_mines [ i ] - mc_miners [ i ] ;
34399: LD_ADDR_VAR 0 4
34403: PUSH
34404: LD_EXP 89
34408: PUSH
34409: LD_VAR 0 2
34413: ARRAY
34414: PUSH
34415: LD_EXP 90
34419: PUSH
34420: LD_VAR 0 2
34424: ARRAY
34425: MINUS
34426: ST_TO_ADDR
// if k > list then
34427: LD_VAR 0 4
34431: PUSH
34432: LD_VAR 0 6
34436: GREATER
34437: IFFALSE 34449
// k := list ;
34439: LD_ADDR_VAR 0 4
34443: PUSH
34444: LD_VAR 0 6
34448: ST_TO_ADDR
// for j = 1 to k do
34449: LD_ADDR_VAR 0 3
34453: PUSH
34454: DOUBLE
34455: LD_INT 1
34457: DEC
34458: ST_TO_ADDR
34459: LD_VAR 0 4
34463: PUSH
34464: FOR_TO
34465: IFFALSE 34519
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34467: LD_ADDR_EXP 90
34471: PUSH
34472: LD_EXP 90
34476: PPUSH
34477: LD_VAR 0 2
34481: PUSH
34482: LD_EXP 90
34486: PUSH
34487: LD_VAR 0 2
34491: ARRAY
34492: PUSH
34493: LD_INT 1
34495: PLUS
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PPUSH
34501: LD_VAR 0 6
34505: PUSH
34506: LD_VAR 0 3
34510: ARRAY
34511: PPUSH
34512: CALL 57045 0 3
34516: ST_TO_ADDR
34517: GO 34464
34519: POP
34520: POP
// end ;
34521: GO 33772
34523: POP
34524: POP
// end ;
34525: LD_VAR 0 1
34529: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34530: LD_INT 0
34532: PPUSH
34533: PPUSH
34534: PPUSH
34535: PPUSH
34536: PPUSH
34537: PPUSH
34538: PPUSH
34539: PPUSH
34540: PPUSH
34541: PPUSH
34542: PPUSH
// if not mc_bases then
34543: LD_EXP 76
34547: NOT
34548: IFFALSE 34552
// exit ;
34550: GO 36375
// for i = 1 to mc_bases do
34552: LD_ADDR_VAR 0 2
34556: PUSH
34557: DOUBLE
34558: LD_INT 1
34560: DEC
34561: ST_TO_ADDR
34562: LD_EXP 76
34566: PUSH
34567: FOR_TO
34568: IFFALSE 36373
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34570: LD_EXP 76
34574: PUSH
34575: LD_VAR 0 2
34579: ARRAY
34580: NOT
34581: PUSH
34582: LD_EXP 83
34586: PUSH
34587: LD_VAR 0 2
34591: ARRAY
34592: OR
34593: IFFALSE 34597
// continue ;
34595: GO 34567
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34597: LD_EXP 92
34601: PUSH
34602: LD_VAR 0 2
34606: ARRAY
34607: NOT
34608: PUSH
34609: LD_EXP 93
34613: PUSH
34614: LD_VAR 0 2
34618: ARRAY
34619: AND
34620: IFFALSE 34658
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34622: LD_ADDR_EXP 93
34626: PUSH
34627: LD_EXP 93
34631: PPUSH
34632: LD_VAR 0 2
34636: PPUSH
34637: EMPTY
34638: PPUSH
34639: CALL_OW 1
34643: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34644: LD_VAR 0 2
34648: PPUSH
34649: LD_INT 107
34651: PPUSH
34652: CALL 25405 0 2
// continue ;
34656: GO 34567
// end ; target := [ ] ;
34658: LD_ADDR_VAR 0 7
34662: PUSH
34663: EMPTY
34664: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34665: LD_ADDR_VAR 0 6
34669: PUSH
34670: LD_EXP 76
34674: PUSH
34675: LD_VAR 0 2
34679: ARRAY
34680: PUSH
34681: LD_INT 1
34683: ARRAY
34684: PPUSH
34685: CALL_OW 255
34689: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34690: LD_ADDR_VAR 0 9
34694: PUSH
34695: LD_EXP 76
34699: PUSH
34700: LD_VAR 0 2
34704: ARRAY
34705: PPUSH
34706: LD_INT 2
34708: PUSH
34709: LD_INT 30
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 30
34721: PUSH
34722: LD_INT 1
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: LIST
34733: PPUSH
34734: CALL_OW 72
34738: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34739: LD_ADDR_VAR 0 3
34743: PUSH
34744: DOUBLE
34745: LD_EXP 92
34749: PUSH
34750: LD_VAR 0 2
34754: ARRAY
34755: INC
34756: ST_TO_ADDR
34757: LD_INT 1
34759: PUSH
34760: FOR_DOWNTO
34761: IFFALSE 35006
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34763: LD_EXP 92
34767: PUSH
34768: LD_VAR 0 2
34772: ARRAY
34773: PUSH
34774: LD_VAR 0 3
34778: ARRAY
34779: PUSH
34780: LD_INT 2
34782: ARRAY
34783: PPUSH
34784: LD_EXP 92
34788: PUSH
34789: LD_VAR 0 2
34793: ARRAY
34794: PUSH
34795: LD_VAR 0 3
34799: ARRAY
34800: PUSH
34801: LD_INT 3
34803: ARRAY
34804: PPUSH
34805: CALL_OW 488
34809: PUSH
34810: LD_EXP 92
34814: PUSH
34815: LD_VAR 0 2
34819: ARRAY
34820: PUSH
34821: LD_VAR 0 3
34825: ARRAY
34826: PUSH
34827: LD_INT 2
34829: ARRAY
34830: PPUSH
34831: LD_EXP 92
34835: PUSH
34836: LD_VAR 0 2
34840: ARRAY
34841: PUSH
34842: LD_VAR 0 3
34846: ARRAY
34847: PUSH
34848: LD_INT 3
34850: ARRAY
34851: PPUSH
34852: CALL_OW 284
34856: PUSH
34857: LD_INT 0
34859: EQUAL
34860: AND
34861: IFFALSE 34916
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34863: LD_ADDR_VAR 0 5
34867: PUSH
34868: LD_EXP 92
34872: PUSH
34873: LD_VAR 0 2
34877: ARRAY
34878: PPUSH
34879: LD_VAR 0 3
34883: PPUSH
34884: CALL_OW 3
34888: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
34889: LD_ADDR_EXP 92
34893: PUSH
34894: LD_EXP 92
34898: PPUSH
34899: LD_VAR 0 2
34903: PPUSH
34904: LD_VAR 0 5
34908: PPUSH
34909: CALL_OW 1
34913: ST_TO_ADDR
// continue ;
34914: GO 34760
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
34916: LD_VAR 0 6
34920: PPUSH
34921: LD_EXP 92
34925: PUSH
34926: LD_VAR 0 2
34930: ARRAY
34931: PUSH
34932: LD_VAR 0 3
34936: ARRAY
34937: PUSH
34938: LD_INT 2
34940: ARRAY
34941: PPUSH
34942: LD_EXP 92
34946: PUSH
34947: LD_VAR 0 2
34951: ARRAY
34952: PUSH
34953: LD_VAR 0 3
34957: ARRAY
34958: PUSH
34959: LD_INT 3
34961: ARRAY
34962: PPUSH
34963: LD_INT 30
34965: PPUSH
34966: CALL 57941 0 4
34970: PUSH
34971: LD_INT 4
34973: ARRAY
34974: PUSH
34975: LD_INT 0
34977: EQUAL
34978: IFFALSE 35004
// begin target := mc_crates [ i ] [ j ] ;
34980: LD_ADDR_VAR 0 7
34984: PUSH
34985: LD_EXP 92
34989: PUSH
34990: LD_VAR 0 2
34994: ARRAY
34995: PUSH
34996: LD_VAR 0 3
35000: ARRAY
35001: ST_TO_ADDR
// break ;
35002: GO 35006
// end ; end ;
35004: GO 34760
35006: POP
35007: POP
// if not target then
35008: LD_VAR 0 7
35012: NOT
35013: IFFALSE 35017
// continue ;
35015: GO 34567
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35017: LD_ADDR_VAR 0 8
35021: PUSH
35022: LD_EXP 95
35026: PUSH
35027: LD_VAR 0 2
35031: ARRAY
35032: PPUSH
35033: LD_INT 2
35035: PUSH
35036: LD_INT 3
35038: PUSH
35039: LD_INT 58
35041: PUSH
35042: EMPTY
35043: LIST
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 61
35051: PUSH
35052: EMPTY
35053: LIST
35054: PUSH
35055: LD_INT 33
35057: PUSH
35058: LD_INT 5
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: PUSH
35065: LD_INT 33
35067: PUSH
35068: LD_INT 3
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 2
35084: PUSH
35085: LD_INT 34
35087: PUSH
35088: LD_INT 32
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 34
35097: PUSH
35098: LD_INT 51
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 34
35107: PUSH
35108: LD_INT 12
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PPUSH
35125: CALL_OW 72
35129: ST_TO_ADDR
// if not cargo then
35130: LD_VAR 0 8
35134: NOT
35135: IFFALSE 35841
// begin if mc_crates_collector [ i ] < 5 then
35137: LD_EXP 93
35141: PUSH
35142: LD_VAR 0 2
35146: ARRAY
35147: PUSH
35148: LD_INT 5
35150: LESS
35151: IFFALSE 35517
// begin if mc_ape [ i ] then
35153: LD_EXP 105
35157: PUSH
35158: LD_VAR 0 2
35162: ARRAY
35163: IFFALSE 35210
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35165: LD_ADDR_VAR 0 5
35169: PUSH
35170: LD_EXP 105
35174: PUSH
35175: LD_VAR 0 2
35179: ARRAY
35180: PPUSH
35181: LD_INT 25
35183: PUSH
35184: LD_INT 16
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 24
35193: PUSH
35194: LD_INT 750
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PPUSH
35205: CALL_OW 72
35209: ST_TO_ADDR
// if not tmp then
35210: LD_VAR 0 5
35214: NOT
35215: IFFALSE 35262
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35217: LD_ADDR_VAR 0 5
35221: PUSH
35222: LD_EXP 76
35226: PUSH
35227: LD_VAR 0 2
35231: ARRAY
35232: PPUSH
35233: LD_INT 25
35235: PUSH
35236: LD_INT 2
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 24
35245: PUSH
35246: LD_INT 750
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PPUSH
35257: CALL_OW 72
35261: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35262: LD_EXP 105
35266: PUSH
35267: LD_VAR 0 2
35271: ARRAY
35272: PUSH
35273: LD_EXP 76
35277: PUSH
35278: LD_VAR 0 2
35282: ARRAY
35283: PPUSH
35284: LD_INT 25
35286: PUSH
35287: LD_INT 2
35289: PUSH
35290: EMPTY
35291: LIST
35292: LIST
35293: PUSH
35294: LD_INT 24
35296: PUSH
35297: LD_INT 750
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PPUSH
35308: CALL_OW 72
35312: AND
35313: PUSH
35314: LD_VAR 0 5
35318: PUSH
35319: LD_INT 5
35321: LESS
35322: AND
35323: IFFALSE 35405
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35325: LD_ADDR_VAR 0 3
35329: PUSH
35330: LD_EXP 76
35334: PUSH
35335: LD_VAR 0 2
35339: ARRAY
35340: PPUSH
35341: LD_INT 25
35343: PUSH
35344: LD_INT 2
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 24
35353: PUSH
35354: LD_INT 750
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PPUSH
35365: CALL_OW 72
35369: PUSH
35370: FOR_IN
35371: IFFALSE 35403
// begin tmp := tmp union j ;
35373: LD_ADDR_VAR 0 5
35377: PUSH
35378: LD_VAR 0 5
35382: PUSH
35383: LD_VAR 0 3
35387: UNION
35388: ST_TO_ADDR
// if tmp >= 5 then
35389: LD_VAR 0 5
35393: PUSH
35394: LD_INT 5
35396: GREATEREQUAL
35397: IFFALSE 35401
// break ;
35399: GO 35403
// end ;
35401: GO 35370
35403: POP
35404: POP
// end ; if not tmp then
35405: LD_VAR 0 5
35409: NOT
35410: IFFALSE 35414
// continue ;
35412: GO 34567
// for j in tmp do
35414: LD_ADDR_VAR 0 3
35418: PUSH
35419: LD_VAR 0 5
35423: PUSH
35424: FOR_IN
35425: IFFALSE 35515
// if not GetTag ( j ) then
35427: LD_VAR 0 3
35431: PPUSH
35432: CALL_OW 110
35436: NOT
35437: IFFALSE 35513
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35439: LD_ADDR_EXP 93
35443: PUSH
35444: LD_EXP 93
35448: PPUSH
35449: LD_VAR 0 2
35453: PUSH
35454: LD_EXP 93
35458: PUSH
35459: LD_VAR 0 2
35463: ARRAY
35464: PUSH
35465: LD_INT 1
35467: PLUS
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PPUSH
35473: LD_VAR 0 3
35477: PPUSH
35478: CALL 57045 0 3
35482: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35483: LD_VAR 0 3
35487: PPUSH
35488: LD_INT 107
35490: PPUSH
35491: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35495: LD_EXP 93
35499: PUSH
35500: LD_VAR 0 2
35504: ARRAY
35505: PUSH
35506: LD_INT 5
35508: GREATEREQUAL
35509: IFFALSE 35513
// break ;
35511: GO 35515
// end ;
35513: GO 35424
35515: POP
35516: POP
// end ; if mc_crates_collector [ i ] and target then
35517: LD_EXP 93
35521: PUSH
35522: LD_VAR 0 2
35526: ARRAY
35527: PUSH
35528: LD_VAR 0 7
35532: AND
35533: IFFALSE 35839
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35535: LD_EXP 93
35539: PUSH
35540: LD_VAR 0 2
35544: ARRAY
35545: PUSH
35546: LD_VAR 0 7
35550: PUSH
35551: LD_INT 1
35553: ARRAY
35554: LESS
35555: IFFALSE 35575
// tmp := mc_crates_collector [ i ] else
35557: LD_ADDR_VAR 0 5
35561: PUSH
35562: LD_EXP 93
35566: PUSH
35567: LD_VAR 0 2
35571: ARRAY
35572: ST_TO_ADDR
35573: GO 35589
// tmp := target [ 1 ] ;
35575: LD_ADDR_VAR 0 5
35579: PUSH
35580: LD_VAR 0 7
35584: PUSH
35585: LD_INT 1
35587: ARRAY
35588: ST_TO_ADDR
// k := 0 ;
35589: LD_ADDR_VAR 0 4
35593: PUSH
35594: LD_INT 0
35596: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35597: LD_ADDR_VAR 0 3
35601: PUSH
35602: LD_EXP 93
35606: PUSH
35607: LD_VAR 0 2
35611: ARRAY
35612: PUSH
35613: FOR_IN
35614: IFFALSE 35837
// begin k := k + 1 ;
35616: LD_ADDR_VAR 0 4
35620: PUSH
35621: LD_VAR 0 4
35625: PUSH
35626: LD_INT 1
35628: PLUS
35629: ST_TO_ADDR
// if k > tmp then
35630: LD_VAR 0 4
35634: PUSH
35635: LD_VAR 0 5
35639: GREATER
35640: IFFALSE 35644
// break ;
35642: GO 35837
// if not GetClass ( j ) in [ 2 , 16 ] then
35644: LD_VAR 0 3
35648: PPUSH
35649: CALL_OW 257
35653: PUSH
35654: LD_INT 2
35656: PUSH
35657: LD_INT 16
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: IN
35664: NOT
35665: IFFALSE 35718
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35667: LD_ADDR_EXP 93
35671: PUSH
35672: LD_EXP 93
35676: PPUSH
35677: LD_VAR 0 2
35681: PPUSH
35682: LD_EXP 93
35686: PUSH
35687: LD_VAR 0 2
35691: ARRAY
35692: PUSH
35693: LD_VAR 0 3
35697: DIFF
35698: PPUSH
35699: CALL_OW 1
35703: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35704: LD_VAR 0 3
35708: PPUSH
35709: LD_INT 0
35711: PPUSH
35712: CALL_OW 109
// continue ;
35716: GO 35613
// end ; if IsInUnit ( j ) then
35718: LD_VAR 0 3
35722: PPUSH
35723: CALL_OW 310
35727: IFFALSE 35738
// ComExitBuilding ( j ) ;
35729: LD_VAR 0 3
35733: PPUSH
35734: CALL_OW 122
// wait ( 3 ) ;
35738: LD_INT 3
35740: PPUSH
35741: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35745: LD_VAR 0 3
35749: PPUSH
35750: CALL_OW 314
35754: PUSH
35755: LD_VAR 0 6
35759: PPUSH
35760: LD_VAR 0 7
35764: PUSH
35765: LD_INT 2
35767: ARRAY
35768: PPUSH
35769: LD_VAR 0 7
35773: PUSH
35774: LD_INT 3
35776: ARRAY
35777: PPUSH
35778: LD_INT 30
35780: PPUSH
35781: CALL 57941 0 4
35785: PUSH
35786: LD_INT 4
35788: ARRAY
35789: AND
35790: IFFALSE 35808
// ComStandNearbyBuilding ( j , depot ) else
35792: LD_VAR 0 3
35796: PPUSH
35797: LD_VAR 0 9
35801: PPUSH
35802: CALL 53472 0 2
35806: GO 35835
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35808: LD_VAR 0 3
35812: PPUSH
35813: LD_VAR 0 7
35817: PUSH
35818: LD_INT 2
35820: ARRAY
35821: PPUSH
35822: LD_VAR 0 7
35826: PUSH
35827: LD_INT 3
35829: ARRAY
35830: PPUSH
35831: CALL_OW 117
// end ;
35835: GO 35613
35837: POP
35838: POP
// end ; end else
35839: GO 36371
// begin for j in cargo do
35841: LD_ADDR_VAR 0 3
35845: PUSH
35846: LD_VAR 0 8
35850: PUSH
35851: FOR_IN
35852: IFFALSE 36369
// begin if GetTag ( j ) <> 0 then
35854: LD_VAR 0 3
35858: PPUSH
35859: CALL_OW 110
35863: PUSH
35864: LD_INT 0
35866: NONEQUAL
35867: IFFALSE 35871
// continue ;
35869: GO 35851
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35871: LD_VAR 0 3
35875: PPUSH
35876: CALL_OW 256
35880: PUSH
35881: LD_INT 1000
35883: LESS
35884: PUSH
35885: LD_VAR 0 3
35889: PPUSH
35890: LD_EXP 100
35894: PUSH
35895: LD_VAR 0 2
35899: ARRAY
35900: PPUSH
35901: CALL_OW 308
35905: NOT
35906: AND
35907: IFFALSE 35929
// ComMoveToArea ( j , mc_parking [ i ] ) ;
35909: LD_VAR 0 3
35913: PPUSH
35914: LD_EXP 100
35918: PUSH
35919: LD_VAR 0 2
35923: ARRAY
35924: PPUSH
35925: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
35929: LD_VAR 0 3
35933: PPUSH
35934: CALL_OW 256
35938: PUSH
35939: LD_INT 1000
35941: LESS
35942: PUSH
35943: LD_VAR 0 3
35947: PPUSH
35948: LD_EXP 100
35952: PUSH
35953: LD_VAR 0 2
35957: ARRAY
35958: PPUSH
35959: CALL_OW 308
35963: AND
35964: IFFALSE 35968
// continue ;
35966: GO 35851
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
35968: LD_VAR 0 3
35972: PPUSH
35973: CALL_OW 262
35977: PUSH
35978: LD_INT 2
35980: EQUAL
35981: PUSH
35982: LD_VAR 0 3
35986: PPUSH
35987: CALL_OW 261
35991: PUSH
35992: LD_INT 15
35994: LESS
35995: AND
35996: IFFALSE 36000
// continue ;
35998: GO 35851
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36000: LD_VAR 0 3
36004: PPUSH
36005: CALL_OW 262
36009: PUSH
36010: LD_INT 1
36012: EQUAL
36013: PUSH
36014: LD_VAR 0 3
36018: PPUSH
36019: CALL_OW 261
36023: PUSH
36024: LD_INT 10
36026: LESS
36027: AND
36028: IFFALSE 36308
// begin if not depot then
36030: LD_VAR 0 9
36034: NOT
36035: IFFALSE 36039
// continue ;
36037: GO 35851
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36039: LD_VAR 0 3
36043: PPUSH
36044: LD_VAR 0 9
36048: PPUSH
36049: LD_VAR 0 3
36053: PPUSH
36054: CALL_OW 74
36058: PPUSH
36059: CALL_OW 296
36063: PUSH
36064: LD_INT 6
36066: LESS
36067: IFFALSE 36083
// SetFuel ( j , 100 ) else
36069: LD_VAR 0 3
36073: PPUSH
36074: LD_INT 100
36076: PPUSH
36077: CALL_OW 240
36081: GO 36308
// if GetFuel ( j ) = 0 then
36083: LD_VAR 0 3
36087: PPUSH
36088: CALL_OW 261
36092: PUSH
36093: LD_INT 0
36095: EQUAL
36096: IFFALSE 36308
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36098: LD_ADDR_EXP 95
36102: PUSH
36103: LD_EXP 95
36107: PPUSH
36108: LD_VAR 0 2
36112: PPUSH
36113: LD_EXP 95
36117: PUSH
36118: LD_VAR 0 2
36122: ARRAY
36123: PUSH
36124: LD_VAR 0 3
36128: DIFF
36129: PPUSH
36130: CALL_OW 1
36134: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36135: LD_VAR 0 3
36139: PPUSH
36140: CALL_OW 263
36144: PUSH
36145: LD_INT 1
36147: EQUAL
36148: IFFALSE 36164
// ComExitVehicle ( IsInUnit ( j ) ) ;
36150: LD_VAR 0 3
36154: PPUSH
36155: CALL_OW 310
36159: PPUSH
36160: CALL_OW 121
// if GetControl ( j ) = control_remote then
36164: LD_VAR 0 3
36168: PPUSH
36169: CALL_OW 263
36173: PUSH
36174: LD_INT 2
36176: EQUAL
36177: IFFALSE 36188
// ComUnlink ( j ) ;
36179: LD_VAR 0 3
36183: PPUSH
36184: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36188: LD_ADDR_VAR 0 10
36192: PUSH
36193: LD_VAR 0 2
36197: PPUSH
36198: LD_INT 3
36200: PPUSH
36201: CALL 45975 0 2
36205: ST_TO_ADDR
// if fac then
36206: LD_VAR 0 10
36210: IFFALSE 36306
// begin for k in fac do
36212: LD_ADDR_VAR 0 4
36216: PUSH
36217: LD_VAR 0 10
36221: PUSH
36222: FOR_IN
36223: IFFALSE 36304
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36225: LD_ADDR_VAR 0 11
36229: PUSH
36230: LD_VAR 0 10
36234: PPUSH
36235: LD_VAR 0 3
36239: PPUSH
36240: CALL_OW 265
36244: PPUSH
36245: LD_VAR 0 3
36249: PPUSH
36250: CALL_OW 262
36254: PPUSH
36255: LD_VAR 0 3
36259: PPUSH
36260: CALL_OW 263
36264: PPUSH
36265: LD_VAR 0 3
36269: PPUSH
36270: CALL_OW 264
36274: PPUSH
36275: CALL 54543 0 5
36279: ST_TO_ADDR
// if components then
36280: LD_VAR 0 11
36284: IFFALSE 36302
// begin MC_InsertProduceList ( i , components ) ;
36286: LD_VAR 0 2
36290: PPUSH
36291: LD_VAR 0 11
36295: PPUSH
36296: CALL 45520 0 2
// break ;
36300: GO 36304
// end ; end ;
36302: GO 36222
36304: POP
36305: POP
// end ; continue ;
36306: GO 35851
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36308: LD_VAR 0 3
36312: PPUSH
36313: LD_INT 1
36315: PPUSH
36316: CALL_OW 289
36320: PUSH
36321: LD_INT 100
36323: LESS
36324: PUSH
36325: LD_VAR 0 3
36329: PPUSH
36330: CALL_OW 314
36334: NOT
36335: AND
36336: IFFALSE 36365
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36338: LD_VAR 0 3
36342: PPUSH
36343: LD_VAR 0 7
36347: PUSH
36348: LD_INT 2
36350: ARRAY
36351: PPUSH
36352: LD_VAR 0 7
36356: PUSH
36357: LD_INT 3
36359: ARRAY
36360: PPUSH
36361: CALL_OW 117
// break ;
36365: GO 36369
// end ;
36367: GO 35851
36369: POP
36370: POP
// end ; end ;
36371: GO 34567
36373: POP
36374: POP
// end ;
36375: LD_VAR 0 1
36379: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36380: LD_INT 0
36382: PPUSH
36383: PPUSH
36384: PPUSH
36385: PPUSH
// if not mc_bases then
36386: LD_EXP 76
36390: NOT
36391: IFFALSE 36395
// exit ;
36393: GO 36556
// for i = 1 to mc_bases do
36395: LD_ADDR_VAR 0 2
36399: PUSH
36400: DOUBLE
36401: LD_INT 1
36403: DEC
36404: ST_TO_ADDR
36405: LD_EXP 76
36409: PUSH
36410: FOR_TO
36411: IFFALSE 36554
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36413: LD_ADDR_VAR 0 4
36417: PUSH
36418: LD_EXP 95
36422: PUSH
36423: LD_VAR 0 2
36427: ARRAY
36428: PUSH
36429: LD_EXP 98
36433: PUSH
36434: LD_VAR 0 2
36438: ARRAY
36439: UNION
36440: PPUSH
36441: LD_INT 33
36443: PUSH
36444: LD_INT 2
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PPUSH
36451: CALL_OW 72
36455: ST_TO_ADDR
// if tmp then
36456: LD_VAR 0 4
36460: IFFALSE 36552
// for j in tmp do
36462: LD_ADDR_VAR 0 3
36466: PUSH
36467: LD_VAR 0 4
36471: PUSH
36472: FOR_IN
36473: IFFALSE 36550
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36475: LD_VAR 0 3
36479: PPUSH
36480: CALL_OW 312
36484: NOT
36485: PUSH
36486: LD_VAR 0 3
36490: PPUSH
36491: CALL_OW 256
36495: PUSH
36496: LD_INT 250
36498: GREATEREQUAL
36499: AND
36500: IFFALSE 36513
// Connect ( j ) else
36502: LD_VAR 0 3
36506: PPUSH
36507: CALL 60014 0 1
36511: GO 36548
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36513: LD_VAR 0 3
36517: PPUSH
36518: CALL_OW 256
36522: PUSH
36523: LD_INT 250
36525: LESS
36526: PUSH
36527: LD_VAR 0 3
36531: PPUSH
36532: CALL_OW 312
36536: AND
36537: IFFALSE 36548
// ComUnlink ( j ) ;
36539: LD_VAR 0 3
36543: PPUSH
36544: CALL_OW 136
36548: GO 36472
36550: POP
36551: POP
// end ;
36552: GO 36410
36554: POP
36555: POP
// end ;
36556: LD_VAR 0 1
36560: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36561: LD_INT 0
36563: PPUSH
36564: PPUSH
36565: PPUSH
36566: PPUSH
36567: PPUSH
// if not mc_bases then
36568: LD_EXP 76
36572: NOT
36573: IFFALSE 36577
// exit ;
36575: GO 37022
// for i = 1 to mc_bases do
36577: LD_ADDR_VAR 0 2
36581: PUSH
36582: DOUBLE
36583: LD_INT 1
36585: DEC
36586: ST_TO_ADDR
36587: LD_EXP 76
36591: PUSH
36592: FOR_TO
36593: IFFALSE 37020
// begin if not mc_produce [ i ] then
36595: LD_EXP 97
36599: PUSH
36600: LD_VAR 0 2
36604: ARRAY
36605: NOT
36606: IFFALSE 36610
// continue ;
36608: GO 36592
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36610: LD_ADDR_VAR 0 5
36614: PUSH
36615: LD_EXP 76
36619: PUSH
36620: LD_VAR 0 2
36624: ARRAY
36625: PPUSH
36626: LD_INT 30
36628: PUSH
36629: LD_INT 3
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PPUSH
36636: CALL_OW 72
36640: ST_TO_ADDR
// if not fac then
36641: LD_VAR 0 5
36645: NOT
36646: IFFALSE 36650
// continue ;
36648: GO 36592
// for j in fac do
36650: LD_ADDR_VAR 0 3
36654: PUSH
36655: LD_VAR 0 5
36659: PUSH
36660: FOR_IN
36661: IFFALSE 37016
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36663: LD_VAR 0 3
36667: PPUSH
36668: CALL_OW 461
36672: PUSH
36673: LD_INT 2
36675: NONEQUAL
36676: PUSH
36677: LD_VAR 0 3
36681: PPUSH
36682: LD_INT 15
36684: PPUSH
36685: CALL 59642 0 2
36689: PUSH
36690: LD_INT 4
36692: ARRAY
36693: OR
36694: IFFALSE 36698
// continue ;
36696: GO 36660
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36698: LD_VAR 0 3
36702: PPUSH
36703: LD_EXP 97
36707: PUSH
36708: LD_VAR 0 2
36712: ARRAY
36713: PUSH
36714: LD_INT 1
36716: ARRAY
36717: PUSH
36718: LD_INT 1
36720: ARRAY
36721: PPUSH
36722: LD_EXP 97
36726: PUSH
36727: LD_VAR 0 2
36731: ARRAY
36732: PUSH
36733: LD_INT 1
36735: ARRAY
36736: PUSH
36737: LD_INT 2
36739: ARRAY
36740: PPUSH
36741: LD_EXP 97
36745: PUSH
36746: LD_VAR 0 2
36750: ARRAY
36751: PUSH
36752: LD_INT 1
36754: ARRAY
36755: PUSH
36756: LD_INT 3
36758: ARRAY
36759: PPUSH
36760: LD_EXP 97
36764: PUSH
36765: LD_VAR 0 2
36769: ARRAY
36770: PUSH
36771: LD_INT 1
36773: ARRAY
36774: PUSH
36775: LD_INT 4
36777: ARRAY
36778: PPUSH
36779: CALL_OW 448
36783: PUSH
36784: LD_VAR 0 3
36788: PPUSH
36789: LD_EXP 97
36793: PUSH
36794: LD_VAR 0 2
36798: ARRAY
36799: PUSH
36800: LD_INT 1
36802: ARRAY
36803: PUSH
36804: LD_INT 1
36806: ARRAY
36807: PUSH
36808: LD_EXP 97
36812: PUSH
36813: LD_VAR 0 2
36817: ARRAY
36818: PUSH
36819: LD_INT 1
36821: ARRAY
36822: PUSH
36823: LD_INT 2
36825: ARRAY
36826: PUSH
36827: LD_EXP 97
36831: PUSH
36832: LD_VAR 0 2
36836: ARRAY
36837: PUSH
36838: LD_INT 1
36840: ARRAY
36841: PUSH
36842: LD_INT 3
36844: ARRAY
36845: PUSH
36846: LD_EXP 97
36850: PUSH
36851: LD_VAR 0 2
36855: ARRAY
36856: PUSH
36857: LD_INT 1
36859: ARRAY
36860: PUSH
36861: LD_INT 4
36863: ARRAY
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: PPUSH
36871: CALL 63409 0 2
36875: AND
36876: IFFALSE 37014
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
36878: LD_VAR 0 3
36882: PPUSH
36883: LD_EXP 97
36887: PUSH
36888: LD_VAR 0 2
36892: ARRAY
36893: PUSH
36894: LD_INT 1
36896: ARRAY
36897: PUSH
36898: LD_INT 1
36900: ARRAY
36901: PPUSH
36902: LD_EXP 97
36906: PUSH
36907: LD_VAR 0 2
36911: ARRAY
36912: PUSH
36913: LD_INT 1
36915: ARRAY
36916: PUSH
36917: LD_INT 2
36919: ARRAY
36920: PPUSH
36921: LD_EXP 97
36925: PUSH
36926: LD_VAR 0 2
36930: ARRAY
36931: PUSH
36932: LD_INT 1
36934: ARRAY
36935: PUSH
36936: LD_INT 3
36938: ARRAY
36939: PPUSH
36940: LD_EXP 97
36944: PUSH
36945: LD_VAR 0 2
36949: ARRAY
36950: PUSH
36951: LD_INT 1
36953: ARRAY
36954: PUSH
36955: LD_INT 4
36957: ARRAY
36958: PPUSH
36959: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
36963: LD_ADDR_VAR 0 4
36967: PUSH
36968: LD_EXP 97
36972: PUSH
36973: LD_VAR 0 2
36977: ARRAY
36978: PPUSH
36979: LD_INT 1
36981: PPUSH
36982: CALL_OW 3
36986: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
36987: LD_ADDR_EXP 97
36991: PUSH
36992: LD_EXP 97
36996: PPUSH
36997: LD_VAR 0 2
37001: PPUSH
37002: LD_VAR 0 4
37006: PPUSH
37007: CALL_OW 1
37011: ST_TO_ADDR
// break ;
37012: GO 37016
// end ; end ;
37014: GO 36660
37016: POP
37017: POP
// end ;
37018: GO 36592
37020: POP
37021: POP
// end ;
37022: LD_VAR 0 1
37026: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37027: LD_INT 0
37029: PPUSH
37030: PPUSH
37031: PPUSH
// if not mc_bases then
37032: LD_EXP 76
37036: NOT
37037: IFFALSE 37041
// exit ;
37039: GO 37130
// for i = 1 to mc_bases do
37041: LD_ADDR_VAR 0 2
37045: PUSH
37046: DOUBLE
37047: LD_INT 1
37049: DEC
37050: ST_TO_ADDR
37051: LD_EXP 76
37055: PUSH
37056: FOR_TO
37057: IFFALSE 37128
// begin if mc_attack [ i ] then
37059: LD_EXP 96
37063: PUSH
37064: LD_VAR 0 2
37068: ARRAY
37069: IFFALSE 37126
// begin tmp := mc_attack [ i ] [ 1 ] ;
37071: LD_ADDR_VAR 0 3
37075: PUSH
37076: LD_EXP 96
37080: PUSH
37081: LD_VAR 0 2
37085: ARRAY
37086: PUSH
37087: LD_INT 1
37089: ARRAY
37090: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37091: LD_ADDR_EXP 96
37095: PUSH
37096: LD_EXP 96
37100: PPUSH
37101: LD_VAR 0 2
37105: PPUSH
37106: EMPTY
37107: PPUSH
37108: CALL_OW 1
37112: ST_TO_ADDR
// Attack ( tmp ) ;
37113: LD_VAR 0 3
37117: PPUSH
37118: CALL 113104 0 1
// exit ;
37122: POP
37123: POP
37124: GO 37130
// end ; end ;
37126: GO 37056
37128: POP
37129: POP
// end ;
37130: LD_VAR 0 1
37134: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37135: LD_INT 0
37137: PPUSH
37138: PPUSH
37139: PPUSH
37140: PPUSH
37141: PPUSH
37142: PPUSH
37143: PPUSH
// if not mc_bases then
37144: LD_EXP 76
37148: NOT
37149: IFFALSE 37153
// exit ;
37151: GO 38010
// for i = 1 to mc_bases do
37153: LD_ADDR_VAR 0 2
37157: PUSH
37158: DOUBLE
37159: LD_INT 1
37161: DEC
37162: ST_TO_ADDR
37163: LD_EXP 76
37167: PUSH
37168: FOR_TO
37169: IFFALSE 38008
// begin if not mc_bases [ i ] then
37171: LD_EXP 76
37175: PUSH
37176: LD_VAR 0 2
37180: ARRAY
37181: NOT
37182: IFFALSE 37186
// continue ;
37184: GO 37168
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37186: LD_ADDR_VAR 0 7
37190: PUSH
37191: LD_EXP 76
37195: PUSH
37196: LD_VAR 0 2
37200: ARRAY
37201: PUSH
37202: LD_INT 1
37204: ARRAY
37205: PPUSH
37206: CALL 53694 0 1
37210: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37211: LD_ADDR_EXP 99
37215: PUSH
37216: LD_EXP 99
37220: PPUSH
37221: LD_VAR 0 2
37225: PPUSH
37226: LD_EXP 76
37230: PUSH
37231: LD_VAR 0 2
37235: ARRAY
37236: PUSH
37237: LD_INT 1
37239: ARRAY
37240: PPUSH
37241: CALL_OW 255
37245: PPUSH
37246: LD_EXP 101
37250: PUSH
37251: LD_VAR 0 2
37255: ARRAY
37256: PPUSH
37257: CALL 53659 0 2
37261: PPUSH
37262: CALL_OW 1
37266: ST_TO_ADDR
// if not mc_scan [ i ] then
37267: LD_EXP 99
37271: PUSH
37272: LD_VAR 0 2
37276: ARRAY
37277: NOT
37278: IFFALSE 37456
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37280: LD_ADDR_EXP 119
37284: PUSH
37285: LD_EXP 119
37289: PPUSH
37290: LD_VAR 0 2
37294: PPUSH
37295: LD_INT 0
37297: PPUSH
37298: CALL_OW 1
37302: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37303: LD_ADDR_VAR 0 4
37307: PUSH
37308: LD_EXP 76
37312: PUSH
37313: LD_VAR 0 2
37317: ARRAY
37318: PPUSH
37319: LD_INT 2
37321: PUSH
37322: LD_INT 25
37324: PUSH
37325: LD_INT 5
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 25
37334: PUSH
37335: LD_INT 8
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 25
37344: PUSH
37345: LD_INT 9
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: PPUSH
37358: CALL_OW 72
37362: ST_TO_ADDR
// if not tmp then
37363: LD_VAR 0 4
37367: NOT
37368: IFFALSE 37372
// continue ;
37370: GO 37168
// for j in tmp do
37372: LD_ADDR_VAR 0 3
37376: PUSH
37377: LD_VAR 0 4
37381: PUSH
37382: FOR_IN
37383: IFFALSE 37454
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37385: LD_VAR 0 3
37389: PPUSH
37390: CALL_OW 310
37394: PPUSH
37395: CALL_OW 266
37399: PUSH
37400: LD_INT 5
37402: EQUAL
37403: PUSH
37404: LD_VAR 0 3
37408: PPUSH
37409: CALL_OW 257
37413: PUSH
37414: LD_INT 1
37416: EQUAL
37417: AND
37418: PUSH
37419: LD_VAR 0 3
37423: PPUSH
37424: CALL_OW 459
37428: NOT
37429: AND
37430: PUSH
37431: LD_VAR 0 7
37435: AND
37436: IFFALSE 37452
// ComChangeProfession ( j , class ) ;
37438: LD_VAR 0 3
37442: PPUSH
37443: LD_VAR 0 7
37447: PPUSH
37448: CALL_OW 123
37452: GO 37382
37454: POP
37455: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37456: LD_EXP 99
37460: PUSH
37461: LD_VAR 0 2
37465: ARRAY
37466: PUSH
37467: LD_EXP 119
37471: PUSH
37472: LD_VAR 0 2
37476: ARRAY
37477: NOT
37478: AND
37479: PUSH
37480: LD_EXP 98
37484: PUSH
37485: LD_VAR 0 2
37489: ARRAY
37490: NOT
37491: AND
37492: PUSH
37493: LD_EXP 76
37497: PUSH
37498: LD_VAR 0 2
37502: ARRAY
37503: PPUSH
37504: LD_INT 50
37506: PUSH
37507: EMPTY
37508: LIST
37509: PUSH
37510: LD_INT 2
37512: PUSH
37513: LD_INT 30
37515: PUSH
37516: LD_INT 32
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 30
37525: PUSH
37526: LD_INT 33
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 30
37535: PUSH
37536: LD_INT 4
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 30
37545: PUSH
37546: LD_INT 5
37548: PUSH
37549: EMPTY
37550: LIST
37551: LIST
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: LIST
37557: LIST
37558: LIST
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: PPUSH
37564: CALL_OW 72
37568: PUSH
37569: LD_INT 4
37571: LESS
37572: PUSH
37573: LD_EXP 76
37577: PUSH
37578: LD_VAR 0 2
37582: ARRAY
37583: PPUSH
37584: LD_INT 3
37586: PUSH
37587: LD_INT 24
37589: PUSH
37590: LD_INT 1000
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 2
37603: PUSH
37604: LD_INT 30
37606: PUSH
37607: LD_INT 0
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 30
37616: PUSH
37617: LD_INT 1
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: LIST
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PPUSH
37633: CALL_OW 72
37637: OR
37638: AND
37639: IFFALSE 37890
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37641: LD_ADDR_EXP 119
37645: PUSH
37646: LD_EXP 119
37650: PPUSH
37651: LD_VAR 0 2
37655: PPUSH
37656: LD_INT 1
37658: PPUSH
37659: CALL_OW 1
37663: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37664: LD_ADDR_VAR 0 4
37668: PUSH
37669: LD_EXP 76
37673: PUSH
37674: LD_VAR 0 2
37678: ARRAY
37679: PPUSH
37680: LD_INT 2
37682: PUSH
37683: LD_INT 25
37685: PUSH
37686: LD_INT 1
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 25
37695: PUSH
37696: LD_INT 5
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 25
37705: PUSH
37706: LD_INT 8
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 25
37715: PUSH
37716: LD_INT 9
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: PPUSH
37730: CALL_OW 72
37734: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37735: LD_ADDR_VAR 0 4
37739: PUSH
37740: LD_VAR 0 4
37744: PUSH
37745: LD_VAR 0 4
37749: PPUSH
37750: LD_INT 18
37752: PPUSH
37753: CALL 86931 0 2
37757: DIFF
37758: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37759: LD_VAR 0 4
37763: NOT
37764: PUSH
37765: LD_EXP 76
37769: PUSH
37770: LD_VAR 0 2
37774: ARRAY
37775: PPUSH
37776: LD_INT 2
37778: PUSH
37779: LD_INT 30
37781: PUSH
37782: LD_INT 4
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 30
37791: PUSH
37792: LD_INT 5
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: LIST
37803: PPUSH
37804: CALL_OW 72
37808: NOT
37809: AND
37810: IFFALSE 37872
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37812: LD_ADDR_VAR 0 4
37816: PUSH
37817: LD_EXP 76
37821: PUSH
37822: LD_VAR 0 2
37826: ARRAY
37827: PPUSH
37828: LD_INT 2
37830: PUSH
37831: LD_INT 25
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 25
37843: PUSH
37844: LD_INT 3
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 25
37853: PUSH
37854: LD_INT 4
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: LIST
37865: LIST
37866: PPUSH
37867: CALL_OW 72
37871: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
37872: LD_VAR 0 2
37876: PPUSH
37877: LD_VAR 0 4
37881: PPUSH
37882: CALL 117813 0 2
// exit ;
37886: POP
37887: POP
37888: GO 38010
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
37890: LD_EXP 99
37894: PUSH
37895: LD_VAR 0 2
37899: ARRAY
37900: PUSH
37901: LD_EXP 119
37905: PUSH
37906: LD_VAR 0 2
37910: ARRAY
37911: NOT
37912: AND
37913: PUSH
37914: LD_EXP 98
37918: PUSH
37919: LD_VAR 0 2
37923: ARRAY
37924: AND
37925: IFFALSE 38006
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37927: LD_ADDR_EXP 119
37931: PUSH
37932: LD_EXP 119
37936: PPUSH
37937: LD_VAR 0 2
37941: PPUSH
37942: LD_INT 1
37944: PPUSH
37945: CALL_OW 1
37949: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
37950: LD_ADDR_VAR 0 4
37954: PUSH
37955: LD_EXP 98
37959: PUSH
37960: LD_VAR 0 2
37964: ARRAY
37965: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37966: LD_ADDR_EXP 98
37970: PUSH
37971: LD_EXP 98
37975: PPUSH
37976: LD_VAR 0 2
37980: PPUSH
37981: EMPTY
37982: PPUSH
37983: CALL_OW 1
37987: ST_TO_ADDR
// Defend ( i , tmp ) ;
37988: LD_VAR 0 2
37992: PPUSH
37993: LD_VAR 0 4
37997: PPUSH
37998: CALL 118409 0 2
// exit ;
38002: POP
38003: POP
38004: GO 38010
// end ; end ;
38006: GO 37168
38008: POP
38009: POP
// end ;
38010: LD_VAR 0 1
38014: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38015: LD_INT 0
38017: PPUSH
38018: PPUSH
38019: PPUSH
38020: PPUSH
38021: PPUSH
38022: PPUSH
38023: PPUSH
38024: PPUSH
38025: PPUSH
38026: PPUSH
38027: PPUSH
// if not mc_bases then
38028: LD_EXP 76
38032: NOT
38033: IFFALSE 38037
// exit ;
38035: GO 39124
// for i = 1 to mc_bases do
38037: LD_ADDR_VAR 0 2
38041: PUSH
38042: DOUBLE
38043: LD_INT 1
38045: DEC
38046: ST_TO_ADDR
38047: LD_EXP 76
38051: PUSH
38052: FOR_TO
38053: IFFALSE 39122
// begin tmp := mc_lab [ i ] ;
38055: LD_ADDR_VAR 0 6
38059: PUSH
38060: LD_EXP 109
38064: PUSH
38065: LD_VAR 0 2
38069: ARRAY
38070: ST_TO_ADDR
// if not tmp then
38071: LD_VAR 0 6
38075: NOT
38076: IFFALSE 38080
// continue ;
38078: GO 38052
// idle_lab := 0 ;
38080: LD_ADDR_VAR 0 11
38084: PUSH
38085: LD_INT 0
38087: ST_TO_ADDR
// for j in tmp do
38088: LD_ADDR_VAR 0 3
38092: PUSH
38093: LD_VAR 0 6
38097: PUSH
38098: FOR_IN
38099: IFFALSE 39118
// begin researching := false ;
38101: LD_ADDR_VAR 0 10
38105: PUSH
38106: LD_INT 0
38108: ST_TO_ADDR
// side := GetSide ( j ) ;
38109: LD_ADDR_VAR 0 4
38113: PUSH
38114: LD_VAR 0 3
38118: PPUSH
38119: CALL_OW 255
38123: ST_TO_ADDR
// if not mc_tech [ side ] then
38124: LD_EXP 103
38128: PUSH
38129: LD_VAR 0 4
38133: ARRAY
38134: NOT
38135: IFFALSE 38139
// continue ;
38137: GO 38098
// if BuildingStatus ( j ) = bs_idle then
38139: LD_VAR 0 3
38143: PPUSH
38144: CALL_OW 461
38148: PUSH
38149: LD_INT 2
38151: EQUAL
38152: IFFALSE 38340
// begin if idle_lab and UnitsInside ( j ) < 6 then
38154: LD_VAR 0 11
38158: PUSH
38159: LD_VAR 0 3
38163: PPUSH
38164: CALL_OW 313
38168: PUSH
38169: LD_INT 6
38171: LESS
38172: AND
38173: IFFALSE 38244
// begin tmp2 := UnitsInside ( idle_lab ) ;
38175: LD_ADDR_VAR 0 9
38179: PUSH
38180: LD_VAR 0 11
38184: PPUSH
38185: CALL_OW 313
38189: ST_TO_ADDR
// if tmp2 then
38190: LD_VAR 0 9
38194: IFFALSE 38236
// for x in tmp2 do
38196: LD_ADDR_VAR 0 7
38200: PUSH
38201: LD_VAR 0 9
38205: PUSH
38206: FOR_IN
38207: IFFALSE 38234
// begin ComExitBuilding ( x ) ;
38209: LD_VAR 0 7
38213: PPUSH
38214: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38218: LD_VAR 0 7
38222: PPUSH
38223: LD_VAR 0 3
38227: PPUSH
38228: CALL_OW 180
// end ;
38232: GO 38206
38234: POP
38235: POP
// idle_lab := 0 ;
38236: LD_ADDR_VAR 0 11
38240: PUSH
38241: LD_INT 0
38243: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38244: LD_ADDR_VAR 0 5
38248: PUSH
38249: LD_EXP 103
38253: PUSH
38254: LD_VAR 0 4
38258: ARRAY
38259: PUSH
38260: FOR_IN
38261: IFFALSE 38321
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38263: LD_VAR 0 3
38267: PPUSH
38268: LD_VAR 0 5
38272: PPUSH
38273: CALL_OW 430
38277: PUSH
38278: LD_VAR 0 4
38282: PPUSH
38283: LD_VAR 0 5
38287: PPUSH
38288: CALL 52764 0 2
38292: AND
38293: IFFALSE 38319
// begin researching := true ;
38295: LD_ADDR_VAR 0 10
38299: PUSH
38300: LD_INT 1
38302: ST_TO_ADDR
// ComResearch ( j , t ) ;
38303: LD_VAR 0 3
38307: PPUSH
38308: LD_VAR 0 5
38312: PPUSH
38313: CALL_OW 124
// break ;
38317: GO 38321
// end ;
38319: GO 38260
38321: POP
38322: POP
// if not researching then
38323: LD_VAR 0 10
38327: NOT
38328: IFFALSE 38340
// idle_lab := j ;
38330: LD_ADDR_VAR 0 11
38334: PUSH
38335: LD_VAR 0 3
38339: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38340: LD_VAR 0 3
38344: PPUSH
38345: CALL_OW 461
38349: PUSH
38350: LD_INT 10
38352: EQUAL
38353: IFFALSE 38941
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38355: LD_EXP 105
38359: PUSH
38360: LD_VAR 0 2
38364: ARRAY
38365: NOT
38366: PUSH
38367: LD_EXP 106
38371: PUSH
38372: LD_VAR 0 2
38376: ARRAY
38377: NOT
38378: AND
38379: PUSH
38380: LD_EXP 103
38384: PUSH
38385: LD_VAR 0 4
38389: ARRAY
38390: PUSH
38391: LD_INT 1
38393: GREATER
38394: AND
38395: IFFALSE 38526
// begin ComCancel ( j ) ;
38397: LD_VAR 0 3
38401: PPUSH
38402: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38406: LD_ADDR_EXP 103
38410: PUSH
38411: LD_EXP 103
38415: PPUSH
38416: LD_VAR 0 4
38420: PPUSH
38421: LD_EXP 103
38425: PUSH
38426: LD_VAR 0 4
38430: ARRAY
38431: PPUSH
38432: LD_EXP 103
38436: PUSH
38437: LD_VAR 0 4
38441: ARRAY
38442: PUSH
38443: LD_INT 1
38445: MINUS
38446: PPUSH
38447: LD_EXP 103
38451: PUSH
38452: LD_VAR 0 4
38456: ARRAY
38457: PPUSH
38458: LD_INT 0
38460: PPUSH
38461: CALL 56463 0 4
38465: PPUSH
38466: CALL_OW 1
38470: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38471: LD_ADDR_EXP 103
38475: PUSH
38476: LD_EXP 103
38480: PPUSH
38481: LD_VAR 0 4
38485: PPUSH
38486: LD_EXP 103
38490: PUSH
38491: LD_VAR 0 4
38495: ARRAY
38496: PPUSH
38497: LD_EXP 103
38501: PUSH
38502: LD_VAR 0 4
38506: ARRAY
38507: PPUSH
38508: LD_INT 1
38510: PPUSH
38511: LD_INT 0
38513: PPUSH
38514: CALL 56463 0 4
38518: PPUSH
38519: CALL_OW 1
38523: ST_TO_ADDR
// continue ;
38524: GO 38098
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38526: LD_EXP 105
38530: PUSH
38531: LD_VAR 0 2
38535: ARRAY
38536: PUSH
38537: LD_EXP 106
38541: PUSH
38542: LD_VAR 0 2
38546: ARRAY
38547: NOT
38548: AND
38549: IFFALSE 38676
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38551: LD_ADDR_EXP 106
38555: PUSH
38556: LD_EXP 106
38560: PPUSH
38561: LD_VAR 0 2
38565: PUSH
38566: LD_EXP 106
38570: PUSH
38571: LD_VAR 0 2
38575: ARRAY
38576: PUSH
38577: LD_INT 1
38579: PLUS
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PPUSH
38585: LD_EXP 105
38589: PUSH
38590: LD_VAR 0 2
38594: ARRAY
38595: PUSH
38596: LD_INT 1
38598: ARRAY
38599: PPUSH
38600: CALL 57045 0 3
38604: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38605: LD_EXP 105
38609: PUSH
38610: LD_VAR 0 2
38614: ARRAY
38615: PUSH
38616: LD_INT 1
38618: ARRAY
38619: PPUSH
38620: LD_INT 112
38622: PPUSH
38623: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38627: LD_ADDR_VAR 0 9
38631: PUSH
38632: LD_EXP 105
38636: PUSH
38637: LD_VAR 0 2
38641: ARRAY
38642: PPUSH
38643: LD_INT 1
38645: PPUSH
38646: CALL_OW 3
38650: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38651: LD_ADDR_EXP 105
38655: PUSH
38656: LD_EXP 105
38660: PPUSH
38661: LD_VAR 0 2
38665: PPUSH
38666: LD_VAR 0 9
38670: PPUSH
38671: CALL_OW 1
38675: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38676: LD_EXP 105
38680: PUSH
38681: LD_VAR 0 2
38685: ARRAY
38686: PUSH
38687: LD_EXP 106
38691: PUSH
38692: LD_VAR 0 2
38696: ARRAY
38697: AND
38698: PUSH
38699: LD_EXP 106
38703: PUSH
38704: LD_VAR 0 2
38708: ARRAY
38709: PUSH
38710: LD_INT 1
38712: ARRAY
38713: PPUSH
38714: CALL_OW 310
38718: NOT
38719: AND
38720: PUSH
38721: LD_VAR 0 3
38725: PPUSH
38726: CALL_OW 313
38730: PUSH
38731: LD_INT 6
38733: EQUAL
38734: AND
38735: IFFALSE 38791
// begin tmp2 := UnitsInside ( j ) ;
38737: LD_ADDR_VAR 0 9
38741: PUSH
38742: LD_VAR 0 3
38746: PPUSH
38747: CALL_OW 313
38751: ST_TO_ADDR
// if tmp2 = 6 then
38752: LD_VAR 0 9
38756: PUSH
38757: LD_INT 6
38759: EQUAL
38760: IFFALSE 38791
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38762: LD_VAR 0 9
38766: PUSH
38767: LD_INT 1
38769: ARRAY
38770: PPUSH
38771: LD_INT 112
38773: PPUSH
38774: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38778: LD_VAR 0 9
38782: PUSH
38783: LD_INT 1
38785: ARRAY
38786: PPUSH
38787: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38791: LD_EXP 106
38795: PUSH
38796: LD_VAR 0 2
38800: ARRAY
38801: PUSH
38802: LD_EXP 106
38806: PUSH
38807: LD_VAR 0 2
38811: ARRAY
38812: PUSH
38813: LD_INT 1
38815: ARRAY
38816: PPUSH
38817: CALL_OW 314
38821: NOT
38822: AND
38823: PUSH
38824: LD_EXP 106
38828: PUSH
38829: LD_VAR 0 2
38833: ARRAY
38834: PUSH
38835: LD_INT 1
38837: ARRAY
38838: PPUSH
38839: CALL_OW 310
38843: NOT
38844: AND
38845: IFFALSE 38871
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38847: LD_EXP 106
38851: PUSH
38852: LD_VAR 0 2
38856: ARRAY
38857: PUSH
38858: LD_INT 1
38860: ARRAY
38861: PPUSH
38862: LD_VAR 0 3
38866: PPUSH
38867: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38871: LD_EXP 106
38875: PUSH
38876: LD_VAR 0 2
38880: ARRAY
38881: PUSH
38882: LD_INT 1
38884: ARRAY
38885: PPUSH
38886: CALL_OW 310
38890: PUSH
38891: LD_EXP 106
38895: PUSH
38896: LD_VAR 0 2
38900: ARRAY
38901: PUSH
38902: LD_INT 1
38904: ARRAY
38905: PPUSH
38906: CALL_OW 310
38910: PPUSH
38911: CALL_OW 461
38915: PUSH
38916: LD_INT 3
38918: NONEQUAL
38919: AND
38920: IFFALSE 38941
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
38922: LD_EXP 106
38926: PUSH
38927: LD_VAR 0 2
38931: ARRAY
38932: PUSH
38933: LD_INT 1
38935: ARRAY
38936: PPUSH
38937: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
38941: LD_VAR 0 3
38945: PPUSH
38946: CALL_OW 461
38950: PUSH
38951: LD_INT 6
38953: EQUAL
38954: PUSH
38955: LD_VAR 0 6
38959: PUSH
38960: LD_INT 1
38962: GREATER
38963: AND
38964: IFFALSE 39116
// begin sci := [ ] ;
38966: LD_ADDR_VAR 0 8
38970: PUSH
38971: EMPTY
38972: ST_TO_ADDR
// for x in ( tmp diff j ) do
38973: LD_ADDR_VAR 0 7
38977: PUSH
38978: LD_VAR 0 6
38982: PUSH
38983: LD_VAR 0 3
38987: DIFF
38988: PUSH
38989: FOR_IN
38990: IFFALSE 39042
// begin if sci = 6 then
38992: LD_VAR 0 8
38996: PUSH
38997: LD_INT 6
38999: EQUAL
39000: IFFALSE 39004
// break ;
39002: GO 39042
// if BuildingStatus ( x ) = bs_idle then
39004: LD_VAR 0 7
39008: PPUSH
39009: CALL_OW 461
39013: PUSH
39014: LD_INT 2
39016: EQUAL
39017: IFFALSE 39040
// sci := sci ^ UnitsInside ( x ) ;
39019: LD_ADDR_VAR 0 8
39023: PUSH
39024: LD_VAR 0 8
39028: PUSH
39029: LD_VAR 0 7
39033: PPUSH
39034: CALL_OW 313
39038: ADD
39039: ST_TO_ADDR
// end ;
39040: GO 38989
39042: POP
39043: POP
// if not sci then
39044: LD_VAR 0 8
39048: NOT
39049: IFFALSE 39053
// continue ;
39051: GO 38098
// for x in sci do
39053: LD_ADDR_VAR 0 7
39057: PUSH
39058: LD_VAR 0 8
39062: PUSH
39063: FOR_IN
39064: IFFALSE 39114
// if IsInUnit ( x ) and not HasTask ( x ) then
39066: LD_VAR 0 7
39070: PPUSH
39071: CALL_OW 310
39075: PUSH
39076: LD_VAR 0 7
39080: PPUSH
39081: CALL_OW 314
39085: NOT
39086: AND
39087: IFFALSE 39112
// begin ComExitBuilding ( x ) ;
39089: LD_VAR 0 7
39093: PPUSH
39094: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39098: LD_VAR 0 7
39102: PPUSH
39103: LD_VAR 0 3
39107: PPUSH
39108: CALL_OW 180
// end ;
39112: GO 39063
39114: POP
39115: POP
// end ; end ;
39116: GO 38098
39118: POP
39119: POP
// end ;
39120: GO 38052
39122: POP
39123: POP
// end ;
39124: LD_VAR 0 1
39128: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39129: LD_INT 0
39131: PPUSH
39132: PPUSH
// if not mc_bases then
39133: LD_EXP 76
39137: NOT
39138: IFFALSE 39142
// exit ;
39140: GO 39223
// for i = 1 to mc_bases do
39142: LD_ADDR_VAR 0 2
39146: PUSH
39147: DOUBLE
39148: LD_INT 1
39150: DEC
39151: ST_TO_ADDR
39152: LD_EXP 76
39156: PUSH
39157: FOR_TO
39158: IFFALSE 39221
// if mc_mines [ i ] and mc_miners [ i ] then
39160: LD_EXP 89
39164: PUSH
39165: LD_VAR 0 2
39169: ARRAY
39170: PUSH
39171: LD_EXP 90
39175: PUSH
39176: LD_VAR 0 2
39180: ARRAY
39181: AND
39182: IFFALSE 39219
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39184: LD_EXP 90
39188: PUSH
39189: LD_VAR 0 2
39193: ARRAY
39194: PUSH
39195: LD_INT 1
39197: ARRAY
39198: PPUSH
39199: CALL_OW 255
39203: PPUSH
39204: LD_EXP 89
39208: PUSH
39209: LD_VAR 0 2
39213: ARRAY
39214: PPUSH
39215: CALL 53847 0 2
39219: GO 39157
39221: POP
39222: POP
// end ;
39223: LD_VAR 0 1
39227: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39228: LD_INT 0
39230: PPUSH
39231: PPUSH
39232: PPUSH
39233: PPUSH
39234: PPUSH
39235: PPUSH
39236: PPUSH
39237: PPUSH
// if not mc_bases or not mc_parking then
39238: LD_EXP 76
39242: NOT
39243: PUSH
39244: LD_EXP 100
39248: NOT
39249: OR
39250: IFFALSE 39254
// exit ;
39252: GO 39992
// for i = 1 to mc_bases do
39254: LD_ADDR_VAR 0 2
39258: PUSH
39259: DOUBLE
39260: LD_INT 1
39262: DEC
39263: ST_TO_ADDR
39264: LD_EXP 76
39268: PUSH
39269: FOR_TO
39270: IFFALSE 39990
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39272: LD_EXP 76
39276: PUSH
39277: LD_VAR 0 2
39281: ARRAY
39282: NOT
39283: PUSH
39284: LD_EXP 100
39288: PUSH
39289: LD_VAR 0 2
39293: ARRAY
39294: NOT
39295: OR
39296: IFFALSE 39300
// continue ;
39298: GO 39269
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39300: LD_ADDR_VAR 0 5
39304: PUSH
39305: LD_EXP 76
39309: PUSH
39310: LD_VAR 0 2
39314: ARRAY
39315: PUSH
39316: LD_INT 1
39318: ARRAY
39319: PPUSH
39320: CALL_OW 255
39324: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39325: LD_ADDR_VAR 0 6
39329: PUSH
39330: LD_EXP 76
39334: PUSH
39335: LD_VAR 0 2
39339: ARRAY
39340: PPUSH
39341: LD_INT 30
39343: PUSH
39344: LD_INT 3
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PPUSH
39351: CALL_OW 72
39355: ST_TO_ADDR
// if not fac then
39356: LD_VAR 0 6
39360: NOT
39361: IFFALSE 39412
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39363: LD_ADDR_VAR 0 6
39367: PUSH
39368: LD_EXP 76
39372: PUSH
39373: LD_VAR 0 2
39377: ARRAY
39378: PPUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 30
39384: PUSH
39385: LD_INT 0
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 30
39394: PUSH
39395: LD_INT 1
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: LIST
39406: PPUSH
39407: CALL_OW 72
39411: ST_TO_ADDR
// if not fac then
39412: LD_VAR 0 6
39416: NOT
39417: IFFALSE 39421
// continue ;
39419: GO 39269
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39421: LD_ADDR_VAR 0 7
39425: PUSH
39426: LD_EXP 100
39430: PUSH
39431: LD_VAR 0 2
39435: ARRAY
39436: PPUSH
39437: LD_INT 22
39439: PUSH
39440: LD_VAR 0 5
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 21
39451: PUSH
39452: LD_INT 2
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 3
39461: PUSH
39462: LD_INT 60
39464: PUSH
39465: EMPTY
39466: LIST
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 3
39474: PUSH
39475: LD_INT 24
39477: PUSH
39478: LD_INT 1000
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: LIST
39493: LIST
39494: PPUSH
39495: CALL_OW 70
39499: ST_TO_ADDR
// for j in fac do
39500: LD_ADDR_VAR 0 3
39504: PUSH
39505: LD_VAR 0 6
39509: PUSH
39510: FOR_IN
39511: IFFALSE 39606
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39513: LD_ADDR_VAR 0 7
39517: PUSH
39518: LD_VAR 0 7
39522: PUSH
39523: LD_INT 22
39525: PUSH
39526: LD_VAR 0 5
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 91
39537: PUSH
39538: LD_VAR 0 3
39542: PUSH
39543: LD_INT 15
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 21
39553: PUSH
39554: LD_INT 2
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 3
39563: PUSH
39564: LD_INT 60
39566: PUSH
39567: EMPTY
39568: LIST
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 3
39576: PUSH
39577: LD_INT 24
39579: PUSH
39580: LD_INT 1000
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: LIST
39597: PPUSH
39598: CALL_OW 69
39602: UNION
39603: ST_TO_ADDR
39604: GO 39510
39606: POP
39607: POP
// if not vehs then
39608: LD_VAR 0 7
39612: NOT
39613: IFFALSE 39639
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39615: LD_ADDR_EXP 88
39619: PUSH
39620: LD_EXP 88
39624: PPUSH
39625: LD_VAR 0 2
39629: PPUSH
39630: EMPTY
39631: PPUSH
39632: CALL_OW 1
39636: ST_TO_ADDR
// continue ;
39637: GO 39269
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39639: LD_ADDR_VAR 0 8
39643: PUSH
39644: LD_EXP 76
39648: PUSH
39649: LD_VAR 0 2
39653: ARRAY
39654: PPUSH
39655: LD_INT 30
39657: PUSH
39658: LD_INT 3
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PPUSH
39665: CALL_OW 72
39669: ST_TO_ADDR
// if tmp then
39670: LD_VAR 0 8
39674: IFFALSE 39777
// begin for j in tmp do
39676: LD_ADDR_VAR 0 3
39680: PUSH
39681: LD_VAR 0 8
39685: PUSH
39686: FOR_IN
39687: IFFALSE 39775
// for k in UnitsInside ( j ) do
39689: LD_ADDR_VAR 0 4
39693: PUSH
39694: LD_VAR 0 3
39698: PPUSH
39699: CALL_OW 313
39703: PUSH
39704: FOR_IN
39705: IFFALSE 39771
// if k then
39707: LD_VAR 0 4
39711: IFFALSE 39769
// if not k in mc_repair_vehicle [ i ] then
39713: LD_VAR 0 4
39717: PUSH
39718: LD_EXP 88
39722: PUSH
39723: LD_VAR 0 2
39727: ARRAY
39728: IN
39729: NOT
39730: IFFALSE 39769
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39732: LD_ADDR_EXP 88
39736: PUSH
39737: LD_EXP 88
39741: PPUSH
39742: LD_VAR 0 2
39746: PPUSH
39747: LD_EXP 88
39751: PUSH
39752: LD_VAR 0 2
39756: ARRAY
39757: PUSH
39758: LD_VAR 0 4
39762: UNION
39763: PPUSH
39764: CALL_OW 1
39768: ST_TO_ADDR
39769: GO 39704
39771: POP
39772: POP
39773: GO 39686
39775: POP
39776: POP
// end ; if not mc_repair_vehicle [ i ] then
39777: LD_EXP 88
39781: PUSH
39782: LD_VAR 0 2
39786: ARRAY
39787: NOT
39788: IFFALSE 39792
// continue ;
39790: GO 39269
// for j in mc_repair_vehicle [ i ] do
39792: LD_ADDR_VAR 0 3
39796: PUSH
39797: LD_EXP 88
39801: PUSH
39802: LD_VAR 0 2
39806: ARRAY
39807: PUSH
39808: FOR_IN
39809: IFFALSE 39986
// begin if GetClass ( j ) <> 3 then
39811: LD_VAR 0 3
39815: PPUSH
39816: CALL_OW 257
39820: PUSH
39821: LD_INT 3
39823: NONEQUAL
39824: IFFALSE 39865
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39826: LD_ADDR_EXP 88
39830: PUSH
39831: LD_EXP 88
39835: PPUSH
39836: LD_VAR 0 2
39840: PPUSH
39841: LD_EXP 88
39845: PUSH
39846: LD_VAR 0 2
39850: ARRAY
39851: PUSH
39852: LD_VAR 0 3
39856: DIFF
39857: PPUSH
39858: CALL_OW 1
39862: ST_TO_ADDR
// continue ;
39863: GO 39808
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39865: LD_VAR 0 3
39869: PPUSH
39870: CALL_OW 311
39874: NOT
39875: PUSH
39876: LD_VAR 0 3
39880: PUSH
39881: LD_EXP 79
39885: PUSH
39886: LD_VAR 0 2
39890: ARRAY
39891: PUSH
39892: LD_INT 1
39894: ARRAY
39895: IN
39896: NOT
39897: AND
39898: PUSH
39899: LD_VAR 0 3
39903: PUSH
39904: LD_EXP 79
39908: PUSH
39909: LD_VAR 0 2
39913: ARRAY
39914: PUSH
39915: LD_INT 2
39917: ARRAY
39918: IN
39919: NOT
39920: AND
39921: IFFALSE 39984
// begin if IsInUnit ( j ) then
39923: LD_VAR 0 3
39927: PPUSH
39928: CALL_OW 310
39932: IFFALSE 39945
// ComExitBuilding ( j ) else
39934: LD_VAR 0 3
39938: PPUSH
39939: CALL_OW 122
39943: GO 39984
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
39945: LD_VAR 0 3
39949: PPUSH
39950: LD_VAR 0 7
39954: PUSH
39955: LD_INT 1
39957: ARRAY
39958: PPUSH
39959: CALL 91422 0 2
39963: NOT
39964: IFFALSE 39984
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
39966: LD_VAR 0 3
39970: PPUSH
39971: LD_VAR 0 7
39975: PUSH
39976: LD_INT 1
39978: ARRAY
39979: PPUSH
39980: CALL_OW 129
// end ; end ;
39984: GO 39808
39986: POP
39987: POP
// end ;
39988: GO 39269
39990: POP
39991: POP
// end ;
39992: LD_VAR 0 1
39996: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
39997: LD_INT 0
39999: PPUSH
40000: PPUSH
40001: PPUSH
40002: PPUSH
40003: PPUSH
40004: PPUSH
40005: PPUSH
40006: PPUSH
40007: PPUSH
40008: PPUSH
40009: PPUSH
// if not mc_bases then
40010: LD_EXP 76
40014: NOT
40015: IFFALSE 40019
// exit ;
40017: GO 40821
// for i = 1 to mc_bases do
40019: LD_ADDR_VAR 0 2
40023: PUSH
40024: DOUBLE
40025: LD_INT 1
40027: DEC
40028: ST_TO_ADDR
40029: LD_EXP 76
40033: PUSH
40034: FOR_TO
40035: IFFALSE 40819
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40037: LD_EXP 104
40041: PUSH
40042: LD_VAR 0 2
40046: ARRAY
40047: NOT
40048: PUSH
40049: LD_EXP 79
40053: PUSH
40054: LD_VAR 0 2
40058: ARRAY
40059: PUSH
40060: LD_INT 1
40062: ARRAY
40063: OR
40064: PUSH
40065: LD_EXP 79
40069: PUSH
40070: LD_VAR 0 2
40074: ARRAY
40075: PUSH
40076: LD_INT 2
40078: ARRAY
40079: OR
40080: PUSH
40081: LD_EXP 102
40085: PUSH
40086: LD_VAR 0 2
40090: ARRAY
40091: PPUSH
40092: LD_INT 1
40094: PPUSH
40095: CALL_OW 325
40099: NOT
40100: OR
40101: PUSH
40102: LD_EXP 99
40106: PUSH
40107: LD_VAR 0 2
40111: ARRAY
40112: OR
40113: IFFALSE 40117
// continue ;
40115: GO 40034
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40117: LD_ADDR_VAR 0 8
40121: PUSH
40122: LD_EXP 76
40126: PUSH
40127: LD_VAR 0 2
40131: ARRAY
40132: PPUSH
40133: LD_INT 25
40135: PUSH
40136: LD_INT 4
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 50
40145: PUSH
40146: EMPTY
40147: LIST
40148: PUSH
40149: LD_INT 3
40151: PUSH
40152: LD_INT 60
40154: PUSH
40155: EMPTY
40156: LIST
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: LIST
40166: PPUSH
40167: CALL_OW 72
40171: PUSH
40172: LD_EXP 80
40176: PUSH
40177: LD_VAR 0 2
40181: ARRAY
40182: DIFF
40183: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40184: LD_ADDR_VAR 0 9
40188: PUSH
40189: LD_EXP 76
40193: PUSH
40194: LD_VAR 0 2
40198: ARRAY
40199: PPUSH
40200: LD_INT 2
40202: PUSH
40203: LD_INT 30
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 30
40215: PUSH
40216: LD_INT 1
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: LIST
40227: PPUSH
40228: CALL_OW 72
40232: ST_TO_ADDR
// if not tmp or not dep then
40233: LD_VAR 0 8
40237: NOT
40238: PUSH
40239: LD_VAR 0 9
40243: NOT
40244: OR
40245: IFFALSE 40249
// continue ;
40247: GO 40034
// side := GetSide ( tmp [ 1 ] ) ;
40249: LD_ADDR_VAR 0 11
40253: PUSH
40254: LD_VAR 0 8
40258: PUSH
40259: LD_INT 1
40261: ARRAY
40262: PPUSH
40263: CALL_OW 255
40267: ST_TO_ADDR
// dep := dep [ 1 ] ;
40268: LD_ADDR_VAR 0 9
40272: PUSH
40273: LD_VAR 0 9
40277: PUSH
40278: LD_INT 1
40280: ARRAY
40281: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40282: LD_ADDR_VAR 0 7
40286: PUSH
40287: LD_EXP 104
40291: PUSH
40292: LD_VAR 0 2
40296: ARRAY
40297: PPUSH
40298: LD_INT 22
40300: PUSH
40301: LD_INT 0
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 25
40310: PUSH
40311: LD_INT 12
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PPUSH
40322: CALL_OW 70
40326: PUSH
40327: LD_INT 22
40329: PUSH
40330: LD_INT 0
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 25
40339: PUSH
40340: LD_INT 12
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 91
40349: PUSH
40350: LD_VAR 0 9
40354: PUSH
40355: LD_INT 20
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: LIST
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: LIST
40367: PPUSH
40368: CALL_OW 69
40372: UNION
40373: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40374: LD_ADDR_VAR 0 10
40378: PUSH
40379: LD_EXP 104
40383: PUSH
40384: LD_VAR 0 2
40388: ARRAY
40389: PPUSH
40390: LD_INT 81
40392: PUSH
40393: LD_VAR 0 11
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PPUSH
40402: CALL_OW 70
40406: ST_TO_ADDR
// if not apes or danger_at_area then
40407: LD_VAR 0 7
40411: NOT
40412: PUSH
40413: LD_VAR 0 10
40417: OR
40418: IFFALSE 40468
// begin if mc_taming [ i ] then
40420: LD_EXP 107
40424: PUSH
40425: LD_VAR 0 2
40429: ARRAY
40430: IFFALSE 40466
// begin MC_Reset ( i , 121 ) ;
40432: LD_VAR 0 2
40436: PPUSH
40437: LD_INT 121
40439: PPUSH
40440: CALL 25405 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40444: LD_ADDR_EXP 107
40448: PUSH
40449: LD_EXP 107
40453: PPUSH
40454: LD_VAR 0 2
40458: PPUSH
40459: EMPTY
40460: PPUSH
40461: CALL_OW 1
40465: ST_TO_ADDR
// end ; continue ;
40466: GO 40034
// end ; for j in tmp do
40468: LD_ADDR_VAR 0 3
40472: PUSH
40473: LD_VAR 0 8
40477: PUSH
40478: FOR_IN
40479: IFFALSE 40815
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40481: LD_VAR 0 3
40485: PUSH
40486: LD_EXP 107
40490: PUSH
40491: LD_VAR 0 2
40495: ARRAY
40496: IN
40497: NOT
40498: PUSH
40499: LD_EXP 107
40503: PUSH
40504: LD_VAR 0 2
40508: ARRAY
40509: PUSH
40510: LD_INT 3
40512: LESS
40513: AND
40514: IFFALSE 40572
// begin SetTag ( j , 121 ) ;
40516: LD_VAR 0 3
40520: PPUSH
40521: LD_INT 121
40523: PPUSH
40524: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40528: LD_ADDR_EXP 107
40532: PUSH
40533: LD_EXP 107
40537: PPUSH
40538: LD_VAR 0 2
40542: PUSH
40543: LD_EXP 107
40547: PUSH
40548: LD_VAR 0 2
40552: ARRAY
40553: PUSH
40554: LD_INT 1
40556: PLUS
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PPUSH
40562: LD_VAR 0 3
40566: PPUSH
40567: CALL 57045 0 3
40571: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40572: LD_VAR 0 3
40576: PUSH
40577: LD_EXP 107
40581: PUSH
40582: LD_VAR 0 2
40586: ARRAY
40587: IN
40588: IFFALSE 40813
// begin if GetClass ( j ) <> 4 then
40590: LD_VAR 0 3
40594: PPUSH
40595: CALL_OW 257
40599: PUSH
40600: LD_INT 4
40602: NONEQUAL
40603: IFFALSE 40656
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40605: LD_ADDR_EXP 107
40609: PUSH
40610: LD_EXP 107
40614: PPUSH
40615: LD_VAR 0 2
40619: PPUSH
40620: LD_EXP 107
40624: PUSH
40625: LD_VAR 0 2
40629: ARRAY
40630: PUSH
40631: LD_VAR 0 3
40635: DIFF
40636: PPUSH
40637: CALL_OW 1
40641: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40642: LD_VAR 0 3
40646: PPUSH
40647: LD_INT 0
40649: PPUSH
40650: CALL_OW 109
// continue ;
40654: GO 40478
// end ; if IsInUnit ( j ) then
40656: LD_VAR 0 3
40660: PPUSH
40661: CALL_OW 310
40665: IFFALSE 40676
// ComExitBuilding ( j ) ;
40667: LD_VAR 0 3
40671: PPUSH
40672: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40676: LD_ADDR_VAR 0 6
40680: PUSH
40681: LD_VAR 0 7
40685: PPUSH
40686: LD_VAR 0 3
40690: PPUSH
40691: CALL_OW 74
40695: ST_TO_ADDR
// if not ape then
40696: LD_VAR 0 6
40700: NOT
40701: IFFALSE 40705
// break ;
40703: GO 40815
// x := GetX ( ape ) ;
40705: LD_ADDR_VAR 0 4
40709: PUSH
40710: LD_VAR 0 6
40714: PPUSH
40715: CALL_OW 250
40719: ST_TO_ADDR
// y := GetY ( ape ) ;
40720: LD_ADDR_VAR 0 5
40724: PUSH
40725: LD_VAR 0 6
40729: PPUSH
40730: CALL_OW 251
40734: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40735: LD_VAR 0 4
40739: PPUSH
40740: LD_VAR 0 5
40744: PPUSH
40745: CALL_OW 488
40749: NOT
40750: PUSH
40751: LD_VAR 0 11
40755: PPUSH
40756: LD_VAR 0 4
40760: PPUSH
40761: LD_VAR 0 5
40765: PPUSH
40766: LD_INT 20
40768: PPUSH
40769: CALL 57941 0 4
40773: PUSH
40774: LD_INT 4
40776: ARRAY
40777: OR
40778: IFFALSE 40782
// break ;
40780: GO 40815
// if not HasTask ( j ) then
40782: LD_VAR 0 3
40786: PPUSH
40787: CALL_OW 314
40791: NOT
40792: IFFALSE 40813
// ComTameXY ( j , x , y ) ;
40794: LD_VAR 0 3
40798: PPUSH
40799: LD_VAR 0 4
40803: PPUSH
40804: LD_VAR 0 5
40808: PPUSH
40809: CALL_OW 131
// end ; end ;
40813: GO 40478
40815: POP
40816: POP
// end ;
40817: GO 40034
40819: POP
40820: POP
// end ;
40821: LD_VAR 0 1
40825: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40826: LD_INT 0
40828: PPUSH
40829: PPUSH
40830: PPUSH
40831: PPUSH
40832: PPUSH
40833: PPUSH
40834: PPUSH
40835: PPUSH
// if not mc_bases then
40836: LD_EXP 76
40840: NOT
40841: IFFALSE 40845
// exit ;
40843: GO 41471
// for i = 1 to mc_bases do
40845: LD_ADDR_VAR 0 2
40849: PUSH
40850: DOUBLE
40851: LD_INT 1
40853: DEC
40854: ST_TO_ADDR
40855: LD_EXP 76
40859: PUSH
40860: FOR_TO
40861: IFFALSE 41469
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40863: LD_EXP 105
40867: PUSH
40868: LD_VAR 0 2
40872: ARRAY
40873: NOT
40874: PUSH
40875: LD_EXP 105
40879: PUSH
40880: LD_VAR 0 2
40884: ARRAY
40885: PPUSH
40886: LD_INT 25
40888: PUSH
40889: LD_INT 12
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PPUSH
40896: CALL_OW 72
40900: NOT
40901: OR
40902: IFFALSE 40906
// continue ;
40904: GO 40860
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
40906: LD_ADDR_VAR 0 5
40910: PUSH
40911: LD_EXP 105
40915: PUSH
40916: LD_VAR 0 2
40920: ARRAY
40921: PUSH
40922: LD_INT 1
40924: ARRAY
40925: PPUSH
40926: CALL_OW 255
40930: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
40931: LD_VAR 0 5
40935: PPUSH
40936: LD_INT 2
40938: PPUSH
40939: CALL_OW 325
40943: IFFALSE 41196
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
40945: LD_ADDR_VAR 0 4
40949: PUSH
40950: LD_EXP 105
40954: PUSH
40955: LD_VAR 0 2
40959: ARRAY
40960: PPUSH
40961: LD_INT 25
40963: PUSH
40964: LD_INT 16
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: PPUSH
40971: CALL_OW 72
40975: ST_TO_ADDR
// if tmp < 6 then
40976: LD_VAR 0 4
40980: PUSH
40981: LD_INT 6
40983: LESS
40984: IFFALSE 41196
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40986: LD_ADDR_VAR 0 6
40990: PUSH
40991: LD_EXP 76
40995: PUSH
40996: LD_VAR 0 2
41000: ARRAY
41001: PPUSH
41002: LD_INT 2
41004: PUSH
41005: LD_INT 30
41007: PUSH
41008: LD_INT 0
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: LD_INT 30
41017: PUSH
41018: LD_INT 1
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: LIST
41029: PPUSH
41030: CALL_OW 72
41034: ST_TO_ADDR
// if depot then
41035: LD_VAR 0 6
41039: IFFALSE 41196
// begin selected := 0 ;
41041: LD_ADDR_VAR 0 7
41045: PUSH
41046: LD_INT 0
41048: ST_TO_ADDR
// for j in depot do
41049: LD_ADDR_VAR 0 3
41053: PUSH
41054: LD_VAR 0 6
41058: PUSH
41059: FOR_IN
41060: IFFALSE 41091
// begin if UnitsInside ( j ) < 6 then
41062: LD_VAR 0 3
41066: PPUSH
41067: CALL_OW 313
41071: PUSH
41072: LD_INT 6
41074: LESS
41075: IFFALSE 41089
// begin selected := j ;
41077: LD_ADDR_VAR 0 7
41081: PUSH
41082: LD_VAR 0 3
41086: ST_TO_ADDR
// break ;
41087: GO 41091
// end ; end ;
41089: GO 41059
41091: POP
41092: POP
// if selected then
41093: LD_VAR 0 7
41097: IFFALSE 41196
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41099: LD_ADDR_VAR 0 3
41103: PUSH
41104: LD_EXP 105
41108: PUSH
41109: LD_VAR 0 2
41113: ARRAY
41114: PPUSH
41115: LD_INT 25
41117: PUSH
41118: LD_INT 12
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PPUSH
41125: CALL_OW 72
41129: PUSH
41130: FOR_IN
41131: IFFALSE 41194
// if not HasTask ( j ) then
41133: LD_VAR 0 3
41137: PPUSH
41138: CALL_OW 314
41142: NOT
41143: IFFALSE 41192
// begin if not IsInUnit ( j ) then
41145: LD_VAR 0 3
41149: PPUSH
41150: CALL_OW 310
41154: NOT
41155: IFFALSE 41171
// ComEnterUnit ( j , selected ) ;
41157: LD_VAR 0 3
41161: PPUSH
41162: LD_VAR 0 7
41166: PPUSH
41167: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41171: LD_VAR 0 3
41175: PPUSH
41176: LD_INT 16
41178: PPUSH
41179: CALL_OW 183
// AddComExitBuilding ( j ) ;
41183: LD_VAR 0 3
41187: PPUSH
41188: CALL_OW 182
// end ;
41192: GO 41130
41194: POP
41195: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41196: LD_VAR 0 5
41200: PPUSH
41201: LD_INT 11
41203: PPUSH
41204: CALL_OW 325
41208: IFFALSE 41467
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41210: LD_ADDR_VAR 0 4
41214: PUSH
41215: LD_EXP 105
41219: PUSH
41220: LD_VAR 0 2
41224: ARRAY
41225: PPUSH
41226: LD_INT 25
41228: PUSH
41229: LD_INT 16
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PPUSH
41236: CALL_OW 72
41240: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41241: LD_VAR 0 4
41245: PUSH
41246: LD_INT 6
41248: GREATEREQUAL
41249: PUSH
41250: LD_VAR 0 5
41254: PPUSH
41255: LD_INT 2
41257: PPUSH
41258: CALL_OW 325
41262: NOT
41263: OR
41264: IFFALSE 41467
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41266: LD_ADDR_VAR 0 8
41270: PUSH
41271: LD_EXP 76
41275: PUSH
41276: LD_VAR 0 2
41280: ARRAY
41281: PPUSH
41282: LD_INT 2
41284: PUSH
41285: LD_INT 30
41287: PUSH
41288: LD_INT 4
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: LD_INT 30
41297: PUSH
41298: LD_INT 5
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: LIST
41309: PPUSH
41310: CALL_OW 72
41314: ST_TO_ADDR
// if barracks then
41315: LD_VAR 0 8
41319: IFFALSE 41467
// begin selected := 0 ;
41321: LD_ADDR_VAR 0 7
41325: PUSH
41326: LD_INT 0
41328: ST_TO_ADDR
// for j in barracks do
41329: LD_ADDR_VAR 0 3
41333: PUSH
41334: LD_VAR 0 8
41338: PUSH
41339: FOR_IN
41340: IFFALSE 41371
// begin if UnitsInside ( j ) < 6 then
41342: LD_VAR 0 3
41346: PPUSH
41347: CALL_OW 313
41351: PUSH
41352: LD_INT 6
41354: LESS
41355: IFFALSE 41369
// begin selected := j ;
41357: LD_ADDR_VAR 0 7
41361: PUSH
41362: LD_VAR 0 3
41366: ST_TO_ADDR
// break ;
41367: GO 41371
// end ; end ;
41369: GO 41339
41371: POP
41372: POP
// if selected then
41373: LD_VAR 0 7
41377: IFFALSE 41467
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41379: LD_ADDR_VAR 0 3
41383: PUSH
41384: LD_EXP 105
41388: PUSH
41389: LD_VAR 0 2
41393: ARRAY
41394: PPUSH
41395: LD_INT 25
41397: PUSH
41398: LD_INT 12
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PPUSH
41405: CALL_OW 72
41409: PUSH
41410: FOR_IN
41411: IFFALSE 41465
// if not IsInUnit ( j ) and not HasTask ( j ) then
41413: LD_VAR 0 3
41417: PPUSH
41418: CALL_OW 310
41422: NOT
41423: PUSH
41424: LD_VAR 0 3
41428: PPUSH
41429: CALL_OW 314
41433: NOT
41434: AND
41435: IFFALSE 41463
// begin ComEnterUnit ( j , selected ) ;
41437: LD_VAR 0 3
41441: PPUSH
41442: LD_VAR 0 7
41446: PPUSH
41447: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41451: LD_VAR 0 3
41455: PPUSH
41456: LD_INT 15
41458: PPUSH
41459: CALL_OW 183
// end ;
41463: GO 41410
41465: POP
41466: POP
// end ; end ; end ; end ; end ;
41467: GO 40860
41469: POP
41470: POP
// end ;
41471: LD_VAR 0 1
41475: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41476: LD_INT 0
41478: PPUSH
41479: PPUSH
41480: PPUSH
41481: PPUSH
// if not mc_bases then
41482: LD_EXP 76
41486: NOT
41487: IFFALSE 41491
// exit ;
41489: GO 41669
// for i = 1 to mc_bases do
41491: LD_ADDR_VAR 0 2
41495: PUSH
41496: DOUBLE
41497: LD_INT 1
41499: DEC
41500: ST_TO_ADDR
41501: LD_EXP 76
41505: PUSH
41506: FOR_TO
41507: IFFALSE 41667
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41509: LD_ADDR_VAR 0 4
41513: PUSH
41514: LD_EXP 76
41518: PUSH
41519: LD_VAR 0 2
41523: ARRAY
41524: PPUSH
41525: LD_INT 25
41527: PUSH
41528: LD_INT 9
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PPUSH
41535: CALL_OW 72
41539: ST_TO_ADDR
// if not tmp then
41540: LD_VAR 0 4
41544: NOT
41545: IFFALSE 41549
// continue ;
41547: GO 41506
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41549: LD_EXP 102
41553: PUSH
41554: LD_VAR 0 2
41558: ARRAY
41559: PPUSH
41560: LD_INT 29
41562: PPUSH
41563: CALL_OW 325
41567: NOT
41568: PUSH
41569: LD_EXP 102
41573: PUSH
41574: LD_VAR 0 2
41578: ARRAY
41579: PPUSH
41580: LD_INT 28
41582: PPUSH
41583: CALL_OW 325
41587: NOT
41588: AND
41589: IFFALSE 41593
// continue ;
41591: GO 41506
// for j in tmp do
41593: LD_ADDR_VAR 0 3
41597: PUSH
41598: LD_VAR 0 4
41602: PUSH
41603: FOR_IN
41604: IFFALSE 41663
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41606: LD_VAR 0 3
41610: PUSH
41611: LD_EXP 79
41615: PUSH
41616: LD_VAR 0 2
41620: ARRAY
41621: PUSH
41622: LD_INT 1
41624: ARRAY
41625: IN
41626: NOT
41627: PUSH
41628: LD_VAR 0 3
41632: PUSH
41633: LD_EXP 79
41637: PUSH
41638: LD_VAR 0 2
41642: ARRAY
41643: PUSH
41644: LD_INT 2
41646: ARRAY
41647: IN
41648: NOT
41649: AND
41650: IFFALSE 41661
// ComSpaceTimeShoot ( j ) ;
41652: LD_VAR 0 3
41656: PPUSH
41657: CALL 52855 0 1
41661: GO 41603
41663: POP
41664: POP
// end ;
41665: GO 41506
41667: POP
41668: POP
// end ;
41669: LD_VAR 0 1
41673: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41674: LD_INT 0
41676: PPUSH
41677: PPUSH
41678: PPUSH
41679: PPUSH
41680: PPUSH
41681: PPUSH
41682: PPUSH
41683: PPUSH
41684: PPUSH
// if not mc_bases then
41685: LD_EXP 76
41689: NOT
41690: IFFALSE 41694
// exit ;
41692: GO 42316
// for i = 1 to mc_bases do
41694: LD_ADDR_VAR 0 2
41698: PUSH
41699: DOUBLE
41700: LD_INT 1
41702: DEC
41703: ST_TO_ADDR
41704: LD_EXP 76
41708: PUSH
41709: FOR_TO
41710: IFFALSE 42314
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41712: LD_EXP 111
41716: PUSH
41717: LD_VAR 0 2
41721: ARRAY
41722: NOT
41723: PUSH
41724: LD_INT 38
41726: PPUSH
41727: LD_EXP 102
41731: PUSH
41732: LD_VAR 0 2
41736: ARRAY
41737: PPUSH
41738: CALL_OW 321
41742: PUSH
41743: LD_INT 2
41745: NONEQUAL
41746: OR
41747: IFFALSE 41751
// continue ;
41749: GO 41709
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41751: LD_ADDR_VAR 0 8
41755: PUSH
41756: LD_EXP 76
41760: PUSH
41761: LD_VAR 0 2
41765: ARRAY
41766: PPUSH
41767: LD_INT 30
41769: PUSH
41770: LD_INT 34
41772: PUSH
41773: EMPTY
41774: LIST
41775: LIST
41776: PPUSH
41777: CALL_OW 72
41781: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41782: LD_ADDR_VAR 0 9
41786: PUSH
41787: LD_EXP 76
41791: PUSH
41792: LD_VAR 0 2
41796: ARRAY
41797: PPUSH
41798: LD_INT 25
41800: PUSH
41801: LD_INT 4
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PPUSH
41808: CALL_OW 72
41812: PPUSH
41813: LD_INT 0
41815: PPUSH
41816: CALL 86931 0 2
41820: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41821: LD_VAR 0 9
41825: NOT
41826: PUSH
41827: LD_VAR 0 8
41831: NOT
41832: OR
41833: PUSH
41834: LD_EXP 76
41838: PUSH
41839: LD_VAR 0 2
41843: ARRAY
41844: PPUSH
41845: LD_INT 124
41847: PPUSH
41848: CALL 86931 0 2
41852: OR
41853: IFFALSE 41857
// continue ;
41855: GO 41709
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41857: LD_EXP 112
41861: PUSH
41862: LD_VAR 0 2
41866: ARRAY
41867: PUSH
41868: LD_EXP 111
41872: PUSH
41873: LD_VAR 0 2
41877: ARRAY
41878: LESS
41879: PUSH
41880: LD_EXP 112
41884: PUSH
41885: LD_VAR 0 2
41889: ARRAY
41890: PUSH
41891: LD_VAR 0 8
41895: LESS
41896: AND
41897: IFFALSE 42312
// begin tmp := sci [ 1 ] ;
41899: LD_ADDR_VAR 0 7
41903: PUSH
41904: LD_VAR 0 9
41908: PUSH
41909: LD_INT 1
41911: ARRAY
41912: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
41913: LD_VAR 0 7
41917: PPUSH
41918: LD_INT 124
41920: PPUSH
41921: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
41925: LD_ADDR_VAR 0 3
41929: PUSH
41930: DOUBLE
41931: LD_EXP 111
41935: PUSH
41936: LD_VAR 0 2
41940: ARRAY
41941: INC
41942: ST_TO_ADDR
41943: LD_EXP 111
41947: PUSH
41948: LD_VAR 0 2
41952: ARRAY
41953: PUSH
41954: FOR_DOWNTO
41955: IFFALSE 42298
// begin if IsInUnit ( tmp ) then
41957: LD_VAR 0 7
41961: PPUSH
41962: CALL_OW 310
41966: IFFALSE 41977
// ComExitBuilding ( tmp ) ;
41968: LD_VAR 0 7
41972: PPUSH
41973: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
41977: LD_INT 35
41979: PPUSH
41980: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
41984: LD_VAR 0 7
41988: PPUSH
41989: CALL_OW 310
41993: NOT
41994: PUSH
41995: LD_VAR 0 7
41999: PPUSH
42000: CALL_OW 314
42004: NOT
42005: AND
42006: IFFALSE 41977
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42008: LD_ADDR_VAR 0 6
42012: PUSH
42013: LD_VAR 0 7
42017: PPUSH
42018: CALL_OW 250
42022: PUSH
42023: LD_VAR 0 7
42027: PPUSH
42028: CALL_OW 251
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42037: LD_INT 35
42039: PPUSH
42040: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42044: LD_ADDR_VAR 0 4
42048: PUSH
42049: LD_EXP 111
42053: PUSH
42054: LD_VAR 0 2
42058: ARRAY
42059: PUSH
42060: LD_VAR 0 3
42064: ARRAY
42065: PUSH
42066: LD_INT 1
42068: ARRAY
42069: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42070: LD_ADDR_VAR 0 5
42074: PUSH
42075: LD_EXP 111
42079: PUSH
42080: LD_VAR 0 2
42084: ARRAY
42085: PUSH
42086: LD_VAR 0 3
42090: ARRAY
42091: PUSH
42092: LD_INT 2
42094: ARRAY
42095: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42096: LD_VAR 0 7
42100: PPUSH
42101: LD_INT 10
42103: PPUSH
42104: CALL 59642 0 2
42108: PUSH
42109: LD_INT 4
42111: ARRAY
42112: IFFALSE 42150
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42114: LD_VAR 0 7
42118: PPUSH
42119: LD_VAR 0 6
42123: PUSH
42124: LD_INT 1
42126: ARRAY
42127: PPUSH
42128: LD_VAR 0 6
42132: PUSH
42133: LD_INT 2
42135: ARRAY
42136: PPUSH
42137: CALL_OW 111
// wait ( 0 0$10 ) ;
42141: LD_INT 350
42143: PPUSH
42144: CALL_OW 67
// end else
42148: GO 42176
// begin ComMoveXY ( tmp , x , y ) ;
42150: LD_VAR 0 7
42154: PPUSH
42155: LD_VAR 0 4
42159: PPUSH
42160: LD_VAR 0 5
42164: PPUSH
42165: CALL_OW 111
// wait ( 0 0$3 ) ;
42169: LD_INT 105
42171: PPUSH
42172: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42176: LD_VAR 0 7
42180: PPUSH
42181: LD_VAR 0 4
42185: PPUSH
42186: LD_VAR 0 5
42190: PPUSH
42191: CALL_OW 307
42195: IFFALSE 42037
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42197: LD_VAR 0 7
42201: PPUSH
42202: LD_VAR 0 4
42206: PPUSH
42207: LD_VAR 0 5
42211: PPUSH
42212: LD_VAR 0 8
42216: PUSH
42217: LD_VAR 0 3
42221: ARRAY
42222: PPUSH
42223: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42227: LD_INT 35
42229: PPUSH
42230: CALL_OW 67
// until not HasTask ( tmp ) ;
42234: LD_VAR 0 7
42238: PPUSH
42239: CALL_OW 314
42243: NOT
42244: IFFALSE 42227
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42246: LD_ADDR_EXP 112
42250: PUSH
42251: LD_EXP 112
42255: PPUSH
42256: LD_VAR 0 2
42260: PUSH
42261: LD_EXP 112
42265: PUSH
42266: LD_VAR 0 2
42270: ARRAY
42271: PUSH
42272: LD_INT 1
42274: PLUS
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PPUSH
42280: LD_VAR 0 8
42284: PUSH
42285: LD_VAR 0 3
42289: ARRAY
42290: PPUSH
42291: CALL 57045 0 3
42295: ST_TO_ADDR
// end ;
42296: GO 41954
42298: POP
42299: POP
// MC_Reset ( i , 124 ) ;
42300: LD_VAR 0 2
42304: PPUSH
42305: LD_INT 124
42307: PPUSH
42308: CALL 25405 0 2
// end ; end ;
42312: GO 41709
42314: POP
42315: POP
// end ;
42316: LD_VAR 0 1
42320: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42321: LD_INT 0
42323: PPUSH
42324: PPUSH
42325: PPUSH
// if not mc_bases then
42326: LD_EXP 76
42330: NOT
42331: IFFALSE 42335
// exit ;
42333: GO 42941
// for i = 1 to mc_bases do
42335: LD_ADDR_VAR 0 2
42339: PUSH
42340: DOUBLE
42341: LD_INT 1
42343: DEC
42344: ST_TO_ADDR
42345: LD_EXP 76
42349: PUSH
42350: FOR_TO
42351: IFFALSE 42939
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42353: LD_ADDR_VAR 0 3
42357: PUSH
42358: LD_EXP 76
42362: PUSH
42363: LD_VAR 0 2
42367: ARRAY
42368: PPUSH
42369: LD_INT 25
42371: PUSH
42372: LD_INT 4
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PPUSH
42379: CALL_OW 72
42383: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42384: LD_VAR 0 3
42388: NOT
42389: PUSH
42390: LD_EXP 113
42394: PUSH
42395: LD_VAR 0 2
42399: ARRAY
42400: NOT
42401: OR
42402: PUSH
42403: LD_EXP 76
42407: PUSH
42408: LD_VAR 0 2
42412: ARRAY
42413: PPUSH
42414: LD_INT 2
42416: PUSH
42417: LD_INT 30
42419: PUSH
42420: LD_INT 0
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 30
42429: PUSH
42430: LD_INT 1
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: LIST
42441: PPUSH
42442: CALL_OW 72
42446: NOT
42447: OR
42448: IFFALSE 42498
// begin if mc_deposits_finder [ i ] then
42450: LD_EXP 114
42454: PUSH
42455: LD_VAR 0 2
42459: ARRAY
42460: IFFALSE 42496
// begin MC_Reset ( i , 125 ) ;
42462: LD_VAR 0 2
42466: PPUSH
42467: LD_INT 125
42469: PPUSH
42470: CALL 25405 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42474: LD_ADDR_EXP 114
42478: PUSH
42479: LD_EXP 114
42483: PPUSH
42484: LD_VAR 0 2
42488: PPUSH
42489: EMPTY
42490: PPUSH
42491: CALL_OW 1
42495: ST_TO_ADDR
// end ; continue ;
42496: GO 42350
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42498: LD_EXP 113
42502: PUSH
42503: LD_VAR 0 2
42507: ARRAY
42508: PUSH
42509: LD_INT 1
42511: ARRAY
42512: PUSH
42513: LD_INT 3
42515: ARRAY
42516: PUSH
42517: LD_INT 1
42519: EQUAL
42520: PUSH
42521: LD_INT 20
42523: PPUSH
42524: LD_EXP 102
42528: PUSH
42529: LD_VAR 0 2
42533: ARRAY
42534: PPUSH
42535: CALL_OW 321
42539: PUSH
42540: LD_INT 2
42542: NONEQUAL
42543: AND
42544: IFFALSE 42594
// begin if mc_deposits_finder [ i ] then
42546: LD_EXP 114
42550: PUSH
42551: LD_VAR 0 2
42555: ARRAY
42556: IFFALSE 42592
// begin MC_Reset ( i , 125 ) ;
42558: LD_VAR 0 2
42562: PPUSH
42563: LD_INT 125
42565: PPUSH
42566: CALL 25405 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42570: LD_ADDR_EXP 114
42574: PUSH
42575: LD_EXP 114
42579: PPUSH
42580: LD_VAR 0 2
42584: PPUSH
42585: EMPTY
42586: PPUSH
42587: CALL_OW 1
42591: ST_TO_ADDR
// end ; continue ;
42592: GO 42350
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42594: LD_EXP 113
42598: PUSH
42599: LD_VAR 0 2
42603: ARRAY
42604: PUSH
42605: LD_INT 1
42607: ARRAY
42608: PUSH
42609: LD_INT 1
42611: ARRAY
42612: PPUSH
42613: LD_EXP 113
42617: PUSH
42618: LD_VAR 0 2
42622: ARRAY
42623: PUSH
42624: LD_INT 1
42626: ARRAY
42627: PUSH
42628: LD_INT 2
42630: ARRAY
42631: PPUSH
42632: LD_EXP 102
42636: PUSH
42637: LD_VAR 0 2
42641: ARRAY
42642: PPUSH
42643: CALL_OW 440
42647: IFFALSE 42690
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42649: LD_ADDR_EXP 113
42653: PUSH
42654: LD_EXP 113
42658: PPUSH
42659: LD_VAR 0 2
42663: PPUSH
42664: LD_EXP 113
42668: PUSH
42669: LD_VAR 0 2
42673: ARRAY
42674: PPUSH
42675: LD_INT 1
42677: PPUSH
42678: CALL_OW 3
42682: PPUSH
42683: CALL_OW 1
42687: ST_TO_ADDR
42688: GO 42937
// begin if not mc_deposits_finder [ i ] then
42690: LD_EXP 114
42694: PUSH
42695: LD_VAR 0 2
42699: ARRAY
42700: NOT
42701: IFFALSE 42753
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42703: LD_ADDR_EXP 114
42707: PUSH
42708: LD_EXP 114
42712: PPUSH
42713: LD_VAR 0 2
42717: PPUSH
42718: LD_VAR 0 3
42722: PUSH
42723: LD_INT 1
42725: ARRAY
42726: PUSH
42727: EMPTY
42728: LIST
42729: PPUSH
42730: CALL_OW 1
42734: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42735: LD_VAR 0 3
42739: PUSH
42740: LD_INT 1
42742: ARRAY
42743: PPUSH
42744: LD_INT 125
42746: PPUSH
42747: CALL_OW 109
// end else
42751: GO 42937
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42753: LD_EXP 114
42757: PUSH
42758: LD_VAR 0 2
42762: ARRAY
42763: PUSH
42764: LD_INT 1
42766: ARRAY
42767: PPUSH
42768: CALL_OW 310
42772: IFFALSE 42795
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42774: LD_EXP 114
42778: PUSH
42779: LD_VAR 0 2
42783: ARRAY
42784: PUSH
42785: LD_INT 1
42787: ARRAY
42788: PPUSH
42789: CALL_OW 122
42793: GO 42937
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42795: LD_EXP 114
42799: PUSH
42800: LD_VAR 0 2
42804: ARRAY
42805: PUSH
42806: LD_INT 1
42808: ARRAY
42809: PPUSH
42810: CALL_OW 314
42814: NOT
42815: PUSH
42816: LD_EXP 114
42820: PUSH
42821: LD_VAR 0 2
42825: ARRAY
42826: PUSH
42827: LD_INT 1
42829: ARRAY
42830: PPUSH
42831: LD_EXP 113
42835: PUSH
42836: LD_VAR 0 2
42840: ARRAY
42841: PUSH
42842: LD_INT 1
42844: ARRAY
42845: PUSH
42846: LD_INT 1
42848: ARRAY
42849: PPUSH
42850: LD_EXP 113
42854: PUSH
42855: LD_VAR 0 2
42859: ARRAY
42860: PUSH
42861: LD_INT 1
42863: ARRAY
42864: PUSH
42865: LD_INT 2
42867: ARRAY
42868: PPUSH
42869: CALL_OW 297
42873: PUSH
42874: LD_INT 6
42876: GREATER
42877: AND
42878: IFFALSE 42937
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42880: LD_EXP 114
42884: PUSH
42885: LD_VAR 0 2
42889: ARRAY
42890: PUSH
42891: LD_INT 1
42893: ARRAY
42894: PPUSH
42895: LD_EXP 113
42899: PUSH
42900: LD_VAR 0 2
42904: ARRAY
42905: PUSH
42906: LD_INT 1
42908: ARRAY
42909: PUSH
42910: LD_INT 1
42912: ARRAY
42913: PPUSH
42914: LD_EXP 113
42918: PUSH
42919: LD_VAR 0 2
42923: ARRAY
42924: PUSH
42925: LD_INT 1
42927: ARRAY
42928: PUSH
42929: LD_INT 2
42931: ARRAY
42932: PPUSH
42933: CALL_OW 111
// end ; end ; end ;
42937: GO 42350
42939: POP
42940: POP
// end ;
42941: LD_VAR 0 1
42945: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
42946: LD_INT 0
42948: PPUSH
42949: PPUSH
42950: PPUSH
42951: PPUSH
42952: PPUSH
42953: PPUSH
42954: PPUSH
42955: PPUSH
42956: PPUSH
42957: PPUSH
42958: PPUSH
// if not mc_bases then
42959: LD_EXP 76
42963: NOT
42964: IFFALSE 42968
// exit ;
42966: GO 43908
// for i = 1 to mc_bases do
42968: LD_ADDR_VAR 0 2
42972: PUSH
42973: DOUBLE
42974: LD_INT 1
42976: DEC
42977: ST_TO_ADDR
42978: LD_EXP 76
42982: PUSH
42983: FOR_TO
42984: IFFALSE 43906
// begin if not mc_bases [ i ] or mc_scan [ i ] then
42986: LD_EXP 76
42990: PUSH
42991: LD_VAR 0 2
42995: ARRAY
42996: NOT
42997: PUSH
42998: LD_EXP 99
43002: PUSH
43003: LD_VAR 0 2
43007: ARRAY
43008: OR
43009: IFFALSE 43013
// continue ;
43011: GO 42983
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43013: LD_ADDR_VAR 0 7
43017: PUSH
43018: LD_EXP 76
43022: PUSH
43023: LD_VAR 0 2
43027: ARRAY
43028: PUSH
43029: LD_INT 1
43031: ARRAY
43032: PPUSH
43033: CALL_OW 248
43037: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43038: LD_VAR 0 7
43042: PUSH
43043: LD_INT 3
43045: EQUAL
43046: PUSH
43047: LD_EXP 95
43051: PUSH
43052: LD_VAR 0 2
43056: ARRAY
43057: PUSH
43058: LD_EXP 98
43062: PUSH
43063: LD_VAR 0 2
43067: ARRAY
43068: UNION
43069: PPUSH
43070: LD_INT 33
43072: PUSH
43073: LD_INT 2
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PPUSH
43080: CALL_OW 72
43084: NOT
43085: OR
43086: IFFALSE 43090
// continue ;
43088: GO 42983
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43090: LD_ADDR_VAR 0 9
43094: PUSH
43095: LD_EXP 76
43099: PUSH
43100: LD_VAR 0 2
43104: ARRAY
43105: PPUSH
43106: LD_INT 30
43108: PUSH
43109: LD_INT 36
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PPUSH
43116: CALL_OW 72
43120: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43121: LD_ADDR_VAR 0 10
43125: PUSH
43126: LD_EXP 95
43130: PUSH
43131: LD_VAR 0 2
43135: ARRAY
43136: PPUSH
43137: LD_INT 34
43139: PUSH
43140: LD_INT 31
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PPUSH
43147: CALL_OW 72
43151: ST_TO_ADDR
// if not cts and not mcts then
43152: LD_VAR 0 9
43156: NOT
43157: PUSH
43158: LD_VAR 0 10
43162: NOT
43163: AND
43164: IFFALSE 43168
// continue ;
43166: GO 42983
// x := cts ;
43168: LD_ADDR_VAR 0 11
43172: PUSH
43173: LD_VAR 0 9
43177: ST_TO_ADDR
// if not x then
43178: LD_VAR 0 11
43182: NOT
43183: IFFALSE 43195
// x := mcts ;
43185: LD_ADDR_VAR 0 11
43189: PUSH
43190: LD_VAR 0 10
43194: ST_TO_ADDR
// if not x then
43195: LD_VAR 0 11
43199: NOT
43200: IFFALSE 43204
// continue ;
43202: GO 42983
// if mc_remote_driver [ i ] then
43204: LD_EXP 116
43208: PUSH
43209: LD_VAR 0 2
43213: ARRAY
43214: IFFALSE 43601
// for j in mc_remote_driver [ i ] do
43216: LD_ADDR_VAR 0 3
43220: PUSH
43221: LD_EXP 116
43225: PUSH
43226: LD_VAR 0 2
43230: ARRAY
43231: PUSH
43232: FOR_IN
43233: IFFALSE 43599
// begin if GetClass ( j ) <> 3 then
43235: LD_VAR 0 3
43239: PPUSH
43240: CALL_OW 257
43244: PUSH
43245: LD_INT 3
43247: NONEQUAL
43248: IFFALSE 43301
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43250: LD_ADDR_EXP 116
43254: PUSH
43255: LD_EXP 116
43259: PPUSH
43260: LD_VAR 0 2
43264: PPUSH
43265: LD_EXP 116
43269: PUSH
43270: LD_VAR 0 2
43274: ARRAY
43275: PUSH
43276: LD_VAR 0 3
43280: DIFF
43281: PPUSH
43282: CALL_OW 1
43286: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43287: LD_VAR 0 3
43291: PPUSH
43292: LD_INT 0
43294: PPUSH
43295: CALL_OW 109
// continue ;
43299: GO 43232
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43301: LD_EXP 95
43305: PUSH
43306: LD_VAR 0 2
43310: ARRAY
43311: PPUSH
43312: LD_INT 34
43314: PUSH
43315: LD_INT 31
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 58
43324: PUSH
43325: EMPTY
43326: LIST
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PPUSH
43332: CALL_OW 72
43336: PUSH
43337: LD_VAR 0 3
43341: PPUSH
43342: CALL 86966 0 1
43346: NOT
43347: AND
43348: IFFALSE 43419
// begin if IsInUnit ( j ) then
43350: LD_VAR 0 3
43354: PPUSH
43355: CALL_OW 310
43359: IFFALSE 43370
// ComExitBuilding ( j ) ;
43361: LD_VAR 0 3
43365: PPUSH
43366: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43370: LD_VAR 0 3
43374: PPUSH
43375: LD_EXP 95
43379: PUSH
43380: LD_VAR 0 2
43384: ARRAY
43385: PPUSH
43386: LD_INT 34
43388: PUSH
43389: LD_INT 31
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 58
43398: PUSH
43399: EMPTY
43400: LIST
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PPUSH
43406: CALL_OW 72
43410: PUSH
43411: LD_INT 1
43413: ARRAY
43414: PPUSH
43415: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43419: LD_VAR 0 3
43423: PPUSH
43424: CALL_OW 310
43428: NOT
43429: PUSH
43430: LD_VAR 0 3
43434: PPUSH
43435: CALL_OW 310
43439: PPUSH
43440: CALL_OW 266
43444: PUSH
43445: LD_INT 36
43447: NONEQUAL
43448: PUSH
43449: LD_VAR 0 3
43453: PPUSH
43454: CALL 86966 0 1
43458: NOT
43459: AND
43460: OR
43461: IFFALSE 43597
// begin if IsInUnit ( j ) then
43463: LD_VAR 0 3
43467: PPUSH
43468: CALL_OW 310
43472: IFFALSE 43483
// ComExitBuilding ( j ) ;
43474: LD_VAR 0 3
43478: PPUSH
43479: CALL_OW 122
// ct := 0 ;
43483: LD_ADDR_VAR 0 8
43487: PUSH
43488: LD_INT 0
43490: ST_TO_ADDR
// for k in x do
43491: LD_ADDR_VAR 0 4
43495: PUSH
43496: LD_VAR 0 11
43500: PUSH
43501: FOR_IN
43502: IFFALSE 43575
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43504: LD_VAR 0 4
43508: PPUSH
43509: CALL_OW 264
43513: PUSH
43514: LD_INT 31
43516: EQUAL
43517: PUSH
43518: LD_VAR 0 4
43522: PPUSH
43523: CALL_OW 311
43527: NOT
43528: AND
43529: PUSH
43530: LD_VAR 0 4
43534: PPUSH
43535: CALL_OW 266
43539: PUSH
43540: LD_INT 36
43542: EQUAL
43543: PUSH
43544: LD_VAR 0 4
43548: PPUSH
43549: CALL_OW 313
43553: PUSH
43554: LD_INT 3
43556: LESS
43557: AND
43558: OR
43559: IFFALSE 43573
// begin ct := k ;
43561: LD_ADDR_VAR 0 8
43565: PUSH
43566: LD_VAR 0 4
43570: ST_TO_ADDR
// break ;
43571: GO 43575
// end ;
43573: GO 43501
43575: POP
43576: POP
// if ct then
43577: LD_VAR 0 8
43581: IFFALSE 43597
// ComEnterUnit ( j , ct ) ;
43583: LD_VAR 0 3
43587: PPUSH
43588: LD_VAR 0 8
43592: PPUSH
43593: CALL_OW 120
// end ; end ;
43597: GO 43232
43599: POP
43600: POP
// places := 0 ;
43601: LD_ADDR_VAR 0 5
43605: PUSH
43606: LD_INT 0
43608: ST_TO_ADDR
// for j = 1 to x do
43609: LD_ADDR_VAR 0 3
43613: PUSH
43614: DOUBLE
43615: LD_INT 1
43617: DEC
43618: ST_TO_ADDR
43619: LD_VAR 0 11
43623: PUSH
43624: FOR_TO
43625: IFFALSE 43701
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43627: LD_VAR 0 11
43631: PUSH
43632: LD_VAR 0 3
43636: ARRAY
43637: PPUSH
43638: CALL_OW 264
43642: PUSH
43643: LD_INT 31
43645: EQUAL
43646: IFFALSE 43664
// places := places + 1 else
43648: LD_ADDR_VAR 0 5
43652: PUSH
43653: LD_VAR 0 5
43657: PUSH
43658: LD_INT 1
43660: PLUS
43661: ST_TO_ADDR
43662: GO 43699
// if GetBType ( x [ j ] ) = b_control_tower then
43664: LD_VAR 0 11
43668: PUSH
43669: LD_VAR 0 3
43673: ARRAY
43674: PPUSH
43675: CALL_OW 266
43679: PUSH
43680: LD_INT 36
43682: EQUAL
43683: IFFALSE 43699
// places := places + 3 ;
43685: LD_ADDR_VAR 0 5
43689: PUSH
43690: LD_VAR 0 5
43694: PUSH
43695: LD_INT 3
43697: PLUS
43698: ST_TO_ADDR
43699: GO 43624
43701: POP
43702: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43703: LD_VAR 0 5
43707: PUSH
43708: LD_INT 0
43710: EQUAL
43711: PUSH
43712: LD_VAR 0 5
43716: PUSH
43717: LD_EXP 116
43721: PUSH
43722: LD_VAR 0 2
43726: ARRAY
43727: LESSEQUAL
43728: OR
43729: IFFALSE 43733
// continue ;
43731: GO 42983
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43733: LD_ADDR_VAR 0 6
43737: PUSH
43738: LD_EXP 76
43742: PUSH
43743: LD_VAR 0 2
43747: ARRAY
43748: PPUSH
43749: LD_INT 25
43751: PUSH
43752: LD_INT 3
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PPUSH
43759: CALL_OW 72
43763: PUSH
43764: LD_EXP 116
43768: PUSH
43769: LD_VAR 0 2
43773: ARRAY
43774: DIFF
43775: PPUSH
43776: LD_INT 3
43778: PPUSH
43779: CALL 87866 0 2
43783: ST_TO_ADDR
// for j in tmp do
43784: LD_ADDR_VAR 0 3
43788: PUSH
43789: LD_VAR 0 6
43793: PUSH
43794: FOR_IN
43795: IFFALSE 43830
// if GetTag ( j ) > 0 then
43797: LD_VAR 0 3
43801: PPUSH
43802: CALL_OW 110
43806: PUSH
43807: LD_INT 0
43809: GREATER
43810: IFFALSE 43828
// tmp := tmp diff j ;
43812: LD_ADDR_VAR 0 6
43816: PUSH
43817: LD_VAR 0 6
43821: PUSH
43822: LD_VAR 0 3
43826: DIFF
43827: ST_TO_ADDR
43828: GO 43794
43830: POP
43831: POP
// if not tmp then
43832: LD_VAR 0 6
43836: NOT
43837: IFFALSE 43841
// continue ;
43839: GO 42983
// if places then
43841: LD_VAR 0 5
43845: IFFALSE 43904
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43847: LD_ADDR_EXP 116
43851: PUSH
43852: LD_EXP 116
43856: PPUSH
43857: LD_VAR 0 2
43861: PPUSH
43862: LD_EXP 116
43866: PUSH
43867: LD_VAR 0 2
43871: ARRAY
43872: PUSH
43873: LD_VAR 0 6
43877: PUSH
43878: LD_INT 1
43880: ARRAY
43881: UNION
43882: PPUSH
43883: CALL_OW 1
43887: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43888: LD_VAR 0 6
43892: PUSH
43893: LD_INT 1
43895: ARRAY
43896: PPUSH
43897: LD_INT 126
43899: PPUSH
43900: CALL_OW 109
// end ; end ;
43904: GO 42983
43906: POP
43907: POP
// end ;
43908: LD_VAR 0 1
43912: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
43913: LD_INT 0
43915: PPUSH
43916: PPUSH
43917: PPUSH
43918: PPUSH
43919: PPUSH
43920: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
43921: LD_VAR 0 1
43925: NOT
43926: PUSH
43927: LD_VAR 0 2
43931: NOT
43932: OR
43933: PUSH
43934: LD_VAR 0 3
43938: NOT
43939: OR
43940: PUSH
43941: LD_VAR 0 4
43945: PUSH
43946: LD_INT 1
43948: PUSH
43949: LD_INT 2
43951: PUSH
43952: LD_INT 3
43954: PUSH
43955: LD_INT 4
43957: PUSH
43958: LD_INT 5
43960: PUSH
43961: LD_INT 8
43963: PUSH
43964: LD_INT 9
43966: PUSH
43967: LD_INT 15
43969: PUSH
43970: LD_INT 16
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: LIST
43977: LIST
43978: LIST
43979: LIST
43980: LIST
43981: LIST
43982: LIST
43983: IN
43984: NOT
43985: OR
43986: IFFALSE 43990
// exit ;
43988: GO 44890
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
43990: LD_ADDR_VAR 0 2
43994: PUSH
43995: LD_VAR 0 2
43999: PPUSH
44000: LD_INT 21
44002: PUSH
44003: LD_INT 3
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 24
44012: PUSH
44013: LD_INT 250
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PPUSH
44024: CALL_OW 72
44028: ST_TO_ADDR
// case class of 1 , 15 :
44029: LD_VAR 0 4
44033: PUSH
44034: LD_INT 1
44036: DOUBLE
44037: EQUAL
44038: IFTRUE 44048
44040: LD_INT 15
44042: DOUBLE
44043: EQUAL
44044: IFTRUE 44048
44046: GO 44133
44048: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44049: LD_ADDR_VAR 0 8
44053: PUSH
44054: LD_VAR 0 2
44058: PPUSH
44059: LD_INT 2
44061: PUSH
44062: LD_INT 30
44064: PUSH
44065: LD_INT 32
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 30
44074: PUSH
44075: LD_INT 31
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: LIST
44086: PPUSH
44087: CALL_OW 72
44091: PUSH
44092: LD_VAR 0 2
44096: PPUSH
44097: LD_INT 2
44099: PUSH
44100: LD_INT 30
44102: PUSH
44103: LD_INT 4
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 30
44112: PUSH
44113: LD_INT 5
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: LIST
44124: PPUSH
44125: CALL_OW 72
44129: ADD
44130: ST_TO_ADDR
44131: GO 44379
44133: LD_INT 2
44135: DOUBLE
44136: EQUAL
44137: IFTRUE 44147
44139: LD_INT 16
44141: DOUBLE
44142: EQUAL
44143: IFTRUE 44147
44145: GO 44193
44147: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44148: LD_ADDR_VAR 0 8
44152: PUSH
44153: LD_VAR 0 2
44157: PPUSH
44158: LD_INT 2
44160: PUSH
44161: LD_INT 30
44163: PUSH
44164: LD_INT 0
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 30
44173: PUSH
44174: LD_INT 1
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: LIST
44185: PPUSH
44186: CALL_OW 72
44190: ST_TO_ADDR
44191: GO 44379
44193: LD_INT 3
44195: DOUBLE
44196: EQUAL
44197: IFTRUE 44201
44199: GO 44247
44201: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44202: LD_ADDR_VAR 0 8
44206: PUSH
44207: LD_VAR 0 2
44211: PPUSH
44212: LD_INT 2
44214: PUSH
44215: LD_INT 30
44217: PUSH
44218: LD_INT 2
44220: PUSH
44221: EMPTY
44222: LIST
44223: LIST
44224: PUSH
44225: LD_INT 30
44227: PUSH
44228: LD_INT 3
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: LIST
44239: PPUSH
44240: CALL_OW 72
44244: ST_TO_ADDR
44245: GO 44379
44247: LD_INT 4
44249: DOUBLE
44250: EQUAL
44251: IFTRUE 44255
44253: GO 44312
44255: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44256: LD_ADDR_VAR 0 8
44260: PUSH
44261: LD_VAR 0 2
44265: PPUSH
44266: LD_INT 2
44268: PUSH
44269: LD_INT 30
44271: PUSH
44272: LD_INT 6
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 30
44281: PUSH
44282: LD_INT 7
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 30
44291: PUSH
44292: LD_INT 8
44294: PUSH
44295: EMPTY
44296: LIST
44297: LIST
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: PPUSH
44305: CALL_OW 72
44309: ST_TO_ADDR
44310: GO 44379
44312: LD_INT 5
44314: DOUBLE
44315: EQUAL
44316: IFTRUE 44332
44318: LD_INT 8
44320: DOUBLE
44321: EQUAL
44322: IFTRUE 44332
44324: LD_INT 9
44326: DOUBLE
44327: EQUAL
44328: IFTRUE 44332
44330: GO 44378
44332: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44333: LD_ADDR_VAR 0 8
44337: PUSH
44338: LD_VAR 0 2
44342: PPUSH
44343: LD_INT 2
44345: PUSH
44346: LD_INT 30
44348: PUSH
44349: LD_INT 4
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 30
44358: PUSH
44359: LD_INT 5
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: LIST
44370: PPUSH
44371: CALL_OW 72
44375: ST_TO_ADDR
44376: GO 44379
44378: POP
// if not tmp then
44379: LD_VAR 0 8
44383: NOT
44384: IFFALSE 44388
// exit ;
44386: GO 44890
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44388: LD_VAR 0 4
44392: PUSH
44393: LD_INT 1
44395: PUSH
44396: LD_INT 15
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: IN
44403: PUSH
44404: LD_EXP 85
44408: PUSH
44409: LD_VAR 0 1
44413: ARRAY
44414: AND
44415: IFFALSE 44571
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44417: LD_ADDR_VAR 0 9
44421: PUSH
44422: LD_EXP 85
44426: PUSH
44427: LD_VAR 0 1
44431: ARRAY
44432: PUSH
44433: LD_INT 1
44435: ARRAY
44436: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44437: LD_VAR 0 9
44441: PUSH
44442: LD_EXP 86
44446: PUSH
44447: LD_VAR 0 1
44451: ARRAY
44452: IN
44453: NOT
44454: IFFALSE 44569
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44456: LD_ADDR_EXP 86
44460: PUSH
44461: LD_EXP 86
44465: PPUSH
44466: LD_VAR 0 1
44470: PUSH
44471: LD_EXP 86
44475: PUSH
44476: LD_VAR 0 1
44480: ARRAY
44481: PUSH
44482: LD_INT 1
44484: PLUS
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PPUSH
44490: LD_VAR 0 9
44494: PPUSH
44495: CALL 57045 0 3
44499: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44500: LD_ADDR_EXP 85
44504: PUSH
44505: LD_EXP 85
44509: PPUSH
44510: LD_VAR 0 1
44514: PPUSH
44515: LD_EXP 85
44519: PUSH
44520: LD_VAR 0 1
44524: ARRAY
44525: PUSH
44526: LD_VAR 0 9
44530: DIFF
44531: PPUSH
44532: CALL_OW 1
44536: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44537: LD_VAR 0 3
44541: PPUSH
44542: LD_EXP 86
44546: PUSH
44547: LD_VAR 0 1
44551: ARRAY
44552: PUSH
44553: LD_EXP 86
44557: PUSH
44558: LD_VAR 0 1
44562: ARRAY
44563: ARRAY
44564: PPUSH
44565: CALL_OW 120
// end ; exit ;
44569: GO 44890
// end ; if tmp > 1 then
44571: LD_VAR 0 8
44575: PUSH
44576: LD_INT 1
44578: GREATER
44579: IFFALSE 44683
// for i = 2 to tmp do
44581: LD_ADDR_VAR 0 6
44585: PUSH
44586: DOUBLE
44587: LD_INT 2
44589: DEC
44590: ST_TO_ADDR
44591: LD_VAR 0 8
44595: PUSH
44596: FOR_TO
44597: IFFALSE 44681
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44599: LD_VAR 0 8
44603: PUSH
44604: LD_VAR 0 6
44608: ARRAY
44609: PPUSH
44610: CALL_OW 461
44614: PUSH
44615: LD_INT 6
44617: EQUAL
44618: IFFALSE 44679
// begin x := tmp [ i ] ;
44620: LD_ADDR_VAR 0 9
44624: PUSH
44625: LD_VAR 0 8
44629: PUSH
44630: LD_VAR 0 6
44634: ARRAY
44635: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44636: LD_ADDR_VAR 0 8
44640: PUSH
44641: LD_VAR 0 8
44645: PPUSH
44646: LD_VAR 0 6
44650: PPUSH
44651: CALL_OW 3
44655: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44656: LD_ADDR_VAR 0 8
44660: PUSH
44661: LD_VAR 0 8
44665: PPUSH
44666: LD_INT 1
44668: PPUSH
44669: LD_VAR 0 9
44673: PPUSH
44674: CALL_OW 2
44678: ST_TO_ADDR
// end ;
44679: GO 44596
44681: POP
44682: POP
// for i in tmp do
44683: LD_ADDR_VAR 0 6
44687: PUSH
44688: LD_VAR 0 8
44692: PUSH
44693: FOR_IN
44694: IFFALSE 44763
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44696: LD_VAR 0 6
44700: PPUSH
44701: CALL_OW 313
44705: PUSH
44706: LD_INT 6
44708: LESS
44709: PUSH
44710: LD_VAR 0 6
44714: PPUSH
44715: CALL_OW 266
44719: PUSH
44720: LD_INT 31
44722: PUSH
44723: LD_INT 32
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: IN
44730: NOT
44731: AND
44732: PUSH
44733: LD_VAR 0 6
44737: PPUSH
44738: CALL_OW 313
44742: PUSH
44743: LD_INT 0
44745: EQUAL
44746: OR
44747: IFFALSE 44761
// begin j := i ;
44749: LD_ADDR_VAR 0 7
44753: PUSH
44754: LD_VAR 0 6
44758: ST_TO_ADDR
// break ;
44759: GO 44763
// end ; end ;
44761: GO 44693
44763: POP
44764: POP
// if j then
44765: LD_VAR 0 7
44769: IFFALSE 44787
// ComEnterUnit ( unit , j ) else
44771: LD_VAR 0 3
44775: PPUSH
44776: LD_VAR 0 7
44780: PPUSH
44781: CALL_OW 120
44785: GO 44890
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44787: LD_ADDR_VAR 0 10
44791: PUSH
44792: LD_VAR 0 2
44796: PPUSH
44797: LD_INT 2
44799: PUSH
44800: LD_INT 30
44802: PUSH
44803: LD_INT 0
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: PUSH
44810: LD_INT 30
44812: PUSH
44813: LD_INT 1
44815: PUSH
44816: EMPTY
44817: LIST
44818: LIST
44819: PUSH
44820: EMPTY
44821: LIST
44822: LIST
44823: LIST
44824: PPUSH
44825: CALL_OW 72
44829: ST_TO_ADDR
// if depot then
44830: LD_VAR 0 10
44834: IFFALSE 44890
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44836: LD_ADDR_VAR 0 10
44840: PUSH
44841: LD_VAR 0 10
44845: PPUSH
44846: LD_VAR 0 3
44850: PPUSH
44851: CALL_OW 74
44855: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44856: LD_VAR 0 3
44860: PPUSH
44861: LD_VAR 0 10
44865: PPUSH
44866: CALL_OW 296
44870: PUSH
44871: LD_INT 10
44873: GREATER
44874: IFFALSE 44890
// ComStandNearbyBuilding ( unit , depot ) ;
44876: LD_VAR 0 3
44880: PPUSH
44881: LD_VAR 0 10
44885: PPUSH
44886: CALL 53472 0 2
// end ; end ; end ;
44890: LD_VAR 0 5
44894: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44895: LD_INT 0
44897: PPUSH
44898: PPUSH
44899: PPUSH
44900: PPUSH
// if not mc_bases then
44901: LD_EXP 76
44905: NOT
44906: IFFALSE 44910
// exit ;
44908: GO 45149
// for i = 1 to mc_bases do
44910: LD_ADDR_VAR 0 2
44914: PUSH
44915: DOUBLE
44916: LD_INT 1
44918: DEC
44919: ST_TO_ADDR
44920: LD_EXP 76
44924: PUSH
44925: FOR_TO
44926: IFFALSE 45147
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
44928: LD_ADDR_VAR 0 4
44932: PUSH
44933: LD_EXP 76
44937: PUSH
44938: LD_VAR 0 2
44942: ARRAY
44943: PPUSH
44944: LD_INT 21
44946: PUSH
44947: LD_INT 1
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PPUSH
44954: CALL_OW 72
44958: PUSH
44959: LD_EXP 105
44963: PUSH
44964: LD_VAR 0 2
44968: ARRAY
44969: UNION
44970: ST_TO_ADDR
// if not tmp then
44971: LD_VAR 0 4
44975: NOT
44976: IFFALSE 44980
// continue ;
44978: GO 44925
// for j in tmp do
44980: LD_ADDR_VAR 0 3
44984: PUSH
44985: LD_VAR 0 4
44989: PUSH
44990: FOR_IN
44991: IFFALSE 45143
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
44993: LD_VAR 0 3
44997: PPUSH
44998: CALL_OW 110
45002: NOT
45003: PUSH
45004: LD_VAR 0 3
45008: PPUSH
45009: CALL_OW 314
45013: NOT
45014: AND
45015: PUSH
45016: LD_VAR 0 3
45020: PPUSH
45021: CALL_OW 311
45025: NOT
45026: AND
45027: PUSH
45028: LD_VAR 0 3
45032: PPUSH
45033: CALL_OW 310
45037: NOT
45038: AND
45039: PUSH
45040: LD_VAR 0 3
45044: PUSH
45045: LD_EXP 79
45049: PUSH
45050: LD_VAR 0 2
45054: ARRAY
45055: PUSH
45056: LD_INT 1
45058: ARRAY
45059: IN
45060: NOT
45061: AND
45062: PUSH
45063: LD_VAR 0 3
45067: PUSH
45068: LD_EXP 79
45072: PUSH
45073: LD_VAR 0 2
45077: ARRAY
45078: PUSH
45079: LD_INT 2
45081: ARRAY
45082: IN
45083: NOT
45084: AND
45085: PUSH
45086: LD_VAR 0 3
45090: PUSH
45091: LD_EXP 88
45095: PUSH
45096: LD_VAR 0 2
45100: ARRAY
45101: IN
45102: NOT
45103: AND
45104: IFFALSE 45141
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45106: LD_VAR 0 2
45110: PPUSH
45111: LD_EXP 76
45115: PUSH
45116: LD_VAR 0 2
45120: ARRAY
45121: PPUSH
45122: LD_VAR 0 3
45126: PPUSH
45127: LD_VAR 0 3
45131: PPUSH
45132: CALL_OW 257
45136: PPUSH
45137: CALL 43913 0 4
// end ;
45141: GO 44990
45143: POP
45144: POP
// end ;
45145: GO 44925
45147: POP
45148: POP
// end ;
45149: LD_VAR 0 1
45153: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45154: LD_INT 0
45156: PPUSH
45157: PPUSH
45158: PPUSH
45159: PPUSH
45160: PPUSH
45161: PPUSH
// if not mc_bases [ base ] then
45162: LD_EXP 76
45166: PUSH
45167: LD_VAR 0 1
45171: ARRAY
45172: NOT
45173: IFFALSE 45177
// exit ;
45175: GO 45359
// tmp := [ ] ;
45177: LD_ADDR_VAR 0 6
45181: PUSH
45182: EMPTY
45183: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45184: LD_ADDR_VAR 0 7
45188: PUSH
45189: LD_VAR 0 3
45193: PPUSH
45194: LD_INT 0
45196: PPUSH
45197: CALL_OW 517
45201: ST_TO_ADDR
// if not list then
45202: LD_VAR 0 7
45206: NOT
45207: IFFALSE 45211
// exit ;
45209: GO 45359
// for i = 1 to amount do
45211: LD_ADDR_VAR 0 5
45215: PUSH
45216: DOUBLE
45217: LD_INT 1
45219: DEC
45220: ST_TO_ADDR
45221: LD_VAR 0 2
45225: PUSH
45226: FOR_TO
45227: IFFALSE 45307
// begin x := rand ( 1 , list [ 1 ] ) ;
45229: LD_ADDR_VAR 0 8
45233: PUSH
45234: LD_INT 1
45236: PPUSH
45237: LD_VAR 0 7
45241: PUSH
45242: LD_INT 1
45244: ARRAY
45245: PPUSH
45246: CALL_OW 12
45250: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45251: LD_ADDR_VAR 0 6
45255: PUSH
45256: LD_VAR 0 6
45260: PPUSH
45261: LD_VAR 0 5
45265: PPUSH
45266: LD_VAR 0 7
45270: PUSH
45271: LD_INT 1
45273: ARRAY
45274: PUSH
45275: LD_VAR 0 8
45279: ARRAY
45280: PUSH
45281: LD_VAR 0 7
45285: PUSH
45286: LD_INT 2
45288: ARRAY
45289: PUSH
45290: LD_VAR 0 8
45294: ARRAY
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PPUSH
45300: CALL_OW 1
45304: ST_TO_ADDR
// end ;
45305: GO 45226
45307: POP
45308: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45309: LD_ADDR_EXP 89
45313: PUSH
45314: LD_EXP 89
45318: PPUSH
45319: LD_VAR 0 1
45323: PPUSH
45324: LD_VAR 0 6
45328: PPUSH
45329: CALL_OW 1
45333: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45334: LD_ADDR_EXP 91
45338: PUSH
45339: LD_EXP 91
45343: PPUSH
45344: LD_VAR 0 1
45348: PPUSH
45349: LD_VAR 0 3
45353: PPUSH
45354: CALL_OW 1
45358: ST_TO_ADDR
// end ;
45359: LD_VAR 0 4
45363: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45364: LD_INT 0
45366: PPUSH
// if not mc_bases [ base ] then
45367: LD_EXP 76
45371: PUSH
45372: LD_VAR 0 1
45376: ARRAY
45377: NOT
45378: IFFALSE 45382
// exit ;
45380: GO 45407
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45382: LD_ADDR_EXP 81
45386: PUSH
45387: LD_EXP 81
45391: PPUSH
45392: LD_VAR 0 1
45396: PPUSH
45397: LD_VAR 0 2
45401: PPUSH
45402: CALL_OW 1
45406: ST_TO_ADDR
// end ;
45407: LD_VAR 0 3
45411: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45412: LD_INT 0
45414: PPUSH
// if not mc_bases [ base ] then
45415: LD_EXP 76
45419: PUSH
45420: LD_VAR 0 1
45424: ARRAY
45425: NOT
45426: IFFALSE 45430
// exit ;
45428: GO 45467
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45430: LD_ADDR_EXP 81
45434: PUSH
45435: LD_EXP 81
45439: PPUSH
45440: LD_VAR 0 1
45444: PPUSH
45445: LD_EXP 81
45449: PUSH
45450: LD_VAR 0 1
45454: ARRAY
45455: PUSH
45456: LD_VAR 0 2
45460: UNION
45461: PPUSH
45462: CALL_OW 1
45466: ST_TO_ADDR
// end ;
45467: LD_VAR 0 3
45471: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45472: LD_INT 0
45474: PPUSH
// if not mc_bases [ base ] then
45475: LD_EXP 76
45479: PUSH
45480: LD_VAR 0 1
45484: ARRAY
45485: NOT
45486: IFFALSE 45490
// exit ;
45488: GO 45515
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45490: LD_ADDR_EXP 97
45494: PUSH
45495: LD_EXP 97
45499: PPUSH
45500: LD_VAR 0 1
45504: PPUSH
45505: LD_VAR 0 2
45509: PPUSH
45510: CALL_OW 1
45514: ST_TO_ADDR
// end ;
45515: LD_VAR 0 3
45519: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45520: LD_INT 0
45522: PPUSH
// if not mc_bases [ base ] then
45523: LD_EXP 76
45527: PUSH
45528: LD_VAR 0 1
45532: ARRAY
45533: NOT
45534: IFFALSE 45538
// exit ;
45536: GO 45575
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45538: LD_ADDR_EXP 97
45542: PUSH
45543: LD_EXP 97
45547: PPUSH
45548: LD_VAR 0 1
45552: PPUSH
45553: LD_EXP 97
45557: PUSH
45558: LD_VAR 0 1
45562: ARRAY
45563: PUSH
45564: LD_VAR 0 2
45568: ADD
45569: PPUSH
45570: CALL_OW 1
45574: ST_TO_ADDR
// end ;
45575: LD_VAR 0 3
45579: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45580: LD_INT 0
45582: PPUSH
// if not mc_bases [ base ] then
45583: LD_EXP 76
45587: PUSH
45588: LD_VAR 0 1
45592: ARRAY
45593: NOT
45594: IFFALSE 45598
// exit ;
45596: GO 45652
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45598: LD_ADDR_EXP 98
45602: PUSH
45603: LD_EXP 98
45607: PPUSH
45608: LD_VAR 0 1
45612: PPUSH
45613: LD_VAR 0 2
45617: PPUSH
45618: CALL_OW 1
45622: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45623: LD_ADDR_EXP 87
45627: PUSH
45628: LD_EXP 87
45632: PPUSH
45633: LD_VAR 0 1
45637: PPUSH
45638: LD_VAR 0 2
45642: PUSH
45643: LD_INT 0
45645: PLUS
45646: PPUSH
45647: CALL_OW 1
45651: ST_TO_ADDR
// end ;
45652: LD_VAR 0 3
45656: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45657: LD_INT 0
45659: PPUSH
// if not mc_bases [ base ] then
45660: LD_EXP 76
45664: PUSH
45665: LD_VAR 0 1
45669: ARRAY
45670: NOT
45671: IFFALSE 45675
// exit ;
45673: GO 45700
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45675: LD_ADDR_EXP 87
45679: PUSH
45680: LD_EXP 87
45684: PPUSH
45685: LD_VAR 0 1
45689: PPUSH
45690: LD_VAR 0 2
45694: PPUSH
45695: CALL_OW 1
45699: ST_TO_ADDR
// end ;
45700: LD_VAR 0 3
45704: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45705: LD_INT 0
45707: PPUSH
45708: PPUSH
45709: PPUSH
45710: PPUSH
// if not mc_bases [ base ] then
45711: LD_EXP 76
45715: PUSH
45716: LD_VAR 0 1
45720: ARRAY
45721: NOT
45722: IFFALSE 45726
// exit ;
45724: GO 45791
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45726: LD_ADDR_EXP 96
45730: PUSH
45731: LD_EXP 96
45735: PPUSH
45736: LD_VAR 0 1
45740: PUSH
45741: LD_EXP 96
45745: PUSH
45746: LD_VAR 0 1
45750: ARRAY
45751: PUSH
45752: LD_INT 1
45754: PLUS
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PPUSH
45760: LD_VAR 0 1
45764: PUSH
45765: LD_VAR 0 2
45769: PUSH
45770: LD_VAR 0 3
45774: PUSH
45775: LD_VAR 0 4
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: PPUSH
45786: CALL 57045 0 3
45790: ST_TO_ADDR
// end ;
45791: LD_VAR 0 5
45795: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45796: LD_INT 0
45798: PPUSH
// if not mc_bases [ base ] then
45799: LD_EXP 76
45803: PUSH
45804: LD_VAR 0 1
45808: ARRAY
45809: NOT
45810: IFFALSE 45814
// exit ;
45812: GO 45839
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45814: LD_ADDR_EXP 113
45818: PUSH
45819: LD_EXP 113
45823: PPUSH
45824: LD_VAR 0 1
45828: PPUSH
45829: LD_VAR 0 2
45833: PPUSH
45834: CALL_OW 1
45838: ST_TO_ADDR
// end ;
45839: LD_VAR 0 3
45843: RET
// export function MC_GetMinesField ( base ) ; begin
45844: LD_INT 0
45846: PPUSH
// result := mc_mines [ base ] ;
45847: LD_ADDR_VAR 0 2
45851: PUSH
45852: LD_EXP 89
45856: PUSH
45857: LD_VAR 0 1
45861: ARRAY
45862: ST_TO_ADDR
// end ;
45863: LD_VAR 0 2
45867: RET
// export function MC_GetProduceList ( base ) ; begin
45868: LD_INT 0
45870: PPUSH
// result := mc_produce [ base ] ;
45871: LD_ADDR_VAR 0 2
45875: PUSH
45876: LD_EXP 97
45880: PUSH
45881: LD_VAR 0 1
45885: ARRAY
45886: ST_TO_ADDR
// end ;
45887: LD_VAR 0 2
45891: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45892: LD_INT 0
45894: PPUSH
45895: PPUSH
// if not mc_bases then
45896: LD_EXP 76
45900: NOT
45901: IFFALSE 45905
// exit ;
45903: GO 45970
// if mc_bases [ base ] then
45905: LD_EXP 76
45909: PUSH
45910: LD_VAR 0 1
45914: ARRAY
45915: IFFALSE 45970
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
45917: LD_ADDR_VAR 0 3
45921: PUSH
45922: LD_EXP 76
45926: PUSH
45927: LD_VAR 0 1
45931: ARRAY
45932: PPUSH
45933: LD_INT 30
45935: PUSH
45936: LD_VAR 0 2
45940: PUSH
45941: EMPTY
45942: LIST
45943: LIST
45944: PPUSH
45945: CALL_OW 72
45949: ST_TO_ADDR
// if result then
45950: LD_VAR 0 3
45954: IFFALSE 45970
// result := result [ 1 ] ;
45956: LD_ADDR_VAR 0 3
45960: PUSH
45961: LD_VAR 0 3
45965: PUSH
45966: LD_INT 1
45968: ARRAY
45969: ST_TO_ADDR
// end ; end ;
45970: LD_VAR 0 3
45974: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
45975: LD_INT 0
45977: PPUSH
45978: PPUSH
// if not mc_bases then
45979: LD_EXP 76
45983: NOT
45984: IFFALSE 45988
// exit ;
45986: GO 46033
// if mc_bases [ base ] then
45988: LD_EXP 76
45992: PUSH
45993: LD_VAR 0 1
45997: ARRAY
45998: IFFALSE 46033
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46000: LD_ADDR_VAR 0 3
46004: PUSH
46005: LD_EXP 76
46009: PUSH
46010: LD_VAR 0 1
46014: ARRAY
46015: PPUSH
46016: LD_INT 30
46018: PUSH
46019: LD_VAR 0 2
46023: PUSH
46024: EMPTY
46025: LIST
46026: LIST
46027: PPUSH
46028: CALL_OW 72
46032: ST_TO_ADDR
// end ;
46033: LD_VAR 0 3
46037: RET
// export function MC_SetTame ( base , area ) ; begin
46038: LD_INT 0
46040: PPUSH
// if not mc_bases or not base then
46041: LD_EXP 76
46045: NOT
46046: PUSH
46047: LD_VAR 0 1
46051: NOT
46052: OR
46053: IFFALSE 46057
// exit ;
46055: GO 46082
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46057: LD_ADDR_EXP 104
46061: PUSH
46062: LD_EXP 104
46066: PPUSH
46067: LD_VAR 0 1
46071: PPUSH
46072: LD_VAR 0 2
46076: PPUSH
46077: CALL_OW 1
46081: ST_TO_ADDR
// end ;
46082: LD_VAR 0 3
46086: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46087: LD_INT 0
46089: PPUSH
46090: PPUSH
// if not mc_bases or not base then
46091: LD_EXP 76
46095: NOT
46096: PUSH
46097: LD_VAR 0 1
46101: NOT
46102: OR
46103: IFFALSE 46107
// exit ;
46105: GO 46209
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46107: LD_ADDR_VAR 0 4
46111: PUSH
46112: LD_EXP 76
46116: PUSH
46117: LD_VAR 0 1
46121: ARRAY
46122: PPUSH
46123: LD_INT 30
46125: PUSH
46126: LD_VAR 0 2
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PPUSH
46135: CALL_OW 72
46139: ST_TO_ADDR
// if not tmp then
46140: LD_VAR 0 4
46144: NOT
46145: IFFALSE 46149
// exit ;
46147: GO 46209
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46149: LD_ADDR_EXP 108
46153: PUSH
46154: LD_EXP 108
46158: PPUSH
46159: LD_VAR 0 1
46163: PPUSH
46164: LD_EXP 108
46168: PUSH
46169: LD_VAR 0 1
46173: ARRAY
46174: PPUSH
46175: LD_EXP 108
46179: PUSH
46180: LD_VAR 0 1
46184: ARRAY
46185: PUSH
46186: LD_INT 1
46188: PLUS
46189: PPUSH
46190: LD_VAR 0 4
46194: PUSH
46195: LD_INT 1
46197: ARRAY
46198: PPUSH
46199: CALL_OW 2
46203: PPUSH
46204: CALL_OW 1
46208: ST_TO_ADDR
// end ;
46209: LD_VAR 0 3
46213: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46214: LD_INT 0
46216: PPUSH
46217: PPUSH
// if not mc_bases or not base or not kinds then
46218: LD_EXP 76
46222: NOT
46223: PUSH
46224: LD_VAR 0 1
46228: NOT
46229: OR
46230: PUSH
46231: LD_VAR 0 2
46235: NOT
46236: OR
46237: IFFALSE 46241
// exit ;
46239: GO 46302
// for i in kinds do
46241: LD_ADDR_VAR 0 4
46245: PUSH
46246: LD_VAR 0 2
46250: PUSH
46251: FOR_IN
46252: IFFALSE 46300
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46254: LD_ADDR_EXP 110
46258: PUSH
46259: LD_EXP 110
46263: PPUSH
46264: LD_VAR 0 1
46268: PUSH
46269: LD_EXP 110
46273: PUSH
46274: LD_VAR 0 1
46278: ARRAY
46279: PUSH
46280: LD_INT 1
46282: PLUS
46283: PUSH
46284: EMPTY
46285: LIST
46286: LIST
46287: PPUSH
46288: LD_VAR 0 4
46292: PPUSH
46293: CALL 57045 0 3
46297: ST_TO_ADDR
46298: GO 46251
46300: POP
46301: POP
// end ;
46302: LD_VAR 0 3
46306: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46307: LD_INT 0
46309: PPUSH
// if not mc_bases or not base or not areas then
46310: LD_EXP 76
46314: NOT
46315: PUSH
46316: LD_VAR 0 1
46320: NOT
46321: OR
46322: PUSH
46323: LD_VAR 0 2
46327: NOT
46328: OR
46329: IFFALSE 46333
// exit ;
46331: GO 46358
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46333: LD_ADDR_EXP 94
46337: PUSH
46338: LD_EXP 94
46342: PPUSH
46343: LD_VAR 0 1
46347: PPUSH
46348: LD_VAR 0 2
46352: PPUSH
46353: CALL_OW 1
46357: ST_TO_ADDR
// end ;
46358: LD_VAR 0 3
46362: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46363: LD_INT 0
46365: PPUSH
// if not mc_bases or not base or not teleports_exit then
46366: LD_EXP 76
46370: NOT
46371: PUSH
46372: LD_VAR 0 1
46376: NOT
46377: OR
46378: PUSH
46379: LD_VAR 0 2
46383: NOT
46384: OR
46385: IFFALSE 46389
// exit ;
46387: GO 46414
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46389: LD_ADDR_EXP 111
46393: PUSH
46394: LD_EXP 111
46398: PPUSH
46399: LD_VAR 0 1
46403: PPUSH
46404: LD_VAR 0 2
46408: PPUSH
46409: CALL_OW 1
46413: ST_TO_ADDR
// end ;
46414: LD_VAR 0 3
46418: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46419: LD_INT 0
46421: PPUSH
46422: PPUSH
46423: PPUSH
// if not mc_bases or not base or not ext_list then
46424: LD_EXP 76
46428: NOT
46429: PUSH
46430: LD_VAR 0 1
46434: NOT
46435: OR
46436: PUSH
46437: LD_VAR 0 5
46441: NOT
46442: OR
46443: IFFALSE 46447
// exit ;
46445: GO 46620
// tmp := GetFacExtXYD ( x , y , d ) ;
46447: LD_ADDR_VAR 0 8
46451: PUSH
46452: LD_VAR 0 2
46456: PPUSH
46457: LD_VAR 0 3
46461: PPUSH
46462: LD_VAR 0 4
46466: PPUSH
46467: CALL 86996 0 3
46471: ST_TO_ADDR
// if not tmp then
46472: LD_VAR 0 8
46476: NOT
46477: IFFALSE 46481
// exit ;
46479: GO 46620
// for i in tmp do
46481: LD_ADDR_VAR 0 7
46485: PUSH
46486: LD_VAR 0 8
46490: PUSH
46491: FOR_IN
46492: IFFALSE 46618
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46494: LD_ADDR_EXP 81
46498: PUSH
46499: LD_EXP 81
46503: PPUSH
46504: LD_VAR 0 1
46508: PPUSH
46509: LD_EXP 81
46513: PUSH
46514: LD_VAR 0 1
46518: ARRAY
46519: PPUSH
46520: LD_EXP 81
46524: PUSH
46525: LD_VAR 0 1
46529: ARRAY
46530: PUSH
46531: LD_INT 1
46533: PLUS
46534: PPUSH
46535: LD_VAR 0 5
46539: PUSH
46540: LD_INT 1
46542: ARRAY
46543: PUSH
46544: LD_VAR 0 7
46548: PUSH
46549: LD_INT 1
46551: ARRAY
46552: PUSH
46553: LD_VAR 0 7
46557: PUSH
46558: LD_INT 2
46560: ARRAY
46561: PUSH
46562: LD_VAR 0 7
46566: PUSH
46567: LD_INT 3
46569: ARRAY
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: LIST
46575: LIST
46576: PPUSH
46577: CALL_OW 2
46581: PPUSH
46582: CALL_OW 1
46586: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46587: LD_ADDR_VAR 0 5
46591: PUSH
46592: LD_VAR 0 5
46596: PPUSH
46597: LD_INT 1
46599: PPUSH
46600: CALL_OW 3
46604: ST_TO_ADDR
// if not ext_list then
46605: LD_VAR 0 5
46609: NOT
46610: IFFALSE 46616
// exit ;
46612: POP
46613: POP
46614: GO 46620
// end ;
46616: GO 46491
46618: POP
46619: POP
// end ;
46620: LD_VAR 0 6
46624: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46625: LD_INT 0
46627: PPUSH
// if not mc_bases or not base or not weapon_list then
46628: LD_EXP 76
46632: NOT
46633: PUSH
46634: LD_VAR 0 1
46638: NOT
46639: OR
46640: PUSH
46641: LD_VAR 0 2
46645: NOT
46646: OR
46647: IFFALSE 46651
// exit ;
46649: GO 46676
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46651: LD_ADDR_EXP 115
46655: PUSH
46656: LD_EXP 115
46660: PPUSH
46661: LD_VAR 0 1
46665: PPUSH
46666: LD_VAR 0 2
46670: PPUSH
46671: CALL_OW 1
46675: ST_TO_ADDR
// end ;
46676: LD_VAR 0 3
46680: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46681: LD_INT 0
46683: PPUSH
// if not mc_bases or not base or not tech_list then
46684: LD_EXP 76
46688: NOT
46689: PUSH
46690: LD_VAR 0 1
46694: NOT
46695: OR
46696: PUSH
46697: LD_VAR 0 2
46701: NOT
46702: OR
46703: IFFALSE 46707
// exit ;
46705: GO 46732
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46707: LD_ADDR_EXP 103
46711: PUSH
46712: LD_EXP 103
46716: PPUSH
46717: LD_VAR 0 1
46721: PPUSH
46722: LD_VAR 0 2
46726: PPUSH
46727: CALL_OW 1
46731: ST_TO_ADDR
// end ;
46732: LD_VAR 0 3
46736: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46737: LD_INT 0
46739: PPUSH
// if not mc_bases or not parking_area or not base then
46740: LD_EXP 76
46744: NOT
46745: PUSH
46746: LD_VAR 0 2
46750: NOT
46751: OR
46752: PUSH
46753: LD_VAR 0 1
46757: NOT
46758: OR
46759: IFFALSE 46763
// exit ;
46761: GO 46788
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46763: LD_ADDR_EXP 100
46767: PUSH
46768: LD_EXP 100
46772: PPUSH
46773: LD_VAR 0 1
46777: PPUSH
46778: LD_VAR 0 2
46782: PPUSH
46783: CALL_OW 1
46787: ST_TO_ADDR
// end ;
46788: LD_VAR 0 3
46792: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46793: LD_INT 0
46795: PPUSH
// if not mc_bases or not base or not scan_area then
46796: LD_EXP 76
46800: NOT
46801: PUSH
46802: LD_VAR 0 1
46806: NOT
46807: OR
46808: PUSH
46809: LD_VAR 0 2
46813: NOT
46814: OR
46815: IFFALSE 46819
// exit ;
46817: GO 46844
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46819: LD_ADDR_EXP 101
46823: PUSH
46824: LD_EXP 101
46828: PPUSH
46829: LD_VAR 0 1
46833: PPUSH
46834: LD_VAR 0 2
46838: PPUSH
46839: CALL_OW 1
46843: ST_TO_ADDR
// end ;
46844: LD_VAR 0 3
46848: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46849: LD_INT 0
46851: PPUSH
46852: PPUSH
// if not mc_bases or not base then
46853: LD_EXP 76
46857: NOT
46858: PUSH
46859: LD_VAR 0 1
46863: NOT
46864: OR
46865: IFFALSE 46869
// exit ;
46867: GO 46933
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46869: LD_ADDR_VAR 0 3
46873: PUSH
46874: LD_INT 1
46876: PUSH
46877: LD_INT 2
46879: PUSH
46880: LD_INT 3
46882: PUSH
46883: LD_INT 4
46885: PUSH
46886: LD_INT 11
46888: PUSH
46889: EMPTY
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46896: LD_ADDR_EXP 103
46900: PUSH
46901: LD_EXP 103
46905: PPUSH
46906: LD_VAR 0 1
46910: PPUSH
46911: LD_EXP 103
46915: PUSH
46916: LD_VAR 0 1
46920: ARRAY
46921: PUSH
46922: LD_VAR 0 3
46926: DIFF
46927: PPUSH
46928: CALL_OW 1
46932: ST_TO_ADDR
// end ;
46933: LD_VAR 0 2
46937: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
46938: LD_INT 0
46940: PPUSH
// result := mc_vehicles [ base ] ;
46941: LD_ADDR_VAR 0 3
46945: PUSH
46946: LD_EXP 95
46950: PUSH
46951: LD_VAR 0 1
46955: ARRAY
46956: ST_TO_ADDR
// if onlyCombat then
46957: LD_VAR 0 2
46961: IFFALSE 47133
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
46963: LD_ADDR_VAR 0 3
46967: PUSH
46968: LD_VAR 0 3
46972: PUSH
46973: LD_VAR 0 3
46977: PPUSH
46978: LD_INT 2
46980: PUSH
46981: LD_INT 34
46983: PUSH
46984: LD_INT 12
46986: PUSH
46987: EMPTY
46988: LIST
46989: LIST
46990: PUSH
46991: LD_INT 34
46993: PUSH
46994: LD_INT 51
46996: PUSH
46997: EMPTY
46998: LIST
46999: LIST
47000: PUSH
47001: LD_INT 34
47003: PUSH
47004: LD_INT 89
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PUSH
47011: LD_INT 34
47013: PUSH
47014: LD_INT 32
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 34
47023: PUSH
47024: LD_INT 13
47026: PUSH
47027: EMPTY
47028: LIST
47029: LIST
47030: PUSH
47031: LD_INT 34
47033: PUSH
47034: LD_INT 52
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 34
47043: PUSH
47044: LD_INT 88
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 34
47053: PUSH
47054: LD_INT 14
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: LD_INT 34
47063: PUSH
47064: LD_INT 53
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: PUSH
47071: LD_INT 34
47073: PUSH
47074: LD_INT 98
47076: PUSH
47077: EMPTY
47078: LIST
47079: LIST
47080: PUSH
47081: LD_INT 34
47083: PUSH
47084: LD_INT 31
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PUSH
47091: LD_INT 34
47093: PUSH
47094: LD_INT 48
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 34
47103: PUSH
47104: LD_INT 8
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: LIST
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: LIST
47126: PPUSH
47127: CALL_OW 72
47131: DIFF
47132: ST_TO_ADDR
// end ; end_of_file
47133: LD_VAR 0 3
47137: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47138: LD_INT 0
47140: PPUSH
47141: PPUSH
47142: PPUSH
// if not mc_bases or not skirmish then
47143: LD_EXP 76
47147: NOT
47148: PUSH
47149: LD_EXP 74
47153: NOT
47154: OR
47155: IFFALSE 47159
// exit ;
47157: GO 47324
// for i = 1 to mc_bases do
47159: LD_ADDR_VAR 0 4
47163: PUSH
47164: DOUBLE
47165: LD_INT 1
47167: DEC
47168: ST_TO_ADDR
47169: LD_EXP 76
47173: PUSH
47174: FOR_TO
47175: IFFALSE 47322
// begin if sci in mc_bases [ i ] then
47177: LD_VAR 0 2
47181: PUSH
47182: LD_EXP 76
47186: PUSH
47187: LD_VAR 0 4
47191: ARRAY
47192: IN
47193: IFFALSE 47320
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47195: LD_ADDR_EXP 105
47199: PUSH
47200: LD_EXP 105
47204: PPUSH
47205: LD_VAR 0 4
47209: PUSH
47210: LD_EXP 105
47214: PUSH
47215: LD_VAR 0 4
47219: ARRAY
47220: PUSH
47221: LD_INT 1
47223: PLUS
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PPUSH
47229: LD_VAR 0 1
47233: PPUSH
47234: CALL 57045 0 3
47238: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47239: LD_ADDR_VAR 0 5
47243: PUSH
47244: LD_EXP 76
47248: PUSH
47249: LD_VAR 0 4
47253: ARRAY
47254: PPUSH
47255: LD_INT 2
47257: PUSH
47258: LD_INT 30
47260: PUSH
47261: LD_INT 0
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: PUSH
47268: LD_INT 30
47270: PUSH
47271: LD_INT 1
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: LIST
47282: PPUSH
47283: CALL_OW 72
47287: PPUSH
47288: LD_VAR 0 1
47292: PPUSH
47293: CALL_OW 74
47297: ST_TO_ADDR
// if tmp then
47298: LD_VAR 0 5
47302: IFFALSE 47318
// ComStandNearbyBuilding ( ape , tmp ) ;
47304: LD_VAR 0 1
47308: PPUSH
47309: LD_VAR 0 5
47313: PPUSH
47314: CALL 53472 0 2
// break ;
47318: GO 47322
// end ; end ;
47320: GO 47174
47322: POP
47323: POP
// end ;
47324: LD_VAR 0 3
47328: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47329: LD_INT 0
47331: PPUSH
47332: PPUSH
47333: PPUSH
// if not mc_bases or not skirmish then
47334: LD_EXP 76
47338: NOT
47339: PUSH
47340: LD_EXP 74
47344: NOT
47345: OR
47346: IFFALSE 47350
// exit ;
47348: GO 47439
// for i = 1 to mc_bases do
47350: LD_ADDR_VAR 0 4
47354: PUSH
47355: DOUBLE
47356: LD_INT 1
47358: DEC
47359: ST_TO_ADDR
47360: LD_EXP 76
47364: PUSH
47365: FOR_TO
47366: IFFALSE 47437
// begin if building in mc_busy_turret_list [ i ] then
47368: LD_VAR 0 1
47372: PUSH
47373: LD_EXP 86
47377: PUSH
47378: LD_VAR 0 4
47382: ARRAY
47383: IN
47384: IFFALSE 47435
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47386: LD_ADDR_VAR 0 5
47390: PUSH
47391: LD_EXP 86
47395: PUSH
47396: LD_VAR 0 4
47400: ARRAY
47401: PUSH
47402: LD_VAR 0 1
47406: DIFF
47407: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47408: LD_ADDR_EXP 86
47412: PUSH
47413: LD_EXP 86
47417: PPUSH
47418: LD_VAR 0 4
47422: PPUSH
47423: LD_VAR 0 5
47427: PPUSH
47428: CALL_OW 1
47432: ST_TO_ADDR
// break ;
47433: GO 47437
// end ; end ;
47435: GO 47365
47437: POP
47438: POP
// end ;
47439: LD_VAR 0 3
47443: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47444: LD_INT 0
47446: PPUSH
47447: PPUSH
47448: PPUSH
// if not mc_bases or not skirmish then
47449: LD_EXP 76
47453: NOT
47454: PUSH
47455: LD_EXP 74
47459: NOT
47460: OR
47461: IFFALSE 47465
// exit ;
47463: GO 47664
// for i = 1 to mc_bases do
47465: LD_ADDR_VAR 0 5
47469: PUSH
47470: DOUBLE
47471: LD_INT 1
47473: DEC
47474: ST_TO_ADDR
47475: LD_EXP 76
47479: PUSH
47480: FOR_TO
47481: IFFALSE 47662
// if building in mc_bases [ i ] then
47483: LD_VAR 0 1
47487: PUSH
47488: LD_EXP 76
47492: PUSH
47493: LD_VAR 0 5
47497: ARRAY
47498: IN
47499: IFFALSE 47660
// begin tmp := mc_bases [ i ] diff building ;
47501: LD_ADDR_VAR 0 6
47505: PUSH
47506: LD_EXP 76
47510: PUSH
47511: LD_VAR 0 5
47515: ARRAY
47516: PUSH
47517: LD_VAR 0 1
47521: DIFF
47522: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47523: LD_ADDR_EXP 76
47527: PUSH
47528: LD_EXP 76
47532: PPUSH
47533: LD_VAR 0 5
47537: PPUSH
47538: LD_VAR 0 6
47542: PPUSH
47543: CALL_OW 1
47547: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47548: LD_VAR 0 1
47552: PUSH
47553: LD_EXP 84
47557: PUSH
47558: LD_VAR 0 5
47562: ARRAY
47563: IN
47564: IFFALSE 47603
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47566: LD_ADDR_EXP 84
47570: PUSH
47571: LD_EXP 84
47575: PPUSH
47576: LD_VAR 0 5
47580: PPUSH
47581: LD_EXP 84
47585: PUSH
47586: LD_VAR 0 5
47590: ARRAY
47591: PUSH
47592: LD_VAR 0 1
47596: DIFF
47597: PPUSH
47598: CALL_OW 1
47602: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47603: LD_VAR 0 1
47607: PUSH
47608: LD_EXP 85
47612: PUSH
47613: LD_VAR 0 5
47617: ARRAY
47618: IN
47619: IFFALSE 47658
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47621: LD_ADDR_EXP 85
47625: PUSH
47626: LD_EXP 85
47630: PPUSH
47631: LD_VAR 0 5
47635: PPUSH
47636: LD_EXP 85
47640: PUSH
47641: LD_VAR 0 5
47645: ARRAY
47646: PUSH
47647: LD_VAR 0 1
47651: DIFF
47652: PPUSH
47653: CALL_OW 1
47657: ST_TO_ADDR
// break ;
47658: GO 47662
// end ;
47660: GO 47480
47662: POP
47663: POP
// end ;
47664: LD_VAR 0 4
47668: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47669: LD_INT 0
47671: PPUSH
47672: PPUSH
47673: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47674: LD_EXP 76
47678: NOT
47679: PUSH
47680: LD_EXP 74
47684: NOT
47685: OR
47686: PUSH
47687: LD_VAR 0 3
47691: PUSH
47692: LD_EXP 102
47696: IN
47697: NOT
47698: OR
47699: IFFALSE 47703
// exit ;
47701: GO 47826
// for i = 1 to mc_vehicles do
47703: LD_ADDR_VAR 0 6
47707: PUSH
47708: DOUBLE
47709: LD_INT 1
47711: DEC
47712: ST_TO_ADDR
47713: LD_EXP 95
47717: PUSH
47718: FOR_TO
47719: IFFALSE 47824
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47721: LD_VAR 0 2
47725: PUSH
47726: LD_EXP 95
47730: PUSH
47731: LD_VAR 0 6
47735: ARRAY
47736: IN
47737: PUSH
47738: LD_VAR 0 1
47742: PUSH
47743: LD_EXP 95
47747: PUSH
47748: LD_VAR 0 6
47752: ARRAY
47753: IN
47754: OR
47755: IFFALSE 47822
// begin tmp := mc_vehicles [ i ] diff old ;
47757: LD_ADDR_VAR 0 7
47761: PUSH
47762: LD_EXP 95
47766: PUSH
47767: LD_VAR 0 6
47771: ARRAY
47772: PUSH
47773: LD_VAR 0 2
47777: DIFF
47778: ST_TO_ADDR
// tmp := tmp diff new ;
47779: LD_ADDR_VAR 0 7
47783: PUSH
47784: LD_VAR 0 7
47788: PUSH
47789: LD_VAR 0 1
47793: DIFF
47794: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47795: LD_ADDR_EXP 95
47799: PUSH
47800: LD_EXP 95
47804: PPUSH
47805: LD_VAR 0 6
47809: PPUSH
47810: LD_VAR 0 7
47814: PPUSH
47815: CALL_OW 1
47819: ST_TO_ADDR
// break ;
47820: GO 47824
// end ;
47822: GO 47718
47824: POP
47825: POP
// end ;
47826: LD_VAR 0 5
47830: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47831: LD_INT 0
47833: PPUSH
47834: PPUSH
47835: PPUSH
47836: PPUSH
// if not mc_bases or not skirmish then
47837: LD_EXP 76
47841: NOT
47842: PUSH
47843: LD_EXP 74
47847: NOT
47848: OR
47849: IFFALSE 47853
// exit ;
47851: GO 48235
// side := GetSide ( vehicle ) ;
47853: LD_ADDR_VAR 0 5
47857: PUSH
47858: LD_VAR 0 1
47862: PPUSH
47863: CALL_OW 255
47867: ST_TO_ADDR
// for i = 1 to mc_bases do
47868: LD_ADDR_VAR 0 4
47872: PUSH
47873: DOUBLE
47874: LD_INT 1
47876: DEC
47877: ST_TO_ADDR
47878: LD_EXP 76
47882: PUSH
47883: FOR_TO
47884: IFFALSE 48233
// begin if factory in mc_bases [ i ] then
47886: LD_VAR 0 2
47890: PUSH
47891: LD_EXP 76
47895: PUSH
47896: LD_VAR 0 4
47900: ARRAY
47901: IN
47902: IFFALSE 48231
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
47904: LD_EXP 98
47908: PUSH
47909: LD_VAR 0 4
47913: ARRAY
47914: PUSH
47915: LD_EXP 87
47919: PUSH
47920: LD_VAR 0 4
47924: ARRAY
47925: LESS
47926: PUSH
47927: LD_VAR 0 1
47931: PPUSH
47932: CALL_OW 264
47936: PUSH
47937: LD_INT 31
47939: PUSH
47940: LD_INT 32
47942: PUSH
47943: LD_INT 51
47945: PUSH
47946: LD_INT 89
47948: PUSH
47949: LD_INT 12
47951: PUSH
47952: LD_INT 30
47954: PUSH
47955: LD_INT 98
47957: PUSH
47958: LD_INT 11
47960: PUSH
47961: LD_INT 53
47963: PUSH
47964: LD_INT 14
47966: PUSH
47967: LD_INT 91
47969: PUSH
47970: LD_INT 29
47972: PUSH
47973: LD_INT 99
47975: PUSH
47976: LD_INT 13
47978: PUSH
47979: LD_INT 52
47981: PUSH
47982: LD_INT 88
47984: PUSH
47985: LD_INT 48
47987: PUSH
47988: LD_INT 8
47990: PUSH
47991: EMPTY
47992: LIST
47993: LIST
47994: LIST
47995: LIST
47996: LIST
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: IN
48011: NOT
48012: AND
48013: IFFALSE 48061
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48015: LD_ADDR_EXP 98
48019: PUSH
48020: LD_EXP 98
48024: PPUSH
48025: LD_VAR 0 4
48029: PUSH
48030: LD_EXP 98
48034: PUSH
48035: LD_VAR 0 4
48039: ARRAY
48040: PUSH
48041: LD_INT 1
48043: PLUS
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: PPUSH
48049: LD_VAR 0 1
48053: PPUSH
48054: CALL 57045 0 3
48058: ST_TO_ADDR
48059: GO 48105
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48061: LD_ADDR_EXP 95
48065: PUSH
48066: LD_EXP 95
48070: PPUSH
48071: LD_VAR 0 4
48075: PUSH
48076: LD_EXP 95
48080: PUSH
48081: LD_VAR 0 4
48085: ARRAY
48086: PUSH
48087: LD_INT 1
48089: PLUS
48090: PUSH
48091: EMPTY
48092: LIST
48093: LIST
48094: PPUSH
48095: LD_VAR 0 1
48099: PPUSH
48100: CALL 57045 0 3
48104: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48105: LD_VAR 0 1
48109: PPUSH
48110: CALL_OW 263
48114: PUSH
48115: LD_INT 2
48117: EQUAL
48118: IFFALSE 48147
// begin repeat wait ( 0 0$3 ) ;
48120: LD_INT 105
48122: PPUSH
48123: CALL_OW 67
// Connect ( vehicle ) ;
48127: LD_VAR 0 1
48131: PPUSH
48132: CALL 60014 0 1
// until IsControledBy ( vehicle ) ;
48136: LD_VAR 0 1
48140: PPUSH
48141: CALL_OW 312
48145: IFFALSE 48120
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48147: LD_VAR 0 1
48151: PPUSH
48152: LD_EXP 100
48156: PUSH
48157: LD_VAR 0 4
48161: ARRAY
48162: PPUSH
48163: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48167: LD_VAR 0 1
48171: PPUSH
48172: CALL_OW 263
48176: PUSH
48177: LD_INT 1
48179: NONEQUAL
48180: IFFALSE 48184
// break ;
48182: GO 48233
// repeat wait ( 0 0$1 ) ;
48184: LD_INT 35
48186: PPUSH
48187: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48191: LD_VAR 0 1
48195: PPUSH
48196: LD_EXP 100
48200: PUSH
48201: LD_VAR 0 4
48205: ARRAY
48206: PPUSH
48207: CALL_OW 308
48211: IFFALSE 48184
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48213: LD_VAR 0 1
48217: PPUSH
48218: CALL_OW 311
48222: PPUSH
48223: CALL_OW 121
// exit ;
48227: POP
48228: POP
48229: GO 48235
// end ; end ;
48231: GO 47883
48233: POP
48234: POP
// end ;
48235: LD_VAR 0 3
48239: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48240: LD_INT 0
48242: PPUSH
48243: PPUSH
48244: PPUSH
48245: PPUSH
// if not mc_bases or not skirmish then
48246: LD_EXP 76
48250: NOT
48251: PUSH
48252: LD_EXP 74
48256: NOT
48257: OR
48258: IFFALSE 48262
// exit ;
48260: GO 48615
// repeat wait ( 0 0$1 ) ;
48262: LD_INT 35
48264: PPUSH
48265: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48269: LD_VAR 0 2
48273: PPUSH
48274: LD_VAR 0 3
48278: PPUSH
48279: CALL_OW 284
48283: IFFALSE 48262
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48285: LD_VAR 0 2
48289: PPUSH
48290: LD_VAR 0 3
48294: PPUSH
48295: CALL_OW 283
48299: PUSH
48300: LD_INT 4
48302: EQUAL
48303: IFFALSE 48307
// exit ;
48305: GO 48615
// for i = 1 to mc_bases do
48307: LD_ADDR_VAR 0 7
48311: PUSH
48312: DOUBLE
48313: LD_INT 1
48315: DEC
48316: ST_TO_ADDR
48317: LD_EXP 76
48321: PUSH
48322: FOR_TO
48323: IFFALSE 48613
// begin if mc_crates_area [ i ] then
48325: LD_EXP 94
48329: PUSH
48330: LD_VAR 0 7
48334: ARRAY
48335: IFFALSE 48446
// for j in mc_crates_area [ i ] do
48337: LD_ADDR_VAR 0 8
48341: PUSH
48342: LD_EXP 94
48346: PUSH
48347: LD_VAR 0 7
48351: ARRAY
48352: PUSH
48353: FOR_IN
48354: IFFALSE 48444
// if InArea ( x , y , j ) then
48356: LD_VAR 0 2
48360: PPUSH
48361: LD_VAR 0 3
48365: PPUSH
48366: LD_VAR 0 8
48370: PPUSH
48371: CALL_OW 309
48375: IFFALSE 48442
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48377: LD_ADDR_EXP 92
48381: PUSH
48382: LD_EXP 92
48386: PPUSH
48387: LD_VAR 0 7
48391: PUSH
48392: LD_EXP 92
48396: PUSH
48397: LD_VAR 0 7
48401: ARRAY
48402: PUSH
48403: LD_INT 1
48405: PLUS
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PPUSH
48411: LD_VAR 0 4
48415: PUSH
48416: LD_VAR 0 2
48420: PUSH
48421: LD_VAR 0 3
48425: PUSH
48426: EMPTY
48427: LIST
48428: LIST
48429: LIST
48430: PPUSH
48431: CALL 57045 0 3
48435: ST_TO_ADDR
// exit ;
48436: POP
48437: POP
48438: POP
48439: POP
48440: GO 48615
// end ;
48442: GO 48353
48444: POP
48445: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48446: LD_ADDR_VAR 0 9
48450: PUSH
48451: LD_EXP 76
48455: PUSH
48456: LD_VAR 0 7
48460: ARRAY
48461: PPUSH
48462: LD_INT 2
48464: PUSH
48465: LD_INT 30
48467: PUSH
48468: LD_INT 0
48470: PUSH
48471: EMPTY
48472: LIST
48473: LIST
48474: PUSH
48475: LD_INT 30
48477: PUSH
48478: LD_INT 1
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: LIST
48489: PPUSH
48490: CALL_OW 72
48494: ST_TO_ADDR
// if not depot then
48495: LD_VAR 0 9
48499: NOT
48500: IFFALSE 48504
// continue ;
48502: GO 48322
// for j in depot do
48504: LD_ADDR_VAR 0 8
48508: PUSH
48509: LD_VAR 0 9
48513: PUSH
48514: FOR_IN
48515: IFFALSE 48609
// if GetDistUnitXY ( j , x , y ) < 30 then
48517: LD_VAR 0 8
48521: PPUSH
48522: LD_VAR 0 2
48526: PPUSH
48527: LD_VAR 0 3
48531: PPUSH
48532: CALL_OW 297
48536: PUSH
48537: LD_INT 30
48539: LESS
48540: IFFALSE 48607
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48542: LD_ADDR_EXP 92
48546: PUSH
48547: LD_EXP 92
48551: PPUSH
48552: LD_VAR 0 7
48556: PUSH
48557: LD_EXP 92
48561: PUSH
48562: LD_VAR 0 7
48566: ARRAY
48567: PUSH
48568: LD_INT 1
48570: PLUS
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: PPUSH
48576: LD_VAR 0 4
48580: PUSH
48581: LD_VAR 0 2
48585: PUSH
48586: LD_VAR 0 3
48590: PUSH
48591: EMPTY
48592: LIST
48593: LIST
48594: LIST
48595: PPUSH
48596: CALL 57045 0 3
48600: ST_TO_ADDR
// exit ;
48601: POP
48602: POP
48603: POP
48604: POP
48605: GO 48615
// end ;
48607: GO 48514
48609: POP
48610: POP
// end ;
48611: GO 48322
48613: POP
48614: POP
// end ;
48615: LD_VAR 0 6
48619: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48620: LD_INT 0
48622: PPUSH
48623: PPUSH
48624: PPUSH
48625: PPUSH
// if not mc_bases or not skirmish then
48626: LD_EXP 76
48630: NOT
48631: PUSH
48632: LD_EXP 74
48636: NOT
48637: OR
48638: IFFALSE 48642
// exit ;
48640: GO 48919
// side := GetSide ( lab ) ;
48642: LD_ADDR_VAR 0 4
48646: PUSH
48647: LD_VAR 0 2
48651: PPUSH
48652: CALL_OW 255
48656: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48657: LD_VAR 0 4
48661: PUSH
48662: LD_EXP 102
48666: IN
48667: NOT
48668: PUSH
48669: LD_EXP 103
48673: NOT
48674: OR
48675: PUSH
48676: LD_EXP 76
48680: NOT
48681: OR
48682: IFFALSE 48686
// exit ;
48684: GO 48919
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48686: LD_ADDR_EXP 103
48690: PUSH
48691: LD_EXP 103
48695: PPUSH
48696: LD_VAR 0 4
48700: PPUSH
48701: LD_EXP 103
48705: PUSH
48706: LD_VAR 0 4
48710: ARRAY
48711: PUSH
48712: LD_VAR 0 1
48716: DIFF
48717: PPUSH
48718: CALL_OW 1
48722: ST_TO_ADDR
// for i = 1 to mc_bases do
48723: LD_ADDR_VAR 0 5
48727: PUSH
48728: DOUBLE
48729: LD_INT 1
48731: DEC
48732: ST_TO_ADDR
48733: LD_EXP 76
48737: PUSH
48738: FOR_TO
48739: IFFALSE 48917
// begin if lab in mc_bases [ i ] then
48741: LD_VAR 0 2
48745: PUSH
48746: LD_EXP 76
48750: PUSH
48751: LD_VAR 0 5
48755: ARRAY
48756: IN
48757: IFFALSE 48915
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48759: LD_VAR 0 1
48763: PUSH
48764: LD_INT 11
48766: PUSH
48767: LD_INT 4
48769: PUSH
48770: LD_INT 3
48772: PUSH
48773: LD_INT 2
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: LIST
48780: LIST
48781: IN
48782: PUSH
48783: LD_EXP 106
48787: PUSH
48788: LD_VAR 0 5
48792: ARRAY
48793: AND
48794: IFFALSE 48915
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48796: LD_ADDR_VAR 0 6
48800: PUSH
48801: LD_EXP 106
48805: PUSH
48806: LD_VAR 0 5
48810: ARRAY
48811: PUSH
48812: LD_INT 1
48814: ARRAY
48815: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48816: LD_ADDR_EXP 106
48820: PUSH
48821: LD_EXP 106
48825: PPUSH
48826: LD_VAR 0 5
48830: PPUSH
48831: EMPTY
48832: PPUSH
48833: CALL_OW 1
48837: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48838: LD_VAR 0 6
48842: PPUSH
48843: LD_INT 0
48845: PPUSH
48846: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48850: LD_VAR 0 6
48854: PPUSH
48855: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48859: LD_ADDR_EXP 105
48863: PUSH
48864: LD_EXP 105
48868: PPUSH
48869: LD_VAR 0 5
48873: PPUSH
48874: LD_EXP 105
48878: PUSH
48879: LD_VAR 0 5
48883: ARRAY
48884: PPUSH
48885: LD_INT 1
48887: PPUSH
48888: LD_VAR 0 6
48892: PPUSH
48893: CALL_OW 2
48897: PPUSH
48898: CALL_OW 1
48902: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
48903: LD_VAR 0 5
48907: PPUSH
48908: LD_INT 112
48910: PPUSH
48911: CALL 25405 0 2
// end ; end ; end ;
48915: GO 48738
48917: POP
48918: POP
// end ;
48919: LD_VAR 0 3
48923: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
48924: LD_INT 0
48926: PPUSH
48927: PPUSH
48928: PPUSH
48929: PPUSH
48930: PPUSH
48931: PPUSH
48932: PPUSH
48933: PPUSH
// if not mc_bases or not skirmish then
48934: LD_EXP 76
48938: NOT
48939: PUSH
48940: LD_EXP 74
48944: NOT
48945: OR
48946: IFFALSE 48950
// exit ;
48948: GO 50319
// for i = 1 to mc_bases do
48950: LD_ADDR_VAR 0 3
48954: PUSH
48955: DOUBLE
48956: LD_INT 1
48958: DEC
48959: ST_TO_ADDR
48960: LD_EXP 76
48964: PUSH
48965: FOR_TO
48966: IFFALSE 50317
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
48968: LD_VAR 0 1
48972: PUSH
48973: LD_EXP 76
48977: PUSH
48978: LD_VAR 0 3
48982: ARRAY
48983: IN
48984: PUSH
48985: LD_VAR 0 1
48989: PUSH
48990: LD_EXP 83
48994: PUSH
48995: LD_VAR 0 3
48999: ARRAY
49000: IN
49001: OR
49002: PUSH
49003: LD_VAR 0 1
49007: PUSH
49008: LD_EXP 98
49012: PUSH
49013: LD_VAR 0 3
49017: ARRAY
49018: IN
49019: OR
49020: PUSH
49021: LD_VAR 0 1
49025: PUSH
49026: LD_EXP 95
49030: PUSH
49031: LD_VAR 0 3
49035: ARRAY
49036: IN
49037: OR
49038: PUSH
49039: LD_VAR 0 1
49043: PUSH
49044: LD_EXP 105
49048: PUSH
49049: LD_VAR 0 3
49053: ARRAY
49054: IN
49055: OR
49056: PUSH
49057: LD_VAR 0 1
49061: PUSH
49062: LD_EXP 106
49066: PUSH
49067: LD_VAR 0 3
49071: ARRAY
49072: IN
49073: OR
49074: IFFALSE 50315
// begin if un in mc_ape [ i ] then
49076: LD_VAR 0 1
49080: PUSH
49081: LD_EXP 105
49085: PUSH
49086: LD_VAR 0 3
49090: ARRAY
49091: IN
49092: IFFALSE 49131
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49094: LD_ADDR_EXP 105
49098: PUSH
49099: LD_EXP 105
49103: PPUSH
49104: LD_VAR 0 3
49108: PPUSH
49109: LD_EXP 105
49113: PUSH
49114: LD_VAR 0 3
49118: ARRAY
49119: PUSH
49120: LD_VAR 0 1
49124: DIFF
49125: PPUSH
49126: CALL_OW 1
49130: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49131: LD_VAR 0 1
49135: PUSH
49136: LD_EXP 106
49140: PUSH
49141: LD_VAR 0 3
49145: ARRAY
49146: IN
49147: IFFALSE 49171
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49149: LD_ADDR_EXP 106
49153: PUSH
49154: LD_EXP 106
49158: PPUSH
49159: LD_VAR 0 3
49163: PPUSH
49164: EMPTY
49165: PPUSH
49166: CALL_OW 1
49170: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49171: LD_VAR 0 1
49175: PPUSH
49176: CALL_OW 247
49180: PUSH
49181: LD_INT 2
49183: EQUAL
49184: PUSH
49185: LD_VAR 0 1
49189: PPUSH
49190: CALL_OW 110
49194: PUSH
49195: LD_INT 20
49197: EQUAL
49198: PUSH
49199: LD_VAR 0 1
49203: PUSH
49204: LD_EXP 98
49208: PUSH
49209: LD_VAR 0 3
49213: ARRAY
49214: IN
49215: OR
49216: PUSH
49217: LD_VAR 0 1
49221: PPUSH
49222: CALL_OW 264
49226: PUSH
49227: LD_INT 12
49229: PUSH
49230: LD_INT 51
49232: PUSH
49233: LD_INT 89
49235: PUSH
49236: LD_INT 32
49238: PUSH
49239: LD_INT 13
49241: PUSH
49242: LD_INT 52
49244: PUSH
49245: LD_INT 31
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: LIST
49252: LIST
49253: LIST
49254: LIST
49255: LIST
49256: IN
49257: OR
49258: AND
49259: IFFALSE 49567
// begin if un in mc_defender [ i ] then
49261: LD_VAR 0 1
49265: PUSH
49266: LD_EXP 98
49270: PUSH
49271: LD_VAR 0 3
49275: ARRAY
49276: IN
49277: IFFALSE 49316
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49279: LD_ADDR_EXP 98
49283: PUSH
49284: LD_EXP 98
49288: PPUSH
49289: LD_VAR 0 3
49293: PPUSH
49294: LD_EXP 98
49298: PUSH
49299: LD_VAR 0 3
49303: ARRAY
49304: PUSH
49305: LD_VAR 0 1
49309: DIFF
49310: PPUSH
49311: CALL_OW 1
49315: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49316: LD_ADDR_VAR 0 8
49320: PUSH
49321: LD_VAR 0 3
49325: PPUSH
49326: LD_INT 3
49328: PPUSH
49329: CALL 45975 0 2
49333: ST_TO_ADDR
// if fac then
49334: LD_VAR 0 8
49338: IFFALSE 49567
// begin for j in fac do
49340: LD_ADDR_VAR 0 4
49344: PUSH
49345: LD_VAR 0 8
49349: PUSH
49350: FOR_IN
49351: IFFALSE 49565
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49353: LD_ADDR_VAR 0 9
49357: PUSH
49358: LD_VAR 0 8
49362: PPUSH
49363: LD_VAR 0 1
49367: PPUSH
49368: CALL_OW 265
49372: PPUSH
49373: LD_VAR 0 1
49377: PPUSH
49378: CALL_OW 262
49382: PPUSH
49383: LD_VAR 0 1
49387: PPUSH
49388: CALL_OW 263
49392: PPUSH
49393: LD_VAR 0 1
49397: PPUSH
49398: CALL_OW 264
49402: PPUSH
49403: CALL 54543 0 5
49407: ST_TO_ADDR
// if components then
49408: LD_VAR 0 9
49412: IFFALSE 49563
// begin if GetWeapon ( un ) = ar_control_tower then
49414: LD_VAR 0 1
49418: PPUSH
49419: CALL_OW 264
49423: PUSH
49424: LD_INT 31
49426: EQUAL
49427: IFFALSE 49544
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49429: LD_VAR 0 1
49433: PPUSH
49434: CALL_OW 311
49438: PPUSH
49439: LD_INT 0
49441: PPUSH
49442: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49446: LD_ADDR_EXP 116
49450: PUSH
49451: LD_EXP 116
49455: PPUSH
49456: LD_VAR 0 3
49460: PPUSH
49461: LD_EXP 116
49465: PUSH
49466: LD_VAR 0 3
49470: ARRAY
49471: PUSH
49472: LD_VAR 0 1
49476: PPUSH
49477: CALL_OW 311
49481: DIFF
49482: PPUSH
49483: CALL_OW 1
49487: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49488: LD_ADDR_VAR 0 7
49492: PUSH
49493: LD_EXP 97
49497: PUSH
49498: LD_VAR 0 3
49502: ARRAY
49503: PPUSH
49504: LD_INT 1
49506: PPUSH
49507: LD_VAR 0 9
49511: PPUSH
49512: CALL_OW 2
49516: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49517: LD_ADDR_EXP 97
49521: PUSH
49522: LD_EXP 97
49526: PPUSH
49527: LD_VAR 0 3
49531: PPUSH
49532: LD_VAR 0 7
49536: PPUSH
49537: CALL_OW 1
49541: ST_TO_ADDR
// end else
49542: GO 49561
// MC_InsertProduceList ( i , [ components ] ) ;
49544: LD_VAR 0 3
49548: PPUSH
49549: LD_VAR 0 9
49553: PUSH
49554: EMPTY
49555: LIST
49556: PPUSH
49557: CALL 45520 0 2
// break ;
49561: GO 49565
// end ; end ;
49563: GO 49350
49565: POP
49566: POP
// end ; end ; if GetType ( un ) = unit_building then
49567: LD_VAR 0 1
49571: PPUSH
49572: CALL_OW 247
49576: PUSH
49577: LD_INT 3
49579: EQUAL
49580: IFFALSE 49983
// begin btype := GetBType ( un ) ;
49582: LD_ADDR_VAR 0 5
49586: PUSH
49587: LD_VAR 0 1
49591: PPUSH
49592: CALL_OW 266
49596: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49597: LD_VAR 0 5
49601: PUSH
49602: LD_INT 29
49604: PUSH
49605: LD_INT 30
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: IN
49612: IFFALSE 49685
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49614: LD_VAR 0 1
49618: PPUSH
49619: CALL_OW 250
49623: PPUSH
49624: LD_VAR 0 1
49628: PPUSH
49629: CALL_OW 251
49633: PPUSH
49634: LD_VAR 0 1
49638: PPUSH
49639: CALL_OW 255
49643: PPUSH
49644: CALL_OW 440
49648: NOT
49649: IFFALSE 49685
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49651: LD_VAR 0 1
49655: PPUSH
49656: CALL_OW 250
49660: PPUSH
49661: LD_VAR 0 1
49665: PPUSH
49666: CALL_OW 251
49670: PPUSH
49671: LD_VAR 0 1
49675: PPUSH
49676: CALL_OW 255
49680: PPUSH
49681: CALL_OW 441
// end ; if btype = b_warehouse then
49685: LD_VAR 0 5
49689: PUSH
49690: LD_INT 1
49692: EQUAL
49693: IFFALSE 49711
// begin btype := b_depot ;
49695: LD_ADDR_VAR 0 5
49699: PUSH
49700: LD_INT 0
49702: ST_TO_ADDR
// pos := 1 ;
49703: LD_ADDR_VAR 0 6
49707: PUSH
49708: LD_INT 1
49710: ST_TO_ADDR
// end ; if btype = b_factory then
49711: LD_VAR 0 5
49715: PUSH
49716: LD_INT 3
49718: EQUAL
49719: IFFALSE 49737
// begin btype := b_workshop ;
49721: LD_ADDR_VAR 0 5
49725: PUSH
49726: LD_INT 2
49728: ST_TO_ADDR
// pos := 1 ;
49729: LD_ADDR_VAR 0 6
49733: PUSH
49734: LD_INT 1
49736: ST_TO_ADDR
// end ; if btype = b_barracks then
49737: LD_VAR 0 5
49741: PUSH
49742: LD_INT 5
49744: EQUAL
49745: IFFALSE 49755
// btype := b_armoury ;
49747: LD_ADDR_VAR 0 5
49751: PUSH
49752: LD_INT 4
49754: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49755: LD_VAR 0 5
49759: PUSH
49760: LD_INT 7
49762: PUSH
49763: LD_INT 8
49765: PUSH
49766: EMPTY
49767: LIST
49768: LIST
49769: IN
49770: IFFALSE 49780
// btype := b_lab ;
49772: LD_ADDR_VAR 0 5
49776: PUSH
49777: LD_INT 6
49779: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49780: LD_ADDR_EXP 81
49784: PUSH
49785: LD_EXP 81
49789: PPUSH
49790: LD_VAR 0 3
49794: PUSH
49795: LD_EXP 81
49799: PUSH
49800: LD_VAR 0 3
49804: ARRAY
49805: PUSH
49806: LD_INT 1
49808: PLUS
49809: PUSH
49810: EMPTY
49811: LIST
49812: LIST
49813: PPUSH
49814: LD_VAR 0 5
49818: PUSH
49819: LD_VAR 0 1
49823: PPUSH
49824: CALL_OW 250
49828: PUSH
49829: LD_VAR 0 1
49833: PPUSH
49834: CALL_OW 251
49838: PUSH
49839: LD_VAR 0 1
49843: PPUSH
49844: CALL_OW 254
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: PPUSH
49855: CALL 57045 0 3
49859: ST_TO_ADDR
// if pos = 1 then
49860: LD_VAR 0 6
49864: PUSH
49865: LD_INT 1
49867: EQUAL
49868: IFFALSE 49983
// begin tmp := mc_build_list [ i ] ;
49870: LD_ADDR_VAR 0 7
49874: PUSH
49875: LD_EXP 81
49879: PUSH
49880: LD_VAR 0 3
49884: ARRAY
49885: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
49886: LD_VAR 0 7
49890: PPUSH
49891: LD_INT 2
49893: PUSH
49894: LD_INT 30
49896: PUSH
49897: LD_INT 0
49899: PUSH
49900: EMPTY
49901: LIST
49902: LIST
49903: PUSH
49904: LD_INT 30
49906: PUSH
49907: LD_INT 1
49909: PUSH
49910: EMPTY
49911: LIST
49912: LIST
49913: PUSH
49914: EMPTY
49915: LIST
49916: LIST
49917: LIST
49918: PPUSH
49919: CALL_OW 72
49923: IFFALSE 49933
// pos := 2 ;
49925: LD_ADDR_VAR 0 6
49929: PUSH
49930: LD_INT 2
49932: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
49933: LD_ADDR_VAR 0 7
49937: PUSH
49938: LD_VAR 0 7
49942: PPUSH
49943: LD_VAR 0 6
49947: PPUSH
49948: LD_VAR 0 7
49952: PPUSH
49953: CALL 57371 0 3
49957: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
49958: LD_ADDR_EXP 81
49962: PUSH
49963: LD_EXP 81
49967: PPUSH
49968: LD_VAR 0 3
49972: PPUSH
49973: LD_VAR 0 7
49977: PPUSH
49978: CALL_OW 1
49982: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
49983: LD_VAR 0 1
49987: PUSH
49988: LD_EXP 76
49992: PUSH
49993: LD_VAR 0 3
49997: ARRAY
49998: IN
49999: IFFALSE 50038
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50001: LD_ADDR_EXP 76
50005: PUSH
50006: LD_EXP 76
50010: PPUSH
50011: LD_VAR 0 3
50015: PPUSH
50016: LD_EXP 76
50020: PUSH
50021: LD_VAR 0 3
50025: ARRAY
50026: PUSH
50027: LD_VAR 0 1
50031: DIFF
50032: PPUSH
50033: CALL_OW 1
50037: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50038: LD_VAR 0 1
50042: PUSH
50043: LD_EXP 83
50047: PUSH
50048: LD_VAR 0 3
50052: ARRAY
50053: IN
50054: IFFALSE 50093
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50056: LD_ADDR_EXP 83
50060: PUSH
50061: LD_EXP 83
50065: PPUSH
50066: LD_VAR 0 3
50070: PPUSH
50071: LD_EXP 83
50075: PUSH
50076: LD_VAR 0 3
50080: ARRAY
50081: PUSH
50082: LD_VAR 0 1
50086: DIFF
50087: PPUSH
50088: CALL_OW 1
50092: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50093: LD_VAR 0 1
50097: PUSH
50098: LD_EXP 95
50102: PUSH
50103: LD_VAR 0 3
50107: ARRAY
50108: IN
50109: IFFALSE 50148
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50111: LD_ADDR_EXP 95
50115: PUSH
50116: LD_EXP 95
50120: PPUSH
50121: LD_VAR 0 3
50125: PPUSH
50126: LD_EXP 95
50130: PUSH
50131: LD_VAR 0 3
50135: ARRAY
50136: PUSH
50137: LD_VAR 0 1
50141: DIFF
50142: PPUSH
50143: CALL_OW 1
50147: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50148: LD_VAR 0 1
50152: PUSH
50153: LD_EXP 98
50157: PUSH
50158: LD_VAR 0 3
50162: ARRAY
50163: IN
50164: IFFALSE 50203
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50166: LD_ADDR_EXP 98
50170: PUSH
50171: LD_EXP 98
50175: PPUSH
50176: LD_VAR 0 3
50180: PPUSH
50181: LD_EXP 98
50185: PUSH
50186: LD_VAR 0 3
50190: ARRAY
50191: PUSH
50192: LD_VAR 0 1
50196: DIFF
50197: PPUSH
50198: CALL_OW 1
50202: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50203: LD_VAR 0 1
50207: PUSH
50208: LD_EXP 85
50212: PUSH
50213: LD_VAR 0 3
50217: ARRAY
50218: IN
50219: IFFALSE 50258
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50221: LD_ADDR_EXP 85
50225: PUSH
50226: LD_EXP 85
50230: PPUSH
50231: LD_VAR 0 3
50235: PPUSH
50236: LD_EXP 85
50240: PUSH
50241: LD_VAR 0 3
50245: ARRAY
50246: PUSH
50247: LD_VAR 0 1
50251: DIFF
50252: PPUSH
50253: CALL_OW 1
50257: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50258: LD_VAR 0 1
50262: PUSH
50263: LD_EXP 84
50267: PUSH
50268: LD_VAR 0 3
50272: ARRAY
50273: IN
50274: IFFALSE 50313
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50276: LD_ADDR_EXP 84
50280: PUSH
50281: LD_EXP 84
50285: PPUSH
50286: LD_VAR 0 3
50290: PPUSH
50291: LD_EXP 84
50295: PUSH
50296: LD_VAR 0 3
50300: ARRAY
50301: PUSH
50302: LD_VAR 0 1
50306: DIFF
50307: PPUSH
50308: CALL_OW 1
50312: ST_TO_ADDR
// end ; break ;
50313: GO 50317
// end ;
50315: GO 48965
50317: POP
50318: POP
// end ;
50319: LD_VAR 0 2
50323: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50324: LD_INT 0
50326: PPUSH
50327: PPUSH
50328: PPUSH
// if not mc_bases or not skirmish then
50329: LD_EXP 76
50333: NOT
50334: PUSH
50335: LD_EXP 74
50339: NOT
50340: OR
50341: IFFALSE 50345
// exit ;
50343: GO 50560
// for i = 1 to mc_bases do
50345: LD_ADDR_VAR 0 3
50349: PUSH
50350: DOUBLE
50351: LD_INT 1
50353: DEC
50354: ST_TO_ADDR
50355: LD_EXP 76
50359: PUSH
50360: FOR_TO
50361: IFFALSE 50558
// begin if building in mc_construct_list [ i ] then
50363: LD_VAR 0 1
50367: PUSH
50368: LD_EXP 83
50372: PUSH
50373: LD_VAR 0 3
50377: ARRAY
50378: IN
50379: IFFALSE 50556
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50381: LD_ADDR_EXP 83
50385: PUSH
50386: LD_EXP 83
50390: PPUSH
50391: LD_VAR 0 3
50395: PPUSH
50396: LD_EXP 83
50400: PUSH
50401: LD_VAR 0 3
50405: ARRAY
50406: PUSH
50407: LD_VAR 0 1
50411: DIFF
50412: PPUSH
50413: CALL_OW 1
50417: ST_TO_ADDR
// if building in mc_lab [ i ] then
50418: LD_VAR 0 1
50422: PUSH
50423: LD_EXP 109
50427: PUSH
50428: LD_VAR 0 3
50432: ARRAY
50433: IN
50434: IFFALSE 50489
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50436: LD_ADDR_EXP 110
50440: PUSH
50441: LD_EXP 110
50445: PPUSH
50446: LD_VAR 0 3
50450: PPUSH
50451: LD_EXP 110
50455: PUSH
50456: LD_VAR 0 3
50460: ARRAY
50461: PPUSH
50462: LD_INT 1
50464: PPUSH
50465: LD_EXP 110
50469: PUSH
50470: LD_VAR 0 3
50474: ARRAY
50475: PPUSH
50476: LD_INT 0
50478: PPUSH
50479: CALL 56463 0 4
50483: PPUSH
50484: CALL_OW 1
50488: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50489: LD_VAR 0 1
50493: PUSH
50494: LD_EXP 76
50498: PUSH
50499: LD_VAR 0 3
50503: ARRAY
50504: IN
50505: NOT
50506: IFFALSE 50552
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50508: LD_ADDR_EXP 76
50512: PUSH
50513: LD_EXP 76
50517: PPUSH
50518: LD_VAR 0 3
50522: PUSH
50523: LD_EXP 76
50527: PUSH
50528: LD_VAR 0 3
50532: ARRAY
50533: PUSH
50534: LD_INT 1
50536: PLUS
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: PPUSH
50542: LD_VAR 0 1
50546: PPUSH
50547: CALL 57045 0 3
50551: ST_TO_ADDR
// exit ;
50552: POP
50553: POP
50554: GO 50560
// end ; end ;
50556: GO 50360
50558: POP
50559: POP
// end ;
50560: LD_VAR 0 2
50564: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50565: LD_INT 0
50567: PPUSH
50568: PPUSH
50569: PPUSH
50570: PPUSH
50571: PPUSH
50572: PPUSH
50573: PPUSH
// if not mc_bases or not skirmish then
50574: LD_EXP 76
50578: NOT
50579: PUSH
50580: LD_EXP 74
50584: NOT
50585: OR
50586: IFFALSE 50590
// exit ;
50588: GO 51251
// for i = 1 to mc_bases do
50590: LD_ADDR_VAR 0 3
50594: PUSH
50595: DOUBLE
50596: LD_INT 1
50598: DEC
50599: ST_TO_ADDR
50600: LD_EXP 76
50604: PUSH
50605: FOR_TO
50606: IFFALSE 51249
// begin if building in mc_construct_list [ i ] then
50608: LD_VAR 0 1
50612: PUSH
50613: LD_EXP 83
50617: PUSH
50618: LD_VAR 0 3
50622: ARRAY
50623: IN
50624: IFFALSE 51247
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50626: LD_ADDR_EXP 83
50630: PUSH
50631: LD_EXP 83
50635: PPUSH
50636: LD_VAR 0 3
50640: PPUSH
50641: LD_EXP 83
50645: PUSH
50646: LD_VAR 0 3
50650: ARRAY
50651: PUSH
50652: LD_VAR 0 1
50656: DIFF
50657: PPUSH
50658: CALL_OW 1
50662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50663: LD_ADDR_EXP 76
50667: PUSH
50668: LD_EXP 76
50672: PPUSH
50673: LD_VAR 0 3
50677: PUSH
50678: LD_EXP 76
50682: PUSH
50683: LD_VAR 0 3
50687: ARRAY
50688: PUSH
50689: LD_INT 1
50691: PLUS
50692: PUSH
50693: EMPTY
50694: LIST
50695: LIST
50696: PPUSH
50697: LD_VAR 0 1
50701: PPUSH
50702: CALL 57045 0 3
50706: ST_TO_ADDR
// btype := GetBType ( building ) ;
50707: LD_ADDR_VAR 0 5
50711: PUSH
50712: LD_VAR 0 1
50716: PPUSH
50717: CALL_OW 266
50721: ST_TO_ADDR
// side := GetSide ( building ) ;
50722: LD_ADDR_VAR 0 8
50726: PUSH
50727: LD_VAR 0 1
50731: PPUSH
50732: CALL_OW 255
50736: ST_TO_ADDR
// if btype = b_lab then
50737: LD_VAR 0 5
50741: PUSH
50742: LD_INT 6
50744: EQUAL
50745: IFFALSE 50795
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50747: LD_ADDR_EXP 109
50751: PUSH
50752: LD_EXP 109
50756: PPUSH
50757: LD_VAR 0 3
50761: PUSH
50762: LD_EXP 109
50766: PUSH
50767: LD_VAR 0 3
50771: ARRAY
50772: PUSH
50773: LD_INT 1
50775: PLUS
50776: PUSH
50777: EMPTY
50778: LIST
50779: LIST
50780: PPUSH
50781: LD_VAR 0 1
50785: PPUSH
50786: CALL 57045 0 3
50790: ST_TO_ADDR
// exit ;
50791: POP
50792: POP
50793: GO 51251
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50795: LD_VAR 0 5
50799: PUSH
50800: LD_INT 0
50802: PUSH
50803: LD_INT 2
50805: PUSH
50806: LD_INT 4
50808: PUSH
50809: EMPTY
50810: LIST
50811: LIST
50812: LIST
50813: IN
50814: IFFALSE 50938
// begin if btype = b_armoury then
50816: LD_VAR 0 5
50820: PUSH
50821: LD_INT 4
50823: EQUAL
50824: IFFALSE 50834
// btype := b_barracks ;
50826: LD_ADDR_VAR 0 5
50830: PUSH
50831: LD_INT 5
50833: ST_TO_ADDR
// if btype = b_depot then
50834: LD_VAR 0 5
50838: PUSH
50839: LD_INT 0
50841: EQUAL
50842: IFFALSE 50852
// btype := b_warehouse ;
50844: LD_ADDR_VAR 0 5
50848: PUSH
50849: LD_INT 1
50851: ST_TO_ADDR
// if btype = b_workshop then
50852: LD_VAR 0 5
50856: PUSH
50857: LD_INT 2
50859: EQUAL
50860: IFFALSE 50870
// btype := b_factory ;
50862: LD_ADDR_VAR 0 5
50866: PUSH
50867: LD_INT 3
50869: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50870: LD_VAR 0 5
50874: PPUSH
50875: LD_VAR 0 8
50879: PPUSH
50880: CALL_OW 323
50884: PUSH
50885: LD_INT 1
50887: EQUAL
50888: IFFALSE 50934
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
50890: LD_ADDR_EXP 108
50894: PUSH
50895: LD_EXP 108
50899: PPUSH
50900: LD_VAR 0 3
50904: PUSH
50905: LD_EXP 108
50909: PUSH
50910: LD_VAR 0 3
50914: ARRAY
50915: PUSH
50916: LD_INT 1
50918: PLUS
50919: PUSH
50920: EMPTY
50921: LIST
50922: LIST
50923: PPUSH
50924: LD_VAR 0 1
50928: PPUSH
50929: CALL 57045 0 3
50933: ST_TO_ADDR
// exit ;
50934: POP
50935: POP
50936: GO 51251
// end ; if btype in [ b_bunker , b_turret ] then
50938: LD_VAR 0 5
50942: PUSH
50943: LD_INT 32
50945: PUSH
50946: LD_INT 33
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: IN
50953: IFFALSE 51243
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
50955: LD_ADDR_EXP 84
50959: PUSH
50960: LD_EXP 84
50964: PPUSH
50965: LD_VAR 0 3
50969: PUSH
50970: LD_EXP 84
50974: PUSH
50975: LD_VAR 0 3
50979: ARRAY
50980: PUSH
50981: LD_INT 1
50983: PLUS
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: PPUSH
50989: LD_VAR 0 1
50993: PPUSH
50994: CALL 57045 0 3
50998: ST_TO_ADDR
// if btype = b_bunker then
50999: LD_VAR 0 5
51003: PUSH
51004: LD_INT 32
51006: EQUAL
51007: IFFALSE 51243
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51009: LD_ADDR_EXP 85
51013: PUSH
51014: LD_EXP 85
51018: PPUSH
51019: LD_VAR 0 3
51023: PUSH
51024: LD_EXP 85
51028: PUSH
51029: LD_VAR 0 3
51033: ARRAY
51034: PUSH
51035: LD_INT 1
51037: PLUS
51038: PUSH
51039: EMPTY
51040: LIST
51041: LIST
51042: PPUSH
51043: LD_VAR 0 1
51047: PPUSH
51048: CALL 57045 0 3
51052: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51053: LD_ADDR_VAR 0 6
51057: PUSH
51058: LD_EXP 76
51062: PUSH
51063: LD_VAR 0 3
51067: ARRAY
51068: PPUSH
51069: LD_INT 25
51071: PUSH
51072: LD_INT 1
51074: PUSH
51075: EMPTY
51076: LIST
51077: LIST
51078: PUSH
51079: LD_INT 3
51081: PUSH
51082: LD_INT 54
51084: PUSH
51085: EMPTY
51086: LIST
51087: PUSH
51088: EMPTY
51089: LIST
51090: LIST
51091: PUSH
51092: EMPTY
51093: LIST
51094: LIST
51095: PPUSH
51096: CALL_OW 72
51100: ST_TO_ADDR
// if tmp then
51101: LD_VAR 0 6
51105: IFFALSE 51111
// exit ;
51107: POP
51108: POP
51109: GO 51251
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51111: LD_ADDR_VAR 0 6
51115: PUSH
51116: LD_EXP 76
51120: PUSH
51121: LD_VAR 0 3
51125: ARRAY
51126: PPUSH
51127: LD_INT 2
51129: PUSH
51130: LD_INT 30
51132: PUSH
51133: LD_INT 4
51135: PUSH
51136: EMPTY
51137: LIST
51138: LIST
51139: PUSH
51140: LD_INT 30
51142: PUSH
51143: LD_INT 5
51145: PUSH
51146: EMPTY
51147: LIST
51148: LIST
51149: PUSH
51150: EMPTY
51151: LIST
51152: LIST
51153: LIST
51154: PPUSH
51155: CALL_OW 72
51159: ST_TO_ADDR
// if not tmp then
51160: LD_VAR 0 6
51164: NOT
51165: IFFALSE 51171
// exit ;
51167: POP
51168: POP
51169: GO 51251
// for j in tmp do
51171: LD_ADDR_VAR 0 4
51175: PUSH
51176: LD_VAR 0 6
51180: PUSH
51181: FOR_IN
51182: IFFALSE 51241
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51184: LD_ADDR_VAR 0 7
51188: PUSH
51189: LD_VAR 0 4
51193: PPUSH
51194: CALL_OW 313
51198: PPUSH
51199: LD_INT 25
51201: PUSH
51202: LD_INT 1
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PPUSH
51209: CALL_OW 72
51213: ST_TO_ADDR
// if units then
51214: LD_VAR 0 7
51218: IFFALSE 51239
// begin ComExitBuilding ( units [ 1 ] ) ;
51220: LD_VAR 0 7
51224: PUSH
51225: LD_INT 1
51227: ARRAY
51228: PPUSH
51229: CALL_OW 122
// exit ;
51233: POP
51234: POP
51235: POP
51236: POP
51237: GO 51251
// end ; end ;
51239: GO 51181
51241: POP
51242: POP
// end ; end ; exit ;
51243: POP
51244: POP
51245: GO 51251
// end ; end ;
51247: GO 50605
51249: POP
51250: POP
// end ;
51251: LD_VAR 0 2
51255: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51256: LD_INT 0
51258: PPUSH
51259: PPUSH
51260: PPUSH
51261: PPUSH
51262: PPUSH
51263: PPUSH
51264: PPUSH
// if not mc_bases or not skirmish then
51265: LD_EXP 76
51269: NOT
51270: PUSH
51271: LD_EXP 74
51275: NOT
51276: OR
51277: IFFALSE 51281
// exit ;
51279: GO 51546
// btype := GetBType ( building ) ;
51281: LD_ADDR_VAR 0 6
51285: PUSH
51286: LD_VAR 0 1
51290: PPUSH
51291: CALL_OW 266
51295: ST_TO_ADDR
// x := GetX ( building ) ;
51296: LD_ADDR_VAR 0 7
51300: PUSH
51301: LD_VAR 0 1
51305: PPUSH
51306: CALL_OW 250
51310: ST_TO_ADDR
// y := GetY ( building ) ;
51311: LD_ADDR_VAR 0 8
51315: PUSH
51316: LD_VAR 0 1
51320: PPUSH
51321: CALL_OW 251
51325: ST_TO_ADDR
// d := GetDir ( building ) ;
51326: LD_ADDR_VAR 0 9
51330: PUSH
51331: LD_VAR 0 1
51335: PPUSH
51336: CALL_OW 254
51340: ST_TO_ADDR
// for i = 1 to mc_bases do
51341: LD_ADDR_VAR 0 4
51345: PUSH
51346: DOUBLE
51347: LD_INT 1
51349: DEC
51350: ST_TO_ADDR
51351: LD_EXP 76
51355: PUSH
51356: FOR_TO
51357: IFFALSE 51544
// begin if not mc_build_list [ i ] then
51359: LD_EXP 81
51363: PUSH
51364: LD_VAR 0 4
51368: ARRAY
51369: NOT
51370: IFFALSE 51374
// continue ;
51372: GO 51356
// for j := 1 to mc_build_list [ i ] do
51374: LD_ADDR_VAR 0 5
51378: PUSH
51379: DOUBLE
51380: LD_INT 1
51382: DEC
51383: ST_TO_ADDR
51384: LD_EXP 81
51388: PUSH
51389: LD_VAR 0 4
51393: ARRAY
51394: PUSH
51395: FOR_TO
51396: IFFALSE 51540
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51398: LD_VAR 0 6
51402: PUSH
51403: LD_VAR 0 7
51407: PUSH
51408: LD_VAR 0 8
51412: PUSH
51413: LD_VAR 0 9
51417: PUSH
51418: EMPTY
51419: LIST
51420: LIST
51421: LIST
51422: LIST
51423: PPUSH
51424: LD_EXP 81
51428: PUSH
51429: LD_VAR 0 4
51433: ARRAY
51434: PUSH
51435: LD_VAR 0 5
51439: ARRAY
51440: PPUSH
51441: CALL 63225 0 2
51445: IFFALSE 51538
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51447: LD_ADDR_EXP 81
51451: PUSH
51452: LD_EXP 81
51456: PPUSH
51457: LD_VAR 0 4
51461: PPUSH
51462: LD_EXP 81
51466: PUSH
51467: LD_VAR 0 4
51471: ARRAY
51472: PPUSH
51473: LD_VAR 0 5
51477: PPUSH
51478: CALL_OW 3
51482: PPUSH
51483: CALL_OW 1
51487: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51488: LD_ADDR_EXP 83
51492: PUSH
51493: LD_EXP 83
51497: PPUSH
51498: LD_VAR 0 4
51502: PUSH
51503: LD_EXP 83
51507: PUSH
51508: LD_VAR 0 4
51512: ARRAY
51513: PUSH
51514: LD_INT 1
51516: PLUS
51517: PUSH
51518: EMPTY
51519: LIST
51520: LIST
51521: PPUSH
51522: LD_VAR 0 1
51526: PPUSH
51527: CALL 57045 0 3
51531: ST_TO_ADDR
// exit ;
51532: POP
51533: POP
51534: POP
51535: POP
51536: GO 51546
// end ;
51538: GO 51395
51540: POP
51541: POP
// end ;
51542: GO 51356
51544: POP
51545: POP
// end ;
51546: LD_VAR 0 3
51550: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51551: LD_INT 0
51553: PPUSH
51554: PPUSH
51555: PPUSH
// if not mc_bases or not skirmish then
51556: LD_EXP 76
51560: NOT
51561: PUSH
51562: LD_EXP 74
51566: NOT
51567: OR
51568: IFFALSE 51572
// exit ;
51570: GO 51762
// for i = 1 to mc_bases do
51572: LD_ADDR_VAR 0 4
51576: PUSH
51577: DOUBLE
51578: LD_INT 1
51580: DEC
51581: ST_TO_ADDR
51582: LD_EXP 76
51586: PUSH
51587: FOR_TO
51588: IFFALSE 51675
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51590: LD_VAR 0 1
51594: PUSH
51595: LD_EXP 84
51599: PUSH
51600: LD_VAR 0 4
51604: ARRAY
51605: IN
51606: PUSH
51607: LD_VAR 0 1
51611: PUSH
51612: LD_EXP 85
51616: PUSH
51617: LD_VAR 0 4
51621: ARRAY
51622: IN
51623: NOT
51624: AND
51625: IFFALSE 51673
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51627: LD_ADDR_EXP 85
51631: PUSH
51632: LD_EXP 85
51636: PPUSH
51637: LD_VAR 0 4
51641: PUSH
51642: LD_EXP 85
51646: PUSH
51647: LD_VAR 0 4
51651: ARRAY
51652: PUSH
51653: LD_INT 1
51655: PLUS
51656: PUSH
51657: EMPTY
51658: LIST
51659: LIST
51660: PPUSH
51661: LD_VAR 0 1
51665: PPUSH
51666: CALL 57045 0 3
51670: ST_TO_ADDR
// break ;
51671: GO 51675
// end ; end ;
51673: GO 51587
51675: POP
51676: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51677: LD_VAR 0 1
51681: PPUSH
51682: CALL_OW 257
51686: PUSH
51687: LD_EXP 102
51691: IN
51692: PUSH
51693: LD_VAR 0 1
51697: PPUSH
51698: CALL_OW 266
51702: PUSH
51703: LD_INT 5
51705: EQUAL
51706: AND
51707: PUSH
51708: LD_VAR 0 2
51712: PPUSH
51713: CALL_OW 110
51717: PUSH
51718: LD_INT 18
51720: NONEQUAL
51721: AND
51722: IFFALSE 51762
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51724: LD_VAR 0 2
51728: PPUSH
51729: CALL_OW 257
51733: PUSH
51734: LD_INT 5
51736: PUSH
51737: LD_INT 8
51739: PUSH
51740: LD_INT 9
51742: PUSH
51743: EMPTY
51744: LIST
51745: LIST
51746: LIST
51747: IN
51748: IFFALSE 51762
// SetClass ( unit , 1 ) ;
51750: LD_VAR 0 2
51754: PPUSH
51755: LD_INT 1
51757: PPUSH
51758: CALL_OW 336
// end ;
51762: LD_VAR 0 3
51766: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51767: LD_INT 0
51769: PPUSH
51770: PPUSH
// if not mc_bases or not skirmish then
51771: LD_EXP 76
51775: NOT
51776: PUSH
51777: LD_EXP 74
51781: NOT
51782: OR
51783: IFFALSE 51787
// exit ;
51785: GO 51903
// if GetLives ( abandoned_vehicle ) > 250 then
51787: LD_VAR 0 2
51791: PPUSH
51792: CALL_OW 256
51796: PUSH
51797: LD_INT 250
51799: GREATER
51800: IFFALSE 51804
// exit ;
51802: GO 51903
// for i = 1 to mc_bases do
51804: LD_ADDR_VAR 0 6
51808: PUSH
51809: DOUBLE
51810: LD_INT 1
51812: DEC
51813: ST_TO_ADDR
51814: LD_EXP 76
51818: PUSH
51819: FOR_TO
51820: IFFALSE 51901
// begin if driver in mc_bases [ i ] then
51822: LD_VAR 0 1
51826: PUSH
51827: LD_EXP 76
51831: PUSH
51832: LD_VAR 0 6
51836: ARRAY
51837: IN
51838: IFFALSE 51899
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51840: LD_VAR 0 1
51844: PPUSH
51845: LD_EXP 76
51849: PUSH
51850: LD_VAR 0 6
51854: ARRAY
51855: PPUSH
51856: LD_INT 2
51858: PUSH
51859: LD_INT 30
51861: PUSH
51862: LD_INT 0
51864: PUSH
51865: EMPTY
51866: LIST
51867: LIST
51868: PUSH
51869: LD_INT 30
51871: PUSH
51872: LD_INT 1
51874: PUSH
51875: EMPTY
51876: LIST
51877: LIST
51878: PUSH
51879: EMPTY
51880: LIST
51881: LIST
51882: LIST
51883: PPUSH
51884: CALL_OW 72
51888: PUSH
51889: LD_INT 1
51891: ARRAY
51892: PPUSH
51893: CALL 90234 0 2
// break ;
51897: GO 51901
// end ; end ;
51899: GO 51819
51901: POP
51902: POP
// end ; end_of_file
51903: LD_VAR 0 5
51907: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
51908: LD_INT 0
51910: PPUSH
51911: PPUSH
// if exist_mode then
51912: LD_VAR 0 2
51916: IFFALSE 51941
// unit := CreateCharacter ( prefix & ident ) else
51918: LD_ADDR_VAR 0 5
51922: PUSH
51923: LD_VAR 0 3
51927: PUSH
51928: LD_VAR 0 1
51932: STR
51933: PPUSH
51934: CALL_OW 34
51938: ST_TO_ADDR
51939: GO 51956
// unit := NewCharacter ( ident ) ;
51941: LD_ADDR_VAR 0 5
51945: PUSH
51946: LD_VAR 0 1
51950: PPUSH
51951: CALL_OW 25
51955: ST_TO_ADDR
// result := unit ;
51956: LD_ADDR_VAR 0 4
51960: PUSH
51961: LD_VAR 0 5
51965: ST_TO_ADDR
// end ;
51966: LD_VAR 0 4
51970: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
51971: LD_INT 0
51973: PPUSH
51974: PPUSH
// if not side or not nation then
51975: LD_VAR 0 1
51979: NOT
51980: PUSH
51981: LD_VAR 0 2
51985: NOT
51986: OR
51987: IFFALSE 51991
// exit ;
51989: GO 52759
// case nation of nation_american :
51991: LD_VAR 0 2
51995: PUSH
51996: LD_INT 1
51998: DOUBLE
51999: EQUAL
52000: IFTRUE 52004
52002: GO 52218
52004: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52005: LD_ADDR_VAR 0 4
52009: PUSH
52010: LD_INT 35
52012: PUSH
52013: LD_INT 45
52015: PUSH
52016: LD_INT 46
52018: PUSH
52019: LD_INT 47
52021: PUSH
52022: LD_INT 82
52024: PUSH
52025: LD_INT 83
52027: PUSH
52028: LD_INT 84
52030: PUSH
52031: LD_INT 85
52033: PUSH
52034: LD_INT 86
52036: PUSH
52037: LD_INT 1
52039: PUSH
52040: LD_INT 2
52042: PUSH
52043: LD_INT 6
52045: PUSH
52046: LD_INT 15
52048: PUSH
52049: LD_INT 16
52051: PUSH
52052: LD_INT 7
52054: PUSH
52055: LD_INT 12
52057: PUSH
52058: LD_INT 13
52060: PUSH
52061: LD_INT 10
52063: PUSH
52064: LD_INT 14
52066: PUSH
52067: LD_INT 20
52069: PUSH
52070: LD_INT 21
52072: PUSH
52073: LD_INT 22
52075: PUSH
52076: LD_INT 25
52078: PUSH
52079: LD_INT 32
52081: PUSH
52082: LD_INT 27
52084: PUSH
52085: LD_INT 36
52087: PUSH
52088: LD_INT 69
52090: PUSH
52091: LD_INT 39
52093: PUSH
52094: LD_INT 34
52096: PUSH
52097: LD_INT 40
52099: PUSH
52100: LD_INT 48
52102: PUSH
52103: LD_INT 49
52105: PUSH
52106: LD_INT 50
52108: PUSH
52109: LD_INT 51
52111: PUSH
52112: LD_INT 52
52114: PUSH
52115: LD_INT 53
52117: PUSH
52118: LD_INT 54
52120: PUSH
52121: LD_INT 55
52123: PUSH
52124: LD_INT 56
52126: PUSH
52127: LD_INT 57
52129: PUSH
52130: LD_INT 58
52132: PUSH
52133: LD_INT 59
52135: PUSH
52136: LD_INT 60
52138: PUSH
52139: LD_INT 61
52141: PUSH
52142: LD_INT 62
52144: PUSH
52145: LD_INT 80
52147: PUSH
52148: LD_INT 82
52150: PUSH
52151: LD_INT 83
52153: PUSH
52154: LD_INT 84
52156: PUSH
52157: LD_INT 85
52159: PUSH
52160: LD_INT 86
52162: PUSH
52163: EMPTY
52164: LIST
52165: LIST
52166: LIST
52167: LIST
52168: LIST
52169: LIST
52170: LIST
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: LIST
52176: LIST
52177: LIST
52178: LIST
52179: LIST
52180: LIST
52181: LIST
52182: LIST
52183: LIST
52184: LIST
52185: LIST
52186: LIST
52187: LIST
52188: LIST
52189: LIST
52190: LIST
52191: LIST
52192: LIST
52193: LIST
52194: LIST
52195: LIST
52196: LIST
52197: LIST
52198: LIST
52199: LIST
52200: LIST
52201: LIST
52202: LIST
52203: LIST
52204: LIST
52205: LIST
52206: LIST
52207: LIST
52208: LIST
52209: LIST
52210: LIST
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: ST_TO_ADDR
52216: GO 52683
52218: LD_INT 2
52220: DOUBLE
52221: EQUAL
52222: IFTRUE 52226
52224: GO 52452
52226: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52227: LD_ADDR_VAR 0 4
52231: PUSH
52232: LD_INT 35
52234: PUSH
52235: LD_INT 45
52237: PUSH
52238: LD_INT 46
52240: PUSH
52241: LD_INT 47
52243: PUSH
52244: LD_INT 82
52246: PUSH
52247: LD_INT 83
52249: PUSH
52250: LD_INT 84
52252: PUSH
52253: LD_INT 85
52255: PUSH
52256: LD_INT 87
52258: PUSH
52259: LD_INT 70
52261: PUSH
52262: LD_INT 1
52264: PUSH
52265: LD_INT 11
52267: PUSH
52268: LD_INT 3
52270: PUSH
52271: LD_INT 4
52273: PUSH
52274: LD_INT 5
52276: PUSH
52277: LD_INT 6
52279: PUSH
52280: LD_INT 15
52282: PUSH
52283: LD_INT 18
52285: PUSH
52286: LD_INT 7
52288: PUSH
52289: LD_INT 17
52291: PUSH
52292: LD_INT 8
52294: PUSH
52295: LD_INT 20
52297: PUSH
52298: LD_INT 21
52300: PUSH
52301: LD_INT 22
52303: PUSH
52304: LD_INT 72
52306: PUSH
52307: LD_INT 26
52309: PUSH
52310: LD_INT 69
52312: PUSH
52313: LD_INT 39
52315: PUSH
52316: LD_INT 40
52318: PUSH
52319: LD_INT 41
52321: PUSH
52322: LD_INT 42
52324: PUSH
52325: LD_INT 43
52327: PUSH
52328: LD_INT 48
52330: PUSH
52331: LD_INT 49
52333: PUSH
52334: LD_INT 50
52336: PUSH
52337: LD_INT 51
52339: PUSH
52340: LD_INT 52
52342: PUSH
52343: LD_INT 53
52345: PUSH
52346: LD_INT 54
52348: PUSH
52349: LD_INT 55
52351: PUSH
52352: LD_INT 56
52354: PUSH
52355: LD_INT 60
52357: PUSH
52358: LD_INT 61
52360: PUSH
52361: LD_INT 62
52363: PUSH
52364: LD_INT 66
52366: PUSH
52367: LD_INT 67
52369: PUSH
52370: LD_INT 68
52372: PUSH
52373: LD_INT 81
52375: PUSH
52376: LD_INT 82
52378: PUSH
52379: LD_INT 83
52381: PUSH
52382: LD_INT 84
52384: PUSH
52385: LD_INT 85
52387: PUSH
52388: LD_INT 87
52390: PUSH
52391: LD_INT 88
52393: PUSH
52394: EMPTY
52395: LIST
52396: LIST
52397: LIST
52398: LIST
52399: LIST
52400: LIST
52401: LIST
52402: LIST
52403: LIST
52404: LIST
52405: LIST
52406: LIST
52407: LIST
52408: LIST
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: LIST
52414: LIST
52415: LIST
52416: LIST
52417: LIST
52418: LIST
52419: LIST
52420: LIST
52421: LIST
52422: LIST
52423: LIST
52424: LIST
52425: LIST
52426: LIST
52427: LIST
52428: LIST
52429: LIST
52430: LIST
52431: LIST
52432: LIST
52433: LIST
52434: LIST
52435: LIST
52436: LIST
52437: LIST
52438: LIST
52439: LIST
52440: LIST
52441: LIST
52442: LIST
52443: LIST
52444: LIST
52445: LIST
52446: LIST
52447: LIST
52448: LIST
52449: ST_TO_ADDR
52450: GO 52683
52452: LD_INT 3
52454: DOUBLE
52455: EQUAL
52456: IFTRUE 52460
52458: GO 52682
52460: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52461: LD_ADDR_VAR 0 4
52465: PUSH
52466: LD_INT 46
52468: PUSH
52469: LD_INT 47
52471: PUSH
52472: LD_INT 1
52474: PUSH
52475: LD_INT 2
52477: PUSH
52478: LD_INT 82
52480: PUSH
52481: LD_INT 83
52483: PUSH
52484: LD_INT 84
52486: PUSH
52487: LD_INT 85
52489: PUSH
52490: LD_INT 86
52492: PUSH
52493: LD_INT 11
52495: PUSH
52496: LD_INT 9
52498: PUSH
52499: LD_INT 20
52501: PUSH
52502: LD_INT 19
52504: PUSH
52505: LD_INT 21
52507: PUSH
52508: LD_INT 24
52510: PUSH
52511: LD_INT 22
52513: PUSH
52514: LD_INT 25
52516: PUSH
52517: LD_INT 28
52519: PUSH
52520: LD_INT 29
52522: PUSH
52523: LD_INT 30
52525: PUSH
52526: LD_INT 31
52528: PUSH
52529: LD_INT 37
52531: PUSH
52532: LD_INT 38
52534: PUSH
52535: LD_INT 32
52537: PUSH
52538: LD_INT 27
52540: PUSH
52541: LD_INT 33
52543: PUSH
52544: LD_INT 69
52546: PUSH
52547: LD_INT 39
52549: PUSH
52550: LD_INT 34
52552: PUSH
52553: LD_INT 40
52555: PUSH
52556: LD_INT 71
52558: PUSH
52559: LD_INT 23
52561: PUSH
52562: LD_INT 44
52564: PUSH
52565: LD_INT 48
52567: PUSH
52568: LD_INT 49
52570: PUSH
52571: LD_INT 50
52573: PUSH
52574: LD_INT 51
52576: PUSH
52577: LD_INT 52
52579: PUSH
52580: LD_INT 53
52582: PUSH
52583: LD_INT 54
52585: PUSH
52586: LD_INT 55
52588: PUSH
52589: LD_INT 56
52591: PUSH
52592: LD_INT 57
52594: PUSH
52595: LD_INT 58
52597: PUSH
52598: LD_INT 59
52600: PUSH
52601: LD_INT 63
52603: PUSH
52604: LD_INT 64
52606: PUSH
52607: LD_INT 65
52609: PUSH
52610: LD_INT 82
52612: PUSH
52613: LD_INT 83
52615: PUSH
52616: LD_INT 84
52618: PUSH
52619: LD_INT 85
52621: PUSH
52622: LD_INT 86
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: LIST
52629: LIST
52630: LIST
52631: LIST
52632: LIST
52633: LIST
52634: LIST
52635: LIST
52636: LIST
52637: LIST
52638: LIST
52639: LIST
52640: LIST
52641: LIST
52642: LIST
52643: LIST
52644: LIST
52645: LIST
52646: LIST
52647: LIST
52648: LIST
52649: LIST
52650: LIST
52651: LIST
52652: LIST
52653: LIST
52654: LIST
52655: LIST
52656: LIST
52657: LIST
52658: LIST
52659: LIST
52660: LIST
52661: LIST
52662: LIST
52663: LIST
52664: LIST
52665: LIST
52666: LIST
52667: LIST
52668: LIST
52669: LIST
52670: LIST
52671: LIST
52672: LIST
52673: LIST
52674: LIST
52675: LIST
52676: LIST
52677: LIST
52678: LIST
52679: ST_TO_ADDR
52680: GO 52683
52682: POP
// if state > - 1 and state < 3 then
52683: LD_VAR 0 3
52687: PUSH
52688: LD_INT 1
52690: NEG
52691: GREATER
52692: PUSH
52693: LD_VAR 0 3
52697: PUSH
52698: LD_INT 3
52700: LESS
52701: AND
52702: IFFALSE 52759
// for i in result do
52704: LD_ADDR_VAR 0 5
52708: PUSH
52709: LD_VAR 0 4
52713: PUSH
52714: FOR_IN
52715: IFFALSE 52757
// if GetTech ( i , side ) <> state then
52717: LD_VAR 0 5
52721: PPUSH
52722: LD_VAR 0 1
52726: PPUSH
52727: CALL_OW 321
52731: PUSH
52732: LD_VAR 0 3
52736: NONEQUAL
52737: IFFALSE 52755
// result := result diff i ;
52739: LD_ADDR_VAR 0 4
52743: PUSH
52744: LD_VAR 0 4
52748: PUSH
52749: LD_VAR 0 5
52753: DIFF
52754: ST_TO_ADDR
52755: GO 52714
52757: POP
52758: POP
// end ;
52759: LD_VAR 0 4
52763: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52764: LD_INT 0
52766: PPUSH
52767: PPUSH
52768: PPUSH
// result := true ;
52769: LD_ADDR_VAR 0 3
52773: PUSH
52774: LD_INT 1
52776: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52777: LD_ADDR_VAR 0 5
52781: PUSH
52782: LD_VAR 0 2
52786: PPUSH
52787: CALL_OW 480
52791: ST_TO_ADDR
// if not tmp then
52792: LD_VAR 0 5
52796: NOT
52797: IFFALSE 52801
// exit ;
52799: GO 52850
// for i in tmp do
52801: LD_ADDR_VAR 0 4
52805: PUSH
52806: LD_VAR 0 5
52810: PUSH
52811: FOR_IN
52812: IFFALSE 52848
// if GetTech ( i , side ) <> state_researched then
52814: LD_VAR 0 4
52818: PPUSH
52819: LD_VAR 0 1
52823: PPUSH
52824: CALL_OW 321
52828: PUSH
52829: LD_INT 2
52831: NONEQUAL
52832: IFFALSE 52846
// begin result := false ;
52834: LD_ADDR_VAR 0 3
52838: PUSH
52839: LD_INT 0
52841: ST_TO_ADDR
// exit ;
52842: POP
52843: POP
52844: GO 52850
// end ;
52846: GO 52811
52848: POP
52849: POP
// end ;
52850: LD_VAR 0 3
52854: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52855: LD_INT 0
52857: PPUSH
52858: PPUSH
52859: PPUSH
52860: PPUSH
52861: PPUSH
52862: PPUSH
52863: PPUSH
52864: PPUSH
52865: PPUSH
52866: PPUSH
52867: PPUSH
52868: PPUSH
52869: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52870: LD_VAR 0 1
52874: NOT
52875: PUSH
52876: LD_VAR 0 1
52880: PPUSH
52881: CALL_OW 257
52885: PUSH
52886: LD_INT 9
52888: NONEQUAL
52889: OR
52890: IFFALSE 52894
// exit ;
52892: GO 53467
// side := GetSide ( unit ) ;
52894: LD_ADDR_VAR 0 9
52898: PUSH
52899: LD_VAR 0 1
52903: PPUSH
52904: CALL_OW 255
52908: ST_TO_ADDR
// tech_space := tech_spacanom ;
52909: LD_ADDR_VAR 0 12
52913: PUSH
52914: LD_INT 29
52916: ST_TO_ADDR
// tech_time := tech_taurad ;
52917: LD_ADDR_VAR 0 13
52921: PUSH
52922: LD_INT 28
52924: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
52925: LD_ADDR_VAR 0 11
52929: PUSH
52930: LD_VAR 0 1
52934: PPUSH
52935: CALL_OW 310
52939: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
52940: LD_VAR 0 11
52944: PPUSH
52945: CALL_OW 247
52949: PUSH
52950: LD_INT 2
52952: EQUAL
52953: IFFALSE 52957
// exit ;
52955: GO 53467
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
52957: LD_ADDR_VAR 0 8
52961: PUSH
52962: LD_INT 81
52964: PUSH
52965: LD_VAR 0 9
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: PUSH
52974: LD_INT 3
52976: PUSH
52977: LD_INT 21
52979: PUSH
52980: LD_INT 3
52982: PUSH
52983: EMPTY
52984: LIST
52985: LIST
52986: PUSH
52987: EMPTY
52988: LIST
52989: LIST
52990: PUSH
52991: EMPTY
52992: LIST
52993: LIST
52994: PPUSH
52995: CALL_OW 69
52999: ST_TO_ADDR
// if not tmp then
53000: LD_VAR 0 8
53004: NOT
53005: IFFALSE 53009
// exit ;
53007: GO 53467
// if in_unit then
53009: LD_VAR 0 11
53013: IFFALSE 53037
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53015: LD_ADDR_VAR 0 10
53019: PUSH
53020: LD_VAR 0 8
53024: PPUSH
53025: LD_VAR 0 11
53029: PPUSH
53030: CALL_OW 74
53034: ST_TO_ADDR
53035: GO 53057
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53037: LD_ADDR_VAR 0 10
53041: PUSH
53042: LD_VAR 0 8
53046: PPUSH
53047: LD_VAR 0 1
53051: PPUSH
53052: CALL_OW 74
53056: ST_TO_ADDR
// if not enemy then
53057: LD_VAR 0 10
53061: NOT
53062: IFFALSE 53066
// exit ;
53064: GO 53467
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53066: LD_VAR 0 11
53070: PUSH
53071: LD_VAR 0 11
53075: PPUSH
53076: LD_VAR 0 10
53080: PPUSH
53081: CALL_OW 296
53085: PUSH
53086: LD_INT 13
53088: GREATER
53089: AND
53090: PUSH
53091: LD_VAR 0 1
53095: PPUSH
53096: LD_VAR 0 10
53100: PPUSH
53101: CALL_OW 296
53105: PUSH
53106: LD_INT 12
53108: GREATER
53109: OR
53110: IFFALSE 53114
// exit ;
53112: GO 53467
// missile := [ 1 ] ;
53114: LD_ADDR_VAR 0 14
53118: PUSH
53119: LD_INT 1
53121: PUSH
53122: EMPTY
53123: LIST
53124: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53125: LD_VAR 0 9
53129: PPUSH
53130: LD_VAR 0 12
53134: PPUSH
53135: CALL_OW 325
53139: IFFALSE 53168
// missile := Replace ( missile , missile + 1 , 2 ) ;
53141: LD_ADDR_VAR 0 14
53145: PUSH
53146: LD_VAR 0 14
53150: PPUSH
53151: LD_VAR 0 14
53155: PUSH
53156: LD_INT 1
53158: PLUS
53159: PPUSH
53160: LD_INT 2
53162: PPUSH
53163: CALL_OW 1
53167: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53168: LD_VAR 0 9
53172: PPUSH
53173: LD_VAR 0 13
53177: PPUSH
53178: CALL_OW 325
53182: PUSH
53183: LD_VAR 0 10
53187: PPUSH
53188: CALL_OW 255
53192: PPUSH
53193: LD_VAR 0 13
53197: PPUSH
53198: CALL_OW 325
53202: NOT
53203: AND
53204: IFFALSE 53233
// missile := Replace ( missile , missile + 1 , 3 ) ;
53206: LD_ADDR_VAR 0 14
53210: PUSH
53211: LD_VAR 0 14
53215: PPUSH
53216: LD_VAR 0 14
53220: PUSH
53221: LD_INT 1
53223: PLUS
53224: PPUSH
53225: LD_INT 3
53227: PPUSH
53228: CALL_OW 1
53232: ST_TO_ADDR
// if missile < 2 then
53233: LD_VAR 0 14
53237: PUSH
53238: LD_INT 2
53240: LESS
53241: IFFALSE 53245
// exit ;
53243: GO 53467
// x := GetX ( enemy ) ;
53245: LD_ADDR_VAR 0 4
53249: PUSH
53250: LD_VAR 0 10
53254: PPUSH
53255: CALL_OW 250
53259: ST_TO_ADDR
// y := GetY ( enemy ) ;
53260: LD_ADDR_VAR 0 5
53264: PUSH
53265: LD_VAR 0 10
53269: PPUSH
53270: CALL_OW 251
53274: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53275: LD_ADDR_VAR 0 6
53279: PUSH
53280: LD_VAR 0 4
53284: PUSH
53285: LD_INT 1
53287: NEG
53288: PPUSH
53289: LD_INT 1
53291: PPUSH
53292: CALL_OW 12
53296: PLUS
53297: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53298: LD_ADDR_VAR 0 7
53302: PUSH
53303: LD_VAR 0 5
53307: PUSH
53308: LD_INT 1
53310: NEG
53311: PPUSH
53312: LD_INT 1
53314: PPUSH
53315: CALL_OW 12
53319: PLUS
53320: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53321: LD_VAR 0 6
53325: PPUSH
53326: LD_VAR 0 7
53330: PPUSH
53331: CALL_OW 488
53335: NOT
53336: IFFALSE 53358
// begin _x := x ;
53338: LD_ADDR_VAR 0 6
53342: PUSH
53343: LD_VAR 0 4
53347: ST_TO_ADDR
// _y := y ;
53348: LD_ADDR_VAR 0 7
53352: PUSH
53353: LD_VAR 0 5
53357: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53358: LD_ADDR_VAR 0 3
53362: PUSH
53363: LD_INT 1
53365: PPUSH
53366: LD_VAR 0 14
53370: PPUSH
53371: CALL_OW 12
53375: ST_TO_ADDR
// case i of 1 :
53376: LD_VAR 0 3
53380: PUSH
53381: LD_INT 1
53383: DOUBLE
53384: EQUAL
53385: IFTRUE 53389
53387: GO 53406
53389: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53390: LD_VAR 0 1
53394: PPUSH
53395: LD_VAR 0 10
53399: PPUSH
53400: CALL_OW 115
53404: GO 53467
53406: LD_INT 2
53408: DOUBLE
53409: EQUAL
53410: IFTRUE 53414
53412: GO 53436
53414: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53415: LD_VAR 0 1
53419: PPUSH
53420: LD_VAR 0 6
53424: PPUSH
53425: LD_VAR 0 7
53429: PPUSH
53430: CALL_OW 153
53434: GO 53467
53436: LD_INT 3
53438: DOUBLE
53439: EQUAL
53440: IFTRUE 53444
53442: GO 53466
53444: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53445: LD_VAR 0 1
53449: PPUSH
53450: LD_VAR 0 6
53454: PPUSH
53455: LD_VAR 0 7
53459: PPUSH
53460: CALL_OW 154
53464: GO 53467
53466: POP
// end ;
53467: LD_VAR 0 2
53471: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53472: LD_INT 0
53474: PPUSH
53475: PPUSH
53476: PPUSH
53477: PPUSH
53478: PPUSH
53479: PPUSH
// if not unit or not building then
53480: LD_VAR 0 1
53484: NOT
53485: PUSH
53486: LD_VAR 0 2
53490: NOT
53491: OR
53492: IFFALSE 53496
// exit ;
53494: GO 53654
// x := GetX ( building ) ;
53496: LD_ADDR_VAR 0 5
53500: PUSH
53501: LD_VAR 0 2
53505: PPUSH
53506: CALL_OW 250
53510: ST_TO_ADDR
// y := GetY ( building ) ;
53511: LD_ADDR_VAR 0 6
53515: PUSH
53516: LD_VAR 0 2
53520: PPUSH
53521: CALL_OW 251
53525: ST_TO_ADDR
// for i = 0 to 5 do
53526: LD_ADDR_VAR 0 4
53530: PUSH
53531: DOUBLE
53532: LD_INT 0
53534: DEC
53535: ST_TO_ADDR
53536: LD_INT 5
53538: PUSH
53539: FOR_TO
53540: IFFALSE 53652
// begin _x := ShiftX ( x , i , 3 ) ;
53542: LD_ADDR_VAR 0 7
53546: PUSH
53547: LD_VAR 0 5
53551: PPUSH
53552: LD_VAR 0 4
53556: PPUSH
53557: LD_INT 3
53559: PPUSH
53560: CALL_OW 272
53564: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53565: LD_ADDR_VAR 0 8
53569: PUSH
53570: LD_VAR 0 6
53574: PPUSH
53575: LD_VAR 0 4
53579: PPUSH
53580: LD_INT 3
53582: PPUSH
53583: CALL_OW 273
53587: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53588: LD_VAR 0 7
53592: PPUSH
53593: LD_VAR 0 8
53597: PPUSH
53598: CALL_OW 488
53602: NOT
53603: IFFALSE 53607
// continue ;
53605: GO 53539
// if HexInfo ( _x , _y ) = 0 then
53607: LD_VAR 0 7
53611: PPUSH
53612: LD_VAR 0 8
53616: PPUSH
53617: CALL_OW 428
53621: PUSH
53622: LD_INT 0
53624: EQUAL
53625: IFFALSE 53650
// begin ComMoveXY ( unit , _x , _y ) ;
53627: LD_VAR 0 1
53631: PPUSH
53632: LD_VAR 0 7
53636: PPUSH
53637: LD_VAR 0 8
53641: PPUSH
53642: CALL_OW 111
// exit ;
53646: POP
53647: POP
53648: GO 53654
// end ; end ;
53650: GO 53539
53652: POP
53653: POP
// end ;
53654: LD_VAR 0 3
53658: RET
// export function ScanBase ( side , base_area ) ; begin
53659: LD_INT 0
53661: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53662: LD_ADDR_VAR 0 3
53666: PUSH
53667: LD_VAR 0 2
53671: PPUSH
53672: LD_INT 81
53674: PUSH
53675: LD_VAR 0 1
53679: PUSH
53680: EMPTY
53681: LIST
53682: LIST
53683: PPUSH
53684: CALL_OW 70
53688: ST_TO_ADDR
// end ;
53689: LD_VAR 0 3
53693: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53694: LD_INT 0
53696: PPUSH
53697: PPUSH
53698: PPUSH
53699: PPUSH
// result := false ;
53700: LD_ADDR_VAR 0 2
53704: PUSH
53705: LD_INT 0
53707: ST_TO_ADDR
// side := GetSide ( unit ) ;
53708: LD_ADDR_VAR 0 3
53712: PUSH
53713: LD_VAR 0 1
53717: PPUSH
53718: CALL_OW 255
53722: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53723: LD_ADDR_VAR 0 4
53727: PUSH
53728: LD_VAR 0 1
53732: PPUSH
53733: CALL_OW 248
53737: ST_TO_ADDR
// case nat of 1 :
53738: LD_VAR 0 4
53742: PUSH
53743: LD_INT 1
53745: DOUBLE
53746: EQUAL
53747: IFTRUE 53751
53749: GO 53762
53751: POP
// tech := tech_lassight ; 2 :
53752: LD_ADDR_VAR 0 5
53756: PUSH
53757: LD_INT 12
53759: ST_TO_ADDR
53760: GO 53801
53762: LD_INT 2
53764: DOUBLE
53765: EQUAL
53766: IFTRUE 53770
53768: GO 53781
53770: POP
// tech := tech_mortar ; 3 :
53771: LD_ADDR_VAR 0 5
53775: PUSH
53776: LD_INT 41
53778: ST_TO_ADDR
53779: GO 53801
53781: LD_INT 3
53783: DOUBLE
53784: EQUAL
53785: IFTRUE 53789
53787: GO 53800
53789: POP
// tech := tech_bazooka ; end ;
53790: LD_ADDR_VAR 0 5
53794: PUSH
53795: LD_INT 44
53797: ST_TO_ADDR
53798: GO 53801
53800: POP
// if Researched ( side , tech ) then
53801: LD_VAR 0 3
53805: PPUSH
53806: LD_VAR 0 5
53810: PPUSH
53811: CALL_OW 325
53815: IFFALSE 53842
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53817: LD_ADDR_VAR 0 2
53821: PUSH
53822: LD_INT 5
53824: PUSH
53825: LD_INT 8
53827: PUSH
53828: LD_INT 9
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: LIST
53835: PUSH
53836: LD_VAR 0 4
53840: ARRAY
53841: ST_TO_ADDR
// end ;
53842: LD_VAR 0 2
53846: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53847: LD_INT 0
53849: PPUSH
53850: PPUSH
53851: PPUSH
// if not mines then
53852: LD_VAR 0 2
53856: NOT
53857: IFFALSE 53861
// exit ;
53859: GO 54005
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53861: LD_ADDR_VAR 0 5
53865: PUSH
53866: LD_INT 81
53868: PUSH
53869: LD_VAR 0 1
53873: PUSH
53874: EMPTY
53875: LIST
53876: LIST
53877: PUSH
53878: LD_INT 3
53880: PUSH
53881: LD_INT 21
53883: PUSH
53884: LD_INT 3
53886: PUSH
53887: EMPTY
53888: LIST
53889: LIST
53890: PUSH
53891: EMPTY
53892: LIST
53893: LIST
53894: PUSH
53895: EMPTY
53896: LIST
53897: LIST
53898: PPUSH
53899: CALL_OW 69
53903: ST_TO_ADDR
// for i in mines do
53904: LD_ADDR_VAR 0 4
53908: PUSH
53909: LD_VAR 0 2
53913: PUSH
53914: FOR_IN
53915: IFFALSE 54003
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
53917: LD_VAR 0 4
53921: PUSH
53922: LD_INT 1
53924: ARRAY
53925: PPUSH
53926: LD_VAR 0 4
53930: PUSH
53931: LD_INT 2
53933: ARRAY
53934: PPUSH
53935: CALL_OW 458
53939: NOT
53940: IFFALSE 53944
// continue ;
53942: GO 53914
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
53944: LD_VAR 0 4
53948: PUSH
53949: LD_INT 1
53951: ARRAY
53952: PPUSH
53953: LD_VAR 0 4
53957: PUSH
53958: LD_INT 2
53960: ARRAY
53961: PPUSH
53962: CALL_OW 428
53966: PUSH
53967: LD_VAR 0 5
53971: IN
53972: IFFALSE 54001
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
53974: LD_VAR 0 4
53978: PUSH
53979: LD_INT 1
53981: ARRAY
53982: PPUSH
53983: LD_VAR 0 4
53987: PUSH
53988: LD_INT 2
53990: ARRAY
53991: PPUSH
53992: LD_VAR 0 1
53996: PPUSH
53997: CALL_OW 456
// end ;
54001: GO 53914
54003: POP
54004: POP
// end ;
54005: LD_VAR 0 3
54009: RET
// export function Count ( array ) ; var i ; begin
54010: LD_INT 0
54012: PPUSH
54013: PPUSH
// result := 0 ;
54014: LD_ADDR_VAR 0 2
54018: PUSH
54019: LD_INT 0
54021: ST_TO_ADDR
// for i in array do
54022: LD_ADDR_VAR 0 3
54026: PUSH
54027: LD_VAR 0 1
54031: PUSH
54032: FOR_IN
54033: IFFALSE 54057
// if i then
54035: LD_VAR 0 3
54039: IFFALSE 54055
// result := result + 1 ;
54041: LD_ADDR_VAR 0 2
54045: PUSH
54046: LD_VAR 0 2
54050: PUSH
54051: LD_INT 1
54053: PLUS
54054: ST_TO_ADDR
54055: GO 54032
54057: POP
54058: POP
// end ;
54059: LD_VAR 0 2
54063: RET
// export function IsEmpty ( building ) ; begin
54064: LD_INT 0
54066: PPUSH
// if not building then
54067: LD_VAR 0 1
54071: NOT
54072: IFFALSE 54076
// exit ;
54074: GO 54119
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54076: LD_ADDR_VAR 0 2
54080: PUSH
54081: LD_VAR 0 1
54085: PUSH
54086: LD_INT 22
54088: PUSH
54089: LD_VAR 0 1
54093: PPUSH
54094: CALL_OW 255
54098: PUSH
54099: EMPTY
54100: LIST
54101: LIST
54102: PUSH
54103: LD_INT 58
54105: PUSH
54106: EMPTY
54107: LIST
54108: PUSH
54109: EMPTY
54110: LIST
54111: LIST
54112: PPUSH
54113: CALL_OW 69
54117: IN
54118: ST_TO_ADDR
// end ;
54119: LD_VAR 0 2
54123: RET
// export function IsNotFull ( building ) ; var places ; begin
54124: LD_INT 0
54126: PPUSH
54127: PPUSH
// if not building then
54128: LD_VAR 0 1
54132: NOT
54133: IFFALSE 54137
// exit ;
54135: GO 54308
// result := false ;
54137: LD_ADDR_VAR 0 2
54141: PUSH
54142: LD_INT 0
54144: ST_TO_ADDR
// places := 0 ;
54145: LD_ADDR_VAR 0 3
54149: PUSH
54150: LD_INT 0
54152: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
54153: LD_VAR 0 1
54157: PPUSH
54158: CALL_OW 266
54162: PUSH
54163: LD_INT 0
54165: DOUBLE
54166: EQUAL
54167: IFTRUE 54225
54169: LD_INT 1
54171: DOUBLE
54172: EQUAL
54173: IFTRUE 54225
54175: LD_INT 6
54177: DOUBLE
54178: EQUAL
54179: IFTRUE 54225
54181: LD_INT 7
54183: DOUBLE
54184: EQUAL
54185: IFTRUE 54225
54187: LD_INT 8
54189: DOUBLE
54190: EQUAL
54191: IFTRUE 54225
54193: LD_INT 4
54195: DOUBLE
54196: EQUAL
54197: IFTRUE 54225
54199: LD_INT 5
54201: DOUBLE
54202: EQUAL
54203: IFTRUE 54225
54205: LD_INT 2
54207: DOUBLE
54208: EQUAL
54209: IFTRUE 54225
54211: LD_INT 3
54213: DOUBLE
54214: EQUAL
54215: IFTRUE 54225
54217: LD_INT 35
54219: DOUBLE
54220: EQUAL
54221: IFTRUE 54225
54223: GO 54236
54225: POP
// places := 6 ; b_bunker , b_breastwork :
54226: LD_ADDR_VAR 0 3
54230: PUSH
54231: LD_INT 6
54233: ST_TO_ADDR
54234: GO 54281
54236: LD_INT 32
54238: DOUBLE
54239: EQUAL
54240: IFTRUE 54250
54242: LD_INT 31
54244: DOUBLE
54245: EQUAL
54246: IFTRUE 54250
54248: GO 54261
54250: POP
// places := 1 ; b_control_tower :
54251: LD_ADDR_VAR 0 3
54255: PUSH
54256: LD_INT 1
54258: ST_TO_ADDR
54259: GO 54281
54261: LD_INT 36
54263: DOUBLE
54264: EQUAL
54265: IFTRUE 54269
54267: GO 54280
54269: POP
// places := 3 ; end ;
54270: LD_ADDR_VAR 0 3
54274: PUSH
54275: LD_INT 3
54277: ST_TO_ADDR
54278: GO 54281
54280: POP
// if places then
54281: LD_VAR 0 3
54285: IFFALSE 54308
// result := UnitsInside ( building ) < places ;
54287: LD_ADDR_VAR 0 2
54291: PUSH
54292: LD_VAR 0 1
54296: PPUSH
54297: CALL_OW 313
54301: PUSH
54302: LD_VAR 0 3
54306: LESS
54307: ST_TO_ADDR
// end ;
54308: LD_VAR 0 2
54312: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54313: LD_INT 0
54315: PPUSH
54316: PPUSH
54317: PPUSH
54318: PPUSH
// tmp := [ ] ;
54319: LD_ADDR_VAR 0 3
54323: PUSH
54324: EMPTY
54325: ST_TO_ADDR
// list := [ ] ;
54326: LD_ADDR_VAR 0 5
54330: PUSH
54331: EMPTY
54332: ST_TO_ADDR
// for i = 16 to 25 do
54333: LD_ADDR_VAR 0 4
54337: PUSH
54338: DOUBLE
54339: LD_INT 16
54341: DEC
54342: ST_TO_ADDR
54343: LD_INT 25
54345: PUSH
54346: FOR_TO
54347: IFFALSE 54420
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54349: LD_ADDR_VAR 0 3
54353: PUSH
54354: LD_VAR 0 3
54358: PUSH
54359: LD_INT 22
54361: PUSH
54362: LD_VAR 0 1
54366: PPUSH
54367: CALL_OW 255
54371: PUSH
54372: EMPTY
54373: LIST
54374: LIST
54375: PUSH
54376: LD_INT 91
54378: PUSH
54379: LD_VAR 0 1
54383: PUSH
54384: LD_INT 6
54386: PUSH
54387: EMPTY
54388: LIST
54389: LIST
54390: LIST
54391: PUSH
54392: LD_INT 30
54394: PUSH
54395: LD_VAR 0 4
54399: PUSH
54400: EMPTY
54401: LIST
54402: LIST
54403: PUSH
54404: EMPTY
54405: LIST
54406: LIST
54407: LIST
54408: PUSH
54409: EMPTY
54410: LIST
54411: PPUSH
54412: CALL_OW 69
54416: ADD
54417: ST_TO_ADDR
54418: GO 54346
54420: POP
54421: POP
// for i = 1 to tmp do
54422: LD_ADDR_VAR 0 4
54426: PUSH
54427: DOUBLE
54428: LD_INT 1
54430: DEC
54431: ST_TO_ADDR
54432: LD_VAR 0 3
54436: PUSH
54437: FOR_TO
54438: IFFALSE 54526
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54440: LD_ADDR_VAR 0 5
54444: PUSH
54445: LD_VAR 0 5
54449: PUSH
54450: LD_VAR 0 3
54454: PUSH
54455: LD_VAR 0 4
54459: ARRAY
54460: PPUSH
54461: CALL_OW 266
54465: PUSH
54466: LD_VAR 0 3
54470: PUSH
54471: LD_VAR 0 4
54475: ARRAY
54476: PPUSH
54477: CALL_OW 250
54481: PUSH
54482: LD_VAR 0 3
54486: PUSH
54487: LD_VAR 0 4
54491: ARRAY
54492: PPUSH
54493: CALL_OW 251
54497: PUSH
54498: LD_VAR 0 3
54502: PUSH
54503: LD_VAR 0 4
54507: ARRAY
54508: PPUSH
54509: CALL_OW 254
54513: PUSH
54514: EMPTY
54515: LIST
54516: LIST
54517: LIST
54518: LIST
54519: PUSH
54520: EMPTY
54521: LIST
54522: ADD
54523: ST_TO_ADDR
54524: GO 54437
54526: POP
54527: POP
// result := list ;
54528: LD_ADDR_VAR 0 2
54532: PUSH
54533: LD_VAR 0 5
54537: ST_TO_ADDR
// end ;
54538: LD_VAR 0 2
54542: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54543: LD_INT 0
54545: PPUSH
54546: PPUSH
54547: PPUSH
54548: PPUSH
54549: PPUSH
54550: PPUSH
54551: PPUSH
// if not factory then
54552: LD_VAR 0 1
54556: NOT
54557: IFFALSE 54561
// exit ;
54559: GO 55154
// if control = control_apeman then
54561: LD_VAR 0 4
54565: PUSH
54566: LD_INT 5
54568: EQUAL
54569: IFFALSE 54678
// begin tmp := UnitsInside ( factory ) ;
54571: LD_ADDR_VAR 0 8
54575: PUSH
54576: LD_VAR 0 1
54580: PPUSH
54581: CALL_OW 313
54585: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54586: LD_VAR 0 8
54590: PPUSH
54591: LD_INT 25
54593: PUSH
54594: LD_INT 12
54596: PUSH
54597: EMPTY
54598: LIST
54599: LIST
54600: PPUSH
54601: CALL_OW 72
54605: NOT
54606: IFFALSE 54616
// control := control_manual ;
54608: LD_ADDR_VAR 0 4
54612: PUSH
54613: LD_INT 1
54615: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54616: LD_ADDR_VAR 0 8
54620: PUSH
54621: LD_VAR 0 1
54625: PPUSH
54626: CALL 54313 0 1
54630: ST_TO_ADDR
// if tmp then
54631: LD_VAR 0 8
54635: IFFALSE 54678
// begin for i in tmp do
54637: LD_ADDR_VAR 0 7
54641: PUSH
54642: LD_VAR 0 8
54646: PUSH
54647: FOR_IN
54648: IFFALSE 54676
// if i [ 1 ] = b_ext_radio then
54650: LD_VAR 0 7
54654: PUSH
54655: LD_INT 1
54657: ARRAY
54658: PUSH
54659: LD_INT 22
54661: EQUAL
54662: IFFALSE 54674
// begin control := control_remote ;
54664: LD_ADDR_VAR 0 4
54668: PUSH
54669: LD_INT 2
54671: ST_TO_ADDR
// break ;
54672: GO 54676
// end ;
54674: GO 54647
54676: POP
54677: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54678: LD_VAR 0 1
54682: PPUSH
54683: LD_VAR 0 2
54687: PPUSH
54688: LD_VAR 0 3
54692: PPUSH
54693: LD_VAR 0 4
54697: PPUSH
54698: LD_VAR 0 5
54702: PPUSH
54703: CALL_OW 448
54707: IFFALSE 54742
// begin result := [ chassis , engine , control , weapon ] ;
54709: LD_ADDR_VAR 0 6
54713: PUSH
54714: LD_VAR 0 2
54718: PUSH
54719: LD_VAR 0 3
54723: PUSH
54724: LD_VAR 0 4
54728: PUSH
54729: LD_VAR 0 5
54733: PUSH
54734: EMPTY
54735: LIST
54736: LIST
54737: LIST
54738: LIST
54739: ST_TO_ADDR
// exit ;
54740: GO 55154
// end ; _chassis := AvailableChassisList ( factory ) ;
54742: LD_ADDR_VAR 0 9
54746: PUSH
54747: LD_VAR 0 1
54751: PPUSH
54752: CALL_OW 475
54756: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54757: LD_ADDR_VAR 0 11
54761: PUSH
54762: LD_VAR 0 1
54766: PPUSH
54767: CALL_OW 476
54771: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54772: LD_ADDR_VAR 0 12
54776: PUSH
54777: LD_VAR 0 1
54781: PPUSH
54782: CALL_OW 477
54786: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54787: LD_ADDR_VAR 0 10
54791: PUSH
54792: LD_VAR 0 1
54796: PPUSH
54797: CALL_OW 478
54801: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54802: LD_VAR 0 9
54806: NOT
54807: PUSH
54808: LD_VAR 0 11
54812: NOT
54813: OR
54814: PUSH
54815: LD_VAR 0 12
54819: NOT
54820: OR
54821: PUSH
54822: LD_VAR 0 10
54826: NOT
54827: OR
54828: IFFALSE 54863
// begin result := [ chassis , engine , control , weapon ] ;
54830: LD_ADDR_VAR 0 6
54834: PUSH
54835: LD_VAR 0 2
54839: PUSH
54840: LD_VAR 0 3
54844: PUSH
54845: LD_VAR 0 4
54849: PUSH
54850: LD_VAR 0 5
54854: PUSH
54855: EMPTY
54856: LIST
54857: LIST
54858: LIST
54859: LIST
54860: ST_TO_ADDR
// exit ;
54861: GO 55154
// end ; if not chassis in _chassis then
54863: LD_VAR 0 2
54867: PUSH
54868: LD_VAR 0 9
54872: IN
54873: NOT
54874: IFFALSE 54900
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54876: LD_ADDR_VAR 0 2
54880: PUSH
54881: LD_VAR 0 9
54885: PUSH
54886: LD_INT 1
54888: PPUSH
54889: LD_VAR 0 9
54893: PPUSH
54894: CALL_OW 12
54898: ARRAY
54899: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54900: LD_VAR 0 2
54904: PPUSH
54905: LD_VAR 0 3
54909: PPUSH
54910: CALL 55159 0 2
54914: NOT
54915: IFFALSE 54974
// repeat engine := _engine [ 1 ] ;
54917: LD_ADDR_VAR 0 3
54921: PUSH
54922: LD_VAR 0 11
54926: PUSH
54927: LD_INT 1
54929: ARRAY
54930: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54931: LD_ADDR_VAR 0 11
54935: PUSH
54936: LD_VAR 0 11
54940: PPUSH
54941: LD_INT 1
54943: PPUSH
54944: CALL_OW 3
54948: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54949: LD_VAR 0 2
54953: PPUSH
54954: LD_VAR 0 3
54958: PPUSH
54959: CALL 55159 0 2
54963: PUSH
54964: LD_VAR 0 11
54968: PUSH
54969: EMPTY
54970: EQUAL
54971: OR
54972: IFFALSE 54917
// if not control in _control then
54974: LD_VAR 0 4
54978: PUSH
54979: LD_VAR 0 12
54983: IN
54984: NOT
54985: IFFALSE 55011
// control := _control [ rand ( 1 , _control ) ] ;
54987: LD_ADDR_VAR 0 4
54991: PUSH
54992: LD_VAR 0 12
54996: PUSH
54997: LD_INT 1
54999: PPUSH
55000: LD_VAR 0 12
55004: PPUSH
55005: CALL_OW 12
55009: ARRAY
55010: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55011: LD_VAR 0 2
55015: PPUSH
55016: LD_VAR 0 5
55020: PPUSH
55021: CALL 55379 0 2
55025: NOT
55026: IFFALSE 55085
// repeat weapon := _weapon [ 1 ] ;
55028: LD_ADDR_VAR 0 5
55032: PUSH
55033: LD_VAR 0 10
55037: PUSH
55038: LD_INT 1
55040: ARRAY
55041: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55042: LD_ADDR_VAR 0 10
55046: PUSH
55047: LD_VAR 0 10
55051: PPUSH
55052: LD_INT 1
55054: PPUSH
55055: CALL_OW 3
55059: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55060: LD_VAR 0 2
55064: PPUSH
55065: LD_VAR 0 5
55069: PPUSH
55070: CALL 55379 0 2
55074: PUSH
55075: LD_VAR 0 10
55079: PUSH
55080: EMPTY
55081: EQUAL
55082: OR
55083: IFFALSE 55028
// result := [ ] ;
55085: LD_ADDR_VAR 0 6
55089: PUSH
55090: EMPTY
55091: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55092: LD_VAR 0 1
55096: PPUSH
55097: LD_VAR 0 2
55101: PPUSH
55102: LD_VAR 0 3
55106: PPUSH
55107: LD_VAR 0 4
55111: PPUSH
55112: LD_VAR 0 5
55116: PPUSH
55117: CALL_OW 448
55121: IFFALSE 55154
// result := [ chassis , engine , control , weapon ] ;
55123: LD_ADDR_VAR 0 6
55127: PUSH
55128: LD_VAR 0 2
55132: PUSH
55133: LD_VAR 0 3
55137: PUSH
55138: LD_VAR 0 4
55142: PUSH
55143: LD_VAR 0 5
55147: PUSH
55148: EMPTY
55149: LIST
55150: LIST
55151: LIST
55152: LIST
55153: ST_TO_ADDR
// end ;
55154: LD_VAR 0 6
55158: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55159: LD_INT 0
55161: PPUSH
// if not chassis or not engine then
55162: LD_VAR 0 1
55166: NOT
55167: PUSH
55168: LD_VAR 0 2
55172: NOT
55173: OR
55174: IFFALSE 55178
// exit ;
55176: GO 55374
// case engine of engine_solar :
55178: LD_VAR 0 2
55182: PUSH
55183: LD_INT 2
55185: DOUBLE
55186: EQUAL
55187: IFTRUE 55191
55189: GO 55229
55191: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55192: LD_ADDR_VAR 0 3
55196: PUSH
55197: LD_INT 11
55199: PUSH
55200: LD_INT 12
55202: PUSH
55203: LD_INT 13
55205: PUSH
55206: LD_INT 14
55208: PUSH
55209: LD_INT 1
55211: PUSH
55212: LD_INT 2
55214: PUSH
55215: LD_INT 3
55217: PUSH
55218: EMPTY
55219: LIST
55220: LIST
55221: LIST
55222: LIST
55223: LIST
55224: LIST
55225: LIST
55226: ST_TO_ADDR
55227: GO 55358
55229: LD_INT 1
55231: DOUBLE
55232: EQUAL
55233: IFTRUE 55237
55235: GO 55299
55237: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55238: LD_ADDR_VAR 0 3
55242: PUSH
55243: LD_INT 11
55245: PUSH
55246: LD_INT 12
55248: PUSH
55249: LD_INT 13
55251: PUSH
55252: LD_INT 14
55254: PUSH
55255: LD_INT 1
55257: PUSH
55258: LD_INT 2
55260: PUSH
55261: LD_INT 3
55263: PUSH
55264: LD_INT 4
55266: PUSH
55267: LD_INT 5
55269: PUSH
55270: LD_INT 21
55272: PUSH
55273: LD_INT 23
55275: PUSH
55276: LD_INT 22
55278: PUSH
55279: LD_INT 24
55281: PUSH
55282: EMPTY
55283: LIST
55284: LIST
55285: LIST
55286: LIST
55287: LIST
55288: LIST
55289: LIST
55290: LIST
55291: LIST
55292: LIST
55293: LIST
55294: LIST
55295: LIST
55296: ST_TO_ADDR
55297: GO 55358
55299: LD_INT 3
55301: DOUBLE
55302: EQUAL
55303: IFTRUE 55307
55305: GO 55357
55307: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55308: LD_ADDR_VAR 0 3
55312: PUSH
55313: LD_INT 13
55315: PUSH
55316: LD_INT 14
55318: PUSH
55319: LD_INT 2
55321: PUSH
55322: LD_INT 3
55324: PUSH
55325: LD_INT 4
55327: PUSH
55328: LD_INT 5
55330: PUSH
55331: LD_INT 21
55333: PUSH
55334: LD_INT 22
55336: PUSH
55337: LD_INT 23
55339: PUSH
55340: LD_INT 24
55342: PUSH
55343: EMPTY
55344: LIST
55345: LIST
55346: LIST
55347: LIST
55348: LIST
55349: LIST
55350: LIST
55351: LIST
55352: LIST
55353: LIST
55354: ST_TO_ADDR
55355: GO 55358
55357: POP
// result := ( chassis in result ) ;
55358: LD_ADDR_VAR 0 3
55362: PUSH
55363: LD_VAR 0 1
55367: PUSH
55368: LD_VAR 0 3
55372: IN
55373: ST_TO_ADDR
// end ;
55374: LD_VAR 0 3
55378: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55379: LD_INT 0
55381: PPUSH
// if not chassis or not weapon then
55382: LD_VAR 0 1
55386: NOT
55387: PUSH
55388: LD_VAR 0 2
55392: NOT
55393: OR
55394: IFFALSE 55398
// exit ;
55396: GO 56458
// case weapon of us_machine_gun :
55398: LD_VAR 0 2
55402: PUSH
55403: LD_INT 2
55405: DOUBLE
55406: EQUAL
55407: IFTRUE 55411
55409: GO 55441
55411: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55412: LD_ADDR_VAR 0 3
55416: PUSH
55417: LD_INT 1
55419: PUSH
55420: LD_INT 2
55422: PUSH
55423: LD_INT 3
55425: PUSH
55426: LD_INT 4
55428: PUSH
55429: LD_INT 5
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: LIST
55436: LIST
55437: LIST
55438: ST_TO_ADDR
55439: GO 56442
55441: LD_INT 3
55443: DOUBLE
55444: EQUAL
55445: IFTRUE 55449
55447: GO 55479
55449: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55450: LD_ADDR_VAR 0 3
55454: PUSH
55455: LD_INT 1
55457: PUSH
55458: LD_INT 2
55460: PUSH
55461: LD_INT 3
55463: PUSH
55464: LD_INT 4
55466: PUSH
55467: LD_INT 5
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: LIST
55474: LIST
55475: LIST
55476: ST_TO_ADDR
55477: GO 56442
55479: LD_INT 11
55481: DOUBLE
55482: EQUAL
55483: IFTRUE 55487
55485: GO 55517
55487: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55488: LD_ADDR_VAR 0 3
55492: PUSH
55493: LD_INT 1
55495: PUSH
55496: LD_INT 2
55498: PUSH
55499: LD_INT 3
55501: PUSH
55502: LD_INT 4
55504: PUSH
55505: LD_INT 5
55507: PUSH
55508: EMPTY
55509: LIST
55510: LIST
55511: LIST
55512: LIST
55513: LIST
55514: ST_TO_ADDR
55515: GO 56442
55517: LD_INT 4
55519: DOUBLE
55520: EQUAL
55521: IFTRUE 55525
55523: GO 55551
55525: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55526: LD_ADDR_VAR 0 3
55530: PUSH
55531: LD_INT 2
55533: PUSH
55534: LD_INT 3
55536: PUSH
55537: LD_INT 4
55539: PUSH
55540: LD_INT 5
55542: PUSH
55543: EMPTY
55544: LIST
55545: LIST
55546: LIST
55547: LIST
55548: ST_TO_ADDR
55549: GO 56442
55551: LD_INT 5
55553: DOUBLE
55554: EQUAL
55555: IFTRUE 55559
55557: GO 55585
55559: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55560: LD_ADDR_VAR 0 3
55564: PUSH
55565: LD_INT 2
55567: PUSH
55568: LD_INT 3
55570: PUSH
55571: LD_INT 4
55573: PUSH
55574: LD_INT 5
55576: PUSH
55577: EMPTY
55578: LIST
55579: LIST
55580: LIST
55581: LIST
55582: ST_TO_ADDR
55583: GO 56442
55585: LD_INT 9
55587: DOUBLE
55588: EQUAL
55589: IFTRUE 55593
55591: GO 55619
55593: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55594: LD_ADDR_VAR 0 3
55598: PUSH
55599: LD_INT 2
55601: PUSH
55602: LD_INT 3
55604: PUSH
55605: LD_INT 4
55607: PUSH
55608: LD_INT 5
55610: PUSH
55611: EMPTY
55612: LIST
55613: LIST
55614: LIST
55615: LIST
55616: ST_TO_ADDR
55617: GO 56442
55619: LD_INT 7
55621: DOUBLE
55622: EQUAL
55623: IFTRUE 55627
55625: GO 55653
55627: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55628: LD_ADDR_VAR 0 3
55632: PUSH
55633: LD_INT 2
55635: PUSH
55636: LD_INT 3
55638: PUSH
55639: LD_INT 4
55641: PUSH
55642: LD_INT 5
55644: PUSH
55645: EMPTY
55646: LIST
55647: LIST
55648: LIST
55649: LIST
55650: ST_TO_ADDR
55651: GO 56442
55653: LD_INT 12
55655: DOUBLE
55656: EQUAL
55657: IFTRUE 55661
55659: GO 55687
55661: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55662: LD_ADDR_VAR 0 3
55666: PUSH
55667: LD_INT 2
55669: PUSH
55670: LD_INT 3
55672: PUSH
55673: LD_INT 4
55675: PUSH
55676: LD_INT 5
55678: PUSH
55679: EMPTY
55680: LIST
55681: LIST
55682: LIST
55683: LIST
55684: ST_TO_ADDR
55685: GO 56442
55687: LD_INT 13
55689: DOUBLE
55690: EQUAL
55691: IFTRUE 55695
55693: GO 55721
55695: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55696: LD_ADDR_VAR 0 3
55700: PUSH
55701: LD_INT 2
55703: PUSH
55704: LD_INT 3
55706: PUSH
55707: LD_INT 4
55709: PUSH
55710: LD_INT 5
55712: PUSH
55713: EMPTY
55714: LIST
55715: LIST
55716: LIST
55717: LIST
55718: ST_TO_ADDR
55719: GO 56442
55721: LD_INT 14
55723: DOUBLE
55724: EQUAL
55725: IFTRUE 55729
55727: GO 55747
55729: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55730: LD_ADDR_VAR 0 3
55734: PUSH
55735: LD_INT 4
55737: PUSH
55738: LD_INT 5
55740: PUSH
55741: EMPTY
55742: LIST
55743: LIST
55744: ST_TO_ADDR
55745: GO 56442
55747: LD_INT 6
55749: DOUBLE
55750: EQUAL
55751: IFTRUE 55755
55753: GO 55773
55755: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55756: LD_ADDR_VAR 0 3
55760: PUSH
55761: LD_INT 4
55763: PUSH
55764: LD_INT 5
55766: PUSH
55767: EMPTY
55768: LIST
55769: LIST
55770: ST_TO_ADDR
55771: GO 56442
55773: LD_INT 10
55775: DOUBLE
55776: EQUAL
55777: IFTRUE 55781
55779: GO 55799
55781: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55782: LD_ADDR_VAR 0 3
55786: PUSH
55787: LD_INT 4
55789: PUSH
55790: LD_INT 5
55792: PUSH
55793: EMPTY
55794: LIST
55795: LIST
55796: ST_TO_ADDR
55797: GO 56442
55799: LD_INT 22
55801: DOUBLE
55802: EQUAL
55803: IFTRUE 55807
55805: GO 55833
55807: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55808: LD_ADDR_VAR 0 3
55812: PUSH
55813: LD_INT 11
55815: PUSH
55816: LD_INT 12
55818: PUSH
55819: LD_INT 13
55821: PUSH
55822: LD_INT 14
55824: PUSH
55825: EMPTY
55826: LIST
55827: LIST
55828: LIST
55829: LIST
55830: ST_TO_ADDR
55831: GO 56442
55833: LD_INT 23
55835: DOUBLE
55836: EQUAL
55837: IFTRUE 55841
55839: GO 55867
55841: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55842: LD_ADDR_VAR 0 3
55846: PUSH
55847: LD_INT 11
55849: PUSH
55850: LD_INT 12
55852: PUSH
55853: LD_INT 13
55855: PUSH
55856: LD_INT 14
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: LIST
55863: LIST
55864: ST_TO_ADDR
55865: GO 56442
55867: LD_INT 24
55869: DOUBLE
55870: EQUAL
55871: IFTRUE 55875
55873: GO 55901
55875: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55876: LD_ADDR_VAR 0 3
55880: PUSH
55881: LD_INT 11
55883: PUSH
55884: LD_INT 12
55886: PUSH
55887: LD_INT 13
55889: PUSH
55890: LD_INT 14
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: LIST
55897: LIST
55898: ST_TO_ADDR
55899: GO 56442
55901: LD_INT 30
55903: DOUBLE
55904: EQUAL
55905: IFTRUE 55909
55907: GO 55935
55909: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55910: LD_ADDR_VAR 0 3
55914: PUSH
55915: LD_INT 11
55917: PUSH
55918: LD_INT 12
55920: PUSH
55921: LD_INT 13
55923: PUSH
55924: LD_INT 14
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: ST_TO_ADDR
55933: GO 56442
55935: LD_INT 25
55937: DOUBLE
55938: EQUAL
55939: IFTRUE 55943
55941: GO 55961
55943: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55944: LD_ADDR_VAR 0 3
55948: PUSH
55949: LD_INT 13
55951: PUSH
55952: LD_INT 14
55954: PUSH
55955: EMPTY
55956: LIST
55957: LIST
55958: ST_TO_ADDR
55959: GO 56442
55961: LD_INT 27
55963: DOUBLE
55964: EQUAL
55965: IFTRUE 55969
55967: GO 55987
55969: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55970: LD_ADDR_VAR 0 3
55974: PUSH
55975: LD_INT 13
55977: PUSH
55978: LD_INT 14
55980: PUSH
55981: EMPTY
55982: LIST
55983: LIST
55984: ST_TO_ADDR
55985: GO 56442
55987: LD_INT 92
55989: DOUBLE
55990: EQUAL
55991: IFTRUE 55995
55993: GO 56021
55995: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55996: LD_ADDR_VAR 0 3
56000: PUSH
56001: LD_INT 11
56003: PUSH
56004: LD_INT 12
56006: PUSH
56007: LD_INT 13
56009: PUSH
56010: LD_INT 14
56012: PUSH
56013: EMPTY
56014: LIST
56015: LIST
56016: LIST
56017: LIST
56018: ST_TO_ADDR
56019: GO 56442
56021: LD_INT 28
56023: DOUBLE
56024: EQUAL
56025: IFTRUE 56029
56027: GO 56047
56029: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56030: LD_ADDR_VAR 0 3
56034: PUSH
56035: LD_INT 13
56037: PUSH
56038: LD_INT 14
56040: PUSH
56041: EMPTY
56042: LIST
56043: LIST
56044: ST_TO_ADDR
56045: GO 56442
56047: LD_INT 29
56049: DOUBLE
56050: EQUAL
56051: IFTRUE 56055
56053: GO 56073
56055: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56056: LD_ADDR_VAR 0 3
56060: PUSH
56061: LD_INT 13
56063: PUSH
56064: LD_INT 14
56066: PUSH
56067: EMPTY
56068: LIST
56069: LIST
56070: ST_TO_ADDR
56071: GO 56442
56073: LD_INT 31
56075: DOUBLE
56076: EQUAL
56077: IFTRUE 56081
56079: GO 56099
56081: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56082: LD_ADDR_VAR 0 3
56086: PUSH
56087: LD_INT 13
56089: PUSH
56090: LD_INT 14
56092: PUSH
56093: EMPTY
56094: LIST
56095: LIST
56096: ST_TO_ADDR
56097: GO 56442
56099: LD_INT 26
56101: DOUBLE
56102: EQUAL
56103: IFTRUE 56107
56105: GO 56125
56107: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56108: LD_ADDR_VAR 0 3
56112: PUSH
56113: LD_INT 13
56115: PUSH
56116: LD_INT 14
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: ST_TO_ADDR
56123: GO 56442
56125: LD_INT 42
56127: DOUBLE
56128: EQUAL
56129: IFTRUE 56133
56131: GO 56159
56133: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56134: LD_ADDR_VAR 0 3
56138: PUSH
56139: LD_INT 21
56141: PUSH
56142: LD_INT 22
56144: PUSH
56145: LD_INT 23
56147: PUSH
56148: LD_INT 24
56150: PUSH
56151: EMPTY
56152: LIST
56153: LIST
56154: LIST
56155: LIST
56156: ST_TO_ADDR
56157: GO 56442
56159: LD_INT 43
56161: DOUBLE
56162: EQUAL
56163: IFTRUE 56167
56165: GO 56193
56167: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56168: LD_ADDR_VAR 0 3
56172: PUSH
56173: LD_INT 21
56175: PUSH
56176: LD_INT 22
56178: PUSH
56179: LD_INT 23
56181: PUSH
56182: LD_INT 24
56184: PUSH
56185: EMPTY
56186: LIST
56187: LIST
56188: LIST
56189: LIST
56190: ST_TO_ADDR
56191: GO 56442
56193: LD_INT 44
56195: DOUBLE
56196: EQUAL
56197: IFTRUE 56201
56199: GO 56227
56201: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56202: LD_ADDR_VAR 0 3
56206: PUSH
56207: LD_INT 21
56209: PUSH
56210: LD_INT 22
56212: PUSH
56213: LD_INT 23
56215: PUSH
56216: LD_INT 24
56218: PUSH
56219: EMPTY
56220: LIST
56221: LIST
56222: LIST
56223: LIST
56224: ST_TO_ADDR
56225: GO 56442
56227: LD_INT 45
56229: DOUBLE
56230: EQUAL
56231: IFTRUE 56235
56233: GO 56261
56235: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56236: LD_ADDR_VAR 0 3
56240: PUSH
56241: LD_INT 21
56243: PUSH
56244: LD_INT 22
56246: PUSH
56247: LD_INT 23
56249: PUSH
56250: LD_INT 24
56252: PUSH
56253: EMPTY
56254: LIST
56255: LIST
56256: LIST
56257: LIST
56258: ST_TO_ADDR
56259: GO 56442
56261: LD_INT 49
56263: DOUBLE
56264: EQUAL
56265: IFTRUE 56269
56267: GO 56295
56269: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56270: LD_ADDR_VAR 0 3
56274: PUSH
56275: LD_INT 21
56277: PUSH
56278: LD_INT 22
56280: PUSH
56281: LD_INT 23
56283: PUSH
56284: LD_INT 24
56286: PUSH
56287: EMPTY
56288: LIST
56289: LIST
56290: LIST
56291: LIST
56292: ST_TO_ADDR
56293: GO 56442
56295: LD_INT 51
56297: DOUBLE
56298: EQUAL
56299: IFTRUE 56303
56301: GO 56329
56303: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56304: LD_ADDR_VAR 0 3
56308: PUSH
56309: LD_INT 21
56311: PUSH
56312: LD_INT 22
56314: PUSH
56315: LD_INT 23
56317: PUSH
56318: LD_INT 24
56320: PUSH
56321: EMPTY
56322: LIST
56323: LIST
56324: LIST
56325: LIST
56326: ST_TO_ADDR
56327: GO 56442
56329: LD_INT 52
56331: DOUBLE
56332: EQUAL
56333: IFTRUE 56337
56335: GO 56363
56337: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56338: LD_ADDR_VAR 0 3
56342: PUSH
56343: LD_INT 21
56345: PUSH
56346: LD_INT 22
56348: PUSH
56349: LD_INT 23
56351: PUSH
56352: LD_INT 24
56354: PUSH
56355: EMPTY
56356: LIST
56357: LIST
56358: LIST
56359: LIST
56360: ST_TO_ADDR
56361: GO 56442
56363: LD_INT 53
56365: DOUBLE
56366: EQUAL
56367: IFTRUE 56371
56369: GO 56389
56371: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56372: LD_ADDR_VAR 0 3
56376: PUSH
56377: LD_INT 23
56379: PUSH
56380: LD_INT 24
56382: PUSH
56383: EMPTY
56384: LIST
56385: LIST
56386: ST_TO_ADDR
56387: GO 56442
56389: LD_INT 46
56391: DOUBLE
56392: EQUAL
56393: IFTRUE 56397
56395: GO 56415
56397: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56398: LD_ADDR_VAR 0 3
56402: PUSH
56403: LD_INT 23
56405: PUSH
56406: LD_INT 24
56408: PUSH
56409: EMPTY
56410: LIST
56411: LIST
56412: ST_TO_ADDR
56413: GO 56442
56415: LD_INT 47
56417: DOUBLE
56418: EQUAL
56419: IFTRUE 56423
56421: GO 56441
56423: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56424: LD_ADDR_VAR 0 3
56428: PUSH
56429: LD_INT 23
56431: PUSH
56432: LD_INT 24
56434: PUSH
56435: EMPTY
56436: LIST
56437: LIST
56438: ST_TO_ADDR
56439: GO 56442
56441: POP
// result := ( chassis in result ) ;
56442: LD_ADDR_VAR 0 3
56446: PUSH
56447: LD_VAR 0 1
56451: PUSH
56452: LD_VAR 0 3
56456: IN
56457: ST_TO_ADDR
// end ;
56458: LD_VAR 0 3
56462: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56463: LD_INT 0
56465: PPUSH
56466: PPUSH
56467: PPUSH
56468: PPUSH
56469: PPUSH
56470: PPUSH
56471: PPUSH
// result := array ;
56472: LD_ADDR_VAR 0 5
56476: PUSH
56477: LD_VAR 0 1
56481: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56482: LD_VAR 0 1
56486: NOT
56487: PUSH
56488: LD_VAR 0 2
56492: NOT
56493: OR
56494: PUSH
56495: LD_VAR 0 3
56499: NOT
56500: OR
56501: PUSH
56502: LD_VAR 0 2
56506: PUSH
56507: LD_VAR 0 1
56511: GREATER
56512: OR
56513: PUSH
56514: LD_VAR 0 3
56518: PUSH
56519: LD_VAR 0 1
56523: GREATER
56524: OR
56525: IFFALSE 56529
// exit ;
56527: GO 56825
// if direction then
56529: LD_VAR 0 4
56533: IFFALSE 56597
// begin d := 1 ;
56535: LD_ADDR_VAR 0 9
56539: PUSH
56540: LD_INT 1
56542: ST_TO_ADDR
// if i_from > i_to then
56543: LD_VAR 0 2
56547: PUSH
56548: LD_VAR 0 3
56552: GREATER
56553: IFFALSE 56579
// length := ( array - i_from ) + i_to else
56555: LD_ADDR_VAR 0 11
56559: PUSH
56560: LD_VAR 0 1
56564: PUSH
56565: LD_VAR 0 2
56569: MINUS
56570: PUSH
56571: LD_VAR 0 3
56575: PLUS
56576: ST_TO_ADDR
56577: GO 56595
// length := i_to - i_from ;
56579: LD_ADDR_VAR 0 11
56583: PUSH
56584: LD_VAR 0 3
56588: PUSH
56589: LD_VAR 0 2
56593: MINUS
56594: ST_TO_ADDR
// end else
56595: GO 56658
// begin d := - 1 ;
56597: LD_ADDR_VAR 0 9
56601: PUSH
56602: LD_INT 1
56604: NEG
56605: ST_TO_ADDR
// if i_from > i_to then
56606: LD_VAR 0 2
56610: PUSH
56611: LD_VAR 0 3
56615: GREATER
56616: IFFALSE 56636
// length := i_from - i_to else
56618: LD_ADDR_VAR 0 11
56622: PUSH
56623: LD_VAR 0 2
56627: PUSH
56628: LD_VAR 0 3
56632: MINUS
56633: ST_TO_ADDR
56634: GO 56658
// length := ( array - i_to ) + i_from ;
56636: LD_ADDR_VAR 0 11
56640: PUSH
56641: LD_VAR 0 1
56645: PUSH
56646: LD_VAR 0 3
56650: MINUS
56651: PUSH
56652: LD_VAR 0 2
56656: PLUS
56657: ST_TO_ADDR
// end ; if not length then
56658: LD_VAR 0 11
56662: NOT
56663: IFFALSE 56667
// exit ;
56665: GO 56825
// tmp := array ;
56667: LD_ADDR_VAR 0 10
56671: PUSH
56672: LD_VAR 0 1
56676: ST_TO_ADDR
// for i = 1 to length do
56677: LD_ADDR_VAR 0 6
56681: PUSH
56682: DOUBLE
56683: LD_INT 1
56685: DEC
56686: ST_TO_ADDR
56687: LD_VAR 0 11
56691: PUSH
56692: FOR_TO
56693: IFFALSE 56813
// begin for j = 1 to array do
56695: LD_ADDR_VAR 0 7
56699: PUSH
56700: DOUBLE
56701: LD_INT 1
56703: DEC
56704: ST_TO_ADDR
56705: LD_VAR 0 1
56709: PUSH
56710: FOR_TO
56711: IFFALSE 56799
// begin k := j + d ;
56713: LD_ADDR_VAR 0 8
56717: PUSH
56718: LD_VAR 0 7
56722: PUSH
56723: LD_VAR 0 9
56727: PLUS
56728: ST_TO_ADDR
// if k > array then
56729: LD_VAR 0 8
56733: PUSH
56734: LD_VAR 0 1
56738: GREATER
56739: IFFALSE 56749
// k := 1 ;
56741: LD_ADDR_VAR 0 8
56745: PUSH
56746: LD_INT 1
56748: ST_TO_ADDR
// if not k then
56749: LD_VAR 0 8
56753: NOT
56754: IFFALSE 56766
// k := array ;
56756: LD_ADDR_VAR 0 8
56760: PUSH
56761: LD_VAR 0 1
56765: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56766: LD_ADDR_VAR 0 10
56770: PUSH
56771: LD_VAR 0 10
56775: PPUSH
56776: LD_VAR 0 8
56780: PPUSH
56781: LD_VAR 0 1
56785: PUSH
56786: LD_VAR 0 7
56790: ARRAY
56791: PPUSH
56792: CALL_OW 1
56796: ST_TO_ADDR
// end ;
56797: GO 56710
56799: POP
56800: POP
// array := tmp ;
56801: LD_ADDR_VAR 0 1
56805: PUSH
56806: LD_VAR 0 10
56810: ST_TO_ADDR
// end ;
56811: GO 56692
56813: POP
56814: POP
// result := array ;
56815: LD_ADDR_VAR 0 5
56819: PUSH
56820: LD_VAR 0 1
56824: ST_TO_ADDR
// end ;
56825: LD_VAR 0 5
56829: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56830: LD_INT 0
56832: PPUSH
56833: PPUSH
// result := 0 ;
56834: LD_ADDR_VAR 0 3
56838: PUSH
56839: LD_INT 0
56841: ST_TO_ADDR
// if not array or not value in array then
56842: LD_VAR 0 1
56846: NOT
56847: PUSH
56848: LD_VAR 0 2
56852: PUSH
56853: LD_VAR 0 1
56857: IN
56858: NOT
56859: OR
56860: IFFALSE 56864
// exit ;
56862: GO 56918
// for i = 1 to array do
56864: LD_ADDR_VAR 0 4
56868: PUSH
56869: DOUBLE
56870: LD_INT 1
56872: DEC
56873: ST_TO_ADDR
56874: LD_VAR 0 1
56878: PUSH
56879: FOR_TO
56880: IFFALSE 56916
// if value = array [ i ] then
56882: LD_VAR 0 2
56886: PUSH
56887: LD_VAR 0 1
56891: PUSH
56892: LD_VAR 0 4
56896: ARRAY
56897: EQUAL
56898: IFFALSE 56914
// begin result := i ;
56900: LD_ADDR_VAR 0 3
56904: PUSH
56905: LD_VAR 0 4
56909: ST_TO_ADDR
// exit ;
56910: POP
56911: POP
56912: GO 56918
// end ;
56914: GO 56879
56916: POP
56917: POP
// end ;
56918: LD_VAR 0 3
56922: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56923: LD_INT 0
56925: PPUSH
// vc_chassis := chassis ;
56926: LD_ADDR_OWVAR 37
56930: PUSH
56931: LD_VAR 0 1
56935: ST_TO_ADDR
// vc_engine := engine ;
56936: LD_ADDR_OWVAR 39
56940: PUSH
56941: LD_VAR 0 2
56945: ST_TO_ADDR
// vc_control := control ;
56946: LD_ADDR_OWVAR 38
56950: PUSH
56951: LD_VAR 0 3
56955: ST_TO_ADDR
// vc_weapon := weapon ;
56956: LD_ADDR_OWVAR 40
56960: PUSH
56961: LD_VAR 0 4
56965: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56966: LD_ADDR_OWVAR 41
56970: PUSH
56971: LD_VAR 0 5
56975: ST_TO_ADDR
// end ;
56976: LD_VAR 0 6
56980: RET
// export function WantPlant ( unit ) ; var task ; begin
56981: LD_INT 0
56983: PPUSH
56984: PPUSH
// result := false ;
56985: LD_ADDR_VAR 0 2
56989: PUSH
56990: LD_INT 0
56992: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56993: LD_ADDR_VAR 0 3
56997: PUSH
56998: LD_VAR 0 1
57002: PPUSH
57003: CALL_OW 437
57007: ST_TO_ADDR
// if task then
57008: LD_VAR 0 3
57012: IFFALSE 57040
// if task [ 1 ] [ 1 ] = p then
57014: LD_VAR 0 3
57018: PUSH
57019: LD_INT 1
57021: ARRAY
57022: PUSH
57023: LD_INT 1
57025: ARRAY
57026: PUSH
57027: LD_STRING p
57029: EQUAL
57030: IFFALSE 57040
// result := true ;
57032: LD_ADDR_VAR 0 2
57036: PUSH
57037: LD_INT 1
57039: ST_TO_ADDR
// end ;
57040: LD_VAR 0 2
57044: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57045: LD_INT 0
57047: PPUSH
57048: PPUSH
57049: PPUSH
57050: PPUSH
// if pos < 1 then
57051: LD_VAR 0 2
57055: PUSH
57056: LD_INT 1
57058: LESS
57059: IFFALSE 57063
// exit ;
57061: GO 57366
// if pos = 1 then
57063: LD_VAR 0 2
57067: PUSH
57068: LD_INT 1
57070: EQUAL
57071: IFFALSE 57104
// result := Replace ( arr , pos [ 1 ] , value ) else
57073: LD_ADDR_VAR 0 4
57077: PUSH
57078: LD_VAR 0 1
57082: PPUSH
57083: LD_VAR 0 2
57087: PUSH
57088: LD_INT 1
57090: ARRAY
57091: PPUSH
57092: LD_VAR 0 3
57096: PPUSH
57097: CALL_OW 1
57101: ST_TO_ADDR
57102: GO 57366
// begin tmp := arr ;
57104: LD_ADDR_VAR 0 6
57108: PUSH
57109: LD_VAR 0 1
57113: ST_TO_ADDR
// s_arr := [ tmp ] ;
57114: LD_ADDR_VAR 0 7
57118: PUSH
57119: LD_VAR 0 6
57123: PUSH
57124: EMPTY
57125: LIST
57126: ST_TO_ADDR
// for i = 1 to pos - 1 do
57127: LD_ADDR_VAR 0 5
57131: PUSH
57132: DOUBLE
57133: LD_INT 1
57135: DEC
57136: ST_TO_ADDR
57137: LD_VAR 0 2
57141: PUSH
57142: LD_INT 1
57144: MINUS
57145: PUSH
57146: FOR_TO
57147: IFFALSE 57192
// begin tmp := tmp [ pos [ i ] ] ;
57149: LD_ADDR_VAR 0 6
57153: PUSH
57154: LD_VAR 0 6
57158: PUSH
57159: LD_VAR 0 2
57163: PUSH
57164: LD_VAR 0 5
57168: ARRAY
57169: ARRAY
57170: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57171: LD_ADDR_VAR 0 7
57175: PUSH
57176: LD_VAR 0 7
57180: PUSH
57181: LD_VAR 0 6
57185: PUSH
57186: EMPTY
57187: LIST
57188: ADD
57189: ST_TO_ADDR
// end ;
57190: GO 57146
57192: POP
57193: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57194: LD_ADDR_VAR 0 6
57198: PUSH
57199: LD_VAR 0 6
57203: PPUSH
57204: LD_VAR 0 2
57208: PUSH
57209: LD_VAR 0 2
57213: ARRAY
57214: PPUSH
57215: LD_VAR 0 3
57219: PPUSH
57220: CALL_OW 1
57224: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57225: LD_ADDR_VAR 0 7
57229: PUSH
57230: LD_VAR 0 7
57234: PPUSH
57235: LD_VAR 0 7
57239: PPUSH
57240: LD_VAR 0 6
57244: PPUSH
57245: CALL_OW 1
57249: ST_TO_ADDR
// for i = s_arr downto 2 do
57250: LD_ADDR_VAR 0 5
57254: PUSH
57255: DOUBLE
57256: LD_VAR 0 7
57260: INC
57261: ST_TO_ADDR
57262: LD_INT 2
57264: PUSH
57265: FOR_DOWNTO
57266: IFFALSE 57350
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57268: LD_ADDR_VAR 0 6
57272: PUSH
57273: LD_VAR 0 7
57277: PUSH
57278: LD_VAR 0 5
57282: PUSH
57283: LD_INT 1
57285: MINUS
57286: ARRAY
57287: PPUSH
57288: LD_VAR 0 2
57292: PUSH
57293: LD_VAR 0 5
57297: PUSH
57298: LD_INT 1
57300: MINUS
57301: ARRAY
57302: PPUSH
57303: LD_VAR 0 7
57307: PUSH
57308: LD_VAR 0 5
57312: ARRAY
57313: PPUSH
57314: CALL_OW 1
57318: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57319: LD_ADDR_VAR 0 7
57323: PUSH
57324: LD_VAR 0 7
57328: PPUSH
57329: LD_VAR 0 5
57333: PUSH
57334: LD_INT 1
57336: MINUS
57337: PPUSH
57338: LD_VAR 0 6
57342: PPUSH
57343: CALL_OW 1
57347: ST_TO_ADDR
// end ;
57348: GO 57265
57350: POP
57351: POP
// result := s_arr [ 1 ] ;
57352: LD_ADDR_VAR 0 4
57356: PUSH
57357: LD_VAR 0 7
57361: PUSH
57362: LD_INT 1
57364: ARRAY
57365: ST_TO_ADDR
// end ; end ;
57366: LD_VAR 0 4
57370: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57371: LD_INT 0
57373: PPUSH
57374: PPUSH
// if not list then
57375: LD_VAR 0 1
57379: NOT
57380: IFFALSE 57384
// exit ;
57382: GO 57475
// i := list [ pos1 ] ;
57384: LD_ADDR_VAR 0 5
57388: PUSH
57389: LD_VAR 0 1
57393: PUSH
57394: LD_VAR 0 2
57398: ARRAY
57399: ST_TO_ADDR
// if not i then
57400: LD_VAR 0 5
57404: NOT
57405: IFFALSE 57409
// exit ;
57407: GO 57475
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57409: LD_ADDR_VAR 0 1
57413: PUSH
57414: LD_VAR 0 1
57418: PPUSH
57419: LD_VAR 0 2
57423: PPUSH
57424: LD_VAR 0 1
57428: PUSH
57429: LD_VAR 0 3
57433: ARRAY
57434: PPUSH
57435: CALL_OW 1
57439: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57440: LD_ADDR_VAR 0 1
57444: PUSH
57445: LD_VAR 0 1
57449: PPUSH
57450: LD_VAR 0 3
57454: PPUSH
57455: LD_VAR 0 5
57459: PPUSH
57460: CALL_OW 1
57464: ST_TO_ADDR
// result := list ;
57465: LD_ADDR_VAR 0 4
57469: PUSH
57470: LD_VAR 0 1
57474: ST_TO_ADDR
// end ;
57475: LD_VAR 0 4
57479: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57480: LD_INT 0
57482: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57483: LD_ADDR_VAR 0 5
57487: PUSH
57488: LD_VAR 0 1
57492: PPUSH
57493: CALL_OW 250
57497: PPUSH
57498: LD_VAR 0 1
57502: PPUSH
57503: CALL_OW 251
57507: PPUSH
57508: LD_VAR 0 2
57512: PPUSH
57513: LD_VAR 0 3
57517: PPUSH
57518: LD_VAR 0 4
57522: PPUSH
57523: CALL 57533 0 5
57527: ST_TO_ADDR
// end ;
57528: LD_VAR 0 5
57532: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57533: LD_INT 0
57535: PPUSH
57536: PPUSH
57537: PPUSH
57538: PPUSH
// if not list then
57539: LD_VAR 0 3
57543: NOT
57544: IFFALSE 57548
// exit ;
57546: GO 57936
// result := [ ] ;
57548: LD_ADDR_VAR 0 6
57552: PUSH
57553: EMPTY
57554: ST_TO_ADDR
// for i in list do
57555: LD_ADDR_VAR 0 7
57559: PUSH
57560: LD_VAR 0 3
57564: PUSH
57565: FOR_IN
57566: IFFALSE 57768
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57568: LD_ADDR_VAR 0 9
57572: PUSH
57573: LD_VAR 0 7
57577: PPUSH
57578: LD_VAR 0 1
57582: PPUSH
57583: LD_VAR 0 2
57587: PPUSH
57588: CALL_OW 297
57592: ST_TO_ADDR
// if not result then
57593: LD_VAR 0 6
57597: NOT
57598: IFFALSE 57624
// result := [ [ i , tmp ] ] else
57600: LD_ADDR_VAR 0 6
57604: PUSH
57605: LD_VAR 0 7
57609: PUSH
57610: LD_VAR 0 9
57614: PUSH
57615: EMPTY
57616: LIST
57617: LIST
57618: PUSH
57619: EMPTY
57620: LIST
57621: ST_TO_ADDR
57622: GO 57766
// begin if result [ result ] [ 2 ] < tmp then
57624: LD_VAR 0 6
57628: PUSH
57629: LD_VAR 0 6
57633: ARRAY
57634: PUSH
57635: LD_INT 2
57637: ARRAY
57638: PUSH
57639: LD_VAR 0 9
57643: LESS
57644: IFFALSE 57686
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57646: LD_ADDR_VAR 0 6
57650: PUSH
57651: LD_VAR 0 6
57655: PPUSH
57656: LD_VAR 0 6
57660: PUSH
57661: LD_INT 1
57663: PLUS
57664: PPUSH
57665: LD_VAR 0 7
57669: PUSH
57670: LD_VAR 0 9
57674: PUSH
57675: EMPTY
57676: LIST
57677: LIST
57678: PPUSH
57679: CALL_OW 2
57683: ST_TO_ADDR
57684: GO 57766
// for j = 1 to result do
57686: LD_ADDR_VAR 0 8
57690: PUSH
57691: DOUBLE
57692: LD_INT 1
57694: DEC
57695: ST_TO_ADDR
57696: LD_VAR 0 6
57700: PUSH
57701: FOR_TO
57702: IFFALSE 57764
// begin if tmp < result [ j ] [ 2 ] then
57704: LD_VAR 0 9
57708: PUSH
57709: LD_VAR 0 6
57713: PUSH
57714: LD_VAR 0 8
57718: ARRAY
57719: PUSH
57720: LD_INT 2
57722: ARRAY
57723: LESS
57724: IFFALSE 57762
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57726: LD_ADDR_VAR 0 6
57730: PUSH
57731: LD_VAR 0 6
57735: PPUSH
57736: LD_VAR 0 8
57740: PPUSH
57741: LD_VAR 0 7
57745: PUSH
57746: LD_VAR 0 9
57750: PUSH
57751: EMPTY
57752: LIST
57753: LIST
57754: PPUSH
57755: CALL_OW 2
57759: ST_TO_ADDR
// break ;
57760: GO 57764
// end ; end ;
57762: GO 57701
57764: POP
57765: POP
// end ; end ;
57766: GO 57565
57768: POP
57769: POP
// if result and not asc then
57770: LD_VAR 0 6
57774: PUSH
57775: LD_VAR 0 4
57779: NOT
57780: AND
57781: IFFALSE 57856
// begin tmp := result ;
57783: LD_ADDR_VAR 0 9
57787: PUSH
57788: LD_VAR 0 6
57792: ST_TO_ADDR
// for i = tmp downto 1 do
57793: LD_ADDR_VAR 0 7
57797: PUSH
57798: DOUBLE
57799: LD_VAR 0 9
57803: INC
57804: ST_TO_ADDR
57805: LD_INT 1
57807: PUSH
57808: FOR_DOWNTO
57809: IFFALSE 57854
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57811: LD_ADDR_VAR 0 6
57815: PUSH
57816: LD_VAR 0 6
57820: PPUSH
57821: LD_VAR 0 9
57825: PUSH
57826: LD_VAR 0 7
57830: MINUS
57831: PUSH
57832: LD_INT 1
57834: PLUS
57835: PPUSH
57836: LD_VAR 0 9
57840: PUSH
57841: LD_VAR 0 7
57845: ARRAY
57846: PPUSH
57847: CALL_OW 1
57851: ST_TO_ADDR
57852: GO 57808
57854: POP
57855: POP
// end ; tmp := [ ] ;
57856: LD_ADDR_VAR 0 9
57860: PUSH
57861: EMPTY
57862: ST_TO_ADDR
// if mode then
57863: LD_VAR 0 5
57867: IFFALSE 57936
// begin for i = 1 to result do
57869: LD_ADDR_VAR 0 7
57873: PUSH
57874: DOUBLE
57875: LD_INT 1
57877: DEC
57878: ST_TO_ADDR
57879: LD_VAR 0 6
57883: PUSH
57884: FOR_TO
57885: IFFALSE 57924
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57887: LD_ADDR_VAR 0 9
57891: PUSH
57892: LD_VAR 0 9
57896: PPUSH
57897: LD_VAR 0 7
57901: PPUSH
57902: LD_VAR 0 6
57906: PUSH
57907: LD_VAR 0 7
57911: ARRAY
57912: PUSH
57913: LD_INT 1
57915: ARRAY
57916: PPUSH
57917: CALL_OW 1
57921: ST_TO_ADDR
57922: GO 57884
57924: POP
57925: POP
// result := tmp ;
57926: LD_ADDR_VAR 0 6
57930: PUSH
57931: LD_VAR 0 9
57935: ST_TO_ADDR
// end ; end ;
57936: LD_VAR 0 6
57940: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57941: LD_INT 0
57943: PPUSH
57944: PPUSH
57945: PPUSH
57946: PPUSH
57947: PPUSH
57948: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57949: LD_ADDR_VAR 0 5
57953: PUSH
57954: LD_INT 0
57956: PUSH
57957: LD_INT 0
57959: PUSH
57960: LD_INT 0
57962: PUSH
57963: EMPTY
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: LIST
57969: LIST
57970: ST_TO_ADDR
// if not x or not y then
57971: LD_VAR 0 2
57975: NOT
57976: PUSH
57977: LD_VAR 0 3
57981: NOT
57982: OR
57983: IFFALSE 57987
// exit ;
57985: GO 59637
// if not range then
57987: LD_VAR 0 4
57991: NOT
57992: IFFALSE 58002
// range := 10 ;
57994: LD_ADDR_VAR 0 4
57998: PUSH
57999: LD_INT 10
58001: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58002: LD_ADDR_VAR 0 8
58006: PUSH
58007: LD_INT 81
58009: PUSH
58010: LD_VAR 0 1
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: PUSH
58019: LD_INT 92
58021: PUSH
58022: LD_VAR 0 2
58026: PUSH
58027: LD_VAR 0 3
58031: PUSH
58032: LD_VAR 0 4
58036: PUSH
58037: EMPTY
58038: LIST
58039: LIST
58040: LIST
58041: LIST
58042: PUSH
58043: LD_INT 3
58045: PUSH
58046: LD_INT 21
58048: PUSH
58049: LD_INT 3
58051: PUSH
58052: EMPTY
58053: LIST
58054: LIST
58055: PUSH
58056: EMPTY
58057: LIST
58058: LIST
58059: PUSH
58060: EMPTY
58061: LIST
58062: LIST
58063: LIST
58064: PPUSH
58065: CALL_OW 69
58069: ST_TO_ADDR
// if not tmp then
58070: LD_VAR 0 8
58074: NOT
58075: IFFALSE 58079
// exit ;
58077: GO 59637
// for i in tmp do
58079: LD_ADDR_VAR 0 6
58083: PUSH
58084: LD_VAR 0 8
58088: PUSH
58089: FOR_IN
58090: IFFALSE 59612
// begin points := [ 0 , 0 , 0 ] ;
58092: LD_ADDR_VAR 0 9
58096: PUSH
58097: LD_INT 0
58099: PUSH
58100: LD_INT 0
58102: PUSH
58103: LD_INT 0
58105: PUSH
58106: EMPTY
58107: LIST
58108: LIST
58109: LIST
58110: ST_TO_ADDR
// bpoints := 1 ;
58111: LD_ADDR_VAR 0 10
58115: PUSH
58116: LD_INT 1
58118: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58119: LD_VAR 0 6
58123: PPUSH
58124: CALL_OW 247
58128: PUSH
58129: LD_INT 1
58131: DOUBLE
58132: EQUAL
58133: IFTRUE 58137
58135: GO 58715
58137: POP
// begin if GetClass ( i ) = 1 then
58138: LD_VAR 0 6
58142: PPUSH
58143: CALL_OW 257
58147: PUSH
58148: LD_INT 1
58150: EQUAL
58151: IFFALSE 58172
// points := [ 10 , 5 , 3 ] ;
58153: LD_ADDR_VAR 0 9
58157: PUSH
58158: LD_INT 10
58160: PUSH
58161: LD_INT 5
58163: PUSH
58164: LD_INT 3
58166: PUSH
58167: EMPTY
58168: LIST
58169: LIST
58170: LIST
58171: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58172: LD_VAR 0 6
58176: PPUSH
58177: CALL_OW 257
58181: PUSH
58182: LD_INT 2
58184: PUSH
58185: LD_INT 3
58187: PUSH
58188: LD_INT 4
58190: PUSH
58191: EMPTY
58192: LIST
58193: LIST
58194: LIST
58195: IN
58196: IFFALSE 58217
// points := [ 3 , 2 , 1 ] ;
58198: LD_ADDR_VAR 0 9
58202: PUSH
58203: LD_INT 3
58205: PUSH
58206: LD_INT 2
58208: PUSH
58209: LD_INT 1
58211: PUSH
58212: EMPTY
58213: LIST
58214: LIST
58215: LIST
58216: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58217: LD_VAR 0 6
58221: PPUSH
58222: CALL_OW 257
58226: PUSH
58227: LD_INT 5
58229: EQUAL
58230: IFFALSE 58251
// points := [ 130 , 5 , 2 ] ;
58232: LD_ADDR_VAR 0 9
58236: PUSH
58237: LD_INT 130
58239: PUSH
58240: LD_INT 5
58242: PUSH
58243: LD_INT 2
58245: PUSH
58246: EMPTY
58247: LIST
58248: LIST
58249: LIST
58250: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58251: LD_VAR 0 6
58255: PPUSH
58256: CALL_OW 257
58260: PUSH
58261: LD_INT 8
58263: EQUAL
58264: IFFALSE 58285
// points := [ 35 , 35 , 30 ] ;
58266: LD_ADDR_VAR 0 9
58270: PUSH
58271: LD_INT 35
58273: PUSH
58274: LD_INT 35
58276: PUSH
58277: LD_INT 30
58279: PUSH
58280: EMPTY
58281: LIST
58282: LIST
58283: LIST
58284: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58285: LD_VAR 0 6
58289: PPUSH
58290: CALL_OW 257
58294: PUSH
58295: LD_INT 9
58297: EQUAL
58298: IFFALSE 58319
// points := [ 20 , 55 , 40 ] ;
58300: LD_ADDR_VAR 0 9
58304: PUSH
58305: LD_INT 20
58307: PUSH
58308: LD_INT 55
58310: PUSH
58311: LD_INT 40
58313: PUSH
58314: EMPTY
58315: LIST
58316: LIST
58317: LIST
58318: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58319: LD_VAR 0 6
58323: PPUSH
58324: CALL_OW 257
58328: PUSH
58329: LD_INT 12
58331: PUSH
58332: LD_INT 16
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: IN
58339: IFFALSE 58360
// points := [ 5 , 3 , 2 ] ;
58341: LD_ADDR_VAR 0 9
58345: PUSH
58346: LD_INT 5
58348: PUSH
58349: LD_INT 3
58351: PUSH
58352: LD_INT 2
58354: PUSH
58355: EMPTY
58356: LIST
58357: LIST
58358: LIST
58359: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58360: LD_VAR 0 6
58364: PPUSH
58365: CALL_OW 257
58369: PUSH
58370: LD_INT 17
58372: EQUAL
58373: IFFALSE 58394
// points := [ 100 , 50 , 75 ] ;
58375: LD_ADDR_VAR 0 9
58379: PUSH
58380: LD_INT 100
58382: PUSH
58383: LD_INT 50
58385: PUSH
58386: LD_INT 75
58388: PUSH
58389: EMPTY
58390: LIST
58391: LIST
58392: LIST
58393: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58394: LD_VAR 0 6
58398: PPUSH
58399: CALL_OW 257
58403: PUSH
58404: LD_INT 15
58406: EQUAL
58407: IFFALSE 58428
// points := [ 10 , 5 , 3 ] ;
58409: LD_ADDR_VAR 0 9
58413: PUSH
58414: LD_INT 10
58416: PUSH
58417: LD_INT 5
58419: PUSH
58420: LD_INT 3
58422: PUSH
58423: EMPTY
58424: LIST
58425: LIST
58426: LIST
58427: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58428: LD_VAR 0 6
58432: PPUSH
58433: CALL_OW 257
58437: PUSH
58438: LD_INT 14
58440: EQUAL
58441: IFFALSE 58462
// points := [ 10 , 0 , 0 ] ;
58443: LD_ADDR_VAR 0 9
58447: PUSH
58448: LD_INT 10
58450: PUSH
58451: LD_INT 0
58453: PUSH
58454: LD_INT 0
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: LIST
58461: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58462: LD_VAR 0 6
58466: PPUSH
58467: CALL_OW 257
58471: PUSH
58472: LD_INT 11
58474: EQUAL
58475: IFFALSE 58496
// points := [ 30 , 10 , 5 ] ;
58477: LD_ADDR_VAR 0 9
58481: PUSH
58482: LD_INT 30
58484: PUSH
58485: LD_INT 10
58487: PUSH
58488: LD_INT 5
58490: PUSH
58491: EMPTY
58492: LIST
58493: LIST
58494: LIST
58495: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58496: LD_VAR 0 1
58500: PPUSH
58501: LD_INT 5
58503: PPUSH
58504: CALL_OW 321
58508: PUSH
58509: LD_INT 2
58511: EQUAL
58512: IFFALSE 58529
// bpoints := bpoints * 1.8 ;
58514: LD_ADDR_VAR 0 10
58518: PUSH
58519: LD_VAR 0 10
58523: PUSH
58524: LD_REAL  1.80000000000000E+0000
58527: MUL
58528: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58529: LD_VAR 0 6
58533: PPUSH
58534: CALL_OW 257
58538: PUSH
58539: LD_INT 1
58541: PUSH
58542: LD_INT 2
58544: PUSH
58545: LD_INT 3
58547: PUSH
58548: LD_INT 4
58550: PUSH
58551: EMPTY
58552: LIST
58553: LIST
58554: LIST
58555: LIST
58556: IN
58557: PUSH
58558: LD_VAR 0 1
58562: PPUSH
58563: LD_INT 51
58565: PPUSH
58566: CALL_OW 321
58570: PUSH
58571: LD_INT 2
58573: EQUAL
58574: AND
58575: IFFALSE 58592
// bpoints := bpoints * 1.2 ;
58577: LD_ADDR_VAR 0 10
58581: PUSH
58582: LD_VAR 0 10
58586: PUSH
58587: LD_REAL  1.20000000000000E+0000
58590: MUL
58591: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58592: LD_VAR 0 6
58596: PPUSH
58597: CALL_OW 257
58601: PUSH
58602: LD_INT 5
58604: PUSH
58605: LD_INT 7
58607: PUSH
58608: LD_INT 9
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: LIST
58615: IN
58616: PUSH
58617: LD_VAR 0 1
58621: PPUSH
58622: LD_INT 52
58624: PPUSH
58625: CALL_OW 321
58629: PUSH
58630: LD_INT 2
58632: EQUAL
58633: AND
58634: IFFALSE 58651
// bpoints := bpoints * 1.5 ;
58636: LD_ADDR_VAR 0 10
58640: PUSH
58641: LD_VAR 0 10
58645: PUSH
58646: LD_REAL  1.50000000000000E+0000
58649: MUL
58650: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58651: LD_VAR 0 1
58655: PPUSH
58656: LD_INT 66
58658: PPUSH
58659: CALL_OW 321
58663: PUSH
58664: LD_INT 2
58666: EQUAL
58667: IFFALSE 58684
// bpoints := bpoints * 1.1 ;
58669: LD_ADDR_VAR 0 10
58673: PUSH
58674: LD_VAR 0 10
58678: PUSH
58679: LD_REAL  1.10000000000000E+0000
58682: MUL
58683: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58684: LD_ADDR_VAR 0 10
58688: PUSH
58689: LD_VAR 0 10
58693: PUSH
58694: LD_VAR 0 6
58698: PPUSH
58699: LD_INT 1
58701: PPUSH
58702: CALL_OW 259
58706: PUSH
58707: LD_REAL  1.15000000000000E+0000
58710: MUL
58711: MUL
58712: ST_TO_ADDR
// end ; unit_vehicle :
58713: GO 59541
58715: LD_INT 2
58717: DOUBLE
58718: EQUAL
58719: IFTRUE 58723
58721: GO 59529
58723: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58724: LD_VAR 0 6
58728: PPUSH
58729: CALL_OW 264
58733: PUSH
58734: LD_INT 2
58736: PUSH
58737: LD_INT 42
58739: PUSH
58740: LD_INT 24
58742: PUSH
58743: EMPTY
58744: LIST
58745: LIST
58746: LIST
58747: IN
58748: IFFALSE 58769
// points := [ 25 , 5 , 3 ] ;
58750: LD_ADDR_VAR 0 9
58754: PUSH
58755: LD_INT 25
58757: PUSH
58758: LD_INT 5
58760: PUSH
58761: LD_INT 3
58763: PUSH
58764: EMPTY
58765: LIST
58766: LIST
58767: LIST
58768: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58769: LD_VAR 0 6
58773: PPUSH
58774: CALL_OW 264
58778: PUSH
58779: LD_INT 4
58781: PUSH
58782: LD_INT 43
58784: PUSH
58785: LD_INT 25
58787: PUSH
58788: EMPTY
58789: LIST
58790: LIST
58791: LIST
58792: IN
58793: IFFALSE 58814
// points := [ 40 , 15 , 5 ] ;
58795: LD_ADDR_VAR 0 9
58799: PUSH
58800: LD_INT 40
58802: PUSH
58803: LD_INT 15
58805: PUSH
58806: LD_INT 5
58808: PUSH
58809: EMPTY
58810: LIST
58811: LIST
58812: LIST
58813: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58814: LD_VAR 0 6
58818: PPUSH
58819: CALL_OW 264
58823: PUSH
58824: LD_INT 3
58826: PUSH
58827: LD_INT 23
58829: PUSH
58830: EMPTY
58831: LIST
58832: LIST
58833: IN
58834: IFFALSE 58855
// points := [ 7 , 25 , 8 ] ;
58836: LD_ADDR_VAR 0 9
58840: PUSH
58841: LD_INT 7
58843: PUSH
58844: LD_INT 25
58846: PUSH
58847: LD_INT 8
58849: PUSH
58850: EMPTY
58851: LIST
58852: LIST
58853: LIST
58854: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58855: LD_VAR 0 6
58859: PPUSH
58860: CALL_OW 264
58864: PUSH
58865: LD_INT 5
58867: PUSH
58868: LD_INT 27
58870: PUSH
58871: LD_INT 44
58873: PUSH
58874: EMPTY
58875: LIST
58876: LIST
58877: LIST
58878: IN
58879: IFFALSE 58900
// points := [ 14 , 50 , 16 ] ;
58881: LD_ADDR_VAR 0 9
58885: PUSH
58886: LD_INT 14
58888: PUSH
58889: LD_INT 50
58891: PUSH
58892: LD_INT 16
58894: PUSH
58895: EMPTY
58896: LIST
58897: LIST
58898: LIST
58899: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58900: LD_VAR 0 6
58904: PPUSH
58905: CALL_OW 264
58909: PUSH
58910: LD_INT 6
58912: PUSH
58913: LD_INT 46
58915: PUSH
58916: EMPTY
58917: LIST
58918: LIST
58919: IN
58920: IFFALSE 58941
// points := [ 32 , 120 , 70 ] ;
58922: LD_ADDR_VAR 0 9
58926: PUSH
58927: LD_INT 32
58929: PUSH
58930: LD_INT 120
58932: PUSH
58933: LD_INT 70
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: LIST
58940: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58941: LD_VAR 0 6
58945: PPUSH
58946: CALL_OW 264
58950: PUSH
58951: LD_INT 7
58953: PUSH
58954: LD_INT 28
58956: PUSH
58957: LD_INT 45
58959: PUSH
58960: LD_INT 92
58962: PUSH
58963: EMPTY
58964: LIST
58965: LIST
58966: LIST
58967: LIST
58968: IN
58969: IFFALSE 58990
// points := [ 35 , 20 , 45 ] ;
58971: LD_ADDR_VAR 0 9
58975: PUSH
58976: LD_INT 35
58978: PUSH
58979: LD_INT 20
58981: PUSH
58982: LD_INT 45
58984: PUSH
58985: EMPTY
58986: LIST
58987: LIST
58988: LIST
58989: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58990: LD_VAR 0 6
58994: PPUSH
58995: CALL_OW 264
58999: PUSH
59000: LD_INT 47
59002: PUSH
59003: EMPTY
59004: LIST
59005: IN
59006: IFFALSE 59027
// points := [ 67 , 45 , 75 ] ;
59008: LD_ADDR_VAR 0 9
59012: PUSH
59013: LD_INT 67
59015: PUSH
59016: LD_INT 45
59018: PUSH
59019: LD_INT 75
59021: PUSH
59022: EMPTY
59023: LIST
59024: LIST
59025: LIST
59026: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59027: LD_VAR 0 6
59031: PPUSH
59032: CALL_OW 264
59036: PUSH
59037: LD_INT 26
59039: PUSH
59040: EMPTY
59041: LIST
59042: IN
59043: IFFALSE 59064
// points := [ 120 , 30 , 80 ] ;
59045: LD_ADDR_VAR 0 9
59049: PUSH
59050: LD_INT 120
59052: PUSH
59053: LD_INT 30
59055: PUSH
59056: LD_INT 80
59058: PUSH
59059: EMPTY
59060: LIST
59061: LIST
59062: LIST
59063: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59064: LD_VAR 0 6
59068: PPUSH
59069: CALL_OW 264
59073: PUSH
59074: LD_INT 22
59076: PUSH
59077: EMPTY
59078: LIST
59079: IN
59080: IFFALSE 59101
// points := [ 40 , 1 , 1 ] ;
59082: LD_ADDR_VAR 0 9
59086: PUSH
59087: LD_INT 40
59089: PUSH
59090: LD_INT 1
59092: PUSH
59093: LD_INT 1
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: LIST
59100: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59101: LD_VAR 0 6
59105: PPUSH
59106: CALL_OW 264
59110: PUSH
59111: LD_INT 29
59113: PUSH
59114: EMPTY
59115: LIST
59116: IN
59117: IFFALSE 59138
// points := [ 70 , 200 , 400 ] ;
59119: LD_ADDR_VAR 0 9
59123: PUSH
59124: LD_INT 70
59126: PUSH
59127: LD_INT 200
59129: PUSH
59130: LD_INT 400
59132: PUSH
59133: EMPTY
59134: LIST
59135: LIST
59136: LIST
59137: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59138: LD_VAR 0 6
59142: PPUSH
59143: CALL_OW 264
59147: PUSH
59148: LD_INT 14
59150: PUSH
59151: LD_INT 53
59153: PUSH
59154: EMPTY
59155: LIST
59156: LIST
59157: IN
59158: IFFALSE 59179
// points := [ 40 , 10 , 20 ] ;
59160: LD_ADDR_VAR 0 9
59164: PUSH
59165: LD_INT 40
59167: PUSH
59168: LD_INT 10
59170: PUSH
59171: LD_INT 20
59173: PUSH
59174: EMPTY
59175: LIST
59176: LIST
59177: LIST
59178: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59179: LD_VAR 0 6
59183: PPUSH
59184: CALL_OW 264
59188: PUSH
59189: LD_INT 9
59191: PUSH
59192: EMPTY
59193: LIST
59194: IN
59195: IFFALSE 59216
// points := [ 5 , 70 , 20 ] ;
59197: LD_ADDR_VAR 0 9
59201: PUSH
59202: LD_INT 5
59204: PUSH
59205: LD_INT 70
59207: PUSH
59208: LD_INT 20
59210: PUSH
59211: EMPTY
59212: LIST
59213: LIST
59214: LIST
59215: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59216: LD_VAR 0 6
59220: PPUSH
59221: CALL_OW 264
59225: PUSH
59226: LD_INT 10
59228: PUSH
59229: EMPTY
59230: LIST
59231: IN
59232: IFFALSE 59253
// points := [ 35 , 110 , 70 ] ;
59234: LD_ADDR_VAR 0 9
59238: PUSH
59239: LD_INT 35
59241: PUSH
59242: LD_INT 110
59244: PUSH
59245: LD_INT 70
59247: PUSH
59248: EMPTY
59249: LIST
59250: LIST
59251: LIST
59252: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59253: LD_VAR 0 6
59257: PPUSH
59258: CALL_OW 265
59262: PUSH
59263: LD_INT 25
59265: EQUAL
59266: IFFALSE 59287
// points := [ 80 , 65 , 100 ] ;
59268: LD_ADDR_VAR 0 9
59272: PUSH
59273: LD_INT 80
59275: PUSH
59276: LD_INT 65
59278: PUSH
59279: LD_INT 100
59281: PUSH
59282: EMPTY
59283: LIST
59284: LIST
59285: LIST
59286: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59287: LD_VAR 0 6
59291: PPUSH
59292: CALL_OW 263
59296: PUSH
59297: LD_INT 1
59299: EQUAL
59300: IFFALSE 59335
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59302: LD_ADDR_VAR 0 10
59306: PUSH
59307: LD_VAR 0 10
59311: PUSH
59312: LD_VAR 0 6
59316: PPUSH
59317: CALL_OW 311
59321: PPUSH
59322: LD_INT 3
59324: PPUSH
59325: CALL_OW 259
59329: PUSH
59330: LD_INT 4
59332: MUL
59333: MUL
59334: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59335: LD_VAR 0 6
59339: PPUSH
59340: CALL_OW 263
59344: PUSH
59345: LD_INT 2
59347: EQUAL
59348: IFFALSE 59399
// begin j := IsControledBy ( i ) ;
59350: LD_ADDR_VAR 0 7
59354: PUSH
59355: LD_VAR 0 6
59359: PPUSH
59360: CALL_OW 312
59364: ST_TO_ADDR
// if j then
59365: LD_VAR 0 7
59369: IFFALSE 59399
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59371: LD_ADDR_VAR 0 10
59375: PUSH
59376: LD_VAR 0 10
59380: PUSH
59381: LD_VAR 0 7
59385: PPUSH
59386: LD_INT 3
59388: PPUSH
59389: CALL_OW 259
59393: PUSH
59394: LD_INT 3
59396: MUL
59397: MUL
59398: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59399: LD_VAR 0 6
59403: PPUSH
59404: CALL_OW 264
59408: PUSH
59409: LD_INT 5
59411: PUSH
59412: LD_INT 6
59414: PUSH
59415: LD_INT 46
59417: PUSH
59418: LD_INT 44
59420: PUSH
59421: LD_INT 47
59423: PUSH
59424: LD_INT 45
59426: PUSH
59427: LD_INT 28
59429: PUSH
59430: LD_INT 7
59432: PUSH
59433: LD_INT 27
59435: PUSH
59436: LD_INT 29
59438: PUSH
59439: EMPTY
59440: LIST
59441: LIST
59442: LIST
59443: LIST
59444: LIST
59445: LIST
59446: LIST
59447: LIST
59448: LIST
59449: LIST
59450: IN
59451: PUSH
59452: LD_VAR 0 1
59456: PPUSH
59457: LD_INT 52
59459: PPUSH
59460: CALL_OW 321
59464: PUSH
59465: LD_INT 2
59467: EQUAL
59468: AND
59469: IFFALSE 59486
// bpoints := bpoints * 1.2 ;
59471: LD_ADDR_VAR 0 10
59475: PUSH
59476: LD_VAR 0 10
59480: PUSH
59481: LD_REAL  1.20000000000000E+0000
59484: MUL
59485: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59486: LD_VAR 0 6
59490: PPUSH
59491: CALL_OW 264
59495: PUSH
59496: LD_INT 6
59498: PUSH
59499: LD_INT 46
59501: PUSH
59502: LD_INT 47
59504: PUSH
59505: EMPTY
59506: LIST
59507: LIST
59508: LIST
59509: IN
59510: IFFALSE 59527
// bpoints := bpoints * 1.2 ;
59512: LD_ADDR_VAR 0 10
59516: PUSH
59517: LD_VAR 0 10
59521: PUSH
59522: LD_REAL  1.20000000000000E+0000
59525: MUL
59526: ST_TO_ADDR
// end ; unit_building :
59527: GO 59541
59529: LD_INT 3
59531: DOUBLE
59532: EQUAL
59533: IFTRUE 59537
59535: GO 59540
59537: POP
// ; end ;
59538: GO 59541
59540: POP
// for j = 1 to 3 do
59541: LD_ADDR_VAR 0 7
59545: PUSH
59546: DOUBLE
59547: LD_INT 1
59549: DEC
59550: ST_TO_ADDR
59551: LD_INT 3
59553: PUSH
59554: FOR_TO
59555: IFFALSE 59608
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59557: LD_ADDR_VAR 0 5
59561: PUSH
59562: LD_VAR 0 5
59566: PPUSH
59567: LD_VAR 0 7
59571: PPUSH
59572: LD_VAR 0 5
59576: PUSH
59577: LD_VAR 0 7
59581: ARRAY
59582: PUSH
59583: LD_VAR 0 9
59587: PUSH
59588: LD_VAR 0 7
59592: ARRAY
59593: PUSH
59594: LD_VAR 0 10
59598: MUL
59599: PLUS
59600: PPUSH
59601: CALL_OW 1
59605: ST_TO_ADDR
59606: GO 59554
59608: POP
59609: POP
// end ;
59610: GO 58089
59612: POP
59613: POP
// result := Replace ( result , 4 , tmp ) ;
59614: LD_ADDR_VAR 0 5
59618: PUSH
59619: LD_VAR 0 5
59623: PPUSH
59624: LD_INT 4
59626: PPUSH
59627: LD_VAR 0 8
59631: PPUSH
59632: CALL_OW 1
59636: ST_TO_ADDR
// end ;
59637: LD_VAR 0 5
59641: RET
// export function DangerAtRange ( unit , range ) ; begin
59642: LD_INT 0
59644: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59645: LD_ADDR_VAR 0 3
59649: PUSH
59650: LD_VAR 0 1
59654: PPUSH
59655: CALL_OW 255
59659: PPUSH
59660: LD_VAR 0 1
59664: PPUSH
59665: CALL_OW 250
59669: PPUSH
59670: LD_VAR 0 1
59674: PPUSH
59675: CALL_OW 251
59679: PPUSH
59680: LD_VAR 0 2
59684: PPUSH
59685: CALL 57941 0 4
59689: ST_TO_ADDR
// end ;
59690: LD_VAR 0 3
59694: RET
// export function DangerInArea ( side , area ) ; begin
59695: LD_INT 0
59697: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59698: LD_ADDR_VAR 0 3
59702: PUSH
59703: LD_VAR 0 2
59707: PPUSH
59708: LD_INT 81
59710: PUSH
59711: LD_VAR 0 1
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: PPUSH
59720: CALL_OW 70
59724: ST_TO_ADDR
// end ;
59725: LD_VAR 0 3
59729: RET
// export function IsExtension ( b ) ; begin
59730: LD_INT 0
59732: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59733: LD_ADDR_VAR 0 2
59737: PUSH
59738: LD_VAR 0 1
59742: PUSH
59743: LD_INT 23
59745: PUSH
59746: LD_INT 20
59748: PUSH
59749: LD_INT 22
59751: PUSH
59752: LD_INT 17
59754: PUSH
59755: LD_INT 24
59757: PUSH
59758: LD_INT 21
59760: PUSH
59761: LD_INT 19
59763: PUSH
59764: LD_INT 16
59766: PUSH
59767: LD_INT 25
59769: PUSH
59770: LD_INT 18
59772: PUSH
59773: EMPTY
59774: LIST
59775: LIST
59776: LIST
59777: LIST
59778: LIST
59779: LIST
59780: LIST
59781: LIST
59782: LIST
59783: LIST
59784: IN
59785: ST_TO_ADDR
// end ;
59786: LD_VAR 0 2
59790: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59791: LD_INT 0
59793: PPUSH
59794: PPUSH
59795: PPUSH
// result := [ ] ;
59796: LD_ADDR_VAR 0 4
59800: PUSH
59801: EMPTY
59802: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59803: LD_ADDR_VAR 0 5
59807: PUSH
59808: LD_VAR 0 2
59812: PPUSH
59813: LD_INT 21
59815: PUSH
59816: LD_INT 3
59818: PUSH
59819: EMPTY
59820: LIST
59821: LIST
59822: PPUSH
59823: CALL_OW 70
59827: ST_TO_ADDR
// if not tmp then
59828: LD_VAR 0 5
59832: NOT
59833: IFFALSE 59837
// exit ;
59835: GO 59901
// if checkLink then
59837: LD_VAR 0 3
59841: IFFALSE 59891
// begin for i in tmp do
59843: LD_ADDR_VAR 0 6
59847: PUSH
59848: LD_VAR 0 5
59852: PUSH
59853: FOR_IN
59854: IFFALSE 59889
// if GetBase ( i ) <> base then
59856: LD_VAR 0 6
59860: PPUSH
59861: CALL_OW 274
59865: PUSH
59866: LD_VAR 0 1
59870: NONEQUAL
59871: IFFALSE 59887
// ComLinkToBase ( base , i ) ;
59873: LD_VAR 0 1
59877: PPUSH
59878: LD_VAR 0 6
59882: PPUSH
59883: CALL_OW 169
59887: GO 59853
59889: POP
59890: POP
// end ; result := tmp ;
59891: LD_ADDR_VAR 0 4
59895: PUSH
59896: LD_VAR 0 5
59900: ST_TO_ADDR
// end ;
59901: LD_VAR 0 4
59905: RET
// export function ComComplete ( units , b ) ; var i ; begin
59906: LD_INT 0
59908: PPUSH
59909: PPUSH
// if not units then
59910: LD_VAR 0 1
59914: NOT
59915: IFFALSE 59919
// exit ;
59917: GO 60009
// for i in units do
59919: LD_ADDR_VAR 0 4
59923: PUSH
59924: LD_VAR 0 1
59928: PUSH
59929: FOR_IN
59930: IFFALSE 60007
// if BuildingStatus ( b ) = bs_build then
59932: LD_VAR 0 2
59936: PPUSH
59937: CALL_OW 461
59941: PUSH
59942: LD_INT 1
59944: EQUAL
59945: IFFALSE 60005
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59947: LD_VAR 0 4
59951: PPUSH
59952: LD_STRING h
59954: PUSH
59955: LD_VAR 0 2
59959: PPUSH
59960: CALL_OW 250
59964: PUSH
59965: LD_VAR 0 2
59969: PPUSH
59970: CALL_OW 251
59974: PUSH
59975: LD_VAR 0 2
59979: PUSH
59980: LD_INT 0
59982: PUSH
59983: LD_INT 0
59985: PUSH
59986: LD_INT 0
59988: PUSH
59989: EMPTY
59990: LIST
59991: LIST
59992: LIST
59993: LIST
59994: LIST
59995: LIST
59996: LIST
59997: PUSH
59998: EMPTY
59999: LIST
60000: PPUSH
60001: CALL_OW 446
60005: GO 59929
60007: POP
60008: POP
// end ;
60009: LD_VAR 0 3
60013: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60014: LD_INT 0
60016: PPUSH
60017: PPUSH
60018: PPUSH
60019: PPUSH
60020: PPUSH
60021: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
60022: LD_VAR 0 1
60026: NOT
60027: PUSH
60028: LD_VAR 0 1
60032: PPUSH
60033: CALL_OW 263
60037: PUSH
60038: LD_INT 2
60040: NONEQUAL
60041: OR
60042: IFFALSE 60046
// exit ;
60044: GO 60362
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60046: LD_ADDR_VAR 0 6
60050: PUSH
60051: LD_INT 22
60053: PUSH
60054: LD_VAR 0 1
60058: PPUSH
60059: CALL_OW 255
60063: PUSH
60064: EMPTY
60065: LIST
60066: LIST
60067: PUSH
60068: LD_INT 2
60070: PUSH
60071: LD_INT 30
60073: PUSH
60074: LD_INT 36
60076: PUSH
60077: EMPTY
60078: LIST
60079: LIST
60080: PUSH
60081: LD_INT 34
60083: PUSH
60084: LD_INT 31
60086: PUSH
60087: EMPTY
60088: LIST
60089: LIST
60090: PUSH
60091: EMPTY
60092: LIST
60093: LIST
60094: LIST
60095: PUSH
60096: EMPTY
60097: LIST
60098: LIST
60099: PPUSH
60100: CALL_OW 69
60104: ST_TO_ADDR
// if not tmp then
60105: LD_VAR 0 6
60109: NOT
60110: IFFALSE 60114
// exit ;
60112: GO 60362
// result := [ ] ;
60114: LD_ADDR_VAR 0 2
60118: PUSH
60119: EMPTY
60120: ST_TO_ADDR
// for i in tmp do
60121: LD_ADDR_VAR 0 3
60125: PUSH
60126: LD_VAR 0 6
60130: PUSH
60131: FOR_IN
60132: IFFALSE 60203
// begin t := UnitsInside ( i ) ;
60134: LD_ADDR_VAR 0 4
60138: PUSH
60139: LD_VAR 0 3
60143: PPUSH
60144: CALL_OW 313
60148: ST_TO_ADDR
// if t then
60149: LD_VAR 0 4
60153: IFFALSE 60201
// for j in t do
60155: LD_ADDR_VAR 0 7
60159: PUSH
60160: LD_VAR 0 4
60164: PUSH
60165: FOR_IN
60166: IFFALSE 60199
// result := Replace ( result , result + 1 , j ) ;
60168: LD_ADDR_VAR 0 2
60172: PUSH
60173: LD_VAR 0 2
60177: PPUSH
60178: LD_VAR 0 2
60182: PUSH
60183: LD_INT 1
60185: PLUS
60186: PPUSH
60187: LD_VAR 0 7
60191: PPUSH
60192: CALL_OW 1
60196: ST_TO_ADDR
60197: GO 60165
60199: POP
60200: POP
// end ;
60201: GO 60131
60203: POP
60204: POP
// if not result then
60205: LD_VAR 0 2
60209: NOT
60210: IFFALSE 60214
// exit ;
60212: GO 60362
// mech := result [ 1 ] ;
60214: LD_ADDR_VAR 0 5
60218: PUSH
60219: LD_VAR 0 2
60223: PUSH
60224: LD_INT 1
60226: ARRAY
60227: ST_TO_ADDR
// if result > 1 then
60228: LD_VAR 0 2
60232: PUSH
60233: LD_INT 1
60235: GREATER
60236: IFFALSE 60348
// begin for i = 2 to result do
60238: LD_ADDR_VAR 0 3
60242: PUSH
60243: DOUBLE
60244: LD_INT 2
60246: DEC
60247: ST_TO_ADDR
60248: LD_VAR 0 2
60252: PUSH
60253: FOR_TO
60254: IFFALSE 60346
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60256: LD_ADDR_VAR 0 4
60260: PUSH
60261: LD_VAR 0 2
60265: PUSH
60266: LD_VAR 0 3
60270: ARRAY
60271: PPUSH
60272: LD_INT 3
60274: PPUSH
60275: CALL_OW 259
60279: PUSH
60280: LD_VAR 0 2
60284: PUSH
60285: LD_VAR 0 3
60289: ARRAY
60290: PPUSH
60291: CALL_OW 432
60295: MINUS
60296: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60297: LD_VAR 0 4
60301: PUSH
60302: LD_VAR 0 5
60306: PPUSH
60307: LD_INT 3
60309: PPUSH
60310: CALL_OW 259
60314: PUSH
60315: LD_VAR 0 5
60319: PPUSH
60320: CALL_OW 432
60324: MINUS
60325: GREATEREQUAL
60326: IFFALSE 60344
// mech := result [ i ] ;
60328: LD_ADDR_VAR 0 5
60332: PUSH
60333: LD_VAR 0 2
60337: PUSH
60338: LD_VAR 0 3
60342: ARRAY
60343: ST_TO_ADDR
// end ;
60344: GO 60253
60346: POP
60347: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60348: LD_VAR 0 1
60352: PPUSH
60353: LD_VAR 0 5
60357: PPUSH
60358: CALL_OW 135
// end ;
60362: LD_VAR 0 2
60366: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60367: LD_INT 0
60369: PPUSH
60370: PPUSH
60371: PPUSH
60372: PPUSH
60373: PPUSH
60374: PPUSH
60375: PPUSH
60376: PPUSH
60377: PPUSH
60378: PPUSH
60379: PPUSH
60380: PPUSH
60381: PPUSH
// result := [ ] ;
60382: LD_ADDR_VAR 0 7
60386: PUSH
60387: EMPTY
60388: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60389: LD_VAR 0 1
60393: PPUSH
60394: CALL_OW 266
60398: PUSH
60399: LD_INT 0
60401: PUSH
60402: LD_INT 1
60404: PUSH
60405: EMPTY
60406: LIST
60407: LIST
60408: IN
60409: NOT
60410: IFFALSE 60414
// exit ;
60412: GO 62048
// if name then
60414: LD_VAR 0 3
60418: IFFALSE 60434
// SetBName ( base_dep , name ) ;
60420: LD_VAR 0 1
60424: PPUSH
60425: LD_VAR 0 3
60429: PPUSH
60430: CALL_OW 500
// base := GetBase ( base_dep ) ;
60434: LD_ADDR_VAR 0 15
60438: PUSH
60439: LD_VAR 0 1
60443: PPUSH
60444: CALL_OW 274
60448: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60449: LD_ADDR_VAR 0 16
60453: PUSH
60454: LD_VAR 0 1
60458: PPUSH
60459: CALL_OW 255
60463: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60464: LD_ADDR_VAR 0 17
60468: PUSH
60469: LD_VAR 0 1
60473: PPUSH
60474: CALL_OW 248
60478: ST_TO_ADDR
// if sources then
60479: LD_VAR 0 5
60483: IFFALSE 60530
// for i = 1 to 3 do
60485: LD_ADDR_VAR 0 8
60489: PUSH
60490: DOUBLE
60491: LD_INT 1
60493: DEC
60494: ST_TO_ADDR
60495: LD_INT 3
60497: PUSH
60498: FOR_TO
60499: IFFALSE 60528
// AddResourceType ( base , i , sources [ i ] ) ;
60501: LD_VAR 0 15
60505: PPUSH
60506: LD_VAR 0 8
60510: PPUSH
60511: LD_VAR 0 5
60515: PUSH
60516: LD_VAR 0 8
60520: ARRAY
60521: PPUSH
60522: CALL_OW 276
60526: GO 60498
60528: POP
60529: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60530: LD_ADDR_VAR 0 18
60534: PUSH
60535: LD_VAR 0 15
60539: PPUSH
60540: LD_VAR 0 2
60544: PPUSH
60545: LD_INT 1
60547: PPUSH
60548: CALL 59791 0 3
60552: ST_TO_ADDR
// InitHc ;
60553: CALL_OW 19
// InitUc ;
60557: CALL_OW 18
// uc_side := side ;
60561: LD_ADDR_OWVAR 20
60565: PUSH
60566: LD_VAR 0 16
60570: ST_TO_ADDR
// uc_nation := nation ;
60571: LD_ADDR_OWVAR 21
60575: PUSH
60576: LD_VAR 0 17
60580: ST_TO_ADDR
// if buildings then
60581: LD_VAR 0 18
60585: IFFALSE 61907
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60587: LD_ADDR_VAR 0 19
60591: PUSH
60592: LD_VAR 0 18
60596: PPUSH
60597: LD_INT 2
60599: PUSH
60600: LD_INT 30
60602: PUSH
60603: LD_INT 29
60605: PUSH
60606: EMPTY
60607: LIST
60608: LIST
60609: PUSH
60610: LD_INT 30
60612: PUSH
60613: LD_INT 30
60615: PUSH
60616: EMPTY
60617: LIST
60618: LIST
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: LIST
60624: PPUSH
60625: CALL_OW 72
60629: ST_TO_ADDR
// if tmp then
60630: LD_VAR 0 19
60634: IFFALSE 60682
// for i in tmp do
60636: LD_ADDR_VAR 0 8
60640: PUSH
60641: LD_VAR 0 19
60645: PUSH
60646: FOR_IN
60647: IFFALSE 60680
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60649: LD_VAR 0 8
60653: PPUSH
60654: CALL_OW 250
60658: PPUSH
60659: LD_VAR 0 8
60663: PPUSH
60664: CALL_OW 251
60668: PPUSH
60669: LD_VAR 0 16
60673: PPUSH
60674: CALL_OW 441
60678: GO 60646
60680: POP
60681: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60682: LD_VAR 0 18
60686: PPUSH
60687: LD_INT 2
60689: PUSH
60690: LD_INT 30
60692: PUSH
60693: LD_INT 32
60695: PUSH
60696: EMPTY
60697: LIST
60698: LIST
60699: PUSH
60700: LD_INT 30
60702: PUSH
60703: LD_INT 33
60705: PUSH
60706: EMPTY
60707: LIST
60708: LIST
60709: PUSH
60710: EMPTY
60711: LIST
60712: LIST
60713: LIST
60714: PPUSH
60715: CALL_OW 72
60719: IFFALSE 60807
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60721: LD_ADDR_VAR 0 8
60725: PUSH
60726: LD_VAR 0 18
60730: PPUSH
60731: LD_INT 2
60733: PUSH
60734: LD_INT 30
60736: PUSH
60737: LD_INT 32
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: PUSH
60744: LD_INT 30
60746: PUSH
60747: LD_INT 33
60749: PUSH
60750: EMPTY
60751: LIST
60752: LIST
60753: PUSH
60754: EMPTY
60755: LIST
60756: LIST
60757: LIST
60758: PPUSH
60759: CALL_OW 72
60763: PUSH
60764: FOR_IN
60765: IFFALSE 60805
// begin if not GetBWeapon ( i ) then
60767: LD_VAR 0 8
60771: PPUSH
60772: CALL_OW 269
60776: NOT
60777: IFFALSE 60803
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60779: LD_VAR 0 8
60783: PPUSH
60784: LD_VAR 0 8
60788: PPUSH
60789: LD_VAR 0 2
60793: PPUSH
60794: CALL 62053 0 2
60798: PPUSH
60799: CALL_OW 431
// end ;
60803: GO 60764
60805: POP
60806: POP
// end ; for i = 1 to personel do
60807: LD_ADDR_VAR 0 8
60811: PUSH
60812: DOUBLE
60813: LD_INT 1
60815: DEC
60816: ST_TO_ADDR
60817: LD_VAR 0 6
60821: PUSH
60822: FOR_TO
60823: IFFALSE 61887
// begin if i > 4 then
60825: LD_VAR 0 8
60829: PUSH
60830: LD_INT 4
60832: GREATER
60833: IFFALSE 60837
// break ;
60835: GO 61887
// case i of 1 :
60837: LD_VAR 0 8
60841: PUSH
60842: LD_INT 1
60844: DOUBLE
60845: EQUAL
60846: IFTRUE 60850
60848: GO 60930
60850: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60851: LD_ADDR_VAR 0 12
60855: PUSH
60856: LD_VAR 0 18
60860: PPUSH
60861: LD_INT 22
60863: PUSH
60864: LD_VAR 0 16
60868: PUSH
60869: EMPTY
60870: LIST
60871: LIST
60872: PUSH
60873: LD_INT 58
60875: PUSH
60876: EMPTY
60877: LIST
60878: PUSH
60879: LD_INT 2
60881: PUSH
60882: LD_INT 30
60884: PUSH
60885: LD_INT 32
60887: PUSH
60888: EMPTY
60889: LIST
60890: LIST
60891: PUSH
60892: LD_INT 30
60894: PUSH
60895: LD_INT 4
60897: PUSH
60898: EMPTY
60899: LIST
60900: LIST
60901: PUSH
60902: LD_INT 30
60904: PUSH
60905: LD_INT 5
60907: PUSH
60908: EMPTY
60909: LIST
60910: LIST
60911: PUSH
60912: EMPTY
60913: LIST
60914: LIST
60915: LIST
60916: LIST
60917: PUSH
60918: EMPTY
60919: LIST
60920: LIST
60921: LIST
60922: PPUSH
60923: CALL_OW 72
60927: ST_TO_ADDR
60928: GO 61152
60930: LD_INT 2
60932: DOUBLE
60933: EQUAL
60934: IFTRUE 60938
60936: GO 61000
60938: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60939: LD_ADDR_VAR 0 12
60943: PUSH
60944: LD_VAR 0 18
60948: PPUSH
60949: LD_INT 22
60951: PUSH
60952: LD_VAR 0 16
60956: PUSH
60957: EMPTY
60958: LIST
60959: LIST
60960: PUSH
60961: LD_INT 2
60963: PUSH
60964: LD_INT 30
60966: PUSH
60967: LD_INT 0
60969: PUSH
60970: EMPTY
60971: LIST
60972: LIST
60973: PUSH
60974: LD_INT 30
60976: PUSH
60977: LD_INT 1
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: PUSH
60984: EMPTY
60985: LIST
60986: LIST
60987: LIST
60988: PUSH
60989: EMPTY
60990: LIST
60991: LIST
60992: PPUSH
60993: CALL_OW 72
60997: ST_TO_ADDR
60998: GO 61152
61000: LD_INT 3
61002: DOUBLE
61003: EQUAL
61004: IFTRUE 61008
61006: GO 61070
61008: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61009: LD_ADDR_VAR 0 12
61013: PUSH
61014: LD_VAR 0 18
61018: PPUSH
61019: LD_INT 22
61021: PUSH
61022: LD_VAR 0 16
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PUSH
61031: LD_INT 2
61033: PUSH
61034: LD_INT 30
61036: PUSH
61037: LD_INT 2
61039: PUSH
61040: EMPTY
61041: LIST
61042: LIST
61043: PUSH
61044: LD_INT 30
61046: PUSH
61047: LD_INT 3
61049: PUSH
61050: EMPTY
61051: LIST
61052: LIST
61053: PUSH
61054: EMPTY
61055: LIST
61056: LIST
61057: LIST
61058: PUSH
61059: EMPTY
61060: LIST
61061: LIST
61062: PPUSH
61063: CALL_OW 72
61067: ST_TO_ADDR
61068: GO 61152
61070: LD_INT 4
61072: DOUBLE
61073: EQUAL
61074: IFTRUE 61078
61076: GO 61151
61078: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61079: LD_ADDR_VAR 0 12
61083: PUSH
61084: LD_VAR 0 18
61088: PPUSH
61089: LD_INT 22
61091: PUSH
61092: LD_VAR 0 16
61096: PUSH
61097: EMPTY
61098: LIST
61099: LIST
61100: PUSH
61101: LD_INT 2
61103: PUSH
61104: LD_INT 30
61106: PUSH
61107: LD_INT 6
61109: PUSH
61110: EMPTY
61111: LIST
61112: LIST
61113: PUSH
61114: LD_INT 30
61116: PUSH
61117: LD_INT 7
61119: PUSH
61120: EMPTY
61121: LIST
61122: LIST
61123: PUSH
61124: LD_INT 30
61126: PUSH
61127: LD_INT 8
61129: PUSH
61130: EMPTY
61131: LIST
61132: LIST
61133: PUSH
61134: EMPTY
61135: LIST
61136: LIST
61137: LIST
61138: LIST
61139: PUSH
61140: EMPTY
61141: LIST
61142: LIST
61143: PPUSH
61144: CALL_OW 72
61148: ST_TO_ADDR
61149: GO 61152
61151: POP
// if i = 1 then
61152: LD_VAR 0 8
61156: PUSH
61157: LD_INT 1
61159: EQUAL
61160: IFFALSE 61271
// begin tmp := [ ] ;
61162: LD_ADDR_VAR 0 19
61166: PUSH
61167: EMPTY
61168: ST_TO_ADDR
// for j in f do
61169: LD_ADDR_VAR 0 9
61173: PUSH
61174: LD_VAR 0 12
61178: PUSH
61179: FOR_IN
61180: IFFALSE 61253
// if GetBType ( j ) = b_bunker then
61182: LD_VAR 0 9
61186: PPUSH
61187: CALL_OW 266
61191: PUSH
61192: LD_INT 32
61194: EQUAL
61195: IFFALSE 61222
// tmp := Insert ( tmp , 1 , j ) else
61197: LD_ADDR_VAR 0 19
61201: PUSH
61202: LD_VAR 0 19
61206: PPUSH
61207: LD_INT 1
61209: PPUSH
61210: LD_VAR 0 9
61214: PPUSH
61215: CALL_OW 2
61219: ST_TO_ADDR
61220: GO 61251
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61222: LD_ADDR_VAR 0 19
61226: PUSH
61227: LD_VAR 0 19
61231: PPUSH
61232: LD_VAR 0 19
61236: PUSH
61237: LD_INT 1
61239: PLUS
61240: PPUSH
61241: LD_VAR 0 9
61245: PPUSH
61246: CALL_OW 2
61250: ST_TO_ADDR
61251: GO 61179
61253: POP
61254: POP
// if tmp then
61255: LD_VAR 0 19
61259: IFFALSE 61271
// f := tmp ;
61261: LD_ADDR_VAR 0 12
61265: PUSH
61266: LD_VAR 0 19
61270: ST_TO_ADDR
// end ; x := personel [ i ] ;
61271: LD_ADDR_VAR 0 13
61275: PUSH
61276: LD_VAR 0 6
61280: PUSH
61281: LD_VAR 0 8
61285: ARRAY
61286: ST_TO_ADDR
// if x = - 1 then
61287: LD_VAR 0 13
61291: PUSH
61292: LD_INT 1
61294: NEG
61295: EQUAL
61296: IFFALSE 61505
// begin for j in f do
61298: LD_ADDR_VAR 0 9
61302: PUSH
61303: LD_VAR 0 12
61307: PUSH
61308: FOR_IN
61309: IFFALSE 61501
// repeat InitHc ;
61311: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61315: LD_VAR 0 9
61319: PPUSH
61320: CALL_OW 266
61324: PUSH
61325: LD_INT 5
61327: EQUAL
61328: IFFALSE 61398
// begin if UnitsInside ( j ) < 3 then
61330: LD_VAR 0 9
61334: PPUSH
61335: CALL_OW 313
61339: PUSH
61340: LD_INT 3
61342: LESS
61343: IFFALSE 61379
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61345: LD_INT 0
61347: PPUSH
61348: LD_INT 5
61350: PUSH
61351: LD_INT 8
61353: PUSH
61354: LD_INT 9
61356: PUSH
61357: EMPTY
61358: LIST
61359: LIST
61360: LIST
61361: PUSH
61362: LD_VAR 0 17
61366: ARRAY
61367: PPUSH
61368: LD_VAR 0 4
61372: PPUSH
61373: CALL_OW 380
61377: GO 61396
// PrepareHuman ( false , i , skill ) ;
61379: LD_INT 0
61381: PPUSH
61382: LD_VAR 0 8
61386: PPUSH
61387: LD_VAR 0 4
61391: PPUSH
61392: CALL_OW 380
// end else
61396: GO 61415
// PrepareHuman ( false , i , skill ) ;
61398: LD_INT 0
61400: PPUSH
61401: LD_VAR 0 8
61405: PPUSH
61406: LD_VAR 0 4
61410: PPUSH
61411: CALL_OW 380
// un := CreateHuman ;
61415: LD_ADDR_VAR 0 14
61419: PUSH
61420: CALL_OW 44
61424: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61425: LD_ADDR_VAR 0 7
61429: PUSH
61430: LD_VAR 0 7
61434: PPUSH
61435: LD_INT 1
61437: PPUSH
61438: LD_VAR 0 14
61442: PPUSH
61443: CALL_OW 2
61447: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61448: LD_VAR 0 14
61452: PPUSH
61453: LD_VAR 0 9
61457: PPUSH
61458: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61462: LD_VAR 0 9
61466: PPUSH
61467: CALL_OW 313
61471: PUSH
61472: LD_INT 6
61474: EQUAL
61475: PUSH
61476: LD_VAR 0 9
61480: PPUSH
61481: CALL_OW 266
61485: PUSH
61486: LD_INT 32
61488: PUSH
61489: LD_INT 31
61491: PUSH
61492: EMPTY
61493: LIST
61494: LIST
61495: IN
61496: OR
61497: IFFALSE 61311
61499: GO 61308
61501: POP
61502: POP
// end else
61503: GO 61885
// for j = 1 to x do
61505: LD_ADDR_VAR 0 9
61509: PUSH
61510: DOUBLE
61511: LD_INT 1
61513: DEC
61514: ST_TO_ADDR
61515: LD_VAR 0 13
61519: PUSH
61520: FOR_TO
61521: IFFALSE 61883
// begin InitHc ;
61523: CALL_OW 19
// if not f then
61527: LD_VAR 0 12
61531: NOT
61532: IFFALSE 61621
// begin PrepareHuman ( false , i , skill ) ;
61534: LD_INT 0
61536: PPUSH
61537: LD_VAR 0 8
61541: PPUSH
61542: LD_VAR 0 4
61546: PPUSH
61547: CALL_OW 380
// un := CreateHuman ;
61551: LD_ADDR_VAR 0 14
61555: PUSH
61556: CALL_OW 44
61560: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61561: LD_ADDR_VAR 0 7
61565: PUSH
61566: LD_VAR 0 7
61570: PPUSH
61571: LD_INT 1
61573: PPUSH
61574: LD_VAR 0 14
61578: PPUSH
61579: CALL_OW 2
61583: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61584: LD_VAR 0 14
61588: PPUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: CALL_OW 250
61598: PPUSH
61599: LD_VAR 0 1
61603: PPUSH
61604: CALL_OW 251
61608: PPUSH
61609: LD_INT 10
61611: PPUSH
61612: LD_INT 0
61614: PPUSH
61615: CALL_OW 50
// continue ;
61619: GO 61520
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61621: LD_VAR 0 12
61625: PUSH
61626: LD_INT 1
61628: ARRAY
61629: PPUSH
61630: CALL_OW 313
61634: PUSH
61635: LD_VAR 0 12
61639: PUSH
61640: LD_INT 1
61642: ARRAY
61643: PPUSH
61644: CALL_OW 266
61648: PUSH
61649: LD_INT 32
61651: PUSH
61652: LD_INT 31
61654: PUSH
61655: EMPTY
61656: LIST
61657: LIST
61658: IN
61659: AND
61660: PUSH
61661: LD_VAR 0 12
61665: PUSH
61666: LD_INT 1
61668: ARRAY
61669: PPUSH
61670: CALL_OW 313
61674: PUSH
61675: LD_INT 6
61677: EQUAL
61678: OR
61679: IFFALSE 61699
// f := Delete ( f , 1 ) ;
61681: LD_ADDR_VAR 0 12
61685: PUSH
61686: LD_VAR 0 12
61690: PPUSH
61691: LD_INT 1
61693: PPUSH
61694: CALL_OW 3
61698: ST_TO_ADDR
// if not f then
61699: LD_VAR 0 12
61703: NOT
61704: IFFALSE 61722
// begin x := x + 2 ;
61706: LD_ADDR_VAR 0 13
61710: PUSH
61711: LD_VAR 0 13
61715: PUSH
61716: LD_INT 2
61718: PLUS
61719: ST_TO_ADDR
// continue ;
61720: GO 61520
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61722: LD_VAR 0 12
61726: PUSH
61727: LD_INT 1
61729: ARRAY
61730: PPUSH
61731: CALL_OW 266
61735: PUSH
61736: LD_INT 5
61738: EQUAL
61739: IFFALSE 61813
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61741: LD_VAR 0 12
61745: PUSH
61746: LD_INT 1
61748: ARRAY
61749: PPUSH
61750: CALL_OW 313
61754: PUSH
61755: LD_INT 3
61757: LESS
61758: IFFALSE 61794
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61760: LD_INT 0
61762: PPUSH
61763: LD_INT 5
61765: PUSH
61766: LD_INT 8
61768: PUSH
61769: LD_INT 9
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: LIST
61776: PUSH
61777: LD_VAR 0 17
61781: ARRAY
61782: PPUSH
61783: LD_VAR 0 4
61787: PPUSH
61788: CALL_OW 380
61792: GO 61811
// PrepareHuman ( false , i , skill ) ;
61794: LD_INT 0
61796: PPUSH
61797: LD_VAR 0 8
61801: PPUSH
61802: LD_VAR 0 4
61806: PPUSH
61807: CALL_OW 380
// end else
61811: GO 61830
// PrepareHuman ( false , i , skill ) ;
61813: LD_INT 0
61815: PPUSH
61816: LD_VAR 0 8
61820: PPUSH
61821: LD_VAR 0 4
61825: PPUSH
61826: CALL_OW 380
// un := CreateHuman ;
61830: LD_ADDR_VAR 0 14
61834: PUSH
61835: CALL_OW 44
61839: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61840: LD_ADDR_VAR 0 7
61844: PUSH
61845: LD_VAR 0 7
61849: PPUSH
61850: LD_INT 1
61852: PPUSH
61853: LD_VAR 0 14
61857: PPUSH
61858: CALL_OW 2
61862: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61863: LD_VAR 0 14
61867: PPUSH
61868: LD_VAR 0 12
61872: PUSH
61873: LD_INT 1
61875: ARRAY
61876: PPUSH
61877: CALL_OW 52
// end ;
61881: GO 61520
61883: POP
61884: POP
// end ;
61885: GO 60822
61887: POP
61888: POP
// result := result ^ buildings ;
61889: LD_ADDR_VAR 0 7
61893: PUSH
61894: LD_VAR 0 7
61898: PUSH
61899: LD_VAR 0 18
61903: ADD
61904: ST_TO_ADDR
// end else
61905: GO 62048
// begin for i = 1 to personel do
61907: LD_ADDR_VAR 0 8
61911: PUSH
61912: DOUBLE
61913: LD_INT 1
61915: DEC
61916: ST_TO_ADDR
61917: LD_VAR 0 6
61921: PUSH
61922: FOR_TO
61923: IFFALSE 62046
// begin if i > 4 then
61925: LD_VAR 0 8
61929: PUSH
61930: LD_INT 4
61932: GREATER
61933: IFFALSE 61937
// break ;
61935: GO 62046
// x := personel [ i ] ;
61937: LD_ADDR_VAR 0 13
61941: PUSH
61942: LD_VAR 0 6
61946: PUSH
61947: LD_VAR 0 8
61951: ARRAY
61952: ST_TO_ADDR
// if x = - 1 then
61953: LD_VAR 0 13
61957: PUSH
61958: LD_INT 1
61960: NEG
61961: EQUAL
61962: IFFALSE 61966
// continue ;
61964: GO 61922
// PrepareHuman ( false , i , skill ) ;
61966: LD_INT 0
61968: PPUSH
61969: LD_VAR 0 8
61973: PPUSH
61974: LD_VAR 0 4
61978: PPUSH
61979: CALL_OW 380
// un := CreateHuman ;
61983: LD_ADDR_VAR 0 14
61987: PUSH
61988: CALL_OW 44
61992: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61993: LD_VAR 0 14
61997: PPUSH
61998: LD_VAR 0 1
62002: PPUSH
62003: CALL_OW 250
62007: PPUSH
62008: LD_VAR 0 1
62012: PPUSH
62013: CALL_OW 251
62017: PPUSH
62018: LD_INT 10
62020: PPUSH
62021: LD_INT 0
62023: PPUSH
62024: CALL_OW 50
// result := result ^ un ;
62028: LD_ADDR_VAR 0 7
62032: PUSH
62033: LD_VAR 0 7
62037: PUSH
62038: LD_VAR 0 14
62042: ADD
62043: ST_TO_ADDR
// end ;
62044: GO 61922
62046: POP
62047: POP
// end ; end ;
62048: LD_VAR 0 7
62052: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62053: LD_INT 0
62055: PPUSH
62056: PPUSH
62057: PPUSH
62058: PPUSH
62059: PPUSH
62060: PPUSH
62061: PPUSH
62062: PPUSH
62063: PPUSH
62064: PPUSH
62065: PPUSH
62066: PPUSH
62067: PPUSH
62068: PPUSH
62069: PPUSH
62070: PPUSH
// result := false ;
62071: LD_ADDR_VAR 0 3
62075: PUSH
62076: LD_INT 0
62078: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62079: LD_VAR 0 1
62083: NOT
62084: PUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: CALL_OW 266
62094: PUSH
62095: LD_INT 32
62097: PUSH
62098: LD_INT 33
62100: PUSH
62101: EMPTY
62102: LIST
62103: LIST
62104: IN
62105: NOT
62106: OR
62107: IFFALSE 62111
// exit ;
62109: GO 63220
// nat := GetNation ( tower ) ;
62111: LD_ADDR_VAR 0 12
62115: PUSH
62116: LD_VAR 0 1
62120: PPUSH
62121: CALL_OW 248
62125: ST_TO_ADDR
// side := GetSide ( tower ) ;
62126: LD_ADDR_VAR 0 16
62130: PUSH
62131: LD_VAR 0 1
62135: PPUSH
62136: CALL_OW 255
62140: ST_TO_ADDR
// x := GetX ( tower ) ;
62141: LD_ADDR_VAR 0 10
62145: PUSH
62146: LD_VAR 0 1
62150: PPUSH
62151: CALL_OW 250
62155: ST_TO_ADDR
// y := GetY ( tower ) ;
62156: LD_ADDR_VAR 0 11
62160: PUSH
62161: LD_VAR 0 1
62165: PPUSH
62166: CALL_OW 251
62170: ST_TO_ADDR
// if not x or not y then
62171: LD_VAR 0 10
62175: NOT
62176: PUSH
62177: LD_VAR 0 11
62181: NOT
62182: OR
62183: IFFALSE 62187
// exit ;
62185: GO 63220
// weapon := 0 ;
62187: LD_ADDR_VAR 0 18
62191: PUSH
62192: LD_INT 0
62194: ST_TO_ADDR
// fac_list := [ ] ;
62195: LD_ADDR_VAR 0 17
62199: PUSH
62200: EMPTY
62201: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62202: LD_ADDR_VAR 0 6
62206: PUSH
62207: LD_VAR 0 1
62211: PPUSH
62212: CALL_OW 274
62216: PPUSH
62217: LD_VAR 0 2
62221: PPUSH
62222: LD_INT 0
62224: PPUSH
62225: CALL 59791 0 3
62229: PPUSH
62230: LD_INT 30
62232: PUSH
62233: LD_INT 3
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: PPUSH
62240: CALL_OW 72
62244: ST_TO_ADDR
// if not factories then
62245: LD_VAR 0 6
62249: NOT
62250: IFFALSE 62254
// exit ;
62252: GO 63220
// for i in factories do
62254: LD_ADDR_VAR 0 8
62258: PUSH
62259: LD_VAR 0 6
62263: PUSH
62264: FOR_IN
62265: IFFALSE 62290
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62267: LD_ADDR_VAR 0 17
62271: PUSH
62272: LD_VAR 0 17
62276: PUSH
62277: LD_VAR 0 8
62281: PPUSH
62282: CALL_OW 478
62286: UNION
62287: ST_TO_ADDR
62288: GO 62264
62290: POP
62291: POP
// if not fac_list then
62292: LD_VAR 0 17
62296: NOT
62297: IFFALSE 62301
// exit ;
62299: GO 63220
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62301: LD_ADDR_VAR 0 5
62305: PUSH
62306: LD_INT 4
62308: PUSH
62309: LD_INT 5
62311: PUSH
62312: LD_INT 9
62314: PUSH
62315: LD_INT 10
62317: PUSH
62318: LD_INT 6
62320: PUSH
62321: LD_INT 7
62323: PUSH
62324: LD_INT 11
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: LIST
62331: LIST
62332: LIST
62333: LIST
62334: LIST
62335: PUSH
62336: LD_INT 27
62338: PUSH
62339: LD_INT 28
62341: PUSH
62342: LD_INT 26
62344: PUSH
62345: LD_INT 30
62347: PUSH
62348: EMPTY
62349: LIST
62350: LIST
62351: LIST
62352: LIST
62353: PUSH
62354: LD_INT 43
62356: PUSH
62357: LD_INT 44
62359: PUSH
62360: LD_INT 46
62362: PUSH
62363: LD_INT 45
62365: PUSH
62366: LD_INT 47
62368: PUSH
62369: LD_INT 49
62371: PUSH
62372: EMPTY
62373: LIST
62374: LIST
62375: LIST
62376: LIST
62377: LIST
62378: LIST
62379: PUSH
62380: EMPTY
62381: LIST
62382: LIST
62383: LIST
62384: PUSH
62385: LD_VAR 0 12
62389: ARRAY
62390: ST_TO_ADDR
// list := list isect fac_list ;
62391: LD_ADDR_VAR 0 5
62395: PUSH
62396: LD_VAR 0 5
62400: PUSH
62401: LD_VAR 0 17
62405: ISECT
62406: ST_TO_ADDR
// if not list then
62407: LD_VAR 0 5
62411: NOT
62412: IFFALSE 62416
// exit ;
62414: GO 63220
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62416: LD_VAR 0 12
62420: PUSH
62421: LD_INT 3
62423: EQUAL
62424: PUSH
62425: LD_INT 49
62427: PUSH
62428: LD_VAR 0 5
62432: IN
62433: AND
62434: PUSH
62435: LD_INT 31
62437: PPUSH
62438: LD_VAR 0 16
62442: PPUSH
62443: CALL_OW 321
62447: PUSH
62448: LD_INT 2
62450: EQUAL
62451: AND
62452: IFFALSE 62512
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62454: LD_INT 22
62456: PUSH
62457: LD_VAR 0 16
62461: PUSH
62462: EMPTY
62463: LIST
62464: LIST
62465: PUSH
62466: LD_INT 35
62468: PUSH
62469: LD_INT 49
62471: PUSH
62472: EMPTY
62473: LIST
62474: LIST
62475: PUSH
62476: LD_INT 91
62478: PUSH
62479: LD_VAR 0 1
62483: PUSH
62484: LD_INT 10
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: LIST
62491: PUSH
62492: EMPTY
62493: LIST
62494: LIST
62495: LIST
62496: PPUSH
62497: CALL_OW 69
62501: NOT
62502: IFFALSE 62512
// weapon := ru_time_lapser ;
62504: LD_ADDR_VAR 0 18
62508: PUSH
62509: LD_INT 49
62511: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62512: LD_VAR 0 12
62516: PUSH
62517: LD_INT 1
62519: PUSH
62520: LD_INT 2
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: IN
62527: PUSH
62528: LD_INT 11
62530: PUSH
62531: LD_VAR 0 5
62535: IN
62536: PUSH
62537: LD_INT 30
62539: PUSH
62540: LD_VAR 0 5
62544: IN
62545: OR
62546: AND
62547: PUSH
62548: LD_INT 6
62550: PPUSH
62551: LD_VAR 0 16
62555: PPUSH
62556: CALL_OW 321
62560: PUSH
62561: LD_INT 2
62563: EQUAL
62564: AND
62565: IFFALSE 62730
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62567: LD_INT 22
62569: PUSH
62570: LD_VAR 0 16
62574: PUSH
62575: EMPTY
62576: LIST
62577: LIST
62578: PUSH
62579: LD_INT 2
62581: PUSH
62582: LD_INT 35
62584: PUSH
62585: LD_INT 11
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: PUSH
62592: LD_INT 35
62594: PUSH
62595: LD_INT 30
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: LIST
62606: PUSH
62607: LD_INT 91
62609: PUSH
62610: LD_VAR 0 1
62614: PUSH
62615: LD_INT 18
62617: PUSH
62618: EMPTY
62619: LIST
62620: LIST
62621: LIST
62622: PUSH
62623: EMPTY
62624: LIST
62625: LIST
62626: LIST
62627: PPUSH
62628: CALL_OW 69
62632: NOT
62633: PUSH
62634: LD_INT 22
62636: PUSH
62637: LD_VAR 0 16
62641: PUSH
62642: EMPTY
62643: LIST
62644: LIST
62645: PUSH
62646: LD_INT 2
62648: PUSH
62649: LD_INT 30
62651: PUSH
62652: LD_INT 32
62654: PUSH
62655: EMPTY
62656: LIST
62657: LIST
62658: PUSH
62659: LD_INT 30
62661: PUSH
62662: LD_INT 33
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: PUSH
62669: EMPTY
62670: LIST
62671: LIST
62672: LIST
62673: PUSH
62674: LD_INT 91
62676: PUSH
62677: LD_VAR 0 1
62681: PUSH
62682: LD_INT 12
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: LIST
62689: PUSH
62690: EMPTY
62691: LIST
62692: LIST
62693: LIST
62694: PUSH
62695: EMPTY
62696: LIST
62697: PPUSH
62698: CALL_OW 69
62702: PUSH
62703: LD_INT 2
62705: GREATER
62706: AND
62707: IFFALSE 62730
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62709: LD_ADDR_VAR 0 18
62713: PUSH
62714: LD_INT 11
62716: PUSH
62717: LD_INT 30
62719: PUSH
62720: EMPTY
62721: LIST
62722: LIST
62723: PUSH
62724: LD_VAR 0 12
62728: ARRAY
62729: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62730: LD_VAR 0 18
62734: NOT
62735: PUSH
62736: LD_INT 40
62738: PPUSH
62739: LD_VAR 0 16
62743: PPUSH
62744: CALL_OW 321
62748: PUSH
62749: LD_INT 2
62751: EQUAL
62752: AND
62753: PUSH
62754: LD_INT 7
62756: PUSH
62757: LD_VAR 0 5
62761: IN
62762: PUSH
62763: LD_INT 28
62765: PUSH
62766: LD_VAR 0 5
62770: IN
62771: OR
62772: PUSH
62773: LD_INT 45
62775: PUSH
62776: LD_VAR 0 5
62780: IN
62781: OR
62782: AND
62783: IFFALSE 63037
// begin hex := GetHexInfo ( x , y ) ;
62785: LD_ADDR_VAR 0 4
62789: PUSH
62790: LD_VAR 0 10
62794: PPUSH
62795: LD_VAR 0 11
62799: PPUSH
62800: CALL_OW 546
62804: ST_TO_ADDR
// if hex [ 1 ] then
62805: LD_VAR 0 4
62809: PUSH
62810: LD_INT 1
62812: ARRAY
62813: IFFALSE 62817
// exit ;
62815: GO 63220
// height := hex [ 2 ] ;
62817: LD_ADDR_VAR 0 15
62821: PUSH
62822: LD_VAR 0 4
62826: PUSH
62827: LD_INT 2
62829: ARRAY
62830: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62831: LD_ADDR_VAR 0 14
62835: PUSH
62836: LD_INT 0
62838: PUSH
62839: LD_INT 2
62841: PUSH
62842: LD_INT 3
62844: PUSH
62845: LD_INT 5
62847: PUSH
62848: EMPTY
62849: LIST
62850: LIST
62851: LIST
62852: LIST
62853: ST_TO_ADDR
// for i in tmp do
62854: LD_ADDR_VAR 0 8
62858: PUSH
62859: LD_VAR 0 14
62863: PUSH
62864: FOR_IN
62865: IFFALSE 63035
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62867: LD_ADDR_VAR 0 9
62871: PUSH
62872: LD_VAR 0 10
62876: PPUSH
62877: LD_VAR 0 8
62881: PPUSH
62882: LD_INT 5
62884: PPUSH
62885: CALL_OW 272
62889: PUSH
62890: LD_VAR 0 11
62894: PPUSH
62895: LD_VAR 0 8
62899: PPUSH
62900: LD_INT 5
62902: PPUSH
62903: CALL_OW 273
62907: PUSH
62908: EMPTY
62909: LIST
62910: LIST
62911: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62912: LD_VAR 0 9
62916: PUSH
62917: LD_INT 1
62919: ARRAY
62920: PPUSH
62921: LD_VAR 0 9
62925: PUSH
62926: LD_INT 2
62928: ARRAY
62929: PPUSH
62930: CALL_OW 488
62934: IFFALSE 63033
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62936: LD_ADDR_VAR 0 4
62940: PUSH
62941: LD_VAR 0 9
62945: PUSH
62946: LD_INT 1
62948: ARRAY
62949: PPUSH
62950: LD_VAR 0 9
62954: PUSH
62955: LD_INT 2
62957: ARRAY
62958: PPUSH
62959: CALL_OW 546
62963: ST_TO_ADDR
// if hex [ 1 ] then
62964: LD_VAR 0 4
62968: PUSH
62969: LD_INT 1
62971: ARRAY
62972: IFFALSE 62976
// continue ;
62974: GO 62864
// h := hex [ 2 ] ;
62976: LD_ADDR_VAR 0 13
62980: PUSH
62981: LD_VAR 0 4
62985: PUSH
62986: LD_INT 2
62988: ARRAY
62989: ST_TO_ADDR
// if h + 7 < height then
62990: LD_VAR 0 13
62994: PUSH
62995: LD_INT 7
62997: PLUS
62998: PUSH
62999: LD_VAR 0 15
63003: LESS
63004: IFFALSE 63033
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63006: LD_ADDR_VAR 0 18
63010: PUSH
63011: LD_INT 7
63013: PUSH
63014: LD_INT 28
63016: PUSH
63017: LD_INT 45
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: LIST
63024: PUSH
63025: LD_VAR 0 12
63029: ARRAY
63030: ST_TO_ADDR
// break ;
63031: GO 63035
// end ; end ; end ;
63033: GO 62864
63035: POP
63036: POP
// end ; if not weapon then
63037: LD_VAR 0 18
63041: NOT
63042: IFFALSE 63102
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63044: LD_ADDR_VAR 0 5
63048: PUSH
63049: LD_VAR 0 5
63053: PUSH
63054: LD_INT 11
63056: PUSH
63057: LD_INT 30
63059: PUSH
63060: LD_INT 49
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: LIST
63067: DIFF
63068: ST_TO_ADDR
// if not list then
63069: LD_VAR 0 5
63073: NOT
63074: IFFALSE 63078
// exit ;
63076: GO 63220
// weapon := list [ rand ( 1 , list ) ] ;
63078: LD_ADDR_VAR 0 18
63082: PUSH
63083: LD_VAR 0 5
63087: PUSH
63088: LD_INT 1
63090: PPUSH
63091: LD_VAR 0 5
63095: PPUSH
63096: CALL_OW 12
63100: ARRAY
63101: ST_TO_ADDR
// end ; if weapon then
63102: LD_VAR 0 18
63106: IFFALSE 63220
// begin tmp := CostOfWeapon ( weapon ) ;
63108: LD_ADDR_VAR 0 14
63112: PUSH
63113: LD_VAR 0 18
63117: PPUSH
63118: CALL_OW 451
63122: ST_TO_ADDR
// j := GetBase ( tower ) ;
63123: LD_ADDR_VAR 0 9
63127: PUSH
63128: LD_VAR 0 1
63132: PPUSH
63133: CALL_OW 274
63137: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63138: LD_VAR 0 9
63142: PPUSH
63143: LD_INT 1
63145: PPUSH
63146: CALL_OW 275
63150: PUSH
63151: LD_VAR 0 14
63155: PUSH
63156: LD_INT 1
63158: ARRAY
63159: GREATEREQUAL
63160: PUSH
63161: LD_VAR 0 9
63165: PPUSH
63166: LD_INT 2
63168: PPUSH
63169: CALL_OW 275
63173: PUSH
63174: LD_VAR 0 14
63178: PUSH
63179: LD_INT 2
63181: ARRAY
63182: GREATEREQUAL
63183: AND
63184: PUSH
63185: LD_VAR 0 9
63189: PPUSH
63190: LD_INT 3
63192: PPUSH
63193: CALL_OW 275
63197: PUSH
63198: LD_VAR 0 14
63202: PUSH
63203: LD_INT 3
63205: ARRAY
63206: GREATEREQUAL
63207: AND
63208: IFFALSE 63220
// result := weapon ;
63210: LD_ADDR_VAR 0 3
63214: PUSH
63215: LD_VAR 0 18
63219: ST_TO_ADDR
// end ; end ;
63220: LD_VAR 0 3
63224: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63225: LD_INT 0
63227: PPUSH
63228: PPUSH
// result := true ;
63229: LD_ADDR_VAR 0 3
63233: PUSH
63234: LD_INT 1
63236: ST_TO_ADDR
// if array1 = array2 then
63237: LD_VAR 0 1
63241: PUSH
63242: LD_VAR 0 2
63246: EQUAL
63247: IFFALSE 63307
// begin for i = 1 to array1 do
63249: LD_ADDR_VAR 0 4
63253: PUSH
63254: DOUBLE
63255: LD_INT 1
63257: DEC
63258: ST_TO_ADDR
63259: LD_VAR 0 1
63263: PUSH
63264: FOR_TO
63265: IFFALSE 63303
// if array1 [ i ] <> array2 [ i ] then
63267: LD_VAR 0 1
63271: PUSH
63272: LD_VAR 0 4
63276: ARRAY
63277: PUSH
63278: LD_VAR 0 2
63282: PUSH
63283: LD_VAR 0 4
63287: ARRAY
63288: NONEQUAL
63289: IFFALSE 63301
// begin result := false ;
63291: LD_ADDR_VAR 0 3
63295: PUSH
63296: LD_INT 0
63298: ST_TO_ADDR
// break ;
63299: GO 63303
// end ;
63301: GO 63264
63303: POP
63304: POP
// end else
63305: GO 63315
// result := false ;
63307: LD_ADDR_VAR 0 3
63311: PUSH
63312: LD_INT 0
63314: ST_TO_ADDR
// end ;
63315: LD_VAR 0 3
63319: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63320: LD_INT 0
63322: PPUSH
63323: PPUSH
// if not array1 or not array2 then
63324: LD_VAR 0 1
63328: NOT
63329: PUSH
63330: LD_VAR 0 2
63334: NOT
63335: OR
63336: IFFALSE 63340
// exit ;
63338: GO 63404
// result := true ;
63340: LD_ADDR_VAR 0 3
63344: PUSH
63345: LD_INT 1
63347: ST_TO_ADDR
// for i = 1 to array1 do
63348: LD_ADDR_VAR 0 4
63352: PUSH
63353: DOUBLE
63354: LD_INT 1
63356: DEC
63357: ST_TO_ADDR
63358: LD_VAR 0 1
63362: PUSH
63363: FOR_TO
63364: IFFALSE 63402
// if array1 [ i ] <> array2 [ i ] then
63366: LD_VAR 0 1
63370: PUSH
63371: LD_VAR 0 4
63375: ARRAY
63376: PUSH
63377: LD_VAR 0 2
63381: PUSH
63382: LD_VAR 0 4
63386: ARRAY
63387: NONEQUAL
63388: IFFALSE 63400
// begin result := false ;
63390: LD_ADDR_VAR 0 3
63394: PUSH
63395: LD_INT 0
63397: ST_TO_ADDR
// break ;
63398: GO 63402
// end ;
63400: GO 63363
63402: POP
63403: POP
// end ;
63404: LD_VAR 0 3
63408: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63409: LD_INT 0
63411: PPUSH
63412: PPUSH
63413: PPUSH
// pom := GetBase ( fac ) ;
63414: LD_ADDR_VAR 0 5
63418: PUSH
63419: LD_VAR 0 1
63423: PPUSH
63424: CALL_OW 274
63428: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63429: LD_ADDR_VAR 0 4
63433: PUSH
63434: LD_VAR 0 2
63438: PUSH
63439: LD_INT 1
63441: ARRAY
63442: PPUSH
63443: LD_VAR 0 2
63447: PUSH
63448: LD_INT 2
63450: ARRAY
63451: PPUSH
63452: LD_VAR 0 2
63456: PUSH
63457: LD_INT 3
63459: ARRAY
63460: PPUSH
63461: LD_VAR 0 2
63465: PUSH
63466: LD_INT 4
63468: ARRAY
63469: PPUSH
63470: CALL_OW 449
63474: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63475: LD_ADDR_VAR 0 3
63479: PUSH
63480: LD_VAR 0 5
63484: PPUSH
63485: LD_INT 1
63487: PPUSH
63488: CALL_OW 275
63492: PUSH
63493: LD_VAR 0 4
63497: PUSH
63498: LD_INT 1
63500: ARRAY
63501: GREATEREQUAL
63502: PUSH
63503: LD_VAR 0 5
63507: PPUSH
63508: LD_INT 2
63510: PPUSH
63511: CALL_OW 275
63515: PUSH
63516: LD_VAR 0 4
63520: PUSH
63521: LD_INT 2
63523: ARRAY
63524: GREATEREQUAL
63525: AND
63526: PUSH
63527: LD_VAR 0 5
63531: PPUSH
63532: LD_INT 3
63534: PPUSH
63535: CALL_OW 275
63539: PUSH
63540: LD_VAR 0 4
63544: PUSH
63545: LD_INT 3
63547: ARRAY
63548: GREATEREQUAL
63549: AND
63550: ST_TO_ADDR
// end ;
63551: LD_VAR 0 3
63555: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63556: LD_INT 0
63558: PPUSH
63559: PPUSH
63560: PPUSH
63561: PPUSH
// pom := GetBase ( building ) ;
63562: LD_ADDR_VAR 0 3
63566: PUSH
63567: LD_VAR 0 1
63571: PPUSH
63572: CALL_OW 274
63576: ST_TO_ADDR
// if not pom then
63577: LD_VAR 0 3
63581: NOT
63582: IFFALSE 63586
// exit ;
63584: GO 63756
// btype := GetBType ( building ) ;
63586: LD_ADDR_VAR 0 5
63590: PUSH
63591: LD_VAR 0 1
63595: PPUSH
63596: CALL_OW 266
63600: ST_TO_ADDR
// if btype = b_armoury then
63601: LD_VAR 0 5
63605: PUSH
63606: LD_INT 4
63608: EQUAL
63609: IFFALSE 63619
// btype := b_barracks ;
63611: LD_ADDR_VAR 0 5
63615: PUSH
63616: LD_INT 5
63618: ST_TO_ADDR
// if btype = b_depot then
63619: LD_VAR 0 5
63623: PUSH
63624: LD_INT 0
63626: EQUAL
63627: IFFALSE 63637
// btype := b_warehouse ;
63629: LD_ADDR_VAR 0 5
63633: PUSH
63634: LD_INT 1
63636: ST_TO_ADDR
// if btype = b_workshop then
63637: LD_VAR 0 5
63641: PUSH
63642: LD_INT 2
63644: EQUAL
63645: IFFALSE 63655
// btype := b_factory ;
63647: LD_ADDR_VAR 0 5
63651: PUSH
63652: LD_INT 3
63654: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63655: LD_ADDR_VAR 0 4
63659: PUSH
63660: LD_VAR 0 5
63664: PPUSH
63665: LD_VAR 0 1
63669: PPUSH
63670: CALL_OW 248
63674: PPUSH
63675: CALL_OW 450
63679: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63680: LD_ADDR_VAR 0 2
63684: PUSH
63685: LD_VAR 0 3
63689: PPUSH
63690: LD_INT 1
63692: PPUSH
63693: CALL_OW 275
63697: PUSH
63698: LD_VAR 0 4
63702: PUSH
63703: LD_INT 1
63705: ARRAY
63706: GREATEREQUAL
63707: PUSH
63708: LD_VAR 0 3
63712: PPUSH
63713: LD_INT 2
63715: PPUSH
63716: CALL_OW 275
63720: PUSH
63721: LD_VAR 0 4
63725: PUSH
63726: LD_INT 2
63728: ARRAY
63729: GREATEREQUAL
63730: AND
63731: PUSH
63732: LD_VAR 0 3
63736: PPUSH
63737: LD_INT 3
63739: PPUSH
63740: CALL_OW 275
63744: PUSH
63745: LD_VAR 0 4
63749: PUSH
63750: LD_INT 3
63752: ARRAY
63753: GREATEREQUAL
63754: AND
63755: ST_TO_ADDR
// end ;
63756: LD_VAR 0 2
63760: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63761: LD_INT 0
63763: PPUSH
63764: PPUSH
63765: PPUSH
// pom := GetBase ( building ) ;
63766: LD_ADDR_VAR 0 4
63770: PUSH
63771: LD_VAR 0 1
63775: PPUSH
63776: CALL_OW 274
63780: ST_TO_ADDR
// if not pom then
63781: LD_VAR 0 4
63785: NOT
63786: IFFALSE 63790
// exit ;
63788: GO 63891
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63790: LD_ADDR_VAR 0 5
63794: PUSH
63795: LD_VAR 0 2
63799: PPUSH
63800: LD_VAR 0 1
63804: PPUSH
63805: CALL_OW 248
63809: PPUSH
63810: CALL_OW 450
63814: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63815: LD_ADDR_VAR 0 3
63819: PUSH
63820: LD_VAR 0 4
63824: PPUSH
63825: LD_INT 1
63827: PPUSH
63828: CALL_OW 275
63832: PUSH
63833: LD_VAR 0 5
63837: PUSH
63838: LD_INT 1
63840: ARRAY
63841: GREATEREQUAL
63842: PUSH
63843: LD_VAR 0 4
63847: PPUSH
63848: LD_INT 2
63850: PPUSH
63851: CALL_OW 275
63855: PUSH
63856: LD_VAR 0 5
63860: PUSH
63861: LD_INT 2
63863: ARRAY
63864: GREATEREQUAL
63865: AND
63866: PUSH
63867: LD_VAR 0 4
63871: PPUSH
63872: LD_INT 3
63874: PPUSH
63875: CALL_OW 275
63879: PUSH
63880: LD_VAR 0 5
63884: PUSH
63885: LD_INT 3
63887: ARRAY
63888: GREATEREQUAL
63889: AND
63890: ST_TO_ADDR
// end ;
63891: LD_VAR 0 3
63895: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63896: LD_INT 0
63898: PPUSH
63899: PPUSH
63900: PPUSH
63901: PPUSH
63902: PPUSH
63903: PPUSH
63904: PPUSH
63905: PPUSH
63906: PPUSH
63907: PPUSH
63908: PPUSH
// result := false ;
63909: LD_ADDR_VAR 0 8
63913: PUSH
63914: LD_INT 0
63916: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63917: LD_VAR 0 5
63921: NOT
63922: PUSH
63923: LD_VAR 0 1
63927: NOT
63928: OR
63929: PUSH
63930: LD_VAR 0 2
63934: NOT
63935: OR
63936: PUSH
63937: LD_VAR 0 3
63941: NOT
63942: OR
63943: IFFALSE 63947
// exit ;
63945: GO 64761
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63947: LD_ADDR_VAR 0 14
63951: PUSH
63952: LD_VAR 0 1
63956: PPUSH
63957: LD_VAR 0 2
63961: PPUSH
63962: LD_VAR 0 3
63966: PPUSH
63967: LD_VAR 0 4
63971: PPUSH
63972: LD_VAR 0 5
63976: PUSH
63977: LD_INT 1
63979: ARRAY
63980: PPUSH
63981: CALL_OW 248
63985: PPUSH
63986: LD_INT 0
63988: PPUSH
63989: CALL 65994 0 6
63993: ST_TO_ADDR
// if not hexes then
63994: LD_VAR 0 14
63998: NOT
63999: IFFALSE 64003
// exit ;
64001: GO 64761
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64003: LD_ADDR_VAR 0 17
64007: PUSH
64008: LD_VAR 0 5
64012: PPUSH
64013: LD_INT 22
64015: PUSH
64016: LD_VAR 0 13
64020: PPUSH
64021: CALL_OW 255
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PUSH
64030: LD_INT 2
64032: PUSH
64033: LD_INT 30
64035: PUSH
64036: LD_INT 0
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: LD_INT 30
64045: PUSH
64046: LD_INT 1
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: LIST
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: PPUSH
64062: CALL_OW 72
64066: ST_TO_ADDR
// for i = 1 to hexes do
64067: LD_ADDR_VAR 0 9
64071: PUSH
64072: DOUBLE
64073: LD_INT 1
64075: DEC
64076: ST_TO_ADDR
64077: LD_VAR 0 14
64081: PUSH
64082: FOR_TO
64083: IFFALSE 64759
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64085: LD_ADDR_VAR 0 13
64089: PUSH
64090: LD_VAR 0 14
64094: PUSH
64095: LD_VAR 0 9
64099: ARRAY
64100: PUSH
64101: LD_INT 1
64103: ARRAY
64104: PPUSH
64105: LD_VAR 0 14
64109: PUSH
64110: LD_VAR 0 9
64114: ARRAY
64115: PUSH
64116: LD_INT 2
64118: ARRAY
64119: PPUSH
64120: CALL_OW 428
64124: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64125: LD_VAR 0 14
64129: PUSH
64130: LD_VAR 0 9
64134: ARRAY
64135: PUSH
64136: LD_INT 1
64138: ARRAY
64139: PPUSH
64140: LD_VAR 0 14
64144: PUSH
64145: LD_VAR 0 9
64149: ARRAY
64150: PUSH
64151: LD_INT 2
64153: ARRAY
64154: PPUSH
64155: CALL_OW 351
64159: PUSH
64160: LD_VAR 0 14
64164: PUSH
64165: LD_VAR 0 9
64169: ARRAY
64170: PUSH
64171: LD_INT 1
64173: ARRAY
64174: PPUSH
64175: LD_VAR 0 14
64179: PUSH
64180: LD_VAR 0 9
64184: ARRAY
64185: PUSH
64186: LD_INT 2
64188: ARRAY
64189: PPUSH
64190: CALL_OW 488
64194: NOT
64195: OR
64196: PUSH
64197: LD_VAR 0 13
64201: PPUSH
64202: CALL_OW 247
64206: PUSH
64207: LD_INT 3
64209: EQUAL
64210: OR
64211: IFFALSE 64217
// exit ;
64213: POP
64214: POP
64215: GO 64761
// if not tmp then
64217: LD_VAR 0 13
64221: NOT
64222: IFFALSE 64226
// continue ;
64224: GO 64082
// result := true ;
64226: LD_ADDR_VAR 0 8
64230: PUSH
64231: LD_INT 1
64233: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64234: LD_VAR 0 6
64238: PUSH
64239: LD_VAR 0 13
64243: PPUSH
64244: CALL_OW 247
64248: PUSH
64249: LD_INT 2
64251: EQUAL
64252: AND
64253: PUSH
64254: LD_VAR 0 13
64258: PPUSH
64259: CALL_OW 263
64263: PUSH
64264: LD_INT 1
64266: EQUAL
64267: AND
64268: IFFALSE 64432
// begin if IsDrivenBy ( tmp ) then
64270: LD_VAR 0 13
64274: PPUSH
64275: CALL_OW 311
64279: IFFALSE 64283
// continue ;
64281: GO 64082
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64283: LD_VAR 0 6
64287: PPUSH
64288: LD_INT 3
64290: PUSH
64291: LD_INT 60
64293: PUSH
64294: EMPTY
64295: LIST
64296: PUSH
64297: EMPTY
64298: LIST
64299: LIST
64300: PUSH
64301: LD_INT 3
64303: PUSH
64304: LD_INT 55
64306: PUSH
64307: EMPTY
64308: LIST
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: EMPTY
64315: LIST
64316: LIST
64317: PPUSH
64318: CALL_OW 72
64322: IFFALSE 64430
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64324: LD_ADDR_VAR 0 18
64328: PUSH
64329: LD_VAR 0 6
64333: PPUSH
64334: LD_INT 3
64336: PUSH
64337: LD_INT 60
64339: PUSH
64340: EMPTY
64341: LIST
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: PUSH
64347: LD_INT 3
64349: PUSH
64350: LD_INT 55
64352: PUSH
64353: EMPTY
64354: LIST
64355: PUSH
64356: EMPTY
64357: LIST
64358: LIST
64359: PUSH
64360: EMPTY
64361: LIST
64362: LIST
64363: PPUSH
64364: CALL_OW 72
64368: PUSH
64369: LD_INT 1
64371: ARRAY
64372: ST_TO_ADDR
// if IsInUnit ( driver ) then
64373: LD_VAR 0 18
64377: PPUSH
64378: CALL_OW 310
64382: IFFALSE 64393
// ComExit ( driver ) ;
64384: LD_VAR 0 18
64388: PPUSH
64389: CALL 89755 0 1
// AddComEnterUnit ( driver , tmp ) ;
64393: LD_VAR 0 18
64397: PPUSH
64398: LD_VAR 0 13
64402: PPUSH
64403: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64407: LD_VAR 0 18
64411: PPUSH
64412: LD_VAR 0 7
64416: PPUSH
64417: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64421: LD_VAR 0 18
64425: PPUSH
64426: CALL_OW 181
// end ; continue ;
64430: GO 64082
// end ; if not cleaners or not tmp in cleaners then
64432: LD_VAR 0 6
64436: NOT
64437: PUSH
64438: LD_VAR 0 13
64442: PUSH
64443: LD_VAR 0 6
64447: IN
64448: NOT
64449: OR
64450: IFFALSE 64757
// begin if dep then
64452: LD_VAR 0 17
64456: IFFALSE 64592
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64458: LD_ADDR_VAR 0 16
64462: PUSH
64463: LD_VAR 0 17
64467: PUSH
64468: LD_INT 1
64470: ARRAY
64471: PPUSH
64472: CALL_OW 250
64476: PPUSH
64477: LD_VAR 0 17
64481: PUSH
64482: LD_INT 1
64484: ARRAY
64485: PPUSH
64486: CALL_OW 254
64490: PPUSH
64491: LD_INT 5
64493: PPUSH
64494: CALL_OW 272
64498: PUSH
64499: LD_VAR 0 17
64503: PUSH
64504: LD_INT 1
64506: ARRAY
64507: PPUSH
64508: CALL_OW 251
64512: PPUSH
64513: LD_VAR 0 17
64517: PUSH
64518: LD_INT 1
64520: ARRAY
64521: PPUSH
64522: CALL_OW 254
64526: PPUSH
64527: LD_INT 5
64529: PPUSH
64530: CALL_OW 273
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64539: LD_VAR 0 16
64543: PUSH
64544: LD_INT 1
64546: ARRAY
64547: PPUSH
64548: LD_VAR 0 16
64552: PUSH
64553: LD_INT 2
64555: ARRAY
64556: PPUSH
64557: CALL_OW 488
64561: IFFALSE 64592
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64563: LD_VAR 0 13
64567: PPUSH
64568: LD_VAR 0 16
64572: PUSH
64573: LD_INT 1
64575: ARRAY
64576: PPUSH
64577: LD_VAR 0 16
64581: PUSH
64582: LD_INT 2
64584: ARRAY
64585: PPUSH
64586: CALL_OW 111
// continue ;
64590: GO 64082
// end ; end ; r := GetDir ( tmp ) ;
64592: LD_ADDR_VAR 0 15
64596: PUSH
64597: LD_VAR 0 13
64601: PPUSH
64602: CALL_OW 254
64606: ST_TO_ADDR
// if r = 5 then
64607: LD_VAR 0 15
64611: PUSH
64612: LD_INT 5
64614: EQUAL
64615: IFFALSE 64625
// r := 0 ;
64617: LD_ADDR_VAR 0 15
64621: PUSH
64622: LD_INT 0
64624: ST_TO_ADDR
// for j = r to 5 do
64625: LD_ADDR_VAR 0 10
64629: PUSH
64630: DOUBLE
64631: LD_VAR 0 15
64635: DEC
64636: ST_TO_ADDR
64637: LD_INT 5
64639: PUSH
64640: FOR_TO
64641: IFFALSE 64755
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64643: LD_ADDR_VAR 0 11
64647: PUSH
64648: LD_VAR 0 13
64652: PPUSH
64653: CALL_OW 250
64657: PPUSH
64658: LD_VAR 0 10
64662: PPUSH
64663: LD_INT 2
64665: PPUSH
64666: CALL_OW 272
64670: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64671: LD_ADDR_VAR 0 12
64675: PUSH
64676: LD_VAR 0 13
64680: PPUSH
64681: CALL_OW 251
64685: PPUSH
64686: LD_VAR 0 10
64690: PPUSH
64691: LD_INT 2
64693: PPUSH
64694: CALL_OW 273
64698: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64699: LD_VAR 0 11
64703: PPUSH
64704: LD_VAR 0 12
64708: PPUSH
64709: CALL_OW 488
64713: PUSH
64714: LD_VAR 0 11
64718: PPUSH
64719: LD_VAR 0 12
64723: PPUSH
64724: CALL_OW 428
64728: NOT
64729: AND
64730: IFFALSE 64753
// begin ComMoveXY ( tmp , _x , _y ) ;
64732: LD_VAR 0 13
64736: PPUSH
64737: LD_VAR 0 11
64741: PPUSH
64742: LD_VAR 0 12
64746: PPUSH
64747: CALL_OW 111
// break ;
64751: GO 64755
// end ; end ;
64753: GO 64640
64755: POP
64756: POP
// end ; end ;
64757: GO 64082
64759: POP
64760: POP
// end ;
64761: LD_VAR 0 8
64765: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64766: LD_INT 0
64768: PPUSH
// result := true ;
64769: LD_ADDR_VAR 0 3
64773: PUSH
64774: LD_INT 1
64776: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64777: LD_VAR 0 2
64781: PUSH
64782: LD_INT 24
64784: DOUBLE
64785: EQUAL
64786: IFTRUE 64796
64788: LD_INT 33
64790: DOUBLE
64791: EQUAL
64792: IFTRUE 64796
64794: GO 64821
64796: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64797: LD_ADDR_VAR 0 3
64801: PUSH
64802: LD_INT 32
64804: PPUSH
64805: LD_VAR 0 1
64809: PPUSH
64810: CALL_OW 321
64814: PUSH
64815: LD_INT 2
64817: EQUAL
64818: ST_TO_ADDR
64819: GO 65137
64821: LD_INT 20
64823: DOUBLE
64824: EQUAL
64825: IFTRUE 64829
64827: GO 64854
64829: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64830: LD_ADDR_VAR 0 3
64834: PUSH
64835: LD_INT 6
64837: PPUSH
64838: LD_VAR 0 1
64842: PPUSH
64843: CALL_OW 321
64847: PUSH
64848: LD_INT 2
64850: EQUAL
64851: ST_TO_ADDR
64852: GO 65137
64854: LD_INT 22
64856: DOUBLE
64857: EQUAL
64858: IFTRUE 64868
64860: LD_INT 36
64862: DOUBLE
64863: EQUAL
64864: IFTRUE 64868
64866: GO 64893
64868: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64869: LD_ADDR_VAR 0 3
64873: PUSH
64874: LD_INT 15
64876: PPUSH
64877: LD_VAR 0 1
64881: PPUSH
64882: CALL_OW 321
64886: PUSH
64887: LD_INT 2
64889: EQUAL
64890: ST_TO_ADDR
64891: GO 65137
64893: LD_INT 30
64895: DOUBLE
64896: EQUAL
64897: IFTRUE 64901
64899: GO 64926
64901: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64902: LD_ADDR_VAR 0 3
64906: PUSH
64907: LD_INT 20
64909: PPUSH
64910: LD_VAR 0 1
64914: PPUSH
64915: CALL_OW 321
64919: PUSH
64920: LD_INT 2
64922: EQUAL
64923: ST_TO_ADDR
64924: GO 65137
64926: LD_INT 28
64928: DOUBLE
64929: EQUAL
64930: IFTRUE 64940
64932: LD_INT 21
64934: DOUBLE
64935: EQUAL
64936: IFTRUE 64940
64938: GO 64965
64940: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64941: LD_ADDR_VAR 0 3
64945: PUSH
64946: LD_INT 21
64948: PPUSH
64949: LD_VAR 0 1
64953: PPUSH
64954: CALL_OW 321
64958: PUSH
64959: LD_INT 2
64961: EQUAL
64962: ST_TO_ADDR
64963: GO 65137
64965: LD_INT 16
64967: DOUBLE
64968: EQUAL
64969: IFTRUE 64973
64971: GO 64998
64973: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64974: LD_ADDR_VAR 0 3
64978: PUSH
64979: LD_INT 84
64981: PPUSH
64982: LD_VAR 0 1
64986: PPUSH
64987: CALL_OW 321
64991: PUSH
64992: LD_INT 2
64994: EQUAL
64995: ST_TO_ADDR
64996: GO 65137
64998: LD_INT 19
65000: DOUBLE
65001: EQUAL
65002: IFTRUE 65012
65004: LD_INT 23
65006: DOUBLE
65007: EQUAL
65008: IFTRUE 65012
65010: GO 65037
65012: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
65013: LD_ADDR_VAR 0 3
65017: PUSH
65018: LD_INT 83
65020: PPUSH
65021: LD_VAR 0 1
65025: PPUSH
65026: CALL_OW 321
65030: PUSH
65031: LD_INT 2
65033: EQUAL
65034: ST_TO_ADDR
65035: GO 65137
65037: LD_INT 17
65039: DOUBLE
65040: EQUAL
65041: IFTRUE 65045
65043: GO 65070
65045: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65046: LD_ADDR_VAR 0 3
65050: PUSH
65051: LD_INT 39
65053: PPUSH
65054: LD_VAR 0 1
65058: PPUSH
65059: CALL_OW 321
65063: PUSH
65064: LD_INT 2
65066: EQUAL
65067: ST_TO_ADDR
65068: GO 65137
65070: LD_INT 18
65072: DOUBLE
65073: EQUAL
65074: IFTRUE 65078
65076: GO 65103
65078: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65079: LD_ADDR_VAR 0 3
65083: PUSH
65084: LD_INT 40
65086: PPUSH
65087: LD_VAR 0 1
65091: PPUSH
65092: CALL_OW 321
65096: PUSH
65097: LD_INT 2
65099: EQUAL
65100: ST_TO_ADDR
65101: GO 65137
65103: LD_INT 27
65105: DOUBLE
65106: EQUAL
65107: IFTRUE 65111
65109: GO 65136
65111: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65112: LD_ADDR_VAR 0 3
65116: PUSH
65117: LD_INT 35
65119: PPUSH
65120: LD_VAR 0 1
65124: PPUSH
65125: CALL_OW 321
65129: PUSH
65130: LD_INT 2
65132: EQUAL
65133: ST_TO_ADDR
65134: GO 65137
65136: POP
// end ;
65137: LD_VAR 0 3
65141: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65142: LD_INT 0
65144: PPUSH
65145: PPUSH
65146: PPUSH
65147: PPUSH
65148: PPUSH
65149: PPUSH
65150: PPUSH
65151: PPUSH
65152: PPUSH
65153: PPUSH
65154: PPUSH
// result := false ;
65155: LD_ADDR_VAR 0 6
65159: PUSH
65160: LD_INT 0
65162: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65163: LD_VAR 0 1
65167: NOT
65168: PUSH
65169: LD_VAR 0 1
65173: PPUSH
65174: CALL_OW 266
65178: PUSH
65179: LD_INT 0
65181: PUSH
65182: LD_INT 1
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: IN
65189: NOT
65190: OR
65191: PUSH
65192: LD_VAR 0 2
65196: NOT
65197: OR
65198: PUSH
65199: LD_VAR 0 5
65203: PUSH
65204: LD_INT 0
65206: PUSH
65207: LD_INT 1
65209: PUSH
65210: LD_INT 2
65212: PUSH
65213: LD_INT 3
65215: PUSH
65216: LD_INT 4
65218: PUSH
65219: LD_INT 5
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: IN
65230: NOT
65231: OR
65232: PUSH
65233: LD_VAR 0 3
65237: PPUSH
65238: LD_VAR 0 4
65242: PPUSH
65243: CALL_OW 488
65247: NOT
65248: OR
65249: IFFALSE 65253
// exit ;
65251: GO 65989
// side := GetSide ( depot ) ;
65253: LD_ADDR_VAR 0 9
65257: PUSH
65258: LD_VAR 0 1
65262: PPUSH
65263: CALL_OW 255
65267: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65268: LD_VAR 0 9
65272: PPUSH
65273: LD_VAR 0 2
65277: PPUSH
65278: CALL 64766 0 2
65282: NOT
65283: IFFALSE 65287
// exit ;
65285: GO 65989
// pom := GetBase ( depot ) ;
65287: LD_ADDR_VAR 0 10
65291: PUSH
65292: LD_VAR 0 1
65296: PPUSH
65297: CALL_OW 274
65301: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65302: LD_ADDR_VAR 0 11
65306: PUSH
65307: LD_VAR 0 2
65311: PPUSH
65312: LD_VAR 0 1
65316: PPUSH
65317: CALL_OW 248
65321: PPUSH
65322: CALL_OW 450
65326: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65327: LD_VAR 0 10
65331: PPUSH
65332: LD_INT 1
65334: PPUSH
65335: CALL_OW 275
65339: PUSH
65340: LD_VAR 0 11
65344: PUSH
65345: LD_INT 1
65347: ARRAY
65348: GREATEREQUAL
65349: PUSH
65350: LD_VAR 0 10
65354: PPUSH
65355: LD_INT 2
65357: PPUSH
65358: CALL_OW 275
65362: PUSH
65363: LD_VAR 0 11
65367: PUSH
65368: LD_INT 2
65370: ARRAY
65371: GREATEREQUAL
65372: AND
65373: PUSH
65374: LD_VAR 0 10
65378: PPUSH
65379: LD_INT 3
65381: PPUSH
65382: CALL_OW 275
65386: PUSH
65387: LD_VAR 0 11
65391: PUSH
65392: LD_INT 3
65394: ARRAY
65395: GREATEREQUAL
65396: AND
65397: NOT
65398: IFFALSE 65402
// exit ;
65400: GO 65989
// if GetBType ( depot ) = b_depot then
65402: LD_VAR 0 1
65406: PPUSH
65407: CALL_OW 266
65411: PUSH
65412: LD_INT 0
65414: EQUAL
65415: IFFALSE 65427
// dist := 28 else
65417: LD_ADDR_VAR 0 14
65421: PUSH
65422: LD_INT 28
65424: ST_TO_ADDR
65425: GO 65435
// dist := 36 ;
65427: LD_ADDR_VAR 0 14
65431: PUSH
65432: LD_INT 36
65434: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65435: LD_VAR 0 1
65439: PPUSH
65440: LD_VAR 0 3
65444: PPUSH
65445: LD_VAR 0 4
65449: PPUSH
65450: CALL_OW 297
65454: PUSH
65455: LD_VAR 0 14
65459: GREATER
65460: IFFALSE 65464
// exit ;
65462: GO 65989
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65464: LD_ADDR_VAR 0 12
65468: PUSH
65469: LD_VAR 0 2
65473: PPUSH
65474: LD_VAR 0 3
65478: PPUSH
65479: LD_VAR 0 4
65483: PPUSH
65484: LD_VAR 0 5
65488: PPUSH
65489: LD_VAR 0 1
65493: PPUSH
65494: CALL_OW 248
65498: PPUSH
65499: LD_INT 0
65501: PPUSH
65502: CALL 65994 0 6
65506: ST_TO_ADDR
// if not hexes then
65507: LD_VAR 0 12
65511: NOT
65512: IFFALSE 65516
// exit ;
65514: GO 65989
// hex := GetHexInfo ( x , y ) ;
65516: LD_ADDR_VAR 0 15
65520: PUSH
65521: LD_VAR 0 3
65525: PPUSH
65526: LD_VAR 0 4
65530: PPUSH
65531: CALL_OW 546
65535: ST_TO_ADDR
// if hex [ 1 ] then
65536: LD_VAR 0 15
65540: PUSH
65541: LD_INT 1
65543: ARRAY
65544: IFFALSE 65548
// exit ;
65546: GO 65989
// height := hex [ 2 ] ;
65548: LD_ADDR_VAR 0 13
65552: PUSH
65553: LD_VAR 0 15
65557: PUSH
65558: LD_INT 2
65560: ARRAY
65561: ST_TO_ADDR
// for i = 1 to hexes do
65562: LD_ADDR_VAR 0 7
65566: PUSH
65567: DOUBLE
65568: LD_INT 1
65570: DEC
65571: ST_TO_ADDR
65572: LD_VAR 0 12
65576: PUSH
65577: FOR_TO
65578: IFFALSE 65908
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65580: LD_VAR 0 12
65584: PUSH
65585: LD_VAR 0 7
65589: ARRAY
65590: PUSH
65591: LD_INT 1
65593: ARRAY
65594: PPUSH
65595: LD_VAR 0 12
65599: PUSH
65600: LD_VAR 0 7
65604: ARRAY
65605: PUSH
65606: LD_INT 2
65608: ARRAY
65609: PPUSH
65610: CALL_OW 488
65614: NOT
65615: PUSH
65616: LD_VAR 0 12
65620: PUSH
65621: LD_VAR 0 7
65625: ARRAY
65626: PUSH
65627: LD_INT 1
65629: ARRAY
65630: PPUSH
65631: LD_VAR 0 12
65635: PUSH
65636: LD_VAR 0 7
65640: ARRAY
65641: PUSH
65642: LD_INT 2
65644: ARRAY
65645: PPUSH
65646: CALL_OW 428
65650: PUSH
65651: LD_INT 0
65653: GREATER
65654: OR
65655: PUSH
65656: LD_VAR 0 12
65660: PUSH
65661: LD_VAR 0 7
65665: ARRAY
65666: PUSH
65667: LD_INT 1
65669: ARRAY
65670: PPUSH
65671: LD_VAR 0 12
65675: PUSH
65676: LD_VAR 0 7
65680: ARRAY
65681: PUSH
65682: LD_INT 2
65684: ARRAY
65685: PPUSH
65686: CALL_OW 351
65690: OR
65691: IFFALSE 65697
// exit ;
65693: POP
65694: POP
65695: GO 65989
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65697: LD_ADDR_VAR 0 8
65701: PUSH
65702: LD_VAR 0 12
65706: PUSH
65707: LD_VAR 0 7
65711: ARRAY
65712: PUSH
65713: LD_INT 1
65715: ARRAY
65716: PPUSH
65717: LD_VAR 0 12
65721: PUSH
65722: LD_VAR 0 7
65726: ARRAY
65727: PUSH
65728: LD_INT 2
65730: ARRAY
65731: PPUSH
65732: CALL_OW 546
65736: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65737: LD_VAR 0 8
65741: PUSH
65742: LD_INT 1
65744: ARRAY
65745: PUSH
65746: LD_VAR 0 8
65750: PUSH
65751: LD_INT 2
65753: ARRAY
65754: PUSH
65755: LD_VAR 0 13
65759: PUSH
65760: LD_INT 2
65762: PLUS
65763: GREATER
65764: OR
65765: PUSH
65766: LD_VAR 0 8
65770: PUSH
65771: LD_INT 2
65773: ARRAY
65774: PUSH
65775: LD_VAR 0 13
65779: PUSH
65780: LD_INT 2
65782: MINUS
65783: LESS
65784: OR
65785: PUSH
65786: LD_VAR 0 8
65790: PUSH
65791: LD_INT 3
65793: ARRAY
65794: PUSH
65795: LD_INT 0
65797: PUSH
65798: LD_INT 8
65800: PUSH
65801: LD_INT 9
65803: PUSH
65804: LD_INT 10
65806: PUSH
65807: LD_INT 11
65809: PUSH
65810: LD_INT 12
65812: PUSH
65813: LD_INT 13
65815: PUSH
65816: LD_INT 16
65818: PUSH
65819: LD_INT 17
65821: PUSH
65822: LD_INT 18
65824: PUSH
65825: LD_INT 19
65827: PUSH
65828: LD_INT 20
65830: PUSH
65831: LD_INT 21
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: IN
65849: NOT
65850: OR
65851: PUSH
65852: LD_VAR 0 8
65856: PUSH
65857: LD_INT 5
65859: ARRAY
65860: NOT
65861: OR
65862: PUSH
65863: LD_VAR 0 8
65867: PUSH
65868: LD_INT 6
65870: ARRAY
65871: PUSH
65872: LD_INT 1
65874: PUSH
65875: LD_INT 2
65877: PUSH
65878: LD_INT 7
65880: PUSH
65881: LD_INT 9
65883: PUSH
65884: LD_INT 10
65886: PUSH
65887: LD_INT 11
65889: PUSH
65890: EMPTY
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: IN
65898: NOT
65899: OR
65900: IFFALSE 65906
// exit ;
65902: POP
65903: POP
65904: GO 65989
// end ;
65906: GO 65577
65908: POP
65909: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65910: LD_VAR 0 9
65914: PPUSH
65915: LD_VAR 0 3
65919: PPUSH
65920: LD_VAR 0 4
65924: PPUSH
65925: LD_INT 20
65927: PPUSH
65928: CALL 57941 0 4
65932: PUSH
65933: LD_INT 4
65935: ARRAY
65936: IFFALSE 65940
// exit ;
65938: GO 65989
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65940: LD_VAR 0 2
65944: PUSH
65945: LD_INT 29
65947: PUSH
65948: LD_INT 30
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: IN
65955: PUSH
65956: LD_VAR 0 3
65960: PPUSH
65961: LD_VAR 0 4
65965: PPUSH
65966: LD_VAR 0 9
65970: PPUSH
65971: CALL_OW 440
65975: NOT
65976: AND
65977: IFFALSE 65981
// exit ;
65979: GO 65989
// result := true ;
65981: LD_ADDR_VAR 0 6
65985: PUSH
65986: LD_INT 1
65988: ST_TO_ADDR
// end ;
65989: LD_VAR 0 6
65993: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65994: LD_INT 0
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
66001: PPUSH
66002: PPUSH
66003: PPUSH
66004: PPUSH
66005: PPUSH
66006: PPUSH
66007: PPUSH
66008: PPUSH
66009: PPUSH
66010: PPUSH
66011: PPUSH
66012: PPUSH
66013: PPUSH
66014: PPUSH
66015: PPUSH
66016: PPUSH
66017: PPUSH
66018: PPUSH
66019: PPUSH
66020: PPUSH
66021: PPUSH
66022: PPUSH
66023: PPUSH
66024: PPUSH
66025: PPUSH
66026: PPUSH
66027: PPUSH
66028: PPUSH
66029: PPUSH
66030: PPUSH
66031: PPUSH
66032: PPUSH
66033: PPUSH
66034: PPUSH
66035: PPUSH
66036: PPUSH
66037: PPUSH
66038: PPUSH
66039: PPUSH
66040: PPUSH
66041: PPUSH
66042: PPUSH
66043: PPUSH
66044: PPUSH
66045: PPUSH
66046: PPUSH
66047: PPUSH
66048: PPUSH
66049: PPUSH
66050: PPUSH
66051: PPUSH
66052: PPUSH
66053: PPUSH
// result = [ ] ;
66054: LD_ADDR_VAR 0 7
66058: PUSH
66059: EMPTY
66060: ST_TO_ADDR
// temp_list = [ ] ;
66061: LD_ADDR_VAR 0 9
66065: PUSH
66066: EMPTY
66067: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66068: LD_VAR 0 4
66072: PUSH
66073: LD_INT 0
66075: PUSH
66076: LD_INT 1
66078: PUSH
66079: LD_INT 2
66081: PUSH
66082: LD_INT 3
66084: PUSH
66085: LD_INT 4
66087: PUSH
66088: LD_INT 5
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: LIST
66095: LIST
66096: LIST
66097: LIST
66098: IN
66099: NOT
66100: PUSH
66101: LD_VAR 0 1
66105: PUSH
66106: LD_INT 0
66108: PUSH
66109: LD_INT 1
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: IN
66116: PUSH
66117: LD_VAR 0 5
66121: PUSH
66122: LD_INT 1
66124: PUSH
66125: LD_INT 2
66127: PUSH
66128: LD_INT 3
66130: PUSH
66131: EMPTY
66132: LIST
66133: LIST
66134: LIST
66135: IN
66136: NOT
66137: AND
66138: OR
66139: IFFALSE 66143
// exit ;
66141: GO 84534
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66143: LD_VAR 0 1
66147: PUSH
66148: LD_INT 6
66150: PUSH
66151: LD_INT 7
66153: PUSH
66154: LD_INT 8
66156: PUSH
66157: LD_INT 13
66159: PUSH
66160: LD_INT 12
66162: PUSH
66163: LD_INT 15
66165: PUSH
66166: LD_INT 11
66168: PUSH
66169: LD_INT 14
66171: PUSH
66172: LD_INT 10
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: IN
66186: IFFALSE 66196
// btype = b_lab ;
66188: LD_ADDR_VAR 0 1
66192: PUSH
66193: LD_INT 6
66195: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66196: LD_VAR 0 6
66200: PUSH
66201: LD_INT 0
66203: PUSH
66204: LD_INT 1
66206: PUSH
66207: LD_INT 2
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: LIST
66214: IN
66215: NOT
66216: PUSH
66217: LD_VAR 0 1
66221: PUSH
66222: LD_INT 0
66224: PUSH
66225: LD_INT 1
66227: PUSH
66228: LD_INT 2
66230: PUSH
66231: LD_INT 3
66233: PUSH
66234: LD_INT 6
66236: PUSH
66237: LD_INT 36
66239: PUSH
66240: LD_INT 4
66242: PUSH
66243: LD_INT 5
66245: PUSH
66246: LD_INT 31
66248: PUSH
66249: LD_INT 32
66251: PUSH
66252: LD_INT 33
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: LIST
66264: LIST
66265: LIST
66266: LIST
66267: IN
66268: NOT
66269: PUSH
66270: LD_VAR 0 6
66274: PUSH
66275: LD_INT 1
66277: EQUAL
66278: AND
66279: OR
66280: PUSH
66281: LD_VAR 0 1
66285: PUSH
66286: LD_INT 2
66288: PUSH
66289: LD_INT 3
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: IN
66296: NOT
66297: PUSH
66298: LD_VAR 0 6
66302: PUSH
66303: LD_INT 2
66305: EQUAL
66306: AND
66307: OR
66308: IFFALSE 66318
// mode = 0 ;
66310: LD_ADDR_VAR 0 6
66314: PUSH
66315: LD_INT 0
66317: ST_TO_ADDR
// case mode of 0 :
66318: LD_VAR 0 6
66322: PUSH
66323: LD_INT 0
66325: DOUBLE
66326: EQUAL
66327: IFTRUE 66331
66329: GO 77784
66331: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66332: LD_ADDR_VAR 0 11
66336: PUSH
66337: LD_INT 0
66339: PUSH
66340: LD_INT 0
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 0
66349: PUSH
66350: LD_INT 1
66352: NEG
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: LD_INT 1
66360: PUSH
66361: LD_INT 0
66363: PUSH
66364: EMPTY
66365: LIST
66366: LIST
66367: PUSH
66368: LD_INT 1
66370: PUSH
66371: LD_INT 1
66373: PUSH
66374: EMPTY
66375: LIST
66376: LIST
66377: PUSH
66378: LD_INT 0
66380: PUSH
66381: LD_INT 1
66383: PUSH
66384: EMPTY
66385: LIST
66386: LIST
66387: PUSH
66388: LD_INT 1
66390: NEG
66391: PUSH
66392: LD_INT 0
66394: PUSH
66395: EMPTY
66396: LIST
66397: LIST
66398: PUSH
66399: LD_INT 1
66401: NEG
66402: PUSH
66403: LD_INT 1
66405: NEG
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 1
66413: NEG
66414: PUSH
66415: LD_INT 2
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 0
66425: PUSH
66426: LD_INT 2
66428: NEG
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PUSH
66434: LD_INT 1
66436: PUSH
66437: LD_INT 1
66439: NEG
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PUSH
66445: LD_INT 1
66447: PUSH
66448: LD_INT 2
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: LD_INT 0
66457: PUSH
66458: LD_INT 2
66460: PUSH
66461: EMPTY
66462: LIST
66463: LIST
66464: PUSH
66465: LD_INT 1
66467: NEG
66468: PUSH
66469: LD_INT 1
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 1
66478: PUSH
66479: LD_INT 3
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: LD_INT 0
66488: PUSH
66489: LD_INT 3
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PUSH
66496: LD_INT 1
66498: NEG
66499: PUSH
66500: LD_INT 2
66502: PUSH
66503: EMPTY
66504: LIST
66505: LIST
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66525: LD_ADDR_VAR 0 12
66529: PUSH
66530: LD_INT 0
66532: PUSH
66533: LD_INT 0
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 0
66542: PUSH
66543: LD_INT 1
66545: NEG
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: PUSH
66551: LD_INT 1
66553: PUSH
66554: LD_INT 0
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 1
66563: PUSH
66564: LD_INT 1
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: PUSH
66571: LD_INT 0
66573: PUSH
66574: LD_INT 1
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 1
66583: NEG
66584: PUSH
66585: LD_INT 0
66587: PUSH
66588: EMPTY
66589: LIST
66590: LIST
66591: PUSH
66592: LD_INT 1
66594: NEG
66595: PUSH
66596: LD_INT 1
66598: NEG
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: LD_INT 1
66606: PUSH
66607: LD_INT 1
66609: NEG
66610: PUSH
66611: EMPTY
66612: LIST
66613: LIST
66614: PUSH
66615: LD_INT 2
66617: PUSH
66618: LD_INT 0
66620: PUSH
66621: EMPTY
66622: LIST
66623: LIST
66624: PUSH
66625: LD_INT 2
66627: PUSH
66628: LD_INT 1
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 1
66637: NEG
66638: PUSH
66639: LD_INT 1
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: PUSH
66646: LD_INT 2
66648: NEG
66649: PUSH
66650: LD_INT 0
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: PUSH
66657: LD_INT 2
66659: NEG
66660: PUSH
66661: LD_INT 1
66663: NEG
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: LD_INT 2
66671: NEG
66672: PUSH
66673: LD_INT 1
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: PUSH
66680: LD_INT 3
66682: NEG
66683: PUSH
66684: LD_INT 0
66686: PUSH
66687: EMPTY
66688: LIST
66689: LIST
66690: PUSH
66691: LD_INT 3
66693: NEG
66694: PUSH
66695: LD_INT 1
66697: NEG
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: LIST
66707: LIST
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66721: LD_ADDR_VAR 0 13
66725: PUSH
66726: LD_INT 0
66728: PUSH
66729: LD_INT 0
66731: PUSH
66732: EMPTY
66733: LIST
66734: LIST
66735: PUSH
66736: LD_INT 0
66738: PUSH
66739: LD_INT 1
66741: NEG
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: LD_INT 1
66749: PUSH
66750: LD_INT 0
66752: PUSH
66753: EMPTY
66754: LIST
66755: LIST
66756: PUSH
66757: LD_INT 1
66759: PUSH
66760: LD_INT 1
66762: PUSH
66763: EMPTY
66764: LIST
66765: LIST
66766: PUSH
66767: LD_INT 0
66769: PUSH
66770: LD_INT 1
66772: PUSH
66773: EMPTY
66774: LIST
66775: LIST
66776: PUSH
66777: LD_INT 1
66779: NEG
66780: PUSH
66781: LD_INT 0
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: PUSH
66788: LD_INT 1
66790: NEG
66791: PUSH
66792: LD_INT 1
66794: NEG
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 1
66802: NEG
66803: PUSH
66804: LD_INT 2
66806: NEG
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: PUSH
66812: LD_INT 2
66814: PUSH
66815: LD_INT 1
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: LD_INT 2
66824: PUSH
66825: LD_INT 2
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 1
66834: PUSH
66835: LD_INT 2
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 2
66844: NEG
66845: PUSH
66846: LD_INT 1
66848: NEG
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 2
66856: NEG
66857: PUSH
66858: LD_INT 2
66860: NEG
66861: PUSH
66862: EMPTY
66863: LIST
66864: LIST
66865: PUSH
66866: LD_INT 2
66868: NEG
66869: PUSH
66870: LD_INT 3
66872: NEG
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: PUSH
66878: LD_INT 3
66880: NEG
66881: PUSH
66882: LD_INT 2
66884: NEG
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: PUSH
66890: LD_INT 3
66892: NEG
66893: PUSH
66894: LD_INT 3
66896: NEG
66897: PUSH
66898: EMPTY
66899: LIST
66900: LIST
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: LIST
66906: LIST
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66920: LD_ADDR_VAR 0 14
66924: PUSH
66925: LD_INT 0
66927: PUSH
66928: LD_INT 0
66930: PUSH
66931: EMPTY
66932: LIST
66933: LIST
66934: PUSH
66935: LD_INT 0
66937: PUSH
66938: LD_INT 1
66940: NEG
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PUSH
66946: LD_INT 1
66948: PUSH
66949: LD_INT 0
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: PUSH
66956: LD_INT 1
66958: PUSH
66959: LD_INT 1
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: PUSH
66966: LD_INT 0
66968: PUSH
66969: LD_INT 1
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PUSH
66976: LD_INT 1
66978: NEG
66979: PUSH
66980: LD_INT 0
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: LD_INT 1
66989: NEG
66990: PUSH
66991: LD_INT 1
66993: NEG
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: LD_INT 1
67001: NEG
67002: PUSH
67003: LD_INT 2
67005: NEG
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: PUSH
67011: LD_INT 0
67013: PUSH
67014: LD_INT 2
67016: NEG
67017: PUSH
67018: EMPTY
67019: LIST
67020: LIST
67021: PUSH
67022: LD_INT 1
67024: PUSH
67025: LD_INT 1
67027: NEG
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 1
67035: PUSH
67036: LD_INT 2
67038: PUSH
67039: EMPTY
67040: LIST
67041: LIST
67042: PUSH
67043: LD_INT 0
67045: PUSH
67046: LD_INT 2
67048: PUSH
67049: EMPTY
67050: LIST
67051: LIST
67052: PUSH
67053: LD_INT 1
67055: NEG
67056: PUSH
67057: LD_INT 1
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: LD_INT 1
67066: NEG
67067: PUSH
67068: LD_INT 3
67070: NEG
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 0
67078: PUSH
67079: LD_INT 3
67081: NEG
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: LD_INT 1
67089: PUSH
67090: LD_INT 2
67092: NEG
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: LIST
67104: LIST
67105: LIST
67106: LIST
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: LIST
67113: LIST
67114: LIST
67115: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67116: LD_ADDR_VAR 0 15
67120: PUSH
67121: LD_INT 0
67123: PUSH
67124: LD_INT 0
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 0
67133: PUSH
67134: LD_INT 1
67136: NEG
67137: PUSH
67138: EMPTY
67139: LIST
67140: LIST
67141: PUSH
67142: LD_INT 1
67144: PUSH
67145: LD_INT 0
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 1
67154: PUSH
67155: LD_INT 1
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 0
67164: PUSH
67165: LD_INT 1
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 1
67174: NEG
67175: PUSH
67176: LD_INT 0
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 1
67185: NEG
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 1
67197: PUSH
67198: LD_INT 1
67200: NEG
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 2
67208: PUSH
67209: LD_INT 0
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 2
67218: PUSH
67219: LD_INT 1
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 1
67228: NEG
67229: PUSH
67230: LD_INT 1
67232: PUSH
67233: EMPTY
67234: LIST
67235: LIST
67236: PUSH
67237: LD_INT 2
67239: NEG
67240: PUSH
67241: LD_INT 0
67243: PUSH
67244: EMPTY
67245: LIST
67246: LIST
67247: PUSH
67248: LD_INT 2
67250: NEG
67251: PUSH
67252: LD_INT 1
67254: NEG
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: PUSH
67260: LD_INT 2
67262: PUSH
67263: LD_INT 1
67265: NEG
67266: PUSH
67267: EMPTY
67268: LIST
67269: LIST
67270: PUSH
67271: LD_INT 3
67273: PUSH
67274: LD_INT 0
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: LD_INT 3
67283: PUSH
67284: LD_INT 1
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: PUSH
67291: EMPTY
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67309: LD_ADDR_VAR 0 16
67313: PUSH
67314: LD_INT 0
67316: PUSH
67317: LD_INT 0
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: PUSH
67324: LD_INT 0
67326: PUSH
67327: LD_INT 1
67329: NEG
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: PUSH
67335: LD_INT 1
67337: PUSH
67338: LD_INT 0
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 1
67347: PUSH
67348: LD_INT 1
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 0
67357: PUSH
67358: LD_INT 1
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 1
67367: NEG
67368: PUSH
67369: LD_INT 0
67371: PUSH
67372: EMPTY
67373: LIST
67374: LIST
67375: PUSH
67376: LD_INT 1
67378: NEG
67379: PUSH
67380: LD_INT 1
67382: NEG
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: LD_INT 1
67390: NEG
67391: PUSH
67392: LD_INT 2
67394: NEG
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: LD_INT 2
67402: PUSH
67403: LD_INT 1
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 2
67412: PUSH
67413: LD_INT 2
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 1
67422: PUSH
67423: LD_INT 2
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 2
67432: NEG
67433: PUSH
67434: LD_INT 1
67436: NEG
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 2
67444: NEG
67445: PUSH
67446: LD_INT 2
67448: NEG
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PUSH
67454: LD_INT 3
67456: PUSH
67457: LD_INT 2
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 3
67466: PUSH
67467: LD_INT 3
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: LD_INT 2
67476: PUSH
67477: LD_INT 3
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: EMPTY
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67502: LD_ADDR_VAR 0 17
67506: PUSH
67507: LD_INT 0
67509: PUSH
67510: LD_INT 0
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 0
67519: PUSH
67520: LD_INT 1
67522: NEG
67523: PUSH
67524: EMPTY
67525: LIST
67526: LIST
67527: PUSH
67528: LD_INT 1
67530: PUSH
67531: LD_INT 0
67533: PUSH
67534: EMPTY
67535: LIST
67536: LIST
67537: PUSH
67538: LD_INT 1
67540: PUSH
67541: LD_INT 1
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 0
67550: PUSH
67551: LD_INT 1
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 1
67560: NEG
67561: PUSH
67562: LD_INT 0
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 1
67571: NEG
67572: PUSH
67573: LD_INT 1
67575: NEG
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 1
67583: NEG
67584: PUSH
67585: LD_INT 2
67587: NEG
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 0
67595: PUSH
67596: LD_INT 2
67598: NEG
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PUSH
67604: LD_INT 1
67606: PUSH
67607: LD_INT 1
67609: NEG
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: PUSH
67615: LD_INT 2
67617: PUSH
67618: LD_INT 0
67620: PUSH
67621: EMPTY
67622: LIST
67623: LIST
67624: PUSH
67625: LD_INT 2
67627: PUSH
67628: LD_INT 1
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: LD_INT 2
67637: PUSH
67638: LD_INT 2
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: PUSH
67645: LD_INT 1
67647: PUSH
67648: LD_INT 2
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 0
67657: PUSH
67658: LD_INT 2
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 1
67667: NEG
67668: PUSH
67669: LD_INT 1
67671: PUSH
67672: EMPTY
67673: LIST
67674: LIST
67675: PUSH
67676: LD_INT 2
67678: NEG
67679: PUSH
67680: LD_INT 0
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PUSH
67687: LD_INT 2
67689: NEG
67690: PUSH
67691: LD_INT 1
67693: NEG
67694: PUSH
67695: EMPTY
67696: LIST
67697: LIST
67698: PUSH
67699: LD_INT 2
67701: NEG
67702: PUSH
67703: LD_INT 2
67705: NEG
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: LIST
67715: LIST
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67732: LD_ADDR_VAR 0 18
67736: PUSH
67737: LD_INT 0
67739: PUSH
67740: LD_INT 0
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: LD_INT 1
67752: NEG
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: LD_INT 1
67760: PUSH
67761: LD_INT 0
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 1
67770: PUSH
67771: LD_INT 1
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: LD_INT 0
67780: PUSH
67781: LD_INT 1
67783: PUSH
67784: EMPTY
67785: LIST
67786: LIST
67787: PUSH
67788: LD_INT 1
67790: NEG
67791: PUSH
67792: LD_INT 0
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PUSH
67799: LD_INT 1
67801: NEG
67802: PUSH
67803: LD_INT 1
67805: NEG
67806: PUSH
67807: EMPTY
67808: LIST
67809: LIST
67810: PUSH
67811: LD_INT 1
67813: NEG
67814: PUSH
67815: LD_INT 2
67817: NEG
67818: PUSH
67819: EMPTY
67820: LIST
67821: LIST
67822: PUSH
67823: LD_INT 0
67825: PUSH
67826: LD_INT 2
67828: NEG
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: LD_INT 1
67836: PUSH
67837: LD_INT 1
67839: NEG
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 2
67847: PUSH
67848: LD_INT 0
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 2
67857: PUSH
67858: LD_INT 1
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: PUSH
67865: LD_INT 2
67867: PUSH
67868: LD_INT 2
67870: PUSH
67871: EMPTY
67872: LIST
67873: LIST
67874: PUSH
67875: LD_INT 1
67877: PUSH
67878: LD_INT 2
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 0
67887: PUSH
67888: LD_INT 2
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 1
67897: NEG
67898: PUSH
67899: LD_INT 1
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 2
67908: NEG
67909: PUSH
67910: LD_INT 0
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: LD_INT 2
67919: NEG
67920: PUSH
67921: LD_INT 1
67923: NEG
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 2
67931: NEG
67932: PUSH
67933: LD_INT 2
67935: NEG
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: EMPTY
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: LIST
67952: LIST
67953: LIST
67954: LIST
67955: LIST
67956: LIST
67957: LIST
67958: LIST
67959: LIST
67960: LIST
67961: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67962: LD_ADDR_VAR 0 19
67966: PUSH
67967: LD_INT 0
67969: PUSH
67970: LD_INT 0
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: LD_INT 0
67979: PUSH
67980: LD_INT 1
67982: NEG
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 1
67990: PUSH
67991: LD_INT 0
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PUSH
67998: LD_INT 1
68000: PUSH
68001: LD_INT 1
68003: PUSH
68004: EMPTY
68005: LIST
68006: LIST
68007: PUSH
68008: LD_INT 0
68010: PUSH
68011: LD_INT 1
68013: PUSH
68014: EMPTY
68015: LIST
68016: LIST
68017: PUSH
68018: LD_INT 1
68020: NEG
68021: PUSH
68022: LD_INT 0
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 1
68031: NEG
68032: PUSH
68033: LD_INT 1
68035: NEG
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: LD_INT 1
68043: NEG
68044: PUSH
68045: LD_INT 2
68047: NEG
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 0
68055: PUSH
68056: LD_INT 2
68058: NEG
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 1
68066: PUSH
68067: LD_INT 1
68069: NEG
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 2
68077: PUSH
68078: LD_INT 0
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: LD_INT 1
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 2
68097: PUSH
68098: LD_INT 2
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 1
68107: PUSH
68108: LD_INT 2
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: PUSH
68115: LD_INT 0
68117: PUSH
68118: LD_INT 2
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 1
68127: NEG
68128: PUSH
68129: LD_INT 1
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 2
68138: NEG
68139: PUSH
68140: LD_INT 0
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: LD_INT 2
68149: NEG
68150: PUSH
68151: LD_INT 1
68153: NEG
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: LD_INT 2
68161: NEG
68162: PUSH
68163: LD_INT 2
68165: NEG
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68192: LD_ADDR_VAR 0 20
68196: PUSH
68197: LD_INT 0
68199: PUSH
68200: LD_INT 0
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 0
68209: PUSH
68210: LD_INT 1
68212: NEG
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: LD_INT 1
68220: PUSH
68221: LD_INT 0
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: LD_INT 1
68230: PUSH
68231: LD_INT 1
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: PUSH
68238: LD_INT 0
68240: PUSH
68241: LD_INT 1
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: PUSH
68248: LD_INT 1
68250: NEG
68251: PUSH
68252: LD_INT 0
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 1
68261: NEG
68262: PUSH
68263: LD_INT 1
68265: NEG
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: PUSH
68271: LD_INT 1
68273: NEG
68274: PUSH
68275: LD_INT 2
68277: NEG
68278: PUSH
68279: EMPTY
68280: LIST
68281: LIST
68282: PUSH
68283: LD_INT 0
68285: PUSH
68286: LD_INT 2
68288: NEG
68289: PUSH
68290: EMPTY
68291: LIST
68292: LIST
68293: PUSH
68294: LD_INT 1
68296: PUSH
68297: LD_INT 1
68299: NEG
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 2
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 2
68317: PUSH
68318: LD_INT 1
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: PUSH
68325: LD_INT 2
68327: PUSH
68328: LD_INT 2
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 1
68337: PUSH
68338: LD_INT 2
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 0
68347: PUSH
68348: LD_INT 2
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PUSH
68355: LD_INT 1
68357: NEG
68358: PUSH
68359: LD_INT 1
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PUSH
68366: LD_INT 2
68368: NEG
68369: PUSH
68370: LD_INT 0
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 2
68379: NEG
68380: PUSH
68381: LD_INT 1
68383: NEG
68384: PUSH
68385: EMPTY
68386: LIST
68387: LIST
68388: PUSH
68389: LD_INT 2
68391: NEG
68392: PUSH
68393: LD_INT 2
68395: NEG
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68422: LD_ADDR_VAR 0 21
68426: PUSH
68427: LD_INT 0
68429: PUSH
68430: LD_INT 0
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: LD_INT 0
68439: PUSH
68440: LD_INT 1
68442: NEG
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 1
68450: PUSH
68451: LD_INT 0
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 1
68460: PUSH
68461: LD_INT 1
68463: PUSH
68464: EMPTY
68465: LIST
68466: LIST
68467: PUSH
68468: LD_INT 0
68470: PUSH
68471: LD_INT 1
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 1
68480: NEG
68481: PUSH
68482: LD_INT 0
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 1
68491: NEG
68492: PUSH
68493: LD_INT 1
68495: NEG
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: LD_INT 1
68503: NEG
68504: PUSH
68505: LD_INT 2
68507: NEG
68508: PUSH
68509: EMPTY
68510: LIST
68511: LIST
68512: PUSH
68513: LD_INT 0
68515: PUSH
68516: LD_INT 2
68518: NEG
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: PUSH
68524: LD_INT 1
68526: PUSH
68527: LD_INT 1
68529: NEG
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PUSH
68535: LD_INT 2
68537: PUSH
68538: LD_INT 0
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: PUSH
68545: LD_INT 2
68547: PUSH
68548: LD_INT 1
68550: PUSH
68551: EMPTY
68552: LIST
68553: LIST
68554: PUSH
68555: LD_INT 2
68557: PUSH
68558: LD_INT 2
68560: PUSH
68561: EMPTY
68562: LIST
68563: LIST
68564: PUSH
68565: LD_INT 1
68567: PUSH
68568: LD_INT 2
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PUSH
68575: LD_INT 0
68577: PUSH
68578: LD_INT 2
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: PUSH
68585: LD_INT 1
68587: NEG
68588: PUSH
68589: LD_INT 1
68591: PUSH
68592: EMPTY
68593: LIST
68594: LIST
68595: PUSH
68596: LD_INT 2
68598: NEG
68599: PUSH
68600: LD_INT 0
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 2
68609: NEG
68610: PUSH
68611: LD_INT 1
68613: NEG
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: LD_INT 2
68621: NEG
68622: PUSH
68623: LD_INT 2
68625: NEG
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: LIST
68650: LIST
68651: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68652: LD_ADDR_VAR 0 22
68656: PUSH
68657: LD_INT 0
68659: PUSH
68660: LD_INT 0
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: LD_INT 1
68672: NEG
68673: PUSH
68674: EMPTY
68675: LIST
68676: LIST
68677: PUSH
68678: LD_INT 1
68680: PUSH
68681: LD_INT 0
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 1
68690: PUSH
68691: LD_INT 1
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PUSH
68698: LD_INT 0
68700: PUSH
68701: LD_INT 1
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 1
68710: NEG
68711: PUSH
68712: LD_INT 0
68714: PUSH
68715: EMPTY
68716: LIST
68717: LIST
68718: PUSH
68719: LD_INT 1
68721: NEG
68722: PUSH
68723: LD_INT 1
68725: NEG
68726: PUSH
68727: EMPTY
68728: LIST
68729: LIST
68730: PUSH
68731: LD_INT 1
68733: NEG
68734: PUSH
68735: LD_INT 2
68737: NEG
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PUSH
68743: LD_INT 0
68745: PUSH
68746: LD_INT 2
68748: NEG
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: PUSH
68754: LD_INT 1
68756: PUSH
68757: LD_INT 1
68759: NEG
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 2
68767: PUSH
68768: LD_INT 0
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 2
68777: PUSH
68778: LD_INT 1
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 2
68787: PUSH
68788: LD_INT 2
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: LD_INT 1
68797: PUSH
68798: LD_INT 2
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 0
68807: PUSH
68808: LD_INT 2
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 1
68817: NEG
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 2
68828: NEG
68829: PUSH
68830: LD_INT 0
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 2
68839: NEG
68840: PUSH
68841: LD_INT 1
68843: NEG
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: LD_INT 2
68851: NEG
68852: PUSH
68853: LD_INT 2
68855: NEG
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: PUSH
68861: EMPTY
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: LIST
68881: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68882: LD_ADDR_VAR 0 23
68886: PUSH
68887: LD_INT 0
68889: PUSH
68890: LD_INT 0
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 0
68899: PUSH
68900: LD_INT 1
68902: NEG
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 1
68910: PUSH
68911: LD_INT 0
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: PUSH
68918: LD_INT 1
68920: PUSH
68921: LD_INT 1
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 0
68930: PUSH
68931: LD_INT 1
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: LD_INT 1
68940: NEG
68941: PUSH
68942: LD_INT 0
68944: PUSH
68945: EMPTY
68946: LIST
68947: LIST
68948: PUSH
68949: LD_INT 1
68951: NEG
68952: PUSH
68953: LD_INT 1
68955: NEG
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PUSH
68961: LD_INT 1
68963: NEG
68964: PUSH
68965: LD_INT 2
68967: NEG
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: PUSH
68973: LD_INT 0
68975: PUSH
68976: LD_INT 2
68978: NEG
68979: PUSH
68980: EMPTY
68981: LIST
68982: LIST
68983: PUSH
68984: LD_INT 1
68986: PUSH
68987: LD_INT 1
68989: NEG
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 2
68997: PUSH
68998: LD_INT 0
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: LD_INT 2
69007: PUSH
69008: LD_INT 1
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 2
69017: PUSH
69018: LD_INT 2
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 1
69027: PUSH
69028: LD_INT 2
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: LD_INT 0
69037: PUSH
69038: LD_INT 2
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 1
69047: NEG
69048: PUSH
69049: LD_INT 1
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: LD_INT 2
69058: NEG
69059: PUSH
69060: LD_INT 0
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: LD_INT 2
69069: NEG
69070: PUSH
69071: LD_INT 1
69073: NEG
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: LD_INT 2
69081: NEG
69082: PUSH
69083: LD_INT 2
69085: NEG
69086: PUSH
69087: EMPTY
69088: LIST
69089: LIST
69090: PUSH
69091: LD_INT 2
69093: NEG
69094: PUSH
69095: LD_INT 3
69097: NEG
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: PUSH
69103: LD_INT 1
69105: NEG
69106: PUSH
69107: LD_INT 3
69109: NEG
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 1
69117: PUSH
69118: LD_INT 2
69120: NEG
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: PUSH
69126: LD_INT 2
69128: PUSH
69129: LD_INT 1
69131: NEG
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: LIST
69155: LIST
69156: LIST
69157: LIST
69158: LIST
69159: LIST
69160: LIST
69161: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69162: LD_ADDR_VAR 0 24
69166: PUSH
69167: LD_INT 0
69169: PUSH
69170: LD_INT 0
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: LD_INT 1
69182: NEG
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 1
69190: PUSH
69191: LD_INT 0
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 1
69200: PUSH
69201: LD_INT 1
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 0
69210: PUSH
69211: LD_INT 1
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: LD_INT 1
69220: NEG
69221: PUSH
69222: LD_INT 0
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 1
69231: NEG
69232: PUSH
69233: LD_INT 1
69235: NEG
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 1
69243: NEG
69244: PUSH
69245: LD_INT 2
69247: NEG
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 0
69255: PUSH
69256: LD_INT 2
69258: NEG
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 1
69266: PUSH
69267: LD_INT 1
69269: NEG
69270: PUSH
69271: EMPTY
69272: LIST
69273: LIST
69274: PUSH
69275: LD_INT 2
69277: PUSH
69278: LD_INT 0
69280: PUSH
69281: EMPTY
69282: LIST
69283: LIST
69284: PUSH
69285: LD_INT 2
69287: PUSH
69288: LD_INT 1
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: PUSH
69295: LD_INT 2
69297: PUSH
69298: LD_INT 2
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PUSH
69305: LD_INT 1
69307: PUSH
69308: LD_INT 2
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 0
69317: PUSH
69318: LD_INT 2
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 1
69327: NEG
69328: PUSH
69329: LD_INT 1
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: LD_INT 2
69338: NEG
69339: PUSH
69340: LD_INT 0
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: LD_INT 2
69349: NEG
69350: PUSH
69351: LD_INT 1
69353: NEG
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: PUSH
69359: LD_INT 2
69361: NEG
69362: PUSH
69363: LD_INT 2
69365: NEG
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 1
69373: PUSH
69374: LD_INT 2
69376: NEG
69377: PUSH
69378: EMPTY
69379: LIST
69380: LIST
69381: PUSH
69382: LD_INT 2
69384: PUSH
69385: LD_INT 1
69387: NEG
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 3
69395: PUSH
69396: LD_INT 1
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: LD_INT 3
69405: PUSH
69406: LD_INT 2
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: LIST
69435: LIST
69436: LIST
69437: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69438: LD_ADDR_VAR 0 25
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: LD_INT 0
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: PUSH
69453: LD_INT 0
69455: PUSH
69456: LD_INT 1
69458: NEG
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 1
69466: PUSH
69467: LD_INT 0
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PUSH
69474: LD_INT 1
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: PUSH
69484: LD_INT 0
69486: PUSH
69487: LD_INT 1
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 1
69496: NEG
69497: PUSH
69498: LD_INT 0
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 1
69507: NEG
69508: PUSH
69509: LD_INT 1
69511: NEG
69512: PUSH
69513: EMPTY
69514: LIST
69515: LIST
69516: PUSH
69517: LD_INT 1
69519: NEG
69520: PUSH
69521: LD_INT 2
69523: NEG
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: PUSH
69529: LD_INT 0
69531: PUSH
69532: LD_INT 2
69534: NEG
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: PUSH
69540: LD_INT 1
69542: PUSH
69543: LD_INT 1
69545: NEG
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: LD_INT 2
69553: PUSH
69554: LD_INT 0
69556: PUSH
69557: EMPTY
69558: LIST
69559: LIST
69560: PUSH
69561: LD_INT 2
69563: PUSH
69564: LD_INT 1
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 2
69573: PUSH
69574: LD_INT 2
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PUSH
69581: LD_INT 1
69583: PUSH
69584: LD_INT 2
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: LD_INT 0
69593: PUSH
69594: LD_INT 2
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 1
69603: NEG
69604: PUSH
69605: LD_INT 1
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 2
69614: NEG
69615: PUSH
69616: LD_INT 0
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: LD_INT 2
69625: NEG
69626: PUSH
69627: LD_INT 1
69629: NEG
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 2
69637: NEG
69638: PUSH
69639: LD_INT 2
69641: NEG
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 3
69649: PUSH
69650: LD_INT 1
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 3
69659: PUSH
69660: LD_INT 2
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 2
69669: PUSH
69670: LD_INT 3
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: LD_INT 3
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69712: LD_ADDR_VAR 0 26
69716: PUSH
69717: LD_INT 0
69719: PUSH
69720: LD_INT 0
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: PUSH
69727: LD_INT 0
69729: PUSH
69730: LD_INT 1
69732: NEG
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: PUSH
69738: LD_INT 1
69740: PUSH
69741: LD_INT 0
69743: PUSH
69744: EMPTY
69745: LIST
69746: LIST
69747: PUSH
69748: LD_INT 1
69750: PUSH
69751: LD_INT 1
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: PUSH
69758: LD_INT 0
69760: PUSH
69761: LD_INT 1
69763: PUSH
69764: EMPTY
69765: LIST
69766: LIST
69767: PUSH
69768: LD_INT 1
69770: NEG
69771: PUSH
69772: LD_INT 0
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: PUSH
69779: LD_INT 1
69781: NEG
69782: PUSH
69783: LD_INT 1
69785: NEG
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: PUSH
69791: LD_INT 1
69793: NEG
69794: PUSH
69795: LD_INT 2
69797: NEG
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 0
69805: PUSH
69806: LD_INT 2
69808: NEG
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 1
69816: PUSH
69817: LD_INT 1
69819: NEG
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: LD_INT 2
69827: PUSH
69828: LD_INT 0
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: PUSH
69835: LD_INT 2
69837: PUSH
69838: LD_INT 1
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 2
69847: PUSH
69848: LD_INT 2
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 1
69857: PUSH
69858: LD_INT 2
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: PUSH
69865: LD_INT 0
69867: PUSH
69868: LD_INT 2
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 1
69877: NEG
69878: PUSH
69879: LD_INT 1
69881: PUSH
69882: EMPTY
69883: LIST
69884: LIST
69885: PUSH
69886: LD_INT 2
69888: NEG
69889: PUSH
69890: LD_INT 0
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 2
69899: NEG
69900: PUSH
69901: LD_INT 1
69903: NEG
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 2
69911: NEG
69912: PUSH
69913: LD_INT 2
69915: NEG
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 2
69923: PUSH
69924: LD_INT 3
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 1
69933: PUSH
69934: LD_INT 3
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 1
69943: NEG
69944: PUSH
69945: LD_INT 2
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PUSH
69952: LD_INT 2
69954: NEG
69955: PUSH
69956: LD_INT 1
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69988: LD_ADDR_VAR 0 27
69992: PUSH
69993: LD_INT 0
69995: PUSH
69996: LD_INT 0
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 0
70005: PUSH
70006: LD_INT 1
70008: NEG
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 1
70016: PUSH
70017: LD_INT 0
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 1
70026: PUSH
70027: LD_INT 1
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 0
70036: PUSH
70037: LD_INT 1
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 1
70046: NEG
70047: PUSH
70048: LD_INT 0
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: LD_INT 1
70061: NEG
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 1
70069: NEG
70070: PUSH
70071: LD_INT 2
70073: NEG
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 0
70081: PUSH
70082: LD_INT 2
70084: NEG
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 1
70092: PUSH
70093: LD_INT 1
70095: NEG
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 2
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: LD_INT 1
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 2
70123: PUSH
70124: LD_INT 2
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 1
70133: PUSH
70134: LD_INT 2
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 0
70143: PUSH
70144: LD_INT 2
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 1
70153: NEG
70154: PUSH
70155: LD_INT 1
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: PUSH
70162: LD_INT 2
70164: NEG
70165: PUSH
70166: LD_INT 0
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 2
70175: NEG
70176: PUSH
70177: LD_INT 1
70179: NEG
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PUSH
70185: LD_INT 2
70187: NEG
70188: PUSH
70189: LD_INT 2
70191: NEG
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 1
70199: NEG
70200: PUSH
70201: LD_INT 2
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 2
70210: NEG
70211: PUSH
70212: LD_INT 1
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 3
70221: NEG
70222: PUSH
70223: LD_INT 1
70225: NEG
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: PUSH
70231: LD_INT 3
70233: NEG
70234: PUSH
70235: LD_INT 2
70237: NEG
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: LIST
70264: LIST
70265: LIST
70266: LIST
70267: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70268: LD_ADDR_VAR 0 28
70272: PUSH
70273: LD_INT 0
70275: PUSH
70276: LD_INT 0
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 0
70285: PUSH
70286: LD_INT 1
70288: NEG
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: PUSH
70294: LD_INT 1
70296: PUSH
70297: LD_INT 0
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: PUSH
70304: LD_INT 1
70306: PUSH
70307: LD_INT 1
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: PUSH
70314: LD_INT 0
70316: PUSH
70317: LD_INT 1
70319: PUSH
70320: EMPTY
70321: LIST
70322: LIST
70323: PUSH
70324: LD_INT 1
70326: NEG
70327: PUSH
70328: LD_INT 0
70330: PUSH
70331: EMPTY
70332: LIST
70333: LIST
70334: PUSH
70335: LD_INT 1
70337: NEG
70338: PUSH
70339: LD_INT 1
70341: NEG
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 1
70349: NEG
70350: PUSH
70351: LD_INT 2
70353: NEG
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 0
70361: PUSH
70362: LD_INT 2
70364: NEG
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 1
70372: PUSH
70373: LD_INT 1
70375: NEG
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 2
70383: PUSH
70384: LD_INT 0
70386: PUSH
70387: EMPTY
70388: LIST
70389: LIST
70390: PUSH
70391: LD_INT 2
70393: PUSH
70394: LD_INT 1
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PUSH
70401: LD_INT 2
70403: PUSH
70404: LD_INT 2
70406: PUSH
70407: EMPTY
70408: LIST
70409: LIST
70410: PUSH
70411: LD_INT 1
70413: PUSH
70414: LD_INT 2
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: PUSH
70421: LD_INT 0
70423: PUSH
70424: LD_INT 2
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PUSH
70431: LD_INT 1
70433: NEG
70434: PUSH
70435: LD_INT 1
70437: PUSH
70438: EMPTY
70439: LIST
70440: LIST
70441: PUSH
70442: LD_INT 2
70444: NEG
70445: PUSH
70446: LD_INT 0
70448: PUSH
70449: EMPTY
70450: LIST
70451: LIST
70452: PUSH
70453: LD_INT 2
70455: NEG
70456: PUSH
70457: LD_INT 1
70459: NEG
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PUSH
70465: LD_INT 2
70467: NEG
70468: PUSH
70469: LD_INT 2
70471: NEG
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 2
70479: NEG
70480: PUSH
70481: LD_INT 3
70483: NEG
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 1
70491: NEG
70492: PUSH
70493: LD_INT 3
70495: NEG
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 3
70503: NEG
70504: PUSH
70505: LD_INT 1
70507: NEG
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 3
70515: NEG
70516: PUSH
70517: LD_INT 2
70519: NEG
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70550: LD_ADDR_VAR 0 29
70554: PUSH
70555: LD_INT 0
70557: PUSH
70558: LD_INT 0
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: PUSH
70565: LD_INT 0
70567: PUSH
70568: LD_INT 1
70570: NEG
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 1
70578: PUSH
70579: LD_INT 0
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 1
70588: PUSH
70589: LD_INT 1
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: LD_INT 0
70598: PUSH
70599: LD_INT 1
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 1
70608: NEG
70609: PUSH
70610: LD_INT 0
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 1
70619: NEG
70620: PUSH
70621: LD_INT 1
70623: NEG
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 1
70631: NEG
70632: PUSH
70633: LD_INT 2
70635: NEG
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 0
70643: PUSH
70644: LD_INT 2
70646: NEG
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: LD_INT 1
70654: PUSH
70655: LD_INT 1
70657: NEG
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: LD_INT 2
70665: PUSH
70666: LD_INT 0
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 2
70675: PUSH
70676: LD_INT 1
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: PUSH
70683: LD_INT 1
70685: PUSH
70686: LD_INT 2
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: LD_INT 0
70695: PUSH
70696: LD_INT 2
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: LD_INT 1
70705: NEG
70706: PUSH
70707: LD_INT 1
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 2
70716: NEG
70717: PUSH
70718: LD_INT 1
70720: NEG
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 2
70728: NEG
70729: PUSH
70730: LD_INT 2
70732: NEG
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PUSH
70738: LD_INT 2
70740: NEG
70741: PUSH
70742: LD_INT 3
70744: NEG
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 2
70752: PUSH
70753: LD_INT 1
70755: NEG
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 3
70763: PUSH
70764: LD_INT 1
70766: PUSH
70767: EMPTY
70768: LIST
70769: LIST
70770: PUSH
70771: LD_INT 1
70773: PUSH
70774: LD_INT 3
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PUSH
70781: LD_INT 1
70783: NEG
70784: PUSH
70785: LD_INT 2
70787: PUSH
70788: EMPTY
70789: LIST
70790: LIST
70791: PUSH
70792: LD_INT 3
70794: NEG
70795: PUSH
70796: LD_INT 2
70798: NEG
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: LIST
70824: LIST
70825: LIST
70826: LIST
70827: LIST
70828: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70829: LD_ADDR_VAR 0 30
70833: PUSH
70834: LD_INT 0
70836: PUSH
70837: LD_INT 0
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 0
70846: PUSH
70847: LD_INT 1
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 1
70857: PUSH
70858: LD_INT 0
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: PUSH
70865: LD_INT 1
70867: PUSH
70868: LD_INT 1
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 0
70877: PUSH
70878: LD_INT 1
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 1
70887: NEG
70888: PUSH
70889: LD_INT 0
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: LD_INT 1
70902: NEG
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 1
70910: NEG
70911: PUSH
70912: LD_INT 2
70914: NEG
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 0
70922: PUSH
70923: LD_INT 2
70925: NEG
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 1
70933: PUSH
70934: LD_INT 1
70936: NEG
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: PUSH
70942: LD_INT 2
70944: PUSH
70945: LD_INT 0
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: PUSH
70952: LD_INT 2
70954: PUSH
70955: LD_INT 1
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: LD_INT 2
70964: PUSH
70965: LD_INT 2
70967: PUSH
70968: EMPTY
70969: LIST
70970: LIST
70971: PUSH
70972: LD_INT 1
70974: PUSH
70975: LD_INT 2
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 1
70984: NEG
70985: PUSH
70986: LD_INT 1
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 2
70995: NEG
70996: PUSH
70997: LD_INT 0
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 2
71006: NEG
71007: PUSH
71008: LD_INT 1
71010: NEG
71011: PUSH
71012: EMPTY
71013: LIST
71014: LIST
71015: PUSH
71016: LD_INT 1
71018: NEG
71019: PUSH
71020: LD_INT 3
71022: NEG
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 1
71030: PUSH
71031: LD_INT 2
71033: NEG
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 3
71041: PUSH
71042: LD_INT 2
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 2
71051: PUSH
71052: LD_INT 3
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 2
71061: NEG
71062: PUSH
71063: LD_INT 1
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: LD_INT 3
71072: NEG
71073: PUSH
71074: LD_INT 1
71076: NEG
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: EMPTY
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: LIST
71101: LIST
71102: LIST
71103: LIST
71104: LIST
71105: LIST
71106: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71107: LD_ADDR_VAR 0 31
71111: PUSH
71112: LD_INT 0
71114: PUSH
71115: LD_INT 0
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PUSH
71122: LD_INT 0
71124: PUSH
71125: LD_INT 1
71127: NEG
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: LD_INT 1
71135: PUSH
71136: LD_INT 0
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 1
71145: PUSH
71146: LD_INT 1
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: LD_INT 0
71155: PUSH
71156: LD_INT 1
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: LD_INT 1
71165: NEG
71166: PUSH
71167: LD_INT 0
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 1
71176: NEG
71177: PUSH
71178: LD_INT 1
71180: NEG
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PUSH
71186: LD_INT 1
71188: NEG
71189: PUSH
71190: LD_INT 2
71192: NEG
71193: PUSH
71194: EMPTY
71195: LIST
71196: LIST
71197: PUSH
71198: LD_INT 1
71200: PUSH
71201: LD_INT 1
71203: NEG
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PUSH
71209: LD_INT 2
71211: PUSH
71212: LD_INT 0
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: LD_INT 2
71221: PUSH
71222: LD_INT 1
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: PUSH
71229: LD_INT 2
71231: PUSH
71232: LD_INT 2
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 1
71241: PUSH
71242: LD_INT 2
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: LD_INT 0
71251: PUSH
71252: LD_INT 2
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 1
71261: NEG
71262: PUSH
71263: LD_INT 1
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 2
71272: NEG
71273: PUSH
71274: LD_INT 1
71276: NEG
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 2
71284: NEG
71285: PUSH
71286: LD_INT 2
71288: NEG
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PUSH
71294: LD_INT 2
71296: NEG
71297: PUSH
71298: LD_INT 3
71300: NEG
71301: PUSH
71302: EMPTY
71303: LIST
71304: LIST
71305: PUSH
71306: LD_INT 2
71308: PUSH
71309: LD_INT 1
71311: NEG
71312: PUSH
71313: EMPTY
71314: LIST
71315: LIST
71316: PUSH
71317: LD_INT 3
71319: PUSH
71320: LD_INT 1
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 1
71329: PUSH
71330: LD_INT 3
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 1
71339: NEG
71340: PUSH
71341: LD_INT 2
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PUSH
71348: LD_INT 3
71350: NEG
71351: PUSH
71352: LD_INT 2
71354: NEG
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71385: LD_ADDR_VAR 0 32
71389: PUSH
71390: LD_INT 0
71392: PUSH
71393: LD_INT 0
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: PUSH
71400: LD_INT 0
71402: PUSH
71403: LD_INT 1
71405: NEG
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: LD_INT 1
71413: PUSH
71414: LD_INT 0
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: LD_INT 1
71423: PUSH
71424: LD_INT 1
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 0
71433: PUSH
71434: LD_INT 1
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PUSH
71441: LD_INT 1
71443: NEG
71444: PUSH
71445: LD_INT 0
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 1
71454: NEG
71455: PUSH
71456: LD_INT 1
71458: NEG
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 1
71466: NEG
71467: PUSH
71468: LD_INT 2
71470: NEG
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 0
71478: PUSH
71479: LD_INT 2
71481: NEG
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: PUSH
71487: LD_INT 1
71489: PUSH
71490: LD_INT 1
71492: NEG
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: PUSH
71498: LD_INT 2
71500: PUSH
71501: LD_INT 1
71503: PUSH
71504: EMPTY
71505: LIST
71506: LIST
71507: PUSH
71508: LD_INT 2
71510: PUSH
71511: LD_INT 2
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 1
71520: PUSH
71521: LD_INT 2
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: LD_INT 0
71530: PUSH
71531: LD_INT 2
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 1
71540: NEG
71541: PUSH
71542: LD_INT 1
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: PUSH
71549: LD_INT 2
71551: NEG
71552: PUSH
71553: LD_INT 0
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PUSH
71560: LD_INT 2
71562: NEG
71563: PUSH
71564: LD_INT 1
71566: NEG
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PUSH
71572: LD_INT 1
71574: NEG
71575: PUSH
71576: LD_INT 3
71578: NEG
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: PUSH
71584: LD_INT 1
71586: PUSH
71587: LD_INT 2
71589: NEG
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 3
71597: PUSH
71598: LD_INT 2
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: LD_INT 2
71607: PUSH
71608: LD_INT 3
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: PUSH
71615: LD_INT 2
71617: NEG
71618: PUSH
71619: LD_INT 1
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: PUSH
71626: LD_INT 3
71628: NEG
71629: PUSH
71630: LD_INT 1
71632: NEG
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: EMPTY
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: LIST
71655: LIST
71656: LIST
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: LIST
71662: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71663: LD_ADDR_VAR 0 33
71667: PUSH
71668: LD_INT 0
71670: PUSH
71671: LD_INT 0
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: PUSH
71678: LD_INT 0
71680: PUSH
71681: LD_INT 1
71683: NEG
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 1
71691: PUSH
71692: LD_INT 0
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 1
71701: PUSH
71702: LD_INT 1
71704: PUSH
71705: EMPTY
71706: LIST
71707: LIST
71708: PUSH
71709: LD_INT 0
71711: PUSH
71712: LD_INT 1
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: PUSH
71719: LD_INT 1
71721: NEG
71722: PUSH
71723: LD_INT 0
71725: PUSH
71726: EMPTY
71727: LIST
71728: LIST
71729: PUSH
71730: LD_INT 1
71732: NEG
71733: PUSH
71734: LD_INT 1
71736: NEG
71737: PUSH
71738: EMPTY
71739: LIST
71740: LIST
71741: PUSH
71742: LD_INT 1
71744: NEG
71745: PUSH
71746: LD_INT 2
71748: NEG
71749: PUSH
71750: EMPTY
71751: LIST
71752: LIST
71753: PUSH
71754: LD_INT 1
71756: PUSH
71757: LD_INT 1
71759: NEG
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: PUSH
71765: LD_INT 2
71767: PUSH
71768: LD_INT 0
71770: PUSH
71771: EMPTY
71772: LIST
71773: LIST
71774: PUSH
71775: LD_INT 2
71777: PUSH
71778: LD_INT 1
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: PUSH
71785: LD_INT 1
71787: PUSH
71788: LD_INT 2
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 0
71797: PUSH
71798: LD_INT 2
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: PUSH
71809: LD_INT 1
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 2
71818: NEG
71819: PUSH
71820: LD_INT 0
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 2
71829: NEG
71830: PUSH
71831: LD_INT 1
71833: NEG
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 2
71841: NEG
71842: PUSH
71843: LD_INT 2
71845: NEG
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PUSH
71851: LD_INT 2
71853: NEG
71854: PUSH
71855: LD_INT 3
71857: NEG
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: PUSH
71863: LD_INT 2
71865: PUSH
71866: LD_INT 1
71868: NEG
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: PUSH
71874: LD_INT 3
71876: PUSH
71877: LD_INT 1
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 1
71886: PUSH
71887: LD_INT 3
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 1
71896: NEG
71897: PUSH
71898: LD_INT 2
71900: PUSH
71901: EMPTY
71902: LIST
71903: LIST
71904: PUSH
71905: LD_INT 3
71907: NEG
71908: PUSH
71909: LD_INT 2
71911: NEG
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: LIST
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: LIST
71929: LIST
71930: LIST
71931: LIST
71932: LIST
71933: LIST
71934: LIST
71935: LIST
71936: LIST
71937: LIST
71938: LIST
71939: LIST
71940: LIST
71941: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71942: LD_ADDR_VAR 0 34
71946: PUSH
71947: LD_INT 0
71949: PUSH
71950: LD_INT 0
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 0
71959: PUSH
71960: LD_INT 1
71962: NEG
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: LD_INT 1
71970: PUSH
71971: LD_INT 0
71973: PUSH
71974: EMPTY
71975: LIST
71976: LIST
71977: PUSH
71978: LD_INT 1
71980: PUSH
71981: LD_INT 1
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: LD_INT 0
71990: PUSH
71991: LD_INT 1
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 1
72000: NEG
72001: PUSH
72002: LD_INT 0
72004: PUSH
72005: EMPTY
72006: LIST
72007: LIST
72008: PUSH
72009: LD_INT 1
72011: NEG
72012: PUSH
72013: LD_INT 1
72015: NEG
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 1
72023: NEG
72024: PUSH
72025: LD_INT 2
72027: NEG
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 0
72035: PUSH
72036: LD_INT 2
72038: NEG
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 1
72046: PUSH
72047: LD_INT 1
72049: NEG
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: LD_INT 2
72057: PUSH
72058: LD_INT 1
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: LD_INT 2
72067: PUSH
72068: LD_INT 2
72070: PUSH
72071: EMPTY
72072: LIST
72073: LIST
72074: PUSH
72075: LD_INT 1
72077: PUSH
72078: LD_INT 2
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: PUSH
72085: LD_INT 1
72087: NEG
72088: PUSH
72089: LD_INT 1
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 2
72098: NEG
72099: PUSH
72100: LD_INT 0
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: PUSH
72107: LD_INT 2
72109: NEG
72110: PUSH
72111: LD_INT 1
72113: NEG
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 2
72121: NEG
72122: PUSH
72123: LD_INT 2
72125: NEG
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 1
72133: NEG
72134: PUSH
72135: LD_INT 3
72137: NEG
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 1
72145: PUSH
72146: LD_INT 2
72148: NEG
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 3
72156: PUSH
72157: LD_INT 2
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 2
72166: PUSH
72167: LD_INT 3
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PUSH
72174: LD_INT 2
72176: NEG
72177: PUSH
72178: LD_INT 1
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: PUSH
72185: LD_INT 3
72187: NEG
72188: PUSH
72189: LD_INT 1
72191: NEG
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: LIST
72201: LIST
72202: LIST
72203: LIST
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: LIST
72217: LIST
72218: LIST
72219: LIST
72220: LIST
72221: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72222: LD_ADDR_VAR 0 35
72226: PUSH
72227: LD_INT 0
72229: PUSH
72230: LD_INT 0
72232: PUSH
72233: EMPTY
72234: LIST
72235: LIST
72236: PUSH
72237: LD_INT 0
72239: PUSH
72240: LD_INT 1
72242: NEG
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 1
72250: PUSH
72251: LD_INT 0
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: LD_INT 1
72260: PUSH
72261: LD_INT 1
72263: PUSH
72264: EMPTY
72265: LIST
72266: LIST
72267: PUSH
72268: LD_INT 0
72270: PUSH
72271: LD_INT 1
72273: PUSH
72274: EMPTY
72275: LIST
72276: LIST
72277: PUSH
72278: LD_INT 1
72280: NEG
72281: PUSH
72282: LD_INT 0
72284: PUSH
72285: EMPTY
72286: LIST
72287: LIST
72288: PUSH
72289: LD_INT 1
72291: NEG
72292: PUSH
72293: LD_INT 1
72295: NEG
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: PUSH
72301: LD_INT 2
72303: PUSH
72304: LD_INT 1
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: LD_INT 2
72313: NEG
72314: PUSH
72315: LD_INT 1
72317: NEG
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72334: LD_ADDR_VAR 0 36
72338: PUSH
72339: LD_INT 0
72341: PUSH
72342: LD_INT 0
72344: PUSH
72345: EMPTY
72346: LIST
72347: LIST
72348: PUSH
72349: LD_INT 0
72351: PUSH
72352: LD_INT 1
72354: NEG
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 1
72362: PUSH
72363: LD_INT 0
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 1
72372: PUSH
72373: LD_INT 1
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 0
72382: PUSH
72383: LD_INT 1
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: PUSH
72390: LD_INT 1
72392: NEG
72393: PUSH
72394: LD_INT 0
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: LD_INT 1
72403: NEG
72404: PUSH
72405: LD_INT 1
72407: NEG
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: LD_INT 1
72415: NEG
72416: PUSH
72417: LD_INT 2
72419: NEG
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: LD_INT 2
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: LIST
72441: LIST
72442: LIST
72443: LIST
72444: LIST
72445: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72446: LD_ADDR_VAR 0 37
72450: PUSH
72451: LD_INT 0
72453: PUSH
72454: LD_INT 0
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 0
72463: PUSH
72464: LD_INT 1
72466: NEG
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 1
72474: PUSH
72475: LD_INT 0
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 1
72484: PUSH
72485: LD_INT 1
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: LD_INT 1
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 1
72504: NEG
72505: PUSH
72506: LD_INT 0
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 1
72515: NEG
72516: PUSH
72517: LD_INT 1
72519: NEG
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 1
72527: PUSH
72528: LD_INT 1
72530: NEG
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PUSH
72536: LD_INT 1
72538: NEG
72539: PUSH
72540: LD_INT 1
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72558: LD_ADDR_VAR 0 38
72562: PUSH
72563: LD_INT 0
72565: PUSH
72566: LD_INT 0
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 0
72575: PUSH
72576: LD_INT 1
72578: NEG
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PUSH
72584: LD_INT 1
72586: PUSH
72587: LD_INT 0
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: PUSH
72594: LD_INT 1
72596: PUSH
72597: LD_INT 1
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: LD_INT 0
72606: PUSH
72607: LD_INT 1
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 1
72616: NEG
72617: PUSH
72618: LD_INT 0
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: PUSH
72625: LD_INT 1
72627: NEG
72628: PUSH
72629: LD_INT 1
72631: NEG
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: PUSH
72637: LD_INT 2
72639: PUSH
72640: LD_INT 1
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 2
72649: NEG
72650: PUSH
72651: LD_INT 1
72653: NEG
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72670: LD_ADDR_VAR 0 39
72674: PUSH
72675: LD_INT 0
72677: PUSH
72678: LD_INT 0
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 0
72687: PUSH
72688: LD_INT 1
72690: NEG
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 1
72698: PUSH
72699: LD_INT 0
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 1
72708: PUSH
72709: LD_INT 1
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 0
72718: PUSH
72719: LD_INT 1
72721: PUSH
72722: EMPTY
72723: LIST
72724: LIST
72725: PUSH
72726: LD_INT 1
72728: NEG
72729: PUSH
72730: LD_INT 0
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: PUSH
72737: LD_INT 1
72739: NEG
72740: PUSH
72741: LD_INT 1
72743: NEG
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 1
72751: NEG
72752: PUSH
72753: LD_INT 2
72755: NEG
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 1
72763: PUSH
72764: LD_INT 2
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72782: LD_ADDR_VAR 0 40
72786: PUSH
72787: LD_INT 0
72789: PUSH
72790: LD_INT 0
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 0
72799: PUSH
72800: LD_INT 1
72802: NEG
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PUSH
72808: LD_INT 1
72810: PUSH
72811: LD_INT 0
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: LD_INT 1
72820: PUSH
72821: LD_INT 1
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: PUSH
72828: LD_INT 0
72830: PUSH
72831: LD_INT 1
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: PUSH
72838: LD_INT 1
72840: NEG
72841: PUSH
72842: LD_INT 0
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: PUSH
72849: LD_INT 1
72851: NEG
72852: PUSH
72853: LD_INT 1
72855: NEG
72856: PUSH
72857: EMPTY
72858: LIST
72859: LIST
72860: PUSH
72861: LD_INT 1
72863: PUSH
72864: LD_INT 1
72866: NEG
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: PUSH
72872: LD_INT 1
72874: NEG
72875: PUSH
72876: LD_INT 1
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: LIST
72890: LIST
72891: LIST
72892: LIST
72893: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72894: LD_ADDR_VAR 0 41
72898: PUSH
72899: LD_INT 0
72901: PUSH
72902: LD_INT 0
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PUSH
72909: LD_INT 0
72911: PUSH
72912: LD_INT 1
72914: NEG
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: PUSH
72920: LD_INT 1
72922: PUSH
72923: LD_INT 0
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 1
72932: PUSH
72933: LD_INT 1
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: LD_INT 1
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 1
72952: NEG
72953: PUSH
72954: LD_INT 0
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: LD_INT 1
72967: NEG
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 1
72975: NEG
72976: PUSH
72977: LD_INT 2
72979: NEG
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: PUSH
72985: LD_INT 1
72987: PUSH
72988: LD_INT 1
72990: NEG
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: PUSH
72996: LD_INT 2
72998: PUSH
72999: LD_INT 0
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: PUSH
73006: LD_INT 2
73008: PUSH
73009: LD_INT 1
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: LD_INT 2
73018: PUSH
73019: LD_INT 2
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 1
73028: PUSH
73029: LD_INT 2
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PUSH
73036: LD_INT 1
73038: NEG
73039: PUSH
73040: LD_INT 1
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: LD_INT 2
73049: NEG
73050: PUSH
73051: LD_INT 0
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 2
73060: NEG
73061: PUSH
73062: LD_INT 1
73064: NEG
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_INT 2
73072: NEG
73073: PUSH
73074: LD_INT 2
73076: NEG
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 2
73084: NEG
73085: PUSH
73086: LD_INT 3
73088: NEG
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 2
73096: PUSH
73097: LD_INT 1
73099: NEG
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 3
73107: PUSH
73108: LD_INT 0
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: PUSH
73115: LD_INT 3
73117: PUSH
73118: LD_INT 1
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 3
73127: PUSH
73128: LD_INT 2
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PUSH
73135: LD_INT 3
73137: PUSH
73138: LD_INT 3
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 2
73147: PUSH
73148: LD_INT 3
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 2
73157: NEG
73158: PUSH
73159: LD_INT 1
73161: PUSH
73162: EMPTY
73163: LIST
73164: LIST
73165: PUSH
73166: LD_INT 3
73168: NEG
73169: PUSH
73170: LD_INT 0
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PUSH
73177: LD_INT 3
73179: NEG
73180: PUSH
73181: LD_INT 1
73183: NEG
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 3
73191: NEG
73192: PUSH
73193: LD_INT 2
73195: NEG
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 3
73203: NEG
73204: PUSH
73205: LD_INT 3
73207: NEG
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: PUSH
73213: EMPTY
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: LIST
73243: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73244: LD_ADDR_VAR 0 42
73248: PUSH
73249: LD_INT 0
73251: PUSH
73252: LD_INT 0
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 0
73261: PUSH
73262: LD_INT 1
73264: NEG
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 1
73272: PUSH
73273: LD_INT 0
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: LD_INT 1
73282: PUSH
73283: LD_INT 1
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 0
73292: PUSH
73293: LD_INT 1
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 1
73302: NEG
73303: PUSH
73304: LD_INT 0
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: LD_INT 1
73317: NEG
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 1
73325: NEG
73326: PUSH
73327: LD_INT 2
73329: NEG
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 0
73337: PUSH
73338: LD_INT 2
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 1
73348: PUSH
73349: LD_INT 1
73351: NEG
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: PUSH
73357: LD_INT 2
73359: PUSH
73360: LD_INT 1
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: PUSH
73367: LD_INT 2
73369: PUSH
73370: LD_INT 2
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: PUSH
73377: LD_INT 1
73379: PUSH
73380: LD_INT 2
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: LD_INT 2
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 1
73399: NEG
73400: PUSH
73401: LD_INT 1
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PUSH
73408: LD_INT 2
73410: NEG
73411: PUSH
73412: LD_INT 1
73414: NEG
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 2
73422: NEG
73423: PUSH
73424: LD_INT 2
73426: NEG
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: LD_INT 2
73434: NEG
73435: PUSH
73436: LD_INT 3
73438: NEG
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 1
73446: NEG
73447: PUSH
73448: LD_INT 3
73450: NEG
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 0
73458: PUSH
73459: LD_INT 3
73461: NEG
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: LD_INT 1
73469: PUSH
73470: LD_INT 2
73472: NEG
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: LD_INT 3
73480: PUSH
73481: LD_INT 2
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: PUSH
73488: LD_INT 3
73490: PUSH
73491: LD_INT 3
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 2
73500: PUSH
73501: LD_INT 3
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 1
73510: PUSH
73511: LD_INT 3
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 0
73520: PUSH
73521: LD_INT 3
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 1
73530: NEG
73531: PUSH
73532: LD_INT 2
73534: PUSH
73535: EMPTY
73536: LIST
73537: LIST
73538: PUSH
73539: LD_INT 3
73541: NEG
73542: PUSH
73543: LD_INT 2
73545: NEG
73546: PUSH
73547: EMPTY
73548: LIST
73549: LIST
73550: PUSH
73551: LD_INT 3
73553: NEG
73554: PUSH
73555: LD_INT 3
73557: NEG
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: LIST
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73594: LD_ADDR_VAR 0 43
73598: PUSH
73599: LD_INT 0
73601: PUSH
73602: LD_INT 0
73604: PUSH
73605: EMPTY
73606: LIST
73607: LIST
73608: PUSH
73609: LD_INT 0
73611: PUSH
73612: LD_INT 1
73614: NEG
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: PUSH
73620: LD_INT 1
73622: PUSH
73623: LD_INT 0
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: PUSH
73630: LD_INT 1
73632: PUSH
73633: LD_INT 1
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 0
73642: PUSH
73643: LD_INT 1
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: PUSH
73650: LD_INT 1
73652: NEG
73653: PUSH
73654: LD_INT 0
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: LD_INT 1
73663: NEG
73664: PUSH
73665: LD_INT 1
73667: NEG
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 1
73675: NEG
73676: PUSH
73677: LD_INT 2
73679: NEG
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: PUSH
73685: LD_INT 0
73687: PUSH
73688: LD_INT 2
73690: NEG
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: LD_INT 1
73698: PUSH
73699: LD_INT 1
73701: NEG
73702: PUSH
73703: EMPTY
73704: LIST
73705: LIST
73706: PUSH
73707: LD_INT 2
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 2
73719: PUSH
73720: LD_INT 1
73722: PUSH
73723: EMPTY
73724: LIST
73725: LIST
73726: PUSH
73727: LD_INT 1
73729: PUSH
73730: LD_INT 2
73732: PUSH
73733: EMPTY
73734: LIST
73735: LIST
73736: PUSH
73737: LD_INT 0
73739: PUSH
73740: LD_INT 2
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 1
73749: NEG
73750: PUSH
73751: LD_INT 1
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: PUSH
73758: LD_INT 2
73760: NEG
73761: PUSH
73762: LD_INT 0
73764: PUSH
73765: EMPTY
73766: LIST
73767: LIST
73768: PUSH
73769: LD_INT 2
73771: NEG
73772: PUSH
73773: LD_INT 1
73775: NEG
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: PUSH
73781: LD_INT 1
73783: NEG
73784: PUSH
73785: LD_INT 3
73787: NEG
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 0
73795: PUSH
73796: LD_INT 3
73798: NEG
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 1
73806: PUSH
73807: LD_INT 2
73809: NEG
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: PUSH
73815: LD_INT 2
73817: PUSH
73818: LD_INT 1
73820: NEG
73821: PUSH
73822: EMPTY
73823: LIST
73824: LIST
73825: PUSH
73826: LD_INT 3
73828: PUSH
73829: LD_INT 0
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 3
73838: PUSH
73839: LD_INT 1
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PUSH
73846: LD_INT 1
73848: PUSH
73849: LD_INT 3
73851: PUSH
73852: EMPTY
73853: LIST
73854: LIST
73855: PUSH
73856: LD_INT 0
73858: PUSH
73859: LD_INT 3
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 1
73868: NEG
73869: PUSH
73870: LD_INT 2
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 2
73879: NEG
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 3
73890: NEG
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 3
73901: NEG
73902: PUSH
73903: LD_INT 1
73905: NEG
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: LIST
73940: LIST
73941: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73942: LD_ADDR_VAR 0 44
73946: PUSH
73947: LD_INT 0
73949: PUSH
73950: LD_INT 0
73952: PUSH
73953: EMPTY
73954: LIST
73955: LIST
73956: PUSH
73957: LD_INT 0
73959: PUSH
73960: LD_INT 1
73962: NEG
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 1
73970: PUSH
73971: LD_INT 0
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 1
73980: PUSH
73981: LD_INT 1
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 0
73990: PUSH
73991: LD_INT 1
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 1
74000: NEG
74001: PUSH
74002: LD_INT 0
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PUSH
74009: LD_INT 1
74011: NEG
74012: PUSH
74013: LD_INT 1
74015: NEG
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: LD_INT 1
74023: NEG
74024: PUSH
74025: LD_INT 2
74027: NEG
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: PUSH
74033: LD_INT 1
74035: PUSH
74036: LD_INT 1
74038: NEG
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 2
74046: PUSH
74047: LD_INT 0
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: LD_INT 2
74056: PUSH
74057: LD_INT 1
74059: PUSH
74060: EMPTY
74061: LIST
74062: LIST
74063: PUSH
74064: LD_INT 2
74066: PUSH
74067: LD_INT 2
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: PUSH
74074: LD_INT 1
74076: PUSH
74077: LD_INT 2
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 1
74086: NEG
74087: PUSH
74088: LD_INT 1
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: LD_INT 2
74097: NEG
74098: PUSH
74099: LD_INT 0
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 2
74108: NEG
74109: PUSH
74110: LD_INT 1
74112: NEG
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 2
74120: NEG
74121: PUSH
74122: LD_INT 2
74124: NEG
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 2
74132: NEG
74133: PUSH
74134: LD_INT 3
74136: NEG
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 2
74144: PUSH
74145: LD_INT 1
74147: NEG
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 3
74155: PUSH
74156: LD_INT 0
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_INT 3
74165: PUSH
74166: LD_INT 1
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PUSH
74173: LD_INT 3
74175: PUSH
74176: LD_INT 2
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: LD_INT 3
74185: PUSH
74186: LD_INT 3
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: LD_INT 2
74195: PUSH
74196: LD_INT 3
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PUSH
74203: LD_INT 2
74205: NEG
74206: PUSH
74207: LD_INT 1
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: PUSH
74214: LD_INT 3
74216: NEG
74217: PUSH
74218: LD_INT 0
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: PUSH
74225: LD_INT 3
74227: NEG
74228: PUSH
74229: LD_INT 1
74231: NEG
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PUSH
74237: LD_INT 3
74239: NEG
74240: PUSH
74241: LD_INT 2
74243: NEG
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 3
74251: NEG
74252: PUSH
74253: LD_INT 3
74255: NEG
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: LIST
74265: LIST
74266: LIST
74267: LIST
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: LIST
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: LIST
74291: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74292: LD_ADDR_VAR 0 45
74296: PUSH
74297: LD_INT 0
74299: PUSH
74300: LD_INT 0
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: LD_INT 0
74309: PUSH
74310: LD_INT 1
74312: NEG
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 1
74320: PUSH
74321: LD_INT 0
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: LD_INT 1
74330: PUSH
74331: LD_INT 1
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PUSH
74338: LD_INT 0
74340: PUSH
74341: LD_INT 1
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: PUSH
74348: LD_INT 1
74350: NEG
74351: PUSH
74352: LD_INT 0
74354: PUSH
74355: EMPTY
74356: LIST
74357: LIST
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: PUSH
74363: LD_INT 1
74365: NEG
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: PUSH
74371: LD_INT 1
74373: NEG
74374: PUSH
74375: LD_INT 2
74377: NEG
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 0
74385: PUSH
74386: LD_INT 2
74388: NEG
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 1
74396: PUSH
74397: LD_INT 1
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 2
74407: PUSH
74408: LD_INT 1
74410: PUSH
74411: EMPTY
74412: LIST
74413: LIST
74414: PUSH
74415: LD_INT 2
74417: PUSH
74418: LD_INT 2
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 1
74427: PUSH
74428: LD_INT 2
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PUSH
74435: LD_INT 0
74437: PUSH
74438: LD_INT 2
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PUSH
74445: LD_INT 1
74447: NEG
74448: PUSH
74449: LD_INT 1
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 2
74458: NEG
74459: PUSH
74460: LD_INT 1
74462: NEG
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: LD_INT 2
74470: NEG
74471: PUSH
74472: LD_INT 2
74474: NEG
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: LD_INT 2
74482: NEG
74483: PUSH
74484: LD_INT 3
74486: NEG
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 1
74494: NEG
74495: PUSH
74496: LD_INT 3
74498: NEG
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 0
74506: PUSH
74507: LD_INT 3
74509: NEG
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: PUSH
74515: LD_INT 1
74517: PUSH
74518: LD_INT 2
74520: NEG
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 3
74528: PUSH
74529: LD_INT 2
74531: PUSH
74532: EMPTY
74533: LIST
74534: LIST
74535: PUSH
74536: LD_INT 3
74538: PUSH
74539: LD_INT 3
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: LD_INT 2
74548: PUSH
74549: LD_INT 3
74551: PUSH
74552: EMPTY
74553: LIST
74554: LIST
74555: PUSH
74556: LD_INT 1
74558: PUSH
74559: LD_INT 3
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PUSH
74566: LD_INT 0
74568: PUSH
74569: LD_INT 3
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 1
74578: NEG
74579: PUSH
74580: LD_INT 2
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PUSH
74587: LD_INT 3
74589: NEG
74590: PUSH
74591: LD_INT 2
74593: NEG
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: PUSH
74599: LD_INT 3
74601: NEG
74602: PUSH
74603: LD_INT 3
74605: NEG
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: LIST
74615: LIST
74616: LIST
74617: LIST
74618: LIST
74619: LIST
74620: LIST
74621: LIST
74622: LIST
74623: LIST
74624: LIST
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: LIST
74637: LIST
74638: LIST
74639: LIST
74640: LIST
74641: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74642: LD_ADDR_VAR 0 46
74646: PUSH
74647: LD_INT 0
74649: PUSH
74650: LD_INT 0
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: LD_INT 0
74659: PUSH
74660: LD_INT 1
74662: NEG
74663: PUSH
74664: EMPTY
74665: LIST
74666: LIST
74667: PUSH
74668: LD_INT 1
74670: PUSH
74671: LD_INT 0
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: PUSH
74678: LD_INT 1
74680: PUSH
74681: LD_INT 1
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PUSH
74688: LD_INT 0
74690: PUSH
74691: LD_INT 1
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PUSH
74698: LD_INT 1
74700: NEG
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 1
74711: NEG
74712: PUSH
74713: LD_INT 1
74715: NEG
74716: PUSH
74717: EMPTY
74718: LIST
74719: LIST
74720: PUSH
74721: LD_INT 1
74723: NEG
74724: PUSH
74725: LD_INT 2
74727: NEG
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 0
74735: PUSH
74736: LD_INT 2
74738: NEG
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: PUSH
74744: LD_INT 1
74746: PUSH
74747: LD_INT 1
74749: NEG
74750: PUSH
74751: EMPTY
74752: LIST
74753: LIST
74754: PUSH
74755: LD_INT 2
74757: PUSH
74758: LD_INT 0
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: PUSH
74765: LD_INT 2
74767: PUSH
74768: LD_INT 1
74770: PUSH
74771: EMPTY
74772: LIST
74773: LIST
74774: PUSH
74775: LD_INT 1
74777: PUSH
74778: LD_INT 2
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: PUSH
74785: LD_INT 0
74787: PUSH
74788: LD_INT 2
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PUSH
74795: LD_INT 1
74797: NEG
74798: PUSH
74799: LD_INT 1
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 2
74808: NEG
74809: PUSH
74810: LD_INT 0
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 2
74819: NEG
74820: PUSH
74821: LD_INT 1
74823: NEG
74824: PUSH
74825: EMPTY
74826: LIST
74827: LIST
74828: PUSH
74829: LD_INT 1
74831: NEG
74832: PUSH
74833: LD_INT 3
74835: NEG
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 0
74843: PUSH
74844: LD_INT 3
74846: NEG
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: PUSH
74855: LD_INT 2
74857: NEG
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 2
74865: PUSH
74866: LD_INT 1
74868: NEG
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: LD_INT 3
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: PUSH
74884: LD_INT 3
74886: PUSH
74887: LD_INT 1
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: LD_INT 1
74896: PUSH
74897: LD_INT 3
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: PUSH
74904: LD_INT 0
74906: PUSH
74907: LD_INT 3
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 1
74916: NEG
74917: PUSH
74918: LD_INT 2
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: LD_INT 2
74927: NEG
74928: PUSH
74929: LD_INT 1
74931: PUSH
74932: EMPTY
74933: LIST
74934: LIST
74935: PUSH
74936: LD_INT 3
74938: NEG
74939: PUSH
74940: LD_INT 0
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PUSH
74947: LD_INT 3
74949: NEG
74950: PUSH
74951: LD_INT 1
74953: NEG
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: LIST
74969: LIST
74970: LIST
74971: LIST
74972: LIST
74973: LIST
74974: LIST
74975: LIST
74976: LIST
74977: LIST
74978: LIST
74979: LIST
74980: LIST
74981: LIST
74982: LIST
74983: LIST
74984: LIST
74985: LIST
74986: LIST
74987: LIST
74988: LIST
74989: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74990: LD_ADDR_VAR 0 47
74994: PUSH
74995: LD_INT 0
74997: PUSH
74998: LD_INT 0
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: LD_INT 0
75007: PUSH
75008: LD_INT 1
75010: NEG
75011: PUSH
75012: EMPTY
75013: LIST
75014: LIST
75015: PUSH
75016: LD_INT 1
75018: PUSH
75019: LD_INT 0
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 1
75028: PUSH
75029: LD_INT 1
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: LD_INT 0
75038: PUSH
75039: LD_INT 1
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PUSH
75046: LD_INT 1
75048: NEG
75049: PUSH
75050: LD_INT 0
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 1
75059: NEG
75060: PUSH
75061: LD_INT 1
75063: NEG
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 1
75071: NEG
75072: PUSH
75073: LD_INT 2
75075: NEG
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 0
75083: PUSH
75084: LD_INT 2
75086: NEG
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 1
75094: PUSH
75095: LD_INT 1
75097: NEG
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 2
75105: NEG
75106: PUSH
75107: LD_INT 1
75109: NEG
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 2
75117: NEG
75118: PUSH
75119: LD_INT 2
75121: NEG
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75141: LD_ADDR_VAR 0 48
75145: PUSH
75146: LD_INT 0
75148: PUSH
75149: LD_INT 0
75151: PUSH
75152: EMPTY
75153: LIST
75154: LIST
75155: PUSH
75156: LD_INT 0
75158: PUSH
75159: LD_INT 1
75161: NEG
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 1
75169: PUSH
75170: LD_INT 0
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: LD_INT 1
75179: PUSH
75180: LD_INT 1
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: LD_INT 1
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: PUSH
75197: LD_INT 1
75199: NEG
75200: PUSH
75201: LD_INT 0
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 1
75210: NEG
75211: PUSH
75212: LD_INT 1
75214: NEG
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 1
75222: NEG
75223: PUSH
75224: LD_INT 2
75226: NEG
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 0
75234: PUSH
75235: LD_INT 2
75237: NEG
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 1
75245: PUSH
75246: LD_INT 1
75248: NEG
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 2
75256: PUSH
75257: LD_INT 0
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 2
75266: PUSH
75267: LD_INT 1
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: LIST
75278: LIST
75279: LIST
75280: LIST
75281: LIST
75282: LIST
75283: LIST
75284: LIST
75285: LIST
75286: LIST
75287: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75288: LD_ADDR_VAR 0 49
75292: PUSH
75293: LD_INT 0
75295: PUSH
75296: LD_INT 0
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: PUSH
75303: LD_INT 0
75305: PUSH
75306: LD_INT 1
75308: NEG
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: LD_INT 1
75316: PUSH
75317: LD_INT 0
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 1
75326: PUSH
75327: LD_INT 1
75329: PUSH
75330: EMPTY
75331: LIST
75332: LIST
75333: PUSH
75334: LD_INT 0
75336: PUSH
75337: LD_INT 1
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 1
75346: NEG
75347: PUSH
75348: LD_INT 0
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 1
75357: NEG
75358: PUSH
75359: LD_INT 1
75361: NEG
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 1
75369: PUSH
75370: LD_INT 1
75372: NEG
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 2
75380: PUSH
75381: LD_INT 0
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 2
75390: PUSH
75391: LD_INT 1
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 2
75400: PUSH
75401: LD_INT 2
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 1
75410: PUSH
75411: LD_INT 2
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: LIST
75425: LIST
75426: LIST
75427: LIST
75428: LIST
75429: LIST
75430: LIST
75431: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75432: LD_ADDR_VAR 0 50
75436: PUSH
75437: LD_INT 0
75439: PUSH
75440: LD_INT 0
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PUSH
75447: LD_INT 0
75449: PUSH
75450: LD_INT 1
75452: NEG
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: LD_INT 1
75460: PUSH
75461: LD_INT 0
75463: PUSH
75464: EMPTY
75465: LIST
75466: LIST
75467: PUSH
75468: LD_INT 1
75470: PUSH
75471: LD_INT 1
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: LD_INT 0
75480: PUSH
75481: LD_INT 1
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 1
75490: NEG
75491: PUSH
75492: LD_INT 0
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 1
75501: NEG
75502: PUSH
75503: LD_INT 1
75505: NEG
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: LD_INT 2
75513: PUSH
75514: LD_INT 1
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 2
75523: PUSH
75524: LD_INT 2
75526: PUSH
75527: EMPTY
75528: LIST
75529: LIST
75530: PUSH
75531: LD_INT 1
75533: PUSH
75534: LD_INT 2
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 0
75543: PUSH
75544: LD_INT 2
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: LD_INT 1
75553: NEG
75554: PUSH
75555: LD_INT 1
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: LIST
75566: LIST
75567: LIST
75568: LIST
75569: LIST
75570: LIST
75571: LIST
75572: LIST
75573: LIST
75574: LIST
75575: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75576: LD_ADDR_VAR 0 51
75580: PUSH
75581: LD_INT 0
75583: PUSH
75584: LD_INT 0
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 0
75593: PUSH
75594: LD_INT 1
75596: NEG
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 1
75604: PUSH
75605: LD_INT 0
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 1
75614: PUSH
75615: LD_INT 1
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 0
75624: PUSH
75625: LD_INT 1
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 1
75634: NEG
75635: PUSH
75636: LD_INT 0
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 1
75645: NEG
75646: PUSH
75647: LD_INT 1
75649: NEG
75650: PUSH
75651: EMPTY
75652: LIST
75653: LIST
75654: PUSH
75655: LD_INT 1
75657: PUSH
75658: LD_INT 2
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 0
75667: PUSH
75668: LD_INT 2
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 1
75677: NEG
75678: PUSH
75679: LD_INT 1
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: PUSH
75686: LD_INT 2
75688: NEG
75689: PUSH
75690: LD_INT 0
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 2
75699: NEG
75700: PUSH
75701: LD_INT 1
75703: NEG
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: LIST
75713: LIST
75714: LIST
75715: LIST
75716: LIST
75717: LIST
75718: LIST
75719: LIST
75720: LIST
75721: LIST
75722: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75723: LD_ADDR_VAR 0 52
75727: PUSH
75728: LD_INT 0
75730: PUSH
75731: LD_INT 0
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 0
75740: PUSH
75741: LD_INT 1
75743: NEG
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 1
75751: PUSH
75752: LD_INT 0
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: LD_INT 1
75761: PUSH
75762: LD_INT 1
75764: PUSH
75765: EMPTY
75766: LIST
75767: LIST
75768: PUSH
75769: LD_INT 0
75771: PUSH
75772: LD_INT 1
75774: PUSH
75775: EMPTY
75776: LIST
75777: LIST
75778: PUSH
75779: LD_INT 1
75781: NEG
75782: PUSH
75783: LD_INT 0
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 1
75792: NEG
75793: PUSH
75794: LD_INT 1
75796: NEG
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: PUSH
75802: LD_INT 1
75804: NEG
75805: PUSH
75806: LD_INT 2
75808: NEG
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: PUSH
75814: LD_INT 1
75816: NEG
75817: PUSH
75818: LD_INT 1
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 2
75827: NEG
75828: PUSH
75829: LD_INT 0
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 2
75838: NEG
75839: PUSH
75840: LD_INT 1
75842: NEG
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: LD_INT 2
75850: NEG
75851: PUSH
75852: LD_INT 2
75854: NEG
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: LIST
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: LIST
75870: LIST
75871: LIST
75872: LIST
75873: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75874: LD_ADDR_VAR 0 53
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: LD_INT 0
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: LD_INT 0
75891: PUSH
75892: LD_INT 1
75894: NEG
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 1
75902: PUSH
75903: LD_INT 0
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 1
75912: PUSH
75913: LD_INT 1
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: LD_INT 0
75922: PUSH
75923: LD_INT 1
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PUSH
75930: LD_INT 1
75932: NEG
75933: PUSH
75934: LD_INT 0
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: PUSH
75941: LD_INT 1
75943: NEG
75944: PUSH
75945: LD_INT 1
75947: NEG
75948: PUSH
75949: EMPTY
75950: LIST
75951: LIST
75952: PUSH
75953: LD_INT 1
75955: NEG
75956: PUSH
75957: LD_INT 2
75959: NEG
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 0
75967: PUSH
75968: LD_INT 2
75970: NEG
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 1
75978: PUSH
75979: LD_INT 1
75981: NEG
75982: PUSH
75983: EMPTY
75984: LIST
75985: LIST
75986: PUSH
75987: LD_INT 2
75989: PUSH
75990: LD_INT 0
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 2
75999: PUSH
76000: LD_INT 1
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 2
76009: PUSH
76010: LD_INT 2
76012: PUSH
76013: EMPTY
76014: LIST
76015: LIST
76016: PUSH
76017: LD_INT 1
76019: PUSH
76020: LD_INT 2
76022: PUSH
76023: EMPTY
76024: LIST
76025: LIST
76026: PUSH
76027: LD_INT 0
76029: PUSH
76030: LD_INT 2
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 1
76039: NEG
76040: PUSH
76041: LD_INT 1
76043: PUSH
76044: EMPTY
76045: LIST
76046: LIST
76047: PUSH
76048: LD_INT 2
76050: NEG
76051: PUSH
76052: LD_INT 0
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PUSH
76059: LD_INT 2
76061: NEG
76062: PUSH
76063: LD_INT 1
76065: NEG
76066: PUSH
76067: EMPTY
76068: LIST
76069: LIST
76070: PUSH
76071: LD_INT 2
76073: NEG
76074: PUSH
76075: LD_INT 2
76077: NEG
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: LIST
76100: LIST
76101: LIST
76102: LIST
76103: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76104: LD_ADDR_VAR 0 54
76108: PUSH
76109: LD_INT 0
76111: PUSH
76112: LD_INT 0
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: PUSH
76119: LD_INT 0
76121: PUSH
76122: LD_INT 1
76124: NEG
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 1
76132: PUSH
76133: LD_INT 0
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PUSH
76140: LD_INT 1
76142: PUSH
76143: LD_INT 1
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: PUSH
76150: LD_INT 0
76152: PUSH
76153: LD_INT 1
76155: PUSH
76156: EMPTY
76157: LIST
76158: LIST
76159: PUSH
76160: LD_INT 1
76162: NEG
76163: PUSH
76164: LD_INT 0
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PUSH
76171: LD_INT 1
76173: NEG
76174: PUSH
76175: LD_INT 1
76177: NEG
76178: PUSH
76179: EMPTY
76180: LIST
76181: LIST
76182: PUSH
76183: LD_INT 1
76185: NEG
76186: PUSH
76187: LD_INT 2
76189: NEG
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 0
76197: PUSH
76198: LD_INT 2
76200: NEG
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: LD_INT 1
76208: PUSH
76209: LD_INT 1
76211: NEG
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 2
76219: PUSH
76220: LD_INT 0
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 2
76229: PUSH
76230: LD_INT 1
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 2
76239: PUSH
76240: LD_INT 2
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 1
76249: PUSH
76250: LD_INT 2
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 0
76259: PUSH
76260: LD_INT 2
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 1
76269: NEG
76270: PUSH
76271: LD_INT 1
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: LD_INT 2
76280: NEG
76281: PUSH
76282: LD_INT 0
76284: PUSH
76285: EMPTY
76286: LIST
76287: LIST
76288: PUSH
76289: LD_INT 2
76291: NEG
76292: PUSH
76293: LD_INT 1
76295: NEG
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: PUSH
76301: LD_INT 2
76303: NEG
76304: PUSH
76305: LD_INT 2
76307: NEG
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: LIST
76317: LIST
76318: LIST
76319: LIST
76320: LIST
76321: LIST
76322: LIST
76323: LIST
76324: LIST
76325: LIST
76326: LIST
76327: LIST
76328: LIST
76329: LIST
76330: LIST
76331: LIST
76332: LIST
76333: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76334: LD_ADDR_VAR 0 55
76338: PUSH
76339: LD_INT 0
76341: PUSH
76342: LD_INT 0
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 0
76351: PUSH
76352: LD_INT 1
76354: NEG
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: PUSH
76360: LD_INT 1
76362: PUSH
76363: LD_INT 0
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: PUSH
76370: LD_INT 1
76372: PUSH
76373: LD_INT 1
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: LD_INT 0
76382: PUSH
76383: LD_INT 1
76385: PUSH
76386: EMPTY
76387: LIST
76388: LIST
76389: PUSH
76390: LD_INT 1
76392: NEG
76393: PUSH
76394: LD_INT 0
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 1
76403: NEG
76404: PUSH
76405: LD_INT 1
76407: NEG
76408: PUSH
76409: EMPTY
76410: LIST
76411: LIST
76412: PUSH
76413: LD_INT 1
76415: NEG
76416: PUSH
76417: LD_INT 2
76419: NEG
76420: PUSH
76421: EMPTY
76422: LIST
76423: LIST
76424: PUSH
76425: LD_INT 0
76427: PUSH
76428: LD_INT 2
76430: NEG
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: PUSH
76436: LD_INT 1
76438: PUSH
76439: LD_INT 1
76441: NEG
76442: PUSH
76443: EMPTY
76444: LIST
76445: LIST
76446: PUSH
76447: LD_INT 2
76449: PUSH
76450: LD_INT 0
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: LD_INT 2
76459: PUSH
76460: LD_INT 1
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: PUSH
76467: LD_INT 2
76469: PUSH
76470: LD_INT 2
76472: PUSH
76473: EMPTY
76474: LIST
76475: LIST
76476: PUSH
76477: LD_INT 1
76479: PUSH
76480: LD_INT 2
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 0
76489: PUSH
76490: LD_INT 2
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 1
76499: NEG
76500: PUSH
76501: LD_INT 1
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 2
76510: NEG
76511: PUSH
76512: LD_INT 0
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: LD_INT 2
76521: NEG
76522: PUSH
76523: LD_INT 1
76525: NEG
76526: PUSH
76527: EMPTY
76528: LIST
76529: LIST
76530: PUSH
76531: LD_INT 2
76533: NEG
76534: PUSH
76535: LD_INT 2
76537: NEG
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: LIST
76560: LIST
76561: LIST
76562: LIST
76563: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76564: LD_ADDR_VAR 0 56
76568: PUSH
76569: LD_INT 0
76571: PUSH
76572: LD_INT 0
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 0
76581: PUSH
76582: LD_INT 1
76584: NEG
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 1
76592: PUSH
76593: LD_INT 0
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 1
76602: PUSH
76603: LD_INT 1
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 0
76612: PUSH
76613: LD_INT 1
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 1
76622: NEG
76623: PUSH
76624: LD_INT 0
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 1
76633: NEG
76634: PUSH
76635: LD_INT 1
76637: NEG
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: PUSH
76643: LD_INT 1
76645: NEG
76646: PUSH
76647: LD_INT 2
76649: NEG
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 0
76657: PUSH
76658: LD_INT 2
76660: NEG
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 1
76668: PUSH
76669: LD_INT 1
76671: NEG
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 2
76679: PUSH
76680: LD_INT 0
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 2
76689: PUSH
76690: LD_INT 1
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 2
76699: PUSH
76700: LD_INT 2
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 1
76709: PUSH
76710: LD_INT 2
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 0
76719: PUSH
76720: LD_INT 2
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 1
76729: NEG
76730: PUSH
76731: LD_INT 1
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: LD_INT 2
76740: NEG
76741: PUSH
76742: LD_INT 0
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 2
76751: NEG
76752: PUSH
76753: LD_INT 1
76755: NEG
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: LD_INT 2
76763: NEG
76764: PUSH
76765: LD_INT 2
76767: NEG
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: EMPTY
76774: LIST
76775: LIST
76776: LIST
76777: LIST
76778: LIST
76779: LIST
76780: LIST
76781: LIST
76782: LIST
76783: LIST
76784: LIST
76785: LIST
76786: LIST
76787: LIST
76788: LIST
76789: LIST
76790: LIST
76791: LIST
76792: LIST
76793: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76794: LD_ADDR_VAR 0 57
76798: PUSH
76799: LD_INT 0
76801: PUSH
76802: LD_INT 0
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 0
76811: PUSH
76812: LD_INT 1
76814: NEG
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: LD_INT 0
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: PUSH
76830: LD_INT 1
76832: PUSH
76833: LD_INT 1
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 0
76842: PUSH
76843: LD_INT 1
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: LD_INT 1
76852: NEG
76853: PUSH
76854: LD_INT 0
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: LD_INT 1
76863: NEG
76864: PUSH
76865: LD_INT 1
76867: NEG
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 1
76875: NEG
76876: PUSH
76877: LD_INT 2
76879: NEG
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: LD_INT 0
76887: PUSH
76888: LD_INT 2
76890: NEG
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 1
76898: PUSH
76899: LD_INT 1
76901: NEG
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 2
76909: PUSH
76910: LD_INT 0
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 2
76919: PUSH
76920: LD_INT 1
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 2
76929: PUSH
76930: LD_INT 2
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 1
76939: PUSH
76940: LD_INT 2
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: PUSH
76947: LD_INT 0
76949: PUSH
76950: LD_INT 2
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 1
76959: NEG
76960: PUSH
76961: LD_INT 1
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 2
76970: NEG
76971: PUSH
76972: LD_INT 0
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 2
76981: NEG
76982: PUSH
76983: LD_INT 1
76985: NEG
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: PUSH
76991: LD_INT 2
76993: NEG
76994: PUSH
76995: LD_INT 2
76997: NEG
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: LIST
77007: LIST
77008: LIST
77009: LIST
77010: LIST
77011: LIST
77012: LIST
77013: LIST
77014: LIST
77015: LIST
77016: LIST
77017: LIST
77018: LIST
77019: LIST
77020: LIST
77021: LIST
77022: LIST
77023: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77024: LD_ADDR_VAR 0 58
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: LD_INT 0
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 0
77041: PUSH
77042: LD_INT 1
77044: NEG
77045: PUSH
77046: EMPTY
77047: LIST
77048: LIST
77049: PUSH
77050: LD_INT 1
77052: PUSH
77053: LD_INT 0
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PUSH
77060: LD_INT 1
77062: PUSH
77063: LD_INT 1
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: PUSH
77070: LD_INT 0
77072: PUSH
77073: LD_INT 1
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: PUSH
77080: LD_INT 1
77082: NEG
77083: PUSH
77084: LD_INT 0
77086: PUSH
77087: EMPTY
77088: LIST
77089: LIST
77090: PUSH
77091: LD_INT 1
77093: NEG
77094: PUSH
77095: LD_INT 1
77097: NEG
77098: PUSH
77099: EMPTY
77100: LIST
77101: LIST
77102: PUSH
77103: LD_INT 1
77105: NEG
77106: PUSH
77107: LD_INT 2
77109: NEG
77110: PUSH
77111: EMPTY
77112: LIST
77113: LIST
77114: PUSH
77115: LD_INT 0
77117: PUSH
77118: LD_INT 2
77120: NEG
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: LD_INT 1
77128: PUSH
77129: LD_INT 1
77131: NEG
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 2
77139: PUSH
77140: LD_INT 0
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: LD_INT 2
77149: PUSH
77150: LD_INT 1
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: LD_INT 2
77159: PUSH
77160: LD_INT 2
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: PUSH
77167: LD_INT 1
77169: PUSH
77170: LD_INT 2
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: PUSH
77177: LD_INT 0
77179: PUSH
77180: LD_INT 2
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 1
77189: NEG
77190: PUSH
77191: LD_INT 1
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 2
77200: NEG
77201: PUSH
77202: LD_INT 0
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 2
77211: NEG
77212: PUSH
77213: LD_INT 1
77215: NEG
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 2
77223: NEG
77224: PUSH
77225: LD_INT 2
77227: NEG
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: LIST
77237: LIST
77238: LIST
77239: LIST
77240: LIST
77241: LIST
77242: LIST
77243: LIST
77244: LIST
77245: LIST
77246: LIST
77247: LIST
77248: LIST
77249: LIST
77250: LIST
77251: LIST
77252: LIST
77253: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77254: LD_ADDR_VAR 0 59
77258: PUSH
77259: LD_INT 0
77261: PUSH
77262: LD_INT 0
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 0
77271: PUSH
77272: LD_INT 1
77274: NEG
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: PUSH
77280: LD_INT 1
77282: PUSH
77283: LD_INT 0
77285: PUSH
77286: EMPTY
77287: LIST
77288: LIST
77289: PUSH
77290: LD_INT 1
77292: PUSH
77293: LD_INT 1
77295: PUSH
77296: EMPTY
77297: LIST
77298: LIST
77299: PUSH
77300: LD_INT 0
77302: PUSH
77303: LD_INT 1
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: PUSH
77310: LD_INT 1
77312: NEG
77313: PUSH
77314: LD_INT 0
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: PUSH
77321: LD_INT 1
77323: NEG
77324: PUSH
77325: LD_INT 1
77327: NEG
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: LIST
77337: LIST
77338: LIST
77339: LIST
77340: LIST
77341: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77342: LD_ADDR_VAR 0 60
77346: PUSH
77347: LD_INT 0
77349: PUSH
77350: LD_INT 0
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: LD_INT 0
77359: PUSH
77360: LD_INT 1
77362: NEG
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: LD_INT 1
77370: PUSH
77371: LD_INT 0
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 1
77380: PUSH
77381: LD_INT 1
77383: PUSH
77384: EMPTY
77385: LIST
77386: LIST
77387: PUSH
77388: LD_INT 0
77390: PUSH
77391: LD_INT 1
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: LD_INT 1
77400: NEG
77401: PUSH
77402: LD_INT 0
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: LD_INT 1
77415: NEG
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: LIST
77425: LIST
77426: LIST
77427: LIST
77428: LIST
77429: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77430: LD_ADDR_VAR 0 61
77434: PUSH
77435: LD_INT 0
77437: PUSH
77438: LD_INT 0
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: LD_INT 0
77447: PUSH
77448: LD_INT 1
77450: NEG
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PUSH
77456: LD_INT 1
77458: PUSH
77459: LD_INT 0
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: PUSH
77466: LD_INT 1
77468: PUSH
77469: LD_INT 1
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 0
77478: PUSH
77479: LD_INT 1
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 1
77488: NEG
77489: PUSH
77490: LD_INT 0
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: PUSH
77497: LD_INT 1
77499: NEG
77500: PUSH
77501: LD_INT 1
77503: NEG
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: LIST
77513: LIST
77514: LIST
77515: LIST
77516: LIST
77517: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77518: LD_ADDR_VAR 0 62
77522: PUSH
77523: LD_INT 0
77525: PUSH
77526: LD_INT 0
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: LD_INT 0
77535: PUSH
77536: LD_INT 1
77538: NEG
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 1
77546: PUSH
77547: LD_INT 0
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PUSH
77554: LD_INT 1
77556: PUSH
77557: LD_INT 1
77559: PUSH
77560: EMPTY
77561: LIST
77562: LIST
77563: PUSH
77564: LD_INT 0
77566: PUSH
77567: LD_INT 1
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: LD_INT 1
77576: NEG
77577: PUSH
77578: LD_INT 0
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 1
77587: NEG
77588: PUSH
77589: LD_INT 1
77591: NEG
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: PUSH
77597: EMPTY
77598: LIST
77599: LIST
77600: LIST
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77606: LD_ADDR_VAR 0 63
77610: PUSH
77611: LD_INT 0
77613: PUSH
77614: LD_INT 0
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 0
77623: PUSH
77624: LD_INT 1
77626: NEG
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: PUSH
77632: LD_INT 1
77634: PUSH
77635: LD_INT 0
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: PUSH
77642: LD_INT 1
77644: PUSH
77645: LD_INT 1
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: LD_INT 0
77654: PUSH
77655: LD_INT 1
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 1
77664: NEG
77665: PUSH
77666: LD_INT 0
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 1
77675: NEG
77676: PUSH
77677: LD_INT 1
77679: NEG
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: EMPTY
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77694: LD_ADDR_VAR 0 64
77698: PUSH
77699: LD_INT 0
77701: PUSH
77702: LD_INT 0
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 0
77711: PUSH
77712: LD_INT 1
77714: NEG
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: PUSH
77720: LD_INT 1
77722: PUSH
77723: LD_INT 0
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: PUSH
77730: LD_INT 1
77732: PUSH
77733: LD_INT 1
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: PUSH
77740: LD_INT 0
77742: PUSH
77743: LD_INT 1
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 1
77752: NEG
77753: PUSH
77754: LD_INT 0
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 1
77763: NEG
77764: PUSH
77765: LD_INT 1
77767: NEG
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: ST_TO_ADDR
// end ; 1 :
77782: GO 83679
77784: LD_INT 1
77786: DOUBLE
77787: EQUAL
77788: IFTRUE 77792
77790: GO 80415
77792: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77793: LD_ADDR_VAR 0 11
77797: PUSH
77798: LD_INT 1
77800: NEG
77801: PUSH
77802: LD_INT 3
77804: NEG
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: LD_INT 0
77812: PUSH
77813: LD_INT 3
77815: NEG
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: LD_INT 1
77823: PUSH
77824: LD_INT 2
77826: NEG
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: LIST
77836: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77837: LD_ADDR_VAR 0 12
77841: PUSH
77842: LD_INT 2
77844: PUSH
77845: LD_INT 1
77847: NEG
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 3
77855: PUSH
77856: LD_INT 0
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 3
77865: PUSH
77866: LD_INT 1
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: EMPTY
77874: LIST
77875: LIST
77876: LIST
77877: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77878: LD_ADDR_VAR 0 13
77882: PUSH
77883: LD_INT 3
77885: PUSH
77886: LD_INT 2
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 3
77895: PUSH
77896: LD_INT 3
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: PUSH
77903: LD_INT 2
77905: PUSH
77906: LD_INT 3
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: LIST
77917: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77918: LD_ADDR_VAR 0 14
77922: PUSH
77923: LD_INT 1
77925: PUSH
77926: LD_INT 3
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: LD_INT 0
77935: PUSH
77936: LD_INT 3
77938: PUSH
77939: EMPTY
77940: LIST
77941: LIST
77942: PUSH
77943: LD_INT 1
77945: NEG
77946: PUSH
77947: LD_INT 2
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: LIST
77958: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77959: LD_ADDR_VAR 0 15
77963: PUSH
77964: LD_INT 2
77966: NEG
77967: PUSH
77968: LD_INT 1
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 3
77977: NEG
77978: PUSH
77979: LD_INT 0
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: LD_INT 3
77988: NEG
77989: PUSH
77990: LD_INT 1
77992: NEG
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: EMPTY
77999: LIST
78000: LIST
78001: LIST
78002: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78003: LD_ADDR_VAR 0 16
78007: PUSH
78008: LD_INT 2
78010: NEG
78011: PUSH
78012: LD_INT 3
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 3
78022: NEG
78023: PUSH
78024: LD_INT 2
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 3
78034: NEG
78035: PUSH
78036: LD_INT 3
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: LIST
78048: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78049: LD_ADDR_VAR 0 17
78053: PUSH
78054: LD_INT 1
78056: NEG
78057: PUSH
78058: LD_INT 3
78060: NEG
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: LD_INT 0
78068: PUSH
78069: LD_INT 3
78071: NEG
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: LD_INT 1
78079: PUSH
78080: LD_INT 2
78082: NEG
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: LIST
78092: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78093: LD_ADDR_VAR 0 18
78097: PUSH
78098: LD_INT 2
78100: PUSH
78101: LD_INT 1
78103: NEG
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 3
78111: PUSH
78112: LD_INT 0
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: PUSH
78119: LD_INT 3
78121: PUSH
78122: LD_INT 1
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: LIST
78133: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78134: LD_ADDR_VAR 0 19
78138: PUSH
78139: LD_INT 3
78141: PUSH
78142: LD_INT 2
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 3
78151: PUSH
78152: LD_INT 3
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 2
78161: PUSH
78162: LD_INT 3
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: LIST
78173: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78174: LD_ADDR_VAR 0 20
78178: PUSH
78179: LD_INT 1
78181: PUSH
78182: LD_INT 3
78184: PUSH
78185: EMPTY
78186: LIST
78187: LIST
78188: PUSH
78189: LD_INT 0
78191: PUSH
78192: LD_INT 3
78194: PUSH
78195: EMPTY
78196: LIST
78197: LIST
78198: PUSH
78199: LD_INT 1
78201: NEG
78202: PUSH
78203: LD_INT 2
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: LIST
78214: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78215: LD_ADDR_VAR 0 21
78219: PUSH
78220: LD_INT 2
78222: NEG
78223: PUSH
78224: LD_INT 1
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: PUSH
78231: LD_INT 3
78233: NEG
78234: PUSH
78235: LD_INT 0
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: LD_INT 3
78244: NEG
78245: PUSH
78246: LD_INT 1
78248: NEG
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: LIST
78258: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78259: LD_ADDR_VAR 0 22
78263: PUSH
78264: LD_INT 2
78266: NEG
78267: PUSH
78268: LD_INT 3
78270: NEG
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 3
78278: NEG
78279: PUSH
78280: LD_INT 2
78282: NEG
78283: PUSH
78284: EMPTY
78285: LIST
78286: LIST
78287: PUSH
78288: LD_INT 3
78290: NEG
78291: PUSH
78292: LD_INT 3
78294: NEG
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: EMPTY
78301: LIST
78302: LIST
78303: LIST
78304: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78305: LD_ADDR_VAR 0 23
78309: PUSH
78310: LD_INT 0
78312: PUSH
78313: LD_INT 3
78315: NEG
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 1
78323: NEG
78324: PUSH
78325: LD_INT 4
78327: NEG
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PUSH
78333: LD_INT 1
78335: PUSH
78336: LD_INT 3
78338: NEG
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: LIST
78348: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78349: LD_ADDR_VAR 0 24
78353: PUSH
78354: LD_INT 3
78356: PUSH
78357: LD_INT 0
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: LD_INT 3
78366: PUSH
78367: LD_INT 1
78369: NEG
78370: PUSH
78371: EMPTY
78372: LIST
78373: LIST
78374: PUSH
78375: LD_INT 4
78377: PUSH
78378: LD_INT 1
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: LIST
78389: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78390: LD_ADDR_VAR 0 25
78394: PUSH
78395: LD_INT 3
78397: PUSH
78398: LD_INT 3
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: LD_INT 4
78407: PUSH
78408: LD_INT 3
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 3
78417: PUSH
78418: LD_INT 4
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: LIST
78429: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78430: LD_ADDR_VAR 0 26
78434: PUSH
78435: LD_INT 0
78437: PUSH
78438: LD_INT 3
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 1
78447: PUSH
78448: LD_INT 4
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 1
78457: NEG
78458: PUSH
78459: LD_INT 3
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: LIST
78470: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78471: LD_ADDR_VAR 0 27
78475: PUSH
78476: LD_INT 3
78478: NEG
78479: PUSH
78480: LD_INT 0
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 3
78489: NEG
78490: PUSH
78491: LD_INT 1
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 4
78500: NEG
78501: PUSH
78502: LD_INT 1
78504: NEG
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: EMPTY
78511: LIST
78512: LIST
78513: LIST
78514: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78515: LD_ADDR_VAR 0 28
78519: PUSH
78520: LD_INT 3
78522: NEG
78523: PUSH
78524: LD_INT 3
78526: NEG
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PUSH
78532: LD_INT 3
78534: NEG
78535: PUSH
78536: LD_INT 4
78538: NEG
78539: PUSH
78540: EMPTY
78541: LIST
78542: LIST
78543: PUSH
78544: LD_INT 4
78546: NEG
78547: PUSH
78548: LD_INT 3
78550: NEG
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: LIST
78560: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78561: LD_ADDR_VAR 0 29
78565: PUSH
78566: LD_INT 1
78568: NEG
78569: PUSH
78570: LD_INT 3
78572: NEG
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 0
78580: PUSH
78581: LD_INT 3
78583: NEG
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 1
78591: PUSH
78592: LD_INT 2
78594: NEG
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 1
78602: NEG
78603: PUSH
78604: LD_INT 4
78606: NEG
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 0
78614: PUSH
78615: LD_INT 4
78617: NEG
78618: PUSH
78619: EMPTY
78620: LIST
78621: LIST
78622: PUSH
78623: LD_INT 1
78625: PUSH
78626: LD_INT 3
78628: NEG
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 1
78636: NEG
78637: PUSH
78638: LD_INT 5
78640: NEG
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 0
78648: PUSH
78649: LD_INT 5
78651: NEG
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 1
78659: PUSH
78660: LD_INT 4
78662: NEG
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: PUSH
78668: LD_INT 1
78670: NEG
78671: PUSH
78672: LD_INT 6
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 0
78682: PUSH
78683: LD_INT 6
78685: NEG
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: LD_INT 1
78693: PUSH
78694: LD_INT 5
78696: NEG
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: EMPTY
78703: LIST
78704: LIST
78705: LIST
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: LIST
78711: LIST
78712: LIST
78713: LIST
78714: LIST
78715: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78716: LD_ADDR_VAR 0 30
78720: PUSH
78721: LD_INT 2
78723: PUSH
78724: LD_INT 1
78726: NEG
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 3
78734: PUSH
78735: LD_INT 0
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 3
78744: PUSH
78745: LD_INT 1
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 3
78754: PUSH
78755: LD_INT 1
78757: NEG
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 4
78765: PUSH
78766: LD_INT 0
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 4
78775: PUSH
78776: LD_INT 1
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 4
78785: PUSH
78786: LD_INT 1
78788: NEG
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 5
78796: PUSH
78797: LD_INT 0
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 5
78806: PUSH
78807: LD_INT 1
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: LD_INT 5
78816: PUSH
78817: LD_INT 1
78819: NEG
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 6
78827: PUSH
78828: LD_INT 0
78830: PUSH
78831: EMPTY
78832: LIST
78833: LIST
78834: PUSH
78835: LD_INT 6
78837: PUSH
78838: LD_INT 1
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: LIST
78858: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78859: LD_ADDR_VAR 0 31
78863: PUSH
78864: LD_INT 3
78866: PUSH
78867: LD_INT 2
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 3
78876: PUSH
78877: LD_INT 3
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: PUSH
78884: LD_INT 2
78886: PUSH
78887: LD_INT 3
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PUSH
78894: LD_INT 4
78896: PUSH
78897: LD_INT 3
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 4
78906: PUSH
78907: LD_INT 4
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 3
78916: PUSH
78917: LD_INT 4
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 5
78926: PUSH
78927: LD_INT 4
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 5
78936: PUSH
78937: LD_INT 5
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PUSH
78944: LD_INT 4
78946: PUSH
78947: LD_INT 5
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 6
78956: PUSH
78957: LD_INT 5
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 6
78966: PUSH
78967: LD_INT 6
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 5
78976: PUSH
78977: LD_INT 6
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78998: LD_ADDR_VAR 0 32
79002: PUSH
79003: LD_INT 1
79005: PUSH
79006: LD_INT 3
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 0
79015: PUSH
79016: LD_INT 3
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 1
79025: NEG
79026: PUSH
79027: LD_INT 2
79029: PUSH
79030: EMPTY
79031: LIST
79032: LIST
79033: PUSH
79034: LD_INT 1
79036: PUSH
79037: LD_INT 4
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 0
79046: PUSH
79047: LD_INT 4
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 1
79056: NEG
79057: PUSH
79058: LD_INT 3
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 1
79067: PUSH
79068: LD_INT 5
79070: PUSH
79071: EMPTY
79072: LIST
79073: LIST
79074: PUSH
79075: LD_INT 0
79077: PUSH
79078: LD_INT 5
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 1
79087: NEG
79088: PUSH
79089: LD_INT 4
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 1
79098: PUSH
79099: LD_INT 6
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 0
79108: PUSH
79109: LD_INT 6
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 1
79118: NEG
79119: PUSH
79120: LD_INT 5
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79141: LD_ADDR_VAR 0 33
79145: PUSH
79146: LD_INT 2
79148: NEG
79149: PUSH
79150: LD_INT 1
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 3
79159: NEG
79160: PUSH
79161: LD_INT 0
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: PUSH
79168: LD_INT 3
79170: NEG
79171: PUSH
79172: LD_INT 1
79174: NEG
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 3
79182: NEG
79183: PUSH
79184: LD_INT 1
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: LD_INT 4
79193: NEG
79194: PUSH
79195: LD_INT 0
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 4
79204: NEG
79205: PUSH
79206: LD_INT 1
79208: NEG
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 4
79216: NEG
79217: PUSH
79218: LD_INT 1
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 5
79227: NEG
79228: PUSH
79229: LD_INT 0
79231: PUSH
79232: EMPTY
79233: LIST
79234: LIST
79235: PUSH
79236: LD_INT 5
79238: NEG
79239: PUSH
79240: LD_INT 1
79242: NEG
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 5
79250: NEG
79251: PUSH
79252: LD_INT 1
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 6
79261: NEG
79262: PUSH
79263: LD_INT 0
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 6
79272: NEG
79273: PUSH
79274: LD_INT 1
79276: NEG
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: LIST
79295: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79296: LD_ADDR_VAR 0 34
79300: PUSH
79301: LD_INT 2
79303: NEG
79304: PUSH
79305: LD_INT 3
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 3
79315: NEG
79316: PUSH
79317: LD_INT 2
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 3
79327: NEG
79328: PUSH
79329: LD_INT 3
79331: NEG
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 3
79339: NEG
79340: PUSH
79341: LD_INT 4
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 4
79351: NEG
79352: PUSH
79353: LD_INT 3
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 4
79363: NEG
79364: PUSH
79365: LD_INT 4
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 4
79375: NEG
79376: PUSH
79377: LD_INT 5
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 5
79387: NEG
79388: PUSH
79389: LD_INT 4
79391: NEG
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 5
79399: NEG
79400: PUSH
79401: LD_INT 5
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 5
79411: NEG
79412: PUSH
79413: LD_INT 6
79415: NEG
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: LD_INT 6
79423: NEG
79424: PUSH
79425: LD_INT 5
79427: NEG
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PUSH
79433: LD_INT 6
79435: NEG
79436: PUSH
79437: LD_INT 6
79439: NEG
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79459: LD_ADDR_VAR 0 41
79463: PUSH
79464: LD_INT 0
79466: PUSH
79467: LD_INT 2
79469: NEG
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: LD_INT 1
79477: NEG
79478: PUSH
79479: LD_INT 3
79481: NEG
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: PUSH
79487: LD_INT 1
79489: PUSH
79490: LD_INT 2
79492: NEG
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: LIST
79502: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79503: LD_ADDR_VAR 0 42
79507: PUSH
79508: LD_INT 2
79510: PUSH
79511: LD_INT 0
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 2
79520: PUSH
79521: LD_INT 1
79523: NEG
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 3
79531: PUSH
79532: LD_INT 1
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: LIST
79543: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79544: LD_ADDR_VAR 0 43
79548: PUSH
79549: LD_INT 2
79551: PUSH
79552: LD_INT 2
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 3
79561: PUSH
79562: LD_INT 2
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 2
79571: PUSH
79572: LD_INT 3
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: LIST
79583: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79584: LD_ADDR_VAR 0 44
79588: PUSH
79589: LD_INT 0
79591: PUSH
79592: LD_INT 2
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: LD_INT 3
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 1
79611: NEG
79612: PUSH
79613: LD_INT 2
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: LIST
79624: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79625: LD_ADDR_VAR 0 45
79629: PUSH
79630: LD_INT 2
79632: NEG
79633: PUSH
79634: LD_INT 0
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 2
79643: NEG
79644: PUSH
79645: LD_INT 1
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 3
79654: NEG
79655: PUSH
79656: LD_INT 1
79658: NEG
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: LIST
79668: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79669: LD_ADDR_VAR 0 46
79673: PUSH
79674: LD_INT 2
79676: NEG
79677: PUSH
79678: LD_INT 2
79680: NEG
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 2
79688: NEG
79689: PUSH
79690: LD_INT 3
79692: NEG
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 3
79700: NEG
79701: PUSH
79702: LD_INT 2
79704: NEG
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: LIST
79714: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79715: LD_ADDR_VAR 0 47
79719: PUSH
79720: LD_INT 2
79722: NEG
79723: PUSH
79724: LD_INT 3
79726: NEG
79727: PUSH
79728: EMPTY
79729: LIST
79730: LIST
79731: PUSH
79732: LD_INT 1
79734: NEG
79735: PUSH
79736: LD_INT 3
79738: NEG
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79748: LD_ADDR_VAR 0 48
79752: PUSH
79753: LD_INT 1
79755: PUSH
79756: LD_INT 2
79758: NEG
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: LD_INT 2
79766: PUSH
79767: LD_INT 1
79769: NEG
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79779: LD_ADDR_VAR 0 49
79783: PUSH
79784: LD_INT 3
79786: PUSH
79787: LD_INT 1
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 3
79796: PUSH
79797: LD_INT 2
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79808: LD_ADDR_VAR 0 50
79812: PUSH
79813: LD_INT 2
79815: PUSH
79816: LD_INT 3
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 1
79825: PUSH
79826: LD_INT 3
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79837: LD_ADDR_VAR 0 51
79841: PUSH
79842: LD_INT 1
79844: NEG
79845: PUSH
79846: LD_INT 2
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 2
79855: NEG
79856: PUSH
79857: LD_INT 1
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79868: LD_ADDR_VAR 0 52
79872: PUSH
79873: LD_INT 3
79875: NEG
79876: PUSH
79877: LD_INT 1
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 3
79887: NEG
79888: PUSH
79889: LD_INT 2
79891: NEG
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79901: LD_ADDR_VAR 0 53
79905: PUSH
79906: LD_INT 1
79908: NEG
79909: PUSH
79910: LD_INT 3
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 0
79920: PUSH
79921: LD_INT 3
79923: NEG
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 1
79931: PUSH
79932: LD_INT 2
79934: NEG
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: LIST
79944: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79945: LD_ADDR_VAR 0 54
79949: PUSH
79950: LD_INT 2
79952: PUSH
79953: LD_INT 1
79955: NEG
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 3
79963: PUSH
79964: LD_INT 0
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PUSH
79971: LD_INT 3
79973: PUSH
79974: LD_INT 1
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: LIST
79985: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79986: LD_ADDR_VAR 0 55
79990: PUSH
79991: LD_INT 3
79993: PUSH
79994: LD_INT 2
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 3
80003: PUSH
80004: LD_INT 3
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: PUSH
80011: LD_INT 2
80013: PUSH
80014: LD_INT 3
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: LIST
80025: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80026: LD_ADDR_VAR 0 56
80030: PUSH
80031: LD_INT 1
80033: PUSH
80034: LD_INT 3
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 0
80043: PUSH
80044: LD_INT 3
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: LD_INT 1
80053: NEG
80054: PUSH
80055: LD_INT 2
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: LIST
80066: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80067: LD_ADDR_VAR 0 57
80071: PUSH
80072: LD_INT 2
80074: NEG
80075: PUSH
80076: LD_INT 1
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 3
80085: NEG
80086: PUSH
80087: LD_INT 0
80089: PUSH
80090: EMPTY
80091: LIST
80092: LIST
80093: PUSH
80094: LD_INT 3
80096: NEG
80097: PUSH
80098: LD_INT 1
80100: NEG
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: LIST
80110: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80111: LD_ADDR_VAR 0 58
80115: PUSH
80116: LD_INT 2
80118: NEG
80119: PUSH
80120: LD_INT 3
80122: NEG
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 3
80130: NEG
80131: PUSH
80132: LD_INT 2
80134: NEG
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 3
80142: NEG
80143: PUSH
80144: LD_INT 3
80146: NEG
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: LIST
80156: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80157: LD_ADDR_VAR 0 59
80161: PUSH
80162: LD_INT 1
80164: NEG
80165: PUSH
80166: LD_INT 2
80168: NEG
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 0
80176: PUSH
80177: LD_INT 2
80179: NEG
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 1
80187: PUSH
80188: LD_INT 1
80190: NEG
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: LIST
80200: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80201: LD_ADDR_VAR 0 60
80205: PUSH
80206: LD_INT 1
80208: PUSH
80209: LD_INT 1
80211: NEG
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 2
80219: PUSH
80220: LD_INT 0
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 2
80229: PUSH
80230: LD_INT 1
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: LIST
80241: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80242: LD_ADDR_VAR 0 61
80246: PUSH
80247: LD_INT 2
80249: PUSH
80250: LD_INT 1
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: PUSH
80257: LD_INT 2
80259: PUSH
80260: LD_INT 2
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 1
80269: PUSH
80270: LD_INT 2
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: LIST
80281: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80282: LD_ADDR_VAR 0 62
80286: PUSH
80287: LD_INT 1
80289: PUSH
80290: LD_INT 2
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 0
80299: PUSH
80300: LD_INT 2
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 1
80309: NEG
80310: PUSH
80311: LD_INT 1
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: LIST
80322: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80323: LD_ADDR_VAR 0 63
80327: PUSH
80328: LD_INT 1
80330: NEG
80331: PUSH
80332: LD_INT 1
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 2
80341: NEG
80342: PUSH
80343: LD_INT 0
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 2
80352: NEG
80353: PUSH
80354: LD_INT 1
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: LIST
80366: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80367: LD_ADDR_VAR 0 64
80371: PUSH
80372: LD_INT 1
80374: NEG
80375: PUSH
80376: LD_INT 2
80378: NEG
80379: PUSH
80380: EMPTY
80381: LIST
80382: LIST
80383: PUSH
80384: LD_INT 2
80386: NEG
80387: PUSH
80388: LD_INT 1
80390: NEG
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 2
80398: NEG
80399: PUSH
80400: LD_INT 2
80402: NEG
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: LIST
80412: ST_TO_ADDR
// end ; 2 :
80413: GO 83679
80415: LD_INT 2
80417: DOUBLE
80418: EQUAL
80419: IFTRUE 80423
80421: GO 83678
80423: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80424: LD_ADDR_VAR 0 29
80428: PUSH
80429: LD_INT 4
80431: PUSH
80432: LD_INT 0
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 4
80441: PUSH
80442: LD_INT 1
80444: NEG
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: LD_INT 5
80452: PUSH
80453: LD_INT 0
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: PUSH
80460: LD_INT 5
80462: PUSH
80463: LD_INT 1
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 4
80472: PUSH
80473: LD_INT 1
80475: PUSH
80476: EMPTY
80477: LIST
80478: LIST
80479: PUSH
80480: LD_INT 3
80482: PUSH
80483: LD_INT 0
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 3
80492: PUSH
80493: LD_INT 1
80495: NEG
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 3
80503: PUSH
80504: LD_INT 2
80506: NEG
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 5
80514: PUSH
80515: LD_INT 2
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: PUSH
80522: LD_INT 3
80524: PUSH
80525: LD_INT 3
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: PUSH
80532: LD_INT 3
80534: PUSH
80535: LD_INT 2
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 4
80544: PUSH
80545: LD_INT 3
80547: PUSH
80548: EMPTY
80549: LIST
80550: LIST
80551: PUSH
80552: LD_INT 4
80554: PUSH
80555: LD_INT 4
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 3
80564: PUSH
80565: LD_INT 4
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: PUSH
80572: LD_INT 2
80574: PUSH
80575: LD_INT 3
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 2
80584: PUSH
80585: LD_INT 2
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: LD_INT 4
80594: PUSH
80595: LD_INT 2
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 2
80604: PUSH
80605: LD_INT 4
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: LD_INT 4
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: LD_INT 0
80624: PUSH
80625: LD_INT 3
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 1
80634: PUSH
80635: LD_INT 4
80637: PUSH
80638: EMPTY
80639: LIST
80640: LIST
80641: PUSH
80642: LD_INT 1
80644: PUSH
80645: LD_INT 5
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: LD_INT 5
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 1
80664: NEG
80665: PUSH
80666: LD_INT 4
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: LD_INT 3
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: PUSH
80684: LD_INT 2
80686: PUSH
80687: LD_INT 5
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 2
80696: NEG
80697: PUSH
80698: LD_INT 3
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 3
80707: NEG
80708: PUSH
80709: LD_INT 0
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 3
80718: NEG
80719: PUSH
80720: LD_INT 1
80722: NEG
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 2
80730: NEG
80731: PUSH
80732: LD_INT 0
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 2
80741: NEG
80742: PUSH
80743: LD_INT 1
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 3
80752: NEG
80753: PUSH
80754: LD_INT 1
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 4
80763: NEG
80764: PUSH
80765: LD_INT 0
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PUSH
80772: LD_INT 4
80774: NEG
80775: PUSH
80776: LD_INT 1
80778: NEG
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 4
80786: NEG
80787: PUSH
80788: LD_INT 2
80790: NEG
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 2
80798: NEG
80799: PUSH
80800: LD_INT 2
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 4
80809: NEG
80810: PUSH
80811: LD_INT 4
80813: NEG
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 4
80821: NEG
80822: PUSH
80823: LD_INT 5
80825: NEG
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: LD_INT 3
80833: NEG
80834: PUSH
80835: LD_INT 4
80837: NEG
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 3
80845: NEG
80846: PUSH
80847: LD_INT 3
80849: NEG
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: LD_INT 4
80857: NEG
80858: PUSH
80859: LD_INT 3
80861: NEG
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 5
80869: NEG
80870: PUSH
80871: LD_INT 4
80873: NEG
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 5
80881: NEG
80882: PUSH
80883: LD_INT 5
80885: NEG
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PUSH
80891: LD_INT 3
80893: NEG
80894: PUSH
80895: LD_INT 5
80897: NEG
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 5
80905: NEG
80906: PUSH
80907: LD_INT 3
80909: NEG
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80962: LD_ADDR_VAR 0 30
80966: PUSH
80967: LD_INT 4
80969: PUSH
80970: LD_INT 4
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 4
80979: PUSH
80980: LD_INT 3
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 5
80989: PUSH
80990: LD_INT 4
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 5
80999: PUSH
81000: LD_INT 5
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 4
81009: PUSH
81010: LD_INT 5
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 3
81019: PUSH
81020: LD_INT 4
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 3
81029: PUSH
81030: LD_INT 3
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 5
81039: PUSH
81040: LD_INT 3
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 3
81049: PUSH
81050: LD_INT 5
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 0
81059: PUSH
81060: LD_INT 3
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 0
81069: PUSH
81070: LD_INT 2
81072: PUSH
81073: EMPTY
81074: LIST
81075: LIST
81076: PUSH
81077: LD_INT 1
81079: PUSH
81080: LD_INT 3
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 1
81089: PUSH
81090: LD_INT 4
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 0
81099: PUSH
81100: LD_INT 4
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 1
81109: NEG
81110: PUSH
81111: LD_INT 3
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: LD_INT 2
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: LD_INT 2
81131: PUSH
81132: LD_INT 4
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 2
81141: NEG
81142: PUSH
81143: LD_INT 2
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 4
81152: NEG
81153: PUSH
81154: LD_INT 0
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 4
81163: NEG
81164: PUSH
81165: LD_INT 1
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 3
81175: NEG
81176: PUSH
81177: LD_INT 0
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 3
81186: NEG
81187: PUSH
81188: LD_INT 1
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 4
81197: NEG
81198: PUSH
81199: LD_INT 1
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 5
81208: NEG
81209: PUSH
81210: LD_INT 0
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 5
81219: NEG
81220: PUSH
81221: LD_INT 1
81223: NEG
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: PUSH
81229: LD_INT 5
81231: NEG
81232: PUSH
81233: LD_INT 2
81235: NEG
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 3
81243: NEG
81244: PUSH
81245: LD_INT 2
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 3
81254: NEG
81255: PUSH
81256: LD_INT 3
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 3
81266: NEG
81267: PUSH
81268: LD_INT 4
81270: NEG
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 2
81278: NEG
81279: PUSH
81280: LD_INT 3
81282: NEG
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 2
81290: NEG
81291: PUSH
81292: LD_INT 2
81294: NEG
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 3
81302: NEG
81303: PUSH
81304: LD_INT 2
81306: NEG
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 4
81314: NEG
81315: PUSH
81316: LD_INT 3
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 4
81326: NEG
81327: PUSH
81328: LD_INT 4
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 2
81338: NEG
81339: PUSH
81340: LD_INT 4
81342: NEG
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 4
81350: NEG
81351: PUSH
81352: LD_INT 2
81354: NEG
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 0
81362: PUSH
81363: LD_INT 4
81365: NEG
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 0
81373: PUSH
81374: LD_INT 5
81376: NEG
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 1
81384: PUSH
81385: LD_INT 4
81387: NEG
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 1
81395: PUSH
81396: LD_INT 3
81398: NEG
81399: PUSH
81400: EMPTY
81401: LIST
81402: LIST
81403: PUSH
81404: LD_INT 0
81406: PUSH
81407: LD_INT 3
81409: NEG
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 1
81417: NEG
81418: PUSH
81419: LD_INT 4
81421: NEG
81422: PUSH
81423: EMPTY
81424: LIST
81425: LIST
81426: PUSH
81427: LD_INT 1
81429: NEG
81430: PUSH
81431: LD_INT 5
81433: NEG
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 2
81441: PUSH
81442: LD_INT 3
81444: NEG
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 2
81452: NEG
81453: PUSH
81454: LD_INT 5
81456: NEG
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: LIST
81508: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81509: LD_ADDR_VAR 0 31
81513: PUSH
81514: LD_INT 0
81516: PUSH
81517: LD_INT 4
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 0
81526: PUSH
81527: LD_INT 3
81529: PUSH
81530: EMPTY
81531: LIST
81532: LIST
81533: PUSH
81534: LD_INT 1
81536: PUSH
81537: LD_INT 4
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 1
81546: PUSH
81547: LD_INT 5
81549: PUSH
81550: EMPTY
81551: LIST
81552: LIST
81553: PUSH
81554: LD_INT 0
81556: PUSH
81557: LD_INT 5
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: LD_INT 1
81566: NEG
81567: PUSH
81568: LD_INT 4
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: NEG
81578: PUSH
81579: LD_INT 3
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 2
81588: PUSH
81589: LD_INT 5
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 2
81598: NEG
81599: PUSH
81600: LD_INT 3
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: PUSH
81607: LD_INT 3
81609: NEG
81610: PUSH
81611: LD_INT 0
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 3
81620: NEG
81621: PUSH
81622: LD_INT 1
81624: NEG
81625: PUSH
81626: EMPTY
81627: LIST
81628: LIST
81629: PUSH
81630: LD_INT 2
81632: NEG
81633: PUSH
81634: LD_INT 0
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 2
81643: NEG
81644: PUSH
81645: LD_INT 1
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: PUSH
81652: LD_INT 3
81654: NEG
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 4
81665: NEG
81666: PUSH
81667: LD_INT 0
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 4
81676: NEG
81677: PUSH
81678: LD_INT 1
81680: NEG
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: PUSH
81686: LD_INT 4
81688: NEG
81689: PUSH
81690: LD_INT 2
81692: NEG
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 2
81700: NEG
81701: PUSH
81702: LD_INT 2
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 4
81711: NEG
81712: PUSH
81713: LD_INT 4
81715: NEG
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 4
81723: NEG
81724: PUSH
81725: LD_INT 5
81727: NEG
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 3
81735: NEG
81736: PUSH
81737: LD_INT 4
81739: NEG
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 3
81747: NEG
81748: PUSH
81749: LD_INT 3
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 4
81759: NEG
81760: PUSH
81761: LD_INT 3
81763: NEG
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 5
81771: NEG
81772: PUSH
81773: LD_INT 4
81775: NEG
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 5
81783: NEG
81784: PUSH
81785: LD_INT 5
81787: NEG
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 3
81795: NEG
81796: PUSH
81797: LD_INT 5
81799: NEG
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 5
81807: NEG
81808: PUSH
81809: LD_INT 3
81811: NEG
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 0
81819: PUSH
81820: LD_INT 3
81822: NEG
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 0
81830: PUSH
81831: LD_INT 4
81833: NEG
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 1
81841: PUSH
81842: LD_INT 3
81844: NEG
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 1
81852: PUSH
81853: LD_INT 2
81855: NEG
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 0
81863: PUSH
81864: LD_INT 2
81866: NEG
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 1
81874: NEG
81875: PUSH
81876: LD_INT 3
81878: NEG
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PUSH
81884: LD_INT 1
81886: NEG
81887: PUSH
81888: LD_INT 4
81890: NEG
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 2
81898: PUSH
81899: LD_INT 2
81901: NEG
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 2
81909: NEG
81910: PUSH
81911: LD_INT 4
81913: NEG
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 4
81921: PUSH
81922: LD_INT 0
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 4
81931: PUSH
81932: LD_INT 1
81934: NEG
81935: PUSH
81936: EMPTY
81937: LIST
81938: LIST
81939: PUSH
81940: LD_INT 5
81942: PUSH
81943: LD_INT 0
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 5
81952: PUSH
81953: LD_INT 1
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 4
81962: PUSH
81963: LD_INT 1
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 3
81972: PUSH
81973: LD_INT 0
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 3
81982: PUSH
81983: LD_INT 1
81985: NEG
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 3
81993: PUSH
81994: LD_INT 2
81996: NEG
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 5
82004: PUSH
82005: LD_INT 2
82007: PUSH
82008: EMPTY
82009: LIST
82010: LIST
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: LIST
82055: LIST
82056: LIST
82057: LIST
82058: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82059: LD_ADDR_VAR 0 32
82063: PUSH
82064: LD_INT 4
82066: NEG
82067: PUSH
82068: LD_INT 0
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 4
82077: NEG
82078: PUSH
82079: LD_INT 1
82081: NEG
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 3
82089: NEG
82090: PUSH
82091: LD_INT 0
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 3
82100: NEG
82101: PUSH
82102: LD_INT 1
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 4
82111: NEG
82112: PUSH
82113: LD_INT 1
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 5
82122: NEG
82123: PUSH
82124: LD_INT 0
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 5
82133: NEG
82134: PUSH
82135: LD_INT 1
82137: NEG
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 5
82145: NEG
82146: PUSH
82147: LD_INT 2
82149: NEG
82150: PUSH
82151: EMPTY
82152: LIST
82153: LIST
82154: PUSH
82155: LD_INT 3
82157: NEG
82158: PUSH
82159: LD_INT 2
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 3
82168: NEG
82169: PUSH
82170: LD_INT 3
82172: NEG
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 3
82180: NEG
82181: PUSH
82182: LD_INT 4
82184: NEG
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 2
82192: NEG
82193: PUSH
82194: LD_INT 3
82196: NEG
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 2
82204: NEG
82205: PUSH
82206: LD_INT 2
82208: NEG
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 3
82216: NEG
82217: PUSH
82218: LD_INT 2
82220: NEG
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 4
82228: NEG
82229: PUSH
82230: LD_INT 3
82232: NEG
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 4
82240: NEG
82241: PUSH
82242: LD_INT 4
82244: NEG
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 2
82252: NEG
82253: PUSH
82254: LD_INT 4
82256: NEG
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 4
82264: NEG
82265: PUSH
82266: LD_INT 2
82268: NEG
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 0
82276: PUSH
82277: LD_INT 4
82279: NEG
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 0
82287: PUSH
82288: LD_INT 5
82290: NEG
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 1
82298: PUSH
82299: LD_INT 4
82301: NEG
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 1
82309: PUSH
82310: LD_INT 3
82312: NEG
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: LD_INT 0
82320: PUSH
82321: LD_INT 3
82323: NEG
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 1
82331: NEG
82332: PUSH
82333: LD_INT 4
82335: NEG
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: NEG
82344: PUSH
82345: LD_INT 5
82347: NEG
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 2
82355: PUSH
82356: LD_INT 3
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 2
82366: NEG
82367: PUSH
82368: LD_INT 5
82370: NEG
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: LD_INT 3
82378: PUSH
82379: LD_INT 0
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 3
82388: PUSH
82389: LD_INT 1
82391: NEG
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 4
82399: PUSH
82400: LD_INT 0
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: LD_INT 4
82409: PUSH
82410: LD_INT 1
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 3
82419: PUSH
82420: LD_INT 1
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 2
82429: PUSH
82430: LD_INT 0
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 2
82439: PUSH
82440: LD_INT 1
82442: NEG
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 2
82450: PUSH
82451: LD_INT 2
82453: NEG
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 4
82461: PUSH
82462: LD_INT 2
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 4
82471: PUSH
82472: LD_INT 4
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 4
82481: PUSH
82482: LD_INT 3
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 5
82491: PUSH
82492: LD_INT 4
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 5
82501: PUSH
82502: LD_INT 5
82504: PUSH
82505: EMPTY
82506: LIST
82507: LIST
82508: PUSH
82509: LD_INT 4
82511: PUSH
82512: LD_INT 5
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 3
82521: PUSH
82522: LD_INT 4
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 3
82531: PUSH
82532: LD_INT 3
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 5
82541: PUSH
82542: LD_INT 3
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 3
82551: PUSH
82552: LD_INT 5
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: LIST
82601: LIST
82602: LIST
82603: LIST
82604: LIST
82605: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82606: LD_ADDR_VAR 0 33
82610: PUSH
82611: LD_INT 4
82613: NEG
82614: PUSH
82615: LD_INT 4
82617: NEG
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 4
82625: NEG
82626: PUSH
82627: LD_INT 5
82629: NEG
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 3
82637: NEG
82638: PUSH
82639: LD_INT 4
82641: NEG
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 3
82649: NEG
82650: PUSH
82651: LD_INT 3
82653: NEG
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: LD_INT 4
82661: NEG
82662: PUSH
82663: LD_INT 3
82665: NEG
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 5
82673: NEG
82674: PUSH
82675: LD_INT 4
82677: NEG
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 5
82685: NEG
82686: PUSH
82687: LD_INT 5
82689: NEG
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 3
82697: NEG
82698: PUSH
82699: LD_INT 5
82701: NEG
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 5
82709: NEG
82710: PUSH
82711: LD_INT 3
82713: NEG
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 0
82721: PUSH
82722: LD_INT 3
82724: NEG
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 0
82732: PUSH
82733: LD_INT 4
82735: NEG
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 1
82743: PUSH
82744: LD_INT 3
82746: NEG
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 1
82754: PUSH
82755: LD_INT 2
82757: NEG
82758: PUSH
82759: EMPTY
82760: LIST
82761: LIST
82762: PUSH
82763: LD_INT 0
82765: PUSH
82766: LD_INT 2
82768: NEG
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 1
82776: NEG
82777: PUSH
82778: LD_INT 3
82780: NEG
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 1
82788: NEG
82789: PUSH
82790: LD_INT 4
82792: NEG
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 2
82800: PUSH
82801: LD_INT 2
82803: NEG
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 2
82811: NEG
82812: PUSH
82813: LD_INT 4
82815: NEG
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 4
82823: PUSH
82824: LD_INT 0
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: LD_INT 4
82833: PUSH
82834: LD_INT 1
82836: NEG
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 5
82844: PUSH
82845: LD_INT 0
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 5
82854: PUSH
82855: LD_INT 1
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 4
82864: PUSH
82865: LD_INT 1
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 3
82874: PUSH
82875: LD_INT 0
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 3
82884: PUSH
82885: LD_INT 1
82887: NEG
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 3
82895: PUSH
82896: LD_INT 2
82898: NEG
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 5
82906: PUSH
82907: LD_INT 2
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 3
82916: PUSH
82917: LD_INT 3
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: LD_INT 3
82926: PUSH
82927: LD_INT 2
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 4
82936: PUSH
82937: LD_INT 3
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 4
82946: PUSH
82947: LD_INT 4
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 3
82956: PUSH
82957: LD_INT 4
82959: PUSH
82960: EMPTY
82961: LIST
82962: LIST
82963: PUSH
82964: LD_INT 2
82966: PUSH
82967: LD_INT 3
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 2
82976: PUSH
82977: LD_INT 2
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: LD_INT 4
82986: PUSH
82987: LD_INT 2
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 2
82996: PUSH
82997: LD_INT 4
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: LD_INT 4
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 0
83016: PUSH
83017: LD_INT 3
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: PUSH
83024: LD_INT 1
83026: PUSH
83027: LD_INT 4
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: LD_INT 1
83036: PUSH
83037: LD_INT 5
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 0
83046: PUSH
83047: LD_INT 5
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 1
83056: NEG
83057: PUSH
83058: LD_INT 4
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: LD_INT 3
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 2
83078: PUSH
83079: LD_INT 5
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 2
83088: NEG
83089: PUSH
83090: LD_INT 3
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83144: LD_ADDR_VAR 0 34
83148: PUSH
83149: LD_INT 0
83151: PUSH
83152: LD_INT 4
83154: NEG
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 0
83162: PUSH
83163: LD_INT 5
83165: NEG
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: LD_INT 4
83176: NEG
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: LD_INT 1
83184: PUSH
83185: LD_INT 3
83187: NEG
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 0
83195: PUSH
83196: LD_INT 3
83198: NEG
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 1
83206: NEG
83207: PUSH
83208: LD_INT 4
83210: NEG
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: PUSH
83216: LD_INT 1
83218: NEG
83219: PUSH
83220: LD_INT 5
83222: NEG
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 2
83230: PUSH
83231: LD_INT 3
83233: NEG
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 2
83241: NEG
83242: PUSH
83243: LD_INT 5
83245: NEG
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 3
83253: PUSH
83254: LD_INT 0
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 3
83263: PUSH
83264: LD_INT 1
83266: NEG
83267: PUSH
83268: EMPTY
83269: LIST
83270: LIST
83271: PUSH
83272: LD_INT 4
83274: PUSH
83275: LD_INT 0
83277: PUSH
83278: EMPTY
83279: LIST
83280: LIST
83281: PUSH
83282: LD_INT 4
83284: PUSH
83285: LD_INT 1
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 3
83294: PUSH
83295: LD_INT 1
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 2
83304: PUSH
83305: LD_INT 0
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 2
83314: PUSH
83315: LD_INT 1
83317: NEG
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 2
83325: PUSH
83326: LD_INT 2
83328: NEG
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 4
83336: PUSH
83337: LD_INT 2
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 4
83346: PUSH
83347: LD_INT 4
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 4
83356: PUSH
83357: LD_INT 3
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 5
83366: PUSH
83367: LD_INT 4
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PUSH
83374: LD_INT 5
83376: PUSH
83377: LD_INT 5
83379: PUSH
83380: EMPTY
83381: LIST
83382: LIST
83383: PUSH
83384: LD_INT 4
83386: PUSH
83387: LD_INT 5
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PUSH
83394: LD_INT 3
83396: PUSH
83397: LD_INT 4
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 3
83406: PUSH
83407: LD_INT 3
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 5
83416: PUSH
83417: LD_INT 3
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 3
83426: PUSH
83427: LD_INT 5
83429: PUSH
83430: EMPTY
83431: LIST
83432: LIST
83433: PUSH
83434: LD_INT 0
83436: PUSH
83437: LD_INT 3
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 0
83446: PUSH
83447: LD_INT 2
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 1
83456: PUSH
83457: LD_INT 3
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: LD_INT 1
83466: PUSH
83467: LD_INT 4
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 0
83476: PUSH
83477: LD_INT 4
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 1
83486: NEG
83487: PUSH
83488: LD_INT 3
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 1
83497: NEG
83498: PUSH
83499: LD_INT 2
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: LD_INT 4
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 2
83518: NEG
83519: PUSH
83520: LD_INT 2
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 4
83529: NEG
83530: PUSH
83531: LD_INT 0
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 4
83540: NEG
83541: PUSH
83542: LD_INT 1
83544: NEG
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: LD_INT 3
83552: NEG
83553: PUSH
83554: LD_INT 0
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 3
83563: NEG
83564: PUSH
83565: LD_INT 1
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 4
83574: NEG
83575: PUSH
83576: LD_INT 1
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 5
83585: NEG
83586: PUSH
83587: LD_INT 0
83589: PUSH
83590: EMPTY
83591: LIST
83592: LIST
83593: PUSH
83594: LD_INT 5
83596: NEG
83597: PUSH
83598: LD_INT 1
83600: NEG
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PUSH
83606: LD_INT 5
83608: NEG
83609: PUSH
83610: LD_INT 2
83612: NEG
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 3
83620: NEG
83621: PUSH
83622: LD_INT 2
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: LIST
83673: LIST
83674: LIST
83675: ST_TO_ADDR
// end ; end ;
83676: GO 83679
83678: POP
// case btype of b_depot , b_warehouse :
83679: LD_VAR 0 1
83683: PUSH
83684: LD_INT 0
83686: DOUBLE
83687: EQUAL
83688: IFTRUE 83698
83690: LD_INT 1
83692: DOUBLE
83693: EQUAL
83694: IFTRUE 83698
83696: GO 83899
83698: POP
// case nation of nation_american :
83699: LD_VAR 0 5
83703: PUSH
83704: LD_INT 1
83706: DOUBLE
83707: EQUAL
83708: IFTRUE 83712
83710: GO 83768
83712: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83713: LD_ADDR_VAR 0 9
83717: PUSH
83718: LD_VAR 0 11
83722: PUSH
83723: LD_VAR 0 12
83727: PUSH
83728: LD_VAR 0 13
83732: PUSH
83733: LD_VAR 0 14
83737: PUSH
83738: LD_VAR 0 15
83742: PUSH
83743: LD_VAR 0 16
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: PUSH
83756: LD_VAR 0 4
83760: PUSH
83761: LD_INT 1
83763: PLUS
83764: ARRAY
83765: ST_TO_ADDR
83766: GO 83897
83768: LD_INT 2
83770: DOUBLE
83771: EQUAL
83772: IFTRUE 83776
83774: GO 83832
83776: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83777: LD_ADDR_VAR 0 9
83781: PUSH
83782: LD_VAR 0 17
83786: PUSH
83787: LD_VAR 0 18
83791: PUSH
83792: LD_VAR 0 19
83796: PUSH
83797: LD_VAR 0 20
83801: PUSH
83802: LD_VAR 0 21
83806: PUSH
83807: LD_VAR 0 22
83811: PUSH
83812: EMPTY
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: PUSH
83820: LD_VAR 0 4
83824: PUSH
83825: LD_INT 1
83827: PLUS
83828: ARRAY
83829: ST_TO_ADDR
83830: GO 83897
83832: LD_INT 3
83834: DOUBLE
83835: EQUAL
83836: IFTRUE 83840
83838: GO 83896
83840: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83841: LD_ADDR_VAR 0 9
83845: PUSH
83846: LD_VAR 0 23
83850: PUSH
83851: LD_VAR 0 24
83855: PUSH
83856: LD_VAR 0 25
83860: PUSH
83861: LD_VAR 0 26
83865: PUSH
83866: LD_VAR 0 27
83870: PUSH
83871: LD_VAR 0 28
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: PUSH
83884: LD_VAR 0 4
83888: PUSH
83889: LD_INT 1
83891: PLUS
83892: ARRAY
83893: ST_TO_ADDR
83894: GO 83897
83896: POP
83897: GO 84452
83899: LD_INT 2
83901: DOUBLE
83902: EQUAL
83903: IFTRUE 83913
83905: LD_INT 3
83907: DOUBLE
83908: EQUAL
83909: IFTRUE 83913
83911: GO 83969
83913: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83914: LD_ADDR_VAR 0 9
83918: PUSH
83919: LD_VAR 0 29
83923: PUSH
83924: LD_VAR 0 30
83928: PUSH
83929: LD_VAR 0 31
83933: PUSH
83934: LD_VAR 0 32
83938: PUSH
83939: LD_VAR 0 33
83943: PUSH
83944: LD_VAR 0 34
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: PUSH
83957: LD_VAR 0 4
83961: PUSH
83962: LD_INT 1
83964: PLUS
83965: ARRAY
83966: ST_TO_ADDR
83967: GO 84452
83969: LD_INT 16
83971: DOUBLE
83972: EQUAL
83973: IFTRUE 84031
83975: LD_INT 17
83977: DOUBLE
83978: EQUAL
83979: IFTRUE 84031
83981: LD_INT 18
83983: DOUBLE
83984: EQUAL
83985: IFTRUE 84031
83987: LD_INT 19
83989: DOUBLE
83990: EQUAL
83991: IFTRUE 84031
83993: LD_INT 22
83995: DOUBLE
83996: EQUAL
83997: IFTRUE 84031
83999: LD_INT 20
84001: DOUBLE
84002: EQUAL
84003: IFTRUE 84031
84005: LD_INT 21
84007: DOUBLE
84008: EQUAL
84009: IFTRUE 84031
84011: LD_INT 23
84013: DOUBLE
84014: EQUAL
84015: IFTRUE 84031
84017: LD_INT 24
84019: DOUBLE
84020: EQUAL
84021: IFTRUE 84031
84023: LD_INT 25
84025: DOUBLE
84026: EQUAL
84027: IFTRUE 84031
84029: GO 84087
84031: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84032: LD_ADDR_VAR 0 9
84036: PUSH
84037: LD_VAR 0 35
84041: PUSH
84042: LD_VAR 0 36
84046: PUSH
84047: LD_VAR 0 37
84051: PUSH
84052: LD_VAR 0 38
84056: PUSH
84057: LD_VAR 0 39
84061: PUSH
84062: LD_VAR 0 40
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: PUSH
84075: LD_VAR 0 4
84079: PUSH
84080: LD_INT 1
84082: PLUS
84083: ARRAY
84084: ST_TO_ADDR
84085: GO 84452
84087: LD_INT 6
84089: DOUBLE
84090: EQUAL
84091: IFTRUE 84143
84093: LD_INT 7
84095: DOUBLE
84096: EQUAL
84097: IFTRUE 84143
84099: LD_INT 8
84101: DOUBLE
84102: EQUAL
84103: IFTRUE 84143
84105: LD_INT 13
84107: DOUBLE
84108: EQUAL
84109: IFTRUE 84143
84111: LD_INT 12
84113: DOUBLE
84114: EQUAL
84115: IFTRUE 84143
84117: LD_INT 15
84119: DOUBLE
84120: EQUAL
84121: IFTRUE 84143
84123: LD_INT 11
84125: DOUBLE
84126: EQUAL
84127: IFTRUE 84143
84129: LD_INT 14
84131: DOUBLE
84132: EQUAL
84133: IFTRUE 84143
84135: LD_INT 10
84137: DOUBLE
84138: EQUAL
84139: IFTRUE 84143
84141: GO 84199
84143: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84144: LD_ADDR_VAR 0 9
84148: PUSH
84149: LD_VAR 0 41
84153: PUSH
84154: LD_VAR 0 42
84158: PUSH
84159: LD_VAR 0 43
84163: PUSH
84164: LD_VAR 0 44
84168: PUSH
84169: LD_VAR 0 45
84173: PUSH
84174: LD_VAR 0 46
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: LIST
84183: LIST
84184: LIST
84185: LIST
84186: PUSH
84187: LD_VAR 0 4
84191: PUSH
84192: LD_INT 1
84194: PLUS
84195: ARRAY
84196: ST_TO_ADDR
84197: GO 84452
84199: LD_INT 36
84201: DOUBLE
84202: EQUAL
84203: IFTRUE 84207
84205: GO 84263
84207: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84208: LD_ADDR_VAR 0 9
84212: PUSH
84213: LD_VAR 0 47
84217: PUSH
84218: LD_VAR 0 48
84222: PUSH
84223: LD_VAR 0 49
84227: PUSH
84228: LD_VAR 0 50
84232: PUSH
84233: LD_VAR 0 51
84237: PUSH
84238: LD_VAR 0 52
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: PUSH
84251: LD_VAR 0 4
84255: PUSH
84256: LD_INT 1
84258: PLUS
84259: ARRAY
84260: ST_TO_ADDR
84261: GO 84452
84263: LD_INT 4
84265: DOUBLE
84266: EQUAL
84267: IFTRUE 84289
84269: LD_INT 5
84271: DOUBLE
84272: EQUAL
84273: IFTRUE 84289
84275: LD_INT 34
84277: DOUBLE
84278: EQUAL
84279: IFTRUE 84289
84281: LD_INT 37
84283: DOUBLE
84284: EQUAL
84285: IFTRUE 84289
84287: GO 84345
84289: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84290: LD_ADDR_VAR 0 9
84294: PUSH
84295: LD_VAR 0 53
84299: PUSH
84300: LD_VAR 0 54
84304: PUSH
84305: LD_VAR 0 55
84309: PUSH
84310: LD_VAR 0 56
84314: PUSH
84315: LD_VAR 0 57
84319: PUSH
84320: LD_VAR 0 58
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: PUSH
84333: LD_VAR 0 4
84337: PUSH
84338: LD_INT 1
84340: PLUS
84341: ARRAY
84342: ST_TO_ADDR
84343: GO 84452
84345: LD_INT 31
84347: DOUBLE
84348: EQUAL
84349: IFTRUE 84395
84351: LD_INT 32
84353: DOUBLE
84354: EQUAL
84355: IFTRUE 84395
84357: LD_INT 33
84359: DOUBLE
84360: EQUAL
84361: IFTRUE 84395
84363: LD_INT 27
84365: DOUBLE
84366: EQUAL
84367: IFTRUE 84395
84369: LD_INT 26
84371: DOUBLE
84372: EQUAL
84373: IFTRUE 84395
84375: LD_INT 28
84377: DOUBLE
84378: EQUAL
84379: IFTRUE 84395
84381: LD_INT 29
84383: DOUBLE
84384: EQUAL
84385: IFTRUE 84395
84387: LD_INT 30
84389: DOUBLE
84390: EQUAL
84391: IFTRUE 84395
84393: GO 84451
84395: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84396: LD_ADDR_VAR 0 9
84400: PUSH
84401: LD_VAR 0 59
84405: PUSH
84406: LD_VAR 0 60
84410: PUSH
84411: LD_VAR 0 61
84415: PUSH
84416: LD_VAR 0 62
84420: PUSH
84421: LD_VAR 0 63
84425: PUSH
84426: LD_VAR 0 64
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: PUSH
84439: LD_VAR 0 4
84443: PUSH
84444: LD_INT 1
84446: PLUS
84447: ARRAY
84448: ST_TO_ADDR
84449: GO 84452
84451: POP
// temp_list2 = [ ] ;
84452: LD_ADDR_VAR 0 10
84456: PUSH
84457: EMPTY
84458: ST_TO_ADDR
// for i in temp_list do
84459: LD_ADDR_VAR 0 8
84463: PUSH
84464: LD_VAR 0 9
84468: PUSH
84469: FOR_IN
84470: IFFALSE 84522
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84472: LD_ADDR_VAR 0 10
84476: PUSH
84477: LD_VAR 0 10
84481: PUSH
84482: LD_VAR 0 8
84486: PUSH
84487: LD_INT 1
84489: ARRAY
84490: PUSH
84491: LD_VAR 0 2
84495: PLUS
84496: PUSH
84497: LD_VAR 0 8
84501: PUSH
84502: LD_INT 2
84504: ARRAY
84505: PUSH
84506: LD_VAR 0 3
84510: PLUS
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: PUSH
84516: EMPTY
84517: LIST
84518: ADD
84519: ST_TO_ADDR
84520: GO 84469
84522: POP
84523: POP
// result = temp_list2 ;
84524: LD_ADDR_VAR 0 7
84528: PUSH
84529: LD_VAR 0 10
84533: ST_TO_ADDR
// end ;
84534: LD_VAR 0 7
84538: RET
// export function EnemyInRange ( unit , dist ) ; begin
84539: LD_INT 0
84541: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84542: LD_ADDR_VAR 0 3
84546: PUSH
84547: LD_VAR 0 1
84551: PPUSH
84552: CALL_OW 255
84556: PPUSH
84557: LD_VAR 0 1
84561: PPUSH
84562: CALL_OW 250
84566: PPUSH
84567: LD_VAR 0 1
84571: PPUSH
84572: CALL_OW 251
84576: PPUSH
84577: LD_VAR 0 2
84581: PPUSH
84582: CALL 57941 0 4
84586: PUSH
84587: LD_INT 4
84589: ARRAY
84590: ST_TO_ADDR
// end ;
84591: LD_VAR 0 3
84595: RET
// export function PlayerSeeMe ( unit ) ; begin
84596: LD_INT 0
84598: PPUSH
// result := See ( your_side , unit ) ;
84599: LD_ADDR_VAR 0 2
84603: PUSH
84604: LD_OWVAR 2
84608: PPUSH
84609: LD_VAR 0 1
84613: PPUSH
84614: CALL_OW 292
84618: ST_TO_ADDR
// end ;
84619: LD_VAR 0 2
84623: RET
// export function ReverseDir ( unit ) ; begin
84624: LD_INT 0
84626: PPUSH
// if not unit then
84627: LD_VAR 0 1
84631: NOT
84632: IFFALSE 84636
// exit ;
84634: GO 84659
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84636: LD_ADDR_VAR 0 2
84640: PUSH
84641: LD_VAR 0 1
84645: PPUSH
84646: CALL_OW 254
84650: PUSH
84651: LD_INT 3
84653: PLUS
84654: PUSH
84655: LD_INT 6
84657: MOD
84658: ST_TO_ADDR
// end ;
84659: LD_VAR 0 2
84663: RET
// export function ReverseArray ( array ) ; var i ; begin
84664: LD_INT 0
84666: PPUSH
84667: PPUSH
// if not array then
84668: LD_VAR 0 1
84672: NOT
84673: IFFALSE 84677
// exit ;
84675: GO 84732
// result := [ ] ;
84677: LD_ADDR_VAR 0 2
84681: PUSH
84682: EMPTY
84683: ST_TO_ADDR
// for i := array downto 1 do
84684: LD_ADDR_VAR 0 3
84688: PUSH
84689: DOUBLE
84690: LD_VAR 0 1
84694: INC
84695: ST_TO_ADDR
84696: LD_INT 1
84698: PUSH
84699: FOR_DOWNTO
84700: IFFALSE 84730
// result := Join ( result , array [ i ] ) ;
84702: LD_ADDR_VAR 0 2
84706: PUSH
84707: LD_VAR 0 2
84711: PPUSH
84712: LD_VAR 0 1
84716: PUSH
84717: LD_VAR 0 3
84721: ARRAY
84722: PPUSH
84723: CALL 89357 0 2
84727: ST_TO_ADDR
84728: GO 84699
84730: POP
84731: POP
// end ;
84732: LD_VAR 0 2
84736: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
84737: LD_INT 0
84739: PPUSH
84740: PPUSH
84741: PPUSH
84742: PPUSH
84743: PPUSH
84744: PPUSH
// if not unit or not hexes then
84745: LD_VAR 0 1
84749: NOT
84750: PUSH
84751: LD_VAR 0 2
84755: NOT
84756: OR
84757: IFFALSE 84761
// exit ;
84759: GO 84884
// dist := 9999 ;
84761: LD_ADDR_VAR 0 5
84765: PUSH
84766: LD_INT 9999
84768: ST_TO_ADDR
// for i = 1 to hexes do
84769: LD_ADDR_VAR 0 4
84773: PUSH
84774: DOUBLE
84775: LD_INT 1
84777: DEC
84778: ST_TO_ADDR
84779: LD_VAR 0 2
84783: PUSH
84784: FOR_TO
84785: IFFALSE 84872
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84787: LD_ADDR_VAR 0 6
84791: PUSH
84792: LD_VAR 0 1
84796: PPUSH
84797: LD_VAR 0 2
84801: PUSH
84802: LD_VAR 0 4
84806: ARRAY
84807: PUSH
84808: LD_INT 1
84810: ARRAY
84811: PPUSH
84812: LD_VAR 0 2
84816: PUSH
84817: LD_VAR 0 4
84821: ARRAY
84822: PUSH
84823: LD_INT 2
84825: ARRAY
84826: PPUSH
84827: CALL_OW 297
84831: ST_TO_ADDR
// if tdist < dist then
84832: LD_VAR 0 6
84836: PUSH
84837: LD_VAR 0 5
84841: LESS
84842: IFFALSE 84870
// begin hex := hexes [ i ] ;
84844: LD_ADDR_VAR 0 8
84848: PUSH
84849: LD_VAR 0 2
84853: PUSH
84854: LD_VAR 0 4
84858: ARRAY
84859: ST_TO_ADDR
// dist := tdist ;
84860: LD_ADDR_VAR 0 5
84864: PUSH
84865: LD_VAR 0 6
84869: ST_TO_ADDR
// end ; end ;
84870: GO 84784
84872: POP
84873: POP
// result := hex ;
84874: LD_ADDR_VAR 0 3
84878: PUSH
84879: LD_VAR 0 8
84883: ST_TO_ADDR
// end ;
84884: LD_VAR 0 3
84888: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84889: LD_INT 0
84891: PPUSH
84892: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84893: LD_VAR 0 1
84897: NOT
84898: PUSH
84899: LD_VAR 0 1
84903: PUSH
84904: LD_INT 21
84906: PUSH
84907: LD_INT 2
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 23
84916: PUSH
84917: LD_INT 2
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PPUSH
84928: CALL_OW 69
84932: IN
84933: NOT
84934: OR
84935: IFFALSE 84939
// exit ;
84937: GO 84986
// for i = 1 to 3 do
84939: LD_ADDR_VAR 0 3
84943: PUSH
84944: DOUBLE
84945: LD_INT 1
84947: DEC
84948: ST_TO_ADDR
84949: LD_INT 3
84951: PUSH
84952: FOR_TO
84953: IFFALSE 84984
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84955: LD_VAR 0 1
84959: PPUSH
84960: CALL_OW 250
84964: PPUSH
84965: LD_VAR 0 1
84969: PPUSH
84970: CALL_OW 251
84974: PPUSH
84975: LD_INT 1
84977: PPUSH
84978: CALL_OW 453
84982: GO 84952
84984: POP
84985: POP
// end ;
84986: LD_VAR 0 2
84990: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84991: LD_INT 0
84993: PPUSH
84994: PPUSH
84995: PPUSH
84996: PPUSH
84997: PPUSH
84998: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84999: LD_VAR 0 1
85003: NOT
85004: PUSH
85005: LD_VAR 0 2
85009: NOT
85010: OR
85011: PUSH
85012: LD_VAR 0 1
85016: PPUSH
85017: CALL_OW 314
85021: OR
85022: IFFALSE 85026
// exit ;
85024: GO 85467
// x := GetX ( enemy_unit ) ;
85026: LD_ADDR_VAR 0 7
85030: PUSH
85031: LD_VAR 0 2
85035: PPUSH
85036: CALL_OW 250
85040: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85041: LD_ADDR_VAR 0 8
85045: PUSH
85046: LD_VAR 0 2
85050: PPUSH
85051: CALL_OW 251
85055: ST_TO_ADDR
// if not x or not y then
85056: LD_VAR 0 7
85060: NOT
85061: PUSH
85062: LD_VAR 0 8
85066: NOT
85067: OR
85068: IFFALSE 85072
// exit ;
85070: GO 85467
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85072: LD_ADDR_VAR 0 6
85076: PUSH
85077: LD_VAR 0 7
85081: PPUSH
85082: LD_INT 0
85084: PPUSH
85085: LD_INT 4
85087: PPUSH
85088: CALL_OW 272
85092: PUSH
85093: LD_VAR 0 8
85097: PPUSH
85098: LD_INT 0
85100: PPUSH
85101: LD_INT 4
85103: PPUSH
85104: CALL_OW 273
85108: PUSH
85109: EMPTY
85110: LIST
85111: LIST
85112: PUSH
85113: LD_VAR 0 7
85117: PPUSH
85118: LD_INT 1
85120: PPUSH
85121: LD_INT 4
85123: PPUSH
85124: CALL_OW 272
85128: PUSH
85129: LD_VAR 0 8
85133: PPUSH
85134: LD_INT 1
85136: PPUSH
85137: LD_INT 4
85139: PPUSH
85140: CALL_OW 273
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_VAR 0 7
85153: PPUSH
85154: LD_INT 2
85156: PPUSH
85157: LD_INT 4
85159: PPUSH
85160: CALL_OW 272
85164: PUSH
85165: LD_VAR 0 8
85169: PPUSH
85170: LD_INT 2
85172: PPUSH
85173: LD_INT 4
85175: PPUSH
85176: CALL_OW 273
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: PUSH
85185: LD_VAR 0 7
85189: PPUSH
85190: LD_INT 3
85192: PPUSH
85193: LD_INT 4
85195: PPUSH
85196: CALL_OW 272
85200: PUSH
85201: LD_VAR 0 8
85205: PPUSH
85206: LD_INT 3
85208: PPUSH
85209: LD_INT 4
85211: PPUSH
85212: CALL_OW 273
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_VAR 0 7
85225: PPUSH
85226: LD_INT 4
85228: PPUSH
85229: LD_INT 4
85231: PPUSH
85232: CALL_OW 272
85236: PUSH
85237: LD_VAR 0 8
85241: PPUSH
85242: LD_INT 4
85244: PPUSH
85245: LD_INT 4
85247: PPUSH
85248: CALL_OW 273
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_VAR 0 7
85261: PPUSH
85262: LD_INT 5
85264: PPUSH
85265: LD_INT 4
85267: PPUSH
85268: CALL_OW 272
85272: PUSH
85273: LD_VAR 0 8
85277: PPUSH
85278: LD_INT 5
85280: PPUSH
85281: LD_INT 4
85283: PPUSH
85284: CALL_OW 273
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: ST_TO_ADDR
// for i = tmp downto 1 do
85301: LD_ADDR_VAR 0 4
85305: PUSH
85306: DOUBLE
85307: LD_VAR 0 6
85311: INC
85312: ST_TO_ADDR
85313: LD_INT 1
85315: PUSH
85316: FOR_DOWNTO
85317: IFFALSE 85418
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85319: LD_VAR 0 6
85323: PUSH
85324: LD_VAR 0 4
85328: ARRAY
85329: PUSH
85330: LD_INT 1
85332: ARRAY
85333: PPUSH
85334: LD_VAR 0 6
85338: PUSH
85339: LD_VAR 0 4
85343: ARRAY
85344: PUSH
85345: LD_INT 2
85347: ARRAY
85348: PPUSH
85349: CALL_OW 488
85353: NOT
85354: PUSH
85355: LD_VAR 0 6
85359: PUSH
85360: LD_VAR 0 4
85364: ARRAY
85365: PUSH
85366: LD_INT 1
85368: ARRAY
85369: PPUSH
85370: LD_VAR 0 6
85374: PUSH
85375: LD_VAR 0 4
85379: ARRAY
85380: PUSH
85381: LD_INT 2
85383: ARRAY
85384: PPUSH
85385: CALL_OW 428
85389: PUSH
85390: LD_INT 0
85392: NONEQUAL
85393: OR
85394: IFFALSE 85416
// tmp := Delete ( tmp , i ) ;
85396: LD_ADDR_VAR 0 6
85400: PUSH
85401: LD_VAR 0 6
85405: PPUSH
85406: LD_VAR 0 4
85410: PPUSH
85411: CALL_OW 3
85415: ST_TO_ADDR
85416: GO 85316
85418: POP
85419: POP
// j := GetClosestHex ( unit , tmp ) ;
85420: LD_ADDR_VAR 0 5
85424: PUSH
85425: LD_VAR 0 1
85429: PPUSH
85430: LD_VAR 0 6
85434: PPUSH
85435: CALL 84737 0 2
85439: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85440: LD_VAR 0 1
85444: PPUSH
85445: LD_VAR 0 5
85449: PUSH
85450: LD_INT 1
85452: ARRAY
85453: PPUSH
85454: LD_VAR 0 5
85458: PUSH
85459: LD_INT 2
85461: ARRAY
85462: PPUSH
85463: CALL_OW 111
// end ;
85467: LD_VAR 0 3
85471: RET
// export function PrepareApemanSoldier ( ) ; begin
85472: LD_INT 0
85474: PPUSH
// uc_nation := 0 ;
85475: LD_ADDR_OWVAR 21
85479: PUSH
85480: LD_INT 0
85482: ST_TO_ADDR
// hc_sex := sex_male ;
85483: LD_ADDR_OWVAR 27
85487: PUSH
85488: LD_INT 1
85490: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
85491: LD_ADDR_OWVAR 28
85495: PUSH
85496: LD_INT 15
85498: ST_TO_ADDR
// hc_gallery :=  ;
85499: LD_ADDR_OWVAR 33
85503: PUSH
85504: LD_STRING 
85506: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85507: LD_ADDR_OWVAR 31
85511: PUSH
85512: LD_INT 0
85514: PPUSH
85515: LD_INT 3
85517: PPUSH
85518: CALL_OW 12
85522: PUSH
85523: LD_INT 0
85525: PPUSH
85526: LD_INT 3
85528: PPUSH
85529: CALL_OW 12
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: LD_INT 0
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: ST_TO_ADDR
// end ;
85546: LD_VAR 0 1
85550: RET
// export function PrepareApemanEngineer ( ) ; begin
85551: LD_INT 0
85553: PPUSH
// uc_nation := 0 ;
85554: LD_ADDR_OWVAR 21
85558: PUSH
85559: LD_INT 0
85561: ST_TO_ADDR
// hc_sex := sex_male ;
85562: LD_ADDR_OWVAR 27
85566: PUSH
85567: LD_INT 1
85569: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
85570: LD_ADDR_OWVAR 28
85574: PUSH
85575: LD_INT 16
85577: ST_TO_ADDR
// hc_gallery :=  ;
85578: LD_ADDR_OWVAR 33
85582: PUSH
85583: LD_STRING 
85585: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85586: LD_ADDR_OWVAR 31
85590: PUSH
85591: LD_INT 0
85593: PPUSH
85594: LD_INT 3
85596: PPUSH
85597: CALL_OW 12
85601: PUSH
85602: LD_INT 0
85604: PPUSH
85605: LD_INT 3
85607: PPUSH
85608: CALL_OW 12
85612: PUSH
85613: LD_INT 0
85615: PUSH
85616: LD_INT 0
85618: PUSH
85619: EMPTY
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: ST_TO_ADDR
// end ;
85625: LD_VAR 0 1
85629: RET
// export function PrepareApeman ( agressivity ) ; begin
85630: LD_INT 0
85632: PPUSH
// uc_side := 0 ;
85633: LD_ADDR_OWVAR 20
85637: PUSH
85638: LD_INT 0
85640: ST_TO_ADDR
// uc_nation := 0 ;
85641: LD_ADDR_OWVAR 21
85645: PUSH
85646: LD_INT 0
85648: ST_TO_ADDR
// hc_sex := sex_male ;
85649: LD_ADDR_OWVAR 27
85653: PUSH
85654: LD_INT 1
85656: ST_TO_ADDR
// hc_class := class_apeman ;
85657: LD_ADDR_OWVAR 28
85661: PUSH
85662: LD_INT 12
85664: ST_TO_ADDR
// hc_gallery :=  ;
85665: LD_ADDR_OWVAR 33
85669: PUSH
85670: LD_STRING 
85672: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85673: LD_ADDR_OWVAR 35
85677: PUSH
85678: LD_VAR 0 1
85682: NEG
85683: PPUSH
85684: LD_VAR 0 1
85688: PPUSH
85689: CALL_OW 12
85693: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
85694: LD_ADDR_OWVAR 31
85698: PUSH
85699: LD_INT 0
85701: PPUSH
85702: LD_INT 3
85704: PPUSH
85705: CALL_OW 12
85709: PUSH
85710: LD_INT 0
85712: PPUSH
85713: LD_INT 3
85715: PPUSH
85716: CALL_OW 12
85720: PUSH
85721: LD_INT 0
85723: PUSH
85724: LD_INT 0
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: ST_TO_ADDR
// end ;
85733: LD_VAR 0 2
85737: RET
// export function PrepareTiger ( agressivity ) ; begin
85738: LD_INT 0
85740: PPUSH
// uc_side := 0 ;
85741: LD_ADDR_OWVAR 20
85745: PUSH
85746: LD_INT 0
85748: ST_TO_ADDR
// uc_nation := 0 ;
85749: LD_ADDR_OWVAR 21
85753: PUSH
85754: LD_INT 0
85756: ST_TO_ADDR
// hc_class := class_tiger ;
85757: LD_ADDR_OWVAR 28
85761: PUSH
85762: LD_INT 14
85764: ST_TO_ADDR
// hc_gallery :=  ;
85765: LD_ADDR_OWVAR 33
85769: PUSH
85770: LD_STRING 
85772: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
85773: LD_ADDR_OWVAR 35
85777: PUSH
85778: LD_VAR 0 1
85782: NEG
85783: PPUSH
85784: LD_VAR 0 1
85788: PPUSH
85789: CALL_OW 12
85793: ST_TO_ADDR
// end ;
85794: LD_VAR 0 2
85798: RET
// export function PrepareEnchidna ( ) ; begin
85799: LD_INT 0
85801: PPUSH
// uc_side := 0 ;
85802: LD_ADDR_OWVAR 20
85806: PUSH
85807: LD_INT 0
85809: ST_TO_ADDR
// uc_nation := 0 ;
85810: LD_ADDR_OWVAR 21
85814: PUSH
85815: LD_INT 0
85817: ST_TO_ADDR
// hc_class := class_baggie ;
85818: LD_ADDR_OWVAR 28
85822: PUSH
85823: LD_INT 13
85825: ST_TO_ADDR
// hc_gallery :=  ;
85826: LD_ADDR_OWVAR 33
85830: PUSH
85831: LD_STRING 
85833: ST_TO_ADDR
// end ;
85834: LD_VAR 0 1
85838: RET
// export function PrepareFrog ( ) ; begin
85839: LD_INT 0
85841: PPUSH
// uc_side := 0 ;
85842: LD_ADDR_OWVAR 20
85846: PUSH
85847: LD_INT 0
85849: ST_TO_ADDR
// uc_nation := 0 ;
85850: LD_ADDR_OWVAR 21
85854: PUSH
85855: LD_INT 0
85857: ST_TO_ADDR
// hc_class := class_frog ;
85858: LD_ADDR_OWVAR 28
85862: PUSH
85863: LD_INT 19
85865: ST_TO_ADDR
// hc_gallery :=  ;
85866: LD_ADDR_OWVAR 33
85870: PUSH
85871: LD_STRING 
85873: ST_TO_ADDR
// end ;
85874: LD_VAR 0 1
85878: RET
// export function PrepareFish ( ) ; begin
85879: LD_INT 0
85881: PPUSH
// uc_side := 0 ;
85882: LD_ADDR_OWVAR 20
85886: PUSH
85887: LD_INT 0
85889: ST_TO_ADDR
// uc_nation := 0 ;
85890: LD_ADDR_OWVAR 21
85894: PUSH
85895: LD_INT 0
85897: ST_TO_ADDR
// hc_class := class_fish ;
85898: LD_ADDR_OWVAR 28
85902: PUSH
85903: LD_INT 20
85905: ST_TO_ADDR
// hc_gallery :=  ;
85906: LD_ADDR_OWVAR 33
85910: PUSH
85911: LD_STRING 
85913: ST_TO_ADDR
// end ;
85914: LD_VAR 0 1
85918: RET
// export function PrepareBird ( ) ; begin
85919: LD_INT 0
85921: PPUSH
// uc_side := 0 ;
85922: LD_ADDR_OWVAR 20
85926: PUSH
85927: LD_INT 0
85929: ST_TO_ADDR
// uc_nation := 0 ;
85930: LD_ADDR_OWVAR 21
85934: PUSH
85935: LD_INT 0
85937: ST_TO_ADDR
// hc_class := class_phororhacos ;
85938: LD_ADDR_OWVAR 28
85942: PUSH
85943: LD_INT 18
85945: ST_TO_ADDR
// hc_gallery :=  ;
85946: LD_ADDR_OWVAR 33
85950: PUSH
85951: LD_STRING 
85953: ST_TO_ADDR
// end ;
85954: LD_VAR 0 1
85958: RET
// export function PrepareHorse ( ) ; begin
85959: LD_INT 0
85961: PPUSH
// uc_side := 0 ;
85962: LD_ADDR_OWVAR 20
85966: PUSH
85967: LD_INT 0
85969: ST_TO_ADDR
// uc_nation := 0 ;
85970: LD_ADDR_OWVAR 21
85974: PUSH
85975: LD_INT 0
85977: ST_TO_ADDR
// hc_class := class_horse ;
85978: LD_ADDR_OWVAR 28
85982: PUSH
85983: LD_INT 21
85985: ST_TO_ADDR
// hc_gallery :=  ;
85986: LD_ADDR_OWVAR 33
85990: PUSH
85991: LD_STRING 
85993: ST_TO_ADDR
// end ;
85994: LD_VAR 0 1
85998: RET
// export function PrepareMastodont ( ) ; begin
85999: LD_INT 0
86001: PPUSH
// uc_side := 0 ;
86002: LD_ADDR_OWVAR 20
86006: PUSH
86007: LD_INT 0
86009: ST_TO_ADDR
// uc_nation := 0 ;
86010: LD_ADDR_OWVAR 21
86014: PUSH
86015: LD_INT 0
86017: ST_TO_ADDR
// vc_chassis := class_mastodont ;
86018: LD_ADDR_OWVAR 37
86022: PUSH
86023: LD_INT 31
86025: ST_TO_ADDR
// vc_control := control_rider ;
86026: LD_ADDR_OWVAR 38
86030: PUSH
86031: LD_INT 4
86033: ST_TO_ADDR
// end ;
86034: LD_VAR 0 1
86038: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
86039: LD_INT 0
86041: PPUSH
86042: PPUSH
86043: PPUSH
// uc_side = 0 ;
86044: LD_ADDR_OWVAR 20
86048: PUSH
86049: LD_INT 0
86051: ST_TO_ADDR
// uc_nation = 0 ;
86052: LD_ADDR_OWVAR 21
86056: PUSH
86057: LD_INT 0
86059: ST_TO_ADDR
// InitHc_All ( ) ;
86060: CALL_OW 584
// InitVc ;
86064: CALL_OW 20
// if mastodonts then
86068: LD_VAR 0 6
86072: IFFALSE 86139
// for i = 1 to mastodonts do
86074: LD_ADDR_VAR 0 11
86078: PUSH
86079: DOUBLE
86080: LD_INT 1
86082: DEC
86083: ST_TO_ADDR
86084: LD_VAR 0 6
86088: PUSH
86089: FOR_TO
86090: IFFALSE 86137
// begin vc_chassis := 31 ;
86092: LD_ADDR_OWVAR 37
86096: PUSH
86097: LD_INT 31
86099: ST_TO_ADDR
// vc_control := control_rider ;
86100: LD_ADDR_OWVAR 38
86104: PUSH
86105: LD_INT 4
86107: ST_TO_ADDR
// animal := CreateVehicle ;
86108: LD_ADDR_VAR 0 12
86112: PUSH
86113: CALL_OW 45
86117: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86118: LD_VAR 0 12
86122: PPUSH
86123: LD_VAR 0 8
86127: PPUSH
86128: LD_INT 0
86130: PPUSH
86131: CALL 88274 0 3
// end ;
86135: GO 86089
86137: POP
86138: POP
// if horses then
86139: LD_VAR 0 5
86143: IFFALSE 86210
// for i = 1 to horses do
86145: LD_ADDR_VAR 0 11
86149: PUSH
86150: DOUBLE
86151: LD_INT 1
86153: DEC
86154: ST_TO_ADDR
86155: LD_VAR 0 5
86159: PUSH
86160: FOR_TO
86161: IFFALSE 86208
// begin hc_class := 21 ;
86163: LD_ADDR_OWVAR 28
86167: PUSH
86168: LD_INT 21
86170: ST_TO_ADDR
// hc_gallery :=  ;
86171: LD_ADDR_OWVAR 33
86175: PUSH
86176: LD_STRING 
86178: ST_TO_ADDR
// animal := CreateHuman ;
86179: LD_ADDR_VAR 0 12
86183: PUSH
86184: CALL_OW 44
86188: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86189: LD_VAR 0 12
86193: PPUSH
86194: LD_VAR 0 8
86198: PPUSH
86199: LD_INT 0
86201: PPUSH
86202: CALL 88274 0 3
// end ;
86206: GO 86160
86208: POP
86209: POP
// if birds then
86210: LD_VAR 0 1
86214: IFFALSE 86281
// for i = 1 to birds do
86216: LD_ADDR_VAR 0 11
86220: PUSH
86221: DOUBLE
86222: LD_INT 1
86224: DEC
86225: ST_TO_ADDR
86226: LD_VAR 0 1
86230: PUSH
86231: FOR_TO
86232: IFFALSE 86279
// begin hc_class = 18 ;
86234: LD_ADDR_OWVAR 28
86238: PUSH
86239: LD_INT 18
86241: ST_TO_ADDR
// hc_gallery =  ;
86242: LD_ADDR_OWVAR 33
86246: PUSH
86247: LD_STRING 
86249: ST_TO_ADDR
// animal := CreateHuman ;
86250: LD_ADDR_VAR 0 12
86254: PUSH
86255: CALL_OW 44
86259: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86260: LD_VAR 0 12
86264: PPUSH
86265: LD_VAR 0 8
86269: PPUSH
86270: LD_INT 0
86272: PPUSH
86273: CALL 88274 0 3
// end ;
86277: GO 86231
86279: POP
86280: POP
// if tigers then
86281: LD_VAR 0 2
86285: IFFALSE 86369
// for i = 1 to tigers do
86287: LD_ADDR_VAR 0 11
86291: PUSH
86292: DOUBLE
86293: LD_INT 1
86295: DEC
86296: ST_TO_ADDR
86297: LD_VAR 0 2
86301: PUSH
86302: FOR_TO
86303: IFFALSE 86367
// begin hc_class = class_tiger ;
86305: LD_ADDR_OWVAR 28
86309: PUSH
86310: LD_INT 14
86312: ST_TO_ADDR
// hc_gallery =  ;
86313: LD_ADDR_OWVAR 33
86317: PUSH
86318: LD_STRING 
86320: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
86321: LD_ADDR_OWVAR 35
86325: PUSH
86326: LD_INT 7
86328: NEG
86329: PPUSH
86330: LD_INT 7
86332: PPUSH
86333: CALL_OW 12
86337: ST_TO_ADDR
// animal := CreateHuman ;
86338: LD_ADDR_VAR 0 12
86342: PUSH
86343: CALL_OW 44
86347: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86348: LD_VAR 0 12
86352: PPUSH
86353: LD_VAR 0 8
86357: PPUSH
86358: LD_INT 0
86360: PPUSH
86361: CALL 88274 0 3
// end ;
86365: GO 86302
86367: POP
86368: POP
// if apemans then
86369: LD_VAR 0 3
86373: IFFALSE 86496
// for i = 1 to apemans do
86375: LD_ADDR_VAR 0 11
86379: PUSH
86380: DOUBLE
86381: LD_INT 1
86383: DEC
86384: ST_TO_ADDR
86385: LD_VAR 0 3
86389: PUSH
86390: FOR_TO
86391: IFFALSE 86494
// begin hc_class = class_apeman ;
86393: LD_ADDR_OWVAR 28
86397: PUSH
86398: LD_INT 12
86400: ST_TO_ADDR
// hc_gallery =  ;
86401: LD_ADDR_OWVAR 33
86405: PUSH
86406: LD_STRING 
86408: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
86409: LD_ADDR_OWVAR 35
86413: PUSH
86414: LD_INT 2
86416: NEG
86417: PPUSH
86418: LD_INT 2
86420: PPUSH
86421: CALL_OW 12
86425: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
86426: LD_ADDR_OWVAR 31
86430: PUSH
86431: LD_INT 1
86433: PPUSH
86434: LD_INT 3
86436: PPUSH
86437: CALL_OW 12
86441: PUSH
86442: LD_INT 1
86444: PPUSH
86445: LD_INT 3
86447: PPUSH
86448: CALL_OW 12
86452: PUSH
86453: LD_INT 0
86455: PUSH
86456: LD_INT 0
86458: PUSH
86459: EMPTY
86460: LIST
86461: LIST
86462: LIST
86463: LIST
86464: ST_TO_ADDR
// animal := CreateHuman ;
86465: LD_ADDR_VAR 0 12
86469: PUSH
86470: CALL_OW 44
86474: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86475: LD_VAR 0 12
86479: PPUSH
86480: LD_VAR 0 8
86484: PPUSH
86485: LD_INT 0
86487: PPUSH
86488: CALL 88274 0 3
// end ;
86492: GO 86390
86494: POP
86495: POP
// if enchidnas then
86496: LD_VAR 0 4
86500: IFFALSE 86567
// for i = 1 to enchidnas do
86502: LD_ADDR_VAR 0 11
86506: PUSH
86507: DOUBLE
86508: LD_INT 1
86510: DEC
86511: ST_TO_ADDR
86512: LD_VAR 0 4
86516: PUSH
86517: FOR_TO
86518: IFFALSE 86565
// begin hc_class = 13 ;
86520: LD_ADDR_OWVAR 28
86524: PUSH
86525: LD_INT 13
86527: ST_TO_ADDR
// hc_gallery =  ;
86528: LD_ADDR_OWVAR 33
86532: PUSH
86533: LD_STRING 
86535: ST_TO_ADDR
// animal := CreateHuman ;
86536: LD_ADDR_VAR 0 12
86540: PUSH
86541: CALL_OW 44
86545: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
86546: LD_VAR 0 12
86550: PPUSH
86551: LD_VAR 0 8
86555: PPUSH
86556: LD_INT 0
86558: PPUSH
86559: CALL 88274 0 3
// end ;
86563: GO 86517
86565: POP
86566: POP
// if fishes then
86567: LD_VAR 0 7
86571: IFFALSE 86638
// for i = 1 to fishes do
86573: LD_ADDR_VAR 0 11
86577: PUSH
86578: DOUBLE
86579: LD_INT 1
86581: DEC
86582: ST_TO_ADDR
86583: LD_VAR 0 7
86587: PUSH
86588: FOR_TO
86589: IFFALSE 86636
// begin hc_class = 20 ;
86591: LD_ADDR_OWVAR 28
86595: PUSH
86596: LD_INT 20
86598: ST_TO_ADDR
// hc_gallery =  ;
86599: LD_ADDR_OWVAR 33
86603: PUSH
86604: LD_STRING 
86606: ST_TO_ADDR
// animal := CreateHuman ;
86607: LD_ADDR_VAR 0 12
86611: PUSH
86612: CALL_OW 44
86616: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86617: LD_VAR 0 12
86621: PPUSH
86622: LD_VAR 0 9
86626: PPUSH
86627: LD_INT 0
86629: PPUSH
86630: CALL 88274 0 3
// end ;
86634: GO 86588
86636: POP
86637: POP
// end ;
86638: LD_VAR 0 10
86642: RET
// export function WantHeal ( sci , unit ) ; begin
86643: LD_INT 0
86645: PPUSH
// if GetTaskList ( sci ) > 0 then
86646: LD_VAR 0 1
86650: PPUSH
86651: CALL_OW 437
86655: PUSH
86656: LD_INT 0
86658: GREATER
86659: IFFALSE 86729
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86661: LD_VAR 0 1
86665: PPUSH
86666: CALL_OW 437
86670: PUSH
86671: LD_INT 1
86673: ARRAY
86674: PUSH
86675: LD_INT 1
86677: ARRAY
86678: PUSH
86679: LD_STRING l
86681: EQUAL
86682: PUSH
86683: LD_VAR 0 1
86687: PPUSH
86688: CALL_OW 437
86692: PUSH
86693: LD_INT 1
86695: ARRAY
86696: PUSH
86697: LD_INT 4
86699: ARRAY
86700: PUSH
86701: LD_VAR 0 2
86705: EQUAL
86706: AND
86707: IFFALSE 86719
// result := true else
86709: LD_ADDR_VAR 0 3
86713: PUSH
86714: LD_INT 1
86716: ST_TO_ADDR
86717: GO 86727
// result := false ;
86719: LD_ADDR_VAR 0 3
86723: PUSH
86724: LD_INT 0
86726: ST_TO_ADDR
// end else
86727: GO 86737
// result := false ;
86729: LD_ADDR_VAR 0 3
86733: PUSH
86734: LD_INT 0
86736: ST_TO_ADDR
// end ;
86737: LD_VAR 0 3
86741: RET
// export function HealTarget ( sci ) ; begin
86742: LD_INT 0
86744: PPUSH
// if not sci then
86745: LD_VAR 0 1
86749: NOT
86750: IFFALSE 86754
// exit ;
86752: GO 86819
// result := 0 ;
86754: LD_ADDR_VAR 0 2
86758: PUSH
86759: LD_INT 0
86761: ST_TO_ADDR
// if GetTaskList ( sci ) then
86762: LD_VAR 0 1
86766: PPUSH
86767: CALL_OW 437
86771: IFFALSE 86819
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86773: LD_VAR 0 1
86777: PPUSH
86778: CALL_OW 437
86782: PUSH
86783: LD_INT 1
86785: ARRAY
86786: PUSH
86787: LD_INT 1
86789: ARRAY
86790: PUSH
86791: LD_STRING l
86793: EQUAL
86794: IFFALSE 86819
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86796: LD_ADDR_VAR 0 2
86800: PUSH
86801: LD_VAR 0 1
86805: PPUSH
86806: CALL_OW 437
86810: PUSH
86811: LD_INT 1
86813: ARRAY
86814: PUSH
86815: LD_INT 4
86817: ARRAY
86818: ST_TO_ADDR
// end ;
86819: LD_VAR 0 2
86823: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86824: LD_INT 0
86826: PPUSH
86827: PPUSH
86828: PPUSH
86829: PPUSH
// if not base_units then
86830: LD_VAR 0 1
86834: NOT
86835: IFFALSE 86839
// exit ;
86837: GO 86926
// result := false ;
86839: LD_ADDR_VAR 0 2
86843: PUSH
86844: LD_INT 0
86846: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86847: LD_ADDR_VAR 0 5
86851: PUSH
86852: LD_VAR 0 1
86856: PPUSH
86857: LD_INT 21
86859: PUSH
86860: LD_INT 3
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PPUSH
86867: CALL_OW 72
86871: ST_TO_ADDR
// if not tmp then
86872: LD_VAR 0 5
86876: NOT
86877: IFFALSE 86881
// exit ;
86879: GO 86926
// for i in tmp do
86881: LD_ADDR_VAR 0 3
86885: PUSH
86886: LD_VAR 0 5
86890: PUSH
86891: FOR_IN
86892: IFFALSE 86924
// begin result := EnemyInRange ( i , 22 ) ;
86894: LD_ADDR_VAR 0 2
86898: PUSH
86899: LD_VAR 0 3
86903: PPUSH
86904: LD_INT 22
86906: PPUSH
86907: CALL 84539 0 2
86911: ST_TO_ADDR
// if result then
86912: LD_VAR 0 2
86916: IFFALSE 86922
// exit ;
86918: POP
86919: POP
86920: GO 86926
// end ;
86922: GO 86891
86924: POP
86925: POP
// end ;
86926: LD_VAR 0 2
86930: RET
// export function FilterByTag ( units , tag ) ; begin
86931: LD_INT 0
86933: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
86934: LD_ADDR_VAR 0 3
86938: PUSH
86939: LD_VAR 0 1
86943: PPUSH
86944: LD_INT 120
86946: PUSH
86947: LD_VAR 0 2
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PPUSH
86956: CALL_OW 72
86960: ST_TO_ADDR
// end ;
86961: LD_VAR 0 3
86965: RET
// export function IsDriver ( un ) ; begin
86966: LD_INT 0
86968: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
86969: LD_ADDR_VAR 0 2
86973: PUSH
86974: LD_VAR 0 1
86978: PUSH
86979: LD_INT 55
86981: PUSH
86982: EMPTY
86983: LIST
86984: PPUSH
86985: CALL_OW 69
86989: IN
86990: ST_TO_ADDR
// end ;
86991: LD_VAR 0 2
86995: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
86996: LD_INT 0
86998: PPUSH
86999: PPUSH
// list := [ ] ;
87000: LD_ADDR_VAR 0 5
87004: PUSH
87005: EMPTY
87006: ST_TO_ADDR
// case d of 0 :
87007: LD_VAR 0 3
87011: PUSH
87012: LD_INT 0
87014: DOUBLE
87015: EQUAL
87016: IFTRUE 87020
87018: GO 87153
87020: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
87021: LD_ADDR_VAR 0 5
87025: PUSH
87026: LD_VAR 0 1
87030: PUSH
87031: LD_INT 4
87033: MINUS
87034: PUSH
87035: LD_VAR 0 2
87039: PUSH
87040: LD_INT 4
87042: MINUS
87043: PUSH
87044: LD_INT 2
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: LIST
87051: PUSH
87052: LD_VAR 0 1
87056: PUSH
87057: LD_INT 3
87059: MINUS
87060: PUSH
87061: LD_VAR 0 2
87065: PUSH
87066: LD_INT 1
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: LIST
87073: PUSH
87074: LD_VAR 0 1
87078: PUSH
87079: LD_INT 4
87081: PLUS
87082: PUSH
87083: LD_VAR 0 2
87087: PUSH
87088: LD_INT 4
87090: PUSH
87091: EMPTY
87092: LIST
87093: LIST
87094: LIST
87095: PUSH
87096: LD_VAR 0 1
87100: PUSH
87101: LD_INT 3
87103: PLUS
87104: PUSH
87105: LD_VAR 0 2
87109: PUSH
87110: LD_INT 3
87112: PLUS
87113: PUSH
87114: LD_INT 5
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: LIST
87121: PUSH
87122: LD_VAR 0 1
87126: PUSH
87127: LD_VAR 0 2
87131: PUSH
87132: LD_INT 4
87134: PLUS
87135: PUSH
87136: LD_INT 0
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: LIST
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: LIST
87150: ST_TO_ADDR
// end ; 1 :
87151: GO 87851
87153: LD_INT 1
87155: DOUBLE
87156: EQUAL
87157: IFTRUE 87161
87159: GO 87294
87161: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
87162: LD_ADDR_VAR 0 5
87166: PUSH
87167: LD_VAR 0 1
87171: PUSH
87172: LD_VAR 0 2
87176: PUSH
87177: LD_INT 4
87179: MINUS
87180: PUSH
87181: LD_INT 3
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: LIST
87188: PUSH
87189: LD_VAR 0 1
87193: PUSH
87194: LD_INT 3
87196: MINUS
87197: PUSH
87198: LD_VAR 0 2
87202: PUSH
87203: LD_INT 3
87205: MINUS
87206: PUSH
87207: LD_INT 2
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: LIST
87214: PUSH
87215: LD_VAR 0 1
87219: PUSH
87220: LD_INT 4
87222: MINUS
87223: PUSH
87224: LD_VAR 0 2
87228: PUSH
87229: LD_INT 1
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: LIST
87236: PUSH
87237: LD_VAR 0 1
87241: PUSH
87242: LD_VAR 0 2
87246: PUSH
87247: LD_INT 3
87249: PLUS
87250: PUSH
87251: LD_INT 0
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: LIST
87258: PUSH
87259: LD_VAR 0 1
87263: PUSH
87264: LD_INT 4
87266: PLUS
87267: PUSH
87268: LD_VAR 0 2
87272: PUSH
87273: LD_INT 4
87275: PLUS
87276: PUSH
87277: LD_INT 5
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: LIST
87284: PUSH
87285: EMPTY
87286: LIST
87287: LIST
87288: LIST
87289: LIST
87290: LIST
87291: ST_TO_ADDR
// end ; 2 :
87292: GO 87851
87294: LD_INT 2
87296: DOUBLE
87297: EQUAL
87298: IFTRUE 87302
87300: GO 87431
87302: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
87303: LD_ADDR_VAR 0 5
87307: PUSH
87308: LD_VAR 0 1
87312: PUSH
87313: LD_VAR 0 2
87317: PUSH
87318: LD_INT 3
87320: MINUS
87321: PUSH
87322: LD_INT 3
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: LIST
87329: PUSH
87330: LD_VAR 0 1
87334: PUSH
87335: LD_INT 4
87337: PLUS
87338: PUSH
87339: LD_VAR 0 2
87343: PUSH
87344: LD_INT 4
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: LIST
87351: PUSH
87352: LD_VAR 0 1
87356: PUSH
87357: LD_VAR 0 2
87361: PUSH
87362: LD_INT 4
87364: PLUS
87365: PUSH
87366: LD_INT 0
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: LIST
87373: PUSH
87374: LD_VAR 0 1
87378: PUSH
87379: LD_INT 3
87381: MINUS
87382: PUSH
87383: LD_VAR 0 2
87387: PUSH
87388: LD_INT 1
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: LIST
87395: PUSH
87396: LD_VAR 0 1
87400: PUSH
87401: LD_INT 4
87403: MINUS
87404: PUSH
87405: LD_VAR 0 2
87409: PUSH
87410: LD_INT 4
87412: MINUS
87413: PUSH
87414: LD_INT 2
87416: PUSH
87417: EMPTY
87418: LIST
87419: LIST
87420: LIST
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: LIST
87428: ST_TO_ADDR
// end ; 3 :
87429: GO 87851
87431: LD_INT 3
87433: DOUBLE
87434: EQUAL
87435: IFTRUE 87439
87437: GO 87572
87439: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
87440: LD_ADDR_VAR 0 5
87444: PUSH
87445: LD_VAR 0 1
87449: PUSH
87450: LD_INT 3
87452: PLUS
87453: PUSH
87454: LD_VAR 0 2
87458: PUSH
87459: LD_INT 4
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: LIST
87466: PUSH
87467: LD_VAR 0 1
87471: PUSH
87472: LD_INT 4
87474: PLUS
87475: PUSH
87476: LD_VAR 0 2
87480: PUSH
87481: LD_INT 4
87483: PLUS
87484: PUSH
87485: LD_INT 5
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: LIST
87492: PUSH
87493: LD_VAR 0 1
87497: PUSH
87498: LD_INT 4
87500: MINUS
87501: PUSH
87502: LD_VAR 0 2
87506: PUSH
87507: LD_INT 1
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: LIST
87514: PUSH
87515: LD_VAR 0 1
87519: PUSH
87520: LD_VAR 0 2
87524: PUSH
87525: LD_INT 4
87527: MINUS
87528: PUSH
87529: LD_INT 3
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: LIST
87536: PUSH
87537: LD_VAR 0 1
87541: PUSH
87542: LD_INT 3
87544: MINUS
87545: PUSH
87546: LD_VAR 0 2
87550: PUSH
87551: LD_INT 3
87553: MINUS
87554: PUSH
87555: LD_INT 2
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: LIST
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: ST_TO_ADDR
// end ; 4 :
87570: GO 87851
87572: LD_INT 4
87574: DOUBLE
87575: EQUAL
87576: IFTRUE 87580
87578: GO 87713
87580: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
87581: LD_ADDR_VAR 0 5
87585: PUSH
87586: LD_VAR 0 1
87590: PUSH
87591: LD_VAR 0 2
87595: PUSH
87596: LD_INT 4
87598: PLUS
87599: PUSH
87600: LD_INT 0
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: LIST
87607: PUSH
87608: LD_VAR 0 1
87612: PUSH
87613: LD_INT 3
87615: PLUS
87616: PUSH
87617: LD_VAR 0 2
87621: PUSH
87622: LD_INT 3
87624: PLUS
87625: PUSH
87626: LD_INT 5
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: LIST
87633: PUSH
87634: LD_VAR 0 1
87638: PUSH
87639: LD_INT 4
87641: PLUS
87642: PUSH
87643: LD_VAR 0 2
87647: PUSH
87648: LD_INT 4
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: LIST
87655: PUSH
87656: LD_VAR 0 1
87660: PUSH
87661: LD_VAR 0 2
87665: PUSH
87666: LD_INT 3
87668: MINUS
87669: PUSH
87670: LD_INT 3
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: LIST
87677: PUSH
87678: LD_VAR 0 1
87682: PUSH
87683: LD_INT 4
87685: MINUS
87686: PUSH
87687: LD_VAR 0 2
87691: PUSH
87692: LD_INT 4
87694: MINUS
87695: PUSH
87696: LD_INT 2
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: LIST
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: ST_TO_ADDR
// end ; 5 :
87711: GO 87851
87713: LD_INT 5
87715: DOUBLE
87716: EQUAL
87717: IFTRUE 87721
87719: GO 87850
87721: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87722: LD_ADDR_VAR 0 5
87726: PUSH
87727: LD_VAR 0 1
87731: PUSH
87732: LD_INT 4
87734: MINUS
87735: PUSH
87736: LD_VAR 0 2
87740: PUSH
87741: LD_INT 1
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: LIST
87748: PUSH
87749: LD_VAR 0 1
87753: PUSH
87754: LD_VAR 0 2
87758: PUSH
87759: LD_INT 4
87761: MINUS
87762: PUSH
87763: LD_INT 3
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: LIST
87770: PUSH
87771: LD_VAR 0 1
87775: PUSH
87776: LD_INT 4
87778: PLUS
87779: PUSH
87780: LD_VAR 0 2
87784: PUSH
87785: LD_INT 4
87787: PLUS
87788: PUSH
87789: LD_INT 5
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: LIST
87796: PUSH
87797: LD_VAR 0 1
87801: PUSH
87802: LD_INT 3
87804: PLUS
87805: PUSH
87806: LD_VAR 0 2
87810: PUSH
87811: LD_INT 4
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: LIST
87818: PUSH
87819: LD_VAR 0 1
87823: PUSH
87824: LD_VAR 0 2
87828: PUSH
87829: LD_INT 3
87831: PLUS
87832: PUSH
87833: LD_INT 0
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: LIST
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: ST_TO_ADDR
// end ; end ;
87848: GO 87851
87850: POP
// result := list ;
87851: LD_ADDR_VAR 0 4
87855: PUSH
87856: LD_VAR 0 5
87860: ST_TO_ADDR
// end ;
87861: LD_VAR 0 4
87865: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87866: LD_INT 0
87868: PPUSH
87869: PPUSH
87870: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87871: LD_VAR 0 1
87875: NOT
87876: PUSH
87877: LD_VAR 0 2
87881: PUSH
87882: LD_INT 1
87884: PUSH
87885: LD_INT 2
87887: PUSH
87888: LD_INT 3
87890: PUSH
87891: LD_INT 4
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: IN
87900: NOT
87901: OR
87902: IFFALSE 87906
// exit ;
87904: GO 87998
// tmp := [ ] ;
87906: LD_ADDR_VAR 0 5
87910: PUSH
87911: EMPTY
87912: ST_TO_ADDR
// for i in units do
87913: LD_ADDR_VAR 0 4
87917: PUSH
87918: LD_VAR 0 1
87922: PUSH
87923: FOR_IN
87924: IFFALSE 87967
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
87926: LD_ADDR_VAR 0 5
87930: PUSH
87931: LD_VAR 0 5
87935: PPUSH
87936: LD_VAR 0 5
87940: PUSH
87941: LD_INT 1
87943: PLUS
87944: PPUSH
87945: LD_VAR 0 4
87949: PPUSH
87950: LD_VAR 0 2
87954: PPUSH
87955: CALL_OW 259
87959: PPUSH
87960: CALL_OW 2
87964: ST_TO_ADDR
87965: GO 87923
87967: POP
87968: POP
// if not tmp then
87969: LD_VAR 0 5
87973: NOT
87974: IFFALSE 87978
// exit ;
87976: GO 87998
// result := SortListByListDesc ( units , tmp ) ;
87978: LD_ADDR_VAR 0 3
87982: PUSH
87983: LD_VAR 0 1
87987: PPUSH
87988: LD_VAR 0 5
87992: PPUSH
87993: CALL_OW 77
87997: ST_TO_ADDR
// end ;
87998: LD_VAR 0 3
88002: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
88003: LD_INT 0
88005: PPUSH
88006: PPUSH
88007: PPUSH
// result := false ;
88008: LD_ADDR_VAR 0 3
88012: PUSH
88013: LD_INT 0
88015: ST_TO_ADDR
// x := GetX ( building ) ;
88016: LD_ADDR_VAR 0 4
88020: PUSH
88021: LD_VAR 0 2
88025: PPUSH
88026: CALL_OW 250
88030: ST_TO_ADDR
// y := GetY ( building ) ;
88031: LD_ADDR_VAR 0 5
88035: PUSH
88036: LD_VAR 0 2
88040: PPUSH
88041: CALL_OW 251
88045: ST_TO_ADDR
// if not building or not x or not y then
88046: LD_VAR 0 2
88050: NOT
88051: PUSH
88052: LD_VAR 0 4
88056: NOT
88057: OR
88058: PUSH
88059: LD_VAR 0 5
88063: NOT
88064: OR
88065: IFFALSE 88069
// exit ;
88067: GO 88161
// if GetTaskList ( unit ) then
88069: LD_VAR 0 1
88073: PPUSH
88074: CALL_OW 437
88078: IFFALSE 88161
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88080: LD_STRING e
88082: PUSH
88083: LD_VAR 0 1
88087: PPUSH
88088: CALL_OW 437
88092: PUSH
88093: LD_INT 1
88095: ARRAY
88096: PUSH
88097: LD_INT 1
88099: ARRAY
88100: EQUAL
88101: PUSH
88102: LD_VAR 0 4
88106: PUSH
88107: LD_VAR 0 1
88111: PPUSH
88112: CALL_OW 437
88116: PUSH
88117: LD_INT 1
88119: ARRAY
88120: PUSH
88121: LD_INT 2
88123: ARRAY
88124: EQUAL
88125: AND
88126: PUSH
88127: LD_VAR 0 5
88131: PUSH
88132: LD_VAR 0 1
88136: PPUSH
88137: CALL_OW 437
88141: PUSH
88142: LD_INT 1
88144: ARRAY
88145: PUSH
88146: LD_INT 3
88148: ARRAY
88149: EQUAL
88150: AND
88151: IFFALSE 88161
// result := true end ;
88153: LD_ADDR_VAR 0 3
88157: PUSH
88158: LD_INT 1
88160: ST_TO_ADDR
// end ;
88161: LD_VAR 0 3
88165: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
88166: LD_INT 0
88168: PPUSH
// result := false ;
88169: LD_ADDR_VAR 0 4
88173: PUSH
88174: LD_INT 0
88176: ST_TO_ADDR
// if GetTaskList ( unit ) then
88177: LD_VAR 0 1
88181: PPUSH
88182: CALL_OW 437
88186: IFFALSE 88269
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
88188: LD_STRING M
88190: PUSH
88191: LD_VAR 0 1
88195: PPUSH
88196: CALL_OW 437
88200: PUSH
88201: LD_INT 1
88203: ARRAY
88204: PUSH
88205: LD_INT 1
88207: ARRAY
88208: EQUAL
88209: PUSH
88210: LD_VAR 0 2
88214: PUSH
88215: LD_VAR 0 1
88219: PPUSH
88220: CALL_OW 437
88224: PUSH
88225: LD_INT 1
88227: ARRAY
88228: PUSH
88229: LD_INT 2
88231: ARRAY
88232: EQUAL
88233: AND
88234: PUSH
88235: LD_VAR 0 3
88239: PUSH
88240: LD_VAR 0 1
88244: PPUSH
88245: CALL_OW 437
88249: PUSH
88250: LD_INT 1
88252: ARRAY
88253: PUSH
88254: LD_INT 3
88256: ARRAY
88257: EQUAL
88258: AND
88259: IFFALSE 88269
// result := true ;
88261: LD_ADDR_VAR 0 4
88265: PUSH
88266: LD_INT 1
88268: ST_TO_ADDR
// end ; end ;
88269: LD_VAR 0 4
88273: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
88274: LD_INT 0
88276: PPUSH
88277: PPUSH
88278: PPUSH
88279: PPUSH
// if not unit or not area then
88280: LD_VAR 0 1
88284: NOT
88285: PUSH
88286: LD_VAR 0 2
88290: NOT
88291: OR
88292: IFFALSE 88296
// exit ;
88294: GO 88460
// tmp := AreaToList ( area , i ) ;
88296: LD_ADDR_VAR 0 6
88300: PUSH
88301: LD_VAR 0 2
88305: PPUSH
88306: LD_VAR 0 5
88310: PPUSH
88311: CALL_OW 517
88315: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
88316: LD_ADDR_VAR 0 5
88320: PUSH
88321: DOUBLE
88322: LD_INT 1
88324: DEC
88325: ST_TO_ADDR
88326: LD_VAR 0 6
88330: PUSH
88331: LD_INT 1
88333: ARRAY
88334: PUSH
88335: FOR_TO
88336: IFFALSE 88458
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
88338: LD_ADDR_VAR 0 7
88342: PUSH
88343: LD_VAR 0 6
88347: PUSH
88348: LD_INT 1
88350: ARRAY
88351: PUSH
88352: LD_VAR 0 5
88356: ARRAY
88357: PUSH
88358: LD_VAR 0 6
88362: PUSH
88363: LD_INT 2
88365: ARRAY
88366: PUSH
88367: LD_VAR 0 5
88371: ARRAY
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
88377: LD_VAR 0 7
88381: PUSH
88382: LD_INT 1
88384: ARRAY
88385: PPUSH
88386: LD_VAR 0 7
88390: PUSH
88391: LD_INT 2
88393: ARRAY
88394: PPUSH
88395: CALL_OW 428
88399: PUSH
88400: LD_INT 0
88402: EQUAL
88403: IFFALSE 88456
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
88405: LD_VAR 0 1
88409: PPUSH
88410: LD_VAR 0 7
88414: PUSH
88415: LD_INT 1
88417: ARRAY
88418: PPUSH
88419: LD_VAR 0 7
88423: PUSH
88424: LD_INT 2
88426: ARRAY
88427: PPUSH
88428: LD_VAR 0 3
88432: PPUSH
88433: CALL_OW 48
// result := IsPlaced ( unit ) ;
88437: LD_ADDR_VAR 0 4
88441: PUSH
88442: LD_VAR 0 1
88446: PPUSH
88447: CALL_OW 305
88451: ST_TO_ADDR
// exit ;
88452: POP
88453: POP
88454: GO 88460
// end ; end ;
88456: GO 88335
88458: POP
88459: POP
// end ;
88460: LD_VAR 0 4
88464: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
88465: LD_INT 0
88467: PPUSH
88468: PPUSH
88469: PPUSH
// if not side or side > 8 then
88470: LD_VAR 0 1
88474: NOT
88475: PUSH
88476: LD_VAR 0 1
88480: PUSH
88481: LD_INT 8
88483: GREATER
88484: OR
88485: IFFALSE 88489
// exit ;
88487: GO 88676
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
88489: LD_ADDR_VAR 0 4
88493: PUSH
88494: LD_INT 22
88496: PUSH
88497: LD_VAR 0 1
88501: PUSH
88502: EMPTY
88503: LIST
88504: LIST
88505: PUSH
88506: LD_INT 21
88508: PUSH
88509: LD_INT 3
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PPUSH
88520: CALL_OW 69
88524: ST_TO_ADDR
// if not tmp then
88525: LD_VAR 0 4
88529: NOT
88530: IFFALSE 88534
// exit ;
88532: GO 88676
// enable_addtolog := true ;
88534: LD_ADDR_OWVAR 81
88538: PUSH
88539: LD_INT 1
88541: ST_TO_ADDR
// AddToLog ( [ ) ;
88542: LD_STRING [
88544: PPUSH
88545: CALL_OW 561
// for i in tmp do
88549: LD_ADDR_VAR 0 3
88553: PUSH
88554: LD_VAR 0 4
88558: PUSH
88559: FOR_IN
88560: IFFALSE 88667
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
88562: LD_STRING [
88564: PUSH
88565: LD_VAR 0 3
88569: PPUSH
88570: CALL_OW 266
88574: STR
88575: PUSH
88576: LD_STRING , 
88578: STR
88579: PUSH
88580: LD_VAR 0 3
88584: PPUSH
88585: CALL_OW 250
88589: STR
88590: PUSH
88591: LD_STRING , 
88593: STR
88594: PUSH
88595: LD_VAR 0 3
88599: PPUSH
88600: CALL_OW 251
88604: STR
88605: PUSH
88606: LD_STRING , 
88608: STR
88609: PUSH
88610: LD_VAR 0 3
88614: PPUSH
88615: CALL_OW 254
88619: STR
88620: PUSH
88621: LD_STRING , 
88623: STR
88624: PUSH
88625: LD_VAR 0 3
88629: PPUSH
88630: LD_INT 1
88632: PPUSH
88633: CALL_OW 268
88637: STR
88638: PUSH
88639: LD_STRING , 
88641: STR
88642: PUSH
88643: LD_VAR 0 3
88647: PPUSH
88648: LD_INT 2
88650: PPUSH
88651: CALL_OW 268
88655: STR
88656: PUSH
88657: LD_STRING ],
88659: STR
88660: PPUSH
88661: CALL_OW 561
// end ;
88665: GO 88559
88667: POP
88668: POP
// AddToLog ( ]; ) ;
88669: LD_STRING ];
88671: PPUSH
88672: CALL_OW 561
// end ;
88676: LD_VAR 0 2
88680: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88681: LD_INT 0
88683: PPUSH
88684: PPUSH
88685: PPUSH
88686: PPUSH
88687: PPUSH
// if not area or not rate or not max then
88688: LD_VAR 0 1
88692: NOT
88693: PUSH
88694: LD_VAR 0 2
88698: NOT
88699: OR
88700: PUSH
88701: LD_VAR 0 4
88705: NOT
88706: OR
88707: IFFALSE 88711
// exit ;
88709: GO 88900
// while 1 do
88711: LD_INT 1
88713: IFFALSE 88900
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88715: LD_ADDR_VAR 0 9
88719: PUSH
88720: LD_VAR 0 1
88724: PPUSH
88725: LD_INT 1
88727: PPUSH
88728: CALL_OW 287
88732: PUSH
88733: LD_INT 10
88735: MUL
88736: ST_TO_ADDR
// r := rate / 10 ;
88737: LD_ADDR_VAR 0 7
88741: PUSH
88742: LD_VAR 0 2
88746: PUSH
88747: LD_INT 10
88749: DIVREAL
88750: ST_TO_ADDR
// time := 1 1$00 ;
88751: LD_ADDR_VAR 0 8
88755: PUSH
88756: LD_INT 2100
88758: ST_TO_ADDR
// if amount < min then
88759: LD_VAR 0 9
88763: PUSH
88764: LD_VAR 0 3
88768: LESS
88769: IFFALSE 88787
// r := r * 2 else
88771: LD_ADDR_VAR 0 7
88775: PUSH
88776: LD_VAR 0 7
88780: PUSH
88781: LD_INT 2
88783: MUL
88784: ST_TO_ADDR
88785: GO 88813
// if amount > max then
88787: LD_VAR 0 9
88791: PUSH
88792: LD_VAR 0 4
88796: GREATER
88797: IFFALSE 88813
// r := r / 2 ;
88799: LD_ADDR_VAR 0 7
88803: PUSH
88804: LD_VAR 0 7
88808: PUSH
88809: LD_INT 2
88811: DIVREAL
88812: ST_TO_ADDR
// time := time / r ;
88813: LD_ADDR_VAR 0 8
88817: PUSH
88818: LD_VAR 0 8
88822: PUSH
88823: LD_VAR 0 7
88827: DIVREAL
88828: ST_TO_ADDR
// if time < 0 then
88829: LD_VAR 0 8
88833: PUSH
88834: LD_INT 0
88836: LESS
88837: IFFALSE 88854
// time := time * - 1 ;
88839: LD_ADDR_VAR 0 8
88843: PUSH
88844: LD_VAR 0 8
88848: PUSH
88849: LD_INT 1
88851: NEG
88852: MUL
88853: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
88854: LD_VAR 0 8
88858: PUSH
88859: LD_INT 35
88861: PPUSH
88862: LD_INT 875
88864: PPUSH
88865: CALL_OW 12
88869: PLUS
88870: PPUSH
88871: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88875: LD_INT 1
88877: PPUSH
88878: LD_INT 5
88880: PPUSH
88881: CALL_OW 12
88885: PPUSH
88886: LD_VAR 0 1
88890: PPUSH
88891: LD_INT 1
88893: PPUSH
88894: CALL_OW 55
// end ;
88898: GO 88711
// end ;
88900: LD_VAR 0 5
88904: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88905: LD_INT 0
88907: PPUSH
88908: PPUSH
88909: PPUSH
88910: PPUSH
88911: PPUSH
88912: PPUSH
88913: PPUSH
88914: PPUSH
// if not turrets or not factories then
88915: LD_VAR 0 1
88919: NOT
88920: PUSH
88921: LD_VAR 0 2
88925: NOT
88926: OR
88927: IFFALSE 88931
// exit ;
88929: GO 89238
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88931: LD_ADDR_VAR 0 10
88935: PUSH
88936: LD_INT 5
88938: PUSH
88939: LD_INT 6
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 2
88948: PUSH
88949: LD_INT 4
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 3
88958: PUSH
88959: LD_INT 5
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: LIST
88970: PUSH
88971: LD_INT 24
88973: PUSH
88974: LD_INT 25
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 23
88983: PUSH
88984: LD_INT 27
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 42
88997: PUSH
88998: LD_INT 43
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 44
89007: PUSH
89008: LD_INT 46
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 45
89017: PUSH
89018: LD_INT 47
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: LIST
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: LIST
89034: ST_TO_ADDR
// result := [ ] ;
89035: LD_ADDR_VAR 0 3
89039: PUSH
89040: EMPTY
89041: ST_TO_ADDR
// for i in turrets do
89042: LD_ADDR_VAR 0 4
89046: PUSH
89047: LD_VAR 0 1
89051: PUSH
89052: FOR_IN
89053: IFFALSE 89236
// begin nat := GetNation ( i ) ;
89055: LD_ADDR_VAR 0 7
89059: PUSH
89060: LD_VAR 0 4
89064: PPUSH
89065: CALL_OW 248
89069: ST_TO_ADDR
// weapon := 0 ;
89070: LD_ADDR_VAR 0 8
89074: PUSH
89075: LD_INT 0
89077: ST_TO_ADDR
// if not nat then
89078: LD_VAR 0 7
89082: NOT
89083: IFFALSE 89087
// continue ;
89085: GO 89052
// for j in list [ nat ] do
89087: LD_ADDR_VAR 0 5
89091: PUSH
89092: LD_VAR 0 10
89096: PUSH
89097: LD_VAR 0 7
89101: ARRAY
89102: PUSH
89103: FOR_IN
89104: IFFALSE 89145
// if GetBWeapon ( i ) = j [ 1 ] then
89106: LD_VAR 0 4
89110: PPUSH
89111: CALL_OW 269
89115: PUSH
89116: LD_VAR 0 5
89120: PUSH
89121: LD_INT 1
89123: ARRAY
89124: EQUAL
89125: IFFALSE 89143
// begin weapon := j [ 2 ] ;
89127: LD_ADDR_VAR 0 8
89131: PUSH
89132: LD_VAR 0 5
89136: PUSH
89137: LD_INT 2
89139: ARRAY
89140: ST_TO_ADDR
// break ;
89141: GO 89145
// end ;
89143: GO 89103
89145: POP
89146: POP
// if not weapon then
89147: LD_VAR 0 8
89151: NOT
89152: IFFALSE 89156
// continue ;
89154: GO 89052
// for k in factories do
89156: LD_ADDR_VAR 0 6
89160: PUSH
89161: LD_VAR 0 2
89165: PUSH
89166: FOR_IN
89167: IFFALSE 89232
// begin weapons := AvailableWeaponList ( k ) ;
89169: LD_ADDR_VAR 0 9
89173: PUSH
89174: LD_VAR 0 6
89178: PPUSH
89179: CALL_OW 478
89183: ST_TO_ADDR
// if not weapons then
89184: LD_VAR 0 9
89188: NOT
89189: IFFALSE 89193
// continue ;
89191: GO 89166
// if weapon in weapons then
89193: LD_VAR 0 8
89197: PUSH
89198: LD_VAR 0 9
89202: IN
89203: IFFALSE 89230
// begin result := [ i , weapon ] ;
89205: LD_ADDR_VAR 0 3
89209: PUSH
89210: LD_VAR 0 4
89214: PUSH
89215: LD_VAR 0 8
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: ST_TO_ADDR
// exit ;
89224: POP
89225: POP
89226: POP
89227: POP
89228: GO 89238
// end ; end ;
89230: GO 89166
89232: POP
89233: POP
// end ;
89234: GO 89052
89236: POP
89237: POP
// end ;
89238: LD_VAR 0 3
89242: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
89243: LD_INT 0
89245: PPUSH
// if not side or side > 8 then
89246: LD_VAR 0 3
89250: NOT
89251: PUSH
89252: LD_VAR 0 3
89256: PUSH
89257: LD_INT 8
89259: GREATER
89260: OR
89261: IFFALSE 89265
// exit ;
89263: GO 89324
// if not range then
89265: LD_VAR 0 4
89269: NOT
89270: IFFALSE 89281
// range := - 12 ;
89272: LD_ADDR_VAR 0 4
89276: PUSH
89277: LD_INT 12
89279: NEG
89280: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
89281: LD_VAR 0 1
89285: PPUSH
89286: LD_VAR 0 2
89290: PPUSH
89291: LD_VAR 0 3
89295: PPUSH
89296: LD_VAR 0 4
89300: PPUSH
89301: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
89305: LD_VAR 0 1
89309: PPUSH
89310: LD_VAR 0 2
89314: PPUSH
89315: LD_VAR 0 3
89319: PPUSH
89320: CALL_OW 331
// end ;
89324: LD_VAR 0 5
89328: RET
// export function Video ( mode ) ; begin
89329: LD_INT 0
89331: PPUSH
// ingame_video = mode ;
89332: LD_ADDR_OWVAR 52
89336: PUSH
89337: LD_VAR 0 1
89341: ST_TO_ADDR
// interface_hidden = mode ;
89342: LD_ADDR_OWVAR 54
89346: PUSH
89347: LD_VAR 0 1
89351: ST_TO_ADDR
// end ;
89352: LD_VAR 0 2
89356: RET
// export function Join ( array , element ) ; begin
89357: LD_INT 0
89359: PPUSH
// result := Replace ( array , array + 1 , element ) ;
89360: LD_ADDR_VAR 0 3
89364: PUSH
89365: LD_VAR 0 1
89369: PPUSH
89370: LD_VAR 0 1
89374: PUSH
89375: LD_INT 1
89377: PLUS
89378: PPUSH
89379: LD_VAR 0 2
89383: PPUSH
89384: CALL_OW 1
89388: ST_TO_ADDR
// end ;
89389: LD_VAR 0 3
89393: RET
// export function JoinUnion ( array , element ) ; begin
89394: LD_INT 0
89396: PPUSH
// result := array union element ;
89397: LD_ADDR_VAR 0 3
89401: PUSH
89402: LD_VAR 0 1
89406: PUSH
89407: LD_VAR 0 2
89411: UNION
89412: ST_TO_ADDR
// end ;
89413: LD_VAR 0 3
89417: RET
// export function GetBehemoths ( side ) ; begin
89418: LD_INT 0
89420: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
89421: LD_ADDR_VAR 0 2
89425: PUSH
89426: LD_INT 22
89428: PUSH
89429: LD_VAR 0 1
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 31
89440: PUSH
89441: LD_INT 25
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PPUSH
89452: CALL_OW 69
89456: ST_TO_ADDR
// end ;
89457: LD_VAR 0 2
89461: RET
// export function Shuffle ( array ) ; var i , index ; begin
89462: LD_INT 0
89464: PPUSH
89465: PPUSH
89466: PPUSH
// result := [ ] ;
89467: LD_ADDR_VAR 0 2
89471: PUSH
89472: EMPTY
89473: ST_TO_ADDR
// if not array then
89474: LD_VAR 0 1
89478: NOT
89479: IFFALSE 89483
// exit ;
89481: GO 89582
// Randomize ;
89483: CALL_OW 10
// for i = array downto 1 do
89487: LD_ADDR_VAR 0 3
89491: PUSH
89492: DOUBLE
89493: LD_VAR 0 1
89497: INC
89498: ST_TO_ADDR
89499: LD_INT 1
89501: PUSH
89502: FOR_DOWNTO
89503: IFFALSE 89580
// begin index := rand ( 1 , array ) ;
89505: LD_ADDR_VAR 0 4
89509: PUSH
89510: LD_INT 1
89512: PPUSH
89513: LD_VAR 0 1
89517: PPUSH
89518: CALL_OW 12
89522: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
89523: LD_ADDR_VAR 0 2
89527: PUSH
89528: LD_VAR 0 2
89532: PPUSH
89533: LD_VAR 0 2
89537: PUSH
89538: LD_INT 1
89540: PLUS
89541: PPUSH
89542: LD_VAR 0 1
89546: PUSH
89547: LD_VAR 0 4
89551: ARRAY
89552: PPUSH
89553: CALL_OW 2
89557: ST_TO_ADDR
// array := Delete ( array , index ) ;
89558: LD_ADDR_VAR 0 1
89562: PUSH
89563: LD_VAR 0 1
89567: PPUSH
89568: LD_VAR 0 4
89572: PPUSH
89573: CALL_OW 3
89577: ST_TO_ADDR
// end ;
89578: GO 89502
89580: POP
89581: POP
// end ;
89582: LD_VAR 0 2
89586: RET
// export function GetBaseMaterials ( base ) ; begin
89587: LD_INT 0
89589: PPUSH
// result := [ 0 , 0 , 0 ] ;
89590: LD_ADDR_VAR 0 2
89594: PUSH
89595: LD_INT 0
89597: PUSH
89598: LD_INT 0
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: LIST
89608: ST_TO_ADDR
// if not base then
89609: LD_VAR 0 1
89613: NOT
89614: IFFALSE 89618
// exit ;
89616: GO 89667
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89618: LD_ADDR_VAR 0 2
89622: PUSH
89623: LD_VAR 0 1
89627: PPUSH
89628: LD_INT 1
89630: PPUSH
89631: CALL_OW 275
89635: PUSH
89636: LD_VAR 0 1
89640: PPUSH
89641: LD_INT 2
89643: PPUSH
89644: CALL_OW 275
89648: PUSH
89649: LD_VAR 0 1
89653: PPUSH
89654: LD_INT 3
89656: PPUSH
89657: CALL_OW 275
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: LIST
89666: ST_TO_ADDR
// end ;
89667: LD_VAR 0 2
89671: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89672: LD_INT 0
89674: PPUSH
89675: PPUSH
// result := array ;
89676: LD_ADDR_VAR 0 3
89680: PUSH
89681: LD_VAR 0 1
89685: ST_TO_ADDR
// if size >= result then
89686: LD_VAR 0 2
89690: PUSH
89691: LD_VAR 0 3
89695: GREATEREQUAL
89696: IFFALSE 89700
// exit ;
89698: GO 89750
// if size then
89700: LD_VAR 0 2
89704: IFFALSE 89750
// for i := array downto size do
89706: LD_ADDR_VAR 0 4
89710: PUSH
89711: DOUBLE
89712: LD_VAR 0 1
89716: INC
89717: ST_TO_ADDR
89718: LD_VAR 0 2
89722: PUSH
89723: FOR_DOWNTO
89724: IFFALSE 89748
// result := Delete ( result , result ) ;
89726: LD_ADDR_VAR 0 3
89730: PUSH
89731: LD_VAR 0 3
89735: PPUSH
89736: LD_VAR 0 3
89740: PPUSH
89741: CALL_OW 3
89745: ST_TO_ADDR
89746: GO 89723
89748: POP
89749: POP
// end ;
89750: LD_VAR 0 3
89754: RET
// export function ComExit ( unit ) ; var tmp ; begin
89755: LD_INT 0
89757: PPUSH
89758: PPUSH
// if not IsInUnit ( unit ) then
89759: LD_VAR 0 1
89763: PPUSH
89764: CALL_OW 310
89768: NOT
89769: IFFALSE 89773
// exit ;
89771: GO 89833
// tmp := IsInUnit ( unit ) ;
89773: LD_ADDR_VAR 0 3
89777: PUSH
89778: LD_VAR 0 1
89782: PPUSH
89783: CALL_OW 310
89787: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89788: LD_VAR 0 3
89792: PPUSH
89793: CALL_OW 247
89797: PUSH
89798: LD_INT 2
89800: EQUAL
89801: IFFALSE 89814
// ComExitVehicle ( unit ) else
89803: LD_VAR 0 1
89807: PPUSH
89808: CALL_OW 121
89812: GO 89823
// ComExitBuilding ( unit ) ;
89814: LD_VAR 0 1
89818: PPUSH
89819: CALL_OW 122
// result := tmp ;
89823: LD_ADDR_VAR 0 2
89827: PUSH
89828: LD_VAR 0 3
89832: ST_TO_ADDR
// end ;
89833: LD_VAR 0 2
89837: RET
// export function ComExitAll ( units ) ; var i ; begin
89838: LD_INT 0
89840: PPUSH
89841: PPUSH
// if not units then
89842: LD_VAR 0 1
89846: NOT
89847: IFFALSE 89851
// exit ;
89849: GO 89877
// for i in units do
89851: LD_ADDR_VAR 0 3
89855: PUSH
89856: LD_VAR 0 1
89860: PUSH
89861: FOR_IN
89862: IFFALSE 89875
// ComExit ( i ) ;
89864: LD_VAR 0 3
89868: PPUSH
89869: CALL 89755 0 1
89873: GO 89861
89875: POP
89876: POP
// end ;
89877: LD_VAR 0 2
89881: RET
// export function ResetHc ; begin
89882: LD_INT 0
89884: PPUSH
// InitHc ;
89885: CALL_OW 19
// hc_importance := 0 ;
89889: LD_ADDR_OWVAR 32
89893: PUSH
89894: LD_INT 0
89896: ST_TO_ADDR
// end ;
89897: LD_VAR 0 1
89901: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89902: LD_INT 0
89904: PPUSH
89905: PPUSH
89906: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89907: LD_ADDR_VAR 0 6
89911: PUSH
89912: LD_VAR 0 1
89916: PUSH
89917: LD_VAR 0 3
89921: PLUS
89922: PUSH
89923: LD_INT 2
89925: DIV
89926: ST_TO_ADDR
// if _x < 0 then
89927: LD_VAR 0 6
89931: PUSH
89932: LD_INT 0
89934: LESS
89935: IFFALSE 89952
// _x := _x * - 1 ;
89937: LD_ADDR_VAR 0 6
89941: PUSH
89942: LD_VAR 0 6
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: MUL
89951: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
89952: LD_ADDR_VAR 0 7
89956: PUSH
89957: LD_VAR 0 2
89961: PUSH
89962: LD_VAR 0 4
89966: PLUS
89967: PUSH
89968: LD_INT 2
89970: DIV
89971: ST_TO_ADDR
// if _y < 0 then
89972: LD_VAR 0 7
89976: PUSH
89977: LD_INT 0
89979: LESS
89980: IFFALSE 89997
// _y := _y * - 1 ;
89982: LD_ADDR_VAR 0 7
89986: PUSH
89987: LD_VAR 0 7
89991: PUSH
89992: LD_INT 1
89994: NEG
89995: MUL
89996: ST_TO_ADDR
// result := [ _x , _y ] ;
89997: LD_ADDR_VAR 0 5
90001: PUSH
90002: LD_VAR 0 6
90006: PUSH
90007: LD_VAR 0 7
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: ST_TO_ADDR
// end ;
90016: LD_VAR 0 5
90020: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
90021: LD_INT 0
90023: PPUSH
90024: PPUSH
90025: PPUSH
90026: PPUSH
// task := GetTaskList ( unit ) ;
90027: LD_ADDR_VAR 0 7
90031: PUSH
90032: LD_VAR 0 1
90036: PPUSH
90037: CALL_OW 437
90041: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
90042: LD_VAR 0 7
90046: NOT
90047: PUSH
90048: LD_VAR 0 1
90052: PPUSH
90053: LD_VAR 0 2
90057: PPUSH
90058: CALL_OW 308
90062: NOT
90063: AND
90064: IFFALSE 90068
// exit ;
90066: GO 90186
// if IsInArea ( unit , area ) then
90068: LD_VAR 0 1
90072: PPUSH
90073: LD_VAR 0 2
90077: PPUSH
90078: CALL_OW 308
90082: IFFALSE 90100
// begin ComMoveToArea ( unit , goAway ) ;
90084: LD_VAR 0 1
90088: PPUSH
90089: LD_VAR 0 3
90093: PPUSH
90094: CALL_OW 113
// exit ;
90098: GO 90186
// end ; if task [ 1 ] [ 1 ] <> M then
90100: LD_VAR 0 7
90104: PUSH
90105: LD_INT 1
90107: ARRAY
90108: PUSH
90109: LD_INT 1
90111: ARRAY
90112: PUSH
90113: LD_STRING M
90115: NONEQUAL
90116: IFFALSE 90120
// exit ;
90118: GO 90186
// x := task [ 1 ] [ 2 ] ;
90120: LD_ADDR_VAR 0 5
90124: PUSH
90125: LD_VAR 0 7
90129: PUSH
90130: LD_INT 1
90132: ARRAY
90133: PUSH
90134: LD_INT 2
90136: ARRAY
90137: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
90138: LD_ADDR_VAR 0 6
90142: PUSH
90143: LD_VAR 0 7
90147: PUSH
90148: LD_INT 1
90150: ARRAY
90151: PUSH
90152: LD_INT 3
90154: ARRAY
90155: ST_TO_ADDR
// if InArea ( x , y , area ) then
90156: LD_VAR 0 5
90160: PPUSH
90161: LD_VAR 0 6
90165: PPUSH
90166: LD_VAR 0 2
90170: PPUSH
90171: CALL_OW 309
90175: IFFALSE 90186
// ComStop ( unit ) ;
90177: LD_VAR 0 1
90181: PPUSH
90182: CALL_OW 141
// end ;
90186: LD_VAR 0 4
90190: RET
// export function Abs ( value ) ; begin
90191: LD_INT 0
90193: PPUSH
// result := value ;
90194: LD_ADDR_VAR 0 2
90198: PUSH
90199: LD_VAR 0 1
90203: ST_TO_ADDR
// if value < 0 then
90204: LD_VAR 0 1
90208: PUSH
90209: LD_INT 0
90211: LESS
90212: IFFALSE 90229
// result := value * - 1 ;
90214: LD_ADDR_VAR 0 2
90218: PUSH
90219: LD_VAR 0 1
90223: PUSH
90224: LD_INT 1
90226: NEG
90227: MUL
90228: ST_TO_ADDR
// end ;
90229: LD_VAR 0 2
90233: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
90234: LD_INT 0
90236: PPUSH
90237: PPUSH
90238: PPUSH
90239: PPUSH
90240: PPUSH
90241: PPUSH
90242: PPUSH
90243: PPUSH
// if not unit or not building then
90244: LD_VAR 0 1
90248: NOT
90249: PUSH
90250: LD_VAR 0 2
90254: NOT
90255: OR
90256: IFFALSE 90260
// exit ;
90258: GO 90486
// x := GetX ( building ) ;
90260: LD_ADDR_VAR 0 4
90264: PUSH
90265: LD_VAR 0 2
90269: PPUSH
90270: CALL_OW 250
90274: ST_TO_ADDR
// y := GetY ( building ) ;
90275: LD_ADDR_VAR 0 6
90279: PUSH
90280: LD_VAR 0 2
90284: PPUSH
90285: CALL_OW 251
90289: ST_TO_ADDR
// d := GetDir ( building ) ;
90290: LD_ADDR_VAR 0 8
90294: PUSH
90295: LD_VAR 0 2
90299: PPUSH
90300: CALL_OW 254
90304: ST_TO_ADDR
// r := 4 ;
90305: LD_ADDR_VAR 0 9
90309: PUSH
90310: LD_INT 4
90312: ST_TO_ADDR
// for i := 1 to 5 do
90313: LD_ADDR_VAR 0 10
90317: PUSH
90318: DOUBLE
90319: LD_INT 1
90321: DEC
90322: ST_TO_ADDR
90323: LD_INT 5
90325: PUSH
90326: FOR_TO
90327: IFFALSE 90484
// begin _x := ShiftX ( x , d , r + i ) ;
90329: LD_ADDR_VAR 0 5
90333: PUSH
90334: LD_VAR 0 4
90338: PPUSH
90339: LD_VAR 0 8
90343: PPUSH
90344: LD_VAR 0 9
90348: PUSH
90349: LD_VAR 0 10
90353: PLUS
90354: PPUSH
90355: CALL_OW 272
90359: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
90360: LD_ADDR_VAR 0 7
90364: PUSH
90365: LD_VAR 0 6
90369: PPUSH
90370: LD_VAR 0 8
90374: PPUSH
90375: LD_VAR 0 9
90379: PUSH
90380: LD_VAR 0 10
90384: PLUS
90385: PPUSH
90386: CALL_OW 273
90390: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
90391: LD_VAR 0 5
90395: PPUSH
90396: LD_VAR 0 7
90400: PPUSH
90401: CALL_OW 488
90405: PUSH
90406: LD_VAR 0 5
90410: PPUSH
90411: LD_VAR 0 7
90415: PPUSH
90416: CALL_OW 428
90420: PPUSH
90421: CALL_OW 247
90425: PUSH
90426: LD_INT 3
90428: PUSH
90429: LD_INT 2
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: IN
90436: NOT
90437: AND
90438: IFFALSE 90482
// begin ComMoveXY ( unit , _x , _y ) ;
90440: LD_VAR 0 1
90444: PPUSH
90445: LD_VAR 0 5
90449: PPUSH
90450: LD_VAR 0 7
90454: PPUSH
90455: CALL_OW 111
// result := [ _x , _y ] ;
90459: LD_ADDR_VAR 0 3
90463: PUSH
90464: LD_VAR 0 5
90468: PUSH
90469: LD_VAR 0 7
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: ST_TO_ADDR
// exit ;
90478: POP
90479: POP
90480: GO 90486
// end ; end ;
90482: GO 90326
90484: POP
90485: POP
// end ;
90486: LD_VAR 0 3
90490: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
90491: LD_INT 0
90493: PPUSH
90494: PPUSH
90495: PPUSH
// result := 0 ;
90496: LD_ADDR_VAR 0 3
90500: PUSH
90501: LD_INT 0
90503: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
90504: LD_VAR 0 1
90508: PUSH
90509: LD_INT 0
90511: LESS
90512: PUSH
90513: LD_VAR 0 1
90517: PUSH
90518: LD_INT 8
90520: GREATER
90521: OR
90522: PUSH
90523: LD_VAR 0 2
90527: PUSH
90528: LD_INT 0
90530: LESS
90531: OR
90532: PUSH
90533: LD_VAR 0 2
90537: PUSH
90538: LD_INT 8
90540: GREATER
90541: OR
90542: IFFALSE 90546
// exit ;
90544: GO 90621
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
90546: LD_ADDR_VAR 0 4
90550: PUSH
90551: LD_INT 22
90553: PUSH
90554: LD_VAR 0 2
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: PPUSH
90563: CALL_OW 69
90567: PUSH
90568: FOR_IN
90569: IFFALSE 90619
// begin un := UnitShoot ( i ) ;
90571: LD_ADDR_VAR 0 5
90575: PUSH
90576: LD_VAR 0 4
90580: PPUSH
90581: CALL_OW 504
90585: ST_TO_ADDR
// if GetSide ( un ) = side1 then
90586: LD_VAR 0 5
90590: PPUSH
90591: CALL_OW 255
90595: PUSH
90596: LD_VAR 0 1
90600: EQUAL
90601: IFFALSE 90617
// begin result := un ;
90603: LD_ADDR_VAR 0 3
90607: PUSH
90608: LD_VAR 0 5
90612: ST_TO_ADDR
// exit ;
90613: POP
90614: POP
90615: GO 90621
// end ; end ;
90617: GO 90568
90619: POP
90620: POP
// end ;
90621: LD_VAR 0 3
90625: RET
// export function GetCargoBay ( units ) ; begin
90626: LD_INT 0
90628: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90629: LD_ADDR_VAR 0 2
90633: PUSH
90634: LD_VAR 0 1
90638: PPUSH
90639: LD_INT 2
90641: PUSH
90642: LD_INT 34
90644: PUSH
90645: LD_INT 12
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 34
90654: PUSH
90655: LD_INT 51
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 34
90664: PUSH
90665: LD_INT 32
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 34
90674: PUSH
90675: LD_INT 89
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: PPUSH
90689: CALL_OW 72
90693: ST_TO_ADDR
// end ;
90694: LD_VAR 0 2
90698: RET
// export function Negate ( value ) ; begin
90699: LD_INT 0
90701: PPUSH
// result := not value ;
90702: LD_ADDR_VAR 0 2
90706: PUSH
90707: LD_VAR 0 1
90711: NOT
90712: ST_TO_ADDR
// end ;
90713: LD_VAR 0 2
90717: RET
// export function Inc ( value ) ; begin
90718: LD_INT 0
90720: PPUSH
// result := value + 1 ;
90721: LD_ADDR_VAR 0 2
90725: PUSH
90726: LD_VAR 0 1
90730: PUSH
90731: LD_INT 1
90733: PLUS
90734: ST_TO_ADDR
// end ;
90735: LD_VAR 0 2
90739: RET
// export function Dec ( value ) ; begin
90740: LD_INT 0
90742: PPUSH
// result := value - 1 ;
90743: LD_ADDR_VAR 0 2
90747: PUSH
90748: LD_VAR 0 1
90752: PUSH
90753: LD_INT 1
90755: MINUS
90756: ST_TO_ADDR
// end ;
90757: LD_VAR 0 2
90761: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90762: LD_INT 0
90764: PPUSH
90765: PPUSH
90766: PPUSH
90767: PPUSH
90768: PPUSH
90769: PPUSH
90770: PPUSH
90771: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90772: LD_VAR 0 1
90776: PPUSH
90777: LD_VAR 0 2
90781: PPUSH
90782: CALL_OW 488
90786: NOT
90787: PUSH
90788: LD_VAR 0 3
90792: PPUSH
90793: LD_VAR 0 4
90797: PPUSH
90798: CALL_OW 488
90802: NOT
90803: OR
90804: IFFALSE 90817
// begin result := - 1 ;
90806: LD_ADDR_VAR 0 5
90810: PUSH
90811: LD_INT 1
90813: NEG
90814: ST_TO_ADDR
// exit ;
90815: GO 91052
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90817: LD_ADDR_VAR 0 12
90821: PUSH
90822: LD_VAR 0 1
90826: PPUSH
90827: LD_VAR 0 2
90831: PPUSH
90832: LD_VAR 0 3
90836: PPUSH
90837: LD_VAR 0 4
90841: PPUSH
90842: CALL 89902 0 4
90846: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90847: LD_ADDR_VAR 0 11
90851: PUSH
90852: LD_VAR 0 1
90856: PPUSH
90857: LD_VAR 0 2
90861: PPUSH
90862: LD_VAR 0 12
90866: PUSH
90867: LD_INT 1
90869: ARRAY
90870: PPUSH
90871: LD_VAR 0 12
90875: PUSH
90876: LD_INT 2
90878: ARRAY
90879: PPUSH
90880: CALL_OW 298
90884: ST_TO_ADDR
// distance := 9999 ;
90885: LD_ADDR_VAR 0 10
90889: PUSH
90890: LD_INT 9999
90892: ST_TO_ADDR
// for i := 0 to 5 do
90893: LD_ADDR_VAR 0 6
90897: PUSH
90898: DOUBLE
90899: LD_INT 0
90901: DEC
90902: ST_TO_ADDR
90903: LD_INT 5
90905: PUSH
90906: FOR_TO
90907: IFFALSE 91050
// begin _x := ShiftX ( x1 , i , centerDist ) ;
90909: LD_ADDR_VAR 0 7
90913: PUSH
90914: LD_VAR 0 1
90918: PPUSH
90919: LD_VAR 0 6
90923: PPUSH
90924: LD_VAR 0 11
90928: PPUSH
90929: CALL_OW 272
90933: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
90934: LD_ADDR_VAR 0 8
90938: PUSH
90939: LD_VAR 0 2
90943: PPUSH
90944: LD_VAR 0 6
90948: PPUSH
90949: LD_VAR 0 11
90953: PPUSH
90954: CALL_OW 273
90958: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
90959: LD_VAR 0 7
90963: PPUSH
90964: LD_VAR 0 8
90968: PPUSH
90969: CALL_OW 488
90973: NOT
90974: IFFALSE 90978
// continue ;
90976: GO 90906
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
90978: LD_ADDR_VAR 0 9
90982: PUSH
90983: LD_VAR 0 12
90987: PUSH
90988: LD_INT 1
90990: ARRAY
90991: PPUSH
90992: LD_VAR 0 12
90996: PUSH
90997: LD_INT 2
90999: ARRAY
91000: PPUSH
91001: LD_VAR 0 7
91005: PPUSH
91006: LD_VAR 0 8
91010: PPUSH
91011: CALL_OW 298
91015: ST_TO_ADDR
// if tmp < distance then
91016: LD_VAR 0 9
91020: PUSH
91021: LD_VAR 0 10
91025: LESS
91026: IFFALSE 91048
// begin result := i ;
91028: LD_ADDR_VAR 0 5
91032: PUSH
91033: LD_VAR 0 6
91037: ST_TO_ADDR
// distance := tmp ;
91038: LD_ADDR_VAR 0 10
91042: PUSH
91043: LD_VAR 0 9
91047: ST_TO_ADDR
// end ; end ;
91048: GO 90906
91050: POP
91051: POP
// end ;
91052: LD_VAR 0 5
91056: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91057: LD_INT 0
91059: PPUSH
91060: PPUSH
// if not driver or not IsInUnit ( driver ) then
91061: LD_VAR 0 1
91065: NOT
91066: PUSH
91067: LD_VAR 0 1
91071: PPUSH
91072: CALL_OW 310
91076: NOT
91077: OR
91078: IFFALSE 91082
// exit ;
91080: GO 91172
// vehicle := IsInUnit ( driver ) ;
91082: LD_ADDR_VAR 0 3
91086: PUSH
91087: LD_VAR 0 1
91091: PPUSH
91092: CALL_OW 310
91096: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91097: LD_VAR 0 1
91101: PPUSH
91102: LD_STRING \
91104: PUSH
91105: LD_INT 0
91107: PUSH
91108: LD_INT 0
91110: PUSH
91111: LD_INT 0
91113: PUSH
91114: LD_INT 0
91116: PUSH
91117: LD_INT 0
91119: PUSH
91120: LD_INT 0
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: LIST
91130: LIST
91131: PUSH
91132: LD_STRING E
91134: PUSH
91135: LD_INT 0
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: LD_VAR 0 3
91145: PUSH
91146: LD_INT 0
91148: PUSH
91149: LD_INT 0
91151: PUSH
91152: LD_INT 0
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: PPUSH
91168: CALL_OW 446
// end ;
91172: LD_VAR 0 2
91176: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
91177: LD_INT 0
91179: PPUSH
91180: PPUSH
// if not driver or not IsInUnit ( driver ) then
91181: LD_VAR 0 1
91185: NOT
91186: PUSH
91187: LD_VAR 0 1
91191: PPUSH
91192: CALL_OW 310
91196: NOT
91197: OR
91198: IFFALSE 91202
// exit ;
91200: GO 91292
// vehicle := IsInUnit ( driver ) ;
91202: LD_ADDR_VAR 0 3
91206: PUSH
91207: LD_VAR 0 1
91211: PPUSH
91212: CALL_OW 310
91216: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
91217: LD_VAR 0 1
91221: PPUSH
91222: LD_STRING \
91224: PUSH
91225: LD_INT 0
91227: PUSH
91228: LD_INT 0
91230: PUSH
91231: LD_INT 0
91233: PUSH
91234: LD_INT 0
91236: PUSH
91237: LD_INT 0
91239: PUSH
91240: LD_INT 0
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: PUSH
91252: LD_STRING E
91254: PUSH
91255: LD_INT 0
91257: PUSH
91258: LD_INT 0
91260: PUSH
91261: LD_VAR 0 3
91265: PUSH
91266: LD_INT 0
91268: PUSH
91269: LD_INT 0
91271: PUSH
91272: LD_INT 0
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PPUSH
91288: CALL_OW 447
// end ;
91292: LD_VAR 0 2
91296: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
91297: LD_INT 0
91299: PPUSH
91300: PPUSH
91301: PPUSH
// tmp := [ ] ;
91302: LD_ADDR_VAR 0 5
91306: PUSH
91307: EMPTY
91308: ST_TO_ADDR
// for i in units do
91309: LD_ADDR_VAR 0 4
91313: PUSH
91314: LD_VAR 0 1
91318: PUSH
91319: FOR_IN
91320: IFFALSE 91358
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
91322: LD_ADDR_VAR 0 5
91326: PUSH
91327: LD_VAR 0 5
91331: PPUSH
91332: LD_VAR 0 5
91336: PUSH
91337: LD_INT 1
91339: PLUS
91340: PPUSH
91341: LD_VAR 0 4
91345: PPUSH
91346: CALL_OW 256
91350: PPUSH
91351: CALL_OW 2
91355: ST_TO_ADDR
91356: GO 91319
91358: POP
91359: POP
// if not tmp then
91360: LD_VAR 0 5
91364: NOT
91365: IFFALSE 91369
// exit ;
91367: GO 91417
// if asc then
91369: LD_VAR 0 2
91373: IFFALSE 91397
// result := SortListByListAsc ( units , tmp ) else
91375: LD_ADDR_VAR 0 3
91379: PUSH
91380: LD_VAR 0 1
91384: PPUSH
91385: LD_VAR 0 5
91389: PPUSH
91390: CALL_OW 76
91394: ST_TO_ADDR
91395: GO 91417
// result := SortListByListDesc ( units , tmp ) ;
91397: LD_ADDR_VAR 0 3
91401: PUSH
91402: LD_VAR 0 1
91406: PPUSH
91407: LD_VAR 0 5
91411: PPUSH
91412: CALL_OW 77
91416: ST_TO_ADDR
// end ;
91417: LD_VAR 0 3
91421: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
91422: LD_INT 0
91424: PPUSH
91425: PPUSH
// task := GetTaskList ( mech ) ;
91426: LD_ADDR_VAR 0 4
91430: PUSH
91431: LD_VAR 0 1
91435: PPUSH
91436: CALL_OW 437
91440: ST_TO_ADDR
// if not task then
91441: LD_VAR 0 4
91445: NOT
91446: IFFALSE 91450
// exit ;
91448: GO 91492
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
91450: LD_ADDR_VAR 0 3
91454: PUSH
91455: LD_VAR 0 4
91459: PUSH
91460: LD_INT 1
91462: ARRAY
91463: PUSH
91464: LD_INT 1
91466: ARRAY
91467: PUSH
91468: LD_STRING r
91470: EQUAL
91471: PUSH
91472: LD_VAR 0 4
91476: PUSH
91477: LD_INT 1
91479: ARRAY
91480: PUSH
91481: LD_INT 4
91483: ARRAY
91484: PUSH
91485: LD_VAR 0 2
91489: EQUAL
91490: AND
91491: ST_TO_ADDR
// end ;
91492: LD_VAR 0 3
91496: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
91497: LD_INT 0
91499: PPUSH
// SetDir ( unit , d ) ;
91500: LD_VAR 0 1
91504: PPUSH
91505: LD_VAR 0 4
91509: PPUSH
91510: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
91514: LD_VAR 0 1
91518: PPUSH
91519: LD_VAR 0 2
91523: PPUSH
91524: LD_VAR 0 3
91528: PPUSH
91529: LD_VAR 0 5
91533: PPUSH
91534: CALL_OW 48
// end ;
91538: LD_VAR 0 6
91542: RET
// export function ToNaturalNumber ( number ) ; begin
91543: LD_INT 0
91545: PPUSH
// result := number div 1 ;
91546: LD_ADDR_VAR 0 2
91550: PUSH
91551: LD_VAR 0 1
91555: PUSH
91556: LD_INT 1
91558: DIV
91559: ST_TO_ADDR
// if number < 0 then
91560: LD_VAR 0 1
91564: PUSH
91565: LD_INT 0
91567: LESS
91568: IFFALSE 91578
// result := 0 ;
91570: LD_ADDR_VAR 0 2
91574: PUSH
91575: LD_INT 0
91577: ST_TO_ADDR
// end ;
91578: LD_VAR 0 2
91582: RET
// export function SortByClass ( units , class ) ; var un ; begin
91583: LD_INT 0
91585: PPUSH
91586: PPUSH
// if not units or not class then
91587: LD_VAR 0 1
91591: NOT
91592: PUSH
91593: LD_VAR 0 2
91597: NOT
91598: OR
91599: IFFALSE 91603
// exit ;
91601: GO 91698
// result := [ ] ;
91603: LD_ADDR_VAR 0 3
91607: PUSH
91608: EMPTY
91609: ST_TO_ADDR
// for un in units do
91610: LD_ADDR_VAR 0 4
91614: PUSH
91615: LD_VAR 0 1
91619: PUSH
91620: FOR_IN
91621: IFFALSE 91696
// if GetClass ( un ) = class then
91623: LD_VAR 0 4
91627: PPUSH
91628: CALL_OW 257
91632: PUSH
91633: LD_VAR 0 2
91637: EQUAL
91638: IFFALSE 91665
// result := Insert ( result , 1 , un ) else
91640: LD_ADDR_VAR 0 3
91644: PUSH
91645: LD_VAR 0 3
91649: PPUSH
91650: LD_INT 1
91652: PPUSH
91653: LD_VAR 0 4
91657: PPUSH
91658: CALL_OW 2
91662: ST_TO_ADDR
91663: GO 91694
// result := Replace ( result , result + 1 , un ) ;
91665: LD_ADDR_VAR 0 3
91669: PUSH
91670: LD_VAR 0 3
91674: PPUSH
91675: LD_VAR 0 3
91679: PUSH
91680: LD_INT 1
91682: PLUS
91683: PPUSH
91684: LD_VAR 0 4
91688: PPUSH
91689: CALL_OW 1
91693: ST_TO_ADDR
91694: GO 91620
91696: POP
91697: POP
// end ;
91698: LD_VAR 0 3
91702: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91703: LD_INT 0
91705: PPUSH
91706: PPUSH
91707: PPUSH
91708: PPUSH
91709: PPUSH
91710: PPUSH
91711: PPUSH
// result := [ ] ;
91712: LD_ADDR_VAR 0 4
91716: PUSH
91717: EMPTY
91718: ST_TO_ADDR
// if x - r < 0 then
91719: LD_VAR 0 1
91723: PUSH
91724: LD_VAR 0 3
91728: MINUS
91729: PUSH
91730: LD_INT 0
91732: LESS
91733: IFFALSE 91745
// min_x := 0 else
91735: LD_ADDR_VAR 0 8
91739: PUSH
91740: LD_INT 0
91742: ST_TO_ADDR
91743: GO 91761
// min_x := x - r ;
91745: LD_ADDR_VAR 0 8
91749: PUSH
91750: LD_VAR 0 1
91754: PUSH
91755: LD_VAR 0 3
91759: MINUS
91760: ST_TO_ADDR
// if y - r < 0 then
91761: LD_VAR 0 2
91765: PUSH
91766: LD_VAR 0 3
91770: MINUS
91771: PUSH
91772: LD_INT 0
91774: LESS
91775: IFFALSE 91787
// min_y := 0 else
91777: LD_ADDR_VAR 0 7
91781: PUSH
91782: LD_INT 0
91784: ST_TO_ADDR
91785: GO 91803
// min_y := y - r ;
91787: LD_ADDR_VAR 0 7
91791: PUSH
91792: LD_VAR 0 2
91796: PUSH
91797: LD_VAR 0 3
91801: MINUS
91802: ST_TO_ADDR
// max_x := x + r ;
91803: LD_ADDR_VAR 0 9
91807: PUSH
91808: LD_VAR 0 1
91812: PUSH
91813: LD_VAR 0 3
91817: PLUS
91818: ST_TO_ADDR
// max_y := y + r ;
91819: LD_ADDR_VAR 0 10
91823: PUSH
91824: LD_VAR 0 2
91828: PUSH
91829: LD_VAR 0 3
91833: PLUS
91834: ST_TO_ADDR
// for _x = min_x to max_x do
91835: LD_ADDR_VAR 0 5
91839: PUSH
91840: DOUBLE
91841: LD_VAR 0 8
91845: DEC
91846: ST_TO_ADDR
91847: LD_VAR 0 9
91851: PUSH
91852: FOR_TO
91853: IFFALSE 91954
// for _y = min_y to max_y do
91855: LD_ADDR_VAR 0 6
91859: PUSH
91860: DOUBLE
91861: LD_VAR 0 7
91865: DEC
91866: ST_TO_ADDR
91867: LD_VAR 0 10
91871: PUSH
91872: FOR_TO
91873: IFFALSE 91950
// begin if not ValidHex ( _x , _y ) then
91875: LD_VAR 0 5
91879: PPUSH
91880: LD_VAR 0 6
91884: PPUSH
91885: CALL_OW 488
91889: NOT
91890: IFFALSE 91894
// continue ;
91892: GO 91872
// if GetResourceTypeXY ( _x , _y ) then
91894: LD_VAR 0 5
91898: PPUSH
91899: LD_VAR 0 6
91903: PPUSH
91904: CALL_OW 283
91908: IFFALSE 91948
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91910: LD_ADDR_VAR 0 4
91914: PUSH
91915: LD_VAR 0 4
91919: PPUSH
91920: LD_VAR 0 4
91924: PUSH
91925: LD_INT 1
91927: PLUS
91928: PPUSH
91929: LD_VAR 0 5
91933: PUSH
91934: LD_VAR 0 6
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PPUSH
91943: CALL_OW 1
91947: ST_TO_ADDR
// end ;
91948: GO 91872
91950: POP
91951: POP
91952: GO 91852
91954: POP
91955: POP
// end ;
91956: LD_VAR 0 4
91960: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
91961: LD_INT 0
91963: PPUSH
91964: PPUSH
91965: PPUSH
91966: PPUSH
91967: PPUSH
91968: PPUSH
91969: PPUSH
91970: PPUSH
// if not units then
91971: LD_VAR 0 1
91975: NOT
91976: IFFALSE 91980
// exit ;
91978: GO 92504
// result := UnitFilter ( units , [ f_ok ] ) ;
91980: LD_ADDR_VAR 0 3
91984: PUSH
91985: LD_VAR 0 1
91989: PPUSH
91990: LD_INT 50
91992: PUSH
91993: EMPTY
91994: LIST
91995: PPUSH
91996: CALL_OW 72
92000: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
92001: LD_ADDR_VAR 0 8
92005: PUSH
92006: LD_VAR 0 1
92010: PUSH
92011: LD_INT 1
92013: ARRAY
92014: PPUSH
92015: CALL_OW 255
92019: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
92020: LD_ADDR_VAR 0 10
92024: PUSH
92025: LD_INT 29
92027: PUSH
92028: LD_INT 91
92030: PUSH
92031: LD_INT 49
92033: PUSH
92034: EMPTY
92035: LIST
92036: LIST
92037: LIST
92038: ST_TO_ADDR
// if not result then
92039: LD_VAR 0 3
92043: NOT
92044: IFFALSE 92048
// exit ;
92046: GO 92504
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
92048: LD_ADDR_VAR 0 5
92052: PUSH
92053: LD_INT 81
92055: PUSH
92056: LD_VAR 0 8
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PPUSH
92065: CALL_OW 69
92069: ST_TO_ADDR
// for i in result do
92070: LD_ADDR_VAR 0 4
92074: PUSH
92075: LD_VAR 0 3
92079: PUSH
92080: FOR_IN
92081: IFFALSE 92502
// begin tag := GetTag ( i ) + 1 ;
92083: LD_ADDR_VAR 0 9
92087: PUSH
92088: LD_VAR 0 4
92092: PPUSH
92093: CALL_OW 110
92097: PUSH
92098: LD_INT 1
92100: PLUS
92101: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
92102: LD_ADDR_VAR 0 7
92106: PUSH
92107: LD_VAR 0 4
92111: PPUSH
92112: CALL_OW 250
92116: PPUSH
92117: LD_VAR 0 4
92121: PPUSH
92122: CALL_OW 251
92126: PPUSH
92127: LD_INT 6
92129: PPUSH
92130: CALL 91703 0 3
92134: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
92135: LD_VAR 0 4
92139: PPUSH
92140: CALL_OW 247
92144: PUSH
92145: LD_INT 2
92147: EQUAL
92148: PUSH
92149: LD_VAR 0 7
92153: AND
92154: PUSH
92155: LD_VAR 0 4
92159: PPUSH
92160: CALL_OW 264
92164: PUSH
92165: LD_VAR 0 10
92169: IN
92170: NOT
92171: AND
92172: IFFALSE 92211
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
92174: LD_VAR 0 4
92178: PPUSH
92179: LD_VAR 0 7
92183: PUSH
92184: LD_INT 1
92186: ARRAY
92187: PUSH
92188: LD_INT 1
92190: ARRAY
92191: PPUSH
92192: LD_VAR 0 7
92196: PUSH
92197: LD_INT 1
92199: ARRAY
92200: PUSH
92201: LD_INT 2
92203: ARRAY
92204: PPUSH
92205: CALL_OW 116
92209: GO 92500
// if path > tag then
92211: LD_VAR 0 2
92215: PUSH
92216: LD_VAR 0 9
92220: GREATER
92221: IFFALSE 92429
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
92223: LD_ADDR_VAR 0 6
92227: PUSH
92228: LD_VAR 0 5
92232: PPUSH
92233: LD_INT 91
92235: PUSH
92236: LD_VAR 0 4
92240: PUSH
92241: LD_INT 8
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: LIST
92248: PPUSH
92249: CALL_OW 72
92253: ST_TO_ADDR
// if nearEnemy then
92254: LD_VAR 0 6
92258: IFFALSE 92327
// begin if GetWeapon ( i ) = ru_time_lapser then
92260: LD_VAR 0 4
92264: PPUSH
92265: CALL_OW 264
92269: PUSH
92270: LD_INT 49
92272: EQUAL
92273: IFFALSE 92301
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
92275: LD_VAR 0 4
92279: PPUSH
92280: LD_VAR 0 6
92284: PPUSH
92285: LD_VAR 0 4
92289: PPUSH
92290: CALL_OW 74
92294: PPUSH
92295: CALL_OW 112
92299: GO 92325
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
92301: LD_VAR 0 4
92305: PPUSH
92306: LD_VAR 0 6
92310: PPUSH
92311: LD_VAR 0 4
92315: PPUSH
92316: CALL_OW 74
92320: PPUSH
92321: CALL_OW 115
// end else
92325: GO 92427
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
92327: LD_VAR 0 4
92331: PPUSH
92332: LD_VAR 0 2
92336: PUSH
92337: LD_VAR 0 9
92341: ARRAY
92342: PUSH
92343: LD_INT 1
92345: ARRAY
92346: PPUSH
92347: LD_VAR 0 2
92351: PUSH
92352: LD_VAR 0 9
92356: ARRAY
92357: PUSH
92358: LD_INT 2
92360: ARRAY
92361: PPUSH
92362: CALL_OW 297
92366: PUSH
92367: LD_INT 6
92369: GREATER
92370: IFFALSE 92413
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
92372: LD_VAR 0 4
92376: PPUSH
92377: LD_VAR 0 2
92381: PUSH
92382: LD_VAR 0 9
92386: ARRAY
92387: PUSH
92388: LD_INT 1
92390: ARRAY
92391: PPUSH
92392: LD_VAR 0 2
92396: PUSH
92397: LD_VAR 0 9
92401: ARRAY
92402: PUSH
92403: LD_INT 2
92405: ARRAY
92406: PPUSH
92407: CALL_OW 114
92411: GO 92427
// SetTag ( i , tag ) ;
92413: LD_VAR 0 4
92417: PPUSH
92418: LD_VAR 0 9
92422: PPUSH
92423: CALL_OW 109
// end else
92427: GO 92500
// if enemy then
92429: LD_VAR 0 5
92433: IFFALSE 92500
// begin if GetWeapon ( i ) = ru_time_lapser then
92435: LD_VAR 0 4
92439: PPUSH
92440: CALL_OW 264
92444: PUSH
92445: LD_INT 49
92447: EQUAL
92448: IFFALSE 92476
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
92450: LD_VAR 0 4
92454: PPUSH
92455: LD_VAR 0 5
92459: PPUSH
92460: LD_VAR 0 4
92464: PPUSH
92465: CALL_OW 74
92469: PPUSH
92470: CALL_OW 112
92474: GO 92500
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
92476: LD_VAR 0 4
92480: PPUSH
92481: LD_VAR 0 5
92485: PPUSH
92486: LD_VAR 0 4
92490: PPUSH
92491: CALL_OW 74
92495: PPUSH
92496: CALL_OW 115
// end ; end ;
92500: GO 92080
92502: POP
92503: POP
// end ;
92504: LD_VAR 0 3
92508: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
92509: LD_INT 0
92511: PPUSH
92512: PPUSH
92513: PPUSH
// if not unit or IsInUnit ( unit ) then
92514: LD_VAR 0 1
92518: NOT
92519: PUSH
92520: LD_VAR 0 1
92524: PPUSH
92525: CALL_OW 310
92529: OR
92530: IFFALSE 92534
// exit ;
92532: GO 92625
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
92534: LD_ADDR_VAR 0 4
92538: PUSH
92539: LD_VAR 0 1
92543: PPUSH
92544: CALL_OW 250
92548: PPUSH
92549: LD_VAR 0 2
92553: PPUSH
92554: LD_INT 1
92556: PPUSH
92557: CALL_OW 272
92561: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
92562: LD_ADDR_VAR 0 5
92566: PUSH
92567: LD_VAR 0 1
92571: PPUSH
92572: CALL_OW 251
92576: PPUSH
92577: LD_VAR 0 2
92581: PPUSH
92582: LD_INT 1
92584: PPUSH
92585: CALL_OW 273
92589: ST_TO_ADDR
// if ValidHex ( x , y ) then
92590: LD_VAR 0 4
92594: PPUSH
92595: LD_VAR 0 5
92599: PPUSH
92600: CALL_OW 488
92604: IFFALSE 92625
// ComTurnXY ( unit , x , y ) ;
92606: LD_VAR 0 1
92610: PPUSH
92611: LD_VAR 0 4
92615: PPUSH
92616: LD_VAR 0 5
92620: PPUSH
92621: CALL_OW 118
// end ;
92625: LD_VAR 0 3
92629: RET
// export function SeeUnits ( side , units ) ; var i ; begin
92630: LD_INT 0
92632: PPUSH
92633: PPUSH
// result := false ;
92634: LD_ADDR_VAR 0 3
92638: PUSH
92639: LD_INT 0
92641: ST_TO_ADDR
// if not units then
92642: LD_VAR 0 2
92646: NOT
92647: IFFALSE 92651
// exit ;
92649: GO 92696
// for i in units do
92651: LD_ADDR_VAR 0 4
92655: PUSH
92656: LD_VAR 0 2
92660: PUSH
92661: FOR_IN
92662: IFFALSE 92694
// if See ( side , i ) then
92664: LD_VAR 0 1
92668: PPUSH
92669: LD_VAR 0 4
92673: PPUSH
92674: CALL_OW 292
92678: IFFALSE 92692
// begin result := true ;
92680: LD_ADDR_VAR 0 3
92684: PUSH
92685: LD_INT 1
92687: ST_TO_ADDR
// exit ;
92688: POP
92689: POP
92690: GO 92696
// end ;
92692: GO 92661
92694: POP
92695: POP
// end ;
92696: LD_VAR 0 3
92700: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
92701: LD_INT 0
92703: PPUSH
92704: PPUSH
92705: PPUSH
92706: PPUSH
// if not unit or not points then
92707: LD_VAR 0 1
92711: NOT
92712: PUSH
92713: LD_VAR 0 2
92717: NOT
92718: OR
92719: IFFALSE 92723
// exit ;
92721: GO 92813
// dist := 99999 ;
92723: LD_ADDR_VAR 0 5
92727: PUSH
92728: LD_INT 99999
92730: ST_TO_ADDR
// for i in points do
92731: LD_ADDR_VAR 0 4
92735: PUSH
92736: LD_VAR 0 2
92740: PUSH
92741: FOR_IN
92742: IFFALSE 92811
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
92744: LD_ADDR_VAR 0 6
92748: PUSH
92749: LD_VAR 0 1
92753: PPUSH
92754: LD_VAR 0 4
92758: PUSH
92759: LD_INT 1
92761: ARRAY
92762: PPUSH
92763: LD_VAR 0 4
92767: PUSH
92768: LD_INT 2
92770: ARRAY
92771: PPUSH
92772: CALL_OW 297
92776: ST_TO_ADDR
// if tmpDist < dist then
92777: LD_VAR 0 6
92781: PUSH
92782: LD_VAR 0 5
92786: LESS
92787: IFFALSE 92809
// begin result := i ;
92789: LD_ADDR_VAR 0 3
92793: PUSH
92794: LD_VAR 0 4
92798: ST_TO_ADDR
// dist := tmpDist ;
92799: LD_ADDR_VAR 0 5
92803: PUSH
92804: LD_VAR 0 6
92808: ST_TO_ADDR
// end ; end ;
92809: GO 92741
92811: POP
92812: POP
// end ;
92813: LD_VAR 0 3
92817: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
92818: LD_INT 0
92820: PPUSH
// uc_side := side ;
92821: LD_ADDR_OWVAR 20
92825: PUSH
92826: LD_VAR 0 1
92830: ST_TO_ADDR
// uc_nation := 3 ;
92831: LD_ADDR_OWVAR 21
92835: PUSH
92836: LD_INT 3
92838: ST_TO_ADDR
// vc_chassis := 25 ;
92839: LD_ADDR_OWVAR 37
92843: PUSH
92844: LD_INT 25
92846: ST_TO_ADDR
// vc_engine := engine_siberite ;
92847: LD_ADDR_OWVAR 39
92851: PUSH
92852: LD_INT 3
92854: ST_TO_ADDR
// vc_control := control_computer ;
92855: LD_ADDR_OWVAR 38
92859: PUSH
92860: LD_INT 3
92862: ST_TO_ADDR
// vc_weapon := 59 ;
92863: LD_ADDR_OWVAR 40
92867: PUSH
92868: LD_INT 59
92870: ST_TO_ADDR
// result := CreateVehicle ;
92871: LD_ADDR_VAR 0 5
92875: PUSH
92876: CALL_OW 45
92880: ST_TO_ADDR
// SetDir ( result , d ) ;
92881: LD_VAR 0 5
92885: PPUSH
92886: LD_VAR 0 4
92890: PPUSH
92891: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
92895: LD_VAR 0 5
92899: PPUSH
92900: LD_VAR 0 2
92904: PPUSH
92905: LD_VAR 0 3
92909: PPUSH
92910: LD_INT 0
92912: PPUSH
92913: CALL_OW 48
// end ;
92917: LD_VAR 0 5
92921: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
92922: LD_INT 0
92924: PPUSH
92925: PPUSH
92926: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
92927: LD_ADDR_VAR 0 2
92931: PUSH
92932: LD_INT 0
92934: PUSH
92935: LD_INT 0
92937: PUSH
92938: LD_INT 0
92940: PUSH
92941: LD_INT 0
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
92950: LD_VAR 0 1
92954: NOT
92955: PUSH
92956: LD_VAR 0 1
92960: PPUSH
92961: CALL_OW 264
92965: PUSH
92966: LD_INT 12
92968: PUSH
92969: LD_INT 51
92971: PUSH
92972: LD_INT 32
92974: PUSH
92975: LD_INT 89
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: IN
92984: NOT
92985: OR
92986: IFFALSE 92990
// exit ;
92988: GO 93088
// for i := 1 to 3 do
92990: LD_ADDR_VAR 0 3
92994: PUSH
92995: DOUBLE
92996: LD_INT 1
92998: DEC
92999: ST_TO_ADDR
93000: LD_INT 3
93002: PUSH
93003: FOR_TO
93004: IFFALSE 93086
// begin tmp := GetCargo ( cargo , i ) ;
93006: LD_ADDR_VAR 0 4
93010: PUSH
93011: LD_VAR 0 1
93015: PPUSH
93016: LD_VAR 0 3
93020: PPUSH
93021: CALL_OW 289
93025: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
93026: LD_ADDR_VAR 0 2
93030: PUSH
93031: LD_VAR 0 2
93035: PPUSH
93036: LD_VAR 0 3
93040: PPUSH
93041: LD_VAR 0 4
93045: PPUSH
93046: CALL_OW 1
93050: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
93051: LD_ADDR_VAR 0 2
93055: PUSH
93056: LD_VAR 0 2
93060: PPUSH
93061: LD_INT 4
93063: PPUSH
93064: LD_VAR 0 2
93068: PUSH
93069: LD_INT 4
93071: ARRAY
93072: PUSH
93073: LD_VAR 0 4
93077: PLUS
93078: PPUSH
93079: CALL_OW 1
93083: ST_TO_ADDR
// end ;
93084: GO 93003
93086: POP
93087: POP
// end ;
93088: LD_VAR 0 2
93092: RET
// export function Length ( array ) ; begin
93093: LD_INT 0
93095: PPUSH
// result := array + 0 ;
93096: LD_ADDR_VAR 0 2
93100: PUSH
93101: LD_VAR 0 1
93105: PUSH
93106: LD_INT 0
93108: PLUS
93109: ST_TO_ADDR
// end ;
93110: LD_VAR 0 2
93114: RET
// export function PrepareArray ( array ) ; begin
93115: LD_INT 0
93117: PPUSH
// result := array diff 0 ;
93118: LD_ADDR_VAR 0 2
93122: PUSH
93123: LD_VAR 0 1
93127: PUSH
93128: LD_INT 0
93130: DIFF
93131: ST_TO_ADDR
// if not result [ 1 ] then
93132: LD_VAR 0 2
93136: PUSH
93137: LD_INT 1
93139: ARRAY
93140: NOT
93141: IFFALSE 93161
// result := Delete ( result , 1 ) ;
93143: LD_ADDR_VAR 0 2
93147: PUSH
93148: LD_VAR 0 2
93152: PPUSH
93153: LD_INT 1
93155: PPUSH
93156: CALL_OW 3
93160: ST_TO_ADDR
// end ; end_of_file end_of_file
93161: LD_VAR 0 2
93165: RET
// every 0 0$1 do
93166: GO 93168
93168: DISABLE
// begin enable ;
93169: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93170: LD_STRING updateTimer(
93172: PUSH
93173: LD_OWVAR 1
93177: STR
93178: PUSH
93179: LD_STRING );
93181: STR
93182: PPUSH
93183: CALL_OW 559
// end ;
93187: END
// export function SOS_MapStart ( ) ; begin
93188: LD_INT 0
93190: PPUSH
// if streamModeActive then
93191: LD_EXP 120
93195: IFFALSE 93204
// DefineStreamItems ( true ) ;
93197: LD_INT 1
93199: PPUSH
93200: CALL 94858 0 1
// UpdateFactoryWaypoints ( ) ;
93204: CALL 107719 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93208: CALL 107976 0 0
// end ;
93212: LD_VAR 0 1
93216: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93217: LD_INT 0
93219: PPUSH
// if p2 = 100 then
93220: LD_VAR 0 2
93224: PUSH
93225: LD_INT 100
93227: EQUAL
93228: IFFALSE 94231
// begin if not StreamModeActive then
93230: LD_EXP 120
93234: NOT
93235: IFFALSE 93245
// StreamModeActive := true ;
93237: LD_ADDR_EXP 120
93241: PUSH
93242: LD_INT 1
93244: ST_TO_ADDR
// if p3 = 0 then
93245: LD_VAR 0 3
93249: PUSH
93250: LD_INT 0
93252: EQUAL
93253: IFFALSE 93259
// InitStreamMode ;
93255: CALL 94394 0 0
// if p3 = 1 then
93259: LD_VAR 0 3
93263: PUSH
93264: LD_INT 1
93266: EQUAL
93267: IFFALSE 93277
// sRocket := true ;
93269: LD_ADDR_EXP 125
93273: PUSH
93274: LD_INT 1
93276: ST_TO_ADDR
// if p3 = 2 then
93277: LD_VAR 0 3
93281: PUSH
93282: LD_INT 2
93284: EQUAL
93285: IFFALSE 93295
// sSpeed := true ;
93287: LD_ADDR_EXP 124
93291: PUSH
93292: LD_INT 1
93294: ST_TO_ADDR
// if p3 = 3 then
93295: LD_VAR 0 3
93299: PUSH
93300: LD_INT 3
93302: EQUAL
93303: IFFALSE 93313
// sEngine := true ;
93305: LD_ADDR_EXP 126
93309: PUSH
93310: LD_INT 1
93312: ST_TO_ADDR
// if p3 = 4 then
93313: LD_VAR 0 3
93317: PUSH
93318: LD_INT 4
93320: EQUAL
93321: IFFALSE 93331
// sSpec := true ;
93323: LD_ADDR_EXP 123
93327: PUSH
93328: LD_INT 1
93330: ST_TO_ADDR
// if p3 = 5 then
93331: LD_VAR 0 3
93335: PUSH
93336: LD_INT 5
93338: EQUAL
93339: IFFALSE 93349
// sLevel := true ;
93341: LD_ADDR_EXP 127
93345: PUSH
93346: LD_INT 1
93348: ST_TO_ADDR
// if p3 = 6 then
93349: LD_VAR 0 3
93353: PUSH
93354: LD_INT 6
93356: EQUAL
93357: IFFALSE 93367
// sArmoury := true ;
93359: LD_ADDR_EXP 128
93363: PUSH
93364: LD_INT 1
93366: ST_TO_ADDR
// if p3 = 7 then
93367: LD_VAR 0 3
93371: PUSH
93372: LD_INT 7
93374: EQUAL
93375: IFFALSE 93385
// sRadar := true ;
93377: LD_ADDR_EXP 129
93381: PUSH
93382: LD_INT 1
93384: ST_TO_ADDR
// if p3 = 8 then
93385: LD_VAR 0 3
93389: PUSH
93390: LD_INT 8
93392: EQUAL
93393: IFFALSE 93403
// sBunker := true ;
93395: LD_ADDR_EXP 130
93399: PUSH
93400: LD_INT 1
93402: ST_TO_ADDR
// if p3 = 9 then
93403: LD_VAR 0 3
93407: PUSH
93408: LD_INT 9
93410: EQUAL
93411: IFFALSE 93421
// sHack := true ;
93413: LD_ADDR_EXP 131
93417: PUSH
93418: LD_INT 1
93420: ST_TO_ADDR
// if p3 = 10 then
93421: LD_VAR 0 3
93425: PUSH
93426: LD_INT 10
93428: EQUAL
93429: IFFALSE 93439
// sFire := true ;
93431: LD_ADDR_EXP 132
93435: PUSH
93436: LD_INT 1
93438: ST_TO_ADDR
// if p3 = 11 then
93439: LD_VAR 0 3
93443: PUSH
93444: LD_INT 11
93446: EQUAL
93447: IFFALSE 93457
// sRefresh := true ;
93449: LD_ADDR_EXP 133
93453: PUSH
93454: LD_INT 1
93456: ST_TO_ADDR
// if p3 = 12 then
93457: LD_VAR 0 3
93461: PUSH
93462: LD_INT 12
93464: EQUAL
93465: IFFALSE 93475
// sExp := true ;
93467: LD_ADDR_EXP 134
93471: PUSH
93472: LD_INT 1
93474: ST_TO_ADDR
// if p3 = 13 then
93475: LD_VAR 0 3
93479: PUSH
93480: LD_INT 13
93482: EQUAL
93483: IFFALSE 93493
// sDepot := true ;
93485: LD_ADDR_EXP 135
93489: PUSH
93490: LD_INT 1
93492: ST_TO_ADDR
// if p3 = 14 then
93493: LD_VAR 0 3
93497: PUSH
93498: LD_INT 14
93500: EQUAL
93501: IFFALSE 93511
// sFlag := true ;
93503: LD_ADDR_EXP 136
93507: PUSH
93508: LD_INT 1
93510: ST_TO_ADDR
// if p3 = 15 then
93511: LD_VAR 0 3
93515: PUSH
93516: LD_INT 15
93518: EQUAL
93519: IFFALSE 93529
// sKamikadze := true ;
93521: LD_ADDR_EXP 144
93525: PUSH
93526: LD_INT 1
93528: ST_TO_ADDR
// if p3 = 16 then
93529: LD_VAR 0 3
93533: PUSH
93534: LD_INT 16
93536: EQUAL
93537: IFFALSE 93547
// sTroll := true ;
93539: LD_ADDR_EXP 145
93543: PUSH
93544: LD_INT 1
93546: ST_TO_ADDR
// if p3 = 17 then
93547: LD_VAR 0 3
93551: PUSH
93552: LD_INT 17
93554: EQUAL
93555: IFFALSE 93565
// sSlow := true ;
93557: LD_ADDR_EXP 146
93561: PUSH
93562: LD_INT 1
93564: ST_TO_ADDR
// if p3 = 18 then
93565: LD_VAR 0 3
93569: PUSH
93570: LD_INT 18
93572: EQUAL
93573: IFFALSE 93583
// sLack := true ;
93575: LD_ADDR_EXP 147
93579: PUSH
93580: LD_INT 1
93582: ST_TO_ADDR
// if p3 = 19 then
93583: LD_VAR 0 3
93587: PUSH
93588: LD_INT 19
93590: EQUAL
93591: IFFALSE 93601
// sTank := true ;
93593: LD_ADDR_EXP 149
93597: PUSH
93598: LD_INT 1
93600: ST_TO_ADDR
// if p3 = 20 then
93601: LD_VAR 0 3
93605: PUSH
93606: LD_INT 20
93608: EQUAL
93609: IFFALSE 93619
// sRemote := true ;
93611: LD_ADDR_EXP 150
93615: PUSH
93616: LD_INT 1
93618: ST_TO_ADDR
// if p3 = 21 then
93619: LD_VAR 0 3
93623: PUSH
93624: LD_INT 21
93626: EQUAL
93627: IFFALSE 93637
// sPowell := true ;
93629: LD_ADDR_EXP 151
93633: PUSH
93634: LD_INT 1
93636: ST_TO_ADDR
// if p3 = 22 then
93637: LD_VAR 0 3
93641: PUSH
93642: LD_INT 22
93644: EQUAL
93645: IFFALSE 93655
// sTeleport := true ;
93647: LD_ADDR_EXP 154
93651: PUSH
93652: LD_INT 1
93654: ST_TO_ADDR
// if p3 = 23 then
93655: LD_VAR 0 3
93659: PUSH
93660: LD_INT 23
93662: EQUAL
93663: IFFALSE 93673
// sOilTower := true ;
93665: LD_ADDR_EXP 156
93669: PUSH
93670: LD_INT 1
93672: ST_TO_ADDR
// if p3 = 24 then
93673: LD_VAR 0 3
93677: PUSH
93678: LD_INT 24
93680: EQUAL
93681: IFFALSE 93691
// sShovel := true ;
93683: LD_ADDR_EXP 157
93687: PUSH
93688: LD_INT 1
93690: ST_TO_ADDR
// if p3 = 25 then
93691: LD_VAR 0 3
93695: PUSH
93696: LD_INT 25
93698: EQUAL
93699: IFFALSE 93709
// sSheik := true ;
93701: LD_ADDR_EXP 158
93705: PUSH
93706: LD_INT 1
93708: ST_TO_ADDR
// if p3 = 26 then
93709: LD_VAR 0 3
93713: PUSH
93714: LD_INT 26
93716: EQUAL
93717: IFFALSE 93727
// sEarthquake := true ;
93719: LD_ADDR_EXP 160
93723: PUSH
93724: LD_INT 1
93726: ST_TO_ADDR
// if p3 = 27 then
93727: LD_VAR 0 3
93731: PUSH
93732: LD_INT 27
93734: EQUAL
93735: IFFALSE 93745
// sAI := true ;
93737: LD_ADDR_EXP 161
93741: PUSH
93742: LD_INT 1
93744: ST_TO_ADDR
// if p3 = 28 then
93745: LD_VAR 0 3
93749: PUSH
93750: LD_INT 28
93752: EQUAL
93753: IFFALSE 93763
// sCargo := true ;
93755: LD_ADDR_EXP 164
93759: PUSH
93760: LD_INT 1
93762: ST_TO_ADDR
// if p3 = 29 then
93763: LD_VAR 0 3
93767: PUSH
93768: LD_INT 29
93770: EQUAL
93771: IFFALSE 93781
// sDLaser := true ;
93773: LD_ADDR_EXP 165
93777: PUSH
93778: LD_INT 1
93780: ST_TO_ADDR
// if p3 = 30 then
93781: LD_VAR 0 3
93785: PUSH
93786: LD_INT 30
93788: EQUAL
93789: IFFALSE 93799
// sExchange := true ;
93791: LD_ADDR_EXP 166
93795: PUSH
93796: LD_INT 1
93798: ST_TO_ADDR
// if p3 = 31 then
93799: LD_VAR 0 3
93803: PUSH
93804: LD_INT 31
93806: EQUAL
93807: IFFALSE 93817
// sFac := true ;
93809: LD_ADDR_EXP 167
93813: PUSH
93814: LD_INT 1
93816: ST_TO_ADDR
// if p3 = 32 then
93817: LD_VAR 0 3
93821: PUSH
93822: LD_INT 32
93824: EQUAL
93825: IFFALSE 93835
// sPower := true ;
93827: LD_ADDR_EXP 168
93831: PUSH
93832: LD_INT 1
93834: ST_TO_ADDR
// if p3 = 33 then
93835: LD_VAR 0 3
93839: PUSH
93840: LD_INT 33
93842: EQUAL
93843: IFFALSE 93853
// sRandom := true ;
93845: LD_ADDR_EXP 169
93849: PUSH
93850: LD_INT 1
93852: ST_TO_ADDR
// if p3 = 34 then
93853: LD_VAR 0 3
93857: PUSH
93858: LD_INT 34
93860: EQUAL
93861: IFFALSE 93871
// sShield := true ;
93863: LD_ADDR_EXP 170
93867: PUSH
93868: LD_INT 1
93870: ST_TO_ADDR
// if p3 = 35 then
93871: LD_VAR 0 3
93875: PUSH
93876: LD_INT 35
93878: EQUAL
93879: IFFALSE 93889
// sTime := true ;
93881: LD_ADDR_EXP 171
93885: PUSH
93886: LD_INT 1
93888: ST_TO_ADDR
// if p3 = 36 then
93889: LD_VAR 0 3
93893: PUSH
93894: LD_INT 36
93896: EQUAL
93897: IFFALSE 93907
// sTools := true ;
93899: LD_ADDR_EXP 172
93903: PUSH
93904: LD_INT 1
93906: ST_TO_ADDR
// if p3 = 101 then
93907: LD_VAR 0 3
93911: PUSH
93912: LD_INT 101
93914: EQUAL
93915: IFFALSE 93925
// sSold := true ;
93917: LD_ADDR_EXP 137
93921: PUSH
93922: LD_INT 1
93924: ST_TO_ADDR
// if p3 = 102 then
93925: LD_VAR 0 3
93929: PUSH
93930: LD_INT 102
93932: EQUAL
93933: IFFALSE 93943
// sDiff := true ;
93935: LD_ADDR_EXP 138
93939: PUSH
93940: LD_INT 1
93942: ST_TO_ADDR
// if p3 = 103 then
93943: LD_VAR 0 3
93947: PUSH
93948: LD_INT 103
93950: EQUAL
93951: IFFALSE 93961
// sFog := true ;
93953: LD_ADDR_EXP 141
93957: PUSH
93958: LD_INT 1
93960: ST_TO_ADDR
// if p3 = 104 then
93961: LD_VAR 0 3
93965: PUSH
93966: LD_INT 104
93968: EQUAL
93969: IFFALSE 93979
// sReset := true ;
93971: LD_ADDR_EXP 142
93975: PUSH
93976: LD_INT 1
93978: ST_TO_ADDR
// if p3 = 105 then
93979: LD_VAR 0 3
93983: PUSH
93984: LD_INT 105
93986: EQUAL
93987: IFFALSE 93997
// sSun := true ;
93989: LD_ADDR_EXP 143
93993: PUSH
93994: LD_INT 1
93996: ST_TO_ADDR
// if p3 = 106 then
93997: LD_VAR 0 3
94001: PUSH
94002: LD_INT 106
94004: EQUAL
94005: IFFALSE 94015
// sTiger := true ;
94007: LD_ADDR_EXP 139
94011: PUSH
94012: LD_INT 1
94014: ST_TO_ADDR
// if p3 = 107 then
94015: LD_VAR 0 3
94019: PUSH
94020: LD_INT 107
94022: EQUAL
94023: IFFALSE 94033
// sBomb := true ;
94025: LD_ADDR_EXP 140
94029: PUSH
94030: LD_INT 1
94032: ST_TO_ADDR
// if p3 = 108 then
94033: LD_VAR 0 3
94037: PUSH
94038: LD_INT 108
94040: EQUAL
94041: IFFALSE 94051
// sWound := true ;
94043: LD_ADDR_EXP 148
94047: PUSH
94048: LD_INT 1
94050: ST_TO_ADDR
// if p3 = 109 then
94051: LD_VAR 0 3
94055: PUSH
94056: LD_INT 109
94058: EQUAL
94059: IFFALSE 94069
// sBetray := true ;
94061: LD_ADDR_EXP 152
94065: PUSH
94066: LD_INT 1
94068: ST_TO_ADDR
// if p3 = 110 then
94069: LD_VAR 0 3
94073: PUSH
94074: LD_INT 110
94076: EQUAL
94077: IFFALSE 94087
// sContamin := true ;
94079: LD_ADDR_EXP 153
94083: PUSH
94084: LD_INT 1
94086: ST_TO_ADDR
// if p3 = 111 then
94087: LD_VAR 0 3
94091: PUSH
94092: LD_INT 111
94094: EQUAL
94095: IFFALSE 94105
// sOil := true ;
94097: LD_ADDR_EXP 155
94101: PUSH
94102: LD_INT 1
94104: ST_TO_ADDR
// if p3 = 112 then
94105: LD_VAR 0 3
94109: PUSH
94110: LD_INT 112
94112: EQUAL
94113: IFFALSE 94123
// sStu := true ;
94115: LD_ADDR_EXP 159
94119: PUSH
94120: LD_INT 1
94122: ST_TO_ADDR
// if p3 = 113 then
94123: LD_VAR 0 3
94127: PUSH
94128: LD_INT 113
94130: EQUAL
94131: IFFALSE 94141
// sBazooka := true ;
94133: LD_ADDR_EXP 162
94137: PUSH
94138: LD_INT 1
94140: ST_TO_ADDR
// if p3 = 114 then
94141: LD_VAR 0 3
94145: PUSH
94146: LD_INT 114
94148: EQUAL
94149: IFFALSE 94159
// sMortar := true ;
94151: LD_ADDR_EXP 163
94155: PUSH
94156: LD_INT 1
94158: ST_TO_ADDR
// if p3 = 115 then
94159: LD_VAR 0 3
94163: PUSH
94164: LD_INT 115
94166: EQUAL
94167: IFFALSE 94177
// sRanger := true ;
94169: LD_ADDR_EXP 173
94173: PUSH
94174: LD_INT 1
94176: ST_TO_ADDR
// if p3 = 116 then
94177: LD_VAR 0 3
94181: PUSH
94182: LD_INT 116
94184: EQUAL
94185: IFFALSE 94195
// sComputer := true ;
94187: LD_ADDR_EXP 174
94191: PUSH
94192: LD_INT 1
94194: ST_TO_ADDR
// if p3 = 117 then
94195: LD_VAR 0 3
94199: PUSH
94200: LD_INT 117
94202: EQUAL
94203: IFFALSE 94213
// s30 := true ;
94205: LD_ADDR_EXP 175
94209: PUSH
94210: LD_INT 1
94212: ST_TO_ADDR
// if p3 = 118 then
94213: LD_VAR 0 3
94217: PUSH
94218: LD_INT 118
94220: EQUAL
94221: IFFALSE 94231
// s60 := true ;
94223: LD_ADDR_EXP 176
94227: PUSH
94228: LD_INT 1
94230: ST_TO_ADDR
// end ; if p2 = 101 then
94231: LD_VAR 0 2
94235: PUSH
94236: LD_INT 101
94238: EQUAL
94239: IFFALSE 94367
// begin case p3 of 1 :
94241: LD_VAR 0 3
94245: PUSH
94246: LD_INT 1
94248: DOUBLE
94249: EQUAL
94250: IFTRUE 94254
94252: GO 94261
94254: POP
// hHackUnlimitedResources ; 2 :
94255: CALL 106465 0 0
94259: GO 94367
94261: LD_INT 2
94263: DOUBLE
94264: EQUAL
94265: IFTRUE 94269
94267: GO 94276
94269: POP
// hHackSetLevel10 ; 3 :
94270: CALL 106598 0 0
94274: GO 94367
94276: LD_INT 3
94278: DOUBLE
94279: EQUAL
94280: IFTRUE 94284
94282: GO 94291
94284: POP
// hHackSetLevel10YourUnits ; 4 :
94285: CALL 106683 0 0
94289: GO 94367
94291: LD_INT 4
94293: DOUBLE
94294: EQUAL
94295: IFTRUE 94299
94297: GO 94306
94299: POP
// hHackInvincible ; 5 :
94300: CALL 107131 0 0
94304: GO 94367
94306: LD_INT 5
94308: DOUBLE
94309: EQUAL
94310: IFTRUE 94314
94312: GO 94321
94314: POP
// hHackInvisible ; 6 :
94315: CALL 107242 0 0
94319: GO 94367
94321: LD_INT 6
94323: DOUBLE
94324: EQUAL
94325: IFTRUE 94329
94327: GO 94336
94329: POP
// hHackChangeYourSide ; 7 :
94330: CALL 107299 0 0
94334: GO 94367
94336: LD_INT 7
94338: DOUBLE
94339: EQUAL
94340: IFTRUE 94344
94342: GO 94351
94344: POP
// hHackChangeUnitSide ; 8 :
94345: CALL 107341 0 0
94349: GO 94367
94351: LD_INT 8
94353: DOUBLE
94354: EQUAL
94355: IFTRUE 94359
94357: GO 94366
94359: POP
// hHackFog ; end ;
94360: CALL 107442 0 0
94364: GO 94367
94366: POP
// end ; end ;
94367: LD_VAR 0 7
94371: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
94372: GO 94374
94374: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
94375: LD_STRING initStreamRollete();
94377: PPUSH
94378: CALL_OW 559
// InitStreamMode ;
94382: CALL 94394 0 0
// DefineStreamItems ( false ) ;
94386: LD_INT 0
94388: PPUSH
94389: CALL 94858 0 1
// end ;
94393: END
// function InitStreamMode ; begin
94394: LD_INT 0
94396: PPUSH
// streamModeActive := false ;
94397: LD_ADDR_EXP 120
94401: PUSH
94402: LD_INT 0
94404: ST_TO_ADDR
// normalCounter := 36 ;
94405: LD_ADDR_EXP 121
94409: PUSH
94410: LD_INT 36
94412: ST_TO_ADDR
// hardcoreCounter := 18 ;
94413: LD_ADDR_EXP 122
94417: PUSH
94418: LD_INT 18
94420: ST_TO_ADDR
// sRocket := false ;
94421: LD_ADDR_EXP 125
94425: PUSH
94426: LD_INT 0
94428: ST_TO_ADDR
// sSpeed := false ;
94429: LD_ADDR_EXP 124
94433: PUSH
94434: LD_INT 0
94436: ST_TO_ADDR
// sEngine := false ;
94437: LD_ADDR_EXP 126
94441: PUSH
94442: LD_INT 0
94444: ST_TO_ADDR
// sSpec := false ;
94445: LD_ADDR_EXP 123
94449: PUSH
94450: LD_INT 0
94452: ST_TO_ADDR
// sLevel := false ;
94453: LD_ADDR_EXP 127
94457: PUSH
94458: LD_INT 0
94460: ST_TO_ADDR
// sArmoury := false ;
94461: LD_ADDR_EXP 128
94465: PUSH
94466: LD_INT 0
94468: ST_TO_ADDR
// sRadar := false ;
94469: LD_ADDR_EXP 129
94473: PUSH
94474: LD_INT 0
94476: ST_TO_ADDR
// sBunker := false ;
94477: LD_ADDR_EXP 130
94481: PUSH
94482: LD_INT 0
94484: ST_TO_ADDR
// sHack := false ;
94485: LD_ADDR_EXP 131
94489: PUSH
94490: LD_INT 0
94492: ST_TO_ADDR
// sFire := false ;
94493: LD_ADDR_EXP 132
94497: PUSH
94498: LD_INT 0
94500: ST_TO_ADDR
// sRefresh := false ;
94501: LD_ADDR_EXP 133
94505: PUSH
94506: LD_INT 0
94508: ST_TO_ADDR
// sExp := false ;
94509: LD_ADDR_EXP 134
94513: PUSH
94514: LD_INT 0
94516: ST_TO_ADDR
// sDepot := false ;
94517: LD_ADDR_EXP 135
94521: PUSH
94522: LD_INT 0
94524: ST_TO_ADDR
// sFlag := false ;
94525: LD_ADDR_EXP 136
94529: PUSH
94530: LD_INT 0
94532: ST_TO_ADDR
// sKamikadze := false ;
94533: LD_ADDR_EXP 144
94537: PUSH
94538: LD_INT 0
94540: ST_TO_ADDR
// sTroll := false ;
94541: LD_ADDR_EXP 145
94545: PUSH
94546: LD_INT 0
94548: ST_TO_ADDR
// sSlow := false ;
94549: LD_ADDR_EXP 146
94553: PUSH
94554: LD_INT 0
94556: ST_TO_ADDR
// sLack := false ;
94557: LD_ADDR_EXP 147
94561: PUSH
94562: LD_INT 0
94564: ST_TO_ADDR
// sTank := false ;
94565: LD_ADDR_EXP 149
94569: PUSH
94570: LD_INT 0
94572: ST_TO_ADDR
// sRemote := false ;
94573: LD_ADDR_EXP 150
94577: PUSH
94578: LD_INT 0
94580: ST_TO_ADDR
// sPowell := false ;
94581: LD_ADDR_EXP 151
94585: PUSH
94586: LD_INT 0
94588: ST_TO_ADDR
// sTeleport := false ;
94589: LD_ADDR_EXP 154
94593: PUSH
94594: LD_INT 0
94596: ST_TO_ADDR
// sOilTower := false ;
94597: LD_ADDR_EXP 156
94601: PUSH
94602: LD_INT 0
94604: ST_TO_ADDR
// sShovel := false ;
94605: LD_ADDR_EXP 157
94609: PUSH
94610: LD_INT 0
94612: ST_TO_ADDR
// sSheik := false ;
94613: LD_ADDR_EXP 158
94617: PUSH
94618: LD_INT 0
94620: ST_TO_ADDR
// sEarthquake := false ;
94621: LD_ADDR_EXP 160
94625: PUSH
94626: LD_INT 0
94628: ST_TO_ADDR
// sAI := false ;
94629: LD_ADDR_EXP 161
94633: PUSH
94634: LD_INT 0
94636: ST_TO_ADDR
// sCargo := false ;
94637: LD_ADDR_EXP 164
94641: PUSH
94642: LD_INT 0
94644: ST_TO_ADDR
// sDLaser := false ;
94645: LD_ADDR_EXP 165
94649: PUSH
94650: LD_INT 0
94652: ST_TO_ADDR
// sExchange := false ;
94653: LD_ADDR_EXP 166
94657: PUSH
94658: LD_INT 0
94660: ST_TO_ADDR
// sFac := false ;
94661: LD_ADDR_EXP 167
94665: PUSH
94666: LD_INT 0
94668: ST_TO_ADDR
// sPower := false ;
94669: LD_ADDR_EXP 168
94673: PUSH
94674: LD_INT 0
94676: ST_TO_ADDR
// sRandom := false ;
94677: LD_ADDR_EXP 169
94681: PUSH
94682: LD_INT 0
94684: ST_TO_ADDR
// sShield := false ;
94685: LD_ADDR_EXP 170
94689: PUSH
94690: LD_INT 0
94692: ST_TO_ADDR
// sTime := false ;
94693: LD_ADDR_EXP 171
94697: PUSH
94698: LD_INT 0
94700: ST_TO_ADDR
// sTools := false ;
94701: LD_ADDR_EXP 172
94705: PUSH
94706: LD_INT 0
94708: ST_TO_ADDR
// sSold := false ;
94709: LD_ADDR_EXP 137
94713: PUSH
94714: LD_INT 0
94716: ST_TO_ADDR
// sDiff := false ;
94717: LD_ADDR_EXP 138
94721: PUSH
94722: LD_INT 0
94724: ST_TO_ADDR
// sFog := false ;
94725: LD_ADDR_EXP 141
94729: PUSH
94730: LD_INT 0
94732: ST_TO_ADDR
// sReset := false ;
94733: LD_ADDR_EXP 142
94737: PUSH
94738: LD_INT 0
94740: ST_TO_ADDR
// sSun := false ;
94741: LD_ADDR_EXP 143
94745: PUSH
94746: LD_INT 0
94748: ST_TO_ADDR
// sTiger := false ;
94749: LD_ADDR_EXP 139
94753: PUSH
94754: LD_INT 0
94756: ST_TO_ADDR
// sBomb := false ;
94757: LD_ADDR_EXP 140
94761: PUSH
94762: LD_INT 0
94764: ST_TO_ADDR
// sWound := false ;
94765: LD_ADDR_EXP 148
94769: PUSH
94770: LD_INT 0
94772: ST_TO_ADDR
// sBetray := false ;
94773: LD_ADDR_EXP 152
94777: PUSH
94778: LD_INT 0
94780: ST_TO_ADDR
// sContamin := false ;
94781: LD_ADDR_EXP 153
94785: PUSH
94786: LD_INT 0
94788: ST_TO_ADDR
// sOil := false ;
94789: LD_ADDR_EXP 155
94793: PUSH
94794: LD_INT 0
94796: ST_TO_ADDR
// sStu := false ;
94797: LD_ADDR_EXP 159
94801: PUSH
94802: LD_INT 0
94804: ST_TO_ADDR
// sBazooka := false ;
94805: LD_ADDR_EXP 162
94809: PUSH
94810: LD_INT 0
94812: ST_TO_ADDR
// sMortar := false ;
94813: LD_ADDR_EXP 163
94817: PUSH
94818: LD_INT 0
94820: ST_TO_ADDR
// sRanger := false ;
94821: LD_ADDR_EXP 173
94825: PUSH
94826: LD_INT 0
94828: ST_TO_ADDR
// sComputer := false ;
94829: LD_ADDR_EXP 174
94833: PUSH
94834: LD_INT 0
94836: ST_TO_ADDR
// s30 := false ;
94837: LD_ADDR_EXP 175
94841: PUSH
94842: LD_INT 0
94844: ST_TO_ADDR
// s60 := false ;
94845: LD_ADDR_EXP 176
94849: PUSH
94850: LD_INT 0
94852: ST_TO_ADDR
// end ;
94853: LD_VAR 0 1
94857: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
94858: LD_INT 0
94860: PPUSH
94861: PPUSH
94862: PPUSH
94863: PPUSH
94864: PPUSH
94865: PPUSH
94866: PPUSH
// result := [ ] ;
94867: LD_ADDR_VAR 0 2
94871: PUSH
94872: EMPTY
94873: ST_TO_ADDR
// if campaign_id = 1 then
94874: LD_OWVAR 69
94878: PUSH
94879: LD_INT 1
94881: EQUAL
94882: IFFALSE 98048
// begin case mission_number of 1 :
94884: LD_OWVAR 70
94888: PUSH
94889: LD_INT 1
94891: DOUBLE
94892: EQUAL
94893: IFTRUE 94897
94895: GO 94973
94897: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
94898: LD_ADDR_VAR 0 2
94902: PUSH
94903: LD_INT 2
94905: PUSH
94906: LD_INT 4
94908: PUSH
94909: LD_INT 11
94911: PUSH
94912: LD_INT 12
94914: PUSH
94915: LD_INT 15
94917: PUSH
94918: LD_INT 16
94920: PUSH
94921: LD_INT 22
94923: PUSH
94924: LD_INT 23
94926: PUSH
94927: LD_INT 26
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: PUSH
94941: LD_INT 101
94943: PUSH
94944: LD_INT 102
94946: PUSH
94947: LD_INT 106
94949: PUSH
94950: LD_INT 116
94952: PUSH
94953: LD_INT 117
94955: PUSH
94956: LD_INT 118
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: ST_TO_ADDR
94971: GO 98046
94973: LD_INT 2
94975: DOUBLE
94976: EQUAL
94977: IFTRUE 94981
94979: GO 95065
94981: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
94982: LD_ADDR_VAR 0 2
94986: PUSH
94987: LD_INT 2
94989: PUSH
94990: LD_INT 4
94992: PUSH
94993: LD_INT 11
94995: PUSH
94996: LD_INT 12
94998: PUSH
94999: LD_INT 15
95001: PUSH
95002: LD_INT 16
95004: PUSH
95005: LD_INT 22
95007: PUSH
95008: LD_INT 23
95010: PUSH
95011: LD_INT 26
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: PUSH
95025: LD_INT 101
95027: PUSH
95028: LD_INT 102
95030: PUSH
95031: LD_INT 105
95033: PUSH
95034: LD_INT 106
95036: PUSH
95037: LD_INT 108
95039: PUSH
95040: LD_INT 116
95042: PUSH
95043: LD_INT 117
95045: PUSH
95046: LD_INT 118
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: ST_TO_ADDR
95063: GO 98046
95065: LD_INT 3
95067: DOUBLE
95068: EQUAL
95069: IFTRUE 95073
95071: GO 95161
95073: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95074: LD_ADDR_VAR 0 2
95078: PUSH
95079: LD_INT 2
95081: PUSH
95082: LD_INT 4
95084: PUSH
95085: LD_INT 5
95087: PUSH
95088: LD_INT 11
95090: PUSH
95091: LD_INT 12
95093: PUSH
95094: LD_INT 15
95096: PUSH
95097: LD_INT 16
95099: PUSH
95100: LD_INT 22
95102: PUSH
95103: LD_INT 26
95105: PUSH
95106: LD_INT 36
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: PUSH
95121: LD_INT 101
95123: PUSH
95124: LD_INT 102
95126: PUSH
95127: LD_INT 105
95129: PUSH
95130: LD_INT 106
95132: PUSH
95133: LD_INT 108
95135: PUSH
95136: LD_INT 116
95138: PUSH
95139: LD_INT 117
95141: PUSH
95142: LD_INT 118
95144: PUSH
95145: EMPTY
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: ST_TO_ADDR
95159: GO 98046
95161: LD_INT 4
95163: DOUBLE
95164: EQUAL
95165: IFTRUE 95169
95167: GO 95265
95169: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95170: LD_ADDR_VAR 0 2
95174: PUSH
95175: LD_INT 2
95177: PUSH
95178: LD_INT 4
95180: PUSH
95181: LD_INT 5
95183: PUSH
95184: LD_INT 8
95186: PUSH
95187: LD_INT 11
95189: PUSH
95190: LD_INT 12
95192: PUSH
95193: LD_INT 15
95195: PUSH
95196: LD_INT 16
95198: PUSH
95199: LD_INT 22
95201: PUSH
95202: LD_INT 23
95204: PUSH
95205: LD_INT 26
95207: PUSH
95208: LD_INT 36
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 101
95227: PUSH
95228: LD_INT 102
95230: PUSH
95231: LD_INT 105
95233: PUSH
95234: LD_INT 106
95236: PUSH
95237: LD_INT 108
95239: PUSH
95240: LD_INT 116
95242: PUSH
95243: LD_INT 117
95245: PUSH
95246: LD_INT 118
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: ST_TO_ADDR
95263: GO 98046
95265: LD_INT 5
95267: DOUBLE
95268: EQUAL
95269: IFTRUE 95273
95271: GO 95385
95273: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95274: LD_ADDR_VAR 0 2
95278: PUSH
95279: LD_INT 2
95281: PUSH
95282: LD_INT 4
95284: PUSH
95285: LD_INT 5
95287: PUSH
95288: LD_INT 6
95290: PUSH
95291: LD_INT 8
95293: PUSH
95294: LD_INT 11
95296: PUSH
95297: LD_INT 12
95299: PUSH
95300: LD_INT 15
95302: PUSH
95303: LD_INT 16
95305: PUSH
95306: LD_INT 22
95308: PUSH
95309: LD_INT 23
95311: PUSH
95312: LD_INT 25
95314: PUSH
95315: LD_INT 26
95317: PUSH
95318: LD_INT 36
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: PUSH
95337: LD_INT 101
95339: PUSH
95340: LD_INT 102
95342: PUSH
95343: LD_INT 105
95345: PUSH
95346: LD_INT 106
95348: PUSH
95349: LD_INT 108
95351: PUSH
95352: LD_INT 109
95354: PUSH
95355: LD_INT 112
95357: PUSH
95358: LD_INT 116
95360: PUSH
95361: LD_INT 117
95363: PUSH
95364: LD_INT 118
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: PUSH
95379: EMPTY
95380: LIST
95381: LIST
95382: ST_TO_ADDR
95383: GO 98046
95385: LD_INT 6
95387: DOUBLE
95388: EQUAL
95389: IFTRUE 95393
95391: GO 95525
95393: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95394: LD_ADDR_VAR 0 2
95398: PUSH
95399: LD_INT 2
95401: PUSH
95402: LD_INT 4
95404: PUSH
95405: LD_INT 5
95407: PUSH
95408: LD_INT 6
95410: PUSH
95411: LD_INT 8
95413: PUSH
95414: LD_INT 11
95416: PUSH
95417: LD_INT 12
95419: PUSH
95420: LD_INT 15
95422: PUSH
95423: LD_INT 16
95425: PUSH
95426: LD_INT 20
95428: PUSH
95429: LD_INT 21
95431: PUSH
95432: LD_INT 22
95434: PUSH
95435: LD_INT 23
95437: PUSH
95438: LD_INT 25
95440: PUSH
95441: LD_INT 26
95443: PUSH
95444: LD_INT 30
95446: PUSH
95447: LD_INT 31
95449: PUSH
95450: LD_INT 32
95452: PUSH
95453: LD_INT 36
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: PUSH
95477: LD_INT 101
95479: PUSH
95480: LD_INT 102
95482: PUSH
95483: LD_INT 105
95485: PUSH
95486: LD_INT 106
95488: PUSH
95489: LD_INT 108
95491: PUSH
95492: LD_INT 109
95494: PUSH
95495: LD_INT 112
95497: PUSH
95498: LD_INT 116
95500: PUSH
95501: LD_INT 117
95503: PUSH
95504: LD_INT 118
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: ST_TO_ADDR
95523: GO 98046
95525: LD_INT 7
95527: DOUBLE
95528: EQUAL
95529: IFTRUE 95533
95531: GO 95645
95533: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95534: LD_ADDR_VAR 0 2
95538: PUSH
95539: LD_INT 2
95541: PUSH
95542: LD_INT 4
95544: PUSH
95545: LD_INT 5
95547: PUSH
95548: LD_INT 7
95550: PUSH
95551: LD_INT 11
95553: PUSH
95554: LD_INT 12
95556: PUSH
95557: LD_INT 15
95559: PUSH
95560: LD_INT 16
95562: PUSH
95563: LD_INT 20
95565: PUSH
95566: LD_INT 21
95568: PUSH
95569: LD_INT 22
95571: PUSH
95572: LD_INT 23
95574: PUSH
95575: LD_INT 25
95577: PUSH
95578: LD_INT 26
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: PUSH
95597: LD_INT 101
95599: PUSH
95600: LD_INT 102
95602: PUSH
95603: LD_INT 103
95605: PUSH
95606: LD_INT 105
95608: PUSH
95609: LD_INT 106
95611: PUSH
95612: LD_INT 108
95614: PUSH
95615: LD_INT 112
95617: PUSH
95618: LD_INT 116
95620: PUSH
95621: LD_INT 117
95623: PUSH
95624: LD_INT 118
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: ST_TO_ADDR
95643: GO 98046
95645: LD_INT 8
95647: DOUBLE
95648: EQUAL
95649: IFTRUE 95653
95651: GO 95793
95653: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95654: LD_ADDR_VAR 0 2
95658: PUSH
95659: LD_INT 2
95661: PUSH
95662: LD_INT 4
95664: PUSH
95665: LD_INT 5
95667: PUSH
95668: LD_INT 6
95670: PUSH
95671: LD_INT 7
95673: PUSH
95674: LD_INT 8
95676: PUSH
95677: LD_INT 11
95679: PUSH
95680: LD_INT 12
95682: PUSH
95683: LD_INT 15
95685: PUSH
95686: LD_INT 16
95688: PUSH
95689: LD_INT 20
95691: PUSH
95692: LD_INT 21
95694: PUSH
95695: LD_INT 22
95697: PUSH
95698: LD_INT 23
95700: PUSH
95701: LD_INT 25
95703: PUSH
95704: LD_INT 26
95706: PUSH
95707: LD_INT 30
95709: PUSH
95710: LD_INT 31
95712: PUSH
95713: LD_INT 32
95715: PUSH
95716: LD_INT 36
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: PUSH
95741: LD_INT 101
95743: PUSH
95744: LD_INT 102
95746: PUSH
95747: LD_INT 103
95749: PUSH
95750: LD_INT 105
95752: PUSH
95753: LD_INT 106
95755: PUSH
95756: LD_INT 108
95758: PUSH
95759: LD_INT 109
95761: PUSH
95762: LD_INT 112
95764: PUSH
95765: LD_INT 116
95767: PUSH
95768: LD_INT 117
95770: PUSH
95771: LD_INT 118
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: ST_TO_ADDR
95791: GO 98046
95793: LD_INT 9
95795: DOUBLE
95796: EQUAL
95797: IFTRUE 95801
95799: GO 95949
95801: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95802: LD_ADDR_VAR 0 2
95806: PUSH
95807: LD_INT 2
95809: PUSH
95810: LD_INT 4
95812: PUSH
95813: LD_INT 5
95815: PUSH
95816: LD_INT 6
95818: PUSH
95819: LD_INT 7
95821: PUSH
95822: LD_INT 8
95824: PUSH
95825: LD_INT 11
95827: PUSH
95828: LD_INT 12
95830: PUSH
95831: LD_INT 15
95833: PUSH
95834: LD_INT 16
95836: PUSH
95837: LD_INT 20
95839: PUSH
95840: LD_INT 21
95842: PUSH
95843: LD_INT 22
95845: PUSH
95846: LD_INT 23
95848: PUSH
95849: LD_INT 25
95851: PUSH
95852: LD_INT 26
95854: PUSH
95855: LD_INT 28
95857: PUSH
95858: LD_INT 30
95860: PUSH
95861: LD_INT 31
95863: PUSH
95864: LD_INT 32
95866: PUSH
95867: LD_INT 36
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: PUSH
95893: LD_INT 101
95895: PUSH
95896: LD_INT 102
95898: PUSH
95899: LD_INT 103
95901: PUSH
95902: LD_INT 105
95904: PUSH
95905: LD_INT 106
95907: PUSH
95908: LD_INT 108
95910: PUSH
95911: LD_INT 109
95913: PUSH
95914: LD_INT 112
95916: PUSH
95917: LD_INT 114
95919: PUSH
95920: LD_INT 116
95922: PUSH
95923: LD_INT 117
95925: PUSH
95926: LD_INT 118
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: PUSH
95943: EMPTY
95944: LIST
95945: LIST
95946: ST_TO_ADDR
95947: GO 98046
95949: LD_INT 10
95951: DOUBLE
95952: EQUAL
95953: IFTRUE 95957
95955: GO 96153
95957: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
95958: LD_ADDR_VAR 0 2
95962: PUSH
95963: LD_INT 2
95965: PUSH
95966: LD_INT 4
95968: PUSH
95969: LD_INT 5
95971: PUSH
95972: LD_INT 6
95974: PUSH
95975: LD_INT 7
95977: PUSH
95978: LD_INT 8
95980: PUSH
95981: LD_INT 9
95983: PUSH
95984: LD_INT 10
95986: PUSH
95987: LD_INT 11
95989: PUSH
95990: LD_INT 12
95992: PUSH
95993: LD_INT 13
95995: PUSH
95996: LD_INT 14
95998: PUSH
95999: LD_INT 15
96001: PUSH
96002: LD_INT 16
96004: PUSH
96005: LD_INT 17
96007: PUSH
96008: LD_INT 18
96010: PUSH
96011: LD_INT 19
96013: PUSH
96014: LD_INT 20
96016: PUSH
96017: LD_INT 21
96019: PUSH
96020: LD_INT 22
96022: PUSH
96023: LD_INT 23
96025: PUSH
96026: LD_INT 24
96028: PUSH
96029: LD_INT 25
96031: PUSH
96032: LD_INT 26
96034: PUSH
96035: LD_INT 28
96037: PUSH
96038: LD_INT 30
96040: PUSH
96041: LD_INT 31
96043: PUSH
96044: LD_INT 32
96046: PUSH
96047: LD_INT 36
96049: PUSH
96050: EMPTY
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: PUSH
96081: LD_INT 101
96083: PUSH
96084: LD_INT 102
96086: PUSH
96087: LD_INT 103
96089: PUSH
96090: LD_INT 104
96092: PUSH
96093: LD_INT 105
96095: PUSH
96096: LD_INT 106
96098: PUSH
96099: LD_INT 107
96101: PUSH
96102: LD_INT 108
96104: PUSH
96105: LD_INT 109
96107: PUSH
96108: LD_INT 110
96110: PUSH
96111: LD_INT 111
96113: PUSH
96114: LD_INT 112
96116: PUSH
96117: LD_INT 114
96119: PUSH
96120: LD_INT 116
96122: PUSH
96123: LD_INT 117
96125: PUSH
96126: LD_INT 118
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: ST_TO_ADDR
96151: GO 98046
96153: LD_INT 11
96155: DOUBLE
96156: EQUAL
96157: IFTRUE 96161
96159: GO 96365
96161: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96162: LD_ADDR_VAR 0 2
96166: PUSH
96167: LD_INT 2
96169: PUSH
96170: LD_INT 3
96172: PUSH
96173: LD_INT 4
96175: PUSH
96176: LD_INT 5
96178: PUSH
96179: LD_INT 6
96181: PUSH
96182: LD_INT 7
96184: PUSH
96185: LD_INT 8
96187: PUSH
96188: LD_INT 9
96190: PUSH
96191: LD_INT 10
96193: PUSH
96194: LD_INT 11
96196: PUSH
96197: LD_INT 12
96199: PUSH
96200: LD_INT 13
96202: PUSH
96203: LD_INT 14
96205: PUSH
96206: LD_INT 15
96208: PUSH
96209: LD_INT 16
96211: PUSH
96212: LD_INT 17
96214: PUSH
96215: LD_INT 18
96217: PUSH
96218: LD_INT 19
96220: PUSH
96221: LD_INT 20
96223: PUSH
96224: LD_INT 21
96226: PUSH
96227: LD_INT 22
96229: PUSH
96230: LD_INT 23
96232: PUSH
96233: LD_INT 24
96235: PUSH
96236: LD_INT 25
96238: PUSH
96239: LD_INT 26
96241: PUSH
96242: LD_INT 28
96244: PUSH
96245: LD_INT 30
96247: PUSH
96248: LD_INT 31
96250: PUSH
96251: LD_INT 32
96253: PUSH
96254: LD_INT 34
96256: PUSH
96257: LD_INT 36
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 101
96295: PUSH
96296: LD_INT 102
96298: PUSH
96299: LD_INT 103
96301: PUSH
96302: LD_INT 104
96304: PUSH
96305: LD_INT 105
96307: PUSH
96308: LD_INT 106
96310: PUSH
96311: LD_INT 107
96313: PUSH
96314: LD_INT 108
96316: PUSH
96317: LD_INT 109
96319: PUSH
96320: LD_INT 110
96322: PUSH
96323: LD_INT 111
96325: PUSH
96326: LD_INT 112
96328: PUSH
96329: LD_INT 114
96331: PUSH
96332: LD_INT 116
96334: PUSH
96335: LD_INT 117
96337: PUSH
96338: LD_INT 118
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: ST_TO_ADDR
96363: GO 98046
96365: LD_INT 12
96367: DOUBLE
96368: EQUAL
96369: IFTRUE 96373
96371: GO 96593
96373: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96374: LD_ADDR_VAR 0 2
96378: PUSH
96379: LD_INT 1
96381: PUSH
96382: LD_INT 2
96384: PUSH
96385: LD_INT 3
96387: PUSH
96388: LD_INT 4
96390: PUSH
96391: LD_INT 5
96393: PUSH
96394: LD_INT 6
96396: PUSH
96397: LD_INT 7
96399: PUSH
96400: LD_INT 8
96402: PUSH
96403: LD_INT 9
96405: PUSH
96406: LD_INT 10
96408: PUSH
96409: LD_INT 11
96411: PUSH
96412: LD_INT 12
96414: PUSH
96415: LD_INT 13
96417: PUSH
96418: LD_INT 14
96420: PUSH
96421: LD_INT 15
96423: PUSH
96424: LD_INT 16
96426: PUSH
96427: LD_INT 17
96429: PUSH
96430: LD_INT 18
96432: PUSH
96433: LD_INT 19
96435: PUSH
96436: LD_INT 20
96438: PUSH
96439: LD_INT 21
96441: PUSH
96442: LD_INT 22
96444: PUSH
96445: LD_INT 23
96447: PUSH
96448: LD_INT 24
96450: PUSH
96451: LD_INT 25
96453: PUSH
96454: LD_INT 26
96456: PUSH
96457: LD_INT 27
96459: PUSH
96460: LD_INT 28
96462: PUSH
96463: LD_INT 30
96465: PUSH
96466: LD_INT 31
96468: PUSH
96469: LD_INT 32
96471: PUSH
96472: LD_INT 33
96474: PUSH
96475: LD_INT 34
96477: PUSH
96478: LD_INT 36
96480: PUSH
96481: EMPTY
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: PUSH
96517: LD_INT 101
96519: PUSH
96520: LD_INT 102
96522: PUSH
96523: LD_INT 103
96525: PUSH
96526: LD_INT 104
96528: PUSH
96529: LD_INT 105
96531: PUSH
96532: LD_INT 106
96534: PUSH
96535: LD_INT 107
96537: PUSH
96538: LD_INT 108
96540: PUSH
96541: LD_INT 109
96543: PUSH
96544: LD_INT 110
96546: PUSH
96547: LD_INT 111
96549: PUSH
96550: LD_INT 112
96552: PUSH
96553: LD_INT 113
96555: PUSH
96556: LD_INT 114
96558: PUSH
96559: LD_INT 116
96561: PUSH
96562: LD_INT 117
96564: PUSH
96565: LD_INT 118
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: ST_TO_ADDR
96591: GO 98046
96593: LD_INT 13
96595: DOUBLE
96596: EQUAL
96597: IFTRUE 96601
96599: GO 96809
96601: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96602: LD_ADDR_VAR 0 2
96606: PUSH
96607: LD_INT 1
96609: PUSH
96610: LD_INT 2
96612: PUSH
96613: LD_INT 3
96615: PUSH
96616: LD_INT 4
96618: PUSH
96619: LD_INT 5
96621: PUSH
96622: LD_INT 8
96624: PUSH
96625: LD_INT 9
96627: PUSH
96628: LD_INT 10
96630: PUSH
96631: LD_INT 11
96633: PUSH
96634: LD_INT 12
96636: PUSH
96637: LD_INT 14
96639: PUSH
96640: LD_INT 15
96642: PUSH
96643: LD_INT 16
96645: PUSH
96646: LD_INT 17
96648: PUSH
96649: LD_INT 18
96651: PUSH
96652: LD_INT 19
96654: PUSH
96655: LD_INT 20
96657: PUSH
96658: LD_INT 21
96660: PUSH
96661: LD_INT 22
96663: PUSH
96664: LD_INT 23
96666: PUSH
96667: LD_INT 24
96669: PUSH
96670: LD_INT 25
96672: PUSH
96673: LD_INT 26
96675: PUSH
96676: LD_INT 27
96678: PUSH
96679: LD_INT 28
96681: PUSH
96682: LD_INT 30
96684: PUSH
96685: LD_INT 31
96687: PUSH
96688: LD_INT 32
96690: PUSH
96691: LD_INT 33
96693: PUSH
96694: LD_INT 34
96696: PUSH
96697: LD_INT 36
96699: PUSH
96700: EMPTY
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: LIST
96718: LIST
96719: LIST
96720: LIST
96721: LIST
96722: LIST
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: PUSH
96733: LD_INT 101
96735: PUSH
96736: LD_INT 102
96738: PUSH
96739: LD_INT 103
96741: PUSH
96742: LD_INT 104
96744: PUSH
96745: LD_INT 105
96747: PUSH
96748: LD_INT 106
96750: PUSH
96751: LD_INT 107
96753: PUSH
96754: LD_INT 108
96756: PUSH
96757: LD_INT 109
96759: PUSH
96760: LD_INT 110
96762: PUSH
96763: LD_INT 111
96765: PUSH
96766: LD_INT 112
96768: PUSH
96769: LD_INT 113
96771: PUSH
96772: LD_INT 114
96774: PUSH
96775: LD_INT 116
96777: PUSH
96778: LD_INT 117
96780: PUSH
96781: LD_INT 118
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: ST_TO_ADDR
96807: GO 98046
96809: LD_INT 14
96811: DOUBLE
96812: EQUAL
96813: IFTRUE 96817
96815: GO 97041
96817: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
96818: LD_ADDR_VAR 0 2
96822: PUSH
96823: LD_INT 1
96825: PUSH
96826: LD_INT 2
96828: PUSH
96829: LD_INT 3
96831: PUSH
96832: LD_INT 4
96834: PUSH
96835: LD_INT 5
96837: PUSH
96838: LD_INT 6
96840: PUSH
96841: LD_INT 7
96843: PUSH
96844: LD_INT 8
96846: PUSH
96847: LD_INT 9
96849: PUSH
96850: LD_INT 10
96852: PUSH
96853: LD_INT 11
96855: PUSH
96856: LD_INT 12
96858: PUSH
96859: LD_INT 13
96861: PUSH
96862: LD_INT 14
96864: PUSH
96865: LD_INT 15
96867: PUSH
96868: LD_INT 16
96870: PUSH
96871: LD_INT 17
96873: PUSH
96874: LD_INT 18
96876: PUSH
96877: LD_INT 19
96879: PUSH
96880: LD_INT 20
96882: PUSH
96883: LD_INT 21
96885: PUSH
96886: LD_INT 22
96888: PUSH
96889: LD_INT 23
96891: PUSH
96892: LD_INT 24
96894: PUSH
96895: LD_INT 25
96897: PUSH
96898: LD_INT 26
96900: PUSH
96901: LD_INT 27
96903: PUSH
96904: LD_INT 28
96906: PUSH
96907: LD_INT 29
96909: PUSH
96910: LD_INT 30
96912: PUSH
96913: LD_INT 31
96915: PUSH
96916: LD_INT 32
96918: PUSH
96919: LD_INT 33
96921: PUSH
96922: LD_INT 34
96924: PUSH
96925: LD_INT 36
96927: PUSH
96928: EMPTY
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 101
96967: PUSH
96968: LD_INT 102
96970: PUSH
96971: LD_INT 103
96973: PUSH
96974: LD_INT 104
96976: PUSH
96977: LD_INT 105
96979: PUSH
96980: LD_INT 106
96982: PUSH
96983: LD_INT 107
96985: PUSH
96986: LD_INT 108
96988: PUSH
96989: LD_INT 109
96991: PUSH
96992: LD_INT 110
96994: PUSH
96995: LD_INT 111
96997: PUSH
96998: LD_INT 112
97000: PUSH
97001: LD_INT 113
97003: PUSH
97004: LD_INT 114
97006: PUSH
97007: LD_INT 116
97009: PUSH
97010: LD_INT 117
97012: PUSH
97013: LD_INT 118
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: PUSH
97035: EMPTY
97036: LIST
97037: LIST
97038: ST_TO_ADDR
97039: GO 98046
97041: LD_INT 15
97043: DOUBLE
97044: EQUAL
97045: IFTRUE 97049
97047: GO 97273
97049: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97050: LD_ADDR_VAR 0 2
97054: PUSH
97055: LD_INT 1
97057: PUSH
97058: LD_INT 2
97060: PUSH
97061: LD_INT 3
97063: PUSH
97064: LD_INT 4
97066: PUSH
97067: LD_INT 5
97069: PUSH
97070: LD_INT 6
97072: PUSH
97073: LD_INT 7
97075: PUSH
97076: LD_INT 8
97078: PUSH
97079: LD_INT 9
97081: PUSH
97082: LD_INT 10
97084: PUSH
97085: LD_INT 11
97087: PUSH
97088: LD_INT 12
97090: PUSH
97091: LD_INT 13
97093: PUSH
97094: LD_INT 14
97096: PUSH
97097: LD_INT 15
97099: PUSH
97100: LD_INT 16
97102: PUSH
97103: LD_INT 17
97105: PUSH
97106: LD_INT 18
97108: PUSH
97109: LD_INT 19
97111: PUSH
97112: LD_INT 20
97114: PUSH
97115: LD_INT 21
97117: PUSH
97118: LD_INT 22
97120: PUSH
97121: LD_INT 23
97123: PUSH
97124: LD_INT 24
97126: PUSH
97127: LD_INT 25
97129: PUSH
97130: LD_INT 26
97132: PUSH
97133: LD_INT 27
97135: PUSH
97136: LD_INT 28
97138: PUSH
97139: LD_INT 29
97141: PUSH
97142: LD_INT 30
97144: PUSH
97145: LD_INT 31
97147: PUSH
97148: LD_INT 32
97150: PUSH
97151: LD_INT 33
97153: PUSH
97154: LD_INT 34
97156: PUSH
97157: LD_INT 36
97159: PUSH
97160: EMPTY
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: LIST
97196: PUSH
97197: LD_INT 101
97199: PUSH
97200: LD_INT 102
97202: PUSH
97203: LD_INT 103
97205: PUSH
97206: LD_INT 104
97208: PUSH
97209: LD_INT 105
97211: PUSH
97212: LD_INT 106
97214: PUSH
97215: LD_INT 107
97217: PUSH
97218: LD_INT 108
97220: PUSH
97221: LD_INT 109
97223: PUSH
97224: LD_INT 110
97226: PUSH
97227: LD_INT 111
97229: PUSH
97230: LD_INT 112
97232: PUSH
97233: LD_INT 113
97235: PUSH
97236: LD_INT 114
97238: PUSH
97239: LD_INT 116
97241: PUSH
97242: LD_INT 117
97244: PUSH
97245: LD_INT 118
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: ST_TO_ADDR
97271: GO 98046
97273: LD_INT 16
97275: DOUBLE
97276: EQUAL
97277: IFTRUE 97281
97279: GO 97417
97281: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97282: LD_ADDR_VAR 0 2
97286: PUSH
97287: LD_INT 2
97289: PUSH
97290: LD_INT 4
97292: PUSH
97293: LD_INT 5
97295: PUSH
97296: LD_INT 7
97298: PUSH
97299: LD_INT 11
97301: PUSH
97302: LD_INT 12
97304: PUSH
97305: LD_INT 15
97307: PUSH
97308: LD_INT 16
97310: PUSH
97311: LD_INT 20
97313: PUSH
97314: LD_INT 21
97316: PUSH
97317: LD_INT 22
97319: PUSH
97320: LD_INT 23
97322: PUSH
97323: LD_INT 25
97325: PUSH
97326: LD_INT 26
97328: PUSH
97329: LD_INT 30
97331: PUSH
97332: LD_INT 31
97334: PUSH
97335: LD_INT 32
97337: PUSH
97338: LD_INT 33
97340: PUSH
97341: LD_INT 34
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: LIST
97357: LIST
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: PUSH
97365: LD_INT 101
97367: PUSH
97368: LD_INT 102
97370: PUSH
97371: LD_INT 103
97373: PUSH
97374: LD_INT 106
97376: PUSH
97377: LD_INT 108
97379: PUSH
97380: LD_INT 112
97382: PUSH
97383: LD_INT 113
97385: PUSH
97386: LD_INT 114
97388: PUSH
97389: LD_INT 116
97391: PUSH
97392: LD_INT 117
97394: PUSH
97395: LD_INT 118
97397: PUSH
97398: EMPTY
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: PUSH
97411: EMPTY
97412: LIST
97413: LIST
97414: ST_TO_ADDR
97415: GO 98046
97417: LD_INT 17
97419: DOUBLE
97420: EQUAL
97421: IFTRUE 97425
97423: GO 97649
97425: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97426: LD_ADDR_VAR 0 2
97430: PUSH
97431: LD_INT 1
97433: PUSH
97434: LD_INT 2
97436: PUSH
97437: LD_INT 3
97439: PUSH
97440: LD_INT 4
97442: PUSH
97443: LD_INT 5
97445: PUSH
97446: LD_INT 6
97448: PUSH
97449: LD_INT 7
97451: PUSH
97452: LD_INT 8
97454: PUSH
97455: LD_INT 9
97457: PUSH
97458: LD_INT 10
97460: PUSH
97461: LD_INT 11
97463: PUSH
97464: LD_INT 12
97466: PUSH
97467: LD_INT 13
97469: PUSH
97470: LD_INT 14
97472: PUSH
97473: LD_INT 15
97475: PUSH
97476: LD_INT 16
97478: PUSH
97479: LD_INT 17
97481: PUSH
97482: LD_INT 18
97484: PUSH
97485: LD_INT 19
97487: PUSH
97488: LD_INT 20
97490: PUSH
97491: LD_INT 21
97493: PUSH
97494: LD_INT 22
97496: PUSH
97497: LD_INT 23
97499: PUSH
97500: LD_INT 24
97502: PUSH
97503: LD_INT 25
97505: PUSH
97506: LD_INT 26
97508: PUSH
97509: LD_INT 27
97511: PUSH
97512: LD_INT 28
97514: PUSH
97515: LD_INT 29
97517: PUSH
97518: LD_INT 30
97520: PUSH
97521: LD_INT 31
97523: PUSH
97524: LD_INT 32
97526: PUSH
97527: LD_INT 33
97529: PUSH
97530: LD_INT 34
97532: PUSH
97533: LD_INT 36
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: LIST
97540: LIST
97541: LIST
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: LIST
97548: LIST
97549: LIST
97550: LIST
97551: LIST
97552: LIST
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: PUSH
97573: LD_INT 101
97575: PUSH
97576: LD_INT 102
97578: PUSH
97579: LD_INT 103
97581: PUSH
97582: LD_INT 104
97584: PUSH
97585: LD_INT 105
97587: PUSH
97588: LD_INT 106
97590: PUSH
97591: LD_INT 107
97593: PUSH
97594: LD_INT 108
97596: PUSH
97597: LD_INT 109
97599: PUSH
97600: LD_INT 110
97602: PUSH
97603: LD_INT 111
97605: PUSH
97606: LD_INT 112
97608: PUSH
97609: LD_INT 113
97611: PUSH
97612: LD_INT 114
97614: PUSH
97615: LD_INT 116
97617: PUSH
97618: LD_INT 117
97620: PUSH
97621: LD_INT 118
97623: PUSH
97624: EMPTY
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: PUSH
97643: EMPTY
97644: LIST
97645: LIST
97646: ST_TO_ADDR
97647: GO 98046
97649: LD_INT 18
97651: DOUBLE
97652: EQUAL
97653: IFTRUE 97657
97655: GO 97805
97657: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97658: LD_ADDR_VAR 0 2
97662: PUSH
97663: LD_INT 2
97665: PUSH
97666: LD_INT 4
97668: PUSH
97669: LD_INT 5
97671: PUSH
97672: LD_INT 7
97674: PUSH
97675: LD_INT 11
97677: PUSH
97678: LD_INT 12
97680: PUSH
97681: LD_INT 15
97683: PUSH
97684: LD_INT 16
97686: PUSH
97687: LD_INT 20
97689: PUSH
97690: LD_INT 21
97692: PUSH
97693: LD_INT 22
97695: PUSH
97696: LD_INT 23
97698: PUSH
97699: LD_INT 25
97701: PUSH
97702: LD_INT 26
97704: PUSH
97705: LD_INT 30
97707: PUSH
97708: LD_INT 31
97710: PUSH
97711: LD_INT 32
97713: PUSH
97714: LD_INT 33
97716: PUSH
97717: LD_INT 34
97719: PUSH
97720: LD_INT 35
97722: PUSH
97723: LD_INT 36
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: PUSH
97749: LD_INT 101
97751: PUSH
97752: LD_INT 102
97754: PUSH
97755: LD_INT 103
97757: PUSH
97758: LD_INT 106
97760: PUSH
97761: LD_INT 108
97763: PUSH
97764: LD_INT 112
97766: PUSH
97767: LD_INT 113
97769: PUSH
97770: LD_INT 114
97772: PUSH
97773: LD_INT 115
97775: PUSH
97776: LD_INT 116
97778: PUSH
97779: LD_INT 117
97781: PUSH
97782: LD_INT 118
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: PUSH
97799: EMPTY
97800: LIST
97801: LIST
97802: ST_TO_ADDR
97803: GO 98046
97805: LD_INT 19
97807: DOUBLE
97808: EQUAL
97809: IFTRUE 97813
97811: GO 98045
97813: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
97814: LD_ADDR_VAR 0 2
97818: PUSH
97819: LD_INT 1
97821: PUSH
97822: LD_INT 2
97824: PUSH
97825: LD_INT 3
97827: PUSH
97828: LD_INT 4
97830: PUSH
97831: LD_INT 5
97833: PUSH
97834: LD_INT 6
97836: PUSH
97837: LD_INT 7
97839: PUSH
97840: LD_INT 8
97842: PUSH
97843: LD_INT 9
97845: PUSH
97846: LD_INT 10
97848: PUSH
97849: LD_INT 11
97851: PUSH
97852: LD_INT 12
97854: PUSH
97855: LD_INT 13
97857: PUSH
97858: LD_INT 14
97860: PUSH
97861: LD_INT 15
97863: PUSH
97864: LD_INT 16
97866: PUSH
97867: LD_INT 17
97869: PUSH
97870: LD_INT 18
97872: PUSH
97873: LD_INT 19
97875: PUSH
97876: LD_INT 20
97878: PUSH
97879: LD_INT 21
97881: PUSH
97882: LD_INT 22
97884: PUSH
97885: LD_INT 23
97887: PUSH
97888: LD_INT 24
97890: PUSH
97891: LD_INT 25
97893: PUSH
97894: LD_INT 26
97896: PUSH
97897: LD_INT 27
97899: PUSH
97900: LD_INT 28
97902: PUSH
97903: LD_INT 29
97905: PUSH
97906: LD_INT 30
97908: PUSH
97909: LD_INT 31
97911: PUSH
97912: LD_INT 32
97914: PUSH
97915: LD_INT 33
97917: PUSH
97918: LD_INT 34
97920: PUSH
97921: LD_INT 35
97923: PUSH
97924: LD_INT 36
97926: PUSH
97927: EMPTY
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: LIST
97950: LIST
97951: LIST
97952: LIST
97953: LIST
97954: LIST
97955: LIST
97956: LIST
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: PUSH
97965: LD_INT 101
97967: PUSH
97968: LD_INT 102
97970: PUSH
97971: LD_INT 103
97973: PUSH
97974: LD_INT 104
97976: PUSH
97977: LD_INT 105
97979: PUSH
97980: LD_INT 106
97982: PUSH
97983: LD_INT 107
97985: PUSH
97986: LD_INT 108
97988: PUSH
97989: LD_INT 109
97991: PUSH
97992: LD_INT 110
97994: PUSH
97995: LD_INT 111
97997: PUSH
97998: LD_INT 112
98000: PUSH
98001: LD_INT 113
98003: PUSH
98004: LD_INT 114
98006: PUSH
98007: LD_INT 115
98009: PUSH
98010: LD_INT 116
98012: PUSH
98013: LD_INT 117
98015: PUSH
98016: LD_INT 118
98018: PUSH
98019: EMPTY
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: PUSH
98039: EMPTY
98040: LIST
98041: LIST
98042: ST_TO_ADDR
98043: GO 98046
98045: POP
// end else
98046: GO 98277
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98048: LD_ADDR_VAR 0 2
98052: PUSH
98053: LD_INT 1
98055: PUSH
98056: LD_INT 2
98058: PUSH
98059: LD_INT 3
98061: PUSH
98062: LD_INT 4
98064: PUSH
98065: LD_INT 5
98067: PUSH
98068: LD_INT 6
98070: PUSH
98071: LD_INT 7
98073: PUSH
98074: LD_INT 8
98076: PUSH
98077: LD_INT 9
98079: PUSH
98080: LD_INT 10
98082: PUSH
98083: LD_INT 11
98085: PUSH
98086: LD_INT 12
98088: PUSH
98089: LD_INT 13
98091: PUSH
98092: LD_INT 14
98094: PUSH
98095: LD_INT 15
98097: PUSH
98098: LD_INT 16
98100: PUSH
98101: LD_INT 17
98103: PUSH
98104: LD_INT 18
98106: PUSH
98107: LD_INT 19
98109: PUSH
98110: LD_INT 20
98112: PUSH
98113: LD_INT 21
98115: PUSH
98116: LD_INT 22
98118: PUSH
98119: LD_INT 23
98121: PUSH
98122: LD_INT 24
98124: PUSH
98125: LD_INT 25
98127: PUSH
98128: LD_INT 26
98130: PUSH
98131: LD_INT 27
98133: PUSH
98134: LD_INT 28
98136: PUSH
98137: LD_INT 29
98139: PUSH
98140: LD_INT 30
98142: PUSH
98143: LD_INT 31
98145: PUSH
98146: LD_INT 32
98148: PUSH
98149: LD_INT 33
98151: PUSH
98152: LD_INT 34
98154: PUSH
98155: LD_INT 35
98157: PUSH
98158: LD_INT 36
98160: PUSH
98161: EMPTY
98162: LIST
98163: LIST
98164: LIST
98165: LIST
98166: LIST
98167: LIST
98168: LIST
98169: LIST
98170: LIST
98171: LIST
98172: LIST
98173: LIST
98174: LIST
98175: LIST
98176: LIST
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: PUSH
98199: LD_INT 101
98201: PUSH
98202: LD_INT 102
98204: PUSH
98205: LD_INT 103
98207: PUSH
98208: LD_INT 104
98210: PUSH
98211: LD_INT 105
98213: PUSH
98214: LD_INT 106
98216: PUSH
98217: LD_INT 107
98219: PUSH
98220: LD_INT 108
98222: PUSH
98223: LD_INT 109
98225: PUSH
98226: LD_INT 110
98228: PUSH
98229: LD_INT 111
98231: PUSH
98232: LD_INT 112
98234: PUSH
98235: LD_INT 113
98237: PUSH
98238: LD_INT 114
98240: PUSH
98241: LD_INT 115
98243: PUSH
98244: LD_INT 116
98246: PUSH
98247: LD_INT 117
98249: PUSH
98250: LD_INT 118
98252: PUSH
98253: EMPTY
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: LIST
98271: LIST
98272: PUSH
98273: EMPTY
98274: LIST
98275: LIST
98276: ST_TO_ADDR
// if result then
98277: LD_VAR 0 2
98281: IFFALSE 99067
// begin normal :=  ;
98283: LD_ADDR_VAR 0 5
98287: PUSH
98288: LD_STRING 
98290: ST_TO_ADDR
// hardcore :=  ;
98291: LD_ADDR_VAR 0 6
98295: PUSH
98296: LD_STRING 
98298: ST_TO_ADDR
// active :=  ;
98299: LD_ADDR_VAR 0 7
98303: PUSH
98304: LD_STRING 
98306: ST_TO_ADDR
// for i = 1 to normalCounter do
98307: LD_ADDR_VAR 0 8
98311: PUSH
98312: DOUBLE
98313: LD_INT 1
98315: DEC
98316: ST_TO_ADDR
98317: LD_EXP 121
98321: PUSH
98322: FOR_TO
98323: IFFALSE 98424
// begin tmp := 0 ;
98325: LD_ADDR_VAR 0 3
98329: PUSH
98330: LD_STRING 0
98332: ST_TO_ADDR
// if result [ 1 ] then
98333: LD_VAR 0 2
98337: PUSH
98338: LD_INT 1
98340: ARRAY
98341: IFFALSE 98406
// if result [ 1 ] [ 1 ] = i then
98343: LD_VAR 0 2
98347: PUSH
98348: LD_INT 1
98350: ARRAY
98351: PUSH
98352: LD_INT 1
98354: ARRAY
98355: PUSH
98356: LD_VAR 0 8
98360: EQUAL
98361: IFFALSE 98406
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98363: LD_ADDR_VAR 0 2
98367: PUSH
98368: LD_VAR 0 2
98372: PPUSH
98373: LD_INT 1
98375: PPUSH
98376: LD_VAR 0 2
98380: PUSH
98381: LD_INT 1
98383: ARRAY
98384: PPUSH
98385: LD_INT 1
98387: PPUSH
98388: CALL_OW 3
98392: PPUSH
98393: CALL_OW 1
98397: ST_TO_ADDR
// tmp := 1 ;
98398: LD_ADDR_VAR 0 3
98402: PUSH
98403: LD_STRING 1
98405: ST_TO_ADDR
// end ; normal := normal & tmp ;
98406: LD_ADDR_VAR 0 5
98410: PUSH
98411: LD_VAR 0 5
98415: PUSH
98416: LD_VAR 0 3
98420: STR
98421: ST_TO_ADDR
// end ;
98422: GO 98322
98424: POP
98425: POP
// for i = 1 to hardcoreCounter do
98426: LD_ADDR_VAR 0 8
98430: PUSH
98431: DOUBLE
98432: LD_INT 1
98434: DEC
98435: ST_TO_ADDR
98436: LD_EXP 122
98440: PUSH
98441: FOR_TO
98442: IFFALSE 98547
// begin tmp := 0 ;
98444: LD_ADDR_VAR 0 3
98448: PUSH
98449: LD_STRING 0
98451: ST_TO_ADDR
// if result [ 2 ] then
98452: LD_VAR 0 2
98456: PUSH
98457: LD_INT 2
98459: ARRAY
98460: IFFALSE 98529
// if result [ 2 ] [ 1 ] = 100 + i then
98462: LD_VAR 0 2
98466: PUSH
98467: LD_INT 2
98469: ARRAY
98470: PUSH
98471: LD_INT 1
98473: ARRAY
98474: PUSH
98475: LD_INT 100
98477: PUSH
98478: LD_VAR 0 8
98482: PLUS
98483: EQUAL
98484: IFFALSE 98529
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98486: LD_ADDR_VAR 0 2
98490: PUSH
98491: LD_VAR 0 2
98495: PPUSH
98496: LD_INT 2
98498: PPUSH
98499: LD_VAR 0 2
98503: PUSH
98504: LD_INT 2
98506: ARRAY
98507: PPUSH
98508: LD_INT 1
98510: PPUSH
98511: CALL_OW 3
98515: PPUSH
98516: CALL_OW 1
98520: ST_TO_ADDR
// tmp := 1 ;
98521: LD_ADDR_VAR 0 3
98525: PUSH
98526: LD_STRING 1
98528: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98529: LD_ADDR_VAR 0 6
98533: PUSH
98534: LD_VAR 0 6
98538: PUSH
98539: LD_VAR 0 3
98543: STR
98544: ST_TO_ADDR
// end ;
98545: GO 98441
98547: POP
98548: POP
// if isGameLoad then
98549: LD_VAR 0 1
98553: IFFALSE 99028
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
98555: LD_ADDR_VAR 0 4
98559: PUSH
98560: LD_EXP 125
98564: PUSH
98565: LD_EXP 124
98569: PUSH
98570: LD_EXP 126
98574: PUSH
98575: LD_EXP 123
98579: PUSH
98580: LD_EXP 127
98584: PUSH
98585: LD_EXP 128
98589: PUSH
98590: LD_EXP 129
98594: PUSH
98595: LD_EXP 130
98599: PUSH
98600: LD_EXP 131
98604: PUSH
98605: LD_EXP 132
98609: PUSH
98610: LD_EXP 133
98614: PUSH
98615: LD_EXP 134
98619: PUSH
98620: LD_EXP 135
98624: PUSH
98625: LD_EXP 136
98629: PUSH
98630: LD_EXP 144
98634: PUSH
98635: LD_EXP 145
98639: PUSH
98640: LD_EXP 146
98644: PUSH
98645: LD_EXP 147
98649: PUSH
98650: LD_EXP 149
98654: PUSH
98655: LD_EXP 150
98659: PUSH
98660: LD_EXP 151
98664: PUSH
98665: LD_EXP 154
98669: PUSH
98670: LD_EXP 156
98674: PUSH
98675: LD_EXP 157
98679: PUSH
98680: LD_EXP 158
98684: PUSH
98685: LD_EXP 160
98689: PUSH
98690: LD_EXP 161
98694: PUSH
98695: LD_EXP 164
98699: PUSH
98700: LD_EXP 165
98704: PUSH
98705: LD_EXP 166
98709: PUSH
98710: LD_EXP 167
98714: PUSH
98715: LD_EXP 168
98719: PUSH
98720: LD_EXP 169
98724: PUSH
98725: LD_EXP 170
98729: PUSH
98730: LD_EXP 171
98734: PUSH
98735: LD_EXP 172
98739: PUSH
98740: LD_EXP 137
98744: PUSH
98745: LD_EXP 138
98749: PUSH
98750: LD_EXP 141
98754: PUSH
98755: LD_EXP 142
98759: PUSH
98760: LD_EXP 143
98764: PUSH
98765: LD_EXP 139
98769: PUSH
98770: LD_EXP 140
98774: PUSH
98775: LD_EXP 148
98779: PUSH
98780: LD_EXP 152
98784: PUSH
98785: LD_EXP 153
98789: PUSH
98790: LD_EXP 155
98794: PUSH
98795: LD_EXP 159
98799: PUSH
98800: LD_EXP 162
98804: PUSH
98805: LD_EXP 163
98809: PUSH
98810: LD_EXP 173
98814: PUSH
98815: LD_EXP 174
98819: PUSH
98820: LD_EXP 175
98824: PUSH
98825: LD_EXP 176
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: LIST
98834: LIST
98835: LIST
98836: LIST
98837: LIST
98838: LIST
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: LIST
98845: LIST
98846: LIST
98847: LIST
98848: LIST
98849: LIST
98850: LIST
98851: LIST
98852: LIST
98853: LIST
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: LIST
98884: LIST
98885: ST_TO_ADDR
// tmp :=  ;
98886: LD_ADDR_VAR 0 3
98890: PUSH
98891: LD_STRING 
98893: ST_TO_ADDR
// for i = 1 to normalCounter do
98894: LD_ADDR_VAR 0 8
98898: PUSH
98899: DOUBLE
98900: LD_INT 1
98902: DEC
98903: ST_TO_ADDR
98904: LD_EXP 121
98908: PUSH
98909: FOR_TO
98910: IFFALSE 98946
// begin if flags [ i ] then
98912: LD_VAR 0 4
98916: PUSH
98917: LD_VAR 0 8
98921: ARRAY
98922: IFFALSE 98944
// tmp := tmp & i & ; ;
98924: LD_ADDR_VAR 0 3
98928: PUSH
98929: LD_VAR 0 3
98933: PUSH
98934: LD_VAR 0 8
98938: STR
98939: PUSH
98940: LD_STRING ;
98942: STR
98943: ST_TO_ADDR
// end ;
98944: GO 98909
98946: POP
98947: POP
// for i = 1 to hardcoreCounter do
98948: LD_ADDR_VAR 0 8
98952: PUSH
98953: DOUBLE
98954: LD_INT 1
98956: DEC
98957: ST_TO_ADDR
98958: LD_EXP 122
98962: PUSH
98963: FOR_TO
98964: IFFALSE 99010
// begin if flags [ normalCounter + i ] then
98966: LD_VAR 0 4
98970: PUSH
98971: LD_EXP 121
98975: PUSH
98976: LD_VAR 0 8
98980: PLUS
98981: ARRAY
98982: IFFALSE 99008
// tmp := tmp & ( 100 + i ) & ; ;
98984: LD_ADDR_VAR 0 3
98988: PUSH
98989: LD_VAR 0 3
98993: PUSH
98994: LD_INT 100
98996: PUSH
98997: LD_VAR 0 8
99001: PLUS
99002: STR
99003: PUSH
99004: LD_STRING ;
99006: STR
99007: ST_TO_ADDR
// end ;
99008: GO 98963
99010: POP
99011: POP
// if tmp then
99012: LD_VAR 0 3
99016: IFFALSE 99028
// active := tmp ;
99018: LD_ADDR_VAR 0 7
99022: PUSH
99023: LD_VAR 0 3
99027: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99028: LD_STRING getStreamItemsFromMission("
99030: PUSH
99031: LD_VAR 0 5
99035: STR
99036: PUSH
99037: LD_STRING ","
99039: STR
99040: PUSH
99041: LD_VAR 0 6
99045: STR
99046: PUSH
99047: LD_STRING ","
99049: STR
99050: PUSH
99051: LD_VAR 0 7
99055: STR
99056: PUSH
99057: LD_STRING ")
99059: STR
99060: PPUSH
99061: CALL_OW 559
// end else
99065: GO 99074
// ToLua ( getStreamItemsFromMission("","","") ) ;
99067: LD_STRING getStreamItemsFromMission("","","")
99069: PPUSH
99070: CALL_OW 559
// end ;
99074: LD_VAR 0 2
99078: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99079: LD_EXP 120
99083: PUSH
99084: LD_EXP 125
99088: AND
99089: IFFALSE 99213
99091: GO 99093
99093: DISABLE
99094: LD_INT 0
99096: PPUSH
99097: PPUSH
// begin enable ;
99098: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99099: LD_ADDR_VAR 0 2
99103: PUSH
99104: LD_INT 22
99106: PUSH
99107: LD_OWVAR 2
99111: PUSH
99112: EMPTY
99113: LIST
99114: LIST
99115: PUSH
99116: LD_INT 2
99118: PUSH
99119: LD_INT 34
99121: PUSH
99122: LD_INT 7
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PUSH
99129: LD_INT 34
99131: PUSH
99132: LD_INT 45
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: PUSH
99139: LD_INT 34
99141: PUSH
99142: LD_INT 28
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: LD_INT 34
99151: PUSH
99152: LD_INT 47
99154: PUSH
99155: EMPTY
99156: LIST
99157: LIST
99158: PUSH
99159: EMPTY
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: PUSH
99166: EMPTY
99167: LIST
99168: LIST
99169: PPUSH
99170: CALL_OW 69
99174: ST_TO_ADDR
// if not tmp then
99175: LD_VAR 0 2
99179: NOT
99180: IFFALSE 99184
// exit ;
99182: GO 99213
// for i in tmp do
99184: LD_ADDR_VAR 0 1
99188: PUSH
99189: LD_VAR 0 2
99193: PUSH
99194: FOR_IN
99195: IFFALSE 99211
// begin SetLives ( i , 0 ) ;
99197: LD_VAR 0 1
99201: PPUSH
99202: LD_INT 0
99204: PPUSH
99205: CALL_OW 234
// end ;
99209: GO 99194
99211: POP
99212: POP
// end ;
99213: PPOPN 2
99215: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99216: LD_EXP 120
99220: PUSH
99221: LD_EXP 126
99225: AND
99226: IFFALSE 99310
99228: GO 99230
99230: DISABLE
99231: LD_INT 0
99233: PPUSH
99234: PPUSH
// begin enable ;
99235: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99236: LD_ADDR_VAR 0 2
99240: PUSH
99241: LD_INT 22
99243: PUSH
99244: LD_OWVAR 2
99248: PUSH
99249: EMPTY
99250: LIST
99251: LIST
99252: PUSH
99253: LD_INT 32
99255: PUSH
99256: LD_INT 3
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: PUSH
99263: EMPTY
99264: LIST
99265: LIST
99266: PPUSH
99267: CALL_OW 69
99271: ST_TO_ADDR
// if not tmp then
99272: LD_VAR 0 2
99276: NOT
99277: IFFALSE 99281
// exit ;
99279: GO 99310
// for i in tmp do
99281: LD_ADDR_VAR 0 1
99285: PUSH
99286: LD_VAR 0 2
99290: PUSH
99291: FOR_IN
99292: IFFALSE 99308
// begin SetLives ( i , 0 ) ;
99294: LD_VAR 0 1
99298: PPUSH
99299: LD_INT 0
99301: PPUSH
99302: CALL_OW 234
// end ;
99306: GO 99291
99308: POP
99309: POP
// end ;
99310: PPOPN 2
99312: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
99313: LD_EXP 120
99317: PUSH
99318: LD_EXP 123
99322: AND
99323: IFFALSE 99416
99325: GO 99327
99327: DISABLE
99328: LD_INT 0
99330: PPUSH
// begin enable ;
99331: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
99332: LD_ADDR_VAR 0 1
99336: PUSH
99337: LD_INT 22
99339: PUSH
99340: LD_OWVAR 2
99344: PUSH
99345: EMPTY
99346: LIST
99347: LIST
99348: PUSH
99349: LD_INT 2
99351: PUSH
99352: LD_INT 25
99354: PUSH
99355: LD_INT 5
99357: PUSH
99358: EMPTY
99359: LIST
99360: LIST
99361: PUSH
99362: LD_INT 25
99364: PUSH
99365: LD_INT 9
99367: PUSH
99368: EMPTY
99369: LIST
99370: LIST
99371: PUSH
99372: LD_INT 25
99374: PUSH
99375: LD_INT 8
99377: PUSH
99378: EMPTY
99379: LIST
99380: LIST
99381: PUSH
99382: EMPTY
99383: LIST
99384: LIST
99385: LIST
99386: LIST
99387: PUSH
99388: EMPTY
99389: LIST
99390: LIST
99391: PPUSH
99392: CALL_OW 69
99396: PUSH
99397: FOR_IN
99398: IFFALSE 99414
// begin SetClass ( i , 1 ) ;
99400: LD_VAR 0 1
99404: PPUSH
99405: LD_INT 1
99407: PPUSH
99408: CALL_OW 336
// end ;
99412: GO 99397
99414: POP
99415: POP
// end ;
99416: PPOPN 1
99418: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
99419: LD_EXP 120
99423: PUSH
99424: LD_EXP 124
99428: AND
99429: PUSH
99430: LD_OWVAR 65
99434: PUSH
99435: LD_INT 7
99437: LESS
99438: AND
99439: IFFALSE 99453
99441: GO 99443
99443: DISABLE
// begin enable ;
99444: ENABLE
// game_speed := 7 ;
99445: LD_ADDR_OWVAR 65
99449: PUSH
99450: LD_INT 7
99452: ST_TO_ADDR
// end ;
99453: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
99454: LD_EXP 120
99458: PUSH
99459: LD_EXP 127
99463: AND
99464: IFFALSE 99666
99466: GO 99468
99468: DISABLE
99469: LD_INT 0
99471: PPUSH
99472: PPUSH
99473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99474: LD_ADDR_VAR 0 3
99478: PUSH
99479: LD_INT 81
99481: PUSH
99482: LD_OWVAR 2
99486: PUSH
99487: EMPTY
99488: LIST
99489: LIST
99490: PUSH
99491: LD_INT 21
99493: PUSH
99494: LD_INT 1
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: PUSH
99501: EMPTY
99502: LIST
99503: LIST
99504: PPUSH
99505: CALL_OW 69
99509: ST_TO_ADDR
// if not tmp then
99510: LD_VAR 0 3
99514: NOT
99515: IFFALSE 99519
// exit ;
99517: GO 99666
// if tmp > 5 then
99519: LD_VAR 0 3
99523: PUSH
99524: LD_INT 5
99526: GREATER
99527: IFFALSE 99539
// k := 5 else
99529: LD_ADDR_VAR 0 2
99533: PUSH
99534: LD_INT 5
99536: ST_TO_ADDR
99537: GO 99549
// k := tmp ;
99539: LD_ADDR_VAR 0 2
99543: PUSH
99544: LD_VAR 0 3
99548: ST_TO_ADDR
// for i := 1 to k do
99549: LD_ADDR_VAR 0 1
99553: PUSH
99554: DOUBLE
99555: LD_INT 1
99557: DEC
99558: ST_TO_ADDR
99559: LD_VAR 0 2
99563: PUSH
99564: FOR_TO
99565: IFFALSE 99664
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
99567: LD_VAR 0 3
99571: PUSH
99572: LD_VAR 0 1
99576: ARRAY
99577: PPUSH
99578: LD_VAR 0 1
99582: PUSH
99583: LD_INT 4
99585: MOD
99586: PUSH
99587: LD_INT 1
99589: PLUS
99590: PPUSH
99591: CALL_OW 259
99595: PUSH
99596: LD_INT 10
99598: LESS
99599: IFFALSE 99662
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99601: LD_VAR 0 3
99605: PUSH
99606: LD_VAR 0 1
99610: ARRAY
99611: PPUSH
99612: LD_VAR 0 1
99616: PUSH
99617: LD_INT 4
99619: MOD
99620: PUSH
99621: LD_INT 1
99623: PLUS
99624: PPUSH
99625: LD_VAR 0 3
99629: PUSH
99630: LD_VAR 0 1
99634: ARRAY
99635: PPUSH
99636: LD_VAR 0 1
99640: PUSH
99641: LD_INT 4
99643: MOD
99644: PUSH
99645: LD_INT 1
99647: PLUS
99648: PPUSH
99649: CALL_OW 259
99653: PUSH
99654: LD_INT 1
99656: PLUS
99657: PPUSH
99658: CALL_OW 237
99662: GO 99564
99664: POP
99665: POP
// end ;
99666: PPOPN 3
99668: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99669: LD_EXP 120
99673: PUSH
99674: LD_EXP 128
99678: AND
99679: IFFALSE 99699
99681: GO 99683
99683: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99684: LD_INT 4
99686: PPUSH
99687: LD_OWVAR 2
99691: PPUSH
99692: LD_INT 0
99694: PPUSH
99695: CALL_OW 324
99699: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99700: LD_EXP 120
99704: PUSH
99705: LD_EXP 157
99709: AND
99710: IFFALSE 99730
99712: GO 99714
99714: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99715: LD_INT 19
99717: PPUSH
99718: LD_OWVAR 2
99722: PPUSH
99723: LD_INT 0
99725: PPUSH
99726: CALL_OW 324
99730: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99731: LD_EXP 120
99735: PUSH
99736: LD_EXP 129
99740: AND
99741: IFFALSE 99843
99743: GO 99745
99745: DISABLE
99746: LD_INT 0
99748: PPUSH
99749: PPUSH
// begin enable ;
99750: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99751: LD_ADDR_VAR 0 2
99755: PUSH
99756: LD_INT 22
99758: PUSH
99759: LD_OWVAR 2
99763: PUSH
99764: EMPTY
99765: LIST
99766: LIST
99767: PUSH
99768: LD_INT 2
99770: PUSH
99771: LD_INT 34
99773: PUSH
99774: LD_INT 11
99776: PUSH
99777: EMPTY
99778: LIST
99779: LIST
99780: PUSH
99781: LD_INT 34
99783: PUSH
99784: LD_INT 30
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: EMPTY
99792: LIST
99793: LIST
99794: LIST
99795: PUSH
99796: EMPTY
99797: LIST
99798: LIST
99799: PPUSH
99800: CALL_OW 69
99804: ST_TO_ADDR
// if not tmp then
99805: LD_VAR 0 2
99809: NOT
99810: IFFALSE 99814
// exit ;
99812: GO 99843
// for i in tmp do
99814: LD_ADDR_VAR 0 1
99818: PUSH
99819: LD_VAR 0 2
99823: PUSH
99824: FOR_IN
99825: IFFALSE 99841
// begin SetLives ( i , 0 ) ;
99827: LD_VAR 0 1
99831: PPUSH
99832: LD_INT 0
99834: PPUSH
99835: CALL_OW 234
// end ;
99839: GO 99824
99841: POP
99842: POP
// end ;
99843: PPOPN 2
99845: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99846: LD_EXP 120
99850: PUSH
99851: LD_EXP 130
99855: AND
99856: IFFALSE 99876
99858: GO 99860
99860: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99861: LD_INT 32
99863: PPUSH
99864: LD_OWVAR 2
99868: PPUSH
99869: LD_INT 0
99871: PPUSH
99872: CALL_OW 324
99876: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99877: LD_EXP 120
99881: PUSH
99882: LD_EXP 131
99886: AND
99887: IFFALSE 100068
99889: GO 99891
99891: DISABLE
99892: LD_INT 0
99894: PPUSH
99895: PPUSH
99896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99897: LD_ADDR_VAR 0 2
99901: PUSH
99902: LD_INT 22
99904: PUSH
99905: LD_OWVAR 2
99909: PUSH
99910: EMPTY
99911: LIST
99912: LIST
99913: PUSH
99914: LD_INT 33
99916: PUSH
99917: LD_INT 3
99919: PUSH
99920: EMPTY
99921: LIST
99922: LIST
99923: PUSH
99924: EMPTY
99925: LIST
99926: LIST
99927: PPUSH
99928: CALL_OW 69
99932: ST_TO_ADDR
// if not tmp then
99933: LD_VAR 0 2
99937: NOT
99938: IFFALSE 99942
// exit ;
99940: GO 100068
// side := 0 ;
99942: LD_ADDR_VAR 0 3
99946: PUSH
99947: LD_INT 0
99949: ST_TO_ADDR
// for i := 1 to 8 do
99950: LD_ADDR_VAR 0 1
99954: PUSH
99955: DOUBLE
99956: LD_INT 1
99958: DEC
99959: ST_TO_ADDR
99960: LD_INT 8
99962: PUSH
99963: FOR_TO
99964: IFFALSE 100012
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99966: LD_OWVAR 2
99970: PUSH
99971: LD_VAR 0 1
99975: NONEQUAL
99976: PUSH
99977: LD_OWVAR 2
99981: PPUSH
99982: LD_VAR 0 1
99986: PPUSH
99987: CALL_OW 81
99991: PUSH
99992: LD_INT 2
99994: EQUAL
99995: AND
99996: IFFALSE 100010
// begin side := i ;
99998: LD_ADDR_VAR 0 3
100002: PUSH
100003: LD_VAR 0 1
100007: ST_TO_ADDR
// break ;
100008: GO 100012
// end ;
100010: GO 99963
100012: POP
100013: POP
// if not side then
100014: LD_VAR 0 3
100018: NOT
100019: IFFALSE 100023
// exit ;
100021: GO 100068
// for i := 1 to tmp do
100023: LD_ADDR_VAR 0 1
100027: PUSH
100028: DOUBLE
100029: LD_INT 1
100031: DEC
100032: ST_TO_ADDR
100033: LD_VAR 0 2
100037: PUSH
100038: FOR_TO
100039: IFFALSE 100066
// if Prob ( 60 ) then
100041: LD_INT 60
100043: PPUSH
100044: CALL_OW 13
100048: IFFALSE 100064
// SetSide ( i , side ) ;
100050: LD_VAR 0 1
100054: PPUSH
100055: LD_VAR 0 3
100059: PPUSH
100060: CALL_OW 235
100064: GO 100038
100066: POP
100067: POP
// end ;
100068: PPOPN 3
100070: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100071: LD_EXP 120
100075: PUSH
100076: LD_EXP 133
100080: AND
100081: IFFALSE 100200
100083: GO 100085
100085: DISABLE
100086: LD_INT 0
100088: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100089: LD_ADDR_VAR 0 1
100093: PUSH
100094: LD_INT 22
100096: PUSH
100097: LD_OWVAR 2
100101: PUSH
100102: EMPTY
100103: LIST
100104: LIST
100105: PUSH
100106: LD_INT 21
100108: PUSH
100109: LD_INT 1
100111: PUSH
100112: EMPTY
100113: LIST
100114: LIST
100115: PUSH
100116: LD_INT 3
100118: PUSH
100119: LD_INT 23
100121: PUSH
100122: LD_INT 0
100124: PUSH
100125: EMPTY
100126: LIST
100127: LIST
100128: PUSH
100129: EMPTY
100130: LIST
100131: LIST
100132: PUSH
100133: EMPTY
100134: LIST
100135: LIST
100136: LIST
100137: PPUSH
100138: CALL_OW 69
100142: PUSH
100143: FOR_IN
100144: IFFALSE 100198
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100146: LD_VAR 0 1
100150: PPUSH
100151: CALL_OW 257
100155: PUSH
100156: LD_INT 1
100158: PUSH
100159: LD_INT 2
100161: PUSH
100162: LD_INT 3
100164: PUSH
100165: LD_INT 4
100167: PUSH
100168: EMPTY
100169: LIST
100170: LIST
100171: LIST
100172: LIST
100173: IN
100174: IFFALSE 100196
// SetClass ( un , rand ( 1 , 4 ) ) ;
100176: LD_VAR 0 1
100180: PPUSH
100181: LD_INT 1
100183: PPUSH
100184: LD_INT 4
100186: PPUSH
100187: CALL_OW 12
100191: PPUSH
100192: CALL_OW 336
100196: GO 100143
100198: POP
100199: POP
// end ;
100200: PPOPN 1
100202: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100203: LD_EXP 120
100207: PUSH
100208: LD_EXP 132
100212: AND
100213: IFFALSE 100292
100215: GO 100217
100217: DISABLE
100218: LD_INT 0
100220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100221: LD_ADDR_VAR 0 1
100225: PUSH
100226: LD_INT 22
100228: PUSH
100229: LD_OWVAR 2
100233: PUSH
100234: EMPTY
100235: LIST
100236: LIST
100237: PUSH
100238: LD_INT 21
100240: PUSH
100241: LD_INT 3
100243: PUSH
100244: EMPTY
100245: LIST
100246: LIST
100247: PUSH
100248: EMPTY
100249: LIST
100250: LIST
100251: PPUSH
100252: CALL_OW 69
100256: ST_TO_ADDR
// if not tmp then
100257: LD_VAR 0 1
100261: NOT
100262: IFFALSE 100266
// exit ;
100264: GO 100292
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100266: LD_VAR 0 1
100270: PUSH
100271: LD_INT 1
100273: PPUSH
100274: LD_VAR 0 1
100278: PPUSH
100279: CALL_OW 12
100283: ARRAY
100284: PPUSH
100285: LD_INT 100
100287: PPUSH
100288: CALL_OW 234
// end ;
100292: PPOPN 1
100294: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
100295: LD_EXP 120
100299: PUSH
100300: LD_EXP 134
100304: AND
100305: IFFALSE 100403
100307: GO 100309
100309: DISABLE
100310: LD_INT 0
100312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100313: LD_ADDR_VAR 0 1
100317: PUSH
100318: LD_INT 22
100320: PUSH
100321: LD_OWVAR 2
100325: PUSH
100326: EMPTY
100327: LIST
100328: LIST
100329: PUSH
100330: LD_INT 21
100332: PUSH
100333: LD_INT 1
100335: PUSH
100336: EMPTY
100337: LIST
100338: LIST
100339: PUSH
100340: EMPTY
100341: LIST
100342: LIST
100343: PPUSH
100344: CALL_OW 69
100348: ST_TO_ADDR
// if not tmp then
100349: LD_VAR 0 1
100353: NOT
100354: IFFALSE 100358
// exit ;
100356: GO 100403
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
100358: LD_VAR 0 1
100362: PUSH
100363: LD_INT 1
100365: PPUSH
100366: LD_VAR 0 1
100370: PPUSH
100371: CALL_OW 12
100375: ARRAY
100376: PPUSH
100377: LD_INT 1
100379: PPUSH
100380: LD_INT 4
100382: PPUSH
100383: CALL_OW 12
100387: PPUSH
100388: LD_INT 3000
100390: PPUSH
100391: LD_INT 9000
100393: PPUSH
100394: CALL_OW 12
100398: PPUSH
100399: CALL_OW 492
// end ;
100403: PPOPN 1
100405: END
// every 0 0$1 trigger StreamModeActive and sDepot do
100406: LD_EXP 120
100410: PUSH
100411: LD_EXP 135
100415: AND
100416: IFFALSE 100436
100418: GO 100420
100420: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
100421: LD_INT 1
100423: PPUSH
100424: LD_OWVAR 2
100428: PPUSH
100429: LD_INT 0
100431: PPUSH
100432: CALL_OW 324
100436: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
100437: LD_EXP 120
100441: PUSH
100442: LD_EXP 136
100446: AND
100447: IFFALSE 100530
100449: GO 100451
100451: DISABLE
100452: LD_INT 0
100454: PPUSH
100455: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100456: LD_ADDR_VAR 0 2
100460: PUSH
100461: LD_INT 22
100463: PUSH
100464: LD_OWVAR 2
100468: PUSH
100469: EMPTY
100470: LIST
100471: LIST
100472: PUSH
100473: LD_INT 21
100475: PUSH
100476: LD_INT 3
100478: PUSH
100479: EMPTY
100480: LIST
100481: LIST
100482: PUSH
100483: EMPTY
100484: LIST
100485: LIST
100486: PPUSH
100487: CALL_OW 69
100491: ST_TO_ADDR
// if not tmp then
100492: LD_VAR 0 2
100496: NOT
100497: IFFALSE 100501
// exit ;
100499: GO 100530
// for i in tmp do
100501: LD_ADDR_VAR 0 1
100505: PUSH
100506: LD_VAR 0 2
100510: PUSH
100511: FOR_IN
100512: IFFALSE 100528
// SetBLevel ( i , 10 ) ;
100514: LD_VAR 0 1
100518: PPUSH
100519: LD_INT 10
100521: PPUSH
100522: CALL_OW 241
100526: GO 100511
100528: POP
100529: POP
// end ;
100530: PPOPN 2
100532: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
100533: LD_EXP 120
100537: PUSH
100538: LD_EXP 137
100542: AND
100543: IFFALSE 100654
100545: GO 100547
100547: DISABLE
100548: LD_INT 0
100550: PPUSH
100551: PPUSH
100552: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100553: LD_ADDR_VAR 0 3
100557: PUSH
100558: LD_INT 22
100560: PUSH
100561: LD_OWVAR 2
100565: PUSH
100566: EMPTY
100567: LIST
100568: LIST
100569: PUSH
100570: LD_INT 25
100572: PUSH
100573: LD_INT 1
100575: PUSH
100576: EMPTY
100577: LIST
100578: LIST
100579: PUSH
100580: EMPTY
100581: LIST
100582: LIST
100583: PPUSH
100584: CALL_OW 69
100588: ST_TO_ADDR
// if not tmp then
100589: LD_VAR 0 3
100593: NOT
100594: IFFALSE 100598
// exit ;
100596: GO 100654
// un := tmp [ rand ( 1 , tmp ) ] ;
100598: LD_ADDR_VAR 0 2
100602: PUSH
100603: LD_VAR 0 3
100607: PUSH
100608: LD_INT 1
100610: PPUSH
100611: LD_VAR 0 3
100615: PPUSH
100616: CALL_OW 12
100620: ARRAY
100621: ST_TO_ADDR
// if Crawls ( un ) then
100622: LD_VAR 0 2
100626: PPUSH
100627: CALL_OW 318
100631: IFFALSE 100642
// ComWalk ( un ) ;
100633: LD_VAR 0 2
100637: PPUSH
100638: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100642: LD_VAR 0 2
100646: PPUSH
100647: LD_INT 5
100649: PPUSH
100650: CALL_OW 336
// end ;
100654: PPOPN 3
100656: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100657: LD_EXP 120
100661: PUSH
100662: LD_EXP 138
100666: AND
100667: PUSH
100668: LD_OWVAR 67
100672: PUSH
100673: LD_INT 4
100675: LESS
100676: AND
100677: IFFALSE 100696
100679: GO 100681
100681: DISABLE
// begin Difficulty := Difficulty + 1 ;
100682: LD_ADDR_OWVAR 67
100686: PUSH
100687: LD_OWVAR 67
100691: PUSH
100692: LD_INT 1
100694: PLUS
100695: ST_TO_ADDR
// end ;
100696: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100697: LD_EXP 120
100701: PUSH
100702: LD_EXP 139
100706: AND
100707: IFFALSE 100810
100709: GO 100711
100711: DISABLE
100712: LD_INT 0
100714: PPUSH
// begin for i := 1 to 5 do
100715: LD_ADDR_VAR 0 1
100719: PUSH
100720: DOUBLE
100721: LD_INT 1
100723: DEC
100724: ST_TO_ADDR
100725: LD_INT 5
100727: PUSH
100728: FOR_TO
100729: IFFALSE 100808
// begin uc_nation := nation_nature ;
100731: LD_ADDR_OWVAR 21
100735: PUSH
100736: LD_INT 0
100738: ST_TO_ADDR
// uc_side := 0 ;
100739: LD_ADDR_OWVAR 20
100743: PUSH
100744: LD_INT 0
100746: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100747: LD_ADDR_OWVAR 29
100751: PUSH
100752: LD_INT 12
100754: PUSH
100755: LD_INT 12
100757: PUSH
100758: EMPTY
100759: LIST
100760: LIST
100761: ST_TO_ADDR
// hc_agressivity := 20 ;
100762: LD_ADDR_OWVAR 35
100766: PUSH
100767: LD_INT 20
100769: ST_TO_ADDR
// hc_class := class_tiger ;
100770: LD_ADDR_OWVAR 28
100774: PUSH
100775: LD_INT 14
100777: ST_TO_ADDR
// hc_gallery :=  ;
100778: LD_ADDR_OWVAR 33
100782: PUSH
100783: LD_STRING 
100785: ST_TO_ADDR
// hc_name :=  ;
100786: LD_ADDR_OWVAR 26
100790: PUSH
100791: LD_STRING 
100793: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100794: CALL_OW 44
100798: PPUSH
100799: LD_INT 0
100801: PPUSH
100802: CALL_OW 51
// end ;
100806: GO 100728
100808: POP
100809: POP
// end ;
100810: PPOPN 1
100812: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100813: LD_EXP 120
100817: PUSH
100818: LD_EXP 140
100822: AND
100823: IFFALSE 100832
100825: GO 100827
100827: DISABLE
// StreamSibBomb ;
100828: CALL 100833 0 0
100832: END
// export function StreamSibBomb ; var i , x , y ; begin
100833: LD_INT 0
100835: PPUSH
100836: PPUSH
100837: PPUSH
100838: PPUSH
// result := false ;
100839: LD_ADDR_VAR 0 1
100843: PUSH
100844: LD_INT 0
100846: ST_TO_ADDR
// for i := 1 to 16 do
100847: LD_ADDR_VAR 0 2
100851: PUSH
100852: DOUBLE
100853: LD_INT 1
100855: DEC
100856: ST_TO_ADDR
100857: LD_INT 16
100859: PUSH
100860: FOR_TO
100861: IFFALSE 101060
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100863: LD_ADDR_VAR 0 3
100867: PUSH
100868: LD_INT 10
100870: PUSH
100871: LD_INT 20
100873: PUSH
100874: LD_INT 30
100876: PUSH
100877: LD_INT 40
100879: PUSH
100880: LD_INT 50
100882: PUSH
100883: LD_INT 60
100885: PUSH
100886: LD_INT 70
100888: PUSH
100889: LD_INT 80
100891: PUSH
100892: LD_INT 90
100894: PUSH
100895: LD_INT 100
100897: PUSH
100898: LD_INT 110
100900: PUSH
100901: LD_INT 120
100903: PUSH
100904: LD_INT 130
100906: PUSH
100907: LD_INT 140
100909: PUSH
100910: LD_INT 150
100912: PUSH
100913: EMPTY
100914: LIST
100915: LIST
100916: LIST
100917: LIST
100918: LIST
100919: LIST
100920: LIST
100921: LIST
100922: LIST
100923: LIST
100924: LIST
100925: LIST
100926: LIST
100927: LIST
100928: LIST
100929: PUSH
100930: LD_INT 1
100932: PPUSH
100933: LD_INT 15
100935: PPUSH
100936: CALL_OW 12
100940: ARRAY
100941: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100942: LD_ADDR_VAR 0 4
100946: PUSH
100947: LD_INT 10
100949: PUSH
100950: LD_INT 20
100952: PUSH
100953: LD_INT 30
100955: PUSH
100956: LD_INT 40
100958: PUSH
100959: LD_INT 50
100961: PUSH
100962: LD_INT 60
100964: PUSH
100965: LD_INT 70
100967: PUSH
100968: LD_INT 80
100970: PUSH
100971: LD_INT 90
100973: PUSH
100974: LD_INT 100
100976: PUSH
100977: LD_INT 110
100979: PUSH
100980: LD_INT 120
100982: PUSH
100983: LD_INT 130
100985: PUSH
100986: LD_INT 140
100988: PUSH
100989: LD_INT 150
100991: PUSH
100992: EMPTY
100993: LIST
100994: LIST
100995: LIST
100996: LIST
100997: LIST
100998: LIST
100999: LIST
101000: LIST
101001: LIST
101002: LIST
101003: LIST
101004: LIST
101005: LIST
101006: LIST
101007: LIST
101008: PUSH
101009: LD_INT 1
101011: PPUSH
101012: LD_INT 15
101014: PPUSH
101015: CALL_OW 12
101019: ARRAY
101020: ST_TO_ADDR
// if ValidHex ( x , y ) then
101021: LD_VAR 0 3
101025: PPUSH
101026: LD_VAR 0 4
101030: PPUSH
101031: CALL_OW 488
101035: IFFALSE 101058
// begin result := [ x , y ] ;
101037: LD_ADDR_VAR 0 1
101041: PUSH
101042: LD_VAR 0 3
101046: PUSH
101047: LD_VAR 0 4
101051: PUSH
101052: EMPTY
101053: LIST
101054: LIST
101055: ST_TO_ADDR
// break ;
101056: GO 101060
// end ; end ;
101058: GO 100860
101060: POP
101061: POP
// if result then
101062: LD_VAR 0 1
101066: IFFALSE 101126
// begin ToLua ( playSibBomb() ) ;
101068: LD_STRING playSibBomb()
101070: PPUSH
101071: CALL_OW 559
// wait ( 0 0$14 ) ;
101075: LD_INT 490
101077: PPUSH
101078: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101082: LD_VAR 0 1
101086: PUSH
101087: LD_INT 1
101089: ARRAY
101090: PPUSH
101091: LD_VAR 0 1
101095: PUSH
101096: LD_INT 2
101098: ARRAY
101099: PPUSH
101100: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101104: LD_VAR 0 1
101108: PUSH
101109: LD_INT 1
101111: ARRAY
101112: PPUSH
101113: LD_VAR 0 1
101117: PUSH
101118: LD_INT 2
101120: ARRAY
101121: PPUSH
101122: CALL_OW 429
// end ; end ;
101126: LD_VAR 0 1
101130: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101131: LD_EXP 120
101135: PUSH
101136: LD_EXP 142
101140: AND
101141: IFFALSE 101153
101143: GO 101145
101145: DISABLE
// YouLost (  ) ;
101146: LD_STRING 
101148: PPUSH
101149: CALL_OW 104
101153: END
// every 0 0$1 trigger StreamModeActive and sFog do
101154: LD_EXP 120
101158: PUSH
101159: LD_EXP 141
101163: AND
101164: IFFALSE 101178
101166: GO 101168
101168: DISABLE
// FogOff ( your_side ) ;
101169: LD_OWVAR 2
101173: PPUSH
101174: CALL_OW 344
101178: END
// every 0 0$1 trigger StreamModeActive and sSun do
101179: LD_EXP 120
101183: PUSH
101184: LD_EXP 143
101188: AND
101189: IFFALSE 101217
101191: GO 101193
101193: DISABLE
// begin solar_recharge_percent := 0 ;
101194: LD_ADDR_OWVAR 79
101198: PUSH
101199: LD_INT 0
101201: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101202: LD_INT 10500
101204: PPUSH
101205: CALL_OW 67
// solar_recharge_percent := 100 ;
101209: LD_ADDR_OWVAR 79
101213: PUSH
101214: LD_INT 100
101216: ST_TO_ADDR
// end ;
101217: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101218: LD_EXP 120
101222: PUSH
101223: LD_EXP 144
101227: AND
101228: IFFALSE 101467
101230: GO 101232
101232: DISABLE
101233: LD_INT 0
101235: PPUSH
101236: PPUSH
101237: PPUSH
// begin tmp := [ ] ;
101238: LD_ADDR_VAR 0 3
101242: PUSH
101243: EMPTY
101244: ST_TO_ADDR
// for i := 1 to 6 do
101245: LD_ADDR_VAR 0 1
101249: PUSH
101250: DOUBLE
101251: LD_INT 1
101253: DEC
101254: ST_TO_ADDR
101255: LD_INT 6
101257: PUSH
101258: FOR_TO
101259: IFFALSE 101364
// begin uc_nation := nation_nature ;
101261: LD_ADDR_OWVAR 21
101265: PUSH
101266: LD_INT 0
101268: ST_TO_ADDR
// uc_side := 0 ;
101269: LD_ADDR_OWVAR 20
101273: PUSH
101274: LD_INT 0
101276: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101277: LD_ADDR_OWVAR 29
101281: PUSH
101282: LD_INT 12
101284: PUSH
101285: LD_INT 12
101287: PUSH
101288: EMPTY
101289: LIST
101290: LIST
101291: ST_TO_ADDR
// hc_agressivity := 20 ;
101292: LD_ADDR_OWVAR 35
101296: PUSH
101297: LD_INT 20
101299: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
101300: LD_ADDR_OWVAR 28
101304: PUSH
101305: LD_INT 17
101307: ST_TO_ADDR
// hc_gallery :=  ;
101308: LD_ADDR_OWVAR 33
101312: PUSH
101313: LD_STRING 
101315: ST_TO_ADDR
// hc_name :=  ;
101316: LD_ADDR_OWVAR 26
101320: PUSH
101321: LD_STRING 
101323: ST_TO_ADDR
// un := CreateHuman ;
101324: LD_ADDR_VAR 0 2
101328: PUSH
101329: CALL_OW 44
101333: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
101334: LD_VAR 0 2
101338: PPUSH
101339: LD_INT 1
101341: PPUSH
101342: CALL_OW 51
// tmp := tmp ^ un ;
101346: LD_ADDR_VAR 0 3
101350: PUSH
101351: LD_VAR 0 3
101355: PUSH
101356: LD_VAR 0 2
101360: ADD
101361: ST_TO_ADDR
// end ;
101362: GO 101258
101364: POP
101365: POP
// repeat wait ( 0 0$1 ) ;
101366: LD_INT 35
101368: PPUSH
101369: CALL_OW 67
// for un in tmp do
101373: LD_ADDR_VAR 0 2
101377: PUSH
101378: LD_VAR 0 3
101382: PUSH
101383: FOR_IN
101384: IFFALSE 101458
// begin if IsDead ( un ) then
101386: LD_VAR 0 2
101390: PPUSH
101391: CALL_OW 301
101395: IFFALSE 101415
// begin tmp := tmp diff un ;
101397: LD_ADDR_VAR 0 3
101401: PUSH
101402: LD_VAR 0 3
101406: PUSH
101407: LD_VAR 0 2
101411: DIFF
101412: ST_TO_ADDR
// continue ;
101413: GO 101383
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
101415: LD_VAR 0 2
101419: PPUSH
101420: LD_INT 3
101422: PUSH
101423: LD_INT 22
101425: PUSH
101426: LD_INT 0
101428: PUSH
101429: EMPTY
101430: LIST
101431: LIST
101432: PUSH
101433: EMPTY
101434: LIST
101435: LIST
101436: PPUSH
101437: CALL_OW 69
101441: PPUSH
101442: LD_VAR 0 2
101446: PPUSH
101447: CALL_OW 74
101451: PPUSH
101452: CALL_OW 115
// end ;
101456: GO 101383
101458: POP
101459: POP
// until not tmp ;
101460: LD_VAR 0 3
101464: NOT
101465: IFFALSE 101366
// end ;
101467: PPOPN 3
101469: END
// every 0 0$1 trigger StreamModeActive and sTroll do
101470: LD_EXP 120
101474: PUSH
101475: LD_EXP 145
101479: AND
101480: IFFALSE 101534
101482: GO 101484
101484: DISABLE
// begin ToLua ( displayTroll(); ) ;
101485: LD_STRING displayTroll();
101487: PPUSH
101488: CALL_OW 559
// wait ( 3 3$00 ) ;
101492: LD_INT 6300
101494: PPUSH
101495: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101499: LD_STRING hideTroll();
101501: PPUSH
101502: CALL_OW 559
// wait ( 1 1$00 ) ;
101506: LD_INT 2100
101508: PPUSH
101509: CALL_OW 67
// ToLua ( displayTroll(); ) ;
101513: LD_STRING displayTroll();
101515: PPUSH
101516: CALL_OW 559
// wait ( 1 1$00 ) ;
101520: LD_INT 2100
101522: PPUSH
101523: CALL_OW 67
// ToLua ( hideTroll(); ) ;
101527: LD_STRING hideTroll();
101529: PPUSH
101530: CALL_OW 559
// end ;
101534: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
101535: LD_EXP 120
101539: PUSH
101540: LD_EXP 146
101544: AND
101545: IFFALSE 101608
101547: GO 101549
101549: DISABLE
101550: LD_INT 0
101552: PPUSH
// begin p := 0 ;
101553: LD_ADDR_VAR 0 1
101557: PUSH
101558: LD_INT 0
101560: ST_TO_ADDR
// repeat game_speed := 1 ;
101561: LD_ADDR_OWVAR 65
101565: PUSH
101566: LD_INT 1
101568: ST_TO_ADDR
// wait ( 0 0$1 ) ;
101569: LD_INT 35
101571: PPUSH
101572: CALL_OW 67
// p := p + 1 ;
101576: LD_ADDR_VAR 0 1
101580: PUSH
101581: LD_VAR 0 1
101585: PUSH
101586: LD_INT 1
101588: PLUS
101589: ST_TO_ADDR
// until p >= 60 ;
101590: LD_VAR 0 1
101594: PUSH
101595: LD_INT 60
101597: GREATEREQUAL
101598: IFFALSE 101561
// game_speed := 4 ;
101600: LD_ADDR_OWVAR 65
101604: PUSH
101605: LD_INT 4
101607: ST_TO_ADDR
// end ;
101608: PPOPN 1
101610: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101611: LD_EXP 120
101615: PUSH
101616: LD_EXP 147
101620: AND
101621: IFFALSE 101767
101623: GO 101625
101625: DISABLE
101626: LD_INT 0
101628: PPUSH
101629: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101630: LD_ADDR_VAR 0 1
101634: PUSH
101635: LD_INT 22
101637: PUSH
101638: LD_OWVAR 2
101642: PUSH
101643: EMPTY
101644: LIST
101645: LIST
101646: PUSH
101647: LD_INT 2
101649: PUSH
101650: LD_INT 30
101652: PUSH
101653: LD_INT 0
101655: PUSH
101656: EMPTY
101657: LIST
101658: LIST
101659: PUSH
101660: LD_INT 30
101662: PUSH
101663: LD_INT 1
101665: PUSH
101666: EMPTY
101667: LIST
101668: LIST
101669: PUSH
101670: EMPTY
101671: LIST
101672: LIST
101673: LIST
101674: PUSH
101675: EMPTY
101676: LIST
101677: LIST
101678: PPUSH
101679: CALL_OW 69
101683: ST_TO_ADDR
// if not depot then
101684: LD_VAR 0 1
101688: NOT
101689: IFFALSE 101693
// exit ;
101691: GO 101767
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101693: LD_ADDR_VAR 0 2
101697: PUSH
101698: LD_VAR 0 1
101702: PUSH
101703: LD_INT 1
101705: PPUSH
101706: LD_VAR 0 1
101710: PPUSH
101711: CALL_OW 12
101715: ARRAY
101716: PPUSH
101717: CALL_OW 274
101721: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101722: LD_VAR 0 2
101726: PPUSH
101727: LD_INT 1
101729: PPUSH
101730: LD_INT 0
101732: PPUSH
101733: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101737: LD_VAR 0 2
101741: PPUSH
101742: LD_INT 2
101744: PPUSH
101745: LD_INT 0
101747: PPUSH
101748: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101752: LD_VAR 0 2
101756: PPUSH
101757: LD_INT 3
101759: PPUSH
101760: LD_INT 0
101762: PPUSH
101763: CALL_OW 277
// end ;
101767: PPOPN 2
101769: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101770: LD_EXP 120
101774: PUSH
101775: LD_EXP 148
101779: AND
101780: IFFALSE 101877
101782: GO 101784
101784: DISABLE
101785: LD_INT 0
101787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101788: LD_ADDR_VAR 0 1
101792: PUSH
101793: LD_INT 22
101795: PUSH
101796: LD_OWVAR 2
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: PUSH
101805: LD_INT 21
101807: PUSH
101808: LD_INT 1
101810: PUSH
101811: EMPTY
101812: LIST
101813: LIST
101814: PUSH
101815: LD_INT 3
101817: PUSH
101818: LD_INT 23
101820: PUSH
101821: LD_INT 0
101823: PUSH
101824: EMPTY
101825: LIST
101826: LIST
101827: PUSH
101828: EMPTY
101829: LIST
101830: LIST
101831: PUSH
101832: EMPTY
101833: LIST
101834: LIST
101835: LIST
101836: PPUSH
101837: CALL_OW 69
101841: ST_TO_ADDR
// if not tmp then
101842: LD_VAR 0 1
101846: NOT
101847: IFFALSE 101851
// exit ;
101849: GO 101877
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101851: LD_VAR 0 1
101855: PUSH
101856: LD_INT 1
101858: PPUSH
101859: LD_VAR 0 1
101863: PPUSH
101864: CALL_OW 12
101868: ARRAY
101869: PPUSH
101870: LD_INT 200
101872: PPUSH
101873: CALL_OW 234
// end ;
101877: PPOPN 1
101879: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101880: LD_EXP 120
101884: PUSH
101885: LD_EXP 149
101889: AND
101890: IFFALSE 101969
101892: GO 101894
101894: DISABLE
101895: LD_INT 0
101897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101898: LD_ADDR_VAR 0 1
101902: PUSH
101903: LD_INT 22
101905: PUSH
101906: LD_OWVAR 2
101910: PUSH
101911: EMPTY
101912: LIST
101913: LIST
101914: PUSH
101915: LD_INT 21
101917: PUSH
101918: LD_INT 2
101920: PUSH
101921: EMPTY
101922: LIST
101923: LIST
101924: PUSH
101925: EMPTY
101926: LIST
101927: LIST
101928: PPUSH
101929: CALL_OW 69
101933: ST_TO_ADDR
// if not tmp then
101934: LD_VAR 0 1
101938: NOT
101939: IFFALSE 101943
// exit ;
101941: GO 101969
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101943: LD_VAR 0 1
101947: PUSH
101948: LD_INT 1
101950: PPUSH
101951: LD_VAR 0 1
101955: PPUSH
101956: CALL_OW 12
101960: ARRAY
101961: PPUSH
101962: LD_INT 60
101964: PPUSH
101965: CALL_OW 234
// end ;
101969: PPOPN 1
101971: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101972: LD_EXP 120
101976: PUSH
101977: LD_EXP 150
101981: AND
101982: IFFALSE 102081
101984: GO 101986
101986: DISABLE
101987: LD_INT 0
101989: PPUSH
101990: PPUSH
// begin enable ;
101991: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101992: LD_ADDR_VAR 0 1
101996: PUSH
101997: LD_INT 22
101999: PUSH
102000: LD_OWVAR 2
102004: PUSH
102005: EMPTY
102006: LIST
102007: LIST
102008: PUSH
102009: LD_INT 61
102011: PUSH
102012: EMPTY
102013: LIST
102014: PUSH
102015: LD_INT 33
102017: PUSH
102018: LD_INT 2
102020: PUSH
102021: EMPTY
102022: LIST
102023: LIST
102024: PUSH
102025: EMPTY
102026: LIST
102027: LIST
102028: LIST
102029: PPUSH
102030: CALL_OW 69
102034: ST_TO_ADDR
// if not tmp then
102035: LD_VAR 0 1
102039: NOT
102040: IFFALSE 102044
// exit ;
102042: GO 102081
// for i in tmp do
102044: LD_ADDR_VAR 0 2
102048: PUSH
102049: LD_VAR 0 1
102053: PUSH
102054: FOR_IN
102055: IFFALSE 102079
// if IsControledBy ( i ) then
102057: LD_VAR 0 2
102061: PPUSH
102062: CALL_OW 312
102066: IFFALSE 102077
// ComUnlink ( i ) ;
102068: LD_VAR 0 2
102072: PPUSH
102073: CALL_OW 136
102077: GO 102054
102079: POP
102080: POP
// end ;
102081: PPOPN 2
102083: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102084: LD_EXP 120
102088: PUSH
102089: LD_EXP 151
102093: AND
102094: IFFALSE 102234
102096: GO 102098
102098: DISABLE
102099: LD_INT 0
102101: PPUSH
102102: PPUSH
// begin ToLua ( displayPowell(); ) ;
102103: LD_STRING displayPowell();
102105: PPUSH
102106: CALL_OW 559
// uc_side := 0 ;
102110: LD_ADDR_OWVAR 20
102114: PUSH
102115: LD_INT 0
102117: ST_TO_ADDR
// uc_nation := 2 ;
102118: LD_ADDR_OWVAR 21
102122: PUSH
102123: LD_INT 2
102125: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102126: LD_ADDR_OWVAR 37
102130: PUSH
102131: LD_INT 14
102133: ST_TO_ADDR
// vc_engine := engine_siberite ;
102134: LD_ADDR_OWVAR 39
102138: PUSH
102139: LD_INT 3
102141: ST_TO_ADDR
// vc_control := control_apeman ;
102142: LD_ADDR_OWVAR 38
102146: PUSH
102147: LD_INT 5
102149: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102150: LD_ADDR_OWVAR 40
102154: PUSH
102155: LD_INT 29
102157: ST_TO_ADDR
// un := CreateVehicle ;
102158: LD_ADDR_VAR 0 2
102162: PUSH
102163: CALL_OW 45
102167: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102168: LD_VAR 0 2
102172: PPUSH
102173: LD_INT 1
102175: PPUSH
102176: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102180: LD_INT 35
102182: PPUSH
102183: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102187: LD_VAR 0 2
102191: PPUSH
102192: LD_INT 22
102194: PUSH
102195: LD_OWVAR 2
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PPUSH
102204: CALL_OW 69
102208: PPUSH
102209: LD_VAR 0 2
102213: PPUSH
102214: CALL_OW 74
102218: PPUSH
102219: CALL_OW 115
// until IsDead ( un ) ;
102223: LD_VAR 0 2
102227: PPUSH
102228: CALL_OW 301
102232: IFFALSE 102180
// end ;
102234: PPOPN 2
102236: END
// every 0 0$1 trigger StreamModeActive and sStu do
102237: LD_EXP 120
102241: PUSH
102242: LD_EXP 159
102246: AND
102247: IFFALSE 102263
102249: GO 102251
102251: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102252: LD_STRING displayStucuk();
102254: PPUSH
102255: CALL_OW 559
// ResetFog ;
102259: CALL_OW 335
// end ;
102263: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102264: LD_EXP 120
102268: PUSH
102269: LD_EXP 152
102273: AND
102274: IFFALSE 102415
102276: GO 102278
102278: DISABLE
102279: LD_INT 0
102281: PPUSH
102282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102283: LD_ADDR_VAR 0 2
102287: PUSH
102288: LD_INT 22
102290: PUSH
102291: LD_OWVAR 2
102295: PUSH
102296: EMPTY
102297: LIST
102298: LIST
102299: PUSH
102300: LD_INT 21
102302: PUSH
102303: LD_INT 1
102305: PUSH
102306: EMPTY
102307: LIST
102308: LIST
102309: PUSH
102310: EMPTY
102311: LIST
102312: LIST
102313: PPUSH
102314: CALL_OW 69
102318: ST_TO_ADDR
// if not tmp then
102319: LD_VAR 0 2
102323: NOT
102324: IFFALSE 102328
// exit ;
102326: GO 102415
// un := tmp [ rand ( 1 , tmp ) ] ;
102328: LD_ADDR_VAR 0 1
102332: PUSH
102333: LD_VAR 0 2
102337: PUSH
102338: LD_INT 1
102340: PPUSH
102341: LD_VAR 0 2
102345: PPUSH
102346: CALL_OW 12
102350: ARRAY
102351: ST_TO_ADDR
// SetSide ( un , 0 ) ;
102352: LD_VAR 0 1
102356: PPUSH
102357: LD_INT 0
102359: PPUSH
102360: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
102364: LD_VAR 0 1
102368: PPUSH
102369: LD_OWVAR 3
102373: PUSH
102374: LD_VAR 0 1
102378: DIFF
102379: PPUSH
102380: LD_VAR 0 1
102384: PPUSH
102385: CALL_OW 74
102389: PPUSH
102390: CALL_OW 115
// wait ( 0 0$20 ) ;
102394: LD_INT 700
102396: PPUSH
102397: CALL_OW 67
// SetSide ( un , your_side ) ;
102401: LD_VAR 0 1
102405: PPUSH
102406: LD_OWVAR 2
102410: PPUSH
102411: CALL_OW 235
// end ;
102415: PPOPN 2
102417: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
102418: LD_EXP 120
102422: PUSH
102423: LD_EXP 153
102427: AND
102428: IFFALSE 102534
102430: GO 102432
102432: DISABLE
102433: LD_INT 0
102435: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102436: LD_ADDR_VAR 0 1
102440: PUSH
102441: LD_INT 22
102443: PUSH
102444: LD_OWVAR 2
102448: PUSH
102449: EMPTY
102450: LIST
102451: LIST
102452: PUSH
102453: LD_INT 2
102455: PUSH
102456: LD_INT 30
102458: PUSH
102459: LD_INT 0
102461: PUSH
102462: EMPTY
102463: LIST
102464: LIST
102465: PUSH
102466: LD_INT 30
102468: PUSH
102469: LD_INT 1
102471: PUSH
102472: EMPTY
102473: LIST
102474: LIST
102475: PUSH
102476: EMPTY
102477: LIST
102478: LIST
102479: LIST
102480: PUSH
102481: EMPTY
102482: LIST
102483: LIST
102484: PPUSH
102485: CALL_OW 69
102489: ST_TO_ADDR
// if not depot then
102490: LD_VAR 0 1
102494: NOT
102495: IFFALSE 102499
// exit ;
102497: GO 102534
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
102499: LD_VAR 0 1
102503: PUSH
102504: LD_INT 1
102506: ARRAY
102507: PPUSH
102508: CALL_OW 250
102512: PPUSH
102513: LD_VAR 0 1
102517: PUSH
102518: LD_INT 1
102520: ARRAY
102521: PPUSH
102522: CALL_OW 251
102526: PPUSH
102527: LD_INT 70
102529: PPUSH
102530: CALL_OW 495
// end ;
102534: PPOPN 1
102536: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
102537: LD_EXP 120
102541: PUSH
102542: LD_EXP 154
102546: AND
102547: IFFALSE 102758
102549: GO 102551
102551: DISABLE
102552: LD_INT 0
102554: PPUSH
102555: PPUSH
102556: PPUSH
102557: PPUSH
102558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102559: LD_ADDR_VAR 0 5
102563: PUSH
102564: LD_INT 22
102566: PUSH
102567: LD_OWVAR 2
102571: PUSH
102572: EMPTY
102573: LIST
102574: LIST
102575: PUSH
102576: LD_INT 21
102578: PUSH
102579: LD_INT 1
102581: PUSH
102582: EMPTY
102583: LIST
102584: LIST
102585: PUSH
102586: EMPTY
102587: LIST
102588: LIST
102589: PPUSH
102590: CALL_OW 69
102594: ST_TO_ADDR
// if not tmp then
102595: LD_VAR 0 5
102599: NOT
102600: IFFALSE 102604
// exit ;
102602: GO 102758
// for i in tmp do
102604: LD_ADDR_VAR 0 1
102608: PUSH
102609: LD_VAR 0 5
102613: PUSH
102614: FOR_IN
102615: IFFALSE 102756
// begin d := rand ( 0 , 5 ) ;
102617: LD_ADDR_VAR 0 4
102621: PUSH
102622: LD_INT 0
102624: PPUSH
102625: LD_INT 5
102627: PPUSH
102628: CALL_OW 12
102632: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102633: LD_ADDR_VAR 0 2
102637: PUSH
102638: LD_VAR 0 1
102642: PPUSH
102643: CALL_OW 250
102647: PPUSH
102648: LD_VAR 0 4
102652: PPUSH
102653: LD_INT 3
102655: PPUSH
102656: LD_INT 12
102658: PPUSH
102659: CALL_OW 12
102663: PPUSH
102664: CALL_OW 272
102668: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102669: LD_ADDR_VAR 0 3
102673: PUSH
102674: LD_VAR 0 1
102678: PPUSH
102679: CALL_OW 251
102683: PPUSH
102684: LD_VAR 0 4
102688: PPUSH
102689: LD_INT 3
102691: PPUSH
102692: LD_INT 12
102694: PPUSH
102695: CALL_OW 12
102699: PPUSH
102700: CALL_OW 273
102704: ST_TO_ADDR
// if ValidHex ( x , y ) then
102705: LD_VAR 0 2
102709: PPUSH
102710: LD_VAR 0 3
102714: PPUSH
102715: CALL_OW 488
102719: IFFALSE 102754
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102721: LD_VAR 0 1
102725: PPUSH
102726: LD_VAR 0 2
102730: PPUSH
102731: LD_VAR 0 3
102735: PPUSH
102736: LD_INT 3
102738: PPUSH
102739: LD_INT 6
102741: PPUSH
102742: CALL_OW 12
102746: PPUSH
102747: LD_INT 1
102749: PPUSH
102750: CALL_OW 483
// end ;
102754: GO 102614
102756: POP
102757: POP
// end ;
102758: PPOPN 5
102760: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102761: LD_EXP 120
102765: PUSH
102766: LD_EXP 155
102770: AND
102771: IFFALSE 102865
102773: GO 102775
102775: DISABLE
102776: LD_INT 0
102778: PPUSH
102779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102780: LD_ADDR_VAR 0 2
102784: PUSH
102785: LD_INT 22
102787: PUSH
102788: LD_OWVAR 2
102792: PUSH
102793: EMPTY
102794: LIST
102795: LIST
102796: PUSH
102797: LD_INT 32
102799: PUSH
102800: LD_INT 1
102802: PUSH
102803: EMPTY
102804: LIST
102805: LIST
102806: PUSH
102807: LD_INT 21
102809: PUSH
102810: LD_INT 2
102812: PUSH
102813: EMPTY
102814: LIST
102815: LIST
102816: PUSH
102817: EMPTY
102818: LIST
102819: LIST
102820: LIST
102821: PPUSH
102822: CALL_OW 69
102826: ST_TO_ADDR
// if not tmp then
102827: LD_VAR 0 2
102831: NOT
102832: IFFALSE 102836
// exit ;
102834: GO 102865
// for i in tmp do
102836: LD_ADDR_VAR 0 1
102840: PUSH
102841: LD_VAR 0 2
102845: PUSH
102846: FOR_IN
102847: IFFALSE 102863
// SetFuel ( i , 0 ) ;
102849: LD_VAR 0 1
102853: PPUSH
102854: LD_INT 0
102856: PPUSH
102857: CALL_OW 240
102861: GO 102846
102863: POP
102864: POP
// end ;
102865: PPOPN 2
102867: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102868: LD_EXP 120
102872: PUSH
102873: LD_EXP 156
102877: AND
102878: IFFALSE 102944
102880: GO 102882
102882: DISABLE
102883: LD_INT 0
102885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102886: LD_ADDR_VAR 0 1
102890: PUSH
102891: LD_INT 22
102893: PUSH
102894: LD_OWVAR 2
102898: PUSH
102899: EMPTY
102900: LIST
102901: LIST
102902: PUSH
102903: LD_INT 30
102905: PUSH
102906: LD_INT 29
102908: PUSH
102909: EMPTY
102910: LIST
102911: LIST
102912: PUSH
102913: EMPTY
102914: LIST
102915: LIST
102916: PPUSH
102917: CALL_OW 69
102921: ST_TO_ADDR
// if not tmp then
102922: LD_VAR 0 1
102926: NOT
102927: IFFALSE 102931
// exit ;
102929: GO 102944
// DestroyUnit ( tmp [ 1 ] ) ;
102931: LD_VAR 0 1
102935: PUSH
102936: LD_INT 1
102938: ARRAY
102939: PPUSH
102940: CALL_OW 65
// end ;
102944: PPOPN 1
102946: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102947: LD_EXP 120
102951: PUSH
102952: LD_EXP 158
102956: AND
102957: IFFALSE 103086
102959: GO 102961
102961: DISABLE
102962: LD_INT 0
102964: PPUSH
// begin uc_side := 0 ;
102965: LD_ADDR_OWVAR 20
102969: PUSH
102970: LD_INT 0
102972: ST_TO_ADDR
// uc_nation := nation_arabian ;
102973: LD_ADDR_OWVAR 21
102977: PUSH
102978: LD_INT 2
102980: ST_TO_ADDR
// hc_gallery :=  ;
102981: LD_ADDR_OWVAR 33
102985: PUSH
102986: LD_STRING 
102988: ST_TO_ADDR
// hc_name :=  ;
102989: LD_ADDR_OWVAR 26
102993: PUSH
102994: LD_STRING 
102996: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102997: LD_INT 1
102999: PPUSH
103000: LD_INT 11
103002: PPUSH
103003: LD_INT 10
103005: PPUSH
103006: CALL_OW 380
// un := CreateHuman ;
103010: LD_ADDR_VAR 0 1
103014: PUSH
103015: CALL_OW 44
103019: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103020: LD_VAR 0 1
103024: PPUSH
103025: LD_INT 1
103027: PPUSH
103028: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103032: LD_INT 35
103034: PPUSH
103035: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103039: LD_VAR 0 1
103043: PPUSH
103044: LD_INT 22
103046: PUSH
103047: LD_OWVAR 2
103051: PUSH
103052: EMPTY
103053: LIST
103054: LIST
103055: PPUSH
103056: CALL_OW 69
103060: PPUSH
103061: LD_VAR 0 1
103065: PPUSH
103066: CALL_OW 74
103070: PPUSH
103071: CALL_OW 115
// until IsDead ( un ) ;
103075: LD_VAR 0 1
103079: PPUSH
103080: CALL_OW 301
103084: IFFALSE 103032
// end ;
103086: PPOPN 1
103088: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103089: LD_EXP 120
103093: PUSH
103094: LD_EXP 160
103098: AND
103099: IFFALSE 103111
103101: GO 103103
103103: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103104: LD_STRING earthquake(getX(game), 0, 32)
103106: PPUSH
103107: CALL_OW 559
103111: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103112: LD_EXP 120
103116: PUSH
103117: LD_EXP 161
103121: AND
103122: IFFALSE 103213
103124: GO 103126
103126: DISABLE
103127: LD_INT 0
103129: PPUSH
// begin enable ;
103130: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103131: LD_ADDR_VAR 0 1
103135: PUSH
103136: LD_INT 22
103138: PUSH
103139: LD_OWVAR 2
103143: PUSH
103144: EMPTY
103145: LIST
103146: LIST
103147: PUSH
103148: LD_INT 21
103150: PUSH
103151: LD_INT 2
103153: PUSH
103154: EMPTY
103155: LIST
103156: LIST
103157: PUSH
103158: LD_INT 33
103160: PUSH
103161: LD_INT 3
103163: PUSH
103164: EMPTY
103165: LIST
103166: LIST
103167: PUSH
103168: EMPTY
103169: LIST
103170: LIST
103171: LIST
103172: PPUSH
103173: CALL_OW 69
103177: ST_TO_ADDR
// if not tmp then
103178: LD_VAR 0 1
103182: NOT
103183: IFFALSE 103187
// exit ;
103185: GO 103213
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103187: LD_VAR 0 1
103191: PUSH
103192: LD_INT 1
103194: PPUSH
103195: LD_VAR 0 1
103199: PPUSH
103200: CALL_OW 12
103204: ARRAY
103205: PPUSH
103206: LD_INT 1
103208: PPUSH
103209: CALL_OW 234
// end ;
103213: PPOPN 1
103215: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103216: LD_EXP 120
103220: PUSH
103221: LD_EXP 162
103225: AND
103226: IFFALSE 103367
103228: GO 103230
103230: DISABLE
103231: LD_INT 0
103233: PPUSH
103234: PPUSH
103235: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103236: LD_ADDR_VAR 0 3
103240: PUSH
103241: LD_INT 22
103243: PUSH
103244: LD_OWVAR 2
103248: PUSH
103249: EMPTY
103250: LIST
103251: LIST
103252: PUSH
103253: LD_INT 25
103255: PUSH
103256: LD_INT 1
103258: PUSH
103259: EMPTY
103260: LIST
103261: LIST
103262: PUSH
103263: EMPTY
103264: LIST
103265: LIST
103266: PPUSH
103267: CALL_OW 69
103271: ST_TO_ADDR
// if not tmp then
103272: LD_VAR 0 3
103276: NOT
103277: IFFALSE 103281
// exit ;
103279: GO 103367
// un := tmp [ rand ( 1 , tmp ) ] ;
103281: LD_ADDR_VAR 0 2
103285: PUSH
103286: LD_VAR 0 3
103290: PUSH
103291: LD_INT 1
103293: PPUSH
103294: LD_VAR 0 3
103298: PPUSH
103299: CALL_OW 12
103303: ARRAY
103304: ST_TO_ADDR
// if Crawls ( un ) then
103305: LD_VAR 0 2
103309: PPUSH
103310: CALL_OW 318
103314: IFFALSE 103325
// ComWalk ( un ) ;
103316: LD_VAR 0 2
103320: PPUSH
103321: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
103325: LD_VAR 0 2
103329: PPUSH
103330: LD_INT 9
103332: PPUSH
103333: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
103337: LD_INT 28
103339: PPUSH
103340: LD_OWVAR 2
103344: PPUSH
103345: LD_INT 2
103347: PPUSH
103348: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
103352: LD_INT 29
103354: PPUSH
103355: LD_OWVAR 2
103359: PPUSH
103360: LD_INT 2
103362: PPUSH
103363: CALL_OW 322
// end ;
103367: PPOPN 3
103369: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
103370: LD_EXP 120
103374: PUSH
103375: LD_EXP 163
103379: AND
103380: IFFALSE 103491
103382: GO 103384
103384: DISABLE
103385: LD_INT 0
103387: PPUSH
103388: PPUSH
103389: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103390: LD_ADDR_VAR 0 3
103394: PUSH
103395: LD_INT 22
103397: PUSH
103398: LD_OWVAR 2
103402: PUSH
103403: EMPTY
103404: LIST
103405: LIST
103406: PUSH
103407: LD_INT 25
103409: PUSH
103410: LD_INT 1
103412: PUSH
103413: EMPTY
103414: LIST
103415: LIST
103416: PUSH
103417: EMPTY
103418: LIST
103419: LIST
103420: PPUSH
103421: CALL_OW 69
103425: ST_TO_ADDR
// if not tmp then
103426: LD_VAR 0 3
103430: NOT
103431: IFFALSE 103435
// exit ;
103433: GO 103491
// un := tmp [ rand ( 1 , tmp ) ] ;
103435: LD_ADDR_VAR 0 2
103439: PUSH
103440: LD_VAR 0 3
103444: PUSH
103445: LD_INT 1
103447: PPUSH
103448: LD_VAR 0 3
103452: PPUSH
103453: CALL_OW 12
103457: ARRAY
103458: ST_TO_ADDR
// if Crawls ( un ) then
103459: LD_VAR 0 2
103463: PPUSH
103464: CALL_OW 318
103468: IFFALSE 103479
// ComWalk ( un ) ;
103470: LD_VAR 0 2
103474: PPUSH
103475: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103479: LD_VAR 0 2
103483: PPUSH
103484: LD_INT 8
103486: PPUSH
103487: CALL_OW 336
// end ;
103491: PPOPN 3
103493: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
103494: LD_EXP 120
103498: PUSH
103499: LD_EXP 164
103503: AND
103504: IFFALSE 103648
103506: GO 103508
103508: DISABLE
103509: LD_INT 0
103511: PPUSH
103512: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
103513: LD_ADDR_VAR 0 2
103517: PUSH
103518: LD_INT 22
103520: PUSH
103521: LD_OWVAR 2
103525: PUSH
103526: EMPTY
103527: LIST
103528: LIST
103529: PUSH
103530: LD_INT 21
103532: PUSH
103533: LD_INT 2
103535: PUSH
103536: EMPTY
103537: LIST
103538: LIST
103539: PUSH
103540: LD_INT 2
103542: PUSH
103543: LD_INT 34
103545: PUSH
103546: LD_INT 12
103548: PUSH
103549: EMPTY
103550: LIST
103551: LIST
103552: PUSH
103553: LD_INT 34
103555: PUSH
103556: LD_INT 51
103558: PUSH
103559: EMPTY
103560: LIST
103561: LIST
103562: PUSH
103563: LD_INT 34
103565: PUSH
103566: LD_INT 32
103568: PUSH
103569: EMPTY
103570: LIST
103571: LIST
103572: PUSH
103573: EMPTY
103574: LIST
103575: LIST
103576: LIST
103577: LIST
103578: PUSH
103579: EMPTY
103580: LIST
103581: LIST
103582: LIST
103583: PPUSH
103584: CALL_OW 69
103588: ST_TO_ADDR
// if not tmp then
103589: LD_VAR 0 2
103593: NOT
103594: IFFALSE 103598
// exit ;
103596: GO 103648
// for i in tmp do
103598: LD_ADDR_VAR 0 1
103602: PUSH
103603: LD_VAR 0 2
103607: PUSH
103608: FOR_IN
103609: IFFALSE 103646
// if GetCargo ( i , mat_artifact ) = 0 then
103611: LD_VAR 0 1
103615: PPUSH
103616: LD_INT 4
103618: PPUSH
103619: CALL_OW 289
103623: PUSH
103624: LD_INT 0
103626: EQUAL
103627: IFFALSE 103644
// SetCargo ( i , mat_siberit , 100 ) ;
103629: LD_VAR 0 1
103633: PPUSH
103634: LD_INT 3
103636: PPUSH
103637: LD_INT 100
103639: PPUSH
103640: CALL_OW 290
103644: GO 103608
103646: POP
103647: POP
// end ;
103648: PPOPN 2
103650: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103651: LD_EXP 120
103655: PUSH
103656: LD_EXP 165
103660: AND
103661: IFFALSE 103844
103663: GO 103665
103665: DISABLE
103666: LD_INT 0
103668: PPUSH
103669: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103670: LD_ADDR_VAR 0 2
103674: PUSH
103675: LD_INT 22
103677: PUSH
103678: LD_OWVAR 2
103682: PUSH
103683: EMPTY
103684: LIST
103685: LIST
103686: PPUSH
103687: CALL_OW 69
103691: ST_TO_ADDR
// if not tmp then
103692: LD_VAR 0 2
103696: NOT
103697: IFFALSE 103701
// exit ;
103699: GO 103844
// for i := 1 to 2 do
103701: LD_ADDR_VAR 0 1
103705: PUSH
103706: DOUBLE
103707: LD_INT 1
103709: DEC
103710: ST_TO_ADDR
103711: LD_INT 2
103713: PUSH
103714: FOR_TO
103715: IFFALSE 103842
// begin uc_side := your_side ;
103717: LD_ADDR_OWVAR 20
103721: PUSH
103722: LD_OWVAR 2
103726: ST_TO_ADDR
// uc_nation := nation_american ;
103727: LD_ADDR_OWVAR 21
103731: PUSH
103732: LD_INT 1
103734: ST_TO_ADDR
// vc_chassis := us_morphling ;
103735: LD_ADDR_OWVAR 37
103739: PUSH
103740: LD_INT 5
103742: ST_TO_ADDR
// vc_engine := engine_siberite ;
103743: LD_ADDR_OWVAR 39
103747: PUSH
103748: LD_INT 3
103750: ST_TO_ADDR
// vc_control := control_computer ;
103751: LD_ADDR_OWVAR 38
103755: PUSH
103756: LD_INT 3
103758: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103759: LD_ADDR_OWVAR 40
103763: PUSH
103764: LD_INT 10
103766: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
103767: LD_VAR 0 2
103771: PUSH
103772: LD_INT 1
103774: ARRAY
103775: PPUSH
103776: CALL_OW 310
103780: NOT
103781: IFFALSE 103828
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
103783: CALL_OW 45
103787: PPUSH
103788: LD_VAR 0 2
103792: PUSH
103793: LD_INT 1
103795: ARRAY
103796: PPUSH
103797: CALL_OW 250
103801: PPUSH
103802: LD_VAR 0 2
103806: PUSH
103807: LD_INT 1
103809: ARRAY
103810: PPUSH
103811: CALL_OW 251
103815: PPUSH
103816: LD_INT 12
103818: PPUSH
103819: LD_INT 1
103821: PPUSH
103822: CALL_OW 50
103826: GO 103840
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
103828: CALL_OW 45
103832: PPUSH
103833: LD_INT 1
103835: PPUSH
103836: CALL_OW 51
// end ;
103840: GO 103714
103842: POP
103843: POP
// end ;
103844: PPOPN 2
103846: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103847: LD_EXP 120
103851: PUSH
103852: LD_EXP 166
103856: AND
103857: IFFALSE 104079
103859: GO 103861
103861: DISABLE
103862: LD_INT 0
103864: PPUSH
103865: PPUSH
103866: PPUSH
103867: PPUSH
103868: PPUSH
103869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103870: LD_ADDR_VAR 0 6
103874: PUSH
103875: LD_INT 22
103877: PUSH
103878: LD_OWVAR 2
103882: PUSH
103883: EMPTY
103884: LIST
103885: LIST
103886: PUSH
103887: LD_INT 21
103889: PUSH
103890: LD_INT 1
103892: PUSH
103893: EMPTY
103894: LIST
103895: LIST
103896: PUSH
103897: LD_INT 3
103899: PUSH
103900: LD_INT 23
103902: PUSH
103903: LD_INT 0
103905: PUSH
103906: EMPTY
103907: LIST
103908: LIST
103909: PUSH
103910: EMPTY
103911: LIST
103912: LIST
103913: PUSH
103914: EMPTY
103915: LIST
103916: LIST
103917: LIST
103918: PPUSH
103919: CALL_OW 69
103923: ST_TO_ADDR
// if not tmp then
103924: LD_VAR 0 6
103928: NOT
103929: IFFALSE 103933
// exit ;
103931: GO 104079
// s1 := rand ( 1 , 4 ) ;
103933: LD_ADDR_VAR 0 2
103937: PUSH
103938: LD_INT 1
103940: PPUSH
103941: LD_INT 4
103943: PPUSH
103944: CALL_OW 12
103948: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103949: LD_ADDR_VAR 0 4
103953: PUSH
103954: LD_VAR 0 6
103958: PUSH
103959: LD_INT 1
103961: ARRAY
103962: PPUSH
103963: LD_VAR 0 2
103967: PPUSH
103968: CALL_OW 259
103972: ST_TO_ADDR
// if s1 = 1 then
103973: LD_VAR 0 2
103977: PUSH
103978: LD_INT 1
103980: EQUAL
103981: IFFALSE 104001
// s2 := rand ( 2 , 4 ) else
103983: LD_ADDR_VAR 0 3
103987: PUSH
103988: LD_INT 2
103990: PPUSH
103991: LD_INT 4
103993: PPUSH
103994: CALL_OW 12
103998: ST_TO_ADDR
103999: GO 104009
// s2 := 1 ;
104001: LD_ADDR_VAR 0 3
104005: PUSH
104006: LD_INT 1
104008: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104009: LD_ADDR_VAR 0 5
104013: PUSH
104014: LD_VAR 0 6
104018: PUSH
104019: LD_INT 1
104021: ARRAY
104022: PPUSH
104023: LD_VAR 0 3
104027: PPUSH
104028: CALL_OW 259
104032: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104033: LD_VAR 0 6
104037: PUSH
104038: LD_INT 1
104040: ARRAY
104041: PPUSH
104042: LD_VAR 0 2
104046: PPUSH
104047: LD_VAR 0 5
104051: PPUSH
104052: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104056: LD_VAR 0 6
104060: PUSH
104061: LD_INT 1
104063: ARRAY
104064: PPUSH
104065: LD_VAR 0 3
104069: PPUSH
104070: LD_VAR 0 4
104074: PPUSH
104075: CALL_OW 237
// end ;
104079: PPOPN 6
104081: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104082: LD_EXP 120
104086: PUSH
104087: LD_EXP 167
104091: AND
104092: IFFALSE 104171
104094: GO 104096
104096: DISABLE
104097: LD_INT 0
104099: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104100: LD_ADDR_VAR 0 1
104104: PUSH
104105: LD_INT 22
104107: PUSH
104108: LD_OWVAR 2
104112: PUSH
104113: EMPTY
104114: LIST
104115: LIST
104116: PUSH
104117: LD_INT 30
104119: PUSH
104120: LD_INT 3
104122: PUSH
104123: EMPTY
104124: LIST
104125: LIST
104126: PUSH
104127: EMPTY
104128: LIST
104129: LIST
104130: PPUSH
104131: CALL_OW 69
104135: ST_TO_ADDR
// if not tmp then
104136: LD_VAR 0 1
104140: NOT
104141: IFFALSE 104145
// exit ;
104143: GO 104171
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104145: LD_VAR 0 1
104149: PUSH
104150: LD_INT 1
104152: PPUSH
104153: LD_VAR 0 1
104157: PPUSH
104158: CALL_OW 12
104162: ARRAY
104163: PPUSH
104164: LD_INT 1
104166: PPUSH
104167: CALL_OW 234
// end ;
104171: PPOPN 1
104173: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104174: LD_EXP 120
104178: PUSH
104179: LD_EXP 168
104183: AND
104184: IFFALSE 104296
104186: GO 104188
104188: DISABLE
104189: LD_INT 0
104191: PPUSH
104192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104193: LD_ADDR_VAR 0 2
104197: PUSH
104198: LD_INT 22
104200: PUSH
104201: LD_OWVAR 2
104205: PUSH
104206: EMPTY
104207: LIST
104208: LIST
104209: PUSH
104210: LD_INT 2
104212: PUSH
104213: LD_INT 30
104215: PUSH
104216: LD_INT 27
104218: PUSH
104219: EMPTY
104220: LIST
104221: LIST
104222: PUSH
104223: LD_INT 30
104225: PUSH
104226: LD_INT 26
104228: PUSH
104229: EMPTY
104230: LIST
104231: LIST
104232: PUSH
104233: LD_INT 30
104235: PUSH
104236: LD_INT 28
104238: PUSH
104239: EMPTY
104240: LIST
104241: LIST
104242: PUSH
104243: EMPTY
104244: LIST
104245: LIST
104246: LIST
104247: LIST
104248: PUSH
104249: EMPTY
104250: LIST
104251: LIST
104252: PPUSH
104253: CALL_OW 69
104257: ST_TO_ADDR
// if not tmp then
104258: LD_VAR 0 2
104262: NOT
104263: IFFALSE 104267
// exit ;
104265: GO 104296
// for i in tmp do
104267: LD_ADDR_VAR 0 1
104271: PUSH
104272: LD_VAR 0 2
104276: PUSH
104277: FOR_IN
104278: IFFALSE 104294
// SetLives ( i , 1 ) ;
104280: LD_VAR 0 1
104284: PPUSH
104285: LD_INT 1
104287: PPUSH
104288: CALL_OW 234
104292: GO 104277
104294: POP
104295: POP
// end ;
104296: PPOPN 2
104298: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
104299: LD_EXP 120
104303: PUSH
104304: LD_EXP 169
104308: AND
104309: IFFALSE 104596
104311: GO 104313
104313: DISABLE
104314: LD_INT 0
104316: PPUSH
104317: PPUSH
104318: PPUSH
// begin i := rand ( 1 , 7 ) ;
104319: LD_ADDR_VAR 0 1
104323: PUSH
104324: LD_INT 1
104326: PPUSH
104327: LD_INT 7
104329: PPUSH
104330: CALL_OW 12
104334: ST_TO_ADDR
// case i of 1 :
104335: LD_VAR 0 1
104339: PUSH
104340: LD_INT 1
104342: DOUBLE
104343: EQUAL
104344: IFTRUE 104348
104346: GO 104358
104348: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
104349: LD_STRING earthquake(getX(game), 0, 32)
104351: PPUSH
104352: CALL_OW 559
104356: GO 104596
104358: LD_INT 2
104360: DOUBLE
104361: EQUAL
104362: IFTRUE 104366
104364: GO 104380
104366: POP
// begin ToLua ( displayStucuk(); ) ;
104367: LD_STRING displayStucuk();
104369: PPUSH
104370: CALL_OW 559
// ResetFog ;
104374: CALL_OW 335
// end ; 3 :
104378: GO 104596
104380: LD_INT 3
104382: DOUBLE
104383: EQUAL
104384: IFTRUE 104388
104386: GO 104492
104388: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104389: LD_ADDR_VAR 0 2
104393: PUSH
104394: LD_INT 22
104396: PUSH
104397: LD_OWVAR 2
104401: PUSH
104402: EMPTY
104403: LIST
104404: LIST
104405: PUSH
104406: LD_INT 25
104408: PUSH
104409: LD_INT 1
104411: PUSH
104412: EMPTY
104413: LIST
104414: LIST
104415: PUSH
104416: EMPTY
104417: LIST
104418: LIST
104419: PPUSH
104420: CALL_OW 69
104424: ST_TO_ADDR
// if not tmp then
104425: LD_VAR 0 2
104429: NOT
104430: IFFALSE 104434
// exit ;
104432: GO 104596
// un := tmp [ rand ( 1 , tmp ) ] ;
104434: LD_ADDR_VAR 0 3
104438: PUSH
104439: LD_VAR 0 2
104443: PUSH
104444: LD_INT 1
104446: PPUSH
104447: LD_VAR 0 2
104451: PPUSH
104452: CALL_OW 12
104456: ARRAY
104457: ST_TO_ADDR
// if Crawls ( un ) then
104458: LD_VAR 0 3
104462: PPUSH
104463: CALL_OW 318
104467: IFFALSE 104478
// ComWalk ( un ) ;
104469: LD_VAR 0 3
104473: PPUSH
104474: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104478: LD_VAR 0 3
104482: PPUSH
104483: LD_INT 8
104485: PPUSH
104486: CALL_OW 336
// end ; 4 :
104490: GO 104596
104492: LD_INT 4
104494: DOUBLE
104495: EQUAL
104496: IFTRUE 104500
104498: GO 104574
104500: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104501: LD_ADDR_VAR 0 2
104505: PUSH
104506: LD_INT 22
104508: PUSH
104509: LD_OWVAR 2
104513: PUSH
104514: EMPTY
104515: LIST
104516: LIST
104517: PUSH
104518: LD_INT 30
104520: PUSH
104521: LD_INT 29
104523: PUSH
104524: EMPTY
104525: LIST
104526: LIST
104527: PUSH
104528: EMPTY
104529: LIST
104530: LIST
104531: PPUSH
104532: CALL_OW 69
104536: ST_TO_ADDR
// if not tmp then
104537: LD_VAR 0 2
104541: NOT
104542: IFFALSE 104546
// exit ;
104544: GO 104596
// CenterNowOnUnits ( tmp [ 1 ] ) ;
104546: LD_VAR 0 2
104550: PUSH
104551: LD_INT 1
104553: ARRAY
104554: PPUSH
104555: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
104559: LD_VAR 0 2
104563: PUSH
104564: LD_INT 1
104566: ARRAY
104567: PPUSH
104568: CALL_OW 65
// end ; 5 .. 7 :
104572: GO 104596
104574: LD_INT 5
104576: DOUBLE
104577: GREATEREQUAL
104578: IFFALSE 104586
104580: LD_INT 7
104582: DOUBLE
104583: LESSEQUAL
104584: IFTRUE 104588
104586: GO 104595
104588: POP
// StreamSibBomb ; end ;
104589: CALL 100833 0 0
104593: GO 104596
104595: POP
// end ;
104596: PPOPN 3
104598: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104599: LD_EXP 120
104603: PUSH
104604: LD_EXP 170
104608: AND
104609: IFFALSE 104765
104611: GO 104613
104613: DISABLE
104614: LD_INT 0
104616: PPUSH
104617: PPUSH
104618: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104619: LD_ADDR_VAR 0 2
104623: PUSH
104624: LD_INT 81
104626: PUSH
104627: LD_OWVAR 2
104631: PUSH
104632: EMPTY
104633: LIST
104634: LIST
104635: PUSH
104636: LD_INT 2
104638: PUSH
104639: LD_INT 21
104641: PUSH
104642: LD_INT 1
104644: PUSH
104645: EMPTY
104646: LIST
104647: LIST
104648: PUSH
104649: LD_INT 21
104651: PUSH
104652: LD_INT 2
104654: PUSH
104655: EMPTY
104656: LIST
104657: LIST
104658: PUSH
104659: EMPTY
104660: LIST
104661: LIST
104662: LIST
104663: PUSH
104664: EMPTY
104665: LIST
104666: LIST
104667: PPUSH
104668: CALL_OW 69
104672: ST_TO_ADDR
// if not tmp then
104673: LD_VAR 0 2
104677: NOT
104678: IFFALSE 104682
// exit ;
104680: GO 104765
// p := 0 ;
104682: LD_ADDR_VAR 0 3
104686: PUSH
104687: LD_INT 0
104689: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104690: LD_INT 35
104692: PPUSH
104693: CALL_OW 67
// p := p + 1 ;
104697: LD_ADDR_VAR 0 3
104701: PUSH
104702: LD_VAR 0 3
104706: PUSH
104707: LD_INT 1
104709: PLUS
104710: ST_TO_ADDR
// for i in tmp do
104711: LD_ADDR_VAR 0 1
104715: PUSH
104716: LD_VAR 0 2
104720: PUSH
104721: FOR_IN
104722: IFFALSE 104753
// if GetLives ( i ) < 1000 then
104724: LD_VAR 0 1
104728: PPUSH
104729: CALL_OW 256
104733: PUSH
104734: LD_INT 1000
104736: LESS
104737: IFFALSE 104751
// SetLives ( i , 1000 ) ;
104739: LD_VAR 0 1
104743: PPUSH
104744: LD_INT 1000
104746: PPUSH
104747: CALL_OW 234
104751: GO 104721
104753: POP
104754: POP
// until p > 20 ;
104755: LD_VAR 0 3
104759: PUSH
104760: LD_INT 20
104762: GREATER
104763: IFFALSE 104690
// end ;
104765: PPOPN 3
104767: END
// every 0 0$1 trigger StreamModeActive and sTime do
104768: LD_EXP 120
104772: PUSH
104773: LD_EXP 171
104777: AND
104778: IFFALSE 104813
104780: GO 104782
104782: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104783: LD_INT 28
104785: PPUSH
104786: LD_OWVAR 2
104790: PPUSH
104791: LD_INT 2
104793: PPUSH
104794: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104798: LD_INT 30
104800: PPUSH
104801: LD_OWVAR 2
104805: PPUSH
104806: LD_INT 2
104808: PPUSH
104809: CALL_OW 322
// end ;
104813: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104814: LD_EXP 120
104818: PUSH
104819: LD_EXP 172
104823: AND
104824: IFFALSE 104945
104826: GO 104828
104828: DISABLE
104829: LD_INT 0
104831: PPUSH
104832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104833: LD_ADDR_VAR 0 2
104837: PUSH
104838: LD_INT 22
104840: PUSH
104841: LD_OWVAR 2
104845: PUSH
104846: EMPTY
104847: LIST
104848: LIST
104849: PUSH
104850: LD_INT 21
104852: PUSH
104853: LD_INT 1
104855: PUSH
104856: EMPTY
104857: LIST
104858: LIST
104859: PUSH
104860: LD_INT 3
104862: PUSH
104863: LD_INT 23
104865: PUSH
104866: LD_INT 0
104868: PUSH
104869: EMPTY
104870: LIST
104871: LIST
104872: PUSH
104873: EMPTY
104874: LIST
104875: LIST
104876: PUSH
104877: EMPTY
104878: LIST
104879: LIST
104880: LIST
104881: PPUSH
104882: CALL_OW 69
104886: ST_TO_ADDR
// if not tmp then
104887: LD_VAR 0 2
104891: NOT
104892: IFFALSE 104896
// exit ;
104894: GO 104945
// for i in tmp do
104896: LD_ADDR_VAR 0 1
104900: PUSH
104901: LD_VAR 0 2
104905: PUSH
104906: FOR_IN
104907: IFFALSE 104943
// begin if Crawls ( i ) then
104909: LD_VAR 0 1
104913: PPUSH
104914: CALL_OW 318
104918: IFFALSE 104929
// ComWalk ( i ) ;
104920: LD_VAR 0 1
104924: PPUSH
104925: CALL_OW 138
// SetClass ( i , 2 ) ;
104929: LD_VAR 0 1
104933: PPUSH
104934: LD_INT 2
104936: PPUSH
104937: CALL_OW 336
// end ;
104941: GO 104906
104943: POP
104944: POP
// end ;
104945: PPOPN 2
104947: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104948: LD_EXP 120
104952: PUSH
104953: LD_EXP 173
104957: AND
104958: IFFALSE 105246
104960: GO 104962
104962: DISABLE
104963: LD_INT 0
104965: PPUSH
104966: PPUSH
104967: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104968: LD_OWVAR 2
104972: PPUSH
104973: LD_INT 9
104975: PPUSH
104976: LD_INT 1
104978: PPUSH
104979: LD_INT 1
104981: PPUSH
104982: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104986: LD_INT 9
104988: PPUSH
104989: LD_OWVAR 2
104993: PPUSH
104994: CALL_OW 343
// uc_side := 9 ;
104998: LD_ADDR_OWVAR 20
105002: PUSH
105003: LD_INT 9
105005: ST_TO_ADDR
// uc_nation := 2 ;
105006: LD_ADDR_OWVAR 21
105010: PUSH
105011: LD_INT 2
105013: ST_TO_ADDR
// hc_name := Dark Warrior ;
105014: LD_ADDR_OWVAR 26
105018: PUSH
105019: LD_STRING Dark Warrior
105021: ST_TO_ADDR
// hc_gallery :=  ;
105022: LD_ADDR_OWVAR 33
105026: PUSH
105027: LD_STRING 
105029: ST_TO_ADDR
// hc_noskilllimit := true ;
105030: LD_ADDR_OWVAR 76
105034: PUSH
105035: LD_INT 1
105037: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105038: LD_ADDR_OWVAR 31
105042: PUSH
105043: LD_INT 30
105045: PUSH
105046: LD_INT 30
105048: PUSH
105049: LD_INT 30
105051: PUSH
105052: LD_INT 30
105054: PUSH
105055: EMPTY
105056: LIST
105057: LIST
105058: LIST
105059: LIST
105060: ST_TO_ADDR
// un := CreateHuman ;
105061: LD_ADDR_VAR 0 3
105065: PUSH
105066: CALL_OW 44
105070: ST_TO_ADDR
// hc_noskilllimit := false ;
105071: LD_ADDR_OWVAR 76
105075: PUSH
105076: LD_INT 0
105078: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105079: LD_VAR 0 3
105083: PPUSH
105084: LD_INT 1
105086: PPUSH
105087: CALL_OW 51
// ToLua ( playRanger() ) ;
105091: LD_STRING playRanger()
105093: PPUSH
105094: CALL_OW 559
// p := 0 ;
105098: LD_ADDR_VAR 0 2
105102: PUSH
105103: LD_INT 0
105105: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105106: LD_INT 35
105108: PPUSH
105109: CALL_OW 67
// p := p + 1 ;
105113: LD_ADDR_VAR 0 2
105117: PUSH
105118: LD_VAR 0 2
105122: PUSH
105123: LD_INT 1
105125: PLUS
105126: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105127: LD_VAR 0 3
105131: PPUSH
105132: CALL_OW 256
105136: PUSH
105137: LD_INT 1000
105139: LESS
105140: IFFALSE 105154
// SetLives ( un , 1000 ) ;
105142: LD_VAR 0 3
105146: PPUSH
105147: LD_INT 1000
105149: PPUSH
105150: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105154: LD_VAR 0 3
105158: PPUSH
105159: LD_INT 81
105161: PUSH
105162: LD_OWVAR 2
105166: PUSH
105167: EMPTY
105168: LIST
105169: LIST
105170: PUSH
105171: LD_INT 91
105173: PUSH
105174: LD_VAR 0 3
105178: PUSH
105179: LD_INT 30
105181: PUSH
105182: EMPTY
105183: LIST
105184: LIST
105185: LIST
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: PPUSH
105191: CALL_OW 69
105195: PPUSH
105196: LD_VAR 0 3
105200: PPUSH
105201: CALL_OW 74
105205: PPUSH
105206: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105210: LD_VAR 0 2
105214: PUSH
105215: LD_INT 80
105217: GREATER
105218: PUSH
105219: LD_VAR 0 3
105223: PPUSH
105224: CALL_OW 301
105228: OR
105229: IFFALSE 105106
// if un then
105231: LD_VAR 0 3
105235: IFFALSE 105246
// RemoveUnit ( un ) ;
105237: LD_VAR 0 3
105241: PPUSH
105242: CALL_OW 64
// end ;
105246: PPOPN 3
105248: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105249: LD_EXP 174
105253: IFFALSE 105369
105255: GO 105257
105257: DISABLE
105258: LD_INT 0
105260: PPUSH
105261: PPUSH
105262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105263: LD_ADDR_VAR 0 2
105267: PUSH
105268: LD_INT 81
105270: PUSH
105271: LD_OWVAR 2
105275: PUSH
105276: EMPTY
105277: LIST
105278: LIST
105279: PUSH
105280: LD_INT 21
105282: PUSH
105283: LD_INT 1
105285: PUSH
105286: EMPTY
105287: LIST
105288: LIST
105289: PUSH
105290: EMPTY
105291: LIST
105292: LIST
105293: PPUSH
105294: CALL_OW 69
105298: ST_TO_ADDR
// ToLua ( playComputer() ) ;
105299: LD_STRING playComputer()
105301: PPUSH
105302: CALL_OW 559
// if not tmp then
105306: LD_VAR 0 2
105310: NOT
105311: IFFALSE 105315
// exit ;
105313: GO 105369
// for i in tmp do
105315: LD_ADDR_VAR 0 1
105319: PUSH
105320: LD_VAR 0 2
105324: PUSH
105325: FOR_IN
105326: IFFALSE 105367
// for j := 1 to 4 do
105328: LD_ADDR_VAR 0 3
105332: PUSH
105333: DOUBLE
105334: LD_INT 1
105336: DEC
105337: ST_TO_ADDR
105338: LD_INT 4
105340: PUSH
105341: FOR_TO
105342: IFFALSE 105363
// SetSkill ( i , j , 10 ) ;
105344: LD_VAR 0 1
105348: PPUSH
105349: LD_VAR 0 3
105353: PPUSH
105354: LD_INT 10
105356: PPUSH
105357: CALL_OW 237
105361: GO 105341
105363: POP
105364: POP
105365: GO 105325
105367: POP
105368: POP
// end ;
105369: PPOPN 3
105371: END
// every 0 0$1 trigger s30 do var i , tmp ;
105372: LD_EXP 175
105376: IFFALSE 105445
105378: GO 105380
105380: DISABLE
105381: LD_INT 0
105383: PPUSH
105384: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105385: LD_ADDR_VAR 0 2
105389: PUSH
105390: LD_INT 22
105392: PUSH
105393: LD_OWVAR 2
105397: PUSH
105398: EMPTY
105399: LIST
105400: LIST
105401: PPUSH
105402: CALL_OW 69
105406: ST_TO_ADDR
// if not tmp then
105407: LD_VAR 0 2
105411: NOT
105412: IFFALSE 105416
// exit ;
105414: GO 105445
// for i in tmp do
105416: LD_ADDR_VAR 0 1
105420: PUSH
105421: LD_VAR 0 2
105425: PUSH
105426: FOR_IN
105427: IFFALSE 105443
// SetLives ( i , 300 ) ;
105429: LD_VAR 0 1
105433: PPUSH
105434: LD_INT 300
105436: PPUSH
105437: CALL_OW 234
105441: GO 105426
105443: POP
105444: POP
// end ;
105445: PPOPN 2
105447: END
// every 0 0$1 trigger s60 do var i , tmp ;
105448: LD_EXP 176
105452: IFFALSE 105521
105454: GO 105456
105456: DISABLE
105457: LD_INT 0
105459: PPUSH
105460: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105461: LD_ADDR_VAR 0 2
105465: PUSH
105466: LD_INT 22
105468: PUSH
105469: LD_OWVAR 2
105473: PUSH
105474: EMPTY
105475: LIST
105476: LIST
105477: PPUSH
105478: CALL_OW 69
105482: ST_TO_ADDR
// if not tmp then
105483: LD_VAR 0 2
105487: NOT
105488: IFFALSE 105492
// exit ;
105490: GO 105521
// for i in tmp do
105492: LD_ADDR_VAR 0 1
105496: PUSH
105497: LD_VAR 0 2
105501: PUSH
105502: FOR_IN
105503: IFFALSE 105519
// SetLives ( i , 600 ) ;
105505: LD_VAR 0 1
105509: PPUSH
105510: LD_INT 600
105512: PPUSH
105513: CALL_OW 234
105517: GO 105502
105519: POP
105520: POP
// end ;
105521: PPOPN 2
105523: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105524: LD_INT 0
105526: PPUSH
// case cmd of 301 :
105527: LD_VAR 0 1
105531: PUSH
105532: LD_INT 301
105534: DOUBLE
105535: EQUAL
105536: IFTRUE 105540
105538: GO 105572
105540: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
105541: LD_VAR 0 6
105545: PPUSH
105546: LD_VAR 0 7
105550: PPUSH
105551: LD_VAR 0 8
105555: PPUSH
105556: LD_VAR 0 4
105560: PPUSH
105561: LD_VAR 0 5
105565: PPUSH
105566: CALL 106773 0 5
105570: GO 105693
105572: LD_INT 302
105574: DOUBLE
105575: EQUAL
105576: IFTRUE 105580
105578: GO 105617
105580: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
105581: LD_VAR 0 6
105585: PPUSH
105586: LD_VAR 0 7
105590: PPUSH
105591: LD_VAR 0 8
105595: PPUSH
105596: LD_VAR 0 9
105600: PPUSH
105601: LD_VAR 0 4
105605: PPUSH
105606: LD_VAR 0 5
105610: PPUSH
105611: CALL 106864 0 6
105615: GO 105693
105617: LD_INT 303
105619: DOUBLE
105620: EQUAL
105621: IFTRUE 105625
105623: GO 105662
105625: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105626: LD_VAR 0 6
105630: PPUSH
105631: LD_VAR 0 7
105635: PPUSH
105636: LD_VAR 0 8
105640: PPUSH
105641: LD_VAR 0 9
105645: PPUSH
105646: LD_VAR 0 4
105650: PPUSH
105651: LD_VAR 0 5
105655: PPUSH
105656: CALL 105698 0 6
105660: GO 105693
105662: LD_INT 304
105664: DOUBLE
105665: EQUAL
105666: IFTRUE 105670
105668: GO 105692
105670: POP
// hHackTeleport ( unit , x , y ) ; end ;
105671: LD_VAR 0 2
105675: PPUSH
105676: LD_VAR 0 4
105680: PPUSH
105681: LD_VAR 0 5
105685: PPUSH
105686: CALL 107457 0 3
105690: GO 105693
105692: POP
// end ;
105693: LD_VAR 0 12
105697: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
105698: LD_INT 0
105700: PPUSH
105701: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
105702: LD_VAR 0 1
105706: PUSH
105707: LD_INT 1
105709: LESS
105710: PUSH
105711: LD_VAR 0 1
105715: PUSH
105716: LD_INT 3
105718: GREATER
105719: OR
105720: PUSH
105721: LD_VAR 0 5
105725: PPUSH
105726: LD_VAR 0 6
105730: PPUSH
105731: CALL_OW 428
105735: OR
105736: IFFALSE 105740
// exit ;
105738: GO 106460
// uc_side := your_side ;
105740: LD_ADDR_OWVAR 20
105744: PUSH
105745: LD_OWVAR 2
105749: ST_TO_ADDR
// uc_nation := nation ;
105750: LD_ADDR_OWVAR 21
105754: PUSH
105755: LD_VAR 0 1
105759: ST_TO_ADDR
// bc_level = 1 ;
105760: LD_ADDR_OWVAR 43
105764: PUSH
105765: LD_INT 1
105767: ST_TO_ADDR
// case btype of 1 :
105768: LD_VAR 0 2
105772: PUSH
105773: LD_INT 1
105775: DOUBLE
105776: EQUAL
105777: IFTRUE 105781
105779: GO 105792
105781: POP
// bc_type := b_depot ; 2 :
105782: LD_ADDR_OWVAR 42
105786: PUSH
105787: LD_INT 0
105789: ST_TO_ADDR
105790: GO 106404
105792: LD_INT 2
105794: DOUBLE
105795: EQUAL
105796: IFTRUE 105800
105798: GO 105811
105800: POP
// bc_type := b_warehouse ; 3 :
105801: LD_ADDR_OWVAR 42
105805: PUSH
105806: LD_INT 1
105808: ST_TO_ADDR
105809: GO 106404
105811: LD_INT 3
105813: DOUBLE
105814: EQUAL
105815: IFTRUE 105819
105817: GO 105830
105819: POP
// bc_type := b_lab ; 4 .. 9 :
105820: LD_ADDR_OWVAR 42
105824: PUSH
105825: LD_INT 6
105827: ST_TO_ADDR
105828: GO 106404
105830: LD_INT 4
105832: DOUBLE
105833: GREATEREQUAL
105834: IFFALSE 105842
105836: LD_INT 9
105838: DOUBLE
105839: LESSEQUAL
105840: IFTRUE 105844
105842: GO 105896
105844: POP
// begin bc_type := b_lab_half ;
105845: LD_ADDR_OWVAR 42
105849: PUSH
105850: LD_INT 7
105852: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
105853: LD_ADDR_OWVAR 44
105857: PUSH
105858: LD_INT 10
105860: PUSH
105861: LD_INT 11
105863: PUSH
105864: LD_INT 12
105866: PUSH
105867: LD_INT 15
105869: PUSH
105870: LD_INT 14
105872: PUSH
105873: LD_INT 13
105875: PUSH
105876: EMPTY
105877: LIST
105878: LIST
105879: LIST
105880: LIST
105881: LIST
105882: LIST
105883: PUSH
105884: LD_VAR 0 2
105888: PUSH
105889: LD_INT 3
105891: MINUS
105892: ARRAY
105893: ST_TO_ADDR
// end ; 10 .. 13 :
105894: GO 106404
105896: LD_INT 10
105898: DOUBLE
105899: GREATEREQUAL
105900: IFFALSE 105908
105902: LD_INT 13
105904: DOUBLE
105905: LESSEQUAL
105906: IFTRUE 105910
105908: GO 105987
105910: POP
// begin bc_type := b_lab_full ;
105911: LD_ADDR_OWVAR 42
105915: PUSH
105916: LD_INT 8
105918: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105919: LD_ADDR_OWVAR 44
105923: PUSH
105924: LD_INT 10
105926: PUSH
105927: LD_INT 12
105929: PUSH
105930: LD_INT 14
105932: PUSH
105933: LD_INT 13
105935: PUSH
105936: EMPTY
105937: LIST
105938: LIST
105939: LIST
105940: LIST
105941: PUSH
105942: LD_VAR 0 2
105946: PUSH
105947: LD_INT 9
105949: MINUS
105950: ARRAY
105951: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105952: LD_ADDR_OWVAR 45
105956: PUSH
105957: LD_INT 11
105959: PUSH
105960: LD_INT 15
105962: PUSH
105963: LD_INT 12
105965: PUSH
105966: LD_INT 15
105968: PUSH
105969: EMPTY
105970: LIST
105971: LIST
105972: LIST
105973: LIST
105974: PUSH
105975: LD_VAR 0 2
105979: PUSH
105980: LD_INT 9
105982: MINUS
105983: ARRAY
105984: ST_TO_ADDR
// end ; 14 :
105985: GO 106404
105987: LD_INT 14
105989: DOUBLE
105990: EQUAL
105991: IFTRUE 105995
105993: GO 106006
105995: POP
// bc_type := b_workshop ; 15 :
105996: LD_ADDR_OWVAR 42
106000: PUSH
106001: LD_INT 2
106003: ST_TO_ADDR
106004: GO 106404
106006: LD_INT 15
106008: DOUBLE
106009: EQUAL
106010: IFTRUE 106014
106012: GO 106025
106014: POP
// bc_type := b_factory ; 16 :
106015: LD_ADDR_OWVAR 42
106019: PUSH
106020: LD_INT 3
106022: ST_TO_ADDR
106023: GO 106404
106025: LD_INT 16
106027: DOUBLE
106028: EQUAL
106029: IFTRUE 106033
106031: GO 106044
106033: POP
// bc_type := b_ext_gun ; 17 :
106034: LD_ADDR_OWVAR 42
106038: PUSH
106039: LD_INT 17
106041: ST_TO_ADDR
106042: GO 106404
106044: LD_INT 17
106046: DOUBLE
106047: EQUAL
106048: IFTRUE 106052
106050: GO 106080
106052: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106053: LD_ADDR_OWVAR 42
106057: PUSH
106058: LD_INT 19
106060: PUSH
106061: LD_INT 23
106063: PUSH
106064: LD_INT 19
106066: PUSH
106067: EMPTY
106068: LIST
106069: LIST
106070: LIST
106071: PUSH
106072: LD_VAR 0 1
106076: ARRAY
106077: ST_TO_ADDR
106078: GO 106404
106080: LD_INT 18
106082: DOUBLE
106083: EQUAL
106084: IFTRUE 106088
106086: GO 106099
106088: POP
// bc_type := b_ext_radar ; 19 :
106089: LD_ADDR_OWVAR 42
106093: PUSH
106094: LD_INT 20
106096: ST_TO_ADDR
106097: GO 106404
106099: LD_INT 19
106101: DOUBLE
106102: EQUAL
106103: IFTRUE 106107
106105: GO 106118
106107: POP
// bc_type := b_ext_radio ; 20 :
106108: LD_ADDR_OWVAR 42
106112: PUSH
106113: LD_INT 22
106115: ST_TO_ADDR
106116: GO 106404
106118: LD_INT 20
106120: DOUBLE
106121: EQUAL
106122: IFTRUE 106126
106124: GO 106137
106126: POP
// bc_type := b_ext_siberium ; 21 :
106127: LD_ADDR_OWVAR 42
106131: PUSH
106132: LD_INT 21
106134: ST_TO_ADDR
106135: GO 106404
106137: LD_INT 21
106139: DOUBLE
106140: EQUAL
106141: IFTRUE 106145
106143: GO 106156
106145: POP
// bc_type := b_ext_computer ; 22 :
106146: LD_ADDR_OWVAR 42
106150: PUSH
106151: LD_INT 24
106153: ST_TO_ADDR
106154: GO 106404
106156: LD_INT 22
106158: DOUBLE
106159: EQUAL
106160: IFTRUE 106164
106162: GO 106175
106164: POP
// bc_type := b_ext_track ; 23 :
106165: LD_ADDR_OWVAR 42
106169: PUSH
106170: LD_INT 16
106172: ST_TO_ADDR
106173: GO 106404
106175: LD_INT 23
106177: DOUBLE
106178: EQUAL
106179: IFTRUE 106183
106181: GO 106194
106183: POP
// bc_type := b_ext_laser ; 24 :
106184: LD_ADDR_OWVAR 42
106188: PUSH
106189: LD_INT 25
106191: ST_TO_ADDR
106192: GO 106404
106194: LD_INT 24
106196: DOUBLE
106197: EQUAL
106198: IFTRUE 106202
106200: GO 106213
106202: POP
// bc_type := b_control_tower ; 25 :
106203: LD_ADDR_OWVAR 42
106207: PUSH
106208: LD_INT 36
106210: ST_TO_ADDR
106211: GO 106404
106213: LD_INT 25
106215: DOUBLE
106216: EQUAL
106217: IFTRUE 106221
106219: GO 106232
106221: POP
// bc_type := b_breastwork ; 26 :
106222: LD_ADDR_OWVAR 42
106226: PUSH
106227: LD_INT 31
106229: ST_TO_ADDR
106230: GO 106404
106232: LD_INT 26
106234: DOUBLE
106235: EQUAL
106236: IFTRUE 106240
106238: GO 106251
106240: POP
// bc_type := b_bunker ; 27 :
106241: LD_ADDR_OWVAR 42
106245: PUSH
106246: LD_INT 32
106248: ST_TO_ADDR
106249: GO 106404
106251: LD_INT 27
106253: DOUBLE
106254: EQUAL
106255: IFTRUE 106259
106257: GO 106270
106259: POP
// bc_type := b_turret ; 28 :
106260: LD_ADDR_OWVAR 42
106264: PUSH
106265: LD_INT 33
106267: ST_TO_ADDR
106268: GO 106404
106270: LD_INT 28
106272: DOUBLE
106273: EQUAL
106274: IFTRUE 106278
106276: GO 106289
106278: POP
// bc_type := b_armoury ; 29 :
106279: LD_ADDR_OWVAR 42
106283: PUSH
106284: LD_INT 4
106286: ST_TO_ADDR
106287: GO 106404
106289: LD_INT 29
106291: DOUBLE
106292: EQUAL
106293: IFTRUE 106297
106295: GO 106308
106297: POP
// bc_type := b_barracks ; 30 :
106298: LD_ADDR_OWVAR 42
106302: PUSH
106303: LD_INT 5
106305: ST_TO_ADDR
106306: GO 106404
106308: LD_INT 30
106310: DOUBLE
106311: EQUAL
106312: IFTRUE 106316
106314: GO 106327
106316: POP
// bc_type := b_solar_power ; 31 :
106317: LD_ADDR_OWVAR 42
106321: PUSH
106322: LD_INT 27
106324: ST_TO_ADDR
106325: GO 106404
106327: LD_INT 31
106329: DOUBLE
106330: EQUAL
106331: IFTRUE 106335
106333: GO 106346
106335: POP
// bc_type := b_oil_power ; 32 :
106336: LD_ADDR_OWVAR 42
106340: PUSH
106341: LD_INT 26
106343: ST_TO_ADDR
106344: GO 106404
106346: LD_INT 32
106348: DOUBLE
106349: EQUAL
106350: IFTRUE 106354
106352: GO 106365
106354: POP
// bc_type := b_siberite_power ; 33 :
106355: LD_ADDR_OWVAR 42
106359: PUSH
106360: LD_INT 28
106362: ST_TO_ADDR
106363: GO 106404
106365: LD_INT 33
106367: DOUBLE
106368: EQUAL
106369: IFTRUE 106373
106371: GO 106384
106373: POP
// bc_type := b_oil_mine ; 34 :
106374: LD_ADDR_OWVAR 42
106378: PUSH
106379: LD_INT 29
106381: ST_TO_ADDR
106382: GO 106404
106384: LD_INT 34
106386: DOUBLE
106387: EQUAL
106388: IFTRUE 106392
106390: GO 106403
106392: POP
// bc_type := b_siberite_mine ; end ;
106393: LD_ADDR_OWVAR 42
106397: PUSH
106398: LD_INT 30
106400: ST_TO_ADDR
106401: GO 106404
106403: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
106404: LD_ADDR_VAR 0 8
106408: PUSH
106409: LD_VAR 0 5
106413: PPUSH
106414: LD_VAR 0 6
106418: PPUSH
106419: LD_VAR 0 3
106423: PPUSH
106424: CALL_OW 47
106428: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
106429: LD_OWVAR 42
106433: PUSH
106434: LD_INT 32
106436: PUSH
106437: LD_INT 33
106439: PUSH
106440: EMPTY
106441: LIST
106442: LIST
106443: IN
106444: IFFALSE 106460
// PlaceWeaponTurret ( b , weapon ) ;
106446: LD_VAR 0 8
106450: PPUSH
106451: LD_VAR 0 4
106455: PPUSH
106456: CALL_OW 431
// end ;
106460: LD_VAR 0 7
106464: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
106465: LD_INT 0
106467: PPUSH
106468: PPUSH
106469: PPUSH
106470: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106471: LD_ADDR_VAR 0 4
106475: PUSH
106476: LD_INT 22
106478: PUSH
106479: LD_OWVAR 2
106483: PUSH
106484: EMPTY
106485: LIST
106486: LIST
106487: PUSH
106488: LD_INT 2
106490: PUSH
106491: LD_INT 30
106493: PUSH
106494: LD_INT 0
106496: PUSH
106497: EMPTY
106498: LIST
106499: LIST
106500: PUSH
106501: LD_INT 30
106503: PUSH
106504: LD_INT 1
106506: PUSH
106507: EMPTY
106508: LIST
106509: LIST
106510: PUSH
106511: EMPTY
106512: LIST
106513: LIST
106514: LIST
106515: PUSH
106516: EMPTY
106517: LIST
106518: LIST
106519: PPUSH
106520: CALL_OW 69
106524: ST_TO_ADDR
// if not tmp then
106525: LD_VAR 0 4
106529: NOT
106530: IFFALSE 106534
// exit ;
106532: GO 106593
// for i in tmp do
106534: LD_ADDR_VAR 0 2
106538: PUSH
106539: LD_VAR 0 4
106543: PUSH
106544: FOR_IN
106545: IFFALSE 106591
// for j = 1 to 3 do
106547: LD_ADDR_VAR 0 3
106551: PUSH
106552: DOUBLE
106553: LD_INT 1
106555: DEC
106556: ST_TO_ADDR
106557: LD_INT 3
106559: PUSH
106560: FOR_TO
106561: IFFALSE 106587
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
106563: LD_VAR 0 2
106567: PPUSH
106568: CALL_OW 274
106572: PPUSH
106573: LD_VAR 0 3
106577: PPUSH
106578: LD_INT 99999
106580: PPUSH
106581: CALL_OW 277
106585: GO 106560
106587: POP
106588: POP
106589: GO 106544
106591: POP
106592: POP
// end ;
106593: LD_VAR 0 1
106597: RET
// export function hHackSetLevel10 ; var i , j ; begin
106598: LD_INT 0
106600: PPUSH
106601: PPUSH
106602: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106603: LD_ADDR_VAR 0 2
106607: PUSH
106608: LD_INT 21
106610: PUSH
106611: LD_INT 1
106613: PUSH
106614: EMPTY
106615: LIST
106616: LIST
106617: PPUSH
106618: CALL_OW 69
106622: PUSH
106623: FOR_IN
106624: IFFALSE 106676
// if IsSelected ( i ) then
106626: LD_VAR 0 2
106630: PPUSH
106631: CALL_OW 306
106635: IFFALSE 106674
// begin for j := 1 to 4 do
106637: LD_ADDR_VAR 0 3
106641: PUSH
106642: DOUBLE
106643: LD_INT 1
106645: DEC
106646: ST_TO_ADDR
106647: LD_INT 4
106649: PUSH
106650: FOR_TO
106651: IFFALSE 106672
// SetSkill ( i , j , 10 ) ;
106653: LD_VAR 0 2
106657: PPUSH
106658: LD_VAR 0 3
106662: PPUSH
106663: LD_INT 10
106665: PPUSH
106666: CALL_OW 237
106670: GO 106650
106672: POP
106673: POP
// end ;
106674: GO 106623
106676: POP
106677: POP
// end ;
106678: LD_VAR 0 1
106682: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
106683: LD_INT 0
106685: PPUSH
106686: PPUSH
106687: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
106688: LD_ADDR_VAR 0 2
106692: PUSH
106693: LD_INT 22
106695: PUSH
106696: LD_OWVAR 2
106700: PUSH
106701: EMPTY
106702: LIST
106703: LIST
106704: PUSH
106705: LD_INT 21
106707: PUSH
106708: LD_INT 1
106710: PUSH
106711: EMPTY
106712: LIST
106713: LIST
106714: PUSH
106715: EMPTY
106716: LIST
106717: LIST
106718: PPUSH
106719: CALL_OW 69
106723: PUSH
106724: FOR_IN
106725: IFFALSE 106766
// begin for j := 1 to 4 do
106727: LD_ADDR_VAR 0 3
106731: PUSH
106732: DOUBLE
106733: LD_INT 1
106735: DEC
106736: ST_TO_ADDR
106737: LD_INT 4
106739: PUSH
106740: FOR_TO
106741: IFFALSE 106762
// SetSkill ( i , j , 10 ) ;
106743: LD_VAR 0 2
106747: PPUSH
106748: LD_VAR 0 3
106752: PPUSH
106753: LD_INT 10
106755: PPUSH
106756: CALL_OW 237
106760: GO 106740
106762: POP
106763: POP
// end ;
106764: GO 106724
106766: POP
106767: POP
// end ;
106768: LD_VAR 0 1
106772: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
106773: LD_INT 0
106775: PPUSH
// uc_side := your_side ;
106776: LD_ADDR_OWVAR 20
106780: PUSH
106781: LD_OWVAR 2
106785: ST_TO_ADDR
// uc_nation := nation ;
106786: LD_ADDR_OWVAR 21
106790: PUSH
106791: LD_VAR 0 1
106795: ST_TO_ADDR
// InitHc ;
106796: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
106800: LD_INT 0
106802: PPUSH
106803: LD_VAR 0 2
106807: PPUSH
106808: LD_VAR 0 3
106812: PPUSH
106813: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
106817: LD_VAR 0 4
106821: PPUSH
106822: LD_VAR 0 5
106826: PPUSH
106827: CALL_OW 428
106831: PUSH
106832: LD_INT 0
106834: EQUAL
106835: IFFALSE 106859
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
106837: CALL_OW 44
106841: PPUSH
106842: LD_VAR 0 4
106846: PPUSH
106847: LD_VAR 0 5
106851: PPUSH
106852: LD_INT 1
106854: PPUSH
106855: CALL_OW 48
// end ;
106859: LD_VAR 0 6
106863: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
106864: LD_INT 0
106866: PPUSH
106867: PPUSH
// uc_side := your_side ;
106868: LD_ADDR_OWVAR 20
106872: PUSH
106873: LD_OWVAR 2
106877: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106878: LD_VAR 0 1
106882: PUSH
106883: LD_INT 1
106885: PUSH
106886: LD_INT 2
106888: PUSH
106889: LD_INT 3
106891: PUSH
106892: LD_INT 4
106894: PUSH
106895: LD_INT 5
106897: PUSH
106898: EMPTY
106899: LIST
106900: LIST
106901: LIST
106902: LIST
106903: LIST
106904: IN
106905: IFFALSE 106917
// uc_nation := nation_american else
106907: LD_ADDR_OWVAR 21
106911: PUSH
106912: LD_INT 1
106914: ST_TO_ADDR
106915: GO 106960
// if chassis in [ 11 , 12 , 13 , 14 ] then
106917: LD_VAR 0 1
106921: PUSH
106922: LD_INT 11
106924: PUSH
106925: LD_INT 12
106927: PUSH
106928: LD_INT 13
106930: PUSH
106931: LD_INT 14
106933: PUSH
106934: EMPTY
106935: LIST
106936: LIST
106937: LIST
106938: LIST
106939: IN
106940: IFFALSE 106952
// uc_nation := nation_arabian else
106942: LD_ADDR_OWVAR 21
106946: PUSH
106947: LD_INT 2
106949: ST_TO_ADDR
106950: GO 106960
// uc_nation := nation_russian ;
106952: LD_ADDR_OWVAR 21
106956: PUSH
106957: LD_INT 3
106959: ST_TO_ADDR
// vc_chassis := chassis ;
106960: LD_ADDR_OWVAR 37
106964: PUSH
106965: LD_VAR 0 1
106969: ST_TO_ADDR
// vc_engine := engine ;
106970: LD_ADDR_OWVAR 39
106974: PUSH
106975: LD_VAR 0 2
106979: ST_TO_ADDR
// vc_control := control ;
106980: LD_ADDR_OWVAR 38
106984: PUSH
106985: LD_VAR 0 3
106989: ST_TO_ADDR
// vc_weapon := weapon ;
106990: LD_ADDR_OWVAR 40
106994: PUSH
106995: LD_VAR 0 4
106999: ST_TO_ADDR
// un := CreateVehicle ;
107000: LD_ADDR_VAR 0 8
107004: PUSH
107005: CALL_OW 45
107009: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107010: LD_VAR 0 8
107014: PPUSH
107015: LD_INT 0
107017: PPUSH
107018: LD_INT 5
107020: PPUSH
107021: CALL_OW 12
107025: PPUSH
107026: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107030: LD_VAR 0 8
107034: PPUSH
107035: LD_VAR 0 5
107039: PPUSH
107040: LD_VAR 0 6
107044: PPUSH
107045: LD_INT 1
107047: PPUSH
107048: CALL_OW 48
// end ;
107052: LD_VAR 0 7
107056: RET
// export hInvincible ; every 1 do
107057: GO 107059
107059: DISABLE
// hInvincible := [ ] ;
107060: LD_ADDR_EXP 177
107064: PUSH
107065: EMPTY
107066: ST_TO_ADDR
107067: END
// every 10 do var i ;
107068: GO 107070
107070: DISABLE
107071: LD_INT 0
107073: PPUSH
// begin enable ;
107074: ENABLE
// if not hInvincible then
107075: LD_EXP 177
107079: NOT
107080: IFFALSE 107084
// exit ;
107082: GO 107128
// for i in hInvincible do
107084: LD_ADDR_VAR 0 1
107088: PUSH
107089: LD_EXP 177
107093: PUSH
107094: FOR_IN
107095: IFFALSE 107126
// if GetLives ( i ) < 1000 then
107097: LD_VAR 0 1
107101: PPUSH
107102: CALL_OW 256
107106: PUSH
107107: LD_INT 1000
107109: LESS
107110: IFFALSE 107124
// SetLives ( i , 1000 ) ;
107112: LD_VAR 0 1
107116: PPUSH
107117: LD_INT 1000
107119: PPUSH
107120: CALL_OW 234
107124: GO 107094
107126: POP
107127: POP
// end ;
107128: PPOPN 1
107130: END
// export function hHackInvincible ; var i ; begin
107131: LD_INT 0
107133: PPUSH
107134: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107135: LD_ADDR_VAR 0 2
107139: PUSH
107140: LD_INT 2
107142: PUSH
107143: LD_INT 21
107145: PUSH
107146: LD_INT 1
107148: PUSH
107149: EMPTY
107150: LIST
107151: LIST
107152: PUSH
107153: LD_INT 21
107155: PUSH
107156: LD_INT 2
107158: PUSH
107159: EMPTY
107160: LIST
107161: LIST
107162: PUSH
107163: EMPTY
107164: LIST
107165: LIST
107166: LIST
107167: PPUSH
107168: CALL_OW 69
107172: PUSH
107173: FOR_IN
107174: IFFALSE 107235
// if IsSelected ( i ) then
107176: LD_VAR 0 2
107180: PPUSH
107181: CALL_OW 306
107185: IFFALSE 107233
// begin if i in hInvincible then
107187: LD_VAR 0 2
107191: PUSH
107192: LD_EXP 177
107196: IN
107197: IFFALSE 107217
// hInvincible := hInvincible diff i else
107199: LD_ADDR_EXP 177
107203: PUSH
107204: LD_EXP 177
107208: PUSH
107209: LD_VAR 0 2
107213: DIFF
107214: ST_TO_ADDR
107215: GO 107233
// hInvincible := hInvincible union i ;
107217: LD_ADDR_EXP 177
107221: PUSH
107222: LD_EXP 177
107226: PUSH
107227: LD_VAR 0 2
107231: UNION
107232: ST_TO_ADDR
// end ;
107233: GO 107173
107235: POP
107236: POP
// end ;
107237: LD_VAR 0 1
107241: RET
// export function hHackInvisible ; var i , j ; begin
107242: LD_INT 0
107244: PPUSH
107245: PPUSH
107246: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107247: LD_ADDR_VAR 0 2
107251: PUSH
107252: LD_INT 21
107254: PUSH
107255: LD_INT 1
107257: PUSH
107258: EMPTY
107259: LIST
107260: LIST
107261: PPUSH
107262: CALL_OW 69
107266: PUSH
107267: FOR_IN
107268: IFFALSE 107292
// if IsSelected ( i ) then
107270: LD_VAR 0 2
107274: PPUSH
107275: CALL_OW 306
107279: IFFALSE 107290
// ComForceInvisible ( i ) ;
107281: LD_VAR 0 2
107285: PPUSH
107286: CALL_OW 496
107290: GO 107267
107292: POP
107293: POP
// end ;
107294: LD_VAR 0 1
107298: RET
// export function hHackChangeYourSide ; begin
107299: LD_INT 0
107301: PPUSH
// if your_side = 8 then
107302: LD_OWVAR 2
107306: PUSH
107307: LD_INT 8
107309: EQUAL
107310: IFFALSE 107322
// your_side := 0 else
107312: LD_ADDR_OWVAR 2
107316: PUSH
107317: LD_INT 0
107319: ST_TO_ADDR
107320: GO 107336
// your_side := your_side + 1 ;
107322: LD_ADDR_OWVAR 2
107326: PUSH
107327: LD_OWVAR 2
107331: PUSH
107332: LD_INT 1
107334: PLUS
107335: ST_TO_ADDR
// end ;
107336: LD_VAR 0 1
107340: RET
// export function hHackChangeUnitSide ; var i , j ; begin
107341: LD_INT 0
107343: PPUSH
107344: PPUSH
107345: PPUSH
// for i in all_units do
107346: LD_ADDR_VAR 0 2
107350: PUSH
107351: LD_OWVAR 3
107355: PUSH
107356: FOR_IN
107357: IFFALSE 107435
// if IsSelected ( i ) then
107359: LD_VAR 0 2
107363: PPUSH
107364: CALL_OW 306
107368: IFFALSE 107433
// begin j := GetSide ( i ) ;
107370: LD_ADDR_VAR 0 3
107374: PUSH
107375: LD_VAR 0 2
107379: PPUSH
107380: CALL_OW 255
107384: ST_TO_ADDR
// if j = 8 then
107385: LD_VAR 0 3
107389: PUSH
107390: LD_INT 8
107392: EQUAL
107393: IFFALSE 107405
// j := 0 else
107395: LD_ADDR_VAR 0 3
107399: PUSH
107400: LD_INT 0
107402: ST_TO_ADDR
107403: GO 107419
// j := j + 1 ;
107405: LD_ADDR_VAR 0 3
107409: PUSH
107410: LD_VAR 0 3
107414: PUSH
107415: LD_INT 1
107417: PLUS
107418: ST_TO_ADDR
// SetSide ( i , j ) ;
107419: LD_VAR 0 2
107423: PPUSH
107424: LD_VAR 0 3
107428: PPUSH
107429: CALL_OW 235
// end ;
107433: GO 107356
107435: POP
107436: POP
// end ;
107437: LD_VAR 0 1
107441: RET
// export function hHackFog ; begin
107442: LD_INT 0
107444: PPUSH
// FogOff ( true ) ;
107445: LD_INT 1
107447: PPUSH
107448: CALL_OW 344
// end ;
107452: LD_VAR 0 1
107456: RET
// export function hHackTeleport ( unit , x , y ) ; begin
107457: LD_INT 0
107459: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
107460: LD_VAR 0 1
107464: PPUSH
107465: LD_VAR 0 2
107469: PPUSH
107470: LD_VAR 0 3
107474: PPUSH
107475: LD_INT 1
107477: PPUSH
107478: LD_INT 1
107480: PPUSH
107481: CALL_OW 483
// CenterOnXY ( x , y ) ;
107485: LD_VAR 0 2
107489: PPUSH
107490: LD_VAR 0 3
107494: PPUSH
107495: CALL_OW 84
// end ;
107499: LD_VAR 0 4
107503: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107504: LD_INT 0
107506: PPUSH
107507: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107508: LD_VAR 0 1
107512: NOT
107513: PUSH
107514: LD_VAR 0 2
107518: PPUSH
107519: LD_VAR 0 3
107523: PPUSH
107524: CALL_OW 488
107528: NOT
107529: OR
107530: PUSH
107531: LD_VAR 0 1
107535: PPUSH
107536: CALL_OW 266
107540: PUSH
107541: LD_INT 3
107543: NONEQUAL
107544: PUSH
107545: LD_VAR 0 1
107549: PPUSH
107550: CALL_OW 247
107554: PUSH
107555: LD_INT 1
107557: EQUAL
107558: NOT
107559: AND
107560: OR
107561: IFFALSE 107565
// exit ;
107563: GO 107714
// if GetType ( factory ) = unit_human then
107565: LD_VAR 0 1
107569: PPUSH
107570: CALL_OW 247
107574: PUSH
107575: LD_INT 1
107577: EQUAL
107578: IFFALSE 107595
// factory := IsInUnit ( factory ) ;
107580: LD_ADDR_VAR 0 1
107584: PUSH
107585: LD_VAR 0 1
107589: PPUSH
107590: CALL_OW 310
107594: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107595: LD_VAR 0 1
107599: PPUSH
107600: CALL_OW 266
107604: PUSH
107605: LD_INT 3
107607: NONEQUAL
107608: IFFALSE 107612
// exit ;
107610: GO 107714
// if HexInfo ( x , y ) = factory then
107612: LD_VAR 0 2
107616: PPUSH
107617: LD_VAR 0 3
107621: PPUSH
107622: CALL_OW 428
107626: PUSH
107627: LD_VAR 0 1
107631: EQUAL
107632: IFFALSE 107659
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107634: LD_ADDR_EXP 178
107638: PUSH
107639: LD_EXP 178
107643: PPUSH
107644: LD_VAR 0 1
107648: PPUSH
107649: LD_INT 0
107651: PPUSH
107652: CALL_OW 1
107656: ST_TO_ADDR
107657: GO 107710
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107659: LD_ADDR_EXP 178
107663: PUSH
107664: LD_EXP 178
107668: PPUSH
107669: LD_VAR 0 1
107673: PPUSH
107674: LD_VAR 0 1
107678: PPUSH
107679: CALL_OW 255
107683: PUSH
107684: LD_VAR 0 1
107688: PUSH
107689: LD_VAR 0 2
107693: PUSH
107694: LD_VAR 0 3
107698: PUSH
107699: EMPTY
107700: LIST
107701: LIST
107702: LIST
107703: LIST
107704: PPUSH
107705: CALL_OW 1
107709: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107710: CALL 107719 0 0
// end ;
107714: LD_VAR 0 4
107718: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
107719: LD_INT 0
107721: PPUSH
107722: PPUSH
107723: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107724: LD_STRING resetFactoryWaypoint();
107726: PPUSH
107727: CALL_OW 559
// if factoryWaypoints then
107731: LD_EXP 178
107735: IFFALSE 107861
// begin list := PrepareArray ( factoryWaypoints ) ;
107737: LD_ADDR_VAR 0 3
107741: PUSH
107742: LD_EXP 178
107746: PPUSH
107747: CALL 93115 0 1
107751: ST_TO_ADDR
// for i := 1 to list do
107752: LD_ADDR_VAR 0 2
107756: PUSH
107757: DOUBLE
107758: LD_INT 1
107760: DEC
107761: ST_TO_ADDR
107762: LD_VAR 0 3
107766: PUSH
107767: FOR_TO
107768: IFFALSE 107859
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107770: LD_STRING setFactoryWaypointXY(
107772: PUSH
107773: LD_VAR 0 3
107777: PUSH
107778: LD_VAR 0 2
107782: ARRAY
107783: PUSH
107784: LD_INT 1
107786: ARRAY
107787: STR
107788: PUSH
107789: LD_STRING ,
107791: STR
107792: PUSH
107793: LD_VAR 0 3
107797: PUSH
107798: LD_VAR 0 2
107802: ARRAY
107803: PUSH
107804: LD_INT 2
107806: ARRAY
107807: STR
107808: PUSH
107809: LD_STRING ,
107811: STR
107812: PUSH
107813: LD_VAR 0 3
107817: PUSH
107818: LD_VAR 0 2
107822: ARRAY
107823: PUSH
107824: LD_INT 3
107826: ARRAY
107827: STR
107828: PUSH
107829: LD_STRING ,
107831: STR
107832: PUSH
107833: LD_VAR 0 3
107837: PUSH
107838: LD_VAR 0 2
107842: ARRAY
107843: PUSH
107844: LD_INT 4
107846: ARRAY
107847: STR
107848: PUSH
107849: LD_STRING )
107851: STR
107852: PPUSH
107853: CALL_OW 559
107857: GO 107767
107859: POP
107860: POP
// end ; end ;
107861: LD_VAR 0 1
107865: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
107866: LD_INT 0
107868: PPUSH
// if HexInfo ( x , y ) = warehouse then
107869: LD_VAR 0 2
107873: PPUSH
107874: LD_VAR 0 3
107878: PPUSH
107879: CALL_OW 428
107883: PUSH
107884: LD_VAR 0 1
107888: EQUAL
107889: IFFALSE 107916
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107891: LD_ADDR_EXP 179
107895: PUSH
107896: LD_EXP 179
107900: PPUSH
107901: LD_VAR 0 1
107905: PPUSH
107906: LD_INT 0
107908: PPUSH
107909: CALL_OW 1
107913: ST_TO_ADDR
107914: GO 107967
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
107916: LD_ADDR_EXP 179
107920: PUSH
107921: LD_EXP 179
107925: PPUSH
107926: LD_VAR 0 1
107930: PPUSH
107931: LD_VAR 0 1
107935: PPUSH
107936: CALL_OW 255
107940: PUSH
107941: LD_VAR 0 1
107945: PUSH
107946: LD_VAR 0 2
107950: PUSH
107951: LD_VAR 0 3
107955: PUSH
107956: EMPTY
107957: LIST
107958: LIST
107959: LIST
107960: LIST
107961: PPUSH
107962: CALL_OW 1
107966: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
107967: CALL 107976 0 0
// end ;
107971: LD_VAR 0 4
107975: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
107976: LD_INT 0
107978: PPUSH
107979: PPUSH
107980: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
107981: LD_STRING resetWarehouseGatheringPoints();
107983: PPUSH
107984: CALL_OW 559
// if warehouseGatheringPoints then
107988: LD_EXP 179
107992: IFFALSE 108118
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
107994: LD_ADDR_VAR 0 3
107998: PUSH
107999: LD_EXP 179
108003: PPUSH
108004: CALL 93115 0 1
108008: ST_TO_ADDR
// for i := 1 to list do
108009: LD_ADDR_VAR 0 2
108013: PUSH
108014: DOUBLE
108015: LD_INT 1
108017: DEC
108018: ST_TO_ADDR
108019: LD_VAR 0 3
108023: PUSH
108024: FOR_TO
108025: IFFALSE 108116
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108027: LD_STRING setWarehouseGatheringPointXY(
108029: PUSH
108030: LD_VAR 0 3
108034: PUSH
108035: LD_VAR 0 2
108039: ARRAY
108040: PUSH
108041: LD_INT 1
108043: ARRAY
108044: STR
108045: PUSH
108046: LD_STRING ,
108048: STR
108049: PUSH
108050: LD_VAR 0 3
108054: PUSH
108055: LD_VAR 0 2
108059: ARRAY
108060: PUSH
108061: LD_INT 2
108063: ARRAY
108064: STR
108065: PUSH
108066: LD_STRING ,
108068: STR
108069: PUSH
108070: LD_VAR 0 3
108074: PUSH
108075: LD_VAR 0 2
108079: ARRAY
108080: PUSH
108081: LD_INT 3
108083: ARRAY
108084: STR
108085: PUSH
108086: LD_STRING ,
108088: STR
108089: PUSH
108090: LD_VAR 0 3
108094: PUSH
108095: LD_VAR 0 2
108099: ARRAY
108100: PUSH
108101: LD_INT 4
108103: ARRAY
108104: STR
108105: PUSH
108106: LD_STRING )
108108: STR
108109: PPUSH
108110: CALL_OW 559
108114: GO 108024
108116: POP
108117: POP
// end ; end ;
108118: LD_VAR 0 1
108122: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108123: LD_EXP 179
108127: IFFALSE 108812
108129: GO 108131
108131: DISABLE
108132: LD_INT 0
108134: PPUSH
108135: PPUSH
108136: PPUSH
108137: PPUSH
108138: PPUSH
108139: PPUSH
108140: PPUSH
108141: PPUSH
108142: PPUSH
// begin enable ;
108143: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108144: LD_ADDR_VAR 0 3
108148: PUSH
108149: LD_EXP 179
108153: PPUSH
108154: CALL 93115 0 1
108158: ST_TO_ADDR
// if not list then
108159: LD_VAR 0 3
108163: NOT
108164: IFFALSE 108168
// exit ;
108166: GO 108812
// for i := 1 to list do
108168: LD_ADDR_VAR 0 1
108172: PUSH
108173: DOUBLE
108174: LD_INT 1
108176: DEC
108177: ST_TO_ADDR
108178: LD_VAR 0 3
108182: PUSH
108183: FOR_TO
108184: IFFALSE 108810
// begin depot := list [ i ] [ 2 ] ;
108186: LD_ADDR_VAR 0 8
108190: PUSH
108191: LD_VAR 0 3
108195: PUSH
108196: LD_VAR 0 1
108200: ARRAY
108201: PUSH
108202: LD_INT 2
108204: ARRAY
108205: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108206: LD_ADDR_VAR 0 5
108210: PUSH
108211: LD_VAR 0 3
108215: PUSH
108216: LD_VAR 0 1
108220: ARRAY
108221: PUSH
108222: LD_INT 1
108224: ARRAY
108225: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108226: LD_VAR 0 8
108230: PPUSH
108231: CALL_OW 301
108235: PUSH
108236: LD_VAR 0 5
108240: PUSH
108241: LD_VAR 0 8
108245: PPUSH
108246: CALL_OW 255
108250: NONEQUAL
108251: OR
108252: IFFALSE 108281
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108254: LD_ADDR_EXP 179
108258: PUSH
108259: LD_EXP 179
108263: PPUSH
108264: LD_VAR 0 8
108268: PPUSH
108269: LD_INT 0
108271: PPUSH
108272: CALL_OW 1
108276: ST_TO_ADDR
// exit ;
108277: POP
108278: POP
108279: GO 108812
// end ; x := list [ i ] [ 3 ] ;
108281: LD_ADDR_VAR 0 6
108285: PUSH
108286: LD_VAR 0 3
108290: PUSH
108291: LD_VAR 0 1
108295: ARRAY
108296: PUSH
108297: LD_INT 3
108299: ARRAY
108300: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
108301: LD_ADDR_VAR 0 7
108305: PUSH
108306: LD_VAR 0 3
108310: PUSH
108311: LD_VAR 0 1
108315: ARRAY
108316: PUSH
108317: LD_INT 4
108319: ARRAY
108320: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
108321: LD_ADDR_VAR 0 9
108325: PUSH
108326: LD_VAR 0 6
108330: PPUSH
108331: LD_VAR 0 7
108335: PPUSH
108336: LD_INT 16
108338: PPUSH
108339: CALL 91703 0 3
108343: ST_TO_ADDR
// if not cratesNearbyPoint then
108344: LD_VAR 0 9
108348: NOT
108349: IFFALSE 108355
// exit ;
108351: POP
108352: POP
108353: GO 108812
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
108355: LD_ADDR_VAR 0 4
108359: PUSH
108360: LD_INT 22
108362: PUSH
108363: LD_VAR 0 5
108367: PUSH
108368: EMPTY
108369: LIST
108370: LIST
108371: PUSH
108372: LD_INT 3
108374: PUSH
108375: LD_INT 60
108377: PUSH
108378: EMPTY
108379: LIST
108380: PUSH
108381: EMPTY
108382: LIST
108383: LIST
108384: PUSH
108385: LD_INT 91
108387: PUSH
108388: LD_VAR 0 8
108392: PUSH
108393: LD_INT 6
108395: PUSH
108396: EMPTY
108397: LIST
108398: LIST
108399: LIST
108400: PUSH
108401: LD_INT 2
108403: PUSH
108404: LD_INT 25
108406: PUSH
108407: LD_INT 2
108409: PUSH
108410: EMPTY
108411: LIST
108412: LIST
108413: PUSH
108414: LD_INT 25
108416: PUSH
108417: LD_INT 16
108419: PUSH
108420: EMPTY
108421: LIST
108422: LIST
108423: PUSH
108424: EMPTY
108425: LIST
108426: LIST
108427: LIST
108428: PUSH
108429: EMPTY
108430: LIST
108431: LIST
108432: LIST
108433: LIST
108434: PPUSH
108435: CALL_OW 69
108439: PUSH
108440: LD_VAR 0 8
108444: PPUSH
108445: CALL_OW 313
108449: PPUSH
108450: LD_INT 3
108452: PUSH
108453: LD_INT 60
108455: PUSH
108456: EMPTY
108457: LIST
108458: PUSH
108459: EMPTY
108460: LIST
108461: LIST
108462: PUSH
108463: LD_INT 2
108465: PUSH
108466: LD_INT 25
108468: PUSH
108469: LD_INT 2
108471: PUSH
108472: EMPTY
108473: LIST
108474: LIST
108475: PUSH
108476: LD_INT 25
108478: PUSH
108479: LD_INT 16
108481: PUSH
108482: EMPTY
108483: LIST
108484: LIST
108485: PUSH
108486: EMPTY
108487: LIST
108488: LIST
108489: LIST
108490: PUSH
108491: EMPTY
108492: LIST
108493: LIST
108494: PPUSH
108495: CALL_OW 72
108499: UNION
108500: ST_TO_ADDR
// if tmp then
108501: LD_VAR 0 4
108505: IFFALSE 108585
// begin tmp := ShrinkArray ( tmp , 3 ) ;
108507: LD_ADDR_VAR 0 4
108511: PUSH
108512: LD_VAR 0 4
108516: PPUSH
108517: LD_INT 3
108519: PPUSH
108520: CALL 89672 0 2
108524: ST_TO_ADDR
// for j in tmp do
108525: LD_ADDR_VAR 0 2
108529: PUSH
108530: LD_VAR 0 4
108534: PUSH
108535: FOR_IN
108536: IFFALSE 108579
// begin if IsInUnit ( j ) then
108538: LD_VAR 0 2
108542: PPUSH
108543: CALL_OW 310
108547: IFFALSE 108558
// ComExit ( j ) ;
108549: LD_VAR 0 2
108553: PPUSH
108554: CALL 89755 0 1
// AddComCollect ( j , x , y ) ;
108558: LD_VAR 0 2
108562: PPUSH
108563: LD_VAR 0 6
108567: PPUSH
108568: LD_VAR 0 7
108572: PPUSH
108573: CALL_OW 177
// end ;
108577: GO 108535
108579: POP
108580: POP
// exit ;
108581: POP
108582: POP
108583: GO 108812
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
108585: LD_ADDR_VAR 0 4
108589: PUSH
108590: LD_INT 22
108592: PUSH
108593: LD_VAR 0 5
108597: PUSH
108598: EMPTY
108599: LIST
108600: LIST
108601: PUSH
108602: LD_INT 91
108604: PUSH
108605: LD_VAR 0 8
108609: PUSH
108610: LD_INT 8
108612: PUSH
108613: EMPTY
108614: LIST
108615: LIST
108616: LIST
108617: PUSH
108618: LD_INT 2
108620: PUSH
108621: LD_INT 34
108623: PUSH
108624: LD_INT 12
108626: PUSH
108627: EMPTY
108628: LIST
108629: LIST
108630: PUSH
108631: LD_INT 34
108633: PUSH
108634: LD_INT 51
108636: PUSH
108637: EMPTY
108638: LIST
108639: LIST
108640: PUSH
108641: LD_INT 34
108643: PUSH
108644: LD_INT 32
108646: PUSH
108647: EMPTY
108648: LIST
108649: LIST
108650: PUSH
108651: LD_INT 34
108653: PUSH
108654: LD_INT 89
108656: PUSH
108657: EMPTY
108658: LIST
108659: LIST
108660: PUSH
108661: EMPTY
108662: LIST
108663: LIST
108664: LIST
108665: LIST
108666: LIST
108667: PUSH
108668: EMPTY
108669: LIST
108670: LIST
108671: LIST
108672: PPUSH
108673: CALL_OW 69
108677: ST_TO_ADDR
// if tmp then
108678: LD_VAR 0 4
108682: IFFALSE 108808
// begin for j in tmp do
108684: LD_ADDR_VAR 0 2
108688: PUSH
108689: LD_VAR 0 4
108693: PUSH
108694: FOR_IN
108695: IFFALSE 108806
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
108697: LD_VAR 0 2
108701: PPUSH
108702: CALL_OW 262
108706: PUSH
108707: LD_INT 3
108709: EQUAL
108710: PUSH
108711: LD_VAR 0 2
108715: PPUSH
108716: CALL_OW 261
108720: PUSH
108721: LD_INT 20
108723: GREATER
108724: OR
108725: PUSH
108726: LD_VAR 0 2
108730: PPUSH
108731: CALL_OW 314
108735: NOT
108736: AND
108737: PUSH
108738: LD_VAR 0 2
108742: PPUSH
108743: CALL_OW 263
108747: PUSH
108748: LD_INT 1
108750: NONEQUAL
108751: PUSH
108752: LD_VAR 0 2
108756: PPUSH
108757: CALL_OW 311
108761: OR
108762: AND
108763: IFFALSE 108804
// begin ComCollect ( j , x , y ) ;
108765: LD_VAR 0 2
108769: PPUSH
108770: LD_VAR 0 6
108774: PPUSH
108775: LD_VAR 0 7
108779: PPUSH
108780: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
108784: LD_VAR 0 2
108788: PPUSH
108789: LD_VAR 0 8
108793: PPUSH
108794: CALL_OW 172
// exit ;
108798: POP
108799: POP
108800: POP
108801: POP
108802: GO 108812
// end ;
108804: GO 108694
108806: POP
108807: POP
// end ; end ;
108808: GO 108183
108810: POP
108811: POP
// end ; end_of_file
108812: PPOPN 9
108814: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
108815: LD_INT 0
108817: PPUSH
108818: PPUSH
108819: PPUSH
108820: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
108821: LD_VAR 0 1
108825: PPUSH
108826: CALL_OW 264
108830: PUSH
108831: LD_INT 91
108833: EQUAL
108834: IFFALSE 108906
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
108836: LD_INT 68
108838: PPUSH
108839: LD_VAR 0 1
108843: PPUSH
108844: CALL_OW 255
108848: PPUSH
108849: CALL_OW 321
108853: PUSH
108854: LD_INT 2
108856: EQUAL
108857: IFFALSE 108869
// eff := 70 else
108859: LD_ADDR_VAR 0 4
108863: PUSH
108864: LD_INT 70
108866: ST_TO_ADDR
108867: GO 108877
// eff := 30 ;
108869: LD_ADDR_VAR 0 4
108873: PUSH
108874: LD_INT 30
108876: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
108877: LD_VAR 0 1
108881: PPUSH
108882: CALL_OW 250
108886: PPUSH
108887: LD_VAR 0 1
108891: PPUSH
108892: CALL_OW 251
108896: PPUSH
108897: LD_VAR 0 4
108901: PPUSH
108902: CALL_OW 495
// end ; end ;
108906: LD_VAR 0 2
108910: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
108911: LD_INT 0
108913: PPUSH
// end ;
108914: LD_VAR 0 4
108918: RET
// export function SOS_Command ( cmd ) ; begin
108919: LD_INT 0
108921: PPUSH
// end ;
108922: LD_VAR 0 2
108926: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
108927: LD_INT 0
108929: PPUSH
// end ;
108930: LD_VAR 0 6
108934: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
108935: LD_INT 0
108937: PPUSH
108938: PPUSH
// if not vehicle or not factory then
108939: LD_VAR 0 1
108943: NOT
108944: PUSH
108945: LD_VAR 0 2
108949: NOT
108950: OR
108951: IFFALSE 108955
// exit ;
108953: GO 109186
// if factoryWaypoints >= factory then
108955: LD_EXP 178
108959: PUSH
108960: LD_VAR 0 2
108964: GREATEREQUAL
108965: IFFALSE 109186
// if factoryWaypoints [ factory ] then
108967: LD_EXP 178
108971: PUSH
108972: LD_VAR 0 2
108976: ARRAY
108977: IFFALSE 109186
// begin if GetControl ( vehicle ) = control_manual then
108979: LD_VAR 0 1
108983: PPUSH
108984: CALL_OW 263
108988: PUSH
108989: LD_INT 1
108991: EQUAL
108992: IFFALSE 109073
// begin driver := IsDrivenBy ( vehicle ) ;
108994: LD_ADDR_VAR 0 4
108998: PUSH
108999: LD_VAR 0 1
109003: PPUSH
109004: CALL_OW 311
109008: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109009: LD_VAR 0 4
109013: PPUSH
109014: LD_EXP 178
109018: PUSH
109019: LD_VAR 0 2
109023: ARRAY
109024: PUSH
109025: LD_INT 3
109027: ARRAY
109028: PPUSH
109029: LD_EXP 178
109033: PUSH
109034: LD_VAR 0 2
109038: ARRAY
109039: PUSH
109040: LD_INT 4
109042: ARRAY
109043: PPUSH
109044: CALL_OW 171
// AddComExitVehicle ( driver ) ;
109048: LD_VAR 0 4
109052: PPUSH
109053: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
109057: LD_VAR 0 4
109061: PPUSH
109062: LD_VAR 0 2
109066: PPUSH
109067: CALL_OW 180
// end else
109071: GO 109186
// if GetControl ( vehicle ) = control_remote then
109073: LD_VAR 0 1
109077: PPUSH
109078: CALL_OW 263
109082: PUSH
109083: LD_INT 2
109085: EQUAL
109086: IFFALSE 109147
// begin wait ( 0 0$2 ) ;
109088: LD_INT 70
109090: PPUSH
109091: CALL_OW 67
// if Connect ( vehicle ) then
109095: LD_VAR 0 1
109099: PPUSH
109100: CALL 60014 0 1
109104: IFFALSE 109145
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109106: LD_VAR 0 1
109110: PPUSH
109111: LD_EXP 178
109115: PUSH
109116: LD_VAR 0 2
109120: ARRAY
109121: PUSH
109122: LD_INT 3
109124: ARRAY
109125: PPUSH
109126: LD_EXP 178
109130: PUSH
109131: LD_VAR 0 2
109135: ARRAY
109136: PUSH
109137: LD_INT 4
109139: ARRAY
109140: PPUSH
109141: CALL_OW 171
// end else
109145: GO 109186
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
109147: LD_VAR 0 1
109151: PPUSH
109152: LD_EXP 178
109156: PUSH
109157: LD_VAR 0 2
109161: ARRAY
109162: PUSH
109163: LD_INT 3
109165: ARRAY
109166: PPUSH
109167: LD_EXP 178
109171: PUSH
109172: LD_VAR 0 2
109176: ARRAY
109177: PUSH
109178: LD_INT 4
109180: ARRAY
109181: PPUSH
109182: CALL_OW 171
// end ; end ;
109186: LD_VAR 0 3
109190: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
109191: LD_INT 0
109193: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
109194: LD_VAR 0 1
109198: PUSH
109199: LD_INT 250
109201: EQUAL
109202: PUSH
109203: LD_VAR 0 2
109207: PPUSH
109208: CALL_OW 264
109212: PUSH
109213: LD_INT 81
109215: EQUAL
109216: AND
109217: IFFALSE 109238
// MinerPlaceMine ( unit , x , y ) ;
109219: LD_VAR 0 2
109223: PPUSH
109224: LD_VAR 0 4
109228: PPUSH
109229: LD_VAR 0 5
109233: PPUSH
109234: CALL 111623 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
109238: LD_VAR 0 1
109242: PUSH
109243: LD_INT 251
109245: EQUAL
109246: PUSH
109247: LD_VAR 0 2
109251: PPUSH
109252: CALL_OW 264
109256: PUSH
109257: LD_INT 81
109259: EQUAL
109260: AND
109261: IFFALSE 109282
// MinerDetonateMine ( unit , x , y ) ;
109263: LD_VAR 0 2
109267: PPUSH
109268: LD_VAR 0 4
109272: PPUSH
109273: LD_VAR 0 5
109277: PPUSH
109278: CALL 111898 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
109282: LD_VAR 0 1
109286: PUSH
109287: LD_INT 252
109289: EQUAL
109290: PUSH
109291: LD_VAR 0 2
109295: PPUSH
109296: CALL_OW 264
109300: PUSH
109301: LD_INT 81
109303: EQUAL
109304: AND
109305: IFFALSE 109326
// MinerCreateMinefield ( unit , x , y ) ;
109307: LD_VAR 0 2
109311: PPUSH
109312: LD_VAR 0 4
109316: PPUSH
109317: LD_VAR 0 5
109321: PPUSH
109322: CALL 112315 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
109326: LD_VAR 0 1
109330: PUSH
109331: LD_INT 253
109333: EQUAL
109334: PUSH
109335: LD_VAR 0 2
109339: PPUSH
109340: CALL_OW 257
109344: PUSH
109345: LD_INT 5
109347: EQUAL
109348: AND
109349: IFFALSE 109370
// ComBinocular ( unit , x , y ) ;
109351: LD_VAR 0 2
109355: PPUSH
109356: LD_VAR 0 4
109360: PPUSH
109361: LD_VAR 0 5
109365: PPUSH
109366: CALL 112684 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
109370: LD_VAR 0 1
109374: PUSH
109375: LD_INT 254
109377: EQUAL
109378: PUSH
109379: LD_VAR 0 2
109383: PPUSH
109384: CALL_OW 264
109388: PUSH
109389: LD_INT 99
109391: EQUAL
109392: AND
109393: PUSH
109394: LD_VAR 0 3
109398: PPUSH
109399: CALL_OW 263
109403: PUSH
109404: LD_INT 3
109406: EQUAL
109407: AND
109408: IFFALSE 109424
// HackDestroyVehicle ( unit , selectedUnit ) ;
109410: LD_VAR 0 2
109414: PPUSH
109415: LD_VAR 0 3
109419: PPUSH
109420: CALL 110987 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
109424: LD_VAR 0 1
109428: PUSH
109429: LD_INT 255
109431: EQUAL
109432: PUSH
109433: LD_VAR 0 2
109437: PPUSH
109438: CALL_OW 264
109442: PUSH
109443: LD_INT 14
109445: PUSH
109446: LD_INT 53
109448: PUSH
109449: EMPTY
109450: LIST
109451: LIST
109452: IN
109453: AND
109454: PUSH
109455: LD_VAR 0 4
109459: PPUSH
109460: LD_VAR 0 5
109464: PPUSH
109465: CALL_OW 488
109469: AND
109470: IFFALSE 109494
// CutTreeXYR ( unit , x , y , 12 ) ;
109472: LD_VAR 0 2
109476: PPUSH
109477: LD_VAR 0 4
109481: PPUSH
109482: LD_VAR 0 5
109486: PPUSH
109487: LD_INT 12
109489: PPUSH
109490: CALL 109557 0 4
// if cmd = 256 then
109494: LD_VAR 0 1
109498: PUSH
109499: LD_INT 256
109501: EQUAL
109502: IFFALSE 109523
// SetFactoryWaypoint ( unit , x , y ) ;
109504: LD_VAR 0 2
109508: PPUSH
109509: LD_VAR 0 4
109513: PPUSH
109514: LD_VAR 0 5
109518: PPUSH
109519: CALL 107504 0 3
// if cmd = 257 then
109523: LD_VAR 0 1
109527: PUSH
109528: LD_INT 257
109530: EQUAL
109531: IFFALSE 109552
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109533: LD_VAR 0 2
109537: PPUSH
109538: LD_VAR 0 4
109542: PPUSH
109543: LD_VAR 0 5
109547: PPUSH
109548: CALL 107866 0 3
// end ;
109552: LD_VAR 0 6
109556: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109557: LD_INT 0
109559: PPUSH
109560: PPUSH
109561: PPUSH
109562: PPUSH
109563: PPUSH
109564: PPUSH
109565: PPUSH
109566: PPUSH
109567: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
109568: LD_VAR 0 1
109572: NOT
109573: PUSH
109574: LD_VAR 0 2
109578: PPUSH
109579: LD_VAR 0 3
109583: PPUSH
109584: CALL_OW 488
109588: NOT
109589: OR
109590: PUSH
109591: LD_VAR 0 4
109595: NOT
109596: OR
109597: IFFALSE 109601
// exit ;
109599: GO 109941
// list := [ ] ;
109601: LD_ADDR_VAR 0 13
109605: PUSH
109606: EMPTY
109607: ST_TO_ADDR
// if x - r < 0 then
109608: LD_VAR 0 2
109612: PUSH
109613: LD_VAR 0 4
109617: MINUS
109618: PUSH
109619: LD_INT 0
109621: LESS
109622: IFFALSE 109634
// min_x := 0 else
109624: LD_ADDR_VAR 0 7
109628: PUSH
109629: LD_INT 0
109631: ST_TO_ADDR
109632: GO 109650
// min_x := x - r ;
109634: LD_ADDR_VAR 0 7
109638: PUSH
109639: LD_VAR 0 2
109643: PUSH
109644: LD_VAR 0 4
109648: MINUS
109649: ST_TO_ADDR
// if y - r < 0 then
109650: LD_VAR 0 3
109654: PUSH
109655: LD_VAR 0 4
109659: MINUS
109660: PUSH
109661: LD_INT 0
109663: LESS
109664: IFFALSE 109676
// min_y := 0 else
109666: LD_ADDR_VAR 0 8
109670: PUSH
109671: LD_INT 0
109673: ST_TO_ADDR
109674: GO 109692
// min_y := y - r ;
109676: LD_ADDR_VAR 0 8
109680: PUSH
109681: LD_VAR 0 3
109685: PUSH
109686: LD_VAR 0 4
109690: MINUS
109691: ST_TO_ADDR
// max_x := x + r ;
109692: LD_ADDR_VAR 0 9
109696: PUSH
109697: LD_VAR 0 2
109701: PUSH
109702: LD_VAR 0 4
109706: PLUS
109707: ST_TO_ADDR
// max_y := y + r ;
109708: LD_ADDR_VAR 0 10
109712: PUSH
109713: LD_VAR 0 3
109717: PUSH
109718: LD_VAR 0 4
109722: PLUS
109723: ST_TO_ADDR
// for _x = min_x to max_x do
109724: LD_ADDR_VAR 0 11
109728: PUSH
109729: DOUBLE
109730: LD_VAR 0 7
109734: DEC
109735: ST_TO_ADDR
109736: LD_VAR 0 9
109740: PUSH
109741: FOR_TO
109742: IFFALSE 109859
// for _y = min_y to max_y do
109744: LD_ADDR_VAR 0 12
109748: PUSH
109749: DOUBLE
109750: LD_VAR 0 8
109754: DEC
109755: ST_TO_ADDR
109756: LD_VAR 0 10
109760: PUSH
109761: FOR_TO
109762: IFFALSE 109855
// begin if not ValidHex ( _x , _y ) then
109764: LD_VAR 0 11
109768: PPUSH
109769: LD_VAR 0 12
109773: PPUSH
109774: CALL_OW 488
109778: NOT
109779: IFFALSE 109783
// continue ;
109781: GO 109761
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109783: LD_VAR 0 11
109787: PPUSH
109788: LD_VAR 0 12
109792: PPUSH
109793: CALL_OW 351
109797: PUSH
109798: LD_VAR 0 11
109802: PPUSH
109803: LD_VAR 0 12
109807: PPUSH
109808: CALL_OW 554
109812: AND
109813: IFFALSE 109853
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109815: LD_ADDR_VAR 0 13
109819: PUSH
109820: LD_VAR 0 13
109824: PPUSH
109825: LD_VAR 0 13
109829: PUSH
109830: LD_INT 1
109832: PLUS
109833: PPUSH
109834: LD_VAR 0 11
109838: PUSH
109839: LD_VAR 0 12
109843: PUSH
109844: EMPTY
109845: LIST
109846: LIST
109847: PPUSH
109848: CALL_OW 2
109852: ST_TO_ADDR
// end ;
109853: GO 109761
109855: POP
109856: POP
109857: GO 109741
109859: POP
109860: POP
// if not list then
109861: LD_VAR 0 13
109865: NOT
109866: IFFALSE 109870
// exit ;
109868: GO 109941
// for i in list do
109870: LD_ADDR_VAR 0 6
109874: PUSH
109875: LD_VAR 0 13
109879: PUSH
109880: FOR_IN
109881: IFFALSE 109939
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109883: LD_VAR 0 1
109887: PPUSH
109888: LD_STRING M
109890: PUSH
109891: LD_VAR 0 6
109895: PUSH
109896: LD_INT 1
109898: ARRAY
109899: PUSH
109900: LD_VAR 0 6
109904: PUSH
109905: LD_INT 2
109907: ARRAY
109908: PUSH
109909: LD_INT 0
109911: PUSH
109912: LD_INT 0
109914: PUSH
109915: LD_INT 0
109917: PUSH
109918: LD_INT 0
109920: PUSH
109921: EMPTY
109922: LIST
109923: LIST
109924: LIST
109925: LIST
109926: LIST
109927: LIST
109928: LIST
109929: PUSH
109930: EMPTY
109931: LIST
109932: PPUSH
109933: CALL_OW 447
109937: GO 109880
109939: POP
109940: POP
// end ;
109941: LD_VAR 0 5
109945: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
109946: LD_EXP 181
109950: NOT
109951: IFFALSE 110001
109953: GO 109955
109955: DISABLE
// begin initHack := true ;
109956: LD_ADDR_EXP 181
109960: PUSH
109961: LD_INT 1
109963: ST_TO_ADDR
// hackTanks := [ ] ;
109964: LD_ADDR_EXP 182
109968: PUSH
109969: EMPTY
109970: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
109971: LD_ADDR_EXP 183
109975: PUSH
109976: EMPTY
109977: ST_TO_ADDR
// hackLimit := 3 ;
109978: LD_ADDR_EXP 184
109982: PUSH
109983: LD_INT 3
109985: ST_TO_ADDR
// hackDist := 12 ;
109986: LD_ADDR_EXP 185
109990: PUSH
109991: LD_INT 12
109993: ST_TO_ADDR
// hackCounter := [ ] ;
109994: LD_ADDR_EXP 186
109998: PUSH
109999: EMPTY
110000: ST_TO_ADDR
// end ;
110001: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110002: LD_EXP 181
110006: PUSH
110007: LD_INT 34
110009: PUSH
110010: LD_INT 99
110012: PUSH
110013: EMPTY
110014: LIST
110015: LIST
110016: PPUSH
110017: CALL_OW 69
110021: AND
110022: IFFALSE 110275
110024: GO 110026
110026: DISABLE
110027: LD_INT 0
110029: PPUSH
110030: PPUSH
// begin enable ;
110031: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110032: LD_ADDR_VAR 0 1
110036: PUSH
110037: LD_INT 34
110039: PUSH
110040: LD_INT 99
110042: PUSH
110043: EMPTY
110044: LIST
110045: LIST
110046: PPUSH
110047: CALL_OW 69
110051: PUSH
110052: FOR_IN
110053: IFFALSE 110273
// begin if not i in hackTanks then
110055: LD_VAR 0 1
110059: PUSH
110060: LD_EXP 182
110064: IN
110065: NOT
110066: IFFALSE 110149
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110068: LD_ADDR_EXP 182
110072: PUSH
110073: LD_EXP 182
110077: PPUSH
110078: LD_EXP 182
110082: PUSH
110083: LD_INT 1
110085: PLUS
110086: PPUSH
110087: LD_VAR 0 1
110091: PPUSH
110092: CALL_OW 1
110096: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110097: LD_ADDR_EXP 183
110101: PUSH
110102: LD_EXP 183
110106: PPUSH
110107: LD_EXP 183
110111: PUSH
110112: LD_INT 1
110114: PLUS
110115: PPUSH
110116: EMPTY
110117: PPUSH
110118: CALL_OW 1
110122: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110123: LD_ADDR_EXP 186
110127: PUSH
110128: LD_EXP 186
110132: PPUSH
110133: LD_EXP 186
110137: PUSH
110138: LD_INT 1
110140: PLUS
110141: PPUSH
110142: EMPTY
110143: PPUSH
110144: CALL_OW 1
110148: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110149: LD_VAR 0 1
110153: PPUSH
110154: CALL_OW 302
110158: NOT
110159: IFFALSE 110172
// begin HackUnlinkAll ( i ) ;
110161: LD_VAR 0 1
110165: PPUSH
110166: CALL 110278 0 1
// continue ;
110170: GO 110052
// end ; HackCheckCapturedStatus ( i ) ;
110172: LD_VAR 0 1
110176: PPUSH
110177: CALL 110721 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110181: LD_ADDR_VAR 0 2
110185: PUSH
110186: LD_INT 81
110188: PUSH
110189: LD_VAR 0 1
110193: PPUSH
110194: CALL_OW 255
110198: PUSH
110199: EMPTY
110200: LIST
110201: LIST
110202: PUSH
110203: LD_INT 33
110205: PUSH
110206: LD_INT 3
110208: PUSH
110209: EMPTY
110210: LIST
110211: LIST
110212: PUSH
110213: LD_INT 91
110215: PUSH
110216: LD_VAR 0 1
110220: PUSH
110221: LD_EXP 185
110225: PUSH
110226: EMPTY
110227: LIST
110228: LIST
110229: LIST
110230: PUSH
110231: LD_INT 50
110233: PUSH
110234: EMPTY
110235: LIST
110236: PUSH
110237: EMPTY
110238: LIST
110239: LIST
110240: LIST
110241: LIST
110242: PPUSH
110243: CALL_OW 69
110247: ST_TO_ADDR
// if not tmp then
110248: LD_VAR 0 2
110252: NOT
110253: IFFALSE 110257
// continue ;
110255: GO 110052
// HackLink ( i , tmp ) ;
110257: LD_VAR 0 1
110261: PPUSH
110262: LD_VAR 0 2
110266: PPUSH
110267: CALL 110414 0 2
// end ;
110271: GO 110052
110273: POP
110274: POP
// end ;
110275: PPOPN 2
110277: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110278: LD_INT 0
110280: PPUSH
110281: PPUSH
110282: PPUSH
// if not hack in hackTanks then
110283: LD_VAR 0 1
110287: PUSH
110288: LD_EXP 182
110292: IN
110293: NOT
110294: IFFALSE 110298
// exit ;
110296: GO 110409
// index := GetElementIndex ( hackTanks , hack ) ;
110298: LD_ADDR_VAR 0 4
110302: PUSH
110303: LD_EXP 182
110307: PPUSH
110308: LD_VAR 0 1
110312: PPUSH
110313: CALL 56830 0 2
110317: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110318: LD_EXP 183
110322: PUSH
110323: LD_VAR 0 4
110327: ARRAY
110328: IFFALSE 110409
// begin for i in hackTanksCaptured [ index ] do
110330: LD_ADDR_VAR 0 3
110334: PUSH
110335: LD_EXP 183
110339: PUSH
110340: LD_VAR 0 4
110344: ARRAY
110345: PUSH
110346: FOR_IN
110347: IFFALSE 110373
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110349: LD_VAR 0 3
110353: PUSH
110354: LD_INT 1
110356: ARRAY
110357: PPUSH
110358: LD_VAR 0 3
110362: PUSH
110363: LD_INT 2
110365: ARRAY
110366: PPUSH
110367: CALL_OW 235
110371: GO 110346
110373: POP
110374: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110375: LD_ADDR_EXP 183
110379: PUSH
110380: LD_EXP 183
110384: PPUSH
110385: LD_VAR 0 4
110389: PPUSH
110390: EMPTY
110391: PPUSH
110392: CALL_OW 1
110396: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110397: LD_VAR 0 1
110401: PPUSH
110402: LD_INT 0
110404: PPUSH
110405: CALL_OW 505
// end ; end ;
110409: LD_VAR 0 2
110413: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110414: LD_INT 0
110416: PPUSH
110417: PPUSH
110418: PPUSH
// if not hack in hackTanks or not vehicles then
110419: LD_VAR 0 1
110423: PUSH
110424: LD_EXP 182
110428: IN
110429: NOT
110430: PUSH
110431: LD_VAR 0 2
110435: NOT
110436: OR
110437: IFFALSE 110441
// exit ;
110439: GO 110716
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110441: LD_ADDR_VAR 0 2
110445: PUSH
110446: LD_VAR 0 1
110450: PPUSH
110451: LD_VAR 0 2
110455: PPUSH
110456: LD_INT 1
110458: PPUSH
110459: LD_INT 1
110461: PPUSH
110462: CALL 57480 0 4
110466: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110467: LD_ADDR_VAR 0 5
110471: PUSH
110472: LD_EXP 182
110476: PPUSH
110477: LD_VAR 0 1
110481: PPUSH
110482: CALL 56830 0 2
110486: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110487: LD_EXP 183
110491: PUSH
110492: LD_VAR 0 5
110496: ARRAY
110497: PUSH
110498: LD_EXP 184
110502: LESS
110503: IFFALSE 110692
// begin for i := 1 to vehicles do
110505: LD_ADDR_VAR 0 4
110509: PUSH
110510: DOUBLE
110511: LD_INT 1
110513: DEC
110514: ST_TO_ADDR
110515: LD_VAR 0 2
110519: PUSH
110520: FOR_TO
110521: IFFALSE 110690
// begin if hackTanksCaptured [ index ] = hackLimit then
110523: LD_EXP 183
110527: PUSH
110528: LD_VAR 0 5
110532: ARRAY
110533: PUSH
110534: LD_EXP 184
110538: EQUAL
110539: IFFALSE 110543
// break ;
110541: GO 110690
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110543: LD_ADDR_EXP 186
110547: PUSH
110548: LD_EXP 186
110552: PPUSH
110553: LD_VAR 0 5
110557: PPUSH
110558: LD_EXP 186
110562: PUSH
110563: LD_VAR 0 5
110567: ARRAY
110568: PUSH
110569: LD_INT 1
110571: PLUS
110572: PPUSH
110573: CALL_OW 1
110577: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110578: LD_ADDR_EXP 183
110582: PUSH
110583: LD_EXP 183
110587: PPUSH
110588: LD_VAR 0 5
110592: PUSH
110593: LD_EXP 183
110597: PUSH
110598: LD_VAR 0 5
110602: ARRAY
110603: PUSH
110604: LD_INT 1
110606: PLUS
110607: PUSH
110608: EMPTY
110609: LIST
110610: LIST
110611: PPUSH
110612: LD_VAR 0 2
110616: PUSH
110617: LD_VAR 0 4
110621: ARRAY
110622: PUSH
110623: LD_VAR 0 2
110627: PUSH
110628: LD_VAR 0 4
110632: ARRAY
110633: PPUSH
110634: CALL_OW 255
110638: PUSH
110639: EMPTY
110640: LIST
110641: LIST
110642: PPUSH
110643: CALL 57045 0 3
110647: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110648: LD_VAR 0 2
110652: PUSH
110653: LD_VAR 0 4
110657: ARRAY
110658: PPUSH
110659: LD_VAR 0 1
110663: PPUSH
110664: CALL_OW 255
110668: PPUSH
110669: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110673: LD_VAR 0 2
110677: PUSH
110678: LD_VAR 0 4
110682: ARRAY
110683: PPUSH
110684: CALL_OW 141
// end ;
110688: GO 110520
110690: POP
110691: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110692: LD_VAR 0 1
110696: PPUSH
110697: LD_EXP 183
110701: PUSH
110702: LD_VAR 0 5
110706: ARRAY
110707: PUSH
110708: LD_INT 0
110710: PLUS
110711: PPUSH
110712: CALL_OW 505
// end ;
110716: LD_VAR 0 3
110720: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110721: LD_INT 0
110723: PPUSH
110724: PPUSH
110725: PPUSH
110726: PPUSH
// if not hack in hackTanks then
110727: LD_VAR 0 1
110731: PUSH
110732: LD_EXP 182
110736: IN
110737: NOT
110738: IFFALSE 110742
// exit ;
110740: GO 110982
// index := GetElementIndex ( hackTanks , hack ) ;
110742: LD_ADDR_VAR 0 4
110746: PUSH
110747: LD_EXP 182
110751: PPUSH
110752: LD_VAR 0 1
110756: PPUSH
110757: CALL 56830 0 2
110761: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110762: LD_ADDR_VAR 0 3
110766: PUSH
110767: DOUBLE
110768: LD_EXP 183
110772: PUSH
110773: LD_VAR 0 4
110777: ARRAY
110778: INC
110779: ST_TO_ADDR
110780: LD_INT 1
110782: PUSH
110783: FOR_DOWNTO
110784: IFFALSE 110956
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110786: LD_ADDR_VAR 0 5
110790: PUSH
110791: LD_EXP 183
110795: PUSH
110796: LD_VAR 0 4
110800: ARRAY
110801: PUSH
110802: LD_VAR 0 3
110806: ARRAY
110807: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110808: LD_VAR 0 5
110812: PUSH
110813: LD_INT 1
110815: ARRAY
110816: PPUSH
110817: CALL_OW 302
110821: NOT
110822: PUSH
110823: LD_VAR 0 5
110827: PUSH
110828: LD_INT 1
110830: ARRAY
110831: PPUSH
110832: CALL_OW 255
110836: PUSH
110837: LD_VAR 0 1
110841: PPUSH
110842: CALL_OW 255
110846: NONEQUAL
110847: OR
110848: IFFALSE 110954
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
110850: LD_VAR 0 5
110854: PUSH
110855: LD_INT 1
110857: ARRAY
110858: PPUSH
110859: CALL_OW 305
110863: PUSH
110864: LD_VAR 0 5
110868: PUSH
110869: LD_INT 1
110871: ARRAY
110872: PPUSH
110873: CALL_OW 255
110877: PUSH
110878: LD_VAR 0 1
110882: PPUSH
110883: CALL_OW 255
110887: EQUAL
110888: AND
110889: IFFALSE 110913
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110891: LD_VAR 0 5
110895: PUSH
110896: LD_INT 1
110898: ARRAY
110899: PPUSH
110900: LD_VAR 0 5
110904: PUSH
110905: LD_INT 2
110907: ARRAY
110908: PPUSH
110909: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
110913: LD_ADDR_EXP 183
110917: PUSH
110918: LD_EXP 183
110922: PPUSH
110923: LD_VAR 0 4
110927: PPUSH
110928: LD_EXP 183
110932: PUSH
110933: LD_VAR 0 4
110937: ARRAY
110938: PPUSH
110939: LD_VAR 0 3
110943: PPUSH
110944: CALL_OW 3
110948: PPUSH
110949: CALL_OW 1
110953: ST_TO_ADDR
// end ; end ;
110954: GO 110783
110956: POP
110957: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110958: LD_VAR 0 1
110962: PPUSH
110963: LD_EXP 183
110967: PUSH
110968: LD_VAR 0 4
110972: ARRAY
110973: PUSH
110974: LD_INT 0
110976: PLUS
110977: PPUSH
110978: CALL_OW 505
// end ;
110982: LD_VAR 0 2
110986: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
110987: LD_INT 0
110989: PPUSH
110990: PPUSH
110991: PPUSH
110992: PPUSH
// if not hack in hackTanks then
110993: LD_VAR 0 1
110997: PUSH
110998: LD_EXP 182
111002: IN
111003: NOT
111004: IFFALSE 111008
// exit ;
111006: GO 111093
// index := GetElementIndex ( hackTanks , hack ) ;
111008: LD_ADDR_VAR 0 5
111012: PUSH
111013: LD_EXP 182
111017: PPUSH
111018: LD_VAR 0 1
111022: PPUSH
111023: CALL 56830 0 2
111027: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111028: LD_ADDR_VAR 0 4
111032: PUSH
111033: DOUBLE
111034: LD_INT 1
111036: DEC
111037: ST_TO_ADDR
111038: LD_EXP 183
111042: PUSH
111043: LD_VAR 0 5
111047: ARRAY
111048: PUSH
111049: FOR_TO
111050: IFFALSE 111091
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111052: LD_EXP 183
111056: PUSH
111057: LD_VAR 0 5
111061: ARRAY
111062: PUSH
111063: LD_VAR 0 4
111067: ARRAY
111068: PUSH
111069: LD_INT 1
111071: ARRAY
111072: PUSH
111073: LD_VAR 0 2
111077: EQUAL
111078: IFFALSE 111089
// KillUnit ( vehicle ) ;
111080: LD_VAR 0 2
111084: PPUSH
111085: CALL_OW 66
111089: GO 111049
111091: POP
111092: POP
// end ;
111093: LD_VAR 0 3
111097: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111098: LD_EXP 187
111102: NOT
111103: IFFALSE 111138
111105: GO 111107
111107: DISABLE
// begin initMiner := true ;
111108: LD_ADDR_EXP 187
111112: PUSH
111113: LD_INT 1
111115: ST_TO_ADDR
// minersList := [ ] ;
111116: LD_ADDR_EXP 188
111120: PUSH
111121: EMPTY
111122: ST_TO_ADDR
// minerMinesList := [ ] ;
111123: LD_ADDR_EXP 189
111127: PUSH
111128: EMPTY
111129: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111130: LD_ADDR_EXP 190
111134: PUSH
111135: LD_INT 5
111137: ST_TO_ADDR
// end ;
111138: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111139: LD_EXP 187
111143: PUSH
111144: LD_INT 34
111146: PUSH
111147: LD_INT 81
111149: PUSH
111150: EMPTY
111151: LIST
111152: LIST
111153: PPUSH
111154: CALL_OW 69
111158: AND
111159: IFFALSE 111620
111161: GO 111163
111163: DISABLE
111164: LD_INT 0
111166: PPUSH
111167: PPUSH
111168: PPUSH
111169: PPUSH
// begin enable ;
111170: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111171: LD_ADDR_VAR 0 1
111175: PUSH
111176: LD_INT 34
111178: PUSH
111179: LD_INT 81
111181: PUSH
111182: EMPTY
111183: LIST
111184: LIST
111185: PPUSH
111186: CALL_OW 69
111190: PUSH
111191: FOR_IN
111192: IFFALSE 111264
// begin if not i in minersList then
111194: LD_VAR 0 1
111198: PUSH
111199: LD_EXP 188
111203: IN
111204: NOT
111205: IFFALSE 111262
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111207: LD_ADDR_EXP 188
111211: PUSH
111212: LD_EXP 188
111216: PPUSH
111217: LD_EXP 188
111221: PUSH
111222: LD_INT 1
111224: PLUS
111225: PPUSH
111226: LD_VAR 0 1
111230: PPUSH
111231: CALL_OW 1
111235: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111236: LD_ADDR_EXP 189
111240: PUSH
111241: LD_EXP 189
111245: PPUSH
111246: LD_EXP 189
111250: PUSH
111251: LD_INT 1
111253: PLUS
111254: PPUSH
111255: EMPTY
111256: PPUSH
111257: CALL_OW 1
111261: ST_TO_ADDR
// end end ;
111262: GO 111191
111264: POP
111265: POP
// for i := minerMinesList downto 1 do
111266: LD_ADDR_VAR 0 1
111270: PUSH
111271: DOUBLE
111272: LD_EXP 189
111276: INC
111277: ST_TO_ADDR
111278: LD_INT 1
111280: PUSH
111281: FOR_DOWNTO
111282: IFFALSE 111618
// begin if IsLive ( minersList [ i ] ) then
111284: LD_EXP 188
111288: PUSH
111289: LD_VAR 0 1
111293: ARRAY
111294: PPUSH
111295: CALL_OW 300
111299: IFFALSE 111327
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111301: LD_EXP 188
111305: PUSH
111306: LD_VAR 0 1
111310: ARRAY
111311: PPUSH
111312: LD_EXP 189
111316: PUSH
111317: LD_VAR 0 1
111321: ARRAY
111322: PPUSH
111323: CALL_OW 505
// if not minerMinesList [ i ] then
111327: LD_EXP 189
111331: PUSH
111332: LD_VAR 0 1
111336: ARRAY
111337: NOT
111338: IFFALSE 111342
// continue ;
111340: GO 111281
// for j := minerMinesList [ i ] downto 1 do
111342: LD_ADDR_VAR 0 2
111346: PUSH
111347: DOUBLE
111348: LD_EXP 189
111352: PUSH
111353: LD_VAR 0 1
111357: ARRAY
111358: INC
111359: ST_TO_ADDR
111360: LD_INT 1
111362: PUSH
111363: FOR_DOWNTO
111364: IFFALSE 111614
// begin side := GetSide ( minersList [ i ] ) ;
111366: LD_ADDR_VAR 0 3
111370: PUSH
111371: LD_EXP 188
111375: PUSH
111376: LD_VAR 0 1
111380: ARRAY
111381: PPUSH
111382: CALL_OW 255
111386: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111387: LD_ADDR_VAR 0 4
111391: PUSH
111392: LD_EXP 189
111396: PUSH
111397: LD_VAR 0 1
111401: ARRAY
111402: PUSH
111403: LD_VAR 0 2
111407: ARRAY
111408: PUSH
111409: LD_INT 1
111411: ARRAY
111412: PPUSH
111413: LD_EXP 189
111417: PUSH
111418: LD_VAR 0 1
111422: ARRAY
111423: PUSH
111424: LD_VAR 0 2
111428: ARRAY
111429: PUSH
111430: LD_INT 2
111432: ARRAY
111433: PPUSH
111434: CALL_OW 428
111438: ST_TO_ADDR
// if not tmp then
111439: LD_VAR 0 4
111443: NOT
111444: IFFALSE 111448
// continue ;
111446: GO 111363
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111448: LD_VAR 0 4
111452: PUSH
111453: LD_INT 81
111455: PUSH
111456: LD_VAR 0 3
111460: PUSH
111461: EMPTY
111462: LIST
111463: LIST
111464: PPUSH
111465: CALL_OW 69
111469: IN
111470: PUSH
111471: LD_EXP 189
111475: PUSH
111476: LD_VAR 0 1
111480: ARRAY
111481: PUSH
111482: LD_VAR 0 2
111486: ARRAY
111487: PUSH
111488: LD_INT 1
111490: ARRAY
111491: PPUSH
111492: LD_EXP 189
111496: PUSH
111497: LD_VAR 0 1
111501: ARRAY
111502: PUSH
111503: LD_VAR 0 2
111507: ARRAY
111508: PUSH
111509: LD_INT 2
111511: ARRAY
111512: PPUSH
111513: CALL_OW 458
111517: AND
111518: IFFALSE 111612
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111520: LD_EXP 189
111524: PUSH
111525: LD_VAR 0 1
111529: ARRAY
111530: PUSH
111531: LD_VAR 0 2
111535: ARRAY
111536: PUSH
111537: LD_INT 1
111539: ARRAY
111540: PPUSH
111541: LD_EXP 189
111545: PUSH
111546: LD_VAR 0 1
111550: ARRAY
111551: PUSH
111552: LD_VAR 0 2
111556: ARRAY
111557: PUSH
111558: LD_INT 2
111560: ARRAY
111561: PPUSH
111562: LD_VAR 0 3
111566: PPUSH
111567: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111571: LD_ADDR_EXP 189
111575: PUSH
111576: LD_EXP 189
111580: PPUSH
111581: LD_VAR 0 1
111585: PPUSH
111586: LD_EXP 189
111590: PUSH
111591: LD_VAR 0 1
111595: ARRAY
111596: PPUSH
111597: LD_VAR 0 2
111601: PPUSH
111602: CALL_OW 3
111606: PPUSH
111607: CALL_OW 1
111611: ST_TO_ADDR
// end ; end ;
111612: GO 111363
111614: POP
111615: POP
// end ;
111616: GO 111281
111618: POP
111619: POP
// end ;
111620: PPOPN 4
111622: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111623: LD_INT 0
111625: PPUSH
111626: PPUSH
// result := false ;
111627: LD_ADDR_VAR 0 4
111631: PUSH
111632: LD_INT 0
111634: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111635: LD_VAR 0 1
111639: PPUSH
111640: CALL_OW 264
111644: PUSH
111645: LD_INT 81
111647: EQUAL
111648: NOT
111649: IFFALSE 111653
// exit ;
111651: GO 111893
// index := GetElementIndex ( minersList , unit ) ;
111653: LD_ADDR_VAR 0 5
111657: PUSH
111658: LD_EXP 188
111662: PPUSH
111663: LD_VAR 0 1
111667: PPUSH
111668: CALL 56830 0 2
111672: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111673: LD_EXP 189
111677: PUSH
111678: LD_VAR 0 5
111682: ARRAY
111683: PUSH
111684: LD_EXP 190
111688: GREATEREQUAL
111689: IFFALSE 111693
// exit ;
111691: GO 111893
// ComMoveXY ( unit , x , y ) ;
111693: LD_VAR 0 1
111697: PPUSH
111698: LD_VAR 0 2
111702: PPUSH
111703: LD_VAR 0 3
111707: PPUSH
111708: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111712: LD_INT 35
111714: PPUSH
111715: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111719: LD_VAR 0 1
111723: PPUSH
111724: LD_VAR 0 2
111728: PPUSH
111729: LD_VAR 0 3
111733: PPUSH
111734: CALL 88166 0 3
111738: NOT
111739: PUSH
111740: LD_VAR 0 1
111744: PPUSH
111745: CALL_OW 314
111749: AND
111750: IFFALSE 111754
// exit ;
111752: GO 111893
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111754: LD_VAR 0 2
111758: PPUSH
111759: LD_VAR 0 3
111763: PPUSH
111764: CALL_OW 428
111768: PUSH
111769: LD_VAR 0 1
111773: EQUAL
111774: PUSH
111775: LD_VAR 0 1
111779: PPUSH
111780: CALL_OW 314
111784: NOT
111785: AND
111786: IFFALSE 111712
// PlaySoundXY ( x , y , PlantMine ) ;
111788: LD_VAR 0 2
111792: PPUSH
111793: LD_VAR 0 3
111797: PPUSH
111798: LD_STRING PlantMine
111800: PPUSH
111801: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111805: LD_VAR 0 2
111809: PPUSH
111810: LD_VAR 0 3
111814: PPUSH
111815: LD_VAR 0 1
111819: PPUSH
111820: CALL_OW 255
111824: PPUSH
111825: LD_INT 0
111827: PPUSH
111828: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
111832: LD_ADDR_EXP 189
111836: PUSH
111837: LD_EXP 189
111841: PPUSH
111842: LD_VAR 0 5
111846: PUSH
111847: LD_EXP 189
111851: PUSH
111852: LD_VAR 0 5
111856: ARRAY
111857: PUSH
111858: LD_INT 1
111860: PLUS
111861: PUSH
111862: EMPTY
111863: LIST
111864: LIST
111865: PPUSH
111866: LD_VAR 0 2
111870: PUSH
111871: LD_VAR 0 3
111875: PUSH
111876: EMPTY
111877: LIST
111878: LIST
111879: PPUSH
111880: CALL 57045 0 3
111884: ST_TO_ADDR
// result := true ;
111885: LD_ADDR_VAR 0 4
111889: PUSH
111890: LD_INT 1
111892: ST_TO_ADDR
// end ;
111893: LD_VAR 0 4
111897: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
111898: LD_INT 0
111900: PPUSH
111901: PPUSH
111902: PPUSH
// if not unit in minersList then
111903: LD_VAR 0 1
111907: PUSH
111908: LD_EXP 188
111912: IN
111913: NOT
111914: IFFALSE 111918
// exit ;
111916: GO 112310
// index := GetElementIndex ( minersList , unit ) ;
111918: LD_ADDR_VAR 0 6
111922: PUSH
111923: LD_EXP 188
111927: PPUSH
111928: LD_VAR 0 1
111932: PPUSH
111933: CALL 56830 0 2
111937: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
111938: LD_ADDR_VAR 0 5
111942: PUSH
111943: DOUBLE
111944: LD_EXP 189
111948: PUSH
111949: LD_VAR 0 6
111953: ARRAY
111954: INC
111955: ST_TO_ADDR
111956: LD_INT 1
111958: PUSH
111959: FOR_DOWNTO
111960: IFFALSE 112121
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
111962: LD_EXP 189
111966: PUSH
111967: LD_VAR 0 6
111971: ARRAY
111972: PUSH
111973: LD_VAR 0 5
111977: ARRAY
111978: PUSH
111979: LD_INT 1
111981: ARRAY
111982: PUSH
111983: LD_VAR 0 2
111987: EQUAL
111988: PUSH
111989: LD_EXP 189
111993: PUSH
111994: LD_VAR 0 6
111998: ARRAY
111999: PUSH
112000: LD_VAR 0 5
112004: ARRAY
112005: PUSH
112006: LD_INT 2
112008: ARRAY
112009: PUSH
112010: LD_VAR 0 3
112014: EQUAL
112015: AND
112016: IFFALSE 112119
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112018: LD_EXP 189
112022: PUSH
112023: LD_VAR 0 6
112027: ARRAY
112028: PUSH
112029: LD_VAR 0 5
112033: ARRAY
112034: PUSH
112035: LD_INT 1
112037: ARRAY
112038: PPUSH
112039: LD_EXP 189
112043: PUSH
112044: LD_VAR 0 6
112048: ARRAY
112049: PUSH
112050: LD_VAR 0 5
112054: ARRAY
112055: PUSH
112056: LD_INT 2
112058: ARRAY
112059: PPUSH
112060: LD_VAR 0 1
112064: PPUSH
112065: CALL_OW 255
112069: PPUSH
112070: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112074: LD_ADDR_EXP 189
112078: PUSH
112079: LD_EXP 189
112083: PPUSH
112084: LD_VAR 0 6
112088: PPUSH
112089: LD_EXP 189
112093: PUSH
112094: LD_VAR 0 6
112098: ARRAY
112099: PPUSH
112100: LD_VAR 0 5
112104: PPUSH
112105: CALL_OW 3
112109: PPUSH
112110: CALL_OW 1
112114: ST_TO_ADDR
// exit ;
112115: POP
112116: POP
112117: GO 112310
// end ; end ;
112119: GO 111959
112121: POP
112122: POP
// for i := minerMinesList [ index ] downto 1 do
112123: LD_ADDR_VAR 0 5
112127: PUSH
112128: DOUBLE
112129: LD_EXP 189
112133: PUSH
112134: LD_VAR 0 6
112138: ARRAY
112139: INC
112140: ST_TO_ADDR
112141: LD_INT 1
112143: PUSH
112144: FOR_DOWNTO
112145: IFFALSE 112308
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112147: LD_EXP 189
112151: PUSH
112152: LD_VAR 0 6
112156: ARRAY
112157: PUSH
112158: LD_VAR 0 5
112162: ARRAY
112163: PUSH
112164: LD_INT 1
112166: ARRAY
112167: PPUSH
112168: LD_EXP 189
112172: PUSH
112173: LD_VAR 0 6
112177: ARRAY
112178: PUSH
112179: LD_VAR 0 5
112183: ARRAY
112184: PUSH
112185: LD_INT 2
112187: ARRAY
112188: PPUSH
112189: LD_VAR 0 2
112193: PPUSH
112194: LD_VAR 0 3
112198: PPUSH
112199: CALL_OW 298
112203: PUSH
112204: LD_INT 6
112206: LESS
112207: IFFALSE 112306
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112209: LD_EXP 189
112213: PUSH
112214: LD_VAR 0 6
112218: ARRAY
112219: PUSH
112220: LD_VAR 0 5
112224: ARRAY
112225: PUSH
112226: LD_INT 1
112228: ARRAY
112229: PPUSH
112230: LD_EXP 189
112234: PUSH
112235: LD_VAR 0 6
112239: ARRAY
112240: PUSH
112241: LD_VAR 0 5
112245: ARRAY
112246: PUSH
112247: LD_INT 2
112249: ARRAY
112250: PPUSH
112251: LD_VAR 0 1
112255: PPUSH
112256: CALL_OW 255
112260: PPUSH
112261: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112265: LD_ADDR_EXP 189
112269: PUSH
112270: LD_EXP 189
112274: PPUSH
112275: LD_VAR 0 6
112279: PPUSH
112280: LD_EXP 189
112284: PUSH
112285: LD_VAR 0 6
112289: ARRAY
112290: PPUSH
112291: LD_VAR 0 5
112295: PPUSH
112296: CALL_OW 3
112300: PPUSH
112301: CALL_OW 1
112305: ST_TO_ADDR
// end ; end ;
112306: GO 112144
112308: POP
112309: POP
// end ;
112310: LD_VAR 0 4
112314: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112315: LD_INT 0
112317: PPUSH
112318: PPUSH
112319: PPUSH
112320: PPUSH
112321: PPUSH
112322: PPUSH
112323: PPUSH
112324: PPUSH
112325: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112326: LD_VAR 0 1
112330: PPUSH
112331: CALL_OW 264
112335: PUSH
112336: LD_INT 81
112338: EQUAL
112339: NOT
112340: PUSH
112341: LD_VAR 0 1
112345: PUSH
112346: LD_EXP 188
112350: IN
112351: NOT
112352: OR
112353: IFFALSE 112357
// exit ;
112355: GO 112679
// index := GetElementIndex ( minersList , unit ) ;
112357: LD_ADDR_VAR 0 6
112361: PUSH
112362: LD_EXP 188
112366: PPUSH
112367: LD_VAR 0 1
112371: PPUSH
112372: CALL 56830 0 2
112376: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112377: LD_ADDR_VAR 0 8
112381: PUSH
112382: LD_EXP 190
112386: PUSH
112387: LD_EXP 189
112391: PUSH
112392: LD_VAR 0 6
112396: ARRAY
112397: MINUS
112398: ST_TO_ADDR
// if not minesFreeAmount then
112399: LD_VAR 0 8
112403: NOT
112404: IFFALSE 112408
// exit ;
112406: GO 112679
// tmp := [ ] ;
112408: LD_ADDR_VAR 0 7
112412: PUSH
112413: EMPTY
112414: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112415: LD_ADDR_VAR 0 5
112419: PUSH
112420: DOUBLE
112421: LD_INT 1
112423: DEC
112424: ST_TO_ADDR
112425: LD_VAR 0 8
112429: PUSH
112430: FOR_TO
112431: IFFALSE 112626
// begin _d := rand ( 0 , 5 ) ;
112433: LD_ADDR_VAR 0 11
112437: PUSH
112438: LD_INT 0
112440: PPUSH
112441: LD_INT 5
112443: PPUSH
112444: CALL_OW 12
112448: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112449: LD_ADDR_VAR 0 12
112453: PUSH
112454: LD_INT 2
112456: PPUSH
112457: LD_INT 6
112459: PPUSH
112460: CALL_OW 12
112464: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112465: LD_ADDR_VAR 0 9
112469: PUSH
112470: LD_VAR 0 2
112474: PPUSH
112475: LD_VAR 0 11
112479: PPUSH
112480: LD_VAR 0 12
112484: PPUSH
112485: CALL_OW 272
112489: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112490: LD_ADDR_VAR 0 10
112494: PUSH
112495: LD_VAR 0 3
112499: PPUSH
112500: LD_VAR 0 11
112504: PPUSH
112505: LD_VAR 0 12
112509: PPUSH
112510: CALL_OW 273
112514: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112515: LD_VAR 0 9
112519: PPUSH
112520: LD_VAR 0 10
112524: PPUSH
112525: CALL_OW 488
112529: PUSH
112530: LD_VAR 0 9
112534: PUSH
112535: LD_VAR 0 10
112539: PUSH
112540: EMPTY
112541: LIST
112542: LIST
112543: PUSH
112544: LD_VAR 0 7
112548: IN
112549: NOT
112550: AND
112551: PUSH
112552: LD_VAR 0 9
112556: PPUSH
112557: LD_VAR 0 10
112561: PPUSH
112562: CALL_OW 458
112566: NOT
112567: AND
112568: IFFALSE 112610
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112570: LD_ADDR_VAR 0 7
112574: PUSH
112575: LD_VAR 0 7
112579: PPUSH
112580: LD_VAR 0 7
112584: PUSH
112585: LD_INT 1
112587: PLUS
112588: PPUSH
112589: LD_VAR 0 9
112593: PUSH
112594: LD_VAR 0 10
112598: PUSH
112599: EMPTY
112600: LIST
112601: LIST
112602: PPUSH
112603: CALL_OW 1
112607: ST_TO_ADDR
112608: GO 112624
// i := i - 1 ;
112610: LD_ADDR_VAR 0 5
112614: PUSH
112615: LD_VAR 0 5
112619: PUSH
112620: LD_INT 1
112622: MINUS
112623: ST_TO_ADDR
// end ;
112624: GO 112430
112626: POP
112627: POP
// for i in tmp do
112628: LD_ADDR_VAR 0 5
112632: PUSH
112633: LD_VAR 0 7
112637: PUSH
112638: FOR_IN
112639: IFFALSE 112677
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112641: LD_VAR 0 1
112645: PPUSH
112646: LD_VAR 0 5
112650: PUSH
112651: LD_INT 1
112653: ARRAY
112654: PPUSH
112655: LD_VAR 0 5
112659: PUSH
112660: LD_INT 2
112662: ARRAY
112663: PPUSH
112664: CALL 111623 0 3
112668: NOT
112669: IFFALSE 112675
// exit ;
112671: POP
112672: POP
112673: GO 112679
112675: GO 112638
112677: POP
112678: POP
// end ;
112679: LD_VAR 0 4
112683: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
112684: LD_INT 0
112686: PPUSH
112687: PPUSH
112688: PPUSH
112689: PPUSH
112690: PPUSH
112691: PPUSH
112692: PPUSH
// if not GetClass ( unit ) = class_sniper then
112693: LD_VAR 0 1
112697: PPUSH
112698: CALL_OW 257
112702: PUSH
112703: LD_INT 5
112705: EQUAL
112706: NOT
112707: IFFALSE 112711
// exit ;
112709: GO 113099
// dist := 8 ;
112711: LD_ADDR_VAR 0 5
112715: PUSH
112716: LD_INT 8
112718: ST_TO_ADDR
// viewRange := 12 ;
112719: LD_ADDR_VAR 0 7
112723: PUSH
112724: LD_INT 12
112726: ST_TO_ADDR
// side := GetSide ( unit ) ;
112727: LD_ADDR_VAR 0 6
112731: PUSH
112732: LD_VAR 0 1
112736: PPUSH
112737: CALL_OW 255
112741: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112742: LD_INT 61
112744: PPUSH
112745: LD_VAR 0 6
112749: PPUSH
112750: CALL_OW 321
112754: PUSH
112755: LD_INT 2
112757: EQUAL
112758: IFFALSE 112768
// viewRange := 16 ;
112760: LD_ADDR_VAR 0 7
112764: PUSH
112765: LD_INT 16
112767: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112768: LD_VAR 0 1
112772: PPUSH
112773: LD_VAR 0 2
112777: PPUSH
112778: LD_VAR 0 3
112782: PPUSH
112783: CALL_OW 297
112787: PUSH
112788: LD_VAR 0 5
112792: GREATER
112793: IFFALSE 112872
// begin ComMoveXY ( unit , x , y ) ;
112795: LD_VAR 0 1
112799: PPUSH
112800: LD_VAR 0 2
112804: PPUSH
112805: LD_VAR 0 3
112809: PPUSH
112810: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112814: LD_INT 35
112816: PPUSH
112817: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
112821: LD_VAR 0 1
112825: PPUSH
112826: LD_VAR 0 2
112830: PPUSH
112831: LD_VAR 0 3
112835: PPUSH
112836: CALL 88166 0 3
112840: NOT
112841: IFFALSE 112845
// exit ;
112843: GO 113099
// until GetDistUnitXY ( unit , x , y ) < dist ;
112845: LD_VAR 0 1
112849: PPUSH
112850: LD_VAR 0 2
112854: PPUSH
112855: LD_VAR 0 3
112859: PPUSH
112860: CALL_OW 297
112864: PUSH
112865: LD_VAR 0 5
112869: LESS
112870: IFFALSE 112814
// end ; ComTurnXY ( unit , x , y ) ;
112872: LD_VAR 0 1
112876: PPUSH
112877: LD_VAR 0 2
112881: PPUSH
112882: LD_VAR 0 3
112886: PPUSH
112887: CALL_OW 118
// wait ( 5 ) ;
112891: LD_INT 5
112893: PPUSH
112894: CALL_OW 67
// _d := GetDir ( unit ) ;
112898: LD_ADDR_VAR 0 10
112902: PUSH
112903: LD_VAR 0 1
112907: PPUSH
112908: CALL_OW 254
112912: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
112913: LD_ADDR_VAR 0 8
112917: PUSH
112918: LD_VAR 0 1
112922: PPUSH
112923: CALL_OW 250
112927: PPUSH
112928: LD_VAR 0 10
112932: PPUSH
112933: LD_VAR 0 5
112937: PPUSH
112938: CALL_OW 272
112942: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
112943: LD_ADDR_VAR 0 9
112947: PUSH
112948: LD_VAR 0 1
112952: PPUSH
112953: CALL_OW 251
112957: PPUSH
112958: LD_VAR 0 10
112962: PPUSH
112963: LD_VAR 0 5
112967: PPUSH
112968: CALL_OW 273
112972: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
112973: LD_VAR 0 8
112977: PPUSH
112978: LD_VAR 0 9
112982: PPUSH
112983: CALL_OW 488
112987: NOT
112988: IFFALSE 112992
// exit ;
112990: GO 113099
// ComAnimCustom ( unit , 1 ) ;
112992: LD_VAR 0 1
112996: PPUSH
112997: LD_INT 1
112999: PPUSH
113000: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113004: LD_VAR 0 8
113008: PPUSH
113009: LD_VAR 0 9
113013: PPUSH
113014: LD_VAR 0 6
113018: PPUSH
113019: LD_VAR 0 7
113023: PPUSH
113024: CALL_OW 330
// repeat wait ( 1 ) ;
113028: LD_INT 1
113030: PPUSH
113031: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
113035: LD_VAR 0 1
113039: PPUSH
113040: CALL_OW 316
113044: PUSH
113045: LD_VAR 0 1
113049: PPUSH
113050: CALL_OW 314
113054: OR
113055: PUSH
113056: LD_VAR 0 1
113060: PPUSH
113061: CALL_OW 302
113065: NOT
113066: OR
113067: PUSH
113068: LD_VAR 0 1
113072: PPUSH
113073: CALL_OW 301
113077: OR
113078: IFFALSE 113028
// RemoveSeeing ( _x , _y , side ) ;
113080: LD_VAR 0 8
113084: PPUSH
113085: LD_VAR 0 9
113089: PPUSH
113090: LD_VAR 0 6
113094: PPUSH
113095: CALL_OW 331
// end ; end_of_file
113099: LD_VAR 0 4
113103: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
113104: LD_INT 0
113106: PPUSH
113107: PPUSH
113108: PPUSH
113109: PPUSH
113110: PPUSH
113111: PPUSH
113112: PPUSH
113113: PPUSH
113114: PPUSH
113115: PPUSH
113116: PPUSH
113117: PPUSH
113118: PPUSH
113119: PPUSH
113120: PPUSH
113121: PPUSH
113122: PPUSH
113123: PPUSH
113124: PPUSH
113125: PPUSH
113126: PPUSH
113127: PPUSH
113128: PPUSH
113129: PPUSH
113130: PPUSH
113131: PPUSH
113132: PPUSH
113133: PPUSH
113134: PPUSH
113135: PPUSH
113136: PPUSH
113137: PPUSH
113138: PPUSH
113139: PPUSH
// if not list then
113140: LD_VAR 0 1
113144: NOT
113145: IFFALSE 113149
// exit ;
113147: GO 117808
// base := list [ 1 ] ;
113149: LD_ADDR_VAR 0 3
113153: PUSH
113154: LD_VAR 0 1
113158: PUSH
113159: LD_INT 1
113161: ARRAY
113162: ST_TO_ADDR
// group := list [ 2 ] ;
113163: LD_ADDR_VAR 0 4
113167: PUSH
113168: LD_VAR 0 1
113172: PUSH
113173: LD_INT 2
113175: ARRAY
113176: ST_TO_ADDR
// path := list [ 3 ] ;
113177: LD_ADDR_VAR 0 5
113181: PUSH
113182: LD_VAR 0 1
113186: PUSH
113187: LD_INT 3
113189: ARRAY
113190: ST_TO_ADDR
// flags := list [ 4 ] ;
113191: LD_ADDR_VAR 0 6
113195: PUSH
113196: LD_VAR 0 1
113200: PUSH
113201: LD_INT 4
113203: ARRAY
113204: ST_TO_ADDR
// mined := [ ] ;
113205: LD_ADDR_VAR 0 27
113209: PUSH
113210: EMPTY
113211: ST_TO_ADDR
// bombed := [ ] ;
113212: LD_ADDR_VAR 0 28
113216: PUSH
113217: EMPTY
113218: ST_TO_ADDR
// healers := [ ] ;
113219: LD_ADDR_VAR 0 31
113223: PUSH
113224: EMPTY
113225: ST_TO_ADDR
// to_heal := [ ] ;
113226: LD_ADDR_VAR 0 30
113230: PUSH
113231: EMPTY
113232: ST_TO_ADDR
// repairs := [ ] ;
113233: LD_ADDR_VAR 0 33
113237: PUSH
113238: EMPTY
113239: ST_TO_ADDR
// to_repair := [ ] ;
113240: LD_ADDR_VAR 0 32
113244: PUSH
113245: EMPTY
113246: ST_TO_ADDR
// if not group or not path then
113247: LD_VAR 0 4
113251: NOT
113252: PUSH
113253: LD_VAR 0 5
113257: NOT
113258: OR
113259: IFFALSE 113263
// exit ;
113261: GO 117808
// side := GetSide ( group [ 1 ] ) ;
113263: LD_ADDR_VAR 0 35
113267: PUSH
113268: LD_VAR 0 4
113272: PUSH
113273: LD_INT 1
113275: ARRAY
113276: PPUSH
113277: CALL_OW 255
113281: ST_TO_ADDR
// if flags then
113282: LD_VAR 0 6
113286: IFFALSE 113430
// begin f_ignore_area := flags [ 1 ] ;
113288: LD_ADDR_VAR 0 17
113292: PUSH
113293: LD_VAR 0 6
113297: PUSH
113298: LD_INT 1
113300: ARRAY
113301: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
113302: LD_ADDR_VAR 0 18
113306: PUSH
113307: LD_VAR 0 6
113311: PUSH
113312: LD_INT 2
113314: ARRAY
113315: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
113316: LD_ADDR_VAR 0 19
113320: PUSH
113321: LD_VAR 0 6
113325: PUSH
113326: LD_INT 3
113328: ARRAY
113329: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
113330: LD_ADDR_VAR 0 20
113334: PUSH
113335: LD_VAR 0 6
113339: PUSH
113340: LD_INT 4
113342: ARRAY
113343: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
113344: LD_ADDR_VAR 0 21
113348: PUSH
113349: LD_VAR 0 6
113353: PUSH
113354: LD_INT 5
113356: ARRAY
113357: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
113358: LD_ADDR_VAR 0 22
113362: PUSH
113363: LD_VAR 0 6
113367: PUSH
113368: LD_INT 6
113370: ARRAY
113371: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
113372: LD_ADDR_VAR 0 23
113376: PUSH
113377: LD_VAR 0 6
113381: PUSH
113382: LD_INT 7
113384: ARRAY
113385: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
113386: LD_ADDR_VAR 0 24
113390: PUSH
113391: LD_VAR 0 6
113395: PUSH
113396: LD_INT 8
113398: ARRAY
113399: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
113400: LD_ADDR_VAR 0 25
113404: PUSH
113405: LD_VAR 0 6
113409: PUSH
113410: LD_INT 9
113412: ARRAY
113413: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
113414: LD_ADDR_VAR 0 26
113418: PUSH
113419: LD_VAR 0 6
113423: PUSH
113424: LD_INT 10
113426: ARRAY
113427: ST_TO_ADDR
// end else
113428: GO 113510
// begin f_ignore_area := false ;
113430: LD_ADDR_VAR 0 17
113434: PUSH
113435: LD_INT 0
113437: ST_TO_ADDR
// f_capture := false ;
113438: LD_ADDR_VAR 0 18
113442: PUSH
113443: LD_INT 0
113445: ST_TO_ADDR
// f_ignore_civ := false ;
113446: LD_ADDR_VAR 0 19
113450: PUSH
113451: LD_INT 0
113453: ST_TO_ADDR
// f_murder := false ;
113454: LD_ADDR_VAR 0 20
113458: PUSH
113459: LD_INT 0
113461: ST_TO_ADDR
// f_mines := false ;
113462: LD_ADDR_VAR 0 21
113466: PUSH
113467: LD_INT 0
113469: ST_TO_ADDR
// f_repair := false ;
113470: LD_ADDR_VAR 0 22
113474: PUSH
113475: LD_INT 0
113477: ST_TO_ADDR
// f_heal := false ;
113478: LD_ADDR_VAR 0 23
113482: PUSH
113483: LD_INT 0
113485: ST_TO_ADDR
// f_spacetime := false ;
113486: LD_ADDR_VAR 0 24
113490: PUSH
113491: LD_INT 0
113493: ST_TO_ADDR
// f_attack_depot := false ;
113494: LD_ADDR_VAR 0 25
113498: PUSH
113499: LD_INT 0
113501: ST_TO_ADDR
// f_crawl := false ;
113502: LD_ADDR_VAR 0 26
113506: PUSH
113507: LD_INT 0
113509: ST_TO_ADDR
// end ; if f_heal then
113510: LD_VAR 0 23
113514: IFFALSE 113541
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113516: LD_ADDR_VAR 0 31
113520: PUSH
113521: LD_VAR 0 4
113525: PPUSH
113526: LD_INT 25
113528: PUSH
113529: LD_INT 4
113531: PUSH
113532: EMPTY
113533: LIST
113534: LIST
113535: PPUSH
113536: CALL_OW 72
113540: ST_TO_ADDR
// if f_repair then
113541: LD_VAR 0 22
113545: IFFALSE 113572
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113547: LD_ADDR_VAR 0 33
113551: PUSH
113552: LD_VAR 0 4
113556: PPUSH
113557: LD_INT 25
113559: PUSH
113560: LD_INT 3
113562: PUSH
113563: EMPTY
113564: LIST
113565: LIST
113566: PPUSH
113567: CALL_OW 72
113571: ST_TO_ADDR
// units_path := [ ] ;
113572: LD_ADDR_VAR 0 16
113576: PUSH
113577: EMPTY
113578: ST_TO_ADDR
// for i = 1 to group do
113579: LD_ADDR_VAR 0 7
113583: PUSH
113584: DOUBLE
113585: LD_INT 1
113587: DEC
113588: ST_TO_ADDR
113589: LD_VAR 0 4
113593: PUSH
113594: FOR_TO
113595: IFFALSE 113624
// units_path := Replace ( units_path , i , path ) ;
113597: LD_ADDR_VAR 0 16
113601: PUSH
113602: LD_VAR 0 16
113606: PPUSH
113607: LD_VAR 0 7
113611: PPUSH
113612: LD_VAR 0 5
113616: PPUSH
113617: CALL_OW 1
113621: ST_TO_ADDR
113622: GO 113594
113624: POP
113625: POP
// repeat for i = group downto 1 do
113626: LD_ADDR_VAR 0 7
113630: PUSH
113631: DOUBLE
113632: LD_VAR 0 4
113636: INC
113637: ST_TO_ADDR
113638: LD_INT 1
113640: PUSH
113641: FOR_DOWNTO
113642: IFFALSE 117764
// begin wait ( 5 ) ;
113644: LD_INT 5
113646: PPUSH
113647: CALL_OW 67
// tmp := [ ] ;
113651: LD_ADDR_VAR 0 14
113655: PUSH
113656: EMPTY
113657: ST_TO_ADDR
// attacking := false ;
113658: LD_ADDR_VAR 0 29
113662: PUSH
113663: LD_INT 0
113665: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113666: LD_VAR 0 4
113670: PUSH
113671: LD_VAR 0 7
113675: ARRAY
113676: PPUSH
113677: CALL_OW 301
113681: PUSH
113682: LD_VAR 0 4
113686: PUSH
113687: LD_VAR 0 7
113691: ARRAY
113692: NOT
113693: OR
113694: IFFALSE 113803
// begin if GetType ( group [ i ] ) = unit_human then
113696: LD_VAR 0 4
113700: PUSH
113701: LD_VAR 0 7
113705: ARRAY
113706: PPUSH
113707: CALL_OW 247
113711: PUSH
113712: LD_INT 1
113714: EQUAL
113715: IFFALSE 113761
// begin to_heal := to_heal diff group [ i ] ;
113717: LD_ADDR_VAR 0 30
113721: PUSH
113722: LD_VAR 0 30
113726: PUSH
113727: LD_VAR 0 4
113731: PUSH
113732: LD_VAR 0 7
113736: ARRAY
113737: DIFF
113738: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113739: LD_ADDR_VAR 0 31
113743: PUSH
113744: LD_VAR 0 31
113748: PUSH
113749: LD_VAR 0 4
113753: PUSH
113754: LD_VAR 0 7
113758: ARRAY
113759: DIFF
113760: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113761: LD_ADDR_VAR 0 4
113765: PUSH
113766: LD_VAR 0 4
113770: PPUSH
113771: LD_VAR 0 7
113775: PPUSH
113776: CALL_OW 3
113780: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113781: LD_ADDR_VAR 0 16
113785: PUSH
113786: LD_VAR 0 16
113790: PPUSH
113791: LD_VAR 0 7
113795: PPUSH
113796: CALL_OW 3
113800: ST_TO_ADDR
// continue ;
113801: GO 113641
// end ; if f_repair then
113803: LD_VAR 0 22
113807: IFFALSE 114296
// begin if GetType ( group [ i ] ) = unit_vehicle then
113809: LD_VAR 0 4
113813: PUSH
113814: LD_VAR 0 7
113818: ARRAY
113819: PPUSH
113820: CALL_OW 247
113824: PUSH
113825: LD_INT 2
113827: EQUAL
113828: IFFALSE 114018
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113830: LD_VAR 0 4
113834: PUSH
113835: LD_VAR 0 7
113839: ARRAY
113840: PPUSH
113841: CALL_OW 256
113845: PUSH
113846: LD_INT 700
113848: LESS
113849: PUSH
113850: LD_VAR 0 4
113854: PUSH
113855: LD_VAR 0 7
113859: ARRAY
113860: PUSH
113861: LD_VAR 0 32
113865: IN
113866: NOT
113867: AND
113868: IFFALSE 113892
// to_repair := to_repair union group [ i ] ;
113870: LD_ADDR_VAR 0 32
113874: PUSH
113875: LD_VAR 0 32
113879: PUSH
113880: LD_VAR 0 4
113884: PUSH
113885: LD_VAR 0 7
113889: ARRAY
113890: UNION
113891: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113892: LD_VAR 0 4
113896: PUSH
113897: LD_VAR 0 7
113901: ARRAY
113902: PPUSH
113903: CALL_OW 256
113907: PUSH
113908: LD_INT 1000
113910: EQUAL
113911: PUSH
113912: LD_VAR 0 4
113916: PUSH
113917: LD_VAR 0 7
113921: ARRAY
113922: PUSH
113923: LD_VAR 0 32
113927: IN
113928: AND
113929: IFFALSE 113953
// to_repair := to_repair diff group [ i ] ;
113931: LD_ADDR_VAR 0 32
113935: PUSH
113936: LD_VAR 0 32
113940: PUSH
113941: LD_VAR 0 4
113945: PUSH
113946: LD_VAR 0 7
113950: ARRAY
113951: DIFF
113952: ST_TO_ADDR
// if group [ i ] in to_repair then
113953: LD_VAR 0 4
113957: PUSH
113958: LD_VAR 0 7
113962: ARRAY
113963: PUSH
113964: LD_VAR 0 32
113968: IN
113969: IFFALSE 114016
// begin if not IsInArea ( group [ i ] , f_repair ) then
113971: LD_VAR 0 4
113975: PUSH
113976: LD_VAR 0 7
113980: ARRAY
113981: PPUSH
113982: LD_VAR 0 22
113986: PPUSH
113987: CALL_OW 308
113991: NOT
113992: IFFALSE 114014
// ComMoveToArea ( group [ i ] , f_repair ) ;
113994: LD_VAR 0 4
113998: PUSH
113999: LD_VAR 0 7
114003: ARRAY
114004: PPUSH
114005: LD_VAR 0 22
114009: PPUSH
114010: CALL_OW 113
// continue ;
114014: GO 113641
// end ; end else
114016: GO 114296
// if group [ i ] in repairs then
114018: LD_VAR 0 4
114022: PUSH
114023: LD_VAR 0 7
114027: ARRAY
114028: PUSH
114029: LD_VAR 0 33
114033: IN
114034: IFFALSE 114296
// begin if IsInUnit ( group [ i ] ) then
114036: LD_VAR 0 4
114040: PUSH
114041: LD_VAR 0 7
114045: ARRAY
114046: PPUSH
114047: CALL_OW 310
114051: IFFALSE 114119
// begin z := IsInUnit ( group [ i ] ) ;
114053: LD_ADDR_VAR 0 13
114057: PUSH
114058: LD_VAR 0 4
114062: PUSH
114063: LD_VAR 0 7
114067: ARRAY
114068: PPUSH
114069: CALL_OW 310
114073: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
114074: LD_VAR 0 13
114078: PUSH
114079: LD_VAR 0 32
114083: IN
114084: PUSH
114085: LD_VAR 0 13
114089: PPUSH
114090: LD_VAR 0 22
114094: PPUSH
114095: CALL_OW 308
114099: AND
114100: IFFALSE 114117
// ComExitVehicle ( group [ i ] ) ;
114102: LD_VAR 0 4
114106: PUSH
114107: LD_VAR 0 7
114111: ARRAY
114112: PPUSH
114113: CALL_OW 121
// end else
114117: GO 114296
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
114119: LD_ADDR_VAR 0 13
114123: PUSH
114124: LD_VAR 0 4
114128: PPUSH
114129: LD_INT 95
114131: PUSH
114132: LD_VAR 0 22
114136: PUSH
114137: EMPTY
114138: LIST
114139: LIST
114140: PUSH
114141: LD_INT 58
114143: PUSH
114144: EMPTY
114145: LIST
114146: PUSH
114147: EMPTY
114148: LIST
114149: LIST
114150: PPUSH
114151: CALL_OW 72
114155: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
114156: LD_VAR 0 4
114160: PUSH
114161: LD_VAR 0 7
114165: ARRAY
114166: PPUSH
114167: CALL_OW 314
114171: NOT
114172: IFFALSE 114294
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
114174: LD_ADDR_VAR 0 10
114178: PUSH
114179: LD_VAR 0 13
114183: PPUSH
114184: LD_VAR 0 4
114188: PUSH
114189: LD_VAR 0 7
114193: ARRAY
114194: PPUSH
114195: CALL_OW 74
114199: ST_TO_ADDR
// if not x then
114200: LD_VAR 0 10
114204: NOT
114205: IFFALSE 114209
// continue ;
114207: GO 113641
// if GetLives ( x ) < 1000 then
114209: LD_VAR 0 10
114213: PPUSH
114214: CALL_OW 256
114218: PUSH
114219: LD_INT 1000
114221: LESS
114222: IFFALSE 114246
// ComRepairVehicle ( group [ i ] , x ) else
114224: LD_VAR 0 4
114228: PUSH
114229: LD_VAR 0 7
114233: ARRAY
114234: PPUSH
114235: LD_VAR 0 10
114239: PPUSH
114240: CALL_OW 129
114244: GO 114294
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
114246: LD_VAR 0 23
114250: PUSH
114251: LD_VAR 0 4
114255: PUSH
114256: LD_VAR 0 7
114260: ARRAY
114261: PPUSH
114262: CALL_OW 256
114266: PUSH
114267: LD_INT 1000
114269: LESS
114270: AND
114271: NOT
114272: IFFALSE 114294
// ComEnterUnit ( group [ i ] , x ) ;
114274: LD_VAR 0 4
114278: PUSH
114279: LD_VAR 0 7
114283: ARRAY
114284: PPUSH
114285: LD_VAR 0 10
114289: PPUSH
114290: CALL_OW 120
// end ; continue ;
114294: GO 113641
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
114296: LD_VAR 0 23
114300: PUSH
114301: LD_VAR 0 4
114305: PUSH
114306: LD_VAR 0 7
114310: ARRAY
114311: PPUSH
114312: CALL_OW 247
114316: PUSH
114317: LD_INT 1
114319: EQUAL
114320: AND
114321: IFFALSE 114799
// begin if group [ i ] in healers then
114323: LD_VAR 0 4
114327: PUSH
114328: LD_VAR 0 7
114332: ARRAY
114333: PUSH
114334: LD_VAR 0 31
114338: IN
114339: IFFALSE 114612
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
114341: LD_VAR 0 4
114345: PUSH
114346: LD_VAR 0 7
114350: ARRAY
114351: PPUSH
114352: LD_VAR 0 23
114356: PPUSH
114357: CALL_OW 308
114361: NOT
114362: PUSH
114363: LD_VAR 0 4
114367: PUSH
114368: LD_VAR 0 7
114372: ARRAY
114373: PPUSH
114374: CALL_OW 314
114378: NOT
114379: AND
114380: IFFALSE 114404
// ComMoveToArea ( group [ i ] , f_heal ) else
114382: LD_VAR 0 4
114386: PUSH
114387: LD_VAR 0 7
114391: ARRAY
114392: PPUSH
114393: LD_VAR 0 23
114397: PPUSH
114398: CALL_OW 113
114402: GO 114610
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
114404: LD_VAR 0 4
114408: PUSH
114409: LD_VAR 0 7
114413: ARRAY
114414: PPUSH
114415: CALL 86742 0 1
114419: PPUSH
114420: CALL_OW 256
114424: PUSH
114425: LD_INT 1000
114427: EQUAL
114428: IFFALSE 114447
// ComStop ( group [ i ] ) else
114430: LD_VAR 0 4
114434: PUSH
114435: LD_VAR 0 7
114439: ARRAY
114440: PPUSH
114441: CALL_OW 141
114445: GO 114610
// if not HasTask ( group [ i ] ) and to_heal then
114447: LD_VAR 0 4
114451: PUSH
114452: LD_VAR 0 7
114456: ARRAY
114457: PPUSH
114458: CALL_OW 314
114462: NOT
114463: PUSH
114464: LD_VAR 0 30
114468: AND
114469: IFFALSE 114610
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114471: LD_ADDR_VAR 0 13
114475: PUSH
114476: LD_VAR 0 30
114480: PPUSH
114481: LD_INT 3
114483: PUSH
114484: LD_INT 54
114486: PUSH
114487: EMPTY
114488: LIST
114489: PUSH
114490: EMPTY
114491: LIST
114492: LIST
114493: PPUSH
114494: CALL_OW 72
114498: PPUSH
114499: LD_VAR 0 4
114503: PUSH
114504: LD_VAR 0 7
114508: ARRAY
114509: PPUSH
114510: CALL_OW 74
114514: ST_TO_ADDR
// if z then
114515: LD_VAR 0 13
114519: IFFALSE 114610
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114521: LD_INT 91
114523: PUSH
114524: LD_VAR 0 13
114528: PUSH
114529: LD_INT 10
114531: PUSH
114532: EMPTY
114533: LIST
114534: LIST
114535: LIST
114536: PUSH
114537: LD_INT 81
114539: PUSH
114540: LD_VAR 0 13
114544: PPUSH
114545: CALL_OW 255
114549: PUSH
114550: EMPTY
114551: LIST
114552: LIST
114553: PUSH
114554: EMPTY
114555: LIST
114556: LIST
114557: PPUSH
114558: CALL_OW 69
114562: PUSH
114563: LD_INT 0
114565: EQUAL
114566: IFFALSE 114590
// ComHeal ( group [ i ] , z ) else
114568: LD_VAR 0 4
114572: PUSH
114573: LD_VAR 0 7
114577: ARRAY
114578: PPUSH
114579: LD_VAR 0 13
114583: PPUSH
114584: CALL_OW 128
114588: GO 114610
// ComMoveToArea ( group [ i ] , f_heal ) ;
114590: LD_VAR 0 4
114594: PUSH
114595: LD_VAR 0 7
114599: ARRAY
114600: PPUSH
114601: LD_VAR 0 23
114605: PPUSH
114606: CALL_OW 113
// end ; continue ;
114610: GO 113641
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114612: LD_VAR 0 4
114616: PUSH
114617: LD_VAR 0 7
114621: ARRAY
114622: PPUSH
114623: CALL_OW 256
114627: PUSH
114628: LD_INT 700
114630: LESS
114631: PUSH
114632: LD_VAR 0 4
114636: PUSH
114637: LD_VAR 0 7
114641: ARRAY
114642: PUSH
114643: LD_VAR 0 30
114647: IN
114648: NOT
114649: AND
114650: IFFALSE 114674
// to_heal := to_heal union group [ i ] ;
114652: LD_ADDR_VAR 0 30
114656: PUSH
114657: LD_VAR 0 30
114661: PUSH
114662: LD_VAR 0 4
114666: PUSH
114667: LD_VAR 0 7
114671: ARRAY
114672: UNION
114673: ST_TO_ADDR
// if group [ i ] in to_heal then
114674: LD_VAR 0 4
114678: PUSH
114679: LD_VAR 0 7
114683: ARRAY
114684: PUSH
114685: LD_VAR 0 30
114689: IN
114690: IFFALSE 114799
// begin if GetLives ( group [ i ] ) = 1000 then
114692: LD_VAR 0 4
114696: PUSH
114697: LD_VAR 0 7
114701: ARRAY
114702: PPUSH
114703: CALL_OW 256
114707: PUSH
114708: LD_INT 1000
114710: EQUAL
114711: IFFALSE 114737
// to_heal := to_heal diff group [ i ] else
114713: LD_ADDR_VAR 0 30
114717: PUSH
114718: LD_VAR 0 30
114722: PUSH
114723: LD_VAR 0 4
114727: PUSH
114728: LD_VAR 0 7
114732: ARRAY
114733: DIFF
114734: ST_TO_ADDR
114735: GO 114799
// begin if not IsInArea ( group [ i ] , to_heal ) then
114737: LD_VAR 0 4
114741: PUSH
114742: LD_VAR 0 7
114746: ARRAY
114747: PPUSH
114748: LD_VAR 0 30
114752: PPUSH
114753: CALL_OW 308
114757: NOT
114758: IFFALSE 114782
// ComMoveToArea ( group [ i ] , f_heal ) else
114760: LD_VAR 0 4
114764: PUSH
114765: LD_VAR 0 7
114769: ARRAY
114770: PPUSH
114771: LD_VAR 0 23
114775: PPUSH
114776: CALL_OW 113
114780: GO 114797
// ComHold ( group [ i ] ) ;
114782: LD_VAR 0 4
114786: PUSH
114787: LD_VAR 0 7
114791: ARRAY
114792: PPUSH
114793: CALL_OW 140
// continue ;
114797: GO 113641
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114799: LD_VAR 0 4
114803: PUSH
114804: LD_VAR 0 7
114808: ARRAY
114809: PPUSH
114810: LD_INT 10
114812: PPUSH
114813: CALL 84539 0 2
114817: NOT
114818: PUSH
114819: LD_VAR 0 16
114823: PUSH
114824: LD_VAR 0 7
114828: ARRAY
114829: PUSH
114830: EMPTY
114831: EQUAL
114832: NOT
114833: AND
114834: IFFALSE 115100
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114836: LD_VAR 0 4
114840: PUSH
114841: LD_VAR 0 7
114845: ARRAY
114846: PPUSH
114847: CALL_OW 262
114851: PUSH
114852: LD_INT 1
114854: PUSH
114855: LD_INT 2
114857: PUSH
114858: EMPTY
114859: LIST
114860: LIST
114861: IN
114862: IFFALSE 114903
// if GetFuel ( group [ i ] ) < 10 then
114864: LD_VAR 0 4
114868: PUSH
114869: LD_VAR 0 7
114873: ARRAY
114874: PPUSH
114875: CALL_OW 261
114879: PUSH
114880: LD_INT 10
114882: LESS
114883: IFFALSE 114903
// SetFuel ( group [ i ] , 12 ) ;
114885: LD_VAR 0 4
114889: PUSH
114890: LD_VAR 0 7
114894: ARRAY
114895: PPUSH
114896: LD_INT 12
114898: PPUSH
114899: CALL_OW 240
// if units_path [ i ] then
114903: LD_VAR 0 16
114907: PUSH
114908: LD_VAR 0 7
114912: ARRAY
114913: IFFALSE 115098
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114915: LD_VAR 0 4
114919: PUSH
114920: LD_VAR 0 7
114924: ARRAY
114925: PPUSH
114926: LD_VAR 0 16
114930: PUSH
114931: LD_VAR 0 7
114935: ARRAY
114936: PUSH
114937: LD_INT 1
114939: ARRAY
114940: PUSH
114941: LD_INT 1
114943: ARRAY
114944: PPUSH
114945: LD_VAR 0 16
114949: PUSH
114950: LD_VAR 0 7
114954: ARRAY
114955: PUSH
114956: LD_INT 1
114958: ARRAY
114959: PUSH
114960: LD_INT 2
114962: ARRAY
114963: PPUSH
114964: CALL_OW 297
114968: PUSH
114969: LD_INT 6
114971: GREATER
114972: IFFALSE 115047
// begin if not HasTask ( group [ i ] ) then
114974: LD_VAR 0 4
114978: PUSH
114979: LD_VAR 0 7
114983: ARRAY
114984: PPUSH
114985: CALL_OW 314
114989: NOT
114990: IFFALSE 115045
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114992: LD_VAR 0 4
114996: PUSH
114997: LD_VAR 0 7
115001: ARRAY
115002: PPUSH
115003: LD_VAR 0 16
115007: PUSH
115008: LD_VAR 0 7
115012: ARRAY
115013: PUSH
115014: LD_INT 1
115016: ARRAY
115017: PUSH
115018: LD_INT 1
115020: ARRAY
115021: PPUSH
115022: LD_VAR 0 16
115026: PUSH
115027: LD_VAR 0 7
115031: ARRAY
115032: PUSH
115033: LD_INT 1
115035: ARRAY
115036: PUSH
115037: LD_INT 2
115039: ARRAY
115040: PPUSH
115041: CALL_OW 114
// end else
115045: GO 115098
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
115047: LD_ADDR_VAR 0 15
115051: PUSH
115052: LD_VAR 0 16
115056: PUSH
115057: LD_VAR 0 7
115061: ARRAY
115062: PPUSH
115063: LD_INT 1
115065: PPUSH
115066: CALL_OW 3
115070: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
115071: LD_ADDR_VAR 0 16
115075: PUSH
115076: LD_VAR 0 16
115080: PPUSH
115081: LD_VAR 0 7
115085: PPUSH
115086: LD_VAR 0 15
115090: PPUSH
115091: CALL_OW 1
115095: ST_TO_ADDR
// continue ;
115096: GO 113641
// end ; end ; end else
115098: GO 117762
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
115100: LD_ADDR_VAR 0 14
115104: PUSH
115105: LD_INT 81
115107: PUSH
115108: LD_VAR 0 4
115112: PUSH
115113: LD_VAR 0 7
115117: ARRAY
115118: PPUSH
115119: CALL_OW 255
115123: PUSH
115124: EMPTY
115125: LIST
115126: LIST
115127: PPUSH
115128: CALL_OW 69
115132: ST_TO_ADDR
// if not tmp then
115133: LD_VAR 0 14
115137: NOT
115138: IFFALSE 115142
// continue ;
115140: GO 113641
// if f_ignore_area then
115142: LD_VAR 0 17
115146: IFFALSE 115234
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
115148: LD_ADDR_VAR 0 15
115152: PUSH
115153: LD_VAR 0 14
115157: PPUSH
115158: LD_INT 3
115160: PUSH
115161: LD_INT 92
115163: PUSH
115164: LD_VAR 0 17
115168: PUSH
115169: LD_INT 1
115171: ARRAY
115172: PUSH
115173: LD_VAR 0 17
115177: PUSH
115178: LD_INT 2
115180: ARRAY
115181: PUSH
115182: LD_VAR 0 17
115186: PUSH
115187: LD_INT 3
115189: ARRAY
115190: PUSH
115191: EMPTY
115192: LIST
115193: LIST
115194: LIST
115195: LIST
115196: PUSH
115197: EMPTY
115198: LIST
115199: LIST
115200: PPUSH
115201: CALL_OW 72
115205: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115206: LD_VAR 0 14
115210: PUSH
115211: LD_VAR 0 15
115215: DIFF
115216: IFFALSE 115234
// tmp := tmp diff tmp2 ;
115218: LD_ADDR_VAR 0 14
115222: PUSH
115223: LD_VAR 0 14
115227: PUSH
115228: LD_VAR 0 15
115232: DIFF
115233: ST_TO_ADDR
// end ; if not f_murder then
115234: LD_VAR 0 20
115238: NOT
115239: IFFALSE 115297
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
115241: LD_ADDR_VAR 0 15
115245: PUSH
115246: LD_VAR 0 14
115250: PPUSH
115251: LD_INT 3
115253: PUSH
115254: LD_INT 50
115256: PUSH
115257: EMPTY
115258: LIST
115259: PUSH
115260: EMPTY
115261: LIST
115262: LIST
115263: PPUSH
115264: CALL_OW 72
115268: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
115269: LD_VAR 0 14
115273: PUSH
115274: LD_VAR 0 15
115278: DIFF
115279: IFFALSE 115297
// tmp := tmp diff tmp2 ;
115281: LD_ADDR_VAR 0 14
115285: PUSH
115286: LD_VAR 0 14
115290: PUSH
115291: LD_VAR 0 15
115295: DIFF
115296: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
115297: LD_ADDR_VAR 0 14
115301: PUSH
115302: LD_VAR 0 4
115306: PUSH
115307: LD_VAR 0 7
115311: ARRAY
115312: PPUSH
115313: LD_VAR 0 14
115317: PPUSH
115318: LD_INT 1
115320: PPUSH
115321: LD_INT 1
115323: PPUSH
115324: CALL 57480 0 4
115328: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
115329: LD_VAR 0 4
115333: PUSH
115334: LD_VAR 0 7
115338: ARRAY
115339: PPUSH
115340: CALL_OW 257
115344: PUSH
115345: LD_INT 1
115347: EQUAL
115348: IFFALSE 115796
// begin if WantPlant ( group [ i ] ) then
115350: LD_VAR 0 4
115354: PUSH
115355: LD_VAR 0 7
115359: ARRAY
115360: PPUSH
115361: CALL 56981 0 1
115365: IFFALSE 115369
// continue ;
115367: GO 113641
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
115369: LD_VAR 0 18
115373: PUSH
115374: LD_VAR 0 4
115378: PUSH
115379: LD_VAR 0 7
115383: ARRAY
115384: PPUSH
115385: CALL_OW 310
115389: NOT
115390: AND
115391: PUSH
115392: LD_VAR 0 14
115396: PUSH
115397: LD_INT 1
115399: ARRAY
115400: PUSH
115401: LD_VAR 0 14
115405: PPUSH
115406: LD_INT 21
115408: PUSH
115409: LD_INT 2
115411: PUSH
115412: EMPTY
115413: LIST
115414: LIST
115415: PUSH
115416: LD_INT 58
115418: PUSH
115419: EMPTY
115420: LIST
115421: PUSH
115422: EMPTY
115423: LIST
115424: LIST
115425: PPUSH
115426: CALL_OW 72
115430: IN
115431: AND
115432: IFFALSE 115468
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
115434: LD_VAR 0 4
115438: PUSH
115439: LD_VAR 0 7
115443: ARRAY
115444: PPUSH
115445: LD_VAR 0 14
115449: PUSH
115450: LD_INT 1
115452: ARRAY
115453: PPUSH
115454: CALL_OW 120
// attacking := true ;
115458: LD_ADDR_VAR 0 29
115462: PUSH
115463: LD_INT 1
115465: ST_TO_ADDR
// continue ;
115466: GO 113641
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115468: LD_VAR 0 26
115472: PUSH
115473: LD_VAR 0 4
115477: PUSH
115478: LD_VAR 0 7
115482: ARRAY
115483: PPUSH
115484: CALL_OW 257
115488: PUSH
115489: LD_INT 1
115491: EQUAL
115492: AND
115493: PUSH
115494: LD_VAR 0 4
115498: PUSH
115499: LD_VAR 0 7
115503: ARRAY
115504: PPUSH
115505: CALL_OW 256
115509: PUSH
115510: LD_INT 800
115512: LESS
115513: AND
115514: PUSH
115515: LD_VAR 0 4
115519: PUSH
115520: LD_VAR 0 7
115524: ARRAY
115525: PPUSH
115526: CALL_OW 318
115530: NOT
115531: AND
115532: IFFALSE 115549
// ComCrawl ( group [ i ] ) ;
115534: LD_VAR 0 4
115538: PUSH
115539: LD_VAR 0 7
115543: ARRAY
115544: PPUSH
115545: CALL_OW 137
// if f_mines then
115549: LD_VAR 0 21
115553: IFFALSE 115796
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115555: LD_VAR 0 14
115559: PUSH
115560: LD_INT 1
115562: ARRAY
115563: PPUSH
115564: CALL_OW 247
115568: PUSH
115569: LD_INT 3
115571: EQUAL
115572: PUSH
115573: LD_VAR 0 14
115577: PUSH
115578: LD_INT 1
115580: ARRAY
115581: PUSH
115582: LD_VAR 0 27
115586: IN
115587: NOT
115588: AND
115589: IFFALSE 115796
// begin x := GetX ( tmp [ 1 ] ) ;
115591: LD_ADDR_VAR 0 10
115595: PUSH
115596: LD_VAR 0 14
115600: PUSH
115601: LD_INT 1
115603: ARRAY
115604: PPUSH
115605: CALL_OW 250
115609: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115610: LD_ADDR_VAR 0 11
115614: PUSH
115615: LD_VAR 0 14
115619: PUSH
115620: LD_INT 1
115622: ARRAY
115623: PPUSH
115624: CALL_OW 251
115628: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115629: LD_ADDR_VAR 0 12
115633: PUSH
115634: LD_VAR 0 4
115638: PUSH
115639: LD_VAR 0 7
115643: ARRAY
115644: PPUSH
115645: CALL 84624 0 1
115649: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115650: LD_VAR 0 4
115654: PUSH
115655: LD_VAR 0 7
115659: ARRAY
115660: PPUSH
115661: LD_VAR 0 10
115665: PPUSH
115666: LD_VAR 0 11
115670: PPUSH
115671: LD_VAR 0 14
115675: PUSH
115676: LD_INT 1
115678: ARRAY
115679: PPUSH
115680: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115684: LD_VAR 0 4
115688: PUSH
115689: LD_VAR 0 7
115693: ARRAY
115694: PPUSH
115695: LD_VAR 0 10
115699: PPUSH
115700: LD_VAR 0 12
115704: PPUSH
115705: LD_INT 7
115707: PPUSH
115708: CALL_OW 272
115712: PPUSH
115713: LD_VAR 0 11
115717: PPUSH
115718: LD_VAR 0 12
115722: PPUSH
115723: LD_INT 7
115725: PPUSH
115726: CALL_OW 273
115730: PPUSH
115731: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115735: LD_VAR 0 4
115739: PUSH
115740: LD_VAR 0 7
115744: ARRAY
115745: PPUSH
115746: LD_INT 71
115748: PPUSH
115749: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115753: LD_ADDR_VAR 0 27
115757: PUSH
115758: LD_VAR 0 27
115762: PPUSH
115763: LD_VAR 0 27
115767: PUSH
115768: LD_INT 1
115770: PLUS
115771: PPUSH
115772: LD_VAR 0 14
115776: PUSH
115777: LD_INT 1
115779: ARRAY
115780: PPUSH
115781: CALL_OW 1
115785: ST_TO_ADDR
// attacking := true ;
115786: LD_ADDR_VAR 0 29
115790: PUSH
115791: LD_INT 1
115793: ST_TO_ADDR
// continue ;
115794: GO 113641
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115796: LD_VAR 0 4
115800: PUSH
115801: LD_VAR 0 7
115805: ARRAY
115806: PPUSH
115807: CALL_OW 257
115811: PUSH
115812: LD_INT 17
115814: EQUAL
115815: PUSH
115816: LD_VAR 0 4
115820: PUSH
115821: LD_VAR 0 7
115825: ARRAY
115826: PPUSH
115827: CALL_OW 110
115831: PUSH
115832: LD_INT 71
115834: EQUAL
115835: NOT
115836: AND
115837: IFFALSE 115983
// begin attacking := false ;
115839: LD_ADDR_VAR 0 29
115843: PUSH
115844: LD_INT 0
115846: ST_TO_ADDR
// k := 5 ;
115847: LD_ADDR_VAR 0 9
115851: PUSH
115852: LD_INT 5
115854: ST_TO_ADDR
// if tmp < k then
115855: LD_VAR 0 14
115859: PUSH
115860: LD_VAR 0 9
115864: LESS
115865: IFFALSE 115877
// k := tmp ;
115867: LD_ADDR_VAR 0 9
115871: PUSH
115872: LD_VAR 0 14
115876: ST_TO_ADDR
// for j = 1 to k do
115877: LD_ADDR_VAR 0 8
115881: PUSH
115882: DOUBLE
115883: LD_INT 1
115885: DEC
115886: ST_TO_ADDR
115887: LD_VAR 0 9
115891: PUSH
115892: FOR_TO
115893: IFFALSE 115981
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115895: LD_VAR 0 14
115899: PUSH
115900: LD_VAR 0 8
115904: ARRAY
115905: PUSH
115906: LD_VAR 0 14
115910: PPUSH
115911: LD_INT 58
115913: PUSH
115914: EMPTY
115915: LIST
115916: PPUSH
115917: CALL_OW 72
115921: IN
115922: NOT
115923: IFFALSE 115979
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115925: LD_VAR 0 4
115929: PUSH
115930: LD_VAR 0 7
115934: ARRAY
115935: PPUSH
115936: LD_VAR 0 14
115940: PUSH
115941: LD_VAR 0 8
115945: ARRAY
115946: PPUSH
115947: CALL_OW 115
// attacking := true ;
115951: LD_ADDR_VAR 0 29
115955: PUSH
115956: LD_INT 1
115958: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115959: LD_VAR 0 4
115963: PUSH
115964: LD_VAR 0 7
115968: ARRAY
115969: PPUSH
115970: LD_INT 71
115972: PPUSH
115973: CALL_OW 109
// continue ;
115977: GO 115892
// end ; end ;
115979: GO 115892
115981: POP
115982: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115983: LD_VAR 0 4
115987: PUSH
115988: LD_VAR 0 7
115992: ARRAY
115993: PPUSH
115994: CALL_OW 257
115998: PUSH
115999: LD_INT 8
116001: EQUAL
116002: PUSH
116003: LD_VAR 0 4
116007: PUSH
116008: LD_VAR 0 7
116012: ARRAY
116013: PPUSH
116014: CALL_OW 264
116018: PUSH
116019: LD_INT 28
116021: PUSH
116022: LD_INT 45
116024: PUSH
116025: LD_INT 7
116027: PUSH
116028: LD_INT 47
116030: PUSH
116031: EMPTY
116032: LIST
116033: LIST
116034: LIST
116035: LIST
116036: IN
116037: OR
116038: IFFALSE 116294
// begin attacking := false ;
116040: LD_ADDR_VAR 0 29
116044: PUSH
116045: LD_INT 0
116047: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
116048: LD_VAR 0 14
116052: PUSH
116053: LD_INT 1
116055: ARRAY
116056: PPUSH
116057: CALL_OW 266
116061: PUSH
116062: LD_INT 32
116064: PUSH
116065: LD_INT 31
116067: PUSH
116068: LD_INT 33
116070: PUSH
116071: LD_INT 4
116073: PUSH
116074: LD_INT 5
116076: PUSH
116077: EMPTY
116078: LIST
116079: LIST
116080: LIST
116081: LIST
116082: LIST
116083: IN
116084: IFFALSE 116270
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
116086: LD_ADDR_VAR 0 9
116090: PUSH
116091: LD_VAR 0 14
116095: PUSH
116096: LD_INT 1
116098: ARRAY
116099: PPUSH
116100: CALL_OW 266
116104: PPUSH
116105: LD_VAR 0 14
116109: PUSH
116110: LD_INT 1
116112: ARRAY
116113: PPUSH
116114: CALL_OW 250
116118: PPUSH
116119: LD_VAR 0 14
116123: PUSH
116124: LD_INT 1
116126: ARRAY
116127: PPUSH
116128: CALL_OW 251
116132: PPUSH
116133: LD_VAR 0 14
116137: PUSH
116138: LD_INT 1
116140: ARRAY
116141: PPUSH
116142: CALL_OW 254
116146: PPUSH
116147: LD_VAR 0 14
116151: PUSH
116152: LD_INT 1
116154: ARRAY
116155: PPUSH
116156: CALL_OW 248
116160: PPUSH
116161: LD_INT 0
116163: PPUSH
116164: CALL 65994 0 6
116168: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
116169: LD_ADDR_VAR 0 8
116173: PUSH
116174: LD_VAR 0 4
116178: PUSH
116179: LD_VAR 0 7
116183: ARRAY
116184: PPUSH
116185: LD_VAR 0 9
116189: PPUSH
116190: CALL 84737 0 2
116194: ST_TO_ADDR
// if j then
116195: LD_VAR 0 8
116199: IFFALSE 116268
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
116201: LD_VAR 0 8
116205: PUSH
116206: LD_INT 1
116208: ARRAY
116209: PPUSH
116210: LD_VAR 0 8
116214: PUSH
116215: LD_INT 2
116217: ARRAY
116218: PPUSH
116219: CALL_OW 488
116223: IFFALSE 116268
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
116225: LD_VAR 0 4
116229: PUSH
116230: LD_VAR 0 7
116234: ARRAY
116235: PPUSH
116236: LD_VAR 0 8
116240: PUSH
116241: LD_INT 1
116243: ARRAY
116244: PPUSH
116245: LD_VAR 0 8
116249: PUSH
116250: LD_INT 2
116252: ARRAY
116253: PPUSH
116254: CALL_OW 116
// attacking := true ;
116258: LD_ADDR_VAR 0 29
116262: PUSH
116263: LD_INT 1
116265: ST_TO_ADDR
// continue ;
116266: GO 113641
// end ; end else
116268: GO 116294
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116270: LD_VAR 0 4
116274: PUSH
116275: LD_VAR 0 7
116279: ARRAY
116280: PPUSH
116281: LD_VAR 0 14
116285: PUSH
116286: LD_INT 1
116288: ARRAY
116289: PPUSH
116290: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
116294: LD_VAR 0 4
116298: PUSH
116299: LD_VAR 0 7
116303: ARRAY
116304: PPUSH
116305: CALL_OW 265
116309: PUSH
116310: LD_INT 11
116312: EQUAL
116313: IFFALSE 116591
// begin k := 10 ;
116315: LD_ADDR_VAR 0 9
116319: PUSH
116320: LD_INT 10
116322: ST_TO_ADDR
// x := 0 ;
116323: LD_ADDR_VAR 0 10
116327: PUSH
116328: LD_INT 0
116330: ST_TO_ADDR
// if tmp < k then
116331: LD_VAR 0 14
116335: PUSH
116336: LD_VAR 0 9
116340: LESS
116341: IFFALSE 116353
// k := tmp ;
116343: LD_ADDR_VAR 0 9
116347: PUSH
116348: LD_VAR 0 14
116352: ST_TO_ADDR
// for j = k downto 1 do
116353: LD_ADDR_VAR 0 8
116357: PUSH
116358: DOUBLE
116359: LD_VAR 0 9
116363: INC
116364: ST_TO_ADDR
116365: LD_INT 1
116367: PUSH
116368: FOR_DOWNTO
116369: IFFALSE 116444
// begin if GetType ( tmp [ j ] ) = unit_human then
116371: LD_VAR 0 14
116375: PUSH
116376: LD_VAR 0 8
116380: ARRAY
116381: PPUSH
116382: CALL_OW 247
116386: PUSH
116387: LD_INT 1
116389: EQUAL
116390: IFFALSE 116442
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
116392: LD_VAR 0 4
116396: PUSH
116397: LD_VAR 0 7
116401: ARRAY
116402: PPUSH
116403: LD_VAR 0 14
116407: PUSH
116408: LD_VAR 0 8
116412: ARRAY
116413: PPUSH
116414: CALL 84991 0 2
// x := tmp [ j ] ;
116418: LD_ADDR_VAR 0 10
116422: PUSH
116423: LD_VAR 0 14
116427: PUSH
116428: LD_VAR 0 8
116432: ARRAY
116433: ST_TO_ADDR
// attacking := true ;
116434: LD_ADDR_VAR 0 29
116438: PUSH
116439: LD_INT 1
116441: ST_TO_ADDR
// end ; end ;
116442: GO 116368
116444: POP
116445: POP
// if not x then
116446: LD_VAR 0 10
116450: NOT
116451: IFFALSE 116591
// begin attacking := true ;
116453: LD_ADDR_VAR 0 29
116457: PUSH
116458: LD_INT 1
116460: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116461: LD_VAR 0 4
116465: PUSH
116466: LD_VAR 0 7
116470: ARRAY
116471: PPUSH
116472: CALL_OW 250
116476: PPUSH
116477: LD_VAR 0 4
116481: PUSH
116482: LD_VAR 0 7
116486: ARRAY
116487: PPUSH
116488: CALL_OW 251
116492: PPUSH
116493: CALL_OW 546
116497: PUSH
116498: LD_INT 2
116500: ARRAY
116501: PUSH
116502: LD_VAR 0 14
116506: PUSH
116507: LD_INT 1
116509: ARRAY
116510: PPUSH
116511: CALL_OW 250
116515: PPUSH
116516: LD_VAR 0 14
116520: PUSH
116521: LD_INT 1
116523: ARRAY
116524: PPUSH
116525: CALL_OW 251
116529: PPUSH
116530: CALL_OW 546
116534: PUSH
116535: LD_INT 2
116537: ARRAY
116538: EQUAL
116539: IFFALSE 116567
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116541: LD_VAR 0 4
116545: PUSH
116546: LD_VAR 0 7
116550: ARRAY
116551: PPUSH
116552: LD_VAR 0 14
116556: PUSH
116557: LD_INT 1
116559: ARRAY
116560: PPUSH
116561: CALL 84991 0 2
116565: GO 116591
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116567: LD_VAR 0 4
116571: PUSH
116572: LD_VAR 0 7
116576: ARRAY
116577: PPUSH
116578: LD_VAR 0 14
116582: PUSH
116583: LD_INT 1
116585: ARRAY
116586: PPUSH
116587: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116591: LD_VAR 0 4
116595: PUSH
116596: LD_VAR 0 7
116600: ARRAY
116601: PPUSH
116602: CALL_OW 264
116606: PUSH
116607: LD_INT 29
116609: EQUAL
116610: IFFALSE 116976
// begin if WantsToAttack ( group [ i ] ) in bombed then
116612: LD_VAR 0 4
116616: PUSH
116617: LD_VAR 0 7
116621: ARRAY
116622: PPUSH
116623: CALL_OW 319
116627: PUSH
116628: LD_VAR 0 28
116632: IN
116633: IFFALSE 116637
// continue ;
116635: GO 113641
// k := 8 ;
116637: LD_ADDR_VAR 0 9
116641: PUSH
116642: LD_INT 8
116644: ST_TO_ADDR
// x := 0 ;
116645: LD_ADDR_VAR 0 10
116649: PUSH
116650: LD_INT 0
116652: ST_TO_ADDR
// if tmp < k then
116653: LD_VAR 0 14
116657: PUSH
116658: LD_VAR 0 9
116662: LESS
116663: IFFALSE 116675
// k := tmp ;
116665: LD_ADDR_VAR 0 9
116669: PUSH
116670: LD_VAR 0 14
116674: ST_TO_ADDR
// for j = 1 to k do
116675: LD_ADDR_VAR 0 8
116679: PUSH
116680: DOUBLE
116681: LD_INT 1
116683: DEC
116684: ST_TO_ADDR
116685: LD_VAR 0 9
116689: PUSH
116690: FOR_TO
116691: IFFALSE 116823
// begin if GetType ( tmp [ j ] ) = unit_building then
116693: LD_VAR 0 14
116697: PUSH
116698: LD_VAR 0 8
116702: ARRAY
116703: PPUSH
116704: CALL_OW 247
116708: PUSH
116709: LD_INT 3
116711: EQUAL
116712: IFFALSE 116821
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116714: LD_VAR 0 14
116718: PUSH
116719: LD_VAR 0 8
116723: ARRAY
116724: PUSH
116725: LD_VAR 0 28
116729: IN
116730: NOT
116731: PUSH
116732: LD_VAR 0 14
116736: PUSH
116737: LD_VAR 0 8
116741: ARRAY
116742: PPUSH
116743: CALL_OW 313
116747: AND
116748: IFFALSE 116821
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116750: LD_VAR 0 4
116754: PUSH
116755: LD_VAR 0 7
116759: ARRAY
116760: PPUSH
116761: LD_VAR 0 14
116765: PUSH
116766: LD_VAR 0 8
116770: ARRAY
116771: PPUSH
116772: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116776: LD_ADDR_VAR 0 28
116780: PUSH
116781: LD_VAR 0 28
116785: PPUSH
116786: LD_VAR 0 28
116790: PUSH
116791: LD_INT 1
116793: PLUS
116794: PPUSH
116795: LD_VAR 0 14
116799: PUSH
116800: LD_VAR 0 8
116804: ARRAY
116805: PPUSH
116806: CALL_OW 1
116810: ST_TO_ADDR
// attacking := true ;
116811: LD_ADDR_VAR 0 29
116815: PUSH
116816: LD_INT 1
116818: ST_TO_ADDR
// break ;
116819: GO 116823
// end ; end ;
116821: GO 116690
116823: POP
116824: POP
// if not attacking and f_attack_depot then
116825: LD_VAR 0 29
116829: NOT
116830: PUSH
116831: LD_VAR 0 25
116835: AND
116836: IFFALSE 116931
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116838: LD_ADDR_VAR 0 13
116842: PUSH
116843: LD_VAR 0 14
116847: PPUSH
116848: LD_INT 2
116850: PUSH
116851: LD_INT 30
116853: PUSH
116854: LD_INT 0
116856: PUSH
116857: EMPTY
116858: LIST
116859: LIST
116860: PUSH
116861: LD_INT 30
116863: PUSH
116864: LD_INT 1
116866: PUSH
116867: EMPTY
116868: LIST
116869: LIST
116870: PUSH
116871: EMPTY
116872: LIST
116873: LIST
116874: LIST
116875: PPUSH
116876: CALL_OW 72
116880: ST_TO_ADDR
// if z then
116881: LD_VAR 0 13
116885: IFFALSE 116931
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116887: LD_VAR 0 4
116891: PUSH
116892: LD_VAR 0 7
116896: ARRAY
116897: PPUSH
116898: LD_VAR 0 13
116902: PPUSH
116903: LD_VAR 0 4
116907: PUSH
116908: LD_VAR 0 7
116912: ARRAY
116913: PPUSH
116914: CALL_OW 74
116918: PPUSH
116919: CALL_OW 115
// attacking := true ;
116923: LD_ADDR_VAR 0 29
116927: PUSH
116928: LD_INT 1
116930: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116931: LD_VAR 0 4
116935: PUSH
116936: LD_VAR 0 7
116940: ARRAY
116941: PPUSH
116942: CALL_OW 256
116946: PUSH
116947: LD_INT 500
116949: LESS
116950: IFFALSE 116976
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116952: LD_VAR 0 4
116956: PUSH
116957: LD_VAR 0 7
116961: ARRAY
116962: PPUSH
116963: LD_VAR 0 14
116967: PUSH
116968: LD_INT 1
116970: ARRAY
116971: PPUSH
116972: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116976: LD_VAR 0 4
116980: PUSH
116981: LD_VAR 0 7
116985: ARRAY
116986: PPUSH
116987: CALL_OW 264
116991: PUSH
116992: LD_INT 49
116994: EQUAL
116995: IFFALSE 117116
// begin if not HasTask ( group [ i ] ) then
116997: LD_VAR 0 4
117001: PUSH
117002: LD_VAR 0 7
117006: ARRAY
117007: PPUSH
117008: CALL_OW 314
117012: NOT
117013: IFFALSE 117116
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
117015: LD_ADDR_VAR 0 9
117019: PUSH
117020: LD_INT 81
117022: PUSH
117023: LD_VAR 0 4
117027: PUSH
117028: LD_VAR 0 7
117032: ARRAY
117033: PPUSH
117034: CALL_OW 255
117038: PUSH
117039: EMPTY
117040: LIST
117041: LIST
117042: PPUSH
117043: CALL_OW 69
117047: PPUSH
117048: LD_VAR 0 4
117052: PUSH
117053: LD_VAR 0 7
117057: ARRAY
117058: PPUSH
117059: CALL_OW 74
117063: ST_TO_ADDR
// if k then
117064: LD_VAR 0 9
117068: IFFALSE 117116
// if GetDistUnits ( group [ i ] , k ) > 10 then
117070: LD_VAR 0 4
117074: PUSH
117075: LD_VAR 0 7
117079: ARRAY
117080: PPUSH
117081: LD_VAR 0 9
117085: PPUSH
117086: CALL_OW 296
117090: PUSH
117091: LD_INT 10
117093: GREATER
117094: IFFALSE 117116
// ComMoveUnit ( group [ i ] , k ) ;
117096: LD_VAR 0 4
117100: PUSH
117101: LD_VAR 0 7
117105: ARRAY
117106: PPUSH
117107: LD_VAR 0 9
117111: PPUSH
117112: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
117116: LD_VAR 0 4
117120: PUSH
117121: LD_VAR 0 7
117125: ARRAY
117126: PPUSH
117127: CALL_OW 256
117131: PUSH
117132: LD_INT 250
117134: LESS
117135: PUSH
117136: LD_VAR 0 4
117140: PUSH
117141: LD_VAR 0 7
117145: ARRAY
117146: PUSH
117147: LD_INT 21
117149: PUSH
117150: LD_INT 2
117152: PUSH
117153: EMPTY
117154: LIST
117155: LIST
117156: PUSH
117157: LD_INT 23
117159: PUSH
117160: LD_INT 2
117162: PUSH
117163: EMPTY
117164: LIST
117165: LIST
117166: PUSH
117167: EMPTY
117168: LIST
117169: LIST
117170: PPUSH
117171: CALL_OW 69
117175: IN
117176: AND
117177: IFFALSE 117302
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
117179: LD_ADDR_VAR 0 9
117183: PUSH
117184: LD_OWVAR 3
117188: PUSH
117189: LD_VAR 0 4
117193: PUSH
117194: LD_VAR 0 7
117198: ARRAY
117199: DIFF
117200: PPUSH
117201: LD_VAR 0 4
117205: PUSH
117206: LD_VAR 0 7
117210: ARRAY
117211: PPUSH
117212: CALL_OW 74
117216: ST_TO_ADDR
// if not k then
117217: LD_VAR 0 9
117221: NOT
117222: IFFALSE 117226
// continue ;
117224: GO 113641
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
117226: LD_VAR 0 9
117230: PUSH
117231: LD_INT 81
117233: PUSH
117234: LD_VAR 0 4
117238: PUSH
117239: LD_VAR 0 7
117243: ARRAY
117244: PPUSH
117245: CALL_OW 255
117249: PUSH
117250: EMPTY
117251: LIST
117252: LIST
117253: PPUSH
117254: CALL_OW 69
117258: IN
117259: PUSH
117260: LD_VAR 0 9
117264: PPUSH
117265: LD_VAR 0 4
117269: PUSH
117270: LD_VAR 0 7
117274: ARRAY
117275: PPUSH
117276: CALL_OW 296
117280: PUSH
117281: LD_INT 5
117283: LESS
117284: AND
117285: IFFALSE 117302
// ComAutodestruct ( group [ i ] ) ;
117287: LD_VAR 0 4
117291: PUSH
117292: LD_VAR 0 7
117296: ARRAY
117297: PPUSH
117298: CALL 84889 0 1
// end ; if f_attack_depot then
117302: LD_VAR 0 25
117306: IFFALSE 117418
// begin k := 6 ;
117308: LD_ADDR_VAR 0 9
117312: PUSH
117313: LD_INT 6
117315: ST_TO_ADDR
// if tmp < k then
117316: LD_VAR 0 14
117320: PUSH
117321: LD_VAR 0 9
117325: LESS
117326: IFFALSE 117338
// k := tmp ;
117328: LD_ADDR_VAR 0 9
117332: PUSH
117333: LD_VAR 0 14
117337: ST_TO_ADDR
// for j = 1 to k do
117338: LD_ADDR_VAR 0 8
117342: PUSH
117343: DOUBLE
117344: LD_INT 1
117346: DEC
117347: ST_TO_ADDR
117348: LD_VAR 0 9
117352: PUSH
117353: FOR_TO
117354: IFFALSE 117416
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
117356: LD_VAR 0 8
117360: PPUSH
117361: CALL_OW 266
117365: PUSH
117366: LD_INT 0
117368: PUSH
117369: LD_INT 1
117371: PUSH
117372: EMPTY
117373: LIST
117374: LIST
117375: IN
117376: IFFALSE 117414
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117378: LD_VAR 0 4
117382: PUSH
117383: LD_VAR 0 7
117387: ARRAY
117388: PPUSH
117389: LD_VAR 0 14
117393: PUSH
117394: LD_VAR 0 8
117398: ARRAY
117399: PPUSH
117400: CALL_OW 115
// attacking := true ;
117404: LD_ADDR_VAR 0 29
117408: PUSH
117409: LD_INT 1
117411: ST_TO_ADDR
// break ;
117412: GO 117416
// end ;
117414: GO 117353
117416: POP
117417: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
117418: LD_VAR 0 4
117422: PUSH
117423: LD_VAR 0 7
117427: ARRAY
117428: PPUSH
117429: CALL_OW 302
117433: PUSH
117434: LD_VAR 0 29
117438: NOT
117439: AND
117440: IFFALSE 117762
// begin if GetTag ( group [ i ] ) = 71 then
117442: LD_VAR 0 4
117446: PUSH
117447: LD_VAR 0 7
117451: ARRAY
117452: PPUSH
117453: CALL_OW 110
117457: PUSH
117458: LD_INT 71
117460: EQUAL
117461: IFFALSE 117502
// begin if HasTask ( group [ i ] ) then
117463: LD_VAR 0 4
117467: PUSH
117468: LD_VAR 0 7
117472: ARRAY
117473: PPUSH
117474: CALL_OW 314
117478: IFFALSE 117484
// continue else
117480: GO 113641
117482: GO 117502
// SetTag ( group [ i ] , 0 ) ;
117484: LD_VAR 0 4
117488: PUSH
117489: LD_VAR 0 7
117493: ARRAY
117494: PPUSH
117495: LD_INT 0
117497: PPUSH
117498: CALL_OW 109
// end ; k := 8 ;
117502: LD_ADDR_VAR 0 9
117506: PUSH
117507: LD_INT 8
117509: ST_TO_ADDR
// x := 0 ;
117510: LD_ADDR_VAR 0 10
117514: PUSH
117515: LD_INT 0
117517: ST_TO_ADDR
// if tmp < k then
117518: LD_VAR 0 14
117522: PUSH
117523: LD_VAR 0 9
117527: LESS
117528: IFFALSE 117540
// k := tmp ;
117530: LD_ADDR_VAR 0 9
117534: PUSH
117535: LD_VAR 0 14
117539: ST_TO_ADDR
// for j = 1 to k do
117540: LD_ADDR_VAR 0 8
117544: PUSH
117545: DOUBLE
117546: LD_INT 1
117548: DEC
117549: ST_TO_ADDR
117550: LD_VAR 0 9
117554: PUSH
117555: FOR_TO
117556: IFFALSE 117654
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117558: LD_VAR 0 14
117562: PUSH
117563: LD_VAR 0 8
117567: ARRAY
117568: PPUSH
117569: CALL_OW 247
117573: PUSH
117574: LD_INT 1
117576: EQUAL
117577: PUSH
117578: LD_VAR 0 14
117582: PUSH
117583: LD_VAR 0 8
117587: ARRAY
117588: PPUSH
117589: CALL_OW 256
117593: PUSH
117594: LD_INT 250
117596: LESS
117597: PUSH
117598: LD_VAR 0 20
117602: AND
117603: PUSH
117604: LD_VAR 0 20
117608: NOT
117609: PUSH
117610: LD_VAR 0 14
117614: PUSH
117615: LD_VAR 0 8
117619: ARRAY
117620: PPUSH
117621: CALL_OW 256
117625: PUSH
117626: LD_INT 250
117628: GREATEREQUAL
117629: AND
117630: OR
117631: AND
117632: IFFALSE 117652
// begin x := tmp [ j ] ;
117634: LD_ADDR_VAR 0 10
117638: PUSH
117639: LD_VAR 0 14
117643: PUSH
117644: LD_VAR 0 8
117648: ARRAY
117649: ST_TO_ADDR
// break ;
117650: GO 117654
// end ;
117652: GO 117555
117654: POP
117655: POP
// if x then
117656: LD_VAR 0 10
117660: IFFALSE 117684
// ComAttackUnit ( group [ i ] , x ) else
117662: LD_VAR 0 4
117666: PUSH
117667: LD_VAR 0 7
117671: ARRAY
117672: PPUSH
117673: LD_VAR 0 10
117677: PPUSH
117678: CALL_OW 115
117682: GO 117708
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117684: LD_VAR 0 4
117688: PUSH
117689: LD_VAR 0 7
117693: ARRAY
117694: PPUSH
117695: LD_VAR 0 14
117699: PUSH
117700: LD_INT 1
117702: ARRAY
117703: PPUSH
117704: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117708: LD_VAR 0 4
117712: PUSH
117713: LD_VAR 0 7
117717: ARRAY
117718: PPUSH
117719: CALL_OW 314
117723: NOT
117724: IFFALSE 117762
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117726: LD_VAR 0 4
117730: PUSH
117731: LD_VAR 0 7
117735: ARRAY
117736: PPUSH
117737: LD_VAR 0 14
117741: PPUSH
117742: LD_VAR 0 4
117746: PUSH
117747: LD_VAR 0 7
117751: ARRAY
117752: PPUSH
117753: CALL_OW 74
117757: PPUSH
117758: CALL_OW 115
// end ; end ; end ;
117762: GO 113641
117764: POP
117765: POP
// wait ( 0 0$2 ) ;
117766: LD_INT 70
117768: PPUSH
117769: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117773: LD_VAR 0 4
117777: NOT
117778: PUSH
117779: LD_VAR 0 4
117783: PUSH
117784: EMPTY
117785: EQUAL
117786: OR
117787: PUSH
117788: LD_INT 81
117790: PUSH
117791: LD_VAR 0 35
117795: PUSH
117796: EMPTY
117797: LIST
117798: LIST
117799: PPUSH
117800: CALL_OW 69
117804: NOT
117805: OR
117806: IFFALSE 113626
// end ;
117808: LD_VAR 0 2
117812: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
117813: LD_INT 0
117815: PPUSH
117816: PPUSH
117817: PPUSH
117818: PPUSH
117819: PPUSH
117820: PPUSH
// if not base or not mc_bases [ base ] or not solds then
117821: LD_VAR 0 1
117825: NOT
117826: PUSH
117827: LD_EXP 76
117831: PUSH
117832: LD_VAR 0 1
117836: ARRAY
117837: NOT
117838: OR
117839: PUSH
117840: LD_VAR 0 2
117844: NOT
117845: OR
117846: IFFALSE 117850
// exit ;
117848: GO 118404
// side := mc_sides [ base ] ;
117850: LD_ADDR_VAR 0 6
117854: PUSH
117855: LD_EXP 102
117859: PUSH
117860: LD_VAR 0 1
117864: ARRAY
117865: ST_TO_ADDR
// if not side then
117866: LD_VAR 0 6
117870: NOT
117871: IFFALSE 117875
// exit ;
117873: GO 118404
// for i in solds do
117875: LD_ADDR_VAR 0 7
117879: PUSH
117880: LD_VAR 0 2
117884: PUSH
117885: FOR_IN
117886: IFFALSE 117947
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117888: LD_VAR 0 7
117892: PPUSH
117893: CALL_OW 310
117897: PPUSH
117898: CALL_OW 266
117902: PUSH
117903: LD_INT 32
117905: PUSH
117906: LD_INT 31
117908: PUSH
117909: EMPTY
117910: LIST
117911: LIST
117912: IN
117913: IFFALSE 117933
// solds := solds diff i else
117915: LD_ADDR_VAR 0 2
117919: PUSH
117920: LD_VAR 0 2
117924: PUSH
117925: LD_VAR 0 7
117929: DIFF
117930: ST_TO_ADDR
117931: GO 117945
// SetTag ( i , 18 ) ;
117933: LD_VAR 0 7
117937: PPUSH
117938: LD_INT 18
117940: PPUSH
117941: CALL_OW 109
117945: GO 117885
117947: POP
117948: POP
// if not solds then
117949: LD_VAR 0 2
117953: NOT
117954: IFFALSE 117958
// exit ;
117956: GO 118404
// repeat wait ( 0 0$2 ) ;
117958: LD_INT 70
117960: PPUSH
117961: CALL_OW 67
// enemy := mc_scan [ base ] ;
117965: LD_ADDR_VAR 0 4
117969: PUSH
117970: LD_EXP 99
117974: PUSH
117975: LD_VAR 0 1
117979: ARRAY
117980: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117981: LD_EXP 76
117985: PUSH
117986: LD_VAR 0 1
117990: ARRAY
117991: NOT
117992: PUSH
117993: LD_EXP 76
117997: PUSH
117998: LD_VAR 0 1
118002: ARRAY
118003: PUSH
118004: EMPTY
118005: EQUAL
118006: OR
118007: IFFALSE 118044
// begin for i in solds do
118009: LD_ADDR_VAR 0 7
118013: PUSH
118014: LD_VAR 0 2
118018: PUSH
118019: FOR_IN
118020: IFFALSE 118033
// ComStop ( i ) ;
118022: LD_VAR 0 7
118026: PPUSH
118027: CALL_OW 141
118031: GO 118019
118033: POP
118034: POP
// solds := [ ] ;
118035: LD_ADDR_VAR 0 2
118039: PUSH
118040: EMPTY
118041: ST_TO_ADDR
// exit ;
118042: GO 118404
// end ; for i in solds do
118044: LD_ADDR_VAR 0 7
118048: PUSH
118049: LD_VAR 0 2
118053: PUSH
118054: FOR_IN
118055: IFFALSE 118376
// begin if IsInUnit ( i ) then
118057: LD_VAR 0 7
118061: PPUSH
118062: CALL_OW 310
118066: IFFALSE 118077
// ComExitBuilding ( i ) ;
118068: LD_VAR 0 7
118072: PPUSH
118073: CALL_OW 122
// if GetLives ( i ) > 500 then
118077: LD_VAR 0 7
118081: PPUSH
118082: CALL_OW 256
118086: PUSH
118087: LD_INT 500
118089: GREATER
118090: IFFALSE 118143
// begin e := NearestUnitToUnit ( enemy , i ) ;
118092: LD_ADDR_VAR 0 5
118096: PUSH
118097: LD_VAR 0 4
118101: PPUSH
118102: LD_VAR 0 7
118106: PPUSH
118107: CALL_OW 74
118111: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
118112: LD_VAR 0 7
118116: PPUSH
118117: LD_VAR 0 5
118121: PPUSH
118122: CALL_OW 250
118126: PPUSH
118127: LD_VAR 0 5
118131: PPUSH
118132: CALL_OW 251
118136: PPUSH
118137: CALL_OW 114
// end else
118141: GO 118374
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
118143: LD_VAR 0 7
118147: PPUSH
118148: LD_EXP 76
118152: PUSH
118153: LD_VAR 0 1
118157: ARRAY
118158: PPUSH
118159: LD_INT 2
118161: PUSH
118162: LD_INT 30
118164: PUSH
118165: LD_INT 0
118167: PUSH
118168: EMPTY
118169: LIST
118170: LIST
118171: PUSH
118172: LD_INT 30
118174: PUSH
118175: LD_INT 1
118177: PUSH
118178: EMPTY
118179: LIST
118180: LIST
118181: PUSH
118182: LD_INT 30
118184: PUSH
118185: LD_INT 6
118187: PUSH
118188: EMPTY
118189: LIST
118190: LIST
118191: PUSH
118192: EMPTY
118193: LIST
118194: LIST
118195: LIST
118196: LIST
118197: PPUSH
118198: CALL_OW 72
118202: PPUSH
118203: LD_VAR 0 7
118207: PPUSH
118208: CALL_OW 74
118212: PPUSH
118213: CALL_OW 296
118217: PUSH
118218: LD_INT 10
118220: GREATER
118221: IFFALSE 118374
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
118223: LD_ADDR_VAR 0 8
118227: PUSH
118228: LD_EXP 76
118232: PUSH
118233: LD_VAR 0 1
118237: ARRAY
118238: PPUSH
118239: LD_INT 2
118241: PUSH
118242: LD_INT 30
118244: PUSH
118245: LD_INT 0
118247: PUSH
118248: EMPTY
118249: LIST
118250: LIST
118251: PUSH
118252: LD_INT 30
118254: PUSH
118255: LD_INT 1
118257: PUSH
118258: EMPTY
118259: LIST
118260: LIST
118261: PUSH
118262: LD_INT 30
118264: PUSH
118265: LD_INT 6
118267: PUSH
118268: EMPTY
118269: LIST
118270: LIST
118271: PUSH
118272: EMPTY
118273: LIST
118274: LIST
118275: LIST
118276: LIST
118277: PPUSH
118278: CALL_OW 72
118282: PPUSH
118283: LD_VAR 0 7
118287: PPUSH
118288: CALL_OW 74
118292: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
118293: LD_VAR 0 7
118297: PPUSH
118298: LD_VAR 0 8
118302: PPUSH
118303: CALL_OW 250
118307: PPUSH
118308: LD_INT 3
118310: PPUSH
118311: LD_INT 5
118313: PPUSH
118314: CALL_OW 272
118318: PPUSH
118319: LD_VAR 0 8
118323: PPUSH
118324: CALL_OW 251
118328: PPUSH
118329: LD_INT 3
118331: PPUSH
118332: LD_INT 5
118334: PPUSH
118335: CALL_OW 273
118339: PPUSH
118340: CALL_OW 111
// SetTag ( i , 0 ) ;
118344: LD_VAR 0 7
118348: PPUSH
118349: LD_INT 0
118351: PPUSH
118352: CALL_OW 109
// solds := solds diff i ;
118356: LD_ADDR_VAR 0 2
118360: PUSH
118361: LD_VAR 0 2
118365: PUSH
118366: LD_VAR 0 7
118370: DIFF
118371: ST_TO_ADDR
// continue ;
118372: GO 118054
// end ; end ;
118374: GO 118054
118376: POP
118377: POP
// until not solds or not enemy ;
118378: LD_VAR 0 2
118382: NOT
118383: PUSH
118384: LD_VAR 0 4
118388: NOT
118389: OR
118390: IFFALSE 117958
// MC_Reset ( base , 18 ) ;
118392: LD_VAR 0 1
118396: PPUSH
118397: LD_INT 18
118399: PPUSH
118400: CALL 25405 0 2
// end ;
118404: LD_VAR 0 3
118408: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
118409: LD_INT 0
118411: PPUSH
118412: PPUSH
118413: PPUSH
118414: PPUSH
118415: PPUSH
118416: PPUSH
118417: PPUSH
118418: PPUSH
118419: PPUSH
118420: PPUSH
118421: PPUSH
118422: PPUSH
118423: PPUSH
118424: PPUSH
118425: PPUSH
118426: PPUSH
118427: PPUSH
118428: PPUSH
118429: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
118430: LD_ADDR_VAR 0 12
118434: PUSH
118435: LD_EXP 76
118439: PUSH
118440: LD_VAR 0 1
118444: ARRAY
118445: PPUSH
118446: LD_INT 25
118448: PUSH
118449: LD_INT 3
118451: PUSH
118452: EMPTY
118453: LIST
118454: LIST
118455: PPUSH
118456: CALL_OW 72
118460: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118461: LD_EXP 116
118465: PUSH
118466: LD_VAR 0 1
118470: ARRAY
118471: IFFALSE 118495
// mechs := mechs diff mc_remote_driver [ base ] ;
118473: LD_ADDR_VAR 0 12
118477: PUSH
118478: LD_VAR 0 12
118482: PUSH
118483: LD_EXP 116
118487: PUSH
118488: LD_VAR 0 1
118492: ARRAY
118493: DIFF
118494: ST_TO_ADDR
// for i in mechs do
118495: LD_ADDR_VAR 0 4
118499: PUSH
118500: LD_VAR 0 12
118504: PUSH
118505: FOR_IN
118506: IFFALSE 118541
// if GetTag ( i ) > 0 then
118508: LD_VAR 0 4
118512: PPUSH
118513: CALL_OW 110
118517: PUSH
118518: LD_INT 0
118520: GREATER
118521: IFFALSE 118539
// mechs := mechs diff i ;
118523: LD_ADDR_VAR 0 12
118527: PUSH
118528: LD_VAR 0 12
118532: PUSH
118533: LD_VAR 0 4
118537: DIFF
118538: ST_TO_ADDR
118539: GO 118505
118541: POP
118542: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118543: LD_ADDR_VAR 0 8
118547: PUSH
118548: LD_EXP 76
118552: PUSH
118553: LD_VAR 0 1
118557: ARRAY
118558: PPUSH
118559: LD_INT 2
118561: PUSH
118562: LD_INT 25
118564: PUSH
118565: LD_INT 1
118567: PUSH
118568: EMPTY
118569: LIST
118570: LIST
118571: PUSH
118572: LD_INT 25
118574: PUSH
118575: LD_INT 5
118577: PUSH
118578: EMPTY
118579: LIST
118580: LIST
118581: PUSH
118582: LD_INT 25
118584: PUSH
118585: LD_INT 8
118587: PUSH
118588: EMPTY
118589: LIST
118590: LIST
118591: PUSH
118592: LD_INT 25
118594: PUSH
118595: LD_INT 9
118597: PUSH
118598: EMPTY
118599: LIST
118600: LIST
118601: PUSH
118602: EMPTY
118603: LIST
118604: LIST
118605: LIST
118606: LIST
118607: LIST
118608: PPUSH
118609: CALL_OW 72
118613: ST_TO_ADDR
// if not defenders and not solds then
118614: LD_VAR 0 2
118618: NOT
118619: PUSH
118620: LD_VAR 0 8
118624: NOT
118625: AND
118626: IFFALSE 118630
// exit ;
118628: GO 120400
// depot_under_attack := false ;
118630: LD_ADDR_VAR 0 16
118634: PUSH
118635: LD_INT 0
118637: ST_TO_ADDR
// sold_defenders := [ ] ;
118638: LD_ADDR_VAR 0 17
118642: PUSH
118643: EMPTY
118644: ST_TO_ADDR
// if mechs then
118645: LD_VAR 0 12
118649: IFFALSE 118802
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118651: LD_ADDR_VAR 0 4
118655: PUSH
118656: LD_VAR 0 2
118660: PPUSH
118661: LD_INT 21
118663: PUSH
118664: LD_INT 2
118666: PUSH
118667: EMPTY
118668: LIST
118669: LIST
118670: PPUSH
118671: CALL_OW 72
118675: PUSH
118676: FOR_IN
118677: IFFALSE 118800
// begin if GetTag ( i ) <> 20 then
118679: LD_VAR 0 4
118683: PPUSH
118684: CALL_OW 110
118688: PUSH
118689: LD_INT 20
118691: NONEQUAL
118692: IFFALSE 118706
// SetTag ( i , 20 ) ;
118694: LD_VAR 0 4
118698: PPUSH
118699: LD_INT 20
118701: PPUSH
118702: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118706: LD_VAR 0 4
118710: PPUSH
118711: CALL_OW 263
118715: PUSH
118716: LD_INT 1
118718: EQUAL
118719: PUSH
118720: LD_VAR 0 4
118724: PPUSH
118725: CALL_OW 311
118729: NOT
118730: AND
118731: IFFALSE 118798
// begin un := mechs [ 1 ] ;
118733: LD_ADDR_VAR 0 10
118737: PUSH
118738: LD_VAR 0 12
118742: PUSH
118743: LD_INT 1
118745: ARRAY
118746: ST_TO_ADDR
// ComExit ( un ) ;
118747: LD_VAR 0 10
118751: PPUSH
118752: CALL 89755 0 1
// AddComEnterUnit ( un , i ) ;
118756: LD_VAR 0 10
118760: PPUSH
118761: LD_VAR 0 4
118765: PPUSH
118766: CALL_OW 180
// SetTag ( un , 19 ) ;
118770: LD_VAR 0 10
118774: PPUSH
118775: LD_INT 19
118777: PPUSH
118778: CALL_OW 109
// mechs := mechs diff un ;
118782: LD_ADDR_VAR 0 12
118786: PUSH
118787: LD_VAR 0 12
118791: PUSH
118792: LD_VAR 0 10
118796: DIFF
118797: ST_TO_ADDR
// end ; end ;
118798: GO 118676
118800: POP
118801: POP
// if solds then
118802: LD_VAR 0 8
118806: IFFALSE 118865
// for i in solds do
118808: LD_ADDR_VAR 0 4
118812: PUSH
118813: LD_VAR 0 8
118817: PUSH
118818: FOR_IN
118819: IFFALSE 118863
// if not GetTag ( i ) then
118821: LD_VAR 0 4
118825: PPUSH
118826: CALL_OW 110
118830: NOT
118831: IFFALSE 118861
// begin defenders := defenders union i ;
118833: LD_ADDR_VAR 0 2
118837: PUSH
118838: LD_VAR 0 2
118842: PUSH
118843: LD_VAR 0 4
118847: UNION
118848: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118849: LD_VAR 0 4
118853: PPUSH
118854: LD_INT 18
118856: PPUSH
118857: CALL_OW 109
// end ;
118861: GO 118818
118863: POP
118864: POP
// repeat wait ( 0 0$2 ) ;
118865: LD_INT 70
118867: PPUSH
118868: CALL_OW 67
// enemy := mc_scan [ base ] ;
118872: LD_ADDR_VAR 0 21
118876: PUSH
118877: LD_EXP 99
118881: PUSH
118882: LD_VAR 0 1
118886: ARRAY
118887: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118888: LD_EXP 76
118892: PUSH
118893: LD_VAR 0 1
118897: ARRAY
118898: NOT
118899: PUSH
118900: LD_EXP 76
118904: PUSH
118905: LD_VAR 0 1
118909: ARRAY
118910: PUSH
118911: EMPTY
118912: EQUAL
118913: OR
118914: IFFALSE 118951
// begin for i in defenders do
118916: LD_ADDR_VAR 0 4
118920: PUSH
118921: LD_VAR 0 2
118925: PUSH
118926: FOR_IN
118927: IFFALSE 118940
// ComStop ( i ) ;
118929: LD_VAR 0 4
118933: PPUSH
118934: CALL_OW 141
118938: GO 118926
118940: POP
118941: POP
// defenders := [ ] ;
118942: LD_ADDR_VAR 0 2
118946: PUSH
118947: EMPTY
118948: ST_TO_ADDR
// exit ;
118949: GO 120400
// end ; for i in defenders do
118951: LD_ADDR_VAR 0 4
118955: PUSH
118956: LD_VAR 0 2
118960: PUSH
118961: FOR_IN
118962: IFFALSE 119860
// begin e := NearestUnitToUnit ( enemy , i ) ;
118964: LD_ADDR_VAR 0 13
118968: PUSH
118969: LD_VAR 0 21
118973: PPUSH
118974: LD_VAR 0 4
118978: PPUSH
118979: CALL_OW 74
118983: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118984: LD_ADDR_VAR 0 7
118988: PUSH
118989: LD_EXP 76
118993: PUSH
118994: LD_VAR 0 1
118998: ARRAY
118999: PPUSH
119000: LD_INT 2
119002: PUSH
119003: LD_INT 30
119005: PUSH
119006: LD_INT 0
119008: PUSH
119009: EMPTY
119010: LIST
119011: LIST
119012: PUSH
119013: LD_INT 30
119015: PUSH
119016: LD_INT 1
119018: PUSH
119019: EMPTY
119020: LIST
119021: LIST
119022: PUSH
119023: EMPTY
119024: LIST
119025: LIST
119026: LIST
119027: PPUSH
119028: CALL_OW 72
119032: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
119033: LD_ADDR_VAR 0 16
119037: PUSH
119038: LD_VAR 0 7
119042: NOT
119043: PUSH
119044: LD_VAR 0 7
119048: PPUSH
119049: LD_INT 3
119051: PUSH
119052: LD_INT 24
119054: PUSH
119055: LD_INT 600
119057: PUSH
119058: EMPTY
119059: LIST
119060: LIST
119061: PUSH
119062: EMPTY
119063: LIST
119064: LIST
119065: PPUSH
119066: CALL_OW 72
119070: OR
119071: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
119072: LD_VAR 0 4
119076: PPUSH
119077: CALL_OW 247
119081: PUSH
119082: LD_INT 2
119084: DOUBLE
119085: EQUAL
119086: IFTRUE 119090
119088: GO 119486
119090: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
119091: LD_VAR 0 4
119095: PPUSH
119096: CALL_OW 256
119100: PUSH
119101: LD_INT 1000
119103: EQUAL
119104: PUSH
119105: LD_VAR 0 4
119109: PPUSH
119110: LD_VAR 0 13
119114: PPUSH
119115: CALL_OW 296
119119: PUSH
119120: LD_INT 40
119122: LESS
119123: PUSH
119124: LD_VAR 0 13
119128: PPUSH
119129: LD_EXP 101
119133: PUSH
119134: LD_VAR 0 1
119138: ARRAY
119139: PPUSH
119140: CALL_OW 308
119144: OR
119145: AND
119146: IFFALSE 119268
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
119148: LD_VAR 0 4
119152: PPUSH
119153: CALL_OW 262
119157: PUSH
119158: LD_INT 1
119160: EQUAL
119161: PUSH
119162: LD_VAR 0 4
119166: PPUSH
119167: CALL_OW 261
119171: PUSH
119172: LD_INT 30
119174: LESS
119175: AND
119176: PUSH
119177: LD_VAR 0 7
119181: AND
119182: IFFALSE 119252
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
119184: LD_VAR 0 4
119188: PPUSH
119189: LD_VAR 0 7
119193: PPUSH
119194: LD_VAR 0 4
119198: PPUSH
119199: CALL_OW 74
119203: PPUSH
119204: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
119208: LD_VAR 0 4
119212: PPUSH
119213: LD_VAR 0 7
119217: PPUSH
119218: LD_VAR 0 4
119222: PPUSH
119223: CALL_OW 74
119227: PPUSH
119228: CALL_OW 296
119232: PUSH
119233: LD_INT 6
119235: LESS
119236: IFFALSE 119250
// SetFuel ( i , 100 ) ;
119238: LD_VAR 0 4
119242: PPUSH
119243: LD_INT 100
119245: PPUSH
119246: CALL_OW 240
// end else
119250: GO 119266
// ComAttackUnit ( i , e ) ;
119252: LD_VAR 0 4
119256: PPUSH
119257: LD_VAR 0 13
119261: PPUSH
119262: CALL_OW 115
// end else
119266: GO 119369
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
119268: LD_VAR 0 13
119272: PPUSH
119273: LD_EXP 101
119277: PUSH
119278: LD_VAR 0 1
119282: ARRAY
119283: PPUSH
119284: CALL_OW 308
119288: NOT
119289: PUSH
119290: LD_VAR 0 4
119294: PPUSH
119295: LD_VAR 0 13
119299: PPUSH
119300: CALL_OW 296
119304: PUSH
119305: LD_INT 40
119307: GREATEREQUAL
119308: AND
119309: PUSH
119310: LD_VAR 0 4
119314: PPUSH
119315: CALL_OW 256
119319: PUSH
119320: LD_INT 650
119322: LESSEQUAL
119323: OR
119324: PUSH
119325: LD_VAR 0 4
119329: PPUSH
119330: LD_EXP 100
119334: PUSH
119335: LD_VAR 0 1
119339: ARRAY
119340: PPUSH
119341: CALL_OW 308
119345: NOT
119346: AND
119347: IFFALSE 119369
// ComMoveToArea ( i , mc_parking [ base ] ) ;
119349: LD_VAR 0 4
119353: PPUSH
119354: LD_EXP 100
119358: PUSH
119359: LD_VAR 0 1
119363: ARRAY
119364: PPUSH
119365: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
119369: LD_VAR 0 4
119373: PPUSH
119374: CALL_OW 256
119378: PUSH
119379: LD_INT 1000
119381: LESS
119382: PUSH
119383: LD_VAR 0 4
119387: PPUSH
119388: CALL_OW 263
119392: PUSH
119393: LD_INT 1
119395: EQUAL
119396: AND
119397: PUSH
119398: LD_VAR 0 4
119402: PPUSH
119403: CALL_OW 311
119407: AND
119408: PUSH
119409: LD_VAR 0 4
119413: PPUSH
119414: LD_EXP 100
119418: PUSH
119419: LD_VAR 0 1
119423: ARRAY
119424: PPUSH
119425: CALL_OW 308
119429: AND
119430: IFFALSE 119484
// begin mech := IsDrivenBy ( i ) ;
119432: LD_ADDR_VAR 0 9
119436: PUSH
119437: LD_VAR 0 4
119441: PPUSH
119442: CALL_OW 311
119446: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119447: LD_VAR 0 9
119451: PPUSH
119452: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119456: LD_VAR 0 9
119460: PPUSH
119461: LD_VAR 0 4
119465: PPUSH
119466: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119470: LD_VAR 0 9
119474: PPUSH
119475: LD_VAR 0 4
119479: PPUSH
119480: CALL_OW 180
// end ; end ; unit_human :
119484: GO 119831
119486: LD_INT 1
119488: DOUBLE
119489: EQUAL
119490: IFTRUE 119494
119492: GO 119830
119494: POP
// begin b := IsInUnit ( i ) ;
119495: LD_ADDR_VAR 0 18
119499: PUSH
119500: LD_VAR 0 4
119504: PPUSH
119505: CALL_OW 310
119509: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119510: LD_ADDR_VAR 0 19
119514: PUSH
119515: LD_VAR 0 18
119519: NOT
119520: PUSH
119521: LD_VAR 0 18
119525: PPUSH
119526: CALL_OW 266
119530: PUSH
119531: LD_INT 32
119533: PUSH
119534: LD_INT 31
119536: PUSH
119537: EMPTY
119538: LIST
119539: LIST
119540: IN
119541: OR
119542: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119543: LD_VAR 0 18
119547: PPUSH
119548: CALL_OW 266
119552: PUSH
119553: LD_INT 5
119555: EQUAL
119556: PUSH
119557: LD_VAR 0 4
119561: PPUSH
119562: CALL_OW 257
119566: PUSH
119567: LD_INT 1
119569: PUSH
119570: LD_INT 2
119572: PUSH
119573: LD_INT 3
119575: PUSH
119576: LD_INT 4
119578: PUSH
119579: EMPTY
119580: LIST
119581: LIST
119582: LIST
119583: LIST
119584: IN
119585: AND
119586: IFFALSE 119623
// begin class := AllowSpecClass ( i ) ;
119588: LD_ADDR_VAR 0 20
119592: PUSH
119593: LD_VAR 0 4
119597: PPUSH
119598: CALL 53694 0 1
119602: ST_TO_ADDR
// if class then
119603: LD_VAR 0 20
119607: IFFALSE 119623
// ComChangeProfession ( i , class ) ;
119609: LD_VAR 0 4
119613: PPUSH
119614: LD_VAR 0 20
119618: PPUSH
119619: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119623: LD_VAR 0 16
119627: PUSH
119628: LD_VAR 0 2
119632: PPUSH
119633: LD_INT 21
119635: PUSH
119636: LD_INT 2
119638: PUSH
119639: EMPTY
119640: LIST
119641: LIST
119642: PPUSH
119643: CALL_OW 72
119647: PUSH
119648: LD_INT 1
119650: LESSEQUAL
119651: OR
119652: PUSH
119653: LD_VAR 0 19
119657: AND
119658: PUSH
119659: LD_VAR 0 4
119663: PUSH
119664: LD_VAR 0 17
119668: IN
119669: NOT
119670: AND
119671: IFFALSE 119764
// begin if b then
119673: LD_VAR 0 18
119677: IFFALSE 119726
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119679: LD_VAR 0 18
119683: PPUSH
119684: LD_VAR 0 21
119688: PPUSH
119689: LD_VAR 0 18
119693: PPUSH
119694: CALL_OW 74
119698: PPUSH
119699: CALL_OW 296
119703: PUSH
119704: LD_INT 10
119706: LESS
119707: PUSH
119708: LD_VAR 0 18
119712: PPUSH
119713: CALL_OW 461
119717: PUSH
119718: LD_INT 7
119720: NONEQUAL
119721: AND
119722: IFFALSE 119726
// continue ;
119724: GO 118961
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119726: LD_ADDR_VAR 0 17
119730: PUSH
119731: LD_VAR 0 17
119735: PPUSH
119736: LD_VAR 0 17
119740: PUSH
119741: LD_INT 1
119743: PLUS
119744: PPUSH
119745: LD_VAR 0 4
119749: PPUSH
119750: CALL_OW 1
119754: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119755: LD_VAR 0 4
119759: PPUSH
119760: CALL_OW 122
// end ; if sold_defenders then
119764: LD_VAR 0 17
119768: IFFALSE 119828
// if i in sold_defenders then
119770: LD_VAR 0 4
119774: PUSH
119775: LD_VAR 0 17
119779: IN
119780: IFFALSE 119828
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119782: LD_VAR 0 4
119786: PPUSH
119787: CALL_OW 314
119791: NOT
119792: PUSH
119793: LD_VAR 0 4
119797: PPUSH
119798: LD_VAR 0 13
119802: PPUSH
119803: CALL_OW 296
119807: PUSH
119808: LD_INT 30
119810: LESS
119811: AND
119812: IFFALSE 119828
// ComAttackUnit ( i , e ) ;
119814: LD_VAR 0 4
119818: PPUSH
119819: LD_VAR 0 13
119823: PPUSH
119824: CALL_OW 115
// end ; end ; end ;
119828: GO 119831
119830: POP
// if IsDead ( i ) then
119831: LD_VAR 0 4
119835: PPUSH
119836: CALL_OW 301
119840: IFFALSE 119858
// defenders := defenders diff i ;
119842: LD_ADDR_VAR 0 2
119846: PUSH
119847: LD_VAR 0 2
119851: PUSH
119852: LD_VAR 0 4
119856: DIFF
119857: ST_TO_ADDR
// end ;
119858: GO 118961
119860: POP
119861: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119862: LD_VAR 0 21
119866: NOT
119867: PUSH
119868: LD_VAR 0 2
119872: NOT
119873: OR
119874: PUSH
119875: LD_EXP 76
119879: PUSH
119880: LD_VAR 0 1
119884: ARRAY
119885: NOT
119886: OR
119887: IFFALSE 118865
// MC_Reset ( base , 18 ) ;
119889: LD_VAR 0 1
119893: PPUSH
119894: LD_INT 18
119896: PPUSH
119897: CALL 25405 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119901: LD_ADDR_VAR 0 2
119905: PUSH
119906: LD_VAR 0 2
119910: PUSH
119911: LD_VAR 0 2
119915: PPUSH
119916: LD_INT 2
119918: PUSH
119919: LD_INT 25
119921: PUSH
119922: LD_INT 1
119924: PUSH
119925: EMPTY
119926: LIST
119927: LIST
119928: PUSH
119929: LD_INT 25
119931: PUSH
119932: LD_INT 5
119934: PUSH
119935: EMPTY
119936: LIST
119937: LIST
119938: PUSH
119939: LD_INT 25
119941: PUSH
119942: LD_INT 8
119944: PUSH
119945: EMPTY
119946: LIST
119947: LIST
119948: PUSH
119949: LD_INT 25
119951: PUSH
119952: LD_INT 9
119954: PUSH
119955: EMPTY
119956: LIST
119957: LIST
119958: PUSH
119959: EMPTY
119960: LIST
119961: LIST
119962: LIST
119963: LIST
119964: LIST
119965: PPUSH
119966: CALL_OW 72
119970: DIFF
119971: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119972: LD_VAR 0 21
119976: NOT
119977: PUSH
119978: LD_VAR 0 2
119982: PPUSH
119983: LD_INT 21
119985: PUSH
119986: LD_INT 2
119988: PUSH
119989: EMPTY
119990: LIST
119991: LIST
119992: PPUSH
119993: CALL_OW 72
119997: AND
119998: IFFALSE 120336
// begin tmp := FilterByTag ( defenders , 19 ) ;
120000: LD_ADDR_VAR 0 11
120004: PUSH
120005: LD_VAR 0 2
120009: PPUSH
120010: LD_INT 19
120012: PPUSH
120013: CALL 86931 0 2
120017: ST_TO_ADDR
// if tmp then
120018: LD_VAR 0 11
120022: IFFALSE 120092
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
120024: LD_ADDR_VAR 0 11
120028: PUSH
120029: LD_VAR 0 11
120033: PPUSH
120034: LD_INT 25
120036: PUSH
120037: LD_INT 3
120039: PUSH
120040: EMPTY
120041: LIST
120042: LIST
120043: PPUSH
120044: CALL_OW 72
120048: ST_TO_ADDR
// if tmp then
120049: LD_VAR 0 11
120053: IFFALSE 120092
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
120055: LD_ADDR_EXP 88
120059: PUSH
120060: LD_EXP 88
120064: PPUSH
120065: LD_VAR 0 1
120069: PPUSH
120070: LD_EXP 88
120074: PUSH
120075: LD_VAR 0 1
120079: ARRAY
120080: PUSH
120081: LD_VAR 0 11
120085: UNION
120086: PPUSH
120087: CALL_OW 1
120091: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
120092: LD_VAR 0 1
120096: PPUSH
120097: LD_INT 19
120099: PPUSH
120100: CALL 25405 0 2
// repeat wait ( 0 0$1 ) ;
120104: LD_INT 35
120106: PPUSH
120107: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120111: LD_EXP 76
120115: PUSH
120116: LD_VAR 0 1
120120: ARRAY
120121: NOT
120122: PUSH
120123: LD_EXP 76
120127: PUSH
120128: LD_VAR 0 1
120132: ARRAY
120133: PUSH
120134: EMPTY
120135: EQUAL
120136: OR
120137: IFFALSE 120174
// begin for i in defenders do
120139: LD_ADDR_VAR 0 4
120143: PUSH
120144: LD_VAR 0 2
120148: PUSH
120149: FOR_IN
120150: IFFALSE 120163
// ComStop ( i ) ;
120152: LD_VAR 0 4
120156: PPUSH
120157: CALL_OW 141
120161: GO 120149
120163: POP
120164: POP
// defenders := [ ] ;
120165: LD_ADDR_VAR 0 2
120169: PUSH
120170: EMPTY
120171: ST_TO_ADDR
// exit ;
120172: GO 120400
// end ; for i in defenders do
120174: LD_ADDR_VAR 0 4
120178: PUSH
120179: LD_VAR 0 2
120183: PUSH
120184: FOR_IN
120185: IFFALSE 120274
// begin if not IsInArea ( i , mc_parking [ base ] ) then
120187: LD_VAR 0 4
120191: PPUSH
120192: LD_EXP 100
120196: PUSH
120197: LD_VAR 0 1
120201: ARRAY
120202: PPUSH
120203: CALL_OW 308
120207: NOT
120208: IFFALSE 120232
// ComMoveToArea ( i , mc_parking [ base ] ) else
120210: LD_VAR 0 4
120214: PPUSH
120215: LD_EXP 100
120219: PUSH
120220: LD_VAR 0 1
120224: ARRAY
120225: PPUSH
120226: CALL_OW 113
120230: GO 120272
// if GetControl ( i ) = control_manual then
120232: LD_VAR 0 4
120236: PPUSH
120237: CALL_OW 263
120241: PUSH
120242: LD_INT 1
120244: EQUAL
120245: IFFALSE 120272
// if IsDrivenBy ( i ) then
120247: LD_VAR 0 4
120251: PPUSH
120252: CALL_OW 311
120256: IFFALSE 120272
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
120258: LD_VAR 0 4
120262: PPUSH
120263: CALL_OW 311
120267: PPUSH
120268: CALL_OW 121
// end ;
120272: GO 120184
120274: POP
120275: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
120276: LD_VAR 0 2
120280: PPUSH
120281: LD_INT 95
120283: PUSH
120284: LD_EXP 100
120288: PUSH
120289: LD_VAR 0 1
120293: ARRAY
120294: PUSH
120295: EMPTY
120296: LIST
120297: LIST
120298: PPUSH
120299: CALL_OW 72
120303: PUSH
120304: LD_VAR 0 2
120308: EQUAL
120309: PUSH
120310: LD_EXP 99
120314: PUSH
120315: LD_VAR 0 1
120319: ARRAY
120320: OR
120321: PUSH
120322: LD_EXP 76
120326: PUSH
120327: LD_VAR 0 1
120331: ARRAY
120332: NOT
120333: OR
120334: IFFALSE 120104
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
120336: LD_ADDR_EXP 98
120340: PUSH
120341: LD_EXP 98
120345: PPUSH
120346: LD_VAR 0 1
120350: PPUSH
120351: LD_VAR 0 2
120355: PPUSH
120356: LD_INT 21
120358: PUSH
120359: LD_INT 2
120361: PUSH
120362: EMPTY
120363: LIST
120364: LIST
120365: PPUSH
120366: CALL_OW 72
120370: PPUSH
120371: CALL_OW 1
120375: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
120376: LD_VAR 0 1
120380: PPUSH
120381: LD_INT 19
120383: PPUSH
120384: CALL 25405 0 2
// MC_Reset ( base , 20 ) ;
120388: LD_VAR 0 1
120392: PPUSH
120393: LD_INT 20
120395: PPUSH
120396: CALL 25405 0 2
// end ; end_of_file
120400: LD_VAR 0 3
120404: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
120405: LD_VAR 0 1
120409: PUSH
120410: LD_INT 200
120412: DOUBLE
120413: GREATEREQUAL
120414: IFFALSE 120422
120416: LD_INT 299
120418: DOUBLE
120419: LESSEQUAL
120420: IFTRUE 120424
120422: GO 120456
120424: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
120425: LD_VAR 0 1
120429: PPUSH
120430: LD_VAR 0 2
120434: PPUSH
120435: LD_VAR 0 3
120439: PPUSH
120440: LD_VAR 0 4
120444: PPUSH
120445: LD_VAR 0 5
120449: PPUSH
120450: CALL 109191 0 5
120454: GO 120533
120456: LD_INT 300
120458: DOUBLE
120459: GREATEREQUAL
120460: IFFALSE 120468
120462: LD_INT 399
120464: DOUBLE
120465: LESSEQUAL
120466: IFTRUE 120470
120468: GO 120532
120470: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120471: LD_VAR 0 1
120475: PPUSH
120476: LD_VAR 0 2
120480: PPUSH
120481: LD_VAR 0 3
120485: PPUSH
120486: LD_VAR 0 4
120490: PPUSH
120491: LD_VAR 0 5
120495: PPUSH
120496: LD_VAR 0 6
120500: PPUSH
120501: LD_VAR 0 7
120505: PPUSH
120506: LD_VAR 0 8
120510: PPUSH
120511: LD_VAR 0 9
120515: PPUSH
120516: LD_VAR 0 10
120520: PPUSH
120521: LD_VAR 0 11
120525: PPUSH
120526: CALL 105524 0 11
120530: GO 120533
120532: POP
// end ;
120533: PPOPN 11
120535: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120536: LD_VAR 0 1
120540: PPUSH
120541: LD_VAR 0 2
120545: PPUSH
120546: LD_VAR 0 3
120550: PPUSH
120551: LD_VAR 0 4
120555: PPUSH
120556: LD_VAR 0 5
120560: PPUSH
120561: CALL 108927 0 5
// end ; end_of_file
120565: PPOPN 5
120567: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120568: LD_VAR 0 1
120572: PPUSH
120573: LD_VAR 0 2
120577: PPUSH
120578: LD_VAR 0 3
120582: PPUSH
120583: LD_VAR 0 4
120587: PPUSH
120588: LD_VAR 0 5
120592: PPUSH
120593: LD_VAR 0 6
120597: PPUSH
120598: CALL 93217 0 6
// end ;
120602: PPOPN 6
120604: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120605: LD_INT 0
120607: PPUSH
// begin if not units then
120608: LD_VAR 0 1
120612: NOT
120613: IFFALSE 120617
// exit ;
120615: GO 120617
// end ;
120617: PPOPN 7
120619: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120620: CALL 93188 0 0
// end ;
120624: PPOPN 1
120626: END
