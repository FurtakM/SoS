// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22869 0 0
// InitNature ;
  19: CALL 19535 0 0
// InitArtifact ;
  23: CALL 20152 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5136 0 0
// PrepareAlliance ;
  44: CALL 1460 0 0
// PrepareArabian ;
  48: CALL 7179 0 0
// PrepareRussian ;
  52: CALL 9486 0 0
// PrepareLegion ;
  56: CALL 7746 0 0
// Action ;
  60: CALL 12458 0 0
// MC_Start ( ) ;
  64: CALL 25049 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked , negotiationWithArabs , omarKilled ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// negotiationWithArabs := LoadVariable ( 13a_negotiationWithArabs , false ) ;
  96: LD_ADDR_EXP 19
 100: PUSH
 101: LD_STRING 13a_negotiationWithArabs
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// omarKilled := false ;
 112: LD_ADDR_EXP 20
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// russianDestroyed := false ;
 120: LD_ADDR_EXP 2
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// legionDestroyed := false ;
 128: LD_ADDR_EXP 3
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// americanDestroyed := false ;
 136: LD_ADDR_EXP 4
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// arabianDestroyed := false ;
 144: LD_ADDR_EXP 5
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// americanCapitulated := false ;
 152: LD_ADDR_EXP 6
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// russianCapitulated := false ;
 160: LD_ADDR_EXP 7
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// legionCapitulated := false ;
 168: LD_ADDR_EXP 8
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactIResearched := false ;
 176: LD_ADDR_EXP 12
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// artifactIIResearched := false ;
 184: LD_ADDR_EXP 13
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// artifactIIIResearched := false ;
 192: LD_ADDR_EXP 14
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// alienSpotted := false ;
 200: LD_ADDR_EXP 10
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// spawnOmar := false ;
 208: LD_ADDR_EXP 11
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 224: LD_ADDR_EXP 16
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// allianceTeam := [ ] ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// arabianAttacked := false ;
 239: LD_ADDR_EXP 18
 243: PUSH
 244: LD_INT 0
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 1
 251: RET
// export function CustomInitMacro ( ) ; begin
 252: LD_INT 0
 254: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 255: LD_ADDR_EXP 104
 259: PUSH
 260: LD_INT 26
 262: PUSH
 263: LD_INT 1
 265: PUSH
 266: LD_INT 4
 268: PUSH
 269: LD_INT 8
 271: PUSH
 272: EMPTY
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 278: LD_ADDR_EXP 105
 282: PUSH
 283: LD_INT 27
 285: PUSH
 286: LD_INT 2
 288: PUSH
 289: LD_INT 3
 291: PUSH
 292: LD_INT 7
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 6
 306: PUSH
 307: LD_INT 7
 309: PUSH
 310: LD_INT 9
 312: PUSH
 313: LD_INT 10
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_OWVAR 67
 326: ARRAY
 327: PPUSH
 328: LD_INT 28
 330: PPUSH
 331: CALL 46766 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 335: LD_INT 1
 337: PPUSH
 338: LD_INT 10
 340: PUSH
 341: LD_INT 11
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: LD_INT 15
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: PPUSH
 356: CALL 47845 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 29
 365: PUSH
 366: EMPTY
 367: LIST
 368: PPUSH
 369: CALL 47938 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 373: LD_ADDR_EXP 109
 377: PUSH
 378: LD_EXP 109
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: LD_INT 22
 388: PUSH
 389: LD_INT 2
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: PUSH
 396: LD_INT 25
 398: PUSH
 399: LD_INT 15
 401: PUSH
 402: EMPTY
 403: LIST
 404: LIST
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: PPUSH
 410: CALL_OW 69
 414: PPUSH
 415: CALL_OW 1
 419: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 420: LD_INT 1
 422: PPUSH
 423: LD_INT 13
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 1
 431: PUSH
 432: LD_INT 31
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: PUSH
 441: LD_INT 13
 443: PUSH
 444: LD_INT 2
 446: PUSH
 447: LD_INT 1
 449: PUSH
 450: LD_INT 31
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: PUSH
 459: LD_INT 13
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 1
 467: PUSH
 468: LD_INT 28
 470: PUSH
 471: EMPTY
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 13
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 1
 485: PUSH
 486: LD_INT 28
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: PUSH
 495: LD_INT 13
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 28
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 13
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: LD_INT 1
 521: PUSH
 522: LD_INT 28
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_INT 13
 533: PUSH
 534: LD_INT 1
 536: PUSH
 537: LD_INT 2
 539: PUSH
 540: LD_INT 88
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: LIST
 547: LIST
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL 47103 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 4
 567: PPUSH
 568: CALL 47288 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 572: LD_INT 2
 574: PPUSH
 575: LD_INT 10
 577: PUSH
 578: LD_INT 11
 580: PUSH
 581: LD_INT 12
 583: PUSH
 584: LD_INT 14
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PPUSH
 593: CALL 47845 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 597: LD_INT 2
 599: PPUSH
 600: LD_INT 14
 602: PUSH
 603: EMPTY
 604: LIST
 605: PPUSH
 606: CALL 47938 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 610: LD_INT 2
 612: PPUSH
 613: LD_INT 21
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 51
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 22
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 52
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_INT 24
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 3
 747: PUSH
 748: LD_INT 47
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PPUSH
 767: CALL 47103 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 771: LD_INT 2
 773: PPUSH
 774: LD_INT 5
 776: PPUSH
 777: CALL 47288 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 781: LD_INT 2
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL 47718 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 791: LD_INT 3
 793: PPUSH
 794: LD_INT 10
 796: PUSH
 797: LD_INT 12
 799: PUSH
 800: LD_INT 14
 802: PUSH
 803: LD_INT 15
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: PUSH
 812: LD_OWVAR 67
 816: ARRAY
 817: PPUSH
 818: LD_INT 24
 820: PPUSH
 821: CALL 46766 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 825: LD_INT 3
 827: PPUSH
 828: LD_INT 10
 830: PUSH
 831: LD_INT 11
 833: PUSH
 834: LD_INT 13
 836: PUSH
 837: LD_INT 15
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PPUSH
 846: CALL 47845 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 850: LD_INT 3
 852: PPUSH
 853: LD_INT 13
 855: PUSH
 856: EMPTY
 857: LIST
 858: PPUSH
 859: CALL 47938 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 863: LD_ADDR_EXP 109
 867: PUSH
 868: LD_EXP 109
 872: PPUSH
 873: LD_INT 3
 875: PPUSH
 876: LD_INT 22
 878: PUSH
 879: LD_INT 8
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 25
 888: PUSH
 889: LD_INT 15
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PPUSH
 900: CALL_OW 69
 904: PPUSH
 905: CALL_OW 1
 909: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 910: LD_INT 3
 912: PPUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 2
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 31
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 13
 951: PUSH
 952: LD_INT 3
 954: PUSH
 955: LD_INT 2
 957: PUSH
 958: LD_INT 32
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 28
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PUSH
1039: LD_INT 14
1041: PUSH
1042: LD_INT 1
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 88
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: LIST
1066: PPUSH
1067: CALL 47103 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1071: LD_INT 3
1073: PPUSH
1074: LD_INT 4
1076: PPUSH
1077: CALL 47288 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 10
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 11
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 47845 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 33
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 47938 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 6
1127: PUSH
1128: LD_INT 7
1130: PUSH
1131: LD_INT 9
1133: PUSH
1134: LD_INT 10
1136: PUSH
1137: EMPTY
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 48256 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1148: LD_INT 4
1150: PPUSH
1151: LD_INT 54
1153: PPUSH
1154: LD_INT 85
1156: PPUSH
1157: LD_INT 2
1159: PPUSH
1160: LD_INT 25
1162: PUSH
1163: LD_INT 16
1165: PUSH
1166: LD_INT 17
1168: PUSH
1169: LD_INT 18
1171: PUSH
1172: LD_INT 22
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 48050 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 5
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 1
1197: PUSH
1198: LD_INT 7
1200: PUSH
1201: EMPTY
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 1
1215: PUSH
1216: LD_INT 6
1218: PUSH
1219: EMPTY
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: PUSH
1225: LD_INT 5
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 1
1233: PUSH
1234: LD_INT 7
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: LD_INT 1
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: LD_INT 6
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: LD_INT 1
1266: PUSH
1267: LD_INT 3
1269: PUSH
1270: LD_INT 12
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: PUSH
1279: LD_INT 3
1281: PUSH
1282: LD_INT 1
1284: PUSH
1285: LD_INT 3
1287: PUSH
1288: LD_INT 13
1290: PUSH
1291: EMPTY
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: LIST
1304: PPUSH
1305: CALL 47103 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1309: LD_INT 4
1311: PPUSH
1312: LD_INT 4
1314: PPUSH
1315: CALL 47288 0 2
// MC_SetTame ( 4 , powellApe ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 11
1324: PPUSH
1325: CALL 47669 0 2
// end ;
1329: LD_VAR 0 1
1333: RET
// every 0 0$1 trigger debug do var i ;
1334: LD_EXP 1
1338: IFFALSE 1436
1340: GO 1342
1342: DISABLE
1343: LD_INT 0
1345: PPUSH
// begin enable ;
1346: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1347: LD_ADDR_VAR 0 1
1351: PUSH
1352: LD_INT 22
1354: PUSH
1355: LD_INT 7
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: LD_INT 21
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: PUSH
1375: LD_INT 21
1377: PUSH
1378: LD_INT 2
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 3
1392: PUSH
1393: LD_INT 24
1395: PUSH
1396: LD_INT 1000
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PPUSH
1412: CALL_OW 69
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1434
// SetLives ( i , 1000 ) ;
1420: LD_VAR 0 1
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 234
1432: GO 1417
1434: POP
1435: POP
// end ;
1436: PPOPN 1
1438: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1439: LD_EXP 16
1443: PUSH
1444: LD_INT 5
1446: GREATEREQUAL
1447: IFFALSE 1459
1449: GO 1451
1451: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1452: LD_STRING ACH_ARTIFACT
1454: PPUSH
1455: CALL_OW 543
1459: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1460: LD_INT 0
1462: PPUSH
1463: PPUSH
1464: PPUSH
1465: PPUSH
1466: PPUSH
// SetInvulnrability ( alien , true ) ;
1467: LD_INT 1
1469: PPUSH
1470: LD_INT 1
1472: PPUSH
1473: CALL_OW 607
// uc_side := 7 ;
1477: LD_ADDR_OWVAR 20
1481: PUSH
1482: LD_INT 7
1484: ST_TO_ADDR
// tmp := [ ] ;
1485: LD_ADDR_VAR 0 5
1489: PUSH
1490: EMPTY
1491: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1492: LD_ADDR_EXP 21
1496: PUSH
1497: LD_STRING JMM
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: LD_STRING 14a_
1508: PPUSH
1509: CALL 53577 0 3
1513: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1514: LD_ADDR_EXP 54
1518: PUSH
1519: LD_STRING Burlak
1521: PPUSH
1522: LD_EXP 1
1526: NOT
1527: PPUSH
1528: LD_STRING 14a_
1530: PPUSH
1531: CALL 53577 0 3
1535: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1536: LD_ADDR_EXP 36
1540: PUSH
1541: LD_STRING Joan
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 13a_
1552: PPUSH
1553: CALL 53577 0 3
1557: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1558: LD_ADDR_EXP 22
1562: PUSH
1563: LD_STRING Roth
1565: PPUSH
1566: LD_EXP 1
1570: NOT
1571: PPUSH
1572: LD_STRING 13a_
1574: PPUSH
1575: CALL 53577 0 3
1579: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1580: LD_ADDR_EXP 40
1584: PUSH
1585: LD_STRING Gossudarov
1587: PPUSH
1588: LD_EXP 1
1592: NOT
1593: PPUSH
1594: LD_STRING 13a_
1596: PPUSH
1597: CALL 53577 0 3
1601: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1602: LD_ADDR_EXP 27
1606: PUSH
1607: LD_STRING Denis
1609: PPUSH
1610: LD_EXP 1
1614: NOT
1615: PPUSH
1616: LD_STRING 13a_
1618: PPUSH
1619: CALL 53577 0 3
1623: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1624: LD_ADDR_EXP 37
1628: PUSH
1629: LD_STRING DeltaDoctor
1631: PPUSH
1632: LD_EXP 1
1636: NOT
1637: PPUSH
1638: LD_STRING 13a_
1640: PPUSH
1641: CALL 53577 0 3
1645: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1646: LD_ADDR_EXP 39
1650: PUSH
1651: LD_STRING Mike
1653: PPUSH
1654: LD_EXP 1
1658: NOT
1659: PPUSH
1660: LD_STRING 13a_
1662: PPUSH
1663: CALL 53577 0 3
1667: ST_TO_ADDR
// if DeltaDoctor then
1668: LD_EXP 37
1672: IFFALSE 1690
// tmp := tmp ^ DeltaDoctor ;
1674: LD_ADDR_VAR 0 5
1678: PUSH
1679: LD_VAR 0 5
1683: PUSH
1684: LD_EXP 37
1688: ADD
1689: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1690: LD_ADDR_EXP 35
1694: PUSH
1695: LD_STRING Simms
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 13a_
1706: PPUSH
1707: CALL 53577 0 3
1711: ST_TO_ADDR
// if Simms then
1712: LD_EXP 35
1716: IFFALSE 1734
// tmp := tmp ^ Simms ;
1718: LD_ADDR_VAR 0 5
1722: PUSH
1723: LD_VAR 0 5
1727: PUSH
1728: LD_EXP 35
1732: ADD
1733: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1734: LD_ADDR_EXP 33
1738: PUSH
1739: LD_STRING Frank
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 13a_
1750: PPUSH
1751: CALL 53577 0 3
1755: ST_TO_ADDR
// if Frank then
1756: LD_EXP 33
1760: IFFALSE 1778
// tmp := tmp ^ Frank ;
1762: LD_ADDR_VAR 0 5
1766: PUSH
1767: LD_VAR 0 5
1771: PUSH
1772: LD_EXP 33
1776: ADD
1777: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1778: LD_ADDR_EXP 41
1782: PUSH
1783: LD_STRING Kirilenkova
1785: PPUSH
1786: LD_EXP 1
1790: NOT
1791: PPUSH
1792: LD_STRING 13a_
1794: PPUSH
1795: CALL 53577 0 3
1799: ST_TO_ADDR
// if Kirilenkova then
1800: LD_EXP 41
1804: IFFALSE 1822
// tmp := tmp ^ Kirilenkova ;
1806: LD_ADDR_VAR 0 5
1810: PUSH
1811: LD_VAR 0 5
1815: PUSH
1816: LD_EXP 41
1820: ADD
1821: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1822: LD_ADDR_EXP 42
1826: PUSH
1827: LD_STRING Titov
1829: PPUSH
1830: LD_EXP 1
1834: NOT
1835: PPUSH
1836: LD_STRING 13a_
1838: PPUSH
1839: CALL 53577 0 3
1843: ST_TO_ADDR
// if Titov then
1844: LD_EXP 42
1848: IFFALSE 1866
// tmp := tmp ^ Titov ;
1850: LD_ADDR_VAR 0 5
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 42
1864: ADD
1865: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1866: LD_ADDR_EXP 43
1870: PUSH
1871: LD_STRING Fadeev
1873: PPUSH
1874: LD_EXP 1
1878: NOT
1879: PPUSH
1880: LD_STRING 13a_
1882: PPUSH
1883: CALL 53577 0 3
1887: ST_TO_ADDR
// if Fadeev then
1888: LD_EXP 43
1892: IFFALSE 1910
// tmp := tmp ^ Fadeev ;
1894: LD_ADDR_VAR 0 5
1898: PUSH
1899: LD_VAR 0 5
1903: PUSH
1904: LD_EXP 43
1908: ADD
1909: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1910: LD_ADDR_EXP 44
1914: PUSH
1915: LD_STRING Dolgov
1917: PPUSH
1918: LD_EXP 1
1922: NOT
1923: PPUSH
1924: LD_STRING 13a_
1926: PPUSH
1927: CALL 53577 0 3
1931: ST_TO_ADDR
// if Dolgov then
1932: LD_EXP 44
1936: IFFALSE 1954
// tmp := tmp ^ Dolgov ;
1938: LD_ADDR_VAR 0 5
1942: PUSH
1943: LD_VAR 0 5
1947: PUSH
1948: LD_EXP 44
1952: ADD
1953: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1954: LD_ADDR_EXP 45
1958: PUSH
1959: LD_STRING Petrosyan
1961: PPUSH
1962: LD_EXP 1
1966: NOT
1967: PPUSH
1968: LD_STRING 13a_
1970: PPUSH
1971: CALL 53577 0 3
1975: ST_TO_ADDR
// if Petrosyan then
1976: LD_EXP 45
1980: IFFALSE 1998
// tmp := tmp ^ Petrosyan ;
1982: LD_ADDR_VAR 0 5
1986: PUSH
1987: LD_VAR 0 5
1991: PUSH
1992: LD_EXP 45
1996: ADD
1997: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1998: LD_ADDR_EXP 46
2002: PUSH
2003: LD_STRING Scholtze
2005: PPUSH
2006: LD_EXP 1
2010: NOT
2011: PPUSH
2012: LD_STRING 13a_
2014: PPUSH
2015: CALL 53577 0 3
2019: ST_TO_ADDR
// if Scholtze then
2020: LD_EXP 46
2024: IFFALSE 2042
// tmp := tmp ^ Scholtze ;
2026: LD_ADDR_VAR 0 5
2030: PUSH
2031: LD_VAR 0 5
2035: PUSH
2036: LD_EXP 46
2040: ADD
2041: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2042: LD_ADDR_EXP 47
2046: PUSH
2047: LD_STRING Oblukov
2049: PPUSH
2050: LD_EXP 1
2054: NOT
2055: PPUSH
2056: LD_STRING 13a_
2058: PPUSH
2059: CALL 53577 0 3
2063: ST_TO_ADDR
// if Oblukov then
2064: LD_EXP 47
2068: IFFALSE 2086
// tmp := tmp ^ Oblukov ;
2070: LD_ADDR_VAR 0 5
2074: PUSH
2075: LD_VAR 0 5
2079: PUSH
2080: LD_EXP 47
2084: ADD
2085: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2086: LD_ADDR_EXP 48
2090: PUSH
2091: LD_STRING Kapitsova
2093: PPUSH
2094: LD_EXP 1
2098: NOT
2099: PPUSH
2100: LD_STRING 13a_
2102: PPUSH
2103: CALL 53577 0 3
2107: ST_TO_ADDR
// if Kapitsova then
2108: LD_EXP 48
2112: IFFALSE 2130
// tmp := tmp ^ Kapitsova ;
2114: LD_ADDR_VAR 0 5
2118: PUSH
2119: LD_VAR 0 5
2123: PUSH
2124: LD_EXP 48
2128: ADD
2129: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2130: LD_ADDR_EXP 49
2134: PUSH
2135: LD_STRING Lipshchin
2137: PPUSH
2138: LD_EXP 1
2142: NOT
2143: PPUSH
2144: LD_STRING 13a_
2146: PPUSH
2147: CALL 53577 0 3
2151: ST_TO_ADDR
// if Lipshchin then
2152: LD_EXP 49
2156: IFFALSE 2174
// tmp := tmp ^ Lipshchin ;
2158: LD_ADDR_VAR 0 5
2162: PUSH
2163: LD_VAR 0 5
2167: PUSH
2168: LD_EXP 49
2172: ADD
2173: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2174: LD_ADDR_EXP 50
2178: PUSH
2179: LD_STRING Petrovova
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13a_
2190: PPUSH
2191: CALL 53577 0 3
2195: ST_TO_ADDR
// if Petrovova then
2196: LD_EXP 50
2200: IFFALSE 2218
// tmp := tmp ^ Petrovova ;
2202: LD_ADDR_VAR 0 5
2206: PUSH
2207: LD_VAR 0 5
2211: PUSH
2212: LD_EXP 50
2216: ADD
2217: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2218: LD_ADDR_EXP 51
2222: PUSH
2223: LD_STRING Kovalyuk
2225: PPUSH
2226: LD_EXP 1
2230: NOT
2231: PPUSH
2232: LD_STRING 13a_
2234: PPUSH
2235: CALL 53577 0 3
2239: ST_TO_ADDR
// if Kovalyuk then
2240: LD_EXP 51
2244: IFFALSE 2262
// tmp := tmp ^ Kovalyuk ;
2246: LD_ADDR_VAR 0 5
2250: PUSH
2251: LD_VAR 0 5
2255: PUSH
2256: LD_EXP 51
2260: ADD
2261: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2262: LD_ADDR_EXP 52
2266: PUSH
2267: LD_STRING Kuzmov
2269: PPUSH
2270: LD_EXP 1
2274: NOT
2275: PPUSH
2276: LD_STRING 13a_
2278: PPUSH
2279: CALL 53577 0 3
2283: ST_TO_ADDR
// if Kuzmov then
2284: LD_EXP 52
2288: IFFALSE 2306
// tmp := tmp ^ Kuzmov ;
2290: LD_ADDR_VAR 0 5
2294: PUSH
2295: LD_VAR 0 5
2299: PUSH
2300: LD_EXP 52
2304: ADD
2305: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 53
2310: PUSH
2311: LD_STRING Karamazov
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 53577 0 3
2327: ST_TO_ADDR
// if Karamazov then
2328: LD_EXP 53
2332: IFFALSE 2350
// tmp := tmp ^ Karamazov ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 53
2348: ADD
2349: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2350: LD_ADDR_EXP 55
2354: PUSH
2355: LD_STRING Belkov
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13a_
2366: PPUSH
2367: CALL 53577 0 3
2371: ST_TO_ADDR
// if Belkov then
2372: LD_EXP 55
2376: IFFALSE 2394
// tmp := tmp ^ Belkov ;
2378: LD_ADDR_VAR 0 5
2382: PUSH
2383: LD_VAR 0 5
2387: PUSH
2388: LD_EXP 55
2392: ADD
2393: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2394: LD_ADDR_EXP 56
2398: PUSH
2399: LD_STRING Gnyevko
2401: PPUSH
2402: LD_EXP 1
2406: NOT
2407: PPUSH
2408: LD_STRING 13a_
2410: PPUSH
2411: CALL 53577 0 3
2415: ST_TO_ADDR
// if Gnyevko then
2416: LD_EXP 56
2420: IFFALSE 2438
// tmp := tmp ^ Gnyevko ;
2422: LD_ADDR_VAR 0 5
2426: PUSH
2427: LD_VAR 0 5
2431: PUSH
2432: LD_EXP 56
2436: ADD
2437: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING Coonie
2445: PPUSH
2446: CALL_OW 25
2450: ST_TO_ADDR
// if not Lisa then
2451: LD_EXP 23
2455: NOT
2456: IFFALSE 2502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2458: LD_ADDR_EXP 23
2462: PUSH
2463: LD_STRING Lisa
2465: PPUSH
2466: LD_EXP 1
2470: NOT
2471: PPUSH
2472: LD_STRING 13a_
2474: PPUSH
2475: CALL 53577 0 3
2479: ST_TO_ADDR
// if Lisa then
2480: LD_EXP 23
2484: IFFALSE 2502
// tmp := tmp ^ Lisa ;
2486: LD_ADDR_VAR 0 5
2490: PUSH
2491: LD_VAR 0 5
2495: PUSH
2496: LD_EXP 23
2500: ADD
2501: ST_TO_ADDR
// end ; if not Donaldson then
2502: LD_EXP 24
2506: NOT
2507: IFFALSE 2553
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2509: LD_ADDR_EXP 24
2513: PUSH
2514: LD_STRING Donaldson
2516: PPUSH
2517: LD_EXP 1
2521: NOT
2522: PPUSH
2523: LD_STRING 13a_
2525: PPUSH
2526: CALL 53577 0 3
2530: ST_TO_ADDR
// if Donaldson then
2531: LD_EXP 24
2535: IFFALSE 2553
// tmp := tmp ^ Donaldson ;
2537: LD_ADDR_VAR 0 5
2541: PUSH
2542: LD_VAR 0 5
2546: PUSH
2547: LD_EXP 24
2551: ADD
2552: ST_TO_ADDR
// end ; if not Bobby then
2553: LD_EXP 25
2557: NOT
2558: IFFALSE 2604
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2560: LD_ADDR_EXP 25
2564: PUSH
2565: LD_STRING Bobby
2567: PPUSH
2568: LD_EXP 1
2572: NOT
2573: PPUSH
2574: LD_STRING 13a_
2576: PPUSH
2577: CALL 53577 0 3
2581: ST_TO_ADDR
// if Bobby then
2582: LD_EXP 25
2586: IFFALSE 2604
// tmp := tmp ^ Bobby ;
2588: LD_ADDR_VAR 0 5
2592: PUSH
2593: LD_VAR 0 5
2597: PUSH
2598: LD_EXP 25
2602: ADD
2603: ST_TO_ADDR
// end ; if not Cyrus then
2604: LD_EXP 26
2608: NOT
2609: IFFALSE 2655
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2611: LD_ADDR_EXP 26
2615: PUSH
2616: LD_STRING Cyrus
2618: PPUSH
2619: LD_EXP 1
2623: NOT
2624: PPUSH
2625: LD_STRING 13a_
2627: PPUSH
2628: CALL 53577 0 3
2632: ST_TO_ADDR
// if Cyrus then
2633: LD_EXP 26
2637: IFFALSE 2655
// tmp := tmp ^ Cyrus ;
2639: LD_ADDR_VAR 0 5
2643: PUSH
2644: LD_VAR 0 5
2648: PUSH
2649: LD_EXP 26
2653: ADD
2654: ST_TO_ADDR
// end ; if not Brown then
2655: LD_EXP 28
2659: NOT
2660: IFFALSE 2706
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2662: LD_ADDR_EXP 28
2666: PUSH
2667: LD_STRING Brown
2669: PPUSH
2670: LD_EXP 1
2674: NOT
2675: PPUSH
2676: LD_STRING 13a_
2678: PPUSH
2679: CALL 53577 0 3
2683: ST_TO_ADDR
// if Brown then
2684: LD_EXP 28
2688: IFFALSE 2706
// tmp := tmp ^ Brown ;
2690: LD_ADDR_VAR 0 5
2694: PUSH
2695: LD_VAR 0 5
2699: PUSH
2700: LD_EXP 28
2704: ADD
2705: ST_TO_ADDR
// end ; if not Gladstone then
2706: LD_EXP 29
2710: NOT
2711: IFFALSE 2757
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2713: LD_ADDR_EXP 29
2717: PUSH
2718: LD_STRING Gladstone
2720: PPUSH
2721: LD_EXP 1
2725: NOT
2726: PPUSH
2727: LD_STRING 13a_
2729: PPUSH
2730: CALL 53577 0 3
2734: ST_TO_ADDR
// if Gladstone then
2735: LD_EXP 29
2739: IFFALSE 2757
// tmp := tmp ^ Gladstone ;
2741: LD_ADDR_VAR 0 5
2745: PUSH
2746: LD_VAR 0 5
2750: PUSH
2751: LD_EXP 29
2755: ADD
2756: ST_TO_ADDR
// end ; if not Cornel then
2757: LD_EXP 31
2761: NOT
2762: IFFALSE 2808
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2764: LD_ADDR_EXP 31
2768: PUSH
2769: LD_STRING Cornel
2771: PPUSH
2772: LD_EXP 1
2776: NOT
2777: PPUSH
2778: LD_STRING 13a_
2780: PPUSH
2781: CALL 53577 0 3
2785: ST_TO_ADDR
// if Cornel then
2786: LD_EXP 31
2790: IFFALSE 2808
// tmp := tmp ^ Cornel ;
2792: LD_ADDR_VAR 0 5
2796: PUSH
2797: LD_VAR 0 5
2801: PUSH
2802: LD_EXP 31
2806: ADD
2807: ST_TO_ADDR
// end ; if not Houten then
2808: LD_EXP 30
2812: NOT
2813: IFFALSE 2859
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2815: LD_ADDR_EXP 30
2819: PUSH
2820: LD_STRING Houten
2822: PPUSH
2823: LD_EXP 1
2827: NOT
2828: PPUSH
2829: LD_STRING 13a_
2831: PPUSH
2832: CALL 53577 0 3
2836: ST_TO_ADDR
// if Houten then
2837: LD_EXP 30
2841: IFFALSE 2859
// tmp := tmp ^ Houten ;
2843: LD_ADDR_VAR 0 5
2847: PUSH
2848: LD_VAR 0 5
2852: PUSH
2853: LD_EXP 30
2857: ADD
2858: ST_TO_ADDR
// end ; if not Gary then
2859: LD_EXP 32
2863: NOT
2864: IFFALSE 2910
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2866: LD_ADDR_EXP 32
2870: PUSH
2871: LD_STRING Gary
2873: PPUSH
2874: LD_EXP 1
2878: NOT
2879: PPUSH
2880: LD_STRING 13a_
2882: PPUSH
2883: CALL 53577 0 3
2887: ST_TO_ADDR
// if Gary then
2888: LD_EXP 32
2892: IFFALSE 2910
// tmp := tmp ^ Gary ;
2894: LD_ADDR_VAR 0 5
2898: PUSH
2899: LD_VAR 0 5
2903: PUSH
2904: LD_EXP 32
2908: ADD
2909: ST_TO_ADDR
// end ; if not Kikuchi then
2910: LD_EXP 34
2914: NOT
2915: IFFALSE 2961
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2917: LD_ADDR_EXP 34
2921: PUSH
2922: LD_STRING Kikuchi
2924: PPUSH
2925: LD_EXP 1
2929: NOT
2930: PPUSH
2931: LD_STRING 13a_
2933: PPUSH
2934: CALL 53577 0 3
2938: ST_TO_ADDR
// if Kikuchi then
2939: LD_EXP 34
2943: IFFALSE 2961
// tmp := tmp ^ Kikuchi ;
2945: LD_ADDR_VAR 0 5
2949: PUSH
2950: LD_VAR 0 5
2954: PUSH
2955: LD_EXP 34
2959: ADD
2960: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2961: LD_ADDR_VAR 0 5
2965: PUSH
2966: LD_VAR 0 5
2970: PUSH
2971: LD_STRING 13a_others
2973: PPUSH
2974: CALL_OW 31
2978: UNION
2979: ST_TO_ADDR
// tmp := tmp diff 0 ;
2980: LD_ADDR_VAR 0 5
2984: PUSH
2985: LD_VAR 0 5
2989: PUSH
2990: LD_INT 0
2992: DIFF
2993: ST_TO_ADDR
// if tmp < 15 then
2994: LD_VAR 0 5
2998: PUSH
2999: LD_INT 15
3001: LESS
3002: IFFALSE 3090
// for i = 15 downto tmp do
3004: LD_ADDR_VAR 0 2
3008: PUSH
3009: DOUBLE
3010: LD_INT 15
3012: INC
3013: ST_TO_ADDR
3014: LD_VAR 0 5
3018: PUSH
3019: FOR_DOWNTO
3020: IFFALSE 3088
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 1
3039: PPUSH
3040: LD_INT 2
3042: PPUSH
3043: CALL_OW 12
3047: ARRAY
3048: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3049: LD_INT 0
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: LD_INT 4
3057: PPUSH
3058: CALL_OW 12
3062: PPUSH
3063: LD_INT 8
3065: PPUSH
3066: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3070: LD_ADDR_VAR 0 5
3074: PUSH
3075: LD_VAR 0 5
3079: PUSH
3080: CALL_OW 44
3084: ADD
3085: ST_TO_ADDR
// end ;
3086: GO 3019
3088: POP
3089: POP
// if not debug then
3090: LD_EXP 1
3094: NOT
3095: IFFALSE 3275
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3097: LD_ADDR_VAR 0 4
3101: PUSH
3102: LD_STRING 
3104: PPUSH
3105: LD_INT 14
3107: PUSH
3108: LD_INT 13
3110: PUSH
3111: LD_INT 12
3113: PUSH
3114: LD_INT 11
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_OWVAR 67
3127: ARRAY
3128: PPUSH
3129: LD_INT 14
3131: PUSH
3132: LD_INT 13
3134: PUSH
3135: LD_INT 12
3137: PUSH
3138: LD_INT 11
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: PUSH
3147: LD_OWVAR 67
3151: ARRAY
3152: PPUSH
3153: LD_INT -5
3155: PUSH
3156: LD_EXP 21
3160: PUSH
3161: LD_EXP 54
3165: PUSH
3166: LD_EXP 22
3170: PUSH
3171: LD_EXP 36
3175: PUSH
3176: LD_EXP 27
3180: PUSH
3181: LD_EXP 40
3185: PUSH
3186: LD_INT -2
3188: PUSH
3189: LD_INT -3
3191: PUSH
3192: LD_INT -5
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: PUSH
3207: LD_VAR 0 5
3211: ADD
3212: PPUSH
3213: LD_INT 1
3215: PUSH
3216: LD_INT 4
3218: PUSH
3219: LD_INT 2
3221: PUSH
3222: LD_INT 1
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 5
3234: PUSH
3235: LD_INT 0
3237: PUSH
3238: LD_INT 3
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: PUSH
3246: LD_INT 9
3248: PUSH
3249: LD_INT 0
3251: PUSH
3252: LD_INT 3
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: PPUSH
3268: CALL_OW 42
3272: ST_TO_ADDR
3273: GO 3324
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_EXP 42
3284: PUSH
3285: LD_EXP 43
3289: PUSH
3290: LD_EXP 44
3294: PUSH
3295: LD_EXP 45
3299: PUSH
3300: LD_EXP 46
3304: PUSH
3305: LD_EXP 47
3309: PUSH
3310: LD_EXP 48
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: LIST
3319: LIST
3320: LIST
3321: LIST
3322: LIST
3323: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3324: LD_ADDR_EXP 17
3328: PUSH
3329: LD_VAR 0 5
3333: PUSH
3334: LD_VAR 0 4
3338: DIFF
3339: ST_TO_ADDR
// uc_nation := 1 ;
3340: LD_ADDR_OWVAR 21
3344: PUSH
3345: LD_INT 1
3347: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3348: LD_INT 5
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 1
3356: PPUSH
3357: LD_INT 6
3359: PPUSH
3360: LD_INT 100
3362: PPUSH
3363: CALL 58438 0 5
// veh := CreateVehicle ;
3367: LD_ADDR_VAR 0 3
3371: PUSH
3372: CALL_OW 45
3376: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3377: LD_VAR 0 3
3381: PPUSH
3382: LD_INT 7
3384: NEG
3385: PPUSH
3386: CALL_OW 242
// SetDir ( veh , 3 ) ;
3390: LD_VAR 0 3
3394: PPUSH
3395: LD_INT 3
3397: PPUSH
3398: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3402: LD_VAR 0 3
3406: PPUSH
3407: LD_INT 31
3409: PPUSH
3410: LD_INT 0
3412: PPUSH
3413: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3417: LD_EXP 21
3421: PPUSH
3422: LD_VAR 0 3
3426: PPUSH
3427: CALL_OW 52
// if Joan then
3431: LD_EXP 36
3435: IFFALSE 3507
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 3
3442: PPUSH
3443: LD_INT 1
3445: PPUSH
3446: LD_INT 11
3448: PPUSH
3449: LD_INT 100
3451: PPUSH
3452: CALL 58438 0 5
// veh := CreateVehicle ;
3456: LD_ADDR_VAR 0 3
3460: PUSH
3461: CALL_OW 45
3465: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3466: LD_VAR 0 3
3470: PPUSH
3471: LD_INT 3
3473: PPUSH
3474: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3478: LD_VAR 0 3
3482: PPUSH
3483: LD_INT 30
3485: PPUSH
3486: LD_INT 0
3488: PPUSH
3489: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3493: LD_EXP 36
3497: PPUSH
3498: LD_VAR 0 3
3502: PPUSH
3503: CALL_OW 52
// end ; if Roth then
3507: LD_EXP 22
3511: IFFALSE 3583
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 1
3521: PPUSH
3522: LD_INT 11
3524: PPUSH
3525: LD_INT 100
3527: PPUSH
3528: CALL 58438 0 5
// veh := CreateVehicle ;
3532: LD_ADDR_VAR 0 3
3536: PUSH
3537: CALL_OW 45
3541: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3542: LD_VAR 0 3
3546: PPUSH
3547: LD_INT 3
3549: PPUSH
3550: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3554: LD_VAR 0 3
3558: PPUSH
3559: LD_INT 30
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3569: LD_EXP 22
3573: PPUSH
3574: LD_VAR 0 3
3578: PPUSH
3579: CALL_OW 52
// end ; if Denis then
3583: LD_EXP 27
3587: IFFALSE 3659
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3589: LD_INT 5
3591: PPUSH
3592: LD_INT 3
3594: PPUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 9
3600: PPUSH
3601: LD_INT 100
3603: PPUSH
3604: CALL 58438 0 5
// veh := CreateVehicle ;
3608: LD_ADDR_VAR 0 3
3612: PUSH
3613: CALL_OW 45
3617: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3618: LD_VAR 0 3
3622: PPUSH
3623: LD_INT 3
3625: PPUSH
3626: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3630: LD_VAR 0 3
3634: PPUSH
3635: LD_INT 30
3637: PPUSH
3638: LD_INT 0
3640: PPUSH
3641: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3645: LD_EXP 27
3649: PPUSH
3650: LD_VAR 0 3
3654: PPUSH
3655: CALL_OW 52
// end ; uc_nation := 3 ;
3659: LD_ADDR_OWVAR 21
3663: PUSH
3664: LD_INT 3
3666: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3667: LD_INT 22
3669: PPUSH
3670: LD_INT 3
3672: PPUSH
3673: LD_INT 1
3675: PPUSH
3676: LD_INT 45
3678: PPUSH
3679: LD_INT 100
3681: PPUSH
3682: CALL 58438 0 5
// veh := CreateVehicle ;
3686: LD_ADDR_VAR 0 3
3690: PUSH
3691: CALL_OW 45
3695: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3696: LD_VAR 0 3
3700: PPUSH
3701: LD_INT 7
3703: NEG
3704: PPUSH
3705: CALL_OW 242
// SetDir ( veh , 3 ) ;
3709: LD_VAR 0 3
3713: PPUSH
3714: LD_INT 3
3716: PPUSH
3717: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3721: LD_VAR 0 3
3725: PPUSH
3726: LD_INT 31
3728: PPUSH
3729: LD_INT 0
3731: PPUSH
3732: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3736: LD_EXP 54
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 52
// if Gossudarov then
3750: LD_EXP 40
3754: IFFALSE 3841
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3756: LD_INT 22
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 51
3767: PPUSH
3768: LD_INT 100
3770: PPUSH
3771: CALL 58438 0 5
// veh := CreateVehicle ;
3775: LD_ADDR_VAR 0 3
3779: PUSH
3780: CALL_OW 45
3784: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3785: LD_VAR 0 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3797: LD_VAR 0 3
3801: PPUSH
3802: LD_INT 30
3804: PPUSH
3805: LD_INT 0
3807: PPUSH
3808: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3812: LD_EXP 40
3816: PPUSH
3817: LD_VAR 0 3
3821: PPUSH
3822: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3826: LD_VAR 0 3
3830: PPUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 100
3836: PPUSH
3837: CALL_OW 290
// end ; if Mike then
3841: LD_EXP 39
3845: IFFALSE 3862
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3847: LD_EXP 39
3851: PPUSH
3852: LD_INT 30
3854: PPUSH
3855: LD_INT 0
3857: PPUSH
3858: CALL_OW 49
// for i in selected do
3862: LD_ADDR_VAR 0 2
3866: PUSH
3867: LD_VAR 0 4
3871: PUSH
3872: FOR_IN
3873: IFFALSE 4431
// begin uc_nation := GetNation ( i ) ;
3875: LD_ADDR_OWVAR 21
3879: PUSH
3880: LD_VAR 0 2
3884: PPUSH
3885: CALL_OW 248
3889: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3890: LD_VAR 0 2
3894: PUSH
3895: LD_EXP 23
3899: PUSH
3900: LD_EXP 24
3904: PUSH
3905: LD_EXP 26
3909: PUSH
3910: LD_EXP 25
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: IN
3921: IFFALSE 3944
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3923: LD_INT 5
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 1
3931: PPUSH
3932: LD_INT 6
3934: PPUSH
3935: LD_INT 100
3937: PPUSH
3938: CALL 58438 0 5
3942: GO 4378
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3944: LD_VAR 0 2
3948: PUSH
3949: LD_EXP 47
3953: PUSH
3954: LD_EXP 52
3958: PUSH
3959: LD_EXP 50
3963: PUSH
3964: LD_EXP 42
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: LIST
3973: LIST
3974: IN
3975: IFFALSE 4006
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3977: LD_INT 24
3979: PPUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_INT 1
3985: PPUSH
3986: LD_INT 46
3988: PPUSH
3989: LD_INT 65
3991: PPUSH
3992: LD_INT 75
3994: PPUSH
3995: CALL_OW 12
3999: PPUSH
4000: CALL 58438 0 5
4004: GO 4378
// if i = Karamazov then
4006: LD_VAR 0 2
4010: PUSH
4011: LD_EXP 53
4015: EQUAL
4016: IFFALSE 4039
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
4018: LD_INT 22
4020: PPUSH
4021: LD_INT 3
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 52
4029: PPUSH
4030: LD_INT 100
4032: PPUSH
4033: CALL 58438 0 5
4037: GO 4378
// if i = Brown then
4039: LD_VAR 0 2
4043: PUSH
4044: LD_EXP 28
4048: EQUAL
4049: IFFALSE 4072
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 3
4056: PPUSH
4057: LD_INT 1
4059: PPUSH
4060: LD_INT 13
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 58438 0 5
4070: GO 4378
// if uc_nation = nation_american then
4072: LD_OWVAR 21
4076: PUSH
4077: LD_INT 1
4079: EQUAL
4080: IFFALSE 4231
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4082: LD_INT 3
4084: PUSH
4085: LD_INT 5
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: PUSH
4096: LD_OWVAR 21
4100: PUSH
4101: LD_INT 3
4103: MOD
4104: PUSH
4105: LD_INT 1
4107: PLUS
4108: ARRAY
4109: PPUSH
4110: LD_INT 1
4112: PUSH
4113: LD_INT 3
4115: PUSH
4116: LD_INT 1
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: LIST
4123: PUSH
4124: LD_OWVAR 21
4128: PUSH
4129: LD_INT 3
4131: MOD
4132: PUSH
4133: LD_INT 1
4135: PLUS
4136: ARRAY
4137: PPUSH
4138: LD_INT 1
4140: PPUSH
4141: LD_INT 11
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: LD_INT 5
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: LD_INT 6
4157: PUSH
4158: LD_INT 7
4160: PUSH
4161: LD_INT 9
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: PUSH
4169: LD_INT 6
4171: PUSH
4172: LD_INT 9
4174: PUSH
4175: LD_INT 12
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: LIST
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: LIST
4187: PUSH
4188: LD_OWVAR 21
4192: PUSH
4193: LD_INT 3
4195: MOD
4196: PUSH
4197: LD_INT 1
4199: PLUS
4200: ARRAY
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: PPUSH
4214: LD_INT 65
4216: PPUSH
4217: LD_INT 75
4219: PPUSH
4220: CALL_OW 12
4224: PPUSH
4225: CALL 58438 0 5
// end else
4229: GO 4378
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4231: LD_INT 22
4233: PUSH
4234: LD_INT 23
4236: PUSH
4237: LD_INT 23
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PUSH
4245: LD_OWVAR 21
4249: PUSH
4250: LD_INT 3
4252: MOD
4253: PUSH
4254: LD_INT 1
4256: PLUS
4257: ARRAY
4258: PPUSH
4259: LD_INT 1
4261: PUSH
4262: LD_INT 3
4264: PUSH
4265: LD_INT 1
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: LIST
4272: PUSH
4273: LD_OWVAR 21
4277: PUSH
4278: LD_INT 3
4280: MOD
4281: PUSH
4282: LD_INT 1
4284: PLUS
4285: ARRAY
4286: PPUSH
4287: LD_INT 1
4289: PPUSH
4290: LD_INT 45
4292: PUSH
4293: LD_INT 43
4295: PUSH
4296: LD_INT 44
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 46
4306: PUSH
4307: LD_INT 45
4309: PUSH
4310: LD_INT 44
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: PUSH
4318: LD_INT 46
4320: PUSH
4321: LD_INT 43
4323: PUSH
4324: LD_INT 45
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: LIST
4336: PUSH
4337: LD_OWVAR 21
4341: PUSH
4342: LD_INT 3
4344: MOD
4345: PUSH
4346: LD_INT 1
4348: PLUS
4349: ARRAY
4350: PUSH
4351: LD_INT 1
4353: PPUSH
4354: LD_INT 3
4356: PPUSH
4357: CALL_OW 12
4361: ARRAY
4362: PPUSH
4363: LD_INT 65
4365: PPUSH
4366: LD_INT 75
4368: PPUSH
4369: CALL_OW 12
4373: PPUSH
4374: CALL 58438 0 5
// end ; veh := CreateVehicle ;
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: CALL_OW 45
4387: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4388: LD_VAR 0 3
4392: PPUSH
4393: LD_INT 3
4395: PPUSH
4396: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4400: LD_VAR 0 3
4404: PPUSH
4405: LD_INT 30
4407: PPUSH
4408: LD_INT 0
4410: PPUSH
4411: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4415: LD_VAR 0 2
4419: PPUSH
4420: LD_VAR 0 3
4424: PPUSH
4425: CALL_OW 52
// end ;
4429: GO 3872
4431: POP
4432: POP
// if artifactArCaptured then
4433: LD_EXP 9
4437: IFFALSE 4523
// begin uc_nation := nation_american ;
4439: LD_ADDR_OWVAR 21
4443: PUSH
4444: LD_INT 1
4446: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4447: LD_INT 3
4449: PPUSH
4450: LD_INT 3
4452: PPUSH
4453: LD_INT 3
4455: PPUSH
4456: LD_INT 12
4458: PPUSH
4459: LD_INT 100
4461: PPUSH
4462: CALL 58438 0 5
// veh := CreateVehicle ;
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: CALL_OW 45
4475: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 3
4483: PPUSH
4484: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4488: LD_VAR 0 3
4492: PPUSH
4493: LD_INT 198
4495: PPUSH
4496: LD_INT 22
4498: PPUSH
4499: LD_INT 0
4501: PPUSH
4502: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4506: LD_VAR 0 3
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 50
4516: PPUSH
4517: CALL_OW 290
// end else
4521: GO 4542
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4523: LD_INT 4
4525: PPUSH
4526: LD_INT 5
4528: PPUSH
4529: LD_INT 267
4531: PPUSH
4532: LD_INT 226
4534: PPUSH
4535: LD_INT 0
4537: PPUSH
4538: CALL_OW 58
// end ; uc_nation := nation_american ;
4542: LD_ADDR_OWVAR 21
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4550: LD_INT 3
4552: PPUSH
4553: LD_INT 3
4555: PPUSH
4556: LD_INT 3
4558: PPUSH
4559: LD_INT 12
4561: PPUSH
4562: LD_INT 100
4564: PPUSH
4565: CALL 58438 0 5
// veh := CreateVehicle ;
4569: LD_ADDR_VAR 0 3
4573: PUSH
4574: CALL_OW 45
4578: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4579: LD_VAR 0 3
4583: PPUSH
4584: LD_INT 3
4586: PPUSH
4587: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 218
4598: PPUSH
4599: LD_INT 23
4601: PPUSH
4602: LD_INT 0
4604: PPUSH
4605: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4609: LD_VAR 0 3
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 30
4619: PPUSH
4620: CALL_OW 290
// uc_nation := nation_russian ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 3
4631: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4632: LD_INT 22
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 51
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 58438 0 5
// veh := CreateVehicle ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4661: LD_VAR 0 3
4665: PPUSH
4666: LD_INT 3
4668: PPUSH
4669: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4673: LD_VAR 0 3
4677: PPUSH
4678: LD_INT 214
4680: PPUSH
4681: LD_INT 20
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4691: LD_VAR 0 3
4695: PPUSH
4696: LD_INT 4
4698: PPUSH
4699: LD_INT 40
4701: PPUSH
4702: CALL_OW 290
// end ;
4706: LD_VAR 0 1
4710: RET
// export function AllianceSupport ; var i , veh ; begin
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
// if not allianceTeam then
4716: LD_EXP 17
4720: NOT
4721: IFFALSE 4725
// exit ;
4723: GO 5131
// for i := 1 to 6 do
4725: LD_ADDR_VAR 0 2
4729: PUSH
4730: DOUBLE
4731: LD_INT 1
4733: DEC
4734: ST_TO_ADDR
4735: LD_INT 6
4737: PUSH
4738: FOR_TO
4739: IFFALSE 5035
// begin uc_side := 7 ;
4741: LD_ADDR_OWVAR 20
4745: PUSH
4746: LD_INT 7
4748: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4749: LD_ADDR_OWVAR 21
4753: PUSH
4754: LD_INT 1
4756: PUSH
4757: LD_INT 3
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: PUSH
4764: LD_VAR 0 2
4768: PUSH
4769: LD_INT 2
4771: MOD
4772: PUSH
4773: LD_INT 1
4775: PLUS
4776: ARRAY
4777: ST_TO_ADDR
// if uc_nation = 1 then
4778: LD_OWVAR 21
4782: PUSH
4783: LD_INT 1
4785: EQUAL
4786: IFFALSE 4828
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4788: LD_INT 5
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 6
4799: PUSH
4800: LD_INT 7
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: LD_INT 1
4809: PPUSH
4810: LD_INT 2
4812: PPUSH
4813: CALL_OW 12
4817: ARRAY
4818: PPUSH
4819: LD_INT 100
4821: PPUSH
4822: CALL 58438 0 5
4826: GO 4866
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4828: LD_INT 23
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 46
4839: PUSH
4840: LD_INT 47
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: LD_INT 1
4849: PPUSH
4850: LD_INT 2
4852: PPUSH
4853: CALL_OW 12
4857: ARRAY
4858: PPUSH
4859: LD_INT 100
4861: PPUSH
4862: CALL 58438 0 5
// if not allianceTeam then
4866: LD_EXP 17
4870: NOT
4871: IFFALSE 4875
// break ;
4873: GO 5035
// veh := CreateVehicle ;
4875: LD_ADDR_VAR 0 3
4879: PUSH
4880: CALL_OW 45
4884: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4885: LD_VAR 0 3
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4897: LD_VAR 0 3
4901: PPUSH
4902: LD_INT 38
4904: PPUSH
4905: LD_INT 0
4907: PPUSH
4908: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4912: LD_EXP 17
4916: PUSH
4917: LD_INT 1
4919: ARRAY
4920: PPUSH
4921: LD_INT 3
4923: PPUSH
4924: CALL_OW 259
4928: PUSH
4929: LD_INT 4
4931: GREATER
4932: IFFALSE 4950
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4934: LD_EXP 17
4938: PUSH
4939: LD_INT 1
4941: ARRAY
4942: PPUSH
4943: LD_INT 3
4945: PPUSH
4946: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4950: LD_EXP 17
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: LD_INT 4
4961: PPUSH
4962: CALL_OW 259
4966: PUSH
4967: LD_INT 8
4969: GREATER
4970: IFFALSE 4988
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4972: LD_EXP 17
4976: PUSH
4977: LD_INT 1
4979: ARRAY
4980: PPUSH
4981: LD_INT 4
4983: PPUSH
4984: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4988: LD_EXP 17
4992: PUSH
4993: LD_INT 1
4995: ARRAY
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
5006: LD_ADDR_EXP 17
5010: PUSH
5011: LD_EXP 17
5015: PPUSH
5016: LD_INT 1
5018: PPUSH
5019: CALL_OW 3
5023: ST_TO_ADDR
// ComHold ( veh ) ;
5024: LD_VAR 0 3
5028: PPUSH
5029: CALL_OW 140
// end ;
5033: GO 4738
5035: POP
5036: POP
// uc_side := 7 ;
5037: LD_ADDR_OWVAR 20
5041: PUSH
5042: LD_INT 7
5044: ST_TO_ADDR
// uc_nation := 1 ;
5045: LD_ADDR_OWVAR 21
5049: PUSH
5050: LD_INT 1
5052: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5053: LD_INT 5
5055: PPUSH
5056: LD_INT 3
5058: PPUSH
5059: LD_INT 3
5061: PPUSH
5062: LD_INT 11
5064: PPUSH
5065: LD_INT 100
5067: PPUSH
5068: CALL 58438 0 5
// veh := CreateVehicle ;
5072: LD_ADDR_VAR 0 3
5076: PUSH
5077: CALL_OW 45
5081: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 4
5089: PPUSH
5090: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5094: LD_VAR 0 3
5098: PPUSH
5099: LD_INT 305
5101: PPUSH
5102: LD_INT 218
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 48
// ComHold ( veh ) ;
5112: LD_VAR 0 3
5116: PPUSH
5117: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5121: LD_INT 313
5123: PPUSH
5124: LD_INT 220
5126: PPUSH
5127: CALL_OW 86
// end ; end_of_file
5131: LD_VAR 0 1
5135: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5136: LD_INT 0
5138: PPUSH
5139: PPUSH
5140: PPUSH
5141: PPUSH
5142: PPUSH
5143: PPUSH
5144: PPUSH
5145: PPUSH
5146: PPUSH
5147: PPUSH
5148: PPUSH
// if Difficulty = 1 then
5149: LD_OWVAR 67
5153: PUSH
5154: LD_INT 1
5156: EQUAL
5157: IFFALSE 5195
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
5159: LD_ADDR_VAR 0 2
5163: PUSH
5164: LD_INT 95
5166: PUSH
5167: LD_INT 39
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: PUSH
5179: FOR_IN
5180: IFFALSE 5193
// RemoveUnit ( i ) ;
5182: LD_VAR 0 2
5186: PPUSH
5187: CALL_OW 64
5191: GO 5179
5193: POP
5194: POP
// InitHc ;
5195: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5199: LD_INT 387
5201: PPUSH
5202: LD_STRING sigma
5204: PPUSH
5205: CALL_OW 500
// uc_side := 1 ;
5209: LD_ADDR_OWVAR 20
5213: PUSH
5214: LD_INT 1
5216: ST_TO_ADDR
// uc_nation := 1 ;
5217: LD_ADDR_OWVAR 21
5221: PUSH
5222: LD_INT 1
5224: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5225: LD_ADDR_VAR 0 2
5229: PUSH
5230: LD_INT 22
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 21
5242: PUSH
5243: LD_INT 3
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL_OW 69
5258: PUSH
5259: FOR_IN
5260: IFFALSE 5276
// SetBLevel ( i , 10 ) ;
5262: LD_VAR 0 2
5266: PPUSH
5267: LD_INT 10
5269: PPUSH
5270: CALL_OW 241
5274: GO 5259
5276: POP
5277: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 274
5285: PPUSH
5286: LD_INT 1
5288: PPUSH
5289: LD_INT 7500
5291: PPUSH
5292: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5296: LD_INT 387
5298: PPUSH
5299: CALL_OW 274
5303: PPUSH
5304: LD_INT 2
5306: PPUSH
5307: LD_INT 4000
5309: PPUSH
5310: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5314: LD_INT 387
5316: PPUSH
5317: CALL_OW 274
5321: PPUSH
5322: LD_INT 3
5324: PPUSH
5325: LD_INT 50
5327: PPUSH
5328: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5332: LD_INT 476
5334: PPUSH
5335: CALL_OW 274
5339: PPUSH
5340: LD_INT 1
5342: PPUSH
5343: LD_INT 5500
5345: PPUSH
5346: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5350: LD_INT 476
5352: PPUSH
5353: CALL_OW 274
5357: PPUSH
5358: LD_INT 2
5360: PPUSH
5361: LD_INT 4000
5363: PPUSH
5364: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5368: LD_INT 476
5370: PPUSH
5371: CALL_OW 274
5375: PPUSH
5376: LD_INT 3
5378: PPUSH
5379: LD_INT 10
5381: PPUSH
5382: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5386: LD_STRING 12a_PowellKilled
5388: PPUSH
5389: LD_INT 0
5391: PPUSH
5392: CALL_OW 30
5396: IFFALSE 5423
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5398: LD_INT 1
5400: PPUSH
5401: LD_INT 1
5403: PPUSH
5404: LD_INT 10
5406: PPUSH
5407: CALL_OW 380
// Powell := CreateHuman ;
5411: LD_ADDR_EXP 57
5415: PUSH
5416: CALL_OW 44
5420: ST_TO_ADDR
// end else
5421: GO 5436
// Powell := NewCharacter ( Powell ) ;
5423: LD_ADDR_EXP 57
5427: PUSH
5428: LD_STRING Powell
5430: PPUSH
5431: CALL_OW 25
5435: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5436: LD_EXP 57
5440: PPUSH
5441: LD_INT 387
5443: PPUSH
5444: CALL_OW 52
// tmp := [ ] ;
5448: LD_ADDR_VAR 0 7
5452: PUSH
5453: EMPTY
5454: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5455: LD_ADDR_EXP 23
5459: PUSH
5460: LD_STRING Lisa
5462: PPUSH
5463: LD_EXP 1
5467: NOT
5468: PPUSH
5469: LD_STRING 12p_
5471: PPUSH
5472: CALL 53577 0 3
5476: ST_TO_ADDR
// if Lisa then
5477: LD_EXP 23
5481: IFFALSE 5499
// tmp := tmp ^ Lisa ;
5483: LD_ADDR_VAR 0 7
5487: PUSH
5488: LD_VAR 0 7
5492: PUSH
5493: LD_EXP 23
5497: ADD
5498: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5499: LD_ADDR_EXP 24
5503: PUSH
5504: LD_STRING Donaldson
5506: PPUSH
5507: LD_EXP 1
5511: NOT
5512: PPUSH
5513: LD_STRING 12p_
5515: PPUSH
5516: CALL 53577 0 3
5520: ST_TO_ADDR
// if Donaldson then
5521: LD_EXP 24
5525: IFFALSE 5543
// tmp := tmp ^ Donaldson ;
5527: LD_ADDR_VAR 0 7
5531: PUSH
5532: LD_VAR 0 7
5536: PUSH
5537: LD_EXP 24
5541: ADD
5542: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5543: LD_ADDR_EXP 25
5547: PUSH
5548: LD_STRING Bobby
5550: PPUSH
5551: LD_EXP 1
5555: NOT
5556: PPUSH
5557: LD_STRING 12p_
5559: PPUSH
5560: CALL 53577 0 3
5564: ST_TO_ADDR
// if Bobby then
5565: LD_EXP 25
5569: IFFALSE 5587
// tmp := tmp ^ Bobby ;
5571: LD_ADDR_VAR 0 7
5575: PUSH
5576: LD_VAR 0 7
5580: PUSH
5581: LD_EXP 25
5585: ADD
5586: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5587: LD_ADDR_EXP 26
5591: PUSH
5592: LD_STRING Cyrus
5594: PPUSH
5595: LD_EXP 1
5599: NOT
5600: PPUSH
5601: LD_STRING 12p_
5603: PPUSH
5604: CALL 53577 0 3
5608: ST_TO_ADDR
// if Cyrus then
5609: LD_EXP 26
5613: IFFALSE 5631
// tmp := tmp ^ Cyrus ;
5615: LD_ADDR_VAR 0 7
5619: PUSH
5620: LD_VAR 0 7
5624: PUSH
5625: LD_EXP 26
5629: ADD
5630: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5631: LD_ADDR_EXP 28
5635: PUSH
5636: LD_STRING Brown
5638: PPUSH
5639: LD_EXP 1
5643: NOT
5644: PPUSH
5645: LD_STRING 12p_
5647: PPUSH
5648: CALL 53577 0 3
5652: ST_TO_ADDR
// if Brown then
5653: LD_EXP 28
5657: IFFALSE 5675
// tmp := tmp ^ Brown ;
5659: LD_ADDR_VAR 0 7
5663: PUSH
5664: LD_VAR 0 7
5668: PUSH
5669: LD_EXP 28
5673: ADD
5674: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5675: LD_ADDR_EXP 29
5679: PUSH
5680: LD_STRING Gladstone
5682: PPUSH
5683: LD_EXP 1
5687: NOT
5688: PPUSH
5689: LD_STRING 12p_
5691: PPUSH
5692: CALL 53577 0 3
5696: ST_TO_ADDR
// if Gladstone then
5697: LD_EXP 29
5701: IFFALSE 5719
// tmp := tmp ^ Gladstone ;
5703: LD_ADDR_VAR 0 7
5707: PUSH
5708: LD_VAR 0 7
5712: PUSH
5713: LD_EXP 29
5717: ADD
5718: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5719: LD_ADDR_EXP 30
5723: PUSH
5724: LD_STRING Houten
5726: PPUSH
5727: LD_EXP 1
5731: NOT
5732: PPUSH
5733: LD_STRING 12p_
5735: PPUSH
5736: CALL 53577 0 3
5740: ST_TO_ADDR
// if Houten then
5741: LD_EXP 30
5745: IFFALSE 5763
// tmp := tmp ^ Houten ;
5747: LD_ADDR_VAR 0 7
5751: PUSH
5752: LD_VAR 0 7
5756: PUSH
5757: LD_EXP 30
5761: ADD
5762: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5763: LD_ADDR_EXP 31
5767: PUSH
5768: LD_STRING Cornel
5770: PPUSH
5771: LD_EXP 1
5775: NOT
5776: PPUSH
5777: LD_STRING 12p_
5779: PPUSH
5780: CALL 53577 0 3
5784: ST_TO_ADDR
// if Cornel then
5785: LD_EXP 31
5789: IFFALSE 5807
// tmp := tmp ^ Cornel ;
5791: LD_ADDR_VAR 0 7
5795: PUSH
5796: LD_VAR 0 7
5800: PUSH
5801: LD_EXP 31
5805: ADD
5806: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5807: LD_ADDR_EXP 32
5811: PUSH
5812: LD_STRING Gary
5814: PPUSH
5815: LD_EXP 1
5819: NOT
5820: PPUSH
5821: LD_STRING 12p_
5823: PPUSH
5824: CALL 53577 0 3
5828: ST_TO_ADDR
// if Gary then
5829: LD_EXP 32
5833: IFFALSE 5851
// tmp := tmp ^ Gary ;
5835: LD_ADDR_VAR 0 7
5839: PUSH
5840: LD_VAR 0 7
5844: PUSH
5845: LD_EXP 32
5849: ADD
5850: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5851: LD_ADDR_EXP 34
5855: PUSH
5856: LD_STRING Kikuchi
5858: PPUSH
5859: LD_EXP 1
5863: NOT
5864: PPUSH
5865: LD_STRING 12p_
5867: PPUSH
5868: CALL 53577 0 3
5872: ST_TO_ADDR
// if Kikuchi then
5873: LD_EXP 34
5877: IFFALSE 5895
// tmp := tmp ^ Kikuchi ;
5879: LD_ADDR_VAR 0 7
5883: PUSH
5884: LD_VAR 0 7
5888: PUSH
5889: LD_EXP 34
5893: ADD
5894: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5895: LD_ADDR_VAR 0 7
5899: PUSH
5900: LD_VAR 0 7
5904: PUSH
5905: LD_STRING 12p_others
5907: PPUSH
5908: CALL_OW 31
5912: UNION
5913: ST_TO_ADDR
// InitHc_All ( ) ;
5914: CALL_OW 584
// if tmp < 36 then
5918: LD_VAR 0 7
5922: PUSH
5923: LD_INT 36
5925: LESS
5926: IFFALSE 5993
// for i = 1 to 36 - tmp do
5928: LD_ADDR_VAR 0 2
5932: PUSH
5933: DOUBLE
5934: LD_INT 1
5936: DEC
5937: ST_TO_ADDR
5938: LD_INT 36
5940: PUSH
5941: LD_VAR 0 7
5945: MINUS
5946: PUSH
5947: FOR_TO
5948: IFFALSE 5991
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5950: LD_INT 1
5952: PPUSH
5953: LD_VAR 0 2
5957: PUSH
5958: LD_INT 4
5960: MOD
5961: PUSH
5962: LD_INT 1
5964: PLUS
5965: PPUSH
5966: LD_INT 10
5968: PPUSH
5969: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5973: LD_ADDR_VAR 0 7
5977: PUSH
5978: LD_VAR 0 7
5982: PUSH
5983: CALL_OW 44
5987: ADD
5988: ST_TO_ADDR
// end ;
5989: GO 5947
5991: POP
5992: POP
// p := 0 ;
5993: LD_ADDR_VAR 0 6
5997: PUSH
5998: LD_INT 0
6000: ST_TO_ADDR
// for i in tmp do
6001: LD_ADDR_VAR 0 2
6005: PUSH
6006: LD_VAR 0 7
6010: PUSH
6011: FOR_IN
6012: IFFALSE 6064
// begin p := Inc ( p ) ;
6014: LD_ADDR_VAR 0 6
6018: PUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: CALL 92670 0 1
6028: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
6029: LD_VAR 0 2
6033: PPUSH
6034: LD_INT 62
6036: PPUSH
6037: LD_INT 93
6039: PPUSH
6040: LD_INT 9
6042: PPUSH
6043: LD_INT 0
6045: PPUSH
6046: CALL_OW 50
// if p > 36 then
6050: LD_VAR 0 6
6054: PUSH
6055: LD_INT 36
6057: GREATER
6058: IFFALSE 6062
// break ;
6060: GO 6064
// end ;
6062: GO 6011
6064: POP
6065: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
6066: LD_ADDR_EXP 80
6070: PUSH
6071: LD_EXP 80
6075: PPUSH
6076: LD_INT 4
6078: PPUSH
6079: LD_INT 22
6081: PUSH
6082: LD_INT 1
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: PPUSH
6089: CALL_OW 69
6093: PUSH
6094: LD_EXP 57
6098: DIFF
6099: PPUSH
6100: CALL_OW 1
6104: ST_TO_ADDR
// uc_side := 0 ;
6105: LD_ADDR_OWVAR 20
6109: PUSH
6110: LD_INT 0
6112: ST_TO_ADDR
// uc_nation := 0 ;
6113: LD_ADDR_OWVAR 21
6117: PUSH
6118: LD_INT 0
6120: ST_TO_ADDR
// for i = 1 to 4 do
6121: LD_ADDR_VAR 0 2
6125: PUSH
6126: DOUBLE
6127: LD_INT 1
6129: DEC
6130: ST_TO_ADDR
6131: LD_INT 4
6133: PUSH
6134: FOR_TO
6135: IFFALSE 6166
// begin InitHc ;
6137: CALL_OW 19
// hc_class := class_apeman ;
6141: LD_ADDR_OWVAR 28
6145: PUSH
6146: LD_INT 12
6148: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6149: CALL_OW 44
6153: PPUSH
6154: LD_INT 11
6156: PPUSH
6157: LD_INT 0
6159: PPUSH
6160: CALL_OW 49
// end ;
6164: GO 6134
6166: POP
6167: POP
// end ;
6168: LD_VAR 0 1
6172: RET
// every 6 6$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6173: LD_EXP 4
6177: NOT
6178: IFFALSE 7101
6180: GO 6182
6182: DISABLE
6183: LD_INT 0
6185: PPUSH
6186: PPUSH
6187: PPUSH
6188: PPUSH
// begin enable ;
6189: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6190: LD_INT 22
6192: PUSH
6193: LD_INT 1
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PUSH
6200: LD_INT 23
6202: PUSH
6203: LD_INT 1
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 30
6212: PUSH
6213: LD_INT 3
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: PPUSH
6225: CALL_OW 69
6229: NOT
6230: IFFALSE 6234
// exit ;
6232: GO 7101
// if Prob ( 40 ) then
6234: LD_INT 40
6236: PPUSH
6237: CALL_OW 13
6241: IFFALSE 6368
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6243: LD_INT 4
6245: PPUSH
6246: LD_INT 5
6248: PUSH
6249: LD_INT 1
6251: PUSH
6252: LD_INT 2
6254: PUSH
6255: LD_INT 7
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: LD_INT 5
6266: PUSH
6267: LD_INT 1
6269: PUSH
6270: LD_INT 2
6272: PUSH
6273: LD_INT 7
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_INT 5
6284: PUSH
6285: LD_INT 1
6287: PUSH
6288: LD_INT 2
6290: PUSH
6291: LD_INT 7
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 5
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: LD_INT 2
6308: PUSH
6309: LD_INT 6
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: PUSH
6318: LD_INT 5
6320: PUSH
6321: LD_INT 1
6323: PUSH
6324: LD_INT 2
6326: PUSH
6327: LD_INT 6
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 5
6338: PUSH
6339: LD_INT 1
6341: PUSH
6342: LD_INT 2
6344: PUSH
6345: LD_INT 6
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: LIST
6360: LIST
6361: PPUSH
6362: CALL 47151 0 2
// end else
6366: GO 6491
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6368: LD_INT 4
6370: PPUSH
6371: LD_INT 5
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: LD_INT 2
6379: PUSH
6380: LD_INT 7
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: LIST
6387: LIST
6388: PUSH
6389: LD_INT 5
6391: PUSH
6392: LD_INT 1
6394: PUSH
6395: LD_INT 2
6397: PUSH
6398: LD_INT 9
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 5
6409: PUSH
6410: LD_INT 1
6412: PUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 9
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 5
6427: PUSH
6428: LD_INT 1
6430: PUSH
6431: LD_INT 2
6433: PUSH
6434: LD_INT 6
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: PUSH
6443: LD_INT 5
6445: PUSH
6446: LD_INT 1
6448: PUSH
6449: LD_INT 2
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: EMPTY
6456: LIST
6457: LIST
6458: LIST
6459: LIST
6460: PUSH
6461: LD_INT 5
6463: PUSH
6464: LD_INT 1
6466: PUSH
6467: LD_INT 2
6469: PUSH
6470: LD_INT 6
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: LIST
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: PPUSH
6487: CALL 47151 0 2
// end ; p := 0 ;
6491: LD_ADDR_VAR 0 4
6495: PUSH
6496: LD_INT 0
6498: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6499: LD_INT 35
6501: PPUSH
6502: CALL_OW 67
// p := Inc ( p ) ;
6506: LD_ADDR_VAR 0 4
6510: PUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 92670 0 1
6520: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6521: LD_INT 4
6523: PPUSH
6524: LD_INT 1
6526: PPUSH
6527: CALL 48569 0 2
6531: PUSH
6532: LD_INT 6
6534: GREATEREQUAL
6535: PUSH
6536: LD_VAR 0 4
6540: PUSH
6541: LD_INT 100
6543: GREATER
6544: OR
6545: IFFALSE 6499
// wait ( 0 0$30 ) ;
6547: LD_INT 1050
6549: PPUSH
6550: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_siberium_rocket ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , us_crane ] ] ] ) diff mc_defender [ 4 ] ;
6554: LD_ADDR_VAR 0 2
6558: PUSH
6559: LD_INT 22
6561: PUSH
6562: LD_INT 1
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: LD_INT 21
6571: PUSH
6572: LD_INT 2
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: PUSH
6579: LD_INT 3
6581: PUSH
6582: LD_INT 34
6584: PUSH
6585: LD_INT 8
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PUSH
6596: LD_INT 3
6598: PUSH
6599: LD_INT 34
6601: PUSH
6602: LD_INT 12
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PUSH
6613: LD_INT 3
6615: PUSH
6616: LD_INT 34
6618: PUSH
6619: LD_INT 13
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: LIST
6636: PPUSH
6637: CALL_OW 69
6641: PUSH
6642: LD_EXP 102
6646: PUSH
6647: LD_INT 4
6649: ARRAY
6650: DIFF
6651: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6652: LD_ADDR_EXP 99
6656: PUSH
6657: LD_EXP 99
6661: PPUSH
6662: LD_INT 4
6664: PPUSH
6665: LD_EXP 99
6669: PUSH
6670: LD_INT 4
6672: ARRAY
6673: PUSH
6674: LD_VAR 0 2
6678: DIFF
6679: PPUSH
6680: CALL_OW 1
6684: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6685: LD_ADDR_VAR 0 3
6689: PUSH
6690: LD_INT 0
6692: PPUSH
6693: LD_INT 2
6695: PPUSH
6696: CALL_OW 12
6700: ST_TO_ADDR
// p := 0 ;
6701: LD_ADDR_VAR 0 4
6705: PUSH
6706: LD_INT 0
6708: ST_TO_ADDR
// if target then
6709: LD_VAR 0 3
6713: IFFALSE 6866
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6715: LD_ADDR_VAR 0 2
6719: PUSH
6720: LD_VAR 0 2
6724: PPUSH
6725: LD_INT 24
6727: PUSH
6728: LD_INT 250
6730: PUSH
6731: EMPTY
6732: LIST
6733: LIST
6734: PPUSH
6735: CALL_OW 72
6739: ST_TO_ADDR
// for i in tmp do
6740: LD_ADDR_VAR 0 1
6744: PUSH
6745: LD_VAR 0 2
6749: PUSH
6750: FOR_IN
6751: IFFALSE 6791
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6753: LD_VAR 0 1
6757: PPUSH
6758: LD_INT 114
6760: PPUSH
6761: LD_INT 108
6763: PPUSH
6764: CALL_OW 297
6768: PUSH
6769: LD_INT 9
6771: GREATER
6772: IFFALSE 6789
// ComMoveXY ( i , 114 , 108 ) ;
6774: LD_VAR 0 1
6778: PPUSH
6779: LD_INT 114
6781: PPUSH
6782: LD_INT 108
6784: PPUSH
6785: CALL_OW 111
6789: GO 6750
6791: POP
6792: POP
// wait ( 0 0$1 ) ;
6793: LD_INT 35
6795: PPUSH
6796: CALL_OW 67
// p := Inc ( p ) ;
6800: LD_ADDR_VAR 0 4
6804: PUSH
6805: LD_VAR 0 4
6809: PPUSH
6810: CALL 92670 0 1
6814: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6815: LD_VAR 0 2
6819: PPUSH
6820: LD_INT 92
6822: PUSH
6823: LD_INT 114
6825: PUSH
6826: LD_INT 108
6828: PUSH
6829: LD_INT 9
6831: PUSH
6832: EMPTY
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: PPUSH
6838: CALL_OW 72
6842: PUSH
6843: LD_VAR 0 2
6847: PUSH
6848: LD_INT 1
6850: MINUS
6851: GREATEREQUAL
6852: PUSH
6853: LD_VAR 0 4
6857: PUSH
6858: LD_INT 30
6860: GREATER
6861: OR
6862: IFFALSE 6715
// end else
6864: GO 7015
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6866: LD_ADDR_VAR 0 2
6870: PUSH
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 24
6878: PUSH
6879: LD_INT 250
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: PPUSH
6886: CALL_OW 72
6890: ST_TO_ADDR
// for i in tmp do
6891: LD_ADDR_VAR 0 1
6895: PUSH
6896: LD_VAR 0 2
6900: PUSH
6901: FOR_IN
6902: IFFALSE 6942
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 129
6911: PPUSH
6912: LD_INT 139
6914: PPUSH
6915: CALL_OW 297
6919: PUSH
6920: LD_INT 9
6922: GREATER
6923: IFFALSE 6940
// ComMoveXY ( i , 129 , 139 ) ;
6925: LD_VAR 0 1
6929: PPUSH
6930: LD_INT 129
6932: PPUSH
6933: LD_INT 139
6935: PPUSH
6936: CALL_OW 111
6940: GO 6901
6942: POP
6943: POP
// wait ( 0 0$1 ) ;
6944: LD_INT 35
6946: PPUSH
6947: CALL_OW 67
// p := Inc ( p ) ;
6951: LD_ADDR_VAR 0 4
6955: PUSH
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 92670 0 1
6965: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6966: LD_VAR 0 2
6970: PPUSH
6971: LD_INT 92
6973: PUSH
6974: LD_INT 129
6976: PUSH
6977: LD_INT 139
6979: PUSH
6980: LD_INT 9
6982: PUSH
6983: EMPTY
6984: LIST
6985: LIST
6986: LIST
6987: LIST
6988: PPUSH
6989: CALL_OW 72
6993: PUSH
6994: LD_VAR 0 2
6998: PUSH
6999: LD_INT 1
7001: MINUS
7002: GREATEREQUAL
7003: PUSH
7004: LD_VAR 0 4
7008: PUSH
7009: LD_INT 30
7011: GREATER
7012: OR
7013: IFFALSE 6866
// end ; repeat wait ( 0 0$1 ) ;
7015: LD_INT 35
7017: PPUSH
7018: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7022: LD_ADDR_VAR 0 2
7026: PUSH
7027: LD_VAR 0 2
7031: PPUSH
7032: LD_INT 50
7034: PUSH
7035: EMPTY
7036: LIST
7037: PPUSH
7038: CALL_OW 72
7042: ST_TO_ADDR
// for i in tmp do
7043: LD_ADDR_VAR 0 1
7047: PUSH
7048: LD_VAR 0 2
7052: PUSH
7053: FOR_IN
7054: IFFALSE 7092
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
7056: LD_VAR 0 1
7060: PPUSH
7061: LD_INT 81
7063: PUSH
7064: LD_INT 1
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PPUSH
7071: CALL_OW 69
7075: PPUSH
7076: LD_VAR 0 1
7080: PPUSH
7081: CALL_OW 74
7085: PPUSH
7086: CALL_OW 115
7090: GO 7053
7092: POP
7093: POP
// until not tmp ;
7094: LD_VAR 0 2
7098: NOT
7099: IFFALSE 7015
// end ;
7101: PPOPN 4
7103: END
// every 30 30$00 trigger not americanDestroyed do
7104: LD_EXP 4
7108: NOT
7109: IFFALSE 7178
7111: GO 7113
7113: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
7114: LD_INT 63000
7116: PUSH
7117: LD_INT 42000
7119: PUSH
7120: LD_INT 31500
7122: PUSH
7123: LD_INT 21000
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: LIST
7130: LIST
7131: PUSH
7132: LD_OWVAR 67
7136: ARRAY
7137: PPUSH
7138: CALL_OW 67
// if americanDestroyed then
7142: LD_EXP 4
7146: IFFALSE 7150
// exit ;
7148: GO 7178
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
7150: LD_INT 4
7152: PPUSH
7153: LD_INT 5
7155: PUSH
7156: LD_INT 3
7158: PUSH
7159: LD_INT 1
7161: PUSH
7162: LD_INT 8
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: PUSH
7171: EMPTY
7172: LIST
7173: PPUSH
7174: CALL 47151 0 2
// end ; end_of_file
7178: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
7179: LD_INT 0
7181: PPUSH
7182: PPUSH
7183: PPUSH
7184: PPUSH
7185: PPUSH
// side := 2 ;
7186: LD_ADDR_VAR 0 5
7190: PUSH
7191: LD_INT 2
7193: ST_TO_ADDR
// InitHc ;
7194: CALL_OW 19
// uc_side := side ;
7198: LD_ADDR_OWVAR 20
7202: PUSH
7203: LD_VAR 0 5
7207: ST_TO_ADDR
// uc_nation := 2 ;
7208: LD_ADDR_OWVAR 21
7212: PUSH
7213: LD_INT 2
7215: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7216: LD_ADDR_VAR 0 2
7220: PUSH
7221: LD_INT 22
7223: PUSH
7224: LD_INT 2
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PUSH
7231: LD_INT 21
7233: PUSH
7234: LD_INT 3
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: PPUSH
7245: CALL_OW 69
7249: PUSH
7250: FOR_IN
7251: IFFALSE 7267
// SetBLevel ( i , 10 ) ;
7253: LD_VAR 0 2
7257: PPUSH
7258: LD_INT 10
7260: PPUSH
7261: CALL_OW 241
7265: GO 7250
7267: POP
7268: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7269: LD_ADDR_VAR 0 4
7273: PUSH
7274: LD_INT 22
7276: PUSH
7277: LD_VAR 0 5
7281: PUSH
7282: EMPTY
7283: LIST
7284: LIST
7285: PUSH
7286: LD_INT 30
7288: PUSH
7289: LD_INT 32
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 58
7298: PUSH
7299: EMPTY
7300: LIST
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: LIST
7306: PPUSH
7307: CALL_OW 69
7311: ST_TO_ADDR
// for i = 1 to 10 do
7312: LD_ADDR_VAR 0 2
7316: PUSH
7317: DOUBLE
7318: LD_INT 1
7320: DEC
7321: ST_TO_ADDR
7322: LD_INT 10
7324: PUSH
7325: FOR_TO
7326: IFFALSE 7398
// begin uc_nation := nation_nature ;
7328: LD_ADDR_OWVAR 21
7332: PUSH
7333: LD_INT 0
7335: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7336: LD_ADDR_OWVAR 28
7340: PUSH
7341: LD_INT 15
7343: ST_TO_ADDR
// hc_gallery :=  ;
7344: LD_ADDR_OWVAR 33
7348: PUSH
7349: LD_STRING 
7351: ST_TO_ADDR
// hc_name :=  ;
7352: LD_ADDR_OWVAR 26
7356: PUSH
7357: LD_STRING 
7359: ST_TO_ADDR
// un := CreateHuman ;
7360: LD_ADDR_VAR 0 3
7364: PUSH
7365: CALL_OW 44
7369: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7370: LD_VAR 0 3
7374: PPUSH
7375: LD_VAR 0 4
7379: PUSH
7380: LD_VAR 0 4
7384: PUSH
7385: LD_VAR 0 2
7389: MINUS
7390: ARRAY
7391: PPUSH
7392: CALL_OW 52
// end ;
7396: GO 7325
7398: POP
7399: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7400: LD_INT 503
7402: PPUSH
7403: LD_INT 27
7405: PPUSH
7406: LD_STRING 
7408: PPUSH
7409: LD_INT 8
7411: PUSH
7412: LD_INT 9
7414: PUSH
7415: LD_INT 10
7417: PUSH
7418: LD_INT 10
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: LIST
7425: LIST
7426: PUSH
7427: LD_OWVAR 67
7431: ARRAY
7432: PPUSH
7433: LD_INT 3000
7435: PUSH
7436: LD_INT 500
7438: PUSH
7439: LD_INT 150
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: PPUSH
7447: LD_INT 16
7449: PUSH
7450: LD_INT 6
7452: PUSH
7453: LD_INT 6
7455: PUSH
7456: LD_INT 6
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: LIST
7463: LIST
7464: PPUSH
7465: CALL 62259 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7469: LD_ADDR_EXP 80
7473: PUSH
7474: LD_EXP 80
7478: PPUSH
7479: LD_INT 1
7481: PPUSH
7482: LD_INT 22
7484: PUSH
7485: LD_VAR 0 5
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 23
7496: PUSH
7497: LD_INT 2
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: LD_INT 3
7506: PUSH
7507: LD_INT 21
7509: PUSH
7510: LD_INT 2
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PUSH
7521: EMPTY
7522: LIST
7523: LIST
7524: LIST
7525: PPUSH
7526: CALL_OW 69
7530: PPUSH
7531: CALL_OW 1
7535: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7536: LD_INT 216
7538: PPUSH
7539: LD_INT 228
7541: PPUSH
7542: LD_INT 2
7544: PPUSH
7545: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7549: LD_INT 223
7551: PPUSH
7552: LD_INT 241
7554: PPUSH
7555: LD_INT 2
7557: PPUSH
7558: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7562: LD_INT 216
7564: PPUSH
7565: LD_INT 217
7567: PPUSH
7568: LD_INT 2
7570: PPUSH
7571: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7575: LD_INT 233
7577: PPUSH
7578: LD_INT 257
7580: PPUSH
7581: LD_INT 2
7583: PPUSH
7584: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7588: LD_INT 230
7590: PPUSH
7591: LD_INT 199
7593: PPUSH
7594: LD_INT 2
7596: PPUSH
7597: CALL_OW 244
// end ;
7601: LD_VAR 0 1
7605: RET
// export Omar ; export function PrepareOmarAli ; begin
7606: LD_INT 0
7608: PPUSH
// uc_side := 5 ;
7609: LD_ADDR_OWVAR 20
7613: PUSH
7614: LD_INT 5
7616: ST_TO_ADDR
// uc_nation := 2 ;
7617: LD_ADDR_OWVAR 21
7621: PUSH
7622: LD_INT 2
7624: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7625: LD_ADDR_EXP 58
7629: PUSH
7630: LD_STRING Omar
7632: PPUSH
7633: CALL_OW 25
7637: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7638: LD_EXP 58
7642: PPUSH
7643: LD_INT 330
7645: PPUSH
7646: LD_INT 244
7648: PPUSH
7649: LD_INT 0
7651: PPUSH
7652: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7656: LD_EXP 58
7660: PPUSH
7661: LD_INT 252
7663: PPUSH
7664: LD_INT 220
7666: PPUSH
7667: CALL_OW 111
// end ;
7671: LD_VAR 0 1
7675: RET
// export function PrepareOmarAli2 ; begin
7676: LD_INT 0
7678: PPUSH
// uc_side := 5 ;
7679: LD_ADDR_OWVAR 20
7683: PUSH
7684: LD_INT 5
7686: ST_TO_ADDR
// uc_nation := 2 ;
7687: LD_ADDR_OWVAR 21
7691: PUSH
7692: LD_INT 2
7694: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7695: LD_ADDR_EXP 58
7699: PUSH
7700: LD_STRING Omar
7702: PPUSH
7703: CALL_OW 25
7707: ST_TO_ADDR
// PlaceUnitXY ( Omar , 289 , 164 , false ) ;
7708: LD_EXP 58
7712: PPUSH
7713: LD_INT 289
7715: PPUSH
7716: LD_INT 164
7718: PPUSH
7719: LD_INT 0
7721: PPUSH
7722: CALL_OW 48
// ComMoveXY ( Omar , 254 , 166 ) ;
7726: LD_EXP 58
7730: PPUSH
7731: LD_INT 254
7733: PPUSH
7734: LD_INT 166
7736: PPUSH
7737: CALL_OW 111
// end ; end_of_file
7741: LD_VAR 0 1
7745: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7746: LD_INT 0
7748: PPUSH
7749: PPUSH
7750: PPUSH
7751: PPUSH
7752: PPUSH
// side := 8 ;
7753: LD_ADDR_VAR 0 3
7757: PUSH
7758: LD_INT 8
7760: ST_TO_ADDR
// InitHc ;
7761: CALL_OW 19
// uc_side := side ;
7765: LD_ADDR_OWVAR 20
7769: PUSH
7770: LD_VAR 0 3
7774: ST_TO_ADDR
// uc_nation := 2 ;
7775: LD_ADDR_OWVAR 21
7779: PUSH
7780: LD_INT 2
7782: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7783: LD_ADDR_VAR 0 2
7787: PUSH
7788: LD_INT 22
7790: PUSH
7791: LD_VAR 0 3
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: LD_INT 21
7802: PUSH
7803: LD_INT 3
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PPUSH
7814: CALL_OW 69
7818: PUSH
7819: FOR_IN
7820: IFFALSE 7836
// SetBLevel ( i , 10 ) ;
7822: LD_VAR 0 2
7826: PPUSH
7827: LD_INT 10
7829: PPUSH
7830: CALL_OW 241
7834: GO 7819
7836: POP
7837: POP
// Schulz := NewCharacter ( Schulz ) ;
7838: LD_ADDR_EXP 59
7842: PUSH
7843: LD_STRING Schulz
7845: PPUSH
7846: CALL_OW 25
7850: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7851: LD_ADDR_EXP 61
7855: PUSH
7856: LD_STRING Kaia
7858: PPUSH
7859: CALL_OW 25
7863: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7864: LD_EXP 61
7868: PPUSH
7869: LD_INT 324
7871: PPUSH
7872: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7876: LD_ADDR_EXP 60
7880: PUSH
7881: LD_STRING Kozlov
7883: PPUSH
7884: LD_INT 0
7886: PPUSH
7887: LD_STRING 
7889: PPUSH
7890: CALL 53577 0 3
7894: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7895: LD_EXP 60
7899: PPUSH
7900: LD_INT 22
7902: PUSH
7903: LD_INT 8
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 23
7912: PUSH
7913: LD_INT 3
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 30
7922: PUSH
7923: LD_INT 8
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PUSH
7930: EMPTY
7931: LIST
7932: LIST
7933: LIST
7934: PPUSH
7935: CALL_OW 69
7939: PUSH
7940: LD_INT 1
7942: ARRAY
7943: PPUSH
7944: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7948: LD_EXP 60
7952: PPUSH
7953: LD_INT 3
7955: PPUSH
7956: LD_INT 10
7958: PPUSH
7959: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7963: LD_ADDR_VAR 0 5
7967: PUSH
7968: LD_INT 22
7970: PUSH
7971: LD_VAR 0 3
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PUSH
7980: LD_INT 30
7982: PUSH
7983: LD_INT 32
7985: PUSH
7986: EMPTY
7987: LIST
7988: LIST
7989: PUSH
7990: LD_INT 58
7992: PUSH
7993: EMPTY
7994: LIST
7995: PUSH
7996: EMPTY
7997: LIST
7998: LIST
7999: LIST
8000: PPUSH
8001: CALL_OW 69
8005: ST_TO_ADDR
// for i = 1 to 10 do
8006: LD_ADDR_VAR 0 2
8010: PUSH
8011: DOUBLE
8012: LD_INT 1
8014: DEC
8015: ST_TO_ADDR
8016: LD_INT 10
8018: PUSH
8019: FOR_TO
8020: IFFALSE 8092
// begin uc_nation := nation_nature ;
8022: LD_ADDR_OWVAR 21
8026: PUSH
8027: LD_INT 0
8029: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
8030: LD_ADDR_OWVAR 28
8034: PUSH
8035: LD_INT 15
8037: ST_TO_ADDR
// hc_gallery :=  ;
8038: LD_ADDR_OWVAR 33
8042: PUSH
8043: LD_STRING 
8045: ST_TO_ADDR
// hc_name :=  ;
8046: LD_ADDR_OWVAR 26
8050: PUSH
8051: LD_STRING 
8053: ST_TO_ADDR
// un := CreateHuman ;
8054: LD_ADDR_VAR 0 4
8058: PUSH
8059: CALL_OW 44
8063: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
8064: LD_VAR 0 4
8068: PPUSH
8069: LD_VAR 0 5
8073: PUSH
8074: LD_VAR 0 5
8078: PUSH
8079: LD_VAR 0 2
8083: MINUS
8084: ARRAY
8085: PPUSH
8086: CALL_OW 52
// end ;
8090: GO 8019
8092: POP
8093: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
8094: LD_INT 324
8096: PPUSH
8097: LD_INT 3
8099: PPUSH
8100: LD_STRING 
8102: PPUSH
8103: LD_INT 8
8105: PUSH
8106: LD_INT 9
8108: PUSH
8109: LD_INT 10
8111: PUSH
8112: LD_INT 10
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: LIST
8120: PUSH
8121: LD_OWVAR 67
8125: ARRAY
8126: PPUSH
8127: LD_INT 3000
8129: PUSH
8130: LD_INT 500
8132: PUSH
8133: LD_INT 150
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: LIST
8140: PPUSH
8141: LD_INT 16
8143: PUSH
8144: LD_INT 6
8146: PUSH
8147: LD_INT 6
8149: PUSH
8150: LD_INT 8
8152: PUSH
8153: EMPTY
8154: LIST
8155: LIST
8156: LIST
8157: LIST
8158: PPUSH
8159: CALL 62259 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
8163: LD_ADDR_EXP 80
8167: PUSH
8168: LD_EXP 80
8172: PPUSH
8173: LD_INT 3
8175: PPUSH
8176: LD_INT 22
8178: PUSH
8179: LD_VAR 0 3
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PUSH
8188: LD_INT 23
8190: PUSH
8191: LD_INT 2
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: PUSH
8198: LD_INT 3
8200: PUSH
8201: LD_INT 21
8203: PUSH
8204: LD_INT 2
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: PUSH
8215: EMPTY
8216: LIST
8217: LIST
8218: LIST
8219: PPUSH
8220: CALL_OW 69
8224: PUSH
8225: LD_EXP 59
8229: DIFF
8230: PPUSH
8231: CALL_OW 1
8235: ST_TO_ADDR
// end ;
8236: LD_VAR 0 1
8240: RET
// export function BuildKozlovBomb ; begin
8241: LD_INT 0
8243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
8244: LD_INT 332
8246: PPUSH
8247: CALL_OW 302
8251: NOT
8252: PUSH
8253: LD_INT 336
8255: PPUSH
8256: CALL_OW 302
8260: NOT
8261: OR
8262: IFFALSE 8266
// exit ;
8264: GO 8363
// ComChangeProfession ( Kozlov , 4 ) ;
8266: LD_EXP 60
8270: PPUSH
8271: LD_INT 4
8273: PPUSH
8274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8278: LD_INT 336
8280: PPUSH
8281: LD_INT 25
8283: PPUSH
8284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8288: LD_INT 35
8290: PPUSH
8291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8295: LD_INT 25
8297: PPUSH
8298: LD_INT 8
8300: PPUSH
8301: CALL_OW 321
8305: PUSH
8306: LD_INT 2
8308: EQUAL
8309: IFFALSE 8288
// ComExitBuilding ( Kozlov ) ;
8311: LD_EXP 60
8315: PPUSH
8316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8320: LD_EXP 60
8324: PPUSH
8325: LD_INT 332
8327: PPUSH
8328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8332: LD_EXP 60
8336: PPUSH
8337: LD_INT 3
8339: PPUSH
8340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8344: LD_INT 332
8346: PPUSH
8347: LD_INT 23
8349: PPUSH
8350: LD_INT 3
8352: PPUSH
8353: LD_INT 1
8355: PPUSH
8356: LD_INT 48
8358: PPUSH
8359: CALL_OW 125
// end ;
8363: LD_VAR 0 1
8367: RET
// every 5 5$30 + 4 4$00 trigger not legionDestroyed do var i , tmp , target , p ;
8368: LD_EXP 3
8372: NOT
8373: IFFALSE 9380
8375: GO 8377
8377: DISABLE
8378: LD_INT 0
8380: PPUSH
8381: PPUSH
8382: PPUSH
8383: PPUSH
// begin enable ;
8384: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8385: LD_INT 22
8387: PUSH
8388: LD_INT 8
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PUSH
8395: LD_INT 23
8397: PUSH
8398: LD_INT 2
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 30
8407: PUSH
8408: LD_INT 3
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: NOT
8425: IFFALSE 8429
// exit ;
8427: GO 9380
// if Prob ( 40 ) then
8429: LD_INT 40
8431: PPUSH
8432: CALL_OW 13
8436: IFFALSE 8563
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8438: LD_INT 3
8440: PPUSH
8441: LD_INT 14
8443: PUSH
8444: LD_INT 1
8446: PUSH
8447: LD_INT 2
8449: PUSH
8450: LD_INT 28
8452: PUSH
8453: EMPTY
8454: LIST
8455: LIST
8456: LIST
8457: LIST
8458: PUSH
8459: LD_INT 14
8461: PUSH
8462: LD_INT 1
8464: PUSH
8465: LD_INT 2
8467: PUSH
8468: LD_INT 28
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 14
8479: PUSH
8480: LD_INT 1
8482: PUSH
8483: LD_INT 2
8485: PUSH
8486: LD_INT 28
8488: PUSH
8489: EMPTY
8490: LIST
8491: LIST
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 14
8497: PUSH
8498: LD_INT 1
8500: PUSH
8501: LD_INT 2
8503: PUSH
8504: LD_INT 28
8506: PUSH
8507: EMPTY
8508: LIST
8509: LIST
8510: LIST
8511: LIST
8512: PUSH
8513: LD_INT 14
8515: PUSH
8516: LD_INT 1
8518: PUSH
8519: LD_INT 2
8521: PUSH
8522: LD_INT 28
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: PUSH
8531: LD_INT 14
8533: PUSH
8534: LD_INT 1
8536: PUSH
8537: LD_INT 2
8539: PUSH
8540: LD_INT 26
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: PUSH
8549: EMPTY
8550: LIST
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: PPUSH
8557: CALL 47151 0 2
// end else
8561: GO 8770
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8563: LD_INT 3
8565: PPUSH
8566: LD_INT 14
8568: PUSH
8569: LD_INT 1
8571: PUSH
8572: LD_INT 2
8574: PUSH
8575: LD_INT 27
8577: PUSH
8578: LD_INT 26
8580: PUSH
8581: LD_INT 26
8583: PUSH
8584: LD_INT 28
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: LIST
8603: LIST
8604: PUSH
8605: LD_INT 14
8607: PUSH
8608: LD_INT 1
8610: PUSH
8611: LD_INT 2
8613: PUSH
8614: LD_INT 27
8616: PUSH
8617: LD_INT 26
8619: PUSH
8620: LD_INT 26
8622: PUSH
8623: LD_INT 26
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: LD_OWVAR 67
8636: ARRAY
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_INT 14
8646: PUSH
8647: LD_INT 1
8649: PUSH
8650: LD_INT 2
8652: PUSH
8653: LD_INT 26
8655: PUSH
8656: LD_INT 26
8658: PUSH
8659: LD_INT 29
8661: PUSH
8662: LD_INT 29
8664: PUSH
8665: EMPTY
8666: LIST
8667: LIST
8668: LIST
8669: LIST
8670: PUSH
8671: LD_OWVAR 67
8675: ARRAY
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: LIST
8681: LIST
8682: PUSH
8683: LD_INT 13
8685: PUSH
8686: LD_INT 1
8688: PUSH
8689: LD_INT 2
8691: PUSH
8692: LD_INT 26
8694: PUSH
8695: LD_INT 29
8697: PUSH
8698: LD_INT 29
8700: PUSH
8701: LD_INT 29
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: LIST
8708: LIST
8709: PUSH
8710: LD_OWVAR 67
8714: ARRAY
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 13
8724: PUSH
8725: LD_INT 1
8727: PUSH
8728: LD_INT 2
8730: PUSH
8731: LD_INT 29
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: PUSH
8740: LD_INT 14
8742: PUSH
8743: LD_INT 1
8745: PUSH
8746: LD_INT 2
8748: PUSH
8749: LD_INT 26
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: LIST
8762: LIST
8763: LIST
8764: LIST
8765: PPUSH
8766: CALL 47151 0 2
// end ; p := 0 ;
8770: LD_ADDR_VAR 0 4
8774: PUSH
8775: LD_INT 0
8777: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8778: LD_INT 35
8780: PPUSH
8781: CALL_OW 67
// p := Inc ( p ) ;
8785: LD_ADDR_VAR 0 4
8789: PUSH
8790: LD_VAR 0 4
8794: PPUSH
8795: CALL 92670 0 1
8799: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8800: LD_INT 3
8802: PPUSH
8803: LD_INT 1
8805: PPUSH
8806: CALL 48569 0 2
8810: PUSH
8811: LD_INT 6
8813: GREATEREQUAL
8814: PUSH
8815: LD_VAR 0 4
8819: PUSH
8820: LD_INT 100
8822: GREATER
8823: OR
8824: IFFALSE 8778
// wait ( 0 0$30 ) ;
8826: LD_INT 1050
8828: PPUSH
8829: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
8833: LD_ADDR_VAR 0 2
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_INT 8
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: PUSH
8848: LD_INT 21
8850: PUSH
8851: LD_INT 2
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 3
8860: PUSH
8861: LD_INT 34
8863: PUSH
8864: LD_INT 31
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: PUSH
8875: LD_INT 3
8877: PUSH
8878: LD_INT 34
8880: PUSH
8881: LD_INT 32
8883: PUSH
8884: EMPTY
8885: LIST
8886: LIST
8887: PUSH
8888: EMPTY
8889: LIST
8890: LIST
8891: PUSH
8892: LD_INT 3
8894: PUSH
8895: LD_INT 34
8897: PUSH
8898: LD_INT 88
8900: PUSH
8901: EMPTY
8902: LIST
8903: LIST
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: EMPTY
8910: LIST
8911: LIST
8912: LIST
8913: LIST
8914: LIST
8915: PPUSH
8916: CALL_OW 69
8920: PUSH
8921: LD_EXP 102
8925: PUSH
8926: LD_INT 3
8928: ARRAY
8929: DIFF
8930: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8931: LD_ADDR_EXP 99
8935: PUSH
8936: LD_EXP 99
8940: PPUSH
8941: LD_INT 3
8943: PPUSH
8944: LD_EXP 99
8948: PUSH
8949: LD_INT 3
8951: ARRAY
8952: PUSH
8953: LD_VAR 0 2
8957: DIFF
8958: PPUSH
8959: CALL_OW 1
8963: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8964: LD_ADDR_VAR 0 3
8968: PUSH
8969: LD_INT 0
8971: PPUSH
8972: LD_INT 2
8974: PPUSH
8975: CALL_OW 12
8979: ST_TO_ADDR
// p := 0 ;
8980: LD_ADDR_VAR 0 4
8984: PUSH
8985: LD_INT 0
8987: ST_TO_ADDR
// if target then
8988: LD_VAR 0 3
8992: IFFALSE 9145
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8994: LD_ADDR_VAR 0 2
8998: PUSH
8999: LD_VAR 0 2
9003: PPUSH
9004: LD_INT 24
9006: PUSH
9007: LD_INT 250
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 72
9018: ST_TO_ADDR
// for i in tmp do
9019: LD_ADDR_VAR 0 1
9023: PUSH
9024: LD_VAR 0 2
9028: PUSH
9029: FOR_IN
9030: IFFALSE 9070
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
9032: LD_VAR 0 1
9036: PPUSH
9037: LD_INT 89
9039: PPUSH
9040: LD_INT 71
9042: PPUSH
9043: CALL_OW 297
9047: PUSH
9048: LD_INT 9
9050: GREATER
9051: IFFALSE 9068
// ComMoveXY ( i , 89 , 71 ) ;
9053: LD_VAR 0 1
9057: PPUSH
9058: LD_INT 89
9060: PPUSH
9061: LD_INT 71
9063: PPUSH
9064: CALL_OW 111
9068: GO 9029
9070: POP
9071: POP
// wait ( 0 0$1 ) ;
9072: LD_INT 35
9074: PPUSH
9075: CALL_OW 67
// p := Inc ( p ) ;
9079: LD_ADDR_VAR 0 4
9083: PUSH
9084: LD_VAR 0 4
9088: PPUSH
9089: CALL 92670 0 1
9093: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9094: LD_VAR 0 2
9098: PPUSH
9099: LD_INT 92
9101: PUSH
9102: LD_INT 89
9104: PUSH
9105: LD_INT 71
9107: PUSH
9108: LD_INT 9
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: LIST
9115: LIST
9116: PPUSH
9117: CALL_OW 72
9121: PUSH
9122: LD_VAR 0 2
9126: PUSH
9127: LD_INT 1
9129: MINUS
9130: GREATEREQUAL
9131: PUSH
9132: LD_VAR 0 4
9136: PUSH
9137: LD_INT 30
9139: GREATER
9140: OR
9141: IFFALSE 8994
// end else
9143: GO 9294
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9145: LD_ADDR_VAR 0 2
9149: PUSH
9150: LD_VAR 0 2
9154: PPUSH
9155: LD_INT 24
9157: PUSH
9158: LD_INT 250
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: PPUSH
9165: CALL_OW 72
9169: ST_TO_ADDR
// for i in tmp do
9170: LD_ADDR_VAR 0 1
9174: PUSH
9175: LD_VAR 0 2
9179: PUSH
9180: FOR_IN
9181: IFFALSE 9221
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
9183: LD_VAR 0 1
9187: PPUSH
9188: LD_INT 147
9190: PPUSH
9191: LD_INT 4
9193: PPUSH
9194: CALL_OW 297
9198: PUSH
9199: LD_INT 9
9201: GREATER
9202: IFFALSE 9219
// ComMoveXY ( i , 147 , 4 ) ;
9204: LD_VAR 0 1
9208: PPUSH
9209: LD_INT 147
9211: PPUSH
9212: LD_INT 4
9214: PPUSH
9215: CALL_OW 111
9219: GO 9180
9221: POP
9222: POP
// wait ( 0 0$1 ) ;
9223: LD_INT 35
9225: PPUSH
9226: CALL_OW 67
// p := Inc ( p ) ;
9230: LD_ADDR_VAR 0 4
9234: PUSH
9235: LD_VAR 0 4
9239: PPUSH
9240: CALL 92670 0 1
9244: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9245: LD_VAR 0 2
9249: PPUSH
9250: LD_INT 92
9252: PUSH
9253: LD_INT 147
9255: PUSH
9256: LD_INT 4
9258: PUSH
9259: LD_INT 9
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: LIST
9266: LIST
9267: PPUSH
9268: CALL_OW 72
9272: PUSH
9273: LD_VAR 0 2
9277: PUSH
9278: LD_INT 1
9280: MINUS
9281: GREATEREQUAL
9282: PUSH
9283: LD_VAR 0 4
9287: PUSH
9288: LD_INT 30
9290: GREATER
9291: OR
9292: IFFALSE 9145
// end ; repeat wait ( 0 0$1 ) ;
9294: LD_INT 35
9296: PPUSH
9297: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
9301: LD_ADDR_VAR 0 2
9305: PUSH
9306: LD_VAR 0 2
9310: PPUSH
9311: LD_INT 50
9313: PUSH
9314: EMPTY
9315: LIST
9316: PPUSH
9317: CALL_OW 72
9321: ST_TO_ADDR
// for i in tmp do
9322: LD_ADDR_VAR 0 1
9326: PUSH
9327: LD_VAR 0 2
9331: PUSH
9332: FOR_IN
9333: IFFALSE 9371
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
9335: LD_VAR 0 1
9339: PPUSH
9340: LD_INT 81
9342: PUSH
9343: LD_INT 8
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: PPUSH
9350: CALL_OW 69
9354: PPUSH
9355: LD_VAR 0 1
9359: PPUSH
9360: CALL_OW 74
9364: PPUSH
9365: CALL_OW 115
9369: GO 9332
9371: POP
9372: POP
// until not tmp ;
9373: LD_VAR 0 2
9377: NOT
9378: IFFALSE 9294
// end ;
9380: PPOPN 4
9382: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
9383: LD_EXP 60
9387: PPUSH
9388: CALL_OW 302
9392: PUSH
9393: LD_EXP 3
9397: NOT
9398: AND
9399: IFFALSE 9408
9401: GO 9403
9403: DISABLE
// BuildKozlovBomb ;
9404: CALL 8241 0 0
9408: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9409: LD_INT 22
9411: PUSH
9412: LD_INT 8
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: PUSH
9419: LD_INT 34
9421: PUSH
9422: LD_INT 48
9424: PUSH
9425: EMPTY
9426: LIST
9427: LIST
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PPUSH
9433: CALL_OW 69
9437: IFFALSE 9485
9439: GO 9441
9441: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9442: LD_INT 22
9444: PUSH
9445: LD_INT 8
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PUSH
9452: LD_INT 34
9454: PUSH
9455: LD_INT 48
9457: PUSH
9458: EMPTY
9459: LIST
9460: LIST
9461: PUSH
9462: EMPTY
9463: LIST
9464: LIST
9465: PPUSH
9466: CALL_OW 69
9470: PUSH
9471: LD_INT 1
9473: ARRAY
9474: PPUSH
9475: LD_INT 173
9477: PPUSH
9478: LD_INT 96
9480: PPUSH
9481: CALL_OW 116
// end ; end_of_file
9485: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9486: LD_INT 0
9488: PPUSH
9489: PPUSH
9490: PPUSH
9491: PPUSH
9492: PPUSH
9493: PPUSH
9494: PPUSH
9495: PPUSH
9496: PPUSH
9497: PPUSH
// side := 3 ;
9498: LD_ADDR_VAR 0 6
9502: PUSH
9503: LD_INT 3
9505: ST_TO_ADDR
// InitHc ;
9506: CALL_OW 19
// uc_side := side ;
9510: LD_ADDR_OWVAR 20
9514: PUSH
9515: LD_VAR 0 6
9519: ST_TO_ADDR
// uc_nation := 3 ;
9520: LD_ADDR_OWVAR 21
9524: PUSH
9525: LD_INT 3
9527: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9528: LD_ADDR_VAR 0 2
9532: PUSH
9533: LD_INT 22
9535: PUSH
9536: LD_VAR 0 6
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PUSH
9545: LD_INT 21
9547: PUSH
9548: LD_INT 3
9550: PUSH
9551: EMPTY
9552: LIST
9553: LIST
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PPUSH
9559: CALL_OW 69
9563: PUSH
9564: FOR_IN
9565: IFFALSE 9581
// SetBLevel ( i , 10 ) ;
9567: LD_VAR 0 2
9571: PPUSH
9572: LD_INT 10
9574: PPUSH
9575: CALL_OW 241
9579: GO 9564
9581: POP
9582: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9583: LD_ADDR_VAR 0 10
9587: PUSH
9588: LD_INT 22
9590: PUSH
9591: LD_VAR 0 6
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: LD_INT 30
9602: PUSH
9603: LD_INT 34
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PPUSH
9614: CALL_OW 69
9618: ST_TO_ADDR
// if teleport then
9619: LD_VAR 0 10
9623: IFFALSE 9644
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9625: LD_VAR 0 10
9629: PUSH
9630: LD_INT 1
9632: ARRAY
9633: PPUSH
9634: LD_INT 123
9636: PPUSH
9637: LD_INT 122
9639: PPUSH
9640: CALL_OW 243
// hc_importance := 0 ;
9644: LD_ADDR_OWVAR 32
9648: PUSH
9649: LD_INT 0
9651: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9652: LD_ADDR_EXP 62
9656: PUSH
9657: LD_STRING Platonov
9659: PPUSH
9660: CALL_OW 25
9664: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9665: LD_ADDR_EXP 63
9669: PUSH
9670: LD_STRING Yakotich
9672: PPUSH
9673: LD_EXP 1
9677: NOT
9678: PPUSH
9679: LD_STRING 09_
9681: PPUSH
9682: CALL 53577 0 3
9686: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9687: LD_ADDR_EXP 64
9691: PUSH
9692: LD_STRING Gleb
9694: PPUSH
9695: CALL_OW 25
9699: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9700: LD_STRING 03_Cornel
9702: PPUSH
9703: CALL_OW 28
9707: IFFALSE 9755
// begin Bierezov := NewCharacter ( Mikhail ) ;
9709: LD_ADDR_EXP 65
9713: PUSH
9714: LD_STRING Mikhail
9716: PPUSH
9717: CALL_OW 25
9721: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9722: LD_EXP 65
9726: PPUSH
9727: LD_INT 197
9729: PPUSH
9730: LD_INT 111
9732: PPUSH
9733: LD_INT 9
9735: PPUSH
9736: LD_INT 0
9738: PPUSH
9739: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9743: LD_EXP 65
9747: PPUSH
9748: LD_INT 3
9750: PPUSH
9751: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9755: LD_EXP 62
9759: PPUSH
9760: LD_INT 126
9762: PPUSH
9763: CALL_OW 52
// if Yakotich then
9767: LD_EXP 63
9771: IFFALSE 9794
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9773: LD_EXP 63
9777: PPUSH
9778: LD_INT 197
9780: PPUSH
9781: LD_INT 111
9783: PPUSH
9784: LD_INT 9
9786: PPUSH
9787: LD_INT 0
9789: PPUSH
9790: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9794: LD_EXP 64
9798: PPUSH
9799: LD_INT 197
9801: PPUSH
9802: LD_INT 111
9804: PPUSH
9805: LD_INT 9
9807: PPUSH
9808: LD_INT 0
9810: PPUSH
9811: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9815: LD_ADDR_VAR 0 5
9819: PUSH
9820: LD_INT 126
9822: PPUSH
9823: LD_INT 2
9825: PPUSH
9826: LD_STRING zhukov
9828: PPUSH
9829: LD_INT 9
9831: PUSH
9832: LD_INT 10
9834: PUSH
9835: LD_INT 10
9837: PUSH
9838: LD_INT 10
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_OWVAR 67
9851: ARRAY
9852: PPUSH
9853: LD_INT 9000
9855: PUSH
9856: LD_INT 1000
9858: PUSH
9859: LD_INT 300
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: LIST
9866: PPUSH
9867: LD_INT 21
9869: PUSH
9870: LD_INT 8
9872: PUSH
9873: LD_INT 13
9875: PUSH
9876: LD_INT 8
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: LIST
9883: LIST
9884: PPUSH
9885: CALL 62259 0 6
9889: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9890: LD_ADDR_EXP 80
9894: PUSH
9895: LD_EXP 80
9899: PPUSH
9900: LD_INT 2
9902: PPUSH
9903: LD_VAR 0 5
9907: PUSH
9908: LD_EXP 63
9912: PUSH
9913: LD_EXP 64
9917: PUSH
9918: LD_EXP 65
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: LIST
9927: UNION
9928: PPUSH
9929: CALL_OW 1
9933: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9934: LD_ADDR_VAR 0 4
9938: PUSH
9939: LD_INT 267
9941: PPUSH
9942: CALL_OW 274
9946: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9947: LD_VAR 0 4
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 5000
9957: PPUSH
9958: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9962: LD_VAR 0 4
9966: PPUSH
9967: LD_INT 2
9969: PPUSH
9970: LD_INT 200
9972: PPUSH
9973: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9977: LD_VAR 0 4
9981: PPUSH
9982: LD_INT 3
9984: PPUSH
9985: LD_INT 200
9987: PPUSH
9988: CALL_OW 277
// for i := 1 to 6 do
9992: LD_ADDR_VAR 0 2
9996: PUSH
9997: DOUBLE
9998: LD_INT 1
10000: DEC
10001: ST_TO_ADDR
10002: LD_INT 6
10004: PUSH
10005: FOR_TO
10006: IFFALSE 10089
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
10008: LD_INT 0
10010: PPUSH
10011: LD_INT 8
10013: PUSH
10014: LD_INT 9
10016: PUSH
10017: LD_INT 10
10019: PUSH
10020: LD_INT 10
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: LIST
10027: LIST
10028: PUSH
10029: LD_OWVAR 67
10033: ARRAY
10034: PPUSH
10035: CALL_OW 381
// un := CreateHuman ;
10039: LD_ADDR_VAR 0 8
10043: PUSH
10044: CALL_OW 44
10048: ST_TO_ADDR
// if i mod 2 = 0 then
10049: LD_VAR 0 2
10053: PUSH
10054: LD_INT 2
10056: MOD
10057: PUSH
10058: LD_INT 0
10060: EQUAL
10061: IFFALSE 10075
// SetClass ( un , class_bazooker ) ;
10063: LD_VAR 0 8
10067: PPUSH
10068: LD_INT 9
10070: PPUSH
10071: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
10075: LD_VAR 0 8
10079: PPUSH
10080: LD_INT 674
10082: PPUSH
10083: CALL_OW 52
// end ;
10087: GO 10005
10089: POP
10090: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
10091: LD_INT 21
10093: PPUSH
10094: LD_INT 3
10096: PPUSH
10097: LD_INT 3
10099: PPUSH
10100: LD_INT 52
10102: PPUSH
10103: LD_INT 100
10105: PPUSH
10106: CALL 58438 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
10110: CALL_OW 45
10114: PPUSH
10115: LD_INT 259
10117: PPUSH
10118: LD_INT 145
10120: PPUSH
10121: LD_INT 3
10123: PPUSH
10124: LD_INT 0
10126: PPUSH
10127: CALL 93449 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
10131: CALL_OW 45
10135: PPUSH
10136: LD_INT 245
10138: PPUSH
10139: LD_INT 139
10141: PPUSH
10142: LD_INT 3
10144: PPUSH
10145: LD_INT 0
10147: PPUSH
10148: CALL 93449 0 5
// behemoths := [ ] ;
10152: LD_ADDR_EXP 66
10156: PUSH
10157: EMPTY
10158: ST_TO_ADDR
// behemothBuilders := [ ] ;
10159: LD_ADDR_EXP 67
10163: PUSH
10164: EMPTY
10165: ST_TO_ADDR
// j := 3 ;
10166: LD_ADDR_VAR 0 3
10170: PUSH
10171: LD_INT 3
10173: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
10174: LD_ADDR_VAR 0 2
10178: PUSH
10179: LD_INT 22
10181: PUSH
10182: LD_INT 3
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: PUSH
10189: LD_INT 25
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: PUSH
10199: EMPTY
10200: LIST
10201: LIST
10202: PPUSH
10203: CALL_OW 69
10207: PUSH
10208: FOR_IN
10209: IFFALSE 10259
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
10211: LD_ADDR_EXP 67
10215: PUSH
10216: LD_EXP 67
10220: PPUSH
10221: LD_VAR 0 2
10225: PPUSH
10226: CALL 91309 0 2
10230: ST_TO_ADDR
// j := j - 1 ;
10231: LD_ADDR_VAR 0 3
10235: PUSH
10236: LD_VAR 0 3
10240: PUSH
10241: LD_INT 1
10243: MINUS
10244: ST_TO_ADDR
// if j = 0 then
10245: LD_VAR 0 3
10249: PUSH
10250: LD_INT 0
10252: EQUAL
10253: IFFALSE 10257
// break ;
10255: GO 10259
// end ;
10257: GO 10208
10259: POP
10260: POP
// end ;
10261: LD_VAR 0 1
10265: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
10266: LD_INT 0
10268: PPUSH
10269: PPUSH
10270: PPUSH
10271: PPUSH
10272: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
10273: LD_ADDR_VAR 0 4
10277: PUSH
10278: LD_INT 209
10280: PUSH
10281: LD_INT 149
10283: PUSH
10284: EMPTY
10285: LIST
10286: LIST
10287: PUSH
10288: LD_INT 219
10290: PUSH
10291: LD_INT 154
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: PUSH
10298: LD_INT 223
10300: PUSH
10301: LD_INT 149
10303: PUSH
10304: EMPTY
10305: LIST
10306: LIST
10307: PUSH
10308: LD_INT 232
10310: PUSH
10311: LD_INT 155
10313: PUSH
10314: EMPTY
10315: LIST
10316: LIST
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: ST_TO_ADDR
// if not behemothBuilders then
10324: LD_EXP 67
10328: NOT
10329: IFFALSE 10333
// exit ;
10331: GO 10437
// j := 1 ;
10333: LD_ADDR_VAR 0 3
10337: PUSH
10338: LD_INT 1
10340: ST_TO_ADDR
// for i in behemothBuilders do
10341: LD_ADDR_VAR 0 2
10345: PUSH
10346: LD_EXP 67
10350: PUSH
10351: FOR_IN
10352: IFFALSE 10435
// begin if IsInUnit ( i ) then
10354: LD_VAR 0 2
10358: PPUSH
10359: CALL_OW 310
10363: IFFALSE 10374
// ComExitBuilding ( i ) ;
10365: LD_VAR 0 2
10369: PPUSH
10370: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
10374: LD_VAR 0 2
10378: PPUSH
10379: LD_INT 37
10381: PPUSH
10382: LD_VAR 0 4
10386: PUSH
10387: LD_VAR 0 3
10391: ARRAY
10392: PUSH
10393: LD_INT 1
10395: ARRAY
10396: PPUSH
10397: LD_VAR 0 4
10401: PUSH
10402: LD_VAR 0 3
10406: ARRAY
10407: PUSH
10408: LD_INT 2
10410: ARRAY
10411: PPUSH
10412: LD_INT 0
10414: PPUSH
10415: CALL_OW 230
// j := j + 1 ;
10419: LD_ADDR_VAR 0 3
10423: PUSH
10424: LD_VAR 0 3
10428: PUSH
10429: LD_INT 1
10431: PLUS
10432: ST_TO_ADDR
// end ;
10433: GO 10351
10435: POP
10436: POP
// end ;
10437: LD_VAR 0 1
10441: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10442: LD_INT 3
10444: PPUSH
10445: CALL 91370 0 1
10449: PUSH
10450: LD_INT 22
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PUSH
10460: LD_INT 30
10462: PUSH
10463: LD_INT 37
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PPUSH
10474: CALL_OW 69
10478: NOT
10479: AND
10480: IFFALSE 10666
10482: GO 10484
10484: DISABLE
10485: LD_INT 0
10487: PPUSH
10488: PPUSH
// begin enable ;
10489: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10490: LD_ADDR_VAR 0 2
10494: PUSH
10495: LD_INT 3
10497: PPUSH
10498: CALL 91370 0 1
10502: ST_TO_ADDR
// for i in tmp do
10503: LD_ADDR_VAR 0 1
10507: PUSH
10508: LD_VAR 0 2
10512: PUSH
10513: FOR_IN
10514: IFFALSE 10664
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10516: LD_VAR 0 1
10520: PPUSH
10521: LD_INT 7
10523: PPUSH
10524: CALL_OW 308
10528: PUSH
10529: LD_VAR 0 1
10533: PPUSH
10534: CALL_OW 110
10538: PUSH
10539: LD_INT 2
10541: EQUAL
10542: NOT
10543: AND
10544: IFFALSE 10558
// SetTag ( i , 2 ) ;
10546: LD_VAR 0 1
10550: PPUSH
10551: LD_INT 2
10553: PPUSH
10554: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10558: LD_INT 81
10560: PUSH
10561: LD_INT 3
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 91
10570: PUSH
10571: LD_VAR 0 1
10575: PUSH
10576: LD_INT 12
10578: PUSH
10579: EMPTY
10580: LIST
10581: LIST
10582: LIST
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PPUSH
10588: CALL_OW 69
10592: NOT
10593: PUSH
10594: LD_VAR 0 1
10598: PPUSH
10599: CALL_OW 110
10603: PUSH
10604: LD_INT 2
10606: EQUAL
10607: NOT
10608: AND
10609: IFFALSE 10628
// ComAgressiveMove ( i , 64 , 93 ) else
10611: LD_VAR 0 1
10615: PPUSH
10616: LD_INT 64
10618: PPUSH
10619: LD_INT 93
10621: PPUSH
10622: CALL_OW 114
10626: GO 10662
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 81
10635: PUSH
10636: LD_INT 3
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PPUSH
10643: CALL_OW 69
10647: PPUSH
10648: LD_VAR 0 1
10652: PPUSH
10653: CALL_OW 74
10657: PPUSH
10658: CALL_OW 115
// end ;
10662: GO 10513
10664: POP
10665: POP
// end ;
10666: PPOPN 2
10668: END
// every 6 6$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10669: LD_EXP 2
10673: NOT
10674: IFFALSE 11760
10676: GO 10678
10678: DISABLE
10679: LD_INT 0
10681: PPUSH
10682: PPUSH
10683: PPUSH
10684: PPUSH
10685: PPUSH
// begin enable ;
10686: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10687: LD_INT 22
10689: PUSH
10690: LD_INT 3
10692: PUSH
10693: EMPTY
10694: LIST
10695: LIST
10696: PUSH
10697: LD_INT 30
10699: PUSH
10700: LD_INT 3
10702: PUSH
10703: EMPTY
10704: LIST
10705: LIST
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: PPUSH
10711: CALL_OW 69
10715: NOT
10716: IFFALSE 10720
// exit ;
10718: GO 11760
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10720: LD_ADDR_VAR 0 4
10724: PUSH
10725: LD_INT 22
10727: PUSH
10728: LD_INT 3
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: LD_INT 30
10737: PUSH
10738: LD_INT 34
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PUSH
10745: EMPTY
10746: LIST
10747: LIST
10748: PPUSH
10749: CALL_OW 69
10753: ST_TO_ADDR
// if Prob ( 40 ) then
10754: LD_INT 40
10756: PPUSH
10757: CALL_OW 13
10761: IFFALSE 10888
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10763: LD_INT 2
10765: PPUSH
10766: LD_INT 22
10768: PUSH
10769: LD_INT 3
10771: PUSH
10772: LD_INT 3
10774: PUSH
10775: LD_INT 49
10777: PUSH
10778: EMPTY
10779: LIST
10780: LIST
10781: LIST
10782: LIST
10783: PUSH
10784: LD_INT 22
10786: PUSH
10787: LD_INT 3
10789: PUSH
10790: LD_INT 3
10792: PUSH
10793: LD_INT 49
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: LIST
10800: LIST
10801: PUSH
10802: LD_INT 22
10804: PUSH
10805: LD_INT 3
10807: PUSH
10808: LD_INT 3
10810: PUSH
10811: LD_INT 49
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: LIST
10818: LIST
10819: PUSH
10820: LD_INT 24
10822: PUSH
10823: LD_INT 3
10825: PUSH
10826: LD_INT 3
10828: PUSH
10829: LD_INT 46
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: LIST
10836: LIST
10837: PUSH
10838: LD_INT 24
10840: PUSH
10841: LD_INT 3
10843: PUSH
10844: LD_INT 3
10846: PUSH
10847: LD_INT 46
10849: PUSH
10850: EMPTY
10851: LIST
10852: LIST
10853: LIST
10854: LIST
10855: PUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 3
10861: PUSH
10862: LD_INT 3
10864: PUSH
10865: LD_INT 46
10867: PUSH
10868: EMPTY
10869: LIST
10870: LIST
10871: LIST
10872: LIST
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL 47151 0 2
// end else
10886: GO 11011
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10888: LD_INT 2
10890: PPUSH
10891: LD_INT 24
10893: PUSH
10894: LD_INT 3
10896: PUSH
10897: LD_INT 3
10899: PUSH
10900: LD_INT 47
10902: PUSH
10903: EMPTY
10904: LIST
10905: LIST
10906: LIST
10907: LIST
10908: PUSH
10909: LD_INT 24
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: LD_INT 3
10917: PUSH
10918: LD_INT 47
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: LIST
10925: LIST
10926: PUSH
10927: LD_INT 24
10929: PUSH
10930: LD_INT 3
10932: PUSH
10933: LD_INT 3
10935: PUSH
10936: LD_INT 47
10938: PUSH
10939: EMPTY
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: PUSH
10945: LD_INT 24
10947: PUSH
10948: LD_INT 3
10950: PUSH
10951: LD_INT 3
10953: PUSH
10954: LD_INT 46
10956: PUSH
10957: EMPTY
10958: LIST
10959: LIST
10960: LIST
10961: LIST
10962: PUSH
10963: LD_INT 24
10965: PUSH
10966: LD_INT 3
10968: PUSH
10969: LD_INT 3
10971: PUSH
10972: LD_INT 46
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: LIST
10979: LIST
10980: PUSH
10981: LD_INT 24
10983: PUSH
10984: LD_INT 3
10986: PUSH
10987: LD_INT 3
10989: PUSH
10990: LD_INT 46
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: LIST
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: LIST
11006: PPUSH
11007: CALL 47151 0 2
// end ; if Difficulty > 1 then
11011: LD_OWVAR 67
11015: PUSH
11016: LD_INT 1
11018: GREATER
11019: IFFALSE 11049
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
11021: LD_INT 2
11023: PPUSH
11024: LD_INT 24
11026: PUSH
11027: LD_INT 3
11029: PUSH
11030: LD_INT 3
11032: PUSH
11033: LD_INT 47
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: LIST
11040: LIST
11041: PUSH
11042: EMPTY
11043: LIST
11044: PPUSH
11045: CALL 47151 0 2
// p := 0 ;
11049: LD_ADDR_VAR 0 5
11053: PUSH
11054: LD_INT 0
11056: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11057: LD_INT 35
11059: PPUSH
11060: CALL_OW 67
// p := Inc ( p ) ;
11064: LD_ADDR_VAR 0 5
11068: PUSH
11069: LD_VAR 0 5
11073: PPUSH
11074: CALL 92670 0 1
11078: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 120 ;
11079: LD_INT 2
11081: PPUSH
11082: LD_INT 1
11084: PPUSH
11085: CALL 48569 0 2
11089: PUSH
11090: LD_INT 6
11092: PUSH
11093: LD_INT 7
11095: PUSH
11096: LD_INT 7
11098: PUSH
11099: LD_INT 7
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: PUSH
11108: LD_OWVAR 67
11112: ARRAY
11113: GREATEREQUAL
11114: PUSH
11115: LD_VAR 0 5
11119: PUSH
11120: LD_INT 120
11122: GREATER
11123: OR
11124: IFFALSE 11057
// wait ( 0 0$30 ) ;
11126: LD_INT 1050
11128: PPUSH
11129: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11133: LD_ADDR_VAR 0 2
11137: PUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 23
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: LD_INT 21
11160: PUSH
11161: LD_INT 2
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 34
11173: PUSH
11174: LD_INT 48
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: LD_INT 3
11187: PUSH
11188: LD_INT 34
11190: PUSH
11191: LD_INT 51
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: EMPTY
11199: LIST
11200: LIST
11201: PUSH
11202: LD_INT 3
11204: PUSH
11205: LD_INT 34
11207: PUSH
11208: LD_INT 52
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: PUSH
11215: EMPTY
11216: LIST
11217: LIST
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: PPUSH
11227: CALL_OW 69
11231: PUSH
11232: LD_EXP 102
11236: PUSH
11237: LD_INT 2
11239: ARRAY
11240: DIFF
11241: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11242: LD_ADDR_EXP 99
11246: PUSH
11247: LD_EXP 99
11251: PPUSH
11252: LD_INT 2
11254: PPUSH
11255: LD_EXP 99
11259: PUSH
11260: LD_INT 2
11262: ARRAY
11263: PUSH
11264: LD_VAR 0 2
11268: DIFF
11269: PPUSH
11270: CALL_OW 1
11274: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11275: LD_ADDR_VAR 0 3
11279: PUSH
11280: LD_INT 0
11282: PPUSH
11283: LD_INT 1
11285: PPUSH
11286: CALL_OW 12
11290: ST_TO_ADDR
// p := 0 ;
11291: LD_ADDR_VAR 0 5
11295: PUSH
11296: LD_INT 0
11298: ST_TO_ADDR
// if target then
11299: LD_VAR 0 3
11303: IFFALSE 11456
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11305: LD_ADDR_VAR 0 2
11309: PUSH
11310: LD_VAR 0 2
11314: PPUSH
11315: LD_INT 24
11317: PUSH
11318: LD_INT 250
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: PPUSH
11325: CALL_OW 72
11329: ST_TO_ADDR
// for i in tmp do
11330: LD_ADDR_VAR 0 1
11334: PUSH
11335: LD_VAR 0 2
11339: PUSH
11340: FOR_IN
11341: IFFALSE 11381
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11343: LD_VAR 0 1
11347: PPUSH
11348: LD_INT 139
11350: PPUSH
11351: LD_INT 89
11353: PPUSH
11354: CALL_OW 297
11358: PUSH
11359: LD_INT 9
11361: GREATER
11362: IFFALSE 11379
// ComMoveXY ( i , 139 , 89 ) ;
11364: LD_VAR 0 1
11368: PPUSH
11369: LD_INT 139
11371: PPUSH
11372: LD_INT 89
11374: PPUSH
11375: CALL_OW 111
11379: GO 11340
11381: POP
11382: POP
// wait ( 0 0$1 ) ;
11383: LD_INT 35
11385: PPUSH
11386: CALL_OW 67
// p := Inc ( p ) ;
11390: LD_ADDR_VAR 0 5
11394: PUSH
11395: LD_VAR 0 5
11399: PPUSH
11400: CALL 92670 0 1
11404: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11405: LD_VAR 0 2
11409: PPUSH
11410: LD_INT 92
11412: PUSH
11413: LD_INT 139
11415: PUSH
11416: LD_INT 89
11418: PUSH
11419: LD_INT 9
11421: PUSH
11422: EMPTY
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: PPUSH
11428: CALL_OW 72
11432: PUSH
11433: LD_VAR 0 2
11437: PUSH
11438: LD_INT 1
11440: MINUS
11441: GREATEREQUAL
11442: PUSH
11443: LD_VAR 0 5
11447: PUSH
11448: LD_INT 30
11450: GREATER
11451: OR
11452: IFFALSE 11305
// end else
11454: GO 11623
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11456: LD_VAR 0 2
11460: PPUSH
11461: LD_VAR 0 4
11465: PUSH
11466: LD_INT 1
11468: ARRAY
11469: PPUSH
11470: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11474: LD_ADDR_VAR 0 2
11478: PUSH
11479: LD_VAR 0 2
11483: PPUSH
11484: LD_INT 24
11486: PUSH
11487: LD_INT 250
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PPUSH
11494: CALL_OW 72
11498: ST_TO_ADDR
// for i in tmp do
11499: LD_ADDR_VAR 0 1
11503: PUSH
11504: LD_VAR 0 2
11508: PUSH
11509: FOR_IN
11510: IFFALSE 11550
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11512: LD_VAR 0 1
11516: PPUSH
11517: LD_INT 124
11519: PPUSH
11520: LD_INT 139
11522: PPUSH
11523: CALL_OW 297
11527: PUSH
11528: LD_INT 9
11530: GREATER
11531: IFFALSE 11548
// ComMoveXY ( i , 124 , 139 ) ;
11533: LD_VAR 0 1
11537: PPUSH
11538: LD_INT 124
11540: PPUSH
11541: LD_INT 139
11543: PPUSH
11544: CALL_OW 111
11548: GO 11509
11550: POP
11551: POP
// wait ( 0 0$1 ) ;
11552: LD_INT 35
11554: PPUSH
11555: CALL_OW 67
// p := Inc ( p ) ;
11559: LD_ADDR_VAR 0 5
11563: PUSH
11564: LD_VAR 0 5
11568: PPUSH
11569: CALL 92670 0 1
11573: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11574: LD_VAR 0 2
11578: PPUSH
11579: LD_INT 92
11581: PUSH
11582: LD_INT 124
11584: PUSH
11585: LD_INT 139
11587: PUSH
11588: LD_INT 9
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: LIST
11595: LIST
11596: PPUSH
11597: CALL_OW 72
11601: PUSH
11602: LD_VAR 0 2
11606: PUSH
11607: LD_INT 1
11609: MINUS
11610: GREATEREQUAL
11611: PUSH
11612: LD_VAR 0 5
11616: PUSH
11617: LD_INT 30
11619: GREATER
11620: OR
11621: IFFALSE 11474
// end ; repeat wait ( 0 0$1 ) ;
11623: LD_INT 35
11625: PPUSH
11626: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11630: LD_ADDR_VAR 0 2
11634: PUSH
11635: LD_VAR 0 2
11639: PPUSH
11640: LD_INT 50
11642: PUSH
11643: EMPTY
11644: LIST
11645: PPUSH
11646: CALL_OW 72
11650: ST_TO_ADDR
// for i in tmp do
11651: LD_ADDR_VAR 0 1
11655: PUSH
11656: LD_VAR 0 2
11660: PUSH
11661: FOR_IN
11662: IFFALSE 11751
// begin if GetWeapon ( i ) = ru_time_lapser then
11664: LD_VAR 0 1
11668: PPUSH
11669: CALL_OW 264
11673: PUSH
11674: LD_INT 49
11676: EQUAL
11677: IFFALSE 11715
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11679: LD_VAR 0 1
11683: PPUSH
11684: LD_INT 81
11686: PUSH
11687: LD_INT 3
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PPUSH
11694: CALL_OW 69
11698: PPUSH
11699: LD_VAR 0 1
11703: PPUSH
11704: CALL_OW 74
11708: PPUSH
11709: CALL_OW 112
11713: GO 11749
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11715: LD_VAR 0 1
11719: PPUSH
11720: LD_INT 81
11722: PUSH
11723: LD_INT 3
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: PPUSH
11730: CALL_OW 69
11734: PPUSH
11735: LD_VAR 0 1
11739: PPUSH
11740: CALL_OW 74
11744: PPUSH
11745: CALL_OW 115
// end ;
11749: GO 11661
11751: POP
11752: POP
// until not tmp ;
11753: LD_VAR 0 2
11757: NOT
11758: IFFALSE 11623
// end ;
11760: PPOPN 5
11762: END
// every 30 30$00 trigger not russianDestroyed do
11763: LD_EXP 2
11767: NOT
11768: IFFALSE 11837
11770: GO 11772
11772: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11773: LD_INT 105000
11775: PUSH
11776: LD_INT 84000
11778: PUSH
11779: LD_INT 63000
11781: PUSH
11782: LD_INT 52500
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: PUSH
11791: LD_OWVAR 67
11795: ARRAY
11796: PPUSH
11797: CALL_OW 67
// if russianDestroyed then
11801: LD_EXP 2
11805: IFFALSE 11809
// exit ;
11807: GO 11837
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11809: LD_INT 2
11811: PPUSH
11812: LD_INT 23
11814: PUSH
11815: LD_INT 3
11817: PUSH
11818: LD_INT 1
11820: PUSH
11821: LD_INT 48
11823: PUSH
11824: EMPTY
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: PUSH
11830: EMPTY
11831: LIST
11832: PPUSH
11833: CALL 47151 0 2
// end ; end_of_file
11837: END
// export function CustomEvent ( event ) ; begin
11838: LD_INT 0
11840: PPUSH
// end ;
11841: LD_VAR 0 2
11845: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11846: LD_VAR 0 2
11850: PPUSH
11851: LD_VAR 0 3
11855: PPUSH
11856: LD_INT 15
11858: PPUSH
11859: CALL_OW 309
11863: IFFALSE 11872
// YouLost ( MothContaminate ) ;
11865: LD_STRING MothContaminate
11867: PPUSH
11868: CALL_OW 104
// end ;
11872: PPOPN 3
11874: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11875: LD_VAR 0 2
11879: PPUSH
11880: LD_VAR 0 3
11884: PPUSH
11885: LD_INT 15
11887: PPUSH
11888: CALL_OW 309
11892: IFFALSE 11908
// begin wait ( 0 0$6 ) ;
11894: LD_INT 210
11896: PPUSH
11897: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11901: LD_STRING MothContaminateBomb
11903: PPUSH
11904: CALL_OW 104
// end ; end ;
11908: PPOPN 3
11910: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11911: LD_VAR 0 1
11915: PPUSH
11916: CALL 112340 0 1
// if un = JMM then
11920: LD_VAR 0 1
11924: PUSH
11925: LD_EXP 21
11929: EQUAL
11930: IFFALSE 11941
// begin YouLost ( JMM ) ;
11932: LD_STRING JMM
11934: PPUSH
11935: CALL_OW 104
// exit ;
11939: GO 12090
// end ; if un = Omar then
11941: LD_VAR 0 1
11945: PUSH
11946: LD_EXP 58
11950: EQUAL
11951: IFFALSE 11961
// omarKilled := true ;
11953: LD_ADDR_EXP 20
11957: PUSH
11958: LD_INT 1
11960: ST_TO_ADDR
// if GetSide ( un ) = 2 and not arabianAttacked then
11961: LD_VAR 0 1
11965: PPUSH
11966: CALL_OW 255
11970: PUSH
11971: LD_INT 2
11973: EQUAL
11974: PUSH
11975: LD_EXP 18
11979: NOT
11980: AND
11981: IFFALSE 11991
// arabianAttacked := true ;
11983: LD_ADDR_EXP 18
11987: PUSH
11988: LD_INT 1
11990: ST_TO_ADDR
// if un = Powell then
11991: LD_VAR 0 1
11995: PUSH
11996: LD_EXP 57
12000: EQUAL
12001: IFFALSE 12011
// americanDestroyed := true ;
12003: LD_ADDR_EXP 4
12007: PUSH
12008: LD_INT 1
12010: ST_TO_ADDR
// if un = Platonov then
12011: LD_VAR 0 1
12015: PUSH
12016: LD_EXP 62
12020: EQUAL
12021: IFFALSE 12031
// russianDestroyed := true ;
12023: LD_ADDR_EXP 2
12027: PUSH
12028: LD_INT 1
12030: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
12031: LD_VAR 0 1
12035: PUSH
12036: LD_INT 22
12038: PUSH
12039: LD_INT 7
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 21
12048: PUSH
12049: LD_INT 2
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PPUSH
12060: CALL_OW 69
12064: IN
12065: IFFALSE 12081
// vehicleLostCounter := vehicleLostCounter + 1 ;
12067: LD_ADDR_EXP 15
12071: PUSH
12072: LD_EXP 15
12076: PUSH
12077: LD_INT 1
12079: PLUS
12080: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
12081: LD_VAR 0 1
12085: PPUSH
12086: CALL 50593 0 1
// end ;
12090: PPOPN 1
12092: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12093: LD_VAR 0 1
12097: PPUSH
12098: LD_VAR 0 2
12102: PPUSH
12103: CALL 52925 0 2
// end ;
12107: PPOPN 2
12109: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12110: LD_VAR 0 1
12114: PPUSH
12115: CALL 51993 0 1
// end ;
12119: PPOPN 1
12121: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
12122: LD_VAR 0 1
12126: PUSH
12127: LD_INT 22
12129: PUSH
12130: LD_INT 8
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 30
12139: PUSH
12140: LD_INT 2
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 23
12149: PUSH
12150: LD_INT 3
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: EMPTY
12158: LIST
12159: LIST
12160: LIST
12161: PPUSH
12162: CALL_OW 69
12166: IN
12167: IFFALSE 12194
// begin ComUpgrade ( building ) ;
12169: LD_VAR 0 1
12173: PPUSH
12174: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
12178: LD_EXP 60
12182: PPUSH
12183: LD_VAR 0 1
12187: PPUSH
12188: CALL 61798 0 2
// exit ;
12192: GO 12203
// end ; MCE_BuildingComplete ( building ) ;
12194: LD_VAR 0 1
12198: PPUSH
12199: CALL 52234 0 1
// end ;
12203: PPOPN 1
12205: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12206: LD_VAR 0 1
12210: PPUSH
12211: LD_VAR 0 2
12215: PPUSH
12216: CALL 50289 0 2
// end ;
12220: PPOPN 2
12222: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12223: LD_VAR 0 1
12227: PPUSH
12228: LD_VAR 0 2
12232: PPUSH
12233: LD_VAR 0 3
12237: PPUSH
12238: LD_VAR 0 4
12242: PPUSH
12243: LD_VAR 0 5
12247: PPUSH
12248: CALL 49909 0 5
// end ;
12252: PPOPN 5
12254: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
12255: LD_VAR 0 1
12259: PPUSH
12260: LD_VAR 0 2
12264: PPUSH
12265: CALL 112398 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
12269: LD_VAR 0 1
12273: PPUSH
12274: LD_VAR 0 2
12278: PPUSH
12279: CALL 49462 0 2
// end ;
12283: PPOPN 2
12285: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12286: LD_VAR 0 1
12290: PPUSH
12291: LD_VAR 0 2
12295: PPUSH
12296: LD_VAR 0 3
12300: PPUSH
12301: LD_VAR 0 4
12305: PPUSH
12306: CALL 49300 0 4
// end ;
12310: PPOPN 4
12312: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12313: LD_VAR 0 1
12317: PPUSH
12318: LD_VAR 0 2
12322: PPUSH
12323: LD_VAR 0 3
12327: PPUSH
12328: CALL 49075 0 3
// end ;
12332: PPOPN 3
12334: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12335: LD_VAR 0 1
12339: PPUSH
12340: LD_VAR 0 2
12344: PPUSH
12345: CALL 48960 0 2
// end ;
12349: PPOPN 2
12351: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12352: LD_VAR 0 1
12356: PPUSH
12357: LD_VAR 0 2
12361: PPUSH
12362: CALL 53220 0 2
// end ;
12366: PPOPN 2
12368: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
12369: LD_VAR 0 1
12373: PUSH
12374: LD_INT 674
12376: EQUAL
12377: IFFALSE 12399
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
12379: LD_VAR 0 2
12383: PPUSH
12384: LD_INT 227
12386: PPUSH
12387: LD_INT 136
12389: PPUSH
12390: CALL_OW 428
12394: PPUSH
12395: CALL_OW 120
// end ;
12399: PPOPN 2
12401: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12402: LD_VAR 0 1
12406: PPUSH
12407: LD_VAR 0 2
12411: PPUSH
12412: LD_VAR 0 3
12416: PPUSH
12417: LD_VAR 0 4
12421: PPUSH
12422: CALL 53436 0 4
// end ;
12426: PPOPN 4
12428: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12429: LD_VAR 0 1
12433: PPUSH
12434: LD_VAR 0 2
12438: PPUSH
12439: CALL 48769 0 2
// end ;
12443: PPOPN 2
12445: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12446: LD_VAR 0 1
12450: PPUSH
12451: CALL 112382 0 1
// end ; end_of_file
12455: PPOPN 1
12457: END
// export function Action ; begin
12458: LD_INT 0
12460: PPUSH
// InGameOn ;
12461: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
12465: LD_INT 206
12467: PPUSH
12468: LD_INT 11
12470: PPUSH
12471: CALL_OW 86
// wait ( 0 0$1 ) ;
12475: LD_INT 35
12477: PPUSH
12478: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
12482: LD_EXP 21
12486: PPUSH
12487: LD_STRING DStart-JMM-JMM-1
12489: PPUSH
12490: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
12494: LD_EXP 54
12498: PPUSH
12499: LD_STRING DStart-JMM-Bur-1
12501: PPUSH
12502: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12506: LD_EXP 21
12510: PPUSH
12511: LD_STRING DStart-JMM-JMM-2
12513: PPUSH
12514: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
12518: LD_EXP 54
12522: PPUSH
12523: LD_STRING DStart-JMM-Bur-2
12525: PPUSH
12526: CALL_OW 88
// InGameOff ;
12530: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12534: LD_STRING MStart
12536: PPUSH
12537: CALL_OW 337
// SaveForQuickRestart ;
12541: CALL_OW 22
// end ;
12545: LD_VAR 0 1
12549: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12550: LD_INT 7
12552: PPUSH
12553: LD_INT 255
12555: PPUSH
12556: LD_INT 219
12558: PPUSH
12559: CALL_OW 293
12563: IFFALSE 13172
12565: GO 12567
12567: DISABLE
12568: LD_INT 0
12570: PPUSH
// begin wait ( 0 0$3 ) ;
12571: LD_INT 105
12573: PPUSH
12574: CALL_OW 67
// alienSpotted := true ;
12578: LD_ADDR_EXP 10
12582: PUSH
12583: LD_INT 1
12585: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12586: LD_ADDR_VAR 0 1
12590: PUSH
12591: LD_INT 22
12593: PUSH
12594: LD_INT 7
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: PUSH
12601: LD_INT 23
12603: PUSH
12604: LD_INT 3
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: LD_INT 21
12613: PUSH
12614: LD_INT 1
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: PUSH
12621: LD_INT 26
12623: PUSH
12624: LD_INT 1
12626: PUSH
12627: EMPTY
12628: LIST
12629: LIST
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: LIST
12635: LIST
12636: PPUSH
12637: CALL_OW 69
12641: PUSH
12642: LD_EXP 54
12646: PUSH
12647: LD_EXP 42
12651: PUSH
12652: LD_EXP 44
12656: PUSH
12657: LD_EXP 45
12661: PUSH
12662: LD_EXP 52
12666: PUSH
12667: LD_EXP 51
12671: PUSH
12672: LD_EXP 46
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: DIFF
12686: ST_TO_ADDR
// DialogueOn ;
12687: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12691: LD_INT 255
12693: PPUSH
12694: LD_INT 219
12696: PPUSH
12697: LD_INT 7
12699: PPUSH
12700: LD_INT 20
12702: NEG
12703: PPUSH
12704: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12708: LD_INT 255
12710: PPUSH
12711: LD_INT 219
12713: PPUSH
12714: CALL_OW 86
// if speaker then
12718: LD_VAR 0 1
12722: IFFALSE 12740
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12724: LD_VAR 0 1
12728: PUSH
12729: LD_INT 1
12731: ARRAY
12732: PPUSH
12733: LD_STRING DAlienBase-RSol1-1
12735: PPUSH
12736: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12740: LD_EXP 21
12744: PPUSH
12745: LD_STRING DAlienBase-JMM-1
12747: PPUSH
12748: CALL_OW 88
// if IsOk ( Burlak ) then
12752: LD_EXP 54
12756: PPUSH
12757: CALL_OW 302
12761: IFFALSE 12782
// begin dwait ( 0 0$1 ) ;
12763: LD_INT 35
12765: PPUSH
12766: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12770: LD_EXP 54
12774: PPUSH
12775: LD_STRING DAlienBase-Bur-1
12777: PPUSH
12778: CALL_OW 88
// end ; if IsOk ( Roth ) then
12782: LD_EXP 22
12786: PPUSH
12787: CALL_OW 302
12791: IFFALSE 12805
// Say ( Roth , DAlienBase-Roth-1 ) ;
12793: LD_EXP 22
12797: PPUSH
12798: LD_STRING DAlienBase-Roth-1
12800: PPUSH
12801: CALL_OW 88
// if IsOk ( Gossudarov ) then
12805: LD_EXP 40
12809: PPUSH
12810: CALL_OW 302
12814: IFFALSE 12830
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12816: LD_EXP 40
12820: PPUSH
12821: LD_STRING DAlienBase-Gos-1
12823: PPUSH
12824: CALL_OW 88
12828: GO 12947
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12830: LD_ADDR_VAR 0 1
12834: PUSH
12835: LD_INT 22
12837: PUSH
12838: LD_INT 7
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: PUSH
12845: LD_INT 25
12847: PUSH
12848: LD_INT 4
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: PUSH
12855: LD_INT 21
12857: PUSH
12858: LD_INT 1
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: PUSH
12865: LD_INT 26
12867: PUSH
12868: LD_INT 1
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PUSH
12875: EMPTY
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: PPUSH
12881: CALL_OW 69
12885: PUSH
12886: LD_EXP 22
12890: PUSH
12891: LD_EXP 21
12895: PUSH
12896: LD_EXP 54
12900: PUSH
12901: LD_EXP 42
12905: PUSH
12906: LD_EXP 52
12910: PUSH
12911: LD_EXP 51
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: DIFF
12924: ST_TO_ADDR
// if speaker then
12925: LD_VAR 0 1
12929: IFFALSE 12947
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12931: LD_VAR 0 1
12935: PUSH
12936: LD_INT 1
12938: ARRAY
12939: PPUSH
12940: LD_STRING DAlienBase-Sci1-1
12942: PPUSH
12943: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12947: LD_INT 255
12949: PPUSH
12950: LD_INT 219
12952: PPUSH
12953: LD_INT 7
12955: PPUSH
12956: CALL_OW 331
// DialogueOff ;
12960: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12964: LD_INT 35
12966: PPUSH
12967: CALL_OW 67
// until IsSelected ( alien ) ;
12971: LD_INT 1
12973: PPUSH
12974: CALL_OW 306
12978: IFFALSE 12964
// if not artifactIResearched or not artifactIIResearched then
12980: LD_EXP 12
12984: NOT
12985: PUSH
12986: LD_EXP 13
12990: NOT
12991: OR
12992: IFFALSE 13172
// begin if IsOk ( Roth ) then
12994: LD_EXP 22
12998: PPUSH
12999: CALL_OW 302
13003: IFFALSE 13019
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
13005: LD_EXP 22
13009: PPUSH
13010: LD_STRING DAlieBaseNotReady-Roth-1
13012: PPUSH
13013: CALL_OW 88
13017: GO 13172
// if IsOk ( Gossudarov ) then
13019: LD_EXP 40
13023: PPUSH
13024: CALL_OW 302
13028: IFFALSE 13044
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
13030: LD_EXP 40
13034: PPUSH
13035: LD_STRING DAlieBaseNotReady-Gos-1
13037: PPUSH
13038: CALL_OW 88
13042: GO 13172
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13044: LD_ADDR_VAR 0 1
13048: PUSH
13049: LD_INT 22
13051: PUSH
13052: LD_INT 7
13054: PUSH
13055: EMPTY
13056: LIST
13057: LIST
13058: PUSH
13059: LD_INT 23
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PUSH
13069: LD_INT 25
13071: PUSH
13072: LD_INT 4
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: LD_INT 21
13081: PUSH
13082: LD_INT 1
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 26
13091: PUSH
13092: LD_INT 1
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: LIST
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL_OW 69
13110: PUSH
13111: LD_EXP 22
13115: PUSH
13116: LD_EXP 21
13120: PUSH
13121: LD_EXP 54
13125: PUSH
13126: LD_EXP 42
13130: PUSH
13131: LD_EXP 52
13135: PUSH
13136: LD_EXP 51
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: DIFF
13149: ST_TO_ADDR
// if speaker then
13150: LD_VAR 0 1
13154: IFFALSE 13172
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
13156: LD_VAR 0 1
13160: PUSH
13161: LD_INT 1
13163: ARRAY
13164: PPUSH
13165: LD_STRING DAlieBaseNotReady-RSci1-1
13167: PPUSH
13168: CALL_OW 88
// end ; end ; end ;
13172: PPOPN 1
13174: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
13175: LD_INT 24
13177: PPUSH
13178: LD_INT 7
13180: PPUSH
13181: CALL_OW 321
13185: PUSH
13186: LD_INT 2
13188: EQUAL
13189: IFFALSE 13880
13191: GO 13193
13193: DISABLE
13194: LD_INT 0
13196: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13197: LD_ADDR_VAR 0 1
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 7
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 23
13214: PUSH
13215: LD_INT 3
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: LD_INT 25
13224: PUSH
13225: LD_INT 4
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PUSH
13232: LD_INT 21
13234: PUSH
13235: LD_INT 1
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: PUSH
13242: LD_INT 26
13244: PUSH
13245: LD_INT 1
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: LIST
13256: LIST
13257: LIST
13258: PPUSH
13259: CALL_OW 69
13263: PUSH
13264: LD_EXP 22
13268: PUSH
13269: LD_EXP 21
13273: PUSH
13274: LD_EXP 54
13278: PUSH
13279: LD_EXP 42
13283: PUSH
13284: LD_EXP 52
13288: PUSH
13289: LD_EXP 51
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: LIST
13301: DIFF
13302: ST_TO_ADDR
// if not speaker then
13303: LD_VAR 0 1
13307: NOT
13308: IFFALSE 13312
// exit ;
13310: GO 13880
// DialogueOn ;
13312: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
13316: LD_VAR 0 1
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: PPUSH
13325: LD_STRING DArtefTechnology-RSci1-1
13327: PPUSH
13328: CALL_OW 88
// if IsOk ( Burlak ) then
13332: LD_EXP 54
13336: PPUSH
13337: CALL_OW 302
13341: IFFALSE 13355
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
13343: LD_EXP 54
13347: PPUSH
13348: LD_STRING DArtefTechnology-Bur-1
13350: PPUSH
13351: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
13355: LD_VAR 0 1
13359: PUSH
13360: LD_INT 1
13362: ARRAY
13363: PPUSH
13364: LD_STRING DArtefTechnology-RSci1-2
13366: PPUSH
13367: CALL_OW 88
// if Denis then
13371: LD_EXP 27
13375: IFFALSE 13392
// speaker := [ Denis ] else
13377: LD_ADDR_VAR 0 1
13381: PUSH
13382: LD_EXP 27
13386: PUSH
13387: EMPTY
13388: LIST
13389: ST_TO_ADDR
13390: GO 13498
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13392: LD_ADDR_VAR 0 1
13396: PUSH
13397: LD_INT 22
13399: PUSH
13400: LD_INT 7
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PUSH
13407: LD_INT 23
13409: PUSH
13410: LD_INT 1
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: PUSH
13417: LD_INT 25
13419: PUSH
13420: LD_INT 4
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: PUSH
13427: LD_INT 21
13429: PUSH
13430: LD_INT 1
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: PUSH
13437: LD_INT 26
13439: PUSH
13440: LD_INT 1
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: PPUSH
13454: CALL_OW 69
13458: PUSH
13459: LD_EXP 22
13463: PUSH
13464: LD_EXP 21
13468: PUSH
13469: LD_EXP 54
13473: PUSH
13474: LD_EXP 42
13478: PUSH
13479: LD_EXP 52
13483: PUSH
13484: LD_EXP 51
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: LIST
13493: LIST
13494: LIST
13495: LIST
13496: DIFF
13497: ST_TO_ADDR
// if speaker then
13498: LD_VAR 0 1
13502: IFFALSE 13520
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
13504: LD_VAR 0 1
13508: PUSH
13509: LD_INT 1
13511: ARRAY
13512: PPUSH
13513: LD_STRING DArtefTechnology-Sci1-2
13515: PPUSH
13516: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13520: LD_ADDR_VAR 0 1
13524: PUSH
13525: LD_INT 22
13527: PUSH
13528: LD_INT 7
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: LD_INT 23
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: LD_INT 25
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: LD_INT 21
13557: PUSH
13558: LD_INT 1
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: LD_INT 26
13567: PUSH
13568: LD_INT 1
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: PPUSH
13582: CALL_OW 69
13586: PUSH
13587: LD_EXP 22
13591: PUSH
13592: LD_EXP 21
13596: PUSH
13597: LD_EXP 54
13601: PUSH
13602: LD_EXP 42
13606: PUSH
13607: LD_EXP 52
13611: PUSH
13612: LD_EXP 51
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: DIFF
13625: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13626: LD_VAR 0 1
13630: PUSH
13631: LD_EXP 9
13635: PUSH
13636: LD_EXP 5
13640: OR
13641: AND
13642: IFFALSE 13876
// begin if arabianDestroyed and IsOk ( Burlak ) then
13644: LD_EXP 5
13648: PUSH
13649: LD_EXP 54
13653: PPUSH
13654: CALL_OW 302
13658: AND
13659: IFFALSE 13675
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13661: LD_EXP 54
13665: PPUSH
13666: LD_STRING DArtefTechnology-Bur-2
13668: PPUSH
13669: CALL_OW 88
13673: GO 13687
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13675: LD_EXP 21
13679: PPUSH
13680: LD_STRING DArtefTechnology-JMM-2
13682: PPUSH
13683: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13687: LD_VAR 0 1
13691: PUSH
13692: LD_INT 1
13694: ARRAY
13695: PPUSH
13696: LD_STRING DArtefTechnology-RSci1-3
13698: PPUSH
13699: CALL_OW 88
// if Denis then
13703: LD_EXP 27
13707: IFFALSE 13724
// speaker := [ Denis ] else
13709: LD_ADDR_VAR 0 1
13713: PUSH
13714: LD_EXP 27
13718: PUSH
13719: EMPTY
13720: LIST
13721: ST_TO_ADDR
13722: GO 13830
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13724: LD_ADDR_VAR 0 1
13728: PUSH
13729: LD_INT 22
13731: PUSH
13732: LD_INT 7
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PUSH
13739: LD_INT 23
13741: PUSH
13742: LD_INT 1
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: PUSH
13749: LD_INT 25
13751: PUSH
13752: LD_INT 4
13754: PUSH
13755: EMPTY
13756: LIST
13757: LIST
13758: PUSH
13759: LD_INT 21
13761: PUSH
13762: LD_INT 1
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: PUSH
13769: LD_INT 26
13771: PUSH
13772: LD_INT 1
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: LIST
13785: PPUSH
13786: CALL_OW 69
13790: PUSH
13791: LD_EXP 22
13795: PUSH
13796: LD_EXP 21
13800: PUSH
13801: LD_EXP 54
13805: PUSH
13806: LD_EXP 42
13810: PUSH
13811: LD_EXP 52
13815: PUSH
13816: LD_EXP 51
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: DIFF
13829: ST_TO_ADDR
// if speaker then
13830: LD_VAR 0 1
13834: IFFALSE 13876
// if alienSpotted then
13836: LD_EXP 10
13840: IFFALSE 13860
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13842: LD_VAR 0 1
13846: PUSH
13847: LD_INT 1
13849: ARRAY
13850: PPUSH
13851: LD_STRING DArtefTechnology-Sci1-3
13853: PPUSH
13854: CALL_OW 88
13858: GO 13876
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13860: LD_VAR 0 1
13864: PUSH
13865: LD_INT 1
13867: ARRAY
13868: PPUSH
13869: LD_STRING DArtefTechnology-Sci1-3a
13871: PPUSH
13872: CALL_OW 88
// end ; DialogueOff ;
13876: CALL_OW 7
// end ;
13880: PPOPN 1
13882: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13883: LD_EXP 12
13887: IFFALSE 14090
13889: GO 13891
13891: DISABLE
13892: LD_INT 0
13894: PPUSH
// begin if Denis then
13895: LD_EXP 27
13899: IFFALSE 13916
// speaker := [ Denis ] else
13901: LD_ADDR_VAR 0 1
13905: PUSH
13906: LD_EXP 27
13910: PUSH
13911: EMPTY
13912: LIST
13913: ST_TO_ADDR
13914: GO 14022
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13916: LD_ADDR_VAR 0 1
13920: PUSH
13921: LD_INT 22
13923: PUSH
13924: LD_INT 7
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: PUSH
13931: LD_INT 23
13933: PUSH
13934: LD_INT 1
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PUSH
13941: LD_INT 25
13943: PUSH
13944: LD_INT 4
13946: PUSH
13947: EMPTY
13948: LIST
13949: LIST
13950: PUSH
13951: LD_INT 21
13953: PUSH
13954: LD_INT 1
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: PUSH
13961: LD_INT 26
13963: PUSH
13964: LD_INT 1
13966: PUSH
13967: EMPTY
13968: LIST
13969: LIST
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: PPUSH
13978: CALL_OW 69
13982: PUSH
13983: LD_EXP 22
13987: PUSH
13988: LD_EXP 21
13992: PUSH
13993: LD_EXP 54
13997: PUSH
13998: LD_EXP 42
14002: PUSH
14003: LD_EXP 52
14007: PUSH
14008: LD_EXP 51
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: LIST
14017: LIST
14018: LIST
14019: LIST
14020: DIFF
14021: ST_TO_ADDR
// if not speaker then
14022: LD_VAR 0 1
14026: NOT
14027: IFFALSE 14031
// exit ;
14029: GO 14090
// DialogueOn ;
14031: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
14035: LD_VAR 0 1
14039: PUSH
14040: LD_INT 1
14042: ARRAY
14043: PPUSH
14044: LD_STRING DArtefTechnologyAm-Sci1-1
14046: PPUSH
14047: CALL_OW 88
// if IsOk ( Burlak ) then
14051: LD_EXP 54
14055: PPUSH
14056: CALL_OW 302
14060: IFFALSE 14074
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
14062: LD_EXP 54
14066: PPUSH
14067: LD_STRING DArtefTechnologyAm-Bur-1
14069: PPUSH
14070: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
14074: LD_EXP 21
14078: PPUSH
14079: LD_STRING DArtefTechnologyAm-JMM-1
14081: PPUSH
14082: CALL_OW 88
// DialogueOff ;
14086: CALL_OW 7
// end ;
14090: PPOPN 1
14092: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
14093: LD_EXP 13
14097: IFFALSE 14299
14099: GO 14101
14101: DISABLE
14102: LD_INT 0
14104: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14105: LD_ADDR_VAR 0 1
14109: PUSH
14110: LD_INT 22
14112: PUSH
14113: LD_INT 7
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: PUSH
14120: LD_INT 23
14122: PUSH
14123: LD_INT 3
14125: PUSH
14126: EMPTY
14127: LIST
14128: LIST
14129: PUSH
14130: LD_INT 25
14132: PUSH
14133: LD_INT 4
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: PUSH
14140: LD_INT 21
14142: PUSH
14143: LD_INT 1
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: PUSH
14150: LD_INT 26
14152: PUSH
14153: LD_INT 1
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: PUSH
14160: EMPTY
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: PPUSH
14167: CALL_OW 69
14171: PUSH
14172: LD_EXP 22
14176: PUSH
14177: LD_EXP 21
14181: PUSH
14182: LD_EXP 54
14186: PUSH
14187: LD_EXP 42
14191: PUSH
14192: LD_EXP 52
14196: PUSH
14197: LD_EXP 51
14201: PUSH
14202: EMPTY
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: DIFF
14210: ST_TO_ADDR
// if not speaker then
14211: LD_VAR 0 1
14215: NOT
14216: IFFALSE 14220
// exit ;
14218: GO 14299
// DialogueOn ;
14220: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
14224: LD_VAR 0 1
14228: PUSH
14229: LD_VAR 0 1
14233: ARRAY
14234: PPUSH
14235: LD_STRING DArtefTechnologyRu-RSci1-1
14237: PPUSH
14238: CALL_OW 88
// if IsOk ( Burlak ) then
14242: LD_EXP 54
14246: PPUSH
14247: CALL_OW 302
14251: IFFALSE 14265
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
14253: LD_EXP 54
14257: PPUSH
14258: LD_STRING DArtefTechnologyRu-Bur-1
14260: PPUSH
14261: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
14265: LD_VAR 0 1
14269: PUSH
14270: LD_VAR 0 1
14274: ARRAY
14275: PPUSH
14276: LD_STRING DArtefTechnologyRu-RSci1-2
14278: PPUSH
14279: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
14283: LD_EXP 21
14287: PPUSH
14288: LD_STRING DArtefTechnologyRu-JMM-1
14290: PPUSH
14291: CALL_OW 88
// DialogueOff ;
14295: CALL_OW 7
// end ;
14299: PPOPN 1
14301: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
14302: LD_INT 24
14304: PPUSH
14305: LD_INT 7
14307: PPUSH
14308: CALL_OW 321
14312: PUSH
14313: LD_INT 2
14315: EQUAL
14316: PUSH
14317: LD_INT 1
14319: PPUSH
14320: CALL_OW 255
14324: PUSH
14325: LD_INT 7
14327: EQUAL
14328: AND
14329: IFFALSE 14497
14331: GO 14333
14333: DISABLE
14334: LD_INT 0
14336: PPUSH
// begin if Denis then
14337: LD_EXP 27
14341: IFFALSE 14358
// speaker := [ Denis ] else
14343: LD_ADDR_VAR 0 1
14347: PUSH
14348: LD_EXP 27
14352: PUSH
14353: EMPTY
14354: LIST
14355: ST_TO_ADDR
14356: GO 14464
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14358: LD_ADDR_VAR 0 1
14362: PUSH
14363: LD_INT 22
14365: PUSH
14366: LD_INT 7
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 23
14375: PUSH
14376: LD_INT 1
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PUSH
14383: LD_INT 25
14385: PUSH
14386: LD_INT 4
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: LD_INT 21
14395: PUSH
14396: LD_INT 1
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: PUSH
14403: LD_INT 26
14405: PUSH
14406: LD_INT 1
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: PPUSH
14420: CALL_OW 69
14424: PUSH
14425: LD_EXP 22
14429: PUSH
14430: LD_EXP 21
14434: PUSH
14435: LD_EXP 54
14439: PUSH
14440: LD_EXP 42
14444: PUSH
14445: LD_EXP 52
14449: PUSH
14450: LD_EXP 51
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: LIST
14462: DIFF
14463: ST_TO_ADDR
// if not speaker then
14464: LD_VAR 0 1
14468: NOT
14469: IFFALSE 14473
// exit ;
14471: GO 14497
// DialogueOn ;
14473: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
14477: LD_VAR 0 1
14481: PUSH
14482: LD_INT 1
14484: ARRAY
14485: PPUSH
14486: LD_STRING DArtefTechnologyArStart-Sci1-1
14488: PPUSH
14489: CALL_OW 88
// DialogueOff ;
14493: CALL_OW 7
// end ;
14497: PPOPN 1
14499: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
14500: LD_EXP 14
14504: IFFALSE 14785
14506: GO 14508
14508: DISABLE
14509: LD_INT 0
14511: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14512: LD_ADDR_VAR 0 1
14516: PUSH
14517: LD_INT 22
14519: PUSH
14520: LD_INT 7
14522: PUSH
14523: EMPTY
14524: LIST
14525: LIST
14526: PUSH
14527: LD_INT 23
14529: PUSH
14530: LD_INT 3
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PUSH
14537: LD_INT 25
14539: PUSH
14540: LD_INT 4
14542: PUSH
14543: EMPTY
14544: LIST
14545: LIST
14546: PUSH
14547: LD_INT 21
14549: PUSH
14550: LD_INT 1
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PUSH
14557: LD_INT 26
14559: PUSH
14560: LD_INT 1
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: PPUSH
14574: CALL_OW 69
14578: PUSH
14579: LD_EXP 22
14583: PUSH
14584: LD_EXP 21
14588: PUSH
14589: LD_EXP 54
14593: PUSH
14594: LD_EXP 42
14598: PUSH
14599: LD_EXP 52
14603: PUSH
14604: LD_EXP 51
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: DIFF
14617: ST_TO_ADDR
// if not speaker then
14618: LD_VAR 0 1
14622: NOT
14623: IFFALSE 14627
// exit ;
14625: GO 14785
// DialogueOn ;
14627: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14631: LD_VAR 0 1
14635: PUSH
14636: LD_INT 1
14638: ARRAY
14639: PPUSH
14640: LD_STRING DArtefTechnologyAr-RSci1-1
14642: PPUSH
14643: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14647: LD_EXP 21
14651: PPUSH
14652: LD_STRING DArtefTechnologyAr-JMM-1
14654: PPUSH
14655: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14659: LD_VAR 0 1
14663: PUSH
14664: LD_INT 1
14666: ARRAY
14667: PPUSH
14668: LD_STRING DArtefTechnologyAr-RSci1-2
14670: PPUSH
14671: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14675: LD_EXP 21
14679: PPUSH
14680: LD_STRING DArtefTechnologyAr-JMM-2
14682: PPUSH
14683: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14687: LD_VAR 0 1
14691: PUSH
14692: LD_INT 1
14694: ARRAY
14695: PPUSH
14696: LD_STRING DArtefTechnologyAr-RSci1-3
14698: PPUSH
14699: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14703: LD_EXP 21
14707: PPUSH
14708: LD_STRING DArtefTechnologyAr-JMM-3
14710: PPUSH
14711: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14715: LD_VAR 0 1
14719: PUSH
14720: LD_INT 1
14722: ARRAY
14723: PPUSH
14724: LD_STRING DArtefTechnologyAr-RSci1-4
14726: PPUSH
14727: CALL_OW 88
// if IsOk ( Burlak ) then
14731: LD_EXP 54
14735: PPUSH
14736: CALL_OW 302
14740: IFFALSE 14754
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14742: LD_EXP 54
14746: PPUSH
14747: LD_STRING DArtefTechnologyAr-Bur-4
14749: PPUSH
14750: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14754: LD_EXP 21
14758: PPUSH
14759: LD_STRING DArtefTechnologyAr-JMM-4
14761: PPUSH
14762: CALL_OW 88
// DialogueOff ;
14766: CALL_OW 7
// wait ( 0 0$45 ) ;
14770: LD_INT 1575
14772: PPUSH
14773: CALL_OW 67
// spawnOmar := true ;
14777: LD_ADDR_EXP 11
14781: PUSH
14782: LD_INT 1
14784: ST_TO_ADDR
// end ;
14785: PPOPN 1
14787: END
// every 0 0$1 trigger spawnOmar and negotiationWithArabs do
14788: LD_EXP 11
14792: PUSH
14793: LD_EXP 19
14797: AND
14798: IFFALSE 15177
14800: GO 14802
14802: DISABLE
// begin PrepareOmarAli ;
14803: CALL 7606 0 0
// if not HasTask ( Omar ) then
14807: LD_EXP 58
14811: PPUSH
14812: CALL_OW 314
14816: NOT
14817: IFFALSE 14834
// ComMoveXY ( Omar , 252 , 220 ) ;
14819: LD_EXP 58
14823: PPUSH
14824: LD_INT 252
14826: PPUSH
14827: LD_INT 220
14829: PPUSH
14830: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14834: LD_INT 35
14836: PPUSH
14837: CALL_OW 67
// if omarKilled then
14841: LD_EXP 20
14845: IFFALSE 14849
// exit ;
14847: GO 15177
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14849: LD_EXP 58
14853: PPUSH
14854: CALL_OW 314
14858: NOT
14859: PUSH
14860: LD_EXP 58
14864: PPUSH
14865: LD_INT 252
14867: PPUSH
14868: LD_INT 220
14870: PPUSH
14871: CALL_OW 297
14875: PUSH
14876: LD_INT 6
14878: GREATER
14879: AND
14880: IFFALSE 14897
// ComMoveXY ( Omar , 252 , 220 ) ;
14882: LD_EXP 58
14886: PPUSH
14887: LD_INT 252
14889: PPUSH
14890: LD_INT 220
14892: PPUSH
14893: CALL_OW 111
// until See ( 7 , Omar ) ;
14897: LD_INT 7
14899: PPUSH
14900: LD_EXP 58
14904: PPUSH
14905: CALL_OW 292
14909: IFFALSE 14834
// CenterNowOnUnits ( Omar ) ;
14911: LD_EXP 58
14915: PPUSH
14916: CALL_OW 87
// DialogueOn ;
14920: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14924: LD_EXP 58
14928: PPUSH
14929: LD_STRING DOmar-Omar-1
14931: PPUSH
14932: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14936: LD_EXP 21
14940: PPUSH
14941: LD_STRING DOmar-JMM-1
14943: PPUSH
14944: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14948: LD_EXP 58
14952: PPUSH
14953: LD_STRING DOmar-Omar-2
14955: PPUSH
14956: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14960: LD_EXP 21
14964: PPUSH
14965: LD_STRING DOmar-JMM-2
14967: PPUSH
14968: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14972: LD_EXP 58
14976: PPUSH
14977: LD_STRING DOmar-Omar-3
14979: PPUSH
14980: CALL_OW 88
// if IsOk ( Burlak ) then
14984: LD_EXP 54
14988: PPUSH
14989: CALL_OW 302
14993: IFFALSE 15009
// Say ( Burlak , DOmar-Bur-3 ) else
14995: LD_EXP 54
14999: PPUSH
15000: LD_STRING DOmar-Bur-3
15002: PPUSH
15003: CALL_OW 88
15007: GO 15021
// Say ( JMM , DOmar-JMM-3 ) ;
15009: LD_EXP 21
15013: PPUSH
15014: LD_STRING DOmar-JMM-3
15016: PPUSH
15017: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
15021: LD_EXP 58
15025: PPUSH
15026: LD_STRING DOmar-Omar-4
15028: PPUSH
15029: CALL_OW 88
// case Query ( QAccept ) of 1 :
15033: LD_STRING QAccept
15035: PPUSH
15036: CALL_OW 97
15040: PUSH
15041: LD_INT 1
15043: DOUBLE
15044: EQUAL
15045: IFTRUE 15049
15047: GO 15085
15049: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
15050: LD_EXP 21
15054: PPUSH
15055: LD_STRING DQrAccept#1-JMM-1
15057: PPUSH
15058: CALL_OW 88
// SetSide ( Omar , 7 ) ;
15062: LD_EXP 58
15066: PPUSH
15067: LD_INT 7
15069: PPUSH
15070: CALL_OW 235
// ComStop ( Omar ) ;
15074: LD_EXP 58
15078: PPUSH
15079: CALL_OW 141
// end ; 2 :
15083: GO 15134
15085: LD_INT 2
15087: DOUBLE
15088: EQUAL
15089: IFTRUE 15093
15091: GO 15133
15093: POP
// begin if IsOk ( Burlak ) then
15094: LD_EXP 54
15098: PPUSH
15099: CALL_OW 302
15103: IFFALSE 15119
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
15105: LD_EXP 54
15109: PPUSH
15110: LD_STRING DQrAccept#2-Bur-1
15112: PPUSH
15113: CALL_OW 88
15117: GO 15131
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
15119: LD_EXP 21
15123: PPUSH
15124: LD_STRING DQrAccept#2-JMM-1
15126: PPUSH
15127: CALL_OW 88
// end ; end ;
15131: GO 15134
15133: POP
// DialogueOff ;
15134: CALL_OW 7
// if GetSide ( Omar ) = 7 then
15138: LD_EXP 58
15142: PPUSH
15143: CALL_OW 255
15147: PUSH
15148: LD_INT 7
15150: EQUAL
15151: IFFALSE 15162
// begin SetAchievement ( ACH_OMAR ) ;
15153: LD_STRING ACH_OMAR
15155: PPUSH
15156: CALL_OW 543
// exit ;
15160: GO 15177
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
15162: LD_EXP 58
15166: PPUSH
15167: LD_INT 202
15169: PPUSH
15170: LD_INT 115
15172: PPUSH
15173: CALL_OW 111
// end ;
15177: END
// every 0 0$1 trigger not omarKilled and russianCapitulated and ( ( IsOk ( Omar ) and GetSide ( Omar ) = 7 ) or not negotiationWithArabs ) do var i ;
15178: LD_EXP 20
15182: NOT
15183: PUSH
15184: LD_EXP 7
15188: AND
15189: PUSH
15190: LD_EXP 58
15194: PPUSH
15195: CALL_OW 302
15199: PUSH
15200: LD_EXP 58
15204: PPUSH
15205: CALL_OW 255
15209: PUSH
15210: LD_INT 7
15212: EQUAL
15213: AND
15214: PUSH
15215: LD_EXP 19
15219: NOT
15220: OR
15221: AND
15222: IFFALSE 15740
15224: GO 15226
15226: DISABLE
15227: LD_INT 0
15229: PPUSH
// begin if not negotiationWithArabs and not omarKilled then
15230: LD_EXP 19
15234: NOT
15235: PUSH
15236: LD_EXP 20
15240: NOT
15241: AND
15242: IFFALSE 15248
// PrepareOmarAli2 ;
15244: CALL 7676 0 0
// wait ( 0 0$2 ) ;
15248: LD_INT 70
15250: PPUSH
15251: CALL_OW 67
// SetSide ( Omar , 5 ) ;
15255: LD_EXP 58
15259: PPUSH
15260: LD_INT 5
15262: PPUSH
15263: CALL_OW 235
// if IsInUnit ( Omar ) then
15267: LD_EXP 58
15271: PPUSH
15272: CALL_OW 310
15276: IFFALSE 15287
// ComExitVehicle ( Omar ) ;
15278: LD_EXP 58
15282: PPUSH
15283: CALL_OW 121
// if IsInUnit ( Omar ) then
15287: LD_EXP 58
15291: PPUSH
15292: CALL_OW 310
15296: IFFALSE 15307
// ComExitBuilding ( Omar ) ;
15298: LD_EXP 58
15302: PPUSH
15303: CALL_OW 122
// wait ( 0 0$1 ) ;
15307: LD_INT 35
15309: PPUSH
15310: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15314: LD_EXP 58
15318: PPUSH
15319: LD_INT 203
15321: PPUSH
15322: LD_INT 120
15324: PPUSH
15325: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15329: LD_INT 35
15331: PPUSH
15332: CALL_OW 67
// if omarKilled then
15336: LD_EXP 20
15340: IFFALSE 15344
// exit ;
15342: GO 15740
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
15344: LD_EXP 58
15348: PPUSH
15349: CALL_OW 306
15353: PUSH
15354: LD_EXP 58
15358: PPUSH
15359: LD_INT 203
15361: PPUSH
15362: LD_INT 120
15364: PPUSH
15365: CALL_OW 297
15369: PUSH
15370: LD_INT 20
15372: LESS
15373: OR
15374: IFFALSE 15329
// DialogueOn ;
15376: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
15380: LD_EXP 58
15384: PPUSH
15385: CALL_OW 250
15389: PPUSH
15390: LD_EXP 58
15394: PPUSH
15395: CALL_OW 251
15399: PPUSH
15400: LD_INT 7
15402: PPUSH
15403: LD_INT 6
15405: NEG
15406: PPUSH
15407: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
15411: LD_EXP 58
15415: PPUSH
15416: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
15420: LD_EXP 21
15424: PPUSH
15425: LD_STRING DOmarContam-JMM-1
15427: PPUSH
15428: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
15432: LD_EXP 58
15436: PPUSH
15437: LD_STRING DOmarContam-Omar-1
15439: PPUSH
15440: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
15444: LD_EXP 21
15448: PPUSH
15449: LD_STRING DOmarContam-JMM-2
15451: PPUSH
15452: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
15456: LD_EXP 58
15460: PPUSH
15461: CALL_OW 250
15465: PPUSH
15466: LD_EXP 58
15470: PPUSH
15471: CALL_OW 251
15475: PPUSH
15476: LD_INT 7
15478: PPUSH
15479: CALL_OW 331
// DialogueOff ;
15483: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
15487: LD_INT 5
15489: PPUSH
15490: LD_INT 7
15492: PPUSH
15493: LD_INT 2
15495: PPUSH
15496: LD_INT 1
15498: PPUSH
15499: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
15503: LD_INT 105
15505: PPUSH
15506: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15510: LD_EXP 58
15514: PPUSH
15515: LD_INT 203
15517: PPUSH
15518: LD_INT 120
15520: PPUSH
15521: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
15525: LD_EXP 58
15529: PPUSH
15530: LD_INT 203
15532: PPUSH
15533: LD_INT 120
15535: PPUSH
15536: CALL_OW 307
15540: IFFALSE 15503
// ComHold ( Omar ) ;
15542: LD_EXP 58
15546: PPUSH
15547: CALL_OW 140
// InGameOn ;
15551: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
15555: LD_INT 203
15557: PPUSH
15558: LD_INT 120
15560: PPUSH
15561: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
15565: LD_INT 203
15567: PPUSH
15568: LD_INT 120
15570: PPUSH
15571: LD_INT 7
15573: PPUSH
15574: LD_INT 30
15576: NEG
15577: PPUSH
15578: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
15582: LD_ADDR_VAR 0 1
15586: PUSH
15587: LD_INT 203
15589: PUSH
15590: LD_INT 120
15592: PUSH
15593: EMPTY
15594: LIST
15595: LIST
15596: PUSH
15597: LD_INT 202
15599: PUSH
15600: LD_INT 125
15602: PUSH
15603: EMPTY
15604: LIST
15605: LIST
15606: PUSH
15607: LD_INT 195
15609: PUSH
15610: LD_INT 117
15612: PUSH
15613: EMPTY
15614: LIST
15615: LIST
15616: PUSH
15617: LD_INT 216
15619: PUSH
15620: LD_INT 123
15622: PUSH
15623: EMPTY
15624: LIST
15625: LIST
15626: PUSH
15627: LD_INT 224
15629: PUSH
15630: LD_INT 131
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: PUSH
15637: LD_INT 212
15639: PUSH
15640: LD_INT 133
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: PUSH
15647: EMPTY
15648: LIST
15649: LIST
15650: LIST
15651: LIST
15652: LIST
15653: LIST
15654: PUSH
15655: FOR_IN
15656: IFFALSE 15692
// begin wait ( 0 0$0.5 ) ;
15658: LD_INT 18
15660: PPUSH
15661: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15665: LD_VAR 0 1
15669: PUSH
15670: LD_INT 1
15672: ARRAY
15673: PPUSH
15674: LD_VAR 0 1
15678: PUSH
15679: LD_INT 2
15681: ARRAY
15682: PPUSH
15683: LD_INT 5
15685: PPUSH
15686: CALL_OW 495
// end ;
15690: GO 15655
15692: POP
15693: POP
// KillUnit ( Omar ) ;
15694: LD_EXP 58
15698: PPUSH
15699: CALL_OW 66
// wait ( 0 0$3 ) ;
15703: LD_INT 105
15705: PPUSH
15706: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15710: LD_EXP 21
15714: PPUSH
15715: LD_STRING D16b-JMM-1
15717: PPUSH
15718: CALL_OW 91
// wait ( 0 0$2 ) ;
15722: LD_INT 70
15724: PPUSH
15725: CALL_OW 67
// InGameOff ;
15729: CALL_OW 9
// YouLost ( MothContaminate ) ;
15733: LD_STRING MothContaminate
15735: PPUSH
15736: CALL_OW 104
// end ;
15740: PPOPN 1
15742: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15743: LD_EXP 4
15747: NOT
15748: PUSH
15749: LD_INT 22
15751: PUSH
15752: LD_INT 1
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: PUSH
15759: LD_INT 34
15761: PUSH
15762: LD_INT 8
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 69
15777: AND
15778: IFFALSE 15897
15780: GO 15782
15782: DISABLE
// begin wait ( 0 0$10 ) ;
15783: LD_INT 350
15785: PPUSH
15786: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15790: LD_EXP 57
15794: PPUSH
15795: CALL_OW 302
15799: NOT
15800: PUSH
15801: LD_INT 22
15803: PUSH
15804: LD_INT 1
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: LD_INT 34
15813: PUSH
15814: LD_INT 8
15816: PUSH
15817: EMPTY
15818: LIST
15819: LIST
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: PPUSH
15825: CALL_OW 69
15829: NOT
15830: OR
15831: IFFALSE 15835
// exit ;
15833: GO 15897
// DialogueOn ;
15835: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15839: LD_EXP 57
15843: PPUSH
15844: LD_STRING DWinAmericans-Pow-1
15846: PPUSH
15847: CALL_OW 94
// if IsOk ( Burlak ) then
15851: LD_EXP 54
15855: PPUSH
15856: CALL_OW 302
15860: IFFALSE 15874
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15862: LD_EXP 54
15866: PPUSH
15867: LD_STRING DWinAmericans-Bur-1
15869: PPUSH
15870: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15874: LD_EXP 21
15878: PPUSH
15879: LD_STRING DWinAmericans-JMM-1
15881: PPUSH
15882: CALL_OW 88
// DialogueOff ;
15886: CALL_OW 7
// YouLost ( AmBomb ) ;
15890: LD_STRING AmBomb
15892: PPUSH
15893: CALL_OW 104
// end ;
15897: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15898: LD_EXP 2
15902: NOT
15903: PUSH
15904: LD_INT 22
15906: PUSH
15907: LD_INT 3
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: PUSH
15914: LD_INT 34
15916: PUSH
15917: LD_INT 48
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: PPUSH
15928: CALL_OW 69
15932: AND
15933: IFFALSE 16052
15935: GO 15937
15937: DISABLE
// begin wait ( 0 0$10 ) ;
15938: LD_INT 350
15940: PPUSH
15941: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15945: LD_EXP 62
15949: PPUSH
15950: CALL_OW 302
15954: NOT
15955: PUSH
15956: LD_INT 22
15958: PUSH
15959: LD_INT 3
15961: PUSH
15962: EMPTY
15963: LIST
15964: LIST
15965: PUSH
15966: LD_INT 34
15968: PUSH
15969: LD_INT 48
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: PUSH
15976: EMPTY
15977: LIST
15978: LIST
15979: PPUSH
15980: CALL_OW 69
15984: NOT
15985: OR
15986: IFFALSE 15990
// exit ;
15988: GO 16052
// DialogueOn ;
15990: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15994: LD_EXP 62
15998: PPUSH
15999: LD_STRING DWinRussians-Pla-1
16001: PPUSH
16002: CALL_OW 94
// if IsOk ( Burlak ) then
16006: LD_EXP 54
16010: PPUSH
16011: CALL_OW 302
16015: IFFALSE 16029
// Say ( Burlak , DWinRussians-Bur-1 ) ;
16017: LD_EXP 54
16021: PPUSH
16022: LD_STRING DWinRussians-Bur-1
16024: PPUSH
16025: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
16029: LD_EXP 21
16033: PPUSH
16034: LD_STRING DWinRussians-JMM-1
16036: PPUSH
16037: CALL_OW 88
// DialogueOff ;
16041: CALL_OW 7
// YouLost ( RuBomb ) ;
16045: LD_STRING RuBomb
16047: PPUSH
16048: CALL_OW 104
// end ;
16052: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
16053: LD_INT 7
16055: PPUSH
16056: LD_INT 22
16058: PUSH
16059: LD_INT 7
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: PPUSH
16066: CALL_OW 70
16070: PUSH
16071: LD_EXP 4
16075: NOT
16076: AND
16077: IFFALSE 16106
16079: GO 16081
16081: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
16082: LD_EXP 57
16086: PPUSH
16087: LD_STRING DSurrenderAmericans-Pow-1
16089: PPUSH
16090: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
16094: LD_EXP 21
16098: PPUSH
16099: LD_STRING DSurrenderAmericans-JMM-1
16101: PPUSH
16102: CALL_OW 88
// end ;
16106: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
16107: LD_INT 2
16109: PPUSH
16110: LD_INT 22
16112: PUSH
16113: LD_INT 7
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: PPUSH
16120: CALL_OW 70
16124: PUSH
16125: LD_EXP 2
16129: NOT
16130: AND
16131: PUSH
16132: LD_EXP 54
16136: AND
16137: IFFALSE 16166
16139: GO 16141
16141: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
16142: LD_EXP 62
16146: PPUSH
16147: LD_STRING DSurrenderRussians-Pla-1
16149: PPUSH
16150: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
16154: LD_EXP 54
16158: PPUSH
16159: LD_STRING DSurrenderRussians-Bur-1
16161: PPUSH
16162: CALL_OW 88
// end ;
16166: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
16167: LD_EXP 4
16171: IFFALSE 16610
16173: GO 16175
16175: DISABLE
16176: LD_INT 0
16178: PPUSH
16179: PPUSH
16180: PPUSH
// begin MC_Kill ( 4 ) ;
16181: LD_INT 4
16183: PPUSH
16184: CALL 23126 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
16188: LD_INT 1
16190: PPUSH
16191: LD_INT 7
16193: PPUSH
16194: LD_INT 1
16196: PPUSH
16197: LD_INT 1
16199: PPUSH
16200: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
16204: LD_ADDR_VAR 0 3
16208: PUSH
16209: LD_INT 22
16211: PUSH
16212: LD_INT 1
16214: PUSH
16215: EMPTY
16216: LIST
16217: LIST
16218: PUSH
16219: LD_INT 50
16221: PUSH
16222: EMPTY
16223: LIST
16224: PUSH
16225: LD_INT 26
16227: PUSH
16228: LD_INT 1
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: PUSH
16235: LD_INT 23
16237: PUSH
16238: LD_INT 1
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: PUSH
16245: EMPTY
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: PPUSH
16251: CALL_OW 69
16255: PUSH
16256: LD_EXP 57
16260: PUSH
16261: LD_EXP 29
16265: PUSH
16266: LD_EXP 26
16270: PUSH
16271: LD_EXP 25
16275: PUSH
16276: LD_EXP 32
16280: PUSH
16281: LD_EXP 30
16285: PUSH
16286: EMPTY
16287: LIST
16288: LIST
16289: LIST
16290: LIST
16291: LIST
16292: LIST
16293: DIFF
16294: ST_TO_ADDR
// if not speaker then
16295: LD_VAR 0 3
16299: NOT
16300: IFFALSE 16340
// begin uc_side := 1 ;
16302: LD_ADDR_OWVAR 20
16306: PUSH
16307: LD_INT 1
16309: ST_TO_ADDR
// uc_nation := 1 ;
16310: LD_ADDR_OWVAR 21
16314: PUSH
16315: LD_INT 1
16317: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16318: LD_INT 1
16320: PPUSH
16321: LD_INT 0
16323: PPUSH
16324: CALL_OW 381
// speaker := CreateHuman ;
16328: LD_ADDR_VAR 0 3
16332: PUSH
16333: CALL_OW 44
16337: ST_TO_ADDR
// end else
16338: GO 16354
// speaker := speaker [ 1 ] ;
16340: LD_ADDR_VAR 0 3
16344: PUSH
16345: LD_VAR 0 3
16349: PUSH
16350: LD_INT 1
16352: ARRAY
16353: ST_TO_ADDR
// DialogueOn ;
16354: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
16358: LD_VAR 0 3
16362: PPUSH
16363: LD_STRING DSurrenderAmericans-Sol1-1a
16365: PPUSH
16366: CALL_OW 94
// DialogueOff ;
16370: CALL_OW 7
// americanCapitulated := true ;
16374: LD_ADDR_EXP 6
16378: PUSH
16379: LD_INT 1
16381: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16382: LD_ADDR_VAR 0 2
16386: PUSH
16387: LD_INT 22
16389: PUSH
16390: LD_INT 1
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PUSH
16397: LD_INT 21
16399: PUSH
16400: LD_INT 1
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: PUSH
16407: EMPTY
16408: LIST
16409: LIST
16410: PPUSH
16411: CALL_OW 69
16415: PUSH
16416: LD_INT 22
16418: PUSH
16419: LD_INT 1
16421: PUSH
16422: EMPTY
16423: LIST
16424: LIST
16425: PUSH
16426: LD_INT 21
16428: PUSH
16429: LD_INT 2
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: PUSH
16436: LD_INT 1
16438: PUSH
16439: EMPTY
16440: LIST
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: LIST
16446: PPUSH
16447: CALL_OW 69
16451: ADD
16452: ST_TO_ADDR
// if tmp then
16453: LD_VAR 0 2
16457: IFFALSE 16610
// repeat wait ( 0 0$1 ) ;
16459: LD_INT 35
16461: PPUSH
16462: CALL_OW 67
// for i in tmp do
16466: LD_ADDR_VAR 0 1
16470: PUSH
16471: LD_VAR 0 2
16475: PUSH
16476: FOR_IN
16477: IFFALSE 16559
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16479: LD_VAR 0 1
16483: PPUSH
16484: CALL_OW 310
16488: PUSH
16489: LD_VAR 0 1
16493: PPUSH
16494: CALL_OW 310
16498: PPUSH
16499: CALL_OW 247
16503: PUSH
16504: LD_INT 3
16506: EQUAL
16507: AND
16508: IFFALSE 16519
// ComExitBuilding ( i ) ;
16510: LD_VAR 0 1
16514: PPUSH
16515: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_INT 122
16526: PPUSH
16527: LD_INT 242
16529: PPUSH
16530: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
16534: LD_VAR 0 1
16538: PPUSH
16539: LD_INT 35
16541: PPUSH
16542: CALL_OW 308
16546: IFFALSE 16557
// RemoveUnit ( i ) ;
16548: LD_VAR 0 1
16552: PPUSH
16553: CALL_OW 64
// end ;
16557: GO 16476
16559: POP
16560: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16561: LD_INT 22
16563: PUSH
16564: LD_INT 1
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: LD_INT 2
16573: PUSH
16574: LD_INT 21
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 33
16586: PUSH
16587: LD_INT 1
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: EMPTY
16595: LIST
16596: LIST
16597: LIST
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PPUSH
16603: CALL_OW 69
16607: NOT
16608: IFFALSE 16459
// end ;
16610: PPOPN 3
16612: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16613: LD_EXP 2
16617: IFFALSE 17066
16619: GO 16621
16621: DISABLE
16622: LD_INT 0
16624: PPUSH
16625: PPUSH
16626: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16627: LD_INT 35
16629: PPUSH
16630: CALL_OW 67
// until IsDead ( Yakotich ) ;
16634: LD_EXP 63
16638: PPUSH
16639: CALL_OW 301
16643: IFFALSE 16627
// MC_Kill ( 2 ) ;
16645: LD_INT 2
16647: PPUSH
16648: CALL 23126 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16652: LD_INT 3
16654: PPUSH
16655: LD_INT 7
16657: PPUSH
16658: LD_INT 1
16660: PPUSH
16661: LD_INT 1
16663: PPUSH
16664: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16668: LD_ADDR_VAR 0 3
16672: PUSH
16673: LD_INT 22
16675: PUSH
16676: LD_INT 3
16678: PUSH
16679: EMPTY
16680: LIST
16681: LIST
16682: PUSH
16683: LD_INT 50
16685: PUSH
16686: EMPTY
16687: LIST
16688: PUSH
16689: LD_INT 26
16691: PUSH
16692: LD_INT 1
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PUSH
16699: LD_INT 23
16701: PUSH
16702: LD_INT 3
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: PPUSH
16715: CALL_OW 69
16719: PUSH
16720: LD_EXP 62
16724: DIFF
16725: ST_TO_ADDR
// if not speaker then
16726: LD_VAR 0 3
16730: NOT
16731: IFFALSE 16771
// begin uc_side := 3 ;
16733: LD_ADDR_OWVAR 20
16737: PUSH
16738: LD_INT 3
16740: ST_TO_ADDR
// uc_nation := 3 ;
16741: LD_ADDR_OWVAR 21
16745: PUSH
16746: LD_INT 3
16748: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16749: LD_INT 1
16751: PPUSH
16752: LD_INT 0
16754: PPUSH
16755: CALL_OW 381
// speaker := CreateHuman ;
16759: LD_ADDR_VAR 0 3
16763: PUSH
16764: CALL_OW 44
16768: ST_TO_ADDR
// end else
16769: GO 16785
// speaker := speaker [ 1 ] ;
16771: LD_ADDR_VAR 0 3
16775: PUSH
16776: LD_VAR 0 3
16780: PUSH
16781: LD_INT 1
16783: ARRAY
16784: ST_TO_ADDR
// DialogueOn ;
16785: CALL_OW 6
// if IsOK ( Burlak ) then
16789: LD_EXP 54
16793: PPUSH
16794: CALL_OW 302
16798: IFFALSE 16814
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16800: LD_VAR 0 3
16804: PPUSH
16805: LD_STRING DSurrenderRussians-RSol1-1
16807: PPUSH
16808: CALL_OW 94
16812: GO 16826
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16814: LD_VAR 0 3
16818: PPUSH
16819: LD_STRING DSurrenderRussians-RSol1-1a
16821: PPUSH
16822: CALL_OW 94
// DialogueOff ;
16826: CALL_OW 7
// russianCapitulated := true ;
16830: LD_ADDR_EXP 7
16834: PUSH
16835: LD_INT 1
16837: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16838: LD_ADDR_VAR 0 2
16842: PUSH
16843: LD_INT 22
16845: PUSH
16846: LD_INT 3
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: LD_INT 21
16855: PUSH
16856: LD_INT 1
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PPUSH
16867: CALL_OW 69
16871: PUSH
16872: LD_INT 22
16874: PUSH
16875: LD_INT 3
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PUSH
16882: LD_INT 21
16884: PUSH
16885: LD_INT 2
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: PUSH
16892: LD_INT 1
16894: PUSH
16895: EMPTY
16896: LIST
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: LIST
16902: PPUSH
16903: CALL_OW 69
16907: ADD
16908: ST_TO_ADDR
// if tmp then
16909: LD_VAR 0 2
16913: IFFALSE 17066
// repeat wait ( 0 0$1 ) ;
16915: LD_INT 35
16917: PPUSH
16918: CALL_OW 67
// for i in tmp do
16922: LD_ADDR_VAR 0 1
16926: PUSH
16927: LD_VAR 0 2
16931: PUSH
16932: FOR_IN
16933: IFFALSE 17015
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16935: LD_VAR 0 1
16939: PPUSH
16940: CALL_OW 310
16944: PUSH
16945: LD_VAR 0 1
16949: PPUSH
16950: CALL_OW 310
16954: PPUSH
16955: CALL_OW 247
16959: PUSH
16960: LD_INT 3
16962: EQUAL
16963: AND
16964: IFFALSE 16975
// ComExitBuilding ( i ) ;
16966: LD_VAR 0 1
16970: PPUSH
16971: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16975: LD_VAR 0 1
16979: PPUSH
16980: LD_INT 154
16982: PPUSH
16983: LD_INT 1
16985: PPUSH
16986: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16990: LD_VAR 0 1
16994: PPUSH
16995: LD_INT 36
16997: PPUSH
16998: CALL_OW 308
17002: IFFALSE 17013
// RemoveUnit ( i ) ;
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL_OW 64
// end ;
17013: GO 16932
17015: POP
17016: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17017: LD_INT 22
17019: PUSH
17020: LD_INT 3
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: LD_INT 2
17029: PUSH
17030: LD_INT 21
17032: PUSH
17033: LD_INT 1
17035: PUSH
17036: EMPTY
17037: LIST
17038: LIST
17039: PUSH
17040: LD_INT 33
17042: PUSH
17043: LD_INT 1
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: PUSH
17050: EMPTY
17051: LIST
17052: LIST
17053: LIST
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PPUSH
17059: CALL_OW 69
17063: NOT
17064: IFFALSE 16915
// end ;
17066: PPOPN 3
17068: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
17069: LD_INT 22
17071: PUSH
17072: LD_INT 8
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PUSH
17079: LD_INT 21
17081: PUSH
17082: LD_INT 1
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PUSH
17089: LD_INT 23
17091: PUSH
17092: LD_INT 2
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PUSH
17099: EMPTY
17100: LIST
17101: LIST
17102: LIST
17103: PPUSH
17104: CALL_OW 69
17108: PUSH
17109: LD_INT 18
17111: LESS
17112: PUSH
17113: LD_EXP 60
17117: PPUSH
17118: CALL_OW 301
17122: OR
17123: PUSH
17124: LD_INT 324
17126: PPUSH
17127: CALL_OW 255
17131: PUSH
17132: LD_INT 7
17134: EQUAL
17135: OR
17136: IFFALSE 17149
17138: GO 17140
17140: DISABLE
// legionDestroyed := true ;
17141: LD_ADDR_EXP 3
17145: PUSH
17146: LD_INT 1
17148: ST_TO_ADDR
17149: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
17150: LD_INT 22
17152: PUSH
17153: LD_INT 2
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: PUSH
17160: LD_INT 21
17162: PUSH
17163: LD_INT 1
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: PUSH
17170: LD_INT 23
17172: PUSH
17173: LD_INT 2
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: LIST
17184: PPUSH
17185: CALL_OW 69
17189: PUSH
17190: LD_INT 9
17192: LESS
17193: PUSH
17194: LD_INT 503
17196: PPUSH
17197: CALL_OW 301
17201: OR
17202: PUSH
17203: LD_INT 503
17205: PPUSH
17206: CALL_OW 255
17210: PUSH
17211: LD_INT 7
17213: EQUAL
17214: OR
17215: IFFALSE 17228
17217: GO 17219
17219: DISABLE
// arabianDestroyed := true ;
17220: LD_ADDR_EXP 5
17224: PUSH
17225: LD_INT 1
17227: ST_TO_ADDR
17228: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
17229: LD_EXP 5
17233: IFFALSE 17477
17235: GO 17237
17237: DISABLE
17238: LD_INT 0
17240: PPUSH
17241: PPUSH
// begin MC_Kill ( 1 ) ;
17242: LD_INT 1
17244: PPUSH
17245: CALL 23126 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17249: LD_ADDR_VAR 0 2
17253: PUSH
17254: LD_INT 22
17256: PUSH
17257: LD_INT 2
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PUSH
17264: LD_INT 21
17266: PUSH
17267: LD_INT 1
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PPUSH
17278: CALL_OW 69
17282: PUSH
17283: LD_INT 22
17285: PUSH
17286: LD_INT 2
17288: PUSH
17289: EMPTY
17290: LIST
17291: LIST
17292: PUSH
17293: LD_INT 21
17295: PUSH
17296: LD_INT 2
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PUSH
17303: LD_INT 1
17305: PUSH
17306: EMPTY
17307: LIST
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: LIST
17313: PPUSH
17314: CALL_OW 69
17318: ADD
17319: ST_TO_ADDR
// if tmp then
17320: LD_VAR 0 2
17324: IFFALSE 17477
// repeat wait ( 0 0$1 ) ;
17326: LD_INT 35
17328: PPUSH
17329: CALL_OW 67
// for i in tmp do
17333: LD_ADDR_VAR 0 1
17337: PUSH
17338: LD_VAR 0 2
17342: PUSH
17343: FOR_IN
17344: IFFALSE 17426
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17346: LD_VAR 0 1
17350: PPUSH
17351: CALL_OW 310
17355: PUSH
17356: LD_VAR 0 1
17360: PPUSH
17361: CALL_OW 310
17365: PPUSH
17366: CALL_OW 247
17370: PUSH
17371: LD_INT 3
17373: EQUAL
17374: AND
17375: IFFALSE 17386
// ComExitBuilding ( i ) ;
17377: LD_VAR 0 1
17381: PPUSH
17382: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
17386: LD_VAR 0 1
17390: PPUSH
17391: LD_INT 254
17393: PPUSH
17394: LD_INT 268
17396: PPUSH
17397: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 34
17408: PPUSH
17409: CALL_OW 308
17413: IFFALSE 17424
// RemoveUnit ( i ) ;
17415: LD_VAR 0 1
17419: PPUSH
17420: CALL_OW 64
// end ;
17424: GO 17343
17426: POP
17427: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17428: LD_INT 22
17430: PUSH
17431: LD_INT 2
17433: PUSH
17434: EMPTY
17435: LIST
17436: LIST
17437: PUSH
17438: LD_INT 2
17440: PUSH
17441: LD_INT 21
17443: PUSH
17444: LD_INT 1
17446: PUSH
17447: EMPTY
17448: LIST
17449: LIST
17450: PUSH
17451: LD_INT 33
17453: PUSH
17454: LD_INT 1
17456: PUSH
17457: EMPTY
17458: LIST
17459: LIST
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: LIST
17465: PUSH
17466: EMPTY
17467: LIST
17468: LIST
17469: PPUSH
17470: CALL_OW 69
17474: NOT
17475: IFFALSE 17326
// end ;
17477: PPOPN 2
17479: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
17480: LD_EXP 3
17484: IFFALSE 17836
17486: GO 17488
17488: DISABLE
17489: LD_INT 0
17491: PPUSH
17492: PPUSH
// begin MC_Kill ( 3 ) ;
17493: LD_INT 3
17495: PPUSH
17496: CALL 23126 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
17500: LD_INT 8
17502: PPUSH
17503: LD_INT 7
17505: PPUSH
17506: LD_INT 1
17508: PPUSH
17509: LD_INT 1
17511: PPUSH
17512: CALL_OW 80
// DialogueOn ;
17516: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
17520: LD_EXP 59
17524: PPUSH
17525: LD_STRING D15-Szulc-1
17527: PPUSH
17528: CALL_OW 94
// DialogueOff ;
17532: CALL_OW 7
// legionCapitulated := true ;
17536: LD_ADDR_EXP 8
17540: PUSH
17541: LD_INT 1
17543: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
17544: LD_ADDR_VAR 0 1
17548: PUSH
17549: LD_INT 22
17551: PUSH
17552: LD_INT 8
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: PUSH
17559: LD_INT 21
17561: PUSH
17562: LD_INT 3
17564: PUSH
17565: EMPTY
17566: LIST
17567: LIST
17568: PUSH
17569: LD_INT 23
17571: PUSH
17572: LD_INT 3
17574: PUSH
17575: EMPTY
17576: LIST
17577: LIST
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: LIST
17583: PPUSH
17584: CALL_OW 69
17588: PUSH
17589: FOR_IN
17590: IFFALSE 17606
// SetLives ( i , 3 ) ;
17592: LD_VAR 0 1
17596: PPUSH
17597: LD_INT 3
17599: PPUSH
17600: CALL_OW 234
17604: GO 17589
17606: POP
17607: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17608: LD_ADDR_VAR 0 2
17612: PUSH
17613: LD_INT 22
17615: PUSH
17616: LD_INT 8
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: PUSH
17623: LD_INT 21
17625: PUSH
17626: LD_INT 1
17628: PUSH
17629: EMPTY
17630: LIST
17631: LIST
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: PPUSH
17637: CALL_OW 69
17641: PUSH
17642: LD_INT 22
17644: PUSH
17645: LD_INT 8
17647: PUSH
17648: EMPTY
17649: LIST
17650: LIST
17651: PUSH
17652: LD_INT 21
17654: PUSH
17655: LD_INT 2
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PUSH
17662: LD_INT 1
17664: PUSH
17665: EMPTY
17666: LIST
17667: PUSH
17668: EMPTY
17669: LIST
17670: LIST
17671: LIST
17672: PPUSH
17673: CALL_OW 69
17677: ADD
17678: ST_TO_ADDR
// if tmp then
17679: LD_VAR 0 2
17683: IFFALSE 17836
// repeat wait ( 0 0$1 ) ;
17685: LD_INT 35
17687: PPUSH
17688: CALL_OW 67
// for i in tmp do
17692: LD_ADDR_VAR 0 1
17696: PUSH
17697: LD_VAR 0 2
17701: PUSH
17702: FOR_IN
17703: IFFALSE 17785
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17705: LD_VAR 0 1
17709: PPUSH
17710: CALL_OW 310
17714: PUSH
17715: LD_VAR 0 1
17719: PPUSH
17720: CALL_OW 310
17724: PPUSH
17725: CALL_OW 247
17729: PUSH
17730: LD_INT 3
17732: EQUAL
17733: AND
17734: IFFALSE 17745
// ComExitBuilding ( i ) ;
17736: LD_VAR 0 1
17740: PPUSH
17741: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_INT 10
17752: PPUSH
17753: LD_INT 1
17755: PPUSH
17756: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17760: LD_VAR 0 1
17764: PPUSH
17765: LD_INT 32
17767: PPUSH
17768: CALL_OW 308
17772: IFFALSE 17783
// RemoveUnit ( i ) ;
17774: LD_VAR 0 1
17778: PPUSH
17779: CALL_OW 64
// end ;
17783: GO 17702
17785: POP
17786: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17787: LD_INT 22
17789: PUSH
17790: LD_INT 8
17792: PUSH
17793: EMPTY
17794: LIST
17795: LIST
17796: PUSH
17797: LD_INT 2
17799: PUSH
17800: LD_INT 21
17802: PUSH
17803: LD_INT 1
17805: PUSH
17806: EMPTY
17807: LIST
17808: LIST
17809: PUSH
17810: LD_INT 33
17812: PUSH
17813: LD_INT 1
17815: PUSH
17816: EMPTY
17817: LIST
17818: LIST
17819: PUSH
17820: EMPTY
17821: LIST
17822: LIST
17823: LIST
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PPUSH
17829: CALL_OW 69
17833: NOT
17834: IFFALSE 17685
// end ;
17836: PPOPN 2
17838: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17839: LD_EXP 5
17843: NOT
17844: PUSH
17845: LD_OWVAR 1
17849: PUSH
17850: LD_INT 63000
17852: GREATEREQUAL
17853: AND
17854: PUSH
17855: LD_OWVAR 67
17859: PUSH
17860: LD_INT 3
17862: LESS
17863: AND
17864: IFFALSE 17873
17866: GO 17868
17868: DISABLE
// AllianceSupport ;
17869: CALL 4711 0 0
17873: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or omarKilled or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17874: LD_EXP 4
17878: PUSH
17879: LD_EXP 2
17883: AND
17884: PUSH
17885: LD_EXP 3
17889: AND
17890: PUSH
17891: LD_EXP 5
17895: AND
17896: PUSH
17897: LD_EXP 6
17901: AND
17902: PUSH
17903: LD_EXP 7
17907: AND
17908: PUSH
17909: LD_EXP 8
17913: AND
17914: PUSH
17915: LD_EXP 58
17919: PPUSH
17920: CALL_OW 255
17924: PUSH
17925: LD_INT 5
17927: NONEQUAL
17928: PUSH
17929: LD_EXP 20
17933: OR
17934: PUSH
17935: LD_EXP 58
17939: PPUSH
17940: CALL_OW 305
17944: NOT
17945: OR
17946: AND
17947: IFFALSE 19532
17949: GO 17951
17951: DISABLE
17952: LD_INT 0
17954: PPUSH
17955: PPUSH
// begin wait ( 0 0$5 ) ;
17956: LD_INT 175
17958: PPUSH
17959: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 3 then
17963: LD_INT 22
17965: PUSH
17966: LD_INT 7
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: PUSH
17973: LD_INT 21
17975: PUSH
17976: LD_INT 1
17978: PUSH
17979: EMPTY
17980: LIST
17981: LIST
17982: PUSH
17983: LD_INT 23
17985: PUSH
17986: LD_INT 1
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 50
17995: PUSH
17996: EMPTY
17997: LIST
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: PPUSH
18005: CALL_OW 69
18009: PPUSH
18010: CALL 55700 0 1
18014: PUSH
18015: LD_INT 3
18017: LESS
18018: IFFALSE 18029
// begin YouLost ( LostVictory ) ;
18020: LD_STRING LostVictory
18022: PPUSH
18023: CALL_OW 104
// exit ;
18027: GO 19532
// end ; music_class := 5 ;
18029: LD_ADDR_OWVAR 72
18033: PUSH
18034: LD_INT 5
18036: ST_TO_ADDR
// music_nat := 5 ;
18037: LD_ADDR_OWVAR 71
18041: PUSH
18042: LD_INT 5
18044: ST_TO_ADDR
// if vehicleLostCounter < 3 then
18045: LD_EXP 15
18049: PUSH
18050: LD_INT 3
18052: LESS
18053: IFFALSE 18062
// SetAchievement ( ACH_ECONOMY ) ;
18055: LD_STRING ACH_ECONOMY
18057: PPUSH
18058: CALL_OW 543
// if tick < 60 60$00 then
18062: LD_OWVAR 1
18066: PUSH
18067: LD_INT 126000
18069: LESS
18070: IFFALSE 18086
// begin wait ( 3 ) ;
18072: LD_INT 3
18074: PPUSH
18075: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
18079: LD_STRING ACH_ASPEED_19
18081: PPUSH
18082: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
18086: LD_EXP 21
18090: PPUSH
18091: CALL_OW 87
// InGameOn ;
18095: CALL_OW 8
// DialogueOn ;
18099: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
18103: LD_EXP 21
18107: PPUSH
18108: LD_STRING DEnd-JMM-JMM-1
18110: PPUSH
18111: CALL_OW 88
// if Joan then
18115: LD_EXP 36
18119: IFFALSE 18135
// Say ( Joan , DEnd-JMM-Joan-1 ) else
18121: LD_EXP 36
18125: PPUSH
18126: LD_STRING DEnd-JMM-Joan-1
18128: PPUSH
18129: CALL_OW 88
18133: GO 18179
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
18135: LD_EXP 23
18139: PUSH
18140: LD_EXP 23
18144: PPUSH
18145: CALL_OW 255
18149: PUSH
18150: LD_INT 7
18152: EQUAL
18153: AND
18154: PUSH
18155: LD_EXP 23
18159: PPUSH
18160: CALL_OW 305
18164: AND
18165: IFFALSE 18179
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
18167: LD_EXP 23
18171: PPUSH
18172: LD_STRING DEnd-JMM-Lisa-1
18174: PPUSH
18175: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
18179: LD_EXP 33
18183: PUSH
18184: LD_EXP 33
18188: PPUSH
18189: CALL_OW 305
18193: AND
18194: IFFALSE 18208
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
18196: LD_EXP 33
18200: PPUSH
18201: LD_STRING DEnd-JMM-Frank-1
18203: PPUSH
18204: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
18208: LD_EXP 26
18212: PUSH
18213: LD_EXP 26
18217: PPUSH
18218: CALL_OW 255
18222: PUSH
18223: LD_INT 7
18225: EQUAL
18226: AND
18227: PUSH
18228: LD_EXP 26
18232: PPUSH
18233: CALL_OW 305
18237: AND
18238: IFFALSE 18252
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
18240: LD_EXP 26
18244: PPUSH
18245: LD_STRING DEnd-JMM-Cyrus-1
18247: PPUSH
18248: CALL_OW 88
// if Burlak then
18252: LD_EXP 54
18256: IFFALSE 18270
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
18258: LD_EXP 54
18262: PPUSH
18263: LD_STRING DEnd-JMM-Bur-1
18265: PPUSH
18266: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
18270: LD_EXP 36
18274: PUSH
18275: LD_EXP 23
18279: AND
18280: PUSH
18281: LD_EXP 23
18285: PPUSH
18286: CALL_OW 255
18290: PUSH
18291: LD_INT 7
18293: EQUAL
18294: AND
18295: PUSH
18296: LD_EXP 23
18300: PPUSH
18301: CALL_OW 305
18305: AND
18306: PUSH
18307: LD_EXP 54
18311: PPUSH
18312: CALL_OW 302
18316: AND
18317: IFFALSE 18331
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
18319: LD_EXP 23
18323: PPUSH
18324: LD_STRING DEnd-Burlak-Lisa-1
18326: PPUSH
18327: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
18331: LD_EXP 55
18335: PUSH
18336: LD_EXP 55
18340: PPUSH
18341: CALL_OW 305
18345: AND
18346: IFFALSE 18360
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18348: LD_EXP 55
18352: PPUSH
18353: LD_STRING DEnd-JMM-Bel-1
18355: PPUSH
18356: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
18360: LD_EXP 56
18364: PUSH
18365: LD_EXP 56
18369: PPUSH
18370: CALL_OW 305
18374: AND
18375: IFFALSE 18389
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18377: LD_EXP 56
18381: PPUSH
18382: LD_STRING DEnd-JMM-Gny-1
18384: PPUSH
18385: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
18389: LD_EXP 31
18393: PUSH
18394: LD_EXP 31
18398: PPUSH
18399: CALL_OW 255
18403: PUSH
18404: LD_INT 7
18406: EQUAL
18407: AND
18408: PUSH
18409: LD_EXP 31
18413: PPUSH
18414: CALL_OW 305
18418: AND
18419: IFFALSE 18433
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
18421: LD_EXP 31
18425: PPUSH
18426: LD_STRING DEnd-JMM-Corn-1
18428: PPUSH
18429: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
18433: LD_EXP 24
18437: PUSH
18438: LD_EXP 24
18442: PPUSH
18443: CALL_OW 255
18447: PUSH
18448: LD_INT 7
18450: EQUAL
18451: AND
18452: PUSH
18453: LD_EXP 24
18457: PPUSH
18458: CALL_OW 305
18462: AND
18463: IFFALSE 18477
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
18465: LD_EXP 24
18469: PPUSH
18470: LD_STRING DEnd-JMM-Don-1
18472: PPUSH
18473: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
18477: LD_EXP 25
18481: PUSH
18482: LD_EXP 25
18486: PPUSH
18487: CALL_OW 255
18491: PUSH
18492: LD_INT 7
18494: EQUAL
18495: AND
18496: PUSH
18497: LD_EXP 25
18501: PPUSH
18502: CALL_OW 305
18506: AND
18507: IFFALSE 18521
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
18509: LD_EXP 25
18513: PPUSH
18514: LD_STRING DEnd-JMM-Bobby-1
18516: PPUSH
18517: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
18521: LD_EXP 27
18525: PUSH
18526: LD_EXP 27
18530: PPUSH
18531: CALL_OW 255
18535: PUSH
18536: LD_INT 7
18538: EQUAL
18539: AND
18540: PUSH
18541: LD_EXP 27
18545: PPUSH
18546: CALL_OW 305
18550: AND
18551: IFFALSE 18565
// Say ( Denis , DEnd-JMM-Den-1 ) ;
18553: LD_EXP 27
18557: PPUSH
18558: LD_STRING DEnd-JMM-Den-1
18560: PPUSH
18561: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
18565: LD_EXP 29
18569: PUSH
18570: LD_EXP 29
18574: PPUSH
18575: CALL_OW 255
18579: PUSH
18580: LD_INT 7
18582: EQUAL
18583: AND
18584: PUSH
18585: LD_EXP 29
18589: PPUSH
18590: CALL_OW 305
18594: AND
18595: IFFALSE 18609
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
18597: LD_EXP 29
18601: PPUSH
18602: LD_STRING DEnd-JMM-Glad-1
18604: PPUSH
18605: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18609: LD_EXP 34
18613: PUSH
18614: LD_EXP 34
18618: PPUSH
18619: CALL_OW 255
18623: PUSH
18624: LD_INT 7
18626: EQUAL
18627: AND
18628: PUSH
18629: LD_EXP 34
18633: PPUSH
18634: CALL_OW 305
18638: AND
18639: IFFALSE 18653
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18641: LD_EXP 34
18645: PPUSH
18646: LD_STRING DEnd-JMM-Yam-1
18648: PPUSH
18649: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
18653: LD_EXP 28
18657: PUSH
18658: LD_EXP 28
18662: PPUSH
18663: CALL_OW 255
18667: PUSH
18668: LD_INT 7
18670: EQUAL
18671: AND
18672: PUSH
18673: LD_EXP 28
18677: PPUSH
18678: CALL_OW 305
18682: AND
18683: IFFALSE 18697
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18685: LD_EXP 28
18689: PPUSH
18690: LD_STRING DEnd-JMM-Brown-1
18692: PPUSH
18693: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
18697: LD_EXP 38
18701: PUSH
18702: LD_EXP 38
18706: PPUSH
18707: CALL_OW 255
18711: PUSH
18712: LD_INT 7
18714: EQUAL
18715: AND
18716: PUSH
18717: LD_EXP 38
18721: PPUSH
18722: CALL_OW 305
18726: AND
18727: IFFALSE 18741
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18729: LD_EXP 38
18733: PPUSH
18734: LD_STRING DEnd-JMM-Con-1
18736: PPUSH
18737: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18741: LD_EXP 32
18745: PUSH
18746: LD_EXP 32
18750: PPUSH
18751: CALL_OW 255
18755: PUSH
18756: LD_INT 7
18758: EQUAL
18759: AND
18760: PUSH
18761: LD_EXP 32
18765: PPUSH
18766: CALL_OW 305
18770: AND
18771: IFFALSE 18785
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18773: LD_EXP 32
18777: PPUSH
18778: LD_STRING DEnd-JMM-Gary-1
18780: PPUSH
18781: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18785: LD_EXP 22
18789: PUSH
18790: LD_EXP 22
18794: PPUSH
18795: CALL_OW 305
18799: AND
18800: IFFALSE 18814
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18802: LD_EXP 22
18806: PPUSH
18807: LD_STRING DEnd-JMM-Roth-1
18809: PPUSH
18810: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18814: LD_EXP 35
18818: PUSH
18819: LD_EXP 22
18823: AND
18824: PUSH
18825: LD_EXP 35
18829: PPUSH
18830: CALL_OW 305
18834: AND
18835: IFFALSE 18849
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18837: LD_EXP 35
18841: PPUSH
18842: LD_STRING DEnd-JMM-Sim-1
18844: PPUSH
18845: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18849: LD_EXP 30
18853: PUSH
18854: LD_EXP 30
18858: PPUSH
18859: CALL_OW 255
18863: PUSH
18864: LD_INT 7
18866: EQUAL
18867: AND
18868: PUSH
18869: LD_EXP 30
18873: PPUSH
18874: CALL_OW 305
18878: AND
18879: IFFALSE 18893
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18881: LD_EXP 30
18885: PPUSH
18886: LD_STRING DEnd-JMM-VanH-1
18888: PPUSH
18889: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18893: LD_EXP 44
18897: PUSH
18898: LD_EXP 44
18902: PPUSH
18903: CALL_OW 305
18907: AND
18908: IFFALSE 18922
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18910: LD_EXP 44
18914: PPUSH
18915: LD_STRING DEnd-JMM-Dol-1
18917: PPUSH
18918: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18922: LD_EXP 34
18926: PUSH
18927: LD_EXP 34
18931: PPUSH
18932: CALL_OW 255
18936: PUSH
18937: LD_INT 7
18939: EQUAL
18940: AND
18941: PUSH
18942: LD_EXP 34
18946: PPUSH
18947: CALL_OW 305
18951: AND
18952: IFFALSE 18966
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18954: LD_EXP 34
18958: PPUSH
18959: LD_STRING DEnd-JMM-Yam-1
18961: PPUSH
18962: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18966: LD_EXP 48
18970: PUSH
18971: LD_EXP 48
18975: PPUSH
18976: CALL_OW 305
18980: AND
18981: IFFALSE 18995
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18983: LD_EXP 48
18987: PPUSH
18988: LD_STRING DEnd-JMM-Kap-1
18990: PPUSH
18991: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18995: LD_EXP 51
18999: PUSH
19000: LD_EXP 51
19004: PPUSH
19005: CALL_OW 305
19009: AND
19010: IFFALSE 19024
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
19012: LD_EXP 51
19016: PPUSH
19017: LD_STRING DEnd-JMM-Kov-1
19019: PPUSH
19020: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
19024: LD_EXP 46
19028: PUSH
19029: LD_EXP 46
19033: PPUSH
19034: CALL_OW 305
19038: AND
19039: IFFALSE 19053
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
19041: LD_EXP 46
19045: PPUSH
19046: LD_STRING DEnd-JMM-Sch-1
19048: PPUSH
19049: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
19053: LD_EXP 42
19057: PUSH
19058: LD_EXP 42
19062: PPUSH
19063: CALL_OW 305
19067: AND
19068: PUSH
19069: LD_EXP 54
19073: PPUSH
19074: CALL_OW 302
19078: AND
19079: IFFALSE 19093
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
19081: LD_EXP 42
19085: PPUSH
19086: LD_STRING DEnd-JMM-Tit-1
19088: PPUSH
19089: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
19093: LD_EXP 47
19097: PUSH
19098: LD_EXP 47
19102: PPUSH
19103: CALL_OW 305
19107: AND
19108: IFFALSE 19122
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
19110: LD_EXP 47
19114: PPUSH
19115: LD_STRING DEnd-JMM-Obl-1
19117: PPUSH
19118: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
19122: LD_EXP 49
19126: PUSH
19127: LD_EXP 49
19131: PPUSH
19132: CALL_OW 305
19136: AND
19137: IFFALSE 19151
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
19139: LD_EXP 49
19143: PPUSH
19144: LD_STRING DEnd-JMM-Lip-1
19146: PPUSH
19147: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
19151: LD_EXP 43
19155: PUSH
19156: LD_EXP 43
19160: PPUSH
19161: CALL_OW 305
19165: AND
19166: PUSH
19167: LD_EXP 54
19171: PPUSH
19172: CALL_OW 302
19176: AND
19177: IFFALSE 19191
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
19179: LD_EXP 43
19183: PPUSH
19184: LD_STRING DEnd-Burlak-Fad-1
19186: PPUSH
19187: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
19191: LD_EXP 50
19195: PUSH
19196: LD_EXP 50
19200: PPUSH
19201: CALL_OW 305
19205: AND
19206: IFFALSE 19220
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
19208: LD_EXP 50
19212: PPUSH
19213: LD_STRING DEnd-Burlak-Ptr-1
19215: PPUSH
19216: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
19220: LD_EXP 52
19224: PUSH
19225: LD_EXP 52
19229: PPUSH
19230: CALL_OW 305
19234: AND
19235: IFFALSE 19249
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
19237: LD_EXP 52
19241: PPUSH
19242: LD_STRING DEnd-Burlak-Kuz-1
19244: PPUSH
19245: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
19249: LD_EXP 41
19253: PUSH
19254: LD_EXP 41
19258: PPUSH
19259: CALL_OW 305
19263: AND
19264: PUSH
19265: LD_EXP 54
19269: PPUSH
19270: CALL_OW 302
19274: AND
19275: IFFALSE 19289
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
19277: LD_EXP 41
19281: PPUSH
19282: LD_STRING DEnd-Burlak-Kir-1
19284: PPUSH
19285: CALL_OW 88
// if Joan then
19289: LD_EXP 36
19293: IFFALSE 19307
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
19295: LD_EXP 36
19299: PPUSH
19300: LD_STRING DEnd-Burlak-Joan-1
19302: PPUSH
19303: CALL_OW 88
// if IsOk ( Burlak ) then
19307: LD_EXP 54
19311: PPUSH
19312: CALL_OW 302
19316: IFFALSE 19330
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
19318: LD_EXP 21
19322: PPUSH
19323: LD_STRING DEnd-Burlak-JMM-1
19325: PPUSH
19326: CALL_OW 88
// dwait ( 0 0$2 ) ;
19330: LD_INT 70
19332: PPUSH
19333: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
19337: LD_EXP 59
19341: PPUSH
19342: LD_STRING DEnd-Szulc
19344: PPUSH
19345: CALL_OW 94
// dwait ( 0 0$1 ) ;
19349: LD_INT 35
19351: PPUSH
19352: CALL_OW 68
// if IsLive ( Burlak ) then
19356: LD_EXP 54
19360: PPUSH
19361: CALL_OW 300
19365: IFFALSE 19377
// med1 := 1 else
19367: LD_ADDR_VAR 0 1
19371: PUSH
19372: LD_INT 1
19374: ST_TO_ADDR
19375: GO 19386
// med1 := - 1 ;
19377: LD_ADDR_VAR 0 1
19381: PUSH
19382: LD_INT 1
19384: NEG
19385: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
19386: LD_EXP 12
19390: PUSH
19391: LD_EXP 13
19395: AND
19396: PUSH
19397: LD_EXP 14
19401: AND
19402: IFFALSE 19414
// med2 := 1 else
19404: LD_ADDR_VAR 0 2
19408: PUSH
19409: LD_INT 1
19411: ST_TO_ADDR
19412: GO 19423
// med2 := - 1 ;
19414: LD_ADDR_VAR 0 2
19418: PUSH
19419: LD_INT 1
19421: NEG
19422: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
19423: LD_STRING Hero
19425: PPUSH
19426: LD_INT 1
19428: PPUSH
19429: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
19433: LD_STRING Artefact
19435: PPUSH
19436: LD_VAR 0 2
19440: PPUSH
19441: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
19445: LD_STRING ReconcileBurlak
19447: PPUSH
19448: LD_VAR 0 1
19452: PPUSH
19453: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
19457: LD_OWVAR 67
19461: PUSH
19462: LD_INT 3
19464: GREATEREQUAL
19465: PUSH
19466: LD_VAR 0 1
19470: PUSH
19471: LD_INT 1
19473: EQUAL
19474: AND
19475: PUSH
19476: LD_VAR 0 2
19480: PUSH
19481: LD_INT 1
19483: EQUAL
19484: AND
19485: IFFALSE 19497
// SetAchievementEX ( ACH_AMER , 19 ) ;
19487: LD_STRING ACH_AMER
19489: PPUSH
19490: LD_INT 19
19492: PPUSH
19493: CALL_OW 564
// GiveMedals ( MAIN ) ;
19497: LD_STRING MAIN
19499: PPUSH
19500: CALL_OW 102
// InGameOff ;
19504: CALL_OW 9
// DialogueOff ;
19508: CALL_OW 7
// music_nat := 1 ;
19512: LD_ADDR_OWVAR 71
19516: PUSH
19517: LD_INT 1
19519: ST_TO_ADDR
// music_class := 4 ;
19520: LD_ADDR_OWVAR 72
19524: PUSH
19525: LD_INT 4
19527: ST_TO_ADDR
// YouWin ;
19528: CALL_OW 103
// end ; end_of_file
19532: PPOPN 2
19534: END
// export function InitNature ; begin
19535: LD_INT 0
19537: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
19538: LD_INT 3
19540: PPUSH
19541: LD_INT 3
19543: PPUSH
19544: LD_INT 2
19546: PPUSH
19547: LD_INT 1
19549: PPUSH
19550: LD_INT 1
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: LD_INT 0
19558: PPUSH
19559: LD_INT 17
19561: PPUSH
19562: LD_INT 0
19564: PPUSH
19565: CALL 87986 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
19569: LD_INT 2
19571: PPUSH
19572: LD_INT 1
19574: PPUSH
19575: LD_INT 1
19577: PPUSH
19578: LD_INT 1
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: LD_INT 0
19586: PPUSH
19587: LD_INT 0
19589: PPUSH
19590: LD_INT 18
19592: PPUSH
19593: LD_INT 0
19595: PPUSH
19596: CALL 87986 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
19600: LD_INT 4
19602: PPUSH
19603: LD_INT 1
19605: PPUSH
19606: LD_INT 2
19608: PPUSH
19609: LD_INT 4
19611: PPUSH
19612: LD_INT 2
19614: PPUSH
19615: LD_INT 1
19617: PPUSH
19618: LD_INT 0
19620: PPUSH
19621: LD_INT 19
19623: PPUSH
19624: LD_INT 0
19626: PPUSH
19627: CALL 87986 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
19631: LD_INT 0
19633: PPUSH
19634: LD_INT 0
19636: PPUSH
19637: LD_INT 0
19639: PPUSH
19640: LD_INT 0
19642: PPUSH
19643: LD_INT 0
19645: PPUSH
19646: LD_INT 0
19648: PPUSH
19649: LD_INT 9
19651: PPUSH
19652: LD_INT 0
19654: PPUSH
19655: LD_INT 20
19657: PPUSH
19658: CALL 87986 0 9
// end ; end_of_file
19662: LD_VAR 0 1
19666: RET
// every 0 0$30 do var time ;
19667: GO 19669
19669: DISABLE
19670: LD_INT 0
19672: PPUSH
// begin time := 0 0$30 ;
19673: LD_ADDR_VAR 0 1
19677: PUSH
19678: LD_INT 1050
19680: ST_TO_ADDR
// repeat wait ( time ) ;
19681: LD_VAR 0 1
19685: PPUSH
19686: CALL_OW 67
// if Prob ( 50 ) then
19690: LD_INT 50
19692: PPUSH
19693: CALL_OW 13
19697: IFFALSE 19726
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
19699: LD_INT 1
19701: PPUSH
19702: LD_INT 5
19704: PPUSH
19705: CALL_OW 12
19709: PPUSH
19710: LD_INT 106
19712: PPUSH
19713: LD_INT 89
19715: PPUSH
19716: LD_INT 45
19718: PPUSH
19719: LD_INT 1
19721: PPUSH
19722: CALL_OW 56
// time := time + 0 0$3 ;
19726: LD_ADDR_VAR 0 1
19730: PUSH
19731: LD_VAR 0 1
19735: PUSH
19736: LD_INT 105
19738: PLUS
19739: ST_TO_ADDR
// if Prob ( 30 ) then
19740: LD_INT 30
19742: PPUSH
19743: CALL_OW 13
19747: IFFALSE 19793
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19749: LD_INT 525
19751: PPUSH
19752: LD_INT 735
19754: PPUSH
19755: CALL_OW 12
19759: PPUSH
19760: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19764: LD_INT 1
19766: PPUSH
19767: LD_INT 5
19769: PPUSH
19770: CALL_OW 12
19774: PPUSH
19775: LD_INT 21
19777: PPUSH
19778: LD_INT 26
19780: PPUSH
19781: LD_INT 12
19783: PPUSH
19784: LD_INT 1
19786: PPUSH
19787: CALL_OW 56
// end else
19791: GO 19829
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19793: LD_INT 700
19795: PPUSH
19796: LD_INT 1225
19798: PPUSH
19799: CALL_OW 12
19803: PPUSH
19804: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19808: LD_INT 1
19810: PPUSH
19811: LD_INT 5
19813: PPUSH
19814: CALL_OW 12
19818: PPUSH
19819: LD_INT 14
19821: PPUSH
19822: LD_INT 1
19824: PPUSH
19825: CALL_OW 55
// end ; if Prob ( 50 ) then
19829: LD_INT 50
19831: PPUSH
19832: CALL_OW 13
19836: IFFALSE 19882
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19838: LD_INT 700
19840: PPUSH
19841: LD_INT 1050
19843: PPUSH
19844: CALL_OW 12
19848: PPUSH
19849: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19853: LD_INT 1
19855: PPUSH
19856: LD_INT 5
19858: PPUSH
19859: CALL_OW 12
19863: PPUSH
19864: LD_INT 181
19866: PPUSH
19867: LD_INT 218
19869: PPUSH
19870: LD_INT 16
19872: PPUSH
19873: LD_INT 1
19875: PPUSH
19876: CALL_OW 56
// end else
19880: GO 19954
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19882: LD_INT 350
19884: PPUSH
19885: LD_INT 525
19887: PPUSH
19888: CALL_OW 12
19892: PPUSH
19893: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19897: LD_INT 1
19899: PPUSH
19900: LD_INT 5
19902: PPUSH
19903: CALL_OW 12
19907: PPUSH
19908: LD_INT 13
19910: PPUSH
19911: LD_INT 1
19913: PPUSH
19914: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19918: LD_INT 350
19920: PPUSH
19921: LD_INT 700
19923: PPUSH
19924: CALL_OW 12
19928: PPUSH
19929: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19933: LD_INT 1
19935: PPUSH
19936: LD_INT 5
19938: PPUSH
19939: CALL_OW 12
19943: PPUSH
19944: LD_INT 33
19946: PPUSH
19947: LD_INT 1
19949: PPUSH
19950: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19954: LD_INT 65
19956: PUSH
19957: LD_INT 62
19959: PUSH
19960: LD_INT 55
19962: PUSH
19963: LD_INT 50
19965: PUSH
19966: EMPTY
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: PUSH
19972: LD_OWVAR 67
19976: ARRAY
19977: PPUSH
19978: CALL_OW 13
19982: IFFALSE 20028
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19984: LD_INT 525
19986: PPUSH
19987: LD_INT 875
19989: PPUSH
19990: CALL_OW 12
19994: PPUSH
19995: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19999: LD_INT 1
20001: PPUSH
20002: LD_INT 5
20004: PPUSH
20005: CALL_OW 12
20009: PPUSH
20010: LD_INT 294
20012: PPUSH
20013: LD_INT 211
20015: PPUSH
20016: LD_INT 30
20018: PPUSH
20019: LD_INT 1
20021: PPUSH
20022: CALL_OW 56
// end else
20026: GO 20070
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
20028: LD_INT 420
20030: PPUSH
20031: LD_INT 770
20033: PPUSH
20034: CALL_OW 12
20038: PPUSH
20039: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
20043: LD_INT 1
20045: PPUSH
20046: LD_INT 5
20048: PPUSH
20049: CALL_OW 12
20053: PPUSH
20054: LD_INT 294
20056: PPUSH
20057: LD_INT 211
20059: PPUSH
20060: LD_INT 30
20062: PPUSH
20063: LD_INT 1
20065: PPUSH
20066: CALL_OW 56
// end ; if time > 2 2$20 then
20070: LD_VAR 0 1
20074: PUSH
20075: LD_INT 4900
20077: GREATER
20078: IFFALSE 20088
// time := 0 0$50 ;
20080: LD_ADDR_VAR 0 1
20084: PUSH
20085: LD_INT 1750
20087: ST_TO_ADDR
// until false ;
20088: LD_INT 0
20090: IFFALSE 19681
// end ;
20092: PPOPN 1
20094: END
// every 0 0$45 trigger tick < 10 10$00 do
20095: LD_OWVAR 1
20099: PUSH
20100: LD_INT 21000
20102: LESS
20103: IFFALSE 20151
20105: GO 20107
20107: DISABLE
// begin enable ;
20108: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
20109: LD_INT 350
20111: PPUSH
20112: LD_INT 700
20114: PPUSH
20115: CALL_OW 12
20119: PPUSH
20120: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
20124: LD_INT 3
20126: PPUSH
20127: LD_INT 5
20129: PPUSH
20130: CALL_OW 12
20134: PPUSH
20135: LD_INT 181
20137: PPUSH
20138: LD_INT 13
20140: PPUSH
20141: LD_INT 20
20143: PPUSH
20144: LD_INT 1
20146: PPUSH
20147: CALL_OW 56
// end ; end_of_file
20151: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
20152: LD_INT 0
20154: PPUSH
// SetArtifactRes ( 7 , true ) ;
20155: LD_INT 7
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
20165: LD_ADDR_EXP 68
20169: PUSH
20170: EMPTY
20171: PUSH
20172: EMPTY
20173: PUSH
20174: EMPTY
20175: PUSH
20176: EMPTY
20177: LIST
20178: LIST
20179: LIST
20180: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
20181: LD_ADDR_EXP 69
20185: PUSH
20186: LD_INT 1050
20188: PUSH
20189: LD_OWVAR 67
20193: MUL
20194: PUSH
20195: LD_INT 2800
20197: PUSH
20198: LD_OWVAR 67
20202: MUL
20203: PUSH
20204: LD_INT 1
20206: NEG
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: LIST
20212: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
20213: LD_ADDR_EXP 70
20217: PUSH
20218: LD_INT 10
20220: PUSH
20221: LD_INT 35
20223: PUSH
20224: LD_INT 100
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: LIST
20231: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
20232: LD_ADDR_EXP 71
20236: PUSH
20237: LD_INT 0
20239: PUSH
20240: LD_INT 0
20242: PUSH
20243: LD_INT 0
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: LIST
20250: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
20251: LD_ADDR_EXP 73
20255: PUSH
20256: LD_INT 300
20258: PUSH
20259: LD_INT 500
20261: PUSH
20262: LD_INT 800
20264: PUSH
20265: EMPTY
20266: LIST
20267: LIST
20268: LIST
20269: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
20270: LD_ADDR_EXP 74
20274: PUSH
20275: LD_INT 0
20277: PUSH
20278: LD_INT 0
20280: PUSH
20281: LD_INT 0
20283: PUSH
20284: EMPTY
20285: LIST
20286: LIST
20287: LIST
20288: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
20289: LD_ADDR_EXP 75
20293: PUSH
20294: LD_INT 0
20296: PUSH
20297: LD_INT 0
20299: PUSH
20300: LD_INT 0
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: LIST
20307: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
20308: LD_ADDR_EXP 72
20312: PUSH
20313: LD_INT 0
20315: PUSH
20316: LD_INT 0
20318: PUSH
20319: LD_INT 0
20321: PUSH
20322: EMPTY
20323: LIST
20324: LIST
20325: LIST
20326: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
20327: LD_ADDR_EXP 76
20331: PUSH
20332: LD_INT 4
20334: PUSH
20335: LD_INT 3
20337: PUSH
20338: LD_INT 1
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: PUSH
20346: LD_INT 5
20348: PUSH
20349: LD_INT 4
20351: PUSH
20352: LD_INT 2
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: PUSH
20360: LD_INT 6
20362: PUSH
20363: LD_INT 3
20365: PUSH
20366: LD_INT 3
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: LIST
20373: PUSH
20374: EMPTY
20375: LIST
20376: LIST
20377: LIST
20378: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
20379: LD_ADDR_EXP 77
20383: PUSH
20384: LD_INT 0
20386: PUSH
20387: LD_INT 0
20389: PUSH
20390: LD_INT 0
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: ST_TO_ADDR
// end ;
20398: LD_VAR 0 1
20402: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
20403: LD_INT 24
20405: PPUSH
20406: LD_INT 7
20408: PPUSH
20409: CALL_OW 321
20413: PUSH
20414: LD_INT 2
20416: EQUAL
20417: IFFALSE 21343
20419: GO 20421
20421: DISABLE
20422: LD_INT 0
20424: PPUSH
20425: PPUSH
20426: PPUSH
20427: PPUSH
20428: PPUSH
// begin enable ;
20429: ENABLE
// for i = 1 to 3 do
20430: LD_ADDR_VAR 0 1
20434: PUSH
20435: DOUBLE
20436: LD_INT 1
20438: DEC
20439: ST_TO_ADDR
20440: LD_INT 3
20442: PUSH
20443: FOR_TO
20444: IFFALSE 21341
// begin pos := FindArtifact ( i + 2 ) ;
20446: LD_ADDR_VAR 0 2
20450: PUSH
20451: LD_VAR 0 1
20455: PUSH
20456: LD_INT 2
20458: PLUS
20459: PPUSH
20460: CALL_OW 469
20464: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
20465: LD_ADDR_EXP 68
20469: PUSH
20470: LD_EXP 68
20474: PPUSH
20475: LD_VAR 0 1
20479: PPUSH
20480: LD_VAR 0 2
20484: PPUSH
20485: CALL_OW 1
20489: ST_TO_ADDR
// if pos then
20490: LD_VAR 0 2
20494: IFFALSE 21202
// begin case i of 1 :
20496: LD_VAR 0 1
20500: PUSH
20501: LD_INT 1
20503: DOUBLE
20504: EQUAL
20505: IFTRUE 20509
20507: GO 20586
20509: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
20510: LD_ADDR_VAR 0 4
20514: PUSH
20515: LD_INT 22
20517: PUSH
20518: LD_INT 7
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: PUSH
20525: LD_INT 23
20527: PUSH
20528: LD_INT 1
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: LD_INT 2
20537: PUSH
20538: LD_INT 30
20540: PUSH
20541: LD_INT 8
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 30
20550: PUSH
20551: LD_INT 7
20553: PUSH
20554: EMPTY
20555: LIST
20556: LIST
20557: PUSH
20558: LD_INT 30
20560: PUSH
20561: LD_INT 11
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: PUSH
20568: EMPTY
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: PUSH
20574: EMPTY
20575: LIST
20576: LIST
20577: LIST
20578: PPUSH
20579: CALL_OW 69
20583: ST_TO_ADDR
20584: GO 20694
20586: LD_INT 2
20588: DOUBLE
20589: EQUAL
20590: IFTRUE 20594
20592: GO 20671
20594: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
20595: LD_ADDR_VAR 0 4
20599: PUSH
20600: LD_INT 22
20602: PUSH
20603: LD_INT 7
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PUSH
20610: LD_INT 23
20612: PUSH
20613: LD_INT 3
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PUSH
20620: LD_INT 2
20622: PUSH
20623: LD_INT 30
20625: PUSH
20626: LD_INT 8
20628: PUSH
20629: EMPTY
20630: LIST
20631: LIST
20632: PUSH
20633: LD_INT 30
20635: PUSH
20636: LD_INT 7
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: PUSH
20643: LD_INT 30
20645: PUSH
20646: LD_INT 11
20648: PUSH
20649: EMPTY
20650: LIST
20651: LIST
20652: PUSH
20653: EMPTY
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: PUSH
20659: EMPTY
20660: LIST
20661: LIST
20662: LIST
20663: PPUSH
20664: CALL_OW 69
20668: ST_TO_ADDR
20669: GO 20694
20671: LD_INT 3
20673: DOUBLE
20674: EQUAL
20675: IFTRUE 20679
20677: GO 20693
20679: POP
// labs := [ alien ] ; end ;
20680: LD_ADDR_VAR 0 4
20684: PUSH
20685: LD_INT 1
20687: PUSH
20688: EMPTY
20689: LIST
20690: ST_TO_ADDR
20691: GO 20694
20693: POP
// if not labs then
20694: LD_VAR 0 4
20698: NOT
20699: IFFALSE 20703
// continue ;
20701: GO 20443
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
20703: LD_ADDR_VAR 0 5
20707: PUSH
20708: LD_VAR 0 4
20712: PPUSH
20713: LD_EXP 68
20717: PUSH
20718: LD_VAR 0 1
20722: ARRAY
20723: PUSH
20724: LD_INT 1
20726: ARRAY
20727: PPUSH
20728: LD_EXP 68
20732: PUSH
20733: LD_VAR 0 1
20737: ARRAY
20738: PUSH
20739: LD_INT 2
20741: ARRAY
20742: PPUSH
20743: CALL_OW 73
20747: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20748: LD_VAR 0 5
20752: NOT
20753: PUSH
20754: LD_VAR 0 5
20758: PUSH
20759: LD_EXP 75
20763: PUSH
20764: LD_VAR 0 1
20768: ARRAY
20769: NONEQUAL
20770: OR
20771: IFFALSE 20876
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20773: LD_INT 7
20775: PPUSH
20776: LD_EXP 76
20780: PUSH
20781: LD_VAR 0 1
20785: ARRAY
20786: PUSH
20787: LD_INT 3
20789: ARRAY
20790: PPUSH
20791: LD_INT 0
20793: PPUSH
20794: LD_EXP 75
20798: PUSH
20799: LD_VAR 0 1
20803: ARRAY
20804: PPUSH
20805: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20809: LD_INT 7
20811: PPUSH
20812: LD_EXP 76
20816: PUSH
20817: LD_VAR 0 1
20821: ARRAY
20822: PUSH
20823: LD_INT 1
20825: ARRAY
20826: PPUSH
20827: LD_INT 0
20829: PPUSH
20830: LD_EXP 75
20834: PUSH
20835: LD_VAR 0 1
20839: ARRAY
20840: PPUSH
20841: CALL_OW 468
// if nearestLab then
20845: LD_VAR 0 5
20849: IFFALSE 20876
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20851: LD_ADDR_EXP 75
20855: PUSH
20856: LD_EXP 75
20860: PPUSH
20861: LD_VAR 0 1
20865: PPUSH
20866: LD_VAR 0 5
20870: PPUSH
20871: CALL_OW 1
20875: ST_TO_ADDR
// end ; if not nearestLab then
20876: LD_VAR 0 5
20880: NOT
20881: IFFALSE 20885
// continue ;
20883: GO 20443
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20885: LD_VAR 0 5
20889: PPUSH
20890: LD_EXP 68
20894: PUSH
20895: LD_VAR 0 1
20899: ARRAY
20900: PUSH
20901: LD_INT 1
20903: ARRAY
20904: PPUSH
20905: LD_EXP 68
20909: PUSH
20910: LD_VAR 0 1
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: ARRAY
20919: PPUSH
20920: CALL_OW 297
20924: PUSH
20925: LD_INT 8
20927: LESS
20928: IFFALSE 21125
// begin if not artifactsResearched [ i ] then
20930: LD_EXP 71
20934: PUSH
20935: LD_VAR 0 1
20939: ARRAY
20940: NOT
20941: IFFALSE 21022
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20943: LD_VAR 0 5
20947: PPUSH
20948: CALL_OW 461
20952: PUSH
20953: LD_INT 2
20955: EQUAL
20956: IFFALSE 20990
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20958: LD_INT 7
20960: PPUSH
20961: LD_EXP 76
20965: PUSH
20966: LD_VAR 0 1
20970: ARRAY
20971: PUSH
20972: LD_INT 3
20974: ARRAY
20975: PPUSH
20976: LD_INT 2
20978: PPUSH
20979: LD_VAR 0 5
20983: PPUSH
20984: CALL_OW 468
20988: GO 21020
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20990: LD_INT 7
20992: PPUSH
20993: LD_EXP 76
20997: PUSH
20998: LD_VAR 0 1
21002: ARRAY
21003: PUSH
21004: LD_INT 3
21006: ARRAY
21007: PPUSH
21008: LD_INT 1
21010: PPUSH
21011: LD_VAR 0 5
21015: PPUSH
21016: CALL_OW 468
// end else
21020: GO 21123
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
21022: LD_VAR 0 5
21026: PPUSH
21027: CALL_OW 461
21031: PUSH
21032: LD_INT 2
21034: EQUAL
21035: PUSH
21036: LD_EXP 77
21040: PUSH
21041: LD_VAR 0 1
21045: ARRAY
21046: AND
21047: IFFALSE 21093
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
21049: LD_INT 7
21051: PPUSH
21052: LD_EXP 76
21056: PUSH
21057: LD_VAR 0 1
21061: ARRAY
21062: PUSH
21063: LD_INT 1
21065: ARRAY
21066: PPUSH
21067: LD_EXP 76
21071: PUSH
21072: LD_VAR 0 1
21076: ARRAY
21077: PUSH
21078: LD_INT 2
21080: ARRAY
21081: PPUSH
21082: LD_VAR 0 5
21086: PPUSH
21087: CALL_OW 468
21091: GO 21123
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
21093: LD_INT 7
21095: PPUSH
21096: LD_EXP 76
21100: PUSH
21101: LD_VAR 0 1
21105: ARRAY
21106: PUSH
21107: LD_INT 1
21109: ARRAY
21110: PPUSH
21111: LD_INT 1
21113: PPUSH
21114: LD_VAR 0 5
21118: PPUSH
21119: CALL_OW 468
// end else
21123: GO 21200
// begin if not artifactsResearched [ i ] then
21125: LD_EXP 71
21129: PUSH
21130: LD_VAR 0 1
21134: ARRAY
21135: NOT
21136: IFFALSE 21170
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
21138: LD_INT 7
21140: PPUSH
21141: LD_EXP 76
21145: PUSH
21146: LD_VAR 0 1
21150: ARRAY
21151: PUSH
21152: LD_INT 3
21154: ARRAY
21155: PPUSH
21156: LD_INT 0
21158: PPUSH
21159: LD_VAR 0 5
21163: PPUSH
21164: CALL_OW 468
21168: GO 21200
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
21170: LD_INT 7
21172: PPUSH
21173: LD_EXP 76
21177: PUSH
21178: LD_VAR 0 1
21182: ARRAY
21183: PUSH
21184: LD_INT 1
21186: ARRAY
21187: PPUSH
21188: LD_INT 0
21190: PPUSH
21191: LD_VAR 0 5
21195: PPUSH
21196: CALL_OW 468
// end ; end else
21200: GO 21339
// begin if not artifactsLabs [ i ] then
21202: LD_EXP 75
21206: PUSH
21207: LD_VAR 0 1
21211: ARRAY
21212: NOT
21213: IFFALSE 21217
// continue ;
21215: GO 20443
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
21217: LD_INT 7
21219: PPUSH
21220: LD_EXP 76
21224: PUSH
21225: LD_VAR 0 1
21229: ARRAY
21230: PUSH
21231: LD_INT 3
21233: ARRAY
21234: PPUSH
21235: LD_INT 0
21237: PPUSH
21238: LD_EXP 75
21242: PUSH
21243: LD_VAR 0 1
21247: ARRAY
21248: PPUSH
21249: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21253: LD_INT 7
21255: PPUSH
21256: LD_EXP 76
21260: PUSH
21261: LD_VAR 0 1
21265: ARRAY
21266: PUSH
21267: LD_INT 1
21269: ARRAY
21270: PPUSH
21271: LD_INT 0
21273: PPUSH
21274: LD_EXP 75
21278: PUSH
21279: LD_VAR 0 1
21283: ARRAY
21284: PPUSH
21285: CALL_OW 468
// if artifactsLabsWorking [ i ] then
21289: LD_EXP 72
21293: PUSH
21294: LD_VAR 0 1
21298: ARRAY
21299: IFFALSE 21339
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
21301: LD_ADDR_EXP 72
21305: PUSH
21306: LD_EXP 72
21310: PPUSH
21311: LD_VAR 0 1
21315: PPUSH
21316: LD_INT 0
21318: PPUSH
21319: CALL_OW 1
21323: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
21324: LD_EXP 75
21328: PUSH
21329: LD_VAR 0 1
21333: ARRAY
21334: PPUSH
21335: CALL_OW 127
// end ; end ; end ;
21339: GO 20443
21341: POP
21342: POP
// end ;
21343: PPOPN 5
21345: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
21346: LD_INT 0
21348: PPUSH
21349: PPUSH
21350: PPUSH
21351: PPUSH
21352: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
21353: LD_VAR 0 2
21357: PUSH
21358: LD_EXP 76
21362: PUSH
21363: LD_INT 1
21365: ARRAY
21366: PUSH
21367: LD_INT 3
21369: ARRAY
21370: EQUAL
21371: IFFALSE 21494
// begin lab := artifactsLabs [ 1 ] ;
21373: LD_ADDR_VAR 0 6
21377: PUSH
21378: LD_EXP 75
21382: PUSH
21383: LD_INT 1
21385: ARRAY
21386: ST_TO_ADDR
// if not lab then
21387: LD_VAR 0 6
21391: NOT
21392: IFFALSE 21396
// exit ;
21394: GO 22474
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
21396: LD_VAR 0 6
21400: PPUSH
21401: LD_EXP 73
21405: PUSH
21406: LD_INT 1
21408: ARRAY
21409: PPUSH
21410: LD_INT 1
21412: PPUSH
21413: CALL_OW 486
// if artifactsResProgress [ 1 ] then
21417: LD_EXP 74
21421: PUSH
21422: LD_INT 1
21424: ARRAY
21425: IFFALSE 21445
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
21427: LD_VAR 0 6
21431: PPUSH
21432: LD_EXP 74
21436: PUSH
21437: LD_INT 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
21445: LD_ADDR_EXP 72
21449: PUSH
21450: LD_EXP 72
21454: PPUSH
21455: LD_INT 1
21457: PPUSH
21458: LD_INT 1
21460: PPUSH
21461: CALL_OW 1
21465: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
21466: LD_INT 7
21468: PPUSH
21469: LD_EXP 76
21473: PUSH
21474: LD_INT 1
21476: ARRAY
21477: PUSH
21478: LD_INT 3
21480: ARRAY
21481: PPUSH
21482: LD_INT 0
21484: PPUSH
21485: LD_VAR 0 6
21489: PPUSH
21490: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
21494: LD_VAR 0 2
21498: PUSH
21499: LD_EXP 76
21503: PUSH
21504: LD_INT 2
21506: ARRAY
21507: PUSH
21508: LD_INT 3
21510: ARRAY
21511: EQUAL
21512: IFFALSE 21635
// begin lab := artifactsLabs [ 2 ] ;
21514: LD_ADDR_VAR 0 6
21518: PUSH
21519: LD_EXP 75
21523: PUSH
21524: LD_INT 2
21526: ARRAY
21527: ST_TO_ADDR
// if not lab then
21528: LD_VAR 0 6
21532: NOT
21533: IFFALSE 21537
// exit ;
21535: GO 22474
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
21537: LD_VAR 0 6
21541: PPUSH
21542: LD_EXP 73
21546: PUSH
21547: LD_INT 2
21549: ARRAY
21550: PPUSH
21551: LD_INT 1
21553: PPUSH
21554: CALL_OW 486
// if artifactsResProgress [ 2 ] then
21558: LD_EXP 74
21562: PUSH
21563: LD_INT 2
21565: ARRAY
21566: IFFALSE 21586
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
21568: LD_VAR 0 6
21572: PPUSH
21573: LD_EXP 74
21577: PUSH
21578: LD_INT 2
21580: ARRAY
21581: PPUSH
21582: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
21586: LD_ADDR_EXP 72
21590: PUSH
21591: LD_EXP 72
21595: PPUSH
21596: LD_INT 2
21598: PPUSH
21599: LD_INT 1
21601: PPUSH
21602: CALL_OW 1
21606: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
21607: LD_INT 7
21609: PPUSH
21610: LD_EXP 76
21614: PUSH
21615: LD_INT 2
21617: ARRAY
21618: PUSH
21619: LD_INT 3
21621: ARRAY
21622: PPUSH
21623: LD_INT 0
21625: PPUSH
21626: LD_VAR 0 6
21630: PPUSH
21631: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
21635: LD_VAR 0 2
21639: PUSH
21640: LD_EXP 76
21644: PUSH
21645: LD_INT 3
21647: ARRAY
21648: PUSH
21649: LD_INT 3
21651: ARRAY
21652: EQUAL
21653: IFFALSE 21776
// begin lab := artifactsLabs [ 3 ] ;
21655: LD_ADDR_VAR 0 6
21659: PUSH
21660: LD_EXP 75
21664: PUSH
21665: LD_INT 3
21667: ARRAY
21668: ST_TO_ADDR
// if not lab then
21669: LD_VAR 0 6
21673: NOT
21674: IFFALSE 21678
// exit ;
21676: GO 22474
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
21678: LD_VAR 0 6
21682: PPUSH
21683: LD_EXP 73
21687: PUSH
21688: LD_INT 3
21690: ARRAY
21691: PPUSH
21692: LD_INT 1
21694: PPUSH
21695: CALL_OW 486
// if artifactsResProgress [ 3 ] then
21699: LD_EXP 74
21703: PUSH
21704: LD_INT 3
21706: ARRAY
21707: IFFALSE 21727
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
21709: LD_VAR 0 6
21713: PPUSH
21714: LD_EXP 74
21718: PUSH
21719: LD_INT 3
21721: ARRAY
21722: PPUSH
21723: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21727: LD_ADDR_EXP 72
21731: PUSH
21732: LD_EXP 72
21736: PPUSH
21737: LD_INT 3
21739: PPUSH
21740: LD_INT 1
21742: PPUSH
21743: CALL_OW 1
21747: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21748: LD_INT 7
21750: PPUSH
21751: LD_EXP 76
21755: PUSH
21756: LD_INT 3
21758: ARRAY
21759: PUSH
21760: LD_INT 3
21762: ARRAY
21763: PPUSH
21764: LD_INT 0
21766: PPUSH
21767: LD_VAR 0 6
21771: PPUSH
21772: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21776: LD_VAR 0 2
21780: PUSH
21781: LD_EXP 76
21785: PUSH
21786: LD_INT 1
21788: ARRAY
21789: PUSH
21790: LD_INT 1
21792: ARRAY
21793: EQUAL
21794: IFFALSE 21952
// begin lab := artifactsLabs [ 1 ] ;
21796: LD_ADDR_VAR 0 6
21800: PUSH
21801: LD_EXP 75
21805: PUSH
21806: LD_INT 1
21808: ARRAY
21809: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21810: LD_VAR 0 6
21814: PPUSH
21815: CALL_OW 274
21819: PPUSH
21820: CALL 91539 0 1
21824: PUSH
21825: LD_INT 3
21827: ARRAY
21828: PUSH
21829: LD_EXP 70
21833: PUSH
21834: LD_INT 1
21836: ARRAY
21837: LESS
21838: IFFALSE 21852
// begin HintSpec ( ArtifactCost , 2 ) ;
21840: LD_STRING ArtifactCost
21842: PPUSH
21843: LD_INT 2
21845: PPUSH
21846: CALL_OW 338
// exit ;
21850: GO 22474
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21852: LD_ADDR_EXP 77
21856: PUSH
21857: LD_EXP 77
21861: PPUSH
21862: LD_INT 1
21864: PPUSH
21865: LD_INT 0
21867: PPUSH
21868: CALL_OW 1
21872: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21873: LD_VAR 0 3
21877: PPUSH
21878: LD_VAR 0 4
21882: PPUSH
21883: LD_INT 7
21885: PPUSH
21886: LD_INT 12
21888: NEG
21889: PPUSH
21890: CALL_OW 330
// wait ( 0 0$30 ) ;
21894: LD_INT 1050
21896: PPUSH
21897: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21901: LD_VAR 0 3
21905: PPUSH
21906: LD_VAR 0 4
21910: PPUSH
21911: LD_INT 7
21913: PPUSH
21914: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21918: LD_EXP 69
21922: PUSH
21923: LD_INT 1
21925: ARRAY
21926: PPUSH
21927: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21931: LD_ADDR_EXP 77
21935: PUSH
21936: LD_EXP 77
21940: PPUSH
21941: LD_INT 1
21943: PPUSH
21944: LD_INT 1
21946: PPUSH
21947: CALL_OW 1
21951: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21952: LD_VAR 0 2
21956: PUSH
21957: LD_EXP 76
21961: PUSH
21962: LD_INT 2
21964: ARRAY
21965: PUSH
21966: LD_INT 1
21968: ARRAY
21969: EQUAL
21970: IFFALSE 22207
// begin lab := artifactsLabs [ 2 ] ;
21972: LD_ADDR_VAR 0 6
21976: PUSH
21977: LD_EXP 75
21981: PUSH
21982: LD_INT 2
21984: ARRAY
21985: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21986: LD_VAR 0 3
21990: PUSH
21991: LD_INT 81
21993: PUSH
21994: LD_INT 7
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 2
22003: PUSH
22004: LD_INT 32
22006: PUSH
22007: LD_INT 3
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: PUSH
22014: LD_INT 30
22016: PUSH
22017: LD_INT 28
22019: PUSH
22020: EMPTY
22021: LIST
22022: LIST
22023: PUSH
22024: LD_INT 30
22026: PUSH
22027: LD_INT 30
22029: PUSH
22030: EMPTY
22031: LIST
22032: LIST
22033: PUSH
22034: LD_INT 35
22036: PUSH
22037: LD_INT 49
22039: PUSH
22040: EMPTY
22041: LIST
22042: LIST
22043: PUSH
22044: LD_INT 34
22046: PUSH
22047: LD_INT 49
22049: PUSH
22050: EMPTY
22051: LIST
22052: LIST
22053: PUSH
22054: LD_INT 30
22056: PUSH
22057: LD_INT 21
22059: PUSH
22060: EMPTY
22061: LIST
22062: LIST
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: LIST
22068: LIST
22069: LIST
22070: LIST
22071: LIST
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PPUSH
22077: CALL_OW 69
22081: IN
22082: NOT
22083: IFFALSE 22087
// exit ;
22085: GO 22474
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
22087: LD_VAR 0 6
22091: PPUSH
22092: CALL_OW 274
22096: PPUSH
22097: CALL 91539 0 1
22101: PUSH
22102: LD_INT 3
22104: ARRAY
22105: PUSH
22106: LD_EXP 70
22110: PUSH
22111: LD_INT 2
22113: ARRAY
22114: LESS
22115: IFFALSE 22129
// begin HintSpec ( ArtifactCost , 2 ) ;
22117: LD_STRING ArtifactCost
22119: PPUSH
22120: LD_INT 2
22122: PPUSH
22123: CALL_OW 338
// exit ;
22127: GO 22474
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
22129: LD_ADDR_EXP 77
22133: PUSH
22134: LD_EXP 77
22138: PPUSH
22139: LD_INT 2
22141: PPUSH
22142: LD_INT 0
22144: PPUSH
22145: CALL_OW 1
22149: ST_TO_ADDR
// KillUnit ( x ) ;
22150: LD_VAR 0 3
22154: PPUSH
22155: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
22159: LD_ADDR_EXP 16
22163: PUSH
22164: LD_EXP 16
22168: PUSH
22169: LD_INT 1
22171: PLUS
22172: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
22173: LD_EXP 69
22177: PUSH
22178: LD_INT 2
22180: ARRAY
22181: PPUSH
22182: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
22186: LD_ADDR_EXP 77
22190: PUSH
22191: LD_EXP 77
22195: PPUSH
22196: LD_INT 2
22198: PPUSH
22199: LD_INT 1
22201: PPUSH
22202: CALL_OW 1
22206: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
22207: LD_VAR 0 2
22211: PUSH
22212: LD_EXP 76
22216: PUSH
22217: LD_INT 3
22219: ARRAY
22220: PUSH
22221: LD_INT 1
22223: ARRAY
22224: EQUAL
22225: IFFALSE 22474
// begin lab := artifactsLabs [ 3 ] ;
22227: LD_ADDR_VAR 0 6
22231: PUSH
22232: LD_EXP 75
22236: PUSH
22237: LD_INT 3
22239: ARRAY
22240: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
22241: LD_VAR 0 6
22245: PPUSH
22246: CALL_OW 274
22250: PPUSH
22251: CALL 91539 0 1
22255: PUSH
22256: LD_INT 3
22258: ARRAY
22259: PUSH
22260: LD_EXP 70
22264: PUSH
22265: LD_INT 3
22267: ARRAY
22268: LESS
22269: IFFALSE 22283
// begin HintSpec ( ArtifactCost , 2 ) ;
22271: LD_STRING ArtifactCost
22273: PPUSH
22274: LD_INT 2
22276: PPUSH
22277: CALL_OW 338
// exit ;
22281: GO 22474
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
22283: LD_INT 37
22285: PPUSH
22286: LD_INT 1
22288: PPUSH
22289: CALL_OW 424
// time := 0 0$30 ;
22293: LD_ADDR_VAR 0 7
22297: PUSH
22298: LD_INT 1050
22300: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
22301: LD_ADDR_EXP 77
22305: PUSH
22306: LD_EXP 77
22310: PPUSH
22311: LD_INT 3
22313: PPUSH
22314: LD_INT 0
22316: PPUSH
22317: CALL_OW 1
22321: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
22322: LD_ADDR_OWVAR 47
22326: PUSH
22327: LD_STRING #Am15a-1
22329: PUSH
22330: LD_VAR 0 7
22334: PUSH
22335: EMPTY
22336: LIST
22337: LIST
22338: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22339: LD_INT 35
22341: PPUSH
22342: CALL_OW 67
// time := time - 0 0$1 ;
22346: LD_ADDR_VAR 0 7
22350: PUSH
22351: LD_VAR 0 7
22355: PUSH
22356: LD_INT 35
22358: MINUS
22359: ST_TO_ADDR
// until time = 0 0$00 ;
22360: LD_VAR 0 7
22364: PUSH
22365: LD_INT 0
22367: EQUAL
22368: IFFALSE 22322
// display_strings :=  ;
22370: LD_ADDR_OWVAR 47
22374: PUSH
22375: LD_STRING 
22377: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
22378: LD_INT 37
22380: PPUSH
22381: LD_INT 0
22383: PPUSH
22384: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
22388: LD_ADDR_VAR 0 8
22392: PUSH
22393: LD_INT 37
22395: PPUSH
22396: LD_INT 3
22398: PUSH
22399: LD_INT 21
22401: PUSH
22402: LD_INT 3
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PPUSH
22413: CALL_OW 70
22417: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
22418: LD_VAR 0 3
22422: PPUSH
22423: LD_VAR 0 4
22427: PPUSH
22428: CALL_OW 84
// for un in list do
22432: LD_ADDR_VAR 0 9
22436: PUSH
22437: LD_VAR 0 8
22441: PUSH
22442: FOR_IN
22443: IFFALSE 22472
// TeleportUnit ( un , x , y , 12 , true ) ;
22445: LD_VAR 0 9
22449: PPUSH
22450: LD_VAR 0 3
22454: PPUSH
22455: LD_VAR 0 4
22459: PPUSH
22460: LD_INT 12
22462: PPUSH
22463: LD_INT 1
22465: PPUSH
22466: CALL_OW 483
22470: GO 22442
22472: POP
22473: POP
// end ; end ;
22474: PPOPN 9
22476: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
22477: LD_INT 0
22479: PPUSH
22480: PPUSH
// begin labNum := 0 ;
22481: LD_ADDR_VAR 0 4
22485: PUSH
22486: LD_INT 0
22488: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22489: LD_ADDR_VAR 0 3
22493: PUSH
22494: DOUBLE
22495: LD_INT 1
22497: DEC
22498: ST_TO_ADDR
22499: LD_EXP 75
22503: PUSH
22504: FOR_TO
22505: IFFALSE 22539
// if artifactsLabs [ i ] = lab then
22507: LD_EXP 75
22511: PUSH
22512: LD_VAR 0 3
22516: ARRAY
22517: PUSH
22518: LD_VAR 0 1
22522: EQUAL
22523: IFFALSE 22537
// begin labNum := i ;
22525: LD_ADDR_VAR 0 4
22529: PUSH
22530: LD_VAR 0 3
22534: ST_TO_ADDR
// break ;
22535: GO 22539
// end ;
22537: GO 22504
22539: POP
22540: POP
// if not labNum then
22541: LD_VAR 0 4
22545: NOT
22546: IFFALSE 22550
// exit ;
22548: GO 22628
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
22550: LD_INT 7
22552: PPUSH
22553: LD_EXP 76
22557: PUSH
22558: LD_VAR 0 4
22562: ARRAY
22563: PUSH
22564: LD_INT 3
22566: ARRAY
22567: PPUSH
22568: LD_INT 2
22570: PPUSH
22571: LD_VAR 0 1
22575: PPUSH
22576: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
22580: LD_ADDR_EXP 74
22584: PUSH
22585: LD_EXP 74
22589: PPUSH
22590: LD_VAR 0 4
22594: PPUSH
22595: LD_VAR 0 2
22599: PPUSH
22600: CALL_OW 1
22604: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
22605: LD_ADDR_EXP 72
22609: PUSH
22610: LD_EXP 72
22614: PPUSH
22615: LD_VAR 0 4
22619: PPUSH
22620: LD_INT 0
22622: PPUSH
22623: CALL_OW 1
22627: ST_TO_ADDR
// end ;
22628: PPOPN 4
22630: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
22631: LD_INT 0
22633: PPUSH
22634: PPUSH
// begin labNum := 0 ;
22635: LD_ADDR_VAR 0 3
22639: PUSH
22640: LD_INT 0
22642: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22643: LD_ADDR_VAR 0 2
22647: PUSH
22648: DOUBLE
22649: LD_INT 1
22651: DEC
22652: ST_TO_ADDR
22653: LD_EXP 75
22657: PUSH
22658: FOR_TO
22659: IFFALSE 22693
// if artifactsLabs [ i ] = lab then
22661: LD_EXP 75
22665: PUSH
22666: LD_VAR 0 2
22670: ARRAY
22671: PUSH
22672: LD_VAR 0 1
22676: EQUAL
22677: IFFALSE 22691
// begin labNum := i ;
22679: LD_ADDR_VAR 0 3
22683: PUSH
22684: LD_VAR 0 2
22688: ST_TO_ADDR
// break ;
22689: GO 22693
// end ;
22691: GO 22658
22693: POP
22694: POP
// if not labNum then
22695: LD_VAR 0 3
22699: NOT
22700: IFFALSE 22704
// exit ;
22702: GO 22866
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
22704: LD_INT 7
22706: PPUSH
22707: LD_EXP 76
22711: PUSH
22712: LD_VAR 0 3
22716: ARRAY
22717: PUSH
22718: LD_INT 3
22720: ARRAY
22721: PPUSH
22722: LD_INT 0
22724: PPUSH
22725: LD_VAR 0 1
22729: PPUSH
22730: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22734: LD_ADDR_EXP 71
22738: PUSH
22739: LD_EXP 71
22743: PPUSH
22744: LD_VAR 0 3
22748: PPUSH
22749: LD_INT 1
22751: PPUSH
22752: CALL_OW 1
22756: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22757: LD_ADDR_EXP 77
22761: PUSH
22762: LD_EXP 77
22766: PPUSH
22767: LD_VAR 0 3
22771: PPUSH
22772: LD_INT 1
22774: PPUSH
22775: CALL_OW 1
22779: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22780: LD_ADDR_EXP 72
22784: PUSH
22785: LD_EXP 72
22789: PPUSH
22790: LD_VAR 0 3
22794: PPUSH
22795: LD_INT 0
22797: PPUSH
22798: CALL_OW 1
22802: ST_TO_ADDR
// case labNum of 1 :
22803: LD_VAR 0 3
22807: PUSH
22808: LD_INT 1
22810: DOUBLE
22811: EQUAL
22812: IFTRUE 22816
22814: GO 22827
22816: POP
// artifactIResearched := true ; 2 :
22817: LD_ADDR_EXP 12
22821: PUSH
22822: LD_INT 1
22824: ST_TO_ADDR
22825: GO 22866
22827: LD_INT 2
22829: DOUBLE
22830: EQUAL
22831: IFTRUE 22835
22833: GO 22846
22835: POP
// artifactIIResearched := true ; 3 :
22836: LD_ADDR_EXP 13
22840: PUSH
22841: LD_INT 1
22843: ST_TO_ADDR
22844: GO 22866
22846: LD_INT 3
22848: DOUBLE
22849: EQUAL
22850: IFTRUE 22854
22852: GO 22865
22854: POP
// artifactIIIResearched := true ; end ;
22855: LD_ADDR_EXP 14
22859: PUSH
22860: LD_INT 1
22862: ST_TO_ADDR
22863: GO 22866
22865: POP
// end ; end_of_file
22866: PPOPN 3
22868: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22869: LD_INT 0
22871: PPUSH
22872: PPUSH
// skirmish := false ;
22873: LD_ADDR_EXP 78
22877: PUSH
22878: LD_INT 0
22880: ST_TO_ADDR
// debug_mc := false ;
22881: LD_ADDR_EXP 79
22885: PUSH
22886: LD_INT 0
22888: ST_TO_ADDR
// mc_bases := [ ] ;
22889: LD_ADDR_EXP 80
22893: PUSH
22894: EMPTY
22895: ST_TO_ADDR
// mc_sides := [ ] ;
22896: LD_ADDR_EXP 106
22900: PUSH
22901: EMPTY
22902: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22903: LD_ADDR_EXP 81
22907: PUSH
22908: EMPTY
22909: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22910: LD_ADDR_EXP 82
22914: PUSH
22915: EMPTY
22916: ST_TO_ADDR
// mc_need_heal := [ ] ;
22917: LD_ADDR_EXP 83
22921: PUSH
22922: EMPTY
22923: ST_TO_ADDR
// mc_healers := [ ] ;
22924: LD_ADDR_EXP 84
22928: PUSH
22929: EMPTY
22930: ST_TO_ADDR
// mc_build_list := [ ] ;
22931: LD_ADDR_EXP 85
22935: PUSH
22936: EMPTY
22937: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22938: LD_ADDR_EXP 112
22942: PUSH
22943: EMPTY
22944: ST_TO_ADDR
// mc_builders := [ ] ;
22945: LD_ADDR_EXP 86
22949: PUSH
22950: EMPTY
22951: ST_TO_ADDR
// mc_construct_list := [ ] ;
22952: LD_ADDR_EXP 87
22956: PUSH
22957: EMPTY
22958: ST_TO_ADDR
// mc_turret_list := [ ] ;
22959: LD_ADDR_EXP 88
22963: PUSH
22964: EMPTY
22965: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22966: LD_ADDR_EXP 89
22970: PUSH
22971: EMPTY
22972: ST_TO_ADDR
// mc_miners := [ ] ;
22973: LD_ADDR_EXP 94
22977: PUSH
22978: EMPTY
22979: ST_TO_ADDR
// mc_mines := [ ] ;
22980: LD_ADDR_EXP 93
22984: PUSH
22985: EMPTY
22986: ST_TO_ADDR
// mc_minefields := [ ] ;
22987: LD_ADDR_EXP 95
22991: PUSH
22992: EMPTY
22993: ST_TO_ADDR
// mc_crates := [ ] ;
22994: LD_ADDR_EXP 96
22998: PUSH
22999: EMPTY
23000: ST_TO_ADDR
// mc_crates_collector := [ ] ;
23001: LD_ADDR_EXP 97
23005: PUSH
23006: EMPTY
23007: ST_TO_ADDR
// mc_crates_area := [ ] ;
23008: LD_ADDR_EXP 98
23012: PUSH
23013: EMPTY
23014: ST_TO_ADDR
// mc_vehicles := [ ] ;
23015: LD_ADDR_EXP 99
23019: PUSH
23020: EMPTY
23021: ST_TO_ADDR
// mc_attack := [ ] ;
23022: LD_ADDR_EXP 100
23026: PUSH
23027: EMPTY
23028: ST_TO_ADDR
// mc_produce := [ ] ;
23029: LD_ADDR_EXP 101
23033: PUSH
23034: EMPTY
23035: ST_TO_ADDR
// mc_defender := [ ] ;
23036: LD_ADDR_EXP 102
23040: PUSH
23041: EMPTY
23042: ST_TO_ADDR
// mc_parking := [ ] ;
23043: LD_ADDR_EXP 104
23047: PUSH
23048: EMPTY
23049: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
23050: LD_ADDR_EXP 90
23054: PUSH
23055: EMPTY
23056: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
23057: LD_ADDR_EXP 92
23061: PUSH
23062: EMPTY
23063: ST_TO_ADDR
// mc_scan := [ ] ;
23064: LD_ADDR_EXP 103
23068: PUSH
23069: EMPTY
23070: ST_TO_ADDR
// mc_scan_area := [ ] ;
23071: LD_ADDR_EXP 105
23075: PUSH
23076: EMPTY
23077: ST_TO_ADDR
// mc_tech := [ ] ;
23078: LD_ADDR_EXP 107
23082: PUSH
23083: EMPTY
23084: ST_TO_ADDR
// mc_class := [ ] ;
23085: LD_ADDR_EXP 121
23089: PUSH
23090: EMPTY
23091: ST_TO_ADDR
// mc_class_case_use := [ ] ;
23092: LD_ADDR_EXP 122
23096: PUSH
23097: EMPTY
23098: ST_TO_ADDR
// mc_is_defending := [ ] ;
23099: LD_ADDR_EXP 123
23103: PUSH
23104: EMPTY
23105: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
23106: LD_ADDR_EXP 114
23110: PUSH
23111: EMPTY
23112: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
23113: LD_ADDR_EXP 124
23117: PUSH
23118: LD_INT 0
23120: ST_TO_ADDR
// end ;
23121: LD_VAR 0 1
23125: RET
// export function MC_Kill ( base ) ; begin
23126: LD_INT 0
23128: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
23129: LD_ADDR_EXP 80
23133: PUSH
23134: LD_EXP 80
23138: PPUSH
23139: LD_VAR 0 1
23143: PPUSH
23144: EMPTY
23145: PPUSH
23146: CALL_OW 1
23150: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23151: LD_ADDR_EXP 81
23155: PUSH
23156: LD_EXP 81
23160: PPUSH
23161: LD_VAR 0 1
23165: PPUSH
23166: EMPTY
23167: PPUSH
23168: CALL_OW 1
23172: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23173: LD_ADDR_EXP 82
23177: PUSH
23178: LD_EXP 82
23182: PPUSH
23183: LD_VAR 0 1
23187: PPUSH
23188: EMPTY
23189: PPUSH
23190: CALL_OW 1
23194: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23195: LD_ADDR_EXP 83
23199: PUSH
23200: LD_EXP 83
23204: PPUSH
23205: LD_VAR 0 1
23209: PPUSH
23210: EMPTY
23211: PPUSH
23212: CALL_OW 1
23216: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23217: LD_ADDR_EXP 84
23221: PUSH
23222: LD_EXP 84
23226: PPUSH
23227: LD_VAR 0 1
23231: PPUSH
23232: EMPTY
23233: PPUSH
23234: CALL_OW 1
23238: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23239: LD_ADDR_EXP 85
23243: PUSH
23244: LD_EXP 85
23248: PPUSH
23249: LD_VAR 0 1
23253: PPUSH
23254: EMPTY
23255: PPUSH
23256: CALL_OW 1
23260: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23261: LD_ADDR_EXP 86
23265: PUSH
23266: LD_EXP 86
23270: PPUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: EMPTY
23277: PPUSH
23278: CALL_OW 1
23282: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23283: LD_ADDR_EXP 87
23287: PUSH
23288: LD_EXP 87
23292: PPUSH
23293: LD_VAR 0 1
23297: PPUSH
23298: EMPTY
23299: PPUSH
23300: CALL_OW 1
23304: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23305: LD_ADDR_EXP 88
23309: PUSH
23310: LD_EXP 88
23314: PPUSH
23315: LD_VAR 0 1
23319: PPUSH
23320: EMPTY
23321: PPUSH
23322: CALL_OW 1
23326: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23327: LD_ADDR_EXP 89
23331: PUSH
23332: LD_EXP 89
23336: PPUSH
23337: LD_VAR 0 1
23341: PPUSH
23342: EMPTY
23343: PPUSH
23344: CALL_OW 1
23348: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23349: LD_ADDR_EXP 90
23353: PUSH
23354: LD_EXP 90
23358: PPUSH
23359: LD_VAR 0 1
23363: PPUSH
23364: EMPTY
23365: PPUSH
23366: CALL_OW 1
23370: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23371: LD_ADDR_EXP 91
23375: PUSH
23376: LD_EXP 91
23380: PPUSH
23381: LD_VAR 0 1
23385: PPUSH
23386: LD_INT 0
23388: PPUSH
23389: CALL_OW 1
23393: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23394: LD_ADDR_EXP 92
23398: PUSH
23399: LD_EXP 92
23403: PPUSH
23404: LD_VAR 0 1
23408: PPUSH
23409: EMPTY
23410: PPUSH
23411: CALL_OW 1
23415: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23416: LD_ADDR_EXP 93
23420: PUSH
23421: LD_EXP 93
23425: PPUSH
23426: LD_VAR 0 1
23430: PPUSH
23431: EMPTY
23432: PPUSH
23433: CALL_OW 1
23437: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23438: LD_ADDR_EXP 94
23442: PUSH
23443: LD_EXP 94
23447: PPUSH
23448: LD_VAR 0 1
23452: PPUSH
23453: EMPTY
23454: PPUSH
23455: CALL_OW 1
23459: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23460: LD_ADDR_EXP 95
23464: PUSH
23465: LD_EXP 95
23469: PPUSH
23470: LD_VAR 0 1
23474: PPUSH
23475: EMPTY
23476: PPUSH
23477: CALL_OW 1
23481: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23482: LD_ADDR_EXP 96
23486: PUSH
23487: LD_EXP 96
23491: PPUSH
23492: LD_VAR 0 1
23496: PPUSH
23497: EMPTY
23498: PPUSH
23499: CALL_OW 1
23503: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23504: LD_ADDR_EXP 97
23508: PUSH
23509: LD_EXP 97
23513: PPUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: EMPTY
23520: PPUSH
23521: CALL_OW 1
23525: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23526: LD_ADDR_EXP 98
23530: PUSH
23531: LD_EXP 98
23535: PPUSH
23536: LD_VAR 0 1
23540: PPUSH
23541: EMPTY
23542: PPUSH
23543: CALL_OW 1
23547: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23548: LD_ADDR_EXP 99
23552: PUSH
23553: LD_EXP 99
23557: PPUSH
23558: LD_VAR 0 1
23562: PPUSH
23563: EMPTY
23564: PPUSH
23565: CALL_OW 1
23569: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23570: LD_ADDR_EXP 100
23574: PUSH
23575: LD_EXP 100
23579: PPUSH
23580: LD_VAR 0 1
23584: PPUSH
23585: EMPTY
23586: PPUSH
23587: CALL_OW 1
23591: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23592: LD_ADDR_EXP 101
23596: PUSH
23597: LD_EXP 101
23601: PPUSH
23602: LD_VAR 0 1
23606: PPUSH
23607: EMPTY
23608: PPUSH
23609: CALL_OW 1
23613: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23614: LD_ADDR_EXP 102
23618: PUSH
23619: LD_EXP 102
23623: PPUSH
23624: LD_VAR 0 1
23628: PPUSH
23629: EMPTY
23630: PPUSH
23631: CALL_OW 1
23635: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23636: LD_ADDR_EXP 103
23640: PUSH
23641: LD_EXP 103
23645: PPUSH
23646: LD_VAR 0 1
23650: PPUSH
23651: EMPTY
23652: PPUSH
23653: CALL_OW 1
23657: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23658: LD_ADDR_EXP 104
23662: PUSH
23663: LD_EXP 104
23667: PPUSH
23668: LD_VAR 0 1
23672: PPUSH
23673: EMPTY
23674: PPUSH
23675: CALL_OW 1
23679: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23680: LD_ADDR_EXP 105
23684: PUSH
23685: LD_EXP 105
23689: PPUSH
23690: LD_VAR 0 1
23694: PPUSH
23695: EMPTY
23696: PPUSH
23697: CALL_OW 1
23701: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23702: LD_ADDR_EXP 107
23706: PUSH
23707: LD_EXP 107
23711: PPUSH
23712: LD_VAR 0 1
23716: PPUSH
23717: EMPTY
23718: PPUSH
23719: CALL_OW 1
23723: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23724: LD_ADDR_EXP 109
23728: PUSH
23729: LD_EXP 109
23733: PPUSH
23734: LD_VAR 0 1
23738: PPUSH
23739: EMPTY
23740: PPUSH
23741: CALL_OW 1
23745: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23746: LD_ADDR_EXP 110
23750: PUSH
23751: LD_EXP 110
23755: PPUSH
23756: LD_VAR 0 1
23760: PPUSH
23761: EMPTY
23762: PPUSH
23763: CALL_OW 1
23767: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23768: LD_ADDR_EXP 111
23772: PUSH
23773: LD_EXP 111
23777: PPUSH
23778: LD_VAR 0 1
23782: PPUSH
23783: EMPTY
23784: PPUSH
23785: CALL_OW 1
23789: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23790: LD_ADDR_EXP 112
23794: PUSH
23795: LD_EXP 112
23799: PPUSH
23800: LD_VAR 0 1
23804: PPUSH
23805: EMPTY
23806: PPUSH
23807: CALL_OW 1
23811: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23812: LD_ADDR_EXP 113
23816: PUSH
23817: LD_EXP 113
23821: PPUSH
23822: LD_VAR 0 1
23826: PPUSH
23827: EMPTY
23828: PPUSH
23829: CALL_OW 1
23833: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23834: LD_ADDR_EXP 114
23838: PUSH
23839: LD_EXP 114
23843: PPUSH
23844: LD_VAR 0 1
23848: PPUSH
23849: EMPTY
23850: PPUSH
23851: CALL_OW 1
23855: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23856: LD_ADDR_EXP 115
23860: PUSH
23861: LD_EXP 115
23865: PPUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: EMPTY
23872: PPUSH
23873: CALL_OW 1
23877: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23878: LD_ADDR_EXP 116
23882: PUSH
23883: LD_EXP 116
23887: PPUSH
23888: LD_VAR 0 1
23892: PPUSH
23893: EMPTY
23894: PPUSH
23895: CALL_OW 1
23899: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23900: LD_ADDR_EXP 117
23904: PUSH
23905: LD_EXP 117
23909: PPUSH
23910: LD_VAR 0 1
23914: PPUSH
23915: EMPTY
23916: PPUSH
23917: CALL_OW 1
23921: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23922: LD_ADDR_EXP 118
23926: PUSH
23927: LD_EXP 118
23931: PPUSH
23932: LD_VAR 0 1
23936: PPUSH
23937: EMPTY
23938: PPUSH
23939: CALL_OW 1
23943: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23944: LD_ADDR_EXP 119
23948: PUSH
23949: LD_EXP 119
23953: PPUSH
23954: LD_VAR 0 1
23958: PPUSH
23959: EMPTY
23960: PPUSH
23961: CALL_OW 1
23965: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23966: LD_ADDR_EXP 120
23970: PUSH
23971: LD_EXP 120
23975: PPUSH
23976: LD_VAR 0 1
23980: PPUSH
23981: EMPTY
23982: PPUSH
23983: CALL_OW 1
23987: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23988: LD_ADDR_EXP 121
23992: PUSH
23993: LD_EXP 121
23997: PPUSH
23998: LD_VAR 0 1
24002: PPUSH
24003: EMPTY
24004: PPUSH
24005: CALL_OW 1
24009: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24010: LD_ADDR_EXP 122
24014: PUSH
24015: LD_EXP 122
24019: PPUSH
24020: LD_VAR 0 1
24024: PPUSH
24025: LD_INT 0
24027: PPUSH
24028: CALL_OW 1
24032: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24033: LD_ADDR_EXP 123
24037: PUSH
24038: LD_EXP 123
24042: PPUSH
24043: LD_VAR 0 1
24047: PPUSH
24048: LD_INT 0
24050: PPUSH
24051: CALL_OW 1
24055: ST_TO_ADDR
// end ;
24056: LD_VAR 0 2
24060: RET
// export function MC_Add ( side , units ) ; var base ; begin
24061: LD_INT 0
24063: PPUSH
24064: PPUSH
// base := mc_bases + 1 ;
24065: LD_ADDR_VAR 0 4
24069: PUSH
24070: LD_EXP 80
24074: PUSH
24075: LD_INT 1
24077: PLUS
24078: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
24079: LD_ADDR_EXP 106
24083: PUSH
24084: LD_EXP 106
24088: PPUSH
24089: LD_VAR 0 4
24093: PPUSH
24094: LD_VAR 0 1
24098: PPUSH
24099: CALL_OW 1
24103: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
24104: LD_ADDR_EXP 80
24108: PUSH
24109: LD_EXP 80
24113: PPUSH
24114: LD_VAR 0 4
24118: PPUSH
24119: LD_VAR 0 2
24123: PPUSH
24124: CALL_OW 1
24128: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
24129: LD_ADDR_EXP 81
24133: PUSH
24134: LD_EXP 81
24138: PPUSH
24139: LD_VAR 0 4
24143: PPUSH
24144: EMPTY
24145: PPUSH
24146: CALL_OW 1
24150: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
24151: LD_ADDR_EXP 82
24155: PUSH
24156: LD_EXP 82
24160: PPUSH
24161: LD_VAR 0 4
24165: PPUSH
24166: EMPTY
24167: PPUSH
24168: CALL_OW 1
24172: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
24173: LD_ADDR_EXP 83
24177: PUSH
24178: LD_EXP 83
24182: PPUSH
24183: LD_VAR 0 4
24187: PPUSH
24188: EMPTY
24189: PPUSH
24190: CALL_OW 1
24194: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
24195: LD_ADDR_EXP 84
24199: PUSH
24200: LD_EXP 84
24204: PPUSH
24205: LD_VAR 0 4
24209: PPUSH
24210: EMPTY
24211: PPUSH
24212: CALL_OW 1
24216: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
24217: LD_ADDR_EXP 85
24221: PUSH
24222: LD_EXP 85
24226: PPUSH
24227: LD_VAR 0 4
24231: PPUSH
24232: EMPTY
24233: PPUSH
24234: CALL_OW 1
24238: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
24239: LD_ADDR_EXP 86
24243: PUSH
24244: LD_EXP 86
24248: PPUSH
24249: LD_VAR 0 4
24253: PPUSH
24254: EMPTY
24255: PPUSH
24256: CALL_OW 1
24260: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
24261: LD_ADDR_EXP 87
24265: PUSH
24266: LD_EXP 87
24270: PPUSH
24271: LD_VAR 0 4
24275: PPUSH
24276: EMPTY
24277: PPUSH
24278: CALL_OW 1
24282: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
24283: LD_ADDR_EXP 88
24287: PUSH
24288: LD_EXP 88
24292: PPUSH
24293: LD_VAR 0 4
24297: PPUSH
24298: EMPTY
24299: PPUSH
24300: CALL_OW 1
24304: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
24305: LD_ADDR_EXP 89
24309: PUSH
24310: LD_EXP 89
24314: PPUSH
24315: LD_VAR 0 4
24319: PPUSH
24320: EMPTY
24321: PPUSH
24322: CALL_OW 1
24326: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
24327: LD_ADDR_EXP 90
24331: PUSH
24332: LD_EXP 90
24336: PPUSH
24337: LD_VAR 0 4
24341: PPUSH
24342: EMPTY
24343: PPUSH
24344: CALL_OW 1
24348: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
24349: LD_ADDR_EXP 91
24353: PUSH
24354: LD_EXP 91
24358: PPUSH
24359: LD_VAR 0 4
24363: PPUSH
24364: LD_INT 0
24366: PPUSH
24367: CALL_OW 1
24371: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
24372: LD_ADDR_EXP 92
24376: PUSH
24377: LD_EXP 92
24381: PPUSH
24382: LD_VAR 0 4
24386: PPUSH
24387: EMPTY
24388: PPUSH
24389: CALL_OW 1
24393: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
24394: LD_ADDR_EXP 93
24398: PUSH
24399: LD_EXP 93
24403: PPUSH
24404: LD_VAR 0 4
24408: PPUSH
24409: EMPTY
24410: PPUSH
24411: CALL_OW 1
24415: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
24416: LD_ADDR_EXP 94
24420: PUSH
24421: LD_EXP 94
24425: PPUSH
24426: LD_VAR 0 4
24430: PPUSH
24431: EMPTY
24432: PPUSH
24433: CALL_OW 1
24437: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24438: LD_ADDR_EXP 95
24442: PUSH
24443: LD_EXP 95
24447: PPUSH
24448: LD_VAR 0 4
24452: PPUSH
24453: EMPTY
24454: PPUSH
24455: CALL_OW 1
24459: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
24460: LD_ADDR_EXP 96
24464: PUSH
24465: LD_EXP 96
24469: PPUSH
24470: LD_VAR 0 4
24474: PPUSH
24475: EMPTY
24476: PPUSH
24477: CALL_OW 1
24481: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
24482: LD_ADDR_EXP 97
24486: PUSH
24487: LD_EXP 97
24491: PPUSH
24492: LD_VAR 0 4
24496: PPUSH
24497: EMPTY
24498: PPUSH
24499: CALL_OW 1
24503: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24504: LD_ADDR_EXP 98
24508: PUSH
24509: LD_EXP 98
24513: PPUSH
24514: LD_VAR 0 4
24518: PPUSH
24519: EMPTY
24520: PPUSH
24521: CALL_OW 1
24525: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
24526: LD_ADDR_EXP 99
24530: PUSH
24531: LD_EXP 99
24535: PPUSH
24536: LD_VAR 0 4
24540: PPUSH
24541: EMPTY
24542: PPUSH
24543: CALL_OW 1
24547: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
24548: LD_ADDR_EXP 100
24552: PUSH
24553: LD_EXP 100
24557: PPUSH
24558: LD_VAR 0 4
24562: PPUSH
24563: EMPTY
24564: PPUSH
24565: CALL_OW 1
24569: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
24570: LD_ADDR_EXP 101
24574: PUSH
24575: LD_EXP 101
24579: PPUSH
24580: LD_VAR 0 4
24584: PPUSH
24585: EMPTY
24586: PPUSH
24587: CALL_OW 1
24591: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
24592: LD_ADDR_EXP 102
24596: PUSH
24597: LD_EXP 102
24601: PPUSH
24602: LD_VAR 0 4
24606: PPUSH
24607: EMPTY
24608: PPUSH
24609: CALL_OW 1
24613: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
24614: LD_ADDR_EXP 103
24618: PUSH
24619: LD_EXP 103
24623: PPUSH
24624: LD_VAR 0 4
24628: PPUSH
24629: EMPTY
24630: PPUSH
24631: CALL_OW 1
24635: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
24636: LD_ADDR_EXP 104
24640: PUSH
24641: LD_EXP 104
24645: PPUSH
24646: LD_VAR 0 4
24650: PPUSH
24651: EMPTY
24652: PPUSH
24653: CALL_OW 1
24657: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
24658: LD_ADDR_EXP 105
24662: PUSH
24663: LD_EXP 105
24667: PPUSH
24668: LD_VAR 0 4
24672: PPUSH
24673: EMPTY
24674: PPUSH
24675: CALL_OW 1
24679: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24680: LD_ADDR_EXP 107
24684: PUSH
24685: LD_EXP 107
24689: PPUSH
24690: LD_VAR 0 4
24694: PPUSH
24695: EMPTY
24696: PPUSH
24697: CALL_OW 1
24701: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24702: LD_ADDR_EXP 109
24706: PUSH
24707: LD_EXP 109
24711: PPUSH
24712: LD_VAR 0 4
24716: PPUSH
24717: EMPTY
24718: PPUSH
24719: CALL_OW 1
24723: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24724: LD_ADDR_EXP 110
24728: PUSH
24729: LD_EXP 110
24733: PPUSH
24734: LD_VAR 0 4
24738: PPUSH
24739: EMPTY
24740: PPUSH
24741: CALL_OW 1
24745: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24746: LD_ADDR_EXP 111
24750: PUSH
24751: LD_EXP 111
24755: PPUSH
24756: LD_VAR 0 4
24760: PPUSH
24761: EMPTY
24762: PPUSH
24763: CALL_OW 1
24767: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24768: LD_ADDR_EXP 112
24772: PUSH
24773: LD_EXP 112
24777: PPUSH
24778: LD_VAR 0 4
24782: PPUSH
24783: EMPTY
24784: PPUSH
24785: CALL_OW 1
24789: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24790: LD_ADDR_EXP 113
24794: PUSH
24795: LD_EXP 113
24799: PPUSH
24800: LD_VAR 0 4
24804: PPUSH
24805: EMPTY
24806: PPUSH
24807: CALL_OW 1
24811: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24812: LD_ADDR_EXP 114
24816: PUSH
24817: LD_EXP 114
24821: PPUSH
24822: LD_VAR 0 4
24826: PPUSH
24827: EMPTY
24828: PPUSH
24829: CALL_OW 1
24833: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24834: LD_ADDR_EXP 115
24838: PUSH
24839: LD_EXP 115
24843: PPUSH
24844: LD_VAR 0 4
24848: PPUSH
24849: EMPTY
24850: PPUSH
24851: CALL_OW 1
24855: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24856: LD_ADDR_EXP 116
24860: PUSH
24861: LD_EXP 116
24865: PPUSH
24866: LD_VAR 0 4
24870: PPUSH
24871: EMPTY
24872: PPUSH
24873: CALL_OW 1
24877: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24878: LD_ADDR_EXP 117
24882: PUSH
24883: LD_EXP 117
24887: PPUSH
24888: LD_VAR 0 4
24892: PPUSH
24893: EMPTY
24894: PPUSH
24895: CALL_OW 1
24899: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24900: LD_ADDR_EXP 118
24904: PUSH
24905: LD_EXP 118
24909: PPUSH
24910: LD_VAR 0 4
24914: PPUSH
24915: EMPTY
24916: PPUSH
24917: CALL_OW 1
24921: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24922: LD_ADDR_EXP 119
24926: PUSH
24927: LD_EXP 119
24931: PPUSH
24932: LD_VAR 0 4
24936: PPUSH
24937: EMPTY
24938: PPUSH
24939: CALL_OW 1
24943: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24944: LD_ADDR_EXP 120
24948: PUSH
24949: LD_EXP 120
24953: PPUSH
24954: LD_VAR 0 4
24958: PPUSH
24959: EMPTY
24960: PPUSH
24961: CALL_OW 1
24965: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24966: LD_ADDR_EXP 121
24970: PUSH
24971: LD_EXP 121
24975: PPUSH
24976: LD_VAR 0 4
24980: PPUSH
24981: EMPTY
24982: PPUSH
24983: CALL_OW 1
24987: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24988: LD_ADDR_EXP 122
24992: PUSH
24993: LD_EXP 122
24997: PPUSH
24998: LD_VAR 0 4
25002: PPUSH
25003: LD_INT 0
25005: PPUSH
25006: CALL_OW 1
25010: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
25011: LD_ADDR_EXP 123
25015: PUSH
25016: LD_EXP 123
25020: PPUSH
25021: LD_VAR 0 4
25025: PPUSH
25026: LD_INT 0
25028: PPUSH
25029: CALL_OW 1
25033: ST_TO_ADDR
// result := base ;
25034: LD_ADDR_VAR 0 3
25038: PUSH
25039: LD_VAR 0 4
25043: ST_TO_ADDR
// end ;
25044: LD_VAR 0 3
25048: RET
// export function MC_Start ( ) ; var i ; begin
25049: LD_INT 0
25051: PPUSH
25052: PPUSH
// for i = 1 to mc_bases do
25053: LD_ADDR_VAR 0 2
25057: PUSH
25058: DOUBLE
25059: LD_INT 1
25061: DEC
25062: ST_TO_ADDR
25063: LD_EXP 80
25067: PUSH
25068: FOR_TO
25069: IFFALSE 26169
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
25071: LD_ADDR_EXP 80
25075: PUSH
25076: LD_EXP 80
25080: PPUSH
25081: LD_VAR 0 2
25085: PPUSH
25086: LD_EXP 80
25090: PUSH
25091: LD_VAR 0 2
25095: ARRAY
25096: PUSH
25097: LD_INT 0
25099: DIFF
25100: PPUSH
25101: CALL_OW 1
25105: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
25106: LD_ADDR_EXP 81
25110: PUSH
25111: LD_EXP 81
25115: PPUSH
25116: LD_VAR 0 2
25120: PPUSH
25121: EMPTY
25122: PPUSH
25123: CALL_OW 1
25127: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
25128: LD_ADDR_EXP 82
25132: PUSH
25133: LD_EXP 82
25137: PPUSH
25138: LD_VAR 0 2
25142: PPUSH
25143: EMPTY
25144: PPUSH
25145: CALL_OW 1
25149: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
25150: LD_ADDR_EXP 83
25154: PUSH
25155: LD_EXP 83
25159: PPUSH
25160: LD_VAR 0 2
25164: PPUSH
25165: EMPTY
25166: PPUSH
25167: CALL_OW 1
25171: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
25172: LD_ADDR_EXP 84
25176: PUSH
25177: LD_EXP 84
25181: PPUSH
25182: LD_VAR 0 2
25186: PPUSH
25187: EMPTY
25188: PUSH
25189: EMPTY
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PPUSH
25195: CALL_OW 1
25199: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
25200: LD_ADDR_EXP 85
25204: PUSH
25205: LD_EXP 85
25209: PPUSH
25210: LD_VAR 0 2
25214: PPUSH
25215: EMPTY
25216: PPUSH
25217: CALL_OW 1
25221: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
25222: LD_ADDR_EXP 112
25226: PUSH
25227: LD_EXP 112
25231: PPUSH
25232: LD_VAR 0 2
25236: PPUSH
25237: EMPTY
25238: PPUSH
25239: CALL_OW 1
25243: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
25244: LD_ADDR_EXP 86
25248: PUSH
25249: LD_EXP 86
25253: PPUSH
25254: LD_VAR 0 2
25258: PPUSH
25259: EMPTY
25260: PPUSH
25261: CALL_OW 1
25265: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
25266: LD_ADDR_EXP 87
25270: PUSH
25271: LD_EXP 87
25275: PPUSH
25276: LD_VAR 0 2
25280: PPUSH
25281: EMPTY
25282: PPUSH
25283: CALL_OW 1
25287: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
25288: LD_ADDR_EXP 88
25292: PUSH
25293: LD_EXP 88
25297: PPUSH
25298: LD_VAR 0 2
25302: PPUSH
25303: LD_EXP 80
25307: PUSH
25308: LD_VAR 0 2
25312: ARRAY
25313: PPUSH
25314: LD_INT 2
25316: PUSH
25317: LD_INT 30
25319: PUSH
25320: LD_INT 32
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: LD_INT 30
25329: PUSH
25330: LD_INT 33
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: LIST
25341: PPUSH
25342: CALL_OW 72
25346: PPUSH
25347: CALL_OW 1
25351: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
25352: LD_ADDR_EXP 89
25356: PUSH
25357: LD_EXP 89
25361: PPUSH
25362: LD_VAR 0 2
25366: PPUSH
25367: LD_EXP 80
25371: PUSH
25372: LD_VAR 0 2
25376: ARRAY
25377: PPUSH
25378: LD_INT 2
25380: PUSH
25381: LD_INT 30
25383: PUSH
25384: LD_INT 32
25386: PUSH
25387: EMPTY
25388: LIST
25389: LIST
25390: PUSH
25391: LD_INT 30
25393: PUSH
25394: LD_INT 31
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: PUSH
25401: EMPTY
25402: LIST
25403: LIST
25404: LIST
25405: PUSH
25406: LD_INT 58
25408: PUSH
25409: EMPTY
25410: LIST
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PPUSH
25416: CALL_OW 72
25420: PPUSH
25421: CALL_OW 1
25425: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
25426: LD_ADDR_EXP 90
25430: PUSH
25431: LD_EXP 90
25435: PPUSH
25436: LD_VAR 0 2
25440: PPUSH
25441: EMPTY
25442: PPUSH
25443: CALL_OW 1
25447: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
25448: LD_ADDR_EXP 94
25452: PUSH
25453: LD_EXP 94
25457: PPUSH
25458: LD_VAR 0 2
25462: PPUSH
25463: EMPTY
25464: PPUSH
25465: CALL_OW 1
25469: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
25470: LD_ADDR_EXP 93
25474: PUSH
25475: LD_EXP 93
25479: PPUSH
25480: LD_VAR 0 2
25484: PPUSH
25485: EMPTY
25486: PPUSH
25487: CALL_OW 1
25491: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
25492: LD_ADDR_EXP 95
25496: PUSH
25497: LD_EXP 95
25501: PPUSH
25502: LD_VAR 0 2
25506: PPUSH
25507: EMPTY
25508: PPUSH
25509: CALL_OW 1
25513: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
25514: LD_ADDR_EXP 96
25518: PUSH
25519: LD_EXP 96
25523: PPUSH
25524: LD_VAR 0 2
25528: PPUSH
25529: EMPTY
25530: PPUSH
25531: CALL_OW 1
25535: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
25536: LD_ADDR_EXP 97
25540: PUSH
25541: LD_EXP 97
25545: PPUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: EMPTY
25552: PPUSH
25553: CALL_OW 1
25557: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
25558: LD_ADDR_EXP 98
25562: PUSH
25563: LD_EXP 98
25567: PPUSH
25568: LD_VAR 0 2
25572: PPUSH
25573: EMPTY
25574: PPUSH
25575: CALL_OW 1
25579: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
25580: LD_ADDR_EXP 99
25584: PUSH
25585: LD_EXP 99
25589: PPUSH
25590: LD_VAR 0 2
25594: PPUSH
25595: EMPTY
25596: PPUSH
25597: CALL_OW 1
25601: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
25602: LD_ADDR_EXP 100
25606: PUSH
25607: LD_EXP 100
25611: PPUSH
25612: LD_VAR 0 2
25616: PPUSH
25617: EMPTY
25618: PPUSH
25619: CALL_OW 1
25623: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
25624: LD_ADDR_EXP 101
25628: PUSH
25629: LD_EXP 101
25633: PPUSH
25634: LD_VAR 0 2
25638: PPUSH
25639: EMPTY
25640: PPUSH
25641: CALL_OW 1
25645: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
25646: LD_ADDR_EXP 102
25650: PUSH
25651: LD_EXP 102
25655: PPUSH
25656: LD_VAR 0 2
25660: PPUSH
25661: EMPTY
25662: PPUSH
25663: CALL_OW 1
25667: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
25668: LD_ADDR_EXP 91
25672: PUSH
25673: LD_EXP 91
25677: PPUSH
25678: LD_VAR 0 2
25682: PPUSH
25683: LD_INT 0
25685: PPUSH
25686: CALL_OW 1
25690: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
25691: LD_ADDR_EXP 104
25695: PUSH
25696: LD_EXP 104
25700: PPUSH
25701: LD_VAR 0 2
25705: PPUSH
25706: LD_INT 0
25708: PPUSH
25709: CALL_OW 1
25713: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
25714: LD_ADDR_EXP 92
25718: PUSH
25719: LD_EXP 92
25723: PPUSH
25724: LD_VAR 0 2
25728: PPUSH
25729: EMPTY
25730: PPUSH
25731: CALL_OW 1
25735: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25736: LD_ADDR_EXP 103
25740: PUSH
25741: LD_EXP 103
25745: PPUSH
25746: LD_VAR 0 2
25750: PPUSH
25751: LD_INT 0
25753: PPUSH
25754: CALL_OW 1
25758: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25759: LD_ADDR_EXP 105
25763: PUSH
25764: LD_EXP 105
25768: PPUSH
25769: LD_VAR 0 2
25773: PPUSH
25774: EMPTY
25775: PPUSH
25776: CALL_OW 1
25780: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25781: LD_ADDR_EXP 108
25785: PUSH
25786: LD_EXP 108
25790: PPUSH
25791: LD_VAR 0 2
25795: PPUSH
25796: LD_INT 0
25798: PPUSH
25799: CALL_OW 1
25803: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25804: LD_ADDR_EXP 109
25808: PUSH
25809: LD_EXP 109
25813: PPUSH
25814: LD_VAR 0 2
25818: PPUSH
25819: EMPTY
25820: PPUSH
25821: CALL_OW 1
25825: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25826: LD_ADDR_EXP 110
25830: PUSH
25831: LD_EXP 110
25835: PPUSH
25836: LD_VAR 0 2
25840: PPUSH
25841: EMPTY
25842: PPUSH
25843: CALL_OW 1
25847: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25848: LD_ADDR_EXP 111
25852: PUSH
25853: LD_EXP 111
25857: PPUSH
25858: LD_VAR 0 2
25862: PPUSH
25863: EMPTY
25864: PPUSH
25865: CALL_OW 1
25869: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25870: LD_ADDR_EXP 113
25874: PUSH
25875: LD_EXP 113
25879: PPUSH
25880: LD_VAR 0 2
25884: PPUSH
25885: LD_EXP 80
25889: PUSH
25890: LD_VAR 0 2
25894: ARRAY
25895: PPUSH
25896: LD_INT 2
25898: PUSH
25899: LD_INT 30
25901: PUSH
25902: LD_INT 6
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PUSH
25909: LD_INT 30
25911: PUSH
25912: LD_INT 7
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: LD_INT 30
25921: PUSH
25922: LD_INT 8
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: LIST
25934: PPUSH
25935: CALL_OW 72
25939: PPUSH
25940: CALL_OW 1
25944: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25945: LD_ADDR_EXP 114
25949: PUSH
25950: LD_EXP 114
25954: PPUSH
25955: LD_VAR 0 2
25959: PPUSH
25960: EMPTY
25961: PPUSH
25962: CALL_OW 1
25966: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25967: LD_ADDR_EXP 115
25971: PUSH
25972: LD_EXP 115
25976: PPUSH
25977: LD_VAR 0 2
25981: PPUSH
25982: EMPTY
25983: PPUSH
25984: CALL_OW 1
25988: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25989: LD_ADDR_EXP 116
25993: PUSH
25994: LD_EXP 116
25998: PPUSH
25999: LD_VAR 0 2
26003: PPUSH
26004: EMPTY
26005: PPUSH
26006: CALL_OW 1
26010: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
26011: LD_ADDR_EXP 117
26015: PUSH
26016: LD_EXP 117
26020: PPUSH
26021: LD_VAR 0 2
26025: PPUSH
26026: EMPTY
26027: PPUSH
26028: CALL_OW 1
26032: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
26033: LD_ADDR_EXP 118
26037: PUSH
26038: LD_EXP 118
26042: PPUSH
26043: LD_VAR 0 2
26047: PPUSH
26048: EMPTY
26049: PPUSH
26050: CALL_OW 1
26054: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
26055: LD_ADDR_EXP 119
26059: PUSH
26060: LD_EXP 119
26064: PPUSH
26065: LD_VAR 0 2
26069: PPUSH
26070: EMPTY
26071: PPUSH
26072: CALL_OW 1
26076: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
26077: LD_ADDR_EXP 120
26081: PUSH
26082: LD_EXP 120
26086: PPUSH
26087: LD_VAR 0 2
26091: PPUSH
26092: EMPTY
26093: PPUSH
26094: CALL_OW 1
26098: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
26099: LD_ADDR_EXP 121
26103: PUSH
26104: LD_EXP 121
26108: PPUSH
26109: LD_VAR 0 2
26113: PPUSH
26114: EMPTY
26115: PPUSH
26116: CALL_OW 1
26120: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
26121: LD_ADDR_EXP 122
26125: PUSH
26126: LD_EXP 122
26130: PPUSH
26131: LD_VAR 0 2
26135: PPUSH
26136: LD_INT 0
26138: PPUSH
26139: CALL_OW 1
26143: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
26144: LD_ADDR_EXP 123
26148: PUSH
26149: LD_EXP 123
26153: PPUSH
26154: LD_VAR 0 2
26158: PPUSH
26159: LD_INT 0
26161: PPUSH
26162: CALL_OW 1
26166: ST_TO_ADDR
// end ;
26167: GO 25068
26169: POP
26170: POP
// MC_InitSides ( ) ;
26171: CALL 26457 0 0
// MC_InitResearch ( ) ;
26175: CALL 26196 0 0
// CustomInitMacro ( ) ;
26179: CALL 252 0 0
// skirmish := true ;
26183: LD_ADDR_EXP 78
26187: PUSH
26188: LD_INT 1
26190: ST_TO_ADDR
// end ;
26191: LD_VAR 0 1
26195: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
26196: LD_INT 0
26198: PPUSH
26199: PPUSH
26200: PPUSH
26201: PPUSH
26202: PPUSH
26203: PPUSH
// if not mc_bases then
26204: LD_EXP 80
26208: NOT
26209: IFFALSE 26213
// exit ;
26211: GO 26452
// for i = 1 to 8 do
26213: LD_ADDR_VAR 0 2
26217: PUSH
26218: DOUBLE
26219: LD_INT 1
26221: DEC
26222: ST_TO_ADDR
26223: LD_INT 8
26225: PUSH
26226: FOR_TO
26227: IFFALSE 26253
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
26229: LD_ADDR_EXP 107
26233: PUSH
26234: LD_EXP 107
26238: PPUSH
26239: LD_VAR 0 2
26243: PPUSH
26244: EMPTY
26245: PPUSH
26246: CALL_OW 1
26250: ST_TO_ADDR
26251: GO 26226
26253: POP
26254: POP
// tmp := [ ] ;
26255: LD_ADDR_VAR 0 5
26259: PUSH
26260: EMPTY
26261: ST_TO_ADDR
// for i = 1 to mc_sides do
26262: LD_ADDR_VAR 0 2
26266: PUSH
26267: DOUBLE
26268: LD_INT 1
26270: DEC
26271: ST_TO_ADDR
26272: LD_EXP 106
26276: PUSH
26277: FOR_TO
26278: IFFALSE 26336
// if not mc_sides [ i ] in tmp then
26280: LD_EXP 106
26284: PUSH
26285: LD_VAR 0 2
26289: ARRAY
26290: PUSH
26291: LD_VAR 0 5
26295: IN
26296: NOT
26297: IFFALSE 26334
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
26299: LD_ADDR_VAR 0 5
26303: PUSH
26304: LD_VAR 0 5
26308: PPUSH
26309: LD_VAR 0 5
26313: PUSH
26314: LD_INT 1
26316: PLUS
26317: PPUSH
26318: LD_EXP 106
26322: PUSH
26323: LD_VAR 0 2
26327: ARRAY
26328: PPUSH
26329: CALL_OW 2
26333: ST_TO_ADDR
26334: GO 26277
26336: POP
26337: POP
// if not tmp then
26338: LD_VAR 0 5
26342: NOT
26343: IFFALSE 26347
// exit ;
26345: GO 26452
// for j in tmp do
26347: LD_ADDR_VAR 0 3
26351: PUSH
26352: LD_VAR 0 5
26356: PUSH
26357: FOR_IN
26358: IFFALSE 26450
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
26360: LD_ADDR_VAR 0 6
26364: PUSH
26365: LD_INT 22
26367: PUSH
26368: LD_VAR 0 3
26372: PUSH
26373: EMPTY
26374: LIST
26375: LIST
26376: PPUSH
26377: CALL_OW 69
26381: ST_TO_ADDR
// if not un then
26382: LD_VAR 0 6
26386: NOT
26387: IFFALSE 26391
// continue ;
26389: GO 26357
// nation := GetNation ( un [ 1 ] ) ;
26391: LD_ADDR_VAR 0 4
26395: PUSH
26396: LD_VAR 0 6
26400: PUSH
26401: LD_INT 1
26403: ARRAY
26404: PPUSH
26405: CALL_OW 248
26409: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
26410: LD_ADDR_EXP 107
26414: PUSH
26415: LD_EXP 107
26419: PPUSH
26420: LD_VAR 0 3
26424: PPUSH
26425: LD_VAR 0 3
26429: PPUSH
26430: LD_VAR 0 4
26434: PPUSH
26435: LD_INT 1
26437: PPUSH
26438: CALL 53661 0 3
26442: PPUSH
26443: CALL_OW 1
26447: ST_TO_ADDR
// end ;
26448: GO 26357
26450: POP
26451: POP
// end ;
26452: LD_VAR 0 1
26456: RET
// export function MC_InitSides ( ) ; var i ; begin
26457: LD_INT 0
26459: PPUSH
26460: PPUSH
// if not mc_bases then
26461: LD_EXP 80
26465: NOT
26466: IFFALSE 26470
// exit ;
26468: GO 26544
// for i = 1 to mc_bases do
26470: LD_ADDR_VAR 0 2
26474: PUSH
26475: DOUBLE
26476: LD_INT 1
26478: DEC
26479: ST_TO_ADDR
26480: LD_EXP 80
26484: PUSH
26485: FOR_TO
26486: IFFALSE 26542
// if mc_bases [ i ] then
26488: LD_EXP 80
26492: PUSH
26493: LD_VAR 0 2
26497: ARRAY
26498: IFFALSE 26540
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
26500: LD_ADDR_EXP 106
26504: PUSH
26505: LD_EXP 106
26509: PPUSH
26510: LD_VAR 0 2
26514: PPUSH
26515: LD_EXP 80
26519: PUSH
26520: LD_VAR 0 2
26524: ARRAY
26525: PUSH
26526: LD_INT 1
26528: ARRAY
26529: PPUSH
26530: CALL_OW 255
26534: PPUSH
26535: CALL_OW 1
26539: ST_TO_ADDR
26540: GO 26485
26542: POP
26543: POP
// end ;
26544: LD_VAR 0 1
26548: RET
// every 0 0$03 trigger skirmish do
26549: LD_EXP 78
26553: IFFALSE 26707
26555: GO 26557
26557: DISABLE
// begin enable ;
26558: ENABLE
// MC_CheckBuildings ( ) ;
26559: CALL 31219 0 0
// MC_CheckPeopleLife ( ) ;
26563: CALL 31380 0 0
// RaiseSailEvent ( 100 ) ;
26567: LD_INT 100
26569: PPUSH
26570: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
26574: LD_INT 103
26576: PPUSH
26577: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
26581: LD_INT 104
26583: PPUSH
26584: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
26588: LD_INT 105
26590: PPUSH
26591: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
26595: LD_INT 106
26597: PPUSH
26598: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
26602: LD_INT 107
26604: PPUSH
26605: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
26609: LD_INT 108
26611: PPUSH
26612: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
26616: LD_INT 109
26618: PPUSH
26619: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
26623: LD_INT 110
26625: PPUSH
26626: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
26630: LD_INT 111
26632: PPUSH
26633: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
26637: LD_INT 112
26639: PPUSH
26640: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
26644: LD_INT 113
26646: PPUSH
26647: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
26651: LD_INT 120
26653: PPUSH
26654: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
26658: LD_INT 121
26660: PPUSH
26661: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
26665: LD_INT 122
26667: PPUSH
26668: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
26672: LD_INT 123
26674: PPUSH
26675: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
26679: LD_INT 124
26681: PPUSH
26682: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
26686: LD_INT 125
26688: PPUSH
26689: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
26693: LD_INT 126
26695: PPUSH
26696: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
26700: LD_INT 200
26702: PPUSH
26703: CALL_OW 427
// end ;
26707: END
// on SailEvent ( event ) do begin if event < 100 then
26708: LD_VAR 0 1
26712: PUSH
26713: LD_INT 100
26715: LESS
26716: IFFALSE 26727
// CustomEvent ( event ) ;
26718: LD_VAR 0 1
26722: PPUSH
26723: CALL 11838 0 1
// if event = 100 then
26727: LD_VAR 0 1
26731: PUSH
26732: LD_INT 100
26734: EQUAL
26735: IFFALSE 26741
// MC_ClassManager ( ) ;
26737: CALL 27133 0 0
// if event = 101 then
26741: LD_VAR 0 1
26745: PUSH
26746: LD_INT 101
26748: EQUAL
26749: IFFALSE 26755
// MC_RepairBuildings ( ) ;
26751: CALL 31965 0 0
// if event = 102 then
26755: LD_VAR 0 1
26759: PUSH
26760: LD_INT 102
26762: EQUAL
26763: IFFALSE 26769
// MC_Heal ( ) ;
26765: CALL 32900 0 0
// if event = 103 then
26769: LD_VAR 0 1
26773: PUSH
26774: LD_INT 103
26776: EQUAL
26777: IFFALSE 26783
// MC_Build ( ) ;
26779: CALL 33322 0 0
// if event = 104 then
26783: LD_VAR 0 1
26787: PUSH
26788: LD_INT 104
26790: EQUAL
26791: IFFALSE 26797
// MC_TurretWeapon ( ) ;
26793: CALL 34956 0 0
// if event = 105 then
26797: LD_VAR 0 1
26801: PUSH
26802: LD_INT 105
26804: EQUAL
26805: IFFALSE 26811
// MC_BuildUpgrade ( ) ;
26807: CALL 34507 0 0
// if event = 106 then
26811: LD_VAR 0 1
26815: PUSH
26816: LD_INT 106
26818: EQUAL
26819: IFFALSE 26825
// MC_PlantMines ( ) ;
26821: CALL 35386 0 0
// if event = 107 then
26825: LD_VAR 0 1
26829: PUSH
26830: LD_INT 107
26832: EQUAL
26833: IFFALSE 26839
// MC_CollectCrates ( ) ;
26835: CALL 36184 0 0
// if event = 108 then
26839: LD_VAR 0 1
26843: PUSH
26844: LD_INT 108
26846: EQUAL
26847: IFFALSE 26853
// MC_LinkRemoteControl ( ) ;
26849: CALL 38034 0 0
// if event = 109 then
26853: LD_VAR 0 1
26857: PUSH
26858: LD_INT 109
26860: EQUAL
26861: IFFALSE 26867
// MC_ProduceVehicle ( ) ;
26863: CALL 38215 0 0
// if event = 110 then
26867: LD_VAR 0 1
26871: PUSH
26872: LD_INT 110
26874: EQUAL
26875: IFFALSE 26881
// MC_SendAttack ( ) ;
26877: CALL 38681 0 0
// if event = 111 then
26881: LD_VAR 0 1
26885: PUSH
26886: LD_INT 111
26888: EQUAL
26889: IFFALSE 26895
// MC_Defend ( ) ;
26891: CALL 38789 0 0
// if event = 112 then
26895: LD_VAR 0 1
26899: PUSH
26900: LD_INT 112
26902: EQUAL
26903: IFFALSE 26909
// MC_Research ( ) ;
26905: CALL 39669 0 0
// if event = 113 then
26909: LD_VAR 0 1
26913: PUSH
26914: LD_INT 113
26916: EQUAL
26917: IFFALSE 26923
// MC_MinesTrigger ( ) ;
26919: CALL 40783 0 0
// if event = 120 then
26923: LD_VAR 0 1
26927: PUSH
26928: LD_INT 120
26930: EQUAL
26931: IFFALSE 26937
// MC_RepairVehicle ( ) ;
26933: CALL 40882 0 0
// if event = 121 then
26937: LD_VAR 0 1
26941: PUSH
26942: LD_INT 121
26944: EQUAL
26945: IFFALSE 26951
// MC_TameApe ( ) ;
26947: CALL 41651 0 0
// if event = 122 then
26951: LD_VAR 0 1
26955: PUSH
26956: LD_INT 122
26958: EQUAL
26959: IFFALSE 26965
// MC_ChangeApeClass ( ) ;
26961: CALL 42480 0 0
// if event = 123 then
26965: LD_VAR 0 1
26969: PUSH
26970: LD_INT 123
26972: EQUAL
26973: IFFALSE 26979
// MC_Bazooka ( ) ;
26975: CALL 43130 0 0
// if event = 124 then
26979: LD_VAR 0 1
26983: PUSH
26984: LD_INT 124
26986: EQUAL
26987: IFFALSE 26993
// MC_TeleportExit ( ) ;
26989: CALL 43328 0 0
// if event = 125 then
26993: LD_VAR 0 1
26997: PUSH
26998: LD_INT 125
27000: EQUAL
27001: IFFALSE 27007
// MC_Deposits ( ) ;
27003: CALL 43975 0 0
// if event = 126 then
27007: LD_VAR 0 1
27011: PUSH
27012: LD_INT 126
27014: EQUAL
27015: IFFALSE 27021
// MC_RemoteDriver ( ) ;
27017: CALL 44600 0 0
// if event = 200 then
27021: LD_VAR 0 1
27025: PUSH
27026: LD_INT 200
27028: EQUAL
27029: IFFALSE 27035
// MC_Idle ( ) ;
27031: CALL 46507 0 0
// end ;
27035: PPOPN 1
27037: END
// export function MC_Reset ( base , tag ) ; var i ; begin
27038: LD_INT 0
27040: PPUSH
27041: PPUSH
// if not mc_bases [ base ] or not tag then
27042: LD_EXP 80
27046: PUSH
27047: LD_VAR 0 1
27051: ARRAY
27052: NOT
27053: PUSH
27054: LD_VAR 0 2
27058: NOT
27059: OR
27060: IFFALSE 27064
// exit ;
27062: GO 27128
// for i in mc_bases [ base ] union mc_ape [ base ] do
27064: LD_ADDR_VAR 0 4
27068: PUSH
27069: LD_EXP 80
27073: PUSH
27074: LD_VAR 0 1
27078: ARRAY
27079: PUSH
27080: LD_EXP 109
27084: PUSH
27085: LD_VAR 0 1
27089: ARRAY
27090: UNION
27091: PUSH
27092: FOR_IN
27093: IFFALSE 27126
// if GetTag ( i ) = tag then
27095: LD_VAR 0 4
27099: PPUSH
27100: CALL_OW 110
27104: PUSH
27105: LD_VAR 0 2
27109: EQUAL
27110: IFFALSE 27124
// SetTag ( i , 0 ) ;
27112: LD_VAR 0 4
27116: PPUSH
27117: LD_INT 0
27119: PPUSH
27120: CALL_OW 109
27124: GO 27092
27126: POP
27127: POP
// end ;
27128: LD_VAR 0 3
27132: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
27133: LD_INT 0
27135: PPUSH
27136: PPUSH
27137: PPUSH
27138: PPUSH
27139: PPUSH
27140: PPUSH
27141: PPUSH
27142: PPUSH
// if not mc_bases then
27143: LD_EXP 80
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 27601
// for i = 1 to mc_bases do
27152: LD_ADDR_VAR 0 2
27156: PUSH
27157: DOUBLE
27158: LD_INT 1
27160: DEC
27161: ST_TO_ADDR
27162: LD_EXP 80
27166: PUSH
27167: FOR_TO
27168: IFFALSE 27599
// begin tmp := MC_ClassCheckReq ( i ) ;
27170: LD_ADDR_VAR 0 4
27174: PUSH
27175: LD_VAR 0 2
27179: PPUSH
27180: CALL 27606 0 1
27184: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
27185: LD_ADDR_EXP 121
27189: PUSH
27190: LD_EXP 121
27194: PPUSH
27195: LD_VAR 0 2
27199: PPUSH
27200: LD_VAR 0 4
27204: PPUSH
27205: CALL_OW 1
27209: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
27210: LD_ADDR_VAR 0 6
27214: PUSH
27215: LD_EXP 80
27219: PUSH
27220: LD_VAR 0 2
27224: ARRAY
27225: PPUSH
27226: LD_INT 2
27228: PUSH
27229: LD_INT 30
27231: PUSH
27232: LD_INT 4
27234: PUSH
27235: EMPTY
27236: LIST
27237: LIST
27238: PUSH
27239: LD_INT 30
27241: PUSH
27242: LD_INT 5
27244: PUSH
27245: EMPTY
27246: LIST
27247: LIST
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: LIST
27253: PPUSH
27254: CALL_OW 72
27258: PUSH
27259: LD_EXP 80
27263: PUSH
27264: LD_VAR 0 2
27268: ARRAY
27269: PPUSH
27270: LD_INT 2
27272: PUSH
27273: LD_INT 30
27275: PUSH
27276: LD_INT 0
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: LD_INT 30
27285: PUSH
27286: LD_INT 1
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: LIST
27297: PPUSH
27298: CALL_OW 72
27302: PUSH
27303: LD_EXP 80
27307: PUSH
27308: LD_VAR 0 2
27312: ARRAY
27313: PPUSH
27314: LD_INT 30
27316: PUSH
27317: LD_INT 3
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PPUSH
27324: CALL_OW 72
27328: PUSH
27329: LD_EXP 80
27333: PUSH
27334: LD_VAR 0 2
27338: ARRAY
27339: PPUSH
27340: LD_INT 2
27342: PUSH
27343: LD_INT 30
27345: PUSH
27346: LD_INT 6
27348: PUSH
27349: EMPTY
27350: LIST
27351: LIST
27352: PUSH
27353: LD_INT 30
27355: PUSH
27356: LD_INT 7
27358: PUSH
27359: EMPTY
27360: LIST
27361: LIST
27362: PUSH
27363: LD_INT 30
27365: PUSH
27366: LD_INT 8
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: PPUSH
27379: CALL_OW 72
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: ST_TO_ADDR
// for j := 1 to 4 do
27390: LD_ADDR_VAR 0 3
27394: PUSH
27395: DOUBLE
27396: LD_INT 1
27398: DEC
27399: ST_TO_ADDR
27400: LD_INT 4
27402: PUSH
27403: FOR_TO
27404: IFFALSE 27595
// begin if not tmp [ j ] then
27406: LD_VAR 0 4
27410: PUSH
27411: LD_VAR 0 3
27415: ARRAY
27416: NOT
27417: IFFALSE 27421
// continue ;
27419: GO 27403
// for p in tmp [ j ] do
27421: LD_ADDR_VAR 0 5
27425: PUSH
27426: LD_VAR 0 4
27430: PUSH
27431: LD_VAR 0 3
27435: ARRAY
27436: PUSH
27437: FOR_IN
27438: IFFALSE 27591
// begin if not b [ j ] then
27440: LD_VAR 0 6
27444: PUSH
27445: LD_VAR 0 3
27449: ARRAY
27450: NOT
27451: IFFALSE 27455
// break ;
27453: GO 27591
// e := 0 ;
27455: LD_ADDR_VAR 0 7
27459: PUSH
27460: LD_INT 0
27462: ST_TO_ADDR
// for k in b [ j ] do
27463: LD_ADDR_VAR 0 8
27467: PUSH
27468: LD_VAR 0 6
27472: PUSH
27473: LD_VAR 0 3
27477: ARRAY
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27507
// if IsNotFull ( k ) then
27482: LD_VAR 0 8
27486: PPUSH
27487: CALL 55782 0 1
27491: IFFALSE 27505
// begin e := k ;
27493: LD_ADDR_VAR 0 7
27497: PUSH
27498: LD_VAR 0 8
27502: ST_TO_ADDR
// break ;
27503: GO 27507
// end ;
27505: GO 27479
27507: POP
27508: POP
// if e and not UnitGoingToBuilding ( p , e ) then
27509: LD_VAR 0 7
27513: PUSH
27514: LD_VAR 0 5
27518: PPUSH
27519: LD_VAR 0 7
27523: PPUSH
27524: CALL 89941 0 2
27528: NOT
27529: AND
27530: IFFALSE 27589
// begin if IsInUnit ( p ) then
27532: LD_VAR 0 5
27536: PPUSH
27537: CALL_OW 310
27541: IFFALSE 27552
// ComExitBuilding ( p ) ;
27543: LD_VAR 0 5
27547: PPUSH
27548: CALL_OW 122
// ComEnterUnit ( p , e ) ;
27552: LD_VAR 0 5
27556: PPUSH
27557: LD_VAR 0 7
27561: PPUSH
27562: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
27566: LD_VAR 0 5
27570: PPUSH
27571: LD_VAR 0 3
27575: PPUSH
27576: CALL_OW 183
// AddComExitBuilding ( p ) ;
27580: LD_VAR 0 5
27584: PPUSH
27585: CALL_OW 182
// end ; end ;
27589: GO 27437
27591: POP
27592: POP
// end ;
27593: GO 27403
27595: POP
27596: POP
// end ;
27597: GO 27167
27599: POP
27600: POP
// end ;
27601: LD_VAR 0 1
27605: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
27606: LD_INT 0
27608: PPUSH
27609: PPUSH
27610: PPUSH
27611: PPUSH
27612: PPUSH
27613: PPUSH
27614: PPUSH
27615: PPUSH
27616: PPUSH
27617: PPUSH
27618: PPUSH
27619: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
27620: LD_ADDR_VAR 0 2
27624: PUSH
27625: LD_INT 0
27627: PUSH
27628: LD_INT 0
27630: PUSH
27631: LD_INT 0
27633: PUSH
27634: LD_INT 0
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: LIST
27641: LIST
27642: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
27643: LD_VAR 0 1
27647: NOT
27648: PUSH
27649: LD_EXP 80
27653: PUSH
27654: LD_VAR 0 1
27658: ARRAY
27659: NOT
27660: OR
27661: PUSH
27662: LD_EXP 80
27666: PUSH
27667: LD_VAR 0 1
27671: ARRAY
27672: PPUSH
27673: LD_INT 2
27675: PUSH
27676: LD_INT 30
27678: PUSH
27679: LD_INT 0
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 30
27688: PUSH
27689: LD_INT 1
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: EMPTY
27697: LIST
27698: LIST
27699: LIST
27700: PPUSH
27701: CALL_OW 72
27705: NOT
27706: OR
27707: IFFALSE 27711
// exit ;
27709: GO 31214
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27711: LD_ADDR_VAR 0 4
27715: PUSH
27716: LD_EXP 80
27720: PUSH
27721: LD_VAR 0 1
27725: ARRAY
27726: PPUSH
27727: LD_INT 2
27729: PUSH
27730: LD_INT 25
27732: PUSH
27733: LD_INT 1
27735: PUSH
27736: EMPTY
27737: LIST
27738: LIST
27739: PUSH
27740: LD_INT 25
27742: PUSH
27743: LD_INT 2
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PUSH
27750: LD_INT 25
27752: PUSH
27753: LD_INT 3
27755: PUSH
27756: EMPTY
27757: LIST
27758: LIST
27759: PUSH
27760: LD_INT 25
27762: PUSH
27763: LD_INT 4
27765: PUSH
27766: EMPTY
27767: LIST
27768: LIST
27769: PUSH
27770: LD_INT 25
27772: PUSH
27773: LD_INT 5
27775: PUSH
27776: EMPTY
27777: LIST
27778: LIST
27779: PUSH
27780: LD_INT 25
27782: PUSH
27783: LD_INT 8
27785: PUSH
27786: EMPTY
27787: LIST
27788: LIST
27789: PUSH
27790: LD_INT 25
27792: PUSH
27793: LD_INT 9
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: LIST
27804: LIST
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: PPUSH
27810: CALL_OW 72
27814: ST_TO_ADDR
// if not tmp then
27815: LD_VAR 0 4
27819: NOT
27820: IFFALSE 27824
// exit ;
27822: GO 31214
// for i in tmp do
27824: LD_ADDR_VAR 0 3
27828: PUSH
27829: LD_VAR 0 4
27833: PUSH
27834: FOR_IN
27835: IFFALSE 27866
// if GetTag ( i ) then
27837: LD_VAR 0 3
27841: PPUSH
27842: CALL_OW 110
27846: IFFALSE 27864
// tmp := tmp diff i ;
27848: LD_ADDR_VAR 0 4
27852: PUSH
27853: LD_VAR 0 4
27857: PUSH
27858: LD_VAR 0 3
27862: DIFF
27863: ST_TO_ADDR
27864: GO 27834
27866: POP
27867: POP
// if not tmp then
27868: LD_VAR 0 4
27872: NOT
27873: IFFALSE 27877
// exit ;
27875: GO 31214
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27877: LD_ADDR_VAR 0 5
27881: PUSH
27882: LD_EXP 80
27886: PUSH
27887: LD_VAR 0 1
27891: ARRAY
27892: PPUSH
27893: LD_INT 2
27895: PUSH
27896: LD_INT 25
27898: PUSH
27899: LD_INT 1
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: LD_INT 25
27908: PUSH
27909: LD_INT 5
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: PUSH
27916: LD_INT 25
27918: PUSH
27919: LD_INT 8
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: LD_INT 25
27928: PUSH
27929: LD_INT 9
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: LIST
27940: LIST
27941: LIST
27942: PPUSH
27943: CALL_OW 72
27947: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27948: LD_ADDR_VAR 0 6
27952: PUSH
27953: LD_EXP 80
27957: PUSH
27958: LD_VAR 0 1
27962: ARRAY
27963: PPUSH
27964: LD_INT 25
27966: PUSH
27967: LD_INT 2
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: PPUSH
27974: CALL_OW 72
27978: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27979: LD_ADDR_VAR 0 7
27983: PUSH
27984: LD_EXP 80
27988: PUSH
27989: LD_VAR 0 1
27993: ARRAY
27994: PPUSH
27995: LD_INT 25
27997: PUSH
27998: LD_INT 3
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: PPUSH
28005: CALL_OW 72
28009: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
28010: LD_ADDR_VAR 0 8
28014: PUSH
28015: LD_EXP 80
28019: PUSH
28020: LD_VAR 0 1
28024: ARRAY
28025: PPUSH
28026: LD_INT 25
28028: PUSH
28029: LD_INT 4
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 24
28038: PUSH
28039: LD_INT 251
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PPUSH
28050: CALL_OW 72
28054: ST_TO_ADDR
// if mc_is_defending [ base ] then
28055: LD_EXP 123
28059: PUSH
28060: LD_VAR 0 1
28064: ARRAY
28065: IFFALSE 28526
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
28067: LD_ADDR_EXP 122
28071: PUSH
28072: LD_EXP 122
28076: PPUSH
28077: LD_VAR 0 1
28081: PPUSH
28082: LD_INT 4
28084: PPUSH
28085: CALL_OW 1
28089: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
28090: LD_ADDR_VAR 0 12
28094: PUSH
28095: LD_EXP 80
28099: PUSH
28100: LD_VAR 0 1
28104: ARRAY
28105: PPUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 30
28111: PUSH
28112: LD_INT 4
28114: PUSH
28115: EMPTY
28116: LIST
28117: LIST
28118: PUSH
28119: LD_INT 30
28121: PUSH
28122: LD_INT 5
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: LIST
28133: PPUSH
28134: CALL_OW 72
28138: ST_TO_ADDR
// if not b then
28139: LD_VAR 0 12
28143: NOT
28144: IFFALSE 28148
// exit ;
28146: GO 31214
// p := [ ] ;
28148: LD_ADDR_VAR 0 11
28152: PUSH
28153: EMPTY
28154: ST_TO_ADDR
// if sci >= 2 then
28155: LD_VAR 0 8
28159: PUSH
28160: LD_INT 2
28162: GREATEREQUAL
28163: IFFALSE 28194
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
28165: LD_ADDR_VAR 0 8
28169: PUSH
28170: LD_VAR 0 8
28174: PUSH
28175: LD_INT 1
28177: ARRAY
28178: PUSH
28179: LD_VAR 0 8
28183: PUSH
28184: LD_INT 2
28186: ARRAY
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: ST_TO_ADDR
28192: GO 28255
// if sci = 1 then
28194: LD_VAR 0 8
28198: PUSH
28199: LD_INT 1
28201: EQUAL
28202: IFFALSE 28223
// sci := [ sci [ 1 ] ] else
28204: LD_ADDR_VAR 0 8
28208: PUSH
28209: LD_VAR 0 8
28213: PUSH
28214: LD_INT 1
28216: ARRAY
28217: PUSH
28218: EMPTY
28219: LIST
28220: ST_TO_ADDR
28221: GO 28255
// if sci = 0 then
28223: LD_VAR 0 8
28227: PUSH
28228: LD_INT 0
28230: EQUAL
28231: IFFALSE 28255
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
28233: LD_ADDR_VAR 0 11
28237: PUSH
28238: LD_VAR 0 4
28242: PPUSH
28243: LD_INT 4
28245: PPUSH
28246: CALL 89813 0 2
28250: PUSH
28251: LD_INT 1
28253: ARRAY
28254: ST_TO_ADDR
// if eng > 4 then
28255: LD_VAR 0 6
28259: PUSH
28260: LD_INT 4
28262: GREATER
28263: IFFALSE 28309
// for i = eng downto 4 do
28265: LD_ADDR_VAR 0 3
28269: PUSH
28270: DOUBLE
28271: LD_VAR 0 6
28275: INC
28276: ST_TO_ADDR
28277: LD_INT 4
28279: PUSH
28280: FOR_DOWNTO
28281: IFFALSE 28307
// eng := eng diff eng [ i ] ;
28283: LD_ADDR_VAR 0 6
28287: PUSH
28288: LD_VAR 0 6
28292: PUSH
28293: LD_VAR 0 6
28297: PUSH
28298: LD_VAR 0 3
28302: ARRAY
28303: DIFF
28304: ST_TO_ADDR
28305: GO 28280
28307: POP
28308: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
28309: LD_ADDR_VAR 0 4
28313: PUSH
28314: LD_VAR 0 4
28318: PUSH
28319: LD_VAR 0 5
28323: PUSH
28324: LD_VAR 0 6
28328: UNION
28329: PUSH
28330: LD_VAR 0 7
28334: UNION
28335: PUSH
28336: LD_VAR 0 8
28340: UNION
28341: DIFF
28342: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
28343: LD_ADDR_VAR 0 13
28347: PUSH
28348: LD_EXP 80
28352: PUSH
28353: LD_VAR 0 1
28357: ARRAY
28358: PPUSH
28359: LD_INT 2
28361: PUSH
28362: LD_INT 30
28364: PUSH
28365: LD_INT 32
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PUSH
28372: LD_INT 30
28374: PUSH
28375: LD_INT 31
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: EMPTY
28383: LIST
28384: LIST
28385: LIST
28386: PPUSH
28387: CALL_OW 72
28391: PUSH
28392: LD_EXP 80
28396: PUSH
28397: LD_VAR 0 1
28401: ARRAY
28402: PPUSH
28403: LD_INT 2
28405: PUSH
28406: LD_INT 30
28408: PUSH
28409: LD_INT 4
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 30
28418: PUSH
28419: LD_INT 5
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: LIST
28430: PPUSH
28431: CALL_OW 72
28435: PUSH
28436: LD_INT 6
28438: MUL
28439: PLUS
28440: ST_TO_ADDR
// if bcount < tmp then
28441: LD_VAR 0 13
28445: PUSH
28446: LD_VAR 0 4
28450: LESS
28451: IFFALSE 28497
// for i = tmp downto bcount do
28453: LD_ADDR_VAR 0 3
28457: PUSH
28458: DOUBLE
28459: LD_VAR 0 4
28463: INC
28464: ST_TO_ADDR
28465: LD_VAR 0 13
28469: PUSH
28470: FOR_DOWNTO
28471: IFFALSE 28495
// tmp := Delete ( tmp , tmp ) ;
28473: LD_ADDR_VAR 0 4
28477: PUSH
28478: LD_VAR 0 4
28482: PPUSH
28483: LD_VAR 0 4
28487: PPUSH
28488: CALL_OW 3
28492: ST_TO_ADDR
28493: GO 28470
28495: POP
28496: POP
// result := [ tmp , 0 , 0 , p ] ;
28497: LD_ADDR_VAR 0 2
28501: PUSH
28502: LD_VAR 0 4
28506: PUSH
28507: LD_INT 0
28509: PUSH
28510: LD_INT 0
28512: PUSH
28513: LD_VAR 0 11
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: LIST
28522: LIST
28523: ST_TO_ADDR
// exit ;
28524: GO 31214
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28526: LD_EXP 80
28530: PUSH
28531: LD_VAR 0 1
28535: ARRAY
28536: PPUSH
28537: LD_INT 2
28539: PUSH
28540: LD_INT 30
28542: PUSH
28543: LD_INT 6
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PUSH
28550: LD_INT 30
28552: PUSH
28553: LD_INT 7
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 30
28562: PUSH
28563: LD_INT 8
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: EMPTY
28571: LIST
28572: LIST
28573: LIST
28574: LIST
28575: PPUSH
28576: CALL_OW 72
28580: NOT
28581: PUSH
28582: LD_EXP 80
28586: PUSH
28587: LD_VAR 0 1
28591: ARRAY
28592: PPUSH
28593: LD_INT 30
28595: PUSH
28596: LD_INT 3
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PPUSH
28603: CALL_OW 72
28607: NOT
28608: AND
28609: IFFALSE 28681
// begin if eng = tmp then
28611: LD_VAR 0 6
28615: PUSH
28616: LD_VAR 0 4
28620: EQUAL
28621: IFFALSE 28625
// exit ;
28623: GO 31214
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
28625: LD_ADDR_EXP 122
28629: PUSH
28630: LD_EXP 122
28634: PPUSH
28635: LD_VAR 0 1
28639: PPUSH
28640: LD_INT 1
28642: PPUSH
28643: CALL_OW 1
28647: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
28648: LD_ADDR_VAR 0 2
28652: PUSH
28653: LD_INT 0
28655: PUSH
28656: LD_VAR 0 4
28660: PUSH
28661: LD_VAR 0 6
28665: DIFF
28666: PUSH
28667: LD_INT 0
28669: PUSH
28670: LD_INT 0
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: LIST
28677: LIST
28678: ST_TO_ADDR
// exit ;
28679: GO 31214
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28681: LD_EXP 107
28685: PUSH
28686: LD_EXP 106
28690: PUSH
28691: LD_VAR 0 1
28695: ARRAY
28696: ARRAY
28697: PUSH
28698: LD_EXP 80
28702: PUSH
28703: LD_VAR 0 1
28707: ARRAY
28708: PPUSH
28709: LD_INT 2
28711: PUSH
28712: LD_INT 30
28714: PUSH
28715: LD_INT 6
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 30
28724: PUSH
28725: LD_INT 7
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 30
28734: PUSH
28735: LD_INT 8
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: LIST
28746: LIST
28747: PPUSH
28748: CALL_OW 72
28752: AND
28753: PUSH
28754: LD_EXP 80
28758: PUSH
28759: LD_VAR 0 1
28763: ARRAY
28764: PPUSH
28765: LD_INT 30
28767: PUSH
28768: LD_INT 3
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PPUSH
28775: CALL_OW 72
28779: NOT
28780: AND
28781: IFFALSE 28995
// begin if sci >= 6 then
28783: LD_VAR 0 8
28787: PUSH
28788: LD_INT 6
28790: GREATEREQUAL
28791: IFFALSE 28795
// exit ;
28793: GO 31214
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28795: LD_ADDR_EXP 122
28799: PUSH
28800: LD_EXP 122
28804: PPUSH
28805: LD_VAR 0 1
28809: PPUSH
28810: LD_INT 2
28812: PPUSH
28813: CALL_OW 1
28817: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28818: LD_ADDR_VAR 0 9
28822: PUSH
28823: LD_VAR 0 4
28827: PUSH
28828: LD_VAR 0 8
28832: DIFF
28833: PPUSH
28834: LD_INT 4
28836: PPUSH
28837: CALL 89813 0 2
28841: ST_TO_ADDR
// p := [ ] ;
28842: LD_ADDR_VAR 0 11
28846: PUSH
28847: EMPTY
28848: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28849: LD_VAR 0 8
28853: PUSH
28854: LD_INT 6
28856: LESS
28857: PUSH
28858: LD_VAR 0 9
28862: PUSH
28863: LD_INT 6
28865: GREATER
28866: AND
28867: IFFALSE 28948
// begin for i = 1 to 6 - sci do
28869: LD_ADDR_VAR 0 3
28873: PUSH
28874: DOUBLE
28875: LD_INT 1
28877: DEC
28878: ST_TO_ADDR
28879: LD_INT 6
28881: PUSH
28882: LD_VAR 0 8
28886: MINUS
28887: PUSH
28888: FOR_TO
28889: IFFALSE 28944
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28891: LD_ADDR_VAR 0 11
28895: PUSH
28896: LD_VAR 0 11
28900: PPUSH
28901: LD_VAR 0 11
28905: PUSH
28906: LD_INT 1
28908: PLUS
28909: PPUSH
28910: LD_VAR 0 9
28914: PUSH
28915: LD_INT 1
28917: ARRAY
28918: PPUSH
28919: CALL_OW 2
28923: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28924: LD_ADDR_VAR 0 9
28928: PUSH
28929: LD_VAR 0 9
28933: PPUSH
28934: LD_INT 1
28936: PPUSH
28937: CALL_OW 3
28941: ST_TO_ADDR
// end ;
28942: GO 28888
28944: POP
28945: POP
// end else
28946: GO 28968
// if sort then
28948: LD_VAR 0 9
28952: IFFALSE 28968
// p := sort [ 1 ] ;
28954: LD_ADDR_VAR 0 11
28958: PUSH
28959: LD_VAR 0 9
28963: PUSH
28964: LD_INT 1
28966: ARRAY
28967: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28968: LD_ADDR_VAR 0 2
28972: PUSH
28973: LD_INT 0
28975: PUSH
28976: LD_INT 0
28978: PUSH
28979: LD_INT 0
28981: PUSH
28982: LD_VAR 0 11
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// exit ;
28993: GO 31214
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28995: LD_EXP 107
28999: PUSH
29000: LD_EXP 106
29004: PUSH
29005: LD_VAR 0 1
29009: ARRAY
29010: ARRAY
29011: PUSH
29012: LD_EXP 80
29016: PUSH
29017: LD_VAR 0 1
29021: ARRAY
29022: PPUSH
29023: LD_INT 2
29025: PUSH
29026: LD_INT 30
29028: PUSH
29029: LD_INT 6
29031: PUSH
29032: EMPTY
29033: LIST
29034: LIST
29035: PUSH
29036: LD_INT 30
29038: PUSH
29039: LD_INT 7
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 30
29048: PUSH
29049: LD_INT 8
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: LIST
29060: LIST
29061: PPUSH
29062: CALL_OW 72
29066: AND
29067: PUSH
29068: LD_EXP 80
29072: PUSH
29073: LD_VAR 0 1
29077: ARRAY
29078: PPUSH
29079: LD_INT 30
29081: PUSH
29082: LD_INT 3
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PPUSH
29089: CALL_OW 72
29093: AND
29094: IFFALSE 29828
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
29096: LD_ADDR_EXP 122
29100: PUSH
29101: LD_EXP 122
29105: PPUSH
29106: LD_VAR 0 1
29110: PPUSH
29111: LD_INT 3
29113: PPUSH
29114: CALL_OW 1
29118: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29119: LD_ADDR_VAR 0 2
29123: PUSH
29124: LD_INT 0
29126: PUSH
29127: LD_INT 0
29129: PUSH
29130: LD_INT 0
29132: PUSH
29133: LD_INT 0
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: LIST
29140: LIST
29141: ST_TO_ADDR
// if not eng then
29142: LD_VAR 0 6
29146: NOT
29147: IFFALSE 29210
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
29149: LD_ADDR_VAR 0 11
29153: PUSH
29154: LD_VAR 0 4
29158: PPUSH
29159: LD_INT 2
29161: PPUSH
29162: CALL 89813 0 2
29166: PUSH
29167: LD_INT 1
29169: ARRAY
29170: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
29171: LD_ADDR_VAR 0 2
29175: PUSH
29176: LD_VAR 0 2
29180: PPUSH
29181: LD_INT 2
29183: PPUSH
29184: LD_VAR 0 11
29188: PPUSH
29189: CALL_OW 1
29193: ST_TO_ADDR
// tmp := tmp diff p ;
29194: LD_ADDR_VAR 0 4
29198: PUSH
29199: LD_VAR 0 4
29203: PUSH
29204: LD_VAR 0 11
29208: DIFF
29209: ST_TO_ADDR
// end ; if tmp and sci < 6 then
29210: LD_VAR 0 4
29214: PUSH
29215: LD_VAR 0 8
29219: PUSH
29220: LD_INT 6
29222: LESS
29223: AND
29224: IFFALSE 29412
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
29226: LD_ADDR_VAR 0 9
29230: PUSH
29231: LD_VAR 0 4
29235: PUSH
29236: LD_VAR 0 8
29240: PUSH
29241: LD_VAR 0 7
29245: UNION
29246: DIFF
29247: PPUSH
29248: LD_INT 4
29250: PPUSH
29251: CALL 89813 0 2
29255: ST_TO_ADDR
// p := [ ] ;
29256: LD_ADDR_VAR 0 11
29260: PUSH
29261: EMPTY
29262: ST_TO_ADDR
// if sort then
29263: LD_VAR 0 9
29267: IFFALSE 29383
// for i = 1 to 6 - sci do
29269: LD_ADDR_VAR 0 3
29273: PUSH
29274: DOUBLE
29275: LD_INT 1
29277: DEC
29278: ST_TO_ADDR
29279: LD_INT 6
29281: PUSH
29282: LD_VAR 0 8
29286: MINUS
29287: PUSH
29288: FOR_TO
29289: IFFALSE 29381
// begin if i = sort then
29291: LD_VAR 0 3
29295: PUSH
29296: LD_VAR 0 9
29300: EQUAL
29301: IFFALSE 29305
// break ;
29303: GO 29381
// if GetClass ( i ) = 4 then
29305: LD_VAR 0 3
29309: PPUSH
29310: CALL_OW 257
29314: PUSH
29315: LD_INT 4
29317: EQUAL
29318: IFFALSE 29322
// continue ;
29320: GO 29288
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29322: LD_ADDR_VAR 0 11
29326: PUSH
29327: LD_VAR 0 11
29331: PPUSH
29332: LD_VAR 0 11
29336: PUSH
29337: LD_INT 1
29339: PLUS
29340: PPUSH
29341: LD_VAR 0 9
29345: PUSH
29346: LD_VAR 0 3
29350: ARRAY
29351: PPUSH
29352: CALL_OW 2
29356: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29357: LD_ADDR_VAR 0 4
29361: PUSH
29362: LD_VAR 0 4
29366: PUSH
29367: LD_VAR 0 9
29371: PUSH
29372: LD_VAR 0 3
29376: ARRAY
29377: DIFF
29378: ST_TO_ADDR
// end ;
29379: GO 29288
29381: POP
29382: POP
// if p then
29383: LD_VAR 0 11
29387: IFFALSE 29412
// result := Replace ( result , 4 , p ) ;
29389: LD_ADDR_VAR 0 2
29393: PUSH
29394: LD_VAR 0 2
29398: PPUSH
29399: LD_INT 4
29401: PPUSH
29402: LD_VAR 0 11
29406: PPUSH
29407: CALL_OW 1
29411: ST_TO_ADDR
// end ; if tmp and mech < 6 then
29412: LD_VAR 0 4
29416: PUSH
29417: LD_VAR 0 7
29421: PUSH
29422: LD_INT 6
29424: LESS
29425: AND
29426: IFFALSE 29614
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29428: LD_ADDR_VAR 0 9
29432: PUSH
29433: LD_VAR 0 4
29437: PUSH
29438: LD_VAR 0 8
29442: PUSH
29443: LD_VAR 0 7
29447: UNION
29448: DIFF
29449: PPUSH
29450: LD_INT 3
29452: PPUSH
29453: CALL 89813 0 2
29457: ST_TO_ADDR
// p := [ ] ;
29458: LD_ADDR_VAR 0 11
29462: PUSH
29463: EMPTY
29464: ST_TO_ADDR
// if sort then
29465: LD_VAR 0 9
29469: IFFALSE 29585
// for i = 1 to 6 - mech do
29471: LD_ADDR_VAR 0 3
29475: PUSH
29476: DOUBLE
29477: LD_INT 1
29479: DEC
29480: ST_TO_ADDR
29481: LD_INT 6
29483: PUSH
29484: LD_VAR 0 7
29488: MINUS
29489: PUSH
29490: FOR_TO
29491: IFFALSE 29583
// begin if i = sort then
29493: LD_VAR 0 3
29497: PUSH
29498: LD_VAR 0 9
29502: EQUAL
29503: IFFALSE 29507
// break ;
29505: GO 29583
// if GetClass ( i ) = 3 then
29507: LD_VAR 0 3
29511: PPUSH
29512: CALL_OW 257
29516: PUSH
29517: LD_INT 3
29519: EQUAL
29520: IFFALSE 29524
// continue ;
29522: GO 29490
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29524: LD_ADDR_VAR 0 11
29528: PUSH
29529: LD_VAR 0 11
29533: PPUSH
29534: LD_VAR 0 11
29538: PUSH
29539: LD_INT 1
29541: PLUS
29542: PPUSH
29543: LD_VAR 0 9
29547: PUSH
29548: LD_VAR 0 3
29552: ARRAY
29553: PPUSH
29554: CALL_OW 2
29558: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29559: LD_ADDR_VAR 0 4
29563: PUSH
29564: LD_VAR 0 4
29568: PUSH
29569: LD_VAR 0 9
29573: PUSH
29574: LD_VAR 0 3
29578: ARRAY
29579: DIFF
29580: ST_TO_ADDR
// end ;
29581: GO 29490
29583: POP
29584: POP
// if p then
29585: LD_VAR 0 11
29589: IFFALSE 29614
// result := Replace ( result , 3 , p ) ;
29591: LD_ADDR_VAR 0 2
29595: PUSH
29596: LD_VAR 0 2
29600: PPUSH
29601: LD_INT 3
29603: PPUSH
29604: LD_VAR 0 11
29608: PPUSH
29609: CALL_OW 1
29613: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
29614: LD_VAR 0 4
29618: PUSH
29619: LD_INT 6
29621: GREATER
29622: PUSH
29623: LD_VAR 0 6
29627: PUSH
29628: LD_INT 6
29630: LESS
29631: AND
29632: IFFALSE 29826
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29634: LD_ADDR_VAR 0 9
29638: PUSH
29639: LD_VAR 0 4
29643: PUSH
29644: LD_VAR 0 8
29648: PUSH
29649: LD_VAR 0 7
29653: UNION
29654: PUSH
29655: LD_VAR 0 6
29659: UNION
29660: DIFF
29661: PPUSH
29662: LD_INT 2
29664: PPUSH
29665: CALL 89813 0 2
29669: ST_TO_ADDR
// p := [ ] ;
29670: LD_ADDR_VAR 0 11
29674: PUSH
29675: EMPTY
29676: ST_TO_ADDR
// if sort then
29677: LD_VAR 0 9
29681: IFFALSE 29797
// for i = 1 to 6 - eng do
29683: LD_ADDR_VAR 0 3
29687: PUSH
29688: DOUBLE
29689: LD_INT 1
29691: DEC
29692: ST_TO_ADDR
29693: LD_INT 6
29695: PUSH
29696: LD_VAR 0 6
29700: MINUS
29701: PUSH
29702: FOR_TO
29703: IFFALSE 29795
// begin if i = sort then
29705: LD_VAR 0 3
29709: PUSH
29710: LD_VAR 0 9
29714: EQUAL
29715: IFFALSE 29719
// break ;
29717: GO 29795
// if GetClass ( i ) = 2 then
29719: LD_VAR 0 3
29723: PPUSH
29724: CALL_OW 257
29728: PUSH
29729: LD_INT 2
29731: EQUAL
29732: IFFALSE 29736
// continue ;
29734: GO 29702
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29736: LD_ADDR_VAR 0 11
29740: PUSH
29741: LD_VAR 0 11
29745: PPUSH
29746: LD_VAR 0 11
29750: PUSH
29751: LD_INT 1
29753: PLUS
29754: PPUSH
29755: LD_VAR 0 9
29759: PUSH
29760: LD_VAR 0 3
29764: ARRAY
29765: PPUSH
29766: CALL_OW 2
29770: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29771: LD_ADDR_VAR 0 4
29775: PUSH
29776: LD_VAR 0 4
29780: PUSH
29781: LD_VAR 0 9
29785: PUSH
29786: LD_VAR 0 3
29790: ARRAY
29791: DIFF
29792: ST_TO_ADDR
// end ;
29793: GO 29702
29795: POP
29796: POP
// if p then
29797: LD_VAR 0 11
29801: IFFALSE 29826
// result := Replace ( result , 2 , p ) ;
29803: LD_ADDR_VAR 0 2
29807: PUSH
29808: LD_VAR 0 2
29812: PPUSH
29813: LD_INT 2
29815: PPUSH
29816: LD_VAR 0 11
29820: PPUSH
29821: CALL_OW 1
29825: ST_TO_ADDR
// end ; exit ;
29826: GO 31214
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29828: LD_EXP 107
29832: PUSH
29833: LD_EXP 106
29837: PUSH
29838: LD_VAR 0 1
29842: ARRAY
29843: ARRAY
29844: NOT
29845: PUSH
29846: LD_EXP 80
29850: PUSH
29851: LD_VAR 0 1
29855: ARRAY
29856: PPUSH
29857: LD_INT 30
29859: PUSH
29860: LD_INT 3
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PPUSH
29867: CALL_OW 72
29871: AND
29872: PUSH
29873: LD_EXP 85
29877: PUSH
29878: LD_VAR 0 1
29882: ARRAY
29883: AND
29884: IFFALSE 30492
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29886: LD_ADDR_EXP 122
29890: PUSH
29891: LD_EXP 122
29895: PPUSH
29896: LD_VAR 0 1
29900: PPUSH
29901: LD_INT 5
29903: PPUSH
29904: CALL_OW 1
29908: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29909: LD_ADDR_VAR 0 2
29913: PUSH
29914: LD_INT 0
29916: PUSH
29917: LD_INT 0
29919: PUSH
29920: LD_INT 0
29922: PUSH
29923: LD_INT 0
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: ST_TO_ADDR
// if sci > 1 then
29932: LD_VAR 0 8
29936: PUSH
29937: LD_INT 1
29939: GREATER
29940: IFFALSE 29968
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29942: LD_ADDR_VAR 0 4
29946: PUSH
29947: LD_VAR 0 4
29951: PUSH
29952: LD_VAR 0 8
29956: PUSH
29957: LD_VAR 0 8
29961: PUSH
29962: LD_INT 1
29964: ARRAY
29965: DIFF
29966: DIFF
29967: ST_TO_ADDR
// if tmp and not sci then
29968: LD_VAR 0 4
29972: PUSH
29973: LD_VAR 0 8
29977: NOT
29978: AND
29979: IFFALSE 30048
// begin sort := SortBySkill ( tmp , 4 ) ;
29981: LD_ADDR_VAR 0 9
29985: PUSH
29986: LD_VAR 0 4
29990: PPUSH
29991: LD_INT 4
29993: PPUSH
29994: CALL 89813 0 2
29998: ST_TO_ADDR
// if sort then
29999: LD_VAR 0 9
30003: IFFALSE 30019
// p := sort [ 1 ] ;
30005: LD_ADDR_VAR 0 11
30009: PUSH
30010: LD_VAR 0 9
30014: PUSH
30015: LD_INT 1
30017: ARRAY
30018: ST_TO_ADDR
// if p then
30019: LD_VAR 0 11
30023: IFFALSE 30048
// result := Replace ( result , 4 , p ) ;
30025: LD_ADDR_VAR 0 2
30029: PUSH
30030: LD_VAR 0 2
30034: PPUSH
30035: LD_INT 4
30037: PPUSH
30038: LD_VAR 0 11
30042: PPUSH
30043: CALL_OW 1
30047: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30048: LD_ADDR_VAR 0 4
30052: PUSH
30053: LD_VAR 0 4
30057: PUSH
30058: LD_VAR 0 7
30062: DIFF
30063: ST_TO_ADDR
// if tmp and mech < 6 then
30064: LD_VAR 0 4
30068: PUSH
30069: LD_VAR 0 7
30073: PUSH
30074: LD_INT 6
30076: LESS
30077: AND
30078: IFFALSE 30266
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
30080: LD_ADDR_VAR 0 9
30084: PUSH
30085: LD_VAR 0 4
30089: PUSH
30090: LD_VAR 0 8
30094: PUSH
30095: LD_VAR 0 7
30099: UNION
30100: DIFF
30101: PPUSH
30102: LD_INT 3
30104: PPUSH
30105: CALL 89813 0 2
30109: ST_TO_ADDR
// p := [ ] ;
30110: LD_ADDR_VAR 0 11
30114: PUSH
30115: EMPTY
30116: ST_TO_ADDR
// if sort then
30117: LD_VAR 0 9
30121: IFFALSE 30237
// for i = 1 to 6 - mech do
30123: LD_ADDR_VAR 0 3
30127: PUSH
30128: DOUBLE
30129: LD_INT 1
30131: DEC
30132: ST_TO_ADDR
30133: LD_INT 6
30135: PUSH
30136: LD_VAR 0 7
30140: MINUS
30141: PUSH
30142: FOR_TO
30143: IFFALSE 30235
// begin if i = sort then
30145: LD_VAR 0 3
30149: PUSH
30150: LD_VAR 0 9
30154: EQUAL
30155: IFFALSE 30159
// break ;
30157: GO 30235
// if GetClass ( i ) = 3 then
30159: LD_VAR 0 3
30163: PPUSH
30164: CALL_OW 257
30168: PUSH
30169: LD_INT 3
30171: EQUAL
30172: IFFALSE 30176
// continue ;
30174: GO 30142
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30176: LD_ADDR_VAR 0 11
30180: PUSH
30181: LD_VAR 0 11
30185: PPUSH
30186: LD_VAR 0 11
30190: PUSH
30191: LD_INT 1
30193: PLUS
30194: PPUSH
30195: LD_VAR 0 9
30199: PUSH
30200: LD_VAR 0 3
30204: ARRAY
30205: PPUSH
30206: CALL_OW 2
30210: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30211: LD_ADDR_VAR 0 4
30215: PUSH
30216: LD_VAR 0 4
30220: PUSH
30221: LD_VAR 0 9
30225: PUSH
30226: LD_VAR 0 3
30230: ARRAY
30231: DIFF
30232: ST_TO_ADDR
// end ;
30233: GO 30142
30235: POP
30236: POP
// if p then
30237: LD_VAR 0 11
30241: IFFALSE 30266
// result := Replace ( result , 3 , p ) ;
30243: LD_ADDR_VAR 0 2
30247: PUSH
30248: LD_VAR 0 2
30252: PPUSH
30253: LD_INT 3
30255: PPUSH
30256: LD_VAR 0 11
30260: PPUSH
30261: CALL_OW 1
30265: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30266: LD_ADDR_VAR 0 4
30270: PUSH
30271: LD_VAR 0 4
30275: PUSH
30276: LD_VAR 0 6
30280: DIFF
30281: ST_TO_ADDR
// if tmp and eng < 6 then
30282: LD_VAR 0 4
30286: PUSH
30287: LD_VAR 0 6
30291: PUSH
30292: LD_INT 6
30294: LESS
30295: AND
30296: IFFALSE 30490
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30298: LD_ADDR_VAR 0 9
30302: PUSH
30303: LD_VAR 0 4
30307: PUSH
30308: LD_VAR 0 8
30312: PUSH
30313: LD_VAR 0 7
30317: UNION
30318: PUSH
30319: LD_VAR 0 6
30323: UNION
30324: DIFF
30325: PPUSH
30326: LD_INT 2
30328: PPUSH
30329: CALL 89813 0 2
30333: ST_TO_ADDR
// p := [ ] ;
30334: LD_ADDR_VAR 0 11
30338: PUSH
30339: EMPTY
30340: ST_TO_ADDR
// if sort then
30341: LD_VAR 0 9
30345: IFFALSE 30461
// for i = 1 to 6 - eng do
30347: LD_ADDR_VAR 0 3
30351: PUSH
30352: DOUBLE
30353: LD_INT 1
30355: DEC
30356: ST_TO_ADDR
30357: LD_INT 6
30359: PUSH
30360: LD_VAR 0 6
30364: MINUS
30365: PUSH
30366: FOR_TO
30367: IFFALSE 30459
// begin if i = sort then
30369: LD_VAR 0 3
30373: PUSH
30374: LD_VAR 0 9
30378: EQUAL
30379: IFFALSE 30383
// break ;
30381: GO 30459
// if GetClass ( i ) = 2 then
30383: LD_VAR 0 3
30387: PPUSH
30388: CALL_OW 257
30392: PUSH
30393: LD_INT 2
30395: EQUAL
30396: IFFALSE 30400
// continue ;
30398: GO 30366
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30400: LD_ADDR_VAR 0 11
30404: PUSH
30405: LD_VAR 0 11
30409: PPUSH
30410: LD_VAR 0 11
30414: PUSH
30415: LD_INT 1
30417: PLUS
30418: PPUSH
30419: LD_VAR 0 9
30423: PUSH
30424: LD_VAR 0 3
30428: ARRAY
30429: PPUSH
30430: CALL_OW 2
30434: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30435: LD_ADDR_VAR 0 4
30439: PUSH
30440: LD_VAR 0 4
30444: PUSH
30445: LD_VAR 0 9
30449: PUSH
30450: LD_VAR 0 3
30454: ARRAY
30455: DIFF
30456: ST_TO_ADDR
// end ;
30457: GO 30366
30459: POP
30460: POP
// if p then
30461: LD_VAR 0 11
30465: IFFALSE 30490
// result := Replace ( result , 2 , p ) ;
30467: LD_ADDR_VAR 0 2
30471: PUSH
30472: LD_VAR 0 2
30476: PPUSH
30477: LD_INT 2
30479: PPUSH
30480: LD_VAR 0 11
30484: PPUSH
30485: CALL_OW 1
30489: ST_TO_ADDR
// end ; exit ;
30490: GO 31214
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
30492: LD_EXP 107
30496: PUSH
30497: LD_EXP 106
30501: PUSH
30502: LD_VAR 0 1
30506: ARRAY
30507: ARRAY
30508: NOT
30509: PUSH
30510: LD_EXP 80
30514: PUSH
30515: LD_VAR 0 1
30519: ARRAY
30520: PPUSH
30521: LD_INT 30
30523: PUSH
30524: LD_INT 3
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PPUSH
30531: CALL_OW 72
30535: AND
30536: PUSH
30537: LD_EXP 85
30541: PUSH
30542: LD_VAR 0 1
30546: ARRAY
30547: NOT
30548: AND
30549: IFFALSE 31214
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
30551: LD_ADDR_EXP 122
30555: PUSH
30556: LD_EXP 122
30560: PPUSH
30561: LD_VAR 0 1
30565: PPUSH
30566: LD_INT 6
30568: PPUSH
30569: CALL_OW 1
30573: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30574: LD_ADDR_VAR 0 2
30578: PUSH
30579: LD_INT 0
30581: PUSH
30582: LD_INT 0
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 0
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: ST_TO_ADDR
// if sci >= 1 then
30597: LD_VAR 0 8
30601: PUSH
30602: LD_INT 1
30604: GREATEREQUAL
30605: IFFALSE 30627
// tmp := tmp diff sci [ 1 ] ;
30607: LD_ADDR_VAR 0 4
30611: PUSH
30612: LD_VAR 0 4
30616: PUSH
30617: LD_VAR 0 8
30621: PUSH
30622: LD_INT 1
30624: ARRAY
30625: DIFF
30626: ST_TO_ADDR
// if tmp and not sci then
30627: LD_VAR 0 4
30631: PUSH
30632: LD_VAR 0 8
30636: NOT
30637: AND
30638: IFFALSE 30707
// begin sort := SortBySkill ( tmp , 4 ) ;
30640: LD_ADDR_VAR 0 9
30644: PUSH
30645: LD_VAR 0 4
30649: PPUSH
30650: LD_INT 4
30652: PPUSH
30653: CALL 89813 0 2
30657: ST_TO_ADDR
// if sort then
30658: LD_VAR 0 9
30662: IFFALSE 30678
// p := sort [ 1 ] ;
30664: LD_ADDR_VAR 0 11
30668: PUSH
30669: LD_VAR 0 9
30673: PUSH
30674: LD_INT 1
30676: ARRAY
30677: ST_TO_ADDR
// if p then
30678: LD_VAR 0 11
30682: IFFALSE 30707
// result := Replace ( result , 4 , p ) ;
30684: LD_ADDR_VAR 0 2
30688: PUSH
30689: LD_VAR 0 2
30693: PPUSH
30694: LD_INT 4
30696: PPUSH
30697: LD_VAR 0 11
30701: PPUSH
30702: CALL_OW 1
30706: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30707: LD_ADDR_VAR 0 4
30711: PUSH
30712: LD_VAR 0 4
30716: PUSH
30717: LD_VAR 0 7
30721: DIFF
30722: ST_TO_ADDR
// if tmp and mech < 6 then
30723: LD_VAR 0 4
30727: PUSH
30728: LD_VAR 0 7
30732: PUSH
30733: LD_INT 6
30735: LESS
30736: AND
30737: IFFALSE 30919
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30739: LD_ADDR_VAR 0 9
30743: PUSH
30744: LD_VAR 0 4
30748: PUSH
30749: LD_VAR 0 7
30753: DIFF
30754: PPUSH
30755: LD_INT 3
30757: PPUSH
30758: CALL 89813 0 2
30762: ST_TO_ADDR
// p := [ ] ;
30763: LD_ADDR_VAR 0 11
30767: PUSH
30768: EMPTY
30769: ST_TO_ADDR
// if sort then
30770: LD_VAR 0 9
30774: IFFALSE 30890
// for i = 1 to 6 - mech do
30776: LD_ADDR_VAR 0 3
30780: PUSH
30781: DOUBLE
30782: LD_INT 1
30784: DEC
30785: ST_TO_ADDR
30786: LD_INT 6
30788: PUSH
30789: LD_VAR 0 7
30793: MINUS
30794: PUSH
30795: FOR_TO
30796: IFFALSE 30888
// begin if i = sort then
30798: LD_VAR 0 3
30802: PUSH
30803: LD_VAR 0 9
30807: EQUAL
30808: IFFALSE 30812
// break ;
30810: GO 30888
// if GetClass ( i ) = 3 then
30812: LD_VAR 0 3
30816: PPUSH
30817: CALL_OW 257
30821: PUSH
30822: LD_INT 3
30824: EQUAL
30825: IFFALSE 30829
// continue ;
30827: GO 30795
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30829: LD_ADDR_VAR 0 11
30833: PUSH
30834: LD_VAR 0 11
30838: PPUSH
30839: LD_VAR 0 11
30843: PUSH
30844: LD_INT 1
30846: PLUS
30847: PPUSH
30848: LD_VAR 0 9
30852: PUSH
30853: LD_VAR 0 3
30857: ARRAY
30858: PPUSH
30859: CALL_OW 2
30863: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30864: LD_ADDR_VAR 0 4
30868: PUSH
30869: LD_VAR 0 4
30873: PUSH
30874: LD_VAR 0 9
30878: PUSH
30879: LD_VAR 0 3
30883: ARRAY
30884: DIFF
30885: ST_TO_ADDR
// end ;
30886: GO 30795
30888: POP
30889: POP
// if p then
30890: LD_VAR 0 11
30894: IFFALSE 30919
// result := Replace ( result , 3 , p ) ;
30896: LD_ADDR_VAR 0 2
30900: PUSH
30901: LD_VAR 0 2
30905: PPUSH
30906: LD_INT 3
30908: PPUSH
30909: LD_VAR 0 11
30913: PPUSH
30914: CALL_OW 1
30918: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30919: LD_ADDR_VAR 0 4
30923: PUSH
30924: LD_VAR 0 4
30928: PUSH
30929: LD_VAR 0 6
30933: DIFF
30934: ST_TO_ADDR
// if tmp and eng < 4 then
30935: LD_VAR 0 4
30939: PUSH
30940: LD_VAR 0 6
30944: PUSH
30945: LD_INT 4
30947: LESS
30948: AND
30949: IFFALSE 31139
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30951: LD_ADDR_VAR 0 9
30955: PUSH
30956: LD_VAR 0 4
30960: PUSH
30961: LD_VAR 0 7
30965: PUSH
30966: LD_VAR 0 6
30970: UNION
30971: DIFF
30972: PPUSH
30973: LD_INT 2
30975: PPUSH
30976: CALL 89813 0 2
30980: ST_TO_ADDR
// p := [ ] ;
30981: LD_ADDR_VAR 0 11
30985: PUSH
30986: EMPTY
30987: ST_TO_ADDR
// if sort then
30988: LD_VAR 0 9
30992: IFFALSE 31108
// for i = 1 to 4 - eng do
30994: LD_ADDR_VAR 0 3
30998: PUSH
30999: DOUBLE
31000: LD_INT 1
31002: DEC
31003: ST_TO_ADDR
31004: LD_INT 4
31006: PUSH
31007: LD_VAR 0 6
31011: MINUS
31012: PUSH
31013: FOR_TO
31014: IFFALSE 31106
// begin if i = sort then
31016: LD_VAR 0 3
31020: PUSH
31021: LD_VAR 0 9
31025: EQUAL
31026: IFFALSE 31030
// break ;
31028: GO 31106
// if GetClass ( i ) = 2 then
31030: LD_VAR 0 3
31034: PPUSH
31035: CALL_OW 257
31039: PUSH
31040: LD_INT 2
31042: EQUAL
31043: IFFALSE 31047
// continue ;
31045: GO 31013
// p := Insert ( p , p + 1 , sort [ i ] ) ;
31047: LD_ADDR_VAR 0 11
31051: PUSH
31052: LD_VAR 0 11
31056: PPUSH
31057: LD_VAR 0 11
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PPUSH
31066: LD_VAR 0 9
31070: PUSH
31071: LD_VAR 0 3
31075: ARRAY
31076: PPUSH
31077: CALL_OW 2
31081: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
31082: LD_ADDR_VAR 0 4
31086: PUSH
31087: LD_VAR 0 4
31091: PUSH
31092: LD_VAR 0 9
31096: PUSH
31097: LD_VAR 0 3
31101: ARRAY
31102: DIFF
31103: ST_TO_ADDR
// end ;
31104: GO 31013
31106: POP
31107: POP
// if p then
31108: LD_VAR 0 11
31112: IFFALSE 31137
// result := Replace ( result , 2 , p ) ;
31114: LD_ADDR_VAR 0 2
31118: PUSH
31119: LD_VAR 0 2
31123: PPUSH
31124: LD_INT 2
31126: PPUSH
31127: LD_VAR 0 11
31131: PPUSH
31132: CALL_OW 1
31136: ST_TO_ADDR
// end else
31137: GO 31183
// for i = eng downto 5 do
31139: LD_ADDR_VAR 0 3
31143: PUSH
31144: DOUBLE
31145: LD_VAR 0 6
31149: INC
31150: ST_TO_ADDR
31151: LD_INT 5
31153: PUSH
31154: FOR_DOWNTO
31155: IFFALSE 31181
// tmp := tmp union eng [ i ] ;
31157: LD_ADDR_VAR 0 4
31161: PUSH
31162: LD_VAR 0 4
31166: PUSH
31167: LD_VAR 0 6
31171: PUSH
31172: LD_VAR 0 3
31176: ARRAY
31177: UNION
31178: ST_TO_ADDR
31179: GO 31154
31181: POP
31182: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
31183: LD_ADDR_VAR 0 2
31187: PUSH
31188: LD_VAR 0 2
31192: PPUSH
31193: LD_INT 1
31195: PPUSH
31196: LD_VAR 0 4
31200: PUSH
31201: LD_VAR 0 5
31205: DIFF
31206: PPUSH
31207: CALL_OW 1
31211: ST_TO_ADDR
// exit ;
31212: GO 31214
// end ; end ;
31214: LD_VAR 0 2
31218: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
31219: LD_INT 0
31221: PPUSH
31222: PPUSH
31223: PPUSH
// if not mc_bases then
31224: LD_EXP 80
31228: NOT
31229: IFFALSE 31233
// exit ;
31231: GO 31375
// for i = 1 to mc_bases do
31233: LD_ADDR_VAR 0 2
31237: PUSH
31238: DOUBLE
31239: LD_INT 1
31241: DEC
31242: ST_TO_ADDR
31243: LD_EXP 80
31247: PUSH
31248: FOR_TO
31249: IFFALSE 31366
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
31251: LD_ADDR_VAR 0 3
31255: PUSH
31256: LD_EXP 80
31260: PUSH
31261: LD_VAR 0 2
31265: ARRAY
31266: PPUSH
31267: LD_INT 21
31269: PUSH
31270: LD_INT 3
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 3
31279: PUSH
31280: LD_INT 2
31282: PUSH
31283: LD_INT 30
31285: PUSH
31286: LD_INT 29
31288: PUSH
31289: EMPTY
31290: LIST
31291: LIST
31292: PUSH
31293: LD_INT 30
31295: PUSH
31296: LD_INT 30
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: LIST
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 3
31314: PUSH
31315: LD_INT 24
31317: PUSH
31318: LD_INT 1000
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: LIST
31333: PPUSH
31334: CALL_OW 72
31338: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
31339: LD_ADDR_EXP 81
31343: PUSH
31344: LD_EXP 81
31348: PPUSH
31349: LD_VAR 0 2
31353: PPUSH
31354: LD_VAR 0 3
31358: PPUSH
31359: CALL_OW 1
31363: ST_TO_ADDR
// end ;
31364: GO 31248
31366: POP
31367: POP
// RaiseSailEvent ( 101 ) ;
31368: LD_INT 101
31370: PPUSH
31371: CALL_OW 427
// end ;
31375: LD_VAR 0 1
31379: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
31380: LD_INT 0
31382: PPUSH
31383: PPUSH
31384: PPUSH
31385: PPUSH
31386: PPUSH
31387: PPUSH
31388: PPUSH
// if not mc_bases then
31389: LD_EXP 80
31393: NOT
31394: IFFALSE 31398
// exit ;
31396: GO 31960
// for i = 1 to mc_bases do
31398: LD_ADDR_VAR 0 2
31402: PUSH
31403: DOUBLE
31404: LD_INT 1
31406: DEC
31407: ST_TO_ADDR
31408: LD_EXP 80
31412: PUSH
31413: FOR_TO
31414: IFFALSE 31951
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
31416: LD_ADDR_VAR 0 5
31420: PUSH
31421: LD_EXP 80
31425: PUSH
31426: LD_VAR 0 2
31430: ARRAY
31431: PUSH
31432: LD_EXP 109
31436: PUSH
31437: LD_VAR 0 2
31441: ARRAY
31442: UNION
31443: PPUSH
31444: LD_INT 21
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 1
31456: PUSH
31457: LD_INT 3
31459: PUSH
31460: LD_INT 54
31462: PUSH
31463: EMPTY
31464: LIST
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 3
31472: PUSH
31473: LD_INT 24
31475: PUSH
31476: LD_INT 1000
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: LIST
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PPUSH
31496: CALL_OW 72
31500: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
31501: LD_ADDR_VAR 0 6
31505: PUSH
31506: LD_EXP 80
31510: PUSH
31511: LD_VAR 0 2
31515: ARRAY
31516: PPUSH
31517: LD_INT 21
31519: PUSH
31520: LD_INT 1
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 1
31529: PUSH
31530: LD_INT 3
31532: PUSH
31533: LD_INT 54
31535: PUSH
31536: EMPTY
31537: LIST
31538: PUSH
31539: EMPTY
31540: LIST
31541: LIST
31542: PUSH
31543: LD_INT 3
31545: PUSH
31546: LD_INT 24
31548: PUSH
31549: LD_INT 250
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: EMPTY
31561: LIST
31562: LIST
31563: LIST
31564: PUSH
31565: EMPTY
31566: LIST
31567: LIST
31568: PPUSH
31569: CALL_OW 72
31573: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
31574: LD_ADDR_VAR 0 7
31578: PUSH
31579: LD_VAR 0 5
31583: PUSH
31584: LD_VAR 0 6
31588: DIFF
31589: ST_TO_ADDR
// if not need_heal_1 then
31590: LD_VAR 0 6
31594: NOT
31595: IFFALSE 31628
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
31597: LD_ADDR_EXP 83
31601: PUSH
31602: LD_EXP 83
31606: PPUSH
31607: LD_VAR 0 2
31611: PUSH
31612: LD_INT 1
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PPUSH
31619: EMPTY
31620: PPUSH
31621: CALL 58560 0 3
31625: ST_TO_ADDR
31626: GO 31698
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
31628: LD_ADDR_EXP 83
31632: PUSH
31633: LD_EXP 83
31637: PPUSH
31638: LD_VAR 0 2
31642: PUSH
31643: LD_INT 1
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PPUSH
31650: LD_EXP 83
31654: PUSH
31655: LD_VAR 0 2
31659: ARRAY
31660: PUSH
31661: LD_INT 1
31663: ARRAY
31664: PPUSH
31665: LD_INT 3
31667: PUSH
31668: LD_INT 24
31670: PUSH
31671: LD_INT 1000
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PPUSH
31682: CALL_OW 72
31686: PUSH
31687: LD_VAR 0 6
31691: UNION
31692: PPUSH
31693: CALL 58560 0 3
31697: ST_TO_ADDR
// if not need_heal_2 then
31698: LD_VAR 0 7
31702: NOT
31703: IFFALSE 31736
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
31705: LD_ADDR_EXP 83
31709: PUSH
31710: LD_EXP 83
31714: PPUSH
31715: LD_VAR 0 2
31719: PUSH
31720: LD_INT 2
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: PPUSH
31727: EMPTY
31728: PPUSH
31729: CALL 58560 0 3
31733: ST_TO_ADDR
31734: GO 31768
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31736: LD_ADDR_EXP 83
31740: PUSH
31741: LD_EXP 83
31745: PPUSH
31746: LD_VAR 0 2
31750: PUSH
31751: LD_INT 2
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PPUSH
31758: LD_VAR 0 7
31762: PPUSH
31763: CALL 58560 0 3
31767: ST_TO_ADDR
// if need_heal_2 then
31768: LD_VAR 0 7
31772: IFFALSE 31933
// for j in need_heal_2 do
31774: LD_ADDR_VAR 0 3
31778: PUSH
31779: LD_VAR 0 7
31783: PUSH
31784: FOR_IN
31785: IFFALSE 31931
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31787: LD_ADDR_VAR 0 5
31791: PUSH
31792: LD_EXP 80
31796: PUSH
31797: LD_VAR 0 2
31801: ARRAY
31802: PPUSH
31803: LD_INT 2
31805: PUSH
31806: LD_INT 30
31808: PUSH
31809: LD_INT 6
31811: PUSH
31812: EMPTY
31813: LIST
31814: LIST
31815: PUSH
31816: LD_INT 30
31818: PUSH
31819: LD_INT 7
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 30
31828: PUSH
31829: LD_INT 8
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 30
31838: PUSH
31839: LD_INT 0
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: LD_INT 30
31848: PUSH
31849: LD_INT 1
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: PPUSH
31864: CALL_OW 72
31868: ST_TO_ADDR
// if tmp then
31869: LD_VAR 0 5
31873: IFFALSE 31929
// begin k := NearestUnitToUnit ( tmp , j ) ;
31875: LD_ADDR_VAR 0 4
31879: PUSH
31880: LD_VAR 0 5
31884: PPUSH
31885: LD_VAR 0 3
31889: PPUSH
31890: CALL_OW 74
31894: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31895: LD_VAR 0 3
31899: PPUSH
31900: LD_VAR 0 4
31904: PPUSH
31905: CALL_OW 296
31909: PUSH
31910: LD_INT 5
31912: GREATER
31913: IFFALSE 31929
// ComMoveToNearbyEntrance ( j , k ) ;
31915: LD_VAR 0 3
31919: PPUSH
31920: LD_VAR 0 4
31924: PPUSH
31925: CALL 92186 0 2
// end ; end ;
31929: GO 31784
31931: POP
31932: POP
// if not need_heal_1 and not need_heal_2 then
31933: LD_VAR 0 6
31937: NOT
31938: PUSH
31939: LD_VAR 0 7
31943: NOT
31944: AND
31945: IFFALSE 31949
// continue ;
31947: GO 31413
// end ;
31949: GO 31413
31951: POP
31952: POP
// RaiseSailEvent ( 102 ) ;
31953: LD_INT 102
31955: PPUSH
31956: CALL_OW 427
// end ;
31960: LD_VAR 0 1
31964: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31965: LD_INT 0
31967: PPUSH
31968: PPUSH
31969: PPUSH
31970: PPUSH
31971: PPUSH
31972: PPUSH
31973: PPUSH
31974: PPUSH
// if not mc_bases then
31975: LD_EXP 80
31979: NOT
31980: IFFALSE 31984
// exit ;
31982: GO 32895
// for i = 1 to mc_bases do
31984: LD_ADDR_VAR 0 2
31988: PUSH
31989: DOUBLE
31990: LD_INT 1
31992: DEC
31993: ST_TO_ADDR
31994: LD_EXP 80
31998: PUSH
31999: FOR_TO
32000: IFFALSE 32893
// begin if not mc_building_need_repair [ i ] then
32002: LD_EXP 81
32006: PUSH
32007: LD_VAR 0 2
32011: ARRAY
32012: NOT
32013: IFFALSE 32198
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
32015: LD_ADDR_VAR 0 6
32019: PUSH
32020: LD_EXP 99
32024: PUSH
32025: LD_VAR 0 2
32029: ARRAY
32030: PPUSH
32031: LD_INT 3
32033: PUSH
32034: LD_INT 24
32036: PUSH
32037: LD_INT 1000
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: LD_INT 2
32050: PUSH
32051: LD_INT 34
32053: PUSH
32054: LD_INT 13
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 34
32063: PUSH
32064: LD_INT 52
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 34
32073: PUSH
32074: LD_INT 88
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PPUSH
32091: CALL_OW 72
32095: ST_TO_ADDR
// if cranes then
32096: LD_VAR 0 6
32100: IFFALSE 32162
// for j in cranes do
32102: LD_ADDR_VAR 0 3
32106: PUSH
32107: LD_VAR 0 6
32111: PUSH
32112: FOR_IN
32113: IFFALSE 32160
// if not IsInArea ( j , mc_parking [ i ] ) then
32115: LD_VAR 0 3
32119: PPUSH
32120: LD_EXP 104
32124: PUSH
32125: LD_VAR 0 2
32129: ARRAY
32130: PPUSH
32131: CALL_OW 308
32135: NOT
32136: IFFALSE 32158
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32138: LD_VAR 0 3
32142: PPUSH
32143: LD_EXP 104
32147: PUSH
32148: LD_VAR 0 2
32152: ARRAY
32153: PPUSH
32154: CALL_OW 113
32158: GO 32112
32160: POP
32161: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
32162: LD_ADDR_EXP 82
32166: PUSH
32167: LD_EXP 82
32171: PPUSH
32172: LD_VAR 0 2
32176: PPUSH
32177: EMPTY
32178: PPUSH
32179: CALL_OW 1
32183: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
32184: LD_VAR 0 2
32188: PPUSH
32189: LD_INT 101
32191: PPUSH
32192: CALL 27038 0 2
// continue ;
32196: GO 31999
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
32198: LD_ADDR_EXP 86
32202: PUSH
32203: LD_EXP 86
32207: PPUSH
32208: LD_VAR 0 2
32212: PPUSH
32213: EMPTY
32214: PPUSH
32215: CALL_OW 1
32219: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32220: LD_VAR 0 2
32224: PPUSH
32225: LD_INT 103
32227: PPUSH
32228: CALL 27038 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
32232: LD_ADDR_VAR 0 5
32236: PUSH
32237: LD_EXP 80
32241: PUSH
32242: LD_VAR 0 2
32246: ARRAY
32247: PUSH
32248: LD_EXP 109
32252: PUSH
32253: LD_VAR 0 2
32257: ARRAY
32258: UNION
32259: PPUSH
32260: LD_INT 2
32262: PUSH
32263: LD_INT 25
32265: PUSH
32266: LD_INT 2
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 25
32275: PUSH
32276: LD_INT 16
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: LIST
32287: PUSH
32288: EMPTY
32289: LIST
32290: PPUSH
32291: CALL_OW 72
32295: ST_TO_ADDR
// if mc_need_heal [ i ] then
32296: LD_EXP 83
32300: PUSH
32301: LD_VAR 0 2
32305: ARRAY
32306: IFFALSE 32350
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
32308: LD_ADDR_VAR 0 5
32312: PUSH
32313: LD_VAR 0 5
32317: PUSH
32318: LD_EXP 83
32322: PUSH
32323: LD_VAR 0 2
32327: ARRAY
32328: PUSH
32329: LD_INT 1
32331: ARRAY
32332: PUSH
32333: LD_EXP 83
32337: PUSH
32338: LD_VAR 0 2
32342: ARRAY
32343: PUSH
32344: LD_INT 2
32346: ARRAY
32347: UNION
32348: DIFF
32349: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
32350: LD_ADDR_VAR 0 6
32354: PUSH
32355: LD_EXP 99
32359: PUSH
32360: LD_VAR 0 2
32364: ARRAY
32365: PPUSH
32366: LD_INT 2
32368: PUSH
32369: LD_INT 34
32371: PUSH
32372: LD_INT 13
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 34
32381: PUSH
32382: LD_INT 52
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 34
32391: PUSH
32392: LD_INT 88
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: EMPTY
32400: LIST
32401: LIST
32402: LIST
32403: LIST
32404: PPUSH
32405: CALL_OW 72
32409: ST_TO_ADDR
// if cranes then
32410: LD_VAR 0 6
32414: IFFALSE 32582
// begin for j in cranes do
32416: LD_ADDR_VAR 0 3
32420: PUSH
32421: LD_VAR 0 6
32425: PUSH
32426: FOR_IN
32427: IFFALSE 32580
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
32429: LD_VAR 0 3
32433: PPUSH
32434: CALL_OW 256
32438: PUSH
32439: LD_INT 1000
32441: EQUAL
32442: PUSH
32443: LD_VAR 0 3
32447: PPUSH
32448: CALL_OW 314
32452: NOT
32453: AND
32454: IFFALSE 32520
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
32456: LD_ADDR_VAR 0 8
32460: PUSH
32461: LD_EXP 81
32465: PUSH
32466: LD_VAR 0 2
32470: ARRAY
32471: PPUSH
32472: LD_VAR 0 3
32476: PPUSH
32477: CALL_OW 74
32481: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
32482: LD_VAR 0 8
32486: PPUSH
32487: LD_INT 16
32489: PPUSH
32490: CALL 61525 0 2
32494: PUSH
32495: LD_INT 4
32497: ARRAY
32498: PUSH
32499: LD_INT 10
32501: LESS
32502: IFFALSE 32518
// ComRepairBuilding ( j , to_repair ) ;
32504: LD_VAR 0 3
32508: PPUSH
32509: LD_VAR 0 8
32513: PPUSH
32514: CALL_OW 130
// end else
32518: GO 32578
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
32520: LD_VAR 0 3
32524: PPUSH
32525: CALL_OW 256
32529: PUSH
32530: LD_INT 500
32532: LESS
32533: PUSH
32534: LD_VAR 0 3
32538: PPUSH
32539: LD_EXP 104
32543: PUSH
32544: LD_VAR 0 2
32548: ARRAY
32549: PPUSH
32550: CALL_OW 308
32554: NOT
32555: AND
32556: IFFALSE 32578
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32558: LD_VAR 0 3
32562: PPUSH
32563: LD_EXP 104
32567: PUSH
32568: LD_VAR 0 2
32572: ARRAY
32573: PPUSH
32574: CALL_OW 113
// end ;
32578: GO 32426
32580: POP
32581: POP
// end ; if tmp > 3 then
32582: LD_VAR 0 5
32586: PUSH
32587: LD_INT 3
32589: GREATER
32590: IFFALSE 32610
// tmp := ShrinkArray ( tmp , 4 ) ;
32592: LD_ADDR_VAR 0 5
32596: PUSH
32597: LD_VAR 0 5
32601: PPUSH
32602: LD_INT 4
32604: PPUSH
32605: CALL 91624 0 2
32609: ST_TO_ADDR
// if not tmp then
32610: LD_VAR 0 5
32614: NOT
32615: IFFALSE 32619
// continue ;
32617: GO 31999
// for j in tmp do
32619: LD_ADDR_VAR 0 3
32623: PUSH
32624: LD_VAR 0 5
32628: PUSH
32629: FOR_IN
32630: IFFALSE 32889
// begin if IsInUnit ( j ) then
32632: LD_VAR 0 3
32636: PPUSH
32637: CALL_OW 310
32641: IFFALSE 32652
// ComExitBuilding ( j ) ;
32643: LD_VAR 0 3
32647: PPUSH
32648: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
32652: LD_VAR 0 3
32656: PUSH
32657: LD_EXP 82
32661: PUSH
32662: LD_VAR 0 2
32666: ARRAY
32667: IN
32668: NOT
32669: IFFALSE 32727
// begin SetTag ( j , 101 ) ;
32671: LD_VAR 0 3
32675: PPUSH
32676: LD_INT 101
32678: PPUSH
32679: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
32683: LD_ADDR_EXP 82
32687: PUSH
32688: LD_EXP 82
32692: PPUSH
32693: LD_VAR 0 2
32697: PUSH
32698: LD_EXP 82
32702: PUSH
32703: LD_VAR 0 2
32707: ARRAY
32708: PUSH
32709: LD_INT 1
32711: PLUS
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PPUSH
32717: LD_VAR 0 3
32721: PPUSH
32722: CALL 58560 0 3
32726: ST_TO_ADDR
// end ; wait ( 1 ) ;
32727: LD_INT 1
32729: PPUSH
32730: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32734: LD_ADDR_VAR 0 7
32738: PUSH
32739: LD_EXP 81
32743: PUSH
32744: LD_VAR 0 2
32748: ARRAY
32749: ST_TO_ADDR
// if mc_scan [ i ] then
32750: LD_EXP 103
32754: PUSH
32755: LD_VAR 0 2
32759: ARRAY
32760: IFFALSE 32822
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32762: LD_ADDR_VAR 0 7
32766: PUSH
32767: LD_EXP 81
32771: PUSH
32772: LD_VAR 0 2
32776: ARRAY
32777: PPUSH
32778: LD_INT 3
32780: PUSH
32781: LD_INT 30
32783: PUSH
32784: LD_INT 32
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 30
32793: PUSH
32794: LD_INT 33
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 30
32803: PUSH
32804: LD_INT 31
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: LIST
32815: LIST
32816: PPUSH
32817: CALL_OW 72
32821: ST_TO_ADDR
// if not to_repair_tmp then
32822: LD_VAR 0 7
32826: NOT
32827: IFFALSE 32831
// continue ;
32829: GO 32629
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32831: LD_ADDR_VAR 0 8
32835: PUSH
32836: LD_VAR 0 7
32840: PPUSH
32841: LD_VAR 0 3
32845: PPUSH
32846: CALL_OW 74
32850: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32851: LD_VAR 0 8
32855: PPUSH
32856: LD_INT 16
32858: PPUSH
32859: CALL 61525 0 2
32863: PUSH
32864: LD_INT 4
32866: ARRAY
32867: PUSH
32868: LD_INT 14
32870: LESS
32871: IFFALSE 32887
// ComRepairBuilding ( j , to_repair ) ;
32873: LD_VAR 0 3
32877: PPUSH
32878: LD_VAR 0 8
32882: PPUSH
32883: CALL_OW 130
// end ;
32887: GO 32629
32889: POP
32890: POP
// end ;
32891: GO 31999
32893: POP
32894: POP
// end ;
32895: LD_VAR 0 1
32899: RET
// export function MC_Heal ; var i , j , tmp ; begin
32900: LD_INT 0
32902: PPUSH
32903: PPUSH
32904: PPUSH
32905: PPUSH
// if not mc_bases then
32906: LD_EXP 80
32910: NOT
32911: IFFALSE 32915
// exit ;
32913: GO 33317
// for i = 1 to mc_bases do
32915: LD_ADDR_VAR 0 2
32919: PUSH
32920: DOUBLE
32921: LD_INT 1
32923: DEC
32924: ST_TO_ADDR
32925: LD_EXP 80
32929: PUSH
32930: FOR_TO
32931: IFFALSE 33315
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32933: LD_EXP 83
32937: PUSH
32938: LD_VAR 0 2
32942: ARRAY
32943: PUSH
32944: LD_INT 1
32946: ARRAY
32947: NOT
32948: PUSH
32949: LD_EXP 83
32953: PUSH
32954: LD_VAR 0 2
32958: ARRAY
32959: PUSH
32960: LD_INT 2
32962: ARRAY
32963: NOT
32964: AND
32965: IFFALSE 33003
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32967: LD_ADDR_EXP 84
32971: PUSH
32972: LD_EXP 84
32976: PPUSH
32977: LD_VAR 0 2
32981: PPUSH
32982: EMPTY
32983: PPUSH
32984: CALL_OW 1
32988: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32989: LD_VAR 0 2
32993: PPUSH
32994: LD_INT 102
32996: PPUSH
32997: CALL 27038 0 2
// continue ;
33001: GO 32930
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
33003: LD_ADDR_VAR 0 4
33007: PUSH
33008: LD_EXP 80
33012: PUSH
33013: LD_VAR 0 2
33017: ARRAY
33018: PPUSH
33019: LD_INT 25
33021: PUSH
33022: LD_INT 4
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PPUSH
33029: CALL_OW 72
33033: ST_TO_ADDR
// if not tmp then
33034: LD_VAR 0 4
33038: NOT
33039: IFFALSE 33043
// continue ;
33041: GO 32930
// if mc_taming [ i ] then
33043: LD_EXP 111
33047: PUSH
33048: LD_VAR 0 2
33052: ARRAY
33053: IFFALSE 33077
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33055: LD_ADDR_EXP 111
33059: PUSH
33060: LD_EXP 111
33064: PPUSH
33065: LD_VAR 0 2
33069: PPUSH
33070: EMPTY
33071: PPUSH
33072: CALL_OW 1
33076: ST_TO_ADDR
// for j in tmp do
33077: LD_ADDR_VAR 0 3
33081: PUSH
33082: LD_VAR 0 4
33086: PUSH
33087: FOR_IN
33088: IFFALSE 33311
// begin if IsInUnit ( j ) then
33090: LD_VAR 0 3
33094: PPUSH
33095: CALL_OW 310
33099: IFFALSE 33110
// ComExitBuilding ( j ) ;
33101: LD_VAR 0 3
33105: PPUSH
33106: CALL_OW 122
// if not j in mc_healers [ i ] then
33110: LD_VAR 0 3
33114: PUSH
33115: LD_EXP 84
33119: PUSH
33120: LD_VAR 0 2
33124: ARRAY
33125: IN
33126: NOT
33127: IFFALSE 33173
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
33129: LD_ADDR_EXP 84
33133: PUSH
33134: LD_EXP 84
33138: PPUSH
33139: LD_VAR 0 2
33143: PUSH
33144: LD_EXP 84
33148: PUSH
33149: LD_VAR 0 2
33153: ARRAY
33154: PUSH
33155: LD_INT 1
33157: PLUS
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PPUSH
33163: LD_VAR 0 3
33167: PPUSH
33168: CALL 58560 0 3
33172: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
33173: LD_VAR 0 3
33177: PPUSH
33178: CALL_OW 110
33182: PUSH
33183: LD_INT 102
33185: NONEQUAL
33186: IFFALSE 33200
// SetTag ( j , 102 ) ;
33188: LD_VAR 0 3
33192: PPUSH
33193: LD_INT 102
33195: PPUSH
33196: CALL_OW 109
// Wait ( 3 ) ;
33200: LD_INT 3
33202: PPUSH
33203: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
33207: LD_EXP 83
33211: PUSH
33212: LD_VAR 0 2
33216: ARRAY
33217: PUSH
33218: LD_INT 1
33220: ARRAY
33221: IFFALSE 33253
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
33223: LD_VAR 0 3
33227: PPUSH
33228: LD_EXP 83
33232: PUSH
33233: LD_VAR 0 2
33237: ARRAY
33238: PUSH
33239: LD_INT 1
33241: ARRAY
33242: PUSH
33243: LD_INT 1
33245: ARRAY
33246: PPUSH
33247: CALL_OW 128
33251: GO 33309
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
33253: LD_VAR 0 3
33257: PPUSH
33258: CALL_OW 314
33262: NOT
33263: PUSH
33264: LD_EXP 83
33268: PUSH
33269: LD_VAR 0 2
33273: ARRAY
33274: PUSH
33275: LD_INT 2
33277: ARRAY
33278: AND
33279: IFFALSE 33309
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
33281: LD_VAR 0 3
33285: PPUSH
33286: LD_EXP 83
33290: PUSH
33291: LD_VAR 0 2
33295: ARRAY
33296: PUSH
33297: LD_INT 2
33299: ARRAY
33300: PUSH
33301: LD_INT 1
33303: ARRAY
33304: PPUSH
33305: CALL_OW 128
// end ;
33309: GO 33087
33311: POP
33312: POP
// end ;
33313: GO 32930
33315: POP
33316: POP
// end ;
33317: LD_VAR 0 1
33321: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
33322: LD_INT 0
33324: PPUSH
33325: PPUSH
33326: PPUSH
33327: PPUSH
33328: PPUSH
33329: PPUSH
// if not mc_bases then
33330: LD_EXP 80
33334: NOT
33335: IFFALSE 33339
// exit ;
33337: GO 34502
// for i = 1 to mc_bases do
33339: LD_ADDR_VAR 0 2
33343: PUSH
33344: DOUBLE
33345: LD_INT 1
33347: DEC
33348: ST_TO_ADDR
33349: LD_EXP 80
33353: PUSH
33354: FOR_TO
33355: IFFALSE 34500
// begin if mc_scan [ i ] then
33357: LD_EXP 103
33361: PUSH
33362: LD_VAR 0 2
33366: ARRAY
33367: IFFALSE 33371
// continue ;
33369: GO 33354
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
33371: LD_EXP 85
33375: PUSH
33376: LD_VAR 0 2
33380: ARRAY
33381: NOT
33382: PUSH
33383: LD_EXP 87
33387: PUSH
33388: LD_VAR 0 2
33392: ARRAY
33393: NOT
33394: AND
33395: PUSH
33396: LD_EXP 86
33400: PUSH
33401: LD_VAR 0 2
33405: ARRAY
33406: AND
33407: IFFALSE 33445
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
33409: LD_ADDR_EXP 86
33413: PUSH
33414: LD_EXP 86
33418: PPUSH
33419: LD_VAR 0 2
33423: PPUSH
33424: EMPTY
33425: PPUSH
33426: CALL_OW 1
33430: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
33431: LD_VAR 0 2
33435: PPUSH
33436: LD_INT 103
33438: PPUSH
33439: CALL 27038 0 2
// continue ;
33443: GO 33354
// end ; if mc_construct_list [ i ] then
33445: LD_EXP 87
33449: PUSH
33450: LD_VAR 0 2
33454: ARRAY
33455: IFFALSE 33675
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33457: LD_ADDR_VAR 0 5
33461: PUSH
33462: LD_EXP 80
33466: PUSH
33467: LD_VAR 0 2
33471: ARRAY
33472: PPUSH
33473: LD_INT 25
33475: PUSH
33476: LD_INT 2
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PPUSH
33483: CALL_OW 72
33487: PUSH
33488: LD_EXP 82
33492: PUSH
33493: LD_VAR 0 2
33497: ARRAY
33498: DIFF
33499: ST_TO_ADDR
// if not tmp then
33500: LD_VAR 0 5
33504: NOT
33505: IFFALSE 33509
// continue ;
33507: GO 33354
// for j in tmp do
33509: LD_ADDR_VAR 0 3
33513: PUSH
33514: LD_VAR 0 5
33518: PUSH
33519: FOR_IN
33520: IFFALSE 33671
// begin if not mc_builders [ i ] then
33522: LD_EXP 86
33526: PUSH
33527: LD_VAR 0 2
33531: ARRAY
33532: NOT
33533: IFFALSE 33591
// begin SetTag ( j , 103 ) ;
33535: LD_VAR 0 3
33539: PPUSH
33540: LD_INT 103
33542: PPUSH
33543: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33547: LD_ADDR_EXP 86
33551: PUSH
33552: LD_EXP 86
33556: PPUSH
33557: LD_VAR 0 2
33561: PUSH
33562: LD_EXP 86
33566: PUSH
33567: LD_VAR 0 2
33571: ARRAY
33572: PUSH
33573: LD_INT 1
33575: PLUS
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PPUSH
33581: LD_VAR 0 3
33585: PPUSH
33586: CALL 58560 0 3
33590: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33591: LD_VAR 0 3
33595: PPUSH
33596: CALL_OW 310
33600: IFFALSE 33611
// ComExitBuilding ( j ) ;
33602: LD_VAR 0 3
33606: PPUSH
33607: CALL_OW 122
// wait ( 3 ) ;
33611: LD_INT 3
33613: PPUSH
33614: CALL_OW 67
// if not mc_construct_list [ i ] then
33618: LD_EXP 87
33622: PUSH
33623: LD_VAR 0 2
33627: ARRAY
33628: NOT
33629: IFFALSE 33633
// break ;
33631: GO 33671
// if not HasTask ( j ) then
33633: LD_VAR 0 3
33637: PPUSH
33638: CALL_OW 314
33642: NOT
33643: IFFALSE 33669
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
33645: LD_VAR 0 3
33649: PPUSH
33650: LD_EXP 87
33654: PUSH
33655: LD_VAR 0 2
33659: ARRAY
33660: PUSH
33661: LD_INT 1
33663: ARRAY
33664: PPUSH
33665: CALL 61798 0 2
// end ;
33669: GO 33519
33671: POP
33672: POP
// end else
33673: GO 34498
// if mc_build_list [ i ] then
33675: LD_EXP 85
33679: PUSH
33680: LD_VAR 0 2
33684: ARRAY
33685: IFFALSE 34498
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
33687: LD_EXP 85
33691: PUSH
33692: LD_VAR 0 2
33696: ARRAY
33697: PUSH
33698: LD_INT 1
33700: ARRAY
33701: PUSH
33702: LD_INT 1
33704: ARRAY
33705: PPUSH
33706: CALL 61622 0 1
33710: PUSH
33711: LD_EXP 80
33715: PUSH
33716: LD_VAR 0 2
33720: ARRAY
33721: PPUSH
33722: LD_INT 2
33724: PUSH
33725: LD_INT 30
33727: PUSH
33728: LD_INT 2
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 30
33737: PUSH
33738: LD_INT 3
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: LIST
33749: PPUSH
33750: CALL_OW 72
33754: NOT
33755: AND
33756: IFFALSE 33861
// begin for j = 1 to mc_build_list [ i ] do
33758: LD_ADDR_VAR 0 3
33762: PUSH
33763: DOUBLE
33764: LD_INT 1
33766: DEC
33767: ST_TO_ADDR
33768: LD_EXP 85
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: PUSH
33779: FOR_TO
33780: IFFALSE 33859
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33782: LD_EXP 85
33786: PUSH
33787: LD_VAR 0 2
33791: ARRAY
33792: PUSH
33793: LD_VAR 0 3
33797: ARRAY
33798: PUSH
33799: LD_INT 1
33801: ARRAY
33802: PUSH
33803: LD_INT 2
33805: EQUAL
33806: IFFALSE 33857
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33808: LD_ADDR_EXP 85
33812: PUSH
33813: LD_EXP 85
33817: PPUSH
33818: LD_VAR 0 2
33822: PPUSH
33823: LD_EXP 85
33827: PUSH
33828: LD_VAR 0 2
33832: ARRAY
33833: PPUSH
33834: LD_VAR 0 3
33838: PPUSH
33839: LD_INT 1
33841: PPUSH
33842: LD_INT 0
33844: PPUSH
33845: CALL 57978 0 4
33849: PPUSH
33850: CALL_OW 1
33854: ST_TO_ADDR
// break ;
33855: GO 33859
// end ;
33857: GO 33779
33859: POP
33860: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33861: LD_ADDR_VAR 0 6
33865: PUSH
33866: LD_EXP 80
33870: PUSH
33871: LD_VAR 0 2
33875: ARRAY
33876: PPUSH
33877: LD_INT 2
33879: PUSH
33880: LD_INT 30
33882: PUSH
33883: LD_INT 0
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: PUSH
33890: LD_INT 30
33892: PUSH
33893: LD_INT 1
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: LIST
33904: PPUSH
33905: CALL_OW 72
33909: ST_TO_ADDR
// for k := 1 to depot do
33910: LD_ADDR_VAR 0 4
33914: PUSH
33915: DOUBLE
33916: LD_INT 1
33918: DEC
33919: ST_TO_ADDR
33920: LD_VAR 0 6
33924: PUSH
33925: FOR_TO
33926: IFFALSE 34496
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33928: LD_EXP 85
33932: PUSH
33933: LD_VAR 0 2
33937: ARRAY
33938: PUSH
33939: LD_INT 1
33941: ARRAY
33942: PUSH
33943: LD_INT 1
33945: ARRAY
33946: PUSH
33947: LD_INT 0
33949: EQUAL
33950: PUSH
33951: LD_VAR 0 6
33955: PUSH
33956: LD_VAR 0 4
33960: ARRAY
33961: PPUSH
33962: LD_EXP 85
33966: PUSH
33967: LD_VAR 0 2
33971: ARRAY
33972: PUSH
33973: LD_INT 1
33975: ARRAY
33976: PUSH
33977: LD_INT 1
33979: ARRAY
33980: PPUSH
33981: LD_EXP 85
33985: PUSH
33986: LD_VAR 0 2
33990: ARRAY
33991: PUSH
33992: LD_INT 1
33994: ARRAY
33995: PUSH
33996: LD_INT 2
33998: ARRAY
33999: PPUSH
34000: LD_EXP 85
34004: PUSH
34005: LD_VAR 0 2
34009: ARRAY
34010: PUSH
34011: LD_INT 1
34013: ARRAY
34014: PUSH
34015: LD_INT 3
34017: ARRAY
34018: PPUSH
34019: LD_EXP 85
34023: PUSH
34024: LD_VAR 0 2
34028: ARRAY
34029: PUSH
34030: LD_INT 1
34032: ARRAY
34033: PUSH
34034: LD_INT 4
34036: ARRAY
34037: PPUSH
34038: CALL 67034 0 5
34042: OR
34043: IFFALSE 34324
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
34045: LD_ADDR_VAR 0 5
34049: PUSH
34050: LD_EXP 80
34054: PUSH
34055: LD_VAR 0 2
34059: ARRAY
34060: PPUSH
34061: LD_INT 25
34063: PUSH
34064: LD_INT 2
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PPUSH
34071: CALL_OW 72
34075: PUSH
34076: LD_EXP 82
34080: PUSH
34081: LD_VAR 0 2
34085: ARRAY
34086: DIFF
34087: ST_TO_ADDR
// if not tmp then
34088: LD_VAR 0 5
34092: NOT
34093: IFFALSE 34097
// continue ;
34095: GO 33925
// for j in tmp do
34097: LD_ADDR_VAR 0 3
34101: PUSH
34102: LD_VAR 0 5
34106: PUSH
34107: FOR_IN
34108: IFFALSE 34320
// begin if not mc_builders [ i ] then
34110: LD_EXP 86
34114: PUSH
34115: LD_VAR 0 2
34119: ARRAY
34120: NOT
34121: IFFALSE 34179
// begin SetTag ( j , 103 ) ;
34123: LD_VAR 0 3
34127: PPUSH
34128: LD_INT 103
34130: PPUSH
34131: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34135: LD_ADDR_EXP 86
34139: PUSH
34140: LD_EXP 86
34144: PPUSH
34145: LD_VAR 0 2
34149: PUSH
34150: LD_EXP 86
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PUSH
34161: LD_INT 1
34163: PLUS
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PPUSH
34169: LD_VAR 0 3
34173: PPUSH
34174: CALL 58560 0 3
34178: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34179: LD_VAR 0 3
34183: PPUSH
34184: CALL_OW 310
34188: IFFALSE 34199
// ComExitBuilding ( j ) ;
34190: LD_VAR 0 3
34194: PPUSH
34195: CALL_OW 122
// wait ( 3 ) ;
34199: LD_INT 3
34201: PPUSH
34202: CALL_OW 67
// if not mc_build_list [ i ] then
34206: LD_EXP 85
34210: PUSH
34211: LD_VAR 0 2
34215: ARRAY
34216: NOT
34217: IFFALSE 34221
// break ;
34219: GO 34320
// if not HasTask ( j ) then
34221: LD_VAR 0 3
34225: PPUSH
34226: CALL_OW 314
34230: NOT
34231: IFFALSE 34318
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
34233: LD_VAR 0 3
34237: PPUSH
34238: LD_EXP 85
34242: PUSH
34243: LD_VAR 0 2
34247: ARRAY
34248: PUSH
34249: LD_INT 1
34251: ARRAY
34252: PUSH
34253: LD_INT 1
34255: ARRAY
34256: PPUSH
34257: LD_EXP 85
34261: PUSH
34262: LD_VAR 0 2
34266: ARRAY
34267: PUSH
34268: LD_INT 1
34270: ARRAY
34271: PUSH
34272: LD_INT 2
34274: ARRAY
34275: PPUSH
34276: LD_EXP 85
34280: PUSH
34281: LD_VAR 0 2
34285: ARRAY
34286: PUSH
34287: LD_INT 1
34289: ARRAY
34290: PUSH
34291: LD_INT 3
34293: ARRAY
34294: PPUSH
34295: LD_EXP 85
34299: PUSH
34300: LD_VAR 0 2
34304: ARRAY
34305: PUSH
34306: LD_INT 1
34308: ARRAY
34309: PUSH
34310: LD_INT 4
34312: ARRAY
34313: PPUSH
34314: CALL_OW 145
// end ;
34318: GO 34107
34320: POP
34321: POP
// end else
34322: GO 34494
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
34324: LD_EXP 80
34328: PUSH
34329: LD_VAR 0 2
34333: ARRAY
34334: PPUSH
34335: LD_EXP 85
34339: PUSH
34340: LD_VAR 0 2
34344: ARRAY
34345: PUSH
34346: LD_INT 1
34348: ARRAY
34349: PUSH
34350: LD_INT 1
34352: ARRAY
34353: PPUSH
34354: LD_EXP 85
34358: PUSH
34359: LD_VAR 0 2
34363: ARRAY
34364: PUSH
34365: LD_INT 1
34367: ARRAY
34368: PUSH
34369: LD_INT 2
34371: ARRAY
34372: PPUSH
34373: LD_EXP 85
34377: PUSH
34378: LD_VAR 0 2
34382: ARRAY
34383: PUSH
34384: LD_INT 1
34386: ARRAY
34387: PUSH
34388: LD_INT 3
34390: ARRAY
34391: PPUSH
34392: LD_EXP 85
34396: PUSH
34397: LD_VAR 0 2
34401: ARRAY
34402: PUSH
34403: LD_INT 1
34405: ARRAY
34406: PUSH
34407: LD_INT 4
34409: ARRAY
34410: PPUSH
34411: LD_EXP 80
34415: PUSH
34416: LD_VAR 0 2
34420: ARRAY
34421: PPUSH
34422: LD_INT 21
34424: PUSH
34425: LD_INT 3
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PPUSH
34432: CALL_OW 72
34436: PPUSH
34437: EMPTY
34438: PPUSH
34439: CALL 65788 0 7
34443: NOT
34444: IFFALSE 34494
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
34446: LD_ADDR_EXP 85
34450: PUSH
34451: LD_EXP 85
34455: PPUSH
34456: LD_VAR 0 2
34460: PPUSH
34461: LD_EXP 85
34465: PUSH
34466: LD_VAR 0 2
34470: ARRAY
34471: PPUSH
34472: LD_INT 1
34474: PPUSH
34475: LD_INT 1
34477: NEG
34478: PPUSH
34479: LD_INT 0
34481: PPUSH
34482: CALL 57978 0 4
34486: PPUSH
34487: CALL_OW 1
34491: ST_TO_ADDR
// continue ;
34492: GO 33925
// end ; end ;
34494: GO 33925
34496: POP
34497: POP
// end ; end ;
34498: GO 33354
34500: POP
34501: POP
// end ;
34502: LD_VAR 0 1
34506: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
34507: LD_INT 0
34509: PPUSH
34510: PPUSH
34511: PPUSH
34512: PPUSH
34513: PPUSH
34514: PPUSH
// if not mc_bases then
34515: LD_EXP 80
34519: NOT
34520: IFFALSE 34524
// exit ;
34522: GO 34951
// for i = 1 to mc_bases do
34524: LD_ADDR_VAR 0 2
34528: PUSH
34529: DOUBLE
34530: LD_INT 1
34532: DEC
34533: ST_TO_ADDR
34534: LD_EXP 80
34538: PUSH
34539: FOR_TO
34540: IFFALSE 34949
// begin tmp := mc_build_upgrade [ i ] ;
34542: LD_ADDR_VAR 0 4
34546: PUSH
34547: LD_EXP 112
34551: PUSH
34552: LD_VAR 0 2
34556: ARRAY
34557: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
34558: LD_ADDR_VAR 0 6
34562: PUSH
34563: LD_EXP 113
34567: PUSH
34568: LD_VAR 0 2
34572: ARRAY
34573: PPUSH
34574: LD_INT 2
34576: PUSH
34577: LD_INT 30
34579: PUSH
34580: LD_INT 6
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: LD_INT 30
34589: PUSH
34590: LD_INT 7
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: LIST
34601: PPUSH
34602: CALL_OW 72
34606: ST_TO_ADDR
// if not tmp and not lab then
34607: LD_VAR 0 4
34611: NOT
34612: PUSH
34613: LD_VAR 0 6
34617: NOT
34618: AND
34619: IFFALSE 34623
// continue ;
34621: GO 34539
// if tmp then
34623: LD_VAR 0 4
34627: IFFALSE 34747
// for j in tmp do
34629: LD_ADDR_VAR 0 3
34633: PUSH
34634: LD_VAR 0 4
34638: PUSH
34639: FOR_IN
34640: IFFALSE 34745
// begin if UpgradeCost ( j ) then
34642: LD_VAR 0 3
34646: PPUSH
34647: CALL 65448 0 1
34651: IFFALSE 34743
// begin ComUpgrade ( j ) ;
34653: LD_VAR 0 3
34657: PPUSH
34658: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
34662: LD_ADDR_EXP 112
34666: PUSH
34667: LD_EXP 112
34671: PPUSH
34672: LD_VAR 0 2
34676: PPUSH
34677: LD_EXP 112
34681: PUSH
34682: LD_VAR 0 2
34686: ARRAY
34687: PUSH
34688: LD_VAR 0 3
34692: DIFF
34693: PPUSH
34694: CALL_OW 1
34698: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34699: LD_ADDR_EXP 87
34703: PUSH
34704: LD_EXP 87
34708: PPUSH
34709: LD_VAR 0 2
34713: PUSH
34714: LD_EXP 87
34718: PUSH
34719: LD_VAR 0 2
34723: ARRAY
34724: PUSH
34725: LD_INT 1
34727: PLUS
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PPUSH
34733: LD_VAR 0 3
34737: PPUSH
34738: CALL 58560 0 3
34742: ST_TO_ADDR
// end ; end ;
34743: GO 34639
34745: POP
34746: POP
// if not lab or not mc_lab_upgrade [ i ] then
34747: LD_VAR 0 6
34751: NOT
34752: PUSH
34753: LD_EXP 114
34757: PUSH
34758: LD_VAR 0 2
34762: ARRAY
34763: NOT
34764: OR
34765: IFFALSE 34769
// continue ;
34767: GO 34539
// for j in lab do
34769: LD_ADDR_VAR 0 3
34773: PUSH
34774: LD_VAR 0 6
34778: PUSH
34779: FOR_IN
34780: IFFALSE 34945
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34782: LD_VAR 0 3
34786: PPUSH
34787: CALL_OW 266
34791: PUSH
34792: LD_INT 6
34794: PUSH
34795: LD_INT 7
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: IN
34802: PUSH
34803: LD_VAR 0 3
34807: PPUSH
34808: CALL_OW 461
34812: PUSH
34813: LD_INT 1
34815: NONEQUAL
34816: AND
34817: IFFALSE 34943
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34819: LD_VAR 0 3
34823: PPUSH
34824: LD_EXP 114
34828: PUSH
34829: LD_VAR 0 2
34833: ARRAY
34834: PUSH
34835: LD_INT 1
34837: ARRAY
34838: PPUSH
34839: CALL 65653 0 2
34843: IFFALSE 34943
// begin ComCancel ( j ) ;
34845: LD_VAR 0 3
34849: PPUSH
34850: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34854: LD_VAR 0 3
34858: PPUSH
34859: LD_EXP 114
34863: PUSH
34864: LD_VAR 0 2
34868: ARRAY
34869: PUSH
34870: LD_INT 1
34872: ARRAY
34873: PPUSH
34874: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34878: LD_VAR 0 3
34882: PUSH
34883: LD_EXP 87
34887: PUSH
34888: LD_VAR 0 2
34892: ARRAY
34893: IN
34894: NOT
34895: IFFALSE 34941
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34897: LD_ADDR_EXP 87
34901: PUSH
34902: LD_EXP 87
34906: PPUSH
34907: LD_VAR 0 2
34911: PUSH
34912: LD_EXP 87
34916: PUSH
34917: LD_VAR 0 2
34921: ARRAY
34922: PUSH
34923: LD_INT 1
34925: PLUS
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PPUSH
34931: LD_VAR 0 3
34935: PPUSH
34936: CALL 58560 0 3
34940: ST_TO_ADDR
// break ;
34941: GO 34945
// end ; end ; end ;
34943: GO 34779
34945: POP
34946: POP
// end ;
34947: GO 34539
34949: POP
34950: POP
// end ;
34951: LD_VAR 0 1
34955: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34956: LD_INT 0
34958: PPUSH
34959: PPUSH
34960: PPUSH
34961: PPUSH
34962: PPUSH
34963: PPUSH
34964: PPUSH
34965: PPUSH
34966: PPUSH
// if not mc_bases then
34967: LD_EXP 80
34971: NOT
34972: IFFALSE 34976
// exit ;
34974: GO 35381
// for i = 1 to mc_bases do
34976: LD_ADDR_VAR 0 2
34980: PUSH
34981: DOUBLE
34982: LD_INT 1
34984: DEC
34985: ST_TO_ADDR
34986: LD_EXP 80
34990: PUSH
34991: FOR_TO
34992: IFFALSE 35379
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34994: LD_EXP 88
34998: PUSH
34999: LD_VAR 0 2
35003: ARRAY
35004: NOT
35005: PUSH
35006: LD_EXP 80
35010: PUSH
35011: LD_VAR 0 2
35015: ARRAY
35016: PPUSH
35017: LD_INT 30
35019: PUSH
35020: LD_INT 3
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PPUSH
35027: CALL_OW 72
35031: NOT
35032: OR
35033: IFFALSE 35037
// continue ;
35035: GO 34991
// busy := false ;
35037: LD_ADDR_VAR 0 8
35041: PUSH
35042: LD_INT 0
35044: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35045: LD_ADDR_VAR 0 4
35049: PUSH
35050: LD_EXP 80
35054: PUSH
35055: LD_VAR 0 2
35059: ARRAY
35060: PPUSH
35061: LD_INT 30
35063: PUSH
35064: LD_INT 3
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PPUSH
35071: CALL_OW 72
35075: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
35076: LD_ADDR_VAR 0 6
35080: PUSH
35081: LD_EXP 88
35085: PUSH
35086: LD_VAR 0 2
35090: ARRAY
35091: PPUSH
35092: LD_INT 2
35094: PUSH
35095: LD_INT 30
35097: PUSH
35098: LD_INT 32
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 30
35107: PUSH
35108: LD_INT 33
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: LIST
35119: PPUSH
35120: CALL_OW 72
35124: ST_TO_ADDR
// if not t then
35125: LD_VAR 0 6
35129: NOT
35130: IFFALSE 35134
// continue ;
35132: GO 34991
// for j in tmp do
35134: LD_ADDR_VAR 0 3
35138: PUSH
35139: LD_VAR 0 4
35143: PUSH
35144: FOR_IN
35145: IFFALSE 35175
// if not BuildingStatus ( j ) = bs_idle then
35147: LD_VAR 0 3
35151: PPUSH
35152: CALL_OW 461
35156: PUSH
35157: LD_INT 2
35159: EQUAL
35160: NOT
35161: IFFALSE 35173
// begin busy := true ;
35163: LD_ADDR_VAR 0 8
35167: PUSH
35168: LD_INT 1
35170: ST_TO_ADDR
// break ;
35171: GO 35175
// end ;
35173: GO 35144
35175: POP
35176: POP
// if busy then
35177: LD_VAR 0 8
35181: IFFALSE 35185
// continue ;
35183: GO 34991
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
35185: LD_ADDR_VAR 0 7
35189: PUSH
35190: LD_VAR 0 6
35194: PPUSH
35195: LD_INT 35
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PPUSH
35205: CALL_OW 72
35209: ST_TO_ADDR
// if tw then
35210: LD_VAR 0 7
35214: IFFALSE 35291
// begin tw := tw [ 1 ] ;
35216: LD_ADDR_VAR 0 7
35220: PUSH
35221: LD_VAR 0 7
35225: PUSH
35226: LD_INT 1
35228: ARRAY
35229: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
35230: LD_ADDR_VAR 0 9
35234: PUSH
35235: LD_VAR 0 7
35239: PPUSH
35240: LD_EXP 105
35244: PUSH
35245: LD_VAR 0 2
35249: ARRAY
35250: PPUSH
35251: CALL 63945 0 2
35255: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
35256: LD_EXP 119
35260: PUSH
35261: LD_VAR 0 2
35265: ARRAY
35266: IFFALSE 35289
// if not weapon in mc_allowed_tower_weapons [ i ] then
35268: LD_VAR 0 9
35272: PUSH
35273: LD_EXP 119
35277: PUSH
35278: LD_VAR 0 2
35282: ARRAY
35283: IN
35284: NOT
35285: IFFALSE 35289
// continue ;
35287: GO 34991
// end else
35289: GO 35354
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
35291: LD_ADDR_VAR 0 5
35295: PUSH
35296: LD_EXP 88
35300: PUSH
35301: LD_VAR 0 2
35305: ARRAY
35306: PPUSH
35307: LD_VAR 0 4
35311: PPUSH
35312: CALL 90857 0 2
35316: ST_TO_ADDR
// if not tmp2 then
35317: LD_VAR 0 5
35321: NOT
35322: IFFALSE 35326
// continue ;
35324: GO 34991
// tw := tmp2 [ 1 ] ;
35326: LD_ADDR_VAR 0 7
35330: PUSH
35331: LD_VAR 0 5
35335: PUSH
35336: LD_INT 1
35338: ARRAY
35339: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
35340: LD_ADDR_VAR 0 9
35344: PUSH
35345: LD_VAR 0 5
35349: PUSH
35350: LD_INT 2
35352: ARRAY
35353: ST_TO_ADDR
// end ; if not weapon then
35354: LD_VAR 0 9
35358: NOT
35359: IFFALSE 35363
// continue ;
35361: GO 34991
// ComPlaceWeapon ( tw , weapon ) ;
35363: LD_VAR 0 7
35367: PPUSH
35368: LD_VAR 0 9
35372: PPUSH
35373: CALL_OW 148
// end ;
35377: GO 34991
35379: POP
35380: POP
// end ;
35381: LD_VAR 0 1
35385: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
35386: LD_INT 0
35388: PPUSH
35389: PPUSH
35390: PPUSH
35391: PPUSH
35392: PPUSH
35393: PPUSH
35394: PPUSH
// if not mc_bases then
35395: LD_EXP 80
35399: NOT
35400: IFFALSE 35404
// exit ;
35402: GO 36179
// for i = 1 to mc_bases do
35404: LD_ADDR_VAR 0 2
35408: PUSH
35409: DOUBLE
35410: LD_INT 1
35412: DEC
35413: ST_TO_ADDR
35414: LD_EXP 80
35418: PUSH
35419: FOR_TO
35420: IFFALSE 36177
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
35422: LD_EXP 93
35426: PUSH
35427: LD_VAR 0 2
35431: ARRAY
35432: NOT
35433: PUSH
35434: LD_EXP 93
35438: PUSH
35439: LD_VAR 0 2
35443: ARRAY
35444: PUSH
35445: LD_EXP 94
35449: PUSH
35450: LD_VAR 0 2
35454: ARRAY
35455: EQUAL
35456: OR
35457: PUSH
35458: LD_EXP 103
35462: PUSH
35463: LD_VAR 0 2
35467: ARRAY
35468: OR
35469: IFFALSE 35473
// continue ;
35471: GO 35419
// if mc_miners [ i ] then
35473: LD_EXP 94
35477: PUSH
35478: LD_VAR 0 2
35482: ARRAY
35483: IFFALSE 35864
// begin for j = mc_miners [ i ] downto 1 do
35485: LD_ADDR_VAR 0 3
35489: PUSH
35490: DOUBLE
35491: LD_EXP 94
35495: PUSH
35496: LD_VAR 0 2
35500: ARRAY
35501: INC
35502: ST_TO_ADDR
35503: LD_INT 1
35505: PUSH
35506: FOR_DOWNTO
35507: IFFALSE 35862
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
35509: LD_EXP 94
35513: PUSH
35514: LD_VAR 0 2
35518: ARRAY
35519: PUSH
35520: LD_VAR 0 3
35524: ARRAY
35525: PPUSH
35526: CALL_OW 301
35530: PUSH
35531: LD_EXP 94
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_VAR 0 3
35546: ARRAY
35547: PPUSH
35548: CALL_OW 257
35552: PUSH
35553: LD_INT 1
35555: NONEQUAL
35556: OR
35557: IFFALSE 35620
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
35559: LD_ADDR_VAR 0 5
35563: PUSH
35564: LD_EXP 94
35568: PUSH
35569: LD_VAR 0 2
35573: ARRAY
35574: PUSH
35575: LD_EXP 94
35579: PUSH
35580: LD_VAR 0 2
35584: ARRAY
35585: PUSH
35586: LD_VAR 0 3
35590: ARRAY
35591: DIFF
35592: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
35593: LD_ADDR_EXP 94
35597: PUSH
35598: LD_EXP 94
35602: PPUSH
35603: LD_VAR 0 2
35607: PPUSH
35608: LD_VAR 0 5
35612: PPUSH
35613: CALL_OW 1
35617: ST_TO_ADDR
// continue ;
35618: GO 35506
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
35620: LD_EXP 94
35624: PUSH
35625: LD_VAR 0 2
35629: ARRAY
35630: PUSH
35631: LD_VAR 0 3
35635: ARRAY
35636: PPUSH
35637: CALL_OW 257
35641: PUSH
35642: LD_INT 1
35644: EQUAL
35645: PUSH
35646: LD_EXP 94
35650: PUSH
35651: LD_VAR 0 2
35655: ARRAY
35656: PUSH
35657: LD_VAR 0 3
35661: ARRAY
35662: PPUSH
35663: CALL_OW 459
35667: NOT
35668: AND
35669: PUSH
35670: LD_EXP 94
35674: PUSH
35675: LD_VAR 0 2
35679: ARRAY
35680: PUSH
35681: LD_VAR 0 3
35685: ARRAY
35686: PPUSH
35687: CALL_OW 314
35691: NOT
35692: AND
35693: IFFALSE 35860
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
35695: LD_EXP 94
35699: PUSH
35700: LD_VAR 0 2
35704: ARRAY
35705: PUSH
35706: LD_VAR 0 3
35710: ARRAY
35711: PPUSH
35712: CALL_OW 310
35716: IFFALSE 35739
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35718: LD_EXP 94
35722: PUSH
35723: LD_VAR 0 2
35727: ARRAY
35728: PUSH
35729: LD_VAR 0 3
35733: ARRAY
35734: PPUSH
35735: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35739: LD_EXP 94
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_VAR 0 3
35754: ARRAY
35755: PPUSH
35756: CALL_OW 314
35760: NOT
35761: IFFALSE 35860
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35763: LD_ADDR_VAR 0 7
35767: PUSH
35768: LD_VAR 0 3
35772: PUSH
35773: LD_EXP 93
35777: PUSH
35778: LD_VAR 0 2
35782: ARRAY
35783: PPUSH
35784: CALL 55700 0 1
35788: MOD
35789: PUSH
35790: LD_INT 1
35792: PLUS
35793: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35794: LD_EXP 94
35798: PUSH
35799: LD_VAR 0 2
35803: ARRAY
35804: PUSH
35805: LD_VAR 0 3
35809: ARRAY
35810: PPUSH
35811: LD_EXP 93
35815: PUSH
35816: LD_VAR 0 2
35820: ARRAY
35821: PUSH
35822: LD_VAR 0 7
35826: ARRAY
35827: PUSH
35828: LD_INT 1
35830: ARRAY
35831: PPUSH
35832: LD_EXP 93
35836: PUSH
35837: LD_VAR 0 2
35841: ARRAY
35842: PUSH
35843: LD_VAR 0 7
35847: ARRAY
35848: PUSH
35849: LD_INT 2
35851: ARRAY
35852: PPUSH
35853: LD_INT 0
35855: PPUSH
35856: CALL_OW 193
// end ; end ; end ;
35860: GO 35506
35862: POP
35863: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35864: LD_ADDR_VAR 0 5
35868: PUSH
35869: LD_EXP 80
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PPUSH
35880: LD_INT 2
35882: PUSH
35883: LD_INT 30
35885: PUSH
35886: LD_INT 4
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 30
35895: PUSH
35896: LD_INT 5
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 30
35905: PUSH
35906: LD_INT 32
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: PPUSH
35919: CALL_OW 72
35923: ST_TO_ADDR
// if not tmp then
35924: LD_VAR 0 5
35928: NOT
35929: IFFALSE 35933
// continue ;
35931: GO 35419
// list := [ ] ;
35933: LD_ADDR_VAR 0 6
35937: PUSH
35938: EMPTY
35939: ST_TO_ADDR
// for j in tmp do
35940: LD_ADDR_VAR 0 3
35944: PUSH
35945: LD_VAR 0 5
35949: PUSH
35950: FOR_IN
35951: IFFALSE 36020
// begin for k in UnitsInside ( j ) do
35953: LD_ADDR_VAR 0 4
35957: PUSH
35958: LD_VAR 0 3
35962: PPUSH
35963: CALL_OW 313
35967: PUSH
35968: FOR_IN
35969: IFFALSE 36016
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35971: LD_VAR 0 4
35975: PPUSH
35976: CALL_OW 257
35980: PUSH
35981: LD_INT 1
35983: EQUAL
35984: PUSH
35985: LD_VAR 0 4
35989: PPUSH
35990: CALL_OW 459
35994: NOT
35995: AND
35996: IFFALSE 36014
// list := list ^ k ;
35998: LD_ADDR_VAR 0 6
36002: PUSH
36003: LD_VAR 0 6
36007: PUSH
36008: LD_VAR 0 4
36012: ADD
36013: ST_TO_ADDR
36014: GO 35968
36016: POP
36017: POP
// end ;
36018: GO 35950
36020: POP
36021: POP
// list := list diff mc_miners [ i ] ;
36022: LD_ADDR_VAR 0 6
36026: PUSH
36027: LD_VAR 0 6
36031: PUSH
36032: LD_EXP 94
36036: PUSH
36037: LD_VAR 0 2
36041: ARRAY
36042: DIFF
36043: ST_TO_ADDR
// if not list then
36044: LD_VAR 0 6
36048: NOT
36049: IFFALSE 36053
// continue ;
36051: GO 35419
// k := mc_mines [ i ] - mc_miners [ i ] ;
36053: LD_ADDR_VAR 0 4
36057: PUSH
36058: LD_EXP 93
36062: PUSH
36063: LD_VAR 0 2
36067: ARRAY
36068: PUSH
36069: LD_EXP 94
36073: PUSH
36074: LD_VAR 0 2
36078: ARRAY
36079: MINUS
36080: ST_TO_ADDR
// if k > list then
36081: LD_VAR 0 4
36085: PUSH
36086: LD_VAR 0 6
36090: GREATER
36091: IFFALSE 36103
// k := list ;
36093: LD_ADDR_VAR 0 4
36097: PUSH
36098: LD_VAR 0 6
36102: ST_TO_ADDR
// for j = 1 to k do
36103: LD_ADDR_VAR 0 3
36107: PUSH
36108: DOUBLE
36109: LD_INT 1
36111: DEC
36112: ST_TO_ADDR
36113: LD_VAR 0 4
36117: PUSH
36118: FOR_TO
36119: IFFALSE 36173
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
36121: LD_ADDR_EXP 94
36125: PUSH
36126: LD_EXP 94
36130: PPUSH
36131: LD_VAR 0 2
36135: PUSH
36136: LD_EXP 94
36140: PUSH
36141: LD_VAR 0 2
36145: ARRAY
36146: PUSH
36147: LD_INT 1
36149: PLUS
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PPUSH
36155: LD_VAR 0 6
36159: PUSH
36160: LD_VAR 0 3
36164: ARRAY
36165: PPUSH
36166: CALL 58560 0 3
36170: ST_TO_ADDR
36171: GO 36118
36173: POP
36174: POP
// end ;
36175: GO 35419
36177: POP
36178: POP
// end ;
36179: LD_VAR 0 1
36183: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
36184: LD_INT 0
36186: PPUSH
36187: PPUSH
36188: PPUSH
36189: PPUSH
36190: PPUSH
36191: PPUSH
36192: PPUSH
36193: PPUSH
36194: PPUSH
36195: PPUSH
36196: PPUSH
// if not mc_bases then
36197: LD_EXP 80
36201: NOT
36202: IFFALSE 36206
// exit ;
36204: GO 38029
// for i = 1 to mc_bases do
36206: LD_ADDR_VAR 0 2
36210: PUSH
36211: DOUBLE
36212: LD_INT 1
36214: DEC
36215: ST_TO_ADDR
36216: LD_EXP 80
36220: PUSH
36221: FOR_TO
36222: IFFALSE 38027
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
36224: LD_EXP 80
36228: PUSH
36229: LD_VAR 0 2
36233: ARRAY
36234: NOT
36235: PUSH
36236: LD_EXP 87
36240: PUSH
36241: LD_VAR 0 2
36245: ARRAY
36246: OR
36247: IFFALSE 36251
// continue ;
36249: GO 36221
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
36251: LD_EXP 96
36255: PUSH
36256: LD_VAR 0 2
36260: ARRAY
36261: NOT
36262: PUSH
36263: LD_EXP 97
36267: PUSH
36268: LD_VAR 0 2
36272: ARRAY
36273: AND
36274: IFFALSE 36312
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36276: LD_ADDR_EXP 97
36280: PUSH
36281: LD_EXP 97
36285: PPUSH
36286: LD_VAR 0 2
36290: PPUSH
36291: EMPTY
36292: PPUSH
36293: CALL_OW 1
36297: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
36298: LD_VAR 0 2
36302: PPUSH
36303: LD_INT 107
36305: PPUSH
36306: CALL 27038 0 2
// continue ;
36310: GO 36221
// end ; target := [ ] ;
36312: LD_ADDR_VAR 0 7
36316: PUSH
36317: EMPTY
36318: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36319: LD_ADDR_VAR 0 6
36323: PUSH
36324: LD_EXP 80
36328: PUSH
36329: LD_VAR 0 2
36333: ARRAY
36334: PUSH
36335: LD_INT 1
36337: ARRAY
36338: PPUSH
36339: CALL_OW 255
36343: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36344: LD_ADDR_VAR 0 9
36348: PUSH
36349: LD_EXP 80
36353: PUSH
36354: LD_VAR 0 2
36358: ARRAY
36359: PPUSH
36360: LD_INT 2
36362: PUSH
36363: LD_INT 30
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 30
36375: PUSH
36376: LD_INT 1
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: LIST
36387: PPUSH
36388: CALL_OW 72
36392: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
36393: LD_ADDR_VAR 0 3
36397: PUSH
36398: DOUBLE
36399: LD_EXP 96
36403: PUSH
36404: LD_VAR 0 2
36408: ARRAY
36409: INC
36410: ST_TO_ADDR
36411: LD_INT 1
36413: PUSH
36414: FOR_DOWNTO
36415: IFFALSE 36660
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
36417: LD_EXP 96
36421: PUSH
36422: LD_VAR 0 2
36426: ARRAY
36427: PUSH
36428: LD_VAR 0 3
36432: ARRAY
36433: PUSH
36434: LD_INT 2
36436: ARRAY
36437: PPUSH
36438: LD_EXP 96
36442: PUSH
36443: LD_VAR 0 2
36447: ARRAY
36448: PUSH
36449: LD_VAR 0 3
36453: ARRAY
36454: PUSH
36455: LD_INT 3
36457: ARRAY
36458: PPUSH
36459: CALL_OW 488
36463: PUSH
36464: LD_EXP 96
36468: PUSH
36469: LD_VAR 0 2
36473: ARRAY
36474: PUSH
36475: LD_VAR 0 3
36479: ARRAY
36480: PUSH
36481: LD_INT 2
36483: ARRAY
36484: PPUSH
36485: LD_EXP 96
36489: PUSH
36490: LD_VAR 0 2
36494: ARRAY
36495: PUSH
36496: LD_VAR 0 3
36500: ARRAY
36501: PUSH
36502: LD_INT 3
36504: ARRAY
36505: PPUSH
36506: CALL_OW 284
36510: PUSH
36511: LD_INT 0
36513: EQUAL
36514: AND
36515: IFFALSE 36570
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
36517: LD_ADDR_VAR 0 5
36521: PUSH
36522: LD_EXP 96
36526: PUSH
36527: LD_VAR 0 2
36531: ARRAY
36532: PPUSH
36533: LD_VAR 0 3
36537: PPUSH
36538: CALL_OW 3
36542: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
36543: LD_ADDR_EXP 96
36547: PUSH
36548: LD_EXP 96
36552: PPUSH
36553: LD_VAR 0 2
36557: PPUSH
36558: LD_VAR 0 5
36562: PPUSH
36563: CALL_OW 1
36567: ST_TO_ADDR
// continue ;
36568: GO 36414
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
36570: LD_VAR 0 6
36574: PPUSH
36575: LD_EXP 96
36579: PUSH
36580: LD_VAR 0 2
36584: ARRAY
36585: PUSH
36586: LD_VAR 0 3
36590: ARRAY
36591: PUSH
36592: LD_INT 2
36594: ARRAY
36595: PPUSH
36596: LD_EXP 96
36600: PUSH
36601: LD_VAR 0 2
36605: ARRAY
36606: PUSH
36607: LD_VAR 0 3
36611: ARRAY
36612: PUSH
36613: LD_INT 3
36615: ARRAY
36616: PPUSH
36617: LD_INT 30
36619: PPUSH
36620: CALL 59824 0 4
36624: PUSH
36625: LD_INT 4
36627: ARRAY
36628: PUSH
36629: LD_INT 0
36631: EQUAL
36632: IFFALSE 36658
// begin target := mc_crates [ i ] [ j ] ;
36634: LD_ADDR_VAR 0 7
36638: PUSH
36639: LD_EXP 96
36643: PUSH
36644: LD_VAR 0 2
36648: ARRAY
36649: PUSH
36650: LD_VAR 0 3
36654: ARRAY
36655: ST_TO_ADDR
// break ;
36656: GO 36660
// end ; end ;
36658: GO 36414
36660: POP
36661: POP
// if not target then
36662: LD_VAR 0 7
36666: NOT
36667: IFFALSE 36671
// continue ;
36669: GO 36221
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
36671: LD_ADDR_VAR 0 8
36675: PUSH
36676: LD_EXP 99
36680: PUSH
36681: LD_VAR 0 2
36685: ARRAY
36686: PPUSH
36687: LD_INT 2
36689: PUSH
36690: LD_INT 3
36692: PUSH
36693: LD_INT 58
36695: PUSH
36696: EMPTY
36697: LIST
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 61
36705: PUSH
36706: EMPTY
36707: LIST
36708: PUSH
36709: LD_INT 33
36711: PUSH
36712: LD_INT 5
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 33
36721: PUSH
36722: LD_INT 3
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: LIST
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 2
36738: PUSH
36739: LD_INT 34
36741: PUSH
36742: LD_INT 32
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 34
36751: PUSH
36752: LD_INT 51
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 34
36761: PUSH
36762: LD_INT 12
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PPUSH
36779: CALL_OW 72
36783: ST_TO_ADDR
// if not cargo then
36784: LD_VAR 0 8
36788: NOT
36789: IFFALSE 37495
// begin if mc_crates_collector [ i ] < 5 then
36791: LD_EXP 97
36795: PUSH
36796: LD_VAR 0 2
36800: ARRAY
36801: PUSH
36802: LD_INT 5
36804: LESS
36805: IFFALSE 37171
// begin if mc_ape [ i ] then
36807: LD_EXP 109
36811: PUSH
36812: LD_VAR 0 2
36816: ARRAY
36817: IFFALSE 36864
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36819: LD_ADDR_VAR 0 5
36823: PUSH
36824: LD_EXP 109
36828: PUSH
36829: LD_VAR 0 2
36833: ARRAY
36834: PPUSH
36835: LD_INT 25
36837: PUSH
36838: LD_INT 16
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 24
36847: PUSH
36848: LD_INT 750
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PPUSH
36859: CALL_OW 72
36863: ST_TO_ADDR
// if not tmp then
36864: LD_VAR 0 5
36868: NOT
36869: IFFALSE 36916
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36871: LD_ADDR_VAR 0 5
36875: PUSH
36876: LD_EXP 80
36880: PUSH
36881: LD_VAR 0 2
36885: ARRAY
36886: PPUSH
36887: LD_INT 25
36889: PUSH
36890: LD_INT 2
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 24
36899: PUSH
36900: LD_INT 750
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: EMPTY
36908: LIST
36909: LIST
36910: PPUSH
36911: CALL_OW 72
36915: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36916: LD_EXP 109
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: PUSH
36927: LD_EXP 80
36931: PUSH
36932: LD_VAR 0 2
36936: ARRAY
36937: PPUSH
36938: LD_INT 25
36940: PUSH
36941: LD_INT 2
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 24
36950: PUSH
36951: LD_INT 750
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PPUSH
36962: CALL_OW 72
36966: AND
36967: PUSH
36968: LD_VAR 0 5
36972: PUSH
36973: LD_INT 5
36975: LESS
36976: AND
36977: IFFALSE 37059
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36979: LD_ADDR_VAR 0 3
36983: PUSH
36984: LD_EXP 80
36988: PUSH
36989: LD_VAR 0 2
36993: ARRAY
36994: PPUSH
36995: LD_INT 25
36997: PUSH
36998: LD_INT 2
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 24
37007: PUSH
37008: LD_INT 750
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PPUSH
37019: CALL_OW 72
37023: PUSH
37024: FOR_IN
37025: IFFALSE 37057
// begin tmp := tmp union j ;
37027: LD_ADDR_VAR 0 5
37031: PUSH
37032: LD_VAR 0 5
37036: PUSH
37037: LD_VAR 0 3
37041: UNION
37042: ST_TO_ADDR
// if tmp >= 5 then
37043: LD_VAR 0 5
37047: PUSH
37048: LD_INT 5
37050: GREATEREQUAL
37051: IFFALSE 37055
// break ;
37053: GO 37057
// end ;
37055: GO 37024
37057: POP
37058: POP
// end ; if not tmp then
37059: LD_VAR 0 5
37063: NOT
37064: IFFALSE 37068
// continue ;
37066: GO 36221
// for j in tmp do
37068: LD_ADDR_VAR 0 3
37072: PUSH
37073: LD_VAR 0 5
37077: PUSH
37078: FOR_IN
37079: IFFALSE 37169
// if not GetTag ( j ) then
37081: LD_VAR 0 3
37085: PPUSH
37086: CALL_OW 110
37090: NOT
37091: IFFALSE 37167
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
37093: LD_ADDR_EXP 97
37097: PUSH
37098: LD_EXP 97
37102: PPUSH
37103: LD_VAR 0 2
37107: PUSH
37108: LD_EXP 97
37112: PUSH
37113: LD_VAR 0 2
37117: ARRAY
37118: PUSH
37119: LD_INT 1
37121: PLUS
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PPUSH
37127: LD_VAR 0 3
37131: PPUSH
37132: CALL 58560 0 3
37136: ST_TO_ADDR
// SetTag ( j , 107 ) ;
37137: LD_VAR 0 3
37141: PPUSH
37142: LD_INT 107
37144: PPUSH
37145: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
37149: LD_EXP 97
37153: PUSH
37154: LD_VAR 0 2
37158: ARRAY
37159: PUSH
37160: LD_INT 5
37162: GREATEREQUAL
37163: IFFALSE 37167
// break ;
37165: GO 37169
// end ;
37167: GO 37078
37169: POP
37170: POP
// end ; if mc_crates_collector [ i ] and target then
37171: LD_EXP 97
37175: PUSH
37176: LD_VAR 0 2
37180: ARRAY
37181: PUSH
37182: LD_VAR 0 7
37186: AND
37187: IFFALSE 37493
// begin if mc_crates_collector [ i ] < target [ 1 ] then
37189: LD_EXP 97
37193: PUSH
37194: LD_VAR 0 2
37198: ARRAY
37199: PUSH
37200: LD_VAR 0 7
37204: PUSH
37205: LD_INT 1
37207: ARRAY
37208: LESS
37209: IFFALSE 37229
// tmp := mc_crates_collector [ i ] else
37211: LD_ADDR_VAR 0 5
37215: PUSH
37216: LD_EXP 97
37220: PUSH
37221: LD_VAR 0 2
37225: ARRAY
37226: ST_TO_ADDR
37227: GO 37243
// tmp := target [ 1 ] ;
37229: LD_ADDR_VAR 0 5
37233: PUSH
37234: LD_VAR 0 7
37238: PUSH
37239: LD_INT 1
37241: ARRAY
37242: ST_TO_ADDR
// k := 0 ;
37243: LD_ADDR_VAR 0 4
37247: PUSH
37248: LD_INT 0
37250: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
37251: LD_ADDR_VAR 0 3
37255: PUSH
37256: LD_EXP 97
37260: PUSH
37261: LD_VAR 0 2
37265: ARRAY
37266: PUSH
37267: FOR_IN
37268: IFFALSE 37491
// begin k := k + 1 ;
37270: LD_ADDR_VAR 0 4
37274: PUSH
37275: LD_VAR 0 4
37279: PUSH
37280: LD_INT 1
37282: PLUS
37283: ST_TO_ADDR
// if k > tmp then
37284: LD_VAR 0 4
37288: PUSH
37289: LD_VAR 0 5
37293: GREATER
37294: IFFALSE 37298
// break ;
37296: GO 37491
// if not GetClass ( j ) in [ 2 , 16 ] then
37298: LD_VAR 0 3
37302: PPUSH
37303: CALL_OW 257
37307: PUSH
37308: LD_INT 2
37310: PUSH
37311: LD_INT 16
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: IN
37318: NOT
37319: IFFALSE 37372
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
37321: LD_ADDR_EXP 97
37325: PUSH
37326: LD_EXP 97
37330: PPUSH
37331: LD_VAR 0 2
37335: PPUSH
37336: LD_EXP 97
37340: PUSH
37341: LD_VAR 0 2
37345: ARRAY
37346: PUSH
37347: LD_VAR 0 3
37351: DIFF
37352: PPUSH
37353: CALL_OW 1
37357: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37358: LD_VAR 0 3
37362: PPUSH
37363: LD_INT 0
37365: PPUSH
37366: CALL_OW 109
// continue ;
37370: GO 37267
// end ; if IsInUnit ( j ) then
37372: LD_VAR 0 3
37376: PPUSH
37377: CALL_OW 310
37381: IFFALSE 37392
// ComExitBuilding ( j ) ;
37383: LD_VAR 0 3
37387: PPUSH
37388: CALL_OW 122
// wait ( 3 ) ;
37392: LD_INT 3
37394: PPUSH
37395: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
37399: LD_VAR 0 3
37403: PPUSH
37404: CALL_OW 314
37408: PUSH
37409: LD_VAR 0 6
37413: PPUSH
37414: LD_VAR 0 7
37418: PUSH
37419: LD_INT 2
37421: ARRAY
37422: PPUSH
37423: LD_VAR 0 7
37427: PUSH
37428: LD_INT 3
37430: ARRAY
37431: PPUSH
37432: LD_INT 30
37434: PPUSH
37435: CALL 59824 0 4
37439: PUSH
37440: LD_INT 4
37442: ARRAY
37443: AND
37444: IFFALSE 37462
// ComStandNearbyBuilding ( j , depot ) else
37446: LD_VAR 0 3
37450: PPUSH
37451: LD_VAR 0 9
37455: PPUSH
37456: CALL 55162 0 2
37460: GO 37489
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37462: LD_VAR 0 3
37466: PPUSH
37467: LD_VAR 0 7
37471: PUSH
37472: LD_INT 2
37474: ARRAY
37475: PPUSH
37476: LD_VAR 0 7
37480: PUSH
37481: LD_INT 3
37483: ARRAY
37484: PPUSH
37485: CALL_OW 117
// end ;
37489: GO 37267
37491: POP
37492: POP
// end ; end else
37493: GO 38025
// begin for j in cargo do
37495: LD_ADDR_VAR 0 3
37499: PUSH
37500: LD_VAR 0 8
37504: PUSH
37505: FOR_IN
37506: IFFALSE 38023
// begin if GetTag ( j ) <> 0 then
37508: LD_VAR 0 3
37512: PPUSH
37513: CALL_OW 110
37517: PUSH
37518: LD_INT 0
37520: NONEQUAL
37521: IFFALSE 37525
// continue ;
37523: GO 37505
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
37525: LD_VAR 0 3
37529: PPUSH
37530: CALL_OW 256
37534: PUSH
37535: LD_INT 1000
37537: LESS
37538: PUSH
37539: LD_VAR 0 3
37543: PPUSH
37544: LD_EXP 104
37548: PUSH
37549: LD_VAR 0 2
37553: ARRAY
37554: PPUSH
37555: CALL_OW 308
37559: NOT
37560: AND
37561: IFFALSE 37583
// ComMoveToArea ( j , mc_parking [ i ] ) ;
37563: LD_VAR 0 3
37567: PPUSH
37568: LD_EXP 104
37572: PUSH
37573: LD_VAR 0 2
37577: ARRAY
37578: PPUSH
37579: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
37583: LD_VAR 0 3
37587: PPUSH
37588: CALL_OW 256
37592: PUSH
37593: LD_INT 1000
37595: LESS
37596: PUSH
37597: LD_VAR 0 3
37601: PPUSH
37602: LD_EXP 104
37606: PUSH
37607: LD_VAR 0 2
37611: ARRAY
37612: PPUSH
37613: CALL_OW 308
37617: AND
37618: IFFALSE 37622
// continue ;
37620: GO 37505
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
37622: LD_VAR 0 3
37626: PPUSH
37627: CALL_OW 262
37631: PUSH
37632: LD_INT 2
37634: EQUAL
37635: PUSH
37636: LD_VAR 0 3
37640: PPUSH
37641: CALL_OW 261
37645: PUSH
37646: LD_INT 15
37648: LESS
37649: AND
37650: IFFALSE 37654
// continue ;
37652: GO 37505
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
37654: LD_VAR 0 3
37658: PPUSH
37659: CALL_OW 262
37663: PUSH
37664: LD_INT 1
37666: EQUAL
37667: PUSH
37668: LD_VAR 0 3
37672: PPUSH
37673: CALL_OW 261
37677: PUSH
37678: LD_INT 10
37680: LESS
37681: AND
37682: IFFALSE 37962
// begin if not depot then
37684: LD_VAR 0 9
37688: NOT
37689: IFFALSE 37693
// continue ;
37691: GO 37505
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
37693: LD_VAR 0 3
37697: PPUSH
37698: LD_VAR 0 9
37702: PPUSH
37703: LD_VAR 0 3
37707: PPUSH
37708: CALL_OW 74
37712: PPUSH
37713: CALL_OW 296
37717: PUSH
37718: LD_INT 6
37720: LESS
37721: IFFALSE 37737
// SetFuel ( j , 100 ) else
37723: LD_VAR 0 3
37727: PPUSH
37728: LD_INT 100
37730: PPUSH
37731: CALL_OW 240
37735: GO 37962
// if GetFuel ( j ) = 0 then
37737: LD_VAR 0 3
37741: PPUSH
37742: CALL_OW 261
37746: PUSH
37747: LD_INT 0
37749: EQUAL
37750: IFFALSE 37962
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37752: LD_ADDR_EXP 99
37756: PUSH
37757: LD_EXP 99
37761: PPUSH
37762: LD_VAR 0 2
37766: PPUSH
37767: LD_EXP 99
37771: PUSH
37772: LD_VAR 0 2
37776: ARRAY
37777: PUSH
37778: LD_VAR 0 3
37782: DIFF
37783: PPUSH
37784: CALL_OW 1
37788: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37789: LD_VAR 0 3
37793: PPUSH
37794: CALL_OW 263
37798: PUSH
37799: LD_INT 1
37801: EQUAL
37802: IFFALSE 37818
// ComExitVehicle ( IsInUnit ( j ) ) ;
37804: LD_VAR 0 3
37808: PPUSH
37809: CALL_OW 310
37813: PPUSH
37814: CALL_OW 121
// if GetControl ( j ) = control_remote then
37818: LD_VAR 0 3
37822: PPUSH
37823: CALL_OW 263
37827: PUSH
37828: LD_INT 2
37830: EQUAL
37831: IFFALSE 37842
// ComUnlink ( j ) ;
37833: LD_VAR 0 3
37837: PPUSH
37838: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37842: LD_ADDR_VAR 0 10
37846: PUSH
37847: LD_VAR 0 2
37851: PPUSH
37852: LD_INT 3
37854: PPUSH
37855: CALL 47606 0 2
37859: ST_TO_ADDR
// if fac then
37860: LD_VAR 0 10
37864: IFFALSE 37960
// begin for k in fac do
37866: LD_ADDR_VAR 0 4
37870: PUSH
37871: LD_VAR 0 10
37875: PUSH
37876: FOR_IN
37877: IFFALSE 37958
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37879: LD_ADDR_VAR 0 11
37883: PUSH
37884: LD_VAR 0 10
37888: PPUSH
37889: LD_VAR 0 3
37893: PPUSH
37894: CALL_OW 265
37898: PPUSH
37899: LD_VAR 0 3
37903: PPUSH
37904: CALL_OW 262
37908: PPUSH
37909: LD_VAR 0 3
37913: PPUSH
37914: CALL_OW 263
37918: PPUSH
37919: LD_VAR 0 3
37923: PPUSH
37924: CALL_OW 264
37928: PPUSH
37929: CALL 56058 0 5
37933: ST_TO_ADDR
// if components then
37934: LD_VAR 0 11
37938: IFFALSE 37956
// begin MC_InsertProduceList ( i , components ) ;
37940: LD_VAR 0 2
37944: PPUSH
37945: LD_VAR 0 11
37949: PPUSH
37950: CALL 47151 0 2
// break ;
37954: GO 37958
// end ; end ;
37956: GO 37876
37958: POP
37959: POP
// end ; continue ;
37960: GO 37505
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37962: LD_VAR 0 3
37966: PPUSH
37967: LD_INT 1
37969: PPUSH
37970: CALL_OW 289
37974: PUSH
37975: LD_INT 100
37977: LESS
37978: PUSH
37979: LD_VAR 0 3
37983: PPUSH
37984: CALL_OW 314
37988: NOT
37989: AND
37990: IFFALSE 38019
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37992: LD_VAR 0 3
37996: PPUSH
37997: LD_VAR 0 7
38001: PUSH
38002: LD_INT 2
38004: ARRAY
38005: PPUSH
38006: LD_VAR 0 7
38010: PUSH
38011: LD_INT 3
38013: ARRAY
38014: PPUSH
38015: CALL_OW 117
// break ;
38019: GO 38023
// end ;
38021: GO 37505
38023: POP
38024: POP
// end ; end ;
38025: GO 36221
38027: POP
38028: POP
// end ;
38029: LD_VAR 0 1
38033: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
38034: LD_INT 0
38036: PPUSH
38037: PPUSH
38038: PPUSH
38039: PPUSH
// if not mc_bases then
38040: LD_EXP 80
38044: NOT
38045: IFFALSE 38049
// exit ;
38047: GO 38210
// for i = 1 to mc_bases do
38049: LD_ADDR_VAR 0 2
38053: PUSH
38054: DOUBLE
38055: LD_INT 1
38057: DEC
38058: ST_TO_ADDR
38059: LD_EXP 80
38063: PUSH
38064: FOR_TO
38065: IFFALSE 38208
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
38067: LD_ADDR_VAR 0 4
38071: PUSH
38072: LD_EXP 99
38076: PUSH
38077: LD_VAR 0 2
38081: ARRAY
38082: PUSH
38083: LD_EXP 102
38087: PUSH
38088: LD_VAR 0 2
38092: ARRAY
38093: UNION
38094: PPUSH
38095: LD_INT 33
38097: PUSH
38098: LD_INT 2
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PPUSH
38105: CALL_OW 72
38109: ST_TO_ADDR
// if tmp then
38110: LD_VAR 0 4
38114: IFFALSE 38206
// for j in tmp do
38116: LD_ADDR_VAR 0 3
38120: PUSH
38121: LD_VAR 0 4
38125: PUSH
38126: FOR_IN
38127: IFFALSE 38204
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
38129: LD_VAR 0 3
38133: PPUSH
38134: CALL_OW 312
38138: NOT
38139: PUSH
38140: LD_VAR 0 3
38144: PPUSH
38145: CALL_OW 256
38149: PUSH
38150: LD_INT 250
38152: GREATEREQUAL
38153: AND
38154: IFFALSE 38167
// Connect ( j ) else
38156: LD_VAR 0 3
38160: PPUSH
38161: CALL 61906 0 1
38165: GO 38202
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
38167: LD_VAR 0 3
38171: PPUSH
38172: CALL_OW 256
38176: PUSH
38177: LD_INT 250
38179: LESS
38180: PUSH
38181: LD_VAR 0 3
38185: PPUSH
38186: CALL_OW 312
38190: AND
38191: IFFALSE 38202
// ComUnlink ( j ) ;
38193: LD_VAR 0 3
38197: PPUSH
38198: CALL_OW 136
38202: GO 38126
38204: POP
38205: POP
// end ;
38206: GO 38064
38208: POP
38209: POP
// end ;
38210: LD_VAR 0 1
38214: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
38215: LD_INT 0
38217: PPUSH
38218: PPUSH
38219: PPUSH
38220: PPUSH
38221: PPUSH
// if not mc_bases then
38222: LD_EXP 80
38226: NOT
38227: IFFALSE 38231
// exit ;
38229: GO 38676
// for i = 1 to mc_bases do
38231: LD_ADDR_VAR 0 2
38235: PUSH
38236: DOUBLE
38237: LD_INT 1
38239: DEC
38240: ST_TO_ADDR
38241: LD_EXP 80
38245: PUSH
38246: FOR_TO
38247: IFFALSE 38674
// begin if not mc_produce [ i ] then
38249: LD_EXP 101
38253: PUSH
38254: LD_VAR 0 2
38258: ARRAY
38259: NOT
38260: IFFALSE 38264
// continue ;
38262: GO 38246
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38264: LD_ADDR_VAR 0 5
38268: PUSH
38269: LD_EXP 80
38273: PUSH
38274: LD_VAR 0 2
38278: ARRAY
38279: PPUSH
38280: LD_INT 30
38282: PUSH
38283: LD_INT 3
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PPUSH
38290: CALL_OW 72
38294: ST_TO_ADDR
// if not fac then
38295: LD_VAR 0 5
38299: NOT
38300: IFFALSE 38304
// continue ;
38302: GO 38246
// for j in fac do
38304: LD_ADDR_VAR 0 3
38308: PUSH
38309: LD_VAR 0 5
38313: PUSH
38314: FOR_IN
38315: IFFALSE 38670
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
38317: LD_VAR 0 3
38321: PPUSH
38322: CALL_OW 461
38326: PUSH
38327: LD_INT 2
38329: NONEQUAL
38330: PUSH
38331: LD_VAR 0 3
38335: PPUSH
38336: LD_INT 15
38338: PPUSH
38339: CALL 61525 0 2
38343: PUSH
38344: LD_INT 4
38346: ARRAY
38347: OR
38348: IFFALSE 38352
// continue ;
38350: GO 38314
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
38352: LD_VAR 0 3
38356: PPUSH
38357: LD_EXP 101
38361: PUSH
38362: LD_VAR 0 2
38366: ARRAY
38367: PUSH
38368: LD_INT 1
38370: ARRAY
38371: PUSH
38372: LD_INT 1
38374: ARRAY
38375: PPUSH
38376: LD_EXP 101
38380: PUSH
38381: LD_VAR 0 2
38385: ARRAY
38386: PUSH
38387: LD_INT 1
38389: ARRAY
38390: PUSH
38391: LD_INT 2
38393: ARRAY
38394: PPUSH
38395: LD_EXP 101
38399: PUSH
38400: LD_VAR 0 2
38404: ARRAY
38405: PUSH
38406: LD_INT 1
38408: ARRAY
38409: PUSH
38410: LD_INT 3
38412: ARRAY
38413: PPUSH
38414: LD_EXP 101
38418: PUSH
38419: LD_VAR 0 2
38423: ARRAY
38424: PUSH
38425: LD_INT 1
38427: ARRAY
38428: PUSH
38429: LD_INT 4
38431: ARRAY
38432: PPUSH
38433: CALL_OW 448
38437: PUSH
38438: LD_VAR 0 3
38442: PPUSH
38443: LD_EXP 101
38447: PUSH
38448: LD_VAR 0 2
38452: ARRAY
38453: PUSH
38454: LD_INT 1
38456: ARRAY
38457: PUSH
38458: LD_INT 1
38460: ARRAY
38461: PUSH
38462: LD_EXP 101
38466: PUSH
38467: LD_VAR 0 2
38471: ARRAY
38472: PUSH
38473: LD_INT 1
38475: ARRAY
38476: PUSH
38477: LD_INT 2
38479: ARRAY
38480: PUSH
38481: LD_EXP 101
38485: PUSH
38486: LD_VAR 0 2
38490: ARRAY
38491: PUSH
38492: LD_INT 1
38494: ARRAY
38495: PUSH
38496: LD_INT 3
38498: ARRAY
38499: PUSH
38500: LD_EXP 101
38504: PUSH
38505: LD_VAR 0 2
38509: ARRAY
38510: PUSH
38511: LD_INT 1
38513: ARRAY
38514: PUSH
38515: LD_INT 4
38517: ARRAY
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: PPUSH
38525: CALL 65301 0 2
38529: AND
38530: IFFALSE 38668
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
38532: LD_VAR 0 3
38536: PPUSH
38537: LD_EXP 101
38541: PUSH
38542: LD_VAR 0 2
38546: ARRAY
38547: PUSH
38548: LD_INT 1
38550: ARRAY
38551: PUSH
38552: LD_INT 1
38554: ARRAY
38555: PPUSH
38556: LD_EXP 101
38560: PUSH
38561: LD_VAR 0 2
38565: ARRAY
38566: PUSH
38567: LD_INT 1
38569: ARRAY
38570: PUSH
38571: LD_INT 2
38573: ARRAY
38574: PPUSH
38575: LD_EXP 101
38579: PUSH
38580: LD_VAR 0 2
38584: ARRAY
38585: PUSH
38586: LD_INT 1
38588: ARRAY
38589: PUSH
38590: LD_INT 3
38592: ARRAY
38593: PPUSH
38594: LD_EXP 101
38598: PUSH
38599: LD_VAR 0 2
38603: ARRAY
38604: PUSH
38605: LD_INT 1
38607: ARRAY
38608: PUSH
38609: LD_INT 4
38611: ARRAY
38612: PPUSH
38613: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
38617: LD_ADDR_VAR 0 4
38621: PUSH
38622: LD_EXP 101
38626: PUSH
38627: LD_VAR 0 2
38631: ARRAY
38632: PPUSH
38633: LD_INT 1
38635: PPUSH
38636: CALL_OW 3
38640: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
38641: LD_ADDR_EXP 101
38645: PUSH
38646: LD_EXP 101
38650: PPUSH
38651: LD_VAR 0 2
38655: PPUSH
38656: LD_VAR 0 4
38660: PPUSH
38661: CALL_OW 1
38665: ST_TO_ADDR
// break ;
38666: GO 38670
// end ; end ;
38668: GO 38314
38670: POP
38671: POP
// end ;
38672: GO 38246
38674: POP
38675: POP
// end ;
38676: LD_VAR 0 1
38680: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
38681: LD_INT 0
38683: PPUSH
38684: PPUSH
38685: PPUSH
// if not mc_bases then
38686: LD_EXP 80
38690: NOT
38691: IFFALSE 38695
// exit ;
38693: GO 38784
// for i = 1 to mc_bases do
38695: LD_ADDR_VAR 0 2
38699: PUSH
38700: DOUBLE
38701: LD_INT 1
38703: DEC
38704: ST_TO_ADDR
38705: LD_EXP 80
38709: PUSH
38710: FOR_TO
38711: IFFALSE 38782
// begin if mc_attack [ i ] then
38713: LD_EXP 100
38717: PUSH
38718: LD_VAR 0 2
38722: ARRAY
38723: IFFALSE 38780
// begin tmp := mc_attack [ i ] [ 1 ] ;
38725: LD_ADDR_VAR 0 3
38729: PUSH
38730: LD_EXP 100
38734: PUSH
38735: LD_VAR 0 2
38739: ARRAY
38740: PUSH
38741: LD_INT 1
38743: ARRAY
38744: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38745: LD_ADDR_EXP 100
38749: PUSH
38750: LD_EXP 100
38754: PPUSH
38755: LD_VAR 0 2
38759: PPUSH
38760: EMPTY
38761: PPUSH
38762: CALL_OW 1
38766: ST_TO_ADDR
// Attack ( tmp ) ;
38767: LD_VAR 0 3
38771: PPUSH
38772: CALL 117624 0 1
// exit ;
38776: POP
38777: POP
38778: GO 38784
// end ; end ;
38780: GO 38710
38782: POP
38783: POP
// end ;
38784: LD_VAR 0 1
38788: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38789: LD_INT 0
38791: PPUSH
38792: PPUSH
38793: PPUSH
38794: PPUSH
38795: PPUSH
38796: PPUSH
38797: PPUSH
// if not mc_bases then
38798: LD_EXP 80
38802: NOT
38803: IFFALSE 38807
// exit ;
38805: GO 39664
// for i = 1 to mc_bases do
38807: LD_ADDR_VAR 0 2
38811: PUSH
38812: DOUBLE
38813: LD_INT 1
38815: DEC
38816: ST_TO_ADDR
38817: LD_EXP 80
38821: PUSH
38822: FOR_TO
38823: IFFALSE 39662
// begin if not mc_bases [ i ] then
38825: LD_EXP 80
38829: PUSH
38830: LD_VAR 0 2
38834: ARRAY
38835: NOT
38836: IFFALSE 38840
// continue ;
38838: GO 38822
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38840: LD_ADDR_VAR 0 7
38844: PUSH
38845: LD_EXP 80
38849: PUSH
38850: LD_VAR 0 2
38854: ARRAY
38855: PUSH
38856: LD_INT 1
38858: ARRAY
38859: PPUSH
38860: CALL 55384 0 1
38864: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38865: LD_ADDR_EXP 103
38869: PUSH
38870: LD_EXP 103
38874: PPUSH
38875: LD_VAR 0 2
38879: PPUSH
38880: LD_EXP 80
38884: PUSH
38885: LD_VAR 0 2
38889: ARRAY
38890: PUSH
38891: LD_INT 1
38893: ARRAY
38894: PPUSH
38895: CALL_OW 255
38899: PPUSH
38900: LD_EXP 105
38904: PUSH
38905: LD_VAR 0 2
38909: ARRAY
38910: PPUSH
38911: CALL 55349 0 2
38915: PPUSH
38916: CALL_OW 1
38920: ST_TO_ADDR
// if not mc_scan [ i ] then
38921: LD_EXP 103
38925: PUSH
38926: LD_VAR 0 2
38930: ARRAY
38931: NOT
38932: IFFALSE 39110
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38934: LD_ADDR_EXP 123
38938: PUSH
38939: LD_EXP 123
38943: PPUSH
38944: LD_VAR 0 2
38948: PPUSH
38949: LD_INT 0
38951: PPUSH
38952: CALL_OW 1
38956: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38957: LD_ADDR_VAR 0 4
38961: PUSH
38962: LD_EXP 80
38966: PUSH
38967: LD_VAR 0 2
38971: ARRAY
38972: PPUSH
38973: LD_INT 2
38975: PUSH
38976: LD_INT 25
38978: PUSH
38979: LD_INT 5
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 25
38988: PUSH
38989: LD_INT 8
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: LD_INT 25
38998: PUSH
38999: LD_INT 9
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: PPUSH
39012: CALL_OW 72
39016: ST_TO_ADDR
// if not tmp then
39017: LD_VAR 0 4
39021: NOT
39022: IFFALSE 39026
// continue ;
39024: GO 38822
// for j in tmp do
39026: LD_ADDR_VAR 0 3
39030: PUSH
39031: LD_VAR 0 4
39035: PUSH
39036: FOR_IN
39037: IFFALSE 39108
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
39039: LD_VAR 0 3
39043: PPUSH
39044: CALL_OW 310
39048: PPUSH
39049: CALL_OW 266
39053: PUSH
39054: LD_INT 5
39056: EQUAL
39057: PUSH
39058: LD_VAR 0 3
39062: PPUSH
39063: CALL_OW 257
39067: PUSH
39068: LD_INT 1
39070: EQUAL
39071: AND
39072: PUSH
39073: LD_VAR 0 3
39077: PPUSH
39078: CALL_OW 459
39082: NOT
39083: AND
39084: PUSH
39085: LD_VAR 0 7
39089: AND
39090: IFFALSE 39106
// ComChangeProfession ( j , class ) ;
39092: LD_VAR 0 3
39096: PPUSH
39097: LD_VAR 0 7
39101: PPUSH
39102: CALL_OW 123
39106: GO 39036
39108: POP
39109: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
39110: LD_EXP 103
39114: PUSH
39115: LD_VAR 0 2
39119: ARRAY
39120: PUSH
39121: LD_EXP 123
39125: PUSH
39126: LD_VAR 0 2
39130: ARRAY
39131: NOT
39132: AND
39133: PUSH
39134: LD_EXP 102
39138: PUSH
39139: LD_VAR 0 2
39143: ARRAY
39144: NOT
39145: AND
39146: PUSH
39147: LD_EXP 80
39151: PUSH
39152: LD_VAR 0 2
39156: ARRAY
39157: PPUSH
39158: LD_INT 50
39160: PUSH
39161: EMPTY
39162: LIST
39163: PUSH
39164: LD_INT 2
39166: PUSH
39167: LD_INT 30
39169: PUSH
39170: LD_INT 32
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 30
39179: PUSH
39180: LD_INT 33
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 30
39189: PUSH
39190: LD_INT 4
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 30
39199: PUSH
39200: LD_INT 5
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: LIST
39211: LIST
39212: LIST
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PPUSH
39218: CALL_OW 72
39222: PUSH
39223: LD_INT 4
39225: LESS
39226: PUSH
39227: LD_EXP 80
39231: PUSH
39232: LD_VAR 0 2
39236: ARRAY
39237: PPUSH
39238: LD_INT 3
39240: PUSH
39241: LD_INT 24
39243: PUSH
39244: LD_INT 1000
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 2
39257: PUSH
39258: LD_INT 30
39260: PUSH
39261: LD_INT 0
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 30
39270: PUSH
39271: LD_INT 1
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: LIST
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PPUSH
39287: CALL_OW 72
39291: OR
39292: AND
39293: IFFALSE 39544
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39295: LD_ADDR_EXP 123
39299: PUSH
39300: LD_EXP 123
39304: PPUSH
39305: LD_VAR 0 2
39309: PPUSH
39310: LD_INT 1
39312: PPUSH
39313: CALL_OW 1
39317: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39318: LD_ADDR_VAR 0 4
39322: PUSH
39323: LD_EXP 80
39327: PUSH
39328: LD_VAR 0 2
39332: ARRAY
39333: PPUSH
39334: LD_INT 2
39336: PUSH
39337: LD_INT 25
39339: PUSH
39340: LD_INT 1
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 25
39349: PUSH
39350: LD_INT 5
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 25
39359: PUSH
39360: LD_INT 8
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 25
39369: PUSH
39370: LD_INT 9
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: LIST
39381: LIST
39382: LIST
39383: PPUSH
39384: CALL_OW 72
39388: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
39389: LD_ADDR_VAR 0 4
39393: PUSH
39394: LD_VAR 0 4
39398: PUSH
39399: LD_VAR 0 4
39403: PPUSH
39404: LD_INT 18
39406: PPUSH
39407: CALL 88878 0 2
39411: DIFF
39412: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
39413: LD_VAR 0 4
39417: NOT
39418: PUSH
39419: LD_EXP 80
39423: PUSH
39424: LD_VAR 0 2
39428: ARRAY
39429: PPUSH
39430: LD_INT 2
39432: PUSH
39433: LD_INT 30
39435: PUSH
39436: LD_INT 4
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 30
39445: PUSH
39446: LD_INT 5
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: LIST
39457: PPUSH
39458: CALL_OW 72
39462: NOT
39463: AND
39464: IFFALSE 39526
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
39466: LD_ADDR_VAR 0 4
39470: PUSH
39471: LD_EXP 80
39475: PUSH
39476: LD_VAR 0 2
39480: ARRAY
39481: PPUSH
39482: LD_INT 2
39484: PUSH
39485: LD_INT 25
39487: PUSH
39488: LD_INT 2
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 25
39497: PUSH
39498: LD_INT 3
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 25
39507: PUSH
39508: LD_INT 4
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: PPUSH
39521: CALL_OW 72
39525: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
39526: LD_VAR 0 2
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL 122333 0 2
// exit ;
39540: POP
39541: POP
39542: GO 39664
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
39544: LD_EXP 103
39548: PUSH
39549: LD_VAR 0 2
39553: ARRAY
39554: PUSH
39555: LD_EXP 123
39559: PUSH
39560: LD_VAR 0 2
39564: ARRAY
39565: NOT
39566: AND
39567: PUSH
39568: LD_EXP 102
39572: PUSH
39573: LD_VAR 0 2
39577: ARRAY
39578: AND
39579: IFFALSE 39660
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39581: LD_ADDR_EXP 123
39585: PUSH
39586: LD_EXP 123
39590: PPUSH
39591: LD_VAR 0 2
39595: PPUSH
39596: LD_INT 1
39598: PPUSH
39599: CALL_OW 1
39603: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
39604: LD_ADDR_VAR 0 4
39608: PUSH
39609: LD_EXP 102
39613: PUSH
39614: LD_VAR 0 2
39618: ARRAY
39619: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39620: LD_ADDR_EXP 102
39624: PUSH
39625: LD_EXP 102
39629: PPUSH
39630: LD_VAR 0 2
39634: PPUSH
39635: EMPTY
39636: PPUSH
39637: CALL_OW 1
39641: ST_TO_ADDR
// Defend ( i , tmp ) ;
39642: LD_VAR 0 2
39646: PPUSH
39647: LD_VAR 0 4
39651: PPUSH
39652: CALL 122929 0 2
// exit ;
39656: POP
39657: POP
39658: GO 39664
// end ; end ;
39660: GO 38822
39662: POP
39663: POP
// end ;
39664: LD_VAR 0 1
39668: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
39669: LD_INT 0
39671: PPUSH
39672: PPUSH
39673: PPUSH
39674: PPUSH
39675: PPUSH
39676: PPUSH
39677: PPUSH
39678: PPUSH
39679: PPUSH
39680: PPUSH
39681: PPUSH
// if not mc_bases then
39682: LD_EXP 80
39686: NOT
39687: IFFALSE 39691
// exit ;
39689: GO 40778
// for i = 1 to mc_bases do
39691: LD_ADDR_VAR 0 2
39695: PUSH
39696: DOUBLE
39697: LD_INT 1
39699: DEC
39700: ST_TO_ADDR
39701: LD_EXP 80
39705: PUSH
39706: FOR_TO
39707: IFFALSE 40776
// begin tmp := mc_lab [ i ] ;
39709: LD_ADDR_VAR 0 6
39713: PUSH
39714: LD_EXP 113
39718: PUSH
39719: LD_VAR 0 2
39723: ARRAY
39724: ST_TO_ADDR
// if not tmp then
39725: LD_VAR 0 6
39729: NOT
39730: IFFALSE 39734
// continue ;
39732: GO 39706
// idle_lab := 0 ;
39734: LD_ADDR_VAR 0 11
39738: PUSH
39739: LD_INT 0
39741: ST_TO_ADDR
// for j in tmp do
39742: LD_ADDR_VAR 0 3
39746: PUSH
39747: LD_VAR 0 6
39751: PUSH
39752: FOR_IN
39753: IFFALSE 40772
// begin researching := false ;
39755: LD_ADDR_VAR 0 10
39759: PUSH
39760: LD_INT 0
39762: ST_TO_ADDR
// side := GetSide ( j ) ;
39763: LD_ADDR_VAR 0 4
39767: PUSH
39768: LD_VAR 0 3
39772: PPUSH
39773: CALL_OW 255
39777: ST_TO_ADDR
// if not mc_tech [ side ] then
39778: LD_EXP 107
39782: PUSH
39783: LD_VAR 0 4
39787: ARRAY
39788: NOT
39789: IFFALSE 39793
// continue ;
39791: GO 39752
// if BuildingStatus ( j ) = bs_idle then
39793: LD_VAR 0 3
39797: PPUSH
39798: CALL_OW 461
39802: PUSH
39803: LD_INT 2
39805: EQUAL
39806: IFFALSE 39994
// begin if idle_lab and UnitsInside ( j ) < 6 then
39808: LD_VAR 0 11
39812: PUSH
39813: LD_VAR 0 3
39817: PPUSH
39818: CALL_OW 313
39822: PUSH
39823: LD_INT 6
39825: LESS
39826: AND
39827: IFFALSE 39898
// begin tmp2 := UnitsInside ( idle_lab ) ;
39829: LD_ADDR_VAR 0 9
39833: PUSH
39834: LD_VAR 0 11
39838: PPUSH
39839: CALL_OW 313
39843: ST_TO_ADDR
// if tmp2 then
39844: LD_VAR 0 9
39848: IFFALSE 39890
// for x in tmp2 do
39850: LD_ADDR_VAR 0 7
39854: PUSH
39855: LD_VAR 0 9
39859: PUSH
39860: FOR_IN
39861: IFFALSE 39888
// begin ComExitBuilding ( x ) ;
39863: LD_VAR 0 7
39867: PPUSH
39868: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39872: LD_VAR 0 7
39876: PPUSH
39877: LD_VAR 0 3
39881: PPUSH
39882: CALL_OW 180
// end ;
39886: GO 39860
39888: POP
39889: POP
// idle_lab := 0 ;
39890: LD_ADDR_VAR 0 11
39894: PUSH
39895: LD_INT 0
39897: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39898: LD_ADDR_VAR 0 5
39902: PUSH
39903: LD_EXP 107
39907: PUSH
39908: LD_VAR 0 4
39912: ARRAY
39913: PUSH
39914: FOR_IN
39915: IFFALSE 39975
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39917: LD_VAR 0 3
39921: PPUSH
39922: LD_VAR 0 5
39926: PPUSH
39927: CALL_OW 430
39931: PUSH
39932: LD_VAR 0 4
39936: PPUSH
39937: LD_VAR 0 5
39941: PPUSH
39942: CALL 54454 0 2
39946: AND
39947: IFFALSE 39973
// begin researching := true ;
39949: LD_ADDR_VAR 0 10
39953: PUSH
39954: LD_INT 1
39956: ST_TO_ADDR
// ComResearch ( j , t ) ;
39957: LD_VAR 0 3
39961: PPUSH
39962: LD_VAR 0 5
39966: PPUSH
39967: CALL_OW 124
// break ;
39971: GO 39975
// end ;
39973: GO 39914
39975: POP
39976: POP
// if not researching then
39977: LD_VAR 0 10
39981: NOT
39982: IFFALSE 39994
// idle_lab := j ;
39984: LD_ADDR_VAR 0 11
39988: PUSH
39989: LD_VAR 0 3
39993: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39994: LD_VAR 0 3
39998: PPUSH
39999: CALL_OW 461
40003: PUSH
40004: LD_INT 10
40006: EQUAL
40007: IFFALSE 40595
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
40009: LD_EXP 109
40013: PUSH
40014: LD_VAR 0 2
40018: ARRAY
40019: NOT
40020: PUSH
40021: LD_EXP 110
40025: PUSH
40026: LD_VAR 0 2
40030: ARRAY
40031: NOT
40032: AND
40033: PUSH
40034: LD_EXP 107
40038: PUSH
40039: LD_VAR 0 4
40043: ARRAY
40044: PUSH
40045: LD_INT 1
40047: GREATER
40048: AND
40049: IFFALSE 40180
// begin ComCancel ( j ) ;
40051: LD_VAR 0 3
40055: PPUSH
40056: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
40060: LD_ADDR_EXP 107
40064: PUSH
40065: LD_EXP 107
40069: PPUSH
40070: LD_VAR 0 4
40074: PPUSH
40075: LD_EXP 107
40079: PUSH
40080: LD_VAR 0 4
40084: ARRAY
40085: PPUSH
40086: LD_EXP 107
40090: PUSH
40091: LD_VAR 0 4
40095: ARRAY
40096: PUSH
40097: LD_INT 1
40099: MINUS
40100: PPUSH
40101: LD_EXP 107
40105: PUSH
40106: LD_VAR 0 4
40110: ARRAY
40111: PPUSH
40112: LD_INT 0
40114: PPUSH
40115: CALL 57978 0 4
40119: PPUSH
40120: CALL_OW 1
40124: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
40125: LD_ADDR_EXP 107
40129: PUSH
40130: LD_EXP 107
40134: PPUSH
40135: LD_VAR 0 4
40139: PPUSH
40140: LD_EXP 107
40144: PUSH
40145: LD_VAR 0 4
40149: ARRAY
40150: PPUSH
40151: LD_EXP 107
40155: PUSH
40156: LD_VAR 0 4
40160: ARRAY
40161: PPUSH
40162: LD_INT 1
40164: PPUSH
40165: LD_INT 0
40167: PPUSH
40168: CALL 57978 0 4
40172: PPUSH
40173: CALL_OW 1
40177: ST_TO_ADDR
// continue ;
40178: GO 39752
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
40180: LD_EXP 109
40184: PUSH
40185: LD_VAR 0 2
40189: ARRAY
40190: PUSH
40191: LD_EXP 110
40195: PUSH
40196: LD_VAR 0 2
40200: ARRAY
40201: NOT
40202: AND
40203: IFFALSE 40330
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
40205: LD_ADDR_EXP 110
40209: PUSH
40210: LD_EXP 110
40214: PPUSH
40215: LD_VAR 0 2
40219: PUSH
40220: LD_EXP 110
40224: PUSH
40225: LD_VAR 0 2
40229: ARRAY
40230: PUSH
40231: LD_INT 1
40233: PLUS
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PPUSH
40239: LD_EXP 109
40243: PUSH
40244: LD_VAR 0 2
40248: ARRAY
40249: PUSH
40250: LD_INT 1
40252: ARRAY
40253: PPUSH
40254: CALL 58560 0 3
40258: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
40259: LD_EXP 109
40263: PUSH
40264: LD_VAR 0 2
40268: ARRAY
40269: PUSH
40270: LD_INT 1
40272: ARRAY
40273: PPUSH
40274: LD_INT 112
40276: PPUSH
40277: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
40281: LD_ADDR_VAR 0 9
40285: PUSH
40286: LD_EXP 109
40290: PUSH
40291: LD_VAR 0 2
40295: ARRAY
40296: PPUSH
40297: LD_INT 1
40299: PPUSH
40300: CALL_OW 3
40304: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
40305: LD_ADDR_EXP 109
40309: PUSH
40310: LD_EXP 109
40314: PPUSH
40315: LD_VAR 0 2
40319: PPUSH
40320: LD_VAR 0 9
40324: PPUSH
40325: CALL_OW 1
40329: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
40330: LD_EXP 109
40334: PUSH
40335: LD_VAR 0 2
40339: ARRAY
40340: PUSH
40341: LD_EXP 110
40345: PUSH
40346: LD_VAR 0 2
40350: ARRAY
40351: AND
40352: PUSH
40353: LD_EXP 110
40357: PUSH
40358: LD_VAR 0 2
40362: ARRAY
40363: PUSH
40364: LD_INT 1
40366: ARRAY
40367: PPUSH
40368: CALL_OW 310
40372: NOT
40373: AND
40374: PUSH
40375: LD_VAR 0 3
40379: PPUSH
40380: CALL_OW 313
40384: PUSH
40385: LD_INT 6
40387: EQUAL
40388: AND
40389: IFFALSE 40445
// begin tmp2 := UnitsInside ( j ) ;
40391: LD_ADDR_VAR 0 9
40395: PUSH
40396: LD_VAR 0 3
40400: PPUSH
40401: CALL_OW 313
40405: ST_TO_ADDR
// if tmp2 = 6 then
40406: LD_VAR 0 9
40410: PUSH
40411: LD_INT 6
40413: EQUAL
40414: IFFALSE 40445
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
40416: LD_VAR 0 9
40420: PUSH
40421: LD_INT 1
40423: ARRAY
40424: PPUSH
40425: LD_INT 112
40427: PPUSH
40428: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
40432: LD_VAR 0 9
40436: PUSH
40437: LD_INT 1
40439: ARRAY
40440: PPUSH
40441: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
40445: LD_EXP 110
40449: PUSH
40450: LD_VAR 0 2
40454: ARRAY
40455: PUSH
40456: LD_EXP 110
40460: PUSH
40461: LD_VAR 0 2
40465: ARRAY
40466: PUSH
40467: LD_INT 1
40469: ARRAY
40470: PPUSH
40471: CALL_OW 314
40475: NOT
40476: AND
40477: PUSH
40478: LD_EXP 110
40482: PUSH
40483: LD_VAR 0 2
40487: ARRAY
40488: PUSH
40489: LD_INT 1
40491: ARRAY
40492: PPUSH
40493: CALL_OW 310
40497: NOT
40498: AND
40499: IFFALSE 40525
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
40501: LD_EXP 110
40505: PUSH
40506: LD_VAR 0 2
40510: ARRAY
40511: PUSH
40512: LD_INT 1
40514: ARRAY
40515: PPUSH
40516: LD_VAR 0 3
40520: PPUSH
40521: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
40525: LD_EXP 110
40529: PUSH
40530: LD_VAR 0 2
40534: ARRAY
40535: PUSH
40536: LD_INT 1
40538: ARRAY
40539: PPUSH
40540: CALL_OW 310
40544: PUSH
40545: LD_EXP 110
40549: PUSH
40550: LD_VAR 0 2
40554: ARRAY
40555: PUSH
40556: LD_INT 1
40558: ARRAY
40559: PPUSH
40560: CALL_OW 310
40564: PPUSH
40565: CALL_OW 461
40569: PUSH
40570: LD_INT 3
40572: NONEQUAL
40573: AND
40574: IFFALSE 40595
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
40576: LD_EXP 110
40580: PUSH
40581: LD_VAR 0 2
40585: ARRAY
40586: PUSH
40587: LD_INT 1
40589: ARRAY
40590: PPUSH
40591: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
40595: LD_VAR 0 3
40599: PPUSH
40600: CALL_OW 461
40604: PUSH
40605: LD_INT 6
40607: EQUAL
40608: PUSH
40609: LD_VAR 0 6
40613: PUSH
40614: LD_INT 1
40616: GREATER
40617: AND
40618: IFFALSE 40770
// begin sci := [ ] ;
40620: LD_ADDR_VAR 0 8
40624: PUSH
40625: EMPTY
40626: ST_TO_ADDR
// for x in ( tmp diff j ) do
40627: LD_ADDR_VAR 0 7
40631: PUSH
40632: LD_VAR 0 6
40636: PUSH
40637: LD_VAR 0 3
40641: DIFF
40642: PUSH
40643: FOR_IN
40644: IFFALSE 40696
// begin if sci = 6 then
40646: LD_VAR 0 8
40650: PUSH
40651: LD_INT 6
40653: EQUAL
40654: IFFALSE 40658
// break ;
40656: GO 40696
// if BuildingStatus ( x ) = bs_idle then
40658: LD_VAR 0 7
40662: PPUSH
40663: CALL_OW 461
40667: PUSH
40668: LD_INT 2
40670: EQUAL
40671: IFFALSE 40694
// sci := sci ^ UnitsInside ( x ) ;
40673: LD_ADDR_VAR 0 8
40677: PUSH
40678: LD_VAR 0 8
40682: PUSH
40683: LD_VAR 0 7
40687: PPUSH
40688: CALL_OW 313
40692: ADD
40693: ST_TO_ADDR
// end ;
40694: GO 40643
40696: POP
40697: POP
// if not sci then
40698: LD_VAR 0 8
40702: NOT
40703: IFFALSE 40707
// continue ;
40705: GO 39752
// for x in sci do
40707: LD_ADDR_VAR 0 7
40711: PUSH
40712: LD_VAR 0 8
40716: PUSH
40717: FOR_IN
40718: IFFALSE 40768
// if IsInUnit ( x ) and not HasTask ( x ) then
40720: LD_VAR 0 7
40724: PPUSH
40725: CALL_OW 310
40729: PUSH
40730: LD_VAR 0 7
40734: PPUSH
40735: CALL_OW 314
40739: NOT
40740: AND
40741: IFFALSE 40766
// begin ComExitBuilding ( x ) ;
40743: LD_VAR 0 7
40747: PPUSH
40748: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40752: LD_VAR 0 7
40756: PPUSH
40757: LD_VAR 0 3
40761: PPUSH
40762: CALL_OW 180
// end ;
40766: GO 40717
40768: POP
40769: POP
// end ; end ;
40770: GO 39752
40772: POP
40773: POP
// end ;
40774: GO 39706
40776: POP
40777: POP
// end ;
40778: LD_VAR 0 1
40782: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40783: LD_INT 0
40785: PPUSH
40786: PPUSH
// if not mc_bases then
40787: LD_EXP 80
40791: NOT
40792: IFFALSE 40796
// exit ;
40794: GO 40877
// for i = 1 to mc_bases do
40796: LD_ADDR_VAR 0 2
40800: PUSH
40801: DOUBLE
40802: LD_INT 1
40804: DEC
40805: ST_TO_ADDR
40806: LD_EXP 80
40810: PUSH
40811: FOR_TO
40812: IFFALSE 40875
// if mc_mines [ i ] and mc_miners [ i ] then
40814: LD_EXP 93
40818: PUSH
40819: LD_VAR 0 2
40823: ARRAY
40824: PUSH
40825: LD_EXP 94
40829: PUSH
40830: LD_VAR 0 2
40834: ARRAY
40835: AND
40836: IFFALSE 40873
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40838: LD_EXP 94
40842: PUSH
40843: LD_VAR 0 2
40847: ARRAY
40848: PUSH
40849: LD_INT 1
40851: ARRAY
40852: PPUSH
40853: CALL_OW 255
40857: PPUSH
40858: LD_EXP 93
40862: PUSH
40863: LD_VAR 0 2
40867: ARRAY
40868: PPUSH
40869: CALL 55537 0 2
40873: GO 40811
40875: POP
40876: POP
// end ;
40877: LD_VAR 0 1
40881: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40882: LD_INT 0
40884: PPUSH
40885: PPUSH
40886: PPUSH
40887: PPUSH
40888: PPUSH
40889: PPUSH
40890: PPUSH
40891: PPUSH
// if not mc_bases or not mc_parking then
40892: LD_EXP 80
40896: NOT
40897: PUSH
40898: LD_EXP 104
40902: NOT
40903: OR
40904: IFFALSE 40908
// exit ;
40906: GO 41646
// for i = 1 to mc_bases do
40908: LD_ADDR_VAR 0 2
40912: PUSH
40913: DOUBLE
40914: LD_INT 1
40916: DEC
40917: ST_TO_ADDR
40918: LD_EXP 80
40922: PUSH
40923: FOR_TO
40924: IFFALSE 41644
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40926: LD_EXP 80
40930: PUSH
40931: LD_VAR 0 2
40935: ARRAY
40936: NOT
40937: PUSH
40938: LD_EXP 104
40942: PUSH
40943: LD_VAR 0 2
40947: ARRAY
40948: NOT
40949: OR
40950: IFFALSE 40954
// continue ;
40952: GO 40923
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40954: LD_ADDR_VAR 0 5
40958: PUSH
40959: LD_EXP 80
40963: PUSH
40964: LD_VAR 0 2
40968: ARRAY
40969: PUSH
40970: LD_INT 1
40972: ARRAY
40973: PPUSH
40974: CALL_OW 255
40978: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40979: LD_ADDR_VAR 0 6
40983: PUSH
40984: LD_EXP 80
40988: PUSH
40989: LD_VAR 0 2
40993: ARRAY
40994: PPUSH
40995: LD_INT 30
40997: PUSH
40998: LD_INT 3
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PPUSH
41005: CALL_OW 72
41009: ST_TO_ADDR
// if not fac then
41010: LD_VAR 0 6
41014: NOT
41015: IFFALSE 41066
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41017: LD_ADDR_VAR 0 6
41021: PUSH
41022: LD_EXP 80
41026: PUSH
41027: LD_VAR 0 2
41031: ARRAY
41032: PPUSH
41033: LD_INT 2
41035: PUSH
41036: LD_INT 30
41038: PUSH
41039: LD_INT 0
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 30
41048: PUSH
41049: LD_INT 1
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: LIST
41060: PPUSH
41061: CALL_OW 72
41065: ST_TO_ADDR
// if not fac then
41066: LD_VAR 0 6
41070: NOT
41071: IFFALSE 41075
// continue ;
41073: GO 40923
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41075: LD_ADDR_VAR 0 7
41079: PUSH
41080: LD_EXP 104
41084: PUSH
41085: LD_VAR 0 2
41089: ARRAY
41090: PPUSH
41091: LD_INT 22
41093: PUSH
41094: LD_VAR 0 5
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 21
41105: PUSH
41106: LD_INT 2
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: LD_INT 3
41115: PUSH
41116: LD_INT 60
41118: PUSH
41119: EMPTY
41120: LIST
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 3
41128: PUSH
41129: LD_INT 24
41131: PUSH
41132: LD_INT 1000
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: LIST
41147: LIST
41148: PPUSH
41149: CALL_OW 70
41153: ST_TO_ADDR
// for j in fac do
41154: LD_ADDR_VAR 0 3
41158: PUSH
41159: LD_VAR 0 6
41163: PUSH
41164: FOR_IN
41165: IFFALSE 41260
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41167: LD_ADDR_VAR 0 7
41171: PUSH
41172: LD_VAR 0 7
41176: PUSH
41177: LD_INT 22
41179: PUSH
41180: LD_VAR 0 5
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 91
41191: PUSH
41192: LD_VAR 0 3
41196: PUSH
41197: LD_INT 15
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: LIST
41204: PUSH
41205: LD_INT 21
41207: PUSH
41208: LD_INT 2
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 3
41217: PUSH
41218: LD_INT 60
41220: PUSH
41221: EMPTY
41222: LIST
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 3
41230: PUSH
41231: LD_INT 24
41233: PUSH
41234: LD_INT 1000
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: PPUSH
41252: CALL_OW 69
41256: UNION
41257: ST_TO_ADDR
41258: GO 41164
41260: POP
41261: POP
// if not vehs then
41262: LD_VAR 0 7
41266: NOT
41267: IFFALSE 41293
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41269: LD_ADDR_EXP 92
41273: PUSH
41274: LD_EXP 92
41278: PPUSH
41279: LD_VAR 0 2
41283: PPUSH
41284: EMPTY
41285: PPUSH
41286: CALL_OW 1
41290: ST_TO_ADDR
// continue ;
41291: GO 40923
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41293: LD_ADDR_VAR 0 8
41297: PUSH
41298: LD_EXP 80
41302: PUSH
41303: LD_VAR 0 2
41307: ARRAY
41308: PPUSH
41309: LD_INT 30
41311: PUSH
41312: LD_INT 3
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PPUSH
41319: CALL_OW 72
41323: ST_TO_ADDR
// if tmp then
41324: LD_VAR 0 8
41328: IFFALSE 41431
// begin for j in tmp do
41330: LD_ADDR_VAR 0 3
41334: PUSH
41335: LD_VAR 0 8
41339: PUSH
41340: FOR_IN
41341: IFFALSE 41429
// for k in UnitsInside ( j ) do
41343: LD_ADDR_VAR 0 4
41347: PUSH
41348: LD_VAR 0 3
41352: PPUSH
41353: CALL_OW 313
41357: PUSH
41358: FOR_IN
41359: IFFALSE 41425
// if k then
41361: LD_VAR 0 4
41365: IFFALSE 41423
// if not k in mc_repair_vehicle [ i ] then
41367: LD_VAR 0 4
41371: PUSH
41372: LD_EXP 92
41376: PUSH
41377: LD_VAR 0 2
41381: ARRAY
41382: IN
41383: NOT
41384: IFFALSE 41423
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
41386: LD_ADDR_EXP 92
41390: PUSH
41391: LD_EXP 92
41395: PPUSH
41396: LD_VAR 0 2
41400: PPUSH
41401: LD_EXP 92
41405: PUSH
41406: LD_VAR 0 2
41410: ARRAY
41411: PUSH
41412: LD_VAR 0 4
41416: UNION
41417: PPUSH
41418: CALL_OW 1
41422: ST_TO_ADDR
41423: GO 41358
41425: POP
41426: POP
41427: GO 41340
41429: POP
41430: POP
// end ; if not mc_repair_vehicle [ i ] then
41431: LD_EXP 92
41435: PUSH
41436: LD_VAR 0 2
41440: ARRAY
41441: NOT
41442: IFFALSE 41446
// continue ;
41444: GO 40923
// for j in mc_repair_vehicle [ i ] do
41446: LD_ADDR_VAR 0 3
41450: PUSH
41451: LD_EXP 92
41455: PUSH
41456: LD_VAR 0 2
41460: ARRAY
41461: PUSH
41462: FOR_IN
41463: IFFALSE 41640
// begin if GetClass ( j ) <> 3 then
41465: LD_VAR 0 3
41469: PPUSH
41470: CALL_OW 257
41474: PUSH
41475: LD_INT 3
41477: NONEQUAL
41478: IFFALSE 41519
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
41480: LD_ADDR_EXP 92
41484: PUSH
41485: LD_EXP 92
41489: PPUSH
41490: LD_VAR 0 2
41494: PPUSH
41495: LD_EXP 92
41499: PUSH
41500: LD_VAR 0 2
41504: ARRAY
41505: PUSH
41506: LD_VAR 0 3
41510: DIFF
41511: PPUSH
41512: CALL_OW 1
41516: ST_TO_ADDR
// continue ;
41517: GO 41462
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41519: LD_VAR 0 3
41523: PPUSH
41524: CALL_OW 311
41528: NOT
41529: PUSH
41530: LD_VAR 0 3
41534: PUSH
41535: LD_EXP 83
41539: PUSH
41540: LD_VAR 0 2
41544: ARRAY
41545: PUSH
41546: LD_INT 1
41548: ARRAY
41549: IN
41550: NOT
41551: AND
41552: PUSH
41553: LD_VAR 0 3
41557: PUSH
41558: LD_EXP 83
41562: PUSH
41563: LD_VAR 0 2
41567: ARRAY
41568: PUSH
41569: LD_INT 2
41571: ARRAY
41572: IN
41573: NOT
41574: AND
41575: IFFALSE 41638
// begin if IsInUnit ( j ) then
41577: LD_VAR 0 3
41581: PPUSH
41582: CALL_OW 310
41586: IFFALSE 41599
// ComExitBuilding ( j ) else
41588: LD_VAR 0 3
41592: PPUSH
41593: CALL_OW 122
41597: GO 41638
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
41599: LD_VAR 0 3
41603: PPUSH
41604: LD_VAR 0 7
41608: PUSH
41609: LD_INT 1
41611: ARRAY
41612: PPUSH
41613: CALL 93374 0 2
41617: NOT
41618: IFFALSE 41638
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
41620: LD_VAR 0 3
41624: PPUSH
41625: LD_VAR 0 7
41629: PUSH
41630: LD_INT 1
41632: ARRAY
41633: PPUSH
41634: CALL_OW 129
// end ; end ;
41638: GO 41462
41640: POP
41641: POP
// end ;
41642: GO 40923
41644: POP
41645: POP
// end ;
41646: LD_VAR 0 1
41650: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
41651: LD_INT 0
41653: PPUSH
41654: PPUSH
41655: PPUSH
41656: PPUSH
41657: PPUSH
41658: PPUSH
41659: PPUSH
41660: PPUSH
41661: PPUSH
41662: PPUSH
41663: PPUSH
// if not mc_bases then
41664: LD_EXP 80
41668: NOT
41669: IFFALSE 41673
// exit ;
41671: GO 42475
// for i = 1 to mc_bases do
41673: LD_ADDR_VAR 0 2
41677: PUSH
41678: DOUBLE
41679: LD_INT 1
41681: DEC
41682: ST_TO_ADDR
41683: LD_EXP 80
41687: PUSH
41688: FOR_TO
41689: IFFALSE 42473
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
41691: LD_EXP 108
41695: PUSH
41696: LD_VAR 0 2
41700: ARRAY
41701: NOT
41702: PUSH
41703: LD_EXP 83
41707: PUSH
41708: LD_VAR 0 2
41712: ARRAY
41713: PUSH
41714: LD_INT 1
41716: ARRAY
41717: OR
41718: PUSH
41719: LD_EXP 83
41723: PUSH
41724: LD_VAR 0 2
41728: ARRAY
41729: PUSH
41730: LD_INT 2
41732: ARRAY
41733: OR
41734: PUSH
41735: LD_EXP 106
41739: PUSH
41740: LD_VAR 0 2
41744: ARRAY
41745: PPUSH
41746: LD_INT 1
41748: PPUSH
41749: CALL_OW 325
41753: NOT
41754: OR
41755: PUSH
41756: LD_EXP 103
41760: PUSH
41761: LD_VAR 0 2
41765: ARRAY
41766: OR
41767: IFFALSE 41771
// continue ;
41769: GO 41688
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41771: LD_ADDR_VAR 0 8
41775: PUSH
41776: LD_EXP 80
41780: PUSH
41781: LD_VAR 0 2
41785: ARRAY
41786: PPUSH
41787: LD_INT 25
41789: PUSH
41790: LD_INT 4
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 50
41799: PUSH
41800: EMPTY
41801: LIST
41802: PUSH
41803: LD_INT 3
41805: PUSH
41806: LD_INT 60
41808: PUSH
41809: EMPTY
41810: LIST
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: LIST
41820: PPUSH
41821: CALL_OW 72
41825: PUSH
41826: LD_EXP 84
41830: PUSH
41831: LD_VAR 0 2
41835: ARRAY
41836: DIFF
41837: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41838: LD_ADDR_VAR 0 9
41842: PUSH
41843: LD_EXP 80
41847: PUSH
41848: LD_VAR 0 2
41852: ARRAY
41853: PPUSH
41854: LD_INT 2
41856: PUSH
41857: LD_INT 30
41859: PUSH
41860: LD_INT 0
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 30
41869: PUSH
41870: LD_INT 1
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: LIST
41881: PPUSH
41882: CALL_OW 72
41886: ST_TO_ADDR
// if not tmp or not dep then
41887: LD_VAR 0 8
41891: NOT
41892: PUSH
41893: LD_VAR 0 9
41897: NOT
41898: OR
41899: IFFALSE 41903
// continue ;
41901: GO 41688
// side := GetSide ( tmp [ 1 ] ) ;
41903: LD_ADDR_VAR 0 11
41907: PUSH
41908: LD_VAR 0 8
41912: PUSH
41913: LD_INT 1
41915: ARRAY
41916: PPUSH
41917: CALL_OW 255
41921: ST_TO_ADDR
// dep := dep [ 1 ] ;
41922: LD_ADDR_VAR 0 9
41926: PUSH
41927: LD_VAR 0 9
41931: PUSH
41932: LD_INT 1
41934: ARRAY
41935: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41936: LD_ADDR_VAR 0 7
41940: PUSH
41941: LD_EXP 108
41945: PUSH
41946: LD_VAR 0 2
41950: ARRAY
41951: PPUSH
41952: LD_INT 22
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: EMPTY
41959: LIST
41960: LIST
41961: PUSH
41962: LD_INT 25
41964: PUSH
41965: LD_INT 12
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PPUSH
41976: CALL_OW 70
41980: PUSH
41981: LD_INT 22
41983: PUSH
41984: LD_INT 0
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 25
41993: PUSH
41994: LD_INT 12
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 91
42003: PUSH
42004: LD_VAR 0 9
42008: PUSH
42009: LD_INT 20
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: LIST
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: LIST
42021: PPUSH
42022: CALL_OW 69
42026: UNION
42027: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
42028: LD_ADDR_VAR 0 10
42032: PUSH
42033: LD_EXP 108
42037: PUSH
42038: LD_VAR 0 2
42042: ARRAY
42043: PPUSH
42044: LD_INT 81
42046: PUSH
42047: LD_VAR 0 11
42051: PUSH
42052: EMPTY
42053: LIST
42054: LIST
42055: PPUSH
42056: CALL_OW 70
42060: ST_TO_ADDR
// if not apes or danger_at_area then
42061: LD_VAR 0 7
42065: NOT
42066: PUSH
42067: LD_VAR 0 10
42071: OR
42072: IFFALSE 42122
// begin if mc_taming [ i ] then
42074: LD_EXP 111
42078: PUSH
42079: LD_VAR 0 2
42083: ARRAY
42084: IFFALSE 42120
// begin MC_Reset ( i , 121 ) ;
42086: LD_VAR 0 2
42090: PPUSH
42091: LD_INT 121
42093: PPUSH
42094: CALL 27038 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42098: LD_ADDR_EXP 111
42102: PUSH
42103: LD_EXP 111
42107: PPUSH
42108: LD_VAR 0 2
42112: PPUSH
42113: EMPTY
42114: PPUSH
42115: CALL_OW 1
42119: ST_TO_ADDR
// end ; continue ;
42120: GO 41688
// end ; for j in tmp do
42122: LD_ADDR_VAR 0 3
42126: PUSH
42127: LD_VAR 0 8
42131: PUSH
42132: FOR_IN
42133: IFFALSE 42469
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
42135: LD_VAR 0 3
42139: PUSH
42140: LD_EXP 111
42144: PUSH
42145: LD_VAR 0 2
42149: ARRAY
42150: IN
42151: NOT
42152: PUSH
42153: LD_EXP 111
42157: PUSH
42158: LD_VAR 0 2
42162: ARRAY
42163: PUSH
42164: LD_INT 3
42166: LESS
42167: AND
42168: IFFALSE 42226
// begin SetTag ( j , 121 ) ;
42170: LD_VAR 0 3
42174: PPUSH
42175: LD_INT 121
42177: PPUSH
42178: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
42182: LD_ADDR_EXP 111
42186: PUSH
42187: LD_EXP 111
42191: PPUSH
42192: LD_VAR 0 2
42196: PUSH
42197: LD_EXP 111
42201: PUSH
42202: LD_VAR 0 2
42206: ARRAY
42207: PUSH
42208: LD_INT 1
42210: PLUS
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PPUSH
42216: LD_VAR 0 3
42220: PPUSH
42221: CALL 58560 0 3
42225: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
42226: LD_VAR 0 3
42230: PUSH
42231: LD_EXP 111
42235: PUSH
42236: LD_VAR 0 2
42240: ARRAY
42241: IN
42242: IFFALSE 42467
// begin if GetClass ( j ) <> 4 then
42244: LD_VAR 0 3
42248: PPUSH
42249: CALL_OW 257
42253: PUSH
42254: LD_INT 4
42256: NONEQUAL
42257: IFFALSE 42310
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
42259: LD_ADDR_EXP 111
42263: PUSH
42264: LD_EXP 111
42268: PPUSH
42269: LD_VAR 0 2
42273: PPUSH
42274: LD_EXP 111
42278: PUSH
42279: LD_VAR 0 2
42283: ARRAY
42284: PUSH
42285: LD_VAR 0 3
42289: DIFF
42290: PPUSH
42291: CALL_OW 1
42295: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42296: LD_VAR 0 3
42300: PPUSH
42301: LD_INT 0
42303: PPUSH
42304: CALL_OW 109
// continue ;
42308: GO 42132
// end ; if IsInUnit ( j ) then
42310: LD_VAR 0 3
42314: PPUSH
42315: CALL_OW 310
42319: IFFALSE 42330
// ComExitBuilding ( j ) ;
42321: LD_VAR 0 3
42325: PPUSH
42326: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
42330: LD_ADDR_VAR 0 6
42334: PUSH
42335: LD_VAR 0 7
42339: PPUSH
42340: LD_VAR 0 3
42344: PPUSH
42345: CALL_OW 74
42349: ST_TO_ADDR
// if not ape then
42350: LD_VAR 0 6
42354: NOT
42355: IFFALSE 42359
// break ;
42357: GO 42469
// x := GetX ( ape ) ;
42359: LD_ADDR_VAR 0 4
42363: PUSH
42364: LD_VAR 0 6
42368: PPUSH
42369: CALL_OW 250
42373: ST_TO_ADDR
// y := GetY ( ape ) ;
42374: LD_ADDR_VAR 0 5
42378: PUSH
42379: LD_VAR 0 6
42383: PPUSH
42384: CALL_OW 251
42388: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
42389: LD_VAR 0 4
42393: PPUSH
42394: LD_VAR 0 5
42398: PPUSH
42399: CALL_OW 488
42403: NOT
42404: PUSH
42405: LD_VAR 0 11
42409: PPUSH
42410: LD_VAR 0 4
42414: PPUSH
42415: LD_VAR 0 5
42419: PPUSH
42420: LD_INT 20
42422: PPUSH
42423: CALL 59824 0 4
42427: PUSH
42428: LD_INT 4
42430: ARRAY
42431: OR
42432: IFFALSE 42436
// break ;
42434: GO 42469
// if not HasTask ( j ) then
42436: LD_VAR 0 3
42440: PPUSH
42441: CALL_OW 314
42445: NOT
42446: IFFALSE 42467
// ComTameXY ( j , x , y ) ;
42448: LD_VAR 0 3
42452: PPUSH
42453: LD_VAR 0 4
42457: PPUSH
42458: LD_VAR 0 5
42462: PPUSH
42463: CALL_OW 131
// end ; end ;
42467: GO 42132
42469: POP
42470: POP
// end ;
42471: GO 41688
42473: POP
42474: POP
// end ;
42475: LD_VAR 0 1
42479: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
42480: LD_INT 0
42482: PPUSH
42483: PPUSH
42484: PPUSH
42485: PPUSH
42486: PPUSH
42487: PPUSH
42488: PPUSH
42489: PPUSH
// if not mc_bases then
42490: LD_EXP 80
42494: NOT
42495: IFFALSE 42499
// exit ;
42497: GO 43125
// for i = 1 to mc_bases do
42499: LD_ADDR_VAR 0 2
42503: PUSH
42504: DOUBLE
42505: LD_INT 1
42507: DEC
42508: ST_TO_ADDR
42509: LD_EXP 80
42513: PUSH
42514: FOR_TO
42515: IFFALSE 43123
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
42517: LD_EXP 109
42521: PUSH
42522: LD_VAR 0 2
42526: ARRAY
42527: NOT
42528: PUSH
42529: LD_EXP 109
42533: PUSH
42534: LD_VAR 0 2
42538: ARRAY
42539: PPUSH
42540: LD_INT 25
42542: PUSH
42543: LD_INT 12
42545: PUSH
42546: EMPTY
42547: LIST
42548: LIST
42549: PPUSH
42550: CALL_OW 72
42554: NOT
42555: OR
42556: IFFALSE 42560
// continue ;
42558: GO 42514
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
42560: LD_ADDR_VAR 0 5
42564: PUSH
42565: LD_EXP 109
42569: PUSH
42570: LD_VAR 0 2
42574: ARRAY
42575: PUSH
42576: LD_INT 1
42578: ARRAY
42579: PPUSH
42580: CALL_OW 255
42584: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
42585: LD_VAR 0 5
42589: PPUSH
42590: LD_INT 2
42592: PPUSH
42593: CALL_OW 325
42597: IFFALSE 42850
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42599: LD_ADDR_VAR 0 4
42603: PUSH
42604: LD_EXP 109
42608: PUSH
42609: LD_VAR 0 2
42613: ARRAY
42614: PPUSH
42615: LD_INT 25
42617: PUSH
42618: LD_INT 16
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PPUSH
42625: CALL_OW 72
42629: ST_TO_ADDR
// if tmp < 6 then
42630: LD_VAR 0 4
42634: PUSH
42635: LD_INT 6
42637: LESS
42638: IFFALSE 42850
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42640: LD_ADDR_VAR 0 6
42644: PUSH
42645: LD_EXP 80
42649: PUSH
42650: LD_VAR 0 2
42654: ARRAY
42655: PPUSH
42656: LD_INT 2
42658: PUSH
42659: LD_INT 30
42661: PUSH
42662: LD_INT 0
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PUSH
42669: LD_INT 30
42671: PUSH
42672: LD_INT 1
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: LIST
42683: PPUSH
42684: CALL_OW 72
42688: ST_TO_ADDR
// if depot then
42689: LD_VAR 0 6
42693: IFFALSE 42850
// begin selected := 0 ;
42695: LD_ADDR_VAR 0 7
42699: PUSH
42700: LD_INT 0
42702: ST_TO_ADDR
// for j in depot do
42703: LD_ADDR_VAR 0 3
42707: PUSH
42708: LD_VAR 0 6
42712: PUSH
42713: FOR_IN
42714: IFFALSE 42745
// begin if UnitsInside ( j ) < 6 then
42716: LD_VAR 0 3
42720: PPUSH
42721: CALL_OW 313
42725: PUSH
42726: LD_INT 6
42728: LESS
42729: IFFALSE 42743
// begin selected := j ;
42731: LD_ADDR_VAR 0 7
42735: PUSH
42736: LD_VAR 0 3
42740: ST_TO_ADDR
// break ;
42741: GO 42745
// end ; end ;
42743: GO 42713
42745: POP
42746: POP
// if selected then
42747: LD_VAR 0 7
42751: IFFALSE 42850
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42753: LD_ADDR_VAR 0 3
42757: PUSH
42758: LD_EXP 109
42762: PUSH
42763: LD_VAR 0 2
42767: ARRAY
42768: PPUSH
42769: LD_INT 25
42771: PUSH
42772: LD_INT 12
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PPUSH
42779: CALL_OW 72
42783: PUSH
42784: FOR_IN
42785: IFFALSE 42848
// if not HasTask ( j ) then
42787: LD_VAR 0 3
42791: PPUSH
42792: CALL_OW 314
42796: NOT
42797: IFFALSE 42846
// begin if not IsInUnit ( j ) then
42799: LD_VAR 0 3
42803: PPUSH
42804: CALL_OW 310
42808: NOT
42809: IFFALSE 42825
// ComEnterUnit ( j , selected ) ;
42811: LD_VAR 0 3
42815: PPUSH
42816: LD_VAR 0 7
42820: PPUSH
42821: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42825: LD_VAR 0 3
42829: PPUSH
42830: LD_INT 16
42832: PPUSH
42833: CALL_OW 183
// AddComExitBuilding ( j ) ;
42837: LD_VAR 0 3
42841: PPUSH
42842: CALL_OW 182
// end ;
42846: GO 42784
42848: POP
42849: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42850: LD_VAR 0 5
42854: PPUSH
42855: LD_INT 11
42857: PPUSH
42858: CALL_OW 325
42862: IFFALSE 43121
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42864: LD_ADDR_VAR 0 4
42868: PUSH
42869: LD_EXP 109
42873: PUSH
42874: LD_VAR 0 2
42878: ARRAY
42879: PPUSH
42880: LD_INT 25
42882: PUSH
42883: LD_INT 16
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PPUSH
42890: CALL_OW 72
42894: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42895: LD_VAR 0 4
42899: PUSH
42900: LD_INT 6
42902: GREATEREQUAL
42903: PUSH
42904: LD_VAR 0 5
42908: PPUSH
42909: LD_INT 2
42911: PPUSH
42912: CALL_OW 325
42916: NOT
42917: OR
42918: IFFALSE 43121
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42920: LD_ADDR_VAR 0 8
42924: PUSH
42925: LD_EXP 80
42929: PUSH
42930: LD_VAR 0 2
42934: ARRAY
42935: PPUSH
42936: LD_INT 2
42938: PUSH
42939: LD_INT 30
42941: PUSH
42942: LD_INT 4
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: PUSH
42949: LD_INT 30
42951: PUSH
42952: LD_INT 5
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: LIST
42963: PPUSH
42964: CALL_OW 72
42968: ST_TO_ADDR
// if barracks then
42969: LD_VAR 0 8
42973: IFFALSE 43121
// begin selected := 0 ;
42975: LD_ADDR_VAR 0 7
42979: PUSH
42980: LD_INT 0
42982: ST_TO_ADDR
// for j in barracks do
42983: LD_ADDR_VAR 0 3
42987: PUSH
42988: LD_VAR 0 8
42992: PUSH
42993: FOR_IN
42994: IFFALSE 43025
// begin if UnitsInside ( j ) < 6 then
42996: LD_VAR 0 3
43000: PPUSH
43001: CALL_OW 313
43005: PUSH
43006: LD_INT 6
43008: LESS
43009: IFFALSE 43023
// begin selected := j ;
43011: LD_ADDR_VAR 0 7
43015: PUSH
43016: LD_VAR 0 3
43020: ST_TO_ADDR
// break ;
43021: GO 43025
// end ; end ;
43023: GO 42993
43025: POP
43026: POP
// if selected then
43027: LD_VAR 0 7
43031: IFFALSE 43121
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
43033: LD_ADDR_VAR 0 3
43037: PUSH
43038: LD_EXP 109
43042: PUSH
43043: LD_VAR 0 2
43047: ARRAY
43048: PPUSH
43049: LD_INT 25
43051: PUSH
43052: LD_INT 12
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PPUSH
43059: CALL_OW 72
43063: PUSH
43064: FOR_IN
43065: IFFALSE 43119
// if not IsInUnit ( j ) and not HasTask ( j ) then
43067: LD_VAR 0 3
43071: PPUSH
43072: CALL_OW 310
43076: NOT
43077: PUSH
43078: LD_VAR 0 3
43082: PPUSH
43083: CALL_OW 314
43087: NOT
43088: AND
43089: IFFALSE 43117
// begin ComEnterUnit ( j , selected ) ;
43091: LD_VAR 0 3
43095: PPUSH
43096: LD_VAR 0 7
43100: PPUSH
43101: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
43105: LD_VAR 0 3
43109: PPUSH
43110: LD_INT 15
43112: PPUSH
43113: CALL_OW 183
// end ;
43117: GO 43064
43119: POP
43120: POP
// end ; end ; end ; end ; end ;
43121: GO 42514
43123: POP
43124: POP
// end ;
43125: LD_VAR 0 1
43129: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
43130: LD_INT 0
43132: PPUSH
43133: PPUSH
43134: PPUSH
43135: PPUSH
// if not mc_bases then
43136: LD_EXP 80
43140: NOT
43141: IFFALSE 43145
// exit ;
43143: GO 43323
// for i = 1 to mc_bases do
43145: LD_ADDR_VAR 0 2
43149: PUSH
43150: DOUBLE
43151: LD_INT 1
43153: DEC
43154: ST_TO_ADDR
43155: LD_EXP 80
43159: PUSH
43160: FOR_TO
43161: IFFALSE 43321
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
43163: LD_ADDR_VAR 0 4
43167: PUSH
43168: LD_EXP 80
43172: PUSH
43173: LD_VAR 0 2
43177: ARRAY
43178: PPUSH
43179: LD_INT 25
43181: PUSH
43182: LD_INT 9
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PPUSH
43189: CALL_OW 72
43193: ST_TO_ADDR
// if not tmp then
43194: LD_VAR 0 4
43198: NOT
43199: IFFALSE 43203
// continue ;
43201: GO 43160
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
43203: LD_EXP 106
43207: PUSH
43208: LD_VAR 0 2
43212: ARRAY
43213: PPUSH
43214: LD_INT 29
43216: PPUSH
43217: CALL_OW 325
43221: NOT
43222: PUSH
43223: LD_EXP 106
43227: PUSH
43228: LD_VAR 0 2
43232: ARRAY
43233: PPUSH
43234: LD_INT 28
43236: PPUSH
43237: CALL_OW 325
43241: NOT
43242: AND
43243: IFFALSE 43247
// continue ;
43245: GO 43160
// for j in tmp do
43247: LD_ADDR_VAR 0 3
43251: PUSH
43252: LD_VAR 0 4
43256: PUSH
43257: FOR_IN
43258: IFFALSE 43317
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
43260: LD_VAR 0 3
43264: PUSH
43265: LD_EXP 83
43269: PUSH
43270: LD_VAR 0 2
43274: ARRAY
43275: PUSH
43276: LD_INT 1
43278: ARRAY
43279: IN
43280: NOT
43281: PUSH
43282: LD_VAR 0 3
43286: PUSH
43287: LD_EXP 83
43291: PUSH
43292: LD_VAR 0 2
43296: ARRAY
43297: PUSH
43298: LD_INT 2
43300: ARRAY
43301: IN
43302: NOT
43303: AND
43304: IFFALSE 43315
// ComSpaceTimeShoot ( j ) ;
43306: LD_VAR 0 3
43310: PPUSH
43311: CALL 54545 0 1
43315: GO 43257
43317: POP
43318: POP
// end ;
43319: GO 43160
43321: POP
43322: POP
// end ;
43323: LD_VAR 0 1
43327: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
43328: LD_INT 0
43330: PPUSH
43331: PPUSH
43332: PPUSH
43333: PPUSH
43334: PPUSH
43335: PPUSH
43336: PPUSH
43337: PPUSH
43338: PPUSH
// if not mc_bases then
43339: LD_EXP 80
43343: NOT
43344: IFFALSE 43348
// exit ;
43346: GO 43970
// for i = 1 to mc_bases do
43348: LD_ADDR_VAR 0 2
43352: PUSH
43353: DOUBLE
43354: LD_INT 1
43356: DEC
43357: ST_TO_ADDR
43358: LD_EXP 80
43362: PUSH
43363: FOR_TO
43364: IFFALSE 43968
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
43366: LD_EXP 115
43370: PUSH
43371: LD_VAR 0 2
43375: ARRAY
43376: NOT
43377: PUSH
43378: LD_INT 38
43380: PPUSH
43381: LD_EXP 106
43385: PUSH
43386: LD_VAR 0 2
43390: ARRAY
43391: PPUSH
43392: CALL_OW 321
43396: PUSH
43397: LD_INT 2
43399: NONEQUAL
43400: OR
43401: IFFALSE 43405
// continue ;
43403: GO 43363
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
43405: LD_ADDR_VAR 0 8
43409: PUSH
43410: LD_EXP 80
43414: PUSH
43415: LD_VAR 0 2
43419: ARRAY
43420: PPUSH
43421: LD_INT 30
43423: PUSH
43424: LD_INT 34
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PPUSH
43431: CALL_OW 72
43435: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
43436: LD_ADDR_VAR 0 9
43440: PUSH
43441: LD_EXP 80
43445: PUSH
43446: LD_VAR 0 2
43450: ARRAY
43451: PPUSH
43452: LD_INT 25
43454: PUSH
43455: LD_INT 4
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PPUSH
43462: CALL_OW 72
43466: PPUSH
43467: LD_INT 0
43469: PPUSH
43470: CALL 88878 0 2
43474: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
43475: LD_VAR 0 9
43479: NOT
43480: PUSH
43481: LD_VAR 0 8
43485: NOT
43486: OR
43487: PUSH
43488: LD_EXP 80
43492: PUSH
43493: LD_VAR 0 2
43497: ARRAY
43498: PPUSH
43499: LD_INT 124
43501: PPUSH
43502: CALL 88878 0 2
43506: OR
43507: IFFALSE 43511
// continue ;
43509: GO 43363
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
43511: LD_EXP 116
43515: PUSH
43516: LD_VAR 0 2
43520: ARRAY
43521: PUSH
43522: LD_EXP 115
43526: PUSH
43527: LD_VAR 0 2
43531: ARRAY
43532: LESS
43533: PUSH
43534: LD_EXP 116
43538: PUSH
43539: LD_VAR 0 2
43543: ARRAY
43544: PUSH
43545: LD_VAR 0 8
43549: LESS
43550: AND
43551: IFFALSE 43966
// begin tmp := sci [ 1 ] ;
43553: LD_ADDR_VAR 0 7
43557: PUSH
43558: LD_VAR 0 9
43562: PUSH
43563: LD_INT 1
43565: ARRAY
43566: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
43567: LD_VAR 0 7
43571: PPUSH
43572: LD_INT 124
43574: PPUSH
43575: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
43579: LD_ADDR_VAR 0 3
43583: PUSH
43584: DOUBLE
43585: LD_EXP 115
43589: PUSH
43590: LD_VAR 0 2
43594: ARRAY
43595: INC
43596: ST_TO_ADDR
43597: LD_EXP 115
43601: PUSH
43602: LD_VAR 0 2
43606: ARRAY
43607: PUSH
43608: FOR_DOWNTO
43609: IFFALSE 43952
// begin if IsInUnit ( tmp ) then
43611: LD_VAR 0 7
43615: PPUSH
43616: CALL_OW 310
43620: IFFALSE 43631
// ComExitBuilding ( tmp ) ;
43622: LD_VAR 0 7
43626: PPUSH
43627: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
43631: LD_INT 35
43633: PPUSH
43634: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
43638: LD_VAR 0 7
43642: PPUSH
43643: CALL_OW 310
43647: NOT
43648: PUSH
43649: LD_VAR 0 7
43653: PPUSH
43654: CALL_OW 314
43658: NOT
43659: AND
43660: IFFALSE 43631
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
43662: LD_ADDR_VAR 0 6
43666: PUSH
43667: LD_VAR 0 7
43671: PPUSH
43672: CALL_OW 250
43676: PUSH
43677: LD_VAR 0 7
43681: PPUSH
43682: CALL_OW 251
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
43691: LD_INT 35
43693: PPUSH
43694: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
43698: LD_ADDR_VAR 0 4
43702: PUSH
43703: LD_EXP 115
43707: PUSH
43708: LD_VAR 0 2
43712: ARRAY
43713: PUSH
43714: LD_VAR 0 3
43718: ARRAY
43719: PUSH
43720: LD_INT 1
43722: ARRAY
43723: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43724: LD_ADDR_VAR 0 5
43728: PUSH
43729: LD_EXP 115
43733: PUSH
43734: LD_VAR 0 2
43738: ARRAY
43739: PUSH
43740: LD_VAR 0 3
43744: ARRAY
43745: PUSH
43746: LD_INT 2
43748: ARRAY
43749: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43750: LD_VAR 0 7
43754: PPUSH
43755: LD_INT 10
43757: PPUSH
43758: CALL 61525 0 2
43762: PUSH
43763: LD_INT 4
43765: ARRAY
43766: IFFALSE 43804
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43768: LD_VAR 0 7
43772: PPUSH
43773: LD_VAR 0 6
43777: PUSH
43778: LD_INT 1
43780: ARRAY
43781: PPUSH
43782: LD_VAR 0 6
43786: PUSH
43787: LD_INT 2
43789: ARRAY
43790: PPUSH
43791: CALL_OW 111
// wait ( 0 0$10 ) ;
43795: LD_INT 350
43797: PPUSH
43798: CALL_OW 67
// end else
43802: GO 43830
// begin ComMoveXY ( tmp , x , y ) ;
43804: LD_VAR 0 7
43808: PPUSH
43809: LD_VAR 0 4
43813: PPUSH
43814: LD_VAR 0 5
43818: PPUSH
43819: CALL_OW 111
// wait ( 0 0$3 ) ;
43823: LD_INT 105
43825: PPUSH
43826: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43830: LD_VAR 0 7
43834: PPUSH
43835: LD_VAR 0 4
43839: PPUSH
43840: LD_VAR 0 5
43844: PPUSH
43845: CALL_OW 307
43849: IFFALSE 43691
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43851: LD_VAR 0 7
43855: PPUSH
43856: LD_VAR 0 4
43860: PPUSH
43861: LD_VAR 0 5
43865: PPUSH
43866: LD_VAR 0 8
43870: PUSH
43871: LD_VAR 0 3
43875: ARRAY
43876: PPUSH
43877: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43881: LD_INT 35
43883: PPUSH
43884: CALL_OW 67
// until not HasTask ( tmp ) ;
43888: LD_VAR 0 7
43892: PPUSH
43893: CALL_OW 314
43897: NOT
43898: IFFALSE 43881
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43900: LD_ADDR_EXP 116
43904: PUSH
43905: LD_EXP 116
43909: PPUSH
43910: LD_VAR 0 2
43914: PUSH
43915: LD_EXP 116
43919: PUSH
43920: LD_VAR 0 2
43924: ARRAY
43925: PUSH
43926: LD_INT 1
43928: PLUS
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PPUSH
43934: LD_VAR 0 8
43938: PUSH
43939: LD_VAR 0 3
43943: ARRAY
43944: PPUSH
43945: CALL 58560 0 3
43949: ST_TO_ADDR
// end ;
43950: GO 43608
43952: POP
43953: POP
// MC_Reset ( i , 124 ) ;
43954: LD_VAR 0 2
43958: PPUSH
43959: LD_INT 124
43961: PPUSH
43962: CALL 27038 0 2
// end ; end ;
43966: GO 43363
43968: POP
43969: POP
// end ;
43970: LD_VAR 0 1
43974: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43975: LD_INT 0
43977: PPUSH
43978: PPUSH
43979: PPUSH
// if not mc_bases then
43980: LD_EXP 80
43984: NOT
43985: IFFALSE 43989
// exit ;
43987: GO 44595
// for i = 1 to mc_bases do
43989: LD_ADDR_VAR 0 2
43993: PUSH
43994: DOUBLE
43995: LD_INT 1
43997: DEC
43998: ST_TO_ADDR
43999: LD_EXP 80
44003: PUSH
44004: FOR_TO
44005: IFFALSE 44593
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44007: LD_ADDR_VAR 0 3
44011: PUSH
44012: LD_EXP 80
44016: PUSH
44017: LD_VAR 0 2
44021: ARRAY
44022: PPUSH
44023: LD_INT 25
44025: PUSH
44026: LD_INT 4
44028: PUSH
44029: EMPTY
44030: LIST
44031: LIST
44032: PPUSH
44033: CALL_OW 72
44037: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44038: LD_VAR 0 3
44042: NOT
44043: PUSH
44044: LD_EXP 117
44048: PUSH
44049: LD_VAR 0 2
44053: ARRAY
44054: NOT
44055: OR
44056: PUSH
44057: LD_EXP 80
44061: PUSH
44062: LD_VAR 0 2
44066: ARRAY
44067: PPUSH
44068: LD_INT 2
44070: PUSH
44071: LD_INT 30
44073: PUSH
44074: LD_INT 0
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 30
44083: PUSH
44084: LD_INT 1
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: LIST
44095: PPUSH
44096: CALL_OW 72
44100: NOT
44101: OR
44102: IFFALSE 44152
// begin if mc_deposits_finder [ i ] then
44104: LD_EXP 118
44108: PUSH
44109: LD_VAR 0 2
44113: ARRAY
44114: IFFALSE 44150
// begin MC_Reset ( i , 125 ) ;
44116: LD_VAR 0 2
44120: PPUSH
44121: LD_INT 125
44123: PPUSH
44124: CALL 27038 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44128: LD_ADDR_EXP 118
44132: PUSH
44133: LD_EXP 118
44137: PPUSH
44138: LD_VAR 0 2
44142: PPUSH
44143: EMPTY
44144: PPUSH
44145: CALL_OW 1
44149: ST_TO_ADDR
// end ; continue ;
44150: GO 44004
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
44152: LD_EXP 117
44156: PUSH
44157: LD_VAR 0 2
44161: ARRAY
44162: PUSH
44163: LD_INT 1
44165: ARRAY
44166: PUSH
44167: LD_INT 3
44169: ARRAY
44170: PUSH
44171: LD_INT 1
44173: EQUAL
44174: PUSH
44175: LD_INT 20
44177: PPUSH
44178: LD_EXP 106
44182: PUSH
44183: LD_VAR 0 2
44187: ARRAY
44188: PPUSH
44189: CALL_OW 321
44193: PUSH
44194: LD_INT 2
44196: NONEQUAL
44197: AND
44198: IFFALSE 44248
// begin if mc_deposits_finder [ i ] then
44200: LD_EXP 118
44204: PUSH
44205: LD_VAR 0 2
44209: ARRAY
44210: IFFALSE 44246
// begin MC_Reset ( i , 125 ) ;
44212: LD_VAR 0 2
44216: PPUSH
44217: LD_INT 125
44219: PPUSH
44220: CALL 27038 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44224: LD_ADDR_EXP 118
44228: PUSH
44229: LD_EXP 118
44233: PPUSH
44234: LD_VAR 0 2
44238: PPUSH
44239: EMPTY
44240: PPUSH
44241: CALL_OW 1
44245: ST_TO_ADDR
// end ; continue ;
44246: GO 44004
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
44248: LD_EXP 117
44252: PUSH
44253: LD_VAR 0 2
44257: ARRAY
44258: PUSH
44259: LD_INT 1
44261: ARRAY
44262: PUSH
44263: LD_INT 1
44265: ARRAY
44266: PPUSH
44267: LD_EXP 117
44271: PUSH
44272: LD_VAR 0 2
44276: ARRAY
44277: PUSH
44278: LD_INT 1
44280: ARRAY
44281: PUSH
44282: LD_INT 2
44284: ARRAY
44285: PPUSH
44286: LD_EXP 106
44290: PUSH
44291: LD_VAR 0 2
44295: ARRAY
44296: PPUSH
44297: CALL_OW 440
44301: IFFALSE 44344
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
44303: LD_ADDR_EXP 117
44307: PUSH
44308: LD_EXP 117
44312: PPUSH
44313: LD_VAR 0 2
44317: PPUSH
44318: LD_EXP 117
44322: PUSH
44323: LD_VAR 0 2
44327: ARRAY
44328: PPUSH
44329: LD_INT 1
44331: PPUSH
44332: CALL_OW 3
44336: PPUSH
44337: CALL_OW 1
44341: ST_TO_ADDR
44342: GO 44591
// begin if not mc_deposits_finder [ i ] then
44344: LD_EXP 118
44348: PUSH
44349: LD_VAR 0 2
44353: ARRAY
44354: NOT
44355: IFFALSE 44407
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
44357: LD_ADDR_EXP 118
44361: PUSH
44362: LD_EXP 118
44366: PPUSH
44367: LD_VAR 0 2
44371: PPUSH
44372: LD_VAR 0 3
44376: PUSH
44377: LD_INT 1
44379: ARRAY
44380: PUSH
44381: EMPTY
44382: LIST
44383: PPUSH
44384: CALL_OW 1
44388: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
44389: LD_VAR 0 3
44393: PUSH
44394: LD_INT 1
44396: ARRAY
44397: PPUSH
44398: LD_INT 125
44400: PPUSH
44401: CALL_OW 109
// end else
44405: GO 44591
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
44407: LD_EXP 118
44411: PUSH
44412: LD_VAR 0 2
44416: ARRAY
44417: PUSH
44418: LD_INT 1
44420: ARRAY
44421: PPUSH
44422: CALL_OW 310
44426: IFFALSE 44449
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
44428: LD_EXP 118
44432: PUSH
44433: LD_VAR 0 2
44437: ARRAY
44438: PUSH
44439: LD_INT 1
44441: ARRAY
44442: PPUSH
44443: CALL_OW 122
44447: GO 44591
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
44449: LD_EXP 118
44453: PUSH
44454: LD_VAR 0 2
44458: ARRAY
44459: PUSH
44460: LD_INT 1
44462: ARRAY
44463: PPUSH
44464: CALL_OW 314
44468: NOT
44469: PUSH
44470: LD_EXP 118
44474: PUSH
44475: LD_VAR 0 2
44479: ARRAY
44480: PUSH
44481: LD_INT 1
44483: ARRAY
44484: PPUSH
44485: LD_EXP 117
44489: PUSH
44490: LD_VAR 0 2
44494: ARRAY
44495: PUSH
44496: LD_INT 1
44498: ARRAY
44499: PUSH
44500: LD_INT 1
44502: ARRAY
44503: PPUSH
44504: LD_EXP 117
44508: PUSH
44509: LD_VAR 0 2
44513: ARRAY
44514: PUSH
44515: LD_INT 1
44517: ARRAY
44518: PUSH
44519: LD_INT 2
44521: ARRAY
44522: PPUSH
44523: CALL_OW 297
44527: PUSH
44528: LD_INT 6
44530: GREATER
44531: AND
44532: IFFALSE 44591
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
44534: LD_EXP 118
44538: PUSH
44539: LD_VAR 0 2
44543: ARRAY
44544: PUSH
44545: LD_INT 1
44547: ARRAY
44548: PPUSH
44549: LD_EXP 117
44553: PUSH
44554: LD_VAR 0 2
44558: ARRAY
44559: PUSH
44560: LD_INT 1
44562: ARRAY
44563: PUSH
44564: LD_INT 1
44566: ARRAY
44567: PPUSH
44568: LD_EXP 117
44572: PUSH
44573: LD_VAR 0 2
44577: ARRAY
44578: PUSH
44579: LD_INT 1
44581: ARRAY
44582: PUSH
44583: LD_INT 2
44585: ARRAY
44586: PPUSH
44587: CALL_OW 111
// end ; end ; end ;
44591: GO 44004
44593: POP
44594: POP
// end ;
44595: LD_VAR 0 1
44599: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
44600: LD_INT 0
44602: PPUSH
44603: PPUSH
44604: PPUSH
44605: PPUSH
44606: PPUSH
44607: PPUSH
44608: PPUSH
44609: PPUSH
44610: PPUSH
44611: PPUSH
44612: PPUSH
// if not mc_bases then
44613: LD_EXP 80
44617: NOT
44618: IFFALSE 44622
// exit ;
44620: GO 45562
// for i = 1 to mc_bases do
44622: LD_ADDR_VAR 0 2
44626: PUSH
44627: DOUBLE
44628: LD_INT 1
44630: DEC
44631: ST_TO_ADDR
44632: LD_EXP 80
44636: PUSH
44637: FOR_TO
44638: IFFALSE 45560
// begin if not mc_bases [ i ] or mc_scan [ i ] then
44640: LD_EXP 80
44644: PUSH
44645: LD_VAR 0 2
44649: ARRAY
44650: NOT
44651: PUSH
44652: LD_EXP 103
44656: PUSH
44657: LD_VAR 0 2
44661: ARRAY
44662: OR
44663: IFFALSE 44667
// continue ;
44665: GO 44637
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
44667: LD_ADDR_VAR 0 7
44671: PUSH
44672: LD_EXP 80
44676: PUSH
44677: LD_VAR 0 2
44681: ARRAY
44682: PUSH
44683: LD_INT 1
44685: ARRAY
44686: PPUSH
44687: CALL_OW 248
44691: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
44692: LD_VAR 0 7
44696: PUSH
44697: LD_INT 3
44699: EQUAL
44700: PUSH
44701: LD_EXP 99
44705: PUSH
44706: LD_VAR 0 2
44710: ARRAY
44711: PUSH
44712: LD_EXP 102
44716: PUSH
44717: LD_VAR 0 2
44721: ARRAY
44722: UNION
44723: PPUSH
44724: LD_INT 33
44726: PUSH
44727: LD_INT 2
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PPUSH
44734: CALL_OW 72
44738: NOT
44739: OR
44740: IFFALSE 44744
// continue ;
44742: GO 44637
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44744: LD_ADDR_VAR 0 9
44748: PUSH
44749: LD_EXP 80
44753: PUSH
44754: LD_VAR 0 2
44758: ARRAY
44759: PPUSH
44760: LD_INT 30
44762: PUSH
44763: LD_INT 36
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PPUSH
44770: CALL_OW 72
44774: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44775: LD_ADDR_VAR 0 10
44779: PUSH
44780: LD_EXP 99
44784: PUSH
44785: LD_VAR 0 2
44789: ARRAY
44790: PPUSH
44791: LD_INT 34
44793: PUSH
44794: LD_INT 31
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PPUSH
44801: CALL_OW 72
44805: ST_TO_ADDR
// if not cts and not mcts then
44806: LD_VAR 0 9
44810: NOT
44811: PUSH
44812: LD_VAR 0 10
44816: NOT
44817: AND
44818: IFFALSE 44822
// continue ;
44820: GO 44637
// x := cts ;
44822: LD_ADDR_VAR 0 11
44826: PUSH
44827: LD_VAR 0 9
44831: ST_TO_ADDR
// if not x then
44832: LD_VAR 0 11
44836: NOT
44837: IFFALSE 44849
// x := mcts ;
44839: LD_ADDR_VAR 0 11
44843: PUSH
44844: LD_VAR 0 10
44848: ST_TO_ADDR
// if not x then
44849: LD_VAR 0 11
44853: NOT
44854: IFFALSE 44858
// continue ;
44856: GO 44637
// if mc_remote_driver [ i ] then
44858: LD_EXP 120
44862: PUSH
44863: LD_VAR 0 2
44867: ARRAY
44868: IFFALSE 45255
// for j in mc_remote_driver [ i ] do
44870: LD_ADDR_VAR 0 3
44874: PUSH
44875: LD_EXP 120
44879: PUSH
44880: LD_VAR 0 2
44884: ARRAY
44885: PUSH
44886: FOR_IN
44887: IFFALSE 45253
// begin if GetClass ( j ) <> 3 then
44889: LD_VAR 0 3
44893: PPUSH
44894: CALL_OW 257
44898: PUSH
44899: LD_INT 3
44901: NONEQUAL
44902: IFFALSE 44955
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44904: LD_ADDR_EXP 120
44908: PUSH
44909: LD_EXP 120
44913: PPUSH
44914: LD_VAR 0 2
44918: PPUSH
44919: LD_EXP 120
44923: PUSH
44924: LD_VAR 0 2
44928: ARRAY
44929: PUSH
44930: LD_VAR 0 3
44934: DIFF
44935: PPUSH
44936: CALL_OW 1
44940: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44941: LD_VAR 0 3
44945: PPUSH
44946: LD_INT 0
44948: PPUSH
44949: CALL_OW 109
// continue ;
44953: GO 44886
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44955: LD_EXP 99
44959: PUSH
44960: LD_VAR 0 2
44964: ARRAY
44965: PPUSH
44966: LD_INT 34
44968: PUSH
44969: LD_INT 31
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 58
44978: PUSH
44979: EMPTY
44980: LIST
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PPUSH
44986: CALL_OW 72
44990: PUSH
44991: LD_VAR 0 3
44995: PPUSH
44996: CALL 88913 0 1
45000: NOT
45001: AND
45002: IFFALSE 45073
// begin if IsInUnit ( j ) then
45004: LD_VAR 0 3
45008: PPUSH
45009: CALL_OW 310
45013: IFFALSE 45024
// ComExitBuilding ( j ) ;
45015: LD_VAR 0 3
45019: PPUSH
45020: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
45024: LD_VAR 0 3
45028: PPUSH
45029: LD_EXP 99
45033: PUSH
45034: LD_VAR 0 2
45038: ARRAY
45039: PPUSH
45040: LD_INT 34
45042: PUSH
45043: LD_INT 31
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 58
45052: PUSH
45053: EMPTY
45054: LIST
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: PPUSH
45060: CALL_OW 72
45064: PUSH
45065: LD_INT 1
45067: ARRAY
45068: PPUSH
45069: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
45073: LD_VAR 0 3
45077: PPUSH
45078: CALL_OW 310
45082: NOT
45083: PUSH
45084: LD_VAR 0 3
45088: PPUSH
45089: CALL_OW 310
45093: PPUSH
45094: CALL_OW 266
45098: PUSH
45099: LD_INT 36
45101: NONEQUAL
45102: PUSH
45103: LD_VAR 0 3
45107: PPUSH
45108: CALL 88913 0 1
45112: NOT
45113: AND
45114: OR
45115: IFFALSE 45251
// begin if IsInUnit ( j ) then
45117: LD_VAR 0 3
45121: PPUSH
45122: CALL_OW 310
45126: IFFALSE 45137
// ComExitBuilding ( j ) ;
45128: LD_VAR 0 3
45132: PPUSH
45133: CALL_OW 122
// ct := 0 ;
45137: LD_ADDR_VAR 0 8
45141: PUSH
45142: LD_INT 0
45144: ST_TO_ADDR
// for k in x do
45145: LD_ADDR_VAR 0 4
45149: PUSH
45150: LD_VAR 0 11
45154: PUSH
45155: FOR_IN
45156: IFFALSE 45229
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
45158: LD_VAR 0 4
45162: PPUSH
45163: CALL_OW 264
45167: PUSH
45168: LD_INT 31
45170: EQUAL
45171: PUSH
45172: LD_VAR 0 4
45176: PPUSH
45177: CALL_OW 311
45181: NOT
45182: AND
45183: PUSH
45184: LD_VAR 0 4
45188: PPUSH
45189: CALL_OW 266
45193: PUSH
45194: LD_INT 36
45196: EQUAL
45197: PUSH
45198: LD_VAR 0 4
45202: PPUSH
45203: CALL_OW 313
45207: PUSH
45208: LD_INT 3
45210: LESS
45211: AND
45212: OR
45213: IFFALSE 45227
// begin ct := k ;
45215: LD_ADDR_VAR 0 8
45219: PUSH
45220: LD_VAR 0 4
45224: ST_TO_ADDR
// break ;
45225: GO 45229
// end ;
45227: GO 45155
45229: POP
45230: POP
// if ct then
45231: LD_VAR 0 8
45235: IFFALSE 45251
// ComEnterUnit ( j , ct ) ;
45237: LD_VAR 0 3
45241: PPUSH
45242: LD_VAR 0 8
45246: PPUSH
45247: CALL_OW 120
// end ; end ;
45251: GO 44886
45253: POP
45254: POP
// places := 0 ;
45255: LD_ADDR_VAR 0 5
45259: PUSH
45260: LD_INT 0
45262: ST_TO_ADDR
// for j = 1 to x do
45263: LD_ADDR_VAR 0 3
45267: PUSH
45268: DOUBLE
45269: LD_INT 1
45271: DEC
45272: ST_TO_ADDR
45273: LD_VAR 0 11
45277: PUSH
45278: FOR_TO
45279: IFFALSE 45355
// if GetWeapon ( x [ j ] ) = ar_control_tower then
45281: LD_VAR 0 11
45285: PUSH
45286: LD_VAR 0 3
45290: ARRAY
45291: PPUSH
45292: CALL_OW 264
45296: PUSH
45297: LD_INT 31
45299: EQUAL
45300: IFFALSE 45318
// places := places + 1 else
45302: LD_ADDR_VAR 0 5
45306: PUSH
45307: LD_VAR 0 5
45311: PUSH
45312: LD_INT 1
45314: PLUS
45315: ST_TO_ADDR
45316: GO 45353
// if GetBType ( x [ j ] ) = b_control_tower then
45318: LD_VAR 0 11
45322: PUSH
45323: LD_VAR 0 3
45327: ARRAY
45328: PPUSH
45329: CALL_OW 266
45333: PUSH
45334: LD_INT 36
45336: EQUAL
45337: IFFALSE 45353
// places := places + 3 ;
45339: LD_ADDR_VAR 0 5
45343: PUSH
45344: LD_VAR 0 5
45348: PUSH
45349: LD_INT 3
45351: PLUS
45352: ST_TO_ADDR
45353: GO 45278
45355: POP
45356: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
45357: LD_VAR 0 5
45361: PUSH
45362: LD_INT 0
45364: EQUAL
45365: PUSH
45366: LD_VAR 0 5
45370: PUSH
45371: LD_EXP 120
45375: PUSH
45376: LD_VAR 0 2
45380: ARRAY
45381: LESSEQUAL
45382: OR
45383: IFFALSE 45387
// continue ;
45385: GO 44637
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
45387: LD_ADDR_VAR 0 6
45391: PUSH
45392: LD_EXP 80
45396: PUSH
45397: LD_VAR 0 2
45401: ARRAY
45402: PPUSH
45403: LD_INT 25
45405: PUSH
45406: LD_INT 3
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PPUSH
45413: CALL_OW 72
45417: PUSH
45418: LD_EXP 120
45422: PUSH
45423: LD_VAR 0 2
45427: ARRAY
45428: DIFF
45429: PPUSH
45430: LD_INT 3
45432: PPUSH
45433: CALL 89813 0 2
45437: ST_TO_ADDR
// for j in tmp do
45438: LD_ADDR_VAR 0 3
45442: PUSH
45443: LD_VAR 0 6
45447: PUSH
45448: FOR_IN
45449: IFFALSE 45484
// if GetTag ( j ) > 0 then
45451: LD_VAR 0 3
45455: PPUSH
45456: CALL_OW 110
45460: PUSH
45461: LD_INT 0
45463: GREATER
45464: IFFALSE 45482
// tmp := tmp diff j ;
45466: LD_ADDR_VAR 0 6
45470: PUSH
45471: LD_VAR 0 6
45475: PUSH
45476: LD_VAR 0 3
45480: DIFF
45481: ST_TO_ADDR
45482: GO 45448
45484: POP
45485: POP
// if not tmp then
45486: LD_VAR 0 6
45490: NOT
45491: IFFALSE 45495
// continue ;
45493: GO 44637
// if places then
45495: LD_VAR 0 5
45499: IFFALSE 45558
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
45501: LD_ADDR_EXP 120
45505: PUSH
45506: LD_EXP 120
45510: PPUSH
45511: LD_VAR 0 2
45515: PPUSH
45516: LD_EXP 120
45520: PUSH
45521: LD_VAR 0 2
45525: ARRAY
45526: PUSH
45527: LD_VAR 0 6
45531: PUSH
45532: LD_INT 1
45534: ARRAY
45535: UNION
45536: PPUSH
45537: CALL_OW 1
45541: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
45542: LD_VAR 0 6
45546: PUSH
45547: LD_INT 1
45549: ARRAY
45550: PPUSH
45551: LD_INT 126
45553: PPUSH
45554: CALL_OW 109
// end ; end ;
45558: GO 44637
45560: POP
45561: POP
// end ;
45562: LD_VAR 0 1
45566: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
45567: LD_INT 0
45569: PPUSH
45570: PPUSH
45571: PPUSH
45572: PPUSH
45573: PPUSH
45574: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
45575: LD_VAR 0 1
45579: NOT
45580: PUSH
45581: LD_VAR 0 2
45585: NOT
45586: OR
45587: PUSH
45588: LD_VAR 0 3
45592: NOT
45593: OR
45594: PUSH
45595: LD_VAR 0 4
45599: PUSH
45600: LD_INT 1
45602: PUSH
45603: LD_INT 2
45605: PUSH
45606: LD_INT 3
45608: PUSH
45609: LD_INT 4
45611: PUSH
45612: LD_INT 5
45614: PUSH
45615: LD_INT 8
45617: PUSH
45618: LD_INT 9
45620: PUSH
45621: LD_INT 15
45623: PUSH
45624: LD_INT 16
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: IN
45638: NOT
45639: OR
45640: IFFALSE 45644
// exit ;
45642: GO 46502
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
45644: LD_ADDR_VAR 0 2
45648: PUSH
45649: LD_VAR 0 2
45653: PPUSH
45654: LD_INT 21
45656: PUSH
45657: LD_INT 3
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: PUSH
45664: LD_INT 24
45666: PUSH
45667: LD_INT 250
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PPUSH
45678: CALL_OW 72
45682: ST_TO_ADDR
// case class of 1 , 15 :
45683: LD_VAR 0 4
45687: PUSH
45688: LD_INT 1
45690: DOUBLE
45691: EQUAL
45692: IFTRUE 45702
45694: LD_INT 15
45696: DOUBLE
45697: EQUAL
45698: IFTRUE 45702
45700: GO 45787
45702: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
45703: LD_ADDR_VAR 0 8
45707: PUSH
45708: LD_VAR 0 2
45712: PPUSH
45713: LD_INT 2
45715: PUSH
45716: LD_INT 30
45718: PUSH
45719: LD_INT 32
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 30
45728: PUSH
45729: LD_INT 31
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: LIST
45740: PPUSH
45741: CALL_OW 72
45745: PUSH
45746: LD_VAR 0 2
45750: PPUSH
45751: LD_INT 2
45753: PUSH
45754: LD_INT 30
45756: PUSH
45757: LD_INT 4
45759: PUSH
45760: EMPTY
45761: LIST
45762: LIST
45763: PUSH
45764: LD_INT 30
45766: PUSH
45767: LD_INT 5
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: PUSH
45774: EMPTY
45775: LIST
45776: LIST
45777: LIST
45778: PPUSH
45779: CALL_OW 72
45783: ADD
45784: ST_TO_ADDR
45785: GO 46033
45787: LD_INT 2
45789: DOUBLE
45790: EQUAL
45791: IFTRUE 45801
45793: LD_INT 16
45795: DOUBLE
45796: EQUAL
45797: IFTRUE 45801
45799: GO 45847
45801: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45802: LD_ADDR_VAR 0 8
45806: PUSH
45807: LD_VAR 0 2
45811: PPUSH
45812: LD_INT 2
45814: PUSH
45815: LD_INT 30
45817: PUSH
45818: LD_INT 0
45820: PUSH
45821: EMPTY
45822: LIST
45823: LIST
45824: PUSH
45825: LD_INT 30
45827: PUSH
45828: LD_INT 1
45830: PUSH
45831: EMPTY
45832: LIST
45833: LIST
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: LIST
45839: PPUSH
45840: CALL_OW 72
45844: ST_TO_ADDR
45845: GO 46033
45847: LD_INT 3
45849: DOUBLE
45850: EQUAL
45851: IFTRUE 45855
45853: GO 45901
45855: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45856: LD_ADDR_VAR 0 8
45860: PUSH
45861: LD_VAR 0 2
45865: PPUSH
45866: LD_INT 2
45868: PUSH
45869: LD_INT 30
45871: PUSH
45872: LD_INT 2
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 30
45881: PUSH
45882: LD_INT 3
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: LIST
45893: PPUSH
45894: CALL_OW 72
45898: ST_TO_ADDR
45899: GO 46033
45901: LD_INT 4
45903: DOUBLE
45904: EQUAL
45905: IFTRUE 45909
45907: GO 45966
45909: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45910: LD_ADDR_VAR 0 8
45914: PUSH
45915: LD_VAR 0 2
45919: PPUSH
45920: LD_INT 2
45922: PUSH
45923: LD_INT 30
45925: PUSH
45926: LD_INT 6
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 30
45935: PUSH
45936: LD_INT 7
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 30
45945: PUSH
45946: LD_INT 8
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: LIST
45957: LIST
45958: PPUSH
45959: CALL_OW 72
45963: ST_TO_ADDR
45964: GO 46033
45966: LD_INT 5
45968: DOUBLE
45969: EQUAL
45970: IFTRUE 45986
45972: LD_INT 8
45974: DOUBLE
45975: EQUAL
45976: IFTRUE 45986
45978: LD_INT 9
45980: DOUBLE
45981: EQUAL
45982: IFTRUE 45986
45984: GO 46032
45986: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45987: LD_ADDR_VAR 0 8
45991: PUSH
45992: LD_VAR 0 2
45996: PPUSH
45997: LD_INT 2
45999: PUSH
46000: LD_INT 30
46002: PUSH
46003: LD_INT 4
46005: PUSH
46006: EMPTY
46007: LIST
46008: LIST
46009: PUSH
46010: LD_INT 30
46012: PUSH
46013: LD_INT 5
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: LIST
46024: PPUSH
46025: CALL_OW 72
46029: ST_TO_ADDR
46030: GO 46033
46032: POP
// if not tmp then
46033: LD_VAR 0 8
46037: NOT
46038: IFFALSE 46042
// exit ;
46040: GO 46502
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
46042: LD_VAR 0 4
46046: PUSH
46047: LD_INT 1
46049: PUSH
46050: LD_INT 15
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: IN
46057: PUSH
46058: LD_EXP 89
46062: PUSH
46063: LD_VAR 0 1
46067: ARRAY
46068: AND
46069: IFFALSE 46225
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
46071: LD_ADDR_VAR 0 9
46075: PUSH
46076: LD_EXP 89
46080: PUSH
46081: LD_VAR 0 1
46085: ARRAY
46086: PUSH
46087: LD_INT 1
46089: ARRAY
46090: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
46091: LD_VAR 0 9
46095: PUSH
46096: LD_EXP 90
46100: PUSH
46101: LD_VAR 0 1
46105: ARRAY
46106: IN
46107: NOT
46108: IFFALSE 46223
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
46110: LD_ADDR_EXP 90
46114: PUSH
46115: LD_EXP 90
46119: PPUSH
46120: LD_VAR 0 1
46124: PUSH
46125: LD_EXP 90
46129: PUSH
46130: LD_VAR 0 1
46134: ARRAY
46135: PUSH
46136: LD_INT 1
46138: PLUS
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: PPUSH
46144: LD_VAR 0 9
46148: PPUSH
46149: CALL 58560 0 3
46153: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
46154: LD_ADDR_EXP 89
46158: PUSH
46159: LD_EXP 89
46163: PPUSH
46164: LD_VAR 0 1
46168: PPUSH
46169: LD_EXP 89
46173: PUSH
46174: LD_VAR 0 1
46178: ARRAY
46179: PUSH
46180: LD_VAR 0 9
46184: DIFF
46185: PPUSH
46186: CALL_OW 1
46190: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
46191: LD_VAR 0 3
46195: PPUSH
46196: LD_EXP 90
46200: PUSH
46201: LD_VAR 0 1
46205: ARRAY
46206: PUSH
46207: LD_EXP 90
46211: PUSH
46212: LD_VAR 0 1
46216: ARRAY
46217: ARRAY
46218: PPUSH
46219: CALL_OW 120
// end ; exit ;
46223: GO 46502
// end ; if tmp > 1 then
46225: LD_VAR 0 8
46229: PUSH
46230: LD_INT 1
46232: GREATER
46233: IFFALSE 46337
// for i = 2 to tmp do
46235: LD_ADDR_VAR 0 6
46239: PUSH
46240: DOUBLE
46241: LD_INT 2
46243: DEC
46244: ST_TO_ADDR
46245: LD_VAR 0 8
46249: PUSH
46250: FOR_TO
46251: IFFALSE 46335
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
46253: LD_VAR 0 8
46257: PUSH
46258: LD_VAR 0 6
46262: ARRAY
46263: PPUSH
46264: CALL_OW 461
46268: PUSH
46269: LD_INT 6
46271: EQUAL
46272: IFFALSE 46333
// begin x := tmp [ i ] ;
46274: LD_ADDR_VAR 0 9
46278: PUSH
46279: LD_VAR 0 8
46283: PUSH
46284: LD_VAR 0 6
46288: ARRAY
46289: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
46290: LD_ADDR_VAR 0 8
46294: PUSH
46295: LD_VAR 0 8
46299: PPUSH
46300: LD_VAR 0 6
46304: PPUSH
46305: CALL_OW 3
46309: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
46310: LD_ADDR_VAR 0 8
46314: PUSH
46315: LD_VAR 0 8
46319: PPUSH
46320: LD_INT 1
46322: PPUSH
46323: LD_VAR 0 9
46327: PPUSH
46328: CALL_OW 2
46332: ST_TO_ADDR
// end ;
46333: GO 46250
46335: POP
46336: POP
// for i in tmp do
46337: LD_ADDR_VAR 0 6
46341: PUSH
46342: LD_VAR 0 8
46346: PUSH
46347: FOR_IN
46348: IFFALSE 46375
// begin if IsNotFull ( i ) then
46350: LD_VAR 0 6
46354: PPUSH
46355: CALL 55782 0 1
46359: IFFALSE 46373
// begin j := i ;
46361: LD_ADDR_VAR 0 7
46365: PUSH
46366: LD_VAR 0 6
46370: ST_TO_ADDR
// break ;
46371: GO 46375
// end ; end ;
46373: GO 46347
46375: POP
46376: POP
// if j then
46377: LD_VAR 0 7
46381: IFFALSE 46399
// ComEnterUnit ( unit , j ) else
46383: LD_VAR 0 3
46387: PPUSH
46388: LD_VAR 0 7
46392: PPUSH
46393: CALL_OW 120
46397: GO 46502
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46399: LD_ADDR_VAR 0 10
46403: PUSH
46404: LD_VAR 0 2
46408: PPUSH
46409: LD_INT 2
46411: PUSH
46412: LD_INT 30
46414: PUSH
46415: LD_INT 0
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: PUSH
46422: LD_INT 30
46424: PUSH
46425: LD_INT 1
46427: PUSH
46428: EMPTY
46429: LIST
46430: LIST
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: LIST
46436: PPUSH
46437: CALL_OW 72
46441: ST_TO_ADDR
// if depot then
46442: LD_VAR 0 10
46446: IFFALSE 46502
// begin depot := NearestUnitToUnit ( depot , unit ) ;
46448: LD_ADDR_VAR 0 10
46452: PUSH
46453: LD_VAR 0 10
46457: PPUSH
46458: LD_VAR 0 3
46462: PPUSH
46463: CALL_OW 74
46467: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
46468: LD_VAR 0 3
46472: PPUSH
46473: LD_VAR 0 10
46477: PPUSH
46478: CALL_OW 296
46482: PUSH
46483: LD_INT 10
46485: GREATER
46486: IFFALSE 46502
// ComStandNearbyBuilding ( unit , depot ) ;
46488: LD_VAR 0 3
46492: PPUSH
46493: LD_VAR 0 10
46497: PPUSH
46498: CALL 55162 0 2
// end ; end ; end ;
46502: LD_VAR 0 5
46506: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
46507: LD_INT 0
46509: PPUSH
46510: PPUSH
46511: PPUSH
46512: PPUSH
// if not mc_bases then
46513: LD_EXP 80
46517: NOT
46518: IFFALSE 46522
// exit ;
46520: GO 46761
// for i = 1 to mc_bases do
46522: LD_ADDR_VAR 0 2
46526: PUSH
46527: DOUBLE
46528: LD_INT 1
46530: DEC
46531: ST_TO_ADDR
46532: LD_EXP 80
46536: PUSH
46537: FOR_TO
46538: IFFALSE 46759
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
46540: LD_ADDR_VAR 0 4
46544: PUSH
46545: LD_EXP 80
46549: PUSH
46550: LD_VAR 0 2
46554: ARRAY
46555: PPUSH
46556: LD_INT 21
46558: PUSH
46559: LD_INT 1
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: PPUSH
46566: CALL_OW 72
46570: PUSH
46571: LD_EXP 109
46575: PUSH
46576: LD_VAR 0 2
46580: ARRAY
46581: UNION
46582: ST_TO_ADDR
// if not tmp then
46583: LD_VAR 0 4
46587: NOT
46588: IFFALSE 46592
// continue ;
46590: GO 46537
// for j in tmp do
46592: LD_ADDR_VAR 0 3
46596: PUSH
46597: LD_VAR 0 4
46601: PUSH
46602: FOR_IN
46603: IFFALSE 46755
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
46605: LD_VAR 0 3
46609: PPUSH
46610: CALL_OW 110
46614: NOT
46615: PUSH
46616: LD_VAR 0 3
46620: PPUSH
46621: CALL_OW 314
46625: NOT
46626: AND
46627: PUSH
46628: LD_VAR 0 3
46632: PPUSH
46633: CALL_OW 311
46637: NOT
46638: AND
46639: PUSH
46640: LD_VAR 0 3
46644: PPUSH
46645: CALL_OW 310
46649: NOT
46650: AND
46651: PUSH
46652: LD_VAR 0 3
46656: PUSH
46657: LD_EXP 83
46661: PUSH
46662: LD_VAR 0 2
46666: ARRAY
46667: PUSH
46668: LD_INT 1
46670: ARRAY
46671: IN
46672: NOT
46673: AND
46674: PUSH
46675: LD_VAR 0 3
46679: PUSH
46680: LD_EXP 83
46684: PUSH
46685: LD_VAR 0 2
46689: ARRAY
46690: PUSH
46691: LD_INT 2
46693: ARRAY
46694: IN
46695: NOT
46696: AND
46697: PUSH
46698: LD_VAR 0 3
46702: PUSH
46703: LD_EXP 92
46707: PUSH
46708: LD_VAR 0 2
46712: ARRAY
46713: IN
46714: NOT
46715: AND
46716: IFFALSE 46753
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46718: LD_VAR 0 2
46722: PPUSH
46723: LD_EXP 80
46727: PUSH
46728: LD_VAR 0 2
46732: ARRAY
46733: PPUSH
46734: LD_VAR 0 3
46738: PPUSH
46739: LD_VAR 0 3
46743: PPUSH
46744: CALL_OW 257
46748: PPUSH
46749: CALL 45567 0 4
// end ;
46753: GO 46602
46755: POP
46756: POP
// end ;
46757: GO 46537
46759: POP
46760: POP
// end ;
46761: LD_VAR 0 1
46765: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46766: LD_INT 0
46768: PPUSH
46769: PPUSH
46770: PPUSH
46771: PPUSH
46772: PPUSH
46773: PPUSH
// if not mc_bases [ base ] then
46774: LD_EXP 80
46778: PUSH
46779: LD_VAR 0 1
46783: ARRAY
46784: NOT
46785: IFFALSE 46789
// exit ;
46787: GO 46990
// tmp := [ ] ;
46789: LD_ADDR_VAR 0 6
46793: PUSH
46794: EMPTY
46795: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46796: LD_ADDR_VAR 0 7
46800: PUSH
46801: LD_VAR 0 3
46805: PPUSH
46806: LD_INT 0
46808: PPUSH
46809: CALL_OW 517
46813: ST_TO_ADDR
// if not list then
46814: LD_VAR 0 7
46818: NOT
46819: IFFALSE 46823
// exit ;
46821: GO 46990
// c := Count ( list [ 1 ] ) ;
46823: LD_ADDR_VAR 0 9
46827: PUSH
46828: LD_VAR 0 7
46832: PUSH
46833: LD_INT 1
46835: ARRAY
46836: PPUSH
46837: CALL 55700 0 1
46841: ST_TO_ADDR
// if amount > c then
46842: LD_VAR 0 2
46846: PUSH
46847: LD_VAR 0 9
46851: GREATER
46852: IFFALSE 46864
// amount := c ;
46854: LD_ADDR_VAR 0 2
46858: PUSH
46859: LD_VAR 0 9
46863: ST_TO_ADDR
// for i := 1 to amount do
46864: LD_ADDR_VAR 0 5
46868: PUSH
46869: DOUBLE
46870: LD_INT 1
46872: DEC
46873: ST_TO_ADDR
46874: LD_VAR 0 2
46878: PUSH
46879: FOR_TO
46880: IFFALSE 46938
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46882: LD_ADDR_VAR 0 6
46886: PUSH
46887: LD_VAR 0 6
46891: PPUSH
46892: LD_VAR 0 5
46896: PPUSH
46897: LD_VAR 0 7
46901: PUSH
46902: LD_INT 1
46904: ARRAY
46905: PUSH
46906: LD_VAR 0 5
46910: ARRAY
46911: PUSH
46912: LD_VAR 0 7
46916: PUSH
46917: LD_INT 2
46919: ARRAY
46920: PUSH
46921: LD_VAR 0 5
46925: ARRAY
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PPUSH
46931: CALL_OW 1
46935: ST_TO_ADDR
46936: GO 46879
46938: POP
46939: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46940: LD_ADDR_EXP 93
46944: PUSH
46945: LD_EXP 93
46949: PPUSH
46950: LD_VAR 0 1
46954: PPUSH
46955: LD_VAR 0 6
46959: PPUSH
46960: CALL_OW 1
46964: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46965: LD_ADDR_EXP 95
46969: PUSH
46970: LD_EXP 95
46974: PPUSH
46975: LD_VAR 0 1
46979: PPUSH
46980: LD_VAR 0 3
46984: PPUSH
46985: CALL_OW 1
46989: ST_TO_ADDR
// end ;
46990: LD_VAR 0 4
46994: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46995: LD_INT 0
46997: PPUSH
// if not mc_bases [ base ] then
46998: LD_EXP 80
47002: PUSH
47003: LD_VAR 0 1
47007: ARRAY
47008: NOT
47009: IFFALSE 47013
// exit ;
47011: GO 47038
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
47013: LD_ADDR_EXP 85
47017: PUSH
47018: LD_EXP 85
47022: PPUSH
47023: LD_VAR 0 1
47027: PPUSH
47028: LD_VAR 0 2
47032: PPUSH
47033: CALL_OW 1
47037: ST_TO_ADDR
// end ;
47038: LD_VAR 0 3
47042: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
47043: LD_INT 0
47045: PPUSH
// if not mc_bases [ base ] then
47046: LD_EXP 80
47050: PUSH
47051: LD_VAR 0 1
47055: ARRAY
47056: NOT
47057: IFFALSE 47061
// exit ;
47059: GO 47098
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
47061: LD_ADDR_EXP 85
47065: PUSH
47066: LD_EXP 85
47070: PPUSH
47071: LD_VAR 0 1
47075: PPUSH
47076: LD_EXP 85
47080: PUSH
47081: LD_VAR 0 1
47085: ARRAY
47086: PUSH
47087: LD_VAR 0 2
47091: UNION
47092: PPUSH
47093: CALL_OW 1
47097: ST_TO_ADDR
// end ;
47098: LD_VAR 0 3
47102: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
47103: LD_INT 0
47105: PPUSH
// if not mc_bases [ base ] then
47106: LD_EXP 80
47110: PUSH
47111: LD_VAR 0 1
47115: ARRAY
47116: NOT
47117: IFFALSE 47121
// exit ;
47119: GO 47146
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
47121: LD_ADDR_EXP 101
47125: PUSH
47126: LD_EXP 101
47130: PPUSH
47131: LD_VAR 0 1
47135: PPUSH
47136: LD_VAR 0 2
47140: PPUSH
47141: CALL_OW 1
47145: ST_TO_ADDR
// end ;
47146: LD_VAR 0 3
47150: RET
// export function MC_InsertProduceList ( base , components ) ; begin
47151: LD_INT 0
47153: PPUSH
// if not mc_bases [ base ] then
47154: LD_EXP 80
47158: PUSH
47159: LD_VAR 0 1
47163: ARRAY
47164: NOT
47165: IFFALSE 47169
// exit ;
47167: GO 47206
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
47169: LD_ADDR_EXP 101
47173: PUSH
47174: LD_EXP 101
47178: PPUSH
47179: LD_VAR 0 1
47183: PPUSH
47184: LD_EXP 101
47188: PUSH
47189: LD_VAR 0 1
47193: ARRAY
47194: PUSH
47195: LD_VAR 0 2
47199: ADD
47200: PPUSH
47201: CALL_OW 1
47205: ST_TO_ADDR
// end ;
47206: LD_VAR 0 3
47210: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
47211: LD_INT 0
47213: PPUSH
// if not mc_bases [ base ] then
47214: LD_EXP 80
47218: PUSH
47219: LD_VAR 0 1
47223: ARRAY
47224: NOT
47225: IFFALSE 47229
// exit ;
47227: GO 47283
// mc_defender := Replace ( mc_defender , base , deflist ) ;
47229: LD_ADDR_EXP 102
47233: PUSH
47234: LD_EXP 102
47238: PPUSH
47239: LD_VAR 0 1
47243: PPUSH
47244: LD_VAR 0 2
47248: PPUSH
47249: CALL_OW 1
47253: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
47254: LD_ADDR_EXP 91
47258: PUSH
47259: LD_EXP 91
47263: PPUSH
47264: LD_VAR 0 1
47268: PPUSH
47269: LD_VAR 0 2
47273: PUSH
47274: LD_INT 0
47276: PLUS
47277: PPUSH
47278: CALL_OW 1
47282: ST_TO_ADDR
// end ;
47283: LD_VAR 0 3
47287: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
47288: LD_INT 0
47290: PPUSH
// if not mc_bases [ base ] then
47291: LD_EXP 80
47295: PUSH
47296: LD_VAR 0 1
47300: ARRAY
47301: NOT
47302: IFFALSE 47306
// exit ;
47304: GO 47331
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
47306: LD_ADDR_EXP 91
47310: PUSH
47311: LD_EXP 91
47315: PPUSH
47316: LD_VAR 0 1
47320: PPUSH
47321: LD_VAR 0 2
47325: PPUSH
47326: CALL_OW 1
47330: ST_TO_ADDR
// end ;
47331: LD_VAR 0 3
47335: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
47336: LD_INT 0
47338: PPUSH
47339: PPUSH
47340: PPUSH
47341: PPUSH
// if not mc_bases [ base ] then
47342: LD_EXP 80
47346: PUSH
47347: LD_VAR 0 1
47351: ARRAY
47352: NOT
47353: IFFALSE 47357
// exit ;
47355: GO 47422
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
47357: LD_ADDR_EXP 100
47361: PUSH
47362: LD_EXP 100
47366: PPUSH
47367: LD_VAR 0 1
47371: PUSH
47372: LD_EXP 100
47376: PUSH
47377: LD_VAR 0 1
47381: ARRAY
47382: PUSH
47383: LD_INT 1
47385: PLUS
47386: PUSH
47387: EMPTY
47388: LIST
47389: LIST
47390: PPUSH
47391: LD_VAR 0 1
47395: PUSH
47396: LD_VAR 0 2
47400: PUSH
47401: LD_VAR 0 3
47405: PUSH
47406: LD_VAR 0 4
47410: PUSH
47411: EMPTY
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: PPUSH
47417: CALL 58560 0 3
47421: ST_TO_ADDR
// end ;
47422: LD_VAR 0 5
47426: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
47427: LD_INT 0
47429: PPUSH
// if not mc_bases [ base ] then
47430: LD_EXP 80
47434: PUSH
47435: LD_VAR 0 1
47439: ARRAY
47440: NOT
47441: IFFALSE 47445
// exit ;
47443: GO 47470
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
47445: LD_ADDR_EXP 117
47449: PUSH
47450: LD_EXP 117
47454: PPUSH
47455: LD_VAR 0 1
47459: PPUSH
47460: LD_VAR 0 2
47464: PPUSH
47465: CALL_OW 1
47469: ST_TO_ADDR
// end ;
47470: LD_VAR 0 3
47474: RET
// export function MC_GetMinesField ( base ) ; begin
47475: LD_INT 0
47477: PPUSH
// result := mc_mines [ base ] ;
47478: LD_ADDR_VAR 0 2
47482: PUSH
47483: LD_EXP 93
47487: PUSH
47488: LD_VAR 0 1
47492: ARRAY
47493: ST_TO_ADDR
// end ;
47494: LD_VAR 0 2
47498: RET
// export function MC_GetProduceList ( base ) ; begin
47499: LD_INT 0
47501: PPUSH
// result := mc_produce [ base ] ;
47502: LD_ADDR_VAR 0 2
47506: PUSH
47507: LD_EXP 101
47511: PUSH
47512: LD_VAR 0 1
47516: ARRAY
47517: ST_TO_ADDR
// end ;
47518: LD_VAR 0 2
47522: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
47523: LD_INT 0
47525: PPUSH
47526: PPUSH
// if not mc_bases then
47527: LD_EXP 80
47531: NOT
47532: IFFALSE 47536
// exit ;
47534: GO 47601
// if mc_bases [ base ] then
47536: LD_EXP 80
47540: PUSH
47541: LD_VAR 0 1
47545: ARRAY
47546: IFFALSE 47601
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47548: LD_ADDR_VAR 0 3
47552: PUSH
47553: LD_EXP 80
47557: PUSH
47558: LD_VAR 0 1
47562: ARRAY
47563: PPUSH
47564: LD_INT 30
47566: PUSH
47567: LD_VAR 0 2
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PPUSH
47576: CALL_OW 72
47580: ST_TO_ADDR
// if result then
47581: LD_VAR 0 3
47585: IFFALSE 47601
// result := result [ 1 ] ;
47587: LD_ADDR_VAR 0 3
47591: PUSH
47592: LD_VAR 0 3
47596: PUSH
47597: LD_INT 1
47599: ARRAY
47600: ST_TO_ADDR
// end ; end ;
47601: LD_VAR 0 3
47605: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
47606: LD_INT 0
47608: PPUSH
47609: PPUSH
// if not mc_bases then
47610: LD_EXP 80
47614: NOT
47615: IFFALSE 47619
// exit ;
47617: GO 47664
// if mc_bases [ base ] then
47619: LD_EXP 80
47623: PUSH
47624: LD_VAR 0 1
47628: ARRAY
47629: IFFALSE 47664
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47631: LD_ADDR_VAR 0 3
47635: PUSH
47636: LD_EXP 80
47640: PUSH
47641: LD_VAR 0 1
47645: ARRAY
47646: PPUSH
47647: LD_INT 30
47649: PUSH
47650: LD_VAR 0 2
47654: PUSH
47655: EMPTY
47656: LIST
47657: LIST
47658: PPUSH
47659: CALL_OW 72
47663: ST_TO_ADDR
// end ;
47664: LD_VAR 0 3
47668: RET
// export function MC_SetTame ( base , area ) ; begin
47669: LD_INT 0
47671: PPUSH
// if not mc_bases or not base then
47672: LD_EXP 80
47676: NOT
47677: PUSH
47678: LD_VAR 0 1
47682: NOT
47683: OR
47684: IFFALSE 47688
// exit ;
47686: GO 47713
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
47688: LD_ADDR_EXP 108
47692: PUSH
47693: LD_EXP 108
47697: PPUSH
47698: LD_VAR 0 1
47702: PPUSH
47703: LD_VAR 0 2
47707: PPUSH
47708: CALL_OW 1
47712: ST_TO_ADDR
// end ;
47713: LD_VAR 0 3
47717: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47718: LD_INT 0
47720: PPUSH
47721: PPUSH
// if not mc_bases or not base then
47722: LD_EXP 80
47726: NOT
47727: PUSH
47728: LD_VAR 0 1
47732: NOT
47733: OR
47734: IFFALSE 47738
// exit ;
47736: GO 47840
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47738: LD_ADDR_VAR 0 4
47742: PUSH
47743: LD_EXP 80
47747: PUSH
47748: LD_VAR 0 1
47752: ARRAY
47753: PPUSH
47754: LD_INT 30
47756: PUSH
47757: LD_VAR 0 2
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PPUSH
47766: CALL_OW 72
47770: ST_TO_ADDR
// if not tmp then
47771: LD_VAR 0 4
47775: NOT
47776: IFFALSE 47780
// exit ;
47778: GO 47840
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47780: LD_ADDR_EXP 112
47784: PUSH
47785: LD_EXP 112
47789: PPUSH
47790: LD_VAR 0 1
47794: PPUSH
47795: LD_EXP 112
47799: PUSH
47800: LD_VAR 0 1
47804: ARRAY
47805: PPUSH
47806: LD_EXP 112
47810: PUSH
47811: LD_VAR 0 1
47815: ARRAY
47816: PUSH
47817: LD_INT 1
47819: PLUS
47820: PPUSH
47821: LD_VAR 0 4
47825: PUSH
47826: LD_INT 1
47828: ARRAY
47829: PPUSH
47830: CALL_OW 2
47834: PPUSH
47835: CALL_OW 1
47839: ST_TO_ADDR
// end ;
47840: LD_VAR 0 3
47844: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47845: LD_INT 0
47847: PPUSH
47848: PPUSH
// if not mc_bases or not base or not kinds then
47849: LD_EXP 80
47853: NOT
47854: PUSH
47855: LD_VAR 0 1
47859: NOT
47860: OR
47861: PUSH
47862: LD_VAR 0 2
47866: NOT
47867: OR
47868: IFFALSE 47872
// exit ;
47870: GO 47933
// for i in kinds do
47872: LD_ADDR_VAR 0 4
47876: PUSH
47877: LD_VAR 0 2
47881: PUSH
47882: FOR_IN
47883: IFFALSE 47931
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47885: LD_ADDR_EXP 114
47889: PUSH
47890: LD_EXP 114
47894: PPUSH
47895: LD_VAR 0 1
47899: PUSH
47900: LD_EXP 114
47904: PUSH
47905: LD_VAR 0 1
47909: ARRAY
47910: PUSH
47911: LD_INT 1
47913: PLUS
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PPUSH
47919: LD_VAR 0 4
47923: PPUSH
47924: CALL 58560 0 3
47928: ST_TO_ADDR
47929: GO 47882
47931: POP
47932: POP
// end ;
47933: LD_VAR 0 3
47937: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47938: LD_INT 0
47940: PPUSH
// if not mc_bases or not base or not areas then
47941: LD_EXP 80
47945: NOT
47946: PUSH
47947: LD_VAR 0 1
47951: NOT
47952: OR
47953: PUSH
47954: LD_VAR 0 2
47958: NOT
47959: OR
47960: IFFALSE 47964
// exit ;
47962: GO 47989
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47964: LD_ADDR_EXP 98
47968: PUSH
47969: LD_EXP 98
47973: PPUSH
47974: LD_VAR 0 1
47978: PPUSH
47979: LD_VAR 0 2
47983: PPUSH
47984: CALL_OW 1
47988: ST_TO_ADDR
// end ;
47989: LD_VAR 0 3
47993: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47994: LD_INT 0
47996: PPUSH
// if not mc_bases or not base or not teleports_exit then
47997: LD_EXP 80
48001: NOT
48002: PUSH
48003: LD_VAR 0 1
48007: NOT
48008: OR
48009: PUSH
48010: LD_VAR 0 2
48014: NOT
48015: OR
48016: IFFALSE 48020
// exit ;
48018: GO 48045
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
48020: LD_ADDR_EXP 115
48024: PUSH
48025: LD_EXP 115
48029: PPUSH
48030: LD_VAR 0 1
48034: PPUSH
48035: LD_VAR 0 2
48039: PPUSH
48040: CALL_OW 1
48044: ST_TO_ADDR
// end ;
48045: LD_VAR 0 3
48049: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
48050: LD_INT 0
48052: PPUSH
48053: PPUSH
48054: PPUSH
// if not mc_bases or not base or not ext_list then
48055: LD_EXP 80
48059: NOT
48060: PUSH
48061: LD_VAR 0 1
48065: NOT
48066: OR
48067: PUSH
48068: LD_VAR 0 5
48072: NOT
48073: OR
48074: IFFALSE 48078
// exit ;
48076: GO 48251
// tmp := GetFacExtXYD ( x , y , d ) ;
48078: LD_ADDR_VAR 0 8
48082: PUSH
48083: LD_VAR 0 2
48087: PPUSH
48088: LD_VAR 0 3
48092: PPUSH
48093: LD_VAR 0 4
48097: PPUSH
48098: CALL 88943 0 3
48102: ST_TO_ADDR
// if not tmp then
48103: LD_VAR 0 8
48107: NOT
48108: IFFALSE 48112
// exit ;
48110: GO 48251
// for i in tmp do
48112: LD_ADDR_VAR 0 7
48116: PUSH
48117: LD_VAR 0 8
48121: PUSH
48122: FOR_IN
48123: IFFALSE 48249
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
48125: LD_ADDR_EXP 85
48129: PUSH
48130: LD_EXP 85
48134: PPUSH
48135: LD_VAR 0 1
48139: PPUSH
48140: LD_EXP 85
48144: PUSH
48145: LD_VAR 0 1
48149: ARRAY
48150: PPUSH
48151: LD_EXP 85
48155: PUSH
48156: LD_VAR 0 1
48160: ARRAY
48161: PUSH
48162: LD_INT 1
48164: PLUS
48165: PPUSH
48166: LD_VAR 0 5
48170: PUSH
48171: LD_INT 1
48173: ARRAY
48174: PUSH
48175: LD_VAR 0 7
48179: PUSH
48180: LD_INT 1
48182: ARRAY
48183: PUSH
48184: LD_VAR 0 7
48188: PUSH
48189: LD_INT 2
48191: ARRAY
48192: PUSH
48193: LD_VAR 0 7
48197: PUSH
48198: LD_INT 3
48200: ARRAY
48201: PUSH
48202: EMPTY
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: PPUSH
48208: CALL_OW 2
48212: PPUSH
48213: CALL_OW 1
48217: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
48218: LD_ADDR_VAR 0 5
48222: PUSH
48223: LD_VAR 0 5
48227: PPUSH
48228: LD_INT 1
48230: PPUSH
48231: CALL_OW 3
48235: ST_TO_ADDR
// if not ext_list then
48236: LD_VAR 0 5
48240: NOT
48241: IFFALSE 48247
// exit ;
48243: POP
48244: POP
48245: GO 48251
// end ;
48247: GO 48122
48249: POP
48250: POP
// end ;
48251: LD_VAR 0 6
48255: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
48256: LD_INT 0
48258: PPUSH
// if not mc_bases or not base or not weapon_list then
48259: LD_EXP 80
48263: NOT
48264: PUSH
48265: LD_VAR 0 1
48269: NOT
48270: OR
48271: PUSH
48272: LD_VAR 0 2
48276: NOT
48277: OR
48278: IFFALSE 48282
// exit ;
48280: GO 48307
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
48282: LD_ADDR_EXP 119
48286: PUSH
48287: LD_EXP 119
48291: PPUSH
48292: LD_VAR 0 1
48296: PPUSH
48297: LD_VAR 0 2
48301: PPUSH
48302: CALL_OW 1
48306: ST_TO_ADDR
// end ;
48307: LD_VAR 0 3
48311: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
48312: LD_INT 0
48314: PPUSH
// if not mc_bases or not base or not tech_list then
48315: LD_EXP 80
48319: NOT
48320: PUSH
48321: LD_VAR 0 1
48325: NOT
48326: OR
48327: PUSH
48328: LD_VAR 0 2
48332: NOT
48333: OR
48334: IFFALSE 48338
// exit ;
48336: GO 48363
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
48338: LD_ADDR_EXP 107
48342: PUSH
48343: LD_EXP 107
48347: PPUSH
48348: LD_VAR 0 1
48352: PPUSH
48353: LD_VAR 0 2
48357: PPUSH
48358: CALL_OW 1
48362: ST_TO_ADDR
// end ;
48363: LD_VAR 0 3
48367: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
48368: LD_INT 0
48370: PPUSH
// if not mc_bases or not parking_area or not base then
48371: LD_EXP 80
48375: NOT
48376: PUSH
48377: LD_VAR 0 2
48381: NOT
48382: OR
48383: PUSH
48384: LD_VAR 0 1
48388: NOT
48389: OR
48390: IFFALSE 48394
// exit ;
48392: GO 48419
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
48394: LD_ADDR_EXP 104
48398: PUSH
48399: LD_EXP 104
48403: PPUSH
48404: LD_VAR 0 1
48408: PPUSH
48409: LD_VAR 0 2
48413: PPUSH
48414: CALL_OW 1
48418: ST_TO_ADDR
// end ;
48419: LD_VAR 0 3
48423: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
48424: LD_INT 0
48426: PPUSH
// if not mc_bases or not base or not scan_area then
48427: LD_EXP 80
48431: NOT
48432: PUSH
48433: LD_VAR 0 1
48437: NOT
48438: OR
48439: PUSH
48440: LD_VAR 0 2
48444: NOT
48445: OR
48446: IFFALSE 48450
// exit ;
48448: GO 48475
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
48450: LD_ADDR_EXP 105
48454: PUSH
48455: LD_EXP 105
48459: PPUSH
48460: LD_VAR 0 1
48464: PPUSH
48465: LD_VAR 0 2
48469: PPUSH
48470: CALL_OW 1
48474: ST_TO_ADDR
// end ;
48475: LD_VAR 0 3
48479: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
48480: LD_INT 0
48482: PPUSH
48483: PPUSH
// if not mc_bases or not base then
48484: LD_EXP 80
48488: NOT
48489: PUSH
48490: LD_VAR 0 1
48494: NOT
48495: OR
48496: IFFALSE 48500
// exit ;
48498: GO 48564
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
48500: LD_ADDR_VAR 0 3
48504: PUSH
48505: LD_INT 1
48507: PUSH
48508: LD_INT 2
48510: PUSH
48511: LD_INT 3
48513: PUSH
48514: LD_INT 4
48516: PUSH
48517: LD_INT 11
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: LIST
48526: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
48527: LD_ADDR_EXP 107
48531: PUSH
48532: LD_EXP 107
48536: PPUSH
48537: LD_VAR 0 1
48541: PPUSH
48542: LD_EXP 107
48546: PUSH
48547: LD_VAR 0 1
48551: ARRAY
48552: PUSH
48553: LD_VAR 0 3
48557: DIFF
48558: PPUSH
48559: CALL_OW 1
48563: ST_TO_ADDR
// end ;
48564: LD_VAR 0 2
48568: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
48569: LD_INT 0
48571: PPUSH
// result := mc_vehicles [ base ] ;
48572: LD_ADDR_VAR 0 3
48576: PUSH
48577: LD_EXP 99
48581: PUSH
48582: LD_VAR 0 1
48586: ARRAY
48587: ST_TO_ADDR
// if onlyCombat then
48588: LD_VAR 0 2
48592: IFFALSE 48764
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
48594: LD_ADDR_VAR 0 3
48598: PUSH
48599: LD_VAR 0 3
48603: PUSH
48604: LD_VAR 0 3
48608: PPUSH
48609: LD_INT 2
48611: PUSH
48612: LD_INT 34
48614: PUSH
48615: LD_INT 12
48617: PUSH
48618: EMPTY
48619: LIST
48620: LIST
48621: PUSH
48622: LD_INT 34
48624: PUSH
48625: LD_INT 51
48627: PUSH
48628: EMPTY
48629: LIST
48630: LIST
48631: PUSH
48632: LD_INT 34
48634: PUSH
48635: LD_INT 89
48637: PUSH
48638: EMPTY
48639: LIST
48640: LIST
48641: PUSH
48642: LD_INT 34
48644: PUSH
48645: LD_INT 32
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 34
48654: PUSH
48655: LD_INT 13
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: PUSH
48662: LD_INT 34
48664: PUSH
48665: LD_INT 52
48667: PUSH
48668: EMPTY
48669: LIST
48670: LIST
48671: PUSH
48672: LD_INT 34
48674: PUSH
48675: LD_INT 88
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: PUSH
48682: LD_INT 34
48684: PUSH
48685: LD_INT 14
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PUSH
48692: LD_INT 34
48694: PUSH
48695: LD_INT 53
48697: PUSH
48698: EMPTY
48699: LIST
48700: LIST
48701: PUSH
48702: LD_INT 34
48704: PUSH
48705: LD_INT 98
48707: PUSH
48708: EMPTY
48709: LIST
48710: LIST
48711: PUSH
48712: LD_INT 34
48714: PUSH
48715: LD_INT 31
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PUSH
48722: LD_INT 34
48724: PUSH
48725: LD_INT 48
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: LD_INT 34
48734: PUSH
48735: LD_INT 8
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: LIST
48746: LIST
48747: LIST
48748: LIST
48749: LIST
48750: LIST
48751: LIST
48752: LIST
48753: LIST
48754: LIST
48755: LIST
48756: LIST
48757: PPUSH
48758: CALL_OW 72
48762: DIFF
48763: ST_TO_ADDR
// end ; end_of_file
48764: LD_VAR 0 3
48768: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48769: LD_INT 0
48771: PPUSH
48772: PPUSH
48773: PPUSH
// if not mc_bases or not skirmish then
48774: LD_EXP 80
48778: NOT
48779: PUSH
48780: LD_EXP 78
48784: NOT
48785: OR
48786: IFFALSE 48790
// exit ;
48788: GO 48955
// for i = 1 to mc_bases do
48790: LD_ADDR_VAR 0 4
48794: PUSH
48795: DOUBLE
48796: LD_INT 1
48798: DEC
48799: ST_TO_ADDR
48800: LD_EXP 80
48804: PUSH
48805: FOR_TO
48806: IFFALSE 48953
// begin if sci in mc_bases [ i ] then
48808: LD_VAR 0 2
48812: PUSH
48813: LD_EXP 80
48817: PUSH
48818: LD_VAR 0 4
48822: ARRAY
48823: IN
48824: IFFALSE 48951
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48826: LD_ADDR_EXP 109
48830: PUSH
48831: LD_EXP 109
48835: PPUSH
48836: LD_VAR 0 4
48840: PUSH
48841: LD_EXP 109
48845: PUSH
48846: LD_VAR 0 4
48850: ARRAY
48851: PUSH
48852: LD_INT 1
48854: PLUS
48855: PUSH
48856: EMPTY
48857: LIST
48858: LIST
48859: PPUSH
48860: LD_VAR 0 1
48864: PPUSH
48865: CALL 58560 0 3
48869: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48870: LD_ADDR_VAR 0 5
48874: PUSH
48875: LD_EXP 80
48879: PUSH
48880: LD_VAR 0 4
48884: ARRAY
48885: PPUSH
48886: LD_INT 2
48888: PUSH
48889: LD_INT 30
48891: PUSH
48892: LD_INT 0
48894: PUSH
48895: EMPTY
48896: LIST
48897: LIST
48898: PUSH
48899: LD_INT 30
48901: PUSH
48902: LD_INT 1
48904: PUSH
48905: EMPTY
48906: LIST
48907: LIST
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: LIST
48913: PPUSH
48914: CALL_OW 72
48918: PPUSH
48919: LD_VAR 0 1
48923: PPUSH
48924: CALL_OW 74
48928: ST_TO_ADDR
// if tmp then
48929: LD_VAR 0 5
48933: IFFALSE 48949
// ComStandNearbyBuilding ( ape , tmp ) ;
48935: LD_VAR 0 1
48939: PPUSH
48940: LD_VAR 0 5
48944: PPUSH
48945: CALL 55162 0 2
// break ;
48949: GO 48953
// end ; end ;
48951: GO 48805
48953: POP
48954: POP
// end ;
48955: LD_VAR 0 3
48959: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48960: LD_INT 0
48962: PPUSH
48963: PPUSH
48964: PPUSH
// if not mc_bases or not skirmish then
48965: LD_EXP 80
48969: NOT
48970: PUSH
48971: LD_EXP 78
48975: NOT
48976: OR
48977: IFFALSE 48981
// exit ;
48979: GO 49070
// for i = 1 to mc_bases do
48981: LD_ADDR_VAR 0 4
48985: PUSH
48986: DOUBLE
48987: LD_INT 1
48989: DEC
48990: ST_TO_ADDR
48991: LD_EXP 80
48995: PUSH
48996: FOR_TO
48997: IFFALSE 49068
// begin if building in mc_busy_turret_list [ i ] then
48999: LD_VAR 0 1
49003: PUSH
49004: LD_EXP 90
49008: PUSH
49009: LD_VAR 0 4
49013: ARRAY
49014: IN
49015: IFFALSE 49066
// begin tmp := mc_busy_turret_list [ i ] diff building ;
49017: LD_ADDR_VAR 0 5
49021: PUSH
49022: LD_EXP 90
49026: PUSH
49027: LD_VAR 0 4
49031: ARRAY
49032: PUSH
49033: LD_VAR 0 1
49037: DIFF
49038: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
49039: LD_ADDR_EXP 90
49043: PUSH
49044: LD_EXP 90
49048: PPUSH
49049: LD_VAR 0 4
49053: PPUSH
49054: LD_VAR 0 5
49058: PPUSH
49059: CALL_OW 1
49063: ST_TO_ADDR
// break ;
49064: GO 49068
// end ; end ;
49066: GO 48996
49068: POP
49069: POP
// end ;
49070: LD_VAR 0 3
49074: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
49075: LD_INT 0
49077: PPUSH
49078: PPUSH
49079: PPUSH
// if not mc_bases or not skirmish then
49080: LD_EXP 80
49084: NOT
49085: PUSH
49086: LD_EXP 78
49090: NOT
49091: OR
49092: IFFALSE 49096
// exit ;
49094: GO 49295
// for i = 1 to mc_bases do
49096: LD_ADDR_VAR 0 5
49100: PUSH
49101: DOUBLE
49102: LD_INT 1
49104: DEC
49105: ST_TO_ADDR
49106: LD_EXP 80
49110: PUSH
49111: FOR_TO
49112: IFFALSE 49293
// if building in mc_bases [ i ] then
49114: LD_VAR 0 1
49118: PUSH
49119: LD_EXP 80
49123: PUSH
49124: LD_VAR 0 5
49128: ARRAY
49129: IN
49130: IFFALSE 49291
// begin tmp := mc_bases [ i ] diff building ;
49132: LD_ADDR_VAR 0 6
49136: PUSH
49137: LD_EXP 80
49141: PUSH
49142: LD_VAR 0 5
49146: ARRAY
49147: PUSH
49148: LD_VAR 0 1
49152: DIFF
49153: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
49154: LD_ADDR_EXP 80
49158: PUSH
49159: LD_EXP 80
49163: PPUSH
49164: LD_VAR 0 5
49168: PPUSH
49169: LD_VAR 0 6
49173: PPUSH
49174: CALL_OW 1
49178: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
49179: LD_VAR 0 1
49183: PUSH
49184: LD_EXP 88
49188: PUSH
49189: LD_VAR 0 5
49193: ARRAY
49194: IN
49195: IFFALSE 49234
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
49197: LD_ADDR_EXP 88
49201: PUSH
49202: LD_EXP 88
49206: PPUSH
49207: LD_VAR 0 5
49211: PPUSH
49212: LD_EXP 88
49216: PUSH
49217: LD_VAR 0 5
49221: ARRAY
49222: PUSH
49223: LD_VAR 0 1
49227: DIFF
49228: PPUSH
49229: CALL_OW 1
49233: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
49234: LD_VAR 0 1
49238: PUSH
49239: LD_EXP 89
49243: PUSH
49244: LD_VAR 0 5
49248: ARRAY
49249: IN
49250: IFFALSE 49289
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
49252: LD_ADDR_EXP 89
49256: PUSH
49257: LD_EXP 89
49261: PPUSH
49262: LD_VAR 0 5
49266: PPUSH
49267: LD_EXP 89
49271: PUSH
49272: LD_VAR 0 5
49276: ARRAY
49277: PUSH
49278: LD_VAR 0 1
49282: DIFF
49283: PPUSH
49284: CALL_OW 1
49288: ST_TO_ADDR
// break ;
49289: GO 49293
// end ;
49291: GO 49111
49293: POP
49294: POP
// end ;
49295: LD_VAR 0 4
49299: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
49300: LD_INT 0
49302: PPUSH
49303: PPUSH
49304: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
49305: LD_EXP 80
49309: NOT
49310: PUSH
49311: LD_EXP 78
49315: NOT
49316: OR
49317: PUSH
49318: LD_VAR 0 3
49322: PUSH
49323: LD_EXP 106
49327: IN
49328: NOT
49329: OR
49330: IFFALSE 49334
// exit ;
49332: GO 49457
// for i = 1 to mc_vehicles do
49334: LD_ADDR_VAR 0 6
49338: PUSH
49339: DOUBLE
49340: LD_INT 1
49342: DEC
49343: ST_TO_ADDR
49344: LD_EXP 99
49348: PUSH
49349: FOR_TO
49350: IFFALSE 49455
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
49352: LD_VAR 0 2
49356: PUSH
49357: LD_EXP 99
49361: PUSH
49362: LD_VAR 0 6
49366: ARRAY
49367: IN
49368: PUSH
49369: LD_VAR 0 1
49373: PUSH
49374: LD_EXP 99
49378: PUSH
49379: LD_VAR 0 6
49383: ARRAY
49384: IN
49385: OR
49386: IFFALSE 49453
// begin tmp := mc_vehicles [ i ] diff old ;
49388: LD_ADDR_VAR 0 7
49392: PUSH
49393: LD_EXP 99
49397: PUSH
49398: LD_VAR 0 6
49402: ARRAY
49403: PUSH
49404: LD_VAR 0 2
49408: DIFF
49409: ST_TO_ADDR
// tmp := tmp diff new ;
49410: LD_ADDR_VAR 0 7
49414: PUSH
49415: LD_VAR 0 7
49419: PUSH
49420: LD_VAR 0 1
49424: DIFF
49425: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
49426: LD_ADDR_EXP 99
49430: PUSH
49431: LD_EXP 99
49435: PPUSH
49436: LD_VAR 0 6
49440: PPUSH
49441: LD_VAR 0 7
49445: PPUSH
49446: CALL_OW 1
49450: ST_TO_ADDR
// break ;
49451: GO 49455
// end ;
49453: GO 49349
49455: POP
49456: POP
// end ;
49457: LD_VAR 0 5
49461: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
49462: LD_INT 0
49464: PPUSH
49465: PPUSH
49466: PPUSH
49467: PPUSH
// if not mc_bases or not skirmish then
49468: LD_EXP 80
49472: NOT
49473: PUSH
49474: LD_EXP 78
49478: NOT
49479: OR
49480: IFFALSE 49484
// exit ;
49482: GO 49904
// repeat wait ( 0 0$1 ) ;
49484: LD_INT 35
49486: PPUSH
49487: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
49491: LD_EXP 124
49495: NOT
49496: IFFALSE 49484
// mc_block_vehicle_constructed_thread := true ;
49498: LD_ADDR_EXP 124
49502: PUSH
49503: LD_INT 1
49505: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
49506: LD_ADDR_VAR 0 5
49510: PUSH
49511: LD_VAR 0 1
49515: PPUSH
49516: CALL_OW 255
49520: ST_TO_ADDR
// for i = 1 to mc_bases do
49521: LD_ADDR_VAR 0 4
49525: PUSH
49526: DOUBLE
49527: LD_INT 1
49529: DEC
49530: ST_TO_ADDR
49531: LD_EXP 80
49535: PUSH
49536: FOR_TO
49537: IFFALSE 49894
// begin if factory in mc_bases [ i ] then
49539: LD_VAR 0 2
49543: PUSH
49544: LD_EXP 80
49548: PUSH
49549: LD_VAR 0 4
49553: ARRAY
49554: IN
49555: IFFALSE 49892
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
49557: LD_EXP 102
49561: PUSH
49562: LD_VAR 0 4
49566: ARRAY
49567: PUSH
49568: LD_EXP 91
49572: PUSH
49573: LD_VAR 0 4
49577: ARRAY
49578: LESS
49579: PUSH
49580: LD_VAR 0 1
49584: PPUSH
49585: CALL_OW 264
49589: PUSH
49590: LD_INT 31
49592: PUSH
49593: LD_INT 32
49595: PUSH
49596: LD_INT 51
49598: PUSH
49599: LD_INT 89
49601: PUSH
49602: LD_INT 12
49604: PUSH
49605: LD_INT 30
49607: PUSH
49608: LD_INT 98
49610: PUSH
49611: LD_INT 11
49613: PUSH
49614: LD_INT 53
49616: PUSH
49617: LD_INT 14
49619: PUSH
49620: LD_INT 91
49622: PUSH
49623: LD_INT 29
49625: PUSH
49626: LD_INT 99
49628: PUSH
49629: LD_INT 13
49631: PUSH
49632: LD_INT 52
49634: PUSH
49635: LD_INT 88
49637: PUSH
49638: LD_INT 48
49640: PUSH
49641: LD_INT 8
49643: PUSH
49644: EMPTY
49645: LIST
49646: LIST
49647: LIST
49648: LIST
49649: LIST
49650: LIST
49651: LIST
49652: LIST
49653: LIST
49654: LIST
49655: LIST
49656: LIST
49657: LIST
49658: LIST
49659: LIST
49660: LIST
49661: LIST
49662: LIST
49663: IN
49664: NOT
49665: AND
49666: IFFALSE 49714
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
49668: LD_ADDR_EXP 102
49672: PUSH
49673: LD_EXP 102
49677: PPUSH
49678: LD_VAR 0 4
49682: PUSH
49683: LD_EXP 102
49687: PUSH
49688: LD_VAR 0 4
49692: ARRAY
49693: PUSH
49694: LD_INT 1
49696: PLUS
49697: PUSH
49698: EMPTY
49699: LIST
49700: LIST
49701: PPUSH
49702: LD_VAR 0 1
49706: PPUSH
49707: CALL 58560 0 3
49711: ST_TO_ADDR
49712: GO 49758
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
49714: LD_ADDR_EXP 99
49718: PUSH
49719: LD_EXP 99
49723: PPUSH
49724: LD_VAR 0 4
49728: PUSH
49729: LD_EXP 99
49733: PUSH
49734: LD_VAR 0 4
49738: ARRAY
49739: PUSH
49740: LD_INT 1
49742: PLUS
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: PPUSH
49748: LD_VAR 0 1
49752: PPUSH
49753: CALL 58560 0 3
49757: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49758: LD_ADDR_EXP 124
49762: PUSH
49763: LD_INT 0
49765: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49766: LD_VAR 0 1
49770: PPUSH
49771: CALL_OW 263
49775: PUSH
49776: LD_INT 2
49778: EQUAL
49779: IFFALSE 49808
// begin repeat wait ( 0 0$3 ) ;
49781: LD_INT 105
49783: PPUSH
49784: CALL_OW 67
// Connect ( vehicle ) ;
49788: LD_VAR 0 1
49792: PPUSH
49793: CALL 61906 0 1
// until IsControledBy ( vehicle ) ;
49797: LD_VAR 0 1
49801: PPUSH
49802: CALL_OW 312
49806: IFFALSE 49781
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49808: LD_VAR 0 1
49812: PPUSH
49813: LD_EXP 104
49817: PUSH
49818: LD_VAR 0 4
49822: ARRAY
49823: PPUSH
49824: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49828: LD_VAR 0 1
49832: PPUSH
49833: CALL_OW 263
49837: PUSH
49838: LD_INT 1
49840: NONEQUAL
49841: IFFALSE 49845
// break ;
49843: GO 49894
// repeat wait ( 0 0$1 ) ;
49845: LD_INT 35
49847: PPUSH
49848: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49852: LD_VAR 0 1
49856: PPUSH
49857: LD_EXP 104
49861: PUSH
49862: LD_VAR 0 4
49866: ARRAY
49867: PPUSH
49868: CALL_OW 308
49872: IFFALSE 49845
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49874: LD_VAR 0 1
49878: PPUSH
49879: CALL_OW 311
49883: PPUSH
49884: CALL_OW 121
// exit ;
49888: POP
49889: POP
49890: GO 49904
// end ; end ;
49892: GO 49536
49894: POP
49895: POP
// mc_block_vehicle_constructed_thread := false ;
49896: LD_ADDR_EXP 124
49900: PUSH
49901: LD_INT 0
49903: ST_TO_ADDR
// end ;
49904: LD_VAR 0 3
49908: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49909: LD_INT 0
49911: PPUSH
49912: PPUSH
49913: PPUSH
49914: PPUSH
// if not mc_bases or not skirmish then
49915: LD_EXP 80
49919: NOT
49920: PUSH
49921: LD_EXP 78
49925: NOT
49926: OR
49927: IFFALSE 49931
// exit ;
49929: GO 50284
// repeat wait ( 0 0$1 ) ;
49931: LD_INT 35
49933: PPUSH
49934: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49938: LD_VAR 0 2
49942: PPUSH
49943: LD_VAR 0 3
49947: PPUSH
49948: CALL_OW 284
49952: IFFALSE 49931
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49954: LD_VAR 0 2
49958: PPUSH
49959: LD_VAR 0 3
49963: PPUSH
49964: CALL_OW 283
49968: PUSH
49969: LD_INT 4
49971: EQUAL
49972: IFFALSE 49976
// exit ;
49974: GO 50284
// for i = 1 to mc_bases do
49976: LD_ADDR_VAR 0 7
49980: PUSH
49981: DOUBLE
49982: LD_INT 1
49984: DEC
49985: ST_TO_ADDR
49986: LD_EXP 80
49990: PUSH
49991: FOR_TO
49992: IFFALSE 50282
// begin if mc_crates_area [ i ] then
49994: LD_EXP 98
49998: PUSH
49999: LD_VAR 0 7
50003: ARRAY
50004: IFFALSE 50115
// for j in mc_crates_area [ i ] do
50006: LD_ADDR_VAR 0 8
50010: PUSH
50011: LD_EXP 98
50015: PUSH
50016: LD_VAR 0 7
50020: ARRAY
50021: PUSH
50022: FOR_IN
50023: IFFALSE 50113
// if InArea ( x , y , j ) then
50025: LD_VAR 0 2
50029: PPUSH
50030: LD_VAR 0 3
50034: PPUSH
50035: LD_VAR 0 8
50039: PPUSH
50040: CALL_OW 309
50044: IFFALSE 50111
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50046: LD_ADDR_EXP 96
50050: PUSH
50051: LD_EXP 96
50055: PPUSH
50056: LD_VAR 0 7
50060: PUSH
50061: LD_EXP 96
50065: PUSH
50066: LD_VAR 0 7
50070: ARRAY
50071: PUSH
50072: LD_INT 1
50074: PLUS
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: PPUSH
50080: LD_VAR 0 4
50084: PUSH
50085: LD_VAR 0 2
50089: PUSH
50090: LD_VAR 0 3
50094: PUSH
50095: EMPTY
50096: LIST
50097: LIST
50098: LIST
50099: PPUSH
50100: CALL 58560 0 3
50104: ST_TO_ADDR
// exit ;
50105: POP
50106: POP
50107: POP
50108: POP
50109: GO 50284
// end ;
50111: GO 50022
50113: POP
50114: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50115: LD_ADDR_VAR 0 9
50119: PUSH
50120: LD_EXP 80
50124: PUSH
50125: LD_VAR 0 7
50129: ARRAY
50130: PPUSH
50131: LD_INT 2
50133: PUSH
50134: LD_INT 30
50136: PUSH
50137: LD_INT 0
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: LD_INT 30
50146: PUSH
50147: LD_INT 1
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: EMPTY
50155: LIST
50156: LIST
50157: LIST
50158: PPUSH
50159: CALL_OW 72
50163: ST_TO_ADDR
// if not depot then
50164: LD_VAR 0 9
50168: NOT
50169: IFFALSE 50173
// continue ;
50171: GO 49991
// for j in depot do
50173: LD_ADDR_VAR 0 8
50177: PUSH
50178: LD_VAR 0 9
50182: PUSH
50183: FOR_IN
50184: IFFALSE 50278
// if GetDistUnitXY ( j , x , y ) < 30 then
50186: LD_VAR 0 8
50190: PPUSH
50191: LD_VAR 0 2
50195: PPUSH
50196: LD_VAR 0 3
50200: PPUSH
50201: CALL_OW 297
50205: PUSH
50206: LD_INT 30
50208: LESS
50209: IFFALSE 50276
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50211: LD_ADDR_EXP 96
50215: PUSH
50216: LD_EXP 96
50220: PPUSH
50221: LD_VAR 0 7
50225: PUSH
50226: LD_EXP 96
50230: PUSH
50231: LD_VAR 0 7
50235: ARRAY
50236: PUSH
50237: LD_INT 1
50239: PLUS
50240: PUSH
50241: EMPTY
50242: LIST
50243: LIST
50244: PPUSH
50245: LD_VAR 0 4
50249: PUSH
50250: LD_VAR 0 2
50254: PUSH
50255: LD_VAR 0 3
50259: PUSH
50260: EMPTY
50261: LIST
50262: LIST
50263: LIST
50264: PPUSH
50265: CALL 58560 0 3
50269: ST_TO_ADDR
// exit ;
50270: POP
50271: POP
50272: POP
50273: POP
50274: GO 50284
// end ;
50276: GO 50183
50278: POP
50279: POP
// end ;
50280: GO 49991
50282: POP
50283: POP
// end ;
50284: LD_VAR 0 6
50288: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
50289: LD_INT 0
50291: PPUSH
50292: PPUSH
50293: PPUSH
50294: PPUSH
// if not mc_bases or not skirmish then
50295: LD_EXP 80
50299: NOT
50300: PUSH
50301: LD_EXP 78
50305: NOT
50306: OR
50307: IFFALSE 50311
// exit ;
50309: GO 50588
// side := GetSide ( lab ) ;
50311: LD_ADDR_VAR 0 4
50315: PUSH
50316: LD_VAR 0 2
50320: PPUSH
50321: CALL_OW 255
50325: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
50326: LD_VAR 0 4
50330: PUSH
50331: LD_EXP 106
50335: IN
50336: NOT
50337: PUSH
50338: LD_EXP 107
50342: NOT
50343: OR
50344: PUSH
50345: LD_EXP 80
50349: NOT
50350: OR
50351: IFFALSE 50355
// exit ;
50353: GO 50588
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
50355: LD_ADDR_EXP 107
50359: PUSH
50360: LD_EXP 107
50364: PPUSH
50365: LD_VAR 0 4
50369: PPUSH
50370: LD_EXP 107
50374: PUSH
50375: LD_VAR 0 4
50379: ARRAY
50380: PUSH
50381: LD_VAR 0 1
50385: DIFF
50386: PPUSH
50387: CALL_OW 1
50391: ST_TO_ADDR
// for i = 1 to mc_bases do
50392: LD_ADDR_VAR 0 5
50396: PUSH
50397: DOUBLE
50398: LD_INT 1
50400: DEC
50401: ST_TO_ADDR
50402: LD_EXP 80
50406: PUSH
50407: FOR_TO
50408: IFFALSE 50586
// begin if lab in mc_bases [ i ] then
50410: LD_VAR 0 2
50414: PUSH
50415: LD_EXP 80
50419: PUSH
50420: LD_VAR 0 5
50424: ARRAY
50425: IN
50426: IFFALSE 50584
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
50428: LD_VAR 0 1
50432: PUSH
50433: LD_INT 11
50435: PUSH
50436: LD_INT 4
50438: PUSH
50439: LD_INT 3
50441: PUSH
50442: LD_INT 2
50444: PUSH
50445: EMPTY
50446: LIST
50447: LIST
50448: LIST
50449: LIST
50450: IN
50451: PUSH
50452: LD_EXP 110
50456: PUSH
50457: LD_VAR 0 5
50461: ARRAY
50462: AND
50463: IFFALSE 50584
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
50465: LD_ADDR_VAR 0 6
50469: PUSH
50470: LD_EXP 110
50474: PUSH
50475: LD_VAR 0 5
50479: ARRAY
50480: PUSH
50481: LD_INT 1
50483: ARRAY
50484: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50485: LD_ADDR_EXP 110
50489: PUSH
50490: LD_EXP 110
50494: PPUSH
50495: LD_VAR 0 5
50499: PPUSH
50500: EMPTY
50501: PPUSH
50502: CALL_OW 1
50506: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
50507: LD_VAR 0 6
50511: PPUSH
50512: LD_INT 0
50514: PPUSH
50515: CALL_OW 109
// ComExitBuilding ( tmp ) ;
50519: LD_VAR 0 6
50523: PPUSH
50524: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
50528: LD_ADDR_EXP 109
50532: PUSH
50533: LD_EXP 109
50537: PPUSH
50538: LD_VAR 0 5
50542: PPUSH
50543: LD_EXP 109
50547: PUSH
50548: LD_VAR 0 5
50552: ARRAY
50553: PPUSH
50554: LD_INT 1
50556: PPUSH
50557: LD_VAR 0 6
50561: PPUSH
50562: CALL_OW 2
50566: PPUSH
50567: CALL_OW 1
50571: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
50572: LD_VAR 0 5
50576: PPUSH
50577: LD_INT 112
50579: PPUSH
50580: CALL 27038 0 2
// end ; end ; end ;
50584: GO 50407
50586: POP
50587: POP
// end ;
50588: LD_VAR 0 3
50592: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
50593: LD_INT 0
50595: PPUSH
50596: PPUSH
50597: PPUSH
50598: PPUSH
50599: PPUSH
50600: PPUSH
50601: PPUSH
50602: PPUSH
// if not mc_bases or not skirmish then
50603: LD_EXP 80
50607: NOT
50608: PUSH
50609: LD_EXP 78
50613: NOT
50614: OR
50615: IFFALSE 50619
// exit ;
50617: GO 51988
// for i = 1 to mc_bases do
50619: LD_ADDR_VAR 0 3
50623: PUSH
50624: DOUBLE
50625: LD_INT 1
50627: DEC
50628: ST_TO_ADDR
50629: LD_EXP 80
50633: PUSH
50634: FOR_TO
50635: IFFALSE 51986
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
50637: LD_VAR 0 1
50641: PUSH
50642: LD_EXP 80
50646: PUSH
50647: LD_VAR 0 3
50651: ARRAY
50652: IN
50653: PUSH
50654: LD_VAR 0 1
50658: PUSH
50659: LD_EXP 87
50663: PUSH
50664: LD_VAR 0 3
50668: ARRAY
50669: IN
50670: OR
50671: PUSH
50672: LD_VAR 0 1
50676: PUSH
50677: LD_EXP 102
50681: PUSH
50682: LD_VAR 0 3
50686: ARRAY
50687: IN
50688: OR
50689: PUSH
50690: LD_VAR 0 1
50694: PUSH
50695: LD_EXP 99
50699: PUSH
50700: LD_VAR 0 3
50704: ARRAY
50705: IN
50706: OR
50707: PUSH
50708: LD_VAR 0 1
50712: PUSH
50713: LD_EXP 109
50717: PUSH
50718: LD_VAR 0 3
50722: ARRAY
50723: IN
50724: OR
50725: PUSH
50726: LD_VAR 0 1
50730: PUSH
50731: LD_EXP 110
50735: PUSH
50736: LD_VAR 0 3
50740: ARRAY
50741: IN
50742: OR
50743: IFFALSE 51984
// begin if un in mc_ape [ i ] then
50745: LD_VAR 0 1
50749: PUSH
50750: LD_EXP 109
50754: PUSH
50755: LD_VAR 0 3
50759: ARRAY
50760: IN
50761: IFFALSE 50800
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50763: LD_ADDR_EXP 109
50767: PUSH
50768: LD_EXP 109
50772: PPUSH
50773: LD_VAR 0 3
50777: PPUSH
50778: LD_EXP 109
50782: PUSH
50783: LD_VAR 0 3
50787: ARRAY
50788: PUSH
50789: LD_VAR 0 1
50793: DIFF
50794: PPUSH
50795: CALL_OW 1
50799: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50800: LD_VAR 0 1
50804: PUSH
50805: LD_EXP 110
50809: PUSH
50810: LD_VAR 0 3
50814: ARRAY
50815: IN
50816: IFFALSE 50840
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50818: LD_ADDR_EXP 110
50822: PUSH
50823: LD_EXP 110
50827: PPUSH
50828: LD_VAR 0 3
50832: PPUSH
50833: EMPTY
50834: PPUSH
50835: CALL_OW 1
50839: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50840: LD_VAR 0 1
50844: PPUSH
50845: CALL_OW 247
50849: PUSH
50850: LD_INT 2
50852: EQUAL
50853: PUSH
50854: LD_VAR 0 1
50858: PPUSH
50859: CALL_OW 110
50863: PUSH
50864: LD_INT 20
50866: EQUAL
50867: PUSH
50868: LD_VAR 0 1
50872: PUSH
50873: LD_EXP 102
50877: PUSH
50878: LD_VAR 0 3
50882: ARRAY
50883: IN
50884: OR
50885: PUSH
50886: LD_VAR 0 1
50890: PPUSH
50891: CALL_OW 264
50895: PUSH
50896: LD_INT 12
50898: PUSH
50899: LD_INT 51
50901: PUSH
50902: LD_INT 89
50904: PUSH
50905: LD_INT 32
50907: PUSH
50908: LD_INT 13
50910: PUSH
50911: LD_INT 52
50913: PUSH
50914: LD_INT 31
50916: PUSH
50917: EMPTY
50918: LIST
50919: LIST
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: IN
50926: OR
50927: AND
50928: IFFALSE 51236
// begin if un in mc_defender [ i ] then
50930: LD_VAR 0 1
50934: PUSH
50935: LD_EXP 102
50939: PUSH
50940: LD_VAR 0 3
50944: ARRAY
50945: IN
50946: IFFALSE 50985
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50948: LD_ADDR_EXP 102
50952: PUSH
50953: LD_EXP 102
50957: PPUSH
50958: LD_VAR 0 3
50962: PPUSH
50963: LD_EXP 102
50967: PUSH
50968: LD_VAR 0 3
50972: ARRAY
50973: PUSH
50974: LD_VAR 0 1
50978: DIFF
50979: PPUSH
50980: CALL_OW 1
50984: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50985: LD_ADDR_VAR 0 8
50989: PUSH
50990: LD_VAR 0 3
50994: PPUSH
50995: LD_INT 3
50997: PPUSH
50998: CALL 47606 0 2
51002: ST_TO_ADDR
// if fac then
51003: LD_VAR 0 8
51007: IFFALSE 51236
// begin for j in fac do
51009: LD_ADDR_VAR 0 4
51013: PUSH
51014: LD_VAR 0 8
51018: PUSH
51019: FOR_IN
51020: IFFALSE 51234
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
51022: LD_ADDR_VAR 0 9
51026: PUSH
51027: LD_VAR 0 8
51031: PPUSH
51032: LD_VAR 0 1
51036: PPUSH
51037: CALL_OW 265
51041: PPUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: CALL_OW 262
51051: PPUSH
51052: LD_VAR 0 1
51056: PPUSH
51057: CALL_OW 263
51061: PPUSH
51062: LD_VAR 0 1
51066: PPUSH
51067: CALL_OW 264
51071: PPUSH
51072: CALL 56058 0 5
51076: ST_TO_ADDR
// if components then
51077: LD_VAR 0 9
51081: IFFALSE 51232
// begin if GetWeapon ( un ) = ar_control_tower then
51083: LD_VAR 0 1
51087: PPUSH
51088: CALL_OW 264
51092: PUSH
51093: LD_INT 31
51095: EQUAL
51096: IFFALSE 51213
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
51098: LD_VAR 0 1
51102: PPUSH
51103: CALL_OW 311
51107: PPUSH
51108: LD_INT 0
51110: PPUSH
51111: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
51115: LD_ADDR_EXP 120
51119: PUSH
51120: LD_EXP 120
51124: PPUSH
51125: LD_VAR 0 3
51129: PPUSH
51130: LD_EXP 120
51134: PUSH
51135: LD_VAR 0 3
51139: ARRAY
51140: PUSH
51141: LD_VAR 0 1
51145: PPUSH
51146: CALL_OW 311
51150: DIFF
51151: PPUSH
51152: CALL_OW 1
51156: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
51157: LD_ADDR_VAR 0 7
51161: PUSH
51162: LD_EXP 101
51166: PUSH
51167: LD_VAR 0 3
51171: ARRAY
51172: PPUSH
51173: LD_INT 1
51175: PPUSH
51176: LD_VAR 0 9
51180: PPUSH
51181: CALL_OW 2
51185: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
51186: LD_ADDR_EXP 101
51190: PUSH
51191: LD_EXP 101
51195: PPUSH
51196: LD_VAR 0 3
51200: PPUSH
51201: LD_VAR 0 7
51205: PPUSH
51206: CALL_OW 1
51210: ST_TO_ADDR
// end else
51211: GO 51230
// MC_InsertProduceList ( i , [ components ] ) ;
51213: LD_VAR 0 3
51217: PPUSH
51218: LD_VAR 0 9
51222: PUSH
51223: EMPTY
51224: LIST
51225: PPUSH
51226: CALL 47151 0 2
// break ;
51230: GO 51234
// end ; end ;
51232: GO 51019
51234: POP
51235: POP
// end ; end ; if GetType ( un ) = unit_building then
51236: LD_VAR 0 1
51240: PPUSH
51241: CALL_OW 247
51245: PUSH
51246: LD_INT 3
51248: EQUAL
51249: IFFALSE 51652
// begin btype := GetBType ( un ) ;
51251: LD_ADDR_VAR 0 5
51255: PUSH
51256: LD_VAR 0 1
51260: PPUSH
51261: CALL_OW 266
51265: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
51266: LD_VAR 0 5
51270: PUSH
51271: LD_INT 29
51273: PUSH
51274: LD_INT 30
51276: PUSH
51277: EMPTY
51278: LIST
51279: LIST
51280: IN
51281: IFFALSE 51354
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
51283: LD_VAR 0 1
51287: PPUSH
51288: CALL_OW 250
51292: PPUSH
51293: LD_VAR 0 1
51297: PPUSH
51298: CALL_OW 251
51302: PPUSH
51303: LD_VAR 0 1
51307: PPUSH
51308: CALL_OW 255
51312: PPUSH
51313: CALL_OW 440
51317: NOT
51318: IFFALSE 51354
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
51320: LD_VAR 0 1
51324: PPUSH
51325: CALL_OW 250
51329: PPUSH
51330: LD_VAR 0 1
51334: PPUSH
51335: CALL_OW 251
51339: PPUSH
51340: LD_VAR 0 1
51344: PPUSH
51345: CALL_OW 255
51349: PPUSH
51350: CALL_OW 441
// end ; if btype = b_warehouse then
51354: LD_VAR 0 5
51358: PUSH
51359: LD_INT 1
51361: EQUAL
51362: IFFALSE 51380
// begin btype := b_depot ;
51364: LD_ADDR_VAR 0 5
51368: PUSH
51369: LD_INT 0
51371: ST_TO_ADDR
// pos := 1 ;
51372: LD_ADDR_VAR 0 6
51376: PUSH
51377: LD_INT 1
51379: ST_TO_ADDR
// end ; if btype = b_factory then
51380: LD_VAR 0 5
51384: PUSH
51385: LD_INT 3
51387: EQUAL
51388: IFFALSE 51406
// begin btype := b_workshop ;
51390: LD_ADDR_VAR 0 5
51394: PUSH
51395: LD_INT 2
51397: ST_TO_ADDR
// pos := 1 ;
51398: LD_ADDR_VAR 0 6
51402: PUSH
51403: LD_INT 1
51405: ST_TO_ADDR
// end ; if btype = b_barracks then
51406: LD_VAR 0 5
51410: PUSH
51411: LD_INT 5
51413: EQUAL
51414: IFFALSE 51424
// btype := b_armoury ;
51416: LD_ADDR_VAR 0 5
51420: PUSH
51421: LD_INT 4
51423: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
51424: LD_VAR 0 5
51428: PUSH
51429: LD_INT 7
51431: PUSH
51432: LD_INT 8
51434: PUSH
51435: EMPTY
51436: LIST
51437: LIST
51438: IN
51439: IFFALSE 51449
// btype := b_lab ;
51441: LD_ADDR_VAR 0 5
51445: PUSH
51446: LD_INT 6
51448: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
51449: LD_ADDR_EXP 85
51453: PUSH
51454: LD_EXP 85
51458: PPUSH
51459: LD_VAR 0 3
51463: PUSH
51464: LD_EXP 85
51468: PUSH
51469: LD_VAR 0 3
51473: ARRAY
51474: PUSH
51475: LD_INT 1
51477: PLUS
51478: PUSH
51479: EMPTY
51480: LIST
51481: LIST
51482: PPUSH
51483: LD_VAR 0 5
51487: PUSH
51488: LD_VAR 0 1
51492: PPUSH
51493: CALL_OW 250
51497: PUSH
51498: LD_VAR 0 1
51502: PPUSH
51503: CALL_OW 251
51507: PUSH
51508: LD_VAR 0 1
51512: PPUSH
51513: CALL_OW 254
51517: PUSH
51518: EMPTY
51519: LIST
51520: LIST
51521: LIST
51522: LIST
51523: PPUSH
51524: CALL 58560 0 3
51528: ST_TO_ADDR
// if pos = 1 then
51529: LD_VAR 0 6
51533: PUSH
51534: LD_INT 1
51536: EQUAL
51537: IFFALSE 51652
// begin tmp := mc_build_list [ i ] ;
51539: LD_ADDR_VAR 0 7
51543: PUSH
51544: LD_EXP 85
51548: PUSH
51549: LD_VAR 0 3
51553: ARRAY
51554: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51555: LD_VAR 0 7
51559: PPUSH
51560: LD_INT 2
51562: PUSH
51563: LD_INT 30
51565: PUSH
51566: LD_INT 0
51568: PUSH
51569: EMPTY
51570: LIST
51571: LIST
51572: PUSH
51573: LD_INT 30
51575: PUSH
51576: LD_INT 1
51578: PUSH
51579: EMPTY
51580: LIST
51581: LIST
51582: PUSH
51583: EMPTY
51584: LIST
51585: LIST
51586: LIST
51587: PPUSH
51588: CALL_OW 72
51592: IFFALSE 51602
// pos := 2 ;
51594: LD_ADDR_VAR 0 6
51598: PUSH
51599: LD_INT 2
51601: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
51602: LD_ADDR_VAR 0 7
51606: PUSH
51607: LD_VAR 0 7
51611: PPUSH
51612: LD_VAR 0 6
51616: PPUSH
51617: LD_VAR 0 7
51621: PPUSH
51622: CALL 58886 0 3
51626: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
51627: LD_ADDR_EXP 85
51631: PUSH
51632: LD_EXP 85
51636: PPUSH
51637: LD_VAR 0 3
51641: PPUSH
51642: LD_VAR 0 7
51646: PPUSH
51647: CALL_OW 1
51651: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
51652: LD_VAR 0 1
51656: PUSH
51657: LD_EXP 80
51661: PUSH
51662: LD_VAR 0 3
51666: ARRAY
51667: IN
51668: IFFALSE 51707
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
51670: LD_ADDR_EXP 80
51674: PUSH
51675: LD_EXP 80
51679: PPUSH
51680: LD_VAR 0 3
51684: PPUSH
51685: LD_EXP 80
51689: PUSH
51690: LD_VAR 0 3
51694: ARRAY
51695: PUSH
51696: LD_VAR 0 1
51700: DIFF
51701: PPUSH
51702: CALL_OW 1
51706: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
51707: LD_VAR 0 1
51711: PUSH
51712: LD_EXP 87
51716: PUSH
51717: LD_VAR 0 3
51721: ARRAY
51722: IN
51723: IFFALSE 51762
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51725: LD_ADDR_EXP 87
51729: PUSH
51730: LD_EXP 87
51734: PPUSH
51735: LD_VAR 0 3
51739: PPUSH
51740: LD_EXP 87
51744: PUSH
51745: LD_VAR 0 3
51749: ARRAY
51750: PUSH
51751: LD_VAR 0 1
51755: DIFF
51756: PPUSH
51757: CALL_OW 1
51761: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51762: LD_VAR 0 1
51766: PUSH
51767: LD_EXP 99
51771: PUSH
51772: LD_VAR 0 3
51776: ARRAY
51777: IN
51778: IFFALSE 51817
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51780: LD_ADDR_EXP 99
51784: PUSH
51785: LD_EXP 99
51789: PPUSH
51790: LD_VAR 0 3
51794: PPUSH
51795: LD_EXP 99
51799: PUSH
51800: LD_VAR 0 3
51804: ARRAY
51805: PUSH
51806: LD_VAR 0 1
51810: DIFF
51811: PPUSH
51812: CALL_OW 1
51816: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51817: LD_VAR 0 1
51821: PUSH
51822: LD_EXP 102
51826: PUSH
51827: LD_VAR 0 3
51831: ARRAY
51832: IN
51833: IFFALSE 51872
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51835: LD_ADDR_EXP 102
51839: PUSH
51840: LD_EXP 102
51844: PPUSH
51845: LD_VAR 0 3
51849: PPUSH
51850: LD_EXP 102
51854: PUSH
51855: LD_VAR 0 3
51859: ARRAY
51860: PUSH
51861: LD_VAR 0 1
51865: DIFF
51866: PPUSH
51867: CALL_OW 1
51871: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51872: LD_VAR 0 1
51876: PUSH
51877: LD_EXP 89
51881: PUSH
51882: LD_VAR 0 3
51886: ARRAY
51887: IN
51888: IFFALSE 51927
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51890: LD_ADDR_EXP 89
51894: PUSH
51895: LD_EXP 89
51899: PPUSH
51900: LD_VAR 0 3
51904: PPUSH
51905: LD_EXP 89
51909: PUSH
51910: LD_VAR 0 3
51914: ARRAY
51915: PUSH
51916: LD_VAR 0 1
51920: DIFF
51921: PPUSH
51922: CALL_OW 1
51926: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51927: LD_VAR 0 1
51931: PUSH
51932: LD_EXP 88
51936: PUSH
51937: LD_VAR 0 3
51941: ARRAY
51942: IN
51943: IFFALSE 51982
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51945: LD_ADDR_EXP 88
51949: PUSH
51950: LD_EXP 88
51954: PPUSH
51955: LD_VAR 0 3
51959: PPUSH
51960: LD_EXP 88
51964: PUSH
51965: LD_VAR 0 3
51969: ARRAY
51970: PUSH
51971: LD_VAR 0 1
51975: DIFF
51976: PPUSH
51977: CALL_OW 1
51981: ST_TO_ADDR
// end ; break ;
51982: GO 51986
// end ;
51984: GO 50634
51986: POP
51987: POP
// end ;
51988: LD_VAR 0 2
51992: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51993: LD_INT 0
51995: PPUSH
51996: PPUSH
51997: PPUSH
// if not mc_bases or not skirmish then
51998: LD_EXP 80
52002: NOT
52003: PUSH
52004: LD_EXP 78
52008: NOT
52009: OR
52010: IFFALSE 52014
// exit ;
52012: GO 52229
// for i = 1 to mc_bases do
52014: LD_ADDR_VAR 0 3
52018: PUSH
52019: DOUBLE
52020: LD_INT 1
52022: DEC
52023: ST_TO_ADDR
52024: LD_EXP 80
52028: PUSH
52029: FOR_TO
52030: IFFALSE 52227
// begin if building in mc_construct_list [ i ] then
52032: LD_VAR 0 1
52036: PUSH
52037: LD_EXP 87
52041: PUSH
52042: LD_VAR 0 3
52046: ARRAY
52047: IN
52048: IFFALSE 52225
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52050: LD_ADDR_EXP 87
52054: PUSH
52055: LD_EXP 87
52059: PPUSH
52060: LD_VAR 0 3
52064: PPUSH
52065: LD_EXP 87
52069: PUSH
52070: LD_VAR 0 3
52074: ARRAY
52075: PUSH
52076: LD_VAR 0 1
52080: DIFF
52081: PPUSH
52082: CALL_OW 1
52086: ST_TO_ADDR
// if building in mc_lab [ i ] then
52087: LD_VAR 0 1
52091: PUSH
52092: LD_EXP 113
52096: PUSH
52097: LD_VAR 0 3
52101: ARRAY
52102: IN
52103: IFFALSE 52158
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
52105: LD_ADDR_EXP 114
52109: PUSH
52110: LD_EXP 114
52114: PPUSH
52115: LD_VAR 0 3
52119: PPUSH
52120: LD_EXP 114
52124: PUSH
52125: LD_VAR 0 3
52129: ARRAY
52130: PPUSH
52131: LD_INT 1
52133: PPUSH
52134: LD_EXP 114
52138: PUSH
52139: LD_VAR 0 3
52143: ARRAY
52144: PPUSH
52145: LD_INT 0
52147: PPUSH
52148: CALL 57978 0 4
52152: PPUSH
52153: CALL_OW 1
52157: ST_TO_ADDR
// if not building in mc_bases [ i ] then
52158: LD_VAR 0 1
52162: PUSH
52163: LD_EXP 80
52167: PUSH
52168: LD_VAR 0 3
52172: ARRAY
52173: IN
52174: NOT
52175: IFFALSE 52221
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52177: LD_ADDR_EXP 80
52181: PUSH
52182: LD_EXP 80
52186: PPUSH
52187: LD_VAR 0 3
52191: PUSH
52192: LD_EXP 80
52196: PUSH
52197: LD_VAR 0 3
52201: ARRAY
52202: PUSH
52203: LD_INT 1
52205: PLUS
52206: PUSH
52207: EMPTY
52208: LIST
52209: LIST
52210: PPUSH
52211: LD_VAR 0 1
52215: PPUSH
52216: CALL 58560 0 3
52220: ST_TO_ADDR
// exit ;
52221: POP
52222: POP
52223: GO 52229
// end ; end ;
52225: GO 52029
52227: POP
52228: POP
// end ;
52229: LD_VAR 0 2
52233: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
52234: LD_INT 0
52236: PPUSH
52237: PPUSH
52238: PPUSH
52239: PPUSH
52240: PPUSH
52241: PPUSH
52242: PPUSH
// if not mc_bases or not skirmish then
52243: LD_EXP 80
52247: NOT
52248: PUSH
52249: LD_EXP 78
52253: NOT
52254: OR
52255: IFFALSE 52259
// exit ;
52257: GO 52920
// for i = 1 to mc_bases do
52259: LD_ADDR_VAR 0 3
52263: PUSH
52264: DOUBLE
52265: LD_INT 1
52267: DEC
52268: ST_TO_ADDR
52269: LD_EXP 80
52273: PUSH
52274: FOR_TO
52275: IFFALSE 52918
// begin if building in mc_construct_list [ i ] then
52277: LD_VAR 0 1
52281: PUSH
52282: LD_EXP 87
52286: PUSH
52287: LD_VAR 0 3
52291: ARRAY
52292: IN
52293: IFFALSE 52916
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52295: LD_ADDR_EXP 87
52299: PUSH
52300: LD_EXP 87
52304: PPUSH
52305: LD_VAR 0 3
52309: PPUSH
52310: LD_EXP 87
52314: PUSH
52315: LD_VAR 0 3
52319: ARRAY
52320: PUSH
52321: LD_VAR 0 1
52325: DIFF
52326: PPUSH
52327: CALL_OW 1
52331: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52332: LD_ADDR_EXP 80
52336: PUSH
52337: LD_EXP 80
52341: PPUSH
52342: LD_VAR 0 3
52346: PUSH
52347: LD_EXP 80
52351: PUSH
52352: LD_VAR 0 3
52356: ARRAY
52357: PUSH
52358: LD_INT 1
52360: PLUS
52361: PUSH
52362: EMPTY
52363: LIST
52364: LIST
52365: PPUSH
52366: LD_VAR 0 1
52370: PPUSH
52371: CALL 58560 0 3
52375: ST_TO_ADDR
// btype := GetBType ( building ) ;
52376: LD_ADDR_VAR 0 5
52380: PUSH
52381: LD_VAR 0 1
52385: PPUSH
52386: CALL_OW 266
52390: ST_TO_ADDR
// side := GetSide ( building ) ;
52391: LD_ADDR_VAR 0 8
52395: PUSH
52396: LD_VAR 0 1
52400: PPUSH
52401: CALL_OW 255
52405: ST_TO_ADDR
// if btype = b_lab then
52406: LD_VAR 0 5
52410: PUSH
52411: LD_INT 6
52413: EQUAL
52414: IFFALSE 52464
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
52416: LD_ADDR_EXP 113
52420: PUSH
52421: LD_EXP 113
52425: PPUSH
52426: LD_VAR 0 3
52430: PUSH
52431: LD_EXP 113
52435: PUSH
52436: LD_VAR 0 3
52440: ARRAY
52441: PUSH
52442: LD_INT 1
52444: PLUS
52445: PUSH
52446: EMPTY
52447: LIST
52448: LIST
52449: PPUSH
52450: LD_VAR 0 1
52454: PPUSH
52455: CALL 58560 0 3
52459: ST_TO_ADDR
// exit ;
52460: POP
52461: POP
52462: GO 52920
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
52464: LD_VAR 0 5
52468: PUSH
52469: LD_INT 0
52471: PUSH
52472: LD_INT 2
52474: PUSH
52475: LD_INT 4
52477: PUSH
52478: EMPTY
52479: LIST
52480: LIST
52481: LIST
52482: IN
52483: IFFALSE 52607
// begin if btype = b_armoury then
52485: LD_VAR 0 5
52489: PUSH
52490: LD_INT 4
52492: EQUAL
52493: IFFALSE 52503
// btype := b_barracks ;
52495: LD_ADDR_VAR 0 5
52499: PUSH
52500: LD_INT 5
52502: ST_TO_ADDR
// if btype = b_depot then
52503: LD_VAR 0 5
52507: PUSH
52508: LD_INT 0
52510: EQUAL
52511: IFFALSE 52521
// btype := b_warehouse ;
52513: LD_ADDR_VAR 0 5
52517: PUSH
52518: LD_INT 1
52520: ST_TO_ADDR
// if btype = b_workshop then
52521: LD_VAR 0 5
52525: PUSH
52526: LD_INT 2
52528: EQUAL
52529: IFFALSE 52539
// btype := b_factory ;
52531: LD_ADDR_VAR 0 5
52535: PUSH
52536: LD_INT 3
52538: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
52539: LD_VAR 0 5
52543: PPUSH
52544: LD_VAR 0 8
52548: PPUSH
52549: CALL_OW 323
52553: PUSH
52554: LD_INT 1
52556: EQUAL
52557: IFFALSE 52603
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
52559: LD_ADDR_EXP 112
52563: PUSH
52564: LD_EXP 112
52568: PPUSH
52569: LD_VAR 0 3
52573: PUSH
52574: LD_EXP 112
52578: PUSH
52579: LD_VAR 0 3
52583: ARRAY
52584: PUSH
52585: LD_INT 1
52587: PLUS
52588: PUSH
52589: EMPTY
52590: LIST
52591: LIST
52592: PPUSH
52593: LD_VAR 0 1
52597: PPUSH
52598: CALL 58560 0 3
52602: ST_TO_ADDR
// exit ;
52603: POP
52604: POP
52605: GO 52920
// end ; if btype in [ b_bunker , b_turret ] then
52607: LD_VAR 0 5
52611: PUSH
52612: LD_INT 32
52614: PUSH
52615: LD_INT 33
52617: PUSH
52618: EMPTY
52619: LIST
52620: LIST
52621: IN
52622: IFFALSE 52912
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
52624: LD_ADDR_EXP 88
52628: PUSH
52629: LD_EXP 88
52633: PPUSH
52634: LD_VAR 0 3
52638: PUSH
52639: LD_EXP 88
52643: PUSH
52644: LD_VAR 0 3
52648: ARRAY
52649: PUSH
52650: LD_INT 1
52652: PLUS
52653: PUSH
52654: EMPTY
52655: LIST
52656: LIST
52657: PPUSH
52658: LD_VAR 0 1
52662: PPUSH
52663: CALL 58560 0 3
52667: ST_TO_ADDR
// if btype = b_bunker then
52668: LD_VAR 0 5
52672: PUSH
52673: LD_INT 32
52675: EQUAL
52676: IFFALSE 52912
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52678: LD_ADDR_EXP 89
52682: PUSH
52683: LD_EXP 89
52687: PPUSH
52688: LD_VAR 0 3
52692: PUSH
52693: LD_EXP 89
52697: PUSH
52698: LD_VAR 0 3
52702: ARRAY
52703: PUSH
52704: LD_INT 1
52706: PLUS
52707: PUSH
52708: EMPTY
52709: LIST
52710: LIST
52711: PPUSH
52712: LD_VAR 0 1
52716: PPUSH
52717: CALL 58560 0 3
52721: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52722: LD_ADDR_VAR 0 6
52726: PUSH
52727: LD_EXP 80
52731: PUSH
52732: LD_VAR 0 3
52736: ARRAY
52737: PPUSH
52738: LD_INT 25
52740: PUSH
52741: LD_INT 1
52743: PUSH
52744: EMPTY
52745: LIST
52746: LIST
52747: PUSH
52748: LD_INT 3
52750: PUSH
52751: LD_INT 54
52753: PUSH
52754: EMPTY
52755: LIST
52756: PUSH
52757: EMPTY
52758: LIST
52759: LIST
52760: PUSH
52761: EMPTY
52762: LIST
52763: LIST
52764: PPUSH
52765: CALL_OW 72
52769: ST_TO_ADDR
// if tmp then
52770: LD_VAR 0 6
52774: IFFALSE 52780
// exit ;
52776: POP
52777: POP
52778: GO 52920
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52780: LD_ADDR_VAR 0 6
52784: PUSH
52785: LD_EXP 80
52789: PUSH
52790: LD_VAR 0 3
52794: ARRAY
52795: PPUSH
52796: LD_INT 2
52798: PUSH
52799: LD_INT 30
52801: PUSH
52802: LD_INT 4
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PUSH
52809: LD_INT 30
52811: PUSH
52812: LD_INT 5
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: LIST
52823: PPUSH
52824: CALL_OW 72
52828: ST_TO_ADDR
// if not tmp then
52829: LD_VAR 0 6
52833: NOT
52834: IFFALSE 52840
// exit ;
52836: POP
52837: POP
52838: GO 52920
// for j in tmp do
52840: LD_ADDR_VAR 0 4
52844: PUSH
52845: LD_VAR 0 6
52849: PUSH
52850: FOR_IN
52851: IFFALSE 52910
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52853: LD_ADDR_VAR 0 7
52857: PUSH
52858: LD_VAR 0 4
52862: PPUSH
52863: CALL_OW 313
52867: PPUSH
52868: LD_INT 25
52870: PUSH
52871: LD_INT 1
52873: PUSH
52874: EMPTY
52875: LIST
52876: LIST
52877: PPUSH
52878: CALL_OW 72
52882: ST_TO_ADDR
// if units then
52883: LD_VAR 0 7
52887: IFFALSE 52908
// begin ComExitBuilding ( units [ 1 ] ) ;
52889: LD_VAR 0 7
52893: PUSH
52894: LD_INT 1
52896: ARRAY
52897: PPUSH
52898: CALL_OW 122
// exit ;
52902: POP
52903: POP
52904: POP
52905: POP
52906: GO 52920
// end ; end ;
52908: GO 52850
52910: POP
52911: POP
// end ; end ; exit ;
52912: POP
52913: POP
52914: GO 52920
// end ; end ;
52916: GO 52274
52918: POP
52919: POP
// end ;
52920: LD_VAR 0 2
52924: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52925: LD_INT 0
52927: PPUSH
52928: PPUSH
52929: PPUSH
52930: PPUSH
52931: PPUSH
52932: PPUSH
52933: PPUSH
// if not mc_bases or not skirmish then
52934: LD_EXP 80
52938: NOT
52939: PUSH
52940: LD_EXP 78
52944: NOT
52945: OR
52946: IFFALSE 52950
// exit ;
52948: GO 53215
// btype := GetBType ( building ) ;
52950: LD_ADDR_VAR 0 6
52954: PUSH
52955: LD_VAR 0 1
52959: PPUSH
52960: CALL_OW 266
52964: ST_TO_ADDR
// x := GetX ( building ) ;
52965: LD_ADDR_VAR 0 7
52969: PUSH
52970: LD_VAR 0 1
52974: PPUSH
52975: CALL_OW 250
52979: ST_TO_ADDR
// y := GetY ( building ) ;
52980: LD_ADDR_VAR 0 8
52984: PUSH
52985: LD_VAR 0 1
52989: PPUSH
52990: CALL_OW 251
52994: ST_TO_ADDR
// d := GetDir ( building ) ;
52995: LD_ADDR_VAR 0 9
52999: PUSH
53000: LD_VAR 0 1
53004: PPUSH
53005: CALL_OW 254
53009: ST_TO_ADDR
// for i = 1 to mc_bases do
53010: LD_ADDR_VAR 0 4
53014: PUSH
53015: DOUBLE
53016: LD_INT 1
53018: DEC
53019: ST_TO_ADDR
53020: LD_EXP 80
53024: PUSH
53025: FOR_TO
53026: IFFALSE 53213
// begin if not mc_build_list [ i ] then
53028: LD_EXP 85
53032: PUSH
53033: LD_VAR 0 4
53037: ARRAY
53038: NOT
53039: IFFALSE 53043
// continue ;
53041: GO 53025
// for j := 1 to mc_build_list [ i ] do
53043: LD_ADDR_VAR 0 5
53047: PUSH
53048: DOUBLE
53049: LD_INT 1
53051: DEC
53052: ST_TO_ADDR
53053: LD_EXP 85
53057: PUSH
53058: LD_VAR 0 4
53062: ARRAY
53063: PUSH
53064: FOR_TO
53065: IFFALSE 53209
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
53067: LD_VAR 0 6
53071: PUSH
53072: LD_VAR 0 7
53076: PUSH
53077: LD_VAR 0 8
53081: PUSH
53082: LD_VAR 0 9
53086: PUSH
53087: EMPTY
53088: LIST
53089: LIST
53090: LIST
53091: LIST
53092: PPUSH
53093: LD_EXP 85
53097: PUSH
53098: LD_VAR 0 4
53102: ARRAY
53103: PUSH
53104: LD_VAR 0 5
53108: ARRAY
53109: PPUSH
53110: CALL 65117 0 2
53114: IFFALSE 53207
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
53116: LD_ADDR_EXP 85
53120: PUSH
53121: LD_EXP 85
53125: PPUSH
53126: LD_VAR 0 4
53130: PPUSH
53131: LD_EXP 85
53135: PUSH
53136: LD_VAR 0 4
53140: ARRAY
53141: PPUSH
53142: LD_VAR 0 5
53146: PPUSH
53147: CALL_OW 3
53151: PPUSH
53152: CALL_OW 1
53156: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
53157: LD_ADDR_EXP 87
53161: PUSH
53162: LD_EXP 87
53166: PPUSH
53167: LD_VAR 0 4
53171: PUSH
53172: LD_EXP 87
53176: PUSH
53177: LD_VAR 0 4
53181: ARRAY
53182: PUSH
53183: LD_INT 1
53185: PLUS
53186: PUSH
53187: EMPTY
53188: LIST
53189: LIST
53190: PPUSH
53191: LD_VAR 0 1
53195: PPUSH
53196: CALL 58560 0 3
53200: ST_TO_ADDR
// exit ;
53201: POP
53202: POP
53203: POP
53204: POP
53205: GO 53215
// end ;
53207: GO 53064
53209: POP
53210: POP
// end ;
53211: GO 53025
53213: POP
53214: POP
// end ;
53215: LD_VAR 0 3
53219: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
53220: LD_INT 0
53222: PPUSH
53223: PPUSH
53224: PPUSH
// if not mc_bases or not skirmish then
53225: LD_EXP 80
53229: NOT
53230: PUSH
53231: LD_EXP 78
53235: NOT
53236: OR
53237: IFFALSE 53241
// exit ;
53239: GO 53431
// for i = 1 to mc_bases do
53241: LD_ADDR_VAR 0 4
53245: PUSH
53246: DOUBLE
53247: LD_INT 1
53249: DEC
53250: ST_TO_ADDR
53251: LD_EXP 80
53255: PUSH
53256: FOR_TO
53257: IFFALSE 53344
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
53259: LD_VAR 0 1
53263: PUSH
53264: LD_EXP 88
53268: PUSH
53269: LD_VAR 0 4
53273: ARRAY
53274: IN
53275: PUSH
53276: LD_VAR 0 1
53280: PUSH
53281: LD_EXP 89
53285: PUSH
53286: LD_VAR 0 4
53290: ARRAY
53291: IN
53292: NOT
53293: AND
53294: IFFALSE 53342
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
53296: LD_ADDR_EXP 89
53300: PUSH
53301: LD_EXP 89
53305: PPUSH
53306: LD_VAR 0 4
53310: PUSH
53311: LD_EXP 89
53315: PUSH
53316: LD_VAR 0 4
53320: ARRAY
53321: PUSH
53322: LD_INT 1
53324: PLUS
53325: PUSH
53326: EMPTY
53327: LIST
53328: LIST
53329: PPUSH
53330: LD_VAR 0 1
53334: PPUSH
53335: CALL 58560 0 3
53339: ST_TO_ADDR
// break ;
53340: GO 53344
// end ; end ;
53342: GO 53256
53344: POP
53345: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
53346: LD_VAR 0 1
53350: PPUSH
53351: CALL_OW 257
53355: PUSH
53356: LD_EXP 106
53360: IN
53361: PUSH
53362: LD_VAR 0 1
53366: PPUSH
53367: CALL_OW 266
53371: PUSH
53372: LD_INT 5
53374: EQUAL
53375: AND
53376: PUSH
53377: LD_VAR 0 2
53381: PPUSH
53382: CALL_OW 110
53386: PUSH
53387: LD_INT 18
53389: NONEQUAL
53390: AND
53391: IFFALSE 53431
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
53393: LD_VAR 0 2
53397: PPUSH
53398: CALL_OW 257
53402: PUSH
53403: LD_INT 5
53405: PUSH
53406: LD_INT 8
53408: PUSH
53409: LD_INT 9
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: LIST
53416: IN
53417: IFFALSE 53431
// SetClass ( unit , 1 ) ;
53419: LD_VAR 0 2
53423: PPUSH
53424: LD_INT 1
53426: PPUSH
53427: CALL_OW 336
// end ;
53431: LD_VAR 0 3
53435: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
53436: LD_INT 0
53438: PPUSH
53439: PPUSH
// if not mc_bases or not skirmish then
53440: LD_EXP 80
53444: NOT
53445: PUSH
53446: LD_EXP 78
53450: NOT
53451: OR
53452: IFFALSE 53456
// exit ;
53454: GO 53572
// if GetLives ( abandoned_vehicle ) > 250 then
53456: LD_VAR 0 2
53460: PPUSH
53461: CALL_OW 256
53465: PUSH
53466: LD_INT 250
53468: GREATER
53469: IFFALSE 53473
// exit ;
53471: GO 53572
// for i = 1 to mc_bases do
53473: LD_ADDR_VAR 0 6
53477: PUSH
53478: DOUBLE
53479: LD_INT 1
53481: DEC
53482: ST_TO_ADDR
53483: LD_EXP 80
53487: PUSH
53488: FOR_TO
53489: IFFALSE 53570
// begin if driver in mc_bases [ i ] then
53491: LD_VAR 0 1
53495: PUSH
53496: LD_EXP 80
53500: PUSH
53501: LD_VAR 0 6
53505: ARRAY
53506: IN
53507: IFFALSE 53568
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
53509: LD_VAR 0 1
53513: PPUSH
53514: LD_EXP 80
53518: PUSH
53519: LD_VAR 0 6
53523: ARRAY
53524: PPUSH
53525: LD_INT 2
53527: PUSH
53528: LD_INT 30
53530: PUSH
53531: LD_INT 0
53533: PUSH
53534: EMPTY
53535: LIST
53536: LIST
53537: PUSH
53538: LD_INT 30
53540: PUSH
53541: LD_INT 1
53543: PUSH
53544: EMPTY
53545: LIST
53546: LIST
53547: PUSH
53548: EMPTY
53549: LIST
53550: LIST
53551: LIST
53552: PPUSH
53553: CALL_OW 72
53557: PUSH
53558: LD_INT 1
53560: ARRAY
53561: PPUSH
53562: CALL 92186 0 2
// break ;
53566: GO 53570
// end ; end ;
53568: GO 53488
53570: POP
53571: POP
// end ; end_of_file
53572: LD_VAR 0 5
53576: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
53577: LD_INT 0
53579: PPUSH
53580: PPUSH
// if exist_mode then
53581: LD_VAR 0 2
53585: IFFALSE 53631
// begin unit := CreateCharacter ( prefix & ident ) ;
53587: LD_ADDR_VAR 0 5
53591: PUSH
53592: LD_VAR 0 3
53596: PUSH
53597: LD_VAR 0 1
53601: STR
53602: PPUSH
53603: CALL_OW 34
53607: ST_TO_ADDR
// if unit then
53608: LD_VAR 0 5
53612: IFFALSE 53629
// DeleteCharacters ( prefix & ident ) ;
53614: LD_VAR 0 3
53618: PUSH
53619: LD_VAR 0 1
53623: STR
53624: PPUSH
53625: CALL_OW 40
// end else
53629: GO 53646
// unit := NewCharacter ( ident ) ;
53631: LD_ADDR_VAR 0 5
53635: PUSH
53636: LD_VAR 0 1
53640: PPUSH
53641: CALL_OW 25
53645: ST_TO_ADDR
// result := unit ;
53646: LD_ADDR_VAR 0 4
53650: PUSH
53651: LD_VAR 0 5
53655: ST_TO_ADDR
// end ;
53656: LD_VAR 0 4
53660: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
53661: LD_INT 0
53663: PPUSH
53664: PPUSH
// if not side or not nation then
53665: LD_VAR 0 1
53669: NOT
53670: PUSH
53671: LD_VAR 0 2
53675: NOT
53676: OR
53677: IFFALSE 53681
// exit ;
53679: GO 54449
// case nation of nation_american :
53681: LD_VAR 0 2
53685: PUSH
53686: LD_INT 1
53688: DOUBLE
53689: EQUAL
53690: IFTRUE 53694
53692: GO 53908
53694: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
53695: LD_ADDR_VAR 0 4
53699: PUSH
53700: LD_INT 35
53702: PUSH
53703: LD_INT 45
53705: PUSH
53706: LD_INT 46
53708: PUSH
53709: LD_INT 47
53711: PUSH
53712: LD_INT 82
53714: PUSH
53715: LD_INT 83
53717: PUSH
53718: LD_INT 84
53720: PUSH
53721: LD_INT 85
53723: PUSH
53724: LD_INT 86
53726: PUSH
53727: LD_INT 1
53729: PUSH
53730: LD_INT 2
53732: PUSH
53733: LD_INT 6
53735: PUSH
53736: LD_INT 15
53738: PUSH
53739: LD_INT 16
53741: PUSH
53742: LD_INT 7
53744: PUSH
53745: LD_INT 12
53747: PUSH
53748: LD_INT 13
53750: PUSH
53751: LD_INT 10
53753: PUSH
53754: LD_INT 14
53756: PUSH
53757: LD_INT 20
53759: PUSH
53760: LD_INT 21
53762: PUSH
53763: LD_INT 22
53765: PUSH
53766: LD_INT 25
53768: PUSH
53769: LD_INT 32
53771: PUSH
53772: LD_INT 27
53774: PUSH
53775: LD_INT 36
53777: PUSH
53778: LD_INT 69
53780: PUSH
53781: LD_INT 39
53783: PUSH
53784: LD_INT 34
53786: PUSH
53787: LD_INT 40
53789: PUSH
53790: LD_INT 48
53792: PUSH
53793: LD_INT 49
53795: PUSH
53796: LD_INT 50
53798: PUSH
53799: LD_INT 51
53801: PUSH
53802: LD_INT 52
53804: PUSH
53805: LD_INT 53
53807: PUSH
53808: LD_INT 54
53810: PUSH
53811: LD_INT 55
53813: PUSH
53814: LD_INT 56
53816: PUSH
53817: LD_INT 57
53819: PUSH
53820: LD_INT 58
53822: PUSH
53823: LD_INT 59
53825: PUSH
53826: LD_INT 60
53828: PUSH
53829: LD_INT 61
53831: PUSH
53832: LD_INT 62
53834: PUSH
53835: LD_INT 80
53837: PUSH
53838: LD_INT 82
53840: PUSH
53841: LD_INT 83
53843: PUSH
53844: LD_INT 84
53846: PUSH
53847: LD_INT 85
53849: PUSH
53850: LD_INT 86
53852: PUSH
53853: EMPTY
53854: LIST
53855: LIST
53856: LIST
53857: LIST
53858: LIST
53859: LIST
53860: LIST
53861: LIST
53862: LIST
53863: LIST
53864: LIST
53865: LIST
53866: LIST
53867: LIST
53868: LIST
53869: LIST
53870: LIST
53871: LIST
53872: LIST
53873: LIST
53874: LIST
53875: LIST
53876: LIST
53877: LIST
53878: LIST
53879: LIST
53880: LIST
53881: LIST
53882: LIST
53883: LIST
53884: LIST
53885: LIST
53886: LIST
53887: LIST
53888: LIST
53889: LIST
53890: LIST
53891: LIST
53892: LIST
53893: LIST
53894: LIST
53895: LIST
53896: LIST
53897: LIST
53898: LIST
53899: LIST
53900: LIST
53901: LIST
53902: LIST
53903: LIST
53904: LIST
53905: ST_TO_ADDR
53906: GO 54373
53908: LD_INT 2
53910: DOUBLE
53911: EQUAL
53912: IFTRUE 53916
53914: GO 54142
53916: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53917: LD_ADDR_VAR 0 4
53921: PUSH
53922: LD_INT 35
53924: PUSH
53925: LD_INT 45
53927: PUSH
53928: LD_INT 46
53930: PUSH
53931: LD_INT 47
53933: PUSH
53934: LD_INT 82
53936: PUSH
53937: LD_INT 83
53939: PUSH
53940: LD_INT 84
53942: PUSH
53943: LD_INT 85
53945: PUSH
53946: LD_INT 87
53948: PUSH
53949: LD_INT 70
53951: PUSH
53952: LD_INT 1
53954: PUSH
53955: LD_INT 11
53957: PUSH
53958: LD_INT 3
53960: PUSH
53961: LD_INT 4
53963: PUSH
53964: LD_INT 5
53966: PUSH
53967: LD_INT 6
53969: PUSH
53970: LD_INT 15
53972: PUSH
53973: LD_INT 18
53975: PUSH
53976: LD_INT 7
53978: PUSH
53979: LD_INT 17
53981: PUSH
53982: LD_INT 8
53984: PUSH
53985: LD_INT 20
53987: PUSH
53988: LD_INT 21
53990: PUSH
53991: LD_INT 22
53993: PUSH
53994: LD_INT 72
53996: PUSH
53997: LD_INT 26
53999: PUSH
54000: LD_INT 69
54002: PUSH
54003: LD_INT 39
54005: PUSH
54006: LD_INT 40
54008: PUSH
54009: LD_INT 41
54011: PUSH
54012: LD_INT 42
54014: PUSH
54015: LD_INT 43
54017: PUSH
54018: LD_INT 48
54020: PUSH
54021: LD_INT 49
54023: PUSH
54024: LD_INT 50
54026: PUSH
54027: LD_INT 51
54029: PUSH
54030: LD_INT 52
54032: PUSH
54033: LD_INT 53
54035: PUSH
54036: LD_INT 54
54038: PUSH
54039: LD_INT 55
54041: PUSH
54042: LD_INT 56
54044: PUSH
54045: LD_INT 60
54047: PUSH
54048: LD_INT 61
54050: PUSH
54051: LD_INT 62
54053: PUSH
54054: LD_INT 66
54056: PUSH
54057: LD_INT 67
54059: PUSH
54060: LD_INT 68
54062: PUSH
54063: LD_INT 81
54065: PUSH
54066: LD_INT 82
54068: PUSH
54069: LD_INT 83
54071: PUSH
54072: LD_INT 84
54074: PUSH
54075: LD_INT 85
54077: PUSH
54078: LD_INT 87
54080: PUSH
54081: LD_INT 88
54083: PUSH
54084: EMPTY
54085: LIST
54086: LIST
54087: LIST
54088: LIST
54089: LIST
54090: LIST
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: LIST
54096: LIST
54097: LIST
54098: LIST
54099: LIST
54100: LIST
54101: LIST
54102: LIST
54103: LIST
54104: LIST
54105: LIST
54106: LIST
54107: LIST
54108: LIST
54109: LIST
54110: LIST
54111: LIST
54112: LIST
54113: LIST
54114: LIST
54115: LIST
54116: LIST
54117: LIST
54118: LIST
54119: LIST
54120: LIST
54121: LIST
54122: LIST
54123: LIST
54124: LIST
54125: LIST
54126: LIST
54127: LIST
54128: LIST
54129: LIST
54130: LIST
54131: LIST
54132: LIST
54133: LIST
54134: LIST
54135: LIST
54136: LIST
54137: LIST
54138: LIST
54139: ST_TO_ADDR
54140: GO 54373
54142: LD_INT 3
54144: DOUBLE
54145: EQUAL
54146: IFTRUE 54150
54148: GO 54372
54150: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
54151: LD_ADDR_VAR 0 4
54155: PUSH
54156: LD_INT 46
54158: PUSH
54159: LD_INT 47
54161: PUSH
54162: LD_INT 1
54164: PUSH
54165: LD_INT 2
54167: PUSH
54168: LD_INT 82
54170: PUSH
54171: LD_INT 83
54173: PUSH
54174: LD_INT 84
54176: PUSH
54177: LD_INT 85
54179: PUSH
54180: LD_INT 86
54182: PUSH
54183: LD_INT 11
54185: PUSH
54186: LD_INT 9
54188: PUSH
54189: LD_INT 20
54191: PUSH
54192: LD_INT 19
54194: PUSH
54195: LD_INT 21
54197: PUSH
54198: LD_INT 24
54200: PUSH
54201: LD_INT 22
54203: PUSH
54204: LD_INT 25
54206: PUSH
54207: LD_INT 28
54209: PUSH
54210: LD_INT 29
54212: PUSH
54213: LD_INT 30
54215: PUSH
54216: LD_INT 31
54218: PUSH
54219: LD_INT 37
54221: PUSH
54222: LD_INT 38
54224: PUSH
54225: LD_INT 32
54227: PUSH
54228: LD_INT 27
54230: PUSH
54231: LD_INT 33
54233: PUSH
54234: LD_INT 69
54236: PUSH
54237: LD_INT 39
54239: PUSH
54240: LD_INT 34
54242: PUSH
54243: LD_INT 40
54245: PUSH
54246: LD_INT 71
54248: PUSH
54249: LD_INT 23
54251: PUSH
54252: LD_INT 44
54254: PUSH
54255: LD_INT 48
54257: PUSH
54258: LD_INT 49
54260: PUSH
54261: LD_INT 50
54263: PUSH
54264: LD_INT 51
54266: PUSH
54267: LD_INT 52
54269: PUSH
54270: LD_INT 53
54272: PUSH
54273: LD_INT 54
54275: PUSH
54276: LD_INT 55
54278: PUSH
54279: LD_INT 56
54281: PUSH
54282: LD_INT 57
54284: PUSH
54285: LD_INT 58
54287: PUSH
54288: LD_INT 59
54290: PUSH
54291: LD_INT 63
54293: PUSH
54294: LD_INT 64
54296: PUSH
54297: LD_INT 65
54299: PUSH
54300: LD_INT 82
54302: PUSH
54303: LD_INT 83
54305: PUSH
54306: LD_INT 84
54308: PUSH
54309: LD_INT 85
54311: PUSH
54312: LD_INT 86
54314: PUSH
54315: EMPTY
54316: LIST
54317: LIST
54318: LIST
54319: LIST
54320: LIST
54321: LIST
54322: LIST
54323: LIST
54324: LIST
54325: LIST
54326: LIST
54327: LIST
54328: LIST
54329: LIST
54330: LIST
54331: LIST
54332: LIST
54333: LIST
54334: LIST
54335: LIST
54336: LIST
54337: LIST
54338: LIST
54339: LIST
54340: LIST
54341: LIST
54342: LIST
54343: LIST
54344: LIST
54345: LIST
54346: LIST
54347: LIST
54348: LIST
54349: LIST
54350: LIST
54351: LIST
54352: LIST
54353: LIST
54354: LIST
54355: LIST
54356: LIST
54357: LIST
54358: LIST
54359: LIST
54360: LIST
54361: LIST
54362: LIST
54363: LIST
54364: LIST
54365: LIST
54366: LIST
54367: LIST
54368: LIST
54369: ST_TO_ADDR
54370: GO 54373
54372: POP
// if state > - 1 and state < 3 then
54373: LD_VAR 0 3
54377: PUSH
54378: LD_INT 1
54380: NEG
54381: GREATER
54382: PUSH
54383: LD_VAR 0 3
54387: PUSH
54388: LD_INT 3
54390: LESS
54391: AND
54392: IFFALSE 54449
// for i in result do
54394: LD_ADDR_VAR 0 5
54398: PUSH
54399: LD_VAR 0 4
54403: PUSH
54404: FOR_IN
54405: IFFALSE 54447
// if GetTech ( i , side ) <> state then
54407: LD_VAR 0 5
54411: PPUSH
54412: LD_VAR 0 1
54416: PPUSH
54417: CALL_OW 321
54421: PUSH
54422: LD_VAR 0 3
54426: NONEQUAL
54427: IFFALSE 54445
// result := result diff i ;
54429: LD_ADDR_VAR 0 4
54433: PUSH
54434: LD_VAR 0 4
54438: PUSH
54439: LD_VAR 0 5
54443: DIFF
54444: ST_TO_ADDR
54445: GO 54404
54447: POP
54448: POP
// end ;
54449: LD_VAR 0 4
54453: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
54454: LD_INT 0
54456: PPUSH
54457: PPUSH
54458: PPUSH
// result := true ;
54459: LD_ADDR_VAR 0 3
54463: PUSH
54464: LD_INT 1
54466: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
54467: LD_ADDR_VAR 0 5
54471: PUSH
54472: LD_VAR 0 2
54476: PPUSH
54477: CALL_OW 480
54481: ST_TO_ADDR
// if not tmp then
54482: LD_VAR 0 5
54486: NOT
54487: IFFALSE 54491
// exit ;
54489: GO 54540
// for i in tmp do
54491: LD_ADDR_VAR 0 4
54495: PUSH
54496: LD_VAR 0 5
54500: PUSH
54501: FOR_IN
54502: IFFALSE 54538
// if GetTech ( i , side ) <> state_researched then
54504: LD_VAR 0 4
54508: PPUSH
54509: LD_VAR 0 1
54513: PPUSH
54514: CALL_OW 321
54518: PUSH
54519: LD_INT 2
54521: NONEQUAL
54522: IFFALSE 54536
// begin result := false ;
54524: LD_ADDR_VAR 0 3
54528: PUSH
54529: LD_INT 0
54531: ST_TO_ADDR
// exit ;
54532: POP
54533: POP
54534: GO 54540
// end ;
54536: GO 54501
54538: POP
54539: POP
// end ;
54540: LD_VAR 0 3
54544: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
54545: LD_INT 0
54547: PPUSH
54548: PPUSH
54549: PPUSH
54550: PPUSH
54551: PPUSH
54552: PPUSH
54553: PPUSH
54554: PPUSH
54555: PPUSH
54556: PPUSH
54557: PPUSH
54558: PPUSH
54559: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
54560: LD_VAR 0 1
54564: NOT
54565: PUSH
54566: LD_VAR 0 1
54570: PPUSH
54571: CALL_OW 257
54575: PUSH
54576: LD_INT 9
54578: NONEQUAL
54579: OR
54580: IFFALSE 54584
// exit ;
54582: GO 55157
// side := GetSide ( unit ) ;
54584: LD_ADDR_VAR 0 9
54588: PUSH
54589: LD_VAR 0 1
54593: PPUSH
54594: CALL_OW 255
54598: ST_TO_ADDR
// tech_space := tech_spacanom ;
54599: LD_ADDR_VAR 0 12
54603: PUSH
54604: LD_INT 29
54606: ST_TO_ADDR
// tech_time := tech_taurad ;
54607: LD_ADDR_VAR 0 13
54611: PUSH
54612: LD_INT 28
54614: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
54615: LD_ADDR_VAR 0 11
54619: PUSH
54620: LD_VAR 0 1
54624: PPUSH
54625: CALL_OW 310
54629: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
54630: LD_VAR 0 11
54634: PPUSH
54635: CALL_OW 247
54639: PUSH
54640: LD_INT 2
54642: EQUAL
54643: IFFALSE 54647
// exit ;
54645: GO 55157
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54647: LD_ADDR_VAR 0 8
54651: PUSH
54652: LD_INT 81
54654: PUSH
54655: LD_VAR 0 9
54659: PUSH
54660: EMPTY
54661: LIST
54662: LIST
54663: PUSH
54664: LD_INT 3
54666: PUSH
54667: LD_INT 21
54669: PUSH
54670: LD_INT 3
54672: PUSH
54673: EMPTY
54674: LIST
54675: LIST
54676: PUSH
54677: EMPTY
54678: LIST
54679: LIST
54680: PUSH
54681: EMPTY
54682: LIST
54683: LIST
54684: PPUSH
54685: CALL_OW 69
54689: ST_TO_ADDR
// if not tmp then
54690: LD_VAR 0 8
54694: NOT
54695: IFFALSE 54699
// exit ;
54697: GO 55157
// if in_unit then
54699: LD_VAR 0 11
54703: IFFALSE 54727
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
54705: LD_ADDR_VAR 0 10
54709: PUSH
54710: LD_VAR 0 8
54714: PPUSH
54715: LD_VAR 0 11
54719: PPUSH
54720: CALL_OW 74
54724: ST_TO_ADDR
54725: GO 54747
// enemy := NearestUnitToUnit ( tmp , unit ) ;
54727: LD_ADDR_VAR 0 10
54731: PUSH
54732: LD_VAR 0 8
54736: PPUSH
54737: LD_VAR 0 1
54741: PPUSH
54742: CALL_OW 74
54746: ST_TO_ADDR
// if not enemy then
54747: LD_VAR 0 10
54751: NOT
54752: IFFALSE 54756
// exit ;
54754: GO 55157
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54756: LD_VAR 0 11
54760: PUSH
54761: LD_VAR 0 11
54765: PPUSH
54766: LD_VAR 0 10
54770: PPUSH
54771: CALL_OW 296
54775: PUSH
54776: LD_INT 13
54778: GREATER
54779: AND
54780: PUSH
54781: LD_VAR 0 1
54785: PPUSH
54786: LD_VAR 0 10
54790: PPUSH
54791: CALL_OW 296
54795: PUSH
54796: LD_INT 12
54798: GREATER
54799: OR
54800: IFFALSE 54804
// exit ;
54802: GO 55157
// missile := [ 1 ] ;
54804: LD_ADDR_VAR 0 14
54808: PUSH
54809: LD_INT 1
54811: PUSH
54812: EMPTY
54813: LIST
54814: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54815: LD_VAR 0 9
54819: PPUSH
54820: LD_VAR 0 12
54824: PPUSH
54825: CALL_OW 325
54829: IFFALSE 54858
// missile := Replace ( missile , missile + 1 , 2 ) ;
54831: LD_ADDR_VAR 0 14
54835: PUSH
54836: LD_VAR 0 14
54840: PPUSH
54841: LD_VAR 0 14
54845: PUSH
54846: LD_INT 1
54848: PLUS
54849: PPUSH
54850: LD_INT 2
54852: PPUSH
54853: CALL_OW 1
54857: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54858: LD_VAR 0 9
54862: PPUSH
54863: LD_VAR 0 13
54867: PPUSH
54868: CALL_OW 325
54872: PUSH
54873: LD_VAR 0 10
54877: PPUSH
54878: CALL_OW 255
54882: PPUSH
54883: LD_VAR 0 13
54887: PPUSH
54888: CALL_OW 325
54892: NOT
54893: AND
54894: IFFALSE 54923
// missile := Replace ( missile , missile + 1 , 3 ) ;
54896: LD_ADDR_VAR 0 14
54900: PUSH
54901: LD_VAR 0 14
54905: PPUSH
54906: LD_VAR 0 14
54910: PUSH
54911: LD_INT 1
54913: PLUS
54914: PPUSH
54915: LD_INT 3
54917: PPUSH
54918: CALL_OW 1
54922: ST_TO_ADDR
// if missile < 2 then
54923: LD_VAR 0 14
54927: PUSH
54928: LD_INT 2
54930: LESS
54931: IFFALSE 54935
// exit ;
54933: GO 55157
// x := GetX ( enemy ) ;
54935: LD_ADDR_VAR 0 4
54939: PUSH
54940: LD_VAR 0 10
54944: PPUSH
54945: CALL_OW 250
54949: ST_TO_ADDR
// y := GetY ( enemy ) ;
54950: LD_ADDR_VAR 0 5
54954: PUSH
54955: LD_VAR 0 10
54959: PPUSH
54960: CALL_OW 251
54964: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54965: LD_ADDR_VAR 0 6
54969: PUSH
54970: LD_VAR 0 4
54974: PUSH
54975: LD_INT 1
54977: NEG
54978: PPUSH
54979: LD_INT 1
54981: PPUSH
54982: CALL_OW 12
54986: PLUS
54987: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54988: LD_ADDR_VAR 0 7
54992: PUSH
54993: LD_VAR 0 5
54997: PUSH
54998: LD_INT 1
55000: NEG
55001: PPUSH
55002: LD_INT 1
55004: PPUSH
55005: CALL_OW 12
55009: PLUS
55010: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55011: LD_VAR 0 6
55015: PPUSH
55016: LD_VAR 0 7
55020: PPUSH
55021: CALL_OW 488
55025: NOT
55026: IFFALSE 55048
// begin _x := x ;
55028: LD_ADDR_VAR 0 6
55032: PUSH
55033: LD_VAR 0 4
55037: ST_TO_ADDR
// _y := y ;
55038: LD_ADDR_VAR 0 7
55042: PUSH
55043: LD_VAR 0 5
55047: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
55048: LD_ADDR_VAR 0 3
55052: PUSH
55053: LD_INT 1
55055: PPUSH
55056: LD_VAR 0 14
55060: PPUSH
55061: CALL_OW 12
55065: ST_TO_ADDR
// case i of 1 :
55066: LD_VAR 0 3
55070: PUSH
55071: LD_INT 1
55073: DOUBLE
55074: EQUAL
55075: IFTRUE 55079
55077: GO 55096
55079: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
55080: LD_VAR 0 1
55084: PPUSH
55085: LD_VAR 0 10
55089: PPUSH
55090: CALL_OW 115
55094: GO 55157
55096: LD_INT 2
55098: DOUBLE
55099: EQUAL
55100: IFTRUE 55104
55102: GO 55126
55104: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
55105: LD_VAR 0 1
55109: PPUSH
55110: LD_VAR 0 6
55114: PPUSH
55115: LD_VAR 0 7
55119: PPUSH
55120: CALL_OW 153
55124: GO 55157
55126: LD_INT 3
55128: DOUBLE
55129: EQUAL
55130: IFTRUE 55134
55132: GO 55156
55134: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
55135: LD_VAR 0 1
55139: PPUSH
55140: LD_VAR 0 6
55144: PPUSH
55145: LD_VAR 0 7
55149: PPUSH
55150: CALL_OW 154
55154: GO 55157
55156: POP
// end ;
55157: LD_VAR 0 2
55161: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
55162: LD_INT 0
55164: PPUSH
55165: PPUSH
55166: PPUSH
55167: PPUSH
55168: PPUSH
55169: PPUSH
// if not unit or not building then
55170: LD_VAR 0 1
55174: NOT
55175: PUSH
55176: LD_VAR 0 2
55180: NOT
55181: OR
55182: IFFALSE 55186
// exit ;
55184: GO 55344
// x := GetX ( building ) ;
55186: LD_ADDR_VAR 0 5
55190: PUSH
55191: LD_VAR 0 2
55195: PPUSH
55196: CALL_OW 250
55200: ST_TO_ADDR
// y := GetY ( building ) ;
55201: LD_ADDR_VAR 0 6
55205: PUSH
55206: LD_VAR 0 2
55210: PPUSH
55211: CALL_OW 251
55215: ST_TO_ADDR
// for i = 0 to 5 do
55216: LD_ADDR_VAR 0 4
55220: PUSH
55221: DOUBLE
55222: LD_INT 0
55224: DEC
55225: ST_TO_ADDR
55226: LD_INT 5
55228: PUSH
55229: FOR_TO
55230: IFFALSE 55342
// begin _x := ShiftX ( x , i , 3 ) ;
55232: LD_ADDR_VAR 0 7
55236: PUSH
55237: LD_VAR 0 5
55241: PPUSH
55242: LD_VAR 0 4
55246: PPUSH
55247: LD_INT 3
55249: PPUSH
55250: CALL_OW 272
55254: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
55255: LD_ADDR_VAR 0 8
55259: PUSH
55260: LD_VAR 0 6
55264: PPUSH
55265: LD_VAR 0 4
55269: PPUSH
55270: LD_INT 3
55272: PPUSH
55273: CALL_OW 273
55277: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55278: LD_VAR 0 7
55282: PPUSH
55283: LD_VAR 0 8
55287: PPUSH
55288: CALL_OW 488
55292: NOT
55293: IFFALSE 55297
// continue ;
55295: GO 55229
// if HexInfo ( _x , _y ) = 0 then
55297: LD_VAR 0 7
55301: PPUSH
55302: LD_VAR 0 8
55306: PPUSH
55307: CALL_OW 428
55311: PUSH
55312: LD_INT 0
55314: EQUAL
55315: IFFALSE 55340
// begin ComMoveXY ( unit , _x , _y ) ;
55317: LD_VAR 0 1
55321: PPUSH
55322: LD_VAR 0 7
55326: PPUSH
55327: LD_VAR 0 8
55331: PPUSH
55332: CALL_OW 111
// exit ;
55336: POP
55337: POP
55338: GO 55344
// end ; end ;
55340: GO 55229
55342: POP
55343: POP
// end ;
55344: LD_VAR 0 3
55348: RET
// export function ScanBase ( side , base_area ) ; begin
55349: LD_INT 0
55351: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
55352: LD_ADDR_VAR 0 3
55356: PUSH
55357: LD_VAR 0 2
55361: PPUSH
55362: LD_INT 81
55364: PUSH
55365: LD_VAR 0 1
55369: PUSH
55370: EMPTY
55371: LIST
55372: LIST
55373: PPUSH
55374: CALL_OW 70
55378: ST_TO_ADDR
// end ;
55379: LD_VAR 0 3
55383: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
55384: LD_INT 0
55386: PPUSH
55387: PPUSH
55388: PPUSH
55389: PPUSH
// result := false ;
55390: LD_ADDR_VAR 0 2
55394: PUSH
55395: LD_INT 0
55397: ST_TO_ADDR
// side := GetSide ( unit ) ;
55398: LD_ADDR_VAR 0 3
55402: PUSH
55403: LD_VAR 0 1
55407: PPUSH
55408: CALL_OW 255
55412: ST_TO_ADDR
// nat := GetNation ( unit ) ;
55413: LD_ADDR_VAR 0 4
55417: PUSH
55418: LD_VAR 0 1
55422: PPUSH
55423: CALL_OW 248
55427: ST_TO_ADDR
// case nat of 1 :
55428: LD_VAR 0 4
55432: PUSH
55433: LD_INT 1
55435: DOUBLE
55436: EQUAL
55437: IFTRUE 55441
55439: GO 55452
55441: POP
// tech := tech_lassight ; 2 :
55442: LD_ADDR_VAR 0 5
55446: PUSH
55447: LD_INT 12
55449: ST_TO_ADDR
55450: GO 55491
55452: LD_INT 2
55454: DOUBLE
55455: EQUAL
55456: IFTRUE 55460
55458: GO 55471
55460: POP
// tech := tech_mortar ; 3 :
55461: LD_ADDR_VAR 0 5
55465: PUSH
55466: LD_INT 41
55468: ST_TO_ADDR
55469: GO 55491
55471: LD_INT 3
55473: DOUBLE
55474: EQUAL
55475: IFTRUE 55479
55477: GO 55490
55479: POP
// tech := tech_bazooka ; end ;
55480: LD_ADDR_VAR 0 5
55484: PUSH
55485: LD_INT 44
55487: ST_TO_ADDR
55488: GO 55491
55490: POP
// if Researched ( side , tech ) then
55491: LD_VAR 0 3
55495: PPUSH
55496: LD_VAR 0 5
55500: PPUSH
55501: CALL_OW 325
55505: IFFALSE 55532
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
55507: LD_ADDR_VAR 0 2
55511: PUSH
55512: LD_INT 5
55514: PUSH
55515: LD_INT 8
55517: PUSH
55518: LD_INT 9
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: LIST
55525: PUSH
55526: LD_VAR 0 4
55530: ARRAY
55531: ST_TO_ADDR
// end ;
55532: LD_VAR 0 2
55536: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
55537: LD_INT 0
55539: PPUSH
55540: PPUSH
55541: PPUSH
// if not mines then
55542: LD_VAR 0 2
55546: NOT
55547: IFFALSE 55551
// exit ;
55549: GO 55695
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55551: LD_ADDR_VAR 0 5
55555: PUSH
55556: LD_INT 81
55558: PUSH
55559: LD_VAR 0 1
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: PUSH
55568: LD_INT 3
55570: PUSH
55571: LD_INT 21
55573: PUSH
55574: LD_INT 3
55576: PUSH
55577: EMPTY
55578: LIST
55579: LIST
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: PUSH
55585: EMPTY
55586: LIST
55587: LIST
55588: PPUSH
55589: CALL_OW 69
55593: ST_TO_ADDR
// for i in mines do
55594: LD_ADDR_VAR 0 4
55598: PUSH
55599: LD_VAR 0 2
55603: PUSH
55604: FOR_IN
55605: IFFALSE 55693
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
55607: LD_VAR 0 4
55611: PUSH
55612: LD_INT 1
55614: ARRAY
55615: PPUSH
55616: LD_VAR 0 4
55620: PUSH
55621: LD_INT 2
55623: ARRAY
55624: PPUSH
55625: CALL_OW 458
55629: NOT
55630: IFFALSE 55634
// continue ;
55632: GO 55604
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
55634: LD_VAR 0 4
55638: PUSH
55639: LD_INT 1
55641: ARRAY
55642: PPUSH
55643: LD_VAR 0 4
55647: PUSH
55648: LD_INT 2
55650: ARRAY
55651: PPUSH
55652: CALL_OW 428
55656: PUSH
55657: LD_VAR 0 5
55661: IN
55662: IFFALSE 55691
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
55664: LD_VAR 0 4
55668: PUSH
55669: LD_INT 1
55671: ARRAY
55672: PPUSH
55673: LD_VAR 0 4
55677: PUSH
55678: LD_INT 2
55680: ARRAY
55681: PPUSH
55682: LD_VAR 0 1
55686: PPUSH
55687: CALL_OW 456
// end ;
55691: GO 55604
55693: POP
55694: POP
// end ;
55695: LD_VAR 0 3
55699: RET
// export function Count ( array ) ; begin
55700: LD_INT 0
55702: PPUSH
// result := array + 0 ;
55703: LD_ADDR_VAR 0 2
55707: PUSH
55708: LD_VAR 0 1
55712: PUSH
55713: LD_INT 0
55715: PLUS
55716: ST_TO_ADDR
// end ;
55717: LD_VAR 0 2
55721: RET
// export function IsEmpty ( building ) ; begin
55722: LD_INT 0
55724: PPUSH
// if not building then
55725: LD_VAR 0 1
55729: NOT
55730: IFFALSE 55734
// exit ;
55732: GO 55777
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55734: LD_ADDR_VAR 0 2
55738: PUSH
55739: LD_VAR 0 1
55743: PUSH
55744: LD_INT 22
55746: PUSH
55747: LD_VAR 0 1
55751: PPUSH
55752: CALL_OW 255
55756: PUSH
55757: EMPTY
55758: LIST
55759: LIST
55760: PUSH
55761: LD_INT 58
55763: PUSH
55764: EMPTY
55765: LIST
55766: PUSH
55767: EMPTY
55768: LIST
55769: LIST
55770: PPUSH
55771: CALL_OW 69
55775: IN
55776: ST_TO_ADDR
// end ;
55777: LD_VAR 0 2
55781: RET
// export function IsNotFull ( building ) ; var places ; begin
55782: LD_INT 0
55784: PPUSH
55785: PPUSH
// if not building then
55786: LD_VAR 0 1
55790: NOT
55791: IFFALSE 55795
// exit ;
55793: GO 55823
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55795: LD_ADDR_VAR 0 2
55799: PUSH
55800: LD_VAR 0 1
55804: PPUSH
55805: LD_INT 3
55807: PUSH
55808: LD_INT 62
55810: PUSH
55811: EMPTY
55812: LIST
55813: PUSH
55814: EMPTY
55815: LIST
55816: LIST
55817: PPUSH
55818: CALL_OW 72
55822: ST_TO_ADDR
// end ;
55823: LD_VAR 0 2
55827: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55828: LD_INT 0
55830: PPUSH
55831: PPUSH
55832: PPUSH
55833: PPUSH
// tmp := [ ] ;
55834: LD_ADDR_VAR 0 3
55838: PUSH
55839: EMPTY
55840: ST_TO_ADDR
// list := [ ] ;
55841: LD_ADDR_VAR 0 5
55845: PUSH
55846: EMPTY
55847: ST_TO_ADDR
// for i = 16 to 25 do
55848: LD_ADDR_VAR 0 4
55852: PUSH
55853: DOUBLE
55854: LD_INT 16
55856: DEC
55857: ST_TO_ADDR
55858: LD_INT 25
55860: PUSH
55861: FOR_TO
55862: IFFALSE 55935
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55864: LD_ADDR_VAR 0 3
55868: PUSH
55869: LD_VAR 0 3
55873: PUSH
55874: LD_INT 22
55876: PUSH
55877: LD_VAR 0 1
55881: PPUSH
55882: CALL_OW 255
55886: PUSH
55887: EMPTY
55888: LIST
55889: LIST
55890: PUSH
55891: LD_INT 91
55893: PUSH
55894: LD_VAR 0 1
55898: PUSH
55899: LD_INT 6
55901: PUSH
55902: EMPTY
55903: LIST
55904: LIST
55905: LIST
55906: PUSH
55907: LD_INT 30
55909: PUSH
55910: LD_VAR 0 4
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: PUSH
55919: EMPTY
55920: LIST
55921: LIST
55922: LIST
55923: PUSH
55924: EMPTY
55925: LIST
55926: PPUSH
55927: CALL_OW 69
55931: ADD
55932: ST_TO_ADDR
55933: GO 55861
55935: POP
55936: POP
// for i = 1 to tmp do
55937: LD_ADDR_VAR 0 4
55941: PUSH
55942: DOUBLE
55943: LD_INT 1
55945: DEC
55946: ST_TO_ADDR
55947: LD_VAR 0 3
55951: PUSH
55952: FOR_TO
55953: IFFALSE 56041
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55955: LD_ADDR_VAR 0 5
55959: PUSH
55960: LD_VAR 0 5
55964: PUSH
55965: LD_VAR 0 3
55969: PUSH
55970: LD_VAR 0 4
55974: ARRAY
55975: PPUSH
55976: CALL_OW 266
55980: PUSH
55981: LD_VAR 0 3
55985: PUSH
55986: LD_VAR 0 4
55990: ARRAY
55991: PPUSH
55992: CALL_OW 250
55996: PUSH
55997: LD_VAR 0 3
56001: PUSH
56002: LD_VAR 0 4
56006: ARRAY
56007: PPUSH
56008: CALL_OW 251
56012: PUSH
56013: LD_VAR 0 3
56017: PUSH
56018: LD_VAR 0 4
56022: ARRAY
56023: PPUSH
56024: CALL_OW 254
56028: PUSH
56029: EMPTY
56030: LIST
56031: LIST
56032: LIST
56033: LIST
56034: PUSH
56035: EMPTY
56036: LIST
56037: ADD
56038: ST_TO_ADDR
56039: GO 55952
56041: POP
56042: POP
// result := list ;
56043: LD_ADDR_VAR 0 2
56047: PUSH
56048: LD_VAR 0 5
56052: ST_TO_ADDR
// end ;
56053: LD_VAR 0 2
56057: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
56058: LD_INT 0
56060: PPUSH
56061: PPUSH
56062: PPUSH
56063: PPUSH
56064: PPUSH
56065: PPUSH
56066: PPUSH
// if not factory then
56067: LD_VAR 0 1
56071: NOT
56072: IFFALSE 56076
// exit ;
56074: GO 56669
// if control = control_apeman then
56076: LD_VAR 0 4
56080: PUSH
56081: LD_INT 5
56083: EQUAL
56084: IFFALSE 56193
// begin tmp := UnitsInside ( factory ) ;
56086: LD_ADDR_VAR 0 8
56090: PUSH
56091: LD_VAR 0 1
56095: PPUSH
56096: CALL_OW 313
56100: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
56101: LD_VAR 0 8
56105: PPUSH
56106: LD_INT 25
56108: PUSH
56109: LD_INT 12
56111: PUSH
56112: EMPTY
56113: LIST
56114: LIST
56115: PPUSH
56116: CALL_OW 72
56120: NOT
56121: IFFALSE 56131
// control := control_manual ;
56123: LD_ADDR_VAR 0 4
56127: PUSH
56128: LD_INT 1
56130: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
56131: LD_ADDR_VAR 0 8
56135: PUSH
56136: LD_VAR 0 1
56140: PPUSH
56141: CALL 55828 0 1
56145: ST_TO_ADDR
// if tmp then
56146: LD_VAR 0 8
56150: IFFALSE 56193
// begin for i in tmp do
56152: LD_ADDR_VAR 0 7
56156: PUSH
56157: LD_VAR 0 8
56161: PUSH
56162: FOR_IN
56163: IFFALSE 56191
// if i [ 1 ] = b_ext_radio then
56165: LD_VAR 0 7
56169: PUSH
56170: LD_INT 1
56172: ARRAY
56173: PUSH
56174: LD_INT 22
56176: EQUAL
56177: IFFALSE 56189
// begin control := control_remote ;
56179: LD_ADDR_VAR 0 4
56183: PUSH
56184: LD_INT 2
56186: ST_TO_ADDR
// break ;
56187: GO 56191
// end ;
56189: GO 56162
56191: POP
56192: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56193: LD_VAR 0 1
56197: PPUSH
56198: LD_VAR 0 2
56202: PPUSH
56203: LD_VAR 0 3
56207: PPUSH
56208: LD_VAR 0 4
56212: PPUSH
56213: LD_VAR 0 5
56217: PPUSH
56218: CALL_OW 448
56222: IFFALSE 56257
// begin result := [ chassis , engine , control , weapon ] ;
56224: LD_ADDR_VAR 0 6
56228: PUSH
56229: LD_VAR 0 2
56233: PUSH
56234: LD_VAR 0 3
56238: PUSH
56239: LD_VAR 0 4
56243: PUSH
56244: LD_VAR 0 5
56248: PUSH
56249: EMPTY
56250: LIST
56251: LIST
56252: LIST
56253: LIST
56254: ST_TO_ADDR
// exit ;
56255: GO 56669
// end ; _chassis := AvailableChassisList ( factory ) ;
56257: LD_ADDR_VAR 0 9
56261: PUSH
56262: LD_VAR 0 1
56266: PPUSH
56267: CALL_OW 475
56271: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
56272: LD_ADDR_VAR 0 11
56276: PUSH
56277: LD_VAR 0 1
56281: PPUSH
56282: CALL_OW 476
56286: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
56287: LD_ADDR_VAR 0 12
56291: PUSH
56292: LD_VAR 0 1
56296: PPUSH
56297: CALL_OW 477
56301: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
56302: LD_ADDR_VAR 0 10
56306: PUSH
56307: LD_VAR 0 1
56311: PPUSH
56312: CALL_OW 478
56316: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
56317: LD_VAR 0 9
56321: NOT
56322: PUSH
56323: LD_VAR 0 11
56327: NOT
56328: OR
56329: PUSH
56330: LD_VAR 0 12
56334: NOT
56335: OR
56336: PUSH
56337: LD_VAR 0 10
56341: NOT
56342: OR
56343: IFFALSE 56378
// begin result := [ chassis , engine , control , weapon ] ;
56345: LD_ADDR_VAR 0 6
56349: PUSH
56350: LD_VAR 0 2
56354: PUSH
56355: LD_VAR 0 3
56359: PUSH
56360: LD_VAR 0 4
56364: PUSH
56365: LD_VAR 0 5
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: LIST
56374: LIST
56375: ST_TO_ADDR
// exit ;
56376: GO 56669
// end ; if not chassis in _chassis then
56378: LD_VAR 0 2
56382: PUSH
56383: LD_VAR 0 9
56387: IN
56388: NOT
56389: IFFALSE 56415
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
56391: LD_ADDR_VAR 0 2
56395: PUSH
56396: LD_VAR 0 9
56400: PUSH
56401: LD_INT 1
56403: PPUSH
56404: LD_VAR 0 9
56408: PPUSH
56409: CALL_OW 12
56413: ARRAY
56414: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
56415: LD_VAR 0 2
56419: PPUSH
56420: LD_VAR 0 3
56424: PPUSH
56425: CALL 56674 0 2
56429: NOT
56430: IFFALSE 56489
// repeat engine := _engine [ 1 ] ;
56432: LD_ADDR_VAR 0 3
56436: PUSH
56437: LD_VAR 0 11
56441: PUSH
56442: LD_INT 1
56444: ARRAY
56445: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
56446: LD_ADDR_VAR 0 11
56450: PUSH
56451: LD_VAR 0 11
56455: PPUSH
56456: LD_INT 1
56458: PPUSH
56459: CALL_OW 3
56463: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
56464: LD_VAR 0 2
56468: PPUSH
56469: LD_VAR 0 3
56473: PPUSH
56474: CALL 56674 0 2
56478: PUSH
56479: LD_VAR 0 11
56483: PUSH
56484: EMPTY
56485: EQUAL
56486: OR
56487: IFFALSE 56432
// if not control in _control then
56489: LD_VAR 0 4
56493: PUSH
56494: LD_VAR 0 12
56498: IN
56499: NOT
56500: IFFALSE 56526
// control := _control [ rand ( 1 , _control ) ] ;
56502: LD_ADDR_VAR 0 4
56506: PUSH
56507: LD_VAR 0 12
56511: PUSH
56512: LD_INT 1
56514: PPUSH
56515: LD_VAR 0 12
56519: PPUSH
56520: CALL_OW 12
56524: ARRAY
56525: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
56526: LD_VAR 0 2
56530: PPUSH
56531: LD_VAR 0 5
56535: PPUSH
56536: CALL 56894 0 2
56540: NOT
56541: IFFALSE 56600
// repeat weapon := _weapon [ 1 ] ;
56543: LD_ADDR_VAR 0 5
56547: PUSH
56548: LD_VAR 0 10
56552: PUSH
56553: LD_INT 1
56555: ARRAY
56556: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
56557: LD_ADDR_VAR 0 10
56561: PUSH
56562: LD_VAR 0 10
56566: PPUSH
56567: LD_INT 1
56569: PPUSH
56570: CALL_OW 3
56574: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
56575: LD_VAR 0 2
56579: PPUSH
56580: LD_VAR 0 5
56584: PPUSH
56585: CALL 56894 0 2
56589: PUSH
56590: LD_VAR 0 10
56594: PUSH
56595: EMPTY
56596: EQUAL
56597: OR
56598: IFFALSE 56543
// result := [ ] ;
56600: LD_ADDR_VAR 0 6
56604: PUSH
56605: EMPTY
56606: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56607: LD_VAR 0 1
56611: PPUSH
56612: LD_VAR 0 2
56616: PPUSH
56617: LD_VAR 0 3
56621: PPUSH
56622: LD_VAR 0 4
56626: PPUSH
56627: LD_VAR 0 5
56631: PPUSH
56632: CALL_OW 448
56636: IFFALSE 56669
// result := [ chassis , engine , control , weapon ] ;
56638: LD_ADDR_VAR 0 6
56642: PUSH
56643: LD_VAR 0 2
56647: PUSH
56648: LD_VAR 0 3
56652: PUSH
56653: LD_VAR 0 4
56657: PUSH
56658: LD_VAR 0 5
56662: PUSH
56663: EMPTY
56664: LIST
56665: LIST
56666: LIST
56667: LIST
56668: ST_TO_ADDR
// end ;
56669: LD_VAR 0 6
56673: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
56674: LD_INT 0
56676: PPUSH
// if not chassis or not engine then
56677: LD_VAR 0 1
56681: NOT
56682: PUSH
56683: LD_VAR 0 2
56687: NOT
56688: OR
56689: IFFALSE 56693
// exit ;
56691: GO 56889
// case engine of engine_solar :
56693: LD_VAR 0 2
56697: PUSH
56698: LD_INT 2
56700: DOUBLE
56701: EQUAL
56702: IFTRUE 56706
56704: GO 56744
56706: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
56707: LD_ADDR_VAR 0 3
56711: PUSH
56712: LD_INT 11
56714: PUSH
56715: LD_INT 12
56717: PUSH
56718: LD_INT 13
56720: PUSH
56721: LD_INT 14
56723: PUSH
56724: LD_INT 1
56726: PUSH
56727: LD_INT 2
56729: PUSH
56730: LD_INT 3
56732: PUSH
56733: EMPTY
56734: LIST
56735: LIST
56736: LIST
56737: LIST
56738: LIST
56739: LIST
56740: LIST
56741: ST_TO_ADDR
56742: GO 56873
56744: LD_INT 1
56746: DOUBLE
56747: EQUAL
56748: IFTRUE 56752
56750: GO 56814
56752: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56753: LD_ADDR_VAR 0 3
56757: PUSH
56758: LD_INT 11
56760: PUSH
56761: LD_INT 12
56763: PUSH
56764: LD_INT 13
56766: PUSH
56767: LD_INT 14
56769: PUSH
56770: LD_INT 1
56772: PUSH
56773: LD_INT 2
56775: PUSH
56776: LD_INT 3
56778: PUSH
56779: LD_INT 4
56781: PUSH
56782: LD_INT 5
56784: PUSH
56785: LD_INT 21
56787: PUSH
56788: LD_INT 23
56790: PUSH
56791: LD_INT 22
56793: PUSH
56794: LD_INT 24
56796: PUSH
56797: EMPTY
56798: LIST
56799: LIST
56800: LIST
56801: LIST
56802: LIST
56803: LIST
56804: LIST
56805: LIST
56806: LIST
56807: LIST
56808: LIST
56809: LIST
56810: LIST
56811: ST_TO_ADDR
56812: GO 56873
56814: LD_INT 3
56816: DOUBLE
56817: EQUAL
56818: IFTRUE 56822
56820: GO 56872
56822: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56823: LD_ADDR_VAR 0 3
56827: PUSH
56828: LD_INT 13
56830: PUSH
56831: LD_INT 14
56833: PUSH
56834: LD_INT 2
56836: PUSH
56837: LD_INT 3
56839: PUSH
56840: LD_INT 4
56842: PUSH
56843: LD_INT 5
56845: PUSH
56846: LD_INT 21
56848: PUSH
56849: LD_INT 22
56851: PUSH
56852: LD_INT 23
56854: PUSH
56855: LD_INT 24
56857: PUSH
56858: EMPTY
56859: LIST
56860: LIST
56861: LIST
56862: LIST
56863: LIST
56864: LIST
56865: LIST
56866: LIST
56867: LIST
56868: LIST
56869: ST_TO_ADDR
56870: GO 56873
56872: POP
// result := ( chassis in result ) ;
56873: LD_ADDR_VAR 0 3
56877: PUSH
56878: LD_VAR 0 1
56882: PUSH
56883: LD_VAR 0 3
56887: IN
56888: ST_TO_ADDR
// end ;
56889: LD_VAR 0 3
56893: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56894: LD_INT 0
56896: PPUSH
// if not chassis or not weapon then
56897: LD_VAR 0 1
56901: NOT
56902: PUSH
56903: LD_VAR 0 2
56907: NOT
56908: OR
56909: IFFALSE 56913
// exit ;
56911: GO 57973
// case weapon of us_machine_gun :
56913: LD_VAR 0 2
56917: PUSH
56918: LD_INT 2
56920: DOUBLE
56921: EQUAL
56922: IFTRUE 56926
56924: GO 56956
56926: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56927: LD_ADDR_VAR 0 3
56931: PUSH
56932: LD_INT 1
56934: PUSH
56935: LD_INT 2
56937: PUSH
56938: LD_INT 3
56940: PUSH
56941: LD_INT 4
56943: PUSH
56944: LD_INT 5
56946: PUSH
56947: EMPTY
56948: LIST
56949: LIST
56950: LIST
56951: LIST
56952: LIST
56953: ST_TO_ADDR
56954: GO 57957
56956: LD_INT 3
56958: DOUBLE
56959: EQUAL
56960: IFTRUE 56964
56962: GO 56994
56964: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56965: LD_ADDR_VAR 0 3
56969: PUSH
56970: LD_INT 1
56972: PUSH
56973: LD_INT 2
56975: PUSH
56976: LD_INT 3
56978: PUSH
56979: LD_INT 4
56981: PUSH
56982: LD_INT 5
56984: PUSH
56985: EMPTY
56986: LIST
56987: LIST
56988: LIST
56989: LIST
56990: LIST
56991: ST_TO_ADDR
56992: GO 57957
56994: LD_INT 11
56996: DOUBLE
56997: EQUAL
56998: IFTRUE 57002
57000: GO 57032
57002: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
57003: LD_ADDR_VAR 0 3
57007: PUSH
57008: LD_INT 1
57010: PUSH
57011: LD_INT 2
57013: PUSH
57014: LD_INT 3
57016: PUSH
57017: LD_INT 4
57019: PUSH
57020: LD_INT 5
57022: PUSH
57023: EMPTY
57024: LIST
57025: LIST
57026: LIST
57027: LIST
57028: LIST
57029: ST_TO_ADDR
57030: GO 57957
57032: LD_INT 4
57034: DOUBLE
57035: EQUAL
57036: IFTRUE 57040
57038: GO 57066
57040: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
57041: LD_ADDR_VAR 0 3
57045: PUSH
57046: LD_INT 2
57048: PUSH
57049: LD_INT 3
57051: PUSH
57052: LD_INT 4
57054: PUSH
57055: LD_INT 5
57057: PUSH
57058: EMPTY
57059: LIST
57060: LIST
57061: LIST
57062: LIST
57063: ST_TO_ADDR
57064: GO 57957
57066: LD_INT 5
57068: DOUBLE
57069: EQUAL
57070: IFTRUE 57074
57072: GO 57100
57074: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
57075: LD_ADDR_VAR 0 3
57079: PUSH
57080: LD_INT 2
57082: PUSH
57083: LD_INT 3
57085: PUSH
57086: LD_INT 4
57088: PUSH
57089: LD_INT 5
57091: PUSH
57092: EMPTY
57093: LIST
57094: LIST
57095: LIST
57096: LIST
57097: ST_TO_ADDR
57098: GO 57957
57100: LD_INT 9
57102: DOUBLE
57103: EQUAL
57104: IFTRUE 57108
57106: GO 57134
57108: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
57109: LD_ADDR_VAR 0 3
57113: PUSH
57114: LD_INT 2
57116: PUSH
57117: LD_INT 3
57119: PUSH
57120: LD_INT 4
57122: PUSH
57123: LD_INT 5
57125: PUSH
57126: EMPTY
57127: LIST
57128: LIST
57129: LIST
57130: LIST
57131: ST_TO_ADDR
57132: GO 57957
57134: LD_INT 7
57136: DOUBLE
57137: EQUAL
57138: IFTRUE 57142
57140: GO 57168
57142: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
57143: LD_ADDR_VAR 0 3
57147: PUSH
57148: LD_INT 2
57150: PUSH
57151: LD_INT 3
57153: PUSH
57154: LD_INT 4
57156: PUSH
57157: LD_INT 5
57159: PUSH
57160: EMPTY
57161: LIST
57162: LIST
57163: LIST
57164: LIST
57165: ST_TO_ADDR
57166: GO 57957
57168: LD_INT 12
57170: DOUBLE
57171: EQUAL
57172: IFTRUE 57176
57174: GO 57202
57176: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
57177: LD_ADDR_VAR 0 3
57181: PUSH
57182: LD_INT 2
57184: PUSH
57185: LD_INT 3
57187: PUSH
57188: LD_INT 4
57190: PUSH
57191: LD_INT 5
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: LIST
57198: LIST
57199: ST_TO_ADDR
57200: GO 57957
57202: LD_INT 13
57204: DOUBLE
57205: EQUAL
57206: IFTRUE 57210
57208: GO 57236
57210: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
57211: LD_ADDR_VAR 0 3
57215: PUSH
57216: LD_INT 2
57218: PUSH
57219: LD_INT 3
57221: PUSH
57222: LD_INT 4
57224: PUSH
57225: LD_INT 5
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: LIST
57232: LIST
57233: ST_TO_ADDR
57234: GO 57957
57236: LD_INT 14
57238: DOUBLE
57239: EQUAL
57240: IFTRUE 57244
57242: GO 57262
57244: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
57245: LD_ADDR_VAR 0 3
57249: PUSH
57250: LD_INT 4
57252: PUSH
57253: LD_INT 5
57255: PUSH
57256: EMPTY
57257: LIST
57258: LIST
57259: ST_TO_ADDR
57260: GO 57957
57262: LD_INT 6
57264: DOUBLE
57265: EQUAL
57266: IFTRUE 57270
57268: GO 57288
57270: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
57271: LD_ADDR_VAR 0 3
57275: PUSH
57276: LD_INT 4
57278: PUSH
57279: LD_INT 5
57281: PUSH
57282: EMPTY
57283: LIST
57284: LIST
57285: ST_TO_ADDR
57286: GO 57957
57288: LD_INT 10
57290: DOUBLE
57291: EQUAL
57292: IFTRUE 57296
57294: GO 57314
57296: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
57297: LD_ADDR_VAR 0 3
57301: PUSH
57302: LD_INT 4
57304: PUSH
57305: LD_INT 5
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: ST_TO_ADDR
57312: GO 57957
57314: LD_INT 22
57316: DOUBLE
57317: EQUAL
57318: IFTRUE 57322
57320: GO 57348
57322: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
57323: LD_ADDR_VAR 0 3
57327: PUSH
57328: LD_INT 11
57330: PUSH
57331: LD_INT 12
57333: PUSH
57334: LD_INT 13
57336: PUSH
57337: LD_INT 14
57339: PUSH
57340: EMPTY
57341: LIST
57342: LIST
57343: LIST
57344: LIST
57345: ST_TO_ADDR
57346: GO 57957
57348: LD_INT 23
57350: DOUBLE
57351: EQUAL
57352: IFTRUE 57356
57354: GO 57382
57356: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
57357: LD_ADDR_VAR 0 3
57361: PUSH
57362: LD_INT 11
57364: PUSH
57365: LD_INT 12
57367: PUSH
57368: LD_INT 13
57370: PUSH
57371: LD_INT 14
57373: PUSH
57374: EMPTY
57375: LIST
57376: LIST
57377: LIST
57378: LIST
57379: ST_TO_ADDR
57380: GO 57957
57382: LD_INT 24
57384: DOUBLE
57385: EQUAL
57386: IFTRUE 57390
57388: GO 57416
57390: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
57391: LD_ADDR_VAR 0 3
57395: PUSH
57396: LD_INT 11
57398: PUSH
57399: LD_INT 12
57401: PUSH
57402: LD_INT 13
57404: PUSH
57405: LD_INT 14
57407: PUSH
57408: EMPTY
57409: LIST
57410: LIST
57411: LIST
57412: LIST
57413: ST_TO_ADDR
57414: GO 57957
57416: LD_INT 30
57418: DOUBLE
57419: EQUAL
57420: IFTRUE 57424
57422: GO 57450
57424: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
57425: LD_ADDR_VAR 0 3
57429: PUSH
57430: LD_INT 11
57432: PUSH
57433: LD_INT 12
57435: PUSH
57436: LD_INT 13
57438: PUSH
57439: LD_INT 14
57441: PUSH
57442: EMPTY
57443: LIST
57444: LIST
57445: LIST
57446: LIST
57447: ST_TO_ADDR
57448: GO 57957
57450: LD_INT 25
57452: DOUBLE
57453: EQUAL
57454: IFTRUE 57458
57456: GO 57476
57458: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
57459: LD_ADDR_VAR 0 3
57463: PUSH
57464: LD_INT 13
57466: PUSH
57467: LD_INT 14
57469: PUSH
57470: EMPTY
57471: LIST
57472: LIST
57473: ST_TO_ADDR
57474: GO 57957
57476: LD_INT 27
57478: DOUBLE
57479: EQUAL
57480: IFTRUE 57484
57482: GO 57502
57484: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
57485: LD_ADDR_VAR 0 3
57489: PUSH
57490: LD_INT 13
57492: PUSH
57493: LD_INT 14
57495: PUSH
57496: EMPTY
57497: LIST
57498: LIST
57499: ST_TO_ADDR
57500: GO 57957
57502: LD_INT 92
57504: DOUBLE
57505: EQUAL
57506: IFTRUE 57510
57508: GO 57536
57510: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
57511: LD_ADDR_VAR 0 3
57515: PUSH
57516: LD_INT 11
57518: PUSH
57519: LD_INT 12
57521: PUSH
57522: LD_INT 13
57524: PUSH
57525: LD_INT 14
57527: PUSH
57528: EMPTY
57529: LIST
57530: LIST
57531: LIST
57532: LIST
57533: ST_TO_ADDR
57534: GO 57957
57536: LD_INT 28
57538: DOUBLE
57539: EQUAL
57540: IFTRUE 57544
57542: GO 57562
57544: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
57545: LD_ADDR_VAR 0 3
57549: PUSH
57550: LD_INT 13
57552: PUSH
57553: LD_INT 14
57555: PUSH
57556: EMPTY
57557: LIST
57558: LIST
57559: ST_TO_ADDR
57560: GO 57957
57562: LD_INT 29
57564: DOUBLE
57565: EQUAL
57566: IFTRUE 57570
57568: GO 57588
57570: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
57571: LD_ADDR_VAR 0 3
57575: PUSH
57576: LD_INT 13
57578: PUSH
57579: LD_INT 14
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: ST_TO_ADDR
57586: GO 57957
57588: LD_INT 31
57590: DOUBLE
57591: EQUAL
57592: IFTRUE 57596
57594: GO 57614
57596: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
57597: LD_ADDR_VAR 0 3
57601: PUSH
57602: LD_INT 13
57604: PUSH
57605: LD_INT 14
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: ST_TO_ADDR
57612: GO 57957
57614: LD_INT 26
57616: DOUBLE
57617: EQUAL
57618: IFTRUE 57622
57620: GO 57640
57622: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
57623: LD_ADDR_VAR 0 3
57627: PUSH
57628: LD_INT 13
57630: PUSH
57631: LD_INT 14
57633: PUSH
57634: EMPTY
57635: LIST
57636: LIST
57637: ST_TO_ADDR
57638: GO 57957
57640: LD_INT 42
57642: DOUBLE
57643: EQUAL
57644: IFTRUE 57648
57646: GO 57674
57648: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
57649: LD_ADDR_VAR 0 3
57653: PUSH
57654: LD_INT 21
57656: PUSH
57657: LD_INT 22
57659: PUSH
57660: LD_INT 23
57662: PUSH
57663: LD_INT 24
57665: PUSH
57666: EMPTY
57667: LIST
57668: LIST
57669: LIST
57670: LIST
57671: ST_TO_ADDR
57672: GO 57957
57674: LD_INT 43
57676: DOUBLE
57677: EQUAL
57678: IFTRUE 57682
57680: GO 57708
57682: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
57683: LD_ADDR_VAR 0 3
57687: PUSH
57688: LD_INT 21
57690: PUSH
57691: LD_INT 22
57693: PUSH
57694: LD_INT 23
57696: PUSH
57697: LD_INT 24
57699: PUSH
57700: EMPTY
57701: LIST
57702: LIST
57703: LIST
57704: LIST
57705: ST_TO_ADDR
57706: GO 57957
57708: LD_INT 44
57710: DOUBLE
57711: EQUAL
57712: IFTRUE 57716
57714: GO 57742
57716: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
57717: LD_ADDR_VAR 0 3
57721: PUSH
57722: LD_INT 21
57724: PUSH
57725: LD_INT 22
57727: PUSH
57728: LD_INT 23
57730: PUSH
57731: LD_INT 24
57733: PUSH
57734: EMPTY
57735: LIST
57736: LIST
57737: LIST
57738: LIST
57739: ST_TO_ADDR
57740: GO 57957
57742: LD_INT 45
57744: DOUBLE
57745: EQUAL
57746: IFTRUE 57750
57748: GO 57776
57750: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57751: LD_ADDR_VAR 0 3
57755: PUSH
57756: LD_INT 21
57758: PUSH
57759: LD_INT 22
57761: PUSH
57762: LD_INT 23
57764: PUSH
57765: LD_INT 24
57767: PUSH
57768: EMPTY
57769: LIST
57770: LIST
57771: LIST
57772: LIST
57773: ST_TO_ADDR
57774: GO 57957
57776: LD_INT 49
57778: DOUBLE
57779: EQUAL
57780: IFTRUE 57784
57782: GO 57810
57784: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57785: LD_ADDR_VAR 0 3
57789: PUSH
57790: LD_INT 21
57792: PUSH
57793: LD_INT 22
57795: PUSH
57796: LD_INT 23
57798: PUSH
57799: LD_INT 24
57801: PUSH
57802: EMPTY
57803: LIST
57804: LIST
57805: LIST
57806: LIST
57807: ST_TO_ADDR
57808: GO 57957
57810: LD_INT 51
57812: DOUBLE
57813: EQUAL
57814: IFTRUE 57818
57816: GO 57844
57818: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57819: LD_ADDR_VAR 0 3
57823: PUSH
57824: LD_INT 21
57826: PUSH
57827: LD_INT 22
57829: PUSH
57830: LD_INT 23
57832: PUSH
57833: LD_INT 24
57835: PUSH
57836: EMPTY
57837: LIST
57838: LIST
57839: LIST
57840: LIST
57841: ST_TO_ADDR
57842: GO 57957
57844: LD_INT 52
57846: DOUBLE
57847: EQUAL
57848: IFTRUE 57852
57850: GO 57878
57852: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57853: LD_ADDR_VAR 0 3
57857: PUSH
57858: LD_INT 21
57860: PUSH
57861: LD_INT 22
57863: PUSH
57864: LD_INT 23
57866: PUSH
57867: LD_INT 24
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: LIST
57874: LIST
57875: ST_TO_ADDR
57876: GO 57957
57878: LD_INT 53
57880: DOUBLE
57881: EQUAL
57882: IFTRUE 57886
57884: GO 57904
57886: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57887: LD_ADDR_VAR 0 3
57891: PUSH
57892: LD_INT 23
57894: PUSH
57895: LD_INT 24
57897: PUSH
57898: EMPTY
57899: LIST
57900: LIST
57901: ST_TO_ADDR
57902: GO 57957
57904: LD_INT 46
57906: DOUBLE
57907: EQUAL
57908: IFTRUE 57912
57910: GO 57930
57912: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57913: LD_ADDR_VAR 0 3
57917: PUSH
57918: LD_INT 23
57920: PUSH
57921: LD_INT 24
57923: PUSH
57924: EMPTY
57925: LIST
57926: LIST
57927: ST_TO_ADDR
57928: GO 57957
57930: LD_INT 47
57932: DOUBLE
57933: EQUAL
57934: IFTRUE 57938
57936: GO 57956
57938: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57939: LD_ADDR_VAR 0 3
57943: PUSH
57944: LD_INT 23
57946: PUSH
57947: LD_INT 24
57949: PUSH
57950: EMPTY
57951: LIST
57952: LIST
57953: ST_TO_ADDR
57954: GO 57957
57956: POP
// result := ( chassis in result ) ;
57957: LD_ADDR_VAR 0 3
57961: PUSH
57962: LD_VAR 0 1
57966: PUSH
57967: LD_VAR 0 3
57971: IN
57972: ST_TO_ADDR
// end ;
57973: LD_VAR 0 3
57977: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57978: LD_INT 0
57980: PPUSH
57981: PPUSH
57982: PPUSH
57983: PPUSH
57984: PPUSH
57985: PPUSH
57986: PPUSH
// result := array ;
57987: LD_ADDR_VAR 0 5
57991: PUSH
57992: LD_VAR 0 1
57996: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57997: LD_VAR 0 1
58001: NOT
58002: PUSH
58003: LD_VAR 0 2
58007: NOT
58008: OR
58009: PUSH
58010: LD_VAR 0 3
58014: NOT
58015: OR
58016: PUSH
58017: LD_VAR 0 2
58021: PUSH
58022: LD_VAR 0 1
58026: GREATER
58027: OR
58028: PUSH
58029: LD_VAR 0 3
58033: PUSH
58034: LD_VAR 0 1
58038: GREATER
58039: OR
58040: IFFALSE 58044
// exit ;
58042: GO 58340
// if direction then
58044: LD_VAR 0 4
58048: IFFALSE 58112
// begin d := 1 ;
58050: LD_ADDR_VAR 0 9
58054: PUSH
58055: LD_INT 1
58057: ST_TO_ADDR
// if i_from > i_to then
58058: LD_VAR 0 2
58062: PUSH
58063: LD_VAR 0 3
58067: GREATER
58068: IFFALSE 58094
// length := ( array - i_from ) + i_to else
58070: LD_ADDR_VAR 0 11
58074: PUSH
58075: LD_VAR 0 1
58079: PUSH
58080: LD_VAR 0 2
58084: MINUS
58085: PUSH
58086: LD_VAR 0 3
58090: PLUS
58091: ST_TO_ADDR
58092: GO 58110
// length := i_to - i_from ;
58094: LD_ADDR_VAR 0 11
58098: PUSH
58099: LD_VAR 0 3
58103: PUSH
58104: LD_VAR 0 2
58108: MINUS
58109: ST_TO_ADDR
// end else
58110: GO 58173
// begin d := - 1 ;
58112: LD_ADDR_VAR 0 9
58116: PUSH
58117: LD_INT 1
58119: NEG
58120: ST_TO_ADDR
// if i_from > i_to then
58121: LD_VAR 0 2
58125: PUSH
58126: LD_VAR 0 3
58130: GREATER
58131: IFFALSE 58151
// length := i_from - i_to else
58133: LD_ADDR_VAR 0 11
58137: PUSH
58138: LD_VAR 0 2
58142: PUSH
58143: LD_VAR 0 3
58147: MINUS
58148: ST_TO_ADDR
58149: GO 58173
// length := ( array - i_to ) + i_from ;
58151: LD_ADDR_VAR 0 11
58155: PUSH
58156: LD_VAR 0 1
58160: PUSH
58161: LD_VAR 0 3
58165: MINUS
58166: PUSH
58167: LD_VAR 0 2
58171: PLUS
58172: ST_TO_ADDR
// end ; if not length then
58173: LD_VAR 0 11
58177: NOT
58178: IFFALSE 58182
// exit ;
58180: GO 58340
// tmp := array ;
58182: LD_ADDR_VAR 0 10
58186: PUSH
58187: LD_VAR 0 1
58191: ST_TO_ADDR
// for i = 1 to length do
58192: LD_ADDR_VAR 0 6
58196: PUSH
58197: DOUBLE
58198: LD_INT 1
58200: DEC
58201: ST_TO_ADDR
58202: LD_VAR 0 11
58206: PUSH
58207: FOR_TO
58208: IFFALSE 58328
// begin for j = 1 to array do
58210: LD_ADDR_VAR 0 7
58214: PUSH
58215: DOUBLE
58216: LD_INT 1
58218: DEC
58219: ST_TO_ADDR
58220: LD_VAR 0 1
58224: PUSH
58225: FOR_TO
58226: IFFALSE 58314
// begin k := j + d ;
58228: LD_ADDR_VAR 0 8
58232: PUSH
58233: LD_VAR 0 7
58237: PUSH
58238: LD_VAR 0 9
58242: PLUS
58243: ST_TO_ADDR
// if k > array then
58244: LD_VAR 0 8
58248: PUSH
58249: LD_VAR 0 1
58253: GREATER
58254: IFFALSE 58264
// k := 1 ;
58256: LD_ADDR_VAR 0 8
58260: PUSH
58261: LD_INT 1
58263: ST_TO_ADDR
// if not k then
58264: LD_VAR 0 8
58268: NOT
58269: IFFALSE 58281
// k := array ;
58271: LD_ADDR_VAR 0 8
58275: PUSH
58276: LD_VAR 0 1
58280: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
58281: LD_ADDR_VAR 0 10
58285: PUSH
58286: LD_VAR 0 10
58290: PPUSH
58291: LD_VAR 0 8
58295: PPUSH
58296: LD_VAR 0 1
58300: PUSH
58301: LD_VAR 0 7
58305: ARRAY
58306: PPUSH
58307: CALL_OW 1
58311: ST_TO_ADDR
// end ;
58312: GO 58225
58314: POP
58315: POP
// array := tmp ;
58316: LD_ADDR_VAR 0 1
58320: PUSH
58321: LD_VAR 0 10
58325: ST_TO_ADDR
// end ;
58326: GO 58207
58328: POP
58329: POP
// result := array ;
58330: LD_ADDR_VAR 0 5
58334: PUSH
58335: LD_VAR 0 1
58339: ST_TO_ADDR
// end ;
58340: LD_VAR 0 5
58344: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
58345: LD_INT 0
58347: PPUSH
58348: PPUSH
// result := 0 ;
58349: LD_ADDR_VAR 0 3
58353: PUSH
58354: LD_INT 0
58356: ST_TO_ADDR
// if not array or not value in array then
58357: LD_VAR 0 1
58361: NOT
58362: PUSH
58363: LD_VAR 0 2
58367: PUSH
58368: LD_VAR 0 1
58372: IN
58373: NOT
58374: OR
58375: IFFALSE 58379
// exit ;
58377: GO 58433
// for i = 1 to array do
58379: LD_ADDR_VAR 0 4
58383: PUSH
58384: DOUBLE
58385: LD_INT 1
58387: DEC
58388: ST_TO_ADDR
58389: LD_VAR 0 1
58393: PUSH
58394: FOR_TO
58395: IFFALSE 58431
// if value = array [ i ] then
58397: LD_VAR 0 2
58401: PUSH
58402: LD_VAR 0 1
58406: PUSH
58407: LD_VAR 0 4
58411: ARRAY
58412: EQUAL
58413: IFFALSE 58429
// begin result := i ;
58415: LD_ADDR_VAR 0 3
58419: PUSH
58420: LD_VAR 0 4
58424: ST_TO_ADDR
// exit ;
58425: POP
58426: POP
58427: GO 58433
// end ;
58429: GO 58394
58431: POP
58432: POP
// end ;
58433: LD_VAR 0 3
58437: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
58438: LD_INT 0
58440: PPUSH
// vc_chassis := chassis ;
58441: LD_ADDR_OWVAR 37
58445: PUSH
58446: LD_VAR 0 1
58450: ST_TO_ADDR
// vc_engine := engine ;
58451: LD_ADDR_OWVAR 39
58455: PUSH
58456: LD_VAR 0 2
58460: ST_TO_ADDR
// vc_control := control ;
58461: LD_ADDR_OWVAR 38
58465: PUSH
58466: LD_VAR 0 3
58470: ST_TO_ADDR
// vc_weapon := weapon ;
58471: LD_ADDR_OWVAR 40
58475: PUSH
58476: LD_VAR 0 4
58480: ST_TO_ADDR
// vc_fuel_battery := fuel ;
58481: LD_ADDR_OWVAR 41
58485: PUSH
58486: LD_VAR 0 5
58490: ST_TO_ADDR
// end ;
58491: LD_VAR 0 6
58495: RET
// export function WantPlant ( unit ) ; var task ; begin
58496: LD_INT 0
58498: PPUSH
58499: PPUSH
// result := false ;
58500: LD_ADDR_VAR 0 2
58504: PUSH
58505: LD_INT 0
58507: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
58508: LD_ADDR_VAR 0 3
58512: PUSH
58513: LD_VAR 0 1
58517: PPUSH
58518: CALL_OW 437
58522: ST_TO_ADDR
// if task then
58523: LD_VAR 0 3
58527: IFFALSE 58555
// if task [ 1 ] [ 1 ] = p then
58529: LD_VAR 0 3
58533: PUSH
58534: LD_INT 1
58536: ARRAY
58537: PUSH
58538: LD_INT 1
58540: ARRAY
58541: PUSH
58542: LD_STRING p
58544: EQUAL
58545: IFFALSE 58555
// result := true ;
58547: LD_ADDR_VAR 0 2
58551: PUSH
58552: LD_INT 1
58554: ST_TO_ADDR
// end ;
58555: LD_VAR 0 2
58559: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
58560: LD_INT 0
58562: PPUSH
58563: PPUSH
58564: PPUSH
58565: PPUSH
// if pos < 1 then
58566: LD_VAR 0 2
58570: PUSH
58571: LD_INT 1
58573: LESS
58574: IFFALSE 58578
// exit ;
58576: GO 58881
// if pos = 1 then
58578: LD_VAR 0 2
58582: PUSH
58583: LD_INT 1
58585: EQUAL
58586: IFFALSE 58619
// result := Replace ( arr , pos [ 1 ] , value ) else
58588: LD_ADDR_VAR 0 4
58592: PUSH
58593: LD_VAR 0 1
58597: PPUSH
58598: LD_VAR 0 2
58602: PUSH
58603: LD_INT 1
58605: ARRAY
58606: PPUSH
58607: LD_VAR 0 3
58611: PPUSH
58612: CALL_OW 1
58616: ST_TO_ADDR
58617: GO 58881
// begin tmp := arr ;
58619: LD_ADDR_VAR 0 6
58623: PUSH
58624: LD_VAR 0 1
58628: ST_TO_ADDR
// s_arr := [ tmp ] ;
58629: LD_ADDR_VAR 0 7
58633: PUSH
58634: LD_VAR 0 6
58638: PUSH
58639: EMPTY
58640: LIST
58641: ST_TO_ADDR
// for i = 1 to pos - 1 do
58642: LD_ADDR_VAR 0 5
58646: PUSH
58647: DOUBLE
58648: LD_INT 1
58650: DEC
58651: ST_TO_ADDR
58652: LD_VAR 0 2
58656: PUSH
58657: LD_INT 1
58659: MINUS
58660: PUSH
58661: FOR_TO
58662: IFFALSE 58707
// begin tmp := tmp [ pos [ i ] ] ;
58664: LD_ADDR_VAR 0 6
58668: PUSH
58669: LD_VAR 0 6
58673: PUSH
58674: LD_VAR 0 2
58678: PUSH
58679: LD_VAR 0 5
58683: ARRAY
58684: ARRAY
58685: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
58686: LD_ADDR_VAR 0 7
58690: PUSH
58691: LD_VAR 0 7
58695: PUSH
58696: LD_VAR 0 6
58700: PUSH
58701: EMPTY
58702: LIST
58703: ADD
58704: ST_TO_ADDR
// end ;
58705: GO 58661
58707: POP
58708: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
58709: LD_ADDR_VAR 0 6
58713: PUSH
58714: LD_VAR 0 6
58718: PPUSH
58719: LD_VAR 0 2
58723: PUSH
58724: LD_VAR 0 2
58728: ARRAY
58729: PPUSH
58730: LD_VAR 0 3
58734: PPUSH
58735: CALL_OW 1
58739: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58740: LD_ADDR_VAR 0 7
58744: PUSH
58745: LD_VAR 0 7
58749: PPUSH
58750: LD_VAR 0 7
58754: PPUSH
58755: LD_VAR 0 6
58759: PPUSH
58760: CALL_OW 1
58764: ST_TO_ADDR
// for i = s_arr downto 2 do
58765: LD_ADDR_VAR 0 5
58769: PUSH
58770: DOUBLE
58771: LD_VAR 0 7
58775: INC
58776: ST_TO_ADDR
58777: LD_INT 2
58779: PUSH
58780: FOR_DOWNTO
58781: IFFALSE 58865
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58783: LD_ADDR_VAR 0 6
58787: PUSH
58788: LD_VAR 0 7
58792: PUSH
58793: LD_VAR 0 5
58797: PUSH
58798: LD_INT 1
58800: MINUS
58801: ARRAY
58802: PPUSH
58803: LD_VAR 0 2
58807: PUSH
58808: LD_VAR 0 5
58812: PUSH
58813: LD_INT 1
58815: MINUS
58816: ARRAY
58817: PPUSH
58818: LD_VAR 0 7
58822: PUSH
58823: LD_VAR 0 5
58827: ARRAY
58828: PPUSH
58829: CALL_OW 1
58833: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58834: LD_ADDR_VAR 0 7
58838: PUSH
58839: LD_VAR 0 7
58843: PPUSH
58844: LD_VAR 0 5
58848: PUSH
58849: LD_INT 1
58851: MINUS
58852: PPUSH
58853: LD_VAR 0 6
58857: PPUSH
58858: CALL_OW 1
58862: ST_TO_ADDR
// end ;
58863: GO 58780
58865: POP
58866: POP
// result := s_arr [ 1 ] ;
58867: LD_ADDR_VAR 0 4
58871: PUSH
58872: LD_VAR 0 7
58876: PUSH
58877: LD_INT 1
58879: ARRAY
58880: ST_TO_ADDR
// end ; end ;
58881: LD_VAR 0 4
58885: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58886: LD_INT 0
58888: PPUSH
58889: PPUSH
// if not list then
58890: LD_VAR 0 1
58894: NOT
58895: IFFALSE 58899
// exit ;
58897: GO 58990
// i := list [ pos1 ] ;
58899: LD_ADDR_VAR 0 5
58903: PUSH
58904: LD_VAR 0 1
58908: PUSH
58909: LD_VAR 0 2
58913: ARRAY
58914: ST_TO_ADDR
// if not i then
58915: LD_VAR 0 5
58919: NOT
58920: IFFALSE 58924
// exit ;
58922: GO 58990
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58924: LD_ADDR_VAR 0 1
58928: PUSH
58929: LD_VAR 0 1
58933: PPUSH
58934: LD_VAR 0 2
58938: PPUSH
58939: LD_VAR 0 1
58943: PUSH
58944: LD_VAR 0 3
58948: ARRAY
58949: PPUSH
58950: CALL_OW 1
58954: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58955: LD_ADDR_VAR 0 1
58959: PUSH
58960: LD_VAR 0 1
58964: PPUSH
58965: LD_VAR 0 3
58969: PPUSH
58970: LD_VAR 0 5
58974: PPUSH
58975: CALL_OW 1
58979: ST_TO_ADDR
// result := list ;
58980: LD_ADDR_VAR 0 4
58984: PUSH
58985: LD_VAR 0 1
58989: ST_TO_ADDR
// end ;
58990: LD_VAR 0 4
58994: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58995: LD_INT 0
58997: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58998: LD_ADDR_VAR 0 5
59002: PUSH
59003: LD_VAR 0 1
59007: PPUSH
59008: CALL_OW 250
59012: PPUSH
59013: LD_VAR 0 1
59017: PPUSH
59018: CALL_OW 251
59022: PPUSH
59023: LD_VAR 0 2
59027: PPUSH
59028: LD_VAR 0 3
59032: PPUSH
59033: LD_VAR 0 4
59037: PPUSH
59038: CALL 59416 0 5
59042: ST_TO_ADDR
// end ;
59043: LD_VAR 0 5
59047: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
59048: LD_INT 0
59050: PPUSH
59051: PPUSH
59052: PPUSH
59053: PPUSH
// if not list or not unit then
59054: LD_VAR 0 2
59058: NOT
59059: PUSH
59060: LD_VAR 0 1
59064: NOT
59065: OR
59066: IFFALSE 59070
// exit ;
59068: GO 59411
// result := [ ] ;
59070: LD_ADDR_VAR 0 5
59074: PUSH
59075: EMPTY
59076: ST_TO_ADDR
// for i in list do
59077: LD_ADDR_VAR 0 6
59081: PUSH
59082: LD_VAR 0 2
59086: PUSH
59087: FOR_IN
59088: IFFALSE 59306
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59090: LD_ADDR_VAR 0 8
59094: PUSH
59095: LD_VAR 0 1
59099: PPUSH
59100: LD_VAR 0 6
59104: PUSH
59105: LD_INT 1
59107: ARRAY
59108: PPUSH
59109: LD_VAR 0 6
59113: PUSH
59114: LD_INT 2
59116: ARRAY
59117: PPUSH
59118: CALL_OW 297
59122: ST_TO_ADDR
// if not Count ( result ) then
59123: LD_VAR 0 5
59127: PPUSH
59128: CALL 55700 0 1
59132: NOT
59133: IFFALSE 59166
// begin result := Join ( result , [ i , tmp ] ) ;
59135: LD_ADDR_VAR 0 5
59139: PUSH
59140: LD_VAR 0 5
59144: PPUSH
59145: LD_VAR 0 6
59149: PUSH
59150: LD_VAR 0 8
59154: PUSH
59155: EMPTY
59156: LIST
59157: LIST
59158: PPUSH
59159: CALL 91309 0 2
59163: ST_TO_ADDR
// continue ;
59164: GO 59087
// end ; if result [ result ] [ 2 ] <= tmp then
59166: LD_VAR 0 5
59170: PUSH
59171: LD_VAR 0 5
59175: ARRAY
59176: PUSH
59177: LD_INT 2
59179: ARRAY
59180: PUSH
59181: LD_VAR 0 8
59185: LESSEQUAL
59186: IFFALSE 59219
// result := Join ( result , [ i , tmp ] ) else
59188: LD_ADDR_VAR 0 5
59192: PUSH
59193: LD_VAR 0 5
59197: PPUSH
59198: LD_VAR 0 6
59202: PUSH
59203: LD_VAR 0 8
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: PPUSH
59212: CALL 91309 0 2
59216: ST_TO_ADDR
59217: GO 59304
// begin for j := 1 to Count ( result ) do
59219: LD_ADDR_VAR 0 7
59223: PUSH
59224: DOUBLE
59225: LD_INT 1
59227: DEC
59228: ST_TO_ADDR
59229: LD_VAR 0 5
59233: PPUSH
59234: CALL 55700 0 1
59238: PUSH
59239: FOR_TO
59240: IFFALSE 59302
// begin if tmp < result [ j ] [ 2 ] then
59242: LD_VAR 0 8
59246: PUSH
59247: LD_VAR 0 5
59251: PUSH
59252: LD_VAR 0 7
59256: ARRAY
59257: PUSH
59258: LD_INT 2
59260: ARRAY
59261: LESS
59262: IFFALSE 59300
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59264: LD_ADDR_VAR 0 5
59268: PUSH
59269: LD_VAR 0 5
59273: PPUSH
59274: LD_VAR 0 7
59278: PPUSH
59279: LD_VAR 0 6
59283: PUSH
59284: LD_VAR 0 8
59288: PUSH
59289: EMPTY
59290: LIST
59291: LIST
59292: PPUSH
59293: CALL_OW 2
59297: ST_TO_ADDR
// break ;
59298: GO 59302
// end ; end ;
59300: GO 59239
59302: POP
59303: POP
// end ; end ;
59304: GO 59087
59306: POP
59307: POP
// if result and not asc then
59308: LD_VAR 0 5
59312: PUSH
59313: LD_VAR 0 3
59317: NOT
59318: AND
59319: IFFALSE 59336
// result := ReverseArray ( result ) ;
59321: LD_ADDR_VAR 0 5
59325: PUSH
59326: LD_VAR 0 5
59330: PPUSH
59331: CALL 86576 0 1
59335: ST_TO_ADDR
// tmp := [ ] ;
59336: LD_ADDR_VAR 0 8
59340: PUSH
59341: EMPTY
59342: ST_TO_ADDR
// if mode then
59343: LD_VAR 0 4
59347: IFFALSE 59411
// begin for i := 1 to result do
59349: LD_ADDR_VAR 0 6
59353: PUSH
59354: DOUBLE
59355: LD_INT 1
59357: DEC
59358: ST_TO_ADDR
59359: LD_VAR 0 5
59363: PUSH
59364: FOR_TO
59365: IFFALSE 59399
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
59367: LD_ADDR_VAR 0 8
59371: PUSH
59372: LD_VAR 0 8
59376: PPUSH
59377: LD_VAR 0 5
59381: PUSH
59382: LD_VAR 0 6
59386: ARRAY
59387: PUSH
59388: LD_INT 1
59390: ARRAY
59391: PPUSH
59392: CALL 91309 0 2
59396: ST_TO_ADDR
59397: GO 59364
59399: POP
59400: POP
// result := tmp ;
59401: LD_ADDR_VAR 0 5
59405: PUSH
59406: LD_VAR 0 8
59410: ST_TO_ADDR
// end ; end ;
59411: LD_VAR 0 5
59415: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
59416: LD_INT 0
59418: PPUSH
59419: PPUSH
59420: PPUSH
59421: PPUSH
// if not list then
59422: LD_VAR 0 3
59426: NOT
59427: IFFALSE 59431
// exit ;
59429: GO 59819
// result := [ ] ;
59431: LD_ADDR_VAR 0 6
59435: PUSH
59436: EMPTY
59437: ST_TO_ADDR
// for i in list do
59438: LD_ADDR_VAR 0 7
59442: PUSH
59443: LD_VAR 0 3
59447: PUSH
59448: FOR_IN
59449: IFFALSE 59651
// begin tmp := GetDistUnitXY ( i , x , y ) ;
59451: LD_ADDR_VAR 0 9
59455: PUSH
59456: LD_VAR 0 7
59460: PPUSH
59461: LD_VAR 0 1
59465: PPUSH
59466: LD_VAR 0 2
59470: PPUSH
59471: CALL_OW 297
59475: ST_TO_ADDR
// if not result then
59476: LD_VAR 0 6
59480: NOT
59481: IFFALSE 59507
// result := [ [ i , tmp ] ] else
59483: LD_ADDR_VAR 0 6
59487: PUSH
59488: LD_VAR 0 7
59492: PUSH
59493: LD_VAR 0 9
59497: PUSH
59498: EMPTY
59499: LIST
59500: LIST
59501: PUSH
59502: EMPTY
59503: LIST
59504: ST_TO_ADDR
59505: GO 59649
// begin if result [ result ] [ 2 ] <= tmp then
59507: LD_VAR 0 6
59511: PUSH
59512: LD_VAR 0 6
59516: ARRAY
59517: PUSH
59518: LD_INT 2
59520: ARRAY
59521: PUSH
59522: LD_VAR 0 9
59526: LESSEQUAL
59527: IFFALSE 59569
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
59529: LD_ADDR_VAR 0 6
59533: PUSH
59534: LD_VAR 0 6
59538: PPUSH
59539: LD_VAR 0 6
59543: PUSH
59544: LD_INT 1
59546: PLUS
59547: PPUSH
59548: LD_VAR 0 7
59552: PUSH
59553: LD_VAR 0 9
59557: PUSH
59558: EMPTY
59559: LIST
59560: LIST
59561: PPUSH
59562: CALL_OW 2
59566: ST_TO_ADDR
59567: GO 59649
// for j := 1 to result do
59569: LD_ADDR_VAR 0 8
59573: PUSH
59574: DOUBLE
59575: LD_INT 1
59577: DEC
59578: ST_TO_ADDR
59579: LD_VAR 0 6
59583: PUSH
59584: FOR_TO
59585: IFFALSE 59647
// begin if tmp < result [ j ] [ 2 ] then
59587: LD_VAR 0 9
59591: PUSH
59592: LD_VAR 0 6
59596: PUSH
59597: LD_VAR 0 8
59601: ARRAY
59602: PUSH
59603: LD_INT 2
59605: ARRAY
59606: LESS
59607: IFFALSE 59645
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59609: LD_ADDR_VAR 0 6
59613: PUSH
59614: LD_VAR 0 6
59618: PPUSH
59619: LD_VAR 0 8
59623: PPUSH
59624: LD_VAR 0 7
59628: PUSH
59629: LD_VAR 0 9
59633: PUSH
59634: EMPTY
59635: LIST
59636: LIST
59637: PPUSH
59638: CALL_OW 2
59642: ST_TO_ADDR
// break ;
59643: GO 59647
// end ; end ;
59645: GO 59584
59647: POP
59648: POP
// end ; end ;
59649: GO 59448
59651: POP
59652: POP
// if result and not asc then
59653: LD_VAR 0 6
59657: PUSH
59658: LD_VAR 0 4
59662: NOT
59663: AND
59664: IFFALSE 59739
// begin tmp := result ;
59666: LD_ADDR_VAR 0 9
59670: PUSH
59671: LD_VAR 0 6
59675: ST_TO_ADDR
// for i = tmp downto 1 do
59676: LD_ADDR_VAR 0 7
59680: PUSH
59681: DOUBLE
59682: LD_VAR 0 9
59686: INC
59687: ST_TO_ADDR
59688: LD_INT 1
59690: PUSH
59691: FOR_DOWNTO
59692: IFFALSE 59737
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
59694: LD_ADDR_VAR 0 6
59698: PUSH
59699: LD_VAR 0 6
59703: PPUSH
59704: LD_VAR 0 9
59708: PUSH
59709: LD_VAR 0 7
59713: MINUS
59714: PUSH
59715: LD_INT 1
59717: PLUS
59718: PPUSH
59719: LD_VAR 0 9
59723: PUSH
59724: LD_VAR 0 7
59728: ARRAY
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
59735: GO 59691
59737: POP
59738: POP
// end ; tmp := [ ] ;
59739: LD_ADDR_VAR 0 9
59743: PUSH
59744: EMPTY
59745: ST_TO_ADDR
// if mode then
59746: LD_VAR 0 5
59750: IFFALSE 59819
// begin for i = 1 to result do
59752: LD_ADDR_VAR 0 7
59756: PUSH
59757: DOUBLE
59758: LD_INT 1
59760: DEC
59761: ST_TO_ADDR
59762: LD_VAR 0 6
59766: PUSH
59767: FOR_TO
59768: IFFALSE 59807
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
59770: LD_ADDR_VAR 0 9
59774: PUSH
59775: LD_VAR 0 9
59779: PPUSH
59780: LD_VAR 0 7
59784: PPUSH
59785: LD_VAR 0 6
59789: PUSH
59790: LD_VAR 0 7
59794: ARRAY
59795: PUSH
59796: LD_INT 1
59798: ARRAY
59799: PPUSH
59800: CALL_OW 1
59804: ST_TO_ADDR
59805: GO 59767
59807: POP
59808: POP
// result := tmp ;
59809: LD_ADDR_VAR 0 6
59813: PUSH
59814: LD_VAR 0 9
59818: ST_TO_ADDR
// end ; end ;
59819: LD_VAR 0 6
59823: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
59824: LD_INT 0
59826: PPUSH
59827: PPUSH
59828: PPUSH
59829: PPUSH
59830: PPUSH
59831: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
59832: LD_ADDR_VAR 0 5
59836: PUSH
59837: LD_INT 0
59839: PUSH
59840: LD_INT 0
59842: PUSH
59843: LD_INT 0
59845: PUSH
59846: EMPTY
59847: PUSH
59848: EMPTY
59849: LIST
59850: LIST
59851: LIST
59852: LIST
59853: ST_TO_ADDR
// if not x or not y then
59854: LD_VAR 0 2
59858: NOT
59859: PUSH
59860: LD_VAR 0 3
59864: NOT
59865: OR
59866: IFFALSE 59870
// exit ;
59868: GO 61520
// if not range then
59870: LD_VAR 0 4
59874: NOT
59875: IFFALSE 59885
// range := 10 ;
59877: LD_ADDR_VAR 0 4
59881: PUSH
59882: LD_INT 10
59884: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59885: LD_ADDR_VAR 0 8
59889: PUSH
59890: LD_INT 81
59892: PUSH
59893: LD_VAR 0 1
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: PUSH
59902: LD_INT 92
59904: PUSH
59905: LD_VAR 0 2
59909: PUSH
59910: LD_VAR 0 3
59914: PUSH
59915: LD_VAR 0 4
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: LIST
59924: LIST
59925: PUSH
59926: LD_INT 3
59928: PUSH
59929: LD_INT 21
59931: PUSH
59932: LD_INT 3
59934: PUSH
59935: EMPTY
59936: LIST
59937: LIST
59938: PUSH
59939: EMPTY
59940: LIST
59941: LIST
59942: PUSH
59943: EMPTY
59944: LIST
59945: LIST
59946: LIST
59947: PPUSH
59948: CALL_OW 69
59952: ST_TO_ADDR
// if not tmp then
59953: LD_VAR 0 8
59957: NOT
59958: IFFALSE 59962
// exit ;
59960: GO 61520
// for i in tmp do
59962: LD_ADDR_VAR 0 6
59966: PUSH
59967: LD_VAR 0 8
59971: PUSH
59972: FOR_IN
59973: IFFALSE 61495
// begin points := [ 0 , 0 , 0 ] ;
59975: LD_ADDR_VAR 0 9
59979: PUSH
59980: LD_INT 0
59982: PUSH
59983: LD_INT 0
59985: PUSH
59986: LD_INT 0
59988: PUSH
59989: EMPTY
59990: LIST
59991: LIST
59992: LIST
59993: ST_TO_ADDR
// bpoints := 1 ;
59994: LD_ADDR_VAR 0 10
59998: PUSH
59999: LD_INT 1
60001: ST_TO_ADDR
// case GetType ( i ) of unit_human :
60002: LD_VAR 0 6
60006: PPUSH
60007: CALL_OW 247
60011: PUSH
60012: LD_INT 1
60014: DOUBLE
60015: EQUAL
60016: IFTRUE 60020
60018: GO 60598
60020: POP
// begin if GetClass ( i ) = 1 then
60021: LD_VAR 0 6
60025: PPUSH
60026: CALL_OW 257
60030: PUSH
60031: LD_INT 1
60033: EQUAL
60034: IFFALSE 60055
// points := [ 10 , 5 , 3 ] ;
60036: LD_ADDR_VAR 0 9
60040: PUSH
60041: LD_INT 10
60043: PUSH
60044: LD_INT 5
60046: PUSH
60047: LD_INT 3
60049: PUSH
60050: EMPTY
60051: LIST
60052: LIST
60053: LIST
60054: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
60055: LD_VAR 0 6
60059: PPUSH
60060: CALL_OW 257
60064: PUSH
60065: LD_INT 2
60067: PUSH
60068: LD_INT 3
60070: PUSH
60071: LD_INT 4
60073: PUSH
60074: EMPTY
60075: LIST
60076: LIST
60077: LIST
60078: IN
60079: IFFALSE 60100
// points := [ 3 , 2 , 1 ] ;
60081: LD_ADDR_VAR 0 9
60085: PUSH
60086: LD_INT 3
60088: PUSH
60089: LD_INT 2
60091: PUSH
60092: LD_INT 1
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: LIST
60099: ST_TO_ADDR
// if GetClass ( i ) = 5 then
60100: LD_VAR 0 6
60104: PPUSH
60105: CALL_OW 257
60109: PUSH
60110: LD_INT 5
60112: EQUAL
60113: IFFALSE 60134
// points := [ 130 , 5 , 2 ] ;
60115: LD_ADDR_VAR 0 9
60119: PUSH
60120: LD_INT 130
60122: PUSH
60123: LD_INT 5
60125: PUSH
60126: LD_INT 2
60128: PUSH
60129: EMPTY
60130: LIST
60131: LIST
60132: LIST
60133: ST_TO_ADDR
// if GetClass ( i ) = 8 then
60134: LD_VAR 0 6
60138: PPUSH
60139: CALL_OW 257
60143: PUSH
60144: LD_INT 8
60146: EQUAL
60147: IFFALSE 60168
// points := [ 35 , 35 , 30 ] ;
60149: LD_ADDR_VAR 0 9
60153: PUSH
60154: LD_INT 35
60156: PUSH
60157: LD_INT 35
60159: PUSH
60160: LD_INT 30
60162: PUSH
60163: EMPTY
60164: LIST
60165: LIST
60166: LIST
60167: ST_TO_ADDR
// if GetClass ( i ) = 9 then
60168: LD_VAR 0 6
60172: PPUSH
60173: CALL_OW 257
60177: PUSH
60178: LD_INT 9
60180: EQUAL
60181: IFFALSE 60202
// points := [ 20 , 55 , 40 ] ;
60183: LD_ADDR_VAR 0 9
60187: PUSH
60188: LD_INT 20
60190: PUSH
60191: LD_INT 55
60193: PUSH
60194: LD_INT 40
60196: PUSH
60197: EMPTY
60198: LIST
60199: LIST
60200: LIST
60201: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
60202: LD_VAR 0 6
60206: PPUSH
60207: CALL_OW 257
60211: PUSH
60212: LD_INT 12
60214: PUSH
60215: LD_INT 16
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: IN
60222: IFFALSE 60243
// points := [ 5 , 3 , 2 ] ;
60224: LD_ADDR_VAR 0 9
60228: PUSH
60229: LD_INT 5
60231: PUSH
60232: LD_INT 3
60234: PUSH
60235: LD_INT 2
60237: PUSH
60238: EMPTY
60239: LIST
60240: LIST
60241: LIST
60242: ST_TO_ADDR
// if GetClass ( i ) = 17 then
60243: LD_VAR 0 6
60247: PPUSH
60248: CALL_OW 257
60252: PUSH
60253: LD_INT 17
60255: EQUAL
60256: IFFALSE 60277
// points := [ 100 , 50 , 75 ] ;
60258: LD_ADDR_VAR 0 9
60262: PUSH
60263: LD_INT 100
60265: PUSH
60266: LD_INT 50
60268: PUSH
60269: LD_INT 75
60271: PUSH
60272: EMPTY
60273: LIST
60274: LIST
60275: LIST
60276: ST_TO_ADDR
// if GetClass ( i ) = 15 then
60277: LD_VAR 0 6
60281: PPUSH
60282: CALL_OW 257
60286: PUSH
60287: LD_INT 15
60289: EQUAL
60290: IFFALSE 60311
// points := [ 10 , 5 , 3 ] ;
60292: LD_ADDR_VAR 0 9
60296: PUSH
60297: LD_INT 10
60299: PUSH
60300: LD_INT 5
60302: PUSH
60303: LD_INT 3
60305: PUSH
60306: EMPTY
60307: LIST
60308: LIST
60309: LIST
60310: ST_TO_ADDR
// if GetClass ( i ) = 14 then
60311: LD_VAR 0 6
60315: PPUSH
60316: CALL_OW 257
60320: PUSH
60321: LD_INT 14
60323: EQUAL
60324: IFFALSE 60345
// points := [ 10 , 0 , 0 ] ;
60326: LD_ADDR_VAR 0 9
60330: PUSH
60331: LD_INT 10
60333: PUSH
60334: LD_INT 0
60336: PUSH
60337: LD_INT 0
60339: PUSH
60340: EMPTY
60341: LIST
60342: LIST
60343: LIST
60344: ST_TO_ADDR
// if GetClass ( i ) = 11 then
60345: LD_VAR 0 6
60349: PPUSH
60350: CALL_OW 257
60354: PUSH
60355: LD_INT 11
60357: EQUAL
60358: IFFALSE 60379
// points := [ 30 , 10 , 5 ] ;
60360: LD_ADDR_VAR 0 9
60364: PUSH
60365: LD_INT 30
60367: PUSH
60368: LD_INT 10
60370: PUSH
60371: LD_INT 5
60373: PUSH
60374: EMPTY
60375: LIST
60376: LIST
60377: LIST
60378: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
60379: LD_VAR 0 1
60383: PPUSH
60384: LD_INT 5
60386: PPUSH
60387: CALL_OW 321
60391: PUSH
60392: LD_INT 2
60394: EQUAL
60395: IFFALSE 60412
// bpoints := bpoints * 1.8 ;
60397: LD_ADDR_VAR 0 10
60401: PUSH
60402: LD_VAR 0 10
60406: PUSH
60407: LD_REAL  1.80000000000000E+0000
60410: MUL
60411: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
60412: LD_VAR 0 6
60416: PPUSH
60417: CALL_OW 257
60421: PUSH
60422: LD_INT 1
60424: PUSH
60425: LD_INT 2
60427: PUSH
60428: LD_INT 3
60430: PUSH
60431: LD_INT 4
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: LIST
60438: LIST
60439: IN
60440: PUSH
60441: LD_VAR 0 1
60445: PPUSH
60446: LD_INT 51
60448: PPUSH
60449: CALL_OW 321
60453: PUSH
60454: LD_INT 2
60456: EQUAL
60457: AND
60458: IFFALSE 60475
// bpoints := bpoints * 1.2 ;
60460: LD_ADDR_VAR 0 10
60464: PUSH
60465: LD_VAR 0 10
60469: PUSH
60470: LD_REAL  1.20000000000000E+0000
60473: MUL
60474: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
60475: LD_VAR 0 6
60479: PPUSH
60480: CALL_OW 257
60484: PUSH
60485: LD_INT 5
60487: PUSH
60488: LD_INT 7
60490: PUSH
60491: LD_INT 9
60493: PUSH
60494: EMPTY
60495: LIST
60496: LIST
60497: LIST
60498: IN
60499: PUSH
60500: LD_VAR 0 1
60504: PPUSH
60505: LD_INT 52
60507: PPUSH
60508: CALL_OW 321
60512: PUSH
60513: LD_INT 2
60515: EQUAL
60516: AND
60517: IFFALSE 60534
// bpoints := bpoints * 1.5 ;
60519: LD_ADDR_VAR 0 10
60523: PUSH
60524: LD_VAR 0 10
60528: PUSH
60529: LD_REAL  1.50000000000000E+0000
60532: MUL
60533: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
60534: LD_VAR 0 1
60538: PPUSH
60539: LD_INT 66
60541: PPUSH
60542: CALL_OW 321
60546: PUSH
60547: LD_INT 2
60549: EQUAL
60550: IFFALSE 60567
// bpoints := bpoints * 1.1 ;
60552: LD_ADDR_VAR 0 10
60556: PUSH
60557: LD_VAR 0 10
60561: PUSH
60562: LD_REAL  1.10000000000000E+0000
60565: MUL
60566: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
60567: LD_ADDR_VAR 0 10
60571: PUSH
60572: LD_VAR 0 10
60576: PUSH
60577: LD_VAR 0 6
60581: PPUSH
60582: LD_INT 1
60584: PPUSH
60585: CALL_OW 259
60589: PUSH
60590: LD_REAL  1.15000000000000E+0000
60593: MUL
60594: MUL
60595: ST_TO_ADDR
// end ; unit_vehicle :
60596: GO 61424
60598: LD_INT 2
60600: DOUBLE
60601: EQUAL
60602: IFTRUE 60606
60604: GO 61412
60606: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
60607: LD_VAR 0 6
60611: PPUSH
60612: CALL_OW 264
60616: PUSH
60617: LD_INT 2
60619: PUSH
60620: LD_INT 42
60622: PUSH
60623: LD_INT 24
60625: PUSH
60626: EMPTY
60627: LIST
60628: LIST
60629: LIST
60630: IN
60631: IFFALSE 60652
// points := [ 25 , 5 , 3 ] ;
60633: LD_ADDR_VAR 0 9
60637: PUSH
60638: LD_INT 25
60640: PUSH
60641: LD_INT 5
60643: PUSH
60644: LD_INT 3
60646: PUSH
60647: EMPTY
60648: LIST
60649: LIST
60650: LIST
60651: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
60652: LD_VAR 0 6
60656: PPUSH
60657: CALL_OW 264
60661: PUSH
60662: LD_INT 4
60664: PUSH
60665: LD_INT 43
60667: PUSH
60668: LD_INT 25
60670: PUSH
60671: EMPTY
60672: LIST
60673: LIST
60674: LIST
60675: IN
60676: IFFALSE 60697
// points := [ 40 , 15 , 5 ] ;
60678: LD_ADDR_VAR 0 9
60682: PUSH
60683: LD_INT 40
60685: PUSH
60686: LD_INT 15
60688: PUSH
60689: LD_INT 5
60691: PUSH
60692: EMPTY
60693: LIST
60694: LIST
60695: LIST
60696: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
60697: LD_VAR 0 6
60701: PPUSH
60702: CALL_OW 264
60706: PUSH
60707: LD_INT 3
60709: PUSH
60710: LD_INT 23
60712: PUSH
60713: EMPTY
60714: LIST
60715: LIST
60716: IN
60717: IFFALSE 60738
// points := [ 7 , 25 , 8 ] ;
60719: LD_ADDR_VAR 0 9
60723: PUSH
60724: LD_INT 7
60726: PUSH
60727: LD_INT 25
60729: PUSH
60730: LD_INT 8
60732: PUSH
60733: EMPTY
60734: LIST
60735: LIST
60736: LIST
60737: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
60738: LD_VAR 0 6
60742: PPUSH
60743: CALL_OW 264
60747: PUSH
60748: LD_INT 5
60750: PUSH
60751: LD_INT 27
60753: PUSH
60754: LD_INT 44
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: LIST
60761: IN
60762: IFFALSE 60783
// points := [ 14 , 50 , 16 ] ;
60764: LD_ADDR_VAR 0 9
60768: PUSH
60769: LD_INT 14
60771: PUSH
60772: LD_INT 50
60774: PUSH
60775: LD_INT 16
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: LIST
60782: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
60783: LD_VAR 0 6
60787: PPUSH
60788: CALL_OW 264
60792: PUSH
60793: LD_INT 6
60795: PUSH
60796: LD_INT 46
60798: PUSH
60799: EMPTY
60800: LIST
60801: LIST
60802: IN
60803: IFFALSE 60824
// points := [ 32 , 120 , 70 ] ;
60805: LD_ADDR_VAR 0 9
60809: PUSH
60810: LD_INT 32
60812: PUSH
60813: LD_INT 120
60815: PUSH
60816: LD_INT 70
60818: PUSH
60819: EMPTY
60820: LIST
60821: LIST
60822: LIST
60823: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
60824: LD_VAR 0 6
60828: PPUSH
60829: CALL_OW 264
60833: PUSH
60834: LD_INT 7
60836: PUSH
60837: LD_INT 28
60839: PUSH
60840: LD_INT 45
60842: PUSH
60843: LD_INT 92
60845: PUSH
60846: EMPTY
60847: LIST
60848: LIST
60849: LIST
60850: LIST
60851: IN
60852: IFFALSE 60873
// points := [ 35 , 20 , 45 ] ;
60854: LD_ADDR_VAR 0 9
60858: PUSH
60859: LD_INT 35
60861: PUSH
60862: LD_INT 20
60864: PUSH
60865: LD_INT 45
60867: PUSH
60868: EMPTY
60869: LIST
60870: LIST
60871: LIST
60872: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
60873: LD_VAR 0 6
60877: PPUSH
60878: CALL_OW 264
60882: PUSH
60883: LD_INT 47
60885: PUSH
60886: EMPTY
60887: LIST
60888: IN
60889: IFFALSE 60910
// points := [ 67 , 45 , 75 ] ;
60891: LD_ADDR_VAR 0 9
60895: PUSH
60896: LD_INT 67
60898: PUSH
60899: LD_INT 45
60901: PUSH
60902: LD_INT 75
60904: PUSH
60905: EMPTY
60906: LIST
60907: LIST
60908: LIST
60909: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
60910: LD_VAR 0 6
60914: PPUSH
60915: CALL_OW 264
60919: PUSH
60920: LD_INT 26
60922: PUSH
60923: EMPTY
60924: LIST
60925: IN
60926: IFFALSE 60947
// points := [ 120 , 30 , 80 ] ;
60928: LD_ADDR_VAR 0 9
60932: PUSH
60933: LD_INT 120
60935: PUSH
60936: LD_INT 30
60938: PUSH
60939: LD_INT 80
60941: PUSH
60942: EMPTY
60943: LIST
60944: LIST
60945: LIST
60946: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
60947: LD_VAR 0 6
60951: PPUSH
60952: CALL_OW 264
60956: PUSH
60957: LD_INT 22
60959: PUSH
60960: EMPTY
60961: LIST
60962: IN
60963: IFFALSE 60984
// points := [ 40 , 1 , 1 ] ;
60965: LD_ADDR_VAR 0 9
60969: PUSH
60970: LD_INT 40
60972: PUSH
60973: LD_INT 1
60975: PUSH
60976: LD_INT 1
60978: PUSH
60979: EMPTY
60980: LIST
60981: LIST
60982: LIST
60983: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
60984: LD_VAR 0 6
60988: PPUSH
60989: CALL_OW 264
60993: PUSH
60994: LD_INT 29
60996: PUSH
60997: EMPTY
60998: LIST
60999: IN
61000: IFFALSE 61021
// points := [ 70 , 200 , 400 ] ;
61002: LD_ADDR_VAR 0 9
61006: PUSH
61007: LD_INT 70
61009: PUSH
61010: LD_INT 200
61012: PUSH
61013: LD_INT 400
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: LIST
61020: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
61021: LD_VAR 0 6
61025: PPUSH
61026: CALL_OW 264
61030: PUSH
61031: LD_INT 14
61033: PUSH
61034: LD_INT 53
61036: PUSH
61037: EMPTY
61038: LIST
61039: LIST
61040: IN
61041: IFFALSE 61062
// points := [ 40 , 10 , 20 ] ;
61043: LD_ADDR_VAR 0 9
61047: PUSH
61048: LD_INT 40
61050: PUSH
61051: LD_INT 10
61053: PUSH
61054: LD_INT 20
61056: PUSH
61057: EMPTY
61058: LIST
61059: LIST
61060: LIST
61061: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
61062: LD_VAR 0 6
61066: PPUSH
61067: CALL_OW 264
61071: PUSH
61072: LD_INT 9
61074: PUSH
61075: EMPTY
61076: LIST
61077: IN
61078: IFFALSE 61099
// points := [ 5 , 70 , 20 ] ;
61080: LD_ADDR_VAR 0 9
61084: PUSH
61085: LD_INT 5
61087: PUSH
61088: LD_INT 70
61090: PUSH
61091: LD_INT 20
61093: PUSH
61094: EMPTY
61095: LIST
61096: LIST
61097: LIST
61098: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
61099: LD_VAR 0 6
61103: PPUSH
61104: CALL_OW 264
61108: PUSH
61109: LD_INT 10
61111: PUSH
61112: EMPTY
61113: LIST
61114: IN
61115: IFFALSE 61136
// points := [ 35 , 110 , 70 ] ;
61117: LD_ADDR_VAR 0 9
61121: PUSH
61122: LD_INT 35
61124: PUSH
61125: LD_INT 110
61127: PUSH
61128: LD_INT 70
61130: PUSH
61131: EMPTY
61132: LIST
61133: LIST
61134: LIST
61135: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
61136: LD_VAR 0 6
61140: PPUSH
61141: CALL_OW 265
61145: PUSH
61146: LD_INT 25
61148: EQUAL
61149: IFFALSE 61170
// points := [ 80 , 65 , 100 ] ;
61151: LD_ADDR_VAR 0 9
61155: PUSH
61156: LD_INT 80
61158: PUSH
61159: LD_INT 65
61161: PUSH
61162: LD_INT 100
61164: PUSH
61165: EMPTY
61166: LIST
61167: LIST
61168: LIST
61169: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
61170: LD_VAR 0 6
61174: PPUSH
61175: CALL_OW 263
61179: PUSH
61180: LD_INT 1
61182: EQUAL
61183: IFFALSE 61218
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
61185: LD_ADDR_VAR 0 10
61189: PUSH
61190: LD_VAR 0 10
61194: PUSH
61195: LD_VAR 0 6
61199: PPUSH
61200: CALL_OW 311
61204: PPUSH
61205: LD_INT 3
61207: PPUSH
61208: CALL_OW 259
61212: PUSH
61213: LD_INT 4
61215: MUL
61216: MUL
61217: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
61218: LD_VAR 0 6
61222: PPUSH
61223: CALL_OW 263
61227: PUSH
61228: LD_INT 2
61230: EQUAL
61231: IFFALSE 61282
// begin j := IsControledBy ( i ) ;
61233: LD_ADDR_VAR 0 7
61237: PUSH
61238: LD_VAR 0 6
61242: PPUSH
61243: CALL_OW 312
61247: ST_TO_ADDR
// if j then
61248: LD_VAR 0 7
61252: IFFALSE 61282
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
61254: LD_ADDR_VAR 0 10
61258: PUSH
61259: LD_VAR 0 10
61263: PUSH
61264: LD_VAR 0 7
61268: PPUSH
61269: LD_INT 3
61271: PPUSH
61272: CALL_OW 259
61276: PUSH
61277: LD_INT 3
61279: MUL
61280: MUL
61281: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
61282: LD_VAR 0 6
61286: PPUSH
61287: CALL_OW 264
61291: PUSH
61292: LD_INT 5
61294: PUSH
61295: LD_INT 6
61297: PUSH
61298: LD_INT 46
61300: PUSH
61301: LD_INT 44
61303: PUSH
61304: LD_INT 47
61306: PUSH
61307: LD_INT 45
61309: PUSH
61310: LD_INT 28
61312: PUSH
61313: LD_INT 7
61315: PUSH
61316: LD_INT 27
61318: PUSH
61319: LD_INT 29
61321: PUSH
61322: EMPTY
61323: LIST
61324: LIST
61325: LIST
61326: LIST
61327: LIST
61328: LIST
61329: LIST
61330: LIST
61331: LIST
61332: LIST
61333: IN
61334: PUSH
61335: LD_VAR 0 1
61339: PPUSH
61340: LD_INT 52
61342: PPUSH
61343: CALL_OW 321
61347: PUSH
61348: LD_INT 2
61350: EQUAL
61351: AND
61352: IFFALSE 61369
// bpoints := bpoints * 1.2 ;
61354: LD_ADDR_VAR 0 10
61358: PUSH
61359: LD_VAR 0 10
61363: PUSH
61364: LD_REAL  1.20000000000000E+0000
61367: MUL
61368: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
61369: LD_VAR 0 6
61373: PPUSH
61374: CALL_OW 264
61378: PUSH
61379: LD_INT 6
61381: PUSH
61382: LD_INT 46
61384: PUSH
61385: LD_INT 47
61387: PUSH
61388: EMPTY
61389: LIST
61390: LIST
61391: LIST
61392: IN
61393: IFFALSE 61410
// bpoints := bpoints * 1.2 ;
61395: LD_ADDR_VAR 0 10
61399: PUSH
61400: LD_VAR 0 10
61404: PUSH
61405: LD_REAL  1.20000000000000E+0000
61408: MUL
61409: ST_TO_ADDR
// end ; unit_building :
61410: GO 61424
61412: LD_INT 3
61414: DOUBLE
61415: EQUAL
61416: IFTRUE 61420
61418: GO 61423
61420: POP
// ; end ;
61421: GO 61424
61423: POP
// for j = 1 to 3 do
61424: LD_ADDR_VAR 0 7
61428: PUSH
61429: DOUBLE
61430: LD_INT 1
61432: DEC
61433: ST_TO_ADDR
61434: LD_INT 3
61436: PUSH
61437: FOR_TO
61438: IFFALSE 61491
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
61440: LD_ADDR_VAR 0 5
61444: PUSH
61445: LD_VAR 0 5
61449: PPUSH
61450: LD_VAR 0 7
61454: PPUSH
61455: LD_VAR 0 5
61459: PUSH
61460: LD_VAR 0 7
61464: ARRAY
61465: PUSH
61466: LD_VAR 0 9
61470: PUSH
61471: LD_VAR 0 7
61475: ARRAY
61476: PUSH
61477: LD_VAR 0 10
61481: MUL
61482: PLUS
61483: PPUSH
61484: CALL_OW 1
61488: ST_TO_ADDR
61489: GO 61437
61491: POP
61492: POP
// end ;
61493: GO 59972
61495: POP
61496: POP
// result := Replace ( result , 4 , tmp ) ;
61497: LD_ADDR_VAR 0 5
61501: PUSH
61502: LD_VAR 0 5
61506: PPUSH
61507: LD_INT 4
61509: PPUSH
61510: LD_VAR 0 8
61514: PPUSH
61515: CALL_OW 1
61519: ST_TO_ADDR
// end ;
61520: LD_VAR 0 5
61524: RET
// export function DangerAtRange ( unit , range ) ; begin
61525: LD_INT 0
61527: PPUSH
// if not unit then
61528: LD_VAR 0 1
61532: NOT
61533: IFFALSE 61537
// exit ;
61535: GO 61582
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
61537: LD_ADDR_VAR 0 3
61541: PUSH
61542: LD_VAR 0 1
61546: PPUSH
61547: CALL_OW 255
61551: PPUSH
61552: LD_VAR 0 1
61556: PPUSH
61557: CALL_OW 250
61561: PPUSH
61562: LD_VAR 0 1
61566: PPUSH
61567: CALL_OW 251
61571: PPUSH
61572: LD_VAR 0 2
61576: PPUSH
61577: CALL 59824 0 4
61581: ST_TO_ADDR
// end ;
61582: LD_VAR 0 3
61586: RET
// export function DangerInArea ( side , area ) ; begin
61587: LD_INT 0
61589: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
61590: LD_ADDR_VAR 0 3
61594: PUSH
61595: LD_VAR 0 2
61599: PPUSH
61600: LD_INT 81
61602: PUSH
61603: LD_VAR 0 1
61607: PUSH
61608: EMPTY
61609: LIST
61610: LIST
61611: PPUSH
61612: CALL_OW 70
61616: ST_TO_ADDR
// end ;
61617: LD_VAR 0 3
61621: RET
// export function IsExtension ( b ) ; begin
61622: LD_INT 0
61624: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
61625: LD_ADDR_VAR 0 2
61629: PUSH
61630: LD_VAR 0 1
61634: PUSH
61635: LD_INT 23
61637: PUSH
61638: LD_INT 20
61640: PUSH
61641: LD_INT 22
61643: PUSH
61644: LD_INT 17
61646: PUSH
61647: LD_INT 24
61649: PUSH
61650: LD_INT 21
61652: PUSH
61653: LD_INT 19
61655: PUSH
61656: LD_INT 16
61658: PUSH
61659: LD_INT 25
61661: PUSH
61662: LD_INT 18
61664: PUSH
61665: EMPTY
61666: LIST
61667: LIST
61668: LIST
61669: LIST
61670: LIST
61671: LIST
61672: LIST
61673: LIST
61674: LIST
61675: LIST
61676: IN
61677: ST_TO_ADDR
// end ;
61678: LD_VAR 0 2
61682: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
61683: LD_INT 0
61685: PPUSH
61686: PPUSH
61687: PPUSH
// result := [ ] ;
61688: LD_ADDR_VAR 0 4
61692: PUSH
61693: EMPTY
61694: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
61695: LD_ADDR_VAR 0 5
61699: PUSH
61700: LD_VAR 0 2
61704: PPUSH
61705: LD_INT 21
61707: PUSH
61708: LD_INT 3
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: PPUSH
61715: CALL_OW 70
61719: ST_TO_ADDR
// if not tmp then
61720: LD_VAR 0 5
61724: NOT
61725: IFFALSE 61729
// exit ;
61727: GO 61793
// if checkLink then
61729: LD_VAR 0 3
61733: IFFALSE 61783
// begin for i in tmp do
61735: LD_ADDR_VAR 0 6
61739: PUSH
61740: LD_VAR 0 5
61744: PUSH
61745: FOR_IN
61746: IFFALSE 61781
// if GetBase ( i ) <> base then
61748: LD_VAR 0 6
61752: PPUSH
61753: CALL_OW 274
61757: PUSH
61758: LD_VAR 0 1
61762: NONEQUAL
61763: IFFALSE 61779
// ComLinkToBase ( base , i ) ;
61765: LD_VAR 0 1
61769: PPUSH
61770: LD_VAR 0 6
61774: PPUSH
61775: CALL_OW 169
61779: GO 61745
61781: POP
61782: POP
// end ; result := tmp ;
61783: LD_ADDR_VAR 0 4
61787: PUSH
61788: LD_VAR 0 5
61792: ST_TO_ADDR
// end ;
61793: LD_VAR 0 4
61797: RET
// export function ComComplete ( units , b ) ; var i ; begin
61798: LD_INT 0
61800: PPUSH
61801: PPUSH
// if not units then
61802: LD_VAR 0 1
61806: NOT
61807: IFFALSE 61811
// exit ;
61809: GO 61901
// for i in units do
61811: LD_ADDR_VAR 0 4
61815: PUSH
61816: LD_VAR 0 1
61820: PUSH
61821: FOR_IN
61822: IFFALSE 61899
// if BuildingStatus ( b ) = bs_build then
61824: LD_VAR 0 2
61828: PPUSH
61829: CALL_OW 461
61833: PUSH
61834: LD_INT 1
61836: EQUAL
61837: IFFALSE 61897
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
61839: LD_VAR 0 4
61843: PPUSH
61844: LD_STRING h
61846: PUSH
61847: LD_VAR 0 2
61851: PPUSH
61852: CALL_OW 250
61856: PUSH
61857: LD_VAR 0 2
61861: PPUSH
61862: CALL_OW 251
61866: PUSH
61867: LD_VAR 0 2
61871: PUSH
61872: LD_INT 0
61874: PUSH
61875: LD_INT 0
61877: PUSH
61878: LD_INT 0
61880: PUSH
61881: EMPTY
61882: LIST
61883: LIST
61884: LIST
61885: LIST
61886: LIST
61887: LIST
61888: LIST
61889: PUSH
61890: EMPTY
61891: LIST
61892: PPUSH
61893: CALL_OW 446
61897: GO 61821
61899: POP
61900: POP
// end ;
61901: LD_VAR 0 3
61905: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
61906: LD_INT 0
61908: PPUSH
61909: PPUSH
61910: PPUSH
61911: PPUSH
61912: PPUSH
61913: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
61914: LD_VAR 0 1
61918: NOT
61919: PUSH
61920: LD_VAR 0 1
61924: PPUSH
61925: CALL_OW 263
61929: PUSH
61930: LD_INT 2
61932: NONEQUAL
61933: OR
61934: IFFALSE 61938
// exit ;
61936: GO 62254
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
61938: LD_ADDR_VAR 0 6
61942: PUSH
61943: LD_INT 22
61945: PUSH
61946: LD_VAR 0 1
61950: PPUSH
61951: CALL_OW 255
61955: PUSH
61956: EMPTY
61957: LIST
61958: LIST
61959: PUSH
61960: LD_INT 2
61962: PUSH
61963: LD_INT 30
61965: PUSH
61966: LD_INT 36
61968: PUSH
61969: EMPTY
61970: LIST
61971: LIST
61972: PUSH
61973: LD_INT 34
61975: PUSH
61976: LD_INT 31
61978: PUSH
61979: EMPTY
61980: LIST
61981: LIST
61982: PUSH
61983: EMPTY
61984: LIST
61985: LIST
61986: LIST
61987: PUSH
61988: EMPTY
61989: LIST
61990: LIST
61991: PPUSH
61992: CALL_OW 69
61996: ST_TO_ADDR
// if not tmp then
61997: LD_VAR 0 6
62001: NOT
62002: IFFALSE 62006
// exit ;
62004: GO 62254
// result := [ ] ;
62006: LD_ADDR_VAR 0 2
62010: PUSH
62011: EMPTY
62012: ST_TO_ADDR
// for i in tmp do
62013: LD_ADDR_VAR 0 3
62017: PUSH
62018: LD_VAR 0 6
62022: PUSH
62023: FOR_IN
62024: IFFALSE 62095
// begin t := UnitsInside ( i ) ;
62026: LD_ADDR_VAR 0 4
62030: PUSH
62031: LD_VAR 0 3
62035: PPUSH
62036: CALL_OW 313
62040: ST_TO_ADDR
// if t then
62041: LD_VAR 0 4
62045: IFFALSE 62093
// for j in t do
62047: LD_ADDR_VAR 0 7
62051: PUSH
62052: LD_VAR 0 4
62056: PUSH
62057: FOR_IN
62058: IFFALSE 62091
// result := Replace ( result , result + 1 , j ) ;
62060: LD_ADDR_VAR 0 2
62064: PUSH
62065: LD_VAR 0 2
62069: PPUSH
62070: LD_VAR 0 2
62074: PUSH
62075: LD_INT 1
62077: PLUS
62078: PPUSH
62079: LD_VAR 0 7
62083: PPUSH
62084: CALL_OW 1
62088: ST_TO_ADDR
62089: GO 62057
62091: POP
62092: POP
// end ;
62093: GO 62023
62095: POP
62096: POP
// if not result then
62097: LD_VAR 0 2
62101: NOT
62102: IFFALSE 62106
// exit ;
62104: GO 62254
// mech := result [ 1 ] ;
62106: LD_ADDR_VAR 0 5
62110: PUSH
62111: LD_VAR 0 2
62115: PUSH
62116: LD_INT 1
62118: ARRAY
62119: ST_TO_ADDR
// if result > 1 then
62120: LD_VAR 0 2
62124: PUSH
62125: LD_INT 1
62127: GREATER
62128: IFFALSE 62240
// begin for i = 2 to result do
62130: LD_ADDR_VAR 0 3
62134: PUSH
62135: DOUBLE
62136: LD_INT 2
62138: DEC
62139: ST_TO_ADDR
62140: LD_VAR 0 2
62144: PUSH
62145: FOR_TO
62146: IFFALSE 62238
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
62148: LD_ADDR_VAR 0 4
62152: PUSH
62153: LD_VAR 0 2
62157: PUSH
62158: LD_VAR 0 3
62162: ARRAY
62163: PPUSH
62164: LD_INT 3
62166: PPUSH
62167: CALL_OW 259
62171: PUSH
62172: LD_VAR 0 2
62176: PUSH
62177: LD_VAR 0 3
62181: ARRAY
62182: PPUSH
62183: CALL_OW 432
62187: MINUS
62188: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
62189: LD_VAR 0 4
62193: PUSH
62194: LD_VAR 0 5
62198: PPUSH
62199: LD_INT 3
62201: PPUSH
62202: CALL_OW 259
62206: PUSH
62207: LD_VAR 0 5
62211: PPUSH
62212: CALL_OW 432
62216: MINUS
62217: GREATEREQUAL
62218: IFFALSE 62236
// mech := result [ i ] ;
62220: LD_ADDR_VAR 0 5
62224: PUSH
62225: LD_VAR 0 2
62229: PUSH
62230: LD_VAR 0 3
62234: ARRAY
62235: ST_TO_ADDR
// end ;
62236: GO 62145
62238: POP
62239: POP
// end ; ComLinkTo ( vehicle , mech ) ;
62240: LD_VAR 0 1
62244: PPUSH
62245: LD_VAR 0 5
62249: PPUSH
62250: CALL_OW 135
// end ;
62254: LD_VAR 0 2
62258: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
62259: LD_INT 0
62261: PPUSH
62262: PPUSH
62263: PPUSH
62264: PPUSH
62265: PPUSH
62266: PPUSH
62267: PPUSH
62268: PPUSH
62269: PPUSH
62270: PPUSH
62271: PPUSH
62272: PPUSH
62273: PPUSH
// result := [ ] ;
62274: LD_ADDR_VAR 0 7
62278: PUSH
62279: EMPTY
62280: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
62281: LD_VAR 0 1
62285: PPUSH
62286: CALL_OW 266
62290: PUSH
62291: LD_INT 0
62293: PUSH
62294: LD_INT 1
62296: PUSH
62297: EMPTY
62298: LIST
62299: LIST
62300: IN
62301: NOT
62302: IFFALSE 62306
// exit ;
62304: GO 63940
// if name then
62306: LD_VAR 0 3
62310: IFFALSE 62326
// SetBName ( base_dep , name ) ;
62312: LD_VAR 0 1
62316: PPUSH
62317: LD_VAR 0 3
62321: PPUSH
62322: CALL_OW 500
// base := GetBase ( base_dep ) ;
62326: LD_ADDR_VAR 0 15
62330: PUSH
62331: LD_VAR 0 1
62335: PPUSH
62336: CALL_OW 274
62340: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
62341: LD_ADDR_VAR 0 16
62345: PUSH
62346: LD_VAR 0 1
62350: PPUSH
62351: CALL_OW 255
62355: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
62356: LD_ADDR_VAR 0 17
62360: PUSH
62361: LD_VAR 0 1
62365: PPUSH
62366: CALL_OW 248
62370: ST_TO_ADDR
// if sources then
62371: LD_VAR 0 5
62375: IFFALSE 62422
// for i = 1 to 3 do
62377: LD_ADDR_VAR 0 8
62381: PUSH
62382: DOUBLE
62383: LD_INT 1
62385: DEC
62386: ST_TO_ADDR
62387: LD_INT 3
62389: PUSH
62390: FOR_TO
62391: IFFALSE 62420
// AddResourceType ( base , i , sources [ i ] ) ;
62393: LD_VAR 0 15
62397: PPUSH
62398: LD_VAR 0 8
62402: PPUSH
62403: LD_VAR 0 5
62407: PUSH
62408: LD_VAR 0 8
62412: ARRAY
62413: PPUSH
62414: CALL_OW 276
62418: GO 62390
62420: POP
62421: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
62422: LD_ADDR_VAR 0 18
62426: PUSH
62427: LD_VAR 0 15
62431: PPUSH
62432: LD_VAR 0 2
62436: PPUSH
62437: LD_INT 1
62439: PPUSH
62440: CALL 61683 0 3
62444: ST_TO_ADDR
// InitHc ;
62445: CALL_OW 19
// InitUc ;
62449: CALL_OW 18
// uc_side := side ;
62453: LD_ADDR_OWVAR 20
62457: PUSH
62458: LD_VAR 0 16
62462: ST_TO_ADDR
// uc_nation := nation ;
62463: LD_ADDR_OWVAR 21
62467: PUSH
62468: LD_VAR 0 17
62472: ST_TO_ADDR
// if buildings then
62473: LD_VAR 0 18
62477: IFFALSE 63799
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
62479: LD_ADDR_VAR 0 19
62483: PUSH
62484: LD_VAR 0 18
62488: PPUSH
62489: LD_INT 2
62491: PUSH
62492: LD_INT 30
62494: PUSH
62495: LD_INT 29
62497: PUSH
62498: EMPTY
62499: LIST
62500: LIST
62501: PUSH
62502: LD_INT 30
62504: PUSH
62505: LD_INT 30
62507: PUSH
62508: EMPTY
62509: LIST
62510: LIST
62511: PUSH
62512: EMPTY
62513: LIST
62514: LIST
62515: LIST
62516: PPUSH
62517: CALL_OW 72
62521: ST_TO_ADDR
// if tmp then
62522: LD_VAR 0 19
62526: IFFALSE 62574
// for i in tmp do
62528: LD_ADDR_VAR 0 8
62532: PUSH
62533: LD_VAR 0 19
62537: PUSH
62538: FOR_IN
62539: IFFALSE 62572
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
62541: LD_VAR 0 8
62545: PPUSH
62546: CALL_OW 250
62550: PPUSH
62551: LD_VAR 0 8
62555: PPUSH
62556: CALL_OW 251
62560: PPUSH
62561: LD_VAR 0 16
62565: PPUSH
62566: CALL_OW 441
62570: GO 62538
62572: POP
62573: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
62574: LD_VAR 0 18
62578: PPUSH
62579: LD_INT 2
62581: PUSH
62582: LD_INT 30
62584: PUSH
62585: LD_INT 32
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: PUSH
62592: LD_INT 30
62594: PUSH
62595: LD_INT 33
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: EMPTY
62603: LIST
62604: LIST
62605: LIST
62606: PPUSH
62607: CALL_OW 72
62611: IFFALSE 62699
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
62613: LD_ADDR_VAR 0 8
62617: PUSH
62618: LD_VAR 0 18
62622: PPUSH
62623: LD_INT 2
62625: PUSH
62626: LD_INT 30
62628: PUSH
62629: LD_INT 32
62631: PUSH
62632: EMPTY
62633: LIST
62634: LIST
62635: PUSH
62636: LD_INT 30
62638: PUSH
62639: LD_INT 33
62641: PUSH
62642: EMPTY
62643: LIST
62644: LIST
62645: PUSH
62646: EMPTY
62647: LIST
62648: LIST
62649: LIST
62650: PPUSH
62651: CALL_OW 72
62655: PUSH
62656: FOR_IN
62657: IFFALSE 62697
// begin if not GetBWeapon ( i ) then
62659: LD_VAR 0 8
62663: PPUSH
62664: CALL_OW 269
62668: NOT
62669: IFFALSE 62695
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
62671: LD_VAR 0 8
62675: PPUSH
62676: LD_VAR 0 8
62680: PPUSH
62681: LD_VAR 0 2
62685: PPUSH
62686: CALL 63945 0 2
62690: PPUSH
62691: CALL_OW 431
// end ;
62695: GO 62656
62697: POP
62698: POP
// end ; for i = 1 to personel do
62699: LD_ADDR_VAR 0 8
62703: PUSH
62704: DOUBLE
62705: LD_INT 1
62707: DEC
62708: ST_TO_ADDR
62709: LD_VAR 0 6
62713: PUSH
62714: FOR_TO
62715: IFFALSE 63779
// begin if i > 4 then
62717: LD_VAR 0 8
62721: PUSH
62722: LD_INT 4
62724: GREATER
62725: IFFALSE 62729
// break ;
62727: GO 63779
// case i of 1 :
62729: LD_VAR 0 8
62733: PUSH
62734: LD_INT 1
62736: DOUBLE
62737: EQUAL
62738: IFTRUE 62742
62740: GO 62822
62742: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
62743: LD_ADDR_VAR 0 12
62747: PUSH
62748: LD_VAR 0 18
62752: PPUSH
62753: LD_INT 22
62755: PUSH
62756: LD_VAR 0 16
62760: PUSH
62761: EMPTY
62762: LIST
62763: LIST
62764: PUSH
62765: LD_INT 58
62767: PUSH
62768: EMPTY
62769: LIST
62770: PUSH
62771: LD_INT 2
62773: PUSH
62774: LD_INT 30
62776: PUSH
62777: LD_INT 32
62779: PUSH
62780: EMPTY
62781: LIST
62782: LIST
62783: PUSH
62784: LD_INT 30
62786: PUSH
62787: LD_INT 4
62789: PUSH
62790: EMPTY
62791: LIST
62792: LIST
62793: PUSH
62794: LD_INT 30
62796: PUSH
62797: LD_INT 5
62799: PUSH
62800: EMPTY
62801: LIST
62802: LIST
62803: PUSH
62804: EMPTY
62805: LIST
62806: LIST
62807: LIST
62808: LIST
62809: PUSH
62810: EMPTY
62811: LIST
62812: LIST
62813: LIST
62814: PPUSH
62815: CALL_OW 72
62819: ST_TO_ADDR
62820: GO 63044
62822: LD_INT 2
62824: DOUBLE
62825: EQUAL
62826: IFTRUE 62830
62828: GO 62892
62830: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
62831: LD_ADDR_VAR 0 12
62835: PUSH
62836: LD_VAR 0 18
62840: PPUSH
62841: LD_INT 22
62843: PUSH
62844: LD_VAR 0 16
62848: PUSH
62849: EMPTY
62850: LIST
62851: LIST
62852: PUSH
62853: LD_INT 2
62855: PUSH
62856: LD_INT 30
62858: PUSH
62859: LD_INT 0
62861: PUSH
62862: EMPTY
62863: LIST
62864: LIST
62865: PUSH
62866: LD_INT 30
62868: PUSH
62869: LD_INT 1
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: LIST
62880: PUSH
62881: EMPTY
62882: LIST
62883: LIST
62884: PPUSH
62885: CALL_OW 72
62889: ST_TO_ADDR
62890: GO 63044
62892: LD_INT 3
62894: DOUBLE
62895: EQUAL
62896: IFTRUE 62900
62898: GO 62962
62900: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
62901: LD_ADDR_VAR 0 12
62905: PUSH
62906: LD_VAR 0 18
62910: PPUSH
62911: LD_INT 22
62913: PUSH
62914: LD_VAR 0 16
62918: PUSH
62919: EMPTY
62920: LIST
62921: LIST
62922: PUSH
62923: LD_INT 2
62925: PUSH
62926: LD_INT 30
62928: PUSH
62929: LD_INT 2
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: LD_INT 30
62938: PUSH
62939: LD_INT 3
62941: PUSH
62942: EMPTY
62943: LIST
62944: LIST
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: LIST
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: PPUSH
62955: CALL_OW 72
62959: ST_TO_ADDR
62960: GO 63044
62962: LD_INT 4
62964: DOUBLE
62965: EQUAL
62966: IFTRUE 62970
62968: GO 63043
62970: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
62971: LD_ADDR_VAR 0 12
62975: PUSH
62976: LD_VAR 0 18
62980: PPUSH
62981: LD_INT 22
62983: PUSH
62984: LD_VAR 0 16
62988: PUSH
62989: EMPTY
62990: LIST
62991: LIST
62992: PUSH
62993: LD_INT 2
62995: PUSH
62996: LD_INT 30
62998: PUSH
62999: LD_INT 6
63001: PUSH
63002: EMPTY
63003: LIST
63004: LIST
63005: PUSH
63006: LD_INT 30
63008: PUSH
63009: LD_INT 7
63011: PUSH
63012: EMPTY
63013: LIST
63014: LIST
63015: PUSH
63016: LD_INT 30
63018: PUSH
63019: LD_INT 8
63021: PUSH
63022: EMPTY
63023: LIST
63024: LIST
63025: PUSH
63026: EMPTY
63027: LIST
63028: LIST
63029: LIST
63030: LIST
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: PPUSH
63036: CALL_OW 72
63040: ST_TO_ADDR
63041: GO 63044
63043: POP
// if i = 1 then
63044: LD_VAR 0 8
63048: PUSH
63049: LD_INT 1
63051: EQUAL
63052: IFFALSE 63163
// begin tmp := [ ] ;
63054: LD_ADDR_VAR 0 19
63058: PUSH
63059: EMPTY
63060: ST_TO_ADDR
// for j in f do
63061: LD_ADDR_VAR 0 9
63065: PUSH
63066: LD_VAR 0 12
63070: PUSH
63071: FOR_IN
63072: IFFALSE 63145
// if GetBType ( j ) = b_bunker then
63074: LD_VAR 0 9
63078: PPUSH
63079: CALL_OW 266
63083: PUSH
63084: LD_INT 32
63086: EQUAL
63087: IFFALSE 63114
// tmp := Insert ( tmp , 1 , j ) else
63089: LD_ADDR_VAR 0 19
63093: PUSH
63094: LD_VAR 0 19
63098: PPUSH
63099: LD_INT 1
63101: PPUSH
63102: LD_VAR 0 9
63106: PPUSH
63107: CALL_OW 2
63111: ST_TO_ADDR
63112: GO 63143
// tmp := Insert ( tmp , tmp + 1 , j ) ;
63114: LD_ADDR_VAR 0 19
63118: PUSH
63119: LD_VAR 0 19
63123: PPUSH
63124: LD_VAR 0 19
63128: PUSH
63129: LD_INT 1
63131: PLUS
63132: PPUSH
63133: LD_VAR 0 9
63137: PPUSH
63138: CALL_OW 2
63142: ST_TO_ADDR
63143: GO 63071
63145: POP
63146: POP
// if tmp then
63147: LD_VAR 0 19
63151: IFFALSE 63163
// f := tmp ;
63153: LD_ADDR_VAR 0 12
63157: PUSH
63158: LD_VAR 0 19
63162: ST_TO_ADDR
// end ; x := personel [ i ] ;
63163: LD_ADDR_VAR 0 13
63167: PUSH
63168: LD_VAR 0 6
63172: PUSH
63173: LD_VAR 0 8
63177: ARRAY
63178: ST_TO_ADDR
// if x = - 1 then
63179: LD_VAR 0 13
63183: PUSH
63184: LD_INT 1
63186: NEG
63187: EQUAL
63188: IFFALSE 63397
// begin for j in f do
63190: LD_ADDR_VAR 0 9
63194: PUSH
63195: LD_VAR 0 12
63199: PUSH
63200: FOR_IN
63201: IFFALSE 63393
// repeat InitHc ;
63203: CALL_OW 19
// if GetBType ( j ) = b_barracks then
63207: LD_VAR 0 9
63211: PPUSH
63212: CALL_OW 266
63216: PUSH
63217: LD_INT 5
63219: EQUAL
63220: IFFALSE 63290
// begin if UnitsInside ( j ) < 3 then
63222: LD_VAR 0 9
63226: PPUSH
63227: CALL_OW 313
63231: PUSH
63232: LD_INT 3
63234: LESS
63235: IFFALSE 63271
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63237: LD_INT 0
63239: PPUSH
63240: LD_INT 5
63242: PUSH
63243: LD_INT 8
63245: PUSH
63246: LD_INT 9
63248: PUSH
63249: EMPTY
63250: LIST
63251: LIST
63252: LIST
63253: PUSH
63254: LD_VAR 0 17
63258: ARRAY
63259: PPUSH
63260: LD_VAR 0 4
63264: PPUSH
63265: CALL_OW 380
63269: GO 63288
// PrepareHuman ( false , i , skill ) ;
63271: LD_INT 0
63273: PPUSH
63274: LD_VAR 0 8
63278: PPUSH
63279: LD_VAR 0 4
63283: PPUSH
63284: CALL_OW 380
// end else
63288: GO 63307
// PrepareHuman ( false , i , skill ) ;
63290: LD_INT 0
63292: PPUSH
63293: LD_VAR 0 8
63297: PPUSH
63298: LD_VAR 0 4
63302: PPUSH
63303: CALL_OW 380
// un := CreateHuman ;
63307: LD_ADDR_VAR 0 14
63311: PUSH
63312: CALL_OW 44
63316: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63317: LD_ADDR_VAR 0 7
63321: PUSH
63322: LD_VAR 0 7
63326: PPUSH
63327: LD_INT 1
63329: PPUSH
63330: LD_VAR 0 14
63334: PPUSH
63335: CALL_OW 2
63339: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
63340: LD_VAR 0 14
63344: PPUSH
63345: LD_VAR 0 9
63349: PPUSH
63350: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
63354: LD_VAR 0 9
63358: PPUSH
63359: CALL_OW 313
63363: PUSH
63364: LD_INT 6
63366: EQUAL
63367: PUSH
63368: LD_VAR 0 9
63372: PPUSH
63373: CALL_OW 266
63377: PUSH
63378: LD_INT 32
63380: PUSH
63381: LD_INT 31
63383: PUSH
63384: EMPTY
63385: LIST
63386: LIST
63387: IN
63388: OR
63389: IFFALSE 63203
63391: GO 63200
63393: POP
63394: POP
// end else
63395: GO 63777
// for j = 1 to x do
63397: LD_ADDR_VAR 0 9
63401: PUSH
63402: DOUBLE
63403: LD_INT 1
63405: DEC
63406: ST_TO_ADDR
63407: LD_VAR 0 13
63411: PUSH
63412: FOR_TO
63413: IFFALSE 63775
// begin InitHc ;
63415: CALL_OW 19
// if not f then
63419: LD_VAR 0 12
63423: NOT
63424: IFFALSE 63513
// begin PrepareHuman ( false , i , skill ) ;
63426: LD_INT 0
63428: PPUSH
63429: LD_VAR 0 8
63433: PPUSH
63434: LD_VAR 0 4
63438: PPUSH
63439: CALL_OW 380
// un := CreateHuman ;
63443: LD_ADDR_VAR 0 14
63447: PUSH
63448: CALL_OW 44
63452: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63453: LD_ADDR_VAR 0 7
63457: PUSH
63458: LD_VAR 0 7
63462: PPUSH
63463: LD_INT 1
63465: PPUSH
63466: LD_VAR 0 14
63470: PPUSH
63471: CALL_OW 2
63475: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63476: LD_VAR 0 14
63480: PPUSH
63481: LD_VAR 0 1
63485: PPUSH
63486: CALL_OW 250
63490: PPUSH
63491: LD_VAR 0 1
63495: PPUSH
63496: CALL_OW 251
63500: PPUSH
63501: LD_INT 10
63503: PPUSH
63504: LD_INT 0
63506: PPUSH
63507: CALL_OW 50
// continue ;
63511: GO 63412
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
63513: LD_VAR 0 12
63517: PUSH
63518: LD_INT 1
63520: ARRAY
63521: PPUSH
63522: CALL_OW 313
63526: PUSH
63527: LD_VAR 0 12
63531: PUSH
63532: LD_INT 1
63534: ARRAY
63535: PPUSH
63536: CALL_OW 266
63540: PUSH
63541: LD_INT 32
63543: PUSH
63544: LD_INT 31
63546: PUSH
63547: EMPTY
63548: LIST
63549: LIST
63550: IN
63551: AND
63552: PUSH
63553: LD_VAR 0 12
63557: PUSH
63558: LD_INT 1
63560: ARRAY
63561: PPUSH
63562: CALL_OW 313
63566: PUSH
63567: LD_INT 6
63569: EQUAL
63570: OR
63571: IFFALSE 63591
// f := Delete ( f , 1 ) ;
63573: LD_ADDR_VAR 0 12
63577: PUSH
63578: LD_VAR 0 12
63582: PPUSH
63583: LD_INT 1
63585: PPUSH
63586: CALL_OW 3
63590: ST_TO_ADDR
// if not f then
63591: LD_VAR 0 12
63595: NOT
63596: IFFALSE 63614
// begin x := x + 2 ;
63598: LD_ADDR_VAR 0 13
63602: PUSH
63603: LD_VAR 0 13
63607: PUSH
63608: LD_INT 2
63610: PLUS
63611: ST_TO_ADDR
// continue ;
63612: GO 63412
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
63614: LD_VAR 0 12
63618: PUSH
63619: LD_INT 1
63621: ARRAY
63622: PPUSH
63623: CALL_OW 266
63627: PUSH
63628: LD_INT 5
63630: EQUAL
63631: IFFALSE 63705
// begin if UnitsInside ( f [ 1 ] ) < 3 then
63633: LD_VAR 0 12
63637: PUSH
63638: LD_INT 1
63640: ARRAY
63641: PPUSH
63642: CALL_OW 313
63646: PUSH
63647: LD_INT 3
63649: LESS
63650: IFFALSE 63686
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63652: LD_INT 0
63654: PPUSH
63655: LD_INT 5
63657: PUSH
63658: LD_INT 8
63660: PUSH
63661: LD_INT 9
63663: PUSH
63664: EMPTY
63665: LIST
63666: LIST
63667: LIST
63668: PUSH
63669: LD_VAR 0 17
63673: ARRAY
63674: PPUSH
63675: LD_VAR 0 4
63679: PPUSH
63680: CALL_OW 380
63684: GO 63703
// PrepareHuman ( false , i , skill ) ;
63686: LD_INT 0
63688: PPUSH
63689: LD_VAR 0 8
63693: PPUSH
63694: LD_VAR 0 4
63698: PPUSH
63699: CALL_OW 380
// end else
63703: GO 63722
// PrepareHuman ( false , i , skill ) ;
63705: LD_INT 0
63707: PPUSH
63708: LD_VAR 0 8
63712: PPUSH
63713: LD_VAR 0 4
63717: PPUSH
63718: CALL_OW 380
// un := CreateHuman ;
63722: LD_ADDR_VAR 0 14
63726: PUSH
63727: CALL_OW 44
63731: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63732: LD_ADDR_VAR 0 7
63736: PUSH
63737: LD_VAR 0 7
63741: PPUSH
63742: LD_INT 1
63744: PPUSH
63745: LD_VAR 0 14
63749: PPUSH
63750: CALL_OW 2
63754: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
63755: LD_VAR 0 14
63759: PPUSH
63760: LD_VAR 0 12
63764: PUSH
63765: LD_INT 1
63767: ARRAY
63768: PPUSH
63769: CALL_OW 52
// end ;
63773: GO 63412
63775: POP
63776: POP
// end ;
63777: GO 62714
63779: POP
63780: POP
// result := result ^ buildings ;
63781: LD_ADDR_VAR 0 7
63785: PUSH
63786: LD_VAR 0 7
63790: PUSH
63791: LD_VAR 0 18
63795: ADD
63796: ST_TO_ADDR
// end else
63797: GO 63940
// begin for i = 1 to personel do
63799: LD_ADDR_VAR 0 8
63803: PUSH
63804: DOUBLE
63805: LD_INT 1
63807: DEC
63808: ST_TO_ADDR
63809: LD_VAR 0 6
63813: PUSH
63814: FOR_TO
63815: IFFALSE 63938
// begin if i > 4 then
63817: LD_VAR 0 8
63821: PUSH
63822: LD_INT 4
63824: GREATER
63825: IFFALSE 63829
// break ;
63827: GO 63938
// x := personel [ i ] ;
63829: LD_ADDR_VAR 0 13
63833: PUSH
63834: LD_VAR 0 6
63838: PUSH
63839: LD_VAR 0 8
63843: ARRAY
63844: ST_TO_ADDR
// if x = - 1 then
63845: LD_VAR 0 13
63849: PUSH
63850: LD_INT 1
63852: NEG
63853: EQUAL
63854: IFFALSE 63858
// continue ;
63856: GO 63814
// PrepareHuman ( false , i , skill ) ;
63858: LD_INT 0
63860: PPUSH
63861: LD_VAR 0 8
63865: PPUSH
63866: LD_VAR 0 4
63870: PPUSH
63871: CALL_OW 380
// un := CreateHuman ;
63875: LD_ADDR_VAR 0 14
63879: PUSH
63880: CALL_OW 44
63884: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63885: LD_VAR 0 14
63889: PPUSH
63890: LD_VAR 0 1
63894: PPUSH
63895: CALL_OW 250
63899: PPUSH
63900: LD_VAR 0 1
63904: PPUSH
63905: CALL_OW 251
63909: PPUSH
63910: LD_INT 10
63912: PPUSH
63913: LD_INT 0
63915: PPUSH
63916: CALL_OW 50
// result := result ^ un ;
63920: LD_ADDR_VAR 0 7
63924: PUSH
63925: LD_VAR 0 7
63929: PUSH
63930: LD_VAR 0 14
63934: ADD
63935: ST_TO_ADDR
// end ;
63936: GO 63814
63938: POP
63939: POP
// end ; end ;
63940: LD_VAR 0 7
63944: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
63945: LD_INT 0
63947: PPUSH
63948: PPUSH
63949: PPUSH
63950: PPUSH
63951: PPUSH
63952: PPUSH
63953: PPUSH
63954: PPUSH
63955: PPUSH
63956: PPUSH
63957: PPUSH
63958: PPUSH
63959: PPUSH
63960: PPUSH
63961: PPUSH
63962: PPUSH
// result := false ;
63963: LD_ADDR_VAR 0 3
63967: PUSH
63968: LD_INT 0
63970: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
63971: LD_VAR 0 1
63975: NOT
63976: PUSH
63977: LD_VAR 0 1
63981: PPUSH
63982: CALL_OW 266
63986: PUSH
63987: LD_INT 32
63989: PUSH
63990: LD_INT 33
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: IN
63997: NOT
63998: OR
63999: IFFALSE 64003
// exit ;
64001: GO 65112
// nat := GetNation ( tower ) ;
64003: LD_ADDR_VAR 0 12
64007: PUSH
64008: LD_VAR 0 1
64012: PPUSH
64013: CALL_OW 248
64017: ST_TO_ADDR
// side := GetSide ( tower ) ;
64018: LD_ADDR_VAR 0 16
64022: PUSH
64023: LD_VAR 0 1
64027: PPUSH
64028: CALL_OW 255
64032: ST_TO_ADDR
// x := GetX ( tower ) ;
64033: LD_ADDR_VAR 0 10
64037: PUSH
64038: LD_VAR 0 1
64042: PPUSH
64043: CALL_OW 250
64047: ST_TO_ADDR
// y := GetY ( tower ) ;
64048: LD_ADDR_VAR 0 11
64052: PUSH
64053: LD_VAR 0 1
64057: PPUSH
64058: CALL_OW 251
64062: ST_TO_ADDR
// if not x or not y then
64063: LD_VAR 0 10
64067: NOT
64068: PUSH
64069: LD_VAR 0 11
64073: NOT
64074: OR
64075: IFFALSE 64079
// exit ;
64077: GO 65112
// weapon := 0 ;
64079: LD_ADDR_VAR 0 18
64083: PUSH
64084: LD_INT 0
64086: ST_TO_ADDR
// fac_list := [ ] ;
64087: LD_ADDR_VAR 0 17
64091: PUSH
64092: EMPTY
64093: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
64094: LD_ADDR_VAR 0 6
64098: PUSH
64099: LD_VAR 0 1
64103: PPUSH
64104: CALL_OW 274
64108: PPUSH
64109: LD_VAR 0 2
64113: PPUSH
64114: LD_INT 0
64116: PPUSH
64117: CALL 61683 0 3
64121: PPUSH
64122: LD_INT 30
64124: PUSH
64125: LD_INT 3
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: PPUSH
64132: CALL_OW 72
64136: ST_TO_ADDR
// if not factories then
64137: LD_VAR 0 6
64141: NOT
64142: IFFALSE 64146
// exit ;
64144: GO 65112
// for i in factories do
64146: LD_ADDR_VAR 0 8
64150: PUSH
64151: LD_VAR 0 6
64155: PUSH
64156: FOR_IN
64157: IFFALSE 64182
// fac_list := fac_list union AvailableWeaponList ( i ) ;
64159: LD_ADDR_VAR 0 17
64163: PUSH
64164: LD_VAR 0 17
64168: PUSH
64169: LD_VAR 0 8
64173: PPUSH
64174: CALL_OW 478
64178: UNION
64179: ST_TO_ADDR
64180: GO 64156
64182: POP
64183: POP
// if not fac_list then
64184: LD_VAR 0 17
64188: NOT
64189: IFFALSE 64193
// exit ;
64191: GO 65112
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
64193: LD_ADDR_VAR 0 5
64197: PUSH
64198: LD_INT 4
64200: PUSH
64201: LD_INT 5
64203: PUSH
64204: LD_INT 9
64206: PUSH
64207: LD_INT 10
64209: PUSH
64210: LD_INT 6
64212: PUSH
64213: LD_INT 7
64215: PUSH
64216: LD_INT 11
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: PUSH
64228: LD_INT 27
64230: PUSH
64231: LD_INT 28
64233: PUSH
64234: LD_INT 26
64236: PUSH
64237: LD_INT 30
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 43
64248: PUSH
64249: LD_INT 44
64251: PUSH
64252: LD_INT 46
64254: PUSH
64255: LD_INT 45
64257: PUSH
64258: LD_INT 47
64260: PUSH
64261: LD_INT 49
64263: PUSH
64264: EMPTY
64265: LIST
64266: LIST
64267: LIST
64268: LIST
64269: LIST
64270: LIST
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: LIST
64276: PUSH
64277: LD_VAR 0 12
64281: ARRAY
64282: ST_TO_ADDR
// list := list isect fac_list ;
64283: LD_ADDR_VAR 0 5
64287: PUSH
64288: LD_VAR 0 5
64292: PUSH
64293: LD_VAR 0 17
64297: ISECT
64298: ST_TO_ADDR
// if not list then
64299: LD_VAR 0 5
64303: NOT
64304: IFFALSE 64308
// exit ;
64306: GO 65112
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
64308: LD_VAR 0 12
64312: PUSH
64313: LD_INT 3
64315: EQUAL
64316: PUSH
64317: LD_INT 49
64319: PUSH
64320: LD_VAR 0 5
64324: IN
64325: AND
64326: PUSH
64327: LD_INT 31
64329: PPUSH
64330: LD_VAR 0 16
64334: PPUSH
64335: CALL_OW 321
64339: PUSH
64340: LD_INT 2
64342: EQUAL
64343: AND
64344: IFFALSE 64404
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
64346: LD_INT 22
64348: PUSH
64349: LD_VAR 0 16
64353: PUSH
64354: EMPTY
64355: LIST
64356: LIST
64357: PUSH
64358: LD_INT 35
64360: PUSH
64361: LD_INT 49
64363: PUSH
64364: EMPTY
64365: LIST
64366: LIST
64367: PUSH
64368: LD_INT 91
64370: PUSH
64371: LD_VAR 0 1
64375: PUSH
64376: LD_INT 10
64378: PUSH
64379: EMPTY
64380: LIST
64381: LIST
64382: LIST
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: LIST
64388: PPUSH
64389: CALL_OW 69
64393: NOT
64394: IFFALSE 64404
// weapon := ru_time_lapser ;
64396: LD_ADDR_VAR 0 18
64400: PUSH
64401: LD_INT 49
64403: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
64404: LD_VAR 0 12
64408: PUSH
64409: LD_INT 1
64411: PUSH
64412: LD_INT 2
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: IN
64419: PUSH
64420: LD_INT 11
64422: PUSH
64423: LD_VAR 0 5
64427: IN
64428: PUSH
64429: LD_INT 30
64431: PUSH
64432: LD_VAR 0 5
64436: IN
64437: OR
64438: AND
64439: PUSH
64440: LD_INT 6
64442: PPUSH
64443: LD_VAR 0 16
64447: PPUSH
64448: CALL_OW 321
64452: PUSH
64453: LD_INT 2
64455: EQUAL
64456: AND
64457: IFFALSE 64622
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
64459: LD_INT 22
64461: PUSH
64462: LD_VAR 0 16
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: PUSH
64471: LD_INT 2
64473: PUSH
64474: LD_INT 35
64476: PUSH
64477: LD_INT 11
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: PUSH
64484: LD_INT 35
64486: PUSH
64487: LD_INT 30
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: LIST
64498: PUSH
64499: LD_INT 91
64501: PUSH
64502: LD_VAR 0 1
64506: PUSH
64507: LD_INT 18
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: LIST
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: LIST
64519: PPUSH
64520: CALL_OW 69
64524: NOT
64525: PUSH
64526: LD_INT 22
64528: PUSH
64529: LD_VAR 0 16
64533: PUSH
64534: EMPTY
64535: LIST
64536: LIST
64537: PUSH
64538: LD_INT 2
64540: PUSH
64541: LD_INT 30
64543: PUSH
64544: LD_INT 32
64546: PUSH
64547: EMPTY
64548: LIST
64549: LIST
64550: PUSH
64551: LD_INT 30
64553: PUSH
64554: LD_INT 33
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: EMPTY
64562: LIST
64563: LIST
64564: LIST
64565: PUSH
64566: LD_INT 91
64568: PUSH
64569: LD_VAR 0 1
64573: PUSH
64574: LD_INT 12
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: LIST
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: LIST
64586: PUSH
64587: EMPTY
64588: LIST
64589: PPUSH
64590: CALL_OW 69
64594: PUSH
64595: LD_INT 2
64597: GREATER
64598: AND
64599: IFFALSE 64622
// weapon := [ us_radar , ar_radar ] [ nat ] ;
64601: LD_ADDR_VAR 0 18
64605: PUSH
64606: LD_INT 11
64608: PUSH
64609: LD_INT 30
64611: PUSH
64612: EMPTY
64613: LIST
64614: LIST
64615: PUSH
64616: LD_VAR 0 12
64620: ARRAY
64621: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
64622: LD_VAR 0 18
64626: NOT
64627: PUSH
64628: LD_INT 40
64630: PPUSH
64631: LD_VAR 0 16
64635: PPUSH
64636: CALL_OW 321
64640: PUSH
64641: LD_INT 2
64643: EQUAL
64644: AND
64645: PUSH
64646: LD_INT 7
64648: PUSH
64649: LD_VAR 0 5
64653: IN
64654: PUSH
64655: LD_INT 28
64657: PUSH
64658: LD_VAR 0 5
64662: IN
64663: OR
64664: PUSH
64665: LD_INT 45
64667: PUSH
64668: LD_VAR 0 5
64672: IN
64673: OR
64674: AND
64675: IFFALSE 64929
// begin hex := GetHexInfo ( x , y ) ;
64677: LD_ADDR_VAR 0 4
64681: PUSH
64682: LD_VAR 0 10
64686: PPUSH
64687: LD_VAR 0 11
64691: PPUSH
64692: CALL_OW 546
64696: ST_TO_ADDR
// if hex [ 1 ] then
64697: LD_VAR 0 4
64701: PUSH
64702: LD_INT 1
64704: ARRAY
64705: IFFALSE 64709
// exit ;
64707: GO 65112
// height := hex [ 2 ] ;
64709: LD_ADDR_VAR 0 15
64713: PUSH
64714: LD_VAR 0 4
64718: PUSH
64719: LD_INT 2
64721: ARRAY
64722: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
64723: LD_ADDR_VAR 0 14
64727: PUSH
64728: LD_INT 0
64730: PUSH
64731: LD_INT 2
64733: PUSH
64734: LD_INT 3
64736: PUSH
64737: LD_INT 5
64739: PUSH
64740: EMPTY
64741: LIST
64742: LIST
64743: LIST
64744: LIST
64745: ST_TO_ADDR
// for i in tmp do
64746: LD_ADDR_VAR 0 8
64750: PUSH
64751: LD_VAR 0 14
64755: PUSH
64756: FOR_IN
64757: IFFALSE 64927
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
64759: LD_ADDR_VAR 0 9
64763: PUSH
64764: LD_VAR 0 10
64768: PPUSH
64769: LD_VAR 0 8
64773: PPUSH
64774: LD_INT 5
64776: PPUSH
64777: CALL_OW 272
64781: PUSH
64782: LD_VAR 0 11
64786: PPUSH
64787: LD_VAR 0 8
64791: PPUSH
64792: LD_INT 5
64794: PPUSH
64795: CALL_OW 273
64799: PUSH
64800: EMPTY
64801: LIST
64802: LIST
64803: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
64804: LD_VAR 0 9
64808: PUSH
64809: LD_INT 1
64811: ARRAY
64812: PPUSH
64813: LD_VAR 0 9
64817: PUSH
64818: LD_INT 2
64820: ARRAY
64821: PPUSH
64822: CALL_OW 488
64826: IFFALSE 64925
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
64828: LD_ADDR_VAR 0 4
64832: PUSH
64833: LD_VAR 0 9
64837: PUSH
64838: LD_INT 1
64840: ARRAY
64841: PPUSH
64842: LD_VAR 0 9
64846: PUSH
64847: LD_INT 2
64849: ARRAY
64850: PPUSH
64851: CALL_OW 546
64855: ST_TO_ADDR
// if hex [ 1 ] then
64856: LD_VAR 0 4
64860: PUSH
64861: LD_INT 1
64863: ARRAY
64864: IFFALSE 64868
// continue ;
64866: GO 64756
// h := hex [ 2 ] ;
64868: LD_ADDR_VAR 0 13
64872: PUSH
64873: LD_VAR 0 4
64877: PUSH
64878: LD_INT 2
64880: ARRAY
64881: ST_TO_ADDR
// if h + 7 < height then
64882: LD_VAR 0 13
64886: PUSH
64887: LD_INT 7
64889: PLUS
64890: PUSH
64891: LD_VAR 0 15
64895: LESS
64896: IFFALSE 64925
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
64898: LD_ADDR_VAR 0 18
64902: PUSH
64903: LD_INT 7
64905: PUSH
64906: LD_INT 28
64908: PUSH
64909: LD_INT 45
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: LIST
64916: PUSH
64917: LD_VAR 0 12
64921: ARRAY
64922: ST_TO_ADDR
// break ;
64923: GO 64927
// end ; end ; end ;
64925: GO 64756
64927: POP
64928: POP
// end ; if not weapon then
64929: LD_VAR 0 18
64933: NOT
64934: IFFALSE 64994
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
64936: LD_ADDR_VAR 0 5
64940: PUSH
64941: LD_VAR 0 5
64945: PUSH
64946: LD_INT 11
64948: PUSH
64949: LD_INT 30
64951: PUSH
64952: LD_INT 49
64954: PUSH
64955: EMPTY
64956: LIST
64957: LIST
64958: LIST
64959: DIFF
64960: ST_TO_ADDR
// if not list then
64961: LD_VAR 0 5
64965: NOT
64966: IFFALSE 64970
// exit ;
64968: GO 65112
// weapon := list [ rand ( 1 , list ) ] ;
64970: LD_ADDR_VAR 0 18
64974: PUSH
64975: LD_VAR 0 5
64979: PUSH
64980: LD_INT 1
64982: PPUSH
64983: LD_VAR 0 5
64987: PPUSH
64988: CALL_OW 12
64992: ARRAY
64993: ST_TO_ADDR
// end ; if weapon then
64994: LD_VAR 0 18
64998: IFFALSE 65112
// begin tmp := CostOfWeapon ( weapon ) ;
65000: LD_ADDR_VAR 0 14
65004: PUSH
65005: LD_VAR 0 18
65009: PPUSH
65010: CALL_OW 451
65014: ST_TO_ADDR
// j := GetBase ( tower ) ;
65015: LD_ADDR_VAR 0 9
65019: PUSH
65020: LD_VAR 0 1
65024: PPUSH
65025: CALL_OW 274
65029: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
65030: LD_VAR 0 9
65034: PPUSH
65035: LD_INT 1
65037: PPUSH
65038: CALL_OW 275
65042: PUSH
65043: LD_VAR 0 14
65047: PUSH
65048: LD_INT 1
65050: ARRAY
65051: GREATEREQUAL
65052: PUSH
65053: LD_VAR 0 9
65057: PPUSH
65058: LD_INT 2
65060: PPUSH
65061: CALL_OW 275
65065: PUSH
65066: LD_VAR 0 14
65070: PUSH
65071: LD_INT 2
65073: ARRAY
65074: GREATEREQUAL
65075: AND
65076: PUSH
65077: LD_VAR 0 9
65081: PPUSH
65082: LD_INT 3
65084: PPUSH
65085: CALL_OW 275
65089: PUSH
65090: LD_VAR 0 14
65094: PUSH
65095: LD_INT 3
65097: ARRAY
65098: GREATEREQUAL
65099: AND
65100: IFFALSE 65112
// result := weapon ;
65102: LD_ADDR_VAR 0 3
65106: PUSH
65107: LD_VAR 0 18
65111: ST_TO_ADDR
// end ; end ;
65112: LD_VAR 0 3
65116: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
65117: LD_INT 0
65119: PPUSH
65120: PPUSH
// result := true ;
65121: LD_ADDR_VAR 0 3
65125: PUSH
65126: LD_INT 1
65128: ST_TO_ADDR
// if array1 = array2 then
65129: LD_VAR 0 1
65133: PUSH
65134: LD_VAR 0 2
65138: EQUAL
65139: IFFALSE 65199
// begin for i = 1 to array1 do
65141: LD_ADDR_VAR 0 4
65145: PUSH
65146: DOUBLE
65147: LD_INT 1
65149: DEC
65150: ST_TO_ADDR
65151: LD_VAR 0 1
65155: PUSH
65156: FOR_TO
65157: IFFALSE 65195
// if array1 [ i ] <> array2 [ i ] then
65159: LD_VAR 0 1
65163: PUSH
65164: LD_VAR 0 4
65168: ARRAY
65169: PUSH
65170: LD_VAR 0 2
65174: PUSH
65175: LD_VAR 0 4
65179: ARRAY
65180: NONEQUAL
65181: IFFALSE 65193
// begin result := false ;
65183: LD_ADDR_VAR 0 3
65187: PUSH
65188: LD_INT 0
65190: ST_TO_ADDR
// break ;
65191: GO 65195
// end ;
65193: GO 65156
65195: POP
65196: POP
// end else
65197: GO 65207
// result := false ;
65199: LD_ADDR_VAR 0 3
65203: PUSH
65204: LD_INT 0
65206: ST_TO_ADDR
// end ;
65207: LD_VAR 0 3
65211: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
65212: LD_INT 0
65214: PPUSH
65215: PPUSH
// if not array1 or not array2 then
65216: LD_VAR 0 1
65220: NOT
65221: PUSH
65222: LD_VAR 0 2
65226: NOT
65227: OR
65228: IFFALSE 65232
// exit ;
65230: GO 65296
// result := true ;
65232: LD_ADDR_VAR 0 3
65236: PUSH
65237: LD_INT 1
65239: ST_TO_ADDR
// for i = 1 to array1 do
65240: LD_ADDR_VAR 0 4
65244: PUSH
65245: DOUBLE
65246: LD_INT 1
65248: DEC
65249: ST_TO_ADDR
65250: LD_VAR 0 1
65254: PUSH
65255: FOR_TO
65256: IFFALSE 65294
// if array1 [ i ] <> array2 [ i ] then
65258: LD_VAR 0 1
65262: PUSH
65263: LD_VAR 0 4
65267: ARRAY
65268: PUSH
65269: LD_VAR 0 2
65273: PUSH
65274: LD_VAR 0 4
65278: ARRAY
65279: NONEQUAL
65280: IFFALSE 65292
// begin result := false ;
65282: LD_ADDR_VAR 0 3
65286: PUSH
65287: LD_INT 0
65289: ST_TO_ADDR
// break ;
65290: GO 65294
// end ;
65292: GO 65255
65294: POP
65295: POP
// end ;
65296: LD_VAR 0 3
65300: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
65301: LD_INT 0
65303: PPUSH
65304: PPUSH
65305: PPUSH
// pom := GetBase ( fac ) ;
65306: LD_ADDR_VAR 0 5
65310: PUSH
65311: LD_VAR 0 1
65315: PPUSH
65316: CALL_OW 274
65320: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
65321: LD_ADDR_VAR 0 4
65325: PUSH
65326: LD_VAR 0 2
65330: PUSH
65331: LD_INT 1
65333: ARRAY
65334: PPUSH
65335: LD_VAR 0 2
65339: PUSH
65340: LD_INT 2
65342: ARRAY
65343: PPUSH
65344: LD_VAR 0 2
65348: PUSH
65349: LD_INT 3
65351: ARRAY
65352: PPUSH
65353: LD_VAR 0 2
65357: PUSH
65358: LD_INT 4
65360: ARRAY
65361: PPUSH
65362: CALL_OW 449
65366: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65367: LD_ADDR_VAR 0 3
65371: PUSH
65372: LD_VAR 0 5
65376: PPUSH
65377: LD_INT 1
65379: PPUSH
65380: CALL_OW 275
65384: PUSH
65385: LD_VAR 0 4
65389: PUSH
65390: LD_INT 1
65392: ARRAY
65393: GREATEREQUAL
65394: PUSH
65395: LD_VAR 0 5
65399: PPUSH
65400: LD_INT 2
65402: PPUSH
65403: CALL_OW 275
65407: PUSH
65408: LD_VAR 0 4
65412: PUSH
65413: LD_INT 2
65415: ARRAY
65416: GREATEREQUAL
65417: AND
65418: PUSH
65419: LD_VAR 0 5
65423: PPUSH
65424: LD_INT 3
65426: PPUSH
65427: CALL_OW 275
65431: PUSH
65432: LD_VAR 0 4
65436: PUSH
65437: LD_INT 3
65439: ARRAY
65440: GREATEREQUAL
65441: AND
65442: ST_TO_ADDR
// end ;
65443: LD_VAR 0 3
65447: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
65448: LD_INT 0
65450: PPUSH
65451: PPUSH
65452: PPUSH
65453: PPUSH
// pom := GetBase ( building ) ;
65454: LD_ADDR_VAR 0 3
65458: PUSH
65459: LD_VAR 0 1
65463: PPUSH
65464: CALL_OW 274
65468: ST_TO_ADDR
// if not pom then
65469: LD_VAR 0 3
65473: NOT
65474: IFFALSE 65478
// exit ;
65476: GO 65648
// btype := GetBType ( building ) ;
65478: LD_ADDR_VAR 0 5
65482: PUSH
65483: LD_VAR 0 1
65487: PPUSH
65488: CALL_OW 266
65492: ST_TO_ADDR
// if btype = b_armoury then
65493: LD_VAR 0 5
65497: PUSH
65498: LD_INT 4
65500: EQUAL
65501: IFFALSE 65511
// btype := b_barracks ;
65503: LD_ADDR_VAR 0 5
65507: PUSH
65508: LD_INT 5
65510: ST_TO_ADDR
// if btype = b_depot then
65511: LD_VAR 0 5
65515: PUSH
65516: LD_INT 0
65518: EQUAL
65519: IFFALSE 65529
// btype := b_warehouse ;
65521: LD_ADDR_VAR 0 5
65525: PUSH
65526: LD_INT 1
65528: ST_TO_ADDR
// if btype = b_workshop then
65529: LD_VAR 0 5
65533: PUSH
65534: LD_INT 2
65536: EQUAL
65537: IFFALSE 65547
// btype := b_factory ;
65539: LD_ADDR_VAR 0 5
65543: PUSH
65544: LD_INT 3
65546: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65547: LD_ADDR_VAR 0 4
65551: PUSH
65552: LD_VAR 0 5
65556: PPUSH
65557: LD_VAR 0 1
65561: PPUSH
65562: CALL_OW 248
65566: PPUSH
65567: CALL_OW 450
65571: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65572: LD_ADDR_VAR 0 2
65576: PUSH
65577: LD_VAR 0 3
65581: PPUSH
65582: LD_INT 1
65584: PPUSH
65585: CALL_OW 275
65589: PUSH
65590: LD_VAR 0 4
65594: PUSH
65595: LD_INT 1
65597: ARRAY
65598: GREATEREQUAL
65599: PUSH
65600: LD_VAR 0 3
65604: PPUSH
65605: LD_INT 2
65607: PPUSH
65608: CALL_OW 275
65612: PUSH
65613: LD_VAR 0 4
65617: PUSH
65618: LD_INT 2
65620: ARRAY
65621: GREATEREQUAL
65622: AND
65623: PUSH
65624: LD_VAR 0 3
65628: PPUSH
65629: LD_INT 3
65631: PPUSH
65632: CALL_OW 275
65636: PUSH
65637: LD_VAR 0 4
65641: PUSH
65642: LD_INT 3
65644: ARRAY
65645: GREATEREQUAL
65646: AND
65647: ST_TO_ADDR
// end ;
65648: LD_VAR 0 2
65652: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
65653: LD_INT 0
65655: PPUSH
65656: PPUSH
65657: PPUSH
// pom := GetBase ( building ) ;
65658: LD_ADDR_VAR 0 4
65662: PUSH
65663: LD_VAR 0 1
65667: PPUSH
65668: CALL_OW 274
65672: ST_TO_ADDR
// if not pom then
65673: LD_VAR 0 4
65677: NOT
65678: IFFALSE 65682
// exit ;
65680: GO 65783
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65682: LD_ADDR_VAR 0 5
65686: PUSH
65687: LD_VAR 0 2
65691: PPUSH
65692: LD_VAR 0 1
65696: PPUSH
65697: CALL_OW 248
65701: PPUSH
65702: CALL_OW 450
65706: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65707: LD_ADDR_VAR 0 3
65711: PUSH
65712: LD_VAR 0 4
65716: PPUSH
65717: LD_INT 1
65719: PPUSH
65720: CALL_OW 275
65724: PUSH
65725: LD_VAR 0 5
65729: PUSH
65730: LD_INT 1
65732: ARRAY
65733: GREATEREQUAL
65734: PUSH
65735: LD_VAR 0 4
65739: PPUSH
65740: LD_INT 2
65742: PPUSH
65743: CALL_OW 275
65747: PUSH
65748: LD_VAR 0 5
65752: PUSH
65753: LD_INT 2
65755: ARRAY
65756: GREATEREQUAL
65757: AND
65758: PUSH
65759: LD_VAR 0 4
65763: PPUSH
65764: LD_INT 3
65766: PPUSH
65767: CALL_OW 275
65771: PUSH
65772: LD_VAR 0 5
65776: PUSH
65777: LD_INT 3
65779: ARRAY
65780: GREATEREQUAL
65781: AND
65782: ST_TO_ADDR
// end ;
65783: LD_VAR 0 3
65787: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
65788: LD_INT 0
65790: PPUSH
65791: PPUSH
65792: PPUSH
65793: PPUSH
65794: PPUSH
65795: PPUSH
65796: PPUSH
65797: PPUSH
65798: PPUSH
65799: PPUSH
65800: PPUSH
// result := false ;
65801: LD_ADDR_VAR 0 8
65805: PUSH
65806: LD_INT 0
65808: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
65809: LD_VAR 0 5
65813: NOT
65814: PUSH
65815: LD_VAR 0 1
65819: NOT
65820: OR
65821: PUSH
65822: LD_VAR 0 2
65826: NOT
65827: OR
65828: PUSH
65829: LD_VAR 0 3
65833: NOT
65834: OR
65835: IFFALSE 65839
// exit ;
65837: GO 66653
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
65839: LD_ADDR_VAR 0 14
65843: PUSH
65844: LD_VAR 0 1
65848: PPUSH
65849: LD_VAR 0 2
65853: PPUSH
65854: LD_VAR 0 3
65858: PPUSH
65859: LD_VAR 0 4
65863: PPUSH
65864: LD_VAR 0 5
65868: PUSH
65869: LD_INT 1
65871: ARRAY
65872: PPUSH
65873: CALL_OW 248
65877: PPUSH
65878: LD_INT 0
65880: PPUSH
65881: CALL 67906 0 6
65885: ST_TO_ADDR
// if not hexes then
65886: LD_VAR 0 14
65890: NOT
65891: IFFALSE 65895
// exit ;
65893: GO 66653
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
65895: LD_ADDR_VAR 0 17
65899: PUSH
65900: LD_VAR 0 5
65904: PPUSH
65905: LD_INT 22
65907: PUSH
65908: LD_VAR 0 13
65912: PPUSH
65913: CALL_OW 255
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 2
65924: PUSH
65925: LD_INT 30
65927: PUSH
65928: LD_INT 0
65930: PUSH
65931: EMPTY
65932: LIST
65933: LIST
65934: PUSH
65935: LD_INT 30
65937: PUSH
65938: LD_INT 1
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: EMPTY
65946: LIST
65947: LIST
65948: LIST
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PPUSH
65954: CALL_OW 72
65958: ST_TO_ADDR
// for i = 1 to hexes do
65959: LD_ADDR_VAR 0 9
65963: PUSH
65964: DOUBLE
65965: LD_INT 1
65967: DEC
65968: ST_TO_ADDR
65969: LD_VAR 0 14
65973: PUSH
65974: FOR_TO
65975: IFFALSE 66651
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65977: LD_ADDR_VAR 0 13
65981: PUSH
65982: LD_VAR 0 14
65986: PUSH
65987: LD_VAR 0 9
65991: ARRAY
65992: PUSH
65993: LD_INT 1
65995: ARRAY
65996: PPUSH
65997: LD_VAR 0 14
66001: PUSH
66002: LD_VAR 0 9
66006: ARRAY
66007: PUSH
66008: LD_INT 2
66010: ARRAY
66011: PPUSH
66012: CALL_OW 428
66016: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
66017: LD_VAR 0 14
66021: PUSH
66022: LD_VAR 0 9
66026: ARRAY
66027: PUSH
66028: LD_INT 1
66030: ARRAY
66031: PPUSH
66032: LD_VAR 0 14
66036: PUSH
66037: LD_VAR 0 9
66041: ARRAY
66042: PUSH
66043: LD_INT 2
66045: ARRAY
66046: PPUSH
66047: CALL_OW 351
66051: PUSH
66052: LD_VAR 0 14
66056: PUSH
66057: LD_VAR 0 9
66061: ARRAY
66062: PUSH
66063: LD_INT 1
66065: ARRAY
66066: PPUSH
66067: LD_VAR 0 14
66071: PUSH
66072: LD_VAR 0 9
66076: ARRAY
66077: PUSH
66078: LD_INT 2
66080: ARRAY
66081: PPUSH
66082: CALL_OW 488
66086: NOT
66087: OR
66088: PUSH
66089: LD_VAR 0 13
66093: PPUSH
66094: CALL_OW 247
66098: PUSH
66099: LD_INT 3
66101: EQUAL
66102: OR
66103: IFFALSE 66109
// exit ;
66105: POP
66106: POP
66107: GO 66653
// if not tmp then
66109: LD_VAR 0 13
66113: NOT
66114: IFFALSE 66118
// continue ;
66116: GO 65974
// result := true ;
66118: LD_ADDR_VAR 0 8
66122: PUSH
66123: LD_INT 1
66125: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
66126: LD_VAR 0 6
66130: PUSH
66131: LD_VAR 0 13
66135: PPUSH
66136: CALL_OW 247
66140: PUSH
66141: LD_INT 2
66143: EQUAL
66144: AND
66145: PUSH
66146: LD_VAR 0 13
66150: PPUSH
66151: CALL_OW 263
66155: PUSH
66156: LD_INT 1
66158: EQUAL
66159: AND
66160: IFFALSE 66324
// begin if IsDrivenBy ( tmp ) then
66162: LD_VAR 0 13
66166: PPUSH
66167: CALL_OW 311
66171: IFFALSE 66175
// continue ;
66173: GO 65974
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
66175: LD_VAR 0 6
66179: PPUSH
66180: LD_INT 3
66182: PUSH
66183: LD_INT 60
66185: PUSH
66186: EMPTY
66187: LIST
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PUSH
66193: LD_INT 3
66195: PUSH
66196: LD_INT 55
66198: PUSH
66199: EMPTY
66200: LIST
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: PPUSH
66210: CALL_OW 72
66214: IFFALSE 66322
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
66216: LD_ADDR_VAR 0 18
66220: PUSH
66221: LD_VAR 0 6
66225: PPUSH
66226: LD_INT 3
66228: PUSH
66229: LD_INT 60
66231: PUSH
66232: EMPTY
66233: LIST
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: LD_INT 3
66241: PUSH
66242: LD_INT 55
66244: PUSH
66245: EMPTY
66246: LIST
66247: PUSH
66248: EMPTY
66249: LIST
66250: LIST
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PPUSH
66256: CALL_OW 72
66260: PUSH
66261: LD_INT 1
66263: ARRAY
66264: ST_TO_ADDR
// if IsInUnit ( driver ) then
66265: LD_VAR 0 18
66269: PPUSH
66270: CALL_OW 310
66274: IFFALSE 66285
// ComExit ( driver ) ;
66276: LD_VAR 0 18
66280: PPUSH
66281: CALL 91707 0 1
// AddComEnterUnit ( driver , tmp ) ;
66285: LD_VAR 0 18
66289: PPUSH
66290: LD_VAR 0 13
66294: PPUSH
66295: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
66299: LD_VAR 0 18
66303: PPUSH
66304: LD_VAR 0 7
66308: PPUSH
66309: CALL_OW 173
// AddComExitVehicle ( driver ) ;
66313: LD_VAR 0 18
66317: PPUSH
66318: CALL_OW 181
// end ; continue ;
66322: GO 65974
// end ; if not cleaners or not tmp in cleaners then
66324: LD_VAR 0 6
66328: NOT
66329: PUSH
66330: LD_VAR 0 13
66334: PUSH
66335: LD_VAR 0 6
66339: IN
66340: NOT
66341: OR
66342: IFFALSE 66649
// begin if dep then
66344: LD_VAR 0 17
66348: IFFALSE 66484
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
66350: LD_ADDR_VAR 0 16
66354: PUSH
66355: LD_VAR 0 17
66359: PUSH
66360: LD_INT 1
66362: ARRAY
66363: PPUSH
66364: CALL_OW 250
66368: PPUSH
66369: LD_VAR 0 17
66373: PUSH
66374: LD_INT 1
66376: ARRAY
66377: PPUSH
66378: CALL_OW 254
66382: PPUSH
66383: LD_INT 5
66385: PPUSH
66386: CALL_OW 272
66390: PUSH
66391: LD_VAR 0 17
66395: PUSH
66396: LD_INT 1
66398: ARRAY
66399: PPUSH
66400: CALL_OW 251
66404: PPUSH
66405: LD_VAR 0 17
66409: PUSH
66410: LD_INT 1
66412: ARRAY
66413: PPUSH
66414: CALL_OW 254
66418: PPUSH
66419: LD_INT 5
66421: PPUSH
66422: CALL_OW 273
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
66431: LD_VAR 0 16
66435: PUSH
66436: LD_INT 1
66438: ARRAY
66439: PPUSH
66440: LD_VAR 0 16
66444: PUSH
66445: LD_INT 2
66447: ARRAY
66448: PPUSH
66449: CALL_OW 488
66453: IFFALSE 66484
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
66455: LD_VAR 0 13
66459: PPUSH
66460: LD_VAR 0 16
66464: PUSH
66465: LD_INT 1
66467: ARRAY
66468: PPUSH
66469: LD_VAR 0 16
66473: PUSH
66474: LD_INT 2
66476: ARRAY
66477: PPUSH
66478: CALL_OW 111
// continue ;
66482: GO 65974
// end ; end ; r := GetDir ( tmp ) ;
66484: LD_ADDR_VAR 0 15
66488: PUSH
66489: LD_VAR 0 13
66493: PPUSH
66494: CALL_OW 254
66498: ST_TO_ADDR
// if r = 5 then
66499: LD_VAR 0 15
66503: PUSH
66504: LD_INT 5
66506: EQUAL
66507: IFFALSE 66517
// r := 0 ;
66509: LD_ADDR_VAR 0 15
66513: PUSH
66514: LD_INT 0
66516: ST_TO_ADDR
// for j = r to 5 do
66517: LD_ADDR_VAR 0 10
66521: PUSH
66522: DOUBLE
66523: LD_VAR 0 15
66527: DEC
66528: ST_TO_ADDR
66529: LD_INT 5
66531: PUSH
66532: FOR_TO
66533: IFFALSE 66647
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
66535: LD_ADDR_VAR 0 11
66539: PUSH
66540: LD_VAR 0 13
66544: PPUSH
66545: CALL_OW 250
66549: PPUSH
66550: LD_VAR 0 10
66554: PPUSH
66555: LD_INT 2
66557: PPUSH
66558: CALL_OW 272
66562: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
66563: LD_ADDR_VAR 0 12
66567: PUSH
66568: LD_VAR 0 13
66572: PPUSH
66573: CALL_OW 251
66577: PPUSH
66578: LD_VAR 0 10
66582: PPUSH
66583: LD_INT 2
66585: PPUSH
66586: CALL_OW 273
66590: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
66591: LD_VAR 0 11
66595: PPUSH
66596: LD_VAR 0 12
66600: PPUSH
66601: CALL_OW 488
66605: PUSH
66606: LD_VAR 0 11
66610: PPUSH
66611: LD_VAR 0 12
66615: PPUSH
66616: CALL_OW 428
66620: NOT
66621: AND
66622: IFFALSE 66645
// begin ComMoveXY ( tmp , _x , _y ) ;
66624: LD_VAR 0 13
66628: PPUSH
66629: LD_VAR 0 11
66633: PPUSH
66634: LD_VAR 0 12
66638: PPUSH
66639: CALL_OW 111
// break ;
66643: GO 66647
// end ; end ;
66645: GO 66532
66647: POP
66648: POP
// end ; end ;
66649: GO 65974
66651: POP
66652: POP
// end ;
66653: LD_VAR 0 8
66657: RET
// export function BuildingTechInvented ( side , btype ) ; begin
66658: LD_INT 0
66660: PPUSH
// result := true ;
66661: LD_ADDR_VAR 0 3
66665: PUSH
66666: LD_INT 1
66668: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
66669: LD_VAR 0 2
66673: PUSH
66674: LD_INT 24
66676: DOUBLE
66677: EQUAL
66678: IFTRUE 66688
66680: LD_INT 33
66682: DOUBLE
66683: EQUAL
66684: IFTRUE 66688
66686: GO 66713
66688: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
66689: LD_ADDR_VAR 0 3
66693: PUSH
66694: LD_INT 32
66696: PPUSH
66697: LD_VAR 0 1
66701: PPUSH
66702: CALL_OW 321
66706: PUSH
66707: LD_INT 2
66709: EQUAL
66710: ST_TO_ADDR
66711: GO 67029
66713: LD_INT 20
66715: DOUBLE
66716: EQUAL
66717: IFTRUE 66721
66719: GO 66746
66721: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
66722: LD_ADDR_VAR 0 3
66726: PUSH
66727: LD_INT 6
66729: PPUSH
66730: LD_VAR 0 1
66734: PPUSH
66735: CALL_OW 321
66739: PUSH
66740: LD_INT 2
66742: EQUAL
66743: ST_TO_ADDR
66744: GO 67029
66746: LD_INT 22
66748: DOUBLE
66749: EQUAL
66750: IFTRUE 66760
66752: LD_INT 36
66754: DOUBLE
66755: EQUAL
66756: IFTRUE 66760
66758: GO 66785
66760: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
66761: LD_ADDR_VAR 0 3
66765: PUSH
66766: LD_INT 15
66768: PPUSH
66769: LD_VAR 0 1
66773: PPUSH
66774: CALL_OW 321
66778: PUSH
66779: LD_INT 2
66781: EQUAL
66782: ST_TO_ADDR
66783: GO 67029
66785: LD_INT 30
66787: DOUBLE
66788: EQUAL
66789: IFTRUE 66793
66791: GO 66818
66793: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
66794: LD_ADDR_VAR 0 3
66798: PUSH
66799: LD_INT 20
66801: PPUSH
66802: LD_VAR 0 1
66806: PPUSH
66807: CALL_OW 321
66811: PUSH
66812: LD_INT 2
66814: EQUAL
66815: ST_TO_ADDR
66816: GO 67029
66818: LD_INT 28
66820: DOUBLE
66821: EQUAL
66822: IFTRUE 66832
66824: LD_INT 21
66826: DOUBLE
66827: EQUAL
66828: IFTRUE 66832
66830: GO 66857
66832: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
66833: LD_ADDR_VAR 0 3
66837: PUSH
66838: LD_INT 21
66840: PPUSH
66841: LD_VAR 0 1
66845: PPUSH
66846: CALL_OW 321
66850: PUSH
66851: LD_INT 2
66853: EQUAL
66854: ST_TO_ADDR
66855: GO 67029
66857: LD_INT 16
66859: DOUBLE
66860: EQUAL
66861: IFTRUE 66865
66863: GO 66890
66865: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
66866: LD_ADDR_VAR 0 3
66870: PUSH
66871: LD_INT 84
66873: PPUSH
66874: LD_VAR 0 1
66878: PPUSH
66879: CALL_OW 321
66883: PUSH
66884: LD_INT 2
66886: EQUAL
66887: ST_TO_ADDR
66888: GO 67029
66890: LD_INT 19
66892: DOUBLE
66893: EQUAL
66894: IFTRUE 66904
66896: LD_INT 23
66898: DOUBLE
66899: EQUAL
66900: IFTRUE 66904
66902: GO 66929
66904: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
66905: LD_ADDR_VAR 0 3
66909: PUSH
66910: LD_INT 83
66912: PPUSH
66913: LD_VAR 0 1
66917: PPUSH
66918: CALL_OW 321
66922: PUSH
66923: LD_INT 2
66925: EQUAL
66926: ST_TO_ADDR
66927: GO 67029
66929: LD_INT 17
66931: DOUBLE
66932: EQUAL
66933: IFTRUE 66937
66935: GO 66962
66937: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
66938: LD_ADDR_VAR 0 3
66942: PUSH
66943: LD_INT 39
66945: PPUSH
66946: LD_VAR 0 1
66950: PPUSH
66951: CALL_OW 321
66955: PUSH
66956: LD_INT 2
66958: EQUAL
66959: ST_TO_ADDR
66960: GO 67029
66962: LD_INT 18
66964: DOUBLE
66965: EQUAL
66966: IFTRUE 66970
66968: GO 66995
66970: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
66971: LD_ADDR_VAR 0 3
66975: PUSH
66976: LD_INT 40
66978: PPUSH
66979: LD_VAR 0 1
66983: PPUSH
66984: CALL_OW 321
66988: PUSH
66989: LD_INT 2
66991: EQUAL
66992: ST_TO_ADDR
66993: GO 67029
66995: LD_INT 27
66997: DOUBLE
66998: EQUAL
66999: IFTRUE 67003
67001: GO 67028
67003: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
67004: LD_ADDR_VAR 0 3
67008: PUSH
67009: LD_INT 35
67011: PPUSH
67012: LD_VAR 0 1
67016: PPUSH
67017: CALL_OW 321
67021: PUSH
67022: LD_INT 2
67024: EQUAL
67025: ST_TO_ADDR
67026: GO 67029
67028: POP
// end ;
67029: LD_VAR 0 3
67033: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
67034: LD_INT 0
67036: PPUSH
67037: PPUSH
67038: PPUSH
67039: PPUSH
67040: PPUSH
67041: PPUSH
67042: PPUSH
67043: PPUSH
67044: PPUSH
67045: PPUSH
67046: PPUSH
// result := false ;
67047: LD_ADDR_VAR 0 6
67051: PUSH
67052: LD_INT 0
67054: ST_TO_ADDR
// if btype = b_depot then
67055: LD_VAR 0 2
67059: PUSH
67060: LD_INT 0
67062: EQUAL
67063: IFFALSE 67075
// begin result := true ;
67065: LD_ADDR_VAR 0 6
67069: PUSH
67070: LD_INT 1
67072: ST_TO_ADDR
// exit ;
67073: GO 67901
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
67075: LD_VAR 0 1
67079: NOT
67080: PUSH
67081: LD_VAR 0 1
67085: PPUSH
67086: CALL_OW 266
67090: PUSH
67091: LD_INT 0
67093: PUSH
67094: LD_INT 1
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: IN
67101: NOT
67102: OR
67103: PUSH
67104: LD_VAR 0 2
67108: NOT
67109: OR
67110: PUSH
67111: LD_VAR 0 5
67115: PUSH
67116: LD_INT 0
67118: PUSH
67119: LD_INT 1
67121: PUSH
67122: LD_INT 2
67124: PUSH
67125: LD_INT 3
67127: PUSH
67128: LD_INT 4
67130: PUSH
67131: LD_INT 5
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: IN
67142: NOT
67143: OR
67144: PUSH
67145: LD_VAR 0 3
67149: PPUSH
67150: LD_VAR 0 4
67154: PPUSH
67155: CALL_OW 488
67159: NOT
67160: OR
67161: IFFALSE 67165
// exit ;
67163: GO 67901
// side := GetSide ( depot ) ;
67165: LD_ADDR_VAR 0 9
67169: PUSH
67170: LD_VAR 0 1
67174: PPUSH
67175: CALL_OW 255
67179: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
67180: LD_VAR 0 9
67184: PPUSH
67185: LD_VAR 0 2
67189: PPUSH
67190: CALL 66658 0 2
67194: NOT
67195: IFFALSE 67199
// exit ;
67197: GO 67901
// pom := GetBase ( depot ) ;
67199: LD_ADDR_VAR 0 10
67203: PUSH
67204: LD_VAR 0 1
67208: PPUSH
67209: CALL_OW 274
67213: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
67214: LD_ADDR_VAR 0 11
67218: PUSH
67219: LD_VAR 0 2
67223: PPUSH
67224: LD_VAR 0 1
67228: PPUSH
67229: CALL_OW 248
67233: PPUSH
67234: CALL_OW 450
67238: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
67239: LD_VAR 0 10
67243: PPUSH
67244: LD_INT 1
67246: PPUSH
67247: CALL_OW 275
67251: PUSH
67252: LD_VAR 0 11
67256: PUSH
67257: LD_INT 1
67259: ARRAY
67260: GREATEREQUAL
67261: PUSH
67262: LD_VAR 0 10
67266: PPUSH
67267: LD_INT 2
67269: PPUSH
67270: CALL_OW 275
67274: PUSH
67275: LD_VAR 0 11
67279: PUSH
67280: LD_INT 2
67282: ARRAY
67283: GREATEREQUAL
67284: AND
67285: PUSH
67286: LD_VAR 0 10
67290: PPUSH
67291: LD_INT 3
67293: PPUSH
67294: CALL_OW 275
67298: PUSH
67299: LD_VAR 0 11
67303: PUSH
67304: LD_INT 3
67306: ARRAY
67307: GREATEREQUAL
67308: AND
67309: NOT
67310: IFFALSE 67314
// exit ;
67312: GO 67901
// if GetBType ( depot ) = b_depot then
67314: LD_VAR 0 1
67318: PPUSH
67319: CALL_OW 266
67323: PUSH
67324: LD_INT 0
67326: EQUAL
67327: IFFALSE 67339
// dist := 28 else
67329: LD_ADDR_VAR 0 14
67333: PUSH
67334: LD_INT 28
67336: ST_TO_ADDR
67337: GO 67347
// dist := 36 ;
67339: LD_ADDR_VAR 0 14
67343: PUSH
67344: LD_INT 36
67346: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
67347: LD_VAR 0 1
67351: PPUSH
67352: LD_VAR 0 3
67356: PPUSH
67357: LD_VAR 0 4
67361: PPUSH
67362: CALL_OW 297
67366: PUSH
67367: LD_VAR 0 14
67371: GREATER
67372: IFFALSE 67376
// exit ;
67374: GO 67901
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
67376: LD_ADDR_VAR 0 12
67380: PUSH
67381: LD_VAR 0 2
67385: PPUSH
67386: LD_VAR 0 3
67390: PPUSH
67391: LD_VAR 0 4
67395: PPUSH
67396: LD_VAR 0 5
67400: PPUSH
67401: LD_VAR 0 1
67405: PPUSH
67406: CALL_OW 248
67410: PPUSH
67411: LD_INT 0
67413: PPUSH
67414: CALL 67906 0 6
67418: ST_TO_ADDR
// if not hexes then
67419: LD_VAR 0 12
67423: NOT
67424: IFFALSE 67428
// exit ;
67426: GO 67901
// hex := GetHexInfo ( x , y ) ;
67428: LD_ADDR_VAR 0 15
67432: PUSH
67433: LD_VAR 0 3
67437: PPUSH
67438: LD_VAR 0 4
67442: PPUSH
67443: CALL_OW 546
67447: ST_TO_ADDR
// if hex [ 1 ] then
67448: LD_VAR 0 15
67452: PUSH
67453: LD_INT 1
67455: ARRAY
67456: IFFALSE 67460
// exit ;
67458: GO 67901
// height := hex [ 2 ] ;
67460: LD_ADDR_VAR 0 13
67464: PUSH
67465: LD_VAR 0 15
67469: PUSH
67470: LD_INT 2
67472: ARRAY
67473: ST_TO_ADDR
// for i = 1 to hexes do
67474: LD_ADDR_VAR 0 7
67478: PUSH
67479: DOUBLE
67480: LD_INT 1
67482: DEC
67483: ST_TO_ADDR
67484: LD_VAR 0 12
67488: PUSH
67489: FOR_TO
67490: IFFALSE 67820
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
67492: LD_VAR 0 12
67496: PUSH
67497: LD_VAR 0 7
67501: ARRAY
67502: PUSH
67503: LD_INT 1
67505: ARRAY
67506: PPUSH
67507: LD_VAR 0 12
67511: PUSH
67512: LD_VAR 0 7
67516: ARRAY
67517: PUSH
67518: LD_INT 2
67520: ARRAY
67521: PPUSH
67522: CALL_OW 488
67526: NOT
67527: PUSH
67528: LD_VAR 0 12
67532: PUSH
67533: LD_VAR 0 7
67537: ARRAY
67538: PUSH
67539: LD_INT 1
67541: ARRAY
67542: PPUSH
67543: LD_VAR 0 12
67547: PUSH
67548: LD_VAR 0 7
67552: ARRAY
67553: PUSH
67554: LD_INT 2
67556: ARRAY
67557: PPUSH
67558: CALL_OW 428
67562: PUSH
67563: LD_INT 0
67565: GREATER
67566: OR
67567: PUSH
67568: LD_VAR 0 12
67572: PUSH
67573: LD_VAR 0 7
67577: ARRAY
67578: PUSH
67579: LD_INT 1
67581: ARRAY
67582: PPUSH
67583: LD_VAR 0 12
67587: PUSH
67588: LD_VAR 0 7
67592: ARRAY
67593: PUSH
67594: LD_INT 2
67596: ARRAY
67597: PPUSH
67598: CALL_OW 351
67602: OR
67603: IFFALSE 67609
// exit ;
67605: POP
67606: POP
67607: GO 67901
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67609: LD_ADDR_VAR 0 8
67613: PUSH
67614: LD_VAR 0 12
67618: PUSH
67619: LD_VAR 0 7
67623: ARRAY
67624: PUSH
67625: LD_INT 1
67627: ARRAY
67628: PPUSH
67629: LD_VAR 0 12
67633: PUSH
67634: LD_VAR 0 7
67638: ARRAY
67639: PUSH
67640: LD_INT 2
67642: ARRAY
67643: PPUSH
67644: CALL_OW 546
67648: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
67649: LD_VAR 0 8
67653: PUSH
67654: LD_INT 1
67656: ARRAY
67657: PUSH
67658: LD_VAR 0 8
67662: PUSH
67663: LD_INT 2
67665: ARRAY
67666: PUSH
67667: LD_VAR 0 13
67671: PUSH
67672: LD_INT 2
67674: PLUS
67675: GREATER
67676: OR
67677: PUSH
67678: LD_VAR 0 8
67682: PUSH
67683: LD_INT 2
67685: ARRAY
67686: PUSH
67687: LD_VAR 0 13
67691: PUSH
67692: LD_INT 2
67694: MINUS
67695: LESS
67696: OR
67697: PUSH
67698: LD_VAR 0 8
67702: PUSH
67703: LD_INT 3
67705: ARRAY
67706: PUSH
67707: LD_INT 0
67709: PUSH
67710: LD_INT 8
67712: PUSH
67713: LD_INT 9
67715: PUSH
67716: LD_INT 10
67718: PUSH
67719: LD_INT 11
67721: PUSH
67722: LD_INT 12
67724: PUSH
67725: LD_INT 13
67727: PUSH
67728: LD_INT 16
67730: PUSH
67731: LD_INT 17
67733: PUSH
67734: LD_INT 18
67736: PUSH
67737: LD_INT 19
67739: PUSH
67740: LD_INT 20
67742: PUSH
67743: LD_INT 21
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: IN
67761: NOT
67762: OR
67763: PUSH
67764: LD_VAR 0 8
67768: PUSH
67769: LD_INT 5
67771: ARRAY
67772: NOT
67773: OR
67774: PUSH
67775: LD_VAR 0 8
67779: PUSH
67780: LD_INT 6
67782: ARRAY
67783: PUSH
67784: LD_INT 1
67786: PUSH
67787: LD_INT 2
67789: PUSH
67790: LD_INT 7
67792: PUSH
67793: LD_INT 9
67795: PUSH
67796: LD_INT 10
67798: PUSH
67799: LD_INT 11
67801: PUSH
67802: EMPTY
67803: LIST
67804: LIST
67805: LIST
67806: LIST
67807: LIST
67808: LIST
67809: IN
67810: NOT
67811: OR
67812: IFFALSE 67818
// exit ;
67814: POP
67815: POP
67816: GO 67901
// end ;
67818: GO 67489
67820: POP
67821: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67822: LD_VAR 0 9
67826: PPUSH
67827: LD_VAR 0 3
67831: PPUSH
67832: LD_VAR 0 4
67836: PPUSH
67837: LD_INT 20
67839: PPUSH
67840: CALL 59824 0 4
67844: PUSH
67845: LD_INT 4
67847: ARRAY
67848: IFFALSE 67852
// exit ;
67850: GO 67901
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
67852: LD_VAR 0 2
67856: PUSH
67857: LD_INT 29
67859: PUSH
67860: LD_INT 30
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: IN
67867: PUSH
67868: LD_VAR 0 3
67872: PPUSH
67873: LD_VAR 0 4
67877: PPUSH
67878: LD_VAR 0 9
67882: PPUSH
67883: CALL_OW 440
67887: NOT
67888: AND
67889: IFFALSE 67893
// exit ;
67891: GO 67901
// result := true ;
67893: LD_ADDR_VAR 0 6
67897: PUSH
67898: LD_INT 1
67900: ST_TO_ADDR
// end ;
67901: LD_VAR 0 6
67905: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
67906: LD_INT 0
67908: PPUSH
67909: PPUSH
67910: PPUSH
67911: PPUSH
67912: PPUSH
67913: PPUSH
67914: PPUSH
67915: PPUSH
67916: PPUSH
67917: PPUSH
67918: PPUSH
67919: PPUSH
67920: PPUSH
67921: PPUSH
67922: PPUSH
67923: PPUSH
67924: PPUSH
67925: PPUSH
67926: PPUSH
67927: PPUSH
67928: PPUSH
67929: PPUSH
67930: PPUSH
67931: PPUSH
67932: PPUSH
67933: PPUSH
67934: PPUSH
67935: PPUSH
67936: PPUSH
67937: PPUSH
67938: PPUSH
67939: PPUSH
67940: PPUSH
67941: PPUSH
67942: PPUSH
67943: PPUSH
67944: PPUSH
67945: PPUSH
67946: PPUSH
67947: PPUSH
67948: PPUSH
67949: PPUSH
67950: PPUSH
67951: PPUSH
67952: PPUSH
67953: PPUSH
67954: PPUSH
67955: PPUSH
67956: PPUSH
67957: PPUSH
67958: PPUSH
67959: PPUSH
67960: PPUSH
67961: PPUSH
67962: PPUSH
67963: PPUSH
67964: PPUSH
67965: PPUSH
// result = [ ] ;
67966: LD_ADDR_VAR 0 7
67970: PUSH
67971: EMPTY
67972: ST_TO_ADDR
// temp_list = [ ] ;
67973: LD_ADDR_VAR 0 9
67977: PUSH
67978: EMPTY
67979: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
67980: LD_VAR 0 4
67984: PUSH
67985: LD_INT 0
67987: PUSH
67988: LD_INT 1
67990: PUSH
67991: LD_INT 2
67993: PUSH
67994: LD_INT 3
67996: PUSH
67997: LD_INT 4
67999: PUSH
68000: LD_INT 5
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: LIST
68007: LIST
68008: LIST
68009: LIST
68010: IN
68011: NOT
68012: PUSH
68013: LD_VAR 0 1
68017: PUSH
68018: LD_INT 0
68020: PUSH
68021: LD_INT 1
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: IN
68028: PUSH
68029: LD_VAR 0 5
68033: PUSH
68034: LD_INT 1
68036: PUSH
68037: LD_INT 2
68039: PUSH
68040: LD_INT 3
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: LIST
68047: IN
68048: NOT
68049: AND
68050: OR
68051: IFFALSE 68055
// exit ;
68053: GO 86446
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
68055: LD_VAR 0 1
68059: PUSH
68060: LD_INT 6
68062: PUSH
68063: LD_INT 7
68065: PUSH
68066: LD_INT 8
68068: PUSH
68069: LD_INT 13
68071: PUSH
68072: LD_INT 12
68074: PUSH
68075: LD_INT 15
68077: PUSH
68078: LD_INT 11
68080: PUSH
68081: LD_INT 14
68083: PUSH
68084: LD_INT 10
68086: PUSH
68087: EMPTY
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: LIST
68097: IN
68098: IFFALSE 68108
// btype = b_lab ;
68100: LD_ADDR_VAR 0 1
68104: PUSH
68105: LD_INT 6
68107: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
68108: LD_VAR 0 6
68112: PUSH
68113: LD_INT 0
68115: PUSH
68116: LD_INT 1
68118: PUSH
68119: LD_INT 2
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: LIST
68126: IN
68127: NOT
68128: PUSH
68129: LD_VAR 0 1
68133: PUSH
68134: LD_INT 0
68136: PUSH
68137: LD_INT 1
68139: PUSH
68140: LD_INT 2
68142: PUSH
68143: LD_INT 3
68145: PUSH
68146: LD_INT 6
68148: PUSH
68149: LD_INT 36
68151: PUSH
68152: LD_INT 4
68154: PUSH
68155: LD_INT 5
68157: PUSH
68158: LD_INT 31
68160: PUSH
68161: LD_INT 32
68163: PUSH
68164: LD_INT 33
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: IN
68180: NOT
68181: PUSH
68182: LD_VAR 0 6
68186: PUSH
68187: LD_INT 1
68189: EQUAL
68190: AND
68191: OR
68192: PUSH
68193: LD_VAR 0 1
68197: PUSH
68198: LD_INT 2
68200: PUSH
68201: LD_INT 3
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: IN
68208: NOT
68209: PUSH
68210: LD_VAR 0 6
68214: PUSH
68215: LD_INT 2
68217: EQUAL
68218: AND
68219: OR
68220: IFFALSE 68230
// mode = 0 ;
68222: LD_ADDR_VAR 0 6
68226: PUSH
68227: LD_INT 0
68229: ST_TO_ADDR
// case mode of 0 :
68230: LD_VAR 0 6
68234: PUSH
68235: LD_INT 0
68237: DOUBLE
68238: EQUAL
68239: IFTRUE 68243
68241: GO 79696
68243: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
68244: LD_ADDR_VAR 0 11
68248: PUSH
68249: LD_INT 0
68251: PUSH
68252: LD_INT 0
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: LD_INT 0
68261: PUSH
68262: LD_INT 1
68264: NEG
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 1
68272: PUSH
68273: LD_INT 0
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 1
68282: PUSH
68283: LD_INT 1
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 0
68292: PUSH
68293: LD_INT 1
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 1
68302: NEG
68303: PUSH
68304: LD_INT 0
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: LD_INT 1
68313: NEG
68314: PUSH
68315: LD_INT 1
68317: NEG
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 1
68325: NEG
68326: PUSH
68327: LD_INT 2
68329: NEG
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: PUSH
68335: LD_INT 0
68337: PUSH
68338: LD_INT 2
68340: NEG
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 1
68348: PUSH
68349: LD_INT 1
68351: NEG
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 1
68359: PUSH
68360: LD_INT 2
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 0
68369: PUSH
68370: LD_INT 2
68372: PUSH
68373: EMPTY
68374: LIST
68375: LIST
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: LD_INT 1
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 1
68390: PUSH
68391: LD_INT 3
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 0
68400: PUSH
68401: LD_INT 3
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: LD_INT 1
68410: NEG
68411: PUSH
68412: LD_INT 2
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: LIST
68436: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68437: LD_ADDR_VAR 0 12
68441: PUSH
68442: LD_INT 0
68444: PUSH
68445: LD_INT 0
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PUSH
68452: LD_INT 0
68454: PUSH
68455: LD_INT 1
68457: NEG
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 1
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 1
68475: PUSH
68476: LD_INT 1
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 0
68485: PUSH
68486: LD_INT 1
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PUSH
68493: LD_INT 1
68495: NEG
68496: PUSH
68497: LD_INT 0
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 1
68506: NEG
68507: PUSH
68508: LD_INT 1
68510: NEG
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 1
68518: PUSH
68519: LD_INT 1
68521: NEG
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 2
68529: PUSH
68530: LD_INT 0
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 2
68539: PUSH
68540: LD_INT 1
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PUSH
68547: LD_INT 1
68549: NEG
68550: PUSH
68551: LD_INT 1
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: LD_INT 2
68560: NEG
68561: PUSH
68562: LD_INT 0
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 2
68571: NEG
68572: PUSH
68573: LD_INT 1
68575: NEG
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 2
68583: NEG
68584: PUSH
68585: LD_INT 1
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 3
68594: NEG
68595: PUSH
68596: LD_INT 0
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 3
68605: NEG
68606: PUSH
68607: LD_INT 1
68609: NEG
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68633: LD_ADDR_VAR 0 13
68637: PUSH
68638: LD_INT 0
68640: PUSH
68641: LD_INT 0
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 0
68650: PUSH
68651: LD_INT 1
68653: NEG
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: LD_INT 1
68661: PUSH
68662: LD_INT 0
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PUSH
68669: LD_INT 1
68671: PUSH
68672: LD_INT 1
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: PUSH
68679: LD_INT 0
68681: PUSH
68682: LD_INT 1
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: LD_INT 1
68691: NEG
68692: PUSH
68693: LD_INT 0
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 1
68714: NEG
68715: PUSH
68716: LD_INT 2
68718: NEG
68719: PUSH
68720: EMPTY
68721: LIST
68722: LIST
68723: PUSH
68724: LD_INT 2
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 2
68736: PUSH
68737: LD_INT 2
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: PUSH
68744: LD_INT 1
68746: PUSH
68747: LD_INT 2
68749: PUSH
68750: EMPTY
68751: LIST
68752: LIST
68753: PUSH
68754: LD_INT 2
68756: NEG
68757: PUSH
68758: LD_INT 1
68760: NEG
68761: PUSH
68762: EMPTY
68763: LIST
68764: LIST
68765: PUSH
68766: LD_INT 2
68768: NEG
68769: PUSH
68770: LD_INT 2
68772: NEG
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: LD_INT 2
68780: NEG
68781: PUSH
68782: LD_INT 3
68784: NEG
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 3
68792: NEG
68793: PUSH
68794: LD_INT 2
68796: NEG
68797: PUSH
68798: EMPTY
68799: LIST
68800: LIST
68801: PUSH
68802: LD_INT 3
68804: NEG
68805: PUSH
68806: LD_INT 3
68808: NEG
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: LIST
68818: LIST
68819: LIST
68820: LIST
68821: LIST
68822: LIST
68823: LIST
68824: LIST
68825: LIST
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
68832: LD_ADDR_VAR 0 14
68836: PUSH
68837: LD_INT 0
68839: PUSH
68840: LD_INT 0
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 0
68849: PUSH
68850: LD_INT 1
68852: NEG
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PUSH
68858: LD_INT 1
68860: PUSH
68861: LD_INT 0
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: PUSH
68868: LD_INT 1
68870: PUSH
68871: LD_INT 1
68873: PUSH
68874: EMPTY
68875: LIST
68876: LIST
68877: PUSH
68878: LD_INT 0
68880: PUSH
68881: LD_INT 1
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: PUSH
68888: LD_INT 1
68890: NEG
68891: PUSH
68892: LD_INT 0
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: LD_INT 1
68901: NEG
68902: PUSH
68903: LD_INT 1
68905: NEG
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 1
68913: NEG
68914: PUSH
68915: LD_INT 2
68917: NEG
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 0
68925: PUSH
68926: LD_INT 2
68928: NEG
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 1
68936: PUSH
68937: LD_INT 1
68939: NEG
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 1
68947: PUSH
68948: LD_INT 2
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 0
68957: PUSH
68958: LD_INT 2
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: PUSH
68965: LD_INT 1
68967: NEG
68968: PUSH
68969: LD_INT 1
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 1
68978: NEG
68979: PUSH
68980: LD_INT 3
68982: NEG
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 0
68990: PUSH
68991: LD_INT 3
68993: NEG
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: PUSH
68999: LD_INT 1
69001: PUSH
69002: LD_INT 2
69004: NEG
69005: PUSH
69006: EMPTY
69007: LIST
69008: LIST
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69028: LD_ADDR_VAR 0 15
69032: PUSH
69033: LD_INT 0
69035: PUSH
69036: LD_INT 0
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: PUSH
69043: LD_INT 0
69045: PUSH
69046: LD_INT 1
69048: NEG
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 1
69056: PUSH
69057: LD_INT 0
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 1
69066: PUSH
69067: LD_INT 1
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 0
69076: PUSH
69077: LD_INT 1
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 1
69086: NEG
69087: PUSH
69088: LD_INT 0
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 1
69097: NEG
69098: PUSH
69099: LD_INT 1
69101: NEG
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PUSH
69107: LD_INT 1
69109: PUSH
69110: LD_INT 1
69112: NEG
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 2
69120: PUSH
69121: LD_INT 0
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 2
69130: PUSH
69131: LD_INT 1
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: NEG
69141: PUSH
69142: LD_INT 1
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 2
69151: NEG
69152: PUSH
69153: LD_INT 0
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: LD_INT 2
69162: NEG
69163: PUSH
69164: LD_INT 1
69166: NEG
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: LD_INT 1
69177: NEG
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: LD_INT 3
69185: PUSH
69186: LD_INT 0
69188: PUSH
69189: EMPTY
69190: LIST
69191: LIST
69192: PUSH
69193: LD_INT 3
69195: PUSH
69196: LD_INT 1
69198: PUSH
69199: EMPTY
69200: LIST
69201: LIST
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: LIST
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: LIST
69217: LIST
69218: LIST
69219: LIST
69220: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69221: LD_ADDR_VAR 0 16
69225: PUSH
69226: LD_INT 0
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 0
69238: PUSH
69239: LD_INT 1
69241: NEG
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: PUSH
69247: LD_INT 1
69249: PUSH
69250: LD_INT 0
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PUSH
69267: LD_INT 0
69269: PUSH
69270: LD_INT 1
69272: PUSH
69273: EMPTY
69274: LIST
69275: LIST
69276: PUSH
69277: LD_INT 1
69279: NEG
69280: PUSH
69281: LD_INT 0
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 1
69290: NEG
69291: PUSH
69292: LD_INT 1
69294: NEG
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 1
69302: NEG
69303: PUSH
69304: LD_INT 2
69306: NEG
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: LD_INT 2
69314: PUSH
69315: LD_INT 1
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 2
69324: PUSH
69325: LD_INT 2
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 1
69334: PUSH
69335: LD_INT 2
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: LD_INT 2
69344: NEG
69345: PUSH
69346: LD_INT 1
69348: NEG
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: LD_INT 2
69356: NEG
69357: PUSH
69358: LD_INT 2
69360: NEG
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 3
69368: PUSH
69369: LD_INT 2
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 3
69378: PUSH
69379: LD_INT 3
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PUSH
69386: LD_INT 2
69388: PUSH
69389: LD_INT 3
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69414: LD_ADDR_VAR 0 17
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 0
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 1
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 0
69462: PUSH
69463: LD_INT 1
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: NEG
69473: PUSH
69474: LD_INT 0
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 1
69483: NEG
69484: PUSH
69485: LD_INT 1
69487: NEG
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: LD_INT 2
69499: NEG
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 0
69507: PUSH
69508: LD_INT 2
69510: NEG
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 1
69518: PUSH
69519: LD_INT 1
69521: NEG
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 2
69529: PUSH
69530: LD_INT 0
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: LD_INT 2
69539: PUSH
69540: LD_INT 1
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 2
69549: PUSH
69550: LD_INT 2
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 1
69559: PUSH
69560: LD_INT 2
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 0
69569: PUSH
69570: LD_INT 2
69572: PUSH
69573: EMPTY
69574: LIST
69575: LIST
69576: PUSH
69577: LD_INT 1
69579: NEG
69580: PUSH
69581: LD_INT 1
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: LD_INT 2
69590: NEG
69591: PUSH
69592: LD_INT 0
69594: PUSH
69595: EMPTY
69596: LIST
69597: LIST
69598: PUSH
69599: LD_INT 2
69601: NEG
69602: PUSH
69603: LD_INT 1
69605: NEG
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: PUSH
69611: LD_INT 2
69613: NEG
69614: PUSH
69615: LD_INT 2
69617: NEG
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69644: LD_ADDR_VAR 0 18
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 0
69661: PUSH
69662: LD_INT 1
69664: NEG
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 1
69672: PUSH
69673: LD_INT 0
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 1
69682: PUSH
69683: LD_INT 1
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 0
69692: PUSH
69693: LD_INT 1
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 1
69702: NEG
69703: PUSH
69704: LD_INT 0
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 1
69713: NEG
69714: PUSH
69715: LD_INT 1
69717: NEG
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 1
69725: NEG
69726: PUSH
69727: LD_INT 2
69729: NEG
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 0
69737: PUSH
69738: LD_INT 2
69740: NEG
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 1
69748: PUSH
69749: LD_INT 1
69751: NEG
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 2
69759: PUSH
69760: LD_INT 0
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 2
69769: PUSH
69770: LD_INT 1
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 2
69779: PUSH
69780: LD_INT 2
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: LD_INT 2
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 0
69799: PUSH
69800: LD_INT 2
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 1
69809: NEG
69810: PUSH
69811: LD_INT 1
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 2
69820: NEG
69821: PUSH
69822: LD_INT 0
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PUSH
69829: LD_INT 2
69831: NEG
69832: PUSH
69833: LD_INT 1
69835: NEG
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: LD_INT 2
69843: NEG
69844: PUSH
69845: LD_INT 2
69847: NEG
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69874: LD_ADDR_VAR 0 19
69878: PUSH
69879: LD_INT 0
69881: PUSH
69882: LD_INT 0
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 0
69891: PUSH
69892: LD_INT 1
69894: NEG
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 1
69902: PUSH
69903: LD_INT 0
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 1
69912: PUSH
69913: LD_INT 1
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 0
69922: PUSH
69923: LD_INT 1
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PUSH
69930: LD_INT 1
69932: NEG
69933: PUSH
69934: LD_INT 0
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 1
69943: NEG
69944: PUSH
69945: LD_INT 1
69947: NEG
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: LD_INT 1
69955: NEG
69956: PUSH
69957: LD_INT 2
69959: NEG
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PUSH
69965: LD_INT 0
69967: PUSH
69968: LD_INT 2
69970: NEG
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: PUSH
69976: LD_INT 1
69978: PUSH
69979: LD_INT 1
69981: NEG
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 2
69989: PUSH
69990: LD_INT 0
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 2
69999: PUSH
70000: LD_INT 1
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 2
70009: PUSH
70010: LD_INT 2
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 1
70019: PUSH
70020: LD_INT 2
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: PUSH
70027: LD_INT 0
70029: PUSH
70030: LD_INT 2
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 1
70039: NEG
70040: PUSH
70041: LD_INT 1
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PUSH
70048: LD_INT 2
70050: NEG
70051: PUSH
70052: LD_INT 0
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 2
70061: NEG
70062: PUSH
70063: LD_INT 1
70065: NEG
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: PUSH
70071: LD_INT 2
70073: NEG
70074: PUSH
70075: LD_INT 2
70077: NEG
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: LIST
70094: LIST
70095: LIST
70096: LIST
70097: LIST
70098: LIST
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70104: LD_ADDR_VAR 0 20
70108: PUSH
70109: LD_INT 0
70111: PUSH
70112: LD_INT 0
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 0
70121: PUSH
70122: LD_INT 1
70124: NEG
70125: PUSH
70126: EMPTY
70127: LIST
70128: LIST
70129: PUSH
70130: LD_INT 1
70132: PUSH
70133: LD_INT 0
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: LD_INT 1
70142: PUSH
70143: LD_INT 1
70145: PUSH
70146: EMPTY
70147: LIST
70148: LIST
70149: PUSH
70150: LD_INT 0
70152: PUSH
70153: LD_INT 1
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PUSH
70160: LD_INT 1
70162: NEG
70163: PUSH
70164: LD_INT 0
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 1
70173: NEG
70174: PUSH
70175: LD_INT 1
70177: NEG
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: LD_INT 1
70185: NEG
70186: PUSH
70187: LD_INT 2
70189: NEG
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: PUSH
70195: LD_INT 0
70197: PUSH
70198: LD_INT 2
70200: NEG
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 1
70208: PUSH
70209: LD_INT 1
70211: NEG
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 2
70219: PUSH
70220: LD_INT 0
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 2
70229: PUSH
70230: LD_INT 1
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: LD_INT 2
70239: PUSH
70240: LD_INT 2
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PUSH
70247: LD_INT 1
70249: PUSH
70250: LD_INT 2
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: PUSH
70257: LD_INT 0
70259: PUSH
70260: LD_INT 2
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 1
70269: NEG
70270: PUSH
70271: LD_INT 1
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: PUSH
70278: LD_INT 2
70280: NEG
70281: PUSH
70282: LD_INT 0
70284: PUSH
70285: EMPTY
70286: LIST
70287: LIST
70288: PUSH
70289: LD_INT 2
70291: NEG
70292: PUSH
70293: LD_INT 1
70295: NEG
70296: PUSH
70297: EMPTY
70298: LIST
70299: LIST
70300: PUSH
70301: LD_INT 2
70303: NEG
70304: PUSH
70305: LD_INT 2
70307: NEG
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70334: LD_ADDR_VAR 0 21
70338: PUSH
70339: LD_INT 0
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 0
70351: PUSH
70352: LD_INT 1
70354: NEG
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 1
70362: PUSH
70363: LD_INT 0
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 1
70372: PUSH
70373: LD_INT 1
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 0
70382: PUSH
70383: LD_INT 1
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 1
70392: NEG
70393: PUSH
70394: LD_INT 0
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: PUSH
70401: LD_INT 1
70403: NEG
70404: PUSH
70405: LD_INT 1
70407: NEG
70408: PUSH
70409: EMPTY
70410: LIST
70411: LIST
70412: PUSH
70413: LD_INT 1
70415: NEG
70416: PUSH
70417: LD_INT 2
70419: NEG
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 0
70427: PUSH
70428: LD_INT 2
70430: NEG
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 1
70438: PUSH
70439: LD_INT 1
70441: NEG
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 2
70449: PUSH
70450: LD_INT 0
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 2
70459: PUSH
70460: LD_INT 1
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 2
70469: PUSH
70470: LD_INT 2
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 1
70479: PUSH
70480: LD_INT 2
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 0
70489: PUSH
70490: LD_INT 2
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 1
70499: NEG
70500: PUSH
70501: LD_INT 1
70503: PUSH
70504: EMPTY
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 2
70510: NEG
70511: PUSH
70512: LD_INT 0
70514: PUSH
70515: EMPTY
70516: LIST
70517: LIST
70518: PUSH
70519: LD_INT 2
70521: NEG
70522: PUSH
70523: LD_INT 1
70525: NEG
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PUSH
70531: LD_INT 2
70533: NEG
70534: PUSH
70535: LD_INT 2
70537: NEG
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70564: LD_ADDR_VAR 0 22
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: LD_INT 0
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 0
70581: PUSH
70582: LD_INT 1
70584: NEG
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 1
70592: PUSH
70593: LD_INT 0
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 1
70602: PUSH
70603: LD_INT 1
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 0
70612: PUSH
70613: LD_INT 1
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: LD_INT 1
70622: NEG
70623: PUSH
70624: LD_INT 0
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 1
70633: NEG
70634: PUSH
70635: LD_INT 1
70637: NEG
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 1
70645: NEG
70646: PUSH
70647: LD_INT 2
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: LD_INT 0
70657: PUSH
70658: LD_INT 2
70660: NEG
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 1
70668: PUSH
70669: LD_INT 1
70671: NEG
70672: PUSH
70673: EMPTY
70674: LIST
70675: LIST
70676: PUSH
70677: LD_INT 2
70679: PUSH
70680: LD_INT 0
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 2
70689: PUSH
70690: LD_INT 1
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: LD_INT 2
70699: PUSH
70700: LD_INT 2
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: PUSH
70707: LD_INT 1
70709: PUSH
70710: LD_INT 2
70712: PUSH
70713: EMPTY
70714: LIST
70715: LIST
70716: PUSH
70717: LD_INT 0
70719: PUSH
70720: LD_INT 2
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: PUSH
70727: LD_INT 1
70729: NEG
70730: PUSH
70731: LD_INT 1
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PUSH
70738: LD_INT 2
70740: NEG
70741: PUSH
70742: LD_INT 0
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 2
70751: NEG
70752: PUSH
70753: LD_INT 1
70755: NEG
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: PUSH
70761: LD_INT 2
70763: NEG
70764: PUSH
70765: LD_INT 2
70767: NEG
70768: PUSH
70769: EMPTY
70770: LIST
70771: LIST
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
70794: LD_ADDR_VAR 0 23
70798: PUSH
70799: LD_INT 0
70801: PUSH
70802: LD_INT 0
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 0
70811: PUSH
70812: LD_INT 1
70814: NEG
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 1
70822: PUSH
70823: LD_INT 0
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: LD_INT 1
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 0
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 1
70852: NEG
70853: PUSH
70854: LD_INT 0
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 1
70863: NEG
70864: PUSH
70865: LD_INT 1
70867: NEG
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 1
70875: NEG
70876: PUSH
70877: LD_INT 2
70879: NEG
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 0
70887: PUSH
70888: LD_INT 2
70890: NEG
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: PUSH
70899: LD_INT 1
70901: NEG
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 2
70909: PUSH
70910: LD_INT 0
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 2
70919: PUSH
70920: LD_INT 1
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 2
70929: PUSH
70930: LD_INT 2
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 1
70939: PUSH
70940: LD_INT 2
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 0
70949: PUSH
70950: LD_INT 2
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PUSH
70957: LD_INT 1
70959: NEG
70960: PUSH
70961: LD_INT 1
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: LD_INT 2
70970: NEG
70971: PUSH
70972: LD_INT 0
70974: PUSH
70975: EMPTY
70976: LIST
70977: LIST
70978: PUSH
70979: LD_INT 2
70981: NEG
70982: PUSH
70983: LD_INT 1
70985: NEG
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PUSH
70991: LD_INT 2
70993: NEG
70994: PUSH
70995: LD_INT 2
70997: NEG
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: LD_INT 2
71005: NEG
71006: PUSH
71007: LD_INT 3
71009: NEG
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PUSH
71015: LD_INT 1
71017: NEG
71018: PUSH
71019: LD_INT 3
71021: NEG
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 1
71029: PUSH
71030: LD_INT 2
71032: NEG
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 2
71040: PUSH
71041: LD_INT 1
71043: NEG
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: LIST
71053: LIST
71054: LIST
71055: LIST
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
71074: LD_ADDR_VAR 0 24
71078: PUSH
71079: LD_INT 0
71081: PUSH
71082: LD_INT 0
71084: PUSH
71085: EMPTY
71086: LIST
71087: LIST
71088: PUSH
71089: LD_INT 0
71091: PUSH
71092: LD_INT 1
71094: NEG
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 1
71102: PUSH
71103: LD_INT 0
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PUSH
71110: LD_INT 1
71112: PUSH
71113: LD_INT 1
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 0
71122: PUSH
71123: LD_INT 1
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: LD_INT 1
71132: NEG
71133: PUSH
71134: LD_INT 0
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PUSH
71141: LD_INT 1
71143: NEG
71144: PUSH
71145: LD_INT 1
71147: NEG
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: LD_INT 1
71155: NEG
71156: PUSH
71157: LD_INT 2
71159: NEG
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: LD_INT 0
71167: PUSH
71168: LD_INT 2
71170: NEG
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: LD_INT 1
71178: PUSH
71179: LD_INT 1
71181: NEG
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: PUSH
71187: LD_INT 2
71189: PUSH
71190: LD_INT 0
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 2
71199: PUSH
71200: LD_INT 1
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 2
71209: PUSH
71210: LD_INT 2
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: LD_INT 2
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 0
71229: PUSH
71230: LD_INT 2
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 1
71239: NEG
71240: PUSH
71241: LD_INT 1
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 2
71250: NEG
71251: PUSH
71252: LD_INT 0
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 2
71261: NEG
71262: PUSH
71263: LD_INT 1
71265: NEG
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: LD_INT 2
71273: NEG
71274: PUSH
71275: LD_INT 2
71277: NEG
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 1
71285: PUSH
71286: LD_INT 2
71288: NEG
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PUSH
71294: LD_INT 2
71296: PUSH
71297: LD_INT 1
71299: NEG
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: LD_INT 3
71307: PUSH
71308: LD_INT 1
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 3
71317: PUSH
71318: LD_INT 2
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
71350: LD_ADDR_VAR 0 25
71354: PUSH
71355: LD_INT 0
71357: PUSH
71358: LD_INT 0
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 0
71367: PUSH
71368: LD_INT 1
71370: NEG
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 1
71378: PUSH
71379: LD_INT 0
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 1
71388: PUSH
71389: LD_INT 1
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 0
71398: PUSH
71399: LD_INT 1
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: PUSH
71406: LD_INT 1
71408: NEG
71409: PUSH
71410: LD_INT 0
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 1
71419: NEG
71420: PUSH
71421: LD_INT 1
71423: NEG
71424: PUSH
71425: EMPTY
71426: LIST
71427: LIST
71428: PUSH
71429: LD_INT 1
71431: NEG
71432: PUSH
71433: LD_INT 2
71435: NEG
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PUSH
71441: LD_INT 0
71443: PUSH
71444: LD_INT 2
71446: NEG
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 1
71454: PUSH
71455: LD_INT 1
71457: NEG
71458: PUSH
71459: EMPTY
71460: LIST
71461: LIST
71462: PUSH
71463: LD_INT 2
71465: PUSH
71466: LD_INT 0
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: LD_INT 2
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: LD_INT 2
71485: PUSH
71486: LD_INT 2
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 1
71495: PUSH
71496: LD_INT 2
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 0
71505: PUSH
71506: LD_INT 2
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: PUSH
71513: LD_INT 1
71515: NEG
71516: PUSH
71517: LD_INT 1
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: LD_INT 2
71526: NEG
71527: PUSH
71528: LD_INT 0
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: LD_INT 2
71537: NEG
71538: PUSH
71539: LD_INT 1
71541: NEG
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 2
71549: NEG
71550: PUSH
71551: LD_INT 2
71553: NEG
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: PUSH
71559: LD_INT 3
71561: PUSH
71562: LD_INT 1
71564: PUSH
71565: EMPTY
71566: LIST
71567: LIST
71568: PUSH
71569: LD_INT 3
71571: PUSH
71572: LD_INT 2
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 2
71581: PUSH
71582: LD_INT 3
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: PUSH
71589: LD_INT 1
71591: PUSH
71592: LD_INT 3
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
71624: LD_ADDR_VAR 0 26
71628: PUSH
71629: LD_INT 0
71631: PUSH
71632: LD_INT 0
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 0
71641: PUSH
71642: LD_INT 1
71644: NEG
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 1
71652: PUSH
71653: LD_INT 0
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: PUSH
71660: LD_INT 1
71662: PUSH
71663: LD_INT 1
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: PUSH
71670: LD_INT 0
71672: PUSH
71673: LD_INT 1
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 1
71682: NEG
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 1
71693: NEG
71694: PUSH
71695: LD_INT 1
71697: NEG
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 1
71705: NEG
71706: PUSH
71707: LD_INT 2
71709: NEG
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 0
71717: PUSH
71718: LD_INT 2
71720: NEG
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 1
71728: PUSH
71729: LD_INT 1
71731: NEG
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: PUSH
71737: LD_INT 2
71739: PUSH
71740: LD_INT 0
71742: PUSH
71743: EMPTY
71744: LIST
71745: LIST
71746: PUSH
71747: LD_INT 2
71749: PUSH
71750: LD_INT 1
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 2
71759: PUSH
71760: LD_INT 2
71762: PUSH
71763: EMPTY
71764: LIST
71765: LIST
71766: PUSH
71767: LD_INT 1
71769: PUSH
71770: LD_INT 2
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: PUSH
71777: LD_INT 0
71779: PUSH
71780: LD_INT 2
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: PUSH
71787: LD_INT 1
71789: NEG
71790: PUSH
71791: LD_INT 1
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: LD_INT 2
71800: NEG
71801: PUSH
71802: LD_INT 0
71804: PUSH
71805: EMPTY
71806: LIST
71807: LIST
71808: PUSH
71809: LD_INT 2
71811: NEG
71812: PUSH
71813: LD_INT 1
71815: NEG
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PUSH
71821: LD_INT 2
71823: NEG
71824: PUSH
71825: LD_INT 2
71827: NEG
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: PUSH
71833: LD_INT 2
71835: PUSH
71836: LD_INT 3
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 1
71845: PUSH
71846: LD_INT 3
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 1
71855: NEG
71856: PUSH
71857: LD_INT 2
71859: PUSH
71860: EMPTY
71861: LIST
71862: LIST
71863: PUSH
71864: LD_INT 2
71866: NEG
71867: PUSH
71868: LD_INT 1
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: LIST
71881: LIST
71882: LIST
71883: LIST
71884: LIST
71885: LIST
71886: LIST
71887: LIST
71888: LIST
71889: LIST
71890: LIST
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: LIST
71896: LIST
71897: LIST
71898: LIST
71899: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71900: LD_ADDR_VAR 0 27
71904: PUSH
71905: LD_INT 0
71907: PUSH
71908: LD_INT 0
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 0
71917: PUSH
71918: LD_INT 1
71920: NEG
71921: PUSH
71922: EMPTY
71923: LIST
71924: LIST
71925: PUSH
71926: LD_INT 1
71928: PUSH
71929: LD_INT 0
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: PUSH
71936: LD_INT 1
71938: PUSH
71939: LD_INT 1
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: LD_INT 0
71948: PUSH
71949: LD_INT 1
71951: PUSH
71952: EMPTY
71953: LIST
71954: LIST
71955: PUSH
71956: LD_INT 1
71958: NEG
71959: PUSH
71960: LD_INT 0
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 1
71969: NEG
71970: PUSH
71971: LD_INT 1
71973: NEG
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 1
71981: NEG
71982: PUSH
71983: LD_INT 2
71985: NEG
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: LD_INT 2
71996: NEG
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: LD_INT 1
72004: PUSH
72005: LD_INT 1
72007: NEG
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 2
72015: PUSH
72016: LD_INT 0
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 2
72025: PUSH
72026: LD_INT 1
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 2
72035: PUSH
72036: LD_INT 2
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 1
72045: PUSH
72046: LD_INT 2
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 0
72055: PUSH
72056: LD_INT 2
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 1
72065: NEG
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 2
72076: NEG
72077: PUSH
72078: LD_INT 0
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: PUSH
72085: LD_INT 2
72087: NEG
72088: PUSH
72089: LD_INT 1
72091: NEG
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 2
72099: NEG
72100: PUSH
72101: LD_INT 2
72103: NEG
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: PUSH
72109: LD_INT 1
72111: NEG
72112: PUSH
72113: LD_INT 2
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 2
72122: NEG
72123: PUSH
72124: LD_INT 1
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 3
72133: NEG
72134: PUSH
72135: LD_INT 1
72137: NEG
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 3
72145: NEG
72146: PUSH
72147: LD_INT 2
72149: NEG
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: LIST
72159: LIST
72160: LIST
72161: LIST
72162: LIST
72163: LIST
72164: LIST
72165: LIST
72166: LIST
72167: LIST
72168: LIST
72169: LIST
72170: LIST
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
72180: LD_ADDR_VAR 0 28
72184: PUSH
72185: LD_INT 0
72187: PUSH
72188: LD_INT 0
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: PUSH
72195: LD_INT 0
72197: PUSH
72198: LD_INT 1
72200: NEG
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: LD_INT 1
72208: PUSH
72209: LD_INT 0
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 1
72218: PUSH
72219: LD_INT 1
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: LD_INT 0
72228: PUSH
72229: LD_INT 1
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 1
72238: NEG
72239: PUSH
72240: LD_INT 0
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PUSH
72247: LD_INT 1
72249: NEG
72250: PUSH
72251: LD_INT 1
72253: NEG
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: PUSH
72259: LD_INT 1
72261: NEG
72262: PUSH
72263: LD_INT 2
72265: NEG
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 0
72273: PUSH
72274: LD_INT 2
72276: NEG
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 1
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 2
72295: PUSH
72296: LD_INT 0
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 2
72305: PUSH
72306: LD_INT 1
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 2
72315: PUSH
72316: LD_INT 2
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 1
72325: PUSH
72326: LD_INT 2
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 0
72335: PUSH
72336: LD_INT 2
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 1
72345: NEG
72346: PUSH
72347: LD_INT 1
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 2
72356: NEG
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 2
72367: NEG
72368: PUSH
72369: LD_INT 1
72371: NEG
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 2
72379: NEG
72380: PUSH
72381: LD_INT 2
72383: NEG
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 2
72391: NEG
72392: PUSH
72393: LD_INT 3
72395: NEG
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: LD_INT 1
72403: NEG
72404: PUSH
72405: LD_INT 3
72407: NEG
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: LD_INT 3
72415: NEG
72416: PUSH
72417: LD_INT 1
72419: NEG
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 3
72427: NEG
72428: PUSH
72429: LD_INT 2
72431: NEG
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: LIST
72442: LIST
72443: LIST
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72462: LD_ADDR_VAR 0 29
72466: PUSH
72467: LD_INT 0
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 0
72479: PUSH
72480: LD_INT 1
72482: NEG
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 1
72490: PUSH
72491: LD_INT 0
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: PUSH
72501: LD_INT 1
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: PUSH
72508: LD_INT 0
72510: PUSH
72511: LD_INT 1
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: PUSH
72518: LD_INT 1
72520: NEG
72521: PUSH
72522: LD_INT 0
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 1
72531: NEG
72532: PUSH
72533: LD_INT 1
72535: NEG
72536: PUSH
72537: EMPTY
72538: LIST
72539: LIST
72540: PUSH
72541: LD_INT 1
72543: NEG
72544: PUSH
72545: LD_INT 2
72547: NEG
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 0
72555: PUSH
72556: LD_INT 2
72558: NEG
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: LD_INT 1
72566: PUSH
72567: LD_INT 1
72569: NEG
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: LD_INT 2
72577: PUSH
72578: LD_INT 0
72580: PUSH
72581: EMPTY
72582: LIST
72583: LIST
72584: PUSH
72585: LD_INT 2
72587: PUSH
72588: LD_INT 1
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 1
72597: PUSH
72598: LD_INT 2
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: LD_INT 2
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: LD_INT 1
72617: NEG
72618: PUSH
72619: LD_INT 1
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: LD_INT 2
72628: NEG
72629: PUSH
72630: LD_INT 1
72632: NEG
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: LD_INT 2
72640: NEG
72641: PUSH
72642: LD_INT 2
72644: NEG
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 2
72652: NEG
72653: PUSH
72654: LD_INT 3
72656: NEG
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 2
72664: PUSH
72665: LD_INT 1
72667: NEG
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 3
72675: PUSH
72676: LD_INT 1
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 1
72685: PUSH
72686: LD_INT 3
72688: PUSH
72689: EMPTY
72690: LIST
72691: LIST
72692: PUSH
72693: LD_INT 1
72695: NEG
72696: PUSH
72697: LD_INT 2
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 3
72706: NEG
72707: PUSH
72708: LD_INT 2
72710: NEG
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: LIST
72720: LIST
72721: LIST
72722: LIST
72723: LIST
72724: LIST
72725: LIST
72726: LIST
72727: LIST
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: LIST
72736: LIST
72737: LIST
72738: LIST
72739: LIST
72740: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72741: LD_ADDR_VAR 0 30
72745: PUSH
72746: LD_INT 0
72748: PUSH
72749: LD_INT 0
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 0
72758: PUSH
72759: LD_INT 1
72761: NEG
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: LD_INT 1
72769: PUSH
72770: LD_INT 0
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: PUSH
72777: LD_INT 1
72779: PUSH
72780: LD_INT 1
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 0
72789: PUSH
72790: LD_INT 1
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 1
72799: NEG
72800: PUSH
72801: LD_INT 0
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PUSH
72808: LD_INT 1
72810: NEG
72811: PUSH
72812: LD_INT 1
72814: NEG
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 1
72822: NEG
72823: PUSH
72824: LD_INT 2
72826: NEG
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: LD_INT 0
72834: PUSH
72835: LD_INT 2
72837: NEG
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 1
72845: PUSH
72846: LD_INT 1
72848: NEG
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 2
72856: PUSH
72857: LD_INT 0
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 2
72866: PUSH
72867: LD_INT 1
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 2
72876: PUSH
72877: LD_INT 2
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 1
72886: PUSH
72887: LD_INT 2
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: PUSH
72894: LD_INT 1
72896: NEG
72897: PUSH
72898: LD_INT 1
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: LD_INT 2
72907: NEG
72908: PUSH
72909: LD_INT 0
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 2
72918: NEG
72919: PUSH
72920: LD_INT 1
72922: NEG
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: LD_INT 1
72930: NEG
72931: PUSH
72932: LD_INT 3
72934: NEG
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 1
72942: PUSH
72943: LD_INT 2
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 3
72953: PUSH
72954: LD_INT 2
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 2
72963: PUSH
72964: LD_INT 3
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 2
72973: NEG
72974: PUSH
72975: LD_INT 1
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 3
72984: NEG
72985: PUSH
72986: LD_INT 1
72988: NEG
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73019: LD_ADDR_VAR 0 31
73023: PUSH
73024: LD_INT 0
73026: PUSH
73027: LD_INT 0
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: LD_INT 0
73036: PUSH
73037: LD_INT 1
73039: NEG
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 1
73047: PUSH
73048: LD_INT 0
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 1
73057: PUSH
73058: LD_INT 1
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: PUSH
73065: LD_INT 0
73067: PUSH
73068: LD_INT 1
73070: PUSH
73071: EMPTY
73072: LIST
73073: LIST
73074: PUSH
73075: LD_INT 1
73077: NEG
73078: PUSH
73079: LD_INT 0
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: LD_INT 1
73088: NEG
73089: PUSH
73090: LD_INT 1
73092: NEG
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 1
73100: NEG
73101: PUSH
73102: LD_INT 2
73104: NEG
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 1
73112: PUSH
73113: LD_INT 1
73115: NEG
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PUSH
73121: LD_INT 2
73123: PUSH
73124: LD_INT 0
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: LD_INT 2
73133: PUSH
73134: LD_INT 1
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: PUSH
73141: LD_INT 2
73143: PUSH
73144: LD_INT 2
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 1
73153: PUSH
73154: LD_INT 2
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: LD_INT 0
73163: PUSH
73164: LD_INT 2
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 1
73173: NEG
73174: PUSH
73175: LD_INT 1
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 2
73184: NEG
73185: PUSH
73186: LD_INT 1
73188: NEG
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 2
73196: NEG
73197: PUSH
73198: LD_INT 2
73200: NEG
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PUSH
73206: LD_INT 2
73208: NEG
73209: PUSH
73210: LD_INT 3
73212: NEG
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: PUSH
73218: LD_INT 2
73220: PUSH
73221: LD_INT 1
73223: NEG
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PUSH
73229: LD_INT 3
73231: PUSH
73232: LD_INT 1
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 1
73241: PUSH
73242: LD_INT 3
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: LD_INT 1
73251: NEG
73252: PUSH
73253: LD_INT 2
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 3
73262: NEG
73263: PUSH
73264: LD_INT 2
73266: NEG
73267: PUSH
73268: EMPTY
73269: LIST
73270: LIST
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73297: LD_ADDR_VAR 0 32
73301: PUSH
73302: LD_INT 0
73304: PUSH
73305: LD_INT 0
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 0
73314: PUSH
73315: LD_INT 1
73317: NEG
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 1
73325: PUSH
73326: LD_INT 0
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: PUSH
73333: LD_INT 1
73335: PUSH
73336: LD_INT 1
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: LD_INT 0
73345: PUSH
73346: LD_INT 1
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: PUSH
73353: LD_INT 1
73355: NEG
73356: PUSH
73357: LD_INT 0
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: LD_INT 1
73366: NEG
73367: PUSH
73368: LD_INT 1
73370: NEG
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 1
73378: NEG
73379: PUSH
73380: LD_INT 2
73382: NEG
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 0
73390: PUSH
73391: LD_INT 2
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 1
73401: PUSH
73402: LD_INT 1
73404: NEG
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: PUSH
73410: LD_INT 2
73412: PUSH
73413: LD_INT 1
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 2
73422: PUSH
73423: LD_INT 2
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: LD_INT 1
73432: PUSH
73433: LD_INT 2
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 0
73442: PUSH
73443: LD_INT 2
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: PUSH
73450: LD_INT 1
73452: NEG
73453: PUSH
73454: LD_INT 1
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 2
73463: NEG
73464: PUSH
73465: LD_INT 0
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PUSH
73472: LD_INT 2
73474: NEG
73475: PUSH
73476: LD_INT 1
73478: NEG
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 1
73486: NEG
73487: PUSH
73488: LD_INT 3
73490: NEG
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 1
73498: PUSH
73499: LD_INT 2
73501: NEG
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: LD_INT 3
73509: PUSH
73510: LD_INT 2
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 2
73519: PUSH
73520: LD_INT 3
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 2
73529: NEG
73530: PUSH
73531: LD_INT 1
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 3
73540: NEG
73541: PUSH
73542: LD_INT 1
73544: NEG
73545: PUSH
73546: EMPTY
73547: LIST
73548: LIST
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73575: LD_ADDR_VAR 0 33
73579: PUSH
73580: LD_INT 0
73582: PUSH
73583: LD_INT 0
73585: PUSH
73586: EMPTY
73587: LIST
73588: LIST
73589: PUSH
73590: LD_INT 0
73592: PUSH
73593: LD_INT 1
73595: NEG
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: LD_INT 0
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: LD_INT 1
73613: PUSH
73614: LD_INT 1
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 0
73623: PUSH
73624: LD_INT 1
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 1
73633: NEG
73634: PUSH
73635: LD_INT 0
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PUSH
73642: LD_INT 1
73644: NEG
73645: PUSH
73646: LD_INT 1
73648: NEG
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PUSH
73654: LD_INT 1
73656: NEG
73657: PUSH
73658: LD_INT 2
73660: NEG
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 1
73668: PUSH
73669: LD_INT 1
73671: NEG
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 2
73679: PUSH
73680: LD_INT 0
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: LD_INT 2
73689: PUSH
73690: LD_INT 1
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: LD_INT 1
73699: PUSH
73700: LD_INT 2
73702: PUSH
73703: EMPTY
73704: LIST
73705: LIST
73706: PUSH
73707: LD_INT 0
73709: PUSH
73710: LD_INT 2
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 1
73719: NEG
73720: PUSH
73721: LD_INT 1
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 2
73730: NEG
73731: PUSH
73732: LD_INT 0
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: PUSH
73739: LD_INT 2
73741: NEG
73742: PUSH
73743: LD_INT 1
73745: NEG
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: PUSH
73751: LD_INT 2
73753: NEG
73754: PUSH
73755: LD_INT 2
73757: NEG
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 2
73765: NEG
73766: PUSH
73767: LD_INT 3
73769: NEG
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 2
73777: PUSH
73778: LD_INT 1
73780: NEG
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 3
73788: PUSH
73789: LD_INT 1
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PUSH
73796: LD_INT 1
73798: PUSH
73799: LD_INT 3
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 1
73808: NEG
73809: PUSH
73810: LD_INT 2
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 3
73819: NEG
73820: PUSH
73821: LD_INT 2
73823: NEG
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: LIST
73833: LIST
73834: LIST
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: LIST
73846: LIST
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73854: LD_ADDR_VAR 0 34
73858: PUSH
73859: LD_INT 0
73861: PUSH
73862: LD_INT 0
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 0
73871: PUSH
73872: LD_INT 1
73874: NEG
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: LD_INT 1
73882: PUSH
73883: LD_INT 0
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: PUSH
73890: LD_INT 1
73892: PUSH
73893: LD_INT 1
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 0
73902: PUSH
73903: LD_INT 1
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 1
73912: NEG
73913: PUSH
73914: LD_INT 0
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 1
73923: NEG
73924: PUSH
73925: LD_INT 1
73927: NEG
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: LD_INT 2
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: LD_INT 0
73947: PUSH
73948: LD_INT 2
73950: NEG
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 1
73958: PUSH
73959: LD_INT 1
73961: NEG
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: PUSH
73967: LD_INT 2
73969: PUSH
73970: LD_INT 1
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 2
73979: PUSH
73980: LD_INT 2
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_INT 1
73989: PUSH
73990: LD_INT 2
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: LD_INT 1
73999: NEG
74000: PUSH
74001: LD_INT 1
74003: PUSH
74004: EMPTY
74005: LIST
74006: LIST
74007: PUSH
74008: LD_INT 2
74010: NEG
74011: PUSH
74012: LD_INT 0
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 2
74021: NEG
74022: PUSH
74023: LD_INT 1
74025: NEG
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 2
74033: NEG
74034: PUSH
74035: LD_INT 2
74037: NEG
74038: PUSH
74039: EMPTY
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 1
74045: NEG
74046: PUSH
74047: LD_INT 3
74049: NEG
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: PUSH
74055: LD_INT 1
74057: PUSH
74058: LD_INT 2
74060: NEG
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 3
74068: PUSH
74069: LD_INT 2
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PUSH
74076: LD_INT 2
74078: PUSH
74079: LD_INT 3
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: PUSH
74086: LD_INT 2
74088: NEG
74089: PUSH
74090: LD_INT 1
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 3
74099: NEG
74100: PUSH
74101: LD_INT 1
74103: NEG
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: LIST
74113: LIST
74114: LIST
74115: LIST
74116: LIST
74117: LIST
74118: LIST
74119: LIST
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74134: LD_ADDR_VAR 0 35
74138: PUSH
74139: LD_INT 0
74141: PUSH
74142: LD_INT 0
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 0
74151: PUSH
74152: LD_INT 1
74154: NEG
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 1
74162: PUSH
74163: LD_INT 0
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: PUSH
74170: LD_INT 1
74172: PUSH
74173: LD_INT 1
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 0
74182: PUSH
74183: LD_INT 1
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 1
74192: NEG
74193: PUSH
74194: LD_INT 0
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: LD_INT 1
74203: NEG
74204: PUSH
74205: LD_INT 1
74207: NEG
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 2
74215: PUSH
74216: LD_INT 1
74218: PUSH
74219: EMPTY
74220: LIST
74221: LIST
74222: PUSH
74223: LD_INT 2
74225: NEG
74226: PUSH
74227: LD_INT 1
74229: NEG
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: LIST
74243: LIST
74244: LIST
74245: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74246: LD_ADDR_VAR 0 36
74250: PUSH
74251: LD_INT 0
74253: PUSH
74254: LD_INT 0
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: LD_INT 0
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 1
74274: PUSH
74275: LD_INT 0
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: LD_INT 1
74284: PUSH
74285: LD_INT 1
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 0
74294: PUSH
74295: LD_INT 1
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 1
74304: NEG
74305: PUSH
74306: LD_INT 0
74308: PUSH
74309: EMPTY
74310: LIST
74311: LIST
74312: PUSH
74313: LD_INT 1
74315: NEG
74316: PUSH
74317: LD_INT 1
74319: NEG
74320: PUSH
74321: EMPTY
74322: LIST
74323: LIST
74324: PUSH
74325: LD_INT 1
74327: NEG
74328: PUSH
74329: LD_INT 2
74331: NEG
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 1
74339: PUSH
74340: LD_INT 2
74342: PUSH
74343: EMPTY
74344: LIST
74345: LIST
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74358: LD_ADDR_VAR 0 37
74362: PUSH
74363: LD_INT 0
74365: PUSH
74366: LD_INT 0
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: LD_INT 0
74375: PUSH
74376: LD_INT 1
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 1
74386: PUSH
74387: LD_INT 0
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 1
74396: PUSH
74397: LD_INT 1
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: LD_INT 0
74406: PUSH
74407: LD_INT 1
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PUSH
74414: LD_INT 1
74416: NEG
74417: PUSH
74418: LD_INT 0
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 1
74427: NEG
74428: PUSH
74429: LD_INT 1
74431: NEG
74432: PUSH
74433: EMPTY
74434: LIST
74435: LIST
74436: PUSH
74437: LD_INT 1
74439: PUSH
74440: LD_INT 1
74442: NEG
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: LD_INT 1
74450: NEG
74451: PUSH
74452: LD_INT 1
74454: PUSH
74455: EMPTY
74456: LIST
74457: LIST
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: LIST
74463: LIST
74464: LIST
74465: LIST
74466: LIST
74467: LIST
74468: LIST
74469: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74470: LD_ADDR_VAR 0 38
74474: PUSH
74475: LD_INT 0
74477: PUSH
74478: LD_INT 0
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 0
74487: PUSH
74488: LD_INT 1
74490: NEG
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 1
74498: PUSH
74499: LD_INT 0
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 1
74508: PUSH
74509: LD_INT 1
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 0
74518: PUSH
74519: LD_INT 1
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 1
74528: NEG
74529: PUSH
74530: LD_INT 0
74532: PUSH
74533: EMPTY
74534: LIST
74535: LIST
74536: PUSH
74537: LD_INT 1
74539: NEG
74540: PUSH
74541: LD_INT 1
74543: NEG
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 2
74551: PUSH
74552: LD_INT 1
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 2
74561: NEG
74562: PUSH
74563: LD_INT 1
74565: NEG
74566: PUSH
74567: EMPTY
74568: LIST
74569: LIST
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: LIST
74575: LIST
74576: LIST
74577: LIST
74578: LIST
74579: LIST
74580: LIST
74581: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74582: LD_ADDR_VAR 0 39
74586: PUSH
74587: LD_INT 0
74589: PUSH
74590: LD_INT 0
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 0
74599: PUSH
74600: LD_INT 1
74602: NEG
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: LD_INT 0
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: LD_INT 1
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: LD_INT 0
74630: PUSH
74631: LD_INT 1
74633: PUSH
74634: EMPTY
74635: LIST
74636: LIST
74637: PUSH
74638: LD_INT 1
74640: NEG
74641: PUSH
74642: LD_INT 0
74644: PUSH
74645: EMPTY
74646: LIST
74647: LIST
74648: PUSH
74649: LD_INT 1
74651: NEG
74652: PUSH
74653: LD_INT 1
74655: NEG
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 1
74663: NEG
74664: PUSH
74665: LD_INT 2
74667: NEG
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: PUSH
74673: LD_INT 1
74675: PUSH
74676: LD_INT 2
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: LIST
74687: LIST
74688: LIST
74689: LIST
74690: LIST
74691: LIST
74692: LIST
74693: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74694: LD_ADDR_VAR 0 40
74698: PUSH
74699: LD_INT 0
74701: PUSH
74702: LD_INT 0
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: PUSH
74709: LD_INT 0
74711: PUSH
74712: LD_INT 1
74714: NEG
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 1
74722: PUSH
74723: LD_INT 0
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 1
74732: PUSH
74733: LD_INT 1
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: LD_INT 0
74742: PUSH
74743: LD_INT 1
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: PUSH
74750: LD_INT 1
74752: NEG
74753: PUSH
74754: LD_INT 0
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 1
74763: NEG
74764: PUSH
74765: LD_INT 1
74767: NEG
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 1
74775: PUSH
74776: LD_INT 1
74778: NEG
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: LD_INT 1
74786: NEG
74787: PUSH
74788: LD_INT 1
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: LIST
74799: LIST
74800: LIST
74801: LIST
74802: LIST
74803: LIST
74804: LIST
74805: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74806: LD_ADDR_VAR 0 41
74810: PUSH
74811: LD_INT 0
74813: PUSH
74814: LD_INT 0
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: LD_INT 1
74826: NEG
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: LD_INT 0
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 1
74844: PUSH
74845: LD_INT 1
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 0
74854: PUSH
74855: LD_INT 1
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: LD_INT 1
74864: NEG
74865: PUSH
74866: LD_INT 0
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: LD_INT 1
74875: NEG
74876: PUSH
74877: LD_INT 1
74879: NEG
74880: PUSH
74881: EMPTY
74882: LIST
74883: LIST
74884: PUSH
74885: LD_INT 1
74887: NEG
74888: PUSH
74889: LD_INT 2
74891: NEG
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 1
74899: PUSH
74900: LD_INT 1
74902: NEG
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 2
74910: PUSH
74911: LD_INT 0
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 2
74920: PUSH
74921: LD_INT 1
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: LD_INT 2
74930: PUSH
74931: LD_INT 2
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 1
74940: PUSH
74941: LD_INT 2
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: LD_INT 1
74950: NEG
74951: PUSH
74952: LD_INT 1
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: PUSH
74959: LD_INT 2
74961: NEG
74962: PUSH
74963: LD_INT 0
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: LD_INT 2
74972: NEG
74973: PUSH
74974: LD_INT 1
74976: NEG
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PUSH
74982: LD_INT 2
74984: NEG
74985: PUSH
74986: LD_INT 2
74988: NEG
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 2
74996: NEG
74997: PUSH
74998: LD_INT 3
75000: NEG
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: PUSH
75006: LD_INT 2
75008: PUSH
75009: LD_INT 1
75011: NEG
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 3
75019: PUSH
75020: LD_INT 0
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: LD_INT 3
75029: PUSH
75030: LD_INT 1
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 3
75039: PUSH
75040: LD_INT 2
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 3
75049: PUSH
75050: LD_INT 3
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 2
75059: PUSH
75060: LD_INT 3
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 2
75069: NEG
75070: PUSH
75071: LD_INT 1
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: PUSH
75078: LD_INT 3
75080: NEG
75081: PUSH
75082: LD_INT 0
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: PUSH
75089: LD_INT 3
75091: NEG
75092: PUSH
75093: LD_INT 1
75095: NEG
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 3
75103: NEG
75104: PUSH
75105: LD_INT 2
75107: NEG
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 3
75115: NEG
75116: PUSH
75117: LD_INT 3
75119: NEG
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: LIST
75143: LIST
75144: LIST
75145: LIST
75146: LIST
75147: LIST
75148: LIST
75149: LIST
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75156: LD_ADDR_VAR 0 42
75160: PUSH
75161: LD_INT 0
75163: PUSH
75164: LD_INT 0
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 0
75173: PUSH
75174: LD_INT 1
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 1
75184: PUSH
75185: LD_INT 0
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 1
75194: PUSH
75195: LD_INT 1
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: LD_INT 0
75204: PUSH
75205: LD_INT 1
75207: PUSH
75208: EMPTY
75209: LIST
75210: LIST
75211: PUSH
75212: LD_INT 1
75214: NEG
75215: PUSH
75216: LD_INT 0
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 1
75225: NEG
75226: PUSH
75227: LD_INT 1
75229: NEG
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: PUSH
75235: LD_INT 1
75237: NEG
75238: PUSH
75239: LD_INT 2
75241: NEG
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: LD_INT 0
75249: PUSH
75250: LD_INT 2
75252: NEG
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 1
75260: PUSH
75261: LD_INT 1
75263: NEG
75264: PUSH
75265: EMPTY
75266: LIST
75267: LIST
75268: PUSH
75269: LD_INT 2
75271: PUSH
75272: LD_INT 1
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 2
75281: PUSH
75282: LD_INT 2
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 1
75291: PUSH
75292: LD_INT 2
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 0
75301: PUSH
75302: LD_INT 2
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: LD_INT 1
75311: NEG
75312: PUSH
75313: LD_INT 1
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 2
75322: NEG
75323: PUSH
75324: LD_INT 1
75326: NEG
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: PUSH
75332: LD_INT 2
75334: NEG
75335: PUSH
75336: LD_INT 2
75338: NEG
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 2
75346: NEG
75347: PUSH
75348: LD_INT 3
75350: NEG
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 1
75358: NEG
75359: PUSH
75360: LD_INT 3
75362: NEG
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 0
75370: PUSH
75371: LD_INT 3
75373: NEG
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 1
75381: PUSH
75382: LD_INT 2
75384: NEG
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 3
75392: PUSH
75393: LD_INT 2
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: PUSH
75400: LD_INT 3
75402: PUSH
75403: LD_INT 3
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 2
75412: PUSH
75413: LD_INT 3
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 1
75422: PUSH
75423: LD_INT 3
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: PUSH
75430: LD_INT 0
75432: PUSH
75433: LD_INT 3
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 1
75442: NEG
75443: PUSH
75444: LD_INT 2
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 3
75453: NEG
75454: PUSH
75455: LD_INT 2
75457: NEG
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 3
75465: NEG
75466: PUSH
75467: LD_INT 3
75469: NEG
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: PUSH
75475: EMPTY
75476: LIST
75477: LIST
75478: LIST
75479: LIST
75480: LIST
75481: LIST
75482: LIST
75483: LIST
75484: LIST
75485: LIST
75486: LIST
75487: LIST
75488: LIST
75489: LIST
75490: LIST
75491: LIST
75492: LIST
75493: LIST
75494: LIST
75495: LIST
75496: LIST
75497: LIST
75498: LIST
75499: LIST
75500: LIST
75501: LIST
75502: LIST
75503: LIST
75504: LIST
75505: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75506: LD_ADDR_VAR 0 43
75510: PUSH
75511: LD_INT 0
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PUSH
75521: LD_INT 0
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: PUSH
75532: LD_INT 1
75534: PUSH
75535: LD_INT 0
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: PUSH
75542: LD_INT 1
75544: PUSH
75545: LD_INT 1
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 0
75554: PUSH
75555: LD_INT 1
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 1
75564: NEG
75565: PUSH
75566: LD_INT 0
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: LD_INT 1
75575: NEG
75576: PUSH
75577: LD_INT 1
75579: NEG
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 1
75587: NEG
75588: PUSH
75589: LD_INT 2
75591: NEG
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 0
75599: PUSH
75600: LD_INT 2
75602: NEG
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 1
75610: PUSH
75611: LD_INT 1
75613: NEG
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: PUSH
75619: LD_INT 2
75621: PUSH
75622: LD_INT 0
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 2
75631: PUSH
75632: LD_INT 1
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: PUSH
75639: LD_INT 1
75641: PUSH
75642: LD_INT 2
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: PUSH
75649: LD_INT 0
75651: PUSH
75652: LD_INT 2
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 1
75661: NEG
75662: PUSH
75663: LD_INT 1
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 2
75672: NEG
75673: PUSH
75674: LD_INT 0
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: PUSH
75681: LD_INT 2
75683: NEG
75684: PUSH
75685: LD_INT 1
75687: NEG
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 1
75695: NEG
75696: PUSH
75697: LD_INT 3
75699: NEG
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 0
75707: PUSH
75708: LD_INT 3
75710: NEG
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: LD_INT 1
75718: PUSH
75719: LD_INT 2
75721: NEG
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 2
75729: PUSH
75730: LD_INT 1
75732: NEG
75733: PUSH
75734: EMPTY
75735: LIST
75736: LIST
75737: PUSH
75738: LD_INT 3
75740: PUSH
75741: LD_INT 0
75743: PUSH
75744: EMPTY
75745: LIST
75746: LIST
75747: PUSH
75748: LD_INT 3
75750: PUSH
75751: LD_INT 1
75753: PUSH
75754: EMPTY
75755: LIST
75756: LIST
75757: PUSH
75758: LD_INT 1
75760: PUSH
75761: LD_INT 3
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 0
75770: PUSH
75771: LD_INT 3
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: LD_INT 1
75780: NEG
75781: PUSH
75782: LD_INT 2
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: LD_INT 2
75791: NEG
75792: PUSH
75793: LD_INT 1
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PUSH
75800: LD_INT 3
75802: NEG
75803: PUSH
75804: LD_INT 0
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 3
75813: NEG
75814: PUSH
75815: LD_INT 1
75817: NEG
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: LIST
75827: LIST
75828: LIST
75829: LIST
75830: LIST
75831: LIST
75832: LIST
75833: LIST
75834: LIST
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: LIST
75851: LIST
75852: LIST
75853: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75854: LD_ADDR_VAR 0 44
75858: PUSH
75859: LD_INT 0
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: EMPTY
75866: LIST
75867: LIST
75868: PUSH
75869: LD_INT 0
75871: PUSH
75872: LD_INT 1
75874: NEG
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 1
75882: PUSH
75883: LD_INT 0
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: LD_INT 1
75892: PUSH
75893: LD_INT 1
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: PUSH
75900: LD_INT 0
75902: PUSH
75903: LD_INT 1
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 1
75912: NEG
75913: PUSH
75914: LD_INT 0
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: PUSH
75921: LD_INT 1
75923: NEG
75924: PUSH
75925: LD_INT 1
75927: NEG
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: LD_INT 1
75935: NEG
75936: PUSH
75937: LD_INT 2
75939: NEG
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 1
75947: PUSH
75948: LD_INT 1
75950: NEG
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 2
75958: PUSH
75959: LD_INT 0
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 2
75968: PUSH
75969: LD_INT 1
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: PUSH
75976: LD_INT 2
75978: PUSH
75979: LD_INT 2
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 1
75988: PUSH
75989: LD_INT 2
75991: PUSH
75992: EMPTY
75993: LIST
75994: LIST
75995: PUSH
75996: LD_INT 1
75998: NEG
75999: PUSH
76000: LD_INT 1
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 2
76009: NEG
76010: PUSH
76011: LD_INT 0
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: LD_INT 2
76020: NEG
76021: PUSH
76022: LD_INT 1
76024: NEG
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: PUSH
76030: LD_INT 2
76032: NEG
76033: PUSH
76034: LD_INT 2
76036: NEG
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 2
76044: NEG
76045: PUSH
76046: LD_INT 3
76048: NEG
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: PUSH
76054: LD_INT 2
76056: PUSH
76057: LD_INT 1
76059: NEG
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: PUSH
76065: LD_INT 3
76067: PUSH
76068: LD_INT 0
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PUSH
76075: LD_INT 3
76077: PUSH
76078: LD_INT 1
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 3
76087: PUSH
76088: LD_INT 2
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 3
76097: PUSH
76098: LD_INT 3
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 2
76107: PUSH
76108: LD_INT 3
76110: PUSH
76111: EMPTY
76112: LIST
76113: LIST
76114: PUSH
76115: LD_INT 2
76117: NEG
76118: PUSH
76119: LD_INT 1
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: LD_INT 3
76128: NEG
76129: PUSH
76130: LD_INT 0
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: PUSH
76137: LD_INT 3
76139: NEG
76140: PUSH
76141: LD_INT 1
76143: NEG
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 3
76151: NEG
76152: PUSH
76153: LD_INT 2
76155: NEG
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 3
76163: NEG
76164: PUSH
76165: LD_INT 3
76167: NEG
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: LIST
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: LIST
76182: LIST
76183: LIST
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: LIST
76203: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76204: LD_ADDR_VAR 0 45
76208: PUSH
76209: LD_INT 0
76211: PUSH
76212: LD_INT 0
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 0
76221: PUSH
76222: LD_INT 1
76224: NEG
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 1
76232: PUSH
76233: LD_INT 0
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 1
76242: PUSH
76243: LD_INT 1
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: LD_INT 0
76252: PUSH
76253: LD_INT 1
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: LD_INT 1
76262: NEG
76263: PUSH
76264: LD_INT 0
76266: PUSH
76267: EMPTY
76268: LIST
76269: LIST
76270: PUSH
76271: LD_INT 1
76273: NEG
76274: PUSH
76275: LD_INT 1
76277: NEG
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 1
76285: NEG
76286: PUSH
76287: LD_INT 2
76289: NEG
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: PUSH
76295: LD_INT 0
76297: PUSH
76298: LD_INT 2
76300: NEG
76301: PUSH
76302: EMPTY
76303: LIST
76304: LIST
76305: PUSH
76306: LD_INT 1
76308: PUSH
76309: LD_INT 1
76311: NEG
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 2
76319: PUSH
76320: LD_INT 1
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 2
76329: PUSH
76330: LD_INT 2
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 1
76339: PUSH
76340: LD_INT 2
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: PUSH
76347: LD_INT 0
76349: PUSH
76350: LD_INT 2
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 1
76359: NEG
76360: PUSH
76361: LD_INT 1
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 2
76370: NEG
76371: PUSH
76372: LD_INT 1
76374: NEG
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: LD_INT 2
76382: NEG
76383: PUSH
76384: LD_INT 2
76386: NEG
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 2
76394: NEG
76395: PUSH
76396: LD_INT 3
76398: NEG
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 1
76406: NEG
76407: PUSH
76408: LD_INT 3
76410: NEG
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 0
76418: PUSH
76419: LD_INT 3
76421: NEG
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 1
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 3
76440: PUSH
76441: LD_INT 2
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 3
76450: PUSH
76451: LD_INT 3
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: PUSH
76458: LD_INT 2
76460: PUSH
76461: LD_INT 3
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: PUSH
76468: LD_INT 1
76470: PUSH
76471: LD_INT 3
76473: PUSH
76474: EMPTY
76475: LIST
76476: LIST
76477: PUSH
76478: LD_INT 0
76480: PUSH
76481: LD_INT 3
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: PUSH
76488: LD_INT 1
76490: NEG
76491: PUSH
76492: LD_INT 2
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: PUSH
76499: LD_INT 3
76501: NEG
76502: PUSH
76503: LD_INT 2
76505: NEG
76506: PUSH
76507: EMPTY
76508: LIST
76509: LIST
76510: PUSH
76511: LD_INT 3
76513: NEG
76514: PUSH
76515: LD_INT 3
76517: NEG
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76554: LD_ADDR_VAR 0 46
76558: PUSH
76559: LD_INT 0
76561: PUSH
76562: LD_INT 0
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 0
76571: PUSH
76572: LD_INT 1
76574: NEG
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 1
76582: PUSH
76583: LD_INT 0
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 1
76592: PUSH
76593: LD_INT 1
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 0
76602: PUSH
76603: LD_INT 1
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 1
76612: NEG
76613: PUSH
76614: LD_INT 0
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 1
76623: NEG
76624: PUSH
76625: LD_INT 1
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 1
76635: NEG
76636: PUSH
76637: LD_INT 2
76639: NEG
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 0
76647: PUSH
76648: LD_INT 2
76650: NEG
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 1
76658: PUSH
76659: LD_INT 1
76661: NEG
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: LD_INT 0
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PUSH
76677: LD_INT 2
76679: PUSH
76680: LD_INT 1
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 1
76689: PUSH
76690: LD_INT 2
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 0
76699: PUSH
76700: LD_INT 2
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: LD_INT 1
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 2
76720: NEG
76721: PUSH
76722: LD_INT 0
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 2
76731: NEG
76732: PUSH
76733: LD_INT 1
76735: NEG
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 1
76743: NEG
76744: PUSH
76745: LD_INT 3
76747: NEG
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 0
76755: PUSH
76756: LD_INT 3
76758: NEG
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 1
76766: PUSH
76767: LD_INT 2
76769: NEG
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 2
76777: PUSH
76778: LD_INT 1
76780: NEG
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 3
76788: PUSH
76789: LD_INT 0
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 3
76798: PUSH
76799: LD_INT 1
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 1
76808: PUSH
76809: LD_INT 3
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 0
76818: PUSH
76819: LD_INT 3
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 1
76828: NEG
76829: PUSH
76830: LD_INT 2
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 2
76839: NEG
76840: PUSH
76841: LD_INT 1
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: LD_INT 3
76850: NEG
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 3
76861: NEG
76862: PUSH
76863: LD_INT 1
76865: NEG
76866: PUSH
76867: EMPTY
76868: LIST
76869: LIST
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: LIST
76875: LIST
76876: LIST
76877: LIST
76878: LIST
76879: LIST
76880: LIST
76881: LIST
76882: LIST
76883: LIST
76884: LIST
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76902: LD_ADDR_VAR 0 47
76906: PUSH
76907: LD_INT 0
76909: PUSH
76910: LD_INT 0
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 0
76919: PUSH
76920: LD_INT 1
76922: NEG
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 1
76930: PUSH
76931: LD_INT 0
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: LD_INT 1
76940: PUSH
76941: LD_INT 1
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 0
76950: PUSH
76951: LD_INT 1
76953: PUSH
76954: EMPTY
76955: LIST
76956: LIST
76957: PUSH
76958: LD_INT 1
76960: NEG
76961: PUSH
76962: LD_INT 0
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 1
76971: NEG
76972: PUSH
76973: LD_INT 1
76975: NEG
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: LD_INT 1
76983: NEG
76984: PUSH
76985: LD_INT 2
76987: NEG
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 0
76995: PUSH
76996: LD_INT 2
76998: NEG
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 1
77006: PUSH
77007: LD_INT 1
77009: NEG
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 2
77017: NEG
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 2
77029: NEG
77030: PUSH
77031: LD_INT 2
77033: NEG
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: LIST
77043: LIST
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: LIST
77050: LIST
77051: LIST
77052: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77053: LD_ADDR_VAR 0 48
77057: PUSH
77058: LD_INT 0
77060: PUSH
77061: LD_INT 0
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 0
77070: PUSH
77071: LD_INT 1
77073: NEG
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 1
77081: PUSH
77082: LD_INT 0
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 1
77091: PUSH
77092: LD_INT 1
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 0
77101: PUSH
77102: LD_INT 1
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: LD_INT 1
77111: NEG
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 1
77122: NEG
77123: PUSH
77124: LD_INT 1
77126: NEG
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PUSH
77132: LD_INT 1
77134: NEG
77135: PUSH
77136: LD_INT 2
77138: NEG
77139: PUSH
77140: EMPTY
77141: LIST
77142: LIST
77143: PUSH
77144: LD_INT 0
77146: PUSH
77147: LD_INT 2
77149: NEG
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: LD_INT 1
77157: PUSH
77158: LD_INT 1
77160: NEG
77161: PUSH
77162: EMPTY
77163: LIST
77164: LIST
77165: PUSH
77166: LD_INT 2
77168: PUSH
77169: LD_INT 0
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: PUSH
77176: LD_INT 2
77178: PUSH
77179: LD_INT 1
77181: PUSH
77182: EMPTY
77183: LIST
77184: LIST
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: LIST
77190: LIST
77191: LIST
77192: LIST
77193: LIST
77194: LIST
77195: LIST
77196: LIST
77197: LIST
77198: LIST
77199: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77200: LD_ADDR_VAR 0 49
77204: PUSH
77205: LD_INT 0
77207: PUSH
77208: LD_INT 0
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 0
77217: PUSH
77218: LD_INT 1
77220: NEG
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: LD_INT 1
77228: PUSH
77229: LD_INT 0
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 1
77238: PUSH
77239: LD_INT 1
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 0
77248: PUSH
77249: LD_INT 1
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 1
77258: NEG
77259: PUSH
77260: LD_INT 0
77262: PUSH
77263: EMPTY
77264: LIST
77265: LIST
77266: PUSH
77267: LD_INT 1
77269: NEG
77270: PUSH
77271: LD_INT 1
77273: NEG
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: PUSH
77279: LD_INT 1
77281: PUSH
77282: LD_INT 1
77284: NEG
77285: PUSH
77286: EMPTY
77287: LIST
77288: LIST
77289: PUSH
77290: LD_INT 2
77292: PUSH
77293: LD_INT 0
77295: PUSH
77296: EMPTY
77297: LIST
77298: LIST
77299: PUSH
77300: LD_INT 2
77302: PUSH
77303: LD_INT 1
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: PUSH
77310: LD_INT 2
77312: PUSH
77313: LD_INT 2
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 1
77322: PUSH
77323: LD_INT 2
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: LIST
77334: LIST
77335: LIST
77336: LIST
77337: LIST
77338: LIST
77339: LIST
77340: LIST
77341: LIST
77342: LIST
77343: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77344: LD_ADDR_VAR 0 50
77348: PUSH
77349: LD_INT 0
77351: PUSH
77352: LD_INT 0
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 0
77361: PUSH
77362: LD_INT 1
77364: NEG
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PUSH
77370: LD_INT 1
77372: PUSH
77373: LD_INT 0
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 1
77382: PUSH
77383: LD_INT 1
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 0
77392: PUSH
77393: LD_INT 1
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: PUSH
77400: LD_INT 1
77402: NEG
77403: PUSH
77404: LD_INT 0
77406: PUSH
77407: EMPTY
77408: LIST
77409: LIST
77410: PUSH
77411: LD_INT 1
77413: NEG
77414: PUSH
77415: LD_INT 1
77417: NEG
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: PUSH
77423: LD_INT 2
77425: PUSH
77426: LD_INT 1
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 2
77435: PUSH
77436: LD_INT 2
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: LD_INT 1
77445: PUSH
77446: LD_INT 2
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: PUSH
77453: LD_INT 0
77455: PUSH
77456: LD_INT 2
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 1
77465: NEG
77466: PUSH
77467: LD_INT 1
77469: PUSH
77470: EMPTY
77471: LIST
77472: LIST
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: LIST
77480: LIST
77481: LIST
77482: LIST
77483: LIST
77484: LIST
77485: LIST
77486: LIST
77487: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77488: LD_ADDR_VAR 0 51
77492: PUSH
77493: LD_INT 0
77495: PUSH
77496: LD_INT 0
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: PUSH
77503: LD_INT 0
77505: PUSH
77506: LD_INT 1
77508: NEG
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 1
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: PUSH
77524: LD_INT 1
77526: PUSH
77527: LD_INT 1
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: PUSH
77534: LD_INT 0
77536: PUSH
77537: LD_INT 1
77539: PUSH
77540: EMPTY
77541: LIST
77542: LIST
77543: PUSH
77544: LD_INT 1
77546: NEG
77547: PUSH
77548: LD_INT 0
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PUSH
77555: LD_INT 1
77557: NEG
77558: PUSH
77559: LD_INT 1
77561: NEG
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PUSH
77567: LD_INT 1
77569: PUSH
77570: LD_INT 2
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 0
77579: PUSH
77580: LD_INT 2
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 1
77589: NEG
77590: PUSH
77591: LD_INT 1
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 2
77600: NEG
77601: PUSH
77602: LD_INT 0
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 2
77611: NEG
77612: PUSH
77613: LD_INT 1
77615: NEG
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: LIST
77630: LIST
77631: LIST
77632: LIST
77633: LIST
77634: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77635: LD_ADDR_VAR 0 52
77639: PUSH
77640: LD_INT 0
77642: PUSH
77643: LD_INT 0
77645: PUSH
77646: EMPTY
77647: LIST
77648: LIST
77649: PUSH
77650: LD_INT 0
77652: PUSH
77653: LD_INT 1
77655: NEG
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: PUSH
77661: LD_INT 1
77663: PUSH
77664: LD_INT 0
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: PUSH
77671: LD_INT 1
77673: PUSH
77674: LD_INT 1
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: LD_INT 0
77683: PUSH
77684: LD_INT 1
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 1
77693: NEG
77694: PUSH
77695: LD_INT 0
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: PUSH
77702: LD_INT 1
77704: NEG
77705: PUSH
77706: LD_INT 1
77708: NEG
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: PUSH
77714: LD_INT 1
77716: NEG
77717: PUSH
77718: LD_INT 2
77720: NEG
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 1
77728: NEG
77729: PUSH
77730: LD_INT 1
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 2
77739: NEG
77740: PUSH
77741: LD_INT 0
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: LD_INT 2
77750: NEG
77751: PUSH
77752: LD_INT 1
77754: NEG
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 2
77762: NEG
77763: PUSH
77764: LD_INT 2
77766: NEG
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: LIST
77782: LIST
77783: LIST
77784: LIST
77785: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77786: LD_ADDR_VAR 0 53
77790: PUSH
77791: LD_INT 0
77793: PUSH
77794: LD_INT 0
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 0
77803: PUSH
77804: LD_INT 1
77806: NEG
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 1
77814: PUSH
77815: LD_INT 0
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 1
77824: PUSH
77825: LD_INT 1
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 0
77834: PUSH
77835: LD_INT 1
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PUSH
77842: LD_INT 1
77844: NEG
77845: PUSH
77846: LD_INT 0
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 1
77855: NEG
77856: PUSH
77857: LD_INT 1
77859: NEG
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: LD_INT 1
77867: NEG
77868: PUSH
77869: LD_INT 2
77871: NEG
77872: PUSH
77873: EMPTY
77874: LIST
77875: LIST
77876: PUSH
77877: LD_INT 0
77879: PUSH
77880: LD_INT 2
77882: NEG
77883: PUSH
77884: EMPTY
77885: LIST
77886: LIST
77887: PUSH
77888: LD_INT 1
77890: PUSH
77891: LD_INT 1
77893: NEG
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 2
77901: PUSH
77902: LD_INT 0
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 2
77911: PUSH
77912: LD_INT 1
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 2
77921: PUSH
77922: LD_INT 2
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 1
77931: PUSH
77932: LD_INT 2
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 0
77941: PUSH
77942: LD_INT 2
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 1
77951: NEG
77952: PUSH
77953: LD_INT 1
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: LD_INT 2
77962: NEG
77963: PUSH
77964: LD_INT 0
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 2
77973: NEG
77974: PUSH
77975: LD_INT 1
77977: NEG
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: PUSH
77983: LD_INT 2
77985: NEG
77986: PUSH
77987: LD_INT 2
77989: NEG
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: EMPTY
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78016: LD_ADDR_VAR 0 54
78020: PUSH
78021: LD_INT 0
78023: PUSH
78024: LD_INT 0
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 0
78033: PUSH
78034: LD_INT 1
78036: NEG
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PUSH
78042: LD_INT 1
78044: PUSH
78045: LD_INT 0
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: LD_INT 1
78054: PUSH
78055: LD_INT 1
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: LD_INT 0
78064: PUSH
78065: LD_INT 1
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PUSH
78072: LD_INT 1
78074: NEG
78075: PUSH
78076: LD_INT 0
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 1
78085: NEG
78086: PUSH
78087: LD_INT 1
78089: NEG
78090: PUSH
78091: EMPTY
78092: LIST
78093: LIST
78094: PUSH
78095: LD_INT 1
78097: NEG
78098: PUSH
78099: LD_INT 2
78101: NEG
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: LD_INT 0
78109: PUSH
78110: LD_INT 2
78112: NEG
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 1
78120: PUSH
78121: LD_INT 1
78123: NEG
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 2
78131: PUSH
78132: LD_INT 0
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 2
78141: PUSH
78142: LD_INT 1
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 2
78151: PUSH
78152: LD_INT 2
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 1
78161: PUSH
78162: LD_INT 2
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 0
78171: PUSH
78172: LD_INT 2
78174: PUSH
78175: EMPTY
78176: LIST
78177: LIST
78178: PUSH
78179: LD_INT 1
78181: NEG
78182: PUSH
78183: LD_INT 1
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 2
78192: NEG
78193: PUSH
78194: LD_INT 0
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 2
78203: NEG
78204: PUSH
78205: LD_INT 1
78207: NEG
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 2
78215: NEG
78216: PUSH
78217: LD_INT 2
78219: NEG
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78246: LD_ADDR_VAR 0 55
78250: PUSH
78251: LD_INT 0
78253: PUSH
78254: LD_INT 0
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 0
78263: PUSH
78264: LD_INT 1
78266: NEG
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 1
78274: PUSH
78275: LD_INT 0
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: PUSH
78282: LD_INT 1
78284: PUSH
78285: LD_INT 1
78287: PUSH
78288: EMPTY
78289: LIST
78290: LIST
78291: PUSH
78292: LD_INT 0
78294: PUSH
78295: LD_INT 1
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 1
78304: NEG
78305: PUSH
78306: LD_INT 0
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 1
78315: NEG
78316: PUSH
78317: LD_INT 1
78319: NEG
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: PUSH
78325: LD_INT 1
78327: NEG
78328: PUSH
78329: LD_INT 2
78331: NEG
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 0
78339: PUSH
78340: LD_INT 2
78342: NEG
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 1
78350: PUSH
78351: LD_INT 1
78353: NEG
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: PUSH
78359: LD_INT 2
78361: PUSH
78362: LD_INT 0
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 2
78371: PUSH
78372: LD_INT 1
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 2
78381: PUSH
78382: LD_INT 2
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PUSH
78389: LD_INT 1
78391: PUSH
78392: LD_INT 2
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 0
78401: PUSH
78402: LD_INT 2
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 1
78411: NEG
78412: PUSH
78413: LD_INT 1
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 2
78422: NEG
78423: PUSH
78424: LD_INT 0
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 2
78433: NEG
78434: PUSH
78435: LD_INT 1
78437: NEG
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: PUSH
78443: LD_INT 2
78445: NEG
78446: PUSH
78447: LD_INT 2
78449: NEG
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: EMPTY
78456: LIST
78457: LIST
78458: LIST
78459: LIST
78460: LIST
78461: LIST
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: LIST
78468: LIST
78469: LIST
78470: LIST
78471: LIST
78472: LIST
78473: LIST
78474: LIST
78475: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78476: LD_ADDR_VAR 0 56
78480: PUSH
78481: LD_INT 0
78483: PUSH
78484: LD_INT 0
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: PUSH
78491: LD_INT 0
78493: PUSH
78494: LD_INT 1
78496: NEG
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 1
78504: PUSH
78505: LD_INT 0
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 1
78514: PUSH
78515: LD_INT 1
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: LD_INT 0
78524: PUSH
78525: LD_INT 1
78527: PUSH
78528: EMPTY
78529: LIST
78530: LIST
78531: PUSH
78532: LD_INT 1
78534: NEG
78535: PUSH
78536: LD_INT 0
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 1
78545: NEG
78546: PUSH
78547: LD_INT 1
78549: NEG
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: PUSH
78555: LD_INT 1
78557: NEG
78558: PUSH
78559: LD_INT 2
78561: NEG
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 0
78569: PUSH
78570: LD_INT 2
78572: NEG
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 1
78580: PUSH
78581: LD_INT 1
78583: NEG
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 2
78591: PUSH
78592: LD_INT 0
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: LD_INT 2
78601: PUSH
78602: LD_INT 1
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 2
78611: PUSH
78612: LD_INT 2
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 1
78621: PUSH
78622: LD_INT 2
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 0
78631: PUSH
78632: LD_INT 2
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 1
78641: NEG
78642: PUSH
78643: LD_INT 1
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PUSH
78650: LD_INT 2
78652: NEG
78653: PUSH
78654: LD_INT 0
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 2
78663: NEG
78664: PUSH
78665: LD_INT 1
78667: NEG
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 2
78675: NEG
78676: PUSH
78677: LD_INT 2
78679: NEG
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: LIST
78689: LIST
78690: LIST
78691: LIST
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78706: LD_ADDR_VAR 0 57
78710: PUSH
78711: LD_INT 0
78713: PUSH
78714: LD_INT 0
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 0
78723: PUSH
78724: LD_INT 1
78726: NEG
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 1
78734: PUSH
78735: LD_INT 0
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 1
78744: PUSH
78745: LD_INT 1
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 0
78754: PUSH
78755: LD_INT 1
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: PUSH
78762: LD_INT 1
78764: NEG
78765: PUSH
78766: LD_INT 0
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 1
78775: NEG
78776: PUSH
78777: LD_INT 1
78779: NEG
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: LD_INT 1
78787: NEG
78788: PUSH
78789: LD_INT 2
78791: NEG
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: PUSH
78797: LD_INT 0
78799: PUSH
78800: LD_INT 2
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 1
78810: PUSH
78811: LD_INT 1
78813: NEG
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: LD_INT 2
78821: PUSH
78822: LD_INT 0
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PUSH
78829: LD_INT 2
78831: PUSH
78832: LD_INT 1
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 2
78841: PUSH
78842: LD_INT 2
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 1
78851: PUSH
78852: LD_INT 2
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 0
78861: PUSH
78862: LD_INT 2
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 1
78871: NEG
78872: PUSH
78873: LD_INT 1
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: LD_INT 2
78882: NEG
78883: PUSH
78884: LD_INT 0
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: PUSH
78891: LD_INT 2
78893: NEG
78894: PUSH
78895: LD_INT 1
78897: NEG
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: LD_INT 2
78905: NEG
78906: PUSH
78907: LD_INT 2
78909: NEG
78910: PUSH
78911: EMPTY
78912: LIST
78913: LIST
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78936: LD_ADDR_VAR 0 58
78940: PUSH
78941: LD_INT 0
78943: PUSH
78944: LD_INT 0
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 0
78953: PUSH
78954: LD_INT 1
78956: NEG
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 1
78964: PUSH
78965: LD_INT 0
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 1
78974: PUSH
78975: LD_INT 1
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 0
78984: PUSH
78985: LD_INT 1
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: PUSH
78992: LD_INT 1
78994: NEG
78995: PUSH
78996: LD_INT 0
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 1
79005: NEG
79006: PUSH
79007: LD_INT 1
79009: NEG
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: LD_INT 1
79017: NEG
79018: PUSH
79019: LD_INT 2
79021: NEG
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 0
79029: PUSH
79030: LD_INT 2
79032: NEG
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: PUSH
79041: LD_INT 1
79043: NEG
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 2
79051: PUSH
79052: LD_INT 0
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 2
79061: PUSH
79062: LD_INT 1
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 2
79071: PUSH
79072: LD_INT 2
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 1
79081: PUSH
79082: LD_INT 2
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 0
79091: PUSH
79092: LD_INT 2
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 1
79101: NEG
79102: PUSH
79103: LD_INT 1
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: LD_INT 2
79112: NEG
79113: PUSH
79114: LD_INT 0
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 2
79123: NEG
79124: PUSH
79125: LD_INT 1
79127: NEG
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 2
79135: NEG
79136: PUSH
79137: LD_INT 2
79139: NEG
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: LIST
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: LIST
79165: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79166: LD_ADDR_VAR 0 59
79170: PUSH
79171: LD_INT 0
79173: PUSH
79174: LD_INT 0
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 0
79183: PUSH
79184: LD_INT 1
79186: NEG
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 1
79194: PUSH
79195: LD_INT 0
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 1
79204: PUSH
79205: LD_INT 1
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 0
79214: PUSH
79215: LD_INT 1
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 1
79224: NEG
79225: PUSH
79226: LD_INT 0
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 1
79235: NEG
79236: PUSH
79237: LD_INT 1
79239: NEG
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: LIST
79249: LIST
79250: LIST
79251: LIST
79252: LIST
79253: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79254: LD_ADDR_VAR 0 60
79258: PUSH
79259: LD_INT 0
79261: PUSH
79262: LD_INT 0
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 0
79271: PUSH
79272: LD_INT 1
79274: NEG
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 1
79282: PUSH
79283: LD_INT 0
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 1
79292: PUSH
79293: LD_INT 1
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 0
79302: PUSH
79303: LD_INT 1
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 1
79312: NEG
79313: PUSH
79314: LD_INT 0
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: PUSH
79321: LD_INT 1
79323: NEG
79324: PUSH
79325: LD_INT 1
79327: NEG
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79342: LD_ADDR_VAR 0 61
79346: PUSH
79347: LD_INT 0
79349: PUSH
79350: LD_INT 0
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 0
79359: PUSH
79360: LD_INT 1
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 1
79370: PUSH
79371: LD_INT 0
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: PUSH
79378: LD_INT 1
79380: PUSH
79381: LD_INT 1
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 0
79390: PUSH
79391: LD_INT 1
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 1
79400: NEG
79401: PUSH
79402: LD_INT 0
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 1
79411: NEG
79412: PUSH
79413: LD_INT 1
79415: NEG
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79430: LD_ADDR_VAR 0 62
79434: PUSH
79435: LD_INT 0
79437: PUSH
79438: LD_INT 0
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 0
79447: PUSH
79448: LD_INT 1
79450: NEG
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 1
79458: PUSH
79459: LD_INT 0
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 1
79468: PUSH
79469: LD_INT 1
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 0
79478: PUSH
79479: LD_INT 1
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 1
79488: NEG
79489: PUSH
79490: LD_INT 0
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 1
79499: NEG
79500: PUSH
79501: LD_INT 1
79503: NEG
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: EMPTY
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79518: LD_ADDR_VAR 0 63
79522: PUSH
79523: LD_INT 0
79525: PUSH
79526: LD_INT 0
79528: PUSH
79529: EMPTY
79530: LIST
79531: LIST
79532: PUSH
79533: LD_INT 0
79535: PUSH
79536: LD_INT 1
79538: NEG
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 1
79546: PUSH
79547: LD_INT 0
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 1
79556: PUSH
79557: LD_INT 1
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 0
79566: PUSH
79567: LD_INT 1
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 1
79576: NEG
79577: PUSH
79578: LD_INT 0
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 1
79587: NEG
79588: PUSH
79589: LD_INT 1
79591: NEG
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79606: LD_ADDR_VAR 0 64
79610: PUSH
79611: LD_INT 0
79613: PUSH
79614: LD_INT 0
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: PUSH
79621: LD_INT 0
79623: PUSH
79624: LD_INT 1
79626: NEG
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PUSH
79632: LD_INT 1
79634: PUSH
79635: LD_INT 0
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 1
79644: PUSH
79645: LD_INT 1
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 0
79654: PUSH
79655: LD_INT 1
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 1
79664: NEG
79665: PUSH
79666: LD_INT 0
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: LD_INT 1
79675: NEG
79676: PUSH
79677: LD_INT 1
79679: NEG
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: LIST
79693: ST_TO_ADDR
// end ; 1 :
79694: GO 85591
79696: LD_INT 1
79698: DOUBLE
79699: EQUAL
79700: IFTRUE 79704
79702: GO 82327
79704: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79705: LD_ADDR_VAR 0 11
79709: PUSH
79710: LD_INT 1
79712: NEG
79713: PUSH
79714: LD_INT 3
79716: NEG
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 0
79724: PUSH
79725: LD_INT 3
79727: NEG
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 1
79735: PUSH
79736: LD_INT 2
79738: NEG
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: LIST
79748: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79749: LD_ADDR_VAR 0 12
79753: PUSH
79754: LD_INT 2
79756: PUSH
79757: LD_INT 1
79759: NEG
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 3
79767: PUSH
79768: LD_INT 0
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 3
79777: PUSH
79778: LD_INT 1
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: EMPTY
79786: LIST
79787: LIST
79788: LIST
79789: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79790: LD_ADDR_VAR 0 13
79794: PUSH
79795: LD_INT 3
79797: PUSH
79798: LD_INT 2
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 3
79807: PUSH
79808: LD_INT 3
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 2
79817: PUSH
79818: LD_INT 3
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: LIST
79829: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79830: LD_ADDR_VAR 0 14
79834: PUSH
79835: LD_INT 1
79837: PUSH
79838: LD_INT 3
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 0
79847: PUSH
79848: LD_INT 3
79850: PUSH
79851: EMPTY
79852: LIST
79853: LIST
79854: PUSH
79855: LD_INT 1
79857: NEG
79858: PUSH
79859: LD_INT 2
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: LIST
79870: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79871: LD_ADDR_VAR 0 15
79875: PUSH
79876: LD_INT 2
79878: NEG
79879: PUSH
79880: LD_INT 1
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: PUSH
79887: LD_INT 3
79889: NEG
79890: PUSH
79891: LD_INT 0
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 3
79900: NEG
79901: PUSH
79902: LD_INT 1
79904: NEG
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: LIST
79914: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79915: LD_ADDR_VAR 0 16
79919: PUSH
79920: LD_INT 2
79922: NEG
79923: PUSH
79924: LD_INT 3
79926: NEG
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 3
79934: NEG
79935: PUSH
79936: LD_INT 2
79938: NEG
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 3
79946: NEG
79947: PUSH
79948: LD_INT 3
79950: NEG
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: LIST
79960: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79961: LD_ADDR_VAR 0 17
79965: PUSH
79966: LD_INT 1
79968: NEG
79969: PUSH
79970: LD_INT 3
79972: NEG
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 0
79980: PUSH
79981: LD_INT 3
79983: NEG
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 1
79991: PUSH
79992: LD_INT 2
79994: NEG
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: EMPTY
80001: LIST
80002: LIST
80003: LIST
80004: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80005: LD_ADDR_VAR 0 18
80009: PUSH
80010: LD_INT 2
80012: PUSH
80013: LD_INT 1
80015: NEG
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: LD_INT 3
80023: PUSH
80024: LD_INT 0
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: PUSH
80031: LD_INT 3
80033: PUSH
80034: LD_INT 1
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: LIST
80045: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80046: LD_ADDR_VAR 0 19
80050: PUSH
80051: LD_INT 3
80053: PUSH
80054: LD_INT 2
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 3
80063: PUSH
80064: LD_INT 3
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 2
80073: PUSH
80074: LD_INT 3
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: LIST
80085: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80086: LD_ADDR_VAR 0 20
80090: PUSH
80091: LD_INT 1
80093: PUSH
80094: LD_INT 3
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 0
80103: PUSH
80104: LD_INT 3
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 1
80113: NEG
80114: PUSH
80115: LD_INT 2
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: LIST
80126: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80127: LD_ADDR_VAR 0 21
80131: PUSH
80132: LD_INT 2
80134: NEG
80135: PUSH
80136: LD_INT 1
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 3
80145: NEG
80146: PUSH
80147: LD_INT 0
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 3
80156: NEG
80157: PUSH
80158: LD_INT 1
80160: NEG
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: LIST
80170: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80171: LD_ADDR_VAR 0 22
80175: PUSH
80176: LD_INT 2
80178: NEG
80179: PUSH
80180: LD_INT 3
80182: NEG
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 3
80190: NEG
80191: PUSH
80192: LD_INT 2
80194: NEG
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 3
80202: NEG
80203: PUSH
80204: LD_INT 3
80206: NEG
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: LIST
80216: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
80217: LD_ADDR_VAR 0 23
80221: PUSH
80222: LD_INT 0
80224: PUSH
80225: LD_INT 3
80227: NEG
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 1
80235: NEG
80236: PUSH
80237: LD_INT 4
80239: NEG
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 1
80247: PUSH
80248: LD_INT 3
80250: NEG
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: LIST
80260: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
80261: LD_ADDR_VAR 0 24
80265: PUSH
80266: LD_INT 3
80268: PUSH
80269: LD_INT 0
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: PUSH
80276: LD_INT 3
80278: PUSH
80279: LD_INT 1
80281: NEG
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 4
80289: PUSH
80290: LD_INT 1
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: LIST
80301: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
80302: LD_ADDR_VAR 0 25
80306: PUSH
80307: LD_INT 3
80309: PUSH
80310: LD_INT 3
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 4
80319: PUSH
80320: LD_INT 3
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 3
80329: PUSH
80330: LD_INT 4
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: LIST
80341: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
80342: LD_ADDR_VAR 0 26
80346: PUSH
80347: LD_INT 0
80349: PUSH
80350: LD_INT 3
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 1
80359: PUSH
80360: LD_INT 4
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 1
80369: NEG
80370: PUSH
80371: LD_INT 3
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: LIST
80382: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
80383: LD_ADDR_VAR 0 27
80387: PUSH
80388: LD_INT 3
80390: NEG
80391: PUSH
80392: LD_INT 0
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: LD_INT 3
80401: NEG
80402: PUSH
80403: LD_INT 1
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 4
80412: NEG
80413: PUSH
80414: LD_INT 1
80416: NEG
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: LIST
80426: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
80427: LD_ADDR_VAR 0 28
80431: PUSH
80432: LD_INT 3
80434: NEG
80435: PUSH
80436: LD_INT 3
80438: NEG
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: LD_INT 3
80446: NEG
80447: PUSH
80448: LD_INT 4
80450: NEG
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 4
80458: NEG
80459: PUSH
80460: LD_INT 3
80462: NEG
80463: PUSH
80464: EMPTY
80465: LIST
80466: LIST
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: LIST
80472: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
80473: LD_ADDR_VAR 0 29
80477: PUSH
80478: LD_INT 1
80480: NEG
80481: PUSH
80482: LD_INT 3
80484: NEG
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 0
80492: PUSH
80493: LD_INT 3
80495: NEG
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 1
80503: PUSH
80504: LD_INT 2
80506: NEG
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 1
80514: NEG
80515: PUSH
80516: LD_INT 4
80518: NEG
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 0
80526: PUSH
80527: LD_INT 4
80529: NEG
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 1
80537: PUSH
80538: LD_INT 3
80540: NEG
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: LD_INT 5
80552: NEG
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 0
80560: PUSH
80561: LD_INT 5
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 1
80571: PUSH
80572: LD_INT 4
80574: NEG
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 1
80582: NEG
80583: PUSH
80584: LD_INT 6
80586: NEG
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: LD_INT 0
80594: PUSH
80595: LD_INT 6
80597: NEG
80598: PUSH
80599: EMPTY
80600: LIST
80601: LIST
80602: PUSH
80603: LD_INT 1
80605: PUSH
80606: LD_INT 5
80608: NEG
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
80628: LD_ADDR_VAR 0 30
80632: PUSH
80633: LD_INT 2
80635: PUSH
80636: LD_INT 1
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 3
80646: PUSH
80647: LD_INT 0
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 3
80656: PUSH
80657: LD_INT 1
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 3
80666: PUSH
80667: LD_INT 1
80669: NEG
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 4
80677: PUSH
80678: LD_INT 0
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 4
80687: PUSH
80688: LD_INT 1
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 4
80697: PUSH
80698: LD_INT 1
80700: NEG
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 5
80708: PUSH
80709: LD_INT 0
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 5
80718: PUSH
80719: LD_INT 1
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 5
80728: PUSH
80729: LD_INT 1
80731: NEG
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 6
80739: PUSH
80740: LD_INT 0
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 6
80749: PUSH
80750: LD_INT 1
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
80771: LD_ADDR_VAR 0 31
80775: PUSH
80776: LD_INT 3
80778: PUSH
80779: LD_INT 2
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 3
80788: PUSH
80789: LD_INT 3
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 2
80798: PUSH
80799: LD_INT 3
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 4
80808: PUSH
80809: LD_INT 3
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 4
80818: PUSH
80819: LD_INT 4
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 3
80828: PUSH
80829: LD_INT 4
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 5
80838: PUSH
80839: LD_INT 4
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 5
80848: PUSH
80849: LD_INT 5
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 4
80858: PUSH
80859: LD_INT 5
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 6
80868: PUSH
80869: LD_INT 5
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 6
80878: PUSH
80879: LD_INT 6
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 5
80888: PUSH
80889: LD_INT 6
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
80910: LD_ADDR_VAR 0 32
80914: PUSH
80915: LD_INT 1
80917: PUSH
80918: LD_INT 3
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 0
80927: PUSH
80928: LD_INT 3
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 1
80937: NEG
80938: PUSH
80939: LD_INT 2
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 1
80948: PUSH
80949: LD_INT 4
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 0
80958: PUSH
80959: LD_INT 4
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 1
80968: NEG
80969: PUSH
80970: LD_INT 3
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 1
80979: PUSH
80980: LD_INT 5
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 0
80989: PUSH
80990: LD_INT 5
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 1
80999: NEG
81000: PUSH
81001: LD_INT 4
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 1
81010: PUSH
81011: LD_INT 6
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: PUSH
81018: LD_INT 0
81020: PUSH
81021: LD_INT 6
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 1
81030: NEG
81031: PUSH
81032: LD_INT 5
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
81053: LD_ADDR_VAR 0 33
81057: PUSH
81058: LD_INT 2
81060: NEG
81061: PUSH
81062: LD_INT 1
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 3
81071: NEG
81072: PUSH
81073: LD_INT 0
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 3
81082: NEG
81083: PUSH
81084: LD_INT 1
81086: NEG
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 3
81094: NEG
81095: PUSH
81096: LD_INT 1
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 4
81105: NEG
81106: PUSH
81107: LD_INT 0
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 4
81116: NEG
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 4
81128: NEG
81129: PUSH
81130: LD_INT 1
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 5
81139: NEG
81140: PUSH
81141: LD_INT 0
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: PUSH
81148: LD_INT 5
81150: NEG
81151: PUSH
81152: LD_INT 1
81154: NEG
81155: PUSH
81156: EMPTY
81157: LIST
81158: LIST
81159: PUSH
81160: LD_INT 5
81162: NEG
81163: PUSH
81164: LD_INT 1
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 6
81173: NEG
81174: PUSH
81175: LD_INT 0
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 6
81184: NEG
81185: PUSH
81186: LD_INT 1
81188: NEG
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: LIST
81204: LIST
81205: LIST
81206: LIST
81207: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
81208: LD_ADDR_VAR 0 34
81212: PUSH
81213: LD_INT 2
81215: NEG
81216: PUSH
81217: LD_INT 3
81219: NEG
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 3
81227: NEG
81228: PUSH
81229: LD_INT 2
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 3
81239: NEG
81240: PUSH
81241: LD_INT 3
81243: NEG
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 3
81251: NEG
81252: PUSH
81253: LD_INT 4
81255: NEG
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 4
81263: NEG
81264: PUSH
81265: LD_INT 3
81267: NEG
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 4
81275: NEG
81276: PUSH
81277: LD_INT 4
81279: NEG
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 4
81287: NEG
81288: PUSH
81289: LD_INT 5
81291: NEG
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 5
81299: NEG
81300: PUSH
81301: LD_INT 4
81303: NEG
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 5
81311: NEG
81312: PUSH
81313: LD_INT 5
81315: NEG
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 5
81323: NEG
81324: PUSH
81325: LD_INT 6
81327: NEG
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 6
81335: NEG
81336: PUSH
81337: LD_INT 5
81339: NEG
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 6
81347: NEG
81348: PUSH
81349: LD_INT 6
81351: NEG
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: LIST
81361: LIST
81362: LIST
81363: LIST
81364: LIST
81365: LIST
81366: LIST
81367: LIST
81368: LIST
81369: LIST
81370: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
81371: LD_ADDR_VAR 0 41
81375: PUSH
81376: LD_INT 0
81378: PUSH
81379: LD_INT 2
81381: NEG
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 1
81389: NEG
81390: PUSH
81391: LD_INT 3
81393: NEG
81394: PUSH
81395: EMPTY
81396: LIST
81397: LIST
81398: PUSH
81399: LD_INT 1
81401: PUSH
81402: LD_INT 2
81404: NEG
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: LIST
81414: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
81415: LD_ADDR_VAR 0 42
81419: PUSH
81420: LD_INT 2
81422: PUSH
81423: LD_INT 0
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 2
81432: PUSH
81433: LD_INT 1
81435: NEG
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 3
81443: PUSH
81444: LD_INT 1
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: LIST
81455: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
81456: LD_ADDR_VAR 0 43
81460: PUSH
81461: LD_INT 2
81463: PUSH
81464: LD_INT 2
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 3
81473: PUSH
81474: LD_INT 2
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 2
81483: PUSH
81484: LD_INT 3
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: EMPTY
81492: LIST
81493: LIST
81494: LIST
81495: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
81496: LD_ADDR_VAR 0 44
81500: PUSH
81501: LD_INT 0
81503: PUSH
81504: LD_INT 2
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 1
81513: PUSH
81514: LD_INT 3
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 1
81523: NEG
81524: PUSH
81525: LD_INT 2
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: LIST
81536: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81537: LD_ADDR_VAR 0 45
81541: PUSH
81542: LD_INT 2
81544: NEG
81545: PUSH
81546: LD_INT 0
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 2
81555: NEG
81556: PUSH
81557: LD_INT 1
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: LD_INT 3
81566: NEG
81567: PUSH
81568: LD_INT 1
81570: NEG
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: LIST
81580: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
81581: LD_ADDR_VAR 0 46
81585: PUSH
81586: LD_INT 2
81588: NEG
81589: PUSH
81590: LD_INT 2
81592: NEG
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 2
81600: NEG
81601: PUSH
81602: LD_INT 3
81604: NEG
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 3
81612: NEG
81613: PUSH
81614: LD_INT 2
81616: NEG
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: EMPTY
81623: LIST
81624: LIST
81625: LIST
81626: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
81627: LD_ADDR_VAR 0 47
81631: PUSH
81632: LD_INT 2
81634: NEG
81635: PUSH
81636: LD_INT 3
81638: NEG
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 1
81646: NEG
81647: PUSH
81648: LD_INT 3
81650: NEG
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81660: LD_ADDR_VAR 0 48
81664: PUSH
81665: LD_INT 1
81667: PUSH
81668: LD_INT 2
81670: NEG
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 2
81678: PUSH
81679: LD_INT 1
81681: NEG
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
81691: LD_ADDR_VAR 0 49
81695: PUSH
81696: LD_INT 3
81698: PUSH
81699: LD_INT 1
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 3
81708: PUSH
81709: LD_INT 2
81711: PUSH
81712: EMPTY
81713: LIST
81714: LIST
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
81720: LD_ADDR_VAR 0 50
81724: PUSH
81725: LD_INT 2
81727: PUSH
81728: LD_INT 3
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 1
81737: PUSH
81738: LD_INT 3
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81749: LD_ADDR_VAR 0 51
81753: PUSH
81754: LD_INT 1
81756: NEG
81757: PUSH
81758: LD_INT 2
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 2
81767: NEG
81768: PUSH
81769: LD_INT 1
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81780: LD_ADDR_VAR 0 52
81784: PUSH
81785: LD_INT 3
81787: NEG
81788: PUSH
81789: LD_INT 1
81791: NEG
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 3
81799: NEG
81800: PUSH
81801: LD_INT 2
81803: NEG
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81813: LD_ADDR_VAR 0 53
81817: PUSH
81818: LD_INT 1
81820: NEG
81821: PUSH
81822: LD_INT 3
81824: NEG
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 0
81832: PUSH
81833: LD_INT 3
81835: NEG
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 1
81843: PUSH
81844: LD_INT 2
81846: NEG
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: LIST
81856: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81857: LD_ADDR_VAR 0 54
81861: PUSH
81862: LD_INT 2
81864: PUSH
81865: LD_INT 1
81867: NEG
81868: PUSH
81869: EMPTY
81870: LIST
81871: LIST
81872: PUSH
81873: LD_INT 3
81875: PUSH
81876: LD_INT 0
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 3
81885: PUSH
81886: LD_INT 1
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: LIST
81897: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81898: LD_ADDR_VAR 0 55
81902: PUSH
81903: LD_INT 3
81905: PUSH
81906: LD_INT 2
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 3
81915: PUSH
81916: LD_INT 3
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 2
81925: PUSH
81926: LD_INT 3
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: LIST
81937: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81938: LD_ADDR_VAR 0 56
81942: PUSH
81943: LD_INT 1
81945: PUSH
81946: LD_INT 3
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 0
81955: PUSH
81956: LD_INT 3
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 1
81965: NEG
81966: PUSH
81967: LD_INT 2
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: LIST
81978: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81979: LD_ADDR_VAR 0 57
81983: PUSH
81984: LD_INT 2
81986: NEG
81987: PUSH
81988: LD_INT 1
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 3
81997: NEG
81998: PUSH
81999: LD_INT 0
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 3
82008: NEG
82009: PUSH
82010: LD_INT 1
82012: NEG
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: LIST
82022: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82023: LD_ADDR_VAR 0 58
82027: PUSH
82028: LD_INT 2
82030: NEG
82031: PUSH
82032: LD_INT 3
82034: NEG
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 3
82042: NEG
82043: PUSH
82044: LD_INT 2
82046: NEG
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 3
82054: NEG
82055: PUSH
82056: LD_INT 3
82058: NEG
82059: PUSH
82060: EMPTY
82061: LIST
82062: LIST
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: LIST
82068: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
82069: LD_ADDR_VAR 0 59
82073: PUSH
82074: LD_INT 1
82076: NEG
82077: PUSH
82078: LD_INT 2
82080: NEG
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 0
82088: PUSH
82089: LD_INT 2
82091: NEG
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 1
82099: PUSH
82100: LD_INT 1
82102: NEG
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: LIST
82112: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
82113: LD_ADDR_VAR 0 60
82117: PUSH
82118: LD_INT 1
82120: PUSH
82121: LD_INT 1
82123: NEG
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 2
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 2
82141: PUSH
82142: LD_INT 1
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: LIST
82153: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
82154: LD_ADDR_VAR 0 61
82158: PUSH
82159: LD_INT 2
82161: PUSH
82162: LD_INT 1
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 2
82171: PUSH
82172: LD_INT 2
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 1
82181: PUSH
82182: LD_INT 2
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: LIST
82193: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
82194: LD_ADDR_VAR 0 62
82198: PUSH
82199: LD_INT 1
82201: PUSH
82202: LD_INT 2
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 0
82211: PUSH
82212: LD_INT 2
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 1
82221: NEG
82222: PUSH
82223: LD_INT 1
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: LIST
82234: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
82235: LD_ADDR_VAR 0 63
82239: PUSH
82240: LD_INT 1
82242: NEG
82243: PUSH
82244: LD_INT 1
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PUSH
82251: LD_INT 2
82253: NEG
82254: PUSH
82255: LD_INT 0
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 2
82264: NEG
82265: PUSH
82266: LD_INT 1
82268: NEG
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: LIST
82278: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82279: LD_ADDR_VAR 0 64
82283: PUSH
82284: LD_INT 1
82286: NEG
82287: PUSH
82288: LD_INT 2
82290: NEG
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 2
82298: NEG
82299: PUSH
82300: LD_INT 1
82302: NEG
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 2
82310: NEG
82311: PUSH
82312: LD_INT 2
82314: NEG
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: LIST
82324: ST_TO_ADDR
// end ; 2 :
82325: GO 85591
82327: LD_INT 2
82329: DOUBLE
82330: EQUAL
82331: IFTRUE 82335
82333: GO 85590
82335: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
82336: LD_ADDR_VAR 0 29
82340: PUSH
82341: LD_INT 4
82343: PUSH
82344: LD_INT 0
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 4
82353: PUSH
82354: LD_INT 1
82356: NEG
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 5
82364: PUSH
82365: LD_INT 0
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 5
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 4
82384: PUSH
82385: LD_INT 1
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 3
82394: PUSH
82395: LD_INT 0
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 3
82404: PUSH
82405: LD_INT 1
82407: NEG
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 3
82415: PUSH
82416: LD_INT 2
82418: NEG
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 5
82426: PUSH
82427: LD_INT 2
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 3
82436: PUSH
82437: LD_INT 3
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 3
82446: PUSH
82447: LD_INT 2
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 4
82456: PUSH
82457: LD_INT 3
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 4
82466: PUSH
82467: LD_INT 4
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 3
82476: PUSH
82477: LD_INT 4
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 2
82486: PUSH
82487: LD_INT 3
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 2
82496: PUSH
82497: LD_INT 2
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 4
82506: PUSH
82507: LD_INT 2
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 2
82516: PUSH
82517: LD_INT 4
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 0
82526: PUSH
82527: LD_INT 4
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 0
82536: PUSH
82537: LD_INT 3
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 1
82546: PUSH
82547: LD_INT 4
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: LD_INT 5
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 0
82566: PUSH
82567: LD_INT 5
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 1
82576: NEG
82577: PUSH
82578: LD_INT 4
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 1
82587: NEG
82588: PUSH
82589: LD_INT 3
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 2
82598: PUSH
82599: LD_INT 5
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 2
82608: NEG
82609: PUSH
82610: LD_INT 3
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 3
82619: NEG
82620: PUSH
82621: LD_INT 0
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 3
82630: NEG
82631: PUSH
82632: LD_INT 1
82634: NEG
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 2
82642: NEG
82643: PUSH
82644: LD_INT 0
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 2
82653: NEG
82654: PUSH
82655: LD_INT 1
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 3
82664: NEG
82665: PUSH
82666: LD_INT 1
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 4
82675: NEG
82676: PUSH
82677: LD_INT 0
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 4
82686: NEG
82687: PUSH
82688: LD_INT 1
82690: NEG
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: PUSH
82696: LD_INT 4
82698: NEG
82699: PUSH
82700: LD_INT 2
82702: NEG
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: PUSH
82708: LD_INT 2
82710: NEG
82711: PUSH
82712: LD_INT 2
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 4
82721: NEG
82722: PUSH
82723: LD_INT 4
82725: NEG
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: PUSH
82731: LD_INT 4
82733: NEG
82734: PUSH
82735: LD_INT 5
82737: NEG
82738: PUSH
82739: EMPTY
82740: LIST
82741: LIST
82742: PUSH
82743: LD_INT 3
82745: NEG
82746: PUSH
82747: LD_INT 4
82749: NEG
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 3
82757: NEG
82758: PUSH
82759: LD_INT 3
82761: NEG
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 4
82769: NEG
82770: PUSH
82771: LD_INT 3
82773: NEG
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 5
82781: NEG
82782: PUSH
82783: LD_INT 4
82785: NEG
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 5
82793: NEG
82794: PUSH
82795: LD_INT 5
82797: NEG
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: PUSH
82803: LD_INT 3
82805: NEG
82806: PUSH
82807: LD_INT 5
82809: NEG
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: PUSH
82815: LD_INT 5
82817: NEG
82818: PUSH
82819: LD_INT 3
82821: NEG
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
82874: LD_ADDR_VAR 0 30
82878: PUSH
82879: LD_INT 4
82881: PUSH
82882: LD_INT 4
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 4
82891: PUSH
82892: LD_INT 3
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 5
82901: PUSH
82902: LD_INT 4
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 5
82911: PUSH
82912: LD_INT 5
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 4
82921: PUSH
82922: LD_INT 5
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 3
82931: PUSH
82932: LD_INT 4
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 3
82941: PUSH
82942: LD_INT 3
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 5
82951: PUSH
82952: LD_INT 3
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: LD_INT 3
82961: PUSH
82962: LD_INT 5
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 0
82971: PUSH
82972: LD_INT 3
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 0
82981: PUSH
82982: LD_INT 2
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 1
82991: PUSH
82992: LD_INT 3
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 1
83001: PUSH
83002: LD_INT 4
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 0
83011: PUSH
83012: LD_INT 4
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 1
83021: NEG
83022: PUSH
83023: LD_INT 3
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 1
83032: NEG
83033: PUSH
83034: LD_INT 2
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 2
83043: PUSH
83044: LD_INT 4
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 2
83053: NEG
83054: PUSH
83055: LD_INT 2
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 4
83064: NEG
83065: PUSH
83066: LD_INT 0
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 4
83075: NEG
83076: PUSH
83077: LD_INT 1
83079: NEG
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 3
83087: NEG
83088: PUSH
83089: LD_INT 0
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 3
83098: NEG
83099: PUSH
83100: LD_INT 1
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 4
83109: NEG
83110: PUSH
83111: LD_INT 1
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PUSH
83118: LD_INT 5
83120: NEG
83121: PUSH
83122: LD_INT 0
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 5
83131: NEG
83132: PUSH
83133: LD_INT 1
83135: NEG
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 5
83143: NEG
83144: PUSH
83145: LD_INT 2
83147: NEG
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 3
83155: NEG
83156: PUSH
83157: LD_INT 2
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: LD_INT 3
83166: NEG
83167: PUSH
83168: LD_INT 3
83170: NEG
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: LD_INT 3
83178: NEG
83179: PUSH
83180: LD_INT 4
83182: NEG
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 2
83190: NEG
83191: PUSH
83192: LD_INT 3
83194: NEG
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 2
83202: NEG
83203: PUSH
83204: LD_INT 2
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 3
83214: NEG
83215: PUSH
83216: LD_INT 2
83218: NEG
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 4
83226: NEG
83227: PUSH
83228: LD_INT 3
83230: NEG
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: PUSH
83236: LD_INT 4
83238: NEG
83239: PUSH
83240: LD_INT 4
83242: NEG
83243: PUSH
83244: EMPTY
83245: LIST
83246: LIST
83247: PUSH
83248: LD_INT 2
83250: NEG
83251: PUSH
83252: LD_INT 4
83254: NEG
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: PUSH
83260: LD_INT 4
83262: NEG
83263: PUSH
83264: LD_INT 2
83266: NEG
83267: PUSH
83268: EMPTY
83269: LIST
83270: LIST
83271: PUSH
83272: LD_INT 0
83274: PUSH
83275: LD_INT 4
83277: NEG
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 0
83285: PUSH
83286: LD_INT 5
83288: NEG
83289: PUSH
83290: EMPTY
83291: LIST
83292: LIST
83293: PUSH
83294: LD_INT 1
83296: PUSH
83297: LD_INT 4
83299: NEG
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PUSH
83305: LD_INT 1
83307: PUSH
83308: LD_INT 3
83310: NEG
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 0
83318: PUSH
83319: LD_INT 3
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 1
83329: NEG
83330: PUSH
83331: LD_INT 4
83333: NEG
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: LD_INT 1
83341: NEG
83342: PUSH
83343: LD_INT 5
83345: NEG
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 2
83353: PUSH
83354: LD_INT 3
83356: NEG
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 2
83364: NEG
83365: PUSH
83366: LD_INT 5
83368: NEG
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: LIST
83416: LIST
83417: LIST
83418: LIST
83419: LIST
83420: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
83421: LD_ADDR_VAR 0 31
83425: PUSH
83426: LD_INT 0
83428: PUSH
83429: LD_INT 4
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 0
83438: PUSH
83439: LD_INT 3
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: PUSH
83446: LD_INT 1
83448: PUSH
83449: LD_INT 4
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 1
83458: PUSH
83459: LD_INT 5
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 0
83468: PUSH
83469: LD_INT 5
83471: PUSH
83472: EMPTY
83473: LIST
83474: LIST
83475: PUSH
83476: LD_INT 1
83478: NEG
83479: PUSH
83480: LD_INT 4
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 1
83489: NEG
83490: PUSH
83491: LD_INT 3
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 2
83500: PUSH
83501: LD_INT 5
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 2
83510: NEG
83511: PUSH
83512: LD_INT 3
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 3
83521: NEG
83522: PUSH
83523: LD_INT 0
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: PUSH
83530: LD_INT 3
83532: NEG
83533: PUSH
83534: LD_INT 1
83536: NEG
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 2
83544: NEG
83545: PUSH
83546: LD_INT 0
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: PUSH
83553: LD_INT 2
83555: NEG
83556: PUSH
83557: LD_INT 1
83559: PUSH
83560: EMPTY
83561: LIST
83562: LIST
83563: PUSH
83564: LD_INT 3
83566: NEG
83567: PUSH
83568: LD_INT 1
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: PUSH
83575: LD_INT 4
83577: NEG
83578: PUSH
83579: LD_INT 0
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_INT 4
83588: NEG
83589: PUSH
83590: LD_INT 1
83592: NEG
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_INT 4
83600: NEG
83601: PUSH
83602: LD_INT 2
83604: NEG
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: PUSH
83610: LD_INT 2
83612: NEG
83613: PUSH
83614: LD_INT 2
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 4
83623: NEG
83624: PUSH
83625: LD_INT 4
83627: NEG
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: PUSH
83633: LD_INT 4
83635: NEG
83636: PUSH
83637: LD_INT 5
83639: NEG
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 3
83647: NEG
83648: PUSH
83649: LD_INT 4
83651: NEG
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 3
83659: NEG
83660: PUSH
83661: LD_INT 3
83663: NEG
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 4
83671: NEG
83672: PUSH
83673: LD_INT 3
83675: NEG
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 5
83683: NEG
83684: PUSH
83685: LD_INT 4
83687: NEG
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: PUSH
83693: LD_INT 5
83695: NEG
83696: PUSH
83697: LD_INT 5
83699: NEG
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 3
83707: NEG
83708: PUSH
83709: LD_INT 5
83711: NEG
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 5
83719: NEG
83720: PUSH
83721: LD_INT 3
83723: NEG
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 0
83731: PUSH
83732: LD_INT 3
83734: NEG
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PUSH
83740: LD_INT 0
83742: PUSH
83743: LD_INT 4
83745: NEG
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 1
83753: PUSH
83754: LD_INT 3
83756: NEG
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 1
83764: PUSH
83765: LD_INT 2
83767: NEG
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 0
83775: PUSH
83776: LD_INT 2
83778: NEG
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 1
83786: NEG
83787: PUSH
83788: LD_INT 3
83790: NEG
83791: PUSH
83792: EMPTY
83793: LIST
83794: LIST
83795: PUSH
83796: LD_INT 1
83798: NEG
83799: PUSH
83800: LD_INT 4
83802: NEG
83803: PUSH
83804: EMPTY
83805: LIST
83806: LIST
83807: PUSH
83808: LD_INT 2
83810: PUSH
83811: LD_INT 2
83813: NEG
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 2
83821: NEG
83822: PUSH
83823: LD_INT 4
83825: NEG
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: LD_INT 4
83833: PUSH
83834: LD_INT 0
83836: PUSH
83837: EMPTY
83838: LIST
83839: LIST
83840: PUSH
83841: LD_INT 4
83843: PUSH
83844: LD_INT 1
83846: NEG
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 5
83854: PUSH
83855: LD_INT 0
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 5
83864: PUSH
83865: LD_INT 1
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: PUSH
83872: LD_INT 4
83874: PUSH
83875: LD_INT 1
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: PUSH
83882: LD_INT 3
83884: PUSH
83885: LD_INT 0
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 3
83894: PUSH
83895: LD_INT 1
83897: NEG
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 3
83905: PUSH
83906: LD_INT 2
83908: NEG
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: PUSH
83914: LD_INT 5
83916: PUSH
83917: LD_INT 2
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: EMPTY
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
83971: LD_ADDR_VAR 0 32
83975: PUSH
83976: LD_INT 4
83978: NEG
83979: PUSH
83980: LD_INT 0
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 4
83989: NEG
83990: PUSH
83991: LD_INT 1
83993: NEG
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 3
84001: NEG
84002: PUSH
84003: LD_INT 0
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 3
84012: NEG
84013: PUSH
84014: LD_INT 1
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 4
84023: NEG
84024: PUSH
84025: LD_INT 1
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: PUSH
84032: LD_INT 5
84034: NEG
84035: PUSH
84036: LD_INT 0
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 5
84045: NEG
84046: PUSH
84047: LD_INT 1
84049: NEG
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 5
84057: NEG
84058: PUSH
84059: LD_INT 2
84061: NEG
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 3
84069: NEG
84070: PUSH
84071: LD_INT 2
84073: PUSH
84074: EMPTY
84075: LIST
84076: LIST
84077: PUSH
84078: LD_INT 3
84080: NEG
84081: PUSH
84082: LD_INT 3
84084: NEG
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: PUSH
84090: LD_INT 3
84092: NEG
84093: PUSH
84094: LD_INT 4
84096: NEG
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 2
84104: NEG
84105: PUSH
84106: LD_INT 3
84108: NEG
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 2
84116: NEG
84117: PUSH
84118: LD_INT 2
84120: NEG
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 3
84128: NEG
84129: PUSH
84130: LD_INT 2
84132: NEG
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 4
84140: NEG
84141: PUSH
84142: LD_INT 3
84144: NEG
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 4
84152: NEG
84153: PUSH
84154: LD_INT 4
84156: NEG
84157: PUSH
84158: EMPTY
84159: LIST
84160: LIST
84161: PUSH
84162: LD_INT 2
84164: NEG
84165: PUSH
84166: LD_INT 4
84168: NEG
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 4
84176: NEG
84177: PUSH
84178: LD_INT 2
84180: NEG
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 0
84188: PUSH
84189: LD_INT 4
84191: NEG
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: LD_INT 0
84199: PUSH
84200: LD_INT 5
84202: NEG
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PUSH
84208: LD_INT 1
84210: PUSH
84211: LD_INT 4
84213: NEG
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 1
84221: PUSH
84222: LD_INT 3
84224: NEG
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: PUSH
84230: LD_INT 0
84232: PUSH
84233: LD_INT 3
84235: NEG
84236: PUSH
84237: EMPTY
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 1
84243: NEG
84244: PUSH
84245: LD_INT 4
84247: NEG
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 1
84255: NEG
84256: PUSH
84257: LD_INT 5
84259: NEG
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: PUSH
84265: LD_INT 2
84267: PUSH
84268: LD_INT 3
84270: NEG
84271: PUSH
84272: EMPTY
84273: LIST
84274: LIST
84275: PUSH
84276: LD_INT 2
84278: NEG
84279: PUSH
84280: LD_INT 5
84282: NEG
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: PUSH
84288: LD_INT 3
84290: PUSH
84291: LD_INT 0
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: LD_INT 3
84300: PUSH
84301: LD_INT 1
84303: NEG
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 4
84311: PUSH
84312: LD_INT 0
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 4
84321: PUSH
84322: LD_INT 1
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: PUSH
84329: LD_INT 3
84331: PUSH
84332: LD_INT 1
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 2
84341: PUSH
84342: LD_INT 0
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 2
84351: PUSH
84352: LD_INT 1
84354: NEG
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: PUSH
84360: LD_INT 2
84362: PUSH
84363: LD_INT 2
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 4
84373: PUSH
84374: LD_INT 2
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PUSH
84381: LD_INT 4
84383: PUSH
84384: LD_INT 4
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 4
84393: PUSH
84394: LD_INT 3
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 5
84403: PUSH
84404: LD_INT 4
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: PUSH
84411: LD_INT 5
84413: PUSH
84414: LD_INT 5
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: PUSH
84421: LD_INT 4
84423: PUSH
84424: LD_INT 5
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: LD_INT 3
84433: PUSH
84434: LD_INT 4
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 3
84443: PUSH
84444: LD_INT 3
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 5
84453: PUSH
84454: LD_INT 3
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: PUSH
84461: LD_INT 3
84463: PUSH
84464: LD_INT 5
84466: PUSH
84467: EMPTY
84468: LIST
84469: LIST
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
84518: LD_ADDR_VAR 0 33
84522: PUSH
84523: LD_INT 4
84525: NEG
84526: PUSH
84527: LD_INT 4
84529: NEG
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 4
84537: NEG
84538: PUSH
84539: LD_INT 5
84541: NEG
84542: PUSH
84543: EMPTY
84544: LIST
84545: LIST
84546: PUSH
84547: LD_INT 3
84549: NEG
84550: PUSH
84551: LD_INT 4
84553: NEG
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: LD_INT 3
84561: NEG
84562: PUSH
84563: LD_INT 3
84565: NEG
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 4
84573: NEG
84574: PUSH
84575: LD_INT 3
84577: NEG
84578: PUSH
84579: EMPTY
84580: LIST
84581: LIST
84582: PUSH
84583: LD_INT 5
84585: NEG
84586: PUSH
84587: LD_INT 4
84589: NEG
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 5
84597: NEG
84598: PUSH
84599: LD_INT 5
84601: NEG
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 3
84609: NEG
84610: PUSH
84611: LD_INT 5
84613: NEG
84614: PUSH
84615: EMPTY
84616: LIST
84617: LIST
84618: PUSH
84619: LD_INT 5
84621: NEG
84622: PUSH
84623: LD_INT 3
84625: NEG
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: PUSH
84631: LD_INT 0
84633: PUSH
84634: LD_INT 3
84636: NEG
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: PUSH
84642: LD_INT 0
84644: PUSH
84645: LD_INT 4
84647: NEG
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 1
84655: PUSH
84656: LD_INT 3
84658: NEG
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 1
84666: PUSH
84667: LD_INT 2
84669: NEG
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 0
84677: PUSH
84678: LD_INT 2
84680: NEG
84681: PUSH
84682: EMPTY
84683: LIST
84684: LIST
84685: PUSH
84686: LD_INT 1
84688: NEG
84689: PUSH
84690: LD_INT 3
84692: NEG
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: PUSH
84698: LD_INT 1
84700: NEG
84701: PUSH
84702: LD_INT 4
84704: NEG
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 2
84712: PUSH
84713: LD_INT 2
84715: NEG
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 2
84723: NEG
84724: PUSH
84725: LD_INT 4
84727: NEG
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 4
84735: PUSH
84736: LD_INT 0
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 4
84745: PUSH
84746: LD_INT 1
84748: NEG
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: PUSH
84754: LD_INT 5
84756: PUSH
84757: LD_INT 0
84759: PUSH
84760: EMPTY
84761: LIST
84762: LIST
84763: PUSH
84764: LD_INT 5
84766: PUSH
84767: LD_INT 1
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: LD_INT 4
84776: PUSH
84777: LD_INT 1
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 3
84786: PUSH
84787: LD_INT 0
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 3
84796: PUSH
84797: LD_INT 1
84799: NEG
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 3
84807: PUSH
84808: LD_INT 2
84810: NEG
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 5
84818: PUSH
84819: LD_INT 2
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 3
84828: PUSH
84829: LD_INT 3
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 3
84838: PUSH
84839: LD_INT 2
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 4
84848: PUSH
84849: LD_INT 3
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: LD_INT 4
84858: PUSH
84859: LD_INT 4
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: PUSH
84866: LD_INT 3
84868: PUSH
84869: LD_INT 4
84871: PUSH
84872: EMPTY
84873: LIST
84874: LIST
84875: PUSH
84876: LD_INT 2
84878: PUSH
84879: LD_INT 3
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 2
84888: PUSH
84889: LD_INT 2
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 4
84898: PUSH
84899: LD_INT 2
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 2
84908: PUSH
84909: LD_INT 4
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 0
84918: PUSH
84919: LD_INT 4
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 0
84928: PUSH
84929: LD_INT 3
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: PUSH
84936: LD_INT 1
84938: PUSH
84939: LD_INT 4
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 1
84948: PUSH
84949: LD_INT 5
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: LD_INT 0
84958: PUSH
84959: LD_INT 5
84961: PUSH
84962: EMPTY
84963: LIST
84964: LIST
84965: PUSH
84966: LD_INT 1
84968: NEG
84969: PUSH
84970: LD_INT 4
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 1
84979: NEG
84980: PUSH
84981: LD_INT 3
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 2
84990: PUSH
84991: LD_INT 5
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 2
85000: NEG
85001: PUSH
85002: LD_INT 3
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: EMPTY
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: LIST
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
85056: LD_ADDR_VAR 0 34
85060: PUSH
85061: LD_INT 0
85063: PUSH
85064: LD_INT 4
85066: NEG
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: LD_INT 5
85077: NEG
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 1
85085: PUSH
85086: LD_INT 4
85088: NEG
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 1
85096: PUSH
85097: LD_INT 3
85099: NEG
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: PUSH
85105: LD_INT 0
85107: PUSH
85108: LD_INT 3
85110: NEG
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 1
85118: NEG
85119: PUSH
85120: LD_INT 4
85122: NEG
85123: PUSH
85124: EMPTY
85125: LIST
85126: LIST
85127: PUSH
85128: LD_INT 1
85130: NEG
85131: PUSH
85132: LD_INT 5
85134: NEG
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 2
85142: PUSH
85143: LD_INT 3
85145: NEG
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 2
85153: NEG
85154: PUSH
85155: LD_INT 5
85157: NEG
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 3
85165: PUSH
85166: LD_INT 0
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 3
85175: PUSH
85176: LD_INT 1
85178: NEG
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: LD_INT 4
85186: PUSH
85187: LD_INT 0
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: LD_INT 4
85196: PUSH
85197: LD_INT 1
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 3
85206: PUSH
85207: LD_INT 1
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: PUSH
85214: LD_INT 2
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 2
85226: PUSH
85227: LD_INT 1
85229: NEG
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 2
85237: PUSH
85238: LD_INT 2
85240: NEG
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: PUSH
85246: LD_INT 4
85248: PUSH
85249: LD_INT 2
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 4
85258: PUSH
85259: LD_INT 4
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 4
85268: PUSH
85269: LD_INT 3
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 5
85278: PUSH
85279: LD_INT 4
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 5
85288: PUSH
85289: LD_INT 5
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 4
85298: PUSH
85299: LD_INT 5
85301: PUSH
85302: EMPTY
85303: LIST
85304: LIST
85305: PUSH
85306: LD_INT 3
85308: PUSH
85309: LD_INT 4
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: PUSH
85316: LD_INT 3
85318: PUSH
85319: LD_INT 3
85321: PUSH
85322: EMPTY
85323: LIST
85324: LIST
85325: PUSH
85326: LD_INT 5
85328: PUSH
85329: LD_INT 3
85331: PUSH
85332: EMPTY
85333: LIST
85334: LIST
85335: PUSH
85336: LD_INT 3
85338: PUSH
85339: LD_INT 5
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 0
85348: PUSH
85349: LD_INT 3
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: LD_INT 0
85358: PUSH
85359: LD_INT 2
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: LD_INT 3
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 1
85378: PUSH
85379: LD_INT 4
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 0
85388: PUSH
85389: LD_INT 4
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: LD_INT 3
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 1
85409: NEG
85410: PUSH
85411: LD_INT 2
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 2
85420: PUSH
85421: LD_INT 4
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 2
85430: NEG
85431: PUSH
85432: LD_INT 2
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 4
85441: NEG
85442: PUSH
85443: LD_INT 0
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 4
85452: NEG
85453: PUSH
85454: LD_INT 1
85456: NEG
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 3
85464: NEG
85465: PUSH
85466: LD_INT 0
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 3
85475: NEG
85476: PUSH
85477: LD_INT 1
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 4
85486: NEG
85487: PUSH
85488: LD_INT 1
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 5
85497: NEG
85498: PUSH
85499: LD_INT 0
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 5
85508: NEG
85509: PUSH
85510: LD_INT 1
85512: NEG
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 5
85520: NEG
85521: PUSH
85522: LD_INT 2
85524: NEG
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 3
85532: NEG
85533: PUSH
85534: LD_INT 2
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: ST_TO_ADDR
// end ; end ;
85588: GO 85591
85590: POP
// case btype of b_depot , b_warehouse :
85591: LD_VAR 0 1
85595: PUSH
85596: LD_INT 0
85598: DOUBLE
85599: EQUAL
85600: IFTRUE 85610
85602: LD_INT 1
85604: DOUBLE
85605: EQUAL
85606: IFTRUE 85610
85608: GO 85811
85610: POP
// case nation of nation_american :
85611: LD_VAR 0 5
85615: PUSH
85616: LD_INT 1
85618: DOUBLE
85619: EQUAL
85620: IFTRUE 85624
85622: GO 85680
85624: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
85625: LD_ADDR_VAR 0 9
85629: PUSH
85630: LD_VAR 0 11
85634: PUSH
85635: LD_VAR 0 12
85639: PUSH
85640: LD_VAR 0 13
85644: PUSH
85645: LD_VAR 0 14
85649: PUSH
85650: LD_VAR 0 15
85654: PUSH
85655: LD_VAR 0 16
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: PUSH
85668: LD_VAR 0 4
85672: PUSH
85673: LD_INT 1
85675: PLUS
85676: ARRAY
85677: ST_TO_ADDR
85678: GO 85809
85680: LD_INT 2
85682: DOUBLE
85683: EQUAL
85684: IFTRUE 85688
85686: GO 85744
85688: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
85689: LD_ADDR_VAR 0 9
85693: PUSH
85694: LD_VAR 0 17
85698: PUSH
85699: LD_VAR 0 18
85703: PUSH
85704: LD_VAR 0 19
85708: PUSH
85709: LD_VAR 0 20
85713: PUSH
85714: LD_VAR 0 21
85718: PUSH
85719: LD_VAR 0 22
85723: PUSH
85724: EMPTY
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: PUSH
85732: LD_VAR 0 4
85736: PUSH
85737: LD_INT 1
85739: PLUS
85740: ARRAY
85741: ST_TO_ADDR
85742: GO 85809
85744: LD_INT 3
85746: DOUBLE
85747: EQUAL
85748: IFTRUE 85752
85750: GO 85808
85752: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
85753: LD_ADDR_VAR 0 9
85757: PUSH
85758: LD_VAR 0 23
85762: PUSH
85763: LD_VAR 0 24
85767: PUSH
85768: LD_VAR 0 25
85772: PUSH
85773: LD_VAR 0 26
85777: PUSH
85778: LD_VAR 0 27
85782: PUSH
85783: LD_VAR 0 28
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: PUSH
85796: LD_VAR 0 4
85800: PUSH
85801: LD_INT 1
85803: PLUS
85804: ARRAY
85805: ST_TO_ADDR
85806: GO 85809
85808: POP
85809: GO 86364
85811: LD_INT 2
85813: DOUBLE
85814: EQUAL
85815: IFTRUE 85825
85817: LD_INT 3
85819: DOUBLE
85820: EQUAL
85821: IFTRUE 85825
85823: GO 85881
85825: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
85826: LD_ADDR_VAR 0 9
85830: PUSH
85831: LD_VAR 0 29
85835: PUSH
85836: LD_VAR 0 30
85840: PUSH
85841: LD_VAR 0 31
85845: PUSH
85846: LD_VAR 0 32
85850: PUSH
85851: LD_VAR 0 33
85855: PUSH
85856: LD_VAR 0 34
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: PUSH
85869: LD_VAR 0 4
85873: PUSH
85874: LD_INT 1
85876: PLUS
85877: ARRAY
85878: ST_TO_ADDR
85879: GO 86364
85881: LD_INT 16
85883: DOUBLE
85884: EQUAL
85885: IFTRUE 85943
85887: LD_INT 17
85889: DOUBLE
85890: EQUAL
85891: IFTRUE 85943
85893: LD_INT 18
85895: DOUBLE
85896: EQUAL
85897: IFTRUE 85943
85899: LD_INT 19
85901: DOUBLE
85902: EQUAL
85903: IFTRUE 85943
85905: LD_INT 22
85907: DOUBLE
85908: EQUAL
85909: IFTRUE 85943
85911: LD_INT 20
85913: DOUBLE
85914: EQUAL
85915: IFTRUE 85943
85917: LD_INT 21
85919: DOUBLE
85920: EQUAL
85921: IFTRUE 85943
85923: LD_INT 23
85925: DOUBLE
85926: EQUAL
85927: IFTRUE 85943
85929: LD_INT 24
85931: DOUBLE
85932: EQUAL
85933: IFTRUE 85943
85935: LD_INT 25
85937: DOUBLE
85938: EQUAL
85939: IFTRUE 85943
85941: GO 85999
85943: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
85944: LD_ADDR_VAR 0 9
85948: PUSH
85949: LD_VAR 0 35
85953: PUSH
85954: LD_VAR 0 36
85958: PUSH
85959: LD_VAR 0 37
85963: PUSH
85964: LD_VAR 0 38
85968: PUSH
85969: LD_VAR 0 39
85973: PUSH
85974: LD_VAR 0 40
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: LIST
85983: LIST
85984: LIST
85985: LIST
85986: PUSH
85987: LD_VAR 0 4
85991: PUSH
85992: LD_INT 1
85994: PLUS
85995: ARRAY
85996: ST_TO_ADDR
85997: GO 86364
85999: LD_INT 6
86001: DOUBLE
86002: EQUAL
86003: IFTRUE 86055
86005: LD_INT 7
86007: DOUBLE
86008: EQUAL
86009: IFTRUE 86055
86011: LD_INT 8
86013: DOUBLE
86014: EQUAL
86015: IFTRUE 86055
86017: LD_INT 13
86019: DOUBLE
86020: EQUAL
86021: IFTRUE 86055
86023: LD_INT 12
86025: DOUBLE
86026: EQUAL
86027: IFTRUE 86055
86029: LD_INT 15
86031: DOUBLE
86032: EQUAL
86033: IFTRUE 86055
86035: LD_INT 11
86037: DOUBLE
86038: EQUAL
86039: IFTRUE 86055
86041: LD_INT 14
86043: DOUBLE
86044: EQUAL
86045: IFTRUE 86055
86047: LD_INT 10
86049: DOUBLE
86050: EQUAL
86051: IFTRUE 86055
86053: GO 86111
86055: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
86056: LD_ADDR_VAR 0 9
86060: PUSH
86061: LD_VAR 0 41
86065: PUSH
86066: LD_VAR 0 42
86070: PUSH
86071: LD_VAR 0 43
86075: PUSH
86076: LD_VAR 0 44
86080: PUSH
86081: LD_VAR 0 45
86085: PUSH
86086: LD_VAR 0 46
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: PUSH
86099: LD_VAR 0 4
86103: PUSH
86104: LD_INT 1
86106: PLUS
86107: ARRAY
86108: ST_TO_ADDR
86109: GO 86364
86111: LD_INT 36
86113: DOUBLE
86114: EQUAL
86115: IFTRUE 86119
86117: GO 86175
86119: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
86120: LD_ADDR_VAR 0 9
86124: PUSH
86125: LD_VAR 0 47
86129: PUSH
86130: LD_VAR 0 48
86134: PUSH
86135: LD_VAR 0 49
86139: PUSH
86140: LD_VAR 0 50
86144: PUSH
86145: LD_VAR 0 51
86149: PUSH
86150: LD_VAR 0 52
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: PUSH
86163: LD_VAR 0 4
86167: PUSH
86168: LD_INT 1
86170: PLUS
86171: ARRAY
86172: ST_TO_ADDR
86173: GO 86364
86175: LD_INT 4
86177: DOUBLE
86178: EQUAL
86179: IFTRUE 86201
86181: LD_INT 5
86183: DOUBLE
86184: EQUAL
86185: IFTRUE 86201
86187: LD_INT 34
86189: DOUBLE
86190: EQUAL
86191: IFTRUE 86201
86193: LD_INT 37
86195: DOUBLE
86196: EQUAL
86197: IFTRUE 86201
86199: GO 86257
86201: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
86202: LD_ADDR_VAR 0 9
86206: PUSH
86207: LD_VAR 0 53
86211: PUSH
86212: LD_VAR 0 54
86216: PUSH
86217: LD_VAR 0 55
86221: PUSH
86222: LD_VAR 0 56
86226: PUSH
86227: LD_VAR 0 57
86231: PUSH
86232: LD_VAR 0 58
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: PUSH
86245: LD_VAR 0 4
86249: PUSH
86250: LD_INT 1
86252: PLUS
86253: ARRAY
86254: ST_TO_ADDR
86255: GO 86364
86257: LD_INT 31
86259: DOUBLE
86260: EQUAL
86261: IFTRUE 86307
86263: LD_INT 32
86265: DOUBLE
86266: EQUAL
86267: IFTRUE 86307
86269: LD_INT 33
86271: DOUBLE
86272: EQUAL
86273: IFTRUE 86307
86275: LD_INT 27
86277: DOUBLE
86278: EQUAL
86279: IFTRUE 86307
86281: LD_INT 26
86283: DOUBLE
86284: EQUAL
86285: IFTRUE 86307
86287: LD_INT 28
86289: DOUBLE
86290: EQUAL
86291: IFTRUE 86307
86293: LD_INT 29
86295: DOUBLE
86296: EQUAL
86297: IFTRUE 86307
86299: LD_INT 30
86301: DOUBLE
86302: EQUAL
86303: IFTRUE 86307
86305: GO 86363
86307: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
86308: LD_ADDR_VAR 0 9
86312: PUSH
86313: LD_VAR 0 59
86317: PUSH
86318: LD_VAR 0 60
86322: PUSH
86323: LD_VAR 0 61
86327: PUSH
86328: LD_VAR 0 62
86332: PUSH
86333: LD_VAR 0 63
86337: PUSH
86338: LD_VAR 0 64
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: PUSH
86351: LD_VAR 0 4
86355: PUSH
86356: LD_INT 1
86358: PLUS
86359: ARRAY
86360: ST_TO_ADDR
86361: GO 86364
86363: POP
// temp_list2 = [ ] ;
86364: LD_ADDR_VAR 0 10
86368: PUSH
86369: EMPTY
86370: ST_TO_ADDR
// for i in temp_list do
86371: LD_ADDR_VAR 0 8
86375: PUSH
86376: LD_VAR 0 9
86380: PUSH
86381: FOR_IN
86382: IFFALSE 86434
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
86384: LD_ADDR_VAR 0 10
86388: PUSH
86389: LD_VAR 0 10
86393: PUSH
86394: LD_VAR 0 8
86398: PUSH
86399: LD_INT 1
86401: ARRAY
86402: PUSH
86403: LD_VAR 0 2
86407: PLUS
86408: PUSH
86409: LD_VAR 0 8
86413: PUSH
86414: LD_INT 2
86416: ARRAY
86417: PUSH
86418: LD_VAR 0 3
86422: PLUS
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: EMPTY
86429: LIST
86430: ADD
86431: ST_TO_ADDR
86432: GO 86381
86434: POP
86435: POP
// result = temp_list2 ;
86436: LD_ADDR_VAR 0 7
86440: PUSH
86441: LD_VAR 0 10
86445: ST_TO_ADDR
// end ;
86446: LD_VAR 0 7
86450: RET
// export function EnemyInRange ( unit , dist ) ; begin
86451: LD_INT 0
86453: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
86454: LD_ADDR_VAR 0 3
86458: PUSH
86459: LD_VAR 0 1
86463: PPUSH
86464: CALL_OW 255
86468: PPUSH
86469: LD_VAR 0 1
86473: PPUSH
86474: CALL_OW 250
86478: PPUSH
86479: LD_VAR 0 1
86483: PPUSH
86484: CALL_OW 251
86488: PPUSH
86489: LD_VAR 0 2
86493: PPUSH
86494: CALL 59824 0 4
86498: PUSH
86499: LD_INT 4
86501: ARRAY
86502: ST_TO_ADDR
// end ;
86503: LD_VAR 0 3
86507: RET
// export function PlayerSeeMe ( unit ) ; begin
86508: LD_INT 0
86510: PPUSH
// result := See ( your_side , unit ) ;
86511: LD_ADDR_VAR 0 2
86515: PUSH
86516: LD_OWVAR 2
86520: PPUSH
86521: LD_VAR 0 1
86525: PPUSH
86526: CALL_OW 292
86530: ST_TO_ADDR
// end ;
86531: LD_VAR 0 2
86535: RET
// export function ReverseDir ( unit ) ; begin
86536: LD_INT 0
86538: PPUSH
// if not unit then
86539: LD_VAR 0 1
86543: NOT
86544: IFFALSE 86548
// exit ;
86546: GO 86571
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
86548: LD_ADDR_VAR 0 2
86552: PUSH
86553: LD_VAR 0 1
86557: PPUSH
86558: CALL_OW 254
86562: PUSH
86563: LD_INT 3
86565: PLUS
86566: PUSH
86567: LD_INT 6
86569: MOD
86570: ST_TO_ADDR
// end ;
86571: LD_VAR 0 2
86575: RET
// export function ReverseArray ( array ) ; var i ; begin
86576: LD_INT 0
86578: PPUSH
86579: PPUSH
// if not array then
86580: LD_VAR 0 1
86584: NOT
86585: IFFALSE 86589
// exit ;
86587: GO 86644
// result := [ ] ;
86589: LD_ADDR_VAR 0 2
86593: PUSH
86594: EMPTY
86595: ST_TO_ADDR
// for i := array downto 1 do
86596: LD_ADDR_VAR 0 3
86600: PUSH
86601: DOUBLE
86602: LD_VAR 0 1
86606: INC
86607: ST_TO_ADDR
86608: LD_INT 1
86610: PUSH
86611: FOR_DOWNTO
86612: IFFALSE 86642
// result := Join ( result , array [ i ] ) ;
86614: LD_ADDR_VAR 0 2
86618: PUSH
86619: LD_VAR 0 2
86623: PPUSH
86624: LD_VAR 0 1
86628: PUSH
86629: LD_VAR 0 3
86633: ARRAY
86634: PPUSH
86635: CALL 91309 0 2
86639: ST_TO_ADDR
86640: GO 86611
86642: POP
86643: POP
// end ;
86644: LD_VAR 0 2
86648: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
86649: LD_INT 0
86651: PPUSH
86652: PPUSH
86653: PPUSH
86654: PPUSH
86655: PPUSH
86656: PPUSH
// if not unit or not hexes then
86657: LD_VAR 0 1
86661: NOT
86662: PUSH
86663: LD_VAR 0 2
86667: NOT
86668: OR
86669: IFFALSE 86673
// exit ;
86671: GO 86796
// dist := 9999 ;
86673: LD_ADDR_VAR 0 5
86677: PUSH
86678: LD_INT 9999
86680: ST_TO_ADDR
// for i = 1 to hexes do
86681: LD_ADDR_VAR 0 4
86685: PUSH
86686: DOUBLE
86687: LD_INT 1
86689: DEC
86690: ST_TO_ADDR
86691: LD_VAR 0 2
86695: PUSH
86696: FOR_TO
86697: IFFALSE 86784
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
86699: LD_ADDR_VAR 0 6
86703: PUSH
86704: LD_VAR 0 1
86708: PPUSH
86709: LD_VAR 0 2
86713: PUSH
86714: LD_VAR 0 4
86718: ARRAY
86719: PUSH
86720: LD_INT 1
86722: ARRAY
86723: PPUSH
86724: LD_VAR 0 2
86728: PUSH
86729: LD_VAR 0 4
86733: ARRAY
86734: PUSH
86735: LD_INT 2
86737: ARRAY
86738: PPUSH
86739: CALL_OW 297
86743: ST_TO_ADDR
// if tdist < dist then
86744: LD_VAR 0 6
86748: PUSH
86749: LD_VAR 0 5
86753: LESS
86754: IFFALSE 86782
// begin hex := hexes [ i ] ;
86756: LD_ADDR_VAR 0 8
86760: PUSH
86761: LD_VAR 0 2
86765: PUSH
86766: LD_VAR 0 4
86770: ARRAY
86771: ST_TO_ADDR
// dist := tdist ;
86772: LD_ADDR_VAR 0 5
86776: PUSH
86777: LD_VAR 0 6
86781: ST_TO_ADDR
// end ; end ;
86782: GO 86696
86784: POP
86785: POP
// result := hex ;
86786: LD_ADDR_VAR 0 3
86790: PUSH
86791: LD_VAR 0 8
86795: ST_TO_ADDR
// end ;
86796: LD_VAR 0 3
86800: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
86801: LD_INT 0
86803: PPUSH
86804: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86805: LD_VAR 0 1
86809: NOT
86810: PUSH
86811: LD_VAR 0 1
86815: PUSH
86816: LD_INT 21
86818: PUSH
86819: LD_INT 2
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 23
86828: PUSH
86829: LD_INT 2
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PPUSH
86840: CALL_OW 69
86844: IN
86845: NOT
86846: OR
86847: IFFALSE 86851
// exit ;
86849: GO 86898
// for i = 1 to 3 do
86851: LD_ADDR_VAR 0 3
86855: PUSH
86856: DOUBLE
86857: LD_INT 1
86859: DEC
86860: ST_TO_ADDR
86861: LD_INT 3
86863: PUSH
86864: FOR_TO
86865: IFFALSE 86896
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
86867: LD_VAR 0 1
86871: PPUSH
86872: CALL_OW 250
86876: PPUSH
86877: LD_VAR 0 1
86881: PPUSH
86882: CALL_OW 251
86886: PPUSH
86887: LD_INT 1
86889: PPUSH
86890: CALL_OW 453
86894: GO 86864
86896: POP
86897: POP
// end ;
86898: LD_VAR 0 2
86902: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
86903: LD_INT 0
86905: PPUSH
86906: PPUSH
86907: PPUSH
86908: PPUSH
86909: PPUSH
86910: PPUSH
// if not unit or not enemy_unit then
86911: LD_VAR 0 1
86915: NOT
86916: PUSH
86917: LD_VAR 0 2
86921: NOT
86922: OR
86923: IFFALSE 86927
// exit ;
86925: GO 87394
// if GetLives ( i ) < 250 then
86927: LD_VAR 0 4
86931: PPUSH
86932: CALL_OW 256
86936: PUSH
86937: LD_INT 250
86939: LESS
86940: IFFALSE 86953
// begin ComAutodestruct ( i ) ;
86942: LD_VAR 0 4
86946: PPUSH
86947: CALL 86801 0 1
// exit ;
86951: GO 87394
// end ; x := GetX ( enemy_unit ) ;
86953: LD_ADDR_VAR 0 7
86957: PUSH
86958: LD_VAR 0 2
86962: PPUSH
86963: CALL_OW 250
86967: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
86968: LD_ADDR_VAR 0 8
86972: PUSH
86973: LD_VAR 0 2
86977: PPUSH
86978: CALL_OW 251
86982: ST_TO_ADDR
// if not x or not y then
86983: LD_VAR 0 7
86987: NOT
86988: PUSH
86989: LD_VAR 0 8
86993: NOT
86994: OR
86995: IFFALSE 86999
// exit ;
86997: GO 87394
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
86999: LD_ADDR_VAR 0 6
87003: PUSH
87004: LD_VAR 0 7
87008: PPUSH
87009: LD_INT 0
87011: PPUSH
87012: LD_INT 4
87014: PPUSH
87015: CALL_OW 272
87019: PUSH
87020: LD_VAR 0 8
87024: PPUSH
87025: LD_INT 0
87027: PPUSH
87028: LD_INT 4
87030: PPUSH
87031: CALL_OW 273
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PUSH
87040: LD_VAR 0 7
87044: PPUSH
87045: LD_INT 1
87047: PPUSH
87048: LD_INT 4
87050: PPUSH
87051: CALL_OW 272
87055: PUSH
87056: LD_VAR 0 8
87060: PPUSH
87061: LD_INT 1
87063: PPUSH
87064: LD_INT 4
87066: PPUSH
87067: CALL_OW 273
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_VAR 0 7
87080: PPUSH
87081: LD_INT 2
87083: PPUSH
87084: LD_INT 4
87086: PPUSH
87087: CALL_OW 272
87091: PUSH
87092: LD_VAR 0 8
87096: PPUSH
87097: LD_INT 2
87099: PPUSH
87100: LD_INT 4
87102: PPUSH
87103: CALL_OW 273
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_VAR 0 7
87116: PPUSH
87117: LD_INT 3
87119: PPUSH
87120: LD_INT 4
87122: PPUSH
87123: CALL_OW 272
87127: PUSH
87128: LD_VAR 0 8
87132: PPUSH
87133: LD_INT 3
87135: PPUSH
87136: LD_INT 4
87138: PPUSH
87139: CALL_OW 273
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: LD_VAR 0 7
87152: PPUSH
87153: LD_INT 4
87155: PPUSH
87156: LD_INT 4
87158: PPUSH
87159: CALL_OW 272
87163: PUSH
87164: LD_VAR 0 8
87168: PPUSH
87169: LD_INT 4
87171: PPUSH
87172: LD_INT 4
87174: PPUSH
87175: CALL_OW 273
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: PUSH
87184: LD_VAR 0 7
87188: PPUSH
87189: LD_INT 5
87191: PPUSH
87192: LD_INT 4
87194: PPUSH
87195: CALL_OW 272
87199: PUSH
87200: LD_VAR 0 8
87204: PPUSH
87205: LD_INT 5
87207: PPUSH
87208: LD_INT 4
87210: PPUSH
87211: CALL_OW 273
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: ST_TO_ADDR
// for i = tmp downto 1 do
87228: LD_ADDR_VAR 0 4
87232: PUSH
87233: DOUBLE
87234: LD_VAR 0 6
87238: INC
87239: ST_TO_ADDR
87240: LD_INT 1
87242: PUSH
87243: FOR_DOWNTO
87244: IFFALSE 87345
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
87246: LD_VAR 0 6
87250: PUSH
87251: LD_VAR 0 4
87255: ARRAY
87256: PUSH
87257: LD_INT 1
87259: ARRAY
87260: PPUSH
87261: LD_VAR 0 6
87265: PUSH
87266: LD_VAR 0 4
87270: ARRAY
87271: PUSH
87272: LD_INT 2
87274: ARRAY
87275: PPUSH
87276: CALL_OW 488
87280: NOT
87281: PUSH
87282: LD_VAR 0 6
87286: PUSH
87287: LD_VAR 0 4
87291: ARRAY
87292: PUSH
87293: LD_INT 1
87295: ARRAY
87296: PPUSH
87297: LD_VAR 0 6
87301: PUSH
87302: LD_VAR 0 4
87306: ARRAY
87307: PUSH
87308: LD_INT 2
87310: ARRAY
87311: PPUSH
87312: CALL_OW 428
87316: PUSH
87317: LD_INT 0
87319: NONEQUAL
87320: OR
87321: IFFALSE 87343
// tmp := Delete ( tmp , i ) ;
87323: LD_ADDR_VAR 0 6
87327: PUSH
87328: LD_VAR 0 6
87332: PPUSH
87333: LD_VAR 0 4
87337: PPUSH
87338: CALL_OW 3
87342: ST_TO_ADDR
87343: GO 87243
87345: POP
87346: POP
// j := GetClosestHex ( unit , tmp ) ;
87347: LD_ADDR_VAR 0 5
87351: PUSH
87352: LD_VAR 0 1
87356: PPUSH
87357: LD_VAR 0 6
87361: PPUSH
87362: CALL 86649 0 2
87366: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
87367: LD_VAR 0 1
87371: PPUSH
87372: LD_VAR 0 5
87376: PUSH
87377: LD_INT 1
87379: ARRAY
87380: PPUSH
87381: LD_VAR 0 5
87385: PUSH
87386: LD_INT 2
87388: ARRAY
87389: PPUSH
87390: CALL_OW 111
// end ;
87394: LD_VAR 0 3
87398: RET
// export function PrepareApemanSoldier ( ) ; begin
87399: LD_INT 0
87401: PPUSH
// uc_nation := 0 ;
87402: LD_ADDR_OWVAR 21
87406: PUSH
87407: LD_INT 0
87409: ST_TO_ADDR
// hc_sex := sex_male ;
87410: LD_ADDR_OWVAR 27
87414: PUSH
87415: LD_INT 1
87417: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
87418: LD_ADDR_OWVAR 28
87422: PUSH
87423: LD_INT 15
87425: ST_TO_ADDR
// hc_gallery :=  ;
87426: LD_ADDR_OWVAR 33
87430: PUSH
87431: LD_STRING 
87433: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87434: LD_ADDR_OWVAR 31
87438: PUSH
87439: LD_INT 0
87441: PPUSH
87442: LD_INT 3
87444: PPUSH
87445: CALL_OW 12
87449: PUSH
87450: LD_INT 0
87452: PPUSH
87453: LD_INT 3
87455: PPUSH
87456: CALL_OW 12
87460: PUSH
87461: LD_INT 0
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: ST_TO_ADDR
// end ;
87473: LD_VAR 0 1
87477: RET
// export function PrepareApemanEngineer ( ) ; begin
87478: LD_INT 0
87480: PPUSH
// uc_nation := 0 ;
87481: LD_ADDR_OWVAR 21
87485: PUSH
87486: LD_INT 0
87488: ST_TO_ADDR
// hc_sex := sex_male ;
87489: LD_ADDR_OWVAR 27
87493: PUSH
87494: LD_INT 1
87496: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
87497: LD_ADDR_OWVAR 28
87501: PUSH
87502: LD_INT 16
87504: ST_TO_ADDR
// hc_gallery :=  ;
87505: LD_ADDR_OWVAR 33
87509: PUSH
87510: LD_STRING 
87512: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87513: LD_ADDR_OWVAR 31
87517: PUSH
87518: LD_INT 0
87520: PPUSH
87521: LD_INT 3
87523: PPUSH
87524: CALL_OW 12
87528: PUSH
87529: LD_INT 0
87531: PPUSH
87532: LD_INT 3
87534: PPUSH
87535: CALL_OW 12
87539: PUSH
87540: LD_INT 0
87542: PUSH
87543: LD_INT 0
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: ST_TO_ADDR
// end ;
87552: LD_VAR 0 1
87556: RET
// export function PrepareApeman ( agressivity ) ; begin
87557: LD_INT 0
87559: PPUSH
// uc_side := 0 ;
87560: LD_ADDR_OWVAR 20
87564: PUSH
87565: LD_INT 0
87567: ST_TO_ADDR
// uc_nation := 0 ;
87568: LD_ADDR_OWVAR 21
87572: PUSH
87573: LD_INT 0
87575: ST_TO_ADDR
// hc_sex := sex_male ;
87576: LD_ADDR_OWVAR 27
87580: PUSH
87581: LD_INT 1
87583: ST_TO_ADDR
// hc_class := class_apeman ;
87584: LD_ADDR_OWVAR 28
87588: PUSH
87589: LD_INT 12
87591: ST_TO_ADDR
// hc_gallery :=  ;
87592: LD_ADDR_OWVAR 33
87596: PUSH
87597: LD_STRING 
87599: ST_TO_ADDR
// if agressivity = 0 then
87600: LD_VAR 0 1
87604: PUSH
87605: LD_INT 0
87607: EQUAL
87608: IFFALSE 87620
// hc_agressivity := 0 else
87610: LD_ADDR_OWVAR 35
87614: PUSH
87615: LD_INT 0
87617: ST_TO_ADDR
87618: GO 87641
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87620: LD_ADDR_OWVAR 35
87624: PUSH
87625: LD_VAR 0 1
87629: NEG
87630: PPUSH
87631: LD_VAR 0 1
87635: PPUSH
87636: CALL_OW 12
87640: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87641: LD_ADDR_OWVAR 31
87645: PUSH
87646: LD_INT 0
87648: PPUSH
87649: LD_INT 3
87651: PPUSH
87652: CALL_OW 12
87656: PUSH
87657: LD_INT 0
87659: PPUSH
87660: LD_INT 3
87662: PPUSH
87663: CALL_OW 12
87667: PUSH
87668: LD_INT 0
87670: PUSH
87671: LD_INT 0
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: ST_TO_ADDR
// end ;
87680: LD_VAR 0 2
87684: RET
// export function PrepareTiger ( agressivity ) ; begin
87685: LD_INT 0
87687: PPUSH
// uc_side := 0 ;
87688: LD_ADDR_OWVAR 20
87692: PUSH
87693: LD_INT 0
87695: ST_TO_ADDR
// uc_nation := 0 ;
87696: LD_ADDR_OWVAR 21
87700: PUSH
87701: LD_INT 0
87703: ST_TO_ADDR
// hc_class := class_tiger ;
87704: LD_ADDR_OWVAR 28
87708: PUSH
87709: LD_INT 14
87711: ST_TO_ADDR
// hc_gallery :=  ;
87712: LD_ADDR_OWVAR 33
87716: PUSH
87717: LD_STRING 
87719: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87720: LD_ADDR_OWVAR 35
87724: PUSH
87725: LD_VAR 0 1
87729: NEG
87730: PPUSH
87731: LD_VAR 0 1
87735: PPUSH
87736: CALL_OW 12
87740: ST_TO_ADDR
// end ;
87741: LD_VAR 0 2
87745: RET
// export function PrepareEnchidna ( ) ; begin
87746: LD_INT 0
87748: PPUSH
// uc_side := 0 ;
87749: LD_ADDR_OWVAR 20
87753: PUSH
87754: LD_INT 0
87756: ST_TO_ADDR
// uc_nation := 0 ;
87757: LD_ADDR_OWVAR 21
87761: PUSH
87762: LD_INT 0
87764: ST_TO_ADDR
// hc_class := class_baggie ;
87765: LD_ADDR_OWVAR 28
87769: PUSH
87770: LD_INT 13
87772: ST_TO_ADDR
// hc_gallery :=  ;
87773: LD_ADDR_OWVAR 33
87777: PUSH
87778: LD_STRING 
87780: ST_TO_ADDR
// end ;
87781: LD_VAR 0 1
87785: RET
// export function PrepareFrog ( ) ; begin
87786: LD_INT 0
87788: PPUSH
// uc_side := 0 ;
87789: LD_ADDR_OWVAR 20
87793: PUSH
87794: LD_INT 0
87796: ST_TO_ADDR
// uc_nation := 0 ;
87797: LD_ADDR_OWVAR 21
87801: PUSH
87802: LD_INT 0
87804: ST_TO_ADDR
// hc_class := class_frog ;
87805: LD_ADDR_OWVAR 28
87809: PUSH
87810: LD_INT 19
87812: ST_TO_ADDR
// hc_gallery :=  ;
87813: LD_ADDR_OWVAR 33
87817: PUSH
87818: LD_STRING 
87820: ST_TO_ADDR
// end ;
87821: LD_VAR 0 1
87825: RET
// export function PrepareFish ( ) ; begin
87826: LD_INT 0
87828: PPUSH
// uc_side := 0 ;
87829: LD_ADDR_OWVAR 20
87833: PUSH
87834: LD_INT 0
87836: ST_TO_ADDR
// uc_nation := 0 ;
87837: LD_ADDR_OWVAR 21
87841: PUSH
87842: LD_INT 0
87844: ST_TO_ADDR
// hc_class := class_fish ;
87845: LD_ADDR_OWVAR 28
87849: PUSH
87850: LD_INT 20
87852: ST_TO_ADDR
// hc_gallery :=  ;
87853: LD_ADDR_OWVAR 33
87857: PUSH
87858: LD_STRING 
87860: ST_TO_ADDR
// end ;
87861: LD_VAR 0 1
87865: RET
// export function PrepareBird ( ) ; begin
87866: LD_INT 0
87868: PPUSH
// uc_side := 0 ;
87869: LD_ADDR_OWVAR 20
87873: PUSH
87874: LD_INT 0
87876: ST_TO_ADDR
// uc_nation := 0 ;
87877: LD_ADDR_OWVAR 21
87881: PUSH
87882: LD_INT 0
87884: ST_TO_ADDR
// hc_class := class_phororhacos ;
87885: LD_ADDR_OWVAR 28
87889: PUSH
87890: LD_INT 18
87892: ST_TO_ADDR
// hc_gallery :=  ;
87893: LD_ADDR_OWVAR 33
87897: PUSH
87898: LD_STRING 
87900: ST_TO_ADDR
// end ;
87901: LD_VAR 0 1
87905: RET
// export function PrepareHorse ( ) ; begin
87906: LD_INT 0
87908: PPUSH
// uc_side := 0 ;
87909: LD_ADDR_OWVAR 20
87913: PUSH
87914: LD_INT 0
87916: ST_TO_ADDR
// uc_nation := 0 ;
87917: LD_ADDR_OWVAR 21
87921: PUSH
87922: LD_INT 0
87924: ST_TO_ADDR
// hc_class := class_horse ;
87925: LD_ADDR_OWVAR 28
87929: PUSH
87930: LD_INT 21
87932: ST_TO_ADDR
// hc_gallery :=  ;
87933: LD_ADDR_OWVAR 33
87937: PUSH
87938: LD_STRING 
87940: ST_TO_ADDR
// end ;
87941: LD_VAR 0 1
87945: RET
// export function PrepareMastodont ( ) ; begin
87946: LD_INT 0
87948: PPUSH
// uc_side := 0 ;
87949: LD_ADDR_OWVAR 20
87953: PUSH
87954: LD_INT 0
87956: ST_TO_ADDR
// uc_nation := 0 ;
87957: LD_ADDR_OWVAR 21
87961: PUSH
87962: LD_INT 0
87964: ST_TO_ADDR
// vc_chassis := class_mastodont ;
87965: LD_ADDR_OWVAR 37
87969: PUSH
87970: LD_INT 31
87972: ST_TO_ADDR
// vc_control := control_rider ;
87973: LD_ADDR_OWVAR 38
87977: PUSH
87978: LD_INT 4
87980: ST_TO_ADDR
// end ;
87981: LD_VAR 0 1
87985: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
87986: LD_INT 0
87988: PPUSH
87989: PPUSH
87990: PPUSH
// uc_side = 0 ;
87991: LD_ADDR_OWVAR 20
87995: PUSH
87996: LD_INT 0
87998: ST_TO_ADDR
// uc_nation = 0 ;
87999: LD_ADDR_OWVAR 21
88003: PUSH
88004: LD_INT 0
88006: ST_TO_ADDR
// InitHc_All ( ) ;
88007: CALL_OW 584
// InitVc ;
88011: CALL_OW 20
// if mastodonts then
88015: LD_VAR 0 6
88019: IFFALSE 88086
// for i = 1 to mastodonts do
88021: LD_ADDR_VAR 0 11
88025: PUSH
88026: DOUBLE
88027: LD_INT 1
88029: DEC
88030: ST_TO_ADDR
88031: LD_VAR 0 6
88035: PUSH
88036: FOR_TO
88037: IFFALSE 88084
// begin vc_chassis := 31 ;
88039: LD_ADDR_OWVAR 37
88043: PUSH
88044: LD_INT 31
88046: ST_TO_ADDR
// vc_control := control_rider ;
88047: LD_ADDR_OWVAR 38
88051: PUSH
88052: LD_INT 4
88054: ST_TO_ADDR
// animal := CreateVehicle ;
88055: LD_ADDR_VAR 0 12
88059: PUSH
88060: CALL_OW 45
88064: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88065: LD_VAR 0 12
88069: PPUSH
88070: LD_VAR 0 8
88074: PPUSH
88075: LD_INT 0
88077: PPUSH
88078: CALL 90214 0 3
// end ;
88082: GO 88036
88084: POP
88085: POP
// if horses then
88086: LD_VAR 0 5
88090: IFFALSE 88157
// for i = 1 to horses do
88092: LD_ADDR_VAR 0 11
88096: PUSH
88097: DOUBLE
88098: LD_INT 1
88100: DEC
88101: ST_TO_ADDR
88102: LD_VAR 0 5
88106: PUSH
88107: FOR_TO
88108: IFFALSE 88155
// begin hc_class := 21 ;
88110: LD_ADDR_OWVAR 28
88114: PUSH
88115: LD_INT 21
88117: ST_TO_ADDR
// hc_gallery :=  ;
88118: LD_ADDR_OWVAR 33
88122: PUSH
88123: LD_STRING 
88125: ST_TO_ADDR
// animal := CreateHuman ;
88126: LD_ADDR_VAR 0 12
88130: PUSH
88131: CALL_OW 44
88135: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88136: LD_VAR 0 12
88140: PPUSH
88141: LD_VAR 0 8
88145: PPUSH
88146: LD_INT 0
88148: PPUSH
88149: CALL 90214 0 3
// end ;
88153: GO 88107
88155: POP
88156: POP
// if birds then
88157: LD_VAR 0 1
88161: IFFALSE 88228
// for i = 1 to birds do
88163: LD_ADDR_VAR 0 11
88167: PUSH
88168: DOUBLE
88169: LD_INT 1
88171: DEC
88172: ST_TO_ADDR
88173: LD_VAR 0 1
88177: PUSH
88178: FOR_TO
88179: IFFALSE 88226
// begin hc_class := 18 ;
88181: LD_ADDR_OWVAR 28
88185: PUSH
88186: LD_INT 18
88188: ST_TO_ADDR
// hc_gallery =  ;
88189: LD_ADDR_OWVAR 33
88193: PUSH
88194: LD_STRING 
88196: ST_TO_ADDR
// animal := CreateHuman ;
88197: LD_ADDR_VAR 0 12
88201: PUSH
88202: CALL_OW 44
88206: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88207: LD_VAR 0 12
88211: PPUSH
88212: LD_VAR 0 8
88216: PPUSH
88217: LD_INT 0
88219: PPUSH
88220: CALL 90214 0 3
// end ;
88224: GO 88178
88226: POP
88227: POP
// if tigers then
88228: LD_VAR 0 2
88232: IFFALSE 88316
// for i = 1 to tigers do
88234: LD_ADDR_VAR 0 11
88238: PUSH
88239: DOUBLE
88240: LD_INT 1
88242: DEC
88243: ST_TO_ADDR
88244: LD_VAR 0 2
88248: PUSH
88249: FOR_TO
88250: IFFALSE 88314
// begin hc_class = class_tiger ;
88252: LD_ADDR_OWVAR 28
88256: PUSH
88257: LD_INT 14
88259: ST_TO_ADDR
// hc_gallery =  ;
88260: LD_ADDR_OWVAR 33
88264: PUSH
88265: LD_STRING 
88267: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
88268: LD_ADDR_OWVAR 35
88272: PUSH
88273: LD_INT 7
88275: NEG
88276: PPUSH
88277: LD_INT 7
88279: PPUSH
88280: CALL_OW 12
88284: ST_TO_ADDR
// animal := CreateHuman ;
88285: LD_ADDR_VAR 0 12
88289: PUSH
88290: CALL_OW 44
88294: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88295: LD_VAR 0 12
88299: PPUSH
88300: LD_VAR 0 8
88304: PPUSH
88305: LD_INT 0
88307: PPUSH
88308: CALL 90214 0 3
// end ;
88312: GO 88249
88314: POP
88315: POP
// if apemans then
88316: LD_VAR 0 3
88320: IFFALSE 88443
// for i = 1 to apemans do
88322: LD_ADDR_VAR 0 11
88326: PUSH
88327: DOUBLE
88328: LD_INT 1
88330: DEC
88331: ST_TO_ADDR
88332: LD_VAR 0 3
88336: PUSH
88337: FOR_TO
88338: IFFALSE 88441
// begin hc_class = class_apeman ;
88340: LD_ADDR_OWVAR 28
88344: PUSH
88345: LD_INT 12
88347: ST_TO_ADDR
// hc_gallery =  ;
88348: LD_ADDR_OWVAR 33
88352: PUSH
88353: LD_STRING 
88355: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
88356: LD_ADDR_OWVAR 35
88360: PUSH
88361: LD_INT 2
88363: NEG
88364: PPUSH
88365: LD_INT 2
88367: PPUSH
88368: CALL_OW 12
88372: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
88373: LD_ADDR_OWVAR 31
88377: PUSH
88378: LD_INT 1
88380: PPUSH
88381: LD_INT 3
88383: PPUSH
88384: CALL_OW 12
88388: PUSH
88389: LD_INT 1
88391: PPUSH
88392: LD_INT 3
88394: PPUSH
88395: CALL_OW 12
88399: PUSH
88400: LD_INT 0
88402: PUSH
88403: LD_INT 0
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: ST_TO_ADDR
// animal := CreateHuman ;
88412: LD_ADDR_VAR 0 12
88416: PUSH
88417: CALL_OW 44
88421: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88422: LD_VAR 0 12
88426: PPUSH
88427: LD_VAR 0 8
88431: PPUSH
88432: LD_INT 0
88434: PPUSH
88435: CALL 90214 0 3
// end ;
88439: GO 88337
88441: POP
88442: POP
// if enchidnas then
88443: LD_VAR 0 4
88447: IFFALSE 88514
// for i = 1 to enchidnas do
88449: LD_ADDR_VAR 0 11
88453: PUSH
88454: DOUBLE
88455: LD_INT 1
88457: DEC
88458: ST_TO_ADDR
88459: LD_VAR 0 4
88463: PUSH
88464: FOR_TO
88465: IFFALSE 88512
// begin hc_class = 13 ;
88467: LD_ADDR_OWVAR 28
88471: PUSH
88472: LD_INT 13
88474: ST_TO_ADDR
// hc_gallery =  ;
88475: LD_ADDR_OWVAR 33
88479: PUSH
88480: LD_STRING 
88482: ST_TO_ADDR
// animal := CreateHuman ;
88483: LD_ADDR_VAR 0 12
88487: PUSH
88488: CALL_OW 44
88492: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88493: LD_VAR 0 12
88497: PPUSH
88498: LD_VAR 0 8
88502: PPUSH
88503: LD_INT 0
88505: PPUSH
88506: CALL 90214 0 3
// end ;
88510: GO 88464
88512: POP
88513: POP
// if fishes then
88514: LD_VAR 0 7
88518: IFFALSE 88585
// for i = 1 to fishes do
88520: LD_ADDR_VAR 0 11
88524: PUSH
88525: DOUBLE
88526: LD_INT 1
88528: DEC
88529: ST_TO_ADDR
88530: LD_VAR 0 7
88534: PUSH
88535: FOR_TO
88536: IFFALSE 88583
// begin hc_class = 20 ;
88538: LD_ADDR_OWVAR 28
88542: PUSH
88543: LD_INT 20
88545: ST_TO_ADDR
// hc_gallery =  ;
88546: LD_ADDR_OWVAR 33
88550: PUSH
88551: LD_STRING 
88553: ST_TO_ADDR
// animal := CreateHuman ;
88554: LD_ADDR_VAR 0 12
88558: PUSH
88559: CALL_OW 44
88563: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
88564: LD_VAR 0 12
88568: PPUSH
88569: LD_VAR 0 9
88573: PPUSH
88574: LD_INT 0
88576: PPUSH
88577: CALL 90214 0 3
// end ;
88581: GO 88535
88583: POP
88584: POP
// end ;
88585: LD_VAR 0 10
88589: RET
// export function WantHeal ( sci , unit ) ; begin
88590: LD_INT 0
88592: PPUSH
// if GetTaskList ( sci ) > 0 then
88593: LD_VAR 0 1
88597: PPUSH
88598: CALL_OW 437
88602: PUSH
88603: LD_INT 0
88605: GREATER
88606: IFFALSE 88676
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
88608: LD_VAR 0 1
88612: PPUSH
88613: CALL_OW 437
88617: PUSH
88618: LD_INT 1
88620: ARRAY
88621: PUSH
88622: LD_INT 1
88624: ARRAY
88625: PUSH
88626: LD_STRING l
88628: EQUAL
88629: PUSH
88630: LD_VAR 0 1
88634: PPUSH
88635: CALL_OW 437
88639: PUSH
88640: LD_INT 1
88642: ARRAY
88643: PUSH
88644: LD_INT 4
88646: ARRAY
88647: PUSH
88648: LD_VAR 0 2
88652: EQUAL
88653: AND
88654: IFFALSE 88666
// result := true else
88656: LD_ADDR_VAR 0 3
88660: PUSH
88661: LD_INT 1
88663: ST_TO_ADDR
88664: GO 88674
// result := false ;
88666: LD_ADDR_VAR 0 3
88670: PUSH
88671: LD_INT 0
88673: ST_TO_ADDR
// end else
88674: GO 88684
// result := false ;
88676: LD_ADDR_VAR 0 3
88680: PUSH
88681: LD_INT 0
88683: ST_TO_ADDR
// end ;
88684: LD_VAR 0 3
88688: RET
// export function HealTarget ( sci ) ; begin
88689: LD_INT 0
88691: PPUSH
// if not sci then
88692: LD_VAR 0 1
88696: NOT
88697: IFFALSE 88701
// exit ;
88699: GO 88766
// result := 0 ;
88701: LD_ADDR_VAR 0 2
88705: PUSH
88706: LD_INT 0
88708: ST_TO_ADDR
// if GetTaskList ( sci ) then
88709: LD_VAR 0 1
88713: PPUSH
88714: CALL_OW 437
88718: IFFALSE 88766
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
88720: LD_VAR 0 1
88724: PPUSH
88725: CALL_OW 437
88729: PUSH
88730: LD_INT 1
88732: ARRAY
88733: PUSH
88734: LD_INT 1
88736: ARRAY
88737: PUSH
88738: LD_STRING l
88740: EQUAL
88741: IFFALSE 88766
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
88743: LD_ADDR_VAR 0 2
88747: PUSH
88748: LD_VAR 0 1
88752: PPUSH
88753: CALL_OW 437
88757: PUSH
88758: LD_INT 1
88760: ARRAY
88761: PUSH
88762: LD_INT 4
88764: ARRAY
88765: ST_TO_ADDR
// end ;
88766: LD_VAR 0 2
88770: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
88771: LD_INT 0
88773: PPUSH
88774: PPUSH
88775: PPUSH
88776: PPUSH
// if not base_units then
88777: LD_VAR 0 1
88781: NOT
88782: IFFALSE 88786
// exit ;
88784: GO 88873
// result := false ;
88786: LD_ADDR_VAR 0 2
88790: PUSH
88791: LD_INT 0
88793: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
88794: LD_ADDR_VAR 0 5
88798: PUSH
88799: LD_VAR 0 1
88803: PPUSH
88804: LD_INT 21
88806: PUSH
88807: LD_INT 3
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PPUSH
88814: CALL_OW 72
88818: ST_TO_ADDR
// if not tmp then
88819: LD_VAR 0 5
88823: NOT
88824: IFFALSE 88828
// exit ;
88826: GO 88873
// for i in tmp do
88828: LD_ADDR_VAR 0 3
88832: PUSH
88833: LD_VAR 0 5
88837: PUSH
88838: FOR_IN
88839: IFFALSE 88871
// begin result := EnemyInRange ( i , 22 ) ;
88841: LD_ADDR_VAR 0 2
88845: PUSH
88846: LD_VAR 0 3
88850: PPUSH
88851: LD_INT 22
88853: PPUSH
88854: CALL 86451 0 2
88858: ST_TO_ADDR
// if result then
88859: LD_VAR 0 2
88863: IFFALSE 88869
// exit ;
88865: POP
88866: POP
88867: GO 88873
// end ;
88869: GO 88838
88871: POP
88872: POP
// end ;
88873: LD_VAR 0 2
88877: RET
// export function FilterByTag ( units , tag ) ; begin
88878: LD_INT 0
88880: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
88881: LD_ADDR_VAR 0 3
88885: PUSH
88886: LD_VAR 0 1
88890: PPUSH
88891: LD_INT 120
88893: PUSH
88894: LD_VAR 0 2
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PPUSH
88903: CALL_OW 72
88907: ST_TO_ADDR
// end ;
88908: LD_VAR 0 3
88912: RET
// export function IsDriver ( un ) ; begin
88913: LD_INT 0
88915: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
88916: LD_ADDR_VAR 0 2
88920: PUSH
88921: LD_VAR 0 1
88925: PUSH
88926: LD_INT 55
88928: PUSH
88929: EMPTY
88930: LIST
88931: PPUSH
88932: CALL_OW 69
88936: IN
88937: ST_TO_ADDR
// end ;
88938: LD_VAR 0 2
88942: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
88943: LD_INT 0
88945: PPUSH
88946: PPUSH
// list := [ ] ;
88947: LD_ADDR_VAR 0 5
88951: PUSH
88952: EMPTY
88953: ST_TO_ADDR
// case d of 0 :
88954: LD_VAR 0 3
88958: PUSH
88959: LD_INT 0
88961: DOUBLE
88962: EQUAL
88963: IFTRUE 88967
88965: GO 89100
88967: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
88968: LD_ADDR_VAR 0 5
88972: PUSH
88973: LD_VAR 0 1
88977: PUSH
88978: LD_INT 4
88980: MINUS
88981: PUSH
88982: LD_VAR 0 2
88986: PUSH
88987: LD_INT 4
88989: MINUS
88990: PUSH
88991: LD_INT 2
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: LIST
88998: PUSH
88999: LD_VAR 0 1
89003: PUSH
89004: LD_INT 3
89006: MINUS
89007: PUSH
89008: LD_VAR 0 2
89012: PUSH
89013: LD_INT 1
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: LIST
89020: PUSH
89021: LD_VAR 0 1
89025: PUSH
89026: LD_INT 4
89028: PLUS
89029: PUSH
89030: LD_VAR 0 2
89034: PUSH
89035: LD_INT 4
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: LIST
89042: PUSH
89043: LD_VAR 0 1
89047: PUSH
89048: LD_INT 3
89050: PLUS
89051: PUSH
89052: LD_VAR 0 2
89056: PUSH
89057: LD_INT 3
89059: PLUS
89060: PUSH
89061: LD_INT 5
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: LIST
89068: PUSH
89069: LD_VAR 0 1
89073: PUSH
89074: LD_VAR 0 2
89078: PUSH
89079: LD_INT 4
89081: PLUS
89082: PUSH
89083: LD_INT 0
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: LIST
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: ST_TO_ADDR
// end ; 1 :
89098: GO 89798
89100: LD_INT 1
89102: DOUBLE
89103: EQUAL
89104: IFTRUE 89108
89106: GO 89241
89108: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
89109: LD_ADDR_VAR 0 5
89113: PUSH
89114: LD_VAR 0 1
89118: PUSH
89119: LD_VAR 0 2
89123: PUSH
89124: LD_INT 4
89126: MINUS
89127: PUSH
89128: LD_INT 3
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: LIST
89135: PUSH
89136: LD_VAR 0 1
89140: PUSH
89141: LD_INT 3
89143: MINUS
89144: PUSH
89145: LD_VAR 0 2
89149: PUSH
89150: LD_INT 3
89152: MINUS
89153: PUSH
89154: LD_INT 2
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: LIST
89161: PUSH
89162: LD_VAR 0 1
89166: PUSH
89167: LD_INT 4
89169: MINUS
89170: PUSH
89171: LD_VAR 0 2
89175: PUSH
89176: LD_INT 1
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: LIST
89183: PUSH
89184: LD_VAR 0 1
89188: PUSH
89189: LD_VAR 0 2
89193: PUSH
89194: LD_INT 3
89196: PLUS
89197: PUSH
89198: LD_INT 0
89200: PUSH
89201: EMPTY
89202: LIST
89203: LIST
89204: LIST
89205: PUSH
89206: LD_VAR 0 1
89210: PUSH
89211: LD_INT 4
89213: PLUS
89214: PUSH
89215: LD_VAR 0 2
89219: PUSH
89220: LD_INT 4
89222: PLUS
89223: PUSH
89224: LD_INT 5
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: LIST
89231: PUSH
89232: EMPTY
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: ST_TO_ADDR
// end ; 2 :
89239: GO 89798
89241: LD_INT 2
89243: DOUBLE
89244: EQUAL
89245: IFTRUE 89249
89247: GO 89378
89249: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
89250: LD_ADDR_VAR 0 5
89254: PUSH
89255: LD_VAR 0 1
89259: PUSH
89260: LD_VAR 0 2
89264: PUSH
89265: LD_INT 3
89267: MINUS
89268: PUSH
89269: LD_INT 3
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: LIST
89276: PUSH
89277: LD_VAR 0 1
89281: PUSH
89282: LD_INT 4
89284: PLUS
89285: PUSH
89286: LD_VAR 0 2
89290: PUSH
89291: LD_INT 4
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: LIST
89298: PUSH
89299: LD_VAR 0 1
89303: PUSH
89304: LD_VAR 0 2
89308: PUSH
89309: LD_INT 4
89311: PLUS
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: LIST
89320: PUSH
89321: LD_VAR 0 1
89325: PUSH
89326: LD_INT 3
89328: MINUS
89329: PUSH
89330: LD_VAR 0 2
89334: PUSH
89335: LD_INT 1
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: LIST
89342: PUSH
89343: LD_VAR 0 1
89347: PUSH
89348: LD_INT 4
89350: MINUS
89351: PUSH
89352: LD_VAR 0 2
89356: PUSH
89357: LD_INT 4
89359: MINUS
89360: PUSH
89361: LD_INT 2
89363: PUSH
89364: EMPTY
89365: LIST
89366: LIST
89367: LIST
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: ST_TO_ADDR
// end ; 3 :
89376: GO 89798
89378: LD_INT 3
89380: DOUBLE
89381: EQUAL
89382: IFTRUE 89386
89384: GO 89519
89386: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
89387: LD_ADDR_VAR 0 5
89391: PUSH
89392: LD_VAR 0 1
89396: PUSH
89397: LD_INT 3
89399: PLUS
89400: PUSH
89401: LD_VAR 0 2
89405: PUSH
89406: LD_INT 4
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: LIST
89413: PUSH
89414: LD_VAR 0 1
89418: PUSH
89419: LD_INT 4
89421: PLUS
89422: PUSH
89423: LD_VAR 0 2
89427: PUSH
89428: LD_INT 4
89430: PLUS
89431: PUSH
89432: LD_INT 5
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: LIST
89439: PUSH
89440: LD_VAR 0 1
89444: PUSH
89445: LD_INT 4
89447: MINUS
89448: PUSH
89449: LD_VAR 0 2
89453: PUSH
89454: LD_INT 1
89456: PUSH
89457: EMPTY
89458: LIST
89459: LIST
89460: LIST
89461: PUSH
89462: LD_VAR 0 1
89466: PUSH
89467: LD_VAR 0 2
89471: PUSH
89472: LD_INT 4
89474: MINUS
89475: PUSH
89476: LD_INT 3
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: LIST
89483: PUSH
89484: LD_VAR 0 1
89488: PUSH
89489: LD_INT 3
89491: MINUS
89492: PUSH
89493: LD_VAR 0 2
89497: PUSH
89498: LD_INT 3
89500: MINUS
89501: PUSH
89502: LD_INT 2
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: LIST
89509: PUSH
89510: EMPTY
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: ST_TO_ADDR
// end ; 4 :
89517: GO 89798
89519: LD_INT 4
89521: DOUBLE
89522: EQUAL
89523: IFTRUE 89527
89525: GO 89660
89527: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
89528: LD_ADDR_VAR 0 5
89532: PUSH
89533: LD_VAR 0 1
89537: PUSH
89538: LD_VAR 0 2
89542: PUSH
89543: LD_INT 4
89545: PLUS
89546: PUSH
89547: LD_INT 0
89549: PUSH
89550: EMPTY
89551: LIST
89552: LIST
89553: LIST
89554: PUSH
89555: LD_VAR 0 1
89559: PUSH
89560: LD_INT 3
89562: PLUS
89563: PUSH
89564: LD_VAR 0 2
89568: PUSH
89569: LD_INT 3
89571: PLUS
89572: PUSH
89573: LD_INT 5
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: LIST
89580: PUSH
89581: LD_VAR 0 1
89585: PUSH
89586: LD_INT 4
89588: PLUS
89589: PUSH
89590: LD_VAR 0 2
89594: PUSH
89595: LD_INT 4
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: LIST
89602: PUSH
89603: LD_VAR 0 1
89607: PUSH
89608: LD_VAR 0 2
89612: PUSH
89613: LD_INT 3
89615: MINUS
89616: PUSH
89617: LD_INT 3
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: LIST
89624: PUSH
89625: LD_VAR 0 1
89629: PUSH
89630: LD_INT 4
89632: MINUS
89633: PUSH
89634: LD_VAR 0 2
89638: PUSH
89639: LD_INT 4
89641: MINUS
89642: PUSH
89643: LD_INT 2
89645: PUSH
89646: EMPTY
89647: LIST
89648: LIST
89649: LIST
89650: PUSH
89651: EMPTY
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: ST_TO_ADDR
// end ; 5 :
89658: GO 89798
89660: LD_INT 5
89662: DOUBLE
89663: EQUAL
89664: IFTRUE 89668
89666: GO 89797
89668: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
89669: LD_ADDR_VAR 0 5
89673: PUSH
89674: LD_VAR 0 1
89678: PUSH
89679: LD_INT 4
89681: MINUS
89682: PUSH
89683: LD_VAR 0 2
89687: PUSH
89688: LD_INT 1
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: LIST
89695: PUSH
89696: LD_VAR 0 1
89700: PUSH
89701: LD_VAR 0 2
89705: PUSH
89706: LD_INT 4
89708: MINUS
89709: PUSH
89710: LD_INT 3
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: LIST
89717: PUSH
89718: LD_VAR 0 1
89722: PUSH
89723: LD_INT 4
89725: PLUS
89726: PUSH
89727: LD_VAR 0 2
89731: PUSH
89732: LD_INT 4
89734: PLUS
89735: PUSH
89736: LD_INT 5
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: LIST
89743: PUSH
89744: LD_VAR 0 1
89748: PUSH
89749: LD_INT 3
89751: PLUS
89752: PUSH
89753: LD_VAR 0 2
89757: PUSH
89758: LD_INT 4
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: LIST
89765: PUSH
89766: LD_VAR 0 1
89770: PUSH
89771: LD_VAR 0 2
89775: PUSH
89776: LD_INT 3
89778: PLUS
89779: PUSH
89780: LD_INT 0
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: LIST
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: ST_TO_ADDR
// end ; end ;
89795: GO 89798
89797: POP
// result := list ;
89798: LD_ADDR_VAR 0 4
89802: PUSH
89803: LD_VAR 0 5
89807: ST_TO_ADDR
// end ;
89808: LD_VAR 0 4
89812: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
89813: LD_INT 0
89815: PPUSH
89816: PPUSH
89817: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
89818: LD_VAR 0 1
89822: NOT
89823: PUSH
89824: LD_VAR 0 2
89828: PUSH
89829: LD_INT 1
89831: PUSH
89832: LD_INT 2
89834: PUSH
89835: LD_INT 3
89837: PUSH
89838: LD_INT 4
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: IN
89847: NOT
89848: OR
89849: IFFALSE 89853
// exit ;
89851: GO 89936
// tmp := [ ] ;
89853: LD_ADDR_VAR 0 5
89857: PUSH
89858: EMPTY
89859: ST_TO_ADDR
// for i in units do
89860: LD_ADDR_VAR 0 4
89864: PUSH
89865: LD_VAR 0 1
89869: PUSH
89870: FOR_IN
89871: IFFALSE 89905
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
89873: LD_ADDR_VAR 0 5
89877: PUSH
89878: LD_VAR 0 5
89882: PPUSH
89883: LD_VAR 0 4
89887: PPUSH
89888: LD_VAR 0 2
89892: PPUSH
89893: CALL_OW 259
89897: PPUSH
89898: CALL 91309 0 2
89902: ST_TO_ADDR
89903: GO 89870
89905: POP
89906: POP
// if not tmp then
89907: LD_VAR 0 5
89911: NOT
89912: IFFALSE 89916
// exit ;
89914: GO 89936
// result := SortListByListDesc ( units , tmp ) ;
89916: LD_ADDR_VAR 0 3
89920: PUSH
89921: LD_VAR 0 1
89925: PPUSH
89926: LD_VAR 0 5
89930: PPUSH
89931: CALL_OW 77
89935: ST_TO_ADDR
// end ;
89936: LD_VAR 0 3
89940: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
89941: LD_INT 0
89943: PPUSH
89944: PPUSH
89945: PPUSH
// result := false ;
89946: LD_ADDR_VAR 0 3
89950: PUSH
89951: LD_INT 0
89953: ST_TO_ADDR
// if not building then
89954: LD_VAR 0 2
89958: NOT
89959: IFFALSE 89963
// exit ;
89961: GO 90101
// x := GetX ( building ) ;
89963: LD_ADDR_VAR 0 4
89967: PUSH
89968: LD_VAR 0 2
89972: PPUSH
89973: CALL_OW 250
89977: ST_TO_ADDR
// y := GetY ( building ) ;
89978: LD_ADDR_VAR 0 5
89982: PUSH
89983: LD_VAR 0 2
89987: PPUSH
89988: CALL_OW 251
89992: ST_TO_ADDR
// if not x or not y then
89993: LD_VAR 0 4
89997: NOT
89998: PUSH
89999: LD_VAR 0 5
90003: NOT
90004: OR
90005: IFFALSE 90009
// exit ;
90007: GO 90101
// if GetTaskList ( unit ) then
90009: LD_VAR 0 1
90013: PPUSH
90014: CALL_OW 437
90018: IFFALSE 90101
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
90020: LD_STRING e
90022: PUSH
90023: LD_VAR 0 1
90027: PPUSH
90028: CALL_OW 437
90032: PUSH
90033: LD_INT 1
90035: ARRAY
90036: PUSH
90037: LD_INT 1
90039: ARRAY
90040: EQUAL
90041: PUSH
90042: LD_VAR 0 4
90046: PUSH
90047: LD_VAR 0 1
90051: PPUSH
90052: CALL_OW 437
90056: PUSH
90057: LD_INT 1
90059: ARRAY
90060: PUSH
90061: LD_INT 2
90063: ARRAY
90064: EQUAL
90065: AND
90066: PUSH
90067: LD_VAR 0 5
90071: PUSH
90072: LD_VAR 0 1
90076: PPUSH
90077: CALL_OW 437
90081: PUSH
90082: LD_INT 1
90084: ARRAY
90085: PUSH
90086: LD_INT 3
90088: ARRAY
90089: EQUAL
90090: AND
90091: IFFALSE 90101
// result := true end ;
90093: LD_ADDR_VAR 0 3
90097: PUSH
90098: LD_INT 1
90100: ST_TO_ADDR
// end ;
90101: LD_VAR 0 3
90105: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
90106: LD_INT 0
90108: PPUSH
// result := false ;
90109: LD_ADDR_VAR 0 4
90113: PUSH
90114: LD_INT 0
90116: ST_TO_ADDR
// if GetTaskList ( unit ) then
90117: LD_VAR 0 1
90121: PPUSH
90122: CALL_OW 437
90126: IFFALSE 90209
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
90128: LD_STRING M
90130: PUSH
90131: LD_VAR 0 1
90135: PPUSH
90136: CALL_OW 437
90140: PUSH
90141: LD_INT 1
90143: ARRAY
90144: PUSH
90145: LD_INT 1
90147: ARRAY
90148: EQUAL
90149: PUSH
90150: LD_VAR 0 2
90154: PUSH
90155: LD_VAR 0 1
90159: PPUSH
90160: CALL_OW 437
90164: PUSH
90165: LD_INT 1
90167: ARRAY
90168: PUSH
90169: LD_INT 2
90171: ARRAY
90172: EQUAL
90173: AND
90174: PUSH
90175: LD_VAR 0 3
90179: PUSH
90180: LD_VAR 0 1
90184: PPUSH
90185: CALL_OW 437
90189: PUSH
90190: LD_INT 1
90192: ARRAY
90193: PUSH
90194: LD_INT 3
90196: ARRAY
90197: EQUAL
90198: AND
90199: IFFALSE 90209
// result := true ;
90201: LD_ADDR_VAR 0 4
90205: PUSH
90206: LD_INT 1
90208: ST_TO_ADDR
// end ; end ;
90209: LD_VAR 0 4
90213: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
90214: LD_INT 0
90216: PPUSH
90217: PPUSH
90218: PPUSH
90219: PPUSH
// if not unit or not area then
90220: LD_VAR 0 1
90224: NOT
90225: PUSH
90226: LD_VAR 0 2
90230: NOT
90231: OR
90232: IFFALSE 90236
// exit ;
90234: GO 90412
// tmp := AreaToList ( area , i ) ;
90236: LD_ADDR_VAR 0 6
90240: PUSH
90241: LD_VAR 0 2
90245: PPUSH
90246: LD_VAR 0 5
90250: PPUSH
90251: CALL_OW 517
90255: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
90256: LD_ADDR_VAR 0 5
90260: PUSH
90261: DOUBLE
90262: LD_INT 1
90264: DEC
90265: ST_TO_ADDR
90266: LD_VAR 0 6
90270: PUSH
90271: LD_INT 1
90273: ARRAY
90274: PUSH
90275: FOR_TO
90276: IFFALSE 90410
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
90278: LD_ADDR_VAR 0 7
90282: PUSH
90283: LD_VAR 0 6
90287: PUSH
90288: LD_INT 1
90290: ARRAY
90291: PUSH
90292: LD_VAR 0 5
90296: ARRAY
90297: PUSH
90298: LD_VAR 0 6
90302: PUSH
90303: LD_INT 2
90305: ARRAY
90306: PUSH
90307: LD_VAR 0 5
90311: ARRAY
90312: PUSH
90313: EMPTY
90314: LIST
90315: LIST
90316: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
90317: LD_INT 92
90319: PUSH
90320: LD_VAR 0 7
90324: PUSH
90325: LD_INT 1
90327: ARRAY
90328: PUSH
90329: LD_VAR 0 7
90333: PUSH
90334: LD_INT 2
90336: ARRAY
90337: PUSH
90338: LD_INT 2
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: PPUSH
90347: CALL_OW 69
90351: PUSH
90352: LD_INT 0
90354: EQUAL
90355: IFFALSE 90408
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
90357: LD_VAR 0 1
90361: PPUSH
90362: LD_VAR 0 7
90366: PUSH
90367: LD_INT 1
90369: ARRAY
90370: PPUSH
90371: LD_VAR 0 7
90375: PUSH
90376: LD_INT 2
90378: ARRAY
90379: PPUSH
90380: LD_VAR 0 3
90384: PPUSH
90385: CALL_OW 48
// result := IsPlaced ( unit ) ;
90389: LD_ADDR_VAR 0 4
90393: PUSH
90394: LD_VAR 0 1
90398: PPUSH
90399: CALL_OW 305
90403: ST_TO_ADDR
// exit ;
90404: POP
90405: POP
90406: GO 90412
// end ; end ;
90408: GO 90275
90410: POP
90411: POP
// end ;
90412: LD_VAR 0 4
90416: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
90417: LD_INT 0
90419: PPUSH
90420: PPUSH
90421: PPUSH
// if not side or side > 8 then
90422: LD_VAR 0 1
90426: NOT
90427: PUSH
90428: LD_VAR 0 1
90432: PUSH
90433: LD_INT 8
90435: GREATER
90436: OR
90437: IFFALSE 90441
// exit ;
90439: GO 90628
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
90441: LD_ADDR_VAR 0 4
90445: PUSH
90446: LD_INT 22
90448: PUSH
90449: LD_VAR 0 1
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: PUSH
90458: LD_INT 21
90460: PUSH
90461: LD_INT 3
90463: PUSH
90464: EMPTY
90465: LIST
90466: LIST
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PPUSH
90472: CALL_OW 69
90476: ST_TO_ADDR
// if not tmp then
90477: LD_VAR 0 4
90481: NOT
90482: IFFALSE 90486
// exit ;
90484: GO 90628
// enable_addtolog := true ;
90486: LD_ADDR_OWVAR 81
90490: PUSH
90491: LD_INT 1
90493: ST_TO_ADDR
// AddToLog ( [ ) ;
90494: LD_STRING [
90496: PPUSH
90497: CALL_OW 561
// for i in tmp do
90501: LD_ADDR_VAR 0 3
90505: PUSH
90506: LD_VAR 0 4
90510: PUSH
90511: FOR_IN
90512: IFFALSE 90619
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
90514: LD_STRING [
90516: PUSH
90517: LD_VAR 0 3
90521: PPUSH
90522: CALL_OW 266
90526: STR
90527: PUSH
90528: LD_STRING , 
90530: STR
90531: PUSH
90532: LD_VAR 0 3
90536: PPUSH
90537: CALL_OW 250
90541: STR
90542: PUSH
90543: LD_STRING , 
90545: STR
90546: PUSH
90547: LD_VAR 0 3
90551: PPUSH
90552: CALL_OW 251
90556: STR
90557: PUSH
90558: LD_STRING , 
90560: STR
90561: PUSH
90562: LD_VAR 0 3
90566: PPUSH
90567: CALL_OW 254
90571: STR
90572: PUSH
90573: LD_STRING , 
90575: STR
90576: PUSH
90577: LD_VAR 0 3
90581: PPUSH
90582: LD_INT 1
90584: PPUSH
90585: CALL_OW 268
90589: STR
90590: PUSH
90591: LD_STRING , 
90593: STR
90594: PUSH
90595: LD_VAR 0 3
90599: PPUSH
90600: LD_INT 2
90602: PPUSH
90603: CALL_OW 268
90607: STR
90608: PUSH
90609: LD_STRING ],
90611: STR
90612: PPUSH
90613: CALL_OW 561
// end ;
90617: GO 90511
90619: POP
90620: POP
// AddToLog ( ]; ) ;
90621: LD_STRING ];
90623: PPUSH
90624: CALL_OW 561
// end ;
90628: LD_VAR 0 2
90632: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
90633: LD_INT 0
90635: PPUSH
90636: PPUSH
90637: PPUSH
90638: PPUSH
90639: PPUSH
// if not area or not rate or not max then
90640: LD_VAR 0 1
90644: NOT
90645: PUSH
90646: LD_VAR 0 2
90650: NOT
90651: OR
90652: PUSH
90653: LD_VAR 0 4
90657: NOT
90658: OR
90659: IFFALSE 90663
// exit ;
90661: GO 90852
// while 1 do
90663: LD_INT 1
90665: IFFALSE 90852
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
90667: LD_ADDR_VAR 0 9
90671: PUSH
90672: LD_VAR 0 1
90676: PPUSH
90677: LD_INT 1
90679: PPUSH
90680: CALL_OW 287
90684: PUSH
90685: LD_INT 10
90687: MUL
90688: ST_TO_ADDR
// r := rate / 10 ;
90689: LD_ADDR_VAR 0 7
90693: PUSH
90694: LD_VAR 0 2
90698: PUSH
90699: LD_INT 10
90701: DIVREAL
90702: ST_TO_ADDR
// time := 1 1$00 ;
90703: LD_ADDR_VAR 0 8
90707: PUSH
90708: LD_INT 2100
90710: ST_TO_ADDR
// if amount < min then
90711: LD_VAR 0 9
90715: PUSH
90716: LD_VAR 0 3
90720: LESS
90721: IFFALSE 90739
// r := r * 2 else
90723: LD_ADDR_VAR 0 7
90727: PUSH
90728: LD_VAR 0 7
90732: PUSH
90733: LD_INT 2
90735: MUL
90736: ST_TO_ADDR
90737: GO 90765
// if amount > max then
90739: LD_VAR 0 9
90743: PUSH
90744: LD_VAR 0 4
90748: GREATER
90749: IFFALSE 90765
// r := r / 2 ;
90751: LD_ADDR_VAR 0 7
90755: PUSH
90756: LD_VAR 0 7
90760: PUSH
90761: LD_INT 2
90763: DIVREAL
90764: ST_TO_ADDR
// time := time / r ;
90765: LD_ADDR_VAR 0 8
90769: PUSH
90770: LD_VAR 0 8
90774: PUSH
90775: LD_VAR 0 7
90779: DIVREAL
90780: ST_TO_ADDR
// if time < 0 then
90781: LD_VAR 0 8
90785: PUSH
90786: LD_INT 0
90788: LESS
90789: IFFALSE 90806
// time := time * - 1 ;
90791: LD_ADDR_VAR 0 8
90795: PUSH
90796: LD_VAR 0 8
90800: PUSH
90801: LD_INT 1
90803: NEG
90804: MUL
90805: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
90806: LD_VAR 0 8
90810: PUSH
90811: LD_INT 35
90813: PPUSH
90814: LD_INT 875
90816: PPUSH
90817: CALL_OW 12
90821: PLUS
90822: PPUSH
90823: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
90827: LD_INT 1
90829: PPUSH
90830: LD_INT 5
90832: PPUSH
90833: CALL_OW 12
90837: PPUSH
90838: LD_VAR 0 1
90842: PPUSH
90843: LD_INT 1
90845: PPUSH
90846: CALL_OW 55
// end ;
90850: GO 90663
// end ;
90852: LD_VAR 0 5
90856: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
90857: LD_INT 0
90859: PPUSH
90860: PPUSH
90861: PPUSH
90862: PPUSH
90863: PPUSH
90864: PPUSH
90865: PPUSH
90866: PPUSH
// if not turrets or not factories then
90867: LD_VAR 0 1
90871: NOT
90872: PUSH
90873: LD_VAR 0 2
90877: NOT
90878: OR
90879: IFFALSE 90883
// exit ;
90881: GO 91190
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
90883: LD_ADDR_VAR 0 10
90887: PUSH
90888: LD_INT 5
90890: PUSH
90891: LD_INT 6
90893: PUSH
90894: EMPTY
90895: LIST
90896: LIST
90897: PUSH
90898: LD_INT 2
90900: PUSH
90901: LD_INT 4
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: PUSH
90908: LD_INT 3
90910: PUSH
90911: LD_INT 5
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: EMPTY
90919: LIST
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 24
90925: PUSH
90926: LD_INT 25
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 23
90935: PUSH
90936: LD_INT 27
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 42
90949: PUSH
90950: LD_INT 43
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 44
90959: PUSH
90960: LD_INT 46
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 45
90969: PUSH
90970: LD_INT 47
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: LIST
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: LIST
90986: ST_TO_ADDR
// result := [ ] ;
90987: LD_ADDR_VAR 0 3
90991: PUSH
90992: EMPTY
90993: ST_TO_ADDR
// for i in turrets do
90994: LD_ADDR_VAR 0 4
90998: PUSH
90999: LD_VAR 0 1
91003: PUSH
91004: FOR_IN
91005: IFFALSE 91188
// begin nat := GetNation ( i ) ;
91007: LD_ADDR_VAR 0 7
91011: PUSH
91012: LD_VAR 0 4
91016: PPUSH
91017: CALL_OW 248
91021: ST_TO_ADDR
// weapon := 0 ;
91022: LD_ADDR_VAR 0 8
91026: PUSH
91027: LD_INT 0
91029: ST_TO_ADDR
// if not nat then
91030: LD_VAR 0 7
91034: NOT
91035: IFFALSE 91039
// continue ;
91037: GO 91004
// for j in list [ nat ] do
91039: LD_ADDR_VAR 0 5
91043: PUSH
91044: LD_VAR 0 10
91048: PUSH
91049: LD_VAR 0 7
91053: ARRAY
91054: PUSH
91055: FOR_IN
91056: IFFALSE 91097
// if GetBWeapon ( i ) = j [ 1 ] then
91058: LD_VAR 0 4
91062: PPUSH
91063: CALL_OW 269
91067: PUSH
91068: LD_VAR 0 5
91072: PUSH
91073: LD_INT 1
91075: ARRAY
91076: EQUAL
91077: IFFALSE 91095
// begin weapon := j [ 2 ] ;
91079: LD_ADDR_VAR 0 8
91083: PUSH
91084: LD_VAR 0 5
91088: PUSH
91089: LD_INT 2
91091: ARRAY
91092: ST_TO_ADDR
// break ;
91093: GO 91097
// end ;
91095: GO 91055
91097: POP
91098: POP
// if not weapon then
91099: LD_VAR 0 8
91103: NOT
91104: IFFALSE 91108
// continue ;
91106: GO 91004
// for k in factories do
91108: LD_ADDR_VAR 0 6
91112: PUSH
91113: LD_VAR 0 2
91117: PUSH
91118: FOR_IN
91119: IFFALSE 91184
// begin weapons := AvailableWeaponList ( k ) ;
91121: LD_ADDR_VAR 0 9
91125: PUSH
91126: LD_VAR 0 6
91130: PPUSH
91131: CALL_OW 478
91135: ST_TO_ADDR
// if not weapons then
91136: LD_VAR 0 9
91140: NOT
91141: IFFALSE 91145
// continue ;
91143: GO 91118
// if weapon in weapons then
91145: LD_VAR 0 8
91149: PUSH
91150: LD_VAR 0 9
91154: IN
91155: IFFALSE 91182
// begin result := [ i , weapon ] ;
91157: LD_ADDR_VAR 0 3
91161: PUSH
91162: LD_VAR 0 4
91166: PUSH
91167: LD_VAR 0 8
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: ST_TO_ADDR
// exit ;
91176: POP
91177: POP
91178: POP
91179: POP
91180: GO 91190
// end ; end ;
91182: GO 91118
91184: POP
91185: POP
// end ;
91186: GO 91004
91188: POP
91189: POP
// end ;
91190: LD_VAR 0 3
91194: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
91195: LD_INT 0
91197: PPUSH
// if not side or side > 8 then
91198: LD_VAR 0 3
91202: NOT
91203: PUSH
91204: LD_VAR 0 3
91208: PUSH
91209: LD_INT 8
91211: GREATER
91212: OR
91213: IFFALSE 91217
// exit ;
91215: GO 91276
// if not range then
91217: LD_VAR 0 4
91221: NOT
91222: IFFALSE 91233
// range := - 12 ;
91224: LD_ADDR_VAR 0 4
91228: PUSH
91229: LD_INT 12
91231: NEG
91232: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
91233: LD_VAR 0 1
91237: PPUSH
91238: LD_VAR 0 2
91242: PPUSH
91243: LD_VAR 0 3
91247: PPUSH
91248: LD_VAR 0 4
91252: PPUSH
91253: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
91257: LD_VAR 0 1
91261: PPUSH
91262: LD_VAR 0 2
91266: PPUSH
91267: LD_VAR 0 3
91271: PPUSH
91272: CALL_OW 331
// end ;
91276: LD_VAR 0 5
91280: RET
// export function Video ( mode ) ; begin
91281: LD_INT 0
91283: PPUSH
// ingame_video = mode ;
91284: LD_ADDR_OWVAR 52
91288: PUSH
91289: LD_VAR 0 1
91293: ST_TO_ADDR
// interface_hidden = mode ;
91294: LD_ADDR_OWVAR 54
91298: PUSH
91299: LD_VAR 0 1
91303: ST_TO_ADDR
// end ;
91304: LD_VAR 0 2
91308: RET
// export function Join ( array , element ) ; begin
91309: LD_INT 0
91311: PPUSH
// result := Replace ( array , array + 1 , element ) ;
91312: LD_ADDR_VAR 0 3
91316: PUSH
91317: LD_VAR 0 1
91321: PPUSH
91322: LD_VAR 0 1
91326: PUSH
91327: LD_INT 1
91329: PLUS
91330: PPUSH
91331: LD_VAR 0 2
91335: PPUSH
91336: CALL_OW 1
91340: ST_TO_ADDR
// end ;
91341: LD_VAR 0 3
91345: RET
// export function JoinUnion ( array , element ) ; begin
91346: LD_INT 0
91348: PPUSH
// result := array union element ;
91349: LD_ADDR_VAR 0 3
91353: PUSH
91354: LD_VAR 0 1
91358: PUSH
91359: LD_VAR 0 2
91363: UNION
91364: ST_TO_ADDR
// end ;
91365: LD_VAR 0 3
91369: RET
// export function GetBehemoths ( side ) ; begin
91370: LD_INT 0
91372: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
91373: LD_ADDR_VAR 0 2
91377: PUSH
91378: LD_INT 22
91380: PUSH
91381: LD_VAR 0 1
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: PUSH
91390: LD_INT 31
91392: PUSH
91393: LD_INT 25
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PPUSH
91404: CALL_OW 69
91408: ST_TO_ADDR
// end ;
91409: LD_VAR 0 2
91413: RET
// export function Shuffle ( array ) ; var i , index ; begin
91414: LD_INT 0
91416: PPUSH
91417: PPUSH
91418: PPUSH
// result := [ ] ;
91419: LD_ADDR_VAR 0 2
91423: PUSH
91424: EMPTY
91425: ST_TO_ADDR
// if not array then
91426: LD_VAR 0 1
91430: NOT
91431: IFFALSE 91435
// exit ;
91433: GO 91534
// Randomize ;
91435: CALL_OW 10
// for i = array downto 1 do
91439: LD_ADDR_VAR 0 3
91443: PUSH
91444: DOUBLE
91445: LD_VAR 0 1
91449: INC
91450: ST_TO_ADDR
91451: LD_INT 1
91453: PUSH
91454: FOR_DOWNTO
91455: IFFALSE 91532
// begin index := rand ( 1 , array ) ;
91457: LD_ADDR_VAR 0 4
91461: PUSH
91462: LD_INT 1
91464: PPUSH
91465: LD_VAR 0 1
91469: PPUSH
91470: CALL_OW 12
91474: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
91475: LD_ADDR_VAR 0 2
91479: PUSH
91480: LD_VAR 0 2
91484: PPUSH
91485: LD_VAR 0 2
91489: PUSH
91490: LD_INT 1
91492: PLUS
91493: PPUSH
91494: LD_VAR 0 1
91498: PUSH
91499: LD_VAR 0 4
91503: ARRAY
91504: PPUSH
91505: CALL_OW 2
91509: ST_TO_ADDR
// array := Delete ( array , index ) ;
91510: LD_ADDR_VAR 0 1
91514: PUSH
91515: LD_VAR 0 1
91519: PPUSH
91520: LD_VAR 0 4
91524: PPUSH
91525: CALL_OW 3
91529: ST_TO_ADDR
// end ;
91530: GO 91454
91532: POP
91533: POP
// end ;
91534: LD_VAR 0 2
91538: RET
// export function GetBaseMaterials ( base ) ; begin
91539: LD_INT 0
91541: PPUSH
// result := [ 0 , 0 , 0 ] ;
91542: LD_ADDR_VAR 0 2
91546: PUSH
91547: LD_INT 0
91549: PUSH
91550: LD_INT 0
91552: PUSH
91553: LD_INT 0
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: LIST
91560: ST_TO_ADDR
// if not base then
91561: LD_VAR 0 1
91565: NOT
91566: IFFALSE 91570
// exit ;
91568: GO 91619
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
91570: LD_ADDR_VAR 0 2
91574: PUSH
91575: LD_VAR 0 1
91579: PPUSH
91580: LD_INT 1
91582: PPUSH
91583: CALL_OW 275
91587: PUSH
91588: LD_VAR 0 1
91592: PPUSH
91593: LD_INT 2
91595: PPUSH
91596: CALL_OW 275
91600: PUSH
91601: LD_VAR 0 1
91605: PPUSH
91606: LD_INT 3
91608: PPUSH
91609: CALL_OW 275
91613: PUSH
91614: EMPTY
91615: LIST
91616: LIST
91617: LIST
91618: ST_TO_ADDR
// end ;
91619: LD_VAR 0 2
91623: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
91624: LD_INT 0
91626: PPUSH
91627: PPUSH
// result := array ;
91628: LD_ADDR_VAR 0 3
91632: PUSH
91633: LD_VAR 0 1
91637: ST_TO_ADDR
// if size >= result then
91638: LD_VAR 0 2
91642: PUSH
91643: LD_VAR 0 3
91647: GREATEREQUAL
91648: IFFALSE 91652
// exit ;
91650: GO 91702
// if size then
91652: LD_VAR 0 2
91656: IFFALSE 91702
// for i := array downto size do
91658: LD_ADDR_VAR 0 4
91662: PUSH
91663: DOUBLE
91664: LD_VAR 0 1
91668: INC
91669: ST_TO_ADDR
91670: LD_VAR 0 2
91674: PUSH
91675: FOR_DOWNTO
91676: IFFALSE 91700
// result := Delete ( result , result ) ;
91678: LD_ADDR_VAR 0 3
91682: PUSH
91683: LD_VAR 0 3
91687: PPUSH
91688: LD_VAR 0 3
91692: PPUSH
91693: CALL_OW 3
91697: ST_TO_ADDR
91698: GO 91675
91700: POP
91701: POP
// end ;
91702: LD_VAR 0 3
91706: RET
// export function ComExit ( unit ) ; var tmp ; begin
91707: LD_INT 0
91709: PPUSH
91710: PPUSH
// if not IsInUnit ( unit ) then
91711: LD_VAR 0 1
91715: PPUSH
91716: CALL_OW 310
91720: NOT
91721: IFFALSE 91725
// exit ;
91723: GO 91785
// tmp := IsInUnit ( unit ) ;
91725: LD_ADDR_VAR 0 3
91729: PUSH
91730: LD_VAR 0 1
91734: PPUSH
91735: CALL_OW 310
91739: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
91740: LD_VAR 0 3
91744: PPUSH
91745: CALL_OW 247
91749: PUSH
91750: LD_INT 2
91752: EQUAL
91753: IFFALSE 91766
// ComExitVehicle ( unit ) else
91755: LD_VAR 0 1
91759: PPUSH
91760: CALL_OW 121
91764: GO 91775
// ComExitBuilding ( unit ) ;
91766: LD_VAR 0 1
91770: PPUSH
91771: CALL_OW 122
// result := tmp ;
91775: LD_ADDR_VAR 0 2
91779: PUSH
91780: LD_VAR 0 3
91784: ST_TO_ADDR
// end ;
91785: LD_VAR 0 2
91789: RET
// export function ComExitAll ( units ) ; var i ; begin
91790: LD_INT 0
91792: PPUSH
91793: PPUSH
// if not units then
91794: LD_VAR 0 1
91798: NOT
91799: IFFALSE 91803
// exit ;
91801: GO 91829
// for i in units do
91803: LD_ADDR_VAR 0 3
91807: PUSH
91808: LD_VAR 0 1
91812: PUSH
91813: FOR_IN
91814: IFFALSE 91827
// ComExit ( i ) ;
91816: LD_VAR 0 3
91820: PPUSH
91821: CALL 91707 0 1
91825: GO 91813
91827: POP
91828: POP
// end ;
91829: LD_VAR 0 2
91833: RET
// export function ResetHc ; begin
91834: LD_INT 0
91836: PPUSH
// InitHc ;
91837: CALL_OW 19
// hc_importance := 0 ;
91841: LD_ADDR_OWVAR 32
91845: PUSH
91846: LD_INT 0
91848: ST_TO_ADDR
// end ;
91849: LD_VAR 0 1
91853: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
91854: LD_INT 0
91856: PPUSH
91857: PPUSH
91858: PPUSH
// _x := ( x1 + x2 ) div 2 ;
91859: LD_ADDR_VAR 0 6
91863: PUSH
91864: LD_VAR 0 1
91868: PUSH
91869: LD_VAR 0 3
91873: PLUS
91874: PUSH
91875: LD_INT 2
91877: DIV
91878: ST_TO_ADDR
// if _x < 0 then
91879: LD_VAR 0 6
91883: PUSH
91884: LD_INT 0
91886: LESS
91887: IFFALSE 91904
// _x := _x * - 1 ;
91889: LD_ADDR_VAR 0 6
91893: PUSH
91894: LD_VAR 0 6
91898: PUSH
91899: LD_INT 1
91901: NEG
91902: MUL
91903: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
91904: LD_ADDR_VAR 0 7
91908: PUSH
91909: LD_VAR 0 2
91913: PUSH
91914: LD_VAR 0 4
91918: PLUS
91919: PUSH
91920: LD_INT 2
91922: DIV
91923: ST_TO_ADDR
// if _y < 0 then
91924: LD_VAR 0 7
91928: PUSH
91929: LD_INT 0
91931: LESS
91932: IFFALSE 91949
// _y := _y * - 1 ;
91934: LD_ADDR_VAR 0 7
91938: PUSH
91939: LD_VAR 0 7
91943: PUSH
91944: LD_INT 1
91946: NEG
91947: MUL
91948: ST_TO_ADDR
// result := [ _x , _y ] ;
91949: LD_ADDR_VAR 0 5
91953: PUSH
91954: LD_VAR 0 6
91958: PUSH
91959: LD_VAR 0 7
91963: PUSH
91964: EMPTY
91965: LIST
91966: LIST
91967: ST_TO_ADDR
// end ;
91968: LD_VAR 0 5
91972: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
91973: LD_INT 0
91975: PPUSH
91976: PPUSH
91977: PPUSH
91978: PPUSH
// task := GetTaskList ( unit ) ;
91979: LD_ADDR_VAR 0 7
91983: PUSH
91984: LD_VAR 0 1
91988: PPUSH
91989: CALL_OW 437
91993: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
91994: LD_VAR 0 7
91998: NOT
91999: PUSH
92000: LD_VAR 0 1
92004: PPUSH
92005: LD_VAR 0 2
92009: PPUSH
92010: CALL_OW 308
92014: NOT
92015: AND
92016: IFFALSE 92020
// exit ;
92018: GO 92138
// if IsInArea ( unit , area ) then
92020: LD_VAR 0 1
92024: PPUSH
92025: LD_VAR 0 2
92029: PPUSH
92030: CALL_OW 308
92034: IFFALSE 92052
// begin ComMoveToArea ( unit , goAway ) ;
92036: LD_VAR 0 1
92040: PPUSH
92041: LD_VAR 0 3
92045: PPUSH
92046: CALL_OW 113
// exit ;
92050: GO 92138
// end ; if task [ 1 ] [ 1 ] <> M then
92052: LD_VAR 0 7
92056: PUSH
92057: LD_INT 1
92059: ARRAY
92060: PUSH
92061: LD_INT 1
92063: ARRAY
92064: PUSH
92065: LD_STRING M
92067: NONEQUAL
92068: IFFALSE 92072
// exit ;
92070: GO 92138
// x := task [ 1 ] [ 2 ] ;
92072: LD_ADDR_VAR 0 5
92076: PUSH
92077: LD_VAR 0 7
92081: PUSH
92082: LD_INT 1
92084: ARRAY
92085: PUSH
92086: LD_INT 2
92088: ARRAY
92089: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
92090: LD_ADDR_VAR 0 6
92094: PUSH
92095: LD_VAR 0 7
92099: PUSH
92100: LD_INT 1
92102: ARRAY
92103: PUSH
92104: LD_INT 3
92106: ARRAY
92107: ST_TO_ADDR
// if InArea ( x , y , area ) then
92108: LD_VAR 0 5
92112: PPUSH
92113: LD_VAR 0 6
92117: PPUSH
92118: LD_VAR 0 2
92122: PPUSH
92123: CALL_OW 309
92127: IFFALSE 92138
// ComStop ( unit ) ;
92129: LD_VAR 0 1
92133: PPUSH
92134: CALL_OW 141
// end ;
92138: LD_VAR 0 4
92142: RET
// export function Abs ( value ) ; begin
92143: LD_INT 0
92145: PPUSH
// result := value ;
92146: LD_ADDR_VAR 0 2
92150: PUSH
92151: LD_VAR 0 1
92155: ST_TO_ADDR
// if value < 0 then
92156: LD_VAR 0 1
92160: PUSH
92161: LD_INT 0
92163: LESS
92164: IFFALSE 92181
// result := value * - 1 ;
92166: LD_ADDR_VAR 0 2
92170: PUSH
92171: LD_VAR 0 1
92175: PUSH
92176: LD_INT 1
92178: NEG
92179: MUL
92180: ST_TO_ADDR
// end ;
92181: LD_VAR 0 2
92185: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
92186: LD_INT 0
92188: PPUSH
92189: PPUSH
92190: PPUSH
92191: PPUSH
92192: PPUSH
92193: PPUSH
92194: PPUSH
92195: PPUSH
// if not unit or not building then
92196: LD_VAR 0 1
92200: NOT
92201: PUSH
92202: LD_VAR 0 2
92206: NOT
92207: OR
92208: IFFALSE 92212
// exit ;
92210: GO 92438
// x := GetX ( building ) ;
92212: LD_ADDR_VAR 0 4
92216: PUSH
92217: LD_VAR 0 2
92221: PPUSH
92222: CALL_OW 250
92226: ST_TO_ADDR
// y := GetY ( building ) ;
92227: LD_ADDR_VAR 0 6
92231: PUSH
92232: LD_VAR 0 2
92236: PPUSH
92237: CALL_OW 251
92241: ST_TO_ADDR
// d := GetDir ( building ) ;
92242: LD_ADDR_VAR 0 8
92246: PUSH
92247: LD_VAR 0 2
92251: PPUSH
92252: CALL_OW 254
92256: ST_TO_ADDR
// r := 4 ;
92257: LD_ADDR_VAR 0 9
92261: PUSH
92262: LD_INT 4
92264: ST_TO_ADDR
// for i := 1 to 5 do
92265: LD_ADDR_VAR 0 10
92269: PUSH
92270: DOUBLE
92271: LD_INT 1
92273: DEC
92274: ST_TO_ADDR
92275: LD_INT 5
92277: PUSH
92278: FOR_TO
92279: IFFALSE 92436
// begin _x := ShiftX ( x , d , r + i ) ;
92281: LD_ADDR_VAR 0 5
92285: PUSH
92286: LD_VAR 0 4
92290: PPUSH
92291: LD_VAR 0 8
92295: PPUSH
92296: LD_VAR 0 9
92300: PUSH
92301: LD_VAR 0 10
92305: PLUS
92306: PPUSH
92307: CALL_OW 272
92311: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
92312: LD_ADDR_VAR 0 7
92316: PUSH
92317: LD_VAR 0 6
92321: PPUSH
92322: LD_VAR 0 8
92326: PPUSH
92327: LD_VAR 0 9
92331: PUSH
92332: LD_VAR 0 10
92336: PLUS
92337: PPUSH
92338: CALL_OW 273
92342: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
92343: LD_VAR 0 5
92347: PPUSH
92348: LD_VAR 0 7
92352: PPUSH
92353: CALL_OW 488
92357: PUSH
92358: LD_VAR 0 5
92362: PPUSH
92363: LD_VAR 0 7
92367: PPUSH
92368: CALL_OW 428
92372: PPUSH
92373: CALL_OW 247
92377: PUSH
92378: LD_INT 3
92380: PUSH
92381: LD_INT 2
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: IN
92388: NOT
92389: AND
92390: IFFALSE 92434
// begin ComMoveXY ( unit , _x , _y ) ;
92392: LD_VAR 0 1
92396: PPUSH
92397: LD_VAR 0 5
92401: PPUSH
92402: LD_VAR 0 7
92406: PPUSH
92407: CALL_OW 111
// result := [ _x , _y ] ;
92411: LD_ADDR_VAR 0 3
92415: PUSH
92416: LD_VAR 0 5
92420: PUSH
92421: LD_VAR 0 7
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: ST_TO_ADDR
// exit ;
92430: POP
92431: POP
92432: GO 92438
// end ; end ;
92434: GO 92278
92436: POP
92437: POP
// end ;
92438: LD_VAR 0 3
92442: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
92443: LD_INT 0
92445: PPUSH
92446: PPUSH
92447: PPUSH
// result := 0 ;
92448: LD_ADDR_VAR 0 3
92452: PUSH
92453: LD_INT 0
92455: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
92456: LD_VAR 0 1
92460: PUSH
92461: LD_INT 0
92463: LESS
92464: PUSH
92465: LD_VAR 0 1
92469: PUSH
92470: LD_INT 8
92472: GREATER
92473: OR
92474: PUSH
92475: LD_VAR 0 2
92479: PUSH
92480: LD_INT 0
92482: LESS
92483: OR
92484: PUSH
92485: LD_VAR 0 2
92489: PUSH
92490: LD_INT 8
92492: GREATER
92493: OR
92494: IFFALSE 92498
// exit ;
92496: GO 92573
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
92498: LD_ADDR_VAR 0 4
92502: PUSH
92503: LD_INT 22
92505: PUSH
92506: LD_VAR 0 2
92510: PUSH
92511: EMPTY
92512: LIST
92513: LIST
92514: PPUSH
92515: CALL_OW 69
92519: PUSH
92520: FOR_IN
92521: IFFALSE 92571
// begin un := UnitShoot ( i ) ;
92523: LD_ADDR_VAR 0 5
92527: PUSH
92528: LD_VAR 0 4
92532: PPUSH
92533: CALL_OW 504
92537: ST_TO_ADDR
// if GetSide ( un ) = side1 then
92538: LD_VAR 0 5
92542: PPUSH
92543: CALL_OW 255
92547: PUSH
92548: LD_VAR 0 1
92552: EQUAL
92553: IFFALSE 92569
// begin result := un ;
92555: LD_ADDR_VAR 0 3
92559: PUSH
92560: LD_VAR 0 5
92564: ST_TO_ADDR
// exit ;
92565: POP
92566: POP
92567: GO 92573
// end ; end ;
92569: GO 92520
92571: POP
92572: POP
// end ;
92573: LD_VAR 0 3
92577: RET
// export function GetCargoBay ( units ) ; begin
92578: LD_INT 0
92580: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
92581: LD_ADDR_VAR 0 2
92585: PUSH
92586: LD_VAR 0 1
92590: PPUSH
92591: LD_INT 2
92593: PUSH
92594: LD_INT 34
92596: PUSH
92597: LD_INT 12
92599: PUSH
92600: EMPTY
92601: LIST
92602: LIST
92603: PUSH
92604: LD_INT 34
92606: PUSH
92607: LD_INT 51
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 34
92616: PUSH
92617: LD_INT 32
92619: PUSH
92620: EMPTY
92621: LIST
92622: LIST
92623: PUSH
92624: LD_INT 34
92626: PUSH
92627: LD_INT 89
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: PPUSH
92641: CALL_OW 72
92645: ST_TO_ADDR
// end ;
92646: LD_VAR 0 2
92650: RET
// export function Negate ( value ) ; begin
92651: LD_INT 0
92653: PPUSH
// result := not value ;
92654: LD_ADDR_VAR 0 2
92658: PUSH
92659: LD_VAR 0 1
92663: NOT
92664: ST_TO_ADDR
// end ;
92665: LD_VAR 0 2
92669: RET
// export function Inc ( value ) ; begin
92670: LD_INT 0
92672: PPUSH
// result := value + 1 ;
92673: LD_ADDR_VAR 0 2
92677: PUSH
92678: LD_VAR 0 1
92682: PUSH
92683: LD_INT 1
92685: PLUS
92686: ST_TO_ADDR
// end ;
92687: LD_VAR 0 2
92691: RET
// export function Dec ( value ) ; begin
92692: LD_INT 0
92694: PPUSH
// result := value - 1 ;
92695: LD_ADDR_VAR 0 2
92699: PUSH
92700: LD_VAR 0 1
92704: PUSH
92705: LD_INT 1
92707: MINUS
92708: ST_TO_ADDR
// end ;
92709: LD_VAR 0 2
92713: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
92714: LD_INT 0
92716: PPUSH
92717: PPUSH
92718: PPUSH
92719: PPUSH
92720: PPUSH
92721: PPUSH
92722: PPUSH
92723: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
92724: LD_VAR 0 1
92728: PPUSH
92729: LD_VAR 0 2
92733: PPUSH
92734: CALL_OW 488
92738: NOT
92739: PUSH
92740: LD_VAR 0 3
92744: PPUSH
92745: LD_VAR 0 4
92749: PPUSH
92750: CALL_OW 488
92754: NOT
92755: OR
92756: IFFALSE 92769
// begin result := - 1 ;
92758: LD_ADDR_VAR 0 5
92762: PUSH
92763: LD_INT 1
92765: NEG
92766: ST_TO_ADDR
// exit ;
92767: GO 93004
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
92769: LD_ADDR_VAR 0 12
92773: PUSH
92774: LD_VAR 0 1
92778: PPUSH
92779: LD_VAR 0 2
92783: PPUSH
92784: LD_VAR 0 3
92788: PPUSH
92789: LD_VAR 0 4
92793: PPUSH
92794: CALL 91854 0 4
92798: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
92799: LD_ADDR_VAR 0 11
92803: PUSH
92804: LD_VAR 0 1
92808: PPUSH
92809: LD_VAR 0 2
92813: PPUSH
92814: LD_VAR 0 12
92818: PUSH
92819: LD_INT 1
92821: ARRAY
92822: PPUSH
92823: LD_VAR 0 12
92827: PUSH
92828: LD_INT 2
92830: ARRAY
92831: PPUSH
92832: CALL_OW 298
92836: ST_TO_ADDR
// distance := 9999 ;
92837: LD_ADDR_VAR 0 10
92841: PUSH
92842: LD_INT 9999
92844: ST_TO_ADDR
// for i := 0 to 5 do
92845: LD_ADDR_VAR 0 6
92849: PUSH
92850: DOUBLE
92851: LD_INT 0
92853: DEC
92854: ST_TO_ADDR
92855: LD_INT 5
92857: PUSH
92858: FOR_TO
92859: IFFALSE 93002
// begin _x := ShiftX ( x1 , i , centerDist ) ;
92861: LD_ADDR_VAR 0 7
92865: PUSH
92866: LD_VAR 0 1
92870: PPUSH
92871: LD_VAR 0 6
92875: PPUSH
92876: LD_VAR 0 11
92880: PPUSH
92881: CALL_OW 272
92885: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
92886: LD_ADDR_VAR 0 8
92890: PUSH
92891: LD_VAR 0 2
92895: PPUSH
92896: LD_VAR 0 6
92900: PPUSH
92901: LD_VAR 0 11
92905: PPUSH
92906: CALL_OW 273
92910: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92911: LD_VAR 0 7
92915: PPUSH
92916: LD_VAR 0 8
92920: PPUSH
92921: CALL_OW 488
92925: NOT
92926: IFFALSE 92930
// continue ;
92928: GO 92858
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
92930: LD_ADDR_VAR 0 9
92934: PUSH
92935: LD_VAR 0 12
92939: PUSH
92940: LD_INT 1
92942: ARRAY
92943: PPUSH
92944: LD_VAR 0 12
92948: PUSH
92949: LD_INT 2
92951: ARRAY
92952: PPUSH
92953: LD_VAR 0 7
92957: PPUSH
92958: LD_VAR 0 8
92962: PPUSH
92963: CALL_OW 298
92967: ST_TO_ADDR
// if tmp < distance then
92968: LD_VAR 0 9
92972: PUSH
92973: LD_VAR 0 10
92977: LESS
92978: IFFALSE 93000
// begin result := i ;
92980: LD_ADDR_VAR 0 5
92984: PUSH
92985: LD_VAR 0 6
92989: ST_TO_ADDR
// distance := tmp ;
92990: LD_ADDR_VAR 0 10
92994: PUSH
92995: LD_VAR 0 9
92999: ST_TO_ADDR
// end ; end ;
93000: GO 92858
93002: POP
93003: POP
// end ;
93004: LD_VAR 0 5
93008: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
93009: LD_INT 0
93011: PPUSH
93012: PPUSH
// if not driver or not IsInUnit ( driver ) then
93013: LD_VAR 0 1
93017: NOT
93018: PUSH
93019: LD_VAR 0 1
93023: PPUSH
93024: CALL_OW 310
93028: NOT
93029: OR
93030: IFFALSE 93034
// exit ;
93032: GO 93124
// vehicle := IsInUnit ( driver ) ;
93034: LD_ADDR_VAR 0 3
93038: PUSH
93039: LD_VAR 0 1
93043: PPUSH
93044: CALL_OW 310
93048: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
93049: LD_VAR 0 1
93053: PPUSH
93054: LD_STRING \
93056: PUSH
93057: LD_INT 0
93059: PUSH
93060: LD_INT 0
93062: PUSH
93063: LD_INT 0
93065: PUSH
93066: LD_INT 0
93068: PUSH
93069: LD_INT 0
93071: PUSH
93072: LD_INT 0
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: PUSH
93084: LD_STRING E
93086: PUSH
93087: LD_INT 0
93089: PUSH
93090: LD_INT 0
93092: PUSH
93093: LD_VAR 0 3
93097: PUSH
93098: LD_INT 0
93100: PUSH
93101: LD_INT 0
93103: PUSH
93104: LD_INT 0
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: PPUSH
93120: CALL_OW 446
// end ;
93124: LD_VAR 0 2
93128: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
93129: LD_INT 0
93131: PPUSH
93132: PPUSH
// if not driver or not IsInUnit ( driver ) then
93133: LD_VAR 0 1
93137: NOT
93138: PUSH
93139: LD_VAR 0 1
93143: PPUSH
93144: CALL_OW 310
93148: NOT
93149: OR
93150: IFFALSE 93154
// exit ;
93152: GO 93244
// vehicle := IsInUnit ( driver ) ;
93154: LD_ADDR_VAR 0 3
93158: PUSH
93159: LD_VAR 0 1
93163: PPUSH
93164: CALL_OW 310
93168: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
93169: LD_VAR 0 1
93173: PPUSH
93174: LD_STRING \
93176: PUSH
93177: LD_INT 0
93179: PUSH
93180: LD_INT 0
93182: PUSH
93183: LD_INT 0
93185: PUSH
93186: LD_INT 0
93188: PUSH
93189: LD_INT 0
93191: PUSH
93192: LD_INT 0
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: PUSH
93204: LD_STRING E
93206: PUSH
93207: LD_INT 0
93209: PUSH
93210: LD_INT 0
93212: PUSH
93213: LD_VAR 0 3
93217: PUSH
93218: LD_INT 0
93220: PUSH
93221: LD_INT 0
93223: PUSH
93224: LD_INT 0
93226: PUSH
93227: EMPTY
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PPUSH
93240: CALL_OW 447
// end ;
93244: LD_VAR 0 2
93248: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
93249: LD_INT 0
93251: PPUSH
93252: PPUSH
93253: PPUSH
// tmp := [ ] ;
93254: LD_ADDR_VAR 0 5
93258: PUSH
93259: EMPTY
93260: ST_TO_ADDR
// for i in units do
93261: LD_ADDR_VAR 0 4
93265: PUSH
93266: LD_VAR 0 1
93270: PUSH
93271: FOR_IN
93272: IFFALSE 93310
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
93274: LD_ADDR_VAR 0 5
93278: PUSH
93279: LD_VAR 0 5
93283: PPUSH
93284: LD_VAR 0 5
93288: PUSH
93289: LD_INT 1
93291: PLUS
93292: PPUSH
93293: LD_VAR 0 4
93297: PPUSH
93298: CALL_OW 256
93302: PPUSH
93303: CALL_OW 2
93307: ST_TO_ADDR
93308: GO 93271
93310: POP
93311: POP
// if not tmp then
93312: LD_VAR 0 5
93316: NOT
93317: IFFALSE 93321
// exit ;
93319: GO 93369
// if asc then
93321: LD_VAR 0 2
93325: IFFALSE 93349
// result := SortListByListAsc ( units , tmp ) else
93327: LD_ADDR_VAR 0 3
93331: PUSH
93332: LD_VAR 0 1
93336: PPUSH
93337: LD_VAR 0 5
93341: PPUSH
93342: CALL_OW 76
93346: ST_TO_ADDR
93347: GO 93369
// result := SortListByListDesc ( units , tmp ) ;
93349: LD_ADDR_VAR 0 3
93353: PUSH
93354: LD_VAR 0 1
93358: PPUSH
93359: LD_VAR 0 5
93363: PPUSH
93364: CALL_OW 77
93368: ST_TO_ADDR
// end ;
93369: LD_VAR 0 3
93373: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
93374: LD_INT 0
93376: PPUSH
93377: PPUSH
// task := GetTaskList ( mech ) ;
93378: LD_ADDR_VAR 0 4
93382: PUSH
93383: LD_VAR 0 1
93387: PPUSH
93388: CALL_OW 437
93392: ST_TO_ADDR
// if not task then
93393: LD_VAR 0 4
93397: NOT
93398: IFFALSE 93402
// exit ;
93400: GO 93444
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
93402: LD_ADDR_VAR 0 3
93406: PUSH
93407: LD_VAR 0 4
93411: PUSH
93412: LD_INT 1
93414: ARRAY
93415: PUSH
93416: LD_INT 1
93418: ARRAY
93419: PUSH
93420: LD_STRING r
93422: EQUAL
93423: PUSH
93424: LD_VAR 0 4
93428: PUSH
93429: LD_INT 1
93431: ARRAY
93432: PUSH
93433: LD_INT 4
93435: ARRAY
93436: PUSH
93437: LD_VAR 0 2
93441: EQUAL
93442: AND
93443: ST_TO_ADDR
// end ;
93444: LD_VAR 0 3
93448: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
93449: LD_INT 0
93451: PPUSH
// SetDir ( unit , d ) ;
93452: LD_VAR 0 1
93456: PPUSH
93457: LD_VAR 0 4
93461: PPUSH
93462: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
93466: LD_VAR 0 1
93470: PPUSH
93471: LD_VAR 0 2
93475: PPUSH
93476: LD_VAR 0 3
93480: PPUSH
93481: LD_VAR 0 5
93485: PPUSH
93486: CALL_OW 48
// end ;
93490: LD_VAR 0 6
93494: RET
// export function ToNaturalNumber ( number ) ; begin
93495: LD_INT 0
93497: PPUSH
// result := number div 1 ;
93498: LD_ADDR_VAR 0 2
93502: PUSH
93503: LD_VAR 0 1
93507: PUSH
93508: LD_INT 1
93510: DIV
93511: ST_TO_ADDR
// if number < 0 then
93512: LD_VAR 0 1
93516: PUSH
93517: LD_INT 0
93519: LESS
93520: IFFALSE 93530
// result := 0 ;
93522: LD_ADDR_VAR 0 2
93526: PUSH
93527: LD_INT 0
93529: ST_TO_ADDR
// end ;
93530: LD_VAR 0 2
93534: RET
// export function SortByClass ( units , class ) ; var un ; begin
93535: LD_INT 0
93537: PPUSH
93538: PPUSH
// if not units or not class then
93539: LD_VAR 0 1
93543: NOT
93544: PUSH
93545: LD_VAR 0 2
93549: NOT
93550: OR
93551: IFFALSE 93555
// exit ;
93553: GO 93650
// result := [ ] ;
93555: LD_ADDR_VAR 0 3
93559: PUSH
93560: EMPTY
93561: ST_TO_ADDR
// for un in units do
93562: LD_ADDR_VAR 0 4
93566: PUSH
93567: LD_VAR 0 1
93571: PUSH
93572: FOR_IN
93573: IFFALSE 93648
// if GetClass ( un ) = class then
93575: LD_VAR 0 4
93579: PPUSH
93580: CALL_OW 257
93584: PUSH
93585: LD_VAR 0 2
93589: EQUAL
93590: IFFALSE 93617
// result := Insert ( result , 1 , un ) else
93592: LD_ADDR_VAR 0 3
93596: PUSH
93597: LD_VAR 0 3
93601: PPUSH
93602: LD_INT 1
93604: PPUSH
93605: LD_VAR 0 4
93609: PPUSH
93610: CALL_OW 2
93614: ST_TO_ADDR
93615: GO 93646
// result := Replace ( result , result + 1 , un ) ;
93617: LD_ADDR_VAR 0 3
93621: PUSH
93622: LD_VAR 0 3
93626: PPUSH
93627: LD_VAR 0 3
93631: PUSH
93632: LD_INT 1
93634: PLUS
93635: PPUSH
93636: LD_VAR 0 4
93640: PPUSH
93641: CALL_OW 1
93645: ST_TO_ADDR
93646: GO 93572
93648: POP
93649: POP
// end ;
93650: LD_VAR 0 3
93654: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
93655: LD_INT 0
93657: PPUSH
93658: PPUSH
93659: PPUSH
93660: PPUSH
93661: PPUSH
93662: PPUSH
93663: PPUSH
// result := [ ] ;
93664: LD_ADDR_VAR 0 4
93668: PUSH
93669: EMPTY
93670: ST_TO_ADDR
// if x - r < 0 then
93671: LD_VAR 0 1
93675: PUSH
93676: LD_VAR 0 3
93680: MINUS
93681: PUSH
93682: LD_INT 0
93684: LESS
93685: IFFALSE 93697
// min_x := 0 else
93687: LD_ADDR_VAR 0 8
93691: PUSH
93692: LD_INT 0
93694: ST_TO_ADDR
93695: GO 93713
// min_x := x - r ;
93697: LD_ADDR_VAR 0 8
93701: PUSH
93702: LD_VAR 0 1
93706: PUSH
93707: LD_VAR 0 3
93711: MINUS
93712: ST_TO_ADDR
// if y - r < 0 then
93713: LD_VAR 0 2
93717: PUSH
93718: LD_VAR 0 3
93722: MINUS
93723: PUSH
93724: LD_INT 0
93726: LESS
93727: IFFALSE 93739
// min_y := 0 else
93729: LD_ADDR_VAR 0 7
93733: PUSH
93734: LD_INT 0
93736: ST_TO_ADDR
93737: GO 93755
// min_y := y - r ;
93739: LD_ADDR_VAR 0 7
93743: PUSH
93744: LD_VAR 0 2
93748: PUSH
93749: LD_VAR 0 3
93753: MINUS
93754: ST_TO_ADDR
// max_x := x + r ;
93755: LD_ADDR_VAR 0 9
93759: PUSH
93760: LD_VAR 0 1
93764: PUSH
93765: LD_VAR 0 3
93769: PLUS
93770: ST_TO_ADDR
// max_y := y + r ;
93771: LD_ADDR_VAR 0 10
93775: PUSH
93776: LD_VAR 0 2
93780: PUSH
93781: LD_VAR 0 3
93785: PLUS
93786: ST_TO_ADDR
// for _x = min_x to max_x do
93787: LD_ADDR_VAR 0 5
93791: PUSH
93792: DOUBLE
93793: LD_VAR 0 8
93797: DEC
93798: ST_TO_ADDR
93799: LD_VAR 0 9
93803: PUSH
93804: FOR_TO
93805: IFFALSE 93906
// for _y = min_y to max_y do
93807: LD_ADDR_VAR 0 6
93811: PUSH
93812: DOUBLE
93813: LD_VAR 0 7
93817: DEC
93818: ST_TO_ADDR
93819: LD_VAR 0 10
93823: PUSH
93824: FOR_TO
93825: IFFALSE 93902
// begin if not ValidHex ( _x , _y ) then
93827: LD_VAR 0 5
93831: PPUSH
93832: LD_VAR 0 6
93836: PPUSH
93837: CALL_OW 488
93841: NOT
93842: IFFALSE 93846
// continue ;
93844: GO 93824
// if GetResourceTypeXY ( _x , _y ) then
93846: LD_VAR 0 5
93850: PPUSH
93851: LD_VAR 0 6
93855: PPUSH
93856: CALL_OW 283
93860: IFFALSE 93900
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
93862: LD_ADDR_VAR 0 4
93866: PUSH
93867: LD_VAR 0 4
93871: PPUSH
93872: LD_VAR 0 4
93876: PUSH
93877: LD_INT 1
93879: PLUS
93880: PPUSH
93881: LD_VAR 0 5
93885: PUSH
93886: LD_VAR 0 6
93890: PUSH
93891: EMPTY
93892: LIST
93893: LIST
93894: PPUSH
93895: CALL_OW 1
93899: ST_TO_ADDR
// end ;
93900: GO 93824
93902: POP
93903: POP
93904: GO 93804
93906: POP
93907: POP
// end ;
93908: LD_VAR 0 4
93912: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
93913: LD_INT 0
93915: PPUSH
93916: PPUSH
93917: PPUSH
93918: PPUSH
93919: PPUSH
93920: PPUSH
93921: PPUSH
93922: PPUSH
// if not units then
93923: LD_VAR 0 1
93927: NOT
93928: IFFALSE 93932
// exit ;
93930: GO 94460
// result := UnitFilter ( units , [ f_ok ] ) ;
93932: LD_ADDR_VAR 0 3
93936: PUSH
93937: LD_VAR 0 1
93941: PPUSH
93942: LD_INT 50
93944: PUSH
93945: EMPTY
93946: LIST
93947: PPUSH
93948: CALL_OW 72
93952: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
93953: LD_ADDR_VAR 0 8
93957: PUSH
93958: LD_VAR 0 1
93962: PUSH
93963: LD_INT 1
93965: ARRAY
93966: PPUSH
93967: CALL_OW 255
93971: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
93972: LD_ADDR_VAR 0 10
93976: PUSH
93977: LD_INT 29
93979: PUSH
93980: LD_INT 91
93982: PUSH
93983: LD_INT 49
93985: PUSH
93986: EMPTY
93987: LIST
93988: LIST
93989: LIST
93990: ST_TO_ADDR
// if not result then
93991: LD_VAR 0 3
93995: NOT
93996: IFFALSE 94000
// exit ;
93998: GO 94460
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
94000: LD_ADDR_VAR 0 5
94004: PUSH
94005: LD_INT 81
94007: PUSH
94008: LD_VAR 0 8
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PPUSH
94017: CALL_OW 69
94021: ST_TO_ADDR
// for i in result do
94022: LD_ADDR_VAR 0 4
94026: PUSH
94027: LD_VAR 0 3
94031: PUSH
94032: FOR_IN
94033: IFFALSE 94458
// begin tag := GetTag ( i ) + 1 ;
94035: LD_ADDR_VAR 0 9
94039: PUSH
94040: LD_VAR 0 4
94044: PPUSH
94045: CALL_OW 110
94049: PUSH
94050: LD_INT 1
94052: PLUS
94053: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
94054: LD_ADDR_VAR 0 7
94058: PUSH
94059: LD_VAR 0 4
94063: PPUSH
94064: CALL_OW 250
94068: PPUSH
94069: LD_VAR 0 4
94073: PPUSH
94074: CALL_OW 251
94078: PPUSH
94079: LD_INT 4
94081: PPUSH
94082: CALL 93655 0 3
94086: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
94087: LD_VAR 0 4
94091: PPUSH
94092: CALL_OW 247
94096: PUSH
94097: LD_INT 2
94099: EQUAL
94100: PUSH
94101: LD_VAR 0 7
94105: PUSH
94106: LD_INT 2
94108: GREATER
94109: AND
94110: PUSH
94111: LD_VAR 0 4
94115: PPUSH
94116: CALL_OW 264
94120: PUSH
94121: LD_VAR 0 10
94125: IN
94126: NOT
94127: AND
94128: IFFALSE 94167
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
94130: LD_VAR 0 4
94134: PPUSH
94135: LD_VAR 0 7
94139: PUSH
94140: LD_INT 1
94142: ARRAY
94143: PUSH
94144: LD_INT 1
94146: ARRAY
94147: PPUSH
94148: LD_VAR 0 7
94152: PUSH
94153: LD_INT 1
94155: ARRAY
94156: PUSH
94157: LD_INT 2
94159: ARRAY
94160: PPUSH
94161: CALL_OW 116
94165: GO 94456
// if path > tag then
94167: LD_VAR 0 2
94171: PUSH
94172: LD_VAR 0 9
94176: GREATER
94177: IFFALSE 94385
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
94179: LD_ADDR_VAR 0 6
94183: PUSH
94184: LD_VAR 0 5
94188: PPUSH
94189: LD_INT 91
94191: PUSH
94192: LD_VAR 0 4
94196: PUSH
94197: LD_INT 8
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: LIST
94204: PPUSH
94205: CALL_OW 72
94209: ST_TO_ADDR
// if nearEnemy then
94210: LD_VAR 0 6
94214: IFFALSE 94283
// begin if GetWeapon ( i ) = ru_time_lapser then
94216: LD_VAR 0 4
94220: PPUSH
94221: CALL_OW 264
94225: PUSH
94226: LD_INT 49
94228: EQUAL
94229: IFFALSE 94257
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
94231: LD_VAR 0 4
94235: PPUSH
94236: LD_VAR 0 6
94240: PPUSH
94241: LD_VAR 0 4
94245: PPUSH
94246: CALL_OW 74
94250: PPUSH
94251: CALL_OW 112
94255: GO 94281
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
94257: LD_VAR 0 4
94261: PPUSH
94262: LD_VAR 0 6
94266: PPUSH
94267: LD_VAR 0 4
94271: PPUSH
94272: CALL_OW 74
94276: PPUSH
94277: CALL 95531 0 2
// end else
94281: GO 94383
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
94283: LD_VAR 0 4
94287: PPUSH
94288: LD_VAR 0 2
94292: PUSH
94293: LD_VAR 0 9
94297: ARRAY
94298: PUSH
94299: LD_INT 1
94301: ARRAY
94302: PPUSH
94303: LD_VAR 0 2
94307: PUSH
94308: LD_VAR 0 9
94312: ARRAY
94313: PUSH
94314: LD_INT 2
94316: ARRAY
94317: PPUSH
94318: CALL_OW 297
94322: PUSH
94323: LD_INT 6
94325: GREATER
94326: IFFALSE 94369
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
94328: LD_VAR 0 4
94332: PPUSH
94333: LD_VAR 0 2
94337: PUSH
94338: LD_VAR 0 9
94342: ARRAY
94343: PUSH
94344: LD_INT 1
94346: ARRAY
94347: PPUSH
94348: LD_VAR 0 2
94352: PUSH
94353: LD_VAR 0 9
94357: ARRAY
94358: PUSH
94359: LD_INT 2
94361: ARRAY
94362: PPUSH
94363: CALL_OW 114
94367: GO 94383
// SetTag ( i , tag ) ;
94369: LD_VAR 0 4
94373: PPUSH
94374: LD_VAR 0 9
94378: PPUSH
94379: CALL_OW 109
// end else
94383: GO 94456
// if enemy then
94385: LD_VAR 0 5
94389: IFFALSE 94456
// begin if GetWeapon ( i ) = ru_time_lapser then
94391: LD_VAR 0 4
94395: PPUSH
94396: CALL_OW 264
94400: PUSH
94401: LD_INT 49
94403: EQUAL
94404: IFFALSE 94432
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
94406: LD_VAR 0 4
94410: PPUSH
94411: LD_VAR 0 5
94415: PPUSH
94416: LD_VAR 0 4
94420: PPUSH
94421: CALL_OW 74
94425: PPUSH
94426: CALL_OW 112
94430: GO 94456
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
94432: LD_VAR 0 4
94436: PPUSH
94437: LD_VAR 0 5
94441: PPUSH
94442: LD_VAR 0 4
94446: PPUSH
94447: CALL_OW 74
94451: PPUSH
94452: CALL 95531 0 2
// end ; end ;
94456: GO 94032
94458: POP
94459: POP
// end ;
94460: LD_VAR 0 3
94464: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
94465: LD_INT 0
94467: PPUSH
94468: PPUSH
94469: PPUSH
// if not unit or IsInUnit ( unit ) then
94470: LD_VAR 0 1
94474: NOT
94475: PUSH
94476: LD_VAR 0 1
94480: PPUSH
94481: CALL_OW 310
94485: OR
94486: IFFALSE 94490
// exit ;
94488: GO 94581
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
94490: LD_ADDR_VAR 0 4
94494: PUSH
94495: LD_VAR 0 1
94499: PPUSH
94500: CALL_OW 250
94504: PPUSH
94505: LD_VAR 0 2
94509: PPUSH
94510: LD_INT 1
94512: PPUSH
94513: CALL_OW 272
94517: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
94518: LD_ADDR_VAR 0 5
94522: PUSH
94523: LD_VAR 0 1
94527: PPUSH
94528: CALL_OW 251
94532: PPUSH
94533: LD_VAR 0 2
94537: PPUSH
94538: LD_INT 1
94540: PPUSH
94541: CALL_OW 273
94545: ST_TO_ADDR
// if ValidHex ( x , y ) then
94546: LD_VAR 0 4
94550: PPUSH
94551: LD_VAR 0 5
94555: PPUSH
94556: CALL_OW 488
94560: IFFALSE 94581
// ComTurnXY ( unit , x , y ) ;
94562: LD_VAR 0 1
94566: PPUSH
94567: LD_VAR 0 4
94571: PPUSH
94572: LD_VAR 0 5
94576: PPUSH
94577: CALL_OW 118
// end ;
94581: LD_VAR 0 3
94585: RET
// export function SeeUnits ( side , units ) ; var i ; begin
94586: LD_INT 0
94588: PPUSH
94589: PPUSH
// result := false ;
94590: LD_ADDR_VAR 0 3
94594: PUSH
94595: LD_INT 0
94597: ST_TO_ADDR
// if not units then
94598: LD_VAR 0 2
94602: NOT
94603: IFFALSE 94607
// exit ;
94605: GO 94652
// for i in units do
94607: LD_ADDR_VAR 0 4
94611: PUSH
94612: LD_VAR 0 2
94616: PUSH
94617: FOR_IN
94618: IFFALSE 94650
// if See ( side , i ) then
94620: LD_VAR 0 1
94624: PPUSH
94625: LD_VAR 0 4
94629: PPUSH
94630: CALL_OW 292
94634: IFFALSE 94648
// begin result := true ;
94636: LD_ADDR_VAR 0 3
94640: PUSH
94641: LD_INT 1
94643: ST_TO_ADDR
// exit ;
94644: POP
94645: POP
94646: GO 94652
// end ;
94648: GO 94617
94650: POP
94651: POP
// end ;
94652: LD_VAR 0 3
94656: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
94657: LD_INT 0
94659: PPUSH
94660: PPUSH
94661: PPUSH
94662: PPUSH
// if not unit or not points then
94663: LD_VAR 0 1
94667: NOT
94668: PUSH
94669: LD_VAR 0 2
94673: NOT
94674: OR
94675: IFFALSE 94679
// exit ;
94677: GO 94769
// dist := 99999 ;
94679: LD_ADDR_VAR 0 5
94683: PUSH
94684: LD_INT 99999
94686: ST_TO_ADDR
// for i in points do
94687: LD_ADDR_VAR 0 4
94691: PUSH
94692: LD_VAR 0 2
94696: PUSH
94697: FOR_IN
94698: IFFALSE 94767
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
94700: LD_ADDR_VAR 0 6
94704: PUSH
94705: LD_VAR 0 1
94709: PPUSH
94710: LD_VAR 0 4
94714: PUSH
94715: LD_INT 1
94717: ARRAY
94718: PPUSH
94719: LD_VAR 0 4
94723: PUSH
94724: LD_INT 2
94726: ARRAY
94727: PPUSH
94728: CALL_OW 297
94732: ST_TO_ADDR
// if tmpDist < dist then
94733: LD_VAR 0 6
94737: PUSH
94738: LD_VAR 0 5
94742: LESS
94743: IFFALSE 94765
// begin result := i ;
94745: LD_ADDR_VAR 0 3
94749: PUSH
94750: LD_VAR 0 4
94754: ST_TO_ADDR
// dist := tmpDist ;
94755: LD_ADDR_VAR 0 5
94759: PUSH
94760: LD_VAR 0 6
94764: ST_TO_ADDR
// end ; end ;
94765: GO 94697
94767: POP
94768: POP
// end ;
94769: LD_VAR 0 3
94773: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
94774: LD_INT 0
94776: PPUSH
// uc_side := side ;
94777: LD_ADDR_OWVAR 20
94781: PUSH
94782: LD_VAR 0 1
94786: ST_TO_ADDR
// uc_nation := 3 ;
94787: LD_ADDR_OWVAR 21
94791: PUSH
94792: LD_INT 3
94794: ST_TO_ADDR
// vc_chassis := 25 ;
94795: LD_ADDR_OWVAR 37
94799: PUSH
94800: LD_INT 25
94802: ST_TO_ADDR
// vc_engine := engine_siberite ;
94803: LD_ADDR_OWVAR 39
94807: PUSH
94808: LD_INT 3
94810: ST_TO_ADDR
// vc_control := control_computer ;
94811: LD_ADDR_OWVAR 38
94815: PUSH
94816: LD_INT 3
94818: ST_TO_ADDR
// vc_weapon := 59 ;
94819: LD_ADDR_OWVAR 40
94823: PUSH
94824: LD_INT 59
94826: ST_TO_ADDR
// result := CreateVehicle ;
94827: LD_ADDR_VAR 0 5
94831: PUSH
94832: CALL_OW 45
94836: ST_TO_ADDR
// SetDir ( result , d ) ;
94837: LD_VAR 0 5
94841: PPUSH
94842: LD_VAR 0 4
94846: PPUSH
94847: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
94851: LD_VAR 0 5
94855: PPUSH
94856: LD_VAR 0 2
94860: PPUSH
94861: LD_VAR 0 3
94865: PPUSH
94866: LD_INT 0
94868: PPUSH
94869: CALL_OW 48
// end ;
94873: LD_VAR 0 5
94877: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
94878: LD_INT 0
94880: PPUSH
94881: PPUSH
94882: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
94883: LD_ADDR_VAR 0 2
94887: PUSH
94888: LD_INT 0
94890: PUSH
94891: LD_INT 0
94893: PUSH
94894: LD_INT 0
94896: PUSH
94897: LD_INT 0
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
94906: LD_VAR 0 1
94910: NOT
94911: PUSH
94912: LD_VAR 0 1
94916: PPUSH
94917: CALL_OW 264
94921: PUSH
94922: LD_INT 12
94924: PUSH
94925: LD_INT 51
94927: PUSH
94928: LD_INT 32
94930: PUSH
94931: LD_INT 89
94933: PUSH
94934: EMPTY
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: IN
94940: NOT
94941: OR
94942: IFFALSE 94946
// exit ;
94944: GO 95044
// for i := 1 to 3 do
94946: LD_ADDR_VAR 0 3
94950: PUSH
94951: DOUBLE
94952: LD_INT 1
94954: DEC
94955: ST_TO_ADDR
94956: LD_INT 3
94958: PUSH
94959: FOR_TO
94960: IFFALSE 95042
// begin tmp := GetCargo ( cargo , i ) ;
94962: LD_ADDR_VAR 0 4
94966: PUSH
94967: LD_VAR 0 1
94971: PPUSH
94972: LD_VAR 0 3
94976: PPUSH
94977: CALL_OW 289
94981: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
94982: LD_ADDR_VAR 0 2
94986: PUSH
94987: LD_VAR 0 2
94991: PPUSH
94992: LD_VAR 0 3
94996: PPUSH
94997: LD_VAR 0 4
95001: PPUSH
95002: CALL_OW 1
95006: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
95007: LD_ADDR_VAR 0 2
95011: PUSH
95012: LD_VAR 0 2
95016: PPUSH
95017: LD_INT 4
95019: PPUSH
95020: LD_VAR 0 2
95024: PUSH
95025: LD_INT 4
95027: ARRAY
95028: PUSH
95029: LD_VAR 0 4
95033: PLUS
95034: PPUSH
95035: CALL_OW 1
95039: ST_TO_ADDR
// end ;
95040: GO 94959
95042: POP
95043: POP
// end ;
95044: LD_VAR 0 2
95048: RET
// export function Length ( array ) ; begin
95049: LD_INT 0
95051: PPUSH
// result := array + 0 ;
95052: LD_ADDR_VAR 0 2
95056: PUSH
95057: LD_VAR 0 1
95061: PUSH
95062: LD_INT 0
95064: PLUS
95065: ST_TO_ADDR
// end ;
95066: LD_VAR 0 2
95070: RET
// export function PrepareArray ( array ) ; begin
95071: LD_INT 0
95073: PPUSH
// result := array diff 0 ;
95074: LD_ADDR_VAR 0 2
95078: PUSH
95079: LD_VAR 0 1
95083: PUSH
95084: LD_INT 0
95086: DIFF
95087: ST_TO_ADDR
// if not result [ 1 ] then
95088: LD_VAR 0 2
95092: PUSH
95093: LD_INT 1
95095: ARRAY
95096: NOT
95097: IFFALSE 95117
// result := Delete ( result , 1 ) ;
95099: LD_ADDR_VAR 0 2
95103: PUSH
95104: LD_VAR 0 2
95108: PPUSH
95109: LD_INT 1
95111: PPUSH
95112: CALL_OW 3
95116: ST_TO_ADDR
// end ;
95117: LD_VAR 0 2
95121: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
95122: LD_INT 0
95124: PPUSH
95125: PPUSH
95126: PPUSH
95127: PPUSH
// sibRocketRange := 25 ;
95128: LD_ADDR_VAR 0 6
95132: PUSH
95133: LD_INT 25
95135: ST_TO_ADDR
// result := false ;
95136: LD_ADDR_VAR 0 4
95140: PUSH
95141: LD_INT 0
95143: ST_TO_ADDR
// for i := 0 to 5 do
95144: LD_ADDR_VAR 0 5
95148: PUSH
95149: DOUBLE
95150: LD_INT 0
95152: DEC
95153: ST_TO_ADDR
95154: LD_INT 5
95156: PUSH
95157: FOR_TO
95158: IFFALSE 95225
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
95160: LD_VAR 0 1
95164: PPUSH
95165: LD_VAR 0 5
95169: PPUSH
95170: LD_VAR 0 6
95174: PPUSH
95175: CALL_OW 272
95179: PPUSH
95180: LD_VAR 0 2
95184: PPUSH
95185: LD_VAR 0 5
95189: PPUSH
95190: LD_VAR 0 6
95194: PPUSH
95195: CALL_OW 273
95199: PPUSH
95200: LD_VAR 0 3
95204: PPUSH
95205: CALL_OW 309
95209: IFFALSE 95223
// begin result := true ;
95211: LD_ADDR_VAR 0 4
95215: PUSH
95216: LD_INT 1
95218: ST_TO_ADDR
// exit ;
95219: POP
95220: POP
95221: GO 95227
// end ;
95223: GO 95157
95225: POP
95226: POP
// end ;
95227: LD_VAR 0 4
95231: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
95232: LD_INT 0
95234: PPUSH
95235: PPUSH
95236: PPUSH
// if btype = b_depot then
95237: LD_VAR 0 2
95241: PUSH
95242: LD_INT 0
95244: EQUAL
95245: IFFALSE 95257
// begin result := true ;
95247: LD_ADDR_VAR 0 3
95251: PUSH
95252: LD_INT 1
95254: ST_TO_ADDR
// exit ;
95255: GO 95373
// end ; pom := GetBase ( depot ) ;
95257: LD_ADDR_VAR 0 4
95261: PUSH
95262: LD_VAR 0 1
95266: PPUSH
95267: CALL_OW 274
95271: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
95272: LD_ADDR_VAR 0 5
95276: PUSH
95277: LD_VAR 0 2
95281: PPUSH
95282: LD_VAR 0 1
95286: PPUSH
95287: CALL_OW 248
95291: PPUSH
95292: CALL_OW 450
95296: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
95297: LD_ADDR_VAR 0 3
95301: PUSH
95302: LD_VAR 0 4
95306: PPUSH
95307: LD_INT 1
95309: PPUSH
95310: CALL_OW 275
95314: PUSH
95315: LD_VAR 0 5
95319: PUSH
95320: LD_INT 1
95322: ARRAY
95323: GREATEREQUAL
95324: PUSH
95325: LD_VAR 0 4
95329: PPUSH
95330: LD_INT 2
95332: PPUSH
95333: CALL_OW 275
95337: PUSH
95338: LD_VAR 0 5
95342: PUSH
95343: LD_INT 2
95345: ARRAY
95346: GREATEREQUAL
95347: AND
95348: PUSH
95349: LD_VAR 0 4
95353: PPUSH
95354: LD_INT 3
95356: PPUSH
95357: CALL_OW 275
95361: PUSH
95362: LD_VAR 0 5
95366: PUSH
95367: LD_INT 3
95369: ARRAY
95370: GREATEREQUAL
95371: AND
95372: ST_TO_ADDR
// end ;
95373: LD_VAR 0 3
95377: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
95378: LD_INT 0
95380: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
95381: LD_VAR 0 1
95385: PPUSH
95386: LD_VAR 0 2
95390: PPUSH
95391: LD_INT 0
95393: PPUSH
95394: LD_INT 0
95396: PPUSH
95397: LD_INT 1
95399: PPUSH
95400: LD_INT 0
95402: PPUSH
95403: CALL_OW 587
// end ;
95407: LD_VAR 0 3
95411: RET
// export function CenterOnNow ( unit ) ; begin
95412: LD_INT 0
95414: PPUSH
// result := IsInUnit ( unit ) ;
95415: LD_ADDR_VAR 0 2
95419: PUSH
95420: LD_VAR 0 1
95424: PPUSH
95425: CALL_OW 310
95429: ST_TO_ADDR
// if not result then
95430: LD_VAR 0 2
95434: NOT
95435: IFFALSE 95447
// result := unit ;
95437: LD_ADDR_VAR 0 2
95441: PUSH
95442: LD_VAR 0 1
95446: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
95447: LD_VAR 0 1
95451: PPUSH
95452: CALL_OW 87
// end ;
95456: LD_VAR 0 2
95460: RET
// export function ComMoveHex ( unit , hex ) ; begin
95461: LD_INT 0
95463: PPUSH
// if not hex then
95464: LD_VAR 0 2
95468: NOT
95469: IFFALSE 95473
// exit ;
95471: GO 95526
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
95473: LD_VAR 0 2
95477: PUSH
95478: LD_INT 1
95480: ARRAY
95481: PPUSH
95482: LD_VAR 0 2
95486: PUSH
95487: LD_INT 2
95489: ARRAY
95490: PPUSH
95491: CALL_OW 428
95495: IFFALSE 95499
// exit ;
95497: GO 95526
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
95499: LD_VAR 0 1
95503: PPUSH
95504: LD_VAR 0 2
95508: PUSH
95509: LD_INT 1
95511: ARRAY
95512: PPUSH
95513: LD_VAR 0 2
95517: PUSH
95518: LD_INT 2
95520: ARRAY
95521: PPUSH
95522: CALL_OW 111
// end ;
95526: LD_VAR 0 3
95530: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
95531: LD_INT 0
95533: PPUSH
95534: PPUSH
95535: PPUSH
// if not unit or not enemy then
95536: LD_VAR 0 1
95540: NOT
95541: PUSH
95542: LD_VAR 0 2
95546: NOT
95547: OR
95548: IFFALSE 95552
// exit ;
95550: GO 95676
// x := GetX ( enemy ) ;
95552: LD_ADDR_VAR 0 4
95556: PUSH
95557: LD_VAR 0 2
95561: PPUSH
95562: CALL_OW 250
95566: ST_TO_ADDR
// y := GetY ( enemy ) ;
95567: LD_ADDR_VAR 0 5
95571: PUSH
95572: LD_VAR 0 2
95576: PPUSH
95577: CALL_OW 251
95581: ST_TO_ADDR
// if ValidHex ( x , y ) then
95582: LD_VAR 0 4
95586: PPUSH
95587: LD_VAR 0 5
95591: PPUSH
95592: CALL_OW 488
95596: IFFALSE 95676
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
95598: LD_VAR 0 2
95602: PPUSH
95603: CALL_OW 247
95607: PUSH
95608: LD_INT 3
95610: PUSH
95611: LD_INT 2
95613: PUSH
95614: EMPTY
95615: LIST
95616: LIST
95617: IN
95618: PUSH
95619: LD_VAR 0 1
95623: PPUSH
95624: CALL_OW 255
95628: PPUSH
95629: LD_VAR 0 2
95633: PPUSH
95634: CALL_OW 292
95638: OR
95639: IFFALSE 95657
// ComAttackUnit ( unit , enemy ) else
95641: LD_VAR 0 1
95645: PPUSH
95646: LD_VAR 0 2
95650: PPUSH
95651: CALL_OW 115
95655: GO 95676
// ComAgressiveMove ( unit , x , y ) ;
95657: LD_VAR 0 1
95661: PPUSH
95662: LD_VAR 0 4
95666: PPUSH
95667: LD_VAR 0 5
95671: PPUSH
95672: CALL_OW 114
// end ;
95676: LD_VAR 0 3
95680: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
95681: LD_INT 0
95683: PPUSH
95684: PPUSH
95685: PPUSH
// list := AreaToList ( area , 0 ) ;
95686: LD_ADDR_VAR 0 5
95690: PUSH
95691: LD_VAR 0 1
95695: PPUSH
95696: LD_INT 0
95698: PPUSH
95699: CALL_OW 517
95703: ST_TO_ADDR
// if not list then
95704: LD_VAR 0 5
95708: NOT
95709: IFFALSE 95713
// exit ;
95711: GO 95843
// if all then
95713: LD_VAR 0 2
95717: IFFALSE 95805
// begin for i := 1 to list [ 1 ] do
95719: LD_ADDR_VAR 0 4
95723: PUSH
95724: DOUBLE
95725: LD_INT 1
95727: DEC
95728: ST_TO_ADDR
95729: LD_VAR 0 5
95733: PUSH
95734: LD_INT 1
95736: ARRAY
95737: PUSH
95738: FOR_TO
95739: IFFALSE 95801
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
95741: LD_ADDR_VAR 0 3
95745: PUSH
95746: LD_VAR 0 3
95750: PPUSH
95751: LD_VAR 0 3
95755: PUSH
95756: LD_INT 1
95758: PLUS
95759: PPUSH
95760: LD_VAR 0 5
95764: PUSH
95765: LD_INT 1
95767: ARRAY
95768: PUSH
95769: LD_VAR 0 4
95773: ARRAY
95774: PUSH
95775: LD_VAR 0 5
95779: PUSH
95780: LD_INT 2
95782: ARRAY
95783: PUSH
95784: LD_VAR 0 4
95788: ARRAY
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PPUSH
95794: CALL_OW 1
95798: ST_TO_ADDR
95799: GO 95738
95801: POP
95802: POP
// exit ;
95803: GO 95843
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
95805: LD_ADDR_VAR 0 3
95809: PUSH
95810: LD_VAR 0 5
95814: PUSH
95815: LD_INT 1
95817: ARRAY
95818: PUSH
95819: LD_INT 1
95821: ARRAY
95822: PUSH
95823: LD_VAR 0 5
95827: PUSH
95828: LD_INT 2
95830: ARRAY
95831: PUSH
95832: LD_INT 1
95834: ARRAY
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: PUSH
95840: EMPTY
95841: LIST
95842: ST_TO_ADDR
// end ;
95843: LD_VAR 0 3
95847: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
95848: LD_INT 0
95850: PPUSH
95851: PPUSH
// list := AreaToList ( area , 0 ) ;
95852: LD_ADDR_VAR 0 4
95856: PUSH
95857: LD_VAR 0 1
95861: PPUSH
95862: LD_INT 0
95864: PPUSH
95865: CALL_OW 517
95869: ST_TO_ADDR
// if not list then
95870: LD_VAR 0 4
95874: NOT
95875: IFFALSE 95879
// exit ;
95877: GO 95920
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
95879: LD_ADDR_VAR 0 3
95883: PUSH
95884: LD_VAR 0 4
95888: PUSH
95889: LD_INT 1
95891: ARRAY
95892: PUSH
95893: LD_INT 1
95895: ARRAY
95896: PUSH
95897: LD_VAR 0 4
95901: PUSH
95902: LD_INT 2
95904: ARRAY
95905: PUSH
95906: LD_INT 1
95908: ARRAY
95909: PUSH
95910: LD_VAR 0 2
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: LIST
95919: ST_TO_ADDR
// end ;
95920: LD_VAR 0 3
95924: RET
// export function First ( array ) ; begin
95925: LD_INT 0
95927: PPUSH
// if not array then
95928: LD_VAR 0 1
95932: NOT
95933: IFFALSE 95937
// exit ;
95935: GO 95951
// result := array [ 1 ] ;
95937: LD_ADDR_VAR 0 2
95941: PUSH
95942: LD_VAR 0 1
95946: PUSH
95947: LD_INT 1
95949: ARRAY
95950: ST_TO_ADDR
// end ;
95951: LD_VAR 0 2
95955: RET
// export function Last ( array ) ; begin
95956: LD_INT 0
95958: PPUSH
// if not array then
95959: LD_VAR 0 1
95963: NOT
95964: IFFALSE 95968
// exit ;
95966: GO 95984
// result := array [ array ] ;
95968: LD_ADDR_VAR 0 2
95972: PUSH
95973: LD_VAR 0 1
95977: PUSH
95978: LD_VAR 0 1
95982: ARRAY
95983: ST_TO_ADDR
// end ;
95984: LD_VAR 0 2
95988: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
95989: LD_INT 0
95991: PPUSH
95992: PPUSH
// result := [ ] ;
95993: LD_ADDR_VAR 0 5
95997: PUSH
95998: EMPTY
95999: ST_TO_ADDR
// if not array then
96000: LD_VAR 0 1
96004: NOT
96005: IFFALSE 96009
// exit ;
96007: GO 96121
// for i := 1 to array do
96009: LD_ADDR_VAR 0 6
96013: PUSH
96014: DOUBLE
96015: LD_INT 1
96017: DEC
96018: ST_TO_ADDR
96019: LD_VAR 0 1
96023: PUSH
96024: FOR_TO
96025: IFFALSE 96119
// if array [ i ] [ index ] = value then
96027: LD_VAR 0 1
96031: PUSH
96032: LD_VAR 0 6
96036: ARRAY
96037: PUSH
96038: LD_VAR 0 2
96042: ARRAY
96043: PUSH
96044: LD_VAR 0 3
96048: EQUAL
96049: IFFALSE 96117
// begin if indexColumn then
96051: LD_VAR 0 4
96055: IFFALSE 96091
// result := Join ( result , array [ i ] [ indexColumn ] ) else
96057: LD_ADDR_VAR 0 5
96061: PUSH
96062: LD_VAR 0 5
96066: PPUSH
96067: LD_VAR 0 1
96071: PUSH
96072: LD_VAR 0 6
96076: ARRAY
96077: PUSH
96078: LD_VAR 0 4
96082: ARRAY
96083: PPUSH
96084: CALL 91309 0 2
96088: ST_TO_ADDR
96089: GO 96117
// result := Join ( result , array [ i ] ) ;
96091: LD_ADDR_VAR 0 5
96095: PUSH
96096: LD_VAR 0 5
96100: PPUSH
96101: LD_VAR 0 1
96105: PUSH
96106: LD_VAR 0 6
96110: ARRAY
96111: PPUSH
96112: CALL 91309 0 2
96116: ST_TO_ADDR
// end ;
96117: GO 96024
96119: POP
96120: POP
// end ;
96121: LD_VAR 0 5
96125: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
96126: LD_INT 0
96128: PPUSH
// if not vehicles or not parkingPoint then
96129: LD_VAR 0 1
96133: NOT
96134: PUSH
96135: LD_VAR 0 2
96139: NOT
96140: OR
96141: IFFALSE 96145
// exit ;
96143: GO 96243
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
96145: LD_ADDR_VAR 0 1
96149: PUSH
96150: LD_VAR 0 1
96154: PPUSH
96155: LD_INT 50
96157: PUSH
96158: EMPTY
96159: LIST
96160: PUSH
96161: LD_INT 3
96163: PUSH
96164: LD_INT 92
96166: PUSH
96167: LD_VAR 0 2
96171: PUSH
96172: LD_INT 1
96174: ARRAY
96175: PUSH
96176: LD_VAR 0 2
96180: PUSH
96181: LD_INT 2
96183: ARRAY
96184: PUSH
96185: LD_INT 8
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: PUSH
96198: EMPTY
96199: LIST
96200: LIST
96201: PPUSH
96202: CALL_OW 72
96206: ST_TO_ADDR
// if not vehicles then
96207: LD_VAR 0 1
96211: NOT
96212: IFFALSE 96216
// exit ;
96214: GO 96243
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
96216: LD_VAR 0 1
96220: PPUSH
96221: LD_VAR 0 2
96225: PUSH
96226: LD_INT 1
96228: ARRAY
96229: PPUSH
96230: LD_VAR 0 2
96234: PUSH
96235: LD_INT 2
96237: ARRAY
96238: PPUSH
96239: CALL_OW 111
// end ;
96243: LD_VAR 0 3
96247: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
96248: LD_INT 0
96250: PPUSH
96251: PPUSH
96252: PPUSH
// if not side or not area then
96253: LD_VAR 0 1
96257: NOT
96258: PUSH
96259: LD_VAR 0 2
96263: NOT
96264: OR
96265: IFFALSE 96269
// exit ;
96267: GO 96388
// tmp := AreaToList ( area , 0 ) ;
96269: LD_ADDR_VAR 0 5
96273: PUSH
96274: LD_VAR 0 2
96278: PPUSH
96279: LD_INT 0
96281: PPUSH
96282: CALL_OW 517
96286: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
96287: LD_ADDR_VAR 0 4
96291: PUSH
96292: DOUBLE
96293: LD_INT 1
96295: DEC
96296: ST_TO_ADDR
96297: LD_VAR 0 5
96301: PUSH
96302: LD_INT 1
96304: ARRAY
96305: PUSH
96306: FOR_TO
96307: IFFALSE 96386
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
96309: LD_VAR 0 5
96313: PUSH
96314: LD_INT 1
96316: ARRAY
96317: PUSH
96318: LD_VAR 0 4
96322: ARRAY
96323: PPUSH
96324: LD_VAR 0 5
96328: PUSH
96329: LD_INT 2
96331: ARRAY
96332: PUSH
96333: LD_VAR 0 4
96337: ARRAY
96338: PPUSH
96339: CALL_OW 351
96343: IFFALSE 96384
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
96345: LD_VAR 0 5
96349: PUSH
96350: LD_INT 1
96352: ARRAY
96353: PUSH
96354: LD_VAR 0 4
96358: ARRAY
96359: PPUSH
96360: LD_VAR 0 5
96364: PUSH
96365: LD_INT 2
96367: ARRAY
96368: PUSH
96369: LD_VAR 0 4
96373: ARRAY
96374: PPUSH
96375: LD_VAR 0 1
96379: PPUSH
96380: CALL_OW 244
// end ;
96384: GO 96306
96386: POP
96387: POP
// end ; end_of_file end_of_file
96388: LD_VAR 0 3
96392: RET
// export globalGameSaveCounter ; every 0 0$1 do
96393: GO 96395
96395: DISABLE
// begin enable ;
96396: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
96397: LD_STRING updateTimer(
96399: PUSH
96400: LD_OWVAR 1
96404: STR
96405: PUSH
96406: LD_STRING );
96408: STR
96409: PPUSH
96410: CALL_OW 559
// end ;
96414: END
// every 0 0$1 do
96415: GO 96417
96417: DISABLE
// begin globalGameSaveCounter := 0 ;
96418: LD_ADDR_EXP 125
96422: PUSH
96423: LD_INT 0
96425: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
96426: LD_STRING setGameSaveCounter(0)
96428: PPUSH
96429: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
96433: LD_STRING initStreamRollete();
96435: PPUSH
96436: CALL_OW 559
// InitStreamMode ;
96440: CALL 97783 0 0
// DefineStreamItems ( false ) ;
96444: LD_INT 0
96446: PPUSH
96447: CALL 98247 0 1
// end ;
96451: END
// export function SOS_MapStart ( ) ; begin
96452: LD_INT 0
96454: PPUSH
// if streamModeActive then
96455: LD_EXP 126
96459: IFFALSE 96468
// DefineStreamItems ( true ) ;
96461: LD_INT 1
96463: PPUSH
96464: CALL 98247 0 1
// UpdateLuaVariables ( ) ;
96468: CALL 96485 0 0
// UpdateFactoryWaypoints ( ) ;
96472: CALL 111249 0 0
// UpdateWarehouseGatheringPoints ( ) ;
96476: CALL 111501 0 0
// end ;
96480: LD_VAR 0 1
96484: RET
// function UpdateLuaVariables ( ) ; begin
96485: LD_INT 0
96487: PPUSH
// if globalGameSaveCounter then
96488: LD_EXP 125
96492: IFFALSE 96526
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
96494: LD_ADDR_EXP 125
96498: PUSH
96499: LD_EXP 125
96503: PPUSH
96504: CALL 92670 0 1
96508: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96509: LD_STRING setGameSaveCounter(
96511: PUSH
96512: LD_EXP 125
96516: STR
96517: PUSH
96518: LD_STRING )
96520: STR
96521: PPUSH
96522: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
96526: LD_STRING setGameDifficulty(
96528: PUSH
96529: LD_OWVAR 67
96533: STR
96534: PUSH
96535: LD_STRING )
96537: STR
96538: PPUSH
96539: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
96543: LD_STRING displayDifficulty(
96545: PUSH
96546: LD_OWVAR 67
96550: STR
96551: PUSH
96552: LD_STRING )
96554: STR
96555: PPUSH
96556: CALL_OW 559
// end ;
96560: LD_VAR 0 1
96564: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96565: LD_INT 0
96567: PPUSH
// if p2 = stream_mode then
96568: LD_VAR 0 2
96572: PUSH
96573: LD_INT 100
96575: EQUAL
96576: IFFALSE 97579
// begin if not StreamModeActive then
96578: LD_EXP 126
96582: NOT
96583: IFFALSE 96593
// StreamModeActive := true ;
96585: LD_ADDR_EXP 126
96589: PUSH
96590: LD_INT 1
96592: ST_TO_ADDR
// if p3 = 0 then
96593: LD_VAR 0 3
96597: PUSH
96598: LD_INT 0
96600: EQUAL
96601: IFFALSE 96607
// InitStreamMode ;
96603: CALL 97783 0 0
// if p3 = 1 then
96607: LD_VAR 0 3
96611: PUSH
96612: LD_INT 1
96614: EQUAL
96615: IFFALSE 96625
// sRocket := true ;
96617: LD_ADDR_EXP 131
96621: PUSH
96622: LD_INT 1
96624: ST_TO_ADDR
// if p3 = 2 then
96625: LD_VAR 0 3
96629: PUSH
96630: LD_INT 2
96632: EQUAL
96633: IFFALSE 96643
// sSpeed := true ;
96635: LD_ADDR_EXP 130
96639: PUSH
96640: LD_INT 1
96642: ST_TO_ADDR
// if p3 = 3 then
96643: LD_VAR 0 3
96647: PUSH
96648: LD_INT 3
96650: EQUAL
96651: IFFALSE 96661
// sEngine := true ;
96653: LD_ADDR_EXP 132
96657: PUSH
96658: LD_INT 1
96660: ST_TO_ADDR
// if p3 = 4 then
96661: LD_VAR 0 3
96665: PUSH
96666: LD_INT 4
96668: EQUAL
96669: IFFALSE 96679
// sSpec := true ;
96671: LD_ADDR_EXP 129
96675: PUSH
96676: LD_INT 1
96678: ST_TO_ADDR
// if p3 = 5 then
96679: LD_VAR 0 3
96683: PUSH
96684: LD_INT 5
96686: EQUAL
96687: IFFALSE 96697
// sLevel := true ;
96689: LD_ADDR_EXP 133
96693: PUSH
96694: LD_INT 1
96696: ST_TO_ADDR
// if p3 = 6 then
96697: LD_VAR 0 3
96701: PUSH
96702: LD_INT 6
96704: EQUAL
96705: IFFALSE 96715
// sArmoury := true ;
96707: LD_ADDR_EXP 134
96711: PUSH
96712: LD_INT 1
96714: ST_TO_ADDR
// if p3 = 7 then
96715: LD_VAR 0 3
96719: PUSH
96720: LD_INT 7
96722: EQUAL
96723: IFFALSE 96733
// sRadar := true ;
96725: LD_ADDR_EXP 135
96729: PUSH
96730: LD_INT 1
96732: ST_TO_ADDR
// if p3 = 8 then
96733: LD_VAR 0 3
96737: PUSH
96738: LD_INT 8
96740: EQUAL
96741: IFFALSE 96751
// sBunker := true ;
96743: LD_ADDR_EXP 136
96747: PUSH
96748: LD_INT 1
96750: ST_TO_ADDR
// if p3 = 9 then
96751: LD_VAR 0 3
96755: PUSH
96756: LD_INT 9
96758: EQUAL
96759: IFFALSE 96769
// sHack := true ;
96761: LD_ADDR_EXP 137
96765: PUSH
96766: LD_INT 1
96768: ST_TO_ADDR
// if p3 = 10 then
96769: LD_VAR 0 3
96773: PUSH
96774: LD_INT 10
96776: EQUAL
96777: IFFALSE 96787
// sFire := true ;
96779: LD_ADDR_EXP 138
96783: PUSH
96784: LD_INT 1
96786: ST_TO_ADDR
// if p3 = 11 then
96787: LD_VAR 0 3
96791: PUSH
96792: LD_INT 11
96794: EQUAL
96795: IFFALSE 96805
// sRefresh := true ;
96797: LD_ADDR_EXP 139
96801: PUSH
96802: LD_INT 1
96804: ST_TO_ADDR
// if p3 = 12 then
96805: LD_VAR 0 3
96809: PUSH
96810: LD_INT 12
96812: EQUAL
96813: IFFALSE 96823
// sExp := true ;
96815: LD_ADDR_EXP 140
96819: PUSH
96820: LD_INT 1
96822: ST_TO_ADDR
// if p3 = 13 then
96823: LD_VAR 0 3
96827: PUSH
96828: LD_INT 13
96830: EQUAL
96831: IFFALSE 96841
// sDepot := true ;
96833: LD_ADDR_EXP 141
96837: PUSH
96838: LD_INT 1
96840: ST_TO_ADDR
// if p3 = 14 then
96841: LD_VAR 0 3
96845: PUSH
96846: LD_INT 14
96848: EQUAL
96849: IFFALSE 96859
// sFlag := true ;
96851: LD_ADDR_EXP 142
96855: PUSH
96856: LD_INT 1
96858: ST_TO_ADDR
// if p3 = 15 then
96859: LD_VAR 0 3
96863: PUSH
96864: LD_INT 15
96866: EQUAL
96867: IFFALSE 96877
// sKamikadze := true ;
96869: LD_ADDR_EXP 150
96873: PUSH
96874: LD_INT 1
96876: ST_TO_ADDR
// if p3 = 16 then
96877: LD_VAR 0 3
96881: PUSH
96882: LD_INT 16
96884: EQUAL
96885: IFFALSE 96895
// sTroll := true ;
96887: LD_ADDR_EXP 151
96891: PUSH
96892: LD_INT 1
96894: ST_TO_ADDR
// if p3 = 17 then
96895: LD_VAR 0 3
96899: PUSH
96900: LD_INT 17
96902: EQUAL
96903: IFFALSE 96913
// sSlow := true ;
96905: LD_ADDR_EXP 152
96909: PUSH
96910: LD_INT 1
96912: ST_TO_ADDR
// if p3 = 18 then
96913: LD_VAR 0 3
96917: PUSH
96918: LD_INT 18
96920: EQUAL
96921: IFFALSE 96931
// sLack := true ;
96923: LD_ADDR_EXP 153
96927: PUSH
96928: LD_INT 1
96930: ST_TO_ADDR
// if p3 = 19 then
96931: LD_VAR 0 3
96935: PUSH
96936: LD_INT 19
96938: EQUAL
96939: IFFALSE 96949
// sTank := true ;
96941: LD_ADDR_EXP 155
96945: PUSH
96946: LD_INT 1
96948: ST_TO_ADDR
// if p3 = 20 then
96949: LD_VAR 0 3
96953: PUSH
96954: LD_INT 20
96956: EQUAL
96957: IFFALSE 96967
// sRemote := true ;
96959: LD_ADDR_EXP 156
96963: PUSH
96964: LD_INT 1
96966: ST_TO_ADDR
// if p3 = 21 then
96967: LD_VAR 0 3
96971: PUSH
96972: LD_INT 21
96974: EQUAL
96975: IFFALSE 96985
// sPowell := true ;
96977: LD_ADDR_EXP 157
96981: PUSH
96982: LD_INT 1
96984: ST_TO_ADDR
// if p3 = 22 then
96985: LD_VAR 0 3
96989: PUSH
96990: LD_INT 22
96992: EQUAL
96993: IFFALSE 97003
// sTeleport := true ;
96995: LD_ADDR_EXP 160
96999: PUSH
97000: LD_INT 1
97002: ST_TO_ADDR
// if p3 = 23 then
97003: LD_VAR 0 3
97007: PUSH
97008: LD_INT 23
97010: EQUAL
97011: IFFALSE 97021
// sOilTower := true ;
97013: LD_ADDR_EXP 162
97017: PUSH
97018: LD_INT 1
97020: ST_TO_ADDR
// if p3 = 24 then
97021: LD_VAR 0 3
97025: PUSH
97026: LD_INT 24
97028: EQUAL
97029: IFFALSE 97039
// sShovel := true ;
97031: LD_ADDR_EXP 163
97035: PUSH
97036: LD_INT 1
97038: ST_TO_ADDR
// if p3 = 25 then
97039: LD_VAR 0 3
97043: PUSH
97044: LD_INT 25
97046: EQUAL
97047: IFFALSE 97057
// sSheik := true ;
97049: LD_ADDR_EXP 164
97053: PUSH
97054: LD_INT 1
97056: ST_TO_ADDR
// if p3 = 26 then
97057: LD_VAR 0 3
97061: PUSH
97062: LD_INT 26
97064: EQUAL
97065: IFFALSE 97075
// sEarthquake := true ;
97067: LD_ADDR_EXP 166
97071: PUSH
97072: LD_INT 1
97074: ST_TO_ADDR
// if p3 = 27 then
97075: LD_VAR 0 3
97079: PUSH
97080: LD_INT 27
97082: EQUAL
97083: IFFALSE 97093
// sAI := true ;
97085: LD_ADDR_EXP 167
97089: PUSH
97090: LD_INT 1
97092: ST_TO_ADDR
// if p3 = 28 then
97093: LD_VAR 0 3
97097: PUSH
97098: LD_INT 28
97100: EQUAL
97101: IFFALSE 97111
// sCargo := true ;
97103: LD_ADDR_EXP 170
97107: PUSH
97108: LD_INT 1
97110: ST_TO_ADDR
// if p3 = 29 then
97111: LD_VAR 0 3
97115: PUSH
97116: LD_INT 29
97118: EQUAL
97119: IFFALSE 97129
// sDLaser := true ;
97121: LD_ADDR_EXP 171
97125: PUSH
97126: LD_INT 1
97128: ST_TO_ADDR
// if p3 = 30 then
97129: LD_VAR 0 3
97133: PUSH
97134: LD_INT 30
97136: EQUAL
97137: IFFALSE 97147
// sExchange := true ;
97139: LD_ADDR_EXP 172
97143: PUSH
97144: LD_INT 1
97146: ST_TO_ADDR
// if p3 = 31 then
97147: LD_VAR 0 3
97151: PUSH
97152: LD_INT 31
97154: EQUAL
97155: IFFALSE 97165
// sFac := true ;
97157: LD_ADDR_EXP 173
97161: PUSH
97162: LD_INT 1
97164: ST_TO_ADDR
// if p3 = 32 then
97165: LD_VAR 0 3
97169: PUSH
97170: LD_INT 32
97172: EQUAL
97173: IFFALSE 97183
// sPower := true ;
97175: LD_ADDR_EXP 174
97179: PUSH
97180: LD_INT 1
97182: ST_TO_ADDR
// if p3 = 33 then
97183: LD_VAR 0 3
97187: PUSH
97188: LD_INT 33
97190: EQUAL
97191: IFFALSE 97201
// sRandom := true ;
97193: LD_ADDR_EXP 175
97197: PUSH
97198: LD_INT 1
97200: ST_TO_ADDR
// if p3 = 34 then
97201: LD_VAR 0 3
97205: PUSH
97206: LD_INT 34
97208: EQUAL
97209: IFFALSE 97219
// sShield := true ;
97211: LD_ADDR_EXP 176
97215: PUSH
97216: LD_INT 1
97218: ST_TO_ADDR
// if p3 = 35 then
97219: LD_VAR 0 3
97223: PUSH
97224: LD_INT 35
97226: EQUAL
97227: IFFALSE 97237
// sTime := true ;
97229: LD_ADDR_EXP 177
97233: PUSH
97234: LD_INT 1
97236: ST_TO_ADDR
// if p3 = 36 then
97237: LD_VAR 0 3
97241: PUSH
97242: LD_INT 36
97244: EQUAL
97245: IFFALSE 97255
// sTools := true ;
97247: LD_ADDR_EXP 178
97251: PUSH
97252: LD_INT 1
97254: ST_TO_ADDR
// if p3 = 101 then
97255: LD_VAR 0 3
97259: PUSH
97260: LD_INT 101
97262: EQUAL
97263: IFFALSE 97273
// sSold := true ;
97265: LD_ADDR_EXP 143
97269: PUSH
97270: LD_INT 1
97272: ST_TO_ADDR
// if p3 = 102 then
97273: LD_VAR 0 3
97277: PUSH
97278: LD_INT 102
97280: EQUAL
97281: IFFALSE 97291
// sDiff := true ;
97283: LD_ADDR_EXP 144
97287: PUSH
97288: LD_INT 1
97290: ST_TO_ADDR
// if p3 = 103 then
97291: LD_VAR 0 3
97295: PUSH
97296: LD_INT 103
97298: EQUAL
97299: IFFALSE 97309
// sFog := true ;
97301: LD_ADDR_EXP 147
97305: PUSH
97306: LD_INT 1
97308: ST_TO_ADDR
// if p3 = 104 then
97309: LD_VAR 0 3
97313: PUSH
97314: LD_INT 104
97316: EQUAL
97317: IFFALSE 97327
// sReset := true ;
97319: LD_ADDR_EXP 148
97323: PUSH
97324: LD_INT 1
97326: ST_TO_ADDR
// if p3 = 105 then
97327: LD_VAR 0 3
97331: PUSH
97332: LD_INT 105
97334: EQUAL
97335: IFFALSE 97345
// sSun := true ;
97337: LD_ADDR_EXP 149
97341: PUSH
97342: LD_INT 1
97344: ST_TO_ADDR
// if p3 = 106 then
97345: LD_VAR 0 3
97349: PUSH
97350: LD_INT 106
97352: EQUAL
97353: IFFALSE 97363
// sTiger := true ;
97355: LD_ADDR_EXP 145
97359: PUSH
97360: LD_INT 1
97362: ST_TO_ADDR
// if p3 = 107 then
97363: LD_VAR 0 3
97367: PUSH
97368: LD_INT 107
97370: EQUAL
97371: IFFALSE 97381
// sBomb := true ;
97373: LD_ADDR_EXP 146
97377: PUSH
97378: LD_INT 1
97380: ST_TO_ADDR
// if p3 = 108 then
97381: LD_VAR 0 3
97385: PUSH
97386: LD_INT 108
97388: EQUAL
97389: IFFALSE 97399
// sWound := true ;
97391: LD_ADDR_EXP 154
97395: PUSH
97396: LD_INT 1
97398: ST_TO_ADDR
// if p3 = 109 then
97399: LD_VAR 0 3
97403: PUSH
97404: LD_INT 109
97406: EQUAL
97407: IFFALSE 97417
// sBetray := true ;
97409: LD_ADDR_EXP 158
97413: PUSH
97414: LD_INT 1
97416: ST_TO_ADDR
// if p3 = 110 then
97417: LD_VAR 0 3
97421: PUSH
97422: LD_INT 110
97424: EQUAL
97425: IFFALSE 97435
// sContamin := true ;
97427: LD_ADDR_EXP 159
97431: PUSH
97432: LD_INT 1
97434: ST_TO_ADDR
// if p3 = 111 then
97435: LD_VAR 0 3
97439: PUSH
97440: LD_INT 111
97442: EQUAL
97443: IFFALSE 97453
// sOil := true ;
97445: LD_ADDR_EXP 161
97449: PUSH
97450: LD_INT 1
97452: ST_TO_ADDR
// if p3 = 112 then
97453: LD_VAR 0 3
97457: PUSH
97458: LD_INT 112
97460: EQUAL
97461: IFFALSE 97471
// sStu := true ;
97463: LD_ADDR_EXP 165
97467: PUSH
97468: LD_INT 1
97470: ST_TO_ADDR
// if p3 = 113 then
97471: LD_VAR 0 3
97475: PUSH
97476: LD_INT 113
97478: EQUAL
97479: IFFALSE 97489
// sBazooka := true ;
97481: LD_ADDR_EXP 168
97485: PUSH
97486: LD_INT 1
97488: ST_TO_ADDR
// if p3 = 114 then
97489: LD_VAR 0 3
97493: PUSH
97494: LD_INT 114
97496: EQUAL
97497: IFFALSE 97507
// sMortar := true ;
97499: LD_ADDR_EXP 169
97503: PUSH
97504: LD_INT 1
97506: ST_TO_ADDR
// if p3 = 115 then
97507: LD_VAR 0 3
97511: PUSH
97512: LD_INT 115
97514: EQUAL
97515: IFFALSE 97525
// sRanger := true ;
97517: LD_ADDR_EXP 179
97521: PUSH
97522: LD_INT 1
97524: ST_TO_ADDR
// if p3 = 116 then
97525: LD_VAR 0 3
97529: PUSH
97530: LD_INT 116
97532: EQUAL
97533: IFFALSE 97543
// sComputer := true ;
97535: LD_ADDR_EXP 180
97539: PUSH
97540: LD_INT 1
97542: ST_TO_ADDR
// if p3 = 117 then
97543: LD_VAR 0 3
97547: PUSH
97548: LD_INT 117
97550: EQUAL
97551: IFFALSE 97561
// s30 := true ;
97553: LD_ADDR_EXP 181
97557: PUSH
97558: LD_INT 1
97560: ST_TO_ADDR
// if p3 = 118 then
97561: LD_VAR 0 3
97565: PUSH
97566: LD_INT 118
97568: EQUAL
97569: IFFALSE 97579
// s60 := true ;
97571: LD_ADDR_EXP 182
97575: PUSH
97576: LD_INT 1
97578: ST_TO_ADDR
// end ; if p2 = hack_mode then
97579: LD_VAR 0 2
97583: PUSH
97584: LD_INT 101
97586: EQUAL
97587: IFFALSE 97715
// begin case p3 of 1 :
97589: LD_VAR 0 3
97593: PUSH
97594: LD_INT 1
97596: DOUBLE
97597: EQUAL
97598: IFTRUE 97602
97600: GO 97609
97602: POP
// hHackUnlimitedResources ; 2 :
97603: CALL 109862 0 0
97607: GO 97715
97609: LD_INT 2
97611: DOUBLE
97612: EQUAL
97613: IFTRUE 97617
97615: GO 97624
97617: POP
// hHackSetLevel10 ; 3 :
97618: CALL 109995 0 0
97622: GO 97715
97624: LD_INT 3
97626: DOUBLE
97627: EQUAL
97628: IFTRUE 97632
97630: GO 97639
97632: POP
// hHackSetLevel10YourUnits ; 4 :
97633: CALL 110080 0 0
97637: GO 97715
97639: LD_INT 4
97641: DOUBLE
97642: EQUAL
97643: IFTRUE 97647
97645: GO 97654
97647: POP
// hHackInvincible ; 5 :
97648: CALL 110528 0 0
97652: GO 97715
97654: LD_INT 5
97656: DOUBLE
97657: EQUAL
97658: IFTRUE 97662
97660: GO 97669
97662: POP
// hHackInvisible ; 6 :
97663: CALL 110639 0 0
97667: GO 97715
97669: LD_INT 6
97671: DOUBLE
97672: EQUAL
97673: IFTRUE 97677
97675: GO 97684
97677: POP
// hHackChangeYourSide ; 7 :
97678: CALL 110696 0 0
97682: GO 97715
97684: LD_INT 7
97686: DOUBLE
97687: EQUAL
97688: IFTRUE 97692
97690: GO 97699
97692: POP
// hHackChangeUnitSide ; 8 :
97693: CALL 110738 0 0
97697: GO 97715
97699: LD_INT 8
97701: DOUBLE
97702: EQUAL
97703: IFTRUE 97707
97705: GO 97714
97707: POP
// hHackFog ; end ;
97708: CALL 110839 0 0
97712: GO 97715
97714: POP
// end ; if p2 = game_save_mode then
97715: LD_VAR 0 2
97719: PUSH
97720: LD_INT 102
97722: EQUAL
97723: IFFALSE 97778
// begin if p3 = 1 then
97725: LD_VAR 0 3
97729: PUSH
97730: LD_INT 1
97732: EQUAL
97733: IFFALSE 97745
// globalGameSaveCounter := p4 ;
97735: LD_ADDR_EXP 125
97739: PUSH
97740: LD_VAR 0 4
97744: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
97745: LD_VAR 0 3
97749: PUSH
97750: LD_INT 2
97752: EQUAL
97753: PUSH
97754: LD_EXP 125
97758: AND
97759: IFFALSE 97778
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
97761: LD_STRING setGameSaveCounter(
97763: PUSH
97764: LD_EXP 125
97768: STR
97769: PUSH
97770: LD_STRING )
97772: STR
97773: PPUSH
97774: CALL_OW 559
// end ; end ;
97778: LD_VAR 0 7
97782: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
97783: LD_INT 0
97785: PPUSH
// streamModeActive := false ;
97786: LD_ADDR_EXP 126
97790: PUSH
97791: LD_INT 0
97793: ST_TO_ADDR
// normalCounter := 36 ;
97794: LD_ADDR_EXP 127
97798: PUSH
97799: LD_INT 36
97801: ST_TO_ADDR
// hardcoreCounter := 18 ;
97802: LD_ADDR_EXP 128
97806: PUSH
97807: LD_INT 18
97809: ST_TO_ADDR
// sRocket := false ;
97810: LD_ADDR_EXP 131
97814: PUSH
97815: LD_INT 0
97817: ST_TO_ADDR
// sSpeed := false ;
97818: LD_ADDR_EXP 130
97822: PUSH
97823: LD_INT 0
97825: ST_TO_ADDR
// sEngine := false ;
97826: LD_ADDR_EXP 132
97830: PUSH
97831: LD_INT 0
97833: ST_TO_ADDR
// sSpec := false ;
97834: LD_ADDR_EXP 129
97838: PUSH
97839: LD_INT 0
97841: ST_TO_ADDR
// sLevel := false ;
97842: LD_ADDR_EXP 133
97846: PUSH
97847: LD_INT 0
97849: ST_TO_ADDR
// sArmoury := false ;
97850: LD_ADDR_EXP 134
97854: PUSH
97855: LD_INT 0
97857: ST_TO_ADDR
// sRadar := false ;
97858: LD_ADDR_EXP 135
97862: PUSH
97863: LD_INT 0
97865: ST_TO_ADDR
// sBunker := false ;
97866: LD_ADDR_EXP 136
97870: PUSH
97871: LD_INT 0
97873: ST_TO_ADDR
// sHack := false ;
97874: LD_ADDR_EXP 137
97878: PUSH
97879: LD_INT 0
97881: ST_TO_ADDR
// sFire := false ;
97882: LD_ADDR_EXP 138
97886: PUSH
97887: LD_INT 0
97889: ST_TO_ADDR
// sRefresh := false ;
97890: LD_ADDR_EXP 139
97894: PUSH
97895: LD_INT 0
97897: ST_TO_ADDR
// sExp := false ;
97898: LD_ADDR_EXP 140
97902: PUSH
97903: LD_INT 0
97905: ST_TO_ADDR
// sDepot := false ;
97906: LD_ADDR_EXP 141
97910: PUSH
97911: LD_INT 0
97913: ST_TO_ADDR
// sFlag := false ;
97914: LD_ADDR_EXP 142
97918: PUSH
97919: LD_INT 0
97921: ST_TO_ADDR
// sKamikadze := false ;
97922: LD_ADDR_EXP 150
97926: PUSH
97927: LD_INT 0
97929: ST_TO_ADDR
// sTroll := false ;
97930: LD_ADDR_EXP 151
97934: PUSH
97935: LD_INT 0
97937: ST_TO_ADDR
// sSlow := false ;
97938: LD_ADDR_EXP 152
97942: PUSH
97943: LD_INT 0
97945: ST_TO_ADDR
// sLack := false ;
97946: LD_ADDR_EXP 153
97950: PUSH
97951: LD_INT 0
97953: ST_TO_ADDR
// sTank := false ;
97954: LD_ADDR_EXP 155
97958: PUSH
97959: LD_INT 0
97961: ST_TO_ADDR
// sRemote := false ;
97962: LD_ADDR_EXP 156
97966: PUSH
97967: LD_INT 0
97969: ST_TO_ADDR
// sPowell := false ;
97970: LD_ADDR_EXP 157
97974: PUSH
97975: LD_INT 0
97977: ST_TO_ADDR
// sTeleport := false ;
97978: LD_ADDR_EXP 160
97982: PUSH
97983: LD_INT 0
97985: ST_TO_ADDR
// sOilTower := false ;
97986: LD_ADDR_EXP 162
97990: PUSH
97991: LD_INT 0
97993: ST_TO_ADDR
// sShovel := false ;
97994: LD_ADDR_EXP 163
97998: PUSH
97999: LD_INT 0
98001: ST_TO_ADDR
// sSheik := false ;
98002: LD_ADDR_EXP 164
98006: PUSH
98007: LD_INT 0
98009: ST_TO_ADDR
// sEarthquake := false ;
98010: LD_ADDR_EXP 166
98014: PUSH
98015: LD_INT 0
98017: ST_TO_ADDR
// sAI := false ;
98018: LD_ADDR_EXP 167
98022: PUSH
98023: LD_INT 0
98025: ST_TO_ADDR
// sCargo := false ;
98026: LD_ADDR_EXP 170
98030: PUSH
98031: LD_INT 0
98033: ST_TO_ADDR
// sDLaser := false ;
98034: LD_ADDR_EXP 171
98038: PUSH
98039: LD_INT 0
98041: ST_TO_ADDR
// sExchange := false ;
98042: LD_ADDR_EXP 172
98046: PUSH
98047: LD_INT 0
98049: ST_TO_ADDR
// sFac := false ;
98050: LD_ADDR_EXP 173
98054: PUSH
98055: LD_INT 0
98057: ST_TO_ADDR
// sPower := false ;
98058: LD_ADDR_EXP 174
98062: PUSH
98063: LD_INT 0
98065: ST_TO_ADDR
// sRandom := false ;
98066: LD_ADDR_EXP 175
98070: PUSH
98071: LD_INT 0
98073: ST_TO_ADDR
// sShield := false ;
98074: LD_ADDR_EXP 176
98078: PUSH
98079: LD_INT 0
98081: ST_TO_ADDR
// sTime := false ;
98082: LD_ADDR_EXP 177
98086: PUSH
98087: LD_INT 0
98089: ST_TO_ADDR
// sTools := false ;
98090: LD_ADDR_EXP 178
98094: PUSH
98095: LD_INT 0
98097: ST_TO_ADDR
// sSold := false ;
98098: LD_ADDR_EXP 143
98102: PUSH
98103: LD_INT 0
98105: ST_TO_ADDR
// sDiff := false ;
98106: LD_ADDR_EXP 144
98110: PUSH
98111: LD_INT 0
98113: ST_TO_ADDR
// sFog := false ;
98114: LD_ADDR_EXP 147
98118: PUSH
98119: LD_INT 0
98121: ST_TO_ADDR
// sReset := false ;
98122: LD_ADDR_EXP 148
98126: PUSH
98127: LD_INT 0
98129: ST_TO_ADDR
// sSun := false ;
98130: LD_ADDR_EXP 149
98134: PUSH
98135: LD_INT 0
98137: ST_TO_ADDR
// sTiger := false ;
98138: LD_ADDR_EXP 145
98142: PUSH
98143: LD_INT 0
98145: ST_TO_ADDR
// sBomb := false ;
98146: LD_ADDR_EXP 146
98150: PUSH
98151: LD_INT 0
98153: ST_TO_ADDR
// sWound := false ;
98154: LD_ADDR_EXP 154
98158: PUSH
98159: LD_INT 0
98161: ST_TO_ADDR
// sBetray := false ;
98162: LD_ADDR_EXP 158
98166: PUSH
98167: LD_INT 0
98169: ST_TO_ADDR
// sContamin := false ;
98170: LD_ADDR_EXP 159
98174: PUSH
98175: LD_INT 0
98177: ST_TO_ADDR
// sOil := false ;
98178: LD_ADDR_EXP 161
98182: PUSH
98183: LD_INT 0
98185: ST_TO_ADDR
// sStu := false ;
98186: LD_ADDR_EXP 165
98190: PUSH
98191: LD_INT 0
98193: ST_TO_ADDR
// sBazooka := false ;
98194: LD_ADDR_EXP 168
98198: PUSH
98199: LD_INT 0
98201: ST_TO_ADDR
// sMortar := false ;
98202: LD_ADDR_EXP 169
98206: PUSH
98207: LD_INT 0
98209: ST_TO_ADDR
// sRanger := false ;
98210: LD_ADDR_EXP 179
98214: PUSH
98215: LD_INT 0
98217: ST_TO_ADDR
// sComputer := false ;
98218: LD_ADDR_EXP 180
98222: PUSH
98223: LD_INT 0
98225: ST_TO_ADDR
// s30 := false ;
98226: LD_ADDR_EXP 181
98230: PUSH
98231: LD_INT 0
98233: ST_TO_ADDR
// s60 := false ;
98234: LD_ADDR_EXP 182
98238: PUSH
98239: LD_INT 0
98241: ST_TO_ADDR
// end ;
98242: LD_VAR 0 1
98246: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
98247: LD_INT 0
98249: PPUSH
98250: PPUSH
98251: PPUSH
98252: PPUSH
98253: PPUSH
98254: PPUSH
98255: PPUSH
// result := [ ] ;
98256: LD_ADDR_VAR 0 2
98260: PUSH
98261: EMPTY
98262: ST_TO_ADDR
// if campaign_id = 1 then
98263: LD_OWVAR 69
98267: PUSH
98268: LD_INT 1
98270: EQUAL
98271: IFFALSE 101437
// begin case mission_number of 1 :
98273: LD_OWVAR 70
98277: PUSH
98278: LD_INT 1
98280: DOUBLE
98281: EQUAL
98282: IFTRUE 98286
98284: GO 98362
98286: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
98287: LD_ADDR_VAR 0 2
98291: PUSH
98292: LD_INT 2
98294: PUSH
98295: LD_INT 4
98297: PUSH
98298: LD_INT 11
98300: PUSH
98301: LD_INT 12
98303: PUSH
98304: LD_INT 15
98306: PUSH
98307: LD_INT 16
98309: PUSH
98310: LD_INT 22
98312: PUSH
98313: LD_INT 23
98315: PUSH
98316: LD_INT 26
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: PUSH
98330: LD_INT 101
98332: PUSH
98333: LD_INT 102
98335: PUSH
98336: LD_INT 106
98338: PUSH
98339: LD_INT 116
98341: PUSH
98342: LD_INT 117
98344: PUSH
98345: LD_INT 118
98347: PUSH
98348: EMPTY
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: PUSH
98356: EMPTY
98357: LIST
98358: LIST
98359: ST_TO_ADDR
98360: GO 101435
98362: LD_INT 2
98364: DOUBLE
98365: EQUAL
98366: IFTRUE 98370
98368: GO 98454
98370: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
98371: LD_ADDR_VAR 0 2
98375: PUSH
98376: LD_INT 2
98378: PUSH
98379: LD_INT 4
98381: PUSH
98382: LD_INT 11
98384: PUSH
98385: LD_INT 12
98387: PUSH
98388: LD_INT 15
98390: PUSH
98391: LD_INT 16
98393: PUSH
98394: LD_INT 22
98396: PUSH
98397: LD_INT 23
98399: PUSH
98400: LD_INT 26
98402: PUSH
98403: EMPTY
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: PUSH
98414: LD_INT 101
98416: PUSH
98417: LD_INT 102
98419: PUSH
98420: LD_INT 105
98422: PUSH
98423: LD_INT 106
98425: PUSH
98426: LD_INT 108
98428: PUSH
98429: LD_INT 116
98431: PUSH
98432: LD_INT 117
98434: PUSH
98435: LD_INT 118
98437: PUSH
98438: EMPTY
98439: LIST
98440: LIST
98441: LIST
98442: LIST
98443: LIST
98444: LIST
98445: LIST
98446: LIST
98447: PUSH
98448: EMPTY
98449: LIST
98450: LIST
98451: ST_TO_ADDR
98452: GO 101435
98454: LD_INT 3
98456: DOUBLE
98457: EQUAL
98458: IFTRUE 98462
98460: GO 98550
98462: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
98463: LD_ADDR_VAR 0 2
98467: PUSH
98468: LD_INT 2
98470: PUSH
98471: LD_INT 4
98473: PUSH
98474: LD_INT 5
98476: PUSH
98477: LD_INT 11
98479: PUSH
98480: LD_INT 12
98482: PUSH
98483: LD_INT 15
98485: PUSH
98486: LD_INT 16
98488: PUSH
98489: LD_INT 22
98491: PUSH
98492: LD_INT 26
98494: PUSH
98495: LD_INT 36
98497: PUSH
98498: EMPTY
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: PUSH
98510: LD_INT 101
98512: PUSH
98513: LD_INT 102
98515: PUSH
98516: LD_INT 105
98518: PUSH
98519: LD_INT 106
98521: PUSH
98522: LD_INT 108
98524: PUSH
98525: LD_INT 116
98527: PUSH
98528: LD_INT 117
98530: PUSH
98531: LD_INT 118
98533: PUSH
98534: EMPTY
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: LIST
98541: LIST
98542: LIST
98543: PUSH
98544: EMPTY
98545: LIST
98546: LIST
98547: ST_TO_ADDR
98548: GO 101435
98550: LD_INT 4
98552: DOUBLE
98553: EQUAL
98554: IFTRUE 98558
98556: GO 98654
98558: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
98559: LD_ADDR_VAR 0 2
98563: PUSH
98564: LD_INT 2
98566: PUSH
98567: LD_INT 4
98569: PUSH
98570: LD_INT 5
98572: PUSH
98573: LD_INT 8
98575: PUSH
98576: LD_INT 11
98578: PUSH
98579: LD_INT 12
98581: PUSH
98582: LD_INT 15
98584: PUSH
98585: LD_INT 16
98587: PUSH
98588: LD_INT 22
98590: PUSH
98591: LD_INT 23
98593: PUSH
98594: LD_INT 26
98596: PUSH
98597: LD_INT 36
98599: PUSH
98600: EMPTY
98601: LIST
98602: LIST
98603: LIST
98604: LIST
98605: LIST
98606: LIST
98607: LIST
98608: LIST
98609: LIST
98610: LIST
98611: LIST
98612: LIST
98613: PUSH
98614: LD_INT 101
98616: PUSH
98617: LD_INT 102
98619: PUSH
98620: LD_INT 105
98622: PUSH
98623: LD_INT 106
98625: PUSH
98626: LD_INT 108
98628: PUSH
98629: LD_INT 116
98631: PUSH
98632: LD_INT 117
98634: PUSH
98635: LD_INT 118
98637: PUSH
98638: EMPTY
98639: LIST
98640: LIST
98641: LIST
98642: LIST
98643: LIST
98644: LIST
98645: LIST
98646: LIST
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: ST_TO_ADDR
98652: GO 101435
98654: LD_INT 5
98656: DOUBLE
98657: EQUAL
98658: IFTRUE 98662
98660: GO 98774
98662: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
98663: LD_ADDR_VAR 0 2
98667: PUSH
98668: LD_INT 2
98670: PUSH
98671: LD_INT 4
98673: PUSH
98674: LD_INT 5
98676: PUSH
98677: LD_INT 6
98679: PUSH
98680: LD_INT 8
98682: PUSH
98683: LD_INT 11
98685: PUSH
98686: LD_INT 12
98688: PUSH
98689: LD_INT 15
98691: PUSH
98692: LD_INT 16
98694: PUSH
98695: LD_INT 22
98697: PUSH
98698: LD_INT 23
98700: PUSH
98701: LD_INT 25
98703: PUSH
98704: LD_INT 26
98706: PUSH
98707: LD_INT 36
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: LIST
98725: PUSH
98726: LD_INT 101
98728: PUSH
98729: LD_INT 102
98731: PUSH
98732: LD_INT 105
98734: PUSH
98735: LD_INT 106
98737: PUSH
98738: LD_INT 108
98740: PUSH
98741: LD_INT 109
98743: PUSH
98744: LD_INT 112
98746: PUSH
98747: LD_INT 116
98749: PUSH
98750: LD_INT 117
98752: PUSH
98753: LD_INT 118
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: LIST
98764: LIST
98765: LIST
98766: LIST
98767: PUSH
98768: EMPTY
98769: LIST
98770: LIST
98771: ST_TO_ADDR
98772: GO 101435
98774: LD_INT 6
98776: DOUBLE
98777: EQUAL
98778: IFTRUE 98782
98780: GO 98914
98782: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
98783: LD_ADDR_VAR 0 2
98787: PUSH
98788: LD_INT 2
98790: PUSH
98791: LD_INT 4
98793: PUSH
98794: LD_INT 5
98796: PUSH
98797: LD_INT 6
98799: PUSH
98800: LD_INT 8
98802: PUSH
98803: LD_INT 11
98805: PUSH
98806: LD_INT 12
98808: PUSH
98809: LD_INT 15
98811: PUSH
98812: LD_INT 16
98814: PUSH
98815: LD_INT 20
98817: PUSH
98818: LD_INT 21
98820: PUSH
98821: LD_INT 22
98823: PUSH
98824: LD_INT 23
98826: PUSH
98827: LD_INT 25
98829: PUSH
98830: LD_INT 26
98832: PUSH
98833: LD_INT 30
98835: PUSH
98836: LD_INT 31
98838: PUSH
98839: LD_INT 32
98841: PUSH
98842: LD_INT 36
98844: PUSH
98845: EMPTY
98846: LIST
98847: LIST
98848: LIST
98849: LIST
98850: LIST
98851: LIST
98852: LIST
98853: LIST
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: PUSH
98866: LD_INT 101
98868: PUSH
98869: LD_INT 102
98871: PUSH
98872: LD_INT 105
98874: PUSH
98875: LD_INT 106
98877: PUSH
98878: LD_INT 108
98880: PUSH
98881: LD_INT 109
98883: PUSH
98884: LD_INT 112
98886: PUSH
98887: LD_INT 116
98889: PUSH
98890: LD_INT 117
98892: PUSH
98893: LD_INT 118
98895: PUSH
98896: EMPTY
98897: LIST
98898: LIST
98899: LIST
98900: LIST
98901: LIST
98902: LIST
98903: LIST
98904: LIST
98905: LIST
98906: LIST
98907: PUSH
98908: EMPTY
98909: LIST
98910: LIST
98911: ST_TO_ADDR
98912: GO 101435
98914: LD_INT 7
98916: DOUBLE
98917: EQUAL
98918: IFTRUE 98922
98920: GO 99034
98922: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
98923: LD_ADDR_VAR 0 2
98927: PUSH
98928: LD_INT 2
98930: PUSH
98931: LD_INT 4
98933: PUSH
98934: LD_INT 5
98936: PUSH
98937: LD_INT 7
98939: PUSH
98940: LD_INT 11
98942: PUSH
98943: LD_INT 12
98945: PUSH
98946: LD_INT 15
98948: PUSH
98949: LD_INT 16
98951: PUSH
98952: LD_INT 20
98954: PUSH
98955: LD_INT 21
98957: PUSH
98958: LD_INT 22
98960: PUSH
98961: LD_INT 23
98963: PUSH
98964: LD_INT 25
98966: PUSH
98967: LD_INT 26
98969: PUSH
98970: EMPTY
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: PUSH
98986: LD_INT 101
98988: PUSH
98989: LD_INT 102
98991: PUSH
98992: LD_INT 103
98994: PUSH
98995: LD_INT 105
98997: PUSH
98998: LD_INT 106
99000: PUSH
99001: LD_INT 108
99003: PUSH
99004: LD_INT 112
99006: PUSH
99007: LD_INT 116
99009: PUSH
99010: LD_INT 117
99012: PUSH
99013: LD_INT 118
99015: PUSH
99016: EMPTY
99017: LIST
99018: LIST
99019: LIST
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: ST_TO_ADDR
99032: GO 101435
99034: LD_INT 8
99036: DOUBLE
99037: EQUAL
99038: IFTRUE 99042
99040: GO 99182
99042: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
99043: LD_ADDR_VAR 0 2
99047: PUSH
99048: LD_INT 2
99050: PUSH
99051: LD_INT 4
99053: PUSH
99054: LD_INT 5
99056: PUSH
99057: LD_INT 6
99059: PUSH
99060: LD_INT 7
99062: PUSH
99063: LD_INT 8
99065: PUSH
99066: LD_INT 11
99068: PUSH
99069: LD_INT 12
99071: PUSH
99072: LD_INT 15
99074: PUSH
99075: LD_INT 16
99077: PUSH
99078: LD_INT 20
99080: PUSH
99081: LD_INT 21
99083: PUSH
99084: LD_INT 22
99086: PUSH
99087: LD_INT 23
99089: PUSH
99090: LD_INT 25
99092: PUSH
99093: LD_INT 26
99095: PUSH
99096: LD_INT 30
99098: PUSH
99099: LD_INT 31
99101: PUSH
99102: LD_INT 32
99104: PUSH
99105: LD_INT 36
99107: PUSH
99108: EMPTY
99109: LIST
99110: LIST
99111: LIST
99112: LIST
99113: LIST
99114: LIST
99115: LIST
99116: LIST
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: PUSH
99130: LD_INT 101
99132: PUSH
99133: LD_INT 102
99135: PUSH
99136: LD_INT 103
99138: PUSH
99139: LD_INT 105
99141: PUSH
99142: LD_INT 106
99144: PUSH
99145: LD_INT 108
99147: PUSH
99148: LD_INT 109
99150: PUSH
99151: LD_INT 112
99153: PUSH
99154: LD_INT 116
99156: PUSH
99157: LD_INT 117
99159: PUSH
99160: LD_INT 118
99162: PUSH
99163: EMPTY
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: PUSH
99176: EMPTY
99177: LIST
99178: LIST
99179: ST_TO_ADDR
99180: GO 101435
99182: LD_INT 9
99184: DOUBLE
99185: EQUAL
99186: IFTRUE 99190
99188: GO 99338
99190: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
99191: LD_ADDR_VAR 0 2
99195: PUSH
99196: LD_INT 2
99198: PUSH
99199: LD_INT 4
99201: PUSH
99202: LD_INT 5
99204: PUSH
99205: LD_INT 6
99207: PUSH
99208: LD_INT 7
99210: PUSH
99211: LD_INT 8
99213: PUSH
99214: LD_INT 11
99216: PUSH
99217: LD_INT 12
99219: PUSH
99220: LD_INT 15
99222: PUSH
99223: LD_INT 16
99225: PUSH
99226: LD_INT 20
99228: PUSH
99229: LD_INT 21
99231: PUSH
99232: LD_INT 22
99234: PUSH
99235: LD_INT 23
99237: PUSH
99238: LD_INT 25
99240: PUSH
99241: LD_INT 26
99243: PUSH
99244: LD_INT 28
99246: PUSH
99247: LD_INT 30
99249: PUSH
99250: LD_INT 31
99252: PUSH
99253: LD_INT 32
99255: PUSH
99256: LD_INT 36
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: LIST
99277: LIST
99278: LIST
99279: LIST
99280: LIST
99281: PUSH
99282: LD_INT 101
99284: PUSH
99285: LD_INT 102
99287: PUSH
99288: LD_INT 103
99290: PUSH
99291: LD_INT 105
99293: PUSH
99294: LD_INT 106
99296: PUSH
99297: LD_INT 108
99299: PUSH
99300: LD_INT 109
99302: PUSH
99303: LD_INT 112
99305: PUSH
99306: LD_INT 114
99308: PUSH
99309: LD_INT 116
99311: PUSH
99312: LD_INT 117
99314: PUSH
99315: LD_INT 118
99317: PUSH
99318: EMPTY
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: PUSH
99332: EMPTY
99333: LIST
99334: LIST
99335: ST_TO_ADDR
99336: GO 101435
99338: LD_INT 10
99340: DOUBLE
99341: EQUAL
99342: IFTRUE 99346
99344: GO 99542
99346: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
99347: LD_ADDR_VAR 0 2
99351: PUSH
99352: LD_INT 2
99354: PUSH
99355: LD_INT 4
99357: PUSH
99358: LD_INT 5
99360: PUSH
99361: LD_INT 6
99363: PUSH
99364: LD_INT 7
99366: PUSH
99367: LD_INT 8
99369: PUSH
99370: LD_INT 9
99372: PUSH
99373: LD_INT 10
99375: PUSH
99376: LD_INT 11
99378: PUSH
99379: LD_INT 12
99381: PUSH
99382: LD_INT 13
99384: PUSH
99385: LD_INT 14
99387: PUSH
99388: LD_INT 15
99390: PUSH
99391: LD_INT 16
99393: PUSH
99394: LD_INT 17
99396: PUSH
99397: LD_INT 18
99399: PUSH
99400: LD_INT 19
99402: PUSH
99403: LD_INT 20
99405: PUSH
99406: LD_INT 21
99408: PUSH
99409: LD_INT 22
99411: PUSH
99412: LD_INT 23
99414: PUSH
99415: LD_INT 24
99417: PUSH
99418: LD_INT 25
99420: PUSH
99421: LD_INT 26
99423: PUSH
99424: LD_INT 28
99426: PUSH
99427: LD_INT 30
99429: PUSH
99430: LD_INT 31
99432: PUSH
99433: LD_INT 32
99435: PUSH
99436: LD_INT 36
99438: PUSH
99439: EMPTY
99440: LIST
99441: LIST
99442: LIST
99443: LIST
99444: LIST
99445: LIST
99446: LIST
99447: LIST
99448: LIST
99449: LIST
99450: LIST
99451: LIST
99452: LIST
99453: LIST
99454: LIST
99455: LIST
99456: LIST
99457: LIST
99458: LIST
99459: LIST
99460: LIST
99461: LIST
99462: LIST
99463: LIST
99464: LIST
99465: LIST
99466: LIST
99467: LIST
99468: LIST
99469: PUSH
99470: LD_INT 101
99472: PUSH
99473: LD_INT 102
99475: PUSH
99476: LD_INT 103
99478: PUSH
99479: LD_INT 104
99481: PUSH
99482: LD_INT 105
99484: PUSH
99485: LD_INT 106
99487: PUSH
99488: LD_INT 107
99490: PUSH
99491: LD_INT 108
99493: PUSH
99494: LD_INT 109
99496: PUSH
99497: LD_INT 110
99499: PUSH
99500: LD_INT 111
99502: PUSH
99503: LD_INT 112
99505: PUSH
99506: LD_INT 114
99508: PUSH
99509: LD_INT 116
99511: PUSH
99512: LD_INT 117
99514: PUSH
99515: LD_INT 118
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: PUSH
99536: EMPTY
99537: LIST
99538: LIST
99539: ST_TO_ADDR
99540: GO 101435
99542: LD_INT 11
99544: DOUBLE
99545: EQUAL
99546: IFTRUE 99550
99548: GO 99754
99550: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
99551: LD_ADDR_VAR 0 2
99555: PUSH
99556: LD_INT 2
99558: PUSH
99559: LD_INT 3
99561: PUSH
99562: LD_INT 4
99564: PUSH
99565: LD_INT 5
99567: PUSH
99568: LD_INT 6
99570: PUSH
99571: LD_INT 7
99573: PUSH
99574: LD_INT 8
99576: PUSH
99577: LD_INT 9
99579: PUSH
99580: LD_INT 10
99582: PUSH
99583: LD_INT 11
99585: PUSH
99586: LD_INT 12
99588: PUSH
99589: LD_INT 13
99591: PUSH
99592: LD_INT 14
99594: PUSH
99595: LD_INT 15
99597: PUSH
99598: LD_INT 16
99600: PUSH
99601: LD_INT 17
99603: PUSH
99604: LD_INT 18
99606: PUSH
99607: LD_INT 19
99609: PUSH
99610: LD_INT 20
99612: PUSH
99613: LD_INT 21
99615: PUSH
99616: LD_INT 22
99618: PUSH
99619: LD_INT 23
99621: PUSH
99622: LD_INT 24
99624: PUSH
99625: LD_INT 25
99627: PUSH
99628: LD_INT 26
99630: PUSH
99631: LD_INT 28
99633: PUSH
99634: LD_INT 30
99636: PUSH
99637: LD_INT 31
99639: PUSH
99640: LD_INT 32
99642: PUSH
99643: LD_INT 34
99645: PUSH
99646: LD_INT 36
99648: PUSH
99649: EMPTY
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: LIST
99678: LIST
99679: LIST
99680: LIST
99681: PUSH
99682: LD_INT 101
99684: PUSH
99685: LD_INT 102
99687: PUSH
99688: LD_INT 103
99690: PUSH
99691: LD_INT 104
99693: PUSH
99694: LD_INT 105
99696: PUSH
99697: LD_INT 106
99699: PUSH
99700: LD_INT 107
99702: PUSH
99703: LD_INT 108
99705: PUSH
99706: LD_INT 109
99708: PUSH
99709: LD_INT 110
99711: PUSH
99712: LD_INT 111
99714: PUSH
99715: LD_INT 112
99717: PUSH
99718: LD_INT 114
99720: PUSH
99721: LD_INT 116
99723: PUSH
99724: LD_INT 117
99726: PUSH
99727: LD_INT 118
99729: PUSH
99730: EMPTY
99731: LIST
99732: LIST
99733: LIST
99734: LIST
99735: LIST
99736: LIST
99737: LIST
99738: LIST
99739: LIST
99740: LIST
99741: LIST
99742: LIST
99743: LIST
99744: LIST
99745: LIST
99746: LIST
99747: PUSH
99748: EMPTY
99749: LIST
99750: LIST
99751: ST_TO_ADDR
99752: GO 101435
99754: LD_INT 12
99756: DOUBLE
99757: EQUAL
99758: IFTRUE 99762
99760: GO 99982
99762: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
99763: LD_ADDR_VAR 0 2
99767: PUSH
99768: LD_INT 1
99770: PUSH
99771: LD_INT 2
99773: PUSH
99774: LD_INT 3
99776: PUSH
99777: LD_INT 4
99779: PUSH
99780: LD_INT 5
99782: PUSH
99783: LD_INT 6
99785: PUSH
99786: LD_INT 7
99788: PUSH
99789: LD_INT 8
99791: PUSH
99792: LD_INT 9
99794: PUSH
99795: LD_INT 10
99797: PUSH
99798: LD_INT 11
99800: PUSH
99801: LD_INT 12
99803: PUSH
99804: LD_INT 13
99806: PUSH
99807: LD_INT 14
99809: PUSH
99810: LD_INT 15
99812: PUSH
99813: LD_INT 16
99815: PUSH
99816: LD_INT 17
99818: PUSH
99819: LD_INT 18
99821: PUSH
99822: LD_INT 19
99824: PUSH
99825: LD_INT 20
99827: PUSH
99828: LD_INT 21
99830: PUSH
99831: LD_INT 22
99833: PUSH
99834: LD_INT 23
99836: PUSH
99837: LD_INT 24
99839: PUSH
99840: LD_INT 25
99842: PUSH
99843: LD_INT 26
99845: PUSH
99846: LD_INT 27
99848: PUSH
99849: LD_INT 28
99851: PUSH
99852: LD_INT 30
99854: PUSH
99855: LD_INT 31
99857: PUSH
99858: LD_INT 32
99860: PUSH
99861: LD_INT 33
99863: PUSH
99864: LD_INT 34
99866: PUSH
99867: LD_INT 36
99869: PUSH
99870: EMPTY
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: LIST
99883: LIST
99884: LIST
99885: LIST
99886: LIST
99887: LIST
99888: LIST
99889: LIST
99890: LIST
99891: LIST
99892: LIST
99893: LIST
99894: LIST
99895: LIST
99896: LIST
99897: LIST
99898: LIST
99899: LIST
99900: LIST
99901: LIST
99902: LIST
99903: LIST
99904: LIST
99905: PUSH
99906: LD_INT 101
99908: PUSH
99909: LD_INT 102
99911: PUSH
99912: LD_INT 103
99914: PUSH
99915: LD_INT 104
99917: PUSH
99918: LD_INT 105
99920: PUSH
99921: LD_INT 106
99923: PUSH
99924: LD_INT 107
99926: PUSH
99927: LD_INT 108
99929: PUSH
99930: LD_INT 109
99932: PUSH
99933: LD_INT 110
99935: PUSH
99936: LD_INT 111
99938: PUSH
99939: LD_INT 112
99941: PUSH
99942: LD_INT 113
99944: PUSH
99945: LD_INT 114
99947: PUSH
99948: LD_INT 116
99950: PUSH
99951: LD_INT 117
99953: PUSH
99954: LD_INT 118
99956: PUSH
99957: EMPTY
99958: LIST
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: LIST
99964: LIST
99965: LIST
99966: LIST
99967: LIST
99968: LIST
99969: LIST
99970: LIST
99971: LIST
99972: LIST
99973: LIST
99974: LIST
99975: PUSH
99976: EMPTY
99977: LIST
99978: LIST
99979: ST_TO_ADDR
99980: GO 101435
99982: LD_INT 13
99984: DOUBLE
99985: EQUAL
99986: IFTRUE 99990
99988: GO 100198
99990: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
99991: LD_ADDR_VAR 0 2
99995: PUSH
99996: LD_INT 1
99998: PUSH
99999: LD_INT 2
100001: PUSH
100002: LD_INT 3
100004: PUSH
100005: LD_INT 4
100007: PUSH
100008: LD_INT 5
100010: PUSH
100011: LD_INT 8
100013: PUSH
100014: LD_INT 9
100016: PUSH
100017: LD_INT 10
100019: PUSH
100020: LD_INT 11
100022: PUSH
100023: LD_INT 12
100025: PUSH
100026: LD_INT 14
100028: PUSH
100029: LD_INT 15
100031: PUSH
100032: LD_INT 16
100034: PUSH
100035: LD_INT 17
100037: PUSH
100038: LD_INT 18
100040: PUSH
100041: LD_INT 19
100043: PUSH
100044: LD_INT 20
100046: PUSH
100047: LD_INT 21
100049: PUSH
100050: LD_INT 22
100052: PUSH
100053: LD_INT 23
100055: PUSH
100056: LD_INT 24
100058: PUSH
100059: LD_INT 25
100061: PUSH
100062: LD_INT 26
100064: PUSH
100065: LD_INT 27
100067: PUSH
100068: LD_INT 28
100070: PUSH
100071: LD_INT 30
100073: PUSH
100074: LD_INT 31
100076: PUSH
100077: LD_INT 32
100079: PUSH
100080: LD_INT 33
100082: PUSH
100083: LD_INT 34
100085: PUSH
100086: LD_INT 36
100088: PUSH
100089: EMPTY
100090: LIST
100091: LIST
100092: LIST
100093: LIST
100094: LIST
100095: LIST
100096: LIST
100097: LIST
100098: LIST
100099: LIST
100100: LIST
100101: LIST
100102: LIST
100103: LIST
100104: LIST
100105: LIST
100106: LIST
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: LIST
100112: LIST
100113: LIST
100114: LIST
100115: LIST
100116: LIST
100117: LIST
100118: LIST
100119: LIST
100120: LIST
100121: PUSH
100122: LD_INT 101
100124: PUSH
100125: LD_INT 102
100127: PUSH
100128: LD_INT 103
100130: PUSH
100131: LD_INT 104
100133: PUSH
100134: LD_INT 105
100136: PUSH
100137: LD_INT 106
100139: PUSH
100140: LD_INT 107
100142: PUSH
100143: LD_INT 108
100145: PUSH
100146: LD_INT 109
100148: PUSH
100149: LD_INT 110
100151: PUSH
100152: LD_INT 111
100154: PUSH
100155: LD_INT 112
100157: PUSH
100158: LD_INT 113
100160: PUSH
100161: LD_INT 114
100163: PUSH
100164: LD_INT 116
100166: PUSH
100167: LD_INT 117
100169: PUSH
100170: LD_INT 118
100172: PUSH
100173: EMPTY
100174: LIST
100175: LIST
100176: LIST
100177: LIST
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: LIST
100183: LIST
100184: LIST
100185: LIST
100186: LIST
100187: LIST
100188: LIST
100189: LIST
100190: LIST
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: ST_TO_ADDR
100196: GO 101435
100198: LD_INT 14
100200: DOUBLE
100201: EQUAL
100202: IFTRUE 100206
100204: GO 100430
100206: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
100207: LD_ADDR_VAR 0 2
100211: PUSH
100212: LD_INT 1
100214: PUSH
100215: LD_INT 2
100217: PUSH
100218: LD_INT 3
100220: PUSH
100221: LD_INT 4
100223: PUSH
100224: LD_INT 5
100226: PUSH
100227: LD_INT 6
100229: PUSH
100230: LD_INT 7
100232: PUSH
100233: LD_INT 8
100235: PUSH
100236: LD_INT 9
100238: PUSH
100239: LD_INT 10
100241: PUSH
100242: LD_INT 11
100244: PUSH
100245: LD_INT 12
100247: PUSH
100248: LD_INT 13
100250: PUSH
100251: LD_INT 14
100253: PUSH
100254: LD_INT 15
100256: PUSH
100257: LD_INT 16
100259: PUSH
100260: LD_INT 17
100262: PUSH
100263: LD_INT 18
100265: PUSH
100266: LD_INT 19
100268: PUSH
100269: LD_INT 20
100271: PUSH
100272: LD_INT 21
100274: PUSH
100275: LD_INT 22
100277: PUSH
100278: LD_INT 23
100280: PUSH
100281: LD_INT 24
100283: PUSH
100284: LD_INT 25
100286: PUSH
100287: LD_INT 26
100289: PUSH
100290: LD_INT 27
100292: PUSH
100293: LD_INT 28
100295: PUSH
100296: LD_INT 29
100298: PUSH
100299: LD_INT 30
100301: PUSH
100302: LD_INT 31
100304: PUSH
100305: LD_INT 32
100307: PUSH
100308: LD_INT 33
100310: PUSH
100311: LD_INT 34
100313: PUSH
100314: LD_INT 36
100316: PUSH
100317: EMPTY
100318: LIST
100319: LIST
100320: LIST
100321: LIST
100322: LIST
100323: LIST
100324: LIST
100325: LIST
100326: LIST
100327: LIST
100328: LIST
100329: LIST
100330: LIST
100331: LIST
100332: LIST
100333: LIST
100334: LIST
100335: LIST
100336: LIST
100337: LIST
100338: LIST
100339: LIST
100340: LIST
100341: LIST
100342: LIST
100343: LIST
100344: LIST
100345: LIST
100346: LIST
100347: LIST
100348: LIST
100349: LIST
100350: LIST
100351: LIST
100352: LIST
100353: PUSH
100354: LD_INT 101
100356: PUSH
100357: LD_INT 102
100359: PUSH
100360: LD_INT 103
100362: PUSH
100363: LD_INT 104
100365: PUSH
100366: LD_INT 105
100368: PUSH
100369: LD_INT 106
100371: PUSH
100372: LD_INT 107
100374: PUSH
100375: LD_INT 108
100377: PUSH
100378: LD_INT 109
100380: PUSH
100381: LD_INT 110
100383: PUSH
100384: LD_INT 111
100386: PUSH
100387: LD_INT 112
100389: PUSH
100390: LD_INT 113
100392: PUSH
100393: LD_INT 114
100395: PUSH
100396: LD_INT 116
100398: PUSH
100399: LD_INT 117
100401: PUSH
100402: LD_INT 118
100404: PUSH
100405: EMPTY
100406: LIST
100407: LIST
100408: LIST
100409: LIST
100410: LIST
100411: LIST
100412: LIST
100413: LIST
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: LIST
100419: LIST
100420: LIST
100421: LIST
100422: LIST
100423: PUSH
100424: EMPTY
100425: LIST
100426: LIST
100427: ST_TO_ADDR
100428: GO 101435
100430: LD_INT 15
100432: DOUBLE
100433: EQUAL
100434: IFTRUE 100438
100436: GO 100662
100438: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
100439: LD_ADDR_VAR 0 2
100443: PUSH
100444: LD_INT 1
100446: PUSH
100447: LD_INT 2
100449: PUSH
100450: LD_INT 3
100452: PUSH
100453: LD_INT 4
100455: PUSH
100456: LD_INT 5
100458: PUSH
100459: LD_INT 6
100461: PUSH
100462: LD_INT 7
100464: PUSH
100465: LD_INT 8
100467: PUSH
100468: LD_INT 9
100470: PUSH
100471: LD_INT 10
100473: PUSH
100474: LD_INT 11
100476: PUSH
100477: LD_INT 12
100479: PUSH
100480: LD_INT 13
100482: PUSH
100483: LD_INT 14
100485: PUSH
100486: LD_INT 15
100488: PUSH
100489: LD_INT 16
100491: PUSH
100492: LD_INT 17
100494: PUSH
100495: LD_INT 18
100497: PUSH
100498: LD_INT 19
100500: PUSH
100501: LD_INT 20
100503: PUSH
100504: LD_INT 21
100506: PUSH
100507: LD_INT 22
100509: PUSH
100510: LD_INT 23
100512: PUSH
100513: LD_INT 24
100515: PUSH
100516: LD_INT 25
100518: PUSH
100519: LD_INT 26
100521: PUSH
100522: LD_INT 27
100524: PUSH
100525: LD_INT 28
100527: PUSH
100528: LD_INT 29
100530: PUSH
100531: LD_INT 30
100533: PUSH
100534: LD_INT 31
100536: PUSH
100537: LD_INT 32
100539: PUSH
100540: LD_INT 33
100542: PUSH
100543: LD_INT 34
100545: PUSH
100546: LD_INT 36
100548: PUSH
100549: EMPTY
100550: LIST
100551: LIST
100552: LIST
100553: LIST
100554: LIST
100555: LIST
100556: LIST
100557: LIST
100558: LIST
100559: LIST
100560: LIST
100561: LIST
100562: LIST
100563: LIST
100564: LIST
100565: LIST
100566: LIST
100567: LIST
100568: LIST
100569: LIST
100570: LIST
100571: LIST
100572: LIST
100573: LIST
100574: LIST
100575: LIST
100576: LIST
100577: LIST
100578: LIST
100579: LIST
100580: LIST
100581: LIST
100582: LIST
100583: LIST
100584: LIST
100585: PUSH
100586: LD_INT 101
100588: PUSH
100589: LD_INT 102
100591: PUSH
100592: LD_INT 103
100594: PUSH
100595: LD_INT 104
100597: PUSH
100598: LD_INT 105
100600: PUSH
100601: LD_INT 106
100603: PUSH
100604: LD_INT 107
100606: PUSH
100607: LD_INT 108
100609: PUSH
100610: LD_INT 109
100612: PUSH
100613: LD_INT 110
100615: PUSH
100616: LD_INT 111
100618: PUSH
100619: LD_INT 112
100621: PUSH
100622: LD_INT 113
100624: PUSH
100625: LD_INT 114
100627: PUSH
100628: LD_INT 116
100630: PUSH
100631: LD_INT 117
100633: PUSH
100634: LD_INT 118
100636: PUSH
100637: EMPTY
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: LIST
100644: LIST
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: LIST
100655: PUSH
100656: EMPTY
100657: LIST
100658: LIST
100659: ST_TO_ADDR
100660: GO 101435
100662: LD_INT 16
100664: DOUBLE
100665: EQUAL
100666: IFTRUE 100670
100668: GO 100806
100670: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
100671: LD_ADDR_VAR 0 2
100675: PUSH
100676: LD_INT 2
100678: PUSH
100679: LD_INT 4
100681: PUSH
100682: LD_INT 5
100684: PUSH
100685: LD_INT 7
100687: PUSH
100688: LD_INT 11
100690: PUSH
100691: LD_INT 12
100693: PUSH
100694: LD_INT 15
100696: PUSH
100697: LD_INT 16
100699: PUSH
100700: LD_INT 20
100702: PUSH
100703: LD_INT 21
100705: PUSH
100706: LD_INT 22
100708: PUSH
100709: LD_INT 23
100711: PUSH
100712: LD_INT 25
100714: PUSH
100715: LD_INT 26
100717: PUSH
100718: LD_INT 30
100720: PUSH
100721: LD_INT 31
100723: PUSH
100724: LD_INT 32
100726: PUSH
100727: LD_INT 33
100729: PUSH
100730: LD_INT 34
100732: PUSH
100733: EMPTY
100734: LIST
100735: LIST
100736: LIST
100737: LIST
100738: LIST
100739: LIST
100740: LIST
100741: LIST
100742: LIST
100743: LIST
100744: LIST
100745: LIST
100746: LIST
100747: LIST
100748: LIST
100749: LIST
100750: LIST
100751: LIST
100752: LIST
100753: PUSH
100754: LD_INT 101
100756: PUSH
100757: LD_INT 102
100759: PUSH
100760: LD_INT 103
100762: PUSH
100763: LD_INT 106
100765: PUSH
100766: LD_INT 108
100768: PUSH
100769: LD_INT 112
100771: PUSH
100772: LD_INT 113
100774: PUSH
100775: LD_INT 114
100777: PUSH
100778: LD_INT 116
100780: PUSH
100781: LD_INT 117
100783: PUSH
100784: LD_INT 118
100786: PUSH
100787: EMPTY
100788: LIST
100789: LIST
100790: LIST
100791: LIST
100792: LIST
100793: LIST
100794: LIST
100795: LIST
100796: LIST
100797: LIST
100798: LIST
100799: PUSH
100800: EMPTY
100801: LIST
100802: LIST
100803: ST_TO_ADDR
100804: GO 101435
100806: LD_INT 17
100808: DOUBLE
100809: EQUAL
100810: IFTRUE 100814
100812: GO 101038
100814: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
100815: LD_ADDR_VAR 0 2
100819: PUSH
100820: LD_INT 1
100822: PUSH
100823: LD_INT 2
100825: PUSH
100826: LD_INT 3
100828: PUSH
100829: LD_INT 4
100831: PUSH
100832: LD_INT 5
100834: PUSH
100835: LD_INT 6
100837: PUSH
100838: LD_INT 7
100840: PUSH
100841: LD_INT 8
100843: PUSH
100844: LD_INT 9
100846: PUSH
100847: LD_INT 10
100849: PUSH
100850: LD_INT 11
100852: PUSH
100853: LD_INT 12
100855: PUSH
100856: LD_INT 13
100858: PUSH
100859: LD_INT 14
100861: PUSH
100862: LD_INT 15
100864: PUSH
100865: LD_INT 16
100867: PUSH
100868: LD_INT 17
100870: PUSH
100871: LD_INT 18
100873: PUSH
100874: LD_INT 19
100876: PUSH
100877: LD_INT 20
100879: PUSH
100880: LD_INT 21
100882: PUSH
100883: LD_INT 22
100885: PUSH
100886: LD_INT 23
100888: PUSH
100889: LD_INT 24
100891: PUSH
100892: LD_INT 25
100894: PUSH
100895: LD_INT 26
100897: PUSH
100898: LD_INT 27
100900: PUSH
100901: LD_INT 28
100903: PUSH
100904: LD_INT 29
100906: PUSH
100907: LD_INT 30
100909: PUSH
100910: LD_INT 31
100912: PUSH
100913: LD_INT 32
100915: PUSH
100916: LD_INT 33
100918: PUSH
100919: LD_INT 34
100921: PUSH
100922: LD_INT 36
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: LIST
100929: LIST
100930: LIST
100931: LIST
100932: LIST
100933: LIST
100934: LIST
100935: LIST
100936: LIST
100937: LIST
100938: LIST
100939: LIST
100940: LIST
100941: LIST
100942: LIST
100943: LIST
100944: LIST
100945: LIST
100946: LIST
100947: LIST
100948: LIST
100949: LIST
100950: LIST
100951: LIST
100952: LIST
100953: LIST
100954: LIST
100955: LIST
100956: LIST
100957: LIST
100958: LIST
100959: LIST
100960: LIST
100961: PUSH
100962: LD_INT 101
100964: PUSH
100965: LD_INT 102
100967: PUSH
100968: LD_INT 103
100970: PUSH
100971: LD_INT 104
100973: PUSH
100974: LD_INT 105
100976: PUSH
100977: LD_INT 106
100979: PUSH
100980: LD_INT 107
100982: PUSH
100983: LD_INT 108
100985: PUSH
100986: LD_INT 109
100988: PUSH
100989: LD_INT 110
100991: PUSH
100992: LD_INT 111
100994: PUSH
100995: LD_INT 112
100997: PUSH
100998: LD_INT 113
101000: PUSH
101001: LD_INT 114
101003: PUSH
101004: LD_INT 116
101006: PUSH
101007: LD_INT 117
101009: PUSH
101010: LD_INT 118
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: LIST
101017: LIST
101018: LIST
101019: LIST
101020: LIST
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: LIST
101026: LIST
101027: LIST
101028: LIST
101029: LIST
101030: LIST
101031: PUSH
101032: EMPTY
101033: LIST
101034: LIST
101035: ST_TO_ADDR
101036: GO 101435
101038: LD_INT 18
101040: DOUBLE
101041: EQUAL
101042: IFTRUE 101046
101044: GO 101194
101046: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
101047: LD_ADDR_VAR 0 2
101051: PUSH
101052: LD_INT 2
101054: PUSH
101055: LD_INT 4
101057: PUSH
101058: LD_INT 5
101060: PUSH
101061: LD_INT 7
101063: PUSH
101064: LD_INT 11
101066: PUSH
101067: LD_INT 12
101069: PUSH
101070: LD_INT 15
101072: PUSH
101073: LD_INT 16
101075: PUSH
101076: LD_INT 20
101078: PUSH
101079: LD_INT 21
101081: PUSH
101082: LD_INT 22
101084: PUSH
101085: LD_INT 23
101087: PUSH
101088: LD_INT 25
101090: PUSH
101091: LD_INT 26
101093: PUSH
101094: LD_INT 30
101096: PUSH
101097: LD_INT 31
101099: PUSH
101100: LD_INT 32
101102: PUSH
101103: LD_INT 33
101105: PUSH
101106: LD_INT 34
101108: PUSH
101109: LD_INT 35
101111: PUSH
101112: LD_INT 36
101114: PUSH
101115: EMPTY
101116: LIST
101117: LIST
101118: LIST
101119: LIST
101120: LIST
101121: LIST
101122: LIST
101123: LIST
101124: LIST
101125: LIST
101126: LIST
101127: LIST
101128: LIST
101129: LIST
101130: LIST
101131: LIST
101132: LIST
101133: LIST
101134: LIST
101135: LIST
101136: LIST
101137: PUSH
101138: LD_INT 101
101140: PUSH
101141: LD_INT 102
101143: PUSH
101144: LD_INT 103
101146: PUSH
101147: LD_INT 106
101149: PUSH
101150: LD_INT 108
101152: PUSH
101153: LD_INT 112
101155: PUSH
101156: LD_INT 113
101158: PUSH
101159: LD_INT 114
101161: PUSH
101162: LD_INT 115
101164: PUSH
101165: LD_INT 116
101167: PUSH
101168: LD_INT 117
101170: PUSH
101171: LD_INT 118
101173: PUSH
101174: EMPTY
101175: LIST
101176: LIST
101177: LIST
101178: LIST
101179: LIST
101180: LIST
101181: LIST
101182: LIST
101183: LIST
101184: LIST
101185: LIST
101186: LIST
101187: PUSH
101188: EMPTY
101189: LIST
101190: LIST
101191: ST_TO_ADDR
101192: GO 101435
101194: LD_INT 19
101196: DOUBLE
101197: EQUAL
101198: IFTRUE 101202
101200: GO 101434
101202: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
101203: LD_ADDR_VAR 0 2
101207: PUSH
101208: LD_INT 1
101210: PUSH
101211: LD_INT 2
101213: PUSH
101214: LD_INT 3
101216: PUSH
101217: LD_INT 4
101219: PUSH
101220: LD_INT 5
101222: PUSH
101223: LD_INT 6
101225: PUSH
101226: LD_INT 7
101228: PUSH
101229: LD_INT 8
101231: PUSH
101232: LD_INT 9
101234: PUSH
101235: LD_INT 10
101237: PUSH
101238: LD_INT 11
101240: PUSH
101241: LD_INT 12
101243: PUSH
101244: LD_INT 13
101246: PUSH
101247: LD_INT 14
101249: PUSH
101250: LD_INT 15
101252: PUSH
101253: LD_INT 16
101255: PUSH
101256: LD_INT 17
101258: PUSH
101259: LD_INT 18
101261: PUSH
101262: LD_INT 19
101264: PUSH
101265: LD_INT 20
101267: PUSH
101268: LD_INT 21
101270: PUSH
101271: LD_INT 22
101273: PUSH
101274: LD_INT 23
101276: PUSH
101277: LD_INT 24
101279: PUSH
101280: LD_INT 25
101282: PUSH
101283: LD_INT 26
101285: PUSH
101286: LD_INT 27
101288: PUSH
101289: LD_INT 28
101291: PUSH
101292: LD_INT 29
101294: PUSH
101295: LD_INT 30
101297: PUSH
101298: LD_INT 31
101300: PUSH
101301: LD_INT 32
101303: PUSH
101304: LD_INT 33
101306: PUSH
101307: LD_INT 34
101309: PUSH
101310: LD_INT 35
101312: PUSH
101313: LD_INT 36
101315: PUSH
101316: EMPTY
101317: LIST
101318: LIST
101319: LIST
101320: LIST
101321: LIST
101322: LIST
101323: LIST
101324: LIST
101325: LIST
101326: LIST
101327: LIST
101328: LIST
101329: LIST
101330: LIST
101331: LIST
101332: LIST
101333: LIST
101334: LIST
101335: LIST
101336: LIST
101337: LIST
101338: LIST
101339: LIST
101340: LIST
101341: LIST
101342: LIST
101343: LIST
101344: LIST
101345: LIST
101346: LIST
101347: LIST
101348: LIST
101349: LIST
101350: LIST
101351: LIST
101352: LIST
101353: PUSH
101354: LD_INT 101
101356: PUSH
101357: LD_INT 102
101359: PUSH
101360: LD_INT 103
101362: PUSH
101363: LD_INT 104
101365: PUSH
101366: LD_INT 105
101368: PUSH
101369: LD_INT 106
101371: PUSH
101372: LD_INT 107
101374: PUSH
101375: LD_INT 108
101377: PUSH
101378: LD_INT 109
101380: PUSH
101381: LD_INT 110
101383: PUSH
101384: LD_INT 111
101386: PUSH
101387: LD_INT 112
101389: PUSH
101390: LD_INT 113
101392: PUSH
101393: LD_INT 114
101395: PUSH
101396: LD_INT 115
101398: PUSH
101399: LD_INT 116
101401: PUSH
101402: LD_INT 117
101404: PUSH
101405: LD_INT 118
101407: PUSH
101408: EMPTY
101409: LIST
101410: LIST
101411: LIST
101412: LIST
101413: LIST
101414: LIST
101415: LIST
101416: LIST
101417: LIST
101418: LIST
101419: LIST
101420: LIST
101421: LIST
101422: LIST
101423: LIST
101424: LIST
101425: LIST
101426: LIST
101427: PUSH
101428: EMPTY
101429: LIST
101430: LIST
101431: ST_TO_ADDR
101432: GO 101435
101434: POP
// end else
101435: GO 101666
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
101437: LD_ADDR_VAR 0 2
101441: PUSH
101442: LD_INT 1
101444: PUSH
101445: LD_INT 2
101447: PUSH
101448: LD_INT 3
101450: PUSH
101451: LD_INT 4
101453: PUSH
101454: LD_INT 5
101456: PUSH
101457: LD_INT 6
101459: PUSH
101460: LD_INT 7
101462: PUSH
101463: LD_INT 8
101465: PUSH
101466: LD_INT 9
101468: PUSH
101469: LD_INT 10
101471: PUSH
101472: LD_INT 11
101474: PUSH
101475: LD_INT 12
101477: PUSH
101478: LD_INT 13
101480: PUSH
101481: LD_INT 14
101483: PUSH
101484: LD_INT 15
101486: PUSH
101487: LD_INT 16
101489: PUSH
101490: LD_INT 17
101492: PUSH
101493: LD_INT 18
101495: PUSH
101496: LD_INT 19
101498: PUSH
101499: LD_INT 20
101501: PUSH
101502: LD_INT 21
101504: PUSH
101505: LD_INT 22
101507: PUSH
101508: LD_INT 23
101510: PUSH
101511: LD_INT 24
101513: PUSH
101514: LD_INT 25
101516: PUSH
101517: LD_INT 26
101519: PUSH
101520: LD_INT 27
101522: PUSH
101523: LD_INT 28
101525: PUSH
101526: LD_INT 29
101528: PUSH
101529: LD_INT 30
101531: PUSH
101532: LD_INT 31
101534: PUSH
101535: LD_INT 32
101537: PUSH
101538: LD_INT 33
101540: PUSH
101541: LD_INT 34
101543: PUSH
101544: LD_INT 35
101546: PUSH
101547: LD_INT 36
101549: PUSH
101550: EMPTY
101551: LIST
101552: LIST
101553: LIST
101554: LIST
101555: LIST
101556: LIST
101557: LIST
101558: LIST
101559: LIST
101560: LIST
101561: LIST
101562: LIST
101563: LIST
101564: LIST
101565: LIST
101566: LIST
101567: LIST
101568: LIST
101569: LIST
101570: LIST
101571: LIST
101572: LIST
101573: LIST
101574: LIST
101575: LIST
101576: LIST
101577: LIST
101578: LIST
101579: LIST
101580: LIST
101581: LIST
101582: LIST
101583: LIST
101584: LIST
101585: LIST
101586: LIST
101587: PUSH
101588: LD_INT 101
101590: PUSH
101591: LD_INT 102
101593: PUSH
101594: LD_INT 103
101596: PUSH
101597: LD_INT 104
101599: PUSH
101600: LD_INT 105
101602: PUSH
101603: LD_INT 106
101605: PUSH
101606: LD_INT 107
101608: PUSH
101609: LD_INT 108
101611: PUSH
101612: LD_INT 109
101614: PUSH
101615: LD_INT 110
101617: PUSH
101618: LD_INT 111
101620: PUSH
101621: LD_INT 112
101623: PUSH
101624: LD_INT 113
101626: PUSH
101627: LD_INT 114
101629: PUSH
101630: LD_INT 115
101632: PUSH
101633: LD_INT 116
101635: PUSH
101636: LD_INT 117
101638: PUSH
101639: LD_INT 118
101641: PUSH
101642: EMPTY
101643: LIST
101644: LIST
101645: LIST
101646: LIST
101647: LIST
101648: LIST
101649: LIST
101650: LIST
101651: LIST
101652: LIST
101653: LIST
101654: LIST
101655: LIST
101656: LIST
101657: LIST
101658: LIST
101659: LIST
101660: LIST
101661: PUSH
101662: EMPTY
101663: LIST
101664: LIST
101665: ST_TO_ADDR
// if result then
101666: LD_VAR 0 2
101670: IFFALSE 102456
// begin normal :=  ;
101672: LD_ADDR_VAR 0 5
101676: PUSH
101677: LD_STRING 
101679: ST_TO_ADDR
// hardcore :=  ;
101680: LD_ADDR_VAR 0 6
101684: PUSH
101685: LD_STRING 
101687: ST_TO_ADDR
// active :=  ;
101688: LD_ADDR_VAR 0 7
101692: PUSH
101693: LD_STRING 
101695: ST_TO_ADDR
// for i = 1 to normalCounter do
101696: LD_ADDR_VAR 0 8
101700: PUSH
101701: DOUBLE
101702: LD_INT 1
101704: DEC
101705: ST_TO_ADDR
101706: LD_EXP 127
101710: PUSH
101711: FOR_TO
101712: IFFALSE 101813
// begin tmp := 0 ;
101714: LD_ADDR_VAR 0 3
101718: PUSH
101719: LD_STRING 0
101721: ST_TO_ADDR
// if result [ 1 ] then
101722: LD_VAR 0 2
101726: PUSH
101727: LD_INT 1
101729: ARRAY
101730: IFFALSE 101795
// if result [ 1 ] [ 1 ] = i then
101732: LD_VAR 0 2
101736: PUSH
101737: LD_INT 1
101739: ARRAY
101740: PUSH
101741: LD_INT 1
101743: ARRAY
101744: PUSH
101745: LD_VAR 0 8
101749: EQUAL
101750: IFFALSE 101795
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
101752: LD_ADDR_VAR 0 2
101756: PUSH
101757: LD_VAR 0 2
101761: PPUSH
101762: LD_INT 1
101764: PPUSH
101765: LD_VAR 0 2
101769: PUSH
101770: LD_INT 1
101772: ARRAY
101773: PPUSH
101774: LD_INT 1
101776: PPUSH
101777: CALL_OW 3
101781: PPUSH
101782: CALL_OW 1
101786: ST_TO_ADDR
// tmp := 1 ;
101787: LD_ADDR_VAR 0 3
101791: PUSH
101792: LD_STRING 1
101794: ST_TO_ADDR
// end ; normal := normal & tmp ;
101795: LD_ADDR_VAR 0 5
101799: PUSH
101800: LD_VAR 0 5
101804: PUSH
101805: LD_VAR 0 3
101809: STR
101810: ST_TO_ADDR
// end ;
101811: GO 101711
101813: POP
101814: POP
// for i = 1 to hardcoreCounter do
101815: LD_ADDR_VAR 0 8
101819: PUSH
101820: DOUBLE
101821: LD_INT 1
101823: DEC
101824: ST_TO_ADDR
101825: LD_EXP 128
101829: PUSH
101830: FOR_TO
101831: IFFALSE 101936
// begin tmp := 0 ;
101833: LD_ADDR_VAR 0 3
101837: PUSH
101838: LD_STRING 0
101840: ST_TO_ADDR
// if result [ 2 ] then
101841: LD_VAR 0 2
101845: PUSH
101846: LD_INT 2
101848: ARRAY
101849: IFFALSE 101918
// if result [ 2 ] [ 1 ] = 100 + i then
101851: LD_VAR 0 2
101855: PUSH
101856: LD_INT 2
101858: ARRAY
101859: PUSH
101860: LD_INT 1
101862: ARRAY
101863: PUSH
101864: LD_INT 100
101866: PUSH
101867: LD_VAR 0 8
101871: PLUS
101872: EQUAL
101873: IFFALSE 101918
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
101875: LD_ADDR_VAR 0 2
101879: PUSH
101880: LD_VAR 0 2
101884: PPUSH
101885: LD_INT 2
101887: PPUSH
101888: LD_VAR 0 2
101892: PUSH
101893: LD_INT 2
101895: ARRAY
101896: PPUSH
101897: LD_INT 1
101899: PPUSH
101900: CALL_OW 3
101904: PPUSH
101905: CALL_OW 1
101909: ST_TO_ADDR
// tmp := 1 ;
101910: LD_ADDR_VAR 0 3
101914: PUSH
101915: LD_STRING 1
101917: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
101918: LD_ADDR_VAR 0 6
101922: PUSH
101923: LD_VAR 0 6
101927: PUSH
101928: LD_VAR 0 3
101932: STR
101933: ST_TO_ADDR
// end ;
101934: GO 101830
101936: POP
101937: POP
// if isGameLoad then
101938: LD_VAR 0 1
101942: IFFALSE 102417
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
101944: LD_ADDR_VAR 0 4
101948: PUSH
101949: LD_EXP 131
101953: PUSH
101954: LD_EXP 130
101958: PUSH
101959: LD_EXP 132
101963: PUSH
101964: LD_EXP 129
101968: PUSH
101969: LD_EXP 133
101973: PUSH
101974: LD_EXP 134
101978: PUSH
101979: LD_EXP 135
101983: PUSH
101984: LD_EXP 136
101988: PUSH
101989: LD_EXP 137
101993: PUSH
101994: LD_EXP 138
101998: PUSH
101999: LD_EXP 139
102003: PUSH
102004: LD_EXP 140
102008: PUSH
102009: LD_EXP 141
102013: PUSH
102014: LD_EXP 142
102018: PUSH
102019: LD_EXP 150
102023: PUSH
102024: LD_EXP 151
102028: PUSH
102029: LD_EXP 152
102033: PUSH
102034: LD_EXP 153
102038: PUSH
102039: LD_EXP 155
102043: PUSH
102044: LD_EXP 156
102048: PUSH
102049: LD_EXP 157
102053: PUSH
102054: LD_EXP 160
102058: PUSH
102059: LD_EXP 162
102063: PUSH
102064: LD_EXP 163
102068: PUSH
102069: LD_EXP 164
102073: PUSH
102074: LD_EXP 166
102078: PUSH
102079: LD_EXP 167
102083: PUSH
102084: LD_EXP 170
102088: PUSH
102089: LD_EXP 171
102093: PUSH
102094: LD_EXP 172
102098: PUSH
102099: LD_EXP 173
102103: PUSH
102104: LD_EXP 174
102108: PUSH
102109: LD_EXP 175
102113: PUSH
102114: LD_EXP 176
102118: PUSH
102119: LD_EXP 177
102123: PUSH
102124: LD_EXP 178
102128: PUSH
102129: LD_EXP 143
102133: PUSH
102134: LD_EXP 144
102138: PUSH
102139: LD_EXP 147
102143: PUSH
102144: LD_EXP 148
102148: PUSH
102149: LD_EXP 149
102153: PUSH
102154: LD_EXP 145
102158: PUSH
102159: LD_EXP 146
102163: PUSH
102164: LD_EXP 154
102168: PUSH
102169: LD_EXP 158
102173: PUSH
102174: LD_EXP 159
102178: PUSH
102179: LD_EXP 161
102183: PUSH
102184: LD_EXP 165
102188: PUSH
102189: LD_EXP 168
102193: PUSH
102194: LD_EXP 169
102198: PUSH
102199: LD_EXP 179
102203: PUSH
102204: LD_EXP 180
102208: PUSH
102209: LD_EXP 181
102213: PUSH
102214: LD_EXP 182
102218: PUSH
102219: EMPTY
102220: LIST
102221: LIST
102222: LIST
102223: LIST
102224: LIST
102225: LIST
102226: LIST
102227: LIST
102228: LIST
102229: LIST
102230: LIST
102231: LIST
102232: LIST
102233: LIST
102234: LIST
102235: LIST
102236: LIST
102237: LIST
102238: LIST
102239: LIST
102240: LIST
102241: LIST
102242: LIST
102243: LIST
102244: LIST
102245: LIST
102246: LIST
102247: LIST
102248: LIST
102249: LIST
102250: LIST
102251: LIST
102252: LIST
102253: LIST
102254: LIST
102255: LIST
102256: LIST
102257: LIST
102258: LIST
102259: LIST
102260: LIST
102261: LIST
102262: LIST
102263: LIST
102264: LIST
102265: LIST
102266: LIST
102267: LIST
102268: LIST
102269: LIST
102270: LIST
102271: LIST
102272: LIST
102273: LIST
102274: ST_TO_ADDR
// tmp :=  ;
102275: LD_ADDR_VAR 0 3
102279: PUSH
102280: LD_STRING 
102282: ST_TO_ADDR
// for i = 1 to normalCounter do
102283: LD_ADDR_VAR 0 8
102287: PUSH
102288: DOUBLE
102289: LD_INT 1
102291: DEC
102292: ST_TO_ADDR
102293: LD_EXP 127
102297: PUSH
102298: FOR_TO
102299: IFFALSE 102335
// begin if flags [ i ] then
102301: LD_VAR 0 4
102305: PUSH
102306: LD_VAR 0 8
102310: ARRAY
102311: IFFALSE 102333
// tmp := tmp & i & ; ;
102313: LD_ADDR_VAR 0 3
102317: PUSH
102318: LD_VAR 0 3
102322: PUSH
102323: LD_VAR 0 8
102327: STR
102328: PUSH
102329: LD_STRING ;
102331: STR
102332: ST_TO_ADDR
// end ;
102333: GO 102298
102335: POP
102336: POP
// for i = 1 to hardcoreCounter do
102337: LD_ADDR_VAR 0 8
102341: PUSH
102342: DOUBLE
102343: LD_INT 1
102345: DEC
102346: ST_TO_ADDR
102347: LD_EXP 128
102351: PUSH
102352: FOR_TO
102353: IFFALSE 102399
// begin if flags [ normalCounter + i ] then
102355: LD_VAR 0 4
102359: PUSH
102360: LD_EXP 127
102364: PUSH
102365: LD_VAR 0 8
102369: PLUS
102370: ARRAY
102371: IFFALSE 102397
// tmp := tmp & ( 100 + i ) & ; ;
102373: LD_ADDR_VAR 0 3
102377: PUSH
102378: LD_VAR 0 3
102382: PUSH
102383: LD_INT 100
102385: PUSH
102386: LD_VAR 0 8
102390: PLUS
102391: STR
102392: PUSH
102393: LD_STRING ;
102395: STR
102396: ST_TO_ADDR
// end ;
102397: GO 102352
102399: POP
102400: POP
// if tmp then
102401: LD_VAR 0 3
102405: IFFALSE 102417
// active := tmp ;
102407: LD_ADDR_VAR 0 7
102411: PUSH
102412: LD_VAR 0 3
102416: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
102417: LD_STRING getStreamItemsFromMission("
102419: PUSH
102420: LD_VAR 0 5
102424: STR
102425: PUSH
102426: LD_STRING ","
102428: STR
102429: PUSH
102430: LD_VAR 0 6
102434: STR
102435: PUSH
102436: LD_STRING ","
102438: STR
102439: PUSH
102440: LD_VAR 0 7
102444: STR
102445: PUSH
102446: LD_STRING ")
102448: STR
102449: PPUSH
102450: CALL_OW 559
// end else
102454: GO 102463
// ToLua ( getStreamItemsFromMission("","","") ) ;
102456: LD_STRING getStreamItemsFromMission("","","")
102458: PPUSH
102459: CALL_OW 559
// end ;
102463: LD_VAR 0 2
102467: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
102468: LD_EXP 126
102472: PUSH
102473: LD_EXP 131
102477: AND
102478: IFFALSE 102602
102480: GO 102482
102482: DISABLE
102483: LD_INT 0
102485: PPUSH
102486: PPUSH
// begin enable ;
102487: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
102488: LD_ADDR_VAR 0 2
102492: PUSH
102493: LD_INT 22
102495: PUSH
102496: LD_OWVAR 2
102500: PUSH
102501: EMPTY
102502: LIST
102503: LIST
102504: PUSH
102505: LD_INT 2
102507: PUSH
102508: LD_INT 34
102510: PUSH
102511: LD_INT 7
102513: PUSH
102514: EMPTY
102515: LIST
102516: LIST
102517: PUSH
102518: LD_INT 34
102520: PUSH
102521: LD_INT 45
102523: PUSH
102524: EMPTY
102525: LIST
102526: LIST
102527: PUSH
102528: LD_INT 34
102530: PUSH
102531: LD_INT 28
102533: PUSH
102534: EMPTY
102535: LIST
102536: LIST
102537: PUSH
102538: LD_INT 34
102540: PUSH
102541: LD_INT 47
102543: PUSH
102544: EMPTY
102545: LIST
102546: LIST
102547: PUSH
102548: EMPTY
102549: LIST
102550: LIST
102551: LIST
102552: LIST
102553: LIST
102554: PUSH
102555: EMPTY
102556: LIST
102557: LIST
102558: PPUSH
102559: CALL_OW 69
102563: ST_TO_ADDR
// if not tmp then
102564: LD_VAR 0 2
102568: NOT
102569: IFFALSE 102573
// exit ;
102571: GO 102602
// for i in tmp do
102573: LD_ADDR_VAR 0 1
102577: PUSH
102578: LD_VAR 0 2
102582: PUSH
102583: FOR_IN
102584: IFFALSE 102600
// begin SetLives ( i , 0 ) ;
102586: LD_VAR 0 1
102590: PPUSH
102591: LD_INT 0
102593: PPUSH
102594: CALL_OW 234
// end ;
102598: GO 102583
102600: POP
102601: POP
// end ;
102602: PPOPN 2
102604: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
102605: LD_EXP 126
102609: PUSH
102610: LD_EXP 132
102614: AND
102615: IFFALSE 102699
102617: GO 102619
102619: DISABLE
102620: LD_INT 0
102622: PPUSH
102623: PPUSH
// begin enable ;
102624: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
102625: LD_ADDR_VAR 0 2
102629: PUSH
102630: LD_INT 22
102632: PUSH
102633: LD_OWVAR 2
102637: PUSH
102638: EMPTY
102639: LIST
102640: LIST
102641: PUSH
102642: LD_INT 32
102644: PUSH
102645: LD_INT 3
102647: PUSH
102648: EMPTY
102649: LIST
102650: LIST
102651: PUSH
102652: EMPTY
102653: LIST
102654: LIST
102655: PPUSH
102656: CALL_OW 69
102660: ST_TO_ADDR
// if not tmp then
102661: LD_VAR 0 2
102665: NOT
102666: IFFALSE 102670
// exit ;
102668: GO 102699
// for i in tmp do
102670: LD_ADDR_VAR 0 1
102674: PUSH
102675: LD_VAR 0 2
102679: PUSH
102680: FOR_IN
102681: IFFALSE 102697
// begin SetLives ( i , 0 ) ;
102683: LD_VAR 0 1
102687: PPUSH
102688: LD_INT 0
102690: PPUSH
102691: CALL_OW 234
// end ;
102695: GO 102680
102697: POP
102698: POP
// end ;
102699: PPOPN 2
102701: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
102702: LD_EXP 126
102706: PUSH
102707: LD_EXP 129
102711: AND
102712: IFFALSE 102805
102714: GO 102716
102716: DISABLE
102717: LD_INT 0
102719: PPUSH
// begin enable ;
102720: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
102721: LD_ADDR_VAR 0 1
102725: PUSH
102726: LD_INT 22
102728: PUSH
102729: LD_OWVAR 2
102733: PUSH
102734: EMPTY
102735: LIST
102736: LIST
102737: PUSH
102738: LD_INT 2
102740: PUSH
102741: LD_INT 25
102743: PUSH
102744: LD_INT 5
102746: PUSH
102747: EMPTY
102748: LIST
102749: LIST
102750: PUSH
102751: LD_INT 25
102753: PUSH
102754: LD_INT 9
102756: PUSH
102757: EMPTY
102758: LIST
102759: LIST
102760: PUSH
102761: LD_INT 25
102763: PUSH
102764: LD_INT 8
102766: PUSH
102767: EMPTY
102768: LIST
102769: LIST
102770: PUSH
102771: EMPTY
102772: LIST
102773: LIST
102774: LIST
102775: LIST
102776: PUSH
102777: EMPTY
102778: LIST
102779: LIST
102780: PPUSH
102781: CALL_OW 69
102785: PUSH
102786: FOR_IN
102787: IFFALSE 102803
// begin SetClass ( i , 1 ) ;
102789: LD_VAR 0 1
102793: PPUSH
102794: LD_INT 1
102796: PPUSH
102797: CALL_OW 336
// end ;
102801: GO 102786
102803: POP
102804: POP
// end ;
102805: PPOPN 1
102807: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
102808: LD_EXP 126
102812: PUSH
102813: LD_EXP 130
102817: AND
102818: PUSH
102819: LD_OWVAR 65
102823: PUSH
102824: LD_INT 7
102826: LESS
102827: AND
102828: IFFALSE 102842
102830: GO 102832
102832: DISABLE
// begin enable ;
102833: ENABLE
// game_speed := 7 ;
102834: LD_ADDR_OWVAR 65
102838: PUSH
102839: LD_INT 7
102841: ST_TO_ADDR
// end ;
102842: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
102843: LD_EXP 126
102847: PUSH
102848: LD_EXP 133
102852: AND
102853: IFFALSE 103055
102855: GO 102857
102857: DISABLE
102858: LD_INT 0
102860: PPUSH
102861: PPUSH
102862: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102863: LD_ADDR_VAR 0 3
102867: PUSH
102868: LD_INT 81
102870: PUSH
102871: LD_OWVAR 2
102875: PUSH
102876: EMPTY
102877: LIST
102878: LIST
102879: PUSH
102880: LD_INT 21
102882: PUSH
102883: LD_INT 1
102885: PUSH
102886: EMPTY
102887: LIST
102888: LIST
102889: PUSH
102890: EMPTY
102891: LIST
102892: LIST
102893: PPUSH
102894: CALL_OW 69
102898: ST_TO_ADDR
// if not tmp then
102899: LD_VAR 0 3
102903: NOT
102904: IFFALSE 102908
// exit ;
102906: GO 103055
// if tmp > 5 then
102908: LD_VAR 0 3
102912: PUSH
102913: LD_INT 5
102915: GREATER
102916: IFFALSE 102928
// k := 5 else
102918: LD_ADDR_VAR 0 2
102922: PUSH
102923: LD_INT 5
102925: ST_TO_ADDR
102926: GO 102938
// k := tmp ;
102928: LD_ADDR_VAR 0 2
102932: PUSH
102933: LD_VAR 0 3
102937: ST_TO_ADDR
// for i := 1 to k do
102938: LD_ADDR_VAR 0 1
102942: PUSH
102943: DOUBLE
102944: LD_INT 1
102946: DEC
102947: ST_TO_ADDR
102948: LD_VAR 0 2
102952: PUSH
102953: FOR_TO
102954: IFFALSE 103053
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
102956: LD_VAR 0 3
102960: PUSH
102961: LD_VAR 0 1
102965: ARRAY
102966: PPUSH
102967: LD_VAR 0 1
102971: PUSH
102972: LD_INT 4
102974: MOD
102975: PUSH
102976: LD_INT 1
102978: PLUS
102979: PPUSH
102980: CALL_OW 259
102984: PUSH
102985: LD_INT 10
102987: LESS
102988: IFFALSE 103051
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
102990: LD_VAR 0 3
102994: PUSH
102995: LD_VAR 0 1
102999: ARRAY
103000: PPUSH
103001: LD_VAR 0 1
103005: PUSH
103006: LD_INT 4
103008: MOD
103009: PUSH
103010: LD_INT 1
103012: PLUS
103013: PPUSH
103014: LD_VAR 0 3
103018: PUSH
103019: LD_VAR 0 1
103023: ARRAY
103024: PPUSH
103025: LD_VAR 0 1
103029: PUSH
103030: LD_INT 4
103032: MOD
103033: PUSH
103034: LD_INT 1
103036: PLUS
103037: PPUSH
103038: CALL_OW 259
103042: PUSH
103043: LD_INT 1
103045: PLUS
103046: PPUSH
103047: CALL_OW 237
103051: GO 102953
103053: POP
103054: POP
// end ;
103055: PPOPN 3
103057: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
103058: LD_EXP 126
103062: PUSH
103063: LD_EXP 134
103067: AND
103068: IFFALSE 103088
103070: GO 103072
103072: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
103073: LD_INT 4
103075: PPUSH
103076: LD_OWVAR 2
103080: PPUSH
103081: LD_INT 0
103083: PPUSH
103084: CALL_OW 324
103088: END
// every 0 0$1 trigger StreamModeActive and sShovel do
103089: LD_EXP 126
103093: PUSH
103094: LD_EXP 163
103098: AND
103099: IFFALSE 103119
103101: GO 103103
103103: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
103104: LD_INT 19
103106: PPUSH
103107: LD_OWVAR 2
103111: PPUSH
103112: LD_INT 0
103114: PPUSH
103115: CALL_OW 324
103119: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
103120: LD_EXP 126
103124: PUSH
103125: LD_EXP 135
103129: AND
103130: IFFALSE 103232
103132: GO 103134
103134: DISABLE
103135: LD_INT 0
103137: PPUSH
103138: PPUSH
// begin enable ;
103139: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
103140: LD_ADDR_VAR 0 2
103144: PUSH
103145: LD_INT 22
103147: PUSH
103148: LD_OWVAR 2
103152: PUSH
103153: EMPTY
103154: LIST
103155: LIST
103156: PUSH
103157: LD_INT 2
103159: PUSH
103160: LD_INT 34
103162: PUSH
103163: LD_INT 11
103165: PUSH
103166: EMPTY
103167: LIST
103168: LIST
103169: PUSH
103170: LD_INT 34
103172: PUSH
103173: LD_INT 30
103175: PUSH
103176: EMPTY
103177: LIST
103178: LIST
103179: PUSH
103180: EMPTY
103181: LIST
103182: LIST
103183: LIST
103184: PUSH
103185: EMPTY
103186: LIST
103187: LIST
103188: PPUSH
103189: CALL_OW 69
103193: ST_TO_ADDR
// if not tmp then
103194: LD_VAR 0 2
103198: NOT
103199: IFFALSE 103203
// exit ;
103201: GO 103232
// for i in tmp do
103203: LD_ADDR_VAR 0 1
103207: PUSH
103208: LD_VAR 0 2
103212: PUSH
103213: FOR_IN
103214: IFFALSE 103230
// begin SetLives ( i , 0 ) ;
103216: LD_VAR 0 1
103220: PPUSH
103221: LD_INT 0
103223: PPUSH
103224: CALL_OW 234
// end ;
103228: GO 103213
103230: POP
103231: POP
// end ;
103232: PPOPN 2
103234: END
// every 0 0$1 trigger StreamModeActive and sBunker do
103235: LD_EXP 126
103239: PUSH
103240: LD_EXP 136
103244: AND
103245: IFFALSE 103265
103247: GO 103249
103249: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
103250: LD_INT 32
103252: PPUSH
103253: LD_OWVAR 2
103257: PPUSH
103258: LD_INT 0
103260: PPUSH
103261: CALL_OW 324
103265: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
103266: LD_EXP 126
103270: PUSH
103271: LD_EXP 137
103275: AND
103276: IFFALSE 103457
103278: GO 103280
103280: DISABLE
103281: LD_INT 0
103283: PPUSH
103284: PPUSH
103285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
103286: LD_ADDR_VAR 0 2
103290: PUSH
103291: LD_INT 22
103293: PUSH
103294: LD_OWVAR 2
103298: PUSH
103299: EMPTY
103300: LIST
103301: LIST
103302: PUSH
103303: LD_INT 33
103305: PUSH
103306: LD_INT 3
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: PUSH
103313: EMPTY
103314: LIST
103315: LIST
103316: PPUSH
103317: CALL_OW 69
103321: ST_TO_ADDR
// if not tmp then
103322: LD_VAR 0 2
103326: NOT
103327: IFFALSE 103331
// exit ;
103329: GO 103457
// side := 0 ;
103331: LD_ADDR_VAR 0 3
103335: PUSH
103336: LD_INT 0
103338: ST_TO_ADDR
// for i := 1 to 8 do
103339: LD_ADDR_VAR 0 1
103343: PUSH
103344: DOUBLE
103345: LD_INT 1
103347: DEC
103348: ST_TO_ADDR
103349: LD_INT 8
103351: PUSH
103352: FOR_TO
103353: IFFALSE 103401
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
103355: LD_OWVAR 2
103359: PUSH
103360: LD_VAR 0 1
103364: NONEQUAL
103365: PUSH
103366: LD_OWVAR 2
103370: PPUSH
103371: LD_VAR 0 1
103375: PPUSH
103376: CALL_OW 81
103380: PUSH
103381: LD_INT 2
103383: EQUAL
103384: AND
103385: IFFALSE 103399
// begin side := i ;
103387: LD_ADDR_VAR 0 3
103391: PUSH
103392: LD_VAR 0 1
103396: ST_TO_ADDR
// break ;
103397: GO 103401
// end ;
103399: GO 103352
103401: POP
103402: POP
// if not side then
103403: LD_VAR 0 3
103407: NOT
103408: IFFALSE 103412
// exit ;
103410: GO 103457
// for i := 1 to tmp do
103412: LD_ADDR_VAR 0 1
103416: PUSH
103417: DOUBLE
103418: LD_INT 1
103420: DEC
103421: ST_TO_ADDR
103422: LD_VAR 0 2
103426: PUSH
103427: FOR_TO
103428: IFFALSE 103455
// if Prob ( 60 ) then
103430: LD_INT 60
103432: PPUSH
103433: CALL_OW 13
103437: IFFALSE 103453
// SetSide ( i , side ) ;
103439: LD_VAR 0 1
103443: PPUSH
103444: LD_VAR 0 3
103448: PPUSH
103449: CALL_OW 235
103453: GO 103427
103455: POP
103456: POP
// end ;
103457: PPOPN 3
103459: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
103460: LD_EXP 126
103464: PUSH
103465: LD_EXP 139
103469: AND
103470: IFFALSE 103589
103472: GO 103474
103474: DISABLE
103475: LD_INT 0
103477: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
103478: LD_ADDR_VAR 0 1
103482: PUSH
103483: LD_INT 22
103485: PUSH
103486: LD_OWVAR 2
103490: PUSH
103491: EMPTY
103492: LIST
103493: LIST
103494: PUSH
103495: LD_INT 21
103497: PUSH
103498: LD_INT 1
103500: PUSH
103501: EMPTY
103502: LIST
103503: LIST
103504: PUSH
103505: LD_INT 3
103507: PUSH
103508: LD_INT 23
103510: PUSH
103511: LD_INT 0
103513: PUSH
103514: EMPTY
103515: LIST
103516: LIST
103517: PUSH
103518: EMPTY
103519: LIST
103520: LIST
103521: PUSH
103522: EMPTY
103523: LIST
103524: LIST
103525: LIST
103526: PPUSH
103527: CALL_OW 69
103531: PUSH
103532: FOR_IN
103533: IFFALSE 103587
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
103535: LD_VAR 0 1
103539: PPUSH
103540: CALL_OW 257
103544: PUSH
103545: LD_INT 1
103547: PUSH
103548: LD_INT 2
103550: PUSH
103551: LD_INT 3
103553: PUSH
103554: LD_INT 4
103556: PUSH
103557: EMPTY
103558: LIST
103559: LIST
103560: LIST
103561: LIST
103562: IN
103563: IFFALSE 103585
// SetClass ( un , rand ( 1 , 4 ) ) ;
103565: LD_VAR 0 1
103569: PPUSH
103570: LD_INT 1
103572: PPUSH
103573: LD_INT 4
103575: PPUSH
103576: CALL_OW 12
103580: PPUSH
103581: CALL_OW 336
103585: GO 103532
103587: POP
103588: POP
// end ;
103589: PPOPN 1
103591: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
103592: LD_EXP 126
103596: PUSH
103597: LD_EXP 138
103601: AND
103602: IFFALSE 103681
103604: GO 103606
103606: DISABLE
103607: LD_INT 0
103609: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103610: LD_ADDR_VAR 0 1
103614: PUSH
103615: LD_INT 22
103617: PUSH
103618: LD_OWVAR 2
103622: PUSH
103623: EMPTY
103624: LIST
103625: LIST
103626: PUSH
103627: LD_INT 21
103629: PUSH
103630: LD_INT 3
103632: PUSH
103633: EMPTY
103634: LIST
103635: LIST
103636: PUSH
103637: EMPTY
103638: LIST
103639: LIST
103640: PPUSH
103641: CALL_OW 69
103645: ST_TO_ADDR
// if not tmp then
103646: LD_VAR 0 1
103650: NOT
103651: IFFALSE 103655
// exit ;
103653: GO 103681
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
103655: LD_VAR 0 1
103659: PUSH
103660: LD_INT 1
103662: PPUSH
103663: LD_VAR 0 1
103667: PPUSH
103668: CALL_OW 12
103672: ARRAY
103673: PPUSH
103674: LD_INT 100
103676: PPUSH
103677: CALL_OW 234
// end ;
103681: PPOPN 1
103683: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
103684: LD_EXP 126
103688: PUSH
103689: LD_EXP 140
103693: AND
103694: IFFALSE 103792
103696: GO 103698
103698: DISABLE
103699: LD_INT 0
103701: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103702: LD_ADDR_VAR 0 1
103706: PUSH
103707: LD_INT 22
103709: PUSH
103710: LD_OWVAR 2
103714: PUSH
103715: EMPTY
103716: LIST
103717: LIST
103718: PUSH
103719: LD_INT 21
103721: PUSH
103722: LD_INT 1
103724: PUSH
103725: EMPTY
103726: LIST
103727: LIST
103728: PUSH
103729: EMPTY
103730: LIST
103731: LIST
103732: PPUSH
103733: CALL_OW 69
103737: ST_TO_ADDR
// if not tmp then
103738: LD_VAR 0 1
103742: NOT
103743: IFFALSE 103747
// exit ;
103745: GO 103792
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
103747: LD_VAR 0 1
103751: PUSH
103752: LD_INT 1
103754: PPUSH
103755: LD_VAR 0 1
103759: PPUSH
103760: CALL_OW 12
103764: ARRAY
103765: PPUSH
103766: LD_INT 1
103768: PPUSH
103769: LD_INT 4
103771: PPUSH
103772: CALL_OW 12
103776: PPUSH
103777: LD_INT 3000
103779: PPUSH
103780: LD_INT 9000
103782: PPUSH
103783: CALL_OW 12
103787: PPUSH
103788: CALL_OW 492
// end ;
103792: PPOPN 1
103794: END
// every 0 0$1 trigger StreamModeActive and sDepot do
103795: LD_EXP 126
103799: PUSH
103800: LD_EXP 141
103804: AND
103805: IFFALSE 103825
103807: GO 103809
103809: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
103810: LD_INT 1
103812: PPUSH
103813: LD_OWVAR 2
103817: PPUSH
103818: LD_INT 0
103820: PPUSH
103821: CALL_OW 324
103825: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
103826: LD_EXP 126
103830: PUSH
103831: LD_EXP 142
103835: AND
103836: IFFALSE 103919
103838: GO 103840
103840: DISABLE
103841: LD_INT 0
103843: PPUSH
103844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103845: LD_ADDR_VAR 0 2
103849: PUSH
103850: LD_INT 22
103852: PUSH
103853: LD_OWVAR 2
103857: PUSH
103858: EMPTY
103859: LIST
103860: LIST
103861: PUSH
103862: LD_INT 21
103864: PUSH
103865: LD_INT 3
103867: PUSH
103868: EMPTY
103869: LIST
103870: LIST
103871: PUSH
103872: EMPTY
103873: LIST
103874: LIST
103875: PPUSH
103876: CALL_OW 69
103880: ST_TO_ADDR
// if not tmp then
103881: LD_VAR 0 2
103885: NOT
103886: IFFALSE 103890
// exit ;
103888: GO 103919
// for i in tmp do
103890: LD_ADDR_VAR 0 1
103894: PUSH
103895: LD_VAR 0 2
103899: PUSH
103900: FOR_IN
103901: IFFALSE 103917
// SetBLevel ( i , 10 ) ;
103903: LD_VAR 0 1
103907: PPUSH
103908: LD_INT 10
103910: PPUSH
103911: CALL_OW 241
103915: GO 103900
103917: POP
103918: POP
// end ;
103919: PPOPN 2
103921: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
103922: LD_EXP 126
103926: PUSH
103927: LD_EXP 143
103931: AND
103932: IFFALSE 104043
103934: GO 103936
103936: DISABLE
103937: LD_INT 0
103939: PPUSH
103940: PPUSH
103941: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103942: LD_ADDR_VAR 0 3
103946: PUSH
103947: LD_INT 22
103949: PUSH
103950: LD_OWVAR 2
103954: PUSH
103955: EMPTY
103956: LIST
103957: LIST
103958: PUSH
103959: LD_INT 25
103961: PUSH
103962: LD_INT 1
103964: PUSH
103965: EMPTY
103966: LIST
103967: LIST
103968: PUSH
103969: EMPTY
103970: LIST
103971: LIST
103972: PPUSH
103973: CALL_OW 69
103977: ST_TO_ADDR
// if not tmp then
103978: LD_VAR 0 3
103982: NOT
103983: IFFALSE 103987
// exit ;
103985: GO 104043
// un := tmp [ rand ( 1 , tmp ) ] ;
103987: LD_ADDR_VAR 0 2
103991: PUSH
103992: LD_VAR 0 3
103996: PUSH
103997: LD_INT 1
103999: PPUSH
104000: LD_VAR 0 3
104004: PPUSH
104005: CALL_OW 12
104009: ARRAY
104010: ST_TO_ADDR
// if Crawls ( un ) then
104011: LD_VAR 0 2
104015: PPUSH
104016: CALL_OW 318
104020: IFFALSE 104031
// ComWalk ( un ) ;
104022: LD_VAR 0 2
104026: PPUSH
104027: CALL_OW 138
// SetClass ( un , class_sniper ) ;
104031: LD_VAR 0 2
104035: PPUSH
104036: LD_INT 5
104038: PPUSH
104039: CALL_OW 336
// end ;
104043: PPOPN 3
104045: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
104046: LD_EXP 126
104050: PUSH
104051: LD_EXP 144
104055: AND
104056: PUSH
104057: LD_OWVAR 67
104061: PUSH
104062: LD_INT 4
104064: LESS
104065: AND
104066: IFFALSE 104085
104068: GO 104070
104070: DISABLE
// begin Difficulty := Difficulty + 1 ;
104071: LD_ADDR_OWVAR 67
104075: PUSH
104076: LD_OWVAR 67
104080: PUSH
104081: LD_INT 1
104083: PLUS
104084: ST_TO_ADDR
// end ;
104085: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
104086: LD_EXP 126
104090: PUSH
104091: LD_EXP 145
104095: AND
104096: IFFALSE 104199
104098: GO 104100
104100: DISABLE
104101: LD_INT 0
104103: PPUSH
// begin for i := 1 to 5 do
104104: LD_ADDR_VAR 0 1
104108: PUSH
104109: DOUBLE
104110: LD_INT 1
104112: DEC
104113: ST_TO_ADDR
104114: LD_INT 5
104116: PUSH
104117: FOR_TO
104118: IFFALSE 104197
// begin uc_nation := nation_nature ;
104120: LD_ADDR_OWVAR 21
104124: PUSH
104125: LD_INT 0
104127: ST_TO_ADDR
// uc_side := 0 ;
104128: LD_ADDR_OWVAR 20
104132: PUSH
104133: LD_INT 0
104135: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104136: LD_ADDR_OWVAR 29
104140: PUSH
104141: LD_INT 12
104143: PUSH
104144: LD_INT 12
104146: PUSH
104147: EMPTY
104148: LIST
104149: LIST
104150: ST_TO_ADDR
// hc_agressivity := 20 ;
104151: LD_ADDR_OWVAR 35
104155: PUSH
104156: LD_INT 20
104158: ST_TO_ADDR
// hc_class := class_tiger ;
104159: LD_ADDR_OWVAR 28
104163: PUSH
104164: LD_INT 14
104166: ST_TO_ADDR
// hc_gallery :=  ;
104167: LD_ADDR_OWVAR 33
104171: PUSH
104172: LD_STRING 
104174: ST_TO_ADDR
// hc_name :=  ;
104175: LD_ADDR_OWVAR 26
104179: PUSH
104180: LD_STRING 
104182: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
104183: CALL_OW 44
104187: PPUSH
104188: LD_INT 0
104190: PPUSH
104191: CALL_OW 51
// end ;
104195: GO 104117
104197: POP
104198: POP
// end ;
104199: PPOPN 1
104201: END
// every 0 0$1 trigger StreamModeActive and sBomb do
104202: LD_EXP 126
104206: PUSH
104207: LD_EXP 146
104211: AND
104212: IFFALSE 104221
104214: GO 104216
104216: DISABLE
// StreamSibBomb ;
104217: CALL 104222 0 0
104221: END
// export function StreamSibBomb ; var i , x , y ; begin
104222: LD_INT 0
104224: PPUSH
104225: PPUSH
104226: PPUSH
104227: PPUSH
// result := false ;
104228: LD_ADDR_VAR 0 1
104232: PUSH
104233: LD_INT 0
104235: ST_TO_ADDR
// for i := 1 to 16 do
104236: LD_ADDR_VAR 0 2
104240: PUSH
104241: DOUBLE
104242: LD_INT 1
104244: DEC
104245: ST_TO_ADDR
104246: LD_INT 16
104248: PUSH
104249: FOR_TO
104250: IFFALSE 104449
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104252: LD_ADDR_VAR 0 3
104256: PUSH
104257: LD_INT 10
104259: PUSH
104260: LD_INT 20
104262: PUSH
104263: LD_INT 30
104265: PUSH
104266: LD_INT 40
104268: PUSH
104269: LD_INT 50
104271: PUSH
104272: LD_INT 60
104274: PUSH
104275: LD_INT 70
104277: PUSH
104278: LD_INT 80
104280: PUSH
104281: LD_INT 90
104283: PUSH
104284: LD_INT 100
104286: PUSH
104287: LD_INT 110
104289: PUSH
104290: LD_INT 120
104292: PUSH
104293: LD_INT 130
104295: PUSH
104296: LD_INT 140
104298: PUSH
104299: LD_INT 150
104301: PUSH
104302: EMPTY
104303: LIST
104304: LIST
104305: LIST
104306: LIST
104307: LIST
104308: LIST
104309: LIST
104310: LIST
104311: LIST
104312: LIST
104313: LIST
104314: LIST
104315: LIST
104316: LIST
104317: LIST
104318: PUSH
104319: LD_INT 1
104321: PPUSH
104322: LD_INT 15
104324: PPUSH
104325: CALL_OW 12
104329: ARRAY
104330: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104331: LD_ADDR_VAR 0 4
104335: PUSH
104336: LD_INT 10
104338: PUSH
104339: LD_INT 20
104341: PUSH
104342: LD_INT 30
104344: PUSH
104345: LD_INT 40
104347: PUSH
104348: LD_INT 50
104350: PUSH
104351: LD_INT 60
104353: PUSH
104354: LD_INT 70
104356: PUSH
104357: LD_INT 80
104359: PUSH
104360: LD_INT 90
104362: PUSH
104363: LD_INT 100
104365: PUSH
104366: LD_INT 110
104368: PUSH
104369: LD_INT 120
104371: PUSH
104372: LD_INT 130
104374: PUSH
104375: LD_INT 140
104377: PUSH
104378: LD_INT 150
104380: PUSH
104381: EMPTY
104382: LIST
104383: LIST
104384: LIST
104385: LIST
104386: LIST
104387: LIST
104388: LIST
104389: LIST
104390: LIST
104391: LIST
104392: LIST
104393: LIST
104394: LIST
104395: LIST
104396: LIST
104397: PUSH
104398: LD_INT 1
104400: PPUSH
104401: LD_INT 15
104403: PPUSH
104404: CALL_OW 12
104408: ARRAY
104409: ST_TO_ADDR
// if ValidHex ( x , y ) then
104410: LD_VAR 0 3
104414: PPUSH
104415: LD_VAR 0 4
104419: PPUSH
104420: CALL_OW 488
104424: IFFALSE 104447
// begin result := [ x , y ] ;
104426: LD_ADDR_VAR 0 1
104430: PUSH
104431: LD_VAR 0 3
104435: PUSH
104436: LD_VAR 0 4
104440: PUSH
104441: EMPTY
104442: LIST
104443: LIST
104444: ST_TO_ADDR
// break ;
104445: GO 104449
// end ; end ;
104447: GO 104249
104449: POP
104450: POP
// if result then
104451: LD_VAR 0 1
104455: IFFALSE 104515
// begin ToLua ( playSibBomb() ) ;
104457: LD_STRING playSibBomb()
104459: PPUSH
104460: CALL_OW 559
// wait ( 0 0$14 ) ;
104464: LD_INT 490
104466: PPUSH
104467: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
104471: LD_VAR 0 1
104475: PUSH
104476: LD_INT 1
104478: ARRAY
104479: PPUSH
104480: LD_VAR 0 1
104484: PUSH
104485: LD_INT 2
104487: ARRAY
104488: PPUSH
104489: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
104493: LD_VAR 0 1
104497: PUSH
104498: LD_INT 1
104500: ARRAY
104501: PPUSH
104502: LD_VAR 0 1
104506: PUSH
104507: LD_INT 2
104509: ARRAY
104510: PPUSH
104511: CALL_OW 429
// end ; end ;
104515: LD_VAR 0 1
104519: RET
// every 0 0$1 trigger StreamModeActive and sReset do
104520: LD_EXP 126
104524: PUSH
104525: LD_EXP 148
104529: AND
104530: IFFALSE 104542
104532: GO 104534
104534: DISABLE
// YouLost (  ) ;
104535: LD_STRING 
104537: PPUSH
104538: CALL_OW 104
104542: END
// every 0 0$1 trigger StreamModeActive and sFog do
104543: LD_EXP 126
104547: PUSH
104548: LD_EXP 147
104552: AND
104553: IFFALSE 104567
104555: GO 104557
104557: DISABLE
// FogOff ( your_side ) ;
104558: LD_OWVAR 2
104562: PPUSH
104563: CALL_OW 344
104567: END
// every 0 0$1 trigger StreamModeActive and sSun do
104568: LD_EXP 126
104572: PUSH
104573: LD_EXP 149
104577: AND
104578: IFFALSE 104606
104580: GO 104582
104582: DISABLE
// begin solar_recharge_percent := 0 ;
104583: LD_ADDR_OWVAR 79
104587: PUSH
104588: LD_INT 0
104590: ST_TO_ADDR
// wait ( 5 5$00 ) ;
104591: LD_INT 10500
104593: PPUSH
104594: CALL_OW 67
// solar_recharge_percent := 100 ;
104598: LD_ADDR_OWVAR 79
104602: PUSH
104603: LD_INT 100
104605: ST_TO_ADDR
// end ;
104606: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
104607: LD_EXP 126
104611: PUSH
104612: LD_EXP 150
104616: AND
104617: IFFALSE 104856
104619: GO 104621
104621: DISABLE
104622: LD_INT 0
104624: PPUSH
104625: PPUSH
104626: PPUSH
// begin tmp := [ ] ;
104627: LD_ADDR_VAR 0 3
104631: PUSH
104632: EMPTY
104633: ST_TO_ADDR
// for i := 1 to 6 do
104634: LD_ADDR_VAR 0 1
104638: PUSH
104639: DOUBLE
104640: LD_INT 1
104642: DEC
104643: ST_TO_ADDR
104644: LD_INT 6
104646: PUSH
104647: FOR_TO
104648: IFFALSE 104753
// begin uc_nation := nation_nature ;
104650: LD_ADDR_OWVAR 21
104654: PUSH
104655: LD_INT 0
104657: ST_TO_ADDR
// uc_side := 0 ;
104658: LD_ADDR_OWVAR 20
104662: PUSH
104663: LD_INT 0
104665: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104666: LD_ADDR_OWVAR 29
104670: PUSH
104671: LD_INT 12
104673: PUSH
104674: LD_INT 12
104676: PUSH
104677: EMPTY
104678: LIST
104679: LIST
104680: ST_TO_ADDR
// hc_agressivity := 20 ;
104681: LD_ADDR_OWVAR 35
104685: PUSH
104686: LD_INT 20
104688: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
104689: LD_ADDR_OWVAR 28
104693: PUSH
104694: LD_INT 17
104696: ST_TO_ADDR
// hc_gallery :=  ;
104697: LD_ADDR_OWVAR 33
104701: PUSH
104702: LD_STRING 
104704: ST_TO_ADDR
// hc_name :=  ;
104705: LD_ADDR_OWVAR 26
104709: PUSH
104710: LD_STRING 
104712: ST_TO_ADDR
// un := CreateHuman ;
104713: LD_ADDR_VAR 0 2
104717: PUSH
104718: CALL_OW 44
104722: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
104723: LD_VAR 0 2
104727: PPUSH
104728: LD_INT 1
104730: PPUSH
104731: CALL_OW 51
// tmp := tmp ^ un ;
104735: LD_ADDR_VAR 0 3
104739: PUSH
104740: LD_VAR 0 3
104744: PUSH
104745: LD_VAR 0 2
104749: ADD
104750: ST_TO_ADDR
// end ;
104751: GO 104647
104753: POP
104754: POP
// repeat wait ( 0 0$1 ) ;
104755: LD_INT 35
104757: PPUSH
104758: CALL_OW 67
// for un in tmp do
104762: LD_ADDR_VAR 0 2
104766: PUSH
104767: LD_VAR 0 3
104771: PUSH
104772: FOR_IN
104773: IFFALSE 104847
// begin if IsDead ( un ) then
104775: LD_VAR 0 2
104779: PPUSH
104780: CALL_OW 301
104784: IFFALSE 104804
// begin tmp := tmp diff un ;
104786: LD_ADDR_VAR 0 3
104790: PUSH
104791: LD_VAR 0 3
104795: PUSH
104796: LD_VAR 0 2
104800: DIFF
104801: ST_TO_ADDR
// continue ;
104802: GO 104772
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
104804: LD_VAR 0 2
104808: PPUSH
104809: LD_INT 3
104811: PUSH
104812: LD_INT 22
104814: PUSH
104815: LD_INT 0
104817: PUSH
104818: EMPTY
104819: LIST
104820: LIST
104821: PUSH
104822: EMPTY
104823: LIST
104824: LIST
104825: PPUSH
104826: CALL_OW 69
104830: PPUSH
104831: LD_VAR 0 2
104835: PPUSH
104836: CALL_OW 74
104840: PPUSH
104841: CALL_OW 115
// end ;
104845: GO 104772
104847: POP
104848: POP
// until not tmp ;
104849: LD_VAR 0 3
104853: NOT
104854: IFFALSE 104755
// end ;
104856: PPOPN 3
104858: END
// every 0 0$1 trigger StreamModeActive and sTroll do
104859: LD_EXP 126
104863: PUSH
104864: LD_EXP 151
104868: AND
104869: IFFALSE 104923
104871: GO 104873
104873: DISABLE
// begin ToLua ( displayTroll(); ) ;
104874: LD_STRING displayTroll();
104876: PPUSH
104877: CALL_OW 559
// wait ( 3 3$00 ) ;
104881: LD_INT 6300
104883: PPUSH
104884: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104888: LD_STRING hideTroll();
104890: PPUSH
104891: CALL_OW 559
// wait ( 1 1$00 ) ;
104895: LD_INT 2100
104897: PPUSH
104898: CALL_OW 67
// ToLua ( displayTroll(); ) ;
104902: LD_STRING displayTroll();
104904: PPUSH
104905: CALL_OW 559
// wait ( 1 1$00 ) ;
104909: LD_INT 2100
104911: PPUSH
104912: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104916: LD_STRING hideTroll();
104918: PPUSH
104919: CALL_OW 559
// end ;
104923: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
104924: LD_EXP 126
104928: PUSH
104929: LD_EXP 152
104933: AND
104934: IFFALSE 104997
104936: GO 104938
104938: DISABLE
104939: LD_INT 0
104941: PPUSH
// begin p := 0 ;
104942: LD_ADDR_VAR 0 1
104946: PUSH
104947: LD_INT 0
104949: ST_TO_ADDR
// repeat game_speed := 1 ;
104950: LD_ADDR_OWVAR 65
104954: PUSH
104955: LD_INT 1
104957: ST_TO_ADDR
// wait ( 0 0$1 ) ;
104958: LD_INT 35
104960: PPUSH
104961: CALL_OW 67
// p := p + 1 ;
104965: LD_ADDR_VAR 0 1
104969: PUSH
104970: LD_VAR 0 1
104974: PUSH
104975: LD_INT 1
104977: PLUS
104978: ST_TO_ADDR
// until p >= 60 ;
104979: LD_VAR 0 1
104983: PUSH
104984: LD_INT 60
104986: GREATEREQUAL
104987: IFFALSE 104950
// game_speed := 4 ;
104989: LD_ADDR_OWVAR 65
104993: PUSH
104994: LD_INT 4
104996: ST_TO_ADDR
// end ;
104997: PPOPN 1
104999: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
105000: LD_EXP 126
105004: PUSH
105005: LD_EXP 153
105009: AND
105010: IFFALSE 105156
105012: GO 105014
105014: DISABLE
105015: LD_INT 0
105017: PPUSH
105018: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105019: LD_ADDR_VAR 0 1
105023: PUSH
105024: LD_INT 22
105026: PUSH
105027: LD_OWVAR 2
105031: PUSH
105032: EMPTY
105033: LIST
105034: LIST
105035: PUSH
105036: LD_INT 2
105038: PUSH
105039: LD_INT 30
105041: PUSH
105042: LD_INT 0
105044: PUSH
105045: EMPTY
105046: LIST
105047: LIST
105048: PUSH
105049: LD_INT 30
105051: PUSH
105052: LD_INT 1
105054: PUSH
105055: EMPTY
105056: LIST
105057: LIST
105058: PUSH
105059: EMPTY
105060: LIST
105061: LIST
105062: LIST
105063: PUSH
105064: EMPTY
105065: LIST
105066: LIST
105067: PPUSH
105068: CALL_OW 69
105072: ST_TO_ADDR
// if not depot then
105073: LD_VAR 0 1
105077: NOT
105078: IFFALSE 105082
// exit ;
105080: GO 105156
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
105082: LD_ADDR_VAR 0 2
105086: PUSH
105087: LD_VAR 0 1
105091: PUSH
105092: LD_INT 1
105094: PPUSH
105095: LD_VAR 0 1
105099: PPUSH
105100: CALL_OW 12
105104: ARRAY
105105: PPUSH
105106: CALL_OW 274
105110: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
105111: LD_VAR 0 2
105115: PPUSH
105116: LD_INT 1
105118: PPUSH
105119: LD_INT 0
105121: PPUSH
105122: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
105126: LD_VAR 0 2
105130: PPUSH
105131: LD_INT 2
105133: PPUSH
105134: LD_INT 0
105136: PPUSH
105137: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
105141: LD_VAR 0 2
105145: PPUSH
105146: LD_INT 3
105148: PPUSH
105149: LD_INT 0
105151: PPUSH
105152: CALL_OW 277
// end ;
105156: PPOPN 2
105158: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
105159: LD_EXP 126
105163: PUSH
105164: LD_EXP 154
105168: AND
105169: IFFALSE 105266
105171: GO 105173
105173: DISABLE
105174: LD_INT 0
105176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105177: LD_ADDR_VAR 0 1
105181: PUSH
105182: LD_INT 22
105184: PUSH
105185: LD_OWVAR 2
105189: PUSH
105190: EMPTY
105191: LIST
105192: LIST
105193: PUSH
105194: LD_INT 21
105196: PUSH
105197: LD_INT 1
105199: PUSH
105200: EMPTY
105201: LIST
105202: LIST
105203: PUSH
105204: LD_INT 3
105206: PUSH
105207: LD_INT 23
105209: PUSH
105210: LD_INT 0
105212: PUSH
105213: EMPTY
105214: LIST
105215: LIST
105216: PUSH
105217: EMPTY
105218: LIST
105219: LIST
105220: PUSH
105221: EMPTY
105222: LIST
105223: LIST
105224: LIST
105225: PPUSH
105226: CALL_OW 69
105230: ST_TO_ADDR
// if not tmp then
105231: LD_VAR 0 1
105235: NOT
105236: IFFALSE 105240
// exit ;
105238: GO 105266
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
105240: LD_VAR 0 1
105244: PUSH
105245: LD_INT 1
105247: PPUSH
105248: LD_VAR 0 1
105252: PPUSH
105253: CALL_OW 12
105257: ARRAY
105258: PPUSH
105259: LD_INT 200
105261: PPUSH
105262: CALL_OW 234
// end ;
105266: PPOPN 1
105268: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
105269: LD_EXP 126
105273: PUSH
105274: LD_EXP 155
105278: AND
105279: IFFALSE 105358
105281: GO 105283
105283: DISABLE
105284: LD_INT 0
105286: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
105287: LD_ADDR_VAR 0 1
105291: PUSH
105292: LD_INT 22
105294: PUSH
105295: LD_OWVAR 2
105299: PUSH
105300: EMPTY
105301: LIST
105302: LIST
105303: PUSH
105304: LD_INT 21
105306: PUSH
105307: LD_INT 2
105309: PUSH
105310: EMPTY
105311: LIST
105312: LIST
105313: PUSH
105314: EMPTY
105315: LIST
105316: LIST
105317: PPUSH
105318: CALL_OW 69
105322: ST_TO_ADDR
// if not tmp then
105323: LD_VAR 0 1
105327: NOT
105328: IFFALSE 105332
// exit ;
105330: GO 105358
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
105332: LD_VAR 0 1
105336: PUSH
105337: LD_INT 1
105339: PPUSH
105340: LD_VAR 0 1
105344: PPUSH
105345: CALL_OW 12
105349: ARRAY
105350: PPUSH
105351: LD_INT 60
105353: PPUSH
105354: CALL_OW 234
// end ;
105358: PPOPN 1
105360: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
105361: LD_EXP 126
105365: PUSH
105366: LD_EXP 156
105370: AND
105371: IFFALSE 105470
105373: GO 105375
105375: DISABLE
105376: LD_INT 0
105378: PPUSH
105379: PPUSH
// begin enable ;
105380: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
105381: LD_ADDR_VAR 0 1
105385: PUSH
105386: LD_INT 22
105388: PUSH
105389: LD_OWVAR 2
105393: PUSH
105394: EMPTY
105395: LIST
105396: LIST
105397: PUSH
105398: LD_INT 61
105400: PUSH
105401: EMPTY
105402: LIST
105403: PUSH
105404: LD_INT 33
105406: PUSH
105407: LD_INT 2
105409: PUSH
105410: EMPTY
105411: LIST
105412: LIST
105413: PUSH
105414: EMPTY
105415: LIST
105416: LIST
105417: LIST
105418: PPUSH
105419: CALL_OW 69
105423: ST_TO_ADDR
// if not tmp then
105424: LD_VAR 0 1
105428: NOT
105429: IFFALSE 105433
// exit ;
105431: GO 105470
// for i in tmp do
105433: LD_ADDR_VAR 0 2
105437: PUSH
105438: LD_VAR 0 1
105442: PUSH
105443: FOR_IN
105444: IFFALSE 105468
// if IsControledBy ( i ) then
105446: LD_VAR 0 2
105450: PPUSH
105451: CALL_OW 312
105455: IFFALSE 105466
// ComUnlink ( i ) ;
105457: LD_VAR 0 2
105461: PPUSH
105462: CALL_OW 136
105466: GO 105443
105468: POP
105469: POP
// end ;
105470: PPOPN 2
105472: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
105473: LD_EXP 126
105477: PUSH
105478: LD_EXP 157
105482: AND
105483: IFFALSE 105623
105485: GO 105487
105487: DISABLE
105488: LD_INT 0
105490: PPUSH
105491: PPUSH
// begin ToLua ( displayPowell(); ) ;
105492: LD_STRING displayPowell();
105494: PPUSH
105495: CALL_OW 559
// uc_side := 0 ;
105499: LD_ADDR_OWVAR 20
105503: PUSH
105504: LD_INT 0
105506: ST_TO_ADDR
// uc_nation := 2 ;
105507: LD_ADDR_OWVAR 21
105511: PUSH
105512: LD_INT 2
105514: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
105515: LD_ADDR_OWVAR 37
105519: PUSH
105520: LD_INT 14
105522: ST_TO_ADDR
// vc_engine := engine_siberite ;
105523: LD_ADDR_OWVAR 39
105527: PUSH
105528: LD_INT 3
105530: ST_TO_ADDR
// vc_control := control_apeman ;
105531: LD_ADDR_OWVAR 38
105535: PUSH
105536: LD_INT 5
105538: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
105539: LD_ADDR_OWVAR 40
105543: PUSH
105544: LD_INT 29
105546: ST_TO_ADDR
// un := CreateVehicle ;
105547: LD_ADDR_VAR 0 2
105551: PUSH
105552: CALL_OW 45
105556: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105557: LD_VAR 0 2
105561: PPUSH
105562: LD_INT 1
105564: PPUSH
105565: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105569: LD_INT 35
105571: PPUSH
105572: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105576: LD_VAR 0 2
105580: PPUSH
105581: LD_INT 22
105583: PUSH
105584: LD_OWVAR 2
105588: PUSH
105589: EMPTY
105590: LIST
105591: LIST
105592: PPUSH
105593: CALL_OW 69
105597: PPUSH
105598: LD_VAR 0 2
105602: PPUSH
105603: CALL_OW 74
105607: PPUSH
105608: CALL_OW 115
// until IsDead ( un ) ;
105612: LD_VAR 0 2
105616: PPUSH
105617: CALL_OW 301
105621: IFFALSE 105569
// end ;
105623: PPOPN 2
105625: END
// every 0 0$1 trigger StreamModeActive and sStu do
105626: LD_EXP 126
105630: PUSH
105631: LD_EXP 165
105635: AND
105636: IFFALSE 105652
105638: GO 105640
105640: DISABLE
// begin ToLua ( displayStucuk(); ) ;
105641: LD_STRING displayStucuk();
105643: PPUSH
105644: CALL_OW 559
// ResetFog ;
105648: CALL_OW 335
// end ;
105652: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
105653: LD_EXP 126
105657: PUSH
105658: LD_EXP 158
105662: AND
105663: IFFALSE 105804
105665: GO 105667
105667: DISABLE
105668: LD_INT 0
105670: PPUSH
105671: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105672: LD_ADDR_VAR 0 2
105676: PUSH
105677: LD_INT 22
105679: PUSH
105680: LD_OWVAR 2
105684: PUSH
105685: EMPTY
105686: LIST
105687: LIST
105688: PUSH
105689: LD_INT 21
105691: PUSH
105692: LD_INT 1
105694: PUSH
105695: EMPTY
105696: LIST
105697: LIST
105698: PUSH
105699: EMPTY
105700: LIST
105701: LIST
105702: PPUSH
105703: CALL_OW 69
105707: ST_TO_ADDR
// if not tmp then
105708: LD_VAR 0 2
105712: NOT
105713: IFFALSE 105717
// exit ;
105715: GO 105804
// un := tmp [ rand ( 1 , tmp ) ] ;
105717: LD_ADDR_VAR 0 1
105721: PUSH
105722: LD_VAR 0 2
105726: PUSH
105727: LD_INT 1
105729: PPUSH
105730: LD_VAR 0 2
105734: PPUSH
105735: CALL_OW 12
105739: ARRAY
105740: ST_TO_ADDR
// SetSide ( un , 0 ) ;
105741: LD_VAR 0 1
105745: PPUSH
105746: LD_INT 0
105748: PPUSH
105749: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
105753: LD_VAR 0 1
105757: PPUSH
105758: LD_OWVAR 3
105762: PUSH
105763: LD_VAR 0 1
105767: DIFF
105768: PPUSH
105769: LD_VAR 0 1
105773: PPUSH
105774: CALL_OW 74
105778: PPUSH
105779: CALL_OW 115
// wait ( 0 0$20 ) ;
105783: LD_INT 700
105785: PPUSH
105786: CALL_OW 67
// SetSide ( un , your_side ) ;
105790: LD_VAR 0 1
105794: PPUSH
105795: LD_OWVAR 2
105799: PPUSH
105800: CALL_OW 235
// end ;
105804: PPOPN 2
105806: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
105807: LD_EXP 126
105811: PUSH
105812: LD_EXP 159
105816: AND
105817: IFFALSE 105923
105819: GO 105821
105821: DISABLE
105822: LD_INT 0
105824: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105825: LD_ADDR_VAR 0 1
105829: PUSH
105830: LD_INT 22
105832: PUSH
105833: LD_OWVAR 2
105837: PUSH
105838: EMPTY
105839: LIST
105840: LIST
105841: PUSH
105842: LD_INT 2
105844: PUSH
105845: LD_INT 30
105847: PUSH
105848: LD_INT 0
105850: PUSH
105851: EMPTY
105852: LIST
105853: LIST
105854: PUSH
105855: LD_INT 30
105857: PUSH
105858: LD_INT 1
105860: PUSH
105861: EMPTY
105862: LIST
105863: LIST
105864: PUSH
105865: EMPTY
105866: LIST
105867: LIST
105868: LIST
105869: PUSH
105870: EMPTY
105871: LIST
105872: LIST
105873: PPUSH
105874: CALL_OW 69
105878: ST_TO_ADDR
// if not depot then
105879: LD_VAR 0 1
105883: NOT
105884: IFFALSE 105888
// exit ;
105886: GO 105923
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
105888: LD_VAR 0 1
105892: PUSH
105893: LD_INT 1
105895: ARRAY
105896: PPUSH
105897: CALL_OW 250
105901: PPUSH
105902: LD_VAR 0 1
105906: PUSH
105907: LD_INT 1
105909: ARRAY
105910: PPUSH
105911: CALL_OW 251
105915: PPUSH
105916: LD_INT 70
105918: PPUSH
105919: CALL_OW 495
// end ;
105923: PPOPN 1
105925: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
105926: LD_EXP 126
105930: PUSH
105931: LD_EXP 160
105935: AND
105936: IFFALSE 106147
105938: GO 105940
105940: DISABLE
105941: LD_INT 0
105943: PPUSH
105944: PPUSH
105945: PPUSH
105946: PPUSH
105947: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105948: LD_ADDR_VAR 0 5
105952: PUSH
105953: LD_INT 22
105955: PUSH
105956: LD_OWVAR 2
105960: PUSH
105961: EMPTY
105962: LIST
105963: LIST
105964: PUSH
105965: LD_INT 21
105967: PUSH
105968: LD_INT 1
105970: PUSH
105971: EMPTY
105972: LIST
105973: LIST
105974: PUSH
105975: EMPTY
105976: LIST
105977: LIST
105978: PPUSH
105979: CALL_OW 69
105983: ST_TO_ADDR
// if not tmp then
105984: LD_VAR 0 5
105988: NOT
105989: IFFALSE 105993
// exit ;
105991: GO 106147
// for i in tmp do
105993: LD_ADDR_VAR 0 1
105997: PUSH
105998: LD_VAR 0 5
106002: PUSH
106003: FOR_IN
106004: IFFALSE 106145
// begin d := rand ( 0 , 5 ) ;
106006: LD_ADDR_VAR 0 4
106010: PUSH
106011: LD_INT 0
106013: PPUSH
106014: LD_INT 5
106016: PPUSH
106017: CALL_OW 12
106021: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
106022: LD_ADDR_VAR 0 2
106026: PUSH
106027: LD_VAR 0 1
106031: PPUSH
106032: CALL_OW 250
106036: PPUSH
106037: LD_VAR 0 4
106041: PPUSH
106042: LD_INT 3
106044: PPUSH
106045: LD_INT 12
106047: PPUSH
106048: CALL_OW 12
106052: PPUSH
106053: CALL_OW 272
106057: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
106058: LD_ADDR_VAR 0 3
106062: PUSH
106063: LD_VAR 0 1
106067: PPUSH
106068: CALL_OW 251
106072: PPUSH
106073: LD_VAR 0 4
106077: PPUSH
106078: LD_INT 3
106080: PPUSH
106081: LD_INT 12
106083: PPUSH
106084: CALL_OW 12
106088: PPUSH
106089: CALL_OW 273
106093: ST_TO_ADDR
// if ValidHex ( x , y ) then
106094: LD_VAR 0 2
106098: PPUSH
106099: LD_VAR 0 3
106103: PPUSH
106104: CALL_OW 488
106108: IFFALSE 106143
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
106110: LD_VAR 0 1
106114: PPUSH
106115: LD_VAR 0 2
106119: PPUSH
106120: LD_VAR 0 3
106124: PPUSH
106125: LD_INT 3
106127: PPUSH
106128: LD_INT 6
106130: PPUSH
106131: CALL_OW 12
106135: PPUSH
106136: LD_INT 1
106138: PPUSH
106139: CALL_OW 483
// end ;
106143: GO 106003
106145: POP
106146: POP
// end ;
106147: PPOPN 5
106149: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
106150: LD_EXP 126
106154: PUSH
106155: LD_EXP 161
106159: AND
106160: IFFALSE 106254
106162: GO 106164
106164: DISABLE
106165: LD_INT 0
106167: PPUSH
106168: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
106169: LD_ADDR_VAR 0 2
106173: PUSH
106174: LD_INT 22
106176: PUSH
106177: LD_OWVAR 2
106181: PUSH
106182: EMPTY
106183: LIST
106184: LIST
106185: PUSH
106186: LD_INT 32
106188: PUSH
106189: LD_INT 1
106191: PUSH
106192: EMPTY
106193: LIST
106194: LIST
106195: PUSH
106196: LD_INT 21
106198: PUSH
106199: LD_INT 2
106201: PUSH
106202: EMPTY
106203: LIST
106204: LIST
106205: PUSH
106206: EMPTY
106207: LIST
106208: LIST
106209: LIST
106210: PPUSH
106211: CALL_OW 69
106215: ST_TO_ADDR
// if not tmp then
106216: LD_VAR 0 2
106220: NOT
106221: IFFALSE 106225
// exit ;
106223: GO 106254
// for i in tmp do
106225: LD_ADDR_VAR 0 1
106229: PUSH
106230: LD_VAR 0 2
106234: PUSH
106235: FOR_IN
106236: IFFALSE 106252
// SetFuel ( i , 0 ) ;
106238: LD_VAR 0 1
106242: PPUSH
106243: LD_INT 0
106245: PPUSH
106246: CALL_OW 240
106250: GO 106235
106252: POP
106253: POP
// end ;
106254: PPOPN 2
106256: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
106257: LD_EXP 126
106261: PUSH
106262: LD_EXP 162
106266: AND
106267: IFFALSE 106333
106269: GO 106271
106271: DISABLE
106272: LD_INT 0
106274: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106275: LD_ADDR_VAR 0 1
106279: PUSH
106280: LD_INT 22
106282: PUSH
106283: LD_OWVAR 2
106287: PUSH
106288: EMPTY
106289: LIST
106290: LIST
106291: PUSH
106292: LD_INT 30
106294: PUSH
106295: LD_INT 29
106297: PUSH
106298: EMPTY
106299: LIST
106300: LIST
106301: PUSH
106302: EMPTY
106303: LIST
106304: LIST
106305: PPUSH
106306: CALL_OW 69
106310: ST_TO_ADDR
// if not tmp then
106311: LD_VAR 0 1
106315: NOT
106316: IFFALSE 106320
// exit ;
106318: GO 106333
// DestroyUnit ( tmp [ 1 ] ) ;
106320: LD_VAR 0 1
106324: PUSH
106325: LD_INT 1
106327: ARRAY
106328: PPUSH
106329: CALL_OW 65
// end ;
106333: PPOPN 1
106335: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
106336: LD_EXP 126
106340: PUSH
106341: LD_EXP 164
106345: AND
106346: IFFALSE 106475
106348: GO 106350
106350: DISABLE
106351: LD_INT 0
106353: PPUSH
// begin uc_side := 0 ;
106354: LD_ADDR_OWVAR 20
106358: PUSH
106359: LD_INT 0
106361: ST_TO_ADDR
// uc_nation := nation_arabian ;
106362: LD_ADDR_OWVAR 21
106366: PUSH
106367: LD_INT 2
106369: ST_TO_ADDR
// hc_gallery :=  ;
106370: LD_ADDR_OWVAR 33
106374: PUSH
106375: LD_STRING 
106377: ST_TO_ADDR
// hc_name :=  ;
106378: LD_ADDR_OWVAR 26
106382: PUSH
106383: LD_STRING 
106385: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
106386: LD_INT 1
106388: PPUSH
106389: LD_INT 11
106391: PPUSH
106392: LD_INT 10
106394: PPUSH
106395: CALL_OW 380
// un := CreateHuman ;
106399: LD_ADDR_VAR 0 1
106403: PUSH
106404: CALL_OW 44
106408: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106409: LD_VAR 0 1
106413: PPUSH
106414: LD_INT 1
106416: PPUSH
106417: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
106421: LD_INT 35
106423: PPUSH
106424: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
106428: LD_VAR 0 1
106432: PPUSH
106433: LD_INT 22
106435: PUSH
106436: LD_OWVAR 2
106440: PUSH
106441: EMPTY
106442: LIST
106443: LIST
106444: PPUSH
106445: CALL_OW 69
106449: PPUSH
106450: LD_VAR 0 1
106454: PPUSH
106455: CALL_OW 74
106459: PPUSH
106460: CALL_OW 115
// until IsDead ( un ) ;
106464: LD_VAR 0 1
106468: PPUSH
106469: CALL_OW 301
106473: IFFALSE 106421
// end ;
106475: PPOPN 1
106477: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
106478: LD_EXP 126
106482: PUSH
106483: LD_EXP 166
106487: AND
106488: IFFALSE 106500
106490: GO 106492
106492: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
106493: LD_STRING earthquake(getX(game), 0, 32)
106495: PPUSH
106496: CALL_OW 559
106500: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
106501: LD_EXP 126
106505: PUSH
106506: LD_EXP 167
106510: AND
106511: IFFALSE 106602
106513: GO 106515
106515: DISABLE
106516: LD_INT 0
106518: PPUSH
// begin enable ;
106519: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
106520: LD_ADDR_VAR 0 1
106524: PUSH
106525: LD_INT 22
106527: PUSH
106528: LD_OWVAR 2
106532: PUSH
106533: EMPTY
106534: LIST
106535: LIST
106536: PUSH
106537: LD_INT 21
106539: PUSH
106540: LD_INT 2
106542: PUSH
106543: EMPTY
106544: LIST
106545: LIST
106546: PUSH
106547: LD_INT 33
106549: PUSH
106550: LD_INT 3
106552: PUSH
106553: EMPTY
106554: LIST
106555: LIST
106556: PUSH
106557: EMPTY
106558: LIST
106559: LIST
106560: LIST
106561: PPUSH
106562: CALL_OW 69
106566: ST_TO_ADDR
// if not tmp then
106567: LD_VAR 0 1
106571: NOT
106572: IFFALSE 106576
// exit ;
106574: GO 106602
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106576: LD_VAR 0 1
106580: PUSH
106581: LD_INT 1
106583: PPUSH
106584: LD_VAR 0 1
106588: PPUSH
106589: CALL_OW 12
106593: ARRAY
106594: PPUSH
106595: LD_INT 1
106597: PPUSH
106598: CALL_OW 234
// end ;
106602: PPOPN 1
106604: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
106605: LD_EXP 126
106609: PUSH
106610: LD_EXP 168
106614: AND
106615: IFFALSE 106756
106617: GO 106619
106619: DISABLE
106620: LD_INT 0
106622: PPUSH
106623: PPUSH
106624: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106625: LD_ADDR_VAR 0 3
106629: PUSH
106630: LD_INT 22
106632: PUSH
106633: LD_OWVAR 2
106637: PUSH
106638: EMPTY
106639: LIST
106640: LIST
106641: PUSH
106642: LD_INT 25
106644: PUSH
106645: LD_INT 1
106647: PUSH
106648: EMPTY
106649: LIST
106650: LIST
106651: PUSH
106652: EMPTY
106653: LIST
106654: LIST
106655: PPUSH
106656: CALL_OW 69
106660: ST_TO_ADDR
// if not tmp then
106661: LD_VAR 0 3
106665: NOT
106666: IFFALSE 106670
// exit ;
106668: GO 106756
// un := tmp [ rand ( 1 , tmp ) ] ;
106670: LD_ADDR_VAR 0 2
106674: PUSH
106675: LD_VAR 0 3
106679: PUSH
106680: LD_INT 1
106682: PPUSH
106683: LD_VAR 0 3
106687: PPUSH
106688: CALL_OW 12
106692: ARRAY
106693: ST_TO_ADDR
// if Crawls ( un ) then
106694: LD_VAR 0 2
106698: PPUSH
106699: CALL_OW 318
106703: IFFALSE 106714
// ComWalk ( un ) ;
106705: LD_VAR 0 2
106709: PPUSH
106710: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
106714: LD_VAR 0 2
106718: PPUSH
106719: LD_INT 9
106721: PPUSH
106722: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
106726: LD_INT 28
106728: PPUSH
106729: LD_OWVAR 2
106733: PPUSH
106734: LD_INT 2
106736: PPUSH
106737: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
106741: LD_INT 29
106743: PPUSH
106744: LD_OWVAR 2
106748: PPUSH
106749: LD_INT 2
106751: PPUSH
106752: CALL_OW 322
// end ;
106756: PPOPN 3
106758: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
106759: LD_EXP 126
106763: PUSH
106764: LD_EXP 169
106768: AND
106769: IFFALSE 106880
106771: GO 106773
106773: DISABLE
106774: LD_INT 0
106776: PPUSH
106777: PPUSH
106778: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106779: LD_ADDR_VAR 0 3
106783: PUSH
106784: LD_INT 22
106786: PUSH
106787: LD_OWVAR 2
106791: PUSH
106792: EMPTY
106793: LIST
106794: LIST
106795: PUSH
106796: LD_INT 25
106798: PUSH
106799: LD_INT 1
106801: PUSH
106802: EMPTY
106803: LIST
106804: LIST
106805: PUSH
106806: EMPTY
106807: LIST
106808: LIST
106809: PPUSH
106810: CALL_OW 69
106814: ST_TO_ADDR
// if not tmp then
106815: LD_VAR 0 3
106819: NOT
106820: IFFALSE 106824
// exit ;
106822: GO 106880
// un := tmp [ rand ( 1 , tmp ) ] ;
106824: LD_ADDR_VAR 0 2
106828: PUSH
106829: LD_VAR 0 3
106833: PUSH
106834: LD_INT 1
106836: PPUSH
106837: LD_VAR 0 3
106841: PPUSH
106842: CALL_OW 12
106846: ARRAY
106847: ST_TO_ADDR
// if Crawls ( un ) then
106848: LD_VAR 0 2
106852: PPUSH
106853: CALL_OW 318
106857: IFFALSE 106868
// ComWalk ( un ) ;
106859: LD_VAR 0 2
106863: PPUSH
106864: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106868: LD_VAR 0 2
106872: PPUSH
106873: LD_INT 8
106875: PPUSH
106876: CALL_OW 336
// end ;
106880: PPOPN 3
106882: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
106883: LD_EXP 126
106887: PUSH
106888: LD_EXP 170
106892: AND
106893: IFFALSE 107037
106895: GO 106897
106897: DISABLE
106898: LD_INT 0
106900: PPUSH
106901: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
106902: LD_ADDR_VAR 0 2
106906: PUSH
106907: LD_INT 22
106909: PUSH
106910: LD_OWVAR 2
106914: PUSH
106915: EMPTY
106916: LIST
106917: LIST
106918: PUSH
106919: LD_INT 21
106921: PUSH
106922: LD_INT 2
106924: PUSH
106925: EMPTY
106926: LIST
106927: LIST
106928: PUSH
106929: LD_INT 2
106931: PUSH
106932: LD_INT 34
106934: PUSH
106935: LD_INT 12
106937: PUSH
106938: EMPTY
106939: LIST
106940: LIST
106941: PUSH
106942: LD_INT 34
106944: PUSH
106945: LD_INT 51
106947: PUSH
106948: EMPTY
106949: LIST
106950: LIST
106951: PUSH
106952: LD_INT 34
106954: PUSH
106955: LD_INT 32
106957: PUSH
106958: EMPTY
106959: LIST
106960: LIST
106961: PUSH
106962: EMPTY
106963: LIST
106964: LIST
106965: LIST
106966: LIST
106967: PUSH
106968: EMPTY
106969: LIST
106970: LIST
106971: LIST
106972: PPUSH
106973: CALL_OW 69
106977: ST_TO_ADDR
// if not tmp then
106978: LD_VAR 0 2
106982: NOT
106983: IFFALSE 106987
// exit ;
106985: GO 107037
// for i in tmp do
106987: LD_ADDR_VAR 0 1
106991: PUSH
106992: LD_VAR 0 2
106996: PUSH
106997: FOR_IN
106998: IFFALSE 107035
// if GetCargo ( i , mat_artifact ) = 0 then
107000: LD_VAR 0 1
107004: PPUSH
107005: LD_INT 4
107007: PPUSH
107008: CALL_OW 289
107012: PUSH
107013: LD_INT 0
107015: EQUAL
107016: IFFALSE 107033
// SetCargo ( i , mat_siberit , 100 ) ;
107018: LD_VAR 0 1
107022: PPUSH
107023: LD_INT 3
107025: PPUSH
107026: LD_INT 100
107028: PPUSH
107029: CALL_OW 290
107033: GO 106997
107035: POP
107036: POP
// end ;
107037: PPOPN 2
107039: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
107040: LD_EXP 126
107044: PUSH
107045: LD_EXP 171
107049: AND
107050: IFFALSE 107233
107052: GO 107054
107054: DISABLE
107055: LD_INT 0
107057: PPUSH
107058: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107059: LD_ADDR_VAR 0 2
107063: PUSH
107064: LD_INT 22
107066: PUSH
107067: LD_OWVAR 2
107071: PUSH
107072: EMPTY
107073: LIST
107074: LIST
107075: PPUSH
107076: CALL_OW 69
107080: ST_TO_ADDR
// if not tmp then
107081: LD_VAR 0 2
107085: NOT
107086: IFFALSE 107090
// exit ;
107088: GO 107233
// for i := 1 to 2 do
107090: LD_ADDR_VAR 0 1
107094: PUSH
107095: DOUBLE
107096: LD_INT 1
107098: DEC
107099: ST_TO_ADDR
107100: LD_INT 2
107102: PUSH
107103: FOR_TO
107104: IFFALSE 107231
// begin uc_side := your_side ;
107106: LD_ADDR_OWVAR 20
107110: PUSH
107111: LD_OWVAR 2
107115: ST_TO_ADDR
// uc_nation := nation_american ;
107116: LD_ADDR_OWVAR 21
107120: PUSH
107121: LD_INT 1
107123: ST_TO_ADDR
// vc_chassis := us_morphling ;
107124: LD_ADDR_OWVAR 37
107128: PUSH
107129: LD_INT 5
107131: ST_TO_ADDR
// vc_engine := engine_siberite ;
107132: LD_ADDR_OWVAR 39
107136: PUSH
107137: LD_INT 3
107139: ST_TO_ADDR
// vc_control := control_computer ;
107140: LD_ADDR_OWVAR 38
107144: PUSH
107145: LD_INT 3
107147: ST_TO_ADDR
// vc_weapon := us_double_laser ;
107148: LD_ADDR_OWVAR 40
107152: PUSH
107153: LD_INT 10
107155: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
107156: LD_VAR 0 2
107160: PUSH
107161: LD_INT 1
107163: ARRAY
107164: PPUSH
107165: CALL_OW 310
107169: NOT
107170: IFFALSE 107217
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
107172: CALL_OW 45
107176: PPUSH
107177: LD_VAR 0 2
107181: PUSH
107182: LD_INT 1
107184: ARRAY
107185: PPUSH
107186: CALL_OW 250
107190: PPUSH
107191: LD_VAR 0 2
107195: PUSH
107196: LD_INT 1
107198: ARRAY
107199: PPUSH
107200: CALL_OW 251
107204: PPUSH
107205: LD_INT 12
107207: PPUSH
107208: LD_INT 1
107210: PPUSH
107211: CALL_OW 50
107215: GO 107229
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
107217: CALL_OW 45
107221: PPUSH
107222: LD_INT 1
107224: PPUSH
107225: CALL_OW 51
// end ;
107229: GO 107103
107231: POP
107232: POP
// end ;
107233: PPOPN 2
107235: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
107236: LD_EXP 126
107240: PUSH
107241: LD_EXP 172
107245: AND
107246: IFFALSE 107468
107248: GO 107250
107250: DISABLE
107251: LD_INT 0
107253: PPUSH
107254: PPUSH
107255: PPUSH
107256: PPUSH
107257: PPUSH
107258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
107259: LD_ADDR_VAR 0 6
107263: PUSH
107264: LD_INT 22
107266: PUSH
107267: LD_OWVAR 2
107271: PUSH
107272: EMPTY
107273: LIST
107274: LIST
107275: PUSH
107276: LD_INT 21
107278: PUSH
107279: LD_INT 1
107281: PUSH
107282: EMPTY
107283: LIST
107284: LIST
107285: PUSH
107286: LD_INT 3
107288: PUSH
107289: LD_INT 23
107291: PUSH
107292: LD_INT 0
107294: PUSH
107295: EMPTY
107296: LIST
107297: LIST
107298: PUSH
107299: EMPTY
107300: LIST
107301: LIST
107302: PUSH
107303: EMPTY
107304: LIST
107305: LIST
107306: LIST
107307: PPUSH
107308: CALL_OW 69
107312: ST_TO_ADDR
// if not tmp then
107313: LD_VAR 0 6
107317: NOT
107318: IFFALSE 107322
// exit ;
107320: GO 107468
// s1 := rand ( 1 , 4 ) ;
107322: LD_ADDR_VAR 0 2
107326: PUSH
107327: LD_INT 1
107329: PPUSH
107330: LD_INT 4
107332: PPUSH
107333: CALL_OW 12
107337: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
107338: LD_ADDR_VAR 0 4
107342: PUSH
107343: LD_VAR 0 6
107347: PUSH
107348: LD_INT 1
107350: ARRAY
107351: PPUSH
107352: LD_VAR 0 2
107356: PPUSH
107357: CALL_OW 259
107361: ST_TO_ADDR
// if s1 = 1 then
107362: LD_VAR 0 2
107366: PUSH
107367: LD_INT 1
107369: EQUAL
107370: IFFALSE 107390
// s2 := rand ( 2 , 4 ) else
107372: LD_ADDR_VAR 0 3
107376: PUSH
107377: LD_INT 2
107379: PPUSH
107380: LD_INT 4
107382: PPUSH
107383: CALL_OW 12
107387: ST_TO_ADDR
107388: GO 107398
// s2 := 1 ;
107390: LD_ADDR_VAR 0 3
107394: PUSH
107395: LD_INT 1
107397: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
107398: LD_ADDR_VAR 0 5
107402: PUSH
107403: LD_VAR 0 6
107407: PUSH
107408: LD_INT 1
107410: ARRAY
107411: PPUSH
107412: LD_VAR 0 3
107416: PPUSH
107417: CALL_OW 259
107421: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
107422: LD_VAR 0 6
107426: PUSH
107427: LD_INT 1
107429: ARRAY
107430: PPUSH
107431: LD_VAR 0 2
107435: PPUSH
107436: LD_VAR 0 5
107440: PPUSH
107441: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
107445: LD_VAR 0 6
107449: PUSH
107450: LD_INT 1
107452: ARRAY
107453: PPUSH
107454: LD_VAR 0 3
107458: PPUSH
107459: LD_VAR 0 4
107463: PPUSH
107464: CALL_OW 237
// end ;
107468: PPOPN 6
107470: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
107471: LD_EXP 126
107475: PUSH
107476: LD_EXP 173
107480: AND
107481: IFFALSE 107560
107483: GO 107485
107485: DISABLE
107486: LD_INT 0
107488: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
107489: LD_ADDR_VAR 0 1
107493: PUSH
107494: LD_INT 22
107496: PUSH
107497: LD_OWVAR 2
107501: PUSH
107502: EMPTY
107503: LIST
107504: LIST
107505: PUSH
107506: LD_INT 30
107508: PUSH
107509: LD_INT 3
107511: PUSH
107512: EMPTY
107513: LIST
107514: LIST
107515: PUSH
107516: EMPTY
107517: LIST
107518: LIST
107519: PPUSH
107520: CALL_OW 69
107524: ST_TO_ADDR
// if not tmp then
107525: LD_VAR 0 1
107529: NOT
107530: IFFALSE 107534
// exit ;
107532: GO 107560
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
107534: LD_VAR 0 1
107538: PUSH
107539: LD_INT 1
107541: PPUSH
107542: LD_VAR 0 1
107546: PPUSH
107547: CALL_OW 12
107551: ARRAY
107552: PPUSH
107553: LD_INT 1
107555: PPUSH
107556: CALL_OW 234
// end ;
107560: PPOPN 1
107562: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
107563: LD_EXP 126
107567: PUSH
107568: LD_EXP 174
107572: AND
107573: IFFALSE 107685
107575: GO 107577
107577: DISABLE
107578: LD_INT 0
107580: PPUSH
107581: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
107582: LD_ADDR_VAR 0 2
107586: PUSH
107587: LD_INT 22
107589: PUSH
107590: LD_OWVAR 2
107594: PUSH
107595: EMPTY
107596: LIST
107597: LIST
107598: PUSH
107599: LD_INT 2
107601: PUSH
107602: LD_INT 30
107604: PUSH
107605: LD_INT 27
107607: PUSH
107608: EMPTY
107609: LIST
107610: LIST
107611: PUSH
107612: LD_INT 30
107614: PUSH
107615: LD_INT 26
107617: PUSH
107618: EMPTY
107619: LIST
107620: LIST
107621: PUSH
107622: LD_INT 30
107624: PUSH
107625: LD_INT 28
107627: PUSH
107628: EMPTY
107629: LIST
107630: LIST
107631: PUSH
107632: EMPTY
107633: LIST
107634: LIST
107635: LIST
107636: LIST
107637: PUSH
107638: EMPTY
107639: LIST
107640: LIST
107641: PPUSH
107642: CALL_OW 69
107646: ST_TO_ADDR
// if not tmp then
107647: LD_VAR 0 2
107651: NOT
107652: IFFALSE 107656
// exit ;
107654: GO 107685
// for i in tmp do
107656: LD_ADDR_VAR 0 1
107660: PUSH
107661: LD_VAR 0 2
107665: PUSH
107666: FOR_IN
107667: IFFALSE 107683
// SetLives ( i , 1 ) ;
107669: LD_VAR 0 1
107673: PPUSH
107674: LD_INT 1
107676: PPUSH
107677: CALL_OW 234
107681: GO 107666
107683: POP
107684: POP
// end ;
107685: PPOPN 2
107687: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
107688: LD_EXP 126
107692: PUSH
107693: LD_EXP 175
107697: AND
107698: IFFALSE 107985
107700: GO 107702
107702: DISABLE
107703: LD_INT 0
107705: PPUSH
107706: PPUSH
107707: PPUSH
// begin i := rand ( 1 , 7 ) ;
107708: LD_ADDR_VAR 0 1
107712: PUSH
107713: LD_INT 1
107715: PPUSH
107716: LD_INT 7
107718: PPUSH
107719: CALL_OW 12
107723: ST_TO_ADDR
// case i of 1 :
107724: LD_VAR 0 1
107728: PUSH
107729: LD_INT 1
107731: DOUBLE
107732: EQUAL
107733: IFTRUE 107737
107735: GO 107747
107737: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
107738: LD_STRING earthquake(getX(game), 0, 32)
107740: PPUSH
107741: CALL_OW 559
107745: GO 107985
107747: LD_INT 2
107749: DOUBLE
107750: EQUAL
107751: IFTRUE 107755
107753: GO 107769
107755: POP
// begin ToLua ( displayStucuk(); ) ;
107756: LD_STRING displayStucuk();
107758: PPUSH
107759: CALL_OW 559
// ResetFog ;
107763: CALL_OW 335
// end ; 3 :
107767: GO 107985
107769: LD_INT 3
107771: DOUBLE
107772: EQUAL
107773: IFTRUE 107777
107775: GO 107881
107777: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107778: LD_ADDR_VAR 0 2
107782: PUSH
107783: LD_INT 22
107785: PUSH
107786: LD_OWVAR 2
107790: PUSH
107791: EMPTY
107792: LIST
107793: LIST
107794: PUSH
107795: LD_INT 25
107797: PUSH
107798: LD_INT 1
107800: PUSH
107801: EMPTY
107802: LIST
107803: LIST
107804: PUSH
107805: EMPTY
107806: LIST
107807: LIST
107808: PPUSH
107809: CALL_OW 69
107813: ST_TO_ADDR
// if not tmp then
107814: LD_VAR 0 2
107818: NOT
107819: IFFALSE 107823
// exit ;
107821: GO 107985
// un := tmp [ rand ( 1 , tmp ) ] ;
107823: LD_ADDR_VAR 0 3
107827: PUSH
107828: LD_VAR 0 2
107832: PUSH
107833: LD_INT 1
107835: PPUSH
107836: LD_VAR 0 2
107840: PPUSH
107841: CALL_OW 12
107845: ARRAY
107846: ST_TO_ADDR
// if Crawls ( un ) then
107847: LD_VAR 0 3
107851: PPUSH
107852: CALL_OW 318
107856: IFFALSE 107867
// ComWalk ( un ) ;
107858: LD_VAR 0 3
107862: PPUSH
107863: CALL_OW 138
// SetClass ( un , class_mortar ) ;
107867: LD_VAR 0 3
107871: PPUSH
107872: LD_INT 8
107874: PPUSH
107875: CALL_OW 336
// end ; 4 :
107879: GO 107985
107881: LD_INT 4
107883: DOUBLE
107884: EQUAL
107885: IFTRUE 107889
107887: GO 107963
107889: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
107890: LD_ADDR_VAR 0 2
107894: PUSH
107895: LD_INT 22
107897: PUSH
107898: LD_OWVAR 2
107902: PUSH
107903: EMPTY
107904: LIST
107905: LIST
107906: PUSH
107907: LD_INT 30
107909: PUSH
107910: LD_INT 29
107912: PUSH
107913: EMPTY
107914: LIST
107915: LIST
107916: PUSH
107917: EMPTY
107918: LIST
107919: LIST
107920: PPUSH
107921: CALL_OW 69
107925: ST_TO_ADDR
// if not tmp then
107926: LD_VAR 0 2
107930: NOT
107931: IFFALSE 107935
// exit ;
107933: GO 107985
// CenterNowOnUnits ( tmp [ 1 ] ) ;
107935: LD_VAR 0 2
107939: PUSH
107940: LD_INT 1
107942: ARRAY
107943: PPUSH
107944: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
107948: LD_VAR 0 2
107952: PUSH
107953: LD_INT 1
107955: ARRAY
107956: PPUSH
107957: CALL_OW 65
// end ; 5 .. 7 :
107961: GO 107985
107963: LD_INT 5
107965: DOUBLE
107966: GREATEREQUAL
107967: IFFALSE 107975
107969: LD_INT 7
107971: DOUBLE
107972: LESSEQUAL
107973: IFTRUE 107977
107975: GO 107984
107977: POP
// StreamSibBomb ; end ;
107978: CALL 104222 0 0
107982: GO 107985
107984: POP
// end ;
107985: PPOPN 3
107987: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
107988: LD_EXP 126
107992: PUSH
107993: LD_EXP 176
107997: AND
107998: IFFALSE 108154
108000: GO 108002
108002: DISABLE
108003: LD_INT 0
108005: PPUSH
108006: PPUSH
108007: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
108008: LD_ADDR_VAR 0 2
108012: PUSH
108013: LD_INT 81
108015: PUSH
108016: LD_OWVAR 2
108020: PUSH
108021: EMPTY
108022: LIST
108023: LIST
108024: PUSH
108025: LD_INT 2
108027: PUSH
108028: LD_INT 21
108030: PUSH
108031: LD_INT 1
108033: PUSH
108034: EMPTY
108035: LIST
108036: LIST
108037: PUSH
108038: LD_INT 21
108040: PUSH
108041: LD_INT 2
108043: PUSH
108044: EMPTY
108045: LIST
108046: LIST
108047: PUSH
108048: EMPTY
108049: LIST
108050: LIST
108051: LIST
108052: PUSH
108053: EMPTY
108054: LIST
108055: LIST
108056: PPUSH
108057: CALL_OW 69
108061: ST_TO_ADDR
// if not tmp then
108062: LD_VAR 0 2
108066: NOT
108067: IFFALSE 108071
// exit ;
108069: GO 108154
// p := 0 ;
108071: LD_ADDR_VAR 0 3
108075: PUSH
108076: LD_INT 0
108078: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108079: LD_INT 35
108081: PPUSH
108082: CALL_OW 67
// p := p + 1 ;
108086: LD_ADDR_VAR 0 3
108090: PUSH
108091: LD_VAR 0 3
108095: PUSH
108096: LD_INT 1
108098: PLUS
108099: ST_TO_ADDR
// for i in tmp do
108100: LD_ADDR_VAR 0 1
108104: PUSH
108105: LD_VAR 0 2
108109: PUSH
108110: FOR_IN
108111: IFFALSE 108142
// if GetLives ( i ) < 1000 then
108113: LD_VAR 0 1
108117: PPUSH
108118: CALL_OW 256
108122: PUSH
108123: LD_INT 1000
108125: LESS
108126: IFFALSE 108140
// SetLives ( i , 1000 ) ;
108128: LD_VAR 0 1
108132: PPUSH
108133: LD_INT 1000
108135: PPUSH
108136: CALL_OW 234
108140: GO 108110
108142: POP
108143: POP
// until p > 20 ;
108144: LD_VAR 0 3
108148: PUSH
108149: LD_INT 20
108151: GREATER
108152: IFFALSE 108079
// end ;
108154: PPOPN 3
108156: END
// every 0 0$1 trigger StreamModeActive and sTime do
108157: LD_EXP 126
108161: PUSH
108162: LD_EXP 177
108166: AND
108167: IFFALSE 108202
108169: GO 108171
108171: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
108172: LD_INT 28
108174: PPUSH
108175: LD_OWVAR 2
108179: PPUSH
108180: LD_INT 2
108182: PPUSH
108183: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
108187: LD_INT 30
108189: PPUSH
108190: LD_OWVAR 2
108194: PPUSH
108195: LD_INT 2
108197: PPUSH
108198: CALL_OW 322
// end ;
108202: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
108203: LD_EXP 126
108207: PUSH
108208: LD_EXP 178
108212: AND
108213: IFFALSE 108334
108215: GO 108217
108217: DISABLE
108218: LD_INT 0
108220: PPUSH
108221: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108222: LD_ADDR_VAR 0 2
108226: PUSH
108227: LD_INT 22
108229: PUSH
108230: LD_OWVAR 2
108234: PUSH
108235: EMPTY
108236: LIST
108237: LIST
108238: PUSH
108239: LD_INT 21
108241: PUSH
108242: LD_INT 1
108244: PUSH
108245: EMPTY
108246: LIST
108247: LIST
108248: PUSH
108249: LD_INT 3
108251: PUSH
108252: LD_INT 23
108254: PUSH
108255: LD_INT 0
108257: PUSH
108258: EMPTY
108259: LIST
108260: LIST
108261: PUSH
108262: EMPTY
108263: LIST
108264: LIST
108265: PUSH
108266: EMPTY
108267: LIST
108268: LIST
108269: LIST
108270: PPUSH
108271: CALL_OW 69
108275: ST_TO_ADDR
// if not tmp then
108276: LD_VAR 0 2
108280: NOT
108281: IFFALSE 108285
// exit ;
108283: GO 108334
// for i in tmp do
108285: LD_ADDR_VAR 0 1
108289: PUSH
108290: LD_VAR 0 2
108294: PUSH
108295: FOR_IN
108296: IFFALSE 108332
// begin if Crawls ( i ) then
108298: LD_VAR 0 1
108302: PPUSH
108303: CALL_OW 318
108307: IFFALSE 108318
// ComWalk ( i ) ;
108309: LD_VAR 0 1
108313: PPUSH
108314: CALL_OW 138
// SetClass ( i , 2 ) ;
108318: LD_VAR 0 1
108322: PPUSH
108323: LD_INT 2
108325: PPUSH
108326: CALL_OW 336
// end ;
108330: GO 108295
108332: POP
108333: POP
// end ;
108334: PPOPN 2
108336: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
108337: LD_EXP 126
108341: PUSH
108342: LD_EXP 179
108346: AND
108347: IFFALSE 108635
108349: GO 108351
108351: DISABLE
108352: LD_INT 0
108354: PPUSH
108355: PPUSH
108356: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
108357: LD_OWVAR 2
108361: PPUSH
108362: LD_INT 9
108364: PPUSH
108365: LD_INT 1
108367: PPUSH
108368: LD_INT 1
108370: PPUSH
108371: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
108375: LD_INT 9
108377: PPUSH
108378: LD_OWVAR 2
108382: PPUSH
108383: CALL_OW 343
// uc_side := 9 ;
108387: LD_ADDR_OWVAR 20
108391: PUSH
108392: LD_INT 9
108394: ST_TO_ADDR
// uc_nation := 2 ;
108395: LD_ADDR_OWVAR 21
108399: PUSH
108400: LD_INT 2
108402: ST_TO_ADDR
// hc_name := Dark Warrior ;
108403: LD_ADDR_OWVAR 26
108407: PUSH
108408: LD_STRING Dark Warrior
108410: ST_TO_ADDR
// hc_gallery :=  ;
108411: LD_ADDR_OWVAR 33
108415: PUSH
108416: LD_STRING 
108418: ST_TO_ADDR
// hc_noskilllimit := true ;
108419: LD_ADDR_OWVAR 76
108423: PUSH
108424: LD_INT 1
108426: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
108427: LD_ADDR_OWVAR 31
108431: PUSH
108432: LD_INT 30
108434: PUSH
108435: LD_INT 30
108437: PUSH
108438: LD_INT 30
108440: PUSH
108441: LD_INT 30
108443: PUSH
108444: EMPTY
108445: LIST
108446: LIST
108447: LIST
108448: LIST
108449: ST_TO_ADDR
// un := CreateHuman ;
108450: LD_ADDR_VAR 0 3
108454: PUSH
108455: CALL_OW 44
108459: ST_TO_ADDR
// hc_noskilllimit := false ;
108460: LD_ADDR_OWVAR 76
108464: PUSH
108465: LD_INT 0
108467: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
108468: LD_VAR 0 3
108472: PPUSH
108473: LD_INT 1
108475: PPUSH
108476: CALL_OW 51
// ToLua ( playRanger() ) ;
108480: LD_STRING playRanger()
108482: PPUSH
108483: CALL_OW 559
// p := 0 ;
108487: LD_ADDR_VAR 0 2
108491: PUSH
108492: LD_INT 0
108494: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108495: LD_INT 35
108497: PPUSH
108498: CALL_OW 67
// p := p + 1 ;
108502: LD_ADDR_VAR 0 2
108506: PUSH
108507: LD_VAR 0 2
108511: PUSH
108512: LD_INT 1
108514: PLUS
108515: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
108516: LD_VAR 0 3
108520: PPUSH
108521: CALL_OW 256
108525: PUSH
108526: LD_INT 1000
108528: LESS
108529: IFFALSE 108543
// SetLives ( un , 1000 ) ;
108531: LD_VAR 0 3
108535: PPUSH
108536: LD_INT 1000
108538: PPUSH
108539: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
108543: LD_VAR 0 3
108547: PPUSH
108548: LD_INT 81
108550: PUSH
108551: LD_OWVAR 2
108555: PUSH
108556: EMPTY
108557: LIST
108558: LIST
108559: PUSH
108560: LD_INT 91
108562: PUSH
108563: LD_VAR 0 3
108567: PUSH
108568: LD_INT 30
108570: PUSH
108571: EMPTY
108572: LIST
108573: LIST
108574: LIST
108575: PUSH
108576: EMPTY
108577: LIST
108578: LIST
108579: PPUSH
108580: CALL_OW 69
108584: PPUSH
108585: LD_VAR 0 3
108589: PPUSH
108590: CALL_OW 74
108594: PPUSH
108595: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
108599: LD_VAR 0 2
108603: PUSH
108604: LD_INT 80
108606: GREATER
108607: PUSH
108608: LD_VAR 0 3
108612: PPUSH
108613: CALL_OW 301
108617: OR
108618: IFFALSE 108495
// if un then
108620: LD_VAR 0 3
108624: IFFALSE 108635
// RemoveUnit ( un ) ;
108626: LD_VAR 0 3
108630: PPUSH
108631: CALL_OW 64
// end ;
108635: PPOPN 3
108637: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
108638: LD_EXP 180
108642: IFFALSE 108758
108644: GO 108646
108646: DISABLE
108647: LD_INT 0
108649: PPUSH
108650: PPUSH
108651: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
108652: LD_ADDR_VAR 0 2
108656: PUSH
108657: LD_INT 81
108659: PUSH
108660: LD_OWVAR 2
108664: PUSH
108665: EMPTY
108666: LIST
108667: LIST
108668: PUSH
108669: LD_INT 21
108671: PUSH
108672: LD_INT 1
108674: PUSH
108675: EMPTY
108676: LIST
108677: LIST
108678: PUSH
108679: EMPTY
108680: LIST
108681: LIST
108682: PPUSH
108683: CALL_OW 69
108687: ST_TO_ADDR
// ToLua ( playComputer() ) ;
108688: LD_STRING playComputer()
108690: PPUSH
108691: CALL_OW 559
// if not tmp then
108695: LD_VAR 0 2
108699: NOT
108700: IFFALSE 108704
// exit ;
108702: GO 108758
// for i in tmp do
108704: LD_ADDR_VAR 0 1
108708: PUSH
108709: LD_VAR 0 2
108713: PUSH
108714: FOR_IN
108715: IFFALSE 108756
// for j := 1 to 4 do
108717: LD_ADDR_VAR 0 3
108721: PUSH
108722: DOUBLE
108723: LD_INT 1
108725: DEC
108726: ST_TO_ADDR
108727: LD_INT 4
108729: PUSH
108730: FOR_TO
108731: IFFALSE 108752
// SetSkill ( i , j , 10 ) ;
108733: LD_VAR 0 1
108737: PPUSH
108738: LD_VAR 0 3
108742: PPUSH
108743: LD_INT 10
108745: PPUSH
108746: CALL_OW 237
108750: GO 108730
108752: POP
108753: POP
108754: GO 108714
108756: POP
108757: POP
// end ;
108758: PPOPN 3
108760: END
// every 0 0$1 trigger s30 do var i , tmp ;
108761: LD_EXP 181
108765: IFFALSE 108834
108767: GO 108769
108769: DISABLE
108770: LD_INT 0
108772: PPUSH
108773: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108774: LD_ADDR_VAR 0 2
108778: PUSH
108779: LD_INT 22
108781: PUSH
108782: LD_OWVAR 2
108786: PUSH
108787: EMPTY
108788: LIST
108789: LIST
108790: PPUSH
108791: CALL_OW 69
108795: ST_TO_ADDR
// if not tmp then
108796: LD_VAR 0 2
108800: NOT
108801: IFFALSE 108805
// exit ;
108803: GO 108834
// for i in tmp do
108805: LD_ADDR_VAR 0 1
108809: PUSH
108810: LD_VAR 0 2
108814: PUSH
108815: FOR_IN
108816: IFFALSE 108832
// SetLives ( i , 300 ) ;
108818: LD_VAR 0 1
108822: PPUSH
108823: LD_INT 300
108825: PPUSH
108826: CALL_OW 234
108830: GO 108815
108832: POP
108833: POP
// end ;
108834: PPOPN 2
108836: END
// every 0 0$1 trigger s60 do var i , tmp ;
108837: LD_EXP 182
108841: IFFALSE 108910
108843: GO 108845
108845: DISABLE
108846: LD_INT 0
108848: PPUSH
108849: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108850: LD_ADDR_VAR 0 2
108854: PUSH
108855: LD_INT 22
108857: PUSH
108858: LD_OWVAR 2
108862: PUSH
108863: EMPTY
108864: LIST
108865: LIST
108866: PPUSH
108867: CALL_OW 69
108871: ST_TO_ADDR
// if not tmp then
108872: LD_VAR 0 2
108876: NOT
108877: IFFALSE 108881
// exit ;
108879: GO 108910
// for i in tmp do
108881: LD_ADDR_VAR 0 1
108885: PUSH
108886: LD_VAR 0 2
108890: PUSH
108891: FOR_IN
108892: IFFALSE 108908
// SetLives ( i , 600 ) ;
108894: LD_VAR 0 1
108898: PPUSH
108899: LD_INT 600
108901: PPUSH
108902: CALL_OW 234
108906: GO 108891
108908: POP
108909: POP
// end ;
108910: PPOPN 2
108912: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108913: LD_INT 0
108915: PPUSH
// case cmd of 301 :
108916: LD_VAR 0 1
108920: PUSH
108921: LD_INT 301
108923: DOUBLE
108924: EQUAL
108925: IFTRUE 108929
108927: GO 108961
108929: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
108930: LD_VAR 0 6
108934: PPUSH
108935: LD_VAR 0 7
108939: PPUSH
108940: LD_VAR 0 8
108944: PPUSH
108945: LD_VAR 0 4
108949: PPUSH
108950: LD_VAR 0 5
108954: PPUSH
108955: CALL 110170 0 5
108959: GO 109082
108961: LD_INT 302
108963: DOUBLE
108964: EQUAL
108965: IFTRUE 108969
108967: GO 109006
108969: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
108970: LD_VAR 0 6
108974: PPUSH
108975: LD_VAR 0 7
108979: PPUSH
108980: LD_VAR 0 8
108984: PPUSH
108985: LD_VAR 0 9
108989: PPUSH
108990: LD_VAR 0 4
108994: PPUSH
108995: LD_VAR 0 5
108999: PPUSH
109000: CALL 110261 0 6
109004: GO 109082
109006: LD_INT 303
109008: DOUBLE
109009: EQUAL
109010: IFTRUE 109014
109012: GO 109051
109014: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
109015: LD_VAR 0 6
109019: PPUSH
109020: LD_VAR 0 7
109024: PPUSH
109025: LD_VAR 0 8
109029: PPUSH
109030: LD_VAR 0 9
109034: PPUSH
109035: LD_VAR 0 4
109039: PPUSH
109040: LD_VAR 0 5
109044: PPUSH
109045: CALL 109087 0 6
109049: GO 109082
109051: LD_INT 304
109053: DOUBLE
109054: EQUAL
109055: IFTRUE 109059
109057: GO 109081
109059: POP
// hHackTeleport ( unit , x , y ) ; end ;
109060: LD_VAR 0 2
109064: PPUSH
109065: LD_VAR 0 4
109069: PPUSH
109070: LD_VAR 0 5
109074: PPUSH
109075: CALL 110854 0 3
109079: GO 109082
109081: POP
// end ;
109082: LD_VAR 0 12
109086: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
109087: LD_INT 0
109089: PPUSH
109090: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
109091: LD_VAR 0 1
109095: PUSH
109096: LD_INT 1
109098: LESS
109099: PUSH
109100: LD_VAR 0 1
109104: PUSH
109105: LD_INT 3
109107: GREATER
109108: OR
109109: PUSH
109110: LD_VAR 0 5
109114: PPUSH
109115: LD_VAR 0 6
109119: PPUSH
109120: CALL_OW 428
109124: OR
109125: IFFALSE 109129
// exit ;
109127: GO 109857
// uc_side := your_side ;
109129: LD_ADDR_OWVAR 20
109133: PUSH
109134: LD_OWVAR 2
109138: ST_TO_ADDR
// uc_nation := nation ;
109139: LD_ADDR_OWVAR 21
109143: PUSH
109144: LD_VAR 0 1
109148: ST_TO_ADDR
// bc_level = 1 ;
109149: LD_ADDR_OWVAR 43
109153: PUSH
109154: LD_INT 1
109156: ST_TO_ADDR
// case btype of 1 :
109157: LD_VAR 0 2
109161: PUSH
109162: LD_INT 1
109164: DOUBLE
109165: EQUAL
109166: IFTRUE 109170
109168: GO 109181
109170: POP
// bc_type := b_depot ; 2 :
109171: LD_ADDR_OWVAR 42
109175: PUSH
109176: LD_INT 0
109178: ST_TO_ADDR
109179: GO 109801
109181: LD_INT 2
109183: DOUBLE
109184: EQUAL
109185: IFTRUE 109189
109187: GO 109200
109189: POP
// bc_type := b_warehouse ; 3 :
109190: LD_ADDR_OWVAR 42
109194: PUSH
109195: LD_INT 1
109197: ST_TO_ADDR
109198: GO 109801
109200: LD_INT 3
109202: DOUBLE
109203: EQUAL
109204: IFTRUE 109208
109206: GO 109219
109208: POP
// bc_type := b_lab ; 4 .. 9 :
109209: LD_ADDR_OWVAR 42
109213: PUSH
109214: LD_INT 6
109216: ST_TO_ADDR
109217: GO 109801
109219: LD_INT 4
109221: DOUBLE
109222: GREATEREQUAL
109223: IFFALSE 109231
109225: LD_INT 9
109227: DOUBLE
109228: LESSEQUAL
109229: IFTRUE 109233
109231: GO 109293
109233: POP
// begin bc_type := b_lab_half ;
109234: LD_ADDR_OWVAR 42
109238: PUSH
109239: LD_INT 7
109241: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
109242: LD_ADDR_OWVAR 44
109246: PUSH
109247: LD_INT 10
109249: PUSH
109250: LD_INT 11
109252: PUSH
109253: LD_INT 12
109255: PUSH
109256: LD_INT 15
109258: PUSH
109259: LD_INT 14
109261: PUSH
109262: LD_INT 13
109264: PUSH
109265: EMPTY
109266: LIST
109267: LIST
109268: LIST
109269: LIST
109270: LIST
109271: LIST
109272: PUSH
109273: LD_VAR 0 2
109277: PUSH
109278: LD_INT 3
109280: MINUS
109281: ARRAY
109282: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
109283: LD_ADDR_OWVAR 45
109287: PUSH
109288: LD_INT 9
109290: ST_TO_ADDR
// end ; 10 .. 13 :
109291: GO 109801
109293: LD_INT 10
109295: DOUBLE
109296: GREATEREQUAL
109297: IFFALSE 109305
109299: LD_INT 13
109301: DOUBLE
109302: LESSEQUAL
109303: IFTRUE 109307
109305: GO 109384
109307: POP
// begin bc_type := b_lab_full ;
109308: LD_ADDR_OWVAR 42
109312: PUSH
109313: LD_INT 8
109315: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
109316: LD_ADDR_OWVAR 44
109320: PUSH
109321: LD_INT 10
109323: PUSH
109324: LD_INT 12
109326: PUSH
109327: LD_INT 14
109329: PUSH
109330: LD_INT 13
109332: PUSH
109333: EMPTY
109334: LIST
109335: LIST
109336: LIST
109337: LIST
109338: PUSH
109339: LD_VAR 0 2
109343: PUSH
109344: LD_INT 9
109346: MINUS
109347: ARRAY
109348: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
109349: LD_ADDR_OWVAR 45
109353: PUSH
109354: LD_INT 11
109356: PUSH
109357: LD_INT 15
109359: PUSH
109360: LD_INT 12
109362: PUSH
109363: LD_INT 15
109365: PUSH
109366: EMPTY
109367: LIST
109368: LIST
109369: LIST
109370: LIST
109371: PUSH
109372: LD_VAR 0 2
109376: PUSH
109377: LD_INT 9
109379: MINUS
109380: ARRAY
109381: ST_TO_ADDR
// end ; 14 :
109382: GO 109801
109384: LD_INT 14
109386: DOUBLE
109387: EQUAL
109388: IFTRUE 109392
109390: GO 109403
109392: POP
// bc_type := b_workshop ; 15 :
109393: LD_ADDR_OWVAR 42
109397: PUSH
109398: LD_INT 2
109400: ST_TO_ADDR
109401: GO 109801
109403: LD_INT 15
109405: DOUBLE
109406: EQUAL
109407: IFTRUE 109411
109409: GO 109422
109411: POP
// bc_type := b_factory ; 16 :
109412: LD_ADDR_OWVAR 42
109416: PUSH
109417: LD_INT 3
109419: ST_TO_ADDR
109420: GO 109801
109422: LD_INT 16
109424: DOUBLE
109425: EQUAL
109426: IFTRUE 109430
109428: GO 109441
109430: POP
// bc_type := b_ext_gun ; 17 :
109431: LD_ADDR_OWVAR 42
109435: PUSH
109436: LD_INT 17
109438: ST_TO_ADDR
109439: GO 109801
109441: LD_INT 17
109443: DOUBLE
109444: EQUAL
109445: IFTRUE 109449
109447: GO 109477
109449: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
109450: LD_ADDR_OWVAR 42
109454: PUSH
109455: LD_INT 19
109457: PUSH
109458: LD_INT 23
109460: PUSH
109461: LD_INT 19
109463: PUSH
109464: EMPTY
109465: LIST
109466: LIST
109467: LIST
109468: PUSH
109469: LD_VAR 0 1
109473: ARRAY
109474: ST_TO_ADDR
109475: GO 109801
109477: LD_INT 18
109479: DOUBLE
109480: EQUAL
109481: IFTRUE 109485
109483: GO 109496
109485: POP
// bc_type := b_ext_radar ; 19 :
109486: LD_ADDR_OWVAR 42
109490: PUSH
109491: LD_INT 20
109493: ST_TO_ADDR
109494: GO 109801
109496: LD_INT 19
109498: DOUBLE
109499: EQUAL
109500: IFTRUE 109504
109502: GO 109515
109504: POP
// bc_type := b_ext_radio ; 20 :
109505: LD_ADDR_OWVAR 42
109509: PUSH
109510: LD_INT 22
109512: ST_TO_ADDR
109513: GO 109801
109515: LD_INT 20
109517: DOUBLE
109518: EQUAL
109519: IFTRUE 109523
109521: GO 109534
109523: POP
// bc_type := b_ext_siberium ; 21 :
109524: LD_ADDR_OWVAR 42
109528: PUSH
109529: LD_INT 21
109531: ST_TO_ADDR
109532: GO 109801
109534: LD_INT 21
109536: DOUBLE
109537: EQUAL
109538: IFTRUE 109542
109540: GO 109553
109542: POP
// bc_type := b_ext_computer ; 22 :
109543: LD_ADDR_OWVAR 42
109547: PUSH
109548: LD_INT 24
109550: ST_TO_ADDR
109551: GO 109801
109553: LD_INT 22
109555: DOUBLE
109556: EQUAL
109557: IFTRUE 109561
109559: GO 109572
109561: POP
// bc_type := b_ext_track ; 23 :
109562: LD_ADDR_OWVAR 42
109566: PUSH
109567: LD_INT 16
109569: ST_TO_ADDR
109570: GO 109801
109572: LD_INT 23
109574: DOUBLE
109575: EQUAL
109576: IFTRUE 109580
109578: GO 109591
109580: POP
// bc_type := b_ext_laser ; 24 :
109581: LD_ADDR_OWVAR 42
109585: PUSH
109586: LD_INT 25
109588: ST_TO_ADDR
109589: GO 109801
109591: LD_INT 24
109593: DOUBLE
109594: EQUAL
109595: IFTRUE 109599
109597: GO 109610
109599: POP
// bc_type := b_control_tower ; 25 :
109600: LD_ADDR_OWVAR 42
109604: PUSH
109605: LD_INT 36
109607: ST_TO_ADDR
109608: GO 109801
109610: LD_INT 25
109612: DOUBLE
109613: EQUAL
109614: IFTRUE 109618
109616: GO 109629
109618: POP
// bc_type := b_breastwork ; 26 :
109619: LD_ADDR_OWVAR 42
109623: PUSH
109624: LD_INT 31
109626: ST_TO_ADDR
109627: GO 109801
109629: LD_INT 26
109631: DOUBLE
109632: EQUAL
109633: IFTRUE 109637
109635: GO 109648
109637: POP
// bc_type := b_bunker ; 27 :
109638: LD_ADDR_OWVAR 42
109642: PUSH
109643: LD_INT 32
109645: ST_TO_ADDR
109646: GO 109801
109648: LD_INT 27
109650: DOUBLE
109651: EQUAL
109652: IFTRUE 109656
109654: GO 109667
109656: POP
// bc_type := b_turret ; 28 :
109657: LD_ADDR_OWVAR 42
109661: PUSH
109662: LD_INT 33
109664: ST_TO_ADDR
109665: GO 109801
109667: LD_INT 28
109669: DOUBLE
109670: EQUAL
109671: IFTRUE 109675
109673: GO 109686
109675: POP
// bc_type := b_armoury ; 29 :
109676: LD_ADDR_OWVAR 42
109680: PUSH
109681: LD_INT 4
109683: ST_TO_ADDR
109684: GO 109801
109686: LD_INT 29
109688: DOUBLE
109689: EQUAL
109690: IFTRUE 109694
109692: GO 109705
109694: POP
// bc_type := b_barracks ; 30 :
109695: LD_ADDR_OWVAR 42
109699: PUSH
109700: LD_INT 5
109702: ST_TO_ADDR
109703: GO 109801
109705: LD_INT 30
109707: DOUBLE
109708: EQUAL
109709: IFTRUE 109713
109711: GO 109724
109713: POP
// bc_type := b_solar_power ; 31 :
109714: LD_ADDR_OWVAR 42
109718: PUSH
109719: LD_INT 27
109721: ST_TO_ADDR
109722: GO 109801
109724: LD_INT 31
109726: DOUBLE
109727: EQUAL
109728: IFTRUE 109732
109730: GO 109743
109732: POP
// bc_type := b_oil_power ; 32 :
109733: LD_ADDR_OWVAR 42
109737: PUSH
109738: LD_INT 26
109740: ST_TO_ADDR
109741: GO 109801
109743: LD_INT 32
109745: DOUBLE
109746: EQUAL
109747: IFTRUE 109751
109749: GO 109762
109751: POP
// bc_type := b_siberite_power ; 33 :
109752: LD_ADDR_OWVAR 42
109756: PUSH
109757: LD_INT 28
109759: ST_TO_ADDR
109760: GO 109801
109762: LD_INT 33
109764: DOUBLE
109765: EQUAL
109766: IFTRUE 109770
109768: GO 109781
109770: POP
// bc_type := b_oil_mine ; 34 :
109771: LD_ADDR_OWVAR 42
109775: PUSH
109776: LD_INT 29
109778: ST_TO_ADDR
109779: GO 109801
109781: LD_INT 34
109783: DOUBLE
109784: EQUAL
109785: IFTRUE 109789
109787: GO 109800
109789: POP
// bc_type := b_siberite_mine ; end ;
109790: LD_ADDR_OWVAR 42
109794: PUSH
109795: LD_INT 30
109797: ST_TO_ADDR
109798: GO 109801
109800: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
109801: LD_ADDR_VAR 0 8
109805: PUSH
109806: LD_VAR 0 5
109810: PPUSH
109811: LD_VAR 0 6
109815: PPUSH
109816: LD_VAR 0 3
109820: PPUSH
109821: CALL_OW 47
109825: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
109826: LD_OWVAR 42
109830: PUSH
109831: LD_INT 32
109833: PUSH
109834: LD_INT 33
109836: PUSH
109837: EMPTY
109838: LIST
109839: LIST
109840: IN
109841: IFFALSE 109857
// PlaceWeaponTurret ( b , weapon ) ;
109843: LD_VAR 0 8
109847: PPUSH
109848: LD_VAR 0 4
109852: PPUSH
109853: CALL_OW 431
// end ;
109857: LD_VAR 0 7
109861: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
109862: LD_INT 0
109864: PPUSH
109865: PPUSH
109866: PPUSH
109867: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109868: LD_ADDR_VAR 0 4
109872: PUSH
109873: LD_INT 22
109875: PUSH
109876: LD_OWVAR 2
109880: PUSH
109881: EMPTY
109882: LIST
109883: LIST
109884: PUSH
109885: LD_INT 2
109887: PUSH
109888: LD_INT 30
109890: PUSH
109891: LD_INT 0
109893: PUSH
109894: EMPTY
109895: LIST
109896: LIST
109897: PUSH
109898: LD_INT 30
109900: PUSH
109901: LD_INT 1
109903: PUSH
109904: EMPTY
109905: LIST
109906: LIST
109907: PUSH
109908: EMPTY
109909: LIST
109910: LIST
109911: LIST
109912: PUSH
109913: EMPTY
109914: LIST
109915: LIST
109916: PPUSH
109917: CALL_OW 69
109921: ST_TO_ADDR
// if not tmp then
109922: LD_VAR 0 4
109926: NOT
109927: IFFALSE 109931
// exit ;
109929: GO 109990
// for i in tmp do
109931: LD_ADDR_VAR 0 2
109935: PUSH
109936: LD_VAR 0 4
109940: PUSH
109941: FOR_IN
109942: IFFALSE 109988
// for j = 1 to 3 do
109944: LD_ADDR_VAR 0 3
109948: PUSH
109949: DOUBLE
109950: LD_INT 1
109952: DEC
109953: ST_TO_ADDR
109954: LD_INT 3
109956: PUSH
109957: FOR_TO
109958: IFFALSE 109984
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
109960: LD_VAR 0 2
109964: PPUSH
109965: CALL_OW 274
109969: PPUSH
109970: LD_VAR 0 3
109974: PPUSH
109975: LD_INT 99999
109977: PPUSH
109978: CALL_OW 277
109982: GO 109957
109984: POP
109985: POP
109986: GO 109941
109988: POP
109989: POP
// end ;
109990: LD_VAR 0 1
109994: RET
// export function hHackSetLevel10 ; var i , j ; begin
109995: LD_INT 0
109997: PPUSH
109998: PPUSH
109999: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110000: LD_ADDR_VAR 0 2
110004: PUSH
110005: LD_INT 21
110007: PUSH
110008: LD_INT 1
110010: PUSH
110011: EMPTY
110012: LIST
110013: LIST
110014: PPUSH
110015: CALL_OW 69
110019: PUSH
110020: FOR_IN
110021: IFFALSE 110073
// if IsSelected ( i ) then
110023: LD_VAR 0 2
110027: PPUSH
110028: CALL_OW 306
110032: IFFALSE 110071
// begin for j := 1 to 4 do
110034: LD_ADDR_VAR 0 3
110038: PUSH
110039: DOUBLE
110040: LD_INT 1
110042: DEC
110043: ST_TO_ADDR
110044: LD_INT 4
110046: PUSH
110047: FOR_TO
110048: IFFALSE 110069
// SetSkill ( i , j , 10 ) ;
110050: LD_VAR 0 2
110054: PPUSH
110055: LD_VAR 0 3
110059: PPUSH
110060: LD_INT 10
110062: PPUSH
110063: CALL_OW 237
110067: GO 110047
110069: POP
110070: POP
// end ;
110071: GO 110020
110073: POP
110074: POP
// end ;
110075: LD_VAR 0 1
110079: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
110080: LD_INT 0
110082: PPUSH
110083: PPUSH
110084: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
110085: LD_ADDR_VAR 0 2
110089: PUSH
110090: LD_INT 22
110092: PUSH
110093: LD_OWVAR 2
110097: PUSH
110098: EMPTY
110099: LIST
110100: LIST
110101: PUSH
110102: LD_INT 21
110104: PUSH
110105: LD_INT 1
110107: PUSH
110108: EMPTY
110109: LIST
110110: LIST
110111: PUSH
110112: EMPTY
110113: LIST
110114: LIST
110115: PPUSH
110116: CALL_OW 69
110120: PUSH
110121: FOR_IN
110122: IFFALSE 110163
// begin for j := 1 to 4 do
110124: LD_ADDR_VAR 0 3
110128: PUSH
110129: DOUBLE
110130: LD_INT 1
110132: DEC
110133: ST_TO_ADDR
110134: LD_INT 4
110136: PUSH
110137: FOR_TO
110138: IFFALSE 110159
// SetSkill ( i , j , 10 ) ;
110140: LD_VAR 0 2
110144: PPUSH
110145: LD_VAR 0 3
110149: PPUSH
110150: LD_INT 10
110152: PPUSH
110153: CALL_OW 237
110157: GO 110137
110159: POP
110160: POP
// end ;
110161: GO 110121
110163: POP
110164: POP
// end ;
110165: LD_VAR 0 1
110169: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
110170: LD_INT 0
110172: PPUSH
// uc_side := your_side ;
110173: LD_ADDR_OWVAR 20
110177: PUSH
110178: LD_OWVAR 2
110182: ST_TO_ADDR
// uc_nation := nation ;
110183: LD_ADDR_OWVAR 21
110187: PUSH
110188: LD_VAR 0 1
110192: ST_TO_ADDR
// InitHc ;
110193: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
110197: LD_INT 0
110199: PPUSH
110200: LD_VAR 0 2
110204: PPUSH
110205: LD_VAR 0 3
110209: PPUSH
110210: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
110214: LD_VAR 0 4
110218: PPUSH
110219: LD_VAR 0 5
110223: PPUSH
110224: CALL_OW 428
110228: PUSH
110229: LD_INT 0
110231: EQUAL
110232: IFFALSE 110256
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
110234: CALL_OW 44
110238: PPUSH
110239: LD_VAR 0 4
110243: PPUSH
110244: LD_VAR 0 5
110248: PPUSH
110249: LD_INT 1
110251: PPUSH
110252: CALL_OW 48
// end ;
110256: LD_VAR 0 6
110260: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
110261: LD_INT 0
110263: PPUSH
110264: PPUSH
// uc_side := your_side ;
110265: LD_ADDR_OWVAR 20
110269: PUSH
110270: LD_OWVAR 2
110274: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
110275: LD_VAR 0 1
110279: PUSH
110280: LD_INT 1
110282: PUSH
110283: LD_INT 2
110285: PUSH
110286: LD_INT 3
110288: PUSH
110289: LD_INT 4
110291: PUSH
110292: LD_INT 5
110294: PUSH
110295: EMPTY
110296: LIST
110297: LIST
110298: LIST
110299: LIST
110300: LIST
110301: IN
110302: IFFALSE 110314
// uc_nation := nation_american else
110304: LD_ADDR_OWVAR 21
110308: PUSH
110309: LD_INT 1
110311: ST_TO_ADDR
110312: GO 110357
// if chassis in [ 11 , 12 , 13 , 14 ] then
110314: LD_VAR 0 1
110318: PUSH
110319: LD_INT 11
110321: PUSH
110322: LD_INT 12
110324: PUSH
110325: LD_INT 13
110327: PUSH
110328: LD_INT 14
110330: PUSH
110331: EMPTY
110332: LIST
110333: LIST
110334: LIST
110335: LIST
110336: IN
110337: IFFALSE 110349
// uc_nation := nation_arabian else
110339: LD_ADDR_OWVAR 21
110343: PUSH
110344: LD_INT 2
110346: ST_TO_ADDR
110347: GO 110357
// uc_nation := nation_russian ;
110349: LD_ADDR_OWVAR 21
110353: PUSH
110354: LD_INT 3
110356: ST_TO_ADDR
// vc_chassis := chassis ;
110357: LD_ADDR_OWVAR 37
110361: PUSH
110362: LD_VAR 0 1
110366: ST_TO_ADDR
// vc_engine := engine ;
110367: LD_ADDR_OWVAR 39
110371: PUSH
110372: LD_VAR 0 2
110376: ST_TO_ADDR
// vc_control := control ;
110377: LD_ADDR_OWVAR 38
110381: PUSH
110382: LD_VAR 0 3
110386: ST_TO_ADDR
// vc_weapon := weapon ;
110387: LD_ADDR_OWVAR 40
110391: PUSH
110392: LD_VAR 0 4
110396: ST_TO_ADDR
// un := CreateVehicle ;
110397: LD_ADDR_VAR 0 8
110401: PUSH
110402: CALL_OW 45
110406: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
110407: LD_VAR 0 8
110411: PPUSH
110412: LD_INT 0
110414: PPUSH
110415: LD_INT 5
110417: PPUSH
110418: CALL_OW 12
110422: PPUSH
110423: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
110427: LD_VAR 0 8
110431: PPUSH
110432: LD_VAR 0 5
110436: PPUSH
110437: LD_VAR 0 6
110441: PPUSH
110442: LD_INT 1
110444: PPUSH
110445: CALL_OW 48
// end ;
110449: LD_VAR 0 7
110453: RET
// export hInvincible ; every 1 do
110454: GO 110456
110456: DISABLE
// hInvincible := [ ] ;
110457: LD_ADDR_EXP 183
110461: PUSH
110462: EMPTY
110463: ST_TO_ADDR
110464: END
// every 10 do var i ;
110465: GO 110467
110467: DISABLE
110468: LD_INT 0
110470: PPUSH
// begin enable ;
110471: ENABLE
// if not hInvincible then
110472: LD_EXP 183
110476: NOT
110477: IFFALSE 110481
// exit ;
110479: GO 110525
// for i in hInvincible do
110481: LD_ADDR_VAR 0 1
110485: PUSH
110486: LD_EXP 183
110490: PUSH
110491: FOR_IN
110492: IFFALSE 110523
// if GetLives ( i ) < 1000 then
110494: LD_VAR 0 1
110498: PPUSH
110499: CALL_OW 256
110503: PUSH
110504: LD_INT 1000
110506: LESS
110507: IFFALSE 110521
// SetLives ( i , 1000 ) ;
110509: LD_VAR 0 1
110513: PPUSH
110514: LD_INT 1000
110516: PPUSH
110517: CALL_OW 234
110521: GO 110491
110523: POP
110524: POP
// end ;
110525: PPOPN 1
110527: END
// export function hHackInvincible ; var i ; begin
110528: LD_INT 0
110530: PPUSH
110531: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
110532: LD_ADDR_VAR 0 2
110536: PUSH
110537: LD_INT 2
110539: PUSH
110540: LD_INT 21
110542: PUSH
110543: LD_INT 1
110545: PUSH
110546: EMPTY
110547: LIST
110548: LIST
110549: PUSH
110550: LD_INT 21
110552: PUSH
110553: LD_INT 2
110555: PUSH
110556: EMPTY
110557: LIST
110558: LIST
110559: PUSH
110560: EMPTY
110561: LIST
110562: LIST
110563: LIST
110564: PPUSH
110565: CALL_OW 69
110569: PUSH
110570: FOR_IN
110571: IFFALSE 110632
// if IsSelected ( i ) then
110573: LD_VAR 0 2
110577: PPUSH
110578: CALL_OW 306
110582: IFFALSE 110630
// begin if i in hInvincible then
110584: LD_VAR 0 2
110588: PUSH
110589: LD_EXP 183
110593: IN
110594: IFFALSE 110614
// hInvincible := hInvincible diff i else
110596: LD_ADDR_EXP 183
110600: PUSH
110601: LD_EXP 183
110605: PUSH
110606: LD_VAR 0 2
110610: DIFF
110611: ST_TO_ADDR
110612: GO 110630
// hInvincible := hInvincible union i ;
110614: LD_ADDR_EXP 183
110618: PUSH
110619: LD_EXP 183
110623: PUSH
110624: LD_VAR 0 2
110628: UNION
110629: ST_TO_ADDR
// end ;
110630: GO 110570
110632: POP
110633: POP
// end ;
110634: LD_VAR 0 1
110638: RET
// export function hHackInvisible ; var i , j ; begin
110639: LD_INT 0
110641: PPUSH
110642: PPUSH
110643: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110644: LD_ADDR_VAR 0 2
110648: PUSH
110649: LD_INT 21
110651: PUSH
110652: LD_INT 1
110654: PUSH
110655: EMPTY
110656: LIST
110657: LIST
110658: PPUSH
110659: CALL_OW 69
110663: PUSH
110664: FOR_IN
110665: IFFALSE 110689
// if IsSelected ( i ) then
110667: LD_VAR 0 2
110671: PPUSH
110672: CALL_OW 306
110676: IFFALSE 110687
// ComForceInvisible ( i ) ;
110678: LD_VAR 0 2
110682: PPUSH
110683: CALL_OW 496
110687: GO 110664
110689: POP
110690: POP
// end ;
110691: LD_VAR 0 1
110695: RET
// export function hHackChangeYourSide ; begin
110696: LD_INT 0
110698: PPUSH
// if your_side = 8 then
110699: LD_OWVAR 2
110703: PUSH
110704: LD_INT 8
110706: EQUAL
110707: IFFALSE 110719
// your_side := 0 else
110709: LD_ADDR_OWVAR 2
110713: PUSH
110714: LD_INT 0
110716: ST_TO_ADDR
110717: GO 110733
// your_side := your_side + 1 ;
110719: LD_ADDR_OWVAR 2
110723: PUSH
110724: LD_OWVAR 2
110728: PUSH
110729: LD_INT 1
110731: PLUS
110732: ST_TO_ADDR
// end ;
110733: LD_VAR 0 1
110737: RET
// export function hHackChangeUnitSide ; var i , j ; begin
110738: LD_INT 0
110740: PPUSH
110741: PPUSH
110742: PPUSH
// for i in all_units do
110743: LD_ADDR_VAR 0 2
110747: PUSH
110748: LD_OWVAR 3
110752: PUSH
110753: FOR_IN
110754: IFFALSE 110832
// if IsSelected ( i ) then
110756: LD_VAR 0 2
110760: PPUSH
110761: CALL_OW 306
110765: IFFALSE 110830
// begin j := GetSide ( i ) ;
110767: LD_ADDR_VAR 0 3
110771: PUSH
110772: LD_VAR 0 2
110776: PPUSH
110777: CALL_OW 255
110781: ST_TO_ADDR
// if j = 8 then
110782: LD_VAR 0 3
110786: PUSH
110787: LD_INT 8
110789: EQUAL
110790: IFFALSE 110802
// j := 0 else
110792: LD_ADDR_VAR 0 3
110796: PUSH
110797: LD_INT 0
110799: ST_TO_ADDR
110800: GO 110816
// j := j + 1 ;
110802: LD_ADDR_VAR 0 3
110806: PUSH
110807: LD_VAR 0 3
110811: PUSH
110812: LD_INT 1
110814: PLUS
110815: ST_TO_ADDR
// SetSide ( i , j ) ;
110816: LD_VAR 0 2
110820: PPUSH
110821: LD_VAR 0 3
110825: PPUSH
110826: CALL_OW 235
// end ;
110830: GO 110753
110832: POP
110833: POP
// end ;
110834: LD_VAR 0 1
110838: RET
// export function hHackFog ; begin
110839: LD_INT 0
110841: PPUSH
// FogOff ( true ) ;
110842: LD_INT 1
110844: PPUSH
110845: CALL_OW 344
// end ;
110849: LD_VAR 0 1
110853: RET
// export function hHackTeleport ( unit , x , y ) ; begin
110854: LD_INT 0
110856: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
110857: LD_VAR 0 1
110861: PPUSH
110862: LD_VAR 0 2
110866: PPUSH
110867: LD_VAR 0 3
110871: PPUSH
110872: LD_INT 1
110874: PPUSH
110875: LD_INT 1
110877: PPUSH
110878: CALL_OW 483
// CenterOnXY ( x , y ) ;
110882: LD_VAR 0 2
110886: PPUSH
110887: LD_VAR 0 3
110891: PPUSH
110892: CALL_OW 84
// end ;
110896: LD_VAR 0 4
110900: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
110901: LD_INT 0
110903: PPUSH
110904: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
110905: LD_VAR 0 1
110909: NOT
110910: PUSH
110911: LD_VAR 0 2
110915: PPUSH
110916: LD_VAR 0 3
110920: PPUSH
110921: CALL_OW 488
110925: NOT
110926: OR
110927: PUSH
110928: LD_VAR 0 1
110932: PPUSH
110933: CALL_OW 266
110937: PUSH
110938: LD_INT 3
110940: NONEQUAL
110941: PUSH
110942: LD_VAR 0 1
110946: PPUSH
110947: CALL_OW 247
110951: PUSH
110952: LD_INT 1
110954: EQUAL
110955: NOT
110956: AND
110957: OR
110958: IFFALSE 110962
// exit ;
110960: GO 111244
// if GetType ( factory ) = unit_human then
110962: LD_VAR 0 1
110966: PPUSH
110967: CALL_OW 247
110971: PUSH
110972: LD_INT 1
110974: EQUAL
110975: IFFALSE 110992
// factory := IsInUnit ( factory ) ;
110977: LD_ADDR_VAR 0 1
110981: PUSH
110982: LD_VAR 0 1
110986: PPUSH
110987: CALL_OW 310
110991: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
110992: LD_VAR 0 1
110996: PPUSH
110997: CALL_OW 266
111001: PUSH
111002: LD_INT 3
111004: NONEQUAL
111005: IFFALSE 111009
// exit ;
111007: GO 111244
// for i := 1 to Count ( factoryWaypoints ) do
111009: LD_ADDR_VAR 0 5
111013: PUSH
111014: DOUBLE
111015: LD_INT 1
111017: DEC
111018: ST_TO_ADDR
111019: LD_EXP 184
111023: PPUSH
111024: CALL 55700 0 1
111028: PUSH
111029: FOR_TO
111030: IFFALSE 111192
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
111032: LD_VAR 0 2
111036: PPUSH
111037: LD_VAR 0 3
111041: PPUSH
111042: CALL_OW 428
111046: PUSH
111047: LD_EXP 184
111051: PUSH
111052: LD_VAR 0 5
111056: ARRAY
111057: PUSH
111058: LD_INT 2
111060: ARRAY
111061: EQUAL
111062: IFFALSE 111094
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
111064: LD_ADDR_EXP 184
111068: PUSH
111069: LD_EXP 184
111073: PPUSH
111074: LD_VAR 0 5
111078: PPUSH
111079: CALL_OW 3
111083: ST_TO_ADDR
// UpdateFactoryWaypoints ;
111084: CALL 111249 0 0
// exit ;
111088: POP
111089: POP
111090: GO 111244
// end else
111092: GO 111190
// if factory = factoryWaypoints [ i ] [ 2 ] then
111094: LD_VAR 0 1
111098: PUSH
111099: LD_EXP 184
111103: PUSH
111104: LD_VAR 0 5
111108: ARRAY
111109: PUSH
111110: LD_INT 2
111112: ARRAY
111113: EQUAL
111114: IFFALSE 111190
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
111116: LD_ADDR_EXP 184
111120: PUSH
111121: LD_EXP 184
111125: PPUSH
111126: LD_VAR 0 5
111130: PPUSH
111131: CALL_OW 3
111135: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
111136: LD_ADDR_EXP 184
111140: PUSH
111141: LD_EXP 184
111145: PPUSH
111146: LD_VAR 0 1
111150: PPUSH
111151: CALL_OW 255
111155: PUSH
111156: LD_VAR 0 1
111160: PUSH
111161: LD_VAR 0 2
111165: PUSH
111166: LD_VAR 0 3
111170: PUSH
111171: EMPTY
111172: LIST
111173: LIST
111174: LIST
111175: LIST
111176: PPUSH
111177: CALL 91309 0 2
111181: ST_TO_ADDR
// UpdateFactoryWaypoints ;
111182: CALL 111249 0 0
// exit ;
111186: POP
111187: POP
111188: GO 111244
// end ; end ;
111190: GO 111029
111192: POP
111193: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
111194: LD_ADDR_EXP 184
111198: PUSH
111199: LD_EXP 184
111203: PPUSH
111204: LD_VAR 0 1
111208: PPUSH
111209: CALL_OW 255
111213: PUSH
111214: LD_VAR 0 1
111218: PUSH
111219: LD_VAR 0 2
111223: PUSH
111224: LD_VAR 0 3
111228: PUSH
111229: EMPTY
111230: LIST
111231: LIST
111232: LIST
111233: LIST
111234: PPUSH
111235: CALL 91309 0 2
111239: ST_TO_ADDR
// UpdateFactoryWaypoints ;
111240: CALL 111249 0 0
// end ;
111244: LD_VAR 0 4
111248: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
111249: LD_INT 0
111251: PPUSH
111252: PPUSH
111253: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
111254: LD_STRING resetFactoryWaypoint();
111256: PPUSH
111257: CALL_OW 559
// if factoryWaypoints then
111261: LD_EXP 184
111265: IFFALSE 111386
// begin list := factoryWaypoints ;
111267: LD_ADDR_VAR 0 3
111271: PUSH
111272: LD_EXP 184
111276: ST_TO_ADDR
// for i := 1 to list do
111277: LD_ADDR_VAR 0 2
111281: PUSH
111282: DOUBLE
111283: LD_INT 1
111285: DEC
111286: ST_TO_ADDR
111287: LD_VAR 0 3
111291: PUSH
111292: FOR_TO
111293: IFFALSE 111384
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111295: LD_STRING setFactoryWaypointXY(
111297: PUSH
111298: LD_VAR 0 3
111302: PUSH
111303: LD_VAR 0 2
111307: ARRAY
111308: PUSH
111309: LD_INT 1
111311: ARRAY
111312: STR
111313: PUSH
111314: LD_STRING ,
111316: STR
111317: PUSH
111318: LD_VAR 0 3
111322: PUSH
111323: LD_VAR 0 2
111327: ARRAY
111328: PUSH
111329: LD_INT 2
111331: ARRAY
111332: STR
111333: PUSH
111334: LD_STRING ,
111336: STR
111337: PUSH
111338: LD_VAR 0 3
111342: PUSH
111343: LD_VAR 0 2
111347: ARRAY
111348: PUSH
111349: LD_INT 3
111351: ARRAY
111352: STR
111353: PUSH
111354: LD_STRING ,
111356: STR
111357: PUSH
111358: LD_VAR 0 3
111362: PUSH
111363: LD_VAR 0 2
111367: ARRAY
111368: PUSH
111369: LD_INT 4
111371: ARRAY
111372: STR
111373: PUSH
111374: LD_STRING )
111376: STR
111377: PPUSH
111378: CALL_OW 559
111382: GO 111292
111384: POP
111385: POP
// end ; end ;
111386: LD_VAR 0 1
111390: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
111391: LD_INT 0
111393: PPUSH
// if HexInfo ( x , y ) = warehouse then
111394: LD_VAR 0 2
111398: PPUSH
111399: LD_VAR 0 3
111403: PPUSH
111404: CALL_OW 428
111408: PUSH
111409: LD_VAR 0 1
111413: EQUAL
111414: IFFALSE 111441
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
111416: LD_ADDR_EXP 185
111420: PUSH
111421: LD_EXP 185
111425: PPUSH
111426: LD_VAR 0 1
111430: PPUSH
111431: LD_INT 0
111433: PPUSH
111434: CALL_OW 1
111438: ST_TO_ADDR
111439: GO 111492
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
111441: LD_ADDR_EXP 185
111445: PUSH
111446: LD_EXP 185
111450: PPUSH
111451: LD_VAR 0 1
111455: PPUSH
111456: LD_VAR 0 1
111460: PPUSH
111461: CALL_OW 255
111465: PUSH
111466: LD_VAR 0 1
111470: PUSH
111471: LD_VAR 0 2
111475: PUSH
111476: LD_VAR 0 3
111480: PUSH
111481: EMPTY
111482: LIST
111483: LIST
111484: LIST
111485: LIST
111486: PPUSH
111487: CALL_OW 1
111491: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
111492: CALL 111501 0 0
// end ;
111496: LD_VAR 0 4
111500: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
111501: LD_INT 0
111503: PPUSH
111504: PPUSH
111505: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
111506: LD_STRING resetWarehouseGatheringPoints();
111508: PPUSH
111509: CALL_OW 559
// if warehouseGatheringPoints then
111513: LD_EXP 185
111517: IFFALSE 111643
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
111519: LD_ADDR_VAR 0 3
111523: PUSH
111524: LD_EXP 185
111528: PPUSH
111529: CALL 95071 0 1
111533: ST_TO_ADDR
// for i := 1 to list do
111534: LD_ADDR_VAR 0 2
111538: PUSH
111539: DOUBLE
111540: LD_INT 1
111542: DEC
111543: ST_TO_ADDR
111544: LD_VAR 0 3
111548: PUSH
111549: FOR_TO
111550: IFFALSE 111641
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111552: LD_STRING setWarehouseGatheringPointXY(
111554: PUSH
111555: LD_VAR 0 3
111559: PUSH
111560: LD_VAR 0 2
111564: ARRAY
111565: PUSH
111566: LD_INT 1
111568: ARRAY
111569: STR
111570: PUSH
111571: LD_STRING ,
111573: STR
111574: PUSH
111575: LD_VAR 0 3
111579: PUSH
111580: LD_VAR 0 2
111584: ARRAY
111585: PUSH
111586: LD_INT 2
111588: ARRAY
111589: STR
111590: PUSH
111591: LD_STRING ,
111593: STR
111594: PUSH
111595: LD_VAR 0 3
111599: PUSH
111600: LD_VAR 0 2
111604: ARRAY
111605: PUSH
111606: LD_INT 3
111608: ARRAY
111609: STR
111610: PUSH
111611: LD_STRING ,
111613: STR
111614: PUSH
111615: LD_VAR 0 3
111619: PUSH
111620: LD_VAR 0 2
111624: ARRAY
111625: PUSH
111626: LD_INT 4
111628: ARRAY
111629: STR
111630: PUSH
111631: LD_STRING )
111633: STR
111634: PPUSH
111635: CALL_OW 559
111639: GO 111549
111641: POP
111642: POP
// end ; end ;
111643: LD_VAR 0 1
111647: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
111648: LD_EXP 185
111652: IFFALSE 112337
111654: GO 111656
111656: DISABLE
111657: LD_INT 0
111659: PPUSH
111660: PPUSH
111661: PPUSH
111662: PPUSH
111663: PPUSH
111664: PPUSH
111665: PPUSH
111666: PPUSH
111667: PPUSH
// begin enable ;
111668: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
111669: LD_ADDR_VAR 0 3
111673: PUSH
111674: LD_EXP 185
111678: PPUSH
111679: CALL 95071 0 1
111683: ST_TO_ADDR
// if not list then
111684: LD_VAR 0 3
111688: NOT
111689: IFFALSE 111693
// exit ;
111691: GO 112337
// for i := 1 to list do
111693: LD_ADDR_VAR 0 1
111697: PUSH
111698: DOUBLE
111699: LD_INT 1
111701: DEC
111702: ST_TO_ADDR
111703: LD_VAR 0 3
111707: PUSH
111708: FOR_TO
111709: IFFALSE 112335
// begin depot := list [ i ] [ 2 ] ;
111711: LD_ADDR_VAR 0 8
111715: PUSH
111716: LD_VAR 0 3
111720: PUSH
111721: LD_VAR 0 1
111725: ARRAY
111726: PUSH
111727: LD_INT 2
111729: ARRAY
111730: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
111731: LD_ADDR_VAR 0 5
111735: PUSH
111736: LD_VAR 0 3
111740: PUSH
111741: LD_VAR 0 1
111745: ARRAY
111746: PUSH
111747: LD_INT 1
111749: ARRAY
111750: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
111751: LD_VAR 0 8
111755: PPUSH
111756: CALL_OW 301
111760: PUSH
111761: LD_VAR 0 5
111765: PUSH
111766: LD_VAR 0 8
111770: PPUSH
111771: CALL_OW 255
111775: NONEQUAL
111776: OR
111777: IFFALSE 111806
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
111779: LD_ADDR_EXP 185
111783: PUSH
111784: LD_EXP 185
111788: PPUSH
111789: LD_VAR 0 8
111793: PPUSH
111794: LD_INT 0
111796: PPUSH
111797: CALL_OW 1
111801: ST_TO_ADDR
// exit ;
111802: POP
111803: POP
111804: GO 112337
// end ; x := list [ i ] [ 3 ] ;
111806: LD_ADDR_VAR 0 6
111810: PUSH
111811: LD_VAR 0 3
111815: PUSH
111816: LD_VAR 0 1
111820: ARRAY
111821: PUSH
111822: LD_INT 3
111824: ARRAY
111825: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
111826: LD_ADDR_VAR 0 7
111830: PUSH
111831: LD_VAR 0 3
111835: PUSH
111836: LD_VAR 0 1
111840: ARRAY
111841: PUSH
111842: LD_INT 4
111844: ARRAY
111845: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
111846: LD_ADDR_VAR 0 9
111850: PUSH
111851: LD_VAR 0 6
111855: PPUSH
111856: LD_VAR 0 7
111860: PPUSH
111861: LD_INT 16
111863: PPUSH
111864: CALL 93655 0 3
111868: ST_TO_ADDR
// if not cratesNearbyPoint then
111869: LD_VAR 0 9
111873: NOT
111874: IFFALSE 111880
// exit ;
111876: POP
111877: POP
111878: GO 112337
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
111880: LD_ADDR_VAR 0 4
111884: PUSH
111885: LD_INT 22
111887: PUSH
111888: LD_VAR 0 5
111892: PUSH
111893: EMPTY
111894: LIST
111895: LIST
111896: PUSH
111897: LD_INT 3
111899: PUSH
111900: LD_INT 60
111902: PUSH
111903: EMPTY
111904: LIST
111905: PUSH
111906: EMPTY
111907: LIST
111908: LIST
111909: PUSH
111910: LD_INT 91
111912: PUSH
111913: LD_VAR 0 8
111917: PUSH
111918: LD_INT 6
111920: PUSH
111921: EMPTY
111922: LIST
111923: LIST
111924: LIST
111925: PUSH
111926: LD_INT 2
111928: PUSH
111929: LD_INT 25
111931: PUSH
111932: LD_INT 2
111934: PUSH
111935: EMPTY
111936: LIST
111937: LIST
111938: PUSH
111939: LD_INT 25
111941: PUSH
111942: LD_INT 16
111944: PUSH
111945: EMPTY
111946: LIST
111947: LIST
111948: PUSH
111949: EMPTY
111950: LIST
111951: LIST
111952: LIST
111953: PUSH
111954: EMPTY
111955: LIST
111956: LIST
111957: LIST
111958: LIST
111959: PPUSH
111960: CALL_OW 69
111964: PUSH
111965: LD_VAR 0 8
111969: PPUSH
111970: CALL_OW 313
111974: PPUSH
111975: LD_INT 3
111977: PUSH
111978: LD_INT 60
111980: PUSH
111981: EMPTY
111982: LIST
111983: PUSH
111984: EMPTY
111985: LIST
111986: LIST
111987: PUSH
111988: LD_INT 2
111990: PUSH
111991: LD_INT 25
111993: PUSH
111994: LD_INT 2
111996: PUSH
111997: EMPTY
111998: LIST
111999: LIST
112000: PUSH
112001: LD_INT 25
112003: PUSH
112004: LD_INT 16
112006: PUSH
112007: EMPTY
112008: LIST
112009: LIST
112010: PUSH
112011: EMPTY
112012: LIST
112013: LIST
112014: LIST
112015: PUSH
112016: EMPTY
112017: LIST
112018: LIST
112019: PPUSH
112020: CALL_OW 72
112024: UNION
112025: ST_TO_ADDR
// if tmp then
112026: LD_VAR 0 4
112030: IFFALSE 112110
// begin tmp := ShrinkArray ( tmp , 3 ) ;
112032: LD_ADDR_VAR 0 4
112036: PUSH
112037: LD_VAR 0 4
112041: PPUSH
112042: LD_INT 3
112044: PPUSH
112045: CALL 91624 0 2
112049: ST_TO_ADDR
// for j in tmp do
112050: LD_ADDR_VAR 0 2
112054: PUSH
112055: LD_VAR 0 4
112059: PUSH
112060: FOR_IN
112061: IFFALSE 112104
// begin if IsInUnit ( j ) then
112063: LD_VAR 0 2
112067: PPUSH
112068: CALL_OW 310
112072: IFFALSE 112083
// ComExit ( j ) ;
112074: LD_VAR 0 2
112078: PPUSH
112079: CALL 91707 0 1
// AddComCollect ( j , x , y ) ;
112083: LD_VAR 0 2
112087: PPUSH
112088: LD_VAR 0 6
112092: PPUSH
112093: LD_VAR 0 7
112097: PPUSH
112098: CALL_OW 177
// end ;
112102: GO 112060
112104: POP
112105: POP
// exit ;
112106: POP
112107: POP
112108: GO 112337
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
112110: LD_ADDR_VAR 0 4
112114: PUSH
112115: LD_INT 22
112117: PUSH
112118: LD_VAR 0 5
112122: PUSH
112123: EMPTY
112124: LIST
112125: LIST
112126: PUSH
112127: LD_INT 91
112129: PUSH
112130: LD_VAR 0 8
112134: PUSH
112135: LD_INT 8
112137: PUSH
112138: EMPTY
112139: LIST
112140: LIST
112141: LIST
112142: PUSH
112143: LD_INT 2
112145: PUSH
112146: LD_INT 34
112148: PUSH
112149: LD_INT 12
112151: PUSH
112152: EMPTY
112153: LIST
112154: LIST
112155: PUSH
112156: LD_INT 34
112158: PUSH
112159: LD_INT 51
112161: PUSH
112162: EMPTY
112163: LIST
112164: LIST
112165: PUSH
112166: LD_INT 34
112168: PUSH
112169: LD_INT 32
112171: PUSH
112172: EMPTY
112173: LIST
112174: LIST
112175: PUSH
112176: LD_INT 34
112178: PUSH
112179: LD_INT 89
112181: PUSH
112182: EMPTY
112183: LIST
112184: LIST
112185: PUSH
112186: EMPTY
112187: LIST
112188: LIST
112189: LIST
112190: LIST
112191: LIST
112192: PUSH
112193: EMPTY
112194: LIST
112195: LIST
112196: LIST
112197: PPUSH
112198: CALL_OW 69
112202: ST_TO_ADDR
// if tmp then
112203: LD_VAR 0 4
112207: IFFALSE 112333
// begin for j in tmp do
112209: LD_ADDR_VAR 0 2
112213: PUSH
112214: LD_VAR 0 4
112218: PUSH
112219: FOR_IN
112220: IFFALSE 112331
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
112222: LD_VAR 0 2
112226: PPUSH
112227: CALL_OW 262
112231: PUSH
112232: LD_INT 3
112234: EQUAL
112235: PUSH
112236: LD_VAR 0 2
112240: PPUSH
112241: CALL_OW 261
112245: PUSH
112246: LD_INT 20
112248: GREATER
112249: OR
112250: PUSH
112251: LD_VAR 0 2
112255: PPUSH
112256: CALL_OW 314
112260: NOT
112261: AND
112262: PUSH
112263: LD_VAR 0 2
112267: PPUSH
112268: CALL_OW 263
112272: PUSH
112273: LD_INT 1
112275: NONEQUAL
112276: PUSH
112277: LD_VAR 0 2
112281: PPUSH
112282: CALL_OW 311
112286: OR
112287: AND
112288: IFFALSE 112329
// begin ComCollect ( j , x , y ) ;
112290: LD_VAR 0 2
112294: PPUSH
112295: LD_VAR 0 6
112299: PPUSH
112300: LD_VAR 0 7
112304: PPUSH
112305: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
112309: LD_VAR 0 2
112313: PPUSH
112314: LD_VAR 0 8
112318: PPUSH
112319: CALL_OW 172
// exit ;
112323: POP
112324: POP
112325: POP
112326: POP
112327: GO 112337
// end ;
112329: GO 112219
112331: POP
112332: POP
// end ; end ;
112333: GO 111708
112335: POP
112336: POP
// end ; end_of_file
112337: PPOPN 9
112339: END
// export function SOS_UnitDestroyed ( un ) ; begin
112340: LD_INT 0
112342: PPUSH
// ComRadiation ( un ) ;
112343: LD_VAR 0 1
112347: PPUSH
112348: CALL 113329 0 1
// end ;
112352: LD_VAR 0 2
112356: RET
// export function SOS_UnitKamikazed ( un ) ; begin
112357: LD_INT 0
112359: PPUSH
// ComRadiation ( un ) ;
112360: LD_VAR 0 1
112364: PPUSH
112365: CALL 113329 0 1
// end ;
112369: LD_VAR 0 2
112373: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112374: LD_INT 0
112376: PPUSH
// end ;
112377: LD_VAR 0 4
112381: RET
// export function SOS_Command ( cmd ) ; begin
112382: LD_INT 0
112384: PPUSH
// end ;
112385: LD_VAR 0 2
112389: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
112390: LD_INT 0
112392: PPUSH
// end ;
112393: LD_VAR 0 6
112397: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , tag , driver , hex ; begin
112398: LD_INT 0
112400: PPUSH
112401: PPUSH
112402: PPUSH
112403: PPUSH
112404: PPUSH
// if not vehicle or not factory then
112405: LD_VAR 0 1
112409: NOT
112410: PUSH
112411: LD_VAR 0 2
112415: NOT
112416: OR
112417: IFFALSE 112421
// exit ;
112419: GO 112920
// if not factoryWaypoints then
112421: LD_EXP 184
112425: NOT
112426: IFFALSE 112430
// exit ;
112428: GO 112920
// for i := 1 to Count ( factoryWaypoints ) do
112430: LD_ADDR_VAR 0 4
112434: PUSH
112435: DOUBLE
112436: LD_INT 1
112438: DEC
112439: ST_TO_ADDR
112440: LD_EXP 184
112444: PPUSH
112445: CALL 55700 0 1
112449: PUSH
112450: FOR_TO
112451: IFFALSE 112918
// if factoryWaypoints [ i ] [ 2 ] = factory then
112453: LD_EXP 184
112457: PUSH
112458: LD_VAR 0 4
112462: ARRAY
112463: PUSH
112464: LD_INT 2
112466: ARRAY
112467: PUSH
112468: LD_VAR 0 2
112472: EQUAL
112473: IFFALSE 112916
// begin if GetControl ( vehicle ) = control_manual then
112475: LD_VAR 0 1
112479: PPUSH
112480: CALL_OW 263
112484: PUSH
112485: LD_INT 1
112487: EQUAL
112488: IFFALSE 112799
// begin driver := IsDrivenBy ( vehicle ) ;
112490: LD_ADDR_VAR 0 6
112494: PUSH
112495: LD_VAR 0 1
112499: PPUSH
112500: CALL_OW 311
112504: ST_TO_ADDR
// tag := GetTag ( driver ) ;
112505: LD_ADDR_VAR 0 5
112509: PUSH
112510: LD_VAR 0 6
112514: PPUSH
112515: CALL_OW 110
112519: ST_TO_ADDR
// if tag = tDriver or GetTag ( vehicle ) = tDriver then
112520: LD_VAR 0 5
112524: PUSH
112525: LD_INT 501
112527: EQUAL
112528: PUSH
112529: LD_VAR 0 1
112533: PPUSH
112534: CALL_OW 110
112538: PUSH
112539: LD_INT 501
112541: EQUAL
112542: OR
112543: IFFALSE 112549
// exit ;
112545: POP
112546: POP
112547: GO 112920
// if not HasTask ( driver ) then
112549: LD_VAR 0 6
112553: PPUSH
112554: CALL_OW 314
112558: NOT
112559: IFFALSE 112797
// begin SetTag ( driver , tDriver ) ;
112561: LD_VAR 0 6
112565: PPUSH
112566: LD_INT 501
112568: PPUSH
112569: CALL_OW 109
// SetTag ( vehicle , tDriver ) ;
112573: LD_VAR 0 1
112577: PPUSH
112578: LD_INT 501
112580: PPUSH
112581: CALL_OW 109
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
112585: LD_ADDR_VAR 0 7
112589: PUSH
112590: LD_EXP 184
112594: PUSH
112595: LD_VAR 0 4
112599: ARRAY
112600: PUSH
112601: LD_INT 3
112603: ARRAY
112604: PPUSH
112605: LD_EXP 184
112609: PUSH
112610: LD_VAR 0 4
112614: ARRAY
112615: PUSH
112616: LD_INT 4
112618: ARRAY
112619: PPUSH
112620: CALL_OW 428
112624: ST_TO_ADDR
// if hex then
112625: LD_VAR 0 7
112629: IFFALSE 112647
// ComMoveUnit ( driver , hex ) else
112631: LD_VAR 0 6
112635: PPUSH
112636: LD_VAR 0 7
112640: PPUSH
112641: CALL_OW 112
112645: GO 112686
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
112647: LD_VAR 0 6
112651: PPUSH
112652: LD_EXP 184
112656: PUSH
112657: LD_VAR 0 4
112661: ARRAY
112662: PUSH
112663: LD_INT 3
112665: ARRAY
112666: PPUSH
112667: LD_EXP 184
112671: PUSH
112672: LD_VAR 0 4
112676: ARRAY
112677: PUSH
112678: LD_INT 4
112680: ARRAY
112681: PPUSH
112682: CALL_OW 111
// AddComExitVehicle ( driver ) ;
112686: LD_VAR 0 6
112690: PPUSH
112691: CALL_OW 181
// if Multiplayer then
112695: LD_OWVAR 4
112699: IFFALSE 112748
// begin repeat wait ( 10 ) ;
112701: LD_INT 10
112703: PPUSH
112704: CALL_OW 67
// until not IsInUnit ( driver ) ;
112708: LD_VAR 0 6
112712: PPUSH
112713: CALL_OW 310
112717: NOT
112718: IFFALSE 112701
// if not HasTask ( driver ) then
112720: LD_VAR 0 6
112724: PPUSH
112725: CALL_OW 314
112729: NOT
112730: IFFALSE 112746
// ComEnterUnit ( driver , factory ) ;
112732: LD_VAR 0 6
112736: PPUSH
112737: LD_VAR 0 2
112741: PPUSH
112742: CALL_OW 120
// end else
112746: GO 112762
// AddComEnterUnit ( driver , factory ) ;
112748: LD_VAR 0 6
112752: PPUSH
112753: LD_VAR 0 2
112757: PPUSH
112758: CALL_OW 180
// wait ( 0 0$1 ) ;
112762: LD_INT 35
112764: PPUSH
112765: CALL_OW 67
// SetTag ( driver , tag ) ;
112769: LD_VAR 0 6
112773: PPUSH
112774: LD_VAR 0 5
112778: PPUSH
112779: CALL_OW 109
// SetTag ( vehicle , 0 ) ;
112783: LD_VAR 0 1
112787: PPUSH
112788: LD_INT 0
112790: PPUSH
112791: CALL_OW 109
// break ;
112795: GO 112918
// end ; end else
112797: GO 112916
// if GetControl ( vehicle ) = control_remote then
112799: LD_VAR 0 1
112803: PPUSH
112804: CALL_OW 263
112808: PUSH
112809: LD_INT 2
112811: EQUAL
112812: IFFALSE 112875
// begin wait ( 0 0$2 ) ;
112814: LD_INT 70
112816: PPUSH
112817: CALL_OW 67
// if Connect ( vehicle ) then
112821: LD_VAR 0 1
112825: PPUSH
112826: CALL 61906 0 1
112830: IFFALSE 112871
// AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
112832: LD_VAR 0 1
112836: PPUSH
112837: LD_EXP 184
112841: PUSH
112842: LD_VAR 0 4
112846: ARRAY
112847: PUSH
112848: LD_INT 3
112850: ARRAY
112851: PPUSH
112852: LD_EXP 184
112856: PUSH
112857: LD_VAR 0 4
112861: ARRAY
112862: PUSH
112863: LD_INT 4
112865: ARRAY
112866: PPUSH
112867: CALL_OW 171
// break ;
112871: GO 112918
// end else
112873: GO 112916
// begin AddComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
112875: LD_VAR 0 1
112879: PPUSH
112880: LD_EXP 184
112884: PUSH
112885: LD_VAR 0 4
112889: ARRAY
112890: PUSH
112891: LD_INT 3
112893: ARRAY
112894: PPUSH
112895: LD_EXP 184
112899: PUSH
112900: LD_VAR 0 4
112904: ARRAY
112905: PUSH
112906: LD_INT 4
112908: ARRAY
112909: PPUSH
112910: CALL_OW 171
// break ;
112914: GO 112918
// end ; end ;
112916: GO 112450
112918: POP
112919: POP
// end ;
112920: LD_VAR 0 3
112924: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
112925: LD_INT 0
112927: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
112928: LD_VAR 0 1
112932: PUSH
112933: LD_INT 250
112935: EQUAL
112936: PUSH
112937: LD_VAR 0 2
112941: PPUSH
112942: CALL_OW 264
112946: PUSH
112947: LD_INT 81
112949: EQUAL
112950: AND
112951: IFFALSE 112972
// MinerPlaceMine ( unit , x , y ) ;
112953: LD_VAR 0 2
112957: PPUSH
112958: LD_VAR 0 4
112962: PPUSH
112963: LD_VAR 0 5
112967: PPUSH
112968: CALL 116064 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
112972: LD_VAR 0 1
112976: PUSH
112977: LD_INT 251
112979: EQUAL
112980: PUSH
112981: LD_VAR 0 2
112985: PPUSH
112986: CALL_OW 264
112990: PUSH
112991: LD_INT 81
112993: EQUAL
112994: AND
112995: IFFALSE 113016
// MinerDetonateMine ( unit , x , y ) ;
112997: LD_VAR 0 2
113001: PPUSH
113002: LD_VAR 0 4
113006: PPUSH
113007: LD_VAR 0 5
113011: PPUSH
113012: CALL 116339 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
113016: LD_VAR 0 1
113020: PUSH
113021: LD_INT 252
113023: EQUAL
113024: PUSH
113025: LD_VAR 0 2
113029: PPUSH
113030: CALL_OW 264
113034: PUSH
113035: LD_INT 81
113037: EQUAL
113038: AND
113039: IFFALSE 113060
// MinerCreateMinefield ( unit , x , y ) ;
113041: LD_VAR 0 2
113045: PPUSH
113046: LD_VAR 0 4
113050: PPUSH
113051: LD_VAR 0 5
113055: PPUSH
113056: CALL 116756 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
113060: LD_VAR 0 1
113064: PUSH
113065: LD_INT 253
113067: EQUAL
113068: PUSH
113069: LD_VAR 0 2
113073: PPUSH
113074: CALL_OW 257
113078: PUSH
113079: LD_INT 5
113081: EQUAL
113082: AND
113083: IFFALSE 113104
// ComBinocular ( unit , x , y ) ;
113085: LD_VAR 0 2
113089: PPUSH
113090: LD_VAR 0 4
113094: PPUSH
113095: LD_VAR 0 5
113099: PPUSH
113100: CALL 117125 0 3
// if selectedUnit then
113104: LD_VAR 0 3
113108: IFFALSE 113164
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
113110: LD_VAR 0 1
113114: PUSH
113115: LD_INT 254
113117: EQUAL
113118: PUSH
113119: LD_VAR 0 2
113123: PPUSH
113124: CALL_OW 264
113128: PUSH
113129: LD_INT 99
113131: EQUAL
113132: AND
113133: PUSH
113134: LD_VAR 0 3
113138: PPUSH
113139: CALL_OW 263
113143: PUSH
113144: LD_INT 3
113146: EQUAL
113147: AND
113148: IFFALSE 113164
// HackDestroyVehicle ( unit , selectedUnit ) ;
113150: LD_VAR 0 2
113154: PPUSH
113155: LD_VAR 0 3
113159: PPUSH
113160: CALL 115428 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
113164: LD_VAR 0 1
113168: PUSH
113169: LD_INT 255
113171: EQUAL
113172: PUSH
113173: LD_VAR 0 2
113177: PPUSH
113178: CALL_OW 264
113182: PUSH
113183: LD_INT 14
113185: PUSH
113186: LD_INT 53
113188: PUSH
113189: EMPTY
113190: LIST
113191: LIST
113192: IN
113193: AND
113194: PUSH
113195: LD_VAR 0 4
113199: PPUSH
113200: LD_VAR 0 5
113204: PPUSH
113205: CALL_OW 488
113209: AND
113210: IFFALSE 113234
// CutTreeXYR ( unit , x , y , 12 ) ;
113212: LD_VAR 0 2
113216: PPUSH
113217: LD_VAR 0 4
113221: PPUSH
113222: LD_VAR 0 5
113226: PPUSH
113227: LD_INT 12
113229: PPUSH
113230: CALL 113425 0 4
// if cmd = 256 then
113234: LD_VAR 0 1
113238: PUSH
113239: LD_INT 256
113241: EQUAL
113242: IFFALSE 113263
// SetFactoryWaypoint ( unit , x , y ) ;
113244: LD_VAR 0 2
113248: PPUSH
113249: LD_VAR 0 4
113253: PPUSH
113254: LD_VAR 0 5
113258: PPUSH
113259: CALL 110901 0 3
// if cmd = 257 then
113263: LD_VAR 0 1
113267: PUSH
113268: LD_INT 257
113270: EQUAL
113271: IFFALSE 113292
// SetWarehouseGatheringPoint ( unit , x , y ) ;
113273: LD_VAR 0 2
113277: PPUSH
113278: LD_VAR 0 4
113282: PPUSH
113283: LD_VAR 0 5
113287: PPUSH
113288: CALL 111391 0 3
// if cmd = 258 then
113292: LD_VAR 0 1
113296: PUSH
113297: LD_INT 258
113299: EQUAL
113300: IFFALSE 113324
// BurnTreeXYR ( unit , x , y , 8 ) ;
113302: LD_VAR 0 2
113306: PPUSH
113307: LD_VAR 0 4
113311: PPUSH
113312: LD_VAR 0 5
113316: PPUSH
113317: LD_INT 8
113319: PPUSH
113320: CALL 113819 0 4
// end ;
113324: LD_VAR 0 6
113328: RET
// export function ComRadiation ( un ) ; var eff ; begin
113329: LD_INT 0
113331: PPUSH
113332: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
113333: LD_VAR 0 1
113337: PPUSH
113338: CALL_OW 264
113342: PUSH
113343: LD_INT 91
113345: NONEQUAL
113346: IFFALSE 113350
// exit ;
113348: GO 113420
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
113350: LD_INT 68
113352: PPUSH
113353: LD_VAR 0 1
113357: PPUSH
113358: CALL_OW 255
113362: PPUSH
113363: CALL_OW 321
113367: PUSH
113368: LD_INT 2
113370: EQUAL
113371: IFFALSE 113383
// eff := 70 else
113373: LD_ADDR_VAR 0 3
113377: PUSH
113378: LD_INT 70
113380: ST_TO_ADDR
113381: GO 113391
// eff := 30 ;
113383: LD_ADDR_VAR 0 3
113387: PUSH
113388: LD_INT 30
113390: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
113391: LD_VAR 0 1
113395: PPUSH
113396: CALL_OW 250
113400: PPUSH
113401: LD_VAR 0 1
113405: PPUSH
113406: CALL_OW 251
113410: PPUSH
113411: LD_VAR 0 3
113415: PPUSH
113416: CALL_OW 495
// end ;
113420: LD_VAR 0 2
113424: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
113425: LD_INT 0
113427: PPUSH
113428: PPUSH
113429: PPUSH
113430: PPUSH
113431: PPUSH
113432: PPUSH
113433: PPUSH
113434: PPUSH
113435: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
113436: LD_VAR 0 1
113440: PPUSH
113441: CALL_OW 302
113445: NOT
113446: PUSH
113447: LD_VAR 0 2
113451: PPUSH
113452: LD_VAR 0 3
113456: PPUSH
113457: CALL_OW 488
113461: NOT
113462: OR
113463: PUSH
113464: LD_VAR 0 4
113468: NOT
113469: OR
113470: IFFALSE 113474
// exit ;
113472: GO 113814
// list := [ ] ;
113474: LD_ADDR_VAR 0 13
113478: PUSH
113479: EMPTY
113480: ST_TO_ADDR
// if x - r < 0 then
113481: LD_VAR 0 2
113485: PUSH
113486: LD_VAR 0 4
113490: MINUS
113491: PUSH
113492: LD_INT 0
113494: LESS
113495: IFFALSE 113507
// min_x := 0 else
113497: LD_ADDR_VAR 0 7
113501: PUSH
113502: LD_INT 0
113504: ST_TO_ADDR
113505: GO 113523
// min_x := x - r ;
113507: LD_ADDR_VAR 0 7
113511: PUSH
113512: LD_VAR 0 2
113516: PUSH
113517: LD_VAR 0 4
113521: MINUS
113522: ST_TO_ADDR
// if y - r < 0 then
113523: LD_VAR 0 3
113527: PUSH
113528: LD_VAR 0 4
113532: MINUS
113533: PUSH
113534: LD_INT 0
113536: LESS
113537: IFFALSE 113549
// min_y := 0 else
113539: LD_ADDR_VAR 0 8
113543: PUSH
113544: LD_INT 0
113546: ST_TO_ADDR
113547: GO 113565
// min_y := y - r ;
113549: LD_ADDR_VAR 0 8
113553: PUSH
113554: LD_VAR 0 3
113558: PUSH
113559: LD_VAR 0 4
113563: MINUS
113564: ST_TO_ADDR
// max_x := x + r ;
113565: LD_ADDR_VAR 0 9
113569: PUSH
113570: LD_VAR 0 2
113574: PUSH
113575: LD_VAR 0 4
113579: PLUS
113580: ST_TO_ADDR
// max_y := y + r ;
113581: LD_ADDR_VAR 0 10
113585: PUSH
113586: LD_VAR 0 3
113590: PUSH
113591: LD_VAR 0 4
113595: PLUS
113596: ST_TO_ADDR
// for _x = min_x to max_x do
113597: LD_ADDR_VAR 0 11
113601: PUSH
113602: DOUBLE
113603: LD_VAR 0 7
113607: DEC
113608: ST_TO_ADDR
113609: LD_VAR 0 9
113613: PUSH
113614: FOR_TO
113615: IFFALSE 113732
// for _y = min_y to max_y do
113617: LD_ADDR_VAR 0 12
113621: PUSH
113622: DOUBLE
113623: LD_VAR 0 8
113627: DEC
113628: ST_TO_ADDR
113629: LD_VAR 0 10
113633: PUSH
113634: FOR_TO
113635: IFFALSE 113728
// begin if not ValidHex ( _x , _y ) then
113637: LD_VAR 0 11
113641: PPUSH
113642: LD_VAR 0 12
113646: PPUSH
113647: CALL_OW 488
113651: NOT
113652: IFFALSE 113656
// continue ;
113654: GO 113634
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
113656: LD_VAR 0 11
113660: PPUSH
113661: LD_VAR 0 12
113665: PPUSH
113666: CALL_OW 351
113670: PUSH
113671: LD_VAR 0 11
113675: PPUSH
113676: LD_VAR 0 12
113680: PPUSH
113681: CALL_OW 554
113685: AND
113686: IFFALSE 113726
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
113688: LD_ADDR_VAR 0 13
113692: PUSH
113693: LD_VAR 0 13
113697: PPUSH
113698: LD_VAR 0 13
113702: PUSH
113703: LD_INT 1
113705: PLUS
113706: PPUSH
113707: LD_VAR 0 11
113711: PUSH
113712: LD_VAR 0 12
113716: PUSH
113717: EMPTY
113718: LIST
113719: LIST
113720: PPUSH
113721: CALL_OW 2
113725: ST_TO_ADDR
// end ;
113726: GO 113634
113728: POP
113729: POP
113730: GO 113614
113732: POP
113733: POP
// if not list then
113734: LD_VAR 0 13
113738: NOT
113739: IFFALSE 113743
// exit ;
113741: GO 113814
// for i in list do
113743: LD_ADDR_VAR 0 6
113747: PUSH
113748: LD_VAR 0 13
113752: PUSH
113753: FOR_IN
113754: IFFALSE 113812
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
113756: LD_VAR 0 1
113760: PPUSH
113761: LD_STRING M
113763: PUSH
113764: LD_VAR 0 6
113768: PUSH
113769: LD_INT 1
113771: ARRAY
113772: PUSH
113773: LD_VAR 0 6
113777: PUSH
113778: LD_INT 2
113780: ARRAY
113781: PUSH
113782: LD_INT 0
113784: PUSH
113785: LD_INT 0
113787: PUSH
113788: LD_INT 0
113790: PUSH
113791: LD_INT 0
113793: PUSH
113794: EMPTY
113795: LIST
113796: LIST
113797: LIST
113798: LIST
113799: LIST
113800: LIST
113801: LIST
113802: PUSH
113803: EMPTY
113804: LIST
113805: PPUSH
113806: CALL_OW 447
113810: GO 113753
113812: POP
113813: POP
// end ;
113814: LD_VAR 0 5
113818: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
113819: LD_INT 0
113821: PPUSH
113822: PPUSH
113823: PPUSH
113824: PPUSH
113825: PPUSH
113826: PPUSH
113827: PPUSH
113828: PPUSH
113829: PPUSH
113830: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
113831: LD_VAR 0 1
113835: PPUSH
113836: CALL_OW 302
113840: NOT
113841: PUSH
113842: LD_VAR 0 2
113846: PPUSH
113847: LD_VAR 0 3
113851: PPUSH
113852: CALL_OW 488
113856: NOT
113857: OR
113858: PUSH
113859: LD_VAR 0 4
113863: NOT
113864: OR
113865: IFFALSE 113869
// exit ;
113867: GO 114382
// list := [ ] ;
113869: LD_ADDR_VAR 0 13
113873: PUSH
113874: EMPTY
113875: ST_TO_ADDR
// if x - r < 0 then
113876: LD_VAR 0 2
113880: PUSH
113881: LD_VAR 0 4
113885: MINUS
113886: PUSH
113887: LD_INT 0
113889: LESS
113890: IFFALSE 113902
// min_x := 0 else
113892: LD_ADDR_VAR 0 7
113896: PUSH
113897: LD_INT 0
113899: ST_TO_ADDR
113900: GO 113918
// min_x := x - r ;
113902: LD_ADDR_VAR 0 7
113906: PUSH
113907: LD_VAR 0 2
113911: PUSH
113912: LD_VAR 0 4
113916: MINUS
113917: ST_TO_ADDR
// if y - r < 0 then
113918: LD_VAR 0 3
113922: PUSH
113923: LD_VAR 0 4
113927: MINUS
113928: PUSH
113929: LD_INT 0
113931: LESS
113932: IFFALSE 113944
// min_y := 0 else
113934: LD_ADDR_VAR 0 8
113938: PUSH
113939: LD_INT 0
113941: ST_TO_ADDR
113942: GO 113960
// min_y := y - r ;
113944: LD_ADDR_VAR 0 8
113948: PUSH
113949: LD_VAR 0 3
113953: PUSH
113954: LD_VAR 0 4
113958: MINUS
113959: ST_TO_ADDR
// max_x := x + r ;
113960: LD_ADDR_VAR 0 9
113964: PUSH
113965: LD_VAR 0 2
113969: PUSH
113970: LD_VAR 0 4
113974: PLUS
113975: ST_TO_ADDR
// max_y := y + r ;
113976: LD_ADDR_VAR 0 10
113980: PUSH
113981: LD_VAR 0 3
113985: PUSH
113986: LD_VAR 0 4
113990: PLUS
113991: ST_TO_ADDR
// for _x = min_x to max_x do
113992: LD_ADDR_VAR 0 11
113996: PUSH
113997: DOUBLE
113998: LD_VAR 0 7
114002: DEC
114003: ST_TO_ADDR
114004: LD_VAR 0 9
114008: PUSH
114009: FOR_TO
114010: IFFALSE 114127
// for _y = min_y to max_y do
114012: LD_ADDR_VAR 0 12
114016: PUSH
114017: DOUBLE
114018: LD_VAR 0 8
114022: DEC
114023: ST_TO_ADDR
114024: LD_VAR 0 10
114028: PUSH
114029: FOR_TO
114030: IFFALSE 114123
// begin if not ValidHex ( _x , _y ) then
114032: LD_VAR 0 11
114036: PPUSH
114037: LD_VAR 0 12
114041: PPUSH
114042: CALL_OW 488
114046: NOT
114047: IFFALSE 114051
// continue ;
114049: GO 114029
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
114051: LD_VAR 0 11
114055: PPUSH
114056: LD_VAR 0 12
114060: PPUSH
114061: CALL_OW 351
114065: PUSH
114066: LD_VAR 0 11
114070: PPUSH
114071: LD_VAR 0 12
114075: PPUSH
114076: CALL_OW 554
114080: AND
114081: IFFALSE 114121
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
114083: LD_ADDR_VAR 0 13
114087: PUSH
114088: LD_VAR 0 13
114092: PPUSH
114093: LD_VAR 0 13
114097: PUSH
114098: LD_INT 1
114100: PLUS
114101: PPUSH
114102: LD_VAR 0 11
114106: PUSH
114107: LD_VAR 0 12
114111: PUSH
114112: EMPTY
114113: LIST
114114: LIST
114115: PPUSH
114116: CALL_OW 2
114120: ST_TO_ADDR
// end ;
114121: GO 114029
114123: POP
114124: POP
114125: GO 114009
114127: POP
114128: POP
// if not list then
114129: LD_VAR 0 13
114133: NOT
114134: IFFALSE 114138
// exit ;
114136: GO 114382
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
114138: LD_ADDR_VAR 0 13
114142: PUSH
114143: LD_VAR 0 1
114147: PPUSH
114148: LD_VAR 0 13
114152: PPUSH
114153: LD_INT 1
114155: PPUSH
114156: LD_INT 1
114158: PPUSH
114159: CALL 59048 0 4
114163: ST_TO_ADDR
// ComStop ( flame ) ;
114164: LD_VAR 0 1
114168: PPUSH
114169: CALL_OW 141
// for i in list do
114173: LD_ADDR_VAR 0 6
114177: PUSH
114178: LD_VAR 0 13
114182: PUSH
114183: FOR_IN
114184: IFFALSE 114215
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
114186: LD_VAR 0 1
114190: PPUSH
114191: LD_VAR 0 6
114195: PUSH
114196: LD_INT 1
114198: ARRAY
114199: PPUSH
114200: LD_VAR 0 6
114204: PUSH
114205: LD_INT 2
114207: ARRAY
114208: PPUSH
114209: CALL_OW 176
114213: GO 114183
114215: POP
114216: POP
// repeat wait ( 0 0$1 ) ;
114217: LD_INT 35
114219: PPUSH
114220: CALL_OW 67
// task := GetTaskList ( flame ) ;
114224: LD_ADDR_VAR 0 14
114228: PUSH
114229: LD_VAR 0 1
114233: PPUSH
114234: CALL_OW 437
114238: ST_TO_ADDR
// if not task then
114239: LD_VAR 0 14
114243: NOT
114244: IFFALSE 114248
// exit ;
114246: GO 114382
// if task [ 1 ] [ 1 ] <> | then
114248: LD_VAR 0 14
114252: PUSH
114253: LD_INT 1
114255: ARRAY
114256: PUSH
114257: LD_INT 1
114259: ARRAY
114260: PUSH
114261: LD_STRING |
114263: NONEQUAL
114264: IFFALSE 114268
// exit ;
114266: GO 114382
// _x := task [ 1 ] [ 2 ] ;
114268: LD_ADDR_VAR 0 11
114272: PUSH
114273: LD_VAR 0 14
114277: PUSH
114278: LD_INT 1
114280: ARRAY
114281: PUSH
114282: LD_INT 2
114284: ARRAY
114285: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
114286: LD_ADDR_VAR 0 12
114290: PUSH
114291: LD_VAR 0 14
114295: PUSH
114296: LD_INT 1
114298: ARRAY
114299: PUSH
114300: LD_INT 3
114302: ARRAY
114303: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
114304: LD_VAR 0 11
114308: PPUSH
114309: LD_VAR 0 12
114313: PPUSH
114314: CALL_OW 351
114318: NOT
114319: PUSH
114320: LD_VAR 0 11
114324: PPUSH
114325: LD_VAR 0 12
114329: PPUSH
114330: CALL_OW 554
114334: NOT
114335: OR
114336: IFFALSE 114370
// begin task := Delete ( task , 1 ) ;
114338: LD_ADDR_VAR 0 14
114342: PUSH
114343: LD_VAR 0 14
114347: PPUSH
114348: LD_INT 1
114350: PPUSH
114351: CALL_OW 3
114355: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
114356: LD_VAR 0 1
114360: PPUSH
114361: LD_VAR 0 14
114365: PPUSH
114366: CALL_OW 446
// end ; until not HasTask ( flame ) ;
114370: LD_VAR 0 1
114374: PPUSH
114375: CALL_OW 314
114379: NOT
114380: IFFALSE 114217
// end ;
114382: LD_VAR 0 5
114386: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
114387: LD_EXP 187
114391: NOT
114392: IFFALSE 114442
114394: GO 114396
114396: DISABLE
// begin initHack := true ;
114397: LD_ADDR_EXP 187
114401: PUSH
114402: LD_INT 1
114404: ST_TO_ADDR
// hackTanks := [ ] ;
114405: LD_ADDR_EXP 188
114409: PUSH
114410: EMPTY
114411: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
114412: LD_ADDR_EXP 189
114416: PUSH
114417: EMPTY
114418: ST_TO_ADDR
// hackLimit := 3 ;
114419: LD_ADDR_EXP 190
114423: PUSH
114424: LD_INT 3
114426: ST_TO_ADDR
// hackDist := 12 ;
114427: LD_ADDR_EXP 191
114431: PUSH
114432: LD_INT 12
114434: ST_TO_ADDR
// hackCounter := [ ] ;
114435: LD_ADDR_EXP 192
114439: PUSH
114440: EMPTY
114441: ST_TO_ADDR
// end ;
114442: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
114443: LD_EXP 187
114447: PUSH
114448: LD_INT 34
114450: PUSH
114451: LD_INT 99
114453: PUSH
114454: EMPTY
114455: LIST
114456: LIST
114457: PPUSH
114458: CALL_OW 69
114462: AND
114463: IFFALSE 114716
114465: GO 114467
114467: DISABLE
114468: LD_INT 0
114470: PPUSH
114471: PPUSH
// begin enable ;
114472: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
114473: LD_ADDR_VAR 0 1
114477: PUSH
114478: LD_INT 34
114480: PUSH
114481: LD_INT 99
114483: PUSH
114484: EMPTY
114485: LIST
114486: LIST
114487: PPUSH
114488: CALL_OW 69
114492: PUSH
114493: FOR_IN
114494: IFFALSE 114714
// begin if not i in hackTanks then
114496: LD_VAR 0 1
114500: PUSH
114501: LD_EXP 188
114505: IN
114506: NOT
114507: IFFALSE 114590
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
114509: LD_ADDR_EXP 188
114513: PUSH
114514: LD_EXP 188
114518: PPUSH
114519: LD_EXP 188
114523: PUSH
114524: LD_INT 1
114526: PLUS
114527: PPUSH
114528: LD_VAR 0 1
114532: PPUSH
114533: CALL_OW 1
114537: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
114538: LD_ADDR_EXP 189
114542: PUSH
114543: LD_EXP 189
114547: PPUSH
114548: LD_EXP 189
114552: PUSH
114553: LD_INT 1
114555: PLUS
114556: PPUSH
114557: EMPTY
114558: PPUSH
114559: CALL_OW 1
114563: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
114564: LD_ADDR_EXP 192
114568: PUSH
114569: LD_EXP 192
114573: PPUSH
114574: LD_EXP 192
114578: PUSH
114579: LD_INT 1
114581: PLUS
114582: PPUSH
114583: EMPTY
114584: PPUSH
114585: CALL_OW 1
114589: ST_TO_ADDR
// end ; if not IsOk ( i ) then
114590: LD_VAR 0 1
114594: PPUSH
114595: CALL_OW 302
114599: NOT
114600: IFFALSE 114613
// begin HackUnlinkAll ( i ) ;
114602: LD_VAR 0 1
114606: PPUSH
114607: CALL 114719 0 1
// continue ;
114611: GO 114493
// end ; HackCheckCapturedStatus ( i ) ;
114613: LD_VAR 0 1
114617: PPUSH
114618: CALL 115162 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
114622: LD_ADDR_VAR 0 2
114626: PUSH
114627: LD_INT 81
114629: PUSH
114630: LD_VAR 0 1
114634: PPUSH
114635: CALL_OW 255
114639: PUSH
114640: EMPTY
114641: LIST
114642: LIST
114643: PUSH
114644: LD_INT 33
114646: PUSH
114647: LD_INT 3
114649: PUSH
114650: EMPTY
114651: LIST
114652: LIST
114653: PUSH
114654: LD_INT 91
114656: PUSH
114657: LD_VAR 0 1
114661: PUSH
114662: LD_EXP 191
114666: PUSH
114667: EMPTY
114668: LIST
114669: LIST
114670: LIST
114671: PUSH
114672: LD_INT 50
114674: PUSH
114675: EMPTY
114676: LIST
114677: PUSH
114678: EMPTY
114679: LIST
114680: LIST
114681: LIST
114682: LIST
114683: PPUSH
114684: CALL_OW 69
114688: ST_TO_ADDR
// if not tmp then
114689: LD_VAR 0 2
114693: NOT
114694: IFFALSE 114698
// continue ;
114696: GO 114493
// HackLink ( i , tmp ) ;
114698: LD_VAR 0 1
114702: PPUSH
114703: LD_VAR 0 2
114707: PPUSH
114708: CALL 114855 0 2
// end ;
114712: GO 114493
114714: POP
114715: POP
// end ;
114716: PPOPN 2
114718: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
114719: LD_INT 0
114721: PPUSH
114722: PPUSH
114723: PPUSH
// if not hack in hackTanks then
114724: LD_VAR 0 1
114728: PUSH
114729: LD_EXP 188
114733: IN
114734: NOT
114735: IFFALSE 114739
// exit ;
114737: GO 114850
// index := GetElementIndex ( hackTanks , hack ) ;
114739: LD_ADDR_VAR 0 4
114743: PUSH
114744: LD_EXP 188
114748: PPUSH
114749: LD_VAR 0 1
114753: PPUSH
114754: CALL 58345 0 2
114758: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
114759: LD_EXP 189
114763: PUSH
114764: LD_VAR 0 4
114768: ARRAY
114769: IFFALSE 114850
// begin for i in hackTanksCaptured [ index ] do
114771: LD_ADDR_VAR 0 3
114775: PUSH
114776: LD_EXP 189
114780: PUSH
114781: LD_VAR 0 4
114785: ARRAY
114786: PUSH
114787: FOR_IN
114788: IFFALSE 114814
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
114790: LD_VAR 0 3
114794: PUSH
114795: LD_INT 1
114797: ARRAY
114798: PPUSH
114799: LD_VAR 0 3
114803: PUSH
114804: LD_INT 2
114806: ARRAY
114807: PPUSH
114808: CALL_OW 235
114812: GO 114787
114814: POP
114815: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
114816: LD_ADDR_EXP 189
114820: PUSH
114821: LD_EXP 189
114825: PPUSH
114826: LD_VAR 0 4
114830: PPUSH
114831: EMPTY
114832: PPUSH
114833: CALL_OW 1
114837: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
114838: LD_VAR 0 1
114842: PPUSH
114843: LD_INT 0
114845: PPUSH
114846: CALL_OW 505
// end ; end ;
114850: LD_VAR 0 2
114854: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
114855: LD_INT 0
114857: PPUSH
114858: PPUSH
114859: PPUSH
// if not hack in hackTanks or not vehicles then
114860: LD_VAR 0 1
114864: PUSH
114865: LD_EXP 188
114869: IN
114870: NOT
114871: PUSH
114872: LD_VAR 0 2
114876: NOT
114877: OR
114878: IFFALSE 114882
// exit ;
114880: GO 115157
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
114882: LD_ADDR_VAR 0 2
114886: PUSH
114887: LD_VAR 0 1
114891: PPUSH
114892: LD_VAR 0 2
114896: PPUSH
114897: LD_INT 1
114899: PPUSH
114900: LD_INT 1
114902: PPUSH
114903: CALL 58995 0 4
114907: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
114908: LD_ADDR_VAR 0 5
114912: PUSH
114913: LD_EXP 188
114917: PPUSH
114918: LD_VAR 0 1
114922: PPUSH
114923: CALL 58345 0 2
114927: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
114928: LD_EXP 189
114932: PUSH
114933: LD_VAR 0 5
114937: ARRAY
114938: PUSH
114939: LD_EXP 190
114943: LESS
114944: IFFALSE 115133
// begin for i := 1 to vehicles do
114946: LD_ADDR_VAR 0 4
114950: PUSH
114951: DOUBLE
114952: LD_INT 1
114954: DEC
114955: ST_TO_ADDR
114956: LD_VAR 0 2
114960: PUSH
114961: FOR_TO
114962: IFFALSE 115131
// begin if hackTanksCaptured [ index ] = hackLimit then
114964: LD_EXP 189
114968: PUSH
114969: LD_VAR 0 5
114973: ARRAY
114974: PUSH
114975: LD_EXP 190
114979: EQUAL
114980: IFFALSE 114984
// break ;
114982: GO 115131
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
114984: LD_ADDR_EXP 192
114988: PUSH
114989: LD_EXP 192
114993: PPUSH
114994: LD_VAR 0 5
114998: PPUSH
114999: LD_EXP 192
115003: PUSH
115004: LD_VAR 0 5
115008: ARRAY
115009: PUSH
115010: LD_INT 1
115012: PLUS
115013: PPUSH
115014: CALL_OW 1
115018: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
115019: LD_ADDR_EXP 189
115023: PUSH
115024: LD_EXP 189
115028: PPUSH
115029: LD_VAR 0 5
115033: PUSH
115034: LD_EXP 189
115038: PUSH
115039: LD_VAR 0 5
115043: ARRAY
115044: PUSH
115045: LD_INT 1
115047: PLUS
115048: PUSH
115049: EMPTY
115050: LIST
115051: LIST
115052: PPUSH
115053: LD_VAR 0 2
115057: PUSH
115058: LD_VAR 0 4
115062: ARRAY
115063: PUSH
115064: LD_VAR 0 2
115068: PUSH
115069: LD_VAR 0 4
115073: ARRAY
115074: PPUSH
115075: CALL_OW 255
115079: PUSH
115080: EMPTY
115081: LIST
115082: LIST
115083: PPUSH
115084: CALL 58560 0 3
115088: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
115089: LD_VAR 0 2
115093: PUSH
115094: LD_VAR 0 4
115098: ARRAY
115099: PPUSH
115100: LD_VAR 0 1
115104: PPUSH
115105: CALL_OW 255
115109: PPUSH
115110: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
115114: LD_VAR 0 2
115118: PUSH
115119: LD_VAR 0 4
115123: ARRAY
115124: PPUSH
115125: CALL_OW 141
// end ;
115129: GO 114961
115131: POP
115132: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
115133: LD_VAR 0 1
115137: PPUSH
115138: LD_EXP 189
115142: PUSH
115143: LD_VAR 0 5
115147: ARRAY
115148: PUSH
115149: LD_INT 0
115151: PLUS
115152: PPUSH
115153: CALL_OW 505
// end ;
115157: LD_VAR 0 3
115161: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
115162: LD_INT 0
115164: PPUSH
115165: PPUSH
115166: PPUSH
115167: PPUSH
// if not hack in hackTanks then
115168: LD_VAR 0 1
115172: PUSH
115173: LD_EXP 188
115177: IN
115178: NOT
115179: IFFALSE 115183
// exit ;
115181: GO 115423
// index := GetElementIndex ( hackTanks , hack ) ;
115183: LD_ADDR_VAR 0 4
115187: PUSH
115188: LD_EXP 188
115192: PPUSH
115193: LD_VAR 0 1
115197: PPUSH
115198: CALL 58345 0 2
115202: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
115203: LD_ADDR_VAR 0 3
115207: PUSH
115208: DOUBLE
115209: LD_EXP 189
115213: PUSH
115214: LD_VAR 0 4
115218: ARRAY
115219: INC
115220: ST_TO_ADDR
115221: LD_INT 1
115223: PUSH
115224: FOR_DOWNTO
115225: IFFALSE 115397
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
115227: LD_ADDR_VAR 0 5
115231: PUSH
115232: LD_EXP 189
115236: PUSH
115237: LD_VAR 0 4
115241: ARRAY
115242: PUSH
115243: LD_VAR 0 3
115247: ARRAY
115248: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
115249: LD_VAR 0 5
115253: PUSH
115254: LD_INT 1
115256: ARRAY
115257: PPUSH
115258: CALL_OW 302
115262: NOT
115263: PUSH
115264: LD_VAR 0 5
115268: PUSH
115269: LD_INT 1
115271: ARRAY
115272: PPUSH
115273: CALL_OW 255
115277: PUSH
115278: LD_VAR 0 1
115282: PPUSH
115283: CALL_OW 255
115287: NONEQUAL
115288: OR
115289: IFFALSE 115395
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
115291: LD_VAR 0 5
115295: PUSH
115296: LD_INT 1
115298: ARRAY
115299: PPUSH
115300: CALL_OW 305
115304: PUSH
115305: LD_VAR 0 5
115309: PUSH
115310: LD_INT 1
115312: ARRAY
115313: PPUSH
115314: CALL_OW 255
115318: PUSH
115319: LD_VAR 0 1
115323: PPUSH
115324: CALL_OW 255
115328: EQUAL
115329: AND
115330: IFFALSE 115354
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
115332: LD_VAR 0 5
115336: PUSH
115337: LD_INT 1
115339: ARRAY
115340: PPUSH
115341: LD_VAR 0 5
115345: PUSH
115346: LD_INT 2
115348: ARRAY
115349: PPUSH
115350: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
115354: LD_ADDR_EXP 189
115358: PUSH
115359: LD_EXP 189
115363: PPUSH
115364: LD_VAR 0 4
115368: PPUSH
115369: LD_EXP 189
115373: PUSH
115374: LD_VAR 0 4
115378: ARRAY
115379: PPUSH
115380: LD_VAR 0 3
115384: PPUSH
115385: CALL_OW 3
115389: PPUSH
115390: CALL_OW 1
115394: ST_TO_ADDR
// end ; end ;
115395: GO 115224
115397: POP
115398: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
115399: LD_VAR 0 1
115403: PPUSH
115404: LD_EXP 189
115408: PUSH
115409: LD_VAR 0 4
115413: ARRAY
115414: PUSH
115415: LD_INT 0
115417: PLUS
115418: PPUSH
115419: CALL_OW 505
// end ;
115423: LD_VAR 0 2
115427: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
115428: LD_INT 0
115430: PPUSH
115431: PPUSH
115432: PPUSH
115433: PPUSH
// if not hack in hackTanks then
115434: LD_VAR 0 1
115438: PUSH
115439: LD_EXP 188
115443: IN
115444: NOT
115445: IFFALSE 115449
// exit ;
115447: GO 115534
// index := GetElementIndex ( hackTanks , hack ) ;
115449: LD_ADDR_VAR 0 5
115453: PUSH
115454: LD_EXP 188
115458: PPUSH
115459: LD_VAR 0 1
115463: PPUSH
115464: CALL 58345 0 2
115468: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
115469: LD_ADDR_VAR 0 4
115473: PUSH
115474: DOUBLE
115475: LD_INT 1
115477: DEC
115478: ST_TO_ADDR
115479: LD_EXP 189
115483: PUSH
115484: LD_VAR 0 5
115488: ARRAY
115489: PUSH
115490: FOR_TO
115491: IFFALSE 115532
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
115493: LD_EXP 189
115497: PUSH
115498: LD_VAR 0 5
115502: ARRAY
115503: PUSH
115504: LD_VAR 0 4
115508: ARRAY
115509: PUSH
115510: LD_INT 1
115512: ARRAY
115513: PUSH
115514: LD_VAR 0 2
115518: EQUAL
115519: IFFALSE 115530
// KillUnit ( vehicle ) ;
115521: LD_VAR 0 2
115525: PPUSH
115526: CALL_OW 66
115530: GO 115490
115532: POP
115533: POP
// end ;
115534: LD_VAR 0 3
115538: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
115539: LD_EXP 193
115543: NOT
115544: IFFALSE 115579
115546: GO 115548
115548: DISABLE
// begin initMiner := true ;
115549: LD_ADDR_EXP 193
115553: PUSH
115554: LD_INT 1
115556: ST_TO_ADDR
// minersList := [ ] ;
115557: LD_ADDR_EXP 194
115561: PUSH
115562: EMPTY
115563: ST_TO_ADDR
// minerMinesList := [ ] ;
115564: LD_ADDR_EXP 195
115568: PUSH
115569: EMPTY
115570: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
115571: LD_ADDR_EXP 196
115575: PUSH
115576: LD_INT 5
115578: ST_TO_ADDR
// end ;
115579: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
115580: LD_EXP 193
115584: PUSH
115585: LD_INT 34
115587: PUSH
115588: LD_INT 81
115590: PUSH
115591: EMPTY
115592: LIST
115593: LIST
115594: PPUSH
115595: CALL_OW 69
115599: AND
115600: IFFALSE 116061
115602: GO 115604
115604: DISABLE
115605: LD_INT 0
115607: PPUSH
115608: PPUSH
115609: PPUSH
115610: PPUSH
// begin enable ;
115611: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
115612: LD_ADDR_VAR 0 1
115616: PUSH
115617: LD_INT 34
115619: PUSH
115620: LD_INT 81
115622: PUSH
115623: EMPTY
115624: LIST
115625: LIST
115626: PPUSH
115627: CALL_OW 69
115631: PUSH
115632: FOR_IN
115633: IFFALSE 115705
// begin if not i in minersList then
115635: LD_VAR 0 1
115639: PUSH
115640: LD_EXP 194
115644: IN
115645: NOT
115646: IFFALSE 115703
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
115648: LD_ADDR_EXP 194
115652: PUSH
115653: LD_EXP 194
115657: PPUSH
115658: LD_EXP 194
115662: PUSH
115663: LD_INT 1
115665: PLUS
115666: PPUSH
115667: LD_VAR 0 1
115671: PPUSH
115672: CALL_OW 1
115676: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
115677: LD_ADDR_EXP 195
115681: PUSH
115682: LD_EXP 195
115686: PPUSH
115687: LD_EXP 195
115691: PUSH
115692: LD_INT 1
115694: PLUS
115695: PPUSH
115696: EMPTY
115697: PPUSH
115698: CALL_OW 1
115702: ST_TO_ADDR
// end end ;
115703: GO 115632
115705: POP
115706: POP
// for i := minerMinesList downto 1 do
115707: LD_ADDR_VAR 0 1
115711: PUSH
115712: DOUBLE
115713: LD_EXP 195
115717: INC
115718: ST_TO_ADDR
115719: LD_INT 1
115721: PUSH
115722: FOR_DOWNTO
115723: IFFALSE 116059
// begin if IsLive ( minersList [ i ] ) then
115725: LD_EXP 194
115729: PUSH
115730: LD_VAR 0 1
115734: ARRAY
115735: PPUSH
115736: CALL_OW 300
115740: IFFALSE 115768
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
115742: LD_EXP 194
115746: PUSH
115747: LD_VAR 0 1
115751: ARRAY
115752: PPUSH
115753: LD_EXP 195
115757: PUSH
115758: LD_VAR 0 1
115762: ARRAY
115763: PPUSH
115764: CALL_OW 505
// if not minerMinesList [ i ] then
115768: LD_EXP 195
115772: PUSH
115773: LD_VAR 0 1
115777: ARRAY
115778: NOT
115779: IFFALSE 115783
// continue ;
115781: GO 115722
// for j := minerMinesList [ i ] downto 1 do
115783: LD_ADDR_VAR 0 2
115787: PUSH
115788: DOUBLE
115789: LD_EXP 195
115793: PUSH
115794: LD_VAR 0 1
115798: ARRAY
115799: INC
115800: ST_TO_ADDR
115801: LD_INT 1
115803: PUSH
115804: FOR_DOWNTO
115805: IFFALSE 116055
// begin side := GetSide ( minersList [ i ] ) ;
115807: LD_ADDR_VAR 0 3
115811: PUSH
115812: LD_EXP 194
115816: PUSH
115817: LD_VAR 0 1
115821: ARRAY
115822: PPUSH
115823: CALL_OW 255
115827: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
115828: LD_ADDR_VAR 0 4
115832: PUSH
115833: LD_EXP 195
115837: PUSH
115838: LD_VAR 0 1
115842: ARRAY
115843: PUSH
115844: LD_VAR 0 2
115848: ARRAY
115849: PUSH
115850: LD_INT 1
115852: ARRAY
115853: PPUSH
115854: LD_EXP 195
115858: PUSH
115859: LD_VAR 0 1
115863: ARRAY
115864: PUSH
115865: LD_VAR 0 2
115869: ARRAY
115870: PUSH
115871: LD_INT 2
115873: ARRAY
115874: PPUSH
115875: CALL_OW 428
115879: ST_TO_ADDR
// if not tmp then
115880: LD_VAR 0 4
115884: NOT
115885: IFFALSE 115889
// continue ;
115887: GO 115804
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
115889: LD_VAR 0 4
115893: PUSH
115894: LD_INT 81
115896: PUSH
115897: LD_VAR 0 3
115901: PUSH
115902: EMPTY
115903: LIST
115904: LIST
115905: PPUSH
115906: CALL_OW 69
115910: IN
115911: PUSH
115912: LD_EXP 195
115916: PUSH
115917: LD_VAR 0 1
115921: ARRAY
115922: PUSH
115923: LD_VAR 0 2
115927: ARRAY
115928: PUSH
115929: LD_INT 1
115931: ARRAY
115932: PPUSH
115933: LD_EXP 195
115937: PUSH
115938: LD_VAR 0 1
115942: ARRAY
115943: PUSH
115944: LD_VAR 0 2
115948: ARRAY
115949: PUSH
115950: LD_INT 2
115952: ARRAY
115953: PPUSH
115954: CALL_OW 458
115958: AND
115959: IFFALSE 116053
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
115961: LD_EXP 195
115965: PUSH
115966: LD_VAR 0 1
115970: ARRAY
115971: PUSH
115972: LD_VAR 0 2
115976: ARRAY
115977: PUSH
115978: LD_INT 1
115980: ARRAY
115981: PPUSH
115982: LD_EXP 195
115986: PUSH
115987: LD_VAR 0 1
115991: ARRAY
115992: PUSH
115993: LD_VAR 0 2
115997: ARRAY
115998: PUSH
115999: LD_INT 2
116001: ARRAY
116002: PPUSH
116003: LD_VAR 0 3
116007: PPUSH
116008: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
116012: LD_ADDR_EXP 195
116016: PUSH
116017: LD_EXP 195
116021: PPUSH
116022: LD_VAR 0 1
116026: PPUSH
116027: LD_EXP 195
116031: PUSH
116032: LD_VAR 0 1
116036: ARRAY
116037: PPUSH
116038: LD_VAR 0 2
116042: PPUSH
116043: CALL_OW 3
116047: PPUSH
116048: CALL_OW 1
116052: ST_TO_ADDR
// end ; end ;
116053: GO 115804
116055: POP
116056: POP
// end ;
116057: GO 115722
116059: POP
116060: POP
// end ;
116061: PPOPN 4
116063: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
116064: LD_INT 0
116066: PPUSH
116067: PPUSH
// result := false ;
116068: LD_ADDR_VAR 0 4
116072: PUSH
116073: LD_INT 0
116075: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
116076: LD_VAR 0 1
116080: PPUSH
116081: CALL_OW 264
116085: PUSH
116086: LD_INT 81
116088: EQUAL
116089: NOT
116090: IFFALSE 116094
// exit ;
116092: GO 116334
// index := GetElementIndex ( minersList , unit ) ;
116094: LD_ADDR_VAR 0 5
116098: PUSH
116099: LD_EXP 194
116103: PPUSH
116104: LD_VAR 0 1
116108: PPUSH
116109: CALL 58345 0 2
116113: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
116114: LD_EXP 195
116118: PUSH
116119: LD_VAR 0 5
116123: ARRAY
116124: PUSH
116125: LD_EXP 196
116129: GREATEREQUAL
116130: IFFALSE 116134
// exit ;
116132: GO 116334
// ComMoveXY ( unit , x , y ) ;
116134: LD_VAR 0 1
116138: PPUSH
116139: LD_VAR 0 2
116143: PPUSH
116144: LD_VAR 0 3
116148: PPUSH
116149: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
116153: LD_INT 35
116155: PPUSH
116156: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
116160: LD_VAR 0 1
116164: PPUSH
116165: LD_VAR 0 2
116169: PPUSH
116170: LD_VAR 0 3
116174: PPUSH
116175: CALL 90106 0 3
116179: NOT
116180: PUSH
116181: LD_VAR 0 1
116185: PPUSH
116186: CALL_OW 314
116190: AND
116191: IFFALSE 116195
// exit ;
116193: GO 116334
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
116195: LD_VAR 0 2
116199: PPUSH
116200: LD_VAR 0 3
116204: PPUSH
116205: CALL_OW 428
116209: PUSH
116210: LD_VAR 0 1
116214: EQUAL
116215: PUSH
116216: LD_VAR 0 1
116220: PPUSH
116221: CALL_OW 314
116225: NOT
116226: AND
116227: IFFALSE 116153
// PlaySoundXY ( x , y , PlantMine ) ;
116229: LD_VAR 0 2
116233: PPUSH
116234: LD_VAR 0 3
116238: PPUSH
116239: LD_STRING PlantMine
116241: PPUSH
116242: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
116246: LD_VAR 0 2
116250: PPUSH
116251: LD_VAR 0 3
116255: PPUSH
116256: LD_VAR 0 1
116260: PPUSH
116261: CALL_OW 255
116265: PPUSH
116266: LD_INT 0
116268: PPUSH
116269: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
116273: LD_ADDR_EXP 195
116277: PUSH
116278: LD_EXP 195
116282: PPUSH
116283: LD_VAR 0 5
116287: PUSH
116288: LD_EXP 195
116292: PUSH
116293: LD_VAR 0 5
116297: ARRAY
116298: PUSH
116299: LD_INT 1
116301: PLUS
116302: PUSH
116303: EMPTY
116304: LIST
116305: LIST
116306: PPUSH
116307: LD_VAR 0 2
116311: PUSH
116312: LD_VAR 0 3
116316: PUSH
116317: EMPTY
116318: LIST
116319: LIST
116320: PPUSH
116321: CALL 58560 0 3
116325: ST_TO_ADDR
// result := true ;
116326: LD_ADDR_VAR 0 4
116330: PUSH
116331: LD_INT 1
116333: ST_TO_ADDR
// end ;
116334: LD_VAR 0 4
116338: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
116339: LD_INT 0
116341: PPUSH
116342: PPUSH
116343: PPUSH
// if not unit in minersList then
116344: LD_VAR 0 1
116348: PUSH
116349: LD_EXP 194
116353: IN
116354: NOT
116355: IFFALSE 116359
// exit ;
116357: GO 116751
// index := GetElementIndex ( minersList , unit ) ;
116359: LD_ADDR_VAR 0 6
116363: PUSH
116364: LD_EXP 194
116368: PPUSH
116369: LD_VAR 0 1
116373: PPUSH
116374: CALL 58345 0 2
116378: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
116379: LD_ADDR_VAR 0 5
116383: PUSH
116384: DOUBLE
116385: LD_EXP 195
116389: PUSH
116390: LD_VAR 0 6
116394: ARRAY
116395: INC
116396: ST_TO_ADDR
116397: LD_INT 1
116399: PUSH
116400: FOR_DOWNTO
116401: IFFALSE 116562
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
116403: LD_EXP 195
116407: PUSH
116408: LD_VAR 0 6
116412: ARRAY
116413: PUSH
116414: LD_VAR 0 5
116418: ARRAY
116419: PUSH
116420: LD_INT 1
116422: ARRAY
116423: PUSH
116424: LD_VAR 0 2
116428: EQUAL
116429: PUSH
116430: LD_EXP 195
116434: PUSH
116435: LD_VAR 0 6
116439: ARRAY
116440: PUSH
116441: LD_VAR 0 5
116445: ARRAY
116446: PUSH
116447: LD_INT 2
116449: ARRAY
116450: PUSH
116451: LD_VAR 0 3
116455: EQUAL
116456: AND
116457: IFFALSE 116560
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
116459: LD_EXP 195
116463: PUSH
116464: LD_VAR 0 6
116468: ARRAY
116469: PUSH
116470: LD_VAR 0 5
116474: ARRAY
116475: PUSH
116476: LD_INT 1
116478: ARRAY
116479: PPUSH
116480: LD_EXP 195
116484: PUSH
116485: LD_VAR 0 6
116489: ARRAY
116490: PUSH
116491: LD_VAR 0 5
116495: ARRAY
116496: PUSH
116497: LD_INT 2
116499: ARRAY
116500: PPUSH
116501: LD_VAR 0 1
116505: PPUSH
116506: CALL_OW 255
116510: PPUSH
116511: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
116515: LD_ADDR_EXP 195
116519: PUSH
116520: LD_EXP 195
116524: PPUSH
116525: LD_VAR 0 6
116529: PPUSH
116530: LD_EXP 195
116534: PUSH
116535: LD_VAR 0 6
116539: ARRAY
116540: PPUSH
116541: LD_VAR 0 5
116545: PPUSH
116546: CALL_OW 3
116550: PPUSH
116551: CALL_OW 1
116555: ST_TO_ADDR
// exit ;
116556: POP
116557: POP
116558: GO 116751
// end ; end ;
116560: GO 116400
116562: POP
116563: POP
// for i := minerMinesList [ index ] downto 1 do
116564: LD_ADDR_VAR 0 5
116568: PUSH
116569: DOUBLE
116570: LD_EXP 195
116574: PUSH
116575: LD_VAR 0 6
116579: ARRAY
116580: INC
116581: ST_TO_ADDR
116582: LD_INT 1
116584: PUSH
116585: FOR_DOWNTO
116586: IFFALSE 116749
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
116588: LD_EXP 195
116592: PUSH
116593: LD_VAR 0 6
116597: ARRAY
116598: PUSH
116599: LD_VAR 0 5
116603: ARRAY
116604: PUSH
116605: LD_INT 1
116607: ARRAY
116608: PPUSH
116609: LD_EXP 195
116613: PUSH
116614: LD_VAR 0 6
116618: ARRAY
116619: PUSH
116620: LD_VAR 0 5
116624: ARRAY
116625: PUSH
116626: LD_INT 2
116628: ARRAY
116629: PPUSH
116630: LD_VAR 0 2
116634: PPUSH
116635: LD_VAR 0 3
116639: PPUSH
116640: CALL_OW 298
116644: PUSH
116645: LD_INT 6
116647: LESS
116648: IFFALSE 116747
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
116650: LD_EXP 195
116654: PUSH
116655: LD_VAR 0 6
116659: ARRAY
116660: PUSH
116661: LD_VAR 0 5
116665: ARRAY
116666: PUSH
116667: LD_INT 1
116669: ARRAY
116670: PPUSH
116671: LD_EXP 195
116675: PUSH
116676: LD_VAR 0 6
116680: ARRAY
116681: PUSH
116682: LD_VAR 0 5
116686: ARRAY
116687: PUSH
116688: LD_INT 2
116690: ARRAY
116691: PPUSH
116692: LD_VAR 0 1
116696: PPUSH
116697: CALL_OW 255
116701: PPUSH
116702: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
116706: LD_ADDR_EXP 195
116710: PUSH
116711: LD_EXP 195
116715: PPUSH
116716: LD_VAR 0 6
116720: PPUSH
116721: LD_EXP 195
116725: PUSH
116726: LD_VAR 0 6
116730: ARRAY
116731: PPUSH
116732: LD_VAR 0 5
116736: PPUSH
116737: CALL_OW 3
116741: PPUSH
116742: CALL_OW 1
116746: ST_TO_ADDR
// end ; end ;
116747: GO 116585
116749: POP
116750: POP
// end ;
116751: LD_VAR 0 4
116755: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
116756: LD_INT 0
116758: PPUSH
116759: PPUSH
116760: PPUSH
116761: PPUSH
116762: PPUSH
116763: PPUSH
116764: PPUSH
116765: PPUSH
116766: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
116767: LD_VAR 0 1
116771: PPUSH
116772: CALL_OW 264
116776: PUSH
116777: LD_INT 81
116779: EQUAL
116780: NOT
116781: PUSH
116782: LD_VAR 0 1
116786: PUSH
116787: LD_EXP 194
116791: IN
116792: NOT
116793: OR
116794: IFFALSE 116798
// exit ;
116796: GO 117120
// index := GetElementIndex ( minersList , unit ) ;
116798: LD_ADDR_VAR 0 6
116802: PUSH
116803: LD_EXP 194
116807: PPUSH
116808: LD_VAR 0 1
116812: PPUSH
116813: CALL 58345 0 2
116817: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
116818: LD_ADDR_VAR 0 8
116822: PUSH
116823: LD_EXP 196
116827: PUSH
116828: LD_EXP 195
116832: PUSH
116833: LD_VAR 0 6
116837: ARRAY
116838: MINUS
116839: ST_TO_ADDR
// if not minesFreeAmount then
116840: LD_VAR 0 8
116844: NOT
116845: IFFALSE 116849
// exit ;
116847: GO 117120
// tmp := [ ] ;
116849: LD_ADDR_VAR 0 7
116853: PUSH
116854: EMPTY
116855: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
116856: LD_ADDR_VAR 0 5
116860: PUSH
116861: DOUBLE
116862: LD_INT 1
116864: DEC
116865: ST_TO_ADDR
116866: LD_VAR 0 8
116870: PUSH
116871: FOR_TO
116872: IFFALSE 117067
// begin _d := rand ( 0 , 5 ) ;
116874: LD_ADDR_VAR 0 11
116878: PUSH
116879: LD_INT 0
116881: PPUSH
116882: LD_INT 5
116884: PPUSH
116885: CALL_OW 12
116889: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
116890: LD_ADDR_VAR 0 12
116894: PUSH
116895: LD_INT 2
116897: PPUSH
116898: LD_INT 6
116900: PPUSH
116901: CALL_OW 12
116905: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
116906: LD_ADDR_VAR 0 9
116910: PUSH
116911: LD_VAR 0 2
116915: PPUSH
116916: LD_VAR 0 11
116920: PPUSH
116921: LD_VAR 0 12
116925: PPUSH
116926: CALL_OW 272
116930: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
116931: LD_ADDR_VAR 0 10
116935: PUSH
116936: LD_VAR 0 3
116940: PPUSH
116941: LD_VAR 0 11
116945: PPUSH
116946: LD_VAR 0 12
116950: PPUSH
116951: CALL_OW 273
116955: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
116956: LD_VAR 0 9
116960: PPUSH
116961: LD_VAR 0 10
116965: PPUSH
116966: CALL_OW 488
116970: PUSH
116971: LD_VAR 0 9
116975: PUSH
116976: LD_VAR 0 10
116980: PUSH
116981: EMPTY
116982: LIST
116983: LIST
116984: PUSH
116985: LD_VAR 0 7
116989: IN
116990: NOT
116991: AND
116992: PUSH
116993: LD_VAR 0 9
116997: PPUSH
116998: LD_VAR 0 10
117002: PPUSH
117003: CALL_OW 458
117007: NOT
117008: AND
117009: IFFALSE 117051
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
117011: LD_ADDR_VAR 0 7
117015: PUSH
117016: LD_VAR 0 7
117020: PPUSH
117021: LD_VAR 0 7
117025: PUSH
117026: LD_INT 1
117028: PLUS
117029: PPUSH
117030: LD_VAR 0 9
117034: PUSH
117035: LD_VAR 0 10
117039: PUSH
117040: EMPTY
117041: LIST
117042: LIST
117043: PPUSH
117044: CALL_OW 1
117048: ST_TO_ADDR
117049: GO 117065
// i := i - 1 ;
117051: LD_ADDR_VAR 0 5
117055: PUSH
117056: LD_VAR 0 5
117060: PUSH
117061: LD_INT 1
117063: MINUS
117064: ST_TO_ADDR
// end ;
117065: GO 116871
117067: POP
117068: POP
// for i in tmp do
117069: LD_ADDR_VAR 0 5
117073: PUSH
117074: LD_VAR 0 7
117078: PUSH
117079: FOR_IN
117080: IFFALSE 117118
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
117082: LD_VAR 0 1
117086: PPUSH
117087: LD_VAR 0 5
117091: PUSH
117092: LD_INT 1
117094: ARRAY
117095: PPUSH
117096: LD_VAR 0 5
117100: PUSH
117101: LD_INT 2
117103: ARRAY
117104: PPUSH
117105: CALL 116064 0 3
117109: NOT
117110: IFFALSE 117116
// exit ;
117112: POP
117113: POP
117114: GO 117120
117116: GO 117079
117118: POP
117119: POP
// end ;
117120: LD_VAR 0 4
117124: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
117125: LD_INT 0
117127: PPUSH
117128: PPUSH
117129: PPUSH
117130: PPUSH
117131: PPUSH
117132: PPUSH
117133: PPUSH
117134: PPUSH
117135: PPUSH
// if GetClass ( unit ) <> class_sniper then
117136: LD_VAR 0 1
117140: PPUSH
117141: CALL_OW 257
117145: PUSH
117146: LD_INT 5
117148: NONEQUAL
117149: IFFALSE 117153
// exit ;
117151: GO 117619
// dist := 8 ;
117153: LD_ADDR_VAR 0 5
117157: PUSH
117158: LD_INT 8
117160: ST_TO_ADDR
// viewRange := 12 ;
117161: LD_ADDR_VAR 0 8
117165: PUSH
117166: LD_INT 12
117168: ST_TO_ADDR
// side := GetSide ( unit ) ;
117169: LD_ADDR_VAR 0 6
117173: PUSH
117174: LD_VAR 0 1
117178: PPUSH
117179: CALL_OW 255
117183: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
117184: LD_INT 61
117186: PPUSH
117187: LD_VAR 0 6
117191: PPUSH
117192: CALL_OW 321
117196: PUSH
117197: LD_INT 2
117199: EQUAL
117200: IFFALSE 117210
// viewRange := 16 ;
117202: LD_ADDR_VAR 0 8
117206: PUSH
117207: LD_INT 16
117209: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
117210: LD_VAR 0 1
117214: PPUSH
117215: LD_VAR 0 2
117219: PPUSH
117220: LD_VAR 0 3
117224: PPUSH
117225: CALL_OW 297
117229: PUSH
117230: LD_VAR 0 5
117234: GREATER
117235: IFFALSE 117314
// begin ComMoveXY ( unit , x , y ) ;
117237: LD_VAR 0 1
117241: PPUSH
117242: LD_VAR 0 2
117246: PPUSH
117247: LD_VAR 0 3
117251: PPUSH
117252: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
117256: LD_INT 35
117258: PPUSH
117259: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
117263: LD_VAR 0 1
117267: PPUSH
117268: LD_VAR 0 2
117272: PPUSH
117273: LD_VAR 0 3
117277: PPUSH
117278: CALL 90106 0 3
117282: NOT
117283: IFFALSE 117287
// exit ;
117285: GO 117619
// until GetDistUnitXY ( unit , x , y ) < dist ;
117287: LD_VAR 0 1
117291: PPUSH
117292: LD_VAR 0 2
117296: PPUSH
117297: LD_VAR 0 3
117301: PPUSH
117302: CALL_OW 297
117306: PUSH
117307: LD_VAR 0 5
117311: LESS
117312: IFFALSE 117256
// end ; ComTurnXY ( unit , x , y ) ;
117314: LD_VAR 0 1
117318: PPUSH
117319: LD_VAR 0 2
117323: PPUSH
117324: LD_VAR 0 3
117328: PPUSH
117329: CALL_OW 118
// repeat if Multiplayer then
117333: LD_OWVAR 4
117337: IFFALSE 117348
// wait ( 35 ) else
117339: LD_INT 35
117341: PPUSH
117342: CALL_OW 67
117346: GO 117355
// wait ( 5 ) ;
117348: LD_INT 5
117350: PPUSH
117351: CALL_OW 67
// _d := GetDir ( unit ) ;
117355: LD_ADDR_VAR 0 11
117359: PUSH
117360: LD_VAR 0 1
117364: PPUSH
117365: CALL_OW 254
117369: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
117370: LD_ADDR_VAR 0 7
117374: PUSH
117375: LD_VAR 0 1
117379: PPUSH
117380: CALL_OW 250
117384: PPUSH
117385: LD_VAR 0 1
117389: PPUSH
117390: CALL_OW 251
117394: PPUSH
117395: LD_VAR 0 2
117399: PPUSH
117400: LD_VAR 0 3
117404: PPUSH
117405: CALL 92714 0 4
117409: ST_TO_ADDR
// until dir = _d ;
117410: LD_VAR 0 7
117414: PUSH
117415: LD_VAR 0 11
117419: EQUAL
117420: IFFALSE 117333
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
117422: LD_ADDR_VAR 0 9
117426: PUSH
117427: LD_VAR 0 1
117431: PPUSH
117432: CALL_OW 250
117436: PPUSH
117437: LD_VAR 0 7
117441: PPUSH
117442: LD_VAR 0 5
117446: PPUSH
117447: CALL_OW 272
117451: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
117452: LD_ADDR_VAR 0 10
117456: PUSH
117457: LD_VAR 0 1
117461: PPUSH
117462: CALL_OW 251
117466: PPUSH
117467: LD_VAR 0 7
117471: PPUSH
117472: LD_VAR 0 5
117476: PPUSH
117477: CALL_OW 273
117481: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
117482: LD_VAR 0 9
117486: PPUSH
117487: LD_VAR 0 10
117491: PPUSH
117492: CALL_OW 488
117496: NOT
117497: IFFALSE 117501
// exit ;
117499: GO 117619
// ComAnimCustom ( unit , 1 ) ;
117501: LD_VAR 0 1
117505: PPUSH
117506: LD_INT 1
117508: PPUSH
117509: CALL_OW 592
// p := 0 ;
117513: LD_ADDR_VAR 0 12
117517: PUSH
117518: LD_INT 0
117520: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
117521: LD_VAR 0 9
117525: PPUSH
117526: LD_VAR 0 10
117530: PPUSH
117531: LD_VAR 0 6
117535: PPUSH
117536: LD_VAR 0 8
117540: PPUSH
117541: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
117545: LD_INT 35
117547: PPUSH
117548: CALL_OW 67
// p := Inc ( p ) ;
117552: LD_ADDR_VAR 0 12
117556: PUSH
117557: LD_VAR 0 12
117561: PPUSH
117562: CALL 92670 0 1
117566: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
117567: LD_VAR 0 12
117571: PUSH
117572: LD_INT 3
117574: EQUAL
117575: PUSH
117576: LD_VAR 0 1
117580: PPUSH
117581: CALL_OW 302
117585: NOT
117586: OR
117587: PUSH
117588: LD_VAR 0 1
117592: PPUSH
117593: CALL_OW 301
117597: OR
117598: IFFALSE 117545
// RemoveSeeing ( _x , _y , side ) ;
117600: LD_VAR 0 9
117604: PPUSH
117605: LD_VAR 0 10
117609: PPUSH
117610: LD_VAR 0 6
117614: PPUSH
117615: CALL_OW 331
// end ; end_of_file
117619: LD_VAR 0 4
117623: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
117624: LD_INT 0
117626: PPUSH
117627: PPUSH
117628: PPUSH
117629: PPUSH
117630: PPUSH
117631: PPUSH
117632: PPUSH
117633: PPUSH
117634: PPUSH
117635: PPUSH
117636: PPUSH
117637: PPUSH
117638: PPUSH
117639: PPUSH
117640: PPUSH
117641: PPUSH
117642: PPUSH
117643: PPUSH
117644: PPUSH
117645: PPUSH
117646: PPUSH
117647: PPUSH
117648: PPUSH
117649: PPUSH
117650: PPUSH
117651: PPUSH
117652: PPUSH
117653: PPUSH
117654: PPUSH
117655: PPUSH
117656: PPUSH
117657: PPUSH
117658: PPUSH
117659: PPUSH
// if not list then
117660: LD_VAR 0 1
117664: NOT
117665: IFFALSE 117669
// exit ;
117667: GO 122328
// base := list [ 1 ] ;
117669: LD_ADDR_VAR 0 3
117673: PUSH
117674: LD_VAR 0 1
117678: PUSH
117679: LD_INT 1
117681: ARRAY
117682: ST_TO_ADDR
// group := list [ 2 ] ;
117683: LD_ADDR_VAR 0 4
117687: PUSH
117688: LD_VAR 0 1
117692: PUSH
117693: LD_INT 2
117695: ARRAY
117696: ST_TO_ADDR
// path := list [ 3 ] ;
117697: LD_ADDR_VAR 0 5
117701: PUSH
117702: LD_VAR 0 1
117706: PUSH
117707: LD_INT 3
117709: ARRAY
117710: ST_TO_ADDR
// flags := list [ 4 ] ;
117711: LD_ADDR_VAR 0 6
117715: PUSH
117716: LD_VAR 0 1
117720: PUSH
117721: LD_INT 4
117723: ARRAY
117724: ST_TO_ADDR
// mined := [ ] ;
117725: LD_ADDR_VAR 0 27
117729: PUSH
117730: EMPTY
117731: ST_TO_ADDR
// bombed := [ ] ;
117732: LD_ADDR_VAR 0 28
117736: PUSH
117737: EMPTY
117738: ST_TO_ADDR
// healers := [ ] ;
117739: LD_ADDR_VAR 0 31
117743: PUSH
117744: EMPTY
117745: ST_TO_ADDR
// to_heal := [ ] ;
117746: LD_ADDR_VAR 0 30
117750: PUSH
117751: EMPTY
117752: ST_TO_ADDR
// repairs := [ ] ;
117753: LD_ADDR_VAR 0 33
117757: PUSH
117758: EMPTY
117759: ST_TO_ADDR
// to_repair := [ ] ;
117760: LD_ADDR_VAR 0 32
117764: PUSH
117765: EMPTY
117766: ST_TO_ADDR
// if not group or not path then
117767: LD_VAR 0 4
117771: NOT
117772: PUSH
117773: LD_VAR 0 5
117777: NOT
117778: OR
117779: IFFALSE 117783
// exit ;
117781: GO 122328
// side := GetSide ( group [ 1 ] ) ;
117783: LD_ADDR_VAR 0 35
117787: PUSH
117788: LD_VAR 0 4
117792: PUSH
117793: LD_INT 1
117795: ARRAY
117796: PPUSH
117797: CALL_OW 255
117801: ST_TO_ADDR
// if flags then
117802: LD_VAR 0 6
117806: IFFALSE 117950
// begin f_ignore_area := flags [ 1 ] ;
117808: LD_ADDR_VAR 0 17
117812: PUSH
117813: LD_VAR 0 6
117817: PUSH
117818: LD_INT 1
117820: ARRAY
117821: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
117822: LD_ADDR_VAR 0 18
117826: PUSH
117827: LD_VAR 0 6
117831: PUSH
117832: LD_INT 2
117834: ARRAY
117835: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
117836: LD_ADDR_VAR 0 19
117840: PUSH
117841: LD_VAR 0 6
117845: PUSH
117846: LD_INT 3
117848: ARRAY
117849: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
117850: LD_ADDR_VAR 0 20
117854: PUSH
117855: LD_VAR 0 6
117859: PUSH
117860: LD_INT 4
117862: ARRAY
117863: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
117864: LD_ADDR_VAR 0 21
117868: PUSH
117869: LD_VAR 0 6
117873: PUSH
117874: LD_INT 5
117876: ARRAY
117877: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
117878: LD_ADDR_VAR 0 22
117882: PUSH
117883: LD_VAR 0 6
117887: PUSH
117888: LD_INT 6
117890: ARRAY
117891: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
117892: LD_ADDR_VAR 0 23
117896: PUSH
117897: LD_VAR 0 6
117901: PUSH
117902: LD_INT 7
117904: ARRAY
117905: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
117906: LD_ADDR_VAR 0 24
117910: PUSH
117911: LD_VAR 0 6
117915: PUSH
117916: LD_INT 8
117918: ARRAY
117919: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
117920: LD_ADDR_VAR 0 25
117924: PUSH
117925: LD_VAR 0 6
117929: PUSH
117930: LD_INT 9
117932: ARRAY
117933: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
117934: LD_ADDR_VAR 0 26
117938: PUSH
117939: LD_VAR 0 6
117943: PUSH
117944: LD_INT 10
117946: ARRAY
117947: ST_TO_ADDR
// end else
117948: GO 118030
// begin f_ignore_area := false ;
117950: LD_ADDR_VAR 0 17
117954: PUSH
117955: LD_INT 0
117957: ST_TO_ADDR
// f_capture := false ;
117958: LD_ADDR_VAR 0 18
117962: PUSH
117963: LD_INT 0
117965: ST_TO_ADDR
// f_ignore_civ := false ;
117966: LD_ADDR_VAR 0 19
117970: PUSH
117971: LD_INT 0
117973: ST_TO_ADDR
// f_murder := false ;
117974: LD_ADDR_VAR 0 20
117978: PUSH
117979: LD_INT 0
117981: ST_TO_ADDR
// f_mines := false ;
117982: LD_ADDR_VAR 0 21
117986: PUSH
117987: LD_INT 0
117989: ST_TO_ADDR
// f_repair := false ;
117990: LD_ADDR_VAR 0 22
117994: PUSH
117995: LD_INT 0
117997: ST_TO_ADDR
// f_heal := false ;
117998: LD_ADDR_VAR 0 23
118002: PUSH
118003: LD_INT 0
118005: ST_TO_ADDR
// f_spacetime := false ;
118006: LD_ADDR_VAR 0 24
118010: PUSH
118011: LD_INT 0
118013: ST_TO_ADDR
// f_attack_depot := false ;
118014: LD_ADDR_VAR 0 25
118018: PUSH
118019: LD_INT 0
118021: ST_TO_ADDR
// f_crawl := false ;
118022: LD_ADDR_VAR 0 26
118026: PUSH
118027: LD_INT 0
118029: ST_TO_ADDR
// end ; if f_heal then
118030: LD_VAR 0 23
118034: IFFALSE 118061
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
118036: LD_ADDR_VAR 0 31
118040: PUSH
118041: LD_VAR 0 4
118045: PPUSH
118046: LD_INT 25
118048: PUSH
118049: LD_INT 4
118051: PUSH
118052: EMPTY
118053: LIST
118054: LIST
118055: PPUSH
118056: CALL_OW 72
118060: ST_TO_ADDR
// if f_repair then
118061: LD_VAR 0 22
118065: IFFALSE 118092
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
118067: LD_ADDR_VAR 0 33
118071: PUSH
118072: LD_VAR 0 4
118076: PPUSH
118077: LD_INT 25
118079: PUSH
118080: LD_INT 3
118082: PUSH
118083: EMPTY
118084: LIST
118085: LIST
118086: PPUSH
118087: CALL_OW 72
118091: ST_TO_ADDR
// units_path := [ ] ;
118092: LD_ADDR_VAR 0 16
118096: PUSH
118097: EMPTY
118098: ST_TO_ADDR
// for i = 1 to group do
118099: LD_ADDR_VAR 0 7
118103: PUSH
118104: DOUBLE
118105: LD_INT 1
118107: DEC
118108: ST_TO_ADDR
118109: LD_VAR 0 4
118113: PUSH
118114: FOR_TO
118115: IFFALSE 118144
// units_path := Replace ( units_path , i , path ) ;
118117: LD_ADDR_VAR 0 16
118121: PUSH
118122: LD_VAR 0 16
118126: PPUSH
118127: LD_VAR 0 7
118131: PPUSH
118132: LD_VAR 0 5
118136: PPUSH
118137: CALL_OW 1
118141: ST_TO_ADDR
118142: GO 118114
118144: POP
118145: POP
// repeat for i = group downto 1 do
118146: LD_ADDR_VAR 0 7
118150: PUSH
118151: DOUBLE
118152: LD_VAR 0 4
118156: INC
118157: ST_TO_ADDR
118158: LD_INT 1
118160: PUSH
118161: FOR_DOWNTO
118162: IFFALSE 122284
// begin wait ( 5 ) ;
118164: LD_INT 5
118166: PPUSH
118167: CALL_OW 67
// tmp := [ ] ;
118171: LD_ADDR_VAR 0 14
118175: PUSH
118176: EMPTY
118177: ST_TO_ADDR
// attacking := false ;
118178: LD_ADDR_VAR 0 29
118182: PUSH
118183: LD_INT 0
118185: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
118186: LD_VAR 0 4
118190: PUSH
118191: LD_VAR 0 7
118195: ARRAY
118196: PPUSH
118197: CALL_OW 301
118201: PUSH
118202: LD_VAR 0 4
118206: PUSH
118207: LD_VAR 0 7
118211: ARRAY
118212: NOT
118213: OR
118214: IFFALSE 118323
// begin if GetType ( group [ i ] ) = unit_human then
118216: LD_VAR 0 4
118220: PUSH
118221: LD_VAR 0 7
118225: ARRAY
118226: PPUSH
118227: CALL_OW 247
118231: PUSH
118232: LD_INT 1
118234: EQUAL
118235: IFFALSE 118281
// begin to_heal := to_heal diff group [ i ] ;
118237: LD_ADDR_VAR 0 30
118241: PUSH
118242: LD_VAR 0 30
118246: PUSH
118247: LD_VAR 0 4
118251: PUSH
118252: LD_VAR 0 7
118256: ARRAY
118257: DIFF
118258: ST_TO_ADDR
// healers := healers diff group [ i ] ;
118259: LD_ADDR_VAR 0 31
118263: PUSH
118264: LD_VAR 0 31
118268: PUSH
118269: LD_VAR 0 4
118273: PUSH
118274: LD_VAR 0 7
118278: ARRAY
118279: DIFF
118280: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
118281: LD_ADDR_VAR 0 4
118285: PUSH
118286: LD_VAR 0 4
118290: PPUSH
118291: LD_VAR 0 7
118295: PPUSH
118296: CALL_OW 3
118300: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
118301: LD_ADDR_VAR 0 16
118305: PUSH
118306: LD_VAR 0 16
118310: PPUSH
118311: LD_VAR 0 7
118315: PPUSH
118316: CALL_OW 3
118320: ST_TO_ADDR
// continue ;
118321: GO 118161
// end ; if f_repair then
118323: LD_VAR 0 22
118327: IFFALSE 118816
// begin if GetType ( group [ i ] ) = unit_vehicle then
118329: LD_VAR 0 4
118333: PUSH
118334: LD_VAR 0 7
118338: ARRAY
118339: PPUSH
118340: CALL_OW 247
118344: PUSH
118345: LD_INT 2
118347: EQUAL
118348: IFFALSE 118538
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
118350: LD_VAR 0 4
118354: PUSH
118355: LD_VAR 0 7
118359: ARRAY
118360: PPUSH
118361: CALL_OW 256
118365: PUSH
118366: LD_INT 700
118368: LESS
118369: PUSH
118370: LD_VAR 0 4
118374: PUSH
118375: LD_VAR 0 7
118379: ARRAY
118380: PUSH
118381: LD_VAR 0 32
118385: IN
118386: NOT
118387: AND
118388: IFFALSE 118412
// to_repair := to_repair union group [ i ] ;
118390: LD_ADDR_VAR 0 32
118394: PUSH
118395: LD_VAR 0 32
118399: PUSH
118400: LD_VAR 0 4
118404: PUSH
118405: LD_VAR 0 7
118409: ARRAY
118410: UNION
118411: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
118412: LD_VAR 0 4
118416: PUSH
118417: LD_VAR 0 7
118421: ARRAY
118422: PPUSH
118423: CALL_OW 256
118427: PUSH
118428: LD_INT 1000
118430: EQUAL
118431: PUSH
118432: LD_VAR 0 4
118436: PUSH
118437: LD_VAR 0 7
118441: ARRAY
118442: PUSH
118443: LD_VAR 0 32
118447: IN
118448: AND
118449: IFFALSE 118473
// to_repair := to_repair diff group [ i ] ;
118451: LD_ADDR_VAR 0 32
118455: PUSH
118456: LD_VAR 0 32
118460: PUSH
118461: LD_VAR 0 4
118465: PUSH
118466: LD_VAR 0 7
118470: ARRAY
118471: DIFF
118472: ST_TO_ADDR
// if group [ i ] in to_repair then
118473: LD_VAR 0 4
118477: PUSH
118478: LD_VAR 0 7
118482: ARRAY
118483: PUSH
118484: LD_VAR 0 32
118488: IN
118489: IFFALSE 118536
// begin if not IsInArea ( group [ i ] , f_repair ) then
118491: LD_VAR 0 4
118495: PUSH
118496: LD_VAR 0 7
118500: ARRAY
118501: PPUSH
118502: LD_VAR 0 22
118506: PPUSH
118507: CALL_OW 308
118511: NOT
118512: IFFALSE 118534
// ComMoveToArea ( group [ i ] , f_repair ) ;
118514: LD_VAR 0 4
118518: PUSH
118519: LD_VAR 0 7
118523: ARRAY
118524: PPUSH
118525: LD_VAR 0 22
118529: PPUSH
118530: CALL_OW 113
// continue ;
118534: GO 118161
// end ; end else
118536: GO 118816
// if group [ i ] in repairs then
118538: LD_VAR 0 4
118542: PUSH
118543: LD_VAR 0 7
118547: ARRAY
118548: PUSH
118549: LD_VAR 0 33
118553: IN
118554: IFFALSE 118816
// begin if IsInUnit ( group [ i ] ) then
118556: LD_VAR 0 4
118560: PUSH
118561: LD_VAR 0 7
118565: ARRAY
118566: PPUSH
118567: CALL_OW 310
118571: IFFALSE 118639
// begin z := IsInUnit ( group [ i ] ) ;
118573: LD_ADDR_VAR 0 13
118577: PUSH
118578: LD_VAR 0 4
118582: PUSH
118583: LD_VAR 0 7
118587: ARRAY
118588: PPUSH
118589: CALL_OW 310
118593: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
118594: LD_VAR 0 13
118598: PUSH
118599: LD_VAR 0 32
118603: IN
118604: PUSH
118605: LD_VAR 0 13
118609: PPUSH
118610: LD_VAR 0 22
118614: PPUSH
118615: CALL_OW 308
118619: AND
118620: IFFALSE 118637
// ComExitVehicle ( group [ i ] ) ;
118622: LD_VAR 0 4
118626: PUSH
118627: LD_VAR 0 7
118631: ARRAY
118632: PPUSH
118633: CALL_OW 121
// end else
118637: GO 118816
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
118639: LD_ADDR_VAR 0 13
118643: PUSH
118644: LD_VAR 0 4
118648: PPUSH
118649: LD_INT 95
118651: PUSH
118652: LD_VAR 0 22
118656: PUSH
118657: EMPTY
118658: LIST
118659: LIST
118660: PUSH
118661: LD_INT 58
118663: PUSH
118664: EMPTY
118665: LIST
118666: PUSH
118667: EMPTY
118668: LIST
118669: LIST
118670: PPUSH
118671: CALL_OW 72
118675: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
118676: LD_VAR 0 4
118680: PUSH
118681: LD_VAR 0 7
118685: ARRAY
118686: PPUSH
118687: CALL_OW 314
118691: NOT
118692: IFFALSE 118814
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
118694: LD_ADDR_VAR 0 10
118698: PUSH
118699: LD_VAR 0 13
118703: PPUSH
118704: LD_VAR 0 4
118708: PUSH
118709: LD_VAR 0 7
118713: ARRAY
118714: PPUSH
118715: CALL_OW 74
118719: ST_TO_ADDR
// if not x then
118720: LD_VAR 0 10
118724: NOT
118725: IFFALSE 118729
// continue ;
118727: GO 118161
// if GetLives ( x ) < 1000 then
118729: LD_VAR 0 10
118733: PPUSH
118734: CALL_OW 256
118738: PUSH
118739: LD_INT 1000
118741: LESS
118742: IFFALSE 118766
// ComRepairVehicle ( group [ i ] , x ) else
118744: LD_VAR 0 4
118748: PUSH
118749: LD_VAR 0 7
118753: ARRAY
118754: PPUSH
118755: LD_VAR 0 10
118759: PPUSH
118760: CALL_OW 129
118764: GO 118814
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
118766: LD_VAR 0 23
118770: PUSH
118771: LD_VAR 0 4
118775: PUSH
118776: LD_VAR 0 7
118780: ARRAY
118781: PPUSH
118782: CALL_OW 256
118786: PUSH
118787: LD_INT 1000
118789: LESS
118790: AND
118791: NOT
118792: IFFALSE 118814
// ComEnterUnit ( group [ i ] , x ) ;
118794: LD_VAR 0 4
118798: PUSH
118799: LD_VAR 0 7
118803: ARRAY
118804: PPUSH
118805: LD_VAR 0 10
118809: PPUSH
118810: CALL_OW 120
// end ; continue ;
118814: GO 118161
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
118816: LD_VAR 0 23
118820: PUSH
118821: LD_VAR 0 4
118825: PUSH
118826: LD_VAR 0 7
118830: ARRAY
118831: PPUSH
118832: CALL_OW 247
118836: PUSH
118837: LD_INT 1
118839: EQUAL
118840: AND
118841: IFFALSE 119319
// begin if group [ i ] in healers then
118843: LD_VAR 0 4
118847: PUSH
118848: LD_VAR 0 7
118852: ARRAY
118853: PUSH
118854: LD_VAR 0 31
118858: IN
118859: IFFALSE 119132
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
118861: LD_VAR 0 4
118865: PUSH
118866: LD_VAR 0 7
118870: ARRAY
118871: PPUSH
118872: LD_VAR 0 23
118876: PPUSH
118877: CALL_OW 308
118881: NOT
118882: PUSH
118883: LD_VAR 0 4
118887: PUSH
118888: LD_VAR 0 7
118892: ARRAY
118893: PPUSH
118894: CALL_OW 314
118898: NOT
118899: AND
118900: IFFALSE 118924
// ComMoveToArea ( group [ i ] , f_heal ) else
118902: LD_VAR 0 4
118906: PUSH
118907: LD_VAR 0 7
118911: ARRAY
118912: PPUSH
118913: LD_VAR 0 23
118917: PPUSH
118918: CALL_OW 113
118922: GO 119130
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
118924: LD_VAR 0 4
118928: PUSH
118929: LD_VAR 0 7
118933: ARRAY
118934: PPUSH
118935: CALL 88689 0 1
118939: PPUSH
118940: CALL_OW 256
118944: PUSH
118945: LD_INT 1000
118947: EQUAL
118948: IFFALSE 118967
// ComStop ( group [ i ] ) else
118950: LD_VAR 0 4
118954: PUSH
118955: LD_VAR 0 7
118959: ARRAY
118960: PPUSH
118961: CALL_OW 141
118965: GO 119130
// if not HasTask ( group [ i ] ) and to_heal then
118967: LD_VAR 0 4
118971: PUSH
118972: LD_VAR 0 7
118976: ARRAY
118977: PPUSH
118978: CALL_OW 314
118982: NOT
118983: PUSH
118984: LD_VAR 0 30
118988: AND
118989: IFFALSE 119130
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
118991: LD_ADDR_VAR 0 13
118995: PUSH
118996: LD_VAR 0 30
119000: PPUSH
119001: LD_INT 3
119003: PUSH
119004: LD_INT 54
119006: PUSH
119007: EMPTY
119008: LIST
119009: PUSH
119010: EMPTY
119011: LIST
119012: LIST
119013: PPUSH
119014: CALL_OW 72
119018: PPUSH
119019: LD_VAR 0 4
119023: PUSH
119024: LD_VAR 0 7
119028: ARRAY
119029: PPUSH
119030: CALL_OW 74
119034: ST_TO_ADDR
// if z then
119035: LD_VAR 0 13
119039: IFFALSE 119130
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
119041: LD_INT 91
119043: PUSH
119044: LD_VAR 0 13
119048: PUSH
119049: LD_INT 10
119051: PUSH
119052: EMPTY
119053: LIST
119054: LIST
119055: LIST
119056: PUSH
119057: LD_INT 81
119059: PUSH
119060: LD_VAR 0 13
119064: PPUSH
119065: CALL_OW 255
119069: PUSH
119070: EMPTY
119071: LIST
119072: LIST
119073: PUSH
119074: EMPTY
119075: LIST
119076: LIST
119077: PPUSH
119078: CALL_OW 69
119082: PUSH
119083: LD_INT 0
119085: EQUAL
119086: IFFALSE 119110
// ComHeal ( group [ i ] , z ) else
119088: LD_VAR 0 4
119092: PUSH
119093: LD_VAR 0 7
119097: ARRAY
119098: PPUSH
119099: LD_VAR 0 13
119103: PPUSH
119104: CALL_OW 128
119108: GO 119130
// ComMoveToArea ( group [ i ] , f_heal ) ;
119110: LD_VAR 0 4
119114: PUSH
119115: LD_VAR 0 7
119119: ARRAY
119120: PPUSH
119121: LD_VAR 0 23
119125: PPUSH
119126: CALL_OW 113
// end ; continue ;
119130: GO 118161
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
119132: LD_VAR 0 4
119136: PUSH
119137: LD_VAR 0 7
119141: ARRAY
119142: PPUSH
119143: CALL_OW 256
119147: PUSH
119148: LD_INT 700
119150: LESS
119151: PUSH
119152: LD_VAR 0 4
119156: PUSH
119157: LD_VAR 0 7
119161: ARRAY
119162: PUSH
119163: LD_VAR 0 30
119167: IN
119168: NOT
119169: AND
119170: IFFALSE 119194
// to_heal := to_heal union group [ i ] ;
119172: LD_ADDR_VAR 0 30
119176: PUSH
119177: LD_VAR 0 30
119181: PUSH
119182: LD_VAR 0 4
119186: PUSH
119187: LD_VAR 0 7
119191: ARRAY
119192: UNION
119193: ST_TO_ADDR
// if group [ i ] in to_heal then
119194: LD_VAR 0 4
119198: PUSH
119199: LD_VAR 0 7
119203: ARRAY
119204: PUSH
119205: LD_VAR 0 30
119209: IN
119210: IFFALSE 119319
// begin if GetLives ( group [ i ] ) = 1000 then
119212: LD_VAR 0 4
119216: PUSH
119217: LD_VAR 0 7
119221: ARRAY
119222: PPUSH
119223: CALL_OW 256
119227: PUSH
119228: LD_INT 1000
119230: EQUAL
119231: IFFALSE 119257
// to_heal := to_heal diff group [ i ] else
119233: LD_ADDR_VAR 0 30
119237: PUSH
119238: LD_VAR 0 30
119242: PUSH
119243: LD_VAR 0 4
119247: PUSH
119248: LD_VAR 0 7
119252: ARRAY
119253: DIFF
119254: ST_TO_ADDR
119255: GO 119319
// begin if not IsInArea ( group [ i ] , to_heal ) then
119257: LD_VAR 0 4
119261: PUSH
119262: LD_VAR 0 7
119266: ARRAY
119267: PPUSH
119268: LD_VAR 0 30
119272: PPUSH
119273: CALL_OW 308
119277: NOT
119278: IFFALSE 119302
// ComMoveToArea ( group [ i ] , f_heal ) else
119280: LD_VAR 0 4
119284: PUSH
119285: LD_VAR 0 7
119289: ARRAY
119290: PPUSH
119291: LD_VAR 0 23
119295: PPUSH
119296: CALL_OW 113
119300: GO 119317
// ComHold ( group [ i ] ) ;
119302: LD_VAR 0 4
119306: PUSH
119307: LD_VAR 0 7
119311: ARRAY
119312: PPUSH
119313: CALL_OW 140
// continue ;
119317: GO 118161
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
119319: LD_VAR 0 4
119323: PUSH
119324: LD_VAR 0 7
119328: ARRAY
119329: PPUSH
119330: LD_INT 10
119332: PPUSH
119333: CALL 86451 0 2
119337: NOT
119338: PUSH
119339: LD_VAR 0 16
119343: PUSH
119344: LD_VAR 0 7
119348: ARRAY
119349: PUSH
119350: EMPTY
119351: EQUAL
119352: NOT
119353: AND
119354: IFFALSE 119620
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
119356: LD_VAR 0 4
119360: PUSH
119361: LD_VAR 0 7
119365: ARRAY
119366: PPUSH
119367: CALL_OW 262
119371: PUSH
119372: LD_INT 1
119374: PUSH
119375: LD_INT 2
119377: PUSH
119378: EMPTY
119379: LIST
119380: LIST
119381: IN
119382: IFFALSE 119423
// if GetFuel ( group [ i ] ) < 10 then
119384: LD_VAR 0 4
119388: PUSH
119389: LD_VAR 0 7
119393: ARRAY
119394: PPUSH
119395: CALL_OW 261
119399: PUSH
119400: LD_INT 10
119402: LESS
119403: IFFALSE 119423
// SetFuel ( group [ i ] , 12 ) ;
119405: LD_VAR 0 4
119409: PUSH
119410: LD_VAR 0 7
119414: ARRAY
119415: PPUSH
119416: LD_INT 12
119418: PPUSH
119419: CALL_OW 240
// if units_path [ i ] then
119423: LD_VAR 0 16
119427: PUSH
119428: LD_VAR 0 7
119432: ARRAY
119433: IFFALSE 119618
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
119435: LD_VAR 0 4
119439: PUSH
119440: LD_VAR 0 7
119444: ARRAY
119445: PPUSH
119446: LD_VAR 0 16
119450: PUSH
119451: LD_VAR 0 7
119455: ARRAY
119456: PUSH
119457: LD_INT 1
119459: ARRAY
119460: PUSH
119461: LD_INT 1
119463: ARRAY
119464: PPUSH
119465: LD_VAR 0 16
119469: PUSH
119470: LD_VAR 0 7
119474: ARRAY
119475: PUSH
119476: LD_INT 1
119478: ARRAY
119479: PUSH
119480: LD_INT 2
119482: ARRAY
119483: PPUSH
119484: CALL_OW 297
119488: PUSH
119489: LD_INT 6
119491: GREATER
119492: IFFALSE 119567
// begin if not HasTask ( group [ i ] ) then
119494: LD_VAR 0 4
119498: PUSH
119499: LD_VAR 0 7
119503: ARRAY
119504: PPUSH
119505: CALL_OW 314
119509: NOT
119510: IFFALSE 119565
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
119512: LD_VAR 0 4
119516: PUSH
119517: LD_VAR 0 7
119521: ARRAY
119522: PPUSH
119523: LD_VAR 0 16
119527: PUSH
119528: LD_VAR 0 7
119532: ARRAY
119533: PUSH
119534: LD_INT 1
119536: ARRAY
119537: PUSH
119538: LD_INT 1
119540: ARRAY
119541: PPUSH
119542: LD_VAR 0 16
119546: PUSH
119547: LD_VAR 0 7
119551: ARRAY
119552: PUSH
119553: LD_INT 1
119555: ARRAY
119556: PUSH
119557: LD_INT 2
119559: ARRAY
119560: PPUSH
119561: CALL_OW 114
// end else
119565: GO 119618
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
119567: LD_ADDR_VAR 0 15
119571: PUSH
119572: LD_VAR 0 16
119576: PUSH
119577: LD_VAR 0 7
119581: ARRAY
119582: PPUSH
119583: LD_INT 1
119585: PPUSH
119586: CALL_OW 3
119590: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
119591: LD_ADDR_VAR 0 16
119595: PUSH
119596: LD_VAR 0 16
119600: PPUSH
119601: LD_VAR 0 7
119605: PPUSH
119606: LD_VAR 0 15
119610: PPUSH
119611: CALL_OW 1
119615: ST_TO_ADDR
// continue ;
119616: GO 118161
// end ; end ; end else
119618: GO 122282
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
119620: LD_ADDR_VAR 0 14
119624: PUSH
119625: LD_INT 81
119627: PUSH
119628: LD_VAR 0 4
119632: PUSH
119633: LD_VAR 0 7
119637: ARRAY
119638: PPUSH
119639: CALL_OW 255
119643: PUSH
119644: EMPTY
119645: LIST
119646: LIST
119647: PPUSH
119648: CALL_OW 69
119652: ST_TO_ADDR
// if not tmp then
119653: LD_VAR 0 14
119657: NOT
119658: IFFALSE 119662
// continue ;
119660: GO 118161
// if f_ignore_area then
119662: LD_VAR 0 17
119666: IFFALSE 119754
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
119668: LD_ADDR_VAR 0 15
119672: PUSH
119673: LD_VAR 0 14
119677: PPUSH
119678: LD_INT 3
119680: PUSH
119681: LD_INT 92
119683: PUSH
119684: LD_VAR 0 17
119688: PUSH
119689: LD_INT 1
119691: ARRAY
119692: PUSH
119693: LD_VAR 0 17
119697: PUSH
119698: LD_INT 2
119700: ARRAY
119701: PUSH
119702: LD_VAR 0 17
119706: PUSH
119707: LD_INT 3
119709: ARRAY
119710: PUSH
119711: EMPTY
119712: LIST
119713: LIST
119714: LIST
119715: LIST
119716: PUSH
119717: EMPTY
119718: LIST
119719: LIST
119720: PPUSH
119721: CALL_OW 72
119725: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
119726: LD_VAR 0 14
119730: PUSH
119731: LD_VAR 0 15
119735: DIFF
119736: IFFALSE 119754
// tmp := tmp diff tmp2 ;
119738: LD_ADDR_VAR 0 14
119742: PUSH
119743: LD_VAR 0 14
119747: PUSH
119748: LD_VAR 0 15
119752: DIFF
119753: ST_TO_ADDR
// end ; if not f_murder then
119754: LD_VAR 0 20
119758: NOT
119759: IFFALSE 119817
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
119761: LD_ADDR_VAR 0 15
119765: PUSH
119766: LD_VAR 0 14
119770: PPUSH
119771: LD_INT 3
119773: PUSH
119774: LD_INT 50
119776: PUSH
119777: EMPTY
119778: LIST
119779: PUSH
119780: EMPTY
119781: LIST
119782: LIST
119783: PPUSH
119784: CALL_OW 72
119788: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
119789: LD_VAR 0 14
119793: PUSH
119794: LD_VAR 0 15
119798: DIFF
119799: IFFALSE 119817
// tmp := tmp diff tmp2 ;
119801: LD_ADDR_VAR 0 14
119805: PUSH
119806: LD_VAR 0 14
119810: PUSH
119811: LD_VAR 0 15
119815: DIFF
119816: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
119817: LD_ADDR_VAR 0 14
119821: PUSH
119822: LD_VAR 0 4
119826: PUSH
119827: LD_VAR 0 7
119831: ARRAY
119832: PPUSH
119833: LD_VAR 0 14
119837: PPUSH
119838: LD_INT 1
119840: PPUSH
119841: LD_INT 1
119843: PPUSH
119844: CALL 58995 0 4
119848: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
119849: LD_VAR 0 4
119853: PUSH
119854: LD_VAR 0 7
119858: ARRAY
119859: PPUSH
119860: CALL_OW 257
119864: PUSH
119865: LD_INT 1
119867: EQUAL
119868: IFFALSE 120316
// begin if WantPlant ( group [ i ] ) then
119870: LD_VAR 0 4
119874: PUSH
119875: LD_VAR 0 7
119879: ARRAY
119880: PPUSH
119881: CALL 58496 0 1
119885: IFFALSE 119889
// continue ;
119887: GO 118161
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
119889: LD_VAR 0 18
119893: PUSH
119894: LD_VAR 0 4
119898: PUSH
119899: LD_VAR 0 7
119903: ARRAY
119904: PPUSH
119905: CALL_OW 310
119909: NOT
119910: AND
119911: PUSH
119912: LD_VAR 0 14
119916: PUSH
119917: LD_INT 1
119919: ARRAY
119920: PUSH
119921: LD_VAR 0 14
119925: PPUSH
119926: LD_INT 21
119928: PUSH
119929: LD_INT 2
119931: PUSH
119932: EMPTY
119933: LIST
119934: LIST
119935: PUSH
119936: LD_INT 58
119938: PUSH
119939: EMPTY
119940: LIST
119941: PUSH
119942: EMPTY
119943: LIST
119944: LIST
119945: PPUSH
119946: CALL_OW 72
119950: IN
119951: AND
119952: IFFALSE 119988
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
119954: LD_VAR 0 4
119958: PUSH
119959: LD_VAR 0 7
119963: ARRAY
119964: PPUSH
119965: LD_VAR 0 14
119969: PUSH
119970: LD_INT 1
119972: ARRAY
119973: PPUSH
119974: CALL_OW 120
// attacking := true ;
119978: LD_ADDR_VAR 0 29
119982: PUSH
119983: LD_INT 1
119985: ST_TO_ADDR
// continue ;
119986: GO 118161
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
119988: LD_VAR 0 26
119992: PUSH
119993: LD_VAR 0 4
119997: PUSH
119998: LD_VAR 0 7
120002: ARRAY
120003: PPUSH
120004: CALL_OW 257
120008: PUSH
120009: LD_INT 1
120011: EQUAL
120012: AND
120013: PUSH
120014: LD_VAR 0 4
120018: PUSH
120019: LD_VAR 0 7
120023: ARRAY
120024: PPUSH
120025: CALL_OW 256
120029: PUSH
120030: LD_INT 800
120032: LESS
120033: AND
120034: PUSH
120035: LD_VAR 0 4
120039: PUSH
120040: LD_VAR 0 7
120044: ARRAY
120045: PPUSH
120046: CALL_OW 318
120050: NOT
120051: AND
120052: IFFALSE 120069
// ComCrawl ( group [ i ] ) ;
120054: LD_VAR 0 4
120058: PUSH
120059: LD_VAR 0 7
120063: ARRAY
120064: PPUSH
120065: CALL_OW 137
// if f_mines then
120069: LD_VAR 0 21
120073: IFFALSE 120316
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
120075: LD_VAR 0 14
120079: PUSH
120080: LD_INT 1
120082: ARRAY
120083: PPUSH
120084: CALL_OW 247
120088: PUSH
120089: LD_INT 3
120091: EQUAL
120092: PUSH
120093: LD_VAR 0 14
120097: PUSH
120098: LD_INT 1
120100: ARRAY
120101: PUSH
120102: LD_VAR 0 27
120106: IN
120107: NOT
120108: AND
120109: IFFALSE 120316
// begin x := GetX ( tmp [ 1 ] ) ;
120111: LD_ADDR_VAR 0 10
120115: PUSH
120116: LD_VAR 0 14
120120: PUSH
120121: LD_INT 1
120123: ARRAY
120124: PPUSH
120125: CALL_OW 250
120129: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
120130: LD_ADDR_VAR 0 11
120134: PUSH
120135: LD_VAR 0 14
120139: PUSH
120140: LD_INT 1
120142: ARRAY
120143: PPUSH
120144: CALL_OW 251
120148: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
120149: LD_ADDR_VAR 0 12
120153: PUSH
120154: LD_VAR 0 4
120158: PUSH
120159: LD_VAR 0 7
120163: ARRAY
120164: PPUSH
120165: CALL 86536 0 1
120169: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
120170: LD_VAR 0 4
120174: PUSH
120175: LD_VAR 0 7
120179: ARRAY
120180: PPUSH
120181: LD_VAR 0 10
120185: PPUSH
120186: LD_VAR 0 11
120190: PPUSH
120191: LD_VAR 0 14
120195: PUSH
120196: LD_INT 1
120198: ARRAY
120199: PPUSH
120200: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
120204: LD_VAR 0 4
120208: PUSH
120209: LD_VAR 0 7
120213: ARRAY
120214: PPUSH
120215: LD_VAR 0 10
120219: PPUSH
120220: LD_VAR 0 12
120224: PPUSH
120225: LD_INT 7
120227: PPUSH
120228: CALL_OW 272
120232: PPUSH
120233: LD_VAR 0 11
120237: PPUSH
120238: LD_VAR 0 12
120242: PPUSH
120243: LD_INT 7
120245: PPUSH
120246: CALL_OW 273
120250: PPUSH
120251: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
120255: LD_VAR 0 4
120259: PUSH
120260: LD_VAR 0 7
120264: ARRAY
120265: PPUSH
120266: LD_INT 71
120268: PPUSH
120269: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
120273: LD_ADDR_VAR 0 27
120277: PUSH
120278: LD_VAR 0 27
120282: PPUSH
120283: LD_VAR 0 27
120287: PUSH
120288: LD_INT 1
120290: PLUS
120291: PPUSH
120292: LD_VAR 0 14
120296: PUSH
120297: LD_INT 1
120299: ARRAY
120300: PPUSH
120301: CALL_OW 1
120305: ST_TO_ADDR
// attacking := true ;
120306: LD_ADDR_VAR 0 29
120310: PUSH
120311: LD_INT 1
120313: ST_TO_ADDR
// continue ;
120314: GO 118161
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
120316: LD_VAR 0 4
120320: PUSH
120321: LD_VAR 0 7
120325: ARRAY
120326: PPUSH
120327: CALL_OW 257
120331: PUSH
120332: LD_INT 17
120334: EQUAL
120335: PUSH
120336: LD_VAR 0 4
120340: PUSH
120341: LD_VAR 0 7
120345: ARRAY
120346: PPUSH
120347: CALL_OW 110
120351: PUSH
120352: LD_INT 71
120354: EQUAL
120355: NOT
120356: AND
120357: IFFALSE 120503
// begin attacking := false ;
120359: LD_ADDR_VAR 0 29
120363: PUSH
120364: LD_INT 0
120366: ST_TO_ADDR
// k := 5 ;
120367: LD_ADDR_VAR 0 9
120371: PUSH
120372: LD_INT 5
120374: ST_TO_ADDR
// if tmp < k then
120375: LD_VAR 0 14
120379: PUSH
120380: LD_VAR 0 9
120384: LESS
120385: IFFALSE 120397
// k := tmp ;
120387: LD_ADDR_VAR 0 9
120391: PUSH
120392: LD_VAR 0 14
120396: ST_TO_ADDR
// for j = 1 to k do
120397: LD_ADDR_VAR 0 8
120401: PUSH
120402: DOUBLE
120403: LD_INT 1
120405: DEC
120406: ST_TO_ADDR
120407: LD_VAR 0 9
120411: PUSH
120412: FOR_TO
120413: IFFALSE 120501
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
120415: LD_VAR 0 14
120419: PUSH
120420: LD_VAR 0 8
120424: ARRAY
120425: PUSH
120426: LD_VAR 0 14
120430: PPUSH
120431: LD_INT 58
120433: PUSH
120434: EMPTY
120435: LIST
120436: PPUSH
120437: CALL_OW 72
120441: IN
120442: NOT
120443: IFFALSE 120499
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120445: LD_VAR 0 4
120449: PUSH
120450: LD_VAR 0 7
120454: ARRAY
120455: PPUSH
120456: LD_VAR 0 14
120460: PUSH
120461: LD_VAR 0 8
120465: ARRAY
120466: PPUSH
120467: CALL_OW 115
// attacking := true ;
120471: LD_ADDR_VAR 0 29
120475: PUSH
120476: LD_INT 1
120478: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
120479: LD_VAR 0 4
120483: PUSH
120484: LD_VAR 0 7
120488: ARRAY
120489: PPUSH
120490: LD_INT 71
120492: PPUSH
120493: CALL_OW 109
// continue ;
120497: GO 120412
// end ; end ;
120499: GO 120412
120501: POP
120502: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
120503: LD_VAR 0 4
120507: PUSH
120508: LD_VAR 0 7
120512: ARRAY
120513: PPUSH
120514: CALL_OW 257
120518: PUSH
120519: LD_INT 8
120521: EQUAL
120522: PUSH
120523: LD_VAR 0 4
120527: PUSH
120528: LD_VAR 0 7
120532: ARRAY
120533: PPUSH
120534: CALL_OW 264
120538: PUSH
120539: LD_INT 28
120541: PUSH
120542: LD_INT 45
120544: PUSH
120545: LD_INT 7
120547: PUSH
120548: LD_INT 47
120550: PUSH
120551: EMPTY
120552: LIST
120553: LIST
120554: LIST
120555: LIST
120556: IN
120557: OR
120558: IFFALSE 120814
// begin attacking := false ;
120560: LD_ADDR_VAR 0 29
120564: PUSH
120565: LD_INT 0
120567: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
120568: LD_VAR 0 14
120572: PUSH
120573: LD_INT 1
120575: ARRAY
120576: PPUSH
120577: CALL_OW 266
120581: PUSH
120582: LD_INT 32
120584: PUSH
120585: LD_INT 31
120587: PUSH
120588: LD_INT 33
120590: PUSH
120591: LD_INT 4
120593: PUSH
120594: LD_INT 5
120596: PUSH
120597: EMPTY
120598: LIST
120599: LIST
120600: LIST
120601: LIST
120602: LIST
120603: IN
120604: IFFALSE 120790
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
120606: LD_ADDR_VAR 0 9
120610: PUSH
120611: LD_VAR 0 14
120615: PUSH
120616: LD_INT 1
120618: ARRAY
120619: PPUSH
120620: CALL_OW 266
120624: PPUSH
120625: LD_VAR 0 14
120629: PUSH
120630: LD_INT 1
120632: ARRAY
120633: PPUSH
120634: CALL_OW 250
120638: PPUSH
120639: LD_VAR 0 14
120643: PUSH
120644: LD_INT 1
120646: ARRAY
120647: PPUSH
120648: CALL_OW 251
120652: PPUSH
120653: LD_VAR 0 14
120657: PUSH
120658: LD_INT 1
120660: ARRAY
120661: PPUSH
120662: CALL_OW 254
120666: PPUSH
120667: LD_VAR 0 14
120671: PUSH
120672: LD_INT 1
120674: ARRAY
120675: PPUSH
120676: CALL_OW 248
120680: PPUSH
120681: LD_INT 0
120683: PPUSH
120684: CALL 67906 0 6
120688: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
120689: LD_ADDR_VAR 0 8
120693: PUSH
120694: LD_VAR 0 4
120698: PUSH
120699: LD_VAR 0 7
120703: ARRAY
120704: PPUSH
120705: LD_VAR 0 9
120709: PPUSH
120710: CALL 86649 0 2
120714: ST_TO_ADDR
// if j then
120715: LD_VAR 0 8
120719: IFFALSE 120788
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
120721: LD_VAR 0 8
120725: PUSH
120726: LD_INT 1
120728: ARRAY
120729: PPUSH
120730: LD_VAR 0 8
120734: PUSH
120735: LD_INT 2
120737: ARRAY
120738: PPUSH
120739: CALL_OW 488
120743: IFFALSE 120788
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
120745: LD_VAR 0 4
120749: PUSH
120750: LD_VAR 0 7
120754: ARRAY
120755: PPUSH
120756: LD_VAR 0 8
120760: PUSH
120761: LD_INT 1
120763: ARRAY
120764: PPUSH
120765: LD_VAR 0 8
120769: PUSH
120770: LD_INT 2
120772: ARRAY
120773: PPUSH
120774: CALL_OW 116
// attacking := true ;
120778: LD_ADDR_VAR 0 29
120782: PUSH
120783: LD_INT 1
120785: ST_TO_ADDR
// continue ;
120786: GO 118161
// end ; end else
120788: GO 120814
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120790: LD_VAR 0 4
120794: PUSH
120795: LD_VAR 0 7
120799: ARRAY
120800: PPUSH
120801: LD_VAR 0 14
120805: PUSH
120806: LD_INT 1
120808: ARRAY
120809: PPUSH
120810: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
120814: LD_VAR 0 4
120818: PUSH
120819: LD_VAR 0 7
120823: ARRAY
120824: PPUSH
120825: CALL_OW 265
120829: PUSH
120830: LD_INT 11
120832: EQUAL
120833: IFFALSE 121111
// begin k := 10 ;
120835: LD_ADDR_VAR 0 9
120839: PUSH
120840: LD_INT 10
120842: ST_TO_ADDR
// x := 0 ;
120843: LD_ADDR_VAR 0 10
120847: PUSH
120848: LD_INT 0
120850: ST_TO_ADDR
// if tmp < k then
120851: LD_VAR 0 14
120855: PUSH
120856: LD_VAR 0 9
120860: LESS
120861: IFFALSE 120873
// k := tmp ;
120863: LD_ADDR_VAR 0 9
120867: PUSH
120868: LD_VAR 0 14
120872: ST_TO_ADDR
// for j = k downto 1 do
120873: LD_ADDR_VAR 0 8
120877: PUSH
120878: DOUBLE
120879: LD_VAR 0 9
120883: INC
120884: ST_TO_ADDR
120885: LD_INT 1
120887: PUSH
120888: FOR_DOWNTO
120889: IFFALSE 120964
// begin if GetType ( tmp [ j ] ) = unit_human then
120891: LD_VAR 0 14
120895: PUSH
120896: LD_VAR 0 8
120900: ARRAY
120901: PPUSH
120902: CALL_OW 247
120906: PUSH
120907: LD_INT 1
120909: EQUAL
120910: IFFALSE 120962
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
120912: LD_VAR 0 4
120916: PUSH
120917: LD_VAR 0 7
120921: ARRAY
120922: PPUSH
120923: LD_VAR 0 14
120927: PUSH
120928: LD_VAR 0 8
120932: ARRAY
120933: PPUSH
120934: CALL 86903 0 2
// x := tmp [ j ] ;
120938: LD_ADDR_VAR 0 10
120942: PUSH
120943: LD_VAR 0 14
120947: PUSH
120948: LD_VAR 0 8
120952: ARRAY
120953: ST_TO_ADDR
// attacking := true ;
120954: LD_ADDR_VAR 0 29
120958: PUSH
120959: LD_INT 1
120961: ST_TO_ADDR
// end ; end ;
120962: GO 120888
120964: POP
120965: POP
// if not x then
120966: LD_VAR 0 10
120970: NOT
120971: IFFALSE 121111
// begin attacking := true ;
120973: LD_ADDR_VAR 0 29
120977: PUSH
120978: LD_INT 1
120980: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
120981: LD_VAR 0 4
120985: PUSH
120986: LD_VAR 0 7
120990: ARRAY
120991: PPUSH
120992: CALL_OW 250
120996: PPUSH
120997: LD_VAR 0 4
121001: PUSH
121002: LD_VAR 0 7
121006: ARRAY
121007: PPUSH
121008: CALL_OW 251
121012: PPUSH
121013: CALL_OW 546
121017: PUSH
121018: LD_INT 2
121020: ARRAY
121021: PUSH
121022: LD_VAR 0 14
121026: PUSH
121027: LD_INT 1
121029: ARRAY
121030: PPUSH
121031: CALL_OW 250
121035: PPUSH
121036: LD_VAR 0 14
121040: PUSH
121041: LD_INT 1
121043: ARRAY
121044: PPUSH
121045: CALL_OW 251
121049: PPUSH
121050: CALL_OW 546
121054: PUSH
121055: LD_INT 2
121057: ARRAY
121058: EQUAL
121059: IFFALSE 121087
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
121061: LD_VAR 0 4
121065: PUSH
121066: LD_VAR 0 7
121070: ARRAY
121071: PPUSH
121072: LD_VAR 0 14
121076: PUSH
121077: LD_INT 1
121079: ARRAY
121080: PPUSH
121081: CALL 86903 0 2
121085: GO 121111
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121087: LD_VAR 0 4
121091: PUSH
121092: LD_VAR 0 7
121096: ARRAY
121097: PPUSH
121098: LD_VAR 0 14
121102: PUSH
121103: LD_INT 1
121105: ARRAY
121106: PPUSH
121107: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
121111: LD_VAR 0 4
121115: PUSH
121116: LD_VAR 0 7
121120: ARRAY
121121: PPUSH
121122: CALL_OW 264
121126: PUSH
121127: LD_INT 29
121129: EQUAL
121130: IFFALSE 121496
// begin if WantsToAttack ( group [ i ] ) in bombed then
121132: LD_VAR 0 4
121136: PUSH
121137: LD_VAR 0 7
121141: ARRAY
121142: PPUSH
121143: CALL_OW 319
121147: PUSH
121148: LD_VAR 0 28
121152: IN
121153: IFFALSE 121157
// continue ;
121155: GO 118161
// k := 8 ;
121157: LD_ADDR_VAR 0 9
121161: PUSH
121162: LD_INT 8
121164: ST_TO_ADDR
// x := 0 ;
121165: LD_ADDR_VAR 0 10
121169: PUSH
121170: LD_INT 0
121172: ST_TO_ADDR
// if tmp < k then
121173: LD_VAR 0 14
121177: PUSH
121178: LD_VAR 0 9
121182: LESS
121183: IFFALSE 121195
// k := tmp ;
121185: LD_ADDR_VAR 0 9
121189: PUSH
121190: LD_VAR 0 14
121194: ST_TO_ADDR
// for j = 1 to k do
121195: LD_ADDR_VAR 0 8
121199: PUSH
121200: DOUBLE
121201: LD_INT 1
121203: DEC
121204: ST_TO_ADDR
121205: LD_VAR 0 9
121209: PUSH
121210: FOR_TO
121211: IFFALSE 121343
// begin if GetType ( tmp [ j ] ) = unit_building then
121213: LD_VAR 0 14
121217: PUSH
121218: LD_VAR 0 8
121222: ARRAY
121223: PPUSH
121224: CALL_OW 247
121228: PUSH
121229: LD_INT 3
121231: EQUAL
121232: IFFALSE 121341
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
121234: LD_VAR 0 14
121238: PUSH
121239: LD_VAR 0 8
121243: ARRAY
121244: PUSH
121245: LD_VAR 0 28
121249: IN
121250: NOT
121251: PUSH
121252: LD_VAR 0 14
121256: PUSH
121257: LD_VAR 0 8
121261: ARRAY
121262: PPUSH
121263: CALL_OW 313
121267: AND
121268: IFFALSE 121341
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121270: LD_VAR 0 4
121274: PUSH
121275: LD_VAR 0 7
121279: ARRAY
121280: PPUSH
121281: LD_VAR 0 14
121285: PUSH
121286: LD_VAR 0 8
121290: ARRAY
121291: PPUSH
121292: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
121296: LD_ADDR_VAR 0 28
121300: PUSH
121301: LD_VAR 0 28
121305: PPUSH
121306: LD_VAR 0 28
121310: PUSH
121311: LD_INT 1
121313: PLUS
121314: PPUSH
121315: LD_VAR 0 14
121319: PUSH
121320: LD_VAR 0 8
121324: ARRAY
121325: PPUSH
121326: CALL_OW 1
121330: ST_TO_ADDR
// attacking := true ;
121331: LD_ADDR_VAR 0 29
121335: PUSH
121336: LD_INT 1
121338: ST_TO_ADDR
// break ;
121339: GO 121343
// end ; end ;
121341: GO 121210
121343: POP
121344: POP
// if not attacking and f_attack_depot then
121345: LD_VAR 0 29
121349: NOT
121350: PUSH
121351: LD_VAR 0 25
121355: AND
121356: IFFALSE 121451
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
121358: LD_ADDR_VAR 0 13
121362: PUSH
121363: LD_VAR 0 14
121367: PPUSH
121368: LD_INT 2
121370: PUSH
121371: LD_INT 30
121373: PUSH
121374: LD_INT 0
121376: PUSH
121377: EMPTY
121378: LIST
121379: LIST
121380: PUSH
121381: LD_INT 30
121383: PUSH
121384: LD_INT 1
121386: PUSH
121387: EMPTY
121388: LIST
121389: LIST
121390: PUSH
121391: EMPTY
121392: LIST
121393: LIST
121394: LIST
121395: PPUSH
121396: CALL_OW 72
121400: ST_TO_ADDR
// if z then
121401: LD_VAR 0 13
121405: IFFALSE 121451
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
121407: LD_VAR 0 4
121411: PUSH
121412: LD_VAR 0 7
121416: ARRAY
121417: PPUSH
121418: LD_VAR 0 13
121422: PPUSH
121423: LD_VAR 0 4
121427: PUSH
121428: LD_VAR 0 7
121432: ARRAY
121433: PPUSH
121434: CALL_OW 74
121438: PPUSH
121439: CALL_OW 115
// attacking := true ;
121443: LD_ADDR_VAR 0 29
121447: PUSH
121448: LD_INT 1
121450: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
121451: LD_VAR 0 4
121455: PUSH
121456: LD_VAR 0 7
121460: ARRAY
121461: PPUSH
121462: CALL_OW 256
121466: PUSH
121467: LD_INT 500
121469: LESS
121470: IFFALSE 121496
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121472: LD_VAR 0 4
121476: PUSH
121477: LD_VAR 0 7
121481: ARRAY
121482: PPUSH
121483: LD_VAR 0 14
121487: PUSH
121488: LD_INT 1
121490: ARRAY
121491: PPUSH
121492: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
121496: LD_VAR 0 4
121500: PUSH
121501: LD_VAR 0 7
121505: ARRAY
121506: PPUSH
121507: CALL_OW 264
121511: PUSH
121512: LD_INT 49
121514: EQUAL
121515: IFFALSE 121636
// begin if not HasTask ( group [ i ] ) then
121517: LD_VAR 0 4
121521: PUSH
121522: LD_VAR 0 7
121526: ARRAY
121527: PPUSH
121528: CALL_OW 314
121532: NOT
121533: IFFALSE 121636
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
121535: LD_ADDR_VAR 0 9
121539: PUSH
121540: LD_INT 81
121542: PUSH
121543: LD_VAR 0 4
121547: PUSH
121548: LD_VAR 0 7
121552: ARRAY
121553: PPUSH
121554: CALL_OW 255
121558: PUSH
121559: EMPTY
121560: LIST
121561: LIST
121562: PPUSH
121563: CALL_OW 69
121567: PPUSH
121568: LD_VAR 0 4
121572: PUSH
121573: LD_VAR 0 7
121577: ARRAY
121578: PPUSH
121579: CALL_OW 74
121583: ST_TO_ADDR
// if k then
121584: LD_VAR 0 9
121588: IFFALSE 121636
// if GetDistUnits ( group [ i ] , k ) > 10 then
121590: LD_VAR 0 4
121594: PUSH
121595: LD_VAR 0 7
121599: ARRAY
121600: PPUSH
121601: LD_VAR 0 9
121605: PPUSH
121606: CALL_OW 296
121610: PUSH
121611: LD_INT 10
121613: GREATER
121614: IFFALSE 121636
// ComMoveUnit ( group [ i ] , k ) ;
121616: LD_VAR 0 4
121620: PUSH
121621: LD_VAR 0 7
121625: ARRAY
121626: PPUSH
121627: LD_VAR 0 9
121631: PPUSH
121632: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
121636: LD_VAR 0 4
121640: PUSH
121641: LD_VAR 0 7
121645: ARRAY
121646: PPUSH
121647: CALL_OW 256
121651: PUSH
121652: LD_INT 250
121654: LESS
121655: PUSH
121656: LD_VAR 0 4
121660: PUSH
121661: LD_VAR 0 7
121665: ARRAY
121666: PUSH
121667: LD_INT 21
121669: PUSH
121670: LD_INT 2
121672: PUSH
121673: EMPTY
121674: LIST
121675: LIST
121676: PUSH
121677: LD_INT 23
121679: PUSH
121680: LD_INT 2
121682: PUSH
121683: EMPTY
121684: LIST
121685: LIST
121686: PUSH
121687: EMPTY
121688: LIST
121689: LIST
121690: PPUSH
121691: CALL_OW 69
121695: IN
121696: AND
121697: IFFALSE 121822
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
121699: LD_ADDR_VAR 0 9
121703: PUSH
121704: LD_OWVAR 3
121708: PUSH
121709: LD_VAR 0 4
121713: PUSH
121714: LD_VAR 0 7
121718: ARRAY
121719: DIFF
121720: PPUSH
121721: LD_VAR 0 4
121725: PUSH
121726: LD_VAR 0 7
121730: ARRAY
121731: PPUSH
121732: CALL_OW 74
121736: ST_TO_ADDR
// if not k then
121737: LD_VAR 0 9
121741: NOT
121742: IFFALSE 121746
// continue ;
121744: GO 118161
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
121746: LD_VAR 0 9
121750: PUSH
121751: LD_INT 81
121753: PUSH
121754: LD_VAR 0 4
121758: PUSH
121759: LD_VAR 0 7
121763: ARRAY
121764: PPUSH
121765: CALL_OW 255
121769: PUSH
121770: EMPTY
121771: LIST
121772: LIST
121773: PPUSH
121774: CALL_OW 69
121778: IN
121779: PUSH
121780: LD_VAR 0 9
121784: PPUSH
121785: LD_VAR 0 4
121789: PUSH
121790: LD_VAR 0 7
121794: ARRAY
121795: PPUSH
121796: CALL_OW 296
121800: PUSH
121801: LD_INT 5
121803: LESS
121804: AND
121805: IFFALSE 121822
// ComAutodestruct ( group [ i ] ) ;
121807: LD_VAR 0 4
121811: PUSH
121812: LD_VAR 0 7
121816: ARRAY
121817: PPUSH
121818: CALL 86801 0 1
// end ; if f_attack_depot then
121822: LD_VAR 0 25
121826: IFFALSE 121938
// begin k := 6 ;
121828: LD_ADDR_VAR 0 9
121832: PUSH
121833: LD_INT 6
121835: ST_TO_ADDR
// if tmp < k then
121836: LD_VAR 0 14
121840: PUSH
121841: LD_VAR 0 9
121845: LESS
121846: IFFALSE 121858
// k := tmp ;
121848: LD_ADDR_VAR 0 9
121852: PUSH
121853: LD_VAR 0 14
121857: ST_TO_ADDR
// for j = 1 to k do
121858: LD_ADDR_VAR 0 8
121862: PUSH
121863: DOUBLE
121864: LD_INT 1
121866: DEC
121867: ST_TO_ADDR
121868: LD_VAR 0 9
121872: PUSH
121873: FOR_TO
121874: IFFALSE 121936
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
121876: LD_VAR 0 8
121880: PPUSH
121881: CALL_OW 266
121885: PUSH
121886: LD_INT 0
121888: PUSH
121889: LD_INT 1
121891: PUSH
121892: EMPTY
121893: LIST
121894: LIST
121895: IN
121896: IFFALSE 121934
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121898: LD_VAR 0 4
121902: PUSH
121903: LD_VAR 0 7
121907: ARRAY
121908: PPUSH
121909: LD_VAR 0 14
121913: PUSH
121914: LD_VAR 0 8
121918: ARRAY
121919: PPUSH
121920: CALL_OW 115
// attacking := true ;
121924: LD_ADDR_VAR 0 29
121928: PUSH
121929: LD_INT 1
121931: ST_TO_ADDR
// break ;
121932: GO 121936
// end ;
121934: GO 121873
121936: POP
121937: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
121938: LD_VAR 0 4
121942: PUSH
121943: LD_VAR 0 7
121947: ARRAY
121948: PPUSH
121949: CALL_OW 302
121953: PUSH
121954: LD_VAR 0 29
121958: NOT
121959: AND
121960: IFFALSE 122282
// begin if GetTag ( group [ i ] ) = 71 then
121962: LD_VAR 0 4
121966: PUSH
121967: LD_VAR 0 7
121971: ARRAY
121972: PPUSH
121973: CALL_OW 110
121977: PUSH
121978: LD_INT 71
121980: EQUAL
121981: IFFALSE 122022
// begin if HasTask ( group [ i ] ) then
121983: LD_VAR 0 4
121987: PUSH
121988: LD_VAR 0 7
121992: ARRAY
121993: PPUSH
121994: CALL_OW 314
121998: IFFALSE 122004
// continue else
122000: GO 118161
122002: GO 122022
// SetTag ( group [ i ] , 0 ) ;
122004: LD_VAR 0 4
122008: PUSH
122009: LD_VAR 0 7
122013: ARRAY
122014: PPUSH
122015: LD_INT 0
122017: PPUSH
122018: CALL_OW 109
// end ; k := 8 ;
122022: LD_ADDR_VAR 0 9
122026: PUSH
122027: LD_INT 8
122029: ST_TO_ADDR
// x := 0 ;
122030: LD_ADDR_VAR 0 10
122034: PUSH
122035: LD_INT 0
122037: ST_TO_ADDR
// if tmp < k then
122038: LD_VAR 0 14
122042: PUSH
122043: LD_VAR 0 9
122047: LESS
122048: IFFALSE 122060
// k := tmp ;
122050: LD_ADDR_VAR 0 9
122054: PUSH
122055: LD_VAR 0 14
122059: ST_TO_ADDR
// for j = 1 to k do
122060: LD_ADDR_VAR 0 8
122064: PUSH
122065: DOUBLE
122066: LD_INT 1
122068: DEC
122069: ST_TO_ADDR
122070: LD_VAR 0 9
122074: PUSH
122075: FOR_TO
122076: IFFALSE 122174
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
122078: LD_VAR 0 14
122082: PUSH
122083: LD_VAR 0 8
122087: ARRAY
122088: PPUSH
122089: CALL_OW 247
122093: PUSH
122094: LD_INT 1
122096: EQUAL
122097: PUSH
122098: LD_VAR 0 14
122102: PUSH
122103: LD_VAR 0 8
122107: ARRAY
122108: PPUSH
122109: CALL_OW 256
122113: PUSH
122114: LD_INT 250
122116: LESS
122117: PUSH
122118: LD_VAR 0 20
122122: AND
122123: PUSH
122124: LD_VAR 0 20
122128: NOT
122129: PUSH
122130: LD_VAR 0 14
122134: PUSH
122135: LD_VAR 0 8
122139: ARRAY
122140: PPUSH
122141: CALL_OW 256
122145: PUSH
122146: LD_INT 250
122148: GREATEREQUAL
122149: AND
122150: OR
122151: AND
122152: IFFALSE 122172
// begin x := tmp [ j ] ;
122154: LD_ADDR_VAR 0 10
122158: PUSH
122159: LD_VAR 0 14
122163: PUSH
122164: LD_VAR 0 8
122168: ARRAY
122169: ST_TO_ADDR
// break ;
122170: GO 122174
// end ;
122172: GO 122075
122174: POP
122175: POP
// if x then
122176: LD_VAR 0 10
122180: IFFALSE 122204
// ComAttackUnit ( group [ i ] , x ) else
122182: LD_VAR 0 4
122186: PUSH
122187: LD_VAR 0 7
122191: ARRAY
122192: PPUSH
122193: LD_VAR 0 10
122197: PPUSH
122198: CALL_OW 115
122202: GO 122228
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
122204: LD_VAR 0 4
122208: PUSH
122209: LD_VAR 0 7
122213: ARRAY
122214: PPUSH
122215: LD_VAR 0 14
122219: PUSH
122220: LD_INT 1
122222: ARRAY
122223: PPUSH
122224: CALL_OW 115
// if not HasTask ( group [ i ] ) then
122228: LD_VAR 0 4
122232: PUSH
122233: LD_VAR 0 7
122237: ARRAY
122238: PPUSH
122239: CALL_OW 314
122243: NOT
122244: IFFALSE 122282
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
122246: LD_VAR 0 4
122250: PUSH
122251: LD_VAR 0 7
122255: ARRAY
122256: PPUSH
122257: LD_VAR 0 14
122261: PPUSH
122262: LD_VAR 0 4
122266: PUSH
122267: LD_VAR 0 7
122271: ARRAY
122272: PPUSH
122273: CALL_OW 74
122277: PPUSH
122278: CALL_OW 115
// end ; end ; end ;
122282: GO 118161
122284: POP
122285: POP
// wait ( 0 0$2 ) ;
122286: LD_INT 70
122288: PPUSH
122289: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
122293: LD_VAR 0 4
122297: NOT
122298: PUSH
122299: LD_VAR 0 4
122303: PUSH
122304: EMPTY
122305: EQUAL
122306: OR
122307: PUSH
122308: LD_INT 81
122310: PUSH
122311: LD_VAR 0 35
122315: PUSH
122316: EMPTY
122317: LIST
122318: LIST
122319: PPUSH
122320: CALL_OW 69
122324: NOT
122325: OR
122326: IFFALSE 118146
// end ;
122328: LD_VAR 0 2
122332: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
122333: LD_INT 0
122335: PPUSH
122336: PPUSH
122337: PPUSH
122338: PPUSH
122339: PPUSH
122340: PPUSH
// if not base or not mc_bases [ base ] or not solds then
122341: LD_VAR 0 1
122345: NOT
122346: PUSH
122347: LD_EXP 80
122351: PUSH
122352: LD_VAR 0 1
122356: ARRAY
122357: NOT
122358: OR
122359: PUSH
122360: LD_VAR 0 2
122364: NOT
122365: OR
122366: IFFALSE 122370
// exit ;
122368: GO 122924
// side := mc_sides [ base ] ;
122370: LD_ADDR_VAR 0 6
122374: PUSH
122375: LD_EXP 106
122379: PUSH
122380: LD_VAR 0 1
122384: ARRAY
122385: ST_TO_ADDR
// if not side then
122386: LD_VAR 0 6
122390: NOT
122391: IFFALSE 122395
// exit ;
122393: GO 122924
// for i in solds do
122395: LD_ADDR_VAR 0 7
122399: PUSH
122400: LD_VAR 0 2
122404: PUSH
122405: FOR_IN
122406: IFFALSE 122467
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
122408: LD_VAR 0 7
122412: PPUSH
122413: CALL_OW 310
122417: PPUSH
122418: CALL_OW 266
122422: PUSH
122423: LD_INT 32
122425: PUSH
122426: LD_INT 31
122428: PUSH
122429: EMPTY
122430: LIST
122431: LIST
122432: IN
122433: IFFALSE 122453
// solds := solds diff i else
122435: LD_ADDR_VAR 0 2
122439: PUSH
122440: LD_VAR 0 2
122444: PUSH
122445: LD_VAR 0 7
122449: DIFF
122450: ST_TO_ADDR
122451: GO 122465
// SetTag ( i , 18 ) ;
122453: LD_VAR 0 7
122457: PPUSH
122458: LD_INT 18
122460: PPUSH
122461: CALL_OW 109
122465: GO 122405
122467: POP
122468: POP
// if not solds then
122469: LD_VAR 0 2
122473: NOT
122474: IFFALSE 122478
// exit ;
122476: GO 122924
// repeat wait ( 0 0$2 ) ;
122478: LD_INT 70
122480: PPUSH
122481: CALL_OW 67
// enemy := mc_scan [ base ] ;
122485: LD_ADDR_VAR 0 4
122489: PUSH
122490: LD_EXP 103
122494: PUSH
122495: LD_VAR 0 1
122499: ARRAY
122500: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122501: LD_EXP 80
122505: PUSH
122506: LD_VAR 0 1
122510: ARRAY
122511: NOT
122512: PUSH
122513: LD_EXP 80
122517: PUSH
122518: LD_VAR 0 1
122522: ARRAY
122523: PUSH
122524: EMPTY
122525: EQUAL
122526: OR
122527: IFFALSE 122564
// begin for i in solds do
122529: LD_ADDR_VAR 0 7
122533: PUSH
122534: LD_VAR 0 2
122538: PUSH
122539: FOR_IN
122540: IFFALSE 122553
// ComStop ( i ) ;
122542: LD_VAR 0 7
122546: PPUSH
122547: CALL_OW 141
122551: GO 122539
122553: POP
122554: POP
// solds := [ ] ;
122555: LD_ADDR_VAR 0 2
122559: PUSH
122560: EMPTY
122561: ST_TO_ADDR
// exit ;
122562: GO 122924
// end ; for i in solds do
122564: LD_ADDR_VAR 0 7
122568: PUSH
122569: LD_VAR 0 2
122573: PUSH
122574: FOR_IN
122575: IFFALSE 122896
// begin if IsInUnit ( i ) then
122577: LD_VAR 0 7
122581: PPUSH
122582: CALL_OW 310
122586: IFFALSE 122597
// ComExitBuilding ( i ) ;
122588: LD_VAR 0 7
122592: PPUSH
122593: CALL_OW 122
// if GetLives ( i ) > 500 then
122597: LD_VAR 0 7
122601: PPUSH
122602: CALL_OW 256
122606: PUSH
122607: LD_INT 500
122609: GREATER
122610: IFFALSE 122663
// begin e := NearestUnitToUnit ( enemy , i ) ;
122612: LD_ADDR_VAR 0 5
122616: PUSH
122617: LD_VAR 0 4
122621: PPUSH
122622: LD_VAR 0 7
122626: PPUSH
122627: CALL_OW 74
122631: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
122632: LD_VAR 0 7
122636: PPUSH
122637: LD_VAR 0 5
122641: PPUSH
122642: CALL_OW 250
122646: PPUSH
122647: LD_VAR 0 5
122651: PPUSH
122652: CALL_OW 251
122656: PPUSH
122657: CALL_OW 114
// end else
122661: GO 122894
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
122663: LD_VAR 0 7
122667: PPUSH
122668: LD_EXP 80
122672: PUSH
122673: LD_VAR 0 1
122677: ARRAY
122678: PPUSH
122679: LD_INT 2
122681: PUSH
122682: LD_INT 30
122684: PUSH
122685: LD_INT 0
122687: PUSH
122688: EMPTY
122689: LIST
122690: LIST
122691: PUSH
122692: LD_INT 30
122694: PUSH
122695: LD_INT 1
122697: PUSH
122698: EMPTY
122699: LIST
122700: LIST
122701: PUSH
122702: LD_INT 30
122704: PUSH
122705: LD_INT 6
122707: PUSH
122708: EMPTY
122709: LIST
122710: LIST
122711: PUSH
122712: EMPTY
122713: LIST
122714: LIST
122715: LIST
122716: LIST
122717: PPUSH
122718: CALL_OW 72
122722: PPUSH
122723: LD_VAR 0 7
122727: PPUSH
122728: CALL_OW 74
122732: PPUSH
122733: CALL_OW 296
122737: PUSH
122738: LD_INT 10
122740: GREATER
122741: IFFALSE 122894
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
122743: LD_ADDR_VAR 0 8
122747: PUSH
122748: LD_EXP 80
122752: PUSH
122753: LD_VAR 0 1
122757: ARRAY
122758: PPUSH
122759: LD_INT 2
122761: PUSH
122762: LD_INT 30
122764: PUSH
122765: LD_INT 0
122767: PUSH
122768: EMPTY
122769: LIST
122770: LIST
122771: PUSH
122772: LD_INT 30
122774: PUSH
122775: LD_INT 1
122777: PUSH
122778: EMPTY
122779: LIST
122780: LIST
122781: PUSH
122782: LD_INT 30
122784: PUSH
122785: LD_INT 6
122787: PUSH
122788: EMPTY
122789: LIST
122790: LIST
122791: PUSH
122792: EMPTY
122793: LIST
122794: LIST
122795: LIST
122796: LIST
122797: PPUSH
122798: CALL_OW 72
122802: PPUSH
122803: LD_VAR 0 7
122807: PPUSH
122808: CALL_OW 74
122812: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
122813: LD_VAR 0 7
122817: PPUSH
122818: LD_VAR 0 8
122822: PPUSH
122823: CALL_OW 250
122827: PPUSH
122828: LD_INT 3
122830: PPUSH
122831: LD_INT 5
122833: PPUSH
122834: CALL_OW 272
122838: PPUSH
122839: LD_VAR 0 8
122843: PPUSH
122844: CALL_OW 251
122848: PPUSH
122849: LD_INT 3
122851: PPUSH
122852: LD_INT 5
122854: PPUSH
122855: CALL_OW 273
122859: PPUSH
122860: CALL_OW 111
// SetTag ( i , 0 ) ;
122864: LD_VAR 0 7
122868: PPUSH
122869: LD_INT 0
122871: PPUSH
122872: CALL_OW 109
// solds := solds diff i ;
122876: LD_ADDR_VAR 0 2
122880: PUSH
122881: LD_VAR 0 2
122885: PUSH
122886: LD_VAR 0 7
122890: DIFF
122891: ST_TO_ADDR
// continue ;
122892: GO 122574
// end ; end ;
122894: GO 122574
122896: POP
122897: POP
// until not solds or not enemy ;
122898: LD_VAR 0 2
122902: NOT
122903: PUSH
122904: LD_VAR 0 4
122908: NOT
122909: OR
122910: IFFALSE 122478
// MC_Reset ( base , 18 ) ;
122912: LD_VAR 0 1
122916: PPUSH
122917: LD_INT 18
122919: PPUSH
122920: CALL 27038 0 2
// end ;
122924: LD_VAR 0 3
122928: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
122929: LD_INT 0
122931: PPUSH
122932: PPUSH
122933: PPUSH
122934: PPUSH
122935: PPUSH
122936: PPUSH
122937: PPUSH
122938: PPUSH
122939: PPUSH
122940: PPUSH
122941: PPUSH
122942: PPUSH
122943: PPUSH
122944: PPUSH
122945: PPUSH
122946: PPUSH
122947: PPUSH
122948: PPUSH
122949: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
122950: LD_ADDR_VAR 0 12
122954: PUSH
122955: LD_EXP 80
122959: PUSH
122960: LD_VAR 0 1
122964: ARRAY
122965: PPUSH
122966: LD_INT 25
122968: PUSH
122969: LD_INT 3
122971: PUSH
122972: EMPTY
122973: LIST
122974: LIST
122975: PPUSH
122976: CALL_OW 72
122980: ST_TO_ADDR
// if mc_remote_driver [ base ] then
122981: LD_EXP 120
122985: PUSH
122986: LD_VAR 0 1
122990: ARRAY
122991: IFFALSE 123015
// mechs := mechs diff mc_remote_driver [ base ] ;
122993: LD_ADDR_VAR 0 12
122997: PUSH
122998: LD_VAR 0 12
123002: PUSH
123003: LD_EXP 120
123007: PUSH
123008: LD_VAR 0 1
123012: ARRAY
123013: DIFF
123014: ST_TO_ADDR
// for i in mechs do
123015: LD_ADDR_VAR 0 4
123019: PUSH
123020: LD_VAR 0 12
123024: PUSH
123025: FOR_IN
123026: IFFALSE 123061
// if GetTag ( i ) > 0 then
123028: LD_VAR 0 4
123032: PPUSH
123033: CALL_OW 110
123037: PUSH
123038: LD_INT 0
123040: GREATER
123041: IFFALSE 123059
// mechs := mechs diff i ;
123043: LD_ADDR_VAR 0 12
123047: PUSH
123048: LD_VAR 0 12
123052: PUSH
123053: LD_VAR 0 4
123057: DIFF
123058: ST_TO_ADDR
123059: GO 123025
123061: POP
123062: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
123063: LD_ADDR_VAR 0 8
123067: PUSH
123068: LD_EXP 80
123072: PUSH
123073: LD_VAR 0 1
123077: ARRAY
123078: PPUSH
123079: LD_INT 2
123081: PUSH
123082: LD_INT 25
123084: PUSH
123085: LD_INT 1
123087: PUSH
123088: EMPTY
123089: LIST
123090: LIST
123091: PUSH
123092: LD_INT 25
123094: PUSH
123095: LD_INT 5
123097: PUSH
123098: EMPTY
123099: LIST
123100: LIST
123101: PUSH
123102: LD_INT 25
123104: PUSH
123105: LD_INT 8
123107: PUSH
123108: EMPTY
123109: LIST
123110: LIST
123111: PUSH
123112: LD_INT 25
123114: PUSH
123115: LD_INT 9
123117: PUSH
123118: EMPTY
123119: LIST
123120: LIST
123121: PUSH
123122: EMPTY
123123: LIST
123124: LIST
123125: LIST
123126: LIST
123127: LIST
123128: PPUSH
123129: CALL_OW 72
123133: ST_TO_ADDR
// if not defenders and not solds then
123134: LD_VAR 0 2
123138: NOT
123139: PUSH
123140: LD_VAR 0 8
123144: NOT
123145: AND
123146: IFFALSE 123150
// exit ;
123148: GO 124920
// depot_under_attack := false ;
123150: LD_ADDR_VAR 0 16
123154: PUSH
123155: LD_INT 0
123157: ST_TO_ADDR
// sold_defenders := [ ] ;
123158: LD_ADDR_VAR 0 17
123162: PUSH
123163: EMPTY
123164: ST_TO_ADDR
// if mechs then
123165: LD_VAR 0 12
123169: IFFALSE 123322
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
123171: LD_ADDR_VAR 0 4
123175: PUSH
123176: LD_VAR 0 2
123180: PPUSH
123181: LD_INT 21
123183: PUSH
123184: LD_INT 2
123186: PUSH
123187: EMPTY
123188: LIST
123189: LIST
123190: PPUSH
123191: CALL_OW 72
123195: PUSH
123196: FOR_IN
123197: IFFALSE 123320
// begin if GetTag ( i ) <> 20 then
123199: LD_VAR 0 4
123203: PPUSH
123204: CALL_OW 110
123208: PUSH
123209: LD_INT 20
123211: NONEQUAL
123212: IFFALSE 123226
// SetTag ( i , 20 ) ;
123214: LD_VAR 0 4
123218: PPUSH
123219: LD_INT 20
123221: PPUSH
123222: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
123226: LD_VAR 0 4
123230: PPUSH
123231: CALL_OW 263
123235: PUSH
123236: LD_INT 1
123238: EQUAL
123239: PUSH
123240: LD_VAR 0 4
123244: PPUSH
123245: CALL_OW 311
123249: NOT
123250: AND
123251: IFFALSE 123318
// begin un := mechs [ 1 ] ;
123253: LD_ADDR_VAR 0 10
123257: PUSH
123258: LD_VAR 0 12
123262: PUSH
123263: LD_INT 1
123265: ARRAY
123266: ST_TO_ADDR
// ComExit ( un ) ;
123267: LD_VAR 0 10
123271: PPUSH
123272: CALL 91707 0 1
// AddComEnterUnit ( un , i ) ;
123276: LD_VAR 0 10
123280: PPUSH
123281: LD_VAR 0 4
123285: PPUSH
123286: CALL_OW 180
// SetTag ( un , 19 ) ;
123290: LD_VAR 0 10
123294: PPUSH
123295: LD_INT 19
123297: PPUSH
123298: CALL_OW 109
// mechs := mechs diff un ;
123302: LD_ADDR_VAR 0 12
123306: PUSH
123307: LD_VAR 0 12
123311: PUSH
123312: LD_VAR 0 10
123316: DIFF
123317: ST_TO_ADDR
// end ; end ;
123318: GO 123196
123320: POP
123321: POP
// if solds then
123322: LD_VAR 0 8
123326: IFFALSE 123385
// for i in solds do
123328: LD_ADDR_VAR 0 4
123332: PUSH
123333: LD_VAR 0 8
123337: PUSH
123338: FOR_IN
123339: IFFALSE 123383
// if not GetTag ( i ) then
123341: LD_VAR 0 4
123345: PPUSH
123346: CALL_OW 110
123350: NOT
123351: IFFALSE 123381
// begin defenders := defenders union i ;
123353: LD_ADDR_VAR 0 2
123357: PUSH
123358: LD_VAR 0 2
123362: PUSH
123363: LD_VAR 0 4
123367: UNION
123368: ST_TO_ADDR
// SetTag ( i , 18 ) ;
123369: LD_VAR 0 4
123373: PPUSH
123374: LD_INT 18
123376: PPUSH
123377: CALL_OW 109
// end ;
123381: GO 123338
123383: POP
123384: POP
// repeat wait ( 0 0$2 ) ;
123385: LD_INT 70
123387: PPUSH
123388: CALL_OW 67
// enemy := mc_scan [ base ] ;
123392: LD_ADDR_VAR 0 21
123396: PUSH
123397: LD_EXP 103
123401: PUSH
123402: LD_VAR 0 1
123406: ARRAY
123407: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
123408: LD_EXP 80
123412: PUSH
123413: LD_VAR 0 1
123417: ARRAY
123418: NOT
123419: PUSH
123420: LD_EXP 80
123424: PUSH
123425: LD_VAR 0 1
123429: ARRAY
123430: PUSH
123431: EMPTY
123432: EQUAL
123433: OR
123434: IFFALSE 123471
// begin for i in defenders do
123436: LD_ADDR_VAR 0 4
123440: PUSH
123441: LD_VAR 0 2
123445: PUSH
123446: FOR_IN
123447: IFFALSE 123460
// ComStop ( i ) ;
123449: LD_VAR 0 4
123453: PPUSH
123454: CALL_OW 141
123458: GO 123446
123460: POP
123461: POP
// defenders := [ ] ;
123462: LD_ADDR_VAR 0 2
123466: PUSH
123467: EMPTY
123468: ST_TO_ADDR
// exit ;
123469: GO 124920
// end ; for i in defenders do
123471: LD_ADDR_VAR 0 4
123475: PUSH
123476: LD_VAR 0 2
123480: PUSH
123481: FOR_IN
123482: IFFALSE 124380
// begin e := NearestUnitToUnit ( enemy , i ) ;
123484: LD_ADDR_VAR 0 13
123488: PUSH
123489: LD_VAR 0 21
123493: PPUSH
123494: LD_VAR 0 4
123498: PPUSH
123499: CALL_OW 74
123503: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
123504: LD_ADDR_VAR 0 7
123508: PUSH
123509: LD_EXP 80
123513: PUSH
123514: LD_VAR 0 1
123518: ARRAY
123519: PPUSH
123520: LD_INT 2
123522: PUSH
123523: LD_INT 30
123525: PUSH
123526: LD_INT 0
123528: PUSH
123529: EMPTY
123530: LIST
123531: LIST
123532: PUSH
123533: LD_INT 30
123535: PUSH
123536: LD_INT 1
123538: PUSH
123539: EMPTY
123540: LIST
123541: LIST
123542: PUSH
123543: EMPTY
123544: LIST
123545: LIST
123546: LIST
123547: PPUSH
123548: CALL_OW 72
123552: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
123553: LD_ADDR_VAR 0 16
123557: PUSH
123558: LD_VAR 0 7
123562: NOT
123563: PUSH
123564: LD_VAR 0 7
123568: PPUSH
123569: LD_INT 3
123571: PUSH
123572: LD_INT 24
123574: PUSH
123575: LD_INT 600
123577: PUSH
123578: EMPTY
123579: LIST
123580: LIST
123581: PUSH
123582: EMPTY
123583: LIST
123584: LIST
123585: PPUSH
123586: CALL_OW 72
123590: OR
123591: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
123592: LD_VAR 0 4
123596: PPUSH
123597: CALL_OW 247
123601: PUSH
123602: LD_INT 2
123604: DOUBLE
123605: EQUAL
123606: IFTRUE 123610
123608: GO 124006
123610: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
123611: LD_VAR 0 4
123615: PPUSH
123616: CALL_OW 256
123620: PUSH
123621: LD_INT 1000
123623: EQUAL
123624: PUSH
123625: LD_VAR 0 4
123629: PPUSH
123630: LD_VAR 0 13
123634: PPUSH
123635: CALL_OW 296
123639: PUSH
123640: LD_INT 40
123642: LESS
123643: PUSH
123644: LD_VAR 0 13
123648: PPUSH
123649: LD_EXP 105
123653: PUSH
123654: LD_VAR 0 1
123658: ARRAY
123659: PPUSH
123660: CALL_OW 308
123664: OR
123665: AND
123666: IFFALSE 123788
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
123668: LD_VAR 0 4
123672: PPUSH
123673: CALL_OW 262
123677: PUSH
123678: LD_INT 1
123680: EQUAL
123681: PUSH
123682: LD_VAR 0 4
123686: PPUSH
123687: CALL_OW 261
123691: PUSH
123692: LD_INT 30
123694: LESS
123695: AND
123696: PUSH
123697: LD_VAR 0 7
123701: AND
123702: IFFALSE 123772
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
123704: LD_VAR 0 4
123708: PPUSH
123709: LD_VAR 0 7
123713: PPUSH
123714: LD_VAR 0 4
123718: PPUSH
123719: CALL_OW 74
123723: PPUSH
123724: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
123728: LD_VAR 0 4
123732: PPUSH
123733: LD_VAR 0 7
123737: PPUSH
123738: LD_VAR 0 4
123742: PPUSH
123743: CALL_OW 74
123747: PPUSH
123748: CALL_OW 296
123752: PUSH
123753: LD_INT 6
123755: LESS
123756: IFFALSE 123770
// SetFuel ( i , 100 ) ;
123758: LD_VAR 0 4
123762: PPUSH
123763: LD_INT 100
123765: PPUSH
123766: CALL_OW 240
// end else
123770: GO 123786
// ComAttackUnit ( i , e ) ;
123772: LD_VAR 0 4
123776: PPUSH
123777: LD_VAR 0 13
123781: PPUSH
123782: CALL_OW 115
// end else
123786: GO 123889
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
123788: LD_VAR 0 13
123792: PPUSH
123793: LD_EXP 105
123797: PUSH
123798: LD_VAR 0 1
123802: ARRAY
123803: PPUSH
123804: CALL_OW 308
123808: NOT
123809: PUSH
123810: LD_VAR 0 4
123814: PPUSH
123815: LD_VAR 0 13
123819: PPUSH
123820: CALL_OW 296
123824: PUSH
123825: LD_INT 40
123827: GREATEREQUAL
123828: AND
123829: PUSH
123830: LD_VAR 0 4
123834: PPUSH
123835: CALL_OW 256
123839: PUSH
123840: LD_INT 650
123842: LESSEQUAL
123843: OR
123844: PUSH
123845: LD_VAR 0 4
123849: PPUSH
123850: LD_EXP 104
123854: PUSH
123855: LD_VAR 0 1
123859: ARRAY
123860: PPUSH
123861: CALL_OW 308
123865: NOT
123866: AND
123867: IFFALSE 123889
// ComMoveToArea ( i , mc_parking [ base ] ) ;
123869: LD_VAR 0 4
123873: PPUSH
123874: LD_EXP 104
123878: PUSH
123879: LD_VAR 0 1
123883: ARRAY
123884: PPUSH
123885: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
123889: LD_VAR 0 4
123893: PPUSH
123894: CALL_OW 256
123898: PUSH
123899: LD_INT 1000
123901: LESS
123902: PUSH
123903: LD_VAR 0 4
123907: PPUSH
123908: CALL_OW 263
123912: PUSH
123913: LD_INT 1
123915: EQUAL
123916: AND
123917: PUSH
123918: LD_VAR 0 4
123922: PPUSH
123923: CALL_OW 311
123927: AND
123928: PUSH
123929: LD_VAR 0 4
123933: PPUSH
123934: LD_EXP 104
123938: PUSH
123939: LD_VAR 0 1
123943: ARRAY
123944: PPUSH
123945: CALL_OW 308
123949: AND
123950: IFFALSE 124004
// begin mech := IsDrivenBy ( i ) ;
123952: LD_ADDR_VAR 0 9
123956: PUSH
123957: LD_VAR 0 4
123961: PPUSH
123962: CALL_OW 311
123966: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
123967: LD_VAR 0 9
123971: PPUSH
123972: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
123976: LD_VAR 0 9
123980: PPUSH
123981: LD_VAR 0 4
123985: PPUSH
123986: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
123990: LD_VAR 0 9
123994: PPUSH
123995: LD_VAR 0 4
123999: PPUSH
124000: CALL_OW 180
// end ; end ; unit_human :
124004: GO 124351
124006: LD_INT 1
124008: DOUBLE
124009: EQUAL
124010: IFTRUE 124014
124012: GO 124350
124014: POP
// begin b := IsInUnit ( i ) ;
124015: LD_ADDR_VAR 0 18
124019: PUSH
124020: LD_VAR 0 4
124024: PPUSH
124025: CALL_OW 310
124029: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
124030: LD_ADDR_VAR 0 19
124034: PUSH
124035: LD_VAR 0 18
124039: NOT
124040: PUSH
124041: LD_VAR 0 18
124045: PPUSH
124046: CALL_OW 266
124050: PUSH
124051: LD_INT 32
124053: PUSH
124054: LD_INT 31
124056: PUSH
124057: EMPTY
124058: LIST
124059: LIST
124060: IN
124061: OR
124062: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
124063: LD_VAR 0 18
124067: PPUSH
124068: CALL_OW 266
124072: PUSH
124073: LD_INT 5
124075: EQUAL
124076: PUSH
124077: LD_VAR 0 4
124081: PPUSH
124082: CALL_OW 257
124086: PUSH
124087: LD_INT 1
124089: PUSH
124090: LD_INT 2
124092: PUSH
124093: LD_INT 3
124095: PUSH
124096: LD_INT 4
124098: PUSH
124099: EMPTY
124100: LIST
124101: LIST
124102: LIST
124103: LIST
124104: IN
124105: AND
124106: IFFALSE 124143
// begin class := AllowSpecClass ( i ) ;
124108: LD_ADDR_VAR 0 20
124112: PUSH
124113: LD_VAR 0 4
124117: PPUSH
124118: CALL 55384 0 1
124122: ST_TO_ADDR
// if class then
124123: LD_VAR 0 20
124127: IFFALSE 124143
// ComChangeProfession ( i , class ) ;
124129: LD_VAR 0 4
124133: PPUSH
124134: LD_VAR 0 20
124138: PPUSH
124139: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
124143: LD_VAR 0 16
124147: PUSH
124148: LD_VAR 0 2
124152: PPUSH
124153: LD_INT 21
124155: PUSH
124156: LD_INT 2
124158: PUSH
124159: EMPTY
124160: LIST
124161: LIST
124162: PPUSH
124163: CALL_OW 72
124167: PUSH
124168: LD_INT 1
124170: LESSEQUAL
124171: OR
124172: PUSH
124173: LD_VAR 0 19
124177: AND
124178: PUSH
124179: LD_VAR 0 4
124183: PUSH
124184: LD_VAR 0 17
124188: IN
124189: NOT
124190: AND
124191: IFFALSE 124284
// begin if b then
124193: LD_VAR 0 18
124197: IFFALSE 124246
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
124199: LD_VAR 0 18
124203: PPUSH
124204: LD_VAR 0 21
124208: PPUSH
124209: LD_VAR 0 18
124213: PPUSH
124214: CALL_OW 74
124218: PPUSH
124219: CALL_OW 296
124223: PUSH
124224: LD_INT 10
124226: LESS
124227: PUSH
124228: LD_VAR 0 18
124232: PPUSH
124233: CALL_OW 461
124237: PUSH
124238: LD_INT 7
124240: NONEQUAL
124241: AND
124242: IFFALSE 124246
// continue ;
124244: GO 123481
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
124246: LD_ADDR_VAR 0 17
124250: PUSH
124251: LD_VAR 0 17
124255: PPUSH
124256: LD_VAR 0 17
124260: PUSH
124261: LD_INT 1
124263: PLUS
124264: PPUSH
124265: LD_VAR 0 4
124269: PPUSH
124270: CALL_OW 1
124274: ST_TO_ADDR
// ComExitBuilding ( i ) ;
124275: LD_VAR 0 4
124279: PPUSH
124280: CALL_OW 122
// end ; if sold_defenders then
124284: LD_VAR 0 17
124288: IFFALSE 124348
// if i in sold_defenders then
124290: LD_VAR 0 4
124294: PUSH
124295: LD_VAR 0 17
124299: IN
124300: IFFALSE 124348
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
124302: LD_VAR 0 4
124306: PPUSH
124307: CALL_OW 314
124311: NOT
124312: PUSH
124313: LD_VAR 0 4
124317: PPUSH
124318: LD_VAR 0 13
124322: PPUSH
124323: CALL_OW 296
124327: PUSH
124328: LD_INT 30
124330: LESS
124331: AND
124332: IFFALSE 124348
// ComAttackUnit ( i , e ) ;
124334: LD_VAR 0 4
124338: PPUSH
124339: LD_VAR 0 13
124343: PPUSH
124344: CALL_OW 115
// end ; end ; end ;
124348: GO 124351
124350: POP
// if IsDead ( i ) then
124351: LD_VAR 0 4
124355: PPUSH
124356: CALL_OW 301
124360: IFFALSE 124378
// defenders := defenders diff i ;
124362: LD_ADDR_VAR 0 2
124366: PUSH
124367: LD_VAR 0 2
124371: PUSH
124372: LD_VAR 0 4
124376: DIFF
124377: ST_TO_ADDR
// end ;
124378: GO 123481
124380: POP
124381: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
124382: LD_VAR 0 21
124386: NOT
124387: PUSH
124388: LD_VAR 0 2
124392: NOT
124393: OR
124394: PUSH
124395: LD_EXP 80
124399: PUSH
124400: LD_VAR 0 1
124404: ARRAY
124405: NOT
124406: OR
124407: IFFALSE 123385
// MC_Reset ( base , 18 ) ;
124409: LD_VAR 0 1
124413: PPUSH
124414: LD_INT 18
124416: PPUSH
124417: CALL 27038 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
124421: LD_ADDR_VAR 0 2
124425: PUSH
124426: LD_VAR 0 2
124430: PUSH
124431: LD_VAR 0 2
124435: PPUSH
124436: LD_INT 2
124438: PUSH
124439: LD_INT 25
124441: PUSH
124442: LD_INT 1
124444: PUSH
124445: EMPTY
124446: LIST
124447: LIST
124448: PUSH
124449: LD_INT 25
124451: PUSH
124452: LD_INT 5
124454: PUSH
124455: EMPTY
124456: LIST
124457: LIST
124458: PUSH
124459: LD_INT 25
124461: PUSH
124462: LD_INT 8
124464: PUSH
124465: EMPTY
124466: LIST
124467: LIST
124468: PUSH
124469: LD_INT 25
124471: PUSH
124472: LD_INT 9
124474: PUSH
124475: EMPTY
124476: LIST
124477: LIST
124478: PUSH
124479: EMPTY
124480: LIST
124481: LIST
124482: LIST
124483: LIST
124484: LIST
124485: PPUSH
124486: CALL_OW 72
124490: DIFF
124491: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
124492: LD_VAR 0 21
124496: NOT
124497: PUSH
124498: LD_VAR 0 2
124502: PPUSH
124503: LD_INT 21
124505: PUSH
124506: LD_INT 2
124508: PUSH
124509: EMPTY
124510: LIST
124511: LIST
124512: PPUSH
124513: CALL_OW 72
124517: AND
124518: IFFALSE 124856
// begin tmp := FilterByTag ( defenders , 19 ) ;
124520: LD_ADDR_VAR 0 11
124524: PUSH
124525: LD_VAR 0 2
124529: PPUSH
124530: LD_INT 19
124532: PPUSH
124533: CALL 88878 0 2
124537: ST_TO_ADDR
// if tmp then
124538: LD_VAR 0 11
124542: IFFALSE 124612
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
124544: LD_ADDR_VAR 0 11
124548: PUSH
124549: LD_VAR 0 11
124553: PPUSH
124554: LD_INT 25
124556: PUSH
124557: LD_INT 3
124559: PUSH
124560: EMPTY
124561: LIST
124562: LIST
124563: PPUSH
124564: CALL_OW 72
124568: ST_TO_ADDR
// if tmp then
124569: LD_VAR 0 11
124573: IFFALSE 124612
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
124575: LD_ADDR_EXP 92
124579: PUSH
124580: LD_EXP 92
124584: PPUSH
124585: LD_VAR 0 1
124589: PPUSH
124590: LD_EXP 92
124594: PUSH
124595: LD_VAR 0 1
124599: ARRAY
124600: PUSH
124601: LD_VAR 0 11
124605: UNION
124606: PPUSH
124607: CALL_OW 1
124611: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
124612: LD_VAR 0 1
124616: PPUSH
124617: LD_INT 19
124619: PPUSH
124620: CALL 27038 0 2
// repeat wait ( 0 0$1 ) ;
124624: LD_INT 35
124626: PPUSH
124627: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
124631: LD_EXP 80
124635: PUSH
124636: LD_VAR 0 1
124640: ARRAY
124641: NOT
124642: PUSH
124643: LD_EXP 80
124647: PUSH
124648: LD_VAR 0 1
124652: ARRAY
124653: PUSH
124654: EMPTY
124655: EQUAL
124656: OR
124657: IFFALSE 124694
// begin for i in defenders do
124659: LD_ADDR_VAR 0 4
124663: PUSH
124664: LD_VAR 0 2
124668: PUSH
124669: FOR_IN
124670: IFFALSE 124683
// ComStop ( i ) ;
124672: LD_VAR 0 4
124676: PPUSH
124677: CALL_OW 141
124681: GO 124669
124683: POP
124684: POP
// defenders := [ ] ;
124685: LD_ADDR_VAR 0 2
124689: PUSH
124690: EMPTY
124691: ST_TO_ADDR
// exit ;
124692: GO 124920
// end ; for i in defenders do
124694: LD_ADDR_VAR 0 4
124698: PUSH
124699: LD_VAR 0 2
124703: PUSH
124704: FOR_IN
124705: IFFALSE 124794
// begin if not IsInArea ( i , mc_parking [ base ] ) then
124707: LD_VAR 0 4
124711: PPUSH
124712: LD_EXP 104
124716: PUSH
124717: LD_VAR 0 1
124721: ARRAY
124722: PPUSH
124723: CALL_OW 308
124727: NOT
124728: IFFALSE 124752
// ComMoveToArea ( i , mc_parking [ base ] ) else
124730: LD_VAR 0 4
124734: PPUSH
124735: LD_EXP 104
124739: PUSH
124740: LD_VAR 0 1
124744: ARRAY
124745: PPUSH
124746: CALL_OW 113
124750: GO 124792
// if GetControl ( i ) = control_manual then
124752: LD_VAR 0 4
124756: PPUSH
124757: CALL_OW 263
124761: PUSH
124762: LD_INT 1
124764: EQUAL
124765: IFFALSE 124792
// if IsDrivenBy ( i ) then
124767: LD_VAR 0 4
124771: PPUSH
124772: CALL_OW 311
124776: IFFALSE 124792
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
124778: LD_VAR 0 4
124782: PPUSH
124783: CALL_OW 311
124787: PPUSH
124788: CALL_OW 121
// end ;
124792: GO 124704
124794: POP
124795: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
124796: LD_VAR 0 2
124800: PPUSH
124801: LD_INT 95
124803: PUSH
124804: LD_EXP 104
124808: PUSH
124809: LD_VAR 0 1
124813: ARRAY
124814: PUSH
124815: EMPTY
124816: LIST
124817: LIST
124818: PPUSH
124819: CALL_OW 72
124823: PUSH
124824: LD_VAR 0 2
124828: EQUAL
124829: PUSH
124830: LD_EXP 103
124834: PUSH
124835: LD_VAR 0 1
124839: ARRAY
124840: OR
124841: PUSH
124842: LD_EXP 80
124846: PUSH
124847: LD_VAR 0 1
124851: ARRAY
124852: NOT
124853: OR
124854: IFFALSE 124624
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
124856: LD_ADDR_EXP 102
124860: PUSH
124861: LD_EXP 102
124865: PPUSH
124866: LD_VAR 0 1
124870: PPUSH
124871: LD_VAR 0 2
124875: PPUSH
124876: LD_INT 21
124878: PUSH
124879: LD_INT 2
124881: PUSH
124882: EMPTY
124883: LIST
124884: LIST
124885: PPUSH
124886: CALL_OW 72
124890: PPUSH
124891: CALL_OW 1
124895: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
124896: LD_VAR 0 1
124900: PPUSH
124901: LD_INT 19
124903: PPUSH
124904: CALL 27038 0 2
// MC_Reset ( base , 20 ) ;
124908: LD_VAR 0 1
124912: PPUSH
124913: LD_INT 20
124915: PPUSH
124916: CALL 27038 0 2
// end ; end_of_file
124920: LD_VAR 0 3
124924: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
124925: LD_VAR 0 1
124929: PUSH
124930: LD_INT 200
124932: DOUBLE
124933: GREATEREQUAL
124934: IFFALSE 124942
124936: LD_INT 299
124938: DOUBLE
124939: LESSEQUAL
124940: IFTRUE 124944
124942: GO 124976
124944: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
124945: LD_VAR 0 1
124949: PPUSH
124950: LD_VAR 0 2
124954: PPUSH
124955: LD_VAR 0 3
124959: PPUSH
124960: LD_VAR 0 4
124964: PPUSH
124965: LD_VAR 0 5
124969: PPUSH
124970: CALL 112925 0 5
124974: GO 125053
124976: LD_INT 300
124978: DOUBLE
124979: GREATEREQUAL
124980: IFFALSE 124988
124982: LD_INT 399
124984: DOUBLE
124985: LESSEQUAL
124986: IFTRUE 124990
124988: GO 125052
124990: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
124991: LD_VAR 0 1
124995: PPUSH
124996: LD_VAR 0 2
125000: PPUSH
125001: LD_VAR 0 3
125005: PPUSH
125006: LD_VAR 0 4
125010: PPUSH
125011: LD_VAR 0 5
125015: PPUSH
125016: LD_VAR 0 6
125020: PPUSH
125021: LD_VAR 0 7
125025: PPUSH
125026: LD_VAR 0 8
125030: PPUSH
125031: LD_VAR 0 9
125035: PPUSH
125036: LD_VAR 0 10
125040: PPUSH
125041: LD_VAR 0 11
125045: PPUSH
125046: CALL 108913 0 11
125050: GO 125053
125052: POP
// end ;
125053: PPOPN 11
125055: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
125056: LD_VAR 0 1
125060: PPUSH
125061: LD_VAR 0 2
125065: PPUSH
125066: LD_VAR 0 3
125070: PPUSH
125071: LD_VAR 0 4
125075: PPUSH
125076: LD_VAR 0 5
125080: PPUSH
125081: CALL 112390 0 5
// end ; end_of_file
125085: PPOPN 5
125087: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
125088: LD_VAR 0 1
125092: PPUSH
125093: LD_VAR 0 2
125097: PPUSH
125098: LD_VAR 0 3
125102: PPUSH
125103: LD_VAR 0 4
125107: PPUSH
125108: LD_VAR 0 5
125112: PPUSH
125113: LD_VAR 0 6
125117: PPUSH
125118: CALL 96565 0 6
// end ;
125122: PPOPN 6
125124: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
125125: LD_INT 0
125127: PPUSH
// begin if not units then
125128: LD_VAR 0 1
125132: NOT
125133: IFFALSE 125137
// exit ;
125135: GO 125137
// end ;
125137: PPOPN 7
125139: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
125140: CALL 96452 0 0
// end ;
125144: PPOPN 1
125146: END
